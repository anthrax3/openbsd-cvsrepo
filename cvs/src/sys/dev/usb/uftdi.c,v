head	1.75;
access;
symbols
	OPENBSD_6_2_BASE:1.75
	OPENBSD_6_1:1.75.0.4
	OPENBSD_6_1_BASE:1.75
	OPENBSD_6_0:1.74.0.8
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.74.0.4
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.63.0.2
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.62.0.4
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.59.0.2
	OPENBSD_5_0_BASE:1.59
	OPENBSD_4_9:1.58.0.2
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.56.0.4
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.9
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.75
date	2016.12.12.04.35.04;	author jsg;	state Exp;
branches;
next	1.74;
commitid	zUla3DiGgClAqhFP;

1.74
date	2015.06.18.09.47.16;	author mpi;	state Exp;
branches;
next	1.73;
commitid	FRkic7oma2jQWv4O;

1.73
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.72;
commitid	p4LJxGKbi0BU2cG6;

1.72
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.71;
commitid	PSjXNz8dGohZ6ZSK;

1.71
date	2014.02.04.12.03.12;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.02.03.20.53.32;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2014.01.07.14.00.50;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.12.13.12.32.24;	author yuo;	state Exp;
branches;
next	1.67;

1.67
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.66;

1.66
date	2013.11.07.11.13.31;	author pirofti;	state Exp;
branches;
next	1.65;

1.65
date	2013.11.02.01.41.17;	author jeremy;	state Exp;
branches;
next	1.64;

1.64
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.63;

1.63
date	2012.09.11.16.04.44;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2011.10.28.01.45.55;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2011.10.20.16.37.36;	author mpf;	state Exp;
branches;
next	1.60;

1.60
date	2011.10.07.06.04.14;	author ckuethe;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.56;

1.56
date	2010.02.23.23.31.54;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2009.12.16.21.41.29;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2009.04.22.18.56.56;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.21.05.22.51;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.26.14.29.27;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.10.13.48.54;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.02.12.08.01;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2008.04.17.22.12.42;	author fkr;	state Exp;
branches;
next	1.46;

1.46
date	2008.03.18.12.24.19;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2008.02.22.12.42.40;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2007.11.11.02.14.24;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.09.19.12.39.21;	author pyr;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.03.12.40.31;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.07.23.51.51;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.10.20.45.26;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.16.06.28.25;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.11.14.53.11;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.11.14.38.46;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.26.18.57.00;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.24.03.26.05;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.13.22.32.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.17.07.39.44;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.08.04.29.57;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.01.08.25.39;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.08.02.47.30;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.30.14.36.28;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.13.22.13.55;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.11.07.17.58;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.09.16.54.35;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.08.15.26.22;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.04.01.01.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.19.00.33.26;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.29.03.01.48;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.10.02.56.53;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.18.00.59.16;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches
	1.3.2.1
	1.3.6.1;
next	1.2;

1.2
date	2001.02.20.04.15.28;	author nate;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.20.04.11.52;	author nate;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.21;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.43.50;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.05.19.22.24.07;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Match on the FTDI Suunto product id, from Kristaps Dzonsons who tested
this with a Suunto D6i dive computer.
@
text
@/*	$OpenBSD: uftdi.c,v 1.74 2015/06/18 09:47:16 mpi Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.14 2003/02/23 04:20:07 simonb Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * FTDI FT8U100AX serial adapter driver
 */

/*
 * XXX This driver will not support multiple serial ports.
 * XXX The ucom layer needs to be extended first.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/tty.h>

#include <dev/usb/usb.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#include <dev/usb/uftdireg.h>

#ifdef UFTDI_DEBUG
#define DPRINTF(x)	do { if (uftdidebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uftdidebug>(n)) printf x; } while (0)
int uftdidebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * These are the maximum number of bytes transferred per frame.
 * The output buffer size cannot be increased due to the size encoding.
 */
#define UFTDIIBUFSIZE 64
#define UFTDIOBUFSIZE 64

struct uftdi_softc {
	struct device		 sc_dev;		/* base device */
	struct usbd_device	*sc_udev;	/* device */
	struct usbd_interface	*sc_iface;	/* interface */

	enum uftdi_type		 sc_type;
	u_int			 sc_hdrlen;

	u_char			 sc_msr;
	u_char			 sc_lsr;

	struct device		*sc_subdev;

	u_int			 last_lcr;
};

void	uftdi_get_status(void *, int portno, u_char *lsr, u_char *msr);
void	uftdi_set(void *, int, int, int);
int	uftdi_param(void *, int, struct termios *);
int	uftdi_open(void *sc, int portno);
void	uftdi_read(void *sc, int portno, u_char **ptr,
			   u_int32_t *count);
void	uftdi_write(void *sc, int portno, u_char *to, u_char *from,
			    u_int32_t *count);
void	uftdi_break(void *sc, int portno, int onoff);
int	uftdi_8u232am_getrate(speed_t speed, int *rate);
int	uftdi_2232h_getrate(speed_t speed, int *rate);

struct ucom_methods uftdi_methods = {
	uftdi_get_status,
	uftdi_set,
	uftdi_param,
	NULL,
	uftdi_open,
	NULL,
	uftdi_read,
	uftdi_write,
};

int uftdi_match(struct device *, void *, void *);
void uftdi_attach(struct device *, struct device *, void *);
int uftdi_detach(struct device *, int);

struct cfdriver uftdi_cd = {
	NULL, "uftdi", DV_DULL
};

const struct cfattach uftdi_ca = {
	sizeof(struct uftdi_softc), uftdi_match, uftdi_attach, uftdi_detach
};

static const struct usb_devno uftdi_devs[] = {
	{ USB_VENDOR_ALTI2, USB_PRODUCT_ALTI2_NEPTUNE3 },
	{ USB_VENDOR_ANALOGDEVICES, USB_PRODUCT_ANALOGDEVICES_GNICE },
	{ USB_VENDOR_ANALOGDEVICES, USB_PRODUCT_ANALOGDEVICES_GNICEPLUS },
	{ USB_VENDOR_ATMEL, USB_PRODUCT_ATMEL_STK541 },
	{ USB_VENDOR_BAYER, USB_PRODUCT_BAYER_CONTOUR },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_232USB9M },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_485USB9F2W },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_485USB9F4W },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_485USBTB_2W },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_485USBTB_4W },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_TTL3USB9M },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_TTL5USB9M },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USO9ML2 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USO9ML2DR },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USO9ML2DR2 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USOPTL4 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USOPTL4DR },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USOPTL4DR2 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USOTL4 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USPTL4 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_USTL4 },
	{ USB_VENDOR_BBELECTR, USB_PRODUCT_BBELECTR_ZZ_PROG1 },
	{ USB_VENDOR_DRESDENELEC, USB_PRODUCT_DRESDENELEC_STB },
	{ USB_VENDOR_DRESDENELEC, USB_PRODUCT_DRESDENELEC_WHT },
	{ USB_VENDOR_ELEKTOR, USB_PRODUCT_ELEKTOR_FT323R },
	{ USB_VENDOR_EVOLUTION, USB_PRODUCT_EVOLUTION_ER1 },
	{ USB_VENDOR_EVOLUTION, USB_PRODUCT_EVOLUTION_RCM4_1 },
	{ USB_VENDOR_EVOLUTION, USB_PRODUCT_EVOLUTION_RCM4_2 },
	{ USB_VENDOR_FALCOM, USB_PRODUCT_FALCOM_SAMBA },
	{ USB_VENDOR_FALCOM, USB_PRODUCT_FALCOM_TWIST },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ACCESSO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ACG_HFDUAL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ACTROBOTS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ACTZWAVE },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_AMC232 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ARTEMIS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_5 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_7 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ASK_RDR4X7_8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ATK16 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ATK16C },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ATK16HR },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ATK16HRC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ATK16IC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_BCS_SE923 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CANDAPTER },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CANUSB },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_ICDU20 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_ICDU40 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_ICDU64 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_LOAD_N_GO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_MACHX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CCS_PRIME8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_CHAMELEON },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_COASTAL_TNCX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_DGQG },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_DMX4ALL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_DUSB },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ECLO_1WIRE },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ECO_PRO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_EISCOU },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_ALC8500 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_CLI7000 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_CSI8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_EM1000DL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_EM1010PC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_FEM },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_FHZ1000PC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_FHZ1300PC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_FM3RX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_FS20SIG },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_HS485 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_KL100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_MSM1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_PCD200 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_PCK100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_PPS7330 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_RFP500 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_T1100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_TFD128 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_TFM100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_TWS550 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UAD7 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UAD8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UDF77 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UIO88 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_ULA200 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UM100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UMS100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UO100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UR100 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_USI2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_USR },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_UTP8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS300PC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS444PC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS500 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS550 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS777 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_ELV_WS888 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FISCO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232RL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232_5 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT232_6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FT4232H },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_FTX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GAMMASCOUT },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_5 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_7 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_9 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_A },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_GUDE_B },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_HO820 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_HO870 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_APP70 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_PCMCIA },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_PEDO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_PICPRO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_PK1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_RS232MON },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IBS_US485 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IPLUS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_IPLUS2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_JTAGCABLEII },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_547 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_631 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_632 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_633 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_634 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_635 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_640 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_CFA_642 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_LK202_24 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_LK204_24 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_MTXO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LCD_MX200 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LINX_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LINX_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LINX_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LINX_MASTER2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LM3S_DEVEL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LM3S_EVAL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_LOCOBUFFER },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MATRIX_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MATRIX_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_DB9 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_IC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_KW },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_RS232 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_Y6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_Y8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_Y9 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MHAM_YS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MJS_SIRIUS_PC_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MJS_SIRIUS_PC_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_NXTCAM },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OCEANIC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OOCDLINK },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENDCC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENDCC_GATEWAY },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENDCC_SNIFFER },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENDCC_THROTTLE },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENPORT_13M },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENPORT_13S },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENPORT_13U },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_OPENRD },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PCDJ_DAC2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PIEGROUP_IR },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PROTEGO_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PROTEGO_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PROTEGO_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PROTEGO_R200 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_PYRAMID },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_R2000KU_RNG },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_RELAIS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_REU_TINY },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_0 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_5 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SCS_7 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SEMC_DSS20 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_2232C },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_2232L },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_232BM },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_8U100AX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_8U232AM },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SERIAL_8U232AM4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SPROG_II },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_SUUNTO },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_TERATRONIK_D2XX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_TERATRONIK_VCP },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_THORLABS },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_TIRA1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_TNCX },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_TURTELIZER_JTAG },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_UNICOM },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_UOPTBR },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_USBSERIAL },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_USBUIRT },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_USBX_707 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_VNHC },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_WESTREX_777 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_WESTREX_8900F },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_1 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_2 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_3 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_4 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_5 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_6 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_7 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_XSENS_8 },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_YEI_SC31 },
	{ USB_VENDOR_GNOTOMETRICS, USB_PRODUCT_GNOTOMETRICS_AURICAL },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_ID1 },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2000VR },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2000VT },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2C1 },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2C2 },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2D },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2VR },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP2VT },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP4000VR },
	{ USB_VENDOR_ICOM, USB_PRODUCT_ICOM_RP4000VT },
	{ USB_VENDOR_IDTECH, USB_PRODUCT_IDTECH_SERIAL },
	{ USB_VENDOR_INTERBIO, USB_PRODUCT_INTERBIO_IOBOARD },
	{ USB_VENDOR_INTERBIO, USB_PRODUCT_INTERBIO_MINIIOBOARD },
	{ USB_VENDOR_INTERBIO, USB_PRODUCT_INTERBIO_MINIIOBOARD2 },
	{ USB_VENDOR_INTREPIDCS, USB_PRODUCT_INTREPIDCS_NEOVI },
	{ USB_VENDOR_INTREPIDCS, USB_PRODUCT_INTREPIDCS_VALUECAN },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_FT232R },
	{ USB_VENDOR_JETI, USB_PRODUCT_JETI_SPC1201 },
	{ USB_VENDOR_KOBIL, USB_PRODUCT_KOBIL_B1 },
	{ USB_VENDOR_KOBIL, USB_PRODUCT_KOBIL_KAAN },
	{ USB_VENDOR_LARSENBRUSGAARD, USB_PRODUCT_LARSENBRUSGAARD_ALTITRACK },
	{ USB_VENDOR_MARVELL, USB_PRODUCT_MARVELL_SHEEVAPLUG },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0100 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0101 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0102 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0103 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0104 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0105 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0106 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0107 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0108 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0109 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_010F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0110 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0111 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0112 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0113 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0114 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0115 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0116 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0117 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0118 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0119 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_011F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0120 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0121 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0122 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0123 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0124 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0125 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0126 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0127 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0128 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0129 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_012F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0130 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0131 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0132 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0133 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0134 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0135 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0136 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0137 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0138 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0139 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_013F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0140 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0141 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0142 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0143 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0144 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0145 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0146 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0147 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0148 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0149 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_014F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0150 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0151 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0152 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0153 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0154 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0155 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0156 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0157 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0158 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0159 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_015F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0160 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0161 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0162 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0163 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0164 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0165 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0166 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0167 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0168 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0169 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_016F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0170 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0171 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0172 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0173 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0174 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0175 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0176 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0177 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0178 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0179 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_017F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0180 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0181 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0182 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0183 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0184 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0185 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0186 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0187 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0188 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0189 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_018F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0190 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0191 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0192 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0193 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0194 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0195 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0196 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0197 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0198 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_0199 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019A },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019B },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019C },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019D },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019E },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_019F },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01A9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AD },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01AF },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01B9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BD },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01BF },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01C9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CD },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01CF },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01D9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DD },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01DF },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01E9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01EA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01EB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01EC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01ED },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01EE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01EF },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F0 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F1 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F2 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F3 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F4 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F5 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F6 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F7 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F8 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01F9 },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FA },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FB },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FC },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FD },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FE },
	{ USB_VENDOR_MATRIXORB, USB_PRODUCT_MATRIXORB_LCD_01FF },
	{ USB_VENDOR_MECANIQUE, USB_PRODUCT_MECANIQUE_TELLSTICK },
	{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_PCOPRS1 },
	{ USB_VENDOR_MOBILITY, USB_PRODUCT_MOBILITY_ED200H },
	{ USB_VENDOR_OCT, USB_PRODUCT_OCT_US2308 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_AD4USB },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_AP485_1 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_AP485_2 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_DRAK5 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_DRAK6 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_GOLIATH_MSR },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_GOLIATH_MUX },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_IRAMP },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_LEC },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_MUC },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO101 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO216 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO22 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO303 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO332 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO44 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO603 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_QUIDO88 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB232 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB422_1 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB422_2 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB485C },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB485S },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB485_1 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SB485_2 },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SERIAL },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_SIMUKEY },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_STAVOVY },
	{ USB_VENDOR_PAPOUCH, USB_PRODUCT_PAPOUCH_TMU },
	{ USB_VENDOR_POSIFLEX, USB_PRODUCT_POSIFLEX_PP7000_1 },
	{ USB_VENDOR_POSIFLEX, USB_PRODUCT_POSIFLEX_PP7000_2 },
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60F },
	{ USB_VENDOR_RTSYSTEMS, USB_PRODUCT_RTSYSTEMS_CT57B },
	{ USB_VENDOR_SACOM, USB_PRODUCT_SACOM_USB485BL },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2101 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2102 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2103 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2104 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2106 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2201_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2201_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2202_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2202_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2203_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2203_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2401_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2401_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2401_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2401_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2402_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2402_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2402_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2402_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2403_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2403_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2403_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2403_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_5 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_6 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_7 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2801_8 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_5 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_6 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_7 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2802_8 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_1 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_2 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_3 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_4 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_5 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_6 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_7 },
	{ USB_VENDOR_SEALEVEL, USB_PRODUCT_SEALEVEL_2803_8 },
	{ USB_VENDOR_STOLLMANN, USB_PRODUCT_STOLLMANN_ISDN_TA_USBA },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_174 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_175 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_330 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_435 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_556 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_580 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_845 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_SERIAL_1 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_SERIAL_2 },
	{ USB_VENDOR_TESTO, USB_PRODUCT_TESTO_SERVICE },
	{ USB_VENDOR_THURLBY, USB_PRODUCT_THURLBY_QL355P },
	{ USB_VENDOR_TML, USB_PRODUCT_TML_SERIAL },
	{ USB_VENDOR_UNKNOWN5, USB_PRODUCT_UNKNOWN5_NF_RIC }
};

int
uftdi_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	if (usb_lookup(uftdi_devs, uaa->vendor, uaa->product) == NULL)
		return (UMATCH_NONE);

	/* JTAG on USB interface 0 */
	if (uaa->vendor == USB_VENDOR_FTDI &&
	    uaa->product == USB_PRODUCT_FTDI_OPENRD &&
	    uaa->ifaceno == 0)
		return (UMATCH_NONE);

	return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);
}

void
uftdi_attach(struct device *parent, struct device *self, void *aux)
{
	struct uftdi_softc *sc = (struct uftdi_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	char *devname = sc->sc_dev.dv_xname;
	struct ucom_attach_args uca;
	int i;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;

	if (uaa->release < 0x0200) {
		sc->sc_type = UFTDI_TYPE_SIO;
		sc->sc_hdrlen = 1;
	} else if (uaa->release == 0x0700  || uaa->release == 0x0800) {
		sc->sc_type = UFTDI_TYPE_2232H;
		sc->sc_hdrlen = 0;
	} else {
		sc->sc_type = UFTDI_TYPE_8U232AM;
		sc->sc_hdrlen = 0;
	}

	uca.bulkin = uca.bulkout = -1;
	id = usbd_get_interface_descriptor(sc->sc_iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		int addr, dir, attr;
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: could not read endpoint descriptor\n",
			    devname);
			goto bad;
		}

		addr = ed->bEndpointAddress;
		dir = UE_GET_DIR(ed->bEndpointAddress);
		attr = ed->bmAttributes & UE_XFERTYPE;
		if (dir == UE_DIR_IN && attr == UE_BULK) {
			uca.bulkin = addr;
			uca.ibufsize = (UGETW(ed->wMaxPacketSize) > 0) ?
			    UGETW(ed->wMaxPacketSize) : UFTDIIBUFSIZE;
		} else if (dir == UE_DIR_OUT && attr == UE_BULK) {
			uca.bulkout = addr;
			uca.obufsize = (UGETW(ed->wMaxPacketSize) > 0) ?
			    UGETW(ed->wMaxPacketSize) : UFTDIOBUFSIZE;
			uca.obufsize-= sc->sc_hdrlen;
		} else {
			printf("%s: unexpected endpoint\n", devname);
			goto bad;
		}
	}
	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
		       sc->sc_dev.dv_xname);
		goto bad;
	}
	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
		       sc->sc_dev.dv_xname);
		goto bad;
	}

	if (uaa->iface == NULL)
		uca.portno = FTDI_PIT_SIOA;
	else
		uca.portno = FTDI_PIT_SIOA + id->bInterfaceNumber;
	/* bulkin, bulkout set above */
	uca.ibufsizepad = uca.ibufsize;
	uca.opkthdrlen = sc->sc_hdrlen;
	uca.device = sc->sc_udev;
	uca.iface = sc->sc_iface;
	uca.methods = &uftdi_methods;
	uca.arg = sc;
	uca.info = NULL;

	DPRINTF(("uftdi: in=0x%x out=0x%x\n", uca.bulkin, uca.bulkout));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);

	return;

bad:
	DPRINTF(("uftdi_attach: ATTACH ERROR\n"));
	usbd_deactivate(sc->sc_udev);
}

int
uftdi_detach(struct device *self, int flags)
{
	struct uftdi_softc *sc = (struct uftdi_softc *)self;

	DPRINTF(("uftdi_detach: sc=%p flags=%d\n", sc, flags));
	if (sc->sc_subdev != NULL) {
		config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (0);
}

int
uftdi_open(void *vsc, int portno)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	usbd_status err;
	struct termios t;

	DPRINTF(("uftdi_open: sc=%p\n", sc));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	/* Perform a full reset on the device */
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_RESET;
	USETW(req.wValue, FTDI_SIO_RESET_SIO);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	/* Set 9600 baud, 2 stop bits, no parity, 8 bits */
	t.c_ospeed = 9600;
	t.c_cflag = CSTOPB | CS8;
	(void)uftdi_param(sc, portno, &t);

	/* Turn on RTS/CTS flow control */
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_FLOW_CTRL;
	USETW(req.wValue, 0);
	USETW2(req.wIndex, FTDI_SIO_RTS_CTS_HS, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	return (0);
}

void
uftdi_read(void *vsc, int portno, u_char **ptr, u_int32_t *count)
{
	struct uftdi_softc *sc = vsc;
	u_char msr, lsr;

	DPRINTFN(15,("uftdi_read: sc=%p, port=%d count=%d\n", sc, portno,
		     *count));

	msr = FTDI_GET_MSR(*ptr);
	lsr = FTDI_GET_LSR(*ptr);

#ifdef UFTDI_DEBUG
	if (*count != 2)
		DPRINTFN(10,("uftdi_read: sc=%p, port=%d count=%d data[0]="
			    "0x%02x\n", sc, portno, *count, (*ptr)[2]));
#endif

	if (sc->sc_msr != msr ||
	    (sc->sc_lsr & FTDI_LSR_MASK) != (lsr & FTDI_LSR_MASK)) {
		DPRINTF(("uftdi_read: status change msr=0x%02x(0x%02x) "
			 "lsr=0x%02x(0x%02x)\n", msr, sc->sc_msr,
			 lsr, sc->sc_lsr));
		sc->sc_msr = msr;
		sc->sc_lsr = lsr;
		ucom_status_change((struct ucom_softc *)sc->sc_subdev);
	}

	/* Pick up status and adjust data part. */
	*ptr += 2;
	*count -= 2;
}

void
uftdi_write(void *vsc, int portno, u_char *to, u_char *from, u_int32_t *count)
{
	struct uftdi_softc *sc = vsc;

	DPRINTFN(10,("uftdi_write: sc=%p, port=%d count=%u data[0]=0x%02x\n",
		     vsc, portno, *count, from[0]));

	/* Make length tag and copy data */
	if (sc->sc_hdrlen > 0)
		*to = FTDI_OUT_TAG(*count, portno);

	memcpy(to + sc->sc_hdrlen, from, *count);
	*count += sc->sc_hdrlen;
}

void
uftdi_set(void *vsc, int portno, int reg, int onoff)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	int ctl;

	DPRINTF(("uftdi_set: sc=%p, port=%d reg=%d onoff=%d\n", vsc, portno,
		 reg, onoff));

	switch (reg) {
	case UCOM_SET_DTR:
		ctl = onoff ? FTDI_SIO_SET_DTR_HIGH : FTDI_SIO_SET_DTR_LOW;
		break;
	case UCOM_SET_RTS:
		ctl = onoff ? FTDI_SIO_SET_RTS_HIGH : FTDI_SIO_SET_RTS_LOW;
		break;
	case UCOM_SET_BREAK:
		uftdi_break(sc, portno, onoff);
		return;
	default:
		return;
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_MODEM_CTRL;
	USETW(req.wValue, ctl);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	DPRINTFN(2,("uftdi_set: reqtype=0x%02x req=0x%02x value=0x%04x "
		    "index=0x%04x len=%d\n", req.bmRequestType, req.bRequest,
		    UGETW(req.wValue), UGETW(req.wIndex), UGETW(req.wLength)));
	(void)usbd_do_request(sc->sc_udev, &req, NULL);
}

int
uftdi_param(void *vsc, int portno, struct termios *t)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	usbd_status err;
	int rate, data, flow;

	DPRINTF(("uftdi_param: sc=%p\n", sc));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	switch (sc->sc_type) {
	case UFTDI_TYPE_SIO:
		switch (t->c_ospeed) {
		case 300: rate = ftdi_sio_b300; break;
		case 600: rate = ftdi_sio_b600; break;
		case 1200: rate = ftdi_sio_b1200; break;
		case 2400: rate = ftdi_sio_b2400; break;
		case 4800: rate = ftdi_sio_b4800; break;
		case 9600: rate = ftdi_sio_b9600; break;
		case 19200: rate = ftdi_sio_b19200; break;
		case 38400: rate = ftdi_sio_b38400; break;
		case 57600: rate = ftdi_sio_b57600; break;
		case 115200: rate = ftdi_sio_b115200; break;
		default:
			return (EINVAL);
		}
		break;

	case UFTDI_TYPE_8U232AM:
		if (uftdi_8u232am_getrate(t->c_ospeed, &rate) == -1)
			return (EINVAL);
		break;
	case UFTDI_TYPE_2232H:
		if (uftdi_2232h_getrate(t->c_ospeed, &rate) == -1)
			 return (EINVAL);
		break;
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_BAUD_RATE;
	USETW(req.wValue, rate);
	USETW(req.wIndex, ((rate >> 8) & 0xFF00) | portno);
	USETW(req.wLength, 0);
	DPRINTFN(2,("uftdi_param: reqtype=0x%02x req=0x%02x value=0x%04x "
		    "index=0x%04x len=%d\n", req.bmRequestType, req.bRequest,
		    UGETW(req.wValue), UGETW(req.wIndex), UGETW(req.wLength)));
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	if (ISSET(t->c_cflag, CSTOPB))
		data = FTDI_SIO_SET_DATA_STOP_BITS_2;
	else
		data = FTDI_SIO_SET_DATA_STOP_BITS_1;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			data |= FTDI_SIO_SET_DATA_PARITY_ODD;
		else
			data |= FTDI_SIO_SET_DATA_PARITY_EVEN;
	} else
		data |= FTDI_SIO_SET_DATA_PARITY_NONE;
	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		data |= FTDI_SIO_SET_DATA_BITS(5);
		break;
	case CS6:
		data |= FTDI_SIO_SET_DATA_BITS(6);
		break;
	case CS7:
		data |= FTDI_SIO_SET_DATA_BITS(7);
		break;
	case CS8:
		data |= FTDI_SIO_SET_DATA_BITS(8);
		break;
	}
	sc->last_lcr = data;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	DPRINTFN(2,("uftdi_param: reqtype=0x%02x req=0x%02x value=0x%04x "
		    "index=0x%04x len=%d\n", req.bmRequestType, req.bRequest,
		    UGETW(req.wValue), UGETW(req.wIndex), UGETW(req.wLength)));
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	if (ISSET(t->c_cflag, CRTSCTS)) {
		flow = FTDI_SIO_RTS_CTS_HS;
		USETW(req.wValue, 0);
	} else if (ISSET(t->c_iflag, IXON|IXOFF)) {
		flow = FTDI_SIO_XON_XOFF_HS;
		USETW2(req.wValue, t->c_cc[VSTOP], t->c_cc[VSTART]);
	} else {
		flow = FTDI_SIO_DISABLE_FLOW_CTRL;
		USETW(req.wValue, 0);
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_FLOW_CTRL;
	USETW2(req.wIndex, flow, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	return (0);
}

void
uftdi_get_status(void *vsc, int portno, u_char *lsr, u_char *msr)
{
	struct uftdi_softc *sc = vsc;

	DPRINTF(("uftdi_status: msr=0x%02x lsr=0x%02x\n",
		 sc->sc_msr, sc->sc_lsr));

	if (msr != NULL)
		*msr = sc->sc_msr;
	if (lsr != NULL)
		*lsr = sc->sc_lsr;
}

void
uftdi_break(void *vsc, int portno, int onoff)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	int data;

	DPRINTF(("uftdi_break: sc=%p, port=%d onoff=%d\n", vsc, portno,
		  onoff));

	if (onoff) {
		data = sc->last_lcr | FTDI_SIO_SET_BREAK;
	} else {
		data = sc->last_lcr;
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	(void)usbd_do_request(sc->sc_udev, &req, NULL);
}

int
uftdi_8u232am_getrate(speed_t speed, int *rate)
{
	/* Table of the nearest even powers-of-2 for values 0..15. */
	static const unsigned char roundoff[16] = {
		0, 2, 2, 4,  4,  4,  8,  8,
		8, 8, 8, 8, 16, 16, 16, 16,
	};

	unsigned int d, freq;
	int result;

	if (speed <= 0)
		return (-1);

	/* Special cases for 2M and 3M. */
	if (speed >= 3000000 * 100 / 103 &&
	    speed <= 3000000 * 100 / 97) {
		result = 0;
		goto done;
	}
	if (speed >= 2000000 * 100 / 103 &&
	    speed <= 2000000 * 100 / 97) {
		result = 1;
		goto done;
	}

	d = (FTDI_8U232AM_FREQ << 4) / speed;
	d = (d & ~15) + roundoff[d & 15];

	if (d < FTDI_8U232AM_MIN_DIV)
		d = FTDI_8U232AM_MIN_DIV;
	else if (d > FTDI_8U232AM_MAX_DIV)
		d = FTDI_8U232AM_MAX_DIV;

	/* 
	 * Calculate the frequency needed for d to exactly divide down
	 * to our target speed, and check that the actual frequency is
	 * within 3% of this.
	 */
	freq = speed * d;
	if (freq < (quad_t)(FTDI_8U232AM_FREQ << 4) * 100 / 103 ||
	    freq > (quad_t)(FTDI_8U232AM_FREQ << 4) * 100 / 97)
		return (-1);

	/* 
	 * Pack the divisor into the resultant value.  The lower
	 * 14-bits hold the integral part, while the upper 2 bits
	 * encode the fractional component: either 0, 0.5, 0.25, or
	 * 0.125.
	 */
	result = d >> 4;
	if (d & 8)
		result |= 0x4000;
	else if (d & 4)
		result |= 0x8000;
	else if (d & 2)
		result |= 0xc000;

done:
	*rate = result;
	return (0);
}

int
uftdi_2232h_getrate(speed_t speed, int *rate)
{
	char sub[8] = {0, 3, 2, 4, 1, 5, 6, 7};
	int n = (FTDI_2232H_FREQ << 3) / speed;
	int s = n & 7;
	int result = (n >> 3) | (sub[s] << 14);
	int resultspeed, accuracy;

	/* Special cases */
	if (result == 1)
		result = 0;
	else if (result == 0x4001)
		result = 1;

	/* Check if resulting baud rate is within 3%. */
	if (result == 0)
		goto done;
	resultspeed = (FTDI_2232H_FREQ << 3) /
	    (((result & 0x00003FFF) << 3) | s);
	accuracy = (abs(speed - resultspeed) * 100) / speed;
	if (accuracy > 3)
		return -1;

done:
	result|= 0x00020000; /* Set this bit to turn off a divide by 2.5 */
	*rate = result;
	return 0;
}
@


1.74
log
@Only match devices with a valid configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.73 2015/03/14 03:38:49 jsg Exp $ 	*/
d334 1
@


1.73
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.72 2014/07/12 20:26:33 mpi Exp $ 	*/
a67 4
#define UFTDI_CONFIG_INDEX	0
#define UFTDI_IFACE_INDEX	0


d741 3
a743 2
	int err;
	u_int8_t nifaces;
a747 13
	/* Get the number of interfaces. */
	if (uaa->iface != NULL) {
		nifaces = uaa->nifaces;
	} else {
		err = usbd_set_config_index(uaa->device, UFTDI_CONFIG_INDEX, 1);
		if (err)
			return (UMATCH_NONE);
		err = usbd_interface_count(uaa->device, &nifaces);
		if (err)
			return (UMATCH_NONE);
		usbd_set_config_index(uaa->device, USB_UNCONFIG_INDEX, 1);
	}

d754 1
a754 8
	if (nifaces <= 1)
		return (UMATCH_VENDOR_PRODUCT);

	/* Dual UART chip */
	if (uaa->iface != NULL)
		return (UMATCH_VENDOR_IFACESUBCLASS);
	else
		return (UMATCH_NONE);
a761 2
	struct usbd_device *dev = uaa->device;
	struct usbd_interface *iface;
d765 1
a766 26
	usbd_status err;
	struct ucom_attach_args uca;

	DPRINTFN(10,("\nuftdi_attach: sc=%p\n", sc));

	sc->sc_udev = dev;

	if (uaa->iface == NULL) {
		/* Move the device into the configured state. */
		err = usbd_set_config_index(dev, UFTDI_CONFIG_INDEX, 1);
		if (err) {
			printf("%s: failed to set configuration, err=%s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
			goto bad;
		}

		err = usbd_device2interface_handle(dev, UFTDI_IFACE_INDEX, &iface);
		if (err) {
			printf("%s: failed to get interface, err=%s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
			goto bad;
		}
	} else
		iface = uaa->iface;

	id = usbd_get_interface_descriptor(iface);
d768 2
a769 1
	sc->sc_iface = iface;
d783 1
d786 1
a786 1
		ed = usbd_interface2endpoint_descriptor(iface, i);
d828 2
a829 2
	uca.device = dev;
	uca.iface = iface;
@


1.72
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.71 2014/02/04 12:03:12 mpi Exp $ 	*/
a49 1
#include <dev/usb/usbhid.h>
@


1.71
log
@Make sure the USB device pointer is valid even if attach fails since
it is now checked to prevent any operation on the device.

Problem found and fix tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.70 2014/02/03 20:53:32 mpi Exp $ 	*/
d119 10
a128 15
int uftdi_match(struct device *, void *, void *); 
void uftdi_attach(struct device *, struct device *, void *); 
int uftdi_detach(struct device *, int); 
int uftdi_activate(struct device *, int); 

struct cfdriver uftdi_cd = { 
	NULL, "uftdi", DV_DULL 
}; 

const struct cfattach uftdi_ca = { 
	sizeof(struct uftdi_softc), 
	uftdi_match, 
	uftdi_attach, 
	uftdi_detach, 
	uftdi_activate, 
a890 13
}

int
uftdi_activate(struct device *self, int act)
{
	struct uftdi_softc *sc = (struct uftdi_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.70
log
@Fix a null dereference introduced when converting this driver to use
usbd_is_dying().

Found the hard way by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.69 2014/01/07 14:00:50 deraadt Exp $ 	*/
d802 2
a823 1
	sc->sc_udev = dev;
d895 1
a895 1
	usbd_deactivate(dev);
@


1.69
log
@FTX support; from Chris Hettrick
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.68 2013/12/13 12:32:24 yuo Exp $ 	*/
d894 1
a894 1
	usbd_deactivate(sc->sc_udev);
@


1.68
log
@add SACOM USB485BL
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.67 2013/11/15 08:25:31 pirofti Exp $ 	*/
d250 1
@


1.67
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.66 2013/11/07 11:13:31 pirofti Exp $ 	*/
d682 1
@


1.66
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Testing and okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.65 2013/11/02 01:41:17 jeremy Exp $ 	*/
a898 1
	int rv = 0;
a901 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d905 1
a905 1
	return (rv);
@


1.65
log
@Begin conversion of USB stack to return int instead of usbd_status,
starting with usbd_endpoint_count and usbd_interface_count.  usbd_status
should only be used to indicate the status of a USB transfer, it should
not be used for generic error codes.

Idea from and much hand-holding by mpi@@

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.64 2013/04/15 09:23:02 mglocker Exp $ 	*/
a92 2
	u_char			 sc_dying;

d892 1
a892 1
	sc->sc_dying = 1;
d905 1
a905 1
		sc->sc_dying = 1;
d935 1
a935 1
	if (sc->sc_dying)
d1059 1
a1059 1
	if (sc->sc_dying)
@


1.64
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.63 2012/09/11 16:04:44 deraadt Exp $ 	*/
d751 1
a751 1
	usbd_status err;
@


1.63
log
@Support FTDI FT2232H.  This has a new base clock rate, different divisor,
and the buffersizes are now taken from the endpoint descriptors.
From Raphael Graf
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.62 2011/10/28 01:45:55 deraadt Exp $ 	*/
d82 2
a83 2
	usbd_device_handle	 sc_udev;	/* device */
	usbd_interface_handle	 sc_iface;	/* interface */
d791 2
a792 2
	usbd_device_handle dev = uaa->device;
	usbd_interface_handle iface;
@


1.62
log
@sync to new ufdti; Mark Peoples
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.61 2011/10/20 16:37:36 mpf Exp $ 	*/
d108 1
d828 3
d849 1
a849 1
		if (dir == UE_DIR_IN && attr == UE_BULK)
d851 3
a853 1
		else if (dir == UE_DIR_OUT && attr == UE_BULK)
d855 4
a858 1
		else {
d879 1
a879 3
	uca.ibufsize = UFTDIIBUFSIZE;
	uca.obufsize = UFTDIOBUFSIZE - sc->sc_hdrlen;
	uca.ibufsizepad = UFTDIIBUFSIZE;
d1086 4
d1094 1
a1094 1
	USETW(req.wIndex, portno);
d1263 30
@


1.61
log
@Add Stollmann Active USB ISDN Terminal Adapter.
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.60 2011/10/07 06:04:14 ckuethe Exp $ 	*/
d305 2
a306 1
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_MJS_SIRIUS_PC },
@


1.60
log
@Interface cable for Yaesu ham radios, ok deraadt

uftdi0 at uhub2 port 1 "RT Systems CT57B Radio Cable" rev 2.00/6.00 addr 2
ucom0 at uftdi0 portno 1
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.59 2011/07/03 15:47:17 matthew Exp $ 	*/
d729 1
@


1.59
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.58 2011/01/25 20:03:36 jakemsr Exp $ 	*/
d681 1
@


1.58
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.57 2010/09/24 08:33:59 yuo Exp $ 	*/
a893 3
	case DVACT_ACTIVATE:
		break;

@


1.57
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.56 2010/02/23 23:31:54 jsg Exp $ 	*/
a876 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a915 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.56
log
@Add another 340 product ids found in the linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.55 2009/12/16 21:41:29 deraadt Exp $ 	*/
a914 1
	sc->sc_dying = 1;
@


1.55
log
@Support OpenRD JTAGKey, expect spip the jtag interface port.
from Tobias Ulmer; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.54 2009/10/13 19:33:17 pirofti Exp $ 	*/
d138 5
d146 4
d159 4
d186 3
d192 2
d195 1
d198 1
d200 1
d209 1
d212 1
d214 3
d222 1
d224 1
d231 1
d235 2
d238 1
d240 5
d250 1
d263 2
d274 2
d286 1
d292 2
d306 7
d318 5
d324 11
d342 1
d348 2
d353 1
d366 1
d380 2
a382 1
	{ USB_VENDOR_INTREPIDCS, USB_PRODUCT_INTREPIDCS_NEOVI },
d384 1
d387 259
a646 1
	{ USB_VENDOR_MECANIQUE, USB_PRODUCT_MECANIQUE_TELLSTICK },
d738 3
a740 1
	{ USB_VENDOR_THURLBY, USB_PRODUCT_THURLBY_QL355P }
@


1.54
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.53 2009/04/22 18:56:56 deraadt Exp $ 	*/
d264 1
d430 6
@


1.53
log
@sync to MECANIQUE change, and add a uftdi found there, spotted by Henrik Hellerstedt
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.52 2009/04/21 05:22:51 deraadt Exp $ 	*/
d123 1
a123 1
int uftdi_activate(struct device *, enum devact); 
d549 1
a549 1
uftdi_activate(struct device *self, enum devact act)
@


1.52
log
@new ftdi; 8U232AM4; Takanori Watanabe spotted it
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.51 2008/11/26 14:29:27 mbalmer Exp $ 	*/
d312 1
@


1.51
log
@Add a missing device.  Found by Alex Brodsky <abrodsky@@acs.winnipeg.ca>.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.50 2008/07/10 13:48:54 mbalmer Exp $ 	*/
d272 1
@


1.50
log
@Don't terminate the array of matching product/vendor IDs with { 0, 0 }
when usb_lookup is used.  If a device indeed has 0 as vendor and product
ID, like the  HP DL165 BMC Server Engines SE USB Device, a wrong driver
will attach and the machine will most pbly crash.

Problem reported Rivo Nurges <rix@@estpak.ee>
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.49 2008/06/26 05:42:18 ray Exp $ 	*/
d267 1
@


1.49
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.48 2008/06/02 12:08:01 jsg Exp $ 	*/
d401 1
a401 2
	{ USB_VENDOR_THURLBY, USB_PRODUCT_THURLBY_QL355P },
	{ 0, 0 }
@


1.48
log
@Add a bunch of ELV Elektronik ftdi based devices found in the
Linux driver. Prompted by a diff adding the "ELV EM 1010"
from MERIGHI Marcus <Marcus@@Merighi.AT>
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.47 2008/04/17 22:12:42 fkr Exp $ 	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.47
log
@attach FTDI 2232L
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.46 2008/03/18 12:24:19 jsg Exp $ 	*/
d191 4
d196 13
d212 3
@


1.46
log
@Bring in some changes from DragonFly:
- New matching logic so we don't need to check against vid/pid
  to figure out which kind of chip we have
- Match list in a struct instead of messy if statement (hurrah!)
- More generic dual port handling
- Insane amount of device additions, mostly found in Linux driver
(aue included as a usb vendor got renamed)

Tested by ckuethe@@, 'looks super sensible' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.45 2008/02/22 12:42:40 jsg Exp $ 	*/
d254 1
@


1.45
log
@Simon Dick in FreeBSD PR 96714
* Fossil Abacus Wrist PDA

Thorsten Trampisch in FreeBSD PR 113384
* Expert ISDN Control
* RS232 OptoBridge

Jonathan Charest in FreeBSD PR 110992
* Several Tactrix OpenPort (ECU) devices.

Y.Okabe in FreeBSD PR 119981
* Logitec LAN-GTJ/U2 Ethernet

HAGIMORI 'buggy' Masashige in FreeBSD PR 115933
* RATOC REX-USB60F serial
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.44 2007/11/11 02:14:24 deraadt Exp $ 	*/
d144 247
d395 5
d401 1
d403 9
a411 4
		if (uaa->vendor == USB_VENDOR_FTDI &&
		    (uaa->product == USB_PRODUCT_FTDI_SERIAL_2232C))
			return (UMATCH_VENDOR_IFACESUBCLASS);
		return (UMATCH_NONE);
d414 1
a414 54
	DPRINTFN(20,("uftdi: vendor=0x%x, product=0x%x\n",
		     uaa->vendor, uaa->product));

	if (uaa->vendor == USB_VENDOR_FTDI &&
	    (uaa->product == USB_PRODUCT_FTDI_EISCOU ||
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U100AX ||
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U232AM ||
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_232BM ||
	     uaa->product == USB_PRODUCT_FTDI_SEMC_DSS20 ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_KW ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_YS ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_Y6 ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_Y8 ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_IC ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_DB9 ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_RS232 ||
	     uaa->product == USB_PRODUCT_FTDI_MHAM_Y9 ||
	     uaa->product == USB_PRODUCT_FTDI_COASTAL_TNCX ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_LK202_24 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_LK204_24 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_MX200 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_631 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_632 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_633 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_634 ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_635 ||
	     uaa->product == USB_PRODUCT_FTDI_MJS_SIRIUS_PC ||
	     uaa->product == USB_PRODUCT_FTDI_OPENPORT_13M ||
	     uaa->product == USB_PRODUCT_FTDI_OPENPORT_13S ||
	     uaa->product == USB_PRODUCT_FTDI_OPENPORT_13U ||
	     uaa->product == USB_PRODUCT_FTDI_UOPTBR))
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_IODATA &&
	     uaa->product == USB_PRODUCT_IODATA_FT232R)
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_SIIG2 &&
	    (uaa->product == USB_PRODUCT_SIIG2_US2308))
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_INTREPIDCS &&
	    (uaa->product == USB_PRODUCT_INTREPIDCS_VALUECAN ||
	     uaa->product == USB_PRODUCT_INTREPIDCS_NEOVI))
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_BBELECTRONICS &&
	    (uaa->product == USB_PRODUCT_BBELECTRONICS_USOTL4))
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_FALCOM &&
	    (uaa->product == USB_PRODUCT_FALCOM_TWIST ||
	     uaa->product == USB_PRODUCT_FALCOM_SAMBA))
		 return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_RATOC &&
	    (uaa->product == USB_PRODUCT_RATOC_REXUSB60F))
		return (UMATCH_VENDOR_PRODUCT);
	if (uaa->vendor == USB_VENDOR_SEALEVEL &&
	    uaa->product == USB_PRODUCT_SEALEVEL_USBSERIAL)
d417 5
a421 1
	return (UMATCH_NONE);
d463 4
a466 44
	switch (uaa->vendor) {
	case USB_VENDOR_FTDI:
		switch (uaa->product) {
		case USB_PRODUCT_FTDI_SERIAL_8U100AX:
			sc->sc_type = UFTDI_TYPE_SIO;
			sc->sc_hdrlen = 1;
			break;

		case USB_PRODUCT_FTDI_SEMC_DSS20:
		case USB_PRODUCT_FTDI_SERIAL_8U232AM:
		case USB_PRODUCT_FTDI_SERIAL_2232C:
		case USB_PRODUCT_FTDI_SERIAL_232BM:
		case USB_PRODUCT_FTDI_COASTAL_TNCX:
		case USB_PRODUCT_FTDI_LCD_LK202_24:
		case USB_PRODUCT_FTDI_LCD_LK204_24:
		case USB_PRODUCT_FTDI_LCD_MX200:
		case USB_PRODUCT_FTDI_LCD_CFA_631:
		case USB_PRODUCT_FTDI_LCD_CFA_632:
		case USB_PRODUCT_FTDI_LCD_CFA_633:
		case USB_PRODUCT_FTDI_LCD_CFA_634:
		case USB_PRODUCT_FTDI_LCD_CFA_635:
		case USB_PRODUCT_FTDI_MHAM_KW:
		case USB_PRODUCT_FTDI_MHAM_YS:
		case USB_PRODUCT_FTDI_MHAM_Y6:
		case USB_PRODUCT_FTDI_MHAM_Y8:
		case USB_PRODUCT_FTDI_MHAM_IC:
		case USB_PRODUCT_FTDI_MHAM_DB9:
		case USB_PRODUCT_FTDI_MHAM_RS232:
		case USB_PRODUCT_FTDI_MHAM_Y9:
		case USB_PRODUCT_SEALEVEL_USBSERIAL:
		case USB_PRODUCT_FTDI_MJS_SIRIUS_PC:
			sc->sc_type = UFTDI_TYPE_8U232AM;
			sc->sc_hdrlen = 0;
			break;
		
		default:		/* Can't happen */
			goto bad;
		}
		break;

	case USB_VENDOR_INTREPIDCS:
		switch (uaa->product) {
		case USB_PRODUCT_INTREPIDCS_VALUECAN:
		case USB_PRODUCT_INTREPIDCS_NEOVI:
d468 2
a469 55
			sc->sc_hdrlen = 0;
			break;

		default:                /* Can't happen */
			goto bad;
		}
		break;

	case USB_VENDOR_IODATA:
		switch (uaa->product) {
		case USB_PRODUCT_IODATA_FT232R:
			sc->sc_type = UFTDI_TYPE_8U232AM;
			sc->sc_hdrlen = 0;
			break;
		default:
			goto bad;
		}
		break;			

	case USB_VENDOR_SIIG2:
		switch (uaa->product) {
		case USB_PRODUCT_SIIG2_US2308:
			sc->sc_type = UFTDI_TYPE_8U232AM;
			sc->sc_hdrlen = 0;
			break;

		default:		/* Can't happen */
			goto bad;
		}
		break;

	case USB_VENDOR_BBELECTRONICS:
		switch( uaa->product ){
		case USB_PRODUCT_BBELECTRONICS_USOTL4:
			sc->sc_type = UFTDI_TYPE_8U232AM;
			sc->sc_hdrlen = 0;
			break;
		default:		/* Can't happen */
			goto bad;
		}
		break;

	case USB_VENDOR_FALCOM:
		switch( uaa->product ){
		case USB_PRODUCT_FALCOM_TWIST:
		case USB_PRODUCT_FALCOM_SAMBA:
			sc->sc_type = UFTDI_TYPE_8U232AM;
			sc->sc_hdrlen = 0;
			break;
		default:		/* Can't happen */
			goto bad;
		}
		break;
	}		

@


1.44
log
@support little I-O DATA UPS GPS thingy
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.43 2007/10/11 18:33:15 deraadt Exp $ 	*/
d160 2
a161 1
	    (uaa->product == USB_PRODUCT_FTDI_SERIAL_8U100AX ||
d182 5
a186 1
	     uaa->product == USB_PRODUCT_FTDI_MJS_SIRIUS_PC))
d205 3
@


1.43
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.42 2007/09/19 12:39:21 pyr Exp $ 	*/
d183 3
d298 11
@


1.42
log
@attach CFA 635 as a uftdi.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.41 2007/06/14 10:11:15 mbalmer Exp $ 	*/
a212 1
	char *devinfop;
d224 2
a225 2
			printf("\n%s: failed to set configuration, err=%s\n",
			       devname, usbd_errstr(err));
d231 2
a232 2
			printf("\n%s: failed to get interface, err=%s\n",
			       devname, usbd_errstr(err));
a236 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.41
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.40 2007/06/13 06:25:03 mbalmer Exp $ 	*/
d180 1
d268 1
@


1.40
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.39 2007/06/12 16:26:36 mbalmer Exp $ 	*/
d127 16
a142 1
USB_DECLARE_DRIVER(uftdi);
@


1.39
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.38 2007/06/10 14:49:01 mbalmer Exp $ 	*/
d88 3
a90 3
	struct device		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;	/* device */
	usbd_interface_handle	sc_iface;	/* interface */
d92 2
a93 2
	enum uftdi_type		sc_type;
	u_int			sc_hdrlen;
d95 2
a96 2
	u_char			sc_msr;
	u_char			sc_lsr;
d98 1
a98 1
	struct device *		sc_subdev;
d100 1
a100 1
	u_char			sc_dying;
d102 1
a102 1
	u_int			last_lcr;
@


1.38
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.37 2007/06/10 10:53:48 mbalmer Exp $ 	*/
d98 1
a98 1
	device_ptr_t		sc_subdev;
d383 1
a383 1
uftdi_activate(device_ptr_t self, enum devact act)
d402 1
a402 1
uftdi_detach(device_ptr_t self, int flags)
@


1.37
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.36 2007/06/06 19:25:49 mk Exp $ 	*/
d198 1
a198 1
	char *devname = USBDEVNAME(sc->sc_dev);
d345 1
a345 1
		       USBDEVNAME(sc->sc_dev));
d350 1
a350 1
		       USBDEVNAME(sc->sc_dev));
@


1.36
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.35 2007/06/05 08:43:55 mbalmer Exp $ 	*/
d370 1
a370 1
			   USBDEV(sc->sc_dev));
d414 1
a414 1
			   USBDEV(sc->sc_dev));
@


1.35
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.34 2007/05/27 04:00:25 jsg Exp $ 	*/
d88 1
a88 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.34
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.33 2007/03/03 12:40:31 deraadt Exp $ 	*/
d105 5
a109 5
Static void	uftdi_get_status(void *, int portno, u_char *lsr, u_char *msr);
Static void	uftdi_set(void *, int, int, int);
Static int	uftdi_param(void *, int, struct termios *);
Static int	uftdi_open(void *sc, int portno);
Static void	uftdi_read(void *sc, int portno, u_char **ptr,
d111 1
a111 1
Static void	uftdi_write(void *sc, int portno, u_char *to, u_char *from,
d113 2
a114 2
Static void	uftdi_break(void *sc, int portno, int onoff);
Static int	uftdi_8u232am_getrate(speed_t speed, int *rate);
d419 1
a419 1
Static int
d460 1
a460 1
Static void
d493 1
a493 1
Static void
d509 1
a509 1
Static void
d543 1
a543 1
Static int
d689 1
a689 1
Static int
@


1.33
log
@Sirius To PC Interface is a uftdi; marco@@azbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.32 2007/02/07 23:51:51 jsg Exp $ 	*/
d129 2
a130 1
USB_MATCH(uftdi)
d132 1
a132 1
	USB_MATCH_START(uftdi, uaa);
d188 2
a189 1
USB_ATTACH(uftdi)
d191 2
a192 1
	USB_ATTACH_START(uftdi, sc, uaa);
d224 1
a224 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d375 1
a375 1
	USB_ATTACH_SUCCESS_RETURN;
a379 1
	USB_ATTACH_ERROR_RETURN;
@


1.32
log
@Add support for MaxStream XBee ZigBee Development Kit USB interface.
From Darrin Chandler
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.31 2006/08/10 20:45:26 jason Exp $ 	*/
d163 3
a165 2
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA_634))
	    return (UMATCH_VENDOR_PRODUCT);
d259 1
@


1.31
log
@match the Coastal ChipWorks TNC-X (yet another uftdi)
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.30 2006/06/23 06:27:11 miod Exp $ 	*/
d146 1
d240 1
@


1.30
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.29 2006/06/16 06:28:25 deraadt Exp $ 	*/
d155 1
d239 1
@


1.29
log
@algorithmically handle baudrate requests, allowing all sorts of
strange rates one might need; mrd@@alkemio.org
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.28 2006/05/11 14:53:11 jason Exp $ 	*/
d383 1
a383 1
		return (EOPNOTSUPP);
@


1.28
log
@more microHAM devices
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.27 2006/05/11 14:38:46 jason Exp $ 	*/
d114 1
d568 1
a568 17
		switch(t->c_ospeed) {
		case 300: rate = ftdi_8u232am_b300; break;
		case 600: rate = ftdi_8u232am_b600; break;
		case 1200: rate = ftdi_8u232am_b1200; break;
		case 2400: rate = ftdi_8u232am_b2400; break;
		case 4800: rate = ftdi_8u232am_b4800; break;
		case 9600: rate = ftdi_8u232am_b9600; break;
		case 19200: rate = ftdi_8u232am_b19200; break;
		case 38400: rate = ftdi_8u232am_b38400; break;
		case 57600: rate = ftdi_8u232am_b57600; break;
		case 115200: rate = ftdi_8u232am_b115200; break;
		case 230400: rate = ftdi_8u232am_b230400; break;
		case 460800: rate = ftdi_8u232am_b460800; break;
		case 921600: rate = ftdi_8u232am_b921600; break;
		case 2000000: rate = ftdi_8u232am_b2000000; break;
		case 3000000: rate = ftdi_8u232am_b3000000; break;
		default:
a569 1
		}
d680 64
@


1.27
log
@support the microHAM radio/computer interfaces
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.26 2006/03/26 18:57:00 grange Exp $ 	*/
d146 2
d150 4
a153 1
	     uaa->product == USB_PRODUCT_FTDI_MHAM_USBII ||
d244 2
d248 4
a251 1
		case USB_PRODUCT_FTDI_MHAM_USBII:
@


1.26
log
@Support for Falcom Samba GPRS modem; from tm@@openbsd.ru.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.25 2005/08/01 05:36:48 brad Exp $ 	*/
d146 3
d239 3
@


1.25
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.24 2005/05/24 03:26:05 pascoe Exp $ 	*/
d165 2
a166 1
	    (uaa->product == USB_PRODUCT_FALCOM_TWIST))
d285 1
@


1.24
log
@Support second interface on FTDI 2232C based devices.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.23 2005/05/13 22:32:42 deraadt Exp $ 	*/
d181 1
a181 1
	char devinfo[1024];
d207 1
a207 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d209 2
a210 1
	printf("%s: %s\n", devname, devinfo);
@


1.23
log
@another uftdi varient, from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.22 2005/04/17 07:39:44 dlg Exp $ 	*/
a144 1
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_2232C ||
@


1.22
log
@do {} while (0) wrapper for the debug printf macros
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.21 2005/04/08 04:29:57 deraadt Exp $ 	*/
d168 3
d235 1
@


1.21
log
@handle at least the first port of a dual-port ufdti; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.20 2005/04/01 08:25:39 deraadt Exp $ 	*/
d68 2
a69 2
#define DPRINTF(x)	if (uftdidebug) printf x
#define DPRINTFN(n,x)	if (uftdidebug>(n)) printf x
@


1.20
log
@uftdi 2232c dual usb (1 port supported for now).  they did not mail me a unit... but CHIPS.. gadddggrr...
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.19 2004/12/08 02:47:30 jsg Exp $ 	*/
d132 4
a135 1
	if (uaa->iface != NULL)
d137 1
d187 8
a194 7
	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UFTDI_CONFIG_INDEX, 1);
	if (err) {
		printf("\n%s: failed to set configuration, err=%s\n",
		       devname, usbd_errstr(err));
		goto bad;
	}
d196 8
a203 6
	err = usbd_device2interface_handle(dev, UFTDI_IFACE_INDEX, &iface);
	if (err) {
		printf("\n%s: failed to get interface, err=%s\n",
		       devname, usbd_errstr(err));
		goto bad;
	}
d295 2
a296 2
			printf("%s: could not read endpoint descriptor"
			       ": %s\n", devname, usbd_errstr(err));
d323 4
a326 1
	uca.portno = FTDI_PIT_SIOA;
@


1.19
log
@Falcom Twist-USB GSM/GPRS modem.
From David Coppa <caff at openbeer dot it> with tweaks from me.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.18 2004/10/30 14:36:28 deraadt Exp $ 	*/
d141 1
d217 1
@


1.18
log
@Support another device; prices@@dflytech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.17 2004/08/13 22:13:55 deraadt Exp $ 	*/
d160 3
d267 11
d279 1
@


1.17
log
@LK204-24-USB LCD; adulau@@foo.be
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.16 2004/07/11 07:17:58 deraadt Exp $ 	*/
d157 3
d245 12
@


1.16
log
@support 4 more uftdi ports (3 from freebsd, 1 from netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.16 2004/07/11 07:03:49 deraadt Exp $ 	*/
d143 1
d211 1
@


1.15
log
@support Crystalfontz CF-63[1234] USB LCDs; wpd@@xs4all.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.14 2003/12/08 15:26:22 henning Exp $ 	*/
d141 7
a147 5
	     uaa->product == USB_PRODUCT_FTDI_LCD_MX200_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA631_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA632_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA633_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA634_USB))
d149 7
d199 23
a221 4
	switch (uaa->product) {
	case USB_PRODUCT_FTDI_SERIAL_8U100AX:
		sc->sc_type = UFTDI_TYPE_SIO;
		sc->sc_hdrlen = 1;
d224 4
a227 7
	case USB_PRODUCT_FTDI_SERIAL_8U232AM:
	case USB_PRODUCT_FTDI_LCD_LK202_24_USB:
	case USB_PRODUCT_FTDI_LCD_MX200_USB:
	case USB_PRODUCT_FTDI_LCD_CFA631_USB:
	case USB_PRODUCT_FTDI_LCD_CFA632_USB:
	case USB_PRODUCT_FTDI_LCD_CFA633_USB:
	case USB_PRODUCT_FTDI_LCD_CFA634_USB:
d229 6
a234 1
		sc->sc_hdrlen = 0;
d236 12
a247 4
	
	default:		/* Can't happen */
		goto bad;
	}
d515 2
@


1.14
log
@Matrix Orbital MX200 Series
mostly From: nj@@obsd.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.13 2003/10/04 01:01:34 deraadt Exp $ 	*/
d141 6
a146 2
	     uaa->product == USB_PRODUCT_FTDI_LCD_MX200_USB))
		return (UMATCH_VENDOR_PRODUCT);
d199 4
@


1.13
log
@Support for Matrix Orbital USB LCD Modules; cjeker@@diehard.n-r-g.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.12 2003/05/19 00:33:26 nate Exp $ 	*/
d140 2
a141 1
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U232AM))
a192 4
		sc->sc_type = UFTDI_TYPE_8U232AM;
		sc->sc_hdrlen = 0;
		break;

d194 1
@


1.12
log
@ditch unused return value
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.11 2003/05/07 04:33:33 deraadt Exp $ 	*/
d196 5
@


1.11
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uftdi.c,v 1.10 2002/11/11 02:32:32 nate Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.13 2002/09/23 05:51:23 simonb Exp $	*/
a281 1
	int rv = 0;
d286 1
a286 1
		rv = config_detach(sc->sc_subdev, flags);
@


1.10
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.9 2002/07/29 03:01:48 nate Exp $ 	*/
d176 1
a176 1
	usbd_devinfo(dev, 0, devinfo);
@


1.9
log
@Update from NetBSD.  Log message:

Add code to setup hardware or software flow control (or none at
all, if necessary) depending on the user-specified termios flags.

This allows the device to talk to DCEs which don't assert RTS
(i.e. dumb, 3-wire serial ports).
@
text
@d1 2
a2 2
/*	$OpenBSD: uftdi.c,v 1.8 2002/07/25 02:18:10 nate Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.12 2002/07/18 14:44:10 scw Exp $	*/
a267 1
		break;
@


1.8
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uftdi.c,v 1.7 2002/07/10 02:56:53 nate Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.10 2002/05/08 18:10:19 scw Exp $	*/
d428 1
a428 1
	int rate, data;
d520 18
@


1.7
log
@Support for USB->Serial adapters based on FT8U232AM
various updates
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.6 2002/06/18 00:59:16 nate Exp $ 	*/
d131 1
a131 1
	
d209 1
a209 1
		
d232 1
a232 1
	
d549 1
a549 1
		  onoff)); 
@


1.6
log
@fix uftdi so that it matches what usbdevs says
@
text
@d1 2
a2 2
/*	$OpenBSD: uftdi.c,v 1.5 2002/05/07 18:29:18 nate Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.6 2001/01/23 21:56:17 augustss Exp $	*/
d92 3
d101 2
d109 2
a110 1
Static void	uftdi_read(void *sc, int portno, u_char **ptr,u_int32_t *count);
d113 1
d139 2
a140 1
	    uaa->product == USB_PRODUCT_FTDI_SERIAL_8U100AX)
d185 15
d236 1
a236 1
	uca.obufsize = UFTDIOBUFSIZE - 1;
d238 1
a238 1
	uca.opkthdrlen = 1;
d375 2
d381 5
a385 3
	*to = FTDI_OUT_TAG(*count, portno);
	memcpy(to+1, from, *count);
	++*count;
d406 1
a406 1
		/* XXX how do we set break? */
d435 37
a471 13
	switch (t->c_ospeed) {
	case 300: rate = ftdi_sio_b300; break;
	case 600: rate = ftdi_sio_b600; break;
	case 1200: rate = ftdi_sio_b1200; break;
	case 2400: rate = ftdi_sio_b2400; break;
	case 4800: rate = ftdi_sio_b4800; break;
	case 9600: rate = ftdi_sio_b9600; break;
	case 19200: rate = ftdi_sio_b19200; break;
	case 38400: rate = ftdi_sio_b38400; break;
	case 57600: rate = ftdi_sio_b57600; break;
	case 115200: rate = ftdi_sio_b115200; break;
	default:
		return (EINVAL);
d510 2
d539 24
@


1.5
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.3 2001/05/03 02:20:33 aaron Exp $ 	*/
d132 1
a132 1
	    uaa->product == USB_PRODUCT_FTDI_SERIAL)
@


1.4
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uftdi.c,v 1.9 2001/12/17 14:34:37 ichiro Exp $	*/
a97 2

	u_int			last_lcr;
d104 1
a104 2
Static void	uftdi_read(void *sc, int portno, u_char **ptr,
			   u_int32_t *count);
a106 1
Static void	uftdi_break(void *sc, int portno, int onoff);
d379 1
a379 1
		uftdi_break(sc, portno, onoff);
a458 2
	sc->last_lcr = data;

a485 24
}

void
uftdi_break(void *vsc, int portno, int onoff)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	int data;

	DPRINTF(("uftdi_break: sc=%p, port=%d onoff=%d\n", vsc, portno,
		  onoff)); 

	if (onoff) {
		data = sc->last_lcr | FTDI_SIO_SET_BREAK;
	} else {
		data = sc->last_lcr;
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	(void)usbd_do_request(sc->sc_udev, &req, NULL);
@


1.3
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: uftdi.c,v 1.2 2001/02/20 04:15:28 nate Exp $ 	*/
/*	$NetBSD: uftdi.c,v 1.6 2001/01/23 21:56:17 augustss Exp $	*/
d98 2
d106 2
a107 1
Static void	uftdi_read(void *sc, int portno, u_char **ptr,u_int32_t *count);
d110 1
d383 1
a383 1
		/* XXX how do we set break? */
d463 2
d492 24
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.3 2001/05/03 02:20:33 aaron Exp $ 	*/
@


1.3.6.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ 	*/
/*	$NetBSD: uftdi.c,v 1.12 2002/07/18 14:44:10 scw Exp $	*/
a91 3
	enum uftdi_type		sc_type;
	u_int			sc_hdrlen;

a97 2

	u_int			last_lcr;
d104 1
a104 2
Static void	uftdi_read(void *sc, int portno, u_char **ptr,
			   u_int32_t *count);
a106 1
Static void	uftdi_break(void *sc, int portno, int onoff);
d124 1
a124 1

d132 1
a132 2
	    (uaa->product == USB_PRODUCT_FTDI_SERIAL_8U100AX ||
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U232AM))
a176 15
	switch (uaa->product) {
	case USB_PRODUCT_FTDI_SERIAL_8U100AX:
		sc->sc_type = UFTDI_TYPE_SIO;
		sc->sc_hdrlen = 1;
		break;

	case USB_PRODUCT_FTDI_SERIAL_8U232AM:
		sc->sc_type = UFTDI_TYPE_8U232AM;
		sc->sc_hdrlen = 0;
		break;

	default:		/* Can't happen */
		goto bad;
	}

d186 1
a186 1

d209 1
a209 1

d213 1
a213 1
	uca.obufsize = UFTDIOBUFSIZE - sc->sc_hdrlen;
d215 1
a215 1
	uca.opkthdrlen = sc->sc_hdrlen;
a351 2
	struct uftdi_softc *sc = vsc;

d356 3
a358 5
	if (sc->sc_hdrlen > 0)
		*to = FTDI_OUT_TAG(*count, portno);

	memcpy(to + sc->sc_hdrlen, from, *count);
	*count += sc->sc_hdrlen;
d379 1
a379 1
		uftdi_break(sc, portno, onoff);
d401 1
a401 1
	int rate, data, flow;
d408 13
a420 37
	switch (sc->sc_type) {
	case UFTDI_TYPE_SIO:
		switch (t->c_ospeed) {
		case 300: rate = ftdi_sio_b300; break;
		case 600: rate = ftdi_sio_b600; break;
		case 1200: rate = ftdi_sio_b1200; break;
		case 2400: rate = ftdi_sio_b2400; break;
		case 4800: rate = ftdi_sio_b4800; break;
		case 9600: rate = ftdi_sio_b9600; break;
		case 19200: rate = ftdi_sio_b19200; break;
		case 38400: rate = ftdi_sio_b38400; break;
		case 57600: rate = ftdi_sio_b57600; break;
		case 115200: rate = ftdi_sio_b115200; break;
		default:
			return (EINVAL);
		}
		break;

	case UFTDI_TYPE_8U232AM:
		switch(t->c_ospeed) {
		case 300: rate = ftdi_8u232am_b300; break;
		case 600: rate = ftdi_8u232am_b600; break;
		case 1200: rate = ftdi_8u232am_b1200; break;
		case 2400: rate = ftdi_8u232am_b2400; break;
		case 4800: rate = ftdi_8u232am_b4800; break;
		case 9600: rate = ftdi_8u232am_b9600; break;
		case 19200: rate = ftdi_8u232am_b19200; break;
		case 38400: rate = ftdi_8u232am_b38400; break;
		case 57600: rate = ftdi_8u232am_b57600; break;
		case 115200: rate = ftdi_8u232am_b115200; break;
		case 230400: rate = ftdi_8u232am_b230400; break;
		case 460800: rate = ftdi_8u232am_b460800; break;
		case 921600: rate = ftdi_8u232am_b921600; break;
		default:
			return (EINVAL);
		}
		break;
a458 2
	sc->last_lcr = data;

a470 18
	if (ISSET(t->c_cflag, CRTSCTS)) {
		flow = FTDI_SIO_RTS_CTS_HS;
		USETW(req.wValue, 0);
	} else if (ISSET(t->c_iflag, IXON|IXOFF)) {
		flow = FTDI_SIO_XON_XOFF_HS;
		USETW2(req.wValue, t->c_cc[VSTOP], t->c_cc[VSTART]);
	} else {
		flow = FTDI_SIO_DISABLE_FLOW_CTRL;
		USETW(req.wValue, 0);
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_FLOW_CTRL;
	USETW2(req.wIndex, flow, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

a485 24
}

void
uftdi_break(void *vsc, int portno, int onoff)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	int data;

	DPRINTF(("uftdi_break: sc=%p, port=%d onoff=%d\n", vsc, portno,
		  onoff));

	if (onoff) {
		data = sc->last_lcr | FTDI_SIO_SET_BREAK;
	} else {
		data = sc->last_lcr;
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	(void)usbd_do_request(sc->sc_udev, &req, NULL);
@


1.3.6.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uftdi.c,v 1.13 2002/09/23 05:51:23 simonb Exp $	*/
d176 1
a176 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d268 1
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uftdi.c,v 1.5 2001/01/23 14:04:13 augustss Exp $	*/
d220 1
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ 	*/
/*	$NetBSD: uftdi.c,v 1.6 2001/01/23 21:56:17 augustss Exp $	*/
a219 1
	uca.info = NULL;
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: uftdi.c,v 1.13 2002/09/23 05:51:23 simonb Exp $	*/
a91 3
	enum uftdi_type		sc_type;
	u_int			sc_hdrlen;

a97 2

	u_int			last_lcr;
d104 1
a104 2
Static void	uftdi_read(void *sc, int portno, u_char **ptr,
			   u_int32_t *count);
a106 1
Static void	uftdi_break(void *sc, int portno, int onoff);
d124 1
a124 1

d132 1
a132 2
	    (uaa->product == USB_PRODUCT_FTDI_SERIAL_8U100AX ||
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U232AM))
a176 15
	switch (uaa->product) {
	case USB_PRODUCT_FTDI_SERIAL_8U100AX:
		sc->sc_type = UFTDI_TYPE_SIO;
		sc->sc_hdrlen = 1;
		break;

	case USB_PRODUCT_FTDI_SERIAL_8U232AM:
		sc->sc_type = UFTDI_TYPE_8U232AM;
		sc->sc_hdrlen = 0;
		break;

	default:		/* Can't happen */
		goto bad;
	}

d186 1
a186 1

d209 1
a209 1

d213 1
a213 1
	uca.obufsize = UFTDIOBUFSIZE - sc->sc_hdrlen;
d215 1
a215 1
	uca.opkthdrlen = sc->sc_hdrlen;
d245 1
a351 2
	struct uftdi_softc *sc = vsc;

d356 3
a358 5
	if (sc->sc_hdrlen > 0)
		*to = FTDI_OUT_TAG(*count, portno);

	memcpy(to + sc->sc_hdrlen, from, *count);
	*count += sc->sc_hdrlen;
d379 1
a379 1
		uftdi_break(sc, portno, onoff);
d401 1
a401 1
	int rate, data, flow;
d408 13
a420 37
	switch (sc->sc_type) {
	case UFTDI_TYPE_SIO:
		switch (t->c_ospeed) {
		case 300: rate = ftdi_sio_b300; break;
		case 600: rate = ftdi_sio_b600; break;
		case 1200: rate = ftdi_sio_b1200; break;
		case 2400: rate = ftdi_sio_b2400; break;
		case 4800: rate = ftdi_sio_b4800; break;
		case 9600: rate = ftdi_sio_b9600; break;
		case 19200: rate = ftdi_sio_b19200; break;
		case 38400: rate = ftdi_sio_b38400; break;
		case 57600: rate = ftdi_sio_b57600; break;
		case 115200: rate = ftdi_sio_b115200; break;
		default:
			return (EINVAL);
		}
		break;

	case UFTDI_TYPE_8U232AM:
		switch(t->c_ospeed) {
		case 300: rate = ftdi_8u232am_b300; break;
		case 600: rate = ftdi_8u232am_b600; break;
		case 1200: rate = ftdi_8u232am_b1200; break;
		case 2400: rate = ftdi_8u232am_b2400; break;
		case 4800: rate = ftdi_8u232am_b4800; break;
		case 9600: rate = ftdi_8u232am_b9600; break;
		case 19200: rate = ftdi_8u232am_b19200; break;
		case 38400: rate = ftdi_8u232am_b38400; break;
		case 57600: rate = ftdi_8u232am_b57600; break;
		case 115200: rate = ftdi_8u232am_b115200; break;
		case 230400: rate = ftdi_8u232am_b230400; break;
		case 460800: rate = ftdi_8u232am_b460800; break;
		case 921600: rate = ftdi_8u232am_b921600; break;
		default:
			return (EINVAL);
		}
		break;
a458 2
	sc->last_lcr = data;

a470 18
	if (ISSET(t->c_cflag, CRTSCTS)) {
		flow = FTDI_SIO_RTS_CTS_HS;
		USETW(req.wValue, 0);
	} else if (ISSET(t->c_iflag, IXON|IXOFF)) {
		flow = FTDI_SIO_XON_XOFF_HS;
		USETW2(req.wValue, t->c_cc[VSTOP], t->c_cc[VSTART]);
	} else {
		flow = FTDI_SIO_DISABLE_FLOW_CTRL;
		USETW(req.wValue, 0);
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_FLOW_CTRL;
	USETW2(req.wIndex, flow, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

a485 24
}

void
uftdi_break(void *vsc, int portno, int onoff)
{
	struct uftdi_softc *sc = vsc;
	usb_device_request_t req;
	int data;

	DPRINTF(("uftdi_break: sc=%p, port=%d onoff=%d\n", vsc, portno,
		  onoff));

	if (onoff) {
		data = sc->last_lcr | FTDI_SIO_SET_BREAK;
	} else {
		data = sc->last_lcr;
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FTDI_SIO_SET_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	(void)usbd_do_request(sc->sc_udev, &req, NULL);
@


1.3.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uftdi.c,v 1.3.2.3 2003/03/28 00:38:31 niklas Exp $ 	*/
d176 1
a176 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.3.2.5
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ 	*/
/*	$NetBSD: uftdi.c,v 1.14 2003/02/23 04:20:07 simonb Exp $	*/
d282 1
d287 1
a287 1
		config_detach(sc->sc_subdev, flags);
@


1.3.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d140 1
a140 2
	     uaa->product == USB_PRODUCT_FTDI_SERIAL_8U232AM ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_MX200_USB))
a191 2
	case USB_PRODUCT_FTDI_LCD_LK202_24_USB:
	case USB_PRODUCT_FTDI_LCD_MX200_USB:
d195 1
a195 1
	
@


1.3.2.7
log
@Merge with the trunk
@
text
@d141 2
a142 6
	     uaa->product == USB_PRODUCT_FTDI_LCD_MX200_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA631_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA632_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA633_USB ||
	     uaa->product == USB_PRODUCT_FTDI_LCD_CFA634_USB))
	    return (UMATCH_VENDOR_PRODUCT);
a194 4
	case USB_PRODUCT_FTDI_LCD_CFA631_USB:
	case USB_PRODUCT_FTDI_LCD_CFA632_USB:
	case USB_PRODUCT_FTDI_LCD_CFA633_USB:
	case USB_PRODUCT_FTDI_LCD_CFA634_USB:
@


1.2
log
@Forgot $OpenBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD$ 	*/
/*	$NetBSD: uftdi.c,v 1.5 2001/01/23 14:04:13 augustss Exp $	*/
d220 1
@


1.1
log
@Add the uftdi driver for the FTDI usb->serial converter.
Driver from NetBSD. ok aaron@@
@
text
@d1 1
@

