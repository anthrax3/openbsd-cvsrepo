head	1.55;
access;
symbols
	OPENBSD_6_1:1.54.0.4
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.43.0.2
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.4
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.2
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.36.0.4
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.4
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.14
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	SMP:1.7.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.55
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	uRv5pa9QDlZaYgwD;

1.54
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	x5RWYO05Q3UFL5Oq;

1.53
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.52;
commitid	KhGZngmPmcr1rX2x;

1.52
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.51;
commitid	fbhqfhfdKxBcsetK;

1.51
date	2015.07.09.12.23.17;	author mpi;	state Exp;
branches;
next	1.50;
commitid	SsmCbMKBm9Q5L1P0;

1.50
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.48;
commitid	C5iGb36LQxjM60Q3;

1.48
date	2014.10.19.16.35.53;	author stsp;	state Exp;
branches;
next	1.47;
commitid	XLPeUqPVGswtPN2S;

1.47
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.46;
commitid	PSjXNz8dGohZ6ZSK;

1.46
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.45;
commitid	OBNa5kfxQ2UXoiIw;

1.45
date	2013.11.07.13.11.10;	author pirofti;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.28.17.15.31;	author stsp;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.17.08.36.06;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.09.01.07.02;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.11.12.36.52;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.01.06.12.20;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.07.11.10.47;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.19.00.35.43;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.10.21.41.51;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.04.22.55.56;	author gluk;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.11.44.24;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.22.50.27;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.57;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.22.24.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: ulpt.c,v 1.54 2017/03/26 15:31:15 deraadt Exp $ */
/*	$NetBSD: ulpt.c,v 1.57 2003/01/05 10:19:42 scw Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/ulpt.c,v 1.24 1999/11/17 22:33:44 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Printer Class spec:
 *   http://www.usb.org/developers/devclass_docs/usbprint11.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/uio.h>
#include <sys/conf.h>
#include <sys/vnode.h>
#include <sys/syslog.h>
#include <sys/malloc.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>

#define	TIMEOUT		hz*16	/* wait up to 16 seconds for a ready */
#define	STEP		hz/4

#define	LPTPRI		(PZERO+8)
#define	ULPT_BSIZE	16384

#ifdef ULPT_DEBUG
#define DPRINTF(x)	do { if (ulptdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (ulptdebug>(n)) printf x; } while (0)
int	ulptdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UR_GET_DEVICE_ID 0
#define UR_GET_PORT_STATUS 1
#define UR_SOFT_RESET 2

#define	LPS_NERR		0x08	/* printer no error */
#define	LPS_SELECT		0x10	/* printer selected */
#define	LPS_NOPAPER		0x20	/* printer out of paper */
#define LPS_INVERT      (LPS_SELECT|LPS_NERR)
#define LPS_MASK        (LPS_SELECT|LPS_NERR|LPS_NOPAPER)

struct ulpt_softc {
	struct device sc_dev;
	struct usbd_device *sc_udev;	/* device */
	struct usbd_interface *sc_iface;/* interface */
	int sc_ifaceno;

	int sc_out;
	struct usbd_pipe *sc_out_pipe;	/* bulk out pipe */

	int sc_in;
	struct usbd_pipe *sc_in_pipe;	/* bulk in pipe */
	struct usbd_xfer *sc_in_xfer1;
	struct usbd_xfer *sc_in_xfer2;
	u_char sc_junk[64];	/* somewhere to dump input */

	u_char sc_state;
#define	ULPT_OPEN	0x01	/* device is open */
#define	ULPT_OBUSY	0x02	/* printer is busy doing output */
#define	ULPT_INIT	0x04	/* waiting to initialize for open */
	u_char sc_flags;
#define	ULPT_NOPRIME	0x40	/* don't prime on open */
#define	ULPT_EFIRMWARE	0x80	/* error loading firmware */
	u_char sc_laststatus;

	int sc_refcnt;

	struct ulpt_fwdev *sc_fwdev;
};

void ulpt_disco(void *);

int ulpt_do_write(struct ulpt_softc *, struct uio *uio, int);
int ulpt_status(struct ulpt_softc *);
void ulpt_reset(struct ulpt_softc *);
int ulpt_statusmsg(u_char, struct ulpt_softc *);

/*
 * Printers which need firmware uploads.
 */
void ulpt_load_firmware(struct device *);
usbd_status ulpt_ucode_loader_hp(struct ulpt_softc *);
struct ulpt_fwdev {
	struct usb_devno	 uv_dev;
	char			*ucode_name;
	usbd_status		 (*ucode_loader)(struct ulpt_softc *);
} ulpt_fwdevs[] = {
	{
	    { USB_VENDOR_HP, USB_PRODUCT_HP_1000 },
	    "ulpt-hp1000",
	    ulpt_ucode_loader_hp
	},
	{
	    { USB_VENDOR_HP, USB_PRODUCT_HP_1005 },
	    "ulpt-hp1005",
	    ulpt_ucode_loader_hp
	},
	{
	    { USB_VENDOR_HP, USB_PRODUCT_HP_1018 },
	    "ulpt-hp1018",
	    ulpt_ucode_loader_hp
	},
	{
	    { USB_VENDOR_HP, USB_PRODUCT_HP_1020 },
	    "ulpt-hp1020",
	    ulpt_ucode_loader_hp
	},
};

#if 0
void ieee1284_print_id(char *);
#endif

#define	ULPTUNIT(s)	(minor(s) & 0x1f)
#define	ULPTFLAGS(s)	(minor(s) & 0xe0)


int ulpt_match(struct device *, void *, void *);
void ulpt_attach(struct device *, struct device *, void *);
int ulpt_detach(struct device *, int);

struct cfdriver ulpt_cd = {
	NULL, "ulpt", DV_DULL
};

const struct cfattach ulpt_ca = {
	sizeof(struct ulpt_softc), ulpt_match, ulpt_attach, ulpt_detach
};

int
ulpt_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	DPRINTFN(10,("ulpt_match\n"));
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id != NULL &&
	    id->bInterfaceClass == UICLASS_PRINTER &&
	    id->bInterfaceSubClass == UISUBCLASS_PRINTER &&
	    ((id->bInterfaceProtocol == UIPROTO_PRINTER_UNI) ||
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_BI) ||
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_1284)))
		return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
	return (UMATCH_NONE);
}

void
ulpt_load_firmware(struct device *self)
{
	struct ulpt_softc *sc = (struct ulpt_softc *)self;
	usbd_status err;

	err = (sc->sc_fwdev->ucode_loader)(sc);
	if (err != USBD_NORMAL_COMPLETION) {
		sc->sc_flags |= ULPT_EFIRMWARE;
		printf("%s: could not load firmware '%s'\n",
		    sc->sc_dev.dv_xname, sc->sc_fwdev->ucode_name);
	} else
		sc->sc_flags &= ~ULPT_EFIRMWARE;
}

#define ulpt_lookup(v, p) \
	((struct ulpt_fwdev *)usb_lookup(ulpt_fwdevs, v, p))

void
ulpt_attach(struct device *parent, struct device *self, void *aux)
{
	struct ulpt_softc *sc = (struct ulpt_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	struct usbd_interface *iface = uaa->iface;
	usb_interface_descriptor_t *ifcd = usbd_get_interface_descriptor(iface);
	usb_interface_descriptor_t *id, *iend;
	usb_config_descriptor_t *cdesc;
	usbd_status err;
	usb_endpoint_descriptor_t *ed;
	int i, altno;

	DPRINTFN(10,("ulpt_attach: sc=%p\n", sc));

	//printf("%s: iclass %d/%d\n", sc->sc_dev.dv_xname,
	//    ifcd->bInterfaceClass, ifcd->bInterfaceSubClass);

	/* XXX
	 * Stepping through the alternate settings needs to be abstracted out.
	 */
	cdesc = usbd_get_config_descriptor(dev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		       sc->sc_dev.dv_xname);
		return;
	}
	iend = (usb_interface_descriptor_t *)
		   ((char *)cdesc + UGETW(cdesc->wTotalLength));
#ifdef DIAGNOSTIC
	if (ifcd < (usb_interface_descriptor_t *)cdesc ||
	    ifcd >= iend)
		panic("ulpt: iface desc out of range");
#endif
	/* Step through all the descriptors looking for bidir mode */
	for (id = ifcd, altno = 0;
	     id < iend;
	     id = (void *)((char *)id + id->bLength)) {
		if (id->bDescriptorType == UDESC_INTERFACE &&
		    id->bInterfaceNumber == ifcd->bInterfaceNumber) {
			if (id->bInterfaceClass == UICLASS_PRINTER &&
			    id->bInterfaceSubClass == UISUBCLASS_PRINTER &&
			    (id->bInterfaceProtocol == UIPROTO_PRINTER_BI /*||
			     id->bInterfaceProtocol == UIPROTO_PRINTER_1284*/))
				goto found;
			altno++;
		}
	}
	id = ifcd;		/* not found, use original */
 found:
	if (id != ifcd) {
		/* Found a new bidir setting */
		DPRINTF(("ulpt_attach: set altno = %d\n", altno));
		err = usbd_set_interface(iface, altno);
		if (err) {
			printf("%s: setting alternate interface failed\n",
			       sc->sc_dev.dv_xname);
			usbd_deactivate(sc->sc_udev);
			return;
		}
	}


	sc->sc_in = -1;
	sc->sc_out = -1;

	id = usbd_get_interface_descriptor(iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_in = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_out = ed->bEndpointAddress;
		}
	}
	if (sc->sc_out == -1) {
		printf("%s: could not find bulk out endpoint\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	if (usbd_get_quirks(dev)->uq_flags & UQ_BROKEN_BIDIR) {
		/* This device doesn't handle reading properly. */
		sc->sc_in = -1;
	}

	printf("%s: using %s-directional mode\n", sc->sc_dev.dv_xname,
	       sc->sc_in >= 0 ? "bi" : "uni");

	DPRINTFN(10, ("ulpt_attach: bulk=%d\n", sc->sc_out));

	sc->sc_iface = iface;
	sc->sc_ifaceno = id->bInterfaceNumber;
	sc->sc_udev = dev;

	/* maybe the device needs firmware */
	sc->sc_fwdev = ulpt_lookup(uaa->vendor, uaa->product);
	if (sc->sc_fwdev)
		config_mountroot(self, ulpt_load_firmware);

#if 0
/*
 * This code is disabled because for some mysterious reason it causes
 * printing not to work.  But only sometimes, and mostly with
 * UHCI and less often with OHCI.  *sigh*
 */
	{
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
	usb_device_request_t req;
	int len, alen;

	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_DEVICE_ID;
	USETW(req.wValue, cd->bConfigurationValue);
	USETW2(req.wIndex, id->bInterfaceNumber, id->bAlternateSetting);
	USETW(req.wLength, DEVINFOSIZE - 1);
	err = usbd_do_request_flags(dev, &req, devinfop, USBD_SHORT_XFER_OK,
		  &alen, USBD_DEFAULT_TIMEOUT);
	if (err) {
		printf("%s: cannot get device id\n", sc->sc_dev.dv_xname);
	} else if (alen <= 2) {
		printf("%s: empty device id, no printer connected?\n",
		       sc->sc_dev.dv_xname);
	} else {
		/* devinfop now contains an IEEE-1284 device ID */
		len = ((devinfop[0] & 0xff) << 8) | (devinfop[1] & 0xff);
		if (len > DEVINFOSIZE - 3)
			len = DEVINFOSIZE - 3;
		devinfo[len] = 0;
		printf("%s: device id <", sc->sc_dev.dv_xname);
		ieee1284_print_id(devinfop+2);
		printf(">\n");
	}
	}
#endif
}

int
ulpt_detach(struct device *self, int flags)
{
	struct ulpt_softc *sc = (struct ulpt_softc *)self;
	int s;
	int maj, mn;

	DPRINTF(("ulpt_detach: sc=%p\n", sc));

	if (sc->sc_out_pipe != NULL)
		usbd_abort_pipe(sc->sc_out_pipe);
	if (sc->sc_in_pipe != NULL)
		usbd_abort_pipe(sc->sc_in_pipe);

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* There is noone to wake, aborting the pipe is enough */
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == ulptopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);
	vdevgone(maj, mn | ULPT_NOPRIME , mn | ULPT_NOPRIME, VCHR);

	return (0);
}

int
ulpt_status(struct ulpt_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;
	u_char status;

	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_PORT_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, 1);
	err = usbd_do_request(sc->sc_udev, &req, &status);
	DPRINTFN(1, ("ulpt_status: status=0x%02x err=%d\n", status, err));
	if (!err)
		return (status);
	else
		return (0);
}

void
ulpt_reset(struct ulpt_softc *sc)
{
	usb_device_request_t req;

	DPRINTFN(1, ("ulpt_reset\n"));
	req.bRequest = UR_SOFT_RESET;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, 0);

	/*
	 * There was a mistake in the USB printer 1.0 spec that gave the
	 * request type as UT_WRITE_CLASS_OTHER; it should have been
	 * UT_WRITE_CLASS_INTERFACE.  Many printers use the old one,
	 * so we try both.
	 */
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	if (usbd_do_request(sc->sc_udev, &req, 0)) {	/* 1.0 */
		req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
		(void)usbd_do_request(sc->sc_udev, &req, 0); /* 1.1 */
	}
}

static void
ulpt_input(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ulpt_softc *sc = priv;

	DPRINTFN(2,("ulpt_input: got some data\n"));
	/* Do it again. */
	if (xfer == sc->sc_in_xfer1)
		usbd_transfer(sc->sc_in_xfer2);
	else
		usbd_transfer(sc->sc_in_xfer1);
}

int ulptusein = 1;

/*
 * Reset the printer, then wait until it's selected and not busy.
 */
int
ulptopen(dev_t dev, int flag, int mode, struct proc *p)
{
	u_char flags = ULPTFLAGS(dev);
	struct ulpt_softc *sc;
	usbd_status err;
	int error;

	if (ULPTUNIT(dev) >= ulpt_cd.cd_ndevs)
		return (ENXIO);
	sc = ulpt_cd.cd_devs[ULPTUNIT(dev)];
	if (sc == NULL)
		return (ENXIO);

	if (sc == NULL || sc->sc_iface == NULL || usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	if (sc->sc_state)
		return (EBUSY);

	/* If a previous attempt to load firmware failed, retry. */
	if (sc->sc_flags & ULPT_EFIRMWARE) {
		ulpt_load_firmware(&sc->sc_dev);
		if (sc->sc_flags & ULPT_EFIRMWARE)
			return (EIO);
	}

	sc->sc_state = ULPT_INIT;
	sc->sc_flags = flags;
	DPRINTF(("ulptopen: flags=0x%x\n", (unsigned)flags));

	error = 0;
	sc->sc_refcnt++;

	if ((flags & ULPT_NOPRIME) == 0) {
		ulpt_reset(sc);
		if (usbd_is_dying(sc->sc_udev)) {
			error = ENXIO;
			sc->sc_state = 0;
			goto done;
		}
	}

	err = usbd_open_pipe(sc->sc_iface, sc->sc_out, 0, &sc->sc_out_pipe);
	if (err) {
		sc->sc_state = 0;
		error = EIO;
		goto done;
	}
	if (ulptusein && sc->sc_in != -1) {
		DPRINTF(("ulpt_open: open input pipe\n"));
		err = usbd_open_pipe(sc->sc_iface, sc->sc_in,0,&sc->sc_in_pipe);
		if (err) {
			error = EIO;
			usbd_close_pipe(sc->sc_out_pipe);
			sc->sc_out_pipe = NULL;
			sc->sc_state = 0;
			goto done;
		}
		sc->sc_in_xfer1 = usbd_alloc_xfer(sc->sc_udev);
		sc->sc_in_xfer2 = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_in_xfer1 == NULL || sc->sc_in_xfer2 == NULL) {
			error = ENOMEM;
			if (sc->sc_in_xfer1 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer1);
				sc->sc_in_xfer1 = NULL;
			}
			if (sc->sc_in_xfer2 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer2);
				sc->sc_in_xfer2 = NULL;
			}
			usbd_close_pipe(sc->sc_out_pipe);
			sc->sc_out_pipe = NULL;
			usbd_close_pipe(sc->sc_in_pipe);
			sc->sc_in_pipe = NULL;
			sc->sc_state = 0;
			goto done;
		}
		usbd_setup_xfer(sc->sc_in_xfer1, sc->sc_in_pipe, sc,
		    sc->sc_junk, sizeof sc->sc_junk, USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, ulpt_input);
		usbd_setup_xfer(sc->sc_in_xfer2, sc->sc_in_pipe, sc,
		    sc->sc_junk, sizeof sc->sc_junk, USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, ulpt_input);
		usbd_transfer(sc->sc_in_xfer1); /* ignore failed start */
	}

	sc->sc_state = ULPT_OPEN;

 done:
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	DPRINTF(("ulptopen: done, error=%d\n", error));
	return (error);
}

int
ulpt_statusmsg(u_char status, struct ulpt_softc *sc)
{
	u_char new;

	status = (status ^ LPS_INVERT) & LPS_MASK;
	new = status & ~sc->sc_laststatus;
	sc->sc_laststatus = status;

	if (new & LPS_SELECT)
		log(LOG_NOTICE, "%s: offline\n", sc->sc_dev.dv_xname);
	else if (new & LPS_NOPAPER)
		log(LOG_NOTICE, "%s: out of paper\n", sc->sc_dev.dv_xname);
	else if (new & LPS_NERR)
		log(LOG_NOTICE, "%s: output error\n", sc->sc_dev.dv_xname);

	return (status);
}

int
ulptclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct ulpt_softc *sc;

	sc = ulpt_cd.cd_devs[ULPTUNIT(dev)];

	if (sc->sc_state != ULPT_OPEN)
		/* We are being forced to close before the open completed. */
		return (0);

	if (sc->sc_out_pipe != NULL) {
		usbd_close_pipe(sc->sc_out_pipe);
		sc->sc_out_pipe = NULL;
	}
	if (sc->sc_in_pipe != NULL) {
		usbd_abort_pipe(sc->sc_in_pipe);
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
		if (sc->sc_in_xfer1 != NULL) {
			usbd_free_xfer(sc->sc_in_xfer1);
			sc->sc_in_xfer1 = NULL;
		}
		if (sc->sc_in_xfer2 != NULL) {
			usbd_free_xfer(sc->sc_in_xfer2);
			sc->sc_in_xfer2 = NULL;
		}
	}

	sc->sc_state = 0;

	DPRINTF(("ulptclose: closed\n"));
	return (0);
}

int
ulpt_do_write(struct ulpt_softc *sc, struct uio *uio, int flags)
{
	size_t n;
	int error = 0;
	void *bufp;
	struct usbd_xfer *xfer;
	usbd_status err;

	DPRINTF(("ulptwrite\n"));
	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return (ENOMEM);
	bufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);
	if (bufp == NULL) {
		usbd_free_xfer(xfer);
		return (ENOMEM);
	}
	while ((n = ulmin(ULPT_BSIZE, uio->uio_resid)) != 0) {
		ulpt_statusmsg(ulpt_status(sc), sc);
		error = uiomove(bufp, n, uio);
		if (error)
			break;
		DPRINTFN(1, ("ulptwrite: transfer %zu bytes\n", n));
		usbd_setup_xfer(xfer, sc->sc_out_pipe, 0, bufp, n,
		    USBD_NO_COPY | USBD_SYNCHRONOUS | USBD_CATCH, 0, NULL);
		err = usbd_transfer(xfer);
		if (err) {
			usbd_clear_endpoint_stall(sc->sc_out_pipe);
			DPRINTF(("ulptwrite: error=%d\n", err));
			error = EIO;
			break;
		}
	}
	usbd_free_xfer(xfer);

	return (error);
}

int
ulptwrite(dev_t dev, struct uio *uio, int flags)
{
	struct ulpt_softc *sc;
	int error;

	sc = ulpt_cd.cd_devs[ULPTUNIT(dev)];

	if (usbd_is_dying(sc->sc_udev) || (sc->sc_flags & ULPT_EFIRMWARE))
		return (EIO);

	sc->sc_refcnt++;
	error = ulpt_do_write(sc, uio, flags);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

usbd_status
ulpt_ucode_loader_hp(struct ulpt_softc *sc)
{
	usbd_status error;
	int load_error;
	uint8_t *ucode;
	uint32_t len;
	size_t ucode_size;
	const char *ucode_name = sc->sc_fwdev->ucode_name;
	int offset = 0, remain;
	struct usbd_xfer *xfer;
	void *bufp;

	/* open microcode file */
	load_error = loadfirmware(ucode_name, &ucode, &ucode_size);
	if (load_error != 0) {
		printf("%s: failed loadfirmware of file %s (error %d)\n",
		    sc->sc_dev.dv_xname, ucode_name, load_error);
		return (USBD_INVAL);
	}

	/* upload microcode */
	error = usbd_open_pipe(sc->sc_iface, sc->sc_out, 0, &sc->sc_out_pipe);
	if (error)
		goto free_ucode;
	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		goto close_pipe;
	bufp = usbd_alloc_buffer(xfer, ULPT_BSIZE);
	if (bufp == NULL) {
		error = USBD_NOMEM;
		goto free_xfer;
	}
	remain = ucode_size;
	while (remain > 0) {
		len = min(remain, ULPT_BSIZE);
		memcpy(bufp, &ucode[offset], len);
		usbd_setup_xfer(xfer, sc->sc_out_pipe, 0, bufp, len,
		    USBD_NO_COPY | USBD_SYNCHRONOUS, 0, NULL);
		error = usbd_transfer(xfer);
		if (error != USBD_NORMAL_COMPLETION) {
			usbd_clear_endpoint_stall(sc->sc_out_pipe);
			printf("%s: ucode upload error=%s!\n",
			    sc->sc_dev.dv_xname, usbd_errstr(error));
			break;
		}
		DPRINTF(("%s: uploaded %d bytes ucode\n",
		    sc->sc_dev.dv_xname, len));

		offset += len;
		remain -= len;
	}
free_xfer:
	usbd_free_xfer(xfer);
close_pipe:
	usbd_close_pipe(sc->sc_out_pipe);
	sc->sc_out_pipe = NULL;
free_ucode:
	free(ucode, M_DEVBUF, ucode_size);

	return (error);
}

#if 0
/* XXX This does not belong here. */
/*
 * Print select parts of a IEEE 1284 device ID.
 */
void
ieee1284_print_id(char *str)
{
	char *p, *q;

	for (p = str-1; p; p = strchr(p, ';')) {
		p++;		/* skip ';' */
		if (strncmp(p, "MFG:", 4) == 0 ||
		    strncmp(p, "MANUFACTURER:", 14) == 0 ||
		    strncmp(p, "MDL:", 4) == 0 ||
		    strncmp(p, "MODEL:", 6) == 0) {
			q = strchr(p, ';');
			if (q)
				printf("%.*s", (int)(q - p + 1), p);
		}
	}
}
#endif
@


1.54
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.53 2016/03/03 18:13:24 stefan Exp $ */
a46 1
#include <sys/types.h>
@


1.53
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.52 2015/12/11 16:07:02 mpi Exp $ */
d716 1
a716 1
	free(ucode, M_DEVBUF, 0);
@


1.52
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.51 2015/07/09 12:23:17 mpi Exp $ */
d604 1
a604 1
	u_int32_t n;
d619 1
a619 1
	while ((n = min(ULPT_BSIZE, uio->uio_resid)) != 0) {
d621 1
a621 1
		error = uiomovei(bufp, n, uio);
d624 1
a624 1
		DPRINTFN(1, ("ulptwrite: transfer %d bytes\n", n));
@


1.51
log
@Do not use usbd_endpoint_count(), this function is almost unused and
creates confusion.  Do like the rest of the drivers and simply get a
interface descriptor with usbd_get_interface_descriptor().

Tested by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.50 2015/03/14 03:38:50 jsg Exp $ */
d120 1
a120 1
void ulpt_load_firmware(void *);
d190 1
a190 1
ulpt_load_firmware(void *arg)
d192 1
a192 1
	struct ulpt_softc *sc = (struct ulpt_softc *)arg;
d313 2
a314 6
	if (sc->sc_fwdev) {
		if (rootvp == NULL)
			mountroothook_establish(ulpt_load_firmware, sc);
		else
			ulpt_load_firmware(sc);
	}
d472 1
a472 1
		ulpt_load_firmware(sc);
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.49 2015/02/10 21:56:09 miod Exp $ */
a218 1
	u_int8_t epcount;
a269 2
	epcount = 0;
	(void)usbd_endpoint_count(iface, &epcount);
d273 3
a275 1
	for (i = 0; i < epcount; i++) {
@


1.49
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.48 2014/10/19 16:35:53 stsp Exp $ */
a41 1
#include <sys/kernel.h>
@


1.48
log
@More gracefully handle firmware loading errors in ulpt(4).
The previous lack of error handling could trigger a kernel crash
in some situations, with ulptwrite being called while not ready.
ok deraadt phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.47 2014/07/12 20:26:33 mpi Exp $ */
d627 1
a627 1
		error = uiomove(bufp, n, uio);
@


1.47
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.46 2014/07/12 18:48:52 tedu Exp $ */
d103 1
d197 2
a198 1
	if (err != USBD_NORMAL_COMPLETION)
d201 2
d476 7
d654 1
a654 1
	if (usbd_is_dying(sc->sc_udev))
@


1.46
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.45 2013/11/07 13:11:10 pirofti Exp $ */
d157 10
a166 15
int ulpt_match(struct device *, void *, void *); 
void ulpt_attach(struct device *, struct device *, void *); 
int ulpt_detach(struct device *, int); 
int ulpt_activate(struct device *, int); 

struct cfdriver ulpt_cd = { 
	NULL, "ulpt", DV_DULL 
}; 

const struct cfattach ulpt_ca = { 
	sizeof(struct ulpt_softc), 
	ulpt_match, 
	ulpt_attach, 
	ulpt_detach, 
	ulpt_activate, 
a352 13
}

int
ulpt_activate(struct device *self, int act)
{
	struct ulpt_softc *sc = (struct ulpt_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.45
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.44 2013/09/20 15:34:51 mpi Exp $ */
d729 1
a729 1
	free(ucode, M_DEVBUF);
@


1.44
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.43 2013/04/15 09:23:02 mglocker Exp $ */
a105 1
	u_char sc_dying;
d268 1
a268 1
			sc->sc_dying = 1;
d296 1
a296 1
		sc->sc_dying = 1;
d367 1
a367 1
		sc->sc_dying = 1;
d484 1
a484 1
	if (sc == NULL || sc->sc_iface == NULL || sc->sc_dying)
d499 1
a499 1
		if (sc->sc_dying) {
d661 1
a661 1
	if (sc->sc_dying)
@


1.43
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.42 2013/03/28 03:58:03 tedu Exp $ */
d639 3
a641 2
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
			  USBD_NO_TIMEOUT, bufp, &n, "ulptwr");
d643 1
d709 3
a711 2
		error = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
			  USBD_NO_TIMEOUT, bufp, &len, "ulptwr");
d713 1
@


1.42
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.41 2013/01/28 17:15:31 stsp Exp $ */
d84 2
a85 2
	usbd_device_handle sc_udev;	/* device */
	usbd_interface_handle sc_iface;	/* interface */
d89 1
a89 1
	usbd_pipe_handle sc_out_pipe;	/* bulk out pipe */
d92 3
a94 3
	usbd_pipe_handle sc_in_pipe;	/* bulk in pipe */
	usbd_xfer_handle sc_in_xfer1;
	usbd_xfer_handle sc_in_xfer2;
d215 2
a216 2
	usbd_device_handle dev = uaa->device;
	usbd_interface_handle iface = uaa->iface;
d454 1
a454 1
ulpt_input(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d621 1
a621 1
	usbd_xfer_handle xfer;
d680 1
a680 1
	usbd_xfer_handle xfer;
@


1.41
log
@Make ulpt(4) upload firmware into HP LaserJet printers which require firmware.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.40 2011/09/17 08:36:06 miod Exp $ */
a41 1
#include <sys/proc.h>
@


1.40
log
@Don't bother keeping a {u,}lptioctl function which is a duplicate of
enodev().
ok jsing@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.39 2011/07/03 15:47:17 matthew Exp $ */
d49 2
d108 2
d119 32
d197 15
d316 9
d668 61
@


1.39
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.38 2011/01/25 20:03:36 jakemsr Exp $ */
a44 1
#include <sys/ioctl.h>
a607 13
	return (error);
}

int
ulptioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error = 0;

	switch (cmd) {
	default:
		error = ENODEV;
	}

@


1.38
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.37 2010/09/24 08:33:59 yuo Exp $ */
a308 3
	case DVACT_ACTIVATE:
		break;

@


1.37
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.36 2009/10/13 19:33:19 pirofti Exp $ */
a300 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);
a349 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.36
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.35 2008/10/09 01:07:02 deraadt Exp $ */
a329 1
	sc->sc_dying = 1;
@


1.35
log
@stop waiting for the printer to become ready, see PR 5427 for more
information.  Also explains PR 4124 and 5318
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.34 2008/06/26 05:42:18 ray Exp $ */
d127 1
a127 1
int ulpt_activate(struct device *, enum devact); 
d306 1
a306 1
ulpt_activate(struct device *self, enum devact act)
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.33 2007/10/11 18:33:15 deraadt Exp $ */
d428 1
a428 1
	int spin, error;
d449 1
a449 1
	if ((flags & ULPT_NOPRIME) == 0)
a450 16

	for (spin = 0; (ulpt_status(sc) & LPS_SELECT) == 0; spin += STEP) {
		DPRINTF(("ulpt_open: waiting a while\n"));
		if (spin >= TIMEOUT) {
			error = EBUSY;
			sc->sc_state = 0;
			goto done;
		}

		/* wait 1/4 second, give up if we get a signal */
		error = tsleep((caddr_t)sc, LPTPRI | PCATCH, "ulptop", STEP);
		if (error != EWOULDBLOCK) {
			sc->sc_state = 0;
			goto done;
		}

@


1.33
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.32 2007/06/14 10:11:16 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.31 2007/06/12 16:26:36 mbalmer Exp $ */
a178 1
	char *devinfop;
d185 2
a186 4
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s, iclass %d/%d\n", sc->sc_dev.dv_xname,
	       devinfop, ifcd->bInterfaceClass, ifcd->bInterfaceSubClass);
	usbd_devinfo_free(devinfop);
@


1.31
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.30 2007/06/11 16:30:31 mbalmer Exp $ */
d131 16
a146 1
USB_DECLARE_DRIVER(ulpt);
@


1.30
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.29 2007/06/11 12:36:52 mbalmer Exp $ */
d301 1
a301 1
ulpt_activate(device_ptr_t self, enum devact act)
@


1.29
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.28 2007/06/11 10:58:21 mbalmer Exp $ */
d418 1
a418 1
ulptopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d543 1
a543 1
ulptclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d633 1
a633 1
ulptioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.28
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.27 2007/06/10 14:49:01 mbalmer Exp $ */
d425 5
a429 1
	USB_GET_SC_OPEN(ulpt, ULPTUNIT(dev), sc);
@


1.27
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.26 2007/06/10 10:53:48 mbalmer Exp $ */
d543 1
a543 1
	USB_GET_SC(ulpt, ULPTUNIT(dev), sc);
d616 1
a616 1
	USB_GET_SC(ulpt, ULPTUNIT(dev), sc);
@


1.26
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.25 2007/06/06 19:25:49 mk Exp $ */
d172 1
a172 1
	printf("\n%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
d182 1
a182 1
		       USBDEVNAME(sc->sc_dev));
d214 1
a214 1
			       USBDEVNAME(sc->sc_dev));
d229 1
a229 1
			    USBDEVNAME(sc->sc_dev), i);
d242 1
a242 1
		    USBDEVNAME(sc->sc_dev));
d252 1
a252 1
	printf("%s: using %s-directional mode\n", USBDEVNAME(sc->sc_dev),
d280 1
a280 1
		printf("%s: cannot get device id\n", USBDEVNAME(sc->sc_dev));
d283 1
a283 1
		       USBDEVNAME(sc->sc_dev));
d290 1
a290 1
		printf("%s: device id <", USBDEVNAME(sc->sc_dev));
d529 1
a529 1
		log(LOG_NOTICE, "%s: offline\n", USBDEVNAME(sc->sc_dev));
d531 1
a531 1
		log(LOG_NOTICE, "%s: out of paper\n", USBDEVNAME(sc->sc_dev));
d533 1
a533 1
		log(LOG_NOTICE, "%s: output error\n", USBDEVNAME(sc->sc_dev));
@


1.25
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.24 2007/06/01 06:12:20 mbalmer Exp $ */
d297 1
a297 1
			   USBDEV(sc->sc_dev));
d335 1
a335 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d350 1
a350 1
			   USBDEV(sc->sc_dev));
d513 1
a513 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d624 1
a624 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.24
log
@Remove more Free(?)BSD and NetBSD #ifdef/#endifs.  No functional nor
binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.23 2007/05/27 04:00:25 jsg Exp $ */
d90 1
a90 1
	USBBASEDEVICE sc_dev;
@


1.23
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.22 2007/05/21 05:40:28 jsg Exp $ */
a50 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a52 5
#elif defined(__FreeBSD__)
#include <sys/ioccom.h>
#include <sys/module.h>
#include <sys/bus.h>
#endif
a113 5

#if defined(__FreeBSD__)
	dev_t dev;
	dev_t dev_noprime;
#endif
a115 38
#if defined(__NetBSD__)
dev_type_open(ulptopen);
dev_type_close(ulptclose);
dev_type_write(ulptwrite);
dev_type_ioctl(ulptioctl);

const struct cdevsw ulpt_cdevsw = {
	ulptopen, ulptclose, noread, ulptwrite, ulptioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
#elif defined(__FreeBSD__)
Static d_open_t ulptopen;
Static d_close_t ulptclose;
Static d_write_t ulptwrite;
Static d_ioctl_t ulptioctl;

#define ULPT_CDEV_MAJOR 113

Static struct cdevsw ulpt_cdevsw = {
	/* open */	ulptopen,
	/* close */	ulptclose,
	/* read */	noread,
	/* write */	ulptwrite,
	/* ioctl */	ulptioctl,
	/* poll */	nopoll,
	/* mmap */	nommap,
	/* strategy */	nostrategy,
	/* name */	"ulpt",
	/* maj */	ULPT_CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
	/* bmaj */	-1
#endif
};
#endif

a295 9

#if defined(__FreeBSD__)
	sc->dev = make_dev(&ulpt_cdevsw, device_get_unit(self),
		UID_ROOT, GID_OPERATOR, 0644, "ulpt%d", device_get_unit(self));
	sc->dev_noprime = make_dev(&ulpt_cdevsw,
		device_get_unit(self)|ULPT_NOPRIME,
		UID_ROOT, GID_OPERATOR, 0644, "unlpt%d", device_get_unit(self));
#endif

a299 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a314 1
#endif
a320 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a321 3
#elif defined(__FreeBSD__)
	struct vnode *vp;
#endif
a338 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a339 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ulpt_cdevsw);
#elif defined(__OpenBSD__)
a342 1
#endif
a347 11
#elif defined(__FreeBSD__)
	vp = SLIST_FIRST(&sc->dev->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
	vp = SLIST_FIRST(&sc->dev_noprime->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);

	destroy_dev(sc->dev);
	destroy_dev(sc->dev_noprime);
#endif
a436 8
#if defined(ULPT_DEBUG) && defined(__FreeBSD__)
	/* Ignoring these flags might not be a good idea */
	if ((flags & ~ULPT_NOPRIME) != 0)
		printf("ulptopen: flags ignored: %b\n", flags,
			"\20\3POS_INIT\4POS_ACK\6PRIME_OPEN\7AUTOLF\10BYPASS");
#endif


a662 4
#endif

#if defined(__FreeBSD__)
DRIVER_MODULE(ulpt, uhub, ulpt_driver, ulpt_devclass, usbd_driver_load, 0);
@


1.22
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.21 2006/06/23 06:27:11 miod Exp $ */
d182 2
a183 1
USB_MATCH(ulpt)
d185 1
a185 1
	USB_MATCH_START(ulpt, uaa);
d202 2
a203 1
USB_ATTACH(ulpt)
d205 2
a206 1
	USB_ATTACH_START(ulpt, sc, uaa);
d221 1
a221 2
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
d232 1
a232 1
		USB_ATTACH_ERROR_RETURN;
d265 1
a265 1
			USB_ATTACH_ERROR_RETURN;
d279 1
a279 1
			USB_ATTACH_ERROR_RETURN;
d293 1
a293 1
		USB_ATTACH_ERROR_RETURN;
a355 2

	USB_ATTACH_SUCCESS_RETURN;
d376 2
a377 1
USB_DETACH(ulpt)
d379 1
a379 1
	USB_DETACH_START(ulpt, sc);
@


1.21
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.20 2005/08/01 05:36:49 brad Exp $ */
d77 2
a78 2
#define DPRINTF(x)	do { if (ulptdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (ulptdebug>(n)) logprintf x; } while (0)
@


1.20
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.19 2004/07/08 22:18:44 deraadt Exp $ */
d366 1
a366 1
		return (EOPNOTSUPP);
@


1.19
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.18 2003/11/07 11:10:47 jmc Exp $ */
d210 1
a210 1
	char devinfo[1024];
d216 2
a217 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d220 2
a221 1
	       devinfo, ifcd->bInterfaceClass, ifcd->bInterfaceSubClass);
d323 2
a324 2
	USETW(req.wLength, sizeof devinfo - 1);
	err = usbd_do_request_flags(dev, &req, devinfo, USBD_SHORT_XFER_OK,
d332 4
a335 4
		/* devinfo now contains an IEEE-1284 device ID */
		len = ((devinfo[0] & 0xff) << 8) | (devinfo[1] & 0xff);
		if (len > sizeof devinfo - 3)
			len = sizeof devinfo - 3;
d338 1
a338 1
		ieee1284_print_id(devinfo+2);
@


1.18
log
@updated URLs from Jared Yanovich;

however, I did not apply the diff exactly. After hunting around I
found URLs for the missing files, and the ../index.html link appears
not to work. I replaced it with a more suitable link.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.17 2003/05/19 00:35:43 nate Exp $ */
d77 2
a78 2
#define DPRINTF(x)	if (ulptdebug) logprintf x
#define DPRINTFN(n,x)	if (ulptdebug>(n)) logprintf x
@


1.17
log
@don't use 1284 mode
When detaching a ulpt device, call vdevgone() for the corresponding
NOPRIME minor device too.

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.16 2003/05/07 04:33:33 deraadt Exp $ */
d44 1
a44 1
 *   http://www.usb.org/developers/data/devclass/usbprint11.pdf
@


1.16
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.15 2002/11/11 02:32:32 nate Exp $ */
/*	$NetBSD: ulpt.c,v 1.55 2002/10/23 09:14:01 jdolecek Exp $	*/
d245 2
a246 2
			    (id->bInterfaceProtocol == UIPROTO_PRINTER_BI ||
			     id->bInterfaceProtocol == UIPROTO_PRINTER_1284))
d413 1
@


1.15
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.14 2002/10/12 01:09:44 krw Exp $ */
d216 1
a216 1
	usbd_devinfo(dev, 0, devinfo);
@


1.14
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.13 2002/07/25 04:07:33 nate Exp $ */
/*	$NetBSD: ulpt.c,v 1.50 2002/07/11 21:14:31 augustss Exp $	*/
d128 9
a136 1
cdev_decl(ulpt);
d286 1
a286 1
		printf("%s: could not find bulk endpoint\n",
a290 2
	printf("%s: using %s-directional mode\n", USBDEVNAME(sc->sc_dev),
	       sc->sc_in >= 0 ? "bi" : "uni");
d297 3
a364 1
		break;
d402 3
d408 1
@


1.13
log
@update $NetBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.12 2002/07/25 02:18:10 nate Exp $ */
d227 1
a227 1
		panic("ulpt: iface desc out of range\n");
@


1.12
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.11 2002/07/10 21:41:51 mickey Exp $ */
/*	$NetBSD: ulpt.c,v 1.49 2002/02/25 22:39:01 augustss Exp $	*/
@


1.11
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.10 2002/05/07 18:08:04 nate Exp $ */
d178 1
a178 1
	
d206 1
a206 1
	
d213 1
a213 1
	/* XXX 
d669 1
a669 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY, 
@


1.10
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.9 2001/10/31 04:24:44 nate Exp $ */
d127 1
a127 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.9
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.8 2001/10/04 22:55:56 gluk Exp $ */
/*	$NetBSD: ulpt.c,v 1.43 2001/10/19 15:30:25 nathanw Exp $	*/
d43 2
a44 1
 * Printer Class spec: http://www.usb.org/developers/data/devclass/usbprint11.pdf
d151 1
d153 1
d313 2
a314 2
	err = usbd_do_request_flags(dev, &req, devinfo,USBD_SHORT_XFER_OK,
		  &alen);
d372 3
a375 2
	DPRINTF(("ulpt_detach: sc=%p flags=%d\n", sc, flags));
#elif defined(__FreeBSD__)
a376 1
#endif
d402 6
a407 1
	/* XXX not implemented yet */
a444 1
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
d456 1
d482 1
a482 1
ulptopen(dev_t dev, int flag, int mode, struct proc *p)
d557 8
d567 2
d611 1
a611 1
ulptclose(dev_t dev, int flag, int mode, struct proc *p)
d701 1
a701 1
ulptioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ulpt.c,v 1.49 2002/02/25 22:39:01 augustss Exp $	*/
d43 1
a43 2
 * Printer Class spec:
 *   http://www.usb.org/developers/data/devclass/usbprint11.pdf
a149 1
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
a150 1
#endif
d310 2
a311 2
	err = usbd_do_request_flags(dev, &req, devinfo, USBD_SHORT_XFER_OK,
		  &alen, USBD_DEFAULT_TIMEOUT);
d369 2
d372 1
a372 1
	struct vnode *vp;
a374 2
	DPRINTF(("ulpt_detach: sc=%p\n", sc));

d399 1
a399 6
	vp = SLIST_FIRST(&sc->dev->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
	vp = SLIST_FIRST(&sc->dev_noprime->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
d437 1
a448 1
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
d474 1
a474 1
ulptopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
a548 8
			if (sc->sc_in_xfer1 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer1);
				sc->sc_in_xfer1 = NULL;
			}
			if (sc->sc_in_xfer2 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer2);
				sc->sc_in_xfer2 = NULL;
			}
a550 2
			usbd_close_pipe(sc->sc_in_pipe);
			sc->sc_in_pipe = NULL;
d593 1
a593 1
ulptclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d683 1
a683 1
ulptioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.9.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: ulpt.c,v 1.50 2002/07/11 21:14:31 augustss Exp $	*/
d127 1
a127 1
#if defined(__NetBSD__)
d178 1
a178 1

d206 1
a206 1

d213 1
a213 1
	/* XXX
d227 1
a227 1
		panic("ulpt: iface desc out of range");
d669 1
a669 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
@


1.9.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: ulpt.c,v 1.55 2002/10/23 09:14:01 jdolecek Exp $	*/
d128 1
a128 9
dev_type_open(ulptopen);
dev_type_close(ulptclose);
dev_type_write(ulptwrite);
dev_type_ioctl(ulptioctl);

const struct cdevsw ulpt_cdevsw = {
	ulptopen, ulptclose, noread, ulptwrite, ulptioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
d208 1
a208 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d278 1
a278 1
		printf("%s: could not find bulk out endpoint\n",
d283 2
a290 3
	printf("%s: using %s-directional mode\n", USBDEVNAME(sc->sc_dev),
	       sc->sc_in >= 0 ? "bi" : "uni");

d356 1
a393 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ulpt_cdevsw);
#elif defined(__OpenBSD__)
a396 1
#endif
@


1.8
log
@Match a IEEE 1284.4 protocol. We do not support this protocol directly,
but USB_ATTACH will switch printer to bidirectional protocol.
Read status from printer. From NetBSD.
This forces newest usb printers works.
Tested by drahn@@ (Epson 740) and me (HP LaserJet 2200).
Ok aaron@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.7 2001/05/03 02:20:34 aaron Exp $ */
/*	$NetBSD: ulpt.c,v 1.42 2001/04/16 00:18:06 augustss Exp $	*/
d101 1
a101 1
	usbd_pipe_handle sc_out_pipe;   /* bulk out pipe */
d185 1
a185 1
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_IEEE_1284_4)))
d234 2
a235 1
			    id->bInterfaceProtocol == UIPROTO_PRINTER_BI)
d240 1
a240 1
	id = ifcd;              /* not found, use original */
@


1.7
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.6 2001/01/28 09:43:42 aaron Exp $ */
d43 1
a43 1
 * Printer Class spec: http://www.usb.org/developers/data/devclass/usbprint109.PDF
d183 3
a185 2
	    (id->bInterfaceProtocol == UIPROTO_PRINTER_UNI ||
	     id->bInterfaceProtocol == UIPROTO_PRINTER_BI))
d417 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: ulpt.c,v 1.38 2000/06/01 14:29:00 augustss Exp $	*/
d99 9
a107 2
	usbd_pipe_handle sc_bulkpipe;	/* bulk pipe */
	int sc_bulk;
d161 1
d163 1
d194 4
a197 1
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
d200 2
a201 1
	usbd_status err;
d207 1
a207 1
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
d209 28
a236 13
	/* Figure out which endpoint is the bulk out endpoint. */
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL)
		goto nobulk;
	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_OUT ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_BULK) {
		/* In case we are using a bidir protocol... */
		ed = usbd_interface2endpoint_descriptor(iface, 1);
		if (ed == NULL)
			goto nobulk;
		if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_OUT ||
		    (ed->bmAttributes & UE_XFERTYPE) != UE_BULK)
			goto nobulk;
d238 16
a253 2
	sc->sc_bulk = ed->bEndpointAddress;
	DPRINTFN(10, ("ulpt_attach: bulk=%d\n", sc->sc_bulk));
d255 20
a274 3
	sc->sc_iface = iface;
	err = usbd_interface2device_handle(iface, &sc->sc_udev);
	if (err) {
d278 11
d290 1
a339 5

 nobulk:
	printf("%s: could not find bulk endpoint\n", USBDEVNAME(sc->sc_dev));
	sc->sc_dying = 1;
	USB_ATTACH_ERROR_RETURN;
d374 4
a377 2
	if (sc->sc_bulkpipe != NULL)
		usbd_abort_pipe(sc->sc_bulkpipe);
a415 1
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
d442 1
a442 1
	 * request type as UT_WRITE_CLASS_OTHER, it should have been
d446 1
a446 1
	if (usbd_do_request(sc->sc_udev, &req, 0)) {
d448 1
a448 1
		(void)usbd_do_request(sc->sc_udev, &req, 0);
d452 15
d505 1
d526 1
a526 1
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulk, 0, &sc->sc_bulkpipe);
d532 27
d600 17
a616 2
	usbd_close_pipe(sc->sc_bulkpipe);
	sc->sc_bulkpipe = 0;
d648 1
a648 1
		err = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, 
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ulpt.c,v 1.42 2001/04/16 00:18:06 augustss Exp $	*/
d99 2
a100 9

	int sc_out;
	usbd_pipe_handle sc_out_pipe;   /* bulk out pipe */

	int sc_in;
	usbd_pipe_handle sc_in_pipe;	/* bulk in pipe */
	usbd_xfer_handle sc_in_xfer1;
	usbd_xfer_handle sc_in_xfer2;
	u_char sc_junk[64];	/* somewhere to dump input */
a153 1
#if 0
a154 1
#endif
d185 1
a185 4
	usb_interface_descriptor_t *ifcd = usbd_get_interface_descriptor(iface);
	usb_interface_descriptor_t *id, *iend;
	usb_config_descriptor_t *cdesc;
	usbd_status err;
d188 1
a188 2
	u_int8_t epcount;
	int i, altno;
d194 1
a194 1
	       devinfo, ifcd->bInterfaceClass, ifcd->bInterfaceSubClass);
d196 13
a208 41
	/* XXX 
	 * Stepping through the alternate settings needs to be abstracted out.
	 */
	cdesc = usbd_get_config_descriptor(dev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
	iend = (usb_interface_descriptor_t *)
		   ((char *)cdesc + UGETW(cdesc->wTotalLength));
#ifdef DIAGNOSTIC
	if (ifcd < (usb_interface_descriptor_t *)cdesc ||
	    ifcd >= iend)
		panic("ulpt: iface desc out of range\n");
#endif
	/* Step through all the descriptors looking for bidir mode */
	for (id = ifcd, altno = 0;
	     id < iend;
	     id = (void *)((char *)id + id->bLength)) {
		if (id->bDescriptorType == UDESC_INTERFACE &&
		    id->bInterfaceNumber == ifcd->bInterfaceNumber) {
			if (id->bInterfaceClass == UICLASS_PRINTER &&
			    id->bInterfaceSubClass == UISUBCLASS_PRINTER &&
			    id->bInterfaceProtocol == UIPROTO_PRINTER_BI)
				goto found;
			altno++;
		}
	}
	id = ifcd;              /* not found, use original */
 found:
	if (id != ifcd) {
		/* Found a new bidir setting */
		DPRINTF(("ulpt_attach: set altno = %d\n", altno));
		err = usbd_set_interface(iface, altno);
		if (err) {
			printf("%s: setting alternate interface failed\n",
			       USBDEVNAME(sc->sc_dev));
			sc->sc_dying = 1;
			USB_ATTACH_ERROR_RETURN;
		}
d210 2
d213 3
a215 23
	epcount = 0;
	(void)usbd_endpoint_count(iface, &epcount);

	sc->sc_in = -1;
	sc->sc_out = -1;
	for (i = 0; i < epcount; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    USBDEVNAME(sc->sc_dev), i);
			USB_ATTACH_ERROR_RETURN;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_in = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_out = ed->bEndpointAddress;
		}
	}
	if (sc->sc_out == -1) {
		printf("%s: could not find bulk endpoint\n",
		    USBDEVNAME(sc->sc_dev));
a218 11
	printf("%s: using %s-directional mode\n", USBDEVNAME(sc->sc_dev),
	       sc->sc_in >= 0 ? "bi" : "uni");

	if (usbd_get_quirks(dev)->uq_flags & UQ_BROKEN_BIDIR) {
		/* This device doesn't handle reading properly. */
		sc->sc_in = -1;
	}

	DPRINTFN(10, ("ulpt_attach: bulk=%d\n", sc->sc_out));

	sc->sc_iface = iface;
a219 1
	sc->sc_udev = dev;
d269 5
d308 2
a309 4
	if (sc->sc_out_pipe != NULL)
		usbd_abort_pipe(sc->sc_out_pipe);
	if (sc->sc_in_pipe != NULL)
		usbd_abort_pipe(sc->sc_in_pipe);
d348 1
d375 1
a375 1
	 * request type as UT_WRITE_CLASS_OTHER; it should have been
d379 1
a379 1
	if (usbd_do_request(sc->sc_udev, &req, 0)) {	/* 1.0 */
d381 1
a381 1
		(void)usbd_do_request(sc->sc_udev, &req, 0); /* 1.1 */
a384 15
static void
ulpt_input(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
{
	struct ulpt_softc *sc = priv;

	DPRINTFN(2,("ulpt_input: got some data\n"));
	/* Do it again. */
	if (xfer == sc->sc_in_xfer1)
		usbd_transfer(sc->sc_in_xfer2);
	else
		usbd_transfer(sc->sc_in_xfer1);
}

int ulptusein = 1;

a422 1
		DPRINTF(("ulpt_open: waiting a while\n"));
d443 1
a443 1
	err = usbd_open_pipe(sc->sc_iface, sc->sc_out, 0, &sc->sc_out_pipe);
a448 27
	if (ulptusein && sc->sc_in != -1) {
		DPRINTF(("ulpt_open: open input pipe\n"));
		err = usbd_open_pipe(sc->sc_iface, sc->sc_in,0,&sc->sc_in_pipe);
		if (err) {
			error = EIO;
			usbd_close_pipe(sc->sc_out_pipe);
			sc->sc_out_pipe = NULL;
			sc->sc_state = 0;
			goto done;
		}
		sc->sc_in_xfer1 = usbd_alloc_xfer(sc->sc_udev);
		sc->sc_in_xfer2 = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_in_xfer1 == NULL || sc->sc_in_xfer2 == NULL) {
			error = ENOMEM;
			usbd_close_pipe(sc->sc_out_pipe);
			sc->sc_out_pipe = NULL;
			sc->sc_state = 0;
			goto done;
		}
		usbd_setup_xfer(sc->sc_in_xfer1, sc->sc_in_pipe, sc,
		    sc->sc_junk, sizeof sc->sc_junk, USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, ulpt_input);
		usbd_setup_xfer(sc->sc_in_xfer2, sc->sc_in_pipe, sc,
		    sc->sc_junk, sizeof sc->sc_junk, USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, ulpt_input);
		usbd_transfer(sc->sc_in_xfer1); /* ignore failed start */
	}
d490 2
a491 17
	if (sc->sc_out_pipe != NULL) {
		usbd_close_pipe(sc->sc_out_pipe);
		sc->sc_out_pipe = NULL;
	}
	if (sc->sc_in_pipe != NULL) {
		usbd_abort_pipe(sc->sc_in_pipe);
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
		if (sc->sc_in_xfer1 != NULL) {
			usbd_free_xfer(sc->sc_in_xfer1);
			sc->sc_in_xfer1 = NULL;
		}
		if (sc->sc_in_xfer2 != NULL) {
			usbd_free_xfer(sc->sc_in_xfer2);
			sc->sc_in_xfer2 = NULL;
		}
	}
d523 1
a523 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY, 
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.7.2.2 2001/07/04 10:43:57 niklas Exp $ */
d43 1
a43 1
 * Printer Class spec: http://www.usb.org/developers/data/devclass/usbprint11.pdf
d183 2
a184 3
	    ((id->bInterfaceProtocol == UIPROTO_PRINTER_UNI) ||
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_BI) ||
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_IEEE_1284_4)))
a415 1
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
@


1.7.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ulpt.c,v 1.43 2001/10/19 15:30:25 nathanw Exp $	*/
d101 1
a101 1
	usbd_pipe_handle sc_out_pipe;	/* bulk out pipe */
d185 1
a185 1
	     (id->bInterfaceProtocol == UIPROTO_PRINTER_1284)))
d234 1
a234 2
			    (id->bInterfaceProtocol == UIPROTO_PRINTER_BI ||
			     id->bInterfaceProtocol == UIPROTO_PRINTER_1284))
d239 1
a239 1
	id = ifcd;		/* not found, use original */
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: ulpt.c,v 1.55 2002/10/23 09:14:01 jdolecek Exp $	*/
d43 1
a43 2
 * Printer Class spec:
 *   http://www.usb.org/developers/data/devclass/usbprint11.pdf
d126 2
a127 10
#if defined(__NetBSD__)
dev_type_open(ulptopen);
dev_type_close(ulptclose);
dev_type_write(ulptwrite);
dev_type_ioctl(ulptioctl);

const struct cdevsw ulpt_cdevsw = {
	ulptopen, ulptclose, noread, ulptwrite, ulptioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
a149 1
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
a150 1
#endif
d175 1
a175 1

d203 1
a203 1

d210 1
a210 1
	/* XXX
d224 1
a224 1
		panic("ulpt: iface desc out of range");
d275 1
a275 1
		printf("%s: could not find bulk out endpoint\n",
d280 2
a287 3
	printf("%s: using %s-directional mode\n", USBDEVNAME(sc->sc_dev),
	       sc->sc_in >= 0 ? "bi" : "uni");

d310 2
a311 2
	err = usbd_do_request_flags(dev, &req, devinfo, USBD_SHORT_XFER_OK,
		  &alen, USBD_DEFAULT_TIMEOUT);
d353 1
d369 2
d372 1
a372 1
	struct vnode *vp;
a374 2
	DPRINTF(("ulpt_detach: sc=%p\n", sc));

a390 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ulpt_cdevsw);
#elif defined(__OpenBSD__)
a393 1
#endif
d399 1
a399 6
	vp = SLIST_FIRST(&sc->dev->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
	vp = SLIST_FIRST(&sc->dev_noprime->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
d437 1
a448 1
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
d474 1
a474 1
ulptopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
a548 8
			if (sc->sc_in_xfer1 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer1);
				sc->sc_in_xfer1 = NULL;
			}
			if (sc->sc_in_xfer2 != NULL) {
				usbd_free_xfer(sc->sc_in_xfer2);
				sc->sc_in_xfer2 = NULL;
			}
a550 2
			usbd_close_pipe(sc->sc_in_pipe);
			sc->sc_in_pipe = NULL;
d593 1
a593 1
ulptclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d651 1
a651 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
d683 1
a683 1
ulptioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.7.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.7.2.5 2003/03/28 00:38:32 niklas Exp $ */
d216 1
a216 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.7.2.7
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ulpt.c,v 1.57 2003/01/05 10:19:42 scw Exp $	*/
d245 2
a246 2
			    (id->bInterfaceProtocol == UIPROTO_PRINTER_BI /*||
			     id->bInterfaceProtocol == UIPROTO_PRINTER_1284*/))
a412 1
	vdevgone(maj, mn | ULPT_NOPRIME , mn | ULPT_NOPRIME, VCHR);
@


1.7.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 1
a44 1
 *   http://www.usb.org/developers/devclass_docs/usbprint11.pdf
@


1.6
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.5 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: ulpt.c,v 1.38 2000/06/01 14:29:00 augustss Exp $	*/
d99 9
a107 2
	usbd_pipe_handle sc_bulkpipe;	/* bulk pipe */
	int sc_bulk;
d161 1
d163 1
d194 4
a197 1
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
d200 2
a201 1
	usbd_status err;
d207 1
a207 1
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
d209 28
a236 13
	/* Figure out which endpoint is the bulk out endpoint. */
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL)
		goto nobulk;
	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_OUT ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_BULK) {
		/* In case we are using a bidir protocol... */
		ed = usbd_interface2endpoint_descriptor(iface, 1);
		if (ed == NULL)
			goto nobulk;
		if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_OUT ||
		    (ed->bmAttributes & UE_XFERTYPE) != UE_BULK)
			goto nobulk;
d238 16
a253 2
	sc->sc_bulk = ed->bEndpointAddress;
	DPRINTFN(10, ("ulpt_attach: bulk=%d\n", sc->sc_bulk));
d255 20
a274 3
	sc->sc_iface = iface;
	err = usbd_interface2device_handle(iface, &sc->sc_udev);
	if (err) {
d278 11
d290 1
a339 5

 nobulk:
	printf("%s: could not find bulk endpoint\n", USBDEVNAME(sc->sc_dev));
	sc->sc_dying = 1;
	USB_ATTACH_ERROR_RETURN;
d374 4
a377 2
	if (sc->sc_bulkpipe != NULL)
		usbd_abort_pipe(sc->sc_bulkpipe);
a415 1
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
d442 1
a442 1
	 * request type as UT_WRITE_CLASS_OTHER, it should have been
d446 1
a446 1
	if (usbd_do_request(sc->sc_udev, &req, 0)) {
d448 1
a448 1
		(void)usbd_do_request(sc->sc_udev, &req, 0);
d452 15
d505 1
d526 1
a526 1
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulk, 0, &sc->sc_bulkpipe);
d532 27
d600 17
a616 2
	usbd_close_pipe(sc->sc_bulkpipe);
	sc->sc_bulkpipe = 0;
d648 1
a648 1
		err = usbd_bulk_transfer(xfer, sc->sc_bulkpipe, USBD_NO_COPY, 
@


1.5
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.4 2000/07/04 11:44:24 fgsch Exp $ */
d43 1
a43 1
 * Printer Class spec: http://www.usb.org/developers/data/usbprn10.pdf
d372 11
a382 1
	(void)usbd_do_request(sc->sc_udev, &req, 0);
d416 3
d424 1
d426 1
a426 1
			return (EBUSY);
d433 7
a439 1
			return (error);
d446 2
a447 1
		return (EIO);
d452 6
a457 2
	DPRINTF(("ulptopen: done\n"));
	return (0);
@


1.4
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.3 2000/04/14 22:50:27 aaron Exp $ */
/*	$NetBSD: ulpt.c,v 1.36 2000/04/14 14:12:11 augustss Exp $	*/
d147 1
a147 1
void ulpt_disco __P((void *));
d149 4
a152 4
int ulpt_do_write __P((struct ulpt_softc *, struct uio *uio, int));
int ulpt_status __P((struct ulpt_softc *));
void ulpt_reset __P((struct ulpt_softc *));
int ulpt_statusmsg __P((u_char, struct ulpt_softc *));
d154 1
a154 1
void ieee1284_print_id __P((char *));
d278 1
a278 3
ulpt_activate(self, act)
	device_ptr_t self;
	enum devact act;
d342 1
a342 2
ulpt_status(sc)
	struct ulpt_softc *sc;
d362 1
a362 2
ulpt_reset(sc)
	struct ulpt_softc *sc;
d379 1
a379 5
ulptopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d436 1
a436 3
ulpt_statusmsg(status, sc)
	u_char status;
	struct ulpt_softc *sc;
d455 1
a455 5
ulptclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d475 1
a475 4
ulpt_do_write(sc, uio, flags)
	struct ulpt_softc *sc;
	struct uio *uio;
	int flags;
d512 1
a512 4
ulptwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d530 1
a530 6
ulptioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d548 1
a548 2
ieee1284_print_id(str)
	char *str;
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ulpt.c,v 1.2 2000/03/30 16:19:33 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.2
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: ulpt.c,v 1.1 2000/03/28 19:37:50 aaron Exp $ */
/*	$NetBSD: ulpt.c,v 1.35 2000/03/29 18:24:53 augustss Exp $	*/
d223 1
a223 1
 * This code is disabled because for some mysterious it causes
@


1.1
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ulpt.c,v 1.33 2000/03/06 20:58:39 augustss Exp $	*/
d122 4
a125 4
static d_open_t ulptopen;
static d_close_t ulptclose;
static d_write_t ulptwrite;
static d_ioctl_t ulptioctl;
d129 1
a129 1
static struct cdevsw ulpt_cdevsw = {
@

