head	1.192;
access;
symbols
	OPENBSD_6_0:1.192.0.4
	OPENBSD_6_0_BASE:1.192
	OPENBSD_5_9:1.183.0.2
	OPENBSD_5_9_BASE:1.183
	OPENBSD_5_8:1.181.0.4
	OPENBSD_5_8_BASE:1.181
	OPENBSD_5_7:1.179.0.2
	OPENBSD_5_7_BASE:1.179
	OPENBSD_5_6:1.175.0.4
	OPENBSD_5_6_BASE:1.175
	OPENBSD_5_5:1.174.0.4
	OPENBSD_5_5_BASE:1.174
	OPENBSD_5_4:1.172.0.2
	OPENBSD_5_4_BASE:1.172
	OPENBSD_5_3:1.167.0.4
	OPENBSD_5_3_BASE:1.167
	OPENBSD_5_2:1.167.0.2
	OPENBSD_5_2_BASE:1.167
	OPENBSD_5_1_BASE:1.166
	OPENBSD_5_1:1.166.0.2
	OPENBSD_5_0:1.164.0.2
	OPENBSD_5_0_BASE:1.164
	OPENBSD_4_9:1.149.0.2
	OPENBSD_4_9_BASE:1.149
	OPENBSD_4_8:1.136.0.2
	OPENBSD_4_8_BASE:1.136
	OPENBSD_4_7:1.130.0.2
	OPENBSD_4_7_BASE:1.130
	OPENBSD_4_6:1.126.0.4
	OPENBSD_4_6_BASE:1.126
	OPENBSD_4_5:1.121.0.2
	OPENBSD_4_5_BASE:1.121
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75;
locks; strict;
comment	@ * @;


1.192
date	2016.06.17.07.59.16;	author mglocker;	state Exp;
branches;
next	1.191;
commitid	vNgcdJwdDXyBeL03;

1.191
date	2016.06.15.11.40.56;	author mpi;	state Exp;
branches;
next	1.190;
commitid	Z0i3dXyuhTNQjNc5;

1.190
date	2016.06.14.04.54.33;	author mglocker;	state Exp;
branches;
next	1.189;
commitid	6wNwgRCAZjqS1COF;

1.189
date	2016.06.01.12.58.59;	author mglocker;	state Exp;
branches;
next	1.188;
commitid	BYBEMATViUtOy0fI;

1.188
date	2016.05.28.06.26.49;	author mglocker;	state Exp;
branches;
next	1.187;
commitid	33guq0H7UmfOv0Mf;

1.187
date	2016.05.26.04.47.08;	author mglocker;	state Exp;
branches;
next	1.186;
commitid	hhVjYpfSVngRaSJX;

1.186
date	2016.05.20.19.25.53;	author mglocker;	state Exp;
branches;
next	1.185;
commitid	4Vv7amOkw6nwdtQX;

1.185
date	2016.05.17.08.27.17;	author kettenis;	state Exp;
branches;
next	1.184;
commitid	bMtR3SLieCl8i8iQ;

1.184
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.183;
commitid	gAjwyca5TfuoJAhn;

1.183
date	2015.12.20.10.08.05;	author mpi;	state Exp;
branches
	1.183.2.1;
next	1.182;
commitid	SR6nMKbuhIh9nOvY;

1.182
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.181;
commitid	fbhqfhfdKxBcsetK;

1.181
date	2015.07.09.14.58.32;	author mpi;	state Exp;
branches
	1.181.4.1;
next	1.180;
commitid	FD53NNEpFSdy0VGJ;

1.180
date	2015.06.24.20.17.28;	author miod;	state Exp;
branches;
next	1.179;
commitid	BnS8OzsAxIOX7xH6;

1.179
date	2015.01.06.17.27.58;	author armani;	state Exp;
branches;
next	1.178;
commitid	7EsHTXl2td16LPGq;

1.178
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.177;
commitid	Qb045HZ5OhQfU69H;

1.177
date	2014.10.23.07.34.48;	author brad;	state Exp;
branches;
next	1.176;
commitid	DEXkrYThWW1dQLLe;

1.176
date	2014.10.18.08.01.34;	author armani;	state Exp;
branches;
next	1.175;
commitid	cdW1SBgN6rVYvZes;

1.175
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.174;
commitid	OBNa5kfxQ2UXoiIw;

1.174
date	2014.01.22.03.21.23;	author jsg;	state Exp;
branches;
next	1.173;

1.173
date	2013.11.07.11.14.26;	author pirofti;	state Exp;
branches;
next	1.172;

1.172
date	2013.04.26.14.53.19;	author mpi;	state Exp;
branches;
next	1.171;

1.171
date	2013.04.26.13.46.40;	author mglocker;	state Exp;
branches;
next	1.170;

1.170
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.169;

1.169
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.168;

1.168
date	2013.03.28.03.31.56;	author tedu;	state Exp;
branches;
next	1.167;

1.167
date	2012.06.18.15.43.30;	author mpi;	state Exp;
branches;
next	1.166;

1.166
date	2011.10.28.12.48.31;	author mglocker;	state Exp;
branches;
next	1.165;

1.165
date	2011.09.18.23.24.12;	author krw;	state Exp;
branches;
next	1.164;

1.164
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.163;

1.163
date	2011.06.23.22.03.43;	author oga;	state Exp;
branches;
next	1.162;

1.162
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.161;

1.161
date	2011.04.11.02.04.48;	author jakemsr;	state Exp;
branches;
next	1.160;

1.160
date	2011.04.04.17.38.24;	author jakemsr;	state Exp;
branches;
next	1.159;

1.159
date	2011.03.31.22.13.12;	author jakemsr;	state Exp;
branches;
next	1.158;

1.158
date	2011.03.26.19.50.52;	author jakemsr;	state Exp;
branches;
next	1.157;

1.157
date	2011.03.26.08.24.52;	author jakemsr;	state Exp;
branches;
next	1.156;

1.156
date	2011.03.26.08.21.27;	author jakemsr;	state Exp;
branches;
next	1.155;

1.155
date	2011.03.26.08.15.07;	author jakemsr;	state Exp;
branches;
next	1.154;

1.154
date	2011.03.26.08.13.05;	author jakemsr;	state Exp;
branches;
next	1.153;

1.153
date	2011.03.26.07.57.42;	author jakemsr;	state Exp;
branches;
next	1.152;

1.152
date	2011.03.25.23.19.41;	author jakemsr;	state Exp;
branches;
next	1.151;

1.151
date	2011.03.25.21.23.54;	author jakemsr;	state Exp;
branches;
next	1.150;

1.150
date	2011.03.25.20.05.20;	author jakemsr;	state Exp;
branches;
next	1.149;

1.149
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.148;

1.148
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.147;

1.147
date	2010.11.24.19.53.07;	author jakemsr;	state Exp;
branches;
next	1.146;

1.146
date	2010.10.23.15.42.10;	author jakemsr;	state Exp;
branches;
next	1.145;

1.145
date	2010.10.18.23.25.31;	author jakemsr;	state Exp;
branches;
next	1.144;

1.144
date	2010.10.18.23.20.15;	author jakemsr;	state Exp;
branches;
next	1.143;

1.143
date	2010.10.18.23.12.40;	author jakemsr;	state Exp;
branches;
next	1.142;

1.142
date	2010.10.09.09.48.03;	author jakemsr;	state Exp;
branches;
next	1.141;

1.141
date	2010.10.09.08.41.28;	author jakemsr;	state Exp;
branches;
next	1.140;

1.140
date	2010.10.08.21.41.44;	author jakemsr;	state Exp;
branches;
next	1.139;

1.139
date	2010.09.29.09.33.26;	author jakemsr;	state Exp;
branches;
next	1.138;

1.138
date	2010.09.26.23.44.51;	author jakemsr;	state Exp;
branches;
next	1.137;

1.137
date	2010.09.12.22.27.52;	author jakemsr;	state Exp;
branches;
next	1.136;

1.136
date	2010.07.26.22.17.13;	author mk;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.26.07.12.21;	author mglocker;	state Exp;
branches;
next	1.134;

1.134
date	2010.07.26.07.01.08;	author mglocker;	state Exp;
branches;
next	1.133;

1.133
date	2010.07.15.04.46.33;	author mglocker;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.14.21.24.33;	author jakemsr;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.27.03.38.34;	author marco;	state Exp;
branches;
next	1.130;

1.130
date	2009.11.24.19.08.33;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2009.10.26.15.34.16;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.127;

1.127
date	2009.09.07.19.06.43;	author miod;	state Exp;
branches;
next	1.126;

1.126
date	2009.06.28.17.01.17;	author mglocker;	state Exp;
branches;
next	1.125;

1.125
date	2009.04.18.07.30.50;	author mk;	state Exp;
branches;
next	1.124;

1.124
date	2009.03.29.16.45.35;	author mglocker;	state Exp;
branches;
next	1.123;

1.123
date	2009.03.28.09.18.28;	author mglocker;	state Exp;
branches;
next	1.122;

1.122
date	2009.03.25.09.25.42;	author mglocker;	state Exp;
branches;
next	1.121;

1.121
date	2009.02.27.06.00.31;	author mglocker;	state Exp;
branches;
next	1.120;

1.120
date	2009.02.21.08.18.13;	author mglocker;	state Exp;
branches;
next	1.119;

1.119
date	2009.02.20.08.34.48;	author mglocker;	state Exp;
branches;
next	1.118;

1.118
date	2009.02.20.08.24.07;	author mglocker;	state Exp;
branches;
next	1.117;

1.117
date	2009.02.20.07.24.11;	author mglocker;	state Exp;
branches;
next	1.116;

1.116
date	2009.02.19.21.17.34;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2009.02.06.14.24.44;	author mglocker;	state Exp;
branches;
next	1.114;

1.114
date	2008.12.22.20.51.18;	author mglocker;	state Exp;
branches;
next	1.113;

1.113
date	2008.12.22.13.33.43;	author mglocker;	state Exp;
branches;
next	1.112;

1.112
date	2008.12.22.09.45.46;	author mglocker;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.22.09.34.46;	author mglocker;	state Exp;
branches;
next	1.110;

1.110
date	2008.12.17.18.14.46;	author mglocker;	state Exp;
branches;
next	1.109;

1.109
date	2008.12.17.08.39.01;	author mglocker;	state Exp;
branches;
next	1.108;

1.108
date	2008.12.14.07.38.41;	author ray;	state Exp;
branches;
next	1.107;

1.107
date	2008.12.10.21.20.47;	author mglocker;	state Exp;
branches;
next	1.106;

1.106
date	2008.12.10.11.43.18;	author mglocker;	state Exp;
branches;
next	1.105;

1.105
date	2008.12.10.08.19.23;	author yuo;	state Exp;
branches;
next	1.104;

1.104
date	2008.12.09.06.01.41;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2008.12.08.22.02.39;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2008.12.08.18.54.32;	author mglocker;	state Exp;
branches;
next	1.101;

1.101
date	2008.12.08.18.33.24;	author mglocker;	state Exp;
branches;
next	1.100;

1.100
date	2008.12.06.20.06.39;	author mglocker;	state Exp;
branches;
next	1.99;

1.99
date	2008.12.04.07.22.10;	author yuo;	state Exp;
branches;
next	1.98;

1.98
date	2008.12.03.08.32.18;	author mglocker;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.03.05.18.29;	author mglocker;	state Exp;
branches;
next	1.96;

1.96
date	2008.12.03.03.47.25;	author yuo;	state Exp;
branches;
next	1.95;

1.95
date	2008.12.03.03.38.53;	author yuo;	state Exp;
branches;
next	1.94;

1.94
date	2008.12.03.03.28.25;	author yuo;	state Exp;
branches;
next	1.93;

1.93
date	2008.11.30.15.20.33;	author mglocker;	state Exp;
branches;
next	1.92;

1.92
date	2008.11.24.23.25.33;	author mglocker;	state Exp;
branches;
next	1.91;

1.91
date	2008.11.10.11.54.39;	author mglocker;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.09.21.24.55;	author mglocker;	state Exp;
branches;
next	1.89;

1.89
date	2008.11.09.20.14.06;	author mglocker;	state Exp;
branches;
next	1.88;

1.88
date	2008.11.06.21.07.13;	author mglocker;	state Exp;
branches;
next	1.87;

1.87
date	2008.10.26.21.11.02;	author mglocker;	state Exp;
branches;
next	1.86;

1.86
date	2008.10.04.11.54.43;	author mglocker;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.24.19.46.45;	author mglocker;	state Exp;
branches;
next	1.84;

1.84
date	2008.08.24.11.43.00;	author mglocker;	state Exp;
branches;
next	1.83;

1.83
date	2008.08.24.11.05.02;	author mglocker;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.16.18.56.07;	author mglocker;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.13.20.29.34;	author mglocker;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.12.08.26.42;	author mglocker;	state Exp;
branches;
next	1.79;

1.79
date	2008.08.11.05.37.01;	author mglocker;	state Exp;
branches;
next	1.78;

1.78
date	2008.08.10.10.01.25;	author mglocker;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.09.08.42.03;	author mglocker;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.09.07.57.48;	author mglocker;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.02.21.52.37;	author mglocker;	state Exp;
branches;
next	1.74;

1.74
date	2008.08.02.20.08.49;	author mglocker;	state Exp;
branches;
next	1.73;

1.73
date	2008.08.02.20.05.28;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.02.17.30.31;	author mglocker;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.02.16.34.45;	author mglocker;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.02.12.32.23;	author mglocker;	state Exp;
branches;
next	1.69;

1.69
date	2008.08.02.08.51.25;	author mglocker;	state Exp;
branches;
next	1.68;

1.68
date	2008.08.01.12.16.52;	author mglocker;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.01.08.20.26;	author mglocker;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.31.15.26.25;	author mglocker;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.29.13.45.04;	author mglocker;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.26.11.42.43;	author mglocker;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.25.17.20.27;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.25.11.12.34;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.24.13.30.10;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2008.07.23.14.10.58;	author mglocker;	state Exp;
branches;
next	1.59;

1.59
date	2008.07.22.16.24.40;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2008.07.22.11.02.17;	author mglocker;	state Exp;
branches;
next	1.57;

1.57
date	2008.07.22.10.57.15;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2008.07.19.11.30.55;	author mglocker;	state Exp;
branches;
next	1.55;

1.55
date	2008.07.18.21.45.24;	author mglocker;	state Exp;
branches;
next	1.54;

1.54
date	2008.07.18.18.49.11;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2008.07.14.19.57.36;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2008.07.14.04.45.50;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2008.07.13.12.48.40;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.13.11.49.31;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.10.04.49.12;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.07.18.07.51;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.06.13.50.36;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.03.09.50.04;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.02.21.28.50;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.01.11.02.44;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.30.16.48.49;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.26.21.00.27;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.23.04.58.00;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.22.20.58.17;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2008.06.15.17.07.18;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.15.16.58.57;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.15.11.08.57;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.15.03.44.31;	author robert;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.13.18.04.56;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.12.22.16.16;	author robert;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.11.01.27.31;	author robert;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.11.00.00.37;	author robert;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.10.23.39.01;	author robert;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.10.06.08.22;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.09.20.51.31;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.09.05.49.10;	author robert;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.08.20.11.30;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.08.00.18.33;	author robert;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.07.22.14.57;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.06.19.14.45;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.05.20.50.28;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.30.06.37.38;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.27.18.19.37;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.27.17.47.28;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2008.05.26.17.51.18;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.25.07.47.47;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2008.05.24.19.37.34;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2008.05.18.09.35.35;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.05.18.07.20.09;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.16.12.01.51;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.16.08.01.39;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.15.07.50.41;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.20.09.14.05;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.19.11.24.23;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.18.21.19.15;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.18.13.49.55;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.16.17.18.42;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.16.12.19.11;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.12.10.09.12;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.11.05.37.36;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.10.09.22.15;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.09.20.38.55;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.09.19.49.55;	author robert;	state Exp;
branches;
next	;

1.181.4.1
date	2016.05.17.13.06.29;	author kettenis;	state Exp;
branches;
next	;
commitid	kLMq0smn42nW30p1;

1.183.2.1
date	2016.05.17.09.30.15;	author kettenis;	state Exp;
branches;
next	;
commitid	tF5N1anXm2K5eHj9;


desc
@@


1.192
log
@Replace tsleep/wakeup by usbd_ref_incr/decr/wait to wait for the kthread
to finish on close.

Tested and ok Patrick Keshishian

ok mpi
@
text
@/*	$OpenBSD: uvideo.c,v 1.191 2016/06/15 11:40:56 mpi Exp $ */

/*
 * Copyright (c) 2008 Robert Nagy <robert@@openbsd.org>
 * Copyright (c) 2008 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/lock.h>
#include <sys/stat.h>
#include <sys/poll.h>
#include <sys/timeout.h>
#include <sys/kthread.h>
#include <sys/stdint.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uvideo.h>

#include <dev/video_if.h>

#ifdef UVIDEO_DEBUG
int uvideo_debug = 1;
#define DPRINTF(l, x...) do { if ((l) <= uvideo_debug) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)

#define byteof(x) ((x) >> 3)
#define bitof(x)  (1L << ((x) & 0x7))

struct uvideo_softc {
	struct device				 sc_dev;
	struct usbd_device			*sc_udev;
	int					 sc_nifaces;
	struct usbd_interface			**sc_ifaces;

	struct device				*sc_videodev;

	int					 sc_enabled;
	int					 sc_max_fbuf_size;
	int					 sc_negotiated_flag;
	int					 sc_frame_rate;

	struct uvideo_frame_buffer		 sc_frame_buffer;

	struct uvideo_mmap			 sc_mmap[UVIDEO_MAX_BUFFERS];
	uint8_t					*sc_mmap_buffer;
	size_t					 sc_mmap_buffer_size;
	q_mmap					 sc_mmap_q;
	int					 sc_mmap_count;
	int					 sc_mmap_flag;

	struct vnode				*sc_vp;
	struct usb_task				 sc_task_write;

	int					 sc_nframes;
	struct usb_video_probe_commit		 sc_desc_probe;
	struct usb_video_header_desc_all	 sc_desc_vc_header;
	struct usb_video_input_header_desc_all	 sc_desc_vs_input_header;

#define UVIDEO_MAX_PU				 8
	int					 sc_desc_vc_pu_num;
	struct usb_video_vc_processing_desc	*sc_desc_vc_pu_cur;
	struct usb_video_vc_processing_desc	*sc_desc_vc_pu[UVIDEO_MAX_PU];

#define UVIDEO_MAX_FORMAT			 8
	int					 sc_fmtgrp_idx;
	int					 sc_fmtgrp_num;
	struct uvideo_format_group		*sc_fmtgrp_cur;
	struct uvideo_format_group		 sc_fmtgrp[UVIDEO_MAX_FORMAT];

#define	UVIDEO_MAX_VS_NUM			 8
	struct uvideo_vs_iface			*sc_vs_cur;
	struct uvideo_vs_iface			 sc_vs_coll[UVIDEO_MAX_VS_NUM];

	void					*sc_uplayer_arg;
	int					*sc_uplayer_fsize;
	uint8_t					*sc_uplayer_fbuffer;
	void					 (*sc_uplayer_intr)(void *);

	struct uvideo_devs			*sc_quirk;
	usbd_status				(*sc_decode_stream_header)
						    (struct uvideo_softc *,
						    uint8_t *, int);
};

int		uvideo_enable(void *);
void		uvideo_disable(void *);
int		uvideo_open(void *, int, int *, uint8_t *, void (*)(void *),
		    void *arg);
int		uvideo_close(void *);
int		uvideo_match(struct device *, void *, void *);
void		uvideo_attach(struct device *, struct device *, void *);
void		uvideo_attach_hook(struct device *);
int		uvideo_detach(struct device *, int);

usbd_status	uvideo_vc_parse_desc(struct uvideo_softc *);
usbd_status	uvideo_vc_parse_desc_header(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vc_parse_desc_pu(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vc_get_ctrl(struct uvideo_softc *, uint8_t *, uint8_t,
		    uint8_t, uint16_t, uint16_t);
usbd_status	uvideo_vc_set_ctrl(struct uvideo_softc *, uint8_t *, uint8_t,
		    uint8_t, uint16_t, uint16_t);
int		uvideo_find_ctrl(struct uvideo_softc *, int);
int		uvideo_has_ctrl(struct usb_video_vc_processing_desc *, int);

usbd_status	uvideo_vs_parse_desc(struct uvideo_softc *,
		    usb_config_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_input_header(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_format(struct uvideo_softc *);
usbd_status	uvideo_vs_parse_desc_format_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_format_uncompressed(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_frame(struct uvideo_softc *);
usbd_status	uvideo_vs_parse_desc_frame_sub(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_alt(struct uvideo_softc *, int, int, int);
usbd_status	uvideo_vs_set_alt(struct uvideo_softc *,
		    struct usbd_interface *, int);
int		uvideo_desc_len(const usb_descriptor_t *, int, int, int, int);
void		uvideo_find_res(struct uvideo_softc *, int, int, int,
		    struct uvideo_res *);
usbd_status	uvideo_vs_negotiation(struct uvideo_softc *, int);
usbd_status	uvideo_vs_set_probe(struct uvideo_softc *, uint8_t *);
usbd_status	uvideo_vs_get_probe(struct uvideo_softc *, uint8_t *, uint8_t);
usbd_status	uvideo_vs_set_commit(struct uvideo_softc *, uint8_t *);
usbd_status	uvideo_vs_alloc_frame(struct uvideo_softc *);
void		uvideo_vs_free_frame(struct uvideo_softc *);
usbd_status	uvideo_vs_alloc_isoc(struct uvideo_softc *);
usbd_status	uvideo_vs_alloc_bulk(struct uvideo_softc *);
void		uvideo_vs_free_isoc(struct uvideo_softc *);
void		uvideo_vs_free_bulk(struct uvideo_softc *);
usbd_status	uvideo_vs_open(struct uvideo_softc *);
void		uvideo_vs_close(struct uvideo_softc *);
usbd_status	uvideo_vs_init(struct uvideo_softc *);
int		uvideo_vs_start_bulk(struct uvideo_softc *);
void		uvideo_vs_start_bulk_thread(void *);
void		uvideo_vs_start_isoc(struct uvideo_softc *);
void		uvideo_vs_start_isoc_ixfer(struct uvideo_softc *,
		    struct uvideo_isoc_xfer *);
void		uvideo_vs_cb(struct usbd_xfer *, void *,
		    usbd_status);
usbd_status	uvideo_vs_decode_stream_header(struct uvideo_softc *,
		    uint8_t *, int); 
usbd_status	uvideo_vs_decode_stream_header_isight(struct uvideo_softc *,
		    uint8_t *, int);
int		uvideo_mmap_queue(struct uvideo_softc *, uint8_t *, int);
void		uvideo_read(struct uvideo_softc *, uint8_t *, int);
usbd_status	uvideo_usb_control(struct uvideo_softc *sc, uint8_t rt, uint8_t r,
		    uint16_t value, uint8_t *data, size_t length);

#ifdef UVIDEO_DEBUG
#include <sys/namei.h>
#include <sys/vnode.h>

void		uvideo_dump_desc_all(struct uvideo_softc *);
void		uvideo_dump_desc_vc_header(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_input_header(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_input(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_output(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_endpoint(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_interface(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_config(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_cs_endpoint(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_colorformat(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_format_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_format_uncompressed(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_frame(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_processing(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_dump_desc_extension(struct uvideo_softc *,
		    const usb_descriptor_t *);
void		uvideo_hexdump(void *, int, int);
int		uvideo_debug_file_open(struct uvideo_softc *);
void		uvideo_debug_file_write_frame(void *);
#endif

/*
 * IOCTL's
 */
int		uvideo_querycap(void *, struct v4l2_capability *);
int		uvideo_enum_fmt(void *, struct v4l2_fmtdesc *);
int		uvideo_enum_fsizes(void *, struct v4l2_frmsizeenum *);
int		uvideo_enum_fivals(void *, struct v4l2_frmivalenum *);
int		uvideo_s_fmt(void *, struct v4l2_format *);
int		uvideo_g_fmt(void *, struct v4l2_format *);
int		uvideo_s_parm(void *, struct v4l2_streamparm *);
int		uvideo_g_parm(void *, struct v4l2_streamparm *);
int		uvideo_enum_input(void *, struct v4l2_input *);
int		uvideo_s_input(void *, int);
int		uvideo_g_input(void *, int *);
int		uvideo_reqbufs(void *, struct v4l2_requestbuffers *);
int		uvideo_querybuf(void *, struct v4l2_buffer *);
int		uvideo_qbuf(void *, struct v4l2_buffer *);
int		uvideo_dqbuf(void *, struct v4l2_buffer *);
int		uvideo_streamon(void *, int);
int		uvideo_streamoff(void *, int);
int		uvideo_try_fmt(void *, struct v4l2_format *);
int		uvideo_queryctrl(void *, struct v4l2_queryctrl *);
int		uvideo_g_ctrl(void *, struct v4l2_control *);
int		uvideo_s_ctrl(void *, struct v4l2_control *);

/*
 * Other hardware interface related functions
 */
caddr_t		uvideo_mappage(void *, off_t, int);
int		uvideo_get_bufsize(void *);
int		uvideo_start_read(void *);

/*
 * Firmware
 */
usbd_status	uvideo_ucode_loader_ricoh(struct uvideo_softc *);
usbd_status	uvideo_ucode_loader_apple_isight(struct uvideo_softc *);

struct cfdriver uvideo_cd = {
	NULL, "uvideo", DV_DULL
};

const struct cfattach uvideo_ca = {
	sizeof(struct uvideo_softc), uvideo_match, uvideo_attach, uvideo_detach
};

struct video_hw_if uvideo_hw_if = {
	uvideo_open,		/* open */
	uvideo_close,		/* close */
	uvideo_querycap,	/* VIDIOC_QUERYCAP */
	uvideo_enum_fmt,	/* VIDIOC_ENUM_FMT */
	uvideo_enum_fsizes,	/* VIDIOC_ENUM_FRAMESIZES */
	uvideo_enum_fivals,	/* VIDIOC_ENUM_FRAMEINTERVALS */
	uvideo_s_fmt,		/* VIDIOC_S_FMT */
	uvideo_g_fmt,		/* VIDIOC_G_FMT */
	uvideo_s_parm,		/* VIDIOC_S_PARM */
	uvideo_g_parm,		/* VIDIOC_G_PARM */
	uvideo_enum_input,	/* VIDIOC_ENUMINPUT */
	uvideo_s_input,		/* VIDIOC_S_INPUT */
	uvideo_g_input,		/* VIDIOC_G_INPUT */
	uvideo_reqbufs,		/* VIDIOC_REQBUFS */
	uvideo_querybuf,	/* VIDIOC_QUERYBUF */
	uvideo_qbuf,		/* VIDIOC_QBUF */
	uvideo_dqbuf,		/* VIDIOC_DQBUF */
	uvideo_streamon,	/* VIDIOC_STREAMON */
	uvideo_streamoff,	/* VIDIOC_STREAMOFF */
	uvideo_try_fmt,		/* VIDIOC_TRY_FMT */
	uvideo_queryctrl,	/* VIDIOC_QUERYCTRL */
	uvideo_g_ctrl,		/* VIDIOC_G_CTRL */
	uvideo_s_ctrl,		/* VIDIOC_S_CTRL */
	uvideo_mappage,		/* mmap */
	uvideo_get_bufsize,	/* read */
	uvideo_start_read	/* start stream for read */
};

/*
 * Devices which either fail to declare themselves as UICLASS_VIDEO,
 * or which need firmware uploads or other quirk handling later on.
 */
#define UVIDEO_FLAG_ISIGHT_STREAM_HEADER	0x1
#define UVIDEO_FLAG_REATTACH			0x2
#define UVIDEO_FLAG_VENDOR_CLASS		0x4
struct uvideo_devs {
	struct usb_devno	 uv_dev;
	char			*ucode_name;
	usbd_status		 (*ucode_loader)(struct uvideo_softc *);
	int			 flags;
} uvideo_devs[] = {
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC5 },
	    "uvideo_r5u87x_05ca-1835",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC4 },
	    "uvideo_r5u87x_05ca-1836",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC4_2 },
	    "uvideo_r5u87x_05ca-1837",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC6 },
	    "uvideo_r5u87x_05ca-1839",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC7 },
	    "uvideo_r5u87x_05ca-183a",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC8 },
	    "uvideo_r5u87x_05ca-183b",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_RICOH, USB_PRODUCT_RICOH_VGPVCC9 },
	    "uvideo_r5u87x_05ca-183e",
	    uvideo_ucode_loader_ricoh,
	    0
	},
	{
	    /* Needs firmware */
	    { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_BLUETOOTH },
	    "uvideo_isight_05ac-8300",
	    uvideo_ucode_loader_apple_isight,
	    UVIDEO_FLAG_REATTACH
	},
	{
	    /* Has a non-standard streaming header protocol */
	    { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_ISIGHT_1 },
	    NULL,
	    NULL,
	    UVIDEO_FLAG_ISIGHT_STREAM_HEADER
	},
	{   /* Incorrectly reports as bInterfaceClass=UICLASS_VENDOR */
	    { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMOEM_1 },
	    NULL,
	    NULL,
	    UVIDEO_FLAG_VENDOR_CLASS
	},
};
#define uvideo_lookup(v, p) \
	((struct uvideo_devs *)usb_lookup(uvideo_devs, v, p))

int
uvideo_enable(void *v)
{
	struct uvideo_softc *sc = v;

	DPRINTF(1, "%s: uvideo_enable sc=%p\n", DEVNAME(sc), sc);

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (sc->sc_enabled)
		return (EBUSY);

	sc->sc_enabled = 1;

	return (0);
}

void
uvideo_disable(void *v)
{
	struct uvideo_softc *sc = v;

	DPRINTF(1, "%s: uvideo_disable sc=%p\n", DEVNAME(sc), sc);

	if (!sc->sc_enabled) {
		printf("uvideo_disable: already disabled!\n");
		return;
	}

	sc->sc_enabled = 0;
}

int
uvideo_open(void *addr, int flags, int *size, uint8_t *buffer,
    void (*intr)(void *), void *arg)
{
	struct uvideo_softc *sc = addr;

	DPRINTF(1, "%s: uvideo_open: sc=%p\n", DEVNAME(sc), sc);

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	/* pointers to upper video layer */
	sc->sc_uplayer_arg = arg;
	sc->sc_uplayer_fsize = size;
	sc->sc_uplayer_fbuffer = buffer;
	sc->sc_uplayer_intr = intr;

	sc->sc_mmap_flag = 0;
	sc->sc_negotiated_flag = 0;

	return (0);
}

int
uvideo_close(void *addr)
{
	struct uvideo_softc *sc = addr;

	DPRINTF(1, "%s: uvideo_close: sc=%p\n", DEVNAME(sc), sc);

#ifdef UVIDEO_DUMP
	usb_rem_task(sc->sc_udev, &sc->sc_task_write);
#endif
	/* close video stream pipe */
	uvideo_vs_close(sc);

	/* free video stream xfer buffer */
	if (sc->sc_vs_cur->bulk_endpoint)
		uvideo_vs_free_bulk(sc);
	else
		uvideo_vs_free_isoc(sc);

	/* free video stream frame buffer */
	uvideo_vs_free_frame(sc);
	return (0);
}

int
uvideo_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	struct uvideo_devs *quirk;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return (UMATCH_NONE);

	if (id->bInterfaceClass == UICLASS_VIDEO &&
	    id->bInterfaceSubClass == UISUBCLASS_VIDEOCONTROL)
		return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);

	/* quirk devices which we want to attach */
	quirk = uvideo_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL) {
		if (quirk->flags & UVIDEO_FLAG_REATTACH)
			return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);

		if (quirk->flags & UVIDEO_FLAG_VENDOR_CLASS &&
		    id->bInterfaceClass == UICLASS_VENDOR &&
		    id->bInterfaceSubClass == UISUBCLASS_VIDEOCONTROL)
			return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);
	}

	return (UMATCH_NONE);
}

void
uvideo_attach(struct device *parent, struct device *self, void *aux)
{
	struct uvideo_softc *sc = (struct uvideo_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	int i;

	sc->sc_udev = uaa->device;
	sc->sc_nifaces = uaa->nifaces;
	/*
	 * Claim all video interfaces.  Interfaces must be claimed during
	 * attach, during attach hooks is too late.
	 */
	for (i = 0; i < sc->sc_nifaces; i++) {
		if (usbd_iface_claimed(sc->sc_udev, i))
			continue;
		id = usbd_get_interface_descriptor(&sc->sc_udev->ifaces[i]);
		if (id == NULL)
			continue;
		if (id->bInterfaceClass == UICLASS_VIDEO)
			usbd_claim_iface(sc->sc_udev, i);
	}

	/* maybe the device has quirks */
	sc->sc_quirk = uvideo_lookup(uaa->vendor, uaa->product);

	if (sc->sc_quirk && sc->sc_quirk->ucode_name)
		config_mountroot(self, uvideo_attach_hook);
	else
		uvideo_attach_hook(self);
}

void
uvideo_attach_hook(struct device *self)
{
	struct uvideo_softc *sc = (struct uvideo_softc *)self;
	usb_config_descriptor_t *cdesc;
	usbd_status error;

	/* maybe the device needs a firmware */
	if (sc->sc_quirk && sc->sc_quirk->ucode_name) {
		error = (sc->sc_quirk->ucode_loader)(sc);
		if (error != USBD_NORMAL_COMPLETION)
			return;
	}

	/* map stream header decode function */
	if (sc->sc_quirk &&
	    sc->sc_quirk->flags & UVIDEO_FLAG_ISIGHT_STREAM_HEADER) {
		sc->sc_decode_stream_header =
		    uvideo_vs_decode_stream_header_isight;
	} else {
		sc->sc_decode_stream_header =
		    uvideo_vs_decode_stream_header;
	}

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    DEVNAME(sc));
		return;
	}
#ifdef UVIDEO_DEBUG
	uvideo_dump_desc_all(sc);
#endif
	/* parse video control descriptors */
	error = uvideo_vc_parse_desc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* parse video stream descriptors */
	error = uvideo_vs_parse_desc(sc, cdesc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* set default video stream interface */
	error = usbd_set_interface(sc->sc_vs_cur->ifaceh, 0);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* do device negotiation without commit */
	error = uvideo_vs_negotiation(sc, 0);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* init mmap queue */
	SIMPLEQ_INIT(&sc->sc_mmap_q);
	sc->sc_mmap_count = 0;

	DPRINTF(1, "uvideo_attach: doing video_attach_mi\n");
	sc->sc_videodev = video_attach_mi(&uvideo_hw_if, sc, &sc->sc_dev);
}

int
uvideo_detach(struct device *self, int flags)
{
	struct uvideo_softc *sc = (struct uvideo_softc *)self;
	int rv = 0;

	/* Wait for outstanding requests to complete */
	usbd_delay_ms(sc->sc_udev, UVIDEO_NFRAMES_MAX);

	uvideo_vs_free_frame(sc);

	if (sc->sc_videodev != NULL)
		rv = config_detach(sc->sc_videodev, flags);

	return (rv);
}

usbd_status
uvideo_vc_parse_desc(struct uvideo_softc *sc)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;
	int vc_header_found;
	usbd_status error;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	vc_header_found = 0;

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usbd_desc_iter_next(&iter);
			continue;
		}

		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_VC_HEADER:
			if (!uvideo_desc_len(desc, 12, 11, 1, 0))
				break;
			if (vc_header_found) {
				printf("%s: too many VC_HEADERs!\n",
				    DEVNAME(sc));
				return (USBD_INVAL);
			}
			error = uvideo_vc_parse_desc_header(sc, desc);
			if (error != USBD_NORMAL_COMPLETION)
				return (error);
			vc_header_found = 1;
			break;
		case UDESCSUB_VC_PROCESSING_UNIT:
			/* XXX do correct length calculation */
			if (desc->bLength <
			    sizeof(struct usb_video_frame_desc)) {
				(void)uvideo_vc_parse_desc_pu(sc, desc);
			}
			break;

		/* TODO: which VC descriptors do we need else? */
		}

		desc = usbd_desc_iter_next(&iter);
	}

	if (vc_header_found == 0) {
		printf("%s: no VC_HEADER found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vc_parse_desc_header(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_header_desc *d;

	d = (struct usb_video_header_desc *)(uint8_t *)desc;

	if (d->bInCollection == 0) {
		printf("%s: no VS interface found!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}
	
	sc->sc_desc_vc_header.fix = d;
	sc->sc_desc_vc_header.baInterfaceNr = (uByte *)(d + 1);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vc_parse_desc_pu(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_vc_processing_desc *d;

	/* PU descriptor is variable sized */
	d = (void *)desc;

	if (sc->sc_desc_vc_pu_num == UVIDEO_MAX_PU) {
		printf("%s: too many PU descriptors found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}

	sc->sc_desc_vc_pu[sc->sc_desc_vc_pu_num] = d;
	sc->sc_desc_vc_pu_num++;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vc_get_ctrl(struct uvideo_softc *sc, uint8_t *ctrl_data,
    uint8_t request, uint8_t unitid, uint16_t ctrl_selector, uint16_t ctrl_len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UVIDEO_GET_IF;
	req.bRequest = request;
	USETW(req.wValue, (ctrl_selector << 8));
	USETW(req.wIndex, (unitid << 8));
	USETW(req.wLength, ctrl_len);

	error = usbd_do_request(sc->sc_udev, &req, ctrl_data);
	if (error) {
		DPRINTF(1, "%s: %s: could not GET ctrl request: %s\n",
		    DEVNAME(sc), __func__, usbd_errstr(error));
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vc_set_ctrl(struct uvideo_softc *sc, uint8_t *ctrl_data,
    uint8_t request, uint8_t unitid, uint16_t ctrl_selector, uint16_t ctrl_len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UVIDEO_SET_IF;
	req.bRequest = request;
	USETW(req.wValue, (ctrl_selector << 8));
	USETW(req.wIndex, (unitid << 8));
	USETW(req.wLength, ctrl_len);

	error = usbd_do_request(sc->sc_udev, &req, ctrl_data);
	if (error) {
		DPRINTF(1, "%s: %s: could not SET ctrl request: %s\n",
		    DEVNAME(sc), __func__, usbd_errstr(error));
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

int
uvideo_find_ctrl(struct uvideo_softc *sc, int id)
{
	int i, j, found;

	if (sc->sc_desc_vc_pu_num == 0) {
		/* no processing unit descriptors found */
		DPRINTF(1, "%s: %s: no processing unit descriptors found!\n",
		    DEVNAME(sc), __func__);
		return (EINVAL);
	}

	/* do we support this control? */
	for (found = 0, i = 0; uvideo_ctrls[i].cid != 0; i++) {
		if (id == uvideo_ctrls[i].cid) {
			found = 1;
			break;
		}
	}
	if (found == 0) {
		DPRINTF(1, "%s: %s: control not supported by driver!\n",
		    DEVNAME(sc), __func__);
		return (EINVAL);
	}

	/* does the device support this control? */
	for (found = 0, j = 0; j < sc->sc_desc_vc_pu_num; j++) {
		if (uvideo_has_ctrl(sc->sc_desc_vc_pu[j],
		    uvideo_ctrls[i].ctrl_bit) != 0) {
			found = 1;
			break; 
		}
	}
	if (found == 0) {
		DPRINTF(1, "%s: %s: control not supported by device!\n",
		    DEVNAME(sc), __func__);
		return (EINVAL);
	}
	sc->sc_desc_vc_pu_cur = sc->sc_desc_vc_pu[j];

	return (i);
}

int
uvideo_has_ctrl(struct usb_video_vc_processing_desc *desc, int ctrl_bit)
{
	if (desc->bControlSize * 8 <= ctrl_bit)
		return (0);

	return (desc->bmControls[byteof(ctrl_bit)] & bitof(ctrl_bit));
}

usbd_status
uvideo_vs_parse_desc(struct uvideo_softc *sc, usb_config_descriptor_t *cdesc)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;
	usb_interface_descriptor_t *id;
	int i, iface, numalts;
	usbd_status error;

	DPRINTF(1, "%s: number of total interfaces=%d\n",
	    DEVNAME(sc), sc->sc_nifaces);
	DPRINTF(1, "%s: number of VS interfaces=%d\n",
	    DEVNAME(sc), sc->sc_desc_vc_header.fix->bInCollection);

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usbd_desc_iter_next(&iter);
			continue;
		}

		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_VS_INPUT_HEADER:
			if (!uvideo_desc_len(desc, 13, 3, 0, 12))
				break;
			error = uvideo_vs_parse_desc_input_header(sc, desc);
			if (error != USBD_NORMAL_COMPLETION)
				return (error);
			break;

		/* TODO: which VS descriptors do we need else? */
		}

		desc = usbd_desc_iter_next(&iter);
	}

	/* parse video stream format descriptors */
	error = uvideo_vs_parse_desc_format(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* parse video stream frame descriptors */
	error = uvideo_vs_parse_desc_frame(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* parse interface collection */
	for (i = 0; i < sc->sc_desc_vc_header.fix->bInCollection; i++) {
		iface = sc->sc_desc_vc_header.baInterfaceNr[i];

		id = usbd_get_interface_descriptor(&sc->sc_udev->ifaces[iface]);
		if (id == NULL) {
			printf("%s: can't get VS interface %d!\n",
			    DEVNAME(sc), iface);
			return (USBD_INVAL);
		}
		usbd_claim_iface(sc->sc_udev, iface);

		numalts = usbd_get_no_alts(cdesc, id->bInterfaceNumber);

		DPRINTF(1, "%s: VS interface %d, ", DEVNAME(sc), i);
		DPRINTF(1, "bInterfaceNumber=0x%02x, numalts=%d\n",
		    id->bInterfaceNumber, numalts);

		error = uvideo_vs_parse_desc_alt(sc, i, iface, numalts);
		if (error != USBD_NORMAL_COMPLETION)
			return (error);
	}

	/* XXX for now always use the first video stream */
	sc->sc_vs_cur = &sc->sc_vs_coll[0];

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_input_header(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_input_header_desc *d;

	d = (struct usb_video_input_header_desc *)(uint8_t *)desc;

	/* on some devices bNumFormats is larger than the truth */
	if (d->bNumFormats == 0) {
		printf("%s: no INPUT FORMAT descriptors found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}

	sc->sc_desc_vs_input_header.fix = d;
	sc->sc_desc_vs_input_header.bmaControls = (uByte *)(d + 1);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_format(struct uvideo_softc *sc)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usbd_desc_iter_next(&iter);
			continue;
		}

		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_VS_FORMAT_MJPEG:
			if (desc->bLength == 11) {
				(void)uvideo_vs_parse_desc_format_mjpeg(
				    sc, desc);
			}
			break;
		case UDESCSUB_VS_FORMAT_UNCOMPRESSED:
			if (desc->bLength == 27) {
				(void)uvideo_vs_parse_desc_format_uncompressed(
				    sc, desc);
			}
			break;
		}

		desc = usbd_desc_iter_next(&iter);
	}

	sc->sc_fmtgrp_idx = 0;

	if (sc->sc_fmtgrp_num == 0) {
		printf("%s: no format descriptors found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: number of total format descriptors=%d\n",
	    DEVNAME(sc), sc->sc_fmtgrp_num);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_format_mjpeg(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_format_mjpeg_desc *d;

	d = (struct usb_video_format_mjpeg_desc *)(uint8_t *)desc;

	if (d->bNumFrameDescriptors == 0) {
		printf("%s: no MJPEG frame descriptors available!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

	if (sc->sc_fmtgrp_idx > UVIDEO_MAX_FORMAT) {
		printf("%s: too many format descriptors found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}

	sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format =
	    (struct uvideo_format_desc *)d;
	if (d->bDefaultFrameIndex > d->bNumFrameDescriptors ||
	    d->bDefaultFrameIndex < 1) {
		/* sanitize wrong bDefaultFrameIndex value */
		sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx = 1;
	} else {
		sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx =
		    d->bDefaultFrameIndex;
	}
	sc->sc_fmtgrp[sc->sc_fmtgrp_idx].pixelformat = V4L2_PIX_FMT_MJPEG;

	if (sc->sc_fmtgrp_cur == NULL)
		/* set MJPEG format */
		sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[sc->sc_fmtgrp_idx];

	sc->sc_fmtgrp_idx++;
	sc->sc_fmtgrp_num++;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_format_uncompressed(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_format_uncompressed_desc *d;
	int i;

	d = (struct usb_video_format_uncompressed_desc *)(uint8_t *)desc;

	if (d->bNumFrameDescriptors == 0) {
		printf("%s: no UNCOMPRESSED frame descriptors available!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

	if (sc->sc_fmtgrp_idx > UVIDEO_MAX_FORMAT) {
		printf("%s: too many format descriptors found!\n", DEVNAME(sc));
		return (USBD_INVAL);
	}

	sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format =
	    (struct uvideo_format_desc *)d;
	if (d->bDefaultFrameIndex > d->bNumFrameDescriptors ||
	    d->bDefaultFrameIndex < 1) {
		/* sanitize wrong bDefaultFrameIndex value */
		sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx = 1;
	} else {
		sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx =
		    d->bDefaultFrameIndex;
	}
	i = sc->sc_fmtgrp_idx;
	if (!strcmp(sc->sc_fmtgrp[i].format->u.uc.guidFormat, "YUY2")) {
		sc->sc_fmtgrp[i].pixelformat = V4L2_PIX_FMT_YUYV;
	} else if (!strcmp(sc->sc_fmtgrp[i].format->u.uc.guidFormat, "NV12")) {
		sc->sc_fmtgrp[i].pixelformat = V4L2_PIX_FMT_NV12;
	} else if (!strcmp(sc->sc_fmtgrp[i].format->u.uc.guidFormat, "UYVY")) {
		sc->sc_fmtgrp[i].pixelformat = V4L2_PIX_FMT_UYVY;
	} else {
		sc->sc_fmtgrp[i].pixelformat = 0;
	}

	if (sc->sc_fmtgrp_cur == NULL)
		/* set UNCOMPRESSED format */
		sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[sc->sc_fmtgrp_idx];

	sc->sc_fmtgrp_idx++;
	sc->sc_fmtgrp_num++;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_frame(struct uvideo_softc *sc)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;
	usbd_status error;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType == UDESC_CS_INTERFACE &&
		    desc->bLength > sizeof(struct usb_video_frame_desc) &&
		    (desc->bDescriptorSubtype == UDESCSUB_VS_FRAME_MJPEG ||
		    desc->bDescriptorSubtype == UDESCSUB_VS_FRAME_UNCOMPRESSED)) {
			error = uvideo_vs_parse_desc_frame_sub(sc, desc);
			if (error != USBD_NORMAL_COMPLETION)
				return (error);
		}
		desc = usbd_desc_iter_next(&iter);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_frame_sub(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_frame_desc *fd = 
	    (struct usb_video_frame_desc *)(uint8_t *)desc;
	int fmtidx, frame_num;
	uint32_t fbuf_size;

	fmtidx = sc->sc_fmtgrp_idx;
	frame_num = sc->sc_fmtgrp[fmtidx].frame_num;
	if (frame_num >= UVIDEO_MAX_FRAME) {
		printf("%s: too many %s frame descriptors found!\n",
		    DEVNAME(sc),
		    desc->bDescriptorSubtype == UDESCSUB_VS_FRAME_MJPEG ?
		    "MJPEG" : "UNCOMPRESSED");
		return (USBD_INVAL);
	}
	sc->sc_fmtgrp[fmtidx].frame[frame_num] = fd;

	if (sc->sc_fmtgrp[fmtidx].frame_cur == NULL ||
	    sc->sc_fmtgrp[fmtidx].format_dfidx == fd->bFrameIndex)
		sc->sc_fmtgrp[fmtidx].frame_cur = fd;

	/*
	 * On some devices, dwMaxVideoFrameBufferSize is not correct.
	 * Version 1.1 of the UVC spec says this field is deprecated.
	 * For uncompressed pixel formats, the frame buffer size can
	 * be determined by multiplying width, height, and bytes per pixel.
	 * Uncompressed formats have a fixed number of bytes per pixel.
	 * Bytes per pixel can vary with compressed formats.
	 */
	if (desc->bDescriptorSubtype == UDESCSUB_VS_FRAME_UNCOMPRESSED) {
		fbuf_size = UGETW(fd->wWidth) * UGETW(fd->wHeight) *
		    sc->sc_fmtgrp[fmtidx].format->u.uc.bBitsPerPixel / NBBY;
		DPRINTF(10, "%s: %s: frame buffer size=%d "
		    "width=%d height=%d bpp=%d\n", DEVNAME(sc), __func__,
		    fbuf_size, UGETW(fd->wWidth), UGETW(fd->wHeight),
		    sc->sc_fmtgrp[fmtidx].format->u.uc.bBitsPerPixel);
	} else
		fbuf_size = UGETDW(fd->dwMaxVideoFrameBufferSize);

	/* store max value */
	if (fbuf_size > sc->sc_max_fbuf_size)
		sc->sc_max_fbuf_size = fbuf_size;

	/*
	 * Increment frame count.  If this is the last frame in the
	 * format group, go on to next group.
	 */
	if (++sc->sc_fmtgrp[fmtidx].frame_num ==
	    sc->sc_fmtgrp[fmtidx].format->bNumFrameDescriptors) {
		sc->sc_fmtgrp_idx++;
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_alt(struct uvideo_softc *sc, int vs_nr, int iface, int numalts)
{
	struct uvideo_vs_iface *vs;
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	uint8_t ep_dir, ep_type;

	vs = &sc->sc_vs_coll[vs_nr];

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		/* find video stream interface */
		if (desc->bDescriptorType != UDESC_INTERFACE)
			goto next;
		id = (usb_interface_descriptor_t *)(uint8_t *)desc;
		if (id->bInterfaceNumber != iface)
			goto next;
		DPRINTF(1, "%s: bAlternateSetting=0x%02x, ",
		    DEVNAME(sc), id->bAlternateSetting);
		if (id->bNumEndpoints == 0) {
			DPRINTF(1, "no endpoint descriptor\n");
			goto next;
		}

		/* jump to corresponding endpoint descriptor */
		while ((desc = usbd_desc_iter_next(&iter))) {
			if (desc->bDescriptorType == UDESC_ENDPOINT)
				break;
		}
		ed = (usb_endpoint_descriptor_t *)(uint8_t *)desc;
		DPRINTF(1, "bEndpointAddress=0x%02x, ", ed->bEndpointAddress);
		DPRINTF(1, "wMaxPacketSize=%d\n", UGETW(ed->wMaxPacketSize));

		/* locate endpoint type */
		ep_dir = UE_GET_DIR(ed->bEndpointAddress);
		ep_type = UE_GET_XFERTYPE(ed->bmAttributes);
		if (ep_dir == UE_DIR_IN && ep_type == UE_ISOCHRONOUS)
			vs->bulk_endpoint = 0;
		else if (ep_dir == UE_DIR_IN && ep_type == UE_BULK)
			vs->bulk_endpoint = 1;
		else
			goto next;

		/* save endpoint with largest bandwidth */
		if (UGETW(ed->wMaxPacketSize) > vs->psize) {
			vs->ifaceh = &sc->sc_udev->ifaces[iface];
			vs->endpoint = ed->bEndpointAddress;
			vs->numalts = numalts;
			vs->curalt = id->bAlternateSetting;
			vs->psize = UGETW(ed->wMaxPacketSize);
			vs->iface = iface;
		}
next:
		desc = usbd_desc_iter_next(&iter);
	}

	/* check if we have found a valid alternate interface */
	if (vs->ifaceh == NULL) {
		printf("%s: no valid alternate interface found!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_set_alt(struct uvideo_softc *sc, struct usbd_interface *ifaceh,
    int max_packet_size)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int diff, best_diff = INT_MAX;
	usbd_status error;
	uint32_t psize;

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		/* find video stream interface */
		if (desc->bDescriptorType != UDESC_INTERFACE)
			goto next;
		id = (usb_interface_descriptor_t *)(uint8_t *)desc;
		if (id->bInterfaceNumber != sc->sc_vs_cur->iface)
			goto next;
		if (id->bNumEndpoints == 0)
			goto next;

		/* jump to corresponding endpoint descriptor */
		desc = usbd_desc_iter_next(&iter);
		if (desc->bDescriptorType != UDESC_ENDPOINT)
			goto next;
		ed = (usb_endpoint_descriptor_t *)(uint8_t *)desc;

		/* save endpoint with requested bandwidth */
		psize = UGETW(ed->wMaxPacketSize);
		psize = UE_GET_SIZE(psize) * (1 + UE_GET_TRANS(psize));
		if (psize >= max_packet_size)
			diff = psize - max_packet_size;
		else
			goto next;
		if (diff < best_diff) {
			best_diff = diff;
			sc->sc_vs_cur->endpoint = ed->bEndpointAddress;
			sc->sc_vs_cur->curalt = id->bAlternateSetting;
			sc->sc_vs_cur->psize = psize;
			if (diff == 0)
				break;
		}
next:
		desc = usbd_desc_iter_next(&iter);
	}

	DPRINTF(1, "%s: set alternate iface to ", DEVNAME(sc));
	DPRINTF(1, "bAlternateSetting=0x%02x psize=%d max_packet_size=%d\n",
	    sc->sc_vs_cur->curalt, sc->sc_vs_cur->psize, max_packet_size);

	/* set alternate video stream interface */
	error = usbd_set_interface(ifaceh, sc->sc_vs_cur->curalt);
	if (error) {
		printf("%s: could not set alternate interface %d!\n",
		    DEVNAME(sc), sc->sc_vs_cur->curalt);
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

/*
 * Thanks to the retarded USB Video Class specs there are different
 * descriptors types with the same bDescriptorSubtype which makes
 * it necessary to differ between those types by doing descriptor
 * size dances :-(
 *
 * size_fix:		total size of the fixed structure part
 * off_num_elements:	offset which tells the number of following elements
 * size_element:	size of a single element
 * off_size_element:	if size_element is 0 the element size is taken from
 *			this offset in the descriptor 
 */
int
uvideo_desc_len(const usb_descriptor_t *desc,
    int size_fix, int off_num_elements, int size_element, int off_size_element)
{
	uint8_t *buf;
	int size_elements, size_total;

	if (desc->bLength < size_fix)
		return (0);

	buf = (uint8_t *)desc;

	if (size_element == 0)
		size_element = buf[off_size_element];

	size_elements = buf[off_num_elements] * size_element;
	size_total = size_fix + size_elements;

	if (desc->bLength == size_total && size_elements != 0)
		return (1);

	return (0);
}

/*
 * Find the next best matching resolution which we can offer and
 * return it.
 */
void
uvideo_find_res(struct uvideo_softc *sc, int idx, int width, int height,
    struct uvideo_res *r)
{
	int i, w, h, diff, diff_best, size_want, size_is;

	size_want = width * height;

	for (i = 0; i < sc->sc_fmtgrp[idx].frame_num; i++) {
		w = UGETW(sc->sc_fmtgrp[idx].frame[i]->wWidth);
		h = UGETW(sc->sc_fmtgrp[idx].frame[i]->wHeight);
		size_is = w * h;
		if (size_is > size_want)
			diff = size_is - size_want;
		else
			diff = size_want - size_is;
		if (i == 0)
			diff_best = diff;
		if (diff <= diff_best) {
			diff_best = diff;
			r->width = w;
			r->height = h;
			r->fidx = i;
		}
		DPRINTF(1, "%s: %s: frame index %d: width=%d, height=%d\n",
		    DEVNAME(sc), __func__, i, w, h);
	}
}

usbd_status
uvideo_vs_negotiation(struct uvideo_softc *sc, int commit)
{
	struct usb_video_probe_commit *pc;
	struct uvideo_format_group *fmtgrp;
	struct usb_video_header_desc *hd;
	struct usb_video_frame_desc *frame;
	uint8_t *p, *cur;
	uint8_t probe_data[34];
	uint32_t frame_ival, nivals, min, max, step, diff;
	usbd_status error;
	int i, ival_bytes, changed = 0;

	pc = (struct usb_video_probe_commit *)probe_data;

	fmtgrp = sc->sc_fmtgrp_cur;

	/* check if the format descriptor contains frame descriptors */
	if (fmtgrp->frame_num == 0) {
		printf("%s: %s: no frame descriptors found!\n",
		    __func__, DEVNAME(sc));
		return (USBD_INVAL);
	}

	/* set probe */
	bzero(probe_data, sizeof(probe_data));
	/* hint that dwFrameInterval should be favored over other parameters */
	USETW(pc->bmHint, 0x1);
	pc->bFormatIndex = fmtgrp->format->bFormatIndex;
	pc->bFrameIndex = fmtgrp->frame_cur->bFrameIndex;
	/* dwFrameInterval: 30fps=333333, 15fps=666666, 10fps=1000000 */
	frame_ival = UGETDW(fmtgrp->frame_cur->dwDefaultFrameInterval);
	if (sc->sc_frame_rate != 0) {
		frame_ival = 10000000 / sc->sc_frame_rate;
		/* find closest matching interval the device supports */
		p = (uint8_t *)fmtgrp->frame_cur;
		p += sizeof(struct usb_video_frame_desc);
		nivals = fmtgrp->frame_cur->bFrameIntervalType;
		ival_bytes = fmtgrp->frame_cur->bLength -
		    sizeof(struct usb_video_frame_desc);
		if (!nivals && (ival_bytes >= sizeof(uDWord) * 3)) {
			/* continuous */
			min = UGETDW(p);
			p += sizeof(uDWord);
			max = UGETDW(p);
			p += sizeof(uDWord);
			step = UGETDW(p);
			p += sizeof(uDWord);
			if (frame_ival <= min)
				frame_ival = min;
			else if (frame_ival >= max)
				frame_ival = max;
			else {
				for (i = min; i + step/2 < frame_ival; i+= step)
					;	/* nothing */
				frame_ival = i;
			}
		} else if (nivals > 0 && ival_bytes >= sizeof(uDWord)) {
			/* discrete */
			cur = p;
			min = UINT_MAX;
			for (i = 0; i < nivals; i++) {
				if (ival_bytes < sizeof(uDWord)) {
					/* short descriptor ? */
					break;
				}
				diff = abs(UGETDW(p) - frame_ival);
				if (diff < min) {
					min = diff;
					cur = p;
					if (diff == 0)
						break;
				}
				p += sizeof(uDWord);
				ival_bytes -= sizeof(uDWord);
			}
			frame_ival = UGETDW(cur);
		} else {
			DPRINTF(1, "%s: %s: bad frame ival descriptor\n",
			    DEVNAME(sc), __func__);
		}
	}
	USETDW(pc->dwFrameInterval, frame_ival);
	error = uvideo_vs_set_probe(sc, probe_data);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* get probe */
	bzero(probe_data, sizeof(probe_data));
	error = uvideo_vs_get_probe(sc, probe_data, GET_CUR);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* check that the format and frame indexes are what we wanted */
	if (pc->bFormatIndex != fmtgrp->format->bFormatIndex) {
		changed++;
		DPRINTF(1, "%s: %s: wanted format 0x%x, got format 0x%x\n",
		    DEVNAME(sc), __func__, fmtgrp->format->bFormatIndex,
		    pc->bFormatIndex);
		for (i = 0; i < sc->sc_fmtgrp_num; i++) {
			if (sc->sc_fmtgrp[i].format->bFormatIndex ==
			    pc->bFormatIndex) {
				fmtgrp = &sc->sc_fmtgrp[i];
				break;
			}
		}
		if (i == sc->sc_fmtgrp_num) {
			DPRINTF(1, "%s: %s: invalid format index 0x%x\n",
			    DEVNAME(sc), __func__, pc->bFormatIndex);
			return (USBD_INVAL);
		}
	}
	if (pc->bFrameIndex != fmtgrp->frame_cur->bFrameIndex) {
		changed++;
		DPRINTF(1, "%s: %s: wanted frame 0x%x, got frame 0x%x\n",
		    DEVNAME(sc), __func__, fmtgrp->frame_cur->bFrameIndex,
		    pc->bFrameIndex);
		for (i = 0; i < fmtgrp->frame_num; i++) {
			if (fmtgrp->frame[i]->bFrameIndex == pc->bFrameIndex) {
				frame = fmtgrp->frame[i];
				break;
			}
		}
		if (i == fmtgrp->frame_num) {
			DPRINTF(1, "%s: %s: invalid frame index 0x%x\n",
			    DEVNAME(sc), __func__, pc->bFrameIndex);
			return (USBD_INVAL);
		}
	} else
		frame = fmtgrp->frame_cur;

	/*
	 * Uncompressed formats have fixed bits per pixel, which means
	 * the frame buffer size is fixed and can be calculated.  Because
	 * some devices return incorrect values, always override the
	 * the frame size with a calculated value.
	 */
	if (frame->bDescriptorSubtype == UDESCSUB_VS_FRAME_UNCOMPRESSED) {
		USETDW(pc->dwMaxVideoFrameSize,
		    UGETW(frame->wWidth) * UGETW(frame->wHeight) *
		    fmtgrp->format->u.uc.bBitsPerPixel / NBBY);
		DPRINTF(1, "fixed dwMaxVideoFrameSize=%d, "
		    "width=%d height=%d bpp=%d\n",
		    UGETDW(pc->dwMaxVideoFrameSize),
		    UGETW(frame->wWidth), UGETW(frame->wHeight),
		    fmtgrp->format->u.uc.bBitsPerPixel);
	} else {
		/*
		 * Some UVC 1.00 devices return dwMaxVideoFrameSize = 0.
		 * If so, fix it by format/frame descriptors.
		 */
		hd = sc->sc_desc_vc_header.fix;
		if (UGETDW(pc->dwMaxVideoFrameSize) == 0 &&
		    UGETW(hd->bcdUVC) < 0x0110 ) {
			DPRINTF(1, "%s: dwMaxVideoFrameSize == 0, fixed\n",
			    DEVNAME(sc));
			USETDW(pc->dwMaxVideoFrameSize, 
			    UGETDW(frame->dwMaxVideoFrameBufferSize));
		}
	}

	/* commit */
	if (commit) {
		if (changed > 0) {
			/* didn't get the frame format or size we wanted */
			return (USBD_INVAL);
		}
		error = uvideo_vs_set_commit(sc, probe_data);
		if (error != USBD_NORMAL_COMPLETION)
			return (error);
	}

	/* save a copy of probe commit */
	bcopy(pc, &sc->sc_desc_probe, sizeof(sc->sc_desc_probe));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_set_probe(struct uvideo_softc *sc, uint8_t *probe_data)
{
	usb_device_request_t req;
	usbd_status error;
	uint16_t tmp;
	struct usb_video_probe_commit *pc;

	req.bmRequestType = UVIDEO_SET_IF;
	req.bRequest = SET_CUR;
	tmp = VS_PROBE_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	USETW(req.wIndex, sc->sc_vs_cur->iface);
	USETW(req.wLength, 26);

	pc = (struct usb_video_probe_commit *)probe_data;

	error = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (error) {
		printf("%s: could not SET probe request: %s\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: SET probe request successfully\n", DEVNAME(sc));

	DPRINTF(1, "bmHint=0x%02x\n", UGETW(pc->bmHint));
	DPRINTF(1, "bFormatIndex=0x%02x\n", pc->bFormatIndex);
	DPRINTF(1, "bFrameIndex=0x%02x\n", pc->bFrameIndex);
	DPRINTF(1, "dwFrameInterval=%d (100ns units)\n",
	    UGETDW(pc->dwFrameInterval));
	DPRINTF(1, "wKeyFrameRate=%d\n", UGETW(pc->wKeyFrameRate));
	DPRINTF(1, "wPFrameRate=%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=%d\n", UGETW(pc->wCompQuality));
	DPRINTF(1, "wCompWindowSize=%d\n", UGETW(pc->wCompWindowSize));
	DPRINTF(1, "wDelay=%d (ms)\n", UGETW(pc->wDelay));
	DPRINTF(1, "dwMaxVideoFrameSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxVideoFrameSize));
	DPRINTF(1, "dwMaxPayloadTransferSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxPayloadTransferSize));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_get_probe(struct uvideo_softc *sc, uint8_t *probe_data,
    uint8_t request)
{
	usb_device_request_t req;
	usbd_status error;
	uint16_t tmp;
	struct usb_video_probe_commit *pc;

	req.bmRequestType = UVIDEO_GET_IF;
	req.bRequest = request;
	tmp = VS_PROBE_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	USETW(req.wIndex, sc->sc_vs_cur->iface);
	USETW(req.wLength, 26);

	pc = (struct usb_video_probe_commit *)probe_data;

	error = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (error) {
		printf("%s: could not GET probe request: %s\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: GET probe request successfully\n", DEVNAME(sc));

	DPRINTF(1, "bmHint=0x%02x\n", UGETW(pc->bmHint));
	DPRINTF(1, "bFormatIndex=0x%02x\n", pc->bFormatIndex);
	DPRINTF(1, "bFrameIndex=0x%02x\n", pc->bFrameIndex);
	DPRINTF(1, "dwFrameInterval=%d (100ns units)\n",
	    UGETDW(pc->dwFrameInterval));
	DPRINTF(1, "wKeyFrameRate=%d\n", UGETW(pc->wKeyFrameRate));
	DPRINTF(1, "wPFrameRate=%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=%d\n", UGETW(pc->wCompQuality));
	DPRINTF(1, "wCompWindowSize=%d\n", UGETW(pc->wCompWindowSize));
	DPRINTF(1, "wDelay=%d (ms)\n", UGETW(pc->wDelay));
	DPRINTF(1, "dwMaxVideoFrameSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxVideoFrameSize));
	DPRINTF(1, "dwMaxPayloadTransferSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxPayloadTransferSize));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_set_commit(struct uvideo_softc *sc, uint8_t *probe_data)
{
	usb_device_request_t req;
	usbd_status error;
	uint16_t tmp;

	req.bmRequestType = UVIDEO_SET_IF;
	req.bRequest = SET_CUR;
	tmp = VS_COMMIT_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	USETW(req.wIndex, sc->sc_vs_cur->iface);
	USETW(req.wLength, 26);

	error = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (error) {
		printf("%s: could not SET commit request: %s\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: SET commit request successfully\n", DEVNAME(sc));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_alloc_frame(struct uvideo_softc *sc)
{
	struct uvideo_frame_buffer *fb = &sc->sc_frame_buffer;

	fb->buf_size = UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize);

	/* don't overflow the upper layer frame buffer */
	if (sc->sc_max_fbuf_size < fb->buf_size &&
	    sc->sc_mmap_flag == 0) {
		printf("%s: software video buffer is too small!\n",
		    DEVNAME(sc));
		return (USBD_NOMEM);
	}

	fb->buf = malloc(fb->buf_size, M_DEVBUF, M_NOWAIT);
	if (fb->buf == NULL) {
		printf("%s: can't allocate frame buffer!\n", DEVNAME(sc));
		return (USBD_NOMEM);
	}

	DPRINTF(1, "%s: %s: allocated %d bytes frame buffer\n",
	    DEVNAME(sc), __func__, fb->buf_size);

	fb->sample = 0;
	fb->fid = 0;
	fb->offset = 0;
	fb->fmt_flags = sc->sc_fmtgrp_cur->frame_cur->bDescriptorSubtype ==
	    UDESCSUB_VS_FRAME_UNCOMPRESSED ? 0 : V4L2_FMT_FLAG_COMPRESSED;

	return (USBD_NORMAL_COMPLETION);
}

void
uvideo_vs_free_frame(struct uvideo_softc *sc)
{
	struct uvideo_frame_buffer *fb = &sc->sc_frame_buffer;

	if (fb->buf != NULL) {
		free(fb->buf, M_DEVBUF, 0);
		fb->buf = NULL;
	}

	if (sc->sc_mmap_buffer != NULL) {
		free(sc->sc_mmap_buffer, M_DEVBUF, sc->sc_mmap_buffer_size);
		sc->sc_mmap_buffer = NULL;
		sc->sc_mmap_buffer_size = 0;
	}

	while (!SIMPLEQ_EMPTY(&sc->sc_mmap_q))
		SIMPLEQ_REMOVE_HEAD(&sc->sc_mmap_q, q_frames);

	sc->sc_mmap_count = 0;
}

usbd_status
uvideo_vs_alloc_isoc(struct uvideo_softc *sc)
{
	int size, i;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	for (i = 0; i < UVIDEO_IXFERS; i++) {
		sc->sc_vs_cur->ixfer[i].sc = sc;

		sc->sc_vs_cur->ixfer[i].xfer = usbd_alloc_xfer(sc->sc_udev);	
		if (sc->sc_vs_cur->ixfer[i].xfer == NULL) {
			printf("%s: could not allocate isoc VS xfer!\n",
			    DEVNAME(sc));
			return (USBD_NOMEM);	
		}

		size = sc->sc_vs_cur->psize * sc->sc_nframes;

		sc->sc_vs_cur->ixfer[i].buf =
		    usbd_alloc_buffer(sc->sc_vs_cur->ixfer[i].xfer, size);
		if (sc->sc_vs_cur->ixfer[i].buf == NULL) {
			printf("%s: could not allocate isoc VS buffer!\n",
			    DEVNAME(sc));
			return (USBD_NOMEM);
		}
		DPRINTF(1, "%s: allocated %d bytes isoc VS xfer buffer\n",
		    DEVNAME(sc), size);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_alloc_bulk(struct uvideo_softc *sc)
{
	int size;

	sc->sc_vs_cur->bxfer.sc = sc;

	sc->sc_vs_cur->bxfer.xfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->sc_vs_cur->bxfer.xfer == NULL) {
		printf("%s: could not allocate bulk VS xfer!\n",
		    DEVNAME(sc));
		return (USBD_NOMEM);
	}

	size = UGETDW(sc->sc_desc_probe.dwMaxPayloadTransferSize);

	sc->sc_vs_cur->bxfer.buf =
	    usbd_alloc_buffer(sc->sc_vs_cur->bxfer.xfer, size);
	if (sc->sc_vs_cur->bxfer.buf == NULL) {
		printf("%s: could not allocate bulk VS buffer!\n",
		    DEVNAME(sc));
		return (USBD_NOMEM);
	}
	DPRINTF(1, "%s: allocated %d bytes bulk VS xfer buffer\n",
	    DEVNAME(sc), size);

	return (USBD_NORMAL_COMPLETION);
}

void
uvideo_vs_free_isoc(struct uvideo_softc *sc)
{
	int i;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	for (i = 0; i < UVIDEO_IXFERS; i++) {
		if (sc->sc_vs_cur->ixfer[i].buf != NULL) {
			usbd_free_buffer(sc->sc_vs_cur->ixfer[i].xfer);
			sc->sc_vs_cur->ixfer[i].buf = NULL;
		}

		if (sc->sc_vs_cur->ixfer[i].xfer != NULL) {
			usbd_free_xfer(sc->sc_vs_cur->ixfer[i].xfer);
			sc->sc_vs_cur->ixfer[i].xfer = NULL;
		}
	}
}

void
uvideo_vs_free_bulk(struct uvideo_softc *sc)
{
	if (sc->sc_vs_cur->bxfer.buf != NULL) {
		usbd_free_buffer(sc->sc_vs_cur->bxfer.xfer);
		sc->sc_vs_cur->bxfer.buf = NULL;
	}

	if (sc->sc_vs_cur->bxfer.xfer != NULL) {
		usbd_free_xfer(sc->sc_vs_cur->bxfer.xfer);
		sc->sc_vs_cur->bxfer.xfer = NULL;
	}
}

usbd_status
uvideo_vs_open(struct uvideo_softc *sc)
{
	usb_endpoint_descriptor_t *ed;
	usbd_status error;
	uint32_t dwMaxVideoFrameSize;

	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);

	if (sc->sc_negotiated_flag == 0) {
		/* do device negotiation with commit */
		error = uvideo_vs_negotiation(sc, 1);
		if (error != USBD_NORMAL_COMPLETION)
			return (error);
	}

	error = uvideo_vs_set_alt(sc, sc->sc_vs_cur->ifaceh,
	    UGETDW(sc->sc_desc_probe.dwMaxPayloadTransferSize));
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: could not set alternate interface!\n",
		    DEVNAME(sc));
		return (error);
	}

	/* double check if we can access the selected endpoint descriptor */
	ed = usbd_get_endpoint_descriptor(sc->sc_vs_cur->ifaceh,
	    sc->sc_vs_cur->endpoint);
	if (ed == NULL) {
		printf("%s: no endpoint descriptor for VS iface\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

	DPRINTF(1, "%s: open pipe for bEndpointAddress=0x%02x\n",
	    DEVNAME(sc), sc->sc_vs_cur->endpoint);
	error = usbd_open_pipe(
	    sc->sc_vs_cur->ifaceh,
	    sc->sc_vs_cur->endpoint,
	    USBD_EXCLUSIVE_USE,
	    &sc->sc_vs_cur->pipeh);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: could not open VS pipe: %s\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (error);
	}

	/* calculate optimal isoc xfer size */
	if (strcmp(sc->sc_udev->bus->bdev.dv_cfdata->cf_driver->cd_name,
	    "ohci") == 0) {
		/* ohci workaround */
		sc->sc_nframes = 8;
	} else {
		dwMaxVideoFrameSize =
		    UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize);
		sc->sc_nframes = (dwMaxVideoFrameSize + sc->sc_vs_cur->psize -
		    1) / sc->sc_vs_cur->psize;
	}
	if (sc->sc_nframes > UVIDEO_NFRAMES_MAX)
		sc->sc_nframes = UVIDEO_NFRAMES_MAX;
	DPRINTF(1, "%s: nframes=%d\n", DEVNAME(sc), sc->sc_nframes);

	return (USBD_NORMAL_COMPLETION);
}

void
uvideo_vs_close(struct uvideo_softc *sc)
{
	if (sc->sc_vs_cur->bulk_running == 1) {
		sc->sc_vs_cur->bulk_running = 0;
		usbd_ref_wait(sc->sc_udev);
	}

	if (sc->sc_vs_cur->pipeh) {
		usbd_abort_pipe(sc->sc_vs_cur->pipeh);
		usbd_close_pipe(sc->sc_vs_cur->pipeh);
		sc->sc_vs_cur->pipeh = NULL;
	}

	/*
	 * Some devices need time to shutdown before we switch back to
	 * the default interface (0).  Not doing so can leave the device
	 * back in a undefined condition.
	 */
	usbd_delay_ms(sc->sc_udev, 100);

	/* switch back to default interface (turns off cam LED) */
	(void)usbd_set_interface(sc->sc_vs_cur->ifaceh, 0);
}

usbd_status
uvideo_vs_init(struct uvideo_softc *sc)
{
	usbd_status error;

	/* open video stream pipe */
	error = uvideo_vs_open(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (USBD_INVAL);

	/* allocate video stream xfer buffer */
	if (sc->sc_vs_cur->bulk_endpoint)
		error = uvideo_vs_alloc_bulk(sc);
	else
		error = uvideo_vs_alloc_isoc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (USBD_INVAL);

	/* allocate video stream frame buffer */
	error = uvideo_vs_alloc_frame(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (USBD_INVAL);
#ifdef UVIDEO_DUMP
	if (uvideo_debug_file_open(sc) != 0)
		return (USBD_INVAL);
	usb_init_task(&sc->sc_task_write, uvideo_debug_file_write_frame, sc,
	    USB_TASK_TYPE_GENERIC);
#endif
	return (USBD_NORMAL_COMPLETION);
}

int
uvideo_vs_start_bulk(struct uvideo_softc *sc)
{
	int error;

	sc->sc_vs_cur->bulk_running = 1;

	error = kthread_create(uvideo_vs_start_bulk_thread, sc, NULL,
	    DEVNAME(sc));
	if (error) {
		printf("%s: can't create kernel thread!", DEVNAME(sc));
		return (error);
	}

	return (0);
}

void
uvideo_vs_start_bulk_thread(void *arg)
{
	struct uvideo_softc *sc = arg;
	usbd_status error;
	int size;

	usbd_ref_incr(sc->sc_udev);
	while (sc->sc_vs_cur->bulk_running) {
		size = UGETDW(sc->sc_desc_probe.dwMaxPayloadTransferSize);

		usbd_setup_xfer(
		    sc->sc_vs_cur->bxfer.xfer,
		    sc->sc_vs_cur->pipeh,
		    0,
		    sc->sc_vs_cur->bxfer.buf,
		    size,
		    USBD_NO_COPY | USBD_SHORT_XFER_OK | USBD_SYNCHRONOUS,
		    0,
		    NULL);
		error = usbd_transfer(sc->sc_vs_cur->bxfer.xfer);
		if (error != USBD_NORMAL_COMPLETION) {
			DPRINTF(1, "%s: error in bulk xfer: %s!\n",
			    DEVNAME(sc), usbd_errstr(error));
			break;
		}

		DPRINTF(2, "%s: *** buffer len = %d\n", DEVNAME(sc), size);

		(void)sc->sc_decode_stream_header(sc,
		    sc->sc_vs_cur->bxfer.buf, size);
	}
	usbd_ref_decr(sc->sc_udev);

	kthread_exit(0);
}

void
uvideo_vs_start_isoc(struct uvideo_softc *sc)
{
	int i;

	for (i = 0; i < UVIDEO_IXFERS; i++)
		uvideo_vs_start_isoc_ixfer(sc, &sc->sc_vs_cur->ixfer[i]);
}

void
uvideo_vs_start_isoc_ixfer(struct uvideo_softc *sc,
    struct uvideo_isoc_xfer *ixfer)
{
	int i;
	usbd_status error;

	DPRINTF(2, "%s: %s\n", DEVNAME(sc), __func__);

	if (usbd_is_dying(sc->sc_udev))
		return;

	for (i = 0; i < sc->sc_nframes; i++)
		ixfer->size[i] = sc->sc_vs_cur->psize;

	usbd_setup_isoc_xfer(
	    ixfer->xfer,
	    sc->sc_vs_cur->pipeh,
	    ixfer,
	    ixfer->size,
	    sc->sc_nframes,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK,
	    uvideo_vs_cb);

	error = usbd_transfer(ixfer->xfer);
	if (error && error != USBD_IN_PROGRESS) {
		DPRINTF(1, "%s: usbd_transfer error=%s!\n",
		    DEVNAME(sc), usbd_errstr(error));
	}
}

void
uvideo_vs_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct uvideo_isoc_xfer *ixfer = priv;
	struct uvideo_softc *sc = ixfer->sc;
	int len, i, frame_size;
	uint8_t *frame;
	usbd_status error;

	DPRINTF(2, "%s: %s\n", DEVNAME(sc), __func__);

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(1, "%s: %s: %s\n", DEVNAME(sc), __func__,
		    usbd_errstr(status));
		return;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	DPRINTF(2, "%s: *** buffer len = %d\n", DEVNAME(sc), len);
	if (len == 0)
		goto skip;

	for (i = 0; i < sc->sc_nframes; i++) {
		frame = ixfer->buf + (i * sc->sc_vs_cur->psize);
		frame_size = ixfer->size[i];

		if (frame_size == 0)
			/* frame is empty */
			continue;

		error = sc->sc_decode_stream_header(sc, frame, frame_size);
		if (error == USBD_CANCELLED)
			break;
	}

skip:	/* setup new transfer */
	uvideo_vs_start_isoc_ixfer(sc, ixfer);
}

usbd_status
uvideo_vs_decode_stream_header(struct uvideo_softc *sc, uint8_t *frame,
    int frame_size)
{
	struct uvideo_frame_buffer *fb = &sc->sc_frame_buffer;
	struct usb_video_stream_header *sh;
	int sample_len;

	if (frame_size < UVIDEO_SH_MIN_LEN)
		/* frame too small to contain a valid stream header */
		return (USBD_INVAL);

	sh = (struct usb_video_stream_header *)frame;

	DPRINTF(2, "%s: stream header len = %d\n", DEVNAME(sc), sh->bLength);

	if (sh->bLength > UVIDEO_SH_MAX_LEN || sh->bLength < UVIDEO_SH_MIN_LEN)
		/* invalid header size */
		return (USBD_INVAL);
	if (sh->bLength == frame_size && !(sh->bFlags & UVIDEO_SH_FLAG_EOF)) {
		/* stream header without payload and no EOF */
		return (USBD_INVAL);
	}
	if (sh->bFlags & UVIDEO_SH_FLAG_ERR) {
		/* stream error, skip xfer */
		DPRINTF(1, "%s: %s: stream error!\n", DEVNAME(sc), __func__);
		return (USBD_CANCELLED);
	}

	DPRINTF(2, "%s: frame_size = %d\n", DEVNAME(sc), frame_size);

	if (sh->bFlags & UVIDEO_SH_FLAG_FID) {
		DPRINTF(2, "%s: %s: FID ON (0x%02x)\n",
		    DEVNAME(sc), __func__,
		    sh->bFlags & UVIDEO_SH_FLAG_FID);
	} else {
		DPRINTF(2, "%s: %s: FID OFF (0x%02x)\n",
		    DEVNAME(sc), __func__,
		    sh->bFlags & UVIDEO_SH_FLAG_FID);
	}

	if (fb->sample == 0) {
		/* first sample for a frame */
		fb->sample = 1;
		fb->fid = sh->bFlags & UVIDEO_SH_FLAG_FID;
		fb->offset = 0;
	} else {
		/* continues sample for a frame, check consistency */
		if (fb->fid != (sh->bFlags & UVIDEO_SH_FLAG_FID)) {
			DPRINTF(1, "%s: %s: wrong FID, ignore last frame!\n",
			    DEVNAME(sc), __func__);
			fb->sample = 1;
			fb->fid = sh->bFlags & UVIDEO_SH_FLAG_FID;
			fb->offset = 0;
		}
	}

	/* save sample */
	sample_len = frame_size - sh->bLength;
	if ((fb->offset + sample_len) <= fb->buf_size) {
		bcopy(frame + sh->bLength, fb->buf + fb->offset, sample_len);
		fb->offset += sample_len;
	}

	if (sh->bFlags & UVIDEO_SH_FLAG_EOF) {
		/* got a full frame */
		DPRINTF(2, "%s: %s: EOF (frame size = %d bytes)\n",
		    DEVNAME(sc), __func__, fb->offset);

		if (fb->offset > fb->buf_size) {
			DPRINTF(1, "%s: %s: frame too large, skipped!\n",
			    DEVNAME(sc), __func__);
		} else if (fb->offset < fb->buf_size &&
		    !(fb->fmt_flags & V4L2_FMT_FLAG_COMPRESSED)) {
			DPRINTF(1, "%s: %s: frame too small, skipped!\n",
			    DEVNAME(sc), __func__);
		} else {
#ifdef UVIDEO_DUMP
			/* do the file write in process context */
			usb_rem_task(sc->sc_udev, &sc->sc_task_write);
			usb_add_task(sc->sc_udev, &sc->sc_task_write);
#endif
			if (sc->sc_mmap_flag) {
				/* mmap */
				if (uvideo_mmap_queue(sc, fb->buf, fb->offset))
					return (USBD_NOMEM);
			} else {
				/* read */
				uvideo_read(sc, fb->buf, fb->offset);
			}
		}

		fb->sample = 0;
		fb->fid = 0;
	}

	return (USBD_NORMAL_COMPLETION);
}

/*
 * XXX Doesn't work yet.  Fix it!
 *
 * The iSight first generation device uses a own, non-standard streaming
 * protocol.  The stream header is just sent once per image and looks
 * like following:
 *
 *	uByte 	header length
 *	uByte	flags
 *	uByte	magic1[4]	always "11223344"
 *	uByte	magic2[8]	always "deadbeefdeadface"
 *	uByte	unknown[16]
 *
 * Sometimes the stream header is prefixed by a unknown byte.  Therefore
 * we check for the magic value on two offsets.
 */
usbd_status
uvideo_vs_decode_stream_header_isight(struct uvideo_softc *sc, uint8_t *frame,
    int frame_size)
{
	struct uvideo_frame_buffer *fb = &sc->sc_frame_buffer;
	int sample_len, header = 0;
	uint8_t magic[] = {
	    0x11, 0x22, 0x33, 0x44,
	    0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xfa, 0xce };

	if (frame_size > 13 && !memcmp(&frame[2], magic, 12))
		header = 1;
	if (frame_size > 14 && !memcmp(&frame[3], magic, 12))
		header = 1;

	if (header && fb->fid == 0) {
		fb->fid = 1;
		return (USBD_NORMAL_COMPLETION);
	}

	if (header) {
		if (sc->sc_mmap_flag) {
			/* mmap */
			if (uvideo_mmap_queue(sc, fb->buf, fb->offset))
				return (USBD_NOMEM);
		} else {
			/* read */
			uvideo_read(sc, fb->buf, fb->offset);
		}
		fb->offset = 0;
	} else {
		/* save sample */
		sample_len = frame_size;
		if ((fb->offset + sample_len) <= fb->buf_size) {
			bcopy(frame, fb->buf + fb->offset, sample_len);
			fb->offset += sample_len;
		}
	}

	return (USBD_NORMAL_COMPLETION);
}

int
uvideo_mmap_queue(struct uvideo_softc *sc, uint8_t *buf, int len)
{
	int i;

	if (sc->sc_mmap_count == 0 || sc->sc_mmap_buffer == NULL)
		panic("%s: mmap buffers not allocated", __func__);

	/* find a buffer which is ready for queueing */
	for (i = 0; i < sc->sc_mmap_count; i++) {
		if (sc->sc_mmap[i].v4l2_buf.flags & V4L2_BUF_FLAG_QUEUED)
			break;
	}
	if (i == sc->sc_mmap_count) {
		DPRINTF(1, "%s: %s: mmap queue is full!",
		    DEVNAME(sc), __func__);
		return ENOMEM;
	}

	/* copy frame to mmap buffer and report length */
	bcopy(buf, sc->sc_mmap[i].buf, len);
	sc->sc_mmap[i].v4l2_buf.bytesused = len;

	/* timestamp it */
	getmicrotime(&sc->sc_mmap[i].v4l2_buf.timestamp);

	/* queue it */
	sc->sc_mmap[i].v4l2_buf.flags |= V4L2_BUF_FLAG_DONE;
	sc->sc_mmap[i].v4l2_buf.flags &= ~V4L2_BUF_FLAG_QUEUED;
	SIMPLEQ_INSERT_TAIL(&sc->sc_mmap_q, &sc->sc_mmap[i], q_frames);
	DPRINTF(2, "%s: %s: frame queued on index %d\n",
	    DEVNAME(sc), __func__, i);

	wakeup(sc);

	/*
	 * In case userland uses poll(2), signal that we have a frame
	 * ready to dequeue.
	 */
	sc->sc_uplayer_intr(sc->sc_uplayer_arg);

	return 0;
}

void
uvideo_read(struct uvideo_softc *sc, uint8_t *buf, int len)
{
	/*
	 * Copy video frame to upper layer buffer and call
	 * upper layer interrupt.
	 */
	*sc->sc_uplayer_fsize = len;
	bcopy(buf, sc->sc_uplayer_fbuffer, len);
	sc->sc_uplayer_intr(sc->sc_uplayer_arg);
}

#ifdef UVIDEO_DEBUG
void
uvideo_dump_desc_all(struct uvideo_softc *sc)
{
	struct usbd_desc_iter iter;
	const usb_descriptor_t *desc;

	usbd_desc_iter_init(sc->sc_udev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		printf("bLength=%d\n", desc->bLength);
		printf("bDescriptorType=0x%02x", desc->bDescriptorType);

		switch (desc->bDescriptorType) {
		case UDESC_CS_INTERFACE:
			printf(" (CS_INTERFACE)\n");

			switch (desc->bDescriptorSubtype) {
			case UDESCSUB_VC_HEADER:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				if (uvideo_desc_len(desc, 12, 11, 1, 0)) {
					printf(" (UDESCSUB_VC_HEADER)\n");
					printf("|\n");
					uvideo_dump_desc_vc_header(sc, desc);
					break;
				}
				if (uvideo_desc_len(desc, 13, 3, 0, 12)) {
					printf(" (UDESCSUB_VS_INPUT_HEADER)\n");
					printf("|\n");
					uvideo_dump_desc_input_header(sc, desc);
					break;
				}
				printf(" (unknown)\n");
				break;
			case UDESCSUB_VC_INPUT_TERMINAL:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				printf(" (UDESCSUB_VC_INPUT_TERMINAL)\n");
				printf("|\n");
				uvideo_dump_desc_input(sc, desc);
				break;
			case UDESCSUB_VC_OUTPUT_TERMINAL:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				printf(" (UDESCSUB_VC_OUTPUT)\n");
				printf("|\n");
				uvideo_dump_desc_output(sc, desc);
				break;
			case UDESCSUB_VC_SELECTOR_UNIT:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				if (desc->bLength == 27) {
					printf(" (UDESCSUB_VS_FORMAT_"
					    "UNCOMPRESSED)\n");
					uvideo_dump_desc_format_uncompressed(
					    sc, desc);
				} else {
					printf(" (UDESCSUB_VC_SELECTOR_"
					    "UNIT)\n");
					/* TODO */
				}
				break;
			case UDESCSUB_VC_PROCESSING_UNIT:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				if (desc->bLength >
				    sizeof(struct usb_video_frame_desc)) {
					printf(" (UDESCSUB_VS_FRAME_"
					    "UNCOMPRESSED)\n");
					uvideo_dump_desc_frame(sc, desc);
				} else {
					printf(" (UDESCSUB_VC_PROCESSING_"
					    "UNIT)\n");
					printf("|\n");
					uvideo_dump_desc_processing(sc, desc);
				}
				break;
			case UDESCSUB_VC_EXTENSION_UNIT:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				if (desc->bLength == 11) {
					printf(" (UDESCSUB_VS_FORMAT_MJPEG)\n");
					printf("|\n");
					uvideo_dump_desc_format_mjpeg(sc, desc);
				} else {
					printf(" (UDESCSUB_VC_EXTENSION_"
					    "UNIT)\n");
					printf("|\n");
					uvideo_dump_desc_extension(sc, desc);
				}
				break;
			case UDESCSUB_VS_FRAME_MJPEG:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				printf(" (UDESCSUB_VS_FRAME_MJPEG)\n");
				if (desc->bLength >
				    sizeof(struct usb_video_frame_desc)) {
					printf("|\n");
					uvideo_dump_desc_frame(sc, desc);
				}
				break;
			case UDESCSUB_VS_COLORFORMAT:
				printf("bDescriptorSubtype=0x%02x",
				   desc->bDescriptorSubtype);
				printf(" (UDESCSUB_VS_COLORFORMAT)\n");
				printf("|\n");
				uvideo_dump_desc_colorformat(sc, desc);
				break;
			}

			break;
		case UDESC_CS_ENDPOINT:
			printf(" (UDESC_CS_ENDPOINT)\n");

			switch (desc->bDescriptorSubtype) {
			case EP_INTERRUPT:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				printf(" (EP_INTERRUPT)\n");
				printf("|\n");
				uvideo_dump_desc_cs_endpoint(sc, desc);
				break;
			case EP_GENERAL:
				printf("bDescriptorSubtype=0x%02x",
				    desc->bDescriptorSubtype);
				printf(" (EP_GENERAL)\n");
				printf("|\n");
				uvideo_dump_desc_cs_endpoint(sc, desc);
				break;
			}

			break;
		case UDESC_CONFIG:
			printf(" (UDESC_CONFIG)\n");
			printf("|\n");
			uvideo_dump_desc_config(sc, desc);
			break;
		case UDESC_ENDPOINT:
			printf(" (UDESC_ENDPOINT)\n");
			printf("|\n");
			uvideo_dump_desc_endpoint(sc, desc);
			break;
		case UDESC_INTERFACE:
			printf(" (UDESC_INTERFACE)\n");
			printf("|\n");
			uvideo_dump_desc_interface(sc, desc);
			break;
		default:
			printf(" (unknown)\n");
			break;
		}

		printf("\n");

		desc = usbd_desc_iter_next(&iter);
	}	

}

void
uvideo_dump_desc_vc_header(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_header_desc *d;

	d = (struct usb_video_header_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bcdUVC=0x%04x\n", UGETW(d->bcdUVC));
	printf("wTotalLength=%d\n", UGETW(d->wTotalLength));
	printf("dwClockFrequency=%d\n", UGETDW(d->dwClockFrequency));
	printf("bInCollection=0x%02x\n", d->bInCollection);
}

void
uvideo_dump_desc_input_header(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_input_header_desc *d;

	d = (struct usb_video_input_header_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bNumFormats=%d\n", d->bNumFormats);
	printf("wTotalLength=%d\n", UGETW(d->wTotalLength));
	printf("bEndpointAddress=0x%02x\n", d->bEndpointAddress);
	printf("bmInfo=0x%02x\n", d->bmInfo);
	printf("bTerminalLink=0x%02x\n", d->bTerminalLink);
	printf("bStillCaptureMethod=0x%02x\n", d->bStillCaptureMethod);
	printf("bTriggerSupport=0x%02x\n", d->bTriggerSupport);
	printf("bTriggerUsage=0x%02x\n", d->bTriggerUsage);
	printf("bControlSize=%d\n", d->bControlSize);
}

void
uvideo_dump_desc_input(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_input_terminal_desc *d;

	d = (struct usb_video_input_terminal_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bTerminalID=0x%02x\n", d->bTerminalID);
	printf("wTerminalType=0x%04x\n", UGETW(d->wTerminalType));
	printf("bAssocTerminal=0x%02x\n", d->bAssocTerminal);
	printf("iTerminal=0x%02x\n", d->iTerminal);
}

void
uvideo_dump_desc_output(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_output_terminal_desc *d;

	d = (struct usb_video_output_terminal_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bTerminalID=0x%02x\n", d->bTerminalID);
	printf("bAssocTerminal=0x%02x\n", d->bAssocTerminal);
	printf("bSourceID=0x%02x\n", d->bSourceID);
	printf("iTerminal=0x%02x\n", d->iTerminal);

}

void
uvideo_dump_desc_endpoint(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	usb_endpoint_descriptor_t *d;

	d = (usb_endpoint_descriptor_t *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bEndpointAddress=0x%02x", d->bEndpointAddress);
	if (UE_GET_DIR(d->bEndpointAddress) == UE_DIR_IN)
		printf(" (IN)\n");
	if (UE_GET_DIR(d->bEndpointAddress) == UE_DIR_OUT)
		printf(" (OUT)\n");
	printf("bmAttributes=0x%02x", d->bmAttributes);
	if (UE_GET_XFERTYPE(d->bmAttributes) == UE_ISOCHRONOUS) {
		printf(" (UE_ISOCHRONOUS,");
		if (UE_GET_ISO_TYPE(d->bmAttributes) == UE_ISO_ASYNC)
			printf(" UE_ISO_ASYNC)\n");
		if (UE_GET_ISO_TYPE(d->bmAttributes) == UE_ISO_ADAPT)
			printf(" UE_ISO_ADAPT)\n");
		if (UE_GET_ISO_TYPE(d->bmAttributes) == UE_ISO_SYNC)
			printf(" UE_ISO_SYNC)\n");
	}
	if (UE_GET_XFERTYPE(d->bmAttributes) == UE_CONTROL)
		printf(" (UE_CONTROL)\n");
	if (UE_GET_XFERTYPE(d->bmAttributes) == UE_BULK)
		printf(" (UE_BULK)\n");
	if (UE_GET_XFERTYPE(d->bmAttributes) == UE_INTERRUPT)
		printf(" (UE_INTERRUPT)\n");
	printf("wMaxPacketSize=%d\n", UGETW(d->wMaxPacketSize));
	printf("bInterval=0x%02x\n", d->bInterval);
}

void
uvideo_dump_desc_interface(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	usb_interface_descriptor_t *d;

	d = (usb_interface_descriptor_t *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bInterfaceNumber=0x%02x\n", d->bInterfaceNumber);
	printf("bAlternateSetting=0x%02x\n", d->bAlternateSetting);
	printf("bNumEndpoints=%d\n", d->bNumEndpoints);
	printf("bInterfaceClass=0x%02x\n", d->bInterfaceClass);
	printf("bInterfaceSubClass=0x%02x\n", d->bInterfaceSubClass);
	printf("bInterfaceProtocol=0x%02x\n", d->bInterfaceProtocol);
	printf("iInterface=0x%02x\n", d->iInterface);
}

void
uvideo_dump_desc_config(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	usb_config_descriptor_t *d;

	d = (usb_config_descriptor_t *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("wTotalLength=%d\n", UGETW(d->wTotalLength));
	printf("bNumInterface=0x%02x\n", d->bNumInterface);
	printf("bConfigurationValue=0x%02x\n", d->bConfigurationValue);
	printf("iConfiguration=0x%02x\n", d->iConfiguration);
	printf("bmAttributes=0x%02x\n", d->bmAttributes);
	printf("bMaxPower=0x%02x\n", d->bMaxPower);
}

void
uvideo_dump_desc_cs_endpoint(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_vc_endpoint_desc *d;

	d = (struct usb_video_vc_endpoint_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("wMaxTransferSize=%d\n", UGETW(d->wMaxTransferSize));
}

void
uvideo_dump_desc_colorformat(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_color_matching_descr *d;

	d = (struct usb_video_color_matching_descr *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bColorPrimaries=0x%02x\n", d->bColorPrimaries);
	printf("bTransferCharacteristics=0x%02x\n",
	    d->bTransferCharacteristics);
	printf("bMatrixCoefficients=0x%02x\n", d->bMatrixCoefficients);
}
void
uvideo_dump_desc_format_mjpeg(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_format_mjpeg_desc *d;

	d = (struct usb_video_format_mjpeg_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bFormatIndex=0x%02x\n", d->bFormatIndex);
	printf("bNumFrameDescriptors=0x%02x\n", d->bNumFrameDescriptors);
	printf("bmFlags=0x%02x\n", d->bmFlags);
	printf("bDefaultFrameIndex=0x%02x\n", d->bDefaultFrameIndex);
	printf("bAspectRatioX=0x%02x\n", d->bAspectRatioX);
	printf("bAspectRatioY=0x%02x\n", d->bAspectRatioY);
	printf("bmInterlaceFlags=0x%02x\n", d->bmInterlaceFlags);
	printf("bCopyProtect=0x%02x\n", d->bCopyProtect);
}

void
uvideo_dump_desc_frame(struct uvideo_softc *sc, const usb_descriptor_t *desc)
{
	struct usb_video_frame_desc *d;
	uint8_t *p;
	int length, i;

	d = (struct usb_video_frame_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bFrameIndex=0x%02x\n", d->bFrameIndex);
	printf("bmCapabilities=0x%02x\n", d->bmCapabilities);
	printf("wWidth=%d\n", UGETW(d->wWidth));
	printf("wHeight=%d\n", UGETW(d->wHeight));
	printf("dwMinBitRate=%d\n", UGETDW(d->dwMinBitRate));
	printf("dwMaxBitRate=%d\n", UGETDW(d->dwMaxBitRate));
	printf("dwMaxVideoFrameBufferSize=%d\n",
	    UGETDW(d->dwMaxVideoFrameBufferSize));
	printf("dwDefaultFrameInterval=%d\n",
	    UGETDW(d->dwDefaultFrameInterval));
	printf("bFrameIntervalType=0x%02x\n", d->bFrameIntervalType);

	p = (uint8_t *)d;
	p += sizeof(struct usb_video_frame_desc);

	if (!d->bFrameIntervalType) {
		/* continuous */
		if (d->bLength < (sizeof(struct usb_video_frame_desc) +
		    sizeof(uDWord) * 3)) {
			printf("invalid frame descriptor length\n");
		} else {
			printf("dwMinFrameInterval = %d\n", UGETDW(p));
			p += sizeof(uDWord);
			printf("dwMaxFrameInterval = %d\n", UGETDW(p));
			p += sizeof(uDWord);
			printf("dwFrameIntervalStep = %d\n", UGETDW(p));
			p += sizeof(uDWord);
		}
	} else {
		/* discrete */
		length = d->bLength - sizeof(struct usb_video_frame_desc);
		for (i = 0; i < d->bFrameIntervalType; i++) {
			if (length <= 0) {
				printf("frame descriptor ended early\n");
				break;
			}
			printf("dwFrameInterval = %d\n", UGETDW(p));
			p += sizeof(uDWord);
			length -= sizeof(uDWord);
		}
	}
}

void
uvideo_dump_desc_format_uncompressed(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_format_uncompressed_desc *d;

	d = (struct usb_video_format_uncompressed_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bFormatIndex=0x%02x\n", d->bFormatIndex);
	printf("bNumFrameDescriptors=0x%02x\n", d->bNumFrameDescriptors);
	printf("guidFormat=%s\n", d->guidFormat);
	printf("bBitsPerPixel=0x%02x\n", d->bBitsPerPixel);
	printf("bDefaultFrameIndex=0x%02x\n", d->bDefaultFrameIndex);
	printf("bAspectRatioX=0x%02x\n", d->bAspectRatioX);
	printf("bAspectRatioY=0x%02x\n", d->bAspectRatioY);
	printf("bmInterlaceFlags=0x%02x\n", d->bmInterlaceFlags);
	printf("bCopyProtect=0x%02x\n", d->bCopyProtect);
}

void
uvideo_dump_desc_processing(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_vc_processing_desc *d;

	/* PU descriptor is variable sized */
	d = (void *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bUnitID=0x%02x\n", d->bUnitID);
	printf("bSourceID=0x%02x\n", d->bSourceID);
	printf("wMaxMultiplier=%d\n", UGETW(d->wMaxMultiplier));
	printf("bControlSize=%d\n", d->bControlSize);
	printf("bmControls=0x");
	uvideo_hexdump(d->bmControls, d->bControlSize, 1);
	printf("iProcessing=0x%02x\n", d->bmControls[d->bControlSize]);
	printf("bmVideoStandards=0x%02x\n", d->bmControls[d->bControlSize + 1]);
}

void
uvideo_dump_desc_extension(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_vc_extension_desc *d;

	d = (struct usb_video_vc_extension_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bUnitID=0x%02x\n", d->bUnitID);
	printf("guidExtensionCode=0x");
	uvideo_hexdump(d->guidExtensionCode, sizeof(d->guidExtensionCode), 1);
	printf("bNumControls=0x%02x\n", d->bNumControls);
	printf("bNrInPins=0x%02x\n", d->bNrInPins);
}

void
uvideo_hexdump(void *buf, int len, int quiet)
{
	int i;

	for (i = 0; i < len; i++) {
		if (quiet == 0) {
			if (i % 16 == 0)
				printf("%s%5i:", i ? "\n" : "", i);
			if (i % 4 == 0)
				printf(" ");
		}
		printf("%02x", (int)*((u_char *)buf + i));
	}
	printf("\n");
}

int
uvideo_debug_file_open(struct uvideo_softc *sc)
{
	struct proc *p = curproc;
	struct nameidata nd;
	char name[] = "/tmp/uvideo.mjpeg";
	int error;

	NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, name, p);
	error = vn_open(&nd, O_CREAT | FWRITE | O_NOFOLLOW, S_IRUSR | S_IWUSR);
	if (error) {
		DPRINTF(1, "%s: %s: can't create debug file %s!\n",
		    DEVNAME(sc), __func__, name);
		return (error);
	}

	sc->sc_vp = nd.ni_vp;
	VOP_UNLOCK(sc->sc_vp, p);
	if (nd.ni_vp->v_type != VREG) {
		vn_close(nd.ni_vp, FWRITE, p->p_ucred, p);
		return (EIO);
	}

	DPRINTF(1, "%s: %s: created debug file %s\n",
	    DEVNAME(sc), __func__, name);

	return (0);
}

void
uvideo_debug_file_write_frame(void *arg)
{
	struct uvideo_softc *sc = arg;
	struct uvideo_frame_buffer *sb = &sc->sc_frame_buffer;
	struct proc *p = curproc;
	int error;

	if (sc->sc_vp == NULL) {
		printf("%s: %s: no file open!\n", DEVNAME(sc), __func__);
		return;
	}

	error = vn_rdwr(UIO_WRITE, sc->sc_vp, sb->buf, sb->offset, (off_t)0,
	    UIO_SYSSPACE, IO_APPEND|IO_UNIT, p->p_ucred, NULL, p);

	if (error)
		DPRINTF(1, "vn_rdwr error!\n");
}
#endif

/*
 * IOCTL's
 */
int
uvideo_querycap(void *v, struct v4l2_capability *caps)
{
	struct uvideo_softc *sc = v;

	bzero(caps, sizeof(*caps));
	strlcpy(caps->driver, DEVNAME(sc), sizeof(caps->driver));
	strlcpy(caps->card, "Generic USB video class device",
	    sizeof(caps->card));
	strlcpy(caps->bus_info, "usb", sizeof(caps->bus_info));

	caps->version = 1;
	caps->capabilities = V4L2_CAP_VIDEO_CAPTURE
	    | V4L2_CAP_STREAMING
	    | V4L2_CAP_READWRITE;

	return (0);
}

int
uvideo_enum_fmt(void *v, struct v4l2_fmtdesc *fmtdesc)
{
	struct uvideo_softc *sc = v;
	int idx;

	if (fmtdesc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		/* type not supported */
		return (EINVAL);

	if (fmtdesc->index >= sc->sc_fmtgrp_num)
		/* no more formats left */
		return (EINVAL);
	idx = fmtdesc->index;

	switch (sc->sc_fmtgrp[idx].format->bDescriptorSubtype) {
	case UDESCSUB_VS_FORMAT_MJPEG:
		fmtdesc->flags = V4L2_FMT_FLAG_COMPRESSED;
		(void)strlcpy(fmtdesc->description, "MJPEG",
		    sizeof(fmtdesc->description));
		fmtdesc->pixelformat = V4L2_PIX_FMT_MJPEG;
		bzero(fmtdesc->reserved, sizeof(fmtdesc->reserved));
		break;
	case UDESCSUB_VS_FORMAT_UNCOMPRESSED:
		fmtdesc->flags = 0;
		if (sc->sc_fmtgrp[idx].pixelformat ==
		    V4L2_PIX_FMT_YUYV) {
			(void)strlcpy(fmtdesc->description, "YUYV",
			    sizeof(fmtdesc->description));
			fmtdesc->pixelformat = V4L2_PIX_FMT_YUYV;
		} else if (sc->sc_fmtgrp[idx].pixelformat ==
		    V4L2_PIX_FMT_NV12) {
			(void)strlcpy(fmtdesc->description, "NV12",
			    sizeof(fmtdesc->description));
			fmtdesc->pixelformat = V4L2_PIX_FMT_NV12;
		} else if (sc->sc_fmtgrp[idx].pixelformat ==
		    V4L2_PIX_FMT_UYVY) {
			(void)strlcpy(fmtdesc->description, "UYVY",
			    sizeof(fmtdesc->description));
			fmtdesc->pixelformat = V4L2_PIX_FMT_UYVY;
		} else {
			(void)strlcpy(fmtdesc->description, "Unknown UC Format",
			    sizeof(fmtdesc->description));
			fmtdesc->pixelformat = 0;
		}
		bzero(fmtdesc->reserved, sizeof(fmtdesc->reserved));
		break;
	default:
		fmtdesc->flags = 0;
		(void)strlcpy(fmtdesc->description, "Unknown Format",
		    sizeof(fmtdesc->description));
		fmtdesc->pixelformat = 0;
		bzero(fmtdesc->reserved, sizeof(fmtdesc->reserved));
		break;
	}

	return (0);
}

int
uvideo_enum_fsizes(void *v, struct v4l2_frmsizeenum *fsizes)
{
	struct uvideo_softc *sc = v;
	int idx, found = 0;

	for (idx = 0; idx < sc->sc_fmtgrp_num; idx++) {
		if (sc->sc_fmtgrp[idx].pixelformat == fsizes->pixel_format) {
			found = 1;
			break;
		}
	}
	if (found == 0)
		return (EINVAL);

	if (fsizes->index >= sc->sc_fmtgrp[idx].frame_num)
		return (EINVAL);

	fsizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;
	fsizes->discrete.width =
	    UGETW(sc->sc_fmtgrp[idx].frame[fsizes->index]->wWidth);
	fsizes->discrete.height =
	    UGETW(sc->sc_fmtgrp[idx].frame[fsizes->index]->wHeight);

	return (0);
}

int
uvideo_enum_fivals(void *v, struct v4l2_frmivalenum *fivals)
{
	struct uvideo_softc *sc = v;
	int idx;
	struct uvideo_format_group *fmtgrp = NULL;
	struct usb_video_frame_desc *frame = NULL;
	uint8_t *p;

	for (idx = 0; idx < sc->sc_fmtgrp_num; idx++) {
		if (sc->sc_fmtgrp[idx].pixelformat == fivals->pixel_format) {
			fmtgrp = &sc->sc_fmtgrp[idx];
			break;
		}
	}
	if (fmtgrp == NULL)
		return (EINVAL);

	for (idx = 0; idx < fmtgrp->frame_num; idx++) {
		if (UGETW(fmtgrp->frame[idx]->wWidth) == fivals->width &&
		    UGETW(fmtgrp->frame[idx]->wHeight) == fivals->height) {
			frame = fmtgrp->frame[idx];
			break;
		}
	}
	if (frame == NULL)
		return (EINVAL);

	/* byte-wise pointer to start of frame intervals */
	p = (uint8_t *)frame;
	p += sizeof(struct usb_video_frame_desc);

	if (frame->bFrameIntervalType == 0) {
		if (fivals->index != 0)
			return (EINVAL);
		fivals->type = V4L2_FRMIVAL_TYPE_STEPWISE;
		fivals->stepwise.min.numerator = UGETDW(p);
		fivals->stepwise.min.denominator = 10000000;
		p += sizeof(uDWord);
		fivals->stepwise.max.numerator = UGETDW(p);
		fivals->stepwise.max.denominator = 10000000;
		p += sizeof(uDWord);
		fivals->stepwise.step.numerator = UGETDW(p);
		fivals->stepwise.step.denominator = 10000000;
		p += sizeof(uDWord);
	} else {
		if (fivals->index >= frame->bFrameIntervalType)
			return (EINVAL);
		p += sizeof(uDWord) * fivals->index;
		if (p > frame->bLength + (uint8_t *)frame) {
			printf("%s: frame desc too short?\n", __func__);
			return (EINVAL);
		}
		fivals->type = V4L2_FRMIVAL_TYPE_DISCRETE;
		fivals->discrete.numerator = UGETDW(p);
		fivals->discrete.denominator = 10000000;
	}

	return (0);
}

int
uvideo_s_fmt(void *v, struct v4l2_format *fmt)
{
	struct uvideo_softc *sc = v;
	struct uvideo_format_group *fmtgrp_save;
	struct usb_video_frame_desc *frame_save;
	struct uvideo_res r;
	int found, i;
	usbd_status error;

	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return (EINVAL);

	DPRINTF(1, "%s: %s: requested width=%d, height=%d\n",
	    DEVNAME(sc), __func__, fmt->fmt.pix.width, fmt->fmt.pix.height);

	/* search requested pixel format */
	for (found = 0, i = 0; i < sc->sc_fmtgrp_num; i++) {
		if (fmt->fmt.pix.pixelformat == sc->sc_fmtgrp[i].pixelformat) {
			found = 1;
			break;
		}
	}
	if (found == 0)
		return (EINVAL);

	/* check if the format descriptor contains frame descriptors */
	if (sc->sc_fmtgrp[i].frame_num == 0) {
		printf("%s: %s: no frame descriptors found!\n",
		    __func__, DEVNAME(sc));
		return (EINVAL);
	}

	/* search requested frame resolution */
	uvideo_find_res(sc, i, fmt->fmt.pix.width, fmt->fmt.pix.height, &r);

	/*
	 * Do negotiation.
	 */
	/* save a copy of current fromat group in case of negotiation fails */
	fmtgrp_save = sc->sc_fmtgrp_cur;
	frame_save = sc->sc_fmtgrp_cur->frame_cur;
	/* set new format group */
	sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[i];
	sc->sc_fmtgrp[i].frame_cur = sc->sc_fmtgrp[i].frame[r.fidx];

	/* do device negotiation with commit */
	error = uvideo_vs_negotiation(sc, 1);
	if (error != USBD_NORMAL_COMPLETION) {
		sc->sc_fmtgrp_cur = fmtgrp_save;
		sc->sc_fmtgrp_cur->frame_cur = frame_save;
		return (EINVAL);
	}
	sc->sc_negotiated_flag = 1;

	/* offer closest resolution which we have found */
	fmt->fmt.pix.width = r.width;
	fmt->fmt.pix.height = r.height;

	DPRINTF(1, "%s: %s: offered width=%d, height=%d\n",
	    DEVNAME(sc), __func__, r.width, r.height);

	/* tell our frame buffer size */
	fmt->fmt.pix.sizeimage = UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize);

	return (0);
}

int
uvideo_g_fmt(void *v, struct v4l2_format *fmt)
{
	struct uvideo_softc *sc = v;

	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return (EINVAL);

	fmt->fmt.pix.pixelformat = sc->sc_fmtgrp_cur->pixelformat;
	fmt->fmt.pix.width = UGETW(sc->sc_fmtgrp_cur->frame_cur->wWidth);
	fmt->fmt.pix.height = UGETW(sc->sc_fmtgrp_cur->frame_cur->wHeight);
	fmt->fmt.pix.sizeimage = UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize);

	DPRINTF(1, "%s: %s: current width=%d, height=%d\n",
	    DEVNAME(sc), __func__, fmt->fmt.pix.width, fmt->fmt.pix.height);

	return (0);
}

int
uvideo_s_parm(void *v, struct v4l2_streamparm *parm)
{
	struct uvideo_softc *sc = v;
	usbd_status error;

	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
		/*
		 * XXX Only whole number frame rates for now.  Frame
		 * rate is the inverse of time per frame.
		 */
		if (parm->parm.capture.timeperframe.numerator == 0 ||
		    parm->parm.capture.timeperframe.denominator == 0) {
			sc->sc_frame_rate = 0;
		} else {
			sc->sc_frame_rate =
			    parm->parm.capture.timeperframe.denominator /
			    parm->parm.capture.timeperframe.numerator;
		}
	} else
		return (EINVAL);

	/* renegotiate if necessary */
	if (sc->sc_negotiated_flag) {
		error = uvideo_vs_negotiation(sc, 1);
		if (error != USBD_NORMAL_COMPLETION)
			return (error);
	}

	return (0);
}

int
uvideo_g_parm(void *v, struct v4l2_streamparm *parm)
{
	struct uvideo_softc *sc = v;

	if (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
		parm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;
		parm->parm.capture.capturemode = 0;
		parm->parm.capture.timeperframe.numerator =
		    UGETDW(sc->sc_desc_probe.dwFrameInterval);
		parm->parm.capture.timeperframe.denominator = 10000000;
	} else
		return (EINVAL);

	return (0);
}

int
uvideo_enum_input(void *v, struct v4l2_input *input)
{
	if (input->index != 0)
		/* XXX we just support one input for now */
		return (EINVAL);

	strlcpy(input->name, "Camera Terminal", sizeof(input->name));
	input->type = V4L2_INPUT_TYPE_CAMERA;

	return (0);
}

int
uvideo_s_input(void *v, int input)
{
	if (input != 0)
		/* XXX we just support one input for now */
		return (EINVAL);

	return (0);
}

int
uvideo_g_input(void *v, int *input)
{
	/* XXX we just support one input for now */
	*input = 0;

	return (0);
}

int
uvideo_reqbufs(void *v, struct v4l2_requestbuffers *rb)
{
	struct uvideo_softc *sc = v;
	int i, buf_size, buf_size_total;

	DPRINTF(1, "%s: %s: count=%d\n", DEVNAME(sc), __func__, rb->count);

	/* We do not support freeing buffers via reqbufs(0) */
	if (rb->count == 0)
		return (EINVAL);

	if (sc->sc_mmap_count > 0 || sc->sc_mmap_buffer != NULL) {
		DPRINTF(1, "%s: %s: mmap buffers already allocated\n",
		    DEVNAME(sc), __func__);
		return (EINVAL);
	}

	/* limit the buffers */
	if (rb->count > UVIDEO_MAX_BUFFERS)
		sc->sc_mmap_count = UVIDEO_MAX_BUFFERS;
	else
		sc->sc_mmap_count = rb->count;

	/* allocate the total mmap buffer */	
	buf_size = UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize);
	if (buf_size >= SIZE_MAX / UVIDEO_MAX_BUFFERS) {
		printf("%s: video frame size too large!\n", DEVNAME(sc));
		sc->sc_mmap_count = 0;
		return (EINVAL);
	}
	buf_size_total = sc->sc_mmap_count * buf_size;
	buf_size_total = round_page(buf_size_total); /* page align buffer */
	sc->sc_mmap_buffer = malloc(buf_size_total, M_DEVBUF, M_NOWAIT);
	if (sc->sc_mmap_buffer == NULL) {
		printf("%s: can't allocate mmap buffer!\n", DEVNAME(sc));
		sc->sc_mmap_count = 0;
		return (EINVAL);
	}
	sc->sc_mmap_buffer_size = buf_size_total;
	DPRINTF(1, "%s: allocated %d bytes mmap buffer\n",
	    DEVNAME(sc), buf_size_total);

	/* fill the v4l2_buffer structure */
	for (i = 0; i < sc->sc_mmap_count; i++) {
		sc->sc_mmap[i].buf = sc->sc_mmap_buffer + (i * buf_size);

		sc->sc_mmap[i].v4l2_buf.index = i;
		sc->sc_mmap[i].v4l2_buf.m.offset = i * buf_size;
		sc->sc_mmap[i].v4l2_buf.length = buf_size;
		sc->sc_mmap[i].v4l2_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
		sc->sc_mmap[i].v4l2_buf.sequence = 0;
		sc->sc_mmap[i].v4l2_buf.field = V4L2_FIELD_NONE;
		sc->sc_mmap[i].v4l2_buf.memory = V4L2_MEMORY_MMAP;
		sc->sc_mmap[i].v4l2_buf.flags = V4L2_BUF_FLAG_MAPPED;

		DPRINTF(1, "%s: %s: index=%d, offset=%d, length=%d\n",
		    DEVNAME(sc), __func__,
		    sc->sc_mmap[i].v4l2_buf.index,
		    sc->sc_mmap[i].v4l2_buf.m.offset,
		    sc->sc_mmap[i].v4l2_buf.length);
	}

	/* tell how many buffers we have really allocated */
	rb->count = sc->sc_mmap_count;

	return (0);
}

int
uvideo_querybuf(void *v, struct v4l2_buffer *qb)
{
	struct uvideo_softc *sc = v;

	if (qb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
		return (EINVAL);

	bcopy(&sc->sc_mmap[qb->index].v4l2_buf, qb,
	    sizeof(struct v4l2_buffer));

	DPRINTF(1, "%s: %s: index=%d, offset=%d, length=%d\n",
	    DEVNAME(sc), __func__,
	    qb->index,
	    qb->m.offset,
	    qb->length);

	return (0);
}

int
uvideo_qbuf(void *v, struct v4l2_buffer *qb)
{
	struct uvideo_softc *sc = v;

	if (qb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
		return (EINVAL);

	sc->sc_mmap[qb->index].v4l2_buf.flags &= ~V4L2_BUF_FLAG_DONE;
	sc->sc_mmap[qb->index].v4l2_buf.flags |= V4L2_BUF_FLAG_QUEUED;

	DPRINTF(2, "%s: %s: buffer on index %d ready for queueing\n",
	    DEVNAME(sc), __func__, qb->index);

	return (0);
}

int
uvideo_dqbuf(void *v, struct v4l2_buffer *dqb)
{
	struct uvideo_softc *sc = v;
	struct uvideo_mmap *mmap;
	int error;

	if (dqb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    dqb->memory != V4L2_MEMORY_MMAP)
		return (EINVAL);

	if (SIMPLEQ_EMPTY(&sc->sc_mmap_q)) {
		/* mmap queue is empty, block until first frame is queued */
		error = tsleep(sc, 0, "vid_mmap", 10 * hz);
		if (error)
			return (EINVAL);
	}

	mmap = SIMPLEQ_FIRST(&sc->sc_mmap_q);
	if (mmap == NULL)
		panic("uvideo_dqbuf: NULL pointer!");

	bcopy(&mmap->v4l2_buf, dqb, sizeof(struct v4l2_buffer));

	mmap->v4l2_buf.flags &= ~V4L2_BUF_FLAG_DONE;
	mmap->v4l2_buf.flags &= ~V4L2_BUF_FLAG_QUEUED;

	DPRINTF(2, "%s: %s: frame dequeued from index %d\n",
	    DEVNAME(sc), __func__, mmap->v4l2_buf.index);
	SIMPLEQ_REMOVE_HEAD(&sc->sc_mmap_q, q_frames);

	return (0);
}

int
uvideo_streamon(void *v, int type)
{
	struct uvideo_softc *sc = v;
	usbd_status error;

	error = uvideo_vs_init(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);

	if (sc->sc_vs_cur->bulk_endpoint)
		uvideo_vs_start_bulk(sc);
	else
		uvideo_vs_start_isoc(sc);

	return (0);
}

int
uvideo_streamoff(void *v, int type)
{
	struct uvideo_softc *sc = v;

	uvideo_vs_close(sc);

	return (0);
}

int
uvideo_queryctrl(void *v, struct v4l2_queryctrl *qctrl)
{
	struct uvideo_softc *sc = v;
	int i, ret = 0;
	usbd_status error;
	uint8_t *ctrl_data;
	uint16_t ctrl_len;

	i = uvideo_find_ctrl(sc, qctrl->id);
	if (i == EINVAL)
		return (i);

	ctrl_len = uvideo_ctrls[i].ctrl_len;
	if (ctrl_len < 1 || ctrl_len > 2) {
		printf("%s: invalid control length: %d\n", __func__, ctrl_len);
		return (EINVAL);
	}

	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK | M_CANFAIL);
	if (ctrl_data == NULL) {
		printf("%s: could not allocate control data\n", __func__);
		return (ENOMEM);
	}

	/* set type */
	qctrl->type = uvideo_ctrls[i].type;

	/* set description name */
	strlcpy(qctrl->name, uvideo_ctrls[i].name, sizeof(qctrl->name));

	/* set minimum */
	error = uvideo_vc_get_ctrl(sc, ctrl_data, GET_MIN,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION) {
		ret = EINVAL;
		goto out;
	}
	switch (ctrl_len) {
	case 1:
		qctrl->minimum = uvideo_ctrls[i].sig ?
		    *(int8_t *)ctrl_data :
		    *ctrl_data;
		break;
	case 2:
		qctrl->minimum = uvideo_ctrls[i].sig ?
		    (int16_t)UGETW(ctrl_data) :
		    UGETW(ctrl_data);
		break;
	}

	/* set maximum */
	error = uvideo_vc_get_ctrl(sc, ctrl_data, GET_MAX,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION) {
		ret = EINVAL;
		goto out;
	}
	switch(ctrl_len) {
	case 1:
		qctrl->maximum = uvideo_ctrls[i].sig ?
		    *(int8_t *)ctrl_data :
		    *ctrl_data;
		break;
	case 2:
		qctrl->maximum = uvideo_ctrls[i].sig ?
		    (int16_t)UGETW(ctrl_data) :
		    UGETW(ctrl_data);
		break;
	}

	/* set resolution */
	error = uvideo_vc_get_ctrl(sc, ctrl_data, GET_RES,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION) {
		ret = EINVAL;
		goto out;
	}
	switch(ctrl_len) {
	case 1:
		qctrl->step = uvideo_ctrls[i].sig ?
		    *(int8_t *)ctrl_data:
		    *ctrl_data;
		break;
	case 2:
		qctrl->step = uvideo_ctrls[i].sig ?
		    (int16_t)UGETW(ctrl_data) :
		    UGETW(ctrl_data);
		break;
	}

	/* set default */
	error = uvideo_vc_get_ctrl(sc, ctrl_data, GET_DEF,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION) {
		ret = EINVAL;
		goto out;
	}
	switch(ctrl_len) {
	case 1:
		qctrl->default_value = uvideo_ctrls[i].sig ?
		    *(int8_t *)ctrl_data :
		    *ctrl_data;
		break;
	case 2:
		qctrl->default_value = uvideo_ctrls[i].sig ?
		    (int16_t)UGETW(ctrl_data) :
		    UGETW(ctrl_data);
		break;
	}

	/* set flags */
	qctrl->flags = 0;

out:
	free(ctrl_data, M_USBDEV, 0);

	return (ret);
}

int
uvideo_g_ctrl(void *v, struct v4l2_control *gctrl)
{
	struct uvideo_softc *sc = v;
	int i, ret = 0;
	usbd_status error;
	uint8_t *ctrl_data;
	uint16_t ctrl_len;

	i = uvideo_find_ctrl(sc, gctrl->id);
	if (i == EINVAL)
		return (i);

	ctrl_len = uvideo_ctrls[i].ctrl_len;
	if (ctrl_len < 1 || ctrl_len > 2) {
		printf("%s: invalid control length: %d\n", __func__, ctrl_len);
		return (EINVAL);
	}

	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK | M_CANFAIL);
	if (ctrl_data == NULL) {
		printf("%s: could not allocate control data\n", __func__);
		return (ENOMEM);
	}

	error = uvideo_vc_get_ctrl(sc, ctrl_data, GET_CUR,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION) {
		ret = EINVAL;
		goto out;
	}
	switch(ctrl_len) {
	case 1:
		gctrl->value = uvideo_ctrls[i].sig ?
		    *(int8_t *)ctrl_data :
		    *ctrl_data;
		break;
	case 2:
		gctrl->value = uvideo_ctrls[i].sig ?
		    (int16_t)UGETW(ctrl_data) :
		    UGETW(ctrl_data);
		break;
	}

out:
	free(ctrl_data, M_USBDEV, 0);

	return (0);
}

int
uvideo_s_ctrl(void *v, struct v4l2_control *sctrl)
{
	struct uvideo_softc *sc = v;
	int i, ret = 0;
	usbd_status error;
	uint8_t *ctrl_data;
	uint16_t ctrl_len;

	i = uvideo_find_ctrl(sc, sctrl->id);
	if (i == EINVAL)
		return (i);

	ctrl_len = uvideo_ctrls[i].ctrl_len;
	if (ctrl_len < 1 || ctrl_len > 2) {
		printf("%s: invalid control length: %d\n", __func__, ctrl_len);
		return (EINVAL);
	}

	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK | M_CANFAIL);
	if (ctrl_data == NULL) {
		printf("%s: could not allocate control data\n", __func__);
		return (ENOMEM);
	}

	switch(ctrl_len) {
	case 1:
		if (uvideo_ctrls[i].sig)
			*(int8_t *)ctrl_data = sctrl->value;
		else
			*ctrl_data = sctrl->value;
		break;
	case 2:
		USETW(ctrl_data, sctrl->value);
		break;
	}
	error = uvideo_vc_set_ctrl(sc, ctrl_data, SET_CUR,
	    sc->sc_desc_vc_pu_cur->bUnitID,
	    uvideo_ctrls[i].ctrl_selector, uvideo_ctrls[i].ctrl_len);
	if (error != USBD_NORMAL_COMPLETION)
		ret = EINVAL;

	free(ctrl_data, M_USBDEV, 0);

	return (ret);
}

int
uvideo_try_fmt(void *v, struct v4l2_format *fmt)
{
	struct uvideo_softc *sc = v;
	struct uvideo_res r;
	int found, i;

	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return (EINVAL);

	DPRINTF(1, "%s: %s: requested width=%d, height=%d\n",
	    DEVNAME(sc), __func__, fmt->fmt.pix.width, fmt->fmt.pix.height);

	/* search requested pixel format */
	for (found = 0, i = 0; i < sc->sc_fmtgrp_num; i++) {
		if (fmt->fmt.pix.pixelformat == sc->sc_fmtgrp[i].pixelformat) {
			found = 1;
			break;
		}
	}
	if (found == 0)
		return (EINVAL);

	/* search requested frame resolution */
	uvideo_find_res(sc, i, fmt->fmt.pix.width, fmt->fmt.pix.height, &r);

	/* offer closest resolution which we have found */
	fmt->fmt.pix.width = r.width;
	fmt->fmt.pix.height = r.height;

	DPRINTF(1, "%s: %s: offered width=%d, height=%d\n",
	    DEVNAME(sc), __func__, r.width, r.height);

	/* tell our frame buffer size */
	fmt->fmt.pix.sizeimage = sc->sc_frame_buffer.buf_size;

	return (0);
}

caddr_t
uvideo_mappage(void *v, off_t off, int prot)
{
	struct uvideo_softc *sc = v;
	caddr_t p;

	if (off >= sc->sc_mmap_buffer_size)
		return NULL;

	if (!sc->sc_mmap_flag)
		sc->sc_mmap_flag = 1;

	p = sc->sc_mmap_buffer + off;

	return (p);
}

int
uvideo_get_bufsize(void *v)
{
	struct uvideo_softc *sc = v;

	return (sc->sc_max_fbuf_size);
}

int
uvideo_start_read(void *v)
{
	struct uvideo_softc *sc = v;
	usbd_status error;

	if (sc->sc_mmap_flag)
		sc->sc_mmap_flag = 0;

	error = uvideo_vs_init(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);

	if (sc->sc_vs_cur->bulk_endpoint)
		uvideo_vs_start_bulk(sc);
	else
		uvideo_vs_start_isoc(sc);

	return (0);
}

usbd_status
uvideo_usb_control(struct uvideo_softc *sc, uint8_t rt, uint8_t r,
    uint16_t value, uint8_t *data, size_t length)
{
	usb_device_request_t	req;
	usbd_status		err;

	req.bmRequestType = rt;
	req.bRequest = r;
	USETW(req.wIndex, 0);
	USETW(req.wValue, value);
	USETW(req.wLength, length);

	err = usbd_do_request(sc->sc_udev, &req, data);
	if (err != USBD_NORMAL_COMPLETION)
		return (err);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_ucode_loader_ricoh(struct uvideo_softc *sc)
{
	usbd_status error;
	uint8_t *ucode, len, cbuf;
	size_t ucode_size;
	uint16_t addr;
	int offset = 0, remain;

	/* get device microcode status */
	cbuf = 0;
	error = uvideo_usb_control(sc, UT_READ_VENDOR_DEVICE,
	    0xa4, 0, &cbuf, sizeof cbuf);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: ucode status error=%s!\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	if (cbuf) {
		DPRINTF(1, "%s: microcode already loaded\n", DEVNAME(sc));
		return (USBD_NORMAL_COMPLETION);
	} else {
		DPRINTF(1, "%s: microcode not loaded\n", DEVNAME(sc));
	}

	/* open microcode file */
	error = loadfirmware(sc->sc_quirk->ucode_name, &ucode, &ucode_size);
	if (error != 0) {
		printf("%s: loadfirmware error=%d!\n", DEVNAME(sc), error);
		return (USBD_INVAL);
	}

	/* upload microcode */
	remain = ucode_size;
	while (remain > 0) {
		if (remain < 3) {
			printf("%s: ucode file incomplete!\n", DEVNAME(sc));
			free(ucode, M_DEVBUF, 0);
			return (USBD_INVAL);
		}

		len = ucode[offset];
		addr = ucode[offset + 1] | (ucode[offset + 2] << 8);
		offset += 3;
		remain -= 3;

		error = uvideo_usb_control(sc, UT_WRITE_VENDOR_DEVICE,
		    0xa0, addr, &ucode[offset], len);
		if (error != USBD_NORMAL_COMPLETION) {
			printf("%s: ucode upload error=%s!\n",
			    DEVNAME(sc), usbd_errstr(error));
			free(ucode, M_DEVBUF, 0);
			return (USBD_INVAL);
		}
		DPRINTF(1, "%s: uploaded %d bytes ucode to addr 0x%x\n",
		    DEVNAME(sc), len, addr);

		offset += len;
		remain -= len;
	}
	free(ucode, M_DEVBUF, 0);

	/* activate microcode */
	cbuf = 0;
	error = uvideo_usb_control(sc, UT_WRITE_VENDOR_DEVICE,
	    0xa1, 0, &cbuf, sizeof cbuf);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: ucode activate error=%s!\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: ucode activated\n", DEVNAME(sc));

	return (USBD_NORMAL_COMPLETION);
}

/*
 * The iSight first generation device will first attach as
 * 0x8300 non-UVC.  After the firmware gots uploaded, the device
 * will reset and come back as 0x8501 UVC compatible.
 */
usbd_status
uvideo_ucode_loader_apple_isight(struct uvideo_softc *sc)
{
	usbd_status error;
	uint8_t *ucode, *code, cbuf;
	size_t ucode_size;
	uint16_t len, req, off, llen;

	/* open microcode file */
	error = loadfirmware(sc->sc_quirk->ucode_name, &ucode, &ucode_size);
	if (error != 0) {
		printf("%s: loadfirmware error=%d!\n", DEVNAME(sc), error);
		return (USBD_INVAL);
	}

	/* send init request */
	cbuf = 1;
	error = uvideo_usb_control(sc, UT_WRITE_VENDOR_DEVICE, 0xa0, 0xe600,
	    &cbuf, sizeof(cbuf));
	if (error) {
		printf("%s: failed to init firmware loading state: %s\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (error);
	}

	code = ucode;
	while (code < ucode + ucode_size) {
		/* get header information */
		len = (code[0] << 8) | code[1];
		req = (code[2] << 8) | code[3];
		DPRINTF(1, "%s: ucode data len=%d, request=0x%x\n",
		    DEVNAME(sc), len, req);
		if (len < 1 || len > 1023) {
			printf("%s: ucode header contains wrong value!\n",
			    DEVNAME(sc));
			free(ucode, M_DEVBUF, 0);
			return (USBD_INVAL);
		}
		code += 4;

		/* send data to device */
		for (off = 0; len > 0; req += 50, off += 50) {
			llen = len > 50 ? 50 : len;
			len -= llen;

			DPRINTF(1, "%s: send %d bytes data to offset 0x%x\n",
			    DEVNAME(sc), llen, req);
			error = uvideo_usb_control(sc, UT_WRITE_VENDOR_DEVICE,
			    0xa0, req, code, llen);
			if (error) {
				printf("%s: ucode load failed: %s\n",
				    DEVNAME(sc), usbd_errstr(error));
				free(ucode, M_DEVBUF, 0);
				return (USBD_INVAL);
			}

			code += llen;
		}
	}
	free(ucode, M_DEVBUF, 0);

	/* send finished request */
	cbuf = 0;
	error = uvideo_usb_control(sc, UT_WRITE_VENDOR_DEVICE, 0xa0, 0xe600,
	    &cbuf, sizeof(cbuf));
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: ucode activate error=%s!\n",
		    DEVNAME(sc), usbd_errstr(error));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: ucode activated\n", DEVNAME(sc));

	/*
	 * We will always return from the attach routine since the device
	 * will reset and re-attach at this point.
	 */
	return (USBD_INVAL);
}
@


1.191
log
@No need for a special DVACT_DEACTIVATE hook, autoconf(9) knows how
to deactivate our children.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.190 2016/06/14 04:54:33 mglocker Exp $ */
d1838 1
a1838 1
		(void)tsleep(&sc->sc_vs_cur->bulk_running, 0, "vid_close", 0);
d1913 1
d1938 1
a1938 1
	wakeup(&sc->sc_vs_cur->bulk_running);
@


1.190
log
@Add missing line feed to DPRINTF makes debug reading easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.189 2016/06/01 12:58:59 mglocker Exp $ */
a125 1
int		uvideo_activate(struct device *, int);
d267 1
a267 5
	sizeof(struct uvideo_softc),
	uvideo_match,
	uvideo_attach,
	uvideo_detach,
	uvideo_activate,
a605 19

	return (rv);
}

int
uvideo_activate(struct device *self, int act)
{
	struct uvideo_softc *sc = (struct uvideo_softc *) self;
	int rv = 0;

	DPRINTF(1, "uvideo_activate: sc=%p\n", sc);

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_videodev != NULL)
			config_deactivate(sc->sc_videodev);
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.189
log
@Correctly set the V4L2_BUF_FLAG_QUEUED and V4L2_BUF_FLAG_DONE buffer flags.
With this we can get rid of the sc_mmap_cur variable to query the buffer
queue for a free slot.
Remove resetting of the V4L2_BUF_FLAG_MAPPED buffer flag while here.  It's
enough when it gets set initially by uvideo_reqbufs().

Initial diff from Patrick Keshishian, thanks!

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.188 2016/05/28 06:26:49 mglocker Exp $ */
d1826 1
a1826 1
	DPRINTF(1, "%s: open pipe for bEndpointAddress=0x%02x",
@


1.188
log
@Do the endpoint verification before opening the pipe on the selected
alternate interface endpoint instead statically on interface 0.
Fix duplicate DPRINTF output while there.

Initial diff from Patrick Keshishian, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.187 2016/05/26 04:47:08 mglocker Exp $ */
a80 1
	int					 sc_mmap_cur;
a591 1
	sc->sc_mmap_cur = -1;
a1693 1
	sc->sc_mmap_cur = -1;
d2206 3
a2208 2
	if (sc->sc_mmap_cur < 0 || sc->sc_mmap_count == 0 ||
	    sc->sc_mmap_buffer == NULL)
d2212 2
a2213 3
	while (sc->sc_mmap_cur < sc->sc_mmap_count) {
		if (sc->sc_mmap[sc->sc_mmap_cur].v4l2_buf.flags &
		    V4L2_BUF_FLAG_QUEUED)
a2214 2
		/* not ready for queueing, try next */
		sc->sc_mmap_cur++;
d2216 1
a2216 1
	if (sc->sc_mmap_cur == sc->sc_mmap_count) {
d2223 2
a2224 2
	bcopy(buf, sc->sc_mmap[sc->sc_mmap_cur].buf, len);
	sc->sc_mmap[sc->sc_mmap_cur].v4l2_buf.bytesused = len;
d2227 1
a2227 1
	getmicrotime(&sc->sc_mmap[sc->sc_mmap_cur].v4l2_buf.timestamp);
d2230 3
a2232 2
	SIMPLEQ_INSERT_TAIL(&sc->sc_mmap_q, &sc->sc_mmap[sc->sc_mmap_cur],
	    q_frames);
d2234 1
a2234 7
	    DEVNAME(sc), __func__, sc->sc_mmap_cur);

	/* point to next mmap buffer */
	sc->sc_mmap_cur++;
	if (sc->sc_mmap_cur == sc->sc_mmap_count)
		/* we reached the end of the mmap buffer, start over */
		sc->sc_mmap_cur = 0;
a3202 3
	/* start with the first buffer */
	sc->sc_mmap_cur = 0;

a3238 1
	sc->sc_mmap[qb->index].v4l2_buf.flags |= V4L2_BUF_FLAG_MAPPED;
d3271 2
a3272 1
	mmap->v4l2_buf.flags |= V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_DONE;
@


1.187
log
@Remove superfluous loop counter to set alternate video interface since we
store the alternate video interface number already.

From Patrick Keshishian, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.186 2016/05/20 19:25:53 mglocker Exp $ */
d1820 3
a1822 1
	ed = usbd_interface2endpoint_descriptor(sc->sc_vs_cur->ifaceh, 0);
a1827 6
	DPRINTF(1, "%s: open pipe for ", DEVNAME(sc));
	DPRINTF(1, "bEndpointAddress=0x%02x (0x%02x), wMaxPacketSize=%d (%d)\n",
	    ed->bEndpointAddress,
	    sc->sc_vs_cur->endpoint,
	    UGETW(ed->wMaxPacketSize),
	    sc->sc_vs_cur->psize);
d1829 2
@


1.186
log
@Fix pasto; v4l2_buf.flags = V4L2_MEMORY_MMAP -> V4L2_BUF_FLAG_MAPPED.

From Patrick Keshishian, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.185 2016/05/17 08:27:17 kettenis Exp $ */
d1226 1
a1226 1
	int i, diff, best_diff = INT_MAX;
a1229 1
	i = 0;
a1246 1
		i++;
d1272 1
a1272 1
	error = usbd_set_interface(ifaceh, i);
d1275 1
a1275 1
		    DEVNAME(sc), i);
@


1.185
log
@Plug some gaping holes in the v4l2 ioctl interfaces that would leak kernel
memory to a local user.  Found by Patrick Keshisian.  Fix a potential
integer overflow issue in related code while I'm there.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.184 2016/03/19 12:04:15 natano Exp $ */
d3205 1
a3205 1
		sc->sc_mmap[i].v4l2_buf.flags = V4L2_MEMORY_MMAP;
@


1.184
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.183 2015/12/20 10:08:05 mpi Exp $ */
d34 1
d78 1
d1690 1
a1690 1
		free(sc->sc_mmap_buffer, M_DEVBUF, 0);
d1692 1
d3177 5
d3187 1
d3190 1
d3229 2
a3230 1
	    qb->memory != V4L2_MEMORY_MMAP)
d3250 5
d3272 4
d3592 3
@


1.183
log
@Do not delay video(4) attachment if the device does not need to load
a firmware.

Regression spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.182 2015/12/11 16:07:02 mpi Exp $ */
d2778 1
a2778 1
	VOP_UNLOCK(sc->sc_vp, 0, p);
@


1.183.2.1
log
@Plug some gaping holes in the v4l2 ioctl interfaces that would leak kernel
memory to a local user.  Found by Patrick Keshisian.  Fix a potential
integer overflow issue in related code while I'm there.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.183 2015/12/20 10:08:05 mpi Exp $ */
a33 1
#include <sys/stdint.h>
a76 1
	size_t					 sc_mmap_buffer_size;
d1688 1
a1688 1
		free(sc->sc_mmap_buffer, M_DEVBUF, sc->sc_mmap_buffer_size);
a1689 1
		sc->sc_mmap_buffer_size = 0;
a3173 5
	if (buf_size >= SIZE_MAX / UVIDEO_MAX_BUFFERS) {
		printf("%s: video frame size too large!\n", DEVNAME(sc));
		sc->sc_mmap_count = 0;
		return (EINVAL);
	}
a3178 1
		sc->sc_mmap_count = 0;
a3180 1
	sc->sc_mmap_buffer_size = buf_size_total;
d3219 1
a3219 2
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
a3238 5
	if (qb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
		return (EINVAL);

a3255 4
	if (dqb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    dqb->memory != V4L2_MEMORY_MMAP)
		return (EINVAL);

a3571 3

	if (off >= sc->sc_mmap_buffer_size)
		return NULL;
@


1.182
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.181 2015/07/09 14:58:32 mpi Exp $ */
d529 4
a532 1
	config_mountroot(self, uvideo_attach_hook);
@


1.181
log
@Move the softc definition to uvideo.c so that userland can include
<dev/usb/uvideo.h> to get USB video descriptor definitions.

from Ludovic Coues.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.180 2015/06/24 20:17:28 miod Exp $ */
d123 1
a123 1
void		uvideo_attach_hook(void *);
d529 1
a529 5
	/* if the device needs ucode do mountroothook */
	if ((sc->sc_quirk && sc->sc_quirk->ucode_name) && rootvp == NULL)
		mountroothook_establish(uvideo_attach_hook, sc);
	else
		uvideo_attach_hook(sc);
d533 1
a533 1
uvideo_attach_hook(void *arg)
d535 1
a535 1
	struct uvideo_softc *sc = arg;
@


1.181.4.1
log
@Plug some gaping holes in the v4l2 ioctl interfaces that would leak kernel
memory to a local user.  Found by Patrick Keshisian.  Fix a potential
integer overflow issue in related code while I'm there.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.181 2015/07/09 14:58:32 mpi Exp $ */
a33 1
#include <sys/stdint.h>
a76 1
	size_t					 sc_mmap_buffer_size;
d1689 1
a1689 1
		free(sc->sc_mmap_buffer, M_DEVBUF, sc->sc_mmap_buffer_size);
a1690 1
		sc->sc_mmap_buffer_size = 0;
a3174 5
	if (buf_size >= SIZE_MAX / UVIDEO_MAX_BUFFERS) {
		printf("%s: video frame size too large!\n", DEVNAME(sc));
		sc->sc_mmap_count = 0;
		return (EINVAL);
	}
a3179 1
		sc->sc_mmap_count = 0;
a3181 1
	sc->sc_mmap_buffer_size = buf_size_total;
d3220 1
a3220 2
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
a3239 5
	if (qb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    qb->memory != V4L2_MEMORY_MMAP ||
	    qb->index >= sc->sc_mmap_count)
		return (EINVAL);

a3256 4
	if (dqb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    dqb->memory != V4L2_MEMORY_MMAP)
		return (EINVAL);

a3572 3

	if (off >= sc->sc_mmap_buffer_size)
		return NULL;
@


1.180
log
@Allow uvideo_mmap_queue() to fail gracefully when the mmap queue is full;
found the hard way by sebastia@@ four years ago, and I'd been sitting on that
diff since.

The initial diff was more aggressive and would free the mmap queue upon error,
but jakemsr@@ had objections against this behaviour; this diff only fails
gracefully instead of panic'ing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.179 2015/01/06 17:27:58 armani Exp $ */
d59 56
@


1.179
log
@We do not support freeing memory using reqbufs with a zero size so
return EINVAL in this case.

Also change an easily triggerable panic by a printf and return EINVAL.

Reminded by brad@@, one typo spotted by sthen@@ and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.178 2014/11/18 23:55:01 krw Exp $ */
d125 1
a125 1
void		uvideo_mmap_queue(struct uvideo_softc *, uint8_t *, int);
d2079 2
a2080 1
				uvideo_mmap_queue(sc, fb->buf, fb->offset);
d2133 2
a2134 1
			uvideo_mmap_queue(sc, fb->buf, fb->offset);
d2152 1
a2152 1
void
d2167 5
a2171 2
	if (sc->sc_mmap_cur == sc->sc_mmap_count)
		panic("uvideo_mmap_queue: mmap queue is full!");
d2199 2
d3106 2
a3107 1
		printf("%s: mmap buffers already allocated\n", __func__);
@


1.178
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.177 2014/10/23 07:34:48 brad Exp $ */
d3094 8
a3101 2
	if (sc->sc_mmap_count > 0 || sc->sc_mmap_buffer != NULL)
		panic("%s: mmap buffers already allocated", __func__);
@


1.177
log
@Now that gcc2 is gone revert the removal of anonymous unions, means not having to
modify various third party apps using the V4L2 API to build on OpenBSD specifically.

"I think this is the right thing to do" miod@@
"Fine with me." sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.176 2014/10/18 08:01:34 armani Exp $ */
a30 1
#include <sys/device.h>
@


1.176
log
@Add VIDIOC_G_INPUT ioctl, some ports need it (at least ffmpeg)

ok ratchov@@, sthen@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.175 2014/07/12 18:48:53 tedu Exp $ */
d2850 1
a2850 1
	fsizes->un.discrete.width =
d2852 1
a2852 1
	fsizes->un.discrete.height =
d2894 2
a2895 2
		fivals->un.stepwise.min.numerator = UGETDW(p);
		fivals->un.stepwise.min.denominator = 10000000;
d2897 2
a2898 2
		fivals->un.stepwise.max.numerator = UGETDW(p);
		fivals->un.stepwise.max.denominator = 10000000;
d2900 2
a2901 2
		fivals->un.stepwise.step.numerator = UGETDW(p);
		fivals->un.stepwise.step.denominator = 10000000;
d2912 2
a2913 2
		fivals->un.discrete.numerator = UGETDW(p);
		fivals->un.discrete.denominator = 10000000;
@


1.175
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.174 2014/01/22 03:21:23 jsg Exp $ */
d182 1
d232 1
d3074 9
@


1.174
log
@add a missing argument to a printf
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.173 2013/11/07 11:14:26 pirofti Exp $ */
d1627 1
a1627 1
		free(fb->buf, M_DEVBUF);
d1632 1
a1632 1
		free(sc->sc_mmap_buffer, M_DEVBUF);
d3346 1
a3346 1
	free(ctrl_data, M_USBDEV);
d3397 1
a3397 1
	free(ctrl_data, M_USBDEV);
d3444 1
a3444 1
	free(ctrl_data, M_USBDEV);
d3588 1
a3588 1
			free(ucode, M_DEVBUF);
d3602 1
a3602 1
			free(ucode, M_DEVBUF);
d3611 1
a3611 1
	free(ucode, M_DEVBUF);
d3667 1
a3667 1
			free(ucode, M_DEVBUF);
d3684 1
a3684 1
				free(ucode, M_DEVBUF);
d3691 1
a3691 1
	free(ucode, M_DEVBUF);
@


1.173
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Tested and okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.172 2013/04/26 14:53:19 mpi Exp $ */
d2736 1
a2736 1
		printf("%s: %s: no file open!\n", DEVNAME(sc));
@


1.172
log
@Don't use usbd_bulk_transfer() to submit a synchronous transfer here too.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.171 2013/04/26 13:46:40 mglocker Exp $ */
d339 1
a339 1
	if (sc->sc_dying)
d373 1
a373 1
	if (sc->sc_dying)
d571 1
a571 1
		sc->sc_dying = 1;
d1932 1
a1932 1
	if (sc->sc_dying)
@


1.171
log
@Rename three functions in usbdi.c to their right prefix (usb_* to usbd_*).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.170 2013/04/15 09:23:02 mglocker Exp $ */
d1888 1
a1888 1
		error = usbd_bulk_transfer(
d1891 1
a1891 2
		    USBD_NO_COPY | USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT,
d1893 5
a1897 2
		    &size,
		    "vid_bulk");
@


1.170
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.169 2013/03/28 03:58:03 tedu Exp $ */
d590 2
a591 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d594 1
a594 1
			desc = usb_desc_iter_next(&iter);
d623 1
a623 1
		desc = usb_desc_iter_next(&iter);
d786 2
a787 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d790 1
a790 1
			desc = usb_desc_iter_next(&iter);
d806 1
a806 1
		desc = usb_desc_iter_next(&iter);
d876 2
a877 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d880 1
a880 1
			desc = usb_desc_iter_next(&iter);
d899 1
a899 1
		desc = usb_desc_iter_next(&iter);
d1015 2
a1016 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d1026 1
a1026 1
		desc = usb_desc_iter_next(&iter);
d1102 2
a1103 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d1119 1
a1119 1
		while ((desc = usb_desc_iter_next(&iter))) {
d1147 1
a1147 1
		desc = usb_desc_iter_next(&iter);
d1173 2
a1174 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d1186 1
a1186 1
		desc = usb_desc_iter_next(&iter);
d1208 1
a1208 1
		desc = usb_desc_iter_next(&iter);
d2212 2
a2213 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
d2360 1
a2360 1
		desc = usb_desc_iter_next(&iter);
@


1.169
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.168 2013/03/28 03:31:56 tedu Exp $ */
d97 2
a98 2
usbd_status	uvideo_vs_set_alt(struct uvideo_softc *, usbd_interface_handle,
		    int);
d120 1
a120 1
void		uvideo_vs_cb(usbd_xfer_handle, usbd_private_handle,
d581 1
a581 1
	usbd_desc_iter_t iter;
d775 1
a775 1
	usbd_desc_iter_t iter;
d871 1
a871 1
	usbd_desc_iter_t iter;
d1009 1
a1009 1
	usbd_desc_iter_t iter;
d1094 1
a1094 1
	usbd_desc_iter_t iter;
d1161 1
a1161 1
uvideo_vs_set_alt(struct uvideo_softc *sc, usbd_interface_handle ifaceh,
d1164 1
a1164 1
	usbd_desc_iter_t iter;
d1953 1
a1953 1
uvideo_vs_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d2209 1
a2209 1
	usbd_desc_iter_t iter;
@


1.168
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.167 2012/06/18 15:43:30 mpi Exp $ */
a28 1
#include <sys/proc.h>
@


1.167
log
@Do not try to get the description of an unexisting video format,
from Gregor Best.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.166 2011/10/28 12:48:31 mglocker Exp $ */
a27 1
#include <sys/reboot.h>
a29 2
#include <sys/namei.h>
#include <sys/vnode.h>
d36 2
a37 1
#include <uvm/uvm.h>
d133 3
@


1.166
log
@Fix bogus frame selection check in uvideo_vs_negotiation().

From Pedro Martelletto
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.165 2011/09/18 23:24:12 krw Exp $ */
d2778 1
a2778 1
	if (fmtdesc->index == sc->sc_fmtgrp_num) 
@


1.165
log
@usbdivar.h needs struct timeout. But don't get it indirectly via
sys/kthread.h,  use sys/timeout.h explicitly. Noted by Michael
Knudsen.

ok deraadt@@ kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.164 2011/07/03 15:47:17 matthew Exp $ */
d1417 5
a1421 5
			if (i == fmtgrp->frame_num) {
				DPRINTF(1, "%s: %s: invalid frame index 0x%x\n",
				    DEVNAME(sc), __func__, pc->bFrameIndex);
				return (USBD_INVAL);
			}
@


1.164
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.163 2011/06/23 22:03:43 oga Exp $ */
d37 1
@


1.163
log
@Don't leak the ctrl_data in uvideo_queryctrl, uvideo_s_ctrl and uvideo_g_ctrl.

If one of the usb calls we did here failed we'd return immediately and
not free our buffer.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.162 2011/06/17 07:06:47 mk Exp $ */
a566 2
	case DVACT_ACTIVATE:
		break;
@


1.162
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.161 2011/04/11 02:04:48 jakemsr Exp $ */
d3230 1
a3230 1
	int i;
d3261 4
a3264 2
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);
d3282 4
a3285 2
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);
d3303 4
a3306 2
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);
d3324 4
a3327 2
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);
d3344 1
d3347 1
a3347 1
	return (0);
d3354 1
a3354 1
	int i;
d3378 4
a3381 2
	if (error != USBD_NORMAL_COMPLETION)
		return (EINVAL);
d3395 1
d3405 1
a3405 1
	int i;
d3441 1
a3441 1
		return (EINVAL);
d3445 1
a3445 1
	return (0);
@


1.161
log
@uncompressed video formats have a fixed per-pixel bit depth, which
means the data size of a frame can be calculated if the dimensions
are known.

* calculate frame data sizes for uncompressed formats instead of believing
what the hardware says.  the UVC spec changed between 1.0 and 1.1, and
as a result, some devices return bogus information.
* skip under-sized as well as over-sized uncompressed frames; there is
only one correct size for uncompressed frames.
* remove quirk to fix uncompressed frame sizes on certain devices,
since that now always happens.
* check that the device is actually using the parameters we think it's
using.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.160 2011/04/04 17:38:24 jakemsr Exp $ */
d3245 1
a3245 1
	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK);
d3360 1
a3360 1
	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK);
d3408 1
a3408 1
	ctrl_data = malloc(ctrl_len, M_USBDEV, M_WAITOK);
@


1.160
log
@the v4l2 spec says that setting time per frame to zero should reset time
per frame to the default, so do that instead of returning EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.159 2011/03/31 22:13:12 jakemsr Exp $ */
a251 1
#define UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE	0x8
a326 21
	{
	    /* Needs to fix dwMaxVideoFrameSize */
	    { USB_VENDOR_CHENSOURCE, USB_PRODUCT_CHENSOURCE_CM12402 },
	    NULL,
	    NULL,
	    UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE
	},
	{
	    /* Needs to fix dwMaxVideoFrameSize */
	    { USB_VENDOR_MICRODIA, USB_PRODUCT_MICRODIA_CAM_1 },
	    NULL,
	    NULL,
	    UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE
	},
	{
	    /* Needs to fix dwMaxVideoFrameSize */
	    { USB_VENDOR_MICROSOFT, USB_PRODUCT_MICROSOFT_LIFECAM },
	    NULL,
	    NULL,
	    UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE
	},
d1058 6
a1063 2
	 * On some broken device, dwMaxVideoFrameBufferSize is not correct.
	 * So fix it by frame width/height (XXX YUV2 format only).
d1065 7
a1071 6
	if (sc->sc_quirk &&
	    sc->sc_quirk->flags & UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE &&
	    sc->sc_fmtgrp[fmtidx].pixelformat == V4L2_PIX_FMT_YUYV) {
		fbuf_size = UGETW(fd->wWidth) * UGETW(fd->wHeight) * 4;
		DPRINTF(1, "wWidth = %d, wHeight = %d\n",
			UGETW(fd->wWidth), UGETW(fd->wHeight));
d1301 2
d1307 1
a1307 1
	int i, ival_bytes;
d1389 68
d1459 4
a1525 1
	struct usb_video_header_desc *hd;
a1544 27
	/*
	 * Some UVC 1.00 devices return dwMaxVideoFrameSize = 0.
	 * If so, fix it by format/frame descriptors.
	 */
	hd = sc->sc_desc_vc_header.fix;
	if (UGETDW(pc->dwMaxVideoFrameSize) == 0 &&
	    UGETW(hd->bcdUVC) < 0x0110 ) {
		DPRINTF(1, "%s: dwMaxVideoFrameSize == 0, fixed\n",
		    DEVNAME(sc));
		USETDW(pc->dwMaxVideoFrameSize, 
		    UGETDW(sc->sc_fmtgrp_cur->frame_cur
			->dwMaxVideoFrameBufferSize));

		/*
		 * On some broken device, the above value is not correct.
		 * So fix it by frame width/height (XXX YUV2 format only).
		 */
		if (sc->sc_quirk &&
		    sc->sc_quirk->flags &
			 UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE &&
		    sc->sc_fmtgrp_cur->pixelformat == V4L2_PIX_FMT_YUYV) {
			USETDW(pc->dwMaxVideoFrameSize, 
		    	    UGETW(sc->sc_fmtgrp_cur->frame_cur->wWidth) *
			    UGETW(sc->sc_fmtgrp_cur->frame_cur->wHeight) * 4);
		}
	}

d1616 2
d2062 8
a2069 1
		if (fb->offset <= fb->buf_size) {
a2081 3
		} else {
			DPRINTF(1, "%s: %s: frame too large, skipped!\n",
			    DEVNAME(sc), __func__);
@


1.159
log
@just report the frame interval in the same terms the device gives us.
previously, this was returning the wrong value (frame rate instead
of time per frame, d'oh!).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.158 2011/03/26 19:50:52 jakemsr Exp $ */
a2974 4
		if (parm->parm.capture.timeperframe.numerator == 0 ||
		    parm->parm.capture.timeperframe.denominator == 0)
			return (EINVAL);

d2979 8
a2986 3
		sc->sc_frame_rate =
		    parm->parm.capture.timeperframe.denominator /
		    parm->parm.capture.timeperframe.numerator;
@


1.158
log
@oops.  the frame rate is the inverse of the frame interval.  fixes
setting the frame rate with luvcview.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.157 2011/03/26 08:24:52 jakemsr Exp $ */
a3002 1
	int ns;
a3003 1
	ns = UGETDW(sc->sc_desc_probe.dwFrameInterval);
d3008 2
a3009 2
		    (ns == 0) ? 0 : 10000000 / ns;
		parm->parm.capture.timeperframe.denominator = 1;
@


1.157
log
@use 'sizeof(struct usb_video_frame_desc)' instead of a hardcoded
number
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.156 2011/03/26 08:21:27 jakemsr Exp $ */
d2979 4
a2982 1
		/* only whole number frame rates for now */
d2984 2
a2985 2
		    parm->parm.capture.timeperframe.numerator /
		    parm->parm.capture.timeperframe.denominator;
@


1.156
log
@fill in the timestamp when copying a frame into the mmap buffer
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.155 2011/03/26 08:15:07 jakemsr Exp $ */
d637 2
a638 1
			if (desc->bLength < 25) {
@


1.155
log
@fill in support for VIDIOC_ENUM_FRAMEINTERVALS
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.154 2011/03/26 08:13:05 jakemsr Exp $ */
d2133 3
@


1.154
log
@support VIDIOC_S_PARM and VIDIOC_G_PARM.  these ioctls are used for
setting and and getting the frame interval.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.153 2011/03/26 07:57:42 jakemsr Exp $ */
d2820 4
a2823 1
	int idx, found = 0;
d2827 11
a2837 1
			found = 1;
d2841 1
a2841 1
	if (found == 0)
d2844 3
a2846 1
	/* TODO */
d2848 27
a2874 1
	return (EINVAL);
@


1.153
log
@print the supported frame intervals when printing the frame descriptor
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.152 2011/03/25 23:19:41 jakemsr Exp $ */
d177 2
d226 2
d1316 2
d1319 1
d1321 1
d1325 2
d1328 1
a1328 1
	if (sc->sc_fmtgrp_cur->frame_num == 0) {
d1336 1
d1338 2
a1339 2
	pc->bFormatIndex = sc->sc_fmtgrp_cur->format->bFormatIndex;
	pc->bFrameIndex = sc->sc_fmtgrp_cur->frame_cur->bFrameIndex;
d1341 52
a1392 2
	USETDW(pc->dwFrameInterval,
	    UGETDW(sc->sc_fmtgrp_cur->frame_cur->dwDefaultFrameInterval));
d2919 47
@


1.152
log
@* don't try to align our array of frame descriptors with the
  frame descriptor's bFrameIndex field.  the first valid frame
  in the array is at index 0, not 1.
* don't change the format group's default frame when configuring
  the device, and don't use the default frame as the current
  frame: these are what the format group's 'frame_cur' is for.

tested by several as part of larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.151 2011/03/25 21:23:54 jakemsr Exp $ */
d2467 2
d2486 30
@


1.151
log
@* the mjpeg and uncompressed video frame descriptor structures are
  equivilent.  only define one structure, struct usb_video_frame_desc,
  and handle both types of frame descriptors in the same code.
* replace hardcoded numbers with 'sizeof(struct usb_video_frame_desc)'
  where the numbers represent the size of a frame descriptor

tested by several
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.150 2011/03/25 20:05:20 jakemsr Exp $ */
d1060 1
a1060 2

	frame_num = sc->sc_fmtgrp[fmtidx].frame_num + 1;
a1067 2
	sc->sc_fmtgrp[fmtidx].frame_num = frame_num;

d1071 1
a1071 1
	    sc->sc_fmtgrp[fmtidx].format_dfidx == frame_num) {
a1072 6
	}

	if (sc->sc_fmtgrp[fmtidx].frame_num ==
	    sc->sc_fmtgrp[fmtidx].format->bNumFrameDescriptors) {
		sc->sc_fmtgrp_idx++;
	}
d1091 9
d1287 1
a1287 1
	for (i = 1; i <= sc->sc_fmtgrp[idx].frame_num; i++) {
d1295 1
a1295 1
		if (i == 1)
d1301 1
a1301 1
			r->fidx = sc->sc_fmtgrp[idx].frame[i]->bFrameIndex;
d1328 1
a1328 1
	pc->bFrameIndex = sc->sc_fmtgrp_cur->format_dfidx;
d2700 1
a2700 1
	int i, idx, found = 0;
d2711 1
a2711 3
	i = fsizes->index + 1;
	if (i > sc->sc_fmtgrp[idx].frame_num)
		/* no more frames left */
d2716 1
a2716 1
	    UGETW(sc->sc_fmtgrp[idx].frame[i]->wWidth);
d2718 1
a2718 1
	    UGETW(sc->sc_fmtgrp[idx].frame[i]->wHeight);
d2788 1
a2788 1
	sc->sc_fmtgrp[i].format_dfidx = r.fidx;
@


1.150
log
@* empty the queue of frames in the mmap frame buffer and set the
  index of the current frame to -1 when the mmap frame buffer is free'd
* set the index of the current frame to 0 when allocating the mmap
  frame buffer
* paranoia: panic if a) the mmap frame buffer is already allocated when
  we try to allocate it, or b) the mmap frame buffer is not allocated when
  we try to add frames to it

tested by several
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.149 2011/01/25 20:03:36 jakemsr Exp $ */
d96 1
a96 3
usbd_status	uvideo_vs_parse_desc_frame_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);
usbd_status	uvideo_vs_parse_desc_frame_uncompressed(struct uvideo_softc *,
a152 2
void		uvideo_dump_desc_frame_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);
d157 1
a157 1
void		uvideo_dump_desc_frame_uncompressed(struct uvideo_softc *,
d1036 5
a1040 8
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usb_desc_iter_next(&iter);
			continue;
		}

		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_VS_FRAME_MJPEG:
			error = uvideo_vs_parse_desc_frame_mjpeg(sc, desc);
a1042 10
			break;
		case UDESCSUB_VS_FRAME_UNCOMPRESSED:
			/* XXX do correct length calculation */
			if (desc->bLength > 25) {
				error =uvideo_vs_parse_desc_frame_uncompressed(
				    sc, desc);
				if (error != USBD_NORMAL_COMPLETION)
					return (error);
			}
			break;
a1043 1

d1051 1
a1051 1
uvideo_vs_parse_desc_frame_mjpeg(struct uvideo_softc *sc,
d1054 2
a1055 38
	struct usb_video_frame_mjpeg_desc *d;
	int fmtidx;

	d = (struct usb_video_frame_mjpeg_desc *)(uint8_t *)desc;

	if (d->bFrameIndex == UVIDEO_MAX_FRAME) {
		printf("%s: too many MJPEG frame descriptors found!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

	fmtidx = sc->sc_fmtgrp_idx;
	sc->sc_fmtgrp[fmtidx].frame[d->bFrameIndex] = d;

	if (sc->sc_fmtgrp[fmtidx].format_dfidx == d->bFrameIndex) {
		sc->sc_fmtgrp[fmtidx].frame_cur =
		    sc->sc_fmtgrp[fmtidx].frame[d->bFrameIndex];
	}

	sc->sc_fmtgrp[fmtidx].frame_num++;

	if (sc->sc_fmtgrp[fmtidx].frame_num ==
	    sc->sc_fmtgrp[fmtidx].format->bNumFrameDescriptors)
		sc->sc_fmtgrp_idx++;

	/* store max value */
	if (UGETDW(d->dwMaxVideoFrameBufferSize) > sc->sc_max_fbuf_size)
		sc->sc_max_fbuf_size = UGETDW(d->dwMaxVideoFrameBufferSize);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_parse_desc_frame_uncompressed(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_frame_uncompressed_desc *fd = 
	    (struct usb_video_frame_uncompressed_desc *)(uint8_t *)desc;
d1063 4
a1066 2
		printf("%s: too many UNCOMPRESSED frame descriptors found!\n",
		    DEVNAME(sc));
d1071 1
a1071 2
	sc->sc_fmtgrp[fmtidx].frame[frame_num] =
	    (struct usb_video_frame_mjpeg_desc *)fd;
d1075 1
a1075 2
		sc->sc_fmtgrp[fmtidx].frame_cur =
		    sc->sc_fmtgrp[fmtidx].frame[frame_num];
d2172 2
a2173 2
				/* XXX do correct length calculation */
				if (desc->bLength > 25) {
d2176 1
a2176 2
					uvideo_dump_desc_frame_uncompressed(
					    sc, desc);
d2202 2
a2203 1
				if (desc->bLength > 26) {
d2205 1
a2205 1
					uvideo_dump_desc_frame_mjpeg(sc, desc);
a2441 25

void
uvideo_dump_desc_frame_mjpeg(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
{
	struct usb_video_frame_mjpeg_desc *d;

	d = (struct usb_video_frame_mjpeg_desc *)(uint8_t *)desc;

	printf("bLength=%d\n", d->bLength);
	printf("bDescriptorType=0x%02x\n", d->bDescriptorType);
	printf("bDescriptorSubtype=0x%02x\n", d->bDescriptorSubtype);
	printf("bFrameIndex=0x%02x\n", d->bFrameIndex);
	printf("bmCapabilities=0x%02x\n", d->bmCapabilities);
	printf("wWidth=%d\n", UGETW(d->wWidth));
	printf("wHeight=%d\n", UGETW(d->wHeight));
	printf("dwMinBitRate=%d\n", UGETDW(d->dwMinBitRate));
	printf("dwMaxBitRate=%d\n", UGETDW(d->dwMaxBitRate));
	printf("dwMaxVideoFrameBufferSize=%d\n",
	    UGETDW(d->dwMaxVideoFrameBufferSize));
	printf("dwDefaultFrameInterval=%d\n",
	    UGETDW(d->dwDefaultFrameInterval));
	printf("bFrameIntervalType=0x%02x\n", d->bFrameIntervalType);
}

d2464 1
a2464 2
uvideo_dump_desc_frame_uncompressed(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
d2466 1
a2466 1
	struct usb_video_frame_uncompressed_desc *d;
d2468 1
a2468 1
	d = (struct usb_video_frame_uncompressed_desc *)(uint8_t *)desc;
d2750 1
a2750 1
	struct usb_video_frame_mjpeg_desc *frame_save;
@


1.149
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.148 2011/01/16 22:35:29 jakemsr Exp $ */
d556 1
a556 1
	sc->sc_mmap_cur = 0;
d1597 6
d2108 4
d2943 3
d2986 3
@


1.148
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.147 2010/11/24 19:53:07 jakemsr Exp $ */
a558 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);

a575 2

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.147
log
@- use *un*signed byte array for control data
- use UGETW/USETW instead of letoh16/htole16

fixes controls that use two-byte signed data (e.g. brighness and hue)
on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.146 2010/10/23 15:42:10 jakemsr Exp $ */
d471 2
d476 13
a488 4
	sc->sc_ifaces = malloc(uaa->nifaces * sizeof(usbd_interface_handle),
	    M_USB, M_WAITOK);
	bcopy(uaa->ifaces, sc->sc_ifaces,
	    uaa->nifaces * sizeof(usbd_interface_handle));
a570 2
	free(sc->sc_ifaces, M_USB);

d849 1
a849 1
		id = usbd_get_interface_descriptor(sc->sc_ifaces[iface]);
d855 1
d1210 1
a1210 1
			vs->ifaceh = sc->sc_ifaces[iface];
@


1.146
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.145 2010/10/18 23:25:31 jakemsr Exp $ */
d3109 2
a3110 2
		    letoh16(*(int16_t *)ctrl_data) :
		    letoh16(*(uint16_t *)ctrl_data);
d3128 2
a3129 2
		    letoh16(*(int16_t *)ctrl_data) :
		    letoh16(*(uint16_t *)ctrl_data);
d3147 2
a3148 2
		    letoh16(*(int16_t *)ctrl_data) :
		    letoh16(*(uint16_t *)ctrl_data);
d3166 2
a3167 2
		    letoh16(*(int16_t *)ctrl_data) :
		    letoh16(*(uint16_t *)ctrl_data);
d3185 1
a3185 1
	int8_t *ctrl_data;
d3217 2
a3218 2
		    letoh16(*(int16_t *)ctrl_data) :
		    letoh16(*(uint16_t *)ctrl_data);
d3233 1
a3233 1
	int8_t *ctrl_data;
d3260 1
a3260 4
		if (uvideo_ctrls[i].sig)
			*(int16_t *)ctrl_data = htole16(sctrl->value);
		else
			*(uint16_t *)ctrl_data = htole16(sctrl->value);
@


1.145
log
@bFrameIntervalType affects frame rates, not frame sizes
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.144 2010/10/18 23:20:15 jakemsr Exp $ */
d1805 2
a1806 1
	usb_init_task(&sc->sc_task_write, uvideo_debug_file_write_frame, sc);
@


1.144
log
@when configuring the streaming interface with the video probe and
commit controls, use the hardware frame idenfitier instead of the
software identifier since they can differ, and the hardware only
knows about it's own identifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.143 2010/10/18 23:12:40 jakemsr Exp $ */
d2779 5
a2783 14
	if (sc->sc_fmtgrp[idx].frame[i]->bFrameIntervalType == 0) {
		/* TODO */
		fsizes->type = V4L2_FRMSIZE_TYPE_CONTINUOUS;
		fsizes->un.stepwise.min_width = 0;
		fsizes->un.stepwise.min_height = 0;
		fsizes->un.stepwise.max_width = 0;
		fsizes->un.stepwise.max_height = 0;
	} else {
		fsizes->type = V4L2_FRMSIZE_TYPE_DISCRETE;
		fsizes->un.discrete.width =
		    UGETW(sc->sc_fmtgrp[idx].frame[i]->wWidth);
		fsizes->un.discrete.height =
		    UGETW(sc->sc_fmtgrp[idx].frame[i]->wHeight);
	}
@


1.143
log
@use setting with closest matching bandwidth for the current configuration
instead of the first one that has enough bandwidth as it may be too much
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.142 2010/10/09 09:48:03 jakemsr Exp $ */
d1349 1
a1349 1
			r->fidx = i;
@


1.142
log
@* define structure that represents USB descriptor with variable sized
  member the way uaudio does, make the variable sized member as large
  as it can be and don't define the following members.
* reenable control support for devices where bControlSize != 2 in
  the processing unit descriptor.

tested on alpha, amd64, i386, sparc64 and zaurus, as well as the machine
where previous support for variable bControlSize caused a hang.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.141 2010/10/09 08:41:28 jakemsr Exp $ */
d1229 1
a1229 1
	int i;
d1256 6
a1261 1
		if (psize >= max_packet_size) {
d1265 2
a1266 4
			DPRINTF(1, "%s: set alternate iface to ", DEVNAME(sc));
			DPRINTF(1, "bAlternateSetting=0x%02x\n",
			    id->bAlternateSetting);
			break;
d1271 4
@


1.141
log
@control values can be 1 or 2 bytes, signed or unsigned.  fixes hue
control.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.140 2010/10/08 21:41:44 jakemsr Exp $ */
d677 2
a678 1
	d = (struct usb_video_vc_processing_desc *)(uint8_t *)desc;
a684 7
	/* XXX support variable bmControls fields */
	if (d->bControlSize != 2) {
		printf("%s: video control not supported for this device.\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

d2570 2
a2571 1
	d = (struct usb_video_vc_processing_desc *)(uint8_t *)desc;
d2582 2
a2583 2
	printf("iProcessing=0x%02x\n", d->iProcessing);
	printf("bmVideoStandards=0x%02x\n", d->bmVideoStandards);
@


1.140
log
@don't trust that bFrameIndex in frame descriptors is unique.  fixes
a crash with Kodak S100 webcam.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.139 2010/09/29 09:33:26 jakemsr Exp $ */
d3076 2
a3077 1
	uint8_t ctrl_data[2];
d3083 12
d3107 12
a3118 1
	qctrl->minimum = letoh16(*(uint16_t *)ctrl_data);
d3126 12
a3137 1
	qctrl->maximum = letoh16(*(uint16_t *)ctrl_data);
d3145 12
a3156 1
	qctrl->step = letoh16(*(uint16_t *)ctrl_data);
d3164 12
a3175 1
	qctrl->default_value = letoh16(*(uint16_t *)ctrl_data);
d3180 2
d3191 2
a3192 1
	uint8_t ctrl_data[2];
d3198 12
d3215 14
a3228 1
	gctrl->value = letoh16(*(uint16_t *)ctrl_data);
d3239 2
a3240 1
	uint8_t ctrl_data[2];
d3246 26
a3271 1
	*(uint16_t *)ctrl_data = htole16(sctrl->value);
d3277 2
@


1.139
log
@back out support for variable sized processing unit controls until
I can figure out why it causes boot hangs with some Sonix camera
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.138 2010/09/26 23:44:51 jakemsr Exp $ */
d1108 3
a1110 2
	struct usb_video_frame_uncompressed_desc *d;
	int fmtidx;
a1111 1
	struct usb_video_frame_uncompressed_desc *fd;
d1113 1
a1113 1
	d = (struct usb_video_frame_uncompressed_desc *)(uint8_t *)desc;
d1115 2
a1116 1
	if (d->bFrameIndex == UVIDEO_MAX_FRAME) {
d1121 1
d1123 2
a1124 3
	fmtidx = sc->sc_fmtgrp_idx;
	sc->sc_fmtgrp[fmtidx].frame[d->bFrameIndex] =
	    (struct usb_video_frame_mjpeg_desc *)d;
d1126 2
a1127 1
	if (sc->sc_fmtgrp[fmtidx].format_dfidx == d->bFrameIndex) {
d1129 1
a1129 1
		    sc->sc_fmtgrp[fmtidx].frame[d->bFrameIndex];
a1131 2
	sc->sc_fmtgrp[fmtidx].frame_num++;

d1133 1
a1133 1
	    sc->sc_fmtgrp[fmtidx].format->bNumFrameDescriptors)
d1135 1
a1143 2
		fd = (struct usb_video_frame_uncompressed_desc *)
		    sc->sc_fmtgrp[fmtidx].frame[d->bFrameIndex]; 
d1148 1
a1148 1
		fbuf_size = UGETDW(d->dwMaxVideoFrameBufferSize);
@


1.138
log
@support variable sized (bControlSize != 2) processing unit bmControls,
and add support for more processing unit controls.
from Martin Pieuchot, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.137 2010/09/12 22:27:52 jakemsr Exp $ */
a677 2
	d->iProcessing = d->bmControls[d->bControlSize]; 
	d->bmVideoStandards = d->bmControls[d->bControlSize + 1];
d681 7
@


1.137
log
@anonymous unions aren't standard C and don't work with gcc2.  name the
anonymous unions "un".
delete some obsolete mpeg/jpeg compression methods that have never been
supported, and will not need to be supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.136 2010/07/26 22:17:13 mk Exp $ */
d60 3
d84 1
d678 2
a685 7
	/* XXX support variable bmControls fields */
	if (d->bControlSize != 2) {
		printf("%s: video control not supported for this device.\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
	}

d765 2
a766 2
		if (UGETW(sc->sc_desc_vc_pu[j]->bmControls) &
		    uvideo_ctrls[i].ctrl_bitmap) {
d781 9
d2581 2
a2582 1
	printf("bmControls=0x%02x\n", UGETW(d->bmControls));
@


1.136
log
@Microsoft LifeCam needs the framesize quirk as well.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.135 2010/07/26 07:12:21 mglocker Exp $ */
d2767 4
a2770 4
		fsizes->stepwise.min_width = 0;
		fsizes->stepwise.min_height = 0;
		fsizes->stepwise.max_width = 0;
		fsizes->stepwise.max_height = 0;
d2773 1
a2773 1
		fsizes->discrete.width =
d2775 1
a2775 1
		fsizes->discrete.height =
@


1.135
log
@Fix some spacing / comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.134 2010/07/26 07:01:08 mglocker Exp $ */
d334 7
@


1.134
log
@Make one more Sonix chipset cam work with 640x480 by a) adding it to the
UVIDEO_FLAG_FIX_MAX_VIDEO_FRAME_SIZE quirk list and b) cranking the
manually calculated frame size by pixels * 4 bytes (discussed with
jakemsr@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.133 2010/07/15 04:46:33 mglocker Exp $ */
d313 1
a313 1
	    { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_ISIGHT_1},
d326 1
a326 1
	    { USB_VENDOR_CHENSOURCE, USB_PRODUCT_CHENSOURCE_CM12402},
d1118 1
a1118 2
	 * So fix it by frame width/height.
	 *   XXX: YUV2 format only
d1470 1
a1470 1
		 * So fix it by frame width/height (XXX:YUV2 format only)
@


1.133
log
@* Comment poll support in conf.h
* Comment why we call the video interrupt in the mmap interface now in
uvideo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.132 2010/07/14 21:24:33 jakemsr Exp $ */
d331 7
d1126 1
a1126 1
		fbuf_size = UGETW(fd->wWidth) * UGETW(fd->wHeight) * 2;
d1479 1
a1479 1
			    UGETW(sc->sc_fmtgrp_cur->frame_cur->wHeight) * 2);
@


1.132
log
@implement poll() for video(4)
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.131 2010/04/27 03:38:34 marco Exp $ */
d2097 5
@


1.131
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.130 2009/11/24 19:08:33 deraadt Exp $ */
d2097 1
@


1.130
log
@at close() get rid of the usb task before we start tearing down; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.129 2009/10/26 15:34:16 deraadt Exp $ */
d1027 2
a1028 1
				error = uvideo_vs_parse_desc_frame_uncompressed(				    sc, desc);
@


1.129
log
@better test for if the parent is ohci; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.128 2009/10/13 19:33:19 pirofti Exp $ */
d398 3
a411 3
#ifdef UVIDEO_DUMP
	usb_rem_task(sc->sc_udev, &sc->sc_task_write);
#endif
@


1.128
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.127 2009/09/07 19:06:43 miod Exp $ */
d1711 2
a1712 1
	if (strncmp(sc->sc_udev->bus->bdev.dv_xname, "ohci", 4) == 0) {
@


1.127
log
@sizeof ptr vs sizeof *ptr bug; ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.126 2009/06/28 17:01:17 mglocker Exp $ */
d69 1
a69 1
int		uvideo_activate(struct device *, enum devact);
d558 1
a558 1
uvideo_activate(struct device *self, enum devact act)
@


1.126
log
@Better wording for the not-supported-video-control message.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.125 2009/04/18 07:30:50 mk Exp $ */
d2650 1
a2650 1
	bzero(caps, sizeof(caps));
@


1.125
log
@Fix tyop.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.124 2009/03/29 16:45:35 mglocker Exp $ */
d668 1
a668 1
		printf("%s: just 2 bytes bmControls supported yet!\n",
@


1.124
log
@Finally fix kernel crash (page fault) when closing bulk devices.

Help from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.123 2009/03/28 09:18:28 mglocker Exp $ */
d1529 2
a1530 1
		printf("%s: sofware video buffer is too small!\n", DEVNAME(sc));
@


1.123
log
@Add quirk to support "Chen-Source CM12402 Eagle IR Cam" device, by
fixing wrong dwMaxVideoFrameSize value.  As a side effect, broken
devices which report dwMaxVideoFrameSize=0 today could be fixed as well.

No regressions reported so far.  Discussed with fgsch@@.

Diff from Kenji Aoyama
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.122 2009/03/25 09:25:42 mglocker Exp $ */
d1729 4
a1732 9
	/*
	 * XXX
	 * A bulk device will crash the kernel here, because in almost all
	 * cases we close the pipe before sc->sc_vs_cur->bulk_running = 0
	 * gets noticed in the thread loop of uvideo_vs_start_bulk_thread(),
	 * which make it access a closed pipe.  We need to fix this
	 * properly.
	 */
	sc->sc_vs_cur->bulk_running = 0;
d1827 1
@


1.122
log
@Revert 1.119 bulk crash workaround, because it breaks Logitech QuickCam
9000 devices.  Add a XXX comment that we need to fix the bulk issue
properly instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.121 2009/02/27 06:00:31 mglocker Exp $ */
d248 1
d323 8
a330 1
	}
d1082 2
d1108 16
d1125 2
a1126 2
	if (UGETDW(d->dwMaxVideoFrameBufferSize) > sc->sc_max_fbuf_size)
		sc->sc_max_fbuf_size = UGETDW(d->dwMaxVideoFrameBufferSize);
d1236 1
a1236 1
		if (psize == max_packet_size) {
d1428 1
d1447 27
@


1.121
log
@0x3 is not really a good number for bit flags.  Should fix the Logitech
QuickCam OEM attachment finally.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.120 2009/02/21 08:18:13 mglocker Exp $ */
d1675 8
d1685 6
a1696 6

	if (sc->sc_vs_cur->pipeh) {
		usbd_abort_pipe(sc->sc_vs_cur->pipeh);
		usbd_close_pipe(sc->sc_vs_cur->pipeh);
		sc->sc_vs_cur->pipeh = NULL;
	}
@


1.120
log
@Fix a kernel crash for bulk devices when closing the video stream;
We give the kthread loop a moment to recognize that bulk_running=0
before we close the USB pipes.  Otherwise it can happen that we close
the USB pipes before the kthread loop stopped.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.119 2009/02/20 08:34:48 mglocker Exp $ */
d247 1
a247 1
#define UVIDEO_FLAG_VENDOR_CLASS		0x3
@


1.119
log
@Add Sony VGP-VCC9 Camera (Ricoh chipset) to the quirk list.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.118 2009/02/20 08:24:07 mglocker Exp $ */
a1676 6
	if (sc->sc_vs_cur->pipeh) {
		usbd_abort_pipe(sc->sc_vs_cur->pipeh);
		usbd_close_pipe(sc->sc_vs_cur->pipeh);
		sc->sc_vs_cur->pipeh = NULL;
	}

d1683 6
@


1.118
log
@Add more Ricoh chipsets to the quirk list which could work.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.117 2009/02/20 07:24:11 mglocker Exp $ */
d293 7
@


1.117
log
@Don't attach non-UISUBCLASS_VIDEOCONTROL interfaces from some quirk
devices.

Problem reported by Jerome Pinot (QuickCam OEM).  Also tested by deraadt@@
with ricoh chipset.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.116 2009/02/19 21:17:34 deraadt Exp $ */
d256 28
d286 7
@


1.116
log
@the uaa structure (and things it points, for instance ifaces) is only
alive during match and attach.  do not attempt to reuse this pointer or
ifaces during a deferred attach routine, since it will contain junk,
but instead make copies.
tested on all 3 kinds of uvideo's (ricoh fw load, apple fw load, and the rest)
ok robert mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.115 2009/02/06 14:24:44 mglocker Exp $ */
d246 2
d266 1
a266 1
	    0
d279 1
a279 1
	    0
d370 1
a379 4
	    id->bInterfaceSubClass == UISUBCLASS_VIDEOSTREAM)
		return (UMATCH_NONE);

	if (id->bInterfaceClass == UICLASS_VIDEO &&
d383 11
a393 2
	if (uvideo_lookup(uaa->vendor, uaa->product) != NULL)
		return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);
@


1.115
log
@Fix kernel crash (page fault) for devices with unsorted frame index.

Problem reported by Kenji Aoyama
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.114 2008/12/22 20:51:18 mglocker Exp $ */
d83 1
a83 1
		    struct usb_attach_arg *, usb_config_descriptor_t *);
d96 1
a96 2
usbd_status	uvideo_vs_parse_desc_alt(struct uvideo_softc *,
		    struct usb_attach_arg *uaa, int, int, int);
a395 1
	sc->sc_uaa = uaa;
d397 5
d453 1
a453 1
	error = uvideo_vs_parse_desc(sc, sc->sc_uaa, cdesc);
d484 2
d711 1
a711 2
uvideo_vs_parse_desc(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
    usb_config_descriptor_t *cdesc)
d720 1
a720 1
	    DEVNAME(sc), uaa->nifaces);
d761 1
a761 1
		id = usbd_get_interface_descriptor(uaa->ifaces[iface]);
d774 1
a774 1
		error = uvideo_vs_parse_desc_alt(sc, uaa, i, iface, numalts);
d1056 1
a1056 2
uvideo_vs_parse_desc_alt(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
    int vs_nr, int iface, int numalts)
d1104 1
a1104 1
			vs->ifaceh = uaa->ifaces[iface];
@


1.114
log
@First shoot of the uvideo firmware package.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.113 2008/12/22 13:33:43 mglocker Exp $ */
d1003 1
a1003 1
	if (d->bFrameIndex ==
d1040 1
a1040 1
	if (d->bFrameIndex ==
@


1.113
log
@Fix some logic in the isight specific stream header decode function
(still doesn't work).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.112 2008/12/22 09:45:46 mglocker Exp $ */
d256 1
a256 1
	    "r5u87x-05ca-183a.fw",
d263 1
a263 1
	    "isight.fw",
@


1.112
log
@Sort quirk device list and fix some comments there.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.111 2008/12/22 09:34:46 mglocker Exp $ */
d1921 3
a1923 4
	if (frame_size < 30)
		return (USBD_INVAL);

	if (!memcmp(&frame[2], magic, 12) || !memcmp(&frame[3], magic, 12))
@


1.111
log
@Add firmware load for Apple iSight first generation devices
(0x05ac:8300 before firmware load, 0x05ac:0x8501 after firmware load).

Also those devices have a own stream header procotol for which we've
added a seperate stream header decode function, which does not work yet.

A jointventure work with robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.110 2008/12/17 18:14:46 mglocker Exp $ */
d254 1
a259 6
	{   /* Incorrectly reports as UICLASS_VENDOR */
	    { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMOEM_1 },
	    NULL,
	    NULL,
	    0
	},
d261 1
a261 1
	    /* Has a own streaming header format */
d268 1
d273 6
@


1.110
log
@- Extend our quirk device table by a flags field.
- Add Apple iSight first revision device to the quirk table for future code.
- Fix some logic in the device matching function.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.109 2008/12/17 08:39:01 mglocker Exp $ */
d125 2
d202 1
d267 7
a273 1
	    { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_ISIGHT_1 },
d376 4
d392 1
a392 1
	struct uvideo_softc *sc = (struct uvideo_softc *) self;
a393 2
	usb_config_descriptor_t *cdesc;
	usbd_status error;
d395 1
a397 20
	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    DEVNAME(sc));
		return;
	}
#ifdef UVIDEO_DEBUG
	uvideo_dump_desc_all(sc);
#endif
	/* parse video control descriptors */
	error = uvideo_vc_parse_desc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* parse video stream descriptors */
	error = uvideo_vs_parse_desc(sc, uaa, cdesc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

d412 1
d415 1
d422 30
d1712 1
a1712 1
		(void)uvideo_vs_decode_stream_header(sc,
d1790 1
a1790 1
		error = uvideo_vs_decode_stream_header(sc, frame, frame_size);
d1893 58
d3199 84
@


1.109
log
@Backout anonymous union fix, since it breaks V4L ports.  we try to fix
this upstream instead.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.107 2008/12/10 21:20:47 mglocker Exp $ */
d243 1
d245 4
a248 3
	struct usb_devno uv_dev;
	char		*ucode_name;
	usbd_status	(*ucode_loader)(struct uvideo_softc *);
d253 2
a254 1
	    uvideo_ucode_loader_ricoh
d256 1
a256 1
	{	/* Incorrectly reports as UICLASS_VENDOR */
d258 10
a267 1
	    NULL, NULL
d370 1
a370 3
	if (uvideo_lookup(uaa->vendor, uaa->product) != NULL &&
	    id->bInterfaceClass == UICLASS_VENDOR &&
	    id->bInterfaceSubClass == UISUBCLASS_VIDEOCONTROL)
d406 3
d410 1
a410 3
	sc->sc_ucode = uvideo_lookup(uaa->vendor, uaa->product);

	if ((sc->sc_ucode && sc->sc_ucode->ucode_name) && rootvp == NULL)
d422 2
a423 2
	if (sc->sc_ucode && sc->sc_ucode->ucode_name) {
		error = (sc->sc_ucode->ucode_loader)(sc);
d3069 1
a3069 1
	error = loadfirmware(sc->sc_ucode->ucode_name, &ucode, &ucode_size);
@


1.108
log
@Give names to anonymous unions.

Worked on with mglocker.

OK mglocker
@
text
@d2540 4
a2543 4
		fsizes->size.stepwise.min_width = 0;
		fsizes->size.stepwise.min_height = 0;
		fsizes->size.stepwise.max_width = 0;
		fsizes->size.stepwise.max_height = 0;
d2546 1
a2546 1
		fsizes->size.discrete.width =
d2548 1
a2548 1
		fsizes->size.discrete.height =
@


1.107
log
@Fix ohci xfers for some devices by adjusting the number of microframes to
a static value of 8.

Regression tested by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.106 2008/12/10 11:43:18 mglocker Exp $ */
d2540 4
a2543 4
		fsizes->stepwise.min_width = 0;
		fsizes->stepwise.min_height = 0;
		fsizes->stepwise.max_width = 0;
		fsizes->stepwise.max_height = 0;
d2546 1
a2546 1
		fsizes->discrete.width =
d2548 1
a2548 1
		fsizes->discrete.height =
@


1.106
log
@Macro spacing.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.105 2008/12/10 08:19:23 yuo Exp $ */
d1568 1
a1568 1
		sc->sc_nframes = 6400 / sc->sc_vs_cur->psize;
@


1.105
log
@use maximum value of dwMaxVideoFrameBufferSize in each vs descriptors
as the maximum frame buffer size of video(4)

current logic potentially brake the device initialization
(and the result of the query is not correct).

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.104 2008/12/09 06:01:41 brad Exp $ */
d258 2
a259 1
#define uvideo_lookup(v, p) ((struct uvideo_devs *)usb_lookup(uvideo_devs, v, p))
@


1.104
log
@Also allow V4L2 apps to recognize the UYVY support.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.103 2008/12/08 22:02:39 deraadt Exp $ */
d969 4
d1006 4
a2985 14
	struct usb_video_probe_commit *pc;
	uint8_t probe_data[34];
	usbd_status error;

	pc = (struct usb_video_probe_commit *)probe_data;

	/* find the maximum frame size */
	bzero(probe_data, sizeof(probe_data));
	error = uvideo_vs_get_probe(sc, probe_data, GET_MAX);
	if (error != USBD_NORMAL_COMPLETION) {
		return (EINVAL);
	}

	sc->sc_max_fbuf_size = UGETDW(pc->dwMaxVideoFrameSize);
@


1.103
log
@do device classification for non-UVC and firmware-needing devices together
in the same device table, and abstract usb control out of the ricoh firmware
loader so that it can be reused by other loaders
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.102 2008/12/08 18:54:32 mglocker Exp $ */
d2484 5
@


1.102
log
@- Firmware header field "len" for Ricoh devices is uint8_t not uint16_t.
- Consistency in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.101 2008/12/08 18:33:24 mglocker Exp $ */
d65 2
a66 2
int             uvideo_match(struct device *, void *, void *);
void            uvideo_attach(struct device *, struct device *, void *);
d68 2
a69 2
int             uvideo_detach(struct device *, int);
int             uvideo_activate(struct device *, enum devact);
d73 1
a73 1
	 	    const usb_descriptor_t *);
d127 2
a198 2
int		uvideo_ucode_match(struct uvideo_softc *,
		    struct usb_attach_arg *);
d239 7
a245 4
struct uvideo_ucode {
	int		vendor;
	int		product;
	char		ucode_name[64];
d247 1
a247 1
} uvideo_ucode_devs[] = {
d249 1
a249 2
	    USB_VENDOR_RICOH,
	    USB_PRODUCT_RICOH_VGPVCC7,
d253 4
a256 11
	{ 0, 0, "", NULL }
};

/*
 * Some devices do not report themselfs as UVC compatible although
 * they are.  They report UICLASS_VENDOR in the bInterfaceClass
 * instead of UICLASS_VIDEO.  Give those devices a chance to attach
 * by looking up their USB ID.
 */
static const struct usb_devno uvideo_quirk_devs [] = {
	{ USB_VENDOR_LOGITECH,	USB_PRODUCT_LOGITECH_QUICKCAMOEM_1 }
d258 1
d357 1
a357 1
	if (usb_lookup(uvideo_quirk_devs, uaa->vendor, uaa->product) != NULL &&
d396 1
a396 1
	sc->sc_flags |= uvideo_ucode_match(sc, uaa);
d398 1
a398 1
	if (sc->sc_flags & UVIDEO_FLAGS_NEED_UCODE && rootvp == NULL)
d410 1
a410 1
	if (sc->sc_flags & UVIDEO_FLAGS_NEED_UCODE) {
d1439 1
a1439 1
	    	    DEVNAME(sc), size);
d1731 1
a1731 1
        }
d3012 3
a3014 2
int
uvideo_ucode_match(struct uvideo_softc *sc, struct usb_attach_arg *uaa)
d3016 2
a3017 2
	usb_device_descriptor_t *dd;
	int i;
d3019 5
a3023 1
	dd = usbd_get_device_descriptor(uaa->device);
d3025 3
a3027 7
	for (i = 0; uvideo_ucode_devs[i].vendor != 0; i++) {
		if (UGETW(dd->idVendor) == uvideo_ucode_devs[i].vendor &&
		    UGETW(dd->idProduct) == uvideo_ucode_devs[i].product) {
			sc->sc_ucode = &uvideo_ucode_devs[i];
			return (UVIDEO_FLAGS_NEED_UCODE);
		}
	}
d3029 1
a3029 1
	return (0);
a3034 1
	usb_device_request_t req;
d3036 1
a3036 1
	uint8_t *ucode;
a3037 1
	uint8_t buf, len;
d3039 1
a3039 1
	int offset, remain;
d3042 3
a3044 7
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = 0xa4;
	USETW(req.wIndex, 0);
	USETW(req.wValue, 0);
	USETW(req.wLength, 1);
	buf = 0;
	error = usbd_do_request(sc->sc_udev, &req, &buf);
d3050 1
a3050 1
	if (buf) {
a3064 1
	offset = 0;
d3069 1
d3078 2
a3079 6
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
		req.bRequest = 0xa0;
		USETW(req.wIndex, 0);
		USETW(req.wValue, addr);
		USETW(req.wLength, len);
		error = usbd_do_request(sc->sc_udev, &req, &ucode[offset]);
d3095 3
a3097 7
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = 0xa1;
	USETW(req.wIndex, 0);
	USETW(req.wValue, 0);
	USETW(req.wLength, 1);
	buf = 0;
	error = usbd_do_request(sc->sc_udev, &req, &buf);
@


1.101
log
@Add ability to load firmware for devices which require it.

Tested by deraadt@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.100 2008/12/06 20:06:39 mglocker Exp $ */
d3042 2
a3043 2
	uint8_t buf;
	uint16_t len, addr;
d3066 1
a3066 1
	/* open ucode file */
@


1.100
log
@No need to set dwMaxVideoFrameSize and dwMaxPayloadTransferSize to 0
in the negotation routine explicitly, because the whole structure gets
bzero'ed before.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.99 2008/12/04 07:22:10 yuo Exp $ */
d67 1
d194 7
d239 15
d399 21
d3014 109
@


1.99
log
@fix typo in the dwFrameInterval comment
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.98 2008/12/03 08:32:18 mglocker Exp $ */
a1187 2
	USETDW(pc->dwMaxVideoFrameSize, 0);
	USETDW(pc->dwMaxPayloadTransferSize, 0);
@


1.98
log
@- Fix unit for dwFrameInterval in DPRINTF.
- Add a comment from yuo@@ which describes dwFrameInterval values a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.97 2008/12/03 05:18:29 mglocker Exp $ */
d1185 1
a1185 1
	/* dwFrameInterval: 30fps=333333, 15fps=666666, 10fps=100000 */
@


1.97
log
@Fix error handling for usbd_transfer().
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.96 2008/12/03 03:47:25 yuo Exp $ */
d1185 1
d1242 2
a1243 1
	DPRINTF(1, "dwFrameInterval=%d (ns)\n", UGETDW(pc->dwFrameInterval));
d1287 2
a1288 1
	DPRINTF(1, "dwFrameInterval=%d (ns)\n", UGETDW(pc->dwFrameInterval));
@


1.96
log
@add UYVY video format support for uncompressed video

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.95 2008/12/03 03:38:53 yuo Exp $ */
d1668 1
a1668 1
	if (error != USBD_IN_PROGRESS) {
@


1.95
log
@change UVC VS negotiation logic.

some device return wrong value for get probe request without
initial set probe request.

so, now it issue set probe request and then get probe to initialize
device configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.94 2008/12/03 03:28:25 yuo Exp $ */
d845 2
@


1.94
log
@fix USB packet size handling of uvideo(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.93 2008/11/30 15:20:33 mglocker Exp $ */
d1178 1
a1178 1
	/* get probe */
d1180 1
a1180 5
	error = uvideo_vs_get_probe(sc, probe_data, GET_CUR);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* set probe */
@


1.93
log
@Setup three isoc transfers at a time so we don't miss frames.  This fixes
transfers which require larger bandwidths, e.g. for higher resolutions.

discussed with yuo@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.92 2008/11/24 23:25:33 mglocker Exp $ */
d1012 1
a1012 1
		if (UGETW(ed->wMaxPacketSize) > vs->max_packet_size) {
d1017 1
a1017 1
			vs->max_packet_size = UGETW(ed->wMaxPacketSize);
d1044 1
d1067 3
a1069 1
		if (UGETW(ed->wMaxPacketSize) >= max_packet_size) {
d1072 1
a1072 1
			sc->sc_vs_cur->max_packet_size = max_packet_size;
d1390 1
a1390 1
		size = sc->sc_vs_cur->max_packet_size * sc->sc_nframes;
d1474 1
d1504 1
a1504 1
	    sc->sc_vs_cur->max_packet_size);
d1520 1
a1520 2
		sc->sc_nframes = 6400 /
		    sc->sc_vs_cur->max_packet_size;
d1522 4
a1525 2
		sc->sc_nframes = UGETDW(sc->sc_desc_probe.dwMaxVideoFrameSize) /
		    sc->sc_vs_cur->max_packet_size;
d1658 1
a1658 1
		ixfer->size[i] = sc->sc_vs_cur->max_packet_size;
d1700 1
a1700 1
		frame = ixfer->buf + (i * sc->sc_vs_cur->max_packet_size);
@


1.92
log
@More sanitizing for wrong bDefaultFrameIndex values.  Fixes a panic
at attach time for devices which set bDefaultFrameIndex larger than
the existing frame descriptors.

Spotted, tested, and OK yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.91 2008/11/10 11:54:39 mglocker Exp $ */
d108 4
a111 2
usbd_status	uvideo_vs_alloc(struct uvideo_softc *);
void		uvideo_vs_free(struct uvideo_softc *);
d118 2
d308 4
a311 1
	uvideo_vs_free(sc);
d1371 1
a1371 1
uvideo_vs_alloc(struct uvideo_softc *sc)
d1373 1
a1373 1
	int size;
d1377 11
a1387 1
	sc->sc_vs_cur->sc = sc;
d1389 9
a1397 4
	sc->sc_vs_cur->xfer = usbd_alloc_xfer(sc->sc_udev);	
	if (sc->sc_vs_cur->xfer == NULL) {
		printf("%s: could not allocate VS xfer!\n", DEVNAME(sc));
		return (USBD_NOMEM);	
d1400 18
a1417 4
	if (sc->sc_vs_cur->bulk_endpoint)
		size = UGETDW(sc->sc_desc_probe.dwMaxPayloadTransferSize);
	else
		size = sc->sc_vs_cur->max_packet_size * sc->sc_nframes;
d1419 5
a1423 3
	sc->sc_vs_cur->buf = usbd_alloc_buffer(sc->sc_vs_cur->xfer, size);
	if (sc->sc_vs_cur->buf == NULL) {
		printf("%s: could not allocate VS buffer!\n", DEVNAME(sc));
d1426 1
a1426 1
	DPRINTF(1, "%s: allocated %d bytes VS xfer buffer\n",
d1433 1
a1433 1
uvideo_vs_free(struct uvideo_softc *sc)
d1435 2
d1439 19
a1457 3
	if (sc->sc_vs_cur->buf != NULL) {
		usbd_free_buffer(sc->sc_vs_cur->xfer);
		sc->sc_vs_cur->buf = NULL;
d1460 3
a1462 3
	if (sc->sc_vs_cur->xfer != NULL) {
		usbd_free_xfer(sc->sc_vs_cur->xfer);
		sc->sc_vs_cur->xfer = NULL;
d1562 4
a1565 1
	error = uvideo_vs_alloc(sc);
d1609 1
a1609 1
		    sc->sc_vs_cur->xfer,
d1613 1
a1613 1
		    sc->sc_vs_cur->buf,
d1624 2
a1625 2
		(void)uvideo_vs_decode_stream_header(sc, sc->sc_vs_cur->buf,
		    size);
d1636 11
d1653 1
a1653 1
		sc->sc_vs_cur->size[i] = sc->sc_vs_cur->max_packet_size;
d1656 1
a1656 1
	    sc->sc_vs_cur->xfer,
d1658 2
a1659 2
	    sc->sc_vs_cur,
	    sc->sc_vs_cur->size,
d1664 5
a1668 1
	(void)usbd_transfer(sc->sc_vs_cur->xfer);
d1675 2
a1676 2
	struct uvideo_vs_iface *vs = priv;
	struct uvideo_softc *sc = vs->sc;
d1695 2
a1696 2
		frame = vs->buf + (i * vs->max_packet_size);
		frame_size = vs->size[i];
d1708 1
a1708 1
	uvideo_vs_start_isoc(sc);
@


1.91
log
@One more replacement;  2 -> UVIDEO_SH_MIN_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.90 2008/11/09 21:24:55 mglocker Exp $ */
d783 8
a790 2
	sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx =
	    sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format->u.mjpeg.bDefaultFrameIndex;
d825 8
a832 2
	sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format_dfidx =
	    sc->sc_fmtgrp[sc->sc_fmtgrp_idx].format->u.uc.bDefaultFrameIndex;
d909 1
a909 10
	/*
	 * If bDefaultFrameIndex is not set by the device
	 * use the first bFrameIndex available, otherwise
	 * set it to the default one.
	 */
	if (sc->sc_fmtgrp[fmtidx].format->u.mjpeg.bDefaultFrameIndex == 0) {
		sc->sc_fmtgrp[fmtidx].frame_cur =
		    sc->sc_fmtgrp[fmtidx].frame[1];
	} else if (sc->sc_fmtgrp[fmtidx].format->u.mjpeg.bDefaultFrameIndex ==
	    d->bFrameIndex) {
d942 1
a942 10
	/*
	 * If bDefaultFrameIndex is not set by the device
	 * use the first bFrameIndex available, otherwise
	 * set it to the default one.
	 */
	if (sc->sc_fmtgrp[fmtidx].format->u.uc.bDefaultFrameIndex == 0) {
		sc->sc_fmtgrp[fmtidx].frame_cur =
		    sc->sc_fmtgrp[fmtidx].frame[1];
	} else if (sc->sc_fmtgrp[fmtidx].format->u.uc.bDefaultFrameIndex ==
	    d->bFrameIndex) {
@


1.90
log
@Make own struct for the stream header instead saving the data in single
variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.89 2008/11/09 20:14:06 mglocker Exp $ */
d1651 1
a1651 1
	if (frame_size < 2)
@


1.89
log
@Add BULK xfer support.

Thanks to Carlos Valiente for donating an EeePC 701 where this has been
developed and tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.88 2008/11/06 21:07:13 mglocker Exp $ */
d1648 1
a1648 1
	uint8_t header_len, header_flags;
d1655 1
a1655 2
	header_len = frame[0];
	header_flags = frame[1];
d1657 1
a1657 1
	DPRINTF(2, "%s: header_len = %d\n", DEVNAME(sc), header_len);
d1659 1
a1659 1
	if (header_len > 12 || header_len < 2)
d1662 1
a1662 1
	if (header_len == frame_size && !(header_flags & UVIDEO_STREAM_EOF)) {
d1666 1
a1666 1
	if (header_flags & UVIDEO_STREAM_ERR) {
d1674 1
a1674 1
	if (header_flags & UVIDEO_STREAM_FID) {
d1677 1
a1677 1
		    header_flags & UVIDEO_STREAM_FID);
d1681 1
a1681 1
		    header_flags & UVIDEO_STREAM_FID);
d1687 1
a1687 1
		fb->fid = header_flags & UVIDEO_STREAM_FID;
d1691 1
a1691 1
		if (fb->fid != (header_flags & UVIDEO_STREAM_FID)) {
d1695 1
a1695 1
			fb->fid = header_flags & UVIDEO_STREAM_FID;
d1701 1
a1701 1
	sample_len = frame_size - header_len;
d1703 1
a1703 1
		bcopy(frame + header_len, fb->buf + fb->offset, sample_len);
d1707 1
a1707 1
	if (header_flags & UVIDEO_STREAM_EOF) {
@


1.88
log
@Fix a small bug which made it impossible to use more than one
video control.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.87 2008/10/26 21:11:02 mglocker Exp $ */
d37 1
d113 3
a115 1
void		uvideo_vs_start(struct uvideo_softc *);
d971 1
d1000 8
a1007 2
		/* we just support isoc endpoints yet */
		if (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)
d1384 4
a1387 1
	size = sc->sc_vs_cur->max_packet_size * sc->sc_nframes;
d1482 2
d1528 50
d1579 1
a1579 1
uvideo_vs_start(struct uvideo_softc *sc)
d1640 1
a1640 1
	uvideo_vs_start(sc);
d1660 2
a1661 2
	if (header_len != 12)
		/* frame header is 12 bytes long */
d2687 4
a2690 1
	uvideo_vs_start(sc);
d2893 4
a2896 1
	uvideo_vs_start(sc);
@


1.87
log
@Fix IOERRORs seen on some devices after a few open / close cycles.

Tested and OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.86 2008/10/04 11:54:43 mglocker Exp $ */
d600 1
a600 1
	for (found = 0, j = 0; i < sc->sc_desc_vc_pu_num; j++) {
@


1.86
log
@When closing the video stream switch back to default interface as last
action.  Shuts down the device gracefully.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.85 2008/08/24 19:46:45 mglocker Exp $ */
d1474 7
@


1.85
log
@Get VIDIOC_G_FMT working (makes ekiga happy).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.84 2008/08/24 11:43:00 mglocker Exp $ */
a1468 3
	/* switch back to default interface (turns off cam LED) */
	(void)usbd_set_interface(sc->sc_vs_cur->ifaceh, 0);

d1474 3
@


1.84
log
@Use consistent variable names;  curr -> cur, err -> error.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.83 2008/08/24 11:05:02 mglocker Exp $ */
d2449 2
d2453 8
@


1.83
log
@Add support for processing unit (e.g. brightness) controls.  New V4L2
ioctls therefore are VIDIOC_QUERYCTRL, VIDIOC_G_CTRL, and VIDIOC_S_CTRL.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.82 2008/08/16 18:56:07 mglocker Exp $ */
d367 1
a367 1
	error = usbd_set_interface(sc->sc_vs_curr->ifaceh, 0);
d688 1
a688 1
	sc->sc_vs_curr = &sc->sc_vs_coll[0];
d1042 1
a1042 1
		if (id->bInterfaceNumber != sc->sc_vs_curr->iface)
d1056 3
a1058 3
			sc->sc_vs_curr->endpoint = ed->bEndpointAddress;
			sc->sc_vs_curr->curalt = id->bAlternateSetting;
			sc->sc_vs_curr->max_packet_size = max_packet_size;
d1204 1
a1204 1
	usbd_status err;
d1213 1
a1213 1
	USETW(req.wIndex, sc->sc_vs_curr->iface);
d1218 2
a1219 2
	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
d1221 1
a1221 1
		    DEVNAME(sc), usbd_errstr(err));
d1248 1
a1248 1
	usbd_status err;
d1257 1
a1257 1
	USETW(req.wIndex, sc->sc_vs_curr->iface);
d1262 2
a1263 2
	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
d1265 1
a1265 1
		    DEVNAME(sc), usbd_errstr(err));
d1291 1
a1291 1
	usbd_status err;
d1299 1
a1299 1
	USETW(req.wIndex, sc->sc_vs_curr->iface);
d1302 2
a1303 2
	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
d1305 1
a1305 1
		    DEVNAME(sc), usbd_errstr(err));
d1366 1
a1366 1
	sc->sc_vs_curr->sc = sc;
d1368 2
a1369 2
	sc->sc_vs_curr->xfer = usbd_alloc_xfer(sc->sc_udev);	
	if (sc->sc_vs_curr->xfer == NULL) {
d1374 1
a1374 1
	size = sc->sc_vs_curr->max_packet_size * sc->sc_nframes;
d1376 2
a1377 2
	sc->sc_vs_curr->buf = usbd_alloc_buffer(sc->sc_vs_curr->xfer, size);
	if (sc->sc_vs_curr->buf == NULL) {
d1392 3
a1394 3
	if (sc->sc_vs_curr->buf != NULL) {
		usbd_free_buffer(sc->sc_vs_curr->xfer);
		sc->sc_vs_curr->buf = NULL;
d1397 3
a1399 3
	if (sc->sc_vs_curr->xfer != NULL) {
		usbd_free_xfer(sc->sc_vs_curr->xfer);
		sc->sc_vs_curr->xfer = NULL;
d1418 1
a1418 1
	error = uvideo_vs_set_alt(sc, sc->sc_vs_curr->ifaceh,
d1426 1
a1426 1
	ed = usbd_interface2endpoint_descriptor(sc->sc_vs_curr->ifaceh, 0);
d1435 1
a1435 1
	    sc->sc_vs_curr->endpoint,
d1437 1
a1437 1
	    sc->sc_vs_curr->max_packet_size);
d1440 2
a1441 2
	    sc->sc_vs_curr->ifaceh,
	    sc->sc_vs_curr->endpoint,
d1443 1
a1443 1
	    &sc->sc_vs_curr->pipeh);
d1454 1
a1454 1
		    sc->sc_vs_curr->max_packet_size;
d1457 1
a1457 1
		    sc->sc_vs_curr->max_packet_size;
d1470 1
a1470 1
	(void)usbd_set_interface(sc->sc_vs_curr->ifaceh, 0);
d1472 4
a1475 4
	if (sc->sc_vs_curr->pipeh) {
		usbd_abort_pipe(sc->sc_vs_curr->pipeh);
		usbd_close_pipe(sc->sc_vs_curr->pipeh);
		sc->sc_vs_curr->pipeh = NULL;
d1517 1
a1517 1
		sc->sc_vs_curr->size[i] = sc->sc_vs_curr->max_packet_size;
d1520 4
a1523 4
	    sc->sc_vs_curr->xfer,
	    sc->sc_vs_curr->pipeh,
	    sc->sc_vs_curr,
	    sc->sc_vs_curr->size,
d1528 1
a1528 1
	(void)usbd_transfer(sc->sc_vs_curr->xfer);
@


1.82
log
@If dwMaxPayloadTransferSize doesn't exactly match to an existing
endpoint, pick the next higher endpoint bandwidth.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.81 2008/08/13 20:29:34 mglocker Exp $ */
d71 2
d74 6
d148 2
d175 3
d216 3
a218 1
	NULL,			/* VIDIOC_QUERYCTRL */
d461 6
d503 115
d1786 2
a1787 1
					/* TODO */
d2140 20
d2616 100
@


1.81
log
@Add VIDIOC_ENUM_FRAMESIZES ioctl.  This permits applications to query the
available formats and resolutions of a device (e.g. "luvcview -L").
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.80 2008/08/12 08:26:42 mglocker Exp $ */
d919 1
a919 1
		if (UGETW(ed->wMaxPacketSize) == max_packet_size) {
d922 1
a922 2
			sc->sc_vs_curr->max_packet_size =
			    UGETW(ed->wMaxPacketSize);
@


1.80
log
@Don't process xfers which have the stream error bit set in the stream
header.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.79 2008/08/11 05:37:01 mglocker Exp $ */
d152 2
d190 2
d2162 58
@


1.79
log
@Since we have ehci(4) isoc support now, don't demote USB2 uvideo(4)
devices to USB1, instead let them attach to ehci(4).

This may break a couple of the devices for the moment, but it's the way
we have to go finally.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.78 2008/08/10 10:01:25 mglocker Exp $ */
d1400 1
d1423 3
a1425 1
		(void)uvideo_vs_decode_stream_header(sc, frame, frame_size);
d1455 5
@


1.78
log
@Prepare for ehci:
- Remove GET_DEF request for negotation.  It doesn't help, instead keep
breaking devices.
- On device close first switch back to default interface 0 before
abort/close the isoc pipe.  This fixes IOERRORs on device re-open.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.77 2008/08/09 08:42:03 mglocker Exp $ */
a209 3
 *
 * If the device also doesn't set UDCLASS_VIDEO you need to add an
 * entry in usb_quirks.c, too, so the ehci disown works.
a325 6

	if (uaa->device->bus->usbrev == USBREV_2_0) {
		printf("%s: ehci(4) does not support isochronous transfers "
		    "yet, disable it.\n", DEVNAME(sc));
		return; 
	}
@


1.77
log
@Revert last commit, it doesn't always help, we need to find another
solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.76 2008/08/09 07:57:48 mglocker Exp $ */
d1036 3
a1038 6
	error = uvideo_vs_get_probe(sc, probe_data, GET_DEF);
	if (error != USBD_NORMAL_COMPLETION) {
		error = uvideo_vs_get_probe(sc, probe_data, GET_CUR);
		if (error != USBD_NORMAL_COMPLETION)
			return (error);
	}
d1134 2
a1135 4
		if (request != GET_DEF) {
			printf("%s: could not GET probe request: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
		}
d1339 3
a1346 3

	/* switch back to default interface (turns off cam LED) */
	(void)usbd_set_interface(sc->sc_vs_curr->ifaceh, 0);
@


1.76
log
@Prepare for ehci:  If GET_DEF request has failed, wait a moment before
issuing GET_CUR.  Makes my NX6000 attach on ehci.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.75 2008/08/02 21:52:37 mglocker Exp $ */
a1037 3
		/* relax a moment and retry with GET_CUR */
		usbd_delay_ms(sc->sc_udev, 100);

@


1.75
log
@Use correct terms as in the specs;
"fragment" gets replaced by "sample".
"sample" gets replaced by "frame".
A sample is a peace of a frame (final image).  No functional changes.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.74 2008/08/02 20:08:49 mglocker Exp $ */
d1038 3
@


1.74
log
@Better wording for a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.73 2008/08/02 20:05:28 mglocker Exp $ */
d97 2
a98 2
usbd_status	uvideo_vs_alloc_sample(struct uvideo_softc *);
void		uvideo_vs_free_sample(struct uvideo_softc *);
d144 1
a144 1
void		uvideo_debug_file_write_sample(void *);
d287 2
a288 2
	/* free video stream sample buffer */
	uvideo_vs_free_sample(sc);
d386 1
a386 1
	uvideo_vs_free_sample(sc);
d1189 1
a1189 1
uvideo_vs_alloc_sample(struct uvideo_softc *sc)
d1191 1
a1191 1
	struct uvideo_sample_buffer *fb = &sc->sc_sample_buffer;
d1195 1
a1195 1
	/* don't overflow the upper layer sample buffer */
d1204 1
a1204 1
		printf("%s: can't allocate sample buffer!\n", DEVNAME(sc));
d1208 1
a1208 1
	DPRINTF(1, "%s: %s: allocated %d bytes sample buffer\n",
d1211 1
a1211 1
	fb->fragment = 0;
d1219 1
a1219 1
uvideo_vs_free_sample(struct uvideo_softc *sc)
d1221 1
a1221 1
	struct uvideo_sample_buffer *fb = &sc->sc_sample_buffer;
d1369 2
a1370 2
	/* allocate video stream sample buffer */
	error = uvideo_vs_alloc_sample(sc);
d1376 1
a1376 1
	usb_init_task(&sc->sc_task_write, uvideo_debug_file_write_sample, sc);
d1447 1
a1447 1
	struct uvideo_sample_buffer *fb = &sc->sc_sample_buffer;
d1449 1
a1449 1
	int fragment_len;
d1480 3
a1482 3
	if (fb->fragment == 0) {
		/* first fragment for a sample */
		fb->fragment = 1;
d1486 1
a1486 1
		/* continues fragment for a sample, check consistency */
d1488 1
a1488 1
			DPRINTF(1, "%s: %s: wrong FID, ignore last sample!\n",
d1490 1
a1490 1
			fb->fragment = 1;
d1496 5
a1500 5
	/* save sample fragment */
	fragment_len = frame_size - header_len;
	if ((fb->offset + fragment_len) <= fb->buf_size) {
		bcopy(frame + header_len, fb->buf + fb->offset, fragment_len);
		fb->offset += fragment_len;
d1504 2
a1505 2
		/* got a full sample */
		DPRINTF(2, "%s: %s: EOF (sample size = %d bytes)\n",
d1522 1
a1522 1
			DPRINTF(1, "%s: %s: sample too large, skipped!\n",
d1526 1
a1526 1
		fb->fragment = 0;
d2070 1
a2070 1
uvideo_debug_file_write_sample(void *arg)
d2073 1
a2073 1
	struct uvideo_sample_buffer *sb = &sc->sc_sample_buffer;
d2228 1
a2228 1
	/* tell our sample buffer size */
d2441 2
a2442 2
	/* tell our sample buffer size */
	fmt->fmt.pix.sizeimage = sc->sc_sample_buffer.buf_size;
@


1.73
log
@Spacing, sorting, and remove an unused prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.72 2008/08/02 17:30:31 mglocker Exp $ */
d262 1
a262 1
	/* pointers to upper layer which we need */
@


1.72
log
@Woops, remove #undef which was committed by mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.71 2008/08/02 16:34:45 mglocker Exp $ */
d57 2
a63 1

a71 1

a92 1

d111 1
d171 3
a173 1
#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)
a182 10
struct cfdriver uvideo_cd = {
	NULL,
	"uvideo",
	DV_DULL
};

usbd_status 
uvideo_usb_request(struct uvideo_softc * sc, u_int8_t type, u_int8_t request,
    u_int16_t value, u_int16_t index, u_int16_t length, u_int8_t * data);

d205 13
a293 13

/*
 * Some devices do not report themselfs as UVC compatible although
 * they are.  They report UICLASS_VENDOR in the bInterfaceClass
 * instead of UICLASS_VIDEO.  Give those devices a chance to attach
 * by looking up their USB ID.
 *
 * If the device also doesn't set UDCLASS_VIDEO you need to add an
 * entry in usb_quirks.c, too, so the ehci disown works.
 */
static const struct usb_devno uvideo_quirk_devs [] = {
	{ USB_VENDOR_LOGITECH,	USB_PRODUCT_LOGITECH_QUICKCAMOEM_1 }
};
@


1.71
log
@Don't print error message if GET_DEF request fails, since this is common
for some devices and we will fail back to GET_CUR then.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.70 2008/08/02 12:32:23 mglocker Exp $ */
a49 1
#undef UVIDEO_DEBUG
@


1.70
log
@If a format descriptor doesn't contain any frame descriptors even if it
claims to (as seen on the M$ LifeCam NX6000), abort further processing.
Safes us from potential NULL pointer derefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.69 2008/08/02 08:51:25 mglocker Exp $ */
d50 1
d1146 4
a1149 2
		printf("%s: could not GET probe request: %s\n",
		    DEVNAME(sc), usbd_errstr(err));
@


1.69
log
@Fix typo. Reported by Maxim Belooussov.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.68 2008/08/01 12:16:52 mglocker Exp $ */
d1035 7
d2197 7
@


1.68
log
@- Use defined return values wherever possible instead inventing
custom ones.
- Define functions which use USB return values with usbd_status
instead int.
- Define functions which always return 0 with void instead int.
- (void) function calls which don't check the return code.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.67 2008/08/01 08:20:26 mglocker Exp $ */
d2050 1
a2050 1
		DPRINTF(1, "%s: %s: can't creat debug file %s!\n",
@


1.67
log
@If no format descriptors have been found, abort attachment.  Adjust some
DPRINTF and printf messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.66 2008/07/31 15:26:25 mglocker Exp $ */
d68 2
a69 2
int		uvideo_vc_parse_desc(struct uvideo_softc *);
int		uvideo_vc_parse_desc_header(struct uvideo_softc *,
d72 1
a72 1
int		uvideo_vs_parse_desc(struct uvideo_softc *,
d74 1
a74 1
int		uvideo_vs_parse_desc_input_header(struct uvideo_softc *,
d76 2
a77 2
int		uvideo_vs_parse_desc_format(struct uvideo_softc *);
int		uvideo_vs_parse_desc_format_mjpeg(struct uvideo_softc *,
d79 1
a79 1
int		uvideo_vs_parse_desc_format_uncompressed(struct uvideo_softc *,
d81 2
a82 2
int		uvideo_vs_parse_desc_frame(struct uvideo_softc *);
int		uvideo_vs_parse_desc_frame_mjpeg(struct uvideo_softc *,
d84 1
a84 1
int		uvideo_vs_parse_desc_frame_uncompressed(struct uvideo_softc *,
d86 1
a86 1
int		uvideo_vs_parse_desc_alt(struct uvideo_softc *,
d88 1
a88 1
int		uvideo_vs_set_alt(struct uvideo_softc *, usbd_interface_handle,
d91 1
a91 1
int		uvideo_find_res(struct uvideo_softc *, int, int, int,
d108 1
a108 1
int		uvideo_vs_decode_stream_header(struct uvideo_softc *,
d110 2
a111 2
int		uvideo_mmap_queue(struct uvideo_softc *, uint8_t *, int);
int		uvideo_read(struct uvideo_softc *, uint8_t *, int);
d425 1
a425 1
int
d431 1
d452 1
a452 1
				return (-1);
d454 3
a456 2
			if (uvideo_vc_parse_desc_header(sc, desc) != 0)
				return (-1);
d468 1
a468 1
		return (-1);
d471 1
a471 1
	return (0);
d474 1
a474 1
int
d485 1
a485 1
		return (-1);
d491 1
a491 1
	return (0);
d494 1
a494 1
int
d521 3
a523 2
			if (uvideo_vs_parse_desc_input_header(sc, desc) != 0)
				return (-1);
d570 1
a570 1
int
d581 1
a581 1
		return (-1);
d587 1
a587 1
	return (0);
d590 1
a590 1
int
d609 2
a610 1
				uvideo_vs_parse_desc_format_mjpeg(sc, desc);
d615 2
a616 2
				uvideo_vs_parse_desc_format_uncompressed(sc,
				    desc);
d636 1
a636 1
int
d647 1
a647 1
		return (-1);
d652 1
a652 1
		return (-1);
d668 1
a668 1
	return (0);
d671 1
a671 1
int
d683 1
a683 1
		return (-1);
d688 1
a688 1
		return (-1);
d711 1
a711 1
	return (0);
d714 1
a714 1
int
d719 1
d733 3
a735 2
			if (uvideo_vs_parse_desc_frame_mjpeg(sc, desc))
				return (1);
d740 3
a742 3
				if (uvideo_vs_parse_desc_frame_uncompressed(sc,
				    desc))
					return (1);
d750 1
a750 1
	return (0);
d753 1
a753 1
int
d765 1
a765 1
		return (1);
d791 1
a791 1
	return (0);
d794 1
a794 1
int
d806 1
a806 1
		return (1);
d833 1
a833 1
	return (0);
d836 1
a836 1
int
d900 1
a900 1
int
d997 1
a997 1
int
a1023 2

	return (0);
d1361 1
a1361 1
		return (EIO);
d1366 1
a1366 1
		return (EIO);
d1371 1
a1371 1
		return (EIO);
d1374 1
a1374 1
		return(EIO);
d1435 1
a1435 1
		uvideo_vs_decode_stream_header(sc, frame, frame_size);
d1442 1
a1442 1
int
d1452 1
a1452 1
		return (-1);
d1461 1
a1461 1
		return (-1);
d1464 1
a1464 1
		return (-1);
d1529 1
a1529 1
	return (0);
d1532 1
a1532 1
int
a1562 2

	return (0);
d1565 1
a1565 1
int
a1574 2

	return (0);
d2052 1
a2052 1
		return (-1);
d2059 1
a2059 1
		return (-1);
@


1.66
log
@- Don't relay on bFormatIndex as an internal array index, since this
field is unreliable and can start with any number.  Use an own internal
array index instead.

- If the read buffer is too small, return a propper error to the calling
functions.  Just check the buffer size if we use the read(2) method since
it doesn't affect mmap(2).

Fixes kernel crashes seen with the M$ LifeCam NX-6000 and internal
(laptop) Sonix chipsets.

Tested by jcs@@ (Sonix) and myself (NX-6000).

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.65 2008/07/29 13:45:04 mglocker Exp $ */
d622 8
a629 1
	return (0);
d641 1
a641 1
		printf("%s: no MJPEG frame descriptors found!\n",
d647 1
a647 2
		printf("%s: too many MJPEG format descriptors found!\n",
		    DEVNAME(sc));
d677 1
a677 1
		printf("%s: no UNCOMPRESSED frame descriptors found!\n",
d683 1
a683 2
		printf("%s: too many UNCOMPRESSED format descriptors found!\n",
		    DEVNAME(sc));
@


1.65
log
@The stream header length and flags field are uint8_t not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.64 2008/07/26 11:42:43 mglocker Exp $ */
d83 1
a83 1
		    const usb_descriptor_t *, int *);
d85 1
a85 1
		    const usb_descriptor_t *, int *);
d169 1
a169 1
void		uvideo_start_read(void *);
d620 2
d639 1
a639 1
	if (d->bFormatIndex == UVIDEO_MAX_FORMAT) {
a643 3
	sc->sc_fmtgrp[d->bFormatIndex].format = (struct uvideo_format_desc *)d;
	sc->sc_fmtgrp[d->bFormatIndex].format_dfidx =
	    sc->sc_fmtgrp[d->bFormatIndex].format->u.mjpeg.bDefaultFrameIndex;
d645 5
a649 1
	sc->sc_fmtgrp[d->bFormatIndex].pixelformat = V4L2_PIX_FMT_MJPEG;
d653 1
a653 1
		sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[d->bFormatIndex];
d655 1
d676 1
a676 1
	if (d->bFormatIndex == UVIDEO_MAX_FORMAT) {
a680 3
	sc->sc_fmtgrp[d->bFormatIndex].format = (struct uvideo_format_desc *)d;
	sc->sc_fmtgrp[d->bFormatIndex].format_dfidx =
	    sc->sc_fmtgrp[d->bFormatIndex].format->u.uc.bDefaultFrameIndex;
d682 5
a686 1
	i = d->bFormatIndex;
d697 1
a697 1
		sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[d->bFormatIndex];
d699 1
a709 1
	int fmtidx = 0;
d723 1
a723 1
			if (uvideo_vs_parse_desc_frame_mjpeg(sc, desc, &fmtidx))
d730 1
a730 1
				    desc, &fmtidx))
d744 1
a744 1
    const usb_descriptor_t *desc, int *fmtidx)
d747 1
a750 3
	if (d->bFrameIndex == 1)
		++*fmtidx;

d756 3
a758 1
	sc->sc_fmtgrp[*fmtidx].frame[d->bFrameIndex] = d;
d765 4
a768 4
	if (sc->sc_fmtgrp[*fmtidx].format->u.mjpeg.bDefaultFrameIndex == 0) {
		sc->sc_fmtgrp[*fmtidx].frame_cur =
		    sc->sc_fmtgrp[*fmtidx].frame[1];
	} else if (sc->sc_fmtgrp[*fmtidx].format->u.mjpeg.bDefaultFrameIndex ==
d770 2
a771 2
		sc->sc_fmtgrp[*fmtidx].frame_cur =
		    sc->sc_fmtgrp[*fmtidx].frame[d->bFrameIndex];
d774 5
a778 1
	sc->sc_fmtgrp[*fmtidx].frame_num++;
d785 1
a785 1
    const usb_descriptor_t *desc, int *fmtidx)
d788 1
a791 3
	if (d->bFrameIndex == 1)
		++*fmtidx;

d797 3
a799 1
	sc->sc_fmtgrp[*fmtidx].frame[d->bFrameIndex] =
d807 4
a810 4
	if (sc->sc_fmtgrp[*fmtidx].format->u.uc.bDefaultFrameIndex == 0) {
		sc->sc_fmtgrp[*fmtidx].frame_cur =
		    sc->sc_fmtgrp[*fmtidx].frame[1];
	} else if (sc->sc_fmtgrp[*fmtidx].format->u.uc.bDefaultFrameIndex ==
d812 2
a813 2
		sc->sc_fmtgrp[*fmtidx].frame_cur =
		    sc->sc_fmtgrp[*fmtidx].frame[d->bFrameIndex];
d816 5
a820 1
	sc->sc_fmtgrp[*fmtidx].frame_num++;
d1186 2
a1187 1
	if (sc->sc_max_fbuf_size < fb->buf_size) {
d2116 1
a2116 2
	idx = fmtdesc->index + 1;
	if (idx > sc->sc_fmtgrp_num) 
d2119 1
d2177 1
a2177 1
	for (found = 0, i = 1; i <= sc->sc_fmtgrp_num; i++) {
d2374 5
a2379 1
	uvideo_vs_init(sc);
d2409 1
a2409 1
	for (found = 0, i = 1; i <= sc->sc_fmtgrp_num; i++) {
d2461 1
a2461 1
	if (error != USBD_NORMAL_COMPLETION)
d2463 1
d2470 1
a2470 1
void
d2474 1
d2479 4
a2482 1
	uvideo_vs_init(sc);
d2484 2
@


1.64
log
@Since we are able to change the device image resolution on the fly in the
meantime, the memory allocation for the read(2) method for video(4)
is not right anymore, and can cause a buffer overflow.

We fix this by queuering the maximum available image size for a device at
attach time.  If the image size should exceed our video(4) buffer after a
video format change (which shouldn't happen), uvideo(4) will gracefully
fail.

Also tested by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.63 2008/07/25 17:20:27 mglocker Exp $ */
d1424 2
a1425 1
	int header_len, header_flags, fragment_len;
@


1.63
log
@After our recent changes, VIDIOC_S_FMT didn't always return the correct
maximum image size.  Fix it.  Makes read(2) method work again.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.62 2008/07/25 11:12:34 mglocker Exp $ */
a1121 2
	sc->sc_video_buf_size = UGETDW(pc->dwMaxVideoFrameSize);

d1132 1
a1132 1
	    sc->sc_video_buf_size);
d1173 1
a1173 1
	if (sc->sc_video_buf_size < fb->buf_size) {
d2433 13
d2447 1
a2447 1
	return (sc->sc_video_buf_size);
@


1.62
log
@Not all devices support GET_DEF, fall back on GET_CUR if so.

Reported and tested kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.61 2008/07/24 13:30:10 mglocker Exp $ */
d2203 1
a2203 1
	fmt->fmt.pix.sizeimage = sc->sc_sample_buffer.buf_size;
@


1.61
log
@Simplify uvideo_enum_fmt(), no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.60 2008/07/23 14:10:58 mglocker Exp $ */
d1016 5
a1020 2
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
@


1.60
log
@- Fix potential uvm_fault crash in
uvideo_vs_parse_desc_frame_uncompressed().

- If a VS alternate interface isn't valid (e.g. doesn't contain a
UE_ISOCHRONOUS endpoint), abort attachment with a corresponding error
message instead crashing the kernel.

Tested and OK maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.59 2008/07/22 16:24:40 mglocker Exp $ */
d2101 1
a2101 1
	if (idx == UVIDEO_MAX_FORMAT || sc->sc_fmtgrp[idx].format == NULL)
d2115 2
a2116 2
		if (!strcmp(sc->sc_fmtgrp[idx].format->u.uc.guidFormat,
		    "YUY2")) {
d2120 2
a2121 2
		} else if (!strcmp(sc->sc_fmtgrp[idx].format->u.uc.guidFormat,
		    "NV12")) {
@


1.59
log
@There are devices out there which are UVC compatible, but do not show
up as this (we love standards).  To make those devices attach anyway
we add an explicit quirk device list.  Of course this list still needs
to be extended.

Thanks to Jerome Pinot for reporting about this issue and testing this
diff with his cam, which is such a device.

OK yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.58 2008/07/22 11:02:17 mglocker Exp $ */
d556 3
a558 1
		uvideo_vs_parse_desc_alt(sc, uaa, i, iface, numalts);
d723 1
a723 1
			if (desc->bLength > 11) {
d841 4
a844 3
		desc = usb_desc_iter_next(&iter);
		if (desc->bDescriptorType != UDESC_ENDPOINT)
			goto next;
d849 4
d866 7
d1623 1
a1623 1
				if (desc->bLength > 11) {
@


1.58
log
@Spelling, negotation -> negotiation.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.57 2008/07/22 10:57:15 mglocker Exp $ */
d290 13
d317 5
@


1.57
log
@Fix uvm_fault crash in uvideo_vs_negotation() which was reported by some
users.

Thanks to mpf@@ for his help to debug this bug down.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.56 2008/07/19 11:30:55 mglocker Exp $ */
d94 1
a94 1
usbd_status	uvideo_vs_negotation(struct uvideo_softc *, int);
d351 2
a352 2
	/* do device negotation without commit */
	error = uvideo_vs_negotation(sc, 0);
d973 1
a973 1
uvideo_vs_negotation(struct uvideo_softc *sc, int commit)
d1230 2
a1231 2
		/* do device negotation with commit */
		error = uvideo_vs_negotation(sc, 1);
d2142 1
a2142 1
	 * Do negotation.
d2144 1
a2144 1
	/* save a copy of current fromat group in case of negotation fails */
d2151 2
a2152 2
	/* do device negotation with commit */
	error = uvideo_vs_negotation(sc, 1);
@


1.56
log
@If a resolution which has been requested over VIDEO_TRY_FMT or
VIDEO_S_FMT doesn't exactly match the devices available resolutions,
return the next best matching resolution which we have.

Makes some V4L2 apps happy when running them with the default resolution
(no options).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.55 2008/07/18 21:45:24 mglocker Exp $ */
d703 1
a703 1
			if (desc->bLength == 38) {
@


1.55
log
@For negotation first get the devices default values (GET_DEF) instead
asking for (GET_CUR) directly.  This gets us better negotation values.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.54 2008/07/18 18:49:11 mglocker Exp $ */
d91 2
d937 35
d2118 2
a2119 1
	int found, i, j, width, height;
d2139 1
a2139 18
	for (found = 0, j = 1; j <= sc->sc_fmtgrp[i].frame_num; j++) {
		width = UGETW(sc->sc_fmtgrp[i].frame[j]->wWidth);
		height = UGETW(sc->sc_fmtgrp[i].frame[j]->wHeight);
		DPRINTF(1, "%s: %s: frame index %d: width=%d, height=%d\n",
		    DEVNAME(sc), __func__, j, width, height);
		if (fmt->fmt.pix.width == width &&
		    fmt->fmt.pix.height == height) {
			found = 1;
			break;
		}
	}
	/*
	 * TODO
	 * If we don't have exactly the requested resolution we should
	 * search for the closest matching resolution which we can offer.
	 */
	if (found == 0)
		return (EINVAL);
d2149 2
a2150 2
	sc->sc_fmtgrp[i].frame_cur = sc->sc_fmtgrp[i].frame[j];
	sc->sc_fmtgrp[i].format_dfidx = j;
d2161 2
a2162 2
	fmt->fmt.pix.width = width;
	fmt->fmt.pix.height = height;
d2165 1
a2165 1
	    DEVNAME(sc), __func__, width, height);
d2347 2
a2348 1
	int found, i, j, width, height;
d2367 1
a2367 18
	for (found = 0, j = 1; j <= sc->sc_fmtgrp[i].frame_num; j++) {
		width = UGETW(sc->sc_fmtgrp[i].frame[j]->wWidth);
		height = UGETW(sc->sc_fmtgrp[i].frame[j]->wHeight);
		DPRINTF(1, "%s: %s: frame index %d: width=%d, height=%d\n",
		    DEVNAME(sc), __func__, j, width, height);
		if (fmt->fmt.pix.width == width &&
		    fmt->fmt.pix.height == height) {
			found = 1;
			break;
		}
	}
	/*
	 * TODO
	 * If we don't have exactly the requested resolution we should
	 * search for the closest matching resolution which we can offer.
	 */
	if (found == 0)
		return (EINVAL);
d2370 2
a2371 2
	fmt->fmt.pix.width = width;
	fmt->fmt.pix.height = height;
d2374 1
a2374 1
	    DEVNAME(sc), __func__, width, height);
@


1.54
log
@Implement VIDIOC_S_FMT and VIDIOC_TRY_FMT.  Now V4L2 applications can
set their desired image size, and therefore users can manipulate the
image size, too via the application.

Also tested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.53 2008/07/14 19:57:36 mglocker Exp $ */
d94 1
a94 1
usbd_status	uvideo_vs_get_probe(struct uvideo_softc *, uint8_t *);
d946 1
a946 1
	error = uvideo_vs_get_probe(sc, probe_data);
d963 1
a963 1
	error = uvideo_vs_get_probe(sc, probe_data);
d1024 2
a1025 1
uvideo_vs_get_probe(struct uvideo_softc *sc, uint8_t *probe_data)
d1033 1
a1033 1
	req.bRequest = GET_CUR;
@


1.53
log
@Make VIDIOC_ENUM_FMT list all available formats for the attached device.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.52 2008/07/14 04:45:50 mglocker Exp $ */
d102 1
a248 1
	usbd_status error;
a260 19
	/* open video stream pipe */
	error = uvideo_vs_open(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (EIO);

	/* allocate video stream xfer buffer */
	error = uvideo_vs_alloc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (EIO);

	/* allocate video stream sample buffer */
	error = uvideo_vs_alloc_sample(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return (EIO);
#ifdef UVIDEO_DUMP
	if (uvideo_debug_file_open(sc) != 0)
		return(EIO);
	usb_init_task(&sc->sc_task_write, uvideo_debug_file_write_sample, sc);
#endif
d262 1
d624 2
d630 2
d640 1
d659 9
d672 2
d747 2
d785 2
d1191 6
a1196 4
	/* do device negotation with commit */
	error = uvideo_vs_negotation(sc, 1);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
d1259 27
d2078 4
d2086 60
d2305 1
d2324 3
d2330 43
d2406 1
@


1.52
log
@Finish support for uncompressed payloads (UDESCSUB_VS_FORMAT_UNCOMPRESSED).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.51 2008/07/13 12:48:40 mglocker Exp $ */
d1993 1
d1995 2
a1996 2
	if (fmtdesc->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||
	    fmtdesc->index > 0)
d1999 6
a2004 5
	/*
	 * XXX We need to create a sc->sc_desc_format pointer array
	 * which contains all available format descriptors.
	 */
	switch (sc->sc_fmtgrp_cur->format->bDescriptorSubtype) {
d2009 21
d2035 2
@


1.51
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.50 2008/07/13 11:49:31 mglocker Exp $ */
d85 1
a85 1
		    const usb_descriptor_t *);
d638 7
a644 4
	sc->sc_fmtgrp[d->bFormatIndex].format = d;

	/* set MJPEG format as default */
	sc->sc_fmtgrp_cur = &sc->sc_fmtgrp[d->bFormatIndex];
d663 12
a674 1
	/* TODO */
d701 8
d740 37
a776 1
	if (sc->sc_fmtgrp[*fmtidx].format->bDefaultFrameIndex == 0) {
d779 1
a779 1
	} else if (sc->sc_fmtgrp[*fmtidx].format->bDefaultFrameIndex ==
d950 1
a950 1
	pc->bFrameIndex = sc->sc_fmtgrp_cur->format->bDefaultFrameIndex;
@


1.50
log
@Save format and frame descriptors to a format group structure so we
can use them later for stuff like VIDIOC_S_FMT (e.g. set custom
resolution).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.49 2008/07/10 04:49:12 mglocker Exp $ */
d623 1
a623 1
        struct usb_video_format_mjpeg_desc *d;
d625 1
a625 1
        d = (struct usb_video_format_mjpeg_desc *)(uint8_t *)desc;
d627 5
a631 5
        if (d->bNumFrameDescriptors == 0) {
                printf("%s: no MJPEG frame descriptors found!\n",
                    DEVNAME(sc));
                return (-1);
        }
d643 1
a643 1
        return (0);
@


1.49
log
@Make cams with Sonix chipset work by avoiding excessive alternate
interface switching, which kind of crashed the device.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.48 2008/07/07 18:07:51 mglocker Exp $ */
d83 1
a83 1
		    const usb_descriptor_t *);
d633 9
a641 1
        sc->sc_desc_format_mjpeg = d;
d670 1
d684 2
a685 2
			if (uvideo_vs_parse_desc_frame_mjpeg(sc, desc) == 0)
				return (0);
d692 1
a692 3
	printf("%s: no default frame descriptor found!\n", DEVNAME(sc));

	return (1);
d697 1
a697 1
    const usb_descriptor_t *desc)
d703 10
d718 8
a725 7
	if (!sc->sc_desc_format_mjpeg->bDefaultFrameIndex)
		goto set;
	else if (d->bFrameIndex != sc->sc_desc_format_mjpeg->bDefaultFrameIndex)
		return (1);

set:
	sc->sc_desc_frame_mjpeg = d;
d891 2
a892 2
	pc->bFormatIndex = sc->sc_desc_format_mjpeg->bFormatIndex;
	pc->bFrameIndex = sc->sc_desc_format_mjpeg->bDefaultFrameIndex;
d894 1
a894 1
	    UGETDW(sc->sc_desc_frame_mjpeg->dwDefaultFrameInterval));
d1944 1
a1944 1
	switch (sc->sc_desc_format_mjpeg->bDescriptorSubtype) {
@


1.48
log
@- Improve negotation and fix some more DPRINTFs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.47 2008/07/06 13:50:36 mglocker Exp $ */
d92 1
a92 1
usbd_status	uvideo_vs_negotation(struct uvideo_softc *);
d362 7
a368 2
	/* do device negotation */
	error = uvideo_vs_negotation(sc);
d717 2
a720 2
	int i;
	usbd_status error;
d724 9
a732 12
	for (i = 0; i < numalts; i++) {
		error = usbd_set_interface(uaa->ifaces[iface], i);
		if (error) {
			printf("%s: could not set alternate interface %d!\n",
			    DEVNAME(sc), i);
			return (USBD_INVAL);
		}

		id = usbd_get_interface_descriptor(uaa->ifaces[iface]);
		if (id == NULL)
			continue;

d735 1
a735 3

		ed = usbd_interface2endpoint_descriptor(uaa->ifaces[iface], 0);
		if (ed == NULL) {
d737 1
a737 1
			continue;
d740 5
d748 1
d757 2
a758 8
	}

	/* switch back to default interface, otherwise negotation could fail */
	error = usbd_set_interface(uaa->ifaces[iface], 0);
	if (error) {
		printf("%s: could not set alternate interface 0!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
d768 2
d775 12
a786 7
	for (i = 0; i < sc->sc_vs_curr->numalts; i++) {
		error = usbd_set_interface(ifaceh, i);
		if (error) {
			printf("%s: could not set alternate interface %d!\n",
			    DEVNAME(sc), i);
			return (USBD_INVAL);
		}
d788 6
a793 7
		id = usbd_get_interface_descriptor(ifaceh);
		if (id == NULL)
			continue;

		ed = usbd_interface2endpoint_descriptor(ifaceh, 0);
		if (ed == NULL)
			continue;
d795 1
a800 1

d804 5
d810 6
a815 2
			return (USBD_NORMAL_COMPLETION);
		}
d818 1
a818 1
	return (USBD_INVAL);
d858 1
a858 1
uvideo_vs_negotation(struct uvideo_softc *sc)
d890 5
a894 3
	error = uvideo_vs_set_commit(sc, probe_data);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);
d1112 5
@


1.47
log
@When the device gets close switch back from alternate interface to
default interface.  Nice side effect;  Turns off the cams LED again.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.46 2008/07/03 09:50:04 mglocker Exp $ */
d139 1
a139 1
void		uvideo_hexdump(void *, int);
d849 3
a851 1
	/* set probe */
d853 3
a855 1
	pc = (struct usb_video_probe_commit *)probe_data;
d857 1
d860 4
a863 1

d918 1
a918 1
	DPRINTF(1, "wCompWindowSize=0x%04x\n", UGETW(pc->wCompWindowSize));
d963 1
a963 1
	DPRINTF(1, "wCompWindowSize=0x%04x\n", UGETW(pc->wCompWindowSize));
d1796 2
a1797 2
	/* XXX we need a hexdump here */
	printf("guidExtensionCode=%s\n", d->guidExtensionCode);
d1803 1
a1803 1
uvideo_hexdump(void *buf, int len)
d1808 6
a1813 4
		if (i % 16 == 0)
			printf("%s%5i:", i ? "\n" : "", i);
		if (i % 4 == 0)
			printf(" ");
@


1.46
log
@Add struct for VC_EXTENSION_UNIT and dump it in debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.45 2008/07/02 21:28:50 mglocker Exp $ */
d753 1
a753 1
	/* set back first alternate, otherwise negotation can fail */
d1144 3
@


1.45
log
@Add first bits to support uncompressed format.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.44 2008/07/01 11:02:44 mglocker Exp $ */
d137 2
d1434 2
a1435 1
					/* TODO */
d1771 18
@


1.44
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.43 2008/06/30 16:48:49 mglocker Exp $ */
d79 2
d84 2
d133 4
d598 6
d632 19
d1396 10
a1405 2
				printf(" (UDESCSUB_VC_SELECTOR_UNIT)\n");
				/* TODO */
d1410 11
a1420 2
				printf(" (UDESCSUB_VC_PROCESSING_UNIT)\n");
				/* TODO */
d1430 2
a1431 1
					printf(" (UDESCSUB_VC_EXTENSION_UNIT)\n");
d1725 46
d1868 1
a1868 1
	 * which containts all available format descriptors.
@


1.43
log
@- Free mmap buffer on close/detach.
- Fix DPRINTF while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.42 2008/06/26 21:00:27 mglocker Exp $ */
d297 1
a297 1
uvideo_match(struct device * parent, void *match, void *aux)
d317 1
a317 1
uvideo_attach(struct device * parent, struct device * self, void *aux)
d369 1
a369 1
uvideo_detach(struct device * self, int flags)
d388 1
a388 1
uvideo_activate(struct device * self, enum devact act)
d391 1
a391 1
	int             rv = 0;
@


1.42
log
@Make video stream work properly on uhci and ohci by adding an ohci
isoc xfer workaround.

Improved and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.41 2008/06/23 04:58:00 mglocker Exp $ */
d994 5
d1840 1
a1840 1
	DPRINTF(1, "%s: count=%d\n", __func__, rb->count);
@


1.41
log
@Don't bzero() the USB buffer before every xfer.  This was just for debug
purposes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.40 2008/06/22 20:58:17 mglocker Exp $ */
d1081 8
a1088 1
	sc->sc_nframes = UVIDEO_SFRAMES_MAX / sc->sc_vs_curr->max_packet_size;
@


1.40
log
@If no frame gets queue for a certain time, return EINVAL to the userland
application which will cause it to exit instead let it stuck forever.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.39 2008/06/15 17:07:18 mglocker Exp $ */
a1110 3

	bzero(sc->sc_vs_curr->buf,
	    sc->sc_vs_curr->max_packet_size * sc->sc_nframes);
@


1.39
log
@One more printf -> DPRINTF in the USB xfer callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.38 2008/06/15 16:58:57 mglocker Exp $ */
d1922 1
a1922 1
		error = tsleep(sc, 0, "vid_mmap", 0);
@


1.38
log
@Make frame queueing reliable by setting tsleep() priorities to 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.37 2008/06/15 11:08:57 mglocker Exp $ */
d1139 1
a1139 1
		printf("%s: %s: %s\n", DEVNAME(sc), __func__,
@


1.37
log
@Move noisy frame queueing debug messages up to debug level 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.36 2008/06/15 03:44:31 robert Exp $ */
d1922 1
a1922 1
		error = tsleep(sc, PWAIT | PCATCH, "vid_mmap", 0);
@


1.36
log
@if we are trying to attach to ehci(4) notify the user to disable it
because it does not support isochronous transfers yet. we hope that
we can remove this as soon as possible. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.35 2008/06/13 18:04:56 mglocker Exp $ */
d1274 1
a1274 1
	DPRINTF(1, "%s: %s: frame queued on index %d\n",
d1907 1
a1907 1
	DPRINTF(1, "%s: %s: buffer on index %d ready for queueing\n",
d1935 1
a1935 1
	DPRINTF(1, "%s: %s: frame dequeued from index %d\n",
@


1.35
log
@Remove DEBUG #undef's we can turn it on/off in GENERIC like for all
other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.34 2008/06/12 22:16:16 robert Exp $ */
d39 2
d43 1
d325 6
@


1.34
log
@disable debug printfs and descriptor dumps
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.33 2008/06/11 01:27:31 robert Exp $ */
a45 3

#undef UVIDEO_DEBUG
#undef UVIDEO_DUMP
@


1.33
log
@implement the VIDIOC_STREAMOFF ioctl and remove some unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.32 2008/06/11 00:00:37 robert Exp $ */
d47 1
a47 1
#define UVIDEO_DEBUG
@


1.32
log
@If bDefaultFrameIndex is 0 we should use the first bFrameIndex.
In any other case use the one reported by bDefaultFrameIndex.
Fix indentation while here
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.31 2008/06/10 23:39:01 robert Exp $ */
d148 1
d192 1
d811 1
a811 4
#if 0
	pc->bFormatIndex = 1;
	pc->bFrameIndex = 1;
#endif
d814 1
a1241 1
		//fb->offset = 0;
d1942 10
@


1.31
log
@add VIDIOC_QUERYCTRL to the supported ioctls
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.30 2008/06/10 06:08:22 mglocker Exp $ */
d644 1
a644 1
        struct usb_video_frame_mjpeg_desc *d;
d646 1
a646 1
        d = (struct usb_video_frame_mjpeg_desc *)(uint8_t *)desc;
d648 9
a656 3
	/* choose default frame index */
        if (d->bFrameIndex != sc->sc_desc_format_mjpeg->bDefaultFrameIndex)
                return (1);
d658 2
a659 1
        sc->sc_desc_frame_mjpeg = d;
d661 1
a661 1
        return (0);
@


1.30
log
@Sort functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.29 2008/06/09 20:51:31 mglocker Exp $ */
d192 1
@


1.29
log
@Let the driver switch between read() and mmap() depending on what
the userland application wants.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.28 2008/06/09 05:49:10 robert Exp $ */
a148 1
caddr_t		uvideo_mappage(void *, off_t, int);
d153 1
d1948 14
a1978 14
}

caddr_t
uvideo_mappage(void *v, off_t off, int prot)
{
	struct uvideo_softc *sc = v;
	caddr_t p;

	if (!sc->sc_mmap_flag)
		sc->sc_mmap_flag = 1;

	p = sc->sc_mmap_buffer + off;

	return (p);
@


1.28
log
@Allocate the video buffer based on the maximum frame size that's reported
by the device instead of using the statically set VIDEO_BUF_SIZE.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.27 2008/06/08 20:11:30 mglocker Exp $ */
d104 1
d155 1
d193 2
a194 1
	uvideo_get_bufsize	/* read */
d267 1
a267 1
	//uvideo_vs_start(sc);
d1220 7
a1226 10
#if 0
			/*
			 * Copy video frame to upper layer buffer and call
			 * upper layer interrupt.
			 */
			*sc->sc_uplayer_fsize = fb->offset;
			bcopy(fb->buf, sc->sc_uplayer_fbuffer, fb->offset);
			sc->sc_uplayer_intr(sc->sc_uplayer_arg);
#endif
			uvideo_mmap_queue(sc, fb->buf, fb->offset);
d1275 14
d1956 11
d1972 3
@


1.27
log
@If we have reached the end of the mmap frame buffer, start over again
(ring buffer).  Add some more DPRINTFs to follow the queueing.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.26 2008/06/08 00:18:33 robert Exp $ */
d150 5
d190 2
a191 1
	uvideo_mappage		/* mmap */
d894 2
d906 1
a906 1
	    UGETDW(pc->dwMaxVideoFrameSize));
d947 1
a947 1
	if (VIDEO_BUF_SIZE < fb->buf_size) {
d1932 8
@


1.26
log
@decrease the buffer count after dequeueing a buffer
to prevent the mmap buffer filling up, and
disable the debug code that dumps the stream to a file
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.25 2008/06/07 22:14:57 mglocker Exp $ */
d1246 1
a1246 1
	/* copy frame to mmap buffer */
d1248 1
d1253 2
d1258 3
d1872 3
d1900 2
a1902 1
	sc->sc_mmap_cur--;
@


1.25
log
@Start to queue mmap frames.  Add VIDIOC_QBUF, VIDIOC_DQBUF,
VIDIOC_STREAMON for that purpose, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.24 2008/06/06 19:14:45 mglocker Exp $ */
d48 1
d253 1
a253 1
#ifdef UVIDEO_DEBUG
d278 1
a278 1
#ifdef UVIDEO_DEBUG
d1204 1
a1204 1
#ifdef UVIDEO_DEBUG
d1892 1
@


1.24
log
@Arrange our mmap buffer struct better.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.23 2008/06/05 20:50:28 mglocker Exp $ */
d102 1
d143 3
d180 3
a182 1
	NULL,			/* VIDIOC_DQBUF */
d257 1
a257 1
	uvideo_vs_start(sc);
d338 5
d1208 1
d1216 2
d1231 29
d1787 1
a1787 1
	int i, buf_count, buf_size, buf_size_total;
d1793 1
a1793 1
		buf_count = UVIDEO_MAX_BUFFERS;
d1795 1
a1795 1
		buf_count = rb->count;
d1799 1
a1799 1
	buf_size_total = buf_count * buf_size;
d1810 1
a1810 1
	for (i = 0; i < buf_count; i++) {
d1830 1
a1830 1
	rb->count = buf_count;
d1852 49
@


1.23
log
@Add some first mmap bits.

Help by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.22 2008/05/30 06:37:38 mglocker Exp $ */
d1758 2
a1759 2
	sc->sc_mmap_buffer.buf = malloc(buf_size_total, M_DEVBUF, M_NOWAIT);
	if (sc->sc_mmap_buffer.buf == NULL) {
d1768 11
a1778 9
		sc->sc_mmap_buffer.v4l2_buf[i].index = i;
		sc->sc_mmap_buffer.v4l2_buf[i].m.offset = i * buf_size;
		sc->sc_mmap_buffer.v4l2_buf[i].length = buf_size;
		sc->sc_mmap_buffer.v4l2_buf[i].type =
		    V4L2_BUF_TYPE_VIDEO_CAPTURE;
		sc->sc_mmap_buffer.v4l2_buf[i].sequence = 0;
		sc->sc_mmap_buffer.v4l2_buf[i].field = V4L2_FIELD_NONE;
		sc->sc_mmap_buffer.v4l2_buf[i].memory = V4L2_MEMORY_MMAP;
		sc->sc_mmap_buffer.v4l2_buf[i].flags = V4L2_MEMORY_MMAP;
d1781 3
a1783 3
		    sc->sc_mmap_buffer.v4l2_buf[i].index,
		    sc->sc_mmap_buffer.v4l2_buf[i].m.offset,
		    sc->sc_mmap_buffer.v4l2_buf[i].length);
d1801 1
a1801 1
	bcopy(&sc->sc_mmap_buffer.v4l2_buf[qb->index], qb,
d1828 1
a1828 1
	p = sc->sc_mmap_buffer.buf + off;
@


1.22
log
@Allocate static buffer for software frame buffer and make sure to not
overflow it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.21 2008/05/27 18:19:37 mglocker Exp $ */
d37 1
a137 1
int		uvideo_reqbufs(void *, struct v4l2_requestbuffers *);
d140 2
d143 1
a171 1
	uvideo_reqbufs,		/* VIDIOC_REQBUFS */
d174 2
a175 1
	NULL,			/* VIDIOC_QBUF */
d177 2
a178 1
	uvideo_try_fmt		/* VIDIOC_TRY_FMT */
a1717 6
uvideo_reqbufs(void *v, struct v4l2_requestbuffers *rb)
{
	return (0);
}

int
d1741 71
d1818 11
@


1.21
log
@Don't fail to compile when not in debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.20 2008/05/27 17:47:28 mglocker Exp $ */
d921 6
@


1.20
log
@Instead alloacting a fix frame buffer we allocate the maximum frame size
delivered by the device (dwMaxVideoFrameSize).  Also check for too large
frames (buffer overflow),  they get skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.19 2008/05/26 17:51:18 mglocker Exp $ */
a215 1
	int r;
d243 1
a243 2
	r = uvideo_debug_file_open(sc);
	if (r != 0)
@


1.19
log
@Add more ioctl's (still unfinished);  VIDIOC_ENUM_FMT, VIDIOC_ENUMINPUT,
VIDIOC_S_INPUT, VIDIOC_TRY_FMT.  Allows me at least to use a small V4L2
compatible webcam application to capture some images.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.18 2008/05/25 07:47:47 mglocker Exp $ */
d922 1
a922 1
	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);
d924 1
a924 1
	fb->buf = malloc(32000, M_DEVBUF, M_NOWAIT); /* XXX find proper size */
d930 3
d1173 4
a1176 2
	bcopy(frame + header_len, fb->buf + fb->offset, fragment_len);
	fb->offset += fragment_len;
d1182 2
d1185 3
a1187 3
		/* do the file write in process context */
		usb_rem_task(sc->sc_udev, &sc->sc_task_write);
		usb_add_task(sc->sc_udev, &sc->sc_task_write);
d1189 11
a1199 8
		/*
		 * Copy video frame to upper layer buffer and call
		 * upper layer interrupt.
		 */
		bzero(sc->sc_uplayer_fbuffer, 32000);
		*sc->sc_uplayer_fsize = fb->offset;
		bcopy(fb->buf, sc->sc_uplayer_fbuffer, fb->offset);
		sc->sc_uplayer_intr(sc->sc_uplayer_arg);
d1203 1
a1203 1
//		fb->offset = 0;
d1690 2
d1695 1
a1695 1
	fmt->fmt.pix.sizeimage = 32000;
@


1.18
log
@Spacing.  Comments.  strncpy() -> strlcpy().
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.17 2008/05/24 19:37:34 mglocker Exp $ */
d134 1
d138 3
d166 1
d170 2
d173 2
a174 1
	NULL			/* VIDIOC_DQBUF */
d1649 29
d1683 2
d1700 32
@


1.17
log
@- Enable userland to read(2) video stream from /dev/video.
- Prepare for mmap(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.16 2008/05/18 09:35:35 mglocker Exp $ */
d100 1
a100 2
		    uint8_t *, int);

d130 3
d1618 3
d1622 1
a1622 1
uvideo_querycap(void *v, struct v4l2_capability * caps)
d1627 4
a1630 5
	strlcpy(caps->driver, DEVNAME(sc),
		sizeof(caps->driver));
	strncpy(caps->card, "Generic USB video class device",
		sizeof(caps->card));
	strncpy(caps->bus_info, "usb", sizeof(caps->bus_info));
d1634 2
a1635 2
		| V4L2_CAP_STREAMING
		| V4L2_CAP_READWRITE;
d1641 1
a1641 1
uvideo_s_fmt(void *v, struct v4l2_format * fmt)
d1650 1
a1650 1
uvideo_g_fmt(void *v, struct v4l2_format * fmt)
d1659 1
a1659 1
uvideo_reqbufs(void *v, struct v4l2_requestbuffers * rb)
@


1.16
log
@Move the code which starts the video stream to the right place;
The video stream gets started/stopped when userland open/closes
/dev/video*.  The debug file gets written to /tmp/uvideo.mjpeg now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.15 2008/05/18 07:20:09 mglocker Exp $ */
d57 2
a58 1
int		uvideo_open(void *, int);
d201 2
a202 1
uvideo_open(void *addr, int flags)
d213 6
d1172 9
@


1.15
log
@There is no need to pass uvideo_vs_open() usb_attach_arg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.14 2008/05/16 12:01:51 mglocker Exp $ */
d92 1
d94 1
d203 2
d206 1
a206 1
	DPRINTF(1, "uvideo_open: sc=%p\n", sc);
d211 22
a236 1

a238 1
#if 0
d241 12
a252 1
	DPRINTF(1, "uvideo_close: sc=%p\n", sc);
a311 20
	/* open video stream pipe */
	error = uvideo_vs_open(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* allocate video stream xfer buffer */
	error = uvideo_vs_alloc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* allocate video stream sample buffer */
	error = uvideo_vs_alloc_sample(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;
#ifdef UVIDEO_DEBUG
	uvideo_debug_file_open(sc);
	usb_init_task(&sc->sc_task_write, uvideo_debug_file_write_sample, sc);
#endif
	uvideo_vs_start(sc);

d958 16
d1024 10
d1554 1
a1554 1
	char name[] = "/uvideo.mjpeg";
d1560 2
@


1.14
log
@Free sample buffer on detach.  Noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.13 2008/05/16 08:01:39 mglocker Exp $ */
d81 2
a82 2
int		uvideo_vs_set_alt(struct uvideo_softc *,
		    struct usb_attach_arg *, int, int);
d92 1
a92 1
usbd_status	uvideo_vs_open(struct uvideo_softc *, struct usb_attach_arg *);
d278 1
a278 1
	error = uvideo_vs_open(sc, uaa);
d658 2
a659 2
uvideo_vs_set_alt(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
    int iface, int max_packet_size)
d667 1
a667 1
		error = usbd_set_interface(uaa->ifaces[iface], i);
d674 1
a674 1
		id = usbd_get_interface_descriptor(uaa->ifaces[iface]);
d678 1
a678 1
		ed = usbd_interface2endpoint_descriptor(uaa->ifaces[iface], 0);
d944 1
a944 1
uvideo_vs_open(struct uvideo_softc *sc, struct usb_attach_arg *uaa)
d951 1
a951 1
	error = uvideo_vs_set_alt(sc, uaa, sc->sc_vs_curr->iface,
@


1.13
log
@Fix kernel crash when device gets detached.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.12 2008/05/15 07:50:41 mglocker Exp $ */
d90 1
d312 2
d891 1
a891 1
	fb->buf = malloc(32000, M_TEMP, M_NOWAIT); /* XXX find proper size */
d902 11
@


1.12
log
@#ifdef UVIDEO_DEBUG wrap all debug routines.  Shrinks the kernel.  Noted
by miod@@.  Fix some spacing while there.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.11 2008/04/20 09:14:05 mglocker Exp $ */
d308 2
a309 1
	sc->sc_dying = 1;
d984 3
@


1.11
log
@Parse VS_INPUT_HEADER descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.10 2008/04/19 11:24:23 mglocker Exp $ */
d98 1
d125 1
d305 2
a306 2
	struct uvideo_softc *sc = (struct uvideo_softc *) self;
	int             rv = 0;
d1113 1
d1536 1
@


1.10
log
@Sort functions and remove obsolete bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.9 2008/04/18 21:19:15 mglocker Exp $ */
d71 2
d370 1
a370 1
		/* TODO which VC descriptors do we need else? */
d408 2
d419 21
a439 1
	/* TODO: loop through general VS descriptors */
d478 20
d723 1
a723 1
	if (desc->bLength == size_total)
@


1.9
log
@Add VS_INPUT_HEADER descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.8 2008/04/18 13:49:55 mglocker Exp $ */
a56 1

d60 5
d71 6
a78 2


d81 1
a81 7
int		uvideo_vs_parse_format_desc(struct uvideo_softc *);
int		uvideo_vs_parse_format_desc_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);

int		uvideo_vs_parse_frame_desc(struct uvideo_softc *);
int		uvideo_vs_parse_frame_desc_mjpeg(struct uvideo_softc *,
		    const usb_descriptor_t *);
d83 4
a92 5
usbd_status	uvideo_vs_negotation(struct uvideo_softc *);
usbd_status	uvideo_vs_set_probe(struct uvideo_softc *, uint8_t *);
usbd_status	uvideo_vs_get_probe(struct uvideo_softc *, uint8_t *);
usbd_status	uvideo_vs_set_commit(struct uvideo_softc *, uint8_t *);

d119 1
a119 3

int		uvideo_desc_len(const usb_descriptor_t *, int, int, int, int);

a122 7
void		uvideo_hexdump(void *, int);

int             uvideo_match(struct device *, void *, void *);
void            uvideo_attach(struct device *, struct device *, void *);
int             uvideo_detach(struct device *, int);
int             uvideo_activate(struct device *, enum devact);

d160 58
a261 10
	/* parse video stream format descriptors */
	error = uvideo_vs_parse_format_desc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

	/* parse video stream frame descriptors */
	error = uvideo_vs_parse_frame_desc(sc);
	if (error != USBD_NORMAL_COMPLETION)
		return;

a285 1

d331 1
a335 58
uvideo_enable(void *v)
{
	struct uvideo_softc *sc = v;

	DPRINTF(1, "%s: uvideo_enable sc=%p\n", DEVNAME(sc), sc);

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_enabled)
		return (EBUSY);


	sc->sc_enabled = 1;

	return (0);
}

void
uvideo_disable(void *v)
{
	struct uvideo_softc *sc = v;

	DPRINTF(1, "%s: uvideo_disable sc=%p\n", DEVNAME(sc), sc);

	if (!sc->sc_enabled) {
		printf("uvideo_disable: already disabled!\n");
		return;
	}
	sc->sc_enabled = 0;
}

int
uvideo_open(void *addr, int flags)
{
	struct uvideo_softc *sc = addr;

	DPRINTF(1, "uvideo_open: sc=%p\n", sc);

	if (sc->sc_dying)
		return (EIO);

	return (0);
}

int
uvideo_close(void *addr)
{
#if 0
	struct uvideo_softc *sc = addr;

	DPRINTF(1, "uvideo_close: sc=%p\n", sc);
#endif

	return (0);
}

int
d408 1
d415 12
d454 1
a454 2
uvideo_vs_parse_desc_alt(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
    int vs_nr, int iface, int numalts)
d456 2
a457 5
	struct uvideo_vs_iface *vs;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int i;
	usbd_status error;
d459 1
a459 1
	vs = &sc->sc_vs_coll[vs_nr];
d461 5
a465 18
	for (i = 0; i < numalts; i++) {
		error = usbd_set_interface(uaa->ifaces[iface], i);
		if (error) {
			printf("%s: could not set alternate interface %d!\n",
			    DEVNAME(sc), i);
			return (USBD_INVAL);
		}

		id = usbd_get_interface_descriptor(uaa->ifaces[iface]);
		if (id == NULL)
			continue;

		DPRINTF(1, "%s: bAlternateSetting=0x%02x, ",
		    DEVNAME(sc), id->bAlternateSetting);

		ed = usbd_interface2endpoint_descriptor(uaa->ifaces[iface], 0);
		if (ed == NULL) {
			DPRINTF(1, "no endpoint descriptor\n");
d469 6
a474 10
		DPRINTF(1, "bEndpointAddress=0x%02x, ", ed->bEndpointAddress);
		DPRINTF(1, "wMaxPacketSize=%d\n", UGETW(ed->wMaxPacketSize));

		if (UGETW(ed->wMaxPacketSize) > vs->max_packet_size) {
			vs->ifaceh = uaa->ifaces[iface];
			vs->endpoint = ed->bEndpointAddress;
			vs->numalts = numalts;
			vs->curalt = id->bAlternateSetting;
			vs->max_packet_size = UGETW(ed->wMaxPacketSize);
			vs->iface = iface;
a475 1
	}
d477 1
a477 6
	/* set back first alternate, otherwise negotation can fail */
	error = usbd_set_interface(uaa->ifaces[iface], 0);
	if (error) {
		printf("%s: could not set alternate interface 0!\n",
		    DEVNAME(sc));
		return (USBD_INVAL);
d480 1
a480 1
	return (USBD_NORMAL_COMPLETION);
d484 2
a485 2
uvideo_vs_set_alt(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
    int iface, int max_packet_size)
d487 3
a489 4
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int i;
	usbd_status error;
d491 5
a495 7
	for (i = 0; i < sc->sc_vs_curr->numalts; i++) {
		error = usbd_set_interface(uaa->ifaces[iface], i);
		if (error) {
			printf("%s: could not set alternate interface %d!\n",
			    DEVNAME(sc), i);
			return (USBD_INVAL);
		}
d497 1
a497 3
		id = usbd_get_interface_descriptor(uaa->ifaces[iface]);
		if (id == NULL)
			continue;
d499 1
a499 19
		ed = usbd_interface2endpoint_descriptor(uaa->ifaces[iface], 0);
		if (ed == NULL)
			continue;

		if (UGETW(ed->wMaxPacketSize) == max_packet_size) {
			sc->sc_vs_curr->endpoint = ed->bEndpointAddress;
			sc->sc_vs_curr->curalt = id->bAlternateSetting;
			sc->sc_vs_curr->max_packet_size =
			    UGETW(ed->wMaxPacketSize);

			DPRINTF(1, "%s: set alternate iface to ", DEVNAME(sc));
			DPRINTF(1, "bAlternateSetting=0x%02x\n",
			    id->bAlternateSetting);

			return (USBD_NORMAL_COMPLETION);
		}
	}

	return (USBD_INVAL);
d503 1
a503 1
uvideo_vs_parse_format_desc(struct uvideo_softc *sc)
d519 3
a521 4
		case UDESCSUB_VS_FORMAT_MJPEG:
			if (desc->bLength == 11) {
				uvideo_vs_parse_format_desc_mjpeg(sc, desc);
			}
d528 3
a530 1
	return (0);
d534 1
a534 1
uvideo_vs_parse_format_desc_mjpeg(struct uvideo_softc *sc,
d537 1
a537 1
        struct usb_video_format_mjpeg_desc *d;
d539 1
a539 1
        d = (struct usb_video_format_mjpeg_desc *)(uint8_t *)desc;
d541 3
a543 5
        if (d->bNumFrameDescriptors == 0) {
                printf("%s: no MJPEG frame descriptors found!\n",
                    DEVNAME(sc));
                return (-1);
        }
d545 1
a545 1
        sc->sc_desc_format_mjpeg = d;
d551 2
a552 1
uvideo_vs_parse_frame_desc(struct uvideo_softc *sc)
d554 19
a572 2
	usbd_desc_iter_t iter;
	const usb_descriptor_t *desc;
d574 2
a575 1
	DPRINTF(1, "%s: %s\n", DEVNAME(sc), __func__);
d577 3
a579 5
	usb_desc_iter_init(sc->sc_udev, &iter);
	desc = usb_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usb_desc_iter_next(&iter);
d583 10
a592 5
		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_VS_FRAME_MJPEG:
			if (uvideo_vs_parse_frame_desc_mjpeg(sc, desc) == 0)
				return (0);
			break;
d594 1
d596 6
a601 1
		desc = usb_desc_iter_next(&iter);
d604 41
a644 1
	printf("%s: no default frame descriptor found!\n", DEVNAME(sc));
d646 1
a646 1
	return (1);
d649 12
d662 105
a766 2
uvideo_vs_parse_frame_desc_mjpeg(struct uvideo_softc *sc,
    const usb_descriptor_t *desc)
d768 39
a806 1
        struct usb_video_frame_mjpeg_desc *d;
d808 6
a813 1
        d = (struct usb_video_frame_mjpeg_desc *)(uint8_t *)desc;
d815 7
a821 3
	/* choose default frame index */
        if (d->bFrameIndex != sc->sc_desc_format_mjpeg->bDefaultFrameIndex)
                return (1);
d823 7
a829 1
        sc->sc_desc_frame_mjpeg = d;
d831 1
a831 1
        return (0);
d889 1
a889 9
#if 0
	error = usbd_set_interface(sc->sc_vs_curr->ifaceh,
	    sc->sc_vs_curr->curalt);
	if (error != USBD_NORMAL_COMPLETION) {
		printf("%s: could not set alternate interface!\n",
		    DEVNAME(sc));
		return (error);
	}
#endif
d922 5
a926 148
	/* calculate optimal isoc xfer size */
	sc->sc_nframes = UVIDEO_SFRAMES_MAX / sc->sc_vs_curr->max_packet_size;
	if (sc->sc_nframes > UVIDEO_NFRAMES_MAX)
		sc->sc_nframes = UVIDEO_NFRAMES_MAX;
	DPRINTF(1, "%s: nframes=%d\n", DEVNAME(sc), sc->sc_nframes);

	return (USBD_NORMAL_COMPLETION);
}

void
uvideo_vs_start(struct uvideo_softc *sc)
{
	int i;

	DPRINTF(2, "%s: %s\n", DEVNAME(sc), __func__);

	for (i = 0; i < sc->sc_nframes; i++)
		sc->sc_vs_curr->size[i] = sc->sc_vs_curr->max_packet_size;

	bzero(sc->sc_vs_curr->buf,
	    sc->sc_vs_curr->max_packet_size * sc->sc_nframes);

	usbd_setup_isoc_xfer(
	    sc->sc_vs_curr->xfer,
	    sc->sc_vs_curr->pipeh,
	    sc->sc_vs_curr,
	    sc->sc_vs_curr->size,
	    sc->sc_nframes,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK,
	    uvideo_vs_cb);

	(void)usbd_transfer(sc->sc_vs_curr->xfer);
}

void
uvideo_vs_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
{
	struct uvideo_vs_iface *vs = priv;
	struct uvideo_softc *sc = vs->sc;
	int len, i, frame_size;
	uint8_t *frame;

	DPRINTF(2, "%s: %s\n", DEVNAME(sc), __func__);

	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: %s\n", DEVNAME(sc), __func__,
		    usbd_errstr(status));
		return;
        }
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	DPRINTF(2, "%s: *** buffer len = %d\n", DEVNAME(sc), len);
	if (len == 0)
		goto skip;

	for (i = 0; i < sc->sc_nframes; i++) {
		frame = vs->buf + (i * vs->max_packet_size);
		frame_size = vs->size[i];

		if (frame_size == 0)
			/* frame is empty */
			continue;

		uvideo_vs_decode_stream_header(sc, frame, frame_size);
	}

skip:	/* setup new transfer */
	uvideo_vs_start(sc);
}

usbd_status
uvideo_vs_negotation(struct uvideo_softc *sc)
{
	struct usb_video_probe_commit *pc;
	uint8_t probe_data[34];
	usbd_status error;

	/* set probe */
	bzero(probe_data, sizeof(probe_data));
	pc = (struct usb_video_probe_commit *)probe_data;
#if 0
	pc->bFormatIndex = 1;
	pc->bFrameIndex = 1;
#endif
	pc->bFormatIndex = sc->sc_desc_format_mjpeg->bFormatIndex;
	pc->bFrameIndex = sc->sc_desc_format_mjpeg->bDefaultFrameIndex;
	error = uvideo_vs_set_probe(sc, probe_data);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* get probe */
	bzero(probe_data, sizeof(probe_data));
	error = uvideo_vs_get_probe(sc, probe_data);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* commit */
	error = uvideo_vs_set_commit(sc, probe_data);
	if (error != USBD_NORMAL_COMPLETION)
		return (error);

	/* save a copy of probe commit */
	bcopy(pc, &sc->sc_desc_probe, sizeof(sc->sc_desc_probe));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvideo_vs_set_probe(struct uvideo_softc *sc, uint8_t *probe_data)
{
	usb_device_request_t req;
	usbd_status err;
	uint16_t tmp;
	struct usb_video_probe_commit *pc;

	req.bmRequestType = UVIDEO_SET_IF;
	req.bRequest = SET_CUR;
	tmp = VS_PROBE_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	//USETW(req.wIndex, sc->sc_vs_curr->iface);
	USETW(req.wIndex, 1);
	USETW(req.wLength, 26);

	pc = (struct usb_video_probe_commit *)probe_data;

	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
		printf("%s: could not SET probe request: %s\n",
		    DEVNAME(sc), usbd_errstr(err));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: SET probe request successfully\n", DEVNAME(sc));

	DPRINTF(1, "bmHint=0x%02x\n", UGETW(pc->bmHint));
	DPRINTF(1, "bFormatIndex=0x%02x\n", pc->bFormatIndex);
	DPRINTF(1, "bFrameIndex=0x%02x\n", pc->bFrameIndex);
	DPRINTF(1, "dwFrameInterval=%d (ns)\n", UGETDW(pc->dwFrameInterval));
	DPRINTF(1, "wKeyFrameRate=%d\n", UGETW(pc->wKeyFrameRate));
	DPRINTF(1, "wPFrameRate=%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=%d\n", UGETW(pc->wCompQuality));
	DPRINTF(1, "wCompWindowSize=0x%04x\n", UGETW(pc->wCompWindowSize));
	DPRINTF(1, "wDelay=%d (ms)\n", UGETW(pc->wDelay));
	DPRINTF(1, "dwMaxVideoFrameSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxVideoFrameSize));
	DPRINTF(1, "dwMaxPayloadTransferSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxPayloadTransferSize));
d931 2
a932 2
usbd_status
uvideo_vs_get_probe(struct uvideo_softc *sc, uint8_t *probe_data)
d934 1
a934 4
	usb_device_request_t req;
	usbd_status err;
	uint16_t tmp;
	struct usb_video_probe_commit *pc;
d936 1
a936 8
	req.bmRequestType = UVIDEO_GET_IF;
	req.bRequest = GET_CUR;
	tmp = VS_PROBE_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	//USETW(req.wIndex, sc->sc_vs_curr->iface);
	USETW(req.wIndex, 1);
	USETW(req.wLength, 26);
d938 2
a939 1
	pc = (struct usb_video_probe_commit *)probe_data;
d941 2
a942 7
	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
		printf("%s: could not GET probe request: %s\n",
		    DEVNAME(sc), usbd_errstr(err));
		return (USBD_INVAL);
	}
	DPRINTF(1, "%s: GET probe request successfully\n", DEVNAME(sc));
d944 8
a951 13
	DPRINTF(1, "bmHint=0x%02x\n", UGETW(pc->bmHint));
	DPRINTF(1, "bFormatIndex=0x%02x\n", pc->bFormatIndex);
	DPRINTF(1, "bFrameIndex=0x%02x\n", pc->bFrameIndex);
	DPRINTF(1, "dwFrameInterval=%d (ns)\n", UGETDW(pc->dwFrameInterval));
	DPRINTF(1, "wKeyFrameRate=%d\n", UGETW(pc->wKeyFrameRate));
	DPRINTF(1, "wPFrameRate=%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=%d\n", UGETW(pc->wCompQuality));
	DPRINTF(1, "wCompWindowSize=0x%04x\n", UGETW(pc->wCompWindowSize));
	DPRINTF(1, "wDelay=%d (ms)\n", UGETW(pc->wDelay));
	DPRINTF(1, "dwMaxVideoFrameSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxVideoFrameSize));
	DPRINTF(1, "dwMaxPayloadTransferSize=%d (bytes)\n",
	    UGETDW(pc->dwMaxPayloadTransferSize));
d953 1
a953 1
	return (USBD_NORMAL_COMPLETION);
d956 3
a958 2
usbd_status
uvideo_vs_set_commit(struct uvideo_softc *sc, uint8_t *probe_data)
d960 21
a980 3
	usb_device_request_t req;
	usbd_status err;
	uint16_t tmp;
d982 3
a984 8
	req.bmRequestType = UVIDEO_SET_IF;
	req.bRequest = SET_CUR;
	tmp = VS_COMMIT_CONTROL;
	tmp = tmp << 8;
	USETW(req.wValue, tmp);
	//USETW(req.wIndex, sc->sc_vs_curr->iface);
	USETW(req.wIndex, 1);
	USETW(req.wLength, 26);
d986 1
a986 5
	err = usbd_do_request(sc->sc_udev, &req, probe_data);
	if (err) {
		printf("%s: could not SET commit request: %s\n",
		    DEVNAME(sc), usbd_errstr(err));
		return (USBD_INVAL);
a987 1
	DPRINTF(1, "%s: SET commit request successfully\n", DEVNAME(sc));
d989 2
a990 1
	return (USBD_NORMAL_COMPLETION);
a1066 44
int
uvideo_querycap(void *v, struct v4l2_capability * caps)
{
	struct uvideo_softc *sc = v;

	bzero(caps, sizeof(caps));
	strlcpy(caps->driver, DEVNAME(sc),
		sizeof(caps->driver));
	strncpy(caps->card, "Generic USB video class device",
		sizeof(caps->card));
	strncpy(caps->bus_info, "usb", sizeof(caps->bus_info));

	caps->version = 1;
	caps->capabilities = V4L2_CAP_VIDEO_CAPTURE
		| V4L2_CAP_STREAMING
		| V4L2_CAP_READWRITE;

	return (0);
}

int
uvideo_s_fmt(void *v, struct v4l2_format * fmt)
{
	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return (EINVAL);

	return (0);
}

int
uvideo_g_fmt(void *v, struct v4l2_format * fmt)
{
	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
		return (EINVAL);

	return (0);
}

int
uvideo_reqbufs(void *v, struct v4l2_requestbuffers * rb)
{
	return (0);
}

d1428 2
a1429 15
/*
 * Thanks to the retarded USB Video Class specs there are different
 * descriptors types with the same bDescriptorSubtype which makes
 * it necessary to differ between those types by doing descriptor
 * size dances :-(
 *
 * size_fix:		total size of the fixed structure part
 * off_num_elements:	offset which tells the number of following elements
 * size_element:	size of a single element
 * off_size_element:	if size_element is 0 the element size is taken from
 *			this offset in the descriptor 
 */
int
uvideo_desc_len(const usb_descriptor_t *desc,
    int size_fix, int off_num_elements, int size_element, int off_size_element)
d1431 1
a1431 2
	uint8_t *buf;
	int size_elements, size_total;
d1433 8
a1440 15
	if (desc->bLength < size_fix)
		return (0);

	buf = (uint8_t *)desc;

	if (size_element == 0)
		size_element = buf[off_size_element];

	size_elements = buf[off_num_elements] * size_element;
	size_total = size_fix + size_elements;

	if (desc->bLength == size_total)
		return (1);

	return (0);
d1490 31
a1520 2
void
uvideo_hexdump(void *buf, int len)
d1522 5
a1526 1
	int i;
d1528 4
a1531 8
	for (i = 0; i < len; i++) {
		if (i % 16 == 0)
			printf("%s%5i:", i ? "\n" : "", i);
		if (i % 4 == 0)
			printf(" ");
		printf("%02x", (int)*((u_char *)buf + i));
	}
	printf("\n");
@


1.8
log
@Add a function which can identify an USB descriptor explicitly by it's
size, since the UVC spec uses different USB descriptors with the same
bDescriptorSubtype ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.7 2008/04/16 17:18:42 mglocker Exp $ */
d96 3
a98 1
void		uvideo_dump_desc_vcheader(struct uvideo_softc *,
d119 1
a119 1
int		uvideo_desc_len(const usb_descriptor_t *, int, int, int);
d374 1
a374 1
			if (!uvideo_desc_len(desc, 12, 11, 1))
d1111 1
a1111 1
				if (uvideo_desc_len(desc, 12, 11, 1)) {
d1114 7
a1120 1
					uvideo_dump_desc_vcheader(sc, desc);
d1231 1
a1231 1
uvideo_dump_desc_vcheader(struct uvideo_softc *sc,
d1245 22
a1266 1
	//printf("baInterfaceNr=0x%02x\n", d->baInterfaceNr[0]);
d1461 2
d1466 1
a1466 1
    int size_fix, int off_num_elements, int size_element)
d1475 3
@


1.7
log
@Oops, decrease debug log level back to 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.6 2008/04/16 12:19:11 mglocker Exp $ */
d117 1
a117 1
int		uvideo_desc_len(int, int, int);
d358 2
d372 1
a372 2
			/* XXX length can vary, do better calculation */
			if (desc->bLength != 13)
d1109 2
a1110 2
				printf(" (UDESCSUB_VC_HEADER)\n");
				if (desc->bLength == 13) {
d1113 1
d1115 1
d1428 4
d1434 2
a1435 1
uvideo_desc_len(int size_total, int size_fix, int size_var_element)
d1437 2
a1438 1
	int size_var;
d1440 1
a1440 1
	if (size_total < size_fix)
d1443 1
a1443 2
	if (size_total == size_fix)
		return (1);
d1445 2
a1446 2
	if (size_total > size_fix) {
		size_var = size_total - size_fix;
d1448 2
a1449 3
		if (size_var % size_var_element == 0)
			return (1);
	}
@


1.6
log
@Start to make device initialization automatic instead all the static
games.

Tested by robert@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.5 2008/04/12 10:09:12 mglocker Exp $ */
d49 1
a49 1
int uvideo_debug = 2;
@


1.5
log
@Fix some debug output.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.4 2008/04/11 05:37:36 mglocker Exp $ */
d49 1
a49 1
int uvideo_debug = 1;
d61 5
a65 1
int		uvideo_find_vs_if(struct uvideo_softc *,
d67 15
d83 1
a83 1
usbd_status	uvideo_vs_open(struct uvideo_softc *);
d87 4
a90 3
int		uvideo_vs_set_probe(struct uvideo_softc *, uint8_t *);
int		uvideo_vs_get_probe(struct uvideo_softc *, uint8_t *);
int		uvideo_vs_set_probe_commit(struct uvideo_softc *, uint8_t *);
d117 2
d191 1
a191 3
	usbd_status err;
	uint8_t probe_data[34];
	struct uvideo_sample_buffer *fb = &sc->sc_sample_buffer;
d202 1
a202 1

d204 5
d210 3
a212 2
	bzero(probe_data, sizeof(probe_data));
	if (uvideo_vs_set_probe(sc, probe_data))
d214 4
a217 2
	bzero(probe_data, sizeof(probe_data));
	if (uvideo_vs_get_probe(sc, probe_data))
d219 4
a222 1
	if (uvideo_vs_set_probe_commit(sc, probe_data))
d225 4
a228 1
	uvideo_find_vs_if(sc, uaa, cdesc);
d230 3
a232 2
	err = uvideo_vs_alloc(sc);
	if (err != USBD_NORMAL_COMPLETION)
d235 3
a237 2
	err = uvideo_vs_open(sc);
	if (err != USBD_NORMAL_COMPLETION)
d240 4
a243 1
	fb->buf = malloc(32000, M_TEMP, M_NOWAIT);
d245 1
d248 1
a248 1

d342 1
d346 47
d398 21
a418 1
uvideo_find_vs_if(struct uvideo_softc *sc, struct usb_attach_arg *uaa,
d421 39
a459 1
	struct uvideo_stream_if *si = &sc->sc_curr_strm;
d462 4
a465 1
	int i, numalts;
d467 7
a473 1
	printf("%s: nifaces=%d\n", DEVNAME(sc), uaa->nifaces);
d475 2
a476 2
	for (i = 0; i < uaa->nifaces; i++) {
		if (uaa->ifaces[i] == NULL)
d479 6
a484 2
		id = usbd_get_interface_descriptor(uaa->ifaces[i]);
		if (id == NULL)
d486 1
a486 3
		printf("%s: bInterfaceNumber=%d, bAlternateSetting=%d, ",
		    DEVNAME(sc),
		    id->bInterfaceNumber, id->bAlternateSetting);
d488 2
a489 2
		numalts = usbd_get_no_alts(cdesc, id->bInterfaceNumber);
		printf("numalts=%d\n", numalts);
d491 7
a497 3
		if (id->bInterfaceNumber == 1) {	/* XXX baInterfaceNr */
			si->in_ifaceh = uaa->ifaces[i];
			si->numalts = numalts;
d499 9
d509 16
a524 3
		ed = usbd_interface2endpoint_descriptor(uaa->ifaces[i], i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for iface %d\n",
d526 9
d536 12
a548 2
		printf("%s: bEndpointAddress=0x%02x\n",
		    DEVNAME(sc), ed->bEndpointAddress);
d551 25
a575 5
	for (i = 0; i < si->numalts; i++) {
		if (usbd_set_interface(si->in_ifaceh, i)) {
			printf("%s: could not set alt iface %d\n",
			    DEVNAME(sc), i);
			return (1);
d578 38
a615 4
		ed = usbd_interface2endpoint_descriptor(si->in_ifaceh, 0);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for VS iface\n",
			    DEVNAME(sc));
a617 5
		printf("%s: VS iface alt iface bEndpointAddress=0x%02x, "
		    "wMaxPacketSize=%d\n",
		    DEVNAME(sc),
		    ed->bEndpointAddress,
		    UGETW(ed->wMaxPacketSize));
d619 8
a626 1
		si->endpoint = ed->bEndpointAddress;
d629 40
a668 1
	return (0);
d674 1
a674 1
	struct uvideo_stream_if *si = &sc->sc_curr_strm;
d678 1
a678 1
	si->sc = sc;
d680 3
a682 4
	si->xfer = usbd_alloc_xfer(sc->sc_udev);	
	if (si->xfer == NULL) {
		printf("%s: could not allocate VideoStream xfer!\n",
		    DEVNAME(sc));
d686 5
a690 4
	si->buf = usbd_alloc_buffer(si->xfer, 384 * UVIDEO_NFRAMES);
	if (si->buf == NULL) {
		printf("%s: could not allocate VideoStream buffer!\n",
		    DEVNAME(sc));
d693 2
d700 1
a700 1
uvideo_vs_open(struct uvideo_softc *sc)
a701 1
	struct uvideo_stream_if *si = &sc->sc_curr_strm;
d703 1
a703 1
	usbd_status err;
d706 12
a717 3

	err = usbd_set_interface(si->in_ifaceh, 2);
	if (err != 0) {
d720 1
a720 1
		return (err);
d723 1
a723 1
	ed = usbd_interface2endpoint_descriptor(si->in_ifaceh, 0);
d727 1
a727 1
		return (USBD_NOMEM);
d729 2
a730 3
	printf("%s: open pipe for bEndpointAddress=0x%02x (0x%02x), "
	    "wMaxPacketSize=%d\n",
	    DEVNAME(sc),
d732 10
a741 6
	    si->endpoint,
	    UGETW(ed->wMaxPacketSize));

	err = usbd_open_pipe(si->in_ifaceh, si->endpoint, USBD_EXCLUSIVE_USE,
	    &si->in_pipeh);
	if (err) {
d743 2
a744 2
		    DEVNAME(sc), usbd_errstr(err));
		return (err);
d747 6
a758 1
	struct uvideo_stream_if *si = &sc->sc_curr_strm;
d763 2
a764 2
	for (i = 0; i < UVIDEO_NFRAMES; i++)
		si->size[i] = 384;
d766 2
a767 1
	bzero(si->buf, 384 * UVIDEO_NFRAMES);
d770 5
a774 5
	    si->xfer,
	    si->in_pipeh,
	    si,
	    si->size,
	    UVIDEO_NFRAMES,
d778 1
a778 1
	(void)usbd_transfer(si->xfer);
d785 2
a786 2
	struct uvideo_stream_if *sc_curr_strm = priv;
	struct uvideo_softc *sc = sc_curr_strm->sc;
d803 3
a805 3
	for (i = 0; i < UVIDEO_NFRAMES; i++) {
		frame = sc_curr_strm->buf + (i * 384);
		frame_size = sc_curr_strm->size[i];
d818 38
a855 1
int
d868 1
a872 2
	pc->bFormatIndex = 1;
	pc->bFrameIndex = 1;
d876 1
a876 1
		printf("%s: could not send SET request: %s\n",
d878 1
a878 1
		return (-1);
d880 1
a880 3

	DPRINTF(1, "%s: SET probe control request successfully\n",
	    DEVNAME(sc));
d896 1
a896 1
	return (0);
d899 1
a899 1
int
d912 1
d920 1
a920 1
		printf("%s: could not send GET request: %s\n",
d922 1
a922 1
		return (-1);
d924 1
a924 3

	DPRINTF(1, "%s: GET probe control request successfully\n",
	    DEVNAME(sc));
d940 1
a940 1
	return (0);
d943 2
a944 2
int
uvideo_vs_set_probe_commit(struct uvideo_softc *sc, uint8_t *probe_data)
d955 1
d961 1
a961 1
		printf("%s: could not send SET commit request: %s\n",
d963 1
a963 1
		return (-1);
d965 1
d967 1
a967 4
	DPRINTF(1, "%s: SET probe commit request successfully\n",
	    DEVNAME(sc));

	return (0);
d1234 1
a1234 1
	printf("baInterfaceNr=0x%02x\n", d->baInterfaceNr);
d1303 1
a1303 1
	printf("wMaxPacketsize=%d\n", UGETW(d->wMaxPacketSize));
d1336 1
a1336 1
	printf("wTotalLength=0x%02x\n", d->wTotalLength);
d1379 1
a1379 1
	struct usb_video_frame_descriptor *d;
d1381 1
a1381 1
	d = (struct usb_video_frame_descriptor *)(uint8_t *)desc;
d1403 1
a1403 1
	struct usb_video_format_mjpeg_descriptor *d;
d1405 1
a1405 1
	d = (struct usb_video_format_mjpeg_descriptor *)(uint8_t *)desc;
d1418 27
@


1.4
log
@Correctly initialize the probe sequence buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.3 2008/04/10 09:22:15 mglocker Exp $ */
a518 1
	//USETW(pc->bmHint, 1);
d537 2
a538 2
	DPRINTF(1, "wPFrameRate=0x%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=0x%d\n", UGETW(pc->wCompQuality));
d582 2
a583 2
	DPRINTF(1, "wPFrameRate=0x%d\n", UGETW(pc->wPFrameRate));
	DPRINTF(1, "wCompQuality=0x%d\n", UGETW(pc->wCompQuality));
a644 1

@


1.3
log
@Fix MJPEG Video Frame Descriptor struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.c,v 1.2 2008/04/09 20:38:55 mglocker Exp $ */
d169 1
a169 1
	usbd_status     err;
d185 1
d188 1
a517 1
	bzero(probe_data, sizeof(probe_data));
a518 1
	USETW(pc->bmHint, 8);
d533 14
a565 1
	bzero(probe_data, sizeof(probe_data));
@


1.2
log
@Add OpenBSD cvs id.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1029 5
a1033 4
	printf("wWidth=0x%d\n", UGETW(d->wWidth));
	printf("wHeight=0x%d\n", UGETW(d->wHeight));
	printf("dwMinBitRate=0x%08x\n", UGETDW(d->dwMaxBitRate));
	printf("dwMaxVideoFrameBufferSize=0x%08x\n",
d1035 1
a1035 1
	printf("dwDefaultFrameInterval=0x%d\n",
@


1.1
log
@Initial import for uvideo(4) and video(4):

uvideo(4) is a driver for USB video device class devices including webcams,
camcorders and other cameras.

video(4) is a device-independent layer that implements the V4L2 (Video for Linux Two)
API.

These drivers are *really* work in progress so don't even try to use them just yet,
because the driver still has some issues, even if it can be used to capture simple
MJPEG videos.

ok mglocker@@, deraadt@@
@
text
@d1 2
@

