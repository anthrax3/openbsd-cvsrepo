head	1.58;
access;
symbols
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.41.0.4
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.2
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.2
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.10
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.6
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.20
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.58
date	2017.03.29.00.18.51;	author jsg;	state Exp;
branches;
next	1.57;
commitid	2wnbo81sCyJadOCX;

1.57
date	2016.06.19.22.13.07;	author kettenis;	state Exp;
branches;
next	1.56;
commitid	t6iswU05g187ICnQ;

1.56
date	2016.06.15.19.39.34;	author gerhard;	state Exp;
branches;
next	1.55;
commitid	qJ1QnDnimibODQ30;

1.55
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches;
next	1.54;
commitid	zkpZsVIWMnE2TPgn;

1.54
date	2016.02.28.17.57.50;	author stefan;	state Exp;
branches;
next	1.53;
commitid	v9vYvlfXVHFOePGU;

1.53
date	2015.07.09.05.40.44;	author mpi;	state Exp;
branches;
next	1.52;
commitid	ya04ucVzCGuM1n2l;

1.52
date	2015.06.29.10.52.40;	author mpi;	state Exp;
branches;
next	1.51;
commitid	edRm3cRbjSJzUDvV;

1.51
date	2015.06.22.10.29.18;	author mpi;	state Exp;
branches;
next	1.50;
commitid	rkuRtn1rvEZDAwYu;

1.50
date	2015.02.14.06.18.58;	author uebayasi;	state Exp;
branches;
next	1.49;
commitid	41gTSdOhRJ8D25qH;

1.49
date	2014.11.07.13.56.29;	author mpi;	state Exp;
branches;
next	1.48;
commitid	gYNQMCaIWvIlAGBb;

1.48
date	2014.11.01.14.04.27;	author mpi;	state Exp;
branches;
next	1.47;
commitid	ZelxqVa5DHXCt9BA;

1.47
date	2014.08.08.14.20.05;	author mpi;	state Exp;
branches;
next	1.46;
commitid	HPvxK5z15RUEsAkp;

1.46
date	2014.03.08.11.47.26;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2014.01.20.17.23.17;	author jcs;	state Exp;
branches;
next	1.44;

1.44
date	2013.04.17.11.53.10;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.08.10.34.20;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.16.09.58.40;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2012.06.20.10.51.27;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2012.06.10.10.20.02;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.08.13.12.38;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.11.09.21.45.50;	author sthen;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.04.23.55.32;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.15.23.58.43;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.01.23.35.56;	author mk;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.09.03.08.07;	author yuo;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.09.22.59.20;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2007.11.28.16.50.22;	author robert;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.27.09.16.09;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.17.07.53.11;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.09.11.06.53;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.12.18.12.55;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.23.19.25.07;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.17.06.07.57;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.11.03.47.29;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.10.04.22.55.56;	author gluk;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.04.11.44.24;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.04.22.52.30;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Match on class communications subclass abstract control model protocol
0 "No class specific protocol required" in addition to the existing
protocol 1 "AT Commands: V.250 etc" match.

This lets umodem(4) attach to the serial console on the overdrive 1000
which is a usb type-b socket on the back of the box not a db9 like the
overdrive 3000.
@
text
@/*	$OpenBSD: usb.h,v 1.57 2016/06/19 22:13:07 kettenis Exp $ */
/*	$NetBSD: usb.h,v 1.69 2002/09/22 23:20:50 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.h,v 1.14 1999/11/17 22:33:46 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#ifndef _USB_H_
#define _USB_H_

#include <sys/types.h>
#include <sys/time.h>

#include <sys/ioctl.h>

#define USB_STACK_VERSION 2

#define USB_MAX_DEVICES 128
#define USB_START_ADDR 0

#define USB_CONTROL_ENDPOINT 0
#define USB_MAX_ENDPOINTS 16

#define USB_FRAMES_PER_SECOND 1000

/*
 * The USB records contain some unaligned little-endian word
 * components.  The U[SG]ETW macros take care of both the alignment
 * and endian problem and should always be used to access non-byte
 * values.
 */
typedef u_int8_t uByte;
typedef u_int8_t uWord[2];
typedef u_int8_t uDWord[4];

#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))

#if defined(__STRICT_ALIGNMENT) || _BYTE_ORDER != _LITTLE_ENDIAN
#define UGETW(w) ((w)[0] | ((w)[1] << 8))
#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
		     (w)[1] = (u_int8_t)((v) >> 8), \
		     (w)[2] = (u_int8_t)((v) >> 16), \
		     (w)[3] = (u_int8_t)((v) >> 24))
#else
/*
 * On little-endian machines that can handle unaligned accesses
 * (e.g. i386) these macros can be replaced by the following.
 */
#define UGETW(w) (*(u_int16_t *)(w))
#define USETW(w,v) (*(u_int16_t *)(w) = (v))
#define UGETDW(w) (*(u_int32_t *)(w))
#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
#endif

struct usb_device_request {
	uByte		bmRequestType;
	uByte		bRequest;
	uWord		wValue;
	uWord		wIndex;
	uWord		wLength;
} __packed;
typedef struct usb_device_request usb_device_request_t;

#define UT_WRITE		0x00
#define UT_READ			0x80
#define UT_STANDARD		0x00
#define UT_CLASS		0x20
#define UT_VENDOR		0x40
#define UT_DEVICE		0x00
#define UT_INTERFACE		0x01
#define UT_ENDPOINT		0x02
#define UT_OTHER		0x03

#define UT_READ_DEVICE		(UT_READ  | UT_STANDARD | UT_DEVICE)
#define UT_READ_INTERFACE	(UT_READ  | UT_STANDARD | UT_INTERFACE)
#define UT_READ_ENDPOINT	(UT_READ  | UT_STANDARD | UT_ENDPOINT)
#define UT_WRITE_DEVICE		(UT_WRITE | UT_STANDARD | UT_DEVICE)
#define UT_WRITE_INTERFACE	(UT_WRITE | UT_STANDARD | UT_INTERFACE)
#define UT_WRITE_ENDPOINT	(UT_WRITE | UT_STANDARD | UT_ENDPOINT)
#define UT_READ_CLASS_DEVICE	(UT_READ  | UT_CLASS | UT_DEVICE)
#define UT_READ_CLASS_INTERFACE	(UT_READ  | UT_CLASS | UT_INTERFACE)
#define UT_READ_CLASS_OTHER	(UT_READ  | UT_CLASS | UT_OTHER)
#define UT_READ_CLASS_ENDPOINT	(UT_READ  | UT_CLASS | UT_ENDPOINT)
#define UT_WRITE_CLASS_DEVICE	(UT_WRITE | UT_CLASS | UT_DEVICE)
#define UT_WRITE_CLASS_INTERFACE (UT_WRITE | UT_CLASS | UT_INTERFACE)
#define UT_WRITE_CLASS_OTHER	(UT_WRITE | UT_CLASS | UT_OTHER)
#define UT_WRITE_CLASS_ENDPOINT	(UT_WRITE | UT_CLASS | UT_ENDPOINT)
#define UT_READ_VENDOR_DEVICE	(UT_READ  | UT_VENDOR | UT_DEVICE)
#define UT_READ_VENDOR_INTERFACE (UT_READ  | UT_VENDOR | UT_INTERFACE)
#define UT_READ_VENDOR_OTHER	(UT_READ  | UT_VENDOR | UT_OTHER)
#define UT_READ_VENDOR_ENDPOINT	(UT_READ  | UT_VENDOR | UT_ENDPOINT)
#define UT_WRITE_VENDOR_DEVICE	(UT_WRITE | UT_VENDOR | UT_DEVICE)
#define UT_WRITE_VENDOR_INTERFACE (UT_WRITE | UT_VENDOR | UT_INTERFACE)
#define UT_WRITE_VENDOR_OTHER	(UT_WRITE | UT_VENDOR | UT_OTHER)
#define UT_WRITE_VENDOR_ENDPOINT (UT_WRITE | UT_VENDOR | UT_ENDPOINT)

/* Requests */
#define UR_GET_STATUS		0x00
#define UR_CLEAR_FEATURE	0x01
#define UR_SET_FEATURE		0x03
#define UR_SET_ADDRESS		0x05
#define UR_GET_DESCRIPTOR	0x06
#define  UDESC_DEVICE		0x01
#define  UDESC_CONFIG		0x02
#define  UDESC_STRING		0x03
#define  UDESC_INTERFACE	0x04
#define  UDESC_ENDPOINT		0x05
#define  UDESC_DEVICE_QUALIFIER	0x06
#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
#define  UDESC_INTERFACE_POWER	0x08
#define  UDESC_OTG		0x09
#define  UDESC_DEBUG		0x0A
#define  UDESC_IFACE_ASSOC	0x0B	/* interface association */
#define  UDESC_BOS		0x0F	/* binary object store */
#define  UDESC_DEVICE_CAPABILITY	0x10
#define  UDESC_CS_DEVICE	0x21	/* class specific */
#define  UDESC_CS_CONFIG	0x22
#define  UDESC_CS_STRING	0x23
#define  UDESC_CS_INTERFACE	0x24
#define  UDESC_CS_ENDPOINT	0x25
#define  UDESC_HUB		0x29
#define  UDESC_SS_HUB		0x2A	/* super speed */
#define  UDESC_ENDPOINT_SS_COMP	0x30	/* super speed */
#define UR_SET_DESCRIPTOR	0x07
#define UR_GET_CONFIG		0x08
#define UR_SET_CONFIG		0x09
#define UR_GET_INTERFACE	0x0a
#define UR_SET_INTERFACE	0x0b
#define UR_SYNCH_FRAME		0x0c

/* Feature numbers */
#define UF_ENDPOINT_HALT	0
#define UF_DEVICE_REMOTE_WAKEUP	1
#define UF_TEST_MODE		2

#define USB_MAX_IPACKET		8 /* maximum size of the initial packet */

#define USB_2_MAX_CTRL_PACKET  64
#define USB_2_MAX_BULK_PACKET  512

struct usb_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bDescriptorSubtype;
} __packed;
typedef struct usb_descriptor usb_descriptor_t;

struct usb_device_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize;
	/* The fields below are not part of the initial descriptor. */
	uWord		idVendor;
	uWord		idProduct;
	uWord		bcdDevice;
	uByte		iManufacturer;
	uByte		iProduct;
	uByte		iSerialNumber;
	uByte		bNumConfigurations;
} __packed;
typedef struct usb_device_descriptor usb_device_descriptor_t;
#define USB_DEVICE_DESCRIPTOR_SIZE 18

struct usb_config_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		wTotalLength;
	uByte		bNumInterface;
	uByte		bConfigurationValue;
	uByte		iConfiguration;
	uByte		bmAttributes;
#define UC_BUS_POWERED		0x80
#define UC_SELF_POWERED		0x40
#define UC_REMOTE_WAKEUP	0x20
	uByte		bMaxPower; /* max current in 2 mA units */
#define UC_POWER_FACTOR 2
} __packed;
typedef struct usb_config_descriptor usb_config_descriptor_t;
#define USB_CONFIG_DESCRIPTOR_SIZE 9

struct usb_interface_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bInterfaceNumber;
	uByte		bAlternateSetting;
	uByte		bNumEndpoints;
	uByte		bInterfaceClass;
	uByte		bInterfaceSubClass;
	uByte		bInterfaceProtocol;
	uByte		iInterface;
} __packed;
typedef struct usb_interface_descriptor usb_interface_descriptor_t;
#define USB_INTERFACE_DESCRIPTOR_SIZE 9

struct usb_interface_assoc_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bFirstInterface;
	uByte		bInterfaceCount;
	uByte		bFunctionClass;
	uByte		bFunctionSubClass;
	uByte		bFunctionProtocol;
	uByte		iFunction;
} __packed;
typedef struct usb_interface_assoc_descriptor usb_interface_assoc_descriptor_t;
#define USB_INTERFACE_ASSOC_DESCRIPTOR_SIZE 8

struct usb_endpoint_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bEndpointAddress;
#define UE_GET_DIR(a)	((a) & 0x80)
#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
#define UE_DIR_IN	0x80
#define UE_DIR_OUT	0x00
#define UE_ADDR		0x0f
#define UE_GET_ADDR(a)	((a) & UE_ADDR)
	uByte		bmAttributes;
#define UE_XFERTYPE	0x03
#define  UE_CONTROL	0x00
#define  UE_ISOCHRONOUS	0x01
#define  UE_BULK	0x02
#define  UE_INTERRUPT	0x03
#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
#define UE_ISO_TYPE	0x0c
#define  UE_ISO_ASYNC	0x04
#define  UE_ISO_ADAPT	0x08
#define  UE_ISO_SYNC	0x0c
#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
	uWord		wMaxPacketSize;
#define UE_GET_TRANS(a)	(((a) >> 11) & 0x3)
#define UE_GET_SIZE(a)	((a) & 0x7ff)
	uByte		bInterval;
} __packed;
typedef struct usb_endpoint_descriptor usb_endpoint_descriptor_t;
#define USB_ENDPOINT_DESCRIPTOR_SIZE 7

struct usb_endpoint_ss_comp_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bMaxBurst;
	uByte		bmAttributes;
	uWord		wBytesPerInterval;
} __packed;
typedef struct usb_endpoint_ss_comp_descriptor
		usb_endpoint_ss_comp_descriptor_t;
#define USB_ENDPOINT_SS_COMP_DESCRIPTOR_SIZE 6

/*
 * Note: The length of the USB string descriptor is stored in a one byte
 * value and can therefore be no longer than 255 bytes.  Two bytes are
 * used for the length itself and the descriptor type, a theoretical maximum
 * of 253 bytes is left for the actual string data.  Since the strings are
 * encoded as 2-byte unicode characters, only 252 bytes or 126 two-byte
 * characters can be used.  USB_MAX_STRING_LEN is defined as 127, leaving
 * space for the terminal '\0' character in C strings.
 */
struct usb_string_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bString[126];
} __packed;
typedef struct usb_string_descriptor usb_string_descriptor_t;
#define USB_MAX_STRING_LEN 127
#define USB_LANGUAGE_TABLE 0	/* # of the string language id table */

/* Hub specific request */
#define UR_GET_BUS_STATE	0x02
#define UR_CLEAR_TT_BUFFER	0x08
#define UR_RESET_TT		0x09
#define UR_GET_TT_STATE		0x0a
#define UR_STOP_TT		0x0b
#define UR_SET_DEPTH		0x0c

/* Hub features */
#define UHF_C_HUB_LOCAL_POWER	0
#define UHF_C_HUB_OVER_CURRENT	1

/* Port feature */
#define UHF_PORT_CONNECTION		0
#define UHF_PORT_ENABLE			1
#define UHF_PORT_SUSPEND		2
#define UHF_PORT_OVER_CURRENT		3
#define UHF_PORT_RESET			4
#define UHF_PORT_POWER			8
#define UHF_PORT_LOW_SPEED		9
#define UHF_C_PORT_CONNECTION		16
#define UHF_C_PORT_ENABLE		17
#define UHF_C_PORT_SUSPEND		18
#define UHF_C_PORT_OVER_CURRENT		19
#define UHF_C_PORT_RESET		20
#define UHF_PORT_TEST			21
#define UHF_PORT_INDICATOR		22
#define UHF_C_PORT_L1			23
#define UHF_PORT_DISOWN_TO_1_1		30

/* Super-Speed Port feature */
#define UHF_PORT_U1_TIMEOUT		23
#define UHF_PORT_U2_TIMEOUT		24
#define UHF_C_PORT_LINK_STATE		25
#define UHF_C_PORT_CONFIG_ERROR		26
#define UHF_PORT_REMOTE_WAKE_MASK	27
#define UHF_BH_PORT_RESET		28
#define UHF_C_BH_PORT_RESET		29
#define UHF_FORCE_LINKPM_ACCEPT		30


struct usb_hub_descriptor {
	uByte		bDescLength;
	uByte		bDescriptorType;
	uByte		bNbrPorts;
	uWord		wHubCharacteristics;
#define UHD_PWR			0x0003
#define  UHD_PWR_GANGED		0x0000
#define  UHD_PWR_INDIVIDUAL	0x0001
#define  UHD_PWR_NO_SWITCH	0x0002
#define UHD_COMPOUND		0x0004
#define UHD_OC			0x0018
#define  UHD_OC_GLOBAL		0x0000
#define  UHD_OC_INDIVIDUAL	0x0008
#define  UHD_OC_NONE		0x0010
#define UHD_TT_THINK		0x0060
#define  UHD_TT_THINK_8		0x0000
#define  UHD_TT_THINK_16	0x0020
#define  UHD_TT_THINK_24	0x0040
#define  UHD_TT_THINK_32	0x0060
#define UHD_PORT_IND		0x0080
	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
#define UHD_PWRON_FACTOR 2
	uByte		bHubContrCurrent;
	uByte		DeviceRemovable[32]; /* max 255 ports */
#define UHD_NOT_REMOV(desc, i) \
    (((desc)->DeviceRemovable[(i)/8] >> ((i) % 8)) & 1)
} __packed;
typedef struct usb_hub_descriptor usb_hub_descriptor_t;
#define USB_HUB_DESCRIPTOR_SIZE 8

struct usb_hub_ss_descriptor {
	uByte		bDescLength;
	uByte		bDescriptorType;
	uByte		bNbrPorts;
	uWord		wHubCharacteristics;
	uByte		bPwrOn2PwrGood;	/* delay in 2 ms units */
	uByte		bHubContrCurrent;
	uByte		bHubHdrDecLat;
	uWord		wHubDelay;
	uByte		DeviceRemovable[32]; /* max 255 ports */
} __packed;
typedef struct usb_hub_ss_descriptor usb_hub_ss_descriptor_t;
#define USB_HUB_SS_DESCRIPTOR_SIZE 11

struct usb_device_qualifier {
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize0;
	uByte		bNumConfigurations;
	uByte		bReserved;
} __packed;
typedef struct usb_device_qualifier usb_device_qualifier_t;
#define USB_DEVICE_QUALIFIER_SIZE 10

struct usb_otg_descriptor {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bmAttributes;
#define UOTG_SRP	0x01
#define UOTG_HNP	0x02
} __packed;
typedef struct usb_otg_descriptor usb_otg_descriptor_t;

/* OTG feature selectors */
#define UOTG_B_HNP_ENABLE	3
#define UOTG_A_HNP_SUPPORT	4
#define UOTG_A_ALT_HNP_SUPPORT	5

struct usb_status {
	uWord		wStatus;
/* Device status flags */
#define UDS_SELF_POWERED		0x0001
#define UDS_REMOTE_WAKEUP		0x0002
/* Endpoint status flags */
#define UES_HALT			0x0001
} __packed;
typedef struct usb_status usb_status_t;

struct usb_hub_status {
	uWord		wHubStatus;
#define UHS_LOCAL_POWER			0x0001
#define UHS_OVER_CURRENT		0x0002
	uWord		wHubChange;
} __packed;
typedef struct usb_hub_status usb_hub_status_t;

struct usb_port_status {
	uWord		wPortStatus;
#define UPS_CURRENT_CONNECT_STATUS	0x0001
#define UPS_PORT_ENABLED		0x0002
#define UPS_SUSPEND			0x0004
#define UPS_OVERCURRENT_INDICATOR	0x0008
#define UPS_RESET			0x0010
#define UPS_PORT_L1			0x0020	/* USB 2.0 only */

/* Super-Speed port link state values. */
#define UPS_PORT_LS_U0			0x0000
#define UPS_PORT_LS_U1			0x0020
#define UPS_PORT_LS_U2			0x0040
#define UPS_PORT_LS_U3			0x0060
#define UPS_PORT_LS_SS_DISABLED		0x0080
#define UPS_PORT_LS_RX_DETECT		0x00a0
#define UPS_PORT_LS_SS_INACTIVE		0x00c0
#define UPS_PORT_LS_POLLING		0x00e0
#define UPS_PORT_LS_RECOVERY		0x0100
#define UPS_PORT_LS_HOT_RESET		0x0120
#define UPS_PORT_LS_COMP_MOD		0x0140
#define UPS_PORT_LS_LOOPBACK		0x0160
#define UPS_PORT_LS_GET(x)		(((x) >> 5) & 0xf)
#define UPS_PORT_LS_SET(x)		(((x) & 0xf) << 5)

#define UPS_PORT_POWER			0x0100
#define UPS_PORT_POWER_SS		0x0200	/* USB 3.0 only */
#define UPS_FULL_SPEED			0x0000
#define UPS_LOW_SPEED			0x0200
#define UPS_HIGH_SPEED			0x0400
#define UPS_PORT_TEST			0x0800
#define UPS_PORT_INDICATOR		0x1000

	uWord		wPortChange;
#define UPS_C_CONNECT_STATUS		0x0001
#define UPS_C_PORT_ENABLED		0x0002
#define UPS_C_SUSPEND			0x0004
#define UPS_C_OVERCURRENT_INDICATOR	0x0008
#define UPS_C_PORT_RESET		0x0010
#define UPS_C_PORT_L1			0x0020	/* USB 2.0 only */
#define UPS_C_BH_PORT_RESET		0x0020	/* USB 3.0 only */
#define UPS_C_PORT_LINK_STATE		0x0040
#define UPS_C_PORT_CONFIG_ERROR		0x0080
} __packed;
typedef struct usb_port_status usb_port_status_t;

/* Device class codes */
#define UDCLASS_IN_INTERFACE	0x00
#define UDCLASS_COMM		0x02
#define UDCLASS_HUB		0x09
#define  UDSUBCLASS_HUB		0x00
#define  UDPROTO_FSHUB		0x00
#define  UDPROTO_HSHUBSTT	0x01
#define  UDPROTO_HSHUBMTT	0x02
#define  UDPROTO_SSHUB		0x03
#define UDCLASS_DIAGNOSTIC	0xdc
#define UDCLASS_WIRELESS	0xe0
#define UDCLASS_VIDEO		0xef
#define  UDSUBCLASS_RF		0x01
#define   UDPROTO_BLUETOOTH	0x01
#define UDCLASS_VENDOR		0xff

/* Interface class codes */
#define UICLASS_UNSPEC		0x00

#define UICLASS_AUDIO		0x01
#define  UISUBCLASS_AUDIOCONTROL	1
#define  UISUBCLASS_AUDIOSTREAM		2
#define  UISUBCLASS_MIDISTREAM		3

#define UICLASS_CDC		0x02 /* communication */
#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
#define	 UISUBCLASS_MOBILE_DIRECT_LINE_MODEL	10
#define	 UISUBCLASS_NETWORK_CONTROL_MODEL	13
#define	 UISUBCLASS_MOBILE_BROADBAND_INTERFACE_MODEL 14
#define   UIPROTO_CDC_NOCLASS			0
#define   UIPROTO_CDC_AT			1

#define UICLASS_HID		0x03
#define  UISUBCLASS_BOOT	1
#define  UIPROTO_BOOT_KEYBOARD	1
#define  UIPROTO_BOOT_MOUSE	2

#define UICLASS_PHYSICAL	0x05

#define UICLASS_IMAGE		0x06

#define UICLASS_PRINTER		0x07
#define  UISUBCLASS_PRINTER	1
#define  UIPROTO_PRINTER_UNI	1
#define  UIPROTO_PRINTER_BI	2
#define  UIPROTO_PRINTER_1284	3

#define UICLASS_MASS		0x08
#define  UISUBCLASS_RBC		1
#define  UISUBCLASS_SFF8020I	2
#define  UISUBCLASS_QIC157	3
#define  UISUBCLASS_UFI		4
#define  UISUBCLASS_SFF8070I	5
#define  UISUBCLASS_SCSI	6
#define  UIPROTO_MASS_CBI_I	0
#define  UIPROTO_MASS_CBI	1
#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */

#define UICLASS_HUB		0x09
#define  UISUBCLASS_HUB		0
#define  UIPROTO_FSHUB		0
#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
#define  UIPROTO_HSHUBMTT	1

#define UICLASS_CDC_DATA	0x0a
#define  UISUBCLASS_DATA		0
#define   UIPROTO_DATA_MBIM		0x02    /* MBIM */
#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */

#define UICLASS_SMARTCARD	0x0b

/*#define UICLASS_FIRM_UPD	0x0c*/

#define UICLASS_SECURITY	0x0d

#define UICLASS_VIDEO		0x0e
#define  UISUBCLASS_VIDEOCONTROL		1
#define  UISUBCLASS_VIDEOSTREAM			2
#define  UISUBCLASS_VIDEO_IF_COLLECTION		3 

#define UICLASS_DIAGNOSTIC	0xdc

#define UICLASS_WIRELESS	0xe0
#define  UISUBCLASS_RF			0x01
#define   UIPROTO_BLUETOOTH		0x01
#define   UIPROTO_RNDIS			0x03

#define UICLASS_MISC		0xef
#define  UISUBCLASS_SYNC		0x01
#define   UIPROTO_ACTIVESYNC		0x01

#define UICLASS_APPL_SPEC	0xfe
#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
#define  UISUBCLASS_IRDA		2
#define  UIPROTO_IRDA			0

#define UICLASS_VENDOR		0xff


#define USB_HUB_MAX_DEPTH 5

/*
 * Minimum time a device needs to be powered down to go through
 * a power cycle.  XXX Are these time in the spec?
 */
#define USB_POWER_DOWN_TIME	200 /* ms */
#define USB_PORT_POWER_DOWN_TIME	100 /* ms */

#if 0
/* These are the values from the spec. */
#define USB_PORT_RESET_DELAY	10  /* ms */
#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
#define USB_PORT_RESET_RECOVERY	10  /* ms */
#define USB_PORT_POWERUP_DELAY	100 /* ms */
#define USB_SET_ADDRESS_SETTLE	2   /* ms */
#define USB_RESUME_DELAY	(20*5)  /* ms */
#define USB_RESUME_WAIT		10  /* ms */
#define USB_RESUME_RECOVERY	10  /* ms */
#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
#else
/* Allow for marginal (i.e. non-conforming) devices. */
#define USB_PORT_RESET_DELAY	50  /* ms */
#define USB_PORT_ROOT_RESET_DELAY 100  /* ms */
#define USB_PORT_RESET_RECOVERY	250  /* ms */
#define USB_PORT_POWERUP_DELAY	300 /* ms */
#define USB_SET_ADDRESS_SETTLE	10  /* ms */
#define USB_RESUME_DELAY	(50*5)  /* ms */
#define USB_RESUME_WAIT		50  /* ms */
#define USB_RESUME_RECOVERY	50  /* ms */
#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
#endif

#define USB_MIN_POWER		100 /* mA */
#define USB_MAX_POWER		500 /* mA */

#define USB_BUS_RESET_DELAY	100 /* ms XXX?*/


#define USB_UNCONFIG_NO 0
#define USB_UNCONFIG_INDEX (-1)

/*** ioctl() related stuff ***/

struct usb_ctl_request {
	int	ucr_addr;
	usb_device_request_t ucr_request;
	void	*ucr_data;
	int	ucr_flags;
#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */
	int	ucr_actlen;		/* actual length transferred */
};

struct usb_alt_interface {
	int	uai_config_index;
	int	uai_interface_index;
	int	uai_alt_no;
};

#define USB_CURRENT_CONFIG_INDEX (-1)
#define USB_CURRENT_ALT_INDEX (-1)

struct usb_config_desc {
	int	ucd_config_index;
	struct usb_config_descriptor ucd_desc;
};

struct usb_device_cdesc {
	u_int8_t		udc_bus;
	u_int8_t		udc_addr;	/* device address */
	int			udc_config_index;
	struct usb_config_descriptor udc_desc;
};

struct usb_interface_desc {
	int	uid_config_index;
	int	uid_interface_index;
	int	uid_alt_index;
	struct usb_interface_descriptor uid_desc;
};

struct usb_endpoint_desc {
	int	ued_config_index;
	int	ued_interface_index;
	int	ued_alt_index;
	int	ued_endpoint_index;
	struct usb_endpoint_descriptor ued_desc;
};

struct usb_full_desc {
	int	ufd_config_index;
	u_int	ufd_size;
	u_char	*ufd_data;
};

struct usb_device_fdesc {
	u_int8_t	 udf_bus;
	u_int8_t	 udf_addr;	/* device address */
	int		 udf_config_index;
	u_int		 udf_size;
	u_char		*udf_data;
};

struct usb_device_ddesc {
	u_int8_t	udd_bus;
	u_int8_t	udd_addr;	/* device address */
	struct usb_device_descriptor udd_desc;
};

struct usb_string_desc {
	int	usd_string_index;
	int	usd_language_id;
	struct usb_string_descriptor usd_desc;
};

struct usb_ctl_report_desc {
	int	ucrd_size;
	u_char	ucrd_data[1024];	/* filled data size will vary */
};

#define USB_MAX_DEVNAMES 4
#define USB_MAX_DEVNAMELEN 16
struct usb_device_info {
	u_int8_t	udi_bus;
	u_int8_t	udi_addr;	/* device address */
	char		udi_product[USB_MAX_STRING_LEN];
	char		udi_vendor[USB_MAX_STRING_LEN];
	char		udi_release[8];
	u_int16_t	udi_productNo;
	u_int16_t	udi_vendorNo;
	u_int16_t	udi_releaseNo;
	u_int8_t	udi_class;
	u_int8_t	udi_subclass;
	u_int8_t	udi_protocol;
	u_int8_t	udi_config;
	u_int8_t	udi_speed;
#define USB_SPEED_LOW	1
#define USB_SPEED_FULL	2
#define USB_SPEED_HIGH	3
#define USB_SPEED_SUPER	4
	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
	int		udi_nports;
	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
#define USB_PORT_ENABLED 0xff
#define USB_PORT_SUSPENDED 0xfe
#define USB_PORT_POWERED 0xfd
#define USB_PORT_DISABLED 0xfc
	char		udi_serial[USB_MAX_STRING_LEN];
};

struct usb_ctl_report {
	int	ucr_report;
	u_char	ucr_data[1024];	/* filled data size will vary */
};

struct usb_device_stats {
	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
};

/* USB controller */
#define USB_REQUEST		_IOWR('U', 1, struct usb_ctl_request)
#define USB_SETDEBUG		_IOW ('U', 2, unsigned int)
#define USB_DEVICEINFO		_IOWR('U', 4, struct usb_device_info)
#define USB_DEVICESTATS		_IOR ('U', 5, struct usb_device_stats)
#define USB_DEVICE_GET_CDESC	_IOWR('U', 6, struct usb_device_cdesc)
#define USB_DEVICE_GET_FDESC	_IOWR('U', 7, struct usb_device_fdesc)
#define USB_DEVICE_GET_DDESC	_IOWR('U', 8, struct usb_device_ddesc)

/* Generic HID device */
#define USB_GET_REPORT_DESC	_IOR ('U', 21, struct usb_ctl_report_desc)
#define USB_GET_REPORT		_IOWR('U', 23, struct usb_ctl_report)
#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
#define USB_GET_REPORT_ID	_IOR ('U', 25, int)

/* Generic USB device */
#define USB_GET_CONFIG		_IOR ('U', 100, int)
#define USB_SET_CONFIG		_IOW ('U', 101, int)
#define USB_GET_ALTINTERFACE	_IOWR('U', 102, struct usb_alt_interface)
#define USB_SET_ALTINTERFACE	_IOWR('U', 103, struct usb_alt_interface)
#define USB_GET_NO_ALT		_IOWR('U', 104, struct usb_alt_interface)
#define USB_GET_DEVICE_DESC	_IOR ('U', 105, usb_device_descriptor_t)
#define USB_GET_CONFIG_DESC	_IOWR('U', 106, struct usb_config_desc)
#define USB_GET_INTERFACE_DESC	_IOWR('U', 107, struct usb_interface_desc)
#define USB_GET_ENDPOINT_DESC	_IOWR('U', 108, struct usb_endpoint_desc)
#define USB_GET_FULL_DESC	_IOWR('U', 109, struct usb_full_desc)
#define USB_DO_REQUEST		_IOWR('U', 111, struct usb_ctl_request)
#define USB_GET_DEVICEINFO	_IOR ('U', 112, struct usb_device_info)
#define USB_SET_SHORT_XFER	_IOW ('U', 113, int)
#define USB_SET_TIMEOUT		_IOW ('U', 114, int)

#endif /* _USB_H_ */
@


1.57
log
@Add define for NCM.

ok gerhard@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.56 2016/06/15 19:39:34 gerhard Exp $ */
d513 1
@


1.56
log
@Add umb(4) - a driver for the Mobile Broadband Interface Model (MBIM)

The umb(4) driver provides support for USB MBIM devices.
Those devices establish connections via celluar networks such as
GPRS, UMTS, and LTE.

ok mpi@@ sthen@@
additional feedback from deraadt@@ jmc@@ stsp@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.55 2016/05/24 05:35:01 mpi Exp $ */
d511 1
@


1.55
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.54 2016/02/28 17:57:50 stefan Exp $ */
d511 1
d549 1
@


1.54
log
@Remove USB_SET_IMMED ioctl and corresponding code and manpage bits.
Nothing uses it.

suggested by and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.53 2015/07/09 05:40:44 mpi Exp $ */
a754 1
#define USB_DISCOVER		_IO  ('U', 3)
a777 1
#define USB_GET_STRING_DESC	_IOWR('U', 110, struct usb_string_desc)
a781 4

/* Modem device */
#define USB_GET_CM_OVER_DATA	_IOR ('U', 130, int)
#define USB_SET_CM_OVER_DATA	_IOW ('U', 131, int)
@


1.53
log
@Name unamed structures, from Ludovic Coues with some tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.52 2015/06/29 10:52:40 mpi Exp $ */
a763 1
#define USB_SET_IMMED		_IOW ('U', 22, int)
@


1.52
log
@Add missing definition of "usb_interface_assoc_descriptor" needed to for
a tool parsing device descriptors.

Use the same name as DragonFly/FreeBSD since they export it to userland.

From Ludovic Coues.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.51 2015/06/22 10:29:18 mpi Exp $ */
d85 1
a85 1
typedef struct {
d91 2
a92 1
} __packed usb_device_request_t;
d171 1
a171 1
typedef struct {
d175 2
a176 1
} __packed usb_descriptor_t;
d178 1
a178 1
typedef struct {
d194 2
a195 1
} __packed usb_device_descriptor_t;
d198 1
a198 1
typedef struct {
d211 2
a212 1
} __packed usb_config_descriptor_t;
d215 1
a215 1
typedef struct {
d225 2
a226 1
} __packed usb_interface_descriptor_t;
d230 8
a237 8
    uByte       bLength;
    uByte       bDescriptorType;
    uByte       bFirstInterface;
    uByte       bInterfaceCount;
    uByte       bFunctionClass;
    uByte       bFunctionSubClass;
    uByte       bFunctionProtocol;
    uByte       iFunction;
d240 1
d242 1
a242 1
typedef struct {
d268 2
a269 1
} __packed usb_endpoint_descriptor_t;
d272 1
a272 1
typedef struct {
d278 3
a280 1
} __packed usb_endpoint_ss_comp_descriptor_t;
d292 1
a292 1
typedef struct {
d296 2
a297 1
} __packed usb_string_descriptor_t;
d342 1
a342 1
typedef struct {
d368 2
a369 1
} __packed usb_hub_descriptor_t;
d372 1
a372 1
typedef struct {
d382 2
a383 1
} __packed usb_hub_ss_descriptor_t;
d386 1
a386 1
typedef struct {
d396 2
a397 1
} __packed usb_device_qualifier_t;
d400 1
a400 1
typedef struct {
d406 2
a407 1
} __packed usb_otg_descriptor_t;
d414 1
a414 1
typedef struct {
d421 2
a422 1
} __packed usb_status_t;
d424 1
a424 1
typedef struct {
d429 2
a430 1
} __packed usb_hub_status_t;
d432 1
a432 1
typedef struct {
d475 2
a476 1
} __packed usb_port_status_t;
d656 1
a656 1
	usb_config_descriptor_t ucd_desc;
d663 1
a663 1
	usb_config_descriptor_t udc_desc;
d670 1
a670 1
	usb_interface_descriptor_t uid_desc;
d678 1
a678 1
	usb_endpoint_descriptor_t ued_desc;
d698 1
a698 1
	usb_device_descriptor_t udd_desc;
d704 1
a704 1
	usb_string_descriptor_t usd_desc;
@


1.51
log
@Make xhci(4)'s root hub report the same status bits as physical USB3 hubs.

There's not bit to indicate the speed of a USB3.0 device attached to a hub
port so do not abuse the PORT_TEST bit.  Instead make the xhci(4) root hub
report the PORT_POWER_SS bit when appropriate and use it to determin the
speed of a new device.

While here make the root hub report the link state and config error, from
FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.50 2015/02/14 06:18:58 uebayasi Exp $ */
d223 12
@


1.50
log
@Define UPS_PORT_TEST as FreeBSD/NetBSD do.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d426 2
a433 1
#define UPS_SUPER_SPEED			0x0800
@


1.49
log
@Give Super-Speed hubs a chance to route USB 3.0 transfers.

Without knowing their depth, hubs couldn't find the bits correspdonding
to their downstream port in the route-string.  Now USB 3.0 devices just
work(tm) anywhere in your hub chain.

This commit would not have been possible without the cheese provided by
miod@@ at #HAMoween.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.48 2014/11/01 14:04:27 mpi Exp $ */
d433 1
@


1.48
log
@Super-Speed port feature definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.47 2014/08/08 14:20:05 mpi Exp $ */
d285 1
@


1.47
log
@Super Speed hub descriptor definition and routine, required for upcoming
external USB 3.0 hub support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.46 2014/03/08 11:47:26 mpi Exp $ */
d289 29
a317 15
#define UHF_PORT_CONNECTION	0
#define UHF_PORT_ENABLE		1
#define UHF_PORT_SUSPEND	2
#define UHF_PORT_OVER_CURRENT	3
#define UHF_PORT_RESET		4
#define UHF_PORT_POWER		8
#define UHF_PORT_LOW_SPEED	9
#define UHF_C_PORT_CONNECTION	16
#define UHF_C_PORT_ENABLE	17
#define UHF_C_PORT_SUSPEND	18
#define UHF_C_PORT_OVER_CURRENT	19
#define UHF_C_PORT_RESET	20
#define UHF_PORT_TEST		21
#define UHF_PORT_INDICATOR	22
#define UHF_PORT_DISOWN_TO_1_1	30
d410 16
d427 1
a427 1
#define UPS_PORT_POWER_SS		0x0200	/* super-speed only */
d433 1
d440 4
@


1.46
log
@Add various super speed defines, mostly the same as in FreeBSD to
keep similar userland exported API definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.45 2014/01/20 17:23:17 jcs Exp $ */
a330 1
	/* deprecated */ uByte		PortPowerCtrlMask[1];
d332 14
a345 1
#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */
@


1.45
log
@define UIPROTO_BOOT_MOUSE

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.44 2013/04/17 11:53:10 mglocker Exp $ */
d141 4
d151 2
d167 2
a168 2
#define USB_2_MAX_CTRL_PACKET	64
#define USB_2_MAX_BULK_PACKET	512
a179 2
#define UD_USB_2_0		0x0200
#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
d253 9
d385 2
d389 1
a389 1
#define UPS_PORT_TEST			0x0800
d407 1
d649 4
a652 3
#define USB_SPEED_LOW  1
#define USB_SPEED_FULL 2
#define USB_SPEED_HIGH 3
@


1.44
log
@Add new ioctl command USB_DEVICE_GET_DDESC to usb(4) to retrieve the
device descriptor.

Help and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.43 2013/04/08 10:34:20 mglocker Exp $ */
d421 1
@


1.43
log
@Add new ioctl's USB_DEVICE_GET_CDESC and USB_DEVICE_GET_FDESC to usb(4).
Those are the equivalents for ugen(4)'s USB_GET_CONFIG_DESC and
USB_GET_FULL_DESC.

Help and OK mpi@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.42 2013/03/16 09:58:40 mpi Exp $ */
d599 6
d663 1
@


1.42
log
@Remove the 4.8 version of the USB device info ioctl.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.41 2012/06/20 10:51:27 fgsch Exp $ */
d563 7
d591 8
d655 2
@


1.41
log
@- urndis_match() should support multiple interface descriptors.
- in urndis_attach() use the first interface descriptor that's different
  from the control interface as the data interface.

from armani's colleague with some tweaks by me.
kettenis@@ sthen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.40 2012/06/10 10:20:02 mpi Exp $ */
a624 21
/* OpenBSD <= 4.8 version, to be removed eventually */
struct usb_device_info_48 {
	u_int8_t	udi_bus;
	u_int8_t	udi_addr;	/* device address */
	char		udi_product[USB_MAX_STRING_LEN];
	char		udi_vendor[USB_MAX_STRING_LEN];
	char		udi_release[8];
	u_int16_t	udi_productNo;
	u_int16_t	udi_vendorNo;
	u_int16_t	udi_releaseNo;
	u_int8_t	udi_class;
	u_int8_t	udi_subclass;
	u_int8_t	udi_protocol;
	u_int8_t	udi_config;
	u_int8_t	udi_speed;
	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
	int		udi_nports;
	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
};

a638 1
#define USB_DEVICEINFO_48	_IOWR('U', 4, struct usb_device_info_48)
@


1.40
log
@Remove leftovers from the "usb event" removal.

ok jsg@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.39 2012/01/08 13:12:38 miod Exp $ */
d483 4
@


1.39
log
@Remove usb_event_cookie_t type and instances of it found in various structs;
leftover from the "usb event" stuff removal. Diff from Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.38 2011/11/09 21:45:50 sthen Exp $ */
a648 23
};

/* Events that can be read from /dev/usb */
struct usb_event {
	int			ue_type;
#define USB_EVENT_CTRLR_ATTACH 1
#define USB_EVENT_CTRLR_DETACH 2
#define USB_EVENT_DEVICE_ATTACH 3
#define USB_EVENT_DEVICE_DETACH 4
#define USB_EVENT_DRIVER_ATTACH 5
#define USB_EVENT_DRIVER_DETACH 6
#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
	struct timespec		ue_time;
	union {
		struct {
			int			ue_bus;
		} ue_ctrlr;
		struct usb_device_info		ue_device;
		struct {
			char			ue_devname[16];
		} ue_driver;
	} u;
@


1.38
log
@Add support for UISUBCLASS_MOBILE_DIRECT_LINE_MODEL to cdce(4).
This is available with at least Ericsson-derived HSPA cards (e.g.
Dell 5530/5540) and provides a nice alternative to using them in
ppp mode. From Rivo Nurges (rix at estpak ee), ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.37 2011/03/04 23:55:32 kettenis Exp $ */
a590 2
typedef struct { u_int32_t cookie; } usb_event_cookie_t;

a595 1
	usb_event_cookie_t udi_cookie;
a624 1
	usb_event_cookie_t udi_cookie;
a668 1
			usb_event_cookie_t	ue_cookie;
@


1.37
log
@Apparently keeping some USB devices in reset for too long makes them
non-functional.  Reduce the root port reset delay to 100 ms.  This is still
twice as long as the delay mandated by the standard, but makes the Gunze
TouchScreen on the Sony Vaio VGN-UX91S and a few other devices work.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.36 2011/01/15 23:58:43 jakemsr Exp $ */
d415 1
@


1.36
log
@* add 'udi_serial' to struct usb_device_info.
* fill 'udi_serial' with the serial number in usbd_fill_deviceinfo().
* add compatability ioctl/struct so old binaries continue to work.

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.35 2010/03/01 23:35:56 mk Exp $ */
d514 1
a514 1
#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
@


1.35
log
@Add urndis(4), a driver for RNDIS Ethernet over USB.

It provides an Ethernet transport typically over EDGE or 3G on
cellphones similar to what cdce(4) does on other phones.  It is
likely to work with most of HTC's recent and coming Android based
phones but a bunch of other things (phones in particular) may use
it.

Started by me; brought to a working state by Jonathan Armani and
Fabien Romano over the past week, with some input and additions
from me.

Tested on i386 and macppc by me (HTC Hero), amd64 by Jonathan and
Fabien (HTC Hero), and by gilles@@ (HTC Magic) on i386 or amd64.

It still has a few kinks to work out, but it works well enough that
I can commit this over my HTC Hero.

`commit it!' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.34 2008/12/09 03:08:07 yuo Exp $ */
d620 23
d683 1
@


1.34
log
@assign ehcidebug to USB_DEBUG ioctl argument.

add priv check to the ioctl.
only root priv should access these debug flags.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.33 2008/08/09 22:59:20 mglocker Exp $ */
d481 1
@


1.33
log
@Add isochronous xfer support for ehci(4).  From NetBSD.

OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.32 2008/06/29 10:04:15 yuo Exp $ */
d656 1
a656 1
#define USB_SETDEBUG		_IOW ('U', 2, int)
@


1.32
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.31 2008/06/26 05:42:19 ray Exp $ */
d243 2
@


1.31
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.30 2007/11/28 16:50:22 robert Exp $ */
d288 1
@


1.30
log
@add the device and interface class codes for USB Video Class (UVC)
devices

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.29 2007/07/27 09:16:09 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.29
log
@Correct the length of the usb_string_descriptor_t and fix a possible
buffer overflow.

Problem found by (and original diff from) Marc Winiger <mw@@msys.ch>, comment
by me on jsg's request.

ok jsg, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.28 2007/06/17 07:53:11 mbalmer Exp $ */
d398 1
d474 5
@


1.28
log
@No longer include usb_port.h, all macros have been converted to their C
counterparts.

Revert usb_port.h to it's original form with all the macro definitions to
ease the import of new drivers from other BSDs.

after discussion with deraadt; feedback from mk, miod, jsg, dlg.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.27 2007/06/09 11:06:53 mbalmer Exp $ */
d254 9
d266 1
a266 1
	uWord		bString[127];
d268 1
a268 1
#define USB_MAX_STRING_LEN 128
@


1.27
log
@Remove the definition and use of UPACKED and replace it with our own __packed
(to which UPACKED was define'd before anway).  No binary change, just one layer
of confusion less in the sourcecode.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.26 2007/06/04 10:34:04 mbalmer Exp $ */
a49 4

#if defined(_KERNEL)
#include <dev/usb/usb_port.h>
#endif /* _KERNEL */
@


1.26
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.25 2006/07/12 18:12:55 miod Exp $ */
a95 2
#define UPACKED __packed

d102 1
a102 1
} UPACKED usb_device_request_t;
d179 1
a179 1
} UPACKED usb_descriptor_t;
d199 1
a199 1
} UPACKED usb_device_descriptor_t;
d215 1
a215 1
} UPACKED usb_config_descriptor_t;
d228 1
a228 1
} UPACKED usb_interface_descriptor_t;
d255 1
a255 1
} UPACKED usb_endpoint_descriptor_t;
d262 1
a262 1
} UPACKED usb_string_descriptor_t;
d318 1
a318 1
} UPACKED usb_hub_descriptor_t;
d331 1
a331 1
} UPACKED usb_device_qualifier_t;
d340 1
a340 1
} UPACKED usb_otg_descriptor_t;
d354 1
a354 1
} UPACKED usb_status_t;
d361 1
a361 1
} UPACKED usb_hub_status_t;
d381 1
a381 1
} UPACKED usb_port_status_t;
@


1.25
log
@Do not split multibyte access on little endian architectures with no alignment
requirements; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.24 2006/06/23 19:25:07 miod Exp $ */
a48 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a49 6
#endif
#if defined(__FreeBSD__)
/* These two defines are used by usbd to autoload the usb kld */
#define USB_KLD		"usb"           /* name of usb module */
#define USB_UHUB	"usb/uhub"      /* root hub */
#endif
@


1.24
log
@A typo a day, keeps the dictionnary away.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.23 2003/11/16 20:30:07 avsm Exp $ */
d84 1
a84 1
#if 1
@


1.23
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.22 2003/07/08 13:19:09 nate Exp $ */
d94 1
a94 1
 * On little-endian machines that can handle unanliged accesses
@


1.22
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.21 2003/05/17 06:07:57 nate Exp $ */
d103 1
a103 1
#define UPACKED __attribute__((__packed__))
@


1.21
log
@sync with NetBSD and add various local hacks to make things work correctly
with our scsi layer
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.h,v 1.20 2002/07/25 02:18:11 nate Exp $ */
/*	$NetBSD: usb.h,v 1.52 2001/07/23 15:17:50 nathanw Exp $	*/
d51 6
a61 13
#elif defined(__FreeBSD__)
#if defined(KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#include <dev/usb/usb_port.h>
#endif /* KERNEL */
#endif /* __FreeBSD__ */


d157 4
d177 1
d181 3
d194 2
d277 4
d297 2
d305 15
a319 9
#define UHD_PWR			0x03
#define UHD_PWR_GANGED		0x00
#define UHD_PWR_INDIVIDUAL	0x01
#define UHD_PWR_NO_SWITCH	0x02
#define UHD_COMPOUND		0x04
#define UHD_OC			0x18
#define UHD_OC_GLOBAL		0x00
#define UHD_OC_INDIVIDUAL	0x08
#define UHD_OC_NONE		0x10
d331 26
d381 3
d393 1
a393 1
#define UDCLASS_AUDIO		0x00
a394 1
#define UDCLASS_HID		0x00
d396 9
a404 2
#define  UDSUBCLASS_HUB		0
#define UDCLASS_MASS		0x00
d430 2
d452 3
d472 11
a482 1
#define UICLASS_FIRM_UPD	0x0c
d485 4
d504 2
a505 1
#define USB_PORT_RESET_SETTLE	10  /* ms */
d515 3
a517 2
#define USB_PORT_RESET_RECOVERY	50  /* ms */
#define USB_PORT_POWERUP_DELAY	200 /* ms */
d609 4
a612 1
	u_int8_t	udi_lowspeed;
d642 1
@


1.20
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.19 2002/06/11 03:47:29 nate Exp $ */
d395 2
a396 2
#define  UIPROTO_MASS_BBB	2
#define  UIPROTO_MASS_BBB_P	80	/* 'P' for the Iomega Zip drive */
@


1.19
log
@add stack version #define.
From NetBSD requested by pval
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.18 2002/05/09 15:06:29 nate Exp $ */
d100 1
a100 1
/* 
d409 1
a409 1
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */  
d425 2
a426 2
/* 
 * Minimum time a device needs to be powered down to go through 
d577 1
a577 1
		} ue_driver;			
@


1.18
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.17 2002/05/07 18:29:18 nate Exp $ */
d68 2
@


1.17
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.15 2002/05/02 20:08:04 nate Exp $ */
d591 1
@


1.16
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usb.h,v 1.65 2002/02/26 10:27:49 augustss Exp $	*/
a50 6
#endif
#if defined(__FreeBSD__)
/* These two defines are used by usbd to autoload the usb kld */
#define USB_KLD		"usb"           /* name of usb module */
#define USB_UHUB	"usb/uhub"      /* root hub */
#endif
d56 12
a67 1
#define USB_STACK_VERSION 2
a161 4
#define  UDESC_DEVICE_QUALIFIER	0x06
#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
#define  UDESC_INTERFACE_POWER	0x08
#define  UDESC_OTG		0x09
a177 1
#define UF_TEST_MODE		2
a180 3
#define USB_2_MAX_CTRL_PACKET	64
#define USB_2_MAX_BULK_PACKET	512

a190 2
#define UD_USB_2_0		0x0200
#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
a271 4
#define UR_CLEAR_TT_BUFFER	0x08
#define UR_RESET_TT		0x09
#define UR_GET_TT_STATE		0x0a
#define UR_STOP_TT		0x0b
a287 2
#define UHF_PORT_TEST		21
#define UHF_PORT_INDICATOR	22
d294 9
a302 15
#define UHD_PWR			0x0003
#define  UHD_PWR_GANGED		0x0000
#define  UHD_PWR_INDIVIDUAL	0x0001
#define  UHD_PWR_NO_SWITCH	0x0002
#define UHD_COMPOUND		0x0004
#define UHD_OC			0x0018
#define  UHD_OC_GLOBAL		0x0000
#define  UHD_OC_INDIVIDUAL	0x0008
#define  UHD_OC_NONE		0x0010
#define UHD_TT_THINK		0x0060
#define  UHD_TT_THINK_8		0x0000
#define  UHD_TT_THINK_16	0x0020
#define  UHD_TT_THINK_24	0x0040
#define  UHD_TT_THINK_32	0x0060
#define UHD_PORT_IND		0x0080
a313 26
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize0;
	uByte		bNumConfigurations;
	uByte		bReserved;
} UPACKED usb_device_qualifier_t;
#define USB_DEVICE_QUALIFIER_SIZE 10

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bmAttributes;
#define UOTG_SRP	0x01
#define UOTG_HNP	0x02
} UPACKED usb_otg_descriptor_t;

/* OTG feature selectors */
#define UOTG_B_HNP_ENABLE	3
#define UOTG_A_HNP_SUPPORT	4
#define UOTG_A_ALT_HNP_SUPPORT	5

typedef struct {
a337 3
#define UPS_HIGH_SPEED			0x0400
#define UPS_PORT_TEST			0x0800
#define UPS_PORT_INDICATOR		0x1000
a351 3
#define  UDPROTO_FSHUB		0
#define  UDPROTO_HSHUBSTT	1
#define  UDPROTO_HSHUBMTT	2
d393 2
a394 2
#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
a397 3
#define  UIPROTO_FSHUB		0
#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
#define  UIPROTO_HSHUBMTT	1
a417 4
#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
#define  UISUBCLASS_IRDA		2
#define  UIPROTO_IRDA			0

a432 1
#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
a442 1
#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
d444 1
a444 1
#define USB_PORT_POWERUP_DELAY	300 /* ms */
d536 1
a536 4
	u_int8_t	udi_speed;
#define USB_SPEED_LOW  1
#define USB_SPEED_FULL 2
#define USB_SPEED_HIGH 3
a565 1
#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
a590 1
#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
@


1.15
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.h,v 1.14 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: usb.h,v 1.52 2001/07/23 15:17:50 nathanw Exp $	*/
d51 6
d62 1
a62 12
#elif defined(__FreeBSD__)
#if defined(KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#include <dev/usb/usb_port.h>
#endif /* KERNEL */
#endif /* __FreeBSD__ */

d157 4
d177 1
d181 3
d194 2
d277 4
d297 2
d305 15
a319 9
#define UHD_PWR			0x03
#define UHD_PWR_GANGED		0x00
#define UHD_PWR_INDIVIDUAL	0x01
#define UHD_PWR_NO_SWITCH	0x02
#define UHD_COMPOUND		0x04
#define UHD_OC			0x18
#define UHD_OC_GLOBAL		0x00
#define UHD_OC_INDIVIDUAL	0x08
#define UHD_OC_NONE		0x10
d331 26
d381 3
d398 3
d442 2
a443 2
#define  UIPROTO_MASS_BBB	2
#define  UIPROTO_MASS_BBB_P	80	/* 'P' for the Iomega Zip drive */
d447 3
d470 4
d489 1
d500 1
d502 1
a502 1
#define USB_PORT_POWERUP_DELAY	200 /* ms */
d594 4
a597 1
	u_int8_t	udi_lowspeed;
d627 1
d653 1
@


1.14
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.13 2001/10/04 22:55:56 gluk Exp $ */
d464 4
a467 4
	int	addr;
	usb_device_request_t request;
	void	*data;
	int	flags;
d469 1
a469 1
	int	actlen;		/* actual length transferred */
d473 3
a475 3
	int	config_index;
	int	interface_index;
	int	alt_no;
d482 2
a483 2
	int	config_index;
	usb_config_descriptor_t desc;
d487 4
a490 4
	int	config_index;
	int	interface_index;
	int	alt_index;
	usb_interface_descriptor_t desc;
d494 5
a498 5
	int	config_index;
	int	interface_index;
	int	alt_index;
	int	endpoint_index;
	usb_endpoint_descriptor_t desc;
d502 3
a504 3
	int	config_index;
	u_int	size;
	u_char	*data;
d508 3
a510 3
	int	string_index;
	int	language_id;
	usb_string_descriptor_t desc;
d514 2
a515 2
	int	size;
	u_char	data[1024];	/* filled data size will vary */
d523 18
a540 18
	u_int8_t	bus;
	u_int8_t	addr;	/* device address */
	usb_event_cookie_t cookie;
	char		product[USB_MAX_STRING_LEN];
	char		vendor[USB_MAX_STRING_LEN];
	char		release[8];
	u_int16_t	productNo;
	u_int16_t	vendorNo;
	u_int16_t	releaseNo;
	u_int8_t	class;
	u_int8_t	subclass;
	u_int8_t	protocol;
	u_int8_t	config;
	u_int8_t	lowspeed;
	int		power;	/* power consumption in mA, 0 if selfpowered */
	int		nports;
	char		devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	ports[16];/* hub only: addresses of devices on ports */
d548 2
a549 2
	int	report;
	u_char	data[1024];	/* filled data size will vary */
d553 1
a553 1
	u_long	requests[4];	/* indexed by transfer type UE_* */
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.14 2001/10/31 04:24:44 nate Exp $ */
d464 4
a467 4
	int	ucr_addr;
	usb_device_request_t ucr_request;
	void	*ucr_data;
	int	ucr_flags;
d469 1
a469 1
	int	ucr_actlen;		/* actual length transferred */
d473 3
a475 3
	int	uai_config_index;
	int	uai_interface_index;
	int	uai_alt_no;
d482 2
a483 2
	int	ucd_config_index;
	usb_config_descriptor_t ucd_desc;
d487 4
a490 4
	int	uid_config_index;
	int	uid_interface_index;
	int	uid_alt_index;
	usb_interface_descriptor_t uid_desc;
d494 5
a498 5
	int	ued_config_index;
	int	ued_interface_index;
	int	ued_alt_index;
	int	ued_endpoint_index;
	usb_endpoint_descriptor_t ued_desc;
d502 3
a504 3
	int	ufd_config_index;
	u_int	ufd_size;
	u_char	*ufd_data;
d508 3
a510 3
	int	usd_string_index;
	int	usd_language_id;
	usb_string_descriptor_t usd_desc;
d514 2
a515 2
	int	ucrd_size;
	u_char	ucrd_data[1024];	/* filled data size will vary */
d523 18
a540 18
	u_int8_t	udi_bus;
	u_int8_t	udi_addr;	/* device address */
	usb_event_cookie_t udi_cookie;
	char		udi_product[USB_MAX_STRING_LEN];
	char		udi_vendor[USB_MAX_STRING_LEN];
	char		udi_release[8];
	u_int16_t	udi_productNo;
	u_int16_t	udi_vendorNo;
	u_int16_t	udi_releaseNo;
	u_int8_t	udi_class;
	u_int8_t	udi_subclass;
	u_int8_t	udi_protocol;
	u_int8_t	udi_config;
	u_int8_t	udi_lowspeed;
	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
	int		udi_nports;
	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
d548 2
a549 2
	int	ucr_report;
	u_char	ucr_data[1024];	/* filled data size will vary */
d553 1
a553 1
	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
a590 1
#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
@


1.14.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.14.2.1 2002/06/11 03:42:31 art Exp $ */
a68 2
#define USB_STACK_VERSION 2

d98 1
a98 1
/*
d407 1
a407 1
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
d423 2
a424 2
/*
 * Minimum time a device needs to be powered down to go through
d575 1
a575 1
		} ue_driver;
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d395 2
a396 2
#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
@


1.13
log
@Match a IEEE 1284.4 protocol. We do not support this protocol directly,
but USB_ATTACH will switch printer to bidirectional protocol.
Read status from printer. From NetBSD.
This forces newest usb printers works.
Tested by drahn@@ (Epson 740) and me (HP LaserJet 2200).
Ok aaron@@
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.h,v 1.12 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: usb.h,v 1.50 2000/06/01 15:43:32 augustss Exp $	*/
d382 1
a382 1
#define  UIPROTO_PRINTER_IEEE_1284_4	3
@


1.12
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.11 2000/11/08 18:10:39 aaron Exp $ */
d382 1
@


1.11
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.10 2000/07/04 11:44:24 fgsch Exp $ */
d564 1
@


1.10
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.h,v 1.9 2000/04/04 22:52:30 aaron Exp $ */
/*	$NetBSD: usb.h,v 1.44 2000/04/03 13:40:05 augustss Exp $	*/
@


1.9
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.8 2000/03/28 19:37:50 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d80 1
a80 1
 * and endian problem and should always be used to access 16 bit
d85 5
a91 2
#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
typedef u_int8_t uDWord[4];
d97 1
a101 1
#if 0
d104 2
d108 2
d116 1
a116 1
} usb_device_request_t;
d185 1
a185 1
} usb_descriptor_t;
d203 1
a203 1
} usb_device_descriptor_t;
d219 1
a219 1
} usb_config_descriptor_t;
d232 1
a232 1
} usb_interface_descriptor_t;
d259 1
a259 1
} usb_endpoint_descriptor_t;
d266 1
a266 1
} usb_string_descriptor_t;
d309 3
a311 3
	/* deprecated uByte		PortPowerCtrlMask[]; */
} usb_hub_descriptor_t;
#define USB_HUB_DESCRIPTOR_SIZE 8
d320 1
a320 1
} usb_status_t;
d327 1
a327 1
} usb_hub_status_t;
d344 1
a344 1
} usb_port_status_t;
d438 1
d448 1
d455 4
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb.h,v 1.43 2000/03/24 22:16:42 augustss Exp $	*/
d428 1
a428 1
#define USB_RESUME_TIME		(20*5)  /* ms */
@


1.7
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usb.h,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: usb.h,v 1.42 2000/03/19 22:23:28 augustss Exp $	*/
d340 6
a345 6
#define UDCLASS_AUDIO			0x00
#define UDCLASS_COMM			0x02
#define UDCLASS_HID			0x00
#define UDCLASS_HUB			0x09
#define	UDSUBCLASS_HUB			0
#define UDCLASS_MASS			0x00
d348 1
a348 1
#define UICLASS_UNSPEC			0x00
d350 56
a405 56
#define UICLASS_AUDIO			0x01
#define	UISUBCLASS_AUDIOCONTROL		1
#define	UISUBCLASS_AUDIOSTREAM		2
#define	UISUBCLASS_MIDISTREAM		3

#define UICLASS_CDC			0x02 /* communication */
#define	UI_SUBCLASS_DIRECT_LINE_CONTROL_MODEL		1
#define	UI_SUBCLASS_ABSTRACT_CONTROL_MODEL		2
#define	UI_SUBCLASS_TELEPHONE_CONTROL_MODEL		3
#define	UI_SUBCLASS_MULTICHANNEL_CONTROL_MODEL		4
#define	UI_SUBCLASS_CAPI_CONTROL_MODEL			5
#define	UI_SUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL	6
#define	UI_SUBCLASS_ATM_NETWORKING_CONTROL_MODEL	7
#define	UIPROTO_CDC_AT			1

#define UICLASS_HID			0x03
#define	UI_SUBCLASS_BOOT		1
#define	UIPROTO_BOOT_KEYBOARD		1

#define UICLASS_PHYSICAL		0x05

#define UICLASS_PRINTER			0x07
#define UISUBCLASS_PRINTER		1
#define UIPROTO_PRINTER_UNI		1
#define UIPROTO_PRINTER_BI		2

#define UICLASS_MASS			0x08
#define	UISUBCLASS_RBC			1
#define	UISUBCLASS_SFF8020I		2
#define	UISUBCLASS_QIC157		3
#define	UISUBCLASS_UFI			4
#define	UISUBCLASS_SFF8070I		5
#define	UISUBCLASS_SCSI			6
#define	UIPROTO_MASS_CBI_I		0
#define	UIPROTO_MASS_CBI		1
#define	UIPROTO_MASS_BULK		2
#define	UIPROTO_MASS_BULK_P		80

#define	UICLASS_HUB			0x09
#define UISUBCLASS_HUB			0

#define UICLASS_CDC_DATA		0x0a
#define UISUBCLASS_DATA			0
#define UIPROTO_DATA_ISDNBRI		0x30
#define	UIPROTO_DATA_HDLC		0x31
#define UIPROTO_DATA_TRANSPARENT	0x32
#define UIPROTO_DATA_Q921M		0x50
#define UIPROTO_DATA_Q921		0x51
#define UIPROTO_DATA_Q921TM		0x52
#define UIPROTO_DATA_V42BIS		0x90
#define UIPROTO_DATA_Q931		0x91
#define UIPROTO_DATA_V120		0x92
#define UIPROTO_DATA_CAPI		0x93
#define UIPROTO_DATA_HOST_BASED		0xfd
#define UIPROTO_DATA_PUF		0xfe
#define UIPROTO_DATA_VENDOR		0xff
d407 1
a407 1
#define UICLASS_FIRM_UPD		0x0c
d409 2
a410 2
#define UICLASS_APPL_SPEC		0xfe
#define UICLASS_VENDOR			0xff
d559 2
a560 2
			char			ue_devname[USB_MAX_DEVNAMELEN];
		} ue_driver;
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usb.h,v 1.38 1999/10/20 21:02:39 augustss Exp $	*/
d338 72
a409 48
#define UCLASS_UNSPEC		0
#define UCLASS_AUDIO		1
#define  USUBCLASS_AUDIOCONTROL	1
#define  USUBCLASS_AUDIOSTREAM	2
#define  USUBCLASS_MIDISTREAM	3
#define UCLASS_CDC		2 /* communication */
#define	 USUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
#define  USUBCLASS_ABSTRACT_CONTROL_MODEL	2
#define	 USUBCLASS_TELEPHONE_CONTROL_MODEL	3
#define	 USUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
#define	 USUBCLASS_CAPI_CONTROLMODEL		5
#define	 USUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
#define	 USUBCLASS_ATM_NETWORKING_CONTROL_MODEL	7
#define   UPROTO_CDC_AT		1
#define UCLASS_HID		3
#define  USUBCLASS_BOOT	 	1
#define UCLASS_PRINTER		7
#define  USUBCLASS_PRINTER	1
#define  UPROTO_PRINTER_UNI	1
#define  UPROTO_PRINTER_BI	2
#define UCLASS_MASS		8
#define  USUBCLASS_RBC		1
#define  USUBCLASS_SFF8020I	2
#define  USUBCLASS_QIC157	3
#define  USUBCLASS_UFI		4
#define  USUBCLASS_SFF8070I	5
#define  USUBCLASS_SCSI		6
#define  UPROTO_MASS_CBI_I	0
#define  UPROTO_MASS_CBI	1
#define  UPROTO_MASS_BULK	2
#define  UPROTO_MASS_BULK_P	80
#define UCLASS_HUB		9
#define  USUBCLASS_HUB		0
#define UCLASS_DATA		10
#define  USUBCLASS_DATA		0
#define   UPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
#define   UPROTO_DATA_HDLC		0x31    /* HDLC */
#define   UPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
#define   UPROTO_DATA_Q921M		0x50    /* Management for Q921 */
#define   UPROTO_DATA_Q921		0x51    /* Data for Q921 */
#define   UPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
#define   UPROTO_DATA_V42BIS		0x90    /* Data compression */  
#define   UPROTO_DATA_Q931		0x91    /* Euro-ISDN */
#define   UPROTO_DATA_V120		0x92    /* V.24 rate adaption */
#define   UPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
#define   UPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
#define   UPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
#define   UPROTO_DATA_VENDOR		0xff    /* Vendor specific */
d503 4
d508 1
d510 1
d516 1
d518 2
d524 1
a540 1
typedef struct { u_int32_t cookie; } usb_event_cookie_t;
d544 6
a549 3
#define USB_EVENT_ATTACH 1
#define USB_EVENT_DETACH 2
	struct usb_device_info	ue_device;
d551 10
a560 1
	usb_event_cookie_t	ue_cookie;
d574 1
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usb.h,v 1.12 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: usb.h,v 1.50 2000/06/01 15:43:32 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.h,v 1.14 1999/11/17 22:33:46 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d79 1
a79 1
 * and endian problem and should always be used to access non-byte
a83 5
typedef u_int8_t uDWord[4];

#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))

#if 1
d86 2
a92 1
#else
d97 1
a99 2
#define UGETDW(w) (*(u_int32_t *)(w))
#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
a101 2
#define UPACKED __attribute__((__packed__))

d108 1
a108 1
} UPACKED usb_device_request_t;
d177 1
a177 1
} UPACKED usb_descriptor_t;
d195 1
a195 1
} UPACKED usb_device_descriptor_t;
d211 1
a211 1
} UPACKED usb_config_descriptor_t;
d224 1
a224 1
} UPACKED usb_interface_descriptor_t;
d251 1
a251 1
} UPACKED usb_endpoint_descriptor_t;
d258 1
a258 1
} UPACKED usb_string_descriptor_t;
d301 3
a303 3
	/* deprecated */ uByte		PortPowerCtrlMask[1];
} UPACKED usb_hub_descriptor_t;
#define USB_HUB_DESCRIPTOR_SIZE 9 /* includes deprecated PortPowerCtrlMask */
d312 1
a312 1
} UPACKED usb_status_t;
d319 1
a319 1
} UPACKED usb_hub_status_t;
d336 1
a336 69
} UPACKED usb_port_status_t;

/* Device class codes */
#define UDCLASS_AUDIO		0x00
#define UDCLASS_COMM		0x02
#define UDCLASS_HID		0x00
#define UDCLASS_HUB		0x09
#define  UDSUBCLASS_HUB		0
#define UDCLASS_MASS		0x00

/* Interface class codes */
#define UICLASS_UNSPEC		0x00

#define UICLASS_AUDIO		0x01
#define  UISUBCLASS_AUDIOCONTROL	1
#define  UISUBCLASS_AUDIOSTREAM		2
#define  UISUBCLASS_MIDISTREAM		3

#define UICLASS_CDC		0x02 /* communication */
#define	 UISUBCLASS_DIRECT_LINE_CONTROL_MODEL	1
#define  UISUBCLASS_ABSTRACT_CONTROL_MODEL	2
#define	 UISUBCLASS_TELEPHONE_CONTROL_MODEL	3
#define	 UISUBCLASS_MULTICHANNEL_CONTROL_MODEL	4
#define	 UISUBCLASS_CAPI_CONTROLMODEL		5
#define	 UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL 6
#define	 UISUBCLASS_ATM_NETWORKING_CONTROL_MODEL 7
#define   UIPROTO_CDC_AT			1

#define UICLASS_HID		0x03
#define  UISUBCLASS_BOOT	1
#define  UIPROTO_BOOT_KEYBOARD	1

#define UICLASS_PHYSICAL	0x05

#define UICLASS_PRINTER		0x07
#define  UISUBCLASS_PRINTER	1
#define  UIPROTO_PRINTER_UNI	1
#define  UIPROTO_PRINTER_BI	2

#define UICLASS_MASS		0x08
#define  UISUBCLASS_RBC		1
#define  UISUBCLASS_SFF8020I	2
#define  UISUBCLASS_QIC157	3
#define  UISUBCLASS_UFI		4
#define  UISUBCLASS_SFF8070I	5
#define  UISUBCLASS_SCSI	6
#define  UIPROTO_MASS_CBI_I	0
#define  UIPROTO_MASS_CBI	1
#define  UIPROTO_MASS_BBB	2
#define  UIPROTO_MASS_BBB_P	80	/* 'P' for the Iomega Zip drive */

#define UICLASS_HUB		0x09
#define  UISUBCLASS_HUB		0

#define UICLASS_CDC_DATA	0x0a
#define  UISUBCLASS_DATA		0
#define   UIPROTO_DATA_ISDNBRI		0x30    /* Physical iface */
#define   UIPROTO_DATA_HDLC		0x31    /* HDLC */
#define   UIPROTO_DATA_TRANSPARENT	0x32    /* Transparent */
#define   UIPROTO_DATA_Q921M		0x50    /* Management for Q921 */
#define   UIPROTO_DATA_Q921		0x51    /* Data for Q921 */
#define   UIPROTO_DATA_Q921TM		0x52    /* TEI multiplexer for Q921 */
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */  
#define   UIPROTO_DATA_Q931		0x91    /* Euro-ISDN */
#define   UIPROTO_DATA_V120		0x92    /* V.24 rate adaption */
#define   UIPROTO_DATA_CAPI		0x93    /* CAPI 2.0 commands */
#define   UIPROTO_DATA_HOST_BASED	0xfd    /* Host based driver */
#define   UIPROTO_DATA_PUF		0xfe    /* see Prot. Unit Func. Desc.*/
#define   UIPROTO_DATA_VENDOR		0xff    /* Vendor specific */
d338 48
a385 4
#define UICLASS_FIRM_UPD	0x0c

#define UICLASS_APPL_SPEC	0xfe
#define UICLASS_VENDOR		0xff
d403 1
a403 1
#define USB_RESUME_DELAY	(20*5)  /* ms */
a405 1
#define USB_EXTRA_POWER_UP_TIME	0   /* ms */
a414 1
#define USB_EXTRA_POWER_UP_TIME	20  /* ms */
a421 4

#define USB_UNCONFIG_NO 0
#define USB_UNCONFIG_INDEX (-1)

a478 4
typedef struct { u_int32_t cookie; } usb_event_cookie_t;

#define USB_MAX_DEVNAMES 4
#define USB_MAX_DEVNAMELEN 16
a479 1
	u_int8_t	bus;
a480 1
	usb_event_cookie_t cookie;
a485 1
	u_int16_t	releaseNo;
a486 2
	u_int8_t	subclass;
	u_int8_t	protocol;
a490 1
	char		devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
d507 1
d511 3
a513 7
#define USB_EVENT_CTRLR_ATTACH 1
#define USB_EVENT_CTRLR_DETACH 2
#define USB_EVENT_DEVICE_ATTACH 3
#define USB_EVENT_DEVICE_DETACH 4
#define USB_EVENT_DRIVER_ATTACH 5
#define USB_EVENT_DRIVER_DETACH 6
#define USB_EVENT_IS_ATTACH(n) ((n) == USB_EVENT_CTRLR_ATTACH || (n) == USB_EVENT_DEVICE_ATTACH || (n) == USB_EVENT_DRIVER_ATTACH)
d515 1
a515 10
	union {
		struct {
			int			ue_bus;
		} ue_ctrlr;
		struct usb_device_info		ue_device;
		struct {
			usb_event_cookie_t	ue_cookie;
			char			ue_devname[16];
		} ue_driver;			
	} u;
a528 1
#define USB_SET_REPORT		_IOW ('U', 24, struct usb_ctl_report)
@


1.6.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.6.2.1 2001/05/14 22:26:24 niklas Exp $ */
a381 1
#define  UIPROTO_PRINTER_IEEE_1284_4	3
@


1.6.2.3
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb.h,v 1.52 2001/07/23 15:17:50 nathanw Exp $	*/
d382 1
a382 1
#define  UIPROTO_PRINTER_1284	3
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@a68 2
#define USB_STACK_VERSION 2

d98 1
a98 1
/*
d407 1
a407 1
#define   UIPROTO_DATA_V42BIS		0x90    /* Data compression */
d423 2
a424 2
/*
 * Minimum time a device needs to be powered down to go through
d464 4
a467 4
	int	ucr_addr;
	usb_device_request_t ucr_request;
	void	*ucr_data;
	int	ucr_flags;
d469 1
a469 1
	int	ucr_actlen;		/* actual length transferred */
d473 3
a475 3
	int	uai_config_index;
	int	uai_interface_index;
	int	uai_alt_no;
d482 2
a483 2
	int	ucd_config_index;
	usb_config_descriptor_t ucd_desc;
d487 4
a490 4
	int	uid_config_index;
	int	uid_interface_index;
	int	uid_alt_index;
	usb_interface_descriptor_t uid_desc;
d494 5
a498 5
	int	ued_config_index;
	int	ued_interface_index;
	int	ued_alt_index;
	int	ued_endpoint_index;
	usb_endpoint_descriptor_t ued_desc;
d502 3
a504 3
	int	ufd_config_index;
	u_int	ufd_size;
	u_char	*ufd_data;
d508 3
a510 3
	int	usd_string_index;
	int	usd_language_id;
	usb_string_descriptor_t usd_desc;
d514 2
a515 2
	int	ucrd_size;
	u_char	ucrd_data[1024];	/* filled data size will vary */
d523 18
a540 18
	u_int8_t	udi_bus;
	u_int8_t	udi_addr;	/* device address */
	usb_event_cookie_t udi_cookie;
	char		udi_product[USB_MAX_STRING_LEN];
	char		udi_vendor[USB_MAX_STRING_LEN];
	char		udi_release[8];
	u_int16_t	udi_productNo;
	u_int16_t	udi_vendorNo;
	u_int16_t	udi_releaseNo;
	u_int8_t	udi_class;
	u_int8_t	udi_subclass;
	u_int8_t	udi_protocol;
	u_int8_t	udi_config;
	u_int8_t	udi_lowspeed;
	int		udi_power;	/* power consumption in mA, 0 if selfpowered */
	int		udi_nports;
	char		udi_devnames[USB_MAX_DEVNAMES][USB_MAX_DEVNAMELEN];
	u_int8_t	udi_ports[16];/* hub only: addresses of devices on ports */
d548 2
a549 2
	int	ucr_report;
	u_char	ucr_data[1024];	/* filled data size will vary */
d553 1
a553 1
	u_long	uds_requests[4];	/* indexed by transfer type UE_* */
d575 1
a575 1
		} ue_driver;
a590 1
#define USB_GET_REPORT_ID	_IOR ('U', 25, int)
@


1.6.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.h,v 1.6.2.4 2003/03/28 00:38:32 niklas Exp $ */
d395 2
a396 2
#define  UIPROTO_MASS_BBB_OLD	2	/* Not in the spec anymore */
#define  UIPROTO_MASS_BBB	80	/* 'P' for the Iomega Zip drive */
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb.h,v 1.69 2002/09/22 23:20:50 augustss Exp $	*/
a50 6
#endif
#if defined(__FreeBSD__)
/* These two defines are used by usbd to autoload the usb kld */
#define USB_KLD		"usb"           /* name of usb module */
#define USB_UHUB	"usb/uhub"      /* root hub */
#endif
d56 13
d110 1
a110 1
#define UPACKED __packed
a163 4
#define  UDESC_DEVICE_QUALIFIER	0x06
#define  UDESC_OTHER_SPEED_CONFIGURATION 0x07
#define  UDESC_INTERFACE_POWER	0x08
#define  UDESC_OTG		0x09
a179 1
#define UF_TEST_MODE		2
a182 3
#define USB_2_MAX_CTRL_PACKET	64
#define USB_2_MAX_BULK_PACKET	512

a192 2
#define UD_USB_2_0		0x0200
#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
a273 4
#define UR_CLEAR_TT_BUFFER	0x08
#define UR_RESET_TT		0x09
#define UR_GET_TT_STATE		0x0a
#define UR_STOP_TT		0x0b
a289 2
#define UHF_PORT_TEST		21
#define UHF_PORT_INDICATOR	22
d296 9
a304 15
#define UHD_PWR			0x0003
#define  UHD_PWR_GANGED		0x0000
#define  UHD_PWR_INDIVIDUAL	0x0001
#define  UHD_PWR_NO_SWITCH	0x0002
#define UHD_COMPOUND		0x0004
#define UHD_OC			0x0018
#define  UHD_OC_GLOBAL		0x0000
#define  UHD_OC_INDIVIDUAL	0x0008
#define  UHD_OC_NONE		0x0010
#define UHD_TT_THINK		0x0060
#define  UHD_TT_THINK_8		0x0000
#define  UHD_TT_THINK_16	0x0020
#define  UHD_TT_THINK_24	0x0040
#define  UHD_TT_THINK_32	0x0060
#define UHD_PORT_IND		0x0080
a315 26
	uByte		bLength;
	uByte		bDescriptorType;
	uWord		bcdUSB;
	uByte		bDeviceClass;
	uByte		bDeviceSubClass;
	uByte		bDeviceProtocol;
	uByte		bMaxPacketSize0;
	uByte		bNumConfigurations;
	uByte		bReserved;
} UPACKED usb_device_qualifier_t;
#define USB_DEVICE_QUALIFIER_SIZE 10

typedef struct {
	uByte		bLength;
	uByte		bDescriptorType;
	uByte		bmAttributes;
#define UOTG_SRP	0x01
#define UOTG_HNP	0x02
} UPACKED usb_otg_descriptor_t;

/* OTG feature selectors */
#define UOTG_B_HNP_ENABLE	3
#define UOTG_A_HNP_SUPPORT	4
#define UOTG_A_ALT_HNP_SUPPORT	5

typedef struct {
a339 3
#define UPS_HIGH_SPEED			0x0400
#define UPS_PORT_TEST			0x0800
#define UPS_PORT_INDICATOR		0x1000
d349 1
a349 1
#define UDCLASS_IN_INTERFACE	0x00
d351 1
d353 2
a354 9
#define  UDSUBCLASS_HUB		0x00
#define  UDPROTO_FSHUB		0x00
#define  UDPROTO_HSHUBSTT	0x01
#define  UDPROTO_HSHUBMTT	0x02
#define UDCLASS_DIAGNOSTIC	0xdc
#define UDCLASS_WIRELESS	0xe0
#define  UDSUBCLASS_RF		0x01
#define   UDPROTO_BLUETOOTH	0x01
#define UDCLASS_VENDOR		0xff
a379 2
#define UICLASS_IMAGE		0x06

a399 3
#define  UIPROTO_FSHUB		0
#define  UIPROTO_HSHUBSTT	0 /* Yes, same as previous */
#define  UIPROTO_HSHUBMTT	1
d417 1
a417 11
#define UICLASS_SMARTCARD	0x0b

/*#define UICLASS_FIRM_UPD	0x0c*/

#define UICLASS_SECURITY	0x0d

#define UICLASS_DIAGNOSTIC	0xdc

#define UICLASS_WIRELESS	0xe0
#define  UISUBCLASS_RF			0x01
#define   UIPROTO_BLUETOOTH		0x01
a419 4
#define  UISUBCLASS_FIRMWARE_DOWNLOAD	1
#define  UISUBCLASS_IRDA		2
#define  UIPROTO_IRDA			0

d435 1
a435 2
#define USB_PORT_ROOT_RESET_DELAY 50  /* ms */
#define USB_PORT_RESET_RECOVERY	10  /* ms */
d445 2
a446 3
#define USB_PORT_ROOT_RESET_DELAY 250  /* ms */
#define USB_PORT_RESET_RECOVERY	250  /* ms */
#define USB_PORT_POWERUP_DELAY	300 /* ms */
d538 1
a538 4
	u_int8_t	udi_speed;
#define USB_SPEED_LOW  1
#define USB_SPEED_FULL 2
#define USB_SPEED_HIGH 3
a567 1
#define USB_EVENT_IS_DETACH(n) ((n) == USB_EVENT_CTRLR_DETACH || (n) == USB_EVENT_DEVICE_DETACH || (n) == USB_EVENT_DRIVER_DETACH)
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usb.h,v 1.34 1999/09/16 21:53:58 augustss Exp $	*/
d46 2
d56 1
a58 1
#if defined(KERNEL)
d149 11
a159 5
#define  UDESC_DEVICE		1
#define  UDESC_CONFIG		2
#define  UDESC_STRING		3
#define  UDESC_INTERFACE	4
#define  UDESC_ENDPOINT		5
d232 1
d243 1
d248 1
a337 8
#define UDESC_CS_DEVICE		0x21
#define UDESC_CS_CONFIG		0x22
#define UDESC_CS_STRING		0x23
#define UDESC_CS_INTERFACE	0x24
#define UDESC_CS_ENDPOINT	0x25

#define UDESC_HUB		0x29

d372 15
d499 1
a499 1
	int report;
d505 11
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d2 1
a2 1
/*	$NetBSD: usb.h,v 1.30 1999/08/29 22:45:41 augustss Exp $	*/
d223 3
a225 2
#define UE_IN		0x80
#define UE_OUT		0x00
a227 2
#define UE_GET_IN(a)	(((a) >> 7) & 1)
#define UE_GET_DIR(a)	((a) & 0x80)
d339 1
d364 2
a365 2
#define  UPROTO_MASS_BULK	80
#define  UPROTO_MASS_BULK2	2
d411 1
a411 2
/* XXX must match flags in usbdi.h */
#define USBD_SHORT_XFER_OK	0x04
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.h,v 1.2 1999/08/19 08:18:39 fgsch Exp $	*/
/*	$NetBSD: usb.h,v 1.27 1999/08/18 07:55:19 augustss Exp $	*/
d127 1
d131 1
d135 1
d139 1
@


1.2
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 1
#endif
a48 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d224 1
d358 4
a361 2
#define  UPROTO_MASS_CBI_C	0
#define  UPROTO_MASS_CBI_NC	1
d513 1
@


1.1
log
@From NetBSD; USB support.
@
text
@d2 1
a2 1
/*	$NetBSD: usb.h,v 1.23 1999/06/30 06:44:23 augustss Exp $	*/
d512 4
@

