head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.14
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.8
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.10
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.8
	OPENBSD_5_0:1.14.0.6
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13;
locks; strict;
comment	@ * @;


1.20
date	2016.09.16.11.13.37;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	3p5sLyRWGR6PDmnl;

1.19
date	2013.11.21.14.08.05;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.08.10.12.20;	author pirofti;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.29.10.01.20;	author mpi;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.20.10.51.27;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2010.07.08.18.22.01;	author ckuethe;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.07.17.17.33;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.07.16.20.32;	author fabien;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.07.16.03.29;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.07.14.43.06;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.07.08.58.55;	author mk;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.06.19.04.57;	author armani;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.04.20.23.45;	author armani;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.03.19.01.03;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.02.20.54.27;	author mk;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.02.20.51.42;	author mk;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.02.20.46.02;	author mk;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.02.20.27.25;	author mk;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.01.23.35.56;	author mk;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Switch urndis(4) over to the generic RNDIS header
@
text
@/*	$OpenBSD: if_urndisreg.h,v 1.19 2013/11/21 14:08:05 mpi Exp $ */

/*
 * Copyright (c) 2010 Jonathan Armani <armani@@openbsd.org>
 * Copyright (c) 2010 Fabien Romano <fabien@@openbsd.org>
 * Copyright (c) 2010 Michael Knudsen <mk@@openbsd.org>
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define RNDIS_RX_LIST_CNT	1
#define RNDIS_TX_LIST_CNT	1
#define RNDIS_BUFSZ		1562

struct urndis_chain {
	struct urndis_softc	*sc_softc;
	struct usbd_xfer	*sc_xfer;
	char			*sc_buf;
	struct mbuf		*sc_mbuf;
	int			 sc_idx;
};

struct urndis_cdata {
	struct urndis_chain	sc_rx_chain[RNDIS_RX_LIST_CNT];
	struct urndis_chain	sc_tx_chain[RNDIS_TX_LIST_CNT];
	int			sc_tx_cnt;
};

#define GET_IFP(sc) (&(sc)->sc_arpcom.ac_if)
struct urndis_softc {
	struct device			sc_dev;

	char				sc_attached;
	struct arpcom			sc_arpcom;

	/* RNDIS device info */
	u_int32_t			sc_lim_pktsz;
	u_int32_t			sc_filter;

	/* USB goo */
	struct usbd_device		*sc_udev;
	int				sc_ifaceno_ctl;
	struct usbd_interface		*sc_iface_data;

	struct timeval			sc_rx_notice;
	int				sc_bulkin_no;
	struct usbd_pipe		*sc_bulkin_pipe;
	int				sc_bulkout_no;
	struct usbd_pipe		*sc_bulkout_pipe;

	struct urndis_cdata		sc_data;
};
@


1.19
log
@Revert r1.41, in this driver sc_attached does not indicate that the
driver is not yet attached, it is here to prevent the driver to free
unitialized structures in case something wrong happened during the
the initialization...

Found the hard way and ok giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.18 2013/11/08 10:12:20 pirofti Exp $ */
a63 241

#define RNDIS_STATUS_BUFFER_OVERFLOW 	0x80000005L
#define RNDIS_STATUS_FAILURE 		0xC0000001L
#define RNDIS_STATUS_INVALID_DATA 	0xC0010015L
#define RNDIS_STATUS_MEDIA_CONNECT 	0x4001000BL
#define RNDIS_STATUS_MEDIA_DISCONNECT 	0x4001000CL
#define RNDIS_STATUS_NOT_SUPPORTED 	0xC00000BBL
#define RNDIS_STATUS_PENDING 		STATUS_PENDING /* XXX */
#define RNDIS_STATUS_RESOURCES 		0xC000009AL
#define RNDIS_STATUS_SUCCESS 		0x00000000L

#define	OID_GEN_SUPPORTED_LIST		0x00010101
#define	OID_GEN_HARDWARE_STATUS		0x00010102
#define	OID_GEN_MEDIA_SUPPORTED		0x00010103
#define	OID_GEN_MEDIA_IN_USE		0x00010104
#define	OID_GEN_MAXIMUM_LOOKAHEAD	0x00010105
#define	OID_GEN_MAXIMUM_FRAME_SIZE	0x00010106
#define	OID_GEN_LINK_SPEED		0x00010107
#define	OID_GEN_TRANSMIT_BUFFER_SPACE	0x00010108
#define	OID_GEN_RECEIVE_BUFFER_SPACE	0x00010109
#define	OID_GEN_TRANSMIT_BLOCK_SIZE	0x0001010A
#define	OID_GEN_RECEIVE_BLOCK_SIZE	0x0001010B
#define	OID_GEN_VENDOR_ID		0x0001010C
#define	OID_GEN_VENDOR_DESCRIPTION	0x0001010D
#define	OID_GEN_CURRENT_PACKET_FILTER	0x0001010E
#define	OID_GEN_CURRENT_LOOKAHEAD	0x0001010F
#define	OID_GEN_DRIVER_VERSION		0x00010110
#define	OID_GEN_MAXIMUM_TOTAL_SIZE	0x00010111
#define	OID_GEN_PROTOCOL_OPTIONS	0x00010112
#define	OID_GEN_MAC_OPTIONS		0x00010113
#define	OID_GEN_MEDIA_CONNECT_STATUS	0x00010114
#define	OID_GEN_MAXIMUM_SEND_PACKETS	0x00010115
#define	OID_GEN_VENDOR_DRIVER_VERSION	0x00010116
#define	OID_GEN_SUPPORTED_GUIDS		0x00010117
#define	OID_GEN_NETWORK_LAYER_ADDRESSES	0x00010118
#define	OID_GEN_TRANSPORT_HEADER_OFFSET	0x00010119
#define	OID_GEN_MACHINE_NAME		0x0001021A
#define	OID_GEN_RNDIS_CONFIG_PARAMETER	0x0001021B
#define	OID_GEN_VLAN_ID			0x0001021C

#define	OID_802_3_PERMANENT_ADDRESS	0x01010101
#define	OID_802_3_CURRENT_ADDRESS	0x01010102
#define	OID_802_3_MULTICAST_LIST	0x01010103
#define	OID_802_3_MAXIMUM_LIST_SIZE	0x01010104
#define	OID_802_3_MAC_OPTIONS		0x01010105
#define	OID_802_3_RCV_ERROR_ALIGNMENT	0x01020101
#define	OID_802_3_XMIT_ONE_COLLISION	0x01020102
#define	OID_802_3_XMIT_MORE_COLLISIONS	0x01020103
#define	OID_802_3_XMIT_DEFERRED		0x01020201
#define	OID_802_3_XMIT_MAX_COLLISIONS	0x01020202
#define	OID_802_3_RCV_OVERRUN		0x01020203
#define	OID_802_3_XMIT_UNDERRUN		0x01020204
#define	OID_802_3_XMIT_HEARTBEAT_FAILURE	0x01020205
#define	OID_802_3_XMIT_TIMES_CRS_LOST	0x01020206
#define	OID_802_3_XMIT_LATE_COLLISIONS	0x01020207

#define RNDIS_MEDIUM_802_3		0x00000000

/* Device flags */
#define RNDIS_DF_CONNECTIONLESS		0x00000001
#define RNDIS_DF_CONNECTION_ORIENTED	0x00000002

/*
 * RNDIS data message
 */
#define REMOTE_NDIS_PACKET_MSG		0x00000001


struct urndis_packet_msg {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_dataoffset;
	u_int32_t	rm_datalen;
	u_int32_t	rm_oobdataoffset;
	u_int32_t	rm_oobdatalen;
	u_int32_t	rm_oobdataelements;
	u_int32_t	rm_pktinfooffset;
	u_int32_t	rm_pktinfolen;
	u_int32_t	rm_vchandle;
	u_int32_t	rm_reserved;
};

/*
 * RNDIS control messages
 */
struct urndis_comp_hdr {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_status;
};

/* Initialize the device. */
#define REMOTE_NDIS_INITIALIZE_MSG	0x00000002
#define REMOTE_NDIS_INITIALIZE_CMPLT	0x80000002

struct urndis_init_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_ver_major;
	u_int32_t	rm_ver_minor;
	u_int32_t	rm_max_xfersz;
};

struct urndis_init_comp {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_status;
	u_int32_t	rm_ver_major;
	u_int32_t	rm_ver_minor;
	u_int32_t	rm_devflags;
	u_int32_t	rm_medium;
	u_int32_t	rm_pktmaxcnt;
	u_int32_t	rm_pktmaxsz;
	u_int32_t	rm_align;
	u_int32_t	rm_aflistoffset;
	u_int32_t	rm_aflistsz;
};

/* Halt the device.  No response sent. */
#define REMOTE_NDIS_HALT_MSG		0x00000003

struct urndis_halt_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
};

/* Send a query object. */
#define REMOTE_NDIS_QUERY_MSG		0x00000004
#define REMOTE_NDIS_QUERY_CMPLT		0x80000004

struct urndis_query_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_oid;
	u_int32_t	rm_infobuflen;
	u_int32_t	rm_infobufoffset;
	u_int32_t	rm_devicevchdl;
};

struct urndis_query_comp {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_status;
	u_int32_t	rm_infobuflen;
	u_int32_t	rm_infobufoffset;
};

/* Send a set object request. */
#define REMOTE_NDIS_SET_MSG		0x00000005
#define REMOTE_NDIS_SET_CMPLT		0x80000005

struct urndis_set_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_oid;
	u_int32_t	rm_infobuflen;
	u_int32_t	rm_infobufoffset;
	u_int32_t	rm_devicevchdl;
};

struct urndis_set_comp {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_status;
};

#define REMOTE_NDIS_SET_PARAM_NUMERIC	0x00000000
#define REMOTE_NDIS_SET_PARAM_STRING	0x00000002

struct urndis_set_parameter {
	u_int32_t	rm_nameoffset;
	u_int32_t	rm_namelen;
	u_int32_t	rm_type;
	u_int32_t	rm_valueoffset;
	u_int32_t	rm_valuelen;
};

/* Perform a soft reset on the device. */
#define REMOTE_NDIS_RESET_MSG		0x00000006
#define REMOTE_NDIS_RESET_CMPLT		0x80000006

struct urndis_reset_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
};

struct urndis_reset_comp {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_status;
	u_int32_t	rm_adrreset;
};

/* 802.3 link-state or undefined message error. */
#define REMOTE_NDIS_INDICATE_STATUS_MSG	0x00000007

/* Keepalive messsage.  May be sent by device. */
#define REMOTE_NDIS_KEEPALIVE_MSG	0x00000008
#define REMOTE_NDIS_KEEPALIVE_CMPLT	0x80000008

struct urndis_keepalive_req {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
};

struct urndis_keepalive_comp {
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	u_int32_t	rm_rid;
	u_int32_t	rm_status;
};

/* packet filter bits used by OID_GEN_CURRENT_PACKET_FILTER */
#define RNDIS_PACKET_TYPE_DIRECTED		0x00000001
#define RNDIS_PACKET_TYPE_MULTICAST		0x00000002
#define RNDIS_PACKET_TYPE_ALL_MULTICAST		0x00000004
#define RNDIS_PACKET_TYPE_BROADCAST		0x00000008
#define RNDIS_PACKET_TYPE_SOURCE_ROUTING	0x00000010
#define RNDIS_PACKET_TYPE_PROMISCUOUS		0x00000020
#define RNDIS_PACKET_TYPE_SMT			0x00000040
#define RNDIS_PACKET_TYPE_ALL_LOCAL		0x00000080
#define RNDIS_PACKET_TYPE_GROUP			0x00001000
#define RNDIS_PACKET_TYPE_ALL_FUNCTIONAL	0x00002000
#define RNDIS_PACKET_TYPE_FUNCTIONAL		0x00004000
#define RNDIS_PACKET_TYPE_MAC_FRAME		0x00008000

/* Rndis offsets */
#define RNDIS_HEADER_OFFSET	(sizeof(u_int32_t) * 2)
#define RNDIS_DATA_OFFSET	(sizeof(struct urndis_packet_msg) - \
    				 offsetof(struct urndis_packet_msg, \
    				 rm_dataoffset))
@


1.18
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.17 2013/10/29 10:01:20 mpi Exp $ */
d44 1
@


1.17
log
@Kill sc_attached, attach and detach events for USB devices are triggered
by the same explore task and cannot happen in parallel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.16 2013/04/15 09:23:01 mglocker Exp $ */
a43 1
	int				sc_dying;
@


1.16
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.15 2012/06/20 10:51:27 fgsch Exp $ */
a43 1
	char				sc_attached;
@


1.15
log
@- urndis_match() should support multiple interface descriptors.
- in urndis_attach() use the first interface descriptor that's different
  from the control interface as the data interface.

from armani's colleague with some tweaks by me.
kettenis@@ sthen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.14 2010/07/08 18:22:01 ckuethe Exp $ */
d28 1
a28 1
	usbd_xfer_handle	 sc_xfer;
d53 1
a53 1
	usbd_device_handle		sc_udev;
d55 1
a55 1
	usbd_interface_handle		sc_iface_data;
d59 1
a59 1
	usbd_pipe_handle		sc_bulkin_pipe;
d61 1
a61 1
	usbd_pipe_handle		sc_bulkout_pipe;
@


1.14
log
@make the buffer big enough to hold a 1500 byte packet. Workaround (mtu
decrease) by me, fix from armani@@ (who seems to be away right now). ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.13 2010/03/07 17:17:33 mk Exp $ */
a54 1
	usbd_interface_handle		sc_iface_ctl;
@


1.13
log
@Garbage collect a softc member that we don't use because we don't do
multipacket tx.

ok fabien "if you commit over urndis" armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.12 2010/03/07 16:20:32 fabien Exp $ */
d24 1
a24 1
#define RNDIS_BUFSZ		1542
@


1.12
log
@Update my address, while there update armani's too per his request.

ok armani, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.11 2010/03/07 16:03:29 mk Exp $ */
a49 1
	u_int32_t			sc_pktalign;
@


1.11
log
@Some cleanup and dead code removal to bring us in line with other
usb ethernet drivers.

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.8 2010/03/06 19:04:57 armani Exp $ */
d4 2
a5 2
 * Copyright (c) 2010 Jonathan Armani <dbd@@asystant.net>
 * Copyright (c) 2010 Fabien Romano <fromano@@asystant.net>
@


1.10
log
@We're only sending one packet at a time, so garbage collect sc_lim_pktcnt
that shows how many packets the device will accept in one transfer.

ok armani fabien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.9 2010/03/07 08:58:55 mk Exp $ */
d59 1
@


1.9
log
@Garbage collect some struct members that we don't use.

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.8 2010/03/06 19:04:57 armani Exp $ */
a48 1
	u_int32_t			sc_lim_pktcnt;
@


1.8
log
@Forgot this one, sorry, reported by maja@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.7 2010/03/04 20:23:45 armani Exp $ */
a30 1
	int			 sc_accum;
a36 2
	int			sc_tx_prod;
	int			sc_tx_cons;
a37 1
	int			sc_rx_prod;
@


1.7
log
@Add defines for header and data offset, offsetof() uses from mk@@.

ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.6 2010/03/03 19:01:03 mk Exp $ */
d48 1
@


1.6
log
@When I first started on urndis, I didn't realise that all values were
u_int32_ts, so I made some typedefs for certain types.  It's just
pointless, so get rid of them.

Jonathan and Fabien agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.5 2010/03/02 20:54:27 mk Exp $ */
d137 1
d305 6
@


1.5
log
@Rename sc_sc to sc_softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.4 2010/03/02 20:51:42 mk Exp $ */
a70 2
typedef u_int32_t urndis_status;

a80 4
typedef u_int32_t urndis_req_id; /* seq nr. */

typedef u_int32_t urndis_oid;

a109 1

a125 1
typedef u_int32_t urndis_medium;
d157 2
a158 2
	urndis_req_id	rm_rid;
	urndis_status	rm_status;
d168 1
a168 1
	urndis_req_id	rm_rid;
d177 2
a178 2
	urndis_req_id	rm_rid;
	urndis_status	rm_status;
d182 1
a182 1
	urndis_medium	rm_medium;
d196 1
a196 1
	urndis_req_id	rm_rid;
d206 2
a207 2
	urndis_req_id	rm_rid;
	urndis_oid	rm_oid;
d216 2
a217 2
	urndis_req_id	rm_rid;
	urndis_status	rm_status;
d229 2
a230 2
	urndis_req_id	rm_rid;
	urndis_oid	rm_oid;
d239 2
a240 2
	urndis_req_id	rm_rid;
	urndis_status	rm_status;
d261 1
a261 1
	urndis_req_id	rm_rid;
d267 1
a267 1
	urndis_status	rm_status;
d281 1
a281 1
	urndis_req_id	rm_rid;
d287 2
a288 2
	urndis_req_id	rm_rid;
	urndis_status	rm_status;
@


1.4
log
@Remove some XXXs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.3 2010/03/02 20:46:02 mk Exp $ */
d27 1
a27 1
	struct urndis_softc	*sc_sc;
@


1.3
log
@Zap unused struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.2 2010/03/02 20:27:25 mk Exp $ */
d155 1
a155 1
	u_int32_t	rm_vchandle; /* XXX zero */
d218 1
a218 1
	u_int32_t	rm_devicevchdl; /* XXX DeviceVcHandle */
d241 1
a241 1
	u_int32_t	rm_devicevchdl; /* XXX DeviceVcHandle */
@


1.2
log
@Get rid of the code that deals with the interrupt pipe.  The current
code doesn't do anything at the moment, so no point in keeping it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndisreg.h,v 1.1 2010/03/01 23:35:56 mk Exp $ */
a280 13

struct urndis_status_msg { /* XXX unhappy about the name */
	u_int32_t	rm_type;
	u_int32_t	rm_len;
	urndis_status	rm_status;
	u_int32_t	rm_statusbuflen;
	u_int32_t	rm_statusbufoffset;
	urndis_status	rm_diagstatus;
	u_int32_t	rm_erroroffset;
#if 0
	(RNDIS_MESSAGE) Message; /* XXX */
#endif
};
@


1.1
log
@Add urndis(4), a driver for RNDIS Ethernet over USB.

It provides an Ethernet transport typically over EDGE or 3G on
cellphones similar to what cdce(4) does on other phones.  It is
likely to work with most of HTC's recent and coming Android based
phones but a bunch of other things (phones in particular) may use
it.

Started by me; brought to a working state by Jonathan Armani and
Fabien Romano over the past week, with some input and additions
from me.

Tested on i386 and macppc by me (HTC Hero), amd64 by Jonathan and
Fabien (HTC Hero), and by gilles@@ (HTC Magic) on i386 or amd64.

It still has a few kinks to work out, but it works well enough that
I can commit this over my HTC Hero.

`commit it!' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a25 5
struct urndis_notification {
	u_int32_t	notification;
	u_int32_t	reserved;
};

a61 5

	int				sc_intr_no;
	usbd_pipe_handle		sc_intr_pipe;
	int				sc_intr_size;
	struct urndis_notification	sc_intr_buf;
@

