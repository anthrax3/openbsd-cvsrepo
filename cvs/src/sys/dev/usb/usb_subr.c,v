head	1.132;
access;
symbols
	OPENBSD_6_1:1.132.0.4
	OPENBSD_6_1_BASE:1.132
	OPENBSD_6_0:1.123.0.4
	OPENBSD_6_0_BASE:1.123
	OPENBSD_5_9:1.119.0.2
	OPENBSD_5_9_BASE:1.119
	OPENBSD_5_8:1.117.0.4
	OPENBSD_5_8_BASE:1.117
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.106.0.4
	OPENBSD_5_6_BASE:1.106
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.89.0.2
	OPENBSD_5_4_BASE:1.89
	OPENBSD_5_3:1.82.0.4
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.82.0.2
	OPENBSD_5_2_BASE:1.82
	OPENBSD_5_1_BASE:1.81
	OPENBSD_5_1:1.81.0.2
	OPENBSD_5_0:1.80.0.4
	OPENBSD_5_0_BASE:1.80
	OPENBSD_4_9:1.80.0.2
	OPENBSD_4_9_BASE:1.80
	OPENBSD_4_8:1.73.0.8
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.73.0.4
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.73.0.6
	OPENBSD_4_6_BASE:1.73
	OPENBSD_4_5:1.73.0.2
	OPENBSD_4_5_BASE:1.73
	OPENBSD_4_4:1.71.0.2
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.64.0.2
	OPENBSD_4_3_BASE:1.64
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.48.0.2
	OPENBSD_4_1_BASE:1.48
	OPENBSD_4_0:1.47.0.4
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.33.0.2
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.28.0.4
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.18.0.4
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.22
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.132
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.131;
commitid	x5RWYO05Q3UFL5Oq;

1.131
date	2016.09.19.16.46.10;	author mpi;	state Exp;
branches;
next	1.130;
commitid	yTbhdxv1FB7BxWOc;

1.130
date	2016.09.19.10.20.17;	author mpi;	state Exp;
branches;
next	1.129;
commitid	qwPPXq6wKvurfB8J;

1.129
date	2016.09.18.09.51.24;	author mpi;	state Exp;
branches;
next	1.128;
commitid	tjeR729Wihx6VUKv;

1.128
date	2016.09.12.07.43.10;	author mpi;	state Exp;
branches;
next	1.127;
commitid	BCw4keJGTUfDYVaj;

1.127
date	2016.09.02.11.14.17;	author mpi;	state Exp;
branches;
next	1.126;
commitid	4cOAvKxRZHzQ5kb4;

1.126
date	2016.09.02.10.57.48;	author mpi;	state Exp;
branches;
next	1.125;
commitid	x4Qex8E7sTlS63Tv;

1.125
date	2016.09.02.09.23.56;	author mpi;	state Exp;
branches;
next	1.124;
commitid	Xjo5lG8tXoXKQ7J5;

1.124
date	2016.09.02.09.20.00;	author mpi;	state Exp;
branches;
next	1.123;
commitid	tlVoSTj3Tw4CGrWn;

1.123
date	2016.05.23.11.31.12;	author mpi;	state Exp;
branches;
next	1.122;
commitid	osg2h5b1t4W1KLxf;

1.122
date	2016.05.21.10.40.45;	author patrick;	state Exp;
branches;
next	1.121;
commitid	UoZgt8kBftNgr9GB;

1.121
date	2016.05.18.18.28.58;	author patrick;	state Exp;
branches;
next	1.120;
commitid	SQX964uLUjZqy5aw;

1.120
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.119;
commitid	KhGZngmPmcr1rX2x;

1.119
date	2016.01.14.19.53.59;	author mpi;	state Exp;
branches;
next	1.118;
commitid	uHG1r5sVFkB8gN6y;

1.118
date	2015.10.24.14.01.40;	author stsp;	state Exp;
branches;
next	1.117;
commitid	2WZYrF2dZFbMRKeH;

1.117
date	2015.03.23.22.26.01;	author jsg;	state Exp;
branches;
next	1.116;
commitid	eUwaNadh00mgsxtd;

1.116
date	2014.12.21.12.04.01;	author mpi;	state Exp;
branches;
next	1.115;
commitid	zKT75AtayKC42yGo;

1.115
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.114;
commitid	20ZyHa9gTJxHxhwD;

1.114
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.113;
commitid	zM5ckwX4kwwmipG0;

1.113
date	2014.11.10.11.01.13;	author mpi;	state Exp;
branches;
next	1.112;
commitid	bF7jzK0vSp194wcF;

1.112
date	2014.11.01.14.44.08;	author mpi;	state Exp;
branches;
next	1.111;
commitid	BmycRw1mcwUuxLd7;

1.111
date	2014.11.01.10.21.02;	author mpi;	state Exp;
branches;
next	1.110;
commitid	ysE2z6FpLvLUXT0X;

1.110
date	2014.10.05.08.40.29;	author mpi;	state Exp;
branches;
next	1.109;
commitid	gcxpPOCDYm495eL7;

1.109
date	2014.10.01.08.29.01;	author mpi;	state Exp;
branches;
next	1.108;
commitid	42mUihNr4YGvv5ps;

1.108
date	2014.08.10.12.58.49;	author mpi;	state Exp;
branches;
next	1.107;
commitid	R52FwZgglxGj9KKP;

1.107
date	2014.08.09.09.45.14;	author mpi;	state Exp;
branches;
next	1.106;
commitid	MwiYUakpkX4F7pXj;

1.106
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.105;
commitid	OBNa5kfxQ2UXoiIw;

1.105
date	2014.07.12.07.18.16;	author mpi;	state Exp;
branches;
next	1.104;
commitid	E8K6ZSkqLtxVVkTW;

1.104
date	2014.07.12.07.11.17;	author mpi;	state Exp;
branches;
next	1.103;
commitid	eGR4gQfGJR7BlsN6;

1.103
date	2014.07.10.11.47.14;	author mpi;	state Exp;
branches;
next	1.102;
commitid	zDevcULA8IE8Qbas;

1.102
date	2014.07.09.18.15.04;	author mpi;	state Exp;
branches;
next	1.101;
commitid	7bxb660ER7iHPxAL;

1.101
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.100;
commitid	d8ZHVs7unt3KxWXc;

1.100
date	2014.03.08.11.42.56;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2014.03.07.18.59.40;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2014.02.09.13.21.48;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2014.02.09.11.47.01;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.15.11.10.40;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2013.11.19.14.04.07;	author pirofti;	state Exp;
branches;
next	1.94;

1.94
date	2013.11.02.12.23.58;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2013.08.21.13.45.34;	author mpi;	state Exp;
branches;
next	1.92;

1.92
date	2013.08.13.09.26.04;	author mpi;	state Exp;
branches;
next	1.91;

1.91
date	2013.08.08.09.44.22;	author mpi;	state Exp;
branches;
next	1.90;

1.90
date	2013.08.08.09.37.02;	author mpi;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.10.07.48.36;	author mpi;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.10.07.39.43;	author mpi;	state Exp;
branches;
next	1.86;

1.86
date	2013.04.09.08.42.48;	author mpi;	state Exp;
branches;
next	1.85;

1.85
date	2013.04.01.19.49.53;	author mglocker;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.16.11.11.22;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2012.05.15.12.52.44;	author mpi;	state Exp;
branches;
next	1.81;

1.81
date	2012.01.08.13.12.38;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.79;

1.79
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.15.23.58.43;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2010.12.17.22.38.54;	author jasper;	state Exp;
branches;
next	1.76;

1.76
date	2010.12.15.00.59.26;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.06.04.30.57;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.24.00.12.36;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2009.01.14.21.02.57;	author fgsch;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.24.15.12.00;	author yuo;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.03.02.02.14;	author fgsch;	state Exp;
branches;
next	1.70;

1.70
date	2008.07.28.20.49.28;	author fgsch;	state Exp;
branches;
next	1.69;

1.69
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.21.22.28.21;	author fgsch;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.19.15.51.43;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2008.05.19.14.05.43;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.04.05.52.36;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.10.11.18.30.50;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.06.23.50.55;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.09.18.36.13;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.09.01.00.35;	author fgsch;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.21.16.28.50;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.11.06.14.24;	author mbalmer;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.10.17.46.27;	author mbalmer;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.10.15.33.16;	author mbalmer;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.03.20.49.25;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2007.02.28.22.30.55;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.17.05.24.16;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.07.16.02.01.37;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.16.01.51.18;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.26.19.12.38;	author mjc;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.31.06.18.09;	author pascoe;	state Exp;
branches;
next	1.42;

1.42
date	2006.05.01.01.34.10;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.17.18.00.43;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.10.14.20.16;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.18.02.43.27;	author fgsch;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.21.08.47.57;	author pascoe;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.16.19.45.27;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2005.04.16.18.40.55;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.13.02.54.04;	author pascoe;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.12.06.13.15;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.08.22.01.02;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.02.21.28.55;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.31.12.10.52;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.30.03.06.48;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.18.18.13.22;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.03.22.02.10.22;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.27.04.02.10;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.07.20.38.56;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.04.11.44.25;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.14.22.50.28;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.08.20.55.41;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.51;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.132
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@/*	$OpenBSD: usb_subr.c,v 1.131 2016/09/19 16:46:10 mpi Exp $ */
/*	$NetBSD: usb_subr.c,v 1.103 2003/01/10 11:19:13 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb_subr.c,v 1.18 1999/11/17 22:33:47 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/selinfo.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (usbdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) printf x; } while (0)
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

usbd_status	usbd_set_config(struct usbd_device *, int);
void		usbd_devinfo(struct usbd_device *, int, char *, size_t);
void		usbd_devinfo_vp(struct usbd_device *, char *, size_t,
		    char *, size_t, int);
char		*usbd_get_device_string(struct usbd_device *, uByte);
char		*usbd_get_string(struct usbd_device *, int, char *, size_t);
int		usbd_getnewaddr(struct usbd_bus *);
int		usbd_print(void *, const char *);
void		usbd_free_iface_data(struct usbd_device *, int);
usbd_status	usbd_probe_and_attach(struct device *,
		    struct usbd_device *, int, int);

int		usbd_printBCD(char *cp, size_t len, int bcd);
void		usb_free_device(struct usbd_device *);
int		usbd_parse_idesc(struct usbd_device *, struct usbd_interface *);

#ifdef USBVERBOSE
#include <dev/usb/usbdevs_data.h>
#endif /* USBVERBOSE */

const char * const usbd_error_strs[] = {
	"NORMAL_COMPLETION",
	"IN_PROGRESS",
	"PENDING_REQUESTS",
	"NOT_STARTED",
	"INVAL",
	"NOMEM",
	"CANCELLED",
	"BAD_ADDRESS",
	"IN_USE",
	"NO_ADDR",
	"SET_ADDR_FAILED",
	"NO_POWER",
	"TOO_DEEP",
	"IOERROR",
	"NOT_CONFIGURED",
	"TIMEOUT",
	"SHORT_XFER",
	"STALLED",
	"INTERRUPTED",
	"XXX",
};

const char *
usbd_errstr(usbd_status err)
{
	static char buffer[5];

	if (err < USBD_ERROR_MAX)
		return (usbd_error_strs[err]);
	else {
		snprintf(buffer, sizeof(buffer), "%d", err);
		return (buffer);
	}
}

usbd_status
usbd_get_string_desc(struct usbd_device *dev, int sindex, int langid,
    usb_string_descriptor_t *sdesc, int *sizep)
{
	usb_device_request_t req;
	usbd_status err;
	int actlen;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_STRING, sindex);
	USETW(req.wIndex, langid);
	USETW(req.wLength, 2);	/* size and descriptor type first */
	err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
	    &actlen, USBD_DEFAULT_TIMEOUT);
	if (err)
		return (err);

	if (actlen < 2)
		return (USBD_SHORT_XFER);

	USETW(req.wLength, sdesc->bLength);	/* the whole string */
	err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
	    &actlen, USBD_DEFAULT_TIMEOUT);
	if (err)
		return (err);

	if (actlen != sdesc->bLength) {
		DPRINTFN(-1, ("usbd_get_string_desc: expected %d, got %d\n",
		    sdesc->bLength, actlen));
	}

	*sizep = actlen;
	return (USBD_NORMAL_COMPLETION);
}

char *
usbd_get_string(struct usbd_device *dev, int si, char *buf, size_t buflen)
{
	int swap = dev->quirks->uq_flags & UQ_SWAP_UNICODE;
	usb_string_descriptor_t us;
	char *s;
	int i, n;
	u_int16_t c;
	usbd_status err;
	int size;

	if (si == 0)
		return (0);
	if (dev->quirks->uq_flags & UQ_NO_STRINGS)
		return (0);
	if (dev->langid == USBD_NOLANG) {
		/* Set up default language */
		err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us,
		    &size);
		if (err || size < 4)
			dev->langid = 0; /* Well, just pick English then */
		else {
			/* Pick the first language as the default. */
			dev->langid = UGETW(us.bString[0]);
		}
	}
	err = usbd_get_string_desc(dev, si, dev->langid, &us, &size);
	if (err)
		return (0);
	s = buf;
	n = size / 2 - 1;
	for (i = 0; i < n && i < buflen ; i++) {
		c = UGETW(us.bString[i]);
		/* Convert from Unicode, handle buggy strings. */
		if ((c & 0xff00) == 0)
			*s++ = c;
		else if ((c & 0x00ff) == 0 && swap)
			*s++ = c >> 8;
		else
			*s++ = '?';
	}
	if (buflen > 0)
		*s++ = 0;
	return (buf);
}

static void
usbd_trim_spaces(char *p)
{
	char *q, *e;

	if (p == NULL)
		return;
	q = e = p;
	while (*q == ' ')	/* skip leading spaces */
		q++;
	while ((*p = *q++))	/* copy string */
		if (*p++ != ' ') /* remember last non-space */
			e = p;
	*e = 0;			/* kill trailing spaces */
}

char *
usbd_get_device_string(struct usbd_device *dev, uByte index)
{
	char *buf;

	buf = malloc(USB_MAX_STRING_LEN, M_USB, M_NOWAIT);
	if (buf == NULL)
		return (NULL);

	if (usbd_get_string(dev, index, buf, USB_MAX_STRING_LEN) != NULL) {
		usbd_trim_spaces(buf);
	} else {
		free(buf, M_USB, USB_MAX_STRING_LEN);
		buf = NULL;
	}

	return (buf);
}

void
usbd_devinfo_vp(struct usbd_device *dev, char *v, size_t vl,
    char *p, size_t pl, int usedev)
{
	usb_device_descriptor_t *udd = &dev->ddesc;
	char *vendor = NULL, *product = NULL;
#ifdef USBVERBOSE
	const struct usb_known_vendor *ukv;
	const struct usb_known_product *ukp;
#endif

	if (dev == NULL) {
		v[0] = p[0] = '\0';
		return;
	}

	if (usedev) {
		vendor = usbd_get_string(dev, udd->iManufacturer, v, vl);
		usbd_trim_spaces(vendor);
		product = usbd_get_string(dev, udd->iProduct, p, pl);
		usbd_trim_spaces(product);
	} else {
		if (dev->vendor != NULL)
			vendor = dev->vendor;
		if (dev->product != NULL)
			product = dev->product;
	}
#ifdef USBVERBOSE
	if (vendor == NULL || product == NULL) {
		for (ukv = usb_known_vendors;
		    ukv->vendorname != NULL;
		    ukv++) {
			if (ukv->vendor == UGETW(udd->idVendor)) {
				vendor = ukv->vendorname;
				break;
			}
		}
		if (vendor != NULL) {
			for (ukp = usb_known_products;
			    ukp->productname != NULL;
			    ukp++) {
				if (ukp->vendor == UGETW(udd->idVendor) &&
				    (ukp->product == UGETW(udd->idProduct))) {
					product = ukp->productname;
					break;
				}
			}
		}
	}
#endif

	if (v == vendor)
		;
	else if (vendor != NULL && *vendor)
		strlcpy(v, vendor, vl);
	else
		snprintf(v, vl, "vendor 0x%04x", UGETW(udd->idVendor));

	if (p == product)
		;
	else if (product != NULL && *product)
		strlcpy(p, product, pl);
	else
		snprintf(p, pl, "product 0x%04x", UGETW(udd->idProduct));
}

int
usbd_printBCD(char *cp, size_t len, int bcd)
{
	int l;

	l = snprintf(cp, len, "%x.%02x", bcd >> 8, bcd & 0xff);
	if (l == -1 || len == 0)
		return (0);
	if (l >= len)
		return len - 1;
	return (l);
}

void
usbd_devinfo(struct usbd_device *dev, int showclass, char *base, size_t len)
{
	usb_device_descriptor_t *udd = &dev->ddesc;
	char vendor[USB_MAX_STRING_LEN];
	char product[USB_MAX_STRING_LEN];
	char *cp = base;
	int bcdDevice, bcdUSB;

	usbd_devinfo_vp(dev, vendor, sizeof vendor, product, sizeof product, 0);
	snprintf(cp, len, "\"%s %s\"", vendor, product);
	cp += strlen(cp);
	if (showclass) {
		snprintf(cp, base + len - cp, ", class %d/%d",
		    udd->bDeviceClass, udd->bDeviceSubClass);
		cp += strlen(cp);
	}
	bcdUSB = UGETW(udd->bcdUSB);
	bcdDevice = UGETW(udd->bcdDevice);
	snprintf(cp, base + len - cp, " rev ");
	cp += strlen(cp);
	usbd_printBCD(cp, base + len - cp, bcdUSB);
	cp += strlen(cp);
	snprintf(cp, base + len - cp, "/");
	cp += strlen(cp);
	usbd_printBCD(cp, base + len - cp, bcdDevice);
	cp += strlen(cp);
	snprintf(cp, base + len - cp, " addr %d", dev->address);
}

/* Delay for a certain number of ms */
void
usb_delay_ms(struct usbd_bus *bus, u_int ms)
{
	static int usb_delay_wchan;

	/* Wait at least two clock ticks so we know the time has passed. */
	if (bus->use_polling || cold)
		delay((ms+1) * 1000);
	else
		tsleep(&usb_delay_wchan, PRIBIO, "usbdly",
		    (ms*hz+999)/1000 + 1);
}

/* Delay given a device handle. */
void
usbd_delay_ms(struct usbd_device *dev, u_int ms)
{
	if (usbd_is_dying(dev))
		return;

	usb_delay_ms(dev->bus, ms);
}

usbd_status
usbd_port_disown_to_1_1(struct usbd_device *dev, int port)
{
	usb_port_status_t ps;
	usbd_status err;
	int n;

	err = usbd_set_port_feature(dev, port, UHF_PORT_DISOWN_TO_1_1);
	DPRINTF(("usbd_disown_to_1_1: port %d disown request done, error=%s\n",
	    port, usbd_errstr(err)));
	if (err)
		return (err);
	n = 10;
	do {
		/* Wait for device to recover from reset. */
		usbd_delay_ms(dev, USB_PORT_RESET_DELAY);
		err = usbd_get_port_status(dev, port, &ps);
		if (err) {
			DPRINTF(("%s: get status failed %d\n", __func__, err));
			return (err);
		}
		/* If the device disappeared, just give up. */
		if (!(UGETW(ps.wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
			return (USBD_NORMAL_COMPLETION);
	} while ((UGETW(ps.wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);
	if (n == 0)
		return (USBD_TIMEOUT);

	return (err);
}

int
usbd_reset_port(struct usbd_device *dev, int port)
{
	usb_port_status_t ps;
	int n;

	if (usbd_set_port_feature(dev, port, UHF_PORT_RESET))
		return (EIO);
	DPRINTF(("%s: port %d reset done\n", __func__, port));
	n = 10;
	do {
		/* Wait for device to recover from reset. */
		usbd_delay_ms(dev, USB_PORT_RESET_DELAY);
		if (usbd_get_port_status(dev, port, &ps)) {
			DPRINTF(("%s: get status failed\n", __func__));
			return (EIO);
		}
		/* If the device disappeared, just give up. */
		if (!(UGETW(ps.wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
			return (0);
	} while ((UGETW(ps.wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);

	/* Clear port reset even if a timeout occured. */
	if (usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET)) {
		DPRINTF(("%s: clear port feature failed\n", __func__));
		return (EIO);
	}

	if (n == 0)
		return (ETIMEDOUT);

	/* Wait for the device to recover from reset. */
	usbd_delay_ms(dev, USB_PORT_RESET_RECOVERY);
	return (0);
}

usb_interface_descriptor_t *
usbd_find_idesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx)
{
	char *p = (char *)cd;
	char *end = p + UGETW(cd->wTotalLength);
	usb_interface_descriptor_t *d;
	int curidx, lastidx, curaidx = 0;

	for (curidx = lastidx = -1; p < end; ) {
		d = (usb_interface_descriptor_t *)p;
		DPRINTFN(4,("usbd_find_idesc: idx=%d(%d) altidx=%d(%d) len=%d "
			    "type=%d\n",
			    ifaceidx, curidx, altidx, curaidx,
			    d->bLength, d->bDescriptorType));
		if (d->bLength == 0) /* bad descriptor */
			break;
		p += d->bLength;
		if (p <= end && d->bDescriptorType == UDESC_INTERFACE) {
			if (d->bInterfaceNumber != lastidx) {
				lastidx = d->bInterfaceNumber;
				curidx++;
				curaidx = 0;
			} else
				curaidx++;
			if (ifaceidx == curidx && altidx == curaidx)
				return (d);
		}
	}
	return (NULL);
}

usb_endpoint_descriptor_t *
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx,
		int endptidx)
{
	char *p = (char *)cd;
	char *end = p + UGETW(cd->wTotalLength);
	usb_interface_descriptor_t *d;
	usb_endpoint_descriptor_t *e;
	int curidx;

	d = usbd_find_idesc(cd, ifaceidx, altidx);
	if (d == NULL)
		return (NULL);
	if (endptidx >= d->bNumEndpoints) /* quick exit */
		return (NULL);

	curidx = -1;
	for (p = (char *)d + d->bLength; p < end; ) {
		e = (usb_endpoint_descriptor_t *)p;
		if (e->bLength == 0) /* bad descriptor */
			break;
		p += e->bLength;
		if (p <= end && e->bDescriptorType == UDESC_INTERFACE)
			return (NULL);
		if (p <= end && e->bDescriptorType == UDESC_ENDPOINT) {
			curidx++;
			if (curidx == endptidx)
				return (e);
		}
	}
	return (NULL);
}

usbd_status
usbd_fill_iface_data(struct usbd_device *dev, int ifaceidx, int altidx)
{
	struct usbd_interface *ifc = &dev->ifaces[ifaceidx];
	usb_interface_descriptor_t *idesc;
	int nendpt;

	DPRINTFN(4,("%s: ifaceidx=%d altidx=%d\n", __func__, ifaceidx, altidx));

	idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);
	if (idesc == NULL)
		return (USBD_INVAL);

	nendpt = idesc->bNumEndpoints;
	DPRINTFN(4,("%s: found idesc nendpt=%d\n", __func__, nendpt));

	ifc->device = dev;
	ifc->idesc = idesc;
	ifc->index = ifaceidx;
	ifc->altindex = altidx;
	ifc->endpoints = NULL;
	ifc->priv = NULL;
	LIST_INIT(&ifc->pipes);

	if (nendpt != 0) {
		ifc->endpoints = mallocarray(nendpt, sizeof(*ifc->endpoints),
		    M_USB, M_NOWAIT | M_ZERO);
		if (ifc->endpoints == NULL)
			return (USBD_NOMEM);
	}

	if (usbd_parse_idesc(dev, ifc)) {
		free(ifc->endpoints, M_USB, nendpt * sizeof(*ifc->endpoints));
		ifc->endpoints = NULL;
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

int
usbd_parse_idesc(struct usbd_device *dev, struct usbd_interface *ifc)
{
#define ed ((usb_endpoint_descriptor_t *)p)
	char *p, *end;
	int i;

	p = (char *)ifc->idesc + ifc->idesc->bLength;
	end = (char *)dev->cdesc + UGETW(dev->cdesc->wTotalLength);

	for (i = 0; i < ifc->idesc->bNumEndpoints; i++) {
		for (; p < end; p += ed->bLength) {
			if (p + ed->bLength <= end && ed->bLength != 0 &&
			    ed->bDescriptorType == UDESC_ENDPOINT)
				break;

			if (ed->bLength == 0 ||
			    ed->bDescriptorType == UDESC_INTERFACE)
			    	return (-1);
		}

		if (p >= end)
			return (-1);

		if (dev->speed == USB_SPEED_HIGH) {
			unsigned int mps;

			/* Control and bulk endpoints have max packet limits. */
			switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
			case UE_CONTROL:
				mps = USB_2_MAX_CTRL_PACKET;
				goto check;
			case UE_BULK:
				mps = USB_2_MAX_BULK_PACKET;
			check:
				if (UGETW(ed->wMaxPacketSize) != mps) {
					USETW(ed->wMaxPacketSize, mps);
					DPRINTF(("%s: bad max packet size\n",
					    __func__));
				}
				break;
			default:
				break;
			}
		}

		ifc->endpoints[i].edesc = ed;
		ifc->endpoints[i].refcnt = 0;
		ifc->endpoints[i].savedtoggle = 0;
		p += ed->bLength;
	}

	return (0);
#undef ed
}

void
usbd_free_iface_data(struct usbd_device *dev, int ifcno)
{
	struct usbd_interface *ifc = &dev->ifaces[ifcno];
	if (ifc->endpoints)
		free(ifc->endpoints, M_USB, 0);
}

usbd_status
usbd_set_config(struct usbd_device *dev, int conf)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_CONFIG;
	USETW(req.wValue, conf);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_config_no(struct usbd_device *dev, int no, int msg)
{
	int index;
	usb_config_descriptor_t cd;
	usbd_status err;

	DPRINTFN(5,("usbd_set_config_no: %d\n", no));
	/* Figure out what config index to use. */
	for (index = 0; index < dev->ddesc.bNumConfigurations; index++) {
		err = usbd_get_desc(dev, UDESC_CONFIG, index,
		    USB_CONFIG_DESCRIPTOR_SIZE, &cd);
		if (err || cd.bDescriptorType != UDESC_CONFIG)
			return (err);
		if (cd.bConfigurationValue == no)
			return (usbd_set_config_index(dev, index, msg));
	}
	return (USBD_INVAL);
}

usbd_status
usbd_set_config_index(struct usbd_device *dev, int index, int msg)
{
	usb_status_t ds;
	usb_config_descriptor_t cd, *cdp;
	usbd_status err;
	int i, ifcidx, nifc, len, selfpowered, power;

	DPRINTFN(5,("usbd_set_config_index: dev=%p index=%d\n", dev, index));

	/* XXX check that all interfaces are idle */
	if (dev->config != USB_UNCONFIG_NO) {
		DPRINTF(("usbd_set_config_index: free old config\n"));
		/* Free all configuration data structures. */
		nifc = dev->cdesc->bNumInterface;
		for (ifcidx = 0; ifcidx < nifc; ifcidx++)
			usbd_free_iface_data(dev, ifcidx);
		free(dev->ifaces, M_USB, 0);
		free(dev->cdesc, M_USB, 0);
		dev->ifaces = NULL;
		dev->cdesc = NULL;
		dev->config = USB_UNCONFIG_NO;
	}

	if (index == USB_UNCONFIG_INDEX) {
		/* We are unconfiguring the device, so leave unallocated. */
		DPRINTF(("usbd_set_config_index: set config 0\n"));
		err = usbd_set_config(dev, USB_UNCONFIG_NO);
		if (err)
			DPRINTF(("usbd_set_config_index: setting config=0 "
				 "failed, error=%s\n", usbd_errstr(err)));
		return (err);
	}

	/* Get the short descriptor. */
	err = usbd_get_desc(dev, UDESC_CONFIG, index,
	    USB_CONFIG_DESCRIPTOR_SIZE, &cd);
	if (err)
		return (err);
	if (cd.bDescriptorType != UDESC_CONFIG)
		return (USBD_INVAL);
	len = UGETW(cd.wTotalLength);
	cdp = malloc(len, M_USB, M_NOWAIT);
	if (cdp == NULL)
		return (USBD_NOMEM);
	/* Get the full descriptor. */
	for (i = 0; i < 3; i++) {
		err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
		if (!err)
			break;
		usbd_delay_ms(dev, 200);
	}
	if (err)
		goto bad;

	if (cdp->bDescriptorType != UDESC_CONFIG) {
		DPRINTFN(-1,("usbd_set_config_index: bad desc %d\n",
		    cdp->bDescriptorType));
		err = USBD_INVAL;
		goto bad;
	}

	/* Figure out if the device is self or bus powered. */
	selfpowered = 0;
	if (!(dev->quirks->uq_flags & UQ_BUS_POWERED) &&
	    (cdp->bmAttributes & UC_SELF_POWERED)) {
		/* May be self powered. */
		if (cdp->bmAttributes & UC_BUS_POWERED) {
			/* Must ask device. */
			if (dev->quirks->uq_flags & UQ_POWER_CLAIM) {
				/*
				 * Hub claims to be self powered, but isn't.
				 * It seems that the power status can be
				 * determined by the hub characteristics.
				 */
				usb_hub_descriptor_t hd;
				usb_device_request_t req;
				req.bmRequestType = UT_READ_CLASS_DEVICE;
				req.bRequest = UR_GET_DESCRIPTOR;
				USETW(req.wValue, 0);
				USETW(req.wIndex, 0);
				USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
				err = usbd_do_request(dev, &req, &hd);
				if (!err &&
				    (UGETW(hd.wHubCharacteristics) &
				     UHD_PWR_INDIVIDUAL))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: charac=0x%04x"
				    ", error=%s\n",
				    UGETW(hd.wHubCharacteristics),
				    usbd_errstr(err)));
			} else {
				err = usbd_get_device_status(dev, &ds);
				if (!err &&
				    (UGETW(ds.wStatus) & UDS_SELF_POWERED))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: status=0x%04x"
				    ", error=%s\n",
				    UGETW(ds.wStatus), usbd_errstr(err)));
			}
		} else
			selfpowered = 1;
	}
	DPRINTF(("usbd_set_config_index: (addr %d) cno=%d attr=0x%02x, "
		 "selfpowered=%d, power=%d\n", dev->address,
		 cdp->bConfigurationValue, cdp->bmAttributes,
		 selfpowered, cdp->bMaxPower * 2));

	/* Check if we have enough power. */
#ifdef USB_DEBUG
	if (dev->powersrc == NULL) {
		DPRINTF(("usbd_set_config_index: No power source?\n"));
		err = USBD_IOERROR;
		goto bad;
	}
#endif
	power = cdp->bMaxPower * 2;
	if (power > dev->powersrc->power) {
		DPRINTF(("power exceeded %d %d\n", power,dev->powersrc->power));
		/* XXX print nicer message. */
		if (msg)
			printf("%s: device addr %d (config %d) exceeds power "
			    "budget, %d mA > %d mA\n",
			    dev->bus->bdev.dv_xname, dev->address,
			    cdp->bConfigurationValue,
			    power, dev->powersrc->power);
		err = USBD_NO_POWER;
		goto bad;
	}
	dev->power = power;
	dev->self_powered = selfpowered;

	/* Set the actual configuration value. */
	DPRINTF(("usbd_set_config_index: set config %d\n",
	    cdp->bConfigurationValue));
	err = usbd_set_config(dev, cdp->bConfigurationValue);
	if (err) {
		DPRINTF(("usbd_set_config_index: setting config=%d failed, "
		    "error=%s\n", cdp->bConfigurationValue, usbd_errstr(err)));
		goto bad;
	}

	/* Allocate and fill interface data. */
	nifc = cdp->bNumInterface;
	dev->ifaces = mallocarray(nifc, sizeof(struct usbd_interface),
	    M_USB, M_NOWAIT | M_ZERO);
	if (dev->ifaces == NULL) {
		err = USBD_NOMEM;
		goto bad;
	}
	DPRINTFN(5,("usbd_set_config_index: dev=%p cdesc=%p\n", dev, cdp));
	dev->cdesc = cdp;
	dev->config = cdp->bConfigurationValue;
	for (ifcidx = 0; ifcidx < nifc; ifcidx++) {
		err = usbd_fill_iface_data(dev, ifcidx, 0);
		if (err)
			return (err);
	}

	return (USBD_NORMAL_COMPLETION);

 bad:
	free(cdp, M_USB, 0);
	return (err);
}

/* XXX add function for alternate settings */

usbd_status
usbd_setup_pipe(struct usbd_device *dev, struct usbd_interface *iface,
    struct usbd_endpoint *ep, int ival, struct usbd_pipe **pipe)
{
	struct usbd_pipe *p;
	usbd_status err;

	DPRINTF(("%s: dev=%p iface=%p ep=%p pipe=%p\n", __func__,
		    dev, iface, ep, pipe));
	p = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT|M_ZERO);
	if (p == NULL)
		return (USBD_NOMEM);
	p->device = dev;
	p->iface = iface;
	p->endpoint = ep;
	ep->refcnt++;
	p->interval = ival;
	SIMPLEQ_INIT(&p->queue);
	err = dev->bus->methods->open_pipe(p);
	if (err) {
		DPRINTF(("%s: endpoint=0x%x failed, error=%s\n", __func__,
			 ep->edesc->bEndpointAddress, usbd_errstr(err)));
		free(p, M_USB, 0);
		return (err);
	}
	*pipe = p;
	return (USBD_NORMAL_COMPLETION);
}

int
usbd_set_address(struct usbd_device *dev, int addr)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_ADDRESS;
	USETW(req.wValue, addr);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	if (usbd_do_request(dev, &req, 0))
		return (1);

	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);

	return (0);
}

int
usbd_getnewaddr(struct usbd_bus *bus)
{
	int addr;

	for (addr = 1; addr < USB_MAX_DEVICES; addr++)
		if (bus->devices[addr] == NULL)
			return (addr);
	return (-1);
}

usbd_status
usbd_probe_and_attach(struct device *parent, struct usbd_device *dev, int port,
    int addr)
{
	struct usb_attach_arg uaa;
	usb_device_descriptor_t *dd = &dev->ddesc;
	int i, confi, nifaces, len;
	usbd_status err;
	struct device *dv;
	struct usbd_interface **ifaces;
	extern struct rwlock usbpalock;

	rw_enter_write(&usbpalock);

	uaa.device = dev;
	uaa.iface = NULL;
	uaa.ifaces = NULL;
	uaa.nifaces = 0;
	uaa.usegeneric = 0;
	uaa.port = port;
	uaa.configno = UHUB_UNK_CONFIGURATION;
	uaa.ifaceno = UHUB_UNK_INTERFACE;
	uaa.vendor = UGETW(dd->idVendor);
	uaa.product = UGETW(dd->idProduct);
	uaa.release = UGETW(dd->bcdDevice);

	/* First try with device specific drivers. */
	DPRINTF(("usbd_probe_and_attach trying device specific drivers\n"));
	dv = config_found(parent, &uaa, usbd_print);
	if (dv) {
		dev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);
		if (dev->subdevs == NULL) {
			err = USBD_NOMEM;
			goto fail;
		}
		dev->subdevs[dev->ndevs++] = dv;
		dev->subdevs[dev->ndevs] = 0;
		err = USBD_NORMAL_COMPLETION;
		goto fail;
	}

	DPRINTF(("usbd_probe_and_attach: no device specific driver found\n"));

	DPRINTF(("usbd_probe_and_attach: looping over %d configurations\n",
		 dd->bNumConfigurations));
	/* Next try with interface drivers. */
	for (confi = 0; confi < dd->bNumConfigurations; confi++) {
		DPRINTFN(1,("usbd_probe_and_attach: trying config idx=%d\n",
			    confi));
		err = usbd_set_config_index(dev, confi, 1);
		if (err) {
#ifdef USB_DEBUG
			DPRINTF(("%s: port %d, set config at addr %d failed, "
				 "error=%s\n", parent->dv_xname, port,
				 addr, usbd_errstr(err)));
#else
			printf("%s: port %d, set config %d at addr %d failed\n",
			    parent->dv_xname, port, confi, addr);
#endif

 			goto fail;
		}
		nifaces = dev->cdesc->bNumInterface;
		uaa.configno = dev->cdesc->bConfigurationValue;
		ifaces = mallocarray(nifaces, sizeof(*ifaces), M_USB, M_NOWAIT);
		if (ifaces == NULL) {
			err = USBD_NOMEM;
			goto fail;
		}
		for (i = 0; i < nifaces; i++)
			ifaces[i] = &dev->ifaces[i];
		uaa.ifaces = ifaces;
		uaa.nifaces = nifaces;

		/* add 1 for possible ugen and 1 for NULL terminator */
		dev->subdevs = mallocarray(nifaces + 2, sizeof(dv), M_USB,
		    M_NOWAIT | M_ZERO);
		if (dev->subdevs == NULL) {
			free(ifaces, M_USB, 0);
			err = USBD_NOMEM;
			goto fail;
		}
		len = (nifaces + 2) * sizeof(dv);

		for (i = 0; i < nifaces; i++) {
			if (usbd_iface_claimed(dev, i))
				continue;
			uaa.iface = ifaces[i];
			uaa.ifaceno = ifaces[i]->idesc->bInterfaceNumber;
			dv = config_found(parent, &uaa, usbd_print);
			if (dv != NULL) {
				dev->subdevs[dev->ndevs++] = dv;
				usbd_claim_iface(dev, i);
			}
		}
		free(ifaces, M_USB, 0);

		if (dev->ndevs > 0) {
			for (i = 0; i < nifaces; i++) {
				if (!usbd_iface_claimed(dev, i))
					break;
			}
			if (i < nifaces)
				goto generic;
			 else
				goto fail;
		}

		free(dev->subdevs, M_USB, 0);
		dev->subdevs = NULL;
	}
	/* No interfaces were attached in any of the configurations. */

	if (dd->bNumConfigurations > 1) /* don't change if only 1 config */
		usbd_set_config_index(dev, 0, 0);

	DPRINTF(("usbd_probe_and_attach: no interface drivers found\n"));

generic:
	/* Finally try the generic driver. */
	uaa.iface = NULL;
	uaa.usegeneric = 1;
	uaa.configno = dev->ndevs == 0 ? UHUB_UNK_CONFIGURATION :
	    dev->cdesc->bConfigurationValue;
	uaa.ifaceno = UHUB_UNK_INTERFACE;
	dv = config_found(parent, &uaa, usbd_print);
	if (dv != NULL) {
		if (dev->ndevs == 0) {
			dev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);
			if (dev->subdevs == NULL) {
				err = USBD_NOMEM;
				goto fail;
			}
		}
		dev->subdevs[dev->ndevs++] = dv;
		dev->subdevs[dev->ndevs] = 0;
		err = USBD_NORMAL_COMPLETION;
		goto fail;
	}

	/*
	 * The generic attach failed, but leave the device as it is.
	 * We just did not find any drivers, that's all.  The device is
	 * fully operational and not harming anyone.
	 */
	DPRINTF(("usbd_probe_and_attach: generic attach failed\n"));
 	err = USBD_NORMAL_COMPLETION;
fail:
	rw_exit_write(&usbpalock);
	return (err);
}


/*
 * Called when a new device has been put in the powered state,
 * but not yet in the addressed state.
 * Get initial descriptor, set the address, get full descriptor,
 * and attach a driver.
 */
usbd_status
usbd_new_device(struct device *parent, struct usbd_bus *bus, int depth,
		int speed, int port, struct usbd_port *up)
{
	struct usbd_device *dev, *adev, *hub;
	usb_device_descriptor_t *dd;
	usbd_status err;
	uint32_t mps, mps0;
	int addr, i, p;

	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d speed=%d\n",
		 bus, port, depth, speed));

	/*
	 * Fixed size for ep0 max packet, FULL device variable size is
	 * handled below.
	 */
	switch (speed) {
	case USB_SPEED_LOW:
		mps0 = 8;
		break;
	case USB_SPEED_HIGH:
	case USB_SPEED_FULL:
		mps0 = 64;
		break;
	case USB_SPEED_SUPER:
		mps0 = 512;
		break;
	default:
		return (USBD_INVAL);
	}

	addr = usbd_getnewaddr(bus);
	if (addr < 0) {
		printf("%s: No free USB addresses, new device ignored.\n",
		    bus->bdev.dv_xname);
		return (USBD_NO_ADDR);
	}

	dev = malloc(sizeof *dev, M_USB, M_NOWAIT | M_ZERO);
	if (dev == NULL)
		return (USBD_NOMEM);

	dev->bus = bus;

	/* Set up default endpoint handle. */
	dev->def_ep.edesc = &dev->def_ep_desc;

	/* Set up default endpoint descriptor. */
	dev->def_ep_desc.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE;
	dev->def_ep_desc.bDescriptorType = UDESC_ENDPOINT;
	dev->def_ep_desc.bEndpointAddress = USB_CONTROL_ENDPOINT;
	dev->def_ep_desc.bmAttributes = UE_CONTROL;
	dev->def_ep_desc.bInterval = 0;
	USETW(dev->def_ep_desc.wMaxPacketSize, mps0);

	dev->quirks = &usbd_no_quirk;
	dev->address = USB_START_ADDR;
	dev->ddesc.bMaxPacketSize = 0;
	dev->depth = depth;
	dev->powersrc = up;
	dev->myhub = up->parent;
	dev->speed = speed;
	dev->langid = USBD_NOLANG;

	up->device = dev;

	/* Locate port on upstream high speed hub */
	for (adev = dev, hub = up->parent;
	    hub != NULL && hub->speed != USB_SPEED_HIGH;
	    adev = hub, hub = hub->myhub)
		;
	if (hub) {
		for (p = 0; p < hub->hub->nports; p++) {
			if (hub->hub->ports[p].device == adev) {
				dev->myhsport = &hub->hub->ports[p];
				goto found;
			}
		}
		panic("usbd_new_device: cannot find HS port");
	found:
		DPRINTFN(1,("usbd_new_device: high speed port %d\n", p));
	} else {
		dev->myhsport = NULL;
	}

	/* Establish the default pipe. */
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe);
	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
	}

	dd = &dev->ddesc;

	/* Try to get device descriptor */
	/* 
	 * some device will need small size query at first (XXX: out of spec)
	 * we will get full size descriptor later, just determin the maximum
	 * packet size of the control pipe at this moment.
	 */
	for (i = 0; i < 3; i++) {
		/* Get the first 8 bytes of the device descriptor. */
		/* 8 byte is magic size, some device only return 8 byte for 1st
		 * query (XXX: out of spec) */
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);
		if (!err)
			break;
		usbd_delay_ms(dev, 100+50*i);
	}

	/* some device need actual size request for the query. try again */
	if (err) {
		USETW(dev->def_ep_desc.wMaxPacketSize,
			USB_DEVICE_DESCRIPTOR_SIZE);
		usbd_reset_port(up->parent, port);
		for (i = 0; i < 3; i++) {
			err = usbd_get_desc(dev, UDESC_DEVICE, 0, 
				USB_DEVICE_DESCRIPTOR_SIZE, dd);
			if (!err)
				break;
			usbd_delay_ms(dev, 100+50*i);
		}
	}

	/* XXX some devices need more time to wake up */
	if (err) {
		USETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);
		usbd_reset_port(up->parent, port);
		usbd_delay_ms(dev, 500);
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, 
			USB_MAX_IPACKET, dd);
	}

	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
	}

	DPRINTF(("usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, "
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n",
		 addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength,
		 dev->speed));

	if ((dd->bDescriptorType != UDESC_DEVICE) ||
	    (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE)) {
		usb_free_device(dev);
		up->device = NULL;
		return (USBD_INVAL);
	}

	mps = dd->bMaxPacketSize;
	if (speed == USB_SPEED_SUPER) {
		if (mps == 0xff)
			mps = 9;
		/* xHCI Section 4.8.2.1 */
		mps = (1 << mps);
	}

	if (mps != mps0) {
		if ((speed == USB_SPEED_LOW) ||
		    (mps != 8 && mps != 16 && mps != 32 && mps != 64)) {
			usb_free_device(dev);
			up->device = NULL;
			return (USBD_INVAL);
		}
		USETW(dev->def_ep_desc.wMaxPacketSize, mps);
	}


	/* Set the address if the HC didn't do it already. */
	if (bus->methods->dev_setaddr != NULL &&
	    bus->methods->dev_setaddr(dev, addr)) {
		usb_free_device(dev);
		up->device = NULL;
		return (USBD_SET_ADDR_FAILED);
 	}

	/* Wait for device to settle before reloading the descriptor. */
	usbd_delay_ms(dev, 10);

	/*
	 * If this device is attached to an xHCI controller, this
	 * address does not correspond to the hardware one.
	 */
	dev->address = addr;
	bus->devices[addr] = dev;

	err = usbd_reload_device_desc(dev);
	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
	}

	/* send disown request to handover 2.0 to 1.1. */
	if (dev->quirks->uq_flags & UQ_EHCI_NEEDTO_DISOWN) {
		/* only effective when the target device is on ehci */
		if (dev->bus->usbrev == USBREV_2_0) {
			DPRINTF(("%s: disown request issues to dev:%p on usb2.0 bus\n",
				__func__, dev));
			usbd_port_disown_to_1_1(dev->myhub, port);
			/* reset_port required to finish disown request */
			usbd_reset_port(dev->myhub, port);
  			return (USBD_NORMAL_COMPLETION);
		}
	}

	/* Assume 100mA bus powered for now. Changed when configured. */
	dev->power = USB_MIN_POWER;
	dev->self_powered = 0;

	DPRINTF(("usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n",
		 addr, dev, parent));

	/* Cache some strings if possible. */
	dev->vendor = usbd_get_device_string(dev, dev->ddesc.iManufacturer);
	dev->product = usbd_get_device_string(dev, dev->ddesc.iProduct);
	dev->serial = usbd_get_device_string(dev, dev->ddesc.iSerialNumber);

	err = usbd_probe_and_attach(parent, dev, port, addr);
	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
  	}

  	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_reload_device_desc(struct usbd_device *dev)
{
	usbd_status err;

	/* Get the full device descriptor. */
	err = usbd_get_desc(dev, UDESC_DEVICE, 0,
		USB_DEVICE_DESCRIPTOR_SIZE, &dev->ddesc);
	if (err)
		return (err);

	/* Figure out what's wrong with this device. */
	dev->quirks = usbd_find_quirk(&dev->ddesc);

	return (USBD_NORMAL_COMPLETION);
}

int
usbd_print(void *aux, const char *pnp)
{
	struct usb_attach_arg *uaa = aux;
	char *devinfop;

	devinfop = malloc(DEVINFOSIZE, M_TEMP, M_WAITOK);
	usbd_devinfo(uaa->device, 0, devinfop, DEVINFOSIZE);

	DPRINTFN(15, ("usbd_print dev=%p\n", uaa->device));
	if (pnp) {
		if (!uaa->usegeneric) {
			free(devinfop, M_TEMP, 0);
			return (QUIET);
		}
		printf("%s at %s", devinfop, pnp);
	}
	if (uaa->port != 0)
		printf(" port %d", uaa->port);
	if (uaa->configno != UHUB_UNK_CONFIGURATION)
		printf(" configuration %d", uaa->configno);
	if (uaa->ifaceno != UHUB_UNK_INTERFACE)
		printf(" interface %d", uaa->ifaceno);

	if (!pnp)
		printf(" %s\n", devinfop);
	free(devinfop, M_TEMP, 0);
	return (UNCONF);
}

void
usbd_fill_deviceinfo(struct usbd_device *dev, struct usb_device_info *di,
    int usedev)
{
	struct usbd_port *p;
	int i, err, s;

	di->udi_bus = dev->bus->usbctl->dv_unit;
	di->udi_addr = dev->address;
	usbd_devinfo_vp(dev, di->udi_vendor, sizeof(di->udi_vendor),
	    di->udi_product, sizeof(di->udi_product), usedev);
	usbd_printBCD(di->udi_release, sizeof di->udi_release,
	    UGETW(dev->ddesc.bcdDevice));
	di->udi_vendorNo = UGETW(dev->ddesc.idVendor);
	di->udi_productNo = UGETW(dev->ddesc.idProduct);
	di->udi_releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->udi_class = dev->ddesc.bDeviceClass;
	di->udi_subclass = dev->ddesc.bDeviceSubClass;
	di->udi_protocol = dev->ddesc.bDeviceProtocol;
	di->udi_config = dev->config;
	di->udi_power = dev->self_powered ? 0 : dev->power;
	di->udi_speed = dev->speed;

	if (dev->subdevs != NULL) {
		for (i = 0; dev->subdevs[i] && i < USB_MAX_DEVNAMES; i++) {
			strncpy(di->udi_devnames[i],
			    dev->subdevs[i]->dv_xname, USB_MAX_DEVNAMELEN);
			di->udi_devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
		}
	} else
		i = 0;

	for (/*i is set */; i < USB_MAX_DEVNAMES; i++)
		di->udi_devnames[i][0] = 0; /* empty */

	if (dev->hub) {
		for (i = 0;
		    i < nitems(di->udi_ports) && i < dev->hub->nports; i++) {
			p = &dev->hub->ports[i];
			if (p->device)
				err = p->device->address;
			else {
				s = UGETW(p->status.wPortStatus);
				if (s & UPS_PORT_ENABLED)
					err = USB_PORT_ENABLED;
				else if (s & UPS_SUSPEND)
					err = USB_PORT_SUSPENDED;
				else if (s & UPS_PORT_POWER)
					err = USB_PORT_POWERED;
				else
					err = USB_PORT_DISABLED;
			}
			di->udi_ports[i] = err;
		}
		di->udi_nports = dev->hub->nports;
	} else
		di->udi_nports = 0;

	bzero(di->udi_serial, sizeof(di->udi_serial));
	if (!usedev && dev->serial != NULL) {
		strlcpy(di->udi_serial, dev->serial,
		    sizeof(di->udi_serial));
	} else {
		usbd_get_string(dev, dev->ddesc.iSerialNumber,
		    di->udi_serial, sizeof(di->udi_serial));
	}
}

/* Retrieve a complete descriptor for a certain device and index. */
usb_config_descriptor_t *
usbd_get_cdesc(struct usbd_device *dev, int index, u_int *lenp)
{
	usb_config_descriptor_t *cdesc, *tdesc, cdescr;
	u_int len;
	usbd_status err;

	if (index == USB_CURRENT_CONFIG_INDEX) {
		tdesc = usbd_get_config_descriptor(dev);
		if (tdesc == NULL)
			return (NULL);
		len = UGETW(tdesc->wTotalLength);
		if (lenp)
			*lenp = len;
		cdesc = malloc(len, M_TEMP, M_WAITOK);
		memcpy(cdesc, tdesc, len);
		DPRINTFN(5,("usbd_get_cdesc: current, len=%u\n", len));
	} else {
		err = usbd_get_desc(dev, UDESC_CONFIG, index,
		    USB_CONFIG_DESCRIPTOR_SIZE, &cdescr);
		if (err || cdescr.bDescriptorType != UDESC_CONFIG)
			return (0);
		len = UGETW(cdescr.wTotalLength);
		DPRINTFN(5,("usbd_get_cdesc: index=%d, len=%u\n", index, len));
		if (lenp)
			*lenp = len;
		cdesc = malloc(len, M_TEMP, M_WAITOK);
		err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdesc);
		if (err) {
			free(cdesc, M_TEMP, len);
			return (0);
		}
	}
	return (cdesc);
}

void
usb_free_device(struct usbd_device *dev)
{
	int ifcidx, nifc;

	DPRINTF(("usb_free_device: %p\n", dev));

	if (dev->default_pipe != NULL) {
		usbd_abort_pipe(dev->default_pipe);
		usbd_close_pipe(dev->default_pipe);
	}
	if (dev->ifaces != NULL) {
		nifc = dev->cdesc->bNumInterface;
		for (ifcidx = 0; ifcidx < nifc; ifcidx++)
			usbd_free_iface_data(dev, ifcidx);
		free(dev->ifaces, M_USB, 0);
	}
	if (dev->cdesc != NULL)
		free(dev->cdesc, M_USB, 0);
	if (dev->subdevs != NULL)
		free(dev->subdevs, M_USB, 0);
	dev->bus->devices[dev->address] = NULL;

	if (dev->vendor != NULL)
		free(dev->vendor, M_USB, USB_MAX_STRING_LEN);
	if (dev->product != NULL)
		free(dev->product, M_USB, USB_MAX_STRING_LEN);
	if (dev->serial != NULL)
		free(dev->serial, M_USB, USB_MAX_STRING_LEN);

	free(dev, M_USB, sizeof *dev);
}

/*
 * Should only be called by the USB thread doing bus exploration to
 * avoid connect/disconnect races.
 */
int
usbd_detach(struct usbd_device *dev, struct device *parent)
{
	int i, rv = 0;

	usbd_deactivate(dev);

	if (dev->ndevs > 0) {
		for (i = 0; dev->subdevs[i] != NULL; i++)
			rv |= config_detach(dev->subdevs[i], DETACH_FORCE);
	}

	if (rv == 0)
		usb_free_device(dev);

	return (rv);
}
@


1.131
log
@Correctly check for valid maximum packet size.

from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.130 2016/09/19 10:20:17 mpi Exp $ */
d1401 1
a1401 1
			free(cdesc, M_TEMP, 0);
d1438 1
a1438 1
	free(dev, M_USB, 0);
@


1.130
log
@``bMaxPacketSize'' is reported as a power of 2 for super speed devices
as per section 4.8.2.1 of xHCI specification.

Note that we never got this correctly.

Spotted by and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.129 2016/09/18 09:51:24 mpi Exp $ */
d1187 1
a1187 1
		    (mps != 8 || mps != 16 || mps != 32 || mps != 64)) {
@


1.129
log
@Ensure that the device descriptor ``bMaxPacketSize'' value is usable
before using it as the ``wMaxPacketSize'' of the default endpoint.

This prevents host controller drivers from using incorrect value, in
particular 0, that makes ehci(4) crash.

While here do the 0xff -> 512 conversion for super speed devices.

Crash found with a facedancer21.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.128 2016/09/12 07:43:10 mpi Exp $ */
d1178 6
a1183 2
	if (speed == USB_SPEED_SUPER && mps == 0xff)
		mps = 512;
@


1.128
log
@Split usbd_fill_iface_data() in two and introduce usbd_parse_idesc() a
function for parsing and checking endpoint descriptors.

More checks will be added later to prevent malformed descriptors of
being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.127 2016/09/02 11:14:17 mpi Exp $ */
d1026 1
a1026 2
	struct usbd_device *dev, *adev;
	struct usbd_device *hub;
d1029 2
a1030 3
	int addr;
	int i;
	int p;
d1034 20
a1074 1
	USETW(dev->def_ep_desc.wMaxPacketSize, USB_MAX_IPACKET);
d1076 1
d1084 2
a1106 2
	dev->speed = speed;
	dev->langid = USBD_NOLANG;
a1163 11
	if (speed == USB_SPEED_HIGH) {
		/* Max packet size must be 64 (sec 5.5.3). */
		if (dd->bMaxPacketSize != USB_2_MAX_CTRL_PACKET) {
#ifdef DIAGNOSTIC
			printf("%s: addr=%d bad max packet size %d\n", __func__,
			    addr, dd->bMaxPacketSize);
#endif
			dd->bMaxPacketSize = USB_2_MAX_CTRL_PACKET;
		}
	}

d1170 2
a1171 1
	if (dd->bDescriptorType != UDESC_DEVICE) {
d1177 12
a1188 4
	if (dd->bLength < USB_DEVICE_DESCRIPTOR_SIZE) {
		usb_free_device(dev);
		up->device = NULL;
		return (USBD_INVAL);
a1190 1
	USETW(dev->def_ep_desc.wMaxPacketSize, dd->bMaxPacketSize);
@


1.127
log
@Pass M_ZERO when allocating memory for "struct usbd_endpoint".

These descriptors are filled with value parsed from untrusted USB
descriptors and we don't want to left memory unitialized if an error
occurs during the parsing.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.126 2016/09/02 10:57:48 mpi Exp $ */
d76 1
d504 1
a504 2
	char *p, *end;
	int endpt, nendpt;
d524 2
a525 2
		ifc->endpoints = mallocarray(nendpt,
		    sizeof(struct usbd_endpoint), M_USB, M_NOWAIT | M_ZERO);
d530 16
d548 2
a549 3
#define ed ((usb_endpoint_descriptor_t *)p)
	for (endpt = 0; endpt < nendpt; endpt++) {
		DPRINTFN(10,("%s: endpt=%d\n", __func__, endpt));
a550 3
			DPRINTFN(10,("%s: p=%p end=%p len=%d type=%d\n",
			    __func__, p, end, ed->bLength,
			    ed->bDescriptorType));
d553 2
a554 1
				goto found;
d557 1
a557 1
				break;
d559 4
a562 8
		/* passed end, or bad desc */
		printf("%s: bad descriptor(s): %s\n", __func__,
		    ed->bLength == 0 ? "0 length" :
		    ed->bDescriptorType == UDESC_INTERFACE ? "iface desc" :
		    "out of data");
		goto bad;
	found:
		ifc->endpoints[endpt].edesc = ed;
d564 3
a566 3
			u_int mps;
			/* Control and bulk endpoints have max packet
			   limits. */
d584 4
a587 2
		ifc->endpoints[endpt].refcnt = 0;
		ifc->endpoints[endpt].savedtoggle = 0;
d590 2
a592 8
	return (USBD_NORMAL_COMPLETION);

 bad:
	if (ifc->endpoints != NULL) {
		free(ifc->endpoints, M_USB, 0);
		ifc->endpoints = NULL;
	}
	return (USBD_INVAL);
@


1.126
log
@Cleanup usbd_fill_iface_data() to make it easier to check for bad
descriptors.

No functionnal change.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.125 2016/09/02 09:23:56 mpi Exp $ */
d525 1
a525 1
		    sizeof(struct usbd_endpoint), M_USB, M_NOWAIT);
@


1.125
log
@Do not free the configuration descriptor without setting ``dev->cdesc''
to NULL.

Prevent a use after free triggerable with invalid interface descriptor.

Found with umap2 and a facedancer21.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.124 2016/09/02 09:20:00 mpi Exp $ */
d506 2
a507 2
	DPRINTFN(4,("usbd_fill_iface_data: ifaceidx=%d altidx=%d\n",
		    ifaceidx, altidx));
d511 4
d519 4
a522 2
	nendpt = ifc->idesc->bNumEndpoints;
	DPRINTFN(4,("usbd_fill_iface_data: found idesc nendpt=%d\n", nendpt));
d528 2
a529 3
	} else
		ifc->endpoints = NULL;
	ifc->priv = NULL;
d534 1
a534 1
		DPRINTFN(10,("usbd_fill_iface_data: endpt=%d\n", endpt));
d536 2
a537 2
			DPRINTFN(10,("usbd_fill_iface_data: p=%p end=%p "
			    "len=%d type=%d\n", p, end, ed->bLength,
d547 1
a547 1
		printf("usbd_fill_iface_data: bad descriptor(s): %s\n",
d567 2
a568 4
#ifdef DIAGNOSTIC
					printf("usbd_fill_iface_data: bad max "
					    "packet size\n");
#endif
a579 1
	LIST_INIT(&ifc->pipes);
@


1.124
log
@Prevent a NULL dereference, triggerable with a crafted configuration
descriptor with a bad type.

Found with umap2 and a facedancer21.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.123 2016/05/23 11:31:12 mpi Exp $ */
d784 2
a785 5
		if (err) {
			while (--ifcidx >= 0)
				usbd_free_iface_data(dev, ifcidx);
			goto bad;
		}
@


1.123
log
@Get rid of usbd_get_device_strings() because we use it only once.

Return a char * rather using a void function for usbd_get_device_string()

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.122 2016/05/21 10:40:45 patrick Exp $ */
d666 1
a666 1
	if (err || cd.bDescriptorType != UDESC_CONFIG)
d668 2
@


1.122
log
@Free the cache if the string cannot be retrieved.  This allows the
fallback method to actually do its work and look up the strings via
the vendor and product id.

Regression noticed and ok tb@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.121 2016/05/18 18:28:58 patrick Exp $ */
d66 1
a66 1
void		usbd_get_device_string(struct usbd_device *, uByte, char **);
d215 2
a216 2
void
usbd_get_device_string(struct usbd_device *dev, uByte index, char **buf)
d218 11
a228 8
	char *b = malloc(USB_MAX_STRING_LEN, M_USB, M_NOWAIT);
	if (b != NULL) {
		if (usbd_get_string(dev, index, b, USB_MAX_STRING_LEN) != NULL)
			usbd_trim_spaces(b);
		else {
			free(b, M_USB, USB_MAX_STRING_LEN);
			b = NULL;
		}
a229 2
	*buf = b;
}
d231 1
a231 9
void
usbd_get_device_strings(struct usbd_device *dev)
{
	usbd_get_device_string(dev, dev->ddesc.iManufacturer,
	    &dev->vendor);
	usbd_get_device_string(dev, dev->ddesc.iProduct,
	    &dev->product);
	usbd_get_device_string(dev, dev->ddesc.iSerialNumber,
	    &dev->serial);
d1216 4
a1219 1
	usbd_get_device_strings(dev);
@


1.121
log
@Cache vendor, product and serial info for each usb device.  This allows
ioctl(USB_DEVICEINFO) not to issue any further requests to gather
information.  Thus reducing stress on connected usb devices.
This fixes an issue where usbdevs called in a loop causes a USB mass
storage device to halt operation.

Adapted from a similar commit in NetBSD.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.120 2016/03/03 18:13:24 stefan Exp $ */
d220 6
a225 2
		usbd_get_string(dev, index, b, USB_MAX_STRING_LEN);
		usbd_trim_spaces(b);
@


1.120
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.119 2016/01/14 19:53:59 mpi Exp $ */
d66 1
d216 22
d258 5
d325 1
a325 1
	usbd_devinfo_vp(dev, vendor, sizeof vendor, product, sizeof product, 1);
d1219 2
d1337 7
a1343 2
	usbd_get_string(dev, dev->ddesc.iSerialNumber, di->udi_serial,
	    sizeof(di->udi_serial));
d1405 7
@


1.119
log
@Prevent a NULL dereference when detaching a USB device with ugen(4)
disabled or if allocating memory during the attachment process failed.

Problem reported by and original diff from James Hastings on bugs@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.118 2015/10/24 14:01:40 stsp Exp $ */
d1313 1
a1313 1
usbd_get_cdesc(struct usbd_device *dev, int index, int *lenp)
d1316 1
a1316 1
	int len;
d1328 1
a1328 1
		DPRINTFN(5,("usbd_get_cdesc: current, len=%d\n", len));
d1335 1
a1335 1
		DPRINTFN(5,("usbd_get_cdesc: index=%d, len=%d\n", index, len));
@


1.118
log
@Wait a short while between setting a USB device's address and reloading
its descriptor. Fixes flaky attach of USB devices (most importantly the
detachable keyboard) on the Thinkpad Helix 2, and perhaps elsewhere.
Problem diagnosed by mpi; ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.117 2015/03/23 22:26:01 jsg Exp $ */
d1385 4
a1388 2
	for (i = 0; dev->subdevs[i] != NULL; i++)
		rv |= config_detach(dev->subdevs[i], DETACH_FORCE);
@


1.117
log
@Return an error if getting the config descriptor failed.
Avoids a NULL dereference encountered with a device I have.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.116 2014/12/21 12:04:01 mpi Exp $ */
d1153 3
@


1.116
log
@Always clear a port reset feature after setting it, or at least try to.
Otherwise we might leave a port in an unwanted state.

Found while investigating timeout issues on xhci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.115 2014/12/13 21:05:33 doug Exp $ */
d1318 2
@


1.115
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.114 2014/12/09 07:05:06 doug Exp $ */
d373 1
a373 1
usbd_status
a376 1
	usbd_status err;
d379 2
a380 1
	err = usbd_set_port_feature(dev, port, UHF_PORT_RESET);
a381 2
	if (err)
		return (err);
d386 3
a388 4
		err = usbd_get_port_status(dev, port, &ps);
		if (err) {
			DPRINTF(("%s: get status failed %d\n", __func__, err));
			return (err);
d392 1
a392 1
			return (USBD_NORMAL_COMPLETION);
d394 7
d402 1
a402 6
		return (USBD_TIMEOUT);
	err = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);
#ifdef USB_DEBUG
	if (err)
		DPRINTF(("%s: clear port feature failed %d\n", __func__, err));
#endif
d406 1
a406 1
	return (err);
@


1.114
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.113 2014/11/10 11:01:13 mpi Exp $ */
d897 1
a897 1
		ifaces = malloc(nifaces * sizeof(*ifaces), M_USB, M_NOWAIT);
d908 2
a909 2
		len = (nifaces + 2) * sizeof dv;
		dev->subdevs = malloc(len, M_USB, M_NOWAIT | M_ZERO);
d915 1
@


1.113
log
@Remove USB locators.  They are currently unused and this wont change due
to the way USB buses are discovered.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.112 2014/11/01 14:44:08 mpi Exp $ */
d494 2
a495 2
		ifc->endpoints = malloc(nendpt * sizeof(struct usbd_endpoint),
					M_USB, M_NOWAIT);
d747 1
a747 1
	dev->ifaces = malloc(nifc * sizeof(struct usbd_interface),
@


1.112
log
@Remove the port status argument from usbd_reset_port().  We don't do
anything with it and it simplifies this mess in order to implement
warm reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.111 2014/11/01 10:21:02 mpi Exp $ */
a68 1
int		usbd_submatch(struct device *, void *, void *);
d861 1
a861 1
	dv = config_found_sm(parent, &uaa, usbd_print, usbd_submatch);
d921 1
a921 2
			dv = config_found_sm(parent, &uaa, usbd_print,
					   usbd_submatch);
d957 1
a957 1
	dv = config_found_sm(parent, &uaa, usbd_print, usbd_submatch);
a1242 39
}

int
usbd_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct usb_attach_arg *uaa = aux;

	DPRINTFN(5,("usbd_submatch port=%d,%d configno=%d,%d "
	    "ifaceno=%d,%d vendor=0x%x,0x%x product=0x%x,0x%x release=%d,%d\n",
	    uaa->port, cf->uhubcf_port,
	    uaa->configno, cf->uhubcf_configuration,
	    uaa->ifaceno, cf->uhubcf_interface,
	    uaa->vendor, cf->uhubcf_vendor,
	    uaa->product, cf->uhubcf_product,
	    uaa->release, cf->uhubcf_release));
	if (uaa->port != 0 &&	/* root hub has port 0, it should match */
	    ((uaa->port != 0 &&
	      cf->uhubcf_port != UHUB_UNK_PORT &&
	      cf->uhubcf_port != uaa->port) ||
	     (uaa->configno != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != uaa->configno) ||
	     (uaa->ifaceno != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != uaa->ifaceno) ||
	     (uaa->vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != uaa->vendor) ||
	     (uaa->product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != uaa->product) ||
	     (uaa->release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != uaa->release)
	     )
	   )
		return 0;
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
@


1.111
log
@Use usbd_set_port_feature() instead of rerolling it.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.110 2014/10/05 08:40:29 mpi Exp $ */
d344 1
a344 2
usbd_port_disown_to_1_1(struct usbd_device *dev, int port,
    usb_port_status_t *ps)
d346 1
d359 1
a359 1
		err = usbd_get_port_status(dev, port, ps);
d365 1
a365 1
		if (!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
d367 1
a367 1
	} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);
d375 1
a375 1
usbd_reset_port(struct usbd_device *dev, int port, usb_port_status_t *ps)
d377 1
d382 1
a382 2
	DPRINTFN(1,("usbd_reset_port: port %d reset done, error=%s\n",
		    port, usbd_errstr(err)));
d389 1
a389 1
		err = usbd_get_port_status(dev, port, ps);
d391 1
a391 2
			DPRINTF(("usbd_reset_port: get status failed %d\n",
				 err));
d395 1
a395 1
		if (!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
d397 1
a397 1
	} while ((UGETW(ps->wPortChange) & UPS_C_PORT_RESET) == 0 && --n > 0);
d403 1
a403 2
		DPRINTF(("usbd_reset_port: clear port feature failed %d\n",
			 err));
a999 1
	usb_port_status_t ps;
d1092 1
a1092 1
		usbd_reset_port(up->parent, port, &ps);
d1105 1
a1105 1
		usbd_reset_port(up->parent, port, &ps);
d1176 1
a1176 1
			(void) usbd_port_disown_to_1_1(dev->myhub, port, &ps);
d1178 1
a1178 1
			(void) usbd_reset_port(dev->myhub, port, &ps);
@


1.110
log
@Do not re-establish the default pipe twice for every controller.  Move
this hack in the drivers that need it.

Tested by many, thanks!  ok pirofti@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.109 2014/10/01 08:29:01 mpi Exp $ */
a346 1
	usb_device_request_t req;
d350 1
a350 6
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, UHF_PORT_DISOWN_TO_1_1);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	err = usbd_do_request(dev, &req, 0);
a376 1
	usb_device_request_t req;
d380 1
a380 6
	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, UHF_PORT_RESET);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	err = usbd_do_request(dev, &req, 0);
@


1.109
log
@Check that the speed of a new device does not exceed its parent's speed
prior to calling usbd_new_device().

This will let us set the specified default Max Packet Size before opening
the control pipe and reduces spaghetti!

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.108 2014/08/10 12:58:49 mpi Exp $ */
d904 2
a905 2
			printf("%s: port %d, set config at addr %d failed\n",
			    parent->dv_xname, port, addr);
a1162 17
	/* Re-establish the default pipe with the new max packet size. */
	usbd_close_pipe(dev->default_pipe);
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe);
	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
	}

	err = usbd_reload_device_desc(dev);
	if (err) {
		usb_free_device(dev);
		up->device = NULL;
		return (err);
	}

d1178 1
a1178 4
	/* Re-establish the default pipe with the new address. */
	usbd_close_pipe(dev->default_pipe);
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
	    &dev->default_pipe);
@


1.108
log
@Do not allocate space for the whole structure when we just want to store
a pointer, found by clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.107 2014/08/09 09:45:14 mpi Exp $ */
a1054 11
	if (up->parent && speed > up->parent->speed) {
		DPRINTF(("%s: maximum speed of attached device, "
		    "%d, is higher than speed of parent hub, %d\n",
		    __func__, speed, up->parent->speed));
		/*
		 * Reduce the speed, otherwise we won't setup the
		 * proper transfer methods.
		 */
		speed = up->parent->speed;
	}
	
@


1.107
log
@Do not store the whole USB hub descriptor in the "struct usbd_hub"
to help integrating super speed hubs that use a different descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.106 2014/07/12 18:48:53 tedu Exp $ */
d912 1
a912 2
		ifaces = malloc(nifaces * sizeof(struct usbd_interface),
		    M_USB, M_NOWAIT);
@


1.106
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.105 2014/07/12 07:18:16 mpi Exp $ */
d1073 1
a1073 1
		for (p = 0; p < hub->hub->hubdesc.bNbrPorts; p++) {
d1370 1
a1370 2
		    i < nitems(di->udi_ports) &&
		    i < dev->hub->hubdesc.bNbrPorts; i++) {
d1387 1
a1387 1
		di->udi_nports = dev->hub->hubdesc.bNbrPorts;
@


1.105
log
@Remove incorrect comment about how autoconf(9) works and document
that usbd_detach() should only be called by the thread doing USB
bus exploration to prevent attach/detach races.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.104 2014/07/12 07:11:17 mpi Exp $ */
d573 1
a573 1
		free(ifc->endpoints, M_USB);
d584 1
a584 1
		free(ifc->endpoints, M_USB);
d637 2
a638 2
		free(dev->ifaces, M_USB);
		free(dev->cdesc, M_USB);
d783 1
a783 1
	free(cdp, M_USB);
d811 1
a811 1
		free(p, M_USB);
d927 1
a927 1
			free(ifaces, M_USB);
d944 1
a944 1
		free(ifaces, M_USB);
d957 1
a957 1
		free(dev->subdevs, M_USB);
d1276 1
a1276 1
			free(devinfop, M_TEMP);
d1290 1
a1290 1
	free(devinfop, M_TEMP);
d1425 1
a1425 1
			free(cdesc, M_TEMP);
d1447 1
a1447 1
		free(dev->ifaces, M_USB);
d1450 1
a1450 1
		free(dev->cdesc, M_USB);
d1452 1
a1452 1
		free(dev->subdevs, M_USB);
d1455 1
a1455 1
	free(dev, M_USB);
@


1.104
log
@Only detach the USB device you disconnected, fix a regression reported
by guenther@@.

While here set the dying flag of the disconnected device so that most of
the DVACT_ACTIVATE handlers can go.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.103 2014/07/10 11:47:14 mpi Exp $ */
d1459 2
a1460 15
 * The general mechanism for detaching drivers works as follows: Each
 * driver is responsible for maintaining a reference count on the
 * number of outstanding references to its softc (e.g.  from
 * processing hanging in a read or write).  The detach method of the
 * driver decrements this counter and flags in the softc that the
 * driver is dying and then wakes any sleepers.  It then sleeps on the
 * softc.  Each place that can sleep must maintain the reference
 * count.  When the reference count drops to -1 (0 is the normal value
 * of the reference count) the a wakeup on the softc is performed
 * signaling to the detach waiter that all references are gone.
 */

/*
 * Called from process context when we discover that a port has
 * been disconnected.
@


1.103
log
@Always assign the device address found by the USB stack even if it
does not match the hardware address.

This change only matters for xHCI buses where the controller assigns
device addresses.  But it is the simplest way to comply with the stack
requirement of assigning the first `logical' address to the root hub
device.

Device addresses are not much used anyway and a cleanup will follow to
avoid possible confusions.

This makes usbdevs(8) correctly report devices connected to xhci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.102 2014/07/09 18:15:04 mpi Exp $ */
d1478 6
a1483 1
	int rv;
a1484 1
	rv = config_detach_children(parent, DETACH_FORCE);
@


1.102
log
@autoconf(9) is your friend and it knows you more than you think.  It
even knows your children!  So let him handle the seperation correctly.

Do not rewrite your own custom config_detach_children(9) and as a bonus
start removing the usbd_port tentacles from the stack.

ok pirofti@@, yuo@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.101 2014/07/09 15:47:54 mpi Exp $ */
a830 3
	dev->address = addr;
	dev->bus->devices[addr] = dev;

d1199 7
@


1.101
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.100 2014/03/08 11:42:56 mpi Exp $ */
d75 1
a75 1
void		usb_free_device(struct usbd_device *, struct usbd_port *);
d1095 2
a1096 1
		usb_free_device(dev, up);
a1140 1
	/* fail to get device descriptor, give up */
d1142 2
a1143 3
		DPRINTFN(-1, ("usbd_new_device: addr=%d, getting first desc "
		    "failed\n", addr));
		usb_free_device(dev, up);
d1165 2
a1166 4
		/* Illegal device descriptor */
		DPRINTFN(-1,("usbd_new_device: illegal descriptor %d\n",
		    dd->bDescriptorType));
		usb_free_device(dev, up);
d1171 2
a1172 2
		DPRINTFN(-1,("usbd_new_device: bad length %d\n", dd->bLength));
		usb_free_device(dev, up);
d1183 2
a1184 1
		usb_free_device(dev, up);
d1190 2
a1191 1
		usb_free_device(dev, up);
d1198 2
a1199 1
 		usb_free_device(dev, up);
d1208 2
a1209 1
		usb_free_device(dev, up);
d1235 2
a1236 1
		usb_free_device(dev, up);
d1429 1
a1429 1
usb_free_device(struct usbd_device *dev, struct usbd_port *up)
a1448 1
	up->device = NULL;
d1471 2
a1472 2
void
usb_disconnect_port(struct usbd_port *up, struct device *parent)
d1474 1
a1474 5
	struct usbd_device *dev = up->device;
	int i;

	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n",
		    up, dev, up->portno));
d1476 3
a1478 23
#ifdef DIAGNOSTIC
	if (dev == NULL) {
		printf("usb_disconnect_port: no device\n");
		return;
	}
#endif

	if (dev->subdevs != NULL) {
		DPRINTFN(3,("usb_disconnect_port: disconnect subdevs\n"));
		for (i = 0; dev->subdevs[i]; i++) {
			DPRINTF(("%s: at %s", dev->subdevs[i]->dv_xname,
			    parent->dv_xname));
			if (up->portno != 0)
				DPRINTF((" port %d", up->portno));
			DPRINTF((" (addr %d) deactivated\n", dev->address));
			config_deactivate(dev->subdevs[i]);
		}
		for (i = 0; dev->subdevs[i]; i++) {
			DPRINTF((" (addr %d) disconnected\n", dev->address));
			config_detach(dev->subdevs[i], DETACH_FORCE);
			dev->subdevs[i] = 0;
		}
	}
d1480 1
a1480 1
	usb_free_device(dev, up);
@


1.100
log
@Pass M_ZERO to malloc(9) when allocating usbd pipes to make sure to
initialize the per-controller part.

ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.99 2014/03/07 18:59:40 mpi Exp $ */
d819 22
d846 1
a846 1
		if (bus->devices[addr] == 0)
a1191 2
		DPRINTFN(-1, ("usbd_new_device: addr=%d, getting full desc "
		    "failed\n", addr));
d1196 6
a1201 14
	/* Set the address. */
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	err = usbd_set_address(dev, addr);
	if (err) {
		DPRINTFN(-1,("usbd_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usb_free_device(dev, up);
		return (err);
	}

	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);
	dev->address = addr;	/* New device address now */
	bus->devices[addr] = dev;
@


1.99
log
@Print the wrong device descriptor's bMaxPacketSize before correcting it
for USB2 devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.98 2014/02/09 13:21:48 mpi Exp $ */
d796 1
a796 1
	DPRINTFN(1,("usbd_setup_pipe: dev=%p iface=%p ep=%p pipe=%p\n",
d798 1
a798 1
	p = malloc(dev->bus->pipe_size, M_USB, M_NOWAIT);
a804 4
	p->intrxfer = 0;
	p->running = 0;
	p->aborting = 0;
	p->repeat = 0;
d809 1
a809 2
		DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed, error="
			 "%s\n",
@


1.98
log
@Make sure to close the default pipe before re-opening it when we want
to update the address and packet length, fixes a memory leak introduced
in revision 1.96.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.97 2014/02/09 11:47:01 mpi Exp $ */
d1135 2
a1136 2
			printf("usbd_new_device: addr=%d bad max packet size\n",
			    addr);
@


1.97
log
@Do not allow to unconfigure a device by setting the configuration
number 0, leaving its descriptors pointing to NULL.  There's a lot
of code in our stack that assumes that the various descriptors are
always valid and changing this would be too much work for the moment.

Fix an issue reported by Thomas Pfaff, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.96 2014/01/15 11:10:40 mpi Exp $ */
d1165 1
a1165 1
	usbd_abort_pipe(dev->default_pipe);
d1197 1
a1197 1
	usbd_abort_pipe(dev->default_pipe);
@


1.96
log
@Remove a hack to update the address and packet length for every device
request and instead re-open the default pipe with updated values when
attaching a new device, adapted from FreeBSD r162977.

This fixes a problem where the controller could have cached the previous
values and would fail to get the device descriptor, leaving the device
unrecognized with a message like: "device problem, disabling port n".
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.95 2013/11/19 14:04:07 pirofti Exp $ */
a605 3

	if (no == USB_UNCONFIG_NO)
		return (usbd_set_config_index(dev, USB_UNCONFIG_INDEX, msg));
@


1.95
log
@Kill matchlvl usage throughout the usb stack.

Allows us to move forward on cleaning.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.94 2013/11/02 12:23:58 mpi Exp $ */
d1167 9
d1199 9
a1209 1
		
@


1.94
log
@Remove a layer of abstraction for fetching a configuration descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.93 2013/08/21 13:45:34 mpi Exp $ */
a1302 12
	if (cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	    cf->uhubcf_vendor == uaa->vendor &&
	    cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	    cf->uhubcf_product == uaa->product) {
		/* We have a vendor&product locator match */
		if (cf->uhubcf_release != UHUB_UNK_RELEASE &&
		    cf->uhubcf_release == uaa->release)
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT_REV;
		else
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT;
	} else
		uaa->matchlvl = 0;
@


1.93
log
@Unswap address and configuration value arguments in a debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.92 2013/08/13 09:26:04 mpi Exp $ */
d613 3
a615 2
		err = usbd_get_config_desc(dev, index, &cd);
		if (err)
d658 3
a660 2
	err = usbd_get_config_desc(dev, index, &cd);
	if (err)
d1399 3
a1401 2
		err = usbd_get_config_desc(dev, index, &cdescr);
		if (err)
@


1.92
log
@Remove bogus and useless refcounting of usbd pipes that could lead to
memory leaks and abort the pipe if requests are still pending because
most of our drivers don't do anything if usbd_close_pipe() fails.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.91 2013/08/08 09:44:22 mpi Exp $ */
d723 2
a724 2
		 "selfpowered=%d, power=%d\n",
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes,
@


1.91
log
@These functions should only used in the usb-autoconf glue, do not expose
them.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.89 2013/04/15 09:23:02 mglocker Exp $ */
a805 1
	p->refcnt = 1;
@


1.90
log
@Use the same functions to abort and close the control pipe of a device
as for every other pipes instead of having another function calling the
host controller method.
@
text
@d74 3
@


1.89
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.88 2013/04/10 07:48:36 mpi Exp $ */
a70 1
void		usbd_kill_pipe(struct usbd_pipe *);
a821 10
/* Abort the device control pipe. */
void
usbd_kill_pipe(struct usbd_pipe *pipe)
{
	usbd_abort_pipe(pipe);
	pipe->methods->close(pipe);
	pipe->endpoint->refcnt--;
	free(pipe, M_USB);
}

d1419 4
a1422 2
	if (dev->default_pipe != NULL)
		usbd_kill_pipe(dev->default_pipe);
@


1.88
log
@Merge usbd_get_device_desc() into the only function using them.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.87 2013/04/10 07:39:43 mpi Exp $ */
d62 3
a64 3
usbd_status	usbd_set_config(usbd_device_handle, int);
void		usbd_devinfo(usbd_device_handle, int, char *, size_t);
void		usbd_devinfo_vp(usbd_device_handle, char *, size_t,
d66 2
a67 2
char		*usbd_get_string(usbd_device_handle, int, char *, size_t);
int		usbd_getnewaddr(usbd_bus_handle);
d70 2
a71 2
void		usbd_free_iface_data(usbd_device_handle, int);
void		usbd_kill_pipe(usbd_pipe_handle);
d73 1
a73 1
			    usbd_device_handle, int, int);
d116 1
a116 1
usbd_get_string_desc(usbd_device_handle dev, int sindex, int langid,
d152 1
a152 1
usbd_get_string(usbd_device_handle dev, int si, char *buf, size_t buflen)
d214 1
a214 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, size_t vl,
d288 1
a288 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *base, size_t len)
d319 1
a319 1
usb_delay_ms(usbd_bus_handle bus, u_int ms)
d333 1
a333 1
usbd_delay_ms(usbd_device_handle dev, u_int ms)
d342 2
a343 1
usbd_port_disown_to_1_1(usbd_device_handle dev, int port, usb_port_status_t *ps)
d379 1
a379 1
usbd_reset_port(usbd_device_handle dev, int port, usb_port_status_t *ps)
d488 1
a488 1
usbd_fill_iface_data(usbd_device_handle dev, int ifaceidx, int altidx)
d490 1
a490 1
	usbd_interface_handle ifc = &dev->ifaces[ifaceidx];
d578 1
a578 1
usbd_free_iface_data(usbd_device_handle dev, int ifcno)
d580 1
a580 1
	usbd_interface_handle ifc = &dev->ifaces[ifcno];
d586 1
a586 1
usbd_set_config(usbd_device_handle dev, int conf)
d599 1
a599 1
usbd_set_config_no(usbd_device_handle dev, int no, int msg)
d621 1
a621 1
usbd_set_config_index(usbd_device_handle dev, int index, int msg)
d789 2
a790 2
usbd_setup_pipe(usbd_device_handle dev, usbd_interface_handle iface,
		struct usbd_endpoint *ep, int ival, usbd_pipe_handle *pipe)
d792 1
a792 1
	usbd_pipe_handle p;
d825 1
a825 1
usbd_kill_pipe(usbd_pipe_handle pipe)
d834 1
a834 1
usbd_getnewaddr(usbd_bus_handle bus)
d845 1
a845 1
usbd_probe_and_attach(struct device *parent, usbd_device_handle dev, int port,
d853 1
a853 1
	usbd_interface_handle *ifaces;
d908 1
a908 1
		ifaces = malloc(nifaces * sizeof(usbd_interface_handle),
d1005 1
a1005 1
usbd_new_device(struct device *parent, usbd_bus_handle bus, int depth,
d1008 1
a1008 1
	usbd_device_handle dev, adev;
d1228 1
a1228 1
usbd_reload_device_desc(usbd_device_handle dev)
d1326 1
a1326 1
usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di,
d1391 1
a1391 1
usbd_get_cdesc(usbd_device_handle dev, int index, int *lenp)
d1424 1
a1424 1
usb_free_device(usbd_device_handle dev, struct usbd_port *up)
d1468 1
a1468 1
	usbd_device_handle dev = up->device;
@


1.87
log
@Merge usb_devinfo* helper functions into usbd_print(), nothing else use
them.

ok ratchov@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.85 2013/04/01 19:49:53 mglocker Exp $ */
d1232 2
a1233 1
	err = usbd_get_device_desc(dev, &dev->ddesc);
@


1.86
log
@There's no need for usbd_get_config_desc_full() so just call usbd_get_desc()
directly this also makes it easier to understand which function actually
generates IO.

ok mglocker@@
@
text
@a316 16
char *
usbd_devinfo_alloc(usbd_device_handle dev, int showclass)
{
	char *devinfop;

	devinfop = malloc(DEVINFOSIZE, M_TEMP, M_WAITOK);
	usbd_devinfo(dev, showclass, devinfop, DEVINFOSIZE);
	return devinfop;
}

void
usbd_devinfo_free(char *devinfop)
{
	free(devinfop, M_TEMP);
}

d1248 2
a1249 1
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
d1254 1
a1254 1
			usbd_devinfo_free(devinfop);
d1268 1
a1268 1
	usbd_devinfo_free(devinfop);
@


1.85
log
@Make ugen_get_cdesc() a generic function by renaming it to usbd_get_cdesc()
and move it to usb_subr.c.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.84 2013/03/28 03:58:03 tedu Exp $ */
d1427 1
a1427 1
		err = usbd_get_config_desc_full(dev, index, cdesc, len);
@


1.84
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.83 2013/03/16 11:11:22 mpi Exp $ */
d1400 34
@


1.83
log
@No need for two similar functions to free/remove USB device descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.82 2012/05/15 12:52:44 mpi Exp $ */
a40 1
#include <sys/proc.h>
@


1.82
log
@Set the usb(4) unit number as bus number. This fixes a possible
conflict where machines with two controllers with the same unit
number (i.e. ehci0 and uhci0) would have reported to buses 0.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.81 2012/01/08 13:12:38 miod Exp $ */
d970 1
a970 1
		dev->subdevs = 0;
d1104 1
a1104 1
		usbd_remove_device(dev, up);
d1153 1
a1153 1
		usbd_remove_device(dev, up);
d1178 1
a1178 1
		usbd_remove_device(dev, up);
d1184 1
a1184 1
		usbd_remove_device(dev, up);
d1194 1
a1194 1
		usbd_remove_device(dev, up);
d1204 1
a1204 1
		usbd_remove_device(dev, up);
d1236 1
a1236 1
		usbd_remove_device(dev, up);
a1258 13
void
usbd_remove_device(usbd_device_handle dev, struct usbd_port *up)
{
	DPRINTF(("usbd_remove_device: %p\n", dev));

	if (dev->default_pipe != NULL)
		usbd_kill_pipe(dev->default_pipe);
	up->device = NULL;
	dev->bus->devices[dev->address] = NULL;

	free(dev, M_USB);
}

d1404 1
a1404 1
usb_free_device(usbd_device_handle dev)
d1408 2
d1422 3
d1478 1
a1478 3
	dev->bus->devices[dev->address] = NULL;
	up->device = NULL;
	usb_free_device(dev);
@


1.81
log
@Remove usb_event_cookie_t type and instances of it found in various structs;
leftover from the "usb event" stuff removal. Diff from Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.80 2011/01/25 20:03:36 jakemsr Exp $ */
d1359 1
a1359 1
	di->udi_bus = dev->bus->bdev.dv_unit;
@


1.80
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.79 2011/01/16 22:35:29 jakemsr Exp $ */
a75 2
u_int32_t	usb_cookie_no = 0;

a1098 1
	dev->cookie.cookie = ++usb_cookie_no;
a1360 1
	di->udi_cookie = dev->cookie;
@


1.79
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.78 2011/01/15 23:58:43 jakemsr Exp $ */
a1236 2
	usbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);

a1489 1
	usbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);
@


1.78
log
@* add 'udi_serial' to struct usb_device_info.
* fill 'udi_serial' with the serial number in usbd_fill_deviceinfo().
* add compatability ioctl/struct so old binaries continue to work.

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.77 2010/12/17 22:38:54 jasper Exp $ */
d780 1
a780 1
	    M_USB, M_NOWAIT);
a861 1

d868 1
a868 1
	int found, i, confi, nifaces, len;
d897 2
a898 2
		dev->subdevs[0] = dv;
		dev->subdevs[1] = 0;
d936 3
a938 1
		len = (nifaces+1) * sizeof dv;
a945 1
		found = 0;
d947 2
a948 2
			if (ifaces[i] == NULL)
				continue; /* interface already claimed */
a952 1

d954 2
a955 2
				dev->subdevs[found++] = dv;
				ifaces[i] = NULL; /* consumed */
d959 10
a968 3
		if (found != 0) {
			err = USBD_NORMAL_COMPLETION;
			goto fail;
d970 1
d981 1
d985 2
a986 1
	uaa.configno = UHUB_UNK_CONFIGURATION;
d990 6
a995 4
		dev->subdevs = malloc(2 * sizeof dv, M_USB, M_NOWAIT);
		if (dev->subdevs == 0) {
			err = USBD_NOMEM;
			goto fail;
d997 2
a998 2
		dev->subdevs[0] = dv;
		dev->subdevs[1] = 0;
@


1.77
log
@- use nitems()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.76 2010/12/15 00:59:26 jakemsr Exp $ */
d1405 4
@


1.76
log
@don't delay if the device is dying

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.75 2010/12/06 04:30:57 jakemsr Exp $ */
d1384 1
a1384 1
		    i < sizeof(di->udi_ports) / sizeof(di->udi_ports[0]) &&
@


1.75
log
@call config_deactivate() before config_detach() when detaching devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.74 2010/09/24 00:12:36 deraadt Exp $ */
d354 3
@


1.74
log
@tsleep on a static and private handle, since our goal is to not be
woken up by a wakeup, but only by the actual timeout expiry.  On
architectures which share a kva upage area between processes, we would
not want an accidental wakeup (too short).
discussed with various
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.73 2009/01/14 21:02:57 fgsch Exp $ */
d1464 4
@


1.73
log
@cap device's speed to the parent's one if higher. from FreeBSD.
krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.72 2008/11/24 15:12:00 yuo Exp $ */
d340 2
d346 2
a347 1
		tsleep(&ms, PRIBIO, "usbdly", (ms*hz+999)/1000 + 1);
@


1.72
log
@change a device descriptor get logic during the enumeration process.

Some device could not handle the device descriptor request
with short bLength (less than the device descriptor size(18 byte)).
To handle such kind of devices, add complemental request loop to
current logic.

(memo: and I also found a device which can not response to any device
 descriptor request. It always returns only 8 byte-length head of the
 descriptor for 1st query. This is the reason why the device descriptor
 loop of this usb subsystem start with 8-byte length query.)
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.71 2008/08/03 02:02:14 fgsch Exp $ */
d1052 11
@


1.71
log
@revert part of rev. 1.65 where we set the address earlier. this seems
to cause issues as per netbsd pr/39023.  deraadt@@ yuo@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.70 2008/07/28 20:49:28 fgsch Exp $ */
d1084 8
a1091 2
	/* Try a few times in case the device is slow (i.e. outside specs.) */
	for (i = 0; i < 15; i++) {
d1093 2
d1098 24
a1121 4
		if ((i % 4) == 0)
			usbd_reset_port(up->parent, port, &ps);
		else
			usbd_delay_ms(dev, 200);
d1123 2
@


1.70
log
@When getting the string descriptors, fetch 2 bytes (size and type) first,
and then the whole string based on the returned size, not just one byte.
The Lexar card reader kindly loaned by
Denis Doroshenko (denis dot doroshenko at gmail.com) it's happy now, and
after further inspection it's what other OSs do.
Discussed with yuo@@. krw@@ yuo@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.69 2008/06/29 10:04:15 yuo Exp $ */
a1082 23
	/* Set the address. Do this early; some devices need that. */
	/* Try a few times in case the device is slow (i.e. outside specs.) */
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	for (i = 0; i < 15; i++) {
		err = usbd_set_address(dev, addr);
		if (!err)
			break;
		if ((i % 4) == 0)
			usbd_reset_port(up->parent, port, &ps);
		else
			usbd_delay_ms(dev, 200);
	}
	if (err) {
		DPRINTFN(-1,("usbd_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usbd_remove_device(dev, up);
		return (err);
	}
	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);
	dev->address = addr;	/* New device address now */
	bus->devices[addr] = dev;

d1142 15
@


1.69
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.68 2008/06/26 05:42:19 ray Exp $ */
d130 1
a130 1
	USETW(req.wLength, 1);	/* only size byte first */
d136 1
a136 1
	if (actlen < 1)
@


1.68
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.67 2008/06/21 22:28:21 fgsch Exp $ */
d355 36
d1164 14
@


1.67
log
@print vendor and product in hexa on debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.66 2008/05/19 15:51:43 fgsch Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.66
log
@do not leak memory if there is no power source. code is ifdef USB_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.65 2008/05/19 14:05:43 fgsch Exp $ */
d1220 1
a1220 1
	    "ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\n",
@


1.65
log
@try a few times before giving up while getting the device descriptor. if
it fails, reset the port and try again. this seems to fix some devices that
would punt with "device problem, disabling port" otherwise.
from augustss@@netbsd with some change as per discussion with theo.
set the address before getting the descriptor. from peterbu at bemac dot com
via netbsd kern/24716.
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.64 2007/11/04 05:52:36 deraadt Exp $ */
d712 2
a713 1
		return (USBD_IOERROR);
@


1.64
log
@improve/repair locator printing; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.63 2007/10/11 18:33:15 deraadt Exp $ */
d982 1
d1053 23
d1078 1
a1078 1
	for (i = 0; i < 5; i++) {
d1083 4
a1086 2
		/* progressively increase the delay */
		usbd_delay_ms(dev, 200 * (i + 1));
a1134 15

	/* Set the address */
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	err = usbd_set_address(dev, addr);
	if (err) {
		DPRINTFN(-1,("usbd_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
		usbd_remove_device(dev, up);
		return (err);
	}
	/* Allow device time to set new address */
	usbd_delay_ms(dev, USB_SET_ADDRESS_SETTLE);

	dev->address = addr;	/* New device address now */
	bus->devices[addr] = dev;
@


1.63
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.62 2007/10/11 18:30:50 deraadt Exp $ */
d1186 1
a1186 1
		printf("%s, %s", devinfop, pnp);
d1195 2
a1196 2
	/* Display device info string */
	printf(" %s\n", devinfop);
@


1.62
log
@serialize usbd_probe_and_attach(); only let one usb device be match'd and
attached at a time; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.61 2007/10/06 23:50:55 krw Exp $ */
d316 1
a316 1
	snprintf(cp, base + len - cp, ", rev ");
d324 1
a324 1
	snprintf(cp, base + len - cp, ", addr %d", dev->address);
d1176 3
a1178 1
	char devinfo[1024];
d1182 2
a1183 1
		if (!uaa->usegeneric)
d1185 2
a1186 2
		usbd_devinfo(uaa->device, 1, devinfo, sizeof devinfo);
		printf("%s, %s", devinfo, pnp);
d1194 4
a1197 13
#if 0
	/*
	 * It gets very crowded with these locators on the attach line.
	 * They are not really needed since they are printed in the clear
	 * by each driver.
	 */
	if (uaa->vendor != UHUB_UNK_VENDOR)
		printf(" vendor 0x%04x", uaa->vendor);
	if (uaa->product != UHUB_UNK_PRODUCT)
		printf(" product 0x%04x", uaa->product);
	if (uaa->release != UHUB_UNK_RELEASE)
		printf(" release 0x%04x", uaa->release);
#endif
@


1.61
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.60 2007/09/11 13:39:34 gilles Exp $ */
d49 1
d837 3
d854 1
a854 1
	DPRINTF(("usbd_probe_and_attach: trying device specific drivers\n"));
d858 4
a861 2
		if (dev->subdevs == NULL)
			return (USBD_NOMEM);
d864 2
a865 1
		return (USBD_NORMAL_COMPLETION);
d887 1
a887 1
 			return (err);
d893 4
a896 2
		if (ifaces == NULL)
			return (USBD_NOMEM);
d905 2
a906 1
			return (USBD_NOMEM);
d925 2
a926 1
			return (USBD_NORMAL_COMPLETION);
d946 4
a949 2
		if (dev->subdevs == 0)
			return (USBD_NOMEM);
d952 2
a953 1
		return (USBD_NORMAL_COMPLETION);
d962 4
a965 1
 	return (USBD_NORMAL_COMPLETION);
@


1.60
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.59 2007/09/09 18:36:13 deraadt Exp $ */
d979 1
a979 1
	dev = malloc(sizeof *dev, M_USB, M_NOWAIT);
a981 1
	memset(dev, 0, sizeof *dev);
@


1.59
log
@add string length arguments to some functions, and do not copy a string
buffer to itself; checked by jsg and kettenis and others
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.58 2007/09/09 01:00:35 fgsch Exp $ */
d893 1
a893 1
		dev->subdevs = malloc(len, M_USB, M_NOWAIT|M_ZERO);
@


1.58
log
@more M_ZERO conversions; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.57 2007/07/21 16:28:50 deraadt Exp $ */
d71 3
a73 3
void		usbd_devinfo_vp(usbd_device_handle, char *, char *,
			    int);
char		*usbd_get_string(usbd_device_handle, int, char *);
d161 1
a161 1
usbd_get_string(usbd_device_handle dev, int si, char *buf)
d191 1
a191 1
	for (i = 0; i < n; i++) {
d201 2
a202 1
	*s++ = 0;
d223 2
a224 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, char *p, int usedev)
d227 1
a227 1
	char *vendor = 0, *product = 0;
d239 1
a239 1
		vendor = usbd_get_string(dev, udd->iManufacturer, v);
d241 1
a241 1
		product = usbd_get_string(dev, udd->iProduct, p);
a242 3
	} else {
		vendor = NULL;
		product = NULL;
d246 1
a246 1
		for(ukv = usb_known_vendors;
d255 1
a255 1
			for(ukp = usb_known_products;
d267 5
a271 2
	if (vendor != NULL && *vendor)
		strlcpy(v, vendor, USB_MAX_STRING_LEN); /* XXX */
d273 6
a278 4
		snprintf(v, USB_MAX_STRING_LEN, "vendor 0x%04x", /* XXX */
		    UGETW(udd->idVendor));
	if (product != NULL && *product)
		strlcpy(p, product, USB_MAX_STRING_LEN); /* XXX */
d280 1
a280 2
		snprintf(p, USB_MAX_STRING_LEN, "product 0x%04x", /* XXX */
		    UGETW(udd->idProduct));
d305 2
a306 2
	usbd_devinfo_vp(dev, vendor, product, 1);
	snprintf(cp, len, "%s %s", vendor, product);
d1252 2
a1253 1
	usbd_devinfo_vp(dev, di->udi_vendor, di->udi_product, usedev);
@


1.57
log
@no need to say in two ways "a set of usb devices went away"; ok by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.56 2007/06/12 16:26:37 mbalmer Exp $ */
d890 1
a890 1
		dev->subdevs = malloc(len, M_USB, M_NOWAIT);
a894 1
		bzero(dev->subdevs, len);
@


1.56
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.55 2007/06/11 06:14:24 mbalmer Exp $ */
a1340 1
	char *hubname = parent->dv_xname;
d1356 2
a1357 2
			printf("%s: at %s", dev->subdevs[i]->dv_xname,
			    hubname);
d1359 2
a1360 2
				printf(" port %d", up->portno);
			printf(" (addr %d) disconnected\n", dev->address);
@


1.55
log
@Remove the definiton and usage of the USB_DO_ATTACH macro.  It was a wrapper
around a single function only and it did not even use all of it's arguments.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.54 2007/06/10 17:46:27 mbalmer Exp $ */
d76 1
a76 1
int		usbd_submatch(device_ptr_t, void *, void *);
d79 1
a79 1
usbd_status	usbd_probe_and_attach(device_ptr_t,
d824 1
a824 1
usbd_probe_and_attach(device_ptr_t parent, usbd_device_handle dev, int port,
d831 1
a831 1
	device_ptr_t dv;
d957 1
a957 1
usbd_new_device(device_ptr_t parent, usbd_bus_handle bus, int depth,
d1338 1
a1338 1
usb_disconnect_port(struct usbd_port *up, device_ptr_t parent)
@


1.54
log
@Get rid of the USBDEVPTRNAME macro.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.53 2007/06/10 15:33:16 mbalmer Exp $ */
d848 1
a848 1
	dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
d903 1
a903 1
			dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print,
d930 1
a930 1
	dv = USB_DO_ATTACH(dev, bdev, parent, &uaa, usbd_print, usbd_submatch);
@


1.53
log
@Remove the definition and use of USBDEVUNIT.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.52 2007/06/10 14:49:01 mbalmer Exp $ */
d870 1
a870 1
				 "error=%s\n", USBDEVPTRNAME(parent), port,
d874 1
a874 1
			    USBDEVPTRNAME(parent), port, addr);
d1266 1
a1266 1
			    USBDEVPTRNAME(dev->subdevs[i]), USB_MAX_DEVNAMELEN);
d1341 1
a1341 1
	char *hubname = USBDEVPTRNAME(parent);
d1357 1
a1357 1
			printf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
@


1.52
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.51 2007/06/05 08:43:56 mbalmer Exp $ */
d1247 1
a1247 1
	di->udi_bus = USBDEVUNIT(dev->bus->bdev);
@


1.51
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.50 2007/06/03 20:49:25 deraadt Exp $ */
d718 1
a718 1
			    USBDEVNAME(dev->bus->bdev), dev->address,
d973 1
a973 1
		    USBDEVNAME(bus->bdev));
@


1.50
log
@delete two extra lines which are not needed because that is how strings
actually work, surprise surprise; ok claudio cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.49 2007/05/21 05:40:28 jsg Exp $ */
d69 3
a71 3
Static usbd_status	usbd_set_config(usbd_device_handle, int);
Static void		usbd_devinfo(usbd_device_handle, int, char *, size_t);
Static void		usbd_devinfo_vp(usbd_device_handle, char *, char *,
d73 7
a79 7
Static char		*usbd_get_string(usbd_device_handle, int, char *);
Static int		usbd_getnewaddr(usbd_bus_handle);
Static int		usbd_print(void *, const char *);
Static int		usbd_submatch(device_ptr_t, void *, void *);
Static void		usbd_free_iface_data(usbd_device_handle, int);
Static void		usbd_kill_pipe(usbd_pipe_handle);
Static usbd_status	usbd_probe_and_attach(device_ptr_t,
d82 1
a82 1
Static u_int32_t	usb_cookie_no = 0;
d88 1
a88 1
Static const char * const usbd_error_strs[] = {
d293 1
a293 1
Static void
d564 1
a564 1
Static usbd_status
@


1.49
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.48 2007/02/28 22:30:55 deraadt Exp $ */
a320 2
	cp += strlen(cp);
	*cp = 0;
@


1.48
log
@place types needed by usbdevs_data.h, directly into that file so that it
is consumable by anyone who includes it (matches idea in pcidevs)
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.47 2006/07/17 05:24:16 miod Exp $ */
d61 2
a62 2
#define DPRINTF(x)	do { if (usbdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) logprintf x; } while (0)
@


1.47
log
@Prefer malloc over the stack for an array of 256 pointers. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.46 2006/07/16 02:01:37 dlg Exp $ */
a84 17
typedef u_int16_t usb_vendor_id_t;
typedef u_int16_t usb_product_id_t;

/*
 * Descriptions of of known vendors and devices ("products").
 */
struct usb_known_vendor {
	usb_vendor_id_t		vendor;
	char			*vendorname;
};

struct usb_known_product {
	usb_vendor_id_t		vendor;
	usb_product_id_t	product;
	char			*productname;
};

@


1.46
log
@some knf, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.45 2006/07/16 01:51:18 dlg Exp $ */
d851 1
a851 1
	usbd_interface_handle ifaces[256]; /* 256 is the absolute max */
d900 4
d911 1
d927 1
a927 1
				ifaces[i] = 0; /* consumed */
d930 1
@


1.45
log
@get rid of ifdef __OtherBSD__ cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.44 2006/06/26 19:12:38 mjc Exp $ */
d69 12
a80 11
Static usbd_status usbd_set_config(usbd_device_handle, int);
Static void usbd_devinfo(usbd_device_handle, int, char *, size_t);
Static void usbd_devinfo_vp(usbd_device_handle, char *, char *, int);
Static char *usbd_get_string(usbd_device_handle, int, char *);
Static int usbd_getnewaddr(usbd_bus_handle bus);
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, void *, void *);
Static void usbd_free_iface_data(usbd_device_handle dev, int ifcno);
Static void usbd_kill_pipe(usbd_pipe_handle);
Static usbd_status usbd_probe_and_attach(device_ptr_t parent,
				 usbd_device_handle dev, int port, int addr);
d82 1
a82 1
Static u_int32_t usb_cookie_no = 0;
d133 5
a137 5
	if (err < USBD_ERROR_MAX) {
		return usbd_error_strs[err];
	} else {
		snprintf(buffer, sizeof buffer, "%d", err);
		return buffer;
d143 1
a143 1
		     usb_string_descriptor_t *sdesc, int *sizep)
d155 1
a155 1
		&actlen, USBD_DEFAULT_TIMEOUT);
d163 2
a164 2
        err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
  	                 &actlen, USBD_DEFAULT_TIMEOUT);
d194 3
a196 3
	                 err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us,
                           &size);
  	                 if (err || size < 4) {
d198 1
a198 1
		} else {
d519 2
a520 2
				     "len=%d type=%d\n",
				 p, end, ed->bLength, ed->bDescriptorType));
d530 3
a532 3
		       ed->bLength == 0 ? "0 length" :
		       ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
		       "out of data");
d551 1
a551 1
					       "packet size\n");
d672 1
a672 1
			     cdp->bDescriptorType));
d736 4
a739 4
				 "budget, %d mA > %d mA\n",
			       USBDEVNAME(dev->bus->bdev), dev->address,
			       cdp->bConfigurationValue,
			       power, dev->powersrc->power);
d748 1
a748 1
		 cdp->bConfigurationValue));
d752 1
a752 2
			 "error=%s\n",
			 cdp->bConfigurationValue, usbd_errstr(err)));
d759 1
a759 1
			     M_USB, M_NOWAIT);
d843 2
a844 2
usbd_probe_and_attach(device_ptr_t parent, usbd_device_handle dev,
		      int port, int addr)
d893 1
a893 1
			       USBDEVPTRNAME(parent), port, addr);
d986 1
a986 1
		       USBDEVNAME(bus->bdev));
d1019 2
a1020 2
	     hub != NULL && hub->speed != USB_SPEED_HIGH;
	     adev = hub, hub = hub->myhub)
d1041 1
a1041 1
			      &dev->default_pipe);
d1059 1
a1059 1
			      "failed\n", addr));
d1069 1
a1069 1
			       addr);
d1084 1
a1084 1
			     dd->bDescriptorType));
d1100 1
a1100 1
			      "failed\n", addr));
d1255 1
a1255 1
		     int usedev)
d1277 3
a1279 4
		for (i = 0; dev->subdevs[i] &&
			     i < USB_MAX_DEVNAMES; i++) {
			strncpy(di->udi_devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
				USB_MAX_DEVNAMELEN);
d1281 6
a1286 6
                }
        } else {
                i = 0;
        }
        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)
                di->udi_devnames[i][0] = 0;                 /* empty */
d1290 2
a1291 3
		     i < sizeof(di->udi_ports) / sizeof(di->udi_ports[0]) &&
			     i < dev->hub->hubdesc.bNbrPorts;
		     i++) {
d1371 1
a1371 1
			       hubname);
@


1.44
log
@fix typos in debug messages
ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.43 2006/05/31 06:18:09 pascoe Exp $ */
a45 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a47 4
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#endif
a59 5
#if defined(__FreeBSD__)
#include <machine/clock.h>
#define delay(d)         DELAY(d)
#endif

a73 4
#if defined(__NetBSD__)
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, struct cfdata *cf, void *);
#elif defined(__OpenBSD__)
a75 1
#endif
a852 14
#if defined(__FreeBSD__)
	/*
	 * XXX uaa is a static var. Not a problem as it _should_ be used only
	 * during probe and attach. Should be changed however.
	 */
	device_t bdev;
	bdev = device_add_child(parent, NULL, -1, &uaa);
	if (!bdev) {
	    printf("%s: Device creation failed\n", USBDEVNAME(dev->bus->bdev));
	    return (USBD_INVAL);
	}
	device_quiet(bdev);
#endif

a894 3
#if defined(__FreeBSD__)
			device_delete_child(parent, bdev);
#endif
a906 3
#if defined(__FreeBSD__)
			device_delete_child(parent, bdev);
#endif
a922 11

#if defined(__FreeBSD__)
				/* create another child for the next iface */
				bdev = device_add_child(parent, NULL, -1,&uaa);
				if (!bdev) {
					printf("%s: Device creation failed\n",
					USBDEVNAME(dev->bus->bdev));
					return (USBD_NORMAL_COMPLETION);
				}
				device_quiet(bdev);
#endif
a925 4
#if defined(__FreeBSD__)
			/* remove the last created child again; it is unused */
			device_delete_child(parent, bdev);
#endif
a958 3
#if defined(__FreeBSD__)
	device_delete_child(parent, bdev);
#endif
a1166 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1201 5
#if defined(__NetBSD__)
int
usbd_submatch(struct device *parent, struct cfdata *cf, void *aux)
{
#elif defined(__OpenBSD__)
a1205 1
#endif
a1251 2

#endif
@


1.43
log
@Save and restore the data toggle value when a pipe to an endpoint
is closed and then reopened.  This may be necessary now that
we no longer clear endpoint stalls every time a pipe is opened.
Previously we could assume an initial toggle value of zero because
a clear-stall operation resets the device's toggle state.

Derived from work in FreeBSD.

This is most likely to affect devices like printers, which open
pipes for short periods of time and close them again.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.42 2006/05/01 01:34:10 krw Exp $ */
d1162 1
a1162 1
		DPRINTFN(-1,("usb_new_device: set address %d failed\n", addr));
@


1.42
log
@Zero the memory allocated for subdevs[], preventing a quick trip to
ddb>. Discovered by trying 'usbdevs -v' while a broken card reader was
trying to attach. Broken device provided by Manuel Pata.

ok pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.41 2005/11/21 18:16:44 millert Exp $ */
d574 1
@


1.41
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.40 2005/10/17 18:00:43 drahn Exp $ */
d862 1
a862 1
	int found, i, confi, nifaces;
d935 2
a936 1
		dev->subdevs = malloc((nifaces+1) * sizeof dv, M_USB,M_NOWAIT);
d943 1
a955 1
				dev->subdevs[found] = 0;
@


1.40
log
@Store the usb device names and vendors in more compact structures.
Originally committed in 2001, backed out in a sync, now back in.
saves close to 12k of kernel size. commit deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.15 2001/01/27 04:02:10 deraadt Exp $ */
d48 1
a48 1
#include <sys/select.h>
@


1.39
log
@Don't clear possibly non-existant stall condition while setting up the
pipe. Some devices such as some iPods react badly. Normal devices
don't need it. From nathanw via NetBSD. Fixes the 2nd generation iPod
mini donated by Ed Wandasiewicz.

ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.38 2005/08/01 05:36:49 brad Exp $ */
d105 6
a110 1
struct usb_knowndev {
d113 1
a113 2
	int			flags;
	char			*vendorname, *productname;
a114 1
#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d258 2
a259 1
	const struct usb_knowndev *kdp;
d278 5
a282 6
		for(kdp = usb_knowndevs;
		    kdp->vendorname != NULL;
		    kdp++) {
			if (kdp->vendor == UGETW(udd->idVendor) &&
			    (kdp->product == UGETW(udd->idProduct) ||
			     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))
d284 1
d286 10
a295 6
		if (kdp->vendorname != NULL) {
			if (vendor == NULL)
			    vendor = kdp->vendorname;
			if (product == NULL)
			    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
				kdp->productname : NULL;
@


1.38
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.37 2005/07/18 02:43:27 fgsch Exp $ */
a821 3
	/* Clear any stall and make sure DATA0 toggle will be used next. */
	if (UE_GET_ADDR(ep->edesc->bEndpointAddress) != USB_CONTROL_ENDPOINT)
		usbd_clear_endpoint_stall(p);
@


1.37
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.36 2005/04/21 08:47:57 pascoe Exp $ */
d80 1
d316 1
a316 1
void
d346 16
@


1.36
log
@Relocate debugging printf so it describes the right thing.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.35 2005/04/16 19:45:27 deraadt Exp $ */
d1058 1
a1058 1
		panic("usbd_new_device: cannot find HS port\n");
@


1.35
log
@use snprintf to avoid crossing the overflow point; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.34 2005/04/16 18:40:55 deraadt Exp $ */
d1135 1
a1136 1
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
@


1.34
log
@change usbd_printBCD() to return number of bytes really placed or 0, not
snprintf() style semantics [which people fail to grok]; ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.34 2005/04/16 18:38:57 deraadt Exp $ */
d329 1
a329 1
		      udd->bDeviceClass, udd->bDeviceSubClass);
d338 2
a339 1
	*cp++ = '/';
@


1.33
log
@Merge support for USB1 devices located beyond USB2 hubs, mostly from netbsd.

Supports bulk, control and interrupt pipes, letting USB1 keyboards and most
network interfaces work when connected to a USB2 hub.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.32 2004/12/12 06:13:15 dlg Exp $ */
d305 8
a312 1
	return (snprintf(cp, len, "%x.%02x", bcd >> 8, bcd & 0xff));
@


1.32
log
@backout the original method of reattaching a usb device now that we have
something better and more flexible to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.31 2004/11/08 22:01:02 dlg Exp $ */
d994 1
a994 1
	usbd_device_handle dev;
d1000 1
d1035 5
a1039 1
	for (hub = up->parent;
d1041 1
a1041 1
	     hub = hub->myhub)
d1043 13
a1055 1
	dev->myhighhub = hub;
a1067 1
	up->device = dev;
d1182 2
a1183 2
	up->device = 0;
	dev->bus->devices[dev->address] = 0;
d1408 1
@


1.31
log
@ugly ugly hack to allow a usb device to do a full reset of the port during
attach.

this is required by atu (atmel based usb wireless) devices. something better
will be done, but we need it for now to work on atu.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.30 2004/11/02 21:28:55 dlg Exp $ */
a89 2
Static usbd_status usbd_new_device2(device_ptr_t, usbd_bus_handle, int, int,
    int, struct usbd_port *);
a134 1
	"NEED_RESET",
a920 6
			if (dev->address == USB_START_ADDR) {
#if defined(__FreeBSD__)
				device_delete_child(parent, bdev);
#endif
				return (USBD_NEED_RESET);
			}
d991 1
a991 1
usbd_new_device2(device_ptr_t parent, usbd_bus_handle bus, int depth,
a1135 5
		if (err == USBD_NEED_RESET) {
			DPRINTF(("usbd_new_device2: device needs reset\n"));
			/* must set address back to what it was */
			dev->address = addr;
		} 
a1140 21
}

usbd_status
usbd_new_device(device_ptr_t parent, usbd_bus_handle bus, int depth,
    int speed, int ports, struct usbd_port *up)
{
	int retry = 0;
	usbd_status err;

	do {
		if (retry > 0)
			DPRINTF(("usbd_new_device: re-enumerating device\n"));
		err = usbd_new_device2(parent, bus, depth, speed, ports, up);
	} while ((err == USBD_NEED_RESET) && (retry++ < 5));

	if (retry == 5) {
		DPRINTF(("usbd_new_device: giving up after 5 tries\n"));
		return (USBD_NOT_CONFIGURED);
	}

	return (err);
@


1.30
log
@fix getting strings off a device which broke with the removal of the
UQ_NO_STRINGS quirk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.29 2004/10/31 12:10:52 dlg Exp $ */
d90 2
d137 1
d924 7
d1000 1
a1000 1
usbd_new_device(device_ptr_t parent, usbd_bus_handle bus, int depth,
d1145 5
d1155 21
@


1.29
log
@from netbsd via freebsd via jsg@@

usbdi_util.h (1.29), uhid.c (1.62), ugen.c (1.68), usb_subr.c (1.114)
   Yes, some devices return incorrect lengths in their string
   descriptors.  Rather than losing, do what Windows does: just
   request the maximum size, and allow a shorter response.  Obsoletes
   the need for UQ_NO_STRINGS, and therefore these "quirks" are removed.

usb_subr.c (1.116)
    In the "seemed like a good idea until I found the fatal flaw"
    department...  Attempting to read a maximum-size string descriptor
    causes my kue device to go completely apeshit.  So, go back to the
    original method, but allow the device to return a shorter string than
    it claimed.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.28 2004/08/30 03:06:48 drahn Exp $ */
d169 1
a169 1
	if (actlen < 2)
@


1.28
log
@Remove 'usb_'realloc() usage because it doesn't know the size of the old
buffer, thus may copy too much, causing a memory fault.
ok millert, dlg, henning, tdeval, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.27 2004/07/08 22:18:45 deraadt Exp $ */
d153 1
a153 1
		     usb_string_descriptor_t *sdesc)
d169 1
a169 1
	if (actlen < 1)
d173 12
a184 1
	return (usbd_do_request(dev, &req, sdesc));
d196 1
d204 3
a206 2
		err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us);
		if (err || us.bLength < 4) {
d213 1
a213 1
	err = usbd_get_string_desc(dev, si, dev->langid, &us);
d217 1
a217 1
	n = us.bLength / 2 - 1;
@


1.27
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.26 2003/07/08 13:19:09 nate Exp $ */
a1385 14

#ifdef __OpenBSD__
void *usb_realloc(void *p, u_int size, int pool, int flags)
{
	void *q;

	q = malloc(size, pool, flags);
	if (q == NULL)
		return (NULL);
	bcopy(p, q, size);
	free(p, pool);
	return (q);
}
#endif
@


1.26
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.25 2003/05/18 18:13:22 nate Exp $ */
d71 2
a72 2
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
@


1.25
log
@try a little harder to attach devices that are really slow
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.24 2003/05/07 04:33:33 deraadt Exp $ */
/*	$NetBSD: usb_subr.c,v 1.87 2001/08/15 00:04:59 augustss Exp $	*/
d157 1
d164 2
a165 1
	err = usbd_do_request(dev, &req, sdesc);
d168 4
d371 3
d497 4
a500 4
		DPRINTF(("usbd_fill_iface_data: bad descriptor(s): %s\n",
			 ed->bLength == 0 ? "0 length" :
			 ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
			 "out of data"));
d504 23
d591 1
a591 1
	int ifcidx, nifc, len, selfpowered, power;
d628 6
a633 1
	err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
d636 1
a775 1
	usb_callout_init(p->abort_handle);
d795 1
d978 1
a978 1
		int lowspeed, int port, struct usbd_port *up)
d981 1
d987 2
a988 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\n",
		 bus, port, depth, lowspeed));
d999 1
a999 1
	memset(dev, 0, sizeof(*dev));
a1016 1
	dev->lowspeed = lowspeed != 0;
d1019 7
d1055 11
d1067 1
a1067 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n",
d1070 1
a1070 1
		 dev->lowspeed));
d1274 1
a1274 1
	di->udi_lowspeed = dev->lowspeed;
a1376 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1377 5
#elif defined(__FreeBSD__)
                        device_delete_child(device_get_parent(dev->subdevs[i]),
					    dev->subdevs[i]);
#endif

@


1.24
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.23 2003/04/27 11:22:54 ho Exp $ */
d995 1
a995 1
	for (i = 0; i < 3; i++) {
d1000 2
a1001 1
		usbd_delay_ms(dev, 200);
@


1.23
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.22 2002/07/25 02:18:11 nate Exp $ */
d284 1
a284 1
usbd_printBCD(char *cp, int bcd)
d286 1
a286 1
	return (sprintf(cp, "%x.%02x", bcd >> 8, bcd & 0xff));
d290 1
a290 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *cp)
d295 1
d299 7
a305 4
	cp += sprintf(cp, "%s %s", vendor, product);
	if (showclass)
		cp += sprintf(cp, ", class %d/%d",
			      udd->bDeviceClass, udd->bDeviceSubClass);
d308 4
a311 2
	cp += sprintf(cp, ", rev ");
	cp += usbd_printBCD(cp, bcdUSB);
d313 4
a316 2
	cp += usbd_printBCD(cp, bcdDevice);
	cp += sprintf(cp, ", addr %d", dev->address);
d1112 1
a1112 1
		usbd_devinfo(uaa->device, 1, devinfo);
d1207 2
a1208 1
	usbd_printBCD(di->udi_release, UGETW(dev->ddesc.bcdDevice));
@


1.22
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.21 2002/05/07 18:29:18 nate Exp $ */
d272 1
a272 1
		strcpy(v, vendor);
d274 2
a275 1
		sprintf(v, "vendor 0x%04x", UGETW(udd->idVendor));
d277 1
a277 1
		strcpy(p, product);
d279 2
a280 1
		sprintf(p, "product 0x%04x", UGETW(udd->idProduct));
@


1.21
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.19 2002/05/02 20:08:04 nate Exp $ */
d206 1
a206 1
		else 
d257 1
a257 1
			if (kdp->vendor == UGETW(udd->idVendor) && 
d334 1
a334 1
	
d381 1
a381 1
			    "type=%d\n", 
d402 1
a402 1
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx, 
d639 1
a639 1
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes, 
d656 2
a657 2
			       USBDEVNAME(dev->bus->bdev), dev->address, 
			       cdp->bConfigurationValue, 
d678 1
a678 1
	dev->ifaces = malloc(nifc * sizeof(struct usbd_interface), 
d777 1
a777 1
	/* 
d909 1
a909 1
	/* 
d942 1
a942 1
		printf("%s: No free USB addresses, new device ignored.\n", 
d1000 1
a1000 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n", 
d1002 1
a1002 1
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength, 
d1048 1
a1048 1
	DPRINTF(("usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n", 
d1050 1
a1050 1
  
d1082 1
a1082 1
  
d1112 1
a1112 1
	/* 
d1222 1
a1222 1
		for (i = 0; 
d1291 1
a1291 1
	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n", 
d1304 1
a1304 1
			printf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]), 
@


1.20
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usb_subr.c,v 1.98 2002/02/20 20:30:13 christos Exp $	*/
a354 3
		/* If the device disappeared, just give up. */
		if (!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
			return (USBD_NORMAL_COMPLETION);
d478 4
a481 4
		printf("usbd_fill_iface_data: bad descriptor(s): %s\n",
		       ed->bLength == 0 ? "0 length" :
		       ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
		       "out of data");
a484 23
		if (dev->speed == USB_SPEED_HIGH) {
			u_int mps;
			/* Control and bulk endpoints have max packet
			   limits. */
			switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
			case UE_CONTROL:
				mps = USB_2_MAX_CTRL_PACKET;
				goto check;
			case UE_BULK:
				mps = USB_2_MAX_BULK_PACKET;
			check:
				if (UGETW(ed->wMaxPacketSize) != mps) {
					USETW(ed->wMaxPacketSize, mps);
#ifdef DIAGNOSTIC
					printf("usbd_fill_iface_data: bad max "
					       "packet size\n");
#endif
				}
				break;
			default:
				break;
			}
		}
d728 1
a747 1
	usbd_abort_pipe(pipe);
d930 1
a930 1
		int speed, int port, struct usbd_port *up)
a932 1
	struct usbd_device *hub;
d938 2
a939 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d speed=%d\n",
		 bus, port, depth, speed));
d950 1
a950 1
	memset(dev, 0, sizeof *dev);
d968 1
a970 7
	dev->myhub = up->parent;
	for (hub = up->parent;
	     hub != NULL && hub->speed != USB_SPEED_HIGH;
	     hub = hub->myhub)
		;
	dev->myhighhub = hub;
	dev->speed = speed;
a998 11
	if (speed == USB_SPEED_HIGH) {
		/* Max packet size must be 64 (sec 5.5.3). */
		if (dd->bMaxPacketSize != USB_2_MAX_CTRL_PACKET) {
#ifdef DIAGNOSTIC
			printf("usbd_new_device: addr=%d bad max packet size\n",
			       addr);
#endif
			dd->bMaxPacketSize = USB_2_MAX_CTRL_PACKET;
		}
	}

d1000 1
a1000 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n", 
d1003 1
a1003 1
		 dev->speed));
d1206 1
a1206 1
	di->udi_speed = dev->speed;
d1309 1
d1311 5
@


1.19
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.18 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: usb_subr.c,v 1.87 2001/08/15 00:04:59 augustss Exp $	*/
d355 3
d481 4
a484 4
		DPRINTF(("usbd_fill_iface_data: bad descriptor(s): %s\n",
			 ed->bLength == 0 ? "0 length" :
			 ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
			 "out of data"));
d488 23
a753 1
	usb_callout_init(p->abort_handle);
d773 1
d956 1
a956 1
		int lowspeed, int port, struct usbd_port *up)
d959 1
d965 2
a966 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\n",
		 bus, port, depth, lowspeed));
d977 1
a977 1
	memset(dev, 0, sizeof(*dev));
a994 1
	dev->lowspeed = lowspeed != 0;
d997 7
d1032 11
d1044 1
a1044 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n", 
d1047 1
a1047 1
		 dev->lowspeed));
d1250 1
a1250 1
	di->udi_lowspeed = dev->lowspeed;
a1352 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1353 5
#elif defined(__FreeBSD__)
                        device_delete_child(device_get_parent(dev->subdevs[i]),
					    dev->subdevs[i]);
#endif

@


1.18
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.17 2001/03/22 02:10:22 mickey Exp $ */
d1193 14
a1206 14
	di->bus = USBDEVUNIT(dev->bus->bdev);
	di->addr = dev->address;
	di->cookie = dev->cookie;
	usbd_devinfo_vp(dev, di->vendor, di->product, usedev);
	usbd_printBCD(di->release, UGETW(dev->ddesc.bcdDevice));
	di->vendorNo = UGETW(dev->ddesc.idVendor);
	di->productNo = UGETW(dev->ddesc.idProduct);
	di->releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->class = dev->ddesc.bDeviceClass;
	di->subclass = dev->ddesc.bDeviceSubClass;
	di->protocol = dev->ddesc.bDeviceProtocol;
	di->config = dev->config;
	di->power = dev->self_powered ? 0 : dev->power;
	di->lowspeed = dev->lowspeed;
d1211 1
a1211 1
			strncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
d1213 1
a1213 1
			di->devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
d1219 1
a1219 1
                di->devnames[i][0] = 0;                 /* empty */
d1223 1
a1223 1
		     i < sizeof(di->ports) / sizeof(di->ports[0]) &&
d1240 1
a1240 1
			di->ports[i] = err;
d1242 1
a1242 1
		di->nports = dev->hub->hubdesc.bNbrPorts;
d1244 1
a1244 1
		di->nports = 0;
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.18 2001/10/31 04:24:44 nate Exp $ */
d1193 14
a1206 14
	di->udi_bus = USBDEVUNIT(dev->bus->bdev);
	di->udi_addr = dev->address;
	di->udi_cookie = dev->cookie;
	usbd_devinfo_vp(dev, di->udi_vendor, di->udi_product, usedev);
	usbd_printBCD(di->udi_release, UGETW(dev->ddesc.bcdDevice));
	di->udi_vendorNo = UGETW(dev->ddesc.idVendor);
	di->udi_productNo = UGETW(dev->ddesc.idProduct);
	di->udi_releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->udi_class = dev->ddesc.bDeviceClass;
	di->udi_subclass = dev->ddesc.bDeviceSubClass;
	di->udi_protocol = dev->ddesc.bDeviceProtocol;
	di->udi_config = dev->config;
	di->udi_power = dev->self_powered ? 0 : dev->power;
	di->udi_lowspeed = dev->lowspeed;
d1211 1
a1211 1
			strncpy(di->udi_devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
d1213 1
a1213 1
			di->udi_devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
d1219 1
a1219 1
                di->udi_devnames[i][0] = 0;                 /* empty */
d1223 1
a1223 1
		     i < sizeof(di->udi_ports) / sizeof(di->udi_ports[0]) &&
d1240 1
a1240 1
			di->udi_ports[i] = err;
d1242 1
a1242 1
		di->udi_nports = dev->hub->hubdesc.bNbrPorts;
d1244 1
a1244 1
		di->udi_nports = 0;
@


1.18.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.18.2.1 2002/06/11 03:42:31 art Exp $ */
d206 1
a206 1
		else
d257 1
a257 1
			if (kdp->vendor == UGETW(udd->idVendor) &&
d334 1
a334 1

d381 1
a381 1
			    "type=%d\n",
d402 1
a402 1
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx,
d639 1
a639 1
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes,
d656 2
a657 2
			       USBDEVNAME(dev->bus->bdev), dev->address,
			       cdp->bConfigurationValue,
d678 1
a678 1
	dev->ifaces = malloc(nifc * sizeof(struct usbd_interface),
d777 1
a777 1
	/*
d909 1
a909 1
	/*
d942 1
a942 1
		printf("%s: No free USB addresses, new device ignored.\n",
d1000 1
a1000 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n",
d1002 1
a1002 1
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength,
d1048 1
a1048 1
	DPRINTF(("usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n",
d1050 1
a1050 1

d1082 1
a1082 1

d1112 1
a1112 1
	/*
d1222 1
a1222 1
		for (i = 0;
d1291 1
a1291 1
	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n",
d1304 1
a1304 1
			printf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d272 1
a272 1
		strlcpy(v, vendor, USB_MAX_STRING_LEN); /* XXX */
d274 1
a274 2
		snprintf(v, USB_MAX_STRING_LEN, "vendor 0x%04x", /* XXX */
		    UGETW(udd->idVendor));
d276 1
a276 1
		strlcpy(p, product, USB_MAX_STRING_LEN); /* XXX */
d278 1
a278 2
		snprintf(p, USB_MAX_STRING_LEN, "product 0x%04x", /* XXX */
		    UGETW(udd->idProduct));
d282 1
a282 1
usbd_printBCD(char *cp, size_t len, int bcd)
d284 1
a284 1
	return (snprintf(cp, len, "%x.%02x", bcd >> 8, bcd & 0xff));
d288 1
a288 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *base, size_t len)
a292 1
	char *cp = base;
d296 4
a299 7
	snprintf(cp, len, "%s %s", vendor, product);
	cp += strlen(cp);
	if (showclass) {
		snprintf(cp, base + len - cp, ", class %d/%d",
		      udd->bDeviceClass, udd->bDeviceSubClass);
		cp += strlen(cp);
	}
d302 2
a303 4
	snprintf(cp, base + len - cp, ", rev ");
	cp += strlen(cp);
	usbd_printBCD(cp, base + len - cp, bcdUSB);
	cp += strlen(cp);
d305 2
a306 4
	usbd_printBCD(cp, base + len - cp, bcdDevice);
	cp += strlen(cp);
	snprintf(cp, base + len - cp, ", addr %d", dev->address);
	cp += strlen(cp);
d1102 1
a1102 1
		usbd_devinfo(uaa->device, 1, devinfo, sizeof devinfo);
d1197 1
a1197 2
	usbd_printBCD(di->udi_release, sizeof di->udi_release,
	    UGETW(dev->ddesc.bcdDevice));
@


1.17
log
@contify usbdevs a little
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.16 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: usb_subr.c,v 1.72 2000/04/14 14:13:56 augustss Exp $	*/
d104 1
a104 6
struct usb_known_vendor {
	usb_vendor_id_t		vendor;
	const char		*vendorname;
};

struct usb_known_product {
d107 2
a108 1
	const char		*productname;
d110 1
d213 2
a214 2
static char *
usbd_trim_trailings_spaces(char *p)
d216 1
a216 1
	char *q, *r;
d219 8
a226 6
		return NULL;
	r = p;
	q = p + strlen(p);
	while (--q >= p && *q == ' ')
		*q = 0;
	return r;
d233 1
a233 1
	const char *vendor = NULL, *product = NULL;
d235 1
a235 2
	const struct usb_known_vendor *ukv;
	const struct usb_known_product *ukp;
d244 4
a247 4
		vendor = usbd_trim_trailings_spaces(
		    usbd_get_string(dev, udd->iManufacturer, v));
		product = usbd_trim_trailings_spaces(
		    usbd_get_string(dev, udd->iProduct, p));
d254 6
a259 5
		for(ukv = usb_known_vendors;
		    ukv->vendorname != NULL;
		    ukv++) {
			if (ukv->vendor == UGETW(udd->idVendor)) {
				vendor = ukv->vendorname;
a260 1
			}
d262 6
a267 10
		if (vendor != NULL) {
			for(ukp = usb_known_products;
			    ukp->productname != NULL;
			    ukp++) {
				if (ukp->vendor == UGETW(udd->idVendor) &&
				    (ukp->product == UGETW(udd->idProduct))) {
					product = ukp->productname;
					break;
				}
			}
d296 1
a296 1
	cp += sprintf(cp, "%s%s%s", vendor, *vendor ? " " : "", product);
a466 1
			ed = (usb_endpoint_descriptor_t *)p;
d1169 12
@


1.16
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.15 2001/01/27 04:02:10 deraadt Exp $ */
d106 1
a106 1
	char			*vendorname;
d112 1
a112 1
	char			*productname;
d216 1
a216 1
static void
d219 1
a219 1
	char *q;
d222 2
a223 1
		return;
d227 1
d234 1
a234 1
	char *vendor = 0, *product = 0;
d246 4
a249 4
		vendor = usbd_get_string(dev, udd->iManufacturer, v);
		usbd_trim_trailings_spaces(vendor);
		product = usbd_get_string(dev, udd->iProduct, p);
		usbd_trim_trailings_spaces(product);
@


1.15
log
@re-arrange tables as pcidevs was changed; huge space savings
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.14 2000/11/08 18:10:39 aaron Exp $ */
d79 2
a80 1
Static usbd_status	usbd_set_config(usbd_device_handle, int);
d118 1
a118 1
Static const char *usbd_error_strs[] = {
d216 12
d229 1
a229 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, char *p)
d234 2
a235 2
	struct usb_known_vendor *ukv;
	struct usb_known_product *ukp;
d243 9
a251 2
	vendor = usbd_get_string(dev, udd->iManufacturer, v);
	product = usbd_get_string(dev, udd->iProduct, p);
d299 1
a299 1
	usbd_devinfo_vp(dev, vendor, product);
d1180 2
a1181 1
usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di)
d1189 1
a1189 1
	usbd_devinfo_vp(dev, di->vendor, di->product);
@


1.14
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.13 2000/09/07 20:38:56 aaron Exp $ */
d103 6
a108 1
struct usb_knowndev {
d111 1
a111 2
	int			flags;
	char			*vendorname, *productname;
a112 1
#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d221 2
a222 1
	struct usb_knowndev *kdp;
d234 5
a238 6
		for(kdp = usb_knowndevs;
		    kdp->vendorname != NULL;
		    kdp++) {
			if (kdp->vendor == UGETW(udd->idVendor) && 
			    (kdp->product == UGETW(udd->idProduct) ||
			     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))
d240 1
d242 10
a251 6
		if (kdp->vendorname != NULL) {
			if (!vendor)
			    vendor = kdp->vendorname;
			if (!product)
			    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
				kdp->productname : NULL;
@


1.13
log
@Put back a fix that fgsch@@ whacked during the last NetBSD USB sync:

If the vendor name is NULL, do not output a leading space; reported by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.12 2000/07/04 11:44:25 fgsch Exp $ */
d79 3
a81 3
Static usbd_status	usbd_set_config __P((usbd_device_handle, int));
Static char *usbd_get_string __P((usbd_device_handle, int, char *));
Static int usbd_getnewaddr __P((usbd_bus_handle bus));
d83 2
a84 2
Static int usbd_print __P((void *aux, const char *pnp));
Static int usbd_submatch __P((device_ptr_t, struct cfdata *cf, void *));
d86 2
a87 2
Static int usbd_print __P((void *aux, const char *pnp));
Static int usbd_submatch __P((device_ptr_t, void *, void *));
d89 4
a92 4
Static void usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));
Static void usbd_kill_pipe __P((usbd_pipe_handle));
Static usbd_status usbd_probe_and_attach 
	__P((device_ptr_t parent, usbd_device_handle dev, int port, int addr));
d138 1
a138 2
usbd_errstr(err)
	usbd_status err;
d151 2
a152 5
usbd_get_string_desc(dev, sindex, langid, sdesc)
	usbd_device_handle dev;
	int sindex;
	int langid;
	usb_string_descriptor_t *sdesc;
d170 1
a170 4
usbd_get_string(dev, si, buf)
	usbd_device_handle dev;
	int si;
	char *buf;
d213 1
a213 3
usbd_devinfo_vp(dev, v, p)
	usbd_device_handle dev;
	char *v, *p;
d247 1
a247 1
	if (vendor != NULL)
d251 1
a251 1
	if (product != NULL)
d258 1
a258 3
usbd_printBCD(cp, bcd)
	char *cp;
	int bcd;
d264 1
a264 4
usbd_devinfo(dev, showclass, cp)
	usbd_device_handle dev;
	int showclass;
	char *cp;
d288 1
a288 3
usb_delay_ms(bus, ms)
	usbd_bus_handle bus;
	u_int ms;
d299 1
a299 3
usbd_delay_ms(dev, ms)
	usbd_device_handle dev;
	u_int ms;
d305 1
a305 4
usbd_reset_port(dev, port, ps)
	usbd_device_handle dev;
	int port;
	usb_port_status_t *ps;
d347 1
a347 4
usbd_find_idesc(cd, ifaceidx, altidx)
	usb_config_descriptor_t *cd;
	int ifaceidx;
	int altidx;
d378 2
a379 5
usbd_find_edesc(cd, ifaceidx, altidx, endptidx)
	usb_config_descriptor_t *cd;
	int ifaceidx;
	int altidx;
	int endptidx;
d411 1
a411 4
usbd_fill_iface_data(dev, ifaceidx, altidx)
	usbd_device_handle dev;
	int ifaceidx;
	int altidx;
d478 1
a478 3
usbd_free_iface_data(dev, ifcno)
	usbd_device_handle dev;
	int ifcno;
d486 1
a486 3
usbd_set_config(dev, conf)
	usbd_device_handle dev;
	int conf;
d499 1
a499 4
usbd_set_config_no(dev, no, msg)
	usbd_device_handle dev;
	int no;
	int msg;
d521 1
a521 4
usbd_set_config_index(dev, index, msg)
	usbd_device_handle dev;
	int index;
	int msg;
d580 31
a610 6
			err = usbd_get_device_status(dev, &ds);
			if (!err && (UGETW(ds.wStatus) & UDS_SELF_POWERED))
				selfpowered = 1;
			DPRINTF(("usbd_set_config_index: status=0x%04x, "
				 "error=%s\n",
				 UGETW(ds.wStatus), usbd_errstr(err)));
d614 3
a616 3
	DPRINTF(("usbd_set_config_index: (addr %d) attr=0x%02x, "
		 "selfpowered=%d, power=%d\n", 
		 dev->address, cdp->bmAttributes, 
d628 1
d683 2
a684 6
usbd_setup_pipe(dev, iface, ep, ival, pipe)
	usbd_device_handle dev;
	usbd_interface_handle iface; 
	struct usbd_endpoint *ep;
	int ival;
	usbd_pipe_handle *pipe;
d723 1
a723 2
usbd_kill_pipe(pipe)
	usbd_pipe_handle pipe;
d731 1
a731 2
usbd_getnewaddr(bus)
	usbd_bus_handle bus;
d743 2
a744 5
usbd_probe_and_attach(parent, dev, port, addr)
	device_ptr_t parent;
	usbd_device_handle dev;
	int port;
	int addr;
d906 2
a907 7
usbd_new_device(parent, bus, depth, lowspeed, port, up)
	device_ptr_t parent;
	usbd_bus_handle bus;
	int depth;
	int lowspeed;
	int port;
	struct usbd_port *up;
d1040 1
a1040 2
usbd_reload_device_desc(dev)
	usbd_device_handle dev;
d1056 1
a1056 3
usbd_remove_device(dev, up)
	usbd_device_handle dev;
	struct usbd_port *up;
d1070 1
a1070 3
usbd_print(aux, pnp)
	void *aux;
	const char *pnp;
d1106 1
a1106 4
usbd_submatch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
d1110 1
a1110 4
usbd_submatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d1152 1
a1152 3
usbd_fill_deviceinfo(dev, di)
	usbd_device_handle dev;
	struct usb_device_info *di;
d1212 1
a1212 2
usb_free_device(dev)
	usbd_device_handle dev;
d1249 1
a1249 3
usb_disconnect_port(up, parent)
	struct usbd_port *up;
	device_ptr_t parent;
d1290 1
a1290 5
void *usb_realloc(p, size, pool, flags)
	void *p;
	u_int size;
	int pool;
	int flags;
@


1.12
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.11 2000/04/14 22:50:28 aaron Exp $ */
d286 1
a286 1
	cp += sprintf(cp, "%s %s", vendor, product);
@


1.11
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.10 2000/04/08 20:55:41 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d286 1
a286 1
	cp += sprintf(cp, "%s%s%s", vendor, *vendor ? " " : "", product);
a305 2
	extern int cold;

d353 2
a354 4
	if (n == 0) {
		printf("usbd_reset_port: timeout\n");
		return (USBD_IOERROR);
	}
d444 1
d450 3
d454 1
a454 3
	ifc->idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);
	if (ifc->idesc == 0)
		return (USBD_INVAL);
d500 1
a500 1
	if (ifc->endpoints != NULL)
d502 2
d542 3
d571 1
a571 1
	if (dev->config != 0) {
d581 1
a581 1
		dev->config = 0;
d584 11
a594 1
	/* Figure out what config number to use. */
d602 1
d612 2
d616 1
a616 1
	    cdp->bmAttributes & UC_SELF_POWERED) {
d633 2
d656 1
d666 2
a667 2
	DPRINTF(("usbd_set_config_index: setting new config %d\n",
		 cdp->bConfigurationValue));
@


1.10
log
@If the vendor name is NULL, do not output a leading space; reported by deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.9 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: usb_subr.c,v 1.71 2000/03/29 18:24:53 augustss Exp $	*/
d772 2
a773 2
	uaa.iface = 0;
	uaa.ifaces = 0;
d876 1
a876 1
	uaa.iface = 0;
a879 3
	uaa.vendor = UHUB_UNK_VENDOR;
	uaa.product = UHUB_UNK_PRODUCT;
	uaa.release = UHUB_UNK_RELEASE;
d924 2
a925 2
	DPRINTF(("usbd_new_device bus=%p depth=%d lowspeed=%d\n",
		 bus, depth, lowspeed));
d1136 28
a1163 18
	if ((uaa->port != 0 &&
	     cf->uhubcf_port != UHUB_UNK_PORT &&
	     cf->uhubcf_port != uaa->port) ||
	    (uaa->configno != UHUB_UNK_CONFIGURATION &&
	     cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&
	     cf->uhubcf_configuration != uaa->configno) ||
	    (uaa->ifaceno != UHUB_UNK_INTERFACE &&
	     cf->uhubcf_interface != UHUB_UNK_INTERFACE &&
	     cf->uhubcf_interface != uaa->ifaceno) ||
	    (uaa->vendor != UHUB_UNK_VENDOR &&
	     cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	     cf->uhubcf_vendor != uaa->vendor) ||
	    (uaa->product != UHUB_UNK_PRODUCT &&
	     cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	     cf->uhubcf_product != uaa->product) ||
	    (uaa->release != UHUB_UNK_RELEASE &&
	     cf->uhubcf_release != UHUB_UNK_RELEASE &&
	     cf->uhubcf_release != uaa->release)
@


1.9
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.8 2000/03/28 19:37:51 aaron Exp $ */
d286 1
a286 1
	cp += sprintf(cp, "%s %s", vendor, product);
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_subr.c,v 1.68 2000/03/25 18:02:33 augustss Exp $	*/
d79 3
a81 3
static usbd_status	usbd_set_config __P((usbd_device_handle, int));
static char *usbd_get_string __P((usbd_device_handle, int, char *));
static int usbd_getnewaddr __P((usbd_bus_handle bus));
d83 2
a84 2
static int usbd_print __P((void *aux, const char *pnp));
static int usbd_submatch __P((device_ptr_t, struct cfdata *cf, void *));
d86 2
a87 2
static int usbd_print __P((void *aux, const char *pnp));
static int usbd_submatch __P((device_ptr_t, void *, void *));
d89 3
a91 3
static void usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));
static void usbd_kill_pipe __P((usbd_pipe_handle));
static usbd_status usbd_probe_and_attach 
d94 1
a94 1
static u_int32_t usb_cookie_no = 0;
d114 1
a114 1
static const char *usbd_error_strs[] = {
d517 1
a517 1
static usbd_status
d700 1
@


1.7
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usb_subr.c,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: usb_subr.c,v 1.67 2000/03/13 23:52:37 soren Exp $	*/
d80 2
a81 3
char *usbd_get_string __P((usbd_device_handle, int, char *));
int usbd_getnewaddr __P((usbd_bus_handle bus));
int usbd_print __P((void *aux, const char *pnp));
d83 2
a84 1
int usbd_submatch __P((device_ptr_t, struct cfdata *cf, void *));
d86 2
a87 1
int usbd_submatch __P((device_ptr_t, void *, void *));
d89 3
a91 3
void usbd_free_iface_data __P((usbd_device_handle dev, int ifcno));
void usbd_kill_pipe __P((usbd_pipe_handle));
usbd_status usbd_probe_and_attach 
d114 1
a114 1
const char *usbd_error_strs[] = {
a145 1
#if !defined(__OpenBSD__)
a146 3
#else
		sprintf(buffer, "%d", err);
#endif
d249 1
a249 1
				vendor = kdp->vendorname;
d251 2
a252 2
			product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
			    kdp->productname : NULL;
d362 2
a363 1
		DPRINTF(("usbd_reset_port: clear port feature failed %d\n",r));
d703 1
d785 1
a785 1
	if (dv != NULL) {
d834 1
a834 1
			if (!ifaces[i])
d840 1
a840 1
			if (dv) {
d883 1
a883 1
	if (dv) {
a927 1

a1008 1
	/* Get the full device descriptor. */
d1038 1
a1038 1

d1187 2
a1188 1
		for (i = 0; dev->subdevs[i] && i < USB_MAX_DEVNAMES; i++) {
d1192 6
a1197 6
		}
	} else {
		i = 0;
	}
	for (/* i is set */; i < USB_MAX_DEVNAMES; i++)
		di->devnames[i][0] = 0;			/* empty */
d1293 1
a1293 1
			device_delete_child(device_get_parent(dev->subdevs[i]),
d1306 17
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usb_subr.c,v 1.52 1999/10/13 08:10:58 augustss Exp $	*/
d47 1
a52 1
#include <sys/select.h>
d161 1
a161 1
	usbd_status r;
d168 3
a170 3
	r = usbd_do_request(dev, &req, sdesc);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d186 1
a186 1
	usbd_status r;
d194 2
a195 2
		r = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us);
		if (r != USBD_NORMAL_COMPLETION || us.bLength < 4) {
d202 2
a203 2
	r = usbd_get_string_desc(dev, si, dev->langid, &us);
	if (r != USBD_NORMAL_COMPLETION)
d218 1
a218 1
	return buf;
d232 1
a232 1
	if (!dev) {
d240 1
a240 1
	if (!vendor) {
d249 4
a252 4
		if (kdp->vendorname == NULL)
			vendor = product = NULL;
		else {
			vendor = kdp->vendorname;
d254 1
a254 1
				kdp->productname : NULL;
d258 1
a258 1
	if (vendor)
d262 1
a262 1
	if (product)
d308 2
d311 1
a311 1
	if (bus->use_polling)
d333 1
a333 1
	usbd_status r;
d341 1
a341 1
	r = usbd_do_request(dev, &req, 0);
d343 3
a345 3
		    port, usbd_errstr(r)));
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d350 5
a354 4
		r = usbd_get_port_status(dev, port, ps);
		if (r != USBD_NORMAL_COMPLETION) {
			DPRINTF(("usbd_reset_port: get status failed %d\n",r));
			return (r);
d361 1
a361 1
	r = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);
d363 1
a363 1
	if (r != USBD_NORMAL_COMPLETION)
d369 1
a369 1
	return (r);
d403 1
a403 1
	return (0);
d420 2
a421 2
	if (!d)
		return (0);
d423 1
a423 1
		return (0);
d432 1
a432 1
			return (0);
d439 1
a439 1
	return (0);
d461 1
a461 1
	DPRINTFN(10,("usbd_fill_iface_data: found idesc n=%d\n", nendpt));
d465 1
a465 1
		if (ifc->endpoints == 0)
d468 2
a469 2
		ifc->endpoints = 0;
	ifc->priv = 0;
d483 2
a484 2
			if (ed->bDescriptorType == UDESC_INTERFACE ||
			    ed->bLength == 0)
d488 4
d503 2
a504 1
	free(ifc->endpoints, M_USB);
d541 1
a541 1
	usbd_status r;
d546 3
a548 3
		r = usbd_get_config_desc(dev, index, &cd);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d563 1
a563 1
	usbd_status r;
d577 2
a578 2
		dev->ifaces = 0;
		dev->cdesc = 0;
d583 3
a585 3
	r = usbd_get_config_desc(dev, index, &cd);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d588 1
a588 1
	if (cdp == 0)
d590 2
a591 2
	r = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
	if (r != USBD_NORMAL_COMPLETION)
d596 1
a596 1
		r = USBD_INVAL;
d605 2
a606 3
			r = usbd_get_device_status(dev, &ds);
			if (r == USBD_NORMAL_COMPLETION && 
			    (UGETW(ds.wStatus) & UDS_SELF_POWERED))
d610 1
a610 1
				 UGETW(ds.wStatus), usbd_errstr(r)));
d619 1
a619 1
	if (!dev->powersrc) {
d633 1
a633 1
		r = USBD_NO_POWER;
d641 2
a642 2
	r = usbd_set_config(dev, cdp->bConfigurationValue);
	if (r != USBD_NORMAL_COMPLETION) {
d645 1
a645 1
			 cdp->bConfigurationValue, usbd_errstr(r)));
d653 2
a654 2
	if (dev->ifaces == 0) {
		r = USBD_NOMEM;
d661 2
a662 2
		r = usbd_fill_iface_data(dev, ifcidx, 0);
		if (r != USBD_NORMAL_COMPLETION) {
d673 1
a673 1
	return (r);
d679 1
a679 1
usbd_setup_pipe(dev, iface, ep, pipe)
d683 1
d687 1
a687 1
	usbd_status r;
d692 1
a692 1
	if (p == 0)
d699 1
a699 1
	p->intrreqh = 0;
d702 1
d704 2
a705 2
	r = dev->bus->methods->open_pipe(p);
	if (r != USBD_NORMAL_COMPLETION) {
d708 1
a708 1
			 ep->edesc->bEndpointAddress, usbd_errstr(r)));
d710 1
a710 1
		return (r);
d751 2
a752 1
	int r, found, i, confi, nifaces;
d783 1
d785 1
a785 1
	if (dv) {
d787 1
a787 1
		if (dev->subdevs == 0)
d796 2
d802 2
a803 2
		r = usbd_set_config_index(dev, confi, 1);
		if (r != USBD_NORMAL_COMPLETION) {
d807 1
a807 1
				 addr, usbd_errstr(r)));
d816 1
a816 1
 			return (r);
d825 1
a825 1
		if (dev->subdevs == 0) {
d922 1
a922 1
	usbd_status r;
d928 1
d937 1
a937 1
	if (dev == 0)
d963 4
a966 3
	/* Establish the the default pipe. */
	r = usbd_setup_pipe(dev, 0, &dev->def_ep, &dev->default_pipe);
	if (r != USBD_NORMAL_COMPLETION) {
d968 1
a968 1
		return (r);
d974 1
a974 1
	for (i = 0; i < 5; i++) {
d976 2
a977 2
		r = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);
		if (r == USBD_NORMAL_COMPLETION)
d981 1
a981 1
	if (r != USBD_NORMAL_COMPLETION) {
d983 1
a983 2
			      "failed\n",
			      addr));
d985 1
a985 1
		return (r);
d1011 2
a1012 2
	r = usbd_get_device_desc(dev, dd);
	if (r != USBD_NORMAL_COMPLETION) {
d1016 1
a1016 1
		return (r);
a1018 3
	/* Figure out what's wrong with this device. */
	dev->quirks = usbd_find_quirk(dd);

d1020 5
a1024 4
	r = usbd_set_address(dev, addr);
	if (r != USBD_NORMAL_COMPLETION) {
		DPRINTFN(-1,("usb_new_device: set address %d failed\n",addr));
		r = USBD_SET_ADDR_FAILED;
d1026 1
a1026 1
		return (r);
d1041 4
a1044 2
	r = usbd_probe_and_attach(parent, dev, port, addr);
	if (r != USBD_NORMAL_COMPLETION) {
d1046 1
a1046 1
		return (r);
d1048 1
a1048 2
  
	usbd_add_event(USB_EVENT_ATTACH, dev);
d1052 17
d1076 1
a1076 1
	if (dev->default_pipe)
d1171 1
a1171 1
	int i, r, s;
d1173 3
a1175 1
	di->config = dev->config;
d1180 1
d1182 3
d1187 13
a1199 1
	di->addr = dev->address;
d1207 1
a1207 1
				r = p->device->address;
d1211 1
a1211 1
					r = USB_PORT_ENABLED;
d1213 1
a1213 1
					r = USB_PORT_SUSPENDED;
d1215 1
a1215 1
					r = USB_PORT_POWERED;
d1217 1
a1217 1
					r = USB_PORT_DISABLED;
d1219 1
a1219 1
			di->ports[i] = r;
d1232 1
a1232 1
	if (dev->default_pipe)
d1234 1
a1234 1
	if (dev->ifaces) {
d1240 1
a1240 1
	if (dev->cdesc)
d1242 1
a1242 1
	if (dev->subdevs)
d1277 1
a1277 1
	if (!dev) {
d1283 2
a1284 8
	if (!dev->cdesc) {
		/* Partially attached device, just drop it. */
		dev->bus->devices[dev->address] = 0;
		up->device = 0;
		return;
	}

	if (dev->subdevs) {
a1285 3
			if (!dev->subdevs[i])	/* skip empty elements */
				continue;

d1291 1
d1293 5
d1301 3
a1303 3
	usbd_add_event(USB_EVENT_DETACH, dev);
	dev->bus->devices[dev->address] = 0;
	up->device = 0;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usb_subr.c,v 1.17 2001/03/22 02:10:22 mickey Exp $ */
/*	$NetBSD: usb_subr.c,v 1.72 2000/04/14 14:13:56 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb_subr.c,v 1.18 1999/11/17 22:33:47 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a46 1
#include <sys/select.h>
d52 1
d78 4
a81 4
Static usbd_status usbd_set_config(usbd_device_handle, int);
Static void usbd_devinfo_vp(usbd_device_handle, char *, char *, int);
Static char *usbd_get_string(usbd_device_handle, int, char *);
Static int usbd_getnewaddr(usbd_bus_handle bus);
d83 1
a83 2
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, struct cfdata *cf, void *);
d85 1
a85 2
Static int usbd_print(void *aux, const char *pnp);
Static int usbd_submatch(device_ptr_t, void *, void *);
d87 4
a90 4
Static void usbd_free_iface_data(usbd_device_handle dev, int ifcno);
Static void usbd_kill_pipe(usbd_pipe_handle);
Static usbd_status usbd_probe_and_attach(device_ptr_t parent,
				 usbd_device_handle dev, int port, int addr);
d92 1
a92 1
Static u_int32_t usb_cookie_no = 0;
d101 1
a101 6
struct usb_known_vendor {
	usb_vendor_id_t		vendor;
	const char		*vendorname;
};

struct usb_known_product {
d104 2
a105 1
	const char		*productname;
d107 1
d112 1
a112 1
Static const char * const usbd_error_strs[] = {
d136 2
a137 1
usbd_errstr(usbd_status err)
d144 1
d146 3
d154 5
a158 2
usbd_get_string_desc(usbd_device_handle dev, int sindex, int langid,
		     usb_string_descriptor_t *sdesc)
d161 1
a161 1
	usbd_status err;
d168 3
a170 3
	err = usbd_do_request(dev, &req, sdesc);
	if (err)
		return (err);
d176 4
a179 1
usbd_get_string(usbd_device_handle dev, int si, char *buf)
d186 1
a186 1
	usbd_status err;
d194 2
a195 2
		err = usbd_get_string_desc(dev, USB_LANGUAGE_TABLE, 0, &us);
		if (err || us.bLength < 4) {
d202 2
a203 2
	err = usbd_get_string_desc(dev, si, dev->langid, &us);
	if (err)
d218 1
a218 15
	return (buf);
}

static char *
usbd_trim_trailings_spaces(char *p)
{
	char *q, *r;

	if (p == NULL)
		return NULL;
	r = p;
	q = p + strlen(p);
	while (--q >= p && *q == ' ')
		*q = 0;
	return r;
d222 3
a224 1
usbd_devinfo_vp(usbd_device_handle dev, char *v, char *p, int usedev)
d227 1
a227 1
	const char *vendor = NULL, *product = NULL;
d229 1
a229 2
	const struct usb_known_vendor *ukv;
	const struct usb_known_product *ukp;
d232 1
a232 1
	if (dev == NULL) {
d237 2
a238 9
	if (usedev) {
		vendor = usbd_trim_trailings_spaces(
		    usbd_get_string(dev, udd->iManufacturer, v));
		product = usbd_trim_trailings_spaces(
		    usbd_get_string(dev, udd->iProduct, p));
	} else {
		vendor = NULL;
		product = NULL;
	}
d240 7
a246 6
	if (vendor == NULL || product == NULL) {
		for(ukv = usb_known_vendors;
		    ukv->vendorname != NULL;
		    ukv++) {
			if (ukv->vendor == UGETW(udd->idVendor)) {
				vendor = ukv->vendorname;
a247 1
			}
d249 6
a254 10
		if (vendor != NULL) {
			for(ukp = usb_known_products;
			    ukp->productname != NULL;
			    ukp++) {
				if (ukp->vendor == UGETW(udd->idVendor) &&
				    (ukp->product == UGETW(udd->idProduct))) {
					product = ukp->productname;
					break;
				}
			}
d258 1
a258 1
	if (vendor != NULL && *vendor)
d262 1
a262 1
	if (product != NULL && *product)
d269 3
a271 1
usbd_printBCD(char *cp, int bcd)
d277 4
a280 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *cp)
d287 2
a288 2
	usbd_devinfo_vp(dev, vendor, product, 1);
	cp += sprintf(cp, "%s%s%s", vendor, *vendor ? " " : "", product);
d304 3
a306 1
usb_delay_ms(usbd_bus_handle bus, u_int ms)
d309 1
a309 1
	if (bus->use_polling || cold)
d317 3
a319 1
usbd_delay_ms(usbd_device_handle dev, u_int ms)
d325 4
a328 1
usbd_reset_port(usbd_device_handle dev, int port, usb_port_status_t *ps)
d331 1
a331 1
	usbd_status err;
d339 1
a339 1
	err = usbd_do_request(dev, &req, 0);
d341 3
a343 3
		    port, usbd_errstr(err)));
	if (err)
		return (err);
d348 4
a351 5
		err = usbd_get_port_status(dev, port, ps);
		if (err) {
			DPRINTF(("usbd_reset_port: get status failed %d\n",
				 err));
			return (err);
d354 5
a358 3
	if (n == 0)
		return (USBD_TIMEOUT);
	err = usbd_clear_port_feature(dev, port, UHF_C_PORT_RESET);
d360 2
a361 3
	if (err)
		DPRINTF(("usbd_reset_port: clear port feature failed %d\n",
			 err));
d366 1
a366 1
	return (err);
d370 4
a373 1
usbd_find_idesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx)
d400 1
a400 1
	return (NULL);
d404 5
a408 2
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx, 
		int endptidx)
d417 2
a418 2
	if (d == NULL)
		return (NULL);
d420 1
a420 1
		return (NULL);
d429 1
a429 1
			return (NULL);
d436 1
a436 1
	return (NULL);
d440 4
a443 1
usbd_fill_iface_data(usbd_device_handle dev, int ifaceidx, int altidx)
a445 1
	usb_interface_descriptor_t *idesc;
d451 3
a453 2
	idesc = usbd_find_idesc(dev->cdesc, ifaceidx, altidx);
	if (idesc == NULL)
a454 2
	ifc->device = dev;
	ifc->idesc = idesc;
d458 1
a458 1
	DPRINTFN(4,("usbd_fill_iface_data: found idesc nendpt=%d\n", nendpt));
d462 1
a462 1
		if (ifc->endpoints == NULL)
d465 2
a466 2
		ifc->endpoints = NULL;
	ifc->priv = NULL;
d480 2
a481 2
			if (ed->bLength == 0 ||
			    ed->bDescriptorType == UDESC_INTERFACE)
a484 4
		DPRINTF(("usbd_fill_iface_data: bad descriptor(s): %s\n",
			 ed->bLength == 0 ? "0 length" :
			 ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
			 "out of data"));
d496 1
a496 4
	if (ifc->endpoints != NULL) {
		free(ifc->endpoints, M_USB);
		ifc->endpoints = NULL;
	}
d501 3
a503 1
usbd_free_iface_data(usbd_device_handle dev, int ifcno)
d510 4
a513 2
Static usbd_status
usbd_set_config(usbd_device_handle dev, int conf)
d526 4
a529 1
usbd_set_config_no(usbd_device_handle dev, int no, int msg)
d533 1
a533 4
	usbd_status err;

	if (no == USB_UNCONFIG_NO)
		return (usbd_set_config_index(dev, USB_UNCONFIG_INDEX, msg));
d538 3
a540 3
		err = usbd_get_config_desc(dev, index, &cd);
		if (err)
			return (err);
d548 4
a551 1
usbd_set_config_index(usbd_device_handle dev, int index, int msg)
d555 1
a555 1
	usbd_status err;
d561 1
a561 1
	if (dev->config != USB_UNCONFIG_NO) {
d569 9
a577 19
		dev->ifaces = NULL;
		dev->cdesc = NULL;
		dev->config = USB_UNCONFIG_NO;
	}

	if (index == USB_UNCONFIG_INDEX) {
		/* We are unconfiguring the device, so leave unallocated. */
		DPRINTF(("usbd_set_config_index: set config 0\n"));
		err = usbd_set_config(dev, USB_UNCONFIG_NO);
		if (err)
			DPRINTF(("usbd_set_config_index: setting config=0 "
				 "failed, error=%s\n", usbd_errstr(err)));
		return (err);
	}

	/* Get the short descriptor. */
	err = usbd_get_config_desc(dev, index, &cd);
	if (err)
		return (err);
d580 1
a580 1
	if (cdp == NULL)
d582 2
a583 3
	/* Get the full descriptor. */
	err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
	if (err)
d588 1
a588 1
		err = USBD_INVAL;
a590 2

	/* Figure out if the device is self or bus powered. */
d593 1
a593 1
	    (cdp->bmAttributes & UC_SELF_POWERED)) {
d597 7
a603 31
			if (dev->quirks->uq_flags & UQ_POWER_CLAIM) {
				/*
				 * Hub claims to be self powered, but isn't.
				 * It seems that the power status can be
				 * determined by the hub characteristics.
				 */
				usb_hub_descriptor_t hd;
				usb_device_request_t req;
				req.bmRequestType = UT_READ_CLASS_DEVICE;
				req.bRequest = UR_GET_DESCRIPTOR;
				USETW(req.wValue, 0);
				USETW(req.wIndex, 0);
				USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
				err = usbd_do_request(dev, &req, &hd);
				if (!err &&
				    (UGETW(hd.wHubCharacteristics) &
				     UHD_PWR_INDIVIDUAL))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: charac=0x%04x"
				    ", error=%s\n",
				    UGETW(hd.wHubCharacteristics),
				    usbd_errstr(err)));
			} else {
				err = usbd_get_device_status(dev, &ds);
				if (!err &&
				    (UGETW(ds.wStatus) & UDS_SELF_POWERED))
					selfpowered = 1;
				DPRINTF(("usbd_set_config_index: status=0x%04x"
				    ", error=%s\n",
				    UGETW(ds.wStatus), usbd_errstr(err)));
			}
d607 3
a609 3
	DPRINTF(("usbd_set_config_index: (addr %d) cno=%d attr=0x%02x, "
		 "selfpowered=%d, power=%d\n",
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes, 
a610 2

	/* Check if we have enough power. */
d612 1
a612 1
	if (dev->powersrc == NULL) {
a618 1
		DPRINTF(("power exceeded %d %d\n", power,dev->powersrc->power));
d626 1
a626 1
		err = USBD_NO_POWER;
a631 1
	/* Set the actual configuration value. */
d634 2
a635 2
	err = usbd_set_config(dev, cdp->bConfigurationValue);
	if (err) {
d638 1
a638 1
			 cdp->bConfigurationValue, usbd_errstr(err)));
d641 2
a642 2

	/* Allocate and fill interface data. */
d646 2
a647 2
	if (dev->ifaces == NULL) {
		err = USBD_NOMEM;
d654 2
a655 2
		err = usbd_fill_iface_data(dev, ifcidx, 0);
		if (err) {
d666 1
a666 1
	return (err);
d672 5
a676 2
usbd_setup_pipe(usbd_device_handle dev, usbd_interface_handle iface,
		struct usbd_endpoint *ep, int ival, usbd_pipe_handle *pipe)
d679 1
a679 1
	usbd_status err;
d684 1
a684 1
	if (p == NULL)
d691 1
a691 1
	p->intrxfer = 0;
a692 1
	p->aborting = 0;
a693 1
	p->interval = ival;
d695 2
a696 3
	usb_callout_init(p->abort_handle);
	err = dev->bus->methods->open_pipe(p);
	if (err) {
d699 1
a699 1
			 ep->edesc->bEndpointAddress, usbd_errstr(err)));
d701 1
a701 1
		return (err);
d712 2
a713 1
usbd_kill_pipe(usbd_pipe_handle pipe)
d721 2
a722 1
usbd_getnewaddr(usbd_bus_handle bus)
d734 5
a738 2
usbd_probe_and_attach(device_ptr_t parent, usbd_device_handle dev,
		      int port, int addr)
d742 1
a742 2
	int found, i, confi, nifaces;
	usbd_status err;
d761 2
a762 2
	uaa.iface = NULL;
	uaa.ifaces = NULL;
a772 1
	DPRINTF(("usbd_probe_and_attach: trying device specific drivers\n"));
d776 1
a776 1
		if (dev->subdevs == NULL)
a784 2
	DPRINTF(("usbd_probe_and_attach: looping over %d configurations\n",
		 dd->bNumConfigurations));
d789 2
a790 2
		err = usbd_set_config_index(dev, confi, 1);
		if (err) {
d794 1
a794 1
				 addr, usbd_errstr(err)));
d803 1
a803 1
 			return (err);
d812 1
a812 1
		if (dev->subdevs == NULL) {
d821 1
a821 1
			if (ifaces[i] == NULL)
d827 1
a827 1
			if (dv != NULL) {
d862 1
a862 1
	uaa.iface = NULL;
d866 3
d870 1
a870 1
	if (dv != NULL) {
d899 7
a905 2
usbd_new_device(device_ptr_t parent, usbd_bus_handle bus, int depth,
		int lowspeed, int port, struct usbd_port *up)
d909 1
a909 1
	usbd_status err;
d913 2
a914 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d lowspeed=%d\n",
		 bus, port, depth, lowspeed));
d923 1
a923 1
	if (dev == NULL)
d949 3
a951 4
	/* Establish the default pipe. */
	err = usbd_setup_pipe(dev, 0, &dev->def_ep, USBD_DEFAULT_INTERVAL,
			      &dev->default_pipe);
	if (err) {
d953 1
a953 1
		return (err);
d959 1
a959 1
	for (i = 0; i < 3; i++) {
d961 2
a962 2
		err = usbd_get_desc(dev, UDESC_DEVICE, 0, USB_MAX_IPACKET, dd);
		if (!err)
d966 1
a966 1
	if (err) {
d968 2
a969 1
			      "failed\n", addr));
d971 1
a971 1
		return (err);
d996 3
a998 2
	err = usbd_reload_device_desc(dev);
	if (err) {
d1002 1
a1002 1
		return (err);
d1005 3
d1009 4
a1012 5
	err = usbd_set_address(dev, addr);
	DPRINTFN(5,("usbd_new_device: setting device address=%d\n", addr));
	if (err) {
		DPRINTFN(-1,("usb_new_device: set address %d failed\n", addr));
		err = USBD_SET_ADDR_FAILED;
d1014 1
a1014 1
		return (err);
a1027 2
  
	usbd_add_dev_event(USB_EVENT_DEVICE_ATTACH, dev);
d1029 2
a1030 2
	err = usbd_probe_and_attach(parent, dev, port, addr);
	if (err) {
d1032 1
a1032 1
		return (err);
d1034 2
a1035 1

a1038 16
usbd_status
usbd_reload_device_desc(usbd_device_handle dev)
{
	usbd_status err;

	/* Get the full device descriptor. */
	err = usbd_get_device_desc(dev, &dev->ddesc);
	if (err)
		return (err);

	/* Figure out what's wrong with this device. */
	dev->quirks = usbd_find_quirk(&dev->ddesc);

	return (USBD_NORMAL_COMPLETION);
}

d1040 3
a1042 1
usbd_remove_device(usbd_device_handle dev, struct usbd_port *up)
d1046 1
a1046 1
	if (dev->default_pipe != NULL)
d1056 3
a1058 1
usbd_print(void *aux, const char *pnp)
d1094 4
a1097 1
usbd_submatch(struct device *parent, struct cfdata *cf, void *aux)
d1101 4
a1104 1
usbd_submatch(struct device *parent, void *match, void *aux)
d1110 18
a1127 28
	DPRINTFN(5,("usbd_submatch port=%d,%d configno=%d,%d "
	    "ifaceno=%d,%d vendor=%d,%d product=%d,%d release=%d,%d\n",
	    uaa->port, cf->uhubcf_port,
	    uaa->configno, cf->uhubcf_configuration,
	    uaa->ifaceno, cf->uhubcf_interface,
	    uaa->vendor, cf->uhubcf_vendor,
	    uaa->product, cf->uhubcf_product,
	    uaa->release, cf->uhubcf_release));
	if (uaa->port != 0 &&	/* root hub has port 0, it should match */
	    ((uaa->port != 0 &&
	      cf->uhubcf_port != UHUB_UNK_PORT &&
	      cf->uhubcf_port != uaa->port) ||
	     (uaa->configno != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != UHUB_UNK_CONFIGURATION &&
	      cf->uhubcf_configuration != uaa->configno) ||
	     (uaa->ifaceno != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != UHUB_UNK_INTERFACE &&
	      cf->uhubcf_interface != uaa->ifaceno) ||
	     (uaa->vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	      cf->uhubcf_vendor != uaa->vendor) ||
	     (uaa->product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	      cf->uhubcf_product != uaa->product) ||
	     (uaa->release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != UHUB_UNK_RELEASE &&
	      cf->uhubcf_release != uaa->release)
	     )
d1136 3
a1138 2
usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di,
		     int usedev)
d1141 1
a1141 1
	int i, err, s;
d1143 2
a1144 4
	di->bus = USBDEVUNIT(dev->bus->bdev);
	di->addr = dev->address;
	di->cookie = dev->cookie;
	usbd_devinfo_vp(dev, di->vendor, di->product, usedev);
a1147 1
	di->releaseNo = UGETW(dev->ddesc.bcdDevice);
a1148 3
	di->subclass = dev->ddesc.bDeviceSubClass;
	di->protocol = dev->ddesc.bDeviceProtocol;
	di->config = dev->config;
d1151 1
a1151 14

	if (dev->subdevs != NULL) {
		for (i = 0; dev->subdevs[i] &&
			     i < USB_MAX_DEVNAMES; i++) {
			strncpy(di->devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
				USB_MAX_DEVNAMELEN);
			di->devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
                }
        } else {
                i = 0;
        }
        for (/*i is set */; i < USB_MAX_DEVNAMES; i++)
                di->devnames[i][0] = 0;                 /* empty */

d1159 1
a1159 1
				err = p->device->address;
d1163 1
a1163 1
					err = USB_PORT_ENABLED;
d1165 1
a1165 1
					err = USB_PORT_SUSPENDED;
d1167 1
a1167 1
					err = USB_PORT_POWERED;
d1169 1
a1169 1
					err = USB_PORT_DISABLED;
d1171 1
a1171 1
			di->ports[i] = err;
d1179 2
a1180 1
usb_free_device(usbd_device_handle dev)
d1184 1
a1184 1
	if (dev->default_pipe != NULL)
d1186 1
a1186 1
	if (dev->ifaces != NULL) {
d1192 1
a1192 1
	if (dev->cdesc != NULL)
d1194 1
a1194 1
	if (dev->subdevs != NULL)
d1217 3
a1219 1
usb_disconnect_port(struct usbd_port *up, device_ptr_t parent)
d1229 1
a1229 1
	if (dev == NULL) {
d1235 8
a1242 2
	if (dev->subdevs != NULL) {
		DPRINTFN(3,("usb_disconnect_port: disconnect subdevs\n"));
d1244 3
a1251 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1252 5
#elif defined(__FreeBSD__)
                        device_delete_child(device_get_parent(dev->subdevs[i]),
					    dev->subdevs[i]);
#endif

d1256 3
a1258 3
	usbd_add_dev_event(USB_EVENT_DEVICE_DETACH, dev);
	dev->bus->devices[dev->address] = NULL;
	up->device = NULL;
a1261 13
#ifdef __OpenBSD__
void *usb_realloc(void *p, u_int size, int pool, int flags)
{
	void *q;

	q = malloc(size, pool, flags);
	if (q == NULL)
		return (NULL);
	bcopy(p, q, size);
	free(p, pool);
	return (q);
}
#endif
@


1.6.2.2
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_subr.c,v 1.87 2001/08/15 00:04:59 augustss Exp $	*/
d104 6
a109 1
struct usb_knowndev {
d112 1
a112 2
	int			flags;
	char			*vendorname, *productname;
a113 1
#define	USB_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d216 2
a217 2
static void
usbd_trim_spaces(char *p)
d219 1
a219 1
	char *q, *e;
d222 6
a227 8
		return;
	q = e = p;
	while (*q == ' ')	/* skip leading spaces */
		q++;
	while ((*p = *q++))	/* copy string */
		if (*p++ != ' ') /* remember last non-space */
			e = p;
	*e = 0;			/* kill trailing spaces */
d234 1
a234 1
	char *vendor = 0, *product = 0;
d236 2
a237 1
	const struct usb_knowndev *kdp;
d246 4
a249 4
		vendor = usbd_get_string(dev, udd->iManufacturer, v);
		usbd_trim_spaces(vendor);
		product = usbd_get_string(dev, udd->iProduct, p);
		usbd_trim_spaces(product);
d256 5
a260 6
		for(kdp = usb_knowndevs;
		    kdp->vendorname != NULL;
		    kdp++) {
			if (kdp->vendor == UGETW(udd->idVendor) && 
			    (kdp->product == UGETW(udd->idProduct) ||
			     (kdp->flags & USB_KNOWNDEV_NOPROD) != 0))
d262 1
d264 10
a273 6
		if (kdp->vendorname != NULL) {
			if (vendor == NULL)
			    vendor = kdp->vendorname;
			if (product == NULL)
			    product = (kdp->flags & USB_KNOWNDEV_NOPROD) == 0 ?
				kdp->productname : NULL;
d302 1
a302 1
	cp += sprintf(cp, "%s %s", vendor, product);
d473 1
a1175 12
	if (cf->uhubcf_vendor != UHUB_UNK_VENDOR &&
	    cf->uhubcf_vendor == uaa->vendor &&
	    cf->uhubcf_product != UHUB_UNK_PRODUCT &&
	    cf->uhubcf_product == uaa->product) {
		/* We have a vendor&product locator match */
		if (cf->uhubcf_release != UHUB_UNK_RELEASE &&
		    cf->uhubcf_release == uaa->release)
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT_REV;
		else
			uaa->matchlvl = UMATCH_VENDOR_PRODUCT;
	} else
		uaa->matchlvl = 0;
@


1.6.2.3
log
@Sync the SMP branch with 3.3
@
text
@d206 1
a206 1
		else
d257 1
a257 1
			if (kdp->vendor == UGETW(udd->idVendor) &&
d334 1
a334 1

d381 1
a381 1
			    "type=%d\n",
d402 1
a402 1
usbd_find_edesc(usb_config_descriptor_t *cd, int ifaceidx, int altidx,
d639 1
a639 1
		 cdp->bConfigurationValue, dev->address, cdp->bmAttributes,
d656 2
a657 2
			       USBDEVNAME(dev->bus->bdev), dev->address,
			       cdp->bConfigurationValue,
d678 1
a678 1
	dev->ifaces = malloc(nifc * sizeof(struct usbd_interface),
d777 1
a777 1
	/*
d909 1
a909 1
	/*
d942 1
a942 1
		printf("%s: No free USB addresses, new device ignored.\n",
d1000 1
a1000 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, ls=%d\n",
d1002 1
a1002 1
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dd->bLength,
d1048 1
a1048 1
	DPRINTF(("usbd_new_device: new dev (addr %d), dev=%p, parent=%p\n",
d1050 1
a1050 1

d1082 1
a1082 1

d1112 1
a1112 1
	/*
d1193 14
a1206 14
	di->udi_bus = USBDEVUNIT(dev->bus->bdev);
	di->udi_addr = dev->address;
	di->udi_cookie = dev->cookie;
	usbd_devinfo_vp(dev, di->udi_vendor, di->udi_product, usedev);
	usbd_printBCD(di->udi_release, UGETW(dev->ddesc.bcdDevice));
	di->udi_vendorNo = UGETW(dev->ddesc.idVendor);
	di->udi_productNo = UGETW(dev->ddesc.idProduct);
	di->udi_releaseNo = UGETW(dev->ddesc.bcdDevice);
	di->udi_class = dev->ddesc.bDeviceClass;
	di->udi_subclass = dev->ddesc.bDeviceSubClass;
	di->udi_protocol = dev->ddesc.bDeviceProtocol;
	di->udi_config = dev->config;
	di->udi_power = dev->self_powered ? 0 : dev->power;
	di->udi_lowspeed = dev->lowspeed;
d1211 1
a1211 1
			strncpy(di->udi_devnames[i], USBDEVPTRNAME(dev->subdevs[i]),
d1213 1
a1213 1
			di->udi_devnames[i][USB_MAX_DEVNAMELEN-1] = '\0';
d1219 1
a1219 1
                di->udi_devnames[i][0] = 0;                 /* empty */
d1222 2
a1223 2
		for (i = 0;
		     i < sizeof(di->udi_ports) / sizeof(di->udi_ports[0]) &&
d1240 1
a1240 1
			di->udi_ports[i] = err;
d1242 1
a1242 1
		di->udi_nports = dev->hub->hubdesc.bNbrPorts;
d1244 1
a1244 1
		di->udi_nports = 0;
d1291 1
a1291 1
	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n",
d1304 1
a1304 1
			printf("%s: at %s", USBDEVPTRNAME(dev->subdevs[i]),
@


1.6.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.6.2.3 2003/03/28 00:38:32 niklas Exp $ */
d272 1
a272 1
		strlcpy(v, vendor, USB_MAX_STRING_LEN); /* XXX */
d274 1
a274 2
		snprintf(v, USB_MAX_STRING_LEN, "vendor 0x%04x", /* XXX */
		    UGETW(udd->idVendor));
d276 1
a276 1
		strlcpy(p, product, USB_MAX_STRING_LEN); /* XXX */
d278 1
a278 2
		snprintf(p, USB_MAX_STRING_LEN, "product 0x%04x", /* XXX */
		    UGETW(udd->idProduct));
d282 1
a282 1
usbd_printBCD(char *cp, size_t len, int bcd)
d284 1
a284 1
	return (snprintf(cp, len, "%x.%02x", bcd >> 8, bcd & 0xff));
d288 1
a288 1
usbd_devinfo(usbd_device_handle dev, int showclass, char *base, size_t len)
a292 1
	char *cp = base;
d296 4
a299 7
	snprintf(cp, len, "%s %s", vendor, product);
	cp += strlen(cp);
	if (showclass) {
		snprintf(cp, base + len - cp, ", class %d/%d",
		      udd->bDeviceClass, udd->bDeviceSubClass);
		cp += strlen(cp);
	}
d302 2
a303 4
	snprintf(cp, base + len - cp, ", rev ");
	cp += strlen(cp);
	usbd_printBCD(cp, base + len - cp, bcdUSB);
	cp += strlen(cp);
d305 2
a306 4
	usbd_printBCD(cp, base + len - cp, bcdDevice);
	cp += strlen(cp);
	snprintf(cp, base + len - cp, ", addr %d", dev->address);
	cp += strlen(cp);
d1102 1
a1102 1
		usbd_devinfo(uaa->device, 1, devinfo, sizeof devinfo);
d1197 1
a1197 2
	usbd_printBCD(di->udi_release, sizeof di->udi_release,
	    UGETW(dev->ddesc.bcdDevice));
@


1.6.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_subr.c,v 1.6.2.4 2003/05/13 19:35:12 ho Exp $ */
d995 1
a995 1
	for (i = 0; i < 5; i++) {
d1000 1
a1000 2
		/* progressively increase the delay */
		usbd_delay_ms(dev, 200 * (i + 1));
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_subr.c,v 1.103 2003/01/10 11:19:13 augustss Exp $	*/
a156 1
	int actlen;
d163 1
a163 2
	err = usbd_do_request_flags(dev, &req, sdesc, USBD_SHORT_XFER_OK,
		&actlen, USBD_DEFAULT_TIMEOUT);
a165 4

	if (actlen < 1)
		return (USBD_SHORT_XFER);

a364 3
		/* If the device disappeared, just give up. */
		if (!(UGETW(ps->wPortStatus) & UPS_CURRENT_CONNECT_STATUS))
			return (USBD_NORMAL_COMPLETION);
d488 4
a491 4
		printf("usbd_fill_iface_data: bad descriptor(s): %s\n",
		       ed->bLength == 0 ? "0 length" :
		       ed->bDescriptorType == UDESC_INTERFACE ? "iface desc":
		       "out of data");
a494 23
		if (dev->speed == USB_SPEED_HIGH) {
			u_int mps;
			/* Control and bulk endpoints have max packet
			   limits. */
			switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
			case UE_CONTROL:
				mps = USB_2_MAX_CTRL_PACKET;
				goto check;
			case UE_BULK:
				mps = USB_2_MAX_BULK_PACKET;
			check:
				if (UGETW(ed->wMaxPacketSize) != mps) {
					USETW(ed->wMaxPacketSize, mps);
#ifdef DIAGNOSTIC
					printf("usbd_fill_iface_data: bad max "
					       "packet size\n");
#endif
				}
				break;
			default:
				break;
			}
		}
d559 1
a559 1
	int i, ifcidx, nifc, len, selfpowered, power;
d596 1
a596 6
	for (i = 0; i < 3; i++) {
		err = usbd_get_desc(dev, UDESC_CONFIG, index, len, cdp);
		if (!err)
			break;
		usbd_delay_ms(dev, 200);
	}
a598 1

d738 1
a757 1
	usbd_abort_pipe(pipe);
d940 1
a940 1
		int speed, int port, struct usbd_port *up)
a942 1
	struct usbd_device *hub;
d948 2
a949 2
	DPRINTF(("usbd_new_device bus=%p port=%d depth=%d speed=%d\n",
		 bus, port, depth, speed));
d960 1
a960 1
	memset(dev, 0, sizeof *dev);
d978 1
a980 7
	dev->myhub = up->parent;
	for (hub = up->parent;
	     hub != NULL && hub->speed != USB_SPEED_HIGH;
	     hub = hub->myhub)
		;
	dev->myhighhub = hub;
	dev->speed = speed;
a1009 11
	if (speed == USB_SPEED_HIGH) {
		/* Max packet size must be 64 (sec 5.5.3). */
		if (dd->bMaxPacketSize != USB_2_MAX_CTRL_PACKET) {
#ifdef DIAGNOSTIC
			printf("usbd_new_device: addr=%d bad max packet size\n",
			       addr);
#endif
			dd->bMaxPacketSize = USB_2_MAX_CTRL_PACKET;
		}
	}

d1011 1
a1011 1
		 "subclass=%d, protocol=%d, maxpacket=%d, len=%d, speed=%d\n",
d1014 1
a1014 1
		 dev->speed));
d1218 1
a1218 1
	di->udi_speed = dev->speed;
d1321 1
d1323 5
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usb_subr.c,v 1.48 1999/09/16 19:20:34 augustss Exp $	*/
d92 1
d232 5
d592 2
a593 1
	if (cdp->bmAttributes & UC_SELF_POWERED) {
d752 1
a752 1
	bdev = device_add_child(*parent, NULL, -1, &uaa);
d757 1
d800 1
a800 1
			device_delete_child(*parent, bdev);
d802 1
d812 4
a815 1
		if (dev->subdevs == 0)
d817 4
a820 1
		for (found = i = 0; i < nifaces; i++) {
d831 11
d844 5
a848 1
		if (found != 0)
d850 1
d886 1
a886 5
/*
 * XXX should we delete the child again? Left for now to avoid dangling
 * references.
      device_delete_child(*parent, bdev);
*/
a891 1

d947 1
d1035 1
a1132 7
#elif defined(__FreeBSD__)
static void
usbd_bus_print_child(device_t bus, device_t dev)
{
	/* FIXME print the device address and the configuration used
	 */
}
d1217 1
a1217 1
usb_disconnect_port(up)
d1219 1
d1222 1
a1222 1
	char *hubname;
a1242 1
		hubname = USBDEVPTRNAME(up->parent->subdevs[0]);
d1244 8
a1251 3
			printf("%s: at %s port %d (addr %d) disconnected\n",
			       USBDEVPTRNAME(dev->subdevs[i]), hubname,
			       up->portno, dev->address);
d1256 1
a1259 6

#if defined(__FreeBSD__)
      device_delete_child(
	  device_get_parent(((struct softc *)dev->softc)->sc_dev), 
	  ((struct softc *)dev->softc)->sc_dev);
#endif
@


1.4
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.3 1999/08/19 08:18:39 fgsch Exp $	*/
/*	$NetBSD: usb_subr.c,v 1.38 1999/08/17 20:59:04 augustss Exp $	*/
d54 2
d83 1
a83 1
int usbd_submatch __P((bdevice *, struct cfdata *cf, void *));
d85 1
a85 1
int usbd_submatch __P((bdevice *, void *, void *));
d90 1
a90 1
	__P((bdevice *parent, usbd_device_handle dev, int port, int addr));
d111 1
a111 2
#ifdef USB_DEBUG
char *usbd_error_strs[] = {
a132 1
#endif
d134 1
a134 1
char *
d140 1
a140 2
#ifdef  USB_DEBUG
	if ( err < USBD_ERROR_MAX ) {
d147 1
a147 1
#endif /* !defined(__OpenBSD__) */
a149 8
#else
#if !defined(__OpenBSD__)
	snprintf(buffer, sizeof buffer, "%d", err);
#else
	sprintf(buffer, "%d", err);
#endif /* !defined(__OpenBSD__) */
	return buffer;
#endif
d606 1
a606 1
		printf("usbd_set_config_index: No power source?\n");
d688 1
a688 1
	r = dev->bus->open_pipe(p);
d728 1
a728 1
	bdevice *parent;
d736 1
a736 1
	struct device *dv;
d744 1
a744 1
	bdevice bdev;
d785 1
a785 1
				 "error=%s\n", USBDEVNAME(*parent), port,
d789 1
a789 1
			       USBDEVNAME(*parent), port, addr);
d874 1
a874 1
	bdevice *parent;
d1177 64
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 27
d343 2
a344 2
	DPRINTFN(1,("usbd_reset_port: port %d reset done, error=%d(%s)\n",
		    port, r, usbd_error_strs[r]));
d604 2
a605 2
				 "error=%d(%s)\n",
				 UGETW(ds.wStatus), r, usbd_error_strs[r]));
d639 2
a640 2
			 "error=%d(%s)\n",
			 cdp->bConfigurationValue, r, usbd_error_strs[r]));
d699 3
a701 3
		DPRINTFN(-1,("usbd_setup_pipe: endpoint=0x%x failed, error=%d"
			 "(%s)\n",
			 ep->edesc->bEndpointAddress, r, usbd_error_strs[r]));
d794 2
a795 2
				 "error=%d(%s)\n", USBDEVNAME(*parent), port,
				 addr, r, usbd_error_strs[r]));
d956 6
d970 5
a974 4
	DPRINTF(("usbd_new_device: adding unit addr=%d, rev=%02x, class=%d, "
		 "subclass=%d, protocol=%d, maxpacket=%d, ls=%d\n", 
		 addr,UGETW(dd->bcdUSB), dd->bDeviceClass, dd->bDeviceSubClass,
		 dd->bDeviceProtocol, dd->bMaxPacketSize, dev->lowspeed));
a1121 48

usbd_status
usb_insert_transfer(reqh)
	usbd_request_handle reqh;
{
	usbd_pipe_handle pipe = reqh->pipe;

	SIMPLEQ_INSERT_TAIL(&pipe->queue, reqh, next);
	if (pipe->running)
		return (USBD_IN_PROGRESS);
	pipe->running = 1;
	return (USBD_NORMAL_COMPLETION);
}

void
usb_start_next(pipe)
	usbd_pipe_handle pipe;
{
	usbd_request_handle reqh;
	usbd_status r;

	DPRINTFN(10, ("usb_start_next: pipe=%p\n", pipe));
	
#ifdef DIAGNOSTIC
	if (!pipe) {
		printf("usb_start_next: pipe == 0\n");
		return;
	}
	if (!pipe->methods || !pipe->methods->start) {
		printf("usb_start_next:  no start method\n");
		return;
	}
#endif

	/* Get next request in queue. */
	reqh = SIMPLEQ_FIRST(&pipe->queue);
	DPRINTFN(5, ("usb_start_next: start reqh=%p\n", reqh));
	if (!reqh)
		pipe->running = 0;
	else {
		r = pipe->methods->start(reqh);
		if (r != USBD_IN_PROGRESS) {
			printf("usb_start_next: error=%d\n", r);
			pipe->running = 0;
			/* XXX do what? */
		}
	}
}
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_subr.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: usb_subr.c,v 1.34 1999/06/30 06:44:23 augustss Exp $	*/
d79 1
a80 1
int usbd_print __P((void *aux, const char *pnp));
a82 1
int usbd_print __P((void *aux, const char *pnp));
a464 1
		ifc->endpoints[endpt].toggle = 0;
d678 3
a1119 4
	if (SIMPLEQ_FIRST(&pipe->queue) == 0) {
		printf("usb_start_next: empty\n");
		return;
	}
d1122 1
a1122 2
	/* First remove remove old */
	SIMPLEQ_REMOVE_HEAD(&pipe->queue, SIMPLEQ_FIRST(&pipe->queue), next);
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 2
a69 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
@

