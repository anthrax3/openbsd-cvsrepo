head	1.81;
access;
symbols
	OPENBSD_6_2:1.81.0.4
	OPENBSD_6_2_BASE:1.81
	OPENBSD_6_1:1.80.0.4
	OPENBSD_6_1_BASE:1.80
	OPENBSD_6_0:1.77.0.4
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.69.0.4
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.52.0.2
	OPENBSD_5_3_BASE:1.52
	OPENBSD_5_2:1.51.0.6
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.81
date	2017.07.28.10.50.56;	author bluhm;	state Exp;
branches;
next	1.80;
commitid	x6eDtpWBJ6dYceQR;

1.80
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	x5RWYO05Q3UFL5Oq;

1.79
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.78;
commitid	VyLWTsbepAOk7VQM;

1.78
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.77;
commitid	xlY19nmD0cBL53l1;

1.77
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.76;
commitid	gWZDkudwxydTq8x4;

1.76
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.75;
commitid	fbhqfhfdKxBcsetK;

1.75
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.74;
commitid	B0kwmVGiD5DVx4kv;

1.74
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.73;
commitid	FuSD2mFDJWATHIDx;

1.73
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.72;
commitid	5DvsamK0GblTp8ww;

1.72
date	2015.11.13.10.36.29;	author mpi;	state Exp;
branches;
next	1.71;
commitid	pVgZpZmw966Haagb;

1.71
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.70;
commitid	YT6fyIEviv9qwbl6;

1.70
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.69;
commitid	pwYnMC1gOKohmeGw;

1.69
date	2015.07.15.13.27.41;	author mpi;	state Exp;
branches;
next	1.68;
commitid	sJVc9ekKWGlWJedB;

1.68
date	2015.07.15.04.01.26;	author stsp;	state Exp;
branches;
next	1.67;
commitid	Sx9VfIIYeQMIAhsD;

1.67
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.66;
commitid	p4LJxGKbi0BU2cG6;

1.66
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.65;
commitid	Hly9lJn6CNMylcFu;

1.65
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.64;
commitid	yM2VFFhpDTeFQlve;

1.64
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.63;
commitid	LS2TNeCue5R9L67C;

1.63
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.62;
commitid	Z1vcFtHO8wRH0yRt;

1.62
date	2014.11.01.14.44.08;	author mpi;	state Exp;
branches;
next	1.61;
commitid	BmycRw1mcwUuxLd7;

1.61
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.60;
commitid	Pclvgy2Z4XV9hveD;

1.60
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.59;
commitid	OBNa5kfxQ2UXoiIw;

1.59
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.58;
commitid	b0VSac5dnnsxcDao;

1.58
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.55;

1.55
date	2013.06.11.18.45.25;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2012.10.03.08.05.26;	author sthen;	state Exp;
branches;
next	1.51;

1.51
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.06.19.49.58;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.44;

1.44
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.29.07.12.31;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.03.09.33.10;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.15.17.01.54;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.23.10.47.14;	author canacar;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.08.20.43.31;	author yuo;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.17.21.09.36;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.21.12.57.31;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.11.19.53.58;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.09.08.52.10;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.19.17.22.02;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.02.14.43.50;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.16.15.32.05;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.03.17.51.41;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.03.16.09.21;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.03.19.48.21;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.20.19.47.17;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.18.18.08.32;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.09.18.16.34.23;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.09.18.16.30.17;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.18.01.42.30;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.16.19.54.13;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.16.14.23.42;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.09.16.13.37.41;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2006.09.16.13.21.23;	author damien;	state Exp;
branches;
next	;


desc
@@


1.81
log
@The read buffer size reported by the hardware can be up to 4095
bytes.  This would exceed the mbuf cluster size.  Use larger clusters
in this case.
bug report Ilja Van Sprundel; OK deraadt@@ stsp@@
@
text
@/*	$OpenBSD: if_uath.c,v 1.80 2017/03/26 15:31:15 deraadt Exp $	*/

/*-
 * Copyright (c) 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Driver for Atheros AR5005UG/AR5005UX chipsets.
 *
 * IMPORTANT NOTICE:
 * This driver was written without any documentation or support from Atheros
 * Communications. It is based on a black-box analysis of the Windows binary
 * driver. It handles both pre and post-firmware devices.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>	/* needs_reattach() */
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_uathreg.h>
#include <dev/usb/if_uathvar.h>

#ifdef UATH_DEBUG
#define DPRINTF(x)	do { if (uath_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (uath_debug >= (n)) printf x; } while (0)
int uath_debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

/*-
 * Various supported device vendors/products.
 * UB51: AR5005UG 802.11b/g, UB52: AR5005UX 802.11a/b/g
 */
#define UATH_DEV(v, p, f)						\
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, (f) },		\
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p##_NF },		\
	    (f) | UATH_FLAG_PRE_FIRMWARE }
#define UATH_DEV_UG(v, p)	UATH_DEV(v, p, 0)
#define UATH_DEV_UX(v, p)	UATH_DEV(v, p, UATH_FLAG_ABG)
static const struct uath_type {
	struct usb_devno	dev;
	unsigned int		flags;
#define UATH_FLAG_PRE_FIRMWARE	(1 << 0)
#define UATH_FLAG_ABG		(1 << 1)
} uath_devs[] = {
	UATH_DEV_UG(ACCTON,		SMCWUSBTG2),
	UATH_DEV_UG(ATHEROS,		AR5523),
	UATH_DEV_UG(ATHEROS2,		AR5523_1),
	UATH_DEV_UG(ATHEROS2,		AR5523_2),
	UATH_DEV_UX(ATHEROS2,		AR5523_3),
	UATH_DEV_UG(CONCEPTRONIC,	AR5523_1),
	UATH_DEV_UX(CONCEPTRONIC,	AR5523_2),
	UATH_DEV_UX(DLINK,		DWLAG122),
	UATH_DEV_UX(DLINK,		DWLAG132),	
	UATH_DEV_UG(DLINK,		DWLG132),
	UATH_DEV_UG(DLINK2,		WUA2340),
	UATH_DEV_UG(GIGASET,		AR5523),
	UATH_DEV_UG(GIGASET,		SMCWUSBTG),
	UATH_DEV_UG(GLOBALSUN,		AR5523_1),
	UATH_DEV_UX(GLOBALSUN,		AR5523_2),
	UATH_DEV_UG(IODATA,		USBWNG54US),
	UATH_DEV_UG(MELCO,		WLIU2KAMG54),
	UATH_DEV_UX(NETGEAR,		WG111U),
	UATH_DEV_UG(NETGEAR3,		WG111T),
	UATH_DEV_UG(NETGEAR3,		WPN111),
	UATH_DEV_UG(PHILIPS,		SNU6500),
	UATH_DEV_UX(UMEDIA,		AR5523_2),
	UATH_DEV_UG(UMEDIA,		TEW444UBEU),
	UATH_DEV_UG(WISTRONNEWEB,	AR5523_1),
	UATH_DEV_UX(WISTRONNEWEB,	AR5523_2),
	UATH_DEV_UG(ZCOM,		AR5523),

	/* Devices that share one of the IDs above. */
	{ { USB_VENDOR_NETGEAR3, USB_PRODUCT_NETGEAR3_WG111T_1 }, 0 }		\
};
#define uath_lookup(v, p)	\
	((const struct uath_type *)usb_lookup(uath_devs, v, p))

void	uath_attachhook(struct device *);
int	uath_open_pipes(struct uath_softc *);
void	uath_close_pipes(struct uath_softc *);
int	uath_alloc_tx_data_list(struct uath_softc *);
void	uath_free_tx_data_list(struct uath_softc *);
int	uath_alloc_rx_data_list(struct uath_softc *);
void	uath_free_rx_data_list(struct uath_softc *);
int	uath_alloc_tx_cmd_list(struct uath_softc *);
void	uath_free_tx_cmd_list(struct uath_softc *);
int	uath_alloc_rx_cmd_list(struct uath_softc *);
void	uath_free_rx_cmd_list(struct uath_softc *);
int	uath_media_change(struct ifnet *);
void	uath_stat(void *);
void	uath_next_scan(void *);
void	uath_task(void *);
int	uath_newstate(struct ieee80211com *, enum ieee80211_state, int);
#ifdef UATH_DEBUG
void	uath_dump_cmd(const uint8_t *, int, char);
#endif
int	uath_cmd(struct uath_softc *, uint32_t, const void *, int, void *,
	    int);
int	uath_cmd_write(struct uath_softc *, uint32_t, const void *, int, int);
int	uath_cmd_read(struct uath_softc *, uint32_t, const void *, int, void *,
	    int);
int	uath_write_reg(struct uath_softc *, uint32_t, uint32_t);
int	uath_write_multi(struct uath_softc *, uint32_t, const void *, int);
int	uath_read_reg(struct uath_softc *, uint32_t, uint32_t *);
int	uath_read_eeprom(struct uath_softc *, uint32_t, void *);
void	uath_cmd_rxeof(struct usbd_xfer *, void *, usbd_status);
void	uath_data_rxeof(struct usbd_xfer *, void *, usbd_status);
void	uath_data_txeof(struct usbd_xfer *, void *, usbd_status);
int	uath_tx_null(struct uath_softc *);
int	uath_tx_data(struct uath_softc *, struct mbuf *,
	    struct ieee80211_node *);
void	uath_start(struct ifnet *);
void	uath_watchdog(struct ifnet *);
int	uath_ioctl(struct ifnet *, u_long, caddr_t);
int	uath_query_eeprom(struct uath_softc *);
int	uath_reset(struct uath_softc *);
int	uath_reset_tx_queues(struct uath_softc *);
int	uath_wme_init(struct uath_softc *);
int	uath_set_chan(struct uath_softc *, struct ieee80211_channel *);
int	uath_set_key(struct uath_softc *, const struct ieee80211_key *, int);
int	uath_set_keys(struct uath_softc *);
int	uath_set_rates(struct uath_softc *, const struct ieee80211_rateset *);
int	uath_set_rxfilter(struct uath_softc *, uint32_t, uint32_t);
int	uath_set_led(struct uath_softc *, int, int);
int	uath_switch_channel(struct uath_softc *, struct ieee80211_channel *);
int	uath_init(struct ifnet *);
void	uath_stop(struct ifnet *, int);
int	uath_loadfirmware(struct uath_softc *, const u_char *, int);

int uath_match(struct device *, void *, void *);
void uath_attach(struct device *, struct device *, void *);
int uath_detach(struct device *, int);

struct cfdriver uath_cd = {
	NULL, "uath", DV_IFNET
};

const struct cfattach uath_ca = {
	sizeof(struct uath_softc), uath_match, uath_attach, uath_detach
};

int
uath_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != UATH_CONFIG_NO)
		return UMATCH_NONE;

	return (uath_lookup(uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
uath_attachhook(struct device *self)
{
	struct uath_softc *sc = (struct uath_softc *)self;
	u_char *fw;
	size_t size;
	int error;

	if ((error = loadfirmware("uath-ar5523", &fw, &size)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, "uath-ar5523");
		return;
	}

	error = uath_loadfirmware(sc, fw, size);
	free(fw, M_DEVBUF, size);

	if (error == 0) {
		/*
		 * Hack alert: the device doesn't always gracefully detach
		 * from the bus after a firmware upload.  We need to force
		 * a port reset and a re-exploration on the parent hub.
		 */
		usbd_reset_port(sc->sc_uhub, sc->sc_port);
		usb_needs_reattach(sc->sc_udev);
	} else {
		printf("%s: could not load firmware (error=%s)\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

void
uath_attach(struct device *parent, struct device *self, void *aux)
{
	struct uath_softc *sc = (struct uath_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usbd_status error;
	int i;

	sc->sc_udev = uaa->device;
	sc->sc_uhub = uaa->device->myhub;
	sc->sc_port = uaa->port;

	sc->sc_flags = uath_lookup(uaa->vendor, uaa->product)->flags;

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, UATH_IFACE_INDEX,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * We must open the pipes early because they're used to upload the
	 * firmware (pre-firmware devices) or to send firmware commands.
	 */
	if (uath_open_pipes(sc) != 0) {
		printf("%s: could not open pipes\n", sc->sc_dev.dv_xname);
		return;
	}

	if (sc->sc_flags & UATH_FLAG_PRE_FIRMWARE) {
		config_mountroot(self, uath_attachhook);
		return;
	}

	/*
	 * Only post-firmware devices here.
	 */
	usb_init_task(&sc->sc_task, uath_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, uath_next_scan, sc);
	timeout_set(&sc->stat_to, uath_stat, sc);

	/*
	 * Allocate xfers for firmware commands.
	 */
	if (uath_alloc_tx_cmd_list(sc) != 0) {
		printf("%s: could not allocate Tx command list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if (uath_alloc_rx_cmd_list(sc) != 0) {
		printf("%s: could not allocate Rx command list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Queue Rx command xfers.
	 */
	for (i = 0; i < UATH_RX_CMD_LIST_COUNT; i++) {
		struct uath_rx_cmd *cmd = &sc->rx_cmd[i];

		usbd_setup_xfer(cmd->xfer, sc->cmd_rx_pipe, cmd, cmd->buf,
		    UATH_MAX_RXCMDSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, uath_cmd_rxeof);
		error = usbd_transfer(cmd->xfer);
		if (error != USBD_IN_PROGRESS && error != 0) {
			printf("%s: could not queue Rx command xfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	/*
	 * We're now ready to send/receive firmware commands.
	 */
	if (uath_reset(sc) != 0) {
		printf("%s: could not initialize adapter\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if (uath_query_eeprom(sc) != 0) {
		printf("%s: could not read EEPROM\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	printf("%s: MAC/BBP AR5523, RF AR%c112, address %s\n",
	    sc->sc_dev.dv_xname, (sc->sc_flags & UATH_FLAG_ABG) ? '5': '2',
	    ether_sprintf(ic->ic_myaddr));

	/*
	 * Allocate xfers for Tx/Rx data pipes.
	 */
	if (uath_alloc_tx_data_list(sc) != 0) {
		printf("%s: could not allocate Tx data list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	if (uath_alloc_rx_data_list(sc) != 0) {
		printf("%s: could not allocate Rx data list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP;		/* h/w WEP */

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = uath_ioctl;
	ifp->if_start = uath_start;
	ifp->if_watchdog = uath_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = uath_newstate;
	ieee80211_media_init(ifp, uath_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(UATH_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(UATH_TX_RADIOTAP_PRESENT);
#endif

	return;

fail:	uath_close_pipes(sc);
	uath_free_tx_data_list(sc);
	uath_free_rx_cmd_list(sc);
	uath_free_tx_cmd_list(sc);
	usbd_deactivate(sc->sc_udev);
}

int
uath_detach(struct device *self, int flags)
{
	struct uath_softc *sc = (struct uath_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splnet();

	if (sc->sc_flags & UATH_FLAG_PRE_FIRMWARE) {
		uath_close_pipes(sc);
		splx(s);
		return 0;
	}

	/* post-firmware device */

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->stat_to))
		timeout_del(&sc->stat_to);

	/* close Tx/Rx pipes */
	uath_close_pipes(sc);

	/* free xfers */
	uath_free_tx_data_list(sc);
	uath_free_rx_data_list(sc);
	uath_free_tx_cmd_list(sc);
	uath_free_rx_cmd_list(sc);

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);	/* free all nodes */
		if_detach(ifp);
	}

	splx(s);

	return 0;
}

int
uath_open_pipes(struct uath_softc *sc)
{
	int error;

	/*
	 * XXX pipes numbers are hardcoded because we don't have any way
	 * to distinguish the data pipes from the firmware command pipes
	 * (both are bulk pipes) using the endpoints descriptors.
	 */
	error = usbd_open_pipe(sc->sc_iface, 0x01, USBD_EXCLUSIVE_USE,
	    &sc->cmd_tx_pipe);
	if (error != 0) {
		printf("%s: could not open Tx command pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	error = usbd_open_pipe(sc->sc_iface, 0x02, USBD_EXCLUSIVE_USE,
	    &sc->data_tx_pipe);
	if (error != 0) {
		printf("%s: could not open Tx data pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	error = usbd_open_pipe(sc->sc_iface, 0x81, USBD_EXCLUSIVE_USE,
	    &sc->cmd_rx_pipe);
	if (error != 0) {
		printf("%s: could not open Rx command pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	error = usbd_open_pipe(sc->sc_iface, 0x82, USBD_EXCLUSIVE_USE,
	    &sc->data_rx_pipe);
	if (error != 0) {
		printf("%s: could not open Rx data pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	return 0;

fail:	uath_close_pipes(sc);
	return error;
}

void
uath_close_pipes(struct uath_softc *sc)
{
	if (sc->data_tx_pipe != NULL) {
		usbd_close_pipe(sc->data_tx_pipe);
		sc->data_tx_pipe = NULL;
	}

	if (sc->data_rx_pipe != NULL) {
		usbd_close_pipe(sc->data_rx_pipe);
		sc->data_rx_pipe = NULL;
	}

	if (sc->cmd_tx_pipe != NULL) {
		usbd_close_pipe(sc->cmd_tx_pipe);
		sc->cmd_tx_pipe = NULL;
	}

	if (sc->cmd_rx_pipe != NULL) {
		usbd_close_pipe(sc->cmd_rx_pipe);
		sc->cmd_rx_pipe = NULL;
	}
}

int
uath_alloc_tx_data_list(struct uath_softc *sc)
{
	int i, error;

	for (i = 0; i < UATH_TX_DATA_LIST_COUNT; i++) {
		struct uath_tx_data *data = &sc->tx_data[i];

		data->sc = sc;	/* backpointer for callbacks */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer, UATH_MAX_TXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	uath_free_tx_data_list(sc);
	return error;
}

void
uath_free_tx_data_list(struct uath_softc *sc)
{
	int i;

	for (i = 0; i < UATH_TX_DATA_LIST_COUNT; i++)
		if (sc->tx_data[i].xfer != NULL) {
			usbd_free_xfer(sc->tx_data[i].xfer);
			sc->tx_data[i].xfer = NULL;
		}
}

int
uath_alloc_rx_data_list(struct uath_softc *sc)
{
	int i, error;

	for (i = 0; i < UATH_RX_DATA_LIST_COUNT; i++) {
		struct uath_rx_data *data = &sc->rx_data[i];

		data->sc = sc;	/* backpointer for callbacks */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		if (usbd_alloc_buffer(data->xfer, sc->rxbufsz) == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGETI(data->m, M_DONTWAIT, NULL, sc->rxbufsz);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		data->buf = mtod(data->m, uint8_t *);
	}
	return 0;

fail:	uath_free_rx_data_list(sc);
	return error;
}

void
uath_free_rx_data_list(struct uath_softc *sc)
{
	int i;

	for (i = 0; i < UATH_RX_DATA_LIST_COUNT; i++) {
		struct uath_rx_data *data = &sc->rx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}

		if (data->m != NULL) {
			m_freem(data->m);
			data->m = NULL;
		}
	}
}

int
uath_alloc_tx_cmd_list(struct uath_softc *sc)
{
	int i, error;

	for (i = 0; i < UATH_TX_CMD_LIST_COUNT; i++) {
		struct uath_tx_cmd *cmd = &sc->tx_cmd[i];

		cmd->sc = sc;	/* backpointer for callbacks */

		cmd->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (cmd->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		cmd->buf = usbd_alloc_buffer(cmd->xfer, UATH_MAX_TXCMDSZ);
		if (cmd->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	uath_free_tx_cmd_list(sc);
	return error;
}

void
uath_free_tx_cmd_list(struct uath_softc *sc)
{
	int i;

	for (i = 0; i < UATH_TX_CMD_LIST_COUNT; i++)
		if (sc->tx_cmd[i].xfer != NULL) {
			usbd_free_xfer(sc->tx_cmd[i].xfer);
			sc->tx_cmd[i].xfer = NULL;
		}
}

int
uath_alloc_rx_cmd_list(struct uath_softc *sc)
{
	int i, error;

	for (i = 0; i < UATH_RX_CMD_LIST_COUNT; i++) {
		struct uath_rx_cmd *cmd = &sc->rx_cmd[i];

		cmd->sc = sc;	/* backpointer for callbacks */

		cmd->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (cmd->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		cmd->buf = usbd_alloc_buffer(cmd->xfer, UATH_MAX_RXCMDSZ);
		if (cmd->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	uath_free_rx_cmd_list(sc);
	return error;
}

void
uath_free_rx_cmd_list(struct uath_softc *sc)
{
	int i;

	for (i = 0; i < UATH_RX_CMD_LIST_COUNT; i++)
		if (sc->rx_cmd[i].xfer != NULL) {
			usbd_free_xfer(sc->rx_cmd[i].xfer);
			sc->rx_cmd[i].xfer = NULL;
		}
}

int
uath_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		uath_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every second) when associated to
 * query device statistics.
 */
void
uath_stat(void *arg)
{
	struct uath_softc *sc = arg;
	int error;

	/*
	 * Send request for statistics asynchronously. The timer will be
	 * restarted when we'll get the stats notification.
	 */
	error = uath_cmd_write(sc, UATH_CMD_STATS, NULL, 0,
	    UATH_CMD_FLAG_ASYNC);
	if (error != 0) {
		printf("%s: could not query statistics (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
	}
}

/*
 * This function is called periodically (every 250ms) during scanning to
 * switch from one channel to another.
 */
void
uath_next_scan(void *arg)
{
	struct uath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
}

void
uath_task(void *arg)
{
	struct uath_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	enum ieee80211_state ostate;

	ostate = ic->ic_state;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* turn link and activity LEDs off */
			(void)uath_set_led(sc, UATH_LED_LINK, 0);
			(void)uath_set_led(sc, UATH_LED_ACTIVITY, 0);
		}
		break;

	case IEEE80211_S_SCAN:
		if (uath_switch_channel(sc, ic->ic_bss->ni_chan) != 0) {
			printf("%s: could not switch channel\n",
			    sc->sc_dev.dv_xname);
			break;
		}
		timeout_add_msec(&sc->scan_to, 250);
		break;

	case IEEE80211_S_AUTH:
	{
		struct ieee80211_node *ni = ic->ic_bss;
		struct uath_cmd_bssid bssid;
		struct uath_cmd_0b cmd0b;
		struct uath_cmd_0c cmd0c;

		if (uath_switch_channel(sc, ni->ni_chan) != 0) {
			printf("%s: could not switch channel\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		(void)uath_cmd_write(sc, UATH_CMD_24, NULL, 0, 0);

		bzero(&bssid, sizeof bssid);
		bssid.len = htobe32(IEEE80211_ADDR_LEN);
		IEEE80211_ADDR_COPY(bssid.bssid, ni->ni_bssid);
		(void)uath_cmd_write(sc, UATH_CMD_SET_BSSID, &bssid,
		    sizeof bssid, 0);

		bzero(&cmd0b, sizeof cmd0b);
		cmd0b.code = htobe32(2);
		cmd0b.size = htobe32(sizeof (cmd0b.data));
		(void)uath_cmd_write(sc, UATH_CMD_0B, &cmd0b, sizeof cmd0b, 0);

		bzero(&cmd0c, sizeof cmd0c);
		cmd0c.magic1 = htobe32(2);
		cmd0c.magic2 = htobe32(7);
		cmd0c.magic3 = htobe32(1);
		(void)uath_cmd_write(sc, UATH_CMD_0C, &cmd0c, sizeof cmd0c, 0);

		if (uath_set_rates(sc, &ni->ni_rates) != 0) {
			printf("%s: could not set negotiated rate set\n",
			    sc->sc_dev.dv_xname);
			break;
		}
		break;
	}

	case IEEE80211_S_ASSOC:
		break;

	case IEEE80211_S_RUN:
	{
		struct ieee80211_node *ni = ic->ic_bss;
		struct uath_cmd_bssid bssid;
		struct uath_cmd_xled xled;
		uint32_t val;

		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			/* make both LEDs blink while monitoring */
			bzero(&xled, sizeof xled);
			xled.which = htobe32(0);
			xled.rate = htobe32(1);
			xled.mode = htobe32(2);
			(void)uath_cmd_write(sc, UATH_CMD_SET_XLED, &xled,
			    sizeof xled, 0);
			break;
		}

		/*
		 * Tx rate is controlled by firmware, report the maximum
		 * negotiated rate in ifconfig output.
		 */
		ni->ni_txrate = ni->ni_rates.rs_nrates - 1;

		val = htobe32(1);
		(void)uath_cmd_write(sc, UATH_CMD_2E, &val, sizeof val, 0);

		bzero(&bssid, sizeof bssid);
		bssid.flags1 = htobe32(0xc004);
		bssid.flags2 = htobe32(0x003b);
		bssid.len = htobe32(IEEE80211_ADDR_LEN);
		IEEE80211_ADDR_COPY(bssid.bssid, ni->ni_bssid);
		(void)uath_cmd_write(sc, UATH_CMD_SET_BSSID, &bssid,
		    sizeof bssid, 0);

		/* turn link LED on */
		(void)uath_set_led(sc, UATH_LED_LINK, 1);

		/* make activity LED blink */
		bzero(&xled, sizeof xled);
		xled.which = htobe32(1);
		xled.rate = htobe32(1);
		xled.mode = htobe32(2);
		(void)uath_cmd_write(sc, UATH_CMD_SET_XLED, &xled, sizeof xled,
		    0);

		/* set state to associated */
		val = htobe32(1);
		(void)uath_cmd_write(sc, UATH_CMD_SET_STATE, &val, sizeof val,
		    0);

		/* start statistics timer */
		timeout_add_sec(&sc->stat_to, 1);
		break;
	}
	}
	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);
}

int
uath_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct uath_softc *sc = ic->ic_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	timeout_del(&sc->scan_to);
	timeout_del(&sc->stat_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task);
	return 0;
}

#ifdef UATH_DEBUG
void
uath_dump_cmd(const uint8_t *buf, int len, char prefix)
{
	int i;

	for (i = 0; i < len; i++) {
		if ((i % 16) == 0)
			printf("\n%c ", prefix);
		else if ((i % 4) == 0)
			printf(" ");
		printf("%02x", buf[i]);
	}
	printf("\n");
}
#endif

/*
 * Low-level function to send read or write commands to the firmware.
 */
int
uath_cmd(struct uath_softc *sc, uint32_t code, const void *idata, int ilen,
    void *odata, int flags)
{
	struct uath_cmd_hdr *hdr;
	struct uath_tx_cmd *cmd;
	uint16_t xferflags;
	int s, xferlen, error;

	/* grab a xfer */
	cmd = &sc->tx_cmd[sc->cmd_idx];

	/* always bulk-out a multiple of 4 bytes */
	xferlen = (sizeof (struct uath_cmd_hdr) + ilen + 3) & ~3;

	hdr = (struct uath_cmd_hdr *)cmd->buf;
	bzero(hdr, sizeof (struct uath_cmd_hdr));
	hdr->len   = htobe32(xferlen);
	hdr->code  = htobe32(code);
	hdr->priv  = sc->cmd_idx;	/* don't care about endianness */
	hdr->magic = htobe32((flags & UATH_CMD_FLAG_MAGIC) ? 1 << 24 : 0);
	bcopy(idata, (uint8_t *)(hdr + 1), ilen);

#ifdef UATH_DEBUG
	if (uath_debug >= 5) {
		printf("sending command code=0x%02x flags=0x%x index=%u",
		    code, flags, sc->cmd_idx);
		uath_dump_cmd(cmd->buf, xferlen, '+');
	}
#endif
	xferflags = USBD_FORCE_SHORT_XFER | USBD_NO_COPY;
	if (!(flags & UATH_CMD_FLAG_READ)) {
		if (!(flags & UATH_CMD_FLAG_ASYNC))
			xferflags |= USBD_SYNCHRONOUS;
	} else
		s = splusb();

	cmd->odata = odata;

	usbd_setup_xfer(cmd->xfer, sc->cmd_tx_pipe, cmd, cmd->buf, xferlen,
	    xferflags, UATH_CMD_TIMEOUT, NULL);
	error = usbd_transfer(cmd->xfer);
	if (error != USBD_IN_PROGRESS && error != 0) {
		if (flags & UATH_CMD_FLAG_READ)
			splx(s);
		printf("%s: could not send command 0x%x (error=%s)\n",
		    sc->sc_dev.dv_xname, code, usbd_errstr(error));
		return error;
	}
	sc->cmd_idx = (sc->cmd_idx + 1) % UATH_TX_CMD_LIST_COUNT;

	if (!(flags & UATH_CMD_FLAG_READ))
		return 0;	/* write: don't wait for reply */

	/* wait at most two seconds for command reply */
	error = tsleep(cmd, PCATCH, "uathcmd", 2 * hz);
	cmd->odata = NULL;	/* in case answer is received too late */
	splx(s);
	if (error != 0) {
		printf("%s: timeout waiting for command reply\n",
		    sc->sc_dev.dv_xname);
	}
	return error;
}

int
uath_cmd_write(struct uath_softc *sc, uint32_t code, const void *data, int len,
    int flags)
{
	flags &= ~UATH_CMD_FLAG_READ;
	return uath_cmd(sc, code, data, len, NULL, flags);
}

int
uath_cmd_read(struct uath_softc *sc, uint32_t code, const void *idata,
    int ilen, void *odata, int flags)
{
	flags |= UATH_CMD_FLAG_READ;
	return uath_cmd(sc, code, idata, ilen, odata, flags);
}

int
uath_write_reg(struct uath_softc *sc, uint32_t reg, uint32_t val)
{
	struct uath_write_mac write;
	int error;

	write.reg = htobe32(reg);
	write.len = htobe32(0);	/* 0 = single write */
	*(uint32_t *)write.data = htobe32(val);

	error = uath_cmd_write(sc, UATH_CMD_WRITE_MAC, &write,
	    3 * sizeof (uint32_t), 0);
	if (error != 0) {
		printf("%s: could not write register 0x%02x\n",
		    sc->sc_dev.dv_xname, reg);
	}
	return error;
}

int
uath_write_multi(struct uath_softc *sc, uint32_t reg, const void *data,
    int len)
{
	struct uath_write_mac write;
	int error;

	write.reg = htobe32(reg);
	write.len = htobe32(len);
	bcopy(data, write.data, len);

	/* properly handle the case where len is zero (reset) */
	error = uath_cmd_write(sc, UATH_CMD_WRITE_MAC, &write,
	    (len == 0) ? sizeof (uint32_t) : 2 * sizeof (uint32_t) + len, 0);
	if (error != 0) {
		printf("%s: could not write %d bytes to register 0x%02x\n",
		    sc->sc_dev.dv_xname, len, reg);
	}
	return error;
}

int
uath_read_reg(struct uath_softc *sc, uint32_t reg, uint32_t *val)
{
	struct uath_read_mac read;
	int error;

	reg = htobe32(reg);
	error = uath_cmd_read(sc, UATH_CMD_READ_MAC, &reg, sizeof reg, &read,
	    0);
	if (error != 0) {
		printf("%s: could not read register 0x%02x\n",
		    sc->sc_dev.dv_xname, betoh32(reg));
		return error;
	}
	*val = betoh32(*(uint32_t *)read.data);
	return error;
}

int
uath_read_eeprom(struct uath_softc *sc, uint32_t reg, void *odata)
{
	struct uath_read_mac read;
	int len, error;

	reg = htobe32(reg);
	error = uath_cmd_read(sc, UATH_CMD_READ_EEPROM, &reg, sizeof reg,
	    &read, 0);
	if (error != 0) {
		printf("%s: could not read EEPROM offset 0x%02x\n",
		    sc->sc_dev.dv_xname, betoh32(reg));
		return error;
	}
	len = betoh32(read.len);
	bcopy(read.data, odata, (len == 0) ? sizeof (uint32_t) : len);
	return error;
}

void
uath_cmd_rxeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct uath_rx_cmd *cmd = priv;
	struct uath_softc *sc = cmd->sc;
	struct uath_cmd_hdr *hdr;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cmd_rx_pipe);
		return;
	}

	hdr = (struct uath_cmd_hdr *)cmd->buf;

#ifdef UATH_DEBUG
	if (uath_debug >= 5) {
		printf("received command code=0x%x index=%u len=%u",
		    betoh32(hdr->code), hdr->priv, betoh32(hdr->len));
		uath_dump_cmd(cmd->buf, betoh32(hdr->len), '-');
	}
#endif

	switch (betoh32(hdr->code) & 0xff) {
	/* reply to a read command */
	default:
	{
		struct uath_tx_cmd *txcmd = &sc->tx_cmd[hdr->priv];

		if (txcmd->odata != NULL) {
			/* copy answer into caller's supplied buffer */
			bcopy((uint8_t *)(hdr + 1), txcmd->odata,
			    betoh32(hdr->len) - sizeof (struct uath_cmd_hdr));
		}
		wakeup(txcmd);	/* wake up caller */
		break;
	}
	/* spontaneous firmware notifications */
	case UATH_NOTIF_READY:
		DPRINTF(("received device ready notification\n"));
		wakeup(UATH_COND_INIT(sc));
		break;

	case UATH_NOTIF_TX:
		/* this notification is sent when UATH_TX_NOTIFY is set */
		DPRINTF(("received Tx notification\n"));
		break;

	case UATH_NOTIF_STATS:
		DPRINTFN(2, ("received device statistics\n"));
		timeout_add_sec(&sc->stat_to, 1);
		break;
	}

	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->cmd_rx_pipe, cmd, cmd->buf, UATH_MAX_RXCMDSZ,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
	    uath_cmd_rxeof);
	(void)usbd_transfer(xfer);
}

void
uath_data_rxeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct uath_rx_data *data = priv;
	struct uath_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct uath_rx_desc *desc;
	struct mbuf *mnew, *m;
	uint32_t hdr;
	int s, len;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->data_rx_pipe);

		ifp->if_ierrors++;
		return;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (len < UATH_MIN_RXBUFSZ) {
		DPRINTF(("wrong xfer size (len=%d)\n", len));
		ifp->if_ierrors++;
		goto skip;
	}

	hdr = betoh32(*(uint32_t *)data->buf);

	/* Rx descriptor is located at the end, 32-bit aligned */
	desc = (struct uath_rx_desc *)
	    (data->buf + len - sizeof (struct uath_rx_desc));

	if (betoh32(desc->len) > sc->rxbufsz) {
		DPRINTF(("bad descriptor (len=%d)\n", betoh32(desc->len)));
		ifp->if_ierrors++;
		goto skip;
	}

	/* there's probably a "bad CRC" flag somewhere in the descriptor.. */

	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		goto skip;
	}
	MCLGETI(mnew, M_DONTWAIT, NULL, sc->rxbufsz);
	if (!(mnew->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		m_freem(mnew);
		ifp->if_ierrors++;
		goto skip;
	}

	m = data->m;
	data->m = mnew;

	/* finalize mbuf */
	m->m_data = data->buf + sizeof (uint32_t);
	m->m_pkthdr.len = m->m_len = betoh32(desc->len) -
	    sizeof (struct uath_rx_desc) - IEEE80211_CRC_LEN;

	data->buf = mtod(data->m, uint8_t *);

	wh = mtod(m, struct ieee80211_frame *);
	rxi.rxi_flags = 0;
	if ((wh->i_fc[1] & IEEE80211_FC1_WEP) &&
	    ic->ic_opmode != IEEE80211_M_MONITOR) {
		/*
		 * Hardware decrypts the frame itself but leaves the WEP bit
		 * set in the 802.11 header and doesn't remove the IV and CRC
		 * fields.
		 */
		wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
		memmove((caddr_t)wh + IEEE80211_WEP_IVLEN +
		    IEEE80211_WEP_KIDLEN, wh, sizeof (struct ieee80211_frame));
		m_adj(m, IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN);
		m_adj(m, -IEEE80211_WEP_CRCLEN);
		wh = mtod(m, struct ieee80211_frame *);

		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

#if NBPFILTER > 0
	/* there are a lot more fields in the Rx descriptor */
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct uath_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = 0;
		tap->wr_chan_freq = htole16(betoh32(desc->freq));
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wr_dbm_antsignal = (int8_t)betoh32(desc->rssi);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	s = splnet();
	ni = ieee80211_find_rxnode(ic, wh);
	rxi.rxi_rssi = (int)betoh32(desc->rssi);
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);
	splx(s);

skip:	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->data_rx_pipe, data, data->buf, sc->rxbufsz,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, uath_data_rxeof);
	(void)usbd_transfer(data->xfer);
}

int
uath_tx_null(struct uath_softc *sc)
{
	struct uath_tx_data *data;
	struct uath_tx_desc *desc;

	data = &sc->tx_data[sc->data_idx];

	data->ni = NULL;

	*(uint32_t *)data->buf = UATH_MAKECTL(1, sizeof (struct uath_tx_desc));
	desc = (struct uath_tx_desc *)(data->buf + sizeof (uint32_t));

	bzero(desc, sizeof (struct uath_tx_desc));
	desc->len  = htobe32(sizeof (struct uath_tx_desc));
	desc->type = htobe32(UATH_TX_NULL);

	usbd_setup_xfer(data->xfer, sc->data_tx_pipe, data, data->buf,
	    sizeof (uint32_t) + sizeof (struct uath_tx_desc), USBD_NO_COPY |
	    USBD_FORCE_SHORT_XFER | USBD_SYNCHRONOUS, UATH_DATA_TIMEOUT, NULL);
	if (usbd_transfer(data->xfer) != 0)
		return EIO;

	sc->data_idx = (sc->data_idx + 1) % UATH_TX_DATA_LIST_COUNT;

	return uath_cmd_write(sc, UATH_CMD_0F, NULL, 0, UATH_CMD_FLAG_ASYNC);
}

void
uath_data_txeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct uath_tx_data *data = priv;
	struct uath_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->data_tx_pipe);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->tx_queued--;

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	uath_start(ifp);

	splx(s);
}

int
uath_tx_data(struct uath_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct uath_tx_data *data;
	struct uath_tx_desc *desc;
	const struct ieee80211_frame *wh;
	int paylen, totlen, xferlen, error;

	data = &sc->tx_data[sc->data_idx];
	desc = (struct uath_tx_desc *)(data->buf + sizeof (uint32_t));

	data->ni = ni;

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct uath_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	paylen = m0->m_pkthdr.len;
	xferlen = sizeof (uint32_t) + sizeof (struct uath_tx_desc) + paylen;

	wh = mtod(m0, struct ieee80211_frame *);
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		uint8_t *frm = (uint8_t *)(desc + 1);
		uint32_t iv;

		/* h/w WEP: it's up to the host to fill the IV field */
		bcopy(wh, frm, sizeof (struct ieee80211_frame));
		frm += sizeof (struct ieee80211_frame);

		/* insert IV: code copied from net80211 */
		iv = (ic->ic_iv != 0) ? ic->ic_iv : arc4random();
		if (iv >= 0x03ff00 && (iv & 0xf8ff00) == 0x00ff00)
			iv += 0x000100;
		ic->ic_iv = iv + 1;

		*frm++ = iv & 0xff;
		*frm++ = (iv >>  8) & 0xff;
		*frm++ = (iv >> 16) & 0xff;
		*frm++ = ic->ic_wep_txkey << 6;

		m_copydata(m0, sizeof (struct ieee80211_frame),
		    m0->m_pkthdr.len - sizeof (struct ieee80211_frame), frm);

		paylen  += IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN;
		xferlen += IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN;
		totlen = xferlen + IEEE80211_WEP_CRCLEN;
	} else {
		m_copydata(m0, 0, m0->m_pkthdr.len, (uint8_t *)(desc + 1));
		totlen = xferlen;
	}

	/* fill Tx descriptor */
	*(uint32_t *)data->buf = UATH_MAKECTL(1, xferlen - sizeof (uint32_t));

	desc->len    = htobe32(totlen);
	desc->priv   = sc->data_idx;	/* don't care about endianness */
	desc->paylen = htobe32(paylen);
	desc->type   = htobe32(UATH_TX_DATA);
	desc->flags  = htobe32(0);
	if (IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		desc->dest  = htobe32(UATH_ID_BROADCAST);
		desc->magic = htobe32(3);
	} else {
		desc->dest  = htobe32(UATH_ID_BSS);
		desc->magic = htobe32(1);
	}

	m_freem(m0);	/* mbuf is no longer needed */

#ifdef UATH_DEBUG
	if (uath_debug >= 6) {
		printf("sending frame index=%u len=%d xferlen=%d",
		    sc->data_idx, paylen, xferlen);
		uath_dump_cmd(data->buf, xferlen, '+');
	}
#endif
	usbd_setup_xfer(data->xfer, sc->data_tx_pipe, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, UATH_DATA_TIMEOUT,
	    uath_data_txeof);
	error = usbd_transfer(data->xfer);
	if (error != USBD_IN_PROGRESS && error != 0) {
		ic->ic_if.if_oerrors++;
		return error;
	}
	sc->data_idx = (sc->data_idx + 1) % UATH_TX_DATA_LIST_COUNT;
	sc->tx_queued++;

	return 0;
}

void
uath_start(struct ifnet *ifp)
{
	struct uath_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m0;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) && ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->tx_queued >= UATH_TX_DATA_LIST_COUNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (uath_tx_data(sc, m0, ni) != 0)
				break;
		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (uath_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
uath_watchdog(struct ifnet *ifp)
{
	struct uath_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/*uath_init(ifp); XXX needs a process context! */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
uath_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct uath_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				uath_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				uath_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET)
			error = 0;
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			uath_init(ifp);
		error = 0;
	}

	splx(s);

	return error;
}

int
uath_query_eeprom(struct uath_softc *sc)
{
	uint32_t tmp;
	int error;

	/* retrieve MAC address */
	error = uath_read_eeprom(sc, UATH_EEPROM_MACADDR, sc->sc_ic.ic_myaddr);
	if (error != 0) {
		printf("%s: could not read MAC address\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* retrieve the maximum frame size that the hardware can receive */
	error = uath_read_eeprom(sc, UATH_EEPROM_RXBUFSZ, &tmp);
	if (error != 0) {
		printf("%s: could not read maximum Rx buffer size\n",
		    sc->sc_dev.dv_xname);
		return error;
	}
	sc->rxbufsz = betoh32(tmp) & 0xfff;
	DPRINTF(("maximum Rx buffer size %d\n", sc->rxbufsz));
	return 0;
}

int
uath_reset(struct uath_softc *sc)
{
	struct uath_cmd_setup setup;
	uint32_t reg, val;
	int s, error;

	/* init device with some voodoo incantations.. */
	setup.magic1 = htobe32(1);
	setup.magic2 = htobe32(5);
	setup.magic3 = htobe32(200);
	setup.magic4 = htobe32(27);
	s = splusb();
	error = uath_cmd_write(sc, UATH_CMD_SETUP, &setup, sizeof setup,
	    UATH_CMD_FLAG_ASYNC);
	/* ..and wait until firmware notifies us that it is ready */
	if (error == 0)
		error = tsleep(UATH_COND_INIT(sc), PCATCH, "uathinit", 5 * hz);
	splx(s);
	if (error != 0)
		return error;

	/* read PHY registers */
	for (reg = 0x09; reg <= 0x24; reg++) {
		if (reg == 0x0b || reg == 0x0c)
			continue;
		DELAY(100);
		if ((error = uath_read_reg(sc, reg, &val)) != 0)
			return error;
		DPRINTFN(2, ("reg 0x%02x=0x%08x\n", reg, val));
	}
	return error;
}

int
uath_reset_tx_queues(struct uath_softc *sc)
{
	int ac, error;

	for (ac = 0; ac < 4; ac++) {
		const uint32_t qid = htobe32(UATH_AC_TO_QID(ac));

		DPRINTF(("resetting Tx queue %d\n", UATH_AC_TO_QID(ac)));
		error = uath_cmd_write(sc, UATH_CMD_RESET_QUEUE, &qid,
		    sizeof qid, 0);
		if (error != 0)
			break;
	}
	return error;
}

int
uath_wme_init(struct uath_softc *sc)
{
	struct uath_qinfo qinfo;
	int ac, error;
	static const struct uath_wme_settings uath_wme_11g[4] = {
		{ 7, 4, 10,  0, 0 },	/* Background */
		{ 3, 4, 10,  0, 0 },	/* Best-Effort */
		{ 3, 3,  4, 26, 0 },	/* Video */
		{ 2, 2,  3, 47, 0 }	/* Voice */
	};

	bzero(&qinfo, sizeof qinfo);
	qinfo.size   = htobe32(32);
	qinfo.magic1 = htobe32(1);	/* XXX ack policy? */
	qinfo.magic2 = htobe32(1);
	for (ac = 0; ac < 4; ac++) {
		qinfo.qid      = htobe32(UATH_AC_TO_QID(ac));
		qinfo.ac       = htobe32(ac);
		qinfo.aifsn    = htobe32(uath_wme_11g[ac].aifsn);
		qinfo.logcwmin = htobe32(uath_wme_11g[ac].logcwmin);
		qinfo.logcwmax = htobe32(uath_wme_11g[ac].logcwmax);
		qinfo.txop     = htobe32(UATH_TXOP_TO_US(
				     uath_wme_11g[ac].txop));
		qinfo.acm      = htobe32(uath_wme_11g[ac].acm);

		DPRINTF(("setting up Tx queue %d\n", UATH_AC_TO_QID(ac)));
		error = uath_cmd_write(sc, UATH_CMD_SET_QUEUE, &qinfo,
		    sizeof qinfo, 0);
		if (error != 0)
			break;
	}
	return error;
}

int
uath_set_chan(struct uath_softc *sc, struct ieee80211_channel *c)
{
	struct uath_set_chan chan;

	bzero(&chan, sizeof chan);
	chan.flags  = htobe32(0x1400);
	chan.freq   = htobe32(c->ic_freq);
	chan.magic1 = htobe32(20);
	chan.magic2 = htobe32(50);
	chan.magic3 = htobe32(1);

	DPRINTF(("switching to channel %d\n",
	    ieee80211_chan2ieee(&sc->sc_ic, c)));
	return uath_cmd_write(sc, UATH_CMD_SET_CHAN, &chan, sizeof chan, 0);
}

int
uath_set_key(struct uath_softc *sc, const struct ieee80211_key *k, int index)
{
	struct uath_cmd_crypto crypto;
	int i;

	bzero(&crypto, sizeof crypto);
	crypto.keyidx = htobe32(index);
	crypto.magic1 = htobe32(1);
	crypto.size   = htobe32(368);
	crypto.mask   = htobe32(0xffff);
	crypto.flags  = htobe32(0x80000068);
	if (index != UATH_DEFAULT_KEY)
		crypto.flags |= htobe32(index << 16);
	memset(crypto.magic2, 0xff, sizeof crypto.magic2);

	/*
	 * Each byte of the key must be XOR'ed with 10101010 before being
	 * transmitted to the firmware.
	 */
	for (i = 0; i < k->k_len; i++)
		crypto.key[i] = k->k_key[i] ^ 0xaa;

	DPRINTF(("setting crypto key index=%d len=%d\n", index, k->k_len));
	return uath_cmd_write(sc, UATH_CMD_CRYPTO, &crypto, sizeof crypto, 0);
}

int
uath_set_keys(struct uath_softc *sc)
{
	const struct ieee80211com *ic = &sc->sc_ic;
	int i, error;

	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		const struct ieee80211_key *k = &ic->ic_nw_keys[i];

		if (k->k_len > 0 && (error = uath_set_key(sc, k, i)) != 0)
			return error;
	}
	return uath_set_key(sc, &ic->ic_nw_keys[ic->ic_wep_txkey],
	    UATH_DEFAULT_KEY);
}

int
uath_set_rates(struct uath_softc *sc, const struct ieee80211_rateset *rs)
{
	struct uath_cmd_rates rates;

	bzero(&rates, sizeof rates);
	rates.magic1 = htobe32(0x02);
	rates.size   = htobe32(1 + sizeof rates.rates);
	rates.nrates = rs->rs_nrates;
	bcopy(rs->rs_rates, rates.rates, rs->rs_nrates);

	DPRINTF(("setting supported rates nrates=%d\n", rs->rs_nrates));
	return uath_cmd_write(sc, UATH_CMD_SET_RATES, &rates, sizeof rates, 0);
}

int
uath_set_rxfilter(struct uath_softc *sc, uint32_t filter, uint32_t flags)
{
	struct uath_cmd_filter rxfilter;

	rxfilter.filter = htobe32(filter);
	rxfilter.flags  = htobe32(flags);

	DPRINTF(("setting Rx filter=0x%x flags=0x%x\n", filter, flags));
	return uath_cmd_write(sc, UATH_CMD_SET_FILTER, &rxfilter,
	    sizeof rxfilter, 0);
}

int
uath_set_led(struct uath_softc *sc, int which, int on)
{
	struct uath_cmd_led led;

	led.which = htobe32(which);
	led.state = htobe32(on ? UATH_LED_ON : UATH_LED_OFF);

	DPRINTFN(2, ("switching %s led %s\n",
	    (which == UATH_LED_LINK) ? "link" : "activity",
	    on ? "on" : "off"));
	return uath_cmd_write(sc, UATH_CMD_SET_LED, &led, sizeof led, 0);
}

int
uath_switch_channel(struct uath_softc *sc, struct ieee80211_channel *c)
{
	uint32_t val;
	int error;

	/* set radio frequency */
	if ((error = uath_set_chan(sc, c)) != 0) {
		printf("%s: could not set channel\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* reset Tx rings */
	if ((error = uath_reset_tx_queues(sc)) != 0) {
		printf("%s: could not reset Tx queues\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	/* set Tx rings WME properties */
	if ((error = uath_wme_init(sc)) != 0) {
		printf("%s: could not init Tx queues\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	val = htobe32(0);
	error = uath_cmd_write(sc, UATH_CMD_SET_STATE, &val, sizeof val, 0);
	if (error != 0) {
		printf("%s: could not set state\n", sc->sc_dev.dv_xname);
		return error;
	}

	return uath_tx_null(sc);
}

int
uath_init(struct ifnet *ifp)
{
	struct uath_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct uath_cmd_31 cmd31;
	uint32_t val;
	int i, error;

	/* reset data and command rings */
	sc->tx_queued = sc->data_idx = sc->cmd_idx = 0;

	val = htobe32(0);
	(void)uath_cmd_write(sc, UATH_CMD_02, &val, sizeof val, 0);

	/* set MAC address */
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	(void)uath_write_multi(sc, 0x13, ic->ic_myaddr, IEEE80211_ADDR_LEN);

	(void)uath_write_reg(sc, 0x02, 0x00000001);
	(void)uath_write_reg(sc, 0x0e, 0x0000003f);
	(void)uath_write_reg(sc, 0x10, 0x00000001);
	(void)uath_write_reg(sc, 0x06, 0x0000001e);

	/*
	 * Queue Rx data xfers.
	 */
	for (i = 0; i < UATH_RX_DATA_LIST_COUNT; i++) {
		struct uath_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->data_rx_pipe, data, data->buf,
		    sc->rxbufsz, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT,
		    uath_data_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != USBD_IN_PROGRESS && error != 0) {
			printf("%s: could not queue Rx transfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	error = uath_cmd_read(sc, UATH_CMD_07, NULL, 0, &val,
	    UATH_CMD_FLAG_MAGIC);
	if (error != 0) {
		printf("%s: could not send read command 07h\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	DPRINTF(("command 07h return code: %x\n", betoh32(val)));

	/* set default channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	if ((error = uath_set_chan(sc, ic->ic_bss->ni_chan)) != 0) {
		printf("%s: could not set channel\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	if ((error = uath_wme_init(sc)) != 0) {
		printf("%s: could not setup WME parameters\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* init MAC registers */
	(void)uath_write_reg(sc, 0x19, 0x00000000);
	(void)uath_write_reg(sc, 0x1a, 0x0000003c);
	(void)uath_write_reg(sc, 0x1b, 0x0000003c);
	(void)uath_write_reg(sc, 0x1c, 0x00000000);
	(void)uath_write_reg(sc, 0x1e, 0x00000000);
	(void)uath_write_reg(sc, 0x1f, 0x00000003);
	(void)uath_write_reg(sc, 0x0c, 0x00000000);
	(void)uath_write_reg(sc, 0x0f, 0x00000002);
	(void)uath_write_reg(sc, 0x0a, 0x00000007);	/* XXX retry? */
	(void)uath_write_reg(sc, 0x09, ic->ic_rtsthreshold);

	val = htobe32(4);
	(void)uath_cmd_write(sc, UATH_CMD_27, &val, sizeof val, 0);
	(void)uath_cmd_write(sc, UATH_CMD_27, &val, sizeof val, 0);
	(void)uath_cmd_write(sc, UATH_CMD_1B, NULL, 0, 0);

	if ((error = uath_set_keys(sc)) != 0) {
		printf("%s: could not set crypto keys\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* enable Rx */
	(void)uath_set_rxfilter(sc, 0x0000, 4);
	(void)uath_set_rxfilter(sc, 0x0817, 1);

	cmd31.magic1 = htobe32(0xffffffff);
	cmd31.magic2 = htobe32(0xffffffff);
	(void)uath_cmd_write(sc, UATH_CMD_31, &cmd31, sizeof cmd31, 0);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;

fail:	uath_stop(ifp, 1);
	return error;
}

void
uath_stop(struct ifnet *ifp, int disable)
{
	struct uath_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t val;
	int s;

	s = splusb();

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	val = htobe32(0);
	(void)uath_cmd_write(sc, UATH_CMD_SET_STATE, &val, sizeof val, 0);
	(void)uath_cmd_write(sc, UATH_CMD_RESET, NULL, 0, 0);

	val = htobe32(0);
	(void)uath_cmd_write(sc, UATH_CMD_15, &val, sizeof val, 0);

#if 0
	(void)uath_cmd_read(sc, UATH_CMD_SHUTDOWN, NULL, 0, NULL,
	    UATH_CMD_FLAG_MAGIC);
#endif

	/* abort any pending transfers */
	usbd_abort_pipe(sc->data_tx_pipe);
	usbd_abort_pipe(sc->data_rx_pipe);
	usbd_abort_pipe(sc->cmd_tx_pipe);

	splx(s);
}

/*
 * Load the MIPS R4000 microcode into the device.  Once the image is loaded,
 * the device will detach itself from the bus and reattach later with a new
 * product Id (a la ezusb).  XXX this could also be implemented in userland
 * through /dev/ugen.
 */
int
uath_loadfirmware(struct uath_softc *sc, const u_char *fw, int len)
{
	struct usbd_xfer *ctlxfer, *txxfer, *rxxfer;
	struct uath_fwblock *txblock, *rxblock;
	uint8_t *txdata;
	int error = 0;

	if ((ctlxfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: could not allocate Tx control xfer\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail1;
	}
	txblock = usbd_alloc_buffer(ctlxfer, sizeof (struct uath_fwblock));
	if (txblock == NULL) {
		printf("%s: could not allocate Tx control block\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail2;
	}

	if ((txxfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: could not allocate Tx xfer\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail2;
	}
	txdata = usbd_alloc_buffer(txxfer, UATH_MAX_FWBLOCK_SIZE);
	if (txdata == NULL) {
		printf("%s: could not allocate Tx buffer\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail3;
	}

	if ((rxxfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: could not allocate Rx control xfer\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail3;
	}
	rxblock = usbd_alloc_buffer(rxxfer, sizeof (struct uath_fwblock));
	if (rxblock == NULL) {
		printf("%s: could not allocate Rx control block\n",
		    sc->sc_dev.dv_xname);
		error = USBD_NOMEM;
		goto fail4;
	}

	bzero(txblock, sizeof (struct uath_fwblock));
	txblock->flags = htobe32(UATH_WRITE_BLOCK);
	txblock->total = htobe32(len);

	while (len > 0) {
		int mlen = min(len, UATH_MAX_FWBLOCK_SIZE);

		txblock->remain = htobe32(len - mlen);
		txblock->len = htobe32(mlen);

		DPRINTF(("sending firmware block: %d bytes remaining\n",
		    len - mlen));

		/* send firmware block meta-data */
		usbd_setup_xfer(ctlxfer, sc->cmd_tx_pipe, sc, txblock,
		    sizeof (struct uath_fwblock),
		    USBD_NO_COPY | USBD_SYNCHRONOUS,
		    UATH_CMD_TIMEOUT, NULL);
		if ((error = usbd_transfer(ctlxfer)) != 0) {
			printf("%s: could not send firmware block info\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		/* send firmware block data */
		bcopy(fw, txdata, mlen);
		usbd_setup_xfer(txxfer, sc->data_tx_pipe, sc, txdata, mlen,
		    USBD_NO_COPY | USBD_SYNCHRONOUS, UATH_DATA_TIMEOUT, NULL);
		if ((error = usbd_transfer(txxfer)) != 0) {
			printf("%s: could not send firmware block data\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		/* wait for ack from firmware */
		usbd_setup_xfer(rxxfer, sc->cmd_rx_pipe, sc, rxblock,
		    sizeof (struct uath_fwblock), USBD_SHORT_XFER_OK |
		    USBD_NO_COPY | USBD_SYNCHRONOUS, UATH_CMD_TIMEOUT, NULL);
		if ((error = usbd_transfer(rxxfer)) != 0) {
			printf("%s: could not read firmware answer\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		DPRINTFN(2, ("rxblock flags=0x%x total=%d\n",
		    betoh32(rxblock->flags), betoh32(rxblock->rxtotal)));
		fw += mlen;
		len -= mlen;
	}

fail4:	usbd_free_xfer(rxxfer);
fail3:	usbd_free_xfer(txxfer);
fail2:	usbd_free_xfer(ctlxfer);
fail1:	return error;
}
@


1.80
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.79 2017/01/22 10:17:39 dlg Exp $	*/
d590 1
a590 1
		MCLGET(data->m, M_DONTWAIT);
d1204 1
a1204 1
	MCLGET(mnew, M_DONTWAIT);
@


1.79
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.78 2016/11/06 12:58:01 mpi Exp $	*/
d216 1
a216 1
	free(fw, M_DEVBUF, 0);
@


1.78
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.77 2016/04/13 11:03:37 mpi Exp $	*/
a1336 1
	ifp->if_opackets++;
@


1.77
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.76 2015/12/11 16:07:02 mpi Exp $	*/
d194 1
a194 1
	if (uaa->iface != NULL)
a246 6

	if (usbd_set_config_no(sc->sc_udev, UATH_CONFIG_NO, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.76
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.75 2015/11/25 03:10:00 dlg Exp $	*/
a375 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.75
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.74 2015/11/24 13:45:07 mpi Exp $	*/
d125 1
a125 1
void	uath_attachhook(void *);
d202 1
a202 1
uath_attachhook(void *xsc)
d204 1
a204 1
	struct uath_softc *sc = xsc;
d273 1
a273 4
		if (rootvp == NULL)
			mountroothook_establish(uath_attachhook, sc);
		else
			uath_attachhook(sc);
@


1.74
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.73 2015/11/24 13:33:18 mpi Exp $	*/
d1350 1
a1350 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1474 1
a1474 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1479 1
a1479 1
			ifp->if_flags |= IFF_OACTIVE;
a1936 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1938 1
d1963 2
a1964 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.73
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.72 2015/11/13 10:36:29 mpi Exp $	*/
a48 1
#include <net/if_arp.h>
@


1.72
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.71 2015/11/04 12:12:00 dlg Exp $	*/
a51 1
#include <net/if_types.h>
@


1.71
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.70 2015/10/25 12:11:56 mpi Exp $	*/
d1480 5
a1486 6
			if (sc->tx_queued >= UATH_TX_DATA_LIST_COUNT) {
				mq_requeue(&ic->ic_mgtq, m0);
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}

d1497 2
a1498 1
			IFQ_POLL(&ifp->if_snd, m0);
a1500 5
			if (sc->tx_queued >= UATH_TX_DATA_LIST_COUNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.70
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.69 2015/07/15 13:27:41 mpi Exp $	*/
d1480 1
a1480 1
		IF_POLL(&ic->ic_mgtq, m0);
d1483 1
a1486 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.69
log
@Match another Netgear WG111T.  This one shares the Non-Firmware ID of a
another device.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.68 2015/07/15 04:01:26 stsp Exp $	*/
a1554 1
	struct ifaddr *ifa;
a1561 1
		ifa = (struct ifaddr *)data;
a1562 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.68
log
@Fix a crash caused by uath(4) if device init fails.
usbd_close_pipes() now implies xfer cancellation and this driver was
relying on assumptions from times when it didn't.
With and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.67 2015/03/14 03:38:49 jsg Exp $	*/
d119 4
a122 1
	UATH_DEV_UG(ZCOM,		AR5523)
@


1.67
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.66 2015/02/10 23:25:46 mpi Exp $	*/
d292 1
a292 1
		goto fail1;
d297 1
a297 1
		goto fail2;
d313 1
a313 1
			goto fail3;
d323 1
a323 1
		goto fail3;
d327 1
a327 1
		goto fail3;
d340 1
a340 1
		goto fail3;
d345 1
a345 1
		goto fail4;
d404 4
a407 4
fail4:	uath_free_tx_data_list(sc);
fail3:	uath_free_rx_cmd_list(sc);
fail2:	uath_free_tx_cmd_list(sc);
fail1:	uath_close_pipes(sc);
d434 4
a437 1
	/* abort and free xfers */
a442 3
	/* close Tx/Rx pipes */
	uath_close_pipes(sc);

d504 1
a504 3
	/* assumes no transfers are pending on the pipes */

	if (sc->data_tx_pipe != NULL)
d506 2
d509 1
a509 1
	if (sc->data_rx_pipe != NULL)
d511 2
d514 1
a514 1
	if (sc->cmd_tx_pipe != NULL)
d516 2
d519 1
a519 1
	if (sc->cmd_rx_pipe != NULL)
d521 2
a560 3
	/* make sure no transfers are pending */
	usbd_abort_pipe(sc->data_tx_pipe);

d562 1
a562 1
		if (sc->tx_data[i].xfer != NULL)
d564 2
a619 3
	/* make sure no transfers are pending */
	usbd_abort_pipe(sc->data_rx_pipe);

d623 1
a623 1
		if (data->xfer != NULL)
d625 2
d628 1
a628 1
		if (data->m != NULL)
d630 2
a670 3
	/* make sure no transfers are pending */
	usbd_abort_pipe(sc->cmd_tx_pipe);

d672 1
a672 1
		if (sc->tx_cmd[i].xfer != NULL)
d674 2
a713 3
	/* make sure no transfers are pending */
	usbd_abort_pipe(sc->cmd_rx_pipe);

d715 1
a715 1
		if (sc->rx_cmd[i].xfer != NULL)
d717 2
@


1.66
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.65 2014/12/22 02:28:52 tedu Exp $	*/
a58 2

#include <crypto/arc4.h>
@


1.65
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.64 2014/12/19 22:44:59 guenther Exp $	*/
a1223 1
	m->m_pkthdr.rcvif = ifp;
@


1.64
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.63 2014/11/18 02:37:30 tedu Exp $	*/
a1560 1
#ifdef INET
a1562 1
#endif
@


1.63
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.62 2014/11/01 14:44:08 mpi Exp $	*/
d40 1
a42 1
#include <machine/endian.h>
@


1.62
log
@Remove the port status argument from usbd_reset_port().  We don't do
anything with it and it simplifies this mess in order to implement
warm reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.61 2014/07/13 15:52:49 mpi Exp $	*/
a59 1
#include <dev/rndvar.h>
@


1.61
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.60 2014/07/12 18:48:52 tedu Exp $	*/
a220 2
		usb_port_status_t status;

d226 1
a226 1
		usbd_reset_port(sc->sc_uhub, sc->sc_port, &status);
@


1.60
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.59 2014/07/12 07:59:23 mpi Exp $	*/
a54 1
#include <netinet/in_systm.h>
a55 1
#include <netinet/ip.h>
@


1.59
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.58 2014/03/19 10:09:19 mpi Exp $	*/
d220 1
a220 1
	free(fw, M_DEVBUF);
@


1.58
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.57 2014/03/07 18:39:02 mpi Exp $	*/
a179 1
int	uath_activate(struct device *, int);
d181 3
a183 4
int uath_match(struct device *, void *, void *); 
void uath_attach(struct device *, struct device *, void *); 
int uath_detach(struct device *, int); 
int uath_activate(struct device *, int); 
d185 1
a185 1
struct cfdriver uath_cd = { 
d187 1
a187 1
}; 
d189 2
a190 6
const struct cfattach uath_ca = { 
	sizeof(struct uath_softc), 
	uath_match, 
	uath_attach, 
	uath_detach, 
	uath_activate, 
a2110 13
}

int
uath_activate(struct device *self, int act)
{
	struct uath_softc *sc = (struct uath_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return 0;
@


1.57
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.56 2013/08/07 01:06:42 bluhm Exp $	*/
d1495 1
a1495 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.56
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.55 2013/06/11 18:45:25 deraadt Exp $	*/
a72 4

#ifdef USB_DEBUG
#define UATH_DEBUG
#endif
@


1.55
log
@Replace more ovbcopy with memmove; swap the src and dst arguments too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.54 2013/04/15 09:23:01 mglocker Exp $	*/
a55 1
#include <netinet/in_var.h>
@


1.54
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.53 2013/04/12 12:58:39 mpi Exp $	*/
d1257 2
a1258 2
		ovbcopy(wh, (caddr_t)wh + IEEE80211_WEP_IVLEN +
		    IEEE80211_WEP_KIDLEN, sizeof (struct ieee80211_frame));
@


1.53
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.52 2012/10/03 08:05:26 sthen Exp $	*/
d162 3
a164 3
void	uath_cmd_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void	uath_data_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void	uath_data_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d1111 1
a1111 1
uath_cmd_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d1173 1
a1173 1
uath_data_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d1332 1
a1332 1
uath_data_txeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d2022 1
a2022 1
	usbd_xfer_handle ctlxfer, txxfer, rxxfer;
@


1.52
log
@attach to D-Link WUA-2340, from Aaron Wirtz on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.51 2011/07/03 15:47:17 matthew Exp $	*/
d1322 2
a1323 2
	    USBD_FORCE_SHORT_XFER, UATH_DATA_TIMEOUT, NULL);
	if (usbd_sync_transfer(data->xfer) != 0)
d2084 2
a2085 1
		    sizeof (struct uath_fwblock), USBD_NO_COPY,
d2087 1
a2087 1
		if ((error = usbd_sync_transfer(ctlxfer)) != 0) {
d2096 2
a2097 2
		    USBD_NO_COPY, UATH_DATA_TIMEOUT, NULL);
		if ((error = usbd_sync_transfer(txxfer)) != 0) {
d2106 2
a2107 2
		    USBD_NO_COPY, UATH_CMD_TIMEOUT, NULL);
		if ((error = usbd_sync_transfer(rxxfer)) != 0) {
@


1.51
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.50 2011/04/07 15:30:16 miod Exp $	*/
d114 1
@


1.50
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.49 2011/01/25 20:03:35 jakemsr Exp $	*/
a2128 3
	case DVACT_ACTIVATE:
		break;

@


1.49
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.48 2011/01/06 19:49:58 damien Exp $	*/
d1909 1
a1909 1
	error = uath_cmd_read(sc, UATH_CMD_07, 0, NULL, &val,
@


1.48
log
@Remove dead links.
Atheros have reworked their website.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.47 2010/12/06 04:41:39 jakemsr Exp $	*/
a418 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);

a465 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.47
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.46 2010/10/27 17:51:11 jakemsr Exp $	*/
a21 2
 * http://www.atheros.com/pt/bulletins/AR5005UGBulletin.pdf
 * http://www.atheros.com/pt/bulletins/AR5005UXBulletin.pdf
@


1.46
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.45 2010/10/23 16:14:07 jakemsr Exp $	*/
d430 1
d2134 2
d2141 1
@


1.45
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.44 2010/10/23 15:42:09 jakemsr Exp $	*/
d464 4
a467 2
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);
@


1.44
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.43 2010/08/27 17:08:01 jsg Exp $	*/
d450 4
a453 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->stat_to);
@


1.43
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.42 2010/06/29 07:12:31 matthew Exp $	*/
d301 1
a301 1
	usb_init_task(&sc->sc_task, uath_task, sc);
@


1.42
log
@Interface drivers should use DV_IFNET, not DV_DULL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.41 2010/04/20 22:05:43 tedu Exp $	*/
a393 1
	ifp->if_init = uath_init;
@


1.41
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.40 2009/10/13 19:33:17 pirofti Exp $	*/
d194 1
a194 1
	NULL, "uath", DV_DULL 
@


1.40
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.39 2009/08/03 09:33:10 blambert Exp $	*/
a34 1
#include <sys/sysctl.h>
@


1.39
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.38 2008/12/15 17:01:54 damien Exp $	*/
d187 1
a187 1
int	uath_activate(struct device *, enum devact);
d192 1
a192 1
int uath_activate(struct device *, enum devact); 
d2129 1
a2129 1
uath_activate(struct device *self, enum devact act)
@


1.38
log
@remove duplicated usb id
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.37 2008/10/15 19:12:18 blambert Exp $	*/
d815 1
a815 1
		timeout_add(&sc->scan_to, hz / 4);
@


1.37
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.36 2008/09/23 10:47:14 canacar Exp $	*/
a126 1
	UATH_DEV_UG(UMEDIA,		AR5523_1),
@


1.36
log
@Add IDs for Philips SNU6500 to uath(4) ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.35 2008/07/21 18:43:19 damien Exp $	*/
d914 1
a914 1
		timeout_add(&sc->stat_to, hz);
d1166 1
a1166 1
		timeout_add(&sc->stat_to, hz);
@


1.35
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.34 2008/06/08 20:43:31 yuo Exp $	*/
d126 1
@


1.34
log
@add following devices
- IODATA WN-G54/US (11bg)
- MELCO WLI-U2-KAMG54 (11abg)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.33 2008/04/17 21:09:36 brad Exp $	*/
d1185 1
d1252 1
d1266 2
d1293 3
a1295 1
	ieee80211_input(ifp, m, ni, (int)betoh32(desc->rssi), 0);
@


1.33
log
@Add missing monitor mode capabilities flag.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.32 2008/01/21 12:57:31 jsg Exp $	*/
d121 2
@


1.32
log
@Add support for SMC SMCWUSBT-G2.
Tested by Kaspo Lo <kaxpolox@@yahoo.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.31 2007/10/11 18:33:14 deraadt Exp $	*/
d372 1
@


1.31
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.30 2007/09/11 19:53:58 damien Exp $	*/
d107 1
@


1.30
log
@undo rev 1.10 "implement a zero-copy RX data path".
working with a fixed number of Rx buffers doesn't work well.
fixes problems with blocked incoming traffic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.29 2007/09/07 19:05:05 damien Exp $	*/
a255 1
	char *devinfop;
a260 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.29
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.28 2007/08/28 18:34:38 deraadt Exp $	*/
a139 1
void	uath_free_rx_data(caddr_t, u_int, void *);
a455 9
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);

	sc->sc_dying = 1;
	DPRINTF(("reclaiming %d references\n", sc->sc_refcnt));
	while (sc->sc_refcnt > 0)
		(void)tsleep(UATH_COND_NOREF(sc), 0, "uathdet", 0);
	DPRINTF(("all references reclaimed\n"));

d465 3
d591 1
a591 2
	SLIST_INIT(&sc->rx_freelist);
	for (i = 0; i < UATH_RX_DATA_POOL_COUNT; i++) {
d603 1
a603 2
		data->buf = usbd_alloc_buffer(data->xfer, sc->rxbufsz);
		if (data->buf == NULL) {
d609 17
a625 1
		SLIST_INSERT_HEAD(&sc->rx_freelist, data, next);
d641 2
a642 4
	for (i = 0; i < UATH_RX_DATA_POOL_COUNT; i++)
		if (sc->rx_data[i].xfer != NULL)
			usbd_free_xfer(sc->rx_data[i].xfer);
}
d644 2
a645 5
void
uath_free_rx_data(caddr_t buf, u_int size, void *arg)
{
	struct uath_rx_data *data = arg;
	struct uath_softc *sc = data->sc;
d647 3
a649 6
	/* put the buffer back in the free list */
	SLIST_INSERT_HEAD(&sc->rx_freelist, data, next);

	/* release reference to softc */
	if (--sc->sc_refcnt == 0 && sc->sc_dying)
		wakeup(UATH_COND_NOREF(sc));
a1186 1
	struct uath_rx_data *ndata;
d1188 1
a1188 1
	struct mbuf *m;
d1224 4
a1227 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
d1231 3
a1233 5

	/* grab a new Rx buffer */
	ndata = SLIST_FIRST(&sc->rx_freelist);
	if (ndata == NULL) {
		printf("%s: could not allocate Rx buffer\n",
d1235 1
a1235 1
		m_freem(m);
a1238 1
	SLIST_REMOVE_HEAD(&sc->rx_freelist, next);
d1240 2
a1241 1
	MEXTADD(m, data->buf, sc->rxbufsz, 0, uath_free_rx_data, data);
d1249 1
a1249 1
	data = ndata;
a1288 1
	sc->sc_refcnt++;
d1297 2
a1298 3
	usbd_setup_xfer(data->xfer, sc->data_rx_pipe, data, data->buf,
	    sc->rxbufsz, USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
	    uath_data_rxeof);
d1896 1
a1896 1
		struct uath_rx_data *data = SLIST_FIRST(&sc->rx_freelist);
d1899 2
a1900 2
		    sc->rxbufsz, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, uath_data_rxeof);
a1906 1
		SLIST_REMOVE_HEAD(&sc->rx_freelist, next);
@


1.28
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.27 2007/07/18 18:10:31 damien Exp $	*/
a39 1
#include <sys/malloc.h>
@


1.27
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.26 2007/06/14 10:11:15 mbalmer Exp $	*/
d226 2
a227 2
		printf("%s: could not read firmware (error=%d)\n",
		    sc->sc_dev.dv_xname, error);
@


1.26
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.25 2007/06/12 16:26:36 mbalmer Exp $	*/
d177 1
a177 2
int	uath_set_key(struct uath_softc *, const struct ieee80211_wepkey *,
	    int);
d1753 1
a1753 2
uath_set_key(struct uath_softc *sc, const struct ieee80211_wepkey *wk,
    int index)
d1772 2
a1773 2
	for (i = 0; i < wk->wk_len; i++)
		crypto.key[i] = wk->wk_key[i] ^ 0xaa;
d1775 1
a1775 1
	DPRINTF(("setting crypto key index=%d len=%d\n", index, wk->wk_len));
d1786 1
a1786 1
		const struct ieee80211_wepkey *wk = &ic->ic_nw_keys[i];
d1788 1
a1788 2
		if (wk->wk_len > 0 &&
		    (error = uath_set_key(sc, wk, i)) != 0)
@


1.25
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.24 2007/06/10 14:49:00 mbalmer Exp $	*/
d189 16
a204 1
USB_DECLARE_DRIVER(uath);
@


1.24
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.23 2007/06/10 10:53:48 mbalmer Exp $	*/
d187 1
a187 1
int	uath_activate(device_ptr_t, enum devact);
d2118 1
a2118 1
uath_activate(device_ptr_t self, enum devact act)
@


1.23
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.22 2007/06/09 12:22:53 mbalmer Exp $	*/
d213 1
a213 1
		    USBDEVNAME(sc->sc_dev), error);
d232 1
a232 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d252 1
a252 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d259 1
a259 1
		    USBDEVNAME(sc->sc_dev));
d268 1
a268 1
		    USBDEVNAME(sc->sc_dev));
d277 1
a277 1
		printf("%s: could not open pipes\n", USBDEVNAME(sc->sc_dev));
d301 1
a301 1
		    USBDEVNAME(sc->sc_dev));
d306 1
a306 1
		    USBDEVNAME(sc->sc_dev));
d322 1
a322 1
			    USBDEVNAME(sc->sc_dev));
d332 1
a332 1
		    USBDEVNAME(sc->sc_dev));
d336 1
a336 1
		printf("%s: could not read EEPROM\n", USBDEVNAME(sc->sc_dev));
d341 1
a341 1
	    USBDEVNAME(sc->sc_dev), (sc->sc_flags & UATH_FLAG_ABG) ? '5': '2',
d349 1
a349 1
		    USBDEVNAME(sc->sc_dev));
d354 1
a354 1
		    USBDEVNAME(sc->sc_dev));
d389 1
a389 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d484 1
a484 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d492 1
a492 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d500 1
a500 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d508 1
a508 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d549 1
a549 1
			    USBDEVNAME(sc->sc_dev));
d556 1
a556 1
			    USBDEVNAME(sc->sc_dev));
d594 1
a594 1
			    USBDEVNAME(sc->sc_dev));
d601 1
a601 1
			    USBDEVNAME(sc->sc_dev));
d653 1
a653 1
			    USBDEVNAME(sc->sc_dev));
d660 1
a660 1
			    USBDEVNAME(sc->sc_dev));
d697 1
a697 1
			    USBDEVNAME(sc->sc_dev));
d704 1
a704 1
			    USBDEVNAME(sc->sc_dev));
d761 1
a761 1
		    USBDEVNAME(sc->sc_dev), error);
d801 1
a801 1
			    USBDEVNAME(sc->sc_dev));
d816 1
a816 1
			    USBDEVNAME(sc->sc_dev));
d841 1
a841 1
			    USBDEVNAME(sc->sc_dev));
d991 1
a991 1
		    USBDEVNAME(sc->sc_dev), code, usbd_errstr(error));
d1005 1
a1005 1
		    USBDEVNAME(sc->sc_dev));
d1040 1
a1040 1
		    USBDEVNAME(sc->sc_dev), reg);
d1061 1
a1061 1
		    USBDEVNAME(sc->sc_dev), len, reg);
d1077 1
a1077 1
		    USBDEVNAME(sc->sc_dev), betoh32(reg));
d1095 1
a1095 1
		    USBDEVNAME(sc->sc_dev), betoh32(reg));
d1223 1
a1223 1
		    USBDEVNAME(sc->sc_dev));
d1336 1
a1336 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d1542 1
a1542 1
			printf("%s: device timeout\n", USBDEVNAME(sc->sc_dev));
d1619 1
a1619 1
		    USBDEVNAME(sc->sc_dev));
d1627 1
a1627 1
		    USBDEVNAME(sc->sc_dev));
d1833 1
a1833 1
		printf("%s: could not set channel\n", USBDEVNAME(sc->sc_dev));
d1840 1
a1840 1
		    USBDEVNAME(sc->sc_dev));
d1847 1
a1847 1
		    USBDEVNAME(sc->sc_dev));
d1854 1
a1854 1
		printf("%s: could not set state\n", USBDEVNAME(sc->sc_dev));
d1897 1
a1897 1
			    USBDEVNAME(sc->sc_dev));
d1907 1
a1907 1
		    USBDEVNAME(sc->sc_dev));
d1915 1
a1915 1
		printf("%s: could not set channel\n", USBDEVNAME(sc->sc_dev));
d1921 1
a1921 1
		    USBDEVNAME(sc->sc_dev));
d1944 1
a1944 1
		    USBDEVNAME(sc->sc_dev));
d2022 1
a2022 1
		    USBDEVNAME(sc->sc_dev));
d2029 1
a2029 1
		    USBDEVNAME(sc->sc_dev));
d2036 1
a2036 1
		    USBDEVNAME(sc->sc_dev));
d2043 1
a2043 1
		    USBDEVNAME(sc->sc_dev));
d2050 1
a2050 1
		    USBDEVNAME(sc->sc_dev));
d2057 1
a2057 1
		    USBDEVNAME(sc->sc_dev));
d2081 1
a2081 1
			    USBDEVNAME(sc->sc_dev));
d2091 1
a2091 1
			    USBDEVNAME(sc->sc_dev));
d2101 1
a2101 1
			    USBDEVNAME(sc->sc_dev));
@


1.22
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.21 2007/06/09 08:52:10 damien Exp $	*/
d413 1
a413 1
	    USBDEV(sc->sc_dev));
d465 1
a465 1
	    USBDEV(sc->sc_dev));
@


1.21
log
@re-indent prototypes after "Static" removal.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.20 2007/06/05 08:43:55 mbalmer Exp $	*/
a2124 1
		/*if_deactivate(&sc->sc_ic.ic_if);*/
@


1.20
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.19 2007/05/27 04:00:24 jsg Exp $	*/
d150 1
a150 2
int	uath_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
d154 5
a158 6
int	uath_cmd(struct uath_softc *, uint32_t, const void *, int,
		    void *, int);
int	uath_cmd_write(struct uath_softc *, uint32_t, const void *,
		    int, int);
int	uath_cmd_read(struct uath_softc *, uint32_t, const void *,
		    int, void *, int);
d160 1
a160 2
int	uath_write_multi(struct uath_softc *, uint32_t, const void *,
		    int);
d163 3
a165 6
void	uath_cmd_rxeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
void	uath_data_rxeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
void	uath_data_txeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d168 1
a168 1
		    struct ieee80211_node *);
d177 2
a178 2
int	uath_set_key(struct uath_softc *,
		    const struct ieee80211_wepkey *, int);
d180 1
a180 2
int	uath_set_rates(struct uath_softc *,
		    const struct ieee80211_rateset *);
d183 1
a183 2
int	uath_switch_channel(struct uath_softc *,
		    struct ieee80211_channel *);
@


1.19
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.18 2007/05/21 05:40:27 jsg Exp $	*/
d134 17
a150 17
Static void	uath_attachhook(void *);
Static int	uath_open_pipes(struct uath_softc *);
Static void	uath_close_pipes(struct uath_softc *);
Static int	uath_alloc_tx_data_list(struct uath_softc *);
Static void	uath_free_tx_data_list(struct uath_softc *);
Static int	uath_alloc_rx_data_list(struct uath_softc *);
Static void	uath_free_rx_data_list(struct uath_softc *);
Static void	uath_free_rx_data(caddr_t, u_int, void *);
Static int	uath_alloc_tx_cmd_list(struct uath_softc *);
Static void	uath_free_tx_cmd_list(struct uath_softc *);
Static int	uath_alloc_rx_cmd_list(struct uath_softc *);
Static void	uath_free_rx_cmd_list(struct uath_softc *);
Static int	uath_media_change(struct ifnet *);
Static void	uath_stat(void *);
Static void	uath_next_scan(void *);
Static void	uath_task(void *);
Static int	uath_newstate(struct ieee80211com *, enum ieee80211_state,
d153 1
a153 1
Static void	uath_dump_cmd(const uint8_t *, int, char);
d155 1
a155 1
Static int	uath_cmd(struct uath_softc *, uint32_t, const void *, int,
d157 1
a157 1
Static int	uath_cmd_write(struct uath_softc *, uint32_t, const void *,
d159 1
a159 1
Static int	uath_cmd_read(struct uath_softc *, uint32_t, const void *,
d161 2
a162 2
Static int	uath_write_reg(struct uath_softc *, uint32_t, uint32_t);
Static int	uath_write_multi(struct uath_softc *, uint32_t, const void *,
d164 3
a166 3
Static int	uath_read_reg(struct uath_softc *, uint32_t, uint32_t *);
Static int	uath_read_eeprom(struct uath_softc *, uint32_t, void *);
Static void	uath_cmd_rxeof(usbd_xfer_handle, usbd_private_handle,
d168 1
a168 1
Static void	uath_data_rxeof(usbd_xfer_handle, usbd_private_handle,
d170 1
a170 1
Static void	uath_data_txeof(usbd_xfer_handle, usbd_private_handle,
d172 2
a173 2
Static int	uath_tx_null(struct uath_softc *);
Static int	uath_tx_data(struct uath_softc *, struct mbuf *,
d175 9
a183 9
Static void	uath_start(struct ifnet *);
Static void	uath_watchdog(struct ifnet *);
Static int	uath_ioctl(struct ifnet *, u_long, caddr_t);
Static int	uath_query_eeprom(struct uath_softc *);
Static int	uath_reset(struct uath_softc *);
Static int	uath_reset_tx_queues(struct uath_softc *);
Static int	uath_wme_init(struct uath_softc *);
Static int	uath_set_chan(struct uath_softc *, struct ieee80211_channel *);
Static int	uath_set_key(struct uath_softc *,
d185 2
a186 2
Static int	uath_set_keys(struct uath_softc *);
Static int	uath_set_rates(struct uath_softc *,
d188 3
a190 3
Static int	uath_set_rxfilter(struct uath_softc *, uint32_t, uint32_t);
Static int	uath_set_led(struct uath_softc *, int, int);
Static int	uath_switch_channel(struct uath_softc *,
d192 4
a195 4
Static int	uath_init(struct ifnet *);
Static void	uath_stop(struct ifnet *, int);
Static int	uath_loadfirmware(struct uath_softc *, const u_char *, int);
Static int	uath_activate(device_ptr_t, enum devact);
d211 1
a211 1
Static void
d478 1
a478 1
Static int
d526 1
a526 1
Static void
d544 1
a544 1
Static int
d575 1
a575 1
Static void
d588 1
a588 1
Static int
d621 1
a621 1
Static void
d634 1
a634 1
Static void
d648 1
a648 1
Static int
d679 1
a679 1
Static void
d692 1
a692 1
Static int
d723 1
a723 1
Static void
d736 1
a736 1
Static int
d755 1
a755 1
Static void
d777 1
a777 1
Static void
d788 1
a788 1
Static void
d917 1
a917 1
Static int
d934 1
a934 1
Static void
d953 1
a953 1
Static int
d1018 1
a1018 1
Static int
d1026 1
a1026 1
Static int
d1034 1
a1034 1
Static int
d1053 1
a1053 1
Static int
d1074 1
a1074 1
Static int
d1092 1
a1092 1
Static int
d1111 1
a1111 1
Static void
d1173 1
a1173 1
Static void
d1301 1
a1301 1
Static int
d1329 1
a1329 1
Static void
d1368 1
a1368 1
Static int
d1474 1
a1474 1
Static void
d1541 1
a1541 1
Static void
d1561 1
a1561 1
Static int
d1617 1
a1617 1
Static int
d1643 1
a1643 1
Static int
d1677 1
a1677 1
Static int
d1694 1
a1694 1
Static int
d1729 1
a1729 1
Static int
d1746 1
a1746 1
Static int
d1774 1
a1774 1
Static int
d1791 1
a1791 1
Static int
d1806 1
a1806 1
Static int
d1819 1
a1819 1
Static int
d1833 1
a1833 1
Static int
d1869 1
a1869 1
Static int
d1978 1
a1978 1
Static void
d2020 1
a2020 1
Static int
d2125 1
a2125 1
Static int
@


1.18
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.17 2007/02/19 17:22:02 deraadt Exp $	*/
d199 2
a200 1
USB_MATCH(uath)
d202 1
a202 1
	USB_MATCH_START(uath, uaa);
d244 2
a245 1
USB_ATTACH(uath)
d247 2
a248 1
	USB_ATTACH_START(uath, sc, uaa);
d260 1
a260 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d268 1
a268 1
		USB_ATTACH_ERROR_RETURN;
d277 1
a277 1
		USB_ATTACH_ERROR_RETURN;
d286 1
a286 1
		USB_ATTACH_ERROR_RETURN;
d294 1
a294 1
		USB_ATTACH_SUCCESS_RETURN;
d423 1
a423 1
	USB_ATTACH_SUCCESS_RETURN;
a428 2

	USB_ATTACH_ERROR_RETURN;
d431 2
a432 1
USB_DETACH(uath)
d434 1
a434 1
	USB_DETACH_START(uath, sc);
@


1.17
log
@do not do a curproc test for interrupt context, because it is plainly wrong.
this lets these work on macppc, for instance
diagnosed by kettenis, but damien is not around, so ok jsg and others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.16 2007/01/02 14:43:50 claudio Exp $	*/
d84 2
a85 2
#define DPRINTF(x)	do { if (uath_debug) logprintf x; } while (0)
#define DPRINTFN(n, x)	do { if (uath_debug >= (n)) logprintf x; } while (0)
@


1.16
log
@Don't use M_DUP_PKTHDR() in the driver bpf hook. Using M_DUP_PKTHDR() on a
static mbuf results in a mbuf tag memory leak. Same change as in rum(4).
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.15 2006/12/16 15:32:05 damien Exp $	*/
d925 1
d928 1
a928 6
	if (curproc != NULL) {
		uath_task(sc);
	} else {
		/* do it in a process context */
		usb_add_task(sc->sc_udev, &sc->sc_task);
	}
@


1.15
log
@trim 802.11 FCS from received frames.

noticed by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.14 2006/12/03 17:51:41 damien Exp $	*/
a1277 1
		M_DUP_PKTHDR(&mb, m);
d1281 3
a1283 1
		mb.m_pkthdr.len += mb.m_len;
a1393 1
		M_DUP_PKTHDR(&mb, m0);
d1397 3
a1399 1
		mb.m_pkthdr.len += mb.m_len;
@


1.14
log
@don't include <net80211/ieee80211_amrr.h>
rate control is handled by firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.13 2006/12/03 16:09:21 damien Exp $	*/
d1246 2
a1247 2
	m->m_pkthdr.len = m->m_len =
	    betoh32(desc->len) - sizeof (struct uath_rx_desc);
@


1.13
log
@The device doesn't always detach gracefully from the bus after a firmware
upload. We thus force a port reset and a re-exploration on the parent hub
after firmware upload.

In uath_newstate(), if we're called from a process context, we don't need
to schedule a USB task. This fixes a problem in uath_stop(): when moving
to the S_INIT state, the task was scheduled after the device was reset.

Don't abort the RX firmware command pipe in uath_stop(), otherwise we will
never receive commands ACKs from the firmware anymore.  We now survive to
an ifconfig down up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.12 2006/11/26 11:14:22 deraadt Exp $	*/
a64 1
#include <net80211/ieee80211_amrr.h>
@


1.12
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.11 2006/10/03 19:48:21 damien Exp $	*/
d73 1
d133 1
a133 1
	((struct uath_type *)usb_lookup(uath_devs, v, p))
d225 14
a238 1
	if ((error = uath_loadfirmware(sc, fw, size)) != 0) {
a241 2

	free(fw, M_DEVBUF);
d254 2
a925 1
	/* do it in a process context */
d928 6
a933 2
	usb_add_task(sc->sc_udev, &sc->sc_task);

d1002 2
a1003 2
		printf("%s: could not send command (error=%s)\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1671 1
a2011 1
	usbd_abort_pipe(sc->cmd_rx_pipe);
@


1.11
log
@make sure to call SLIST_INIT on sc->rx_freelist.
sanity check length field in RX descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.10 2006/09/20 19:47:17 damien Exp $	*/
a196 9
/*
 * Supported rates for 802.11b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset uath_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset uath_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d363 2
a364 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = uath_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = uath_rateset_11g;
@


1.10
log
@implement a zero-copy RX data path.
instead of copying the xfer buffer's content into a mbuf cluster, attach
the xfer buffer as a mbuf external storage and pass it to the net80211
layer as is.
maintain a reference count on the softc structure and wait in detach()
until all references have been released by the network layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.9 2006/09/18 18:08:32 damien Exp $	*/
d117 1
a118 1
	UATH_DEV_UG(GIGASET,		AR5523),
d588 1
d1197 2
a1198 3
	if (len < UATH_MIN_RXBUFSZ || len > sc->rxbufsz) {
		DPRINTF(("wrong xfer size: !(%d <= %d <= %d)\n",
		    UATH_MIN_RXBUFSZ, len, sc->rxbufsz));
d1208 6
@


1.9
log
@fix my 1.7 commit.
in uath_reset(), return on error if tsleep() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.8 2006/09/18 16:34:23 damien Exp $	*/
d92 2
a93 2
/* 
 * Various supported device vendors/products
d141 1
d433 1
a433 1
	s = splusb();
d447 9
a464 3
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);

d588 1
a588 1
	for (i = 0; i < UATH_RX_DATA_LIST_COUNT; i++) {
d600 2
a601 1
		if (usbd_alloc_buffer(data->xfer, sc->rxbufsz) == NULL) {
d607 1
a607 17

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    USBDEVNAME(sc->sc_dev));
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    USBDEVNAME(sc->sc_dev));
			error = ENOMEM;
			goto fail;
		}

		data->buf = mtod(data->m, uint8_t *);
d623 10
a632 2
	for (i = 0; i < UATH_RX_DATA_LIST_COUNT; i++) {
		struct uath_rx_data *data = &sc->rx_data[i];
d634 2
a635 2
		if (data->xfer != NULL)
			usbd_free_xfer(data->xfer);
d637 3
a639 3
		if (data->m != NULL)
			m_freem(data->m);
	}
d1004 1
d1178 1
d1180 1
a1180 1
	struct mbuf *mnew, *m;
d1211 2
a1212 4
	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    USBDEVNAME(sc->sc_dev));
d1216 5
a1220 3
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
d1222 1
a1222 1
		m_freem(mnew);
d1226 1
d1228 1
a1228 2
	m = data->m;
	data->m = mnew;
d1236 1
a1236 1
	data->buf = mtod(data->m, uint8_t *);
d1275 1
d1284 4
a1287 3
	usbd_setup_xfer(xfer, sc->data_rx_pipe, data, data->buf, sc->rxbufsz,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, uath_data_rxeof);
	(void)usbd_transfer(xfer);
d1785 1
a1785 1
	rates.size   = htobe32(1 + UATH_MAX_NRATES);
d1884 1
a1884 1
		struct uath_rx_data *data = &sc->rx_data[i];
d1887 2
a1888 2
		    sc->rxbufsz, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT,
		    uath_data_rxeof);
d1895 1
@


1.8
log
@better uath_set_rates().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.7 2006/09/18 16:30:17 damien Exp $	*/
d98 2
a99 1
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p##_NF }, (f) | UATH_FLAG_ABG }
d1646 2
@


1.7
log
@cleanup the list of supported devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.6 2006/09/18 16:20:20 damien Exp $	*/
a1711 3
#ifdef UATH_DEBUG
	struct ieee80211com *ic = &sc->sc_ic;
#endif
d1721 2
a1722 1
	DPRINTF(("switching to channel %d\n", ieee80211_chan2ieee(ic, c)));
d1778 1
a1778 1
	rates.magic2 = htobe32(0x21);
d1783 1
a1783 2
	return uath_cmd_write(sc, UATH_CMD_SET_RATES, &rates,
	    3 * 4 + 1 + rs->rs_nrates, 0);
@


1.6
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.5 2006/09/18 01:42:30 jsg Exp $	*/
d97 4
a100 4
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p },			\
	    (f) },							\
	{ { USB_VENDOR_##v, USB_PRODUCT_##v##_##p##_NF }, 		\
	    (f) | UATH_FLAG_PRE_FIRMWARE }
d105 1
a105 1
#define UATH_FLAG_DUAL_BAND_RF	(1 << 1)
d107 22
a128 39
	/* Atheros Communications */
	UATH_DEV(ATHEROS, AR5523, 0),
	UATH_DEV(ATHEROS2, AR5523_1, 0),
	UATH_DEV(ATHEROS2, AR5523_2, 0),
	UATH_DEV(ATHEROS2, AR5523_3, UATH_FLAG_DUAL_BAND_RF),

	/* Conceptronic */
	UATH_DEV(CONCEPTRONIC, AR5523_1, 0),
	UATH_DEV(CONCEPTRONIC, AR5523_2, UATH_FLAG_DUAL_BAND_RF),

	/* D-Link */
	UATH_DEV(DLINK, DWLAG122, UATH_FLAG_DUAL_BAND_RF),
	UATH_DEV(DLINK, DWLAG132, UATH_FLAG_DUAL_BAND_RF),	
	UATH_DEV(DLINK, DWLG132, 0),

	/* Gigaset */
	UATH_DEV(GIGASET, SMCWUSBTG, 0),
	UATH_DEV(GIGASET, AR5523, 0),

	/* Global Sun Technology */
	UATH_DEV(GLOBALSUN, AR5523_1, 0),
	UATH_DEV(GLOBALSUN, AR5523_2, UATH_FLAG_DUAL_BAND_RF),

	/* Netgear */
	UATH_DEV(NETGEAR, WG111U, UATH_FLAG_DUAL_BAND_RF),
	UATH_DEV(NETGEAR3, WG111T, 0),
	UATH_DEV(NETGEAR3, WPN111, 0),

	/* U-MEDIA Communications */
	UATH_DEV(UMEDIA, AR5523_1, 0),
	UATH_DEV(UMEDIA, AR5523_2, UATH_FLAG_DUAL_BAND_RF),
	UATH_DEV(UMEDIA, TEW444UBEU, 0),

	/* Wistron NeWeb */
	UATH_DEV(WISTRONNEWEB, AR5523_1, 0),
	UATH_DEV(WISTRONNEWEB, AR5523_2, UATH_FLAG_DUAL_BAND_RF),

	/* Z-Com */
	UATH_DEV(ZCOM, AR5523, 0)
d341 1
a341 2
	    USBDEVNAME(sc->sc_dev),
	    (sc->sc_flags & UATH_FLAG_DUAL_BAND_RF) ? '5': '2',
@


1.5
log
@More uath devices, also properly mark some of the UB52/AR5005UX devices
with the dual band flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.4 2006/09/16 19:54:13 damien Exp $	*/
d1510 1
a1510 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a1513 1
				IF_PREPEND(&ifp->if_snd, m0);
d1517 1
@


1.4
log
@add new uath(4) ids and fix existing ones.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.3 2006/09/16 14:23:42 damien Exp $	*/
d92 4
a95 1
/* various supported device vendors/products */
d115 1
a115 1
	UATH_DEV(CONCEPTRONIC, AR5523_2, 0),
d122 4
d128 1
a128 1
	UATH_DEV(GLOBALSUN, AR5523_2, 0),
d138 1
d142 4
a145 1
	UATH_DEV(WISTRONNEWEB, AR5523_2, 0)
@


1.3
log
@more uath(4) usb ids.

from jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.2 2006/09/16 13:37:41 damien Exp $	*/
d93 5
d101 2
d105 8
a112 12
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_1 },
	    0 },
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_1_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_2 },
	    0 },
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_2_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_3 },
	    UATH_FLAG_DUAL_BAND_RF },
	{ { USB_VENDOR_ATHEROS,		USB_PRODUCT_ATHEROS_AR5523_3_NF },
	    UATH_FLAG_PRE_FIRMWARE },
d115 7
a121 12
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLAG122 },
	    UATH_FLAG_DUAL_BAND_RF },
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLAG122_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLAG132 },
	    UATH_FLAG_DUAL_BAND_RF },
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLAG132_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLG132 },
	    0 },
	{ { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLG132_NF },
	    UATH_FLAG_PRE_FIRMWARE },
d124 11
a134 12
	{ { USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_WG111U },
	    UATH_FLAG_DUAL_BAND_RF },
	{ { USB_VENDOR_NETGEAR, 	USB_PRODUCT_NETGEAR_WG111U_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_NETGEAR3,	USB_PRODUCT_NETGEAR3_WG111T },
	    0 },
	{ { USB_VENDOR_NETGEAR3,	USB_PRODUCT_NETGEAR3_WG111T_NF },
	    UATH_FLAG_PRE_FIRMWARE },
	{ { USB_VENDOR_NETGEAR3,	USB_PRODUCT_NETGEAR3_WPN111 },
	    0 },
	{ { USB_VENDOR_NETGEAR3,	USB_PRODUCT_NETGEAR3_WPN111_NF },
	    UATH_FLAG_PRE_FIRMWARE }
d1865 1
a1865 1
	uint32_t /*reg,*/ val;
@


1.2
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_uath.c,v 1.1 2006/09/16 13:21:23 damien Exp $	*/
d97 14
@


1.1
log
@Initial import of uath(4), a driver for Atheros USB2.0 AR5005UG/AR5005UX
chipsets.  Based on a black-box analysis of the Windows binary driver.
Requires a firmware that is not freely redistributable (see man uath).
The driver handles both pre- and post-firmware devices.

Still a bit experimental but Tx/Rx works great in BSS mode (on i386).
No 802.11a, IBSS, or HostAP modes yet but there's more to come.

Great thanks to jsg@@ for digging the USB IDs out of the Windows driver.

Committed over a D-Link DWL-G132.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1626 1
a1626 1
uint32_t reg, val;
@

