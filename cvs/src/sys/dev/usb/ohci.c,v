head	1.152;
access;
symbols
	OPENBSD_6_2:1.152.0.2
	OPENBSD_6_2_BASE:1.152
	OPENBSD_6_1:1.149.0.4
	OPENBSD_6_1_BASE:1.149
	OPENBSD_6_0:1.146.0.6
	OPENBSD_6_0_BASE:1.146
	OPENBSD_5_9:1.146.0.2
	OPENBSD_5_9_BASE:1.146
	OPENBSD_5_8:1.145.0.4
	OPENBSD_5_8_BASE:1.145
	OPENBSD_5_7:1.142.0.2
	OPENBSD_5_7_BASE:1.142
	OPENBSD_5_6:1.137.0.4
	OPENBSD_5_6_BASE:1.137
	OPENBSD_5_5:1.119.0.4
	OPENBSD_5_5_BASE:1.119
	OPENBSD_5_4:1.114.0.2
	OPENBSD_5_4_BASE:1.114
	OPENBSD_5_3:1.106.0.2
	OPENBSD_5_3_BASE:1.106
	OPENBSD_5_2:1.105.0.4
	OPENBSD_5_2_BASE:1.105
	OPENBSD_5_1_BASE:1.105
	OPENBSD_5_1:1.105.0.2
	OPENBSD_5_0:1.104.0.2
	OPENBSD_5_0_BASE:1.104
	OPENBSD_4_9:1.103.0.2
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.95.0.2
	OPENBSD_4_8_BASE:1.95
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.91.0.4
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.90.0.2
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.87.0.2
	OPENBSD_4_4_BASE:1.87
	OPENBSD_4_3:1.85.0.2
	OPENBSD_4_3_BASE:1.85
	OPENBSD_4_2:1.84.0.2
	OPENBSD_4_2_BASE:1.84
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.73.0.4
	OPENBSD_4_0_BASE:1.73
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.55.0.2
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.32
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.152
date	2017.06.01.09.47.55;	author mpi;	state Exp;
branches;
next	1.151;
commitid	y2fqbgGVC2VlY8CT;

1.151
date	2017.05.26.13.13.50;	author mpi;	state Exp;
branches;
next	1.150;
commitid	Noou6A5iinZbDq9R;

1.150
date	2017.05.15.10.52.08;	author mpi;	state Exp;
branches;
next	1.149;
commitid	cyblrmsSmLeFugC0;

1.149
date	2017.03.10.11.18.48;	author mpi;	state Exp;
branches;
next	1.148;
commitid	KVR8Na3SYXI1y1RS;

1.148
date	2017.03.10.09.14.06;	author mpi;	state Exp;
branches;
next	1.147;
commitid	3KSzSoIpPvZCUNqm;

1.147
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.146;
commitid	RlO92XR575sygHqm;

1.146
date	2015.12.02.09.43.03;	author yasuoka;	state Exp;
branches;
next	1.145;
commitid	rdHw4hINRgGuqvHe;

1.145
date	2015.06.26.11.17.34;	author mpi;	state Exp;
branches;
next	1.144;
commitid	EHLAwh7vfwmK7jPG;

1.144
date	2015.06.22.12.56.55;	author mpi;	state Exp;
branches;
next	1.143;
commitid	tsYSHGCfv1hy9V5u;

1.143
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.142;
commitid	p4LJxGKbi0BU2cG6;

1.142
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.141;
commitid	LS2TNeCue5R9L67C;

1.141
date	2014.12.08.21.47.10;	author mpi;	state Exp;
branches;
next	1.140;
commitid	T4gge6N1edYGOJBz;

1.140
date	2014.10.05.08.40.29;	author mpi;	state Exp;
branches;
next	1.139;
commitid	gcxpPOCDYm495eL7;

1.139
date	2014.08.10.11.18.57;	author mpi;	state Exp;
branches;
next	1.138;
commitid	soKLg6qedOsGZg3L;

1.138
date	2014.08.10.11.00.36;	author mpi;	state Exp;
branches;
next	1.137;
commitid	EhRr39ksGEEyKpMd;

1.137
date	2014.08.05.20.26.15;	author mpi;	state Exp;
branches;
next	1.136;
commitid	kKc3w7FVrfZXrW2N;

1.136
date	2014.07.12.20.13.48;	author mpi;	state Exp;
branches;
next	1.135;
commitid	2p79UAVIqrMYziEA;

1.135
date	2014.07.10.20.57.40;	author mpi;	state Exp;
branches;
next	1.134;
commitid	x8n2LAVH0xAVN591;

1.134
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.133;
commitid	d8ZHVs7unt3KxWXc;

1.133
date	2014.06.04.13.52.30;	author mpi;	state Exp;
branches;
next	1.132;
commitid	MFXEmVLW2RJQYk5A;

1.132
date	2014.06.04.12.28.21;	author mpi;	state Exp;
branches;
next	1.131;
commitid	omWT0R9guKUnrNWN;

1.131
date	2014.05.30.13.24.59;	author mpi;	state Exp;
branches;
next	1.130;

1.130
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.129;

1.129
date	2014.05.09.11.01.06;	author mpi;	state Exp;
branches;
next	1.128;

1.128
date	2014.05.04.14.42.36;	author mpi;	state Exp;
branches;
next	1.127;

1.127
date	2014.04.29.21.51.18;	author mpi;	state Exp;
branches;
next	1.126;

1.126
date	2014.04.29.14.11.23;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2014.04.27.14.48.10;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2014.03.15.09.49.28;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2014.03.11.10.24.42;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2014.03.07.09.51.50;	author mpi;	state Exp;
branches;
next	1.120;

1.120
date	2014.03.07.09.38.14;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.15.11.10.40;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2013.12.09.01.02.06;	author brad;	state Exp;
branches;
next	1.117;

1.117
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2013.11.09.08.46.05;	author mpi;	state Exp;
branches;
next	1.115;

1.115
date	2013.11.01.12.00.54;	author mpi;	state Exp;
branches;
next	1.114;

1.114
date	2013.06.25.09.24.34;	author mpi;	state Exp;
branches;
next	1.113;

1.113
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2013.05.20.08.19.47;	author yasuoka;	state Exp;
branches;
next	1.111;

1.111
date	2013.04.19.08.58.53;	author mpi;	state Exp;
branches;
next	1.110;

1.110
date	2013.04.16.12.10.03;	author mpi;	state Exp;
branches;
next	1.109;

1.109
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.02.22.57.30;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2012.08.07.23.51.36;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2011.09.18.18.29.20;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.102;

1.102
date	2010.12.06.06.09.08;	author jakemsr;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.28.16.07.33;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.31.16.59.47;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.30.21.30.16;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2010.08.27.04.09.20;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2010.05.01.19.43.57;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.26.12.27.48;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.02.23.49.33;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2009.02.14.20.05.09;	author chl;	state Exp;
branches;
next	1.89;

1.89
date	2008.11.21.17.08.42;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.14.12.58.09;	author mbalmer;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.78;

1.78
date	2007.05.21.06.10.43;	author jsg;	state Exp;
branches;
next	1.77;

1.77
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2007.03.22.05.53.36;	author pascoe;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.18.06.08.24;	author pascoe;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2006.05.31.06.18.09;	author pascoe;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.29.03.49.22;	author pascoe;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.29.03.35.31;	author pascoe;	state Exp;
branches;
next	1.69;

1.69
date	2006.05.29.03.31.29;	author pascoe;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.22.15.52.48;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.22.15.26.07;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.04.14.21.30;	author jolan;	state Exp;
branches;
next	1.65;

1.65
date	2005.12.03.03.40.52;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2005.11.15.07.02.37;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2005.10.04.22.55.30;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.21.12.30.02;	author pascoe;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.21.10.00.30;	author pascoe;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.21.07.51.46;	author pascoe;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.30.14.12.35;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.30.14.02.03;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.30.03.01.55;	author pascoe;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.06.06.51.53;	author pascoe;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.06.05.30.07;	author pascoe;	state Exp;
branches;
next	1.53;

1.53
date	2005.03.06.05.12.00;	author pascoe;	state Exp;
branches;
next	1.52;

1.52
date	2004.12.26.22.41.40;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.30.11.33.56;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.11.03.33.40;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.11.04.18.34;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.11.04.17.22;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2004.08.11.04.15.10;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2004.08.11.04.12.43;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2004.08.11.04.07.04;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2004.08.11.04.05.29;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2004.08.11.04.03.15;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.11.04.01.41;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.11.05.29.16;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.10.12.59.57;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.26.20.10.22;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.06.20.40.30;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.17.11.19.24;	author todd;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.07.18.57.00;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.09.18.19.58;	author nate;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.07.22.26.34;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.09.15.20.57.33;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.13.07.43.36;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.03.02.20.32;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.25.07.03.26;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.25.07.00.59;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.22.23.24.32;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.11.16.23.30;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.08.18.10.37;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.06.22.42.10;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.04.11.44.21;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.29.13.48.31;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.01.19.11.35;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.30.16.19.32;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.28.19.37.48;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.08.39.45;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.09.27.18.03.54;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.27.09.00.28;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.19.08.18.38;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.15.18.58.58;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.08.55.57;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.03;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.19;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.46;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.7.2.9;

1.7.2.9
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	;


desc
@@


1.152
log
@Defering some processing to the soft-interrupt handler introduced a
race.  Revert for now.

Issue found by claudio@@.
@
text
@/*	$OpenBSD: ohci.c,v 1.151 2017/05/26 13:13:50 mpi Exp $ */
/*	$NetBSD: ohci.c,v 1.139 2003/02/22 05:24:16 tsutsui Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/ohci.c,v 1.22 1999/11/17 22:33:40 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/pool.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/ohcireg.h>
#include <dev/usb/ohcivar.h>

struct cfdriver ohci_cd = {
	NULL, "ohci", DV_DULL
};

#ifdef OHCI_DEBUG
#define DPRINTF(x)	do { if (ohcidebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (ohcidebug>(n)) printf x; } while (0)
int ohcidebug = 0;
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct pool *ohcixfer;

struct ohci_pipe;

struct ohci_soft_ed *ohci_alloc_sed(struct ohci_softc *);
void		ohci_free_sed(struct ohci_softc *, struct ohci_soft_ed *);

struct ohci_soft_td *ohci_alloc_std(struct ohci_softc *);
void		ohci_free_std(struct ohci_softc *, struct ohci_soft_td *);

struct ohci_soft_itd *ohci_alloc_sitd(struct ohci_softc *);
void		ohci_free_sitd(struct ohci_softc *, struct ohci_soft_itd *);

#if 0
void		ohci_free_std_chain(struct ohci_softc *, struct ohci_soft_td *,
		    struct ohci_soft_td *);
#endif
usbd_status	ohci_alloc_std_chain(struct ohci_softc *, u_int,
		    struct usbd_xfer *, struct ohci_soft_td *,
		    struct ohci_soft_td **);

usbd_status	ohci_open(struct usbd_pipe *);
int		ohci_setaddr(struct usbd_device *, int);
void		ohci_poll(struct usbd_bus *);
void		ohci_softintr(void *);
void		ohci_add_done(struct ohci_softc *, ohci_physaddr_t);
void		ohci_rhsc(struct ohci_softc *, struct usbd_xfer *);

usbd_status	ohci_device_request(struct usbd_xfer *xfer);
void		ohci_add_ed(struct ohci_soft_ed *, struct ohci_soft_ed *);
void		ohci_rem_ed(struct ohci_soft_ed *, struct ohci_soft_ed *);
void		ohci_hash_add_td(struct ohci_softc *, struct ohci_soft_td *);
struct ohci_soft_td *ohci_hash_find_td(struct ohci_softc *, ohci_physaddr_t);
void		ohci_hash_add_itd(struct ohci_softc *, struct ohci_soft_itd *);
void		ohci_hash_rem_itd(struct ohci_softc *, struct ohci_soft_itd *);
struct ohci_soft_itd *ohci_hash_find_itd(struct ohci_softc *, ohci_physaddr_t);

usbd_status	ohci_setup_isoc(struct usbd_pipe *pipe);
void		ohci_device_isoc_enter(struct usbd_xfer *);

struct usbd_xfer *ohci_allocx(struct usbd_bus *);
void		ohci_freex(struct usbd_bus *, struct usbd_xfer *);

usbd_status	ohci_root_ctrl_transfer(struct usbd_xfer *);
usbd_status	ohci_root_ctrl_start(struct usbd_xfer *);
void		ohci_root_ctrl_abort(struct usbd_xfer *);
void		ohci_root_ctrl_close(struct usbd_pipe *);
void		ohci_root_ctrl_done(struct usbd_xfer *);

usbd_status	ohci_root_intr_transfer(struct usbd_xfer *);
usbd_status	ohci_root_intr_start(struct usbd_xfer *);
void		ohci_root_intr_abort(struct usbd_xfer *);
void		ohci_root_intr_close(struct usbd_pipe *);
void		ohci_root_intr_done(struct usbd_xfer *);

usbd_status	ohci_device_ctrl_transfer(struct usbd_xfer *);
usbd_status	ohci_device_ctrl_start(struct usbd_xfer *);
void		ohci_device_ctrl_abort(struct usbd_xfer *);
void		ohci_device_ctrl_close(struct usbd_pipe *);
void		ohci_device_ctrl_done(struct usbd_xfer *);

usbd_status	ohci_device_bulk_transfer(struct usbd_xfer *);
usbd_status	ohci_device_bulk_start(struct usbd_xfer *);
void		ohci_device_bulk_abort(struct usbd_xfer *);
void		ohci_device_bulk_close(struct usbd_pipe *);
void		ohci_device_bulk_done(struct usbd_xfer *);

usbd_status	ohci_device_intr_transfer(struct usbd_xfer *);
usbd_status	ohci_device_intr_start(struct usbd_xfer *);
void		ohci_device_intr_abort(struct usbd_xfer *);
void		ohci_device_intr_close(struct usbd_pipe *);
void		ohci_device_intr_done(struct usbd_xfer *);

usbd_status	ohci_device_isoc_transfer(struct usbd_xfer *);
usbd_status	ohci_device_isoc_start(struct usbd_xfer *);
void		ohci_device_isoc_abort(struct usbd_xfer *);
void		ohci_device_isoc_close(struct usbd_pipe *);
void		ohci_device_isoc_done(struct usbd_xfer *);

usbd_status	ohci_device_setintr(struct ohci_softc *sc,
			    struct ohci_pipe *pipe, int ival);

void		ohci_timeout(void *);
void		ohci_timeout_task(void *);
void		ohci_rhsc_able(struct ohci_softc *, int);
void		ohci_rhsc_enable(void *);

void		ohci_close_pipe(struct usbd_pipe *, struct ohci_soft_ed *);
void		ohci_abort_xfer(struct usbd_xfer *, usbd_status);

void		ohci_device_clear_toggle(struct usbd_pipe *pipe);

#ifdef OHCI_DEBUG
void		ohci_dumpregs(struct ohci_softc *);
void		ohci_dump_tds(struct ohci_soft_td *);
void		ohci_dump_td(struct ohci_soft_td *);
void		ohci_dump_ed(struct ohci_soft_ed *);
void		ohci_dump_itd(struct ohci_soft_itd *);
void		ohci_dump_itds(struct ohci_soft_itd *);
#endif

#define OBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
#define OWRITE1(sc, r, x) \
 do { OBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE2(sc, r, x) \
 do { OBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE4(sc, r, x) \
 do { OBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)

__unused static __inline u_int8_t
OREAD1(struct ohci_softc *sc, bus_size_t r)
{
	OBARR(sc);
	return bus_space_read_1(sc->iot, sc->ioh, r);
}

__unused static __inline u_int16_t
OREAD2(struct ohci_softc *sc, bus_size_t r)
{
	OBARR(sc);
	return bus_space_read_2(sc->iot, sc->ioh, r);
}

__unused static __inline u_int32_t
OREAD4(struct ohci_softc *sc, bus_size_t r)
{
	OBARR(sc);
	return bus_space_read_4(sc->iot, sc->ioh, r);
}

/* Reverse the bits in a value 0 .. 31 */
u_int8_t revbits[OHCI_NO_INTRS] =
  { 0x00, 0x10, 0x08, 0x18, 0x04, 0x14, 0x0c, 0x1c,
    0x02, 0x12, 0x0a, 0x1a, 0x06, 0x16, 0x0e, 0x1e,
    0x01, 0x11, 0x09, 0x19, 0x05, 0x15, 0x0d, 0x1d,
    0x03, 0x13, 0x0b, 0x1b, 0x07, 0x17, 0x0f, 0x1f };

struct ohci_pipe {
	struct usbd_pipe pipe;
	struct ohci_soft_ed *sed;
	union {
		struct ohci_soft_td *td;
		struct ohci_soft_itd *itd;
	} tail;
	union {
		/* Control pipe */
		struct {
			struct usb_dma reqdma;
		} ctl;
		/* Interrupt pipe */
		struct {
			int nslots;
			int pos;
		} intr;
		/* Iso pipe */
		struct iso {
			int next, inuse;
		} iso;
	} u;
};

#define OHCI_INTR_ENDPT 1

struct usbd_bus_methods ohci_bus_methods = {
	.open_pipe = ohci_open,
	.dev_setaddr = ohci_setaddr,
	.soft_intr = ohci_softintr,
	.do_poll = ohci_poll,
	.allocx = ohci_allocx,
	.freex = ohci_freex,
};

struct usbd_pipe_methods ohci_root_ctrl_methods = {
	.transfer = ohci_root_ctrl_transfer,
	.start = ohci_root_ctrl_start,
	.abort = ohci_root_ctrl_abort,
	.close = ohci_root_ctrl_close,
	.done = ohci_root_ctrl_done,
};

struct usbd_pipe_methods ohci_root_intr_methods = {
	.transfer = ohci_root_intr_transfer,
	.start = ohci_root_intr_start,
	.abort = ohci_root_intr_abort,
	.close = ohci_root_intr_close,
	.done = ohci_root_intr_done,
};

struct usbd_pipe_methods ohci_device_ctrl_methods = {
	.transfer = ohci_device_ctrl_transfer,
	.start = ohci_device_ctrl_start,
	.abort = ohci_device_ctrl_abort,
	.close = ohci_device_ctrl_close,
	.done = ohci_device_ctrl_done,
};

struct usbd_pipe_methods ohci_device_intr_methods = {
	.transfer = ohci_device_intr_transfer,
	.start = ohci_device_intr_start,
	.abort = ohci_device_intr_abort,
	.close = ohci_device_intr_close,
	.cleartoggle = ohci_device_clear_toggle,
	.done = ohci_device_intr_done,
};

struct usbd_pipe_methods ohci_device_bulk_methods = {
	.transfer = ohci_device_bulk_transfer,
	.start = ohci_device_bulk_start,
	.abort = ohci_device_bulk_abort,
	.close = ohci_device_bulk_close,
	.cleartoggle = ohci_device_clear_toggle,
	.done = ohci_device_bulk_done,
};

struct usbd_pipe_methods ohci_device_isoc_methods = {
	.transfer = ohci_device_isoc_transfer,
	.start = ohci_device_isoc_start,
	.abort = ohci_device_isoc_abort,
	.close = ohci_device_isoc_close,
	.done = ohci_device_isoc_done,
};

int
ohci_activate(struct device *self, int act)
{
	struct ohci_softc *sc = (struct ohci_softc *)self;
	u_int32_t reg;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		sc->sc_bus.use_polling++;
		reg = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = reg;
			sc->sc_intre = OREAD4(sc, OHCI_INTERRUPT_ENABLE);
			sc->sc_ival = OHCI_GET_IVAL(OREAD4(sc,
			    OHCI_FM_INTERVAL));
		}
		reg |= OHCI_HCFS_SUSPEND;
		OWRITE4(sc, OHCI_CONTROL, reg);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_bus.use_polling--;
		break;
	case DVACT_RESUME:
		sc->sc_bus.use_polling++;

		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
		OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE,
			    sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
		if (sc->sc_control)
			reg = sc->sc_control;
		else
			reg = OREAD4(sc, OHCI_CONTROL);
		reg |= OHCI_HCFS_RESUME;
		OWRITE4(sc, OHCI_CONTROL, reg);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		reg = (reg & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, OHCI_CONTROL, reg);

		reg = (OREAD4(sc, OHCI_FM_REMAINING) & OHCI_FIT) ^ OHCI_FIT;
		reg |= OHCI_FSMPS(sc->sc_ival) | sc->sc_ival;
		OWRITE4(sc, OHCI_FM_INTERVAL, reg);
		OWRITE4(sc, OHCI_PERIODIC_START, OHCI_PERIODIC(sc->sc_ival));

		/* Fiddle the No OverCurrent Protection to avoid a chip bug */
		reg = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
		OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, reg | OHCI_NOCP);
		OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
		usb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);
		OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, reg);

		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_control = sc->sc_intre = sc->sc_ival = 0;
		sc->sc_bus.use_polling--;
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
ohci_detach(struct device *self, int flags)
{
	struct ohci_softc *sc = (struct ohci_softc *)self;
	int rv;

	rv = config_detach_children(self, flags);
	if (rv != 0)
		return (rv);

	timeout_del(&sc->sc_tmo_rhsc);

	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

	/* free data structures XXX */

	return (rv);
}

struct ohci_soft_ed *
ohci_alloc_sed(struct ohci_softc *sc)
{
	struct ohci_soft_ed *sed = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freeeds == NULL) {
		DPRINTFN(2, ("ohci_alloc_sed: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_SED_SIZE * OHCI_SED_CHUNK,
			  OHCI_ED_ALIGN, &dma);
		if (err)
			goto out;
		for (i = 0; i < OHCI_SED_CHUNK; i++) {
			offs = i * OHCI_SED_SIZE;
			sed = KERNADDR(&dma, offs);
			sed->physaddr = DMAADDR(&dma, offs);
			sed->next = sc->sc_freeeds;
			sc->sc_freeeds = sed;
		}
	}
	sed = sc->sc_freeeds;
	sc->sc_freeeds = sed->next;
	memset(&sed->ed, 0, sizeof(struct ohci_ed));
	sed->next = NULL;

out:
	splx(s);
	return (sed);
}

void
ohci_free_sed(struct ohci_softc *sc, struct ohci_soft_ed *sed)
{
	int s;

	s = splusb();
	sed->next = sc->sc_freeeds;
	sc->sc_freeeds = sed;
	splx(s);
}

struct ohci_soft_td *
ohci_alloc_std(struct ohci_softc *sc)
{
	struct ohci_soft_td *std = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freetds == NULL) {
		DPRINTFN(2, ("ohci_alloc_std: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_STD_SIZE * OHCI_STD_CHUNK,
			  OHCI_TD_ALIGN, &dma);
		if (err)
			goto out;
		for (i = 0; i < OHCI_STD_CHUNK; i++) {
			offs = i * OHCI_STD_SIZE;
			std = KERNADDR(&dma, offs);
			std->physaddr = DMAADDR(&dma, offs);
			std->nexttd = sc->sc_freetds;
			sc->sc_freetds = std;
		}
	}

	std = sc->sc_freetds;
	sc->sc_freetds = std->nexttd;
	memset(&std->td, 0, sizeof(struct ohci_td));
	std->nexttd = NULL;
	std->xfer = NULL;
	ohci_hash_add_td(sc, std);

out:
	splx(s);
	return (std);
}

void
ohci_free_std(struct ohci_softc *sc, struct ohci_soft_td *std)
{
	int s;

	s = splusb();
	LIST_REMOVE(std, hnext);
	std->nexttd = sc->sc_freetds;
	sc->sc_freetds = std;
	splx(s);
}

usbd_status
ohci_alloc_std_chain(struct ohci_softc *sc, u_int alen, struct usbd_xfer *xfer,
    struct ohci_soft_td *sp, struct ohci_soft_td **ep)
{
	struct ohci_soft_td *next, *cur, *end;
	ohci_physaddr_t dataphys, dataphysend;
	u_int32_t tdflags;
	u_int len, curlen;
	int mps;
	int rd = usbd_xfer_isread(xfer);
	struct usb_dma *dma = &xfer->dmabuf;
	u_int16_t flags = xfer->flags;

	DPRINTFN(alen < 4096,("ohci_alloc_std_chain: start len=%u\n", alen));

	len = alen;
	cur = sp;
	end = NULL;

	dataphys = DMAADDR(dma, 0);
	dataphysend = OHCI_PAGE(dataphys + len - 1);
	tdflags = htole32(
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
	    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |
	    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);
	mps = UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);

	while (len > 0) {
		next = ohci_alloc_std(sc);
		if (next == NULL)
			goto nomem;

		/* The OHCI hardware can handle at most one page crossing. */
		if (OHCI_PAGE(dataphys) == dataphysend ||
		    OHCI_PAGE(dataphys) + OHCI_PAGE_SIZE == dataphysend) {
			/* we can handle it in this TD */
			curlen = len;
		} else {
			/* must use multiple TDs, fill as much as possible. */
			curlen = 2 * OHCI_PAGE_SIZE -
				 (dataphys & (OHCI_PAGE_SIZE-1));
			/* the length must be a multiple of the max size */
			curlen -= curlen % mps;
#ifdef DIAGNOSTIC
			if (curlen == 0)
				panic("ohci_alloc_std: curlen == 0");
#endif
		}
		DPRINTFN(4,("ohci_alloc_std_chain: dataphys=0x%08x "
			    "dataphysend=0x%08x len=%u curlen=%u\n",
			    dataphys, dataphysend,
			    len, curlen));
		len -= curlen;

		cur->td.td_flags = tdflags;
		cur->td.td_cbp = htole32(dataphys);
		cur->nexttd = next;
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = htole32(dataphys + curlen - 1);
		cur->len = curlen;
		cur->flags = OHCI_ADD_LEN;
		cur->xfer = xfer;
		DPRINTFN(10,("ohci_alloc_std_chain: cbp=0x%08x be=0x%08x\n",
			    dataphys, dataphys + curlen - 1));
		DPRINTFN(10,("ohci_alloc_std_chain: extend chain\n"));
		dataphys += curlen;
		end = cur;
		cur = next;
	}
	if (!rd && ((flags & USBD_FORCE_SHORT_XFER) || alen == 0) &&
	    alen % mps == 0) {
		/* Force a 0 length transfer at the end. */

		next = ohci_alloc_std(sc);
		if (next == NULL)
			goto nomem;

		cur->td.td_flags = tdflags;
		cur->td.td_cbp = 0; /* indicate 0 length packet */
		cur->nexttd = next;
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = ~0;
		cur->len = 0;
		cur->flags = 0;
		cur->xfer = xfer;
		DPRINTFN(2,("ohci_alloc_std_chain: add 0 xfer\n"));
		end = cur;
	}
	*ep = end;

	return (USBD_NORMAL_COMPLETION);

 nomem:
	/* XXX free chain */
	return (USBD_NOMEM);
}

#if 0
void
ohci_free_std_chain(struct ohci_softc *sc, struct ohci_soft_td *std,
    struct ohci_soft_td *stdend)
{
	struct ohci_soft_td *p;

	for (; std != stdend; std = p) {
		p = std->nexttd;
		ohci_free_std(sc, std);
	}
}
#endif

struct ohci_soft_itd *
ohci_alloc_sitd(struct ohci_softc *sc)
{
	struct ohci_soft_itd *sitd;
	usbd_status err;
	int i, s, offs;
	struct usb_dma dma;

	if (sc->sc_freeitds == NULL) {
		DPRINTFN(2, ("ohci_alloc_sitd: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_SITD_SIZE * OHCI_SITD_CHUNK,
			  OHCI_ITD_ALIGN, &dma);
		if (err)
			return (NULL);
		s = splusb();
		for(i = 0; i < OHCI_SITD_CHUNK; i++) {
			offs = i * OHCI_SITD_SIZE;
			sitd = KERNADDR(&dma, offs);
			sitd->physaddr = DMAADDR(&dma, offs);
			sitd->nextitd = sc->sc_freeitds;
			sc->sc_freeitds = sitd;
		}
		splx(s);
	}

	s = splusb();
	sitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd->nextitd;
	memset(&sitd->itd, 0, sizeof(struct ohci_itd));
	sitd->nextitd = NULL;
	sitd->xfer = NULL;
	ohci_hash_add_itd(sc, sitd);
	splx(s);

#ifdef DIAGNOSTIC
	sitd->isdone = 0;
#endif

	return (sitd);
}

void
ohci_free_sitd(struct ohci_softc *sc, struct ohci_soft_itd *sitd)
{
	int s;

	DPRINTFN(10,("ohci_free_sitd: sitd=%p\n", sitd));

#ifdef DIAGNOSTIC
	if (!sitd->isdone) {
		panic("ohci_free_sitd: sitd=%p not done", sitd);
		return;
	}
	/* Warn double free */
	sitd->isdone = 0;
#endif

	s = splusb();
	ohci_hash_rem_itd(sc, sitd);
	sitd->nextitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd;
	splx(s);
}

usbd_status
ohci_checkrev(struct ohci_softc *sc)
{
	u_int32_t rev;

	printf(",");
	rev = OREAD4(sc, OHCI_REVISION);
	printf(" version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
	       OHCI_REV_LEGACY(rev) ? ", legacy support" : "");

	if (OHCI_REV_HI(rev) != 1 || OHCI_REV_LO(rev) != 0) {
		printf("%s: unsupported OHCI revision\n",
		       sc->sc_bus.bdev.dv_xname);
		sc->sc_bus.usbrev = USBREV_UNKNOWN;
		return (USBD_INVAL);
	}
	sc->sc_bus.usbrev = USBREV_1_0;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
ohci_handover(struct ohci_softc *sc)
{
	u_int32_t s, ctl;
	int i;

	ctl = OREAD4(sc, OHCI_CONTROL);
	if (ctl & OHCI_IR) {
		/* SMM active, request change */
		DPRINTF(("ohci_handover: SMM active, request owner change\n"));
		if ((sc->sc_intre & (OHCI_OC | OHCI_MIE)) == 
		    (OHCI_OC | OHCI_MIE))
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_MIE);
		s = OREAD4(sc, OHCI_COMMAND_STATUS);
		OWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);
		for (i = 0; i < 100 && (ctl & OHCI_IR); i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			ctl = OREAD4(sc, OHCI_CONTROL);
		}
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_MIE);
		if (ctl & OHCI_IR) {
			printf("%s: SMM does not respond, will reset\n",
			    sc->sc_bus.bdev.dv_xname);
		}
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
ohci_init(struct ohci_softc *sc)
{
	struct ohci_soft_ed *sed, *psed;
	usbd_status err;
	int i;
	u_int32_t ctl, rwc, ival, hcr, fm, per, desca, descb;

	DPRINTF(("ohci_init: start\n"));

	for (i = 0; i < OHCI_HASH_SIZE; i++)
		LIST_INIT(&sc->sc_hash_tds[i]);
	for (i = 0; i < OHCI_HASH_SIZE; i++)
		LIST_INIT(&sc->sc_hash_itds[i]);

	if (ohcixfer == NULL) {
		ohcixfer = malloc(sizeof(struct pool), M_DEVBUF, M_NOWAIT);
		if (ohcixfer == NULL) {
			printf("%s: unable to allocate pool descriptor\n",
			    sc->sc_bus.bdev.dv_xname);
			return (ENOMEM);
		}
		pool_init(ohcixfer, sizeof(struct ohci_xfer), 0, IPL_SOFTUSB,
		    0, "ohcixfer", NULL);
	}

	/* XXX determine alignment by R/W */
	/* Allocate the HCCA area. */
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE,
			 OHCI_HCCA_ALIGN, &sc->sc_hccadma);
	if (err)
		return (err);
	sc->sc_hcca = KERNADDR(&sc->sc_hccadma, 0);
	memset(sc->sc_hcca, 0, OHCI_HCCA_SIZE);

	sc->sc_eintrs = OHCI_NORMAL_INTRS;

	/* Allocate dummy ED that starts the control list. */
	sc->sc_ctrl_head = ohci_alloc_sed(sc);
	if (sc->sc_ctrl_head == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	sc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate dummy ED that starts the bulk list. */
	sc->sc_bulk_head = ohci_alloc_sed(sc);
	if (sc->sc_bulk_head == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}
	sc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate dummy ED that starts the isochronous list. */
	sc->sc_isoc_head = ohci_alloc_sed(sc);
	if (sc->sc_isoc_head == NULL) {
		err = USBD_NOMEM;
		goto bad3;
	}
	sc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate all the dummy EDs that make up the interrupt tree. */
	for (i = 0; i < OHCI_NO_EDS; i++) {
		sed = ohci_alloc_sed(sc);
		if (sed == NULL) {
			while (--i >= 0)
				ohci_free_sed(sc, sc->sc_eds[i]);
			err = USBD_NOMEM;
			goto bad4;
		}
		/* All ED fields are set to 0. */
		sc->sc_eds[i] = sed;
		sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
		if (i != 0)
			psed = sc->sc_eds[(i-1) / 2];
		else
			psed= sc->sc_isoc_head;
		sed->next = psed;
		sed->ed.ed_nexted = htole32(psed->physaddr);
	}
	/*
	 * Fill HCCA interrupt table.  The bit reversal is to get
	 * the tree set up properly to spread the interrupts.
	 */
	for (i = 0; i < OHCI_NO_INTRS; i++)
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] =
		    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);

#ifdef OHCI_DEBUG
	if (ohcidebug > 15) {
		for (i = 0; i < OHCI_NO_EDS; i++) {
			printf("ed#%d ", i);
			ohci_dump_ed(sc->sc_eds[i]);
		}
		printf("iso ");
		ohci_dump_ed(sc->sc_isoc_head);
	}
#endif
	/* Preserve values programmed by SMM/BIOS but lost over reset. */
	ctl = OREAD4(sc, OHCI_CONTROL);
	rwc = ctl & OHCI_RWC;
	fm = OREAD4(sc, OHCI_FM_INTERVAL);
	desca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
	descb = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);

	/* Determine in what context we are running. */
	if (ctl & OHCI_IR) {
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET | rwc);
		goto reset;
#if 0
/* Don't bother trying to reuse the BIOS init, we'll reset it anyway. */
	} else if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_RESET) {
		/* BIOS started controller. */
		DPRINTF(("ohci_init: BIOS active\n"));
		if ((ctl & OHCI_HCFS_MASK) != OHCI_HCFS_OPERATIONAL) {
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL | rwc);
			usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		}
#endif
	} else {
		DPRINTF(("ohci_init: cold started\n"));
	reset:
		/* Controller was cold started. */
		usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);
	}

	/*
	 * This reset should not be necessary according to the OHCI spec, but
	 * without it some controllers do not start.
	 */
	DPRINTF(("%s: resetting\n", sc->sc_bus.bdev.dv_xname));
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET | rwc);
	usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);

	/* We now own the host controller and the bus has been reset. */

	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_HCR); /* Reset HC */
	/* Nominal time for a reset is 10 us. */
	for (i = 0; i < 10; i++) {
		delay(10);
		hcr = OREAD4(sc, OHCI_COMMAND_STATUS) & OHCI_HCR;
		if (!hcr)
			break;
	}
	if (hcr) {
		printf("%s: reset timeout\n", sc->sc_bus.bdev.dv_xname);
		err = USBD_IOERROR;
		goto bad5;
	}
#ifdef OHCI_DEBUG
	if (ohcidebug > 15)
		ohci_dumpregs(sc);
#endif

	/* The controller is now in SUSPEND state, we have 2ms to finish. */

	/* Set up HC registers. */
	OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
	OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
	OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
	/* disable all interrupts and then switch on all desired interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
	/* switch on desired functional features */
	ctl = OREAD4(sc, OHCI_CONTROL);
	ctl &= ~(OHCI_CBSR_MASK | OHCI_LES | OHCI_HCFS_MASK | OHCI_IR);
	ctl |= OHCI_PLE | OHCI_IE | OHCI_CLE | OHCI_BLE |
		OHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL | rwc;
	/* And finally start it! */
	OWRITE4(sc, OHCI_CONTROL, ctl);

	/*
	 * The controller is now OPERATIONAL.  Set a some final
	 * registers that should be set earlier, but that the
	 * controller ignores when in the SUSPEND state.
	 */
	ival = OHCI_GET_IVAL(fm);
	fm = (OREAD4(sc, OHCI_FM_REMAINING) & OHCI_FIT) ^ OHCI_FIT;
	fm |= OHCI_FSMPS(ival) | ival;
	OWRITE4(sc, OHCI_FM_INTERVAL, fm);
	per = OHCI_PERIODIC(ival); /* 90% periodic */
	OWRITE4(sc, OHCI_PERIODIC_START, per);

	/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);
	OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
	usb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_B, descb);
	usb_delay_ms(&sc->sc_bus, OHCI_GET_POTPGT(desca) * UHD_PWRON_FACTOR);

	/*
	 * The AMD756 requires a delay before re-reading the register,
	 * otherwise it will occasionally report 0 ports.
	 */
	sc->sc_noport = 0;
	for (i = 0; i < 10 && sc->sc_noport == 0; i++) {
		usb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);
		sc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));
	}

#ifdef OHCI_DEBUG
	if (ohcidebug > 5)
		ohci_dumpregs(sc);
#endif

	/* Set up the bus struct. */
	sc->sc_bus.methods = &ohci_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct ohci_pipe);

	sc->sc_control = sc->sc_intre = 0;

	timeout_set(&sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);

	/* Finally, turn on interrupts. */
	DPRINTFN(1,("ohci_init: enabling\n"));
	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);

	return (USBD_NORMAL_COMPLETION);

 bad5:
	for (i = 0; i < OHCI_NO_EDS; i++)
		ohci_free_sed(sc, sc->sc_eds[i]);
 bad4:
	ohci_free_sed(sc, sc->sc_isoc_head);
 bad3:
	ohci_free_sed(sc, sc->sc_bulk_head);
 bad2:
	ohci_free_sed(sc, sc->sc_ctrl_head);
 bad1:
	usb_freemem(&sc->sc_bus, &sc->sc_hccadma);
	return (err);
}

struct usbd_xfer *
ohci_allocx(struct usbd_bus *bus)
{
	return (pool_get(ohcixfer, PR_NOWAIT | PR_ZERO));
}

void
ohci_freex(struct usbd_bus *bus, struct usbd_xfer *xfer)
{
	pool_put(ohcixfer, xfer);
}

#ifdef OHCI_DEBUG
void
ohci_dumpregs(struct ohci_softc *sc)
{
	DPRINTF(("ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n",
		 OREAD4(sc, OHCI_REVISION),
		 OREAD4(sc, OHCI_CONTROL),
		 OREAD4(sc, OHCI_COMMAND_STATUS)));
	DPRINTF(("               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n",
		 OREAD4(sc, OHCI_INTERRUPT_STATUS),
		 OREAD4(sc, OHCI_INTERRUPT_ENABLE),
		 OREAD4(sc, OHCI_INTERRUPT_DISABLE)));
	DPRINTF(("               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n",
		 OREAD4(sc, OHCI_HCCA),
		 OREAD4(sc, OHCI_PERIOD_CURRENT_ED),
		 OREAD4(sc, OHCI_CONTROL_HEAD_ED)));
	DPRINTF(("               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n",
		 OREAD4(sc, OHCI_CONTROL_CURRENT_ED),
		 OREAD4(sc, OHCI_BULK_HEAD_ED),
		 OREAD4(sc, OHCI_BULK_CURRENT_ED)));
	DPRINTF(("               done=0x%08x fmival=0x%08x fmrem=0x%08x\n",
		 OREAD4(sc, OHCI_DONE_HEAD),
		 OREAD4(sc, OHCI_FM_INTERVAL),
		 OREAD4(sc, OHCI_FM_REMAINING)));
	DPRINTF(("               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n",
		 OREAD4(sc, OHCI_FM_NUMBER),
		 OREAD4(sc, OHCI_PERIODIC_START),
		 OREAD4(sc, OHCI_LS_THRESHOLD)));
	DPRINTF(("               desca=0x%08x descb=0x%08x stat=0x%08x\n",
		 OREAD4(sc, OHCI_RH_DESCRIPTOR_A),
		 OREAD4(sc, OHCI_RH_DESCRIPTOR_B),
		 OREAD4(sc, OHCI_RH_STATUS)));
	DPRINTF(("               port1=0x%08x port2=0x%08x\n",
		 OREAD4(sc, OHCI_RH_PORT_STATUS(1)),
		 OREAD4(sc, OHCI_RH_PORT_STATUS(2))));
	DPRINTF(("         HCCA: frame_number=0x%04x done_head=0x%08x\n",
		 letoh32(sc->sc_hcca->hcca_frame_number),
		 letoh32(sc->sc_hcca->hcca_done_head)));
}
#endif

int ohci_intr1(struct ohci_softc *);

int
ohci_intr(void *p)
{
	struct ohci_softc *sc = p;

	if (sc == NULL || sc->sc_bus.dying)
		return (0);

	/* If we get an interrupt while polling, then just ignore it. */
	if (sc->sc_bus.use_polling) {
#ifdef DIAGNOSTIC
		static struct timeval ohci_intr_tv;
		if ((OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs) &&
		    usbd_ratecheck(&ohci_intr_tv))
			DPRINTFN(16,
			    ("ohci_intr: ignored interrupt while polling\n"));
#endif
		return (0);
	}

	return (ohci_intr1(sc));
}

int
ohci_intr1(struct ohci_softc *sc)
{
	u_int32_t intrs, eintrs;
	ohci_physaddr_t done;

	DPRINTFN(14,("ohci_intr1: enter\n"));

	/* In case the interrupt occurs before initialization has completed. */
	if (sc == NULL || sc->sc_hcca == NULL) {
#ifdef DIAGNOSTIC
		printf("ohci_intr: sc->sc_hcca == NULL\n");
#endif
		return (0);
	}

        intrs = 0;
	done = letoh32(sc->sc_hcca->hcca_done_head);
	if (done != 0) {
		if (done & ~OHCI_DONE_INTRS)
			intrs = OHCI_WDH;
		if (done & OHCI_DONE_INTRS)
			intrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);
		sc->sc_hcca->hcca_done_head = 0;
	} else {
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);
		/* If we've flushed out a WDH then reread */
		if (intrs & OHCI_WDH) {
			done = letoh32(sc->sc_hcca->hcca_done_head);
			sc->sc_hcca->hcca_done_head = 0;
		}
	}

	if (intrs == 0xffffffff) {
		sc->sc_bus.dying = 1;
		return (0);
	}

	if (!intrs)
		return (0);

	intrs &= ~OHCI_MIE;
	OWRITE4(sc, OHCI_INTERRUPT_STATUS, intrs); /* Acknowledge */
	eintrs = intrs & sc->sc_eintrs;
	if (!eintrs)
		return (0);

	sc->sc_bus.intr_context++;
	sc->sc_bus.no_intrs++;
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
		     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),
		     (u_int)eintrs));

	if (eintrs & OHCI_SO) {
		sc->sc_overrun_cnt++;
		if (usbd_ratecheck(&sc->sc_overrun_ntc)) {
			printf("%s: %u scheduling overruns\n",
			    sc->sc_bus.bdev.dv_xname, sc->sc_overrun_cnt);
			sc->sc_overrun_cnt = 0;
		}
		/* XXX do what */
		eintrs &= ~OHCI_SO;
	}
	if (eintrs & OHCI_WDH) {
		ohci_add_done(sc, done &~ OHCI_DONE_INTRS);
		usb_schedsoftintr(&sc->sc_bus);
		eintrs &= ~OHCI_WDH;
	}
	if (eintrs & OHCI_RD) {
		printf("%s: resume detect\n", sc->sc_bus.bdev.dv_xname);
		/* XXX process resume detect */
	}
	if (eintrs & OHCI_UE) {
		printf("%s: unrecoverable error, controller halted\n",
		       sc->sc_bus.bdev.dv_xname);
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
		/* XXX what else */
	}
	if (eintrs & OHCI_RHSC) {
		ohci_rhsc(sc, sc->sc_intrxfer);
		/*
		 * Disable RHSC interrupt for now, because it will be
		 * on until the port has been reset.
		 */
		ohci_rhsc_able(sc, 0);
		DPRINTFN(2, ("%s: rhsc interrupt disabled\n",
			     sc->sc_bus.bdev.dv_xname));

		/* Do not allow RHSC interrupts > 1 per second */
                timeout_add_sec(&sc->sc_tmo_rhsc, 1);
		eintrs &= ~OHCI_RHSC;
	}

	sc->sc_bus.intr_context--;

	if (eintrs != 0) {
		/* Block unprocessed interrupts. XXX */
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, eintrs);
		sc->sc_eintrs &= ~eintrs;
		printf("%s: blocking intrs 0x%x\n",
		       sc->sc_bus.bdev.dv_xname, eintrs);
	}

	return (1);
}

void
ohci_rhsc_able(struct ohci_softc *sc, int on)
{
	DPRINTFN(4, ("ohci_rhsc_able: on=%d\n", on));
	if (on) {
		sc->sc_eintrs |= OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);
	} else {
		sc->sc_eintrs &= ~OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);
	}
}

void
ohci_rhsc_enable(void *v_sc)
{
	struct ohci_softc *sc = v_sc;
	int s;

	if (sc->sc_bus.dying)
		return;

	s = splhardusb();
	ohci_rhsc(sc, sc->sc_intrxfer);
	DPRINTFN(2, ("%s: rhsc interrupt enabled\n",
		     sc->sc_bus.bdev.dv_xname));

	ohci_rhsc_able(sc, 1);
	splx(s);
}

#ifdef OHCI_DEBUG
char *ohci_cc_strs[] = {
	"NO_ERROR",
	"CRC",
	"BIT_STUFFING",
	"DATA_TOGGLE_MISMATCH",
	"STALL",
	"DEVICE_NOT_RESPONDING",
	"PID_CHECK_FAILURE",
	"UNEXPECTED_PID",
	"DATA_OVERRUN",
	"DATA_UNDERRUN",
	"BUFFER_OVERRUN",
	"BUFFER_UNDERRUN",
	"reserved",
	"reserved",
	"NOT_ACCESSED",
	"NOT_ACCESSED",
};
#endif

void
ohci_add_done(struct ohci_softc *sc, ohci_physaddr_t done)
{
	struct ohci_soft_itd *sitd, *sidone, **ip;
	struct ohci_soft_td *std, *sdone, **p;

	/* Reverse the done list. */
	for (sdone = NULL, sidone = NULL; done != 0; ) {
		std = ohci_hash_find_td(sc, done);
		if (std != NULL) {
			std->dnext = sdone;
			done = letoh32(std->td.td_nexttd);
			sdone = std;
			DPRINTFN(10,("add TD %p\n", std));
			continue;
		}
		sitd = ohci_hash_find_itd(sc, done);
		if (sitd != NULL) {
			sitd->dnext = sidone;
			done = letoh32(sitd->itd.itd_nextitd);
			sidone = sitd;
			DPRINTFN(5,("add ITD %p\n", sitd));
			continue;
		}
		panic("ohci_add_done: addr 0x%08lx not found", (u_long)done);
	}

	/* sdone & sidone now hold the done lists. */
	/* Put them on the already processed lists. */
	for (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)
		;
	*p = sdone;
	for (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)
		;
	*ip = sidone;
}

void
ohci_softintr(void *v)
{
	struct ohci_softc *sc = v;
	struct ohci_soft_itd *sitd, *sidone, *sitdnext;
	struct ohci_soft_td *std, *sdone, *stdnext;
	struct usbd_xfer *xfer;
	struct ohci_pipe *opipe;
	int len, cc, s;
	int i, j, actlen, iframes, uedir;

	DPRINTFN(10,("ohci_softintr: enter\n"));

	if (sc->sc_bus.dying)
		return;

	sc->sc_bus.intr_context++;

	s = splhardusb();
	sdone = sc->sc_sdone;
	sc->sc_sdone = NULL;
	sidone = sc->sc_sidone;
	sc->sc_sidone = NULL;
	splx(s);

	DPRINTFN(10,("ohci_softintr: sdone=%p sidone=%p\n", sdone, sidone));

#ifdef OHCI_DEBUG
	if (ohcidebug > 10) {
		DPRINTF(("ohci_process_done: TD done:\n"));
		ohci_dump_tds(sdone);
	}
#endif

	for (std = sdone; std; std = stdnext) {
		xfer = std->xfer;
		stdnext = std->dnext;
		DPRINTFN(10, ("ohci_process_done: std=%p xfer=%p hcpriv=%p\n",
				std, xfer, xfer ? xfer->hcpriv : 0));
		if (xfer == NULL) {
			/*
			 * xfer == NULL: There seems to be no xfer associated
			 * with this TD. It is tailp that happened to end up on
			 * the done queue.
			 * Shouldn't happen, but some chips are broken(?).
			 */
			continue;
		}
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
			DPRINTF(("ohci_process_done: cancel/timeout %p\n",
				 xfer));
			/* Handled by abort routine. */
			continue;
		}
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);

		len = std->len;
		if (std->td.td_cbp != 0)
			len -= letoh32(std->td.td_be) -
			    letoh32(std->td.td_cbp) + 1;
		DPRINTFN(10, ("ohci_process_done: len=%d, flags=0x%x\n", len,
		    std->flags));
		if (std->flags & OHCI_ADD_LEN)
			xfer->actlen += len;

		cc = OHCI_TD_GET_CC(letoh32(std->td.td_flags));
		if (cc == OHCI_CC_NO_ERROR) {
			if (std->flags & OHCI_CALL_DONE) {
				xfer->status = USBD_NORMAL_COMPLETION;
				s = splusb();
				usb_transfer_complete(xfer);
				splx(s);
			}
			ohci_free_std(sc, std);
		} else {
			/*
			 * Endpoint is halted.  First unlink all the TDs
			 * belonging to the failed transfer, and then restart
			 * the endpoint.
			 */
			struct ohci_soft_td *p, *n;
			opipe = (struct ohci_pipe *)xfer->pipe;

			DPRINTFN(15,("ohci_process_done: error cc=%d (%s)\n",
			  OHCI_TD_GET_CC(letoh32(std->td.td_flags)),
			  ohci_cc_strs[OHCI_TD_GET_CC(letoh32(std->td.td_flags))]));

			/* remove TDs */
			for (p = std; p->xfer == xfer; p = n) {
				n = p->nexttd;
				ohci_free_std(sc, p);
			}

			/* clear halt */
			opipe->sed->ed.ed_headp = htole32(p->physaddr);
			OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);

			if (cc == OHCI_CC_STALL)
				xfer->status = USBD_STALLED;
			else if (cc == OHCI_CC_DATA_UNDERRUN)
				xfer->status = USBD_NORMAL_COMPLETION;
			else
				xfer->status = USBD_IOERROR;
			s = splusb();
			usb_transfer_complete(xfer);
			splx(s);
		}
	}

#ifdef OHCI_DEBUG
	if (ohcidebug > 10) {
		DPRINTF(("ohci_softintr: ITD done:\n"));
		ohci_dump_itds(sidone);
	}
#endif

	for (sitd = sidone; sitd != NULL; sitd = sitdnext) {
		xfer = sitd->xfer;
		sitdnext = sitd->dnext;
		DPRINTFN(1, ("ohci_process_done: sitd=%p xfer=%p hcpriv=%p\n",
			     sitd, xfer, xfer ? xfer->hcpriv : 0));
		if (xfer == NULL)
			continue;
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
			DPRINTF(("ohci_process_done: cancel/timeout %p\n",
				 xfer));
			/* Handled by abort routine. */
			continue;
		}
#ifdef DIAGNOSTIC
		if (sitd->isdone)
			printf("ohci_softintr: sitd=%p is done\n", sitd);
		sitd->isdone = 1;
#endif
		if (sitd->flags & OHCI_CALL_DONE) {
			struct ohci_soft_itd *next;

			opipe = (struct ohci_pipe *)xfer->pipe;
			opipe->u.iso.inuse -= xfer->nframes;
			uedir = UE_GET_DIR(xfer->pipe->endpoint->edesc->
			    bEndpointAddress);
			xfer->status = USBD_NORMAL_COMPLETION;
			actlen = 0;
			for (i = 0, sitd = xfer->hcpriv; ;
			    sitd = next) {
				next = sitd->nextitd;
				if (OHCI_ITD_GET_CC(letoh32(sitd->
				    itd.itd_flags)) != OHCI_CC_NO_ERROR)
					xfer->status = USBD_IOERROR;
				/* For input, update frlengths with actual */
				/* XXX anything necessary for output? */
				if (uedir == UE_DIR_IN &&
				    xfer->status == USBD_NORMAL_COMPLETION) {
					iframes = OHCI_ITD_GET_FC(letoh32(
					    sitd->itd.itd_flags));
					for (j = 0; j < iframes; i++, j++) {
						len = letoh16(sitd->
						    itd.itd_offset[j]);
						if ((OHCI_ITD_PSW_GET_CC(len) &
						    OHCI_CC_NOT_ACCESSED_MASK)
						    == OHCI_CC_NOT_ACCESSED)
							len = 0;
						else
							len = OHCI_ITD_PSW_LENGTH(len);
						xfer->frlengths[i] = len;
						actlen += len;
					}
				}
				if (sitd->flags & OHCI_CALL_DONE)
					break;
				ohci_free_sitd(sc, sitd);
			}
			ohci_free_sitd(sc, sitd);
			if (uedir == UE_DIR_IN &&
			    xfer->status == USBD_NORMAL_COMPLETION)
				xfer->actlen = actlen;
			xfer->hcpriv = NULL;

			s = splusb();
			usb_transfer_complete(xfer);
			splx(s);
		}
	}

	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}

	sc->sc_bus.intr_context--;
	DPRINTFN(10,("ohci_softintr: done:\n"));
}

void
ohci_device_ctrl_done(struct usbd_xfer *xfer)
{
	DPRINTFN(10,("ohci_device_ctrl_done: xfer=%p\n", xfer));

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		panic("ohci_device_ctrl_done: not a request");
	}
#endif
}

void
ohci_device_intr_done(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_soft_ed *sed = opipe->sed;
	struct ohci_soft_td *data, *tail;


	DPRINTFN(10, ("ohci_device_intr_done: xfer=%p, actlen=%d\n", xfer,
	    xfer->actlen));

	if (xfer->pipe->repeat) {
		data = opipe->tail.td;
		tail = ohci_alloc_std(sc); /* XXX should reuse TD */
		if (tail == NULL) {
			xfer->status = USBD_NOMEM;
			return;
		}
		tail->xfer = NULL;

		data->td.td_flags = htole32(
			OHCI_TD_IN | OHCI_TD_NOCC |
			OHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);
		if (xfer->flags & USBD_SHORT_XFER_OK)
			data->td.td_flags |= htole32(OHCI_TD_R);
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
		data->nexttd = tail;
		data->td.td_nexttd = htole32(tail->physaddr);
		data->td.td_be = htole32(letoh32(data->td.td_cbp) +
			xfer->length - 1);
		data->len = xfer->length;
		data->xfer = xfer;
		data->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
		xfer->hcpriv = data;
		xfer->actlen = 0;

		sed->ed.ed_tailp = htole32(tail->physaddr);
		opipe->tail.td = tail;
	}
}

void
ohci_device_bulk_done(struct usbd_xfer *xfer)
{
	DPRINTFN(10, ("ohci_device_bulk_done: xfer=%p, actlen=%d\n", xfer,
	    xfer->actlen));
}

void
ohci_rhsc(struct ohci_softc *sc, struct usbd_xfer *xfer)
{
	u_char *p;
	int i, m;
	int hstatus;

	hstatus = OREAD4(sc, OHCI_RH_STATUS);
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n",
		 sc, xfer, hstatus));

	if (xfer == NULL) {
		/* Just ignore the change. */
		return;
	}

	p = KERNADDR(&xfer->dmabuf, 0);
	m = min(sc->sc_noport, xfer->length * 8 - 1);
	memset(p, 0, xfer->length);
	for (i = 1; i <= m; i++) {
		/* Pick out CHANGE bits from the status reg. */
		if (OREAD4(sc, OHCI_RH_PORT_STATUS(i)) >> 16)
			p[i/8] |= 1 << (i%8);
	}
	DPRINTF(("ohci_rhsc: change=0x%02x\n", *p));
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	usb_transfer_complete(xfer);
}

void
ohci_root_intr_done(struct usbd_xfer *xfer)
{
}

void
ohci_root_ctrl_done(struct usbd_xfer *xfer)
{
}

void
ohci_poll(struct usbd_bus *bus)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;
#ifdef OHCI_DEBUG
	static int last;
	int new;
	new = OREAD4(sc, OHCI_INTERRUPT_STATUS);
	if (new != last) {
		DPRINTFN(10,("ohci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif

	if (OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs)
		ohci_intr1(sc);
}

usbd_status
ohci_device_request(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
	struct ohci_soft_td *setup, *stat, *next, *tail;
	struct ohci_soft_ed *sed;
	u_int len;
	usbd_status err;
	int s;

	len = UGETW(req->wLength);

	DPRINTFN(3,("ohci_device_control type=0x%02x, request=0x%02x, "
		    "wValue=0x%04x, wIndex=0x%04x len=%u, addr=%d, endpt=%d\n",
		    req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), len, xfer->device->address,
		    xfer->pipe->endpoint->edesc->bEndpointAddress));

	setup = opipe->tail.td;
	stat = ohci_alloc_std(sc);
	if (stat == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	tail = ohci_alloc_std(sc);
	if (tail == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}
	tail->xfer = NULL;

	sed = opipe->sed;

	next = stat;

	/* Set up data transaction */
	if (len != 0) {
		struct ohci_soft_td *std = stat;

		err = ohci_alloc_std_chain(sc, len, xfer, std, &stat);
		stat = stat->nexttd; /* point at free TD */
		if (err)
			goto bad3;
		/* Start toggle at 1 and then use the carried toggle. */
		std->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);
		std->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);
	}

	memcpy(KERNADDR(&opipe->u.ctl.reqdma, 0), req, sizeof *req);

	setup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |
				     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma, 0));
	setup->nexttd = next;
	setup->td.td_nexttd = htole32(next->physaddr);
	setup->td.td_be = htole32(letoh32(setup->td.td_cbp) + sizeof *req - 1);
	setup->len = 0;
	setup->xfer = xfer;
	setup->flags = 0;
	xfer->hcpriv = setup;

	stat->td.td_flags = htole32(
		(usbd_xfer_isread(xfer) ? OHCI_TD_OUT : OHCI_TD_IN) |
		OHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));
	stat->td.td_cbp = 0;
	stat->nexttd = tail;
	stat->td.td_nexttd = htole32(tail->physaddr);
	stat->td.td_be = 0;
	stat->flags = OHCI_CALL_DONE;
	stat->len = 0;
	stat->xfer = xfer;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_request:\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(setup);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_CLF);
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                timeout_del(&xfer->timeout_handle);
                timeout_set(&xfer->timeout_handle, ohci_timeout, xfer);
                timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	splx(s);

#ifdef OHCI_DEBUG
	if (ohcidebug > 20) {
		delay(10000);
		DPRINTF(("ohci_device_request: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dumpregs(sc);
		printf("ctrl head:\n");
		ohci_dump_ed(sc->sc_ctrl_head);
		printf("sed:\n");
		ohci_dump_ed(sed);
		ohci_dump_tds(setup);
	}
#endif

	return (USBD_NORMAL_COMPLETION);

 bad3:
	ohci_free_std(sc, tail);
 bad2:
	ohci_free_std(sc, stat);
 bad1:
	return (err);
}

/*
 * Add an ED to the schedule.  Called at splusb().
 */
void
ohci_add_ed(struct ohci_soft_ed *sed, struct ohci_soft_ed *head)
{
	DPRINTFN(8,("ohci_add_ed: sed=%p head=%p\n", sed, head));

	splsoftassert(IPL_SOFTUSB);
	sed->next = head->next;
	sed->ed.ed_nexted = head->ed.ed_nexted;
	head->next = sed;
	head->ed.ed_nexted = htole32(sed->physaddr);
}

/*
 * Remove an ED from the schedule.  Called at splusb().
 */
void
ohci_rem_ed(struct ohci_soft_ed *sed, struct ohci_soft_ed *head)
{
	struct ohci_soft_ed *p;

	splsoftassert(IPL_SOFTUSB);

	/* XXX */
	for (p = head; p != NULL && p->next != sed; p = p->next)
		;
	if (p == NULL)
		panic("ohci_rem_ed: ED not found");
	p->next = sed->next;
	p->ed.ed_nexted = sed->ed.ed_nexted;
}

/*
 * When a transfer is completed the TD is added to the done queue by
 * the host controller.  This queue is the processed by software.
 * Unfortunately the queue contains the physical address of the TD
 * and we have no simple way to translate this back to a kernel address.
 * To make the translation possible (and fast) we use a hash table of
 * TDs currently in the schedule.  The physical address is used as the
 * hash value.
 */

#define HASH(a) (((a) >> 4) % OHCI_HASH_SIZE)
/* Called at splusb() */
void
ohci_hash_add_td(struct ohci_softc *sc, struct ohci_soft_td *std)
{
	int h = HASH(std->physaddr);

	splsoftassert(IPL_SOFTUSB);

	LIST_INSERT_HEAD(&sc->sc_hash_tds[h], std, hnext);
}

struct ohci_soft_td *
ohci_hash_find_td(struct ohci_softc *sc, ohci_physaddr_t a)
{
	int h = HASH(a);
	struct ohci_soft_td *std;

	for (std = LIST_FIRST(&sc->sc_hash_tds[h]);
	     std != NULL;
	     std = LIST_NEXT(std, hnext))
		if (std->physaddr == a)
			return (std);
	return (NULL);
}

/* Called at splusb() */
void
ohci_hash_add_itd(struct ohci_softc *sc, struct ohci_soft_itd *sitd)
{
	int h = HASH(sitd->physaddr);

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n",
		    sitd, (u_long)sitd->physaddr));

	LIST_INSERT_HEAD(&sc->sc_hash_itds[h], sitd, hnext);
}

/* Called at splusb() */
void
ohci_hash_rem_itd(struct ohci_softc *sc, struct ohci_soft_itd *sitd)
{
	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n",
		    sitd, (u_long)sitd->physaddr));

	LIST_REMOVE(sitd, hnext);
}

struct ohci_soft_itd *
ohci_hash_find_itd(struct ohci_softc *sc, ohci_physaddr_t a)
{
	int h = HASH(a);
	struct ohci_soft_itd *sitd;

	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]);
	     sitd != NULL;
	     sitd = LIST_NEXT(sitd, hnext))
		if (sitd->physaddr == a)
			return (sitd);
	return (NULL);
}

void
ohci_timeout(void *addr)
{
	struct usbd_xfer *xfer = addr;
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying) {
		ohci_timeout_task(addr);
		return;
	}

	usb_init_task(&xfer->abort_task, ohci_timeout_task, addr,
	    USB_TASK_TYPE_ABORT);
	usb_add_task(xfer->device, &xfer->abort_task);
}

void
ohci_timeout_task(void *addr)
{
	struct usbd_xfer *xfer = addr;
	int s;

	DPRINTF(("%s: xfer=%p\n", __func__, xfer));

	s = splusb();
	ohci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

#ifdef OHCI_DEBUG
void
ohci_dump_tds(struct ohci_soft_td *std)
{
	for (; std; std = std->nexttd)
		ohci_dump_td(std);
}

void
ohci_dump_td(struct ohci_soft_td *std)
{
	char sbuf[128];

	bitmask_snprintf((u_int32_t)letoh32(std->td.td_flags),
			 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
			 sbuf, sizeof(sbuf));

	printf("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
	       "nexttd=0x%08lx be=0x%08lx\n",
	       std, (u_long)std->physaddr, sbuf,
	       OHCI_TD_GET_DI(letoh32(std->td.td_flags)),
	       OHCI_TD_GET_EC(letoh32(std->td.td_flags)),
	       OHCI_TD_GET_CC(letoh32(std->td.td_flags)),
	       (u_long)letoh32(std->td.td_cbp),
	       (u_long)letoh32(std->td.td_nexttd),
	       (u_long)letoh32(std->td.td_be));
}

void
ohci_dump_itd(struct ohci_soft_itd *sitd)
{
	int i;

	printf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
	       "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
	       sitd, (u_long)sitd->physaddr,
	       OHCI_ITD_GET_SF(letoh32(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_DI(letoh32(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_FC(letoh32(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_CC(letoh32(sitd->itd.itd_flags)),
	       (u_long)letoh32(sitd->itd.itd_bp0),
	       (u_long)letoh32(sitd->itd.itd_nextitd),
	       (u_long)letoh32(sitd->itd.itd_be));
	for (i = 0; i < OHCI_ITD_NOFFSET; i++)
		printf("offs[%d]=0x%04x ", i,
		       (u_int)letoh16(sitd->itd.itd_offset[i]));
	printf("\n");
}

void
ohci_dump_itds(struct ohci_soft_itd *sitd)
{
	for (; sitd; sitd = sitd->nextitd)
		ohci_dump_itd(sitd);
}

void
ohci_dump_ed(struct ohci_soft_ed *sed)
{
	char sbuf[128], sbuf2[128];

	bitmask_snprintf((u_int32_t)letoh32(sed->ed.ed_flags),
			 "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
			 sbuf, sizeof(sbuf));
	bitmask_snprintf((u_int32_t)letoh32(sed->ed.ed_headp),
			 "\20\1HALT\2CARRY", sbuf2, sizeof(sbuf2));

	printf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\n"
	       "tailp=0x%08lx headflags=%s headp=0x%08lx nexted=0x%08lx\n",
	       sed, (u_long)sed->physaddr,
	       OHCI_ED_GET_FA(letoh32(sed->ed.ed_flags)),
	       OHCI_ED_GET_EN(letoh32(sed->ed.ed_flags)),
	       OHCI_ED_GET_MAXP(letoh32(sed->ed.ed_flags)), sbuf,
	       (u_long)letoh32(sed->ed.ed_tailp), sbuf2,
	       (u_long)letoh32(sed->ed.ed_headp),
	       (u_long)letoh32(sed->ed.ed_nexted));
}
#endif

usbd_status
ohci_open(struct usbd_pipe *pipe)
{
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct ohci_soft_ed *sed = NULL;
	struct ohci_soft_td *std = NULL;
	struct ohci_soft_itd *sitd;
	ohci_physaddr_t tdphys;
	u_int32_t fmt;
	usbd_status err;
	int s;
	int ival;

	DPRINTFN(1, ("ohci_open: pipe=%p, addr=%d, endpt=%d\n",
		     pipe, pipe->device->address, ed->bEndpointAddress));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	/* Root Hub */
	if (pipe->device->depth == 0) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &ohci_root_ctrl_methods;
			break;
		case UE_DIR_IN | OHCI_INTR_ENDPT:
			pipe->methods = &ohci_root_intr_methods;
			break;
		default:
			return (USBD_INVAL);
		}
	} else {
		sed = ohci_alloc_sed(sc);
		if (sed == NULL)
			goto bad0;
		opipe->sed = sed;
		if (xfertype == UE_ISOCHRONOUS) {
			sitd = ohci_alloc_sitd(sc);
			if (sitd == NULL)
				goto bad1;
			opipe->tail.itd = sitd;
			tdphys = sitd->physaddr;
			fmt = OHCI_ED_FORMAT_ISO;
			if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
				fmt |= OHCI_ED_DIR_IN;
			else
				fmt |= OHCI_ED_DIR_OUT;
		} else {
			std = ohci_alloc_std(sc);
			if (std == NULL)
				goto bad1;
			opipe->tail.td = std;
			tdphys = std->physaddr;
			fmt = OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD;
		}
		sed->ed.ed_flags = htole32(
			OHCI_ED_SET_FA(pipe->device->address) |
			OHCI_ED_SET_EN(UE_GET_ADDR(ed->bEndpointAddress)) |
			(pipe->device->speed == USB_SPEED_LOW ?
			     OHCI_ED_SPEED : 0) |
			fmt | OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
		sed->ed.ed_headp = htole32(tdphys |
		    (pipe->endpoint->savedtoggle ? OHCI_TOGGLECARRY : 0));
		sed->ed.ed_tailp = htole32(tdphys);

		switch (xfertype) {
		case UE_CONTROL:
			pipe->methods = &ohci_device_ctrl_methods;
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
				  0, &opipe->u.ctl.reqdma);
			if (err)
				goto bad;
			s = splusb();
			ohci_add_ed(sed, sc->sc_ctrl_head);
			splx(s);
			break;
		case UE_INTERRUPT:
			pipe->methods = &ohci_device_intr_methods;
			ival = pipe->interval;
			if (ival == USBD_DEFAULT_INTERVAL)
				ival = ed->bInterval;
			return (ohci_device_setintr(sc, opipe, ival));
		case UE_ISOCHRONOUS:
			pipe->methods = &ohci_device_isoc_methods;
			return (ohci_setup_isoc(pipe));
		case UE_BULK:
			pipe->methods = &ohci_device_bulk_methods;
			s = splusb();
			ohci_add_ed(sed, sc->sc_bulk_head);
			splx(s);
			break;
		}
	}
	return (USBD_NORMAL_COMPLETION);

 bad:
	if (std != NULL)
		ohci_free_std(sc, std);
 bad1:
	if (sed != NULL)
		ohci_free_sed(sc, sed);
 bad0:
	return (USBD_NOMEM);

}

/*
 * Work around the half configured control (default) pipe when setting
 * the address of a device.
 *
 * Because a single ED is setup per endpoint in ohci_open(), and the
 * control pipe is configured before we could have set the address
 * of the device or read the wMaxPacketSize of the endpoint, we have
 * to re-open the pipe twice here.
 */
int
ohci_setaddr(struct usbd_device *dev, int addr)
{
	/* Root Hub */
	if (dev->depth == 0)
		return (0);

	/* Re-establish the default pipe with the new max packet size. */
	ohci_device_ctrl_close(dev->default_pipe);
	if (ohci_open(dev->default_pipe))
		return (EINVAL);

	if (usbd_set_address(dev, addr))
		return (1);

	dev->address = addr;

	/* Re-establish the default pipe with the new address. */
	ohci_device_ctrl_close(dev->default_pipe);
	if (ohci_open(dev->default_pipe))
		return (EINVAL);

	return (0);
}

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
void
ohci_close_pipe(struct usbd_pipe *pipe, struct ohci_soft_ed *head)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;
	struct ohci_soft_ed *sed = opipe->sed;
	int s;

	s = splusb();
#ifdef DIAGNOSTIC
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
	if ((letoh32(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (letoh32(sed->ed.ed_headp) & OHCI_HEADMASK)) {
		struct ohci_soft_td *std;
		std = ohci_hash_find_td(sc, letoh32(sed->ed.ed_headp));
		printf("ohci_close_pipe: pipe not empty sed=%p hd=0x%x "
		       "tl=0x%x pipe=%p, std=%p\n", sed,
		       (int)letoh32(sed->ed.ed_headp),
		       (int)letoh32(sed->ed.ed_tailp),
		       pipe, std);
#ifdef USB_DEBUG
		usbd_dump_pipe(pipe);
#endif
#ifdef OHCI_DEBUG
		ohci_dump_ed(sed);
		if (std)
			ohci_dump_td(std);
#endif
		usb_delay_ms(&sc->sc_bus, 2);
		if ((letoh32(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
		    (letoh32(sed->ed.ed_headp) & OHCI_HEADMASK))
			printf("ohci_close_pipe: pipe still not empty\n");
	}
#endif
	ohci_rem_ed(sed, head);
	/* Make sure the host controller is not touching this ED */
	usb_delay_ms(&sc->sc_bus, 1);
	splx(s);
	pipe->endpoint->savedtoggle =
	    (letoh32(sed->ed.ed_headp) & OHCI_TOGGLECARRY) ? 1 : 0;
	ohci_free_sed(sc, opipe->sed);
}

/*
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
 */
void
ohci_abort_xfer(struct usbd_xfer *xfer, usbd_status status)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_soft_ed *sed = opipe->sed;
	struct ohci_soft_td *p, *n;
	ohci_physaddr_t headp;
	int s, hit;

	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p sed=%p\n", xfer, opipe,
		 sed));

	if (sc->sc_bus.dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}

	if (xfer->device->bus->intr_context || !curproc)
		panic("ohci_abort_xfer: not in process context");

	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);
	splx(s);
	DPRINTFN(1,("ohci_abort_xfer: stop ed=%p\n", sed));
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */

	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(xfer->device->bus, 20); /* Hardware finishes in 1ms */
	s = splusb();
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	tsleep(&sc->sc_softwake, PZERO, "ohciab", 0);
	splx(s);

	/*
	 * Step 3: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
	 */
	s = splusb();		/* XXX why? */
	p = xfer->hcpriv;
#ifdef DIAGNOSTIC
	if (p == NULL) {
		splx(s);
		printf("ohci_abort_xfer: hcpriv is NULL\n");
		return;
	}
#endif
#ifdef OHCI_DEBUG
	if (ohcidebug > 1) {
		DPRINTF(("ohci_abort_xfer: sed=\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(p);
	}
#endif
	headp = letoh32(sed->ed.ed_headp) & OHCI_HEADMASK;
	hit = 0;
	for (; p->xfer == xfer; p = n) {
		hit |= headp == p->physaddr;
		n = p->nexttd;
		if (OHCI_TD_GET_CC(letoh32(p->td.td_flags)) ==
		    OHCI_CC_NOT_ACCESSED)
			ohci_free_std(sc, p);
	}
	/* Zap headp register if hardware pointed inside the xfer. */
	if (hit) {
		DPRINTFN(1,("ohci_abort_xfer: set hd=0x%08x, tl=0x%08x\n",
			    (int)p->physaddr, (int)letoh32(sed->ed.ed_tailp)));
		sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
	} else {
		DPRINTFN(1,("ohci_abort_xfer: no hit\n"));
	}

	/*
	 * Step 4: Turn on hardware again.
	 */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */

	/*
	 * Step 5: Execute callback.
	 */
	usb_transfer_complete(xfer);

	splx(s);
}

/*
 * Data structures and routines to emulate the root hub.
 */
usb_device_descriptor_t ohci_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x01},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indices */
	1			/* # of configurations */
};

usb_config_descriptor_t ohci_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_SELF_POWERED,
	0			/* max power */
};

usb_interface_descriptor_t ohci_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_FSHUB,
	0
};

usb_endpoint_descriptor_t ohci_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | OHCI_INTR_ENDPT,
	UE_INTERRUPT,
	{8, 0},			/* max packet */
	255
};

usb_hub_descriptor_t ohci_hubd = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	0,
	{0,0},
	0,
	0,
	{0},
};

/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
usbd_status
ohci_root_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ohci_root_ctrl_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port, i;
	int s, len, value, index, l, totlen = 0;
	usb_port_status_t ps;
	usb_hub_descriptor_t hubd;
	usbd_status err;
	u_int32_t v;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		/* XXX panic */
		return (USBD_INVAL);
#endif
	req = &xfer->request;

	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(8,("ohci_root_ctrl_control wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			USETW(ohci_devd.idVendor, sc->sc_id_vendor);
			memcpy(buf, &ohci_devd, l);
			break;
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
			memcpy(buf, &ohci_confd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &ohci_ifcd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &ohci_endpd, l);
			break;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
			case 0: /* Language table */
				totlen = usbd_str(buf, len, "\001");
				break;
			case 1: /* Vendor */
				totlen = usbd_str(buf, len, sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = usbd_str(buf, len, "OHCI root hub");
				break;
			}
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
		DPRINTFN(8, ("ohci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
			     "port=%d feature=%d\n",
			     index, value));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = OHCI_RH_PORT_STATUS(index);
		switch(value) {
		case UHF_PORT_ENABLE:
			OWRITE4(sc, port, UPS_CURRENT_CONNECT_STATUS);
			break;
		case UHF_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_OVERCURRENT_INDICATOR);
			break;
		case UHF_PORT_POWER:
			/* Yes, writing to the LOW_SPEED bit clears power. */
			OWRITE4(sc, port, UPS_LOW_SPEED);
			break;
		case UHF_C_PORT_CONNECTION:
			OWRITE4(sc, port, UPS_C_CONNECT_STATUS << 16);
			break;
		case UHF_C_PORT_ENABLE:
			OWRITE4(sc, port, UPS_C_PORT_ENABLED << 16);
			break;
		case UHF_C_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_C_SUSPEND << 16);
			break;
		case UHF_C_PORT_OVER_CURRENT:
			OWRITE4(sc, port, UPS_C_OVERCURRENT_INDICATOR << 16);
			break;
		case UHF_C_PORT_RESET:
			OWRITE4(sc, port, UPS_C_PORT_RESET << 16);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		switch(value) {
		case UHF_C_PORT_CONNECTION:
		case UHF_C_PORT_ENABLE:
		case UHF_C_PORT_SUSPEND:
		case UHF_C_PORT_OVER_CURRENT:
		case UHF_C_PORT_RESET:
			/* Enable RHSC interrupt if condition is cleared. */
			if ((OREAD4(sc, port) >> 16) == 0)
				ohci_rhsc_able(sc, 1);
			break;
		default:
			break;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
		if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
		hubd = ohci_hubd;
		hubd.bNbrPorts = sc->sc_noport;
		USETW(hubd.wHubCharacteristics,
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
		       v & OHCI_PSM ? UHD_PWR_GANGED : UHD_PWR_INDIVIDUAL)
		      /* XXX overcurrent */
		      );
		hubd.bPwrOn2PwrGood = OHCI_GET_POTPGT(v);
		v = OREAD4(sc, OHCI_RH_DESCRIPTOR_B);
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
			hubd.DeviceRemovable[i++] = (u_int8_t)v;
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
		l = min(len, hubd.bDescLength);
		totlen = l;
		memcpy(buf, &hubd, l);
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len); /* ? XXX */
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
		DPRINTFN(8,("ohci_root_ctrl_transfer: get port status i=%d\n",
			    index));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = OREAD4(sc, OHCI_RH_PORT_STATUS(index));
		DPRINTFN(8,("ohci_root_ctrl_transfer: port status=0x%04x\n",
			    v));
		USETW(ps.wPortStatus, v);
		USETW(ps.wPortChange, v >> 16);
		l = min(len, sizeof ps);
		memcpy(buf, &ps, l);
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = OHCI_RH_PORT_STATUS(index);
		switch(value) {
		case UHF_PORT_ENABLE:
			OWRITE4(sc, port, UPS_PORT_ENABLED);
			break;
		case UHF_PORT_SUSPEND:
			OWRITE4(sc, port, UPS_SUSPEND);
			break;
		case UHF_PORT_RESET:
			DPRINTFN(5,("ohci_root_ctrl_transfer: reset port %d\n",
				    index));
			OWRITE4(sc, port, UPS_RESET);
			for (i = 0; i < 5; i++) {
				usb_delay_ms(&sc->sc_bus,
					     USB_PORT_ROOT_RESET_DELAY);
				if (sc->sc_bus.dying) {
					err = USBD_IOERROR;
					goto ret;
				}
				if ((OREAD4(sc, port) & UPS_RESET) == 0)
					break;
			}
			DPRINTFN(8,("ohci port %d reset, status = 0x%04x\n",
				    index, OREAD4(sc, port)));
			break;
		case UHF_PORT_POWER:
			DPRINTFN(2,("ohci_root_ctrl_transfer: set port power "
				    "%d\n", index));
			OWRITE4(sc, port, UPS_PORT_POWER);
			break;
		case UHF_PORT_DISOWN_TO_1_1:
			/* accept, but do nothing */
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (err);
}

/* Abort a root control request. */
void
ohci_root_ctrl_abort(struct usbd_xfer *xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}

/* Close the root pipe. */
void
ohci_root_ctrl_close(struct usbd_pipe *pipe)
{
	DPRINTF(("ohci_root_ctrl_close\n"));
	/* Nothing to do. */
}

usbd_status
ohci_root_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ohci_root_intr_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;

	return (USBD_IN_PROGRESS);
}

void
ohci_root_intr_abort(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	int s;

	sc->sc_intrxfer = NULL;

	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

void
ohci_root_intr_close(struct usbd_pipe *pipe)
{
}

usbd_status
ohci_device_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ohci_device_ctrl_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	usbd_status err;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		/* XXX panic */
		printf("ohci_device_ctrl_transfer: not a request\n");
		return (USBD_INVAL);
	}
#endif

	err = ohci_device_request(xfer);
	if (err)
		return (err);

	return (USBD_IN_PROGRESS);
}

/* Abort a device control request. */
void
ohci_device_ctrl_abort(struct usbd_xfer *xfer)
{
	DPRINTF(("ohci_device_ctrl_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device control pipe. */
void
ohci_device_ctrl_close(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;

	DPRINTF(("ohci_device_ctrl_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_ctrl_head);
	ohci_free_std(sc, opipe->tail.td);
}

/************************/

void
ohci_device_clear_toggle(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;

	opipe->sed->ed.ed_headp &= htole32(~OHCI_TOGGLECARRY);
}

usbd_status
ohci_device_bulk_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ohci_device_bulk_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_soft_td *data, *tail, *tdp;
	struct ohci_soft_ed *sed;
	u_int len;
	int s, endpt;
	usbd_status err;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST) {
		/* XXX panic */
		printf("ohci_device_bulk_start: a request\n");
		return (USBD_INVAL);
	}
#endif

	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	sed = opipe->sed;

	DPRINTFN(4,("ohci_device_bulk_start: xfer=%p len=%u "
		    "flags=%d endpt=%d\n", xfer, len, xfer->flags, endpt));

	/* Update device address */
	sed->ed.ed_flags = htole32(
		(letoh32(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |
		OHCI_ED_SET_FA(xfer->device->address));

	/* Allocate a chain of new TDs (including a new tail). */
	data = opipe->tail.td;
	err = ohci_alloc_std_chain(sc, len, xfer, data, &tail);
	/* We want interrupt at the end of the transfer. */
	tail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);
	tail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));
	tail->flags |= OHCI_CALL_DONE;
	tail = tail->nexttd;	/* point at sentinel */
	if (err)
		return (err);

	tail->xfer = NULL;
	xfer->hcpriv = data;

	DPRINTFN(4,("ohci_device_bulk_start: ed_flags=0x%08x td_flags=0x%08x "
		    "td_cbp=0x%08x td_be=0x%08x\n",
		    (int)letoh32(sed->ed.ed_flags),
		    (int)letoh32(data->td.td_flags),
		    (int)letoh32(data->td.td_cbp),
		    (int)letoh32(data->td.td_be)));

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	for (tdp = data; tdp != tail; tdp = tdp->nexttd) {
		tdp->xfer = xfer;
	}
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
	OWRITE4(sc, OHCI_COMMAND_STATUS, OHCI_BLF);
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                timeout_del(&xfer->timeout_handle);
                timeout_set(&xfer->timeout_handle, ohci_timeout, xfer);
                timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}

#if 0
/* This goes wrong if we are too slow. */
	if (ohcidebug > 10) {
		delay(10000);
		DPRINTF(("ohci_device_intr_transfer: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	splx(s);

	return (USBD_IN_PROGRESS);
}

void
ohci_device_bulk_abort(struct usbd_xfer *xfer)
{
	DPRINTF(("ohci_device_bulk_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
}

/*
 * Close a device bulk pipe.
 */
void
ohci_device_bulk_close(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;

	DPRINTF(("ohci_device_bulk_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_bulk_head);
	ohci_free_std(sc, opipe->tail.td);
}

/************************/

usbd_status
ohci_device_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ohci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ohci_device_intr_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_soft_ed *sed = opipe->sed;
	struct ohci_soft_td *data, *tail;
	int s, len, endpt;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	DPRINTFN(3, ("ohci_device_intr_transfer: xfer=%p len=%u "
		     "flags=%d priv=%p\n",
		     xfer, xfer->length, xfer->flags, xfer->priv));

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ohci_device_intr_transfer: a request");
#endif

	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;

	data = opipe->tail.td;
	tail = ohci_alloc_std(sc);
	if (tail == NULL)
		return (USBD_NOMEM);
	tail->xfer = NULL;

	data->td.td_flags = htole32(
		(usbd_xfer_isread(xfer) ? OHCI_TD_IN : OHCI_TD_OUT) |
		OHCI_TD_NOCC |
		OHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY);
	if (xfer->flags & USBD_SHORT_XFER_OK)
		data->td.td_flags |= htole32(OHCI_TD_R);
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
	data->nexttd = tail;
	data->td.td_nexttd = htole32(tail->physaddr);
	data->td.td_be = htole32(letoh32(data->td.td_cbp) + len - 1);
	data->len = len;
	data->xfer = xfer;
	data->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
	xfer->hcpriv = data;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_intr_transfer:\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif

	/* Insert ED in schedule */
	s = splusb();
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);

#if 0
/*
 * This goes horribly wrong, printing thousands of descriptors,
 * because false references are followed due to the fact that the
 * TD is gone.
 */
	if (ohcidebug > 5) {
		usb_delay_ms(&sc->sc_bus, 5);
		DPRINTF(("ohci_device_intr_transfer: status=%x\n",
			 OREAD4(sc, OHCI_COMMAND_STATUS)));
		ohci_dump_ed(sed);
		ohci_dump_tds(data);
	}
#endif
	splx(s);

	return (USBD_IN_PROGRESS);
}

void
ohci_device_intr_abort(struct usbd_xfer *xfer)
{
	KASSERT(!xfer->pipe->repeat || xfer->pipe->intrxfer == xfer);

	ohci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device interrupt pipe. */
void
ohci_device_intr_close(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;
	int nslots = opipe->u.intr.nslots;
	int pos = opipe->u.intr.pos;
	int j;
	struct ohci_soft_ed *p, *sed = opipe->sed;
	int s;

	DPRINTFN(1,("ohci_device_intr_close: pipe=%p nslots=%d pos=%d\n",
		    pipe, nslots, pos));
	s = splusb();
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
	if ((letoh32(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (letoh32(sed->ed.ed_headp) & OHCI_HEADMASK))
		usb_delay_ms(&sc->sc_bus, 2);

	for (p = sc->sc_eds[pos]; p && p->next != sed; p = p->next)
		;
#ifdef DIAGNOSTIC
	if (p == NULL)
		panic("ohci_device_intr_close: ED not found");
#endif
	p->next = sed->next;
	p->ed.ed_nexted = sed->ed.ed_nexted;
	splx(s);

	for (j = 0; j < nslots; j++)
		--sc->sc_bws[(pos * nslots + j) % OHCI_NO_INTRS];

	ohci_free_std(sc, opipe->tail.td);
	ohci_free_sed(sc, opipe->sed);
}

usbd_status
ohci_device_setintr(struct ohci_softc *sc, struct ohci_pipe *opipe, int ival)
{
	int i, j, s, best;
	u_int npoll, slow, shigh, nslots;
	u_int bestbw, bw;
	struct ohci_soft_ed *hsed, *sed = opipe->sed;

	DPRINTFN(2, ("ohci_setintr: pipe=%p\n", opipe));
	if (ival == 0) {
		printf("ohci_setintr: 0 interval\n");
		return (USBD_INVAL);
	}

	npoll = OHCI_NO_INTRS;
	while (npoll > ival)
		npoll /= 2;
	DPRINTFN(2, ("ohci_setintr: ival=%d npoll=%d\n", ival, npoll));

	/*
	 * We now know which level in the tree the ED must go into.
	 * Figure out which slot has most bandwidth left over.
	 * Slots to examine:
	 * npoll
	 * 1	0
	 * 2	1 2
	 * 4	3 4 5 6
	 * 8	7 8 9 10 11 12 13 14
	 * N    (N-1) .. (N-1+N-1)
	 */
	slow = npoll-1;
	shigh = slow + npoll;
	nslots = OHCI_NO_INTRS / npoll;
	for (best = i = slow, bestbw = ~0; i < shigh; i++) {
		bw = 0;
		for (j = 0; j < nslots; j++)
			bw += sc->sc_bws[(i * nslots + j) % OHCI_NO_INTRS];
		if (bw < bestbw) {
			best = i;
			bestbw = bw;
		}
	}
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n",
		     best, slow, shigh, bestbw));

	s = splusb();
	hsed = sc->sc_eds[best];
	sed->next = hsed->next;
	sed->ed.ed_nexted = hsed->ed.ed_nexted;
	hsed->next = sed;
	hsed->ed.ed_nexted = htole32(sed->physaddr);
	splx(s);

	for (j = 0; j < nslots; j++)
		++sc->sc_bws[(best * nslots + j) % OHCI_NO_INTRS];
	opipe->u.intr.nslots = nslots;
	opipe->u.intr.pos = best;

	DPRINTFN(5, ("ohci_setintr: returns %p\n", opipe));
	return (USBD_NORMAL_COMPLETION);
}

/***********************/

usbd_status
ohci_device_isoc_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTFN(5,("ohci_device_isoc_transfer: xfer=%p\n", xfer));

	/* Put it on our queue, */
	err = usb_insert_transfer(xfer);

	/* bail out on error, */
	if (err && err != USBD_IN_PROGRESS)
		return (err);

	/* XXX should check inuse here */

	/* insert into schedule, */
	ohci_device_isoc_enter(xfer);

	/* and start if the pipe wasn't running */
	if (!err)
		ohci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));

	return (err);
}

void
ohci_device_isoc_enter(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_soft_ed *sed = opipe->sed;
	struct iso *iso = &opipe->u.iso;
	struct ohci_soft_itd *sitd, *nsitd;
	ohci_physaddr_t buf, offs, noffs, bp0;
	int i, ncur, nframes;
	int s;

	DPRINTFN(1,("ohci_device_isoc_enter: used=%d next=%d xfer=%p "
		    "nframes=%d\n",
		    iso->inuse, iso->next, xfer, xfer->nframes));

	if (sc->sc_bus.dying)
		return;

	if (iso->next == -1) {
		/* Not in use yet, schedule it a few frames ahead. */
		iso->next = letoh32(sc->sc_hcca->hcca_frame_number) + 5;
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
			    iso->next));
	}

	sitd = opipe->tail.itd;
	buf = DMAADDR(&xfer->dmabuf, 0);
	bp0 = OHCI_PAGE(buf);
	offs = OHCI_PAGE_OFFSET(buf);
	nframes = xfer->nframes;
	xfer->hcpriv = sitd;
	for (i = ncur = 0; i < nframes; i++, ncur++) {
		noffs = offs + xfer->frlengths[i];
		if (ncur == OHCI_ITD_NOFFSET ||	/* all offsets used */
		    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */

			/* Allocate next ITD */
			nsitd = ohci_alloc_sitd(sc);
			if (nsitd == NULL) {
				/* XXX what now? */
				printf("%s: isoc TD alloc failed\n",
				       sc->sc_bus.bdev.dv_xname);
				return;
			}

			/* Fill current ITD */
			sitd->itd.itd_flags = htole32(
				OHCI_ITD_NOCC |
				OHCI_ITD_SET_SF(iso->next) |
				OHCI_ITD_SET_DI(6) | /* delay intr a little */
				OHCI_ITD_SET_FC(ncur));
			sitd->itd.itd_bp0 = htole32(bp0);
			sitd->nextitd = nsitd;
			sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
			sitd->itd.itd_be = htole32(bp0 + offs - 1);
			sitd->xfer = xfer;
			sitd->flags = 0;

			sitd = nsitd;
			iso->next = iso->next + ncur;
			bp0 = OHCI_PAGE(buf + offs);
			ncur = 0;
		}
		sitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));
		offs = noffs;
	}
	nsitd = ohci_alloc_sitd(sc);
	if (nsitd == NULL) {
		/* XXX what now? */
		printf("%s: isoc TD alloc failed\n",
		       sc->sc_bus.bdev.dv_xname);
		return;
	}
	/* Fixup last used ITD */
	sitd->itd.itd_flags = htole32(
		OHCI_ITD_NOCC |
		OHCI_ITD_SET_SF(iso->next) |
		OHCI_ITD_SET_DI(0) |
		OHCI_ITD_SET_FC(ncur));
	sitd->itd.itd_bp0 = htole32(bp0);
	sitd->nextitd = nsitd;
	sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
	sitd->itd.itd_be = htole32(bp0 + offs - 1);
	sitd->xfer = xfer;
	sitd->flags = OHCI_CALL_DONE;

	iso->next = iso->next + ncur;
	iso->inuse += nframes;

	xfer->actlen = offs;	/* XXX pretend we did it all */

	xfer->status = USBD_IN_PROGRESS;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_isoc_enter: frame=%d\n",
			 letoh32(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif

	s = splusb();
	sed->ed.ed_tailp = htole32(nsitd->physaddr);
	opipe->tail.itd = nsitd;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
	splx(s);

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		delay(150000);
		DPRINTF(("ohci_device_isoc_enter: after frame=%d\n",
			 letoh32(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif
}

usbd_status
ohci_device_isoc_start(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;

	DPRINTFN(5,("ohci_device_isoc_start: xfer=%p\n", xfer));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->status != USBD_IN_PROGRESS)
		printf("ohci_device_isoc_start: not in progress %p\n", xfer);
#endif

	return (USBD_IN_PROGRESS);
}

void
ohci_device_isoc_abort(struct usbd_xfer *xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_soft_ed *sed;
	struct ohci_soft_itd *sitd;
	int s;

	s = splusb();

	DPRINTFN(1,("ohci_device_isoc_abort: xfer=%p\n", xfer));

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED &&
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
		printf("ohci_device_isoc_abort: early return\n");
		return;
	}

	/* Give xfer the requested abort code. */
	xfer->status = USBD_CANCELLED;

	sed = opipe->sed;
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */

	sitd = xfer->hcpriv;
#ifdef DIAGNOSTIC
	if (sitd == NULL) {
		splx(s);
		printf("ohci_device_isoc_abort: hcpriv==0\n");
		return;
	}
#endif
	for (; sitd->xfer == xfer; sitd = sitd->nextitd) {
#ifdef DIAGNOSTIC
		DPRINTFN(1,("abort sets done sitd=%p\n", sitd));
		sitd->isdone = 1;
#endif
	}

	splx(s);

	usb_delay_ms(&sc->sc_bus, OHCI_ITD_NOFFSET);

	s = splusb();

	/* Run callback. */
	usb_transfer_complete(xfer);

	sed->ed.ed_headp = htole32(sitd->physaddr); /* unlink TDs */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */

	splx(s);
}

void
ohci_device_isoc_done(struct usbd_xfer *xfer)
{
	DPRINTFN(1,("ohci_device_isoc_done: xfer=%p\n", xfer));
}

usbd_status
ohci_setup_isoc(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;
	struct iso *iso = &opipe->u.iso;
	int s;

	iso->next = -1;
	iso->inuse = 0;

	s = splusb();
	ohci_add_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);

	return (USBD_NORMAL_COMPLETION);
}

void
ohci_device_isoc_close(struct usbd_pipe *pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;

	DPRINTF(("ohci_device_isoc_close: pipe=%p\n", pipe));
	ohci_close_pipe(pipe, sc->sc_isoc_head);
#ifdef DIAGNOSTIC
	opipe->tail.itd->isdone = 1;
#endif
	ohci_free_sitd(sc, opipe->tail.itd);
}
@


1.151
log
@Prepare ohci_intr1() for IPL_MPSAFE.

Stop manipulating the done list and root hub port status in the interrupt
handler.

Some parts lifted from NetBSD's r1.157 but with functionnal polling and
without leaving WDH interrupts masked after exiting ddb(4).

Fix an splassert() by no longer calling usb_transfer_complete() in the
interrupt handler.

Issue reported by claudio@@, brynet@@ and Jacqueline Jolicoeur.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.150 2017/05/15 10:52:08 mpi Exp $ */
d6 1
a6 1
 * Copyright (c) 1998, 2005 The NetBSD Foundation, Inc.
a11 2
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
a42 1
#include <sys/atomic.h>
d93 1
d152 1
d1019 1
d1031 17
a1047 1
	intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);
d1052 1
d1062 1
d1064 3
d1079 1
d1094 9
a1102 2
		atomic_setbits_int(&sc->sc_flags, OHCIF_RHSC_INTR);
		usb_schedsoftintr(&sc->sc_bus);
d1105 1
d1108 2
d1111 1
a1111 1
		/* Block unprocessed interrupts. */
d1114 2
a1115 2
		DPRINTFN(1, ("%s: blocking intrs 0x%x\n",
		    sc->sc_bus.bdev.dv_xname, eintrs));
d1122 13
d1144 5
a1148 2
	sc->sc_eintrs |= OHCI_RHSC;
	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);
d1174 1
a1174 1
ohci_softintr(void *v)
d1176 2
a1177 31
	struct ohci_softc *sc = v;
	struct ohci_soft_itd *sitd, *sidone, *sitdnext;
	struct ohci_soft_td *std, *sdone, *stdnext;
	struct usbd_xfer *xfer;
	struct ohci_pipe *opipe;
	int len, cc, s;
	int i, j, actlen, iframes, uedir;
	ohci_physaddr_t done = 0;

	DPRINTFN(10,("ohci_softintr: enter\n"));

	if (sc->sc_bus.dying)
		return;

	sc->sc_bus.intr_context++;

	if (sc->sc_flags & OHCIF_RHSC_INTR) {
		atomic_clearbits_int(&sc->sc_flags, OHCIF_RHSC_INTR);
		ohci_rhsc(sc, sc->sc_intrxfer);
	}

	s = splhardusb();
	usb_syncmem(&sc->sc_hccadma, offsetof(struct ohci_hcca, hcca_done_head),
	    sizeof(sc->sc_hcca->hcca_done_head),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	done = le32toh(sc->sc_hcca->hcca_done_head) & ~OHCI_DONE_INTRS;
	sc->sc_hcca->hcca_done_head = 0;
	usb_syncmem(&sc->sc_hccadma, offsetof(struct ohci_hcca, hcca_done_head),
	    sizeof(sc->sc_hcca->hcca_done_head),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	splx(s);
d1197 1
a1197 1
		panic("addr 0x%08lx not found", (u_long)done);
d1200 35
d2438 1
a2438 1
				ohci_rhsc_enable(sc);
@


1.150
log
@Replace remaining SPLUSBCHECK by a splsoftassert(IPL_SOFTUSB).

USB is the last real user of IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.149 2017/03/10 11:18:48 mpi Exp $ */
d6 1
a6 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d12 2
d45 1
a95 1
void		ohci_add_done(struct ohci_softc *, ohci_physaddr_t);
a153 1
void		ohci_rhsc_able(struct ohci_softc *, int);
a1019 1
	ohci_physaddr_t done;
d1031 1
a1031 17
        intrs = 0;
	done = letoh32(sc->sc_hcca->hcca_done_head);
	if (done != 0) {
		if (done & ~OHCI_DONE_INTRS)
			intrs = OHCI_WDH;
		if (done & OHCI_DONE_INTRS)
			intrs |= OREAD4(sc, OHCI_INTERRUPT_STATUS);
		sc->sc_hcca->hcca_done_head = 0;
	} else {
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);
		/* If we've flushed out a WDH then reread */
		if (intrs & OHCI_WDH) {
			done = letoh32(sc->sc_hcca->hcca_done_head);
			sc->sc_hcca->hcca_done_head = 0;
		}
	}

a1035 1

a1044 1
	sc->sc_bus.intr_context++;
a1045 3
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
		     sc, (u_int)intrs, OREAD4(sc, OHCI_INTERRUPT_STATUS),
		     (u_int)eintrs));
a1057 1
		ohci_add_done(sc, done &~ OHCI_DONE_INTRS);
d1072 2
a1073 9
		ohci_rhsc(sc, sc->sc_intrxfer);
		/*
		 * Disable RHSC interrupt for now, because it will be
		 * on until the port has been reset.
		 */
		ohci_rhsc_able(sc, 0);
		DPRINTFN(2, ("%s: rhsc interrupt disabled\n",
			     sc->sc_bus.bdev.dv_xname));

a1075 1
		eintrs &= ~OHCI_RHSC;
a1077 2
	sc->sc_bus.intr_context--;

d1079 1
a1079 1
		/* Block unprocessed interrupts. XXX */
d1082 2
a1083 2
		printf("%s: blocking intrs 0x%x\n",
		       sc->sc_bus.bdev.dv_xname, eintrs);
a1089 13
ohci_rhsc_able(struct ohci_softc *sc, int on)
{
	DPRINTFN(4, ("ohci_rhsc_able: on=%d\n", on));
	if (on) {
		sc->sc_eintrs |= OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_RHSC);
	} else {
		sc->sc_eintrs &= ~OHCI_RHSC;
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_RHSC);
	}
}

void
d1099 2
a1100 5
	ohci_rhsc(sc, sc->sc_intrxfer);
	DPRINTFN(2, ("%s: rhsc interrupt enabled\n",
		     sc->sc_bus.bdev.dv_xname));

	ohci_rhsc_able(sc, 1);
d1126 1
a1126 1
ohci_add_done(struct ohci_softc *sc, ohci_physaddr_t done)
d1128 31
a1158 2
	struct ohci_soft_itd *sitd, *sidone, **ip;
	struct ohci_soft_td *std, *sdone, **p;
d1178 1
a1178 1
		panic("ohci_add_done: addr 0x%08lx not found", (u_long)done);
a1180 35
	/* sdone & sidone now hold the done lists. */
	/* Put them on the already processed lists. */
	for (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)
		;
	*p = sdone;
	for (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)
		;
	*ip = sidone;
}

void
ohci_softintr(void *v)
{
	struct ohci_softc *sc = v;
	struct ohci_soft_itd *sitd, *sidone, *sitdnext;
	struct ohci_soft_td *std, *sdone, *stdnext;
	struct usbd_xfer *xfer;
	struct ohci_pipe *opipe;
	int len, cc, s;
	int i, j, actlen, iframes, uedir;

	DPRINTFN(10,("ohci_softintr: enter\n"));

	if (sc->sc_bus.dying)
		return;

	sc->sc_bus.intr_context++;

	s = splhardusb();
	sdone = sc->sc_sdone;
	sc->sc_sdone = NULL;
	sidone = sc->sc_sidone;
	sc->sc_sidone = NULL;
	splx(s);

d2384 1
a2384 1
				ohci_rhsc_able(sc, 1);
@


1.149
log
@Fix a use-after-free when sending root hub control transfers.

*_root_ctrl_start() routines are synchronous and all end up calling
usb_transfer_complete() in the non-error case.  After calling this
function it is unsafe to dereference ``xfer'' since the transfer
callback has been called.  So returning USBD_IN_PROGRESS is wrong in
this case since transfers are always completed at this point.

So return USBD_NORMAL_COMPLETION or the corresponding error code if
something wrong happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.148 2017/03/10 09:14:06 mpi Exp $ */
d1652 1
a1652 1
	SPLUSBCHECK;
d1667 1
a1667 1
	SPLUSBCHECK;
d1695 1
a1695 1
	SPLUSBCHECK;
d1720 1
a1720 1
	SPLUSBCHECK;
d1732 1
a1732 1
	SPLUSBCHECK;
@


1.148
log
@Move per HC polling code to the stack.

This code contains a use-after-free which be addressed in an upcoming
diff.

This fix xhci(4) polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.147 2016/09/15 02:00:17 dlg Exp $ */
d2553 1
a2553 1
	return (USBD_IN_PROGRESS);
@


1.147
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.146 2015/12/02 09:43:03 yasuoka Exp $ */
a92 1
void		ohci_waitintr(struct ohci_softc *, struct usbd_xfer *);
a1507 36
/*
 * Wait here until controller claims to have an interrupt.
 * Then call ohci_intr and return.  Use timeout to avoid waiting
 * too long.
 */
void
ohci_waitintr(struct ohci_softc *sc, struct usbd_xfer *xfer)
{
	int timo;
	u_int32_t intrs;

	xfer->status = USBD_IN_PROGRESS;
	for (timo = xfer->timeout; timo >= 0; timo--) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_bus.dying)
			break;
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & sc->sc_eintrs;
		DPRINTFN(15,("ohci_waitintr: 0x%04x\n", intrs));
#ifdef OHCI_DEBUG
		if (ohcidebug > 15)
			ohci_dumpregs(sc);
#endif
		if (intrs) {
			ohci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	DPRINTF(("ohci_waitintr: timeout\n"));
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
	/* XXX should free TD */
}

a2651 3
	if (sc->sc_bus.use_polling)
		ohci_waitintr(sc, xfer);

a2788 3
	if (sc->sc_bus.use_polling)
		ohci_waitintr(sc, xfer);

a2903 3
	if (sc->sc_bus.use_polling)
		ohci_waitintr(sc, xfer);

a3175 7

	/* XXX anything to do? */

	if (sc->sc_bus.use_polling) {
		DPRINTF(("Starting ohci isoc xfer with polling. Bad idea?\n"));
		ohci_waitintr(sc, xfer);
	}
@


1.146
log
@Add missing parentheses.  Fix from NetBSD.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.145 2015/06/26 11:17:34 mpi Exp $ */
d727 2
a728 3
		pool_init(ohcixfer, sizeof(struct ohci_xfer), 0, 0, 0,
		    "ohcixfer", NULL);
		pool_setipl(ohcixfer, IPL_SOFTUSB);
@


1.145
log
@Revert previous.  uvideo checks the transfered length of every frame and
this break some devices.

As found the hardway by Hugo Sastre via sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.144 2015/06/22 12:56:55 mpi Exp $ */
d2904 1
a2904 1
		usbd_xfer_isread(xfer) ? OHCI_TD_IN : OHCI_TD_OUT |
@


1.144
log
@Do not update frame lengths to reflect what has really been transfered
when an isochronous transfer is done.

Frame lengths are just input values and no driver mess with them.

ok ratchov@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.143 2015/03/14 03:38:49 jsg Exp $ */
d1221 1
a1221 1
	int i, j, actlen, iframes;
d1354 2
d1364 4
a1367 1
				if (xfer->status == USBD_NORMAL_COMPLETION) {
d1379 1
d1388 2
a1389 1
			if (xfer->status == USBD_NORMAL_COMPLETION)
@


1.143
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.142 2014/12/19 22:44:59 guenther Exp $ */
d1221 1
a1221 1
	int i, j, actlen, iframes, uedir;
a1353 2
			uedir = UE_GET_DIR(xfer->pipe->endpoint->edesc->
			    bEndpointAddress);
d1362 1
a1362 4
				/* For input, update frlengths with actual */
				/* XXX anything necessary for output? */
				if (uedir == UE_DIR_IN &&
				    xfer->status == USBD_NORMAL_COMPLETION) {
a1373 1
						xfer->frlengths[i] = len;
d1382 1
a1382 2
			if (uedir == UE_DIR_IN &&
			    xfer->status == USBD_NORMAL_COMPLETION)
@


1.142
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.141 2014/12/08 21:47:10 mpi Exp $ */
a37 1
#include <sys/kernel.h>
@


1.141
log
@Do not report underruns as bus data errors, as suggested by section
13.2.3, and let the stack set the status to USBD_SHORT_XFER if
appropriate.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.140 2014/10/05 08:40:29 mpi Exp $ */
d43 1
a45 1
#include <machine/endian.h>
@


1.140
log
@Do not re-establish the default pipe twice for every controller.  Move
this hack in the drivers that need it.

Tested by many, thanks!  ok pirofti@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.139 2014/08/10 11:18:57 mpi Exp $ */
d1314 2
@


1.139
log
@Since USB xfer pools are accessed in interrupt context, initialize them
with the correct ipl to prevent your CPU from locking against itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.138 2014/08/10 11:00:36 mpi Exp $ */
d91 1
d236 1
a236 1
	.dev_setaddr = usbd_set_address,
d2007 34
@


1.138
log
@Set and check for XFER_BUSY in the common methods instead of doing it
in every HC driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.137 2014/08/05 20:26:15 mpi Exp $ */
d729 1
@


1.137
log
@Only check if the abort transfer is the interrupt one if the pipe is
opened with a callback.

If a driver opens an interrupt pipe without callback function, like
umct(4) does with one of its bulk in endpoints being reported as an
interrupt endpoint, then we can end up aborting a transfer which is
different from the interrupt one.

Issue reported by Roberto E. Vargas Caballero, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.136 2014/07/12 20:13:48 mpi Exp $ */
d941 1
a941 9
	struct ohci_xfer *ox;

	ox = pool_get(ohcixfer, PR_NOWAIT | PR_ZERO);
#ifdef DIAGNOSTIC
	if (ox != NULL) {
		ox->xfer.busy_free = XFER_BUSY;
	}
#endif
	return ((struct usbd_xfer *)ox);
d947 1
a947 10
	struct ohci_xfer *ox = (struct ohci_xfer*)xfer;

#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("%s: xfer=%p not busy, 0x%08x\n", __func__, xfer,
		    xfer->busy_free);
		return;
	}
#endif
	pool_put(ohcixfer, ox);
@


1.136
log
@Protect the freelists of transfer descriptors with the appropriate spl
so that we do not end up allocating two times new descriptors.

This happens if a thread finds an empty list, start allocating, got
interrupted and the interrupt also finds an empty list.

Fix an issue reported by Nils Frohberg.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.135 2014/07/10 20:57:40 mpi Exp $ */
d2937 1
a2937 1
	KASSERT(xfer->pipe->intrxfer == xfer);
@


1.135
log
@Do not set the bus dying flag during DVACT_DEACTIVATE otherwise the
explore thread will not disconnect the root hub.  The flag will be
set before detaching the children, like it is done during a suspend-
resume cycle.

Fix a panic when unplugging a cardbus *hci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.134 2014/07/09 15:47:54 mpi Exp $ */
d389 1
a389 1
	struct ohci_soft_ed *sed;
d393 1
d395 1
d401 2
a402 2
			return (0);
		for(i = 0; i < OHCI_SED_CHUNK; i++) {
d414 3
d423 3
d428 1
d434 1
a434 1
	struct ohci_soft_td *std;
d440 1
d446 2
a447 3
			return (NULL);
		s = splusb();
		for(i = 0; i < OHCI_STD_CHUNK; i++) {
a453 1
		splx(s);
a455 1
	s = splusb();
d462 2
a464 1

@


1.134
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.133 2014/06/04 13:52:30 mpi Exp $ */
a354 4
		break;
	case DVACT_DEACTIVATE:
		rv = config_activate_children(self, act);
		sc->sc_bus.dying = 1;
@


1.133
log
@Clearing the data toggle bit only makes sense for endpoints that use it,
since this function is optional get rid of the no-op ones.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.132 2014/06/04 12:28:21 mpi Exp $ */
d235 1
@


1.132
log
@Use C99 initializers for pipe and bus methods.

Apart from improving readability, this will help us reduce the number of
no-op functions now that some of them are optional.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.131 2014/05/30 13:24:59 mpi Exp $ */
a159 1
void		ohci_noop(struct usbd_pipe *pipe);
a245 1
	.cleartoggle = ohci_noop,
a253 1
	.cleartoggle = ohci_noop,
a261 1
	.cleartoggle = ohci_noop,
a287 1
	.cleartoggle = ohci_noop,
a2698 5
}

void
ohci_noop(struct usbd_pipe *pipe)
{
@


1.131
log
@Remove unused fields from the pipes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.130 2014/05/16 18:17:03 mpi Exp $ */
d235 5
a239 5
	ohci_open,
	ohci_softintr,
	ohci_poll,
	ohci_allocx,
	ohci_freex,
d243 6
a248 6
	ohci_root_ctrl_transfer,
	ohci_root_ctrl_start,
	ohci_root_ctrl_abort,
	ohci_root_ctrl_close,
	ohci_noop,
	ohci_root_ctrl_done,
d252 6
a257 6
	ohci_root_intr_transfer,
	ohci_root_intr_start,
	ohci_root_intr_abort,
	ohci_root_intr_close,
	ohci_noop,
	ohci_root_intr_done,
d261 6
a266 6
	ohci_device_ctrl_transfer,
	ohci_device_ctrl_start,
	ohci_device_ctrl_abort,
	ohci_device_ctrl_close,
	ohci_noop,
	ohci_device_ctrl_done,
d270 6
a275 6
	ohci_device_intr_transfer,
	ohci_device_intr_start,
	ohci_device_intr_abort,
	ohci_device_intr_close,
	ohci_device_clear_toggle,
	ohci_device_intr_done,
d279 6
a284 6
	ohci_device_bulk_transfer,
	ohci_device_bulk_start,
	ohci_device_bulk_abort,
	ohci_device_bulk_close,
	ohci_device_clear_toggle,
	ohci_device_bulk_done,
d288 6
a293 6
	ohci_device_isoc_transfer,
	ohci_device_isoc_start,
	ohci_device_isoc_abort,
	ohci_device_isoc_close,
	ohci_noop,
	ohci_device_isoc_done,
@


1.130
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.129 2014/05/09 11:01:06 mpi Exp $ */
a214 1
	/* Info needed for different pipe kinds. */
a218 2
			u_int length;
			struct ohci_soft_td *setup, *data, *stat;
a224 5
		/* Bulk pipe */
		struct {
			u_int length;
			int isread;
		} bulk;
a1611 1
	opipe->u.ctl.length = len;
a2752 3

	opipe->u.bulk.isread = usbd_xfer_isread(xfer);
	opipe->u.bulk.length = len;
@


1.129
log
@Plug an xfer leak when detaching root hubs.

This leak is similar to the public xfer leak #1 that was affecting
device interrupt pipes except that root hubs are rarely detached.

Note that this xfer is never associated to any TD and is just used
to indicate that some of the HC ports has changed status, so there
is no need to flag it as "done" before completing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.128 2014/05/04 14:42:36 mpi Exp $ */
d369 1
a369 2
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
d384 1
a384 1
ohci_detach(struct ohci_softc *sc, int flags)
d386 2
a387 4
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
d389 1
@


1.128
log
@Make use of usbd_xfer_isread() instead of rerolling it everywhere.

This has the side effect of simplifying and reducing the differences
between the various *hci_alloc_*_chain() functions since they are the
principal place where we want to known if the transfer is a read or a
write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.127 2014/04/29 21:51:18 mpi Exp $ */
a2626 1
/* Abort a root interrupt request. */
d2630 1
d2633 2
a2634 4
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ohci_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
a2640 1
/* Close the root pipe. */
a2643 5
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;

	DPRINTF(("ohci_root_intr_close\n"));

	sc->sc_intrxfer = NULL;
a2644 2

/************************/
@


1.127
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.126 2014/04/29 14:11:23 mpi Exp $ */
d86 3
a88 3
usbd_status	ohci_alloc_std_chain(struct ohci_pipe *,
			    struct ohci_softc *, u_int, int, struct usbd_xfer *,
			    struct ohci_soft_td *, struct ohci_soft_td **);
d491 1
a491 2
ohci_alloc_std_chain(struct ohci_pipe *opipe, struct ohci_softc *sc,
    u_int alen, int rd, struct usbd_xfer *xfer,
d498 2
d515 1
d532 1
a532 1
			curlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);
d560 1
a560 1
	    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {
a1595 1
	int isread;
a1599 1
	isread = req->bmRequestType & UT_READ;
d1630 1
a1630 2
		err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
			  std, &stat);
d1653 1
a1653 1
		(isread ? OHCI_TD_OUT : OHCI_TD_IN) |
d2754 1
a2754 1
	int s, isread, endpt;
a2769 1
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d2772 2
a2773 3
	DPRINTFN(4,("ohci_device_bulk_start: xfer=%p len=%u isread=%d "
		    "flags=%d endpt=%d\n", xfer, len, isread, xfer->flags,
		    endpt));
d2775 1
a2775 1
	opipe->u.bulk.isread = isread;
d2785 1
a2785 2
	err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
		  data, &tail);
d2889 1
a2889 1
	int s, len, isread, endpt;
a2904 1
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d2913 1
a2913 1
		isread ? OHCI_TD_IN : OHCI_TD_OUT |
@


1.126
log
@Finally plug the public xfer leak #1 in our USB stack.

Every call to usbd_abort_pipe() on an interrupt pipe would simply
reset the intrxfer pointer, which would prevent usbd_close_pipe()
to free it.  Since we abort pipes in a lot of situations: when a
device is detached, when a USB-to-serial adapter is closed, when
an error occurs, when the machine is suspended, etc, this would
result in hundreds of leaked xfers in most of my machines.

xhci(4) is not affected, but you can't enable it right now since
the stack is not ready :)

While here put a KASSERT() to make sure drivers are only calling
the interrupt abort method for intrxfer, if that's not the case,
please let met know.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.125 2014/04/27 14:48:10 mpi Exp $ */
a39 1
#include <sys/selinfo.h>
d41 2
a50 1
#include <dev/usb/usb_quirks.h>
d69 1
a69 4
/*
 * The OHCI controller is little endian, so on big endian machines
 * the data stored in memory needs to be swapped.
 */
d728 10
a737 1
	SIMPLEQ_INIT(&sc->sc_free_xfers);
d949 1
a949 2
	struct ohci_softc *sc = (struct ohci_softc *)bus;
	struct usbd_xfer *xfer;
d951 1
a951 3
	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
d953 2
a954 7
		if (xfer->busy_free != XFER_FREE) {
			printf("ohci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct ohci_xfer), M_USB, M_NOWAIT);
a955 4
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct ohci_xfer));
#ifdef DIAGNOSTIC
		xfer->busy_free = XFER_BUSY;
d957 1
a957 2
	}
	return (xfer);
d963 1
a963 1
	struct ohci_softc *sc = (struct ohci_softc *)bus;
d967 2
a968 2
		printf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
a970 1
	xfer->busy_free = XFER_FREE;
d972 1
a972 1
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
@


1.125
log
@Start de-obfuscating the HC drivers.

Since pipe methods have an xfer argument, always use it to get acces to
various data structure (pipe, bus, device) instead of having a different
way to get a pointer to these descriptors in every function.

Also kill the {E,U}XFER() macro and use a consistent name accross all the
methods for {e,u}hci_xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.124 2014/03/25 20:27:37 mpi Exp $ */
a2975 1
/* Abort a device control request. */
d2979 2
a2980 4
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ohci_device_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
@


1.124
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.123 2014/03/15 09:49:28 mpi Exp $ */
d1453 1
a1454 1
	struct ohci_softc *sc = (struct ohci_softc *)xfer->device->bus;
d1597 1
a1599 2
	struct usbd_device *dev = xfer->device;
	struct ohci_softc *sc = (struct ohci_softc *)dev->bus;
d1613 2
a1614 2
		    UGETW(req->wIndex), len, dev->address,
		    opipe->pipe.endpoint->edesc->bEndpointAddress));
d1937 1
a1937 2
	struct usbd_device *dev = pipe->device;
	struct ohci_softc *sc = (struct ohci_softc *)dev->bus;
a1939 1
	u_int8_t addr = dev->address;
d1941 2
a1942 2
	struct ohci_soft_ed *sed;
	struct ohci_soft_td *std;
d1951 1
a1951 1
		     pipe, addr, ed->bEndpointAddress));
a1955 3
	std = NULL;
	sed = NULL;

d1993 1
a1993 1
			OHCI_ED_SET_FA(addr) |
d1995 2
a1996 1
			(dev->speed == USB_SPEED_LOW ? OHCI_ED_SPEED : 0) |
d2069 1
a2069 1
		usbd_dump_pipe(&opipe->pipe);
d2626 1
a2626 2
	struct usbd_pipe *pipe = xfer->pipe;
	struct ohci_softc *sc = (struct ohci_softc *)pipe->device->bus;
@


1.123
log
@Unify the *hci_timeout() functions, there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.122 2014/03/11 10:24:42 mpi Exp $ */
d1953 2
a1954 2
	DPRINTFN(1, ("ohci_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
		     pipe, addr, ed->bEndpointAddress, sc->sc_addr));
d1962 2
a1963 1
	if (addr == sc->sc_addr) {
a2411 1
		sc->sc_addr = value;
@


1.122
log
@Kill dead links.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.121 2014/03/07 09:51:50 mpi Exp $ */
d1830 2
a1831 5
	struct ohci_xfer *oxfer = addr;
	struct ohci_pipe *opipe = (struct ohci_pipe *)oxfer->xfer.pipe;
	struct ohci_softc *sc = (struct ohci_softc *)opipe->pipe.device->bus;

	DPRINTF(("ohci_timeout: oxfer=%p\n", oxfer));
d1834 1
a1834 1
		ohci_abort_xfer(&oxfer->xfer, USBD_TIMEOUT);
d1838 1
a1838 2
	/* Execute the abort in a process context. */
	usb_init_task(&oxfer->xfer.abort_task, ohci_timeout_task, addr,
d1840 1
a1840 1
	usb_add_task(oxfer->xfer.pipe->device, &oxfer->xfer.abort_task);
d1849 1
a1849 1
	DPRINTF(("ohci_timeout_task: xfer=%p\n", xfer));
@


1.121
log
@Transfer descriptors already have a back pointer to the USB device
descriptor they are linked to, so no need to dereference their pipe
pointer.  Simplify a lot of affectations, no functional change.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.120 2014/03/07 09:38:14 mpi Exp $ */
a32 7
 */

/*
 * USB Open Host Controller driver.
 *
 * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
@


1.120
log
@We already have three identical copies of the *hci_str() function,
so merge them into usbd_str() to not introduce other copies with
the upcoming HC drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.119 2014/01/15 11:10:40 mpi Exp $ */
d1307 1
a1307 1
		usb_rem_task(xfer->pipe->device, &xfer->abort_task);
d1461 1
a1461 1
	struct ohci_softc *sc = (struct ohci_softc *)opipe->pipe.device->bus;
d1606 1
a1606 1
	struct usbd_device *dev = opipe->pipe.device;
d2120 1
a2120 1
	struct ohci_softc *sc = (struct ohci_softc *)opipe->pipe.device->bus;
d2134 1
a2134 1
		usb_rem_task(xfer->pipe->device, &xfer->abort_task);
d2149 1
a2149 1
	usb_rem_task(xfer->pipe->device, &xfer->abort_task);
d2159 1
a2159 1
	usb_delay_ms(opipe->pipe.device->bus, 20); /* Hardware finishes in 1ms */
d2300 1
a2300 1
	struct ohci_softc *sc = (struct ohci_softc *)xfer->pipe->device->bus;
d2699 1
a2699 1
	struct ohci_softc *sc = (struct ohci_softc *)xfer->pipe->device->bus;
d2775 1
a2776 3
	struct usbd_device *dev = opipe->pipe.device;
	struct ohci_softc *sc = (struct ohci_softc *)dev->bus;
	int addr = dev->address;
d2809 1
a2809 1
		OHCI_ED_SET_FA(addr));
d2914 1
a2915 2
	struct usbd_device *dev = opipe->pipe.device;
	struct ohci_softc *sc = (struct ohci_softc *)dev->bus;
d3134 1
a3135 2
	struct usbd_device *dev = opipe->pipe.device;
	struct ohci_softc *sc = (struct ohci_softc *)dev->bus;
d3254 1
a3254 2
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	struct ohci_softc *sc = (struct ohci_softc *)opipe->pipe.device->bus;
d3279 1
a3280 1
	struct ohci_softc *sc = (struct ohci_softc *)opipe->pipe.device->bus;
@


1.119
log
@Remove a hack to update the address and packet length for every device
request and instead re-open the default pipe with updated values when
attaching a new device, adapted from FreeBSD r162977.

This fixes a problem where the controller could have cached the previous
values and would fail to get the device descriptor, leaving the device
unrecognized with a message like: "device problem, disabling port n".
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.118 2013/12/09 01:02:06 brad Exp $ */
a160 2
int		ohci_str(usb_string_descriptor_t *, int, const char *);

a2279 17
int
ohci_str(usb_string_descriptor_t *p, int l, const char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

d2383 1
a2383 1
				totlen = ohci_str(buf, len, "\001");
d2386 1
a2386 1
				totlen = ohci_str(buf, len, sc->sc_vendor);
d2389 1
a2389 1
				totlen = ohci_str(buf, len, "OHCI root hub");
@


1.118
log
@Mark a few functions with __unused.

ohci.c:193:1: error: unused function 'OREAD1' [-Werror,-Wunused-function]
ohci.c:200:1: error: unused function 'OREAD2' [-Werror,-Wunused-function]
uhci.c:256:1: error: unused function 'UREAD4' [-Werror,-Wunused-function]

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.117 2013/12/06 21:03:05 deraadt Exp $ */
a1609 1
	int addr = dev->address;
d1623 1
a1623 1
		    UGETW(req->wIndex), len, addr,
a1640 9

	/* Update device address and length since they may have changed
	   during the setup of the control pipe in usbd_new_device(). */
	/* XXX This only needs to be done once, but it's too early in open. */
	/* XXXX Should not touch ED here! */
	sed->ed.ed_flags = htole32(
	 (letoh32(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
	 OHCI_ED_SET_FA(addr) |
	 OHCI_ED_SET_MAXP(UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize)));
@


1.117
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.116 2013/11/09 08:46:05 mpi Exp $ */
d192 1
a192 1
static __inline u_int8_t
d199 1
a199 1
static __inline u_int16_t
d206 1
a206 1
static __inline u_int32_t
@


1.116
log
@In our USB world, timeouts are in milliseconds, so use timeout_add_msec()
coherently through all our controller drivers and kill the mstohz() macro.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.115 2013/11/01 12:00:54 mpi Exp $ */
a342 4
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
		break;
d384 7
@


1.115
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.114 2013/06/25 09:24:34 mpi Exp $ */
a75 2
#define mstohz(ms) ((ms) * hz / 1000)

d1705 1
a1705 1
                timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
d2880 1
a2880 1
                timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
@


1.114
log
@Bring ohci(4) and uhci(4) in sync with ehci(4) by ensuring that a
transfer is submitted when a zero-length bulk or interrupt transfer
is requested.

This is the missing part of FreeBSD's svn r159024 that should have
been committed with ehci's r1.57.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.113 2013/05/30 16:15:02 deraadt Exp $ */
d1308 1
a1308 2
		usb_rem_task(xfer->pipe->device,
		    &((struct ohci_xfer *)xfer)->abort_task);
d1860 1
a1860 1
	usb_init_task(&oxfer->abort_task, ohci_timeout_task, addr,
d1862 1
a1862 1
	usb_add_task(oxfer->xfer.pipe->device, &oxfer->abort_task);
d2145 1
a2145 2
		usb_rem_task(xfer->pipe->device,
		    &((struct ohci_xfer *)xfer)->abort_task);
d2160 1
a2160 2
	usb_rem_task(xfer->pipe->device,
	    &((struct ohci_xfer *)xfer)->abort_task);
@


1.113
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.112 2013/05/20 08:19:47 yasuoka Exp $ */
d506 1
a506 1
	struct ohci_soft_td *next, *cur;
d517 2
d526 1
a526 1
	for (;;) {
a562 2
		if (len == 0)
			break;
d565 1
d568 1
a568 1
	if (!rd && (flags & USBD_FORCE_SHORT_XFER) &&
a571 1
		cur = next;
d585 1
d587 1
a587 1
	*ep = cur;
@


1.112
log
@Remove `abort_task' from usb task queue before recycling a `struct
usbd_xfer object' which includes the `abort_task'.  Otherwise
usb_abort_task_thread() may try to dequeue the recycled task then it
causes panic with page fault.

reported by Edd Barrett and Wade, Daniel.
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.111 2013/04/19 08:58:53 mpi Exp $ */
a101 1
void		ohci_shutdown(void *v);
d327 1
d345 4
d384 1
a407 3
	if (sc->sc_shutdownhook != NULL)
		shutdownhook_disestablish(sc->sc_shutdownhook);

a923 1
	sc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);
a987 12
}

/*
 * Shut down the controller when the system is going down.
 */
void
ohci_shutdown(void *v)
{
	struct ohci_softc *sc = v;

	DPRINTF(("ohci_shutdown: stopping the HC\n"));
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
@


1.111
log
@Remove allocm() and freem() from the USB bus interface now that they
are only used as wrappers around usb_{alloc,free}mem().

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.110 2013/04/16 12:10:03 mpi Exp $ */
d1318 2
d2156 2
d2172 2
@


1.110
log
@Merge ohci_hash_rem_td() into ohci_free_std() to reduce differences with
uhci(4). No functional change.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.109 2013/04/15 09:23:01 mglocker Exp $ */
a121 3
usbd_status	ohci_allocm(struct usbd_bus *, struct usb_dma *, u_int32_t);
void		ohci_freem(struct usbd_bus *, struct usb_dma *);

a260 2
	ohci_allocm,
	ohci_freem,
a943 16
}

usbd_status
ohci_allocm(struct usbd_bus *bus, struct usb_dma *dma, u_int32_t size)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;

	return (usb_allocmem(&sc->sc_bus, size, 0, dma));
}

void
ohci_freem(struct usbd_bus *bus, struct usb_dma *dma)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;

	usb_freemem(&sc->sc_bus, dma);
@


1.109
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.108 2013/03/28 03:58:03 tedu Exp $ */
a113 1
void		ohci_hash_rem_td(struct ohci_softc *, struct ohci_soft_td *);
d498 1
a498 1
	ohci_hash_rem_td(sc, std);
a1818 9
}

/* Called at splusb() */
void
ohci_hash_rem_td(struct ohci_softc *sc, struct ohci_soft_td *std)
{
	SPLUSBCHECK;

	LIST_REMOVE(std, hnext);
@


1.108
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.107 2013/03/02 22:57:30 miod Exp $ */
d85 2
a86 2
ohci_soft_ed_t  *ohci_alloc_sed(ohci_softc_t *);
void		ohci_free_sed(ohci_softc_t *, ohci_soft_ed_t *);
d88 2
a89 2
ohci_soft_td_t  *ohci_alloc_std(ohci_softc_t *);
void		ohci_free_std(ohci_softc_t *, ohci_soft_td_t *);
d91 2
a92 2
ohci_soft_itd_t *ohci_alloc_sitd(ohci_softc_t *);
void		ohci_free_sitd(ohci_softc_t *,ohci_soft_itd_t *);
d95 2
a96 2
void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *,
					    ohci_soft_td_t *);
d99 2
a100 2
			    ohci_softc_t *, u_int, int, usbd_xfer_handle,
			    ohci_soft_td_t *, ohci_soft_td_t **);
d103 1
a103 1
usbd_status	ohci_open(usbd_pipe_handle);
d106 58
a163 58
void		ohci_waitintr(ohci_softc_t *, usbd_xfer_handle);
void		ohci_add_done(ohci_softc_t *, ohci_physaddr_t);
void		ohci_rhsc(ohci_softc_t *, usbd_xfer_handle);

usbd_status	ohci_device_request(usbd_xfer_handle xfer);
void		ohci_add_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
void		ohci_rem_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
void		ohci_hash_add_td(ohci_softc_t *, ohci_soft_td_t *);
void		ohci_hash_rem_td(ohci_softc_t *, ohci_soft_td_t *);
ohci_soft_td_t  *ohci_hash_find_td(ohci_softc_t *, ohci_physaddr_t);
void		ohci_hash_add_itd(ohci_softc_t *, ohci_soft_itd_t *);
void		ohci_hash_rem_itd(ohci_softc_t *, ohci_soft_itd_t *);
ohci_soft_itd_t  *ohci_hash_find_itd(ohci_softc_t *, ohci_physaddr_t);

usbd_status	ohci_setup_isoc(usbd_pipe_handle pipe);
void		ohci_device_isoc_enter(usbd_xfer_handle);

usbd_status	ohci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
void		ohci_freem(struct usbd_bus *, usb_dma_t *);

usbd_xfer_handle	ohci_allocx(struct usbd_bus *);
void		ohci_freex(struct usbd_bus *, usbd_xfer_handle);

usbd_status	ohci_root_ctrl_transfer(usbd_xfer_handle);
usbd_status	ohci_root_ctrl_start(usbd_xfer_handle);
void		ohci_root_ctrl_abort(usbd_xfer_handle);
void		ohci_root_ctrl_close(usbd_pipe_handle);
void		ohci_root_ctrl_done(usbd_xfer_handle);

usbd_status	ohci_root_intr_transfer(usbd_xfer_handle);
usbd_status	ohci_root_intr_start(usbd_xfer_handle);
void		ohci_root_intr_abort(usbd_xfer_handle);
void		ohci_root_intr_close(usbd_pipe_handle);
void		ohci_root_intr_done(usbd_xfer_handle);

usbd_status	ohci_device_ctrl_transfer(usbd_xfer_handle);
usbd_status	ohci_device_ctrl_start(usbd_xfer_handle);
void		ohci_device_ctrl_abort(usbd_xfer_handle);
void		ohci_device_ctrl_close(usbd_pipe_handle);
void		ohci_device_ctrl_done(usbd_xfer_handle);

usbd_status	ohci_device_bulk_transfer(usbd_xfer_handle);
usbd_status	ohci_device_bulk_start(usbd_xfer_handle);
void		ohci_device_bulk_abort(usbd_xfer_handle);
void		ohci_device_bulk_close(usbd_pipe_handle);
void		ohci_device_bulk_done(usbd_xfer_handle);

usbd_status	ohci_device_intr_transfer(usbd_xfer_handle);
usbd_status	ohci_device_intr_start(usbd_xfer_handle);
void		ohci_device_intr_abort(usbd_xfer_handle);
void		ohci_device_intr_close(usbd_pipe_handle);
void		ohci_device_intr_done(usbd_xfer_handle);

usbd_status	ohci_device_isoc_transfer(usbd_xfer_handle);
usbd_status	ohci_device_isoc_start(usbd_xfer_handle);
void		ohci_device_isoc_abort(usbd_xfer_handle);
void		ohci_device_isoc_close(usbd_pipe_handle);
void		ohci_device_isoc_done(usbd_xfer_handle);
d165 1
a165 1
usbd_status	ohci_device_setintr(ohci_softc_t *sc,
d172 1
a172 1
void		ohci_rhsc_able(ohci_softc_t *, int);
d175 2
a176 2
void		ohci_close_pipe(usbd_pipe_handle, ohci_soft_ed_t *);
void		ohci_abort_xfer(usbd_xfer_handle, usbd_status);
d178 2
a179 2
void		ohci_device_clear_toggle(usbd_pipe_handle pipe);
void		ohci_noop(usbd_pipe_handle pipe);
d182 6
a187 6
void		ohci_dumpregs(ohci_softc_t *);
void		ohci_dump_tds(ohci_soft_td_t *);
void		ohci_dump_td(ohci_soft_td_t *);
void		ohci_dump_ed(ohci_soft_ed_t *);
void		ohci_dump_itd(ohci_soft_itd_t *);
void		ohci_dump_itds(ohci_soft_itd_t *);
d200 1
a200 1
OREAD1(ohci_softc_t *sc, bus_size_t r)
d207 1
a207 1
OREAD2(ohci_softc_t *sc, bus_size_t r)
d214 1
a214 1
OREAD4(ohci_softc_t *sc, bus_size_t r)
d229 1
a229 1
	ohci_soft_ed_t *sed;
d231 2
a232 2
		ohci_soft_td_t *td;
		ohci_soft_itd_t *itd;
d238 1
a238 1
			usb_dma_t reqdma;
d240 1
a240 1
			ohci_soft_td_t *setup, *data, *stat;
d419 2
a420 2
ohci_soft_ed_t *
ohci_alloc_sed(ohci_softc_t *sc)
d422 1
a422 1
	ohci_soft_ed_t *sed;
d425 1
a425 1
	usb_dma_t dma;
d443 1
a443 1
	memset(&sed->ed, 0, sizeof(ohci_ed_t));
d449 1
a449 1
ohci_free_sed(ohci_softc_t *sc, ohci_soft_ed_t *sed)
d455 2
a456 2
ohci_soft_td_t *
ohci_alloc_std(ohci_softc_t *sc)
d458 1
a458 1
	ohci_soft_td_t *std;
d461 1
a461 1
	usb_dma_t dma;
d484 1
a484 1
	memset(&std->td, 0, sizeof(ohci_td_t));
d494 1
a494 1
ohci_free_std(ohci_softc_t *sc, ohci_soft_td_t *std)
d506 3
a508 3
ohci_alloc_std_chain(struct ohci_pipe *opipe, ohci_softc_t *sc,
		     u_int alen, int rd, usbd_xfer_handle xfer,
		     ohci_soft_td_t *sp, ohci_soft_td_t **ep)
d510 1
a510 1
	ohci_soft_td_t *next, *cur;
d514 1
a514 1
	usb_dma_t *dma = &xfer->dmabuf;
d601 2
a602 2
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std,
		    ohci_soft_td_t *stdend)
d604 1
a604 1
	ohci_soft_td_t *p;
d613 2
a614 2
ohci_soft_itd_t *
ohci_alloc_sitd(ohci_softc_t *sc)
d616 1
a616 1
	ohci_soft_itd_t *sitd;
d619 1
a619 1
	usb_dma_t dma;
d641 1
a641 1
	memset(&sitd->itd, 0, sizeof(ohci_itd_t));
d655 1
a655 1
ohci_free_sitd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
d678 1
a678 1
ohci_checkrev(ohci_softc_t *sc)
d699 1
a699 1
ohci_handover(ohci_softc_t *sc)
d728 1
a728 1
ohci_init(ohci_softc_t *sc)
d730 1
a730 1
	ohci_soft_ed_t *sed, *psed;
d953 1
a953 1
ohci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
d961 1
a961 1
ohci_freem(struct usbd_bus *bus, usb_dma_t *dma)
d968 1
a968 1
usbd_xfer_handle
d972 1
a972 1
	usbd_xfer_handle xfer;
d996 1
a996 1
ohci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
d1017 1
a1017 1
	ohci_softc_t *sc = v;
d1025 1
a1025 1
ohci_dumpregs(ohci_softc_t *sc)
d1064 1
a1064 1
int ohci_intr1(ohci_softc_t *);
d1069 1
a1069 1
	ohci_softc_t *sc = p;
d1090 1
a1090 1
ohci_intr1(ohci_softc_t *sc)
d1196 1
a1196 1
ohci_rhsc_able(ohci_softc_t *sc, int on)
d1211 1
a1211 1
	ohci_softc_t *sc = v_sc;
d1248 1
a1248 1
ohci_add_done(ohci_softc_t *sc, ohci_physaddr_t done)
d1250 2
a1251 2
	ohci_soft_itd_t *sitd, *sidone, **ip;
	ohci_soft_td_t  *std,  *sdone,  **p;
d1287 4
a1290 4
	ohci_softc_t *sc = v;
	ohci_soft_itd_t *sitd, *sidone, *sitdnext;
	ohci_soft_td_t  *std,  *sdone,  *stdnext;
	usbd_xfer_handle xfer;
d1365 1
a1365 1
			ohci_soft_td_t *p, *n;
d1419 1
a1419 1
			ohci_soft_itd_t *next;
d1478 1
a1478 1
ohci_device_ctrl_done(usbd_xfer_handle xfer)
d1490 1
a1490 1
ohci_device_intr_done(usbd_xfer_handle xfer)
d1493 3
a1495 3
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *data, *tail;
d1532 1
a1532 1
ohci_device_bulk_done(usbd_xfer_handle xfer)
d1539 1
a1539 1
ohci_rhsc(ohci_softc_t *sc, usbd_xfer_handle xfer)
d1570 1
a1570 1
ohci_root_intr_done(usbd_xfer_handle xfer)
d1575 1
a1575 1
ohci_root_ctrl_done(usbd_xfer_handle xfer)
d1585 1
a1585 1
ohci_waitintr(ohci_softc_t *sc, usbd_xfer_handle xfer)
d1618 1
a1618 1
	ohci_softc_t *sc = (ohci_softc_t *)bus;
d1634 1
a1634 1
ohci_device_request(usbd_xfer_handle xfer)
d1638 2
a1639 2
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
d1641 2
a1642 2
	ohci_soft_td_t *setup, *stat, *next, *tail;
	ohci_soft_ed_t *sed;
d1686 1
a1686 1
		ohci_soft_td_t *std = stat;
d1770 1
a1770 1
ohci_add_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
d1785 1
a1785 1
ohci_rem_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
d1787 1
a1787 1
	ohci_soft_ed_t *p;
d1813 1
a1813 1
ohci_hash_add_td(ohci_softc_t *sc, ohci_soft_td_t *std)
d1824 1
a1824 1
ohci_hash_rem_td(ohci_softc_t *sc, ohci_soft_td_t *std)
d1831 2
a1832 2
ohci_soft_td_t *
ohci_hash_find_td(ohci_softc_t *sc, ohci_physaddr_t a)
d1835 1
a1835 1
	ohci_soft_td_t *std;
d1847 1
a1847 1
ohci_hash_add_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
d1861 1
a1861 1
ohci_hash_rem_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
d1871 2
a1872 2
ohci_soft_itd_t *
ohci_hash_find_itd(ohci_softc_t *sc, ohci_physaddr_t a)
d1875 1
a1875 1
	ohci_soft_itd_t *sitd;
d1890 1
a1890 1
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
d1908 1
a1908 1
	usbd_xfer_handle xfer = addr;
d1920 1
a1920 1
ohci_dump_tds(ohci_soft_td_t *std)
d1927 1
a1927 1
ohci_dump_td(ohci_soft_td_t *std)
d1947 1
a1947 1
ohci_dump_itd(ohci_soft_itd_t *sitd)
d1968 1
a1968 1
ohci_dump_itds(ohci_soft_itd_t *sitd)
d1975 1
a1975 1
ohci_dump_ed(ohci_soft_ed_t *sed)
d1998 1
a1998 1
ohci_open(usbd_pipe_handle pipe)
d2000 2
a2001 2
	usbd_device_handle dev = pipe->device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
d2006 3
a2008 3
	ohci_soft_ed_t *sed;
	ohci_soft_td_t *std;
	ohci_soft_itd_t *sitd;
d2115 1
a2115 1
ohci_close_pipe(usbd_pipe_handle pipe, ohci_soft_ed_t *head)
d2118 2
a2119 2
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
d2127 1
a2127 1
		ohci_soft_td_t *std;
d2168 1
a2168 1
ohci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d2171 3
a2173 3
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *p, *n;
d2350 1
a2350 1
ohci_root_ctrl_transfer(usbd_xfer_handle xfer)
d2364 1
a2364 1
ohci_root_ctrl_start(usbd_xfer_handle xfer)
d2366 1
a2366 1
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
d2678 1
a2678 1
ohci_root_ctrl_abort(usbd_xfer_handle xfer)
d2685 1
a2685 1
ohci_root_ctrl_close(usbd_pipe_handle pipe)
d2692 1
a2692 1
ohci_root_intr_transfer(usbd_xfer_handle xfer)
d2706 1
a2706 1
ohci_root_intr_start(usbd_xfer_handle xfer)
d2708 2
a2709 2
	usbd_pipe_handle pipe = xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d2721 1
a2721 1
ohci_root_intr_abort(usbd_xfer_handle xfer)
d2737 1
a2737 1
ohci_root_intr_close(usbd_pipe_handle pipe)
d2739 1
a2739 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d2749 1
a2749 1
ohci_device_ctrl_transfer(usbd_xfer_handle xfer)
d2763 1
a2763 1
ohci_device_ctrl_start(usbd_xfer_handle xfer)
d2765 1
a2765 1
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
d2791 1
a2791 1
ohci_device_ctrl_abort(usbd_xfer_handle xfer)
d2799 1
a2799 1
ohci_device_ctrl_close(usbd_pipe_handle pipe)
d2802 1
a2802 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d2812 1
a2812 1
ohci_device_clear_toggle(usbd_pipe_handle pipe)
d2820 1
a2820 1
ohci_noop(usbd_pipe_handle pipe)
d2825 1
a2825 1
ohci_device_bulk_transfer(usbd_xfer_handle xfer)
d2839 1
a2839 1
ohci_device_bulk_start(usbd_xfer_handle xfer)
d2842 2
a2843 2
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
d2845 2
a2846 2
	ohci_soft_td_t *data, *tail, *tdp;
	ohci_soft_ed_t *sed;
d2943 1
a2943 1
ohci_device_bulk_abort(usbd_xfer_handle xfer)
d2953 1
a2953 1
ohci_device_bulk_close(usbd_pipe_handle pipe)
d2956 1
a2956 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d2966 1
a2966 1
ohci_device_intr_transfer(usbd_xfer_handle xfer)
d2980 1
a2980 1
ohci_device_intr_start(usbd_xfer_handle xfer)
d2983 4
a2986 4
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *data, *tail;
d3064 1
a3064 1
ohci_device_intr_abort(usbd_xfer_handle xfer)
d3075 1
a3075 1
ohci_device_intr_close(usbd_pipe_handle pipe)
d3078 1
a3078 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d3082 1
a3082 1
	ohci_soft_ed_t *p, *sed = opipe->sed;
d3111 1
a3111 1
ohci_device_setintr(ohci_softc_t *sc, struct ohci_pipe *opipe, int ival)
d3116 1
a3116 1
	ohci_soft_ed_t *hsed, *sed = opipe->sed;
d3175 1
a3175 1
ohci_device_isoc_transfer(usbd_xfer_handle xfer)
d3201 1
a3201 1
ohci_device_isoc_enter(usbd_xfer_handle xfer)
d3204 3
a3206 3
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	ohci_soft_ed_t *sed = opipe->sed;
d3208 1
a3208 1
	ohci_soft_itd_t *sitd, *nsitd;
d3322 1
a3322 1
ohci_device_isoc_start(usbd_xfer_handle xfer)
d3325 1
a3325 1
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
d3348 1
a3348 1
ohci_device_isoc_abort(usbd_xfer_handle xfer)
d3351 3
a3353 3
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_itd_t *sitd;
d3405 1
a3405 1
ohci_device_isoc_done(usbd_xfer_handle xfer)
d3411 1
a3411 1
ohci_setup_isoc(usbd_pipe_handle pipe)
d3414 1
a3414 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
d3429 1
a3429 1
ohci_device_isoc_close(usbd_pipe_handle pipe)
d3432 1
a3432 1
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
@


1.107
log
@Decide whether to use polling or not only upon `sc_bus.use_polling', regardless
of the value of `cold'. This is similar to what the other hci drivers do, and
has not caused any regressions on the few systems this has been tested on.
Commited now to have a change to expose ohci-specific regressions (if any).
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.106 2012/08/07 23:51:36 krw Exp $ */
a47 1
#include <sys/proc.h>
@


1.106
log
@Make all *_device_*_start() functions (e.g. ohci_device_intr_start())
wait for an interrupt when the bus is in polling mode. Otherwise
some devices like my YE-Data USB Floppy take a short sharp trip to
ddb> at 'halt -p'.

Most of the functions were already doing the wait.

ok miod@@. With modification that printf's become DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.105 2011/09/18 18:29:20 krw Exp $ */
d1076 1
a1076 1
	if (!cold && sc->sc_bus.use_polling) {
@


1.105
log
@Set pointer to NULL not 0. From Michael Knudsen (several times).
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.104 2011/07/03 15:47:17 matthew Exp $ */
d3057 3
d3339 5
@


1.104
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.103 2010/12/14 16:13:16 jakemsr Exp $ */
d445 1
a445 1
	sed->next = 0;
@


1.103
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.102 2010/12/06 06:09:08 jakemsr Exp $ */
a333 2
	case DVACT_ACTIVATE:
		break;
@


1.102
log
@* if we got an undercoverable error, set the dying flag
* check the dying flag in timeout and interrupt handlers

fixes crash when disconnecting cardbus usb adapters
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.101 2010/10/28 16:07:33 deraadt Exp $ */
d393 1
a393 1
		sc->sc_dying = 1;
d1074 1
a1074 1
	if (sc == NULL || sc->sc_dying)
d1126 1
a1126 1
		sc->sc_dying = 1;
d1217 1
a1217 1
	if (sc->sc_dying)
d1300 1
a1300 1
	if (sc->sc_dying)
d1596 1
a1596 1
		if (sc->sc_dying)
d1897 1
a1897 1
	if (sc->sc_dying) {
d2021 1
a2021 1
	if (sc->sc_dying)
d2183 1
a2183 1
	if (sc->sc_dying) {
d2379 1
a2379 1
	if (sc->sc_dying)
d2642 1
a2642 1
				if (sc->sc_dying) {
d2714 1
a2714 1
	if (sc->sc_dying)
d2771 1
a2771 1
	if (sc->sc_dying)
d2854 1
a2854 1
	if (sc->sc_dying)
d2992 1
a2992 1
	if (sc->sc_dying)
d3217 1
a3217 1
	if (sc->sc_dying)
d3329 1
a3329 1
	if (sc->sc_dying)
@


1.101
log
@improve look of ;; in a for loop
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.100 2010/10/23 15:42:09 jakemsr Exp $ */
d1217 3
d1299 3
@


1.100
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.99 2010/09/07 16:21:46 deraadt Exp $ */
d1424 1
a1424 1
			for (i = 0, sitd = xfer->hcpriv;;
@


1.99
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.98 2010/08/31 16:59:47 deraadt Exp $ */
d1897 2
a1898 1
	usb_init_task(&oxfer->abort_task, ohci_timeout_task, addr);
@


1.98
log
@sort DVACT_ actions in order of use
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.97 2010/08/30 21:30:16 deraadt Exp $ */
a1023 13
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an interrupt context.  This is all right since we
 * are almost suspended anyway.
 */
void
ohci_powerhook(int why, void *v)
{
	ohci_activate(v, why);
@


1.97
log
@Change powerhooks into activate functions, and provide stub powerhook
functions
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.96 2010/08/27 04:09:20 deraadt Exp $ */
a335 5
	case DVACT_DEACTIVATE:
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
		sc->sc_dying = 1;
		break;
d389 5
@


1.96
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.95 2010/05/01 19:43:57 jsg Exp $ */
d330 1
a335 1

d342 16
a357 1
		ohci_power(PWR_SUSPEND, sc);
d360 34
a393 1
		ohci_power(PWR_RESUME, sc);
d1034 1
a1034 1
ohci_power(int why, void *v)
d1036 1
a1036 67
	ohci_softc_t *sc = v;
	u_int32_t reg;
	int s;

#ifdef OHCI_DEBUG
	DPRINTF(("ohci_power: sc=%p, why=%d\n", sc, why));
	ohci_dumpregs(sc);
#endif

	s = splhardusb();
	switch (why) {
	case PWR_SUSPEND:
		sc->sc_bus.use_polling++;
		reg = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = reg;
			sc->sc_intre = OREAD4(sc, OHCI_INTERRUPT_ENABLE);
			sc->sc_ival = OHCI_GET_IVAL(OREAD4(sc,
			    OHCI_FM_INTERVAL));
		}
		reg |= OHCI_HCFS_SUSPEND;
		OWRITE4(sc, OHCI_CONTROL, reg);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_bus.use_polling--;
		break;
	case PWR_RESUME:
		sc->sc_bus.use_polling++;

		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
		OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE,
			    sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
		if (sc->sc_control)
			reg = sc->sc_control;
		else
			reg = OREAD4(sc, OHCI_CONTROL);
		reg |= OHCI_HCFS_RESUME;
		OWRITE4(sc, OHCI_CONTROL, reg);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		reg = (reg & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, OHCI_CONTROL, reg);

		reg = (OREAD4(sc, OHCI_FM_REMAINING) & OHCI_FIT) ^ OHCI_FIT;
		reg |= OHCI_FSMPS(sc->sc_ival) | sc->sc_ival;
		OWRITE4(sc, OHCI_FM_INTERVAL, reg);
		OWRITE4(sc, OHCI_PERIODIC_START, OHCI_PERIODIC(sc->sc_ival));

		/* Fiddle the No OverCurrent Protection to avoid a chip bug */
		reg = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
		OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, reg | OHCI_NOCP);
		OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
		usb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);
		OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, reg);

		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_control = sc->sc_intre = sc->sc_ival = 0;
		sc->sc_bus.use_polling--;
		break;
	}
	splx(s);
@


1.95
log
@put the read macros into functions so gcc4 doesn't whinge.
ok marco@@ oga@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.94 2009/11/26 12:27:48 deraadt Exp $ */
a999 1
	case PWR_STANDBY:
@


1.94
log
@Call the existing power functions with our activate function for
the suspend and resume operations
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.93 2009/11/04 19:14:10 kettenis Exp $ */
d199 21
a219 3
#define OREAD1(sc, r) (OBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
#define OREAD2(sc, r) (OBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
#define OREAD4(sc, r) (OBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
@


1.93
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.92 2009/10/13 19:33:17 pirofti Exp $ */
d322 6
@


1.92
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.91 2009/06/02 23:49:33 deraadt Exp $ */
a1472 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1476 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a2213 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a2214 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a2215 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a2216 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
@


1.91
log
@ehci_alloc_sqtd_chain() was doing signed math on len, thus the great code
	curlen -= curlen % mps;
can for very large transfers result in an intermediate variable growing
larger than it should.  Probably can't really happen in the real world.
Do the same u_int repairs to the other matching drivers
ok blambert kjell miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.90 2009/02/14 20:05:09 chl Exp $ */
d309 1
a309 1
ohci_activate(struct device *self, enum devact act)
@


1.90
log
@remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok fgsch@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.89 2008/11/21 17:08:42 deraadt Exp $ */
d100 1
a100 1
			    ohci_softc_t *, int, int, usbd_xfer_handle,
d438 1
a438 1
		     int alen, int rd, usbd_xfer_handle xfer,
d444 1
a444 1
	int len, curlen;
d448 1
a448 1
	DPRINTFN(alen < 4096,("ohci_alloc_std_chain: start len=%d\n", alen));
d481 1
a481 1
			    "dataphysend=0x%08x len=%d curlen=%d\n",
d1651 1
a1651 1
	int len;
d1659 1
a1659 1
		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
d2857 2
a2858 1
	int s, len, isread, endpt;
d2877 1
a2877 1
	DPRINTFN(4,("ohci_device_bulk_start: xfer=%p len=%d isread=%d "
d3002 1
a3002 1
	DPRINTFN(3, ("ohci_device_intr_transfer: xfer=%p len=%d "
@


1.89
log
@if interrupt register is all 1s, we know we are dead; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.88 2008/09/10 14:01:23 blambert Exp $ */
a1547 1
	usbd_pipe_handle pipe;
a1559 2

	pipe = xfer->pipe;
@


1.88
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.87 2008/06/29 10:04:15 yuo Exp $ */
d1131 5
@


1.87
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.86 2008/06/26 05:42:18 ray Exp $ */
d1184 1
a1184 1
                timeout_add(&sc->sc_tmo_rhsc, hz);
@


1.86
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.85 2007/11/23 15:43:02 mbalmer Exp $ */
d2661 3
@


1.85
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.84 2007/06/15 11:41:48 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.84
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.83 2007/06/14 12:58:09 mbalmer Exp $ */
d868 1
a868 1
	timeout_set(&sc->sc_tmo_rhsc, NULL, NULL);
a1190 2
                timeout_del(&sc->sc_tmo_rhsc);
                timeout_set(&sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);
@


1.83
log
@Move the mstohz macro out of ubs_port.h and to the three places where it is
used.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.82 2007/06/12 16:26:36 mbalmer Exp $ */
d1477 1
a1477 1
#ifdef USB_USE_SOFTINTR
d1482 1
a1482 1
#endif /* USB_USE_SOFTINTR */
d2223 1
a2223 1
#ifdef USB_USE_SOFTINTR
d2225 1
a2225 1
#endif /* USB_USE_SOFTINTR */
d2227 1
a2227 1
#ifdef USB_USE_SOFTINTR
d2229 1
a2229 1
#endif /* USB_USE_SOFTINTR */
@


1.82
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.81 2007/06/10 14:49:00 mbalmer Exp $ */
d83 2
@


1.81
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.80 2007/06/10 10:15:35 mbalmer Exp $ */
d314 1
a314 1
ohci_activate(device_ptr_t self, enum devact act)
@


1.80
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.79 2007/06/05 08:43:55 mbalmer Exp $ */
d625 1
a625 1
		       USBDEVNAME(sc->sc_bus.bdev));
d656 1
a656 1
			    USBDEVNAME(sc->sc_bus.bdev));
d784 1
a784 1
	DPRINTF(("%s: resetting\n", USBDEVNAME(sc->sc_bus.bdev)));
d799 1
a799 1
		printf("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev));
d1157 1
a1157 1
			    USBDEVNAME(sc->sc_bus.bdev), sc->sc_overrun_cnt);
d1169 1
a1169 1
		printf("%s: resume detect\n", USBDEVNAME(sc->sc_bus.bdev));
d1174 1
a1174 1
		       USBDEVNAME(sc->sc_bus.bdev));
d1186 1
a1186 1
			     USBDEVNAME(sc->sc_bus.bdev)));
d1202 1
a1202 1
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
d1230 1
a1230 1
		     USBDEVNAME(sc->sc_bus.bdev)));
d3251 1
a3251 1
				       USBDEVNAME(sc->sc_bus.bdev));
d3280 1
a3280 1
		       USBDEVNAME(sc->sc_bus.bdev));
@


1.79
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.78 2007/05/21 06:10:43 jsg Exp $ */
d343 1
a343 1
	usb_uncallout(sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);
d866 1
a866 1
	usb_callout_init(sc->sc_tmo_rhsc);
d1189 3
a1191 1
                usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
d1346 1
a1346 1
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d1748 3
a1750 2
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ohci_timeout, xfer);
d2195 1
a2195 1
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d2209 1
a2209 1
	usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d2929 3
a2931 2
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    ohci_timeout, xfer);
@


1.78
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.77 2007/05/21 05:40:27 jsg Exp $ */
d91 2
a92 2
Static ohci_soft_ed_t  *ohci_alloc_sed(ohci_softc_t *);
Static void		ohci_free_sed(ohci_softc_t *, ohci_soft_ed_t *);
d94 2
a95 2
Static ohci_soft_td_t  *ohci_alloc_std(ohci_softc_t *);
Static void		ohci_free_std(ohci_softc_t *, ohci_soft_td_t *);
d97 2
a98 2
Static ohci_soft_itd_t *ohci_alloc_sitd(ohci_softc_t *);
Static void		ohci_free_sitd(ohci_softc_t *,ohci_soft_itd_t *);
d101 1
a101 1
Static void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *,
d104 1
a104 1
Static usbd_status	ohci_alloc_std_chain(struct ohci_pipe *,
d108 62
a169 62
Static void		ohci_shutdown(void *v);
Static usbd_status	ohci_open(usbd_pipe_handle);
Static void		ohci_poll(struct usbd_bus *);
Static void		ohci_softintr(void *);
Static void		ohci_waitintr(ohci_softc_t *, usbd_xfer_handle);
Static void		ohci_add_done(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_rhsc(ohci_softc_t *, usbd_xfer_handle);

Static usbd_status	ohci_device_request(usbd_xfer_handle xfer);
Static void		ohci_add_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_rem_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_hash_add_td(ohci_softc_t *, ohci_soft_td_t *);
Static void		ohci_hash_rem_td(ohci_softc_t *, ohci_soft_td_t *);
Static ohci_soft_td_t  *ohci_hash_find_td(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_hash_add_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static void		ohci_hash_rem_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static ohci_soft_itd_t  *ohci_hash_find_itd(ohci_softc_t *, ohci_physaddr_t);

Static usbd_status	ohci_setup_isoc(usbd_pipe_handle pipe);
Static void		ohci_device_isoc_enter(usbd_xfer_handle);

Static usbd_status	ohci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		ohci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	ohci_allocx(struct usbd_bus *);
Static void		ohci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	ohci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_ctrl_start(usbd_xfer_handle);
Static void		ohci_root_ctrl_abort(usbd_xfer_handle);
Static void		ohci_root_ctrl_close(usbd_pipe_handle);
Static void		ohci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_intr_start(usbd_xfer_handle);
Static void		ohci_root_intr_abort(usbd_xfer_handle);
Static void		ohci_root_intr_close(usbd_pipe_handle);
Static void		ohci_root_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_ctrl_start(usbd_xfer_handle);
Static void		ohci_device_ctrl_abort(usbd_xfer_handle);
Static void		ohci_device_ctrl_close(usbd_pipe_handle);
Static void		ohci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_bulk_start(usbd_xfer_handle);
Static void		ohci_device_bulk_abort(usbd_xfer_handle);
Static void		ohci_device_bulk_close(usbd_pipe_handle);
Static void		ohci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	ohci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_intr_start(usbd_xfer_handle);
Static void		ohci_device_intr_abort(usbd_xfer_handle);
Static void		ohci_device_intr_close(usbd_pipe_handle);
Static void		ohci_device_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_isoc_start(usbd_xfer_handle);
Static void		ohci_device_isoc_abort(usbd_xfer_handle);
Static void		ohci_device_isoc_close(usbd_pipe_handle);
Static void		ohci_device_isoc_done(usbd_xfer_handle);
d171 1
a171 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc,
d174 1
a174 1
Static int		ohci_str(usb_string_descriptor_t *, int, const char *);
d176 4
a179 4
Static void		ohci_timeout(void *);
Static void		ohci_timeout_task(void *);
Static void		ohci_rhsc_able(ohci_softc_t *, int);
Static void		ohci_rhsc_enable(void *);
d181 2
a182 2
Static void		ohci_close_pipe(usbd_pipe_handle, ohci_soft_ed_t *);
Static void		ohci_abort_xfer(usbd_xfer_handle, usbd_status);
d184 2
a185 2
Static void		ohci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		ohci_noop(usbd_pipe_handle pipe);
d188 6
a193 6
Static void		ohci_dumpregs(ohci_softc_t *);
Static void		ohci_dump_tds(ohci_soft_td_t *);
Static void		ohci_dump_td(ohci_soft_td_t *);
Static void		ohci_dump_ed(ohci_soft_ed_t *);
Static void		ohci_dump_itd(ohci_soft_itd_t *);
Static void		ohci_dump_itds(ohci_soft_itd_t *);
d209 1
a209 1
Static u_int8_t revbits[OHCI_NO_INTRS] =
d249 1
a249 1
Static struct usbd_bus_methods ohci_bus_methods = {
d259 1
a259 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {
d268 1
a268 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {
d277 1
a277 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {
d286 1
a286 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {
d295 1
a295 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {
d304 1
a304 1
Static struct usbd_pipe_methods ohci_device_isoc_methods = {
d536 1
a536 1
Static void
d1080 1
a1080 1
Static int ohci_intr1(ohci_softc_t *);
d1105 1
a1105 1
Static int
d2284 1
a2284 1
Static usb_device_descriptor_t ohci_devd = {
d2297 1
a2297 1
Static usb_config_descriptor_t ohci_confd = {
d2310 1
a2310 1
Static usb_interface_descriptor_t ohci_ifcd = {
d2322 1
a2322 1
Static usb_endpoint_descriptor_t ohci_endpd = {
d2331 1
a2331 1
Static usb_hub_descriptor_t ohci_hubd = {
d2341 1
a2341 1
Static int
d2361 1
a2361 1
Static usbd_status
d2375 1
a2375 1
Static usbd_status
d2686 1
a2686 1
Static void
d2693 1
a2693 1
Static void
d2700 1
a2700 1
Static usbd_status
d2714 1
a2714 1
Static usbd_status
d2729 1
a2729 1
Static void
d2745 1
a2745 1
Static void
d2757 1
a2757 1
Static usbd_status
d2771 1
a2771 1
Static usbd_status
d2799 1
a2799 1
Static void
d2807 1
a2807 1
Static void
d2820 1
a2820 1
Static void
d2828 1
a2828 1
Static void
d2833 1
a2833 1
Static usbd_status
d2847 1
a2847 1
Static usbd_status
d2949 1
a2949 1
Static void
d2959 1
a2959 1
Static void
d2972 1
a2972 1
Static usbd_status
d2986 1
a2986 1
Static usbd_status
d3067 1
a3067 1
Static void
d3078 1
a3078 1
Static void
d3114 1
a3114 1
Static usbd_status
@


1.77
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.76 2007/03/22 05:53:36 pascoe Exp $ */
d1075 2
a1076 2
		 le32toh(sc->sc_hcca->hcca_frame_number),
		 le32toh(sc->sc_hcca->hcca_done_head)));
d1122 1
a1122 1
	done = le32toh(sc->sc_hcca->hcca_done_head);
d1133 1
a1133 1
			done = le32toh(sc->sc_hcca->hcca_done_head);
d1266 1
a1266 1
			done = le32toh(std->td.td_nexttd);
d1274 1
a1274 1
			done = le32toh(sitd->itd.itd_nextitd);
d1348 2
a1349 2
			len -= le32toh(std->td.td_be) -
			    le32toh(std->td.td_cbp) + 1;
d1355 1
a1355 1
		cc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));
d1374 2
a1375 2
			  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
			  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))]));
d1435 1
a1435 1
				if (OHCI_ITD_GET_CC(le32toh(sitd->
d1442 1
a1442 1
					iframes = OHCI_ITD_GET_FC(le32toh(
d1445 1
a1445 1
						len = le16toh(sitd->
d1525 1
a1525 1
		data->td.td_be = htole32(le32toh(data->td.td_cbp) +
d1688 1
a1688 1
	 (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
d1715 1
a1715 1
	setup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);
d1939 1
a1939 1
	bitmask_snprintf((u_int32_t)le32toh(std->td.td_flags),
d1946 6
a1951 6
	       OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
	       (u_long)le32toh(std->td.td_cbp),
	       (u_long)le32toh(std->td.td_nexttd),
	       (u_long)le32toh(std->td.td_be));
d1962 7
a1968 7
	       OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
	       (u_long)le32toh(sitd->itd.itd_bp0),
	       (u_long)le32toh(sitd->itd.itd_nextitd),
	       (u_long)le32toh(sitd->itd.itd_be));
d1971 1
a1971 1
		       (u_int)le16toh(sitd->itd.itd_offset[i]));
d1987 1
a1987 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_flags),
d1990 1
a1990 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_headp),
d1996 6
a2001 6
	       OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
	       (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
	       (u_long)le32toh(sed->ed.ed_headp),
	       (u_long)le32toh(sed->ed.ed_nexted));
d2133 2
a2134 2
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {
d2136 1
a2136 1
		std = ohci_hash_find_td(sc, le32toh(sed->ed.ed_headp));
d2139 2
a2140 2
		       (int)le32toh(sed->ed.ed_headp),
		       (int)le32toh(sed->ed.ed_tailp),
d2151 2
a2152 2
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
		    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
d2161 1
a2161 1
	    (le32toh(sed->ed.ed_headp) & OHCI_TOGGLECARRY) ? 1 : 0;
d2250 1
a2250 1
	headp = le32toh(sed->ed.ed_headp) & OHCI_HEADMASK;
d2255 1
a2255 1
		if (OHCI_TD_GET_CC(le32toh(p->td.td_flags)) ==
d2262 1
a2262 1
			    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
d2884 1
a2884 1
		(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |
d2904 4
a2907 4
		    (int)le32toh(sed->ed.ed_flags),
		    (int)le32toh(data->td.td_flags),
		    (int)le32toh(data->td.td_cbp),
		    (int)le32toh(data->td.td_be)));
d3027 1
a3027 1
	data->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);
d3093 2
a3094 2
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
d3226 1
a3226 1
		iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;
d3302 1
a3302 1
			 le32toh(sc->sc_hcca->hcca_frame_number)));
d3318 1
a3318 1
			 le32toh(sc->sc_hcca->hcca_frame_number)));
@


1.76
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.

This time without accidentally leaving the OHCI controller shutdown, and with
some cosmetic fixes.

ok dlg@@, OHCI tests mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.75 2007/03/18 20:14:51 mglocker Exp $ */
d75 2
a76 2
#define DPRINTF(x)	do { if (ohcidebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (ohcidebug>(n)) logprintf x; } while (0)
@


1.75
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.73 2006/06/23 06:27:11 miod Exp $ */
d614 1
a614 1
ohci_init(ohci_softc_t *sc)
d616 1
a616 4
	ohci_soft_ed_t *sed, *psed;
	usbd_status err;
	int i;
	u_int32_t s, ctl, rwc, ival, hcr, fm, per, rev, desca, descb;
a617 1
	DPRINTF(("ohci_init: start\n"));
d631 42
d761 2
a762 18
		/* SMM active, request change */
		DPRINTF(("ohci_init: SMM active, request owner change\n"));
		if ((sc->sc_intre & (OHCI_OC | OHCI_MIE)) == 
		    (OHCI_OC | OHCI_MIE))
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_MIE);
		s = OREAD4(sc, OHCI_COMMAND_STATUS);
		OWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);
		for (i = 0; i < 100 && (ctl & OHCI_IR); i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			ctl = OREAD4(sc, OHCI_CONTROL);
		}
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_MIE);
		if (ctl & OHCI_IR) {
			printf("%s: SMM does not respond, resetting\n",
			       USBDEVNAME(sc->sc_bus.bdev));
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET | rwc);
			goto reset;
		}
@


1.74
log
@Perform legacy emulation handover for USB1 companion controllers immediately
but defer the remainder of their initialisation until after the other devices
on their PCI bus have attached.  This ensures that any USB2 controller has also
completed its initialisation before we start to initialise the USB1 parts.

This minimises the chance that a nasty SMM implementation will trash the USB1
controller's config when it performs legacy emulation handover of the USB2 part.
@
text
@d619 1
a619 1
	u_int32_t ctl, rwc, ival, hcr, fm, per, rev, desca, descb;
d721 1
a721 1
	/* SMM handover performed by the PCI code didn't work? */
d723 18
a740 4
		printf("%s: SMM does not respond, resetting\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET | rwc);
		goto reset;
@


1.73
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.72 2006/05/31 06:18:09 pascoe Exp $ */
d619 1
a619 1
	u_int32_t s, ctl, rwc, ival, hcr, fm, per, rev, desca, descb;
d721 1
a721 1
	/* Determine in what context we are running. */
d723 4
a726 18
		/* SMM active, request change */
		DPRINTF(("ohci_init: SMM active, request owner change\n"));
		if ((sc->sc_intre & (OHCI_OC | OHCI_MIE)) == 
		    (OHCI_OC | OHCI_MIE))
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE, OHCI_MIE);
		s = OREAD4(sc, OHCI_COMMAND_STATUS);
		OWRITE4(sc, OHCI_COMMAND_STATUS, s | OHCI_OCR);
		for (i = 0; i < 100 && (ctl & OHCI_IR); i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			ctl = OREAD4(sc, OHCI_CONTROL);
		}
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_MIE);
		if (ctl & OHCI_IR) {
			printf("%s: SMM does not respond, resetting\n",
			       USBDEVNAME(sc->sc_bus.bdev));
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET | rwc);
			goto reset;
		}
@


1.72
log
@Save and restore the data toggle value when a pipe to an endpoint
is closed and then reopened.  This may be necessary now that
we no longer clear endpoint stalls every time a pipe is opened.
Previously we could assume an initial toggle value of zero because
a clear-stall operation resets the device's toggle state.

Derived from work in FreeBSD.

This is most likely to affect devices like printers, which open
pipes for short periods of time and close them again.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.71 2006/05/29 03:49:22 pascoe Exp $ */
d321 1
a321 1
		return (EOPNOTSUPP);
@


1.71
log
@Correct status value check for OHCI isoc transfer;
the spec says that "not accessed" is 111x, not 1111.

From NetBSD rev1.158
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.70 2006/05/29 03:35:31 pascoe Exp $ */
d2050 3
a2052 1
		sed->ed.ed_headp = sed->ed.ed_tailp = htole32(tdphys);
d2138 2
@


1.70
log
@Only check USBD_FORCE_SHORT_XFER for writes.

From NetBSD rev1.164
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.69 2006/05/29 03:31:29 pascoe Exp $ */
d1425 6
a1430 4
						len =
						    (OHCI_ITD_PSW_GET_CC(len) ==
						    OHCI_CC_NOT_ACCESSED) ? 0 :
						    OHCI_ITD_PSW_LENGTH(len);
@


1.69
log
@Only do the software part of an abort if we are dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.68 2006/05/22 15:52:48 krw Exp $ */
d507 1
a507 1
	if ((flags & USBD_FORCE_SHORT_XFER) &&
@


1.68
log
@Expunge all #if defined(__NetBSD__) and #if defined(__FreeBSD__) crud.
Misused in many cases anyway.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.67 2006/05/22 15:26:07 krw Exp $ */
d2167 1
@


1.67
log
@Don't call shutdownhook_disestablish() unless there is a shutdownhook
established. Should fix PR #5128.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.66 2006/05/04 14:21:30 jolan Exp $ */
a51 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a54 9
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <machine/bus_pio.h>
#include <machine/bus_memio.h>
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
#include <machine/cpu.h>
#endif
#endif
a69 7
#if defined(__FreeBSD__)
#include <machine/clock.h>

#define delay(d)                DELAY(d)
#endif

#if defined(__OpenBSD__)
a72 1
#endif
a77 1
#ifndef __NetBSD__
a78 1
#endif
a87 9
#if defined(__FreeBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
#endif
a312 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a344 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a346 1
#endif
a353 1
#endif
a621 1
#if defined(__OpenBSD__)
a622 3
#else
	printf("%s:", USBDEVNAME(sc->sc_bus.bdev));
#endif
a840 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a842 1
#endif
a868 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a869 1
#endif
a876 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a877 1
#endif
a1012 6
#if defined(__NetBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
@


1.66
log
@fix interrupt out transfers

from netbsd, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.65 2005/12/03 03:40:52 brad Exp $ */
d376 2
a377 1
	shutdownhook_disestablish(sc->sc_shutdownhook);
@


1.65
log
@Allow strings descriptor 0 to be fetched.  It's the default language index.

From augustss NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.64 2005/11/21 18:16:42 millert Exp $ */
d3013 1
a3013 2
	int len;
	int s;
d3028 2
d3038 2
a3039 1
		OHCI_TD_IN | OHCI_TD_NOCC |
@


1.64
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.63 2005/11/15 07:02:37 miod Exp $ */
d2479 3
@


1.63
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.62 2005/10/04 22:55:30 brad Exp $ */
d55 1
a55 1
#include <sys/select.h>
@


1.62
log
@Make sure we don't enable host controller interrupts until all
initialization is finished.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.61 2005/04/21 12:30:02 pascoe Exp $ */
d2312 1
a2312 1
	1,2,0,			/* string indicies */
@


1.61
log
@If the SMM driver had enabled ownership change interrupts, re-enable them
temporarily before we attempt to take control.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.60 2005/04/21 10:00:30 pascoe Exp $ */
a829 1
	OWRITE4(sc, OHCI_INTERRUPT_ENABLE, sc->sc_eintrs | OHCI_MIE);
d883 4
@


1.60
log
@Preserve any configuration data that may have been set by SMM/BIOS over
chip reset.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.58 2005/03/30 14:12:35 dlg Exp $ */
d761 3
d770 1
@


1.59
log
@Fix inverted logic when testing for successful SMM handover.
@
text
@d651 1
a651 1
	u_int32_t s, ctl, ival, hcr, fm, per, rev, desca;
d750 6
a757 1
	ctl = OREAD4(sc, OHCI_CONTROL);
d770 1
a770 1
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
d779 1
a779 1
			OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_OPERATIONAL);
d795 1
a795 1
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
a798 1
	ival = OHCI_GET_IVAL(OREAD4(sc, OHCI_FM_INTERVAL));
d831 1
a831 1
		OHCI_RATIO_1_4 | OHCI_HCFS_OPERATIONAL;
d840 1
a847 1
	desca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
d852 2
@


1.58
log
@restore all of the registers on resume to cope with power loss during
suspend which leaves the controller totally unconfigured.

help from and ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.57 2005/03/30 14:02:03 dlg Exp $ */
d762 1
a762 1
		if ((ctl & OHCI_IR) == 0) {
@


1.57
log
@make the powerhooks the responsibility of the bus ohci is attached to

ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.56 2005/03/30 03:01:55 pascoe Exp $ */
d977 1
a977 1
	u_int32_t ctl;
d990 1
a990 1
		ctl = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
d996 1
a996 1
			sc->sc_control = ctl;
d998 2
d1001 2
a1002 2
		ctl |= OHCI_HCFS_SUSPEND;
		OWRITE4(sc, OHCI_CONTROL, ctl);
d1008 1
d1015 1
a1015 1
				sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
d1017 1
a1017 1
			ctl = sc->sc_control;
d1019 3
a1021 3
			ctl = OREAD4(sc, OHCI_CONTROL);
		ctl |= OHCI_HCFS_RESUME;
		OWRITE4(sc, OHCI_CONTROL, ctl);
d1023 15
a1037 2
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, OHCI_CONTROL, ctl);
d1039 1
a1039 1
		sc->sc_control = sc->sc_intre = 0;
@


1.56
log
@Use the inverse of the T bit in the HcFmRemaining register when adjusting
the frame length.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.55 2005/03/06 06:51:53 pascoe Exp $ */
a137 1
Static void		ohci_power(int, void *);
a375 1
	powerhook_disestablish(sc->sc_powerhook);
a869 1
	sc->sc_powerhook = powerhook_establish(ohci_power, sc);
@


1.55
log
@Wait for the bulk transfer to complete before returning if we are in polled
mode.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.54 2005/03/06 05:30:07 pascoe Exp $ */
d838 1
a838 1
	fm = (OREAD4(sc, OHCI_FM_INTERVAL) & OHCI_FIT) ^ OHCI_FIT;
@


1.54
log
@ohci_rhsc_enable calls usb_transfer_complete via ohci_rhsc - we need to be
at splusb, not splsoftclock.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.53 2005/03/06 05:12:00 pascoe Exp $ */
d2784 1
d2932 3
@


1.53
log
@In [eo]hci_waitintr, xfer->timeout is in ms, not hz.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.52 2004/12/26 22:41:40 miod Exp $ */
d1225 1
a1229 1
	s = splhardusb();
@


1.52
log
@strored -> stored
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.51 2004/09/30 11:33:56 dlg Exp $ */
d1595 1
a1595 2
	int timo = xfer->timeout;
	int usecs;
d1599 1
a1599 1
	for (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {
@


1.51
log
@spelling nit
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.50 2004/09/11 03:33:40 dlg Exp $ */
d106 1
a106 1
 * the data strored in memory needs to be swapped.
@


1.50
log
@backout 1.48, but maintain the fix for the merge error.

fixes hangs/crashes on detach of various devices.

found by jolan@@, tested by drahn@@ and jolan@@, ok by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.49 2004/08/11 04:18:34 dlg Exp $ */
d973 1
a973 1
 * called from an intterupt context.  This is all right since we
@


1.49
log
@from netbsd-bugs, pr 26547:

Transfers should only be removed if they haven't already completed
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.48 2004/08/11 04:17:22 dlg Exp $ */
d1344 1
a1344 3

		if (std->flags & OHCI_CALL_DONE)
			usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
@


1.48
log
@Fixes a merge error as well as being from netbsd-bugs, pr 26546:

The cancellation of the timeout in ohci_softintr should predicate on the
transfer being the last of the batch
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.47 2004/08/11 04:15:10 dlg Exp $ */
d2251 3
a2253 1
		ohci_free_std(sc, p);
@


1.47
log
@from netbsd-bugs, pr 26545:

It's possible that the ohci interrupt can reach the CPU before the write
over PCI. This results in the done head pointer being NULL. If the
subsequent read of the interrupt status indicates that an OHCI_WDH has
occured then the done pointer should be reread and the pointer nulled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.46 2004/08/11 04:12:43 dlg Exp $ */
d1345 3
a1356 1
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
@


1.46
log
@from netbsd, ohci.c 1.140, 1.143, 1.148, 1.149, 1.150
log message for 1.140:
Function names printed in debug messages did not always match the
actual name of the function.

log message for 1.143:
Remove assigned-to but otherwise unused variables.
Remove unreachable break after return statements.

log message for 1.148:
Adjust a couple of comments to make it clear WTF is going on.

log message for 1.149:
Make one message dependent on ohcidebug, so it doesn't interfere with polled
operation; e.g. when entering a root device or in DDB.

log message for 1.150:
Fix an error in a printf() format.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.45 2004/08/11 04:07:04 dlg Exp $ */
d1129 8
a1136 2
	} else
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS) & ~OHCI_WDH;
@


1.45
log
@from netbsd, ohci.c 1.151

Avoid touching the xfer after calling usb_transfer_complete(), as the
driver callback may have recycled it.  From PR 25960.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.44 2004/08/11 04:05:29 dlg Exp $ */
a352 1
		break;
d1096 2
a1097 1
			printf("ohci_intr: ignored interrupt while polling\n");
d1479 1
a1479 1
	DPRINTFN(10,("ohci_ctrl_done: xfer=%p\n", xfer));
d1483 1
a1483 1
		panic("ohci_ctrl_done: not a request");
d1497 2
a1498 2
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n",
		     xfer, xfer->actlen));
d1533 2
a1534 2
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n",
		     xfer, xfer->actlen));
a1540 1
	struct ohci_pipe *opipe;
a1554 1
	opipe = (struct ohci_pipe *)pipe;
d1676 2
a1677 1
	/* Update device address and length since they may have changed. */
d2247 1
a2247 1
		DPRINTFN(1,("ohci_abort_xfer: set hd=0x08%x, tl=0x%08x\n",
@


1.44
log
@from netbsd, ohci.c 1.150

swap the order that two items are written; possibly fixes a race
condition that would affect isoc transfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.43 2004/08/11 04:03:15 dlg Exp $ */
d1457 1
a1485 1
	xfer->hcpriv = NULL;
a1499 2
	xfer->hcpriv = NULL;

a1534 2

	xfer->hcpriv = NULL;
a1575 1
	xfer->hcpriv = NULL;
a1580 1
	xfer->hcpriv = NULL;
a3383 1

a3384 2

	xfer->hcpriv = NULL;
@


1.43
log
@from netbsd, ohci.c 1.142 1.147
log message for 1.142:
Fix a done list handling bug which exhibits under high shared interrupt
rate and bus traffic.  As the interrupt register is read after checking
hcca_done_head, there was a small chance of dropping a done list.
Ignore OHCI_WDH interrupt bit if hcca_done_head is zero so that OHCI_WDH
is processed later.

log message for 1.147:
Failure to properly mask off UE_DIR_IN from the endpoint address was
causing OHCI_ED_FORMAT_ISO and EHCI_QH_HRECL to get set spuriously,
causing rather interesting lossage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.42 2004/08/11 04:01:41 dlg Exp $ */
d3293 1
a3295 1
	sed->ed.ed_tailp = htole32(nsitd->physaddr);
@


1.42
log
@from netbsd, ohci.c 1.141

Update actlen even in the case where a TD returns an error -- this is
critical for the umass bulk-only STALL case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.41 2004/07/11 05:29:16 deraadt Exp $ */
d1130 1
a1130 1
		intrs = OREAD4(sc, OHCI_INTERRUPT_STATUS);
d2069 1
a2069 1
			OHCI_ED_SET_EN(ed->bEndpointAddress) |
@


1.41
log
@from netbsd via loki@@animata.net
uhub.c revision 1.65, ohci.c revision 1.146, uhci.c revision 1.177
Use the correct wValue to get hub desriptors.
Also, make wValue checks of root hub codes less strict.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.40 2004/07/10 12:59:57 ho Exp $ */
d1338 10
a1350 8
			len = std->len;
			if (std->td.td_cbp != 0)
				len -= le32toh(std->td.td_be) -
				       le32toh(std->td.td_cbp) + 1;
			DPRINTFN(10, ("ohci_process_done: len=%d, flags=0x%x\n",
				      len, std->flags));
			if (std->flags & OHCI_ADD_LEN)
				xfer->actlen += len;
@


1.40
log
@Avoid looping messages during boot. Tested by various people. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.39 2004/07/08 22:18:44 deraadt Exp $ */
d2565 1
a2565 1
		if (value != 0) {
@


1.39
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.38 2004/05/04 16:59:32 grange Exp $ */
d1092 1
a1092 1
	if (sc->sc_bus.use_polling) {
d1094 4
a1097 1
		printf("ohci_intr: ignored interrupt while polling\n");
@


1.38
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.37 2004/01/26 20:10:22 deraadt Exp $ */
d93 2
a94 2
#define DPRINTF(x)	if (ohcidebug) logprintf x
#define DPRINTFN(n,x)	if (ohcidebug>(n)) logprintf x
@


1.37
log
@shorter message
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.36 2003/08/06 20:40:30 millert Exp $ */
d923 1
a923 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
@


1.36
log
@The cleanup in ohci_init() is wrong; the statements for label bad2
and label bad3 should be swapped.  From Patrick Latifi
ok deraadt@@ and fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.35 2003/07/08 13:19:09 nate Exp $ */
d663 1
a663 1
	printf(" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
@


1.35
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.34 2003/05/19 04:17:53 nate Exp $ */
d887 2
a889 2
 bad2:
	ohci_free_sed(sc, sc->sc_bulk_head);
@


1.34
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.33 2003/05/17 11:19:24 todd Exp $ */
/*	$NetBSD: ohci.c,v 1.104 2001/09/28 23:57:21 augustss Exp $	*/
d204 1
a204 1
Static int		ohci_str(usb_string_descriptor_t *, int, char *);
d207 1
d209 1
a209 1
Static void		ohci_rhsc_enable(void *sc);
a212 1
Static void		ohci_abort_xfer_end(void *);
d375 2
d382 2
d406 2
a407 2
			sed = (ohci_soft_ed_t *)((char *)KERNADDR(&dma) +offs);
			sed->physaddr = DMAADDR(&dma) + offs;
d444 2
a445 2
			std = (ohci_soft_td_t *)((char *)KERNADDR(&dma) +offs);
			std->physaddr = DMAADDR(&dma) + offs;
d492 1
a492 1
	dataphys = DMAADDR(dma);
d598 1
d601 2
a602 2
			sitd = (ohci_soft_itd_t *)((char *)KERNADDR(&dma)+offs);
			sitd->physaddr = DMAADDR(&dma) + offs;
d606 1
d637 2
a647 9
void
ohci_reset(ohci_softc_t *sc)
{
	ohci_shutdown(sc);
	/* disable all interrupts and then switch on all desired
           interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
}

d687 1
a687 1
	sc->sc_hcca = (struct ohci_hcca *)KERNADDR(&sc->sc_hccadma);
d820 1
a820 1
	OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));
d876 1
d922 1
a922 1
	if (xfer != NULL)
d924 15
a938 4
	else
		xfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		memset(xfer, 0, sizeof *xfer);
d947 8
d1011 1
a1011 1
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));
d1088 3
d1108 2
d1125 1
d1152 1
a1152 1
		intrs &= ~OHCI_SO;
a1155 1
		sc->sc_hcca->hcca_done_head = 0;
d1157 1
a1157 1
		intrs &= ~OHCI_WDH;
a1170 2
		intrs &= ~OHCI_RHSC;

d1176 3
d1180 2
a1181 1
		usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
d1186 7
a1192 3
	/* Block unprocessed interrupts. XXX */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);
	sc->sc_eintrs &= ~intrs;
d1214 1
d1216 5
d1222 1
d1290 1
d1292 3
d1305 1
a1305 1
	DPRINTFN(10,("ohci_process_done: sdone=%p sidone=%p\n", sdone, sidone));
d1320 2
a1321 1
			/* xfer == NULL: There seems to be no xfer associated
d1324 1
d1348 1
d1350 1
d1360 1
a1360 2
			struct ohci_pipe *opipe =
				(struct ohci_pipe *)xfer->pipe;
d1380 1
d1382 1
d1388 1
a1388 1
		DPRINTF(("ohci_process_done: ITD done:\n"));
d1412 35
a1446 11
		cc = OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags));
		if (cc == OHCI_CC_NO_ERROR) {
			/* XXX compute length for input */
			struct ohci_pipe *opipe =
				(struct ohci_pipe *)xfer->pipe;
			if (sitd->flags & OHCI_CALL_DONE) {
				opipe->u.iso.inuse -= xfer->nframes;
				/* XXX update frlengths with actual length */
				/* XXX xfer->actlen = actlen; */
				xfer->status = USBD_NORMAL_COMPLETION;
				usb_transfer_complete(xfer);
d1448 6
a1453 3
		} else {
			/* XXX Do more */
			xfer->status = USBD_IOERROR;
d1455 1
d1459 7
d1467 1
d1511 1
a1511 1
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d1557 1
a1557 1
	p = KERNADDR(&xfer->dmabuf);
d1599 2
d1625 9
d1703 1
a1703 1
	memcpy(KERNADDR(&opipe->u.ctl.reqdma), req, sizeof *req);
d1707 1
a1707 1
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));
d1741 1
a1741 1
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d1746 2
a1747 2
#if 0
	if (ohcidebug > 10) {
d1751 4
d1776 2
d1796 1
a1796 1
	for (p = head; p == NULL && p->next != sed; p = p->next)
d1892 19
d1914 1
a1914 1
	DPRINTF(("ohci_timeout: xfer=%p\n", xfer));
a1916 1
	xfer->device->bus->intr_context++;
a1917 1
	xfer->device->bus->intr_context--;
d1934 1
a1934 1
	bitmask_snprintf((int)le32toh(std->td.td_flags),
d1938 9
a1946 9
	DPRINTF(("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
		 "nexttd=0x%08lx be=0x%08lx\n",
		 std, (u_long)std->physaddr, sbuf,
		 OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
		 (u_long)le32toh(std->td.td_cbp),
		 (u_long)le32toh(std->td.td_nexttd),
		 (u_long)le32toh(std->td.td_be)));
d1954 10
a1963 10
	DPRINTF(("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
		 sitd, (u_long)sitd->physaddr,
		 OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
		 (u_long)le32toh(sitd->itd.itd_bp0),
		 (u_long)le32toh(sitd->itd.itd_nextitd),
		 (u_long)le32toh(sitd->itd.itd_be)));
d1965 3
a1967 3
		DPRINTF(("offs[%d]=0x%04x ", i,
			 (u_int)le16toh(sitd->itd.itd_offset[i])));
	DPRINTF(("\n"));
d1982 1
a1982 1
	bitmask_snprintf((int)le32toh(sed->ed.ed_flags),
d1985 1
a1985 1
	bitmask_snprintf((u_long)le32toh(sed->ed.ed_headp),
d1988 9
a1996 9
	DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %s\ntailp=0x%08lx "
		 "headflags=%s headp=0x%08lx nexted=0x%08lx\n",
		 sed, (u_long)sed->physaddr,
		 OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
		 (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
		 (u_long)le32toh(sed->ed.ed_headp),
		 (u_long)le32toh(sed->ed.ed_nexted)));
d2021 3
d2056 1
a2056 2
			if (std == NULL) {
				ohci_free_std(sc, std);
a2057 1
			}
d2065 2
a2066 2
			(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |
			OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
a2127 1
		ohci_physaddr_t td = le32toh(sed->ed.ed_headp);
d2129 1
a2129 5
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]);
		     std != NULL;
		     std = LIST_NEXT(std, hnext))
		    if (std->physaddr == td)
			break;
d2135 8
d2150 2
d2170 8
a2177 1
	ohci_soft_ed_t *sed;
d2179 8
a2186 1
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p\n", xfer, opipe));
d2188 2
a2189 1
	xfer->status = status;
d2191 5
d2197 1
a2197 2

	sed = opipe->sed;
d2201 6
a2206 29
#if 1
	if (xfer->device->bus->intr_context) {
		/* We have no process context, so we can't use tsleep(). */
		usb_callout(xfer->pipe->abort_handle,
		    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);
	} else {
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
		KASSERT(intr_nesting_level == 0,
	        	("ohci_abort_req in interrupt context"));
#endif
		usb_delay_ms(opipe->pipe.device->bus, 1);
		ohci_abort_xfer_end(xfer);
	}
#else
	delay(1000);
	ohci_abort_xfer_end(xfer);
#endif
}

void
ohci_abort_xfer_end(void *v)
{
	usbd_xfer_handle xfer = v;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_td_t *p, *n;
	int s;

d2208 8
d2217 8
d2229 1
a2229 1
		printf("ohci_abort_xfer: hcpriv==0\n");
d2233 9
d2243 1
d2247 8
d2256 3
a2258 4
	sed = opipe->sed;
	DPRINTFN(2,("ohci_abort_xfer: set hd=%x, tl=%x\n",
		    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
	sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
d2261 3
d2278 1
a2278 1
	0,			/* protocol */
d2306 1
a2306 1
	0,
d2330 1
a2330 4
ohci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d2394 1
a2394 1
		buf = KERNADDR(&xfer->dmabuf);
d2633 7
a2639 2
			for (i = 0; i < 10; i++) {
				usb_delay_ms(&sc->sc_bus, 10); /* XXX */
d2910 1
a2910 1
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d3003 1
a3003 1
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d3211 1
a3211 1
	buf = DMAADDR(&xfer->dmabuf);
d3289 1
d3317 1
a3317 1
		printf("uhci_device_isoc_start: not in progress %p\n", xfer);
a3384 3
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_itd_t *sitd, *nsitd;
a3387 8
	for (sitd = xfer->hcpriv;
	     !(sitd->flags & OHCI_CALL_DONE);
	     sitd = nsitd) {
		nsitd = sitd->nextitd;
		DPRINTFN(1,("ohci_device_isoc_done: free sitd=%p\n", sitd));
		ohci_free_sitd(sc, sitd);
	}
	ohci_free_sitd(sc, sitd);
a3413 1
	int s;
a3415 4

	s = splusb();
	ohci_rem_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);
@


1.33
log
@try a little harder to not end up with 0 usb ports on amd756 chipsets
ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.32 2002/10/12 01:09:44 krw Exp $ */
d46 1
a46 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
@


1.32
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.31 2002/08/07 18:57:00 mickey Exp $ */
d857 5
a861 2
	usb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);
	sc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));
@


1.31
log
@fix the stupidest alloc/free piece of code ever; nate@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.30 2002/07/09 18:19:58 nate Exp $ */
d513 1
a513 1
				panic("ohci_alloc_std: curlen == 0\n");
d628 1
a628 1
		panic("ohci_free_sitd: sitd=%p not done\n", sitd);
d1230 1
a1230 1
		panic("ohci_add_done: addr 0x%08lx not found\n", (u_long)done);
d1392 1
a1392 1
		panic("ohci_ctrl_done: not a request\n");
d1697 1
a1697 1
		panic("ohci_rem_ed: ED not found\n");
d2828 1
a2828 1
		panic("ohci_device_intr_transfer: a request\n");
d2921 1
a2921 1
		panic("ohci_device_intr_close: ED not found\n");
@


1.30
log
@kill trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.29 2002/06/07 22:26:34 miod Exp $ */
d1923 1
a1923 2
			if (sitd == NULL) {
				ohci_free_sitd(sc, sitd);
a1924 1
			}
@


1.29
log
@Fix more timeout handling issues in ohci. There are still cursed harrdware
that will keep dying with this applied, though.
Discussed with drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.28 2002/05/07 18:29:18 nate Exp $ */
d201 1
a201 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc, 
d239 1
a239 1
Static u_int8_t revbits[OHCI_NO_INTRS] = 
d289 1
a289 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {	
d298 1
a298 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {	
d307 1
a307 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {	
d316 1
a316 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {	
d325 1
a325 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {	
d371 1
a371 1
	
d491 1
a491 1
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | 
d507 1
a507 1
			curlen = 2 * OHCI_PAGE_SIZE - 
d568 1
a568 1
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std, 
d668 1
a668 1
		printf("%s: unsupported OHCI revision\n", 
d684 1
a684 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, 
d736 1
a736 1
	/* 
d741 1
a741 1
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] = 
d864 1
a864 1
	
d1074 1
a1074 1
	return (ohci_intr1(sc)); 
d1112 1
a1112 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n", 
d1146 1
a1146 1
		/* 
d1312 1
a1312 1
			struct ohci_pipe *opipe = 
d1366 1
a1366 1
			struct ohci_pipe *opipe = 
d1407 1
a1407 1
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n", 
d1420 1
a1420 1
		
d1422 1
a1422 1
			OHCI_TD_IN | OHCI_TD_NOCC | 
d1445 1
a1445 1
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n", 
d1461 1
a1461 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n", 
d1564 1
a1564 1
		    UGETW(req->wIndex), len, addr, 
d1689 1
a1689 1
	ohci_soft_ed_t *p; 
d1739 1
a1739 1
	for (std = LIST_FIRST(&sc->sc_hash_tds[h]); 
d1755 1
a1755 1
	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n", 
d1767 1
a1767 1
	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n", 
d1779 1
a1779 1
	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]); 
d1820 1
a1820 1
		 "nexttd=0x%08lx be=0x%08lx\n", 
d1836 1
a1836 1
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n", 
d1871 1
a1871 1
		 sed, (u_long)sed->physaddr, 
d1945 1
a1945 1
			OHCI_ED_SET_FA(addr) | 
d1954 2
a1955 2
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
d1990 1
a1990 1
	
d2008 1
a2008 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
d2012 1
a2012 1
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); 
d2023 1
a2023 1
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
d2033 1
a2033 1
/* 
d2234 1
a2234 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n", 
d2249 1
a2249 1
		/* 
d2418 1
a2418 1
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : 
d2424 1
a2424 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) 
d2577 1
a2577 1
	
d2780 1
a2780 1
/* 
d2842 1
a2842 1
		OHCI_TD_IN | OHCI_TD_NOCC | 
d2915 1
a2915 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
d2978 1
a2978 1
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n", 
d3034 1
a3034 1
	ohci_soft_itd_t *sitd, *nsitd;	
d3049 1
a3049 1
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n", 
d3063 1
a3063 1
			
d3075 1
a3075 1
				OHCI_ITD_NOCC | 
d3087 1
a3087 1
			iso->next = iso->next + ncur; 
d3097 1
a3097 1
		printf("%s: isoc TD alloc failed\n", 
d3103 1
a3103 1
		OHCI_ITD_NOCC | 
d3181 1
a3181 1
	if (xfer->status != USBD_NOT_STARTED && 
d3229 1
a3229 1
	ohci_soft_itd_t *sitd, *nsitd;	
@


1.28
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.26 2002/05/02 20:08:04 nate Exp $ */
d874 1
a874 3
#if defined(__OpenBSD__)
	timeout_set(&sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);
#endif
a1150 1
#if defined (__OpenBSD__)
d1152 1
a1152 2
		timeout_add(&sc->sc_tmo_rhsc, hz);
#endif
@


1.27
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: ohci.c,v 1.122 2002/03/17 18:02:52 augustss Exp $	*/
d201 1
a201 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc,
d204 1
a204 1
Static int		ohci_str(usb_string_descriptor_t *, int, const char *);
a206 1
Static void		ohci_timeout_task(void *);
d208 1
a208 1
Static void		ohci_rhsc_enable(void *);
d212 1
d239 1
a239 1
Static u_int8_t revbits[OHCI_NO_INTRS] =
d289 1
a289 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {
d298 1
a298 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {
d307 1
a307 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {
d316 1
a316 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {
d325 1
a325 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {
d371 1
a371 1

a374 2
	usb_uncallout(sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);

a379 2
	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

d491 1
a491 1
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
d507 1
a507 1
			curlen = 2 * OHCI_PAGE_SIZE -
d568 1
a568 1
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std,
d640 9
d668 1
a668 1
		printf("%s: unsupported OHCI revision\n",
d684 1
a684 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE,
d736 1
a736 1
	/*
d741 1
a741 1
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] =
d864 1
a864 1

a877 2
	usb_callout_init(sc->sc_tmo_rhsc);

d921 1
a921 1
	if (xfer != NULL) {
d923 4
a926 15
#ifdef DIAGNOSTIC
		if (xfer->busy_free != XFER_FREE) {
			printf("ohci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct ohci_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct ohci_xfer));
#ifdef DIAGNOSTIC
		xfer->busy_free = XFER_BUSY;
#endif
	}
a934 8
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
		return;
	}
	xfer->busy_free = XFER_FREE;
#endif
a1067 3
	if (sc == NULL || sc->sc_dying)
		return (0);

d1071 1
a1071 5
		static int repeat = 0;
		if (repeat < 10) {
			printf("ohci_intr: ignored interrupt while polling\n");
			++repeat;
		}
d1076 1
a1076 1
	return (ohci_intr1(sc));
a1084 2
	DPRINTFN(14,("ohci_intr1: enter\n"));

d1114 1
a1114 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1126 1
a1126 1
		eintrs &= ~OHCI_SO;
d1132 1
a1132 1
		eintrs &= ~OHCI_WDH;
d1146 3
a1148 1
		/*
d1153 1
a1153 3
		DPRINTFN(2, ("%s: rhsc interrupt disabled\n",
			     USBDEVNAME(sc->sc_bus.bdev)));

d1155 2
a1156 2
                usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
		eintrs &= ~OHCI_RHSC;
d1161 3
a1163 7
	if (eintrs != 0) {
		/* Block unprocessed interrupts. XXX */
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, eintrs);
		sc->sc_eintrs &= ~eintrs;
		printf("%s: blocking intrs 0x%x\n",
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
	}
a1185 4
	ohci_rhsc(sc, sc->sc_intrxfer);
	DPRINTFN(2, ("%s: rhsc interrupt enabled\n",
		     USBDEVNAME(sc->sc_bus.bdev)));

a1255 2
	DPRINTFN(10,("ohci_softintr: enter\n:"));

d1265 1
a1265 1
	DPRINTFN(10,("ohci_softintr: sdone=%p sidone=%p\n", sdone, sidone));
d1280 1
a1280 2
			/*
			 * xfer == NULL: There seems to be no xfer associated
a1282 1
			 * Shouldn't happen, but some chips are broken(?).
d1316 1
a1316 1
			struct ohci_pipe *opipe =
d1343 1
a1343 1
		DPRINTF(("ohci_softintr: ITD done:\n"));
d1370 1
a1370 1
			struct ohci_pipe *opipe =
a1385 5
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}

a1386 1
	DPRINTFN(10,("ohci_softintr: done:\n"));
d1411 1
a1411 1
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n",
d1424 1
a1424 1

d1426 1
a1426 1
			OHCI_TD_IN | OHCI_TD_NOCC |
d1449 1
a1449 1
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n",
d1465 1
a1465 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n",
a1517 2
		if (sc->sc_dying)
			break;
a1541 9
#ifdef OHCI_DEBUG
	static int last;
	int new;
	new = OREAD4(sc, OHCI_INTERRUPT_STATUS);
	if (new != last) {
		DPRINTFN(10,("ohci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif
d1568 1
a1568 1
		    UGETW(req->wIndex), len, addr,
d1654 2
a1655 2
#ifdef OHCI_DEBUG
	if (ohcidebug > 20) {
a1658 4
		ohci_dumpregs(sc);
		printf("ctrl head:\n");
		ohci_dump_ed(sc->sc_ctrl_head);
		printf("sed:\n");
a1679 2
	DPRINTFN(8,("ohci_add_ed: sed=%p head=%p\n", sed, head));

d1693 1
a1693 1
	ohci_soft_ed_t *p;
d1743 1
a1743 1
	for (std = LIST_FIRST(&sc->sc_hash_tds[h]);
d1759 1
a1759 1
	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n",
d1771 1
a1771 1
	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n",
d1783 1
a1783 1
	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]);
a1793 19
	struct ohci_xfer *oxfer = addr;
	struct ohci_pipe *opipe = (struct ohci_pipe *)oxfer->xfer.pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

	DPRINTF(("ohci_timeout: oxfer=%p\n", oxfer));

	if (sc->sc_dying) {
		ohci_abort_xfer(&oxfer->xfer, USBD_TIMEOUT);
		return;
	}

	/* Execute the abort in a process context. */
	usb_init_task(&oxfer->abort_task, ohci_timeout_task, addr);
	usb_add_task(oxfer->xfer.pipe->device, &oxfer->abort_task);
}

void
ohci_timeout_task(void *addr)
{
d1797 1
a1797 1
	DPRINTF(("ohci_timeout_task: xfer=%p\n", xfer));
d1800 1
d1802 1
d1819 1
a1819 1
	bitmask_snprintf((u_int32_t)le32toh(std->td.td_flags),
d1823 9
a1831 9
	printf("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
	       "nexttd=0x%08lx be=0x%08lx\n",
	       std, (u_long)std->physaddr, sbuf,
	       OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
	       (u_long)le32toh(std->td.td_cbp),
	       (u_long)le32toh(std->td.td_nexttd),
	       (u_long)le32toh(std->td.td_be));
d1839 10
a1848 10
	printf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
	       "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
	       sitd, (u_long)sitd->physaddr,
	       OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
	       (u_long)le32toh(sitd->itd.itd_bp0),
	       (u_long)le32toh(sitd->itd.itd_nextitd),
	       (u_long)le32toh(sitd->itd.itd_be));
d1850 3
a1852 3
		printf("offs[%d]=0x%04x ", i,
		       (u_int)le16toh(sitd->itd.itd_offset[i]));
	printf("\n");
d1867 1
a1867 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_flags),
d1870 1
a1870 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_headp),
d1873 9
a1881 9
	printf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\n"
	       "tailp=0x%08lx headflags=%s headp=0x%08lx nexted=0x%08lx\n",
	       sed, (u_long)sed->physaddr,
	       OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
	       (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
	       (u_long)le32toh(sed->ed.ed_headp),
	       (u_long)le32toh(sed->ed.ed_nexted));
a1905 3
	if (sc->sc_dying)
		return (USBD_IOERROR);

d1949 1
a1949 1
			OHCI_ED_SET_FA(addr) |
d1951 2
a1952 2
			(dev->speed == USB_SPEED_LOW ? OHCI_ED_SPEED : 0) |
			fmt | OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
d1958 2
a1959 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d1994 1
a1994 1

d2012 1
a2012 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2014 1
d2016 5
a2020 1
		std = ohci_hash_find_td(sc, le32toh(sed->ed.ed_headp));
a2025 8
#ifdef USB_DEBUG
		usbd_dump_pipe(&opipe->pipe);
#endif
#ifdef OHCI_DEBUG
		ohci_dump_ed(sed);
		if (std)
			ohci_dump_td(std);
#endif
d2027 1
a2027 1
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2037 1
a2037 1
/*
d2051 1
a2051 5
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *p, *n;
	ohci_physaddr_t headp;
	int s, hit;
d2053 1
a2053 2
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p sed=%p\n", xfer, opipe,
		 sed));
d2055 1
a2055 8
	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
		usb_transfer_complete(xfer);
		splx(s);
	}
d2057 1
a2057 2
	if (xfer->device->bus->intr_context || !curproc)
		panic("ohci_abort_xfer: not in process context\n");
d2059 1
a2059 7
	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
	splx(s);
d2063 29
a2091 6
	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(opipe->pipe.device->bus, 20); /* Hardware finishes in 1ms */
a2092 4
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	tsleep(&sc->sc_softwake, PZERO, "ohciab", 0);
	splx(s);
a2093 8
	/*
	 * Step 3: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
	 */
	s = splusb();		/* XXX why? */
d2098 1
a2098 1
		printf("ohci_abort_xfer: hcpriv is NULL\n");
a2101 9
#ifdef OHCI_DEBUG
	if (ohcidebug > 1) {
		DPRINTF(("ohci_abort_xfer: sed=\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(p);
	}
#endif
	headp = le32toh(sed->ed.ed_headp) & OHCI_HEADMASK;
	hit = 0;
a2102 1
		hit |= headp == p->physaddr;
a2105 8
	/* Zap headp register if hardware pointed inside the xfer. */
	if (hit) {
		DPRINTFN(1,("ohci_abort_xfer: set hd=0x08%x, tl=0x%08x\n",
			    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
		sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
	} else {
		DPRINTFN(1,("ohci_abort_xfer: no hit\n"));
	}
d2107 4
a2110 3
	/*
	 * Step 4: Turn on hardware again.
	 */
a2112 3
	/*
	 * Step 5: Execute callback.
	 */
d2127 1
a2127 1
	UDPROTO_FSHUB,
d2155 1
a2155 1
	UIPROTO_FSHUB,
d2179 4
a2182 1
ohci_str(usb_string_descriptor_t *p, int l, const char *s)
d2238 1
a2238 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
d2253 1
a2253 1
		/*
d2422 1
a2422 1
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
d2428 1
a2428 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
d2485 2
a2486 7
			for (i = 0; i < 5; i++) {
				usb_delay_ms(&sc->sc_bus,
					     USB_PORT_ROOT_RESET_DELAY);
				if (sc->sc_dying) {
					err = USBD_IOERROR;
					goto ret;
				}
d2581 1
a2581 1

d2784 1
a2784 1
/*
d2846 1
a2846 1
		OHCI_TD_IN | OHCI_TD_NOCC |
d2919 1
a2919 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2982 1
a2982 1
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n",
d3038 1
a3038 1
	ohci_soft_itd_t *sitd, *nsitd;
d3053 1
a3053 1
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
d3067 1
a3067 1

d3079 1
a3079 1
				OHCI_ITD_NOCC |
d3091 1
a3091 1
			iso->next = iso->next + ncur;
d3101 1
a3101 1
		printf("%s: isoc TD alloc failed\n",
d3107 1
a3107 1
		OHCI_ITD_NOCC |
d3163 1
a3163 1
		printf("ohci_device_isoc_start: not in progress %p\n", xfer);
d3185 1
a3185 1
	if (xfer->status != USBD_NOT_STARTED &&
d3233 1
a3233 1
	ohci_soft_itd_t *sitd, *nsitd;
@


1.26
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.25 2002/03/14 03:16:08 millert Exp $ */
/*	$NetBSD: ohci.c,v 1.104 2001/09/28 23:57:21 augustss Exp $	*/
d201 1
a201 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc, 
d204 1
a204 1
Static int		ohci_str(usb_string_descriptor_t *, int, char *);
d207 1
d209 1
a209 1
Static void		ohci_rhsc_enable(void *sc);
a212 1
Static void		ohci_abort_xfer_end(void *);
d239 1
a239 1
Static u_int8_t revbits[OHCI_NO_INTRS] = 
d289 1
a289 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {	
d298 1
a298 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {	
d307 1
a307 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {	
d316 1
a316 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {	
d325 1
a325 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {	
d371 1
a371 1
	
d375 2
d382 2
d495 1
a495 1
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | 
d511 1
a511 1
			curlen = 2 * OHCI_PAGE_SIZE - 
d572 1
a572 1
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std, 
a643 9
void
ohci_reset(ohci_softc_t *sc)
{
	ohci_shutdown(sc);
	/* disable all interrupts and then switch on all desired
           interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
}

d663 1
a663 1
		printf("%s: unsupported OHCI revision\n", 
d679 1
a679 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, 
d731 1
a731 1
	/* 
d736 1
a736 1
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] = 
d859 1
a859 1
	
d873 2
d918 1
a918 1
	if (xfer != NULL)
d920 15
a934 4
	else
		xfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		memset(xfer, 0, sizeof *xfer);
d943 8
d1084 3
d1090 5
a1094 1
		printf("ohci_intr: ignored interrupt while polling\n");
d1099 1
a1099 1
	return (ohci_intr1(sc)); 
d1108 2
d1139 1
a1139 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n", 
d1151 1
a1151 1
		intrs &= ~OHCI_SO;
d1157 1
a1157 1
		intrs &= ~OHCI_WDH;
d1171 1
a1171 3
		intrs &= ~OHCI_RHSC;

		/* 
d1176 3
a1178 1
#if defined (__OpenBSD__)
d1180 2
a1181 2
		timeout_add(&sc->sc_tmo_rhsc, hz);
#endif
d1186 7
a1192 3
	/* Block unprocessed interrupts. XXX */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, intrs);
	sc->sc_eintrs &= ~intrs;
d1215 4
d1289 2
d1300 1
a1300 1
	DPRINTFN(10,("ohci_process_done: sdone=%p sidone=%p\n", sdone, sidone));
d1315 2
a1316 1
			/* xfer == NULL: There seems to be no xfer associated
d1319 1
d1353 1
a1353 1
			struct ohci_pipe *opipe = 
d1380 1
a1380 1
		DPRINTF(("ohci_process_done: ITD done:\n"));
d1407 1
a1407 1
			struct ohci_pipe *opipe = 
d1423 5
d1429 1
d1454 1
a1454 1
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n", 
d1467 1
a1467 1
		
d1469 1
a1469 1
			OHCI_TD_IN | OHCI_TD_NOCC | 
d1492 1
a1492 1
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n", 
d1508 1
a1508 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n", 
d1561 2
d1587 9
d1622 1
a1622 1
		    UGETW(req->wIndex), len, addr, 
d1708 2
a1709 2
#if 0
	if (ohcidebug > 10) {
d1713 4
d1738 2
d1753 1
a1753 1
	ohci_soft_ed_t *p; 
d1803 1
a1803 1
	for (std = LIST_FIRST(&sc->sc_hash_tds[h]); 
d1819 1
a1819 1
	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n", 
d1831 1
a1831 1
	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n", 
d1843 1
a1843 1
	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]); 
d1854 19
d1876 1
a1876 1
	DPRINTF(("ohci_timeout: xfer=%p\n", xfer));
a1878 1
	xfer->device->bus->intr_context++;
a1879 1
	xfer->device->bus->intr_context--;
d1896 1
a1896 1
	bitmask_snprintf((int)le32toh(std->td.td_flags),
d1900 9
a1908 9
	DPRINTF(("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
		 "nexttd=0x%08lx be=0x%08lx\n", 
		 std, (u_long)std->physaddr, sbuf,
		 OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
		 (u_long)le32toh(std->td.td_cbp),
		 (u_long)le32toh(std->td.td_nexttd),
		 (u_long)le32toh(std->td.td_be)));
d1916 10
a1925 10
	DPRINTF(("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n", 
		 sitd, (u_long)sitd->physaddr,
		 OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
		 (u_long)le32toh(sitd->itd.itd_bp0),
		 (u_long)le32toh(sitd->itd.itd_nextitd),
		 (u_long)le32toh(sitd->itd.itd_be)));
d1927 3
a1929 3
		DPRINTF(("offs[%d]=0x%04x ", i,
			 (u_int)le16toh(sitd->itd.itd_offset[i])));
	DPRINTF(("\n"));
d1944 1
a1944 1
	bitmask_snprintf((int)le32toh(sed->ed.ed_flags),
d1947 1
a1947 1
	bitmask_snprintf((u_long)le32toh(sed->ed.ed_headp),
d1950 9
a1958 9
	DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %s\ntailp=0x%08lx "
		 "headflags=%s headp=0x%08lx nexted=0x%08lx\n",
		 sed, (u_long)sed->physaddr, 
		 OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
		 (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
		 (u_long)le32toh(sed->ed.ed_headp),
		 (u_long)le32toh(sed->ed.ed_nexted)));
d1983 3
d2029 1
a2029 1
			OHCI_ED_SET_FA(addr) | 
d2031 2
a2032 2
			(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |
			OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
d2038 2
a2039 2
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
d2074 1
a2074 1
	
d2092 1
a2092 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
a2093 1
		ohci_physaddr_t td = le32toh(sed->ed.ed_headp);
d2095 1
a2095 5
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]); 
		     std != NULL;
		     std = LIST_NEXT(std, hnext))
		    if (std->physaddr == td)
			break;
d2101 8
d2110 1
a2110 1
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
d2120 1
a2120 1
/* 
d2134 5
a2138 1
	ohci_soft_ed_t *sed;
d2140 2
a2141 1
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p\n", xfer, opipe));
d2143 8
a2150 1
	xfer->status = status;
d2152 8
d2161 1
a2161 2

	sed = opipe->sed;
d2165 6
a2170 29
#if 1
	if (xfer->device->bus->intr_context) {
		/* We have no process context, so we can't use tsleep(). */
		usb_callout(xfer->pipe->abort_handle,
		    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);
	} else {
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
		KASSERT(intr_nesting_level == 0,
	        	("ohci_abort_req in interrupt context"));
#endif
		usb_delay_ms(opipe->pipe.device->bus, 1);
		ohci_abort_xfer_end(xfer);
	}
#else
	delay(1000);
	ohci_abort_xfer_end(xfer);
#endif
}

void
ohci_abort_xfer_end(void *v)
{
	usbd_xfer_handle xfer = v;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_td_t *p, *n;
	int s;

d2172 4
d2177 8
d2189 1
a2189 1
		printf("ohci_abort_xfer: hcpriv==0\n");
d2193 9
d2203 1
d2207 8
d2216 3
a2218 4
	sed = opipe->sed;
	DPRINTFN(2,("ohci_abort_xfer: set hd=%x, tl=%x\n",
		    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
	sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
d2221 3
d2238 1
a2238 1
	0,			/* protocol */
d2266 1
a2266 1
	0,
d2290 1
a2290 4
ohci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d2346 1
a2346 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n", 
d2361 1
a2361 1
		/* 
d2530 1
a2530 1
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH : 
d2536 1
a2536 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) 
d2593 7
a2599 2
			for (i = 0; i < 10; i++) {
				usb_delay_ms(&sc->sc_bus, 10); /* XXX */
d2694 1
a2694 1
	
d2897 1
a2897 1
/* 
d2959 1
a2959 1
		OHCI_TD_IN | OHCI_TD_NOCC | 
d3032 1
a3032 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
d3095 1
a3095 1
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n", 
d3151 1
a3151 1
	ohci_soft_itd_t *sitd, *nsitd;	
d3166 1
a3166 1
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n", 
d3180 1
a3180 1
			
d3192 1
a3192 1
				OHCI_ITD_NOCC | 
d3204 1
a3204 1
			iso->next = iso->next + ncur; 
d3214 1
a3214 1
		printf("%s: isoc TD alloc failed\n", 
d3220 1
a3220 1
		OHCI_ITD_NOCC | 
d3276 1
a3276 1
		printf("uhci_device_isoc_start: not in progress %p\n", xfer);
d3298 1
a3298 1
	if (xfer->status != USBD_NOT_STARTED && 
d3346 1
a3346 1
	ohci_soft_itd_t *sitd, *nsitd;	
@


1.25
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.24 2001/10/31 04:24:44 nate Exp $ */
d208 1
d640 9
d873 3
@


1.24
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.23 2001/09/15 20:57:33 drahn Exp $ */
d595 1
a595 1
			sitd = (ohci_soft_itd_t *)((char*)KERNADDR(&dma)+offs);
@


1.24.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.24 2001/10/31 04:24:44 nate Exp $ */
a207 1
Static void		ohci_rhsc_enable(void *sc);
d595 1
a595 1
			sitd = (ohci_soft_itd_t *)((char *)KERNADDR(&dma)+offs);
a638 9
void
ohci_reset(ohci_softc_t *sc)
{
	ohci_shutdown(sc);
	/* disable all interrupts and then switch on all desired
           interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
}

a863 1
	usb_callout_init(sc->sc_tmo_rhsc);
d1140 1
d1142 2
a1143 1
		usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
@


1.24.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.24.2.1 2002/06/11 03:42:30 art Exp $ */
d201 1
a201 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc,
d239 1
a239 1
Static u_int8_t revbits[OHCI_NO_INTRS] =
d289 1
a289 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {
d298 1
a298 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {
d307 1
a307 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {
d316 1
a316 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {
d325 1
a325 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {
d371 1
a371 1

d491 1
a491 1
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
d507 1
a507 1
			curlen = 2 * OHCI_PAGE_SIZE -
d513 1
a513 1
				panic("ohci_alloc_std: curlen == 0");
d568 1
a568 1
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std,
d628 1
a628 1
		panic("ohci_free_sitd: sitd=%p not done", sitd);
d668 1
a668 1
		printf("%s: unsupported OHCI revision\n",
d684 1
a684 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE,
d736 1
a736 1
	/*
d741 1
a741 1
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] =
d864 1
a864 1

d1074 1
a1074 1
	return (ohci_intr1(sc));
d1112 1
a1112 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1146 1
a1146 1
		/*
d1230 1
a1230 1
		panic("ohci_add_done: addr 0x%08lx not found", (u_long)done);
d1312 1
a1312 1
			struct ohci_pipe *opipe =
d1366 1
a1366 1
			struct ohci_pipe *opipe =
d1392 1
a1392 1
		panic("ohci_ctrl_done: not a request");
d1407 1
a1407 1
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n",
d1420 1
a1420 1

d1422 1
a1422 1
			OHCI_TD_IN | OHCI_TD_NOCC |
d1445 1
a1445 1
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n",
d1461 1
a1461 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n",
d1564 1
a1564 1
		    UGETW(req->wIndex), len, addr,
d1689 1
a1689 1
	ohci_soft_ed_t *p;
d1697 1
a1697 1
		panic("ohci_rem_ed: ED not found");
d1739 1
a1739 1
	for (std = LIST_FIRST(&sc->sc_hash_tds[h]);
d1755 1
a1755 1
	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n",
d1767 1
a1767 1
	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n",
d1779 1
a1779 1
	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]);
d1820 1
a1820 1
		 "nexttd=0x%08lx be=0x%08lx\n",
d1836 1
a1836 1
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
d1871 1
a1871 1
		 sed, (u_long)sed->physaddr,
d1923 2
a1924 1
			if (sitd == NULL)
d1926 1
d1945 1
a1945 1
			OHCI_ED_SET_FA(addr) |
d1954 2
a1955 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d1990 1
a1990 1

d2008 1
a2008 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2012 1
a2012 1
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]);
d2023 1
a2023 1
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2033 1
a2033 1
/*
d2234 1
a2234 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
d2249 1
a2249 1
		/*
d2418 1
a2418 1
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
d2424 1
a2424 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
d2577 1
a2577 1

d2780 1
a2780 1
/*
d2830 1
a2830 1
		panic("ohci_device_intr_transfer: a request");
d2842 1
a2842 1
		OHCI_TD_IN | OHCI_TD_NOCC |
d2915 1
a2915 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2923 1
a2923 1
		panic("ohci_device_intr_close: ED not found");
d2978 1
a2978 1
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n",
d3034 1
a3034 1
	ohci_soft_itd_t *sitd, *nsitd;
d3049 1
a3049 1
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
d3063 1
a3063 1

d3075 1
a3075 1
				OHCI_ITD_NOCC |
d3087 1
a3087 1
			iso->next = iso->next + ncur;
d3097 1
a3097 1
		printf("%s: isoc TD alloc failed\n",
d3103 1
a3103 1
		OHCI_ITD_NOCC |
d3181 1
a3181 1
	if (xfer->status != USBD_NOT_STARTED &&
d3229 1
a3229 1
	ohci_soft_itd_t *sitd, *nsitd;
@


1.23
log
@Add a timer to reinable the OHCI RHSC (Root Hub Status Change)
interrupt after one second. Originally the interrupt was disabled
permanently after it fired once. This causes futher hot plug/removals
to stop working. However the interrupt will fire several times in succession
as a device is inserted/removed. This effectively debounces the interrupt.

Apparently only some systems actually plug directly into the root hub:
Most PCI cards do not, however newer apple motherboards all do.

This was sent around for review some time back and again recently, this
time with no feedback.
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.22 2001/06/13 07:43:36 deraadt Exp $ */
/*	$NetBSD: ohci.c,v 1.102 2001/04/01 15:00:29 augustss Exp $	*/
d141 1
a141 1
Static void		ohci_softintr(struct usbd_bus *);
d654 1
a654 1
	printf(" OHCI version %d.%d%s", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
a655 1
	printf("\n");
d762 2
d771 1
a1155 7
ohci_rhsc_enable(void *v_sc)
{
	ohci_softc_t *sc = v_sc;
	ohci_rhsc_able(sc, 1);
}

void
d1168 8
d1235 1
a1235 1
ohci_softintr(struct usbd_bus *bus)
d1237 1
a1237 1
	ohci_softc_t *sc = (ohci_softc_t *)bus;
d2084 1
a2085 1
		splx(s);
@


1.22
log
@dmesg cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.21 2001/05/03 02:20:32 aaron Exp $ */
d1138 4
d1151 7
@


1.21
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.20 2001/03/25 07:03:26 csapuntz Exp $ */
a655 1
#if !defined(__OpenBSD__)
a656 1
#endif
@


1.20
log
@Missing splx(). Thanks to dawson and team for finding this one
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.19 2001/03/25 07:00:59 csapuntz Exp $ */
/*	$NetBSD: ohci.c,v 1.93 2000/08/17 23:18:56 augustss Exp $	*/
d860 1
d956 1
a956 1
	s = splusb();
d961 10
a970 2
		ctl = OREAD4(sc, OHCI_CONTROL);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_SUSPEND;
d977 12
a988 2
		ctl = OREAD4(sc, OHCI_CONTROL);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_RESUME;
d994 1
d1106 6
a1111 1
		printf("%s: scheduling overrun\n",USBDEVNAME(sc->sc_bus.bdev));
@


1.19
log
@Missing splx(). Thanks to dawson and team for finding this one
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.18 2001/01/28 09:43:41 aaron Exp $ */
d3151 1
@


1.18
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.17 2001/01/22 23:24:32 deraadt Exp $ */
d2048 1
@


1.17
log
@fix pretty printing
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.16 2000/11/11 16:23:30 drahn Exp $ */
d45 2
a46 2
 * OHCI spec: ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.exe
 * USB spec: http://www.usb.org/developers/data/usb11.pdf
d104 14
a945 1
#ifdef OHCI_DEBUG
d947 2
d950 1
a951 1
	/* XXX should suspend/resume */
d954 31
d1324 1
@


1.16
log
@Change the le32toh() le16toh() macros back to the previous defintion.
This change is more portable, redefine the macros to use the host
letoh32/letoh16 instead of using possibly less efficient bswap routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.15 2000/11/08 18:10:37 aaron Exp $ */
d640 1
a640 1
	printf(" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
d642 3
@


1.15
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.14 2000/09/06 22:42:10 rahnds Exp $ */
a101 14
#endif

/*
 * The OHCI controller is little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
@


1.14
log
@Match Free/Net macros for le32toh/letoh32, define in terms of the other.
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.13 2000/07/04 11:44:21 fgsch Exp $ */
/*	$NetBSD: ohci.c,v 1.85 2000/04/01 09:27:35 augustss Exp $	*/
d96 3
d104 14
d120 2
a121 2
Static ohci_soft_ed_t  *ohci_alloc_sed __P((ohci_softc_t *));
Static void		ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));
d123 2
a124 2
Static ohci_soft_td_t  *ohci_alloc_std __P((ohci_softc_t *));
Static void		ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));
d126 2
a127 2
Static ohci_soft_itd_t *ohci_alloc_sitd __P((ohci_softc_t *));
Static void		ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));
d130 2
a131 2
Static void		ohci_free_std_chain __P((ohci_softc_t *, 
			    ohci_soft_td_t *, ohci_soft_td_t *));
d133 1
a133 1
Static usbd_status	ohci_alloc_std_chain __P((struct ohci_pipe *,
d135 1
a135 1
			    ohci_soft_td_t *, ohci_soft_td_t **));
d137 75
a211 84
Static void		ohci_shutdown __P((void *v));
Static void		ohci_power __P((int, void *));
Static usbd_status	ohci_open __P((usbd_pipe_handle));
Static void		ohci_poll __P((struct usbd_bus *));
Static void		ohci_softintr __P((struct usbd_bus *));
Static void		ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));
Static void		ohci_add_done __P((ohci_softc_t *, ohci_physaddr_t));
Static void		ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));

Static usbd_status	ohci_device_request __P((usbd_xfer_handle xfer));
Static void		ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
Static void		ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
Static void		ohci_hash_add_td __P((ohci_softc_t *, 
			    ohci_soft_td_t *));
Static void		ohci_hash_rem_td __P((ohci_softc_t *,
			    ohci_soft_td_t *));
Static ohci_soft_td_t  *ohci_hash_find_td __P((ohci_softc_t *,
			    ohci_physaddr_t));
Static void		ohci_hash_add_itd __P((ohci_softc_t *, 
			    ohci_soft_itd_t *));
Static void		ohci_hash_rem_itd __P((ohci_softc_t *,
			    ohci_soft_itd_t *));
Static ohci_soft_itd_t  *ohci_hash_find_itd __P((ohci_softc_t *,
			    ohci_physaddr_t));

Static usbd_status	ohci_setup_isoc __P((usbd_pipe_handle pipe));
Static void		ohci_device_isoc_enter __P((usbd_xfer_handle));

Static usbd_status	ohci_allocm __P((struct usbd_bus *, usb_dma_t *,
			    u_int32_t));
Static void		ohci_freem __P((struct usbd_bus *, usb_dma_t *));

Static usbd_xfer_handle	ohci_allocx __P((struct usbd_bus *));
Static void		ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));

Static usbd_status	ohci_root_ctrl_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_root_ctrl_start __P((usbd_xfer_handle));
Static void		ohci_root_ctrl_abort __P((usbd_xfer_handle));
Static void		ohci_root_ctrl_close __P((usbd_pipe_handle));
Static void		ohci_root_ctrl_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_root_intr_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_root_intr_start __P((usbd_xfer_handle));
Static void		ohci_root_intr_abort __P((usbd_xfer_handle));
Static void		ohci_root_intr_close __P((usbd_pipe_handle));
Static void		ohci_root_intr_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_device_ctrl_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_device_ctrl_start __P((usbd_xfer_handle));
Static void		ohci_device_ctrl_abort __P((usbd_xfer_handle));
Static void		ohci_device_ctrl_close __P((usbd_pipe_handle));
Static void		ohci_device_ctrl_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_device_bulk_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_device_bulk_start __P((usbd_xfer_handle));
Static void		ohci_device_bulk_abort __P((usbd_xfer_handle));
Static void		ohci_device_bulk_close __P((usbd_pipe_handle));
Static void		ohci_device_bulk_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_device_intr_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_device_intr_start __P((usbd_xfer_handle));
Static void		ohci_device_intr_abort __P((usbd_xfer_handle));
Static void		ohci_device_intr_close __P((usbd_pipe_handle));
Static void		ohci_device_intr_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_device_isoc_transfer __P((usbd_xfer_handle));
Static usbd_status	ohci_device_isoc_start __P((usbd_xfer_handle));
Static void		ohci_device_isoc_abort __P((usbd_xfer_handle));
Static void		ohci_device_isoc_close __P((usbd_pipe_handle));
Static void		ohci_device_isoc_done  __P((usbd_xfer_handle));

Static usbd_status	ohci_device_setintr __P((ohci_softc_t *sc, 
			    struct ohci_pipe *pipe, int ival));

Static int		ohci_str __P((usb_string_descriptor_t *, int, char *));

Static void		ohci_timeout __P((void *));
Static void		ohci_rhsc_able __P((ohci_softc_t *, int));

Static void		ohci_close_pipe __P((usbd_pipe_handle pipe, 
			    ohci_soft_ed_t *head));
Static void		ohci_abort_xfer __P((usbd_xfer_handle xfer,
			    usbd_status status));
Static void		ohci_abort_xfer_end __P((void *));
d213 2
a214 2
Static void		ohci_device_clear_toggle __P((usbd_pipe_handle pipe));
Static void		ohci_noop __P((usbd_pipe_handle pipe));
d217 19
a235 11
Static void		ohci_dumpregs __P((ohci_softc_t *));
Static void		ohci_dump_tds __P((ohci_soft_td_t *));
Static void		ohci_dump_td __P((ohci_soft_td_t *));
Static void		ohci_dump_ed __P((ohci_soft_ed_t *));
Static void		ohci_dump_itd __P((ohci_soft_itd_t *));
Static void		ohci_dump_itds __P((ohci_soft_itd_t *));
#endif

#define OWRITE4(sc, r, x) bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
#define OREAD4(sc, r) bus_space_read_4((sc)->iot, (sc)->ioh, (r))
#define OREAD2(sc, r) bus_space_read_2((sc)->iot, (sc)->ioh, (r))
d344 1
a344 3
ohci_activate(self, act)
	device_ptr_t self;
	enum devact act;
d364 1
a364 3
ohci_detach(sc, flags)
	struct ohci_softc *sc;
	int flags;
d386 1
a386 2
ohci_alloc_sed(sc)
	ohci_softc_t *sc;
d415 1
a415 3
ohci_free_sed(sc, sed)
	ohci_softc_t *sc;
	ohci_soft_ed_t *sed;
d422 1
a422 2
ohci_alloc_std(sc)
	ohci_softc_t *sc;
d460 1
a460 3
ohci_free_std(sc, std)
	ohci_softc_t *sc;
	ohci_soft_td_t *std;
d472 3
a474 6
ohci_alloc_std_chain(opipe, sc, alen, rd, xfer, sp, ep)
	struct ohci_pipe *opipe;
	ohci_softc_t *sc;
	int alen, rd;
	usbd_xfer_handle xfer;
	ohci_soft_td_t *sp, **ep;
d567 2
a568 4
ohci_free_std_chain(sc, std, stdend)
	ohci_softc_t *sc;
	ohci_soft_td_t *std;
	ohci_soft_td_t *stdend;
d580 1
a580 2
ohci_alloc_sitd(sc)
	ohci_softc_t *sc;
d619 1
a619 3
ohci_free_sitd(sc, sitd)
	ohci_softc_t *sc;
	ohci_soft_itd_t *sitd;
d640 1
a640 2
ohci_init(sc)
	ohci_softc_t *sc;
d878 1
a878 4
ohci_allocm(bus, dma, size)
	struct usbd_bus *bus;
	usb_dma_t *dma;
	u_int32_t size;
d888 1
a888 3
ohci_freem(bus, dma)
	struct usbd_bus *bus;
	usb_dma_t *dma;
d898 1
a898 2
ohci_allocx(bus)
	struct usbd_bus *bus;
d914 1
a914 3
ohci_freex(bus, xfer)
	struct usbd_bus *bus;
	usbd_xfer_handle xfer;
d925 1
a925 2
ohci_shutdown(v)
	void *v;
d941 1
a941 3
ohci_power(why, v)
	int why;
	void *v;
d954 1
a954 2
ohci_dumpregs(sc)
	ohci_softc_t *sc;
d993 1
a993 1
Static int ohci_intr1 __P((ohci_softc_t *));
d996 1
a996 2
ohci_intr(p)
	void *p;
d1012 1
a1012 2
ohci_intr1(sc)
	ohci_softc_t *sc;
d1092 1
a1092 3
ohci_rhsc_able(sc, on)
	ohci_softc_t *sc;
	int on;
d1126 1
a1126 3
ohci_add_done(sc, done)
	ohci_softc_t *sc;
	ohci_physaddr_t done;
a1161 3
void baaz(void);
void baaz(void) {} 

d1163 1
a1163 2
ohci_softintr(bus)
	struct usbd_bus *bus;
d1304 1
a1304 2
ohci_device_ctrl_done(xfer)
	usbd_xfer_handle xfer;
d1317 1
a1317 2
ohci_device_intr_done(xfer)
	usbd_xfer_handle xfer;
d1361 1
a1361 2
ohci_device_bulk_done(xfer)
	usbd_xfer_handle xfer;
d1370 1
a1370 3
ohci_rhsc(sc, xfer)
	ohci_softc_t *sc;
	usbd_xfer_handle xfer;
d1406 1
a1406 2
ohci_root_intr_done(xfer)
	usbd_xfer_handle xfer;
d1412 1
a1412 2
ohci_root_ctrl_done(xfer)
	usbd_xfer_handle xfer;
d1423 1
a1423 3
ohci_waitintr(sc, xfer)
	ohci_softc_t *sc;
	usbd_xfer_handle xfer;
d1453 1
a1453 2
ohci_poll(bus)
	struct usbd_bus *bus;
d1462 1
a1462 2
ohci_device_request(xfer)
	usbd_xfer_handle xfer;
d1592 1
a1592 3
ohci_add_ed(sed, head)
	ohci_soft_ed_t *sed; 
	ohci_soft_ed_t *head; 
d1605 1
a1605 3
ohci_rem_ed(sed, head)
	ohci_soft_ed_t *sed; 
	ohci_soft_ed_t *head; 
d1633 1
a1633 3
ohci_hash_add_td(sc, std)
	ohci_softc_t *sc;
	ohci_soft_td_t *std;
d1644 1
a1644 3
ohci_hash_rem_td(sc, std)
	ohci_softc_t *sc;
	ohci_soft_td_t *std;
d1652 1
a1652 3
ohci_hash_find_td(sc, a)
	ohci_softc_t *sc;
	ohci_physaddr_t a;
d1667 1
a1667 3
ohci_hash_add_itd(sc, sitd)
	ohci_softc_t *sc;
	ohci_soft_itd_t *sitd;
d1681 1
a1681 3
ohci_hash_rem_itd(sc, sitd)
	ohci_softc_t *sc;
	ohci_soft_itd_t *sitd;
d1692 1
a1692 3
ohci_hash_find_itd(sc, a)
	ohci_softc_t *sc;
	ohci_physaddr_t a;
d1706 1
a1706 2
ohci_timeout(addr)
	void *addr;
d1722 1
a1722 2
ohci_dump_tds(std)
	ohci_soft_td_t *std;
d1729 1
a1729 2
ohci_dump_td(std)
	ohci_soft_td_t *std;
d1731 7
a1737 1
	DPRINTF(("TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\ncbp=0x%08lx "
d1739 1
a1739 3
		 std, (u_long)std->physaddr,
		 (int)le32toh(std->td.td_flags),
		 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
d1749 1
a1749 2
ohci_dump_itd(sitd)
	ohci_soft_itd_t *sitd;
d1770 1
a1770 2
ohci_dump_itds(sitd)
	ohci_soft_itd_t *sitd;
d1777 1
a1777 2
ohci_dump_ed(sed)
	ohci_soft_ed_t *sed;
d1779 10
a1788 2
	DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %b\ntailp=0x%08lx "
		 "headflags=%b headp=0x%08lx nexted=0x%08lx\n",
d1792 2
a1793 6
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)),
		 (int)le32toh(sed->ed.ed_flags),
		 "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
		 (u_long)le32toh(sed->ed.ed_tailp),
		 (u_long)le32toh(sed->ed.ed_headp),
		 "\20\1HALT\2CARRY",
d1800 1
a1800 2
ohci_open(pipe)
	usbd_pipe_handle pipe;
d1916 1
a1916 3
ohci_close_pipe(pipe, head)
	usbd_pipe_handle pipe;
	ohci_soft_ed_t *head;
d1962 1
a1962 3
ohci_abort_xfer(xfer, status)
	usbd_xfer_handle xfer;
	usbd_status status;
d1997 1
a1997 2
ohci_abort_xfer_end(v)
	void *v;
d2115 1
a2115 2
ohci_root_ctrl_transfer(xfer)
	usbd_xfer_handle xfer;
d2129 1
a2129 2
ohci_root_ctrl_start(xfer)
	usbd_xfer_handle xfer;
d2399 1
a2399 1
				usb_delay_ms(&sc->sc_bus, 10);
d2432 1
a2432 2
ohci_root_ctrl_abort(xfer)
	usbd_xfer_handle xfer;
d2439 1
a2439 2
ohci_root_ctrl_close(pipe)
	usbd_pipe_handle pipe;
d2446 1
a2446 2
ohci_root_intr_transfer(xfer)
	usbd_xfer_handle xfer;
d2460 1
a2460 2
ohci_root_intr_start(xfer)
	usbd_xfer_handle xfer;
d2475 1
a2475 2
ohci_root_intr_abort(xfer)
	usbd_xfer_handle xfer;
d2491 1
a2491 2
ohci_root_intr_close(pipe)
	usbd_pipe_handle pipe;
d2503 1
a2503 2
ohci_device_ctrl_transfer(xfer)
	usbd_xfer_handle xfer;
d2517 1
a2517 2
ohci_device_ctrl_start(xfer)
	usbd_xfer_handle xfer;
d2544 1
a2544 2
ohci_device_ctrl_abort(xfer)
	usbd_xfer_handle xfer;
d2552 1
a2552 2
ohci_device_ctrl_close(pipe)
	usbd_pipe_handle pipe;
d2565 1
a2565 2
ohci_device_clear_toggle(pipe)
	usbd_pipe_handle pipe;
d2573 1
a2573 2
ohci_noop(pipe)
	usbd_pipe_handle pipe;
d2578 1
a2578 2
ohci_device_bulk_transfer(xfer)
	usbd_xfer_handle xfer;
d2592 1
a2592 2
ohci_device_bulk_start(xfer)
	usbd_xfer_handle xfer;
d2691 1
a2691 2
ohci_device_bulk_abort(xfer)
	usbd_xfer_handle xfer;
d2701 1
a2701 2
ohci_device_bulk_close(pipe)
	usbd_pipe_handle pipe;
d2714 1
a2714 2
ohci_device_intr_transfer(xfer)
	usbd_xfer_handle xfer;
d2728 1
a2728 2
ohci_device_intr_start(xfer)
	usbd_xfer_handle xfer;
d2807 1
a2807 2
ohci_device_intr_abort(xfer)
	usbd_xfer_handle xfer;
d2818 1
a2818 2
ohci_device_intr_close(pipe)
	usbd_pipe_handle pipe;
d2854 1
a2854 4
ohci_device_setintr(sc, opipe, ival)
	ohci_softc_t *sc;
	struct ohci_pipe *opipe;
	int ival;
d2918 1
a2918 2
ohci_device_isoc_transfer(xfer)
	usbd_xfer_handle xfer;
d2944 1
a2944 2
ohci_device_isoc_enter(xfer)
	usbd_xfer_handle xfer;
d3064 1
a3064 2
ohci_device_isoc_start(xfer)
	usbd_xfer_handle xfer;
d3085 1
a3085 2
ohci_device_isoc_abort(xfer)
	usbd_xfer_handle xfer;
d3141 1
a3141 2
ohci_device_isoc_done(xfer)
	usbd_xfer_handle xfer;
d3161 1
a3161 2
ohci_setup_isoc(pipe)
	usbd_pipe_handle pipe;
d3179 1
a3179 2
ohci_device_isoc_close(pipe)
	usbd_pipe_handle pipe;
@


1.13
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.12 2000/06/29 13:48:31 aaron Exp $ */
a98 18
#endif

/*
 * The OHCI controller is little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#define htole16(x) (bswap16(x))
#define le16toh(x) (bswap16(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#define htole16(x) (x)
#define le16toh(x) (x)
#endif
@


1.12
log
@Allow USB to compile with USB_DEBUG defined; binkertn@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.11 2000/04/01 19:11:35 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d1442 1
d1889 3
d1970 2
a1971 1
	ohci_free_std(sc, std);
d1973 2
a1974 1
	ohci_free_sed(sc, sed);
d2366 1
@


1.11
log
@The AMD756 requires a delay before reading the number of ports from the
controller to avoid getting 0 from it; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.10 2000/03/30 16:19:32 aaron Exp $ */
d109 2
d114 2
@


1.10
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.9 2000/03/28 19:37:48 aaron Exp $ */
/*	$NetBSD: ohci.c,v 1.84 2000/03/29 18:24:53 augustss Exp $	*/
d854 1
a854 1
	usb_delay_ms(&sc->sc_bus, 5);
d857 5
@


1.9
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ohci.c,v 1.81 2000/03/25 18:02:32 augustss Exp $	*/
d117 2
a118 2
static ohci_soft_ed_t  *ohci_alloc_sed __P((ohci_softc_t *));
static void		ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));
d120 2
a121 2
static ohci_soft_td_t  *ohci_alloc_std __P((ohci_softc_t *));
static void		ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));
d123 2
a124 2
static ohci_soft_itd_t *ohci_alloc_sitd __P((ohci_softc_t *));
static void		ohci_free_sitd __P((ohci_softc_t *,ohci_soft_itd_t *));
d127 1
a127 1
static void		ohci_free_std_chain __P((ohci_softc_t *, 
d130 1
a130 1
static usbd_status	ohci_alloc_std_chain __P((struct ohci_pipe *,
d134 13
a146 13
static void		ohci_shutdown __P((void *v));
static void		ohci_power __P((int, void *));
static usbd_status	ohci_open __P((usbd_pipe_handle));
static void		ohci_poll __P((struct usbd_bus *));
static void		ohci_softintr __P((struct usbd_bus *));
static void		ohci_waitintr __P((ohci_softc_t *,
			    usbd_xfer_handle));
static void		ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));

static usbd_status	ohci_device_request __P((usbd_xfer_handle xfer));
static void		ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
static void		ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
static void		ohci_hash_add_td __P((ohci_softc_t *, 
d148 1
a148 1
static void		ohci_hash_rem_td __P((ohci_softc_t *,
d150 7
a156 1
static ohci_soft_td_t  *ohci_hash_find_td __P((ohci_softc_t *,
d159 2
a160 2
static usbd_status	ohci_setup_isoc __P((usbd_pipe_handle pipe));
static void		ohci_device_isoc_enter __P((usbd_xfer_handle));
d162 1
a162 1
static usbd_status	ohci_allocm __P((struct usbd_bus *, usb_dma_t *,
d164 1
a164 1
static void		ohci_freem __P((struct usbd_bus *, usb_dma_t *));
d166 2
a167 2
static usbd_xfer_handle	ohci_allocx __P((struct usbd_bus *));
static void		ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));
d169 35
a203 35
static usbd_status	ohci_root_ctrl_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_root_ctrl_start __P((usbd_xfer_handle));
static void		ohci_root_ctrl_abort __P((usbd_xfer_handle));
static void		ohci_root_ctrl_close __P((usbd_pipe_handle));
static void		ohci_root_ctrl_done  __P((usbd_xfer_handle));

static usbd_status	ohci_root_intr_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_root_intr_start __P((usbd_xfer_handle));
static void		ohci_root_intr_abort __P((usbd_xfer_handle));
static void		ohci_root_intr_close __P((usbd_pipe_handle));
static void		ohci_root_intr_done  __P((usbd_xfer_handle));

static usbd_status	ohci_device_ctrl_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_device_ctrl_start __P((usbd_xfer_handle));
static void		ohci_device_ctrl_abort __P((usbd_xfer_handle));
static void		ohci_device_ctrl_close __P((usbd_pipe_handle));
static void		ohci_device_ctrl_done  __P((usbd_xfer_handle));

static usbd_status	ohci_device_bulk_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_device_bulk_start __P((usbd_xfer_handle));
static void		ohci_device_bulk_abort __P((usbd_xfer_handle));
static void		ohci_device_bulk_close __P((usbd_pipe_handle));
static void		ohci_device_bulk_done  __P((usbd_xfer_handle));

static usbd_status	ohci_device_intr_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_device_intr_start __P((usbd_xfer_handle));
static void		ohci_device_intr_abort __P((usbd_xfer_handle));
static void		ohci_device_intr_close __P((usbd_pipe_handle));
static void		ohci_device_intr_done  __P((usbd_xfer_handle));

static usbd_status	ohci_device_isoc_transfer __P((usbd_xfer_handle));
static usbd_status	ohci_device_isoc_start __P((usbd_xfer_handle));
static void		ohci_device_isoc_abort __P((usbd_xfer_handle));
static void		ohci_device_isoc_close __P((usbd_pipe_handle));
static void		ohci_device_isoc_done  __P((usbd_xfer_handle));
d205 1
a205 1
static usbd_status	ohci_device_setintr __P((ohci_softc_t *sc, 
d208 1
a208 1
static int		ohci_str __P((usb_string_descriptor_t *, int, char *));
d210 2
a211 2
static void		ohci_timeout __P((void *));
static void		ohci_rhsc_able __P((ohci_softc_t *, int));
d213 1
a213 1
static void		ohci_close_pipe __P((usbd_pipe_handle pipe, 
d215 1
a215 1
static void		ohci_abort_xfer __P((usbd_xfer_handle xfer,
d217 1
a217 1
static void		ohci_abort_xfer_end __P((void *));
d219 2
a220 2
static void		ohci_device_clear_toggle __P((usbd_pipe_handle pipe));
static void		ohci_noop __P((usbd_pipe_handle pipe));
d223 6
a228 4
static void		ohci_dumpregs __P((ohci_softc_t *));
static void		ohci_dump_tds __P((ohci_soft_td_t *));
static void		ohci_dump_td __P((ohci_soft_td_t *));
static void		ohci_dump_ed __P((ohci_soft_ed_t *));
d236 1
a236 1
static u_int8_t revbits[OHCI_NO_INTRS] = 
d276 1
a276 1
static struct usbd_bus_methods ohci_bus_methods = {
d286 1
a286 1
static struct usbd_pipe_methods ohci_root_ctrl_methods = {	
d295 1
a295 1
static struct usbd_pipe_methods ohci_root_intr_methods = {	
d304 1
a304 1
static struct usbd_pipe_methods ohci_device_ctrl_methods = {	
d313 1
a313 1
static struct usbd_pipe_methods ohci_device_intr_methods = {	
d322 1
a322 1
static struct usbd_pipe_methods ohci_device_bulk_methods = {	
d331 1
a331 1
static struct usbd_pipe_methods ohci_device_isoc_methods = {
d357 1
d441 1
a441 1
			return (0);
d457 2
a458 2
	std->nexttd = 0;

a473 1

d577 1
a577 1
static void
d598 1
a598 1
	int i, offs;
d603 2
a604 2
		err = usb_allocmem(&sc->sc_bus, OHCI_STD_SIZE * OHCI_STD_CHUNK,
			  OHCI_TD_ALIGN, &dma);
d606 3
a608 3
			return (0);
		for(i = 0; i < OHCI_STD_CHUNK; i++) {
			offs = i * OHCI_STD_SIZE;
d615 2
d620 9
a628 1
	sitd->nextitd = 0;
d637 13
d652 1
d684 2
d1017 1
a1017 1
static int ohci_intr1 __P((ohci_softc_t *));
d1036 1
a1036 1
static int
d1082 1
a1082 13
		done &= ~OHCI_DONE_INTRS;
		if (sc->sc_done == 0)
			sc->sc_done = done;
		else {
			/* Tack on at the end of sc_done. */
			ohci_physaddr_t ldone;
			ohci_soft_td_t *std;

			for (ldone = sc->sc_done; ldone != 0; 
			     ldone = le32toh(std->td.td_nexttd))
				std = ohci_hash_find_td(sc, ldone);
			std->td.td_nexttd = htole32(done);
		}
d1154 42
d1200 2
a1201 2
	ohci_physaddr_t done;
	ohci_soft_td_t *std, *sdone, *stdnext;
d1208 4
a1211 2
	done = sc->sc_done;
	sc->sc_done = 0;
d1214 1
a1214 8
	DPRINTFN(10,("ohci_process_done: done=0x%08lx\n", (u_long)done));

	/* Reverse the done list. */
	for (sdone = NULL; done != 0; done = le32toh(std->td.td_nexttd)) {
		std = ohci_hash_find_td(sc, done);
		std->dnext = sdone;
		sdone = std;
	}
a1234 2
		cc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d1240 5
a1244 1
		} else if (cc == OHCI_CC_NO_ERROR) {
d1290 44
d1716 47
a1762 1
	panic("ohci_hash_find_td: addr 0x%08lx not found\n", (u_long)a);
d1808 30
d1904 4
d1916 1
a1916 1
			fmt = OHCI_ED_FORMAT_GEN;
a1920 1
			OHCI_ED_DIR_TD | 
d2093 1
a2093 1
static usb_device_descriptor_t ohci_devd = {
d2106 1
a2106 1
static usb_config_descriptor_t ohci_confd = {
d2119 1
a2119 1
static usb_interface_descriptor_t ohci_ifcd = {
d2131 1
a2131 1
static usb_endpoint_descriptor_t ohci_endpd = {
d2140 1
a2140 1
static usb_hub_descriptor_t ohci_hubd = {
d2150 1
a2150 1
static int
d2173 1
a2173 1
static usbd_status
d2188 1
a2188 1
static usbd_status
d2202 3
d2491 1
a2491 1
static void
d2499 1
a2499 1
static void
d2507 1
a2507 1
static usbd_status
d2522 1
a2522 1
static usbd_status
d2529 3
d2538 1
a2538 1
static void
d2555 1
a2555 1
static void
d2568 1
a2568 1
static usbd_status
d2583 1
a2583 1
static usbd_status
d2590 3
d2611 1
a2611 1
static void
d2620 1
a2620 1
static void
d2634 1
a2634 1
static void
d2643 1
a2643 1
static void
d2649 1
a2649 1
static usbd_status
d2664 1
a2664 1
static usbd_status
d2677 3
d2764 1
a2764 1
static void
d2775 1
a2775 1
static void
d2789 1
a2789 1
static usbd_status
d2804 1
a2804 1
static usbd_status
d2816 3
d2884 1
a2884 1
static void
d2896 1
a2896 1
static void
d2933 1
a2933 1
static usbd_status
d3020 1
a3020 1
	/* and put on interrupt list if the pipe wasn't running */
d3037 1
a3037 1
	ohci_physaddr_t buf, offs;
a3038 1
	int ncross;
d3041 14
a3054 1
	s = splusb();
d3057 2
a3058 1
	sitd->itd.itd_bp0 = htole32(buf & OHCI_ITD_PAGE_MASK);
d3060 1
a3060 2
	offs = buf & OHCI_ITD_OFFSET_MASK;
	ncross = 0;
d3062 1
d3064 1
a3064 1
		    ncross > 1) {	/* too many page crossings */
d3066 1
d3070 2
d3074 2
a3075 2
			sitd->nextitd = nsitd;
			sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
d3079 9
a3087 6
				OHCI_ITD_NOINTR |
				OHCI_ITD_SET_FC(OHCI_ITD_NOFFSET));
			sitd->itd.itd_be = htole32(
				le32toh(sitd->itd.itd_bp0) + offs - 1);
			nsitd->itd.itd_bp0 = htole32(
				(buf + offs) & OHCI_ITD_PAGE_MASK);
d3090 1
a3091 1
			ncross = 0;
d3093 2
a3094 5
		/* XXX byte order */
		sitd->itd.itd_offset[i] = 
		    offs | (ncross == 1 ? OHCI_ITD_PAGE_SELECT : 0);
		offs += xfer->frlengths[i];
		/* XXX update ncross */
d3099 2
d3103 2
a3104 3
	sitd->nextitd = nsitd;
	sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
	sitd->itd.itd_flags = le32toh(
d3109 7
a3115 1
	sitd->itd.itd_be = htole32(le32toh(sitd->itd.itd_bp0) + offs - 1);
d3117 14
d3132 1
a3134 1
	/* XXX update ED */
d3136 10
d3152 16
a3167 2
	printf("ohci_device_isoc_start: not implemented\n");
	return (USBD_INVAL);
d3174 51
d3231 15
a3245 1
	printf("ohci_device_isoc_done: not implemented\n");
d3253 1
d3255 1
d3260 4
d3273 1
d3276 4
d3281 3
@


1.8
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: ohci.c,v 1.7 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: ohci.c,v 1.78 2000/03/20 00:37:00 augustss Exp $	*/
d105 1
d107 2
a108 1
#define LE(x) (bswap32(x))
d110 3
a112 1
#define LE(x) (x)
d117 2
a118 2
ohci_soft_ed_t *ohci_alloc_sed __P((ohci_softc_t *));
void		ohci_free_sed __P((ohci_softc_t *, ohci_soft_ed_t *));
d120 2
a121 2
ohci_soft_td_t *ohci_alloc_std __P((ohci_softc_t *));
void		ohci_free_std __P((ohci_softc_t *, ohci_soft_td_t *));
d123 2
a124 2
ohci_soft_itd_t *ohci_alloc_sitd __P((ohci_softc_t *));
void ohci_free_sitd __P((ohci_softc_t *, ohci_soft_itd_t *));
d127 2
a128 2
void		ohci_free_std_chain __P((ohci_softc_t *, 
					 ohci_soft_td_t *, ohci_soft_td_t *));
d130 82
a211 78
usbd_status	ohci_alloc_std_chain __P((struct ohci_pipe *, ohci_softc_t *,
					  int, int, usbd_xfer_handle,
					  ohci_soft_td_t *,
					  ohci_soft_td_t **));

void		ohci_shutdown __P((void *v));
void		ohci_power __P((int, void *));
usbd_status	ohci_open __P((usbd_pipe_handle));
void		ohci_poll __P((struct usbd_bus *));
void		ohci_softintr __P((struct usbd_bus *));
void		ohci_waitintr __P((ohci_softc_t *, usbd_xfer_handle));
void		ohci_rhsc __P((ohci_softc_t *, usbd_xfer_handle));

usbd_status	ohci_device_request __P((usbd_xfer_handle xfer));
void		ohci_add_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
void		ohci_rem_ed __P((ohci_soft_ed_t *, ohci_soft_ed_t *));
void		ohci_hash_add_td __P((ohci_softc_t *, ohci_soft_td_t *));
void		ohci_hash_rem_td __P((ohci_softc_t *, ohci_soft_td_t *));
ohci_soft_td_t *ohci_hash_find_td __P((ohci_softc_t *, ohci_physaddr_t));

usbd_status	ohci_setup_isoc __P((usbd_pipe_handle pipe));
void		ohci_device_isoc_enter __P((usbd_xfer_handle));

usbd_status	ohci_allocm __P((struct usbd_bus *, usb_dma_t *, u_int32_t));
void		ohci_freem __P((struct usbd_bus *, usb_dma_t *));

usbd_xfer_handle ohci_allocx __P((struct usbd_bus *));
void		ohci_freex __P((struct usbd_bus *, usbd_xfer_handle));

usbd_status	ohci_root_ctrl_transfer __P((usbd_xfer_handle));
usbd_status	ohci_root_ctrl_start __P((usbd_xfer_handle));
void		ohci_root_ctrl_abort __P((usbd_xfer_handle));
void		ohci_root_ctrl_close __P((usbd_pipe_handle));
void		ohci_root_ctrl_done __P((usbd_xfer_handle));

usbd_status	ohci_root_intr_transfer __P((usbd_xfer_handle));
usbd_status	ohci_root_intr_start __P((usbd_xfer_handle));
void		ohci_root_intr_abort __P((usbd_xfer_handle));
void		ohci_root_intr_close __P((usbd_pipe_handle));
void		ohci_root_intr_done  __P((usbd_xfer_handle));

usbd_status	ohci_device_ctrl_transfer __P((usbd_xfer_handle));
usbd_status	ohci_device_ctrl_start __P((usbd_xfer_handle));
void		ohci_device_ctrl_abort __P((usbd_xfer_handle));
void		ohci_device_ctrl_close __P((usbd_pipe_handle));
void		ohci_device_ctrl_done  __P((usbd_xfer_handle));

usbd_status	ohci_device_bulk_transfer __P((usbd_xfer_handle));
usbd_status	ohci_device_bulk_start __P((usbd_xfer_handle));
void		ohci_device_bulk_abort __P((usbd_xfer_handle));
void		ohci_device_bulk_close __P((usbd_pipe_handle));
void		ohci_device_bulk_done  __P((usbd_xfer_handle));

usbd_status	ohci_device_intr_transfer __P((usbd_xfer_handle));
usbd_status	ohci_device_intr_start __P((usbd_xfer_handle));
void		ohci_device_intr_abort __P((usbd_xfer_handle));
void		ohci_device_intr_close __P((usbd_pipe_handle));
void		ohci_device_intr_done  __P((usbd_xfer_handle));

usbd_status	ohci_device_isoc_transfer __P((usbd_xfer_handle));
usbd_status	ohci_device_isoc_start __P((usbd_xfer_handle));
void		ohci_device_isoc_abort __P((usbd_xfer_handle));
void		ohci_device_isoc_close __P((usbd_pipe_handle));
void		ohci_device_isoc_done  __P((usbd_xfer_handle));

usbd_status	ohci_device_setintr __P((ohci_softc_t *sc, 
					 struct ohci_pipe *pipe, int ival));

int		ohci_str __P((usb_string_descriptor_t *, int, char *));

void		ohci_timeout __P((void *));
void		ohci_rhsc_able __P((ohci_softc_t *, int));

void		ohci_close_pipe __P((usbd_pipe_handle pipe, 
				     ohci_soft_ed_t *head));
void		ohci_abort_xfer __P((usbd_xfer_handle xfer,
					usbd_status status));
void		ohci_abort_xfer_end __P((void *));
d213 2
a214 2
void		ohci_device_clear_toggle __P((usbd_pipe_handle pipe));
void		ohci_noop __P((usbd_pipe_handle pipe));
d217 4
a220 4
void		ohci_dumpregs __P((ohci_softc_t *));
void		ohci_dump_tds __P((ohci_soft_td_t *));
void		ohci_dump_td __P((ohci_soft_td_t *));
void		ohci_dump_ed __P((ohci_soft_ed_t *));
a260 1
			int xxxxx;
d268 1
a268 1
struct usbd_bus_methods ohci_bus_methods = {
d278 1
a278 1
struct usbd_pipe_methods ohci_root_ctrl_methods = {	
d287 1
a287 1
struct usbd_pipe_methods ohci_root_intr_methods = {	
d296 1
a296 1
struct usbd_pipe_methods ohci_device_ctrl_methods = {	
d305 1
a305 1
struct usbd_pipe_methods ohci_device_intr_methods = {	
d314 1
a314 1
struct usbd_pipe_methods ohci_device_bulk_methods = {	
d323 1
a323 1
struct usbd_pipe_methods ohci_device_isoc_methods = {
d367 1
d370 1
d390 1
a390 1
				 OHCI_ED_ALIGN, &dma);
d430 1
a430 1
				 OHCI_TD_ALIGN, &dma);
d492 2
a493 2
	tdflags = LE(
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
d525 1
a525 1
		cur->td.td_cbp = LE(dataphys);
d527 2
a528 2
		cur->td.td_nexttd = LE(next->physaddr);
		cur->td.td_be = LE(dataphys + curlen - 1);
d552 1
a552 1
		cur->td.td_nexttd = LE(next->physaddr);
d563 1
a563 1
nomem:
d569 1
a569 1
void
d599 1
a599 1
		for (i = 0; i < OHCI_STD_CHUNK; i++) {
d641 1
d672 1
a672 1
	sc->sc_ctrl_head->ed.ed_flags |= LE(OHCI_ED_SKIP);
d680 1
a680 1
	sc->sc_bulk_head->ed.ed_flags |= LE(OHCI_ED_SKIP);
d688 1
a688 1
	sc->sc_isoc_head->ed.ed_flags |= LE(OHCI_ED_SKIP);
d701 1
a701 1
		sed->ed.ed_flags |= LE(OHCI_ED_SKIP);
d705 1
a705 1
			psed = sc->sc_isoc_head;
d707 1
a707 1
		sed->ed.ed_nexted = LE(psed->physaddr);
d715 1
a715 1
			LE(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);
d834 1
d837 1
d889 1
a889 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);	
d897 2
a898 1
void ohci_freex(bus, xfer)
d907 3
d924 1
a924 1
 * called from an interrupt context.  This is all right since we
d978 2
a979 2
		 LE(sc->sc_hcca->hcca_frame_number),
		 LE(sc->sc_hcca->hcca_done_head)));
d983 1
a983 1
int ohci_intr1 __P((ohci_softc_t *));
d999 1
a999 1
	return (ohci_intr1(sc));
d1002 1
a1002 1
int
d1018 1
a1018 1
	done = LE(sc->sc_hcca->hcca_done_head);
a1019 1
		sc->sc_hcca->hcca_done_head = 0;
d1038 1
a1038 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintr=0x%x\n", 
d1052 1
a1052 1
			/* Tack on at end of the sc_dne. */
d1056 2
a1057 2
			for (ldone = sc->sc_done; ldone != 0;
			     ldone = LE(std->td.td_nexttd))
d1059 1
a1059 1
			std->td.td_nexttd = LE(done);
d1126 1
a1126 1
	"NOT ACCESSED",
d1151 1
a1151 1
	for (sdone = NULL; done != 0; done = LE(std->td.td_nexttd)) {
d1169 9
a1177 2
		cc = OHCI_TD_GET_CC(LE(std->td.td_flags));
		usb_untimeout(ohci_timeout, xfer, xfer->timo_handle);
d1186 2
a1187 2
				len -= LE(std->td.td_be) -
				       LE(std->td.td_cbp) + 1;
d1207 3
a1209 3
			DPRINTF(("ohci_process_done: error cc=%d (%s)\n",
			 OHCI_TD_GET_CC(LE(std->td.td_flags)),
			 ohci_cc_strs[OHCI_TD_GET_CC(LE(std->td.td_flags))]));
d1218 1
a1218 1
			opipe->sed->ed.ed_headp = LE(p->physaddr);
d1255 1
d1270 1
a1270 1
		data->td.td_flags = LE(
d1274 2
a1275 2
			data->td.td_flags |= LE(OHCI_TD_R);
		data->td.td_cbp = LE(DMAADDR(&xfer->dmabuf));
d1277 3
a1279 2
		data->td.td_nexttd = LE(tail->physaddr);
		data->td.td_be = LE(LE(data->td.td_cbp) + xfer->length - 1);
d1286 1
a1286 1
		sed->ed.ed_tailp = LE(tail->physaddr);
d1298 1
a1298 1
	xfer->hcpriv = 0;
d1316 1
a1316 1
	if (xfer == 0) {
d1443 2
a1444 2
	sed->ed.ed_flags = LE(
	 (LE(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
d1455 1
a1455 1
			    std, &stat);
d1460 2
a1461 2
		std->td.td_flags &= LE(~OHCI_TD_TOGGLE_MASK);
		std->td.td_flags |= LE(OHCI_TD_TOGGLE_1);
d1466 3
a1468 3
	setup->td.td_flags = LE(OHCI_TD_SETUP | OHCI_TD_NOCC |
				 OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);
	setup->td.td_cbp = LE(DMAADDR(&opipe->u.ctl.reqdma));
d1470 2
a1471 2
	setup->td.td_nexttd = LE(next->physaddr);
	setup->td.td_be = LE(LE(setup->td.td_cbp) + sizeof *req - 1);
d1477 1
a1477 1
	stat->td.td_flags = LE(
d1482 1
a1482 1
	stat->td.td_nexttd = LE(tail->physaddr);
d1498 1
a1498 1
	sed->ed.ed_tailp = LE(tail->physaddr);
d1502 2
a1503 2
                usb_timeout(ohci_timeout, xfer,
			    MS_TO_TICKS(xfer->timeout), xfer->timo_handle);
d1539 1
a1539 1
	head->ed.ed_nexted = LE(sed->physaddr);
d1555 1
a1555 1
	for (p = head; p != NULL && p->next != sed; p = p->next)
d1607 1
a1607 1
	     std != NULL; 
d1646 1
a1646 1
		 (int)LE(std->td.td_flags),
d1648 6
a1653 5
		 OHCI_TD_GET_DI(LE(std->td.td_flags)),
		 OHCI_TD_GET_EC(LE(std->td.td_flags)),
		 OHCI_TD_GET_CC(LE(std->td.td_flags)),
		 (u_long)LE(std->td.td_cbp),
		 (u_long)LE(std->td.td_nexttd), (u_long)LE(std->td.td_be)));
d1661 1
a1661 1
		 "headsflags=%b headp=%b nexted=0x%08lx\n",
d1663 4
a1666 4
		 OHCI_ED_GET_FA(LE(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(LE(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(LE(sed->ed.ed_flags)),
		 (int)LE(sed->ed.ed_flags),
d1668 2
a1669 2
		 (u_long)LE(sed->ed.ed_tailp),
		 (u_long)LE(sed->ed.ed_headp),
d1671 2
a1672 2
		 (u_long)LE(sed->ed.ed_headp),
		 (u_long)LE(sed->ed.ed_nexted)));
d1697 1
d1721 1
a1721 1
			tdphys = LE(sitd->physaddr);
d1730 1
a1730 1
			tdphys = LE(std->physaddr);
d1733 1
a1733 1
		sed->ed.ed_flags = LE(
d1739 1
a1739 1
		sed->ed.ed_headp = sed->ed.ed_tailp = tdphys;
d1745 2
a1746 2
					 sizeof(usb_device_request_t), 
					 0, &opipe->u.ctl.reqdma);
d1797 4
a1800 4
	sed->ed.ed_flags |= LE(OHCI_ED_SKIP);
	if ((sed->ed.ed_tailp & LE(OHCI_HEADMASK)) != 
	    (sed->ed.ed_headp & LE(OHCI_HEADMASK))) {
		ohci_physaddr_t td = sed->ed.ed_headp;
d1809 2
a1810 1
		       (int)LE(sed->ed.ed_headp), (int)LE(sed->ed.ed_tailp),
d1813 2
a1814 2
		if ((sed->ed.ed_tailp & LE(OHCI_HEADMASK)) !=
		    (sed->ed.ed_headp & LE(OHCI_HEADMASK)))
d1845 1
a1845 1
	usb_untimeout(ohci_timeout, xfer, xfer->timo_handle);
d1849 1
a1849 1
	sed->ed.ed_flags |= LE(OHCI_ED_SKIP); /* force hardware skip */
d1854 2
a1855 1
		timeout(ohci_abort_xfer_end, xfer, hz / USB_FRAMES_PER_SECOND);
d1859 1
a1859 1
			("ohci_abort_req in interrupt context"));
d1897 3
a1899 3
		    (int)LE(p->physaddr), (int)LE(sed->ed.ed_tailp)));
	sed->ed.ed_headp = p->physaddr; /* unlink TDs */
	sed->ed.ed_flags &= LE(~OHCI_ED_SKIP); /* remove hardware skip */
d1909 1
a1909 1
usb_device_descriptor_t ohci_devd = {
d1922 1
a1922 1
usb_config_descriptor_t ohci_confd = {
d1935 1
a1935 1
usb_interface_descriptor_t ohci_ifcd = {
d1947 1
a1947 1
usb_endpoint_descriptor_t ohci_endpd = {
d1956 1
a1956 1
usb_hub_descriptor_t ohci_hubd = {
d1966 1
a1966 1
int
d1989 1
a1989 1
usbd_status
d2004 1
a2004 1
usbd_status
d2304 1
a2304 1
void
d2312 1
a2312 1
void
d2320 1
a2320 1
usbd_status
d2335 1
a2335 1
usbd_status
d2348 1
a2348 1
void
d2365 1
a2365 1
void
d2378 1
a2378 1
usbd_status
d2393 1
a2393 1
usbd_status
d2418 1
a2418 1
void
d2427 1
a2427 1
void
d2441 1
a2441 1
void
d2447 1
a2447 1
	opipe->sed->ed.ed_headp &= LE(~OHCI_TOGGLECARRY);
d2450 1
a2450 1
void
d2456 1
a2456 1
usbd_status
d2471 1
a2471 1
usbd_status
d2505 2
a2506 2
	sed->ed.ed_flags = LE(
		(LE(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |
d2511 2
a2512 1
	err = ohci_alloc_std_chain(opipe, sc, len, isread,  xfer, data, &tail);
d2514 2
a2515 2
	tail->td.td_flags &= LE(~OHCI_TD_INTR_MASK);
	tail->td.td_flags |= LE(OHCI_TD_SET_DI(1));
d2526 4
a2529 2
		    (int)LE(sed->ed.ed_flags), (int)LE(data->td.td_flags),
		    (int)LE(data->td.td_cbp), (int)LE(data->td.td_be)));
d2543 1
a2543 1
	sed->ed.ed_tailp = LE(tail->physaddr);
d2545 1
a2545 1
	sed->ed.ed_flags &= LE(~OHCI_ED_SKIP);
d2548 2
a2549 2
                usb_timeout(ohci_timeout, xfer,
			    MS_TO_TICKS(xfer->timeout), xfer->timo_handle);
d2568 1
a2568 1
void
d2579 1
a2579 1
void
d2593 1
a2593 1
usbd_status
d2608 1
a2608 1
usbd_status
d2637 1
a2637 1
	data->td.td_flags = LE(
d2641 2
a2642 2
		data->td.td_flags |= LE(OHCI_TD_R);
	data->td.td_cbp = LE(DMAADDR(&xfer->dmabuf));
d2644 2
a2645 2
	data->td.td_nexttd = LE(tail->physaddr);
	data->td.td_be = LE(LE(data->td.td_cbp) + len - 1);
d2661 1
a2661 1
	sed->ed.ed_tailp = LE(tail->physaddr);
d2663 1
a2663 1
	sed->ed.ed_flags &= LE(~OHCI_ED_SKIP);
d2685 1
a2685 1
void
d2697 1
a2697 1
void
d2712 3
a2714 3
	sed->ed.ed_flags |= LE(OHCI_ED_SKIP);
	if ((sed->ed.ed_tailp & LE(OHCI_HEADMASK)) != 
	    (sed->ed.ed_headp & LE(OHCI_HEADMASK)))
d2734 1
a2734 1
usbd_status
d2787 1
a2787 1
	hsed->ed.ed_nexted = LE(sed->physaddr);
d2818 1
a2818 1
	/* insert into schedule */
d2837 1
a2837 1
	ohci_soft_itd_t *sitd, *nsitd;
d2846 1
a2846 1
	sitd->itd.itd_bp0 = LE(buf & OHCI_ITD_PAGE_MASK);
d2850 4
a2853 3
	for (i = ncur = 0; i < nframes; i ++, ncur++) {
		if (ncur == OHCI_ITD_NOFFSET || /* all offsets used */
		    ncross > 1) {		/* too many page crossings */
d2860 3
a2862 3
			sitd->itd.itd_nextitd = LE(nsitd->physaddr);
			sitd->itd.itd_flags = LE(
				OHCI_ITD_NOCC |
d2866 4
a2869 2
			sitd->itd.itd_be = LE(LE(sitd->itd.itd_bp0) + offs - 1);
			nsitd->itd.itd_bp0 = LE((buf + offs) & OHCI_ITD_PAGE_MASK);
d2871 1
a2871 1
			iso->next = iso->next + ncur;
d2876 1
a2876 1
		sitd->itd.itd_offset[i] =
d2887 3
a2889 3
	sitd->itd.itd_nextitd = LE(nsitd->physaddr);
	sitd->itd.itd_flags = LE(
		OHCI_ITD_NOCC |
d2893 1
a2893 1
	sitd->itd.itd_be = LE(LE(sitd->itd.itd_bp0) + offs - 1);
d2897 1
a2897 1
	sed->ed.ed_tailp = LE(nsitd->physaddr);
a2946 1

@


1.7
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.6 1999/09/27 18:03:54 fgsch Exp $	*/
/*	$NetBSD: ohci.c,v 1.48 1999/09/15 21:14:03 augustss Exp $	*/
a49 1
#include <sys/kernel.h>
d52 1
d54 1
d60 3
a65 1
#include <sys/select.h>
d81 1
d118 4
d124 1
d126 1
a126 1
					  int, int, int, usb_dma_t *, 
d130 1
d134 3
a136 3
void		ohci_waitintr __P((ohci_softc_t *, usbd_request_handle));
void		ohci_rhsc __P((ohci_softc_t *, usbd_request_handle));
void		ohci_process_done __P((ohci_softc_t *, ohci_physaddr_t));
d138 1
a138 1
usbd_status	ohci_device_request __P((usbd_request_handle reqh));
d145 3
d151 6
a156 3
usbd_status	ohci_root_ctrl_transfer __P((usbd_request_handle));
usbd_status	ohci_root_ctrl_start __P((usbd_request_handle));
void		ohci_root_ctrl_abort __P((usbd_request_handle));
d158 1
d160 3
a162 3
usbd_status	ohci_root_intr_transfer __P((usbd_request_handle));
usbd_status	ohci_root_intr_start __P((usbd_request_handle));
void		ohci_root_intr_abort __P((usbd_request_handle));
d164 1
a164 1
void		ohci_root_intr_done  __P((usbd_request_handle));
d166 3
a168 3
usbd_status	ohci_device_ctrl_transfer __P((usbd_request_handle));
usbd_status	ohci_device_ctrl_start __P((usbd_request_handle));
void		ohci_device_ctrl_abort __P((usbd_request_handle));
d170 1
a170 1
void		ohci_device_ctrl_done  __P((usbd_request_handle));
d172 3
a174 3
usbd_status	ohci_device_bulk_transfer __P((usbd_request_handle));
usbd_status	ohci_device_bulk_start __P((usbd_request_handle));
void		ohci_device_bulk_abort __P((usbd_request_handle));
d176 1
a176 1
void		ohci_device_bulk_done  __P((usbd_request_handle));
d178 3
a180 3
usbd_status	ohci_device_intr_transfer __P((usbd_request_handle));
usbd_status	ohci_device_intr_start __P((usbd_request_handle));
void		ohci_device_intr_abort __P((usbd_request_handle));
d182 1
a182 1
void		ohci_device_intr_done  __P((usbd_request_handle));
d184 3
a186 3
usbd_status	ohci_device_isoc_transfer __P((usbd_request_handle));
usbd_status	ohci_device_isoc_start __P((usbd_request_handle));
void		ohci_device_isoc_abort __P((usbd_request_handle));
d188 1
a188 1
void		ohci_device_isoc_done  __P((usbd_request_handle));
d200 1
a200 1
void		ohci_abort_req __P((usbd_request_handle reqh,
d202 1
a202 1
void		ohci_abort_req_end __P((void *));
a207 1
ohci_softc_t   *thesc;
d228 4
a231 1
	ohci_soft_td_t *tail;
d253 1
d262 1
d266 2
d276 1
a276 1
	0,
a314 1
#if 0
a322 1
#endif
d324 1
d360 2
d366 1
d373 1
a373 1
	usbd_status r;
d377 1
a377 1
	if (!sc->sc_freeeds) {
d379 1
a379 1
		r = usb_allocmem(&sc->sc_bus, OHCI_SED_SIZE * OHCI_SED_CHUNK,
d381 1
a381 1
		if (r != USBD_NORMAL_COMPLETION)
d412 1
a412 1
	usbd_status r;
d415 1
d417 1
a417 1
	if (!sc->sc_freetds) {
d419 1
a419 1
		r = usb_allocmem(&sc->sc_bus, OHCI_STD_SIZE * OHCI_STD_CHUNK,
d421 1
a421 1
		if (r != USBD_NORMAL_COMPLETION)
d423 1
d431 1
d433 2
d439 4
d451 5
d458 1
d462 2
a463 2
ohci_alloc_std_chain(upipe, sc, len, rd, shortok, dma, sp, ep)
	struct ohci_pipe *upipe;
d465 2
a466 2
	int len, rd, shortok;
	usb_dma_t *dma;
d471 4
a474 2
	u_int32_t intr;
	int curlen;
d476 3
a478 1
	DPRINTFN(len >= 4096,("ohci_alloc_std_chain: start len=%d\n", len));
d482 5
d489 2
a490 4
		if (next == 0) {
			/* XXX free chain */
			return (USBD_NOMEM);
		}
d501 6
d514 1
a514 5
		intr = len == 0 ? OHCI_TD_SET_DI(1) : OHCI_TD_NOINTR;
		cur->td.td_flags = LE(
			(rd ? OHCI_TD_IN : OHCI_TD_OUT) | OHCI_TD_NOCC |
			intr | OHCI_TD_TOGGLE_CARRY |
			(shortok ? OHCI_TD_R : 0));
d521 1
d530 20
a549 2
	cur->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
	*ep = next;
d552 4
d558 1
d572 40
d618 1
a618 2
	usbd_status r;
	int rev;
d620 1
a620 1
	u_int32_t s, ctl, ival, hcr, fm, per;
a622 1
	rev = OREAD4(sc, OHCI_REVISION);
d624 1
a624 1
	printf(" version %d.%d%s", 
d626 1
a626 1
	printf("%s: OHCI version %d.%d%s\n", USBDEVNAME(sc->sc_bus.bdev),
d628 2
a629 1
	       OHCI_REV_HI(rev), OHCI_REV_LO(rev),
a631 3
#if defined(__OpenBSD__)
		printf(": unsupported\n");
#else
d634 1
a634 1
#endif
a635 4
#if defined(__OpenBSD__)
	} else {
		printf("\n");
#endif
d637 1
d642 3
d646 1
a646 1
	r = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, 
d648 2
a649 2
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d655 1
d657 2
a658 2
	if (!sc->sc_ctrl_head) {
		r = USBD_NOMEM;
d663 1
d665 2
a666 2
	if (!sc->sc_bulk_head) {
		r = USBD_NOMEM;
d671 8
d682 1
a682 1
		if (!sed) {
d685 2
a686 2
			r = USBD_NOMEM;
			goto bad3;
d691 1
a691 1
		if (i != 0) {
d693 4
a696 3
			sed->next = psed;
			sed->ed.ed_nexted = LE(psed->physaddr);
		}
d706 11
d725 1
a725 1
			delay(1000);
d739 1
a739 1
			delay(USB_RESUME_DELAY * 1000);
d745 1
a745 1
		delay(USB_BUS_RESET_DELAY * 1000);
d754 1
a754 1
	delay(USB_BUS_RESET_DELAY * 1000);
d769 2
a770 2
		r = USBD_IOERROR;
		goto bad3;
a772 1
	thesc = sc;
d777 1
a777 1
	/* The controller is now in suspend state, we have 2ms to finish. */
d783 1
d786 1
d805 6
a810 1
	OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC);	/* Enable port power */
d824 1
d828 5
d839 1
a839 1
	return (r);
d867 43
a909 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a922 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a924 3
void ohcidump(void);
void ohcidump(void) { ohci_dumpregs(thesc); }

d966 2
d973 16
d1010 1
d1013 1
d1022 1
a1022 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=%x(%x) eintr=%x\n", 
d1032 15
a1046 1
		ohci_process_done(sc, done &~ OHCI_DONE_INTRS);
d1060 1
a1060 1
		ohci_rhsc(sc, sc->sc_intrreqh);
d1108 3
d1116 4
a1119 2
ohci_process_done(sc, done)
	ohci_softc_t *sc;
a1120 1
{
d1122 9
a1130 2
	usbd_request_handle reqh;
	int len, cc;
d1135 1
a1135 1
	for (sdone = 0; done; done = LE(std->td.td_nexttd)) {
d1149 1
a1149 1
		reqh = std->reqh;
d1151 2
a1152 2
		DPRINTFN(10, ("ohci_process_done: std=%p reqh=%p hcpriv=%p\n",
				std, reqh, reqh->hcpriv));
d1154 3
a1156 3
		usb_untimeout(ohci_timeout, reqh, reqh->timo_handle);
		if (reqh->status == USBD_CANCELLED ||
		    reqh->status == USBD_TIMEOUT) {
d1158 1
a1158 1
				 reqh));
d1165 2
d1168 1
a1168 1
				reqh->actlen += len;
d1170 2
a1171 2
				reqh->status = USBD_NORMAL_COMPLETION;
				usb_transfer_complete(reqh);
a1172 1
			ohci_hash_rem_td(sc, std);
d1182 1
a1182 1
				(struct ohci_pipe *)reqh->pipe;
d1184 1
a1184 1
			DPRINTFN(-1,("ohci_process_done: error cc=%d (%s)\n",
d1189 1
a1189 1
			for (p = std; p->reqh == reqh; p = n) {
a1190 1
				ohci_hash_rem_td(sc, p);
d1199 1
a1199 1
				reqh->status = USBD_STALLED;
d1201 2
a1202 2
				reqh->status = USBD_IOERROR;
			usb_transfer_complete(reqh);
d1205 2
d1210 2
a1211 2
ohci_device_ctrl_done(reqh)
	usbd_request_handle reqh;
d1213 1
a1213 1
	DPRINTFN(10,("ohci_ctrl_done: reqh=%p\n", reqh));
d1216 1
a1216 1
	if (!(reqh->rqflags & URQ_REQUEST)) {
d1220 1
a1220 1
	reqh->hcpriv = 0;
d1224 2
a1225 2
ohci_device_intr_done(reqh)
	usbd_request_handle reqh;
d1227 1
a1227 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
d1232 2
d1235 1
a1235 4
	DPRINTFN(10,("ohci_intr_done: reqh=%p, actlen=%d\n", 
		     reqh, reqh->actlen));

	reqh->hcpriv = 0;
d1237 2
a1238 2
	if (reqh->pipe->repeat) {
		data = opipe->tail;
d1240 2
a1241 2
		if (!tail) {
			reqh->status = USBD_NOMEM;
d1244 1
a1244 1
		tail->reqh = 0;
d1249 1
a1249 1
		if (reqh->flags & USBD_SHORT_XFER_OK)
d1251 1
a1251 1
		data->td.td_cbp = LE(DMAADDR(&reqh->dmabuf));
d1254 3
a1256 3
		data->td.td_be = LE(LE(data->td.td_cbp) + reqh->length - 1);
		data->len = reqh->length;
		data->reqh = reqh;
d1258 2
a1259 2
		reqh->hcpriv = data;
		reqh->actlen = 0;
a1260 1
		ohci_hash_add_td(sc, data);
d1262 1
a1262 1
		opipe->tail = tail;
d1267 2
a1268 2
ohci_device_bulk_done(reqh)
	usbd_request_handle reqh;
d1270 2
a1271 2
	DPRINTFN(10,("ohci_bulk_done: reqh=%p, actlen=%d\n", 
		     reqh, reqh->actlen));
d1273 1
a1273 1
	reqh->hcpriv = 0;
d1277 1
a1277 1
ohci_rhsc(sc, reqh)
d1279 1
a1279 1
	usbd_request_handle reqh;
d1288 2
a1289 2
	DPRINTF(("ohci_rhsc: sc=%p reqh=%p hstatus=0x%08x\n", 
		 sc, reqh, hstatus));
d1291 1
a1291 1
	if (reqh == 0) {
d1296 1
a1296 1
	pipe = reqh->pipe;
d1299 3
a1301 3
	p = KERNADDR(&reqh->dmabuf);
	m = min(sc->sc_noport, reqh->length * 8 - 1);
	memset(p, 0, reqh->length);
d1307 2
a1308 2
	reqh->actlen = reqh->length;
	reqh->status = USBD_NORMAL_COMPLETION;
d1310 1
a1310 1
	usb_transfer_complete(reqh);
d1314 2
a1315 2
ohci_root_intr_done(reqh)
	usbd_request_handle reqh;
d1317 8
a1324 1
	reqh->hcpriv = 0;
d1333 1
a1333 1
ohci_waitintr(sc, reqh)
d1335 1
a1335 1
	usbd_request_handle reqh;
d1337 1
a1337 1
	int timo = reqh->timeout;
d1341 1
a1341 1
	reqh->status = USBD_IN_PROGRESS;
d1351 2
a1352 2
			ohci_intr(sc);
			if (reqh->status != USBD_IN_PROGRESS)
d1359 2
a1360 2
	reqh->status = USBD_TIMEOUT;
	usb_transfer_complete(reqh);
d1371 1
a1371 1
		ohci_intr(sc);
d1375 2
a1376 2
ohci_device_request(reqh)
	usbd_request_handle reqh;
d1378 2
a1379 2
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
	usb_device_request_t *req = &reqh->request;
d1383 1
a1383 1
	ohci_soft_td_t *setup, *data = 0, *stat, *next, *tail;
d1387 1
a1387 1
	usbd_status r;
d1399 1
a1399 1
	setup = opipe->tail;
d1401 2
a1402 2
	if (!stat) {
		r = USBD_NOMEM;
d1406 2
a1407 2
	if (!tail) {
		r = USBD_NOMEM;
d1410 1
a1410 1
	tail->reqh = 0;
d1417 1
d1423 2
d1427 6
a1432 3
		data = ohci_alloc_std(sc);
		if (!data) {
			r = USBD_NOMEM;
d1434 3
a1436 19
		}
		data->td.td_flags = LE(
			(isread ? OHCI_TD_IN : OHCI_TD_OUT) | OHCI_TD_NOCC |
			OHCI_TD_TOGGLE_1 | OHCI_TD_NOINTR |
			(reqh->flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0));
		data->td.td_cbp = LE(DMAADDR(&reqh->dmabuf));
		data->nexttd = stat;
		data->td.td_nexttd = LE(stat->physaddr);
		data->td.td_be = LE(LE(data->td.td_cbp) + len - 1);
		data->len = len;
		data->reqh = reqh;
		data->flags = OHCI_ADD_LEN;

		next = data;
		stat->flags = OHCI_CALL_DONE;
	} else {
		next = stat;
		/* XXX ADD_LEN? */
		stat->flags = OHCI_CALL_DONE | OHCI_ADD_LEN;
d1447 2
a1448 2
	setup->len = 0;		/* XXX The number of byte we count */
	setup->reqh = reqh;
d1450 1
a1450 1
	reqh->hcpriv = setup;
d1453 2
a1454 2
		(isread ? OHCI_TD_OUT : OHCI_TD_IN) | OHCI_TD_NOCC |
		OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));
d1459 1
d1461 1
a1461 1
	stat->reqh = reqh;
a1472 4
	ohci_hash_add_td(sc, setup);
	if (len != 0)
		ohci_hash_add_td(sc, data);
	ohci_hash_add_td(sc, stat);
d1474 1
a1474 1
	opipe->tail = tail;
d1476 3
a1478 3
	if (reqh->timeout && !sc->sc_bus.use_polling) {
                usb_timeout(ohci_timeout, reqh,
			    MS_TO_TICKS(reqh->timeout), reqh->timo_handle);
d1482 3
a1484 3
#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		delay(5000);
d1499 1
a1499 1
	return (r);
d1530 1
a1530 1
	for (p = head; p && p->next != sed; p = p->next)
d1532 1
a1532 1
	if (!p)
d1582 1
a1582 1
	     std != 0; 
d1593 1
a1593 1
	usbd_request_handle reqh = addr;
d1596 1
a1596 1
	DPRINTF(("ohci_timeout: reqh=%p\n", reqh));
d1599 3
a1601 3
	reqh->device->bus->intr_context++;
	ohci_abort_req(reqh, USBD_TIMEOUT);
	reqh->device->bus->intr_context--;
d1634 2
a1635 2
	DPRINTF(("ED(%p) at %08lx: addr=%d endpt=%d maxp=%d %b\ntailp=0x%08lx "
		 "headp=%b nexted=0x%08lx\n",
d1645 1
d1659 1
d1662 4
a1665 1
	usbd_status r;
d1667 1
d1684 1
a1684 1
		if (sed == 0)
a1685 3
	        std = ohci_alloc_std(sc);
		if (std == 0)
			goto bad1;
d1687 19
a1705 1
		opipe->tail = std;
d1710 1
a1710 3
			(dev->lowspeed ? OHCI_ED_SPEED : 0) | 
			((ed->bmAttributes & UE_XFERTYPE) == UE_ISOCHRONOUS ?
			 OHCI_ED_FORMAT_ISO : OHCI_ED_FORMAT_GEN) |
d1712 1
a1712 1
		sed->ed.ed_headp = sed->ed.ed_tailp = LE(std->physaddr);
d1714 1
a1714 1
		switch (ed->bmAttributes & UE_XFERTYPE) {
d1717 1
a1717 1
			r = usb_allocmem(&sc->sc_bus, 
d1720 1
a1720 1
			if (r != USBD_NORMAL_COMPLETION)
d1728 4
a1731 1
			return (ohci_device_setintr(sc, opipe, ed->bInterval));
d1733 2
a1734 2
			printf("ohci_open: open iso unimplemented\n");
			return (USBD_INVAL);
d1771 2
a1772 2
	if ((sed->ed.ed_tailp & LE(OHCI_TAILMASK)) != 
	    (sed->ed.ed_headp & LE(OHCI_TAILMASK))) {
d1776 1
a1776 1
		     std != 0; 
d1785 2
a1786 2
		if ((sed->ed.ed_tailp & LE(OHCI_TAILMASK)) != 
		    (sed->ed.ed_headp & LE(OHCI_TAILMASK)))
a1791 1
	ohci_free_std(sc, opipe->tail);
d1806 2
a1807 2
ohci_abort_req(reqh, status)
	usbd_request_handle reqh;
d1810 1
a1810 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
d1813 1
a1813 1
	DPRINTF(("ohci_abort_req: reqh=%p pipe=%p\n", reqh, opipe));
d1815 1
a1815 1
	reqh->status = status;
d1817 1
a1817 1
	usb_untimeout(ohci_timeout, reqh, reqh->timo_handle);
d1820 1
a1820 1
	DPRINTFN(1,("ohci_abort_req: stop ed=%p\n", sed));
d1823 2
a1824 1
	if (reqh->device->bus->intr_context) {
d1826 1
a1826 1
		timeout(ohci_abort_req_end, reqh, hz / USB_FRAMES_PER_SECOND);
d1828 4
d1833 1
a1833 1
		ohci_abort_req_end(reqh);
d1835 4
d1842 1
a1842 1
ohci_abort_req_end(v)
d1845 2
a1846 2
	usbd_request_handle reqh = v;
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
d1854 1
a1854 1
	p = reqh->hcpriv;
d1856 2
a1857 2
	if (!p) {
		printf("ohci_abort_req: hcpriv==0\n");
d1861 1
a1861 1
	for (; p->reqh == reqh; p = n) {
a1862 1
		ohci_hash_rem_td(sc, p);
d1867 1
a1867 1
	DPRINTFN(2,("ohci_abort_req: set hd=%x, tl=%x\n",
d1872 1
a1872 1
	usb_transfer_complete(reqh);
d1884 2
a1885 2
	UCLASS_HUB,		/* class */
	USUBCLASS_HUB,		/* subclass */
d1912 2
a1913 2
	UCLASS_HUB,
	USUBCLASS_HUB,
d1961 2
a1962 2
ohci_root_ctrl_transfer(reqh)
	usbd_request_handle reqh;
d1964 1
a1964 1
	usbd_status r;
d1967 3
a1969 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1972 1
a1972 1
	return (ohci_root_ctrl_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d1976 2
a1977 2
ohci_root_ctrl_start(reqh)
	usbd_request_handle reqh;
d1979 1
a1979 1
	ohci_softc_t *sc = (ohci_softc_t *)reqh->pipe->device->bus;
d1986 1
a1986 1
	usbd_status r;
d1990 1
a1990 1
	if (!(reqh->rqflags & URQ_REQUEST))
d1994 1
a1994 1
	req = &reqh->request;
d2004 1
a2004 1
		buf = KERNADDR(&reqh->dmabuf);
d2027 1
a2027 1
				r = USBD_IOERROR;
d2036 1
a2036 1
				r = USBD_IOERROR;
d2067 1
a2067 1
			r = USBD_IOERROR;
d2092 1
a2092 1
			r = USBD_IOERROR;
d2099 1
a2099 1
			r = USBD_IOERROR;
d2109 1
a2109 1
		r = USBD_IOERROR;
d2123 1
a2123 1
			r = USBD_IOERROR;
d2153 1
a2153 1
			r = USBD_IOERROR;
d2172 1
a2172 1
			r = USBD_IOERROR;
d2194 1
a2194 1
			r = USBD_IOERROR;
d2204 1
a2204 1
			r = USBD_IOERROR;
d2208 1
a2208 1
			r = USBD_IOERROR;
d2221 1
a2221 1
		r = USBD_IOERROR;
d2227 1
a2227 1
			r = USBD_IOERROR;
d2256 1
a2256 1
			r = USBD_IOERROR;
d2261 1
a2261 1
		r = USBD_IOERROR;
d2264 2
a2265 2
	reqh->actlen = totlen;
	r = USBD_NORMAL_COMPLETION;
d2267 1
a2267 1
	reqh->status = r;
d2269 1
a2269 1
	usb_transfer_complete(reqh);
d2276 2
a2277 2
ohci_root_ctrl_abort(reqh)
	usbd_request_handle reqh;
d2292 2
a2293 2
ohci_root_intr_transfer(reqh)
	usbd_request_handle reqh;
d2295 1
a2295 1
	usbd_status r;
d2298 3
a2300 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2303 1
a2303 1
	return (ohci_root_intr_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d2307 2
a2308 2
ohci_root_intr_start(reqh)
	usbd_request_handle reqh;
d2310 1
a2310 1
	usbd_pipe_handle pipe = reqh->pipe;
d2313 1
a2313 1
	sc->sc_intrreqh = reqh;
d2320 2
a2321 2
ohci_root_intr_abort(reqh)
	usbd_request_handle reqh;
d2323 3
a2325 1
	if (reqh->pipe->intrreqh == reqh) {
d2327 1
a2327 1
		reqh->pipe->intrreqh = 0;
d2329 4
a2332 2
	reqh->status = USBD_CANCELLED;
	usb_transfer_complete(reqh);
d2344 1
a2344 1
	sc->sc_intrreqh = 0;
d2350 2
a2351 2
ohci_device_ctrl_transfer(reqh)
	usbd_request_handle reqh;
d2353 1
a2353 1
	usbd_status r;
d2356 3
a2358 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2361 1
a2361 1
	return (ohci_device_ctrl_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d2365 2
a2366 2
ohci_device_ctrl_start(reqh)
	usbd_request_handle reqh;
d2368 2
a2369 2
	ohci_softc_t *sc = (ohci_softc_t *)reqh->pipe->device->bus;
	usbd_status r;
d2372 1
a2372 1
	if (!(reqh->rqflags & URQ_REQUEST)) {
d2379 3
a2381 3
	r = ohci_device_request(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2384 1
a2384 1
		ohci_waitintr(sc, reqh);
d2390 2
a2391 2
ohci_device_ctrl_abort(reqh)
	usbd_request_handle reqh;
d2393 2
a2394 2
	DPRINTF(("ohci_device_ctrl_abort: reqh=%p\n", reqh));
	ohci_abort_req(reqh, USBD_CANCELLED);
d2402 1
d2407 1
d2418 1
a2418 1
	opipe->sed->ed.ed_tailp &= LE(~OHCI_TOGGLECARRY);
d2428 2
a2429 2
ohci_device_bulk_transfer(reqh)
	usbd_request_handle reqh;
d2431 1
a2431 1
	usbd_status r;
d2434 3
a2436 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2439 1
a2439 1
	return (ohci_device_bulk_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d2443 2
a2444 2
ohci_device_bulk_start(reqh)
	usbd_request_handle reqh;
d2446 1
a2446 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
d2453 1
a2453 1
	usbd_status r;
d2456 1
a2456 1
	if (reqh->rqflags & URQ_REQUEST) {
d2463 2
a2464 2
	len = reqh->length;
	endpt = reqh->pipe->endpoint->edesc->bEndpointAddress;
d2468 2
a2469 2
	DPRINTFN(4,("ohci_device_bulk_start: reqh=%p len=%d isread=%d "
		    "flags=%d endpt=%d\n", reqh, len, isread, reqh->flags,
d2481 9
a2489 6
	data = opipe->tail;
	r = ohci_alloc_std_chain(opipe, sc, len, isread, 
				 reqh->flags & USBD_SHORT_XFER_OK,
				 &reqh->dmabuf, data, &tail);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2491 2
a2492 2
	tail->reqh = 0;
	reqh->hcpriv = data;
d2500 1
a2500 1
	if (ohcidebug > 4) {
d2509 1
a2509 2
		tdp->reqh = reqh;
		ohci_hash_add_td(sc, tdp);
d2512 1
a2512 1
	opipe->tail = tail;
d2515 3
a2517 3
	if (reqh->timeout && !sc->sc_bus.use_polling) {
                usb_timeout(ohci_timeout, reqh,
			    MS_TO_TICKS(reqh->timeout), reqh->timo_handle);
d2522 2
a2523 2
	if (ohcidebug > 5) {
		delay(5000);
d2537 2
a2538 2
ohci_device_bulk_abort(reqh)
	usbd_request_handle reqh;
d2540 2
a2541 2
	DPRINTF(("ohci_device_bulk_abort: reqh=%p\n", reqh));
	ohci_abort_req(reqh, USBD_CANCELLED);
d2551 1
d2556 1
d2562 2
a2563 2
ohci_device_intr_transfer(reqh)
	usbd_request_handle reqh;
d2565 1
a2565 1
	usbd_status r;
d2568 3
a2570 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2573 1
a2573 1
	return (ohci_device_intr_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d2577 2
a2578 2
ohci_device_intr_start(reqh)
	usbd_request_handle reqh;
d2580 1
a2580 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
d2588 1
a2588 1
	DPRINTFN(3, ("ohci_device_intr_transfer: reqh=%p len=%d "
d2590 1
a2590 1
		     reqh, reqh->length, reqh->flags, reqh->priv));
d2593 1
a2593 1
	if (reqh->rqflags & URQ_REQUEST)
d2597 1
a2597 1
	len = reqh->length;
d2599 1
a2599 1
	data = opipe->tail;
d2601 1
a2601 1
	if (!tail)
d2603 1
a2603 1
	tail->reqh = 0;
d2608 1
a2608 1
	if (reqh->flags & USBD_SHORT_XFER_OK)
d2610 1
a2610 1
	data->td.td_cbp = LE(DMAADDR(&reqh->dmabuf));
d2615 1
a2615 1
	data->reqh = reqh;
d2617 1
a2617 1
	reqh->hcpriv = data;
a2628 1
	ohci_hash_add_td(sc, data);
d2630 1
a2630 1
	opipe->tail = tail;
d2640 1
a2640 1
		delay(5000);
d2654 2
a2655 2
ohci_device_intr_abort(reqh)
	usbd_request_handle reqh;
d2657 1
a2657 1
	if (reqh->pipe->intrreqh == reqh) {
d2659 1
a2659 1
		reqh->pipe->intrreqh = 0;
d2661 1
a2661 1
	ohci_abort_req(reqh, USBD_CANCELLED);
d2681 2
a2682 2
	if ((sed->ed.ed_tailp & LE(OHCI_TAILMASK)) != 
	    (sed->ed.ed_headp & LE(OHCI_TAILMASK)))
d2687 2
a2688 1
	if (!p)
d2690 1
d2698 1
a2698 1
	ohci_free_std(sc, opipe->tail);
d2765 146
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: ohci.c,v 1.20 2001/03/25 07:03:26 csapuntz Exp $ */
/*	$NetBSD: ohci.c,v 1.93 2000/08/17 23:18:56 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/ohci.c,v 1.22 1999/11/17 22:33:40 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d44 2
a45 2
 * OHCI spec: http://www.compaq.com/productinfo/development/openhci.html
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
d50 1
a52 1
#include <sys/kernel.h>
a53 1
#include <sys/select.h>
a58 3
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
#include <machine/cpu.h>
#endif
d62 1
a77 1

a90 3
#ifndef __NetBSD__
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#endif
a99 1
#if defined(__FreeBSD__)
d101 1
a101 2
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
d103 1
a103 3
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
d108 2
a109 2
Static ohci_soft_ed_t  *ohci_alloc_sed(ohci_softc_t *);
Static void		ohci_free_sed(ohci_softc_t *, ohci_soft_ed_t *);
d111 2
a112 2
Static ohci_soft_td_t  *ohci_alloc_std(ohci_softc_t *);
Static void		ohci_free_std(ohci_softc_t *, ohci_soft_td_t *);
d114 72
a185 2
Static ohci_soft_itd_t *ohci_alloc_sitd(ohci_softc_t *);
Static void		ohci_free_sitd(ohci_softc_t *,ohci_soft_itd_t *);
d187 9
a195 3
#if 0
Static void		ohci_free_std_chain(ohci_softc_t *, ohci_soft_td_t *,
					    ohci_soft_td_t *);
a196 82
Static usbd_status	ohci_alloc_std_chain(struct ohci_pipe *,
			    ohci_softc_t *, int, int, usbd_xfer_handle,
			    ohci_soft_td_t *, ohci_soft_td_t **);

Static void		ohci_shutdown(void *v);
Static void		ohci_power(int, void *);
Static usbd_status	ohci_open(usbd_pipe_handle);
Static void		ohci_poll(struct usbd_bus *);
Static void		ohci_softintr(struct usbd_bus *);
Static void		ohci_waitintr(ohci_softc_t *, usbd_xfer_handle);
Static void		ohci_add_done(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_rhsc(ohci_softc_t *, usbd_xfer_handle);

Static usbd_status	ohci_device_request(usbd_xfer_handle xfer);
Static void		ohci_add_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_rem_ed(ohci_soft_ed_t *, ohci_soft_ed_t *);
Static void		ohci_hash_add_td(ohci_softc_t *, ohci_soft_td_t *);
Static void		ohci_hash_rem_td(ohci_softc_t *, ohci_soft_td_t *);
Static ohci_soft_td_t  *ohci_hash_find_td(ohci_softc_t *, ohci_physaddr_t);
Static void		ohci_hash_add_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static void		ohci_hash_rem_itd(ohci_softc_t *, ohci_soft_itd_t *);
Static ohci_soft_itd_t  *ohci_hash_find_itd(ohci_softc_t *, ohci_physaddr_t);

Static usbd_status	ohci_setup_isoc(usbd_pipe_handle pipe);
Static void		ohci_device_isoc_enter(usbd_xfer_handle);

Static usbd_status	ohci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		ohci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	ohci_allocx(struct usbd_bus *);
Static void		ohci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	ohci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_ctrl_start(usbd_xfer_handle);
Static void		ohci_root_ctrl_abort(usbd_xfer_handle);
Static void		ohci_root_ctrl_close(usbd_pipe_handle);
Static void		ohci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_root_intr_start(usbd_xfer_handle);
Static void		ohci_root_intr_abort(usbd_xfer_handle);
Static void		ohci_root_intr_close(usbd_pipe_handle);
Static void		ohci_root_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_ctrl_start(usbd_xfer_handle);
Static void		ohci_device_ctrl_abort(usbd_xfer_handle);
Static void		ohci_device_ctrl_close(usbd_pipe_handle);
Static void		ohci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	ohci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_bulk_start(usbd_xfer_handle);
Static void		ohci_device_bulk_abort(usbd_xfer_handle);
Static void		ohci_device_bulk_close(usbd_pipe_handle);
Static void		ohci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	ohci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_intr_start(usbd_xfer_handle);
Static void		ohci_device_intr_abort(usbd_xfer_handle);
Static void		ohci_device_intr_close(usbd_pipe_handle);
Static void		ohci_device_intr_done(usbd_xfer_handle);

Static usbd_status	ohci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	ohci_device_isoc_start(usbd_xfer_handle);
Static void		ohci_device_isoc_abort(usbd_xfer_handle);
Static void		ohci_device_isoc_close(usbd_pipe_handle);
Static void		ohci_device_isoc_done(usbd_xfer_handle);

Static usbd_status	ohci_device_setintr(ohci_softc_t *sc, 
			    struct ohci_pipe *pipe, int ival);

Static int		ohci_str(usb_string_descriptor_t *, int, char *);

Static void		ohci_timeout(void *);
Static void		ohci_rhsc_able(ohci_softc_t *, int);

Static void		ohci_close_pipe(usbd_pipe_handle, ohci_soft_ed_t *);
Static void		ohci_abort_xfer(usbd_xfer_handle, usbd_status);
Static void		ohci_abort_xfer_end(void *);

Static void		ohci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		ohci_noop(usbd_pipe_handle pipe);
d198 3
a200 20
#ifdef OHCI_DEBUG
Static void		ohci_dumpregs(ohci_softc_t *);
Static void		ohci_dump_tds(ohci_soft_td_t *);
Static void		ohci_dump_td(ohci_soft_td_t *);
Static void		ohci_dump_ed(ohci_soft_ed_t *);
Static void		ohci_dump_itd(ohci_soft_itd_t *);
Static void		ohci_dump_itds(ohci_soft_itd_t *);
#endif

#define OBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
#define OWRITE1(sc, r, x) \
 do { OBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE2(sc, r, x) \
 do { OBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OWRITE4(sc, r, x) \
 do { OBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define OREAD1(sc, r) (OBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
#define OREAD2(sc, r) (OBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
#define OREAD4(sc, r) (OBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
d203 1
a203 1
Static u_int8_t revbits[OHCI_NO_INTRS] = 
d212 1
a212 4
	union {
		ohci_soft_td_t *td;
		ohci_soft_itd_t *itd;
	} tail;
d233 1
a233 1
			int next, inuse;
d240 1
a240 1
Static struct usbd_bus_methods ohci_bus_methods = {
a241 1
	ohci_softintr,
a244 2
	ohci_allocx,
	ohci_freex,
d247 1
a247 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {	
d253 1
a253 1
	ohci_root_ctrl_done,
d256 1
a256 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {	
d265 1
a265 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {	
d274 1
a274 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {	
d283 1
a283 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {	
d292 2
a293 1
Static struct usbd_pipe_methods ohci_device_isoc_methods = {
d301 1
a302 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d304 3
a306 1
ohci_activate(device_ptr_t self, enum devact act)
a318 1
		sc->sc_dying = 1;
d325 3
a327 1
ohci_detach(struct ohci_softc *sc, int flags)
a336 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a337 3
	shutdownhook_disestablish(sc->sc_shutdownhook);
#endif

a341 1
#endif
d344 2
a345 1
ohci_alloc_sed(ohci_softc_t *sc)
d348 1
a348 1
	usbd_status err;
d352 1
a352 1
	if (sc->sc_freeeds == NULL) {
d354 3
a356 3
		err = usb_allocmem(&sc->sc_bus, OHCI_SED_SIZE * OHCI_SED_CHUNK,
			  OHCI_ED_ALIGN, &dma);
		if (err)
d374 3
a376 1
ohci_free_sed(ohci_softc_t *sc, ohci_soft_ed_t *sed)
d383 2
a384 1
ohci_alloc_std(ohci_softc_t *sc)
d387 1
a387 1
	usbd_status err;
a389 1
	int s;
d391 1
a391 1
	if (sc->sc_freetds == NULL) {
d393 4
a396 5
		err = usb_allocmem(&sc->sc_bus, OHCI_STD_SIZE * OHCI_STD_CHUNK,
			  OHCI_TD_ALIGN, &dma);
		if (err)
			return (NULL);
		s = splusb();
a403 1
		splx(s);
a404 2

	s = splusb();
d408 1
a408 5
	std->nexttd = NULL;
	std->xfer = NULL;
	ohci_hash_add_td(sc, std);
	splx(s);

d413 3
a415 1
ohci_free_std(ohci_softc_t *sc, ohci_soft_td_t *std)
a416 4
	int s;

	s = splusb();
	ohci_hash_rem_td(sc, std);
a418 1
	splx(s);
d422 6
a427 3
ohci_alloc_std_chain(struct ohci_pipe *opipe, ohci_softc_t *sc,
		     int alen, int rd, usbd_xfer_handle xfer,
		     ohci_soft_td_t *sp, ohci_soft_td_t **ep)
d431 2
a432 4
	u_int32_t tdflags;
	int len, curlen;
	usb_dma_t *dma = &xfer->dmabuf;
	u_int16_t flags = xfer->flags;
d434 1
a434 3
	DPRINTFN(alen < 4096,("ohci_alloc_std_chain: start len=%d\n", alen));

	len = alen;
a437 5
	tdflags = htole32(
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) | 
	    (flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0) |
	    OHCI_TD_NOCC | OHCI_TD_TOGGLE_CARRY | OHCI_TD_NOINTR);

d440 4
a443 2
		if (next == NULL)
			goto nomem;
a453 6
			/* the length must be a multiple of the max size */
			curlen -= curlen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize);
#ifdef DIAGNOSTIC
			if (curlen == 0)
				panic("ohci_alloc_std: curlen == 0\n");
#endif
d461 6
a466 2
		cur->td.td_flags = tdflags;
		cur->td.td_cbp = htole32(dataphys);
d468 2
a469 2
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = htole32(dataphys + curlen - 1);
a471 1
		cur->xfer = xfer;
d480 2
a481 20
	if ((flags & USBD_FORCE_SHORT_XFER) &&
	    alen % UGETW(opipe->pipe.endpoint->edesc->wMaxPacketSize) == 0) {
		/* Force a 0 length transfer at the end. */

		cur = next;
		next = ohci_alloc_std(sc);
		if (next == NULL)
			goto nomem;

		cur->td.td_flags = tdflags;
		cur->td.td_cbp = 0; /* indicate 0 length packet */
		cur->nexttd = next;
		cur->td.td_nexttd = htole32(next->physaddr);
		cur->td.td_be = ~0;
		cur->len = 0;
		cur->flags = 0;
		cur->xfer = xfer;
		DPRINTFN(2,("ohci_alloc_std_chain: add 0 xfer\n"));
	}
	*ep = cur;
a483 4

 nomem:
	/* XXX free chain */
	return (USBD_NOMEM);
d486 5
a490 4
#if 0
Static void
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std, 
		    ohci_soft_td_t *stdend)
a498 61
#endif

ohci_soft_itd_t *
ohci_alloc_sitd(ohci_softc_t *sc)
{
	ohci_soft_itd_t *sitd;
	usbd_status err;
	int i, s, offs;
	usb_dma_t dma;

	if (sc->sc_freeitds == NULL) {
		DPRINTFN(2, ("ohci_alloc_sitd: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, OHCI_SITD_SIZE * OHCI_SITD_CHUNK,
			  OHCI_ITD_ALIGN, &dma);
		if (err)
			return (NULL);
		for(i = 0; i < OHCI_SITD_CHUNK; i++) {
			offs = i * OHCI_SITD_SIZE;
			sitd = (ohci_soft_itd_t *)((char*)KERNADDR(&dma)+offs);
			sitd->physaddr = DMAADDR(&dma) + offs;
			sitd->nextitd = sc->sc_freeitds;
			sc->sc_freeitds = sitd;
		}
	}

	s = splusb();
	sitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd->nextitd;
	memset(&sitd->itd, 0, sizeof(ohci_itd_t));
	sitd->nextitd = NULL;
	sitd->xfer = NULL;
	ohci_hash_add_itd(sc, sitd);
	splx(s);

#ifdef DIAGNOSTIC
	sitd->isdone = 0;
#endif

	return (sitd);
}

void
ohci_free_sitd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
{
	int s;

	DPRINTFN(10,("ohci_free_sitd: sitd=%p\n", sitd));

#ifdef DIAGNOSTIC
	if (!sitd->isdone) {
		panic("ohci_free_sitd: sitd=%p not done\n", sitd);
		return;
	}
#endif

	s = splusb();
	ohci_hash_rem_itd(sc, sitd);
	sitd->nextitd = sc->sc_freeitds;
	sc->sc_freeitds = sitd;
	splx(s);
}
d501 2
a502 1
ohci_init(ohci_softc_t *sc)
d505 2
a506 1
	usbd_status err;
d508 1
a508 1
	u_int32_t s, ctl, ival, hcr, fm, per, rev, desca;
d511 1
d513 1
a513 1
	printf(",");
d515 1
a515 1
	printf("%s:", USBDEVNAME(sc->sc_bus.bdev));
d517 1
a517 2
	rev = OREAD4(sc, OHCI_REVISION);
	printf(" OHCI version %d.%d%s", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
a518 4
#if !defined(__OpenBSD__)
	printf("\n");
#endif

d520 3
d525 1
a525 1
		sc->sc_bus.usbrev = USBREV_UNKNOWN;
d527 4
a531 1
	sc->sc_bus.usbrev = USBREV_1_0;
a534 4
	for (i = 0; i < OHCI_HASH_SIZE; i++)
		LIST_INIT(&sc->sc_hash_itds[i]);

	SIMPLEQ_INIT(&sc->sc_free_xfers);
a535 1
	/* XXX determine alignment by R/W */
d537 1
a537 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE, 
d539 2
a540 2
	if (err)
		return (err);
a545 1
	/* Allocate dummy ED that starts the control list. */
d547 2
a548 2
	if (sc->sc_ctrl_head == NULL) {
		err = USBD_NOMEM;
d551 1
a551 1
	sc->sc_ctrl_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);
a552 1
	/* Allocate dummy ED that starts the bulk list. */
d554 2
a555 2
	if (sc->sc_bulk_head == NULL) {
		err = USBD_NOMEM;
d558 1
a558 9
	sc->sc_bulk_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);

	/* Allocate dummy ED that starts the isochronous list. */
	sc->sc_isoc_head = ohci_alloc_sed(sc);
	if (sc->sc_isoc_head == NULL) {
		err = USBD_NOMEM;
		goto bad3;
	}
	sc->sc_isoc_head->ed.ed_flags |= htole32(OHCI_ED_SKIP);
d563 1
a563 1
		if (sed == NULL) {
d566 2
a567 2
			err = USBD_NOMEM;
			goto bad4;
d571 2
a572 2
		sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
		if (i != 0)
d574 3
a576 4
		else
			psed= sc->sc_isoc_head;
		sed->next = psed;
		sed->ed.ed_nexted = htole32(psed->physaddr);
d584 1
a584 12
		    htole32(sc->sc_eds[OHCI_NO_EDS-OHCI_NO_INTRS+i]->physaddr);

#ifdef OHCI_DEBUG
	if (ohcidebug > 15) {
		for (i = 0; i < OHCI_NO_EDS; i++) {
			printf("ed#%d ", i);
			ohci_dump_ed(sc->sc_eds[i]);
		}
		printf("iso ");
		ohci_dump_ed(sc->sc_isoc_head);
	}
#endif
d594 1
a594 1
			usb_delay_ms(&sc->sc_bus, 1);
d608 1
a608 1
			usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
d614 1
a614 1
		usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);
d623 1
a623 1
	usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY);
d638 2
a639 2
		err = USBD_IOERROR;
		goto bad5;
d642 1
d647 1
a647 1
	/* The controller is now in SUSPEND state, we have 2ms to finish. */
a652 1
	/* disable all interrupts and then switch on all desired interrupts */
a654 1
	/* switch on desired functional features */
d673 1
a673 6
	/* Fiddle the No OverCurrent Protection bit to avoid chip bug. */
	desca = OREAD4(sc, OHCI_RH_DESCRIPTOR_A);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca | OHCI_NOCP);
	OWRITE4(sc, OHCI_RH_STATUS, OHCI_LPSC); /* Enable port power */
	usb_delay_ms(&sc->sc_bus, OHCI_ENABLE_POWER_DELAY);
	OWRITE4(sc, OHCI_RH_DESCRIPTOR_A, desca);
a674 5
	/*
	 * The AMD756 requires a delay before re-reading the register,
	 * otherwise it will occasionally report 0 ports.
	 */
	usb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);
a685 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a686 2
	sc->sc_shutdownhook = shutdownhook_establish(ohci_shutdown, sc);
#endif
a689 5
 bad5:
	for (i = 0; i < OHCI_NO_EDS; i++)
		ohci_free_sed(sc, sc->sc_eds[i]);
 bad4:
	ohci_free_sed(sc, sc->sc_isoc_head);
d696 1
a696 1
	return (err);
d700 4
a703 1
ohci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
d713 3
a715 1
ohci_freem(struct usbd_bus *bus, usb_dma_t *dma)
d724 1
a724 16
usbd_xfer_handle
ohci_allocx(struct usbd_bus *bus)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL)
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
	else
		xfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		memset(xfer, 0, sizeof *xfer);
	return (xfer);
}

d726 3
a728 28
ohci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct ohci_softc *sc = (struct ohci_softc *)bus;

	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

/*
 * Shut down the controller when the system is going down.
 */
void
ohci_shutdown(void *v)
{
	ohci_softc_t *sc = v;

	DPRINTF(("ohci_shutdown: stopping the HC\n"));
	OWRITE4(sc, OHCI_CONTROL, OHCI_HCFS_RESET);
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an intterupt context.  This is all right since we
 * are almost suspended anyway.
 */
void
ohci_power(int why, void *v)
d730 1
a731 2
	u_int32_t ctl;
	int s;
a732 1
#ifdef OHCI_DEBUG
d734 1
a736 31

	s = splusb();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		sc->sc_bus.use_polling++;
		ctl = OREAD4(sc, OHCI_CONTROL);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_SUSPEND;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_bus.use_polling--;
		break;
	case PWR_RESUME:
		sc->sc_bus.use_polling++;
		ctl = OREAD4(sc, OHCI_CONTROL);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_RESUME;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		ctl = (ctl & ~OHCI_HCFS_MASK) | OHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, OHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_bus.use_polling--;
		break;
#if defined(__NetBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
	}
	splx(s);
d738 1
d741 3
d745 2
a746 1
ohci_dumpregs(ohci_softc_t *sc)
d780 2
a781 2
		 le32toh(sc->sc_hcca->hcca_frame_number),
		 le32toh(sc->sc_hcca->hcca_done_head)));
a784 2
Static int ohci_intr1(ohci_softc_t *);

d786 2
a787 1
ohci_intr(void *p)
a789 15

	/* If we get an interrupt while polling, then just ignore it. */
	if (sc->sc_bus.use_polling) {
#ifdef DIAGNOSTIC
		printf("ohci_intr: ignored interrupt while polling\n");
#endif
		return (0);
	}

	return (ohci_intr1(sc)); 
}

Static int
ohci_intr1(ohci_softc_t *sc)
{
d802 1
a802 1
	done = le32toh(sc->sc_hcca->hcca_done_head);
d804 1
a810 1

a812 1

d821 1
a821 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n", 
d831 1
a831 3
		ohci_add_done(sc, done &~ OHCI_DONE_INTRS);
		sc->sc_hcca->hcca_done_head = 0;
		usb_schedsoftintr(&sc->sc_bus);
d845 1
a845 1
		ohci_rhsc(sc, sc->sc_intrxfer);
d865 3
a867 1
ohci_rhsc_able(ohci_softc_t *sc, int on)
a892 3
	"reserved",
	"reserved",
	"NOT_ACCESSED",
d898 3
a900 1
ohci_add_done(ohci_softc_t *sc, ohci_physaddr_t done)
d902 5
a906 2
	ohci_soft_itd_t *sitd, *sidone, **ip;
	ohci_soft_td_t  *std,  *sdone,  **p;
d909 1
a909 1
	for (sdone = NULL, sidone = NULL; done != 0; ) {
d911 3
a913 47
		if (std != NULL) {
			std->dnext = sdone;
			done = le32toh(std->td.td_nexttd);
			sdone = std;
			DPRINTFN(10,("add TD %p\n", std));
			continue;
		}
		sitd = ohci_hash_find_itd(sc, done);
		if (sitd != NULL) {
			sitd->dnext = sidone;
			done = le32toh(sitd->itd.itd_nextitd);
			sidone = sitd;
			DPRINTFN(5,("add ITD %p\n", sitd));
			continue;
		}
		panic("ohci_add_done: addr 0x%08lx not found\n", (u_long)done);
	}

	/* sdone & sidone now hold the done lists. */
	/* Put them on the already processed lists. */
	for (p = &sc->sc_sdone; *p != NULL; p = &(*p)->dnext)
		;
	*p = sdone;
	for (ip = &sc->sc_sidone; *ip != NULL; ip = &(*ip)->dnext)
		;
	*ip = sidone;
}

void
ohci_softintr(struct usbd_bus *bus)
{
	ohci_softc_t *sc = (ohci_softc_t *)bus;
	ohci_soft_itd_t *sitd, *sidone, *sitdnext;
	ohci_soft_td_t  *std,  *sdone,  *stdnext;
	usbd_xfer_handle xfer;
	int len, cc, s;

	sc->sc_bus.intr_context++;

	s = splhardusb();
	sdone = sc->sc_sdone;
	sc->sc_sdone = NULL;
	sidone = sc->sc_sidone;
	sc->sc_sidone = NULL;
	splx(s);

	DPRINTFN(10,("ohci_process_done: sdone=%p sidone=%p\n", sdone, sidone));
d923 1
a923 1
		xfer = std->xfer;
d925 6
a930 11
		DPRINTFN(10, ("ohci_process_done: std=%p xfer=%p hcpriv=%p\n",
				std, xfer, xfer ? xfer->hcpriv : 0));
		if (xfer == NULL) {
			/* xfer == NULL: There seems to be no xfer associated
			 * with this TD. It is tailp that happened to end up on
			 * the done queue.
			 */
			continue;
		}
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
d932 1
a932 1
				 xfer));
d934 1
a934 5
			continue;
		}
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
		cc = OHCI_TD_GET_CC(le32toh(std->td.td_flags));
		if (cc == OHCI_CC_NO_ERROR) {
d937 2
a938 4
				len -= le32toh(std->td.td_be) -
				       le32toh(std->td.td_cbp) + 1;
			DPRINTFN(10, ("ohci_process_done: len=%d, flags=0x%x\n",
				      len, std->flags));
d940 1
a940 1
				xfer->actlen += len;
d942 2
a943 2
				xfer->status = USBD_NORMAL_COMPLETION;
				usb_transfer_complete(xfer);
d945 1
d955 1
a955 1
				(struct ohci_pipe *)xfer->pipe;
d957 3
a959 3
			DPRINTFN(15,("ohci_process_done: error cc=%d (%s)\n",
			  OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
			  ohci_cc_strs[OHCI_TD_GET_CC(le32toh(std->td.td_flags))]));
d962 1
a962 1
			for (p = std; p->xfer == xfer; p = n) {
d964 1
d969 1
a969 1
			opipe->sed->ed.ed_headp = htole32(p->physaddr);
d973 1
a973 1
				xfer->status = USBD_STALLED;
d975 2
a976 47
				xfer->status = USBD_IOERROR;
			usb_transfer_complete(xfer);
		}
	}

#ifdef OHCI_DEBUG
	if (ohcidebug > 10) {
		DPRINTF(("ohci_process_done: ITD done:\n"));
		ohci_dump_itds(sidone);
	}
#endif

	for (sitd = sidone; sitd != NULL; sitd = sitdnext) {
		xfer = sitd->xfer;
		sitdnext = sitd->dnext;
		DPRINTFN(1, ("ohci_process_done: sitd=%p xfer=%p hcpriv=%p\n",
			     sitd, xfer, xfer ? xfer->hcpriv : 0));
		if (xfer == NULL)
			continue;
		if (xfer->status == USBD_CANCELLED ||
		    xfer->status == USBD_TIMEOUT) {
			DPRINTF(("ohci_process_done: cancel/timeout %p\n",
				 xfer));
			/* Handled by abort routine. */
			continue;
		}
#ifdef DIAGNOSTIC
		if (sitd->isdone)
			printf("ohci_softintr: sitd=%p is done\n", sitd);
		sitd->isdone = 1;
#endif
		cc = OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags));
		if (cc == OHCI_CC_NO_ERROR) {
			/* XXX compute length for input */
			struct ohci_pipe *opipe = 
				(struct ohci_pipe *)xfer->pipe;
			if (sitd->flags & OHCI_CALL_DONE) {
				opipe->u.iso.inuse -= xfer->nframes;
				/* XXX update frlengths with actual length */
				/* XXX xfer->actlen = actlen; */
				xfer->status = USBD_NORMAL_COMPLETION;
				usb_transfer_complete(xfer);
			}
		} else {
			/* XXX Do more */
			xfer->status = USBD_IOERROR;
			usb_transfer_complete(xfer);
a978 2

	sc->sc_bus.intr_context--;
d982 2
a983 1
ohci_device_ctrl_done(usbd_xfer_handle xfer)
d985 1
a985 1
	DPRINTFN(10,("ohci_ctrl_done: xfer=%p\n", xfer));
d988 1
a988 1
	if (!(xfer->rqflags & URQ_REQUEST)) {
d992 1
a992 1
	xfer->hcpriv = NULL;
d996 2
a997 1
ohci_device_intr_done(usbd_xfer_handle xfer)
d999 1
a999 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
d1005 2
a1006 2
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n", 
		     xfer, xfer->actlen));
d1008 1
a1008 1
	xfer->hcpriv = NULL;
d1010 2
a1011 2
	if (xfer->pipe->repeat) {
		data = opipe->tail.td;
d1013 2
a1014 2
		if (tail == NULL) {
			xfer->status = USBD_NOMEM;
d1017 1
a1017 1
		tail->xfer = NULL;
d1019 1
a1019 1
		data->td.td_flags = htole32(
d1022 3
a1024 3
		if (xfer->flags & USBD_SHORT_XFER_OK)
			data->td.td_flags |= htole32(OHCI_TD_R);
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d1026 4
a1029 5
		data->td.td_nexttd = htole32(tail->physaddr);
		data->td.td_be = htole32(le32toh(data->td.td_cbp) +
			xfer->length - 1);
		data->len = xfer->length;
		data->xfer = xfer;
d1031 2
a1032 2
		xfer->hcpriv = data;
		xfer->actlen = 0;
d1034 3
a1036 2
		sed->ed.ed_tailp = htole32(tail->physaddr);
		opipe->tail.td = tail;
d1041 2
a1042 1
ohci_device_bulk_done(usbd_xfer_handle xfer)
d1044 2
a1045 2
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n", 
		     xfer, xfer->actlen));
d1047 1
a1047 1
	xfer->hcpriv = NULL;
d1051 3
a1053 1
ohci_rhsc(ohci_softc_t *sc, usbd_xfer_handle xfer)
d1062 2
a1063 2
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n", 
		 sc, xfer, hstatus));
d1065 1
a1065 1
	if (xfer == NULL) {
d1070 1
a1070 1
	pipe = xfer->pipe;
d1073 3
a1075 3
	p = KERNADDR(&xfer->dmabuf);
	m = min(sc->sc_noport, xfer->length * 8 - 1);
	memset(p, 0, xfer->length);
a1076 1
		/* Pick out CHANGE bits from the status reg. */
d1081 2
a1082 2
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;
d1084 1
a1084 1
	usb_transfer_complete(xfer);
d1088 2
a1089 1
ohci_root_intr_done(usbd_xfer_handle xfer)
d1091 1
a1091 7
	xfer->hcpriv = NULL;
}

void
ohci_root_ctrl_done(usbd_xfer_handle xfer)
{
	xfer->hcpriv = NULL;
d1100 3
a1102 1
ohci_waitintr(ohci_softc_t *sc, usbd_xfer_handle xfer)
d1104 1
a1104 1
	int timo = xfer->timeout;
d1108 1
a1108 1
	xfer->status = USBD_IN_PROGRESS;
d1118 2
a1119 2
			ohci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
d1126 2
a1127 2
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
d1132 2
a1133 1
ohci_poll(struct usbd_bus *bus)
d1138 1
a1138 1
		ohci_intr1(sc);
d1142 2
a1143 1
ohci_device_request(usbd_xfer_handle xfer)
d1145 2
a1146 2
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
d1150 1
a1150 1
	ohci_soft_td_t *setup, *stat, *next, *tail;
d1154 1
a1154 1
	usbd_status err;
d1166 1
a1166 1
	setup = opipe->tail.td;
d1168 2
a1169 2
	if (stat == NULL) {
		err = USBD_NOMEM;
d1173 2
a1174 2
	if (tail == NULL) {
		err = USBD_NOMEM;
d1177 1
a1177 1
	tail->xfer = NULL;
d1184 2
a1185 3
	/* XXXX Should not touch ED here! */
	sed->ed.ed_flags = htole32(
	 (le32toh(sed->ed.ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
a1188 2
	next = stat;

d1191 16
a1206 1
		ohci_soft_td_t *std = stat;
d1208 6
a1213 8
		err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
			  std, &stat);
		stat = stat->nexttd; /* point at free TD */
		if (err)
			goto bad3;
		/* Start toggle at 1 and then use the carried toggle. */
		std->td.td_flags &= htole32(~OHCI_TD_TOGGLE_MASK);
		std->td.td_flags |= htole32(OHCI_TD_TOGGLE_1);
d1218 3
a1220 3
	setup->td.td_flags = htole32(OHCI_TD_SETUP | OHCI_TD_NOCC |
				     OHCI_TD_TOGGLE_0 | OHCI_TD_NOINTR);
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma));
d1222 4
a1225 4
	setup->td.td_nexttd = htole32(next->physaddr);
	setup->td.td_be = htole32(le32toh(setup->td.td_cbp) + sizeof *req - 1);
	setup->len = 0;
	setup->xfer = xfer;
d1227 1
a1227 1
	xfer->hcpriv = setup;
d1229 3
a1231 3
	stat->td.td_flags = htole32(
		(isread ? OHCI_TD_OUT : OHCI_TD_IN) |
		OHCI_TD_NOCC | OHCI_TD_TOGGLE_1 | OHCI_TD_SET_DI(1));
d1234 1
a1234 1
	stat->td.td_nexttd = htole32(tail->physaddr);
a1235 1
	stat->flags = OHCI_CALL_DONE;
d1237 1
a1237 1
	stat->xfer = xfer;
d1249 6
a1254 2
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
d1256 3
a1258 3
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ohci_timeout, xfer);
d1262 3
a1264 3
#if 0
	if (ohcidebug > 10) {
		delay(10000);
d1279 1
a1279 1
	return (err);
d1286 3
a1288 1
ohci_add_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
d1294 1
a1294 1
	head->ed.ed_nexted = htole32(sed->physaddr);
d1301 3
a1303 1
ohci_rem_ed(ohci_soft_ed_t *sed, ohci_soft_ed_t *head)
d1310 1
a1310 1
	for (p = head; p == NULL && p->next != sed; p = p->next)
d1312 1
a1312 1
	if (p == NULL)
d1331 3
a1333 1
ohci_hash_add_td(ohci_softc_t *sc, ohci_soft_td_t *std)
d1344 3
a1346 1
ohci_hash_rem_td(ohci_softc_t *sc, ohci_soft_td_t *std)
d1354 3
a1356 1
ohci_hash_find_td(ohci_softc_t *sc, ohci_physaddr_t a)
d1362 1
a1362 1
	     std != NULL;
d1366 1
a1366 1
	return (NULL);
a1368 1
/* Called at splusb() */
d1370 2
a1371 1
ohci_hash_add_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
d1373 1
a1373 40
	int h = HASH(sitd->physaddr);

	SPLUSBCHECK;

	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n", 
		    sitd, (u_long)sitd->physaddr));

	LIST_INSERT_HEAD(&sc->sc_hash_itds[h], sitd, hnext);
}

/* Called at splusb() */
void
ohci_hash_rem_itd(ohci_softc_t *sc, ohci_soft_itd_t *sitd)
{
	SPLUSBCHECK;

	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n", 
		    sitd, (u_long)sitd->physaddr));

	LIST_REMOVE(sitd, hnext);
}

ohci_soft_itd_t *
ohci_hash_find_itd(ohci_softc_t *sc, ohci_physaddr_t a)
{
	int h = HASH(a);
	ohci_soft_itd_t *sitd;

	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]); 
	     sitd != NULL;
	     sitd = LIST_NEXT(sitd, hnext))
		if (sitd->physaddr == a)
			return (sitd);
	return (NULL);
}

void
ohci_timeout(void *addr)
{
	usbd_xfer_handle xfer = addr;
d1376 1
a1376 1
	DPRINTF(("ohci_timeout: xfer=%p\n", xfer));
d1379 3
a1381 3
	xfer->device->bus->intr_context++;
	ohci_abort_xfer(xfer, USBD_TIMEOUT);
	xfer->device->bus->intr_context--;
d1387 2
a1388 1
ohci_dump_tds(ohci_soft_td_t *std)
d1395 2
a1396 1
ohci_dump_td(ohci_soft_td_t *std)
d1398 1
a1398 7
	char sbuf[128];

	bitmask_snprintf((int)le32toh(std->td.td_flags),
			 "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
			 sbuf, sizeof(sbuf));

	DPRINTF(("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
d1400 8
a1407 7
		 std, (u_long)std->physaddr, sbuf,
		 OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
		 OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
		 (u_long)le32toh(std->td.td_cbp),
		 (u_long)le32toh(std->td.td_nexttd),
		 (u_long)le32toh(std->td.td_be)));
d1411 2
a1412 22
ohci_dump_itd(ohci_soft_itd_t *sitd)
{
	int i;

	DPRINTF(("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n", 
		 sitd, (u_long)sitd->physaddr,
		 OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
		 OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
		 (u_long)le32toh(sitd->itd.itd_bp0),
		 (u_long)le32toh(sitd->itd.itd_nextitd),
		 (u_long)le32toh(sitd->itd.itd_be)));
	for (i = 0; i < OHCI_ITD_NOFFSET; i++)
		DPRINTF(("offs[%d]=0x%04x ", i,
			 (u_int)le16toh(sitd->itd.itd_offset[i])));
	DPRINTF(("\n"));
}

void
ohci_dump_itds(ohci_soft_itd_t *sitd)
d1414 2
a1415 17
	for (; sitd; sitd = sitd->nextitd)
		ohci_dump_itd(sitd);
}

void
ohci_dump_ed(ohci_soft_ed_t *sed)
{
	char sbuf[128], sbuf2[128];

	bitmask_snprintf((int)le32toh(sed->ed.ed_flags),
			 "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
			 sbuf, sizeof(sbuf));
	bitmask_snprintf((u_long)le32toh(sed->ed.ed_headp),
			 "\20\1HALT\2CARRY", sbuf2, sizeof(sbuf2));

	DPRINTF(("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d %s\ntailp=0x%08lx "
		 "headflags=%s headp=0x%08lx nexted=0x%08lx\n",
d1417 9
a1425 6
		 OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
		 OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
		 (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
		 (u_long)le32toh(sed->ed.ed_headp),
		 (u_long)le32toh(sed->ed.ed_nexted)));
d1430 2
a1431 1
ohci_open(usbd_pipe_handle pipe)
a1437 1
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
d1440 1
a1440 4
	ohci_soft_itd_t *sitd;
	ohci_physaddr_t tdphys;
	u_int32_t fmt;
	usbd_status err;
a1441 1
	int ival;
a1444 4

	std = NULL;
	sed = NULL;

d1458 1
a1458 1
		if (sed == NULL)
d1460 3
d1464 2
a1465 24
		if (xfertype == UE_ISOCHRONOUS) {
			sitd = ohci_alloc_sitd(sc);
			if (sitd == NULL) {
				ohci_free_sitd(sc, sitd);
				goto bad1;
			}
			opipe->tail.itd = sitd;
			tdphys = sitd->physaddr;
			fmt = OHCI_ED_FORMAT_ISO;
			if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
				fmt |= OHCI_ED_DIR_IN;
			else
				fmt |= OHCI_ED_DIR_OUT;
		} else {
			std = ohci_alloc_std(sc);
			if (std == NULL) {
				ohci_free_std(sc, std);
				goto bad1;
			}
			opipe->tail.td = std;
			tdphys = std->physaddr;
			fmt = OHCI_ED_FORMAT_GEN | OHCI_ED_DIR_TD;
		}
		sed->ed.ed_flags = htole32(
d1468 4
a1471 1
			(dev->lowspeed ? OHCI_ED_SPEED : 0) | fmt |
d1473 1
a1473 1
		sed->ed.ed_headp = sed->ed.ed_tailp = htole32(tdphys);
d1475 1
a1475 1
		switch (xfertype) {
d1478 4
a1481 4
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
				  0, &opipe->u.ctl.reqdma);
			if (err)
d1489 1
a1489 4
			ival = pipe->interval;
			if (ival == USBD_DEFAULT_INTERVAL)
				ival = ed->bInterval;
			return (ohci_device_setintr(sc, opipe, ival));
d1491 2
a1492 2
			pipe->methods = &ohci_device_isoc_methods;
			return (ohci_setup_isoc(pipe));
d1504 1
a1504 2
	if (std != NULL)
		ohci_free_std(sc, std);
d1506 1
a1506 2
	if (sed != NULL)
		ohci_free_sed(sc, sed);
d1517 3
a1519 1
ohci_close_pipe(usbd_pipe_handle pipe, ohci_soft_ed_t *head)
d1528 4
a1531 4
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK)) {
		ohci_physaddr_t td = le32toh(sed->ed.ed_headp);
d1534 1
a1534 1
		     std != NULL;
d1540 1
a1540 2
		       (int)le32toh(sed->ed.ed_headp),
		       (int)le32toh(sed->ed.ed_tailp),
d1543 2
a1544 2
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
		    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
d1550 1
d1565 3
a1567 1
ohci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d1569 1
a1569 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
d1572 1
a1572 1
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p\n", xfer, opipe));
d1574 1
a1574 1
	xfer->status = status;
d1576 1
a1576 1
	usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
d1579 2
a1580 2
	DPRINTFN(1,("ohci_abort_xfer: stop ed=%p\n", sed));
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */
d1582 1
a1582 2
#if 1
	if (xfer->device->bus->intr_context) {
d1584 1
a1584 2
		usb_callout(xfer->pipe->abort_handle,
		    hz / USB_FRAMES_PER_SECOND, ohci_abort_xfer_end, xfer);
a1585 4
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
		KASSERT(intr_nesting_level == 0,
	        	("ohci_abort_req in interrupt context"));
#endif
d1587 1
a1587 1
		ohci_abort_xfer_end(xfer);
a1588 4
#else
	delay(1000);
	ohci_abort_xfer_end(xfer);
#endif
d1592 2
a1593 1
ohci_abort_xfer_end(void *v)
d1595 2
a1596 2
	usbd_xfer_handle xfer = v;
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
d1604 1
a1604 1
	p = xfer->hcpriv;
d1606 2
a1607 3
	if (p == NULL) {
		printf("ohci_abort_xfer: hcpriv==0\n");
		splx(s);
d1611 1
a1611 1
	for (; p->xfer == xfer; p = n) {
d1613 1
d1618 4
a1621 4
	DPRINTFN(2,("ohci_abort_xfer: set hd=%x, tl=%x\n",
		    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
	sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */
d1623 1
a1623 1
	usb_transfer_complete(xfer);
d1631 1
a1631 1
Static usb_device_descriptor_t ohci_devd = {
d1635 2
a1636 2
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
d1644 1
a1644 1
Static usb_config_descriptor_t ohci_confd = {
d1657 1
a1657 1
Static usb_interface_descriptor_t ohci_ifcd = {
d1663 2
a1664 2
	UICLASS_HUB,
	UISUBCLASS_HUB,
d1669 1
a1669 1
Static usb_endpoint_descriptor_t ohci_endpd = {
d1678 1
a1678 1
Static usb_hub_descriptor_t ohci_hubd = {
d1688 1
a1688 1
Static int
d1711 3
a1713 2
Static usbd_status
ohci_root_ctrl_transfer(usbd_xfer_handle xfer)
d1715 1
a1715 1
	usbd_status err;
d1718 3
a1720 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d1723 1
a1723 1
	return (ohci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d1726 3
a1728 2
Static usbd_status
ohci_root_ctrl_start(usbd_xfer_handle xfer)
d1730 1
a1730 1
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
d1737 1
a1737 1
	usbd_status err;
a1739 3
	if (sc->sc_dying)
		return (USBD_IOERROR);

d1741 1
a1741 1
	if (!(xfer->rqflags & URQ_REQUEST))
d1745 1
a1745 1
	req = &xfer->request;
d1755 1
a1755 1
		buf = KERNADDR(&xfer->dmabuf);
d1778 1
a1778 1
				err = USBD_IOERROR;
d1787 1
a1787 1
				err = USBD_IOERROR;
d1818 1
a1818 1
			err = USBD_IOERROR;
d1843 1
a1843 1
			err = USBD_IOERROR;
d1850 1
a1850 1
			err = USBD_IOERROR;
d1860 1
a1860 1
		err = USBD_IOERROR;
d1874 1
a1874 1
			err = USBD_IOERROR;
a1885 1
			/* Yes, writing to the LOW_SPEED bit clears power. */
d1904 1
a1904 1
			err = USBD_IOERROR;
d1923 1
a1923 1
			err = USBD_IOERROR;
d1945 1
a1945 1
			err = USBD_IOERROR;
d1955 1
a1955 1
			err = USBD_IOERROR;
d1959 1
a1959 1
			err = USBD_IOERROR;
d1972 1
a1972 1
		err = USBD_IOERROR;
d1978 1
a1978 1
			err = USBD_IOERROR;
d1994 1
a1994 1
				usb_delay_ms(&sc->sc_bus, 10); /* XXX */
d2007 1
a2007 1
			err = USBD_IOERROR;
d2012 1
a2012 1
		err = USBD_IOERROR;
d2015 2
a2016 2
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
d2018 1
a2018 1
	xfer->status = err;
d2020 1
a2020 1
	usb_transfer_complete(xfer);
d2026 3
a2028 2
Static void
ohci_root_ctrl_abort(usbd_xfer_handle xfer)
d2034 3
a2036 2
Static void
ohci_root_ctrl_close(usbd_pipe_handle pipe)
d2042 3
a2044 2
Static usbd_status
ohci_root_intr_transfer(usbd_xfer_handle xfer)
d2046 1
a2046 1
	usbd_status err;
d2049 3
a2051 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2054 1
a2054 1
	return (ohci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2057 3
a2059 2
Static usbd_status
ohci_root_intr_start(usbd_xfer_handle xfer)
d2061 1
a2061 1
	usbd_pipe_handle pipe = xfer->pipe;
d2064 1
a2064 4
	if (sc->sc_dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;
d2070 3
a2072 2
Static void
ohci_root_intr_abort(usbd_xfer_handle xfer)
d2074 1
a2074 3
	int s;

	if (xfer->pipe->intrxfer == xfer) {
d2076 1
a2076 1
		xfer->pipe->intrxfer = NULL;
d2078 2
a2079 4
	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
d2083 3
a2085 2
Static void
ohci_root_intr_close(usbd_pipe_handle pipe)
d2091 1
a2091 1
	sc->sc_intrxfer = NULL;
d2096 3
a2098 2
Static usbd_status
ohci_device_ctrl_transfer(usbd_xfer_handle xfer)
d2100 1
a2100 1
	usbd_status err;
d2103 3
a2105 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2108 1
a2108 1
	return (ohci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2111 3
a2113 2
Static usbd_status
ohci_device_ctrl_start(usbd_xfer_handle xfer)
d2115 2
a2116 5
	ohci_softc_t *sc = (ohci_softc_t *)xfer->pipe->device->bus;
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);
d2119 1
a2119 1
	if (!(xfer->rqflags & URQ_REQUEST)) {
d2126 3
a2128 3
	err = ohci_device_request(xfer);
	if (err)
		return (err);
d2131 1
a2131 1
		ohci_waitintr(sc, xfer);
d2136 3
a2138 2
Static void
ohci_device_ctrl_abort(usbd_xfer_handle xfer)
d2140 2
a2141 2
	DPRINTF(("ohci_device_ctrl_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
d2145 3
a2147 2
Static void
ohci_device_ctrl_close(usbd_pipe_handle pipe)
a2148 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
a2152 1
	ohci_free_std(sc, opipe->tail.td);
d2157 3
a2159 2
Static void
ohci_device_clear_toggle(usbd_pipe_handle pipe)
d2163 1
a2163 1
	opipe->sed->ed.ed_headp &= htole32(~OHCI_TOGGLECARRY);
d2166 3
a2168 2
Static void
ohci_noop(usbd_pipe_handle pipe)
d2172 3
a2174 2
Static usbd_status
ohci_device_bulk_transfer(usbd_xfer_handle xfer)
d2176 1
a2176 1
	usbd_status err;
d2179 3
a2181 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2184 1
a2184 1
	return (ohci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2187 3
a2189 2
Static usbd_status
ohci_device_bulk_start(usbd_xfer_handle xfer)
d2191 1
a2191 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
d2198 1
a2198 4
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);
d2201 1
a2201 1
	if (xfer->rqflags & URQ_REQUEST) {
d2208 2
a2209 2
	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
d2213 2
a2214 2
	DPRINTFN(4,("ohci_device_bulk_start: xfer=%p len=%d isread=%d "
		    "flags=%d endpt=%d\n", xfer, len, isread, xfer->flags,
d2221 2
a2222 2
	sed->ed.ed_flags = htole32(
		(le32toh(sed->ed.ed_flags) & ~OHCI_ED_ADDRMASK) |
d2226 6
a2231 10
	data = opipe->tail.td;
	err = ohci_alloc_std_chain(opipe, sc, len, isread, xfer,
		  data, &tail);
	/* We want interrupt at the end of the transfer. */
	tail->td.td_flags &= htole32(~OHCI_TD_INTR_MASK);
	tail->td.td_flags |= htole32(OHCI_TD_SET_DI(1));
	tail->flags |= OHCI_CALL_DONE;
	tail = tail->nexttd;	/* point at sentinel */
	if (err)
		return (err);
d2233 2
a2234 2
	tail->xfer = NULL;
	xfer->hcpriv = data;
d2238 2
a2239 4
		    (int)le32toh(sed->ed.ed_flags),
		    (int)le32toh(data->td.td_flags),
		    (int)le32toh(data->td.td_cbp),
		    (int)le32toh(data->td.td_be)));
d2242 1
a2242 1
	if (ohcidebug > 5) {
d2251 2
a2252 1
		tdp->xfer = xfer;
d2254 3
a2256 3
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
d2258 3
a2260 3
	if (xfer->timeout && !sc->sc_bus.use_polling) {
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    ohci_timeout, xfer);
d2265 2
a2266 2
	if (ohcidebug > 10) {
		delay(10000);
d2279 3
a2281 2
Static void
ohci_device_bulk_abort(usbd_xfer_handle xfer)
d2283 2
a2284 2
	DPRINTF(("ohci_device_bulk_abort: xfer=%p\n", xfer));
	ohci_abort_xfer(xfer, USBD_CANCELLED);
d2290 3
a2292 2
Static void
ohci_device_bulk_close(usbd_pipe_handle pipe)
a2293 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
a2297 1
	ohci_free_std(sc, opipe->tail.td);
d2302 3
a2304 2
Static usbd_status
ohci_device_intr_transfer(usbd_xfer_handle xfer)
d2306 1
a2306 1
	usbd_status err;
d2309 3
a2311 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2314 1
a2314 1
	return (ohci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2317 3
a2319 2
Static usbd_status
ohci_device_intr_start(usbd_xfer_handle xfer)
d2321 1
a2321 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
d2329 1
a2329 4
	if (sc->sc_dying)
		return (USBD_IOERROR);

	DPRINTFN(3, ("ohci_device_intr_transfer: xfer=%p len=%d "
d2331 1
a2331 1
		     xfer, xfer->length, xfer->flags, xfer->priv));
d2334 1
a2334 1
	if (xfer->rqflags & URQ_REQUEST)
d2338 1
a2338 1
	len = xfer->length;
d2340 1
a2340 1
	data = opipe->tail.td;
d2342 1
a2342 1
	if (tail == NULL)
d2344 1
a2344 1
	tail->xfer = NULL;
d2346 1
a2346 1
	data->td.td_flags = htole32(
d2349 3
a2351 3
	if (xfer->flags & USBD_SHORT_XFER_OK)
		data->td.td_flags |= htole32(OHCI_TD_R);
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf));
d2353 2
a2354 2
	data->td.td_nexttd = htole32(tail->physaddr);
	data->td.td_be = htole32(le32toh(data->td.td_cbp) + len - 1);
d2356 1
a2356 1
	data->xfer = xfer;
d2358 1
a2358 1
	xfer->hcpriv = data;
d2370 4
a2373 3
	sed->ed.ed_tailp = htole32(tail->physaddr);
	opipe->tail.td = tail;
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
d2382 1
a2382 1
		usb_delay_ms(&sc->sc_bus, 5);
d2395 3
a2397 2
Static void
ohci_device_intr_abort(usbd_xfer_handle xfer)
d2399 1
a2399 1
	if (xfer->pipe->intrxfer == xfer) {
d2401 1
a2401 1
		xfer->pipe->intrxfer = NULL;
d2403 1
a2403 1
	ohci_abort_xfer(xfer, USBD_CANCELLED);
d2407 3
a2409 2
Static void
ohci_device_intr_close(usbd_pipe_handle pipe)
d2422 3
a2424 3
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP);
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) != 
	    (le32toh(sed->ed.ed_headp) & OHCI_HEADMASK))
d2429 1
a2429 2
#ifdef DIAGNOSTIC
	if (p == NULL)
a2430 1
#endif
d2438 1
a2438 1
	ohci_free_std(sc, opipe->tail.td);
d2442 5
a2446 2
Static usbd_status
ohci_device_setintr(ohci_softc_t *sc, struct ohci_pipe *opipe, int ival)
d2495 1
a2495 1
	hsed->ed.ed_nexted = htole32(sed->physaddr);
a2506 282
/***********************/

usbd_status
ohci_device_isoc_transfer(usbd_xfer_handle xfer)
{
	usbd_status err;

	DPRINTFN(5,("ohci_device_isoc_transfer: xfer=%p\n", xfer));

	/* Put it on our queue, */
	err = usb_insert_transfer(xfer);

	/* bail out on error, */
	if (err && err != USBD_IN_PROGRESS)
		return (err);

	/* XXX should check inuse here */

	/* insert into schedule, */
	ohci_device_isoc_enter(xfer);

	/* and start if the pipe wasn't running */
	if (!err)
		ohci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));

	return (err);
}

void
ohci_device_isoc_enter(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	struct iso *iso = &opipe->u.iso;
	ohci_soft_itd_t *sitd, *nsitd;	
	ohci_physaddr_t buf, offs, noffs, bp0;
	int i, ncur, nframes;
	int s;

	DPRINTFN(1,("ohci_device_isoc_enter: used=%d next=%d xfer=%p "
		    "nframes=%d\n",
		    iso->inuse, iso->next, xfer, xfer->nframes));

	if (sc->sc_dying)
		return;

	if (iso->next == -1) {
		/* Not in use yet, schedule it a few frames ahead. */
		iso->next = le32toh(sc->sc_hcca->hcca_frame_number) + 5;
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n", 
			    iso->next));
	}

	sitd = opipe->tail.itd;
	buf = DMAADDR(&xfer->dmabuf);
	bp0 = OHCI_PAGE(buf);
	offs = OHCI_PAGE_OFFSET(buf);
	nframes = xfer->nframes;
	xfer->hcpriv = sitd;
	for (i = ncur = 0; i < nframes; i++, ncur++) {
		noffs = offs + xfer->frlengths[i];
		if (ncur == OHCI_ITD_NOFFSET ||	/* all offsets used */
		    OHCI_PAGE(buf + noffs) > bp0 + OHCI_PAGE_SIZE) { /* too many page crossings */
			
			/* Allocate next ITD */
			nsitd = ohci_alloc_sitd(sc);
			if (nsitd == NULL) {
				/* XXX what now? */
				printf("%s: isoc TD alloc failed\n",
				       USBDEVNAME(sc->sc_bus.bdev));
				return;
			}

			/* Fill current ITD */
			sitd->itd.itd_flags = htole32(
				OHCI_ITD_NOCC | 
				OHCI_ITD_SET_SF(iso->next) |
				OHCI_ITD_SET_DI(6) | /* delay intr a little */
				OHCI_ITD_SET_FC(ncur));
			sitd->itd.itd_bp0 = htole32(bp0);
			sitd->nextitd = nsitd;
			sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
			sitd->itd.itd_be = htole32(bp0 + offs - 1);
			sitd->xfer = xfer;
			sitd->flags = 0;

			sitd = nsitd;
			iso->next = iso->next + ncur; 
			bp0 = OHCI_PAGE(buf + offs);
			ncur = 0;
		}
		sitd->itd.itd_offset[ncur] = htole16(OHCI_ITD_MK_OFFS(offs));
		offs = noffs;
	}
	nsitd = ohci_alloc_sitd(sc);
	if (nsitd == NULL) {
		/* XXX what now? */
		printf("%s: isoc TD alloc failed\n", 
		       USBDEVNAME(sc->sc_bus.bdev));
		return;
	}
	/* Fixup last used ITD */
	sitd->itd.itd_flags = htole32(
		OHCI_ITD_NOCC | 
		OHCI_ITD_SET_SF(iso->next) |
		OHCI_ITD_SET_DI(0) |
		OHCI_ITD_SET_FC(ncur));
	sitd->itd.itd_bp0 = htole32(bp0);
	sitd->nextitd = nsitd;
	sitd->itd.itd_nextitd = htole32(nsitd->physaddr);
	sitd->itd.itd_be = htole32(bp0 + offs - 1);
	sitd->xfer = xfer;
	sitd->flags = OHCI_CALL_DONE;

	iso->next = iso->next + ncur;
	iso->inuse += nframes;

	xfer->actlen = offs;	/* XXX pretend we did it all */

	xfer->status = USBD_IN_PROGRESS;

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		DPRINTF(("ohci_device_isoc_enter: frame=%d\n",
			 le32toh(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif

	s = splusb();
	opipe->tail.itd = nsitd;
	sed->ed.ed_tailp = htole32(nsitd->physaddr);
	splx(s);

#ifdef OHCI_DEBUG
	if (ohcidebug > 5) {
		delay(150000);
		DPRINTF(("ohci_device_isoc_enter: after frame=%d\n",
			 le32toh(sc->sc_hcca->hcca_frame_number)));
		ohci_dump_itds(xfer->hcpriv);
		ohci_dump_ed(sed);
	}
#endif
}

usbd_status
ohci_device_isoc_start(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

	DPRINTFN(5,("ohci_device_isoc_start: xfer=%p\n", xfer));

	if (sc->sc_dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->status != USBD_IN_PROGRESS)
		printf("uhci_device_isoc_start: not in progress %p\n", xfer);
#endif

	/* XXX anything to do? */

	return (USBD_IN_PROGRESS);
}

void
ohci_device_isoc_abort(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed;
	ohci_soft_itd_t *sitd;
	int s;

	s = splusb();

	DPRINTFN(1,("ohci_device_isoc_abort: xfer=%p\n", xfer));

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED && 
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
		printf("ohci_device_isoc_abort: early return\n");
		return;
	}

	/* Give xfer the requested abort code. */
	xfer->status = USBD_CANCELLED;

	sed = opipe->sed;
	sed->ed.ed_flags |= htole32(OHCI_ED_SKIP); /* force hardware skip */

	sitd = xfer->hcpriv;
#ifdef DIAGNOSTIC
	if (sitd == NULL) {
		splx(s);
		printf("ohci_device_isoc_abort: hcpriv==0\n");
		return;
	}
#endif
	for (; sitd->xfer == xfer; sitd = sitd->nextitd) {
#ifdef DIAGNOSTIC
		DPRINTFN(1,("abort sets done sitd=%p\n", sitd));
		sitd->isdone = 1;
#endif
	}

	splx(s);

	usb_delay_ms(&sc->sc_bus, OHCI_ITD_NOFFSET);

	s = splusb();

	/* Run callback. */
	usb_transfer_complete(xfer);

	sed->ed.ed_headp = htole32(sitd->physaddr); /* unlink TDs */
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP); /* remove hardware skip */

	splx(s);
}

void
ohci_device_isoc_done(usbd_xfer_handle xfer)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)xfer->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_itd_t *sitd, *nsitd;	

	DPRINTFN(1,("ohci_device_isoc_done: xfer=%p\n", xfer));

	for (sitd = xfer->hcpriv;
	     !(sitd->flags & OHCI_CALL_DONE);
	     sitd = nsitd) {
		nsitd = sitd->nextitd;
		DPRINTFN(1,("ohci_device_isoc_done: free sitd=%p\n", sitd));
		ohci_free_sitd(sc, sitd);
	}
	ohci_free_sitd(sc, sitd);
	xfer->hcpriv = NULL;
}

usbd_status
ohci_setup_isoc(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	struct iso *iso = &opipe->u.iso;
	int s;

	iso->next = -1;
	iso->inuse = 0;

	s = splusb();
	ohci_add_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);

	return (USBD_NORMAL_COMPLETION);
}

void
ohci_device_isoc_close(usbd_pipe_handle pipe)
{
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	ohci_softc_t *sc = (ohci_softc_t *)pipe->device->bus;
	int s;

	DPRINTF(("ohci_device_isoc_close: pipe=%p\n", pipe));

	s = splusb();
	ohci_rem_ed(opipe->sed, sc->sc_isoc_head);
	splx(s);
	ohci_close_pipe(pipe, sc->sc_isoc_head);
#ifdef DIAGNOSTIC
	opipe->tail.itd->isdone = 1;
#endif
	ohci_free_sitd(sc, opipe->tail.itd);
}
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ohci.c,v 1.102 2001/04/01 15:00:29 augustss Exp $	*/
d656 1
d658 1
a859 1
	sc->sc_control = sc->sc_intre = 0;
d955 1
a955 1
	s = splhardusb();
d960 2
a961 10
		ctl = OREAD4(sc, OHCI_CONTROL) & ~OHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = ctl;
			sc->sc_intre = OREAD4(sc, OHCI_INTERRUPT_ENABLE);
		}
		ctl |= OHCI_HCFS_SUSPEND;
d968 2
a969 12
		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma));
		OWRITE4(sc, OHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, OHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, OHCI_INTERRUPT_ENABLE,
				sc->sc_intre & (OHCI_ALL_INTRS | OHCI_MIE));
		if (sc->sc_control)
			ctl = sc->sc_control;
		else
			ctl = OREAD4(sc, OHCI_CONTROL);
		ctl |= OHCI_HCFS_RESUME;
a974 1
		sc->sc_control = sc->sc_intre = 0;
d1086 1
a1086 6
		sc->sc_overrun_cnt++;
		if (usbd_ratecheck(&sc->sc_overrun_ntc)) {
			printf("%s: %u scheduling overruns\n",
			    USBDEVNAME(sc->sc_bus.bdev), sc->sc_overrun_cnt);
			sc->sc_overrun_cnt = 0;
		}
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.7.2.2 2001/07/04 10:43:46 niklas Exp $ */
a1137 4
#if defined (__OpenBSD__)
		/* Do not allow RHSC interrupts > 1 per second */
		timeout_add(&sc->sc_tmo_rhsc, hz);
#endif
a1146 7
}

void
ohci_rhsc_enable(void *v_sc)
{
	ohci_softc_t *sc = v_sc;
	ohci_rhsc_able(sc, 1);
@


1.7.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ohci.c,v 1.104 2001/09/28 23:57:21 augustss Exp $	*/
d141 1
a141 1
Static void		ohci_softintr(void *);
d654 1
a654 1
	printf(" OHCI version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
d656 1
a762 2
#if 0
/* Don't bother trying to reuse the BIOS init, we'll reset it anyway. */
a769 1
#endif
d1154 7
a1172 8
void
ohci_rhsc_enable(void *v_sc)
{
	ohci_softc_t *sc = v_sc;

	ohci_rhsc_able(sc, 1);
}

d1232 1
a1232 1
ohci_softintr(void *v)
d1234 1
a1234 1
	ohci_softc_t *sc = v;
d2081 1
a2082 1
		printf("ohci_abort_xfer: hcpriv==0\n");
@


1.7.2.5
log
@Merge in -current from roughly a week ago
@
text
@d595 1
a595 1
			sitd = (ohci_soft_itd_t *)((char *)KERNADDR(&dma)+offs);
@


1.7.2.6
log
@Sync the SMP branch with 3.3
@
text
@d201 1
a201 1
Static usbd_status	ohci_device_setintr(ohci_softc_t *sc,
a207 1
Static void		ohci_rhsc_enable(void *sc);
d238 1
a238 1
Static u_int8_t revbits[OHCI_NO_INTRS] =
d288 1
a288 1
Static struct usbd_pipe_methods ohci_root_ctrl_methods = {
d297 1
a297 1
Static struct usbd_pipe_methods ohci_root_intr_methods = {
d306 1
a306 1
Static struct usbd_pipe_methods ohci_device_ctrl_methods = {
d315 1
a315 1
Static struct usbd_pipe_methods ohci_device_intr_methods = {
d324 1
a324 1
Static struct usbd_pipe_methods ohci_device_bulk_methods = {
d370 1
a370 1

d490 1
a490 1
	    (rd ? OHCI_TD_IN : OHCI_TD_OUT) |
d506 1
a506 1
			curlen = 2 * OHCI_PAGE_SIZE -
d512 1
a512 1
				panic("ohci_alloc_std: curlen == 0");
d567 1
a567 1
ohci_free_std_chain(ohci_softc_t *sc, ohci_soft_td_t *std,
d627 1
a627 1
		panic("ohci_free_sitd: sitd=%p not done", sitd);
a638 9
void
ohci_reset(ohci_softc_t *sc)
{
	ohci_shutdown(sc);
	/* disable all interrupts and then switch on all desired
           interrupts */
	OWRITE4(sc, OHCI_INTERRUPT_DISABLE, OHCI_ALL_INTRS);
}

d658 1
a658 1
		printf("%s: unsupported OHCI revision\n",
d674 1
a674 1
	err = usb_allocmem(&sc->sc_bus, OHCI_HCCA_SIZE,
d726 1
a726 1
	/*
d731 1
a731 1
		sc->sc_hcca->hcca_interrupt_table[revbits[i]] =
d854 1
a854 1

a863 1
	usb_callout_init(sc->sc_tmo_rhsc);
d1063 1
a1063 1
	return (ohci_intr1(sc));
d1101 1
a1101 1
	DPRINTFN(7, ("ohci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1135 1
a1135 1
		/*
d1140 1
d1142 2
a1143 1
		usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
d1221 1
a1221 1
		panic("ohci_add_done: addr 0x%08lx not found", (u_long)done);
d1303 1
a1303 1
			struct ohci_pipe *opipe =
d1357 1
a1357 1
			struct ohci_pipe *opipe =
d1383 1
a1383 1
		panic("ohci_ctrl_done: not a request");
d1398 1
a1398 1
	DPRINTFN(10,("ohci_intr_done: xfer=%p, actlen=%d\n",
d1411 1
a1411 1

d1413 1
a1413 1
			OHCI_TD_IN | OHCI_TD_NOCC |
d1436 1
a1436 1
	DPRINTFN(10,("ohci_bulk_done: xfer=%p, actlen=%d\n",
d1452 1
a1452 1
	DPRINTF(("ohci_rhsc: sc=%p xfer=%p hstatus=0x%08x\n",
d1555 1
a1555 1
		    UGETW(req->wIndex), len, addr,
d1680 1
a1680 1
	ohci_soft_ed_t *p;
d1688 1
a1688 1
		panic("ohci_rem_ed: ED not found");
d1730 1
a1730 1
	for (std = LIST_FIRST(&sc->sc_hash_tds[h]);
d1746 1
a1746 1
	DPRINTFN(10,("ohci_hash_add_itd: sitd=%p physaddr=0x%08lx\n",
d1758 1
a1758 1
	DPRINTFN(10,("ohci_hash_rem_itd: sitd=%p physaddr=0x%08lx\n",
d1770 1
a1770 1
	for (sitd = LIST_FIRST(&sc->sc_hash_itds[h]);
d1811 1
a1811 1
		 "nexttd=0x%08lx be=0x%08lx\n",
d1827 1
a1827 1
		 "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
d1862 1
a1862 1
		 sed, (u_long)sed->physaddr,
d1914 2
a1915 1
			if (sitd == NULL)
d1917 1
d1936 1
a1936 1
			OHCI_ED_SET_FA(addr) |
d1945 2
a1946 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d1981 1
a1981 1

d1999 1
a1999 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2003 1
a2003 1
		for (std = LIST_FIRST(&sc->sc_hash_tds[HASH(td)]);
d2014 1
a2014 1
		if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2024 1
a2024 1
/*
d2225 1
a2225 1
	DPRINTFN(4,("ohci_root_ctrl_control type=0x%02x request=%02x\n",
d2240 1
a2240 1
		/*
d2409 1
a2409 1
		      (v & OHCI_NPS ? UHD_PWR_NO_SWITCH :
d2415 1
a2415 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
d2568 1
a2568 1

d2771 1
a2771 1
/*
d2821 1
a2821 1
		panic("ohci_device_intr_transfer: a request");
d2833 1
a2833 1
		OHCI_TD_IN | OHCI_TD_NOCC |
d2906 1
a2906 1
	if ((le32toh(sed->ed.ed_tailp) & OHCI_HEADMASK) !=
d2914 1
a2914 1
		panic("ohci_device_intr_close: ED not found");
d2969 1
a2969 1
	DPRINTFN(2, ("ohci_setintr: best=%d(%d..%d) bestbw=%d\n",
d3025 1
a3025 1
	ohci_soft_itd_t *sitd, *nsitd;
d3040 1
a3040 1
		DPRINTFN(2,("ohci_device_isoc_enter: start next=%d\n",
d3054 1
a3054 1

d3066 1
a3066 1
				OHCI_ITD_NOCC |
d3078 1
a3078 1
			iso->next = iso->next + ncur;
d3088 1
a3088 1
		printf("%s: isoc TD alloc failed\n",
d3094 1
a3094 1
		OHCI_ITD_NOCC |
d3172 1
a3172 1
	if (xfer->status != USBD_NOT_STARTED &&
d3220 1
a3220 1
	ohci_soft_itd_t *sitd, *nsitd;
@


1.7.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.7.2.6 2003/03/28 00:38:31 niklas Exp $ */
d46 1
a46 1
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
d857 2
a858 5
	sc->sc_noport = 0;
	for (i = 0; i < 10 && sc->sc_noport == 0; i++) {
		usb_delay_ms(&sc->sc_bus, OHCI_READ_DESC_DELAY);
		sc->sc_noport = OHCI_GET_NDP(OREAD4(sc, OHCI_RH_DESCRIPTOR_A));
	}
@


1.7.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ohci.c,v 1.139 2003/02/22 05:24:16 tsutsui Exp $	*/
d204 1
a204 1
Static int		ohci_str(usb_string_descriptor_t *, int, const char *);
a206 1
Static void		ohci_timeout_task(void *);
d208 1
a208 1
Static void		ohci_rhsc_enable(void *);
d212 1
a374 2
	usb_uncallout(sc->sc_tmo_rhsc, ohci_rhsc_enable, sc);

a379 2
	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

d402 2
a403 2
			sed = KERNADDR(&dma, offs);
			sed->physaddr = DMAADDR(&dma, offs);
d440 2
a441 2
			std = KERNADDR(&dma, offs);
			std->physaddr = DMAADDR(&dma, offs);
d488 1
a488 1
	dataphys = DMAADDR(dma, 0);
a593 1
		s = splusb();
d596 2
a597 2
			sitd = KERNADDR(&dma, offs);
			sitd->physaddr = DMAADDR(&dma, offs);
a600 1
		splx(s);
a630 2
	/* Warn double free */
	sitd->isdone = 0;
d640 9
d664 1
a664 1
	printf(" version %d.%d%s\n", OHCI_REV_HI(rev), OHCI_REV_LO(rev),
d688 1
a688 1
	sc->sc_hcca = KERNADDR(&sc->sc_hccadma, 0);
d821 1
a821 1
	OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
a876 1

d887 2
a889 2
 bad2:
	ohci_free_sed(sc, sc->sc_ctrl_head);
d922 1
a922 1
	if (xfer != NULL) {
d924 4
a927 15
#ifdef DIAGNOSTIC
		if (xfer->busy_free != XFER_FREE) {
			printf("ohci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct ohci_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct ohci_xfer));
#ifdef DIAGNOSTIC
		xfer->busy_free = XFER_BUSY;
#endif
	}
a935 8
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("ohci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
		return;
	}
	xfer->busy_free = XFER_FREE;
#endif
d992 1
a992 1
		OWRITE4(sc, OHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
a1068 3
	if (sc == NULL || sc->sc_dying)
		return (0);

a1085 2
	DPRINTFN(14,("ohci_intr1: enter\n"));

a1100 1
		sc->sc_hcca->hcca_done_head = 0;
d1127 1
a1127 1
		eintrs &= ~OHCI_SO;
d1131 1
d1133 1
a1133 1
		eintrs &= ~OHCI_WDH;
d1147 2
a1153 3
		DPRINTFN(2, ("%s: rhsc interrupt disabled\n",
			     USBDEVNAME(sc->sc_bus.bdev)));

d1155 1
a1155 2
                usb_callout(sc->sc_tmo_rhsc, hz, ohci_rhsc_enable, sc);
		eintrs &= ~OHCI_RHSC;
d1160 3
a1162 7
	if (eintrs != 0) {
		/* Block unprocessed interrupts. XXX */
		OWRITE4(sc, OHCI_INTERRUPT_DISABLE, eintrs);
		sc->sc_eintrs &= ~eintrs;
		printf("%s: blocking intrs 0x%x\n",
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
	}
a1183 5
	int s;

	ohci_rhsc(sc, sc->sc_intrxfer);
	DPRINTFN(2, ("%s: rhsc interrupt enabled\n",
		     USBDEVNAME(sc->sc_bus.bdev)));
a1184 1
	s = splhardusb();
a1185 1
	splx(s);
a1252 1
	struct ohci_pipe *opipe;
a1253 3
	int i, j, actlen, iframes, uedir;

	DPRINTFN(10,("ohci_softintr: enter\n"));
d1264 1
a1264 1
	DPRINTFN(10,("ohci_softintr: sdone=%p sidone=%p\n", sdone, sidone));
d1279 1
a1279 2
			/*
			 * xfer == NULL: There seems to be no xfer associated
a1281 1
			 * Shouldn't happen, but some chips are broken(?).
a1304 1
				s = splusb();
a1305 1
				splx(s);
d1315 2
a1316 1
			opipe = (struct ohci_pipe *)xfer->pipe;
a1335 1
			s = splusb();
a1336 1
			splx(s);
d1342 1
a1342 1
		DPRINTF(("ohci_softintr: ITD done:\n"));
d1366 11
a1376 35
		if (sitd->flags & OHCI_CALL_DONE) {
			ohci_soft_itd_t *next;

			opipe = (struct ohci_pipe *)xfer->pipe;
			opipe->u.iso.inuse -= xfer->nframes;
			uedir = UE_GET_DIR(xfer->pipe->endpoint->edesc->
			    bEndpointAddress);
			xfer->status = USBD_NORMAL_COMPLETION;
			actlen = 0;
			for (i = 0, sitd = xfer->hcpriv;;
			    sitd = next) {
				next = sitd->nextitd;
				if (OHCI_ITD_GET_CC(le32toh(sitd->
				    itd.itd_flags)) != OHCI_CC_NO_ERROR)
					xfer->status = USBD_IOERROR;
				/* For input, update frlengths with actual */
				/* XXX anything necessary for output? */
				if (uedir == UE_DIR_IN &&
				    xfer->status == USBD_NORMAL_COMPLETION) {
					iframes = OHCI_ITD_GET_FC(le32toh(
					    sitd->itd.itd_flags));
					for (j = 0; j < iframes; i++, j++) {
						len = le16toh(sitd->
						    itd.itd_offset[j]);
						len =
						    (OHCI_ITD_PSW_GET_CC(len) ==
						    OHCI_CC_NOT_ACCESSED) ? 0 :
						    OHCI_ITD_PSW_LENGTH(len);
						xfer->frlengths[i] = len;
						actlen += len;
					}
				}
				if (sitd->flags & OHCI_CALL_DONE)
					break;
				ohci_free_sitd(sc, sitd);
d1378 3
a1380 6
			ohci_free_sitd(sc, sitd);
			if (uedir == UE_DIR_IN &&
			    xfer->status == USBD_NORMAL_COMPLETION)
				xfer->actlen = actlen;

			s = splusb();
a1381 1
			splx(s);
a1384 7
#ifdef USB_USE_SOFTINTR
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}
#endif /* USB_USE_SOFTINTR */

a1385 1
	DPRINTFN(10,("ohci_softintr: done:\n"));
d1429 1
a1429 1
		data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
d1475 1
a1475 1
	p = KERNADDR(&xfer->dmabuf, 0);
a1516 2
		if (sc->sc_dying)
			break;
a1540 9
#ifdef OHCI_DEBUG
	static int last;
	int new;
	new = OREAD4(sc, OHCI_INTERRUPT_STATUS);
	if (new != last) {
		DPRINTFN(10,("ohci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif
d1610 1
a1610 1
	memcpy(KERNADDR(&opipe->u.ctl.reqdma, 0), req, sizeof *req);
d1614 1
a1614 1
	setup->td.td_cbp = htole32(DMAADDR(&opipe->u.ctl.reqdma, 0));
d1648 1
a1648 1
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
d1653 2
a1654 2
#ifdef OHCI_DEBUG
	if (ohcidebug > 20) {
a1657 4
		ohci_dumpregs(sc);
		printf("ctrl head:\n");
		ohci_dump_ed(sc->sc_ctrl_head);
		printf("sed:\n");
a1678 2
	DPRINTFN(8,("ohci_add_ed: sed=%p head=%p\n", sed, head));

d1697 1
a1697 1
	for (p = head; p != NULL && p->next != sed; p = p->next)
a1792 19
	struct ohci_xfer *oxfer = addr;
	struct ohci_pipe *opipe = (struct ohci_pipe *)oxfer->xfer.pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

	DPRINTF(("ohci_timeout: oxfer=%p\n", oxfer));

	if (sc->sc_dying) {
		ohci_abort_xfer(&oxfer->xfer, USBD_TIMEOUT);
		return;
	}

	/* Execute the abort in a process context. */
	usb_init_task(&oxfer->abort_task, ohci_timeout_task, addr);
	usb_add_task(oxfer->xfer.pipe->device, &oxfer->abort_task);
}

void
ohci_timeout_task(void *addr)
{
d1796 1
a1796 1
	DPRINTF(("ohci_timeout_task: xfer=%p\n", xfer));
d1799 1
d1801 1
d1818 1
a1818 1
	bitmask_snprintf((u_int32_t)le32toh(std->td.td_flags),
d1822 9
a1830 9
	printf("TD(%p) at %08lx: %s delay=%d ec=%d cc=%d\ncbp=0x%08lx "
	       "nexttd=0x%08lx be=0x%08lx\n",
	       std, (u_long)std->physaddr, sbuf,
	       OHCI_TD_GET_DI(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_EC(le32toh(std->td.td_flags)),
	       OHCI_TD_GET_CC(le32toh(std->td.td_flags)),
	       (u_long)le32toh(std->td.td_cbp),
	       (u_long)le32toh(std->td.td_nexttd),
	       (u_long)le32toh(std->td.td_be));
d1838 10
a1847 10
	printf("ITD(%p) at %08lx: sf=%d di=%d fc=%d cc=%d\n"
	       "bp0=0x%08lx next=0x%08lx be=0x%08lx\n",
	       sitd, (u_long)sitd->physaddr,
	       OHCI_ITD_GET_SF(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_DI(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_FC(le32toh(sitd->itd.itd_flags)),
	       OHCI_ITD_GET_CC(le32toh(sitd->itd.itd_flags)),
	       (u_long)le32toh(sitd->itd.itd_bp0),
	       (u_long)le32toh(sitd->itd.itd_nextitd),
	       (u_long)le32toh(sitd->itd.itd_be));
d1849 3
a1851 3
		printf("offs[%d]=0x%04x ", i,
		       (u_int)le16toh(sitd->itd.itd_offset[i]));
	printf("\n");
d1866 1
a1866 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_flags),
d1869 1
a1869 1
	bitmask_snprintf((u_int32_t)le32toh(sed->ed.ed_headp),
d1872 9
a1880 9
	printf("ED(%p) at 0x%08lx: addr=%d endpt=%d maxp=%d flags=%s\n"
	       "tailp=0x%08lx headflags=%s headp=0x%08lx nexted=0x%08lx\n",
	       sed, (u_long)sed->physaddr,
	       OHCI_ED_GET_FA(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_EN(le32toh(sed->ed.ed_flags)),
	       OHCI_ED_GET_MAXP(le32toh(sed->ed.ed_flags)), sbuf,
	       (u_long)le32toh(sed->ed.ed_tailp), sbuf2,
	       (u_long)le32toh(sed->ed.ed_headp),
	       (u_long)le32toh(sed->ed.ed_nexted));
a1904 3
	if (sc->sc_dying)
		return (USBD_IOERROR);

d1937 2
a1938 1
			if (std == NULL)
d1940 1
d1948 2
a1949 2
			(dev->speed == USB_SPEED_LOW ? OHCI_ED_SPEED : 0) |
			fmt | OHCI_ED_SET_MAXP(UGETW(ed->wMaxPacketSize)));
d2011 1
d2013 5
a2017 1
		std = ohci_hash_find_td(sc, le32toh(sed->ed.ed_headp));
a2022 8
#ifdef USB_DEBUG
		usbd_dump_pipe(&opipe->pipe);
#endif
#ifdef OHCI_DEBUG
		ohci_dump_ed(sed);
		if (std)
			ohci_dump_td(std);
#endif
a2029 2
	/* Make sure the host controller is not touching this ED */
	usb_delay_ms(&sc->sc_bus, 1);
d2048 1
a2048 5
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	ohci_soft_ed_t *sed = opipe->sed;
	ohci_soft_td_t *p, *n;
	ohci_physaddr_t headp;
	int s, hit;
d2050 1
a2050 2
	DPRINTF(("ohci_abort_xfer: xfer=%p pipe=%p sed=%p\n", xfer, opipe,
		 sed));
d2052 1
a2052 8
	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
		usb_transfer_complete(xfer);
		splx(s);
	}
d2054 1
a2054 2
	if (xfer->device->bus->intr_context || !curproc)
		panic("ohci_abort_xfer: not in process context");
d2056 1
a2056 7
	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	usb_uncallout(xfer->timeout_handle, ohci_timeout, xfer);
	splx(s);
d2060 29
a2088 6
	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(opipe->pipe.device->bus, 20); /* Hardware finishes in 1ms */
a2089 8
#ifdef USB_USE_SOFTINTR
	sc->sc_softwake = 1;
#endif /* USB_USE_SOFTINTR */
	usb_schedsoftintr(&sc->sc_bus);
#ifdef USB_USE_SOFTINTR
	tsleep(&sc->sc_softwake, PZERO, "ohciab", 0);
#endif /* USB_USE_SOFTINTR */
	splx(s);
a2090 8
	/*
	 * Step 3: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
	 */
	s = splusb();		/* XXX why? */
d2095 1
a2095 1
		printf("ohci_abort_xfer: hcpriv is NULL\n");
a2098 9
#ifdef OHCI_DEBUG
	if (ohcidebug > 1) {
		DPRINTF(("ohci_abort_xfer: sed=\n"));
		ohci_dump_ed(sed);
		ohci_dump_tds(p);
	}
#endif
	headp = le32toh(sed->ed.ed_headp) & OHCI_HEADMASK;
	hit = 0;
a2099 1
		hit |= headp == p->physaddr;
a2102 8
	/* Zap headp register if hardware pointed inside the xfer. */
	if (hit) {
		DPRINTFN(1,("ohci_abort_xfer: set hd=0x08%x, tl=0x%08x\n",
			    (int)p->physaddr, (int)le32toh(sed->ed.ed_tailp)));
		sed->ed.ed_headp = htole32(p->physaddr); /* unlink TDs */
	} else {
		DPRINTFN(1,("ohci_abort_xfer: no hit\n"));
	}
d2104 4
a2107 3
	/*
	 * Step 4: Turn on hardware again.
	 */
a2109 3
	/*
	 * Step 5: Execute callback.
	 */
d2124 1
a2124 1
	UDPROTO_FSHUB,
d2152 1
a2152 1
	UIPROTO_FSHUB,
d2176 4
a2179 1
ohci_str(usb_string_descriptor_t *p, int l, const char *s)
d2243 1
a2243 1
		buf = KERNADDR(&xfer->dmabuf, 0);
d2482 2
a2483 7
			for (i = 0; i < 5; i++) {
				usb_delay_ms(&sc->sc_bus,
					     USB_PORT_ROOT_RESET_DELAY);
				if (sc->sc_dying) {
					err = USBD_IOERROR;
					goto ret;
				}
d2754 1
a2754 1
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
d2847 1
a2847 1
	data->td.td_cbp = htole32(DMAADDR(&xfer->dmabuf, 0));
d3055 1
a3055 1
	buf = DMAADDR(&xfer->dmabuf, 0);
a3132 1
	sed->ed.ed_flags &= htole32(~OHCI_ED_SKIP);
d3160 1
a3160 1
		printf("ohci_device_isoc_start: not in progress %p\n", xfer);
d3228 3
d3234 8
d3268 1
d3271 4
@


1.7.2.9
log
@Merge with the trunk
@
text
@d923 1
a923 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
@


1.6
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a77 1

a78 1

d87 9
d190 1
a190 1
#ifdef USB_DEBUG
d325 2
a326 2
ohci_detach(self, flags)
	device_ptr_t self;
a328 1
	struct ohci_softc *sc = (struct ohci_softc *)self;
d641 1
a641 1
#ifdef USB_DEBUG
d677 1
a677 1
#ifdef USB_DEBUG
d705 1
d707 1
d717 1
d719 1
d724 1
a724 1
#if !defined(__OpenBSD__)
d730 1
a730 1
#ifdef USB_DEBUG
d738 1
a738 1
#endif /* !defined(__OpenBSD__) */
d740 1
a740 1
#ifdef USB_DEBUG
d879 1
a879 1
#ifdef USB_DEBUG
d915 1
a915 1
#ifdef USB_DEBUG
d1113 1
a1113 1
#ifdef USB_DEBUG
d1239 1
a1239 1
#if USB_DEBUG
d1262 1
a1262 1
#if USB_DEBUG
d1385 1
a1385 1
#ifdef USB_DEBUG
d1423 2
a1424 1
		 (u_long)LE(sed->ed.ed_headp), "\20\1HALT\2CARRY",
d1732 1
a1732 1
	void *buf;
a1755 4
#ifdef DIAGNOSTIC
	else
		buf = 0;
#endif
d2074 6
a2079 1
	/* No need to abort. */
d2241 1
a2241 1
#ifdef USB_DEBUG
d2263 2
a2264 1
#ifdef USB_DEBUG
d2360 1
a2360 1
#if USB_DEBUG
d2375 6
a2380 1
#ifdef USB_DEBUG
@


1.5
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 2
a2 2
/*	$OpenBSD: ohci.c,v 1.4 1999/08/19 08:18:38 fgsch Exp $	*/
/*	$NetBSD: ohci.c,v 1.33 1999/06/30 06:44:23 augustss Exp $	*/
d105 7
d126 3
d158 6
a207 1
			usb_dma_t datadma;
d210 1
a210 1
			ohci_soft_td_t *setup, *xfer, *stat;
a213 1
			usb_dma_t datadma;
a218 1
			usb_dma_t datadma;
d222 4
d231 8
a238 1
struct usbd_methods ohci_root_ctrl_methods = {	
a244 1
	0,
d247 1
a247 1
struct usbd_methods ohci_root_intr_methods = {	
a253 1
	0,
d256 1
a256 1
struct usbd_methods ohci_device_ctrl_methods = {	
a262 1
	0,
d265 1
a265 1
struct usbd_methods ohci_device_intr_methods = {	
a271 1
	0,
d274 1
a274 1
struct usbd_methods ohci_device_bulk_methods = {	
a280 1
	0,
d283 52
d346 1
a346 1
		r = usb_allocmem(sc->sc_dmatag, OHCI_SED_SIZE * OHCI_SED_CHUNK,
d385 1
a385 1
		r = usb_allocmem(sc->sc_dmatag, OHCI_STD_SIZE * OHCI_STD_CHUNK,
d414 79
d529 1
a529 1
	r = usb_allocmem(sc->sc_dmatag, OHCI_HCCA_SIZE, 
d675 1
a675 1
	sc->sc_bus.open_pipe = ohci_open;
a676 1
	sc->sc_bus.do_poll = ohci_poll;
d678 1
a678 1
	powerhook_establish(ohci_power, sc);
d687 1
a687 1
	usb_freemem(sc->sc_dmatag, &sc->sc_hccadma);
d691 21
d721 1
a721 1
	printf("ohci_power: sc=%p, why=%d\n", sc, why);
d736 34
a769 34
	printf("ohci_dumpregs: rev=0x%08x control=0x%08x command=0x%08x\n",
	       OREAD4(sc, OHCI_REVISION),
	       OREAD4(sc, OHCI_CONTROL),
	       OREAD4(sc, OHCI_COMMAND_STATUS));
	printf("               intrstat=0x%08x intre=0x%08x intrd=0x%08x\n",
	       OREAD4(sc, OHCI_INTERRUPT_STATUS),
	       OREAD4(sc, OHCI_INTERRUPT_ENABLE),
	       OREAD4(sc, OHCI_INTERRUPT_DISABLE));
	printf("               hcca=0x%08x percur=0x%08x ctrlhd=0x%08x\n",
	       OREAD4(sc, OHCI_HCCA),
	       OREAD4(sc, OHCI_PERIOD_CURRENT_ED),
	       OREAD4(sc, OHCI_CONTROL_HEAD_ED));
	printf("               ctrlcur=0x%08x bulkhd=0x%08x bulkcur=0x%08x\n",
	       OREAD4(sc, OHCI_CONTROL_CURRENT_ED),
	       OREAD4(sc, OHCI_BULK_HEAD_ED),
	       OREAD4(sc, OHCI_BULK_CURRENT_ED));
	printf("               done=0x%08x fmival=0x%08x fmrem=0x%08x\n",
	       OREAD4(sc, OHCI_DONE_HEAD),
	       OREAD4(sc, OHCI_FM_INTERVAL),
	       OREAD4(sc, OHCI_FM_REMAINING));
	printf("               fmnum=0x%08x perst=0x%08x lsthrs=0x%08x\n",
	       OREAD4(sc, OHCI_FM_NUMBER),
	       OREAD4(sc, OHCI_PERIODIC_START),
	       OREAD4(sc, OHCI_LS_THRESHOLD));
	printf("               desca=0x%08x descb=0x%08x stat=0x%08x\n",
	       OREAD4(sc, OHCI_RH_DESCRIPTOR_A),
	       OREAD4(sc, OHCI_RH_DESCRIPTOR_B),
	       OREAD4(sc, OHCI_RH_STATUS));
	printf("               port1=0x%08x port2=0x%08x\n",
	       OREAD4(sc, OHCI_RH_PORT_STATUS(1)),
	       OREAD4(sc, OHCI_RH_PORT_STATUS(2)));
	printf("         HCCA: frame_number=0x%04x done_head=0x%08x\n",
	       LE(sc->sc_hcca->hcca_frame_number),
	       LE(sc->sc_hcca->hcca_done_head));
d807 2
a808 1
	sc->sc_intrs++;
d843 2
d890 1
a890 1
	ohci_soft_td_t *std, *sdone;
d905 1
a905 1
		printf("ohci_process_done: TD done:\n");
d910 1
a910 1
	for (std = sdone; std; std = std->dnext) {
d912 1
a921 1
			continue;
d927 2
a928 2
			if (std->flags & OHCI_SET_LEN)
				reqh->actlen = len;
d933 2
d936 5
d944 1
d948 3
a950 6
			/*
			 * Endpoint is halted.  First unlink all the TDs
			 * belonging to the failed transfer, and then restart
			 * the endpoint.
			 */
			for (p = std->nexttd; p->reqh == reqh; p = n) {
d955 1
d959 1
a959 1
			
a965 2
		ohci_hash_rem_td(sc, std);
		ohci_free_std(sc, std);
a972 5
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	u_int len = opipe->u.ctl.length;
	usb_dma_t *dma;

d976 1
a976 1
	if (!reqh->isreq) {
a980 7

	if (len != 0) {
		dma = &opipe->u.ctl.datadma;
		if (reqh->request.bmRequestType & UT_READ)
			memcpy(reqh->buffer, KERNADDR(dma), len);
		usb_freemem(sc->sc_dmatag, dma);
	}
a988 1
	usb_dma_t *dma;
d990 1
a990 1
	ohci_soft_td_t *xfer, *tail;
a997 3
	dma = &opipe->u.intr.datadma;
	memcpy(reqh->buffer, KERNADDR(dma), reqh->actlen);

d999 1
a999 1
		xfer = opipe->tail;
d1007 1
a1007 1
		xfer->td.td_flags = LE(
d1011 10
a1020 9
			xfer->td.td_flags |= LE(OHCI_TD_R);
		xfer->td.td_cbp = LE(DMAADDR(dma));
		xfer->nexttd = tail;
		xfer->td.td_nexttd = LE(tail->physaddr);
		xfer->td.td_be = LE(LE(xfer->td.td_cbp) + reqh->length - 1);
		xfer->len = reqh->length;
		xfer->reqh = reqh;
		xfer->flags = OHCI_CALL_DONE | OHCI_SET_LEN;
		reqh->hcpriv = xfer;
d1022 1
a1022 1
		ohci_hash_add_td(sc, xfer);
a1024 2
	} else {
		usb_freemem(sc->sc_dmatag, dma);
a1031 5
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;
	u_int len = opipe->u.bulk.length;
	usb_dma_t *dma;

a1035 5

	dma = &opipe->u.bulk.datadma;
	if (opipe->u.bulk.isread)
		memcpy(reqh->buffer, KERNADDR(dma), len);
	usb_freemem(sc->sc_dmatag, dma);
d1061 1
a1061 1
	p = KERNADDR(&opipe->u.intr.datadma);
a1078 3
	struct ohci_pipe *opipe = (struct ohci_pipe *)reqh->pipe;
	ohci_softc_t *sc = (ohci_softc_t *)opipe->pipe.device->bus;

a1079 3

	if (!reqh->pipe->repeat)
		usb_freemem(sc->sc_dmatag, &opipe->u.intr.datadma);
d1138 1
a1138 1
	ohci_soft_td_t *setup, *xfer = 0, *stat, *next, *tail;
a1139 1
	usb_dma_t *dmap;
a1167 1
	dmap = &opipe->u.ctl.datadma;
d1179 2
a1180 2
		xfer = ohci_alloc_std(sc);
		if (!xfer) {
d1184 1
a1184 4
		r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
		if (r != USBD_NORMAL_COMPLETION)
			goto bad4;
		xfer->td.td_flags = LE(
d1188 7
a1194 7
		xfer->td.td_cbp = LE(DMAADDR(dmap));
		xfer->nexttd = stat;
		xfer->td.td_nexttd = LE(stat->physaddr);
		xfer->td.td_be = LE(LE(xfer->td.td_cbp) + len - 1);
		xfer->len = len;
		xfer->reqh = reqh;
		xfer->flags = OHCI_SET_LEN;
d1196 1
a1196 1
		next = xfer;
d1200 2
a1201 1
		stat->flags = OHCI_CALL_DONE | OHCI_SET_LEN;
a1204 2
	if (!isread && len != 0)
		memcpy(KERNADDR(dmap), reqh->buffer, len);
d1229 1
a1229 1
		printf("ohci_device_request:\n");
d1239 1
a1239 1
		ohci_hash_add_td(sc, xfer);
d1253 2
a1254 2
		printf("ohci_device_request: status=%x\n",
		       OREAD4(sc, OHCI_COMMAND_STATUS));
a1261 2
 bad4:
	ohci_free_std(sc, xfer);
d1278 1
d1295 2
d1325 2
d1336 2
d1362 1
d1365 3
d1369 2
d1386 10
a1395 10
	printf("TD(%p) at %08lx: %b delay=%d ec=%d cc=%d\ncbp=0x%08lx "
	       "nexttd=0x%08lx be=0x%08lx\n", 
	       std, (u_long)std->physaddr,
	       (int)LE(std->td.td_flags),
	       "\20\23R\24OUT\25IN\31TOG1\32SETTOGGLE",
	       OHCI_TD_GET_DI(LE(std->td.td_flags)),
	       OHCI_TD_GET_EC(LE(std->td.td_flags)),
	       OHCI_TD_GET_CC(LE(std->td.td_flags)),
	       (u_long)LE(std->td.td_cbp),
	       (u_long)LE(std->td.td_nexttd), (u_long)LE(std->td.td_be));
d1402 11
a1412 11
	printf("ED(%p) at %08lx: addr=%d endpt=%d maxp=%d %b\ntailp=0x%08lx "
	       "headp=%b nexted=0x%08lx\n",
	       sed, (u_long)sed->physaddr, 
	       OHCI_ED_GET_FA(LE(sed->ed.ed_flags)),
	       OHCI_ED_GET_EN(LE(sed->ed.ed_flags)),
	       OHCI_ED_GET_MAXP(LE(sed->ed.ed_flags)),
	       (int)LE(sed->ed.ed_flags),
	       "\20\14OUT\15IN\16LOWSPEED\17SKIP\20ISO",
	       (u_long)LE(sed->ed.ed_tailp),
	       (u_long)LE(sed->ed.ed_headp), "\20\1HALT\2CARRY",
	       (u_long)LE(sed->ed.ed_nexted));
d1437 1
a1437 1
		case UE_IN | OHCI_INTR_ENDPT:
d1465 1
a1465 1
			r = usb_allocmem(sc->sc_dmatag, 
d1479 1
a1479 1
			return (USBD_XXX);
d1569 4
a1572 1
	if (curproc) {
a1574 2
	} else {
		timeout(ohci_abort_req_end, reqh, hz / USB_FRAMES_PER_SECOND);
d1659 1
a1659 1
	UE_IN | OHCI_INTR_ENDPT,
a1701 1
	int s;
d1704 1
a1704 1
	s = splusb();
a1705 1
	splx(s);
d1708 3
a1710 2
	else
		return (ohci_root_ctrl_start(reqh));
d1721 1
a1721 1
	int len, value, index, l, totlen = 0;
d1727 2
a1728 1
	if (!reqh->isreq)
d1731 1
a1732 1
	buf = reqh->buffer;
d1740 8
d2010 1
d2012 1
a2036 1
	int s;
d2039 1
a2039 1
	s = splusb();
a2040 1
	splx(s);
d2043 3
a2045 2
	else
		return (ohci_root_intr_start(reqh));
a2053 9
	struct ohci_pipe *upipe = (struct ohci_pipe *)pipe;
	usb_dma_t *dmap;
	usbd_status r;
	int len;

	len = reqh->length;
	dmap = &upipe->u.intr.datadma;
	if (len == 0)
		return (USBD_INVAL); /* XXX should it be? */
a2054 3
	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
a2085 1
	int s;
d2088 1
a2088 1
	s = splusb();
a2089 1
	splx(s);
d2092 3
a2094 2
	else
		return (ohci_device_ctrl_start(reqh));
d2104 2
a2105 1
	if (!reqh->isreq) {
d2110 1
a2161 1
	int s;
d2164 1
a2164 1
	s = splusb();
a2165 1
	splx(s);
d2168 3
a2170 2
	else
		return (ohci_device_bulk_start(reqh));
d2181 1
a2181 1
	ohci_soft_td_t *xfer, *tail;
d2183 1
a2183 1
	usb_dma_t *dmap;
a2184 1
	int s, len, isread;
d2187 1
a2187 1
	if (reqh->isreq) {
d2195 2
a2196 2
	dmap = &opipe->u.bulk.datadma;
	isread = reqh->pipe->endpoint->edesc->bEndpointAddress & UE_IN;
d2201 1
a2201 1
		    reqh->pipe->endpoint->edesc->bEndpointAddress));
a2205 11
	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		goto ret1;

	tail = ohci_alloc_std(sc);
	if (!tail) {
		r = USBD_NOMEM;
		goto ret2;
	}
	tail->reqh = 0;

d2211 7
a2217 14
	/* Set up data transaction */
	xfer = opipe->tail;
	xfer->td.td_flags = LE(
		(isread ? OHCI_TD_IN : OHCI_TD_OUT) | OHCI_TD_NOCC |
		OHCI_TD_SET_DI(1) | OHCI_TD_TOGGLE_CARRY |
		(reqh->flags & USBD_SHORT_XFER_OK ? OHCI_TD_R : 0));
	xfer->td.td_cbp = LE(DMAADDR(dmap));
	xfer->nexttd = tail;
	xfer->td.td_nexttd = LE(tail->physaddr);
	xfer->td.td_be = LE(LE(xfer->td.td_cbp) + len - 1);
	xfer->len = len;
	xfer->reqh = reqh;
	xfer->flags = OHCI_CALL_DONE | OHCI_SET_LEN;
	reqh->hcpriv = xfer;
d2219 2
a2220 2
	if (!isread)
		memcpy(KERNADDR(dmap), reqh->buffer, len);
d2224 2
a2225 2
		    (int)LE(sed->ed.ed_flags), (int)LE(xfer->td.td_flags),
		    (int)LE(xfer->td.td_cbp), (int)LE(xfer->td.td_be)));
d2230 1
a2230 1
		ohci_dump_tds(xfer);
d2236 4
a2239 1
	ohci_hash_add_td(sc, xfer);
d2252 2
a2253 2
		printf("ohci_device_intr_transfer: status=%x\n",
		       OREAD4(sc, OHCI_COMMAND_STATUS));
d2255 1
a2255 1
		ohci_dump_tds(xfer);
a2261 5

 ret2:
	usb_freemem(sc->sc_dmatag, dmap);
 ret1:
	return (r);
a2290 1
	int s;
d2293 1
a2293 1
	s = splusb();
a2294 1
	splx(s);
d2297 3
a2299 2
	else
		return (ohci_device_intr_start(reqh));
d2310 1
a2310 3
	ohci_soft_td_t *xfer, *tail;
	usb_dma_t *dmap;
	usbd_status r;
d2314 1
a2314 1
	DPRINTFN(3, ("ohci_device_intr_transfer: reqh=%p buf=%p len=%d "
d2316 1
a2316 1
		 reqh, reqh->buffer, reqh->length, reqh->flags, reqh->priv));
d2318 2
a2319 1
	if (reqh->isreq)
d2321 1
a2323 3
	dmap = &opipe->u.intr.datadma;
	if (len == 0)
		return (USBD_INVAL); /* XXX should it be? */
d2325 1
a2325 1
	xfer = opipe->tail;
d2327 2
a2328 4
	if (!tail) {
		r = USBD_NOMEM;
		goto ret1;
	}
d2331 1
a2331 5
	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		goto ret2;

	xfer->td.td_flags = LE(
d2335 9
a2343 9
		xfer->td.td_flags |= LE(OHCI_TD_R);
	xfer->td.td_cbp = LE(DMAADDR(dmap));
	xfer->nexttd = tail;
	xfer->td.td_nexttd = LE(tail->physaddr);
	xfer->td.td_be = LE(LE(xfer->td.td_cbp) + len - 1);
	xfer->len = len;
	xfer->reqh = reqh;
	xfer->flags = OHCI_CALL_DONE | OHCI_SET_LEN;
	reqh->hcpriv = xfer;
d2347 1
a2347 1
		printf("ohci_device_intr_transfer:\n");
d2349 1
a2349 1
		ohci_dump_tds(xfer);
d2355 1
a2355 1
	ohci_hash_add_td(sc, xfer);
d2363 2
a2364 2
		printf("ohci_device_intr_transfer: status=%x\n",
		       OREAD4(sc, OHCI_COMMAND_STATUS));
d2366 1
a2366 1
		ohci_dump_tds(xfer);
a2371 5

 ret2:
	ohci_free_std(sc, xfer);
 ret1:
	return (r);
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.3 1999/08/15 18:58:58 fgsch Exp $	*/
d68 1
a69 1
#include <dev/usb/usb_mem.h>
a110 5
void		ohci_idone __P((ohci_softc_t *, usbd_request_handle));
void		ohci_done __P((ohci_softc_t *, usbd_request_handle));
void		ohci_ctrl_done __P((ohci_softc_t *, usbd_request_handle));
void		ohci_intr_done __P((ohci_softc_t *, usbd_request_handle));
void		ohci_bulk_done __P((ohci_softc_t *, usbd_request_handle));
d128 1
d134 1
d140 1
d146 2
d158 3
a160 1
void		ohci_abort_request __P((usbd_request_handle reqh));
d221 1
d230 1
d240 1
d250 1
d260 1
d275 1
a275 5
		sed = malloc(sizeof(ohci_soft_ed_t) * OHCI_ED_CHUNK, 
			     M_USBHC, M_NOWAIT);
		if (!sed)
			return 0;
		r = usb_allocmem(sc->sc_dmatag, OHCI_ED_SIZE * OHCI_ED_CHUNK,
d277 5
a281 6
		if (r != USBD_NORMAL_COMPLETION) {
			free(sed, M_USBHC);
			return 0;
		}
		for(i = 0; i < OHCI_ED_CHUNK; i++, sed++) {
			offs = i * OHCI_ED_SIZE;
a282 2
			sed->ed = (ohci_ed_t *)
					((char *)KERNADDR(&dma) + offs);
d289 1
a289 1
	memset(sed->ed, 0, OHCI_ED_SIZE);
d291 1
a291 1
	return sed;
d314 1
a314 5
		std = malloc(sizeof(ohci_soft_td_t) * OHCI_TD_CHUNK, 
			     M_USBHC, M_NOWAIT);
		if (!std)
			return 0;
		r = usb_allocmem(sc->sc_dmatag, OHCI_TD_SIZE * OHCI_TD_CHUNK,
d316 5
a320 6
		if (r != USBD_NORMAL_COMPLETION) {
			free(std, M_USBHC);
			return 0;
		}
		for(i = 0; i < OHCI_TD_CHUNK; i++, std++) {
			offs = i * OHCI_TD_SIZE;
a321 2
			std->td = (ohci_td_t *)
					((char *)KERNADDR(&dma) + offs);
d328 1
a328 1
	memset(std->td, 0, OHCI_TD_SIZE);
d355 1
a355 1
	printf(", version %d.%d%s", 
d393 1
a393 1
	sc->sc_ctrl_head->ed->ed_flags |= LE(OHCI_ED_SKIP);
d400 1
a400 1
	sc->sc_bulk_head->ed->ed_flags |= LE(OHCI_ED_SKIP);
d413 1
a413 1
		sed->ed->ed_flags |= LE(OHCI_ED_SKIP);
d417 1
a417 1
			sed->ed->ed_nexted = LE(psed->physaddr);
d724 1
a724 1
	for (sdone = 0; done; done = LE(std->td->td_nexttd)) {
d741 2
a742 1
		cc = OHCI_TD_GET_CC(LE(std->td->td_flags));
d747 2
a748 1
			ohci_idone(sc, reqh);
d751 3
a753 3
			if (std->td->td_cbp != 0)
				len -= LE(std->td->td_be) -
				       LE(std->td->td_cbp) + 1;
d758 1
a758 1
				ohci_idone(sc, reqh);
d765 2
a766 2
			 OHCI_TD_GET_CC(LE(std->td->td_flags)),
			 ohci_cc_strs[OHCI_TD_GET_CC(LE(std->td->td_flags))]));
d778 1
a778 1
			opipe->sed->ed->ed_headp = LE(p->physaddr);
d785 1
a785 1
			ohci_idone(sc, reqh);
d793 1
a793 47
ohci_idone(sc, reqh)
	ohci_softc_t *sc;
	usbd_request_handle reqh;
{
	ohci_done(sc, reqh);
	if (reqh->pipe->intrreqh != reqh)
		usb_start_next(reqh->pipe);
}

void
ohci_done(sc, reqh)
	ohci_softc_t *sc;
	usbd_request_handle reqh;
{
	usbd_pipe_handle pipe = reqh->pipe;

#ifdef DIAGNOSTIC
	if (!reqh->hcpriv)
		printf("ohci_done: reqh=%p, no hcpriv\n", reqh);
#endif
	reqh->hcpriv = 0;

	switch (pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) {
	case UE_CONTROL:
		ohci_ctrl_done(sc, reqh);
		break;
	case UE_INTERRUPT:
		ohci_intr_done(sc, reqh);
		break;
	case UE_BULK:
		ohci_bulk_done(sc, reqh);
		break;
	case UE_ISOCHRONOUS:
		printf("ohci_process_done: ISO done?\n");
		break;
	}

	/* Remove request from queue. */
	SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);

	/* And finally execute callback. */
	reqh->xfercb(reqh);
}

void
ohci_ctrl_done(sc, reqh)
	ohci_softc_t *sc;
d797 1
d803 1
a805 1
		return;
d807 2
a815 1
	usb_untimeout(ohci_timeout, reqh, reqh->timo_handle);
d819 1
a819 2
ohci_intr_done(sc, reqh)
	ohci_softc_t *sc;
d823 1
d832 2
d837 1
a837 1
	if (reqh->pipe->intrreqh == reqh) {
d846 1
a846 1
		xfer->td->td_flags = LE(
d850 2
a851 2
			xfer->td->td_flags |= LE(OHCI_TD_R);
		xfer->td->td_cbp = LE(DMAADDR(dma));
d853 2
a854 2
		xfer->td->td_nexttd = LE(tail->physaddr);
		xfer->td->td_be = LE(LE(xfer->td->td_cbp) + reqh->length - 1);
d861 1
a861 1
		sed->ed->ed_tailp = LE(tail->physaddr);
d869 1
a869 2
ohci_bulk_done(sc, reqh)
	ohci_softc_t *sc;
d873 1
a876 1

d880 2
a885 1
	usb_untimeout(ohci_timeout, reqh, reqh->timo_handle);
a920 1
	reqh->xfercb(reqh);
d922 13
a934 2
	if (reqh->pipe->intrreqh != reqh) {
		sc->sc_intrreqh = 0;
a935 2
		usb_start_next(reqh->pipe);
	}
d971 1
a971 1
	ohci_idone(sc, reqh);
d1030 2
a1031 2
	sed->ed->ed_flags = LE(
	 (LE(sed->ed->ed_flags) & ~(OHCI_ED_ADDRMASK | OHCI_ED_MAXPMASK)) |
d1045 1
a1045 1
		xfer->td->td_flags = LE(
d1049 1
a1049 1
		xfer->td->td_cbp = LE(DMAADDR(dmap));
d1051 2
a1052 2
		xfer->td->td_nexttd = LE(stat->physaddr);
		xfer->td->td_be = LE(LE(xfer->td->td_cbp) + len - 1);
d1068 1
a1068 1
	setup->td->td_flags = LE(OHCI_TD_SETUP | OHCI_TD_NOCC |
d1070 1
a1070 1
	setup->td->td_cbp = LE(DMAADDR(&opipe->u.ctl.reqdma));
d1072 2
a1073 2
	setup->td->td_nexttd = LE(next->physaddr);
	setup->td->td_be = LE(LE(setup->td->td_cbp) + sizeof *req - 1);
d1079 1
a1079 1
	stat->td->td_flags = LE(
d1082 1
a1082 1
	stat->td->td_cbp = 0;
d1084 2
a1085 2
	stat->td->td_nexttd = LE(tail->physaddr);
	stat->td->td_be = 0;
d1103 1
a1103 1
	sed->ed->ed_tailp = LE(tail->physaddr);
d1143 1
a1143 1
	sed->ed->ed_nexted = head->ed->ed_nexted;
d1145 1
a1145 1
	head->ed->ed_nexted = LE(sed->physaddr);
d1164 1
a1164 1
	p->ed->ed_nexted = sed->ed->ed_nexted;
d1218 1
a1218 3
#if 0
	usbd_request_handle *reqh = addr;
	int s;
d1221 1
a1221 5
	s = splusb();
	/* XXX need to inactivate TD before calling interrupt routine */
	ohci_XXX_done(reqh);
	splx(s);
#endif
d1240 1
a1240 1
	       (int)LE(std->td->td_flags),
d1242 5
a1246 5
	       OHCI_TD_GET_DI(LE(std->td->td_flags)),
	       OHCI_TD_GET_EC(LE(std->td->td_flags)),
	       OHCI_TD_GET_CC(LE(std->td->td_flags)),
	       (u_long)LE(std->td->td_cbp),
	       (u_long)LE(std->td->td_nexttd), (u_long)LE(std->td->td_be));
d1256 4
a1259 4
	       OHCI_ED_GET_FA(LE(sed->ed->ed_flags)),
	       OHCI_ED_GET_EN(LE(sed->ed->ed_flags)),
	       OHCI_ED_GET_MAXP(LE(sed->ed->ed_flags)),
	       (int)LE(sed->ed->ed_flags),
d1261 3
a1263 3
	       (u_long)LE(sed->ed->ed_tailp),
	       (u_long)LE(sed->ed->ed_headp), "\20\1HALT\2CARRY",
	       (u_long)LE(sed->ed->ed_nexted));
d1303 1
a1303 1
		sed->ed->ed_flags = LE(
d1311 1
a1311 1
		sed->ed->ed_headp = sed->ed->ed_tailp = LE(std->physaddr);
d1366 4
a1369 4
	sed->ed->ed_flags |= LE(OHCI_ED_SKIP);
	if ((sed->ed->ed_tailp & LE(OHCI_TAILMASK)) != 
	    (sed->ed->ed_headp & LE(OHCI_TAILMASK))) {
		ohci_physaddr_t td = sed->ed->ed_headp;
d1378 1
a1378 1
		       (int)LE(sed->ed->ed_headp), (int)LE(sed->ed->ed_tailp),
d1381 2
a1382 2
		if ((sed->ed->ed_tailp & LE(OHCI_TAILMASK)) != 
		    (sed->ed->ed_headp & LE(OHCI_TAILMASK)))
d1403 1
a1403 1
ohci_abort_request(reqh)
d1405 26
d1432 1
d1434 1
a1434 2
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
a1438 1
	DPRINTF(("ohci_abort_request: reqh=%p pipe=%p\n", reqh, opipe));
d1441 4
a1444 5
	reqh->status = USBD_CANCELLED; /* mark as cancelled */

	if (!reqh->hcpriv) {
		/* Not scheduled */
		reqh->xfercb(reqh);
d1447 6
d1455 6
a1460 27
	DPRINTFN(1,("ohci_abort_request: stop ed=%p\n", sed));
	sed->ed->ed_flags |= LE(OHCI_ED_SKIP); /* force hardware skip */
	delay(10);		/* give HC hardware a little time */

	/* if already processed by hardware let interrupt routine handle it */
	if ((sed->ed->ed_tailp & LE(OHCI_TAILMASK)) == 
	    (sed->ed->ed_headp & LE(OHCI_TAILMASK))) {
		DPRINTF(("ohci_abort_request: request processed\n"));
		usb_delay_ms(dev->bus, 2);
	} else {
		p = reqh->hcpriv;
#ifdef DIAGNOSTIC
		if (!p) {
			printf("ohci_abort_request: hcpriv==0\n");
			return;
		}
#endif
		ohci_done(sc, reqh);
		for (; p->reqh == reqh; p = n) {
		    n = p->nexttd;
		    ohci_hash_rem_td(sc, p);
		    ohci_free_std(sc, p);
		}
		DPRINTFN(2,("ohci_abort_request: set hd=%x, tl=%x\n",
			    (int)LE(p->physaddr), (int)LE(sed->ed->ed_tailp)));
		sed->ed->ed_headp = p->physaddr; /* unlink TDs */
	}
a1461 1
	sed->ed->ed_flags &= LE(~OHCI_ED_SKIP); /* remove hardware skip */
a1850 1
	SIMPLEQ_REMOVE_HEAD(&reqh->pipe->queue, reqh, next);
d1852 1
a1852 2
	reqh->xfercb(reqh);
	usb_start_next(reqh->pipe);
d1979 1
a1979 1
	ohci_abort_request(reqh);
d2001 1
a2001 1
	opipe->sed->ed->ed_tailp &= LE(~OHCI_TOGGLECARRY);
d2072 2
a2073 2
	sed->ed->ed_flags = LE(
		(LE(sed->ed->ed_flags) & ~OHCI_ED_ADDRMASK) |
d2078 1
a2078 1
	xfer->td->td_flags = LE(
d2082 1
a2082 1
	xfer->td->td_cbp = LE(DMAADDR(dmap));
d2084 2
a2085 2
	xfer->td->td_nexttd = LE(tail->physaddr);
	xfer->td->td_be = LE(LE(xfer->td->td_cbp) + len - 1);
d2096 2
a2097 2
		    (int)LE(sed->ed->ed_flags), (int)LE(xfer->td->td_flags),
		    (int)LE(xfer->td->td_cbp), (int)LE(xfer->td->td_be)));
d2109 1
a2109 1
	sed->ed->ed_tailp = LE(tail->physaddr);
d2111 1
a2111 1
	sed->ed->ed_flags &= LE(~OHCI_ED_SKIP);
d2143 1
a2143 1
	ohci_abort_request(reqh);
d2215 1
a2215 1
	xfer->td->td_flags = LE(
d2219 2
a2220 2
		xfer->td->td_flags |= LE(OHCI_TD_R);
	xfer->td->td_cbp = LE(DMAADDR(dmap));
d2222 2
a2223 2
	xfer->td->td_nexttd = LE(tail->physaddr);
	xfer->td->td_be = LE(LE(xfer->td->td_cbp) + len - 1);
d2240 1
a2240 1
	sed->ed->ed_tailp = LE(tail->physaddr);
d2242 1
a2242 7
#if 0
	if (reqh->timeout && !sc->sc_bus.use_polling) {
                usb_timeout(ohci_timeout, reqh,
			    MS_TO_TICKS(reqh->timeout), reqh->timo_handle);
	}
#endif
	sed->ed->ed_flags &= LE(~OHCI_ED_SKIP);
d2272 1
a2272 1
	ohci_abort_request(reqh);
d2291 3
a2293 3
	sed->ed->ed_flags |= LE(OHCI_ED_SKIP);
	if ((sed->ed->ed_tailp & LE(OHCI_TAILMASK)) != 
	    (sed->ed->ed_headp & LE(OHCI_TAILMASK)))
d2301 1
a2301 1
	p->ed->ed_nexted = sed->ed->ed_nexted;
d2362 1
a2362 1
	sed->ed->ed_nexted = hsed->ed->ed_nexted;
d2364 1
a2364 1
	hsed->ed->ed_nexted = LE(sed->physaddr);
@


1.3
log
@Sync with NetBSD.
Implement timeouts and abort requests.
Compute length of short transfers correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.2 1999/08/13 08:55:57 fgsch Exp $	*/
a91 3
#if defined(__OpenBSD__)
#define LE(x) (swap32(x))
#else
a92 1
#endif
d160 3
a170 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a173 5
#elif defined(__FreeBSD__)
#define OWRITE4(sc, r, x) (*(u_int32_t *) ((sc)->sc_iobase + (r)) = (x))
#define OREAD4(sc, r) (*(u_int32_t *) ((sc)->sc_iobase + (r)))
#define OREAD2(sc, r) (*(u_int16_t *) ((sc)->sc_iobase + (r)))
#endif
d217 1
d226 1
d235 1
d244 2
d253 1
d536 1
a536 3
#if !defined(__OpenBSD__)
	(void)powerhook_establish(ohci_power, sc);
#endif
d549 1
d563 1
d812 2
d820 1
a820 1
	switch (reqh->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) {
d835 3
d1888 1
d2033 15
@


1.2
log
@shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ohci.c,v 1.1 1999/08/13 05:28:03 fgsch Exp $	*/
d115 2
a116 1
void		ohci_ii_done __P((ohci_softc_t *, usbd_request_handle));
d160 4
d177 1
a177 1
#define OWRITE4(sc, r, x) *(u_int32_t *) ((sc)->sc_iobase + (r)) = x
d402 1
d620 1
a620 1
	if (sc == NULL || sc->sc_hcca == NULL) {	/* NWH added sc==0 */
d750 15
a764 25
		if (cc == OHCI_CC_NO_ERROR) {
			if (std->td->td_cbp == 0)
				len = std->len;
			else
				len = LE(std->td->td_be) - 
				      LE(std->td->td_cbp) + 1;
			/* 
			 * Only do a callback on the last stage of a transfer.
			 * Others have hcpriv = 0.
			 */
			if ((reqh->pipe->endpoint->edesc->bmAttributes & 
			     UE_XFERTYPE) == UE_CONTROL) {
				/* For a control transfer the length is in
				 * the xfer stage */
				if (reqh->hcpriv == std) {
					reqh->status = USBD_NORMAL_COMPLETION;
					ohci_ii_done(sc, reqh);
				} else
					reqh->actlen = len;
			} else {
				if (reqh->hcpriv == std) {
					reqh->actlen = len;
					reqh->status = USBD_NORMAL_COMPLETION;
					ohci_ii_done(sc, reqh);
				}
d791 1
a791 1
			ohci_ii_done(sc, reqh);
d799 11
a809 1
ohci_ii_done(sc, reqh)
d813 6
a821 1
		usb_start_next(reqh->pipe);
a827 1
		usb_start_next(reqh->pipe);
a830 1
		usb_start_next(reqh->pipe);
d880 1
a880 1
	if (reqh->pipe->repeat) {
d900 1
a900 1

a907 1
		usb_start_next(reqh->pipe);
d924 4
a927 6
	if (len != 0) {
		dma = &opipe->u.bulk.datadma;
		if (opipe->u.bulk.isread)
			memcpy(reqh->buffer, KERNADDR(dma), len);
		usb_freemem(sc->sc_dmatag, dma);
	}
d966 1
a966 1
	if (!reqh->pipe->repeat) {
d1006 1
a1006 1
	ohci_ii_done(sc, reqh);
d1090 1
d1093 2
a1094 1
	} else
d1096 2
d1111 2
a1123 2
	reqh->hcpriv = stat;

d1281 1
a1281 1
	       (u_long)LE(std->td->td_flags),
d1300 1
a1300 1
	       (u_long)LE(sed->ed->ed_flags),
d1392 107
d1904 1
a1960 1
	sc->sc_intrreqh = 0;
d1963 2
d2012 2
a2013 3
	/* XXX inactivate */
	usb_delay_ms(reqh->pipe->device->bus, 1); /* make sure it is donw */
	/* XXX call done */
a2020 1
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
a2021 2
	ohci_soft_ed_t *sed = opipe->sed;
	int s;
d2023 2
a2024 9
	s = splusb();
	sed->ed->ed_flags |= LE(OHCI_ED_SKIP);
	if ((LE(sed->ed->ed_tailp) & OHCI_TAILMASK) != LE(sed->ed->ed_headp))
		usb_delay_ms(&sc->sc_bus, 2);
	ohci_rem_ed(sed, sc->sc_ctrl_head);
	splx(s);
	ohci_free_std(sc, opipe->tail);
	ohci_free_sed(sc, opipe->sed);
	/* XXX free other resources */
d2059 1
d2062 1
a2062 1
		printf("ohci_device_bulk_transfer: a request\n");
d2065 1
d2072 4
d2107 1
a2107 1

d2113 12
d2130 1
a2130 1
	sed->ed->ed_flags &= LE(~OHCI_ED_SKIP); /* XXX why */
d2136 11
a2156 1
/* Abort a device bulk request. */
d2161 2
a2162 8
#if 0
	sed->ed->ed_flags |= LE(OHCI_ED_SKIP);
	if ((LE(sed->ed->ed_tailp) & OHCI_TAILMASK) != LE(sed->ed->ed_headp))
		usb_delay_ms(reqh->pipe->device->bus, 2);
#endif
	/* XXX inactivate */
	usb_delay_ms(reqh->pipe->device->bus, 1); /* make sure it is done */
	/* XXX call done */
d2165 3
a2167 1
/* Close a device bulk pipe. */
d2172 1
a2172 4
	struct ohci_pipe *opipe = (struct ohci_pipe *)pipe;
	usbd_device_handle dev = opipe->pipe.device;
	ohci_softc_t *sc = (ohci_softc_t *)dev->bus;
	int s;
d2174 2
a2175 6
	s = splusb();
	ohci_rem_ed(opipe->sed, sc->sc_bulk_head);
	splx(s);
	ohci_free_std(sc, opipe->tail);
	ohci_free_sed(sc, opipe->sed);
	/* XXX free other resources */
d2245 1
a2245 1

d2293 1
a2293 3
	/* XXX inactivate */
	usb_delay_ms(reqh->pipe->device->bus, 1); /* make sure it is done */
	if (reqh->pipe->repeat) {
d2295 1
a2295 2
		reqh->pipe->repeat = 0;
		ohci_intr_done((ohci_softc_t *)reqh->pipe->device->bus, reqh);
d2297 1
d2317 2
a2318 1
	if ((sed->ed->ed_tailp & LE(OHCI_TAILMASK)) != sed->ed->ed_headp)
a2333 1
	/* XXX free other resources */
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d357 3
d361 1
d365 3
d370 1
d372 4
@

