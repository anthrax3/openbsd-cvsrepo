head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.8
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.26
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	6s3MfY9d6ZKdL2Uz;

1.25
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.24;
commitid	KAeCDAijcgEnOtfF;

1.24
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.23;
commitid	kI4H556ZKYkRQGw5;

1.23
date	2015.10.01.14.03.44;	author mpi;	state Exp;
branches;
next	1.22;
commitid	dHJMa0OqkhodYXnp;

1.22
date	2015.06.17.08.31.55;	author mpi;	state Exp;
branches;
next	1.21;
commitid	zrfHHulYTSDt3Te1;

1.21
date	2015.05.14.13.50.34;	author mpi;	state Exp;
branches;
next	1.20;
commitid	0bQ7sEqROezMHki4;

1.20
date	2015.05.11.08.51.31;	author mpi;	state Exp;
branches;
next	1.19;
commitid	CEGujq1eqQr3lsHc;

1.19
date	2015.04.30.10.09.31;	author mpi;	state Exp;
branches;
next	1.18;
commitid	aHhvZu5C2ljRNGSm;

1.18
date	2015.04.30.10.00.50;	author mpi;	state Exp;
branches;
next	1.17;
commitid	MMARg0yhkypYprBI;

1.17
date	2015.04.27.09.14.45;	author mpi;	state Exp;
branches;
next	1.16;
commitid	BAe8E2PSueG3RxYx;

1.16
date	2015.04.27.07.41.41;	author mpi;	state Exp;
branches;
next	1.15;
commitid	FevuHsEsk1X5EmsO;

1.15
date	2015.04.27.07.37.19;	author mpi;	state Exp;
branches;
next	1.14;
commitid	XFKPDZnwU3xcxdti;

1.14
date	2015.04.01.11.44.44;	author mpi;	state Exp;
branches;
next	1.13;
commitid	qpJ7i94W66cLDwIG;

1.13
date	2015.01.11.03.08.38;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	wdVdhgRtFrhnX8iO;

1.12
date	2014.12.11.18.50.32;	author mpi;	state Exp;
branches;
next	1.11;
commitid	2O1dVMHpgNRzVSIx;

1.11
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.10;
commitid	L2P5oN9ppxqXZsYS;

1.10
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.9;
commitid	OBNa5kfxQ2UXoiIw;

1.9
date	2014.05.12.09.50.44;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2014.04.29.07.23.40;	author andre;	state Exp;
branches;
next	1.7;

1.7
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.6;

1.6
date	2014.04.07.21.54.13;	author andre;	state Exp;
branches;
next	1.5;

1.5
date	2014.03.20.13.07.01;	author andre;	state Exp;
branches;
next	1.4;

1.4
date	2014.03.20.12.50.49;	author andre;	state Exp;
branches;
next	1.3;

1.3
date	2014.03.19.16.34.34;	author andre;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.19.16.08.32;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2014.03.17.18.40.46;	author andre;	state Exp;
branches;
next	;


desc
@@


1.26
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: upd.c,v 1.25 2016/01/09 04:14:42 jcs Exp $ */

/*
 * Copyright (c) 2015 David Higgs <higgsd@@gmail.com>
 * Copyright (c) 2014 Andre de Oliveira <andre@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for USB Power Devices sensors */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usbhid.h>
#include <dev/usb/uhidev.h>
#include <dev/usb/usbdi_util.h>

#ifdef UPD_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

#define DEVNAME(sc)	((sc)->sc_hdev.sc_dev.dv_xname)

struct upd_usage_entry {
	uint8_t			usage_pg;
	uint8_t			usage_id;
	enum sensor_type	senstype;
	char			*usage_name; /* sensor string */
	int			nchildren;
	struct upd_usage_entry	*children;
};

static struct upd_usage_entry upd_usage_batdep[] = {
	{ HUP_BATTERY,	HUB_REL_STATEOF_CHARGE,
	    SENSOR_PERCENT,	 "RelativeStateOfCharge" },
	{ HUP_BATTERY,	HUB_ABS_STATEOF_CHARGE,
	    SENSOR_PERCENT,	 "AbsoluteStateOfCharge" },
	{ HUP_BATTERY,	HUB_REM_CAPACITY,
	    SENSOR_PERCENT,	 "RemainingCapacity" },
	{ HUP_BATTERY,	HUB_FULLCHARGE_CAPACITY,
	    SENSOR_PERCENT,	 "FullChargeCapacity" },
	{ HUP_BATTERY,	HUB_CHARGING,
	    SENSOR_INDICATOR,	 "Charging" },
	{ HUP_BATTERY,	HUB_DISCHARGING,
	    SENSOR_INDICATOR,	 "Discharging" },
	{ HUP_BATTERY,	HUB_ATRATE_TIMETOFULL,
	    SENSOR_TIMEDELTA,	 "AtRateTimeToFull" },
	{ HUP_BATTERY,	HUB_ATRATE_TIMETOEMPTY,
	    SENSOR_TIMEDELTA,	 "AtRateTimeToEmpty" },
	{ HUP_BATTERY,	HUB_RUNTIMETO_EMPTY,
	    SENSOR_TIMEDELTA,	 "RunTimeToEmpty" },
	{ HUP_BATTERY,	HUB_NEED_REPLACEMENT,
	    SENSOR_INDICATOR,	 "NeedReplacement" },
};
static struct upd_usage_entry upd_usage_roots[] = {
	{ HUP_BATTERY,	HUB_BATTERY_PRESENT,
	    SENSOR_INDICATOR,	 "BatteryPresent",
	    nitems(upd_usage_batdep),	upd_usage_batdep },
	{ HUP_POWER,	HUP_SHUTDOWN_IMMINENT,
	    SENSOR_INDICATOR,	 "ShutdownImminent" },
	{ HUP_BATTERY,	HUB_AC_PRESENT,
	    SENSOR_INDICATOR,	 "ACPresent" },
	{ HUP_POWER,	HUP_OVERLOAD,
	    SENSOR_INDICATOR,	 "Overload" },
};
#define UPD_MAX_SENSORS	(nitems(upd_usage_batdep) + nitems(upd_usage_roots))

SLIST_HEAD(upd_sensor_head, upd_sensor);

struct upd_report {
	size_t			size;		/* Size of the report */
	struct upd_sensor_head	sensors;	/* List in dependency order */
	int			pending;	/* Waiting for an answer */
};

struct upd_sensor {
	struct ksensor		ksensor;
	struct hid_item		hitem;
	int			attached;	/* Is there a matching report */
	struct upd_sensor_head	children;	/* list of children sensors */
	SLIST_ENTRY(upd_sensor)	dep_next;	/* next in the child list */
	SLIST_ENTRY(upd_sensor)	rep_next;	/* next in the report list */
};

struct upd_softc {
	struct uhidev		 sc_hdev;
	int			 sc_num_sensors;
	u_int			 sc_max_repid;
	char			 sc_buf[256];

	/* sensor framework */
	struct ksensordev	 sc_sensordev;
	struct sensor_task	*sc_sensortask;
	struct upd_report	*sc_reports;
	struct upd_sensor	*sc_sensors;
	struct upd_sensor_head	 sc_root_sensors;
};

int  upd_match(struct device *, void *, void *);
void upd_attach(struct device *, struct device *, void *);
void upd_attach_sensor_tree(struct upd_softc *, void *, int, int,
    struct upd_usage_entry *, struct upd_sensor_head *);
int  upd_detach(struct device *, int);

void upd_intr(struct uhidev *, void *, uint);
void upd_refresh(void *);
void upd_request_children(struct upd_softc *, struct upd_sensor_head *);
void upd_update_report_cb(void *, int, void *, int);

void upd_sensor_invalidate(struct upd_softc *, struct upd_sensor *);
void upd_sensor_update(struct upd_softc *, struct upd_sensor *, uint8_t *, int);
int upd_lookup_usage_entry(void *, int, struct upd_usage_entry *,
    struct hid_item *);
struct upd_sensor *upd_lookup_sensor(struct upd_softc *, int, int);

struct cfdriver upd_cd = {
	NULL, "upd", DV_DULL
};

const struct cfattach upd_ca = {
	sizeof(struct upd_softc), upd_match, upd_attach, upd_detach
};

int
upd_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	int			  size;
	void			 *desc;
	struct hid_item		  item;
	int			  ret = UMATCH_NONE;
	int			  i;

	if (uha->reportid != UHIDEV_CLAIM_ALLREPORTID)
		return (ret);

	DPRINTF(("upd: vendor=0x%04x, product=0x%04x\n", uha->uaa->vendor,
	    uha->uaa->product));

	/* need at least one sensor from root of tree */
	uhidev_get_report_desc(uha->parent, &desc, &size);
	for (i = 0; i < nitems(upd_usage_roots); i++)
		if (upd_lookup_usage_entry(desc, size,
		    upd_usage_roots + i, &item)) {
			ret = UMATCH_VENDOR_PRODUCT;
			break;
		}

	return (ret);
}

void
upd_attach(struct device *parent, struct device *self, void *aux)
{
	struct upd_softc	 *sc = (struct upd_softc *)self;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	int			  size;
	int			  i;
	void			 *desc;

	sc->sc_hdev.sc_intr = upd_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	SLIST_INIT(&sc->sc_root_sensors);

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_max_repid = uha->parent->sc_nrepid;
	DPRINTF(("\nupd: devname=%s sc_max_repid=%d\n",
	    DEVNAME(sc), sc->sc_max_repid));

	sc->sc_reports = mallocarray(sc->sc_max_repid,
	    sizeof(struct upd_report), M_USBDEV, M_WAITOK | M_ZERO);
	for (i = 0; i < sc->sc_max_repid; i++)
		SLIST_INIT(&sc->sc_reports[i].sensors);
	sc->sc_sensors = mallocarray(UPD_MAX_SENSORS,
	    sizeof(struct upd_sensor), M_USBDEV, M_WAITOK | M_ZERO);
	for (i = 0; i < UPD_MAX_SENSORS; i++)
		SLIST_INIT(&sc->sc_sensors[i].children);

	sc->sc_num_sensors = 0;
	uhidev_get_report_desc(uha->parent, &desc, &size);
	upd_attach_sensor_tree(sc, desc, size, nitems(upd_usage_roots),
	    upd_usage_roots, &sc->sc_root_sensors);
	DPRINTF(("upd: sc_num_sensors=%d\n", sc->sc_num_sensors));

	sc->sc_sensortask = sensor_task_register(sc, upd_refresh, 6);
	if (sc->sc_sensortask == NULL) {
		printf(", unable to register update task\n");
		return;
	}
	sensordev_install(&sc->sc_sensordev);

	printf("\n");

	DPRINTF(("upd_attach: complete\n"));
}

void
upd_attach_sensor_tree(struct upd_softc *sc, void *desc, int size,
    int nentries, struct upd_usage_entry *entries,
    struct upd_sensor_head *queue)
{
	struct hid_item		  item;
	struct upd_usage_entry	 *entry;
	struct upd_sensor	 *sensor;
	struct upd_report	 *report;
	int			  i;

	for (i = 0; i < nentries; i++) {
		entry = entries + i;
		if (!upd_lookup_usage_entry(desc, size, entry, &item)) {
			/* dependency missing, add children to parent */
			upd_attach_sensor_tree(sc, desc, size,
			    entry->nchildren, entry->children, queue);
			continue;
		}

		DPRINTF(("%s: found %s on repid=%d\n", DEVNAME(sc),
		    entry->usage_name, item.report_ID));
		if (item.report_ID < 0 ||
		    item.report_ID >= sc->sc_max_repid)
			continue;

		sensor = &sc->sc_sensors[sc->sc_num_sensors];
		memcpy(&sensor->hitem, &item, sizeof(struct hid_item));
		strlcpy(sensor->ksensor.desc, entry->usage_name,
		    sizeof(sensor->ksensor.desc));
		sensor->ksensor.type = entry->senstype;
		sensor->ksensor.flags |= SENSOR_FINVALID;
		sensor->ksensor.status = SENSOR_S_UNKNOWN;
		sensor->ksensor.value = 0;
		sensor_attach(&sc->sc_sensordev, &sensor->ksensor);
		sensor->attached = 1;
		SLIST_INSERT_HEAD(queue, sensor, dep_next);
		sc->sc_num_sensors++;

		upd_attach_sensor_tree(sc, desc, size, entry->nchildren,
		    entry->children, &sensor->children);

		report = &sc->sc_reports[item.report_ID];
		if (SLIST_EMPTY(&report->sensors))
			report->size = hid_report_size(desc,
			    size, item.kind, item.report_ID);
		SLIST_INSERT_HEAD(&report->sensors, sensor, rep_next);
	}
}

int
upd_detach(struct device *self, int flags)
{
	struct upd_softc	*sc = (struct upd_softc *)self;
	struct upd_sensor	*sensor;
	int			 i;

	if (sc->sc_sensortask != NULL)
		sensor_task_unregister(sc->sc_sensortask);

	sensordev_deinstall(&sc->sc_sensordev);

	for (i = 0; i < sc->sc_num_sensors; i++) {
		sensor = &sc->sc_sensors[i];
		if (sensor->attached)
			sensor_detach(&sc->sc_sensordev, &sensor->ksensor);
	}

	free(sc->sc_reports, M_USBDEV, sc->sc_max_repid * sizeof(struct upd_report));
	free(sc->sc_sensors, M_USBDEV, UPD_MAX_SENSORS * sizeof(struct upd_sensor));
	return (0);
}

void
upd_refresh(void *arg)
{
	struct upd_softc	*sc = arg;
	int			 s;

	/* request root sensors, do not let async handlers fire yet */
	s = splusb();
	upd_request_children(sc, &sc->sc_root_sensors);
	splx(s);
}

void
upd_request_children(struct upd_softc *sc, struct upd_sensor_head *queue)
{
	struct upd_sensor	*sensor;
	struct upd_report	*report;
	int			 len, repid;

	SLIST_FOREACH(sensor, queue, dep_next) {
		repid = sensor->hitem.report_ID;
		report = &sc->sc_reports[repid];

		/* already requested */
		if (report->pending)
			continue;
		report->pending = 1;

		len = uhidev_get_report_async(sc->sc_hdev.sc_parent,
		    UHID_FEATURE_REPORT, repid, sc->sc_buf, report->size, sc,
		    upd_update_report_cb);

		/* request failed, force-invalidate all sensors in report */
		if (len < 0) {
			upd_update_report_cb(sc, repid, NULL, -1);
			report->pending = 0;
		}
	}
}

int
upd_lookup_usage_entry(void *desc, int size, struct upd_usage_entry *entry,
    struct hid_item *item)
{
	struct hid_data	*hdata;
	int 		 ret = 0;

	for (hdata = hid_start_parse(desc, size, hid_feature);
	     hid_get_item(hdata, item); ) {
		if (item->kind == hid_feature &&
		    entry->usage_pg == HID_GET_USAGE_PAGE(item->usage) &&
		    entry->usage_id == HID_GET_USAGE(item->usage)) {
			ret = 1;
			break;
		}
	}
	hid_end_parse(hdata);

	return (ret);
}

struct upd_sensor *
upd_lookup_sensor(struct upd_softc *sc, int page, int usage)
{
	struct upd_sensor	*sensor = NULL;
	int			 i;

	for (i = 0; i < sc->sc_num_sensors; i++) {
		sensor = &sc->sc_sensors[i];
		if (page == HID_GET_USAGE_PAGE(sensor->hitem.usage) &&
		    usage == HID_GET_USAGE(sensor->hitem.usage))
			return (sensor);
	}
	return (NULL);
}

void
upd_update_report_cb(void *priv, int repid, void *data, int len)
{
	struct upd_softc	*sc = priv;
	struct upd_report	*report = &sc->sc_reports[repid];
	struct upd_sensor	*sensor;

	/* handle buggy firmware */
	if (len > 0 && report->size != len)
		report->size = len;

	if (data == NULL || len <= 0) {
		SLIST_FOREACH(sensor, &report->sensors, rep_next)
			upd_sensor_invalidate(sc, sensor);
	} else {
		SLIST_FOREACH(sensor, &report->sensors, rep_next)
			upd_sensor_update(sc, sensor, data, len);
	}
	report->pending = 0;
}

void
upd_sensor_invalidate(struct upd_softc *sc, struct upd_sensor *sensor)
{
	struct upd_sensor	*child;

	sensor->ksensor.status = SENSOR_S_UNKNOWN;
	sensor->ksensor.flags |= SENSOR_FINVALID;

	SLIST_FOREACH(child, &sensor->children, dep_next)
		upd_sensor_invalidate(sc, child);
}

void
upd_sensor_update(struct upd_softc *sc, struct upd_sensor *sensor,
    uint8_t *buf, int len)
{
	struct upd_sensor	*child;
	int64_t			 hdata, adjust;

	switch (HID_GET_USAGE(sensor->hitem.usage)) {
	case HUB_REL_STATEOF_CHARGE:
	case HUB_ABS_STATEOF_CHARGE:
	case HUB_REM_CAPACITY:
	case HUB_FULLCHARGE_CAPACITY:
		adjust = 1000; /* scale adjust */
		break;
	case HUB_ATRATE_TIMETOFULL:
	case HUB_ATRATE_TIMETOEMPTY:
	case HUB_RUNTIMETO_EMPTY:
		/* spec says minutes, not seconds */
		adjust = 1000000000LL;
		break;
	default:
		adjust = 1; /* no scale adjust */
		break;
	}

	hdata = hid_get_data(buf, len, &sensor->hitem.loc);
	sensor->ksensor.value = hdata * adjust;
	sensor->ksensor.status = SENSOR_S_OK;
	sensor->ksensor.flags &= ~SENSOR_FINVALID;

	/* if battery not present, invalidate children */
	if (HID_GET_USAGE_PAGE(sensor->hitem.usage) == HUP_BATTERY &&
	    HID_GET_USAGE(sensor->hitem.usage) == HUB_BATTERY_PRESENT &&
	    sensor->ksensor.value == 0) {
		SLIST_FOREACH(child, &sensor->children, dep_next)
			upd_sensor_invalidate(sc, child);
		return;
	}

	upd_request_children(sc, &sensor->children);
}

void
upd_intr(struct uhidev *uh, void *p, uint len)
{
	/* noop */
}
@


1.25
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.24 2016/01/08 15:54:14 jcs Exp $ */
a183 2
	sc->sc_reports = NULL;
	sc->sc_sensors = NULL;
d288 2
a289 2
	free(sc->sc_reports, M_USBDEV, 0);
	free(sc->sc_sensors, M_USBDEV, 0);
@


1.24
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.23 2015/10/01 14:03:44 mpi Exp $ */
a35 2

#include <dev/hid/hid.h>
@


1.23
log
@No need to wakeup(9) the sensor thread because upd_refresh() does not
sleep.

Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.22 2015/06/17 08:31:55 mpi Exp $ */
a29 1
#include <dev/usb/hid.h>
d36 2
@


1.22
log
@Four new sensors, from David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.21 2015/05/14 13:50:34 mpi Exp $ */
d280 1
a280 2
	if (sc->sc_sensortask != NULL) {
		wakeup(&sc->sc_sensortask);
a281 1
	}
@


1.21
log
@Make the "Battery Present" sensor a depency of all the battery-related
sensors only if it is present, From David Higgs.

Fix a regression reported by and ok halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.20 2015/05/11 08:51:31 mpi Exp $ */
d69 7
a75 1
	    SENSOR_TIMEDELTA,	 "AtRateTimeToFull" }
d84 3
a86 1
	    SENSOR_INDICATOR,	 "ACPresent" }
d420 6
@


1.20
log
@Refresh sensor values asynchronously.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.19 2015/04/30 10:09:31 mpi Exp $ */
d228 4
a231 1
		if (!upd_lookup_usage_entry(desc, size, entry, &item))
d233 1
@


1.19
log
@Link report descriptors to known sensors.

Since HID buffers always start by a reportID we can access the corresponding
report descriptor in O(1).  Having a list of sensors attached to each report
descriptor makes it easier to update all of them with only on I/O request.

Note that sensors are attached in depency order on every report list.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.18 2015/04/30 10:00:50 mpi Exp $ */
d4 1
d82 2
d85 3
a87 2
	size_t				size;
	SLIST_HEAD(, upd_sensor)	sensors;
a89 1
SLIST_HEAD(upd_sensor_head, upd_sensor);
d91 6
a96 6
	struct ksensor			ksensor;
	struct hid_item			hitem;
	int				attached;
	struct upd_sensor_head		children;
	SLIST_ENTRY(upd_sensor)		dep_next;
	SLIST_ENTRY(upd_sensor)		rep_next;
d103 1
d119 1
d121 5
a125 4
void upd_update_sensors(struct upd_softc *, uint8_t *, unsigned int, int);
void upd_update_sensor_value(struct upd_softc *, struct upd_sensor *,
    uint8_t *, int);
void upd_intr(struct uhidev *, void *, uint);
d135 1
a135 4
	sizeof(struct upd_softc),
	upd_match,
	upd_attach,
	upd_detach
a278 1
		DPRINTF(("upd_detach: %s\n", sensor->ksensor.desc));
a282 1
	DPRINTF(("upd_detach: complete\n"));
d289 13
a301 1
	struct upd_softc	*sc = (struct upd_softc *)arg;
d303 1
a303 2
	uint8_t			buf[256];
	int			repid, actlen;
d305 2
a306 1
	for (repid = 0; repid < sc->sc_max_repid; repid++) {
d308 3
a310 1
		if (SLIST_EMPTY(&report->sensors))
d312 1
d314 8
a321 7
		memset(buf, 0x0, sizeof(buf));
		actlen = uhidev_get_report(sc->sc_hdev.sc_parent,
		    UHID_FEATURE_REPORT, repid, buf, report->size);

		if (actlen == -1) {
			DPRINTF(("upd: failed to get report id=%02x\n", repid));
			continue;
a322 6

		/* Deal with buggy firmwares. */
		if (actlen < report->size)
			report->size = actlen;

		upd_update_sensors(sc, buf, report->size, repid);
d363 1
a363 2
upd_update_sensors(struct upd_softc *sc, uint8_t *buf, unsigned int len,
    int repid)
d365 2
a367 2
	ulong			batpres;
	int			i;
d369 13
a381 2
	sensor = upd_lookup_sensor(sc, HUP_BATTERY, HUB_BATTERY_PRESENT);
	batpres = sensor ? sensor->ksensor.value : -1;
d383 4
a386 4
	for (i = 0; i < sc->sc_num_sensors; i++) {
		sensor = &sc->sc_sensors[i];
		if (!(sensor->hitem.report_ID == repid && sensor->attached))
			continue;
d388 2
a389 11
		/* invalidate battery dependent sensors */
		if (HID_GET_USAGE_PAGE(sensor->hitem.usage) == HUP_BATTERY &&
		    batpres <= 0) {
			/* exception to the battery sensor itself */
			if (HID_GET_USAGE(sensor->hitem.usage) !=
			    HUB_BATTERY_PRESENT) {
				sensor->ksensor.status = SENSOR_S_UNKNOWN;
				sensor->ksensor.flags |= SENSOR_FINVALID;
				continue;
			}
		}
d391 2
a392 2
		upd_update_sensor_value(sc, sensor, buf, len);
	}
d396 1
a396 1
upd_update_sensor_value(struct upd_softc *sc, struct upd_sensor *sensor,
d399 2
a400 1
	int64_t	hdata, adjust;
d418 11
a428 2
	DPRINTF(("%s: %s hidget data: %lld\n", DEVNAME(sc),
	    sensor->ksensor.desc, hdata));
@


1.18
log
@Instead of using a single flat array for all sensors, put all the
children of a sensor in a separate structure.

Children sensors should only be probbed if their parent is active.
This make the dependency tree explicit and will reduce the number
of I/O.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.17 2015/04/27 09:14:45 mpi Exp $ */
d82 2
a83 2
	size_t		size;
	int		enabled;
d93 1
d187 2
d220 1
d250 5
a254 5
		if (sc->sc_reports[item.report_ID].enabled)
			continue;
		sc->sc_reports[item.report_ID].size = hid_report_size(desc,
		    size, item.kind, item.report_ID);
		sc->sc_reports[item.report_ID].enabled = 1;
d295 1
a295 1
		if (!report->enabled)
@


1.17
log
@Since upd(4) currently supports a known but limited number of sensors,
parse the HID descriptor multiple times to find them.

This logic is necessary to later create a tree of sensors in order to
avoid lookups in the hot path for sensors that depend on the value of
others.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.16 2015/04/27 07:41:41 mpi Exp $ */
d26 1
d50 2
d54 1
a54 1
static struct upd_usage_entry upd_usage_table[] = {
d67 4
d72 2
a73 1
	    SENSOR_INDICATOR,	 "BatteryPresent" },
d77 1
a77 3
	    SENSOR_INDICATOR,	 "ACPresent" },
	{ HUP_BATTERY,	HUB_ATRATE_TIMETOFULL,
	    SENSOR_TIMEDELTA,	 "AtRateTimeToFull" }
d79 1
d86 1
d88 5
a92 3
	struct ksensor		ksensor;
	struct hid_item		hitem;
	int			attached;
d105 1
d110 2
d150 1
a150 3
	/*
	 * look for at least one sensor of our table
	 */
d152 1
a152 1
	for (i = 0; i < nitems(upd_usage_table); i++)
d154 1
a154 1
		    upd_usage_table + i, &item)) {
a166 3
	struct hid_item		  item;
	struct upd_usage_entry	 *entry;
	struct upd_sensor	 *sensor;
d175 1
d186 1
a186 1
	sc->sc_sensors = mallocarray(nitems(upd_usage_table),
d188 3
d192 16
d209 12
a220 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	for (i = 0; i < nitems(upd_usage_table); i++) {
		entry = &upd_usage_table[i];
d240 1
d243 3
a247 1

a251 12
	DPRINTF(("upd: sc_num_sensors=%d\n", sc->sc_num_sensors));

	sc->sc_sensortask = sensor_task_register(sc, upd_refresh, 6);
	if (sc->sc_sensortask == NULL) {
		printf(", unable to register update task\n");
		return;
	}
	sensordev_install(&sc->sc_sensordev);

	printf("\n");

	DPRINTF(("upd_attach: complete\n"));
@


1.16
log
@
with more unit convertion when new sensors will appear.

From David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.15 2015/04/27 07:37:19 mpi Exp $ */
a88 1
	u_int			 sc_max_sensors;
d106 2
a107 1
struct upd_usage_entry *upd_lookup_usage_entry(const struct hid_item *);
a126 1
	struct hid_data		 *hdata;
d129 1
d141 3
a143 3
	for (hdata = hid_start_parse(desc, size, hid_feature);
	     hid_get_item(hdata, &item); ) {
		if (upd_lookup_usage_entry(&item) != NULL) {
a146 2
	}
	hid_end_parse(hdata);
a156 1
	struct hid_data		 *hdata;
d160 1
a166 1
	sc->sc_max_sensors = nitems(upd_usage_table);
d177 1
a177 1
	sc->sc_sensors = mallocarray(sc->sc_max_sensors,
a178 1
	size = sc->sc_max_sensors * sizeof(struct upd_sensor);
d180 1
d182 3
a184 7
	for (hdata = hid_start_parse(desc, size, hid_feature);
	     hid_get_item(hdata, &item) &&
	     sc->sc_num_sensors < sc->sc_max_sensors; ) {
		DPRINTF(("upd: repid=%d\n", item.report_ID));
		if (item.kind != hid_feature ||
		    item.report_ID < 0 ||
		    item.report_ID >= sc->sc_max_repid)
d187 4
a190 7
		if ((entry = upd_lookup_usage_entry(&item)) == NULL)
			continue;

		/* filter repeated usages, avoid duplicated sensors */
		sensor = upd_lookup_sensor(sc, entry->usage_pg,
		    entry->usage_id);
		if (sensor != NULL)
a211 1
	hid_end_parse(hdata);
d283 3
a285 2
struct upd_usage_entry *
upd_lookup_usage_entry(const struct hid_item *hitem)
d287 2
a288 2
	struct upd_usage_entry	*entry = NULL;
	int			 i;
d290 8
a297 5
	for (i = 0; i < nitems(upd_usage_table); i++) {
		entry = &upd_usage_table[i];
		if (entry->usage_pg == HID_GET_USAGE_PAGE(hitem->usage) &&
		    entry->usage_id == HID_GET_USAGE(hitem->usage))
			return (entry);
d299 3
a301 1
	return (NULL);
@


1.15
log
@Make use of DEVNAME(), from David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.14 2015/04/01 11:44:44 mpi Exp $ */
d104 2
d329 1
a329 2
	ulong			hdata, batpres;
	ulong 			adjust;
d352 3
a354 11
		switch (HID_GET_USAGE(sensor->hitem.usage)) {
		case HUB_REL_STATEOF_CHARGE:
		case HUB_ABS_STATEOF_CHARGE:
		case HUB_REM_CAPACITY:
		case HUB_FULLCHARGE_CAPACITY:
			adjust = 1000; /* scale adjust */
			break;
		default:
			adjust = 1; /* no scale adjust */
			break;
		}
d356 5
a360 1
		hdata = hid_get_data(buf, len, &sensor->hitem.loc);
d362 10
a371 4
		sensor->ksensor.value = hdata * adjust;
		sensor->ksensor.status = SENSOR_S_OK;
		sensor->ksensor.flags &= ~SENSOR_FINVALID;
		DPRINTF(("%s: hidget data: %lu\n", DEVNAME(sc), hdata));
d373 7
a380 1

@


1.14
log
@Small cleanups when attaching sensors, from David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.13 2015/01/11 03:08:38 deraadt Exp $ */
d42 2
d169 1
a169 1
	strlcpy(sc->sc_sensordev.xname, sc->sc_hdev.sc_dev.dv_xname,
d174 1
a174 1
	    sc->sc_hdev.sc_dev.dv_xname, sc->sc_max_repid));
d368 1
a368 2
		DPRINTF(("%s: hidget data: %lu\n",
		    sc->sc_sensordev.xname, hdata));
@


1.13
log
@use mallocarray(), then set the size afterwards.  Prefer if people learn
and use this idiom everywhere, it is always safest.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.12 2014/12/11 18:50:32 mpi Exp $ */
d186 2
a187 1
		    item.report_ID < 0)
d196 1
a196 1
		if (sensor && sensor->attached)
a199 1
		/* keep our copy of hid_item */
d211 1
a211 2
		if (item.report_ID >= sc->sc_max_repid ||
		    sc->sc_reports[item.report_ID].enabled)
@


1.12
log
@Handle UPSes with broken report descriptors.

As reported by David Higgs some UPSes might send fewer bytes than
requested.  When such thing happens, do like apcupsd and adjust
the size of the given descriptor.

Based on a diff provided by David Higgs, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.11 2014/12/11 18:39:27 mpi Exp $ */
d174 4
a177 2
	sc->sc_reports = malloc(sc->sc_max_repid * sizeof(struct upd_report),
	    M_USBDEV, M_WAITOK | M_ZERO);
a178 1
	sc->sc_sensors = malloc(size, M_USBDEV, M_WAITOK | M_ZERO);
@


1.11
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.10 2014/07/12 18:48:52 tedu Exp $ */
d277 1
a277 1
		if (actlen != report->size) {
d281 4
@


1.10
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.9 2014/05/12 09:50:44 mpi Exp $ */
d266 1
a266 1
	int			repid, err;
d274 5
a278 9
		/*
		 * XXX uhidev_get_report() is not clever enough to handle
		 * non-NUl reportID, so add an extra byte for it.
		 */
		err = uhidev_get_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
		    repid, buf, report->size + 1);
		if (err) {
			DPRINTF(("read failure: reportid=%02x err=%d\n", repid,
			    err));
d357 1
a357 2
		/* XXX first byte which is the report id */
		hdata = hid_get_data(buf + 1, len, &sensor->hitem.loc);
d362 1
a362 1
		DPRINTF(("%s: hidget data: %d\n",
@


1.9
log
@Backport FreeBSD's HID parser in order to properly parse `moderm'
input device descriptors, notably if they include an Item with an
Usage array (Min-Max range) and others single Usage elements.

Tested by many, thanks!  ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.8 2014/04/29 07:23:40 andre Exp $ */
d254 2
a255 2
	free(sc->sc_reports, M_USBDEV);
	free(sc->sc_sensors, M_USBDEV);
@


1.8
log
@Remove device white-listing as matching method, relies on on usage id
versus supported sensors table filtering.

discussed with and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.7 2014/04/15 09:14:27 mpi Exp $ */
d101 1
a101 1
void upd_update_sensors(struct upd_softc *, uint8_t *, int);
d286 1
a286 1
		upd_update_sensors(sc, buf, repid);
d321 2
a322 1
upd_update_sensors(struct upd_softc *sc, uint8_t *buf, int repid)
a324 1
	struct hid_location	*loc;
d361 2
a362 3
		loc = &sensor->hitem.loc;
		/* first byte which is the report id */
		hdata = hid_get_data(buf + 1, loc);
@


1.7
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.6 2014/04/07 21:54:13 andre Exp $ */
a95 33
static const struct usb_devno upd_devs[] = {
	{ USB_VENDOR_APC, USB_PRODUCT_APC_UPS },
	{ USB_VENDOR_APC, USB_PRODUCT_APC_UPS5G },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C100 },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C1100 },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C120 },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C1250EITWRK },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C1500EITWRK },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C550AVR },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C800 },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6C900 },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F6H375 },
	{ USB_VENDOR_CYBERPOWER, USB_PRODUCT_CYBERPOWER_1500 },
	{ USB_VENDOR_CYBERPOWER, USB_PRODUCT_CYBERPOWER_OR2200 },
	{ USB_VENDOR_CYBERPOWER, USB_PRODUCT_CYBERPOWER_UPS },
	{ USB_VENDOR_DELL2, USB_PRODUCT_DELL2_UPS },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_R1500G2 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_RT2200 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_T1000 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_T1500 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_T750 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_T750G2 },
	{ USB_VENDOR_IDOWELL, USB_PRODUCT_IDOWELL_IDOWELL },
	{ USB_VENDOR_LIEBERT, USB_PRODUCT_LIEBERT_UPS },
	{ USB_VENDOR_LIEBERT2, USB_PRODUCT_LIEBERT2_PSA },
	{ USB_VENDOR_MGE, USB_PRODUCT_MGE_UPS1 },
	{ USB_VENDOR_MGE, USB_PRODUCT_MGE_UPS2 },
	{ USB_VENDOR_OMRON, USB_PRODUCT_OMRON_BX35F },
	{ USB_VENDOR_OMRON, USB_PRODUCT_OMRON_BX50F },
	{ USB_VENDOR_OMRON, USB_PRODUCT_OMRON_BY35S }
};
#define upd_lookup(v, p) usb_lookup(upd_devs, v, p)

a129 3
	if (upd_lookup(uha->uaa->vendor, uha->uaa->product) == NULL)
		return (ret);

d134 1
a134 1
	 * look for at least one sensor of our table, otherwise do not attach
@


1.6
log
@- Remove a enumerator for supported sensors, makes better usage of our usb api;
- Allocate/enable sensors wich match both: the static usage table of supported
  usage IDs and the usages supported by the device;
- Do not attach when no sensors can be allocated;
- Makes device querying smarter: query the device just once for values stored
  in the same reportid reply payload.
- Use sensor_status.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.5 2014/03/20 13:07:01 andre Exp $ */
d310 6
a315 8
		sc->sc_hdev.sc_report_id = repid;
		err = uhidev_get_report(&sc->sc_hdev, UHID_FEATURE_REPORT, buf,
		    report->size + 1); /*
					* cheating with an extra byte on size
					* here, hid_report_size() * is
					* incorrectly telling us report lengths
					* are 1 byte smaller
					*/
@


1.5
log
@Add several devices we already have defined in usbdevs and are also known to be
UPSes.

(forced commit due to previous empty commit message)

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.4 2014/03/20 12:50:49 andre Exp $ */
a41 21
enum upd_sensor_id {
	UPD_SENSOR_UNKNOWN,
	UPD_SENSOR_RELCHARGE,
	UPD_SENSOR_ABSCHARGE,
	UPD_SENSOR_REMCAPACI,
	UPD_SENSOR_FULLCHARG,
	UPD_SENSOR_CHARGING,
	UPD_SENSOR_DISCHARG,
	UPD_SENSOR_BATTPRESENT,
	UPD_SENSOR_SHUTIMMINENT,
	UPD_SENSOR_ACPRESENT,
	UPD_SENSOR_TIMETOFULL,
	UPD_SENSOR_NUM
	/*
	 * TODO
	 * - atratetimetofull
	 * - atratetimetoempty
	 * - cyclecount
	 */
};

a42 1
	enum upd_sensor_id	upd_sid;
d49 2
a50 4
static struct upd_usage_entry upd_usage_table[UPD_SENSOR_NUM] = {
	{ UPD_SENSOR_UNKNOWN,	  HUP_UNDEFINED,HUP_UNDEFINED,
	    -1,			 "unknown" },
	{ UPD_SENSOR_RELCHARGE,	  HUP_BATTERY,	HUB_REL_STATEOF_CHARGE,
d52 1
a52 1
	{ UPD_SENSOR_ABSCHARGE,	  HUP_BATTERY,	HUB_ABS_STATEOF_CHARGE,
d54 1
a54 1
	{ UPD_SENSOR_REMCAPACI,	  HUP_BATTERY,	HUB_REM_CAPACITY,
d56 1
a56 1
	{ UPD_SENSOR_FULLCHARG,	  HUP_BATTERY,	HUB_FULLCHARGE_CAPACITY,
d58 1
a58 1
	{ UPD_SENSOR_CHARGING,	  HUP_BATTERY,	HUB_CHARGING,
d60 1
a60 1
	{ UPD_SENSOR_DISCHARG,	  HUP_BATTERY,	HUB_DISCHARGING,
d62 1
a62 1
	{ UPD_SENSOR_BATTPRESENT, HUP_BATTERY,	HUB_BATTERY_PRESENT,
d64 1
a64 1
	{ UPD_SENSOR_SHUTIMMINENT,HUP_POWER,	HUP_SHUTDOWN_IMMINENT,
d66 1
a66 1
	{ UPD_SENSOR_ACPRESENT,	  HUP_BATTERY,	HUB_AC_PRESENT,
d68 1
a68 1
	{ UPD_SENSOR_TIMETOFULL,  HUP_BATTERY,	HUB_ATRATE_TIMETOFULL,
d72 5
d78 2
a80 3
	struct ksensor		sensor;
	struct hid_item		item;
	size_t			flen;
d86 2
a89 1
	struct upd_sensor	 sc_sensors[UPD_SENSOR_NUM];
d92 2
a132 1
void upd_add_sensor(struct upd_softc *, const struct hid_item *, void *, int);
d134 1
d136 2
d154 5
d161 1
a161 1
		return (UMATCH_NONE);
d164 1
a164 1
		return (UMATCH_NONE);
d166 1
a166 1
	DPRINTF(("upd: vendor=0x%x, product=0x%x\n", uha->uaa->vendor,
d169 14
a182 1
	return (UMATCH_VENDOR_PRODUCT);
d192 2
d199 3
a201 1
	sc->sc_num_sensors = 0;
d206 39
a244 2
	DPRINTF(("upd: devname=%s sc_nrepid=%d\n", sc->sc_hdev.sc_dev.dv_xname,
	    uha->parent->sc_nrepid));
d246 3
a248 5
	uhidev_get_report_desc(uha->parent, &desc, &size);
	hdata = hid_start_parse(desc, size, hid_feature);
	/* lookup for item in our sensors list */
	while (hid_get_item(hdata, &item))
		upd_add_sensor(sc, &item, desc, size);
d250 4
d257 4
a260 7
	if (sc->sc_num_sensors > 0) {
		sc->sc_sensortask = sensor_task_register(sc, upd_refresh, 6);
		if (sc->sc_sensortask == NULL) {
			printf(", unable to register update task\n");
			return;
		}
		sensordev_install(&sc->sc_sensordev);
d262 1
a275 3
	if (sc->sc_num_sensors <= 0)
		goto finish;

d283 1
a283 1
	for (i = 0; i < UPD_SENSOR_NUM; i++) {
d285 3
a287 5
		if (!sensor->attached)
			continue;

		sensor_detach(&sc->sc_sensordev, &sensor->sensor);
		DPRINTF(("upd_detach: %s\n", sensor->sensor.desc));
d290 2
a291 1
finish:
d300 1
a300 4
	struct hid_location	*loc;
	struct upd_sensor	*sensor;
	ulong			hdata;
	ulong 			adjust;
d302 1
a302 1
	int			i, err;
d304 3
a306 3
	for (i = 0; i < UPD_SENSOR_NUM; i++) {
		sensor = &sc->sc_sensors[i];
		if (sensor && !sensor->attached)
a308 26
		switch (i) {
		case UPD_SENSOR_RELCHARGE:
		case UPD_SENSOR_ABSCHARGE:
		case UPD_SENSOR_REMCAPACI:
		case UPD_SENSOR_FULLCHARG:
			adjust = 1000; /* scale adjust */
			/* FALLTHROUGH */
		case UPD_SENSOR_CHARGING:
		case UPD_SENSOR_DISCHARG:
		case UPD_SENSOR_TIMETOFULL:
			/*
			 * don't query nor show battery dependent sensors if no
			 * battery
			 */
			if (sc->sc_sensors[UPD_SENSOR_BATTPRESENT].sensor.value
			    <= 0) {
				sensor->sensor.flags |= SENSOR_FINVALID;
				continue;
			}
			break;
		default:
			adjust = 1; /* no scale adjust */
		}

		loc = &sensor->item.loc;
		sc->sc_hdev.sc_report_id = sensor->item.report_ID;
d310 1
d312 6
a317 1
		    sensor->flen);
d319 2
a320 2
			DPRINTF(("read failure: sens=%02x reportid=%02x "
			    "err=%d\n", i, sc->sc_hdev.sc_report_id, err));
d324 24
a347 1
		hdata = hid_get_data(buf + 1, loc);
d349 5
a353 4
		sensor->sensor.flags &= ~SENSOR_FINVALID;
		sensor->sensor.value = hdata * adjust;
		DPRINTF(("%s: %s: hidget data: %d\n", sc->sc_sensordev.xname,
		    upd_usage_table[i].usage_name, hdata));
d355 1
d359 1
a359 2
upd_add_sensor(struct upd_softc *sc, const struct hid_item *item, void *desc,
    int dsiz)
d361 5
a365 3
	struct upd_usage_entry	*entry = NULL;
	struct upd_sensor	*sensor = NULL;
	int i;
d367 2
a368 6
	for (i = 0; i < UPD_SENSOR_NUM; i++) {
		entry = &upd_usage_table[i];
		if (entry->upd_sid == UPD_SENSOR_UNKNOWN ||
		    entry->usage_pg != HID_GET_USAGE_PAGE(item->usage) ||
		    entry->usage_id != HID_GET_USAGE(item->usage))
			continue;
d370 1
d372 1
a372 1
		if (sensor && sensor->attached)
d375 33
a407 13
		/* keep our copy of hid_item */
		memset(&sensor->item, 0x0, sizeof(struct hid_item));
		memcpy(&sensor->item, item, sizeof(struct hid_item));
		sensor->flen = hid_report_size(desc, dsiz, hid_feature,
		    item->report_ID) + 1;
		strlcpy(sensor->sensor.desc, entry->usage_name,
		    sizeof(sensor->sensor.desc));
		sensor->sensor.type = entry->senstype;
		sensor->sensor.flags |= SENSOR_FINVALID;
		sensor->sensor.value = 0;
		sensor_attach(&sc->sc_sensordev, &sensor->sensor);
		sensor->attached = 1;
		sc->sc_num_sensors++;
d410 1
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.3 2014/03/19 16:34:34 andre Exp $ */
@


1.3
log
@When BatteryPresent flag is not set, invalidate battery-dependent sensors.

suggested by deraadt@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.2 2014/03/19 16:08:32 deraadt Exp $ */
d116 27
a142 1
	{ USB_VENDOR_LIEBERT, USB_PRODUCT_LIEBERT_UPS }
@


1.2
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: upd.c,v 1.1 2014/03/17 18:40:46 andre Exp $ */
d237 1
d243 1
a243 1
		if (sensor && ! sensor->attached)
d246 24
a274 1

d276 2
a277 2
			DPRINTF(("read failure: sens=%02x reportid=%02x err=%d\n", i,
			    sc->sc_hdev.sc_report_id, err));
a281 11
		switch (i) {
		case UPD_SENSOR_RELCHARGE:
		case UPD_SENSOR_ABSCHARGE:
		case UPD_SENSOR_REMCAPACI:
		case UPD_SENSOR_FULLCHARG:
			if (sc->sc_sensors[UPD_SENSOR_BATTPRESENT].sensor.value)
				hdata *= 1000; /* scale adjust */
			else
				hdata = 0;
			break;
		}
d284 3
a286 4
		sensor->sensor.value = hdata;
		DPRINTF(("%s: %s: hidget data: %d\n",
		    sc->sc_sensordev.xname, upd_usage_table[i].usage_name,
		    hdata));
@


1.1
log
@Add upd(4) to the tree, disabled. Please do not enable it yet.

At this moment upd(4) exposes data from usb-based uninterruptable power systems
(or just USB Power Devices), sysctl(8) sensors (read snmpd(8) friendly), it is
also an "in-base" alternative to other 3rdparty UPS-monitoring software, we
have plans to bring more features.

This is my first "something" into the tree. Lots of thanks:
sthen@@ and blambert@@ are the ones to blame for the idea/challenge.
mpi@@ is the one whom pushed me to get it correct (from uhub -> uhidev).
reyk@@ mentored me on OpenBSD-way with previous iked/relayd experiences.

ok mpi@@, deraadt@@ "get it in".
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d148 1
a148 1
                return (UMATCH_NONE);
@

