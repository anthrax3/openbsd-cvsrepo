head	1.47;
access;
symbols
	OPENBSD_5_6:1.46.0.4
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.35.0.4
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.15.0.2
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.14
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.1.0.2
	OPENBSD_2_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.47
date	2014.12.11.19.44.17;	author tedu;	state dead;
branches;
next	1.46;
commitid	jUSAZlQ30WF1ESM9;

1.46
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.45;
commitid	AGVMSdzbrCHVAlSG;

1.45
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.44;
commitid	OBNa5kfxQ2UXoiIw;

1.44
date	2013.11.07.13.10.43;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.17.09.14.08;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.11.12.36.52;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.31.18.20.22;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.17.17.23.39;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.10.21.41.51;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.10.13.18.10;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.11.03.08.15;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.14.15.19.46;	author jakob;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.04.11.44.24;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.15.17.36.28;	author jakob;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.47
log
@dragonflybsd has added a urio driver. conservation of urios requires
that we delete ours, which isn't actually useful.
ok mpi sthen
@
text
@/*	$OpenBSD: urio.c,v 1.46 2014/07/12 21:24:33 mpi Exp $	*/
/*	$NetBSD: urio.c,v 1.15 2002/10/23 09:14:02 jdolecek Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The inspiration and information for this driver comes from the
 * FreeBSD driver written by Iwasa Kazmi.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/usbdevs.h>
#include <dev/usb/urio.h>

#ifdef URIO_DEBUG
#define DPRINTF(x)	do { if (uriodebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uriodebug>(n)) printf x; } while (0)
int	uriodebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define URIO_CONFIG_NO		1
#define URIO_IFACE_IDX		0

#define	URIO_BSIZE	4096

struct urio_softc {
 	struct device		sc_dev;
	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;

	int			sc_in_addr;
	struct usbd_pipe	*sc_in_pipe;
	int			sc_out_addr;
	struct usbd_pipe	*sc_out_pipe;

	int			sc_refcnt;
};

#define URIOUNIT(n) (minor(n))

#define URIO_RW_TIMEOUT 4000	/* ms */

static const struct usb_devno urio_devs[] = {
	{ USB_VENDOR_DIAMOND, USB_PRODUCT_DIAMOND_RIO500USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO600USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO800USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_PSAPLAY120},
};

int urio_match(struct device *, void *, void *);
void urio_attach(struct device *, struct device *, void *);
int urio_detach(struct device *, int);

struct cfdriver urio_cd = {
	NULL, "urio", DV_DULL
};

const struct cfattach urio_ca = {
	sizeof(struct urio_softc), urio_match, urio_attach, urio_detach
};

int
urio_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	DPRINTFN(50,("urio_match\n"));

	if (uaa->iface != NULL)
		return (UMATCH_NONE);

	return (usb_lookup(urio_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
urio_attach(struct device *parent, struct device *self, void *aux)
{
	struct urio_softc	*sc = (struct urio_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct usbd_device	*dev = uaa->device;
	struct usbd_interface	*iface;
	usbd_status		err;
	usb_endpoint_descriptor_t *ed;
	u_int8_t		epcount;
	int			i;

	DPRINTFN(10,("urio_attach: sc=%p\n", sc));

	err = usbd_set_config_no(dev, URIO_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	err = usbd_device2interface_handle(dev, URIO_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_udev = dev;
	sc->sc_iface = iface;

	epcount = 0;
	(void)usbd_endpoint_count(iface, &epcount);

	sc->sc_in_addr = -1;
	sc->sc_out_addr = -1;
	for (i = 0; i < epcount; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_in_addr = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_out_addr = ed->bEndpointAddress;
		}
	}
	if (sc->sc_in_addr == -1 || sc->sc_out_addr == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		return;
	}

	DPRINTFN(10, ("urio_attach: %p\n", sc->sc_udev));
}

int
urio_detach(struct device *self, int flags)
{
	struct urio_softc *sc = (struct urio_softc *)self;
	int s;
	int maj, mn;

	DPRINTF(("urio_detach: sc=%p flags=%d\n", sc, flags));

	/* Abort all pipes.  Causes processes waiting for transfer to wake. */
	if (sc->sc_in_pipe != NULL) {
		usbd_abort_pipe(sc->sc_in_pipe);
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
	}
	if (sc->sc_out_pipe != NULL) {
		usbd_abort_pipe(sc->sc_out_pipe);
		usbd_close_pipe(sc->sc_out_pipe);
		sc->sc_out_pipe = NULL;
	}

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == urioopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

int
urioopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct urio_softc *sc;
	usbd_status err;

	if (URIOUNIT(dev) >= urio_cd.cd_ndevs)
		return (ENXIO);
	sc = urio_cd.cd_devs[URIOUNIT(dev)];
	if (sc == NULL)
		return (ENXIO);

	DPRINTFN(5, ("urioopen: flag=%d, mode=%d, unit=%d\n",
		     flag, mode, URIOUNIT(dev)));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (sc->sc_in_pipe != NULL)
		return (EBUSY);

	if ((flag & (FWRITE|FREAD)) != (FWRITE|FREAD))
		return (EACCES);

	err = usbd_open_pipe(sc->sc_iface, sc->sc_in_addr, 0, &sc->sc_in_pipe);
	if (err)
		return (EIO);
	err = usbd_open_pipe(sc->sc_iface, sc->sc_out_addr,0,&sc->sc_out_pipe);
	if (err) {
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
		return (EIO);
	}

	return (0);
}

int
urioclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct urio_softc *sc;
	sc = urio_cd.cd_devs[URIOUNIT(dev)];

	DPRINTFN(5, ("urioclose: flag=%d, mode=%d, unit=%d\n",
		     flag, mode, URIOUNIT(dev)));

	if (sc->sc_in_pipe != NULL) {
		usbd_abort_pipe(sc->sc_in_pipe);
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
	}
	if (sc->sc_out_pipe != NULL) {
		usbd_abort_pipe(sc->sc_out_pipe);
		usbd_close_pipe(sc->sc_out_pipe);
		sc->sc_out_pipe = NULL;
	}

	return (0);
}

int
urioread(dev_t dev, struct uio *uio, int flag)
{
	struct urio_softc *sc;
	struct usbd_xfer *xfer;
	usbd_status err;
	void *bufp;
	u_int32_t n;
	int error = 0;

	sc = urio_cd.cd_devs[URIOUNIT(dev)];

	DPRINTFN(5, ("urioread: %d\n", URIOUNIT(dev)));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return (ENOMEM);
	bufp = usbd_alloc_buffer(xfer, URIO_BSIZE);
	if (bufp == NULL) {
		usbd_free_xfer(xfer);
		return (ENOMEM);
	}

	sc->sc_refcnt++;

	while ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {
		DPRINTFN(1, ("urioread: start transfer %d bytes\n", n));
		usbd_setup_xfer(xfer, sc->sc_in_pipe, 0, bufp, n,
		    USBD_NO_COPY | USBD_SYNCHRONOUS, URIO_RW_TIMEOUT, NULL);
		err = usbd_transfer(xfer);
		if (err) {
			usbd_clear_endpoint_stall(sc->sc_in_pipe);
			if (err == USBD_TIMEOUT)
				error = ETIMEDOUT;
			else
				error = EIO;
			break;
		}

		DPRINTFN(1, ("urioread: got %d bytes\n", n));

		error = uiomove(bufp, n, uio);
		if (error)
			break;
	}
	usbd_free_xfer(xfer);

	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
uriowrite(dev_t dev, struct uio *uio, int flag)
{
	struct urio_softc *sc;
	struct usbd_xfer *xfer;
	usbd_status err;
	void *bufp;
	u_int32_t n;
	int error = 0;

	sc = urio_cd.cd_devs[URIOUNIT(dev)];

	DPRINTFN(5, ("uriowrite: unit=%d, len=%ld\n", URIOUNIT(dev),
		     (long)uio->uio_resid));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return (ENOMEM);
	bufp = usbd_alloc_buffer(xfer, URIO_BSIZE);
	if (bufp == NULL) {
		usbd_free_xfer(xfer);
		return (ENOMEM);
	}

	sc->sc_refcnt++;

	while ((n = min(URIO_BSIZE, uio->uio_resid)) != 0) {
		error = uiomove(bufp, n, uio);
		if (error)
			break;

		DPRINTFN(1, ("uriowrite: transfer %d bytes\n", n));

		usbd_setup_xfer(xfer, sc->sc_out_pipe, 0, bufp, n,
		    USBD_NO_COPY | USBD_SYNCHRONOUS, URIO_RW_TIMEOUT, NULL);
		err = usbd_transfer(xfer);
		DPRINTFN(2, ("uriowrite: err=%d\n", err));
		if (err) {
			usbd_clear_endpoint_stall(sc->sc_out_pipe);
			if (err == USBD_TIMEOUT)
				error = ETIMEDOUT;
			else
				error = EIO;
			break;
		}
	}

	usbd_free_xfer(xfer);

	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	DPRINTFN(5, ("uriowrite: done unit=%d, error=%d\n", URIOUNIT(dev),
		     error));

	return (error);
}


int
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct urio_softc * sc;
	int unit = URIOUNIT(dev);
	struct urio_command *rcmd;
	int requesttype, len;
	struct iovec iov;
	struct uio uio;
	usb_device_request_t req;
	usbd_status err;
	u_int32_t req_actlen = 0;
	void *ptr = NULL;
	int error = 0;

	sc = urio_cd.cd_devs[unit];

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	rcmd = (struct urio_command *)addr;

	switch (cmd) {
	case URIO_RECV_COMMAND:
		requesttype = rcmd->requesttype | UT_READ_VENDOR_DEVICE;
		break;

	case URIO_SEND_COMMAND:
		requesttype = rcmd->requesttype | UT_WRITE_VENDOR_DEVICE;
		break;

	default:
		return (EINVAL);
		break;
	}

	if (!(flag & FWRITE))
		return (EPERM);
	len = rcmd->length;

	DPRINTFN(1,("urio_ioctl: cmd=0x%08lx reqtype=0x%0x req=0x%0x "
		    "value=0x%0x index=0x%0x len=0x%0x\n",
		    cmd, requesttype, rcmd->request, rcmd->value,
		    rcmd->index, len));

	/* Send rio control message */
	req.bmRequestType = requesttype;
	req.bRequest = rcmd->request;
	USETW(req.wValue, rcmd->value);
	USETW(req.wIndex, rcmd->index);
	USETW(req.wLength, len);

	if (len < 0 || len > 32767)
		return (EINVAL);
	if (len != 0) {
		iov.iov_base = (caddr_t)rcmd->buffer;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_resid = len;
		uio.uio_offset = 0;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_rw = req.bmRequestType & UT_READ ?
			     UIO_READ : UIO_WRITE;
		uio.uio_procp = p;
		ptr = malloc(len, M_TEMP, M_WAITOK);
		if (uio.uio_rw == UIO_WRITE) {
			error = uiomove(ptr, len, &uio);
			if (error)
				goto ret;
		}
	}

	sc->sc_refcnt++;

	err = usbd_do_request_flags(sc->sc_udev, &req, ptr, 0,
		  &req_actlen, USBD_DEFAULT_TIMEOUT);

	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	if (err) {
		error = EIO;
	} else {
		if (req_actlen != 0 && uio.uio_rw == UIO_READ)
			error = uiomove(ptr, req_actlen, &uio);
	}

ret:
	if (ptr != NULL)
		free(ptr, M_TEMP, 0);
	return (error);
}

int
uriopoll(dev_t dev, int events, struct proc *p)
{
	return (0);
}
@


1.46
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.45 2014/07/12 18:48:52 tedu Exp $	*/
@


1.45
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.44 2013/11/07 13:10:43 pirofti Exp $	*/
d96 10
a105 15
int urio_match(struct device *, void *, void *); 
void urio_attach(struct device *, struct device *, void *); 
int urio_detach(struct device *, int); 
int urio_activate(struct device *, int); 

struct cfdriver urio_cd = { 
	NULL, "urio", DV_DULL 
}; 

const struct cfattach urio_ca = { 
	sizeof(struct urio_softc), 
	urio_match, 
	urio_attach, 
	urio_detach, 
	urio_activate, 
a217 13
	return (0);
}

int
urio_activate(struct device *self, int act)
{
	struct urio_softc *sc = (struct urio_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.44
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.43 2013/09/20 15:34:51 mpi Exp $	*/
d507 1
a507 1
		free(ptr, M_TEMP);
@


1.43
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.42 2013/05/17 09:14:08 mpi Exp $	*/
a82 1
	char			sc_dying;
d233 1
a233 1
		sc->sc_dying = 1;
d254 1
a254 1
	if (sc->sc_dying)
d313 1
a313 1
	if (sc->sc_dying)
d370 1
a370 1
	if (sc->sc_dying)
d434 1
a434 1
	if (sc->sc_dying)
@


1.42
log
@Make it clear that the code related to a transfer submission doesn't
leak anything to userland because it doesn't set the USBD_SHORT_XFER_OK
flag.

Also prevent a bad copy/paste from introducing a similar issue by using
the actual transferred length instead of the requested one in uiomove().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.41 2013/04/15 09:23:02 mglocker Exp $	*/
d307 1
a307 1
	u_int32_t n, tn;
d330 3
a332 3
		tn = n;
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, USBD_NO_COPY,
			  URIO_RW_TIMEOUT, bufp, &tn, "uriors");
d334 2
a335 3
			if (err == USBD_INTERRUPTED)
				error = EINTR;
			else if (err == USBD_TIMEOUT)
d342 1
a342 1
		DPRINTFN(1, ("urioread: got %d bytes\n", tn));
d344 2
a345 2
		error = uiomove(bufp, tn, uio);
		if (error || tn < n)
d392 3
a394 2
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
			  URIO_RW_TIMEOUT, bufp, &n, "uriowr");
d397 2
a398 3
			if (err == USBD_INTERRUPTED)
				error = EINTR;
			else if (err == USBD_TIMEOUT)
@


1.41
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.40 2013/03/28 03:58:03 tedu Exp $	*/
a429 1
	int req_flags = 0;
d494 1
a494 1
	err = usbd_do_request_flags(sc->sc_udev, &req, ptr, req_flags,
d503 2
a504 2
		if (len != 0 && uio.uio_rw == UIO_READ)
			error = uiomove(ptr, len, &uio);
@


1.40
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.39 2011/07/03 15:47:17 matthew Exp $	*/
d74 2
a75 2
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
d78 1
a78 1
	usbd_pipe_handle	sc_in_pipe;
d80 1
a80 1
	usbd_pipe_handle	sc_out_pipe;
d133 2
a134 2
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
d304 1
a304 1
	usbd_xfer_handle xfer;
d361 1
a361 1
	usbd_xfer_handle xfer;
@


1.39
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.38 2011/01/25 20:03:36 jakemsr Exp $	*/
a47 1
#include <sys/proc.h>
@


1.38
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.37 2010/12/17 21:53:34 jasper Exp $	*/
a233 3
	case DVACT_ACTIVATE:
		break;

@


1.37
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.36 2010/09/24 08:33:59 yuo Exp $	*/
a185 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);
a223 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.36
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.35 2009/10/13 19:33:19 pirofti Exp $	*/
a96 1
#define urio_lookup(v, p) usb_lookup(urio_devs, v, p)
d125 2
a126 2
	return (urio_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.35
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.34 2008/06/26 05:42:19 ray Exp $	*/
a200 1
	sc->sc_dying = 1;
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.33 2007/10/11 18:33:15 deraadt Exp $	*/
d102 1
a102 1
int urio_activate(struct device *, enum devact); 
d237 1
a237 1
urio_activate(struct device *self, enum devact act)
@


1.33
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.32 2007/06/14 10:11:16 mbalmer Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.31 2007/06/12 16:26:37 mbalmer Exp $	*/
a143 1
	char			*devinfop;
a149 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.31
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.30 2007/06/11 16:30:31 mbalmer Exp $	*/
d106 16
a121 1
USB_DECLARE_DRIVER(urio);
@


1.30
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.29 2007/06/11 12:36:52 mbalmer Exp $	*/
d234 1
a234 1
urio_activate(device_ptr_t self, enum devact act)
@


1.29
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.28 2007/06/11 10:58:21 mbalmer Exp $	*/
d250 1
a250 1
urioopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d287 1
a287 1
urioclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d429 1
a429 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d524 1
a524 1
uriopoll(dev_t dev, int events, usb_proc_ptr p)
@


1.28
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.27 2007/06/10 14:49:01 mbalmer Exp $	*/
d255 5
a259 1
	USB_GET_SC_OPEN(urio, URIOUNIT(dev), sc);
@


1.27
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.26 2007/06/10 10:53:48 mbalmer Exp $	*/
d286 1
a286 1
	USB_GET_SC(urio, URIOUNIT(dev), sc);
d315 1
a315 1
	USB_GET_SC(urio, URIOUNIT(dev), sc);
d372 1
a372 1
	USB_GET_SC(urio, URIOUNIT(dev), sc);
d440 1
a440 1
	USB_GET_SC(urio, unit, sc);
@


1.26
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.25 2007/06/06 19:25:49 mk Exp $	*/
d138 1
a138 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d144 1
a144 1
		    USBDEVNAME(sc->sc_dev));
d151 1
a151 1
		    USBDEVNAME(sc->sc_dev));
d167 1
a167 1
			    USBDEVNAME(sc->sc_dev), i);
d179 1
a179 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
@


1.25
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.24 2007/05/31 18:20:22 mbalmer Exp $	*/
d186 1
a186 1
			   USBDEV(sc->sc_dev));
d214 1
a214 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d228 1
a228 1
			   USBDEV(sc->sc_dev));
d357 1
a357 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d415 1
a415 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d504 1
a504 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.24
log
@Remove more #ifdef/#endif's that checked for other bsds.  No binary
change, no functionality change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.23 2007/05/27 04:00:25 jsg Exp $	*/
d81 1
a81 1
 	USBBASEDEVICE		sc_dev;
@


1.23
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.22 2007/05/21 05:40:28 jsg Exp $	*/
a49 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a51 8
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/ioccom.h>
#include <sys/conf.h>
#include <sys/fcntl.h>
#include <sys/filio.h>
#endif
a74 29

#if defined(__NetBSD__)
dev_type_open(urioopen);
dev_type_close(urioclose);
dev_type_read(urioread);
dev_type_write(uriowrite);
dev_type_ioctl(urioioctl);

const struct cdevsw urio_cdevsw = {
	urioopen, urioclose, urioread, uriowrite, urioioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
#elif defined(__FreeBSD__)
d_open_t  urioopen;
d_close_t urioclose;
d_read_t  urioread;
d_write_t uriowrite;
d_ioctl_t urioioctl;

#define URIO_CDEV_MAJOR	143

static struct cdevsw urio_cdevsw = {
	urioopen,	urioclose,	urioread,	uriowrite,
 	urioioctl,	nopoll,		nommap,		nostrategy,
 	"urio",		URIO_CDEV_MAJOR,nodump,		nopsize,
 	0,		-1
};
#endif  /* defined(__FreeBSD__) */

a77 1

a79 1

a182 7
#if defined(__FreeBSD__)
	/* XXX no error trapping, no storing of dev_t */
	(void)make_dev(&urio_cdevsw, device_get_unit(self),
		       UID_ROOT, GID_OPERATOR,
		       0644, "urio%d", device_get_unit(self));
#endif /* defined(__FreeBSD__) */

a193 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a196 3
#elif defined(__FreeBSD__)
	DPRINTF(("urio_detach: sc=%p\n", sc));
#endif
a217 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a218 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&urio_cdevsw);
#elif defined(__OpenBSD__)
a221 1
#endif
a225 3
#elif defined(__FreeBSD__)
	/* XXX not implemented yet */
#endif
a232 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a247 1
#endif
a523 4

#if defined(__FreeBSD__)
DRIVER_MODULE(urio, uhub, urio_driver, urio_devclass, usbd_driver_load, 0);
#endif /* defined(__FreeBSD__) */
@


1.22
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.21 2006/06/23 06:27:12 miod Exp $	*/
d148 2
a149 1
USB_MATCH(urio)
d151 1
a151 1
	USB_MATCH_START(urio, uaa);
d162 2
a163 1
USB_ATTACH(urio)
d165 2
a166 1
	USB_ATTACH_START(urio, sc, uaa);
d178 1
a178 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d185 1
a185 1
		USB_ATTACH_ERROR_RETURN;
d192 1
a192 1
		USB_ATTACH_ERROR_RETURN;
d208 1
a208 1
			USB_ATTACH_ERROR_RETURN;
d220 1
a220 1
		USB_ATTACH_ERROR_RETURN;
a233 2

	USB_ATTACH_SUCCESS_RETURN;
d236 2
a237 1
USB_DETACH(urio)
d239 1
a239 1
	USB_DETACH_START(urio, sc);
@


1.21
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.20 2005/11/21 18:16:44 millert Exp $	*/
d76 2
a77 2
#define DPRINTF(x)	do { if (uriodebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uriodebug>(n)) logprintf x; } while (0)
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.19 2005/08/01 05:36:49 brad Exp $	*/
a298 1
		return (EOPNOTSUPP);
@


1.19
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.18 2004/07/08 22:18:44 deraadt Exp $	*/
d63 1
a63 1
#include <sys/select.h>
@


1.18
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.17 2003/05/17 17:23:39 nate Exp $	*/
d166 1
a166 1
	char			devinfo[1024];
d174 1
a174 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d176 2
a177 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.17
log
@My psaplay120 is acutally a rio device.  The userland bits need to be worked
on though
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.16 2003/05/07 04:33:33 deraadt Exp $	*/
d76 2
a77 2
#define DPRINTF(x)	if (uriodebug) logprintf x
#define DPRINTFN(n,x)	if (uriodebug>(n)) logprintf x
@


1.16
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.15 2002/11/11 02:32:32 nate Exp $	*/
d142 1
@


1.15
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.14 2002/07/25 04:07:33 nate Exp $	*/
d173 1
a173 1
	usbd_devinfo(dev, 0, devinfo);
@


1.14
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.13 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: urio.c,v 1.12 2002/07/11 21:14:33 augustss Exp $ */
d86 10
a95 1
cdev_decl(urio);
d268 3
d274 1
@


1.13
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.12 2002/07/10 21:41:51 mickey Exp $	*/
/*	$NetBSD: urio.c,v 1.11 2002/02/11 15:11:49 augustss Exp $	*/
@


1.12
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.11 2002/07/10 13:18:10 nate Exp $	*/
d303 1
a303 1
	DPRINTFN(5, ("urioopen: flag=%d, mode=%d, unit=%d\n", 
d420 1
a420 1
	DPRINTFN(5, ("uriowrite: unit=%d, len=%ld\n", URIOUNIT(dev), 
d463 1
a463 1
	DPRINTFN(5, ("uriowrite: done unit=%d, error=%d\n", URIOUNIT(dev), 
d512 1
a512 1
		    "value=0x%0x index=0x%0x len=0x%0x\n", 
d533 1
a533 1
		uio.uio_rw = req.bmRequestType & UT_READ ? 
@


1.11
log
@sync whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.10 2002/07/09 17:41:02 nate Exp $	*/
d85 1
a85 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.10
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.9 2002/06/11 03:08:15 nate Exp $	*/
d547 1
a547 1
				    &req_actlen, USBD_DEFAULT_TIMEOUT);
@


1.9
log
@sync urio with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.8 2002/05/07 18:29:18 nate Exp $	*/
d547 1
a547 1
				    &req_actlen);
@


1.8
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.6 2001/10/31 04:24:44 nate Exp $	*/
/*	$NetBSD: urio.c,v 1.6 2001/09/25 21:08:44 jdolecek Exp $	*/
d129 7
d147 2
a148 9
	if ( ( uaa->vendor == USB_VENDOR_DIAMOND &&
	      uaa->product == USB_PRODUCT_DIAMOND_RIO500USB ) ||
	     ( uaa->vendor == USB_VENDOR_DIAMOND2 &&
	       ( uaa->product == USB_PRODUCT_DIAMOND2_RIO600USB ||
	         uaa->product == USB_PRODUCT_DIAMOND2_RIO800USB ) )
	   )
		return (UMATCH_VENDOR_PRODUCT);
	else
		return (UMATCH_NONE);
d296 1
a296 1
urioopen(dev_t dev, int flag, int mode, struct proc *p)
d329 1
a329 1
urioclose(dev_t dev, int flag, int mode, struct proc *p)
d382 1
a382 1
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, 0,
d444 1
a444 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, 0, 
d471 1
a471 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d566 1
a566 1
uriopoll(dev_t dev, int events, struct proc *p)
@


1.7
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: urio.c,v 1.11 2002/02/11 15:11:49 augustss Exp $	*/
a128 7
static const struct usb_devno urio_devs[] = {
	{ USB_VENDOR_DIAMOND, USB_PRODUCT_DIAMOND_RIO500USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO600USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO800USB},
};
#define urio_lookup(v, p) usb_lookup(urio_devs, v, p)

d140 9
a148 2
	return (urio_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d296 1
a296 1
urioopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d329 1
a329 1
urioclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d382 1
a382 1
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, USBD_NO_COPY,
d444 1
a444 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
d471 1
a471 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d547 1
a547 1
		  &req_actlen, USBD_DEFAULT_TIMEOUT);
d566 1
a566 1
uriopoll(dev_t dev, int events, usb_proc_ptr p)
@


1.6
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.5 2001/01/28 09:43:42 aaron Exp $	*/
/*	$NetBSD: urio.c,v 1.6 2001/09/25 21:08:44 jdolecek Exp $	*/
d129 7
d147 2
a148 9
	if ( ( uaa->vendor == USB_VENDOR_DIAMOND &&
	      uaa->product == USB_PRODUCT_DIAMOND_RIO500USB ) ||
	     ( uaa->vendor == USB_VENDOR_DIAMOND2 &&
	       ( uaa->product == USB_PRODUCT_DIAMOND2_RIO600USB ||
	         uaa->product == USB_PRODUCT_DIAMOND2_RIO800USB ) )
	   )
		return (UMATCH_VENDOR_PRODUCT);
	else
		return (UMATCH_NONE);
d296 1
a296 1
urioopen(dev_t dev, int flag, int mode, struct proc *p)
d329 1
a329 1
urioclose(dev_t dev, int flag, int mode, struct proc *p)
d382 1
a382 1
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, 0,
d444 1
a444 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, 0, 
d471 1
a471 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d547 1
a547 1
				    &req_actlen);
d566 1
a566 1
uriopoll(dev_t dev, int events, struct proc *p)
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.6 2001/10/31 04:24:44 nate Exp $	*/
@


1.6.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: urio.c,v 1.12 2002/07/11 21:14:33 augustss Exp $ */
d85 1
a85 1
#if defined(__NetBSD__)
a128 7
static const struct usb_devno urio_devs[] = {
	{ USB_VENDOR_DIAMOND, USB_PRODUCT_DIAMOND_RIO500USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO600USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO800USB},
};
#define urio_lookup(v, p) usb_lookup(urio_devs, v, p)

d140 9
a148 2
	return (urio_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d296 1
a296 1
urioopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d303 1
a303 1
	DPRINTFN(5, ("urioopen: flag=%d, mode=%d, unit=%d\n",
d329 1
a329 1
urioclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d382 1
a382 1
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, USBD_NO_COPY,
d420 1
a420 1
	DPRINTFN(5, ("uriowrite: unit=%d, len=%ld\n", URIOUNIT(dev),
d444 1
a444 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
d463 1
a463 1
	DPRINTFN(5, ("uriowrite: done unit=%d, error=%d\n", URIOUNIT(dev),
d471 1
a471 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d512 1
a512 1
		    "value=0x%0x index=0x%0x len=0x%0x\n",
d533 1
a533 1
		uio.uio_rw = req.bmRequestType & UT_READ ?
d547 1
a547 1
		  &req_actlen, USBD_DEFAULT_TIMEOUT);
d566 1
a566 1
uriopoll(dev_t dev, int events, usb_proc_ptr p)
@


1.6.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: urio.c,v 1.15 2002/10/23 09:14:02 jdolecek Exp $	*/
d86 1
a86 10
dev_type_open(urioopen);
dev_type_close(urioclose);
dev_type_read(urioread);
dev_type_write(uriowrite);
dev_type_ioctl(urioioctl);

const struct cdevsw urio_cdevsw = {
	urioopen, urioclose, urioread, uriowrite, urioioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
d164 1
a164 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
a258 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&urio_cdevsw);
#elif defined(__OpenBSD__)
a261 1
#endif
@


1.5
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.4 2000/11/08 18:10:38 aaron Exp $	*/
/*	$NetBSD: urio.c,v 1.5 2000/10/24 14:53:59 augustss Exp $	*/
d142 3
a144 2
	      ( uaa->vendor == USB_VENDOR_DIAMOND2 &&
	       uaa->product == USB_PRODUCT_DIAMOND2_RIO600USB )
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.5 2001/01/28 09:43:42 aaron Exp $	*/
@


1.5.4.2
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: urio.c,v 1.6 2001/09/25 21:08:44 jdolecek Exp $	*/
d142 2
a143 3
	     ( uaa->vendor == USB_VENDOR_DIAMOND2 &&
	       ( uaa->product == USB_PRODUCT_DIAMOND2_RIO600USB ||
	         uaa->product == USB_PRODUCT_DIAMOND2_RIO800USB ) )
@


1.5.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: urio.c,v 1.15 2002/10/23 09:14:02 jdolecek Exp $	*/
d85 2
a86 11
#if defined(__NetBSD__)
dev_type_open(urioopen);
dev_type_close(urioclose);
dev_type_read(urioread);
dev_type_write(uriowrite);
dev_type_ioctl(urioioctl);

const struct cdevsw urio_cdevsw = {
	urioopen, urioclose, urioread, uriowrite, urioioctl,
	nostop, notty, nopoll, nommap, nokqfilter,
};
a128 7
static const struct usb_devno urio_devs[] = {
	{ USB_VENDOR_DIAMOND, USB_PRODUCT_DIAMOND_RIO500USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO600USB},
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_RIO800USB},
};
#define urio_lookup(v, p) usb_lookup(urio_devs, v, p)

d140 9
a148 2
	return (urio_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a258 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&urio_cdevsw);
#elif defined(__OpenBSD__)
a261 1
#endif
d296 1
a296 1
urioopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d303 1
a303 1
	DPRINTFN(5, ("urioopen: flag=%d, mode=%d, unit=%d\n",
d329 1
a329 1
urioclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d382 1
a382 1
		err = usbd_bulk_transfer(xfer, sc->sc_in_pipe, USBD_NO_COPY,
d420 1
a420 1
	DPRINTFN(5, ("uriowrite: unit=%d, len=%ld\n", URIOUNIT(dev),
d444 1
a444 1
		err = usbd_bulk_transfer(xfer, sc->sc_out_pipe, USBD_NO_COPY,
d463 1
a463 1
	DPRINTFN(5, ("uriowrite: done unit=%d, error=%d\n", URIOUNIT(dev),
d471 1
a471 1
urioioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d512 1
a512 1
		    "value=0x%0x index=0x%0x len=0x%0x\n",
d533 1
a533 1
		uio.uio_rw = req.bmRequestType & UT_READ ?
d547 1
a547 1
		  &req_actlen, USBD_DEFAULT_TIMEOUT);
d566 1
a566 1
uriopoll(dev_t dev, int events, usb_proc_ptr p)
@


1.5.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.5.4.3 2003/03/28 00:38:32 niklas Exp $	*/
d173 1
a173 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.5.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.5.4.4 2003/05/13 19:35:12 ho Exp $	*/
a141 1
	{ USB_VENDOR_DIAMOND2, USB_PRODUCT_DIAMOND2_PSAPLAY120},
@


1.4
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: urio.c,v 1.3 2000/09/14 15:19:46 jakob Exp $	*/
d277 1
a277 3
urio_activate(self, act)
	device_ptr_t self;
	enum devact act;
d295 1
a295 5
urioopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d328 1
a328 5
urioclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d351 1
a351 4
urioread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d408 1
a408 4
uriowrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d470 1
a470 6
urioioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr; 
	int flag;
	struct proc *p;
d565 1
a565 4
uriopoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
@


1.3
log
@recognize Diamond RIO 600 USB; from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.2 2000/07/04 11:44:24 fgsch Exp $	*/
/*	$NetBSD: urio.c,v 1.4 2000/09/14 03:13:21 augustss Exp $	*/
d167 1
a167 1
	err = usbd_set_config_no(dev, URIO_CONFIG_NO, 0);
@


1.2
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: urio.c,v 1.1 2000/04/15 17:36:28 jakob Exp $	*/
/*	$NetBSD: urio.c,v 1.1 2000/04/14 14:20:02 augustss Exp $	*/
d140 5
a144 2
	if (uaa->vendor == USB_VENDOR_DIAMOND &&
	    uaa->product == USB_PRODUCT_DIAMOND_RIO500USB)
@


1.1
log
@urio(4) - Diamond Multimedia RIO 500 (from NetBSD)

This driver will eventually go away as it really should be implemented
using ugen(4) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@

