head	1.29;
access;
symbols
	OPENBSD_5_8:1.28.0.8
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.25.0.8
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.4
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.2
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.8
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.4
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.12
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.9.0.8
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.14
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2016.01.08.15.54.13;	author jcs;	state dead;
branches;
next	1.28;
commitid	kI4H556ZKYkRQGw5;

1.28
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.27;
commitid	OBNa5kfxQ2UXoiIw;

1.27
date	2014.05.18.21.43.11;	author jca;	state Exp;
branches;
next	1.26;

1.26
date	2014.05.12.09.50.44;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2012.08.05.16.07.11;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.05.15.03.02;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.24.08.37.47;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.09.01.00.35;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.18.10.37;	author aaron;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.07.04.11.44.21;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.14.22.50.24;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.30.16.19.32;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.19.37.46;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.26.08.39.45;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.11.07.21.30.18;	author fgsch;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.08.16.22.08.48;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.03;	author fgsch;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.18;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@/*	$OpenBSD: hid.c,v 1.28 2014/07/12 18:48:52 tedu Exp $ */
/*	$NetBSD: hid.c,v 1.23 2002/07/11 21:14:25 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/hid.c,v 1.11 1999/11/17 22:33:39 n_hibma Exp $ */

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/hid.h>

#ifdef USBHID_DEBUG
#define DPRINTF(x...)	 do { printf(x); } while (0)
#else
#define DPRINTF(x...)
#endif

#define	MAXUSAGE 64
#define	MAXPUSH 4
#define	MAXID 16

struct hid_pos_data {
	int32_t rid;
	uint32_t pos;
};

struct hid_data {
	const uint8_t *start;
	const uint8_t *end;
	const uint8_t *p;
	struct hid_item cur[MAXPUSH];
	struct hid_pos_data last_pos[MAXID];
	int32_t	usages_min[MAXUSAGE];
	int32_t	usages_max[MAXUSAGE];
	int32_t usage_last;	/* last seen usage */
	uint32_t loc_size;	/* last seen size */
	uint32_t loc_count;	/* last seen count */
	enum hid_kind kind;
	uint8_t	pushlevel;	/* current pushlevel */
	uint8_t	ncount;		/* end usage item count */
	uint8_t icount;		/* current usage item count */
	uint8_t	nusage;		/* end "usages_min/max" index */
	uint8_t	iusage;		/* current "usages_min/max" index */
	uint8_t ousage;		/* current "usages_min/max" offset */
	uint8_t	susage;		/* usage set flags */
};

static void
hid_clear_local(struct hid_item *c)
{
	c->loc.count = 0;
	c->loc.size = 0;
	c->usage = 0;
	c->usage_minimum = 0;
	c->usage_maximum = 0;
	c->designator_index = 0;
	c->designator_minimum = 0;
	c->designator_maximum = 0;
	c->string_index = 0;
	c->string_minimum = 0;
	c->string_maximum = 0;
	c->set_delimiter = 0;
}

static void
hid_switch_rid(struct hid_data *s, struct hid_item *c, int32_t nextid)
{
	uint8_t i;

	if (c->report_ID == nextid)
		return;

	/* save current position for current rID */
	if (c->report_ID == 0) {
		i = 0;
	} else {
		for (i = 1; i != MAXID; i++) {
			if (s->last_pos[i].rid == c->report_ID)
				break;
			if (s->last_pos[i].rid == 0)
				break;
		}
	}
	if (i != MAXID) {
		s->last_pos[i].rid = c->report_ID;
		s->last_pos[i].pos = c->loc.pos;
	}

	/* store next report ID */
	c->report_ID = nextid;

	/* lookup last position for next rID */
	if (nextid == 0) {
		i = 0;
	} else {
		for (i = 1; i != MAXID; i++) {
			if (s->last_pos[i].rid == nextid)
				break;
			if (s->last_pos[i].rid == 0)
				break;
		}
	}
	if (i != MAXID) {
		s->last_pos[i].rid = nextid;
		c->loc.pos = s->last_pos[i].pos;
	} else {
		DPRINTF("Out of RID entries, position is set to zero!\n");
		c->loc.pos = 0;
	}
}

struct hid_data *
hid_start_parse(const void *d, int len, enum hid_kind kind)
{
	struct hid_data *s;

	s = malloc(sizeof(*s), M_TEMP, M_WAITOK | M_ZERO);

	s->start = s->p = d;
	s->end = ((const uint8_t *)d) + len;
	s->kind = kind;
	return (s);
}

void
hid_end_parse(struct hid_data *s)
{
	if (s == NULL)
		return;

	free(s, M_TEMP, 0);
}

static uint8_t
hid_get_byte(struct hid_data *s, const uint16_t wSize)
{
	const uint8_t *ptr;
	uint8_t retval;

	ptr = s->p;

	/* check if end is reached */
	if (ptr == s->end)
		return (0);

	/* read out a byte */
	retval = *ptr;

	/* check if data pointer can be advanced by "wSize" bytes */
	if ((s->end - ptr) < wSize)
		ptr = s->end;
	else
		ptr += wSize;

	/* update pointer */
	s->p = ptr;

	return (retval);
}

int
hid_get_item(struct hid_data *s, struct hid_item *h)
{
	struct hid_item *c;
	unsigned int bTag, bType, bSize;
	uint32_t oldpos;
	int32_t mask;
	int32_t dval;

	if (s == NULL)
		return (0);

	c = &s->cur[s->pushlevel];

 top:
	/* check if there is an array of items */
	DPRINTF("%s: icount=%d ncount=%d\n", __func__,
	    s->icount, s->ncount);
	if (s->icount < s->ncount) {
		/* get current usage */
		if (s->iusage < s->nusage) {
			dval = s->usages_min[s->iusage] + s->ousage;
			c->usage = dval;
			s->usage_last = dval;
			if (dval == s->usages_max[s->iusage]) {
				s->iusage ++;
				s->ousage = 0;
			} else {
				s->ousage ++;
			}
		} else {
			DPRINTF("Using last usage\n");
			dval = s->usage_last;
		}
		s->icount ++;
		/*
		 * Only copy HID item, increment position and return
		 * if correct kind!
		 */
		if (s->kind == c->kind) {
			*h = *c;
			DPRINTF("%u,%u,%u\n", h->loc.pos,
			    h->loc.size, h->loc.count);
			c->loc.pos += c->loc.size * c->loc.count;
			return (1);
		}
	}

	/* reset state variables */
	s->icount = 0;
	s->ncount = 0;
	s->iusage = 0;
	s->nusage = 0;
	s->susage = 0;
	s->ousage = 0;
	hid_clear_local(c);

	/* get next item */
	while (s->p != s->end) {

		bSize = hid_get_byte(s, 1);
		if (bSize == 0xfe) {
			/* long item */
			bSize = hid_get_byte(s, 1);
			bSize |= hid_get_byte(s, 1) << 8;
			bTag = hid_get_byte(s, 1);
			bType = 0xff;	/* XXX what should it be */
		} else {
			/* short item */
			bTag = bSize >> 4;
			bType = (bSize >> 2) & 3;
			bSize &= 3;
			if (bSize == 3)
				bSize = 4;
		}
		switch (bSize) {
		case 0:
			dval = 0;
			mask = 0;
			break;
		case 1:
			dval = hid_get_byte(s, 1);
			mask = 0xFF;
			break;
		case 2:
			dval = hid_get_byte(s, 1);
			dval |= hid_get_byte(s, 1) << 8;
			mask = 0xFFFF;
			break;
		case 4:
			dval = hid_get_byte(s, 1);
			dval |= hid_get_byte(s, 1) << 8;
			dval |= hid_get_byte(s, 1) << 16;
			dval |= hid_get_byte(s, 1) << 24;
			mask = 0xFFFFFFFF;
			break;
		default:
			dval = hid_get_byte(s, bSize);
			DPRINTF("bad length %u (data=0x%02x)\n",
			    bSize, dval);
			continue;
		}

		DPRINTF("%s: bType=%d bTag=%d dval=%d\n", __func__,
		    bType, bTag, dval);
		switch (bType) {
		case 0:		/* Main */
			switch (bTag) {
			case 8:	/* Input */
				c->kind = hid_input;
				c->flags = dval;
		ret:
				c->loc.count = s->loc_count;
				c->loc.size = s->loc_size;

				if (c->flags & HIO_VARIABLE) {
					/* range check usage count */
					if (c->loc.count > 255) {
						DPRINTF("Number of "
						    "items truncated to 255\n");
						s->ncount = 255;
					} else
						s->ncount = c->loc.count;

					/*
					 * The "top" loop will return
					 * one and one item:
					 */
					c->loc.count = 1;
				} else {
					s->ncount = 1;
				}
				goto top;

			case 9:	/* Output */
				c->kind = hid_output;
				c->flags = dval;
				goto ret;
			case 10:	/* Collection */
				c->kind = hid_collection;
				c->collection = dval;
				c->collevel++;
				c->usage = s->usage_last;
				*h = *c;
				return (1);
			case 11:	/* Feature */
				c->kind = hid_feature;
				c->flags = dval;
				goto ret;
			case 12:	/* End collection */
				c->kind = hid_endcollection;
				if (c->collevel == 0) {
					DPRINTF("invalid end collection\n");
					return (0);
				}
				c->collevel--;
				*h = *c;
				return (1);
			default:
				DPRINTF("Main bTag=%d\n", bTag);
				break;
			}
			break;
		case 1:		/* Global */
			switch (bTag) {
			case 0:
				c->_usage_page = dval << 16;
				break;
			case 1:
				c->logical_minimum = dval;
				break;
			case 2:
				c->logical_maximum = dval;
				break;
			case 3:
				c->physical_minimum = dval;
				break;
			case 4:
				c->physical_maximum = dval;
				break;
			case 5:
				c->unit_exponent = dval;
				break;
			case 6:
				c->unit = dval;
				break;
			case 7:
				/* mask because value is unsigned */
				s->loc_size = dval & mask;
				break;
			case 8:
				hid_switch_rid(s, c, dval & mask);
				break;
			case 9:
				/* mask because value is unsigned */
				s->loc_count = dval & mask;
				break;
			case 10:	/* Push */
				s->pushlevel ++;
				if (s->pushlevel < MAXPUSH) {
					s->cur[s->pushlevel] = *c;
					/* store size and count */
					c->loc.size = s->loc_size;
					c->loc.count = s->loc_count;
					/* update current item pointer */
					c = &s->cur[s->pushlevel];
				} else {
					DPRINTF("Cannot push "
					    "item @@ %d\n", s->pushlevel);
				}
				break;
			case 11:	/* Pop */
				s->pushlevel --;
				if (s->pushlevel < MAXPUSH) {
					/* preserve position */
					oldpos = c->loc.pos;
					c = &s->cur[s->pushlevel];
					/* restore size and count */
					s->loc_size = c->loc.size;
					s->loc_count = c->loc.count;
					/* set default item location */
					c->loc.pos = oldpos;
					c->loc.size = 0;
					c->loc.count = 0;
				} else {
					DPRINTF("Cannot pop "
					    "item @@ %d\n", s->pushlevel);
				}
				break;
			default:
				DPRINTF("Global bTag=%d\n", bTag);
				break;
			}
			break;
		case 2:		/* Local */
			switch (bTag) {
			case 0:
				if (bSize != 4)
					dval = (dval & mask) | c->_usage_page;

				/* set last usage, in case of a collection */
				s->usage_last = dval;

				if (s->nusage < MAXUSAGE) {
					s->usages_min[s->nusage] = dval;
					s->usages_max[s->nusage] = dval;
					s->nusage ++;
				} else {
					DPRINTF("max usage reached\n");
				}

				/* clear any pending usage sets */
				s->susage = 0;
				break;
			case 1:
				s->susage |= 1;

				if (bSize != 4)
					dval = (dval & mask) | c->_usage_page;
				c->usage_minimum = dval;

				goto check_set;
			case 2:
				s->susage |= 2;

				if (bSize != 4)
					dval = (dval & mask) | c->_usage_page;
				c->usage_maximum = dval;

			check_set:
				if (s->susage != 3)
					break;

				/* sanity check */
				if ((s->nusage < MAXUSAGE) &&
				    (c->usage_minimum <= c->usage_maximum)) {
					/* add usage range */
					s->usages_min[s->nusage] = 
					    c->usage_minimum;
					s->usages_max[s->nusage] = 
					    c->usage_maximum;
					s->nusage ++;
				} else {
					DPRINTF("Usage set dropped\n");
				}
				s->susage = 0;
				break;
			case 3:
				c->designator_index = dval;
				break;
			case 4:
				c->designator_minimum = dval;
				break;
			case 5:
				c->designator_maximum = dval;
				break;
			case 7:
				c->string_index = dval;
				break;
			case 8:
				c->string_minimum = dval;
				break;
			case 9:
				c->string_maximum = dval;
				break;
			case 10:
				c->set_delimiter = dval;
				break;
			default:
				DPRINTF("Local bTag=%d\n", bTag);
				break;
			}
			break;
		default:
			DPRINTF("default bType=%d\n", bType);
			break;
		}
	}
	return (0);
}

int
hid_report_size(const void *buf, int len, enum hid_kind k, u_int8_t id)
{
	struct hid_data *d;
	struct hid_item h;
	int lo, hi;

	h.report_ID = 0;
	lo = hi = -1;
	DPRINTF("hid_report_size: kind=%d id=%d\n", k, id);
	for (d = hid_start_parse(buf, len, k); hid_get_item(d, &h); ) {
		DPRINTF("hid_report_size: item kind=%d id=%d pos=%d "
			  "size=%d count=%d\n",
			  h.kind, h.report_ID, h.loc.pos, h.loc.size,
			  h.loc.count);
		if (h.report_ID == id && h.kind == k) {
			if (lo < 0) {
				lo = h.loc.pos;
#ifdef DIAGNOSTIC
				if (lo != 0) {
					printf("hid_report_size: lo != 0\n");
				}
#endif
			}
			hi = h.loc.pos + h.loc.size * h.loc.count;
			DPRINTF("hid_report_size: lo=%d hi=%d\n", lo, hi);

		}
	}
	hid_end_parse(d);
	return ((hi - lo + 7) / 8);
}

int
hid_locate(const void *desc, int size, int32_t u, uint8_t id, enum hid_kind k,
    struct hid_location *loc, uint32_t *flags)
{
	struct hid_data *d;
	struct hid_item h;

	h.report_ID = 0;
	DPRINTF("hid_locate: enter usage=0x%x kind=%d id=%d\n", u, k, id);
	for (d = hid_start_parse(desc, size, k); hid_get_item(d, &h); ) {
		DPRINTF("hid_locate: usage=0x%x kind=%d id=%d flags=0x%x\n",
			    h.usage, h.kind, h.report_ID, h.flags);
		if (h.kind == k && !(h.flags & HIO_CONST) &&
		    h.usage == u && h.report_ID == id) {
			if (loc != NULL)
				*loc = h.loc;
			if (flags != NULL)
				*flags = h.flags;
			hid_end_parse(d);
			return (1);
		}
	}
	hid_end_parse(d);
	if (loc != NULL)
		loc->size = 0;
	if (flags != NULL)
		*flags = 0;
	return (0);
}

int32_t
hid_get_data(const uint8_t *buf, int len, struct hid_location *loc)
{
	uint32_t hpos = loc->pos;
	uint32_t hsize = loc->size;
	uint32_t data;
	uint32_t rpos;
	uint8_t n;

	DPRINTF("hid_get_data: loc %d/%d\n", hpos, hsize);

	/* Range check and limit */
	if (hsize == 0)
		return (0);
	if (hsize > 32)
		hsize = 32;

	/* Get data in a safe way */
	data = 0;
	rpos = (hpos / 8);
	n = (hsize + 7) / 8;
	rpos += n;
	while (n--) {
		rpos--;
		if (rpos < len)
			data |= buf[rpos] << (8 * n);
	}

	/* Correctly shift down data */
	data = (data >> (hpos % 8));
	n = 32 - hsize;

	data = (int32_t)((int32_t)data << n) >> n;

	DPRINTF("hid_get_data: loc %d/%d = %lu\n",
	    loc->pos, loc->size, (long)data);
	return (data);
}

int
hid_is_collection(const void *desc, int size, uint8_t id, int32_t usage)
{
	struct hid_data *hd;
	struct hid_item hi;
	uint32_t coll_usage = ~0;

	hd = hid_start_parse(desc, size, hid_none);

	DPRINTF("%s: id=%d usage=0x%x\n", __func__, id, usage);
	while (hid_get_item(hd, &hi)) {
		DPRINTF("%s: kind=%d id=%d usage=0x%x(0x%x)\n", __func__,
			    hi.kind, hi.report_ID, hi.usage, coll_usage);
		if (hi.kind == hid_collection &&
		    hi.collection == HCOLL_APPLICATION)
			coll_usage = hi.usage;
		if (hi.kind == hid_endcollection &&
		    coll_usage == usage && hi.report_ID == id) {
			DPRINTF("%s: found\n", __func__);
			hid_end_parse(hd);
			return (1);
		}
	}
	DPRINTF("%s: not found\n", __func__);
	hid_end_parse(hd);
	return (0);
}
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.27 2014/05/18 21:43:11 jca Exp $ */
@


1.27
log
@hid_start_parse can't fail - it calls malloc(M_WAITOK).  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.26 2014/05/12 09:50:44 mpi Exp $ */
d163 1
a163 1
	free(s, M_TEMP);
@


1.26
log
@Backport FreeBSD's HID parser in order to properly parse `moderm'
input device descriptors, notably if they include an Item with an
Usage array (Min-Max range) and others single Usage elements.

Tested by many, thanks!  ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.25 2012/08/05 16:07:11 mpi Exp $ */
a623 2
	if (hd == NULL)
		return (0);
@


1.25
log
@Remove a self-assignment, from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.24 2011/06/17 07:06:47 mk Exp $ */
d44 2
a45 4
#ifdef UHIDEV_DEBUG
#define DPRINTF(x)	do { if (uhidevdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhidevdebug>(n)) printf x; } while (0)
extern int uhidevdebug;
d47 1
a47 2
#define DPRINTF(x)
#define DPRINTFN(n,x)
d50 8
a57 1
void hid_clear_local(struct hid_item *);
a58 1
#define MAXUSAGE 256
d60 10
a69 9
	u_char *start;
	u_char *end;
	u_char *p;
	struct hid_item cur;
	int32_t usages[MAXUSAGE];
	int nu;
	int minset;
	int multi;
	int multimax;
d71 7
d80 1
a80 1
void
d83 2
a84 2

	DPRINTFN(5,("hid_clear_local\n"));
d97 47
d145 1
a145 1
hid_start_parse(void *d, int len, enum hid_kind kind)
d149 1
a149 1
	s = malloc(sizeof *s, M_TEMP, M_WAITOK | M_ZERO);
d152 1
a152 1
	s->end = (char *)d + len;
d160 2
a162 5
	while (s->cur.next != NULL) {
		struct hid_item *hi = s->cur.next->next;
		free(s->cur.next, M_TEMP);
		s->cur.next = hi;
	}
d166 27
d196 1
a196 1
	struct hid_item *c = &s->cur;
d198 2
a199 2
	u_int32_t oldpos;
	u_char *data;
d201 5
a205 4
	u_char *p;
	struct hid_item *hi;
	int i;
	enum hid_kind retkind;
d208 25
a232 6
	DPRINTFN(5,("hid_get_item: multi=%d multimax=%d\n",
		    s->multi, s->multimax));
	if (s->multimax != 0) {
		if (s->multi < s->multimax) {
			c->usage = s->usages[min(s->multi, s->nu-1)];
			s->multi++;
d234 3
a236 3
			c->loc.pos += c->loc.size;
			h->next = NULL;
			DPRINTFN(5,("return multi\n"));
a237 5
		} else {
			c->loc.count = s->multimax;
			s->multimax = 0;
			s->nu = 0;
			hid_clear_local(c);
a239 4
	for (;;) {
		p = s->p;
		if (p >= s->end)
			return (0);
d241 13
a253 1
		bSize = *p++;
d256 4
a259 6
			bSize = *p++;
			bSize |= *p++ << 8;
			bTag = *p++;
			data = p;
			p += bSize;
			bType = 0xff; /* XXX what should it be */
d265 2
a266 3
			if (bSize == 3) bSize = 4;
			data = p;
			p += bSize;
d268 1
a268 2
		s->p = p;
		switch(bSize) {
d271 1
d274 2
a275 1
			dval = /*(int8_t)*/ *data++;
d278 3
a280 2
			dval = *data++;
			dval |= *data++ << 8;
d283 5
a287 4
			dval = *data++;
			dval |= *data++ << 8;
			dval |= *data++ << 16;
			dval |= *data++ << 24;
d290 3
a292 1
			printf("BAD LENGTH %d\n", bSize);
d296 2
a297 2
		DPRINTFN(5,("hid_get_item: bType=%d bTag=%d dval=%d\n",
			 bType, bTag, dval));
d299 1
a299 1
		case 0:			/* Main */
d301 2
a302 10
			case 8:		/* Input */
				retkind = hid_input;
			ret:
				if (s->kind != retkind) {
					s->minset = 0;
					s->nu = 0;
					hid_clear_local(c);
					continue;
				}
				c->kind = retkind;
d304 4
d309 12
a320 2
					s->multimax = c->loc.count;
					s->multi = 0;
a321 11
					if (s->minset) {
						for (i = c->usage_minimum;
						     i <= c->usage_maximum;
						     i++) {
							s->usages[s->nu] = i;
							if (s->nu < MAXUSAGE-1)
								s->nu++;
						}
						s->minset = 0;
					}
					goto top;
d323 1
a323 9
					c->usage = c->_usage_page; /* XXX */
					*h = *c;
					h->next = NULL;
					c->loc.pos +=
					    c->loc.size * c->loc.count;
					s->minset = 0;
					s->nu = 0;
					hid_clear_local(c);
					return (1);
d325 5
a329 2
			case 9:		/* Output */
				retkind = hid_output;
d335 1
a336 2
				hid_clear_local(c);
				s->nu = 0;
d339 2
a340 1
				retkind = hid_feature;
d344 4
a349 1
				s->nu = 0;
d352 1
a352 1
				printf("Main bTag=%d\n", bTag);
d380 2
a381 1
				c->loc.size = dval;
d384 1
a384 2
				c->report_ID = dval;
				c->loc.pos = 0;
d387 16
a402 1
				c->loc.count = dval;
d404 17
a420 11
			case 10: /* Push */
				hi = malloc(sizeof *hi, M_TEMP, M_WAITOK);
				*hi = s->cur;
				c->next = hi;
				break;
			case 11: /* Pop */
				hi = c->next;
				oldpos = c->loc.pos;
				s->cur = *hi;
				c->loc.pos = oldpos;
				free(hi, M_TEMP);
d423 1
a423 1
				printf("Global bTag=%d\n", bTag);
d430 16
a445 8
				if (bSize == 1)
					dval = c->_usage_page | (dval&0xff);
				else if (bSize == 2)
					dval = c->_usage_page | (dval&0xffff);
				c->usage = dval;
				if (s->nu < MAXUSAGE)
					s->usages[s->nu++] = dval;
				/* else XXX */
d448 4
a451 5
				s->minset = 1;
				if (bSize == 1)
					dval = c->_usage_page | (dval&0xff);
				else if (bSize == 2)
					dval = c->_usage_page | (dval&0xffff);
d453 2
a454 1
				break;
d456 4
a459 4
				if (bSize == 1)
					dval = c->_usage_page | (dval&0xff);
				else if (bSize == 2)
					dval = c->_usage_page | (dval&0xffff);
d461 18
d502 1
a502 1
				printf("Local bTag=%d\n", bTag);
d507 1
a507 1
			printf("default bType=%d\n", bType);
d511 1
d515 1
a515 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t id)
d523 1
a523 1
	DPRINTFN(2,("hid_report_size: kind=%d id=%d\n", k, id));
d525 4
a528 4
		DPRINTFN(2,("hid_report_size: item kind=%d id=%d pos=%d "
			    "size=%d count=%d\n",
			    h.kind, h.report_ID, h.loc.pos, h.loc.size,
			    h.loc.count));
d539 2
a540 1
			DPRINTFN(2,("hid_report_size: lo=%d hi=%d\n", lo, hi));
d548 2
a549 2
hid_locate(void *desc, int size, u_int32_t u, u_int8_t id, enum hid_kind k,
	   struct hid_location *loc, u_int32_t *flags)
d555 1
a555 1
	DPRINTFN(5,("hid_locate: enter usage=0x%x kind=%d id=%d\n", u, k, id));
d557 2
a558 2
		DPRINTFN(5,("hid_locate: usage=0x%x kind=%d id=%d flags=0x%x\n",
			    h.usage, h.kind, h.report_ID, h.flags));
d572 2
d577 2
a578 2
u_long
hid_get_data(u_char *buf, struct hid_location *loc)
d580 5
a584 4
	u_int hpos = loc->pos;
	u_int hsize = loc->size;
	u_int32_t data;
	int i, s;
d586 1
a586 1
	DPRINTFN(10, ("hid_get_data: loc %d/%d\n", hpos, hsize));
d588 1
d591 2
d594 1
d596 17
a612 10
	s = hpos / 8;
	for (i = hpos; i < hpos+hsize; i += 8)
		data |= buf[i / 8] << ((i / 8 - s) * 8);
	data >>= hpos % 8;
	data &= (1 << hsize) - 1;
	hsize = 32 - hsize;
	/* Sign extend */
	data = ((int32_t)data << hsize) >> hsize;
	DPRINTFN(10,("hid_get_data: loc %d/%d = %lu\n",
		    loc->pos, loc->size, (long)data));
d617 1
a617 1
hid_is_collection(void *desc, int size, u_int8_t id, u_int32_t usage)
d621 1
a621 1
	u_int32_t coll_usage = ~0;
d627 1
a627 1
	DPRINTFN(2,("hid_is_collection: id=%d usage=0x%x\n", id, usage));
d629 2
a630 3
		DPRINTFN(2,("hid_is_collection: kind=%d id=%d usage=0x%x"
			    "(0x%x)\n",
			    hi.kind, hi.report_ID, hi.usage, coll_usage));
d635 2
a636 3
		    coll_usage == usage &&
		    hi.report_ID == id) {
			DPRINTFN(2,("hid_is_collection: found\n"));
d641 1
a641 1
	DPRINTFN(2,("hid_is_collection: not found\n"));
@


1.24
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.23 2011/04/05 15:03:02 miod Exp $ */
a176 1
			dval = /*(int16_t)*/ dval;
@


1.23
log
@hid_locate() is supposed to accept the last two arguments being NULL, so
correctly handle this in the failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.22 2009/07/24 08:37:47 jsg Exp $ */
a91 2
	if (s == NULL)
		panic("hid_start_parse");
@


1.22
log
@Global Item #3 should be Physical Minimum not Maximum according
to the HID spec.

From FreeBSD hid.c rev 1.31
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.21 2008/06/26 05:42:18 ray Exp $ */
d424 2
a425 1
	loc->size = 0;
@


1.21
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.20 2007/09/11 13:39:34 gilles Exp $ */
d271 1
a271 1
				c->physical_maximum = dval;
@


1.20
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.19 2007/09/09 01:00:35 fgsch Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.19
log
@more M_ZERO conversions; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.18 2007/06/05 08:43:55 mbalmer Exp $ */
d98 1
a98 1
	s = malloc(sizeof *s, M_TEMP, M_WAITOK|M_ZERO);
@


1.18
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.17 2007/06/04 10:34:04 mbalmer Exp $ */
d98 1
a98 1
	s = malloc(sizeof *s, M_TEMP, M_WAITOK);
a100 1
	memset(s, 0, sizeof *s);
@


1.17
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.16 2007/05/21 05:40:27 jsg Exp $ */
d60 1
a60 1
Static void hid_clear_local(struct hid_item *);
d76 1
a76 1
Static void
@


1.16
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.15 2004/07/08 22:18:44 deraadt Exp $ */
a43 3
#if defined(__NetBSD__)
#include <sys/kernel.h>
#endif
@


1.15
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.14 2002/07/25 04:07:32 nate Exp $ */
d55 2
a56 2
#define DPRINTF(x)	do { if (uhidevdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhidevdebug>(n)) logprintf x; } while (0)
@


1.14
log
@update $NetBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.13 2002/07/25 02:18:10 nate Exp $ */
d55 2
a56 2
#define DPRINTF(x)	if (uhidevdebug) logprintf x
#define DPRINTFN(n,x)	if (uhidevdebug>(n)) logprintf x
@


1.13
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.12 2002/05/09 15:06:29 nate Exp $ */
/*	$NetBSD: hid.c,v 1.22 2002/01/12 17:11:03 tsutsui Exp $	*/
@


1.12
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.11 2002/05/07 18:29:18 nate Exp $ */
d48 1
a48 1
 
d202 1
a202 1
		
d224 2
a225 2
						for (i = c->usage_minimum; 
						     i <= c->usage_maximum; 
d238 1
a238 1
					c->loc.pos += 
d323 1
a323 1
				if (bSize == 1) 
d325 1
a325 1
				else if (bSize == 2) 
d334 1
a334 1
				if (bSize == 1) 
d336 1
a336 1
				else if (bSize == 2) 
d341 1
a341 1
				if (bSize == 1) 
d343 1
a343 1
				else if (bSize == 2) 
d424 1
a424 1
		if (h.kind == k && !(h.flags & HIO_CONST) && 
d453 1
a453 1
	s = hpos / 8; 
d461 1
a461 1
	DPRINTFN(10,("hid_get_data: loc %d/%d = %lu\n", 
d482 1
a482 1
		if (hi.kind == hid_collection && 
@


1.11
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.9 2000/11/08 18:10:37 aaron Exp $ */
/*	$NetBSD: hid.c,v 1.16 2000/06/01 14:28:57 augustss Exp $	*/
d54 4
a57 4
#ifdef UHID_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int usbdebug;
d65 1
a65 1
#define MAXUSAGE 100
d76 1
a76 1
	int kindset;
d83 1
d97 1
a97 1
hid_start_parse(void *d, int len, int kindset)
d102 2
d105 1
d108 1
a108 1
	s->kindset = kindset;
d135 1
d138 2
d146 2
a147 1
			h->next = 0;
d185 1
a185 1
			dval = (int8_t)*data++;
d190 1
a190 1
			dval = (int16_t)dval;
d203 2
d209 6
a214 1
				if (!(s->kindset & (1 << hid_input)))
d216 2
a217 1
				c->kind = hid_input;
a218 1
			ret:
d235 1
d237 1
a237 1
					h->next = 0;
d239 3
a241 1
						c->loc.size * c->loc.count;
a242 1
					s->minset = 0;
d246 1
a246 4
				if (!(s->kindset & (1 << hid_output)))
					continue;
				c->kind = hid_output;
				c->flags = dval;
d257 1
a257 4
				if (!(s->kindset & (1 << hid_feature)))
					continue;
				c->kind = hid_feature;
				c->flags = dval;
a262 1
				hid_clear_local(c);
d298 1
d381 1
a381 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t *idp)
d385 1
a385 1
	int size, id;
d387 21
a407 4
	id = 0;
	for (d = hid_start_parse(buf, len, 1<<k); hid_get_item(d, &h); )
		if (h.report_ID != 0)
			id = h.report_ID;
d409 1
a409 7
	size = h.loc.pos;
	if (id != 0) {
		size += 8;
		*idp = id;	/* XXX wrong */
	} else
		*idp = 0;
	return ((size + 7) / 8);
d413 1
a413 1
hid_locate(void *desc, int size, u_int32_t u, enum hid_kind k,
d419 7
a425 2
	for (d = hid_start_parse(desc, size, 1<<k); hid_get_item(d, &h); ) {
		if (h.kind == k && !(h.flags & HIO_CONST) && h.usage == u) {
d467 1
a467 1
hid_is_collection(void *desc, int size, u_int32_t usage)
d471 1
a471 1
	int err;
d473 1
a473 1
	hd = hid_start_parse(desc, size, hid_input);
d477 17
a493 3
	err = hid_get_item(hd, &hi) &&
	    hi.kind == hid_collection &&
	    hi.usage == usage;
d495 1
a495 1
	return (err);
@


1.10
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: hid.c,v 1.22 2002/01/12 17:11:03 tsutsui Exp $	*/
d54 4
a57 4
#ifdef UHIDEV_DEBUG
#define DPRINTF(x)	if (uhidevdebug) logprintf x
#define DPRINTFN(n,x)	if (uhidevdebug>(n)) logprintf x
extern int uhidevdebug;
d65 1
a65 1
#define MAXUSAGE 256
d76 1
a76 1
	enum hid_kind kind;
a82 1
	DPRINTFN(5,("hid_clear_local\n"));
d96 1
a96 1
hid_start_parse(void *d, int len, enum hid_kind kind)
a100 2
	if (s == NULL)
		panic("hid_start_parse");
a101 1

d104 1
a104 1
	s->kind = kind;
a130 1
	enum hid_kind retkind;
a132 2
	DPRINTFN(5,("hid_get_item: multi=%d multimax=%d\n",
		    s->multi, s->multimax));
d139 1
a139 2
			h->next = NULL;
			DPRINTFN(5,("return multi\n"));
d177 1
a177 1
			dval = /*(int8_t)*/ *data++;
d182 1
a182 1
			dval = /*(int16_t)*/ dval;
a194 2
		DPRINTFN(5,("hid_get_item: bType=%d bTag=%d dval=%d\n",
			 bType, bTag, dval));
d199 1
a199 6
				retkind = hid_input;
			ret:
				if (s->kind != retkind) {
					s->minset = 0;
					s->nu = 0;
					hid_clear_local(c);
d201 1
a201 2
				}
				c->kind = retkind;
d203 1
a219 1
					c->usage = c->_usage_page; /* XXX */
d221 1
a221 1
					h->next = NULL;
d223 2
a224 1
					    c->loc.size * c->loc.count;
a225 2
					s->nu = 0;
					hid_clear_local(c);
d229 4
a232 1
				retkind = hid_output;
d243 4
a246 1
				retkind = hid_feature;
d252 1
a287 1
				c->loc.pos = 0;
d370 1
a370 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t id)
d374 1
a374 1
	int lo, hi;
d376 4
a379 21
	h.report_ID = 0;
	lo = hi = -1;
	DPRINTFN(2,("hid_report_size: kind=%d id=%d\n", k, id));
	for (d = hid_start_parse(buf, len, k); hid_get_item(d, &h); ) {
		DPRINTFN(2,("hid_report_size: item kind=%d id=%d pos=%d "
			    "size=%d count=%d\n",
			    h.kind, h.report_ID, h.loc.pos, h.loc.size,
			    h.loc.count));
		if (h.report_ID == id && h.kind == k) {
			if (lo < 0) {
				lo = h.loc.pos;
#ifdef DIAGNOSTIC
				if (lo != 0) {
					printf("hid_report_size: lo != 0\n");
				}
#endif
			}
			hi = h.loc.pos + h.loc.size * h.loc.count;
			DPRINTFN(2,("hid_report_size: lo=%d hi=%d\n", lo, hi));
		}
	}
d381 7
a387 1
	return ((hi - lo + 7) / 8);
d391 1
a391 1
hid_locate(void *desc, int size, u_int32_t u, u_int8_t id, enum hid_kind k,
d397 2
a398 7
	h.report_ID = 0;
	DPRINTFN(5,("hid_locate: enter usage=0x%x kind=%d id=%d\n", u, k, id));
	for (d = hid_start_parse(desc, size, k); hid_get_item(d, &h); ) {
		DPRINTFN(5,("hid_locate: usage=0x%x kind=%d id=%d flags=0x%x\n",
			    h.usage, h.kind, h.report_ID, h.flags));
		if (h.kind == k && !(h.flags & HIO_CONST) && 
		    h.usage == u && h.report_ID == id) {
d440 1
a440 1
hid_is_collection(void *desc, int size, u_int8_t id, u_int32_t usage)
d444 1
a444 1
	u_int32_t coll_usage = ~0;
d446 1
a446 1
	hd = hid_start_parse(desc, size, hid_none);
d450 3
a452 17
	DPRINTFN(2,("hid_is_collection: id=%d usage=0x%x\n", id, usage));
	while (hid_get_item(hd, &hi)) {
		DPRINTFN(2,("hid_is_collection: kind=%d id=%d usage=0x%x"
			    "(0x%x)\n",
			    hi.kind, hi.report_ID, hi.usage, coll_usage));
		if (hi.kind == hid_collection && 
		    hi.collection == HCOLL_APPLICATION)
			coll_usage = hi.usage;
		if (hi.kind == hid_endcollection &&
		    coll_usage == usage &&
		    hi.report_ID == id) {
			DPRINTFN(2,("hid_is_collection: found\n"));
			hid_end_parse(hd);
			return (1);
		}
	}
	DPRINTFN(2,("hid_is_collection: not found\n"));
d454 1
a454 1
	return (0);
@


1.9
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.8 2000/07/04 11:44:21 fgsch Exp $ */
/*	$NetBSD: hid.c,v 1.16 2000/06/01 14:28:57 augustss Exp $	*/
d54 4
a57 4
#ifdef UHID_DEBUG
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int usbdebug;
d65 1
a65 1
#define MAXUSAGE 100
d76 1
a76 1
	int kindset;
d83 1
d97 1
a97 1
hid_start_parse(void *d, int len, int kindset)
d102 2
d105 1
d108 1
a108 1
	s->kindset = kindset;
d135 1
d138 2
d146 2
a147 1
			h->next = 0;
d185 1
a185 1
			dval = (int8_t)*data++;
d190 1
a190 1
			dval = (int16_t)dval;
d203 2
d209 6
a214 1
				if (!(s->kindset & (1 << hid_input)))
d216 2
a217 1
				c->kind = hid_input;
a218 1
			ret:
d235 1
d237 1
a237 1
					h->next = 0;
d239 3
a241 1
						c->loc.size * c->loc.count;
a242 1
					s->minset = 0;
d246 1
a246 4
				if (!(s->kindset & (1 << hid_output)))
					continue;
				c->kind = hid_output;
				c->flags = dval;
d257 1
a257 4
				if (!(s->kindset & (1 << hid_feature)))
					continue;
				c->kind = hid_feature;
				c->flags = dval;
a262 1
				hid_clear_local(c);
d298 1
d381 1
a381 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t *idp)
d385 1
a385 1
	int size, id;
d387 21
a407 4
	id = 0;
	for (d = hid_start_parse(buf, len, 1<<k); hid_get_item(d, &h); )
		if (h.report_ID != 0)
			id = h.report_ID;
d409 1
a409 7
	size = h.loc.pos;
	if (id != 0) {
		size += 8;
		*idp = id;	/* XXX wrong */
	} else
		*idp = 0;
	return ((size + 7) / 8);
d413 1
a413 1
hid_locate(void *desc, int size, u_int32_t u, enum hid_kind k,
d419 7
a425 2
	for (d = hid_start_parse(desc, size, 1<<k); hid_get_item(d, &h); ) {
		if (h.kind == k && !(h.flags & HIO_CONST) && h.usage == u) {
d467 1
a467 1
hid_is_collection(void *desc, int size, u_int32_t usage)
d471 1
a471 1
	int err;
d473 1
a473 1
	hd = hid_start_parse(desc, size, hid_input);
d477 17
a493 3
	err = hid_get_item(hd, &hi) &&
	    hi.kind == hid_collection &&
	    hi.usage == usage;
d495 1
a495 1
	return (err);
@


1.9.6.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: hid.c,v 1.22 2002/01/12 17:11:03 tsutsui Exp $	*/
d54 4
a57 4
#ifdef UHIDEV_DEBUG
#define DPRINTF(x)	if (uhidevdebug) logprintf x
#define DPRINTFN(n,x)	if (uhidevdebug>(n)) logprintf x
extern int uhidevdebug;
d65 1
a65 1
#define MAXUSAGE 256
d76 1
a76 1
	enum hid_kind kind;
a82 1
	DPRINTFN(5,("hid_clear_local\n"));
d96 1
a96 1
hid_start_parse(void *d, int len, enum hid_kind kind)
a100 2
	if (s == NULL)
		panic("hid_start_parse");
a101 1

d104 1
a104 1
	s->kind = kind;
a130 1
	enum hid_kind retkind;
a132 2
	DPRINTFN(5,("hid_get_item: multi=%d multimax=%d\n",
		    s->multi, s->multimax));
d139 1
a139 2
			h->next = NULL;
			DPRINTFN(5,("return multi\n"));
d177 1
a177 1
			dval = /*(int8_t)*/ *data++;
d182 1
a182 1
			dval = /*(int16_t)*/ dval;
a194 2
		DPRINTFN(5,("hid_get_item: bType=%d bTag=%d dval=%d\n",
			 bType, bTag, dval));
d199 1
a199 6
				retkind = hid_input;
			ret:
				if (s->kind != retkind) {
					s->minset = 0;
					s->nu = 0;
					hid_clear_local(c);
d201 1
a201 2
				}
				c->kind = retkind;
d203 1
a219 1
					c->usage = c->_usage_page; /* XXX */
d221 1
a221 1
					h->next = NULL;
d223 2
a224 1
					    c->loc.size * c->loc.count;
a225 2
					s->nu = 0;
					hid_clear_local(c);
d229 4
a232 1
				retkind = hid_output;
d243 4
a246 1
				retkind = hid_feature;
d252 1
a287 1
				c->loc.pos = 0;
d370 1
a370 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t id)
d374 1
a374 1
	int lo, hi;
d376 4
a379 21
	h.report_ID = 0;
	lo = hi = -1;
	DPRINTFN(2,("hid_report_size: kind=%d id=%d\n", k, id));
	for (d = hid_start_parse(buf, len, k); hid_get_item(d, &h); ) {
		DPRINTFN(2,("hid_report_size: item kind=%d id=%d pos=%d "
			    "size=%d count=%d\n",
			    h.kind, h.report_ID, h.loc.pos, h.loc.size,
			    h.loc.count));
		if (h.report_ID == id && h.kind == k) {
			if (lo < 0) {
				lo = h.loc.pos;
#ifdef DIAGNOSTIC
				if (lo != 0) {
					printf("hid_report_size: lo != 0\n");
				}
#endif
			}
			hi = h.loc.pos + h.loc.size * h.loc.count;
			DPRINTFN(2,("hid_report_size: lo=%d hi=%d\n", lo, hi));
		}
	}
d381 7
a387 1
	return ((hi - lo + 7) / 8);
d391 1
a391 1
hid_locate(void *desc, int size, u_int32_t u, u_int8_t id, enum hid_kind k,
d397 2
a398 7
	h.report_ID = 0;
	DPRINTFN(5,("hid_locate: enter usage=0x%x kind=%d id=%d\n", u, k, id));
	for (d = hid_start_parse(desc, size, k); hid_get_item(d, &h); ) {
		DPRINTFN(5,("hid_locate: usage=0x%x kind=%d id=%d flags=0x%x\n",
			    h.usage, h.kind, h.report_ID, h.flags));
		if (h.kind == k && !(h.flags & HIO_CONST) && 
		    h.usage == u && h.report_ID == id) {
d440 1
a440 1
hid_is_collection(void *desc, int size, u_int8_t id, u_int32_t usage)
d444 1
a444 1
	u_int32_t coll_usage = ~0;
d446 1
a446 1
	hd = hid_start_parse(desc, size, hid_none);
d450 3
a452 17
	DPRINTFN(2,("hid_is_collection: id=%d usage=0x%x\n", id, usage));
	while (hid_get_item(hd, &hi)) {
		DPRINTFN(2,("hid_is_collection: kind=%d id=%d usage=0x%x"
			    "(0x%x)\n",
			    hi.kind, hi.report_ID, hi.usage, coll_usage));
		if (hi.kind == hid_collection && 
		    hi.collection == HCOLL_APPLICATION)
			coll_usage = hi.usage;
		if (hi.kind == hid_endcollection &&
		    coll_usage == usage &&
		    hi.report_ID == id) {
			DPRINTFN(2,("hid_is_collection: found\n"));
			hid_end_parse(hd);
			return (1);
		}
	}
	DPRINTFN(2,("hid_is_collection: not found\n"));
d454 1
a454 1
	return (0);
@


1.9.6.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: hid.c,v 1.23 2002/07/11 21:14:25 augustss Exp $	*/
d48 1
a48 1

d202 1
a202 1

d224 2
a225 2
						for (i = c->usage_minimum;
						     i <= c->usage_maximum;
d238 1
a238 1
					c->loc.pos +=
d323 1
a323 1
				if (bSize == 1)
d325 1
a325 1
				else if (bSize == 2)
d334 1
a334 1
				if (bSize == 1)
d336 1
a336 1
				else if (bSize == 2)
d341 1
a341 1
				if (bSize == 1)
d343 1
a343 1
				else if (bSize == 2)
d424 1
a424 1
		if (h.kind == k && !(h.flags & HIO_CONST) &&
d453 1
a453 1
	s = hpos / 8;
d461 1
a461 1
	DPRINTFN(10,("hid_get_data: loc %d/%d = %lu\n",
d482 1
a482 1
		if (hi.kind == hid_collection &&
@


1.8
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.7 2000/04/14 22:50:24 aaron Exp $ */
/*	$NetBSD: hid.c,v 1.14 2000/04/06 22:58:32 augustss Exp $	*/
d63 1
a63 1
Static void hid_clear_local __P((struct hid_item *));
d80 1
a80 2
hid_clear_local(c)
	struct hid_item *c;
d96 1
a96 4
hid_start_parse(d, len, kindset)
	void *d;
	int len;
	int kindset;
d109 1
a109 2
hid_end_parse(s)
	struct hid_data *s;
d121 1
a121 3
hid_get_item(s, h)
	struct hid_data *s;
	struct hid_item *h;
d370 1
a370 5
hid_report_size(buf, len, k, idp)
	void *buf;
	int len;
	enum hid_kind k;
	u_int8_t *idp;
d391 2
a392 7
hid_locate(desc, size, u, k, loc, flags)
	void *desc;
	int size;
	u_int32_t u;
	enum hid_kind k;
	struct hid_location *loc;
	u_int32_t *flags;
d413 1
a413 3
hid_get_data(buf, loc)
	u_char *buf;
	struct hid_location *loc;
d440 1
a440 4
hid_is_collection(desc, size, usage)
	void *desc;
	int size;
	u_int32_t usage;
@


1.7
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.6 2000/03/30 16:19:32 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d83 1
d116 1
@


1.6
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.5 2000/03/28 19:37:46 aaron Exp $ */
/*	$NetBSD: hid.c,v 1.13 2000/03/27 12:33:53 augustss Exp $	*/
d130 1
a130 1
	struct hid_location oldloc;
d304 1
a304 1
				oldloc = c->loc;
d306 1
a306 1
				c->loc = oldloc;
@


1.5
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: hid.c,v 1.12 2000/03/17 18:16:18 augustss Exp $	*/
d63 1
a63 1
static void hid_clear_local __P((struct hid_item *));
d79 1
a79 1
static void
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.3 1999/11/07 21:30:18 fgsch Exp $	*/
d3 1
d44 1
a44 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d374 1
a374 1
int 
@


1.3
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: hid.c,v 1.2 1999/08/16 22:08:48 fgsch Exp $	*/
/*	$NetBSD: hid.c,v 1.7 1999/01/08 11:58:25 augustss Exp $	*/
d43 1
d45 1
a46 3
#if defined(__FreeBSD__)
#include <sys/bus.h>
#endif
d114 1
a114 1
	while (s->cur.next) {
d128 2
a129 1
	int bTag, bType, bSize;
d137 1
a137 1
	if (s->multimax) {
d303 1
d305 1
d386 1
a386 1
		if (h.report_ID)
d390 1
a390 1
	if (id) {
d412 1
a412 1
			if (loc)
d414 1
a414 1
			if (flags)
d462 1
a462 1
	int r;
d465 1
a465 1
	if (!hd)
d468 1
a468 1
	r = hid_get_item(hd, &hi) &&
d472 1
a472 1
	return (r);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: hid.c,v 1.9 2000/11/08 18:10:37 aaron Exp $ */
/*	$NetBSD: hid.c,v 1.16 2000/06/01 14:28:57 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/hid.c,v 1.11 1999/11/17 22:33:39 n_hibma Exp $ */
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a42 1
#if defined(__NetBSD__)
d44 3
a47 1
#include <sys/malloc.h>
d63 1
a63 1
Static void hid_clear_local(struct hid_item *);
d79 3
a81 2
Static void
hid_clear_local(struct hid_item *c)
a82 1

d96 4
a99 1
hid_start_parse(void *d, int len, int kindset)
d112 2
a113 1
hid_end_parse(struct hid_data *s)
d115 1
a115 2

	while (s->cur.next != NULL) {
d124 3
a126 1
hid_get_item(struct hid_data *s, struct hid_item *h)
d129 1
a129 2
	unsigned int bTag, bType, bSize;
	u_int32_t oldpos;
d137 1
a137 1
	if (s->multimax != 0) {
a302 1
				oldpos = c->loc.pos;
a303 1
				c->loc.pos = oldpos;
d371 6
a376 2
int
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t *idp)
d384 1
a384 1
		if (h.report_ID != 0)
d388 1
a388 1
	if (id != 0) {
d397 7
a403 2
hid_locate(void *desc, int size, u_int32_t u, enum hid_kind k,
	   struct hid_location *loc, u_int32_t *flags)
d410 1
a410 1
			if (loc != NULL)
d412 1
a412 1
			if (flags != NULL)
d424 3
a426 1
hid_get_data(u_char *buf, struct hid_location *loc)
d453 4
a456 1
hid_is_collection(void *desc, int size, u_int32_t usage)
d460 1
a460 1
	int err;
d463 1
a463 1
	if (hd == NULL)
d466 1
a466 1
	err = hid_get_item(hd, &hi) &&
d470 1
a470 1
	return (err);
@


1.3.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: hid.c,v 1.23 2002/07/11 21:14:25 augustss Exp $	*/
d48 1
a48 1

d54 4
a57 4
#ifdef UHIDEV_DEBUG
#define DPRINTF(x)	if (uhidevdebug) logprintf x
#define DPRINTFN(n,x)	if (uhidevdebug>(n)) logprintf x
extern int uhidevdebug;
d65 1
a65 1
#define MAXUSAGE 256
d76 1
a76 1
	enum hid_kind kind;
a82 1
	DPRINTFN(5,("hid_clear_local\n"));
d96 1
a96 1
hid_start_parse(void *d, int len, enum hid_kind kind)
a100 2
	if (s == NULL)
		panic("hid_start_parse");
a101 1

d104 1
a104 1
	s->kind = kind;
a130 1
	enum hid_kind retkind;
a132 2
	DPRINTFN(5,("hid_get_item: multi=%d multimax=%d\n",
		    s->multi, s->multimax));
d139 1
a139 2
			h->next = NULL;
			DPRINTFN(5,("return multi\n"));
d177 1
a177 1
			dval = /*(int8_t)*/ *data++;
d182 1
a182 1
			dval = /*(int16_t)*/ dval;
d194 1
a194 3

		DPRINTFN(5,("hid_get_item: bType=%d bTag=%d dval=%d\n",
			 bType, bTag, dval));
d199 1
a199 6
				retkind = hid_input;
			ret:
				if (s->kind != retkind) {
					s->minset = 0;
					s->nu = 0;
					hid_clear_local(c);
d201 1
a201 2
				}
				c->kind = retkind;
d203 1
d209 2
a210 2
						for (i = c->usage_minimum;
						     i <= c->usage_maximum;
a219 1
					c->usage = c->_usage_page; /* XXX */
d221 4
a224 3
					h->next = NULL;
					c->loc.pos +=
					    c->loc.size * c->loc.count;
a225 2
					s->nu = 0;
					hid_clear_local(c);
d229 4
a232 1
				retkind = hid_output;
d243 4
a246 1
				retkind = hid_feature;
d252 1
a287 1
				c->loc.pos = 0;
d312 1
a312 1
				if (bSize == 1)
d314 1
a314 1
				else if (bSize == 2)
d323 1
a323 1
				if (bSize == 1)
d325 1
a325 1
				else if (bSize == 2)
d330 1
a330 1
				if (bSize == 1)
d332 1
a332 1
				else if (bSize == 2)
d370 1
a370 1
hid_report_size(void *buf, int len, enum hid_kind k, u_int8_t id)
d374 1
a374 1
	int lo, hi;
d376 4
a379 21
	h.report_ID = 0;
	lo = hi = -1;
	DPRINTFN(2,("hid_report_size: kind=%d id=%d\n", k, id));
	for (d = hid_start_parse(buf, len, k); hid_get_item(d, &h); ) {
		DPRINTFN(2,("hid_report_size: item kind=%d id=%d pos=%d "
			    "size=%d count=%d\n",
			    h.kind, h.report_ID, h.loc.pos, h.loc.size,
			    h.loc.count));
		if (h.report_ID == id && h.kind == k) {
			if (lo < 0) {
				lo = h.loc.pos;
#ifdef DIAGNOSTIC
				if (lo != 0) {
					printf("hid_report_size: lo != 0\n");
				}
#endif
			}
			hi = h.loc.pos + h.loc.size * h.loc.count;
			DPRINTFN(2,("hid_report_size: lo=%d hi=%d\n", lo, hi));
		}
	}
d381 7
a387 1
	return ((hi - lo + 7) / 8);
d391 1
a391 1
hid_locate(void *desc, int size, u_int32_t u, u_int8_t id, enum hid_kind k,
d397 2
a398 7
	h.report_ID = 0;
	DPRINTFN(5,("hid_locate: enter usage=0x%x kind=%d id=%d\n", u, k, id));
	for (d = hid_start_parse(desc, size, k); hid_get_item(d, &h); ) {
		DPRINTFN(5,("hid_locate: usage=0x%x kind=%d id=%d flags=0x%x\n",
			    h.usage, h.kind, h.report_ID, h.flags));
		if (h.kind == k && !(h.flags & HIO_CONST) &&
		    h.usage == u && h.report_ID == id) {
d426 1
a426 1
	s = hpos / 8;
d434 1
a434 1
	DPRINTFN(10,("hid_get_data: loc %d/%d = %lu\n",
d440 1
a440 1
hid_is_collection(void *desc, int size, u_int8_t id, u_int32_t usage)
d444 1
a444 1
	u_int32_t coll_usage = ~0;
d446 1
a446 1
	hd = hid_start_parse(desc, size, hid_none);
d450 3
a452 17
	DPRINTFN(2,("hid_is_collection: id=%d usage=0x%x\n", id, usage));
	while (hid_get_item(hd, &hi)) {
		DPRINTFN(2,("hid_is_collection: kind=%d id=%d usage=0x%x"
			    "(0x%x)\n",
			    hi.kind, hi.report_ID, hi.usage, coll_usage));
		if (hi.kind == hid_collection &&
		    hi.collection == HCOLL_APPLICATION)
			coll_usage = hi.usage;
		if (hi.kind == hid_endcollection &&
		    coll_usage == usage &&
		    hi.report_ID == id) {
			DPRINTFN(2,("hid_is_collection: found\n"));
			hid_end_parse(hd);
			return (1);
		}
	}
	DPRINTFN(2,("hid_is_collection: not found\n"));
d454 1
a454 1
	return (0);
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 1
a1 1
/*	$OpenBSD: hid.c,v 1.1 1999/08/13 05:28:03 fgsch Exp $	*/
d54 1
a54 1
#ifdef USB_DEBUG
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a56 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
@

