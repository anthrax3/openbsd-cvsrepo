head	1.49;
access;
symbols
	OPENBSD_5_4:1.48.0.2
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.46.0.8
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.6
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.44.0.2
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.8
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.4
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.12
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.49
date	2013.08.20.14.27.33;	author ajacoutot;	state dead;
branches;
next	1.48;

1.48
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.44;

1.44
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.03.03.59.17;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.26.18.34.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.10.17.30.26;	author ajacoutot;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.06.17.25.15;	author ajacoutot;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.11.12.36.53;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.11.09.26.55;	author mk;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.31.18.20.22;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.01.10.33.12;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.17.17.22.58;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.12.12.03.51;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.10.21.41.51;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.09.16.28.02;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.22.23.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.31.04.24.45;	author nate;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.01.28.09.43.43;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.16.19.40.17;	author aaron;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.27;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.44.05;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.06.02.11.48;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Remove uscanner(4). It was disabled in GENERIC more than 2.5 years ago.
No regression has been reported since libusb became the prefered
solution to work with USB scanners.

req. by mpi@@
ok ian@@ mpi@@ miod@@
@
text
@/*	$OpenBSD: uscanner.c,v 1.48 2013/04/15 09:23:02 mglocker Exp $ */
/*	$NetBSD: uscanner.c,v 1.40 2003/01/27 00:32:44 wiz Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology
 * and Nick Hibma (n_hibma@@qubesoft.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>
#include <sys/poll.h>
#include <sys/conf.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/usbdevs.h>

#ifdef USCANNER_DEBUG
#define DPRINTF(x)	do { if (uscannerdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uscannerdebug>(n)) printf x; } while (0)
int	uscannerdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct uscan_info {
	struct usb_devno devno;
	u_int flags;
#define USC_KEEP_OPEN 1
};

/* Table of scanners that may work with this driver. */
static const struct uscan_info uscanner_devs[] = {
  /* Acer Peripherals */
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U }, 0 },

  /* AGFA */
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1236U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE40 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE50 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE20 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE25 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE26 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE52 }, 0 },

  /* Avision */
 {{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U }, 0 },

  /* Canon */
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U }, 0 },
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N670U }, 0 },
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N1220U }, 0 },
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N1240U }, 0 },

  /* Kye */
 {{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO }, 0 },

  /* HP */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_2200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C }, 0 },

  /* Mustek */
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_BEARPAW1200F }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200UB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USBPLUS }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CUPLUS }, 0 },

  /* National */
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 }, 0 },
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW2400 }, 0 },

  /* Primax */
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_6200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 }, 0 },

  /* Epson */
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1260 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1660 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_2400 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_DX3800 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_DX4000 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_DX5000 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_DX6000 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_CX5400 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_GT9700F }, USC_KEEP_OPEN },

  /* UMAX */
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 }, 0 },

  /* Visioneer */
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_3000 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 }, 0 },

  /* Ultima */
 {{ USB_VENDOR_ULTIMA, USB_PRODUCT_ULTIMA_1200UBPLUS }, 0 },

};
#define uscanner_lookup(v, p) ((const struct uscan_info *)usb_lookup(uscanner_devs, v, p))

#define	USCANNER_BUFFERSIZE	1024

struct uscanner_softc {
	struct device		sc_dev;		/* base device */
	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;

	u_int			sc_dev_flags;

	struct usbd_pipe	*sc_bulkin_pipe;
	int			sc_bulkin;
	struct usbd_xfer	*sc_bulkin_xfer;
	void 			*sc_bulkin_buffer;
	int			sc_bulkin_bufferlen;
	int			sc_bulkin_datalen;

	struct usbd_pipe	*sc_bulkout_pipe;
	int			sc_bulkout;
	struct usbd_xfer	*sc_bulkout_xfer;
	void 			*sc_bulkout_buffer;
	int			sc_bulkout_bufferlen;
	int			sc_bulkout_datalen;

	struct selinfo		sc_selq;

	u_char			sc_state;
#define USCANNER_OPEN		0x01	/* opened */

	int			sc_refcnt;
	u_char			sc_dying;
};

int uscanner_do_read(struct uscanner_softc *, struct uio *, int);
int uscanner_do_write(struct uscanner_softc *, struct uio *, int);
void uscanner_do_close(struct uscanner_softc *);

#define USCANNERUNIT(n) (minor(n))

int uscanner_match(struct device *, void *, void *); 
void uscanner_attach(struct device *, struct device *, void *); 
int uscanner_detach(struct device *, int); 
int uscanner_activate(struct device *, int); 

struct cfdriver uscanner_cd = { 
	NULL, "uscanner", DV_DULL 
}; 

const struct cfattach uscanner_ca = { 
	sizeof(struct uscanner_softc), 
	uscanner_match, 
	uscanner_attach, 
	uscanner_detach, 
	uscanner_activate, 
};

int
uscanner_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	if (uaa->iface == NULL)
		return UMATCH_NONE; /* do not grab the entire device */

	if (uscanner_lookup(uaa->vendor, uaa->product) == NULL)
		return UMATCH_NONE; /* not in the list of known devices */
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return UMATCH_NONE;

	/*
	* There isn't a specific UICLASS for scanners, many vendors use
	* UICLASS_VENDOR, so detecting the right interface is not so easy.
	* But certainly we can exclude PRINTER and MASS - which some
	* multifunction devices implement.
	*/
	if (id->bInterfaceClass == UICLASS_PRINTER ||
	    id->bInterfaceClass == UICLASS_MASS)
		return UMATCH_NONE;

	return UMATCH_VENDOR_PRODUCT;
}

void
uscanner_attach(struct device *parent, struct device *self, void *aux)
{
	struct uscanner_softc *sc = (struct uscanner_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id = 0;
	usb_endpoint_descriptor_t *ed, *ed_bulkin = NULL, *ed_bulkout = NULL;
	int i;
	usbd_status err;
	int ifnum;

	sc->sc_dev_flags = uscanner_lookup(uaa->vendor, uaa->product)->flags;

	sc->sc_udev = uaa->device;

	id = usbd_get_interface_descriptor(uaa->iface);
	ifnum = id->bInterfaceNumber;

	err = usbd_device2interface_handle(sc->sc_udev, ifnum, &sc->sc_iface);
	if (!err && sc->sc_iface)
	    id = usbd_get_interface_descriptor(sc->sc_iface);
	if (err || id == 0) {
		printf("%s: could not get interface descriptor, err=%d,id=%p\n",
		       sc->sc_dev.dv_xname, err, id);
		return;
	}

	/* Find the two first bulk endpoints */
	for (i = 0 ; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == 0) {
			printf("%s: could not read endpoint descriptor\n",
			       sc->sc_dev.dv_xname);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
			ed_bulkin = ed;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT
		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
		        ed_bulkout = ed;
		}

		if (ed_bulkin && ed_bulkout)	/* found all we need */
			break;
	}

	/* Verify that we goething sensible */
	if (ed_bulkin == NULL || ed_bulkout == NULL) {
		printf("%s: bulk-in and/or bulk-out endpoint not found\n",
			sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_bulkin = ed_bulkin->bEndpointAddress;
	sc->sc_bulkout = ed_bulkout->bEndpointAddress;
}

int
uscanneropen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct uscanner_softc *sc;
	int unit = USCANNERUNIT(dev);
	usbd_status err;

	if (unit >= uscanner_cd.cd_ndevs)
		return (ENXIO);
	sc = uscanner_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

 	DPRINTFN(5, ("uscanneropen: flag=%d, mode=%d, unit=%d\n",
		     flag, mode, unit));

	if (sc->sc_dying)
		return (ENXIO);

	if (sc->sc_state & USCANNER_OPEN)
		return (EBUSY);

	sc->sc_state |= USCANNER_OPEN;

	sc->sc_bulkin_buffer = malloc(USCANNER_BUFFERSIZE, M_USBDEV, M_WAITOK);
	sc->sc_bulkout_buffer = malloc(USCANNER_BUFFERSIZE, M_USBDEV, M_WAITOK);
	/* No need to check buffers for NULL since we have WAITOK */

	sc->sc_bulkin_bufferlen = USCANNER_BUFFERSIZE;
	sc->sc_bulkout_bufferlen = USCANNER_BUFFERSIZE;

	/* We have decided on which endpoints to use, now open the pipes */
	if (sc->sc_bulkin_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
		if (err) {
			printf("%s: cannot open bulk-in pipe (addr %d)\n",
			       sc->sc_dev.dv_xname, sc->sc_bulkin);
			uscanner_do_close(sc);
			return (EIO);
		}
	}
	if (sc->sc_bulkout_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
		if (err) {
			printf("%s: cannot open bulk-out pipe (addr %d)\n",
			       sc->sc_dev.dv_xname, sc->sc_bulkout);
			uscanner_do_close(sc);
			return (EIO);
		}
	}

	sc->sc_bulkin_xfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->sc_bulkin_xfer == NULL) {
		uscanner_do_close(sc);
		return (ENOMEM);
	}
	sc->sc_bulkout_xfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->sc_bulkout_xfer == NULL) {
		uscanner_do_close(sc);
		return (ENOMEM);
	}

	return (0);	/* success */
}

int
uscannerclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct uscanner_softc *sc;

	sc = uscanner_cd.cd_devs[USCANNERUNIT(dev)];

	DPRINTFN(5, ("uscannerclose: flag=%d, mode=%d, unit=%d\n",
		     flag, mode, USCANNERUNIT(dev)));

#ifdef DIAGNOSTIC
	if (!(sc->sc_state & USCANNER_OPEN)) {
		printf("uscannerclose: not open\n");
		return (EINVAL);
	}
#endif

	uscanner_do_close(sc);

	return (0);
}

void
uscanner_do_close(struct uscanner_softc *sc)
{
	if (sc->sc_bulkin_xfer) {
		usbd_free_xfer(sc->sc_bulkin_xfer);
		sc->sc_bulkin_xfer = NULL;
	}
	if (sc->sc_bulkout_xfer) {
		usbd_free_xfer(sc->sc_bulkout_xfer);
		sc->sc_bulkout_xfer = NULL;
	}

	if (!(sc->sc_dev_flags & USC_KEEP_OPEN)) {
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			sc->sc_bulkin_pipe = NULL;
		}
		if (sc->sc_bulkout_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkout_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			sc->sc_bulkout_pipe = NULL;
		}
	}

	if (sc->sc_bulkin_buffer) {
		free(sc->sc_bulkin_buffer, M_USBDEV);
		sc->sc_bulkin_buffer = NULL;
	}
	if (sc->sc_bulkout_buffer) {
		free(sc->sc_bulkout_buffer, M_USBDEV);
		sc->sc_bulkout_buffer = NULL;
	}

	sc->sc_state &= ~USCANNER_OPEN;
}

int
uscanner_do_read(struct uscanner_softc *sc, struct uio *uio, int flag)
{
	u_int32_t n, tn;
	usbd_status err;
	int error = 0;

	DPRINTFN(5, ("%s: uscannerread\n", sc->sc_dev.dv_xname));

	if (sc->sc_dying)
		return (EIO);

	while ((n = min(sc->sc_bulkin_bufferlen, uio->uio_resid)) != 0) {
		DPRINTFN(1, ("uscannerread: start transfer %d bytes\n",n));
		tn = n;

		err = usbd_bulk_transfer(
			sc->sc_bulkin_xfer, sc->sc_bulkin_pipe,
			USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT,
			sc->sc_bulkin_buffer, &tn,
			"uscnrb");
		if (err) {
			if (err == USBD_INTERRUPTED)
				error = EINTR;
			else if (err == USBD_TIMEOUT)
				error = ETIMEDOUT;
			else
				error = EIO;
			break;
		}
		DPRINTFN(1, ("uscannerread: got %d bytes\n", tn));
		error = uiomove(sc->sc_bulkin_buffer, tn, uio);
		if (error || tn < n)
			break;
	}

	return (error);
}

int
uscannerread(dev_t dev, struct uio *uio, int flag)
{
	struct uscanner_softc *sc;
	int error;

	sc = uscanner_cd.cd_devs[USCANNERUNIT(dev)];

	sc->sc_refcnt++;
	error = uscanner_do_read(sc, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
uscanner_do_write(struct uscanner_softc *sc, struct uio *uio, int flag)
{
	u_int32_t n;
	int error = 0;
	usbd_status err;

	DPRINTFN(5, ("%s: uscanner_do_write\n", sc->sc_dev.dv_xname));

	if (sc->sc_dying)
		return (EIO);

	while ((n = min(sc->sc_bulkout_bufferlen, uio->uio_resid)) != 0) {
		error = uiomove(sc->sc_bulkout_buffer, n, uio);
		if (error)
			break;
		DPRINTFN(1, ("uscanner_do_write: transfer %d bytes\n", n));
		err = usbd_bulk_transfer(
			sc->sc_bulkout_xfer, sc->sc_bulkout_pipe,
			0, USBD_NO_TIMEOUT,
			sc->sc_bulkout_buffer, &n,
			"uscnwb");
		if (err) {
			if (err == USBD_INTERRUPTED)
				error = EINTR;
			else
				error = EIO;
			break;
		}
	}

	return (error);
}

int
uscannerwrite(dev_t dev, struct uio *uio, int flag)
{
	struct uscanner_softc *sc;
	int error;

	sc = uscanner_cd.cd_devs[USCANNERUNIT(dev)];

	sc->sc_refcnt++;
	error = uscanner_do_write(sc, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
uscanner_activate(struct device *self, int act)
{
	struct uscanner_softc *sc = (struct uscanner_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}

int
uscanner_detach(struct device *self, int flags)
{
	struct uscanner_softc *sc = (struct uscanner_softc *)self;
	int s;
	int maj, mn;

	DPRINTF(("uscanner_detach: sc=%p flags=%d\n", sc, flags));

	sc->sc_dev_flags = 0;	/* make close really close device */

	/* Abort all pipes.  Causes processes waiting for transfer to wake. */
	if (sc->sc_bulkin_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkin_pipe);
	if (sc->sc_bulkout_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkout_pipe);

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == uscanneropen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit * USB_MAX_ENDPOINTS;
	vdevgone(maj, mn, mn + USB_MAX_ENDPOINTS - 1, VCHR);

	return (0);
}

int
uscannerpoll(dev_t dev, int events, struct proc *p)
{
	struct uscanner_softc *sc;
	int revents = 0;

	sc = uscanner_cd.cd_devs[USCANNERUNIT(dev)];

	if (sc->sc_dying)
		return (POLLERR);

	/*
	 * We have no easy way of determining if a read will
	 * yield any data or a write will happen.
	 * Pretend they will.
	 */
	revents |= events &
		   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);

	return (revents);
}

int
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	return (EINVAL);
}

void filt_uscannerdetach(struct knote *);
int uscannerkqfilter(dev_t, struct knote *);

void
filt_uscannerdetach(struct knote *kn)
{
	struct uscanner_softc *sc = (void *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_selq.si_note, kn, knote, kn_selnext);
}

struct filterops uscanner_seltrue_filtops =
	{ 1, NULL, filt_uscannerdetach, filt_seltrue };

int
uscannerkqfilter(dev_t dev, struct knote *kn)
{
	struct uscanner_softc *sc;
	struct klist *klist;

	sc = uscanner_cd.cd_devs[USCANNERUNIT(dev)];

	if (sc->sc_dying)
		return (ENXIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
	case EVFILT_WRITE:
		/* 
		 * We have no easy way of determining if a read will
		 * yield any data or a write will happen.
		 * Pretend they will.
		 */
		klist = &sc->sc_selq.si_note;
		kn->kn_fop = &uscanner_seltrue_filtops;
		break;

	default:
		return (EINVAL);
	}

	kn->kn_hook = (void *)sc;

	SLIST_INSERT_HEAD(klist, kn, kn_selnext);

	return (0);
}
@


1.48
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.47 2013/03/28 03:58:03 tedu Exp $ */
@


1.47
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.46 2011/07/03 15:47:17 matthew Exp $ */
d187 2
a188 2
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
d192 1
a192 1
	usbd_pipe_handle	sc_bulkin_pipe;
d194 1
a194 1
	usbd_xfer_handle	sc_bulkin_xfer;
d199 1
a199 1
	usbd_pipe_handle	sc_bulkout_pipe;
d201 1
a201 1
	usbd_xfer_handle	sc_bulkout_xfer;
@


1.46
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.45 2011/07/02 22:20:08 nicm Exp $ */
a43 1
#include <sys/proc.h>
@


1.45
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.44 2011/01/25 20:03:36 jakemsr Exp $ */
a561 3
	case DVACT_ACTIVATE:
		break;

@


1.44
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.43 2010/09/24 08:33:59 yuo Exp $ */
d659 1
a659 1
		return (1);
d674 1
a674 1
		return (1);
@


1.43
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.42 2010/07/03 03:59:17 krw Exp $ */
a323 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);
a603 2
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.42
log
@No more ss(4) or usscanner(4). Unused, unloved and unmaintained.
General huzzahs.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.41 2009/10/13 19:33:19 pirofti Exp $ */
a583 1
	sc->sc_dying = 1;
@


1.41
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.40 2008/06/26 05:42:19 ray Exp $ */
a110 4
#if 0
  /* Handled by usscanner */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C }, 0 },
#endif
a112 13

#if 0
  /* XXX Should be handled by usscanner */
  /* Microtek */
 {{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL }, 0 },
#endif
@


1.40
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.39 2008/02/26 18:34:18 deraadt Exp $ */
d242 1
a242 1
int uscanner_activate(struct device *, enum devact); 
d577 1
a577 1
uscanner_activate(struct device *self, enum devact act)
@


1.39
log
@support EPSON CX5400 scanner; Christophe Etcheverry <cetcheve at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.38 2007/11/10 17:30:26 ajacoutot Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.38
log
@- add support for more multifunction Epson devices (from FreeBSD and SANE).
I'm not adding any new !MF USB scanner IDs as those can be handled using
libusb and sane-backends (from ports).
- bring the uscanner man page up-to-date with actually supported scanners

ok winiger@@ mbalmer@@ jmc@@, input and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.37 2007/11/06 17:25:15 ajacoutot Exp $ */
d183 1
@


1.37
log
@- from FreeBSD:
add support for Epson multifunction USB devices (i.e. scanner/printer/card
readers) by adding their IDs to the table of recognised devices (because
we don't have a "scanner" class) and preventing uscanner attach routine to
reconfigure the whole USB device while we are dealing only with one of its
interfaces.
- add the Epson Stylus 3850/4050 ID in the process

feedback from mbalmer@@ and jmc@@
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.36 2007/10/11 18:33:15 deraadt Exp $ */
d179 4
a182 1
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_DX3850 }, 0 },
@


1.36
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.35 2007/06/14 10:11:16 mbalmer Exp $ */
d179 1
d263 1
d265 17
a281 1
	if (uaa->iface != NULL)
d284 1
a284 2
	return (uscanner_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d296 1
d302 2
a303 6
	err = usbd_set_config_no(uaa->device, 1, 1); /* XXX */
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}
d305 1
a305 2
	/* XXX We only check the first interface */
	err = usbd_device2interface_handle(sc->sc_udev, 0, &sc->sc_iface);
@


1.35
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.34 2007/06/12 16:26:37 mbalmer Exp $ */
a276 1
	char *devinfop;
a278 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.34
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.33 2007/06/11 16:30:31 mbalmer Exp $ */
d241 16
a256 1
USB_DECLARE_DRIVER(uscanner);
@


1.33
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.32 2007/06/11 12:36:53 mbalmer Exp $ */
d557 1
a557 1
uscanner_activate(device_ptr_t self, enum devact act)
@


1.32
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.31 2007/06/11 10:58:21 mbalmer Exp $ */
d327 1
a327 1
uscanneropen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d394 1
a394 1
uscannerclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d612 1
a612 1
uscannerpoll(dev_t dev, int events, usb_proc_ptr p)
d634 1
a634 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
@


1.31
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.30 2007/06/11 09:26:55 mk Exp $ */
d333 5
a337 1
	USB_GET_SC_OPEN(uscanner, unit, sc);
@


1.30
log
@More USB cleanup:  In usb_port.h, get rid of the sel_klist #define
(which was there twice without gcc complaining) and update all uses of
it.

ok jsg mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.29 2007/06/10 14:49:01 mbalmer Exp $ */
d394 1
a394 1
	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);
d493 1
a493 1
	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);
d543 1
a543 1
	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);
d613 1
a613 1
	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);
d655 1
a655 1
	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);
@


1.29
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.28 2007/06/10 10:53:49 mbalmer Exp $ */
d643 1
a643 1
	SLIST_REMOVE(&sc->sc_selq.sel_klist, kn, knote, kn_selnext);
d668 1
a668 1
		klist = &sc->sc_selq.sel_klist;
@


1.28
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.27 2007/06/06 19:25:50 mk Exp $ */
d267 1
a267 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d277 1
a277 1
		    USBDEVNAME(sc->sc_dev));
d287 1
a287 1
		       USBDEVNAME(sc->sc_dev), err, id);
d296 1
a296 1
			       USBDEVNAME(sc->sc_dev));
d315 1
a315 1
			USBDEVNAME(sc->sc_dev));
d359 1
a359 1
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
d369 1
a369 1
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
d455 1
a455 1
	DPRINTFN(5, ("%s: uscannerread\n", USBDEVNAME(sc->sc_dev)));
d510 1
a510 1
	DPRINTFN(5, ("%s: uscanner_do_write\n", USBDEVNAME(sc->sc_dev)));
@


1.27
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.26 2007/06/05 08:43:56 mbalmer Exp $ */
d323 1
a323 1
			   USBDEV(sc->sc_dev));
d498 1
a498 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d548 1
a548 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d589 1
a589 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d602 1
a602 1
			   USBDEV(sc->sc_dev));
@


1.26
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.25 2007/05/31 18:20:22 mbalmer Exp $ */
d206 1
a206 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.25
log
@Remove more #ifdef/#endif's that checked for other bsds.  No binary
change, no functionality change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.24 2007/05/27 04:00:25 jsg Exp $ */
d235 3
a237 3
Static int uscanner_do_read(struct uscanner_softc *, struct uio *, int);
Static int uscanner_do_write(struct uscanner_softc *, struct uio *, int);
Static void uscanner_do_close(struct uscanner_softc *);
d448 1
a448 1
Static int
d503 1
a503 1
Static int
d635 1
a635 1
Static void filt_uscannerdetach(struct knote *);
d638 1
a638 1
Static void
d646 1
a646 1
Static struct filterops uscanner_seltrue_filtops =
@


1.24
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.23 2007/05/21 05:40:28 jsg Exp $ */
a46 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a47 7
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/conf.h>
#include <sys/fcntl.h>
#include <sys/filio.h>
#endif
a234 42
#if defined(__NetBSD__)
dev_type_open(uscanneropen);
dev_type_close(uscannerclose);
dev_type_read(uscannerread);
dev_type_write(uscannerwrite);
dev_type_ioctl(uscannerioctl);
dev_type_poll(uscannerpoll);
dev_type_kqfilter(uscannerkqfilter);

const struct cdevsw uscanner_cdevsw = {
	uscanneropen, uscannerclose, uscannerread, uscannerwrite,
	uscannerioctl, nostop, notty, uscannerpoll, nommap, uscannerkqfilter,
};
#elif defined(__FreeBSD__)
d_open_t  uscanneropen;
d_close_t uscannerclose;
d_read_t  uscannerread;
d_write_t uscannerwrite;
d_poll_t  uscannerpoll;

#define USCANNER_CDEV_MAJOR	156

Static struct cdevsw uscanner_cdevsw = {
	/* open */	uscanneropen,
	/* close */	uscannerclose,
	/* read */	uscannerread,
	/* write */	uscannerwrite,
	/* ioctl */	noioctl,
	/* poll */	uscannerpoll,
	/* mmap */	nommap,
	/* strategy */	nostrategy,
	/* name */	"uscanner",
	/* maj */	USCANNER_CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
	/* bmaj */	-1
#endif
};
#endif

a321 6
#ifdef __FreeBSD__
	/* the main device, ctrl endpoint */
	make_dev(&uscanner_cdevsw, USBDEVUNIT(sc->sc_dev),
		UID_ROOT, GID_OPERATOR, 0644, "%s", USBDEVNAME(sc->sc_dev));
#endif

a551 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a566 1
#endif
a572 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a573 4
#elif defined(__FreeBSD__)
	dev_t dev;
	struct vnode *vp;
#endif
a574 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a575 3
#elif defined(__FreeBSD__)
	DPRINTF(("uscanner_detach: sc=%p\n", sc));
#endif
a592 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a593 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uscanner_cdevsw);
#elif defined(__OpenBSD__)
a596 1
#endif
a600 9
#elif defined(__FreeBSD__)
	/* destroy the device for the control endpoint */
	dev = makedev(USCANNER_CDEV_MAJOR, USBDEVUNIT(sc->sc_dev));
	vp = SLIST_FIRST(&dev->si_hlist);
	if (vp)
		VOP_REVOKE(vp, REVOKEALL);
	destroy_dev(dev);
#endif

a681 4

#if defined(__FreeBSD__)
DRIVER_MODULE(uscanner, uhub, uscanner_driver, uscanner_devclass, usbd_driver_load, 0);
#endif
@


1.23
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.22 2006/11/01 03:37:24 tedu Exp $ */
d293 2
a294 1
USB_MATCH(uscanner)
d296 1
a296 1
	USB_MATCH_START(uscanner, uaa);
d305 2
a306 1
USB_ATTACH(uscanner)
d308 2
a309 1
	USB_ATTACH_START(uscanner, sc, uaa);
d317 1
a317 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d328 1
a328 1
		USB_ATTACH_ERROR_RETURN;
d338 1
a338 1
		USB_ATTACH_ERROR_RETURN;
d347 1
a347 1
			USB_ATTACH_ERROR_RETURN;
d366 1
a366 1
		USB_ATTACH_ERROR_RETURN;
a379 2

	USB_ATTACH_SUCCESS_RETURN;
d626 2
a627 1
USB_DETACH(uscanner)
d629 1
a629 1
	USB_DETACH_START(uscanner, sc);
@


1.22
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.21 2006/07/01 10:33:12 miod Exp $ */
d71 2
a72 2
#define DPRINTF(x)	do { if (uscannerdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uscannerdebug>(n)) logprintf x; } while (0)
@


1.21
log
@More Canon scanners, from NetBSD via Matthieu Baptiste.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.20 2006/06/23 06:27:12 miod Exp $ */
d696 1
a696 1
		return (EIO);
@


1.20
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.19 2005/11/21 18:16:44 millert Exp $ */
d110 3
@


1.19
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.18 2005/08/01 05:36:49 brad Exp $ */
d613 1
a613 1
		return (EOPNOTSUPP);
@


1.18
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.17 2004/07/08 22:18:45 deraadt Exp $ */
a57 1
#if defined(__FreeBSD__) && __FreeBSD_version >= 500014
a58 3
#else
#include <sys/select.h>
#endif
@


1.17
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.16 2003/06/27 16:57:14 nate Exp $ */
d310 1
a310 1
	char devinfo[1024];
d314 1
a314 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d316 2
a317 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.16
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.15 2003/05/17 17:22:58 nate Exp $ */
d75 2
a76 2
#define DPRINTF(x)	if (uscannerdebug) logprintf x
#define DPRINTFN(n,x)	if (uscannerdebug>(n)) logprintf x
@


1.15
log
@more scanners from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uscanner.c,v 1.14 2003/05/07 04:33:33 deraadt Exp $ */
/*	$NetBSD: uscanner.c,v 1.34 2002/10/23 09:14:03 jdolecek Exp $	*/
d235 2
d713 48
@


1.14
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.13 2002/11/11 02:32:32 nate Exp $ */
d181 1
d184 1
d187 1
@


1.13
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.12 2002/07/25 04:07:33 nate Exp $ */
d309 1
a309 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.12
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: uscanner.c,v 1.11 2002/07/25 02:18:11 nate Exp $ */
/*	$NetBSD: uscanner.c,v 1.31 2002/07/14 20:53:21 augustss Exp $	*/
d240 12
a251 1
cdev_decl(uscanner);
a611 1
		break;
d656 3
d662 1
@


1.11
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uscanner.c,v 1.10 2002/07/12 12:03:51 todd Exp $ */
/*	$NetBSD: uscanner.c,v 1.29 2002/06/18 00:32:30 augustss Exp $	*/
@


1.10
log
@'this is a scanner'
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.9 2002/07/10 21:41:51 mickey Exp $ */
d375 1
a375 1
 	DPRINTFN(5, ("uscanneropen: flag=%d, mode=%d, unit=%d\n", 
d679 1
a679 1
	/* 
d684 1
a684 1
	revents |= events & 
@


1.9
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.8 2002/07/09 16:28:02 nate Exp $ */
d168 1
@


1.8
log
@scanner updates from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.7 2002/05/07 18:29:19 nate Exp $ */
d238 1
a238 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.7
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 3
/*	$OpenBSD: uscanner.c,v 1.5 2002/01/03 22:23:43 deraadt Exp $ */
/*	$NetBSD: uscanner.c,v 1.18 2001/10/11 12:05:10 augustss Exp $	*/
/*	$FreeBSD$	*/
d58 3
d62 1
d83 6
d90 37
a126 25
static const struct scanner_id {
	uint16_t	vendor;
	uint16_t	product;
} scanner_ids [] = {
	/* Acer Peripherals */
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U },

	/* AGFA */
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U },
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 },
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH },

	/* Kye */
	{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO },

	/* HP */
	{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C },
d128 2
a129 1
	{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C },
d131 2
a132 5
	{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C },

	/* Avision */
	{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U },
d135 66
a200 56
	/* Microtek */
	{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL },
#endif

	/* Mustek */
	{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_600CU },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_1200USB },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_1200UB },

	/* Primax */
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 },

	/* Epson */
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 },

	/* UMAX */
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 },

	/* Visioneer */
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 },
d202 2
a203 2
 	/* Canon */
	{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U },
a204 1
	{ 0, 0 }
d206 1
d215 2
d263 1
d265 1
a279 1
	int i;
d284 2
a285 8
	for (i = 0; scanner_ids[i].vendor != 0; i++) {
		if (scanner_ids[i].vendor == uaa->vendor &&
		    scanner_ids[i].product == uaa->product) {
			return (UMATCH_VENDOR_PRODUCT);
		}
	}

	return (UMATCH_NONE);
d301 2
d366 1
a366 5
uscanneropen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d393 9
a401 7
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
	if (err) {
		printf("%s: cannot open bulk-in pipe (addr %d)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
		uscanner_do_close(sc);
		return (EIO);
d403 9
a411 7
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
	if (err) {
		printf("%s: cannot open bulk-out pipe (addr %d)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
		uscanner_do_close(sc);
		return (EIO);
d429 1
a429 5
uscannerclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d462 11
a472 9
	if (sc->sc_bulkin_pipe) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
d488 1
a488 4
uscanner_do_read(sc, uio, flag)
	struct uscanner_softc *sc;
	struct uio *uio;
	int flag;
d507 1
a507 1
			"uscannerrb");
d527 1
a527 4
uscannerread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d543 1
a543 4
uscanner_do_write(sc, uio, flag)
	struct uscanner_softc *sc;
	struct uio *uio;
	int flag;
d563 1
a563 1
			"uscannerwb");
d577 1
a577 4
uscannerwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d593 1
a593 3
uscanner_activate(self, act)
	device_ptr_t self;
	enum devact act;
d628 1
d631 1
a631 1
	if (sc->sc_bulkin_pipe)
d633 1
a633 1
	if (sc->sc_bulkout_pipe)
d668 1
a668 4
uscannerpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d690 1
a690 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
@


1.6
log
@Sync ulpt driver with NetBSD
@
text
@d2 2
a3 1
/*	$NetBSD: uscanner.c,v 1.27 2002/02/11 10:09:14 augustss Exp $	*/
a58 3
#if defined(__FreeBSD__) && __FreeBSD_version >= 500014
#include <sys/selinfo.h>
#else
a59 1
#endif
a79 6
struct uscan_info {
	struct usb_devno devno;
	u_int flags;
#define USC_KEEP_OPEN 1
};

d81 25
a105 36
static const struct uscan_info uscanner_devs[] = {
  /* Acer Peripherals */
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U }, 0 },

  /* AGFA */
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1236U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE40 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE50 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE20 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE25 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE26 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE52 }, 0 },

  /* Avision */
 {{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U }, 0 },

  /* Canon */
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U }, 0 },

  /* Kye */
 {{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO }, 0 },

  /* HP */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C }, 0 },
d107 1
a107 2
  /* Handled by usscanner */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C }, 0 },
d109 5
a113 2
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C }, 0 },
d116 56
a171 65
  /* XXX Should be handled by usscanner */
  /* Microtek */
 {{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL }, 0 },
#endif

  /* Mustek */
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_BEARPAW1200F }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200UB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USBPLUS }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CUPLUS }, 0 },

  /* National */
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 }, 0 },
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW2400 }, 0 },

  /* Primax */
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 }, 0 },

  /* Epson */
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_GT9700F }, USC_KEEP_OPEN },

  /* UMAX */
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 }, 0 },

  /* Visioneer */
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 }, 0 },
d173 2
a174 2
  /* Ultima */
 {{ USB_VENDOR_ULTIMA, USB_PRODUCT_ULTIMA_1200UBPLUS }, 0 },
d176 1
a177 1
#define uscanner_lookup(v, p) ((const struct uscan_info *)usb_lookup(uscanner_devs, v, p))
a185 2
	u_int			sc_dev_flags;

a231 1
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
a232 1
#endif
d247 1
d252 8
a259 2
	return (uscanner_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a274 2
	sc->sc_dev_flags = uscanner_lookup(uaa->vendor, uaa->product)->flags;

d338 5
a342 1
uscanneropen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d369 7
a375 9
	if (sc->sc_bulkin_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
		if (err) {
			printf("%s: cannot open bulk-in pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
			uscanner_do_close(sc);
			return (EIO);
		}
d377 7
a383 9
	if (sc->sc_bulkout_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
		if (err) {
			printf("%s: cannot open bulk-out pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
			uscanner_do_close(sc);
			return (EIO);
		}
d401 5
a405 1
uscannerclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d438 9
a446 11
	if (!(sc->sc_dev_flags & USC_KEEP_OPEN)) {
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			sc->sc_bulkin_pipe = NULL;
		}
		if (sc->sc_bulkout_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkout_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			sc->sc_bulkout_pipe = NULL;
		}
d462 4
a465 1
uscanner_do_read(struct uscanner_softc *sc, struct uio *uio, int flag)
d484 1
a484 1
			"uscnrb");
d504 4
a507 1
uscannerread(dev_t dev, struct uio *uio, int flag)
d523 4
a526 1
uscanner_do_write(struct uscanner_softc *sc, struct uio *uio, int flag)
d546 1
a546 1
			"uscnwb");
d560 4
a563 1
uscannerwrite(dev_t dev, struct uio *uio, int flag)
d579 3
a581 1
uscanner_activate(device_ptr_t self, enum devact act)
a615 1
	sc->sc_dev_flags = 0;	/* make close really close device */
d618 1
a618 1
	if (sc->sc_bulkin_pipe != NULL)
d620 1
a620 1
	if (sc->sc_bulkout_pipe != NULL)
d655 4
a658 1
uscannerpoll(dev_t dev, int events, usb_proc_ptr p)
d680 1
a680 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
@


1.5
log
@new names, nate broke the tree
@
text
@d1 2
a2 3
/*	$OpenBSD: uscanner.c,v 1.4 2001/10/31 04:24:45 nate Exp $ */
/*	$NetBSD: uscanner.c,v 1.18 2001/10/11 12:05:10 augustss Exp $	*/
/*	$FreeBSD$	*/
d58 3
d62 1
d83 6
d90 36
a125 25
static const struct scanner_id {
	uint16_t	vendor;
	uint16_t	product;
} scanner_ids [] = {
	/* Acer Peripherals */
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U },
	{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U },

	/* AGFA */
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U },
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 },
	{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH },

	/* Kye */
	{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO },

	/* HP */
	{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C },
d127 2
a128 1
	{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C },
d130 2
a131 5
	{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C },
	{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C },

	/* Avision */
	{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U },
d134 65
a198 56
	/* Microtek */
	{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 },
	{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL },
#endif

	/* Mustek */
	{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_600CU },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_1200USB },
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_MUSTEK_1200UB },

	/* Primax */
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 },
	{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 },

	/* Epson */
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 },

	/* UMAX */
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U },
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 },

	/* Visioneer */
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 },
	{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 },
d200 2
a201 2
 	/* Canon */
	{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U },
a202 1
	{ 0, 0 }
d204 1
d213 2
d261 1
d263 1
a277 1
	int i;
d282 2
a283 8
	for (i = 0; scanner_ids[i].vendor != 0; i++) {
		if (scanner_ids[i].vendor == uaa->vendor &&
		    scanner_ids[i].product == uaa->product) {
			return (UMATCH_VENDOR_PRODUCT);
		}
	}

	return (UMATCH_NONE);
d299 2
d364 1
a364 5
uscanneropen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d391 9
a399 7
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
	if (err) {
		printf("%s: cannot open bulk-in pipe (addr %d)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
		uscanner_do_close(sc);
		return (EIO);
d401 9
a409 7
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
	if (err) {
		printf("%s: cannot open bulk-out pipe (addr %d)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
		uscanner_do_close(sc);
		return (EIO);
d427 1
a427 5
uscannerclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d460 11
a470 9
	if (sc->sc_bulkin_pipe) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
d486 1
a486 4
uscanner_do_read(sc, uio, flag)
	struct uscanner_softc *sc;
	struct uio *uio;
	int flag;
d505 1
a505 1
			"uscannerrb");
d525 1
a525 4
uscannerread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d541 1
a541 4
uscanner_do_write(sc, uio, flag)
	struct uscanner_softc *sc;
	struct uio *uio;
	int flag;
d561 1
a561 1
			"uscannerwb");
d575 1
a575 4
uscannerwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d591 1
a591 3
uscanner_activate(self, act)
	device_ptr_t self;
	enum devact act;
d626 1
d629 1
a629 1
	if (sc->sc_bulkin_pipe)
d631 1
a631 1
	if (sc->sc_bulkout_pipe)
d666 1
a666 4
uscannerpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d688 1
a688 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
@


1.4
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.3 2001/05/03 02:20:34 aaron Exp $ */
d129 1
a129 1
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW },
@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.5 2002/01/03 22:23:43 deraadt Exp $ */
d129 1
a129 1
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 },
@


1.4.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.4.2.1 2002/01/31 22:55:39 niklas Exp $ */
@


1.4.2.3
log
@sync to -current
@
text
@d1 3
a3 2
/*	$OpenBSD$ */
/*	$NetBSD: uscanner.c,v 1.31 2002/07/14 20:53:21 augustss Exp $	*/
a58 3
#if defined(__FreeBSD__) && __FreeBSD_version >= 500014
#include <sys/selinfo.h>
#else
a59 1
#endif
a79 6
struct uscan_info {
	struct usb_devno devno;
	u_int flags;
#define USC_KEEP_OPEN 1
};

d81 25
a105 37
static const struct uscan_info uscanner_devs[] = {
  /* Acer Peripherals */
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U }, 0 },

  /* AGFA */
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1236U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE40 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE50 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE20 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE25 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE26 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE52 }, 0 },

  /* Avision */
 {{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U }, 0 },

  /* Canon */
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U }, 0 },

  /* Kye */
 {{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO }, 0 },

  /* HP */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_2200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C }, 0 },
d107 1
a107 2
  /* Handled by usscanner */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C }, 0 },
d109 5
a113 2
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C }, 0 },
d116 56
a171 67
  /* XXX Should be handled by usscanner */
  /* Microtek */
 {{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL }, 0 },
#endif

  /* Mustek */
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_BEARPAW1200F }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200UB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USBPLUS }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CUPLUS }, 0 },

  /* National */
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 }, 0 },
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW2400 }, 0 },

  /* Primax */
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_6200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 }, 0 },

  /* Epson */
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_GT9700F }, USC_KEEP_OPEN },

  /* UMAX */
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 }, 0 },

  /* Visioneer */
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_3000 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 }, 0 },
d173 2
a174 2
  /* Ultima */
 {{ USB_VENDOR_ULTIMA, USB_PRODUCT_ULTIMA_1200UBPLUS }, 0 },
d176 1
a177 1
#define uscanner_lookup(v, p) ((const struct uscan_info *)usb_lookup(uscanner_devs, v, p))
a185 2
	u_int			sc_dev_flags;

d207 1
a207 1
#if defined(__NetBSD__)
a231 1
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
a232 1
#endif
d247 1
d252 8
a259 2
	return (uscanner_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a274 2
	sc->sc_dev_flags = uscanner_lookup(uaa->vendor, uaa->product)->flags;

d338 5
a342 1
uscanneropen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d350 1
a350 1
 	DPRINTFN(5, ("uscanneropen: flag=%d, mode=%d, unit=%d\n",
d369 7
a375 9
	if (sc->sc_bulkin_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
		if (err) {
			printf("%s: cannot open bulk-in pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
			uscanner_do_close(sc);
			return (EIO);
		}
d377 7
a383 9
	if (sc->sc_bulkout_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
		if (err) {
			printf("%s: cannot open bulk-out pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
			uscanner_do_close(sc);
			return (EIO);
		}
d401 5
a405 1
uscannerclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d438 9
a446 11
	if (!(sc->sc_dev_flags & USC_KEEP_OPEN)) {
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			sc->sc_bulkin_pipe = NULL;
		}
		if (sc->sc_bulkout_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkout_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			sc->sc_bulkout_pipe = NULL;
		}
d462 4
a465 1
uscanner_do_read(struct uscanner_softc *sc, struct uio *uio, int flag)
d484 1
a484 1
			"uscnrb");
d504 4
a507 1
uscannerread(dev_t dev, struct uio *uio, int flag)
d523 4
a526 1
uscanner_do_write(struct uscanner_softc *sc, struct uio *uio, int flag)
d546 1
a546 1
			"uscnwb");
d560 4
a563 1
uscannerwrite(dev_t dev, struct uio *uio, int flag)
d579 3
a581 1
uscanner_activate(device_ptr_t self, enum devact act)
a615 1
	sc->sc_dev_flags = 0;	/* make close really close device */
d618 1
a618 1
	if (sc->sc_bulkin_pipe != NULL)
d620 1
a620 1
	if (sc->sc_bulkout_pipe != NULL)
d655 4
a658 1
uscannerpoll(dev_t dev, int events, usb_proc_ptr p)
d668 1
a668 1
	/*
d673 1
a673 1
	revents |= events &
d680 1
a680 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
@


1.4.2.4
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uscanner.c,v 1.34 2002/10/23 09:14:03 jdolecek Exp $	*/
d240 1
a240 12
dev_type_open(uscanneropen);
dev_type_close(uscannerclose);
dev_type_read(uscannerread);
dev_type_write(uscannerwrite);
dev_type_ioctl(uscannerioctl);
dev_type_poll(uscannerpoll);
dev_type_kqfilter(uscannerkqfilter);

const struct cdevsw uscanner_cdevsw = {
	uscanneropen, uscannerclose, uscannerread, uscannerwrite,
	uscannerioctl, nostop, notty, uscannerpoll, nommap, uscannerkqfilter,
};
d298 1
a298 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d601 1
a645 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uscanner_cdevsw);
#elif defined(__OpenBSD__)
a648 1
#endif
@


1.3
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: uscanner.c,v 1.2 2001/01/28 09:43:43 aaron Exp $ */
/*	$NetBSD: uscanner.c,v 1.12 2001/01/23 14:04:14 augustss Exp $	*/
d101 1
d152 1
d155 2
d163 1
d172 3
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uscanner.c,v 1.11 2001/01/07 14:46:32 augustss Exp $	*/
d323 3
d639 3
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uscanner.c,v 1.12 2001/01/23 14:04:14 augustss Exp $	*/
a322 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

a635 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
@


1.3.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uscanner.c,v 1.18 2001/10/11 12:05:10 augustss Exp $	*/
a100 1
	{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE },
a150 1
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 },
a152 2
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U },
	{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 },
a158 1
	{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 },
a166 3

 	/* Canon */
	{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U },
@


1.3.2.4
log
@Merge in trunk
@
text
@d129 1
a129 1
	{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 },
@


1.3.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 2
a3 1
/*	$NetBSD: uscanner.c,v 1.34 2002/10/23 09:14:03 jdolecek Exp $	*/
a58 3
#if defined(__FreeBSD__) && __FreeBSD_version >= 500014
#include <sys/selinfo.h>
#else
a59 1
#endif
a79 6
struct uscan_info {
	struct usb_devno devno;
	u_int flags;
#define USC_KEEP_OPEN 1
};

d81 25
a105 37
static const struct uscan_info uscanner_devs[] = {
  /* Acer Peripherals */
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_320U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_640U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_620U }, 0 },
 {{ USB_VENDOR_ACERP, USB_PRODUCT_ACERP_ACERSCAN_C310U }, 0 },

  /* AGFA */
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1236U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCAN1212U2 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANTOUCH }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE40 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE50 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE20 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE25 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE26 }, 0 },
 {{ USB_VENDOR_AGFA, USB_PRODUCT_AGFA_SNAPSCANE52 }, 0 },

  /* Avision */
 {{ USB_VENDOR_AVISION, USB_PRODUCT_AVISION_1200U }, 0 },

  /* Canon */
 {{ USB_VENDOR_CANON, USB_PRODUCT_CANON_N656U }, 0 },

  /* Kye */
 {{ USB_VENDOR_KYE, USB_PRODUCT_KYE_VIVIDPRO }, 0 },

  /* HP */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_2200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_3400CSE }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4100C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_4300C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_S20 }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5200C }, 0 },
d107 1
a107 2
  /* Handled by usscanner */
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_5300C }, 0 },
d109 5
a113 2
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6200C }, 0 },
 {{ USB_VENDOR_HP, USB_PRODUCT_HP_6300C }, 0 },
d116 56
a171 67
  /* XXX Should be handled by usscanner */
  /* Microtek */
 {{ USB_VENDOR_SCANLOGIC, USB_PRODUCT_SCANLOGIC_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_X6U }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_336CX2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_C6 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6USL2 }, 0 },
 {{ USB_VENDOR_MICROTEK, USB_PRODUCT_MICROTEK_V6UL }, 0 },
#endif

  /* Mustek */
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_BEARPAW1200F }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_600CU }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200UB }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200USBPLUS }, 0 },
 {{ USB_VENDOR_MUSTEK, USB_PRODUCT_MUSTEK_1200CUPLUS }, 0 },

  /* National */
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW1200 }, 0 },
 {{ USB_VENDOR_NATIONAL, USB_PRODUCT_NATIONAL_BEARPAW2400 }, 0 },

  /* Primax */
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2X300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2300 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E3002 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_9600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_600U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_6200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_19200 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_1200U }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_636I }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2600 }, 0 },
 {{ USB_VENDOR_PRIMAX, USB_PRODUCT_PRIMAX_G2E600 }, 0 },

  /* Epson */
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_636 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_610 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1200 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1240 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1600 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1640 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_640U }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1650 }, 0 },
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_GT9700F }, USC_KEEP_OPEN },

  /* UMAX */
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1220U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA1236U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2000U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA2200U }, 0 },
 {{ USB_VENDOR_UMAX, USB_PRODUCT_UMAX_ASTRA3400 }, 0 },

  /* Visioneer */
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_3000 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_5300 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_7600 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_6200 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8100 }, 0 },
 {{ USB_VENDOR_VISIONEER, USB_PRODUCT_VISIONEER_8600 }, 0 },
d173 2
a174 2
  /* Ultima */
 {{ USB_VENDOR_ULTIMA, USB_PRODUCT_ULTIMA_1200UBPLUS }, 0 },
d176 1
a177 1
#define uscanner_lookup(v, p) ((const struct uscan_info *)usb_lookup(uscanner_devs, v, p))
a185 2
	u_int			sc_dev_flags;

d207 2
a208 13
#if defined(__NetBSD__)
dev_type_open(uscanneropen);
dev_type_close(uscannerclose);
dev_type_read(uscannerread);
dev_type_write(uscannerwrite);
dev_type_ioctl(uscannerioctl);
dev_type_poll(uscannerpoll);
dev_type_kqfilter(uscannerkqfilter);

const struct cdevsw uscanner_cdevsw = {
	uscanneropen, uscannerclose, uscannerread, uscannerwrite,
	uscannerioctl, nostop, notty, uscannerpoll, nommap, uscannerkqfilter,
};
a231 1
#if !defined(__FreeBSD__) || (__FreeBSD__ < 5)
a232 1
#endif
d247 1
d252 8
a259 2
	return (uscanner_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a274 2
	sc->sc_dev_flags = uscanner_lookup(uaa->vendor, uaa->product)->flags;

d338 5
a342 1
uscanneropen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d350 1
a350 1
 	DPRINTFN(5, ("uscanneropen: flag=%d, mode=%d, unit=%d\n",
d369 7
a375 9
	if (sc->sc_bulkin_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
		if (err) {
			printf("%s: cannot open bulk-in pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkin);
			uscanner_do_close(sc);
			return (EIO);
		}
d377 7
a383 9
	if (sc->sc_bulkout_pipe == NULL) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
		if (err) {
			printf("%s: cannot open bulk-out pipe (addr %d)\n",
			       USBDEVNAME(sc->sc_dev), sc->sc_bulkout);
			uscanner_do_close(sc);
			return (EIO);
		}
d401 5
a405 1
uscannerclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d438 9
a446 11
	if (!(sc->sc_dev_flags & USC_KEEP_OPEN)) {
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			sc->sc_bulkin_pipe = NULL;
		}
		if (sc->sc_bulkout_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkout_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			sc->sc_bulkout_pipe = NULL;
		}
d462 4
a465 1
uscanner_do_read(struct uscanner_softc *sc, struct uio *uio, int flag)
d484 1
a484 1
			"uscnrb");
d504 4
a507 1
uscannerread(dev_t dev, struct uio *uio, int flag)
d523 4
a526 1
uscanner_do_write(struct uscanner_softc *sc, struct uio *uio, int flag)
d546 1
a546 1
			"uscnwb");
d560 4
a563 1
uscannerwrite(dev_t dev, struct uio *uio, int flag)
d579 3
a581 1
uscanner_activate(device_ptr_t self, enum devact act)
d588 1
a615 1
	sc->sc_dev_flags = 0;	/* make close really close device */
d618 1
a618 1
	if (sc->sc_bulkin_pipe != NULL)
d620 1
a620 1
	if (sc->sc_bulkout_pipe != NULL)
a631 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uscanner_cdevsw);
#elif defined(__OpenBSD__)
a634 1
#endif
d655 4
a658 1
uscannerpoll(dev_t dev, int events, usb_proc_ptr p)
d668 1
a668 1
	/*
d673 1
a673 1
	revents |= events &
d680 1
a680 1
uscannerioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
@


1.3.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.3.2.5 2003/03/28 00:38:33 niklas Exp $ */
d309 1
a309 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.3.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uscanner.c,v 1.3.2.6 2003/05/13 19:35:13 ho Exp $ */
a180 1
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1260 }, 0 },
a182 1
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_1660 }, 0 },
a184 1
 {{ USB_VENDOR_EPSON, USB_PRODUCT_EPSON_2400 }, 0 },
@


1.3.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uscanner.c,v 1.40 2003/01/27 00:32:44 wiz Exp $	*/
a234 2
	struct selinfo		sc_selq;

a710 48
}

Static void filt_uscannerdetach(struct knote *);
int uscannerkqfilter(dev_t, struct knote *);

Static void
filt_uscannerdetach(struct knote *kn)
{
	struct uscanner_softc *sc = (void *)kn->kn_hook;

	SLIST_REMOVE(&sc->sc_selq.sel_klist, kn, knote, kn_selnext);
}

Static struct filterops uscanner_seltrue_filtops =
	{ 1, NULL, filt_uscannerdetach, filt_seltrue };

int
uscannerkqfilter(dev_t dev, struct knote *kn)
{
	struct uscanner_softc *sc;
	struct klist *klist;

	USB_GET_SC(uscanner, USCANNERUNIT(dev), sc);

	if (sc->sc_dying)
		return (1);

	switch (kn->kn_filter) {
	case EVFILT_READ:
	case EVFILT_WRITE:
		/* 
		 * We have no easy way of determining if a read will
		 * yield any data or a write will happen.
		 * Pretend they will.
		 */
		klist = &sc->sc_selq.sel_klist;
		kn->kn_fop = &uscanner_seltrue_filtops;
		break;

	default:
		return (1);
	}

	kn->kn_hook = (void *)sc;

	SLIST_INSERT_HEAD(klist, kn, kn_selnext);

	return (0);
@


1.2
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: uscanner.c,v 1.1 2000/11/16 19:40:17 aaron Exp $ */
/*	$NetBSD: uscanner.c,v 1.11 2001/01/07 14:46:32 augustss Exp $	*/
d323 3
d639 3
@


1.1
log
@Driver for USB scanners; from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uscanner.c,v 1.9 2000/11/14 13:57:16 augustss Exp $	*/
d105 1
d107 1
d114 1
d116 1
d124 1
d152 1
a640 3
#if defined(__OpenBSD__)
uscannerselect(dev, events, p)
#else
a641 1
#endif
@

