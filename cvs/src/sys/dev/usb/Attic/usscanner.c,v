head	1.34;
access;
symbols
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.6
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.34
date	2010.07.08.00.48.18;	author krw;	state dead;
branches;
next	1.33;

1.33
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.19.21.43.16;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.09.23.15.07;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.20.04.37.54;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.20.04.01.39;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.17.06.07.57;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.03.02.20.35;	author aaron;	state Exp;
branches
	1.3.2.1
	1.3.6.1;
next	1.2;

1.2
date	2001.02.20.13.43.29;	author ho;	state Exp;
branches;
next	1.1;

1.1
date	2001.01.28.16.31.24;	author aaron;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.27;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.44.05;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Move ss and friends to the attic.

Enthusiastic huzzahs from many.

"A great day" dlg@@
@
text
@/*	$OpenBSD: usscanner.c,v 1.33 2010/06/28 18:31:02 krw Exp $	*/
/*	$NetBSD: usscanner.c,v 1.6 2001/01/23 14:04:14 augustss Exp $	*/

/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) and LLoyd Parkes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver is partly based on information taken from the Linux driver
 * by John Fremlin, Oliver Neukum, and Jeremy Hall.
 */
/*
 * Protocol:
 * Send raw SCSI command on the bulk-out pipe.
 * If output command then
 *     send further data on the bulk-out pipe
 * else if input command then
 *     read data on the bulk-in pipe
 * else
 *     don't do anything.
 * Read status byte on the interrupt pipe (which doesn't seem to be
 * an interrupt pipe at all).  This operation sometimes times out.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/buf.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/usbdevs.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <machine/bus.h>

#ifdef USSCANNER_DEBUG
#define DPRINTF(x)	do { if (usscannerdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (usscannerdebug>(n)) printf x; } while (0)
int	usscannerdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
#define XS_CTL_POLL		SCSI_POLL

#define USSCANNER_CONFIG_NO		1
#define USSCANNER_IFACE_IDX		0

#define USSCANNER_SCSIID_HOST	0x00
#define USSCANNER_SCSIID_DEVICE	0x01

#define USSCANNER_MAX_TRANSFER_SIZE	MAXBSIZE

#define USSCANNER_TIMEOUT 2000

struct usscanner_softc {
 	struct device		sc_dev;
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;

	int			sc_in_addr;
	usbd_pipe_handle	sc_in_pipe;

	int			sc_intr_addr;
	usbd_pipe_handle	sc_intr_pipe;
	usbd_xfer_handle	sc_intr_xfer;
	u_char			sc_status;

	int			sc_out_addr;
	usbd_pipe_handle	sc_out_pipe;

	usbd_xfer_handle	sc_cmd_xfer;
	void			*sc_cmd_buffer;
	usbd_xfer_handle	sc_data_xfer;
	void			*sc_data_buffer;

	int			sc_state;
#define UAS_IDLE	0
#define UAS_CMD		1
#define UAS_DATA	2
#define UAS_SENSECMD	3
#define UAS_SENSEDATA	4
#define UAS_STATUS	5

	struct scsipi_xfer	*sc_xs;

	struct device		*sc_child;	/* child device, for detach */

	struct scsipi_link	sc_link;
	struct scsi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter

	int			sc_refcnt;
	char			sc_dying;
};


void usscanner_cleanup(struct usscanner_softc *sc);
void usscanner_scsipi_cmd(struct scsipi_xfer *xs);
void usscanner_scsipi_minphys(struct buf *bp, struct scsi_link *sl);
void usscanner_done(struct usscanner_softc *sc);
void usscanner_sense(struct usscanner_softc *sc);
typedef void callback(usbd_xfer_handle, usbd_private_handle, usbd_status);
callback usscanner_intr_cb;
callback usscanner_cmd_cb;
callback usscanner_data_cb;
callback usscanner_sensecmd_cb;
callback usscanner_sensedata_cb;

int usscanner_match(struct device *, void *, void *); 
void usscanner_attach(struct device *, struct device *, void *); 
int usscanner_detach(struct device *, int); 
int usscanner_activate(struct device *, int); 

struct cfdriver usscanner_cd = { 
	NULL, "usscanner", DV_DULL 
}; 

const struct cfattach usscanner_ca = { 
	sizeof(struct usscanner_softc), 
	usscanner_match, 
	usscanner_attach, 
	usscanner_detach, 
	usscanner_activate, 
};

int
usscanner_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	DPRINTFN(50,("usscanner_match\n"));

	if (uaa->iface != NULL)
		return (UMATCH_NONE);

	if (uaa->vendor == USB_VENDOR_HP &&
	    uaa->product == USB_PRODUCT_HP_5300C)
		return (UMATCH_VENDOR_PRODUCT);
	else
		return (UMATCH_NONE);
}

void
usscanner_attach(struct device *parent, struct device *self, void *aux)
{
	struct usscanner_softc	*sc = (struct usscanner_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct scsibus_attach_args saa;
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
	usbd_status		err;
	usb_endpoint_descriptor_t *ed;
	u_int8_t		epcount;
	int			i;

	DPRINTFN(10,("usscanner_attach: sc=%p\n", sc));

	err = usbd_set_config_no(dev, USSCANNER_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	err = usbd_device2interface_handle(dev, USSCANNER_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_udev = dev;
	sc->sc_iface = iface;

	epcount = 0;
	(void)usbd_endpoint_count(iface, &epcount);

	sc->sc_in_addr = -1;
	sc->sc_intr_addr = -1;
	sc->sc_out_addr = -1;
	for (i = 0; i < epcount; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_in_addr = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_addr = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_out_addr = ed->bEndpointAddress;
		}
	}
	if (sc->sc_in_addr == -1 || sc->sc_intr_addr == -1 ||
	    sc->sc_out_addr == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		return;
	}

	err = usbd_open_pipe(sc->sc_iface, sc->sc_in_addr,
			     USBD_EXCLUSIVE_USE, &sc->sc_in_pipe);
	if (err) {
		printf("%s: open in pipe failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		return;
	}

	/* The interrupt endpoint must be opened as a normal pipe. */
	err = usbd_open_pipe(sc->sc_iface, sc->sc_intr_addr,
			     USBD_EXCLUSIVE_USE, &sc->sc_intr_pipe);

	if (err) {
		printf("%s: open intr pipe failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}
	err = usbd_open_pipe(sc->sc_iface, sc->sc_out_addr,
			     USBD_EXCLUSIVE_USE, &sc->sc_out_pipe);
	if (err) {
		printf("%s: open out pipe failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}

	sc->sc_cmd_xfer = usbd_alloc_xfer(uaa->device);
	if (sc->sc_cmd_xfer == NULL) {
		printf("%s: alloc cmd xfer failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}

	/* XXX too big */
	sc->sc_cmd_buffer = usbd_alloc_buffer(sc->sc_cmd_xfer,
					     USSCANNER_MAX_TRANSFER_SIZE);
	if (sc->sc_cmd_buffer == NULL) {
		printf("%s: alloc cmd buffer failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}

	sc->sc_intr_xfer = usbd_alloc_xfer (uaa->device);
	if (sc->sc_intr_xfer == NULL) {
	  printf("%s: alloc intr xfer failed, err=%d\n",
		 sc->sc_dev.dv_xname, err);
	  usscanner_cleanup(sc);
	  return; 
        }

	sc->sc_data_xfer = usbd_alloc_xfer(uaa->device);
	if (sc->sc_data_xfer == NULL) {
		printf("%s: alloc data xfer failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}
	sc->sc_data_buffer = usbd_alloc_buffer(sc->sc_data_xfer,
					      USSCANNER_MAX_TRANSFER_SIZE);
	if (sc->sc_data_buffer == NULL) {
		printf("%s: alloc data buffer failed, err=%d\n",
		       sc->sc_dev.dv_xname, err);
		usscanner_cleanup(sc);
		return;
	}

	/*
	 * Fill in the adapter.
	 */
	sc->sc_adapter.scsipi_cmd = usscanner_scsipi_cmd;
	sc->sc_adapter.scsipi_minphys = usscanner_scsipi_minphys;

	/*
	 * fill in the prototype scsipi_link.
	 */
	sc->sc_link.flags &= ~SDEV_ATAPI;
	sc->sc_link.adapter_buswidth = 2;
	sc->sc_link.adapter_target = USSCANNER_SCSIID_HOST;

	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &sc->sc_adapter;
	sc->sc_link.openings = 1;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_child = config_found(&sc->sc_dev, &saa, scsiprint);

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

	DPRINTFN(10, ("usscanner_attach: %p\n", sc->sc_udev));
}

int
usscanner_detach(struct device *self, int flags)
{
	struct usscanner_softc *sc = (struct usscanner_softc *)self;
	int rv, s;

	DPRINTF(("usscanner_detach: sc=%p flags=%d\n", sc, flags));

	sc->sc_dying = 1;
	/* Abort all pipes.  Causes processes waiting for transfer to wake. */
	if (sc->sc_in_pipe != NULL)
		usbd_abort_pipe(sc->sc_in_pipe);
	if (sc->sc_intr_pipe != NULL)
		usbd_abort_pipe(sc->sc_intr_pipe);
	if (sc->sc_out_pipe != NULL)
		usbd_abort_pipe(sc->sc_out_pipe);

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
	else
		rv = 0;

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);

	return (rv);
}

void
usscanner_cleanup(struct usscanner_softc *sc)
{
	if (sc->sc_in_pipe != NULL) {
		usbd_close_pipe(sc->sc_in_pipe);
		sc->sc_in_pipe = NULL;
	}
	if (sc->sc_intr_pipe != NULL) {
		usbd_close_pipe(sc->sc_intr_pipe);
		sc->sc_intr_pipe = NULL;
	}
	if (sc->sc_out_pipe != NULL) {
		usbd_close_pipe(sc->sc_out_pipe);
		sc->sc_out_pipe = NULL;
	}
	if (sc->sc_cmd_xfer != NULL) {
		usbd_free_xfer(sc->sc_cmd_xfer);
		sc->sc_cmd_xfer = NULL;
	}
	if (sc->sc_data_xfer != NULL) {
		usbd_free_xfer(sc->sc_data_xfer);
		sc->sc_data_xfer = NULL;
	}
}

int
usscanner_activate(struct device *self, int act)
{
	struct usscanner_softc *sc = (struct usscanner_softc *)self;

	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}

void
usscanner_scsipi_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > USSCANNER_MAX_TRANSFER_SIZE)
		bp->b_bcount = USSCANNER_MAX_TRANSFER_SIZE;
	minphys(bp);
}

void
usscanner_sense(struct usscanner_softc *sc)
{
	struct scsipi_xfer *xs = sc->sc_xs;
	struct scsipi_link *sc_link = xs->sc_link;
	struct scsipi_sense sense_cmd;
	usbd_status err;

	/* fetch sense data */
	memset(&sense_cmd, 0, sizeof(sense_cmd));
	sense_cmd.opcode = REQUEST_SENSE;
	sense_cmd.byte2 = sc_link->lun << SCSI_CMD_LUN_SHIFT;
	sense_cmd.length = sizeof xs->sense;

	sc->sc_state = UAS_SENSECMD;
	memcpy(sc->sc_cmd_buffer, &sense_cmd, sizeof sense_cmd);
	usbd_setup_xfer(sc->sc_cmd_xfer, sc->sc_out_pipe, sc, sc->sc_cmd_buffer,
	    sizeof sense_cmd, USBD_NO_COPY, USSCANNER_TIMEOUT,
	    usscanner_sensecmd_cb);
	err = usbd_transfer(sc->sc_cmd_xfer);
	if (err == USBD_IN_PROGRESS)
		return;

	xs->error = XS_DRIVER_STUFFUP;
	usscanner_done(sc);
}

void
usscanner_intr_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		 usbd_status status)
{
	struct usscanner_softc *sc = priv;

	DPRINTFN(10, ("usscanner_data_cb status=%d\n", status));

#ifdef USSCANNER_DEBUG
	if (sc->sc_state != UAS_STATUS) {
		printf("%s: !UAS_STATUS\n", sc->sc_dev.dv_xname);
	}
	if (sc->sc_status != 0) {
		printf("%s: status byte=0x%02x\n", sc->sc_dev.dv_xname, sc->sc_status);
	}
#endif
	/* XXX what should we do on non-0 status */

	sc->sc_state = UAS_IDLE;

	scsipi_done(sc->sc_xs);
}

void
usscanner_data_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		 usbd_status status)
{
	struct usscanner_softc *sc = priv;
	struct scsipi_xfer *xs = sc->sc_xs;
	u_int32_t len;

	DPRINTFN(10, ("usscanner_data_cb status=%d\n", status));

#ifdef USSCANNER_DEBUG
	if (sc->sc_state != UAS_DATA) {
		printf("%s: !UAS_DATA\n", sc->sc_dev.dv_xname);
	}
#endif

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	xs->resid = xs->datalen - len;

	switch (status) {
	case USBD_NORMAL_COMPLETION:
		if (xs->xs_control & XS_CTL_DATA_IN)
			memcpy(xs->data, sc->sc_data_buffer, len);
		xs->error = XS_NOERROR;
		break;
	case USBD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	case USBD_CANCELLED:
		if (xs->error == XS_SENSE) {
			usscanner_sense(sc);
			return;
		}
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP; /* XXX ? */
		break;
	}
	usscanner_done(sc);
}

void
usscanner_sensedata_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		       usbd_status status)
{
	struct usscanner_softc *sc = priv;
	struct scsipi_xfer *xs = sc->sc_xs;
	u_int32_t len;

	DPRINTFN(10, ("usscanner_sensedata_cb status=%d\n", status));

#ifdef USSCANNER_DEBUG
	if (sc->sc_state != UAS_SENSEDATA) {
		printf("%s: !UAS_SENSEDATA\n", sc->sc_dev.dv_xname);
	}
#endif

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	switch (status) {
	case USBD_NORMAL_COMPLETION:
		memcpy(&xs->sense, sc->sc_data_buffer, len);
		if (len < sizeof xs->sense)
			xs->error = XS_SHORTSENSE;
		break;
	case USBD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	case USBD_CANCELLED:
		xs->error = XS_RESET;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP; /* XXX ? */
		break;
	}
	usscanner_done(sc);
}

void
usscanner_done(struct usscanner_softc *sc)
{
	struct scsipi_xfer *xs = sc->sc_xs;
	usbd_status err;

	DPRINTFN(10,("usscanner_done: error=%d\n", sc->sc_xs->error));

	sc->sc_state = UAS_STATUS;
	usbd_setup_xfer(sc->sc_intr_xfer, sc->sc_intr_pipe, sc, &sc->sc_status,
	    1, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USSCANNER_TIMEOUT, usscanner_intr_cb);
	err = usbd_transfer(sc->sc_intr_xfer);
	if (err == USBD_IN_PROGRESS)
		return;
	xs->error = XS_DRIVER_STUFFUP;
}

void
usscanner_sensecmd_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		      usbd_status status)
{
	struct usscanner_softc *sc = priv;
	struct scsipi_xfer *xs = sc->sc_xs;
	usbd_status err;

	DPRINTFN(10, ("usscanner_sensecmd_cb status=%d\n", status));

#ifdef USSCANNER_DEBUG
#ifdef notyet
	if (usscannerdebug > 15)
		xs->sc_link->flags |= DEBUGLEVEL;
#endif

	if (sc->sc_state != UAS_SENSECMD) {
		printf("%s: !UAS_SENSECMD\n", sc->sc_dev.dv_xname);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif

	switch (status) {
	case USBD_NORMAL_COMPLETION:
		break;
	case USBD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		goto done;
	default:
		xs->error = XS_DRIVER_STUFFUP; /* XXX ? */
		goto done;
	}

	sc->sc_state = UAS_SENSEDATA;
	usbd_setup_xfer(sc->sc_data_xfer, sc->sc_in_pipe, sc,
	    sc->sc_data_buffer,
	    sizeof xs->sense, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USSCANNER_TIMEOUT, usscanner_sensedata_cb);
	err = usbd_transfer(sc->sc_data_xfer);
	if (err == USBD_IN_PROGRESS)
		return;
	xs->error = XS_DRIVER_STUFFUP;
 done:
	usscanner_done(sc);
}

void
usscanner_cmd_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		 usbd_status status)
{
	struct usscanner_softc *sc = priv;
	struct scsipi_xfer *xs = sc->sc_xs;
	usbd_pipe_handle pipe;
	usbd_status err;

	DPRINTFN(10, ("usscanner_cmd_cb status=%d\n", status));

#ifdef USSCANNER_DEBUG
#ifdef notyet
	if (usscannerdebug > 15)
		xs->sc_link->flags |= DEBUGLEVEL;
#endif

	if (sc->sc_state != UAS_CMD) {
		printf("%s: !UAS_CMD\n", sc->sc_dev.dv_xname);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif

	switch (status) {
	case USBD_NORMAL_COMPLETION:
		break;
	case USBD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		goto done;
	case USBD_CANCELLED:
		goto done;
	default:
		xs->error = XS_DRIVER_STUFFUP; /* XXX ? */
		goto done;
	}

	if (xs->datalen == 0) {
		DPRINTFN(4, ("usscanner_cmd_cb: no data phase\n"));
		xs->error = XS_NOERROR;
		goto done;
	}

	if (xs->xs_control & XS_CTL_DATA_IN) {
		DPRINTFN(4, ("usscanner_cmd_cb: data in len=%d\n",
			     xs->datalen));
		pipe = sc->sc_in_pipe;
	} else {
		DPRINTFN(4, ("usscanner_cmd_cb: data out len=%d\n",
			     xs->datalen));
		memcpy(sc->sc_data_buffer, xs->data, xs->datalen);
		pipe = sc->sc_out_pipe;
	}
	sc->sc_state = UAS_DATA;
	usbd_setup_xfer(sc->sc_data_xfer, pipe, sc, sc->sc_data_buffer,
	    xs->datalen, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    xs->timeout, usscanner_data_cb);
	err = usbd_transfer(sc->sc_data_xfer);
	if (err == USBD_IN_PROGRESS)
		return;
	xs->error = XS_DRIVER_STUFFUP;

 done:
	usscanner_done(sc);
}

void
usscanner_scsipi_cmd(struct scsipi_xfer *xs)
{
	struct scsipi_link *sc_link = xs->sc_link;
	struct usscanner_softc *sc = sc_link->adapter_softc;
	usbd_status err;

#ifdef notyet
	DPRINTFN(8, ("%s: usscanner_scsi_cmd: %d:%d "
	    "xs=%p cmd=0x%02x datalen=%d (quirks=0x%x, poll=%d)\n",
	    sc->sc_dev.dv_xname,
	    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun,
	    xs, xs->cmd->opcode, xs->datalen,
	    sc_link->quirks, xs->xs_control & XS_CTL_POLL));
#endif

	if (sc->sc_dying) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

#ifdef USSCANNER_DEBUG
#ifdef notyet
	if (sc_link->scsipi_scsi.target != USSCANNER_SCSIID_DEVICE) {
		DPRINTF(("%s: wrong SCSI ID %d\n", sc->sc_dev.dv_xname,
		    sc_link->scsipi_scsi.target));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif
	if (sc->sc_state != UAS_IDLE) {
		printf("%s: !UAS_IDLE\n", sc->sc_dev.dv_xname);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif

	if (xs->datalen > USSCANNER_MAX_TRANSFER_SIZE) {
		printf("umass_cmd: large datalen, %d\n", xs->datalen);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	DPRINTFN(4, ("usscanner_scsi_cmd: async cmdlen=%d datalen=%d\n",
		    xs->cmdlen, xs->datalen));
	sc->sc_state = UAS_CMD;
	sc->sc_xs = xs;
	memcpy(sc->sc_cmd_buffer, xs->cmd, xs->cmdlen);
	usbd_setup_xfer(sc->sc_cmd_xfer, sc->sc_out_pipe, sc, sc->sc_cmd_buffer,
	    xs->cmdlen, USBD_NO_COPY, USSCANNER_TIMEOUT, usscanner_cmd_cb);
	err = usbd_transfer(sc->sc_cmd_xfer);
	if (err != USBD_IN_PROGRESS) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	return;

 done:
	sc->sc_state = UAS_IDLE;
	scsipi_done(xs);
}
@


1.33
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.32 2010/06/19 21:43:16 krw Exp $	*/
@


1.32
log
@Remove more splbio/splx pairs from around scsi_done() calls.

From Matthew Dempsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.31 2010/03/23 01:57:20 krw Exp $	*/
a79 1
#define scsipi_device		scsi_device
a100 8
struct scsipi_device usscanner_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

a334 1
	sc->sc_link.device = &usscanner_dev;
@


1.31
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.30 2010/01/09 23:15:07 krw Exp $	*/
a473 1
	int s;
a488 1
	s = splbio();
a489 1
	splx(s);
a707 1
	int s;
a761 1
	s = splbio();
a762 1
	splx(s);
@


1.30
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.29 2009/10/13 19:33:19 pirofti Exp $	*/
d153 1
a153 1
int usscanner_scsipi_cmd(struct scsipi_xfer *xs);
d705 1
a705 1
int
d762 1
a762 1
	return (SUCCESSFULLY_QUEUED);
a768 2

	return (COMPLETE);
@


1.29
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.28 2009/02/16 21:19:07 miod Exp $	*/
a89 1
#define XS_STS_DONE		ITSDONE
a489 1
	sc->sc_xs->xs_control |= XS_STS_DONE;
a765 1
	xs->xs_control |= XS_STS_DONE;
@


1.28
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.27 2008/06/26 05:42:19 ray Exp $	*/
d168 1
a168 1
int usscanner_activate(struct device *, enum devact); 
d420 1
a420 1
usscanner_activate(struct device *self, enum devact act)
@


1.27
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.26 2007/10/20 04:37:54 krw Exp $	*/
d155 1
a155 1
void usscanner_scsipi_minphys(struct buf *bp);
d436 1
a436 1
usscanner_scsipi_minphys(struct buf *bp)
@


1.26
log
@Doh. Setting ITSDONE and returning SUCCESSFULLY_QUEUED just means
there is another splbio()/splx and a check for ITSDONE before falling
into the COMPLETE case. So just return COMPLETE if the command has
completed (or never started). Simpler all around.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.25 2007/10/20 04:01:39 krw Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.25
log
@DO NOT access xs after calling scsi_done(xs). It's not there anymore.

Also set ITSDONE (a.k.a. XS_STS_DONE) in correct field - xs->flags
(a.k.a. xs->xs_control) and not xs->status (a.k.a. xs->xs_status).

'totally OK' deraadt@@ 'yes' beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.24 2007/10/11 18:33:15 deraadt Exp $	*/
d720 1
a720 1
	int rslt, s;
a775 4
	if (xs->xs_control & XS_CTL_POLL)
		rslt = COMPLETE;
	else
		rslt = SUCCESSFULLY_QUEUED;
d780 1
a780 1
	return (rslt);
@


1.24
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.23 2007/09/17 01:40:38 fgsch Exp $	*/
d498 1
a498 1
	sc->sc_xs->xs_status |= XS_STS_DONE;
d720 1
a772 1

d775 1
a775 2
	xs->xs_status |= XS_STS_DONE;
	scsipi_done(xs);
d777 1
a777 1
		return (COMPLETE);
d779 6
a784 1
		return (SUCCESSFULLY_QUEUED);
@


1.23
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.22 2007/06/14 10:11:16 mbalmer Exp $	*/
a213 1
	char			*devinfop;
a219 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.22
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.21 2007/06/13 06:25:03 mbalmer Exp $	*/
a59 1
#include <sys/malloc.h>
@


1.21
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.20 2007/06/12 16:26:37 mbalmer Exp $	*/
d173 16
a188 1
USB_DECLARE_DRIVER(usscanner);
@


1.20
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.19 2007/06/10 14:49:01 mbalmer Exp $	*/
d150 1
a150 1
	struct device *		sc_child;	/* child device, for detach */
@


1.19
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.18 2007/06/10 10:53:49 mbalmer Exp $	*/
d150 1
a150 1
	device_ptr_t		sc_child;	/* child device, for detach */
d418 1
a418 1
usscanner_activate(device_ptr_t self, enum devact act)
@


1.18
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.17 2007/06/06 19:25:50 mk Exp $	*/
d209 1
a209 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d215 1
a215 1
		    USBDEVNAME(sc->sc_dev));
d222 1
a222 1
		    USBDEVNAME(sc->sc_dev));
d239 1
a239 1
			    USBDEVNAME(sc->sc_dev), i);
d255 1
a255 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
d263 1
a263 1
		       USBDEVNAME(sc->sc_dev), err);
d273 1
a273 1
		       USBDEVNAME(sc->sc_dev), err);
d281 1
a281 1
		       USBDEVNAME(sc->sc_dev), err);
d289 1
a289 1
		       USBDEVNAME(sc->sc_dev), err);
d299 1
a299 1
		       USBDEVNAME(sc->sc_dev), err);
d307 1
a307 1
		 USBDEVNAME(sc->sc_dev), err);
d315 1
a315 1
		       USBDEVNAME(sc->sc_dev), err);
d323 1
a323 1
		       USBDEVNAME(sc->sc_dev), err);
d479 1
a479 1
		printf("%s: !UAS_STATUS\n", USBDEVNAME(sc->sc_dev));
d482 1
a482 1
		printf("%s: status byte=0x%02x\n", USBDEVNAME(sc->sc_dev), sc->sc_status);
d507 1
a507 1
		printf("%s: !UAS_DATA\n", USBDEVNAME(sc->sc_dev));
d549 1
a549 1
		printf("%s: !UAS_SENSEDATA\n", USBDEVNAME(sc->sc_dev));
d609 1
a609 1
		printf("%s: !UAS_SENSECMD\n", USBDEVNAME(sc->sc_dev));
d657 1
a657 1
		printf("%s: !UAS_CMD\n", USBDEVNAME(sc->sc_dev));
d715 1
a715 1
	    USBDEVNAME(sc->sc_dev),
d729 1
a729 1
		DPRINTF(("%s: wrong SCSI ID %d\n", USBDEVNAME(sc->sc_dev),
d736 1
a736 1
		printf("%s: !UAS_IDLE\n", USBDEVNAME(sc->sc_dev));
@


1.17
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.16 2007/06/05 08:43:56 mbalmer Exp $	*/
d352 1
a352 1
			   USBDEV(sc->sc_dev));
d377 1
a377 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d387 1
a387 1
			   USBDEV(sc->sc_dev));
@


1.16
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.15 2007/06/04 10:34:04 mbalmer Exp $	*/
d120 1
a120 1
 	USBBASEDEVICE		sc_dev;
@


1.15
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.14 2007/05/27 04:00:25 jsg Exp $	*/
d111 1
a111 1
Static struct scsipi_device usscanner_dev =
d161 5
a165 5
Static void usscanner_cleanup(struct usscanner_softc *sc);
Static int usscanner_scsipi_cmd(struct scsipi_xfer *xs);
Static void usscanner_scsipi_minphys(struct buf *bp);
Static void usscanner_done(struct usscanner_softc *sc);
Static void usscanner_sense(struct usscanner_softc *sc);
d167 5
a171 5
Static callback usscanner_intr_cb;
Static callback usscanner_cmd_cb;
Static callback usscanner_data_cb;
Static callback usscanner_sensecmd_cb;
Static callback usscanner_sensedata_cb;
d392 1
a392 1
Static void
d433 1
a433 1
Static void
d441 1
a441 1
Static void
d468 1
a468 1
Static void
d495 1
a495 1
Static void
d537 1
a537 1
Static void
d574 1
a574 1
Static void
d592 1
a592 1
Static void
d639 1
a639 1
Static void
d705 1
a705 1
Static int
@


1.14
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.13 2007/05/21 05:40:28 jsg Exp $	*/
a70 7
#if defined(__NetBSD__)
#include <sys/scsiio.h>
#include <dev/scsipi/scsi_all.h>
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsiconf.h>
#include <dev/scsipi/atapiconf.h>
#elif defined(__OpenBSD__)
a73 1
#endif
a152 4
#if defined(__NetBSD__)
	struct atapi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter._generic
#else
a154 1
#endif
a336 4
#if defined(__NetBSD__)
	sc->sc_link.type = BUS_SCSI;
#endif
#if defined(__OpenBSD__)
a339 1
#endif
a344 6
#if defined(__NetBSD__)
	sc->sc_link.scsipi_scsi.channel = SCSI_CHANNEL_ONLY_ONE;
	sc->sc_link.scsipi_scsi.adapter_target = USSCANNER_SCSIID_HOST;
	sc->sc_link.scsipi_scsi.max_target = USSCANNER_SCSIID_DEVICE;
	sc->sc_link.scsipi_scsi.max_lun = 0;
#endif
a451 3
#if defined(__NetBSD__)
	sense_cmd.byte2 = sc_link->scsipi_scsi.lun << SCSI_CMD_LUN_SHIFT;
#else
a452 1
#endif
@


1.13
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.12 2006/11/28 23:59:45 dlg Exp $	*/
d188 2
a189 1
USB_MATCH(usscanner)
d191 1
a191 1
	USB_MATCH_START(usscanner, uaa);
d205 2
a206 1
USB_ATTACH(usscanner)
d208 2
a209 1
	USB_ATTACH_START(usscanner, sc, uaa);
d222 1
a222 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d229 1
a229 1
		USB_ATTACH_ERROR_RETURN;
d236 1
a236 1
		USB_ATTACH_ERROR_RETURN;
d253 1
a253 1
			USB_ATTACH_ERROR_RETURN;
d269 1
a269 1
		USB_ATTACH_ERROR_RETURN;
d277 1
a277 1
		USB_ATTACH_ERROR_RETURN;
d288 1
a288 1
		USB_ATTACH_ERROR_RETURN;
d296 1
a296 1
		USB_ATTACH_ERROR_RETURN;
d304 1
a304 1
		USB_ATTACH_ERROR_RETURN;
d314 1
a314 1
		USB_ATTACH_ERROR_RETURN;
d322 1
a322 1
	  USB_ATTACH_ERROR_RETURN;
d330 1
a330 1
		USB_ATTACH_ERROR_RETURN;
d338 1
a338 1
		USB_ATTACH_ERROR_RETURN;
a378 2

	USB_ATTACH_SUCCESS_RETURN;
d381 2
a382 1
USB_DETACH(usscanner)
d384 1
a384 1
	USB_DETACH_START(usscanner, sc);
@


1.12
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.11 2006/06/23 06:27:12 miod Exp $	*/
d84 2
a85 2
#define DPRINTF(x)	do { if (usscannerdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (usscannerdebug>(n)) logprintf x; } while (0)
@


1.11
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.10 2005/08/01 05:36:49 brad Exp $	*/
d207 1
d368 4
a371 1
	sc->sc_child = config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
@


1.10
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.9 2004/07/08 22:18:45 deraadt Exp $	*/
a442 1
		return (EOPNOTSUPP);
@


1.9
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.8 2003/05/17 06:07:57 nate Exp $	*/
d209 1
a209 1
	char			devinfo[1024];
d217 1
a217 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d219 2
a220 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.8
log
@sync with NetBSD and add various local hacks to make things work correctly
with our scsi layer
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.7 2003/05/07 04:33:33 deraadt Exp $	*/
d84 2
a85 2
#define DPRINTF(x)	if (usscannerdebug) logprintf x
#define DPRINTFN(n,x)	if (usscannerdebug>(n)) logprintf x
@


1.7
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.6 2002/07/25 02:18:11 nate Exp $	*/
d92 16
@


1.6
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.5 2002/05/07 18:29:19 nate Exp $	*/
d201 1
a201 1
	usbd_devinfo(dev, 0, devinfo);
@


1.5
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.3 2001/05/03 02:20:35 aaron Exp $	*/
d246 1
a246 1
	if (sc->sc_in_addr == -1 || sc->sc_intr_addr == -1 || 
d288 1
a288 1
	sc->sc_cmd_buffer = usbd_alloc_buffer(sc->sc_cmd_xfer, 
d312 1
a312 1
	sc->sc_data_buffer = usbd_alloc_buffer(sc->sc_data_xfer, 
d326 1
a326 1
	
d349 1
a349 1
	
d465 1
a465 1
	    sizeof sense_cmd, USBD_NO_COPY, USSCANNER_TIMEOUT, 
d495 1
a495 1
		
@


1.4
log
@Sync ulpt driver with NetBSD
@
text
@a91 16
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
@


1.3
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.2 2001/02/20 13:43:29 ho Exp $	*/
d92 16
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.3 2001/05/03 02:20:35 aaron Exp $	*/
@


1.3.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.3.6.1 2002/06/11 03:42:31 art Exp $	*/
d246 1
a246 1
	if (sc->sc_in_addr == -1 || sc->sc_intr_addr == -1 ||
d288 1
a288 1
	sc->sc_cmd_buffer = usbd_alloc_buffer(sc->sc_cmd_xfer,
d312 1
a312 1
	sc->sc_data_buffer = usbd_alloc_buffer(sc->sc_data_xfer,
d326 1
a326 1

d349 1
a349 1

d465 1
a465 1
	    sizeof sense_cmd, USBD_NO_COPY, USSCANNER_TIMEOUT,
d495 1
a495 1

@


1.3.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a91 16
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
d201 1
a201 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD$	*/
a351 2
	DPRINTFN(10, ("usscanner_attach: %p\n", sc->sc_udev));

d354 2
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usscanner.c,v 1.6 2001/01/23 14:04:14 augustss Exp $	*/
d352 2
a355 2

	DPRINTFN(10, ("usscanner_attach: %p\n", sc->sc_udev));
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d246 1
a246 1
	if (sc->sc_in_addr == -1 || sc->sc_intr_addr == -1 ||
d288 1
a288 1
	sc->sc_cmd_buffer = usbd_alloc_buffer(sc->sc_cmd_xfer,
d312 1
a312 1
	sc->sc_data_buffer = usbd_alloc_buffer(sc->sc_data_xfer,
d326 1
a326 1

d349 1
a349 1

d465 1
a465 1
	    sizeof sense_cmd, USBD_NO_COPY, USSCANNER_TIMEOUT,
d495 1
a495 1

@


1.3.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.3.2.3 2003/03/28 00:38:33 niklas Exp $	*/
d201 1
a201 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.3.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usscanner.c,v 1.3.2.4 2003/05/13 19:35:13 ho Exp $	*/
a91 16
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
@


1.2
log
@Compile with USCANNER_DEBUG, implied by USB_DEBUG.
@
text
@d1 2
a2 2
/*	$OpenBSD: usscanner.c,v 1.1 2001/01/28 16:31:24 aaron Exp $	*/
/*	$NetBSD$	*/
a351 2
	DPRINTFN(10, ("usscanner_attach: %p\n", sc->sc_udev));

d354 2
@


1.1
log
@Add driver for HP5300 scanner which uses a homebrew SCSI-over-USB protocol.
From NetBSD. /* XXX - untested */
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d610 1
d613 1
d658 1
d661 1
d719 1
d726 1
d734 1
d741 1
@

