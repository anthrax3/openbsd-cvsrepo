head	1.9;
access;
symbols
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.4.0.8
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.6
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.4
	OPENBSD_5_0:1.4.0.2
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.1.0.6
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.4
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.2
	OPENBSD_4_7_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.08.15.15.01.48;	author edd;	state dead;
branches;
next	1.8;

1.8
date	2013.07.09.10.16.48;	author edd;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.01.20.34.52;	author matthieu;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2011.03.03.21.48.49;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.09.21.27.19;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Blast uhts(4). This code was merged into ums(4) last week.

OK mpi@@
@
text
@/*	$OpenBSD: uhts.c,v 1.8 2013/07/09 10:16:48 edd Exp $ */
/*
 * Copyright (c) 2009 Matthieu Herrb <matthieu@@herrb.eu>
 * Copyright (c) 2007 Robert Nagy <robert@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>
#include <dev/usb/hid.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (uhtsdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhtsdebug>(n)) printf x; } while (0)
int	uhtsdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UHTSUNIT(s)	(minor(s))

/* defined in such a way as to aid merge of hidms.c */
#define UHTS_TIP	0x100
#define UHTS_BARELL	0x200
#define UHTS_ERASER	0x400

struct tsscale {
	int	minx, maxx;
	int	miny, maxy;
	int	swapxy;
	int	resx, resy;
};

struct uhts_softc {
	struct uhidev sc_hdev;
	struct hid_location sc_loc_x, sc_loc_y;
#define UHTS_MAX_BUTTONS		31
	struct hid_location sc_loc_btn[UHTS_MAX_BUTTONS];
	int sc_num_buttons;
	int sc_enabled;
	u_int32_t sc_buttons;	/* mouse button status */
	int sc_rawmode;
	struct tsscale sc_tsscale;
	struct device *sc_wsmousedev;
	char sc_dying;
};

struct uhts_pos {
	int down;
	int x, y;
	int z;			/* touch pressure */
};

void uhts_intr(struct uhidev *, void *, u_int);
int uhts_enable(void *);
void uhts_disable(void *);
int uhts_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wsmouse_accessops uhts_accessops = {
	uhts_enable,
	uhts_ioctl,
	uhts_disable
};

int uhts_match(struct device *, void *, void *);
void uhts_attach(struct device *, struct device *, void *);
int uhts_detach(struct device *, int);
int uhts_activate(struct device *, int);
void uhts_parse_desc(struct uhts_softc *);

struct cfdriver uhts_cd = {
	NULL, "uhts", DV_DULL
};

const struct cfattach uhts_ca = {
	sizeof(struct uhts_softc),
	uhts_match,
	uhts_attach,
	uhts_detach,
	uhts_activate
};

int
uhts_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
	void *desc;

	uhidev_get_report_desc(uha->parent, &desc, &size);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_DIGITIZERS, HUD_TOUCHSCREEN)))
		return (UMATCH_IFACECLASS);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_DIGITIZERS, HUD_PEN)))
		return (UMATCH_IFACECLASS);

	return (UMATCH_NONE);
}

void
uhts_parse_desc(struct uhts_softc *sc)
{
	struct hid_data *d;
	struct hid_item h;
	int size;
	void *desc;

	uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
	d = hid_start_parse(desc, size, hid_input);
	while (hid_get_item(d, &h)) {
		if (h.kind != hid_input ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_GENERIC_DESKTOP ||
		    h.report_ID != sc->sc_hdev.sc_report_id)
			continue;
		DPRINTF(("uhts: usage=0x%x range %d..%d\n",
			h.usage, h.logical_minimum, h.logical_maximum));
		switch (HID_GET_USAGE(h.usage)) {
		case HUG_X:
			sc->sc_tsscale.minx = h.logical_minimum;
			sc->sc_tsscale.maxx = h.logical_maximum;
			break;
		case HUG_Y:
			sc->sc_tsscale.miny = h.logical_minimum;
			sc->sc_tsscale.maxy = h.logical_maximum;
			break;
		}
	}
}

void
uhts_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhts_softc *sc = (struct uhts_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct wsmousedev_attach_args a;
	void *desc;
	int size;
	u_int32_t flags, buttons_flags = 0;

	sc->sc_hdev.sc_intr = uhts_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);

	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X),
	       uha->reportid, hid_input, &sc->sc_loc_x, &flags)) {
		printf("\n%s: touchscreen has no X report\n",
		       sc->sc_hdev.sc_dev.dv_xname);
		return;
	}
	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y),
	       uha->reportid, hid_input, &sc->sc_loc_y, &flags)) {
		printf("\n%s: touchscreen has no Y report\n",
		       sc->sc_hdev.sc_dev.dv_xname);
		return;
	}

	if (hid_locate(desc, size, HID_USAGE2(HUP_DIGITIZERS,
	    HUD_TIP_SWITCH), uha->reportid, hid_input,
	    &sc->sc_loc_btn[sc->sc_num_buttons], NULL)){
		buttons_flags |= UHTS_TIP;
		sc->sc_num_buttons++;
	}

	if (hid_locate(desc, size, HID_USAGE2(HUP_DIGITIZERS,
	    HUD_BARREL_SWITCH), uha->reportid, hid_input,
	    &sc->sc_loc_btn[sc->sc_num_buttons], NULL)){
		buttons_flags |= UHTS_BARELL;
		sc->sc_num_buttons++;
	}

	if (hid_locate(desc, size, HID_USAGE2(HUP_DIGITIZERS,
	    HUD_ERASER), uha->reportid, hid_input,
	    &sc->sc_loc_btn[sc->sc_num_buttons], NULL)){
		buttons_flags |= UHTS_ERASER;
		sc->sc_num_buttons++;
	}

	printf(": %d button%s",
	    sc->sc_num_buttons, sc->sc_num_buttons <= 1 ? "" : "s");
	if (buttons_flags & UHTS_TIP)
		printf(", tip");
	if (buttons_flags & UHTS_BARELL)
		printf(", barrel");
	if (buttons_flags & UHTS_ERASER)
		printf(", eraser");
	printf("\n");

	a.accessops = &uhts_accessops;
	a.accesscookie = sc;

	uhts_parse_desc(sc);
	sc->sc_rawmode = 0;
	/*  wild guess */
	sc->sc_tsscale.swapxy = 0;
	sc->sc_tsscale.resx = 1024;
	sc->sc_tsscale.resy = 768;

	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
}

int
uhts_activate(struct device *self, int act)
{
	struct uhts_softc *sc = (struct uhts_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_wsmousedev != NULL)
			rv = config_deactivate(sc->sc_wsmousedev);
		sc->sc_dying = 1;
		break;
	}
	return (rv);
}

int
uhts_detach(struct device *self, int flags)
{
	struct uhts_softc *sc = (struct uhts_softc *)self;
	int rv = 0;

	DPRINTF(("uhts_detach: sc=%p flags=%d\n", sc, flags));

	/* wsmouse takes care of reference counting */
	if (sc->sc_wsmousedev != NULL)
		rv = config_detach(sc->sc_wsmousedev, flags);
	return (rv);
}

void
uhts_intr(struct uhidev *addr, void *buf, u_int len)
{
	struct uhts_softc *sc = (struct uhts_softc *)addr;
	u_char *ibuf = (u_char *)buf;
	struct uhts_pos tp;
	int x, y, s, i;
	u_int32_t buttons = 0;

	DPRINTFN(5, ("uhts_intr: len=%d\n", len));

	x = hid_get_data(ibuf, &sc->sc_loc_x);
	y = hid_get_data(ibuf, &sc->sc_loc_y);

	for (i = 0; i < sc->sc_num_buttons; i++) {
		if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
			buttons |= 1 << i;
	}

	DPRINTFN(10, ("uhts_intr: x:%d y:%d buttons:0x%x\n",
		x, y, buttons));

	if (sc->sc_tsscale.swapxy && !sc->sc_rawmode) {
		/* Swap X/Y-Axis */
		tp.y = x;
		tp.x = y;
	} else {
		tp.x = x;
		tp.y = y;
	}
	if (!sc->sc_rawmode &&
	    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx) != 0 &&
	    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny) != 0) {
		/* Scale down to the screen resolution. */
		tp.x = ((tp.x - sc->sc_tsscale.minx) *
		    sc->sc_tsscale.resx) /
		    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx);
		tp.y = ((tp.y - sc->sc_tsscale.miny) *
		    sc->sc_tsscale.resy) /
		    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny);
	}

	sc->sc_buttons = buttons;
	tp.z = buttons;

	if (sc->sc_wsmousedev != NULL) {
		s = spltty();
		wsmouse_input(sc->sc_wsmousedev, buttons, tp.x, tp.y, tp.z, 0,
		    WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
		    WSMOUSE_INPUT_ABSOLUTE_Z);

		splx(s);
	}
}

int
uhts_enable(void *v)
{
	struct uhts_softc *sc = v;

	DPRINTFN(1, ("uhts_enable: sc=%p\n", sc));

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_enabled)
		return (EBUSY);

	sc->sc_enabled = 1;
	sc->sc_buttons = 0;

	return (uhidev_open(&sc->sc_hdev));
}

void
uhts_disable(void *v)
{
	struct uhts_softc *sc = v;

	DPRINTFN(1, ("uhts_disable: sc=%p\n", sc));
#ifdef DIAGNOSTIC
	if (!sc->sc_enabled) {
		printf("uhts_disable: not enabled\n");
		return;
	}
#endif
	sc->sc_enabled = 0;
	uhidev_close(&sc->sc_hdev);
}

int
uhts_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct uhts_softc *sc = v;
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;
	int rc, error = 0;

	DPRINTF(("uhts_ioctl(%d, '%c', %d)\n",
	    IOCPARM_LEN(cmd), IOCGROUP(cmd), cmd & 0xff));

	rc = uhidev_ioctl(&sc->sc_hdev, cmd, data, flag, p);
	if (rc != -1)
		return rc;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_TPANEL;
		return (0);
	case WSMOUSEIO_SCALIBCOORDS:
		if (!(wsmc->minx >= 0 && wsmc->maxx >= 0 &&
		    wsmc->miny >= 0 && wsmc->maxy >= 0 &&
		    wsmc->resx >= 0 && wsmc->resy >= 0 &&
		    wsmc->minx < 32768 && wsmc->maxx < 32768 &&
		    wsmc->miny < 32768 && wsmc->maxy < 32768 &&
		    (wsmc->maxx - wsmc->minx) != 0 &&
		    (wsmc->maxy - wsmc->miny) != 0 &&
		    wsmc->resx < 32768 && wsmc->resy < 32768 &&
		    wsmc->swapxy >= 0 && wsmc->swapxy <= 1 &&
		    wsmc->samplelen >= 0 && wsmc->samplelen <= 1))
			return (EINVAL);

		sc->sc_tsscale.minx = wsmc->minx;
		sc->sc_tsscale.maxx = wsmc->maxx;
		sc->sc_tsscale.miny = wsmc->miny;
		sc->sc_tsscale.maxy = wsmc->maxy;
		sc->sc_tsscale.swapxy = wsmc->swapxy;
		sc->sc_tsscale.resx = wsmc->resx;
		sc->sc_tsscale.resy = wsmc->resy;
		sc->sc_rawmode = wsmc->samplelen;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		wsmc->minx = sc->sc_tsscale.minx;
		wsmc->maxx = sc->sc_tsscale.maxx;
		wsmc->miny = sc->sc_tsscale.miny;
		wsmc->maxy = sc->sc_tsscale.maxy;
		wsmc->swapxy = sc->sc_tsscale.swapxy;
		wsmc->resx = sc->sc_tsscale.resx;
		wsmc->resy = sc->sc_tsscale.resy;
		wsmc->samplelen = sc->sc_rawmode;
		break;
	default:
		error = ENOTTY;
		break;
	}

	return error;
}
@


1.8
log
@Add basic support for digitisers with pens in uhts(4).

With help from matthieu@@ and mpi@@.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.7 2013/07/01 20:34:52 matthieu Exp $ */
@


1.7
log
@Pass ioctl() calls to parent uhidev() device first, to be able to
get the HID descriptor with usbhidctl -r, among others. ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.6 2013/03/28 03:58:03 tedu Exp $ */
d81 5
d96 3
a98 1
	struct hid_location sc_loc_btn;
a101 1
	int sc_oldx, sc_oldy;
d151 10
a160 4
	if (!hid_is_collection(desc, size, uha->reportid,
		HID_USAGE2(HUP_DIGITIZERS, HUD_TOUCHSCREEN)))
		return (UMATCH_NONE);
	return (UMATCH_IFACECLASS);
d202 1
a202 1
	u_int32_t flags;
d222 20
a241 6
	if (!hid_locate(desc, size, HID_USAGE2(HUP_DIGITIZERS,
		    HUD_TIP_SWITCH), uha->reportid, hid_input,
		&sc->sc_loc_btn, NULL)){
		printf("\n%s: touch screen has no button\n",
		    sc->sc_hdev.sc_dev.dv_xname);
		return;
d243 9
d303 1
a303 1
	int x, y, s;
d310 5
a314 2
	if (hid_get_data(ibuf, &sc->sc_loc_btn))
		buttons = 1;
d319 4
a322 20
	if (buttons) {
		if (sc->sc_tsscale.swapxy && !sc->sc_rawmode) {
			/* Swap X/Y-Axis */
			tp.y = x;
			tp.x = y;
		} else {
			tp.x = x;
			tp.y = y;
		}
		if (!sc->sc_rawmode &&
		    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx) != 0 &&
		    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny) != 0) {
			/* Scale down to the screen resolution. */
			tp.x = ((tp.x - sc->sc_tsscale.minx) *
			    sc->sc_tsscale.resx) /
			    (sc->sc_tsscale.maxx - sc->sc_tsscale.minx);
			tp.y = ((tp.y - sc->sc_tsscale.miny) *
			    sc->sc_tsscale.resy) /
			    (sc->sc_tsscale.maxy - sc->sc_tsscale.miny);
		}
d324 13
a336 2
		tp.x = sc->sc_oldx;
		tp.y = sc->sc_oldy;
d347 1
a347 2
		sc->sc_oldx = tp.x;
		sc->sc_oldy = tp.y;
@


1.6
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.5 2013/03/28 03:31:55 tedu Exp $ */
d360 1
a360 1
	int error = 0;
d364 4
@


1.5
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.4 2011/07/03 15:47:17 matthew Exp $ */
a55 1
#include <sys/proc.h>
@


1.4
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.3 2011/04/07 15:30:16 miod Exp $ */
a56 1
#include <sys/vnode.h>
@


1.3
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.2 2011/03/03 21:48:49 kettenis Exp $ */
a240 2
	case DVACT_ACTIVATE:
		break;
@


1.2
log
@Prevent division-by-zero when scaling down to the screen resolution.  Make
the WSMOUSEIO_SCALIBCOORDS fail with EINVAL if the settings would cause a
division-by-zero.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhts.c,v 1.1 2009/12/09 21:27:19 matthieu Exp $ */
d214 1
a214 1
		&sc->sc_loc_btn, 0)){
@


1.1
log
@add uhts(4) a driver for USB HID touchscreens. ok miod@@.
Man page advices by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d294 3
a296 1
		if (!sc->sc_rawmode) {
d379 2
@

