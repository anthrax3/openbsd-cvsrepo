head	1.39;
access;
symbols
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.6
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.4
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.10
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.39
date	2013.08.20.09.14.18;	author mpi;	state dead;
branches;
next	1.38;

1.38
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2011.11.27.09.20.57;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2011.09.18.23.24.12;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2011.03.22.16.31.19;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.06.05.46.17;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.06.04.41.40;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.05.13.06.57;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2010.04.21.21.07.47;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.09.08.52.10;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.16.13.31.04;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.04.06.59.36;	author canacar;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.30.07.16.09;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.07.20.16.44;	author canacar;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.13.20.20.21;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.19.08.21.46;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.16.14.55.10;	author damien;	state Exp;
branches;
next	;


desc
@@


1.39
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@/*	$OpenBSD: ueagle.c,v 1.38 2013/04/15 09:23:02 mglocker Exp $	*/

/*-
 * Copyright (c) 2003-2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Driver for Analog Devices Eagle chipset.
 * http://www.analog.com/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/bpf.h>
#include <net/if.h>
#include <net/if_atm.h>
#include <net/if_media.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_atm.h>
#include <netinet/if_ether.h>
#endif

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/ezload.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ueaglereg.h>
#include <dev/usb/ueaglevar.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (ueagledebug > 0) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (ueagledebug >= (n)) printf x; } while (0)
int ueagledebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

/* various supported device vendors/products */
static const struct ueagle_type {
	struct usb_devno	dev;
	const char		*fw;
} ueagle_devs[] = {
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEI },      NULL },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEI_NF },   "ueagleI" },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEII },     NULL },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEII_NF },  "ueagleII" },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEIIC },    NULL },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEIIC_NF }, "ueagleII" },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEIII },    NULL },
  { { USB_VENDOR_ANALOG, USB_PRODUCT_ANALOG_EAGLEIII_NF }, "ueagleIII" },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_HEINEKEN_A },     NULL },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_HEINEKEN_A_NF },  "ueagleI" },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_HEINEKEN_B },     NULL },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_HEINEKEN_B_NF },  "ueagleI" },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_MILLER_A },       NULL },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_MILLER_A_NF },    "ueagleI" },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_MILLER_B },       NULL },
  { { USB_VENDOR_USR,    USB_PRODUCT_USR_MILLER_B_NF },    "ueagleI" }
};
#define ueagle_lookup(v, p)	\
	((struct ueagle_type *)usb_lookup(ueagle_devs, v, p))

void		ueagle_attachhook(void *);
int		ueagle_getesi(struct ueagle_softc *, uint8_t *);
void		ueagle_loadpage(void *);
void		ueagle_request(struct ueagle_softc *, uint16_t, uint16_t,
		    void *, int);
#ifdef USB_DEBUG
void		ueagle_dump_cmv(struct ueagle_softc *, struct ueagle_cmv *);
#endif
int		ueagle_cr(struct ueagle_softc *, uint32_t, uint16_t,
		    uint32_t *);
int		ueagle_cw(struct ueagle_softc *, uint32_t, uint16_t, uint32_t);
int		ueagle_stat(struct ueagle_softc *);
void		ueagle_stat_thread(void *);
int		ueagle_boot(struct ueagle_softc *);
void		ueagle_swap_intr(struct ueagle_softc *, struct ueagle_swap *);
void		ueagle_cmv_intr(struct ueagle_softc *, struct ueagle_cmv *);
void		ueagle_intr(struct usbd_xfer *, void *, usbd_status);
uint32_t	ueagle_crc_update(uint32_t, uint8_t *, int);
void		ueagle_push_cell(struct ueagle_softc *, uint8_t *);
void		ueagle_rxeof(struct usbd_xfer *, void *, usbd_status);
void		ueagle_txeof(struct usbd_xfer *, void *, usbd_status);
int		ueagle_encap(struct ueagle_softc *, struct mbuf *);
void		ueagle_start(struct ifnet *);
int		ueagle_open_vcc(struct ueagle_softc *,
		    struct atm_pseudoioctl *);
int		ueagle_close_vcc(struct ueagle_softc *,
		    struct atm_pseudoioctl *);
int		ueagle_ioctl(struct ifnet *, u_long, caddr_t);
int		ueagle_open_pipes(struct ueagle_softc *);
void		ueagle_close_pipes(struct ueagle_softc *);
int		ueagle_init(struct ifnet *);
void		ueagle_stop(struct ifnet *, int);

int ueagle_match(struct device *, void *, void *); 
void ueagle_attach(struct device *, struct device *, void *); 
int ueagle_detach(struct device *, int); 
int ueagle_activate(struct device *, int); 

struct cfdriver ueagle_cd = { 
	NULL, "ueagle", DV_DULL 
}; 

const struct cfattach ueagle_ca = { 
	sizeof(struct ueagle_softc), 
	ueagle_match, 
	ueagle_attach, 
	ueagle_detach, 
	ueagle_activate, 
};

int
ueagle_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface != NULL)
		return UMATCH_NONE;

	return (ueagle_lookup(uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
ueagle_attachhook(void *xsc)
{
	char *firmwares[2];
	struct ueagle_softc *sc = xsc;

	firmwares[0] = (char *)sc->fw;
	firmwares[1] = NULL;

	if (ezload_downloads_and_reset(sc->sc_udev, firmwares) != 0) {
		printf("%s: could not download firmware\n",
		    sc->sc_dev.dv_xname);
		return;
	}
}

void
ueagle_attach(struct device *parent, struct device *self, void *aux)
{
	struct ueagle_softc *sc = (struct ueagle_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ifnet *ifp = &sc->sc_if;
	uint8_t addr[ETHER_ADDR_LEN];

	sc->sc_udev = uaa->device;

	/*
	 * Pre-firmware modems must be flashed and reset first.  They will
	 * automatically detach themselves from the bus and reattach later
	 * with a new product Id.
	 */
	sc->fw = ueagle_lookup(uaa->vendor, uaa->product)->fw;
	if (sc->fw != NULL) {
		if (rootvp == NULL)
			mountroothook_establish(ueagle_attachhook, sc);
		else
			ueagle_attachhook(sc);

		/* processing of pre-firmware modems ends here */
		return;
	}

	if (usbd_set_config_no(sc->sc_udev, UEAGLE_CONFIG_NO, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	if (ueagle_getesi(sc, addr) != 0) {
		printf("%s: could not read end system identifier\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	printf("%s: address: %02x:%02x:%02x:%02x:%02x:%02x\n",
	    sc->sc_dev.dv_xname, addr[0], addr[1], addr[2], addr[3],
	    addr[4], addr[5]);

	usb_init_task(&sc->sc_swap_task, ueagle_loadpage, sc,
	    USB_TASK_TYPE_GENERIC);

	ifp->if_softc = sc;
	ifp->if_flags = IFF_SIMPLEX;
	ifp->if_ioctl = ueagle_ioctl;
	ifp->if_start = ueagle_start;
	IFQ_SET_READY(&ifp->if_snd);
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	atm_ifattach(ifp);

	/* override default MTU value (9180 is too large for us) */
	ifp->if_mtu = UEAGLE_IFMTU;

#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_RAW, 0);
#endif
}

int
ueagle_detach(struct device *self, int flags)
{
	struct ueagle_softc *sc = (struct ueagle_softc *)self;
	struct ifnet *ifp = &sc->sc_if;

	if (sc->fw != NULL)
		return 0; /* shortcut for pre-firmware devices */

	ueagle_stop(ifp, 1);

	/* wait for stat thread to exit properly */
	if (sc->stat_thread != NULL) {
		DPRINTFN(3, ("%s: waiting for stat thread to exit\n",
		    sc->sc_dev.dv_xname));

		tsleep(sc->stat_thread, PZERO, "ueaglestat", 0);

		DPRINTFN(3, ("%s: stat thread exited properly\n",
		    sc->sc_dev.dv_xname));
	}

	if (ifp->if_softc != NULL)
		if_detach(ifp);

	return 0;
}

/*
 * Retrieve the device End System Identifier (MAC address).
 */
int
ueagle_getesi(struct ueagle_softc *sc, uint8_t *addr)
{
	usb_string_descriptor_t us;
	usbd_status error;
	uint16_t c;
	int i, len;

	error = usbd_get_string_desc(sc->sc_udev, UEAGLE_ESISTR, 0, &us, &len);
	if (error != 0)
		return error;

	if (us.bLength < (6 + 1) * 2)
		return 1;

	for (i = 0; i < 6 * 2; i++) {
		if ((c = UGETW(us.bString[i])) & 0xff00)
			return 1;	/* not 8-bit clean */

		if (i & 1)
			addr[i / 2] <<= 4;
		else
			addr[i / 2] = 0;

		if (c >= '0' && c <= '9')
			addr[i / 2] |= c - '0';
		else if (c >= 'a' && c <= 'f')
			addr[i / 2] |= c - 'a' + 10;
		else if (c >= 'A' && c <= 'F')
			addr[i / 2] |= c - 'A' + 10;
		else
			return 1;
	}

	return 0;
}

void
ueagle_loadpage(void *xsc)
{
	struct ueagle_softc *sc = xsc;
	struct usbd_xfer *xfer;
	struct ueagle_block_info bi;
	uint16_t pageno = sc->pageno;
	uint16_t ovl = sc->ovl;
	uint8_t pagecount, blockcount;
	uint16_t blockaddr, blocksize;
	uint32_t pageoffset;
	uint8_t *p;
	int i;

	if (usbd_is_dying(sc->sc_udev))
		return;

	p = sc->dsp;
	pagecount = *p++;

	if (pageno >= pagecount) {
		printf("%s: invalid page number %u requested\n",
		    sc->sc_dev.dv_xname, pageno);
		return;
	}

	p += 4 * pageno;
	pageoffset = UGETDW(p);
	if (pageoffset == 0)
		return;

	p = sc->dsp + pageoffset;
	blockcount = *p++;

	DPRINTF(("%s: sending %u blocks for fw page %u\n",
	    sc->sc_dev.dv_xname, blockcount, pageno));

	if ((xfer = usbd_alloc_xfer(sc->sc_udev)) == NULL) {
		printf("%s: could not allocate xfer\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	USETW(bi.wHdr, UEAGLE_BLOCK_INFO_HDR);
	USETW(bi.wOvl, ovl);
	USETW(bi.wOvlOffset, ovl | 0x8000);

	for (i = 0; i < blockcount; i++) {
		blockaddr = UGETW(p); p += 2;
		blocksize = UGETW(p); p += 2;

		USETW(bi.wSize, blocksize);
		USETW(bi.wAddress, blockaddr);
		USETW(bi.wLast, (i == blockcount - 1) ? 1 : 0);

		/* send block info through the IDMA pipe */
		usbd_setup_xfer(xfer, sc->pipeh_idma, sc, &bi, sizeof bi,
		    USBD_SYNCHRONOUS, UEAGLE_IDMA_TIMEOUT, NULL);
		if (usbd_transfer(xfer) != 0) {
			printf("%s: could not transfer block info\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		/* send block data through the IDMA pipe */
		usbd_setup_xfer(xfer, sc->pipeh_idma, sc, p, blocksize,
		    USBD_SYNCHRONOUS, UEAGLE_IDMA_TIMEOUT, NULL);
		if (usbd_transfer(xfer) != 0) {
			printf("%s: could not transfer block data\n",
			    sc->sc_dev.dv_xname);
			break;
		}

		p += blocksize;
	}

	usbd_free_xfer(xfer);
}

void
ueagle_request(struct ueagle_softc *sc, uint16_t val, uint16_t index,
    void *data, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UEAGLE_REQUEST;
	USETW(req.wValue, val);
	USETW(req.wIndex, index);
	USETW(req.wLength, len);

	error = usbd_do_request_async(sc->sc_udev, &req, data);
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
		printf("%s: could not send request\n", sc->sc_dev.dv_xname);
}

#ifdef USB_DEBUG
void
ueagle_dump_cmv(struct ueagle_softc *sc, struct ueagle_cmv *cmv)
{
	printf("    Preamble:    0x%04x\n", UGETW(cmv->wPreamble));
	printf("    Destination: %s (0x%02x)\n",
	    (cmv->bDst == UEAGLE_HOST) ? "Host" : "Modem", cmv->bDst);
	printf("    Type:        %u\n", cmv->bFunction >> 4);
	printf("    Subtype:     %u\n", cmv->bFunction & 0xf);
	printf("    Index:       %u\n", UGETW(cmv->wIndex));
	printf("    Address:     %c%c%c%c.%u\n",
	    cmv->dwSymbolicAddress[1], cmv->dwSymbolicAddress[0],
	    cmv->dwSymbolicAddress[3], cmv->dwSymbolicAddress[2],
	    UGETW(cmv->wOffsetAddress));
	printf("    Data:        0x%08x\n", UGETDATA(cmv->dwData));
}
#endif

int
ueagle_cr(struct ueagle_softc *sc, uint32_t address, uint16_t offset,
    uint32_t *data)
{
	struct ueagle_cmv cmv;
	usbd_status error;
	int s;

	USETW(cmv.wPreamble, UEAGLE_CMV_PREAMBLE);
	cmv.bDst = UEAGLE_MODEM;
	cmv.bFunction = UEAGLE_CR;
	USETW(cmv.wIndex, sc->index);
	USETW(cmv.wOffsetAddress, offset);
	USETDW(cmv.dwSymbolicAddress, address);
	USETDATA(cmv.dwData, 0);

#ifdef USB_DEBUG
	if (ueagledebug >= 15) {
		printf("%s: reading CMV\n", sc->sc_dev.dv_xname);
		ueagle_dump_cmv(sc, &cmv);
	}
#endif

	s = splusb();

	ueagle_request(sc, UEAGLE_SETBLOCK, UEAGLE_MPTXSTART, &cmv, sizeof cmv);

	/* wait at most 2 seconds for an answer */
	error = tsleep(UEAGLE_COND_CMV(sc), PZERO, "cmv", 2 * hz);
	if (error != 0) {
		printf("%s: timeout waiting for CMV ack\n",
		    sc->sc_dev.dv_xname);
		splx(s);
		return error;
	}

	*data = sc->data;
	splx(s);

	return 0;
}

int
ueagle_cw(struct ueagle_softc *sc, uint32_t address, uint16_t offset,
    uint32_t data)
{
	struct ueagle_cmv cmv;
	usbd_status error;
	int s;

	USETW(cmv.wPreamble, UEAGLE_CMV_PREAMBLE);
	cmv.bDst = UEAGLE_MODEM;
	cmv.bFunction = UEAGLE_CW;
	USETW(cmv.wIndex, sc->index);
	USETW(cmv.wOffsetAddress, offset);
	USETDW(cmv.dwSymbolicAddress, address);
	USETDATA(cmv.dwData, data);

#ifdef USB_DEBUG
	if (ueagledebug >= 15) {
		printf("%s: writing CMV\n", sc->sc_dev.dv_xname);
		ueagle_dump_cmv(sc, &cmv);
	}
#endif

	s = splusb();

	ueagle_request(sc, UEAGLE_SETBLOCK, UEAGLE_MPTXSTART, &cmv, sizeof cmv);

	/* wait at most 2 seconds for an answer */
	error = tsleep(UEAGLE_COND_CMV(sc), PZERO, "cmv", 2 * hz);
	if (error != 0) {
		printf("%s: timeout waiting for CMV ack\n",
		    sc->sc_dev.dv_xname);
		splx(s);
		return error;
	}

	splx(s);

	return 0;
}

int
ueagle_stat(struct ueagle_softc *sc)
{
	struct ifnet *ifp = &sc->sc_if;
	uint32_t data;
	usbd_status error;
#define CR(sc, address, offset, data) do {				\
	if ((error = ueagle_cr(sc, address, offset, data)) != 0)	\
		return error;						\
} while (0)

	CR(sc, UEAGLE_CMV_STAT, 0, &sc->stats.phy.status);
	switch ((sc->stats.phy.status >> 8) & 0xf) {
	case 0: /* idle */
		DPRINTFN(3, ("%s: waiting for synchronization\n",
		    sc->sc_dev.dv_xname));
		return ueagle_cw(sc, UEAGLE_CMV_CNTL, 0, 2);

	case 1: /* initialization */
		DPRINTFN(3, ("%s: initializing\n", sc->sc_dev.dv_xname));
		return ueagle_cw(sc, UEAGLE_CMV_CNTL, 0, 2);

	case 2: /* operational */
		DPRINTFN(4, ("%s: operational\n", sc->sc_dev.dv_xname));
		break;

	default: /* fail ... */
		DPRINTFN(3, ("%s: synchronization failed\n",
		    sc->sc_dev.dv_xname));
		ueagle_init(ifp);
		return 1;
	}

	CR(sc, UEAGLE_CMV_DIAG, 1, &sc->stats.phy.flags);
	if (sc->stats.phy.flags & 0x10) {
		DPRINTF(("%s: delineation LOSS\n", sc->sc_dev.dv_xname));
		sc->stats.phy.status = 0;
		ueagle_init(ifp);
		return 1;
	}

	CR(sc, UEAGLE_CMV_RATE, 0, &data);
	sc->stats.phy.dsrate = ((data >> 16) & 0x1ff) * 32;
	sc->stats.phy.usrate = (data & 0xff) * 32;

	CR(sc, UEAGLE_CMV_DIAG, 23, &data);
	sc->stats.phy.attenuation = (data & 0xff) / 2;

	CR(sc, UEAGLE_CMV_DIAG,  3, &sc->stats.atm.cells_crc_errors);
	CR(sc, UEAGLE_CMV_DIAG, 22, &sc->stats.phy.dserror);
	CR(sc, UEAGLE_CMV_DIAG, 25, &sc->stats.phy.dsmargin);
	CR(sc, UEAGLE_CMV_DIAG, 46, &sc->stats.phy.userror);
	CR(sc, UEAGLE_CMV_DIAG, 49, &sc->stats.phy.usmargin);
	CR(sc, UEAGLE_CMV_DIAG, 51, &sc->stats.phy.rxflow);
	CR(sc, UEAGLE_CMV_DIAG, 52, &sc->stats.phy.txflow);
	CR(sc, UEAGLE_CMV_DIAG, 54, &sc->stats.phy.dsunc);
	CR(sc, UEAGLE_CMV_DIAG, 58, &sc->stats.phy.usunc);
	CR(sc, UEAGLE_CMV_INFO,  8, &sc->stats.phy.vidco);
	CR(sc, UEAGLE_CMV_INFO, 14, &sc->stats.phy.vidcpe);

	if (sc->pipeh_tx != NULL)
		return 0;

	return ueagle_open_pipes(sc);
#undef CR
}

void
ueagle_stat_thread(void *arg)
{
	struct ueagle_softc *sc = arg;

	for (;;) {
		if (ueagle_stat(sc) != 0)
			break;

		usbd_delay_ms(sc->sc_udev, 5000);
		if (usbd_is_dying(sc->sc_udev))
			break;
	}

	wakeup(sc->stat_thread);

	kthread_exit(0);
}

int
ueagle_boot(struct ueagle_softc *sc)
{
	uint16_t zero = 0; /* ;-) */
	usbd_status error;
#define CW(sc, address, offset, data) do {				\
	if ((error = ueagle_cw(sc, address, offset, data)) != 0)	\
		return error;						\
} while (0)

	ueagle_request(sc, UEAGLE_SETMODE, UEAGLE_BOOTIDMA, NULL, 0);
	ueagle_request(sc, UEAGLE_SETMODE, UEAGLE_STARTRESET, NULL, 0);

	usbd_delay_ms(sc->sc_udev, 200);

	ueagle_request(sc, UEAGLE_SETMODE, UEAGLE_ENDRESET, NULL, 0);
	ueagle_request(sc, UEAGLE_SET2183DATA, UEAGLE_MPTXMAILBOX, &zero, 2);
	ueagle_request(sc, UEAGLE_SET2183DATA, UEAGLE_MPRXMAILBOX, &zero, 2);
	ueagle_request(sc, UEAGLE_SET2183DATA, UEAGLE_SWAPMAILBOX, &zero, 2);

	usbd_delay_ms(sc->sc_udev, 1000);

	sc->pageno = 0;
	sc->ovl = 0;
	ueagle_loadpage(sc);

	/* wait until modem reaches operational state */
	error = tsleep(UEAGLE_COND_READY(sc), PZERO | PCATCH, "boot", 10 * hz);
	if (error != 0) {
		printf("%s: timeout waiting for operational state\n",
		    sc->sc_dev.dv_xname);
		return error;
	}

	CW(sc, UEAGLE_CMV_CNTL, 0, 1);

	/* send configuration options */
	CW(sc, UEAGLE_CMV_OPTN, 0, UEAGLE_OPTN0);
	CW(sc, UEAGLE_CMV_OPTN, 2, UEAGLE_OPTN2);
	CW(sc, UEAGLE_CMV_OPTN, 7, UEAGLE_OPTN7);

	/* continue with synchronization */
	CW(sc, UEAGLE_CMV_CNTL, 0, 2);

	return kthread_create(ueagle_stat_thread, sc, &sc->stat_thread,
	    sc->sc_dev.dv_xname);
#undef CW
}

void
ueagle_swap_intr(struct ueagle_softc *sc, struct ueagle_swap *swap)
{
#define rotbr(v, n)	((v) >> (n) | (v) << (8 - (n)))
	sc->pageno = swap->bPageNo;
	sc->ovl = rotbr(swap->bOvl, 4);

	usb_add_task(sc->sc_udev, &sc->sc_swap_task);
#undef rotbr
}

/*
 * This function handles spontaneous CMVs and CMV acknowledgements sent by the
 * modem on the interrupt pipe.
 */
void
ueagle_cmv_intr(struct ueagle_softc *sc, struct ueagle_cmv *cmv)
{
#ifdef USB_DEBUG
	if (ueagledebug >= 15) {
		printf("%s: receiving CMV\n", sc->sc_dev.dv_xname);
		ueagle_dump_cmv(sc, cmv);
	}
#endif

	if (UGETW(cmv->wPreamble) != UEAGLE_CMV_PREAMBLE) {
		printf("%s: received CMV with invalid preamble\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	if (cmv->bDst != UEAGLE_HOST) {
		printf("%s: received CMV with bad direction\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* synchronize our current CMV index with the modem */
	sc->index = UGETW(cmv->wIndex) + 1;

	switch (cmv->bFunction) {
	case UEAGLE_MODEMREADY:
		wakeup(UEAGLE_COND_READY(sc));
		break;

	case UEAGLE_CR_ACK:
		sc->data = UGETDATA(cmv->dwData);
		/* FALLTHROUGH */
	case UEAGLE_CW_ACK:
		wakeup(UEAGLE_COND_CMV(sc));
		break;
	}
}

void
ueagle_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ueagle_softc *sc = priv;
	struct ueagle_intr *intr;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: abnormal interrupt status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status)));

		usbd_clear_endpoint_stall_async(sc->pipeh_intr);
		return;
	}

	intr = (struct ueagle_intr *)sc->ibuf;
	switch (UGETW(intr->wInterrupt)) {
	case UEAGLE_INTR_SWAP:
		ueagle_swap_intr(sc, (struct ueagle_swap *)(intr + 1));
		break;

	case UEAGLE_INTR_CMV:
		ueagle_cmv_intr(sc, (struct ueagle_cmv *)(intr + 1));
		break;

	default:
		printf("%s: caught unknown interrupt\n",
		    sc->sc_dev.dv_xname);
	}
}

static const uint32_t ueagle_crc32_table[256] = {
	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc,
	0x17c56b6b, 0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f,
	0x2f8ad6d6, 0x2b4bcb61, 0x350c9b64, 0x31cd86d3, 0x3c8ea00a,
	0x384fbdbd, 0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
	0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75, 0x6a1936c8,
	0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e,
	0x95609039, 0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
	0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81, 0xad2f2d84,
	0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d, 0xd4326d90, 0xd0f37027,
	0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb, 0xceb42022,
	0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077,
	0x30476dc0, 0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c,
	0x2e003dc5, 0x2ac12072, 0x128e9dcf, 0x164f8078, 0x1b0ca6a1,
	0x1fcdbb16, 0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
	0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde, 0x6b93dddb,
	0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d,
	0x40d816ba, 0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
	0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692, 0x8aad2b2f,
	0x8e6c3698, 0x832f1041, 0x87ee0df6, 0x99a95df3, 0x9d684044,
	0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050, 0xe9362689,
	0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683,
	0xd1799b34, 0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59,
	0x608edb80, 0x644fc637, 0x7a089632, 0x7ec98b85, 0x738aad5c,
	0x774bb0eb, 0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
	0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53, 0x251d3b9e,
	0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48,
	0x0e56f0ff, 0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
	0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2,
	0xe6ea3d65, 0xeba91bbc, 0xef68060b, 0xd727bbb6, 0xd3e6a601,
	0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd, 0xcda1f604,
	0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6,
	0x9ff77d71, 0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad,
	0x81b02d74, 0x857130c3, 0x5d8a9099, 0x594b8d2e, 0x5408abf7,
	0x50c9b640, 0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
	0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8, 0x68860bfd,
	0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b,
	0x0fdc1bec, 0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
	0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654, 0xc5a92679,
	0xc1683bce, 0xcc2b1d17, 0xc8ea00a0, 0xd6ad50a5, 0xd26c4d12,
	0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676, 0xea23f0af,
	0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5,
	0x9e7d9662, 0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06,
	0xa6322bdf, 0xa2f33668, 0xbcb4666d, 0xb8757bda, 0xb5365d03,
	0xb1f740b4
};

uint32_t
ueagle_crc_update(uint32_t crc, uint8_t *buf, int len)
{
	for (; len != 0; len--, buf++)
		crc = ueagle_crc32_table[(crc >> 24) ^ *buf] ^ (crc << 8);

	return crc;
}

/*
 * Reassembly part of the software ATM AAL5 SAR.
 */
void
ueagle_push_cell(struct ueagle_softc *sc, uint8_t *cell)
{
	struct ueagle_vcc *vcc = &sc->vcc;
	struct ifnet *ifp;
	struct mbuf *m;
	uint32_t crc;
	uint16_t pdulen, totlen;
	int s;

	sc->stats.atm.cells_received++;

	if (!(vcc->flags & UEAGLE_VCC_ACTIVE) ||
	    ATM_CH_GETVPI(cell) != vcc->vpi ||
	    ATM_CH_GETVCI(cell) != vcc->vci) {
		sc->stats.atm.vcc_no_conn++;
		return;
	}

	if (vcc->flags & UEAGLE_VCC_DROP) {
		if (ATM_CH_ISLASTCELL(cell)) {
			vcc->flags &= ~UEAGLE_VCC_DROP;
			sc->stats.atm.cspdus_dropped++;
		}

		sc->stats.atm.cells_dropped++;
		return;
	}

	if (vcc->m == NULL) {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			vcc->flags |= UEAGLE_VCC_DROP;
			return;
		}

		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			vcc->flags |= UEAGLE_VCC_DROP;
			m_freem(m);
			return;
		}

		vcc->m = m;
		vcc->dst = mtod(m, uint8_t *);
		vcc->limit = vcc->dst + MCLBYTES - ATM_CELL_PAYLOAD_SIZE;
	}

	if (vcc->dst > vcc->limit) {
		vcc->flags |= UEAGLE_VCC_DROP;
		sc->stats.atm.cells_dropped++;
		goto fail;
	}

	memcpy(vcc->dst, cell + ATM_CELL_HEADER_SIZE, ATM_CELL_PAYLOAD_SIZE);
	vcc->dst += ATM_CELL_PAYLOAD_SIZE;

	if (!ATM_CH_ISLASTCELL(cell))
		return;

	/*
	 * Handle the last cell of the AAL5 CPCS-PDU.
	 */
	m = vcc->m;

	totlen = vcc->dst - mtod(m, uint8_t *);
	pdulen = AAL5_TR_GETPDULEN(cell);

	if (totlen < pdulen + AAL5_TRAILER_SIZE) {
		sc->stats.atm.cspdus_dropped++;
		goto fail;
	}

	if (totlen >= pdulen + ATM_CELL_PAYLOAD_SIZE + AAL5_TRAILER_SIZE) {
		sc->stats.atm.cspdus_dropped++;
		goto fail;
	}

	crc = ueagle_crc_update(CRC_INITIAL, mtod(m, uint8_t *), totlen);
	if (crc != CRC_MAGIC) {
		sc->stats.atm.cspdus_crc_errors++;
		goto fail;
	}

	/* finalize mbuf */
	ifp = &sc->sc_if;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = m->m_len = pdulen;

	sc->stats.atm.cspdus_received++;

	s = splnet();

#if NBPFILTER > 0
	if (ifp->if_bpf != NULL)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	/* send the AAL5 CPCS-PDU to the ATM layer */
	ifp->if_ipackets++;
	atm_input(ifp, &vcc->aph, m, vcc->rxhand);
	vcc->m = NULL;

	splx(s);

	return;

fail:	m_freem(vcc->m);
	vcc->m = NULL;
}

void
ueagle_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ueagle_isoreq *req = priv;
	struct ueagle_softc *sc = req->sc;
	uint32_t count;
	uint8_t *p;
	int i;

	if (status == USBD_CANCELLED)
		return;

	for (i = 0; i < UEAGLE_NISOFRMS; i++) {
		count = req->frlengths[i];
		p = req->offsets[i];

		while (count >= ATM_CELL_SIZE) {
			ueagle_push_cell(sc, p);
			p += ATM_CELL_SIZE;
			count -= ATM_CELL_SIZE;
		}
#ifdef DIAGNOSTIC
		if (count > 0) {
			printf("%s: truncated cell (%u bytes)\n",
			    sc->sc_dev.dv_xname, count);
		}
#endif
		req->frlengths[i] = sc->isize;
	}

	usbd_setup_isoc_xfer(req->xfer, sc->pipeh_rx, req, req->frlengths,
	    UEAGLE_NISOFRMS, USBD_NO_COPY, ueagle_rxeof);
	usbd_transfer(xfer);
}

void
ueagle_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ueagle_txreq *req = priv;
	struct ueagle_softc *sc = req->sc;
	struct ifnet *ifp = &sc->sc_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->pipeh_tx);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ifp->if_opackets++;
	ifp->if_flags &= ~IFF_OACTIVE;
	ueagle_start(ifp);

	splx(s);
}

/*
 * Segmentation part of the software ATM AAL5 SAR.
 */
int
ueagle_encap(struct ueagle_softc *sc, struct mbuf *m0)
{
	struct ueagle_vcc *vcc = &sc->vcc;
	struct ueagle_txreq *req;
	struct mbuf *m;
	uint8_t *src, *dst;
	uint32_t crc;
	int n, cellleft, mleft;
	usbd_status error;

	req = &sc->txreqs[0];

	m_adj(m0, sizeof (struct atm_pseudohdr));

	dst = req->buf;
	cellleft = 0;
	crc = CRC_INITIAL;

	for (m = m0; m != NULL; m = m->m_next) {
		src = mtod(m, uint8_t *);
		mleft = m->m_len;

		crc = ueagle_crc_update(crc, src, mleft);

		if (cellleft != 0) {
			n = min(mleft, cellleft);

			memcpy(dst, src, n);
			dst += n;
			src += n;
			cellleft -= n;
			mleft -= n;
		}

		while (mleft >= ATM_CELL_PAYLOAD_SIZE) {
			memcpy(dst, vcc->ch, ATM_CELL_HEADER_SIZE);
			dst += ATM_CELL_HEADER_SIZE;
			memcpy(dst, src, ATM_CELL_PAYLOAD_SIZE);
			dst += ATM_CELL_PAYLOAD_SIZE;
			src += ATM_CELL_PAYLOAD_SIZE;
			mleft -= ATM_CELL_PAYLOAD_SIZE;
			sc->stats.atm.cells_transmitted++;
		}

		if (mleft != 0) {
			memcpy(dst, vcc->ch, ATM_CELL_HEADER_SIZE);
			dst += ATM_CELL_HEADER_SIZE;
			memcpy(dst, src, mleft);
			dst += mleft;
			cellleft = ATM_CELL_PAYLOAD_SIZE - mleft;
			sc->stats.atm.cells_transmitted++;
		}
	}

	/*
	 * If there is not enough space to put the AAL5 trailer into this cell,
	 * pad the content of this cell with zeros and create a new cell which
	 * will contain no data except the AAL5 trailer itself.
	 */
	if (cellleft < AAL5_TRAILER_SIZE) {
		memset(dst, 0, cellleft);
		crc = ueagle_crc_update(crc, dst, cellleft);
		dst += cellleft;

		memcpy(dst, vcc->ch, ATM_CELL_HEADER_SIZE);
		dst += ATM_CELL_HEADER_SIZE;
		cellleft = ATM_CELL_PAYLOAD_SIZE;
		sc->stats.atm.cells_transmitted++;
	}

	/*
	 * Fill the AAL5 CPCS-PDU trailer.
	 */
	memset(dst, 0, cellleft - AAL5_TRAILER_SIZE);

	/* src now points to the beginning of the last cell */
	src = dst + cellleft - ATM_CELL_SIZE;
	ATM_CH_SETPTFLAGS(src, 1);

	AAL5_TR_SETCPSUU(src, 0);
	AAL5_TR_SETCPI(src, 0);
	AAL5_TR_SETPDULEN(src, m0->m_pkthdr.len);

	crc = ~ueagle_crc_update(crc, dst, cellleft - 4);
	AAL5_TR_SETCRC(src, crc);

	usbd_setup_xfer(req->xfer, sc->pipeh_tx, req, req->buf,
	    dst + cellleft - req->buf, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    UEAGLE_TX_TIMEOUT, ueagle_txeof);

	error = usbd_transfer(req->xfer);
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
		return error;

	sc->stats.atm.cspdus_transmitted++;

	return 0;
}

void
ueagle_start(struct ifnet *ifp)
{
	struct ueagle_softc *sc = ifp->if_softc;
	struct mbuf *m0;

	/* nothing goes out until modem is synchronized and VCC is opened */
	if (!(sc->vcc.flags & UEAGLE_VCC_ACTIVE))
		return;

	if (sc->pipeh_tx == NULL)
		return;

	IFQ_POLL(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;
	IFQ_DEQUEUE(&ifp->if_snd, m0);

	if (ueagle_encap(sc, m0) != 0) {
		m_freem(m0);
		return;
	}

#if NBPFILTER > 0
	if (ifp->if_bpf != NULL)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	m_freem(m0);

	ifp->if_flags |= IFF_OACTIVE;
}

int
ueagle_open_vcc(struct ueagle_softc *sc, struct atm_pseudoioctl *api)
{
	struct ueagle_vcc *vcc = &sc->vcc;

	DPRINTF(("%s: opening ATM VCC\n", sc->sc_dev.dv_xname));

	vcc->vpi = ATM_PH_VPI(&api->aph);
	vcc->vci = ATM_PH_VCI(&api->aph);
	vcc->rxhand = api->rxhand;
	vcc->m = NULL;
	vcc->aph = api->aph;
	vcc->flags = UEAGLE_VCC_ACTIVE;

	/* pre-calculate cell headers (HEC field is set by hardware) */
	ATM_CH_FILL(vcc->ch, 0, vcc->vpi, vcc->vci, 0, 0, 0);

	return 0;
}

int
ueagle_close_vcc(struct ueagle_softc *sc, struct atm_pseudoioctl *api)
{
	DPRINTF(("%s: closing ATM VCC\n", sc->sc_dev.dv_xname));

	sc->vcc.flags &= ~UEAGLE_VCC_ACTIVE;

	return 0;
}

int
ueagle_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ueagle_softc *sc = ifp->if_softc;
	struct atm_pseudoioctl *api;
	struct ifaddr *ifa;
	struct ifreq *ifr;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifa = (struct ifaddr *)data;
		ifp->if_flags |= IFF_UP;

		ueagle_init(ifp);
#ifdef INET
		ifa->ifa_rtrequest = atm_rtrequest;
#endif
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				ueagle_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				ueagle_stop(ifp, 1);
		}
		break;

	case SIOCSIFMTU:
		ifr = (struct ifreq *)data;

		if (ifr->ifr_mtu > UEAGLE_IFMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCATMENA:
		api = (struct atm_pseudoioctl *)data;
		error = ueagle_open_vcc(sc, api);
		break;

	case SIOCATMDIS:
		api = (struct atm_pseudoioctl *)data;
		error = ueagle_close_vcc(sc, api);
		break;

	default:
		error = EINVAL;
	}

	splx(s);

	return error;
}

int
ueagle_open_pipes(struct ueagle_softc *sc)
{
	usb_endpoint_descriptor_t *edesc;
	struct usbd_interface *iface;
	struct ueagle_txreq *txreq;
	struct ueagle_isoreq *isoreq;
	usbd_status error;
	uint8_t *buf;
	int i, j;

	error = usbd_device2interface_handle(sc->sc_udev, UEAGLE_US_IFACE_NO,
	    &iface);
	if (error != 0) {
		printf("%s: could not get tx interface handle\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_open_pipe(iface, UEAGLE_TX_PIPE, USBD_EXCLUSIVE_USE,
	    &sc->pipeh_tx);
	if (error != 0) {
		printf("%s: could not open tx pipe\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < UEAGLE_TX_LIST_CNT; i++) {
		txreq = &sc->txreqs[i];

		txreq->sc = sc;

		txreq->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (txreq->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		txreq->buf = usbd_alloc_buffer(txreq->xfer, UEAGLE_TXBUFLEN);
		if (txreq->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}

	error = usbd_device2interface_handle(sc->sc_udev, UEAGLE_DS_IFACE_NO,
	    &iface);
	if (error != 0) {
		printf("%s: could not get rx interface handle\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* XXX: alternative interface number sould depend on downrate */
	error = usbd_set_interface(iface, 8);
	if (error != 0) {
		printf("%s: could not set rx alternative interface\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	edesc = usbd_get_endpoint_descriptor(iface, UEAGLE_RX_PIPE);
	if (edesc == NULL) {
		printf("%s: could not get rx endpoint descriptor\n",
		    sc->sc_dev.dv_xname);
		error = EIO;
		goto fail;
	}

	sc->isize = UGETW(edesc->wMaxPacketSize);

	error = usbd_open_pipe(iface, UEAGLE_RX_PIPE, USBD_EXCLUSIVE_USE,
	    &sc->pipeh_rx);
	if (error != 0) {
		printf("%s: could not open rx pipe\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < UEAGLE_NISOREQS; i++) {
		isoreq = &sc->isoreqs[i];

		isoreq->sc = sc;

		isoreq->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (isoreq->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		buf = usbd_alloc_buffer(isoreq->xfer,
		    sc->isize * UEAGLE_NISOFRMS);
		if (buf == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		for (j = 0; j < UEAGLE_NISOFRMS; j++) {
			isoreq->frlengths[j] = sc->isize;
			isoreq->offsets[j] = buf + j * sc->isize;
		}

		usbd_setup_isoc_xfer(isoreq->xfer, sc->pipeh_rx, isoreq,
		    isoreq->frlengths, UEAGLE_NISOFRMS, USBD_NO_COPY,
		    ueagle_rxeof);
		usbd_transfer(isoreq->xfer);
	}

	ueagle_request(sc, UEAGLE_SETMODE, UEAGLE_LOOPBACKOFF, NULL, 0);

	return 0;

fail:	ueagle_close_pipes(sc);
	return error;
}

void
ueagle_close_pipes(struct ueagle_softc *sc)
{
	int i;

	ueagle_request(sc, UEAGLE_SETMODE, UEAGLE_LOOPBACKON, NULL, 0);

	/* free Tx resources */
	if (sc->pipeh_tx != NULL) {
		usbd_abort_pipe(sc->pipeh_tx);
		usbd_close_pipe(sc->pipeh_tx);
		sc->pipeh_tx = NULL;
	}

	for (i = 0; i < UEAGLE_TX_LIST_CNT; i++) {
		if (sc->txreqs[i].xfer != NULL) {
			usbd_free_xfer(sc->txreqs[i].xfer);
			sc->txreqs[i].xfer = NULL;
		}
	}

	/* free Rx resources */
	if (sc->pipeh_rx != NULL) {
		usbd_abort_pipe(sc->pipeh_rx);
		usbd_close_pipe(sc->pipeh_rx);
		sc->pipeh_rx = NULL;
	}

	for (i = 0; i < UEAGLE_NISOREQS; i++) {
		if (sc->isoreqs[i].xfer != NULL) {
			usbd_free_xfer(sc->isoreqs[i].xfer);
			sc->isoreqs[i].xfer = NULL;
		}
	}
}

int
ueagle_init(struct ifnet *ifp)
{
	struct ueagle_softc *sc = ifp->if_softc;
	struct usbd_interface *iface;
	usbd_status error;
	size_t len;

	ueagle_stop(ifp, 0);

	error = usbd_device2interface_handle(sc->sc_udev, UEAGLE_US_IFACE_NO,
	    &iface);
	if (error != 0) {
		printf("%s: could not get idma interface handle\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_open_pipe(iface, UEAGLE_IDMA_PIPE, USBD_EXCLUSIVE_USE,
	    &sc->pipeh_idma);
	if (error != 0) {
		printf("%s: could not open idma pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_device2interface_handle(sc->sc_udev, UEAGLE_INTR_IFACE_NO,
	    &iface);
	if (error != 0) {
		printf("%s: could not get interrupt interface handle\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = loadfirmware("ueagle-dsp", &sc->dsp, &len);
	if (error != 0) {
		printf("%s: could not load firmware\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_open_pipe_intr(iface, UEAGLE_INTR_PIPE, USBD_SHORT_XFER_OK,
	    &sc->pipeh_intr, sc, sc->ibuf, UEAGLE_INTR_MAXSIZE, ueagle_intr,
	    UEAGLE_INTR_INTERVAL);
	if (error != 0) {
		printf("%s: could not open interrupt pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = ueagle_boot(sc);
	if (error != 0) {
		printf("%s: could not boot modem\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Opening of tx and rx pipes if deferred after synchronization is
	 * established.
	 */

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	return 0;

fail:	ueagle_stop(ifp, 1);
	return error;
}

void
ueagle_stop(struct ifnet *ifp, int disable)
{
	struct ueagle_softc *sc = ifp->if_softc;

	/* stop any pending task */
	usb_rem_task(sc->sc_udev, &sc->sc_swap_task);

	/* free Tx and Rx resources */
	ueagle_close_pipes(sc);

	/* free firmware */
	if (sc->dsp != NULL) {
		free(sc->dsp, M_DEVBUF);
		sc->dsp = NULL;
	}

	/* free interrupt resources */
	if (sc->pipeh_intr != NULL) {
		usbd_abort_pipe(sc->pipeh_intr);
		usbd_close_pipe(sc->pipeh_intr);
		sc->pipeh_intr = NULL;
	}

	/* free IDMA resources */
	if (sc->pipeh_idma != NULL) {
		usbd_abort_pipe(sc->pipeh_idma);
		usbd_close_pipe(sc->pipeh_idma);
		sc->pipeh_idma = NULL;
	}

	/* reset statistics */
	memset(&sc->stats, 0, sizeof (struct ueagle_stats));

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
}

int
ueagle_activate(struct device *self, int act)
{
	struct ueagle_softc *sc = (struct ueagle_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return 0;
}
@


1.38
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.37 2013/04/12 12:58:39 mpi Exp $	*/
@


1.37
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.36 2011/11/27 09:20:57 claudio Exp $	*/
d107 1
a107 2
void		ueagle_intr(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d110 2
a111 4
void		ueagle_rxeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
void		ueagle_txeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d304 1
a304 1
	usbd_xfer_handle xfer;
d688 1
a688 1
ueagle_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d899 1
a899 2
ueagle_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
d934 1
a934 2
ueagle_txeof(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
d1194 1
a1194 1
	usbd_interface_handle iface;
d1352 1
a1352 1
	usbd_interface_handle iface;
@


1.36
log
@This needs sys/kthread.h to build
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.35 2011/09/18 23:24:12 krw Exp $	*/
d359 3
a361 3
		usbd_setup_xfer(xfer, sc->pipeh_idma, sc, &bi, sizeof bi, 0,
		    UEAGLE_IDMA_TIMEOUT, NULL);
		if (usbd_sync_transfer(xfer) != 0) {
d368 3
a370 3
		usbd_setup_xfer(xfer, sc->pipeh_idma, sc, p, blocksize, 0,
		    UEAGLE_IDMA_TIMEOUT, NULL);
		if (usbd_sync_transfer(xfer) != 0) {
@


1.35
log
@usbdivar.h needs struct timeout. But don't get it indirectly via
sys/kthread.h,  use sys/timeout.h explicitly. Noted by Michael
Knudsen.

ok deraadt@@ kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.34 2011/07/03 15:47:17 matthew Exp $	*/
d31 1
@


1.34
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.33 2011/03/22 16:31:19 deraadt Exp $	*/
d34 1
a34 1
#include <sys/kthread.h>
@


1.33
log
@silently clear the endpoint when the device has failed; ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.32 2011/01/25 20:03:36 jakemsr Exp $	*/
a1463 3
	case DVACT_ACTIVATE:
		break;

@


1.32
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.31 2010/12/06 05:46:17 jakemsr Exp $	*/
d699 2
a700 5
		printf("%s: abnormal interrupt status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->pipeh_intr);
d702 1
@


1.31
log
@a couple unchecked if_detach() in detach routines that were missed
in previous sweep (avoid NULL deref if the device didn't fully attach)
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.30 2010/12/06 04:41:40 jakemsr Exp $	*/
a231 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
a257 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.30
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.29 2010/10/23 15:42:09 jakemsr Exp $	*/
d259 2
a260 1
	if_detach(ifp);
@


1.29
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.28 2010/09/24 08:33:59 yuo Exp $	*/
d321 3
d582 2
d1475 1
a1475 1
		sc->gone = 1;
@


1.28
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.27 2010/08/27 17:08:01 jsg Exp $	*/
d213 2
a214 1
	usb_init_task(&sc->sc_swap_task, ueagle_loadpage, sc);
@


1.27
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.26 2010/06/05 13:06:57 damien Exp $	*/
a244 1
	sc->gone = 1;
@


1.26
log
@'operational' takes a single 'n'
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.25 2010/04/21 21:07:47 claudio Exp $	*/
a216 1
	ifp->if_init = ueagle_init;
@


1.25
log
@sys/sysctl.h is not needed here. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.24 2009/10/13 19:33:17 pirofti Exp $	*/
d613 1
a613 1
	/* wait until modem reaches operationnal state */
d616 1
a616 1
		printf("%s: timeout waiting for operationnal state\n",
@


1.24
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.23 2007/10/11 18:33:15 deraadt Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.23
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.22 2007/09/07 19:05:05 damien Exp $	*/
d130 1
a130 1
int ueagle_activate(struct device *, enum devact); 
d1463 1
a1463 1
ueagle_activate(struct device *self, enum devact act)
@


1.22
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.21 2007/06/14 10:11:15 mbalmer Exp $	*/
a177 1
	char *devinfop;
a180 1
	printf("\n");
a196 4

	devinfop = usbd_devinfo_alloc(sc->sc_udev, 0);
	printf("%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.21
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.20 2007/06/12 16:26:36 mbalmer Exp $	*/
a33 1
#include <sys/malloc.h>
@


1.20
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.19 2007/06/10 14:49:01 mbalmer Exp $	*/
d128 16
a143 1
USB_DECLARE_DRIVER(ueagle);
@


1.19
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.18 2007/06/10 10:53:48 mbalmer Exp $	*/
d1455 1
a1455 1
ueagle_activate(device_ptr_t self, enum devact act)
@


1.18
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.17 2007/06/09 12:22:53 mbalmer Exp $	*/
d153 1
a153 1
		    USBDEVNAME(sc->sc_dev));
d187 1
a187 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d192 1
a192 1
		    USBDEVNAME(sc->sc_dev));
d198 1
a198 1
		    USBDEVNAME(sc->sc_dev));
d203 1
a203 1
	    USBDEVNAME(sc->sc_dev), addr[0], addr[1], addr[2], addr[3],
d214 1
a214 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d245 1
a245 1
		    USBDEVNAME(sc->sc_dev)));
d250 1
a250 1
		    USBDEVNAME(sc->sc_dev)));
d320 1
a320 1
		    USBDEVNAME(sc->sc_dev), pageno);
d333 1
a333 1
	    USBDEVNAME(sc->sc_dev), blockcount, pageno));
d337 1
a337 1
		    USBDEVNAME(sc->sc_dev));
d358 1
a358 1
			    USBDEVNAME(sc->sc_dev));
d367 1
a367 1
			    USBDEVNAME(sc->sc_dev));
d392 1
a392 1
		printf("%s: could not send request\n", USBDEVNAME(sc->sc_dev));
d431 1
a431 1
		printf("%s: reading CMV\n", USBDEVNAME(sc->sc_dev));
d444 1
a444 1
		    USBDEVNAME(sc->sc_dev));
d473 1
a473 1
		printf("%s: writing CMV\n", USBDEVNAME(sc->sc_dev));
d486 1
a486 1
		    USBDEVNAME(sc->sc_dev));
d511 1
a511 1
		    USBDEVNAME(sc->sc_dev)));
d515 1
a515 1
		DPRINTFN(3, ("%s: initializing\n", USBDEVNAME(sc->sc_dev)));
d519 1
a519 1
		DPRINTFN(4, ("%s: operational\n", USBDEVNAME(sc->sc_dev)));
d524 1
a524 1
		    USBDEVNAME(sc->sc_dev)));
d531 1
a531 1
		DPRINTF(("%s: delineation LOSS\n", USBDEVNAME(sc->sc_dev)));
d610 1
a610 1
		    USBDEVNAME(sc->sc_dev));
d625 1
a625 1
	    USBDEVNAME(sc->sc_dev));
d649 1
a649 1
		printf("%s: receiving CMV\n", USBDEVNAME(sc->sc_dev));
d656 1
a656 1
		    USBDEVNAME(sc->sc_dev));
d662 1
a662 1
		    USBDEVNAME(sc->sc_dev));
d694 1
a694 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d714 1
a714 1
		    USBDEVNAME(sc->sc_dev));
d921 1
a921 1
			    USBDEVNAME(sc->sc_dev), count);
d946 1
a946 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d1105 1
a1105 1
	DPRINTF(("%s: opening ATM VCC\n", USBDEVNAME(sc->sc_dev)));
d1123 1
a1123 1
	DPRINTF(("%s: closing ATM VCC\n", USBDEVNAME(sc->sc_dev)));
d1205 1
a1205 1
		    USBDEVNAME(sc->sc_dev));
d1212 1
a1212 1
		printf("%s: could not open tx pipe\n", USBDEVNAME(sc->sc_dev));
d1224 1
a1224 1
			    USBDEVNAME(sc->sc_dev));
d1232 1
a1232 1
			    USBDEVNAME(sc->sc_dev));
d1242 1
a1242 1
		    USBDEVNAME(sc->sc_dev));
d1250 1
a1250 1
		    USBDEVNAME(sc->sc_dev));
d1257 1
a1257 1
		    USBDEVNAME(sc->sc_dev));
d1267 1
a1267 1
		printf("%s: could not open rx pipe\n", USBDEVNAME(sc->sc_dev));
d1279 1
a1279 1
			    USBDEVNAME(sc->sc_dev));
d1288 1
a1288 1
			    USBDEVNAME(sc->sc_dev));
d1362 1
a1362 1
		    USBDEVNAME(sc->sc_dev));
d1370 1
a1370 1
		    USBDEVNAME(sc->sc_dev));
d1378 1
a1378 1
		    USBDEVNAME(sc->sc_dev));
d1384 1
a1384 1
		printf("%s: could not load firmware\n", USBDEVNAME(sc->sc_dev));
d1393 1
a1393 1
		    USBDEVNAME(sc->sc_dev));
d1399 1
a1399 1
		printf("%s: could not boot modem\n", USBDEVNAME(sc->sc_dev));
@


1.17
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.16 2007/06/09 08:52:10 damien Exp $	*/
d227 1
a227 1
	    USBDEV(sc->sc_dev));
d256 1
a256 1
	    USBDEV(sc->sc_dev));
@


1.16
log
@re-indent prototypes after "Static" removal.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.15 2007/06/05 08:43:55 mbalmer Exp $	*/
a1463 1
		if_deactivate(&sc->sc_if);
@


1.15
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.14 2007/05/27 04:00:25 jsg Exp $	*/
d92 4
a95 4
void	ueagle_attachhook(void *);
int	ueagle_getesi(struct ueagle_softc *, uint8_t *);
void	ueagle_loadpage(void *);
void	ueagle_request(struct ueagle_softc *, uint16_t, uint16_t,
d98 1
a98 1
void	ueagle_dump_cmv(struct ueagle_softc *, struct ueagle_cmv *);
d100 1
a100 1
int	ueagle_cr(struct ueagle_softc *, uint32_t, uint16_t,
d102 7
a108 7
int	ueagle_cw(struct ueagle_softc *, uint32_t, uint16_t, uint32_t);
int	ueagle_stat(struct ueagle_softc *);
void	ueagle_stat_thread(void *);
int	ueagle_boot(struct ueagle_softc *);
void	ueagle_swap_intr(struct ueagle_softc *, struct ueagle_swap *);
void	ueagle_cmv_intr(struct ueagle_softc *, struct ueagle_cmv *);
void	ueagle_intr(usbd_xfer_handle, usbd_private_handle,
d111 2
a112 2
void	ueagle_push_cell(struct ueagle_softc *, uint8_t *);
void	ueagle_rxeof(usbd_xfer_handle, usbd_private_handle,
d114 1
a114 1
void	ueagle_txeof(usbd_xfer_handle, usbd_private_handle,
d116 3
a118 3
int	ueagle_encap(struct ueagle_softc *, struct mbuf *);
void	ueagle_start(struct ifnet *);
int	ueagle_open_vcc(struct ueagle_softc *,
d120 1
a120 1
int	ueagle_close_vcc(struct ueagle_softc *,
d122 5
a126 5
int	ueagle_ioctl(struct ifnet *, u_long, caddr_t);
int	ueagle_open_pipes(struct ueagle_softc *);
void	ueagle_close_pipes(struct ueagle_softc *);
int	ueagle_init(struct ifnet *);
void	ueagle_stop(struct ifnet *, int);
@


1.14
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.13 2007/05/21 05:40:28 jsg Exp $	*/
d92 4
a95 4
Static void	ueagle_attachhook(void *);
Static int	ueagle_getesi(struct ueagle_softc *, uint8_t *);
Static void	ueagle_loadpage(void *);
Static void	ueagle_request(struct ueagle_softc *, uint16_t, uint16_t,
d98 1
a98 1
Static void	ueagle_dump_cmv(struct ueagle_softc *, struct ueagle_cmv *);
d100 1
a100 1
Static int	ueagle_cr(struct ueagle_softc *, uint32_t, uint16_t,
d102 7
a108 7
Static int	ueagle_cw(struct ueagle_softc *, uint32_t, uint16_t, uint32_t);
Static int	ueagle_stat(struct ueagle_softc *);
Static void	ueagle_stat_thread(void *);
Static int	ueagle_boot(struct ueagle_softc *);
Static void	ueagle_swap_intr(struct ueagle_softc *, struct ueagle_swap *);
Static void	ueagle_cmv_intr(struct ueagle_softc *, struct ueagle_cmv *);
Static void	ueagle_intr(usbd_xfer_handle, usbd_private_handle,
d110 3
a112 3
Static uint32_t	ueagle_crc_update(uint32_t, uint8_t *, int);
Static void	ueagle_push_cell(struct ueagle_softc *, uint8_t *);
Static void	ueagle_rxeof(usbd_xfer_handle, usbd_private_handle,
d114 1
a114 1
Static void	ueagle_txeof(usbd_xfer_handle, usbd_private_handle,
d116 3
a118 3
Static int	ueagle_encap(struct ueagle_softc *, struct mbuf *);
Static void	ueagle_start(struct ifnet *);
Static int	ueagle_open_vcc(struct ueagle_softc *,
d120 1
a120 1
Static int	ueagle_close_vcc(struct ueagle_softc *,
d122 5
a126 5
Static int	ueagle_ioctl(struct ifnet *, u_long, caddr_t);
Static int	ueagle_open_pipes(struct ueagle_softc *);
Static void	ueagle_close_pipes(struct ueagle_softc *);
Static int	ueagle_init(struct ifnet *);
Static void	ueagle_stop(struct ifnet *, int);
d142 1
a142 1
Static void
d264 1
a264 1
Static int
d301 1
a301 1
Static void
d377 1
a377 1
Static void
d396 1
a396 1
Static void
d413 1
a413 1
Static int
d455 1
a455 1
Static int
d496 1
a496 1
Static int
d563 1
a563 1
Static void
d580 1
a580 1
Static int
d629 1
a629 1
Static void
d644 1
a644 1
Static void
d683 1
a683 1
Static void
d773 1
a773 1
Static uint32_t
d785 1
a785 1
Static void
d896 1
a896 1
Static void
d932 1
a932 1
Static void
d967 1
a967 1
Static int
d1067 1
a1067 1
Static void
d1100 1
a1100 1
Static int
d1120 1
a1120 1
Static int
d1130 1
a1130 1
Static int
d1190 1
a1190 1
Static int
d1312 1
a1312 1
Static void
d1348 1
a1348 1
Static int
d1417 1
a1417 1
Static void
d1454 1
a1454 1
Static int
@


1.13
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.12 2006/09/16 13:31:04 damien Exp $	*/
d130 2
a131 1
USB_MATCH(ueagle)
d133 1
a133 1
	USB_MATCH_START(ueagle, uaa);
d158 2
a159 1
USB_ATTACH(ueagle)
d161 2
a162 1
	USB_ATTACH_START(ueagle, sc, uaa);
d168 1
a168 1
	USB_ATTACH_SETUP;
d183 1
a183 1
		USB_ATTACH_SUCCESS_RETURN;
d193 1
a193 1
		USB_ATTACH_ERROR_RETURN;
d199 1
a199 1
		USB_ATTACH_ERROR_RETURN;
a227 2

	USB_ATTACH_SUCCESS_RETURN;
d230 2
a231 1
USB_DETACH(ueagle)
d233 1
a233 1
	USB_DETACH_START(ueagle, sc);
@


1.12
log
@fix a buggy printf.
in case something wrong happens in the Tx path, don't free a mbuf that
is left in if_snd.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.11 2006/06/23 06:27:11 miod Exp $	*/
d59 2
a60 2
#define DPRINTF(x)	do { if (ueagledebug > 0) logprintf x; } while (0)
#define DPRINTFN(n, x)	do { if (ueagledebug >= (n)) logprintf x; } while (0)
@


1.11
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.10 2006/03/25 22:41:47 djm Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003-2005
d21 1
a21 1
 * Analog Devices Eagle chipset driver
d918 2
a919 2
			printf("%s: truncated cell (%u bytes)\n", count,
			    USBDEVNAME(sc->sc_dev));
d1081 1
a1086 2

	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.10
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.9 2006/01/29 03:22:52 brad Exp $	*/
d1460 1
a1460 1
		return EOPNOTSUPP;
@


1.9
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.8 2006/01/04 06:04:41 canacar Exp $	*/
d878 1
a878 1
		bpf_mtap(ifp->if_bpf, m);
d1091 1
a1091 1
		bpf_mtap(ifp->if_bpf, m0);
@


1.8
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.7 2005/08/04 06:59:36 canacar Exp $	*/
d947 1
a947 1
			usbd_clear_endpoint_stall(sc->pipeh_tx);
@


1.7
log
@Include if_ether.h and use better usbd_devinfo_alloc argument. ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.6 2005/08/01 05:36:48 brad Exp $	*/
a250 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.6
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.5 2005/07/30 07:16:09 brad Exp $	*/
d46 1
d183 1
a183 1
	devinfop = usbd_devinfo_alloc(dev, 0);
@


1.5
log
@6 -> ETHER_ADDR_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.4 2005/07/07 20:16:44 canacar Exp $	*/
d160 1
a160 1
	char devinfo[1024];
d182 3
a184 2
	usbd_devinfo(sc->sc_udev, 0, devinfo, sizeof devinfo);
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.4
log
@ueagle.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.3 2005/05/13 20:20:21 damien Exp $	*/
d161 1
a161 1
	uint8_t addr[6];
@


1.3
log
@fix dmesg output for pre-firmware modems.
@
text
@d1 1
a1 1
/*	$OpenBSD: ueagle.c,v 1.2 2005/04/19 08:21:46 damien Exp $	*/
d1076 3
d1354 1
a1354 1
	int len;
@


1.2
log
@be more cautious when processing CMV interrupts.
drop every CMV reply that is not a CR or CW ack.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a182 1
	USB_ATTACH_SETUP;
@


1.1
log
@Driver for Analog Devices Eagle chipset.
ok deraadt@@
@
text
@d668 2
a669 2
	/* handle spontaneous CMVs */
	if (cmv->bFunction == UEAGLE_MODEMREADY) {
d671 1
a671 2
		return;
	}
d673 1
a673 2
	/* if it is the ack of a previous CR, save the data field */
	if (cmv->bFunction == UEAGLE_CR_ACK)
d675 5
a679 2

	wakeup(UEAGLE_COND_CMV(sc));
@

