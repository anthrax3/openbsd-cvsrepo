head	1.101;
access;
symbols
	OPENBSD_5_1_BASE:1.100
	OPENBSD_5_1:1.100.0.4
	OPENBSD_5_0:1.100.0.2
	OPENBSD_5_0_BASE:1.100
	OPENBSD_4_9:1.99.0.6
	OPENBSD_4_9_BASE:1.99
	OPENBSD_4_8:1.99.0.4
	OPENBSD_4_8_BASE:1.99
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.97.0.8
	OPENBSD_4_6_BASE:1.97
	OPENBSD_4_5:1.97.0.4
	OPENBSD_4_5_BASE:1.97
	OPENBSD_4_4:1.97.0.2
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.96.0.4
	OPENBSD_4_3_BASE:1.96
	OPENBSD_4_2:1.96.0.2
	OPENBSD_4_2_BASE:1.96
	OPENBSD_4_1:1.62.0.2
	OPENBSD_4_1_BASE:1.62
	OPENBSD_4_0:1.61.0.4
	OPENBSD_4_0_BASE:1.61
	OPENBSD_3_9:1.60.0.2
	OPENBSD_3_9_BASE:1.60
	OPENBSD_3_8:1.58.0.2
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.55.0.2
	OPENBSD_3_7_BASE:1.55
	OPENBSD_3_6:1.50.0.4
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.49
	SMP_SYNC_B:1.49
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.40.0.4
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.40
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.101
date	2012.05.18.14.50.35;	author mpi;	state dead;
branches;
next	1.100;

1.100
date	2011.05.24.20.27.11;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.98;

1.98
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.97;

1.97
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.17.07.53.11;	author mbalmer;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.14.12.58.09;	author mbalmer;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.92;

1.92
date	2007.06.14.08.08.21;	author mbalmer;	state Exp;
branches;
next	1.91;

1.91
date	2007.06.14.06.55.10;	author mbalmer;	state Exp;
branches;
next	1.90;

1.90
date	2007.06.13.11.31.33;	author mbalmer;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.88;

1.88
date	2007.06.13.10.33.52;	author mbalmer;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.13.10.10.30;	author mbalmer;	state Exp;
branches;
next	1.86;

1.86
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.11.12.36.53;	author mbalmer;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.11.09.26.55;	author mk;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.11.06.14.24;	author mbalmer;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.11.05.42.54;	author mbalmer;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.10.17.46.27;	author mbalmer;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.10.15.33.16;	author mbalmer;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.10.08.02.16;	author mbalmer;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.09.12.03.39;	author mbalmer;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.29.19.57.45;	author mbalmer;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.21.06.10.44;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.21.05.03.45;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2007.05.20.00.52.26;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2006.09.18.10.55.51;	author dlg;	state Exp;
branches;
next	1.61;

1.61
date	2006.04.23.04.48.07;	author dlg;	state Exp;
branches;
next	1.60;

1.60
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.59;

1.59
date	2005.09.26.22.19.01;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.17.23.50.33;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.02.02.03.33;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.25.21.12.54;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2004.12.26.22.41.40;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.12.06.13.15;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2004.11.23.19.08.54;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.08.22.01.02;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2004.10.05.02.01.18;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.30.03.06.48;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.26.04.26.58;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.02.01.10.09;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.19.12.07.20;	author avsm;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.17.06.07.57;	author nate;	state Exp;
branches;
next	1.40;

1.40
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2002.05.19.18.45.42;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.37;

1.37
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.06.23.07.26;	author nate;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.06.05.44.51;	author nate;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.01.21.47.07;	author nate;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.27.10.47.51;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.02.17.53.47;	author mickey;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.02.19.30.22;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.23.16.56.58;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.25.04.05.51;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.24.21.29.05;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.03.07.46.11;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.03.06.45.34;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.28.22.05.33;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.11.16.23.30;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.06.22.42.10;	author rahnds;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.26.20.08.39;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.04.11.44.25;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.29.13.48.31;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.15.17.36.28;	author jakob;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.12.16.19.12;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.05.00.29.14;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.04.22.51.23;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.31.22.11.37;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.13.08.26.29;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.24;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.44.00;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;

1.40.4.1
date	2003.10.31.06.31.02;	author brad;	state Exp;
branches;
next	;

1.43.2.1
date	2003.10.31.06.07.21;	author brad;	state Exp;
branches;
next	;


desc
@@


1.101
log
@Remove unused header.

ok deraadt@@
@
text
@/*	$OpenBSD: usb_port.h,v 1.100 2011/05/24 20:27:11 matthew Exp $ */
/*	$NetBSD: usb_port.h,v 1.62 2003/02/15 18:33:30 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb_port.h,v 1.21 1999/11/17 22:33:47 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _USB_PORT_H
#define _USB_PORT_H

/*
 * Macros to ease the import of USB drivers from other operating systems, e.g.
 * NetBSD or FreeBSD.
 */

#define Static

/* periph_quirks */
#define	PQUIRK_NOSENSE		ADEV_NOSENSE	/* can't REQUEST SENSE */
#define PQUIRK_ONLYBIG		SDEV_ONLYBIG

#define sel_klist si_note

typedef struct proc *usb_proc_ptr;

#define UCOMBUSCF_PORTNO		0
#define UCOMBUSCF_PORTNO_DEFAULT	-1
#define UHIDBUSCF_REPORTID		0
#define UHIDBUSCF_REPORTID_DEFAULT	-1

#define mstohz(ms) ((ms) * hz / 1000)

#define sel_klist si_note

typedef int usb_malloc_type;

#define if_deactivate(x)
#define IF_INPUT(ifp, m) ether_input_mbuf((ifp), (m))

#define swap_bytes_change_sign16_le swap_bytes_change_sign16
#define change_sign16_swap_bytes_le change_sign16_swap_bytes
#define change_sign16_le change_sign16

#define ulinear8_to_slinear16_le ulinear8_to_linear16_le
#define ulinear8_to_slinear16_be ulinear8_to_linear16_be
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le
#define slinear16_to_ulinear8_be linear16_to_ulinear8_be

typedef struct device *device_ptr_t;
#define USBBASEDEVICE struct device
#define USBDEV(bdev) (&(bdev))
#define USBDEVNAME(bdev) ((bdev).dv_xname)
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
#define USBGETSOFTC(d) ((void *)(d))

#define DECLARE_USB_DMA_T \
	struct usb_dma_block; \
	typedef struct { \
		struct usb_dma_block *block; \
		u_int offs; \
	} usb_dma_t

typedef struct timeout usb_callout_t;
#define usb_callout_init(h)	timeout_set(&(h), NULL, NULL)
#define usb_callout(h, t, f, d) \
	do { \
		timeout_del(&(h)); \
		timeout_set(&(h), (f), (d)); \
		timeout_add(&(h), (t)); \
	} while (0)
#define usb_callout_pending(h)	timeout_pending(&(h))
#define usb_uncallout(h, f, d) timeout_del(&(h))

#define USB_DECLARE_DRIVER_CLASS(dname, devclass)  \
int __CONCAT(dname,_match)(struct device *, void *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, int); \
\
struct cfdriver __CONCAT(dname,_cd) = { \
	NULL, #dname, devclass \
}; \
\
const struct cfattach __CONCAT(dname,_ca) = { \
	sizeof(struct __CONCAT(dname,_softc)), \
	__CONCAT(dname,_match), \
	__CONCAT(dname,_attach), \
	__CONCAT(dname,_detach), \
	__CONCAT(dname,_activate), \
}

#define USB_DECLARE_DRIVER(dname) USB_DECLARE_DRIVER_CLASS(dname, DV_DULL)

#define USB_MATCH(dname) \
int \
__CONCAT(dname,_match)(parent, match, aux) \
	struct device *parent; \
	void *match; \
	void *aux;

#define USB_MATCH_START(dname, uaa) \
	struct usb_attach_arg *uaa = aux

#define USB_ATTACH(dname) \
void \
__CONCAT(dname,_attach)(parent, self, aux) \
	struct device *parent; \
	struct device *self; \
	void *aux;

#define USB_ATTACH_START(dname, sc, uaa) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self; \
	struct usb_attach_arg *uaa = aux

/* Returns from attach */
#define USB_ATTACH_ERROR_RETURN	return
#define USB_ATTACH_SUCCESS_RETURN	return

#define USB_ATTACH_SETUP printf("\n")

#define USB_DETACH(dname) \
int \
__CONCAT(dname,_detach)(self, flags) \
	struct device *self; \
	int flags;

#define USB_DETACH_START(dname, sc) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self

#define USB_GET_SC_OPEN(dname, unit, sc) \
	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
		return (ENXIO); \
	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
	if (sc == NULL) \
		return (ENXIO)

#define USB_GET_SC(dname, unit, sc) \
	sc = __CONCAT(dname,_cd).cd_devs[unit]

#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
	(config_found_sm(parent, args, print, sub))

#endif /* _USB_PORT_H */
@


1.100
log
@On OpenBSD, we've always attached scsibus(4) to umass(4), even for
ATAPI devices.  atapiscsi(4) is only for handling ATAPI devices on an
ATA bus, so umass(4) shouldn't care about it.

ok krw@@, dlg@@; no objections from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.99 2009/11/04 19:14:10 kettenis Exp $ */
@


1.99
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.98 2009/10/13 19:33:19 pirofti Exp $ */
a43 2

#define UMASS_ATAPISTR		"atapiscsi"
@


1.98
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.97 2008/06/26 05:42:19 ray Exp $ */
a41 6

#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
#define USB_USE_SOFTINTR
#else
#undef USB_USE_SOFTINTR
#endif
@


1.97
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.96 2007/06/17 07:53:11 mbalmer Exp $ */
d114 1
a114 1
int __CONCAT(dname,_activate)(struct device *, enum devact); \
@


1.96
log
@No longer include usb_port.h, all macros have been converted to their C
counterparts.

Revert usb_port.h to it's original form with all the macro definitions to
ease the import of new drivers from other BSDs.

after discussion with deraadt; feedback from mk, miod, jsg, dlg.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.67 2007/05/21 06:10:44 jsg Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.95
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.94 2007/06/14 12:58:09 mbalmer Exp $ */
d46 2
a47 1
 * Macro's to cope with the differences between operating systems.
d49 138
@


1.94
log
@Move the mstohz macro out of ubs_port.h and to the three places where it is
used.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.93 2007/06/14 10:11:16 mbalmer Exp $ */
a47 6

#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
#define USB_USE_SOFTINTR
#else
#undef USB_USE_SOFTINTR
#endif
@


1.93
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.92 2007/06/14 08:08:21 mbalmer Exp $ */
a53 2

#define mstohz(ms) ((ms) * hz / 1000)
@


1.92
log
@Move four #defines out of usb_port.h and to the places where they are used.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.91 2007/06/14 06:55:10 mbalmer Exp $ */
a55 20

#define USB_DECLARE_DRIVER_CLASS(dname, devclass)  \
int __CONCAT(dname,_match)(struct device *, void *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, enum devact); \
\
struct cfdriver __CONCAT(dname,_cd) = { \
	NULL, #dname, devclass \
}; \
\
const struct cfattach __CONCAT(dname,_ca) = { \
	sizeof(struct __CONCAT(dname,_softc)), \
	__CONCAT(dname,_match), \
	__CONCAT(dname,_attach), \
	__CONCAT(dname,_detach), \
	__CONCAT(dname,_activate), \
}

#define USB_DECLARE_DRIVER(dname) USB_DECLARE_DRIVER_CLASS(dname, DV_DULL)
@


1.91
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.90 2007/06/13 11:31:33 mbalmer Exp $ */
a53 5

#define UCOMBUSCF_PORTNO		0
#define UCOMBUSCF_PORTNO_DEFAULT	-1
#define UHIDBUSCF_REPORTID		0
#define UHIDBUSCF_REPORTID_DEFAULT	-1
@


1.90
log
@Remove the definition and (single) use of the DECLARE_USB_DMA_T macro.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.89 2007/06/13 11:15:29 mbalmer Exp $ */
a47 2

#include <sys/timeout.h>
@


1.89
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.88 2007/06/13 10:33:52 mbalmer Exp $ */
a62 7

#define DECLARE_USB_DMA_T \
	struct usb_dma_block; \
	typedef struct { \
		struct usb_dma_block *block; \
		u_int offs; \
	} usb_dma_t
@


1.88
log
@Remove the definition and use of umass/umass_quirks related macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.87 2007/06/13 10:10:30 mbalmer Exp $ */
a62 2

#define IF_INPUT(ifp, m) ether_input_mbuf((ifp), (m))
@


1.87
log
@Remove the defintion and use of some byteswap macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.86 2007/06/12 16:26:37 mbalmer Exp $ */
a55 6

#define UMASS_ATAPISTR		"atapiscsi"

/* periph_quirks */
#define	PQUIRK_NOSENSE		ADEV_NOSENSE	/* can't REQUEST SENSE */
#define PQUIRK_ONLYBIG		SDEV_ONLYBIG
@


1.86
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.85 2007/06/11 16:30:31 mbalmer Exp $ */
a70 9

#define swap_bytes_change_sign16_le swap_bytes_change_sign16
#define change_sign16_swap_bytes_le change_sign16_swap_bytes
#define change_sign16_le change_sign16

#define ulinear8_to_slinear16_le ulinear8_to_linear16_le
#define ulinear8_to_slinear16_be ulinear8_to_linear16_be
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le
#define slinear16_to_ulinear8_be linear16_to_ulinear8_be
@


1.85
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.84 2007/06/11 12:36:53 mbalmer Exp $ */
a79 2

typedef struct device *device_ptr_t;
@


1.84
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.83 2007/06/11 10:58:21 mbalmer Exp $ */
a61 2

typedef struct proc *usb_proc_ptr;
@


1.83
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.82 2007/06/11 09:26:55 mk Exp $ */
a110 7

#define USB_GET_SC_OPEN(dname, unit, sc) \
	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
		return (ENXIO); \
	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
	if (sc == NULL) \
		return (ENXIO)
@


1.82
log
@More USB cleanup:  In usb_port.h, get rid of the sel_klist #define
(which was there twice without gcc complaining) and update all uses of
it.

ok jsg mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.81 2007/06/11 06:14:24 mbalmer Exp $ */
a117 3

#define USB_GET_SC(dname, unit, sc) \
	sc = __CONCAT(dname,_cd).cd_devs[unit]
@


1.81
log
@Remove the definiton and usage of the USB_DO_ATTACH macro.  It was a wrapper
around a single function only and it did not even use all of it's arguments.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.80 2007/06/11 05:42:54 mbalmer Exp $ */
a62 2
#define sel_klist si_note

a70 2

#define sel_klist si_note
@


1.80
log
@Remove the definition and usage of the USBGETSOFTC macro, which was really
only a cast to (void *).

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.79 2007/06/10 17:46:27 mbalmer Exp $ */
a124 3

#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
	(config_found_sm(parent, args, print, sub))
@


1.79
log
@Get rid of the USBDEVPTRNAME macro.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.78 2007/06/10 15:33:16 mbalmer Exp $ */
a87 1
#define USBGETSOFTC(d) ((void *)(d))
@


1.78
log
@Remove the definition and use of USBDEVUNIT.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.77 2007/06/10 14:49:01 mbalmer Exp $ */
a87 1
#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
@


1.77
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.76 2007/06/10 10:53:48 mbalmer Exp $ */
a87 1
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
@


1.76
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.75 2007/06/10 10:15:35 mbalmer Exp $ */
a87 1
#define USBDEVNAME(bdev) ((bdev).dv_xname)
@


1.75
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.74 2007/06/10 08:02:16 mbalmer Exp $ */
a87 1
#define USBDEV(bdev) (&(bdev))
@


1.74
log
@Do not turn on debugging in most/all drivers when USB_DEBUG is defined.
Debugging code must be turned on selectively, e.g. by defining UDCF_DEBUG.

idea from and ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.73 2007/06/09 12:22:53 mbalmer Exp $ */
a99 11

typedef struct timeout usb_callout_t;
#define usb_callout_init(h)	timeout_set(&(h), NULL, NULL)
#define usb_callout(h, t, f, d) \
	do { \
		timeout_del(&(h)); \
		timeout_set(&(h), (f), (d)); \
		timeout_add(&(h), (t)); \
	} while (0)
#define usb_callout_pending(h)	timeout_pending(&(h))
#define usb_uncallout(h, f, d) timeout_del(&(h))
@


1.73
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.72 2007/06/09 12:03:39 mbalmer Exp $ */
a54 32
#endif

#ifdef USB_DEBUG
#define UKBD_DEBUG 1
#define UHIDEV_DEBUG 1
#define UHID_DEBUG 1
#define OHCI_DEBUG 1
#define UGEN_DEBUG 1
#define UHCI_DEBUG 1
#define UHUB_DEBUG 1
#define ULPT_DEBUG 1
#define UCOM_DEBUG 1
#define UPLCOM_DEBUG 1
#define UMCT_DEBUG 1
#define UMODEM_DEBUG 1
#define UAUDIO_DEBUG 1
#define AUE_DEBUG 1
#define CUE_DEBUG 1
#define KUE_DEBUG 1
#define UDAV_DEBUG 1
#define UMASS_DEBUG 1
#define UVISOR_DEBUG 1
#define UPL_DEBUG 1
#define UZCOM_DEBUG 1
#define URIO_DEBUG 1
#define UFTDI_DEBUG 1
#define USCANNER_DEBUG 1
#define USSCANNER_DEBUG 1
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
#define UIPAQ_DEBUG 1
#define UDCF_DEBUG 1
@


1.72
log
@Remove the definition and use of usb_malloc_type which is really int.
While here, reindent the function prototypes in usbdi_util.h

No binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.71 2007/06/06 19:25:49 mk Exp $ */
a107 1
#define if_deactivate(x)
@


1.71
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.70 2007/06/05 08:43:56 mbalmer Exp $ */
a106 2

typedef int usb_malloc_type;
@


1.70
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.69 2007/05/29 19:57:45 mbalmer Exp $ */
a122 1
#define USBBASEDEVICE struct device
@


1.69
log
@set UDCF_DEBUG to 1 when USB_DEBUG is defined.

ok mjc
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.68 2007/05/27 04:00:25 jsg Exp $ */
a87 2

#define Static
@


1.68
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.67 2007/05/21 06:10:44 jsg Exp $ */
d86 1
@


1.67
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.66 2007/05/21 05:40:28 jsg Exp $ */
a167 38

#define USB_MATCH(dname) \
int \
__CONCAT(dname,_match)(parent, match, aux) \
	struct device *parent; \
	void *match; \
	void *aux;

#define USB_MATCH_START(dname, uaa) \
	struct usb_attach_arg *uaa = aux

#define USB_ATTACH(dname) \
void \
__CONCAT(dname,_attach)(parent, self, aux) \
	struct device *parent; \
	struct device *self; \
	void *aux;

#define USB_ATTACH_START(dname, sc, uaa) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self; \
	struct usb_attach_arg *uaa = aux

/* Returns from attach */
#define USB_ATTACH_ERROR_RETURN	return
#define USB_ATTACH_SUCCESS_RETURN	return

#define USB_ATTACH_SETUP printf("\n")

#define USB_DETACH(dname) \
int \
__CONCAT(dname,_detach)(self, flags) \
	struct device *self; \
	int flags;

#define USB_DETACH_START(dname, sc) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self
@


1.66
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.65 2007/05/21 05:18:56 jsg Exp $ */
a105 10

/*
 * The UHCI/OHCI controllers are little endian, so on big endian machines
 * the data stored in memory needs to be swapped.
 */

#if defined(letoh32)
#define le32toh(x) letoh32(x)
#define le16toh(x) letoh16(x)
#endif
@


1.65
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.64 2007/05/21 05:03:45 jsg Exp $ */
a122 2

#define logprintf printf
@


1.64
log
@Remove unused bswap{16,32} macros
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.63 2007/05/20 00:52:26 jsg Exp $ */
a120 1
#define Ether_ifattach(ifp, eaddr) ether_ifattach(ifp)
@


1.63
log
@Convert ehci and ucom to rwlock.
Kill the usb specific lockmgr wrapper as nothing uses it now.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.62 2006/09/18 10:55:51 dlg Exp $ */
a103 3

#define bswap32(x)		swap32(x)
#define bswap16(x)		swap16(x)
@


1.62
log
@get rid of the usb_port.h macros that wrap our kthread create functions.

looks ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.61 2006/04/23 04:48:07 dlg Exp $ */
a163 2

#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl))
@


1.61
log
@remove all the compat stuff for the otherbsds. this is openbsd, i prefer
reading openbsd code when im working in the openbsd source tree.

this makes the file immediately less confusing since you can search for a
macro and see how its implemented on openbsd without having to figure out
if you're in the netbsd or freebsd chunk first.

"no problem with me" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.60 2005/11/19 02:18:01 pedro Exp $ */
a120 3

#define usb_kthread_create1	kthread_create
#define usb_kthread_create	kthread_create_deferred
@


1.60
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.59 2005/09/26 22:19:01 miod Exp $ */
a48 157
#if defined(__NetBSD__)
/*
 * NetBSD
 */

#include "opt_usbverbose.h"

#if defined(_KERNEL)
#include <sys/mallocvar.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#endif

#define USB_USE_SOFTINTR

#ifdef USB_DEBUG
#define UKBD_DEBUG 1
#define UHIDEV_DEBUG 1
#define UHID_DEBUG 1
#define OHCI_DEBUG 1
#define UGEN_DEBUG 1
#define UHCI_DEBUG 1
#define UHUB_DEBUG 1
#define ULPT_DEBUG 1
#define UCOM_DEBUG 1
#define UPLCOM_DEBUG 1
#define UMCT_DEBUG 1
#define UMODEM_DEBUG 1
#define UAUDIO_DEBUG 1
#define AUE_DEBUG 1
#define AXE_DEBUG 1
#define CUE_DEBUG 1
#define KUE_DEBUG 1
#define UDAV_DEBUG 1
#define URL_DEBUG 1
#define UMASS_DEBUG 1
#define UVISOR_DEBUG 1
#define UPL_DEBUG 1
#define UZCOM_DEBUG 1
#define URIO_DEBUG 1
#define UFTDI_DEBUG 1
#define USCANNER_DEBUG 1
#define USSCANNER_DEBUG 1
#define UIRDA_DEBUG 1
#define USTIR_DEBUG 1
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
#define UBT_DEBUG 1
#define UAX_DEBUG 1
#define UIPAQ_DEBUG 1
#define Static
#else
#define Static static
#endif

#define SCSI_MODE_SENSE		MODE_SENSE

#define UMASS_ATAPISTR		"atapibus"

typedef struct proc *usb_proc_ptr;

typedef struct device *device_ptr_t;
#define USBBASEDEVICE struct device
#define USBDEV(bdev) (&(bdev))
#define USBDEVNAME(bdev) ((bdev).dv_xname)
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
#define USBDEVPTRNAME(bdevptr) ((bdevptr)->dv_xname)
#define USBGETSOFTC(d) ((void *)(d))

#define DECLARE_USB_DMA_T \
	struct usb_dma_block; \
	typedef struct { \
		struct usb_dma_block *block; \
		u_int offs; \
	} usb_dma_t

typedef struct callout usb_callout_t;
#define usb_callout_init(h)	callout_init(&(h))
#define	usb_callout(h, t, f, d)	callout_reset(&(h), (t), (f), (d))
#define usb_callout_pending(h)	callout_pending(&(h))
#define	usb_uncallout(h, f, d)	callout_stop(&(h))

#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl))

#define usb_kthread_create1	kthread_create1
#define usb_kthread_create	kthread_create

typedef struct malloc_type *usb_malloc_type;

#define Ether_ifattach ether_ifattach
#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))

#define logprintf printf

#define	USB_DNAME(dname)	dname
#define USB_DECLARE_DRIVER(dname)  \
int __CONCAT(dname,_match)(struct device *, struct cfdata *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, enum devact); \
\
extern struct cfdriver __CONCAT(dname,_cd); \
\
CFATTACH_DECL(USB_DNAME(dname), \
    sizeof(struct ___CONCAT(dname,_softc)), \
    ___CONCAT(dname,_match), \
    ___CONCAT(dname,_attach), \
    ___CONCAT(dname,_detach), \
    ___CONCAT(dname,_activate))

#define USB_MATCH(dname) \
int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)

#define USB_MATCH_START(dname, uaa) \
	struct usb_attach_arg *uaa = aux

#define USB_ATTACH(dname) \
void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)

#define USB_ATTACH_START(dname, sc, uaa) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self; \
	struct usb_attach_arg *uaa = aux

/* Returns from attach */
#define USB_ATTACH_ERROR_RETURN	return
#define USB_ATTACH_SUCCESS_RETURN	return

#define USB_ATTACH_SETUP printf("\n")

#define USB_DETACH(dname) \
int __CONCAT(dname,_detach)(struct device *self, int flags)

#define USB_DETACH_START(dname, sc) \
	struct __CONCAT(dname,_softc) *sc = \
		(struct __CONCAT(dname,_softc) *)self

#define USB_GET_SC_OPEN(dname, unit, sc) \
	if (unit >= __CONCAT(dname,_cd).cd_ndevs) \
		return (ENXIO); \
	sc = __CONCAT(dname,_cd).cd_devs[unit]; \
	if (sc == NULL) \
		return (ENXIO)

#define USB_GET_SC(dname, unit, sc) \
	sc = __CONCAT(dname,_cd).cd_devs[unit]

#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
	(config_found_sm(parent, args, print, sub))

#elif defined(__OpenBSD__)
/*
 * OpenBSD
 */
a240 140
#elif defined(__FreeBSD__)
/*
 * FreeBSD
 */

#include "opt_usb.h"

#if defined(_KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#endif

#define Static

#define USBVERBOSE

#define device_ptr_t device_t
#define USBBASEDEVICE device_t
#define USBDEV(bdev) (bdev)
#define USBDEVNAME(bdev) device_get_nameunit(bdev)
#define USBDEVUNIT(bdev) device_get_unit(bdev)
#define USBDEVPTRNAME(bdev) device_get_nameunit(bdev)
#define USBGETSOFTC(bdev) (device_get_softc(bdev))

#define DECLARE_USB_DMA_T typedef void * usb_dma_t

typedef struct proc *usb_proc_ptr;

/* XXX Change this when FreeBSD has memset
 */
#define	memcpy(d, s, l)		bcopy((s),(d),(l))
#define	memset(d, v, l)		bzero((d),(l))
#define bswap32(x)		swap32(x)
#define kthread_create1(f, s, p, a0, a1) \
		kthread_create((f), (s), (p), RFHIGHPID, (a0), (a1))

typedef struct callout_handle usb_callout_t;
#define usb_callout_init(h) callout_handle_init(&(h))
#define usb_callout(h, t, f, d) ((h) = timeout((f), (d), (t)))
#define usb_uncallout(h, f, d) uncallout((f), (d), (h))

#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
#define clfree(p) clist_free_cblocks((p))

#define powerhook_establish(fn, sc) (fn)
#define powerhook_disestablish(hdl)
#define PWR_RESUME 0

#define config_detach(dev, flag) device_delete_child(device_get_parent(dev), dev)

typedef struct malloc_type *usb_malloc_type;

#define USB_DECLARE_DRIVER_INIT(dname, init) \
Static device_probe_t __CONCAT(dname,_match); \
Static device_attach_t __CONCAT(dname,_attach); \
Static device_detach_t __CONCAT(dname,_detach); \
\
Static devclass_t __CONCAT(dname,_devclass); \
\
Static device_method_t __CONCAT(dname,_methods)[] = { \
        DEVMETHOD(device_probe, __CONCAT(dname,_match)), \
        DEVMETHOD(device_attach, __CONCAT(dname,_attach)), \
        DEVMETHOD(device_detach, __CONCAT(dname,_detach)), \
	init, \
        {0,0} \
}; \
\
Static driver_t __CONCAT(dname,_driver) = { \
        #dname, \
        __CONCAT(dname,_methods), \
        sizeof(struct __CONCAT(dname,_softc)) \
}
#define METHODS_NONE			{0,0}
#define USB_DECLARE_DRIVER(dname)	USB_DECLARE_DRIVER_INIT(dname, METHODS_NONE)


#define USB_MATCH(dname) \
Static int \
__CONCAT(dname,_match)(device_t self)

#define USB_MATCH_START(dname, uaa) \
        struct usb_attach_arg *uaa = device_get_ivars(self)

#define USB_ATTACH(dname) \
Static int \
__CONCAT(dname,_attach)(device_t self)

#define USB_ATTACH_START(dname, sc, uaa) \
        struct __CONCAT(dname,_softc) *sc = device_get_softc(self); \
        struct usb_attach_arg *uaa = device_get_ivars(self)

/* Returns from attach */
#define USB_ATTACH_ERROR_RETURN	return ENXIO
#define USB_ATTACH_SUCCESS_RETURN	return 0

#define USB_ATTACH_SETUP \
	sc->sc_dev = self; \
	device_set_desc_copy(self, devinfo)

#define USB_DETACH(dname) \
Static int \
__CONCAT(dname,_detach)(device_t self)

#define USB_DETACH_START(dname, sc) \
	struct __CONCAT(dname,_softc) *sc = device_get_softc(self)

#define USB_GET_SC_OPEN(dname, unit, sc) \
	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit); \
	if (sc == NULL) \
		return (ENXIO)

#define USB_GET_SC(dname, unit, sc) \
	sc = devclass_get_softc(__CONCAT(dname,_devclass), unit)

#define USB_DO_ATTACH(dev, bdev, parent, args, print, sub) \
	(device_probe_and_attach((bdev)) == 0 ? (bdev) : 0)

/* conversion from one type of queue to the other */
#define SIMPLEQ_REMOVE_HEAD	STAILQ_REMOVE_HEAD
#define SIMPLEQ_INSERT_HEAD	STAILQ_INSERT_HEAD
#define SIMPLEQ_INSERT_TAIL	STAILQ_INSERT_TAIL
#define SIMPLEQ_NEXT		STAILQ_NEXT
#define SIMPLEQ_FIRST		STAILQ_FIRST
#define SIMPLEQ_HEAD		STAILQ_HEAD
#define SIMPLEQ_INIT		STAILQ_INIT
#define SIMPLEQ_HEAD_INITIALIZER	STAILQ_HEAD_INITIALIZER
#define SIMPLEQ_ENTRY		STAILQ_ENTRY

#include <sys/syslog.h>
/*
#define logprintf(args...)	log(LOG_DEBUG, args)
*/
#define logprintf		printf

#endif /* __FreeBSD__ */

a241 1

@


1.59
log
@Enable the USB softintr code on platforms which __HAVE_GENERIC_SOFTINTERRUPTS.
go ahead deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.58 2005/06/17 23:50:33 deraadt Exp $ */
d325 1
a325 1
#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl), (p))
@


1.58
log
@uipaq/ucom support; written by isis@@www.cs.umd.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.57 2005/06/02 02:03:33 krw Exp $ */
d208 3
d212 1
@


1.57
log
@Eradicate USB quirks NOTUR and NODOORLOCK. Should no longer be
required and no actual users of the relevant devices found.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.56 2005/05/25 21:12:54 krw Exp $ */
d101 1
d238 1
@


1.56
log
@PQUIK_NOMODESENSE no longer does anything, and PQUIRK_NOBIGMODESENSE was
defined to be 0. Expunge references. Null entries in quirks table will be
removed later.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.55 2004/12/26 22:41:40 miod Exp $ */
a243 2
#define	PQUIRK_NOTUR		ADEV_NOTUR	/* no TEST UNIT READY */
#define	PQUIRK_NODOORLOCK	ADEV_NODOORLOCK	/* can't lock door */
@


1.55
log
@strored -> stored
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.54 2004/12/12 06:13:15 dlg Exp $ */
a243 2
#define	PQUIRK_NOMODESENSE	SDEV_NOMODESENSE/* device doesn't do MODE SENSE
						   properly */
a247 1
#define PQUIRK_NOBIGMODESENSE	0
@


1.54
log
@backout the original method of reattaching a usb device now that we have
something better and more flexible to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.53 2004/11/23 19:08:54 miod Exp $ */
d268 1
a268 1
 * the data strored in memory needs to be swapped.
@


1.53
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.52 2004/11/08 22:01:02 dlg Exp $ */
a177 1
#define USB_ATTACH_NEED_RESET	return
a370 1
#define USB_ATTACH_NEED_RESET	return
a494 1
#define USB_ATTACH_NEED_RESET	return EAGAIN
@


1.52
log
@ugly ugly hack to allow a usb device to do a full reset of the port during
attach.

this is required by atu (atmel based usb wireless) devices. something better
will be done, but we need it for now to work on atu.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.51 2004/10/05 02:01:18 jsg Exp $ */
a280 3

#define	config_pending_incr()
#define	config_pending_decr()
@


1.51
log
@Port of NetBSD's udav driver for Davicom USB DM960 based Ethernet.
Thanks to Mark Uemura for donating several of these adapters.
Tested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.50 2004/08/30 03:06:48 drahn Exp $ */
d178 1
d375 1
d500 1
@


1.50
log
@Remove 'usb_'realloc() usage because it doesn't know the size of the old
buffer, thus may copy too much, causing a memory fault.
ok millert, dlg, henning, tdeval, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.49 2004/05/26 04:26:58 deraadt Exp $ */
d85 1
d226 1
@


1.49
log
@rehab the locator index crack monkeys
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.48 2004/04/02 01:10:09 deraadt Exp $ */
a297 3

#define realloc usb_realloc
void *usb_realloc(void *, u_int, int, int);
@


1.48
log
@axe usb ethernet driver hacked into the tree by taleck@@oz.net
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.47 2004/01/14 02:00:41 krw Exp $ */
d254 1
a254 1
#define UCOMBUSCF_PORTNO		-1
d256 1
a256 1
#define UHIDBUSCF_REPORTID		-1
@


1.47
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.46 2003/12/15 23:36:14 cedric Exp $ */
d82 1
@


1.46
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.45 2003/09/23 16:51:12 millert Exp $ */
a240 2
#define	PQUIRK_FORCELUNS	SDEV_FORCELUNS	/* prehistoric device groks
						   LUNs */
@


1.45
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.44 2003/09/19 12:07:20 avsm Exp $ */
d331 1
a331 1
#define USB_DECLARE_DRIVER(dname)  \
d338 1
a338 1
	NULL, #dname, DV_DULL \
d348 2
@


1.44
log
@Disable USB_USE_SOFTINTR until we have generic support for soft interrupts.
Solves a number of hangs on ohci (and possibly uhci) machines.

Found by me prodding around, and drahn@@ more cluefully
ok pvalchev@@, nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.43 2003/07/08 13:19:09 nate Exp $ */
a287 6

#define	usbpoll			usbselect
#define	uhidpoll		uhidselect
#define	ugenpoll		ugenselect
#define	uriopoll		urioselect
#define uscannerpoll		uscannerselect
@


1.43
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.42 2003/06/27 16:57:14 nate Exp $ */
d205 1
a205 1
#define USB_USE_SOFTINTR
@


1.43.2.1
log
@MFC:
Fix by avsm@@

Disable USB_USE_SOFTINTR until we have generic support for soft interrupts.
Solves a number of hangs on ohci (and possibly uhci) machines.

Found by me prodding around, and drahn@@ more cluefully
ok pvalchev@@, nate@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.43 2003/07/08 13:19:09 nate Exp $ */
d205 1
a205 1
#undef USB_USE_SOFTINTR
@


1.42
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.41 2003/05/17 06:07:57 nate Exp $ */
/*	$NetBSD: usb_port.h,v 1.44 2001/05/14 20:35:29 bouyer Exp $	*/
d56 9
d69 1
d78 1
d84 1
a90 1
#define UMCT_DEBUG 1
d93 6
d104 5
a108 1
#define SCSI_MODE_SENSE			MODE_SENSE
d128 1
d131 2
d136 1
a136 1
typedef int usb_malloc_type;
d143 1
d152 6
a157 7
struct cfattach __CONCAT(dname,_ca) = { \
	sizeof(struct __CONCAT(dname,_softc)), \
	__CONCAT(dname,_match), \
	__CONCAT(dname,_attach), \
	__CONCAT(dname,_detach), \
	__CONCAT(dname,_activate), \
}
d160 1
a160 5
int \
__CONCAT(dname,_match)(parent, match, aux) \
	struct device *parent; \
	struct cfdata *match; \
	void *aux;
d166 1
a166 5
void \
__CONCAT(dname,_attach)(parent, self, aux) \
	struct device *parent; \
	struct device *self; \
	void *aux;
d180 1
a180 4
int \
__CONCAT(dname,_detach)(self, flags) \
	struct device *self; \
	int flags;
a199 1
#include <sys/timeout.h>
d203 4
d217 2
a229 1
#define UMCT_DEBUG 1
d232 2
d251 4
d263 2
a308 1
typedef struct proc *usb_proc_ptr;
d332 1
d347 1
a347 1
struct cfattach __CONCAT(dname,_ca) = { \
d413 9
d436 2
d443 2
a444 3
#define usb_kthread_create1(function, sc, priv, string, name)
#define usb_kthread_create(create_function, sc)
#define usb_kthread_exit(err)
d458 2
d528 1
a528 7
/* XXX In FreeBSD SIMPLEQ_REMOVE_HEAD only removes the head element.
 */
#define SIMPLEQ_REMOVE_HEAD(h, e, f)	do {				\
		if ( (e) != SIMPLEQ_FIRST((h)) )			\
			panic("Removing other than first element");	\
		STAILQ_REMOVE_HEAD(h, f);				\
} while (0)
@


1.41
log
@sync with NetBSD and add various local hacks to make things work correctly
with our scsi layer
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.40 2002/07/25 02:18:11 nate Exp $ */
d249 2
@


1.40
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.39 2002/05/19 18:45:42 miod Exp $ */
d219 13
a233 18

#define SCSI_MODE_SENSE		MODE_SENSE
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
@


1.40.4.1
log
@MFC:
Fix by avsm@@

Disable USB_USE_SOFTINTR until we have generic support for soft interrupts.
Solves a number of hangs on ohci (and possibly uhci) machines.

Found by me prodding around, and drahn@@ more cluefully
ok pvalchev@@, nate@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.40 2002/07/25 02:18:11 nate Exp $ */
d56 1
a56 1
#undef USB_USE_SOFTINTR
@


1.39
log
@Provide a correct timeout behaviour, fixes some panics people had been
experienting.
Discussed and brought to this shape by art@@, drahn@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.38 2002/05/09 15:06:29 nate Exp $ */
d45 1
a45 1
/* 
@


1.38
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.37 2002/05/07 18:29:18 nate Exp $ */
d304 1
a304 1
#define usb_callout_init(h)
d306 5
a310 1
	{ timeout_set(&(h), (f), (d)); timeout_add(&(h), (t)); }
@


1.37
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.35 2002/05/06 23:07:26 nate Exp $ */
d193 1
d239 2
@


1.36
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usb_port.h,v 1.54 2002/03/28 21:49:19 ichiro Exp $	*/
a59 1
#define UHIDEV_DEBUG 1
a67 1
#define UMCT_DEBUG 1
a72 1
#define URL_DEBUG 1
d79 1
a81 5
#define EHCI_DEBUG 1
#define UIRDA_DEBUG 1
#define USTIR_DEBUG 1
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
d87 1
a87 5
#define SCSI_MODE_SENSE		MODE_SENSE

#define UMASS_ATAPISTR		"atapibus"

typedef struct proc *usb_proc_ptr;
a106 1
#define usb_callout_pending(h)	callout_pending(&(h))
a108 2
#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl))

d136 5
a140 1
int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)
d146 5
a150 1
void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)
d164 4
a167 1
int __CONCAT(dname,_detach)(struct device *self, int flags)
d187 1
a190 5
#include <sys/timeout.h>

#define USB_USE_SOFTINTR

#define USB_DEBUG
a192 1
#define UHIDEV_DEBUG 1
a199 2
#define UPLCOM_DEBUG 1
#define UMCT_DEBUG 1
d211 1
a213 3
#define EHCI_DEBUG 1
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
a217 30
#define UMASS_ATAPISTR		"atapiscsi"

/* periph_quirks */
#define	PQUIRK_AUTOSAVE		0x00000001	/* do implicit SAVE POINTERS */
#define	PQUIRK_NOSYNC		0x00000002	/* does not grok SDTR */
#define	PQUIRK_NOWIDE		0x00000004	/* does not grok WDTR */
#define	PQUIRK_NOTAG		0x00000008	/* does not grok tagged cmds */
#define	PQUIRK_NOLUNS		0x00000010	/* DTWT with LUNs */
#define	PQUIRK_FORCELUNS	0x00000020	/* prehistoric device groks
						   LUNs */
#define	PQUIRK_NOMODESENSE	0x00000040	/* device doesn't do MODE SENSE
						   properly */
#define	PQUIRK_NOSTARTUNIT	0x00000080	/* do not issue START UNIT */
#define	PQUIRK_NOSYNCCACHE	0x00000100	/* do not issue SYNC CACHE */
#define	PQUIRK_CDROM		0x00000200	/* device is a CD-ROM, no
						   matter what else it claims */
#define	PQUIRK_LITTLETOC	0x00000400	/* audio TOC is little-endian */
#define	PQUIRK_NOCAPACITY	0x00000800	/* no READ CD CAPACITY */
#define	PQUIRK_NOTUR		0x00001000	/* no TEST UNIT READY */
#define	PQUIRK_NODOORLOCK	0x00002000	/* can't lock door */
#define	PQUIRK_NOSENSE		0x00004000	/* can't REQUEST SENSE */
#define PQUIRK_ONLYBIG		0x00008000	/* only use SCSI_{R,W}_BIG */
#define PQUIRK_BYTE5_ZERO	0x00010000	/* byte5 in capacity is wrong */
#define PQUIRK_NO_FLEX_PAGE	0x00020000	/* does not support flex geom
						   page */
#define PQUIRK_NOBIGMODESENSE	0x00040000	/* has no big mode-sense op */
#define PQUIRK_CAP_SYNC		0x00080000	/* SCSI1 device with sync op */

typedef struct proc *usb_proc_ptr;

d220 18
a237 2
#define UHIDBUSCF_REPORTID		-1
#define UHIDBUSCF_REPORTID_DEFAULT	-1
a303 1
#define usb_callout_pending(h)	timeout_pending(&(h))
a383 9
#if defined(_KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#endif

a397 2
typedef struct proc *usb_proc_ptr;

d403 3
a405 2
#define kthread_create1(f, s, p, a0, a1) \
		kthread_create((f), (s), (p), RFHIGHPID, (a0), (a1))
a417 2

#define config_detach(dev, flag) device_delete_child(device_get_parent(dev), dev)
@


1.35
log
@sync uaudio with NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.34 2002/05/06 05:44:51 nate Exp $ */
/*	$NetBSD: usb_port.h,v 1.44 2001/05/14 20:35:29 bouyer Exp $	*/
d60 1
d69 1
d75 1
a81 1
#define UMCT_DEBUG 1
d84 5
d94 5
a98 1
#define SCSI_MODE_SENSE			MODE_SENSE
d118 1
d121 2
d150 1
a150 5
int \
__CONCAT(dname,_match)(parent, match, aux) \
	struct device *parent; \
	struct cfdata *match; \
	void *aux;
d156 1
a156 5
void \
__CONCAT(dname,_attach)(parent, self, aux) \
	struct device *parent; \
	struct device *self; \
	void *aux;
d170 1
a170 4
int \
__CONCAT(dname,_detach)(self, flags) \
	struct device *self; \
	int flags;
a189 1
#include <sys/timeout.h>
d193 5
d200 1
d208 2
a220 1
#define UMCT_DEBUG 1
d223 3
d230 30
d262 2
a263 18

#define SCSI_MODE_SENSE		MODE_SENSE
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
#define xs_control		flags
#define xs_status		status
d330 1
d411 9
d434 2
d441 2
a442 3
#define usb_kthread_create1(function, sc, priv, string, name)
#define usb_kthread_create(create_function, sc)
#define usb_kthread_exit(err)
d455 2
@


1.34
log
@typedef for proc * for portability
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.33 2002/04/01 21:47:07 nate Exp $ */
d275 5
@


1.33
log
@Add support for a bunch of new adapters.
Sync with NetBSD.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.32 2002/02/27 10:47:51 art Exp $ */
d279 1
@


1.32
log
@We have memcpy and memset in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.31 2001/11/02 17:53:47 mickey Exp $ */
d299 2
@


1.31
log
@i do not think everybody needs USB_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.30 2001/10/31 04:24:44 nate Exp $ */
a238 2
#define	memcpy(d, s, l)		bcopy((s),(d),(l))
#define	memset(d, v, l)		bzero((d),(l))
@


1.31.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.31 2001/11/02 17:53:47 mickey Exp $ */
a192 1
#define UHIDEV_DEBUG 1
a237 2
#define UHIDBUSCF_REPORTID		-1
#define UHIDBUSCF_REPORTID_DEFAULT	-1
d239 2
a277 5
#define ulinear8_to_slinear16_le ulinear8_to_linear16_le
#define ulinear8_to_slinear16_be ulinear8_to_linear16_be
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le
#define slinear16_to_ulinear8_be linear16_to_ulinear8_be

a280 1
typedef struct proc *usb_proc_ptr;
d297 1
a297 1
#define usb_callout_init(h)	timeout_set(&(h), NULL, NULL)
d299 1
a299 5
	do { \
		timeout_del(&(h)); \
		timeout_set(&(h), (f), (d)); \
		timeout_add(&(h), (t)); \
	} while (0)
a300 2

#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl), (p))
@


1.31.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.31.2.1 2002/06/11 03:42:31 art Exp $ */
d45 1
a45 1
/*
@


1.31.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a218 13
#define UMASS_ATAPISTR		"atapiscsi"

/* periph_quirks */
#define	PQUIRK_FORCELUNS	SDEV_FORCELUNS	/* prehistoric device groks
						   LUNs */
#define	PQUIRK_NOMODESENSE	SDEV_NOMODESENSE/* device doesn't do MODE SENSE
						   properly */
#define	PQUIRK_NOTUR		ADEV_NOTUR	/* no TEST UNIT READY */
#define	PQUIRK_NODOORLOCK	ADEV_NODOORLOCK	/* can't lock door */
#define	PQUIRK_NOSENSE		ADEV_NOSENSE	/* can't REQUEST SENSE */
#define PQUIRK_ONLYBIG		SDEV_ONLYBIG
#define PQUIRK_NOBIGMODESENSE	0

d221 18
@


1.30
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.29 2001/10/02 19:30:22 provos Exp $ */
a190 1
#define USB_DEBUG
@


1.29
log
@make usb work across apm suspends. okay millert@@, niklas@@, aaron@@, deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.27 2001/06/25 04:05:51 fgsch Exp $ */
/*	$NetBSD: usb_port.h,v 1.42 2001/03/28 19:00:39 ichiro Exp $	*/
d42 2
d56 2
a67 1
#define UMCT_DEBUG 1
d79 1
d87 2
d191 1
d212 1
d505 3
@


1.28
log
@

Add show_scsipi_xs and show_scsipi_cmd. Closes PR#2008
@
text
@a264 4
#define powerhook_establish(fn, sc) (fn)
#define powerhook_disestablish(hdl)
#define PWR_RESUME 0

@


1.27
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.26 2001/06/24 21:29:05 mickey Exp $ */
d227 2
@


1.26
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.25 2001/05/03 02:20:34 aaron Exp $ */
d255 1
a255 7
#define IF_INPUT(ifp, m) do {						\
	struct ether_header *eh;					\
									\
	eh = mtod(m, struct ether_header *);				\
	m_adj(m, sizeof(struct ether_header));				\
	ether_input((ifp), (eh), (m));					\
} while (0)
@


1.25
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.24 2001/02/03 07:46:11 mickey Exp $ */
a280 2

extern int cold;
@


1.24
log
@oops, sleep(9)
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.23 2001/02/03 06:45:34 mickey Exp $ */
/*	$NetBSD: usb_port.h,v 1.35 2000/09/23 04:32:23 augustss Exp $	*/
d63 2
d71 1
@


1.23
log
@new timeouts; somebody, fold it back to {f,n}bsd
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.22 2001/01/28 22:05:33 aaron Exp $ */
d178 1
@


1.22
log
@Add USSCANNER_DEBUG defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.21 2001/01/28 09:43:42 aaron Exp $ */
d295 1
a295 1
typedef char usb_callout_t;
d297 3
a299 2
#define usb_callout(h, t, f, d) timeout((f), (d), (t))
#define usb_uncallout(h, f, d) untimeout((f), (d))
@


1.21
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.20 2000/11/11 16:23:30 drahn Exp $ */
d74 1
d202 1
@


1.20
log
@Change the le32toh() le16toh() macros back to the previous defintion.
This change is more portable, redefine the macros to use the host
letoh32/letoh16 instead of using possibly less efficient bswap routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.19 2000/11/08 18:10:39 aaron Exp $ */
d261 1
@


1.19
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.18 2000/09/06 22:42:10 rahnds Exp $ */
d228 10
@


1.18
log
@Match Free/Net macros for le32toh/letoh32, define in terms of the other.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.17 2000/08/26 20:08:39 nate Exp $ */
/*	$NetBSD: usb_port.h,v 1.28 2000/03/30 08:53:31 augustss Exp $	*/
d55 1
d73 1
d110 4
a113 4
int __CONCAT(dname,_match) __P((struct device *, struct cfdata *, void *)); \
void __CONCAT(dname,_attach) __P((struct device *, struct device *, void *)); \
int __CONCAT(dname,_detach) __P((struct device *, int)); \
int __CONCAT(dname,_activate) __P((struct device *, enum devact)); \
d167 1
a167 1
	if (!sc) \
d181 1
d200 1
a228 10
/*
 * The UHCI/OHCI controllers are little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */

#if defined(letoh32)
#define le32toh(x) letoh32(x)
#define le16toh(x) letoh16(x)
#endif

d263 1
a263 1
void *usb_realloc __P((void *, u_int, int, int));
d288 4
a291 4
int __CONCAT(dname,_match) __P((struct device *, void *, void *)); \
void __CONCAT(dname,_attach) __P((struct device *, struct device *, void *)); \
int __CONCAT(dname,_detach) __P((struct device *, int)); \
int __CONCAT(dname,_activate) __P((struct device *, enum devact)); \
d347 1
a347 1
	if (!sc) \
d456 1
a456 1
	if (!sc) \
@


1.17
log
@Add support for detach of xe and aue.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.16 2000/07/04 11:44:25 fgsch Exp $ */
d224 11
@


1.16
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.15 2000/06/29 13:48:31 aaron Exp $ */
a231 1
#define mii_attach(x1,x2,x3,x4,x5,x6) mii_phy_probe(x1,x2,x3)
@


1.15
log
@Allow USB to compile with USB_DEBUG defined; binkertn@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.14 2000/04/15 17:36:28 jakob Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d68 4
a71 1
#define UVISOR_DEBUG 1
d100 2
d193 4
d230 2
d393 2
@


1.14
log
@urio(4) - Diamond Multimedia RIO 500 (from NetBSD)

This driver will eventually go away as it really should be implemented
using ugen(4) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.13 2000/04/12 16:19:12 aaron Exp $ */
d214 1
@


1.13
log
@RCSids.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d234 1
@


1.12
log
@Add USB modem driver stubs; from NetBSD. Not yet tested.
@
text
@d1 1
@


1.11
log
@New USB mass storage driver. Improvements: Uses asynchronous USB requests,
supports more transport protocols (bulk-only and CBI), supports more command
sets (SCSI and ATAPI); from NetBSD. Not yet tested.
@
text
@a0 1
/*	$OpenBSD: usb_port.h,v 1.10 2000/03/31 22:11:37 aaron Exp $ */
d190 3
@


1.10
log
@Add support for USB Mass Storage devices; e.g., USB Zip Drives. UNTESTED.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.9 2000/03/30 16:19:33 aaron Exp $ */
d68 1
d187 1
d192 1
@


1.9
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.8 2000/03/28 19:37:50 aaron Exp $ */
d189 15
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_port.h,v 1.23 2000/03/24 22:03:32 augustss Exp $	*/
d67 4
d93 6
d185 1
d188 2
d193 16
a208 1
#define kthread_create1		kthread_create
d227 2
d325 2
d344 3
a346 3
#define kthread_create1(function, sc, priv, string, name)
#define kthread_create(create_function, sc)
#define kthread_exit(err)
d361 3
a363 3
static device_probe_t __CONCAT(dname,_match); \
static device_attach_t __CONCAT(dname,_attach); \
static device_detach_t __CONCAT(dname,_detach); \
d365 1
a365 1
static devclass_t __CONCAT(dname,_devclass); \
d367 1
a367 1
static device_method_t __CONCAT(dname,_methods)[] = { \
d375 1
a375 1
static driver_t __CONCAT(dname,_driver) = { \
d385 1
a385 1
static int \
d392 1
a392 1
static int \
d408 1
a408 1
static int \
@


1.7
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usb_port.h,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: usb_port.h,v 1.21 2000/02/02 07:34:00 augustss Exp $	*/
d84 4
a87 2
#define usb_timeout(f, d, t, h) timeout((f), (d), (t))
#define usb_untimeout(f, d, h) untimeout((f), (d))
d91 1
a91 1
#define USB_DECLARE_DRIVER_(dname)  \
a176 1
typedef struct device *device_ptr_t;
d180 1
d186 14
d214 4
a217 2
#define usb_timeout(f, d, t, h) timeout((f), (d), (t))
#define usb_untimeout(f, d, h) untimeout((f), (d))
d220 1
a220 1
int __CONCAT(dname,_match)  __P((struct device *, void *, void *)); \
d316 4
a319 2
#define usb_timeout(f, d, t, h) ((h) = timeout((f), (d), (t)))
#define usb_untimeout(f, d, h) untimeout((f), (d), (h))
d344 1
a344 1
	#dname, \
d350 1
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usb_port.h,v 1.14 1999/10/14 01:18:39 augustss Exp $	*/
d60 2
d63 3
d72 1
d74 1
d88 1
a88 1
#define USB_DECLARE_DRIVER_NAME_INIT(_1, dname, _2)  \
d166 6
d174 1
a182 1
typedef struct device *device_ptr_t;
d186 1
d188 1
d200 2
a201 2
#define USB_DECLARE_DRIVER_NAME_INIT(_1, dname, _2)  \
int __CONCAT(dname,_match) __P((struct device *, void *, void *)); \
d278 1
d282 1
d284 1
d292 4
a295 3
#define bswap32(x)		swap32(x)		/* XXX not available in FreeBSD */
#define kthread_create1
#define kthread_create
d300 1
a300 1
#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (x)), 0)
d303 1
a303 1
#define powerhook_establish(fn, sc) 0
d307 1
a307 3
#define config_detach(d, _1) device_delete_child(device_get_parent((d)), (d))

#define USB_DECLARE_DRIVER_NAME_INIT(name, dname, init) \
d323 1
a323 1
        name, \
d327 2
a394 11

#define NONE {0,0}

#define USB_DECLARE_DRIVER_NAME(name, dname) \
	USB_DECLARE_DRIVER_NAME_INIT(#name, dname, NONE )
#define USB_DECLARE_DRIVER_INIT(dname, init) \
	USB_DECLARE_DRIVER_NAME_INIT(#dname, dname, init)
#define USB_DECLARE_DRIVER(dname) \
	USB_DECLARE_DRIVER_NAME_INIT(#dname, dname, NONE )

#undef NONE
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usb_port.h,v 1.24 2001/02/03 07:46:11 mickey Exp $ */
/*	$NetBSD: usb_port.h,v 1.35 2000/09/23 04:32:23 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb_port.h,v 1.21 1999/11/17 22:33:47 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a53 1
#define UKBD_DEBUG 1
a59 2
#define UCOM_DEBUG 1
#define UMODEM_DEBUG 1
a60 13
#define AUE_DEBUG 1
#define CUE_DEBUG 1
#define KUE_DEBUG 1
#define UMASS_DEBUG 1
#define UPL_DEBUG 1
#define UZCOM_DEBUG 1
#define URIO_DEBUG 1
#define UFTDI_DEBUG 1
#define USCANNER_DEBUG 1
#define USSCANNER_DEBUG 1
#define Static
#else
#define Static static
a66 1
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
a67 1
#define USBGETSOFTC(d) ((void *)(d))
d76 2
a77 12
typedef struct callout usb_callout_t;
#define usb_callout_init(h)	callout_init(&(h))
#define	usb_callout(h, t, f, d)	callout_reset(&(h), (t), (f), (d))
#define	usb_uncallout(h, f, d)	callout_stop(&(h))

#define usb_kthread_create1	kthread_create1
#define usb_kthread_create	kthread_create

typedef int usb_malloc_type;

#define Ether_ifattach ether_ifattach
#define IF_INPUT(ifp, m) (*(ifp)->if_input)((ifp), (m))
d81 5
a85 5
#define USB_DECLARE_DRIVER(dname)  \
int __CONCAT(dname,_match)(struct device *, struct cfdata *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, enum devact); \
d139 1
a139 1
	if (sc == NULL) \
a148 1
#include <sys/timeout.h>
a152 1
#define UKBD_DEBUG 1
a158 14
#define UCOM_DEBUG 1
#define UMODEM_DEBUG 1
#define UAUDIO_DEBUG 1
#define AUE_DEBUG 1
#define CUE_DEBUG 1
#define KUE_DEBUG 1
#define UMASS_DEBUG 1
#define UVISOR_DEBUG 1
#define UPL_DEBUG 1
#define UZCOM_DEBUG 1
#define URIO_DEBUG 1
#define UFTDI_DEBUG 1
#define USCANNER_DEBUG 1
#define USSCANNER_DEBUG 1
a160 21
#define Static

#define UCOMBUSCF_PORTNO		-1
#define UCOMBUSCF_PORTNO_DEFAULT	-1

#define SCSI_MODE_SENSE		MODE_SENSE
#define XS_STS_DONE		ITSDONE
#define XS_CTL_POLL		SCSI_POLL
#define XS_CTL_DATA_IN		SCSI_DATA_IN
#define XS_CTL_DATA_OUT		SCSI_DATA_OUT
#define scsipi_adapter		scsi_adapter
#define scsipi_cmd		scsi_cmd
#define scsipi_device		scsi_device
#define scsipi_done		scsi_done
#define scsipi_link		scsi_link
#define scsipi_minphys		scsi_minphys
#define scsipi_sense		scsi_sense
#define scsipi_xfer		scsi_xfer
#define xs_control		flags
#define xs_status		status

a163 29
#define bswap16(x)		swap16(x)

/*
 * The UHCI/OHCI controllers are little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */

#if defined(letoh32)
#define le32toh(x) letoh32(x)
#define le16toh(x) letoh16(x)
#endif

#define usb_kthread_create1	kthread_create
#define usb_kthread_create	kthread_create_deferred

#define	config_pending_incr()
#define	config_pending_decr()

typedef int usb_malloc_type;

#define Ether_ifattach(ifp, eaddr) ether_ifattach(ifp)
#define if_deactivate(x)
#define IF_INPUT(ifp, m) do {						\
	struct ether_header *eh;					\
									\
	eh = mtod(m, struct ether_header *);				\
	m_adj(m, sizeof(struct ether_header));				\
	ether_input((ifp), (eh), (m));					\
} while (0)
a167 17
#define	uriopoll		urioselect
#define uscannerpoll		uscannerselect

#define powerhook_establish(fn, sc) (fn)
#define powerhook_disestablish(hdl)
#define PWR_RESUME 0

#define logprintf printf

#define swap_bytes_change_sign16_le swap_bytes_change_sign16
#define change_sign16_swap_bytes_le change_sign16_swap_bytes
#define change_sign16_le change_sign16

#define realloc usb_realloc
void *usb_realloc(void *, u_int, int, int);

extern int cold;
a172 1
#define USBDEVUNIT(bdev) ((bdev).dv_unit)
a173 1
#define USBGETSOFTC(d) ((void *)(d))
d182 8
a189 11
typedef struct timeout usb_callout_t;
#define usb_callout_init(h)
#define usb_callout(h, t, f, d) \
	{ timeout_set(&(h), (f), (d)); timeout_add(&(h), (t)); }
#define usb_uncallout(h, f, d) timeout_del(&(h))

#define USB_DECLARE_DRIVER(dname)  \
int __CONCAT(dname,_match)(struct device *, void *, void *); \
void __CONCAT(dname,_attach)(struct device *, struct device *, void *); \
int __CONCAT(dname,_detach)(struct device *, int); \
int __CONCAT(dname,_activate)(struct device *, enum devact); \
d245 1
a245 1
	if (sc == NULL) \
a260 2
#define Static

a262 1
#define device_ptr_t device_t
a265 1
#define USBDEVUNIT(bdev) device_get_unit(bdev)
a266 1
#define USBGETSOFTC(bdev) (device_get_softc(bdev))
d274 6
a279 9
#define bswap32(x)		swap32(x)
#define usb_kthread_create1(function, sc, priv, string, name)
#define usb_kthread_create(create_function, sc)
#define usb_kthread_exit(err)

typedef struct callout_handle usb_callout_t;
#define usb_callout_init(h) callout_handle_init(&(h))
#define usb_callout(h, t, f, d) ((h) = timeout((f), (d), (t)))
#define usb_uncallout(h, f, d) uncallout((f), (d), (h))
d281 1
a281 1
#define clalloc(p, s, x) (clist_alloc_cblocks((p), (s), (s)), 0)
d284 1
a284 1
#define powerhook_establish(fn, sc) (fn)
d288 1
a288 1
typedef struct malloc_type *usb_malloc_type;
d290 4
a293 4
#define USB_DECLARE_DRIVER_INIT(dname, init) \
Static device_probe_t __CONCAT(dname,_match); \
Static device_attach_t __CONCAT(dname,_attach); \
Static device_detach_t __CONCAT(dname,_detach); \
d295 1
a295 1
Static devclass_t __CONCAT(dname,_devclass); \
d297 1
a297 1
Static device_method_t __CONCAT(dname,_methods)[] = { \
d305 2
a306 2
Static driver_t __CONCAT(dname,_driver) = { \
        #dname, \
a309 3
#define METHODS_NONE			{0,0}
#define USB_DECLARE_DRIVER(dname)	USB_DECLARE_DRIVER_INIT(dname, METHODS_NONE)

d312 1
a312 1
Static int \
d319 1
a319 1
Static int \
d335 1
a335 1
Static int \
d343 1
a343 1
	if (sc == NULL) \
d376 11
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_port.h,v 1.42 2001/03/28 19:00:39 ichiro Exp $	*/
a62 2
#define UPLCOM_DEBUG 1
#define UMCT_DEBUG 1
a68 1
#define UVISOR_DEBUG 1
d252 7
a258 1
#define IF_INPUT(ifp, m) ether_input_mbuf((ifp), (m))
d278 2
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.6.2.2 2001/07/04 10:44:00 niklas Exp $ */
a226 2
#define show_scsipi_xs          show_scsi_xs
#define show_scsipi_cmd         show_scsi_cmd
d262 4
@


1.6.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_port.h,v 1.44 2001/05/14 20:35:29 bouyer Exp $	*/
a41 2
#ifndef _USB_PORT_H
#define _USB_PORT_H
a53 2
#define USB_USE_SOFTINTR

d64 1
a75 1
#define UMCT_DEBUG 1
a82 2
#define SCSI_MODE_SENSE			MODE_SENSE

a204 1
#define UMCT_DEBUG 1
a496 3

#endif /* _USB_PORT_H */

@


1.6.2.5
log
@Merge in trunk
@
text
@d239 2
@


1.6.2.6
log
@Sync the SMP branch with 3.3
@
text
@d45 1
a45 1
/*
a192 1
#define UHIDEV_DEBUG 1
a237 2
#define UHIDBUSCF_REPORTID		-1
#define UHIDBUSCF_REPORTID_DEFAULT	-1
a275 5
#define ulinear8_to_slinear16_le ulinear8_to_linear16_le
#define ulinear8_to_slinear16_be ulinear8_to_linear16_be
#define slinear16_to_ulinear8_le linear16_to_ulinear8_le
#define slinear16_to_ulinear8_be linear16_to_ulinear8_be

a278 1
typedef struct proc *usb_proc_ptr;
d295 1
a295 1
#define usb_callout_init(h)	timeout_set(&(h), NULL, NULL)
d297 1
a297 5
	do { \
		timeout_del(&(h)); \
		timeout_set(&(h), (f), (d)); \
		timeout_add(&(h), (t)); \
	} while (0)
a298 2

#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl), (p))
@


1.6.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.6.2.6 2003/03/28 00:38:32 niklas Exp $ */
a218 13
#define UMASS_ATAPISTR		"atapiscsi"

/* periph_quirks */
#define	PQUIRK_FORCELUNS	SDEV_FORCELUNS	/* prehistoric device groks
						   LUNs */
#define	PQUIRK_NOMODESENSE	SDEV_NOMODESENSE/* device doesn't do MODE SENSE
						   properly */
#define	PQUIRK_NOTUR		ADEV_NOTUR	/* no TEST UNIT READY */
#define	PQUIRK_NODOORLOCK	ADEV_NODOORLOCK	/* can't lock door */
#define	PQUIRK_NOSENSE		ADEV_NOSENSE	/* can't REQUEST SENSE */
#define PQUIRK_ONLYBIG		SDEV_ONLYBIG
#define PQUIRK_NOBIGMODESENSE	0

d221 18
@


1.6.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usb_port.h,v 1.62 2003/02/15 18:33:30 augustss Exp $	*/
a55 9
#if defined(_KERNEL)
#include <sys/mallocvar.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#endif

a59 1
#define UHIDEV_DEBUG 1
a67 1
#define UMCT_DEBUG 1
a72 1
#define URL_DEBUG 1
d79 1
a81 6
#define UIRDA_DEBUG 1
#define USTIR_DEBUG 1
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
#define UBT_DEBUG 1
#define UAX_DEBUG 1
d87 1
a87 5
#define SCSI_MODE_SENSE		MODE_SENSE

#define UMASS_ATAPISTR		"atapibus"

typedef struct proc *usb_proc_ptr;
a106 1
#define usb_callout_pending(h)	callout_pending(&(h))
a108 2
#define usb_lockmgr(l, f, sl, p) lockmgr((l), (f), (sl))

d112 1
a112 1
typedef struct malloc_type *usb_malloc_type;
a118 1
#define	USB_DNAME(dname)	dname
d127 7
a133 6
CFATTACH_DECL(USB_DNAME(dname), \
    sizeof(struct ___CONCAT(dname,_softc)), \
    ___CONCAT(dname,_match), \
    ___CONCAT(dname,_attach), \
    ___CONCAT(dname,_detach), \
    ___CONCAT(dname,_activate))
d136 5
a140 1
int __CONCAT(dname,_match)(struct device *parent, struct cfdata *match, void *aux)
d146 5
a150 1
void __CONCAT(dname,_attach)(struct device *parent, struct device *self, void *aux)
d164 4
a167 1
int __CONCAT(dname,_detach)(struct device *self, int flags)
d187 1
a190 4
#include <sys/timeout.h>

#undef USB_USE_SOFTINTR

a200 2
#define UPLCOM_DEBUG 1
#define UMCT_DEBUG 1
d212 1
a214 2
#define UISDATA_DEBUG 1
#define UDSBR_DEBUG 1
d222 2
a231 4
#define sel_klist si_note

typedef struct proc *usb_proc_ptr;

a239 2
#define mstohz(ms) ((ms) * hz / 1000)

a249 2
#define sel_klist si_note

d262 6
d282 1
a305 1
#define usb_callout_pending(h)	timeout_pending(&(h))
d310 1
a310 1
#define USB_DECLARE_DRIVER_CLASS(dname, devclass)  \
d317 1
a317 1
	NULL, #dname, devclass \
d320 1
a320 1
const struct cfattach __CONCAT(dname,_ca) = { \
a327 2
#define USB_DECLARE_DRIVER(dname) USB_DECLARE_DRIVER_CLASS(dname, DV_DULL)

a385 9
#if defined(_KERNEL)
#include <sys/malloc.h>

MALLOC_DECLARE(M_USB);
MALLOC_DECLARE(M_USBDEV);
MALLOC_DECLARE(M_USBHC);

#endif

a399 2
typedef struct proc *usb_proc_ptr;

d405 3
a407 2
#define kthread_create1(f, s, p, a0, a1) \
		kthread_create((f), (s), (p), RFHIGHPID, (a0), (a1))
a420 2
#define config_detach(dev, flag) device_delete_child(device_get_parent(dev), dev)

d489 7
a495 1
#define SIMPLEQ_REMOVE_HEAD	STAILQ_REMOVE_HEAD
@


1.6.2.9
log
@Merge with the trunk
@
text
@a81 1
#define AXE_DEBUG 1
d253 1
a253 1
#define UCOMBUSCF_PORTNO		0
d255 1
a255 1
#define UHIDBUSCF_REPORTID		0
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usb_port.h,v 1.11 1999/09/11 08:19:27 augustss Exp $	*/
d53 10
d125 10
a135 1
	struct __CONCAT(dname,_softc) *sc; \
d143 1
a143 1
	struct __CONCAT(dname,_softc) *sc = __CONCAT(dname,_cd).cd_devs[unit]
d152 9
a163 2
#define powerhook_establish(h, sc) NULL
#define powerhook_disestablish(sc) /* nothing */
d231 10
a241 1
	struct __CONCAT(dname,_softc) *sc; \
d249 1
a249 1
	struct __CONCAT(dname,_softc) *sc = __CONCAT(dname,_cd).cd_devs[unit]
d261 2
d265 2
a266 2
#define USBDEVNAME(bdev) usbd_devname(bdev)
#define USBDEVPTRNAME(bdev) usbd_devname(bdev)
d272 5
a276 8
#define memset(d, v, s)	\
		do{			\
		if ((v) == 0)		\
			bzero((d), (s));	\
		else			\
			panic("Non zero filler for memset, cannot handle!"); \
		} while (0)

d281 9
a307 1
        DRIVER_TYPE_MISC, \
d313 1
a313 1
__CONCAT(dname,_match)(device_t device)
d316 1
a316 1
        struct usb_attach_arg *uaa = device_get_ivars(device)
d331 9
a339 2
	usbd_device_set_desc(self, devinfo); \
	sc->sc_dev = self
d342 1
a342 2
	struct __CONCAT(dname,_softc) *sc = \
		devclass_get_softc(__CONCAT(dname,_devclass), unit); \
d347 1
a347 2
	struct __CONCAT(dname,_softc) *sc = \
		devclass_get_softc(__CONCAT(dname,_devclass), unit)
d350 1
a350 1
	(device_probe_and_attach((bdev)) == 0 ? ((dev)->softc = (bdev)) : 0)
d353 7
a359 1
#define SIMPLEQ_REMOVE_HEAD	STAILQ_REMOVE_HEAD_UNTIL
d366 1
d369 6
a386 6



#if defined(__NetBSD__) || defined(__OpenBSD__)
#elif defined(__FreeBSD__)
#endif
@


1.4
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usb_port.h,v 1.9 1999/08/17 16:06:21 augustss Exp $	*/
d46 1
a50 1
#if defined(__NetBSD__)
d53 3
d57 1
d59 6
a64 1
typedef struct device bdevice;			/* base device */
d136 2
a137 1
#define powerhook_establish(h, sc) /* nothing */
d143 3
d147 1
d149 6
a154 1
typedef struct device bdevice;			/* base device */
d225 7
a231 6
/* 
 * The following is not a type def to avoid error messages
 * because of includes in the wrong order.
 */
#define bdevice device_t
#define USBDEVNAME(bdev) usbd_devname(&bdev)
d328 5
@


1.3
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb_port.h,v 1.2 1999/08/13 08:26:29 fgsch Exp $	*/
/*	$NetBSD: usb_port.h,v 1.7 1999/06/30 06:44:23 augustss Exp $	*/
d126 2
@


1.2
log
@Display the correct name. Thanks niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb_port.h,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
d60 2
d125 1
a125 1
#define memset(d, v, l)		bzero((d),(l))
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 1
	NULL, _1, DV_DULL \
@

