head	1.77;
access;
symbols
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.75.0.4
	OPENBSD_6_0_BASE:1.75
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.60.0.8
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.6
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.4
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.59.0.2
	OPENBSD_4_9_BASE:1.59
	OPENBSD_4_8:1.52.0.4
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.6
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.19.0.2
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.17
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	SMP:1.8.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.77
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.76;
commitid	VyLWTsbepAOk7VQM;

1.76
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.75;
commitid	xlY19nmD0cBL53l1;

1.75
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.74;
commitid	gWZDkudwxydTq8x4;

1.74
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.73;
commitid	B0kwmVGiD5DVx4kv;

1.73
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.72;
commitid	eYnPulzvLjDImPCa;

1.72
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.71;
commitid	pwYnMC1gOKohmeGw;

1.71
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.70;
commitid	MVWrtktB46JRxFWT;

1.70
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.69;
commitid	aqezguXMYUVIGMPW;

1.69
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.68;
commitid	p4LJxGKbi0BU2cG6;

1.68
date	2015.02.04.05.12.13;	author mpi;	state Exp;
branches;
next	1.67;
commitid	kJMgw6D3PQCR1sKa;

1.67
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.66;
commitid	yM2VFFhpDTeFQlve;

1.66
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.65;
commitid	Pclvgy2Z4XV9hveD;

1.65
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.64;
commitid	b0VSac5dnnsxcDao;

1.64
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.63;

1.63
date	2013.11.05.10.20.04;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.17.13.48.06;	author jasper;	state Exp;
branches;
next	1.57;

1.57
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.24.08.33.58;	author yuo;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.48;

1.48
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.14.06.55.10;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.06.17.56.37;	author mcbride;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.09.16.44.15;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.26.11.29.55;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.06.05.19.20;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.07.08.23.38.08;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.27.06.34.53;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.03.02.20.32;	author aaron;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.02.20.19.39.47;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.25.03.50.52;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.04.11.44.21;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.23.17.33.47;	author maja;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.22.52.30;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.30.16.19.32;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.19.37.47;	author aaron;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.26.18;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.43.41;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2004.06.07.20.41.31;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.77
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_cue.c,v 1.76 2016/11/06 12:58:01 mpi Exp $ */
/*	$NetBSD: if_cue.c,v 1.40 2002/07/11 21:14:26 augustss Exp $	*/
/*
 * Copyright (c) 1997, 1998, 1999, 2000
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/usb/if_cue.c,v 1.4 2000/01/16 22:45:06 wpaul Exp $
 */

/*
 * CATC USB-EL1210A USB to ethernet driver. Used in the CATC Netmate
 * adapters and others.
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The CATC USB-EL1210A provides USB ethernet support at 10Mbps. The
 * RX filter uses a 512-bit multicast hash table, single perfect entry
 * for the station address, and promiscuous mode. Unlike the ADMtek
 * and KLSI chips, the CATC ASIC supports read and write combining
 * mode where multiple packets can be transferred using a single bulk
 * transaction, which helps performance a great deal.
 */

/*
 * Ported to NetBSD and somewhat rewritten by Lennart Augustsson.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <net/if.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_cuereg.h>

#ifdef CUE_DEBUG
#define DPRINTF(x)	do { if (cuedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (cuedebug >= (n)) printf x; } while (0)
int	cuedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
struct usb_devno cue_devs[] = {
	{ USB_VENDOR_CATC, USB_PRODUCT_CATC_NETMATE },
	{ USB_VENDOR_CATC, USB_PRODUCT_CATC_NETMATE2 },
	{ USB_VENDOR_SMARTBRIDGES, USB_PRODUCT_SMARTBRIDGES_SMARTLINK },
	/* Belkin F5U111 adapter covered by NETMATE entry */
};

int cue_match(struct device *, void *, void *);
void cue_attach(struct device *, struct device *, void *);
int cue_detach(struct device *, int);

struct cfdriver cue_cd = {
	NULL, "cue", DV_IFNET
};

const struct cfattach cue_ca = {
	sizeof(struct cue_softc), cue_match, cue_attach, cue_detach
};

int cue_open_pipes(struct cue_softc *);
int cue_tx_list_init(struct cue_softc *);
int cue_rx_list_init(struct cue_softc *);
int cue_newbuf(struct cue_softc *, struct cue_chain *, struct mbuf *);
int cue_send(struct cue_softc *, struct mbuf *, int);
void cue_rxeof(struct usbd_xfer *, void *, usbd_status);
void cue_txeof(struct usbd_xfer *, void *, usbd_status);
void cue_tick(void *);
void cue_tick_task(void *);
void cue_start(struct ifnet *);
int cue_ioctl(struct ifnet *, u_long, caddr_t);
void cue_init(void *);
void cue_stop(struct cue_softc *);
void cue_watchdog(struct ifnet *);

void cue_setmulti(struct cue_softc *);
void cue_reset(struct cue_softc *);

int cue_csr_read_1(struct cue_softc *, int);
int cue_csr_write_1(struct cue_softc *, int, int);
int cue_csr_read_2(struct cue_softc *, int);
#if 0
int cue_csr_write_2(struct cue_softc *, int, int);
#endif
int cue_mem(struct cue_softc *, int, int, void *, int);
int cue_getmac(struct cue_softc *, void *);

#define CUE_SETBIT(sc, reg, x)				\
	cue_csr_write_1(sc, reg, cue_csr_read_1(sc, reg) | (x))

#define CUE_CLRBIT(sc, reg, x)				\
	cue_csr_write_1(sc, reg, cue_csr_read_1(sc, reg) & ~(x))

int
cue_csr_read_1(struct cue_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	u_int8_t		val = 0;

	if (usbd_is_dying(sc->cue_udev))
		return (0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 1);

	err = usbd_do_request(sc->cue_udev, &req, &val);

	if (err) {
		DPRINTF(("%s: cue_csr_read_1: reg=0x%x err=%s\n",
			 sc->cue_dev.dv_xname, reg, usbd_errstr(err)));
		return (0);
	}

	DPRINTFN(10,("%s: cue_csr_read_1 reg=0x%x val=0x%x\n",
		     sc->cue_dev.dv_xname, reg, val));

	return (val);
}

int
cue_csr_read_2(struct cue_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;

	if (usbd_is_dying(sc->cue_udev))
		return (0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->cue_udev, &req, &val);

	DPRINTFN(10,("%s: cue_csr_read_2 reg=0x%x val=0x%x\n",
		     sc->cue_dev.dv_xname, reg, UGETW(val)));

	if (err) {
		DPRINTF(("%s: cue_csr_read_2: reg=0x%x err=%s\n",
			 sc->cue_dev.dv_xname, reg, usbd_errstr(err)));
		return (0);
	}

	return (UGETW(val));
}

int
cue_csr_write_1(struct cue_softc *sc, int reg, int val)
{
	usb_device_request_t	req;
	usbd_status		err;

	if (usbd_is_dying(sc->cue_udev))
		return (0);

	DPRINTFN(10,("%s: cue_csr_write_1 reg=0x%x val=0x%x\n",
		     sc->cue_dev.dv_xname, reg, val));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_WRITEREG;
	USETW(req.wValue, val);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->cue_udev, &req, NULL);

	if (err) {
		DPRINTF(("%s: cue_csr_write_1: reg=0x%x err=%s\n",
			 sc->cue_dev.dv_xname, reg, usbd_errstr(err)));
		return (-1);
	}

	DPRINTFN(20,("%s: cue_csr_write_1, after reg=0x%x val=0x%x\n",
		     sc->cue_dev.dv_xname, reg, cue_csr_read_1(sc, reg)));

	return (0);
}

#if 0
int
cue_csr_write_2(struct cue_softc *sc, int reg, int aval)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;
	int			s;

	if (usbd_is_dying(sc->cue_udev))
		return (0);

	DPRINTFN(10,("%s: cue_csr_write_2 reg=0x%x val=0x%x\n",
		     sc->cue_dev.dv_xname, reg, aval));

	USETW(val, aval);
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_WRITEREG;
	USETW(req.wValue, val);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->cue_udev, &req, NULL);

	if (err) {
		DPRINTF(("%s: cue_csr_write_2: reg=0x%x err=%s\n",
			 sc->cue_dev.dv_xname, reg, usbd_errstr(err)));
		return (-1);
	}

	return (0);
}
#endif

int
cue_mem(struct cue_softc *sc, int cmd, int addr, void *buf, int len)
{
	usb_device_request_t	req;
	usbd_status		err;

	DPRINTFN(10,("%s: cue_mem cmd=0x%x addr=0x%x len=%d\n",
		     sc->cue_dev.dv_xname, cmd, addr, len));

	if (cmd == CUE_CMD_READSRAM)
		req.bmRequestType = UT_READ_VENDOR_DEVICE;
	else
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = cmd;
	USETW(req.wValue, 0);
	USETW(req.wIndex, addr);
	USETW(req.wLength, len);

	err = usbd_do_request(sc->cue_udev, &req, buf);

	if (err) {
		DPRINTF(("%s: cue_csr_mem: addr=0x%x err=%s\n",
			 sc->cue_dev.dv_xname, addr, usbd_errstr(err)));
		return (-1);
	}

	return (0);
}

int
cue_getmac(struct cue_softc *sc, void *buf)
{
	usb_device_request_t	req;
	usbd_status		err;

	DPRINTFN(10,("%s: cue_getmac\n", sc->cue_dev.dv_xname));

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_GET_MACADDR;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, ETHER_ADDR_LEN);

	err = usbd_do_request(sc->cue_udev, &req, buf);

	if (err) {
		printf("%s: read MAC address failed\n",
		       sc->cue_dev.dv_xname);
		return (-1);
	}

	return (0);
}

#define CUE_BITS	9

void
cue_setmulti(struct cue_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		h, i;

	ifp = GET_IFP(sc);

	DPRINTFN(2,("%s: cue_setmulti if_flags=0x%x\n",
		    sc->cue_dev.dv_xname, ifp->if_flags));

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		for (i = 0; i < CUE_MCAST_TABLE_LEN; i++)
			sc->cue_mctab[i] = 0xFF;
		cue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,
		    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);
		return;
	}

	/* first, zot all the existing hash bits */
	for (i = 0; i < CUE_MCAST_TABLE_LEN; i++)
		sc->cue_mctab[i] = 0;

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) &
		    ((1 << CUE_BITS) - 1);
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
		ETHER_NEXT_MULTI(step, enm);
	}

	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Also include the broadcast address in the filter
	 * so we can receive broadcast frames.
	 */
	if (ifp->if_flags & IFF_BROADCAST) {
		h = ether_crc32_le(etherbroadcastaddr, ETHER_ADDR_LEN) &
		    ((1 << CUE_BITS) - 1);
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
	}

	cue_mem(sc, CUE_CMD_WRITESRAM, CUE_MCAST_TABLE_ADDR,
	    &sc->cue_mctab, CUE_MCAST_TABLE_LEN);
}

void
cue_reset(struct cue_softc *sc)
{
	usb_device_request_t	req;
	usbd_status		err;

	DPRINTFN(2,("%s: cue_reset\n", sc->cue_dev.dv_xname));

	if (usbd_is_dying(sc->cue_udev))
		return;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = CUE_CMD_RESET;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->cue_udev, &req, NULL);

	if (err)
		printf("%s: reset failed\n", sc->cue_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	usbd_delay_ms(sc->cue_udev, 1);
}

/*
 * Probe for a CATC chip.
 */
int
cue_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	if (uaa->iface == NULL || uaa->configno != CUE_CONFIG_NO)
		return (UMATCH_NONE);

	return (usb_lookup(cue_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
cue_attach(struct device *parent, struct device *self, void *aux)
{
	struct cue_softc	*sc = (struct cue_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	int			s;
	u_char			eaddr[ETHER_ADDR_LEN];
	struct usbd_device	*dev = uaa->device;
	struct usbd_interface	*iface;
	usbd_status		err;
	struct ifnet		*ifp;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int			i;

	DPRINTFN(5,(" : cue_attach: sc=%p, dev=%p", sc, dev));

	sc->cue_udev = dev;
	sc->cue_product = uaa->product;
	sc->cue_vendor = uaa->vendor;

	usb_init_task(&sc->cue_tick_task, cue_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->cue_stop_task, (void (*)(void *))cue_stop, sc,
	    USB_TASK_TYPE_GENERIC);

	err = usbd_device2interface_handle(dev, CUE_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->cue_dev.dv_xname);
		return;
	}

	sc->cue_iface = iface;
	id = usbd_get_interface_descriptor(iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->cue_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->cue_ed[CUE_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->cue_ed[CUE_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->cue_ed[CUE_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

#if 0
	/* Reset the adapter. */
	cue_reset(sc);
#endif
	/*
	 * Get station address.
	 */
	cue_getmac(sc, &eaddr);

	s = splnet();

	/*
	 * A CATC chip was detected. Inform the world.
	 */
	printf("%s: address %s\n", sc->cue_dev.dv_xname,
	    ether_sprintf(eaddr));

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	/* Initialize interface info.*/
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = cue_ioctl;
	ifp->if_start = cue_start;
	ifp->if_watchdog = cue_watchdog;
	strlcpy(ifp->if_xname, sc->cue_dev.dv_xname, IFNAMSIZ);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->cue_stat_ch, cue_tick, sc);

	splx(s);
}

int
cue_detach(struct device *self, int flags)
{
	struct cue_softc	*sc = (struct cue_softc *)self;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	DPRINTFN(2,("%s: %s: enter\n", sc->cue_dev.dv_xname, __func__));

	if (timeout_initialized(&sc->cue_stat_ch))
		timeout_del(&sc->cue_stat_ch);

	/*
	 * Remove any pending task.  It cannot be executing because it run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->cue_udev, &sc->cue_tick_task);
	usb_rem_task(sc->cue_udev, &sc->cue_stop_task);

	s = splusb();

	if (ifp->if_flags & IFF_RUNNING)
		cue_stop(sc);

	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->cue_ep[CUE_ENDPT_TX] != NULL ||
	    sc->cue_ep[CUE_ENDPT_RX] != NULL ||
	    sc->cue_ep[CUE_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		       sc->cue_dev.dv_xname);
#endif

	splx(s);

	return (0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
cue_newbuf(struct cue_softc *sc, struct cue_chain *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->cue_dev.dv_xname);
			return (ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->cue_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);
	c->cue_mbuf = m_new;

	return (0);
}

int
cue_rx_list_init(struct cue_softc *sc)
{
	struct cue_cdata	*cd;
	struct cue_chain	*c;
	int			i;

	cd = &sc->cue_cdata;
	for (i = 0; i < CUE_RX_LIST_CNT; i++) {
		c = &cd->cue_rx_chain[i];
		c->cue_sc = sc;
		c->cue_idx = i;
		if (cue_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->cue_xfer == NULL) {
			c->cue_xfer = usbd_alloc_xfer(sc->cue_udev);
			if (c->cue_xfer == NULL)
				return (ENOBUFS);
			c->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);
			if (c->cue_buf == NULL) {
				usbd_free_xfer(c->cue_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
cue_tx_list_init(struct cue_softc *sc)
{
	struct cue_cdata	*cd;
	struct cue_chain	*c;
	int			i;

	cd = &sc->cue_cdata;
	for (i = 0; i < CUE_TX_LIST_CNT; i++) {
		c = &cd->cue_tx_chain[i];
		c->cue_sc = sc;
		c->cue_idx = i;
		c->cue_mbuf = NULL;
		if (c->cue_xfer == NULL) {
			c->cue_xfer = usbd_alloc_xfer(sc->cue_udev);
			if (c->cue_xfer == NULL)
				return (ENOBUFS);
			c->cue_buf = usbd_alloc_buffer(c->cue_xfer, CUE_BUFSZ);
			if (c->cue_buf == NULL) {
				usbd_free_xfer(c->cue_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
cue_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct cue_chain	*c = priv;
	struct cue_softc	*sc = c->cue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	int			total_len = 0;
	u_int16_t		len;
	int			s;

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->cue_dev.dv_xname,
		     __func__, status));

	if (usbd_is_dying(sc->cue_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->cue_rx_errs++;
		if (usbd_ratecheck(&sc->cue_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->cue_dev.dv_xname, sc->cue_rx_errs,
			    usbd_errstr(status));
			sc->cue_rx_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cue_ep[CUE_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	memcpy(mtod(c->cue_mbuf, char *), c->cue_buf, total_len);

	m = c->cue_mbuf;
	len = UGETW(mtod(m, u_int8_t *));

	/* No errors; receive the packet. */
	total_len = len;

	if (len < sizeof(struct ether_header)) {
		ifp->if_ierrors++;
		goto done;
	}

	m_adj(m, sizeof(u_int16_t));
	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (cue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

done:
	/* Setup new transfer. */
	usbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],
	    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, cue_rxeof);
	usbd_transfer(c->cue_xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->cue_dev.dv_xname,
		    __func__));
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void
cue_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct cue_chain	*c = priv;
	struct cue_softc	*sc = c->cue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	if (usbd_is_dying(sc->cue_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->cue_dev.dv_xname,
		    __func__, status));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->cue_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cue_ep[CUE_ENDPT_TX]);
		splx(s);
		return;
	}

	m_freem(c->cue_mbuf);
	c->cue_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		cue_start(ifp);

	splx(s);
}

void
cue_tick(void *xsc)
{
	struct cue_softc	*sc = xsc;

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->cue_udev))
		return;

	DPRINTFN(2,("%s: %s: enter\n", sc->cue_dev.dv_xname, __func__));

	/* Perform statistics update in process context. */
	usb_add_task(sc->cue_udev, &sc->cue_tick_task);
}

void
cue_tick_task(void *xsc)
{
	struct cue_softc	*sc = xsc;
	struct ifnet		*ifp;

	if (usbd_is_dying(sc->cue_udev))
		return;

	DPRINTFN(2,("%s: %s: enter\n", sc->cue_dev.dv_xname, __func__));

	ifp = GET_IFP(sc);

	ifp->if_collisions += cue_csr_read_2(sc, CUE_TX_SINGLECOLL);
	ifp->if_collisions += cue_csr_read_2(sc, CUE_TX_MULTICOLL);
	ifp->if_collisions += cue_csr_read_2(sc, CUE_TX_EXCESSCOLL);

	if (cue_csr_read_2(sc, CUE_RX_FRAMEERR))
		ifp->if_ierrors++;
}

int
cue_send(struct cue_softc *sc, struct mbuf *m, int idx)
{
	int			total_len;
	struct cue_chain	*c;
	usbd_status		err;

	c = &sc->cue_cdata.cue_tx_chain[idx];

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving two
	 * bytes at the beginning to hold the frame length.
	 */
	m_copydata(m, 0, m->m_pkthdr.len, c->cue_buf + 2);
	c->cue_mbuf = m;

	total_len = m->m_pkthdr.len + 2;

	DPRINTFN(10,("%s: %s: total_len=%d\n",
		     sc->cue_dev.dv_xname, __func__, total_len));

	/* The first two bytes are the frame length */
	c->cue_buf[0] = (u_int8_t)m->m_pkthdr.len;
	c->cue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);

	/* XXX 10000 */
	usbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_TX],
	    c, c->cue_buf, total_len, USBD_NO_COPY, 10000, cue_txeof);

	/* Transmit */
	err = usbd_transfer(c->cue_xfer);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: cue_send error=%s\n", sc->cue_dev.dv_xname,
		       usbd_errstr(err));
		/* Stop the interface from process context. */
		usb_add_task(sc->cue_udev, &sc->cue_stop_task);
		return (EIO);
	}

	sc->cue_cdata.cue_tx_cnt++;

	return (0);
}

void
cue_start(struct ifnet *ifp)
{
	struct cue_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	if (usbd_is_dying(sc->cue_udev))
		return;

	DPRINTFN(10,("%s: %s: enter\n", sc->cue_dev.dv_xname,__func__));

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (cue_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
cue_init(void *xsc)
{
	struct cue_softc	*sc = xsc;
	struct ifnet		*ifp = GET_IFP(sc);
	int			i, s, ctl;
	u_char			*eaddr;

	if (usbd_is_dying(sc->cue_udev))
		return;

	DPRINTFN(10,("%s: %s: enter\n", sc->cue_dev.dv_xname,__func__));

	if (ifp->if_flags & IFF_RUNNING)
		return;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
#if 1
	cue_reset(sc);
#endif

	/* Set advanced operation modes. */
	cue_csr_write_1(sc, CUE_ADVANCED_OPMODES,
	    CUE_AOP_EMBED_RXLEN | 0x03); /* 1 wait state */

	eaddr = sc->arpcom.ac_enaddr;
	/* Set MAC address */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		cue_csr_write_1(sc, CUE_PAR0 - i, eaddr[i]);

	/* Enable RX logic. */
	ctl = CUE_ETHCTL_RX_ON | CUE_ETHCTL_MCAST_ON;
	if (ifp->if_flags & IFF_PROMISC)
		ctl |= CUE_ETHCTL_PROMISC;
	cue_csr_write_1(sc, CUE_ETHCTL, ctl);

	/* Init TX ring. */
	if (cue_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->cue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init RX ring. */
	if (cue_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->cue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Load the multicast filter. */
	cue_setmulti(sc);

	/*
	 * Set the number of RX and TX buffers that we want
	 * to reserve inside the ASIC.
	 */
	cue_csr_write_1(sc, CUE_RX_BUFPKTS, CUE_RX_FRAMES);
	cue_csr_write_1(sc, CUE_TX_BUFPKTS, CUE_TX_FRAMES);

	/* Set advanced operation modes. */
	cue_csr_write_1(sc, CUE_ADVANCED_OPMODES,
	    CUE_AOP_EMBED_RXLEN | 0x01); /* 1 wait state */

	/* Program the LED operation. */
	cue_csr_write_1(sc, CUE_LEDCTL, CUE_LEDCTL_FOLLOW_LINK);

	if (sc->cue_ep[CUE_ENDPT_RX] == NULL) {
		if (cue_open_pipes(sc)) {
			splx(s);
			return;
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->cue_stat_ch, 1);
}

int
cue_open_pipes(struct cue_softc *sc)
{
	struct cue_chain	*c;
	usbd_status		err;
	int			i;

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->cue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}
	err = usbd_open_pipe(sc->cue_iface, sc->cue_ed[CUE_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->cue_ep[CUE_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->cue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}

	/* Start up the receive pipe. */
	for (i = 0; i < CUE_RX_LIST_CNT; i++) {
		c = &sc->cue_cdata.cue_rx_chain[i];
		usbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],
		    c, c->cue_buf, CUE_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		    cue_rxeof);
		usbd_transfer(c->cue_xfer);
	}

	return (0);
}

int
cue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct cue_softc	*sc = ifp->if_softc;
	int			s, error = 0;

	if (usbd_is_dying(sc->cue_udev))
		return (EIO);

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		cue_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->cue_if_flags & IFF_PROMISC)) {
				CUE_SETBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);
				cue_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->cue_if_flags & IFF_PROMISC) {
				CUE_CLRBIT(sc, CUE_ETHCTL, CUE_ETHCTL_PROMISC);
				cue_setmulti(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
				cue_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cue_stop(sc);
		}
		sc->cue_if_flags = ifp->if_flags;
		error = 0;
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			cue_setmulti(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
cue_watchdog(struct ifnet *ifp)
{
	struct cue_softc	*sc = ifp->if_softc;
	struct cue_chain	*c;
	usbd_status		stat;
	int			s;

	DPRINTFN(5,("%s: %s: enter\n", sc->cue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->cue_udev))
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->cue_dev.dv_xname);

	s = splusb();
	c = &sc->cue_cdata.cue_tx_chain[0];
	usbd_get_xfer_status(c->cue_xfer, NULL, NULL, NULL, &stat);
	cue_txeof(c->cue_xfer, c, stat);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		cue_start(ifp);
	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
cue_stop(struct cue_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	DPRINTFN(10,("%s: %s: enter\n", sc->cue_dev.dv_xname,__func__));

	ifp = GET_IFP(sc);
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	cue_csr_write_1(sc, CUE_ETHCTL, 0);
	cue_reset(sc);
	timeout_del(&sc->cue_stat_ch);

	/* Stop transfers. */
	if (sc->cue_ep[CUE_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);
		err = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			sc->cue_dev.dv_xname, usbd_errstr(err));
		}
		sc->cue_ep[CUE_ENDPT_RX] = NULL;
	}

	if (sc->cue_ep[CUE_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);
		err = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->cue_dev.dv_xname, usbd_errstr(err));
		}
		sc->cue_ep[CUE_ENDPT_TX] = NULL;
	}

	if (sc->cue_ep[CUE_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);
		err = usbd_close_pipe(sc->cue_ep[CUE_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->cue_dev.dv_xname, usbd_errstr(err));
		}
		sc->cue_ep[CUE_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < CUE_RX_LIST_CNT; i++) {
		if (sc->cue_cdata.cue_rx_chain[i].cue_mbuf != NULL) {
			m_freem(sc->cue_cdata.cue_rx_chain[i].cue_mbuf);
			sc->cue_cdata.cue_rx_chain[i].cue_mbuf = NULL;
		}
		if (sc->cue_cdata.cue_rx_chain[i].cue_xfer != NULL) {
			usbd_free_xfer(sc->cue_cdata.cue_rx_chain[i].cue_xfer);
			sc->cue_cdata.cue_rx_chain[i].cue_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < CUE_TX_LIST_CNT; i++) {
		if (sc->cue_cdata.cue_tx_chain[i].cue_mbuf != NULL) {
			m_freem(sc->cue_cdata.cue_tx_chain[i].cue_mbuf);
			sc->cue_cdata.cue_tx_chain[i].cue_mbuf = NULL;
		}
		if (sc->cue_cdata.cue_tx_chain[i].cue_xfer != NULL) {
			usbd_free_xfer(sc->cue_cdata.cue_tx_chain[i].cue_xfer);
			sc->cue_cdata.cue_tx_chain[i].cue_xfer = NULL;
		}
	}
}
@


1.76
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.75 2016/04/13 11:03:37 mpi Exp $ */
a771 2

	ifp->if_opackets++;
@


1.75
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.74 2015/11/25 03:10:00 dlg Exp $ */
d418 1
a418 1
	if (uaa->iface != NULL)
a446 8

	err = usbd_set_config_no(dev, CUE_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->cue_dev.dv_xname);
		return;
	}

@


1.74
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.73 2015/11/20 03:35:23 dlg Exp $ */
a519 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.73
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.72 2015/10/25 12:11:56 mpi Exp $ */
d767 1
a767 1
	ifp->if_flags &= ~IFF_OACTIVE;
d887 1
a887 1
	if (ifp->if_flags & IFF_OACTIVE)
d896 1
a896 1
		ifp->if_flags |= IFF_OACTIVE;
d911 1
a911 1
	ifp->if_flags |= IFF_OACTIVE;
d998 1
a998 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1135 2
a1136 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.72
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.71 2015/06/24 09:40:54 mpi Exp $ */
d890 1
a890 1
	IFQ_POLL(&ifp->if_snd, m_head);
d895 1
d900 1
a900 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.71
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.70 2015/04/10 08:41:43 mpi Exp $ */
a1043 1
	struct ifaddr 		*ifa = (struct ifaddr *)data;
a1054 6

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&sc->arpcom, ifa);
			break;
		}
@


1.70
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.69 2015/03/14 03:38:49 jsg Exp $ */
a721 1
	ifp->if_ipackets++;
@


1.69
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.68 2015/02/04 05:12:13 mpi Exp $ */
d677 1
d725 1
a726 5
	m->m_pkthdr.rcvif = ifp;

	s = splnet();

	/* XXX ugly */
d729 1
a729 1
		goto done1;
d732 2
a733 9
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	DPRINTFN(10,("%s: %s: deliver %d\n", sc->cue_dev.dv_xname,
		    __func__, m->m_len));
	ether_input_mbuf(ifp, m);
 done1:
@


1.68
log
@Kill annoying comments about ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.67 2014/12/22 02:28:52 tedu Exp $ */
a70 1
#include <net/if_dl.h>
@


1.67
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.66 2014/07/13 15:52:49 mpi Exp $ */
a736 6
	/*
	 * Handle BPF listeners. Let the BPF user see the packet, but
	 * don't pass it up to the ether_input() layer unless it's
	 * a broadcast packet, multicast packet, matches our ethernet
	 * address or the interface is in promiscuous mode.
	 */
@


1.66
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.65 2014/07/12 07:59:23 mpi Exp $ */
a1075 1
#ifdef INET
a1078 1
#endif /* INET */
@


1.65
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.64 2013/11/15 10:17:39 pirofti Exp $ */
a76 1
#ifdef INET
a77 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a78 1
#endif
@


1.64
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.63 2013/11/05 10:20:04 mpi Exp $ */
d110 10
a119 15
int cue_match(struct device *, void *, void *); 
void cue_attach(struct device *, struct device *, void *); 
int cue_detach(struct device *, int); 
int cue_activate(struct device *, int); 

struct cfdriver cue_cd = { 
	NULL, "cue", DV_IFNET 
}; 

const struct cfattach cue_ca = { 
	sizeof(struct cue_softc), 
	cue_match, 
	cue_attach, 
	cue_detach, 
	cue_activate, 
a575 15
	return (0);
}

int
cue_activate(struct device *self, int act)
{
	struct cue_softc *sc = (struct cue_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->cue_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->cue_udev);
		break;
	}
@


1.63
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.62 2013/08/07 01:06:41 bluhm Exp $ */
d1193 1
a1193 5
		err = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			sc->cue_dev.dv_xname, usbd_errstr(err));
		}
d1203 1
a1203 5
		err = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			sc->cue_dev.dv_xname, usbd_errstr(err));
		}
d1213 1
a1213 5
		err = usbd_abort_pipe(sc->cue_ep[CUE_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			sc->cue_dev.dv_xname, usbd_errstr(err));
		}
@


1.62
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.61 2013/04/15 09:23:01 mglocker Exp $ */
d345 1
d356 1
a356 2
	if (ifp->if_flags & IFF_PROMISC) {
allmulti:
d370 1
a370 1
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
a371 4
		if (memcmp(enm->enm_addrlo,
		    enm->enm_addrhi, ETHER_ADDR_LEN) != 0)
			goto allmulti;

@


1.61
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.60 2011/07/03 15:47:17 matthew Exp $ */
a79 1
#include <netinet/in_var.h>
@


1.60
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.59 2011/01/25 20:03:35 jakemsr Exp $ */
d133 2
a134 2
void cue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void cue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d451 2
a452 2
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
d702 1
a702 1
cue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d798 1
a798 1
cue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.59
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.58 2010/12/17 13:48:06 jasper Exp $ */
a596 3
	case DVACT_ACTIVATE:
		break;

@


1.58
log
@- use usb_lookup() instead of handrolled macro.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.57 2010/12/06 04:41:39 jakemsr Exp $ */
a544 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->cue_udev,
	    &sc->cue_dev);
a584 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->cue_udev,
	    &sc->cue_dev);
@


1.57
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.56 2010/10/27 17:51:11 jakemsr Exp $ */
a109 1
#define cue_lookup(v, p) (usb_lookup(cue_devs, v, p))
d436 2
a437 2
	return (cue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.56
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.55 2010/10/23 16:14:07 jakemsr Exp $ */
d169 1
a169 1
	if (sc->cue_dying)
d199 1
a199 1
	if (sc->cue_dying)
d228 1
a228 1
	if (sc->cue_dying)
d263 1
a263 1
	if (sc->cue_dying)
d408 1
a408 1
	if (sc->cue_dying)
d462 2
a470 1
	sc->cue_udev = dev;
a544 1
	sc->cue_attached = 1;
a559 4
	/* Detached before attached finished, so just bail out. */
	if (!sc->cue_attached)
		return (0);

a587 1
	sc->cue_attached = 0;
d608 1
a608 1
		sc->cue_dying = 1;
d725 1
a725 1
	if (sc->cue_dying)
d815 1
a815 1
	if (sc->cue_dying)
d859 1
a859 1
	if (sc->cue_dying)
d874 1
a874 1
	if (sc->cue_dying)
d939 1
a939 1
	if (sc->cue_dying)
d983 1
a983 1
	if (sc->cue_dying)
d1104 1
a1104 1
	if (sc->cue_dying)
d1169 1
a1169 1
	if (sc->cue_dying)
@


1.55
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.54 2010/10/23 15:42:09 jakemsr Exp $ */
d579 4
a582 3
	ether_ifdetach(ifp);

	if_detach(ifp);
@


1.54
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.53 2010/09/24 08:33:58 yuo Exp $ */
d564 2
a565 1
	timeout_del(&sc->cue_stat_ch);
@


1.53
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.52 2009/10/13 19:33:17 pirofti Exp $ */
d473 4
a476 2
	usb_init_task(&sc->cue_tick_task, cue_tick_task, sc);
	usb_init_task(&sc->cue_stop_task, (void (*)(void *))cue_stop, sc);
@


1.52
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.51 2008/11/28 02:44:18 brad Exp $ */
d558 4
d563 1
a569 5

	if (!sc->cue_attached) {
		/* Detached before attached finished, so just bail out. */
		return (0);
	}
@


1.51
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.50 2008/10/02 20:21:14 brad Exp $ */
d115 1
a115 1
int cue_activate(struct device *, enum devact); 
d598 1
a598 1
cue_activate(struct device *self, enum devact act)
@


1.50
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.49 2008/09/10 14:01:23 blambert Exp $ */
a1102 1
	struct ifreq		*ifr = (struct ifreq *)data;
a1123 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

d1145 1
a1145 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				cue_setmulti(sc);
			error = 0;
		}
		break;
d1148 6
@


1.49
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.48 2007/11/23 15:43:02 mbalmer Exp $ */
d1170 1
a1170 2
		error = EINVAL;
		break;
a1173 1

@


1.48
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.47 2007/10/11 18:33:14 deraadt Exp $ */
d1059 1
a1059 1
	timeout_add(&sc->cue_stat_ch, hz);
@


1.47
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.46 2007/09/17 01:40:38 fgsch Exp $ */
d540 1
a540 1
	timeout_set(&sc->cue_stat_ch, NULL, NULL);
a1058 2
	timeout_del(&sc->cue_stat_ch);
	timeout_set(&sc->cue_stat_ch, cue_tick, sc);
@


1.46
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.45 2007/06/14 10:11:15 mbalmer Exp $ */
a449 1
	char			*devinfop;
a460 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->cue_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.45
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.44 2007/06/14 06:55:10 mbalmer Exp $ */
a64 1
#include <sys/malloc.h>
@


1.44
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.43 2007/06/13 11:15:29 mbalmer Exp $ */
d113 16
a128 1
USB_DECLARE_DRIVER_CLASS(cue, DV_IFNET);
@


1.43
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.42 2007/06/12 16:26:36 mbalmer Exp $ */
d68 1
a68 1

@


1.42
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.41 2007/06/10 14:49:00 mbalmer Exp $ */
d780 1
a780 1
	IF_INPUT(ifp, m);
@


1.41
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.40 2007/06/10 10:53:48 mbalmer Exp $ */
d589 1
a589 1
cue_activate(device_ptr_t self, enum devact act)
@


1.40
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.39 2007/06/10 10:15:35 mbalmer Exp $ */
d168 1
a168 1
			 USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));
d173 1
a173 1
		     USBDEVNAME(sc->cue_dev), reg, val));
d197 1
a197 1
		     USBDEVNAME(sc->cue_dev), reg, UGETW(val)));
d201 1
a201 1
			 USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));
d218 1
a218 1
		     USBDEVNAME(sc->cue_dev), reg, val));
d230 1
a230 1
			 USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));
d235 1
a235 1
		     USBDEVNAME(sc->cue_dev), reg, cue_csr_read_1(sc, reg)));
d253 1
a253 1
		     USBDEVNAME(sc->cue_dev), reg, aval));
d266 1
a266 1
			 USBDEVNAME(sc->cue_dev), reg, usbd_errstr(err)));
d281 1
a281 1
		     USBDEVNAME(sc->cue_dev), cmd, addr, len));
d296 1
a296 1
			 USBDEVNAME(sc->cue_dev), addr, usbd_errstr(err)));
d309 1
a309 1
	DPRINTFN(10,("%s: cue_getmac\n", USBDEVNAME(sc->cue_dev)));
d321 1
a321 1
		       USBDEVNAME(sc->cue_dev));
d341 1
a341 1
		    USBDEVNAME(sc->cue_dev), ifp->if_flags));
d392 1
a392 1
	DPRINTFN(2,("%s: cue_reset\n", USBDEVNAME(sc->cue_dev)));
d406 1
a406 1
		printf("%s: reset failed\n", USBDEVNAME(sc->cue_dev));
d450 1
a450 1
	printf("\n%s: %s\n", USBDEVNAME(sc->cue_dev), devinfop);
d456 1
a456 1
		    USBDEVNAME(sc->cue_dev));
d470 1
a470 1
		    USBDEVNAME(sc->cue_dev));
d482 1
a482 1
			    USBDEVNAME(sc->cue_dev), i);
d511 1
a511 1
	printf("%s: address %s\n", USBDEVNAME(sc->cue_dev),
d523 1
a523 1
	strlcpy(ifp->if_xname, USBDEVNAME(sc->cue_dev), IFNAMSIZ);
d547 1
a547 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d576 1
a576 1
		       USBDEVNAME(sc->cue_dev));
d593 1
a593 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d618 1
a618 1
			    "-- packet dropped!\n", USBDEVNAME(sc->cue_dev));
d625 1
a625 1
			    "-- packet dropped!\n", USBDEVNAME(sc->cue_dev));
d714 1
a714 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->cue_dev),
d729 1
a729 1
			    USBDEVNAME(sc->cue_dev), sc->cue_rx_errs,
d778 1
a778 1
	DPRINTFN(10,("%s: %s: deliver %d\n", USBDEVNAME(sc->cue_dev),
d791 1
a791 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->cue_dev),
d812 1
a812 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->cue_dev),
d824 1
a824 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->cue_dev),
d854 1
a854 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d869 1
a869 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d900 1
a900 1
		     USBDEVNAME(sc->cue_dev), __func__, total_len));
d913 1
a913 1
		printf("%s: cue_send error=%s\n", USBDEVNAME(sc->cue_dev),
d934 1
a934 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d978 1
a978 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1009 1
a1009 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->cue_dev));
d1016 1
a1016 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->cue_dev));
d1067 1
a1067 1
		    USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1074 1
a1074 1
		    USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1180 1
a1180 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1186 1
a1186 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->cue_dev));
d1209 1
a1209 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1224 1
a1224 1
			USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1229 1
a1229 1
			USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1238 1
a1238 1
			USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1243 1
a1243 1
			    USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1252 1
a1252 1
			USBDEVNAME(sc->cue_dev), usbd_errstr(err));
d1257 1
a1257 1
			    USBDEVNAME(sc->cue_dev), usbd_errstr(err));
@


1.39
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.38 2007/06/09 12:22:53 mbalmer Exp $ */
d537 1
a537 1
	    USBDEV(sc->cue_dev));
d583 1
a583 1
	    USBDEV(sc->cue_dev));
@


1.38
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.37 2007/06/05 08:43:55 mbalmer Exp $ */
d531 1
a531 1
	usb_callout_init(sc->cue_stat_ch);
d549 1
a549 1
	usb_uncallout(sc->cue_stat_ch, cue_tick, sc);
d1050 3
a1052 1
	usb_callout(sc->cue_stat_ch, hz, cue_tick, sc);
d1217 1
a1217 1
	usb_uncallout(sc->cue_stat_ch, cue_tick, sc);
@


1.37
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.36 2007/06/04 10:34:04 mbalmer Exp $ */
a599 2
		/* Deactivate the interface. */
		if_deactivate(&sc->cue_ec.ec_if);
@


1.36
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.35 2007/05/27 04:00:24 jsg Exp $ */
d105 1
a105 1
Static struct usb_devno cue_devs[] = {
d115 21
a135 21
Static int cue_open_pipes(struct cue_softc *);
Static int cue_tx_list_init(struct cue_softc *);
Static int cue_rx_list_init(struct cue_softc *);
Static int cue_newbuf(struct cue_softc *, struct cue_chain *, struct mbuf *);
Static int cue_send(struct cue_softc *, struct mbuf *, int);
Static void cue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void cue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void cue_tick(void *);
Static void cue_tick_task(void *);
Static void cue_start(struct ifnet *);
Static int cue_ioctl(struct ifnet *, u_long, caddr_t);
Static void cue_init(void *);
Static void cue_stop(struct cue_softc *);
Static void cue_watchdog(struct ifnet *);

Static void cue_setmulti(struct cue_softc *);
Static void cue_reset(struct cue_softc *);

Static int cue_csr_read_1(struct cue_softc *, int);
Static int cue_csr_write_1(struct cue_softc *, int, int);
Static int cue_csr_read_2(struct cue_softc *, int);
d137 1
a137 1
Static int cue_csr_write_2(struct cue_softc *, int, int);
d139 2
a140 2
Static int cue_mem(struct cue_softc *, int, int, void *, int);
Static int cue_getmac(struct cue_softc *, void *);
d148 1
a148 1
Static int
d178 1
a178 1
Static int
d208 1
a208 1
Static int
d241 1
a241 1
Static int
d274 1
a274 1
Static int
d303 1
a303 1
Static int
d330 1
a330 1
Static void
d386 1
a386 1
Static void
d611 1
a611 1
Static int
d644 1
a644 1
Static int
d673 1
a673 1
Static int
d705 1
a705 1
Static void
d801 1
a801 1
Static void
d845 1
a845 1
Static void
d862 1
a862 1
Static void
d883 1
a883 1
Static int
d927 1
a927 1
Static void
d969 1
a969 1
Static void
d1055 1
a1055 1
Static int
d1091 1
a1091 1
Static int
d1172 1
a1172 1
Static void
d1202 1
a1202 1
Static void
@


1.35
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.34 2007/05/21 05:40:27 jsg Exp $ */
a62 3
#if !defined(__OpenBSD__)
#include <sys/callout.h>
#endif
a71 3
#if defined(__NetBSD__)
#include <net/if_arp.h>
#endif
a77 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined(__NetBSD__) */

#if defined(__OpenBSD__)
a84 1
#endif /* defined(__OpenBSD__) */
a357 3
#if defined(__NetBSD__)
	ETHER_FIRST_MULTI(step, &sc->cue_ec, enm);
#else
a358 1
#endif
a513 1
#if defined(__OpenBSD__)
a514 1
#endif
a997 1
#if defined(__OpenBSD__)
a998 3
#elif defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
#endif
a1111 3
#if defined(__NetBSD__)
			arp_ifinit(ifp, ifa);
#else
a1112 1
#endif
@


1.34
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.33 2007/05/21 05:18:56 jsg Exp $ */
d435 2
a436 1
USB_MATCH(cue)
d438 1
a438 1
	USB_MATCH_START(cue, uaa);
d451 2
a452 1
USB_ATTACH(cue)
d454 2
a455 1
	USB_ATTACH_START(cue, sc, uaa);
d470 1
a470 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->cue_dev), devinfop);
d477 1
a477 1
		USB_ATTACH_ERROR_RETURN;
d491 1
a491 1
		USB_ATTACH_ERROR_RETURN;
d503 1
a503 1
			USB_ATTACH_ERROR_RETURN;
a559 2

	USB_ATTACH_SUCCESS_RETURN;
d562 2
a563 1
USB_DETACH(cue)
d565 1
a565 1
	USB_DETACH_START(cue, sc);
@


1.33
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.32 2007/02/11 20:29:22 miod Exp $ */
d110 2
a111 2
#define DPRINTF(x)	do { if (cuedebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (cuedebug >= (n)) logprintf x; } while (0)
@


1.32
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.31 2006/06/23 06:27:11 miod Exp $ */
d549 1
a549 1
	Ether_ifattach(ifp, eaddr);
@


1.31
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.30 2006/03/25 22:41:47 djm Exp $ */
a58 3
#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
a59 4
#include "rnd.h"
#elif defined(__OpenBSD__)
#include "bpfilter.h"
#endif /* defined(__OpenBSD__) */
@


1.30
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.29 2006/03/07 04:41:19 krw Exp $ */
a624 1
		return (EOPNOTSUPP);
@


1.29
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.28 2006/01/29 03:22:52 brad Exp $ */
a86 2
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))

d806 1
a806 1
		BPF_MTAP(ifp, m);
d987 1
a987 1
		BPF_MTAP(ifp, m_head);
@


1.28
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.27 2005/08/01 05:36:48 brad Exp $ */
a79 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a558 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, USBDEVNAME(sc->cue_dev),
	    RND_TYPE_NET, 0);
#endif
a596 5
#if defined(__NetBSD__)
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
#endif /* __NetBSD__ */
@


1.27
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.26 2005/07/02 22:21:12 brad Exp $ */
d779 1
a779 1
			usbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_RX]);
d872 1
a872 1
			usbd_clear_endpoint_stall(sc->cue_ep[CUE_ENDPT_TX]);
@


1.26
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.25 2005/06/08 17:03:02 henning Exp $ */
d465 1
a465 1
	char			devinfo[1024];
d478 1
a478 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d480 2
a481 1
	printf("%s: %s\n", USBDEVNAME(sc->cue_dev), devinfo);
@


1.25
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.24 2005/01/03 22:45:52 brad Exp $ */
d1263 1
a1334 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.24
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.23 2004/11/10 10:14:48 grange Exp $ */
a113 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1164 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.23
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.22 2004/09/23 17:45:17 brad Exp $ */
d1221 1
d1227 2
a1228 1
			cue_setmulti(sc);
@


1.22
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.21 2004/07/08 22:18:44 deraadt Exp $ */
d559 1
a559 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->cue_dev), IFNAMSIZ);
@


1.21
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.20 2004/06/06 17:56:37 mcbride Exp $ */
a554 1
	ifp->if_mtu = ETHERMTU;
@


1.20
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.19 2003/12/15 23:36:14 cedric Exp $ */
d127 2
a128 2
#define DPRINTF(x)	if (cuedebug) logprintf x
#define DPRINTFN(n,x)	if (cuedebug >= (n)) logprintf x
@


1.19
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.18 2003/05/07 04:33:33 deraadt Exp $ */
a163 1
Static u_int32_t cue_crc(caddr_t);
a360 1
#define CUE_POLY	0xEDB88320
a362 16
Static u_int32_t
cue_crc(caddr_t addr)
{
	u_int32_t		idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? CUE_POLY : 0);
	}

	return (crc & ((1 << CUE_BITS) - 1));
}

d401 2
a402 1
		h = cue_crc(enm->enm_addrlo);
d414 2
a415 1
		h = cue_crc(etherbroadcastaddr);
d1219 11
a1229 2
		cue_setmulti(sc);
		error = 0;
@


1.18
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.17 2002/07/25 04:07:32 nate Exp $ */
d146 1
a146 1
USB_DECLARE_DRIVER(cue);
@


1.17
log
@update $NetBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.16 2002/07/25 02:18:10 nate Exp $ */
d499 1
a499 1
	usbd_devinfo(dev, 0, devinfo);
@


1.16
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.15 2002/07/10 18:08:13 deraadt Exp $ */
/*	$NetBSD: if_cue.c,v 1.39 2002/07/08 17:46:24 augustss Exp $	*/
@


1.15
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.14 2002/07/09 16:44:15 nate Exp $ */
d99 1
a99 1
#include <netinet/in.h> 
d206 1
a206 1
	DPRINTFN(10,("%s: cue_csr_read_1 reg=0x%x val=0x%x\n", 
d230 1
a230 1
	DPRINTFN(10,("%s: cue_csr_read_2 reg=0x%x val=0x%x\n", 
d251 1
a251 1
	DPRINTFN(10,("%s: cue_csr_write_1 reg=0x%x val=0x%x\n", 
d268 1
a268 1
	DPRINTFN(20,("%s: cue_csr_write_1, after reg=0x%x val=0x%x\n", 
d286 1
a286 1
	DPRINTFN(10,("%s: cue_csr_write_2 reg=0x%x val=0x%x\n", 
d391 1
a391 1
	DPRINTFN(2,("%s: cue_setmulti if_flags=0x%x\n", 
d420 1
a420 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);		
d432 1
a432 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);		
@


1.14
log
@Sync Id string with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.13 2002/06/26 11:29:55 espie Exp $ */
d561 1
a561 1
	printf("%s: Ethernet address %s\n", USBDEVNAME(sc->cue_dev),
@


1.13
log
@Kill __FUNCTION__.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.12 2002/05/06 05:19:20 nate Exp $ */
/*	$NetBSD: if_cue.c,v 1.38 2001/12/12 15:36:08 augustss Exp $	*/
@


1.12
log
@Sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.11 2001/10/31 04:24:44 nate Exp $ */
d605 1
a605 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __FUNCTION__));
d656 1
a656 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __FUNCTION__));
d781 1
a781 1
		     __FUNCTION__, status));
d845 1
a845 1
		    __FUNCTION__, m->m_len));
d858 1
a858 1
		    __FUNCTION__));
d879 1
a879 1
		    __FUNCTION__, status));
d920 1
a920 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __FUNCTION__));
d935 1
a935 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __FUNCTION__));
d966 1
a966 1
		     USBDEVNAME(sc->cue_dev), __FUNCTION__, total_len));
d1000 1
a1000 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__FUNCTION__));
d1044 1
a1044 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__FUNCTION__));
d1256 1
a1256 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__FUNCTION__));
d1285 1
a1285 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__FUNCTION__));
@


1.11
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.10 2001/07/08 23:38:08 fgsch Exp $ */
/*	$NetBSD: if_cue.c,v 1.35 2001/04/13 23:30:09 thorpej Exp $	*/
d138 1
a138 1
Static struct cue_type cue_devs[] = {
a142 1
	{ 0, 0 }
d144 1
a470 1
	struct cue_type			*t;
d475 2
a476 5
	for (t = cue_devs; t->cue_vid != 0; t++)
		if (uaa->vendor == t->cue_vid && uaa->product == t->cue_did)
			return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
a628 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
d1066 1
a1066 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_cue.c,v 1.38 2001/12/12 15:36:08 augustss Exp $	*/
d138 1
a138 1
Static struct usb_devno cue_devs[] = {
d143 1
a144 1
#define cue_lookup(v, p) (usb_lookup(cue_devs, v, p))
d471 1
d476 5
a480 2
	return (cue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d633 3
d1073 1
a1073 1
#endif
@


1.11.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: if_cue.c,v 1.40 2002/07/11 21:14:26 augustss Exp $	*/
d99 1
a99 1
#include <netinet/in.h>
d206 1
a206 1
	DPRINTFN(10,("%s: cue_csr_read_1 reg=0x%x val=0x%x\n",
d230 1
a230 1
	DPRINTFN(10,("%s: cue_csr_read_2 reg=0x%x val=0x%x\n",
d251 1
a251 1
	DPRINTFN(10,("%s: cue_csr_write_1 reg=0x%x val=0x%x\n",
d268 1
a268 1
	DPRINTFN(20,("%s: cue_csr_write_1, after reg=0x%x val=0x%x\n",
d286 1
a286 1
	DPRINTFN(10,("%s: cue_csr_write_2 reg=0x%x val=0x%x\n",
d391 1
a391 1
	DPRINTFN(2,("%s: cue_setmulti if_flags=0x%x\n",
d420 1
a420 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
d432 1
a432 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
d561 1
a561 1
	printf("%s: address %s\n", USBDEVNAME(sc->cue_dev),
d605 1
a605 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d656 1
a656 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d781 1
a781 1
		     __func__, status));
d845 1
a845 1
		    __func__, m->m_len));
d858 1
a858 1
		    __func__));
d879 1
a879 1
		    __func__, status));
d920 1
a920 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d935 1
a935 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d966 1
a966 1
		     USBDEVNAME(sc->cue_dev), __func__, total_len));
d1000 1
a1000 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1044 1
a1044 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1256 1
a1256 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1285 1
a1285 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
@


1.11.2.3
log
@sync
@
text
@d499 1
a499 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.10
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.9 2001/06/27 06:34:53 kjc Exp $ */
/*	$NetBSD: if_cue.c,v 1.34 2001/04/12 23:54:56 augustss Exp $	*/
d580 2
a582 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->cue_dev), IFNAMSIZ);
@


1.9
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.8 2001/05/03 02:20:32 aaron Exp $ */
a579 3
#if defined(__OpenBSD__)
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
#endif
@


1.8
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.7 2001/02/20 19:39:47 mickey Exp $ */
d581 1
a581 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d583 1
d912 1
a912 1
	if (ifp->if_snd.ifq_head != NULL)
d1014 1
a1014 1
	IF_DEQUEUE(&ifp->if_snd, m_head);
a1018 1
		IF_PREPEND(&ifp->if_snd, m_head);
d1023 2
d1278 1
a1278 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: if_cue.c,v 1.21 2000/04/02 21:25:41 augustss Exp $	*/
a58 4
/*
 * TODO:
 * proper cleanup on errors
 */
a78 8
#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a83 2
#endif

d85 1
a85 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a89 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a90 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d92 1
a92 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a113 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a117 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a123 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d148 27
a174 66
Static int cue_open_pipes	__P((struct cue_softc *));
Static int cue_tx_list_init	__P((struct cue_softc *));
Static int cue_rx_list_init	__P((struct cue_softc *));
Static int cue_newbuf		__P((struct cue_softc *, struct cue_chain *,
				    struct mbuf *));
Static int cue_send		__P((struct cue_softc *, struct mbuf *, int));
Static void cue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void cue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void cue_tick		__P((void *));
Static void cue_start		__P((struct ifnet *));
Static int cue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void cue_init		__P((void *));
Static void cue_stop		__P((struct cue_softc *));
Static void cue_watchdog		__P((struct ifnet *));

Static void cue_setmulti	__P((struct cue_softc *));
Static u_int32_t cue_crc	__P((caddr_t));
Static void cue_reset		__P((struct cue_softc *));

Static int cue_csr_read_1	__P((struct cue_softc *, int));
Static int cue_csr_write_1	__P((struct cue_softc *, int, int));
Static int cue_csr_read_2	__P((struct cue_softc *, int));
#ifdef notdef
Static int cue_csr_write_2	__P((struct cue_softc *, int, int));
#endif
Static int cue_mem		__P((struct cue_softc *, int,
				    int, void *, int));
Static int cue_getmac		__P((struct cue_softc *, void *));

#ifdef __FreeBSD__
#ifndef lint
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_cue.c,v 1.4 2000/01/16 22:45:06 wpaul Exp $";
#endif

Static void cue_rxstart		__P((struct ifnet *));
Static void cue_shutdown	__P((device_t));

Static struct usb_qdat cue_qdat;

Static device_method_t cue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		cue_match),
	DEVMETHOD(device_attach,	cue_attach),
	DEVMETHOD(device_detach,	cue_detach),
	DEVMETHOD(device_shutdown,	cue_shutdown),

	{ 0, 0 }
};

Static driver_t cue_driver = {
	"cue",
	cue_methods,
	sizeof(struct cue_softc)
};

Static devclass_t cue_devclass;

DRIVER_MODULE(if_cue, uhub, cue_driver, cue_devclass, usbd_driver_load, 0);

#endif /* defined(__FreeBSD__) */

#define CUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d183 1
a183 3
cue_csr_read_1(sc, reg)
	struct cue_softc	*sc;
	int			reg;
a187 1
	int			s;
d198 1
a198 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, &val);
	splx(s);
d213 1
a213 3
cue_csr_read_2(sc, reg)
	struct cue_softc	*sc;
	int			reg;
a217 1
	int			s;
d228 1
a228 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, &val);
	splx(s);
d243 1
a243 3
cue_csr_write_1(sc, reg, val)
	struct cue_softc	*sc;
	int			reg, val;
a246 1
	int			s;
d260 1
a260 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d274 1
a274 1
#ifdef notdef
d276 1
a276 3
cue_csr_write_2(sc, reg, val)
	struct cue_softc	*sc;
	int			reg, aval;
d296 1
a296 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d309 1
a309 6
cue_mem(sc, cmd, addr, buf, len)
	struct cue_softc	*sc;
	int			cmd;
	int			addr;
	void			*buf;
	int			len;
a312 1
	int			s;
d326 1
a326 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, buf);
	splx(s);
d338 1
a338 3
cue_getmac(sc, buf)
	struct cue_softc	*sc;
	void			*buf;
a341 1
	int			s;
d351 1
a351 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, buf);
	splx(s);
d354 2
a355 1
		printf("%s: read MAC address failed\n", USBDEVNAME(sc->cue_dev));
d366 1
a366 2
cue_crc(addr)
	caddr_t			addr;
d382 1
a382 2
cue_setmulti(sc)
	struct cue_softc	*sc;
a384 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a386 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d394 3
a396 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a408 9
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);		
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a414 1
#if 0
d416 3
a418 6
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			/* XXX what now? */
			return;
		}
#endif
d423 2
a424 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d440 1
a440 2
cue_reset(sc)
	struct cue_softc	*sc;
a443 1
	int			s;
d456 1
a456 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d462 1
a462 1
	delay(1000);		/* XXX */
a500 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct cue_softc));
#endif

d507 1
a507 1
	err = usbd_set_config_no(dev, CUE_CONFIG_NO, 0);
d518 3
d560 1
a560 1
	s = splimp();
a564 31
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->cue_dev), eaddr, ":");

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_unit = USBDEVNAME(sc->cue_dev);
	ifp->if_name = "cue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = cue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = cue_start;
	ifp->if_watchdog = cue_watchdog;
	ifp->if_init = cue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	cue_qdat.ifp = ifp;
	cue_qdat.if_rxstart = cue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a587 1

a592 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

a611 2
	s = splusb();

d613 6
a621 1
		splx(s);
d625 2
d637 1
a638 1
#endif /* __NetBSD__ */
a658 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d660 1
a660 3
cue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a678 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d684 1
a684 4
cue_newbuf(sc, c, m)
	struct cue_softc	*sc;
	struct cue_chain	*c;
	struct mbuf		*m;
d717 1
a717 2
cue_rx_list_init(sc)
	struct cue_softc	*sc;
d746 1
a746 2
cue_tx_list_init(sc)
	struct cue_softc	*sc;
a772 24
#ifdef __FreeBSD__
Static void
cue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct cue_softc	*sc;
	struct cue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->cue_cdata.cue_rx_chain[sc->cue_cdata.cue_rx_prod];

	if (cue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],
	    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, cue_rxeof);
	usbd_transfer(c->cue_xfer);
}
#endif

d778 1
a778 4
cue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a785 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a786 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a830 7
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&cue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d833 1
a833 1
	s = splimp();
d848 1
a848 12
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
		BPF_MTAP(ifp, m);
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
a850 2
	}
#endif
a856 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d874 1
a874 4
cue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d884 1
a884 1
	s = splimp();
a907 5
#if defined(__FreeBSD__)
	c->cue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->cue_mbuf);
	c->cue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a912 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d918 1
a918 2
cue_tick(xsc)
	void			*xsc;
a920 2
	struct ifnet		*ifp;
	int			s;
d930 14
a943 1
	s = splimp();
a952 4

	usb_callout(sc->cue_stat_ch, hz, cue_tick, sc);

	splx(s);
d956 1
a956 4
cue_send(sc, m, idx)
	struct cue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d989 2
a990 1
		cue_stop(sc);
d1000 1
a1000 2
cue_start(ifp)
	struct ifnet		*ifp;
d1041 1
a1041 2
cue_init(xsc)
	void			*xsc;
d1056 1
a1056 1
	s = splimp();
d1069 1
a1069 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d1131 1
a1131 2
cue_open_pipes(sc)
	struct cue_softc	*sc;
d1167 1
a1167 4
cue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1169 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1171 1
#endif
d1177 1
a1177 1
	s = splimp();
a1179 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1218 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d1256 1
a1256 2
cue_watchdog(ifp)
	struct ifnet		*ifp;
d1259 3
d1271 4
a1274 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->cue_udev, 1);
	cue_stop(sc);
	cue_init(sc);
	usbd_set_polling(sc->cue_udev, 0);
d1278 1
d1286 1
a1286 2
cue_stop(sc)
	struct cue_softc	*sc;
a1369 18

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
cue_shutdown(dev)
	device_t		dev;
{
	struct cue_softc	*sc;

	sc = device_get_softc(dev);

	cue_reset(sc);
	cue_stop(sc);
}
#endif
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_cue.c,v 1.34 2001/04/12 23:54:56 augustss Exp $	*/
d59 4
d83 8
d96 2
d99 1
a99 1
#if defined(__NetBSD__)
d104 1
d106 3
d110 1
a110 1
#if NBPFILTER > 0
d132 1
d137 1
d144 4
d172 66
a237 27
Static int cue_open_pipes(struct cue_softc *);
Static int cue_tx_list_init(struct cue_softc *);
Static int cue_rx_list_init(struct cue_softc *);
Static int cue_newbuf(struct cue_softc *, struct cue_chain *, struct mbuf *);
Static int cue_send(struct cue_softc *, struct mbuf *, int);
Static void cue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void cue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void cue_tick(void *);
Static void cue_tick_task(void *);
Static void cue_start(struct ifnet *);
Static int cue_ioctl(struct ifnet *, u_long, caddr_t);
Static void cue_init(void *);
Static void cue_stop(struct cue_softc *);
Static void cue_watchdog(struct ifnet *);

Static void cue_setmulti(struct cue_softc *);
Static u_int32_t cue_crc(caddr_t);
Static void cue_reset(struct cue_softc *);

Static int cue_csr_read_1(struct cue_softc *, int);
Static int cue_csr_write_1(struct cue_softc *, int, int);
Static int cue_csr_read_2(struct cue_softc *, int);
#if 0
Static int cue_csr_write_2(struct cue_softc *, int, int);
#endif
Static int cue_mem(struct cue_softc *, int, int, void *, int);
Static int cue_getmac(struct cue_softc *, void *);
d246 3
a248 1
cue_csr_read_1(struct cue_softc *sc, int reg)
d253 1
d264 3
a266 1
	err = usbd_do_request(sc->cue_udev, &req, &val);
d281 3
a283 1
cue_csr_read_2(struct cue_softc *sc, int reg)
d288 1
d299 3
a301 1
	err = usbd_do_request(sc->cue_udev, &req, &val);
d316 3
a318 1
cue_csr_write_1(struct cue_softc *sc, int reg, int val)
d322 1
d336 3
a338 1
	err = usbd_do_request(sc->cue_udev, &req, NULL);
d352 1
a352 1
#if 0
d354 3
a356 1
cue_csr_write_2(struct cue_softc *sc, int reg, int aval)
d376 3
a378 1
	err = usbd_do_request(sc->cue_udev, &req, NULL);
d391 6
a396 1
cue_mem(struct cue_softc *sc, int cmd, int addr, void *buf, int len)
d400 1
d414 3
a416 1
	err = usbd_do_request(sc->cue_udev, &req, buf);
d428 3
a430 1
cue_getmac(struct cue_softc *sc, void *buf)
d434 1
d444 3
a446 1
	err = usbd_do_request(sc->cue_udev, &req, buf);
d449 1
a449 2
		printf("%s: read MAC address failed\n",
		       USBDEVNAME(sc->cue_dev));
d460 2
a461 1
cue_crc(caddr_t addr)
d477 2
a478 1
cue_setmulti(struct cue_softc *sc)
d481 3
d486 1
d494 1
a494 3
	if (ifp->if_flags & IFF_PROMISC) {
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
d507 9
d522 1
d524 6
a529 3
		    enm->enm_addrhi, ETHER_ADDR_LEN) != 0)
			goto allmulti;

d534 1
a534 2

	ifp->if_flags &= ~IFF_ALLMULTI;
d550 2
a551 1
cue_reset(struct cue_softc *sc)
d555 1
d568 3
a570 1
	err = usbd_do_request(sc->cue_udev, &req, NULL);
d576 1
a576 1
	usbd_delay_ms(sc->cue_udev, 1);
d615 4
d625 1
a625 1
	err = usbd_set_config_no(dev, CUE_CONFIG_NO, 1);
a635 3
	usb_init_task(&sc->cue_tick_task, cue_tick_task, sc);
	usb_init_task(&sc->cue_stop_task, (void (*)(void *))cue_stop, sc);

d675 1
a675 1
	s = splnet();
d680 31
d727 1
a727 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
a728 1
	IFQ_SET_READY(&ifp->if_snd);
d734 1
d740 2
d761 2
a763 6
	/*
	 * Remove any pending task.  It cannot be executing because it run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->cue_udev, &sc->cue_tick_task);
	usb_rem_task(sc->cue_udev, &sc->cue_stop_task);
d767 1
a770 2
	s = splusb();

d781 1
a782 1
	ether_ifdetach(ifp);
d803 1
d805 3
a807 1
cue_activate(device_ptr_t self, enum devact act)
d826 1
d832 4
a835 1
cue_newbuf(struct cue_softc *sc, struct cue_chain *c, struct mbuf *m)
d868 2
a869 1
cue_rx_list_init(struct cue_softc *sc)
d898 2
a899 1
cue_tx_list_init(struct cue_softc *sc)
d926 24
d955 4
a958 1
cue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d966 1
d968 1
d1013 7
d1022 1
a1022 1
	s = splnet();
d1037 12
a1048 1
	if (ifp->if_bpf)
d1051 2
d1059 1
d1077 4
a1080 1
cue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1090 1
a1090 1
	s = splnet();
d1114 5
d1122 1
a1122 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1124 1
d1130 2
a1131 1
cue_tick(void *xsc)
d1134 2
d1145 1
a1145 14
	/* Perform statistics update in process context. */
	usb_add_task(sc->cue_udev, &sc->cue_tick_task);
}

Static void
cue_tick_task(void *xsc)
{
	struct cue_softc	*sc = xsc;
	struct ifnet		*ifp;

	if (sc->cue_dying)
		return;

	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __FUNCTION__));
d1155 4
d1162 4
a1165 1
cue_send(struct cue_softc *sc, struct mbuf *m, int idx)
d1198 1
a1198 2
		/* Stop the interface from process context. */
		usb_add_task(sc->cue_udev, &sc->cue_stop_task);
d1208 2
a1209 1
cue_start(struct ifnet *ifp)
d1222 1
a1222 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1227 1
a1231 2
	IFQ_DEQUEUE(&ifp->if_snd, m_head);

d1250 2
a1251 1
cue_init(void *xsc)
d1266 1
a1266 1
	s = splnet();
d1279 1
a1279 1
#if defined(__OpenBSD__)
d1341 2
a1342 1
cue_open_pipes(struct cue_softc *sc)
d1378 4
a1381 1
cue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d1384 1
d1387 1
d1393 1
a1393 1
	s = splnet();
d1396 7
d1442 2
d1481 2
a1482 1
cue_watchdog(struct ifnet *ifp)
a1484 3
	struct cue_chain	*c;
	usbd_status		stat;
	int			s;
d1494 10
a1503 4
	s = splusb();
	c = &sc->cue_cdata.cue_tx_chain[0];
	usbd_get_xfer_status(c->cue_xfer, NULL, NULL, NULL, &stat);
	cue_txeof(c->cue_xfer, c, stat);
d1505 1
a1505 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
a1506 1
	splx(s);
d1514 2
a1515 1
cue_stop(struct cue_softc *sc)
d1599 18
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.8.2.2 2001/07/04 10:43:41 niklas Exp $ */
d580 3
@


1.8.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_cue.c,v 1.35 2001/04/13 23:30:09 thorpej Exp $	*/
d580 1
a581 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.8.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: if_cue.c,v 1.40 2002/07/11 21:14:26 augustss Exp $	*/
d99 1
a99 1
#include <netinet/in.h>
d138 1
a138 1
Static struct usb_devno cue_devs[] = {
d143 1
a144 1
#define cue_lookup(v, p) (usb_lookup(cue_devs, v, p))
d206 1
a206 1
	DPRINTFN(10,("%s: cue_csr_read_1 reg=0x%x val=0x%x\n",
d230 1
a230 1
	DPRINTFN(10,("%s: cue_csr_read_2 reg=0x%x val=0x%x\n",
d251 1
a251 1
	DPRINTFN(10,("%s: cue_csr_write_1 reg=0x%x val=0x%x\n",
d268 1
a268 1
	DPRINTFN(20,("%s: cue_csr_write_1, after reg=0x%x val=0x%x\n",
d286 1
a286 1
	DPRINTFN(10,("%s: cue_csr_write_2 reg=0x%x val=0x%x\n",
d391 1
a391 1
	DPRINTFN(2,("%s: cue_setmulti if_flags=0x%x\n",
d420 1
a420 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
d432 1
a432 1
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);
d471 1
d476 5
a480 2
	return (cue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d565 1
a565 1
	printf("%s: address %s\n", USBDEVNAME(sc->cue_dev),
d609 1
a609 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d633 3
d663 1
a663 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d788 1
a788 1
		     __func__, status));
d852 1
a852 1
		    __func__, m->m_len));
d865 1
a865 1
		    __func__));
d886 1
a886 1
		    __func__, status));
d927 1
a927 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d942 1
a942 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev), __func__));
d973 1
a973 1
		     USBDEVNAME(sc->cue_dev), __func__, total_len));
d1007 1
a1007 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1051 1
a1051 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1073 1
a1073 1
#endif
d1263 1
a1263 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
d1292 1
a1292 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->cue_dev),__func__));
@


1.8.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.8.2.5 2003/03/28 00:38:31 niklas Exp $ */
d499 1
a499 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.8.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d146 1
a146 1
USB_DECLARE_DRIVER_CLASS(cue, DV_IFNET);
@


1.8.2.8
log
@sync to head
@
text
@d164 1
d362 1
d365 16
d419 1
a419 2
		h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) &
		    ((1 << CUE_BITS) - 1);
d431 1
a431 2
		h = ether_crc32_le(etherbroadcastaddr, ETHER_ADDR_LEN) &
		    ((1 << CUE_BITS) - 1);
d1235 2
a1236 11
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			cue_setmulti(sc);
			error = 0;
		}
@


1.7
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.6 2001/01/25 03:50:52 todd Exp $ */
/*	$NetBSD: if_cue.c,v 1.21 2000/04/02 21:25:41 augustss Exp $	*/
a58 4
/*
 * TODO:
 * proper cleanup on errors
 */
a78 8
#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a83 2
#endif

d85 1
a85 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a89 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a90 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d92 1
a92 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a113 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a117 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a123 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d148 27
a174 66
Static int cue_open_pipes	__P((struct cue_softc *));
Static int cue_tx_list_init	__P((struct cue_softc *));
Static int cue_rx_list_init	__P((struct cue_softc *));
Static int cue_newbuf		__P((struct cue_softc *, struct cue_chain *,
				    struct mbuf *));
Static int cue_send		__P((struct cue_softc *, struct mbuf *, int));
Static void cue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void cue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void cue_tick		__P((void *));
Static void cue_start		__P((struct ifnet *));
Static int cue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void cue_init		__P((void *));
Static void cue_stop		__P((struct cue_softc *));
Static void cue_watchdog		__P((struct ifnet *));

Static void cue_setmulti	__P((struct cue_softc *));
Static u_int32_t cue_crc	__P((caddr_t));
Static void cue_reset		__P((struct cue_softc *));

Static int cue_csr_read_1	__P((struct cue_softc *, int));
Static int cue_csr_write_1	__P((struct cue_softc *, int, int));
Static int cue_csr_read_2	__P((struct cue_softc *, int));
#ifdef notdef
Static int cue_csr_write_2	__P((struct cue_softc *, int, int));
#endif
Static int cue_mem		__P((struct cue_softc *, int,
				    int, void *, int));
Static int cue_getmac		__P((struct cue_softc *, void *));

#ifdef __FreeBSD__
#ifndef lint
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_cue.c,v 1.4 2000/01/16 22:45:06 wpaul Exp $";
#endif

Static void cue_rxstart		__P((struct ifnet *));
Static void cue_shutdown	__P((device_t));

Static struct usb_qdat cue_qdat;

Static device_method_t cue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		cue_match),
	DEVMETHOD(device_attach,	cue_attach),
	DEVMETHOD(device_detach,	cue_detach),
	DEVMETHOD(device_shutdown,	cue_shutdown),

	{ 0, 0 }
};

Static driver_t cue_driver = {
	"cue",
	cue_methods,
	sizeof(struct cue_softc)
};

Static devclass_t cue_devclass;

DRIVER_MODULE(if_cue, uhub, cue_driver, cue_devclass, usbd_driver_load, 0);

#endif /* defined(__FreeBSD__) */

#define CUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d183 1
a183 3
cue_csr_read_1(sc, reg)
	struct cue_softc	*sc;
	int			reg;
a187 1
	int			s;
d198 1
a198 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, &val);
	splx(s);
d213 1
a213 3
cue_csr_read_2(sc, reg)
	struct cue_softc	*sc;
	int			reg;
a217 1
	int			s;
d228 1
a228 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, &val);
	splx(s);
d243 1
a243 3
cue_csr_write_1(sc, reg, val)
	struct cue_softc	*sc;
	int			reg, val;
a246 1
	int			s;
d260 1
a260 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d274 1
a274 1
#ifdef notdef
d276 1
a276 3
cue_csr_write_2(sc, reg, val)
	struct cue_softc	*sc;
	int			reg, aval;
d296 1
a296 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d309 1
a309 6
cue_mem(sc, cmd, addr, buf, len)
	struct cue_softc	*sc;
	int			cmd;
	int			addr;
	void			*buf;
	int			len;
a312 1
	int			s;
d326 1
a326 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, buf);
	splx(s);
d338 1
a338 3
cue_getmac(sc, buf)
	struct cue_softc	*sc;
	void			*buf;
a341 1
	int			s;
d351 1
a351 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, buf);
	splx(s);
d354 2
a355 1
		printf("%s: read MAC address failed\n", USBDEVNAME(sc->cue_dev));
d366 1
a366 2
cue_crc(addr)
	caddr_t			addr;
d382 1
a382 2
cue_setmulti(sc)
	struct cue_softc	*sc;
a384 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a386 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d394 3
a396 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a408 9
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = cue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		sc->cue_mctab[h >> 3] |= 1 << (h & 0x7);		
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a414 1
#if 0
d416 3
a418 6
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			/* XXX what now? */
			return;
		}
#endif
d423 2
a424 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d440 1
a440 2
cue_reset(sc)
	struct cue_softc	*sc;
a443 1
	int			s;
d456 1
a456 3
	s = splusb();
	err = CUE_DO_REQUEST(sc->cue_udev, &req, NULL);
	splx(s);
d462 1
a462 1
	delay(1000);		/* XXX */
a500 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct cue_softc));
#endif

d507 1
a507 1
	err = usbd_set_config_no(dev, CUE_CONFIG_NO, 0);
d518 3
d560 1
a560 1
	s = splimp();
a564 31
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->cue_dev), eaddr, ":");

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_unit = USBDEVNAME(sc->cue_dev);
	ifp->if_name = "cue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = cue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = cue_start;
	ifp->if_watchdog = cue_watchdog;
	ifp->if_init = cue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	cue_qdat.ifp = ifp;
	cue_qdat.if_rxstart = cue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a587 1

a592 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

a611 2
	s = splusb();

d613 6
a621 1
		splx(s);
d625 2
d637 1
a638 1
#endif /* __NetBSD__ */
a658 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d660 1
a660 3
cue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a678 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d684 1
a684 4
cue_newbuf(sc, c, m)
	struct cue_softc	*sc;
	struct cue_chain	*c;
	struct mbuf		*m;
d717 1
a717 2
cue_rx_list_init(sc)
	struct cue_softc	*sc;
d746 1
a746 2
cue_tx_list_init(sc)
	struct cue_softc	*sc;
a772 24
#ifdef __FreeBSD__
Static void
cue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct cue_softc	*sc;
	struct cue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->cue_cdata.cue_rx_chain[sc->cue_cdata.cue_rx_prod];

	if (cue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->cue_xfer, sc->cue_ep[CUE_ENDPT_RX],
	    c, c->cue_buf, CUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, cue_rxeof);
	usbd_transfer(c->cue_xfer);
}
#endif

d778 1
a778 4
cue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a785 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a786 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a830 7
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&cue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d833 1
a833 1
	s = splimp();
d848 1
a848 12
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
		BPF_MTAP(ifp, m);
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
a850 2
	}
#endif
a856 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d874 1
a874 4
cue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d884 1
a884 1
	s = splimp();
a907 5
#if defined(__FreeBSD__)
	c->cue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->cue_mbuf);
	c->cue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a912 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d918 1
a918 2
cue_tick(xsc)
	void			*xsc;
a920 2
	struct ifnet		*ifp;
	int			s;
d930 14
a943 1
	s = splimp();
a952 4

	usb_callout(sc->cue_stat_ch, hz, cue_tick, sc);

	splx(s);
d956 1
a956 4
cue_send(sc, m, idx)
	struct cue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d989 2
a990 1
		cue_stop(sc);
d1000 1
a1000 2
cue_start(ifp)
	struct ifnet		*ifp;
d1041 1
a1041 2
cue_init(xsc)
	void			*xsc;
d1056 1
a1056 1
	s = splimp();
d1069 1
a1069 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d1131 1
a1131 2
cue_open_pipes(sc)
	struct cue_softc	*sc;
d1167 1
a1167 4
cue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1169 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1171 1
#endif
d1177 1
a1177 1
	s = splimp();
a1179 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1218 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d1256 1
a1256 2
cue_watchdog(ifp)
	struct ifnet		*ifp;
d1259 3
d1271 4
a1274 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->cue_udev, 1);
	cue_stop(sc);
	cue_init(sc);
	usbd_set_polling(sc->cue_udev, 0);
d1278 1
d1286 1
a1286 2
cue_stop(sc)
	struct cue_softc	*sc;
a1369 18

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
cue_shutdown(dev)
	device_t		dev;
{
	struct cue_softc	*sc;

	sc = device_get_softc(dev);

	cue_reset(sc);
	cue_stop(sc);
}
#endif
@


1.6
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.5 2000/07/04 11:44:21 fgsch Exp $ */
a734 4
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.5
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.4 2000/04/23 17:33:47 maja Exp $ */
d51 1
a51 1
 * mode where multiple packets can be transfered using a single bulk
@


1.4
log
@Save ethernet address in arpcom.ac_enaddr. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.3 2000/04/04 22:52:30 aaron Exp $ */
d165 1
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cue.c,v 1.2 2000/03/30 16:19:32 aaron Exp $ */
d712 4
@


1.2
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_cue.c,v 1.1 2000/03/28 19:37:47 aaron Exp $ */
/*	$NetBSD: if_cue.c,v 1.20 2000/03/30 08:53:30 augustss Exp $	*/
d1195 2
@


1.1
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_cue.c,v 1.16 2000/03/24 22:03:29 augustss Exp $	*/
d70 1
a70 1
#endif
d162 1
a162 1
static struct cue_type cue_devs[] = {
d171 4
a174 6
#define static

static int cue_open_pipes	__P((struct cue_softc *));
static int cue_tx_list_init	__P((struct cue_softc *));
static int cue_rx_list_init	__P((struct cue_softc *));
static int cue_newbuf		__P((struct cue_softc *, struct cue_chain *,
d176 2
a177 2
static int cue_send		__P((struct cue_softc *, struct mbuf *, int));
static void cue_rxeof		__P((usbd_xfer_handle,
d179 1
a179 1
static void cue_txeof		__P((usbd_xfer_handle,
d181 14
a194 14
static void cue_tick		__P((void *));
static void cue_start		__P((struct ifnet *));
static int cue_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void cue_init		__P((void *));
static void cue_stop		__P((struct cue_softc *));
static void cue_watchdog		__P((struct ifnet *));

static void cue_setmulti	__P((struct cue_softc *));
static u_int32_t cue_crc	__P((caddr_t));
static void cue_reset		__P((struct cue_softc *));

static int cue_csr_read_1	__P((struct cue_softc *, int));
static int cue_csr_write_1	__P((struct cue_softc *, int, int));
static int cue_csr_read_2	__P((struct cue_softc *, int));
d196 1
a196 1
static int cue_csr_write_2	__P((struct cue_softc *, int, int));
d198 1
a198 1
static int cue_mem		__P((struct cue_softc *, int,
d200 1
a200 1
static int cue_getmac		__P((struct cue_softc *, void *));
d208 2
a209 2
static void cue_rxstart		__P((struct ifnet *));
static void cue_shutdown	__P((device_t));
d211 1
a211 1
static struct usb_qdat cue_qdat;
d213 1
a213 1
static device_method_t cue_methods[] = {
d223 1
a223 1
static driver_t cue_driver = {
d229 1
a229 1
static devclass_t cue_devclass;
d244 1
a244 1
static int
d279 1
a279 1
static int
d314 1
a314 1
static int
d352 1
a352 1
static int
d389 1
a389 1
static int
d426 1
a426 1
static int
d458 1
a458 1
static u_int32_t
d475 1
a475 1
static void
d548 1
a548 1
static void
d721 3
d728 1
a728 5
#if defined(__NetBSD__)
	ether_ifattach(ifp, eaddr);
#else
	ether_ifattach(ifp);
#endif
a817 1
#if defined(__NetBSD__)
a819 1
#endif
d830 1
a830 1
static int
d866 1
a866 1
static int
d896 1
a896 1
static int
d926 1
a926 1
static void
d953 1
a953 1
static void
a966 1
	struct ether_header	*eh;
a1028 2
	eh = mtod(m, struct ether_header *);

d1037 2
a1039 1
#if defined(__NetBSD__)
d1047 2
d1055 1
a1055 5
#if defined(__NetBSD__)
	(*ifp->if_input)(ifp, m);
#else
	ether_input(ifp, eh, m);
#endif
d1075 1
a1075 1
static void
d1128 1
a1128 1
static void
d1160 1
a1160 1
static int
d1204 1
a1204 1
static void
d1246 1
a1246 1
static void
d1280 1
a1280 1
#endif /* defined(__NetBSD__) */
d1337 1
a1337 1
static int
d1374 1
a1374 1
static int
d1477 1
a1477 1
static void
d1510 1
a1510 1
static void
d1602 1
a1602 1
static void
@

