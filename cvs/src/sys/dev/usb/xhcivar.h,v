head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.10
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.8
date	2015.01.18.20.35.11;	author mpi;	state Exp;
branches;
next	1.7;
commitid	ov3LUoHeJLH18IpP;

1.7
date	2015.01.18.11.54.02;	author mpi;	state Exp;
branches;
next	1.6;
commitid	imkPnwYlZMsIkL0E;

1.6
date	2014.12.15.17.10.44;	author mpi;	state Exp;
branches;
next	1.5;
commitid	HisRLxB0I1PGsCpI;

1.5
date	2014.10.30.18.25.08;	author mpi;	state Exp;
branches;
next	1.4;
commitid	YqEjpcfinbNspaim;

1.4
date	2014.04.29.12.45.29;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.2;

1.2
date	2014.03.25.17.23.40;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2014.03.08.14.34.11;	author mpi;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Do not trust the content of event TRBs coming from the hardware and
maintain a list of possibly submitted commands.
@
text
@/* $OpenBSD: xhcivar.h,v 1.7 2015/01/18 11:54:02 mpi Exp $ */

/*
 * Copyright (c) 2014 Martin Pieuchot
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef	_XHCIVAR_H_
#define	_XHCIVAR_H_

/* Default command execution time (implementation defined). */
#define	XHCI_CMD_TIMEOUT	500	/* ms */

#define	XHCI_MAX_CMDS		(16 * 1)
#define	XHCI_MAX_EVTS		(16 * 13)
#define	XHCI_MAX_XFER		(16 * 16)

struct usbd_dma_info {
	bus_dma_tag_t		 tag;
	bus_dmamap_t		 map;
	bus_dma_segment_t	 seg;
	int			 nsegs;
	bus_addr_t		 paddr;
	caddr_t			 vaddr;
	bus_size_t		 size;
};

struct xhci_xfer {
	struct usbd_xfer	 xfer;
	int			 index;		/* Index of the last TRB */
	size_t			 ntrb;		/* Number of associated TRBs */
};

struct xhci_ring {
	struct xhci_trb		*trbs;
	size_t			 ntrb;
	struct usbd_dma_info	 dma;

	uint32_t		 index;
	uint32_t		 toggle;	/* Producer/Consumer bit */
};

struct xhci_soft_dev {
	struct xhci_inctx	*input_ctx;	/* Input context */
	struct xhci_sctx	*slot_ctx;
	struct xhci_epctx	*ep_ctx[31];
	struct usbd_dma_info	 ictx_dma;

	struct usbd_dma_info	 octx_dma;	/* Output context */

	struct xhci_pipe	*pipes[31];
};

/* Device context segment table. */
struct xhci_devctx {
	uint64_t		*segs;		/* at most USB_MAX_DEVICES+1 */
	struct usbd_dma_info	 dma;
};

/* Event ring segment table. */
struct xhci_erst {
	struct xhci_erseg	*segs;		/* One segment per event ring */
	struct usbd_dma_info	 dma;
};

struct xhci_scratchpad {
	struct usbd_dma_info	 table_dma;
	struct usbd_dma_info	 pages_dma;
	int			 npage;
};

struct xhci_softc {
	struct usbd_bus		 sc_bus;

	bus_space_tag_t		 iot;
	bus_space_handle_t	 ioh;
	bus_size_t		 sc_size;

	bus_size_t		 sc_oper_off;	/* Operational Register space */
	bus_size_t		 sc_runt_off;	/* Runtime */
	bus_size_t		 sc_door_off;	/* Doorbell  */

	uint32_t		 sc_pagesize;	/* xHCI page size, minimum 4k */
	uint32_t		 sc_ctxsize;	/* 32/64 byte context structs */

	int			 sc_noport;	/* Maximum number of ports */

	u_int8_t		 sc_conf;	/* Device configuration */
	struct usbd_xfer	*sc_intrxfer;	/* Root HUB interrupt xfer */

	struct xhci_devctx	 sc_dcbaa;	/* Device context base addr. */
	struct xhci_ring	 sc_cmd_ring;	/* Command ring */

	struct xhci_erst	 sc_erst;	/* Event ring segment table */
	struct xhci_ring	 sc_evt_ring;	/* Event ring */

	struct xhci_scratchpad	 sc_spad;	/* Optional scratchpad */

	int 			 sc_noslot;	/* Maximum number of slots */
	struct xhci_soft_dev	 sc_sdevs[USB_MAX_DEVICES];

	struct xhci_trb		*sc_cmd_trb;
	struct xhci_trb		 sc_result_trb;

	char			 sc_vendor[16];	/* Vendor string for root hub */
	int			 sc_id_vendor;	/* Vendor ID for root hub */
};

int	xhci_init(struct xhci_softc *);
void	xhci_config(struct xhci_softc *);
int	xhci_intr(void *);
int	xhci_detach(struct device *, int);
int	xhci_activate(struct device *, int);

#define	XREAD1(sc, a) bus_space_read_1((sc)->iot, (sc)->ioh, (a))
#define	XREAD2(sc, a) bus_space_read_2((sc)->iot, (sc)->ioh, (a))
#define	XREAD4(sc, a) bus_space_read_4((sc)->iot, (sc)->ioh, (a))
#define	XWRITE1(sc, a, x) bus_space_write_1((sc)->iot, (sc)->ioh, (a), (x))
#define	XWRITE2(sc, a, x) bus_space_write_2((sc)->iot, (sc)->ioh, (a), (x))
#define	XWRITE4(sc, a, x) bus_space_write_4((sc)->iot, (sc)->ioh, (a), (x))

#define	XOREAD4(sc, a)							\
	bus_space_read_4((sc)->iot, (sc)->ioh, (sc)->sc_oper_off + (a))
#define	XOWRITE4(sc, a, x)						\
	bus_space_write_4((sc)->iot, (sc)->ioh, (sc)->sc_oper_off + (a), (x))

#define	XRREAD4(sc, a) \
	bus_space_read_4((sc)->iot, (sc)->ioh, (sc)->sc_runt_off + (a))
#define	XRWRITE4(sc, a, x) \
	bus_space_write_4((sc)->iot, (sc)->ioh, (sc)->sc_runt_off + (a), (x))

#define	XDREAD4(sc, a) \
	bus_space_read_4((sc)->iot, (sc)->ioh, (sc)->sc_door_off + (a))
#define	XDWRITE4(sc, a, x) \
	bus_space_write_4((sc)->iot, (sc)->ioh, (sc)->sc_door_off + (a), (x))

#endif /* _XHCIVAR_H_ */
@


1.7
log
@Since we are no longer resetting rings when a Babble or Stall condition
is detected, simply keep track of the faulty xfer instead of completing
all the pending ones.

Fix a race condition where we could end up aborting a freshly enqueued
xfer when two different threads are submitting control transfers (i.e.
usbdevs(8) and a kernel driver).
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.6 2014/12/15 17:10:44 mpi Exp $ */
d21 3
@


1.6
log
@Stop using usb_{alloc,free}mem() for the rings and internal structures.

Since xhci(4) does not allocate memory for its rings in interrupt
context, it has no use for the free lists offered by the USB memory
allocator.

Using bus_dmamem_alloc(9) and friends also allows us to respect the
boundary requirement for the various structures specified in Table 54.

While here make use of defines for every alignment and boundary
requirements which are different than a page size.
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.5 2014/10/30 18:25:08 mpi Exp $ */
d38 1
a38 1
	int			 index;		/* Index of the first TRB */
@


1.5
log
@Do not enable interrupts before attaching usb(4), fix a panic when an
Express Card is plugged with USB devices on it.

While here do not print an unitialized error value if xhci_init() fails,
from Patrick Wildt.
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.4 2014/04/29 12:45:29 mpi Exp $ */
d22 13
a34 4
#define	XHCI_MAX_COMMANDS	(16 * 1)
#define	XHCI_MAX_EVENTS		(16 * 13)
#define	XHCI_MAX_TRANSFERS	(16 * 16)

d45 1
a45 1
	struct usb_dma		 dma;
d55 1
a55 1
	struct usb_dma		 ictx_dma;
d57 1
a57 1
	struct usb_dma		 octx_dma;	/* Output context */
d65 1
a65 2
	size_t			 size;
	struct usb_dma		 dma;
d71 1
a71 2
	size_t			 size;
	struct usb_dma		 dma;
d75 2
a76 2
	struct usb_dma		 table_dma;
	struct usb_dma		 pages_dma;
a77 1

@


1.4
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.

With inputs from mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.3 2014/03/25 20:27:37 mpi Exp $ */
d112 1
@


1.3
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.2 2014/03/25 17:23:40 mpi Exp $ */
a105 2

	SIMPLEQ_HEAD(, usbd_xfer) sc_free_xfers; /* free xfers */
@


1.2
log
@Upon resume do a full reset of the HC, including the command and event
rings, and rewrite all the addresses in the registers.

While here don't keep a copy of our usb(4) child device, autoconf(9)
knows how to reach our children.
@
text
@d1 1
a1 1
/* $OpenBSD: xhcivar.h,v 1.1 2014/03/08 14:34:11 mpi Exp $ */
a89 1
	u_int8_t		 sc_addr;	/* Device address */
@


1.1
log
@Dumb xhci(4) implementation.

This driver does not handle isochronous endpoint (yet) and has no logical
TD representation.  Each transfer is linked to the raw TRB of its related
endpoint.

Most of the transfer error completion codes are not handled, even with all
the cheese provided by miod@@ I couldn't find a proper way to reset an
endpoint asynchronously when a device babbles.  Or maybe it was the wine?
Anyway this will come soon.

In general the endpoint configuration and reset code is really crude and
requires some love, but our stack should be fixed to properly open only
once the default pipe of every new USB device first.

This means this driver wont work as it is, our stack needs other changes
first.

Suspend/resume works but ports are not suspended for the moment.

But even with these problems, interrupt devices: ukbd(4), ums(4) and
sensors like ugold(4) work properly and USB 3.0 umass(4) devices give
me a reasonnable read/write speed.

Timeouts to cancel USB transfers are not enabled *on purpose*, to be able
to track down potential timing issues.

I'm committing now so that others can help fixing my bugs (8

All this work has been done on an ExpressCard with a NEC xHCI 0.96, other
implementations/versions might trigger more bugs :)
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a111 1
	struct device		*sc_child;	/* /dev/usb# device */
d116 1
a116 1
int	xhci_detach(struct xhci_softc *, int);
@

