head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.6
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.8
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.4
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.15.0.2
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.13.0.8
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.4.0.6
	OPENBSD_3_4_BASE:1.4
	SMP:1.4.0.4
	UBC:1.4.0.2
	UBC_SYNC_A:1.3
	UBC_SYNC_B:1.2;
locks; strict;
comment	@ * @;


1.45
date	2016.08.03.13.44.49;	author krw;	state Exp;
branches;
next	1.44;
commitid	Cz1z8WXhaZRZXnHz;

1.44
date	2016.08.01.10.56.31;	author krw;	state Exp;
branches;
next	1.43;
commitid	b261qrkmkRs0Dk43;

1.43
date	2015.12.16.14.50.26;	author mpi;	state Exp;
branches;
next	1.42;
commitid	Hjg9j5O0F4eVYCbh;

1.42
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.41;
commitid	p4LJxGKbi0BU2cG6;

1.41
date	2014.08.08.14.16.43;	author mpi;	state Exp;
branches;
next	1.40;
commitid	9vqohsdQtGQBXQ7M;

1.40
date	2013.11.06.14.37.31;	author pirofti;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.22.01.19.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.09.04.37.53;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.24.20.27.11;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.19.23.21.15;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.19.01.21.51;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.06.15.16.54;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.21.02.41.24;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.20.00.55.18;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.13.11.46.33;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.09.23.15.07;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.02.18.50.37;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.13.04.27.07;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.20.04.37.54;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.20.03.37.05;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.09.23.03.30;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.13.10.33.52;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.30.10.05.32;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.25.21.12.54;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.14.23.36.26;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.27.23.54.44;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.01.06.41.13;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.22.02.40.21;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.21.07.43.41;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.21.00.47.42;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.10.09.10.51;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.17.18.25.51;	author krw;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2003.05.17.06.07.57;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.4.4.1
date	2003.06.07.10.39.47;	author ho;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Fold umass_atapi_attach() and umass_scsi_setup() into umass_scsi_attach() to
shorten and simplify code.

No intentional functional change.
@
text
@/*	$OpenBSD: umass_scsi.c,v 1.44 2016/08/01 10:56:31 krw Exp $ */
/*	$NetBSD: umass_scsipi.c,v 1.9 2003/02/16 23:14:08 augustss Exp $	*/
/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/umassvar.h>
#include <dev/usb/umass_scsi.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>
#include <machine/bus.h>

struct umass_scsi_softc {
	struct device		*sc_child;
	struct scsi_link	sc_link;
	struct scsi_iopool	sc_iopool;
	int			sc_open;

	struct scsi_sense	sc_sense_cmd;
};


#define UMASS_SCSIID_HOST	0x00
#define UMASS_SCSIID_DEVICE	0x01

int umass_scsi_probe(struct scsi_link *);
void umass_scsi_cmd(struct scsi_xfer *);
void umass_scsi_minphys(struct buf *, struct scsi_link *);

struct scsi_adapter umass_scsi_switch = {
	umass_scsi_cmd,
	umass_scsi_minphys,
	umass_scsi_probe
};

void umass_scsi_cb(struct umass_softc *sc, void *priv, int residue,
		   int status);
void umass_scsi_sense_cb(struct umass_softc *sc, void *priv, int residue,
			 int status);
void *umass_io_get(void *);
void umass_io_put(void *, void *);

int
umass_scsi_attach(struct umass_softc *sc)
{
	struct scsibus_attach_args saa;
	struct umass_scsi_softc *scbus;

	scbus = malloc(sizeof(*scbus), M_DEVBUF, M_WAITOK | M_ZERO);

	sc->bus = scbus;

	scsi_iopool_init(&scbus->sc_iopool, scbus, umass_io_get, umass_io_put);

	/* Fill in the link. */
	scbus->sc_link.adapter_buswidth = 2;
	scbus->sc_link.adapter = &umass_scsi_switch;
	scbus->sc_link.adapter_softc = sc;
	scbus->sc_link.adapter_target = UMASS_SCSIID_HOST;
	scbus->sc_link.openings = 1;
	scbus->sc_link.quirks = SDEV_ONLYBIG | sc->sc_busquirks;
	scbus->sc_link.pool = &scbus->sc_iopool;
	scbus->sc_link.luns = sc->maxlun + 1;
	scbus->sc_link.flags = SDEV_UMASS;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &scbus->sc_link;

	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
	case UMASS_CPROTO_SCSI:
		DPRINTF(UDMASS_USB, ("%s: umass_attach_bus: SCSI\n"
				     "sc = 0x%p, scbus = 0x%p\n",
				     sc->sc_dev.dv_xname, sc, scbus));
		break;
	case UMASS_CPROTO_UFI:
	case UMASS_CPROTO_ATAPI:
		scbus->sc_link.flags |= SDEV_ATAPI;
		DPRINTF(UDMASS_USB, ("%s: umass_attach_bus: ATAPI\n"
				     "sc = 0x%p, scbus = 0x%p\n",
				     sc->sc_dev.dv_xname, sc, scbus));
		break;
	default:
		break;
	}

	sc->sc_refcnt++;
	scbus->sc_child = config_found((struct device *)sc, &saa, scsiprint);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (0);
}

int
umass_scsi_detach(struct umass_softc *sc, int flags)
{
	struct umass_scsi_softc *scbus = sc->bus;
	int rv = 0;

	if (scbus != NULL) {
		if (scbus->sc_child != NULL)
			rv = config_detach(scbus->sc_child, flags);
		free(scbus, M_DEVBUF, sizeof(*scbus));
		sc->bus = NULL;
	}

	return (rv);
}

int
umass_scsi_probe(struct scsi_link *link)
{
	struct umass_softc *sc = link->adapter_softc;
	struct usb_device_info udi;
	size_t len;

	/* dont fake devids when more than one scsi device can attach. */
	if (sc->maxlun > 0)
		return (0);

	usbd_fill_deviceinfo(sc->sc_udev, &udi, 1);

	/*
	 * Create a fake devid using the vendor and product ids and the last
	 * 12 characters of serial number, as recommended by Section 4.1.1 of
	 * the USB Mass Storage Class - Bulk Only Transport spec. 
	 */
	len = strlen(udi.udi_serial);
	if (len >= 12) {
		char buf[21];
		snprintf(buf, sizeof(buf), "%04x%04x%s", udi.udi_vendorNo,
		    udi.udi_productNo, udi.udi_serial + len - 12);
		link->id = devid_alloc(DEVID_SERIAL, DEVID_F_PRINT,
		    sizeof(buf) - 1, buf);
	}

	return (0);
}

void
umass_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *sc_link = xs->sc_link;
	struct umass_softc *sc = sc_link->adapter_softc;
	struct scsi_generic *cmd;
	int cmdlen, dir;

#ifdef UMASS_DEBUG
	microtime(&sc->tv);
#endif

	DIF(UDMASS_UPPER, sc_link->flags |= SCSIDEBUG_LEVEL);

	DPRINTF(UDMASS_CMD, ("%s: umass_scsi_cmd: at %lld.%06ld: %d:%d "
		"xs=%p cmd=0x%02x datalen=%d (quirks=0x%x, poll=%d)\n",
		sc->sc_dev.dv_xname, (long long)sc->tv.tv_sec, sc->tv.tv_usec,
		sc_link->target, sc_link->lun, xs, xs->cmd->opcode,
		xs->datalen, sc_link->quirks, xs->flags & SCSI_POLL));

	if (usbd_is_dying(sc->sc_udev)) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

#if defined(UMASS_DEBUG)
	if (sc_link->target != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: wrong SCSI ID %d\n",
			sc->sc_dev.dv_xname, sc_link->target));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif

	cmd = xs->cmd;
	cmdlen = xs->cmdlen;

	dir = DIR_NONE;
	if (xs->datalen) {
		switch (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
		case SCSI_DATA_IN:
			dir = DIR_IN;
			break;
		case SCSI_DATA_OUT:
			dir = DIR_OUT;
			break;
		}
	}

	if (xs->datalen > UMASS_MAX_TRANSFER_SIZE) {
		printf("umass_cmd: large datalen, %d\n", xs->datalen);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	if (xs->flags & SCSI_POLL) {
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: sync dir=%d\n", dir));
		usbd_set_polling(sc->sc_udev, 1);
		sc->sc_xfer_flags = USBD_SYNCHRONOUS;
		sc->polled_xfer_status = USBD_INVAL;
		sc->sc_methods->wire_xfer(sc, sc_link->lun, cmd, cmdlen,
					  xs->data, xs->datalen, dir,
					  xs->timeout, umass_scsi_cb, xs);
		sc->sc_xfer_flags = 0;
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n",
				      sc->polled_xfer_status));
		usbd_set_polling(sc->sc_udev, 0);
		/* scsi_done() has already been called. */
		return;
	} else {
		DPRINTF(UDMASS_SCSI,
			("umass_scsi_cmd: async dir=%d, cmdlen=%d"
			 " datalen=%d\n",
			 dir, cmdlen, xs->datalen));
		sc->sc_methods->wire_xfer(sc, sc_link->lun, cmd, cmdlen,
					  xs->data, xs->datalen, dir,
					  xs->timeout, umass_scsi_cb, xs);
		/* scsi_done() has already been called. */
		return;
	}

	/* Return if command finishes early. */
 done:
	scsi_done(xs);
}

void
umass_scsi_minphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)
		bp->b_bcount = UMASS_MAX_TRANSFER_SIZE;

	minphys(bp);
}

void
umass_scsi_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	struct umass_scsi_softc *scbus = sc->bus;
	struct scsi_xfer *xs = priv;
	struct scsi_link *link = xs->sc_link;
	int cmdlen;
#ifdef UMASS_DEBUG
	struct timeval tv;
	u_int delta;
	microtime(&tv);
	delta = (tv.tv_sec - sc->tv.tv_sec) * 1000000 +
		tv.tv_usec - sc->tv.tv_usec;
#endif

	DPRINTF(UDMASS_CMD,
		("umass_scsi_cb: at %lld.%06ld, delta=%u: xs=%p residue=%d"
		 " status=%d\n", (long long)tv.tv_sec, tv.tv_usec, delta, xs, residue,
		 status));

	xs->resid = residue;

	switch (status) {
	case STATUS_CMD_OK:
		xs->error = XS_NOERROR;
		break;

	case STATUS_CMD_UNKNOWN:
		DPRINTF(UDMASS_CMD, ("umass_scsi_cb: status cmd unknown\n"));
		/* we can't issue REQUEST SENSE */
		if (xs->sc_link->quirks & ADEV_NOSENSE) {
			/*
			 * If no residue and no other USB error,
			 * command succeeded.
			 */
			if (residue == 0) {
				xs->error = XS_NOERROR;
				break;
			}

			/*
			 * Some devices return a short INQUIRY
			 * response, omitting response data from the
			 * "vendor specific data" on...
			 */
			if (xs->cmd->opcode == INQUIRY &&
			    residue < xs->datalen) {
				xs->error = XS_NOERROR;
				break;
			}

			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		/* FALLTHROUGH */
	case STATUS_CMD_FAILED:
		DPRINTF(UDMASS_CMD, ("umass_scsi_cb: status cmd failed for "
		    "scsi op 0x%02x\n", xs->cmd->opcode));
		/* fetch sense data */
		sc->sc_sense = 1;
		memset(&scbus->sc_sense_cmd, 0, sizeof(scbus->sc_sense_cmd));
		scbus->sc_sense_cmd.opcode = REQUEST_SENSE;
		scbus->sc_sense_cmd.byte2 = link->lun << SCSI_CMD_LUN_SHIFT;
		scbus->sc_sense_cmd.length = sizeof(xs->sense);

		cmdlen = sizeof(scbus->sc_sense_cmd);
		if (xs->flags & SCSI_POLL) {
			usbd_set_polling(sc->sc_udev, 1);
			sc->sc_xfer_flags = USBD_SYNCHRONOUS;
			sc->polled_xfer_status = USBD_INVAL;
		}
		/* scsi_done() has already been called. */
		sc->sc_methods->wire_xfer(sc, link->lun,
					  &scbus->sc_sense_cmd, cmdlen,
					  &xs->sense, sizeof(xs->sense),
					  DIR_IN, xs->timeout,
					  umass_scsi_sense_cb, xs);
		if (xs->flags & SCSI_POLL) {
			sc->sc_xfer_flags = 0;
			usbd_set_polling(sc->sc_udev, 0);
		}
		return;

	case STATUS_WIRE_FAILED:
		xs->error = XS_RESET;
		break;

	default:
		panic("%s: Unknown status %d in umass_scsi_cb",
		      sc->sc_dev.dv_xname, status);
	}

	DPRINTF(UDMASS_CMD,("umass_scsi_cb: at %lld.%06ld: return error=%d, "
			    "status=0x%x resid=%zu\n",
			    (long long)tv.tv_sec, tv.tv_usec,
			    xs->error, xs->status, xs->resid));

	if ((xs->flags & SCSI_POLL) && (xs->error == XS_NOERROR)) {
		switch (sc->polled_xfer_status) {
		case USBD_NORMAL_COMPLETION:
			xs->error = XS_NOERROR;
			break;
		case USBD_TIMEOUT:
			xs->error = XS_TIMEOUT;
			break;
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
	}

	scsi_done(xs);
}

/*
 * Finalise a completed autosense operation
 */
void
umass_scsi_sense_cb(struct umass_softc *sc, void *priv, int residue,
		    int status)
{
	struct scsi_xfer *xs = priv;

	DPRINTF(UDMASS_CMD,("umass_scsi_sense_cb: xs=%p residue=%d "
		"status=%d\n", xs, residue, status));

	sc->sc_sense = 0;
	switch (status) {
	case STATUS_CMD_OK:
	case STATUS_CMD_UNKNOWN:
		/* getting sense data succeeded */
		if (residue == 0 || residue == 14)/* XXX */
			xs->error = XS_SENSE;
		else
			xs->error = XS_SHORTSENSE;
		break;
	default:
		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
			sc->sc_dev.dv_xname, status));
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	DPRINTF(UDMASS_CMD,("umass_scsi_sense_cb: return xs->error=%d, "
		"xs->flags=0x%x xs->resid=%zu\n", xs->error, xs->status,
		xs->resid));

	if ((xs->flags & SCSI_POLL) && (xs->error == XS_NOERROR)) {
		switch (sc->polled_xfer_status) {
		case USBD_NORMAL_COMPLETION:
			xs->error = XS_NOERROR;
			break;
		case USBD_TIMEOUT:
			xs->error = XS_TIMEOUT;
			break;
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
	}

	scsi_done(xs);
}

void *
umass_io_get(void *cookie)
{
	struct umass_scsi_softc *scbus = cookie;
	void *io = NULL;
	int s;

	s = splusb();
	if (!scbus->sc_open) {
		scbus->sc_open = 1;
		io = scbus; /* just has to be non-NULL */
	}
	splx(s);

	return (io);
}

void
umass_io_put(void *cookie, void *io)
{
	struct umass_scsi_softc *scbus = cookie;
	int s;

	s = splusb();
	scbus->sc_open = 0;
	splx(s);
}
@


1.44
log
@Set SDEV_UMASS on all umass devices, even when they use ATAPI or
UFI command sets. Probe all the LUNs a device reports instead of
assuming ATAPI and UFI devices always have 1 LUN.

Motivated by the device David Vasek reported as claiming to be
ATAPI but wanting to use >1 LUN. Committing quickly to smoke out
the inevitable device that works in the exact opposite way. All
hail USB.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.43 2015/12/16 14:50:26 mpi Exp $ */
a80 2
struct umass_scsi_softc *umass_scsi_setup(struct umass_softc *);

d90 1
a90 5
	scbus = umass_scsi_setup(sc);
	scbus->sc_link.adapter_target = UMASS_SCSIID_HOST;
	scbus->sc_link.luns = sc->maxlun + 1;
	scbus->sc_link.flags &= ~SDEV_ATAPI;
	scbus->sc_link.flags |= SDEV_UMASS;
d92 1
a92 2
	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &scbus->sc_link;
d94 1
a94 3
	DPRINTF(UDMASS_USB, ("%s: umass_attach_bus: SCSI\n"
			     "sc = 0x%p, scbus = 0x%p\n",
			     sc->sc_dev.dv_xname, sc, scbus));
d96 4
a99 15
	sc->sc_refcnt++;
	scbus->sc_child = config_found((struct device *)sc, &saa, scsiprint);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (0);
}

int
umass_atapi_attach(struct umass_softc *sc)
{
	struct scsibus_attach_args saa;
	struct umass_scsi_softc *scbus;

	scbus = umass_scsi_setup(sc);
d101 3
d105 1
a105 2
	scbus->sc_link.openings = 1;
	scbus->sc_link.flags |= SDEV_UMASS | SDEV_ATAPI;
d110 17
a126 3
	DPRINTF(UDMASS_USB, ("%s: umass_attach_bus: ATAPI\n"
			     "sc = 0x%p, scbus = 0x%p\n",
			     sc->sc_dev.dv_xname, sc, scbus));
a133 22
}

struct umass_scsi_softc *
umass_scsi_setup(struct umass_softc *sc)
{
	struct umass_scsi_softc *scbus;

	scbus = malloc(sizeof(*scbus), M_DEVBUF, M_WAITOK | M_ZERO);

	sc->bus = scbus;

	scsi_iopool_init(&scbus->sc_iopool, scbus, umass_io_get, umass_io_put);

	/* Fill in the link. */
	scbus->sc_link.adapter_buswidth = 2;
	scbus->sc_link.adapter = &umass_scsi_switch;
	scbus->sc_link.adapter_softc = sc;
	scbus->sc_link.openings = 1;
	scbus->sc_link.quirks |= SDEV_ONLYBIG | sc->sc_busquirks;
	scbus->sc_link.pool = &scbus->sc_iopool;

	return (scbus);
@


1.43
log
@Refactor umass_detach() in order to pass a size to free(9).

Based on a diff from Mathieu <naabed AT poolp DOT org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.42 2015/03/14 03:38:50 jsg Exp $ */
d121 1
a121 1
	scbus->sc_link.luns = 1;
d123 1
a123 1
	scbus->sc_link.flags |= SDEV_ATAPI;
@


1.42
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.41 2014/08/08 14:16:43 mpi Exp $ */
d55 1
a55 1
	struct umassbus_softc	base;
d106 1
a106 2
	scbus->base.sc_child =
	  config_found((struct device *)sc, &saa, scsiprint);
d133 1
a133 2
	scbus->base.sc_child = config_found((struct device *)sc,
	    &saa, scsiprint);
d147 1
a147 1
	sc->bus = (struct umassbus_softc *)scbus;
d163 16
d306 1
a306 1
	struct umass_scsi_softc *scbus = (struct umass_scsi_softc *)sc->bus;
@


1.41
log
@Fix debug printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.40 2013/11/06 14:37:31 pirofti Exp $ */
a44 1
#include <dev/usb/usbdevs.h>
@


1.40
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.39 2013/04/22 01:19:09 deraadt Exp $ */
d103 1
a103 1
			     "sc = 0x%x, scbus = 0x%x\n",
d131 1
a131 1
			     "sc = 0x%x, scbus = 0x%x\n",
d383 1
a383 1
			    "status=0x%x resid=%d\n",
d434 1
a434 1
		"xs->flags=0x%x xs->resid=%d\n", xs->error, xs->status,
@


1.39
log
@correct tv_sec handling in debug code
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.38 2011/07/17 22:46:48 matthew Exp $ */
d215 1
a215 1
	if (sc->sc_dying) {
@


1.38
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.37 2011/07/09 04:37:53 matthew Exp $ */
d209 1
a209 1
	DPRINTF(UDMASS_CMD, ("%s: umass_scsi_cmd: at %lu.%06lu: %d:%d "
d211 1
a211 1
		sc->sc_dev.dv_xname, sc->tv.tv_sec, sc->tv.tv_usec,
d306 2
a307 2
		("umass_scsi_cb: at %lu.%06lu, delta=%u: xs=%p residue=%d"
		 " status=%d\n", tv.tv_sec, tv.tv_usec, delta, xs, residue,
d382 1
a382 1
	DPRINTF(UDMASS_CMD,("umass_scsi_cb: at %lu.%06lu: return error=%d, "
d384 1
a384 1
			    tv.tv_sec, tv.tv_usec,
@


1.37
log
@Switch umass(4) to use a single target scsibus with
SCSI_NO_ADAPTER_TARGET instead of a two target bus with a reserved
"host" target.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.36 2011/07/08 22:09:27 matthew Exp $ */
d65 2
a66 1
#define UMASS_SCSIID_DEVICE	0x00
d94 2
a95 1
	scbus->sc_link.adapter_target = SCSI_NO_ADAPTER_TARGET;
a100 2
	saa.saa_targets = 1;
	saa.saa_luns = sc->maxlun + 1;
d122 2
a123 1
	scbus->sc_link.adapter_target = SCSI_NO_ADAPTER_TARGET;
a128 2
	saa.saa_targets = 1;
	saa.saa_luns = 1;
d155 1
@


1.36
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.35 2011/05/24 20:27:11 matthew Exp $ */
d65 1
a65 2
#define UMASS_SCSIID_HOST	0x00
#define UMASS_SCSIID_DEVICE	0x01
d93 1
a93 1
	scbus->sc_link.adapter_target = UMASS_SCSIID_HOST;
d99 1
a99 1
	saa.saa_targets = 2;
d122 1
a122 1
	scbus->sc_link.adapter_target = UMASS_SCSIID_HOST;
d128 1
a128 1
	saa.saa_targets = 2;
@


1.35
log
@On OpenBSD, we've always attached scsibus(4) to umass(4), even for
ATAPI devices.  atapiscsi(4) is only for handling ATAPI devices on an
ATA bus, so umass(4) shouldn't care about it.

ok krw@@, dlg@@; no objections from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.34 2011/04/19 23:21:15 matthew Exp $ */
a94 1
	scbus->sc_link.luns = sc->maxlun + 1;
d100 2
a123 1
	scbus->sc_link.luns = 1;
d129 2
a156 1
	scbus->sc_link.adapter_buswidth = 2;
@


1.34
log
@Simplify umass devid generation.  Only use the last 12 characters of
the USB serial number so as to limit the overall devid to just 20
characters.

"Lovely!" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.33 2011/04/19 01:21:51 matthew Exp $ */
a32 2
#include "atapiscsi.h"

a57 1
	struct scsi_adapter	sc_adapter;
a67 2
#define UMASS_ATAPI_DRIVE	0

d72 6
a114 1
#if NATAPISCSI > 0
a141 1
#endif
a153 5
	/* Fill in the adapter. */
	scbus->sc_adapter.scsi_cmd = umass_scsi_cmd;
	scbus->sc_adapter.scsi_minphys = umass_scsi_minphys;
	scbus->sc_adapter.dev_probe = umass_scsi_probe;

d156 1
a156 1
	scbus->sc_link.adapter = &scbus->sc_adapter;
@


1.33
log
@Include USB vendor and product ids when manufacturing a unique disk id
from a USB serial number, as recommended by the umass spec.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.32 2011/04/06 15:16:54 dlg Exp $ */
d176 1
a182 8
	if (udi.udi_serial[0] != '\0') {
		char buf[USB_MAX_STRING_LEN + 16];
		size_t len;

		len = snprintf(buf, sizeof(buf), "%04x%04x:%.*s",
		    udi.udi_vendorNo, udi.udi_productNo,
		    sizeof(udi.udi_serial), udi.udi_serial);
		KASSERT(len < sizeof(buf));
d184 12
a195 1
		link->id = devid_alloc(DEVID_SERIAL, DEVID_F_PRINT, len, buf);
@


1.32
log
@add a new "serial" devid type for scsi devices. add code to usb that fakes
it up by using the usb devices iSerial thing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.31 2010/09/21 02:41:24 dlg Exp $ */
d182 10
a191 4
	if (strlen(udi.udi_serial) > 0) {
		link->id = devid_alloc(DEVID_SERIAL, DEVID_F_PRINT, 
		    min(strlen(udi.udi_serial), sizeof(udi.udi_serial)),
		    udi.udi_serial);
@


1.31
log
@umass is set up to only handle one command on the bus at any point
in time, which is a problem if your umass device has multiple luns
on it. if multiple commands are issued at the same time then they
step on some shared state, which in turn causes some interesting
panics.

this diff introduces an iopool in umass so only one command can be
"allocated" and scheduled at a time.

found, reproduced and investigated by krw@@
fix verified by krw@@
ok matthew@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.30 2010/06/28 18:31:02 krw Exp $ */
d73 1
d158 1
d169 20
@


1.30
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.29 2010/05/20 00:55:18 krw Exp $ */
d61 2
d82 3
d152 2
d164 1
d428 27
@


1.29
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.28 2010/03/23 01:57:20 krw Exp $ */
a79 6
struct scsi_device umass_scsi_dev = { NULL, NULL, NULL, NULL, };

#if NATAPISCSI > 0
struct scsi_device umass_atapiscsi_dev = { NULL, NULL, NULL, NULL, };
#endif

a90 1
	scbus->sc_link.device = &umass_scsi_dev;
a119 1
	scbus->sc_link.device = &umass_atapiscsi_dev;
@


1.28
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.27 2010/01/13 11:46:33 krw Exp $ */
d175 1
a175 1
	int cmdlen, dir, s;
a251 1
	s = splbio();
a252 1
	splx(s);
a270 1
	int s;
a374 1
	s = splbio();
a375 1
	splx(s);
a385 1
	int s;
a424 1
	s = splbio();
a425 1
	splx(s);
@


1.27
log
@Fix another long standing double scsi_done() bug. This time when a
POLL'ed command returned a SENSE error. Found on claudio's USB
stick which doesn't like SYNCH CACHE commands.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.26 2010/01/09 23:15:07 krw Exp $ */
d71 1
a71 1
int umass_scsi_cmd(struct scsi_xfer *);
d169 1
a169 1
int
d237 1
a237 1
		return (COMPLETE);
d247 1
a247 1
		return (SUCCESSFULLY_QUEUED);
a254 2

	return (COMPLETE);
@


1.26
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.25 2009/07/02 18:50:37 krw Exp $ */
a173 1

d175 1
a175 1
	int cmdlen, dir, rslt, s;
a234 13
		if (xs->error == XS_NOERROR) {
			switch (sc->polled_xfer_status) {
			case USBD_NORMAL_COMPLETION:
				xs->error = XS_NOERROR;
				break;
			case USBD_TIMEOUT:
				xs->error = XS_TIMEOUT;
				break;
			default:
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
		}
d236 2
a237 2
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done, error=%d\n",
		    xs->error));
d246 1
a251 5
	if (xs->flags & SCSI_POLL)
		rslt = COMPLETE;
	else
		rslt = SUCCESSFULLY_QUEUED;
	
d256 1
a256 1
	return (rslt);
d335 6
d346 4
a360 4
	if (xs->flags & SCSI_POLL)
		return;


d366 14
d418 14
@


1.25
log
@Revert the 'optimization' I attempted in r1.21 since it turns out
that returning COMPLETE for non-SCSI_POLL commands is significant.
Fixes double free of xs and subsequent crashes caused by pulling
out USB media while i/o is active.  Problem analyzed & fix discovered
by hshoexer@@. A more general fix may follow post-4.6.

ok miod@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.24 2009/02/16 21:19:07 miod Exp $ */
a264 1
	xs->flags |= ITSDONE;
a371 1
	xs->flags |= ITSDONE;
a411 2

	xs->flags |= ITSDONE;
@


1.24
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.23 2008/06/26 05:42:19 ray Exp $ */
d176 1
a176 1
	int cmdlen, dir, s;
d266 5
d274 2
a275 1
	return (COMPLETE);
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.22 2008/06/13 04:27:07 krw Exp $ */
d72 1
a72 1
void umass_scsi_minphys(struct buf *);
d273 1
a273 1
umass_scsi_minphys(struct buf *bp)
@


1.22
log
@Merge show_scsi_xs() and show_scsi_cmd() and move invocation so the
debug output shows the xs/command before it's issued rather than
displaying it on command completion. Some commands don't come back
and it would be nice to see their details.

While here nuke invocations of scsi_show* in umass. If you want SCSI
debug output use SCSI debug options.

Only affects SCSI debug output.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.21 2007/10/20 04:37:54 krw Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Doh. Setting ITSDONE and returning SUCCESSFULLY_QUEUED just means
there is another splbio()/splx and a check for ITSDONE before falling
into the COMPLETE case. So just return COMPLETE if the command has
completed (or never started). Simpler all around.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.20 2007/10/20 03:37:05 krw Exp $ */
a195 7

#if defined(USB_DEBUG) && defined(SCSIDEBUG)
	if (umassdebug & UDMASS_SCSI)
		show_scsi_xs(xs);
	else if (umassdebug & ~UDMASS_CMD)
		show_scsi_cmd(xs);
#endif
@


1.20
log
@DO NOT access xs after calling scsi_done(xs). It's not there anymore.

'totally OK' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.19 2007/10/09 23:03:30 krw Exp $ */
d183 1
a183 1
	int cmdlen, dir, rslt, s;
a279 5
	if (xs->flags & SCSI_POLL)
		rslt = COMPLETE;
	else
		rslt = SUCCESSFULLY_QUEUED;
	
d283 1
a283 2

	return (rslt);
@


1.19
log
@malloc+memset(,0,) -> malloc+M_ZERO. 'Fixes' not zeroing of all
allocated memory, as I can't see an obvious initialization of the
memory elsewhere. NetBSD uses M_ZERO here.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.18 2007/06/13 10:33:52 mbalmer Exp $ */
d183 1
a183 1
	int cmdlen, dir, s;
d280 4
d288 2
a289 4
	if (xs->flags & SCSI_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
@


1.18
log
@Remove the definition and use of umass/umass_quirks related macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.17 2007/06/10 14:49:01 mbalmer Exp $ */
d158 1
a158 3
	scbus = malloc(sizeof(struct umass_scsi_softc), M_DEVBUF, M_WAITOK);
	memset(&scbus->sc_link, 0, sizeof(struct scsi_link));
	memset(&scbus->sc_adapter, 0, sizeof(struct scsi_adapter));
@


1.17
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.16 2007/06/10 10:53:48 mbalmer Exp $ */
d173 1
a173 1
	scbus->sc_link.quirks |= PQUIRK_ONLYBIG | sc->sc_busquirks;
d332 1
a332 1
		if (xs->sc_link->quirks & PQUIRK_NOSENSE) {
@


1.16
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.15 2006/11/30 10:05:32 deraadt Exp $ */
d111 1
a111 1
			     USBDEVNAME(sc->sc_dev), sc, scbus));
d141 1
a141 1
			     USBDEVNAME(sc->sc_dev), sc, scbus));
d195 1
a195 1
		USBDEVNAME(sc->sc_dev), sc->tv.tv_sec, sc->tv.tv_usec,
d214 1
a214 1
			USBDEVNAME(sc->sc_dev), sc_link->target));
d381 1
a381 1
		      USBDEVNAME(sc->sc_dev), status);
d424 1
a424 1
			USBDEVNAME(sc->sc_dev), status));
@


1.15
log
@unitialized variable, busted by dlg, fixed by dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.14 2006/11/28 23:59:45 dlg Exp $ */
d117 1
a117 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d147 1
a147 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.14
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.13 2005/05/25 21:12:54 krw Exp $ */
d106 2
@


1.13
log
@PQUIK_NOMODESENSE no longer does anything, and PQUIRK_NOBIGMODESENSE was
defined to be 0. Expunge references. Null entries in quirks table will be
removed later.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.12 2005/05/14 23:36:26 krw Exp $ */
d96 1
d106 1
d113 1
a113 1
	  config_found((struct device *)sc, &scbus->sc_link, scsiprint);
d124 1
d134 3
d142 2
a143 2
	scbus->base.sc_child =
	  config_found((struct device *)sc, &scbus->sc_link, scsiprint);
@


1.12
log
@Try to ensure that UFI/ATAPI USB umass devices always get the zero
padded 12 byte commands mandated by the standard. Adapt the Linux data
length twiddling on certain commands. We used to have some of this in
a different form, curtesy of csapuntz@@, but it got lost in subsequent
merges.

Fixes the USB card reader of Quentin Barnes who provided much testing
and feedback for over a year!

Tested by drahn@@, ok marco@@, 'this is good stuff' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.11 2005/04/27 23:54:44 krw Exp $ */
d165 1
a165 2
	scbus->sc_link.quirks |= PQUIRK_ONLYBIG | PQUIRK_NOMODESENSE |
		sc->sc_busquirks;
a213 6

	if (cmd->opcode == MODE_SENSE &&
	    (sc_link->quirks & SDEV_NOMODESENSE)) {
		xs->error = XS_TIMEOUT;
		goto done;
	}
@


1.11
log
@Add SDEV_UMASS flag, analogous to SDEV_ATAPI, and use it to force a
full LUN scan on UMASS SCSI targets. UMASS provides reliable max lun
information so we shouldn't waste time. Fixes many x-in-1 card
reader/writers that report identical INQUIRY information for every
slot they provide.

Lots of diagnosis and testing by dlg@@, ok dlg@@, 'I can live with this'
marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.10 2005/04/01 06:41:13 pascoe Exp $ */
a366 2
		if (sc->sc_cmd == UMASS_CPROTO_UFI) /* XXX */
			cmdlen = UFI_COMMAND_LENGTH;
@


1.10
log
@Add support for polled umass/SCSI transactions.  Should eliminate the panics
seen at reboot time after writing to umass devices.

ok dlg@@, testing markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.9 2004/07/22 02:40:21 dlg Exp $ */
d102 1
@


1.9
log
@remove an unused var

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.8 2004/07/21 07:43:41 dlg Exp $ */
a68 1
	usbd_status		sc_sync_status;
a174 1
	struct umass_scsi_softc *scbus = (struct umass_scsi_softc *)sc->bus;
a239 1
		/* Use sync transfer. XXX Broken! */
d241 1
d243 1
a243 1
		scbus->sc_sync_status = USBD_INVAL;
d246 1
a246 1
					  xs->timeout, 0, xs);
d249 13
a261 11
				      scbus->sc_sync_status));
		switch (scbus->sc_sync_status) {
		case USBD_NORMAL_COMPLETION:
			xs->error = XS_NOERROR;
			break;
		case USBD_TIMEOUT:
			xs->error = XS_TIMEOUT;
			break;
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
d263 3
a265 1
		goto done;
d383 3
@


1.8
log
@from netbsd, umass.c 1.100 1.113 1.115, umass_scsipi.c 1.11, umassvar.h 1.21
log message for umass 1.98, umass_scsipi.c 1.11, umassvar.h 1.21:
Fix several problems with CCI handling, and enable it: * We were never calling
the callback function when we got a UFI CCI(!). * We were passing a bogus
residual count on non-UFI CCIs. * After a REQUEST SENSE, the UFI CCI may
include the ASC/ASCQ from the sense  information -- don't consider this a
failure.

In addition, remove a horrible hack that was causing us to drop sense
information on the floor and return empty INQUIRY responses, often in the
case where there is a UNIT ATTENTION pending during the INQUIRY.  (Some drives
send the data and then fail, some don't.)

log message for umass.c 1.113:
Do not return STATUS_WIRE_FAILED in response to a CBI stall.  This is perfectly
normal, and is used to report errors.  Instead, use STATUS_CMD_FAILED, which
causes us to do a REQUEST SENSE.  Should address PR 22960.

log message for umass.c 1.115:
Do not do a CBI reset before returning STATUS_CMD_FAILED.  This causes any
sense information to be thrown away, and is therefore nonsensical.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.7 2004/02/21 00:47:42 krw Exp $ */
d178 1
a178 1
	struct scsi_generic *cmd, trcmd;
a183 2

	memset(&trcmd, 0, sizeof(trcmd));
@


1.7
log
@Eliminate the quirks SDEV_NOSTARTUNIT, UMASS_QUIRK_NO_START_STOP, and
UMASS_QUIRK_FORCE_SHORT_INQUIRY. Fixes a bunch of USB devices. Based
on work by Mycroft in NetBSD.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.6 2004/01/14 02:00:41 krw Exp $ */
d359 1
d409 1
a413 10
		if (xs->cmd->opcode == INQUIRY && (xs->resid < xs->datalen ||
		    (sc->sc_quirks & UMASS_QUIRK_RS_NO_CLEAR_UA /* XXX */))) {
			/*
			 * Some drivers return SENSE errors even after INQUIRY.
			 * The upper layer doesn't like that.
			 */
			xs->error = XS_NOERROR;
			break;
		}
		/* XXX look at residue */
@


1.6
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.5 2004/01/10 09:10:51 grange Exp $ */
a73 2
#define SHORT_INQUIRY_LENGTH    36 /* XXX */

a222 18
	}

	if (cmd->opcode == START_STOP &&
	    (sc->sc_quirks & UMASS_QUIRK_NO_START_STOP)) {
		xs->error = XS_NOERROR;
		goto done;
	}

	if (cmd->opcode == INQUIRY &&
	    (sc->sc_quirks & UMASS_QUIRK_FORCE_SHORT_INQUIRY)) {
			/*
			 * Some drives wedge when asked for full inquiry
			 * information.
			 */
		memcpy(&trcmd, cmd, sizeof(trcmd));
		trcmd.bytes[4] = SHORT_INQUIRY_LENGTH;
		cmd = &trcmd;
		xs->datalen = SHORT_INQUIRY_LENGTH;
@


1.5
log
@Make debug printf a real debug.
ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.4 2003/05/17 18:25:51 krw Exp $ */
d129 1
a130 1
	scbus->sc_link.quirks |= SDEV_NOLUNS;
a163 1
	scbus->sc_link.openings = 1;
@


1.4
log
@Mention in the 'status cmd failed' message the scsi command that
failed.

ok nate@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass_scsi.c,v 1.3 2003/05/17 06:07:57 nate Exp $ */
d377 2
a378 2
		printf("umass_scsi_cb: status cmd failed for scsi op 0x%02x\n",
		    xs->cmd->opcode);
@


1.4.4.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.4.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a128 1
	scbus->sc_link.openings = 1;
d130 1
d164 1
d377 2
a378 2
		DPRINTF(UDMASS_CMD, ("umass_scsi_cb: status cmd failed for "
		    "scsi op 0x%02x\n", xs->cmd->opcode));
@


1.4.4.3
log
@Merge with the trunk
@
text
@d74 2
d225 18
@


1.3
log
@sync with NetBSD and add various local hacks to make things work correctly
with our scsi layer
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d377 2
a378 1
		printf("umass_scsi_cb: status cmd failed\n");
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 28
/*	$OpenBSD: umass_scsi.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
/*
 * Copyright (c) 2001 Nathan L. Binkert
 * All rights reserved.
 *
 * Permission to redistribute, use, copy, and modify this software
 * without fee is hereby granted, provided that the following
 * conditions are met:
 *
 * 1. This entire notice is included in all source code copies of any
 *    software which is or includes a copy or modification of this
 *    software.
 * 2. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
a82 2
int umass_scsi_ioctl(struct scsi_link *, u_long cmd, caddr_t addrp, int flag,
		     struct proc *p);
d92 4
d104 2
a105 4

	scbus->sc_adapter.scsi_cmd = umass_scsi_cmd;
	scbus->sc_adapter.scsi_minphys = umass_scsi_minphys;
	scbus->sc_adapter.ioctl = umass_scsi_ioctl;
d111 1
d114 2
d129 3
a131 4

	scbus->sc_adapter.scsi_cmd = umass_scsi_cmd;
	scbus->sc_adapter.scsi_minphys = umass_scsi_minphys;
	scbus->sc_adapter.ioctl = umass_scsi_ioctl;
d137 1
d140 2
d158 5
a164 2
	scbus->sc_link.flags &= ~SDEV_ATAPI;
	scbus->sc_link.device = &umass_scsi_dev;
d168 2
d182 1
a182 1
	int cmdlen, dir;
d236 4
d243 1
d273 1
a273 1
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n", 
d302 1
d304 1
a319 20
int
umass_scsi_ioctl(struct scsi_link *link, u_long cmd, caddr_t arg, int flag,
		 struct proc *p)
{
#if 0
	struct umass_softc *sc = link->adapter_softc;
#endif

	switch (cmd) {
#if 0
	case SCBUSIORESET:
		ccb->ccb_h.status = CAM_REQ_INPROG;
		umass_reset(sc, umass_cam_cb, (void *) ccb);
		return (0);
#endif
	default:
		return (ENOTTY);
	}
}

d349 1
d377 1
d399 1
a399 1
		panic("%s: Unknown status %d in umass_scsi_cb\n",
d403 2
d415 1
a415 1
/* 
d454 1
a454 1
	xs->status |= ITSDONE;
d457 1
a457 1
		"xs->status=0x%x xs->resid=%d\n", xs->error, xs->status,
d464 1
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

