head	1.37;
access;
symbols
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.18.0.4
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	SMP:1.4.0.2
	UBC_SYNC_A:1.2
	UBC_SYNC_B:1.2;
locks; strict;
comment	@ * @;


1.37
date	2016.10.02.06.36.39;	author kettenis;	state Exp;
branches;
next	1.36;
commitid	IMFyKh2keS7O5Fww;

1.36
date	2015.11.02.14.55.41;	author mpi;	state Exp;
branches;
next	1.35;
commitid	vJlf2yHM5thwrjmA;

1.35
date	2015.04.10.13.56.42;	author mpi;	state Exp;
branches;
next	1.34;
commitid	NEEggNm5YeE2QUZC;

1.34
date	2014.09.01.08.13.02;	author mpi;	state Exp;
branches;
next	1.33;
commitid	J2I4AIhHGYjRpuoh;

1.33
date	2014.08.30.09.33.11;	author mpi;	state Exp;
branches;
next	1.32;
commitid	jlL5Vn6KFEAcR9aL;

1.32
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.29.12.45.29;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.27.14.48.10;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.07.10.15.15;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.01.12.00.54;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.12.11.42.01;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2012.10.09.13.41.04;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.12.17.39.51;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.29.20.06.38;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.17;

1.17
date	2008.10.30.08.11.13;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.09.22.59.20;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.09.23.21.48;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.20.00.52.26;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.14.00.41.11;	author pascoe;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.08.09.32;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.07.11.12.04;	author pascoe;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.29.01.52.27;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.20.12.45.31;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.19.08.10.27;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.30.01.25.17;	author tedu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.05.23.03.23.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.4.2.1
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Save and restore the (non-standard) USBMODE register around a reset of the
controller.  This register controls whether the controller is in device or
host mode on many dual role controllers and gets reset during a reset of
the controller, placing the controller in (non-functional) idle mode.  By
saving and restoring it, we keep the controller in host mode.  Since this is
a non-standard register, add a new EHCIF_USBMODE flag and only do the save and
restore if it has been set.

Makes the upper "OTG" port of the Cubox-i work.

ok mpi@@, jsg@@
@
text
@/*	$OpenBSD: ehcivar.h,v 1.36 2015/11/02 14:55:41 mpi Exp $ */
/*	$NetBSD: ehcivar.h,v 1.19 2005/04/29 15:04:29 augustss Exp $	*/

/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

struct ehci_soft_qtd {
	struct ehci_qtd qtd;
	struct ehci_soft_qtd *nextqtd; /* mirrors nextqtd in TD */
	ehci_physaddr_t physaddr;
	struct usb_dma dma;             /* qTD's DMA infos */
	int offs;                       /* qTD's offset in struct usb_dma */
	LIST_ENTRY(ehci_soft_qtd) hnext;
	u_int16_t len;
};
#define EHCI_SQTD_SIZE ((sizeof (struct ehci_soft_qtd) + EHCI_QTD_ALIGN - 1) / EHCI_QTD_ALIGN * EHCI_QTD_ALIGN)
#define EHCI_SQTD_CHUNK (EHCI_PAGE_SIZE / EHCI_SQTD_SIZE)

struct ehci_soft_qh {
	struct ehci_qh qh;
	struct ehci_soft_qh *next;
	struct ehci_soft_qh *prev;
	struct ehci_soft_qtd *sqtd;
	ehci_physaddr_t physaddr;
	struct usb_dma dma;             /* QH's DMA infos */
	int offs;                       /* QH's offset in struct usb_dma */
	int islot;
};
#define EHCI_SQH_SIZE ((sizeof (struct ehci_soft_qh) + EHCI_QH_ALIGN - 1) / EHCI_QH_ALIGN * EHCI_QH_ALIGN)
#define EHCI_SQH_CHUNK (EHCI_PAGE_SIZE / EHCI_SQH_SIZE)

struct ehci_soft_itd {
	union {
		struct ehci_itd itd;
		struct ehci_sitd sitd;
	};
	union {
		struct {
			/* soft_itds links in a periodic frame*/
			struct ehci_soft_itd *next;
			struct ehci_soft_itd *prev;
		} frame_list;
		/* circular list of free itds */
		LIST_ENTRY(ehci_soft_itd) free_list;
	} u;
	struct ehci_soft_itd *xfer_next; /* Next soft_itd in xfer */
	ehci_physaddr_t physaddr;
	struct usb_dma dma;
	int offs;
	int slot;
	struct timeval t; /* store free time */
};
#define EHCI_ITD_SIZE ((sizeof(struct ehci_soft_itd) + EHCI_QH_ALIGN - 1) / EHCI_ITD_ALIGN * EHCI_ITD_ALIGN)
#define EHCI_ITD_CHUNK (EHCI_PAGE_SIZE / EHCI_ITD_SIZE)

struct ehci_xfer {
	struct usbd_xfer	xfer;
	TAILQ_ENTRY(ehci_xfer)	inext;		/* List of active xfers */
	union {
		struct {
			struct ehci_soft_qtd *start, *end;
		} sqtd;				/* Ctrl/Bulk/Interrupt TD */
		struct {
			struct ehci_soft_itd *start, *end;
		} itd;				/* Isochronous TD */
	} _TD;
#define sqtdstart	_TD.sqtd.start
#define sqtdend		_TD.sqtd.end
#define itdstart	_TD.itd.start
#define itdend		_TD.itd.end

	uint32_t		ehci_xfer_flags;
#ifdef DIAGNOSTIC
	int isdone;
#endif
};
#define EHCI_XFER_ABORTING	0x0001	/* xfer is aborting. */
#define EHCI_XFER_ABORTWAIT	0x0002	/* abort completion is being awaited. */

/* Information about an entry in the interrupt list. */
struct ehci_soft_islot {
	struct ehci_soft_qh *sqh;	/* Queue Head. */
};

#define EHCI_FRAMELIST_MAXCOUNT	1024
#define EHCI_IPOLLRATES		8 /* Poll rates (1ms, 2, 4, 8 .. 128) */
#define EHCI_INTRQHS		((1 << EHCI_IPOLLRATES) - 1)
#define EHCI_IQHIDX(lev, pos) \
	((((pos) & ((1 << (lev)) - 1)) | (1 << (lev))) - 1)
#define EHCI_ILEV_IVAL(lev)	(1 << (lev))


#define EHCI_HASH_SIZE 128
#define EHCI_COMPANION_MAX 8

#define EHCI_FREE_LIST_INTERVAL 100

struct ehci_softc {
	struct usbd_bus sc_bus;		/* base device */
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_size_t sc_size;
	u_int sc_offs;			/* offset to operational regs */
	int sc_flags;			/* misc flags */
#define EHCIF_DROPPED_INTR_WORKAROUND	0x01
#define EHCIF_PCB_INTR			0x02
#define EHCIF_USBMODE			0x04

	char sc_vendor[16];		/* vendor string for root hub */
	int sc_id_vendor;		/* vendor ID for root hub */

	struct usb_dma sc_fldma;
	ehci_link_t *sc_flist;
	u_int sc_flsize;

	struct ehci_soft_islot sc_islots[EHCI_INTRQHS];

	/* jcmm - an array matching sc_flist, but with software pointers,
	 * not hardware address pointers
	 */
	struct ehci_soft_itd **sc_softitds;

	TAILQ_HEAD(, ehci_xfer) sc_intrhead;

	struct ehci_soft_qh *sc_freeqhs;
	struct ehci_soft_qtd *sc_freeqtds;
	LIST_HEAD(sc_freeitds, ehci_soft_itd) sc_freeitds;

	int sc_noport;
	u_int8_t sc_conf;		/* device configuration */
	struct usbd_xfer *sc_intrxfer;
	char sc_isreset;
	char sc_softwake;

	u_int32_t sc_eintrs;
	struct ehci_soft_qh *sc_async_head;

	struct rwlock sc_doorbell_lock;

	struct timeout sc_tmo_intrlist;
};

#define EREAD1(sc, a) bus_space_read_1((sc)->iot, (sc)->ioh, (a))
#define EREAD2(sc, a) bus_space_read_2((sc)->iot, (sc)->ioh, (a))
#define EREAD4(sc, a) bus_space_read_4((sc)->iot, (sc)->ioh, (a))
#define EWRITE1(sc, a, x) bus_space_write_1((sc)->iot, (sc)->ioh, (a), (x))
#define EWRITE2(sc, a, x) bus_space_write_2((sc)->iot, (sc)->ioh, (a), (x))
#define EWRITE4(sc, a, x) bus_space_write_4((sc)->iot, (sc)->ioh, (a), (x))
#define EOREAD1(sc, a) bus_space_read_1((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
#define EOREAD2(sc, a) bus_space_read_2((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
#define EOREAD4(sc, a) bus_space_read_4((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a))
#define EOWRITE1(sc, a, x) bus_space_write_1((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))
#define EOWRITE2(sc, a, x) bus_space_write_2((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))
#define EOWRITE4(sc, a, x) bus_space_write_4((sc)->iot, (sc)->ioh, (sc)->sc_offs+(a), (x))

usbd_status	ehci_init(struct ehci_softc *);
int		ehci_intr(void *);
int		ehci_detach(struct device *, int);
int		ehci_activate(struct device *, int);
usbd_status	ehci_reset(struct ehci_softc *);

@


1.36
log
@Delay root hub interrupt processing to the soft-interrupt path in order
to mark ehci_intr() as IPL_MPSAFE.

Earlier version tested by ratchov@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.35 2015/04/10 13:56:42 mpi Exp $ */
d133 1
@


1.35
log
@Full-speed isochronous transfers support with opportunistic micro-frames
scheduling.

More work is required to properly budget and schedule micro-frames, most
of it at the HUB level.  But this let people use USB1.1 uaudio(4) devices
on ehci(4)-only systems.

Thanks to all the testers!

ok ratchov@@, sthen@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.34 2014/09/01 08:13:02 mpi Exp $ */
d132 1
@


1.34
log
@Revert previous, it puts too much pressure on memory allocation as
reported by Bryan Linton on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.33 2014/08/30 09:33:11 mpi Exp $ */
d59 4
a62 1
	struct ehci_itd itd;
d83 16
a98 7
	struct usbd_xfer xfer;
	TAILQ_ENTRY(ehci_xfer) inext; /* list of active xfers */
	struct ehci_soft_qtd *sqtdstart;
	struct ehci_soft_qtd *sqtdend;
	struct ehci_soft_itd *itdstart;
	struct ehci_soft_itd *itdend;
	u_int32_t ehci_xfer_flags;
@


1.33
log
@Rewrite how queue heads are inserted and removed from the asynchronous
list.  Use a queue head per xfer and no longer per pipe.  Since queue
heads are now setup when a transfer is submited we do not need to open
the control pipe more than once.  This also simplify transfer abortion.

Tested by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.32 2014/05/16 18:17:03 mpi Exp $ */
a81 1
	struct ehci_soft_qh *sqh;
@


1.32
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.31 2014/04/29 12:45:29 mpi Exp $ */
d82 1
@


1.31
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.

With inputs from mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.30 2014/04/27 14:48:10 mpi Exp $ */
a152 2

	struct device *sc_child;		/* /dev/usb# device */
d170 1
a170 1
int		ehci_detach(struct ehci_softc *, int);
@


1.30
log
@Start de-obfuscating the HC drivers.

Since pipe methods have an xfer argument, always use it to get acces to
various data structure (pipe, bus, device) instead of having a different
way to get a pointer to these descriptors in every function.

Also kill the {E,U}XFER() macro and use a consistent name accross all the
methods for {e,u}hci_xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.29 2014/03/25 20:27:37 mpi Exp $ */
a148 2

	SIMPLEQ_HEAD(, usbd_xfer) sc_free_xfers; /* free xfers */
@


1.29
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.28 2013/11/07 10:15:15 mpi Exp $ */
a92 2

#define EXFER(xfer) ((struct ehci_xfer *)(xfer))
@


1.28
log
@Remove isoc_len from the transfer descriptor, it is assigned once but
never read.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.27 2013/11/01 12:00:54 mpi Exp $ */
a143 1
	u_int8_t sc_addr;		/* device address */
@


1.27
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.26 2013/06/12 11:42:01 mpi Exp $ */
a85 1
	u_int isoc_len;
@


1.26
log
@Rework of the suspend/resume logic.

Do not places the ports into suspend mode now that we detach/attach
all USB devicess during a suspend/resume cycle.

Emit a reset when reinitializing the controller after resume and
try to use the same logic as in ehci_init().

Correctly wait for the controller to set the HCHalted bit to one
before attempting a reset.

Tested by many and have been in snap for a week.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.25 2013/04/15 09:23:01 mglocker Exp $ */
a80 1
	struct usb_task	abort_task;
@


1.25
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.24 2012/10/09 13:41:04 deraadt Exp $ */
a127 2
	u_int32_t sc_cmd;		/* shadow of cmd reg during suspend */

d181 2
a182 1
void		ehci_shutdown(void *);
@


1.24
log
@Our arc4random() is safe to use in any context, so we don't the crazy
fake randomizer for pre-boot.  We still need better interrupt scheduling,
but this makes that more clear.
ok yuo mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.23 2012/10/08 21:47:50 deraadt Exp $ */
d33 2
a34 2
typedef struct ehci_soft_qtd {
	ehci_qtd_t qtd;
d37 2
a38 2
	usb_dma_t dma;                  /* qTD's DMA infos */
	int offs;                       /* qTD's offset in usb_dma_t */
d41 1
a41 1
} ehci_soft_qtd_t;
d45 2
a46 2
typedef struct ehci_soft_qh {
	ehci_qh_t qh;
d51 2
a52 2
	usb_dma_t dma;                  /* QH's DMA infos */
	int offs;                       /* QH's offset in usb_dma_t */
d54 1
a54 1
} ehci_soft_qh_t;
d58 2
a59 2
typedef struct ehci_soft_itd {
	ehci_itd_t itd;
d71 1
a71 1
	usb_dma_t dma;
d75 1
a75 1
} ehci_soft_itd_t;
d83 4
a86 4
	ehci_soft_qtd_t *sqtdstart;
	ehci_soft_qtd_t *sqtdend;
	ehci_soft_itd_t *itdstart;
	ehci_soft_itd_t *itdend;
d100 1
a100 1
	ehci_soft_qh_t *sqh;	/* Queue Head. */
d116 1
a116 1
typedef struct ehci_softc {
d130 1
a130 1
	usb_dma_t sc_fldma;
d143 2
a144 2
	ehci_soft_qh_t *sc_freeqhs;
	ehci_soft_qtd_t *sc_freeqtds;
d150 1
a150 1
	usbd_xfer_handle sc_intrxfer;
d155 1
a155 1
	ehci_soft_qh_t *sc_async_head;
d164 1
a164 1
} ehci_softc_t;
d179 1
a179 1
usbd_status	ehci_init(ehci_softc_t *);
d181 1
a181 1
int		ehci_detach(ehci_softc_t *, int);
@


1.23
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.22 2012/05/12 17:39:51 mpi Exp $ */
a132 1
	u_int sc_rand;			/* XXX need proper intr scheduling */
@


1.22
log
@Remove unused xfer pointer from the qTD structure.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.21 2010/12/14 16:13:16 jakemsr Exp $ */
a128 1
	void *sc_shutdownhook;		/* cookie from shutdown hook */
@


1.21
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.20 2010/09/29 20:06:38 kettenis Exp $ */
a38 1
	usbd_xfer_handle xfer;
@


1.20
log
@Add DMA sync operations.  Fixes problems on macppc with gcc4 because
apparently it reorders stores in a bad way.  Mostly from NetBSD.

earlier diff tested by landry@@ (who noticed the problems on macppc)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.19 2010/09/07 16:21:46 deraadt Exp $ */
a166 2

	char sc_dying;
@


1.19
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.18 2009/10/13 19:33:17 pirofti Exp $ */
d37 2
d52 2
@


1.18
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.17 2008/10/30 08:11:13 mglocker Exp $ */
a125 1
	void *sc_powerhook;		/* cookie from power hook */
@


1.17
log
@From Jeremy Morse via NetBSD:

  * Serialize access to the ehci intrlist.
  * Change the ehci intrlist to a tailq so xfers are not queued out of order.
  * In ehci_check_itd_intr, don't treat a transfer error as an indication
    that the xfer is no longer active.

This also fixes "ehci_allocx not free" errors seen recently.

Tested and OK brad@@, kevlo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.16 2008/08/09 22:59:20 mglocker Exp $ */
d184 1
a184 1
int		ehci_activate(struct device *, enum devact);
@


1.16
log
@Add isochronous xfer support for ehci(4).  From NetBSD.

OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.15 2008/06/26 05:42:18 ray Exp $ */
d79 1
a79 1
	LIST_ENTRY(ehci_xfer) inext; /* list of active xfers */
d141 1
a141 1
	LIST_HEAD(, ehci_xfer) sc_intrhead;
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.14 2008/06/09 23:21:48 kettenis Exp $ */
d55 21
d82 3
d111 2
d136 5
d145 1
@


1.14
log
@Don't play games with the PCD interrupt.  It delays the detection of
connect/disconnect events.  From NetBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.13 2007/06/12 16:26:36 mbalmer Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.12 2007/06/10 10:15:35 mbalmer Exp $ */
a135 1
	struct timeout sc_tmo_pcd;
@


1.12
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.11 2007/05/20 00:52:26 jsg Exp $ */
d139 1
a139 1
	device_ptr_t sc_child;		/* /dev/usb# device */
d160 1
a160 1
int		ehci_activate(device_ptr_t, enum devact);
@


1.11
log
@Convert ehci and ucom to rwlock.
Kill the usb specific lockmgr wrapper as nothing uses it now.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.10 2006/08/14 00:41:11 pascoe Exp $ */
d136 2
a137 2
	usb_callout_t sc_tmo_pcd;
	usb_callout_t sc_tmo_intrlist;
@


1.10
log
@Pull in abort path code from FreeBSD.  Without this, the hardware data toggle
code doesn't work correctly when errored transactions occur.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.9 2005/04/11 08:09:32 dlg Exp $ */
d134 1
a134 1
	struct lock sc_doorbell_lock;
@


1.9
log
@get rid of the lines on ehci attach that show the version and the companion
controllers. remove the insane amount of support code needed just for the
printing of the companion controllers while here.

zap it deraadt@@ sure pascoe@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ehcivar.h,v 1.8 2005/03/07 11:12:04 pascoe Exp $ */
/*	$NetBSD: ehcivar.h,v 1.12 2001/12/31 12:16:57 augustss Exp $	*/
d54 1
d68 1
d73 3
@


1.8
log
@Add a workaround for VIA EHCI controllers which, under load, signal qTD
completion before they have performed writeback from the overlay qTD.

This condition would exhibit itself as a umass stall that never recovers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.7 2004/12/29 01:52:27 dlg Exp $ */
a103 4

	u_int sc_ncomp;
	u_int sc_npcomp;
	struct usbd_bus *sc_comps[EHCI_COMPANION_MAX];
@


1.7
log
@from freebsd: ehci.c 1.13, ehci_pci.c 1.13, ehcireg.h 1.5, ehcivar.h 1.3
log message:
Attempt to follow the correct procedure for synchronising with the
system BIOS to disable legacy device emulation as per the "EHCI
Extended Capability: Pre-OS to OS Handoff Synchronisation" section
of the EHCI spec. BIOSes that implement legacy emulation using SMIs
are supposed to disable the emulation when this procedure is performed.

tested on various archs by jsg@@ and me
ok pascoe@@, looks sane jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.6 2004/10/20 12:45:31 dlg Exp $ */
d95 2
d136 1
@


1.6
log
@interrupt transfer support on usb2 controllers. allows the use of usb2 hubs
with usb2 hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.5 2004/10/19 08:10:27 dlg Exp $ */
d157 1
@


1.5
log
@suspend/resume support

while here define EHCI_DEBUG when USB_DEBUG is defined

ok pvalchev@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehcivar.h,v 1.4 2004/05/30 01:25:17 tedu Exp $ */
d56 1
d73 12
d108 1
d110 3
@


1.4
log
@rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d86 1
@


1.4.2.1
log
@Merge with the trunk
@
text
@@


1.3
log
@ehci support; hacked into working shape by jonathon@@gateway.zenbu.net
@
text
@d1 1
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@a0 1
/*	$OpenBSD: ehcivar.h,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

