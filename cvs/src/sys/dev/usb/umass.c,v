head	1.74;
access;
symbols
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.72.0.6
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.62.0.8
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.6
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.4
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.59.0.4
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.6
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.4
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.4
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.19
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	SMP:1.10.0.4
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6;
locks; strict;
comment	@ * @;


1.74
date	2017.01.09.14.44.28;	author mpi;	state Exp;
branches;
next	1.73;
commitid	UdDbQS8WFHHpnq1k;

1.73
date	2016.08.03.13.44.49;	author krw;	state Exp;
branches;
next	1.72;
commitid	Cz1z8WXhaZRZXnHz;

1.72
date	2015.12.17.10.21.22;	author mpi;	state Exp;
branches;
next	1.71;
commitid	unfDajHXUXdPNJvg;

1.71
date	2015.12.16.14.50.26;	author mpi;	state Exp;
branches;
next	1.70;
commitid	Hjg9j5O0F4eVYCbh;

1.70
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.69;
commitid	p4LJxGKbi0BU2cG6;

1.69
date	2015.01.27.11.04.45;	author mpi;	state Exp;
branches;
next	1.68;
commitid	qILRbx7OvaXPTqUW;

1.68
date	2015.01.18.14.40.05;	author mpi;	state Exp;
branches;
next	1.67;
commitid	LnSZXa3jV9gqkB89;

1.67
date	2014.08.21.14.52.56;	author mpi;	state Exp;
branches;
next	1.66;
commitid	nyUgTgf8DHNH5RDf;

1.66
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.65;
commitid	OBNa5kfxQ2UXoiIw;

1.65
date	2013.11.06.14.37.31;	author pirofti;	state Exp;
branches;
next	1.64;

1.64
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.62;

1.62
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.61;

1.61
date	2011.05.24.20.27.11;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2008.09.25.11.07.12;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.56;

1.56
date	2008.05.18.17.15.41;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2008.02.03.00.36.29;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.15.19.22.18;	author bluhm;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.14.06.55.10;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.13.10.33.52;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.01.06.12.20;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.24.04.51.04;	author pascoe;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.15.00.23.33;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.14.23.36.26;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2005.04.01.06.41.13;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.28.04.46.33;	author pascoe;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.28.04.40.15;	author pascoe;	state Exp;
branches;
next	1.36;

1.36
date	2004.07.21.08.01.30;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.21.07.57.27;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.21.07.55.51;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.21.07.51.04;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.21.07.49.07;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2004.07.21.07.48.04;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.21.07.46.55;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.21.07.43.41;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.17.06.04.00;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.15.05.48.09;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.08.00.24.13;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2003.11.07.11.10.47;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.17.06.07.57;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.05.22.41.36;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.15.20.53.32;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.21.00.34.34;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.25.16.13.39;	author drahn;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.05.24.06.21.44;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.24.00.06.32;	author mickey;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.01.29.02.31.06;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.23.08.55.34;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.20.07.34.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.14.22.50.28;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.08.20.28.07;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.08.20.03.34;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.08.19.10.48;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.04.22.51.23;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.31.22.11.37;	author aaron;	state Exp;
branches;
next	;

1.10.4.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.07.04.10.43.57;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.10.4.6;

1.10.4.6
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.10.4.7;

1.10.4.7
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.10.4.8;

1.10.4.8
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.10.4.9;

1.10.4.9
date	2004.06.08.21.07.27;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.22.24.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Remove unneeded <sys/malloc.h> from Michael W. Bombardieri.
@
text
@/*	$OpenBSD: umass.c,v 1.73 2016/08/03 13:44:49 krw Exp $ */
/*	$NetBSD: umass.c,v 1.116 2004/06/30 05:53:46 mycroft Exp $	*/

/*
 * Copyright (c) 2003 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1999 MAEKAWA Masahide <bishop@@rr.iij4u.or.jp>,
 *		      Nick Hibma <n_hibma@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *     $FreeBSD: src/sys/dev/usb/umass.c,v 1.13 2000/03/26 01:39:12 n_hibma Exp $
 */

/*
 * Universal Serial Bus Mass Storage Class specs:
 * http://www.usb.org/developers/devclass_docs/usb_msc_overview_1.2.pdf
 * http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
 * http://www.usb.org/developers/devclass_docs/usb_msc_cbi_1.1.pdf
 * http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
 */

/*
 * Ported to NetBSD by Lennart Augustsson <augustss@@NetBSD.org>.
 * Parts of the code written by Jason R. Thorpe <thorpej@@shagadelic.org>.
 */

/*
 * The driver handles 3 Wire Protocols
 * - Command/Bulk/Interrupt (CBI)
 * - Command/Bulk/Interrupt with Command Completion Interrupt (CBI with CCI)
 * - Mass Storage Bulk-Only (BBB)
 *   (BBB refers Bulk/Bulk/Bulk for Command/Data/Status phases)
 *
 * Over these wire protocols it handles the following command protocols
 * - SCSI
 * - 8070 (ATA/ATAPI for rewritable removable media)
 * - UFI (USB Floppy Interface)
 *
 * 8070i is a transformed version of the SCSI command set. UFI is a transformed
 * version of the 8070i command set.  The sc->transform method is used to
 * convert the commands into the appropriate format (if at all necessary).
 * For example, ATAPI requires all commands to be 12 bytes in length amongst
 * other things.
 *
 * The source code below is marked and can be split into a number of pieces
 * (in this order):
 *
 * - probe/attach/detach
 * - generic transfer routines
 * - BBB
 * - CBI
 * - CBI_I (in addition to functions from CBI)
 * - CAM (Common Access Method)
 * - SCSI
 * - UFI
 * - 8070i
 *
 * The protocols are implemented using a state machine, for the transfers as
 * well as for the resets. The state machine is contained in umass_*_state.
 * The state machine is started through either umass_*_transfer or
 * umass_*_reset.
 *
 * The reason for doing this is a) CAM performs a lot better this way and b) it
 * avoids using tsleep from interrupt context (for example after a failed
 * transfer).
 */

/*
 * The SCSI related part of this driver has been derived from the
 * dev/ppbus/vpo.c driver, by Nicolas Souchu (nsouch@@freebsd.org).
 *
 * The CAM layer uses so called actions which are messages sent to the host
 * adapter for completion. The actions come in through umass_cam_action. The
 * appropriate block of routines is called depending on the transport protocol
 * in use. When the transfer has finished, these routines call
 * umass_cam_cb again to complete the CAM command.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/timeout.h>
#undef KASSERT
#define KASSERT(cond, msg)
#include <machine/bus.h>

#include <scsi/scsi_all.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#include <dev/usb/umassvar.h>
#include <dev/usb/umass_quirks.h>
#include <dev/usb/umass_scsi.h>


#ifdef UMASS_DEBUG
int umassdebug = 0;

char *states[TSTATE_STATES+1] = {
	/* should be kept in sync with the list at transfer_state */
	"Idle",
	"BBB CBW",
	"BBB Data",
	"BBB Data bulk-in/-out clear stall",
	"BBB CSW, 1st attempt",
	"BBB CSW bulk-in clear stall",
	"BBB CSW, 2nd attempt",
	"BBB Reset",
	"BBB bulk-in clear stall",
	"BBB bulk-out clear stall",
	"CBI Command",
	"CBI Data",
	"CBI Status",
	"CBI Data bulk-in/-out clear stall",
	"CBI Status intr-in clear stall",
	"CBI Reset",
	"CBI bulk-in clear stall",
	"CBI bulk-out clear stall",
	NULL
};
#endif

/* USB device probe/attach/detach functions */
int umass_match(struct device *, void *, void *); 
void umass_attach(struct device *, struct device *, void *); 
int umass_detach(struct device *, int); 

struct cfdriver umass_cd = { 
	NULL, "umass", DV_DULL 
}; 

const struct cfattach umass_ca = {
	sizeof(struct umass_softc), umass_match, umass_attach, umass_detach
};

void umass_disco(struct umass_softc *sc);

/* generic transfer functions */
usbd_status umass_polled_transfer(struct umass_softc *sc,
				struct usbd_xfer *xfer);
usbd_status umass_setup_transfer(struct umass_softc *sc,
				struct usbd_pipe *pipe,
				void *buffer, int buflen, int flags,
				struct usbd_xfer *xfer);
usbd_status umass_setup_ctrl_transfer(struct umass_softc *sc,
				usb_device_request_t *req,
				void *buffer, int buflen, int flags,
				struct usbd_xfer *xfer);
void umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
				struct usbd_xfer *xfer);
void umass_adjust_transfer(struct umass_softc *);
#if 0
void umass_reset(struct umass_softc *sc,	transfer_cb_f cb, void *priv);
#endif

/* Bulk-Only related functions */
void umass_bbb_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
void umass_bbb_reset(struct umass_softc *, int);
void umass_bbb_state(struct usbd_xfer *, void *, usbd_status);

u_int8_t umass_bbb_get_max_lun(struct umass_softc *);

/* CBI related functions */
void umass_cbi_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
void umass_cbi_reset(struct umass_softc *, int);
void umass_cbi_state(struct usbd_xfer *, void *, usbd_status);

int umass_cbi_adsc(struct umass_softc *, char *, int, struct usbd_xfer *);

const struct umass_wire_methods umass_bbb_methods = {
	umass_bbb_transfer,
	umass_bbb_reset,
	umass_bbb_state
};

const struct umass_wire_methods umass_cbi_methods = {
	umass_cbi_transfer,
	umass_cbi_reset,
	umass_cbi_state
};

#ifdef UMASS_DEBUG
/* General debugging functions */
void umass_bbb_dump_cbw(struct umass_softc *sc,
				struct umass_bbb_cbw *cbw);
void umass_bbb_dump_csw(struct umass_softc *sc,
				struct umass_bbb_csw *csw);
void umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer,
				int buflen, int printlen);
#endif


/*
 * USB device probe/attach/detach
 */

int
umass_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	const struct umass_quirk *quirk;
	usb_interface_descriptor_t *id;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL)
		return (quirk->uq_match);

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_MASS)
		return (UMATCH_NONE);

	switch (id->bInterfaceSubClass) {
	case UISUBCLASS_RBC:
	case UISUBCLASS_SFF8020I:
	case UISUBCLASS_QIC157:
	case UISUBCLASS_UFI:
	case UISUBCLASS_SFF8070I:
	case UISUBCLASS_SCSI:
		break;
	default:
		return (UMATCH_IFACECLASS);
	}

	switch (id->bInterfaceProtocol) {
	case UIPROTO_MASS_CBI_I:
	case UIPROTO_MASS_CBI:
	case UIPROTO_MASS_BBB_OLD:
	case UIPROTO_MASS_BBB:
		break;
	default:
		return (UMATCH_IFACECLASS_IFACESUBCLASS);
	}

	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
}

void
umass_attach(struct device *parent, struct device *self, void *aux)
{
	struct umass_softc *sc = (struct umass_softc *)self;
	struct usb_attach_arg *uaa = aux;
	const struct umass_quirk *quirk;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	const char *sWire, *sCommand;
	usbd_status err;
	int i, bno, error;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_ifaceno = uaa->ifaceno;

	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL) {
		sc->sc_wire = quirk->uq_wire;
		sc->sc_cmd = quirk->uq_cmd;
		sc->sc_quirks = quirk->uq_flags;
		sc->sc_busquirks = quirk->uq_busquirks;

		if (quirk->uq_fixup != NULL)
			(*quirk->uq_fixup)(sc);
	} else {
		sc->sc_wire = UMASS_WPROTO_UNSPEC;
		sc->sc_cmd = UMASS_CPROTO_UNSPEC;
		sc->sc_quirks = 0;
		sc->sc_busquirks = 0;
	}

	id = usbd_get_interface_descriptor(sc->sc_iface);
	if (id == NULL)
		return;

	if (sc->sc_wire == UMASS_WPROTO_UNSPEC) {
		switch (id->bInterfaceProtocol) {
		case UIPROTO_MASS_CBI:
			sc->sc_wire = UMASS_WPROTO_CBI;
			break;
		case UIPROTO_MASS_CBI_I:
			sc->sc_wire = UMASS_WPROTO_CBI_I;
			break;
		case UIPROTO_MASS_BBB:
		case UIPROTO_MASS_BBB_OLD:
			sc->sc_wire = UMASS_WPROTO_BBB;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported wire protocol %u\n",
				sc->sc_dev.dv_xname,
				id->bInterfaceProtocol));
			return;
		}
	}

	if (sc->sc_cmd == UMASS_CPROTO_UNSPEC) {
		switch (id->bInterfaceSubClass) {
		case UISUBCLASS_SCSI:
			sc->sc_cmd = UMASS_CPROTO_SCSI;
			break;
		case UISUBCLASS_UFI:
			sc->sc_cmd = UMASS_CPROTO_UFI;
			break;
		case UISUBCLASS_SFF8020I:
		case UISUBCLASS_SFF8070I:
		case UISUBCLASS_QIC157:
			sc->sc_cmd = UMASS_CPROTO_ATAPI;
			break;
		case UISUBCLASS_RBC:
			sc->sc_cmd = UMASS_CPROTO_RBC;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported command protocol %u\n",
				sc->sc_dev.dv_xname,
				id->bInterfaceSubClass));
			return;
		}
	}

	switch (sc->sc_wire) {
	case UMASS_WPROTO_CBI:
		sWire = "CBI";
		break;
	case UMASS_WPROTO_CBI_I:
		sWire = "CBI with CCI";
		break;
	case UMASS_WPROTO_BBB:
		sWire = "Bulk-Only";
		break;
	default:
		sWire = "unknown";
		break;
	}

	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
		sCommand = "RBC";
		break;
	case UMASS_CPROTO_SCSI:
		sCommand = "SCSI";
		break;
	case UMASS_CPROTO_UFI:
		sCommand = "UFI";
		break;
	case UMASS_CPROTO_ATAPI:
		sCommand = "ATAPI";
		break;
	case UMASS_CPROTO_ISD_ATA:
		sCommand = "ISD-ATA";
		break;
	default:
		sCommand = "unknown";
		break;
	}

	printf("%s: using %s over %s\n", sc->sc_dev.dv_xname, sCommand,
	       sWire);

	if (quirk != NULL && quirk->uq_init != NULL) {
		err = (*quirk->uq_init)(sc);
		if (err) {
			umass_disco(sc);
			return;
		}
	}

	/*
	 * In addition to the Control endpoint the following endpoints
	 * are required:
	 * a) bulk-in endpoint.
	 * b) bulk-out endpoint.
	 * and for Control/Bulk/Interrupt with CCI (CBI_I)
	 * c) intr-in
	 *
	 * The endpoint addresses are not fixed, so we have to read them
	 * from the device descriptors of the current interface.
	 */
	for (i = 0 ; i < id->bNumEndpoints ; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: could not read endpoint descriptor\n",
			       sc->sc_dev.dv_xname);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
			sc->sc_epaddr[UMASS_BULKIN] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT
		    && (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
			sc->sc_epaddr[UMASS_BULKOUT] = ed->bEndpointAddress;
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I
		    && UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN
		    && (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
			sc->sc_epaddr[UMASS_INTRIN] = ed->bEndpointAddress;
#ifdef UMASS_DEBUG
			if (UGETW(ed->wMaxPacketSize) > 2) {
				DPRINTF(UDMASS_CBI, ("%s: intr size is %d\n",
					sc->sc_dev.dv_xname,
					UGETW(ed->wMaxPacketSize)));
			}
#endif
		}
	}

	/* check whether we found all the endpoints we need */
	if (!sc->sc_epaddr[UMASS_BULKIN] || !sc->sc_epaddr[UMASS_BULKOUT] ||
	    (sc->sc_wire == UMASS_WPROTO_CBI_I &&
	     !sc->sc_epaddr[UMASS_INTRIN])) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %u/%u/%u\n",
			sc->sc_dev.dv_xname, sc->sc_epaddr[UMASS_BULKIN],
			sc->sc_epaddr[UMASS_BULKOUT],
			sc->sc_epaddr[UMASS_INTRIN]));
		return;
	}

	/*
	 * Get the maximum LUN supported by the device.
	 */
	if (sc->sc_wire == UMASS_WPROTO_BBB) {
		sc->maxlun = umass_bbb_get_max_lun(sc);
	} else {
		sc->maxlun = 0;
	}

	/* Open the bulk-in and -out pipe */
	DPRINTF(UDMASS_USB, ("%s: opening iface %p epaddr %d for BULKOUT\n",
	    sc->sc_dev.dv_xname, sc->sc_iface,
	    sc->sc_epaddr[UMASS_BULKOUT]));
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKOUT],
				USBD_EXCLUSIVE_USE,
				&sc->sc_pipe[UMASS_BULKOUT]);
	if (err) {
		DPRINTF(UDMASS_USB, ("%s: cannot open %u-out pipe (bulk)\n",
			sc->sc_dev.dv_xname, sc->sc_epaddr[UMASS_BULKOUT]));
		umass_disco(sc);
		return;
	}
	DPRINTF(UDMASS_USB, ("%s: opening iface %p epaddr %d for BULKIN\n",
	    sc->sc_dev.dv_xname, sc->sc_iface,
	    sc->sc_epaddr[UMASS_BULKIN]));
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_BULKIN]);
	if (err) {
		DPRINTF(UDMASS_USB, ("%s: could not open %u-in pipe (bulk)\n",
			sc->sc_dev.dv_xname, sc->sc_epaddr[UMASS_BULKIN]));
		umass_disco(sc);
		return;
	}
	/*
	 * Open the intr-in pipe if the protocol is CBI with CCI.
	 * Note: early versions of the Zip drive do have an interrupt pipe, but
	 * this pipe is unused
	 *
	 * We do not open the interrupt pipe as an interrupt pipe, but as a
	 * normal bulk endpoint. We send an IN transfer down the wire at the
	 * appropriate time, because we know exactly when to expect data on
	 * that endpoint. This saves bandwidth, but more important, makes the
	 * code for handling the data on that endpoint simpler. No data
	 * arriving concurrently.
	 */
	if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
		DPRINTF(UDMASS_USB, ("%s: opening iface %p epaddr %d for INTRIN\n",
		    sc->sc_dev.dv_xname, sc->sc_iface,
		    sc->sc_epaddr[UMASS_INTRIN]));
		err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_INTRIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_INTRIN]);
		if (err) {
			DPRINTF(UDMASS_USB, ("%s: couldn't open %u-in (intr)\n",
				sc->sc_dev.dv_xname,
				sc->sc_epaddr[UMASS_INTRIN]));
			umass_disco(sc);
			return;
		}
	}

	/* initialisation of generic part */
	sc->transfer_state = TSTATE_IDLE;

	/* request a sufficient number of xfer handles */
	for (i = 0; i < XFER_NR; i++) {
		sc->transfer_xfer[i] = usbd_alloc_xfer(uaa->device);
		if (sc->transfer_xfer[i] == NULL) {
			DPRINTF(UDMASS_USB, ("%s: Out of memory\n",
				sc->sc_dev.dv_xname));
			umass_disco(sc);
			return;
		}
	}
	/* Allocate buffer for data transfer (it's huge). */
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
		bno = XFER_BBB_DATA;
		goto dalloc;
	case UMASS_WPROTO_CBI:
		bno = XFER_CBI_DATA;
		goto dalloc;
	case UMASS_WPROTO_CBI_I:
		bno = XFER_CBI_DATA;
	dalloc:
		sc->data_buffer = usbd_alloc_buffer(sc->transfer_xfer[bno],
						    UMASS_MAX_TRANSFER_SIZE);
		if (sc->data_buffer == NULL) {
			umass_disco(sc);
			return;
		}
		break;
	default:
		break;
	}

	/* Initialise the wire protocol specific methods */
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
		sc->sc_methods = &umass_bbb_methods;
		break;
	case UMASS_WPROTO_CBI:
	case UMASS_WPROTO_CBI_I:
		sc->sc_methods = &umass_cbi_methods;
		break;
	default:
		umass_disco(sc);
		return;
	}

	error = 0;
	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
	case UMASS_CPROTO_SCSI:
	case UMASS_CPROTO_UFI:
	case UMASS_CPROTO_ATAPI:
		error = umass_scsi_attach(sc);
		break;

	case UMASS_CPROTO_ISD_ATA:
		printf("%s: isdata not configured\n", sc->sc_dev.dv_xname);
		break;

	default:
		printf("%s: command protocol=0x%x not supported\n",
		       sc->sc_dev.dv_xname, sc->sc_cmd);
		umass_disco(sc);
		return;
	}
	if (error) {
		printf("%s: bus attach failed\n", sc->sc_dev.dv_xname);
		umass_disco(sc);
		return;
	}

	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", sc->sc_dev.dv_xname));
}

int
umass_detach(struct device *self, int flags)
{
	struct umass_softc *sc = (struct umass_softc *)self;
	int rv = 0, i, s;

	DPRINTF(UDMASS_USB, ("%s: detached\n", sc->sc_dev.dv_xname));

	/* Abort the pipes to wake up any waiting processes. */
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL)
			usbd_abort_pipe(sc->sc_pipe[i]);
	}

	/* Do we really need reference counting?  Perhaps in ioctl() */
	s = splusb();
	if (--sc->sc_refcnt >= 0) {
#ifdef DIAGNOSTIC
		printf("%s: waiting for refcnt\n", sc->sc_dev.dv_xname);
#endif
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}

	/* Free the buffers via callback. */
	if (sc->transfer_state != TSTATE_IDLE && sc->transfer_priv) {
		sc->transfer_state = TSTATE_IDLE;
		sc->transfer_cb(sc, sc->transfer_priv,
				sc->transfer_datalen,
				STATUS_WIRE_FAILED);
		sc->transfer_priv = NULL;
	}
	splx(s);

	rv = umass_scsi_detach(sc, flags);
	if (rv != 0)
		return (rv);

	umass_disco(sc);

	return (rv);
}

void
umass_disco(struct umass_softc *sc)
{
	int i;

	DPRINTF(UDMASS_GEN, ("umass_disco\n"));

	/* Remove all the pipes. */
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL) {
			usbd_close_pipe(sc->sc_pipe[i]);
			sc->sc_pipe[i] = NULL;
		}
	}

	/* Make sure there is no stuck control transfer left. */
	usbd_abort_pipe(sc->sc_udev->default_pipe);

	/* Free the xfers. */
	for (i = 0; i < XFER_NR; i++) {
		if (sc->transfer_xfer[i] != NULL) {
			usbd_free_xfer(sc->transfer_xfer[i]);
			sc->transfer_xfer[i] = NULL;
		}
	}
}

/*
 * Generic functions to handle transfers
 */

usbd_status
umass_polled_transfer(struct umass_softc *sc, struct usbd_xfer *xfer)
{
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return (USBD_IOERROR);

	/*
	 * If a polled transfer is already in progress, preserve the new
	 * struct usbd_xfer and run it after the running one completes.
	 * This converts the recursive calls into the umass_*_state callbacks
	 * into iteration, preventing us from running out of stack under
	 * error conditions.
	 */
	if (sc->polling_depth) {
		if (sc->next_polled_xfer)
			panic("%s: got polled xfer %p, but %p already "
			    "pending\n", sc->sc_dev.dv_xname, xfer,
			    sc->next_polled_xfer);

		DPRINTF(UDMASS_XFER, ("%s: saving polled xfer %p\n",
		    sc->sc_dev.dv_xname, xfer));
		sc->next_polled_xfer = xfer;

		return (USBD_IN_PROGRESS);
	}

	sc->polling_depth++;

start_next_xfer:
	DPRINTF(UDMASS_XFER, ("%s: start polled xfer %p\n",
	    sc->sc_dev.dv_xname, xfer));
	err = usbd_transfer(xfer);
	if (err && err != USBD_IN_PROGRESS && sc->next_polled_xfer == NULL) {
		DPRINTF(UDMASS_BBB, ("%s: failed to setup transfer, %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err)));
		sc->polling_depth--;
		return (err);
	}

	if (err && err != USBD_IN_PROGRESS) {
		DPRINTF(UDMASS_XFER, ("umass_polled_xfer %p has error %s\n",
		    xfer, usbd_errstr(err)));
	}

	if (sc->next_polled_xfer != NULL) {
		DPRINTF(UDMASS_XFER, ("umass_polled_xfer running next "
		    "transaction %p\n", sc->next_polled_xfer));
		xfer = sc->next_polled_xfer;
		sc->next_polled_xfer = NULL;
		goto start_next_xfer;
	}

	sc->polling_depth--;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
umass_setup_transfer(struct umass_softc *sc, struct usbd_pipe *pipe,
			void *buffer, int buflen, int flags,
			struct usbd_xfer *xfer)
{
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return (USBD_IOERROR);

	/* Initialise a USB transfer and then schedule it */

	usbd_setup_xfer(xfer, pipe, (void *)sc, buffer, buflen,
	    flags | sc->sc_xfer_flags, sc->timeout, sc->sc_methods->wire_state);

	if (sc->sc_udev->bus->use_polling) {
		DPRINTF(UDMASS_XFER,("%s: start polled xfer buffer=%p "
		    "buflen=%d flags=0x%x timeout=%d\n", sc->sc_dev.dv_xname,
		    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));
		err = umass_polled_transfer(sc, xfer);
	} else {
		err = usbd_transfer(xfer);
		DPRINTF(UDMASS_XFER,("%s: start xfer buffer=%p buflen=%d "
		    "flags=0x%x timeout=%d\n", sc->sc_dev.dv_xname,
		    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));
	}
	if (err && err != USBD_IN_PROGRESS) {
		DPRINTF(UDMASS_BBB, ("%s: failed to setup transfer, %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err)));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}


usbd_status
umass_setup_ctrl_transfer(struct umass_softc *sc, usb_device_request_t *req,
	 void *buffer, int buflen, int flags, struct usbd_xfer *xfer)
{
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return (USBD_IOERROR);

	/* Initialise a USB control transfer and then schedule it */

	usbd_setup_default_xfer(xfer, sc->sc_udev, (void *) sc,
	    USBD_DEFAULT_TIMEOUT, req, buffer, buflen, flags,
	    sc->sc_methods->wire_state);

	if (sc->sc_udev->bus->use_polling) {
		DPRINTF(UDMASS_XFER,("%s: start polled ctrl xfer buffer=%p "
		    "buflen=%d flags=0x%x\n", sc->sc_dev.dv_xname, buffer,
		    buflen, flags));
		err = umass_polled_transfer(sc, xfer);
	} else {
		DPRINTF(UDMASS_XFER,("%s: start ctrl xfer buffer=%p buflen=%d "
		    "flags=0x%x\n", sc->sc_dev.dv_xname, buffer, buflen,
		    flags));
		err = usbd_transfer(xfer);
	}
	if (err && err != USBD_IN_PROGRESS) {
		DPRINTF(UDMASS_BBB, ("%s: failed to setup ctrl transfer, %s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(err)));

		/* do not reset, as this would make us loop */
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

void
umass_adjust_transfer(struct umass_softc *sc)
{
	switch (sc->sc_cmd) {
	case UMASS_CPROTO_UFI:
		sc->cbw.bCDBLength = UFI_COMMAND_LENGTH; 
		/* Adjust the length field in certain scsi commands. */
		switch (sc->cbw.CBWCDB[0]) {
		case INQUIRY:
			if (sc->transfer_datalen > 36) {
				sc->transfer_datalen = 36;
				sc->cbw.CBWCDB[4] = 36;
			}
			break;
		case MODE_SENSE_BIG:
			if (sc->transfer_datalen > 8) {
				sc->transfer_datalen = 8;
				sc->cbw.CBWCDB[7] = 0;
				sc->cbw.CBWCDB[8] = 8;
			}
			break;
		case REQUEST_SENSE:
			if (sc->transfer_datalen > 18) {
				sc->transfer_datalen = 18;
				sc->cbw.CBWCDB[4] = 18;
			}
			break;
		}
		break;
	case UMASS_CPROTO_ATAPI:
		sc->cbw.bCDBLength = UFI_COMMAND_LENGTH; 
		break;
	}
}

void
umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
    struct usbd_xfer *xfer)
{
	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(UDMASS_BBB, ("%s: Clear endpoint 0x%02x stall\n",
		sc->sc_dev.dv_xname, sc->sc_epaddr[endpt]));

	usbd_clear_endpoint_toggle(sc->sc_pipe[endpt]);

	sc->sc_req.bmRequestType = UT_WRITE_ENDPOINT;
	sc->sc_req.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->sc_req.wValue, UF_ENDPOINT_HALT);
	USETW(sc->sc_req.wIndex, sc->sc_epaddr[endpt]);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0, xfer);
}

#if 0
void
umass_reset(struct umass_softc *sc, transfer_cb_f cb, void *priv)
{
	sc->transfer_cb = cb;
	sc->transfer_priv = priv;

	/* The reset is a forced reset, so no error (yet) */
	sc->reset(sc, STATUS_CMD_OK);
}
#endif

/*
 * Bulk protocol specific functions
 */

void
umass_bbb_reset(struct umass_softc *sc, int status)
{
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_reset\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/*
	 * Reset recovery (5.3.4 in Universal Serial Bus Mass Storage Class)
	 *
	 * For Reset Recovery the host shall issue in the following order:
	 * a) a Bulk-Only Mass Storage Reset
	 * b) a Clear Feature HALT to the Bulk-In endpoint
	 * c) a Clear Feature HALT to the Bulk-Out endpoint
	 *
	 * This is done in 3 steps, states:
	 * TSTATE_BBB_RESET1
	 * TSTATE_BBB_RESET2
	 * TSTATE_BBB_RESET3
	 *
	 * If the reset doesn't succeed, the device should be port reset.
	 */

	DPRINTF(UDMASS_BBB, ("%s: Bulk Reset\n",
		sc->sc_dev.dv_xname));

	sc->transfer_state = TSTATE_BBB_RESET1;
	sc->transfer_status = status;

	/* reset is a class specific interface write */
	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_BBB_RESET;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0,
				  sc->transfer_xfer[XFER_BBB_RESET1]);
}

void
umass_bbb_transfer(struct umass_softc *sc, int lun, void *cmd, int cmdlen,
		   void *data, int datalen, int dir, u_int timeout,
		   umass_callback cb, void *priv)
{
	static int dCBWtag = 42;	/* unique for CBW of transfer */
	usbd_status err;

	DPRINTF(UDMASS_BBB,("%s: umass_bbb_transfer cmd=0x%02x\n",
		sc->sc_dev.dv_xname, *(u_char *)cmd));

	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_transfer\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev)) {
		sc->polled_xfer_status = USBD_IOERROR;
		return;
	}

	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;

	/*
	 * Do a Bulk-Only transfer with cmdlen bytes from cmd, possibly
	 * a data phase of datalen bytes from/to the device and finally a
	 * csw read phase.
	 * If the data direction was inbound a maximum of datalen bytes
	 * is stored in the buffer pointed to by data.
	 *
	 * umass_bbb_transfer initialises the transfer and lets the state
	 * machine in umass_bbb_state handle the completion. It uses the
	 * following states:
	 * TSTATE_BBB_COMMAND
	 *   -> TSTATE_BBB_DATA
	 *   -> TSTATE_BBB_STATUS
	 *   -> TSTATE_BBB_STATUS2
	 *   -> TSTATE_BBB_IDLE
	 *
	 * An error in any of those states will invoke
	 * umass_bbb_reset.
	 */

	/* check the given arguments */
	KASSERT(datalen == 0 || data != NULL,
		("%s: datalen > 0, but no buffer",sc->sc_dev.dv_xname));
	KASSERT(cmdlen <= CBWCDBLENGTH,
		("%s: cmdlen exceeds CDB length in CBW (%d > %d)",
			sc->sc_dev.dv_xname, cmdlen, CBWCDBLENGTH));
	KASSERT(dir == DIR_NONE || datalen > 0,
		("%s: datalen == 0 while direction is not NONE\n",
			sc->sc_dev.dv_xname));
	KASSERT(datalen == 0 || dir != DIR_NONE,
		("%s: direction is NONE while datalen is not zero\n",
			sc->sc_dev.dv_xname));
	KASSERT(sizeof(struct umass_bbb_cbw) == UMASS_BBB_CBW_SIZE,
		("%s: CBW struct does not have the right size (%d vs. %d)\n",
			sc->sc_dev.dv_xname,
			sizeof(struct umass_bbb_cbw), UMASS_BBB_CBW_SIZE));
	KASSERT(sizeof(struct umass_bbb_csw) == UMASS_BBB_CSW_SIZE,
		("%s: CSW struct does not have the right size (%d vs. %d)\n",
			sc->sc_dev.dv_xname,
			sizeof(struct umass_bbb_csw), UMASS_BBB_CSW_SIZE));

	/*
	 * Determine the direction of the data transfer and the length.
	 *
	 * dCBWDataTransferLength (datalen) :
	 *   This field indicates the number of bytes of data that the host
	 *   intends to transfer on the IN or OUT Bulk endpoint(as indicated by
	 *   the Direction bit) during the execution of this command. If this
	 *   field is set to 0, the device will expect that no data will be
	 *   transferred IN or OUT during this command, regardless of the value
	 *   of the Direction bit defined in dCBWFlags.
	 *
	 * dCBWFlags (dir) :
	 *   The bits of the Flags field are defined as follows:
	 *     Bits 0-6	 reserved
	 *     Bit  7	 Direction - this bit shall be ignored if the
	 *			     dCBWDataTransferLength field is zero.
	 *		 0 = data Out from host to device
	 *		 1 = data In from device to host
	 */

	/* Fill in the Command Block Wrapper */
	USETDW(sc->cbw.dCBWSignature, CBWSIGNATURE);
	USETDW(sc->cbw.dCBWTag, dCBWtag);
	dCBWtag++;	/* cannot be done in macro (it will be done 4 times) */
	USETDW(sc->cbw.dCBWDataTransferLength, datalen);
	/* DIR_NONE is treated as DIR_OUT (0x00) */
	sc->cbw.bCBWFlags = (dir == DIR_IN? CBWFLAGS_IN:CBWFLAGS_OUT);
	sc->cbw.bCBWLUN = lun;
	sc->cbw.bCDBLength = cmdlen;
	bzero(sc->cbw.CBWCDB, sizeof(sc->cbw.CBWCDB));
	memcpy(sc->cbw.CBWCDB, cmd, cmdlen);

	DIF(UDMASS_BBB, umass_bbb_dump_cbw(sc, &sc->cbw));

	/* store the details for the data transfer phase */
	sc->transfer_dir = dir;
	sc->transfer_data = data;
	sc->transfer_datalen = datalen;
	sc->transfer_actlen = 0;
	sc->transfer_cb = cb;
	sc->transfer_priv = priv;
	sc->transfer_status = STATUS_CMD_OK;

	/* move from idle to the command state */
	sc->transfer_state = TSTATE_BBB_COMMAND;

	/* Send the CBW from host to device via bulk-out endpoint. */
	umass_adjust_transfer(sc);
	if ((err = umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
			&sc->cbw, UMASS_BBB_CBW_SIZE, 0,
			sc->transfer_xfer[XFER_BBB_CBW])))
		umass_bbb_reset(sc, STATUS_WIRE_FAILED);

	if (sc->sc_udev->bus->use_polling)
		sc->polled_xfer_status = err;
}

void
umass_bbb_state(struct usbd_xfer *xfer, void *priv, usbd_status err)
{
	struct umass_softc *sc = (struct umass_softc *) priv;
	struct usbd_xfer *next_xfer;

	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_state\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/*
	 * State handling for BBB transfers.
	 *
	 * The subroutine is rather long. It steps through the states given in
	 * Annex A of the Bulk-Only specification.
	 * Each state first does the error handling of the previous transfer
	 * and then prepares the next transfer.
	 * Each transfer is done asynchronously so after the request/transfer
	 * has been submitted you will find a 'return;'.
	 */

	DPRINTF(UDMASS_BBB, ("%s: Handling BBB state %d (%s), xfer=%p, %s\n",
		sc->sc_dev.dv_xname, sc->transfer_state,
		states[sc->transfer_state], xfer, usbd_errstr(err)));

	switch (sc->transfer_state) {

	/***** Bulk Transfer *****/
	case TSTATE_BBB_COMMAND:
		/* Command transport phase, error handling */
		if (err) {
			DPRINTF(UDMASS_BBB, ("%s: failed to send CBW\n",
				sc->sc_dev.dv_xname));
			/* If the device detects that the CBW is invalid, then
			 * the device may STALL both bulk endpoints and require
			 * a Bulk-Reset
			 */
			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
		}

		/* Data transport phase, setup transfer */
		sc->transfer_state = TSTATE_BBB_DATA;
		if (sc->transfer_dir == DIR_IN) {
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
					sc->data_buffer, sc->transfer_datalen,
					USBD_SHORT_XFER_OK | USBD_NO_COPY,
					sc->transfer_xfer[XFER_BBB_DATA]))
				umass_bbb_reset(sc, STATUS_WIRE_FAILED);

			return;
		} else if (sc->transfer_dir == DIR_OUT) {
			memcpy(sc->data_buffer, sc->transfer_data,
			       sc->transfer_datalen);
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
					sc->data_buffer, sc->transfer_datalen,
					USBD_NO_COPY,/* fixed length transfer */
					sc->transfer_xfer[XFER_BBB_DATA]))
				umass_bbb_reset(sc, STATUS_WIRE_FAILED);

			return;
		} else {
			DPRINTF(UDMASS_BBB, ("%s: no data phase\n",
				sc->sc_dev.dv_xname));
		}

		/* FALLTHROUGH if no data phase, err == 0 */
	case TSTATE_BBB_DATA:
		/* Command transport phase error handling (ignored if no data
		 * phase (fallthrough from previous state)) */
		if (sc->transfer_dir != DIR_NONE) {
			/* retrieve the length of the transfer that was done */
			usbd_get_xfer_status(xfer, NULL, NULL,
			     &sc->transfer_actlen, NULL);
			DPRINTF(UDMASS_BBB, ("%s: BBB_DATA actlen=%d\n",
				sc->sc_dev.dv_xname, sc->transfer_actlen));

			if (err) {
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %d failed, "
					"%s\n", sc->sc_dev.dv_xname,
					(sc->transfer_dir == DIR_IN?"in":"out"),
					sc->transfer_datalen,usbd_errstr(err)));

				if (err == USBD_STALLED) {
					sc->transfer_state = TSTATE_BBB_DCLEAR;
					umass_clear_endpoint_stall(sc,
					  (sc->transfer_dir == DIR_IN?
					    UMASS_BULKIN:UMASS_BULKOUT),
					  sc->transfer_xfer[XFER_BBB_DCLEAR]);
				} else {
					/* Unless the error is a pipe stall the
					 * error is fatal.
					 */
					umass_bbb_reset(sc,STATUS_WIRE_FAILED);
				}
				return;
			}
		}

		/* FALLTHROUGH, err == 0 (no data phase or successful) */
	case TSTATE_BBB_DCLEAR: /* stall clear after data phase */
		if (sc->transfer_dir == DIR_IN)
			memcpy(sc->transfer_data, sc->data_buffer,
			       sc->transfer_actlen);

		DIF(UDMASS_BBB, if (sc->transfer_dir == DIR_IN)
					umass_dump_buffer(sc, sc->transfer_data,
						sc->transfer_datalen, 48));

		/* FALLTHROUGH, err == 0 (no data phase or successful) */
	case TSTATE_BBB_SCLEAR: /* stall clear after status phase */
		/* Reading of CSW after bulk stall condition in data phase
		 * (TSTATE_BBB_DATA2) or bulk-in stall condition after
		 * reading CSW (TSTATE_BBB_SCLEAR).
		 * In the case of no data phase or successful data phase,
		 * err == 0 and the following if block is passed.
		 */
		if (err) {	/* should not occur */
			DPRINTF(UDMASS_BBB, ("%s: BBB bulk-%s stall clear"
			    " failed, %s\n", sc->sc_dev.dv_xname,
			    (sc->transfer_dir == DIR_IN? "in":"out"),
			    usbd_errstr(err)));
			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
		}

		/* Status transport phase, setup transfer */
		if (sc->transfer_state == TSTATE_BBB_COMMAND ||
		    sc->transfer_state == TSTATE_BBB_DATA ||
		    sc->transfer_state == TSTATE_BBB_DCLEAR) {
			/* After no data phase, successful data phase and
			 * after clearing bulk-in/-out stall condition
			 */
			sc->transfer_state = TSTATE_BBB_STATUS1;
			next_xfer = sc->transfer_xfer[XFER_BBB_CSW1];
		} else {
			/* After first attempt of fetching CSW */
			sc->transfer_state = TSTATE_BBB_STATUS2;
			next_xfer = sc->transfer_xfer[XFER_BBB_CSW2];
		}

		/* Read the Command Status Wrapper via bulk-in endpoint. */
		if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
			&sc->csw, UMASS_BBB_CSW_SIZE, 0, next_xfer)) {
			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
		}

		return;
	case TSTATE_BBB_STATUS1:	/* first attempt */
	case TSTATE_BBB_STATUS2:	/* second attempt */
		/* Status transfer, error handling */
		if (err) {
			DPRINTF(UDMASS_BBB, ("%s: Failed to read CSW, %s%s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err),
				(sc->transfer_state == TSTATE_BBB_STATUS1?
					", retrying":"")));

			/* If this was the first attempt at fetching the CSW
			 * retry it, otherwise fail.
			 */
			if (sc->transfer_state == TSTATE_BBB_STATUS1) {
				sc->transfer_state = TSTATE_BBB_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
				    sc->transfer_xfer[XFER_BBB_SCLEAR]);
				return;
			} else {
				umass_bbb_reset(sc, STATUS_WIRE_FAILED);
				return;
			}
		}

		DIF(UDMASS_BBB, umass_bbb_dump_csw(sc, &sc->csw));

		/* Translate weird command-status signatures. */
		if ((sc->sc_quirks & UMASS_QUIRK_WRONG_CSWSIG) &&
		    UGETDW(sc->csw.dCSWSignature) == CSWSIGNATURE_OLYMPUS_C1)
			USETDW(sc->csw.dCSWSignature, CSWSIGNATURE);

		/* Translate invalid command-status tags */
		if (sc->sc_quirks & UMASS_QUIRK_WRONG_CSWTAG)
			USETDW(sc->csw.dCSWTag, UGETDW(sc->cbw.dCBWTag));

		/* Check CSW and handle any error */
		if (UGETDW(sc->csw.dCSWSignature) != CSWSIGNATURE) {
			/* Invalid CSW: Wrong signature or wrong tag might
			 * indicate that the device is confused -> reset it.
			 */
			printf("%s: Invalid CSW: sig 0x%08x should be 0x%08x\n",
				sc->sc_dev.dv_xname,
				UGETDW(sc->csw.dCSWSignature),
				CSWSIGNATURE);

			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
		} else if (UGETDW(sc->csw.dCSWTag)
				!= UGETDW(sc->cbw.dCBWTag)) {
			printf("%s: Invalid CSW: tag %d should be %d\n",
				sc->sc_dev.dv_xname,
				UGETDW(sc->csw.dCSWTag),
				UGETDW(sc->cbw.dCBWTag));

			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;

		/* CSW is valid here */
		} else if (sc->csw.bCSWStatus > CSWSTATUS_PHASE) {
			printf("%s: Invalid CSW: status %d > %d\n",
				sc->sc_dev.dv_xname,
				sc->csw.bCSWStatus,
				CSWSTATUS_PHASE);

			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
		} else if (sc->csw.bCSWStatus == CSWSTATUS_PHASE) {
			printf("%s: Phase Error, residue = %d\n",
				sc->sc_dev.dv_xname,
				UGETDW(sc->csw.dCSWDataResidue));

			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;

		} else if (sc->transfer_actlen > sc->transfer_datalen) {
			/* Buffer overrun! Don't let this go by unnoticed */
			panic("%s: transferred %d bytes instead of %d bytes",
				sc->sc_dev.dv_xname,
				sc->transfer_actlen, sc->transfer_datalen);
#if 0
		} else if (sc->transfer_datalen - sc->transfer_actlen
			   != UGETDW(sc->csw.dCSWDataResidue)) {
			DPRINTF(UDMASS_BBB, ("%s: actlen=%d != residue=%d\n",
				sc->sc_dev.dv_xname,
				sc->transfer_datalen - sc->transfer_actlen,
				UGETDW(sc->csw.dCSWDataResidue)));

			umass_bbb_reset(sc, STATUS_WIRE_FAILED);
			return;
#endif
		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
			DPRINTF(UDMASS_BBB, ("%s: Command Failed, res = %d\n",
				sc->sc_dev.dv_xname,
				UGETDW(sc->csw.dCSWDataResidue)));

			/* SCSI command failed but transfer was successful */
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
					UGETDW(sc->csw.dCSWDataResidue),
					STATUS_CMD_FAILED);

			return;

		} else {	/* success */
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
					UGETDW(sc->csw.dCSWDataResidue),
					STATUS_CMD_OK);

			return;
		}

	/***** Bulk Reset *****/
	case TSTATE_BBB_RESET1:
		if (err)
			DPRINTF(UDMASS_BBB, ("%s: BBB reset failed, %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err)));

		sc->transfer_state = TSTATE_BBB_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
			sc->transfer_xfer[XFER_BBB_RESET2]);

		return;
	case TSTATE_BBB_RESET2:
		if (err)	/* should not occur */
			DPRINTF(UDMASS_BBB, ("%s: BBB bulk-in clear stall"
				" failed, %s\n", sc->sc_dev.dv_xname,
				usbd_errstr(err)));
			/* no error recovery, otherwise we end up in a loop */

		sc->transfer_state = TSTATE_BBB_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
			sc->transfer_xfer[XFER_BBB_RESET3]);

		return;
	case TSTATE_BBB_RESET3:
		if (err)	/* should not occur */
			DPRINTF(UDMASS_BBB,("%s: BBB bulk-out clear stall"
				" failed, %s\n", sc->sc_dev.dv_xname,
				usbd_errstr(err)));
			/* no error recovery, otherwise we end up in a loop */

		sc->transfer_state = TSTATE_IDLE;
		if (sc->transfer_priv) {
			sc->transfer_cb(sc, sc->transfer_priv,
					sc->transfer_datalen,
					sc->transfer_status);
		}

		return;

	/***** Default *****/
	default:
		panic("%s: Unknown state %d",
		      sc->sc_dev.dv_xname, sc->transfer_state);
	}
}

/*
 * Command/Bulk/Interrupt (CBI) specific functions
 */

int
umass_cbi_adsc(struct umass_softc *sc, char *buffer, int buflen,
    struct usbd_xfer *xfer)
{
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_adsc\n",
		sc->sc_wire));

	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_CBI_ADSC;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, &sc->sc_req, buffer,
					 buflen, 0, xfer);
}


void
umass_cbi_reset(struct umass_softc *sc, int status)
{
	int i;
#	define SEND_DIAGNOSTIC_CMDLEN	12

	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_reset\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/*
	 * Command Block Reset Protocol
	 *
	 * First send a reset request to the device. Then clear
	 * any possibly stalled bulk endpoints.

	 * This is done in 3 steps, states:
	 * TSTATE_CBI_RESET1
	 * TSTATE_CBI_RESET2
	 * TSTATE_CBI_RESET3
	 *
	 * If the reset doesn't succeed, the device should be port reset.
	 */

	DPRINTF(UDMASS_CBI, ("%s: CBI Reset\n",
		sc->sc_dev.dv_xname));

	KASSERT(sizeof(sc->cbl) >= SEND_DIAGNOSTIC_CMDLEN,
		("%s: CBL struct is too small (%d < %d)\n",
			sc->sc_dev.dv_xname,
			sizeof(sc->cbl), SEND_DIAGNOSTIC_CMDLEN));

	sc->transfer_state = TSTATE_CBI_RESET1;
	sc->transfer_status = status;

	/* The 0x1d code is the SEND DIAGNOSTIC command. To distinguish between
	 * the two the last 10 bytes of the cbl is filled with 0xff (section
	 * 2.2 of the CBI spec).
	 */
	sc->cbl[0] = 0x1d;	/* Command Block Reset */
	sc->cbl[1] = 0x04;
	for (i = 2; i < SEND_DIAGNOSTIC_CMDLEN; i++)
		sc->cbl[i] = 0xff;

	umass_cbi_adsc(sc, sc->cbl, SEND_DIAGNOSTIC_CMDLEN,
		       sc->transfer_xfer[XFER_CBI_RESET1]);
	/* XXX if the command fails we should reset the port on the bub */
}

void
umass_cbi_transfer(struct umass_softc *sc, int lun,
		   void *cmd, int cmdlen, void *data, int datalen, int dir,
		   u_int timeout, umass_callback cb, void *priv)
{
	usbd_status err;

	DPRINTF(UDMASS_CBI,("%s: umass_cbi_transfer cmd=0x%02x, len=%d\n",
		sc->sc_dev.dv_xname, *(u_char *)cmd, datalen));

	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_transfer\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev)) {
		sc->polled_xfer_status = USBD_IOERROR;
		return;
	}

	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;

	/*
	 * Do a CBI transfer with cmdlen bytes from cmd, possibly
	 * a data phase of datalen bytes from/to the device and finally a
	 * csw read phase.
	 * If the data direction was inbound a maximum of datalen bytes
	 * is stored in the buffer pointed to by data.
	 *
	 * umass_cbi_transfer initialises the transfer and lets the state
	 * machine in umass_cbi_state handle the completion. It uses the
	 * following states:
	 * TSTATE_CBI_COMMAND
	 *   -> XXX fill in
	 *
	 * An error in any of those states will invoke
	 * umass_cbi_reset.
	 */

	/* check the given arguments */
	KASSERT(datalen == 0 || data != NULL,
		("%s: datalen > 0, but no buffer",sc->sc_dev.dv_xname));
	KASSERT(datalen == 0 || dir != DIR_NONE,
		("%s: direction is NONE while datalen is not zero\n",
			sc->sc_dev.dv_xname));

	/* store the details for the data transfer phase */
	sc->transfer_dir = dir;
	sc->transfer_data = data;
	sc->transfer_datalen = datalen;
	sc->transfer_actlen = 0;
	sc->transfer_cb = cb;
	sc->transfer_priv = priv;
	sc->transfer_status = STATUS_CMD_OK;

	/* move from idle to the command state */
	sc->transfer_state = TSTATE_CBI_COMMAND;

	/* Send the Command Block from host to device via control endpoint. */
	sc->cbw.bCDBLength = cmdlen;
	bzero(sc->cbw.CBWCDB, sizeof(sc->cbw.CBWCDB));
	memcpy(sc->cbw.CBWCDB, cmd, cmdlen);
	umass_adjust_transfer(sc);
	if ((err = umass_cbi_adsc(sc, (void *)sc->cbw.CBWCDB, sc->cbw.bCDBLength,
	    sc->transfer_xfer[XFER_CBI_CB])))
		umass_cbi_reset(sc, STATUS_WIRE_FAILED);

	if (sc->sc_udev->bus->use_polling)
		sc->polled_xfer_status = err;
}

void
umass_cbi_state(struct usbd_xfer *xfer, void *priv,  usbd_status err)
{
	struct umass_softc *sc = (struct umass_softc *) priv;

	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_state\n",
		sc->sc_wire));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/*
	 * State handling for CBI transfers.
	 */

	DPRINTF(UDMASS_CBI, ("%s: Handling CBI state %d (%s), xfer=%p, %s\n",
		sc->sc_dev.dv_xname, sc->transfer_state,
		states[sc->transfer_state], xfer, usbd_errstr(err)));

	switch (sc->transfer_state) {

	/***** CBI Transfer *****/
	case TSTATE_CBI_COMMAND:
		if (err == USBD_STALLED) {
			DPRINTF(UDMASS_CBI, ("%s: Command Transport failed\n",
				sc->sc_dev.dv_xname));
			/* Status transport by control pipe (section 2.3.2.1).
			 * The command contained in the command block failed.
			 *
			 * The control pipe has already been unstalled by the
			 * USB stack.
			 * Section 2.4.3.1.1 states that the bulk in endpoints
			 * should not stalled at this point.
			 */

			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
					sc->transfer_datalen,
					STATUS_CMD_FAILED);

			return;
		} else if (err) {
			DPRINTF(UDMASS_CBI, ("%s: failed to send ADSC\n",
				sc->sc_dev.dv_xname));
			umass_cbi_reset(sc, STATUS_WIRE_FAILED);
			return;
		}

		/* Data transport phase, setup transfer */
		sc->transfer_state = TSTATE_CBI_DATA;
		if (sc->transfer_dir == DIR_IN) {
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
					sc->data_buffer, sc->transfer_datalen,
					USBD_SHORT_XFER_OK | USBD_NO_COPY,
					sc->transfer_xfer[XFER_CBI_DATA]))
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);

			return;
		} else if (sc->transfer_dir == DIR_OUT) {
			memcpy(sc->data_buffer, sc->transfer_data,
			       sc->transfer_datalen);
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
					sc->data_buffer, sc->transfer_datalen,
					USBD_NO_COPY,/* fixed length transfer */
					sc->transfer_xfer[XFER_CBI_DATA]))
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);

			return;
		} else {
			DPRINTF(UDMASS_CBI, ("%s: no data phase\n",
				sc->sc_dev.dv_xname));
		}

		/* FALLTHROUGH if no data phase, err == 0 */
	case TSTATE_CBI_DATA:
		/* Command transport phase error handling (ignored if no data
		 * phase (fallthrough from previous state)) */
		if (sc->transfer_dir != DIR_NONE) {
			/* retrieve the length of the transfer that was done */
			usbd_get_xfer_status(xfer, NULL, NULL,
			    &sc->transfer_actlen, NULL);
			DPRINTF(UDMASS_CBI, ("%s: CBI_DATA actlen=%d\n",
				sc->sc_dev.dv_xname, sc->transfer_actlen));

			if (err) {
				DPRINTF(UDMASS_CBI, ("%s: Data-%s %d failed, "
					"%s\n", sc->sc_dev.dv_xname,
					(sc->transfer_dir == DIR_IN?"in":"out"),
					sc->transfer_datalen,usbd_errstr(err)));

				if (err == USBD_STALLED) {
					sc->transfer_state = TSTATE_CBI_DCLEAR;
					umass_clear_endpoint_stall(sc,
					  (sc->transfer_dir == DIR_IN?
					    UMASS_BULKIN:UMASS_BULKOUT),
					sc->transfer_xfer[XFER_CBI_DCLEAR]);
				} else {
					/* Unless the error is a pipe stall the
					 * error is fatal.
					 */
					umass_cbi_reset(sc, STATUS_WIRE_FAILED);
				}
				return;
			}
		}

		if (sc->transfer_dir == DIR_IN)
			memcpy(sc->transfer_data, sc->data_buffer,
			       sc->transfer_actlen);

		DIF(UDMASS_CBI, if (sc->transfer_dir == DIR_IN)
					umass_dump_buffer(sc, sc->transfer_data,
						sc->transfer_actlen, 48));

		/* Status phase */
		if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
			sc->transfer_state = TSTATE_CBI_STATUS;
			memset(&sc->sbl, 0, sizeof(sc->sbl));
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
				    &sc->sbl, sizeof(sc->sbl),
				    0,	/* fixed length transfer */
				    sc->transfer_xfer[XFER_CBI_STATUS]))
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
		} else {
			/* No command completion interrupt. Request
			 * sense to get status of command.
			 */
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
				sc->transfer_datalen - sc->transfer_actlen,
				STATUS_CMD_UNKNOWN);
		}
		return;

	case TSTATE_CBI_STATUS:
		if (err) {
			DPRINTF(UDMASS_CBI, ("%s: Status Transport failed\n",
				sc->sc_dev.dv_xname));
			/* Status transport by interrupt pipe (section 2.3.2.2).
			 */

			if (err == USBD_STALLED) {
				sc->transfer_state = TSTATE_CBI_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_INTRIN,
					sc->transfer_xfer[XFER_CBI_SCLEAR]);
			} else {
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
			}
			return;
		}

		/* Dissect the information in the buffer */

		{
			u_int32_t actlen;
			usbd_get_xfer_status(xfer, NULL, NULL, &actlen, NULL);
			DPRINTF(UDMASS_CBI, ("%s: CBI_STATUS actlen=%d\n",
			    sc->sc_dev.dv_xname, actlen));
			if (actlen != 2)
				break;
		}

		if (sc->sc_cmd == UMASS_CPROTO_UFI) {
			int status;

			/* Section 3.4.3.1.3 specifies that the UFI command
			 * protocol returns an ASC and ASCQ in the interrupt
			 * data block.
			 */

			DPRINTF(UDMASS_CBI, ("%s: UFI CCI, ASC = 0x%02x, "
				"ASCQ = 0x%02x\n",
				sc->sc_dev.dv_xname,
				sc->sbl.ufi.asc, sc->sbl.ufi.ascq));

			if ((sc->sbl.ufi.asc == 0 && sc->sbl.ufi.ascq == 0) ||
			    sc->sc_sense)
				status = STATUS_CMD_OK;
			else
				status = STATUS_CMD_FAILED;

			/* No autosense, command successful */
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
			    sc->transfer_datalen - sc->transfer_actlen, status);
		} else {
			/* Command Interrupt Data Block */

			DPRINTF(UDMASS_CBI, ("%s: type=0x%02x, value=0x%02x\n",
				sc->sc_dev.dv_xname,
				sc->sbl.common.type, sc->sbl.common.value));

			if (sc->sbl.common.type == IDB_TYPE_CCI) {
				int status;
				switch (sc->sbl.common.value &
				    IDB_VALUE_STATUS_MASK) {
				case IDB_VALUE_PASS:
					status = STATUS_CMD_OK;
					break;
				case IDB_VALUE_FAIL:
				case IDB_VALUE_PERSISTENT:
					status = STATUS_CMD_FAILED;
					break;
				case IDB_VALUE_PHASE:
				default:
					status = STATUS_WIRE_FAILED;
					break;
 				}

				sc->transfer_state = TSTATE_IDLE;
				sc->transfer_cb(sc, sc->transfer_priv,
				    sc->transfer_datalen - sc->transfer_actlen,
				    status);
			}
		}
		return;

	case TSTATE_CBI_DCLEAR:
		if (err) {	/* should not occur */
			printf("%s: CBI bulk-in/out stall clear failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
			umass_cbi_reset(sc, STATUS_WIRE_FAILED);
		} else {
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
			    sc->transfer_datalen, STATUS_CMD_FAILED);
		}
		return;

	case TSTATE_CBI_SCLEAR:
		if (err) {	/* should not occur */
			printf("%s: CBI intr-in stall clear failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
			umass_cbi_reset(sc, STATUS_WIRE_FAILED);
		} else {
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
			    sc->transfer_datalen, STATUS_CMD_FAILED);
		}
		return;

	/***** CBI Reset *****/
	case TSTATE_CBI_RESET1:
		if (err)
			printf("%s: CBI reset failed, %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));

		sc->transfer_state = TSTATE_CBI_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
			sc->transfer_xfer[XFER_CBI_RESET2]);

		return;
	case TSTATE_CBI_RESET2:
		if (err)	/* should not occur */
			printf("%s: CBI bulk-in stall clear failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
			/* no error recovery, otherwise we end up in a loop */

		sc->transfer_state = TSTATE_CBI_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
			sc->transfer_xfer[XFER_CBI_RESET3]);

		return;
	case TSTATE_CBI_RESET3:
		if (err)	/* should not occur */
			printf("%s: CBI bulk-out stall clear failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
			/* no error recovery, otherwise we end up in a loop */

		sc->transfer_state = TSTATE_IDLE;
		if (sc->transfer_priv) {
			sc->transfer_cb(sc, sc->transfer_priv,
					sc->transfer_datalen,
					sc->transfer_status);
		}

		return;


	/***** Default *****/
	default:
		panic("%s: Unknown state %d",
		      sc->sc_dev.dv_xname, sc->transfer_state);
	}
}

u_int8_t
umass_bbb_get_max_lun(struct umass_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;
	u_int8_t maxlun = 0;
	u_int8_t buf = 0;

	DPRINTF(UDMASS_BBB, ("%s: Get Max Lun\n", sc->sc_dev.dv_xname));

	/* The Get Max Lun command is a class-specific request. */
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_BBB_GET_MAX_LUN;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, 1);

	err = usbd_do_request_flags(sc->sc_udev, &req, &buf,
	    USBD_SHORT_XFER_OK, 0, USBD_DEFAULT_TIMEOUT);

	switch (err) {
	case USBD_NORMAL_COMPLETION:
		maxlun = buf;
		break;

	default:
		/* XXX Should we port_reset the device? */
		DPRINTF(UDMASS_BBB, ("%s: Get Max Lun not supported (%s)\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err)));
		break;
	}

	DPRINTF(UDMASS_BBB, ("%s: Max Lun %d\n", sc->sc_dev.dv_xname, maxlun));
	return (maxlun);
}

#ifdef UMASS_DEBUG
void
umass_bbb_dump_cbw(struct umass_softc *sc, struct umass_bbb_cbw *cbw)
{
	int clen = cbw->bCDBLength;
	int dlen = UGETDW(cbw->dCBWDataTransferLength);
	u_int8_t *c = cbw->CBWCDB;
	int tag = UGETDW(cbw->dCBWTag);
	int flags = cbw->bCBWFlags;

	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmdlen=%d "
		"(0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s), "
		"data = %d bytes, dir = %s\n",
		sc->sc_dev.dv_xname, tag, clen,
		c[0], c[1], c[2], c[3], c[4], c[5],
		c[6], c[7], c[8], c[9],
		(clen > 10? "...":""),
		dlen, (flags == CBWFLAGS_IN? "in":
		       (flags == CBWFLAGS_OUT? "out":"<invalid>"))));
}

void
umass_bbb_dump_csw(struct umass_softc *sc, struct umass_bbb_csw *csw)
{
	int sig = UGETDW(csw->dCSWSignature);
	int tag = UGETDW(csw->dCSWTag);
	int res = UGETDW(csw->dCSWDataResidue);
	int status = csw->bCSWStatus;

	DPRINTF(UDMASS_BBB, ("%s: CSW %d: sig = 0x%08x (%s), tag = %d, "
		"res = %d, status = 0x%02x (%s)\n", sc->sc_dev.dv_xname,
		tag, sig, (sig == CSWSIGNATURE?	 "valid":"invalid"),
		tag, res,
		status, (status == CSWSTATUS_GOOD? "good":
			 (status == CSWSTATUS_FAILED? "failed":
			  (status == CSWSTATUS_PHASE? "phase":"<invalid>")))));
}

void
umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer, int buflen,
		  int printlen)
{
	int i, j;
	char s1[40];
	char s2[40];
	char s3[5];

	s1[0] = '\0';
	s3[0] = '\0';

	snprintf(s2, sizeof s2, " buffer=%p, buflen=%d", buffer, buflen);
	for (i = 0; i < buflen && i < printlen; i++) {
		j = i % 16;
		if (j == 0 && i != 0) {
			DPRINTF(UDMASS_GEN, ("%s: 0x %s%s\n",
				sc->sc_dev.dv_xname, s1, s2));
			s2[0] = '\0';
		}
		snprintf(&s1[j*2], sizeof s1 - j*2, "%02x", buffer[i] & 0xff);
	}
	if (buflen > printlen)
		snprintf(s3, sizeof s3, " ...");
	DPRINTF(UDMASS_GEN, ("%s: 0x %s%s%s\n",
		sc->sc_dev.dv_xname, s1, s2, s3));
}
#endif
@


1.73
log
@Fold umass_atapi_attach() and umass_scsi_setup() into umass_scsi_attach() to
shorten and simplify code.

No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.72 2015/12/17 10:21:22 mpi Exp $ */
a132 1
#include <sys/malloc.h>
@


1.72
log
@Missing include, spotted by benoit@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.71 2015/12/16 14:50:26 mpi Exp $ */
a587 3
		error = umass_scsi_attach(sc);
		break;

d590 1
a590 1
		error = umass_atapi_attach(sc);
@


1.71
log
@Refactor umass_detach() in order to pass a size to free(9).

Based on a diff from Mathieu <naabed AT poolp DOT org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.70 2015/03/14 03:38:50 jsg Exp $ */
d132 1
@


1.70
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.69 2015/01/27 11:04:45 mpi Exp $ */
a131 1
#include <sys/device.h>
a617 1
	struct umassbus_softc *scbus;
d648 1
a648 8
	scbus = sc->bus;
	if (scbus != NULL) {
		if (scbus->sc_child != NULL)
			rv = config_detach(scbus->sc_child, flags);
		free(scbus, M_DEVBUF, 0);
		sc->bus = NULL;
	}

@


1.69
log
@Vommiting errors about failed reset or stall clear are not usefull to
the user and do not give enough informations to debug a problem.

Only print such messages in DEBUG mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.68 2015/01/18 14:40:05 mpi Exp $ */
a144 1
#include <dev/usb/usbdevs.h>
@


1.68
log
@Do not try to free xfers before aborting the pipes, otherwise a clown
might eat you.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.67 2014/08/21 14:52:56 mpi Exp $ */
d1185 2
a1186 2
			printf("%s: BBB bulk-%s stall clear failed, %s\n",
			    sc->sc_dev.dv_xname,
d1188 1
a1188 1
			    usbd_errstr(err));
d1330 2
a1331 2
			printf("%s: BBB reset failed, %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));
d1340 3
a1342 2
			printf("%s: BBB bulk-in clear stall failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
d1352 3
a1354 2
			printf("%s: BBB bulk-out clear stall failed, %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.67
log
@Now that DVACT_DEACTIVATE is propagated to the children of a device when
a driver does not implement a specific *_activate() handler and that our
USB stack sets the dying flag before detaching a device, these specific
handlers can die.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.66 2014/07/12 18:48:52 tedu Exp $ */
a673 7
	/* Free the xfers. */
	for (i = 0; i < XFER_NR; i++)
		if (sc->transfer_xfer[i] != NULL) {
			usbd_free_xfer(sc->transfer_xfer[i]);
			sc->transfer_xfer[i] = NULL;
		}

d679 11
@


1.66
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.65 2013/11/06 14:37:31 pirofti Exp $ */
a182 1
int umass_activate(struct device *, int); 
d188 2
a189 6
const struct cfattach umass_ca = { 
	sizeof(struct umass_softc), 
	umass_match, 
	umass_attach, 
	umass_detach, 
	umass_activate, 
d191 1
a663 26
	return (rv);
}

int
umass_activate(struct device *dev, int act)
{
	struct umass_softc *sc = (struct umass_softc *)dev;
	struct umassbus_softc *scbus = sc->bus;
	int rv = 0;

	DPRINTF(UDMASS_USB, ("%s: umass_activate: %d\n",
	    sc->sc_dev.dv_xname, act));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		if (scbus == NULL || scbus->sc_child == NULL)
			break;
		rv = config_deactivate(scbus->sc_child);
		DPRINTF(UDMASS_USB, ("%s: umass_activate: child "
		    "returned %d\n", sc->sc_dev.dv_xname, rv));
		break;
	default:
		rv = config_activate_children(dev, act);
		break;
	}
@


1.65
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.64 2013/05/30 16:15:02 deraadt Exp $ */
d659 1
a659 1
		free(scbus, M_DEVBUF);
@


1.64
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.63 2013/04/15 09:23:02 mglocker Exp $ */
d683 1
a683 1
		sc->sc_dying = 1;
d729 1
a729 1
	if (sc->sc_dying)
d790 1
a790 1
	if (sc->sc_dying)
d825 1
a825 1
	if (sc->sc_dying)
d895 1
a895 1
	if (sc->sc_dying)
d934 1
a934 1
	if (sc->sc_dying)
d984 1
a984 1
	if (sc->sc_dying) {
d1100 1
a1100 1
	if (sc->sc_dying)
d1429 1
a1429 1
	if (sc->sc_dying)
d1485 1
a1485 1
	if (sc->sc_dying) {
d1551 1
a1551 1
	if (sc->sc_dying)
@


1.63
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.62 2011/07/03 15:47:17 matthew Exp $ */
d689 3
@


1.62
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.61 2011/05/24 20:27:11 matthew Exp $ */
d200 1
a200 1
				usbd_xfer_handle xfer);
d202 1
a202 1
				usbd_pipe_handle pipe,
d204 1
a204 1
				usbd_xfer_handle xfer);
d208 1
a208 1
				usbd_xfer_handle xfer);
d210 1
a210 1
				usbd_xfer_handle xfer);
d220 1
a220 1
void umass_bbb_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
d228 1
a228 1
void umass_cbi_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
d230 1
a230 1
int umass_cbi_adsc(struct umass_softc *, char *, int, usbd_xfer_handle);
d247 1
a247 1
				umass_bbb_cbw_t *cbw);
d249 1
a249 1
				umass_bbb_csw_t *csw);
d722 1
a722 1
umass_polled_transfer(struct umass_softc *sc, usbd_xfer_handle xfer)
d731 1
a731 1
	 * usbd_xfer_handle and run it after the running one completes.
d781 1
a781 1
umass_setup_transfer(struct umass_softc *sc, usbd_pipe_handle pipe,
d783 1
a783 1
			usbd_xfer_handle xfer)
d818 1
a818 1
	 void *buffer, int buflen, int flags, usbd_xfer_handle xfer)
d890 1
a890 1
	usbd_xfer_handle xfer)
d1021 1
a1021 1
	KASSERT(sizeof(umass_bbb_cbw_t) == UMASS_BBB_CBW_SIZE,
d1024 2
a1025 2
			sizeof(umass_bbb_cbw_t), UMASS_BBB_CBW_SIZE));
	KASSERT(sizeof(umass_bbb_csw_t) == UMASS_BBB_CSW_SIZE,
d1028 1
a1028 1
			sizeof(umass_bbb_csw_t), UMASS_BBB_CSW_SIZE));
d1088 1
a1088 2
umass_bbb_state(usbd_xfer_handle xfer, usbd_private_handle priv,
		usbd_status err)
d1091 1
a1091 1
	usbd_xfer_handle next_xfer;
d1400 1
a1400 1
	       usbd_xfer_handle xfer)
d1540 1
a1540 2
umass_cbi_state(usbd_xfer_handle xfer, usbd_private_handle priv,
		usbd_status err)
d1864 1
a1864 1
umass_bbb_dump_cbw(struct umass_softc *sc, umass_bbb_cbw_t *cbw)
d1884 1
a1884 1
umass_bbb_dump_csw(struct umass_softc *sc, umass_bbb_csw_t *csw)
@


1.61
log
@On OpenBSD, we've always attached scsibus(4) to umass(4), even for
ATAPI devices.  atapiscsi(4) is only for handling ATAPI devices on an
ATA bus, so umass(4) shouldn't care about it.

ok krw@@, dlg@@; no objections from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.60 2011/01/25 20:03:36 jakemsr Exp $ */
a681 3
	case DVACT_ACTIVATE:
		break;

@


1.60
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.59 2009/10/13 19:33:19 pirofti Exp $ */
a126 2
#include "atapiscsi.h"

a597 1
#if (NATAPIBUS > 0) || (NATAPISCSI > 0)
a598 3
#else
		printf("%s: atapiscsi not configured\n", sc->sc_dev.dv_xname);
#endif
@


1.59
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.58 2008/09/25 11:07:12 krw Exp $ */
a622 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a672 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.58
log
@Add 'default:' stanza to switch() to make clear that 'status' is always
initialized. From NetBSD. "won't hurt" miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.57 2008/06/26 05:42:18 ray Exp $ */
d185 1
a185 1
int umass_activate(struct device *, enum devact); 
d684 1
a684 1
umass_activate(struct device *dev, enum devact act)
@


1.57
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.56 2008/05/18 17:15:41 fgsch Exp $ */
a1742 2
			int status;

d1750 1
d1761 1
@


1.56
log
@avoid leaking pipes by not zeroing the pipe after aborting it, so
umass_disco() have a chance to free'em later.
from nathanw@@netbsd. miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.55 2008/02/03 00:36:29 krw Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.55
log
@Redo umass_bbb_get_max_lun() and uses thereof to

1) Not bail out of umass_attach() just because the max lun cannot be
found. Assume 0 and complete attachment.

2) Not expose sc->maxlun to possible misbehaving devices. Provide a
buffer and copy it into sc->maxlun only if the attempt to get the max
lun succeeds.

3) Shrink and simplify error handling and debug output.

Prompted by the recurrance of the problem reported in PR#5478. Code
taken for the most part from FreeBSD.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.54 2007/10/11 18:33:15 deraadt Exp $ */
d647 1
a647 1
		if (sc->sc_pipe[i] != NULL) {
a648 2
			sc->sc_pipe[i] = NULL;
		}
@


1.54
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.53 2007/09/15 19:22:18 bluhm Exp $ */
d231 1
a231 1
usbd_status umass_bbb_get_max_lun(struct umass_softc *, u_int8_t *);
d493 1
a493 6
		err = umass_bbb_get_max_lun(sc, &sc->maxlun);
		if (err) {
			printf("%s: unable to get Max Lun: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
			return;
		}
d1852 2
a1853 2
usbd_status
umass_bbb_get_max_lun(struct umass_softc *sc, u_int8_t *maxlun)
d1857 2
a1858 2

	*maxlun = 0;		/* Default to 0. */
d1869 1
a1869 1
	err = usbd_do_request_flags(sc->sc_udev, &req, maxlun,
d1871 1
d1874 1
a1874 20
		DPRINTF(UDMASS_BBB, ("%s: Max Lun %d\n",
		    sc->sc_dev.dv_xname, *maxlun));
		break;

	case USBD_STALLED:
		/*
		 * Device doesn't support Get Max Lun request.
		 */
		err = USBD_NORMAL_COMPLETION;
		DPRINTF(UDMASS_BBB, ("%s: Get Max Lun not supported\n",
		    sc->sc_dev.dv_xname));
		break;

	case USBD_SHORT_XFER:
		/*
		 * XXX This must mean Get Max Lun is not supported, too!
		 */
		err = USBD_NORMAL_COMPLETION;
		DPRINTF(UDMASS_BBB, ("%s: Get Max Lun SHORT_XFER\n",
		    sc->sc_dev.dv_xname));
a1877 2
		printf("%s: Get Max Lun failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
d1879 2
d1884 2
a1885 1
	return (err);
@


1.53
log
@Allow to pull out an usb stick with ffs filesystem while mounted
and a file is written onto the stick.  Without these fixes the
machine panics or hangs.
The usb fix calls the callback when the stick is pulled out to free
the associated buffers.  Otherwise we have busy buffers for ever
and the automatic unmount will panic.
The change in the scsi layer prevents passing down further dirty
buffers to usb after the stick has been deactivated.
In vfs the automatic unmount has moved from the function vgonel()
to vop_generic_revoke().  Both are called when the sd device's vnode
is removed.  In vgonel() the VXLOCK is already held which can cause
a deadlock.  So call dounmount() earlier.

ok krw@@, I like this marco@@, tested by ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.52 2007/06/14 10:11:16 mbalmer Exp $ */
a319 1
	char *devinfop;
a321 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.52
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.51 2007/06/14 06:55:10 mbalmer Exp $ */
d671 9
@


1.51
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.50 2007/06/13 10:33:52 mbalmer Exp $ */
d189 16
a204 1
USB_DECLARE_DRIVER(umass);
@


1.50
log
@Remove the definition and use of umass/umass_quirks related macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.49 2007/06/10 14:49:01 mbalmer Exp $ */
d143 1
@


1.49
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.48 2007/06/10 10:53:48 mbalmer Exp $ */
d604 1
a604 2
		printf("%s: "UMASS_ATAPISTR" not configured\n",
		       sc->sc_dev.dv_xname);
@


1.48
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.47 2007/06/05 08:43:55 mbalmer Exp $ */
d309 1
a309 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d351 1
a351 1
				USBDEVNAME(sc->sc_dev),
d376 1
a376 1
				USBDEVNAME(sc->sc_dev),
d418 1
a418 1
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sCommand,
d444 1
a444 1
			       USBDEVNAME(sc->sc_dev));
d460 1
a460 1
					USBDEVNAME(sc->sc_dev),
d472 1
a472 1
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN],
d485 1
a485 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d494 1
a494 1
	    USBDEVNAME(sc->sc_dev), sc->sc_iface,
d501 1
a501 1
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKOUT]));
d506 1
a506 1
	    USBDEVNAME(sc->sc_dev), sc->sc_iface,
d512 1
a512 1
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN]));
d530 1
a530 1
		    USBDEVNAME(sc->sc_dev), sc->sc_iface,
d536 1
a536 1
				USBDEVNAME(sc->sc_dev),
d551 1
a551 1
				USBDEVNAME(sc->sc_dev)));
d605 1
a605 1
		       USBDEVNAME(sc->sc_dev));
d610 1
a610 1
		printf("%s: isdata not configured\n", USBDEVNAME(sc->sc_dev));
d615 1
a615 1
		       USBDEVNAME(sc->sc_dev), sc->sc_cmd);
d620 1
a620 1
		printf("%s: bus attach failed\n", USBDEVNAME(sc->sc_dev));
d628 1
a628 1
	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));
d638 1
a638 1
	DPRINTF(UDMASS_USB, ("%s: detached\n", USBDEVNAME(sc->sc_dev)));
d652 1
a652 1
		printf("%s: waiting for refcnt\n", USBDEVNAME(sc->sc_dev));
d686 1
a686 1
	    USBDEVNAME(sc->sc_dev), act));
d698 1
a698 1
		    "returned %d\n", USBDEVNAME(sc->sc_dev), rv));
d749 1
a749 1
			    "pending\n", USBDEVNAME(sc->sc_dev), xfer,
d753 1
a753 1
		    USBDEVNAME(sc->sc_dev), xfer));
d763 1
a763 1
	    USBDEVNAME(sc->sc_dev), xfer));
d767 1
a767 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d807 1
a807 1
		    "buflen=%d flags=0x%x timeout=%d\n", USBDEVNAME(sc->sc_dev),
d813 1
a813 1
		    "flags=0x%x timeout=%d\n", USBDEVNAME(sc->sc_dev),
d818 1
a818 1
			USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d843 1
a843 1
		    "buflen=%d flags=0x%x\n", USBDEVNAME(sc->sc_dev), buffer,
d848 1
a848 1
		    "flags=0x%x\n", USBDEVNAME(sc->sc_dev), buffer, buflen,
d854 1
a854 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d906 1
a906 1
		USBDEVNAME(sc->sc_dev), sc->sc_epaddr[endpt]));
d961 1
a961 1
		USBDEVNAME(sc->sc_dev)));
d985 1
a985 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd));
d1021 1
a1021 1
		("%s: datalen > 0, but no buffer",USBDEVNAME(sc->sc_dev)));
d1024 1
a1024 1
			USBDEVNAME(sc->sc_dev), cmdlen, CBWCDBLENGTH));
d1027 1
a1027 1
			USBDEVNAME(sc->sc_dev)));
d1030 1
a1030 1
			USBDEVNAME(sc->sc_dev)));
d1033 1
a1033 1
			USBDEVNAME(sc->sc_dev),
d1037 1
a1037 1
			USBDEVNAME(sc->sc_dev),
d1123 1
a1123 1
		USBDEVNAME(sc->sc_dev), sc->transfer_state,
d1133 1
a1133 1
				USBDEVNAME(sc->sc_dev)));
d1164 1
a1164 1
				USBDEVNAME(sc->sc_dev)));
d1176 1
a1176 1
				USBDEVNAME(sc->sc_dev), sc->transfer_actlen));
d1180 1
a1180 1
					"%s\n", USBDEVNAME(sc->sc_dev),
d1220 1
a1220 1
			    USBDEVNAME(sc->sc_dev),
d1255 1
a1255 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err),
d1290 1
a1290 1
				USBDEVNAME(sc->sc_dev),
d1299 1
a1299 1
				USBDEVNAME(sc->sc_dev),
d1309 1
a1309 1
				USBDEVNAME(sc->sc_dev),
d1317 1
a1317 1
				USBDEVNAME(sc->sc_dev),
d1326 1
a1326 1
				USBDEVNAME(sc->sc_dev),
d1332 1
a1332 1
				USBDEVNAME(sc->sc_dev),
d1341 1
a1341 1
				USBDEVNAME(sc->sc_dev),
d1365 1
a1365 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1375 1
a1375 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1386 1
a1386 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1401 1
a1401 1
		      USBDEVNAME(sc->sc_dev), sc->transfer_state);
d1455 1
a1455 1
		USBDEVNAME(sc->sc_dev)));
d1459 1
a1459 1
			USBDEVNAME(sc->sc_dev),
d1487 1
a1487 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd, datalen));
d1520 1
a1520 1
		("%s: datalen > 0, but no buffer",USBDEVNAME(sc->sc_dev)));
d1523 1
a1523 1
			USBDEVNAME(sc->sc_dev)));
d1568 1
a1568 1
		USBDEVNAME(sc->sc_dev), sc->transfer_state,
d1577 1
a1577 1
				USBDEVNAME(sc->sc_dev)));
d1595 1
a1595 1
				USBDEVNAME(sc->sc_dev)));
d1622 1
a1622 1
				USBDEVNAME(sc->sc_dev)));
d1634 1
a1634 1
				USBDEVNAME(sc->sc_dev), sc->transfer_actlen));
d1638 1
a1638 1
					"%s\n", USBDEVNAME(sc->sc_dev),
d1689 1
a1689 1
				USBDEVNAME(sc->sc_dev)));
d1709 1
a1709 1
			    USBDEVNAME(sc->sc_dev), actlen));
d1724 1
a1724 1
				USBDEVNAME(sc->sc_dev),
d1743 1
a1743 1
				USBDEVNAME(sc->sc_dev),
d1772 1
a1772 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1784 1
a1784 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1797 1
a1797 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1807 1
a1807 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1818 1
a1818 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1834 1
a1834 1
		      USBDEVNAME(sc->sc_dev), sc->transfer_state);
d1846 1
a1846 1
	DPRINTF(UDMASS_BBB, ("%s: Get Max Lun\n", USBDEVNAME(sc->sc_dev)));
d1860 1
a1860 1
		    USBDEVNAME(sc->sc_dev), *maxlun));
d1869 1
a1869 1
		    USBDEVNAME(sc->sc_dev)));
d1878 1
a1878 1
		    USBDEVNAME(sc->sc_dev)));
d1883 1
a1883 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1904 1
a1904 1
		USBDEVNAME(sc->sc_dev), tag, clen,
d1921 1
a1921 1
		"res = %d, status = 0x%02x (%s)\n", USBDEVNAME(sc->sc_dev),
d1946 1
a1946 1
				USBDEVNAME(sc->sc_dev), s1, s2));
d1954 1
a1954 1
		USBDEVNAME(sc->sc_dev), s1, s2, s3));
@


1.47
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.46 2007/06/01 06:12:20 mbalmer Exp $ */
d626 1
a626 1
			   USBDEV(sc->sc_dev));
d655 1
a655 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d673 1
a673 1
			   USBDEV(sc->sc_dev));
@


1.46
log
@Remove more Free(?)BSD and NetBSD #ifdef/#endifs.  No functional nor
binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.45 2007/05/27 04:00:25 jsg Exp $ */
d189 1
a189 1
Static void umass_disco(struct umass_softc *sc);
d192 1
a192 1
Static usbd_status umass_polled_transfer(struct umass_softc *sc,
d194 1
a194 1
Static usbd_status umass_setup_transfer(struct umass_softc *sc,
d198 1
a198 1
Static usbd_status umass_setup_ctrl_transfer(struct umass_softc *sc,
d202 1
a202 1
Static void umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
d204 1
a204 1
Static void umass_adjust_transfer(struct umass_softc *);
d206 1
a206 1
Static void umass_reset(struct umass_softc *sc,	transfer_cb_f cb, void *priv);
d210 1
a210 1
Static void umass_bbb_transfer(struct umass_softc *, int, void *, int, void *,
d212 2
a213 2
Static void umass_bbb_reset(struct umass_softc *, int);
Static void umass_bbb_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
d218 1
a218 1
Static void umass_cbi_transfer(struct umass_softc *, int, void *, int, void *,
d220 2
a221 2
Static void umass_cbi_reset(struct umass_softc *, int);
Static void umass_cbi_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
d223 1
a223 1
Static int umass_cbi_adsc(struct umass_softc *, char *, int, usbd_xfer_handle);
d239 1
a239 1
Static void umass_bbb_dump_cbw(struct umass_softc *sc,
d241 1
a241 1
Static void umass_bbb_dump_csw(struct umass_softc *sc,
d243 1
a243 1
Static void umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer,
d704 1
a704 1
Static void
d731 1
a731 1
Static usbd_status
d790 1
a790 1
Static usbd_status
d826 1
a826 1
Static usbd_status
d863 1
a863 1
Static void
d898 1
a898 1
Static void
d919 1
a919 1
Static void
d934 1
a934 1
Static void
d976 1
a976 1
Static void
d1097 1
a1097 1
Static void
d1409 1
a1409 1
Static int
d1427 1
a1427 1
Static void
d1479 1
a1479 1
Static void
d1550 1
a1550 1
Static void
d1892 1
a1892 1
Static void
d1912 1
a1912 1
Static void
d1929 1
a1929 1
Static void
@


1.45
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.44 2006/06/23 06:27:11 miod Exp $ */
a139 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a144 5
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <machine/clock.h>
#endif
a595 1
#if defined(__OpenBSD__) || NSCSIBUS > 0
a596 3
#else
		printf("%s: scsibus not configured\n", USBDEVNAME(sc->sc_dev));
#endif
a609 3
#if defined (__NetBSD__) && NWD > 0
		error = umass_isdata_attach(sc);
#else
a610 1
#endif
a1889 3



@


1.44
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.43 2005/08/01 05:36:49 brad Exp $ */
d258 2
a259 1
USB_MATCH(umass)
d261 1
a261 1
	USB_MATCH_START(umass, uaa);
d301 2
a302 1
USB_ATTACH(umass)
d304 2
a305 1
	USB_ATTACH_START(umass, sc, uaa);
d315 1
a315 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d340 1
a340 1
		USB_ATTACH_ERROR_RETURN;
d359 1
a359 1
			USB_ATTACH_ERROR_RETURN;
d384 1
a384 1
			USB_ATTACH_ERROR_RETURN;
d431 1
a431 1
			USB_ATTACH_ERROR_RETURN;
d451 1
a451 1
			USB_ATTACH_ERROR_RETURN;
d481 1
a481 1
		USB_ATTACH_ERROR_RETURN;
d492 1
a492 1
			USB_ATTACH_ERROR_RETURN;
d509 1
a509 1
		USB_ATTACH_ERROR_RETURN;
d520 1
a520 1
		USB_ATTACH_ERROR_RETURN;
d545 1
a545 1
			USB_ATTACH_ERROR_RETURN;
d559 1
a559 1
			USB_ATTACH_ERROR_RETURN;
d577 1
a577 1
			USB_ATTACH_ERROR_RETURN;
d595 1
a595 1
		USB_ATTACH_ERROR_RETURN;
d631 1
a631 1
		USB_ATTACH_ERROR_RETURN;
d636 1
a636 1
		USB_ATTACH_ERROR_RETURN;
a642 2

	USB_ATTACH_SUCCESS_RETURN;
d645 2
a646 1
USB_DETACH(umass)
d648 1
a648 1
	USB_DETACH_START(umass, sc);
@


1.43
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.42 2005/05/24 04:51:04 pascoe Exp $ */
a702 1
		rv = EOPNOTSUPP;
@


1.42
log
@Set the data length on CBI data transfers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.41 2005/05/15 00:23:33 krw Exp $ */
d307 1
a307 1
	char devinfo[1024];
d311 1
a311 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d313 2
a384 2

	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.41
log
@Oops. atapiscsi.h is needed because that's where NATAPISCSI is
defined. Fixes Y-E DATA USB Floppy Drive that otherwise complains
about 'atapiscsi not configured'.

Should fix PR #4204 from Ben Hooper.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.40 2005/05/14 23:36:26 krw Exp $ */
d1552 1
@


1.40
log
@Try to ensure that UFI/ATAPI USB umass devices always get the zero
padded 12 byte commands mandated by the standard. Adapt the Linux data
length twiddling on certain commands. We used to have some of this in
a different form, curtesy of csapuntz@@, but it got lost in subsequent
merges.

Fixes the USB card reader of Quentin Barnes who provided much testing
and feedback for over a year!

Tested by drahn@@, ok marco@@, 'this is good stuff' deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.39 2005/04/01 06:41:13 pascoe Exp $ */
d133 2
@


1.39
log
@Add support for polled umass/SCSI transactions.  Should eliminate the panics
seen at reboot time after writing to umass devices.

ok dlg@@, testing markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.38 2005/03/28 04:46:33 pascoe Exp $ */
a133 9
#if defined(__NetBSD__)
#include "atapibus.h"
#include "scsibus.h"
#elif defined(__OpenBSD__)
#include "atapiscsi.h"
#endif

#include "wd.h"

d151 2
d208 1
d876 35
d1081 1
d1099 1
d1550 4
a1553 1
	if ((err = umass_cbi_adsc(sc, cmd, cmdlen,
@


1.38
log
@Use USBD_DEFAULT_TIMEOUT on control transfers, rather than the SCSI request
timeout.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.37 2005/03/28 04:40:15 pascoe Exp $ */
d158 1
d163 1
d203 2
d750 59
d823 11
a833 4
	err = usbd_transfer(xfer);
	DPRINTF(UDMASS_XFER,("%s: start xfer buffer=%p buflen=%d flags=0x%x "
	    "timeout=%d\n", USBDEVNAME(sc->sc_dev),
	    buffer, buflen, flags | sc->sc_xfer_flags, sc->timeout));
d859 11
a869 1
	err = usbd_transfer(xfer);
d965 1
d974 2
a975 1
	if (sc->sc_dying)
d977 1
d1069 1
a1069 1
	if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1071 1
a1071 1
			sc->transfer_xfer[XFER_BBB_CBW])) {
d1073 3
a1075 1
	}
a1077 1

d1465 2
d1474 2
a1475 1
	if (sc->sc_dying)
d1477 1
d1519 2
a1520 1
	if (umass_cbi_adsc(sc, cmd, cmdlen, sc->transfer_xfer[XFER_CBI_CB]))
d1522 3
@


1.37
log
@minor spelling corrections.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.36 2004/07/21 08:01:30 dlg Exp $ */
d785 3
a787 2
	usbd_setup_default_xfer(xfer, sc->sc_udev, (void *) sc, sc->timeout,
		req, buffer, buflen, flags, sc->sc_methods->wire_state);
@


1.36
log
@update the netbsd license and tags

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.35 2004/07/21 07:57:27 dlg Exp $ */
d755 1
a755 1
	/* Initialiase a USB transfer and then schedule it */
d783 1
a783 1
	/* Initialiase a USB control transfer and then schedule it */
d1014 1
a1014 1
	 * Each transfer is done asynchroneously so after the request/transfer
d1240 1
a1240 1
			/* SCSI command failed but transfer was succesful */
d1361 1
a1361 1
	/* The 0x1d code is the SEND DIAGNOSTIC command. To distingiush between
@


1.35
log
@from netbsd, umass.c 1.103
Mostly stylistic change, making comments and printf()s similar between BBB
and CBI.

ok krw@@
@
text
@d1 39
a39 2
/*	$OpenBSD: umass.c,v 1.34 2004/07/21 07:55:51 dlg Exp $ */
/*	$NetBSD: umass.c,v 1.98 2003/09/08 19:30:59 mycroft Exp $	*/
d78 1
a78 1
 * Ported to NetBSD by Lennart Augustsson <augustss@@netbsd.org>.
@


1.34
log
@from netbsd, umass.c 1.105

do less work if we hit an error

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.33 2004/07/21 07:51:04 dlg Exp $ */
d1028 1
a1028 1
		/* Command transport phase, error handling (ignored if no data
d1033 3
a1035 1
					     &sc->transfer_actlen, NULL);
a1048 1
					return;
a1053 1
					return;
d1055 1
d1078 4
a1081 5
			/* try the transfer below, even if clear stall failed */
			DPRINTF(UDMASS_BBB, ("%s: bulk-%s stall clear failed"
				", %s\n", USBDEVNAME(sc->sc_dev),
				(sc->transfer_dir == DIR_IN? "in":"out"),
				usbd_errstr(err)));
a1443 1

d1447 1
d1456 1
d1466 1
a1469 1
			goto dostatus;
a1470 1
		return;
d1472 1
d1474 8
a1481 4
		/* retrieve the length of the transfer that was done */
		usbd_get_xfer_status(xfer,NULL,NULL,&sc->transfer_actlen,NULL);
		DPRINTF(UDMASS_CBI, ("%s: CBI_DATA actlen=%d\n",
			USBDEVNAME(sc->sc_dev), sc->transfer_actlen));
d1483 5
a1487 5
		if (err) {
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %d failed, "
				"%s\n", USBDEVNAME(sc->sc_dev),
				(sc->transfer_dir == DIR_IN?"in":"out"),
				sc->transfer_datalen,usbd_errstr(err)));
d1489 5
a1493 3
			if (err == USBD_STALLED) {
				sc->transfer_state = TSTATE_CBI_DCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d1495 7
a1501 2
			} else {
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
a1502 1
			return;
d1513 1
a1513 1
	dostatus:
@


1.33
log
@from netbsd, umass.c 1.112
Fix a printf() error.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.32 2004/07/21 07:49:07 dlg Exp $ */
d611 1
a611 1
	struct umassbus_softc *scbus = sc->bus;
d618 1
a618 1
		if (sc->sc_pipe[i] != NULL)
d620 2
d635 1
@


1.32
log
@
from netbsd, umass.c 1.116
When starting a bulk-only transfer, punt early if the device is going away.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.31 2004/07/21 07:48:04 dlg Exp $ */
d1752 1
a1752 1
	int tag = UGETW(csw->dCSWTag);
@


1.31
log
@from netbsd, umass.c 1.104
Do the quirk initialization earlier.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.30 2004/07/21 07:46:55 dlg Exp $ */
d851 3
@


1.30
log
@from netbsd, umass.c 1.101
On a Bulk-In data stall, make sure we copy back the data received, per the
spec.  This is the real problem behind FORCE_SHORT_INQUIRY.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.29 2004/07/21 07:43:41 dlg Exp $ */
d388 8
a556 8
	}

	if (quirk != NULL && quirk->uq_init != NULL) {
		err = (*quirk->uq_init)(sc);
		if (err) {
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
		}
@


1.29
log
@from netbsd, umass.c 1.100 1.113 1.115, umass_scsipi.c 1.11, umassvar.h 1.21
log message for umass 1.98, umass_scsipi.c 1.11, umassvar.h 1.21:
Fix several problems with CCI handling, and enable it: * We were never calling
the callback function when we got a UFI CCI(!). * We were passing a bogus
residual count on non-UFI CCIs. * After a REQUEST SENSE, the UFI CCI may
include the ASC/ASCQ from the sense  information -- don't consider this a
failure.

In addition, remove a horrible hack that was causing us to drop sense
information on the floor and return empty INQUIRY responses, often in the
case where there is a UNIT ATTENTION pending during the INQUIRY.  (Some drives
send the data and then fail, some don't.)

log message for umass.c 1.113:
Do not return STATUS_WIRE_FAILED in response to a CBI stall.  This is perfectly
normal, and is used to report errors.  Instead, use STATUS_CMD_FAILED, which
causes us to do a REQUEST SENSE.  Should address PR 22960.

log message for umass.c 1.115:
Do not do a CBI reset before returning STATUS_CMD_FAILED.  This causes any
sense information to be thrown away, and is therefore nonsensical.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.28 2004/07/17 06:04:00 dlg Exp $ */
d1052 2
a1062 1
	case TSTATE_BBB_DCLEAR: /* stall clear after data phase */
@


1.28
log
@from netbsd, umass.c 1.98, umassvar.h 1.20
log message:
Remove UMASS_QUIRK_NO_START_STOP and UMASS_QUIRK_NO_MAX_LUN.

We don't have UMASS_QUIRK_NO_START_STOP so I didn't have to remove it. I
consider umass_quirks.c to be too different so I hand removed references to
the removed defines. There are some useless entries in there now which will
be cleaned up after umass is merged with netbsd.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.27 2004/07/15 05:48:09 deraadt Exp $ */
a321 4
	/* XXX - Now unsupported CBI with CCI */
	if (sc->sc_wire == UMASS_WPROTO_CBI_I)
		sc->sc_wire = UMASS_WPROTO_CBI;

d452 3
d464 3
d488 3
a1457 10
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
			DPRINTF(UDMASS_CBI, ("%s: no data phase\n",
				USBDEVNAME(sc->sc_dev)));
			sc->transfer_state = TSTATE_CBI_STATUS;
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
					&sc->sbl, sizeof(sc->sbl),
					0,	/* fixed length transfer */
					sc->transfer_xfer[XFER_CBI_STATUS])){
				umass_cbi_reset(sc, STATUS_WIRE_FAILED);
			}
d1461 1
a1461 6
			/* No command completion interrupt. Request
			 * sense data.
			 */
			sc->transfer_state = TSTATE_IDLE;
			sc->transfer_cb(sc, sc->transfer_priv,
			       0, STATUS_CMD_UNKNOWN);
a1462 1

d1495 1
d1502 1
a1502 1
				    sc->transfer_xfer[XFER_CBI_STATUS])){
a1503 1
			}
d1534 9
d1556 2
a1557 1
			if (sc->sbl.ufi.asc == 0 && sc->sbl.ufi.ascq == 0)
d1562 4
a1565 1
			/* No sense, command successful */
d1567 2
d1570 1
d1576 13
a1588 13
				int err;

				if ((sc->sbl.common.value&IDB_VALUE_STATUS_MASK)
							== IDB_VALUE_PASS) {
					err = STATUS_CMD_OK;
				} else if ((sc->sbl.common.value & IDB_VALUE_STATUS_MASK)
							== IDB_VALUE_FAIL ||
					   (sc->sbl.common.value & IDB_VALUE_STATUS_MASK)
						== IDB_VALUE_PERSISTENT) {
					err = STATUS_CMD_FAILED;
				} else {
					err = STATUS_WIRE_FAILED;
				}
d1592 2
a1593 2
						sc->transfer_datalen,
						err);
d1603 4
a1607 5

		sc->transfer_state = TSTATE_IDLE;
		sc->transfer_cb(sc, sc->transfer_priv,
				sc->transfer_datalen,
				STATUS_CMD_FAILED);
d1611 1
a1611 1
		if (err)	/* should not occur */
d1614 6
a1619 3

		/* Something really bad is going on. Reset the device */
		umass_cbi_reset(sc, STATUS_CMD_FAILED);
@


1.27
log
@from netbsd via dlg, umass.c revision 1.97:
Well, this is bloody obscure...
My Imation USB FlashGO! adapter responds to a Get Max Lun request with a
stall.  With uhci, this does the expected thing.  With ohci, it was returning
a "data underrun" error because we weren't setting "buffer rounding" (i.e.
USBD_SHORT_XFER_OK), and the underrun was taking priority.  This happened with
both the ohci in a Mac cube and the builtin ohci on the S3C2410.
So, set USBD_SHORT_XFER_OK on the Get Max Lun.  Now I get a stall reported and
umass attaches correctly.
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.26 2004/06/08 00:24:13 krw Exp $ */
/*	$NetBSD: umass.c,v 1.97 2003/09/04 00:02:59 mycroft Exp $	*/
d444 1
a444 2
	if (sc->sc_wire == UMASS_WPROTO_BBB &&
	    !(sc->sc_quirks & UMASS_QUIRK_NO_MAX_LUN)) {
@


1.26
log
@Make umass CBI buffer handling consistant with BBB buffer handling by
using sc->data_buffer (not sc->tranfer_data), in the actual data
transfer operations.  From NetBSD PR #25676.

ok tdeval@@ deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.25 2003/11/07 11:10:47 jmc Exp $ */
/*	$NetBSD: umass.c,v 1.96 2003/04/26 12:46:59 dsainty Exp $	*/
d1678 2
a1679 1
	err = usbd_do_request(sc->sc_udev, &req, maxlun);
@


1.25
log
@updated URLs from Jared Yanovich;

however, I did not apply the diff exactly. After hunting around I
found URLs for the missing files, and the ../index.html link appears
not to work. I replaced it with a more suitable link.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.24 2003/05/17 06:07:57 nate Exp $ */
d1440 1
a1440 1
					sc->transfer_data, sc->transfer_datalen,
d1449 1
a1449 1
					sc->transfer_data, sc->transfer_datalen,
@


1.24
log
@sync with NetBSD and add various local hacks to make things work correctly
with our scsi layer
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.23 2003/05/07 04:33:33 deraadt Exp $ */
d34 4
a37 4
 * http://www.usb.org/developers/data/devclass/usbmassover_11.pdf
 * http://www.usb.org/developers/data/devclass/usbmassbulk_10.pdf
 * http://www.usb.org/developers/data/devclass/usbmass-cbi10.pdf
 * http://www.usb.org/developers/data/devclass/usbmass-ufi10.pdf
@


1.23
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.22 2003/04/27 11:22:54 ho Exp $ */
/*	$NetBSD: umass.c,v 1.49 2001/01/21 18:56:38 augustss Exp $	*/
d33 1
a33 1
 * Universal Serial Bus Mass Storage Class Bulk-Only Transport
d42 1
a42 1
 * Parts of the code written my Jason R. Thorpe <thorpej@@shagadelic.org>.
d54 2
a55 2
 * - UFI (floppy command set)
 * - 8070 (ATA/ATAPI)
d57 5
a61 4
 * UFI and 8070i are transformed versions of the SCSI command set. The
 * sc->transform method is used to convert the commands into the appropriate
 * format (if at all necessary). For example, UFI requires all commands to be
 * 12 bytes in length amongst other things.
d97 1
a97 6
/* XXX Should we split the driver into a number of files?  umass.c,
 *     umass_scsi.c, umass_8070.c, umass_ufi.c, umass_bbb.c, umass_cbi.c or
 *     something similar?
 */

#if !defined(__OpenBSD__)
d99 3
d104 2
a112 1
#include <sys/ioctl.h>
d127 3
a129 26
#if defined(__FreeBSD__)
#include <cam/cam.h>
#include <cam/cam_ccb.h>
#include <cam/cam_sim.h>
#include <cam/cam_xpt_sim.h>
#include <cam/scsi/scsi_all.h>
#include <cam/scsi/scsi_da.h>

#ifdef UMASS_DO_CAM_RESCAN
#include <sys/devicestat.h>
#include <cam/cam_periph.h>
#endif

#elif defined(__NetBSD__)
#include <sys/scsiio.h>
#include <dev/scsipi/scsi_all.h>
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsiconf.h>

#include <dev/scsipi/atapiconf.h>

#include <dev/scsipi/scsipi_disk.h>
#include <dev/scsipi/scsi_disk.h>
#include <dev/scsipi/scsi_changer.h>

#include <dev/ata/atavar.h>	/* XXX */
a130 15
#define SCSI_LINK_TARGET(sc)  ((sc)->scsipi_scsi.target)
#define SCSI_LINK_LUN(sc)     ((sc)->scsipi_scsi.lun)
#elif defined(__OpenBSD__)
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>
#include <machine/bus.h>

#define SCSI_LINK_TARGET(sc)  ((sc)->target)
#define SCSI_LINK_LUN(sc)     ((sc)->lun)
#define scsipi_generic   scsi_generic

#endif

#define SHORT_INQUIRY_LENGTH    36 /* XXX */
a132 15
#define DIF(m, x)	if (umassdebug & (m)) do { x ; } while (0)
#define DPRINTF(m, x)	if (umassdebug & (m)) logprintf x
#define UDMASS_UPPER	0x00008000	/* upper layer */
#define UDMASS_GEN	0x00010000	/* general */
#define UDMASS_SCSI	0x00020000	/* scsi */
#define UDMASS_UFI	0x00040000	/* ufi command set */
#define UDMASS_8070	0x00080000	/* 8070i command set */
#define UDMASS_USB	0x00100000	/* USB general */
#define UDMASS_BBB	0x00200000	/* Bulk-Only transfers */
#define UDMASS_CBI	0x00400000	/* CBI transfers */
#define UDMASS_ALL	0xffff0000	/* all of the above */

#define UDMASS_XFER	0x40000000	/* all transfers */
#define UDMASS_CMD	0x80000000

a133 328
#else
#define DIF(m, x)	/* nop */
#define DPRINTF(m, x)	/* nop */
#endif


/* Generic definitions */

#define UFI_COMMAND_LENGTH 12
#define ATAPI_COMMAND_LENGTH 12

/* Direction for umass_*_transfer */
#define DIR_NONE	0
#define DIR_IN		1
#define DIR_OUT		2

/* The transfer speed determines the timeout value */
#define UMASS_DEFAULT_TRANSFER_SPEED	150	/* in kb/s, conservative est. */
#define UMASS_FLOPPY_TRANSFER_SPEED	20
#define UMASS_ZIP100_TRANSFER_SPEED	650

#define UMASS_SPINUP_TIME 10000	/* ms */

#ifdef __FreeBSD__
/* device name */
#define DEVNAME		"umass"
#define DEVNAME_SIM	"umass-"

#define UMASS_MAX_TRANSFER_SIZE		65536

/* CAM specific definitions */

/* The bus id, whatever that is */
#define UMASS_SCSI_BUS		0

/* All USB drives are 'connected' to one SIM (SCSI controller). umass3
 * ends up being target 3 on that SIM. When a request for target 3
 * comes in we fetch the softc with devclass_get_softc(target_id).
 *
 * The SIM is the highest target number. This makes sure that umass0 corresponds
 * to target 0 on the USB SCSI bus.
 */
#ifndef UMASS_DEBUG
#define UMASS_SCSIID_MAX	32	/* maximum number of drives expected */
#else
/* while debugging avoid unnecessary clutter in the output at umass_cam_rescan
 * (XPT_PATH_INQ)
 */
#define UMASS_SCSIID_MAX	3	/* maximum number of drives expected */
#endif
#define UMASS_SCSIID_HOST	UMASS_SCSIID_MAX
#endif

#define MS_TO_TICKS(ms) ((ms) * hz / 1000)


/* Bulk-Only features */

#define UR_BBB_RESET	0xff		/* Bulk-Only reset */
#define	UR_BBB_GET_MAX_LUN	0xfe

/* Command Block Wrapper */
typedef struct {
	uDWord		dCBWSignature;
#	define CBWSIGNATURE	0x43425355
	uDWord		dCBWTag;
	uDWord		dCBWDataTransferLength;
	uByte		bCBWFlags;
#	define CBWFLAGS_OUT	0x00
#	define CBWFLAGS_IN	0x80
	uByte		bCBWLUN;
	uByte		bCDBLength;
#	define CBWCDBLENGTH	16
	uByte		CBWCDB[CBWCDBLENGTH];
} umass_bbb_cbw_t;
#define UMASS_BBB_CBW_SIZE	31

/* Command Status Wrapper */
typedef struct {
	uDWord		dCSWSignature;
#	define CSWSIGNATURE	0x53425355
	uDWord		dCSWTag;
	uDWord		dCSWDataResidue;
	uByte		bCSWStatus;
#	define CSWSTATUS_GOOD	0x0
#	define CSWSTATUS_FAILED 0x1
#	define CSWSTATUS_PHASE	0x2
} umass_bbb_csw_t;
#define UMASS_BBB_CSW_SIZE	13

/* CBI features */

#define UR_CBI_ADSC	0x00

typedef unsigned char umass_cbi_cbl_t[16];	/* Command block */

typedef union {
	struct {
		unsigned char	type;
		#define IDB_TYPE_CCI		0x00
		unsigned char	value;
		#define IDB_VALUE_PASS		0x00
		#define IDB_VALUE_FAIL		0x01
		#define IDB_VALUE_PHASE		0x02
		#define IDB_VALUE_PERSISTENT	0x03
		#define IDB_VALUE_STATUS_MASK	0x03
	} common;

	struct {
		unsigned char	asc;
		unsigned char	ascq;
	} ufi;
} umass_cbi_sbl_t;



struct umass_softc;		/* see below */

typedef void (*transfer_cb_f)(struct umass_softc *sc, void *priv,
				int residue, int status);
#define STATUS_CMD_OK		0	/* everything ok */
#define STATUS_CMD_UNKNOWN	1	/* will have to fetch sense */
#define STATUS_CMD_FAILED	2	/* transfer was ok, command failed */
#define STATUS_WIRE_FAILED	3	/* couldn't even get command across */

typedef void (*wire_reset_f)(struct umass_softc *sc, int status);
typedef void (*wire_transfer_f)(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen, void *data, int datalen,
				int dir, transfer_cb_f cb, void *priv);
typedef void (*wire_state_f)(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);

#if defined(__FreeBSD__)
typedef int (*command_transform_f)(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);
#endif


/* the per device structure */
struct umass_softc {
	USBBASEDEVICE		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;	/* device */

	unsigned char		drive;
#	define DRIVE_GENERIC		0	/* use defaults for this one */
#	define ZIP_100			1	/* to be used for quirks */
#       define ZIP_250                  2
#	define SHUTTLE_EUSB		3
#       define INSYSTEM_USBCABLE        4
	unsigned char		quirks;
	/* The drive does not support Test Unit Ready. Convert to
	 * Start Unit.
	 * Y-E Data
	 * ZIP 100
	 */
#	define NO_TEST_UNIT_READY	0x01
	/* The drive does not reset the Unit Attention state after
	 * REQUEST SENSE has been sent. The INQUIRY command does not reset
	 * the UA either, and so CAM runs in circles trying to retrieve the
	 * initial INQUIRY data.
	 * Y-E Data
	 */
#	define RS_NO_CLEAR_UA		0x02	/* no REQUEST SENSE on INQUIRY*/
	/* The drive does not support START_STOP.
	 * Shuttle E-USB
	 */
#	define NO_START_STOP		0x04
	/* Don't ask for full inquiry data (255 bytes).
	 * Yano ATAPI-USB
	 */
#       define FORCE_SHORT_INQUIRY      0x08

	unsigned int		proto;
#	define PROTO_UNKNOWN	0x0000		/* unknown protocol */
#	define PROTO_BBB	0x0001		/* USB wire protocol */
#	define PROTO_CBI	0x0002
#	define PROTO_CBI_I	0x0004
#	define PROTO_WIRE	0x00ff		/* USB wire protocol mask */
#	define PROTO_SCSI	0x0100		/* command protocol */
#	define PROTO_ATAPI	0x0200
#	define PROTO_UFI	0x0400
#       define PROTO_RBC        0x0800
#	define PROTO_COMMAND	0xff00		/* command protocol mask */

	u_char                  subclass;       /* interface subclass */
	u_char                  protocol;       /* interface protocol */

	usbd_interface_handle	iface;		/* Mass Storage interface */
	int			ifaceno;	/* MS iface number */

	u_int8_t		bulkin;		/* bulk-in Endpoint Address */
	u_int8_t		bulkout;	/* bulk-out Endpoint Address */
	u_int8_t		intrin;		/* intr-in Endp. (CBI) */
	usbd_pipe_handle	bulkin_pipe;
	usbd_pipe_handle	bulkout_pipe;
	usbd_pipe_handle	intrin_pipe;

	/* Reset the device in a wire protocol specific way */
	wire_reset_f		reset;

	/* The start of a wire transfer. It prepares the whole transfer (cmd,
	 * data, and status stage) and initiates it. It is up to the state
	 * machine (below) to handle the various stages and errors in these
	 */
	wire_transfer_f		transfer;

	/* The state machine, handling the various states during a transfer */
	wire_state_f		state;

#if defined(__FreeBSD__)
	/* The command transform function is used to conver the SCSI commands
	 * into their derivatives, like UFI, ATAPI, and friends.
	 */
	command_transform_f	transform;	/* command transform */
#endif

	/* Bulk specific variables for transfers in progress */
	umass_bbb_cbw_t		cbw;	/* command block wrapper */
	umass_bbb_csw_t		csw;	/* command status wrapper*/
	/* CBI specific variables for transfers in progress */
	umass_cbi_cbl_t		cbl;	/* command block */
	umass_cbi_sbl_t		sbl;	/* status block */

	/* generic variables for transfers in progress */
	/* ctrl transfer requests */
	usb_device_request_t	request;

	/* xfer handles
	 * Most of our operations are initiated from interrupt context, so
	 * we need to avoid using the one that is in use. We want to avoid
	 * allocating them in the interrupt context as well.
	 */
	/* indices into array below */
#	define XFER_BBB_CBW		0	/* Bulk-Only */
#	define XFER_BBB_DATA		1
#	define XFER_BBB_DCLEAR		2
#	define XFER_BBB_CSW1		3
#	define XFER_BBB_CSW2		4
#	define XFER_BBB_SCLEAR		5
#	define XFER_BBB_RESET1		6
#	define XFER_BBB_RESET2		7
#	define XFER_BBB_RESET3		8

#	define XFER_CBI_CB		0	/* CBI */
#	define XFER_CBI_DATA		1
#	define XFER_CBI_STATUS		2
#	define XFER_CBI_DCLEAR		3
#	define XFER_CBI_SCLEAR		4
#	define XFER_CBI_RESET1		5
#	define XFER_CBI_RESET2		6
#	define XFER_CBI_RESET3		7

#	define XFER_NR			9	/* maximum number */

	usbd_xfer_handle	transfer_xfer[XFER_NR]; /* for ctrl xfers */

	void			*data_buffer;

	int			transfer_dir;		/* data direction */
	void			*transfer_data;		/* data buffer */
	int			transfer_datalen;	/* (maximum) length */
	int			transfer_actlen;	/* actual length */
	transfer_cb_f		transfer_cb;		/* callback */
	void			*transfer_priv;		/* for callback */
	int			transfer_status;

	int			transfer_state;
#	define TSTATE_IDLE			0
#	define TSTATE_BBB_COMMAND		1	/* CBW transfer */
#	define TSTATE_BBB_DATA			2	/* Data transfer */
#	define TSTATE_BBB_DCLEAR		3	/* clear endpt stall */
#	define TSTATE_BBB_STATUS1		4	/* clear endpt stall */
#	define TSTATE_BBB_SCLEAR		5	/* clear endpt stall */
#	define TSTATE_BBB_STATUS2		6	/* CSW transfer */
#	define TSTATE_BBB_RESET1		7	/* reset command */
#	define TSTATE_BBB_RESET2		8	/* in clear stall */
#	define TSTATE_BBB_RESET3		9	/* out clear stall */
#	define TSTATE_CBI_COMMAND		10	/* command transfer */
#	define TSTATE_CBI_DATA			11	/* data transfer */
#	define TSTATE_CBI_STATUS		12	/* status transfer */
#	define TSTATE_CBI_DCLEAR		13	/* clear ep stall */
#	define TSTATE_CBI_SCLEAR		14	/* clear ep stall */
#	define TSTATE_CBI_RESET1		15	/* reset command */
#	define TSTATE_CBI_RESET2		16	/* in clear stall */
#	define TSTATE_CBI_RESET3		17	/* out clear stall */
#	define TSTATE_STATES			18	/* # of states above */


	int			transfer_speed;		/* in kb/s */
	int			timeout;		/* in msecs */

	u_int8_t		maxlun;			/* max lun supported */

#ifdef UMASS_DEBUG
	struct timeval tv;
#endif

#if defined(__FreeBSD__)
	/* SCSI/CAM specific variables */
	struct scsi_sense	cam_scsi_sense;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
	union {
		struct scsipi_link	sc_link;
#if defined(__NetBSD__)
		struct {
			struct ata_atapi_attach	sc_aa;
			struct ata_drive_datas	sc_aa_drive;
		} aa;
#endif
	} u;
#if defined(__NetBSD__)
	struct atapi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter._generic
#else
	struct scsi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter
#endif
	int			sc_xfer_flags;
	usbd_status		sc_sync_status;
	struct scsipi_sense	sc_sense_cmd;

	device_ptr_t		sc_child;	/* child device, for detach */
	char			sc_dying;

#endif
};
a134 1
#ifdef UMASS_DEBUG
a158 4
struct cam_sim *umass_sim;	/* SCSI Interface Module */
struct cam_path *umass_path;	/*   and its path */


a161 4
Static int umass_match_proto(struct umass_softc *sc,
				usbd_interface_handle iface,
				usbd_device_handle dev);
Static void umass_init_shuttle(struct umass_softc *sc);
a168 1
				usbd_device_handle dev,
d172 2
a173 3
Static void umass_clear_endpoint_stall(struct umass_softc *sc,
				u_int8_t endpt, usbd_pipe_handle pipe,
				int state, usbd_xfer_handle xfer);
d175 1
a175 2
Static void umass_reset(struct umass_softc *sc,
				transfer_cb_f cb, void *priv);
d179 4
a182 10
Static void umass_bbb_reset(struct umass_softc *sc, int status);
Static void umass_bbb_transfer(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen,
				void *data, int datalen, int dir,
				transfer_cb_f cb, void *priv);
Static void umass_bbb_state(usbd_xfer_handle xfer,
				usbd_private_handle priv,
				usbd_status err);
usbd_status umass_bbb_get_max_lun(struct umass_softc *sc,
				       u_int8_t *maxlun);
d184 1
d187 12
a198 33
Static int umass_cbi_adsc(struct umass_softc *sc, char *buffer,int buflen,
				usbd_xfer_handle xfer);
Static void umass_cbi_reset(struct umass_softc *sc, int status);
Static void umass_cbi_transfer(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen,
				void *data, int datalen, int dir,
				transfer_cb_f cb, void *priv);
Static void umass_cbi_state(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);

#if defined(__FreeBSD__)
/* CAM related functions */
Static void umass_cam_action(struct cam_sim *sim, union ccb *ccb);
Static void umass_cam_poll(struct cam_sim *sim);

Static void umass_cam_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
Static void umass_cam_sense_cb(struct umass_softc *sc, void *priv,
				int residue, int status);

#ifdef UMASS_DO_CAM_RESCAN
Static void umass_cam_rescan(struct umass_softc *sc);
#endif

Static int umass_cam_attach_sim(void);
Static int umass_cam_attach(struct umass_softc *sc);
Static int umass_cam_detach_sim(void);
Static int umass_cam_detach(struct umass_softc *sc);

#elif defined(__NetBSD__) || defined(__OpenBSD__)

#define UMASS_SCSIID_HOST	0x00
#define UMASS_SCSIID_DEVICE	0x01
d200 4
a203 10
#define UMASS_ATAPI_DRIVE       0

#define UMASS_MAX_TRANSFER_SIZE	MAXBSIZE

struct scsipi_device umass_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
a205 36
Static int umass_scsipi_cmd(struct scsipi_xfer *xs);
Static void umass_scsipi_minphys(struct buf *bp);
Static int umass_scsipi_ioctl(struct scsipi_link *, u_long,
				   caddr_t, int, struct proc *);
Static void umass_scsipi_cb(struct umass_softc *sc, void *priv,
				     int residue, int status);
Static void umass_scsipi_sense_cb(struct umass_softc *sc, void *priv,
				       int residue, int status);

Static int scsipiprint(void *aux, const char *pnp);
Static int umass_ufi_transform(struct umass_softc *sc,
    struct scsipi_generic *cmd, int cmdlen,
    struct scsipi_generic *rcmd, int *rcmdlen);

#if NATAPIBUS > 0
Static void umass_atapi_probedev(struct atapibus_softc *, int);
#endif
#endif

#if defined(__FreeBSD__)
/* SCSI specific functions */
Static int umass_scsi_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);

/* UFI specific functions */
Static int umass_ufi_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);

/* 8070 specific functions */
Static int umass_8070_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);
#endif

a216 2
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);	/* XXXXX */

d221 1
a221 11
/*
 * Match the device we are seeing with the devices supported. Fill in the
 * proto and drive fields in the softc accordingly.
 * This function is called from both probe and attach.
 */

Static int
umass_match_proto(sc, iface, dev)
	struct umass_softc *sc;
	usbd_interface_handle iface;
	usbd_device_handle dev;
d223 2
a224 1
	usb_device_descriptor_t *dd;
a225 1
	u_int vendor, product;
d227 2
a228 75
	/*
	 * Fill in sc->drive and sc->proto and return a match
	 * value if both are determined and 0 otherwise.
	 */

	sc->drive = DRIVE_GENERIC;
	sc->proto = PROTO_UNKNOWN;
	sc->transfer_speed = UMASS_DEFAULT_TRANSFER_SPEED;

	sc->sc_udev = dev;
	dd = usbd_get_device_descriptor(dev);
	vendor = UGETW(dd->idVendor);
	product = UGETW(dd->idProduct);

	if (vendor == USB_VENDOR_SHUTTLE &&
	    product == USB_PRODUCT_SHUTTLE_EUSB) {
		sc->drive = SHUTTLE_EUSB;
#if CBI_I
		sc->proto = PROTO_ATAPI | PROTO_CBI_I;
#else
		sc->proto = PROTO_ATAPI | PROTO_CBI;
#endif
		sc->subclass = UISUBCLASS_SFF8020I;
		sc->protocol = UIPROTO_MASS_CBI;
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;
		return (UMATCH_VENDOR_PRODUCT);
	}

	if (vendor == USB_VENDOR_TRUMPION &&
	    product == USB_PRODUCT_TRUMPION_XXX1100) {
		sc->proto = PROTO_ATAPI | PROTO_CBI;
		return (UMATCH_VENDOR_PRODUCT);
	}

	if (vendor == USB_VENDOR_YANO &&
	    product == USB_PRODUCT_YANO_U640MO) {
		sc->proto = PROTO_ATAPI | PROTO_CBI_I;
		sc->quirks |= FORCE_SHORT_INQUIRY;
		return (UMATCH_VENDOR_PRODUCT);
	}

	if (vendor == USB_VENDOR_SONY &&
	    product == USB_PRODUCT_SONY_MSC) {
		printf ("XXX Sony MSC\n");
		sc->quirks |= FORCE_SHORT_INQUIRY;
	}

	if (vendor == USB_VENDOR_YEDATA &&
	    product == USB_PRODUCT_YEDATA_FLASHBUSTERU) {

		/* Revisions < 1.28 do not handle the interrupt endpoint
		 * very well.
		 */
		if (UGETW(dd->bcdDevice) < 0x128)
			sc->proto = PROTO_UFI | PROTO_CBI;
		else
#if CBI_I
			sc->proto = PROTO_UFI | PROTO_CBI_I;
#else
			sc->proto = PROTO_UFI | PROTO_CBI;
#endif
		/*
		 * Revisions < 1.28 do not have the TEST UNIT READY command
		 * Revisions == 1.28 have a broken TEST UNIT READY
		 */
		if (UGETW(dd->bcdDevice) <= 0x128)
			sc->quirks |= NO_TEST_UNIT_READY;

		sc->subclass = UISUBCLASS_UFI;
		sc->protocol = UIPROTO_MASS_CBI;

		sc->quirks |= RS_NO_CLEAR_UA;
		sc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;
		return (UMATCH_VENDOR_PRODUCT_REV);
	}
d230 3
a232 7
	if (vendor == USB_VENDOR_INSYSTEM &&
	    product == USB_PRODUCT_INSYSTEM_USBCABLE) {
		sc->drive = INSYSTEM_USBCABLE;
		sc->proto = PROTO_ATAPI | PROTO_CBI;
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;
		return (UMATCH_VENDOR_PRODUCT);
	}
d234 1
a234 1
	id = usbd_get_interface_descriptor(iface);
d238 4
a241 21
	if (vendor == USB_VENDOR_SONY && id->bInterfaceSubClass == 0xff) {
		/*
		 * Sony DSC devices set the sub class to 0xff
		 * instead of 1 (RBC). Fix that here.
		 */
		id->bInterfaceSubClass = UISUBCLASS_RBC;
		/* They also should be able to do higher speed. */
		sc->transfer_speed = 500;
	}

	if (vendor == USB_VENDOR_FUJIPHOTO &&
	    product == USB_PRODUCT_FUJIPHOTO_MASS0100)
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;

	sc->subclass = id->bInterfaceSubClass;
	sc->protocol = id->bInterfaceProtocol;

	switch (sc->subclass) {
	case UISUBCLASS_SCSI:
		sc->proto |= PROTO_SCSI;
		break;
a242 4
		sc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;
		sc->proto |= PROTO_UFI;
		break;
	case UISUBCLASS_SFF8020I:
d244 1
a244 5
	case UISUBCLASS_QIC157:
		sc->proto |= PROTO_ATAPI;
		break;
	case UISUBCLASS_RBC:
		sc->proto |= PROTO_RBC;
d247 1
a247 6
		/* Assume that unsupported devices are ATAPI */
		DPRINTF(UDMASS_GEN, ("%s: Unsupported command protocol %d\n",
			USBDEVNAME(sc->sc_dev), id->bInterfaceSubClass));

		sc->proto |= PROTO_ATAPI;
		break;
d250 2
a251 1
	switch (sc->protocol) {
d253 1
a253 9
		sc->proto |= PROTO_CBI;
		break;
	case UIPROTO_MASS_CBI_I:
#if CBI_I
		sc->proto |= PROTO_CBI_I;
#else
		sc->proto |= PROTO_CBI;
#endif
		break;
a254 7
		sc->proto |= PROTO_BBB;
		break;
	case UIPROTO_MASS_BBB_P:
		sc->drive = ZIP_100;
		sc->proto |= PROTO_BBB;
		sc->transfer_speed = UMASS_ZIP100_TRANSFER_SPEED;
		sc->quirks |= NO_TEST_UNIT_READY;
d257 1
a257 3
		DPRINTF(UDMASS_GEN, ("%s: Unsupported wire protocol %d\n",
			USBDEVNAME(sc->sc_dev), id->bInterfaceProtocol));
		return (UMATCH_NONE);
d260 1
a260 18
	return (UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO);
}

USB_MATCH(umass)
{
	USB_MATCH_START(umass, uaa);
#if defined(__FreeBSD__)
	struct umass_softc *sc = device_get_softc(self);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	struct umass_softc scs, *sc = &scs;
	memset(sc, 0, sizeof *sc);
	strlcpy(sc->sc_dev.dv_xname, "umass", sizeof sc->sc_dev.dv_xname);
#endif

	if (uaa->iface == NULL)
		return(UMATCH_NONE);

	return (umass_match_proto(sc, uaa->iface, uaa->device));
a262 2
void umass_delayed_attach(struct umass_softc  *sc);

d266 1
d269 1
a269 1
	const char *sSubclass, *sProto;
d271 2
a272 7
	int i, bno;
	int err;

	/*
	 * the softc struct is bzero-ed in device_set_driver. We can safely
	 * call umass_detach without specifically initialising the struct.
	 */
d277 19
a295 2
	sc->iface = uaa->iface;
	sc->ifaceno = uaa->ifaceno;
d297 2
a298 3
	/* initialise the proto and drive values in the umass_softc (again) */
	if (umass_match_proto(sc, sc->iface, uaa->device) == 0) {
		printf("%s: match failed\n", USBDEVNAME(sc->sc_dev));
d300 20
d322 28
a349 8
	/*
	 * The timeout is based on the maximum expected transfer size
	 * divided by the expected transfer speed.
	 * We multiply by 4 to make sure a busy system doesn't make things
	 * fail.
	 */
	sc->timeout = 4 * UMASS_MAX_TRANSFER_SIZE / sc->transfer_speed;
	sc->timeout += UMASS_SPINUP_TIME;	/* allow for spinning up */
a350 1
	id = usbd_get_interface_descriptor(sc->iface);
d353 3
a355 12
	switch (sc->subclass) {
	case UISUBCLASS_RBC:
		sSubclass = "RBC";
		break;
	case UISUBCLASS_SCSI:
		sSubclass = "SCSI";
		break;
	case UISUBCLASS_UFI:
		sSubclass = "UFI";
		break;
	case UISUBCLASS_SFF8020I:
		sSubclass = "SFF8020i";
d357 2
a358 2
	case UISUBCLASS_SFF8070I:
		sSubclass = "SFF8070i";
d360 2
a361 2
	case UISUBCLASS_QIC157:
		sSubclass = "QIC157";
d364 1
a364 1
		sSubclass = "unknown";
d367 7
a373 3
	switch (sc->protocol) {
	case UIPROTO_MASS_CBI:
		sProto = "CBI";
d375 2
a376 2
	case UIPROTO_MASS_CBI_I:
		sProto = "CBI-I";
d378 2
a379 2
	case UIPROTO_MASS_BBB:
		sProto = "BBB";
d381 2
a382 2
	case UIPROTO_MASS_BBB_P:
		sProto = "BBB-P";
d385 1
a385 1
		sProto = "unknown";
a387 2
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sSubclass,
	       sProto);
d389 2
a390 10
	if (sc->drive == INSYSTEM_USBCABLE) {
		err = usbd_set_interface(0, 1);
		if (err) {
			DPRINTF(UDMASS_USB, ("%s: could not switch to "
					     "Alt Interface %d\n",
					     USBDEVNAME(sc->sc_dev), 1));
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
                }
	}
d404 2
a405 2
		ed = usbd_interface2endpoint_descriptor(sc->iface, i);
		if (!ed) {
d412 1
a412 1
			sc->bulkin = ed->bEndpointAddress;
d415 2
a416 2
			sc->bulkout = ed->bEndpointAddress;
		} else if (sc->proto & PROTO_CBI_I
d419 1
a419 1
			sc->intrin = ed->bEndpointAddress;
d431 7
a437 6
	if (!sc->bulkin || !sc->bulkout
	    || (sc->proto & PROTO_CBI_I && !sc->intrin) ) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %d/%d/%d\n",
			USBDEVNAME(sc->sc_dev),
			sc->bulkin, sc->bulkout, sc->intrin));
		umass_disco(sc);
d444 2
a445 1
	if ((sc->proto & PROTO_WIRE) == PROTO_BBB) {
d457 3
a459 2
	err = usbd_open_pipe(sc->iface, sc->bulkout,
				USBD_EXCLUSIVE_USE, &sc->bulkout_pipe);
d461 2
a462 2
		DPRINTF(UDMASS_USB, ("%s: cannot open %d-out pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->bulkout));
d466 2
a467 2
	err = usbd_open_pipe(sc->iface, sc->bulkin,
				USBD_EXCLUSIVE_USE, &sc->bulkin_pipe);
d469 2
a470 2
		DPRINTF(UDMASS_USB, ("%s: could not open %d-in pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->bulkin));
d486 3
a488 3
	if (sc->proto & PROTO_CBI_I) {
		err = usbd_open_pipe(sc->iface, sc->intrin,
				USBD_EXCLUSIVE_USE, &sc->intrin_pipe);
d490 3
a492 2
			DPRINTF(UDMASS_USB, ("%s: couldn't open %d-in (intr)\n",
				USBDEVNAME(sc->sc_dev), sc->intrin));
d504 1
a504 1
		if (sc->transfer_xfer[i] == 0) {
d512 2
a513 2
	switch (sc->proto & PROTO_WIRE) {
	case PROTO_BBB:
d516 1
a516 1
	case PROTO_CBI:
d519 1
a519 1
	case PROTO_CBI_I:
d534 11
a544 13
	if (sc->proto & PROTO_BBB) {
		sc->reset = umass_bbb_reset;
		sc->transfer = umass_bbb_transfer;
		sc->state = umass_bbb_state;
	} else if ((sc->proto & PROTO_CBI) || (sc->proto & PROTO_CBI_I)) {
		sc->reset = umass_cbi_reset;
		sc->transfer = umass_cbi_transfer;
		sc->state = umass_cbi_state;
#ifdef UMASS_DEBUG
	} else {
		panic("%s:%d: Unknown proto 0x%02x",
		      __FILE__, __LINE__, sc->proto);
#endif
d547 7
a553 2
	if (sc->drive == SHUTTLE_EUSB)
		umass_init_shuttle(sc);
d555 10
a564 5
	/*
	 * Fill in the adapter.
	 */
	sc->sc_adapter.scsipi_cmd = umass_scsipi_cmd;
	sc->sc_adapter.scsipi_minphys = umass_scsipi_minphys;
d566 9
a574 21
	/*
	 * fill in the prototype scsipi_link.
	 */
	switch (sc->proto & PROTO_COMMAND) {
	case PROTO_SCSI:
	case PROTO_UFI:
	case PROTO_ATAPI:
	case PROTO_RBC:
		if ((sc->proto & PROTO_COMMAND) != PROTO_SCSI)
			sc->u.sc_link.flags |= SDEV_ATAPI;
		else
			sc->u.sc_link.flags &= ~SDEV_ATAPI;

		sc->u.sc_link.adapter_buswidth = 2;
		sc->u.sc_link.adapter_target = UMASS_SCSIID_HOST;
		sc->u.sc_link.luns = sc->maxlun + 1;

		sc->u.sc_link.adapter_softc = sc;
		sc->u.sc_link.adapter = &sc->sc_adapter;
		sc->u.sc_link.device = &umass_dev;
		sc->u.sc_link.openings = 1;
d576 6
a581 2
		if(sc->quirks & NO_TEST_UNIT_READY)
			sc->u.sc_link.quirks |= ADEV_NOTUR;
a583 1

d585 2
a586 2
		printf("%s: proto=0x%x not supported yet\n",
		       USBDEVNAME(sc->sc_dev), sc->proto);
d590 2
a591 19

	if (cold) {
		startuphook_establish((void (*)(void *))umass_delayed_attach,
			sc);
	} else {
		/* hot plug, do it now */
		umass_delayed_attach(sc);
	}

	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
}

void
umass_delayed_attach(struct umass_softc  *sc)
{
	sc->sc_child = config_found(&sc->sc_dev, &sc->u, scsipiprint);
	if (sc->sc_child == NULL) {
d593 1
a593 2
		/* Not an error, just not a complete success. */
		USB_ATTACH_SUCCESS_RETURN;
a597 1
}
d599 3
a601 16
Static int
scsipiprint(aux, pnp)
	void *aux;
	const char *pnp;
{
#if !defined(__OpenBSD__)
	extern int atapi_print(void *aux, const char *pnp);
	struct scsipi_link *l = aux;

	if (l->type == BUS_SCSI)
		return (scsiprint(aux, pnp));
	else
		return (atapi_print(aux, pnp));
#else
	return (scsiprint(aux, pnp));
#endif
d607 2
a608 1
	int rv = 0;
d613 4
a616 6
	if (sc->bulkout_pipe != NULL)
		usbd_abort_pipe(sc->bulkout_pipe);
	if (sc->bulkin_pipe != NULL)
		usbd_abort_pipe(sc->bulkin_pipe);
	if (sc->intrin_pipe != NULL)
		usbd_abort_pipe(sc->intrin_pipe);
a617 1
#if 0
d621 3
a627 1
#endif
d629 7
a635 10
#if defined(__FreeBSD__)
	if ((sc->proto & PROTO_SCSI) ||
	    (sc->proto & PROTO_ATAPI) ||
	    (sc->proto & PROTO_UFI))
		/* detach the device from the SCSI host controller (SIM) */
		rv = umass_cam_detach(sc);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
#endif
d644 1
a644 1
	return (0);
a646 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d648 1
a648 3
umass_activate(self, act)
	struct device *self;
	enum devact act;
d650 2
a651 1
	struct umass_softc *sc = (struct umass_softc *) self;
d663 2
a664 1
		if (sc->sc_child == NULL)
d666 1
a666 1
		rv = config_deactivate(sc->sc_child);
a668 2
		if (rv == 0)
			sc->sc_dying = 1;
a672 1
#endif
d675 1
a675 2
umass_disco(sc)
	struct umass_softc *sc;
d689 6
a694 21
	if (sc->bulkout_pipe != NULL)
		usbd_close_pipe(sc->bulkout_pipe);
	if (sc->bulkin_pipe != NULL)
		usbd_close_pipe(sc->bulkin_pipe);
	if (sc->intrin_pipe != NULL)
		usbd_close_pipe(sc->intrin_pipe);
}

Static void
umass_init_shuttle(struct umass_softc *sc)
{
	usb_device_request_t req;
	u_char status[2];

	/* The Linux driver does this */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = 1;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->ifaceno);
	USETW(req.wLength, sizeof status);
	(void)usbd_do_request(sc->sc_udev, &req, &status);
d714 1
a714 1
	    flags | sc->sc_xfer_flags, sc->timeout, sc->state);
d731 2
a732 4
umass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,
	 usb_device_request_t *req,
	 void *buffer, int buflen, int flags,
	 usbd_xfer_handle xfer)
d741 2
a742 2
	usbd_setup_default_xfer(xfer, dev, (void *) sc,
	    sc->timeout, req, buffer, buflen, flags, sc->state);
d757 2
a758 3
umass_clear_endpoint_stall(struct umass_softc *sc,
	u_int8_t endpt, usbd_pipe_handle pipe,
	int state, usbd_xfer_handle xfer)
a759 2
	usbd_device_handle dev;

d764 1
a764 3
		USBDEVNAME(sc->sc_dev), endpt));

	usbd_interface2device_handle(sc->iface, &dev);
d766 1
a766 1
	sc->transfer_state = state;
d768 6
a773 8
	usbd_clear_endpoint_toggle(pipe);

	sc->request.bmRequestType = UT_WRITE_ENDPOINT;
	sc->request.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->request.wValue, UF_ENDPOINT_HALT);
	USETW(sc->request.wIndex, endpt);
	USETW(sc->request.wLength, 0);
	umass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);
d795 3
a797 4
	usbd_device_handle dev;

	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_reset\n", sc->proto));
a823 2
	usbd_interface2device_handle(sc->iface, &dev);

d825 6
a830 6
	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->request.bRequest = UR_BBB_RESET;
	USETW(sc->request.wValue, 0);
	USETW(sc->request.wIndex, sc->ifaceno);
	USETW(sc->request.wLength, 0);
	umass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,
d836 2
a837 2
		    void *data, int datalen, int dir,
		    transfer_cb_f cb, void *priv)
d844 6
a849 3
	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_transfer\n",
		sc->proto));
d921 1
a921 1
	bcopy(cmd, sc->cbw.CBWCDB, cmdlen);
d938 1
a938 1
	if (umass_setup_transfer(sc, sc->bulkout_pipe,
d953 3
a955 2
	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_state\n",sc->proto));
d994 1
a994 1
			if (umass_setup_transfer(sc, sc->bulkin_pipe,
d1004 1
a1004 1
			if (umass_setup_transfer(sc, sc->bulkout_pipe,
d1026 1
a1026 1
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %db failed, "
d1032 1
d1035 1
a1035 4
					    sc->bulkin:sc->bulkout),
					  (sc->transfer_dir == DIR_IN?
					    sc->bulkin_pipe:sc->bulkout_pipe),
					  TSTATE_BBB_DCLEAR,
d1091 2
a1092 3
		if (umass_setup_transfer(sc, sc->bulkin_pipe,
				&sc->csw, UMASS_BBB_CSW_SIZE, 0,
				next_xfer)) {
d1111 3
a1113 4
				umass_clear_endpoint_stall(sc,
						sc->bulkin, sc->bulkin_pipe,
						TSTATE_BBB_SCLEAR,
						sc->transfer_xfer[XFER_BBB_SCLEAR]);
d1123 9
a1175 1
		}
d1177 1
a1177 1
		else if (sc->transfer_datalen - sc->transfer_actlen
a1185 2

		}
d1187 1
a1187 1
		else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d1215 2
a1216 2
		umass_clear_endpoint_stall(sc,
			sc->bulkin, sc->bulkin_pipe, TSTATE_BBB_RESET2,
d1226 2
a1227 2
		umass_clear_endpoint_stall(sc,
			sc->bulkout, sc->bulkout_pipe, TSTATE_BBB_RESET3,
d1261 10
a1270 13
	usbd_device_handle dev;

	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_adsc\n",sc->proto));

	usbd_interface2device_handle(sc->iface, &dev);

	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->request.bRequest = UR_CBI_ADSC;
	USETW(sc->request.wValue, 0);
	USETW(sc->request.wIndex, sc->ifaceno);
	USETW(sc->request.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,
d1281 3
a1283 2
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_reset\n",sc->proto));
d1329 2
a1330 2
		void *cmd, int cmdlen, void *data, int datalen, int dir,
		transfer_cb_f cb, void *priv)
d1335 3
a1337 3
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_transfer\n",
		sc->proto));
d1342 3
d1392 3
a1394 2
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_state\n", sc->proto));
d1417 4
a1420 4
                         * The control pipe has already been unstalled by the
                         * USB stack.
                         * Section 2.4.3.1.1 states that the bulk in endpoints
                         * should not stalled at this point.
d1439 1
a1439 1
			if (umass_setup_transfer(sc, sc->bulkin_pipe,
d1448 1
a1448 1
			if (umass_setup_transfer(sc, sc->bulkout_pipe,
d1454 1
a1454 1
		} else if (sc->proto & PROTO_CBI_I) {
d1458 1
a1458 1
			if (umass_setup_transfer(sc, sc->intrin_pipe,
d1484 1
a1484 1
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %db failed, "
d1490 2
a1491 3
				umass_clear_endpoint_stall(sc,
					sc->bulkin, sc->bulkin_pipe,
					TSTATE_CBI_DCLEAR,
d1507 1
a1507 1
		if (sc->proto & PROTO_CBI_I) {
d1510 1
a1510 1
			if (umass_setup_transfer(sc, sc->intrin_pipe,
d1535 2
a1536 3
				umass_clear_endpoint_stall(sc,
					sc->intrin, sc->intrin_pipe,
					TSTATE_CBI_SCLEAR,
d1546 1
a1546 1
		if (sc->proto & PROTO_UFI) {
d1622 2
a1623 2
		umass_clear_endpoint_stall(sc,
			sc->bulkin, sc->bulkin_pipe, TSTATE_CBI_RESET2,
d1633 2
a1634 2
		umass_clear_endpoint_stall(sc,
			sc->bulkout, sc->bulkout_pipe, TSTATE_CBI_RESET3,
a1663 1
	usbd_device_handle dev;
a1665 1
	usb_interface_descriptor_t *id;
a1670 3
	usbd_interface2device_handle(sc->iface, &dev);
	id = usbd_get_interface_descriptor(sc->iface);

d1675 1
a1675 1
	USETW(req.wIndex, id->bInterfaceNumber);
d1678 1
a1678 1
	err = usbd_do_request(dev, &req, maxlun);
a1714 700
#if defined(__FreeBSD__)
/*
 * CAM specific functions (used by SCSI, UFI, 8070)
 */

Static int
umass_cam_attach_sim()
{
	struct cam_devq *devq;		/* Per device Queue */

	/* A HBA is attached to the CAM layer.
	 *
	 * The CAM layer will then after a while start probing for
	 * devices on the bus. The number of devices is limitted to one.
	 */

	/* SCSI transparent command set */

	devq = cam_simq_alloc(1 /*maximum openings*/);
	if (devq == NULL)
		return(ENOMEM);

	umass_sim = cam_sim_alloc(umass_cam_action, umass_cam_poll, DEVNAME,
				NULL /*priv*/, 0 /*unit number*/,
				1 /*maximum device openings*/,
				0 /*maximum tagged device openings*/,
				devq);
	if (umass_sim == NULL) {
		cam_simq_free(devq);
		return(ENOMEM);
	}

	if(xpt_bus_register(umass_sim, 0) != CAM_SUCCESS)
		return(ENOMEM);

	if (xpt_create_path(&umass_path, NULL, cam_sim_path(umass_sim),
			    UMASS_SCSIID_HOST, 0)
	    != CAM_REQ_CMP)
		return(ENOMEM);

	return(0);
}

#ifdef UMASS_DO_CAM_RESCAN
/* this function is only used from umass_cam_rescan, so mention
 * prototype down here.
 */
Static void umass_cam_rescan_callback(struct cam_periph *periph,union ccb *ccb);

Static void
umass_cam_rescan_callback(struct cam_periph *periph, union ccb *ccb)
{
#ifdef UMASS_DEBUG
	struct umass_softc *sc = devclass_get_softc(umass_devclass,
					       ccb->ccb_h.target_id);

	if (ccb->ccb_h.status != CAM_REQ_CMP) {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: Rescan failed, 0x%04x\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.status));
	} else {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: Rescan succeeded, freeing resources.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
	}
#endif

	xpt_free_path(ccb->ccb_h.path);
	free(ccb, M_USBDEV);
}

Static void
umass_cam_rescan(struct umass_softc *sc)
{
	struct cam_path *path;
	union ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);

	memset(ccb, 0, sizeof(union ccb));

	DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: scanning bus for new device %d\n",
		USBDEVNAME(sc->sc_dev),	 cam_sim_path(umass_sim),
		device_get_unit(sc->sc_dev), 0,
		device_get_unit(sc->sc_dev)));

	if (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),
		    device_get_unit(sc->sc_dev), 0)
	    != CAM_REQ_CMP)
		return;

	xpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);
	ccb->ccb_h.func_code = XPT_SCAN_BUS;
	ccb->ccb_h.cbfcnp = umass_cam_rescan_callback;
	ccb->crcn.flags = CAM_FLAG_NONE;
	xpt_action(ccb);

	/* The scan is in progress now. */
}
#endif

Static int
umass_cam_attach(struct umass_softc *sc)
{
	/* SIM already attached at module load. The device is a target on the
	 * one SIM we registered: target device_get_unit(self).
	 */

	/* The artificial limit UMASS_SCSIID_MAX is there because CAM expects
	 * a limit to the number of targets that are present on a SIM.
	 */
	if (device_get_unit(sc->sc_dev) > UMASS_SCSIID_MAX) {
		printf("%s: Increase UMASS_SCSIID_MAX (currently %d) in %s "
			"and try again.\n", USBDEVNAME(sc->sc_dev),
			UMASS_SCSIID_MAX, __FILE__);
		return(1);
	}

#ifdef UMASS_DO_CAM_RESCAN
	if (!cold) {
		/* Notify CAM of the new device. Any failure is benign, as the
		 * user can still do it by hand (camcontrol rescan <busno>).
		 * Only do this if we are not booting, because CAM does a scan
		 * after booting has completed, when interrupts have been
		 * enabled.
		 */
		umass_cam_rescan(sc);
	}
#endif

	return(0);	/* always succesful */
}

/* umass_cam_detach
 *	detach from the CAM layer
 */

Static int
umass_cam_detach_sim()
{
	if (umass_sim)
		return(EBUSY);	/* XXX CAM can't handle disappearing SIMs yet */

	if (umass_path) {
		/* XXX do we need to send an asynchroneous event for the SIM?
		xpt_async(AC_LOST_DEVICE, umass_path, NULL);
		 */
		xpt_free_path(umass_path);
		umass_path = NULL;
	}

	if (umass_sim) {
		if (xpt_bus_deregister(cam_sim_path(umass_sim)))
			cam_sim_free(umass_sim, /*free_devq*/TRUE);
		else
			return(EBUSY);

		umass_sim = NULL;
	}

	return(0);
}

Static int
umass_cam_detach(struct umass_softc *sc)
{
	struct cam_path *path;

	/* detach of sim not done until module unload */
	DPRINTF(UDMASS_SCSI, ("%s: losing CAM device entry\n",
		USBDEVNAME(sc->sc_dev)));

	if (xpt_create_path(&path, NULL, cam_sim_path(umass_sim),
		    device_get_unit(sc->sc_dev), CAM_LUN_WILDCARD)
	    != CAM_REQ_CMP)
		return(ENOMEM);
	xpt_async(AC_LOST_DEVICE, path, NULL);
	xpt_free_path(path);

	return(0);
}



/* umass_cam_action
 *	CAM requests for action come through here
 */

Static void
umass_cam_action(struct cam_sim *sim, union ccb *ccb)
{
	struct umass_softc *sc = devclass_get_softc(umass_devclass,
					       ccb->ccb_h.target_id);

	/* The softc is still there, but marked as going away. umass_cam_detach
	 * has not yet notified CAM of the lost device however.
	 */
	if (sc && sc->sc_dying) {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
			"Invalid target (gone)\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.func_code));
		ccb->ccb_h.status = CAM_TID_INVALID;
		xpt_done(ccb);
		return;
	}

	/* Verify, depending on the operation to perform, that we either got a
	 * valid sc, because an existing target was referenced, or otherwise
	 * the SIM is addressed.
	 *
	 * This avoids bombing out at a printf and does give the CAM layer some
	 * sensible feedback on errors.
	 */
	switch (ccb->ccb_h.func_code) {
	case XPT_SCSI_IO:
	case XPT_RESET_DEV:
	case XPT_GET_TRAN_SETTINGS:
	case XPT_SET_TRAN_SETTINGS:
	case XPT_CALC_GEOMETRY:
		/* the opcodes requiring a target. These should never occur. */
		if (sc == NULL) {
			printf("%s:%d:%d:%d:func_code 0x%04x: "
				"Invalid target\n",
				DEVNAME_SIM, UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				ccb->ccb_h.func_code);

			ccb->ccb_h.status = CAM_TID_INVALID;
			xpt_done(ccb);
			return;
		}
		break;
	case XPT_PATH_INQ:
	case XPT_NOOP:
		/* The opcodes sometimes aimed at a target (sc is valid),
		 * sometimes aimed at the SIM (sc is invalid and target is
		 * CAM_TARGET_WILDCARD)
		 */
		if (sc == NULL && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
				"Invalid target\n",
				DEVNAME_SIM, UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				ccb->ccb_h.func_code));

			ccb->ccb_h.status = CAM_TID_INVALID;
			xpt_done(ccb);
			return;
		}
		break;
	default:
		/* XXX Hm, we should check the input parameters */
	}

	/* Perform the requested action */
	switch (ccb->ccb_h.func_code) {
	case XPT_SCSI_IO:
	{
		struct ccb_scsiio *csio = &ccb->csio;	/* deref union */
		int dir;
		unsigned char *cmd;
		int cmdlen;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
			"cmd: 0x%02x, flags: 0x%02x, "
			"%db cmd/%db data/%db sense\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			csio->cdb_io.cdb_bytes[0],
			ccb->ccb_h.flags & CAM_DIR_MASK,
			csio->cdb_len, csio->dxfer_len,
			csio->sense_len));

		/* clear the end of the buffer to make sure we don't send out
		 * garbage.
		 */
		DIF(UDMASS_SCSI, if ((ccb->ccb_h.flags & CAM_DIR_MASK)
				     == CAM_DIR_OUT)
					umass_dump_buffer(sc, csio->data_ptr,
						csio->dxfer_len, 48));

		if (sc->transfer_state != TSTATE_IDLE) {
			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
				"I/O requested while busy (state %d, %s)\n",
				USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				sc->transfer_state,states[sc->transfer_state]));
			ccb->ccb_h.status = CAM_SCSI_BUSY;
			xpt_done(ccb);
			return;
		}

		switch(ccb->ccb_h.flags&CAM_DIR_MASK) {
		case CAM_DIR_IN:
			dir = DIR_IN;
			break;
		case CAM_DIR_OUT:
			dir = DIR_OUT;
			break;
		default:
			dir = DIR_NONE;
		}

		ccb->ccb_h.status = CAM_REQ_INPROG | CAM_SIM_QUEUED;
		if (sc->transform(sc, csio->cdb_io.cdb_bytes, csio->cdb_len,
				  &cmd, &cmdlen)) {
			sc->transfer(sc, ccb->ccb_h.target_lun, cmd, cmdlen,
				     csio->data_ptr,
				     csio->dxfer_len, dir,
				     umass_cam_cb, (void *) ccb);
		} else {
			ccb->ccb_h.status = CAM_REQ_INVALID;
			xpt_done(ccb);
		}

		break;
	}
	case XPT_PATH_INQ:
	{
		struct ccb_pathinq *cpi = &ccb->cpi;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_PATH_INQ:.\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		/* host specific information */
		cpi->version_num = 1;
		cpi->hba_inquiry = 0;
		cpi->target_sprt = 0;
		cpi->hba_misc = 0;
		cpi->hba_eng_cnt = 0;
		cpi->max_target = UMASS_SCSIID_MAX;	/* one target */
		cpi->max_lun = 0;	/* no LUN's supported */
		cpi->initiator_id = UMASS_SCSIID_HOST;
		strncpy(cpi->sim_vid, "FreeBSD", SIM_IDLEN);
		strncpy(cpi->hba_vid, "USB SCSI", HBA_IDLEN);
		strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);
		cpi->unit_number = cam_sim_unit(sim);
		cpi->bus_id = UMASS_SCSI_BUS;
		if (sc) {
			cpi->base_transfer_speed = sc->transfer_speed;
			cpi->max_lun = sc->maxlun;
		}

		cpi->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	case XPT_RESET_DEV:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_RESET_DEV:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_REQ_INPROG;
		umass_reset(sc, umass_cam_cb, (void *) ccb);
		break;
	}
	case XPT_GET_TRAN_SETTINGS:
	{
		struct ccb_trans_settings *cts = &ccb->cts;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		cts->valid = 0;
		cts->flags = 0;		/* no disconnection, tagging */

		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	case XPT_SET_TRAN_SETTINGS:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
		xpt_done(ccb);
		break;
	}
	case XPT_CALC_GEOMETRY:
	{
		struct ccb_calc_geometry *ccg = &ccb->ccg;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_CALC_GEOMETRY: "
			"Volume size = %d\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccg->volume_size));

		/* XXX We should probably ask the drive for the details
		 *     instead of cluching them up ourselves
		 */
		if (sc->drive == ZIP_100) {
			ccg->heads = 64;
			ccg->secs_per_track = 32;
			ccg->cylinders = ccg->volume_size / ccg->heads
					  / ccg->secs_per_track;
			ccb->ccb_h.status = CAM_REQ_CMP;
			break;
		} else if (sc->proto & PROTO_UFI) {
			ccg->heads = 2;
			if (ccg->volume_size == 2880)
				ccg->secs_per_track = 18;
			else
				ccg->secs_per_track = 9;
			ccg->cylinders = 80;
			break;
		} else {
			ccb->ccb_h.status = CAM_REQ_CMP_ERR;
		}

		xpt_done(ccb);
		break;
	}
	case XPT_NOOP:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_NOOP:.\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	default:
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
			"Not implemented\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.func_code));

		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
		xpt_done(ccb);
		break;
	}
}

/* umass_cam_poll
 *	all requests are handled through umass_cam_action, requests
 *	are never pending. So, nothing to do here.
 */
Static void
umass_cam_poll(struct cam_sim *sim)
{
#ifdef UMASS_DEBUG
	struct umass_softc *sc = (struct umass_softc *) sim->softc;

	DPRINTF(UDMASS_SCSI, ("%s: CAM poll\n",
		USBDEVNAME(sc->sc_dev)));
#endif

	/* nop */
}


/* umass_cam_cb
 *	finalise a completed CAM command
 */

Static void
umass_cam_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	union ccb *ccb = (union ccb *) priv;
	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */

	csio->resid = residue;

	switch (status) {
	case STATUS_CMD_OK:
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;

	case STATUS_CMD_UNKNOWN:
	case STATUS_CMD_FAILED:
		switch (ccb->ccb_h.func_code) {
		case XPT_SCSI_IO:
		{
			unsigned char *cmd;
			int cmdlen;

			/* fetch sense data */
			DPRINTF(UDMASS_SCSI,("%s: Fetching %db sense data\n",
			        USBDEVNAME(sc->sc_dev),
			        sc->cam_scsi_sense.length));

			sc->cam_scsi_sense.length = csio->sense_len;

			if (sc->transform(sc, (char *) &sc->cam_scsi_sense,
				      sizeof(sc->cam_scsi_sense),
				      &cmd, &cmdlen)) {
				sc->transfer(sc, ccb->ccb_h.target_lun,
					     cmd, cmdlen,
					     &csio->sense_data,
					     csio->sense_len, DIR_IN,
					     umass_cam_sense_cb, (void *) ccb);
			} else {
#ifdef UMASS_DEBUG
				panic("transform(REQUEST_SENSE) failed");
#else
				csio->resid = sc->transfer_datalen;
				ccb->ccb_h.status = CAM_REQ_CMP_ERR;
				xpt_done(ccb);
#endif
			}
			break;
		}
		case XPT_RESET_DEV: /* Reset failed */
			ccb->ccb_h.status = CAM_REQ_CMP_ERR;
			xpt_done(ccb);
			break;
		default:
			panic("umass_cam_cb called for func_code %d",
			      ccb->ccb_h.func_code);
		}
		break;

	case STATUS_WIRE_FAILED:
		/* the wire protocol failed and will have recovered
		 * (hopefully).	 We return an error to CAM and let CAM retry
		 * the command if necessary.
		 */
		ccb->ccb_h.status = CAM_REQ_CMP_ERR;
		xpt_done(ccb);
		break;

	default:
		panic("%s: Unknown status %d in umass_cam_cb",
			USBDEVNAME(sc->sc_dev), status);
	}
}

/* Finalise a completed autosense operation
 */
Static void
umass_cam_sense_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	union ccb *ccb = (union ccb *) priv;
	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */

	switch (status) {
	case STATUS_CMD_OK:
	case STATUS_CMD_UNKNOWN:
		/* Getting sense data succeeded. The length of the sense data
		 * is not returned in any way. The sense data itself contains
		 * the length of the sense data that is valid.
		 */
		if (sc->quirks & RS_NO_CLEAR_UA
		    && csio->cdb_io.cdb_bytes[0] == INQUIRY
		    && (csio->sense_data.flags & SSD_KEY)
						== SSD_KEY_UNIT_ATTENTION) {
			/* Ignore unit attention errors in the case where
			 * the Unit Attention state is not cleared on
			 * REQUEST SENSE. They will appear again at the next
			 * command.
			 */
			ccb->ccb_h.status = CAM_REQ_CMP;
		} else if ((csio->sense_data.flags & SSD_KEY)
						== SSD_KEY_NO_SENSE) {
			/* No problem after all (in the case of CBI without
			 * CCI)
			 */
			ccb->ccb_h.status = CAM_REQ_CMP;
		} else {
			ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR
					    | CAM_AUTOSNS_VALID;
			csio->scsi_status = SCSI_STATUS_CHECK_COND;
		}
		xpt_done(ccb);
		break;

	default:
		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
			USBDEVNAME(sc->sc_dev), status));
		ccb->ccb_h.status = CAM_AUTOSENSE_FAIL;
		xpt_done(ccb);
	}
}


Static int
umass_driver_load(module_t mod, int what, void *arg)
{
	int err;

	switch (what) {
	case MOD_UNLOAD:
		err = umass_cam_detach_sim();
		if (err)
			return(err);
		return(usbd_driver_load(mod, what, arg));
	case MOD_LOAD:
		/* We don't attach to CAM at this point, because it will try
		 * and malloc memory for it. This is not possible when the
		 * boot loader loads umass as a module before the kernel
		 * has been bootstrapped.
		 */
	default:
		return(usbd_driver_load(mod, what, arg));
	}
}



/* (even the comment is missing) */

DRIVER_MODULE(umass, uhub, umass_driver, umass_devclass, umass_driver_load, 0);


/*
 * SCSI specific functions
 */

Static int
umass_scsi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		     unsigned char **rcmd, int *rcmdlen)
{
	*rcmd = cmd;		/* trivial copy */
	*rcmdlen = cmdlen;

	switch (cmd[0]) {
	case TEST_UNIT_READY:
		if (sc->quirks & NO_TEST_UNIT_READY) {
			DPRINTF(UDMASS_SCSI, ("%s: Converted TEST_UNIT_READY "
				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
			cmd[0] = START_STOP_UNIT;
			cmd[4] = SSS_START;
		}
		break;
	}

	return 1;		/* success */
}

/*
 * UFI specific functions
 */

Static int
umass_ufi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		    unsigned char **rcmd, int *rcmdlen)
{
	*rcmd = cmd;
	/* A UFI command is always 12 bytes in length */
	/* XXX cmd[(cmdlen+1)..12] contains garbage */
	*rcmdlen = 12;

	switch (cmd[0]) {
	case TEST_UNIT_READY:
		if (sc->quirks & NO_TEST_UNIT_READY) {
			DPRINTF(UDMASS_UFI, ("%s: Converted TEST_UNIT_READY "
				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
			cmd[0] = START_STOP_UNIT;
			cmd[4] = SSS_START;
		}
		return 1;
	case INQUIRY:
	case START_STOP_UNIT:
	case MODE_SENSE:
	case PREVENT_ALLOW:
	case READ_10:
	case READ_12:
	case READ_CAPACITY:
	case REQUEST_SENSE:
	case REZERO_UNIT:
	case POSITION_TO_ELEMENT:	/* SEEK_10 */
	case SEND_DIAGNOSTIC:
	case WRITE_10:
	case WRITE_12:
	/* FORMAT_UNIT */
	/* MODE_SELECT */
	/* READ_FORMAT_CAPACITY */
	/* VERIFY */
	/* WRITE_AND_VERIFY */
		return 1;	/* success */
	default:
		return 0;	/* success */
	}
}

/*
 * 8070 specific functions
 */
Static int
umass_8070_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		     unsigned char **rcmd, int *rcmdlen)
{
	return 0;	/* failure */
}

#endif /* __FreeBSD__ */

d1726 2
a1727 2
	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmd = %db "
		"(0x%02x%02x%02x%02x%02x%02x%s), "
d1730 3
a1732 1
		c[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? "...":""),
a1780 479
#endif








#if defined(__NetBSD__) || defined(__OpenBSD__)
Static int
umass_scsipi_cmd(xs)
	struct scsipi_xfer *xs;
{
	struct scsipi_link *sc_link = xs->sc_link;
	struct umass_softc *sc = sc_link->adapter_softc;
	struct scsipi_generic *cmd, trcmd;
	int cmdlen;
	int dir;
#ifdef UMASS_DEBUG
	microtime(&sc->tv);
#endif

	memset(&trcmd, 0, sizeof(trcmd));

#if defined(__NetBSD__)
	DIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);
#endif
#if defined(__OpenBSD__)
	DIF(UDMASS_UPPER, sc_link->flags |= SCSIDEBUG_LEVEL);
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
	DPRINTF(UDMASS_CMD, ("%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x "
	    "(quirks=0x%x, poll=%d)\n", USBDEVNAME(sc->sc_dev),
	    SCSI_LINK_TARGET(sc_link), SCSI_LINK_LUN(sc_link),
	    xs, xs->cmd->opcode, sc_link->quirks,
	    xs->xs_control & XS_CTL_POLL));
#endif

#if defined(USB_DEBUG) && defined(SCSIDEBUG)
	if (umassdebug & UDMASS_SCSI)
		show_scsipi_xs(xs);
	else if (umassdebug & ~UDMASS_CMD)
		show_scsipi_cmd(xs);
#endif

	if (sc->sc_dying) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

#ifdef UMASS_DEBUG
#if defined(__NetBSD__)
	if ((sc_link->type == BUS_ATAPI ?
	     sc_link->scsipi_atapi.drive : SCSI_LINK_TARGET(sc_link))
	    != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: wrong SCSI ID %d\n",
		    USBDEVNAME(sc->sc_dev),
		    SCSI_LINK_TARGET(sc_link)));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif
#if defined(__OpenBSD__)
	if (sc_link->target != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: wrong SCSI ID %d\n",
		    USBDEVNAME(sc->sc_dev),
		    sc_link->target));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif
#endif

	cmd = xs->cmd;

	if (xs->cmd->opcode == MODE_SENSE &&
	    (sc_link->quirks & SDEV_NOMODESENSE)) {
		/*printf("%s: MODE_SENSE\n", USBDEVNAME(sc->sc_dev));*/
		xs->error = XS_TIMEOUT;
		goto done;
	}

	if (xs->cmd->opcode == START_STOP &&
	    (sc->quirks & NO_START_STOP)) {
		/*printf("%s: START_STOP\n", USBDEVNAME(sc->sc_dev));*/
		xs->error = XS_NOERROR;
		goto done;
	}

	if (xs->cmd->opcode == INQUIRY &&
	    (sc->quirks & FORCE_SHORT_INQUIRY)) {
       		memcpy(&trcmd, cmd, sizeof trcmd);
		trcmd.bytes[4] = SHORT_INQUIRY_LENGTH;
		cmd = &trcmd;
	}

	dir = DIR_NONE;
	if (xs->datalen) {
		switch (xs->xs_control & (XS_CTL_DATA_IN | XS_CTL_DATA_OUT)) {
		case XS_CTL_DATA_IN:
			dir = DIR_IN;
			break;
		case XS_CTL_DATA_OUT:
			dir = DIR_OUT;
			break;
		}
	}

	if (xs->datalen > UMASS_MAX_TRANSFER_SIZE) {
		printf("umass_cmd: large datalen, %d\n", xs->datalen);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	cmdlen = xs->cmdlen;
	if (sc->proto & PROTO_UFI) {
		if (!umass_ufi_transform(sc, cmd, cmdlen, &trcmd, &cmdlen)) {
			xs->error = XS_DRIVER_STUFFUP;
			goto done;
		}
		cmd= &trcmd;
	}

	if (sc->proto & PROTO_ATAPI) {
		bcopy(cmd, &trcmd, cmdlen);
		cmd = &trcmd;
		cmdlen = ATAPI_COMMAND_LENGTH;
	}

	if (xs->xs_control & XS_CTL_POLL) {
		/* Use sync transfer. XXX Broken! */
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: sync dir=%d\n", dir));
		sc->sc_xfer_flags = USBD_SYNCHRONOUS;
		sc->sc_sync_status = USBD_INVAL;
		sc->transfer(sc, SCSI_LINK_LUN(sc_link), cmd, cmdlen,
			     xs->data, xs->datalen, dir, 0, xs);
		sc->sc_xfer_flags = 0;
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n",
				      sc->sc_sync_status));
		switch (sc->sc_sync_status) {
		case USBD_NORMAL_COMPLETION:
			xs->error = XS_NOERROR;
			break;
		case USBD_TIMEOUT:
			xs->error = XS_TIMEOUT;
			break;
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		goto done;
	} else {
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: async dir=%d, cmdlen=%d"
				      " datalen=%d\n",
				      dir, cmdlen, xs->datalen));
		sc->transfer(sc, SCSI_LINK_LUN(sc_link), cmd, cmdlen,
		    xs->data, xs->datalen, dir, umass_scsipi_cb, xs);
		return (SUCCESSFULLY_QUEUED);
	}

	/* Return if command finishes early. */
 done:
#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif

	scsipi_done(xs);
	if (xs->xs_control & XS_CTL_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
}

Static void
umass_scsipi_minphys(bp)
	struct buf *bp;
{
	if (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)
		bp->b_bcount = UMASS_MAX_TRANSFER_SIZE;
	minphys(bp);
}

int
umass_scsipi_ioctl(link, cmd, arg, flag, p)
	struct scsipi_link *link;
	u_long cmd;
	caddr_t arg;
	int flag;
	struct proc *p;
{
	/*struct umass_softc *sc = link->adapter_softc;*/

	switch (cmd) {
#if 0
	case SCBUSIORESET:
		ccb->ccb_h.status = CAM_REQ_INPROG;
		umass_reset(sc, umass_cam_cb, (void *) ccb);
		return (0);
#endif
	default:
		return (ENOTTY);
	}
}

Static void
umass_scsipi_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	struct scsipi_xfer *xs = priv;
	struct scsipi_link *sc_link = xs->sc_link;
	int cmdlen;
	int s;
#ifdef UMASS_DEBUG
	struct timeval tv;
	u_int delta;
	microtime(&tv);
	delta = (tv.tv_sec - sc->tv.tv_sec) * 1000000 + tv.tv_usec - sc->tv.tv_usec;
#endif

	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: at %lu.%06lu, delta=%u: xs=%p residue=%d"
	    " status=%d\n", tv.tv_sec, tv.tv_usec, delta, xs, residue, status));
	xs->resid = residue;

	switch (status) {
	case STATUS_CMD_OK:
		xs->error = XS_NOERROR;
		break;

	case STATUS_CMD_UNKNOWN:
	case STATUS_CMD_FAILED:
		/* fetch sense data */
		memset(&sc->sc_sense_cmd, 0, sizeof(sc->sc_sense_cmd));
		sc->sc_sense_cmd.opcode = REQUEST_SENSE;
		sc->sc_sense_cmd.byte2 = SCSI_LINK_LUN(sc_link) <<
		    SCSI_CMD_LUN_SHIFT;
		sc->sc_sense_cmd.length = sizeof(xs->sense);

		cmdlen = sizeof(sc->sc_sense_cmd);
		if (sc->proto & PROTO_UFI)
			cmdlen = UFI_COMMAND_LENGTH;
		else if (sc->proto & PROTO_ATAPI)
			cmdlen = ATAPI_COMMAND_LENGTH;

		sc->transfer(sc, SCSI_LINK_LUN(sc_link),
			     &sc->sc_sense_cmd, cmdlen,
			     &xs->sense, sizeof(xs->sense), DIR_IN,
			     umass_scsipi_sense_cb, xs);
		return;

	case STATUS_WIRE_FAILED:
		xs->error = XS_RESET;
		break;

	default:
		panic("%s: Unknown status %d in umass_scsipi_cb",
			USBDEVNAME(sc->sc_dev), status);
	}

#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif

	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: at %lu.%06lu: return xs->error="
            "%d, xs->xs_status=0x%x xs->resid=%d\n",
	     tv.tv_sec, tv.tv_usec,
	     xs->error, xs->xs_status, xs->resid));

	s = splbio();
	scsipi_done(xs);
	splx(s);
}

/*
 * Finalise a completed autosense operation
 */
Static void
umass_scsipi_sense_cb(struct umass_softc *sc, void *priv, int residue,
		      int status)
{
	struct scsipi_xfer *xs = priv;
	int s;
	int bytes_received;

	DPRINTF(UDMASS_CMD,("umass_scsipi_sense_cb: xs=%p residue=%d "
	    "status=%d\n", xs, residue, status));

	switch (status) {
	case STATUS_CMD_OK:
	case STATUS_CMD_UNKNOWN:
		/* getting sense data succeeded */
		if ((xs->cmd->opcode == INQUIRY)
		    && (xs->resid < xs->datalen)) {
			/* Some drivers return SENSE errors even after INQUIRY
			 * The upper layer doesn't like that.
			 */
			xs->error = XS_NOERROR;
			break;
		}

		bytes_received = sizeof(xs->sense) - residue;

		if (bytes_received < 8 ||
		    (bytes_received < xs->sense.extra_len + 8))
			xs->error = XS_SHORTSENSE;
	        else
			xs->error = XS_SENSE;

#if defined(__OpenBSD__)
		/* Note that this test may need to be revised
		   with QIC-157a/SCSI tape drives that return
		   ILI, EOM in the high bits of flags.
	         */
		if ((xs->sense.error_code & SSD_ERRCODE) == 0x70 &&
		    (xs->sense.flags == 0))
			xs->error = XS_NOERROR;
#endif

		break;
	default:
		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
			USBDEVNAME(sc->sc_dev), status));
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif

	DPRINTF(UDMASS_CMD,("umass_scsipi_sense_cb: return xs->error=%d, "
		"xs->xs_status=0x%x xs->resid=%d\n", xs->error, xs->xs_status,
		xs->resid));

	s = splbio();
	scsipi_done(xs);
	splx(s);
}

/*
 * UFI specific functions
 */

Static int
umass_ufi_transform(struct umass_softc *sc, struct scsipi_generic *cmd,
		    int cmdlen, struct scsipi_generic *rcmd, int *rcmdlen)
{
	*rcmdlen = UFI_COMMAND_LENGTH;
	memset(rcmd, 0, sizeof *rcmd);

	/* Handle any quirks */
	if (cmd->opcode == TEST_UNIT_READY
	    && (sc->quirks & NO_TEST_UNIT_READY)) {
		/*
		 * Some devices do not support this command.
		 * Start Stop Unit should give the same results
		 */
		DPRINTF(UDMASS_UFI, ("%s: Converted TEST_UNIT_READY "
			"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
		rcmd->opcode = START_STOP;
		rcmd->bytes[3] = SSS_START;
		return 1;
	}

	switch (cmd->opcode) {
	/* Commands of which the format has been verified. They should work. */
	case TEST_UNIT_READY:
	case REZERO_UNIT:
	case REQUEST_SENSE:
	case INQUIRY:
	case START_STOP:
	/*case SEND_DIAGNOSTIC: ??*/
	case PREVENT_ALLOW:
	case READ_CAPACITY:
	case READ_BIG:
	case WRITE_BIG:
	case POSITION_TO_ELEMENT:	/* SEEK_10 */
	case MODE_SELECT_BIG:
	case MODE_SENSE_BIG:
	default:
		/* Copy the command into the (zeroed out) destination buffer */
		memcpy(rcmd, cmd, cmdlen);
		return (1);	/* success */

	/*
	 * Other UFI commands: FORMAT_UNIT, MODE_SELECT, READ_FORMAT_CAPACITY,
	 * VERIFY, WRITE_AND_VERIFY.
	 * These should be checked whether they somehow can be made to fit.
	 */

	/* These commands are known _not_ to work. They should be converted. */
	case READ_COMMAND:
	case WRITE_COMMAND:
	case MODE_SENSE:
	case MODE_SELECT:
		printf("%s: Unsupported UFI command 0x%02x",
			USBDEVNAME(sc->sc_dev), cmd->opcode);
		if (cmdlen == 6)
			printf(", 6 byte command should have been converted");
		printf("\n");
		return (0);	/* failure */
	}
}


#if NATAPIBUS > 0
Static void
umass_atapi_probedev(atapi, target)
	struct atapibus_softc *atapi;
	int target;
{
	struct scsipi_link *sc_link;
	struct scsipibus_attach_args sa;
	struct ata_drive_datas *drvp = &atapi->sc_drvs[target];
	char vendor[33], product[65], revision[17];
	struct scsipi_inquiry_data inqbuf;

	DPRINTF(UDMASS_SCSI,("umass_atapi_probedev: atapi=%p target=%d\n",
			     atapi, target));

	if (atapi->sc_link[target])
		return;

	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT);
	if (sc_link == NULL) {
		printf("%s: can't allocate link for drive %d\n",
		       atapi->sc_dev.dv_xname, target);
		return;
	}
	*sc_link = *atapi->adapter_link;

	DIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);

	/* Fill generic parts of the link. */
	sc_link->active = 0;
	sc_link->scsipi_atapi.drive = target;
	sc_link->device = &umass_dev;
	TAILQ_INIT(&sc_link->pending_xfers);

	DPRINTF(UDMASS_SCSI, ("umass_atapi_probedev: doing inquiry\n"));
	/* Now go ask the device all about itself. */
	memset(&inqbuf, 0, sizeof(inqbuf));
	if (scsipi_inquire(sc_link, &inqbuf, XS_CTL_DISCOVERY) != 0)
		goto bad;

	scsipi_strvis(vendor, 33, inqbuf.vendor, 8);
	scsipi_strvis(product, 65, inqbuf.product, 16);
	scsipi_strvis(revision, 17, inqbuf.revision, 4);

	sa.sa_sc_link = sc_link;
	sa.sa_inqbuf.type = inqbuf.device;
	sa.sa_inqbuf.removable = inqbuf.dev_qual2 & SID_REMOVABLE ?
	    T_REMOV : T_FIXED;
	if (sa.sa_inqbuf.removable)
		sc_link->flags |= SDEV_REMOVABLE;
	/* XXX how? sc_link->scsipi_atapi.cap |= ACAP_LEN;*/
	sa.sa_inqbuf.vendor = vendor;
	sa.sa_inqbuf.product = product;
	sa.sa_inqbuf.revision = revision;
	sa.sa_inqptr = NULL;

	drvp->drv_softc = atapi_probedev(atapi, target, sc_link, &sa);
	/* atapi_probedev() frees the scsipi_link when there is no device. */
	return;

bad:
	free(sc_link, M_DEVBUF);
	return;
}
#endif
@


1.22
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.21 2003/01/05 22:41:36 deraadt Exp $ */
d893 1
a893 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.21
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.20 2002/12/15 20:53:32 krw Exp $ */
d867 1
a867 1
	strcpy(sc->sc_dev.dv_xname, "umass");
d3106 1
a3106 1
	sprintf(s2, " buffer=%p, buflen=%d", buffer, buflen);
d3114 1
a3114 1
		sprintf(&s1[j*2], "%02x", buffer[i] & 0xff);
d3117 1
a3117 1
		sprintf(s3, " ...");
@


1.20
log
@Fix/Cleanup some SCSI #defines.

1) Correctly define MODE_SENSE_BIG as 0x5a, not 0x54.
2) Delete duplicate #define's of some opcodes in scsi_disk.h.
3) Delete multiple #define's for same opcode in scsi_disk.h.
4) Replace uses of deleted opcodes in umass.c with remaining ones.

ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.19 2002/10/12 01:09:44 krw Exp $ */
d1697 1
a1697 1
		/* FALLTHROUGH, err == 0 (no data phase or successfull) */
d1703 1
a1703 1
		 * In the case of no data phase or successfull data phase,
d1720 1
a1720 1
			/* After no data phase, successfull data phase and
d2201 1
a2201 1
			/* No sense, command successfull */
@


1.19
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.18 2002/07/25 02:18:10 nate Exp $ */
d3198 1
a3198 1
	if (xs->cmd->opcode == SCSI_MODE_SENSE &&
d3200 1
a3200 1
		/*printf("%s: SCSI_MODE_SENSE\n", USBDEVNAME(sc->sc_dev));*/
d3497 1
a3497 1
	case SCSI_REZERO_UNIT:
d3507 2
a3508 2
	case SCSI_MODE_SELECT_BIG:
	case SCSI_MODE_SENSE_BIG:
d3521 4
a3524 4
	case SCSI_READ_COMMAND:
	case SCSI_WRITE_COMMAND:
	case SCSI_MODE_SENSE:
	case SCSI_MODE_SELECT:
@


1.18
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.17 2002/06/21 00:34:34 art Exp $ */
d1119 1
a1119 1
		panic("%s:%d: Unknown proto 0x%02x\n",
d1807 1
a1807 1
			panic("%s: transferred %d bytes instead of %d bytes\n",
d1885 1
a1885 1
		panic("%s: Unknown state %d\n",
d2293 1
a2293 1
		panic("%s: Unknown state %d\n",
d2863 1
a2863 1
				panic("transform(REQUEST_SENSE) failed\n");
d2877 1
a2877 1
			panic("umass_cam_cb called for func_code %d\n",
d2892 1
a2892 1
		panic("%s: Unknown status %d in umass_cam_cb\n",
d3379 1
a3379 1
		panic("%s: Unknown status %d in umass_scsipi_cb\n",
@


1.17
log
@Trial and error gives me this tweak for the trumpion 0x1100 device.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.16 2002/05/07 18:29:18 nate Exp $ */
d240 1
a240 1
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)			      
d314 1
a314 1
				void *cmd, int cmdlen, void *data, int datalen, 
d403 1
a403 1
	
d408 1
a408 1
	umass_cbi_cbl_t		cbl;	/* command block */ 
d430 1
a430 1
	
d449 1
a449 1
	int			transfer_actlen;	/* actual length */ 
d561 1
a561 1
				void *buffer, int buflen, int flags, 
d789 1
a789 1
		/* 
d804 1
a804 1
	
d957 1
a957 1
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sSubclass, 
d1050 1
a1050 1
	/* 
d1097 1
a1097 1
		sc->data_buffer = usbd_alloc_buffer(sc->transfer_xfer[bno], 
d1132 1
a1132 1
	
d1147 1
a1147 1
		sc->u.sc_link.adapter_target = UMASS_SCSIID_HOST; 
d1161 1
a1161 1
		printf("%s: proto=0x%x not supported yet\n", 
d1292 1
a1292 1
{ 
d1461 1
a1461 1
	
d1499 1
a1499 1
	 * machine in umass_bbb_state handle the completion. It uses the 
d1641 1
a1641 1
			memcpy(sc->data_buffer, sc->transfer_data, 
d1715 1
a1715 1
	
d1801 1
a1801 1
				
d1810 1
a1810 1
		} 
d1929 1
a1929 1
	 * 
d1943 1
a1943 1
	
d1989 1
a1989 1
	 * machine in umass_cbi_state handle the completion. It uses the 
d2071 1
a2071 1
		
d2081 1
a2081 1
			memcpy(sc->data_buffer, sc->transfer_data, 
d2185 1
a2185 1
			
d2473 1
a2473 1
		
d2716 1
a2716 1
	} 
d2864 1
a2864 1
#else 
d3157 1
a3157 1
	    xs, xs->cmd->opcode, sc_link->quirks, 
d3175 2
a3176 2
	if ((sc_link->type == BUS_ATAPI ? 
	     sc_link->scsipi_atapi.drive : SCSI_LINK_TARGET(sc_link)) 
d3260 1
a3260 1
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n", 
d3291 1
a3291 1
	
d3343 1
a3343 1
	
d3400 1
a3400 1
/* 
d3429 2
a3430 2
		if (bytes_received < 8 || 
		    (bytes_received < xs->sense.extra_len + 8)) 
d3444 1
a3444 1
		
d3474 1
a3474 1
umass_ufi_transform(struct umass_softc *sc, struct scsipi_generic *cmd, 
d3492 1
a3492 1
	} 
d3514 1
a3514 1
	/* 
d3553 1
a3553 1
	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT); 
d3557 1
a3557 1
		return;       
@


1.16
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.14 2002/03/14 03:16:08 millert Exp $ */
d725 6
@


1.15
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: umass.c,v 1.87 2002/03/17 18:02:53 augustss Exp $	*/
d33 1
a33 1
 * Universal Serial Bus Mass Storage Class specs:
d54 2
a55 2
 * - 8070 (ATA/ATAPI for rewritable removable media)
 * - UFI (USB Floppy Interface)
d57 4
a60 5
 * 8070i is a transformed version of the SCSI command set. UFI is a transformed
 * version of the 8070i command set.  The sc->transform method is used to 
 * convert the commands into the appropriate format (if at all necessary).
 * For example, ATAPI requires all commands to be 12 bytes in length amongst
 * other things.
d96 6
a101 1
#if defined(__NetBSD__)
a102 3
#include "scsibus.h"
#elif defined(__OpenBSD__)
#include "atapiscsi.h"
a104 2
#include "wd.h"

d127 26
a152 4
#include <dev/usb/umassvar.h>
#include <dev/usb/umass_quirks.h>
#include <dev/usb/umass_scsipi.h>
#include <dev/usb/umass_isdata.h>
d154 15
d171 15
d187 328
d516 1
d541 4
d548 4
d559 1
d563 3
a565 2
Static void umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
				usbd_xfer_handle xfer);
d567 2
a568 1
Static void umass_reset(struct umass_softc *sc,	transfer_cb_f cb, void *priv);
d572 10
a581 4
Static void umass_bbb_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
Static void umass_bbb_reset(struct umass_softc *, int);
Static void umass_bbb_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
a582 1
usbd_status umass_bbb_get_max_lun(struct umass_softc *, u_int8_t *);
d585 44
a628 11
Static void umass_cbi_transfer(struct umass_softc *, int, void *, int, void *,  
			       int, int, u_int, umass_callback, void *);
Static void umass_cbi_reset(struct umass_softc *, int);
Static void umass_cbi_state(usbd_xfer_handle, usbd_private_handle, usbd_status);

Static int umass_cbi_adsc(struct umass_softc *, char *, int, usbd_xfer_handle);

const struct umass_wire_methods umass_bbb_methods = {
	umass_bbb_transfer,
	umass_bbb_reset,
	umass_bbb_state
d631 35
a665 5
const struct umass_wire_methods umass_cbi_methods = {
	umass_cbi_transfer,
	umass_cbi_reset,
	umass_cbi_state
};
d678 2
d684 11
a694 1
USB_MATCH(umass)
d696 1
a696 2
	USB_MATCH_START(umass, uaa);
	const struct umass_quirk *quirk;
d698 66
d765 4
a768 2
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
d770 7
a776 3
	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL)
		return (quirk->uq_match);
d778 1
a778 1
	id = usbd_get_interface_descriptor(uaa->iface);
d782 25
a806 2
	switch (id->bInterfaceSubClass) {
	case UISUBCLASS_RBC:
d808 1
d810 4
a813 3
	case UISUBCLASS_UFI:
	case UISUBCLASS_SFF8070I:
	case UISUBCLASS_SCSI:
d816 6
a821 1
		return (UMATCH_IFACECLASS);
d824 4
a827 1
	switch (id->bInterfaceProtocol) {
d829 6
a834 2
	case UIPROTO_MASS_CBI:
	case UIPROTO_MASS_BBB_OLD:
d836 7
d845 3
a847 1
		return (UMATCH_IFACECLASS_IFACESUBCLASS);
d850 18
a867 1
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
d870 2
a874 1
	const struct umass_quirk *quirk;
d877 1
a877 1
	const char *sWire, *sCommand;
d879 7
a885 2
	usbd_status err;
	int i, bno, error;
d890 2
a891 10
	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_ifaceno = uaa->ifaceno;

	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL) {
		sc->sc_wire = quirk->uq_wire;
		sc->sc_cmd = quirk->uq_cmd;
		sc->sc_quirks = quirk->uq_flags;
		sc->sc_busquirks = quirk->uq_busquirks;
d893 3
a895 11
		if (quirk->uq_fixup != NULL)
			(*quirk->uq_fixup)(sc);
	} else {
		sc->sc_wire = UMASS_WPROTO_UNSPEC;
		sc->sc_cmd = UMASS_CPROTO_UNSPEC;
		sc->sc_quirks = 0;
		sc->sc_busquirks = 0;
	}

	id = usbd_get_interface_descriptor(sc->sc_iface);
	if (id == NULL)
a896 20

	if (sc->sc_wire == UMASS_WPROTO_UNSPEC) {
		switch (id->bInterfaceProtocol) {
		case UIPROTO_MASS_CBI:
			sc->sc_wire = UMASS_WPROTO_CBI;
			break;
		case UIPROTO_MASS_CBI_I:
			sc->sc_wire = UMASS_WPROTO_CBI_I;
			break;
		case UIPROTO_MASS_BBB:
		case UIPROTO_MASS_BBB_OLD:
			sc->sc_wire = UMASS_WPROTO_BBB;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported wire protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceProtocol));
			USB_ATTACH_ERROR_RETURN;
		}
d899 8
a906 28
	/* XXX - Now unsupported CBI with CCI */
	if (sc->sc_wire == UMASS_WPROTO_CBI_I)
		sc->sc_wire = UMASS_WPROTO_CBI;

	if (sc->sc_cmd == UMASS_CPROTO_UNSPEC) {
		switch (id->bInterfaceSubClass) {
		case UISUBCLASS_SCSI:
			sc->sc_cmd = UMASS_CPROTO_SCSI;
			break;
		case UISUBCLASS_UFI:
			sc->sc_cmd = UMASS_CPROTO_UFI;
			break;
		case UISUBCLASS_SFF8020I:
		case UISUBCLASS_SFF8070I:
		case UISUBCLASS_QIC157:
			sc->sc_cmd = UMASS_CPROTO_ATAPI;
			break;
		case UISUBCLASS_RBC:
			sc->sc_cmd = UMASS_CPROTO_RBC;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported command protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceSubClass));
			USB_ATTACH_ERROR_RETURN;
		}
	}
d908 1
d911 12
a922 3
	switch (sc->sc_wire) {
	case UMASS_WPROTO_CBI:
		sWire = "CBI";
d924 2
a925 2
	case UMASS_WPROTO_CBI_I:
		sWire = "CBI with CCI";
d927 2
a928 2
	case UMASS_WPROTO_BBB:
		sWire = "Bulk-Only";
d931 1
a931 1
		sWire = "unknown";
d934 3
a936 4

	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
		sCommand = "RBC";
d938 2
a939 2
	case UMASS_CPROTO_SCSI:
		sCommand = "SCSI";
d941 2
a942 5
	case UMASS_CPROTO_UFI:
		sCommand = "UFI";
		break;
	case UMASS_CPROTO_ATAPI:
		sCommand = "ATAPI";
d944 2
a945 2
	case UMASS_CPROTO_ISD_ATA:
		sCommand = "ISD-ATA";
d948 1
a948 1
		sCommand = "unknown";
d951 2
d954 10
a963 2
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sCommand,
	       sWire);
d977 2
a978 2
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
d985 1
a985 1
			sc->sc_epaddr[UMASS_BULKIN] = ed->bEndpointAddress;
d988 2
a989 2
			sc->sc_epaddr[UMASS_BULKOUT] = ed->bEndpointAddress;
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I
d992 1
a992 1
			sc->sc_epaddr[UMASS_INTRIN] = ed->bEndpointAddress;
d1004 6
a1009 7
	if (!sc->sc_epaddr[UMASS_BULKIN] || !sc->sc_epaddr[UMASS_BULKOUT] ||
	    (sc->sc_wire == UMASS_WPROTO_CBI_I &&
	     !sc->sc_epaddr[UMASS_INTRIN])) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %u/%u/%u\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN],
			sc->sc_epaddr[UMASS_BULKOUT],
			sc->sc_epaddr[UMASS_INTRIN]));
d1016 1
a1016 2
	if (sc->sc_wire == UMASS_WPROTO_BBB && 
	    !(sc->sc_quirks & UMASS_QUIRK_NO_MAX_LUN)) {
d1028 2
a1029 3
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKOUT],
				USBD_EXCLUSIVE_USE,
				&sc->sc_pipe[UMASS_BULKOUT]);
d1031 2
a1032 2
		DPRINTF(UDMASS_USB, ("%s: cannot open %u-out pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKOUT]));
d1036 2
a1037 2
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_BULKIN]);
d1039 2
a1040 2
		DPRINTF(UDMASS_USB, ("%s: could not open %u-in pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN]));
d1056 3
a1058 3
	if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_INTRIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_INTRIN]);
d1060 2
a1061 3
			DPRINTF(UDMASS_USB, ("%s: couldn't open %u-in (intr)\n",
				USBDEVNAME(sc->sc_dev),
				sc->sc_epaddr[UMASS_INTRIN]));
d1081 2
a1082 2
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
d1085 1
a1085 1
	case UMASS_WPROTO_CBI:
d1088 1
a1088 1
	case UMASS_WPROTO_CBI_I:
d1103 13
a1115 11
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
		sc->sc_methods = &umass_bbb_methods;
		break;
	case UMASS_WPROTO_CBI:
	case UMASS_WPROTO_CBI_I:
		sc->sc_methods = &umass_cbi_methods;
		break;
	default:
		umass_disco(sc);
		USB_ATTACH_ERROR_RETURN;
d1118 2
a1119 7
	if (quirk != NULL && quirk->uq_init != NULL) {
		err = (*quirk->uq_init)(sc);
		if (err) {
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
		}
	}
d1121 27
a1147 10
	error = 0;
	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
	case UMASS_CPROTO_SCSI:
#if defined(__OpenBSD__) || NSCSIBUS > 0
		error = umass_scsi_attach(sc);
#else
		printf("%s: scsibus not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1149 2
a1150 8
	case UMASS_CPROTO_UFI:
	case UMASS_CPROTO_ATAPI:
#if (NATAPIBUS > 0) || (NATAPISCSI > 0)
		error = umass_atapi_attach(sc);
#else
		printf("%s: "UMASS_ATAPISTR" not configured\n",
		       USBDEVNAME(sc->sc_dev));
#endif
a1152 7
	case UMASS_CPROTO_ISD_ATA:
#if defined (__NetBSD__) && NWD > 0
		error = umass_isdata_attach(sc);
#else
		printf("%s: isdata not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1155 2
a1156 2
		printf("%s: command protocol=0x%x not supported\n",
		       USBDEVNAME(sc->sc_dev), sc->sc_cmd);
d1160 19
a1178 2
	if (error) {
		printf("%s: bus attach failed\n", USBDEVNAME(sc->sc_dev));
d1180 2
a1181 1
		USB_ATTACH_ERROR_RETURN;
d1186 1
d1188 16
a1203 3
	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
d1209 1
a1209 2
	struct umassbus_softc *scbus = sc->bus;
	int rv = 0, i;
d1214 6
a1219 4
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL)
			usbd_abort_pipe(sc->sc_pipe[i]);
	}
d1231 10
a1240 7
	if (scbus != NULL) {
		if (scbus->sc_child != NULL)
			rv = config_detach(scbus->sc_child, flags);
		free(scbus, M_DEVBUF);
		sc->bus = NULL;
	}

d1249 1
a1249 1
	return (rv);
d1252 1
d1254 3
a1256 1
umass_activate(struct device *dev, enum devact act)
d1258 1
a1258 2
	struct umass_softc *sc = (struct umass_softc *)dev;
	struct umassbus_softc *scbus = sc->bus;
d1270 1
a1270 2
		sc->sc_dying = 1;
		if (scbus == NULL || scbus->sc_child == NULL)
d1272 1
a1272 1
		rv = config_deactivate(scbus->sc_child);
d1275 2
d1281 1
d1284 2
a1285 1
umass_disco(struct umass_softc *sc)
d1299 21
a1319 4
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL)
			usbd_close_pipe(sc->sc_pipe[i]);
	}
d1339 1
a1339 1
	    flags | sc->sc_xfer_flags, sc->timeout, sc->sc_methods->wire_state);
d1356 4
a1359 2
umass_setup_ctrl_transfer(struct umass_softc *sc, usb_device_request_t *req,
	 void *buffer, int buflen, int flags, usbd_xfer_handle xfer)
d1368 2
a1369 2
	usbd_setup_default_xfer(xfer, sc->sc_udev, (void *) sc, sc->timeout,
		req, buffer, buflen, flags, sc->sc_methods->wire_state);
d1384 3
a1386 2
umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
	usbd_xfer_handle xfer)
d1388 2
d1394 5
a1398 1
		USBDEVNAME(sc->sc_dev), sc->sc_epaddr[endpt]));
d1400 1
a1400 1
	usbd_clear_endpoint_toggle(sc->sc_pipe[endpt]);
d1402 6
a1407 6
	sc->sc_req.bmRequestType = UT_WRITE_ENDPOINT;
	sc->sc_req.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->sc_req.wValue, UF_ENDPOINT_HALT);
	USETW(sc->sc_req.wIndex, sc->sc_epaddr[endpt]);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0, xfer);
d1429 4
a1432 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_reset\n",
		sc->sc_wire));
d1459 2
d1462 6
a1467 6
	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_BBB_RESET;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0,
d1473 2
a1474 2
		   void *data, int datalen, int dir, u_int timeout,
		   umass_callback cb, void *priv)
d1481 3
a1483 6
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_transfer\n",
		sc->sc_wire));

	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;
d1555 1
a1555 1
	memcpy(sc->cbw.CBWCDB, cmd, cmdlen);
d1572 1
a1572 1
	if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1587 2
a1588 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_state\n",
		sc->sc_wire));
d1627 1
a1627 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d1637 1
a1637 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1659 1
a1659 1
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %d failed, "
a1664 1
					sc->transfer_state = TSTATE_BBB_DCLEAR;
d1667 4
a1670 1
					    UMASS_BULKIN:UMASS_BULKOUT),
d1726 3
a1728 2
		if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
			&sc->csw, UMASS_BBB_CSW_SIZE, 0, next_xfer)) {
d1747 4
a1750 3
				sc->transfer_state = TSTATE_BBB_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
				    sc->transfer_xfer[XFER_BBB_SCLEAR]);
a1759 5
		/* Translate weird command-status signatures. */
		if ((sc->sc_quirks & UMASS_QUIRK_WRONG_CSWSIG) &&
		    UGETDW(sc->csw.dCSWSignature) == CSWSIGNATURE_OLYMPUS_C1)
			USETDW(sc->csw.dCSWSignature, CSWSIGNATURE);

d1804 1
d1806 1
a1806 1
		} else if (sc->transfer_datalen - sc->transfer_actlen
d1815 2
d1818 1
a1818 1
		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d1846 2
a1847 2
		sc->transfer_state = TSTATE_BBB_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d1857 2
a1858 2
		sc->transfer_state = TSTATE_BBB_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d1892 13
a1904 10
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_adsc\n",
		sc->sc_wire));

	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_CBI_ADSC;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, &sc->sc_req, buffer,
d1915 2
a1916 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_reset\n",
		sc->sc_wire));
d1962 2
a1963 2
		   void *cmd, int cmdlen, void *data, int datalen, int dir,
		   u_int timeout, umass_callback cb, void *priv)
d1968 3
a1970 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_transfer\n",
		sc->sc_wire));
a1974 3
	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;

d2022 2
a2023 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_state\n",
		sc->sc_wire));
d2046 4
a2049 4
			 * The control pipe has already been unstalled by the
			 * USB stack.
			 * Section 2.4.3.1.1 states that the bulk in endpoints
			 * should not stalled at this point.
d2068 1
a2068 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d2077 1
a2077 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d2083 1
a2083 1
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2087 1
a2087 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2113 1
a2113 1
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %d failed, "
d2119 3
a2121 2
				sc->transfer_state = TSTATE_CBI_DCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2137 1
a2137 1
		if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2140 1
a2140 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2165 3
a2167 2
				sc->transfer_state = TSTATE_CBI_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_INTRIN,
d2177 1
a2177 1
		if (sc->sc_cmd == UMASS_CPROTO_UFI) {
d2253 2
a2254 2
		sc->transfer_state = TSTATE_CBI_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2264 2
a2265 2
		sc->transfer_state = TSTATE_CBI_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d2295 1
d2298 1
d2304 3
d2311 1
a2311 1
	USETW(req.wIndex, sc->sc_ifaceno);
d2314 1
a2314 1
	err = usbd_do_request(sc->sc_udev, &req, maxlun);
d2351 700
d3062 2
a3063 2
	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmdlen=%d "
		"(0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s), "
d3066 1
a3066 3
		c[0], c[1], c[2], c[3], c[4], c[5],
		c[6], c[7], c[8], c[9],
		(clen > 10? "...":""),
d3115 479
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.13 2002/03/14 01:27:03 millert Exp $ */
/*	$NetBSD: umass.c,v 1.49 2001/01/21 18:56:38 augustss Exp $	*/
d33 1
a33 1
 * Universal Serial Bus Mass Storage Class Bulk-Only Transport
d54 2
a55 2
 * - UFI (floppy command set)
 * - 8070 (ATA/ATAPI)
d57 5
a61 4
 * UFI and 8070i are transformed versions of the SCSI command set. The
 * sc->transform method is used to convert the commands into the appropriate
 * format (if at all necessary). For example, UFI requires all commands to be
 * 12 bytes in length amongst other things.
d97 1
a97 6
/* XXX Should we split the driver into a number of files?  umass.c,
 *     umass_scsi.c, umass_8070.c, umass_ufi.c, umass_bbb.c, umass_cbi.c or
 *     something similar?
 */

#if !defined(__OpenBSD__)
d99 3
d104 2
d128 4
a131 26
#if defined(__FreeBSD__)
#include <cam/cam.h>
#include <cam/cam_ccb.h>
#include <cam/cam_sim.h>
#include <cam/cam_xpt_sim.h>
#include <cam/scsi/scsi_all.h>
#include <cam/scsi/scsi_da.h>

#ifdef UMASS_DO_CAM_RESCAN
#include <sys/devicestat.h>
#include <cam/cam_periph.h>
#endif

#elif defined(__NetBSD__)
#include <sys/scsiio.h>
#include <dev/scsipi/scsi_all.h>
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsiconf.h>

#include <dev/scsipi/atapiconf.h>

#include <dev/scsipi/scsipi_disk.h>
#include <dev/scsipi/scsi_disk.h>
#include <dev/scsipi/scsi_changer.h>

#include <dev/ata/atavar.h>	/* XXX */
a132 15
#define SCSI_LINK_TARGET(sc)  ((sc)->scsipi_scsi.target)
#define SCSI_LINK_LUN(sc)     ((sc)->scsipi_scsi.lun)
#elif defined(__OpenBSD__)
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>
#include <machine/bus.h>

#define SCSI_LINK_TARGET(sc)  ((sc)->target)
#define SCSI_LINK_LUN(sc)     ((sc)->lun)
#define scsipi_generic   scsi_generic

#endif

#define SHORT_INQUIRY_LENGTH    36 /* XXX */
a134 15
#define DIF(m, x)	if (umassdebug & (m)) do { x ; } while (0)
#define DPRINTF(m, x)	if (umassdebug & (m)) logprintf x
#define UDMASS_UPPER	0x00008000	/* upper layer */
#define UDMASS_GEN	0x00010000	/* general */
#define UDMASS_SCSI	0x00020000	/* scsi */
#define UDMASS_UFI	0x00040000	/* ufi command set */
#define UDMASS_8070	0x00080000	/* 8070i command set */
#define UDMASS_USB	0x00100000	/* USB general */
#define UDMASS_BBB	0x00200000	/* Bulk-Only transfers */
#define UDMASS_CBI	0x00400000	/* CBI transfers */
#define UDMASS_ALL	0xffff0000	/* all of the above */

#define UDMASS_XFER	0x40000000	/* all transfers */
#define UDMASS_CMD	0x80000000

a135 328
#else
#define DIF(m, x)	/* nop */
#define DPRINTF(m, x)	/* nop */
#endif


/* Generic definitions */

#define UFI_COMMAND_LENGTH 12
#define ATAPI_COMMAND_LENGTH 12

/* Direction for umass_*_transfer */
#define DIR_NONE	0
#define DIR_IN		1
#define DIR_OUT		2

/* The transfer speed determines the timeout value */
#define UMASS_DEFAULT_TRANSFER_SPEED	150	/* in kb/s, conservative est. */
#define UMASS_FLOPPY_TRANSFER_SPEED	20
#define UMASS_ZIP100_TRANSFER_SPEED	650

#define UMASS_SPINUP_TIME 10000	/* ms */

#ifdef __FreeBSD__
/* device name */
#define DEVNAME		"umass"
#define DEVNAME_SIM	"umass-"

#define UMASS_MAX_TRANSFER_SIZE		65536

/* CAM specific definitions */

/* The bus id, whatever that is */
#define UMASS_SCSI_BUS		0

/* All USB drives are 'connected' to one SIM (SCSI controller). umass3
 * ends up being target 3 on that SIM. When a request for target 3
 * comes in we fetch the softc with devclass_get_softc(target_id).
 *
 * The SIM is the highest target number. This makes sure that umass0 corresponds
 * to target 0 on the USB SCSI bus.
 */
#ifndef UMASS_DEBUG
#define UMASS_SCSIID_MAX	32	/* maximum number of drives expected */
#else
/* while debugging avoid unnecessary clutter in the output at umass_cam_rescan
 * (XPT_PATH_INQ)
 */
#define UMASS_SCSIID_MAX	3	/* maximum number of drives expected */
#endif
#define UMASS_SCSIID_HOST	UMASS_SCSIID_MAX
#endif

#define MS_TO_TICKS(ms) ((ms) * hz / 1000)			      


/* Bulk-Only features */

#define UR_BBB_RESET	0xff		/* Bulk-Only reset */
#define	UR_BBB_GET_MAX_LUN	0xfe

/* Command Block Wrapper */
typedef struct {
	uDWord		dCBWSignature;
#	define CBWSIGNATURE	0x43425355
	uDWord		dCBWTag;
	uDWord		dCBWDataTransferLength;
	uByte		bCBWFlags;
#	define CBWFLAGS_OUT	0x00
#	define CBWFLAGS_IN	0x80
	uByte		bCBWLUN;
	uByte		bCDBLength;
#	define CBWCDBLENGTH	16
	uByte		CBWCDB[CBWCDBLENGTH];
} umass_bbb_cbw_t;
#define UMASS_BBB_CBW_SIZE	31

/* Command Status Wrapper */
typedef struct {
	uDWord		dCSWSignature;
#	define CSWSIGNATURE	0x53425355
	uDWord		dCSWTag;
	uDWord		dCSWDataResidue;
	uByte		bCSWStatus;
#	define CSWSTATUS_GOOD	0x0
#	define CSWSTATUS_FAILED 0x1
#	define CSWSTATUS_PHASE	0x2
} umass_bbb_csw_t;
#define UMASS_BBB_CSW_SIZE	13

/* CBI features */

#define UR_CBI_ADSC	0x00

typedef unsigned char umass_cbi_cbl_t[16];	/* Command block */

typedef union {
	struct {
		unsigned char	type;
		#define IDB_TYPE_CCI		0x00
		unsigned char	value;
		#define IDB_VALUE_PASS		0x00
		#define IDB_VALUE_FAIL		0x01
		#define IDB_VALUE_PHASE		0x02
		#define IDB_VALUE_PERSISTENT	0x03
		#define IDB_VALUE_STATUS_MASK	0x03
	} common;

	struct {
		unsigned char	asc;
		unsigned char	ascq;
	} ufi;
} umass_cbi_sbl_t;



struct umass_softc;		/* see below */

typedef void (*transfer_cb_f)(struct umass_softc *sc, void *priv,
				int residue, int status);
#define STATUS_CMD_OK		0	/* everything ok */
#define STATUS_CMD_UNKNOWN	1	/* will have to fetch sense */
#define STATUS_CMD_FAILED	2	/* transfer was ok, command failed */
#define STATUS_WIRE_FAILED	3	/* couldn't even get command across */

typedef void (*wire_reset_f)(struct umass_softc *sc, int status);
typedef void (*wire_transfer_f)(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen, void *data, int datalen, 
				int dir, transfer_cb_f cb, void *priv);
typedef void (*wire_state_f)(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);

#if defined(__FreeBSD__)
typedef int (*command_transform_f)(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);
#endif


/* the per device structure */
struct umass_softc {
	USBBASEDEVICE		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;	/* device */

	unsigned char		drive;
#	define DRIVE_GENERIC		0	/* use defaults for this one */
#	define ZIP_100			1	/* to be used for quirks */
#       define ZIP_250                  2
#	define SHUTTLE_EUSB		3
#       define INSYSTEM_USBCABLE        4
	unsigned char		quirks;
	/* The drive does not support Test Unit Ready. Convert to
	 * Start Unit.
	 * Y-E Data
	 * ZIP 100
	 */
#	define NO_TEST_UNIT_READY	0x01
	/* The drive does not reset the Unit Attention state after
	 * REQUEST SENSE has been sent. The INQUIRY command does not reset
	 * the UA either, and so CAM runs in circles trying to retrieve the
	 * initial INQUIRY data.
	 * Y-E Data
	 */
#	define RS_NO_CLEAR_UA		0x02	/* no REQUEST SENSE on INQUIRY*/
	/* The drive does not support START_STOP.
	 * Shuttle E-USB
	 */
#	define NO_START_STOP		0x04
	/* Don't ask for full inquiry data (255 bytes).
	 * Yano ATAPI-USB
	 */
#       define FORCE_SHORT_INQUIRY      0x08

	unsigned int		proto;
#	define PROTO_UNKNOWN	0x0000		/* unknown protocol */
#	define PROTO_BBB	0x0001		/* USB wire protocol */
#	define PROTO_CBI	0x0002
#	define PROTO_CBI_I	0x0004
#	define PROTO_WIRE	0x00ff		/* USB wire protocol mask */
#	define PROTO_SCSI	0x0100		/* command protocol */
#	define PROTO_ATAPI	0x0200
#	define PROTO_UFI	0x0400
#       define PROTO_RBC        0x0800
#	define PROTO_COMMAND	0xff00		/* command protocol mask */

	u_char                  subclass;       /* interface subclass */
	u_char                  protocol;       /* interface protocol */

	usbd_interface_handle	iface;		/* Mass Storage interface */
	int			ifaceno;	/* MS iface number */

	u_int8_t		bulkin;		/* bulk-in Endpoint Address */
	u_int8_t		bulkout;	/* bulk-out Endpoint Address */
	u_int8_t		intrin;		/* intr-in Endp. (CBI) */
	usbd_pipe_handle	bulkin_pipe;
	usbd_pipe_handle	bulkout_pipe;
	usbd_pipe_handle	intrin_pipe;

	/* Reset the device in a wire protocol specific way */
	wire_reset_f		reset;

	/* The start of a wire transfer. It prepares the whole transfer (cmd,
	 * data, and status stage) and initiates it. It is up to the state
	 * machine (below) to handle the various stages and errors in these
	 */
	wire_transfer_f		transfer;

	/* The state machine, handling the various states during a transfer */
	wire_state_f		state;

#if defined(__FreeBSD__)
	/* The command transform function is used to conver the SCSI commands
	 * into their derivatives, like UFI, ATAPI, and friends.
	 */
	command_transform_f	transform;	/* command transform */
#endif
	
	/* Bulk specific variables for transfers in progress */
	umass_bbb_cbw_t		cbw;	/* command block wrapper */
	umass_bbb_csw_t		csw;	/* command status wrapper*/
	/* CBI specific variables for transfers in progress */
	umass_cbi_cbl_t		cbl;	/* command block */ 
	umass_cbi_sbl_t		sbl;	/* status block */

	/* generic variables for transfers in progress */
	/* ctrl transfer requests */
	usb_device_request_t	request;

	/* xfer handles
	 * Most of our operations are initiated from interrupt context, so
	 * we need to avoid using the one that is in use. We want to avoid
	 * allocating them in the interrupt context as well.
	 */
	/* indices into array below */
#	define XFER_BBB_CBW		0	/* Bulk-Only */
#	define XFER_BBB_DATA		1
#	define XFER_BBB_DCLEAR		2
#	define XFER_BBB_CSW1		3
#	define XFER_BBB_CSW2		4
#	define XFER_BBB_SCLEAR		5
#	define XFER_BBB_RESET1		6
#	define XFER_BBB_RESET2		7
#	define XFER_BBB_RESET3		8
	
#	define XFER_CBI_CB		0	/* CBI */
#	define XFER_CBI_DATA		1
#	define XFER_CBI_STATUS		2
#	define XFER_CBI_DCLEAR		3
#	define XFER_CBI_SCLEAR		4
#	define XFER_CBI_RESET1		5
#	define XFER_CBI_RESET2		6
#	define XFER_CBI_RESET3		7

#	define XFER_NR			9	/* maximum number */

	usbd_xfer_handle	transfer_xfer[XFER_NR]; /* for ctrl xfers */

	void			*data_buffer;

	int			transfer_dir;		/* data direction */
	void			*transfer_data;		/* data buffer */
	int			transfer_datalen;	/* (maximum) length */
	int			transfer_actlen;	/* actual length */ 
	transfer_cb_f		transfer_cb;		/* callback */
	void			*transfer_priv;		/* for callback */
	int			transfer_status;

	int			transfer_state;
#	define TSTATE_IDLE			0
#	define TSTATE_BBB_COMMAND		1	/* CBW transfer */
#	define TSTATE_BBB_DATA			2	/* Data transfer */
#	define TSTATE_BBB_DCLEAR		3	/* clear endpt stall */
#	define TSTATE_BBB_STATUS1		4	/* clear endpt stall */
#	define TSTATE_BBB_SCLEAR		5	/* clear endpt stall */
#	define TSTATE_BBB_STATUS2		6	/* CSW transfer */
#	define TSTATE_BBB_RESET1		7	/* reset command */
#	define TSTATE_BBB_RESET2		8	/* in clear stall */
#	define TSTATE_BBB_RESET3		9	/* out clear stall */
#	define TSTATE_CBI_COMMAND		10	/* command transfer */
#	define TSTATE_CBI_DATA			11	/* data transfer */
#	define TSTATE_CBI_STATUS		12	/* status transfer */
#	define TSTATE_CBI_DCLEAR		13	/* clear ep stall */
#	define TSTATE_CBI_SCLEAR		14	/* clear ep stall */
#	define TSTATE_CBI_RESET1		15	/* reset command */
#	define TSTATE_CBI_RESET2		16	/* in clear stall */
#	define TSTATE_CBI_RESET3		17	/* out clear stall */
#	define TSTATE_STATES			18	/* # of states above */


	int			transfer_speed;		/* in kb/s */
	int			timeout;		/* in msecs */

	u_int8_t		maxlun;			/* max lun supported */

#ifdef UMASS_DEBUG
	struct timeval tv;
#endif

#if defined(__FreeBSD__)
	/* SCSI/CAM specific variables */
	struct scsi_sense	cam_scsi_sense;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
	union {
		struct scsipi_link	sc_link;
#if defined(__NetBSD__)
		struct {
			struct ata_atapi_attach	sc_aa;
			struct ata_drive_datas	sc_aa_drive;
		} aa;
#endif
	} u;
#if defined(__NetBSD__)
	struct atapi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter._generic
#else
	struct scsi_adapter	sc_atapi_adapter;
#define sc_adapter sc_atapi_adapter
#endif
	int			sc_xfer_flags;
	usbd_status		sc_sync_status;
	struct scsipi_sense	sc_sense_cmd;

	device_ptr_t		sc_child;	/* child device, for detach */
	char			sc_dying;

#endif
};
a136 1
#ifdef UMASS_DEBUG
a160 4
struct cam_sim *umass_sim;	/* SCSI Interface Module */
struct cam_path *umass_path;	/*   and its path */


a163 4
Static int umass_match_proto(struct umass_softc *sc,
				usbd_interface_handle iface,
				usbd_device_handle dev);
Static void umass_init_shuttle(struct umass_softc *sc);
a170 1
				usbd_device_handle dev,
d174 2
a175 3
Static void umass_clear_endpoint_stall(struct umass_softc *sc,
				u_int8_t endpt, usbd_pipe_handle pipe,
				int state, usbd_xfer_handle xfer);
d177 1
a177 2
Static void umass_reset(struct umass_softc *sc,
				transfer_cb_f cb, void *priv);
d181 4
a184 10
Static void umass_bbb_reset(struct umass_softc *sc, int status);
Static void umass_bbb_transfer(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen,
				void *data, int datalen, int dir,
				transfer_cb_f cb, void *priv);
Static void umass_bbb_state(usbd_xfer_handle xfer,
				usbd_private_handle priv,
				usbd_status err);
usbd_status umass_bbb_get_max_lun(struct umass_softc *sc,
				       u_int8_t *maxlun);
d186 1
d189 12
a200 30
Static int umass_cbi_adsc(struct umass_softc *sc, char *buffer,int buflen,
				usbd_xfer_handle xfer);
Static void umass_cbi_reset(struct umass_softc *sc, int status);
Static void umass_cbi_transfer(struct umass_softc *sc, int lun,
				void *cmd, int cmdlen,
				void *data, int datalen, int dir,
				transfer_cb_f cb, void *priv);
Static void umass_cbi_state(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);

#if defined(__FreeBSD__)
/* CAM related functions */
Static void umass_cam_action(struct cam_sim *sim, union ccb *ccb);
Static void umass_cam_poll(struct cam_sim *sim);

Static void umass_cam_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
Static void umass_cam_sense_cb(struct umass_softc *sc, void *priv,
				int residue, int status);

#ifdef UMASS_DO_CAM_RESCAN
Static void umass_cam_rescan(struct umass_softc *sc);
#endif

Static int umass_cam_attach_sim(void);
Static int umass_cam_attach(struct umass_softc *sc);
Static int umass_cam_detach_sim(void);
Static int umass_cam_detach(struct umass_softc *sc);

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d202 4
a205 13
#define UMASS_SCSIID_HOST	0x00
#define UMASS_SCSIID_DEVICE	0x01

#define UMASS_ATAPI_DRIVE       0

#define UMASS_MAX_TRANSFER_SIZE	MAXBSIZE

struct scsipi_device umass_dev =
{
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
a207 36
Static int umass_scsipi_cmd(struct scsipi_xfer *xs);
Static void umass_scsipi_minphys(struct buf *bp);
Static int umass_scsipi_ioctl(struct scsipi_link *, u_long,
				   caddr_t, int, struct proc *);
Static void umass_scsipi_cb(struct umass_softc *sc, void *priv,
				     int residue, int status);
Static void umass_scsipi_sense_cb(struct umass_softc *sc, void *priv,
				       int residue, int status);

Static int scsipiprint(void *aux, const char *pnp);
Static int umass_ufi_transform(struct umass_softc *sc,
    struct scsipi_generic *cmd, int cmdlen,
    struct scsipi_generic *rcmd, int *rcmdlen);

#if NATAPIBUS > 0
Static void umass_atapi_probedev(struct atapibus_softc *, int);
#endif
#endif

#if defined(__FreeBSD__)
/* SCSI specific functions */
Static int umass_scsi_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);

/* UFI specific functions */
Static int umass_ufi_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);

/* 8070 specific functions */
Static int umass_8070_transform(struct umass_softc *sc,
				unsigned char *cmd, int cmdlen,
				unsigned char **rcmd, int *rcmdlen);
#endif

a218 2
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);	/* XXXXX */

d223 1
a223 11
/*
 * Match the device we are seeing with the devices supported. Fill in the
 * proto and drive fields in the softc accordingly.
 * This function is called from both probe and attach.
 */

Static int
umass_match_proto(sc, iface, dev)
	struct umass_softc *sc;
	usbd_interface_handle iface;
	usbd_device_handle dev;
d225 2
a226 1
	usb_device_descriptor_t *dd;
a227 1
	u_int vendor, product;
d229 2
a230 61
	/*
	 * Fill in sc->drive and sc->proto and return a match
	 * value if both are determined and 0 otherwise.
	 */

	sc->drive = DRIVE_GENERIC;
	sc->proto = PROTO_UNKNOWN;
	sc->transfer_speed = UMASS_DEFAULT_TRANSFER_SPEED;

	sc->sc_udev = dev;
	dd = usbd_get_device_descriptor(dev);
	vendor = UGETW(dd->idVendor);
	product = UGETW(dd->idProduct);

	if (vendor == USB_VENDOR_SHUTTLE &&
	    product == USB_PRODUCT_SHUTTLE_EUSB) {
		sc->drive = SHUTTLE_EUSB;
#if CBI_I
		sc->proto = PROTO_ATAPI | PROTO_CBI_I;
#else
		sc->proto = PROTO_ATAPI | PROTO_CBI;
#endif
		sc->subclass = UISUBCLASS_SFF8020I;
		sc->protocol = UIPROTO_MASS_CBI;
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;
		return (UMATCH_VENDOR_PRODUCT);
	}

	if (vendor == USB_VENDOR_YANO &&
	    product == USB_PRODUCT_YANO_U640MO) {
		sc->proto = PROTO_ATAPI | PROTO_CBI_I;
		sc->quirks |= FORCE_SHORT_INQUIRY;
		return (UMATCH_VENDOR_PRODUCT);
	}

	if (vendor == USB_VENDOR_SONY &&
	    product == USB_PRODUCT_SONY_MSC) {
		printf ("XXX Sony MSC\n");
		sc->quirks |= FORCE_SHORT_INQUIRY;
	}

	if (vendor == USB_VENDOR_YEDATA &&
	    product == USB_PRODUCT_YEDATA_FLASHBUSTERU) {

		/* Revisions < 1.28 do not handle the interrupt endpoint
		 * very well.
		 */
		if (UGETW(dd->bcdDevice) < 0x128)
			sc->proto = PROTO_UFI | PROTO_CBI;
		else
#if CBI_I
			sc->proto = PROTO_UFI | PROTO_CBI_I;
#else
			sc->proto = PROTO_UFI | PROTO_CBI;
#endif
		/*
		 * Revisions < 1.28 do not have the TEST UNIT READY command
		 * Revisions == 1.28 have a broken TEST UNIT READY
		 */
		if (UGETW(dd->bcdDevice) <= 0x128)
			sc->quirks |= NO_TEST_UNIT_READY;
d232 3
a234 15
		sc->subclass = UISUBCLASS_UFI;
		sc->protocol = UIPROTO_MASS_CBI;

		sc->quirks |= RS_NO_CLEAR_UA;
		sc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;
		return (UMATCH_VENDOR_PRODUCT_REV);
	}

	if (vendor == USB_VENDOR_INSYSTEM &&
	    product == USB_PRODUCT_INSYSTEM_USBCABLE) {
		sc->drive = INSYSTEM_USBCABLE;
		sc->proto = PROTO_ATAPI | PROTO_CBI;
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;
		return (UMATCH_VENDOR_PRODUCT);
	}
d236 1
a236 1
	id = usbd_get_interface_descriptor(iface);
d240 4
a243 21
	if (vendor == USB_VENDOR_SONY && id->bInterfaceSubClass == 0xff) {
		/* 
		 * Sony DSC devices set the sub class to 0xff
		 * instead of 1 (RBC). Fix that here.
		 */
		id->bInterfaceSubClass = UISUBCLASS_RBC;
		/* They also should be able to do higher speed. */
		sc->transfer_speed = 500;
	}

	if (vendor == USB_VENDOR_FUJIPHOTO &&
	    product == USB_PRODUCT_FUJIPHOTO_MASS0100)
		sc->quirks |= NO_TEST_UNIT_READY | NO_START_STOP;

	sc->subclass = id->bInterfaceSubClass;
	sc->protocol = id->bInterfaceProtocol;
	
	switch (sc->subclass) {
	case UISUBCLASS_SCSI:
		sc->proto |= PROTO_SCSI;
		break;
a244 4
		sc->transfer_speed = UMASS_FLOPPY_TRANSFER_SPEED;
		sc->proto |= PROTO_UFI;
		break;
	case UISUBCLASS_SFF8020I:
d246 1
a246 5
	case UISUBCLASS_QIC157:
		sc->proto |= PROTO_ATAPI;
		break;
	case UISUBCLASS_RBC:
		sc->proto |= PROTO_RBC;
d249 1
a249 6
		/* Assume that unsupported devices are ATAPI */
		DPRINTF(UDMASS_GEN, ("%s: Unsupported command protocol %d\n",
			USBDEVNAME(sc->sc_dev), id->bInterfaceSubClass));

		sc->proto |= PROTO_ATAPI;
		break;
d252 2
a253 1
	switch (sc->protocol) {
d255 1
a255 9
		sc->proto |= PROTO_CBI;
		break;
	case UIPROTO_MASS_CBI_I:
#if CBI_I
		sc->proto |= PROTO_CBI_I;
#else
		sc->proto |= PROTO_CBI;
#endif
		break;
a256 7
		sc->proto |= PROTO_BBB;
		break;
	case UIPROTO_MASS_BBB_P:
		sc->drive = ZIP_100;
		sc->proto |= PROTO_BBB;
		sc->transfer_speed = UMASS_ZIP100_TRANSFER_SPEED;
		sc->quirks |= NO_TEST_UNIT_READY;
d259 1
a259 3
		DPRINTF(UDMASS_GEN, ("%s: Unsupported wire protocol %d\n",
			USBDEVNAME(sc->sc_dev), id->bInterfaceProtocol));
		return (UMATCH_NONE);
d262 1
a262 18
	return (UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO);
}

USB_MATCH(umass)
{
	USB_MATCH_START(umass, uaa);
#if defined(__FreeBSD__)
	struct umass_softc *sc = device_get_softc(self);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	struct umass_softc scs, *sc = &scs;
	memset(sc, 0, sizeof *sc);
	strcpy(sc->sc_dev.dv_xname, "umass");
#endif

	if (uaa->iface == NULL)
		return(UMATCH_NONE);

	return (umass_match_proto(sc, uaa->iface, uaa->device));
a264 2
void umass_delayed_attach(struct umass_softc  *sc);

d268 1
d271 1
a271 1
	const char *sSubclass, *sProto;
d273 2
a274 7
	int i, bno;
	int err;

	/*
	 * the softc struct is bzero-ed in device_set_driver. We can safely
	 * call umass_detach without specifically initialising the struct.
	 */
d279 10
a288 2
	sc->iface = uaa->iface;
	sc->ifaceno = uaa->ifaceno;
d290 11
a300 3
	/* initialise the proto and drive values in the umass_softc (again) */
	if (umass_match_proto(sc, sc->iface, uaa->device) == 0) {
		printf("%s: match failed\n", USBDEVNAME(sc->sc_dev));
d302 20
d324 28
a351 8
	/*
	 * The timeout is based on the maximum expected transfer size
	 * divided by the expected transfer speed.
	 * We multiply by 4 to make sure a busy system doesn't make things
	 * fail.
	 */
	sc->timeout = 4 * UMASS_MAX_TRANSFER_SIZE / sc->transfer_speed;
	sc->timeout += UMASS_SPINUP_TIME;	/* allow for spinning up */
a352 1
	id = usbd_get_interface_descriptor(sc->iface);
d355 3
a357 12
	switch (sc->subclass) {
	case UISUBCLASS_RBC:
		sSubclass = "RBC";
		break;
	case UISUBCLASS_SCSI:
		sSubclass = "SCSI";
		break;
	case UISUBCLASS_UFI:
		sSubclass = "UFI";
		break;
	case UISUBCLASS_SFF8020I:
		sSubclass = "SFF8020i";
d359 2
a360 2
	case UISUBCLASS_SFF8070I:
		sSubclass = "SFF8070i";
d362 2
a363 2
	case UISUBCLASS_QIC157:
		sSubclass = "QIC157";
d366 1
a366 1
		sSubclass = "unknown";
d369 7
a375 3
	switch (sc->protocol) {
	case UIPROTO_MASS_CBI:
		sProto = "CBI";
d377 2
a378 2
	case UIPROTO_MASS_CBI_I:
		sProto = "CBI-I";
d380 2
a381 2
	case UIPROTO_MASS_BBB:
		sProto = "BBB";
d383 2
a384 2
	case UIPROTO_MASS_BBB_P:
		sProto = "BBB-P";
d387 1
a387 1
		sProto = "unknown";
a389 2
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sSubclass, 
	       sProto);
d391 2
a392 10
	if (sc->drive == INSYSTEM_USBCABLE) {
		err = usbd_set_interface(0, 1);
		if (err) {
			DPRINTF(UDMASS_USB, ("%s: could not switch to "
					     "Alt Interface %d\n",
					     USBDEVNAME(sc->sc_dev), 1));
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
                }
	}
d406 2
a407 2
		ed = usbd_interface2endpoint_descriptor(sc->iface, i);
		if (!ed) {
d414 1
a414 1
			sc->bulkin = ed->bEndpointAddress;
d417 2
a418 2
			sc->bulkout = ed->bEndpointAddress;
		} else if (sc->proto & PROTO_CBI_I
d421 1
a421 1
			sc->intrin = ed->bEndpointAddress;
d433 7
a439 6
	if (!sc->bulkin || !sc->bulkout
	    || (sc->proto & PROTO_CBI_I && !sc->intrin) ) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %d/%d/%d\n",
			USBDEVNAME(sc->sc_dev),
			sc->bulkin, sc->bulkout, sc->intrin));
		umass_disco(sc);
d446 2
a447 1
	if ((sc->proto & PROTO_WIRE) == PROTO_BBB) {
d459 3
a461 2
	err = usbd_open_pipe(sc->iface, sc->bulkout,
				USBD_EXCLUSIVE_USE, &sc->bulkout_pipe);
d463 2
a464 2
		DPRINTF(UDMASS_USB, ("%s: cannot open %d-out pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->bulkout));
d468 2
a469 2
	err = usbd_open_pipe(sc->iface, sc->bulkin,
				USBD_EXCLUSIVE_USE, &sc->bulkin_pipe);
d471 2
a472 2
		DPRINTF(UDMASS_USB, ("%s: could not open %d-in pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->bulkin));
d488 3
a490 3
	if (sc->proto & PROTO_CBI_I) {
		err = usbd_open_pipe(sc->iface, sc->intrin,
				USBD_EXCLUSIVE_USE, &sc->intrin_pipe);
d492 3
a494 2
			DPRINTF(UDMASS_USB, ("%s: couldn't open %d-in (intr)\n",
				USBDEVNAME(sc->sc_dev), sc->intrin));
d514 2
a515 2
	switch (sc->proto & PROTO_WIRE) {
	case PROTO_BBB:
d518 1
a518 1
	case PROTO_CBI:
d521 1
a521 1
	case PROTO_CBI_I:
d536 11
a546 13
	if (sc->proto & PROTO_BBB) {
		sc->reset = umass_bbb_reset;
		sc->transfer = umass_bbb_transfer;
		sc->state = umass_bbb_state;
	} else if ((sc->proto & PROTO_CBI) || (sc->proto & PROTO_CBI_I)) {
		sc->reset = umass_cbi_reset;
		sc->transfer = umass_cbi_transfer;
		sc->state = umass_cbi_state;
#ifdef UMASS_DEBUG
	} else {
		panic("%s:%d: Unknown proto 0x%02x\n",
		      __FILE__, __LINE__, sc->proto);
#endif
d549 7
a555 2
	if (sc->drive == SHUTTLE_EUSB)
		umass_init_shuttle(sc);
d557 10
a566 27
	/*
	 * Fill in the adapter.
	 */
	sc->sc_adapter.scsipi_cmd = umass_scsipi_cmd;
	sc->sc_adapter.scsipi_minphys = umass_scsipi_minphys;
	
	/*
	 * fill in the prototype scsipi_link.
	 */
	switch (sc->proto & PROTO_COMMAND) {
	case PROTO_SCSI:
	case PROTO_UFI:
	case PROTO_ATAPI:
	case PROTO_RBC:
		if ((sc->proto & PROTO_COMMAND) != PROTO_SCSI)
			sc->u.sc_link.flags |= SDEV_ATAPI;
		else
			sc->u.sc_link.flags &= ~SDEV_ATAPI;

		sc->u.sc_link.adapter_buswidth = 2;
		sc->u.sc_link.adapter_target = UMASS_SCSIID_HOST; 
		sc->u.sc_link.luns = sc->maxlun + 1;

		sc->u.sc_link.adapter_softc = sc;
		sc->u.sc_link.adapter = &sc->sc_adapter;
		sc->u.sc_link.device = &umass_dev;
		sc->u.sc_link.openings = 1;
d568 8
a575 2
		if(sc->quirks & NO_TEST_UNIT_READY)
			sc->u.sc_link.quirks |= ADEV_NOTUR;
d578 7
d587 2
a588 2
		printf("%s: proto=0x%x not supported yet\n", 
		       USBDEVNAME(sc->sc_dev), sc->proto);
d592 2
a593 19

	if (cold) {
		startuphook_establish((void (*)(void *))umass_delayed_attach,
			sc);
	} else {
		/* hot plug, do it now */
		umass_delayed_attach(sc);
	}

	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
}

void
umass_delayed_attach(struct umass_softc  *sc)
{
	sc->sc_child = config_found(&sc->sc_dev, &sc->u, scsipiprint);
	if (sc->sc_child == NULL) {
d595 1
a595 2
		/* Not an error, just not a complete success. */
		USB_ATTACH_SUCCESS_RETURN;
a599 1
}
d601 3
a603 16
Static int
scsipiprint(aux, pnp)
	void *aux;
	const char *pnp;
{
#if !defined(__OpenBSD__)
	extern int atapi_print(void *aux, const char *pnp);
	struct scsipi_link *l = aux;

	if (l->type == BUS_SCSI)
		return (scsiprint(aux, pnp));
	else
		return (atapi_print(aux, pnp));
#else
	return (scsiprint(aux, pnp));
#endif
d609 2
a610 1
	int rv = 0;
d615 4
a618 6
	if (sc->bulkout_pipe != NULL)
		usbd_abort_pipe(sc->bulkout_pipe);
	if (sc->bulkin_pipe != NULL)
		usbd_abort_pipe(sc->bulkin_pipe);
	if (sc->intrin_pipe != NULL)
		usbd_abort_pipe(sc->intrin_pipe);
d630 7
a636 10
#if defined(__FreeBSD__)
	if ((sc->proto & PROTO_SCSI) ||
	    (sc->proto & PROTO_ATAPI) ||
	    (sc->proto & PROTO_UFI))
		/* detach the device from the SCSI host controller (SIM) */
		rv = umass_cam_detach(sc);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
#endif
d645 1
a645 1
	return (0);
a647 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d649 1
a649 3
umass_activate(self, act)
	struct device *self;
	enum devact act;
d651 2
a652 1
	struct umass_softc *sc = (struct umass_softc *) self;
d664 2
a665 1
		if (sc->sc_child == NULL)
d667 1
a667 1
		rv = config_deactivate(sc->sc_child);
a669 2
		if (rv == 0)
			sc->sc_dying = 1;
a673 1
#endif
d676 1
a676 2
umass_disco(sc)
	struct umass_softc *sc;
d690 4
a693 21
	if (sc->bulkout_pipe != NULL)
		usbd_close_pipe(sc->bulkout_pipe);
	if (sc->bulkin_pipe != NULL)
		usbd_close_pipe(sc->bulkin_pipe);
	if (sc->intrin_pipe != NULL)
		usbd_close_pipe(sc->intrin_pipe);
}

Static void
umass_init_shuttle(struct umass_softc *sc)
{
	usb_device_request_t req;
	u_char status[2];

	/* The Linux driver does this */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = 1;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->ifaceno);
	USETW(req.wLength, sizeof status);
	(void)usbd_do_request(sc->sc_udev, &req, &status);
d713 1
a713 1
	    flags | sc->sc_xfer_flags, sc->timeout, sc->state);
d730 2
a731 4
umass_setup_ctrl_transfer(struct umass_softc *sc, usbd_device_handle dev,
	 usb_device_request_t *req,
	 void *buffer, int buflen, int flags,
	 usbd_xfer_handle xfer)
d740 2
a741 2
	usbd_setup_default_xfer(xfer, dev, (void *) sc,
	    sc->timeout, req, buffer, buflen, flags, sc->state);
d756 2
a757 3
umass_clear_endpoint_stall(struct umass_softc *sc,
	u_int8_t endpt, usbd_pipe_handle pipe,
	int state, usbd_xfer_handle xfer)
a758 2
	usbd_device_handle dev;

d763 1
a763 5
		USBDEVNAME(sc->sc_dev), endpt));

	usbd_interface2device_handle(sc->iface, &dev);

	sc->transfer_state = state;
d765 1
a765 1
	usbd_clear_endpoint_toggle(pipe);
d767 6
a772 6
	sc->request.bmRequestType = UT_WRITE_ENDPOINT;
	sc->request.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->request.wValue, UF_ENDPOINT_HALT);
	USETW(sc->request.wIndex, endpt);
	USETW(sc->request.wLength, 0);
	umass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0, xfer);
d794 3
a796 4
	usbd_device_handle dev;

	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_reset\n", sc->proto));
a822 2
	usbd_interface2device_handle(sc->iface, &dev);

d824 6
a829 6
	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->request.bRequest = UR_BBB_RESET;
	USETW(sc->request.wValue, 0);
	USETW(sc->request.wIndex, sc->ifaceno);
	USETW(sc->request.wLength, 0);
	umass_setup_ctrl_transfer(sc, dev, &sc->request, NULL, 0, 0,
d835 2
a836 2
		    void *data, int datalen, int dir,
		    transfer_cb_f cb, void *priv)
d843 6
a848 3
	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_transfer\n",
		sc->proto));
d920 1
a920 1
	bcopy(cmd, sc->cbw.CBWCDB, cmdlen);
d937 1
a937 1
	if (umass_setup_transfer(sc, sc->bulkout_pipe,
d952 3
a954 2
	KASSERT(sc->proto & PROTO_BBB,
		("sc->proto == 0x%02x wrong for umass_bbb_state\n",sc->proto));
d993 1
a993 1
			if (umass_setup_transfer(sc, sc->bulkin_pipe,
d1003 1
a1003 1
			if (umass_setup_transfer(sc, sc->bulkout_pipe,
d1025 1
a1025 1
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %db failed, "
d1031 1
d1034 1
a1034 4
					    sc->bulkin:sc->bulkout),
					  (sc->transfer_dir == DIR_IN?
					    sc->bulkin_pipe:sc->bulkout_pipe),
					  TSTATE_BBB_DCLEAR,
d1090 2
a1091 3
		if (umass_setup_transfer(sc, sc->bulkin_pipe,
				&sc->csw, UMASS_BBB_CSW_SIZE, 0,
				next_xfer)) {
d1110 3
a1112 4
				umass_clear_endpoint_stall(sc,
						sc->bulkin, sc->bulkin_pipe,
						TSTATE_BBB_SCLEAR,
						sc->transfer_xfer[XFER_BBB_SCLEAR]);
d1122 5
a1170 1
		} 
d1172 1
a1172 1
		else if (sc->transfer_datalen - sc->transfer_actlen
a1180 2

		}
d1182 1
a1182 1
		else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d1210 2
a1211 2
		umass_clear_endpoint_stall(sc,
			sc->bulkin, sc->bulkin_pipe, TSTATE_BBB_RESET2,
d1221 2
a1222 2
		umass_clear_endpoint_stall(sc,
			sc->bulkout, sc->bulkout_pipe, TSTATE_BBB_RESET3,
d1256 10
a1265 13
	usbd_device_handle dev;

	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_adsc\n",sc->proto));

	usbd_interface2device_handle(sc->iface, &dev);

	sc->request.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->request.bRequest = UR_CBI_ADSC;
	USETW(sc->request.wValue, 0);
	USETW(sc->request.wIndex, sc->ifaceno);
	USETW(sc->request.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, dev, &sc->request, buffer,
d1276 3
a1278 2
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_reset\n",sc->proto));
d1324 2
a1325 2
		void *cmd, int cmdlen, void *data, int datalen, int dir,
		transfer_cb_f cb, void *priv)
d1330 3
a1332 3
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_transfer\n",
		sc->proto));
d1337 3
d1387 3
a1389 2
	KASSERT(sc->proto & (PROTO_CBI|PROTO_CBI_I),
		("sc->proto == 0x%02x wrong for umass_cbi_state\n", sc->proto));
d1412 4
a1415 4
                         * The control pipe has already been unstalled by the
                         * USB stack.
                         * Section 2.4.3.1.1 states that the bulk in endpoints
                         * should not stalled at this point.
d1434 1
a1434 1
			if (umass_setup_transfer(sc, sc->bulkin_pipe,
d1443 1
a1443 1
			if (umass_setup_transfer(sc, sc->bulkout_pipe,
d1449 1
a1449 1
		} else if (sc->proto & PROTO_CBI_I) {
d1453 1
a1453 1
			if (umass_setup_transfer(sc, sc->intrin_pipe,
d1479 1
a1479 1
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %db failed, "
d1485 2
a1486 3
				umass_clear_endpoint_stall(sc,
					sc->bulkin, sc->bulkin_pipe,
					TSTATE_CBI_DCLEAR,
d1502 1
a1502 1
		if (sc->proto & PROTO_CBI_I) {
d1505 1
a1505 1
			if (umass_setup_transfer(sc, sc->intrin_pipe,
d1530 2
a1531 3
				umass_clear_endpoint_stall(sc,
					sc->intrin, sc->intrin_pipe,
					TSTATE_CBI_SCLEAR,
d1541 1
a1541 1
		if (sc->proto & PROTO_UFI) {
d1617 2
a1618 2
		umass_clear_endpoint_stall(sc,
			sc->bulkin, sc->bulkin_pipe, TSTATE_CBI_RESET2,
d1628 2
a1629 2
		umass_clear_endpoint_stall(sc,
			sc->bulkout, sc->bulkout_pipe, TSTATE_CBI_RESET3,
a1658 1
	usbd_device_handle dev;
a1660 1
	usb_interface_descriptor_t *id;
a1665 3
	usbd_interface2device_handle(sc->iface, &dev);
	id = usbd_get_interface_descriptor(sc->iface);

d1670 1
a1670 1
	USETW(req.wIndex, id->bInterfaceNumber);
d1673 1
a1673 1
	err = usbd_do_request(dev, &req, maxlun);
a1709 700
#if defined(__FreeBSD__)
/*
 * CAM specific functions (used by SCSI, UFI, 8070)
 */

Static int
umass_cam_attach_sim()
{
	struct cam_devq *devq;		/* Per device Queue */

	/* A HBA is attached to the CAM layer.
	 *
	 * The CAM layer will then after a while start probing for
	 * devices on the bus. The number of devices is limitted to one.
	 */

	/* SCSI transparent command set */

	devq = cam_simq_alloc(1 /*maximum openings*/);
	if (devq == NULL)
		return(ENOMEM);

	umass_sim = cam_sim_alloc(umass_cam_action, umass_cam_poll, DEVNAME,
				NULL /*priv*/, 0 /*unit number*/,
				1 /*maximum device openings*/,
				0 /*maximum tagged device openings*/,
				devq);
	if (umass_sim == NULL) {
		cam_simq_free(devq);
		return(ENOMEM);
	}

	if(xpt_bus_register(umass_sim, 0) != CAM_SUCCESS)
		return(ENOMEM);

	if (xpt_create_path(&umass_path, NULL, cam_sim_path(umass_sim),
			    UMASS_SCSIID_HOST, 0)
	    != CAM_REQ_CMP)
		return(ENOMEM);

	return(0);
}

#ifdef UMASS_DO_CAM_RESCAN
/* this function is only used from umass_cam_rescan, so mention
 * prototype down here.
 */
Static void umass_cam_rescan_callback(struct cam_periph *periph,union ccb *ccb);

Static void
umass_cam_rescan_callback(struct cam_periph *periph, union ccb *ccb)
{
#ifdef UMASS_DEBUG
	struct umass_softc *sc = devclass_get_softc(umass_devclass,
					       ccb->ccb_h.target_id);

	if (ccb->ccb_h.status != CAM_REQ_CMP) {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: Rescan failed, 0x%04x\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.status));
	} else {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: Rescan succeeded, freeing resources.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));
	}
#endif

	xpt_free_path(ccb->ccb_h.path);
	free(ccb, M_USBDEV);
}

Static void
umass_cam_rescan(struct umass_softc *sc)
{
	struct cam_path *path;
	union ccb *ccb = malloc(sizeof(union ccb), M_USBDEV, M_WAITOK);

	memset(ccb, 0, sizeof(union ccb));

	DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d: scanning bus for new device %d\n",
		USBDEVNAME(sc->sc_dev),	 cam_sim_path(umass_sim),
		device_get_unit(sc->sc_dev), 0,
		device_get_unit(sc->sc_dev)));

	if (xpt_create_path(&path, xpt_periph, cam_sim_path(umass_sim),
		    device_get_unit(sc->sc_dev), 0)
	    != CAM_REQ_CMP)
		return;

	xpt_setup_ccb(&ccb->ccb_h, path, 5/*priority (low)*/);
	ccb->ccb_h.func_code = XPT_SCAN_BUS;
	ccb->ccb_h.cbfcnp = umass_cam_rescan_callback;
	ccb->crcn.flags = CAM_FLAG_NONE;
	xpt_action(ccb);

	/* The scan is in progress now. */
}
#endif

Static int
umass_cam_attach(struct umass_softc *sc)
{
	/* SIM already attached at module load. The device is a target on the
	 * one SIM we registered: target device_get_unit(self).
	 */

	/* The artificial limit UMASS_SCSIID_MAX is there because CAM expects
	 * a limit to the number of targets that are present on a SIM.
	 */
	if (device_get_unit(sc->sc_dev) > UMASS_SCSIID_MAX) {
		printf("%s: Increase UMASS_SCSIID_MAX (currently %d) in %s "
			"and try again.\n", USBDEVNAME(sc->sc_dev),
			UMASS_SCSIID_MAX, __FILE__);
		return(1);
	}
		
#ifdef UMASS_DO_CAM_RESCAN
	if (!cold) {
		/* Notify CAM of the new device. Any failure is benign, as the
		 * user can still do it by hand (camcontrol rescan <busno>).
		 * Only do this if we are not booting, because CAM does a scan
		 * after booting has completed, when interrupts have been
		 * enabled.
		 */
		umass_cam_rescan(sc);
	}
#endif

	return(0);	/* always succesful */
}

/* umass_cam_detach
 *	detach from the CAM layer
 */

Static int
umass_cam_detach_sim()
{
	if (umass_sim)
		return(EBUSY);	/* XXX CAM can't handle disappearing SIMs yet */

	if (umass_path) {
		/* XXX do we need to send an asynchroneous event for the SIM?
		xpt_async(AC_LOST_DEVICE, umass_path, NULL);
		 */
		xpt_free_path(umass_path);
		umass_path = NULL;
	}

	if (umass_sim) {
		if (xpt_bus_deregister(cam_sim_path(umass_sim)))
			cam_sim_free(umass_sim, /*free_devq*/TRUE);
		else
			return(EBUSY);

		umass_sim = NULL;
	}

	return(0);
}

Static int
umass_cam_detach(struct umass_softc *sc)
{
	struct cam_path *path;

	/* detach of sim not done until module unload */
	DPRINTF(UDMASS_SCSI, ("%s: losing CAM device entry\n",
		USBDEVNAME(sc->sc_dev)));

	if (xpt_create_path(&path, NULL, cam_sim_path(umass_sim),
		    device_get_unit(sc->sc_dev), CAM_LUN_WILDCARD)
	    != CAM_REQ_CMP)
		return(ENOMEM);
	xpt_async(AC_LOST_DEVICE, path, NULL);
	xpt_free_path(path);

	return(0);
}



/* umass_cam_action
 *	CAM requests for action come through here
 */

Static void
umass_cam_action(struct cam_sim *sim, union ccb *ccb)
{
	struct umass_softc *sc = devclass_get_softc(umass_devclass,
					       ccb->ccb_h.target_id);

	/* The softc is still there, but marked as going away. umass_cam_detach
	 * has not yet notified CAM of the lost device however.
	 */
	if (sc && sc->sc_dying) {
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
			"Invalid target (gone)\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.func_code));
		ccb->ccb_h.status = CAM_TID_INVALID;
		xpt_done(ccb);
		return;
	}

	/* Verify, depending on the operation to perform, that we either got a
	 * valid sc, because an existing target was referenced, or otherwise
	 * the SIM is addressed.
	 *
	 * This avoids bombing out at a printf and does give the CAM layer some
	 * sensible feedback on errors.
	 */
	switch (ccb->ccb_h.func_code) {
	case XPT_SCSI_IO:
	case XPT_RESET_DEV:
	case XPT_GET_TRAN_SETTINGS:
	case XPT_SET_TRAN_SETTINGS:
	case XPT_CALC_GEOMETRY:
		/* the opcodes requiring a target. These should never occur. */
		if (sc == NULL) {
			printf("%s:%d:%d:%d:func_code 0x%04x: "
				"Invalid target\n",
				DEVNAME_SIM, UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				ccb->ccb_h.func_code);

			ccb->ccb_h.status = CAM_TID_INVALID;
			xpt_done(ccb);
			return;
		}
		break;
	case XPT_PATH_INQ:
	case XPT_NOOP:
		/* The opcodes sometimes aimed at a target (sc is valid),
		 * sometimes aimed at the SIM (sc is invalid and target is
		 * CAM_TARGET_WILDCARD)
		 */
		if (sc == NULL && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
				"Invalid target\n",
				DEVNAME_SIM, UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				ccb->ccb_h.func_code));

			ccb->ccb_h.status = CAM_TID_INVALID;
			xpt_done(ccb);
			return;
		}
		break;
	default:
		/* XXX Hm, we should check the input parameters */
	}

	/* Perform the requested action */
	switch (ccb->ccb_h.func_code) {
	case XPT_SCSI_IO:
	{
		struct ccb_scsiio *csio = &ccb->csio;	/* deref union */
		int dir;
		unsigned char *cmd;
		int cmdlen;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
			"cmd: 0x%02x, flags: 0x%02x, "
			"%db cmd/%db data/%db sense\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			csio->cdb_io.cdb_bytes[0],
			ccb->ccb_h.flags & CAM_DIR_MASK,
			csio->cdb_len, csio->dxfer_len,
			csio->sense_len));

		/* clear the end of the buffer to make sure we don't send out
		 * garbage.
		 */
		DIF(UDMASS_SCSI, if ((ccb->ccb_h.flags & CAM_DIR_MASK)
				     == CAM_DIR_OUT)
					umass_dump_buffer(sc, csio->data_ptr,
						csio->dxfer_len, 48));

		if (sc->transfer_state != TSTATE_IDLE) {
			DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SCSI_IO: "
				"I/O requested while busy (state %d, %s)\n",
				USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
				ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
				sc->transfer_state,states[sc->transfer_state]));
			ccb->ccb_h.status = CAM_SCSI_BUSY;
			xpt_done(ccb);
			return;
		}

		switch(ccb->ccb_h.flags&CAM_DIR_MASK) {
		case CAM_DIR_IN:
			dir = DIR_IN;
			break;
		case CAM_DIR_OUT:
			dir = DIR_OUT;
			break;
		default:
			dir = DIR_NONE;
		}

		ccb->ccb_h.status = CAM_REQ_INPROG | CAM_SIM_QUEUED;
		if (sc->transform(sc, csio->cdb_io.cdb_bytes, csio->cdb_len,
				  &cmd, &cmdlen)) {
			sc->transfer(sc, ccb->ccb_h.target_lun, cmd, cmdlen,
				     csio->data_ptr,
				     csio->dxfer_len, dir,
				     umass_cam_cb, (void *) ccb);
		} else {
			ccb->ccb_h.status = CAM_REQ_INVALID;
			xpt_done(ccb);
		}

		break;
	}
	case XPT_PATH_INQ:
	{
		struct ccb_pathinq *cpi = &ccb->cpi;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_PATH_INQ:.\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		/* host specific information */
		cpi->version_num = 1;
		cpi->hba_inquiry = 0;
		cpi->target_sprt = 0;
		cpi->hba_misc = 0;
		cpi->hba_eng_cnt = 0;
		cpi->max_target = UMASS_SCSIID_MAX;	/* one target */
		cpi->max_lun = 0;	/* no LUN's supported */
		cpi->initiator_id = UMASS_SCSIID_HOST;
		strncpy(cpi->sim_vid, "FreeBSD", SIM_IDLEN);
		strncpy(cpi->hba_vid, "USB SCSI", HBA_IDLEN);
		strncpy(cpi->dev_name, cam_sim_name(sim), DEV_IDLEN);
		cpi->unit_number = cam_sim_unit(sim);
		cpi->bus_id = UMASS_SCSI_BUS;
		if (sc) {
			cpi->base_transfer_speed = sc->transfer_speed;
			cpi->max_lun = sc->maxlun;
		}

		cpi->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	case XPT_RESET_DEV:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_RESET_DEV:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_REQ_INPROG;
		umass_reset(sc, umass_cam_cb, (void *) ccb);
		break;
	} 
	case XPT_GET_TRAN_SETTINGS:
	{
		struct ccb_trans_settings *cts = &ccb->cts;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_GET_TRAN_SETTINGS:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		cts->valid = 0;
		cts->flags = 0;		/* no disconnection, tagging */

		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	case XPT_SET_TRAN_SETTINGS:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_SET_TRAN_SETTINGS:.\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
		xpt_done(ccb);
		break;
	}
	case XPT_CALC_GEOMETRY:
	{
		struct ccb_calc_geometry *ccg = &ccb->ccg;

		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_CALC_GEOMETRY: "
			"Volume size = %d\n",
			USBDEVNAME(sc->sc_dev), UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccg->volume_size));

		/* XXX We should probably ask the drive for the details
		 *     instead of cluching them up ourselves
		 */
		if (sc->drive == ZIP_100) {
			ccg->heads = 64;
			ccg->secs_per_track = 32;
			ccg->cylinders = ccg->volume_size / ccg->heads
					  / ccg->secs_per_track;
			ccb->ccb_h.status = CAM_REQ_CMP;
			break;
		} else if (sc->proto & PROTO_UFI) {
			ccg->heads = 2;
			if (ccg->volume_size == 2880)
				ccg->secs_per_track = 18;
			else
				ccg->secs_per_track = 9;
			ccg->cylinders = 80;
			break;
		} else {
			ccb->ccb_h.status = CAM_REQ_CMP_ERR;
		}

		xpt_done(ccb);
		break;
	}
	case XPT_NOOP:
	{
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:XPT_NOOP:.\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun));

		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;
	}
	default:
		DPRINTF(UDMASS_SCSI, ("%s:%d:%d:%d:func_code 0x%04x: "
			"Not implemented\n",
			(sc == NULL? DEVNAME_SIM:USBDEVNAME(sc->sc_dev)),
			UMASS_SCSI_BUS,
			ccb->ccb_h.target_id, ccb->ccb_h.target_lun,
			ccb->ccb_h.func_code));

		ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
		xpt_done(ccb);
		break;
	}
}

/* umass_cam_poll
 *	all requests are handled through umass_cam_action, requests
 *	are never pending. So, nothing to do here.
 */
Static void
umass_cam_poll(struct cam_sim *sim)
{
#ifdef UMASS_DEBUG
	struct umass_softc *sc = (struct umass_softc *) sim->softc;

	DPRINTF(UDMASS_SCSI, ("%s: CAM poll\n",
		USBDEVNAME(sc->sc_dev)));
#endif

	/* nop */
}


/* umass_cam_cb
 *	finalise a completed CAM command
 */

Static void
umass_cam_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	union ccb *ccb = (union ccb *) priv;
	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */

	csio->resid = residue;

	switch (status) {
	case STATUS_CMD_OK:
		ccb->ccb_h.status = CAM_REQ_CMP;
		xpt_done(ccb);
		break;

	case STATUS_CMD_UNKNOWN:
	case STATUS_CMD_FAILED:
		switch (ccb->ccb_h.func_code) {
		case XPT_SCSI_IO:
		{
			unsigned char *cmd;
			int cmdlen;

			/* fetch sense data */
			DPRINTF(UDMASS_SCSI,("%s: Fetching %db sense data\n",
			        USBDEVNAME(sc->sc_dev),
			        sc->cam_scsi_sense.length));

			sc->cam_scsi_sense.length = csio->sense_len;

			if (sc->transform(sc, (char *) &sc->cam_scsi_sense,
				      sizeof(sc->cam_scsi_sense),
				      &cmd, &cmdlen)) {
				sc->transfer(sc, ccb->ccb_h.target_lun,
					     cmd, cmdlen,
					     &csio->sense_data,
					     csio->sense_len, DIR_IN,
					     umass_cam_sense_cb, (void *) ccb);
			} else {
#ifdef UMASS_DEBUG
				panic("transform(REQUEST_SENSE) failed\n");
#else 
				csio->resid = sc->transfer_datalen;
				ccb->ccb_h.status = CAM_REQ_CMP_ERR;
				xpt_done(ccb);
#endif
			}
			break;
		}
		case XPT_RESET_DEV: /* Reset failed */
			ccb->ccb_h.status = CAM_REQ_CMP_ERR;
			xpt_done(ccb);
			break;
		default:
			panic("umass_cam_cb called for func_code %d\n",
			      ccb->ccb_h.func_code);
		}
		break;

	case STATUS_WIRE_FAILED:
		/* the wire protocol failed and will have recovered
		 * (hopefully).	 We return an error to CAM and let CAM retry
		 * the command if necessary.
		 */
		ccb->ccb_h.status = CAM_REQ_CMP_ERR;
		xpt_done(ccb);
		break;

	default:
		panic("%s: Unknown status %d in umass_cam_cb\n",
			USBDEVNAME(sc->sc_dev), status);
	}
}

/* Finalise a completed autosense operation
 */
Static void
umass_cam_sense_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	union ccb *ccb = (union ccb *) priv;
	struct ccb_scsiio *csio = &ccb->csio;		/* deref union */

	switch (status) {
	case STATUS_CMD_OK:
	case STATUS_CMD_UNKNOWN:
		/* Getting sense data succeeded. The length of the sense data
		 * is not returned in any way. The sense data itself contains
		 * the length of the sense data that is valid.
		 */
		if (sc->quirks & RS_NO_CLEAR_UA
		    && csio->cdb_io.cdb_bytes[0] == INQUIRY
		    && (csio->sense_data.flags & SSD_KEY)
						== SSD_KEY_UNIT_ATTENTION) {
			/* Ignore unit attention errors in the case where
			 * the Unit Attention state is not cleared on
			 * REQUEST SENSE. They will appear again at the next
			 * command.
			 */
			ccb->ccb_h.status = CAM_REQ_CMP;
		} else if ((csio->sense_data.flags & SSD_KEY)
						== SSD_KEY_NO_SENSE) {
			/* No problem after all (in the case of CBI without
			 * CCI)
			 */
			ccb->ccb_h.status = CAM_REQ_CMP;
		} else {
			ccb->ccb_h.status = CAM_SCSI_STATUS_ERROR
					    | CAM_AUTOSNS_VALID;
			csio->scsi_status = SCSI_STATUS_CHECK_COND;
		}
		xpt_done(ccb);
		break;

	default:
		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
			USBDEVNAME(sc->sc_dev), status));
		ccb->ccb_h.status = CAM_AUTOSENSE_FAIL;
		xpt_done(ccb);
	}
}


Static int
umass_driver_load(module_t mod, int what, void *arg)
{
	int err;

	switch (what) {
	case MOD_UNLOAD:
		err = umass_cam_detach_sim();
		if (err)
			return(err);
		return(usbd_driver_load(mod, what, arg));
	case MOD_LOAD:
		/* We don't attach to CAM at this point, because it will try
		 * and malloc memory for it. This is not possible when the
		 * boot loader loads umass as a module before the kernel
		 * has been bootstrapped.
		 */
	default:
		return(usbd_driver_load(mod, what, arg));
	}
}



/* (even the comment is missing) */

DRIVER_MODULE(umass, uhub, umass_driver, umass_devclass, umass_driver_load, 0);


/*
 * SCSI specific functions
 */

Static int
umass_scsi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		     unsigned char **rcmd, int *rcmdlen)
{
	*rcmd = cmd;		/* trivial copy */
	*rcmdlen = cmdlen;

	switch (cmd[0]) {
	case TEST_UNIT_READY:
		if (sc->quirks & NO_TEST_UNIT_READY) {
			DPRINTF(UDMASS_SCSI, ("%s: Converted TEST_UNIT_READY "
				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
			cmd[0] = START_STOP_UNIT;
			cmd[4] = SSS_START;
		}
		break;
	}

	return 1;		/* success */
}

/*
 * UFI specific functions
 */

Static int
umass_ufi_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		    unsigned char **rcmd, int *rcmdlen)
{
	*rcmd = cmd;
	/* A UFI command is always 12 bytes in length */
	/* XXX cmd[(cmdlen+1)..12] contains garbage */
	*rcmdlen = 12;

	switch (cmd[0]) {
	case TEST_UNIT_READY:
		if (sc->quirks & NO_TEST_UNIT_READY) {
			DPRINTF(UDMASS_UFI, ("%s: Converted TEST_UNIT_READY "
				"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
			cmd[0] = START_STOP_UNIT;
			cmd[4] = SSS_START;
		}
		return 1;
	case INQUIRY:
	case START_STOP_UNIT:
	case MODE_SENSE:
	case PREVENT_ALLOW:
	case READ_10:
	case READ_12:
	case READ_CAPACITY:
	case REQUEST_SENSE:
	case REZERO_UNIT:
	case POSITION_TO_ELEMENT:	/* SEEK_10 */
	case SEND_DIAGNOSTIC:
	case WRITE_10:
	case WRITE_12:
	/* FORMAT_UNIT */
	/* MODE_SELECT */
	/* READ_FORMAT_CAPACITY */
	/* VERIFY */
	/* WRITE_AND_VERIFY */
		return 1;	/* success */
	default:
		return 0;	/* success */
	}
}

/*
 * 8070 specific functions
 */
Static int
umass_8070_transform(struct umass_softc *sc, unsigned char *cmd, int cmdlen,
		     unsigned char **rcmd, int *rcmdlen)
{
	return 0;	/* failure */
}

#endif /* __FreeBSD__ */

d1721 2
a1722 2
	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmd = %db "
		"(0x%02x%02x%02x%02x%02x%02x%s), "
d1725 3
a1727 1
		c[0], c[1], c[2], c[3], c[4], c[5], (clen > 6? "...":""),
a1775 479
#endif








#if defined(__NetBSD__) || defined(__OpenBSD__)
Static int
umass_scsipi_cmd(xs)
	struct scsipi_xfer *xs;
{
	struct scsipi_link *sc_link = xs->sc_link;
	struct umass_softc *sc = sc_link->adapter_softc;
	struct scsipi_generic *cmd, trcmd;
	int cmdlen;
	int dir;
#ifdef UMASS_DEBUG
	microtime(&sc->tv);
#endif

	memset(&trcmd, 0, sizeof(trcmd));

#if defined(__NetBSD__)
	DIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);
#endif
#if defined(__OpenBSD__)
	DIF(UDMASS_UPPER, sc_link->flags |= SCSIDEBUG_LEVEL);
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
	DPRINTF(UDMASS_CMD, ("%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x "
	    "(quirks=0x%x, poll=%d)\n", USBDEVNAME(sc->sc_dev),
	    SCSI_LINK_TARGET(sc_link), SCSI_LINK_LUN(sc_link),
	    xs, xs->cmd->opcode, sc_link->quirks, 
	    xs->xs_control & XS_CTL_POLL));
#endif

#if defined(USB_DEBUG) && defined(SCSIDEBUG)
	if (umassdebug & UDMASS_SCSI)
		show_scsipi_xs(xs);
	else if (umassdebug & ~UDMASS_CMD)
		show_scsipi_cmd(xs);
#endif

	if (sc->sc_dying) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

#ifdef UMASS_DEBUG
#if defined(__NetBSD__)
	if ((sc_link->type == BUS_ATAPI ? 
	     sc_link->scsipi_atapi.drive : SCSI_LINK_TARGET(sc_link)) 
	    != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: wrong SCSI ID %d\n",
		    USBDEVNAME(sc->sc_dev),
		    SCSI_LINK_TARGET(sc_link)));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif
#if defined(__OpenBSD__)
	if (sc_link->target != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: wrong SCSI ID %d\n",
		    USBDEVNAME(sc->sc_dev),
		    sc_link->target));
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
#endif
#endif

	cmd = xs->cmd;

	if (xs->cmd->opcode == SCSI_MODE_SENSE &&
	    (sc_link->quirks & SDEV_NOMODESENSE)) {
		/*printf("%s: SCSI_MODE_SENSE\n", USBDEVNAME(sc->sc_dev));*/
		xs->error = XS_TIMEOUT;
		goto done;
	}

	if (xs->cmd->opcode == START_STOP &&
	    (sc->quirks & NO_START_STOP)) {
		/*printf("%s: START_STOP\n", USBDEVNAME(sc->sc_dev));*/
		xs->error = XS_NOERROR;
		goto done;
	}

	if (xs->cmd->opcode == INQUIRY &&
	    (sc->quirks & FORCE_SHORT_INQUIRY)) {
       		memcpy(&trcmd, cmd, sizeof trcmd);
		trcmd.bytes[4] = SHORT_INQUIRY_LENGTH;
		cmd = &trcmd;
	}

	dir = DIR_NONE;
	if (xs->datalen) {
		switch (xs->xs_control & (XS_CTL_DATA_IN | XS_CTL_DATA_OUT)) {
		case XS_CTL_DATA_IN:
			dir = DIR_IN;
			break;
		case XS_CTL_DATA_OUT:
			dir = DIR_OUT;
			break;
		}
	}

	if (xs->datalen > UMASS_MAX_TRANSFER_SIZE) {
		printf("umass_cmd: large datalen, %d\n", xs->datalen);
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	cmdlen = xs->cmdlen;
	if (sc->proto & PROTO_UFI) {
		if (!umass_ufi_transform(sc, cmd, cmdlen, &trcmd, &cmdlen)) {
			xs->error = XS_DRIVER_STUFFUP;
			goto done;
		}
		cmd= &trcmd;
	}

	if (sc->proto & PROTO_ATAPI) {
		bcopy(cmd, &trcmd, cmdlen);
		cmd = &trcmd;
		cmdlen = ATAPI_COMMAND_LENGTH;
	}

	if (xs->xs_control & XS_CTL_POLL) {
		/* Use sync transfer. XXX Broken! */
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: sync dir=%d\n", dir));
		sc->sc_xfer_flags = USBD_SYNCHRONOUS;
		sc->sc_sync_status = USBD_INVAL;
		sc->transfer(sc, SCSI_LINK_LUN(sc_link), cmd, cmdlen,
			     xs->data, xs->datalen, dir, 0, xs);
		sc->sc_xfer_flags = 0;
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n", 
				      sc->sc_sync_status));
		switch (sc->sc_sync_status) {
		case USBD_NORMAL_COMPLETION:
			xs->error = XS_NOERROR;
			break;
		case USBD_TIMEOUT:
			xs->error = XS_TIMEOUT;
			break;
		default:
			xs->error = XS_DRIVER_STUFFUP;
			break;
		}
		goto done;
	} else {
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: async dir=%d, cmdlen=%d"
				      " datalen=%d\n",
				      dir, cmdlen, xs->datalen));
		sc->transfer(sc, SCSI_LINK_LUN(sc_link), cmd, cmdlen,
		    xs->data, xs->datalen, dir, umass_scsipi_cb, xs);
		return (SUCCESSFULLY_QUEUED);
	}

	/* Return if command finishes early. */
 done:
#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif
	
	scsipi_done(xs);
	if (xs->xs_control & XS_CTL_POLL)
		return (COMPLETE);
	else
		return (SUCCESSFULLY_QUEUED);
}

Static void
umass_scsipi_minphys(bp)
	struct buf *bp;
{
	if (bp->b_bcount > UMASS_MAX_TRANSFER_SIZE)
		bp->b_bcount = UMASS_MAX_TRANSFER_SIZE;
	minphys(bp);
}

int
umass_scsipi_ioctl(link, cmd, arg, flag, p)
	struct scsipi_link *link;
	u_long cmd;
	caddr_t arg;
	int flag;
	struct proc *p;
{
	/*struct umass_softc *sc = link->adapter_softc;*/

	switch (cmd) {
#if 0
	case SCBUSIORESET:
		ccb->ccb_h.status = CAM_REQ_INPROG;
		umass_reset(sc, umass_cam_cb, (void *) ccb);
		return (0);
#endif
	default:
		return (ENOTTY);
	}
}

Static void
umass_scsipi_cb(struct umass_softc *sc, void *priv, int residue, int status)
{
	struct scsipi_xfer *xs = priv;
	struct scsipi_link *sc_link = xs->sc_link;
	int cmdlen;
	int s;
#ifdef UMASS_DEBUG
	struct timeval tv;
	u_int delta;
	microtime(&tv);
	delta = (tv.tv_sec - sc->tv.tv_sec) * 1000000 + tv.tv_usec - sc->tv.tv_usec;
#endif
	
	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: at %lu.%06lu, delta=%u: xs=%p residue=%d"
	    " status=%d\n", tv.tv_sec, tv.tv_usec, delta, xs, residue, status));
	xs->resid = residue;

	switch (status) {
	case STATUS_CMD_OK:
		xs->error = XS_NOERROR;
		break;

	case STATUS_CMD_UNKNOWN:
	case STATUS_CMD_FAILED:
		/* fetch sense data */
		memset(&sc->sc_sense_cmd, 0, sizeof(sc->sc_sense_cmd));
		sc->sc_sense_cmd.opcode = REQUEST_SENSE;
		sc->sc_sense_cmd.byte2 = SCSI_LINK_LUN(sc_link) <<
		    SCSI_CMD_LUN_SHIFT;
		sc->sc_sense_cmd.length = sizeof(xs->sense);

		cmdlen = sizeof(sc->sc_sense_cmd);
		if (sc->proto & PROTO_UFI)
			cmdlen = UFI_COMMAND_LENGTH;
		else if (sc->proto & PROTO_ATAPI)
			cmdlen = ATAPI_COMMAND_LENGTH;

		sc->transfer(sc, SCSI_LINK_LUN(sc_link),
			     &sc->sc_sense_cmd, cmdlen,
			     &xs->sense, sizeof(xs->sense), DIR_IN,
			     umass_scsipi_sense_cb, xs);
		return;

	case STATUS_WIRE_FAILED:
		xs->error = XS_RESET;
		break;

	default:
		panic("%s: Unknown status %d in umass_scsipi_cb\n",
			USBDEVNAME(sc->sc_dev), status);
	}

#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif

	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: at %lu.%06lu: return xs->error="
            "%d, xs->xs_status=0x%x xs->resid=%d\n",
	     tv.tv_sec, tv.tv_usec,
	     xs->error, xs->xs_status, xs->resid));

	s = splbio();
	scsipi_done(xs);
	splx(s);
}

/* 
 * Finalise a completed autosense operation
 */
Static void
umass_scsipi_sense_cb(struct umass_softc *sc, void *priv, int residue,
		      int status)
{
	struct scsipi_xfer *xs = priv;
	int s;
	int bytes_received;

	DPRINTF(UDMASS_CMD,("umass_scsipi_sense_cb: xs=%p residue=%d "
	    "status=%d\n", xs, residue, status));

	switch (status) {
	case STATUS_CMD_OK:
	case STATUS_CMD_UNKNOWN:
		/* getting sense data succeeded */
		if ((xs->cmd->opcode == INQUIRY)
		    && (xs->resid < xs->datalen)) {
			/* Some drivers return SENSE errors even after INQUIRY
			 * The upper layer doesn't like that.
			 */
			xs->error = XS_NOERROR;
			break;
		}

		bytes_received = sizeof(xs->sense) - residue;

		if (bytes_received < 8 || 
		    (bytes_received < xs->sense.extra_len + 8)) 
			xs->error = XS_SHORTSENSE;
	        else
			xs->error = XS_SENSE;

#if defined(__OpenBSD__)
		/* Note that this test may need to be revised
		   with QIC-157a/SCSI tape drives that return
		   ILI, EOM in the high bits of flags.
	         */
		if ((xs->sense.error_code & SSD_ERRCODE) == 0x70 &&
		    (xs->sense.flags == 0))
			xs->error = XS_NOERROR;
#endif
		
		break;
	default:
		DPRINTF(UDMASS_SCSI, ("%s: Autosense failed, status %d\n",
			USBDEVNAME(sc->sc_dev), status));
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

#if defined(__NetBSD__)
	xs->xs_status |= XS_STS_DONE;
#endif
#if defined(__OpenBSD__)
	xs->flags |= ITSDONE;
#endif

	DPRINTF(UDMASS_CMD,("umass_scsipi_sense_cb: return xs->error=%d, "
		"xs->xs_status=0x%x xs->resid=%d\n", xs->error, xs->xs_status,
		xs->resid));

	s = splbio();
	scsipi_done(xs);
	splx(s);
}

/*
 * UFI specific functions
 */

Static int
umass_ufi_transform(struct umass_softc *sc, struct scsipi_generic *cmd, 
		    int cmdlen, struct scsipi_generic *rcmd, int *rcmdlen)
{
	*rcmdlen = UFI_COMMAND_LENGTH;
	memset(rcmd, 0, sizeof *rcmd);

	/* Handle any quirks */
	if (cmd->opcode == TEST_UNIT_READY
	    && (sc->quirks & NO_TEST_UNIT_READY)) {
		/*
		 * Some devices do not support this command.
		 * Start Stop Unit should give the same results
		 */
		DPRINTF(UDMASS_UFI, ("%s: Converted TEST_UNIT_READY "
			"to START_UNIT\n", USBDEVNAME(sc->sc_dev)));
		rcmd->opcode = START_STOP;
		rcmd->bytes[3] = SSS_START;
		return 1;
	} 

	switch (cmd->opcode) {
	/* Commands of which the format has been verified. They should work. */
	case TEST_UNIT_READY:
	case SCSI_REZERO_UNIT:
	case REQUEST_SENSE:
	case INQUIRY:
	case START_STOP:
	/*case SEND_DIAGNOSTIC: ??*/
	case PREVENT_ALLOW:
	case READ_CAPACITY:
	case READ_BIG:
	case WRITE_BIG:
	case POSITION_TO_ELEMENT:	/* SEEK_10 */
	case SCSI_MODE_SELECT_BIG:
	case SCSI_MODE_SENSE_BIG:
	default:
		/* Copy the command into the (zeroed out) destination buffer */
		memcpy(rcmd, cmd, cmdlen);
		return (1);	/* success */

	/* 
	 * Other UFI commands: FORMAT_UNIT, MODE_SELECT, READ_FORMAT_CAPACITY,
	 * VERIFY, WRITE_AND_VERIFY.
	 * These should be checked whether they somehow can be made to fit.
	 */

	/* These commands are known _not_ to work. They should be converted. */
	case SCSI_READ_COMMAND:
	case SCSI_WRITE_COMMAND:
	case SCSI_MODE_SENSE:
	case SCSI_MODE_SELECT:
		printf("%s: Unsupported UFI command 0x%02x",
			USBDEVNAME(sc->sc_dev), cmd->opcode);
		if (cmdlen == 6)
			printf(", 6 byte command should have been converted");
		printf("\n");
		return (0);	/* failure */
	}
}


#if NATAPIBUS > 0
Static void
umass_atapi_probedev(atapi, target)
	struct atapibus_softc *atapi;
	int target;
{
	struct scsipi_link *sc_link;
	struct scsipibus_attach_args sa;
	struct ata_drive_datas *drvp = &atapi->sc_drvs[target];
	char vendor[33], product[65], revision[17];
	struct scsipi_inquiry_data inqbuf;

	DPRINTF(UDMASS_SCSI,("umass_atapi_probedev: atapi=%p target=%d\n",
			     atapi, target));

	if (atapi->sc_link[target])
		return;

	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT); 
	if (sc_link == NULL) {
		printf("%s: can't allocate link for drive %d\n",
		       atapi->sc_dev.dv_xname, target);
		return;       
	}
	*sc_link = *atapi->adapter_link;

	DIF(UDMASS_UPPER, sc_link->flags |= DEBUGLEVEL);

	/* Fill generic parts of the link. */
	sc_link->active = 0;
	sc_link->scsipi_atapi.drive = target;
	sc_link->device = &umass_dev;
	TAILQ_INIT(&sc_link->pending_xfers);

	DPRINTF(UDMASS_SCSI, ("umass_atapi_probedev: doing inquiry\n"));
	/* Now go ask the device all about itself. */
	memset(&inqbuf, 0, sizeof(inqbuf));
	if (scsipi_inquire(sc_link, &inqbuf, XS_CTL_DISCOVERY) != 0)
		goto bad;

	scsipi_strvis(vendor, 33, inqbuf.vendor, 8);
	scsipi_strvis(product, 65, inqbuf.product, 16);
	scsipi_strvis(revision, 17, inqbuf.revision, 4);

	sa.sa_sc_link = sc_link;
	sa.sa_inqbuf.type = inqbuf.device;
	sa.sa_inqbuf.removable = inqbuf.dev_qual2 & SID_REMOVABLE ?
	    T_REMOV : T_FIXED;
	if (sa.sa_inqbuf.removable)
		sc_link->flags |= SDEV_REMOVABLE;
	/* XXX how? sc_link->scsipi_atapi.cap |= ACAP_LEN;*/
	sa.sa_inqbuf.vendor = vendor;
	sa.sa_inqbuf.product = product;
	sa.sa_inqbuf.revision = revision;
	sa.sa_inqptr = NULL;

	drvp->drv_softc = atapi_probedev(atapi, target, sc_link, &sa);
	/* atapi_probedev() frees the scsipi_link when there is no device. */
	return;

bad:
	free(sc_link, M_DEVBUF);
	return;
}
#endif
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.12 2001/09/25 16:13:39 drahn Exp $ */
d1479 1
a1479 1
		USBDEVNAME(sc->sc_dev), *(u_char*)cmd));
d1966 1
a1966 1
		USBDEVNAME(sc->sc_dev), *(u_char*)cmd, datalen));
@


1.12
log
@Change to umass to not attach immediately if the system is still 'cold'.
Accessing the device via polling would cause a crash in the usb subsystem.
this change delays the media configuration using startuphooks, when
the system is fully up and running. This allows it to configure properly
and on macppc it is possible to use a umass device as root device.
Has little effect on other system, because they do not force USB configuration
during 'cold'. Tested by myself and brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.11 2001/05/24 06:21:44 csapuntz Exp $ */
d305 2
a306 2
typedef void (*transfer_cb_f)	__P((struct umass_softc *sc, void *priv,
				int residue, int status));
d312 2
a313 2
typedef void (*wire_reset_f)	__P((struct umass_softc *sc, int status));
typedef void (*wire_transfer_f) __P((struct umass_softc *sc, int lun,
d315 3
a317 3
				int dir, transfer_cb_f cb, void *priv));
typedef void (*wire_state_f)	__P((usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err));
d320 1
a320 1
typedef int (*command_transform_f)	__P((struct umass_softc *sc,
d322 1
a322 1
				unsigned char **rcmd, int *rcmdlen));
d547 2
a548 2
Static void umass_disco		__P((struct umass_softc *sc));
Static int umass_match_proto	__P((struct umass_softc *sc,
d550 2
a551 2
				usbd_device_handle dev));
Static void umass_init_shuttle	__P((struct umass_softc *sc));
d554 1
a554 1
Static usbd_status umass_setup_transfer __P((struct umass_softc *sc,
d557 2
a558 2
				usbd_xfer_handle xfer));
Static usbd_status umass_setup_ctrl_transfer	__P((struct umass_softc *sc,
d562 2
a563 2
				usbd_xfer_handle xfer));
Static void umass_clear_endpoint_stall	__P((struct umass_softc *sc,
d565 1
a565 1
				int state, usbd_xfer_handle xfer));
d567 2
a568 2
Static void umass_reset		__P((struct umass_softc *sc,
				transfer_cb_f cb, void *priv));
d572 2
a573 2
Static void umass_bbb_reset	__P((struct umass_softc *sc, int status));
Static void umass_bbb_transfer	__P((struct umass_softc *sc, int lun,
d576 2
a577 2
				transfer_cb_f cb, void *priv));
Static void umass_bbb_state	__P((usbd_xfer_handle xfer,
d579 3
a581 3
				usbd_status err));
usbd_status umass_bbb_get_max_lun __P((struct umass_softc *sc,
				       u_int8_t *maxlun));
d585 4
a588 4
Static int umass_cbi_adsc	__P((struct umass_softc *sc, char *buffer,int buflen,
				usbd_xfer_handle xfer));
Static void umass_cbi_reset	__P((struct umass_softc *sc, int status));
Static void umass_cbi_transfer	__P((struct umass_softc *sc, int lun,
d591 3
a593 3
				transfer_cb_f cb, void *priv));
Static void umass_cbi_state	__P((usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err));
d597 2
a598 2
Static void umass_cam_action	__P((struct cam_sim *sim, union ccb *ccb));
Static void umass_cam_poll	__P((struct cam_sim *sim));
d600 4
a603 4
Static void umass_cam_cb	__P((struct umass_softc *sc, void *priv,
				int residue, int status));
Static void umass_cam_sense_cb	__P((struct umass_softc *sc, void *priv,
				int residue, int status));
d606 1
a606 1
Static void umass_cam_rescan	__P((struct umass_softc *sc));
d609 4
a612 4
Static int umass_cam_attach_sim __P((void));
Static int umass_cam_attach	__P((struct umass_softc *sc));
Static int umass_cam_detach_sim __P((void));
Static int umass_cam_detach	__P((struct umass_softc *sc));
d631 8
a638 8
Static int umass_scsipi_cmd __P((struct scsipi_xfer *xs));
Static void umass_scsipi_minphys __P((struct buf *bp));
Static int umass_scsipi_ioctl __P((struct scsipi_link *, u_long,
				   caddr_t, int, struct proc *));
Static void umass_scsipi_cb	__P((struct umass_softc *sc, void *priv,
				     int residue, int status));
Static void umass_scsipi_sense_cb __P((struct umass_softc *sc, void *priv,
				       int residue, int status));
d640 2
a641 2
Static int scsipiprint __P((void *aux, const char *pnp));
Static int umass_ufi_transform __P((struct umass_softc *sc,
d643 1
a643 1
    struct scsipi_generic *rcmd, int *rcmdlen));
d646 1
a646 1
Static void umass_atapi_probedev __P((struct atapibus_softc *, int));
d652 1
a652 1
Static int umass_scsi_transform __P((struct umass_softc *sc,
d654 1
a654 1
				unsigned char **rcmd, int *rcmdlen));
d657 1
a657 1
Static int umass_ufi_transform	__P((struct umass_softc *sc,
d659 1
a659 1
				unsigned char **rcmd, int *rcmdlen));
d662 1
a662 1
Static int umass_8070_transform __P((struct umass_softc *sc,
d664 1
a664 1
				unsigned char **rcmd, int *rcmdlen));
d669 6
a674 6
Static void umass_bbb_dump_cbw	__P((struct umass_softc *sc,
				umass_bbb_cbw_t *cbw));
Static void umass_bbb_dump_csw	__P((struct umass_softc *sc,
				umass_bbb_csw_t *csw));
Static void umass_dump_buffer	__P((struct umass_softc *sc, u_int8_t *buffer,
				int buflen, int printlen));
d1194 1
a1194 1
	extern int atapi_print __P((void *aux, const char *pnp));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.12 2001/09/25 16:13:39 drahn Exp $ */
d305 2
a306 2
typedef void (*transfer_cb_f)(struct umass_softc *sc, void *priv,
				int residue, int status);
d312 2
a313 2
typedef void (*wire_reset_f)(struct umass_softc *sc, int status);
typedef void (*wire_transfer_f)(struct umass_softc *sc, int lun,
d315 3
a317 3
				int dir, transfer_cb_f cb, void *priv);
typedef void (*wire_state_f)(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);
d320 1
a320 1
typedef int (*command_transform_f)(struct umass_softc *sc,
d322 1
a322 1
				unsigned char **rcmd, int *rcmdlen);
d547 2
a548 2
Static void umass_disco(struct umass_softc *sc);
Static int umass_match_proto(struct umass_softc *sc,
d550 2
a551 2
				usbd_device_handle dev);
Static void umass_init_shuttle(struct umass_softc *sc);
d554 1
a554 1
Static usbd_status umass_setup_transfer(struct umass_softc *sc,
d557 2
a558 2
				usbd_xfer_handle xfer);
Static usbd_status umass_setup_ctrl_transfer(struct umass_softc *sc,
d562 2
a563 2
				usbd_xfer_handle xfer);
Static void umass_clear_endpoint_stall(struct umass_softc *sc,
d565 1
a565 1
				int state, usbd_xfer_handle xfer);
d567 2
a568 2
Static void umass_reset(struct umass_softc *sc,
				transfer_cb_f cb, void *priv);
d572 2
a573 2
Static void umass_bbb_reset(struct umass_softc *sc, int status);
Static void umass_bbb_transfer(struct umass_softc *sc, int lun,
d576 2
a577 2
				transfer_cb_f cb, void *priv);
Static void umass_bbb_state(usbd_xfer_handle xfer,
d579 3
a581 3
				usbd_status err);
usbd_status umass_bbb_get_max_lun(struct umass_softc *sc,
				       u_int8_t *maxlun);
d585 4
a588 4
Static int umass_cbi_adsc(struct umass_softc *sc, char *buffer,int buflen,
				usbd_xfer_handle xfer);
Static void umass_cbi_reset(struct umass_softc *sc, int status);
Static void umass_cbi_transfer(struct umass_softc *sc, int lun,
d591 3
a593 3
				transfer_cb_f cb, void *priv);
Static void umass_cbi_state(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);
d597 2
a598 2
Static void umass_cam_action(struct cam_sim *sim, union ccb *ccb);
Static void umass_cam_poll(struct cam_sim *sim);
d600 4
a603 4
Static void umass_cam_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
Static void umass_cam_sense_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
d606 1
a606 1
Static void umass_cam_rescan(struct umass_softc *sc);
d609 4
a612 4
Static int umass_cam_attach_sim(void);
Static int umass_cam_attach(struct umass_softc *sc);
Static int umass_cam_detach_sim(void);
Static int umass_cam_detach(struct umass_softc *sc);
d631 8
a638 8
Static int umass_scsipi_cmd(struct scsipi_xfer *xs);
Static void umass_scsipi_minphys(struct buf *bp);
Static int umass_scsipi_ioctl(struct scsipi_link *, u_long,
				   caddr_t, int, struct proc *);
Static void umass_scsipi_cb(struct umass_softc *sc, void *priv,
				     int residue, int status);
Static void umass_scsipi_sense_cb(struct umass_softc *sc, void *priv,
				       int residue, int status);
d640 2
a641 2
Static int scsipiprint(void *aux, const char *pnp);
Static int umass_ufi_transform(struct umass_softc *sc,
d643 1
a643 1
    struct scsipi_generic *rcmd, int *rcmdlen);
d646 1
a646 1
Static void umass_atapi_probedev(struct atapibus_softc *, int);
d652 1
a652 1
Static int umass_scsi_transform(struct umass_softc *sc,
d654 1
a654 1
				unsigned char **rcmd, int *rcmdlen);
d657 1
a657 1
Static int umass_ufi_transform(struct umass_softc *sc,
d659 1
a659 1
				unsigned char **rcmd, int *rcmdlen);
d662 1
a662 1
Static int umass_8070_transform(struct umass_softc *sc,
d664 1
a664 1
				unsigned char **rcmd, int *rcmdlen);
d669 6
a674 6
Static void umass_bbb_dump_cbw(struct umass_softc *sc,
				umass_bbb_cbw_t *cbw);
Static void umass_bbb_dump_csw(struct umass_softc *sc,
				umass_bbb_csw_t *csw);
Static void umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer,
				int buflen, int printlen);
d1194 1
a1194 1
	extern int atapi_print(void *aux, const char *pnp);
d1479 1
a1479 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd));
d1966 1
a1966 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd, datalen));
@


1.12.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.12.4.1 2002/06/11 03:42:30 art Exp $ */
d240 1
a240 1
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
d314 1
a314 1
				void *cmd, int cmdlen, void *data, int datalen,
d403 1
a403 1

d408 1
a408 1
	umass_cbi_cbl_t		cbl;	/* command block */
d430 1
a430 1

d449 1
a449 1
	int			transfer_actlen;	/* actual length */
d561 1
a561 1
				void *buffer, int buflen, int flags,
a727 6
	if (vendor == USB_VENDOR_TRUMPION &&
	    product == USB_PRODUCT_TRUMPION_XXX1100) {
		sc->proto = PROTO_ATAPI | PROTO_CBI;
		return (UMATCH_VENDOR_PRODUCT);
	}

d783 1
a783 1
		/*
d798 1
a798 1

d951 1
a951 1
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sSubclass,
d1044 1
a1044 1
	/*
d1091 1
a1091 1
		sc->data_buffer = usbd_alloc_buffer(sc->transfer_xfer[bno],
d1113 1
a1113 1
		panic("%s:%d: Unknown proto 0x%02x",
d1126 1
a1126 1

d1141 1
a1141 1
		sc->u.sc_link.adapter_target = UMASS_SCSIID_HOST;
d1155 1
a1155 1
		printf("%s: proto=0x%x not supported yet\n",
d1286 1
a1286 1
{
d1455 1
a1455 1

d1493 1
a1493 1
	 * machine in umass_bbb_state handle the completion. It uses the
d1635 1
a1635 1
			memcpy(sc->data_buffer, sc->transfer_data,
d1709 1
a1709 1

d1795 1
a1795 1

d1801 1
a1801 1
			panic("%s: transferred %d bytes instead of %d bytes",
d1804 1
a1804 1
		}
d1879 1
a1879 1
		panic("%s: Unknown state %d",
d1923 1
a1923 1
	 *
d1937 1
a1937 1

d1983 1
a1983 1
	 * machine in umass_cbi_state handle the completion. It uses the
d2065 1
a2065 1

d2075 1
a2075 1
			memcpy(sc->data_buffer, sc->transfer_data,
d2179 1
a2179 1

d2287 1
a2287 1
		panic("%s: Unknown state %d",
d2467 1
a2467 1

d2710 1
a2710 1
	}
d2857 2
a2858 2
				panic("transform(REQUEST_SENSE) failed");
#else
d2871 1
a2871 1
			panic("umass_cam_cb called for func_code %d",
d2886 1
a2886 1
		panic("%s: Unknown status %d in umass_cam_cb",
d3151 1
a3151 1
	    xs, xs->cmd->opcode, sc_link->quirks,
d3169 2
a3170 2
	if ((sc_link->type == BUS_ATAPI ?
	     sc_link->scsipi_atapi.drive : SCSI_LINK_TARGET(sc_link))
d3254 1
a3254 1
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n",
d3285 1
a3285 1

d3337 1
a3337 1

d3373 1
a3373 1
		panic("%s: Unknown status %d in umass_scsipi_cb",
d3394 1
a3394 1
/*
d3423 2
a3424 2
		if (bytes_received < 8 ||
		    (bytes_received < xs->sense.extra_len + 8))
d3438 1
a3438 1

d3468 1
a3468 1
umass_ufi_transform(struct umass_softc *sc, struct scsipi_generic *cmd,
d3486 1
a3486 1
	}
d3508 1
a3508 1
	/*
d3547 1
a3547 1
	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT);
d3551 1
a3551 1
		return;
@


1.12.4.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umass.c,v 1.96 2003/04/26 12:46:59 dsainty Exp $	*/
d33 1
a33 1
 * Universal Serial Bus Mass Storage Class specs:
d42 1
a42 1
 * Parts of the code written by Jason R. Thorpe <thorpej@@shagadelic.org>.
d54 2
a55 2
 * - 8070 (ATA/ATAPI for rewritable removable media)
 * - UFI (USB Floppy Interface)
d57 4
a60 5
 * 8070i is a transformed version of the SCSI command set. UFI is a transformed
 * version of the 8070i command set.  The sc->transform method is used to
 * convert the commands into the appropriate format (if at all necessary).
 * For example, ATAPI requires all commands to be 12 bytes in length amongst
 * other things.
d96 6
a101 1
#if defined(__NetBSD__)
a102 3
#include "scsibus.h"
#elif defined(__OpenBSD__)
#include "atapiscsi.h"
a104 2
#include "wd.h"

d112 1
d127 26
a152 3
#include <dev/usb/umassvar.h>
#include <dev/usb/umass_quirks.h>
#include <dev/usb/umass_scsi.h>
d154 15
d171 15
d187 328
d516 1
d541 4
d548 4
d559 1
d563 3
a565 2
Static void umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
				usbd_xfer_handle xfer);
d567 2
a568 1
Static void umass_reset(struct umass_softc *sc,	transfer_cb_f cb, void *priv);
d572 10
a581 4
Static void umass_bbb_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
Static void umass_bbb_reset(struct umass_softc *, int);
Static void umass_bbb_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
a582 1
usbd_status umass_bbb_get_max_lun(struct umass_softc *, u_int8_t *);
d585 44
a628 11
Static void umass_cbi_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
Static void umass_cbi_reset(struct umass_softc *, int);
Static void umass_cbi_state(usbd_xfer_handle, usbd_private_handle, usbd_status);

Static int umass_cbi_adsc(struct umass_softc *, char *, int, usbd_xfer_handle);

const struct umass_wire_methods umass_bbb_methods = {
	umass_bbb_transfer,
	umass_bbb_reset,
	umass_bbb_state
d631 35
a665 5
const struct umass_wire_methods umass_cbi_methods = {
	umass_cbi_transfer,
	umass_cbi_reset,
	umass_cbi_state
};
d678 2
d684 11
a694 1
USB_MATCH(umass)
d696 1
a696 2
	USB_MATCH_START(umass, uaa);
	const struct umass_quirk *quirk;
d698 1
d700 75
a774 2
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
d776 7
a782 3
	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL)
		return (quirk->uq_match);
d784 1
a784 1
	id = usbd_get_interface_descriptor(uaa->iface);
d788 25
a812 2
	switch (id->bInterfaceSubClass) {
	case UISUBCLASS_RBC:
d814 1
d816 4
a819 3
	case UISUBCLASS_UFI:
	case UISUBCLASS_SFF8070I:
	case UISUBCLASS_SCSI:
d822 6
a827 1
		return (UMATCH_IFACECLASS);
d830 4
a833 1
	switch (id->bInterfaceProtocol) {
d835 6
a840 2
	case UIPROTO_MASS_CBI:
	case UIPROTO_MASS_BBB_OLD:
d842 7
d851 3
a853 1
		return (UMATCH_IFACECLASS_IFACESUBCLASS);
d856 18
a873 1
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
d876 2
a880 1
	const struct umass_quirk *quirk;
d883 1
a883 1
	const char *sWire, *sCommand;
d885 7
a891 2
	usbd_status err;
	int i, bno, error;
d893 1
a893 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d896 2
a897 19
	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_ifaceno = uaa->ifaceno;

	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL) {
		sc->sc_wire = quirk->uq_wire;
		sc->sc_cmd = quirk->uq_cmd;
		sc->sc_quirks = quirk->uq_flags;
		sc->sc_busquirks = quirk->uq_busquirks;

		if (quirk->uq_fixup != NULL)
			(*quirk->uq_fixup)(sc);
	} else {
		sc->sc_wire = UMASS_WPROTO_UNSPEC;
		sc->sc_cmd = UMASS_CPROTO_UNSPEC;
		sc->sc_quirks = 0;
		sc->sc_busquirks = 0;
	}
d899 3
a901 2
	id = usbd_get_interface_descriptor(sc->sc_iface);
	if (id == NULL)
a902 20

	if (sc->sc_wire == UMASS_WPROTO_UNSPEC) {
		switch (id->bInterfaceProtocol) {
		case UIPROTO_MASS_CBI:
			sc->sc_wire = UMASS_WPROTO_CBI;
			break;
		case UIPROTO_MASS_CBI_I:
			sc->sc_wire = UMASS_WPROTO_CBI_I;
			break;
		case UIPROTO_MASS_BBB:
		case UIPROTO_MASS_BBB_OLD:
			sc->sc_wire = UMASS_WPROTO_BBB;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported wire protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceProtocol));
			USB_ATTACH_ERROR_RETURN;
		}
d905 8
a912 28
	/* XXX - Now unsupported CBI with CCI */
	if (sc->sc_wire == UMASS_WPROTO_CBI_I)
		sc->sc_wire = UMASS_WPROTO_CBI;

	if (sc->sc_cmd == UMASS_CPROTO_UNSPEC) {
		switch (id->bInterfaceSubClass) {
		case UISUBCLASS_SCSI:
			sc->sc_cmd = UMASS_CPROTO_SCSI;
			break;
		case UISUBCLASS_UFI:
			sc->sc_cmd = UMASS_CPROTO_UFI;
			break;
		case UISUBCLASS_SFF8020I:
		case UISUBCLASS_SFF8070I:
		case UISUBCLASS_QIC157:
			sc->sc_cmd = UMASS_CPROTO_ATAPI;
			break;
		case UISUBCLASS_RBC:
			sc->sc_cmd = UMASS_CPROTO_RBC;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported command protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceSubClass));
			USB_ATTACH_ERROR_RETURN;
		}
	}
d914 1
d917 12
a928 3
	switch (sc->sc_wire) {
	case UMASS_WPROTO_CBI:
		sWire = "CBI";
d930 2
a931 2
	case UMASS_WPROTO_CBI_I:
		sWire = "CBI with CCI";
d933 2
a934 2
	case UMASS_WPROTO_BBB:
		sWire = "Bulk-Only";
d937 1
a937 1
		sWire = "unknown";
d940 3
a942 4

	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
		sCommand = "RBC";
d944 2
a945 2
	case UMASS_CPROTO_SCSI:
		sCommand = "SCSI";
d947 2
a948 5
	case UMASS_CPROTO_UFI:
		sCommand = "UFI";
		break;
	case UMASS_CPROTO_ATAPI:
		sCommand = "ATAPI";
d950 2
a951 2
	case UMASS_CPROTO_ISD_ATA:
		sCommand = "ISD-ATA";
d954 1
a954 1
		sCommand = "unknown";
d957 2
d960 10
a969 2
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sCommand,
	       sWire);
d983 2
a984 2
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
d991 1
a991 1
			sc->sc_epaddr[UMASS_BULKIN] = ed->bEndpointAddress;
d994 2
a995 2
			sc->sc_epaddr[UMASS_BULKOUT] = ed->bEndpointAddress;
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I
d998 1
a998 1
			sc->sc_epaddr[UMASS_INTRIN] = ed->bEndpointAddress;
d1010 6
a1015 7
	if (!sc->sc_epaddr[UMASS_BULKIN] || !sc->sc_epaddr[UMASS_BULKOUT] ||
	    (sc->sc_wire == UMASS_WPROTO_CBI_I &&
	     !sc->sc_epaddr[UMASS_INTRIN])) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %u/%u/%u\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN],
			sc->sc_epaddr[UMASS_BULKOUT],
			sc->sc_epaddr[UMASS_INTRIN]));
d1022 1
a1022 2
	if (sc->sc_wire == UMASS_WPROTO_BBB &&
	    !(sc->sc_quirks & UMASS_QUIRK_NO_MAX_LUN)) {
d1034 2
a1035 3
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKOUT],
				USBD_EXCLUSIVE_USE,
				&sc->sc_pipe[UMASS_BULKOUT]);
d1037 2
a1038 2
		DPRINTF(UDMASS_USB, ("%s: cannot open %u-out pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKOUT]));
d1042 2
a1043 2
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_BULKIN]);
d1045 2
a1046 2
		DPRINTF(UDMASS_USB, ("%s: could not open %u-in pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN]));
d1062 3
a1064 3
	if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_INTRIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_INTRIN]);
d1066 2
a1067 3
			DPRINTF(UDMASS_USB, ("%s: couldn't open %u-in (intr)\n",
				USBDEVNAME(sc->sc_dev),
				sc->sc_epaddr[UMASS_INTRIN]));
d1079 1
a1079 1
		if (sc->transfer_xfer[i] == NULL) {
d1087 2
a1088 2
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
d1091 1
a1091 1
	case UMASS_WPROTO_CBI:
d1094 1
a1094 1
	case UMASS_WPROTO_CBI_I:
d1109 13
a1121 11
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
		sc->sc_methods = &umass_bbb_methods;
		break;
	case UMASS_WPROTO_CBI:
	case UMASS_WPROTO_CBI_I:
		sc->sc_methods = &umass_cbi_methods;
		break;
	default:
		umass_disco(sc);
		USB_ATTACH_ERROR_RETURN;
d1124 8
a1131 7
	if (quirk != NULL && quirk->uq_init != NULL) {
		err = (*quirk->uq_init)(sc);
		if (err) {
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
		}
	}
d1133 21
a1153 10
	error = 0;
	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
	case UMASS_CPROTO_SCSI:
#if defined(__OpenBSD__) || NSCSIBUS > 0
		error = umass_scsi_attach(sc);
#else
		printf("%s: scsibus not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1155 2
a1156 8
	case UMASS_CPROTO_UFI:
	case UMASS_CPROTO_ATAPI:
#if (NATAPIBUS > 0) || (NATAPISCSI > 0)
		error = umass_atapi_attach(sc);
#else
		printf("%s: "UMASS_ATAPISTR" not configured\n",
		       USBDEVNAME(sc->sc_dev));
#endif
a1158 7
	case UMASS_CPROTO_ISD_ATA:
#if defined (__NetBSD__) && NWD > 0
		error = umass_isdata_attach(sc);
#else
		printf("%s: isdata not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1161 2
a1162 2
		printf("%s: command protocol=0x%x not supported\n",
		       USBDEVNAME(sc->sc_dev), sc->sc_cmd);
d1166 19
a1184 2
	if (error) {
		printf("%s: bus attach failed\n", USBDEVNAME(sc->sc_dev));
d1186 2
a1187 1
		USB_ATTACH_ERROR_RETURN;
d1192 1
d1194 16
a1209 3
	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
d1215 1
a1215 2
	struct umassbus_softc *scbus = sc->bus;
	int rv = 0, i, s;
d1220 6
a1225 4
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL)
			usbd_abort_pipe(sc->sc_pipe[i]);
	}
d1227 1
a1230 3
#ifdef DIAGNOSTIC
		printf("%s: waiting for refcnt\n", USBDEVNAME(sc->sc_dev));
#endif
d1235 1
d1237 11
a1247 8
	if (scbus != NULL) {
		if (scbus->sc_child != NULL)
			rv = config_detach(scbus->sc_child, flags);
		free(scbus, M_DEVBUF);
		sc->bus = NULL;
	}

	if (rv != 0)
d1255 1
a1255 1
	return (rv);
d1258 1
d1260 3
a1262 1
umass_activate(struct device *dev, enum devact act)
d1264 1
a1264 2
	struct umass_softc *sc = (struct umass_softc *)dev;
	struct umassbus_softc *scbus = sc->bus;
d1276 1
a1276 2
		sc->sc_dying = 1;
		if (scbus == NULL || scbus->sc_child == NULL)
d1278 1
a1278 1
		rv = config_deactivate(scbus->sc_child);
d1281 2
d1287 1
d1290 2
a1291 1
umass_disco(struct umass_softc *sc)
d1305 21
a1325 6
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL) {
			usbd_close_pipe(sc->sc_pipe[i]);
			sc->sc_pipe[i] = NULL;
		}
	}
d1345 1
a1345 1
	    flags | sc->sc_xfer_flags, sc->timeout, sc->sc_methods->wire_state);
d1362 4
a1365 2
umass_setup_ctrl_transfer(struct umass_softc *sc, usb_device_request_t *req,
	 void *buffer, int buflen, int flags, usbd_xfer_handle xfer)
d1374 2
a1375 2
	usbd_setup_default_xfer(xfer, sc->sc_udev, (void *) sc, sc->timeout,
		req, buffer, buflen, flags, sc->sc_methods->wire_state);
d1390 3
a1392 2
umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
	usbd_xfer_handle xfer)
d1394 2
d1400 3
a1402 1
		USBDEVNAME(sc->sc_dev), sc->sc_epaddr[endpt]));
d1404 1
a1404 1
	usbd_clear_endpoint_toggle(sc->sc_pipe[endpt]);
d1406 8
a1413 6
	sc->sc_req.bmRequestType = UT_WRITE_ENDPOINT;
	sc->sc_req.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->sc_req.wValue, UF_ENDPOINT_HALT);
	USETW(sc->sc_req.wIndex, sc->sc_epaddr[endpt]);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0, xfer);
d1435 4
a1438 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_reset\n",
		sc->sc_wire));
d1465 2
d1468 6
a1473 6
	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_BBB_RESET;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0,
d1479 2
a1480 2
		   void *data, int datalen, int dir, u_int timeout,
		   umass_callback cb, void *priv)
d1487 3
a1489 6
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_transfer\n",
		sc->sc_wire));

	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;
d1561 1
a1561 1
	memcpy(sc->cbw.CBWCDB, cmd, cmdlen);
d1578 1
a1578 1
	if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1593 2
a1594 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_state\n",
		sc->sc_wire));
d1633 1
a1633 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d1643 1
a1643 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1665 1
a1665 1
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %d failed, "
a1670 1
					sc->transfer_state = TSTATE_BBB_DCLEAR;
d1673 4
a1676 1
					    UMASS_BULKIN:UMASS_BULKOUT),
d1697 1
a1697 1
		/* FALLTHROUGH, err == 0 (no data phase or successful) */
d1703 1
a1703 1
		 * In the case of no data phase or successful data phase,
d1720 1
a1720 1
			/* After no data phase, successful data phase and
d1732 3
a1734 2
		if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
			&sc->csw, UMASS_BBB_CSW_SIZE, 0, next_xfer)) {
d1753 4
a1756 3
				sc->transfer_state = TSTATE_BBB_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
				    sc->transfer_xfer[XFER_BBB_SCLEAR]);
a1765 9
		/* Translate weird command-status signatures. */
		if ((sc->sc_quirks & UMASS_QUIRK_WRONG_CSWSIG) &&
		    UGETDW(sc->csw.dCSWSignature) == CSWSIGNATURE_OLYMPUS_C1)
			USETDW(sc->csw.dCSWSignature, CSWSIGNATURE);

		/* Translate invalid command-status tags */
		if (sc->sc_quirks & UMASS_QUIRK_WRONG_CSWTAG)
			USETDW(sc->csw.dCSWTag, UGETDW(sc->cbw.dCBWTag));

d1810 1
d1812 1
a1812 1
		} else if (sc->transfer_datalen - sc->transfer_actlen
d1821 2
d1824 1
a1824 1
		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d1852 2
a1853 2
		sc->transfer_state = TSTATE_BBB_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d1863 2
a1864 2
		sc->transfer_state = TSTATE_BBB_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d1898 13
a1910 10
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_adsc\n",
		sc->sc_wire));

	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_CBI_ADSC;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, &sc->sc_req, buffer,
d1921 2
a1922 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_reset\n",
		sc->sc_wire));
d1968 2
a1969 2
		   void *cmd, int cmdlen, void *data, int datalen, int dir,
		   u_int timeout, umass_callback cb, void *priv)
d1974 3
a1976 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_transfer\n",
		sc->sc_wire));
a1980 3
	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;

d2028 2
a2029 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_state\n",
		sc->sc_wire));
d2052 4
a2055 4
			 * The control pipe has already been unstalled by the
			 * USB stack.
			 * Section 2.4.3.1.1 states that the bulk in endpoints
			 * should not stalled at this point.
d2074 1
a2074 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d2083 1
a2083 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d2089 1
a2089 1
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2093 1
a2093 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2119 1
a2119 1
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %d failed, "
d2125 3
a2127 2
				sc->transfer_state = TSTATE_CBI_DCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2143 1
a2143 1
		if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2146 1
a2146 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2171 3
a2173 2
				sc->transfer_state = TSTATE_CBI_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_INTRIN,
d2183 1
a2183 1
		if (sc->sc_cmd == UMASS_CPROTO_UFI) {
d2201 1
a2201 1
			/* No sense, command successful */
d2259 2
a2260 2
		sc->transfer_state = TSTATE_CBI_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2270 2
a2271 2
		sc->transfer_state = TSTATE_CBI_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d2301 1
d2304 1
d2310 3
d2317 1
a2317 1
	USETW(req.wIndex, sc->sc_ifaceno);
d2320 1
a2320 1
	err = usbd_do_request(sc->sc_udev, &req, maxlun);
d2357 700
d3068 2
a3069 2
	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmdlen=%d "
		"(0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s), "
d3072 1
a3072 3
		c[0], c[1], c[2], c[3], c[4], c[5],
		c[6], c[7], c[8], c[9],
		(clen > 10? "...":""),
d3106 1
a3106 1
	snprintf(s2, sizeof s2, " buffer=%p, buflen=%d", buffer, buflen);
d3114 1
a3114 1
		snprintf(&s1[j*2], sizeof s1 - j*2, "%02x", buffer[i] & 0xff);
d3117 1
a3117 1
		snprintf(s3, sizeof s3, " ...");
d3121 479
@


1.11
log
@

Angelos' Fuji camera is an 8070i device and it only accepts 12 byte CDBs.
I'm going to guess that ATAPI and QIC157 devices also want 12-byte CDBs.

So, pad CDBs to be 12 bytes for ATAPI, QIC157, 8070i (as well as UFI devices)

Also, remove an overly paranoid check in BBB state machine which
actually violates the spec.  This is half of getting Angelos' Olympus
camera to work. The other half involves a semi-violent rewrite of the
sd scsi driver to make it more tolerant.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.10 2001/02/24 00:06:32 mickey Exp $ */
d870 2
d1161 16
a1185 4

	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
@


1.10
log
@#else if/#elif
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.9 2001/01/29 02:31:06 csapuntz Exp $ */
d196 1
d1790 3
a1792 1
		} else if (sc->transfer_datalen - sc->transfer_actlen
d1802 3
a1804 1
		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d3124 2
d3226 6
d3345 3
@


1.10.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.10 2001/02/24 00:06:32 mickey Exp $ */
@


1.10.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.10.4.1 2001/05/14 22:26:23 niklas Exp $ */
a195 1
#define ATAPI_COMMAND_LENGTH 12
d1789 1
a1789 3
		} 
#if 0
		else if (sc->transfer_datalen - sc->transfer_actlen
d1799 1
a1799 3
		}
#endif
		else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
a3118 2
	memset(&trcmd, 0, sizeof(trcmd));

a3218 6
	if (sc->proto & PROTO_ATAPI) {
		bcopy(cmd, &trcmd, cmdlen);
		cmd = &trcmd;
		cmdlen = ATAPI_COMMAND_LENGTH;
	}

a3331 3
		else if (sc->proto & PROTO_ATAPI)
			cmdlen = ATAPI_COMMAND_LENGTH;

@


1.10.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.10.4.2 2001/07/04 10:43:57 niklas Exp $ */
a869 2
void umass_delayed_attach(struct umass_softc  *sc);

a1158 16
	if (cold) {
		startuphook_establish((void (*)(void *))umass_delayed_attach,
			sc);
	} else {
		/* hot plug, do it now */
		umass_delayed_attach(sc);
	}

	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
}

void
umass_delayed_attach(struct umass_softc  *sc)
{
d1168 4
@


1.10.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d305 2
a306 2
typedef void (*transfer_cb_f)(struct umass_softc *sc, void *priv,
				int residue, int status);
d312 2
a313 2
typedef void (*wire_reset_f)(struct umass_softc *sc, int status);
typedef void (*wire_transfer_f)(struct umass_softc *sc, int lun,
d315 3
a317 3
				int dir, transfer_cb_f cb, void *priv);
typedef void (*wire_state_f)(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);
d320 1
a320 1
typedef int (*command_transform_f)(struct umass_softc *sc,
d322 1
a322 1
				unsigned char **rcmd, int *rcmdlen);
d547 2
a548 2
Static void umass_disco(struct umass_softc *sc);
Static int umass_match_proto(struct umass_softc *sc,
d550 2
a551 2
				usbd_device_handle dev);
Static void umass_init_shuttle(struct umass_softc *sc);
d554 1
a554 1
Static usbd_status umass_setup_transfer(struct umass_softc *sc,
d557 2
a558 2
				usbd_xfer_handle xfer);
Static usbd_status umass_setup_ctrl_transfer(struct umass_softc *sc,
d562 2
a563 2
				usbd_xfer_handle xfer);
Static void umass_clear_endpoint_stall(struct umass_softc *sc,
d565 1
a565 1
				int state, usbd_xfer_handle xfer);
d567 2
a568 2
Static void umass_reset(struct umass_softc *sc,
				transfer_cb_f cb, void *priv);
d572 2
a573 2
Static void umass_bbb_reset(struct umass_softc *sc, int status);
Static void umass_bbb_transfer(struct umass_softc *sc, int lun,
d576 2
a577 2
				transfer_cb_f cb, void *priv);
Static void umass_bbb_state(usbd_xfer_handle xfer,
d579 3
a581 3
				usbd_status err);
usbd_status umass_bbb_get_max_lun(struct umass_softc *sc,
				       u_int8_t *maxlun);
d585 4
a588 4
Static int umass_cbi_adsc(struct umass_softc *sc, char *buffer,int buflen,
				usbd_xfer_handle xfer);
Static void umass_cbi_reset(struct umass_softc *sc, int status);
Static void umass_cbi_transfer(struct umass_softc *sc, int lun,
d591 3
a593 3
				transfer_cb_f cb, void *priv);
Static void umass_cbi_state(usbd_xfer_handle xfer,
				usbd_private_handle priv, usbd_status err);
d597 2
a598 2
Static void umass_cam_action(struct cam_sim *sim, union ccb *ccb);
Static void umass_cam_poll(struct cam_sim *sim);
d600 4
a603 4
Static void umass_cam_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
Static void umass_cam_sense_cb(struct umass_softc *sc, void *priv,
				int residue, int status);
d606 1
a606 1
Static void umass_cam_rescan(struct umass_softc *sc);
d609 4
a612 4
Static int umass_cam_attach_sim(void);
Static int umass_cam_attach(struct umass_softc *sc);
Static int umass_cam_detach_sim(void);
Static int umass_cam_detach(struct umass_softc *sc);
d631 8
a638 8
Static int umass_scsipi_cmd(struct scsipi_xfer *xs);
Static void umass_scsipi_minphys(struct buf *bp);
Static int umass_scsipi_ioctl(struct scsipi_link *, u_long,
				   caddr_t, int, struct proc *);
Static void umass_scsipi_cb(struct umass_softc *sc, void *priv,
				     int residue, int status);
Static void umass_scsipi_sense_cb(struct umass_softc *sc, void *priv,
				       int residue, int status);
d640 2
a641 2
Static int scsipiprint(void *aux, const char *pnp);
Static int umass_ufi_transform(struct umass_softc *sc,
d643 1
a643 1
    struct scsipi_generic *rcmd, int *rcmdlen);
d646 1
a646 1
Static void umass_atapi_probedev(struct atapibus_softc *, int);
d652 1
a652 1
Static int umass_scsi_transform(struct umass_softc *sc,
d654 1
a654 1
				unsigned char **rcmd, int *rcmdlen);
d657 1
a657 1
Static int umass_ufi_transform(struct umass_softc *sc,
d659 1
a659 1
				unsigned char **rcmd, int *rcmdlen);
d662 1
a662 1
Static int umass_8070_transform(struct umass_softc *sc,
d664 1
a664 1
				unsigned char **rcmd, int *rcmdlen);
d669 6
a674 6
Static void umass_bbb_dump_cbw(struct umass_softc *sc,
				umass_bbb_cbw_t *cbw);
Static void umass_bbb_dump_csw(struct umass_softc *sc,
				umass_bbb_csw_t *csw);
Static void umass_dump_buffer(struct umass_softc *sc, u_int8_t *buffer,
				int buflen, int printlen);
d1194 1
a1194 1
	extern int atapi_print(void *aux, const char *pnp);
d1479 1
a1479 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd));
d1966 1
a1966 1
		USBDEVNAME(sc->sc_dev), *(u_char *)cmd, datalen));
@


1.10.4.5
log
@Sync the SMP branch with 3.3
@
text
@d240 1
a240 1
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
d314 1
a314 1
				void *cmd, int cmdlen, void *data, int datalen,
d403 1
a403 1

d408 1
a408 1
	umass_cbi_cbl_t		cbl;	/* command block */
d430 1
a430 1

d449 1
a449 1
	int			transfer_actlen;	/* actual length */
d561 1
a561 1
				void *buffer, int buflen, int flags,
a727 6
	if (vendor == USB_VENDOR_TRUMPION &&
	    product == USB_PRODUCT_TRUMPION_XXX1100) {
		sc->proto = PROTO_ATAPI | PROTO_CBI;
		return (UMATCH_VENDOR_PRODUCT);
	}

d783 1
a783 1
		/*
d798 1
a798 1

d951 1
a951 1
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sSubclass,
d1044 1
a1044 1
	/*
d1091 1
a1091 1
		sc->data_buffer = usbd_alloc_buffer(sc->transfer_xfer[bno],
d1113 1
a1113 1
		panic("%s:%d: Unknown proto 0x%02x",
d1126 1
a1126 1

d1141 1
a1141 1
		sc->u.sc_link.adapter_target = UMASS_SCSIID_HOST;
d1155 1
a1155 1
		printf("%s: proto=0x%x not supported yet\n",
d1286 1
a1286 1
{
d1455 1
a1455 1

d1493 1
a1493 1
	 * machine in umass_bbb_state handle the completion. It uses the
d1635 1
a1635 1
			memcpy(sc->data_buffer, sc->transfer_data,
d1691 1
a1691 1
		/* FALLTHROUGH, err == 0 (no data phase or successful) */
d1697 1
a1697 1
		 * In the case of no data phase or successful data phase,
d1709 1
a1709 1

d1714 1
a1714 1
			/* After no data phase, successful data phase and
d1795 1
a1795 1

d1801 1
a1801 1
			panic("%s: transferred %d bytes instead of %d bytes",
d1804 1
a1804 1
		}
d1879 1
a1879 1
		panic("%s: Unknown state %d",
d1923 1
a1923 1
	 *
d1937 1
a1937 1

d1983 1
a1983 1
	 * machine in umass_cbi_state handle the completion. It uses the
d2065 1
a2065 1

d2075 1
a2075 1
			memcpy(sc->data_buffer, sc->transfer_data,
d2179 1
a2179 1

d2195 1
a2195 1
			/* No sense, command successful */
d2287 1
a2287 1
		panic("%s: Unknown state %d",
d2467 1
a2467 1

d2710 1
a2710 1
	}
d2857 2
a2858 2
				panic("transform(REQUEST_SENSE) failed");
#else
d2871 1
a2871 1
			panic("umass_cam_cb called for func_code %d",
d2886 1
a2886 1
		panic("%s: Unknown status %d in umass_cam_cb",
d3151 1
a3151 1
	    xs, xs->cmd->opcode, sc_link->quirks,
d3169 2
a3170 2
	if ((sc_link->type == BUS_ATAPI ?
	     sc_link->scsipi_atapi.drive : SCSI_LINK_TARGET(sc_link))
d3192 1
a3192 1
	if (xs->cmd->opcode == MODE_SENSE &&
d3194 1
a3194 1
		/*printf("%s: MODE_SENSE\n", USBDEVNAME(sc->sc_dev));*/
d3254 1
a3254 1
		DPRINTF(UDMASS_SCSI, ("umass_scsi_cmd: done err=%d\n",
d3285 1
a3285 1

d3337 1
a3337 1

d3373 1
a3373 1
		panic("%s: Unknown status %d in umass_scsipi_cb",
d3394 1
a3394 1
/*
d3423 2
a3424 2
		if (bytes_received < 8 ||
		    (bytes_received < xs->sense.extra_len + 8))
d3438 1
a3438 1

d3468 1
a3468 1
umass_ufi_transform(struct umass_softc *sc, struct scsipi_generic *cmd,
d3486 1
a3486 1
	}
d3491 1
a3491 1
	case REZERO_UNIT:
d3501 2
a3502 2
	case MODE_SELECT_BIG:
	case MODE_SENSE_BIG:
d3508 1
a3508 1
	/*
d3515 4
a3518 4
	case READ_COMMAND:
	case WRITE_COMMAND:
	case MODE_SENSE:
	case MODE_SELECT:
d3547 1
a3547 1
	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT);
d3551 1
a3551 1
		return;
@


1.10.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.10.4.5 2003/03/28 00:38:32 niklas Exp $ */
d867 1
a867 1
	strlcpy(sc->sc_dev.dv_xname, "umass", sizeof sc->sc_dev.dv_xname);
d893 1
a893 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d3106 1
a3106 1
	snprintf(s2, sizeof s2, " buffer=%p, buflen=%d", buffer, buflen);
d3114 1
a3114 1
		snprintf(&s1[j*2], sizeof s1 - j*2, "%02x", buffer[i] & 0xff);
d3117 1
a3117 1
		snprintf(s3, sizeof s3, " ...");
@


1.10.4.7
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umass.c,v 1.96 2003/04/26 12:46:59 dsainty Exp $	*/
d33 1
a33 1
 * Universal Serial Bus Mass Storage Class specs:
d42 1
a42 1
 * Parts of the code written by Jason R. Thorpe <thorpej@@shagadelic.org>.
d54 2
a55 2
 * - 8070 (ATA/ATAPI for rewritable removable media)
 * - UFI (USB Floppy Interface)
d57 4
a60 5
 * 8070i is a transformed version of the SCSI command set. UFI is a transformed
 * version of the 8070i command set.  The sc->transform method is used to
 * convert the commands into the appropriate format (if at all necessary).
 * For example, ATAPI requires all commands to be 12 bytes in length amongst
 * other things.
d96 6
a101 1
#if defined(__NetBSD__)
a102 3
#include "scsibus.h"
#elif defined(__OpenBSD__)
#include "atapiscsi.h"
a104 2
#include "wd.h"

d112 1
d127 26
a152 3
#include <dev/usb/umassvar.h>
#include <dev/usb/umass_quirks.h>
#include <dev/usb/umass_scsi.h>
d154 15
d171 15
d187 328
d516 1
d541 4
d548 4
d559 1
d563 3
a565 2
Static void umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
				usbd_xfer_handle xfer);
d567 2
a568 1
Static void umass_reset(struct umass_softc *sc,	transfer_cb_f cb, void *priv);
d572 10
a581 4
Static void umass_bbb_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
Static void umass_bbb_reset(struct umass_softc *, int);
Static void umass_bbb_state(usbd_xfer_handle, usbd_private_handle, usbd_status);
a582 1
usbd_status umass_bbb_get_max_lun(struct umass_softc *, u_int8_t *);
d585 44
a628 11
Static void umass_cbi_transfer(struct umass_softc *, int, void *, int, void *,
			       int, int, u_int, umass_callback, void *);
Static void umass_cbi_reset(struct umass_softc *, int);
Static void umass_cbi_state(usbd_xfer_handle, usbd_private_handle, usbd_status);

Static int umass_cbi_adsc(struct umass_softc *, char *, int, usbd_xfer_handle);

const struct umass_wire_methods umass_bbb_methods = {
	umass_bbb_transfer,
	umass_bbb_reset,
	umass_bbb_state
d631 35
a665 5
const struct umass_wire_methods umass_cbi_methods = {
	umass_cbi_transfer,
	umass_cbi_reset,
	umass_cbi_state
};
d678 2
d684 11
a694 1
USB_MATCH(umass)
d696 1
a696 2
	USB_MATCH_START(umass, uaa);
	const struct umass_quirk *quirk;
d698 1
d700 75
a774 2
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
d776 7
a782 3
	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL)
		return (quirk->uq_match);
d784 1
a784 1
	id = usbd_get_interface_descriptor(uaa->iface);
d788 25
a812 2
	switch (id->bInterfaceSubClass) {
	case UISUBCLASS_RBC:
d814 1
d816 4
a819 3
	case UISUBCLASS_UFI:
	case UISUBCLASS_SFF8070I:
	case UISUBCLASS_SCSI:
d822 6
a827 1
		return (UMATCH_IFACECLASS);
d830 4
a833 1
	switch (id->bInterfaceProtocol) {
d835 6
a840 2
	case UIPROTO_MASS_CBI:
	case UIPROTO_MASS_BBB_OLD:
d842 7
d851 3
a853 1
		return (UMATCH_IFACECLASS_IFACESUBCLASS);
d856 18
a873 1
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
d876 2
a880 1
	const struct umass_quirk *quirk;
d883 1
a883 1
	const char *sWire, *sCommand;
d885 7
a891 2
	usbd_status err;
	int i, bno, error;
d896 2
a897 19
	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_ifaceno = uaa->ifaceno;

	quirk = umass_lookup(uaa->vendor, uaa->product);
	if (quirk != NULL) {
		sc->sc_wire = quirk->uq_wire;
		sc->sc_cmd = quirk->uq_cmd;
		sc->sc_quirks = quirk->uq_flags;
		sc->sc_busquirks = quirk->uq_busquirks;

		if (quirk->uq_fixup != NULL)
			(*quirk->uq_fixup)(sc);
	} else {
		sc->sc_wire = UMASS_WPROTO_UNSPEC;
		sc->sc_cmd = UMASS_CPROTO_UNSPEC;
		sc->sc_quirks = 0;
		sc->sc_busquirks = 0;
	}
d899 3
a901 2
	id = usbd_get_interface_descriptor(sc->sc_iface);
	if (id == NULL)
a902 20

	if (sc->sc_wire == UMASS_WPROTO_UNSPEC) {
		switch (id->bInterfaceProtocol) {
		case UIPROTO_MASS_CBI:
			sc->sc_wire = UMASS_WPROTO_CBI;
			break;
		case UIPROTO_MASS_CBI_I:
			sc->sc_wire = UMASS_WPROTO_CBI_I;
			break;
		case UIPROTO_MASS_BBB:
		case UIPROTO_MASS_BBB_OLD:
			sc->sc_wire = UMASS_WPROTO_BBB;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported wire protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceProtocol));
			USB_ATTACH_ERROR_RETURN;
		}
d905 8
a912 28
	/* XXX - Now unsupported CBI with CCI */
	if (sc->sc_wire == UMASS_WPROTO_CBI_I)
		sc->sc_wire = UMASS_WPROTO_CBI;

	if (sc->sc_cmd == UMASS_CPROTO_UNSPEC) {
		switch (id->bInterfaceSubClass) {
		case UISUBCLASS_SCSI:
			sc->sc_cmd = UMASS_CPROTO_SCSI;
			break;
		case UISUBCLASS_UFI:
			sc->sc_cmd = UMASS_CPROTO_UFI;
			break;
		case UISUBCLASS_SFF8020I:
		case UISUBCLASS_SFF8070I:
		case UISUBCLASS_QIC157:
			sc->sc_cmd = UMASS_CPROTO_ATAPI;
			break;
		case UISUBCLASS_RBC:
			sc->sc_cmd = UMASS_CPROTO_RBC;
			break;
		default:
			DPRINTF(UDMASS_GEN,
				("%s: Unsupported command protocol %u\n",
				USBDEVNAME(sc->sc_dev),
				id->bInterfaceSubClass));
			USB_ATTACH_ERROR_RETURN;
		}
	}
d914 1
d917 12
a928 3
	switch (sc->sc_wire) {
	case UMASS_WPROTO_CBI:
		sWire = "CBI";
d930 2
a931 2
	case UMASS_WPROTO_CBI_I:
		sWire = "CBI with CCI";
d933 2
a934 2
	case UMASS_WPROTO_BBB:
		sWire = "Bulk-Only";
d937 1
a937 1
		sWire = "unknown";
d940 3
a942 4

	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
		sCommand = "RBC";
d944 2
a945 2
	case UMASS_CPROTO_SCSI:
		sCommand = "SCSI";
d947 2
a948 5
	case UMASS_CPROTO_UFI:
		sCommand = "UFI";
		break;
	case UMASS_CPROTO_ATAPI:
		sCommand = "ATAPI";
d950 2
a951 2
	case UMASS_CPROTO_ISD_ATA:
		sCommand = "ISD-ATA";
d954 1
a954 1
		sCommand = "unknown";
d957 2
d960 10
a969 2
	printf("%s: using %s over %s\n", USBDEVNAME(sc->sc_dev), sCommand,
	       sWire);
d983 2
a984 2
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
d991 1
a991 1
			sc->sc_epaddr[UMASS_BULKIN] = ed->bEndpointAddress;
d994 2
a995 2
			sc->sc_epaddr[UMASS_BULKOUT] = ed->bEndpointAddress;
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I
d998 1
a998 1
			sc->sc_epaddr[UMASS_INTRIN] = ed->bEndpointAddress;
d1010 6
a1015 7
	if (!sc->sc_epaddr[UMASS_BULKIN] || !sc->sc_epaddr[UMASS_BULKOUT] ||
	    (sc->sc_wire == UMASS_WPROTO_CBI_I &&
	     !sc->sc_epaddr[UMASS_INTRIN])) {
		DPRINTF(UDMASS_USB, ("%s: endpoint not found %u/%u/%u\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN],
			sc->sc_epaddr[UMASS_BULKOUT],
			sc->sc_epaddr[UMASS_INTRIN]));
d1022 1
a1022 2
	if (sc->sc_wire == UMASS_WPROTO_BBB &&
	    !(sc->sc_quirks & UMASS_QUIRK_NO_MAX_LUN)) {
d1034 2
a1035 3
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKOUT],
				USBD_EXCLUSIVE_USE,
				&sc->sc_pipe[UMASS_BULKOUT]);
d1037 2
a1038 2
		DPRINTF(UDMASS_USB, ("%s: cannot open %u-out pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKOUT]));
d1042 2
a1043 2
	err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_BULKIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_BULKIN]);
d1045 2
a1046 2
		DPRINTF(UDMASS_USB, ("%s: could not open %u-in pipe (bulk)\n",
			USBDEVNAME(sc->sc_dev), sc->sc_epaddr[UMASS_BULKIN]));
d1062 3
a1064 3
	if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
		err = usbd_open_pipe(sc->sc_iface, sc->sc_epaddr[UMASS_INTRIN],
				USBD_EXCLUSIVE_USE, &sc->sc_pipe[UMASS_INTRIN]);
d1066 2
a1067 3
			DPRINTF(UDMASS_USB, ("%s: couldn't open %u-in (intr)\n",
				USBDEVNAME(sc->sc_dev),
				sc->sc_epaddr[UMASS_INTRIN]));
d1079 1
a1079 1
		if (sc->transfer_xfer[i] == NULL) {
d1087 2
a1088 2
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
d1091 1
a1091 1
	case UMASS_WPROTO_CBI:
d1094 1
a1094 1
	case UMASS_WPROTO_CBI_I:
d1109 13
a1121 11
	switch (sc->sc_wire) {
	case UMASS_WPROTO_BBB:
		sc->sc_methods = &umass_bbb_methods;
		break;
	case UMASS_WPROTO_CBI:
	case UMASS_WPROTO_CBI_I:
		sc->sc_methods = &umass_cbi_methods;
		break;
	default:
		umass_disco(sc);
		USB_ATTACH_ERROR_RETURN;
d1124 8
a1131 7
	if (quirk != NULL && quirk->uq_init != NULL) {
		err = (*quirk->uq_init)(sc);
		if (err) {
			umass_disco(sc);
			USB_ATTACH_ERROR_RETURN;
		}
	}
d1133 21
a1153 10
	error = 0;
	switch (sc->sc_cmd) {
	case UMASS_CPROTO_RBC:
	case UMASS_CPROTO_SCSI:
#if defined(__OpenBSD__) || NSCSIBUS > 0
		error = umass_scsi_attach(sc);
#else
		printf("%s: scsibus not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1155 2
a1156 8
	case UMASS_CPROTO_UFI:
	case UMASS_CPROTO_ATAPI:
#if (NATAPIBUS > 0) || (NATAPISCSI > 0)
		error = umass_atapi_attach(sc);
#else
		printf("%s: "UMASS_ATAPISTR" not configured\n",
		       USBDEVNAME(sc->sc_dev));
#endif
a1158 7
	case UMASS_CPROTO_ISD_ATA:
#if defined (__NetBSD__) && NWD > 0
		error = umass_isdata_attach(sc);
#else
		printf("%s: isdata not configured\n", USBDEVNAME(sc->sc_dev));
#endif
		break;
d1161 2
a1162 2
		printf("%s: command protocol=0x%x not supported\n",
		       USBDEVNAME(sc->sc_dev), sc->sc_cmd);
d1166 19
a1184 2
	if (error) {
		printf("%s: bus attach failed\n", USBDEVNAME(sc->sc_dev));
d1186 2
a1187 1
		USB_ATTACH_ERROR_RETURN;
d1192 1
d1194 16
a1209 3
	DPRINTF(UDMASS_GEN, ("%s: Attach finished\n", USBDEVNAME(sc->sc_dev)));

	USB_ATTACH_SUCCESS_RETURN;
d1215 1
a1215 2
	struct umassbus_softc *scbus = sc->bus;
	int rv = 0, i, s;
d1220 6
a1225 4
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL)
			usbd_abort_pipe(sc->sc_pipe[i]);
	}
d1227 1
a1230 3
#ifdef DIAGNOSTIC
		printf("%s: waiting for refcnt\n", USBDEVNAME(sc->sc_dev));
#endif
d1235 1
d1237 11
a1247 8
	if (scbus != NULL) {
		if (scbus->sc_child != NULL)
			rv = config_detach(scbus->sc_child, flags);
		free(scbus, M_DEVBUF);
		sc->bus = NULL;
	}

	if (rv != 0)
d1255 1
a1255 1
	return (rv);
d1258 1
d1260 3
a1262 1
umass_activate(struct device *dev, enum devact act)
d1264 1
a1264 2
	struct umass_softc *sc = (struct umass_softc *)dev;
	struct umassbus_softc *scbus = sc->bus;
d1276 1
a1276 2
		sc->sc_dying = 1;
		if (scbus == NULL || scbus->sc_child == NULL)
d1278 1
a1278 1
		rv = config_deactivate(scbus->sc_child);
d1281 2
d1287 1
d1290 2
a1291 1
umass_disco(struct umass_softc *sc)
d1305 21
a1325 6
	for (i = 0 ; i < UMASS_NEP ; i++) {
		if (sc->sc_pipe[i] != NULL) {
			usbd_close_pipe(sc->sc_pipe[i]);
			sc->sc_pipe[i] = NULL;
		}
	}
d1345 1
a1345 1
	    flags | sc->sc_xfer_flags, sc->timeout, sc->sc_methods->wire_state);
d1362 4
a1365 2
umass_setup_ctrl_transfer(struct umass_softc *sc, usb_device_request_t *req,
	 void *buffer, int buflen, int flags, usbd_xfer_handle xfer)
d1374 2
a1375 2
	usbd_setup_default_xfer(xfer, sc->sc_udev, (void *) sc, sc->timeout,
		req, buffer, buflen, flags, sc->sc_methods->wire_state);
d1390 3
a1392 2
umass_clear_endpoint_stall(struct umass_softc *sc, int endpt,
	usbd_xfer_handle xfer)
d1394 2
d1400 3
a1402 1
		USBDEVNAME(sc->sc_dev), sc->sc_epaddr[endpt]));
d1404 1
a1404 1
	usbd_clear_endpoint_toggle(sc->sc_pipe[endpt]);
d1406 8
a1413 6
	sc->sc_req.bmRequestType = UT_WRITE_ENDPOINT;
	sc->sc_req.bRequest = UR_CLEAR_FEATURE;
	USETW(sc->sc_req.wValue, UF_ENDPOINT_HALT);
	USETW(sc->sc_req.wIndex, sc->sc_epaddr[endpt]);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0, xfer);
d1435 4
a1438 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_reset\n",
		sc->sc_wire));
d1465 2
d1468 6
a1473 6
	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_BBB_RESET;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, 0);
	umass_setup_ctrl_transfer(sc, &sc->sc_req, NULL, 0, 0,
d1479 2
a1480 2
		   void *data, int datalen, int dir, u_int timeout,
		   umass_callback cb, void *priv)
d1487 3
a1489 6
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_transfer\n",
		sc->sc_wire));

	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;
d1561 1
a1561 1
	memcpy(sc->cbw.CBWCDB, cmd, cmdlen);
d1578 1
a1578 1
	if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1593 2
a1594 3
	KASSERT(sc->sc_wire & UMASS_WPROTO_BBB,
		("sc->sc_wire == 0x%02x wrong for umass_bbb_state\n",
		sc->sc_wire));
d1633 1
a1633 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d1643 1
a1643 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d1665 1
a1665 1
				DPRINTF(UDMASS_BBB, ("%s: Data-%s %d failed, "
a1670 1
					sc->transfer_state = TSTATE_BBB_DCLEAR;
d1673 4
a1676 1
					    UMASS_BULKIN:UMASS_BULKOUT),
d1732 3
a1734 2
		if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
			&sc->csw, UMASS_BBB_CSW_SIZE, 0, next_xfer)) {
d1753 4
a1756 3
				sc->transfer_state = TSTATE_BBB_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
				    sc->transfer_xfer[XFER_BBB_SCLEAR]);
a1765 9
		/* Translate weird command-status signatures. */
		if ((sc->sc_quirks & UMASS_QUIRK_WRONG_CSWSIG) &&
		    UGETDW(sc->csw.dCSWSignature) == CSWSIGNATURE_OLYMPUS_C1)
			USETDW(sc->csw.dCSWSignature, CSWSIGNATURE);

		/* Translate invalid command-status tags */
		if (sc->sc_quirks & UMASS_QUIRK_WRONG_CSWTAG)
			USETDW(sc->csw.dCSWTag, UGETDW(sc->cbw.dCBWTag));

d1810 1
d1812 1
a1812 1
		} else if (sc->transfer_datalen - sc->transfer_actlen
d1821 2
d1824 1
a1824 1
		} else if (sc->csw.bCSWStatus == CSWSTATUS_FAILED) {
d1852 2
a1853 2
		sc->transfer_state = TSTATE_BBB_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d1863 2
a1864 2
		sc->transfer_state = TSTATE_BBB_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d1898 13
a1910 10
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_adsc\n",
		sc->sc_wire));

	sc->sc_req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	sc->sc_req.bRequest = UR_CBI_ADSC;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, sc->sc_ifaceno);
	USETW(sc->sc_req.wLength, buflen);
	return umass_setup_ctrl_transfer(sc, &sc->sc_req, buffer,
d1921 2
a1922 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_reset\n",
		sc->sc_wire));
d1968 2
a1969 2
		   void *cmd, int cmdlen, void *data, int datalen, int dir,
		   u_int timeout, umass_callback cb, void *priv)
d1974 3
a1976 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_transfer\n",
		sc->sc_wire));
a1980 3
	/* Be a little generous. */
	sc->timeout = timeout + USBD_DEFAULT_TIMEOUT;

d2028 2
a2029 3
	KASSERT(sc->sc_wire & (UMASS_WPROTO_CBI|UMASS_WPROTO_CBI_I),
		("sc->sc_wire == 0x%02x wrong for umass_cbi_state\n",
		sc->sc_wire));
d2052 4
a2055 4
			 * The control pipe has already been unstalled by the
			 * USB stack.
			 * Section 2.4.3.1.1 states that the bulk in endpoints
			 * should not stalled at this point.
d2074 1
a2074 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKIN],
d2083 1
a2083 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_BULKOUT],
d2089 1
a2089 1
		} else if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2093 1
a2093 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2119 1
a2119 1
			DPRINTF(UDMASS_CBI, ("%s: Data-%s %d failed, "
d2125 3
a2127 2
				sc->transfer_state = TSTATE_CBI_DCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2143 1
a2143 1
		if (sc->sc_wire == UMASS_WPROTO_CBI_I) {
d2146 1
a2146 1
			if (umass_setup_transfer(sc, sc->sc_pipe[UMASS_INTRIN],
d2171 3
a2173 2
				sc->transfer_state = TSTATE_CBI_SCLEAR;
				umass_clear_endpoint_stall(sc, UMASS_INTRIN,
d2183 1
a2183 1
		if (sc->sc_cmd == UMASS_CPROTO_UFI) {
d2259 2
a2260 2
		sc->transfer_state = TSTATE_CBI_RESET2;
		umass_clear_endpoint_stall(sc, UMASS_BULKIN,
d2270 2
a2271 2
		sc->transfer_state = TSTATE_CBI_RESET3;
		umass_clear_endpoint_stall(sc, UMASS_BULKOUT,
d2301 1
d2304 1
d2310 3
d2317 1
a2317 1
	USETW(req.wIndex, sc->sc_ifaceno);
d2320 1
a2320 1
	err = usbd_do_request(sc->sc_udev, &req, maxlun);
d2357 700
d3068 2
a3069 2
	DPRINTF(UDMASS_BBB, ("%s: CBW %d: cmdlen=%d "
		"(0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%s), "
d3072 1
a3072 3
		c[0], c[1], c[2], c[3], c[4], c[5],
		c[6], c[7], c[8], c[9],
		(clen > 10? "...":""),
d3121 479
@


1.10.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d34 4
a37 4
 * http://www.usb.org/developers/devclass_docs/usb_msc_overview_1.2.pdf
 * http://www.usb.org/developers/devclass_docs/usbmassbulk_10.pdf
 * http://www.usb.org/developers/devclass_docs/usb_msc_cbi_1.1.pdf
 * http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf
@


1.10.4.9
log
@sync to head
@
text
@d1440 1
a1440 1
					sc->data_buffer, sc->transfer_datalen,
d1449 1
a1449 1
					sc->data_buffer, sc->transfer_datalen,
@


1.9
log
@

Pull in updates from NetBSD 1.49. Mostly support for a couple more
quirky devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.8 2000/11/23 08:55:34 deraadt Exp $ */
d857 1
a857 1
#else if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.8
log
@fix lun support, not as nice as i would like
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.7 2000/11/20 07:34:51 deraadt Exp $ */
/*	$NetBSD: umass.c,v 1.33 2000/04/06 13:52:04 augustss Exp $	*/
d34 4
a37 2
 * http://www.usb.org/developers/usbmassbulk_09.pdf
 * XXX Add URL to CBI spec in www.usb.org
d153 3
d159 1
d161 5
d168 2
d195 1
a195 1
#define UFI_PROTO_LEN 12
d333 3
a335 2
#	define SHUTTLE_EUSB		2

d354 4
d366 1
a366 1
#	define PROTO_8070	0x0200
d368 1
d371 3
d480 4
d618 2
d640 4
d697 1
d710 2
d713 2
a714 2
	if (UGETW(dd->idVendor) == USB_VENDOR_SHUTTLE
	    && UGETW(dd->idProduct) == USB_PRODUCT_SHUTTLE_EUSB) {
d717 1
a717 1
		sc->proto = PROTO_8070 | PROTO_CBI_I;
d719 1
a719 1
		sc->proto = PROTO_8070 | PROTO_CBI;
d721 2
d727 15
a741 2
	if (UGETW(dd->idVendor) == USB_VENDOR_YEDATA
	    && UGETW(dd->idProduct) == USB_PRODUCT_YEDATA_FLASHBUSTERU) {
d761 3
d769 7
d781 18
a798 1
	switch (id->bInterfaceSubClass) {
d809 4
a812 1
		sc->proto |= PROTO_8070;
d815 1
d818 3
a820 1
		return (UMATCH_NONE);
d823 1
a823 1
	switch (id->bInterfaceProtocol) {
d860 1
d891 4
a894 1
	(void) umass_match_proto(sc, sc->iface, uaa->device);
d908 4
a911 1
	switch (id->bInterfaceSubClass) {
d931 1
a931 1
	switch (id->bInterfaceProtocol) {
d951 11
a1117 41
#if defined(__FreeBSD__)
	if (sc->proto & PROTO_SCSI)
		sc->transform = umass_scsi_transform;
	else if (sc->proto & PROTO_UFI)
		sc->transform = umass_ufi_transform;
	else if (sc->proto & PROTO_8070)
		sc->transform = umass_8070_transform;
#ifdef UMASS_DEBUG
	else
		panic("No transformation defined for command proto 0x%02x\n",
		      sc->proto & PROTO_COMMAND);
#endif

	/* From here onwards the device can be used. */

	if ((sc->proto & PROTO_SCSI) ||
	    (sc->proto & PROTO_8070) ||
	    (sc->proto & PROTO_UFI)) {
		/* Prepare the SCSI command block */
		sc->cam_scsi_sense.opcode = REQUEST_SENSE;

		/* If this is the first device register the SIM */
		if (umass_sim == NULL) {
			err = umass_cam_attach_sim();
			if (err) {
				umass_disco(self);
				USB_ATTACH_ERROR_RETURN;
			}
		}

		/* Attach the new device to our SCSI host controller (SIM) */
		err = umass_cam_attach(sc);
		if (err) {
			umass_disco(self);
			USB_ATTACH_ERROR_RETURN;
		}
	} else {
		panic("%s:%d: Unknown proto 0x%02x\n",
		      __FILE__, __LINE__, sc->proto);
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1122 3
#if defined(__NetBSD__)
	sc->sc_adapter.scsipi_ioctl = umass_scsipi_ioctl;
#endif
d1130 2
a1131 7
#if defined(__OpenBSD__)
	case PROTO_8070:
#endif
#if defined(__NetBSD__)
		sc->u.sc_link.type = BUS_SCSI;
#endif
#if defined(__OpenBSD__)
a1139 1
#endif
a1144 6
#if defined(__NetBSD__)
		sc->u.sc_link.scsipi_scsi.channel = SCSI_CHANNEL_ONLY_ONE;
		sc->u.sc_link.scsipi_scsi.adapter_target = UMASS_SCSIID_HOST;
		sc->u.sc_link.scsipi_scsi.max_target = UMASS_SCSIID_DEVICE;
		sc->u.sc_link.scsipi_scsi.max_lun = sc->maxlun;
#endif
a1149 13
#if !defined(__OpenBSD__)
#if NATAPIBUS > 0
	case PROTO_8070:
		sc->u.aa.sc_aa.aa_type = T_ATAPI;
		sc->u.aa.sc_aa.aa_channel = 0;
		sc->u.aa.sc_aa.aa_openings = 1;
		sc->u.aa.sc_aa.aa_drv_data = &sc->u.aa.sc_aa_drive;
		sc->u.aa.sc_aa.aa_bus_private = &sc->sc_atapi_adapter;
		sc->sc_atapi_adapter.atapi_probedev = umass_atapi_probedev;
		sc->sc_atapi_adapter.atapi_kill_pending = scsi_kill_pending;
		break;
#endif
#endif
a1163 1
#endif
d1207 1
a1207 1
	/* Do we really need referebce counting?  Perhaps in ioctl() */
d1218 1
a1218 1
	    (sc->proto & PROTO_8070) ||
d1255 1
a1255 1
		if (sc->sc_child != NULL)
d1354 1
a1354 2
	    sc->timeout, req, buffer, buflen, 
	    flags | sc->sc_xfer_flags, sc->state);
a1874 3
	DPRINTF(UDMASS_CBI,("%s: umass_cbi_adsc\n",
		USBDEVNAME(sc->sc_dev)));

d2989 1
a2989 1
		if (sc->quirks &  NO_TEST_UNIT_READY) {
d3112 1
d3115 3
d3126 1
a3126 1
#if defined(__NetBSD__)
d3129 1
a3129 8
	    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun,
	    xs, xs->cmd->opcode, sc_link->quirks, 
	    xs->xs_control & XS_CTL_POLL));
#endif
#if defined(__OpenBSD__)
	DPRINTF(UDMASS_CMD, ("%s: umass_scsi_cmd:  %d:%d xs=%p cmd=0x%02x "
	    "(quirks=0x%x, poll=%d)\n", USBDEVNAME(sc->sc_dev),
	    sc_link->target, sc_link->lun,
d3149 1
a3149 1
	     sc_link->scsipi_atapi.drive : sc_link->scsipi_scsi.target) 
d3153 1
a3153 1
		    sc_link->scsipi_scsi.target));
d3169 1
a3169 1

d3185 7
d3211 7
a3217 3
	/* All UFI commands are 12 bytes.  We'll get a few garbage bytes by extending... */
	if (sc->proto & PROTO_UFI)
		cmdlen = UFI_PROTO_LEN;
d3224 1
a3224 6
#if defined(__NetBSD__)
		sc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,
#endif
#if defined(__OpenBSD__)
		sc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,
#endif
d3245 1
a3245 6
#if defined(__NetBSD__)
		sc->transfer(sc, sc_link->scsipi_scsi.lun, xs->cmd, cmdlen,
#endif
#if defined(__OpenBSD__)
		sc->transfer(sc, sc_link->lun, xs->cmd, cmdlen,
#endif
d3304 9
a3312 4

	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: xs=%p residue=%d status=%d\n",
		xs, residue, status));

d3325 1
a3325 6
#if defined(__NetBSD__)
		sc->sc_sense_cmd.byte2 = sc_link->scsipi_scsi.lun <<
#endif
#if defined(__OpenBSD__)
		sc->sc_sense_cmd.byte2 = sc_link->lun <<
#endif
d3331 2
a3332 7
			cmdlen = UFI_PROTO_LEN;
#if defined(__NetBSD__)
		sc->transfer(sc, sc_link->scsipi_scsi.lun,
#endif
#if defined(__OpenBSD__)
		sc->transfer(sc, sc_link->lun,
#endif
d3354 4
a3357 3
	DPRINTF(UDMASS_CMD,("umass_scsipi_cb: return xs->error=%d, "
		"xs->xs_status=0x%x xs->resid=%d\n", xs->error, xs->xs_status,
		xs->resid));
d3432 66
@


1.7
log
@limit luns on usb
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.6 2000/04/14 22:50:28 aaron Exp $ */
d1087 1
a1087 1
		sc->u.sc_link.maxlun = sc->maxlun;
@


1.6
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: umass.c,v 1.5 2000/04/08 20:28:07 csapuntz Exp $ */
d1087 1
@


1.5
log
@

Y-E UFI drives don't clear sense on INQUIRY. Upper-layer SCSI drivers
don't like that too much.

Now drive is detected correctly, even without floppy in it.
@
text
@d1 2
a2 2
/*	$OpenBSD: umass.c,v 1.4 2000/04/08 20:03:34 aaron Exp $ */
/*	$NetBSD: umass.c,v 1.31 2000/04/03 12:31:34 augustss Exp $	*/
d790 1
d821 6
a826 4
	printf("%s: using ", USBDEVNAME(sc->sc_dev));
	switch (sc->proto & PROTO_COMMAND) {
	case PROTO_SCSI:
		printf("SCSI");
d828 5
a832 2
	case PROTO_8070:
		printf("8070i");
d834 2
a835 2
	case PROTO_UFI:
		printf("UFI");
d838 1
a838 1
		printf("(unknown 0x%02x)", sc->proto&PROTO_COMMAND);
d841 3
a843 4
	printf(" over ");
	switch (sc->proto & PROTO_WIRE) {
	case PROTO_BBB:
		printf("Bulk-Only");
d845 2
a846 2
	case PROTO_CBI:			/* uses Command/Bulk pipes */
		printf("CBI");
d848 5
a852 2
	case PROTO_CBI_I:		/* uses Command/Bulk/Interrupt pipes */
		printf("CBI with CCI");
d855 2
a856 1
		printf("(unknown 0x%02x)", sc->proto&PROTO_WIRE);
d858 2
a859 1
	printf("\n");
@


1.4
log
@Add RCSids.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d3350 9
@


1.3
log
@

Complete the port to OpenBSD started by aaron@@

Tested with Y-E USB floppy.
@
text
@d1 1
@


1.2
log
@New USB mass storage driver. Improvements: Uses asynchronous USB requests,
supports more transport protocols (bulk-only and CBI), supports more command
sets (SCSI and ATAPI); from NetBSD. Not yet tested.
@
text
@a99 2
#else
#include "atapiscsi.h"
a153 2
#include <dev/ata/atavar.h>	/* XXX */
#include <dev/ic/wdcvar.h>
d172 1
a172 1
int umassdebug = 0; //UDMASS_ALL;
d464 1
d469 1
d1062 3
d1067 9
a1075 2
#else
		sc->u.sc_link.flags &= ~SDEV_ATAPI;
d1093 1
d1105 1
d1135 1
a1138 1
#if !defined(__OpenBSD__)
d1144 1
a1144 4
	if (l->flags & SDEV_ATAPI)
		return (atapi_print(aux, pnp));
	else
		return (scsiprint(aux, pnp));
d1311 2
a1312 1
	    sc->timeout, req, buffer, buflen, flags, sc->state);
d1833 3
d1988 4
a1991 4
			 * The control pipe has already been unstalled by the
			 * USB stack.
			 * Section 2.4.3.1.1 states that the bulk in endpoints
			 * should not stalled at this point.
d3076 1
d3078 4
d3083 1
a3085 1
#if defined(__NetBSD__)
d3087 2
a3088 2
#else
	    sc_link->scsipi_scsi.target, sc_link->lun,
d3090 4
d3096 2
d3111 1
a3111 1
#if !defined(__OpenBSD__)
a3112 3
#else
	if ((sc_link->flags & SDEV_ATAPI ?
#endif
d3122 12
d3179 2
a3180 1
#else
d3205 2
a3206 1
#else
d3215 1
d3217 5
d3285 2
a3286 1
#else
d3297 2
a3298 1
#else
d3315 1
d3317 4
d3340 1
d3343 1
a3343 1
		"status=%d\n", xs, residue, status));
d3349 6
a3354 2
		/* XXX look at residue */
		if (residue == 0 || residue == 14)/* XXX */
d3356 11
a3366 2
		else
			xs->error = XS_SHORTSENSE;
d3375 1
d3377 4
@


1.1
log
@Add support for USB Mass Storage devices; e.g., USB Zip Drives. UNTESTED.
From NetBSD.
@
text
@d1 1
a1 39
/*	$OpenBSD$ */
/*	$NetBSD: umass.c,v 1.27 2000/03/29 18:30:46 augustss Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

d4 1
a4 1
 *		      Nick Hibma <hibma@@skylink.it>
d28 12
a39 1
 *	FreeBSD: src/sys/dev/usb/umass.c,v 1.8 1999/06/20 15:46:13 n_hibma Exp
d43 10
a52 2
 * Universal Serial Bus Mass Storage Class Control/Interrupt/Bulk (CBI)
 * Specification:
d54 4
a57 1
 *	http://www.usb.org/developers/data/usbmass-cbi10.pdf
d59 2
a60 1
 * Universal Serial Bus Mass Storage Bulk Only 1.0rc4 Specification:
d62 9
a70 1
 *	http://www.usb.org/developers/data/usbmassbulk_10rc4.pdf
d72 8
a79 2
 * Relevant parts of the old spec (Bulk-only 0.9) have been quoted
 * in the source.
d82 3
a84 3
/* To do:
 *	x The umass_usb_transfer routine uses synchroneous transfers. This
 *	  should be changed to async and state handling.
d86 5
a90 8
 *	x Should handle more than just Iomega USB Zip drives.  There are
 *	  a fair number of USB->SCSI dongles out there.
 *
 *	x Need to implement SCSI command timeout/abort handling.
 *
 *	x Add support for other than Bulk.
 *
 *	x Add support for other than SCSI.
d93 3
a95 3
/* Authors: (with short acronyms for comments)
 *   NWH - Nick Hibma <hibma@@skylink.it>
 *   JRT - Jason R. Thorpe <thorpej@@shagadelic.org>
d98 6
d107 5
d113 7
a119 3
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/proc.h>
d124 14
d139 2
a140 4
#if defined(__OpenBSD__)
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#else
d143 7
a149 2
#include <dev/scsipi/scsiconf.h> 
#endif
d151 7
a157 2
#if defined(USB_DEBUG) && !defined(UMASS_DEBUG)
#define UMASS_DEBUG 1
d161 16
a176 6
#define	DPRINTF(m, x)	if (umassdebug & (m)) logprintf x
#define UDMASS_SCSI	0x00020000
#define UDMASS_USB	0x00040000
#define UDMASS_BULK	0x00080000
#define UDMASS_ALL	0xffff0000
int umassdebug = /* UDMASS_SCSI|UDMASS_BULK|UDMASS_USB */ 0;
d178 2
a179 1
#define	DPRINTF(m, x)
a181 4
typedef struct umass_softc {
	USBBASEDEVICE		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;	/* the interface we use */
d183 20
a202 2
	u_int8_t		sc_subclass;	/* our USB subclass */
	u_int8_t		sc_protocol;	/* our USB protocol */
d204 1
a204 4
	u_int8_t		sc_bulkout;	/* bulk-out Endpoint Address */
	usbd_pipe_handle	sc_bulkout_pipe;
	u_int8_t		sc_bulkin;	/* bulk-in Endpoint Address */
	usbd_pipe_handle	sc_bulkin_pipe;
d206 1
a206 2
	struct scsipi_link	sc_link;	/* prototype for devs */
	struct scsipi_adapter	sc_adapter;
d208 2
a209 1
	device_ptr_t		sc_child;	/* child device, for detach */
d211 17
a227 3
	int			sc_refcnt;
	char			sc_dying;
} umass_softc_t;
d229 1
a229 1
#define USBD_COMMAND_FAILED	USBD_INVAL	/* redefine some errors for */
a230 2
#define UMASS_SCSIID_HOST	0x00
#define UMASS_SCSIID_DEVICE	0x01
d232 1
a232 3
#define DIR_OUT		0
#define DIR_IN		1
#define DIR_NONE	2
d234 2
a235 3
/* Bulk-Only specific request */
#define	UR_RESET	0xff
#define	UR_GET_MAX_LUN	0xfe
a236 1
/* Bulk-Only Mass Storage features */
d240 1
a240 1
#define  CBWSIGNATURE		0x43425355
d244 2
a245 2
#define	 CBWFLAGS_OUT	0x00
#define	 CBWFLAGS_IN	0x80
d248 4
a251 3
	uByte		CBWCDB[16];
} usb_bulk_cbw_t;
#define	USB_BULK_CBW_SIZE	31
d256 1
a256 1
#define	 CSWSIGNATURE		0x53425355
d260 257
a516 5
#define  CSWSTATUS_GOOD		0x0
#define  CSWSTATUS_FAILED	0x1
#define  CSWSTATUS_PHASE	0x2
} usb_bulk_csw_t;
#define	USB_BULK_CSW_SIZE	13
d519 1
d521 5
d527 2
a528 2
/* USB related functions */
usbd_status umass_usb_transfer __P((umass_softc_t *,
d530 14
a543 2
		                void *buf, int buflen,
				int flags, int *xfer_size));
d546 2
a547 3
usbd_status umass_bulk_reset	__P((umass_softc_t *sc));
usbd_status umass_bulk_get_max_lun __P((umass_softc_t *sc, u_int8_t *maxlun));
usbd_status umass_bulk_transfer	__P((umass_softc_t *sc, int lun,
d549 43
a591 2
		    		void *data, int datalen,
				int dir, int *residue));
d593 4
a596 2
/* SCSIPI related functions */
struct scsipi_device umass_dev = {
d600 1
a600 1
	NULL,			/* Use default `done' routine */
d603 137
a739 2
void	umass_scsipi_minphys	__P((struct buf *));
int	umass_scsipi_scsi_cmd	__P((struct scsipi_xfer *));
d741 25
d767 2
d773 6
a778 1
	usb_interface_descriptor_t *id;
d783 1
a783 8
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id != NULL
	    && id->bInterfaceClass == UICLASS_MASS
	    && id->bInterfaceSubClass == UISUBCLASS_SCSI
	    && id->bInterfaceProtocol == UIPROTO_MASS_BBB_P)
		return(UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);

	return(UMATCH_NONE);
d792 2
a793 4
	usbd_status err;
	int i;
	u_int8_t maxlun;
	const char *subclass, *protocol;
d795 4
a798 4
	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_bulkout_pipe = NULL;
	sc->sc_bulkin_pipe = NULL;
d803 14
a816 1
	id = usbd_get_interface_descriptor(sc->sc_iface);
d818 2
a819 2
	sc->sc_subclass = id->bInterfaceSubClass;
	sc->sc_protocol = id->bInterfaceProtocol;
d821 11
a831 9
	switch (sc->sc_subclass) {
#if 0
	case UISUBCLASS_RBC:		subclass = "RBC";	break;
	case UISUBCLASS_SFF8020I:	subclass = "8020i";	break;
	case UISUBCLASS_QIC157:		subclass = "QIC157";	break;
	case UISUBCLASS_UFI:		subclass = "UFI";	break;
	case UISUBCLASS_SFF8070I:	subclass = "8070i";	break;
#endif
	case UISUBCLASS_SCSI:		subclass = "SCSI";	break;
d833 2
a834 1
		panic("umass_attach: impossible subclass");
d836 11
a846 8

	switch (sc->sc_protocol) {
#if 0
	case UIPROTO_MASS_CBI_I:	protocol = "CBI with CCI"; break;
	case UIPROTO_MASS_CBI:		protocol = "CBI";	break;
#endif
	case UIPROTO_MASS_BBB:		/* XXX Is this really right? */
	case UIPROTO_MASS_BBB_P:	protocol = "Bulk-Only";	break;
d848 1
a848 1
		panic("umass_attach: impossible protocol");
d850 1
a850 5

	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
	printf("%s: %s over %s (iclass %d/%d/%d)\n", USBDEVNAME(sc->sc_dev),
	    subclass, protocol, id->bInterfaceClass, id->bInterfaceSubClass,
	    id->bInterfaceProtocol);
d853 6
a858 5
	 * A Bulk-Only Mass Storage device supports the following endpoints,
	 * in addition to the Endpoint 0 for Control transfer that is required
	 * of all USB devices:
	 * (a) bulk-in endpoint.
	 * (b) bulk-out endpoint.
d864 2
a865 2
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
d872 1
a872 1
			sc->sc_bulkin = ed->bEndpointAddress;
d875 12
a886 1
			sc->sc_bulkout = ed->bEndpointAddress;
d890 10
d903 9
a911 5
	err = umass_bulk_get_max_lun(sc, &maxlun);
	if (err) {
		printf("%s: unable to get Max Lun: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		USB_ATTACH_ERROR_RETURN;
d915 2
a916 2
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout,
		  USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
d918 3
a920 2
		DPRINTF(UDMASS_USB,("cannot open bulk out pipe (address %d)\n",
			sc->sc_bulkout));
d923 2
a924 2
	err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin,
		  USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
d926 3
a928 3
		DPRINTF(UDMASS_USB,("cannot open bulk in pipe (address %d)\n",
			sc->sc_bulkin));
		usbd_close_pipe(sc->sc_bulkout_pipe);
d931 25
d957 31
a987 3
	/* attach the device to the SCSIPI layer */
	sc->sc_adapter.scsipi_cmd = umass_scsipi_scsi_cmd;
	sc->sc_adapter.scsipi_minphys = umass_scsipi_minphys;
d989 13
a1001 12
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &sc->sc_adapter;
	sc->sc_link.device = &umass_dev;
	sc->sc_link.openings = 1;
#if defined(__OpenBSD__)
	sc->sc_link.adapter_target = UMASS_SCSIID_HOST;
#else
	sc->sc_link.scsipi_scsi.adapter_target = UMASS_SCSIID_HOST;
	sc->sc_link.scsipi_scsi.channel = SCSI_CHANNEL_ONLY_ONE;
	sc->sc_link.scsipi_scsi.max_target = UMASS_SCSIID_DEVICE; /* XXX */
	sc->sc_link.scsipi_scsi.max_lun = maxlun;
	sc->sc_link.type = BUS_SCSI;
a1002 7

	sc->sc_child = config_found(&sc->sc_dev, &sc->sc_link, scsiprint);
	if (sc->sc_child == NULL) {
		usbd_close_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		/* XXX Not really an error. */
		USB_ATTACH_ERROR_RETURN;
d1005 2
a1006 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d1008 12
a1019 2
	USB_ATTACH_SUCCESS_RETURN;
}
d1021 1
a1021 7
int
umass_activate(self, act)
	struct device *self;
	enum devact act;
{
	struct umass_softc *sc = (struct umass_softc *) self;
	int s, rv = 0;
d1023 14
a1036 2
	DPRINTF(UDMASS_USB, ("%s: umass_activate: %d\n",
	    USBDEVNAME(sc->sc_dev), act));
d1038 45
a1082 4
	s = splhigh();
	switch (act) {
	case DVACT_ACTIVATE:
		rv = EOPNOTSUPP;
d1085 9
a1093 8
	case DVACT_DEACTIVATE:
		if (sc->sc_child == NULL || sc->sc_dying)
			break;
		rv = config_deactivate(sc->sc_child);
		DPRINTF(UDMASS_USB, ("%s: umass_activate: child "
		    "returned %d\n", USBDEVNAME(sc->sc_dev), rv));
		if (rv == 0)
			sc->sc_dying = 1;
d1095 14
d1110 29
a1138 2
	splx(s);
	return (rv);
d1144 1
a1144 4
	int s, rv = 0;

	DPRINTF(UDMASS_USB, ("%s: umass_detach: flags 0x%x\n",
	    USBDEVNAME(sc->sc_dev), flags));
d1146 1
a1146 5
	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
	
	if (rv != 0)
		return (rv);
d1149 6
a1154 4
	if (sc->sc_bulkin_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkin_pipe);
	if (sc->sc_bulkout_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkout_pipe);
d1156 2
d1164 14
d1179 1
a1179 8
	if (sc->sc_bulkin_pipe != NULL) {
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
	}
d1184 30
d1216 40
d1257 2
a1258 7
/* Performs a request over a pipe.
 *
 * flags: Can be set to USBD_SHORT_XFER_OK
 * xfer_size: if not null returns the nr. of bytes transferred
 *
 * If the returned error is USBD_STALLED the pipe stall has
 * been cleared again.
d1261 4
a1264 3
usbd_status
umass_usb_transfer(umass_softc_t *sc, usbd_pipe_handle pipe,
		   void *buf, int buflen, int flags, int *xfer_size)
a1265 4
	usbd_xfer_handle xfer;
	usbd_private_handle priv;
	void *buffer;
	int size;
d1268 4
a1271 3
	/* A transfer is done synchronously. We create and schedule the
	 * transfer and then wait for it to complete
	 */
d1273 2
a1274 6
	xfer = usbd_alloc_xfer(usbd_pipe2device_handle(pipe));
	if (xfer == NULL) {
		DPRINTF(UDMASS_USB, ("%s: not enough memory\n",
		    USBDEVNAME(sc->sc_dev)));
		return USBD_NOMEM;
	}
d1276 6
a1281 4
	usbd_setup_xfer(xfer, pipe, 0, buf, buflen,flags, 3000/*ms*/, NULL);
	err = usbd_sync_transfer(xfer);
	if (err) {
		DPRINTF(UDMASS_USB, ("%s: transfer failed: %s\n",
d1283 1
a1283 2
		usbd_free_xfer(xfer);
		return(err);
d1286 24
a1309 1
	usbd_get_xfer_status(xfer, &priv, &buffer, &size, &err);
d1311 3
a1313 2
	if (xfer_size != NULL)
		*xfer_size = size;
d1315 1
a1315 2
	usbd_free_xfer(xfer);
	return(USBD_NORMAL_COMPLETION);
d1318 4
a1321 2
usbd_status
umass_bulk_get_max_lun(umass_softc_t *sc, u_int8_t *maxlun)
a1323 3
	usb_device_request_t req;
	usbd_status err;
	usb_interface_descriptor_t *id;
d1325 2
a1326 1
	*maxlun = 0;		/* Default to 0. */
d1328 2
a1329 1
	DPRINTF(UDMASS_BULK, ("%s: Get Max Lun\n", USBDEVNAME(sc->sc_dev)));
d1331 1
a1331 2
	usbd_interface2device_handle(sc->sc_iface, &dev);
	id = usbd_get_interface_descriptor(sc->sc_iface);
d1333 1
a1333 6
	/* The Get Max Lun command is a class-specific request. */
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_MAX_LUN;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 1);
d1335 1
a1335 6
	err = usbd_do_request(dev, &req, maxlun);
	switch (err) {
	case USBD_NORMAL_COMPLETION:
		DPRINTF(UDMASS_BULK, ("%s: Max Lun %d\n",
		    USBDEVNAME(sc->sc_dev), *maxlun));
		break;
d1337 7
a1343 8
	case USBD_STALLED:
		/*
		 * Device doesn't support Get Max Lun request.
		 */
		err = USBD_NORMAL_COMPLETION;
		DPRINTF(UDMASS_BULK, ("%s: Get Max Lun not supported\n",
		    USBDEVNAME(sc->sc_dev)));
		break;
d1345 6
a1350 8
	case USBD_SHORT_XFER:
		/*
		 * XXX This must mean Get Max Lun is not supported, too!
		 */
		err = USBD_NORMAL_COMPLETION;
		DPRINTF(UDMASS_BULK, ("%s: Get Max Lun SHORT_XFER\n",
		    USBDEVNAME(sc->sc_dev)));
		break;
d1352 4
a1355 6
	default:
		printf("%s: Get Max Lun failed: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		/* XXX Should we port_reset the device? */
		break;
	}
d1357 3
a1359 2
	return (err);
}
d1361 2
a1362 2
usbd_status
umass_bulk_reset(umass_softc_t *sc)
d1365 6
a1370 3
        usb_device_request_t req;
	usbd_status err;
	usb_interface_descriptor_t *id;
d1379 7
d1388 1
a1388 1
	DPRINTF(UDMASS_BULK, ("%s: Reset\n",
d1390 5
d1396 9
a1404 2
	usbd_interface2device_handle(sc->sc_iface, &dev);
	id = usbd_get_interface_descriptor(sc->sc_iface);
d1406 6
a1411 6
	/* the reset command is a class specific interface request */
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_RESET;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 0);
d1413 2
a1414 7
	err = usbd_do_request(dev, &req, 0);
	if (err) {
		printf("%s: Reset failed, %s\n",
			USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		/* XXX we should port_reset the device */
		return(err);
	}
d1416 3
a1418 2
	usbd_clear_endpoint_stall(sc->sc_bulkout_pipe);
	usbd_clear_endpoint_stall(sc->sc_bulkin_pipe);
a1419 1
#if 0
d1421 17
a1437 2
	 * XXX we should convert this into a more friendly delay.
	 * Perhaps a tsleep (or is this routine run from int context?)
a1439 39
	DELAY(2500000 /*us*/);
#else
	usbd_delay_ms(dev, 2500);
#endif

	return(USBD_NORMAL_COMPLETION);
}

/*
 * Do a Bulk-Only transfer with cmdlen bytes from cmd, possibly
 * a data phase of datalen bytes from/to data and finally a csw read
 * phase.
 *
 * If the data direction was inbound a maximum of datalen bytes
 * is stored in the buffer pointed to by data.
 * The status returned is USBD_NORMAL_COMPLETION,
 * USBD_IOERROR, USBD_COMMAND_FAILED.
 * In the last case *residue is set to the residue from the CSW,
 * otherwise to 0.
 *
 * For the functionality of this subroutine see the Mass Storage
 * Spec., the graphs on page 14 and page 19 and beyong (v0.9 of
 * the spec).
 */

usbd_status
umass_bulk_transfer(umass_softc_t *sc, int lun, void *cmd, int cmdlen,
		    void *data, int datalen, int dir, int *residue)
{
	static int dCBWtag = 42;	/* tag to be used in transfers, 
					 * incremented at each transfer */
	usb_bulk_cbw_t cbw;		/* command block wrapper struct */
	usb_bulk_csw_t csw;		/* command status wrapper struct */
	u_int32_t n = 0;		/* number of bytes transported */
	usbd_status err;

#ifdef UMASS_DEBUG
	u_int8_t *c = cmd;

d1441 10
a1450 2
	if (data == NULL && datalen > 0) {	/* no buffer for transfer */
		DPRINTF(UDMASS_BULK, ("%s: no buffer, but datalen > 0 !\n",
d1452 8
a1459 18
		return USBD_IOERROR;
	}

	DPRINTF(UDMASS_BULK, ("%s: cmd: %d bytes (0x%02x%02x%02x%02x%02x%02x%s)"
		", data: %d bytes, dir: %s\n",
		USBDEVNAME(sc->sc_dev),
		cmdlen, c[0], c[1], c[2], c[3], c[4], c[5],
		(cmdlen > 6? "...":""),
		datalen, (dir == DIR_IN? "in":"out")));
#endif

	if (dir == DIR_NONE || datalen == 0) {		/* make sure they correspond */
		datalen = 0;
		dir = DIR_NONE;
	}

	if (residue != NULL)
		*residue = 0;			/* reset residue */
d1462 1
a1462 1
	 * Determine the direction of transferring data and data length.
d1474 5
a1478 5
	 *     Bits 0-6  reserved
	 *     Bit  7    Direction - this bit shall be ignored if the
	 *                           dCBWDataTransferLength field is zero.
	 *               0 = data Out from host to device
	 *               1 = data In from device to host
d1481 21
d1503 2
a1504 13
	/*
	 * Command transport phase
	 */

	/* Fill in the Command Block Wrapper */
	USETDW(cbw.dCBWSignature, CBWSIGNATURE);
	USETDW(cbw.dCBWTag, dCBWtag++);
	USETDW(cbw.dCBWDataTransferLength, datalen);
	/* we do not check for DIR_NONE below (see text on dCBWFlags above) */
	cbw.bCBWFlags = (dir == DIR_IN? CBWFLAGS_IN:CBWFLAGS_OUT);
	cbw.bCBWLUN = lun;
	cbw.bCDBLength = cmdlen;
	bcopy(cmd, cbw.CBWCDB, cmdlen);
d1507 4
a1510 12
	err = umass_usb_transfer(sc, sc->sc_bulkout_pipe,
				&cbw, USB_BULK_CBW_SIZE, 0, NULL);
	if (err) {
		DPRINTF(UDMASS_BULK, ("%s: failed to send CBW\n",
		         USBDEVNAME(sc->sc_dev)));
		/* If the device detects that the CBW is invalid, then the
		 * device may STALL both bulk endpoints and require a
		 * Bulk-Only MS Reset
		 */
		if (!sc->sc_dying)
			umass_bulk_reset(sc);
		return(USBD_IOERROR);
d1512 1
d1515 6
a1520 3
	/*
	 * Data transport phase (only if there is data to be sent/received)
	 */
d1522 2
a1523 21
	if (dir == DIR_IN) {
		/* we allow short transfers for bulk-in pipes */
		err = umass_usb_transfer(sc, sc->sc_bulkin_pipe,
					data, datalen,
					USBD_SHORT_XFER_OK, &n);
		if (err)
			DPRINTF(UDMASS_BULK, ("%s: failed to receive data, "
				"(%d bytes, n = %d), %s\n", 
				USBDEVNAME(sc->sc_dev),
				datalen, n, usbd_errstr(err)));
	} else if (dir == DIR_OUT) {
		err = umass_usb_transfer(sc, sc->sc_bulkout_pipe,
					data, datalen, 0, &n);
		if (err)
			DPRINTF(UDMASS_BULK, ("%s: failed to send data, "
				"(%d bytes, n = %d), %s\n", 
				USBDEVNAME(sc->sc_dev),
				datalen, n, usbd_errstr(err)));
	}
	if (err && err != USBD_STALLED)
		return(USBD_IOERROR);
d1525 2
d1529 8
a1536 1
	 * Status transport phase
d1539 18
a1556 9
	/* Read the Command Status Wrapper via bulk-in endpoint. */
	err = umass_usb_transfer(sc, sc->sc_bulkin_pipe,
				&csw, USB_BULK_CSW_SIZE, 0, NULL);
	/* Try again if the bulk-in pipe was stalled */
	if (err == USBD_STALLED) {
		err = usbd_clear_endpoint_stall(sc->sc_bulkin_pipe);
		if (!err) {
			err = umass_usb_transfer(sc, sc->sc_bulkin_pipe,
				  &csw, USB_BULK_CSW_SIZE, 0, NULL);
a1557 3
	}
	if (err && err != USBD_STALLED)
		return(USBD_IOERROR);
d1559 18
a1576 3
	/*
	 * Check the CSW for status and validity, and check for fatal errors
	 */
d1578 1
a1578 20
	/* Invalid CSW: Wrong signature or wrong tag might indicate
	 * that the device is confused -> reset it.
	 * Other fatal errors: STALL on read of CSW and Phase error
	 * or unknown status.
	 */
	if (err == USBD_STALLED
	    || UGETDW(csw.dCSWSignature) != CSWSIGNATURE
	    || UGETDW(csw.dCSWTag) != UGETDW(cbw.dCBWTag)
	    || csw.bCSWStatus == CSWSTATUS_PHASE
	    || csw.bCSWStatus > CSWSTATUS_PHASE) {
		if (err) {
			printf("%s: failed to read CSW, %s\n",
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		} else if (csw.bCSWStatus == CSWSTATUS_PHASE) {
			printf("%s: Phase Error, residue = %d, n = %d\n",
				USBDEVNAME(sc->sc_dev),
				UGETDW(csw.dCSWDataResidue), n);
		} else if (csw.bCSWStatus > CSWSTATUS_PHASE) {
			printf("%s: Unknown status %d in CSW\n",
				USBDEVNAME(sc->sc_dev), csw.bCSWStatus);
d1580 36
a1615 4
			printf("%s: invalid CSW, sig = 0x%08x, tag = %d (!= %d)\n",
				USBDEVNAME(sc->sc_dev),
				UGETDW(csw.dCSWSignature),
				UGETDW(csw.dCSWTag), UGETDW(cbw.dCBWTag));
a1616 3
		umass_bulk_reset(sc);
		return(USBD_IOERROR);
	}
d1618 41
a1658 9
	if (csw.bCSWStatus == CSWSTATUS_FAILED) {
		DPRINTF(UDMASS_BULK, ("%s: Command Failed, "
			"residue = %d, n = %d\n",
			USBDEVNAME(sc->sc_dev),
			UGETDW(csw.dCSWDataResidue), n));
		if (residue != NULL)
			*residue = UGETDW(csw.dCSWDataResidue);
		return(USBD_COMMAND_FAILED);
	}
d1660 7
a1666 4
	/*
	 * XXX a residue not equal to 0 might indicate that something
	 * is wrong. Does CAM high level drivers check this for us?
	 */
d1668 24
a1691 2
	return(USBD_NORMAL_COMPLETION);
}
d1693 1
d1695 9
a1703 3
/*
 * SCSIPI specific functions
 */
d1705 8
a1712 9
int
umass_scsipi_scsi_cmd(xs)
	struct scsipi_xfer *xs;
{
	struct scsipi_link *sc_link = xs->sc_link;
	struct umass_softc *sc = sc_link->adapter_softc;
	int residue, dir;
	usbd_status err;
	struct scsipi_sense sense_cmd;
d1714 2
a1715 3
	DPRINTF(UDMASS_SCSI, ("%s: umass_scsi_cmd %d:%d\n",
	    USBDEVNAME(sc->sc_dev),
	    sc_link->scsipi_scsi.target, sc_link->scsipi_scsi.lun));
d1717 6
a1722 9
	if (sc->sc_dying) {
		xs->xs_status |= XS_STS_DONE;
		xs->error = XS_DRIVER_STUFFUP;
		scsipi_done(xs);
		if (xs->xs_control & XS_CTL_POLL)
			return (COMPLETE);
		else
			return (SUCCESSFULLY_QUEUED);
	}
d1724 610
d2335 762
a3096 2
	if (sc_link->scsipi_scsi.target != UMASS_SCSIID_DEVICE) {
		DPRINTF(UDMASS_SCSI, ("%s: Wrong SCSI ID %d\n",
d3100 1
a3100 1
		return (COMPLETE);
d3104 14
d3120 1
a3120 1
		switch (xs->xs_control & (XS_CTL_DATA_IN|XS_CTL_DATA_OUT)) {
d3130 5
a3134 2
	/* Make sure we don't lose our softc. */
	sc->sc_refcnt++;
d3136 12
a3147 3
#if defined(__OpenBSD__)
	err = umass_bulk_transfer(sc, sc_link->lun,
	    xs->cmd, xs->cmdlen, xs->data, xs->datalen, dir, &residue);
d3149 1
a3149 2
	err = umass_bulk_transfer(sc, sc_link->scsipi_scsi.lun,
	    xs->cmd, xs->cmdlen, xs->data, xs->datalen, dir, &residue);
d3151 28
d3180 56
a3235 10
	/*
	 * FAILED commands are supposed to be SCSI failed commands
	 * and are therefore considered to be successfull CDW/CSW  
	 * transfers.  PHASE errors are more serious and should return
	 * an error to the SCSIPI system.
	 *
	 * XXX This is however more based on empirical evidence than on
	 * hard proof from the Bulk-Only spec.
	 */
	if (err == USBD_NORMAL_COMPLETION) {
d3237 1
a3237 7
	} else if (sc->sc_dying) {
		/* We are being detached, no use talking to the device. */
		xs->error = XS_DRIVER_STUFFUP;
	} else {
		DPRINTF(UDMASS_USB|UDMASS_SCSI, ("%s: bulk transfer completed "
		    "with error %s\n", USBDEVNAME(sc->sc_dev),
		    usbd_errstr(err)));
d3239 7
a3245 9
		/*
		 * Probably have a CHECK CONDITION here.  Issue a
		 * REQUEST SENSE.
		 */
		memset(&sense_cmd, 0, sizeof(sense_cmd));
		sense_cmd.opcode = REQUEST_SENSE;
#if defined(__OpenBSD__)
		sense_cmd.byte2 = sc_link->lun <<
		    SCSI_CMD_LUN_SHIFT;
d3247 2
a3248 1
		sense_cmd.byte2 = sc_link->scsipi_scsi.lun <<
d3250 1
a3250 2
#endif
		sense_cmd.length = sizeof(xs->sense);
d3252 5
a3256 2
#if defined(__OpenBSD__)
		if ((err = umass_bulk_transfer(sc, sc_link->lun,
d3258 1
a3258 1
		if ((err = umass_bulk_transfer(sc, sc_link->scsipi_scsi.lun,
d3260 12
a3271 8
		    (struct scsipi_generic *)&sense_cmd, sizeof(sense_cmd),
		    &xs->sense, sizeof(xs->sense), DIR_IN, NULL)) !=
		    USBD_NORMAL_COMPLETION) {
			DPRINTF(UDMASS_SCSI, ("%s: REQUEST SENSE failed: %s\n",
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
			xs->error = XS_DRIVER_STUFFUP;	/* XXX */
		} else
			xs->error = XS_SENSE;
a3272 1
	xs->resid = residue;
d3274 5
a3278 2
	DPRINTF(UDMASS_SCSI, ("%s: umass_scsi_cmd: error = %d, resid = 0x%x\n",
	    USBDEVNAME(sc->sc_dev), xs->error, xs->resid));
d3280 1
a3280 1
	xs->xs_status |= XS_STS_DONE;
d3282 12
d3295 2
a3296 3
	/* We are done with the softc for now. */
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d3298 22
a3319 8
	/*
	 * XXXJRT We must return successfully queued if we're an
	 * XXXJRT `asynchronous' command, otherwise `xs' will be
	 * XXXJRT freed twice: once in scsipi_done(), and once in
	 * XXXJRT scsi_scsipi_cmd().
	 */
	if ((xs->xs_control & XS_CTL_POLL) == 0)
		return (SUCCESSFULLY_QUEUED);
d3321 3
a3323 1
	return (COMPLETE);
d3326 5
a3330 3
void
umass_scsipi_minphys(bp)
	struct buf *bp;
d3332 57
a3388 3

	/* No limit here. */
	minphys(bp);
d3390 2
@

