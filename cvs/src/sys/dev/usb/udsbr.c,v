head	1.27;
access;
symbols
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.8
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.8
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.4
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	SMP:1.5.0.8
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	UBC:1.5.0.4
	UBC_SYNC_B:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.27
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.26;
commitid	xlY19nmD0cBL53l1;

1.26
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.25;
commitid	p4LJxGKbi0BU2cG6;

1.25
date	2013.11.07.12.06.25;	author pirofti;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches
	1.5.4.1
	1.5.8.1;
next	1.4;

1.4
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.07.09.18.37.04;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.5.4.1
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.19.22.24.07;	author tedu;	state Exp;
branches;
next	;

1.5.8.1
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@/*	$OpenBSD: udsbr.c,v 1.26 2015/03/14 03:38:49 jsg Exp $	*/
/*	$NetBSD: udsbr.c,v 1.7 2002/07/11 21:14:27 augustss Exp $	*/

/*
 * Copyright (c) 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the D-Link DSB-R100 FM radio.
 * I apologize for the magic hex constants, but this is what happens
 * when you have to reverse engineer the driver.
 * Parts of the code borrowed from Linux and parts from Warner Losh's
 * FreeBSD driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <sys/radioio.h>
#include <dev/radio_if.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/usbdevs.h>

#ifdef UDSBR_DEBUG
#define DPRINTF(x)	do { if (udsbrdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (udsbrdebug>(n)) printf x; } while (0)
int	udsbrdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UDSBR_CONFIG_NO		1

int     udsbr_get_info(void *, struct radio_info *);
int     udsbr_set_info(void *, struct radio_info *);

struct radio_hw_if udsbr_hw_if = {
	NULL, /* open */
	NULL, /* close */
	udsbr_get_info,
	udsbr_set_info,
	NULL
};

struct udsbr_softc {
 	struct device		 sc_dev;
	struct usbd_device	*sc_udev;

	char			 sc_mute;
	char			 sc_vol;
	u_int32_t		 sc_freq;

	struct device		*sc_child;
};

int	udsbr_req(struct udsbr_softc *sc, int ureq, int value, int index);
void	udsbr_start(struct udsbr_softc *sc);
void	udsbr_stop(struct udsbr_softc *sc);
void	udsbr_setfreq(struct udsbr_softc *sc, int freq);
int	udsbr_status(struct udsbr_softc *sc);

int udsbr_match(struct device *, void *, void *); 
void udsbr_attach(struct device *, struct device *, void *); 
int udsbr_detach(struct device *, int); 
int udsbr_activate(struct device *, int); 

struct cfdriver udsbr_cd = { 
	NULL, "udsbr", DV_DULL 
}; 

const struct cfattach udsbr_ca = { 
	sizeof(struct udsbr_softc), 
	udsbr_match, 
	udsbr_attach, 
	udsbr_detach, 
	udsbr_activate, 
};

int
udsbr_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	DPRINTFN(50,("udsbr_match\n"));

	if (uaa->iface == NULL || uaa->configno != UDSBR_CONFIG_NO)
		return (UMATCH_NONE);

	if (uaa->vendor != USB_VENDOR_CYPRESS ||
	    uaa->product != USB_PRODUCT_CYPRESS_FMRADIO)
		return (UMATCH_NONE);
	return (UMATCH_VENDOR_PRODUCT);
}

void
udsbr_attach(struct device *parent, struct device *self, void *aux)
{
	struct udsbr_softc	*sc = (struct udsbr_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct usbd_device	*dev = uaa->device;

	sc->sc_udev = dev;
	sc->sc_child = radio_attach_mi(&udsbr_hw_if, sc, &sc->sc_dev);
}

int
udsbr_detach(struct device *self, int flags)
{
	struct udsbr_softc *sc = (struct udsbr_softc *)self;
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);

	return (rv);
}

int
udsbr_activate(struct device *self, int act)
{
	struct udsbr_softc *sc = (struct udsbr_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
		break;
	}
	return (rv);
}

int
udsbr_req(struct udsbr_softc *sc, int ureq, int value, int index)
{
	usb_device_request_t req;
	usbd_status err;
	u_char data;

	DPRINTFN(1,("udsbr_req: ureq=0x%02x value=0x%04x index=0x%04x\n",
		    ureq, value, index));
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = ureq;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, 1);
	err = usbd_do_request(sc->sc_udev, &req, &data);
	if (err) {
		printf("%s: request failed err=%d\n", sc->sc_dev.dv_xname,
		       err);
	}
	return !(data & 1);
}

void
udsbr_start(struct udsbr_softc *sc)
{
	(void)udsbr_req(sc, 0x00, 0x0000, 0x00c7);
	(void)udsbr_req(sc, 0x02, 0x0001, 0x0000);
}

void
udsbr_stop(struct udsbr_softc *sc)
{
	(void)udsbr_req(sc, 0x00, 0x0016, 0x001c);
	(void)udsbr_req(sc, 0x02, 0x0000, 0x0000);
}

void
udsbr_setfreq(struct udsbr_softc *sc, int freq)
{
	DPRINTF(("udsbr_setfreq: setfreq=%d\n", freq));
        /*
         * Freq now is in Hz.  We need to convert it to the frequency
         * that the radio wants.  This frequency is 10.7MHz above
         * the actual frequency.  We then need to convert to
         * units of 12.5kHz.  We add one to the IFM to make rounding
         * easier.
         */
        freq = (freq * 1000 + 10700001) / 12500;
	(void)udsbr_req(sc, 0x01, (freq >> 8) & 0xff, freq & 0xff);
	(void)udsbr_req(sc, 0x00, 0x0096, 0x00b7);
	usbd_delay_ms(sc->sc_udev, 240); /* wait for signal to settle */
}

int
udsbr_status(struct udsbr_softc *sc)
{
	return (udsbr_req(sc, 0x00, 0x0000, 0x0024));
}


int
udsbr_get_info(void *v, struct radio_info *ri)
{
	struct udsbr_softc *sc = v;

	ri->mute = sc->sc_mute;
	ri->volume = sc->sc_vol ? 255 : 0;
	ri->caps = RADIO_CAPS_DETECT_STEREO;
	ri->rfreq = 0;
	ri->lock = 0;
	ri->freq = sc->sc_freq;
	ri->info = udsbr_status(sc) ? RADIO_INFO_STEREO : 0;

	return (0);
}

int
udsbr_set_info(void *v, struct radio_info *ri)
{
	struct udsbr_softc *sc = v;

	sc->sc_mute = ri->mute != 0;
	sc->sc_vol = ri->volume != 0;
	sc->sc_freq = ri->freq;
	udsbr_setfreq(sc, sc->sc_freq);

	if (sc->sc_mute || sc->sc_vol == 0)
		udsbr_stop(sc);
	else
		udsbr_start(sc);

	return (0);
}
@


1.26
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.25 2013/11/07 12:06:25 pirofti Exp $	*/
d117 1
a117 1
	if (uaa->iface != NULL)
a131 10
	usbd_status		err;

	DPRINTFN(10,("udsbr_attach: sc=%p\n", sc));

	err = usbd_set_config_no(dev, UDSBR_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}
a133 3

	DPRINTFN(10, ("udsbr_attach: %p\n", sc->sc_udev));

@


1.25
log
@Kill sc_dying. Nobody was using it anyway.

"just kill it" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.24 2013/04/15 09:23:02 mglocker Exp $	*/
a42 1
#include <sys/kernel.h>
@


1.24
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.23 2011/07/03 15:47:17 matthew Exp $	*/
a85 2

	char			 sc_dying;
a170 1
		sc->sc_dying = 1;
@


1.23
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.22 2011/01/25 20:03:36 jakemsr Exp $	*/
d79 1
a79 1
	usbd_device_handle	 sc_udev;
d134 1
a134 1
	usbd_device_handle	dev = uaa->device;
@


1.22
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.21 2009/10/13 19:33:17 pirofti Exp $	*/
a171 3
	case DVACT_ACTIVATE:
		break;

@


1.21
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.20 2008/06/26 05:42:18 ray Exp $	*/
a149 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a160 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.19 2007/10/11 18:33:14 deraadt Exp $	*/
d99 1
a99 1
int udsbr_activate(struct device *, enum devact); 
d172 1
a172 1
udsbr_activate(struct device *self, enum devact act)
@


1.19
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.18 2007/06/14 10:11:15 mbalmer Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.17 2007/06/13 06:25:03 mbalmer Exp $	*/
a141 1
	char			*devinfop;
a144 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.17
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.16 2007/06/12 16:26:36 mbalmer Exp $	*/
d103 16
a118 1
USB_DECLARE_DRIVER(udsbr);
@


1.16
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.15 2007/06/10 14:49:01 mbalmer Exp $	*/
d85 2
a86 2
 	struct device		sc_dev;
	usbd_device_handle	sc_udev;
d88 3
a90 3
	char			sc_mute;
	char			sc_vol;
	u_int32_t		sc_freq;
d94 1
a94 1
	char			sc_dying;
d97 5
a101 6
	int	udsbr_req(struct udsbr_softc *sc, int ureq, int value,
			  int index);
	void	udsbr_start(struct udsbr_softc *sc);
	void	udsbr_stop(struct udsbr_softc *sc);
	void	udsbr_setfreq(struct udsbr_softc *sc, int freq);
	int	udsbr_status(struct udsbr_softc *sc);
@


1.15
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.14 2007/06/10 10:53:48 mbalmer Exp $	*/
d170 1
a170 1
udsbr_activate(device_ptr_t self, enum devact act)
@


1.14
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.13 2007/06/06 19:25:49 mk Exp $	*/
d134 1
a134 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d140 1
a140 1
		    USBDEVNAME(sc->sc_dev));
d204 1
a204 1
		printf("%s: request failed err=%d\n", USBDEVNAME(sc->sc_dev),
@


1.13
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.12 2007/06/05 08:43:55 mbalmer Exp $	*/
d149 1
a149 1
			   USBDEV(sc->sc_dev));
d151 1
a151 1
	sc->sc_child = radio_attach_mi(&udsbr_hw_if, sc, USBDEV(sc->sc_dev));
d164 1
a164 1
			   USBDEV(sc->sc_dev));
@


1.12
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.11 2007/05/27 04:00:25 jsg Exp $	*/
d85 1
a85 1
 	USBBASEDEVICE		sc_dev;
@


1.11
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.10 2007/05/21 05:40:28 jsg Exp $	*/
d73 2
a74 2
Static	int     udsbr_get_info(void *, struct radio_info *);
Static	int     udsbr_set_info(void *, struct radio_info *);
d97 1
a97 1
Static	int	udsbr_req(struct udsbr_softc *sc, int ureq, int value,
d99 4
a102 4
Static	void	udsbr_start(struct udsbr_softc *sc);
Static	void	udsbr_stop(struct udsbr_softc *sc);
Static	void	udsbr_setfreq(struct udsbr_softc *sc, int freq);
Static	int	udsbr_status(struct udsbr_softc *sc);
@


1.10
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.9 2006/06/23 06:27:11 miod Exp $	*/
d106 2
a107 1
USB_MATCH(udsbr)
d109 1
a109 1
	USB_MATCH_START(udsbr, uaa);
d122 2
a123 1
USB_ATTACH(udsbr)
d125 2
a126 1
	USB_ATTACH_START(udsbr, sc, uaa);
d134 1
a134 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d141 1
a141 1
		USB_ATTACH_ERROR_RETURN;
a151 2

	USB_ATTACH_SUCCESS_RETURN;
d154 2
a155 1
USB_DETACH(udsbr)
d157 1
a157 1
	USB_DETACH_START(udsbr, sc);
@


1.9
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.8 2005/08/01 05:36:48 brad Exp $	*/
d63 2
a64 2
#define DPRINTF(x)	do { if (udsbrdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (udsbrdebug>(n)) logprintf x; } while (0)
@


1.8
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.7 2004/07/08 22:18:44 deraadt Exp $	*/
a175 1
		return (EOPNOTSUPP);
@


1.7
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.6 2003/05/07 04:33:33 deraadt Exp $	*/
d125 1
a125 1
	char			devinfo[1024];
d130 1
a130 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d132 2
a133 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.6
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.5 2002/07/25 04:07:32 nate Exp $	*/
d63 2
a64 2
#define DPRINTF(x)	if (udsbrdebug) logprintf x
#define DPRINTFN(n,x)	if (udsbrdebug>(n)) logprintf x
@


1.5
log
@update $NetBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.4 2002/07/25 02:18:10 nate Exp $	*/
d130 1
a130 1
	usbd_devinfo(dev, 0, devinfo);
@


1.5.8.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.5 2002/07/25 04:07:32 nate Exp $	*/
d130 1
a130 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.5.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@sync
@
text
@d130 1
a130 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.4
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: udsbr.c,v 1.3 2002/07/09 18:37:04 nate Exp $	*/
/*	$NetBSD: udsbr.c,v 1.6 2002/02/12 10:51:49 tron Exp $	*/
@


1.3
log
@driver for D-Link DSB-R100 FM Radio
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d232 1
a232 1
         * easier. 
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: udsbr.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

