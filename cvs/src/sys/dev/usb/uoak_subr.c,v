head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.2
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2017.01.09.14.44.28;	author mpi;	state Exp;
branches;
next	1.7;
commitid	UdDbQS8WFHHpnq1k;

1.7
date	2015.05.25.12.53.12;	author jsg;	state Exp;
branches;
next	1.6;
commitid	2wO7pJjjDzkkYiAL;

1.6
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.5;
commitid	p4LJxGKbi0BU2cG6;

1.5
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.4;
commitid	L2P5oN9ppxqXZsYS;

1.4
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2012.10.19.14.52.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.20.13.52.11;	author yuo;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Remove unneeded <sys/malloc.h> from Michael W. Bombardieri.
@
text
@/*	$OpenBSD: uoak_subr.c,v 1.7 2015/05/25 12:53:12 jsg Exp $   */

/*
 * Copyright (c) 2012 Yojiro UO <yuo@@nui.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* TORADEX OAK seriese sensors: common functions */ 
/* http://developer.toradex.com/files/toradex-dev/uploads/media/Oak/Oak_ProgrammingGuide.pdf */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/sensors.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>
#include "uoak.h"

#define UOAK_RETRY_DELAY	 100 /* 100ms, XXX too long? */
#define UOAK_RESPONSE_DELAY	 10  /* 10ms,  XXX too short? */
/*
 *  basic procedure to issue command to the OAK device.
 *  1) check the device is ready to accept command.
 *     if a report of a FEATURE_REPORT request is not start 0xff,
 *     wait for a while, and retry till the reponse start with 0xff.
 *  2) issue command.  (set or get)
 *  3) if the command will response, wait for a while, and issue
 *     FEATURE_REPORT. leading 0xff indicate the response is valid.
 *     if the first byte is not 0xff, retry.
 */
int
uoak_check_device_ready(struct uoak_softc *sc)
{
	int actlen;

	actlen = uhidev_get_report(sc->sc_hdev->sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev->sc_report_id, &sc->sc_buf, sc->sc_flen);
	if (actlen != sc->sc_flen)
		return EIO;

	if (sc->sc_buf[0] != 0xff)
		return -1;

	return 0;
}

int
uoak_set_cmd(struct uoak_softc *sc)
{
	int actlen;
	sc->sc_rcmd.dir = OAK_SET;

	while (uoak_check_device_ready(sc) < 0)
		usbd_delay_ms(sc->sc_udev, UOAK_RETRY_DELAY);

	actlen = uhidev_set_report(sc->sc_hdev->sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev->sc_report_id, &sc->sc_rcmd, sc->sc_flen);
	if (actlen != sc->sc_flen)
		return EIO;

	return 0;
}

int
uoak_get_cmd(struct uoak_softc *sc)
{
	int actlen;
	sc->sc_rcmd.dir = OAK_GET;

	/* check the device is ready to request */
	while (uoak_check_device_ready(sc) < 0) 
		usbd_delay_ms(sc->sc_udev, UOAK_RETRY_DELAY);

	/* issue request */
	actlen = uhidev_set_report(sc->sc_hdev->sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev->sc_report_id, &sc->sc_rcmd, sc->sc_flen);
	if (actlen != sc->sc_flen)
		return EIO;

	/* wait till the device ready to return the request */
	while (uoak_check_device_ready(sc) < 0) 
		usbd_delay_ms(sc->sc_udev, UOAK_RESPONSE_DELAY); 

	return 0;
}

/*
 * Functions to access device configurations.
 * OAK sensor have some storages to store its configuration.
 * (RAM, FLASH and others)
 */
int
uoak_get_device_name(struct uoak_softc *sc, enum uoak_target target)
{
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x15;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_DEVNAME);

	if (uoak_get_cmd(sc) < 0)
		return EIO;

	strlcpy(sc->sc_config[target].devname, sc->sc_buf+1, 
	    sizeof(sc->sc_config[target].devname));
	return 0;
}

int
uoak_get_report_mode(struct uoak_softc *sc, enum uoak_target target)
{
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x1;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_REPORTMODE);

	if (uoak_get_cmd(sc) < 0)
		return EIO;

	sc->sc_config[target].report_mode = sc->sc_buf[1];
	return 0;
}

int
uoak_get_report_rate(struct uoak_softc *sc, enum uoak_target target)
{
	uint16_t result;
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x2;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_REPORTRATE);

	if (uoak_get_cmd(sc) < 0)
		return EIO;

	result = (sc->sc_buf[2] << 8) + sc->sc_buf[1];
	sc->sc_config[target].report_rate = result;

	return 0;
}

int
uoak_get_sample_rate(struct uoak_softc *sc, enum uoak_target target)
{
	uint16_t result;
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x2;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_SAMPLERATE);

	if (uoak_get_cmd(sc) < 0)
		return EIO;

	result = (sc->sc_buf[2] << 8) + sc->sc_buf[1];
	sc->sc_config[target].sample_rate = result;

	return 0;
}

int
uoak_set_sample_rate(struct uoak_softc *sc, enum uoak_target target, int rate)
{
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x2;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_SAMPLERATE);

#if 0
	sc->sc_rcmd.val[0] = (uint8_t)(rate & 0xff);
	sc->sc_rcmd.val[1] = (uint8_t)((rate >> 8) & 0xff)
#else
	USETW(sc->sc_rcmd.val, rate);
#endif

	if (uoak_set_cmd(sc) < 0)
		return EIO;

	return 0;
}

/*
 * LED I/O
 */
int
uoak_led_status(struct uoak_softc *sc, enum uoak_target target, uint8_t *mode)
{
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));
	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x1;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_LEDMODE);

	if (uoak_get_cmd(sc) < 0)
		return EIO;

	*mode =  sc->sc_buf[1];
	return 0;
}

int
uoak_led_ctrl(struct uoak_softc *sc, enum uoak_target target, uint8_t mode)
{
	memset(&sc->sc_rcmd, 0, sizeof(struct uoak_rcmd));

	sc->sc_rcmd.target = target;
	sc->sc_rcmd.datasize = 0x1;
	USETW(&sc->sc_rcmd.cmd, OAK_CMD_LEDMODE);
	sc->sc_rcmd.val[0] = mode;

	return uoak_set_cmd(sc);
}

/* device setting: query and pretty print */
void
uoak_get_devinfo(struct uoak_softc *sc)
{
	/* get device serial# */
	usbd_fill_deviceinfo(sc->sc_udev, &sc->sc_udi, 1);
}

void
uoak_get_setting(struct uoak_softc *sc, enum uoak_target target)
{
	/* get device level */
	(void)uoak_get_device_name(sc, target);

	/* get global sensor configuration */
	(void)uoak_get_report_mode(sc, target);
	(void)uoak_get_sample_rate(sc, target);
	(void)uoak_get_report_rate(sc, target);

	/* get device spcecific information */
	if (sc->sc_methods->dev_setting != NULL)
		sc->sc_methods->dev_setting(sc->sc_parent, target);
}

void
uoak_print_devinfo(struct uoak_softc *sc)
{
	printf(": serial %s", sc->sc_udi.udi_serial);
}

void
uoak_print_setting(struct uoak_softc *sc, enum uoak_target target)
{
	switch (sc->sc_config[target].report_mode) {
	case OAK_REPORTMODE_AFTERSAMPLING:
		printf(" sampling %dms",
		    sc->sc_config[target].sample_rate);
		break;
	case OAK_REPORTMODE_AFTERCHANGE:
		printf(" reports changes");
		break;
	case OAK_REPORTMODE_FIXEDRATE:
		printf(" rate %dms", 
		    sc->sc_config[target].report_rate);
		break;
	default:
		printf(" unknown sampling");
		break;
	}

	/* print device spcecific information */
	if (sc->sc_methods->dev_print != NULL)
		sc->sc_methods->dev_print(sc->sc_parent, target);
	printf("\n");
}

void
uoak_sensor_attach(struct uoak_softc *sc, struct uoak_sensor *s,
  enum sensor_type type)
{
	if (s == NULL)
		return;

	s->avg.type = type;
	s->max.type = type;
	s->min.type = type;
	s->avg.flags |= SENSOR_FINVALID;
	s->max.flags |= SENSOR_FINVALID;
	s->min.flags |= SENSOR_FINVALID;

	(void)snprintf(s->avg.desc, sizeof(s->avg.desc),
	    "avg(#%s)", sc->sc_udi.udi_serial);
	(void)snprintf(s->max.desc, sizeof(s->max.desc),
	    "max(#%s)", sc->sc_udi.udi_serial);
	(void)snprintf(s->min.desc, sizeof(s->min.desc),
	    "min(#%s)", sc->sc_udi.udi_serial);

	sensor_attach(sc->sc_sensordev, &s->avg);
	sensor_attach(sc->sc_sensordev, &s->max);
	sensor_attach(sc->sc_sensordev, &s->min);
}

void
uoak_sensor_detach(struct uoak_softc *sc, struct uoak_sensor *s)
{
	if (s == NULL)
		return;

	sensor_attach(sc->sc_sensordev, &s->avg);
	sensor_attach(sc->sc_sensordev, &s->max);
	sensor_attach(sc->sc_sensordev, &s->min);
}

void
uoak_sensor_update(struct uoak_sensor *s, int val)
{
	if (s == NULL)
		return;

	/* reset */
	if (s->count == 0) {
		s->vmax = s->vmin = s->vavg = val;
		s->count++;
		return;
	}

	/* update min/max */
	if (val > s->vmax)
		s->vmax = val;
	else if (val < s->vmin)
		s->vmin = val;

	/* calc average */
	s->vavg = (s->vavg * s->count + val) / (s->count + 1);

	s->count++;
}

void
uoak_sensor_refresh(struct uoak_sensor *s, int mag, int offset)
{
	if (s == NULL)
		return;
	/* update value */
	s->avg.value = s->vavg * mag + offset;
	s->max.value = s->vmax * mag + offset;
	s->min.value = s->vmin * mag + offset;

	/* update flag */
	s->avg.flags &= ~SENSOR_FINVALID;
	s->max.flags &= ~SENSOR_FINVALID;
	s->min.flags &= ~SENSOR_FINVALID;
	s->count = 0;
}

@


1.7
log
@Make this build when using the __STRICT_ALIGNMENT version of USETW.
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.6 2015/03/14 03:38:50 jsg Exp $   */
a24 1
#include <sys/malloc.h>
@


1.6
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.5 2014/12/11 18:39:27 mpi Exp $   */
d190 1
a190 1
	USETW(&sc->sc_rcmd.val, rate);
@


1.5
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.4 2014/04/15 09:14:27 mpi Exp $   */
a35 1
#include <dev/usb/hid.h>
@


1.4
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.3 2013/03/28 03:58:03 tedu Exp $   */
d54 5
a58 2
	if (uhidev_get_report(sc->sc_hdev, UHID_FEATURE_REPORT,
	        sc->sc_hdev->sc_report_id, &sc->sc_buf, sc->sc_flen))
d70 1
d76 3
a78 2
	if (uhidev_set_report(sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev->sc_report_id, &sc->sc_rcmd, sc->sc_flen))
d87 1
d95 3
a97 2
	if (uhidev_set_report(sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev->sc_report_id, &sc->sc_rcmd, sc->sc_flen))
@


1.3
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.2 2012/10/19 14:52:38 deraadt Exp $   */
d55 1
a55 1
	    &sc->sc_buf, sc->sc_flen))
d73 1
a73 1
	    &sc->sc_rcmd, sc->sc_flen))
d90 1
a90 1
	    &sc->sc_rcmd, sc->sc_flen))
@


1.2
log
@small cleanups and output prettying
ok yuo matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: uoak_subr.c,v 1.1 2012/09/20 13:52:11 yuo Exp $   */
a22 1
#include <sys/proc.h>
@


1.1
log
@add device driver for Toradex OAK usb sensors:
 uoaklux(4): Toradex OAK LUX, USB illuminance sensor
 uoakrh(4) : Toradex OAK RH, USB temperature and relative humidity sensor
 uoakv(4)  : Toradex OAK V, USB +/- 10V 8channel ADC interface

ok deraadet@@
@
text
@d1 1
a1 1
/*	$OpenBSD:$   */
d56 1
a56 1
    		&sc->sc_buf, sc->sc_flen))
d74 1
a74 1
    		&sc->sc_rcmd, sc->sc_flen))
d91 1
a91 1
    		&sc->sc_rcmd, sc->sc_flen))
d118 1
a118 1
	  sizeof(sc->sc_config[target].devname));
d236 1
a236 1
	/* get device lavel */
d252 1
a252 2
	printf(", serial#:%s", sc->sc_udi.udi_serial);
	printf("\n");
d258 4
a261 6
	printf("  device label:%s", sc->sc_config[target].devname);
	printf(", report mode:");
	switch(sc->sc_config[target].report_mode) {
	case OAK_REPORTMODE_AFTERSAMPING:
		printf("after sampling (rate:%d ms).",
		  sc->sc_config[target].sample_rate);
d264 1
a264 1
		printf("after change.");
d267 2
a268 2
		printf("fixed rate (rate:%d ms).", 
		  sc->sc_config[target].report_rate);
d271 1
a271 1
		printf("unknown.");
a273 1
	printf("\n");
d278 1
d288 1
a288 1
	s->ave.type = type;
d291 1
a291 1
	s->ave.flags |= SENSOR_FINVALID;
d295 2
a296 2
	(void)snprintf(s->ave.desc, sizeof(s->ave.desc),
  	  "ave(#%s)", sc->sc_udi.udi_serial);
d298 1
a298 1
	  "max(#%s)", sc->sc_udi.udi_serial);
d300 1
a300 1
  	  "min(#%s)", sc->sc_udi.udi_serial);
d302 1
a302 1
	sensor_attach(sc->sc_sensordev, &s->ave);
d313 1
a313 1
	sensor_attach(sc->sc_sensordev, &s->ave);
d326 1
a326 1
		s->vmax = s->vmin = s->vave = val;
d337 2
a338 2
	/* calc avelage */
	s->vave = (s->vave * s->count + val) / (s->count + 1);
d349 1
a349 1
	s->ave.value = s->vave * mag + offset;
d354 1
a354 1
	s->ave.flags &= ~SENSOR_FINVALID;
@

