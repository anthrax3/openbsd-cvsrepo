head	1.143;
access;
symbols
	OPENBSD_6_2:1.143.0.4
	OPENBSD_6_2_BASE:1.143
	OPENBSD_6_1:1.142.0.4
	OPENBSD_6_1_BASE:1.142
	OPENBSD_6_0:1.138.0.8
	OPENBSD_6_0_BASE:1.138
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.138.0.4
	OPENBSD_5_8_BASE:1.138
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.129.0.4
	OPENBSD_5_6_BASE:1.129
	OPENBSD_5_5:1.105.0.4
	OPENBSD_5_5_BASE:1.105
	OPENBSD_5_4:1.99.0.2
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.92.0.2
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.90.0.6
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.89.0.2
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.70.0.4
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.69.0.2
	OPENBSD_4_5_BASE:1.69
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.64.0.2
	OPENBSD_4_3_BASE:1.64
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.48.0.2
	OPENBSD_4_1_BASE:1.48
	OPENBSD_4_0:1.48.0.4
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.4
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.30.0.4
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.27
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.143
date	2017.05.15.10.52.08;	author mpi;	state Exp;
branches;
next	1.142;
commitid	cyblrmsSmLeFugC0;

1.142
date	2017.03.10.11.18.48;	author mpi;	state Exp;
branches;
next	1.141;
commitid	KVR8Na3SYXI1y1RS;

1.141
date	2017.03.10.09.14.06;	author mpi;	state Exp;
branches;
next	1.140;
commitid	3KSzSoIpPvZCUNqm;

1.140
date	2017.02.02.22.31.05;	author chl;	state Exp;
branches;
next	1.139;
commitid	dtaPiB2Wa47i9aKk;

1.139
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.138;
commitid	RlO92XR575sygHqm;

1.138
date	2015.06.26.11.17.34;	author mpi;	state Exp;
branches;
next	1.137;
commitid	EHLAwh7vfwmK7jPG;

1.137
date	2015.06.22.12.56.55;	author mpi;	state Exp;
branches;
next	1.136;
commitid	tsYSHGCfv1hy9V5u;

1.136
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.135;
commitid	p4LJxGKbi0BU2cG6;

1.135
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.134;
commitid	LS2TNeCue5R9L67C;

1.134
date	2014.12.17.15.27.50;	author kettenis;	state Exp;
branches;
next	1.133;
commitid	nyx881EUiIK6OGRj;

1.133
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.132;
commitid	zM5ckwX4kwwmipG0;

1.132
date	2014.10.30.23.50.25;	author mpi;	state Exp;
branches;
next	1.131;
commitid	OC2UwjyhSceyDB1n;

1.131
date	2014.08.10.11.18.57;	author mpi;	state Exp;
branches;
next	1.130;
commitid	soKLg6qedOsGZg3L;

1.130
date	2014.08.10.11.00.36;	author mpi;	state Exp;
branches;
next	1.129;
commitid	EhRr39ksGEEyKpMd;

1.129
date	2014.08.05.20.26.15;	author mpi;	state Exp;
branches;
next	1.128;
commitid	kKc3w7FVrfZXrW2N;

1.128
date	2014.07.12.20.13.48;	author mpi;	state Exp;
branches;
next	1.127;
commitid	2p79UAVIqrMYziEA;

1.127
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.126;
commitid	OBNa5kfxQ2UXoiIw;

1.126
date	2014.07.10.20.57.40;	author mpi;	state Exp;
branches;
next	1.125;
commitid	x8n2LAVH0xAVN591;

1.125
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.124;
commitid	d8ZHVs7unt3KxWXc;

1.124
date	2014.06.04.13.52.30;	author mpi;	state Exp;
branches;
next	1.123;
commitid	MFXEmVLW2RJQYk5A;

1.123
date	2014.06.04.12.28.21;	author mpi;	state Exp;
branches;
next	1.122;
commitid	omWT0R9guKUnrNWN;

1.122
date	2014.05.30.13.24.59;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2014.05.25.09.59.12;	author mpi;	state Exp;
branches;
next	1.120;

1.120
date	2014.05.19.06.54.34;	author jsg;	state Exp;
branches;
next	1.119;

1.119
date	2014.05.18.17.10.27;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2014.05.16.19.00.18;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.116;

1.116
date	2014.05.09.11.01.06;	author mpi;	state Exp;
branches;
next	1.115;

1.115
date	2014.05.08.14.00.52;	author mpi;	state Exp;
branches;
next	1.114;

1.114
date	2014.05.04.14.42.36;	author mpi;	state Exp;
branches;
next	1.113;

1.113
date	2014.04.29.21.51.18;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2014.04.29.14.11.23;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2014.04.27.14.48.10;	author mpi;	state Exp;
branches;
next	1.110;

1.110
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.109;

1.109
date	2014.03.15.09.49.28;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2014.03.11.10.24.42;	author mpi;	state Exp;
branches;
next	1.107;

1.107
date	2014.03.07.09.51.50;	author mpi;	state Exp;
branches;
next	1.106;

1.106
date	2014.03.07.09.38.14;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.12.09.01.02.06;	author brad;	state Exp;
branches;
next	1.104;

1.104
date	2013.11.09.08.46.05;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2013.11.07.20.37.33;	author mpi;	state Exp;
branches;
next	1.102;

1.102
date	2013.11.07.10.16.27;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.01.17.29.01;	author mpi;	state Exp;
branches;
next	1.100;

1.100
date	2013.11.01.12.00.54;	author mpi;	state Exp;
branches;
next	1.99;

1.99
date	2013.06.25.09.24.34;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.05.20.08.19.47;	author yasuoka;	state Exp;
branches;
next	1.96;

1.96
date	2013.04.19.08.58.53;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2013.04.16.12.22.49;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2012.08.17.17.29.00;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.07.23.51.36;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.89;

1.89
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.06.06.09.08;	author jakemsr;	state Exp;
branches;
next	1.87;

1.87
date	2010.12.06.05.48.56;	author jakemsr;	state Exp;
branches;
next	1.86;

1.86
date	2010.11.21.01.29.07;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2010.11.19.18.42.27;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2010.09.20.06.54.10;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.09.20.03.28.48;	author jsg;	state Exp;
branches;
next	1.81;

1.81
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2010.09.06.19.20.24;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2010.08.31.16.47.36;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2010.08.31.03.50.15;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2010.08.30.21.30.17;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2010.08.27.04.09.21;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.01.19.43.57;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2009.11.26.12.27.48;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.71;

1.71
date	2009.07.24.08.15.38;	author blambert;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.02.23.49.33;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.21.17.08.42;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.67;

1.67
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.66;

1.66
date	2008.06.22.19.00.51;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.21.02.40.39;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2007.11.25.16.40.03;	author jmc;	state Exp;
branches;
next	1.63;

1.63
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.10.16.29.28;	author fgsch;	state Exp;
branches;
next	1.61;

1.61
date	2007.07.20.14.31.17;	author mbalmer;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.14.12.58.09;	author mbalmer;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.21.06.10.43;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.21.04.55.14;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.01.23.30.44;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2007.03.22.05.47.16;	author pascoe;	state Exp;
branches;
next	1.50;

1.50
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2007.03.18.05.55.24;	author pascoe;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.31.06.18.09;	author pascoe;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.29.04.15.49;	author pascoe;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.29.03.15.05;	author pascoe;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.21.07.29.11;	author jolan;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.03.03.40.52;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.15.07.02.37;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.04.22.55.30;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.19.08.33.26;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.11.12.15.48;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.11.04.25.53;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.11.04.24.27;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.11.04.23.15;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2004.08.11.04.21.44;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.11.05.29.16;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.23.15.16.07;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.09.18.19.58;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.10.00.46.36;	author nordin;	state Exp;
branches;
next	1.22;

1.22
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.06.12.19.11.58;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.25.04.26.58;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.11.04.23.20;	author ho;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.11.16.23.30;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.06.22.42.10;	author rahnds;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.04.11.44.23;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.14.22.50.25;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.28.19.37.49;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.26.21.47.51;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.15.53.07;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.45;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.55;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.27.09.00.28;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.19.08.18.38;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.48;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.21;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.43.51;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.22.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.143
log
@Replace remaining SPLUSBCHECK by a splsoftassert(IPL_SOFTUSB).

USB is the last real user of IPL_SOFTNET.
@
text
@/*	$OpenBSD: uhci.c,v 1.142 2017/03/10 11:18:48 mpi Exp $	*/
/*	$NetBSD: uhci.c,v 1.172 2003/02/23 04:19:26 simonb Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhci.c,v 1.33 1999/11/17 22:33:41 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/pool.h>
#include <sys/endian.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/uhcireg.h>
#include <dev/usb/uhcivar.h>

/* Use bandwidth reclamation for control transfers. Some devices choke on it. */
/*#define UHCI_CTL_LOOP */

struct cfdriver uhci_cd = {
	NULL, "uhci", DV_DULL
};

#ifdef UHCI_DEBUG
struct uhci_softc *thesc;
#define DPRINTF(x)	if (uhcidebug) printf x
#define DPRINTFN(n,x)	if (uhcidebug>(n)) printf x
int uhcidebug = 0;
int uhcinoloop = 0;
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct pool *uhcixfer;

struct uhci_pipe {
	struct usbd_pipe pipe;
	int nexttoggle;

	union {
		/* Control pipe */
		struct {
			struct uhci_soft_qh *sqh;
			struct usb_dma reqdma;
			struct uhci_soft_td *setup, *stat;
			u_int length;
		} ctl;
		/* Interrupt pipe */
		struct {
			int npoll;
			int isread;
			struct uhci_soft_qh **qhs;
		} intr;
		/* Bulk pipe */
		struct {
			struct uhci_soft_qh *sqh;
			u_int length;
			int isread;
		} bulk;
		/* Iso pipe */
		struct iso {
			struct uhci_soft_td **stds;
			int next, inuse;
		} iso;
	} u;
};

void		uhci_globalreset(struct uhci_softc *);
usbd_status	uhci_portreset(struct uhci_softc *, int);
void		uhci_reset(struct uhci_softc *);
usbd_status	uhci_run(struct uhci_softc *, int run);
struct uhci_soft_td *uhci_alloc_std(struct uhci_softc *);
void		uhci_free_std(struct uhci_softc *, struct uhci_soft_td *);
struct uhci_soft_qh *uhci_alloc_sqh(struct uhci_softc *);
void		uhci_free_sqh(struct uhci_softc *, struct uhci_soft_qh *);

void		uhci_free_std_chain(struct uhci_softc *,
		    struct uhci_soft_td *, struct uhci_soft_td *);
usbd_status	uhci_alloc_std_chain(struct uhci_softc *, u_int,
		    struct usbd_xfer *, struct uhci_soft_td **,
		    struct uhci_soft_td **);
void		uhci_poll_hub(void *);
void		uhci_check_intr(struct uhci_softc *, struct usbd_xfer *);
void		uhci_idone(struct usbd_xfer *);

void		uhci_abort_xfer(struct usbd_xfer *, usbd_status status);

void		uhci_timeout(void *);
void		uhci_timeout_task(void *);
void		uhci_add_ls_ctrl(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_add_hs_ctrl(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_add_bulk(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_remove_ls_ctrl(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_remove_hs_ctrl(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_remove_bulk(struct uhci_softc *,struct uhci_soft_qh *);
void		uhci_add_loop(struct uhci_softc *sc);
void		uhci_rem_loop(struct uhci_softc *sc);

usbd_status	uhci_setup_isoc(struct usbd_pipe *pipe);
void		uhci_device_isoc_enter(struct usbd_xfer *);

struct usbd_xfer *uhci_allocx(struct usbd_bus *);
void		uhci_freex(struct usbd_bus *, struct usbd_xfer *);

usbd_status	uhci_device_ctrl_transfer(struct usbd_xfer *);
usbd_status	uhci_device_ctrl_start(struct usbd_xfer *);
void		uhci_device_ctrl_abort(struct usbd_xfer *);
void		uhci_device_ctrl_close(struct usbd_pipe *);
void		uhci_device_ctrl_done(struct usbd_xfer *);

usbd_status	uhci_device_intr_transfer(struct usbd_xfer *);
usbd_status	uhci_device_intr_start(struct usbd_xfer *);
void		uhci_device_intr_abort(struct usbd_xfer *);
void		uhci_device_intr_close(struct usbd_pipe *);
void		uhci_device_intr_done(struct usbd_xfer *);

usbd_status	uhci_device_bulk_transfer(struct usbd_xfer *);
usbd_status	uhci_device_bulk_start(struct usbd_xfer *);
void		uhci_device_bulk_abort(struct usbd_xfer *);
void		uhci_device_bulk_close(struct usbd_pipe *);
void		uhci_device_bulk_done(struct usbd_xfer *);

usbd_status	uhci_device_isoc_transfer(struct usbd_xfer *);
usbd_status	uhci_device_isoc_start(struct usbd_xfer *);
void		uhci_device_isoc_abort(struct usbd_xfer *);
void		uhci_device_isoc_close(struct usbd_pipe *);
void		uhci_device_isoc_done(struct usbd_xfer *);

usbd_status	uhci_root_ctrl_transfer(struct usbd_xfer *);
usbd_status	uhci_root_ctrl_start(struct usbd_xfer *);
void		uhci_root_ctrl_abort(struct usbd_xfer *);
void		uhci_root_ctrl_close(struct usbd_pipe *);
void		uhci_root_ctrl_done(struct usbd_xfer *);

usbd_status	uhci_root_intr_transfer(struct usbd_xfer *);
usbd_status	uhci_root_intr_start(struct usbd_xfer *);
void		uhci_root_intr_abort(struct usbd_xfer *);
void		uhci_root_intr_close(struct usbd_pipe *);
void		uhci_root_intr_done(struct usbd_xfer *);

usbd_status	uhci_open(struct usbd_pipe *);
void		uhci_poll(struct usbd_bus *);
void		uhci_softintr(void *);

usbd_status	uhci_device_request(struct usbd_xfer *xfer);

void		uhci_add_intr(struct uhci_softc *, struct uhci_soft_qh *);
void		uhci_remove_intr(struct uhci_softc *, struct uhci_soft_qh *);
usbd_status	uhci_device_setintr(struct uhci_softc *sc,
		    struct uhci_pipe *pipe, int ival);

void		uhci_device_clear_toggle(struct usbd_pipe *pipe);

__inline__ struct uhci_soft_qh *uhci_find_prev_qh(struct uhci_soft_qh *,
		    struct uhci_soft_qh *);

#ifdef UHCI_DEBUG
void		uhci_dump_all(struct uhci_softc *);
void		uhci_dumpregs(struct uhci_softc *);
void		uhci_dump_qhs(struct uhci_soft_qh *);
void		uhci_dump_qh(struct uhci_soft_qh *);
void		uhci_dump_tds(struct uhci_soft_td *);
void		uhci_dump_td(struct uhci_soft_td *);
void		uhci_dump_xfer(struct uhci_xfer *);
void		uhci_dump(void);
#endif

#define UBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
#define UWRITE1(sc, r, x) \
 do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)
#define UWRITE2(sc, r, x) \
 do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)
#define UWRITE4(sc, r, x) \
 do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)

__unused static __inline u_int8_t
UREAD1(struct uhci_softc *sc, bus_size_t r)
{
	UBARR(sc);
	return bus_space_read_1(sc->iot, sc->ioh, r);
}

__unused static __inline u_int16_t
UREAD2(struct uhci_softc *sc, bus_size_t r)
{
	UBARR(sc);
	return bus_space_read_2(sc->iot, sc->ioh, r);
}

__unused static __inline u_int32_t
UREAD4(struct uhci_softc *sc, bus_size_t r)
{
	UBARR(sc);
	return bus_space_read_4(sc->iot, sc->ioh, r);
}

#define UHCICMD(sc, cmd) UWRITE2(sc, UHCI_CMD, cmd)
#define UHCISTS(sc) UREAD2(sc, UHCI_STS)

#define UHCI_RESET_TIMEOUT 100	/* ms, reset timeout */

#define UHCI_CURFRAME(sc) (UREAD2(sc, UHCI_FRNUM) & UHCI_FRNUM_MASK)

#define UHCI_INTR_ENDPT 1

struct usbd_bus_methods uhci_bus_methods = {
	.open_pipe = uhci_open,
	.dev_setaddr = usbd_set_address,
	.soft_intr = uhci_softintr,
	.do_poll = uhci_poll,
	.allocx = uhci_allocx,
	.freex = uhci_freex,
};

struct usbd_pipe_methods uhci_root_ctrl_methods = {
	.transfer = uhci_root_ctrl_transfer,
	.start = uhci_root_ctrl_start,
	.abort = uhci_root_ctrl_abort,
	.close = uhci_root_ctrl_close,
	.done = uhci_root_ctrl_done,
};

struct usbd_pipe_methods uhci_root_intr_methods = {
	.transfer = uhci_root_intr_transfer,
	.start = uhci_root_intr_start,
	.abort = uhci_root_intr_abort,
	.close = uhci_root_intr_close,
	.done = uhci_root_intr_done,
};

struct usbd_pipe_methods uhci_device_ctrl_methods = {
	.transfer = uhci_device_ctrl_transfer,
	.start = uhci_device_ctrl_start,
	.abort = uhci_device_ctrl_abort,
	.close = uhci_device_ctrl_close,
	.done = uhci_device_ctrl_done,
};

struct usbd_pipe_methods uhci_device_intr_methods = {
	.transfer = uhci_device_intr_transfer,
	.start = uhci_device_intr_start,
	.abort = uhci_device_intr_abort,
	.close = uhci_device_intr_close,
	.cleartoggle = uhci_device_clear_toggle,
	.done = uhci_device_intr_done,
};

struct usbd_pipe_methods uhci_device_bulk_methods = {
	.transfer = uhci_device_bulk_transfer,
	.start = uhci_device_bulk_start,
	.abort = uhci_device_bulk_abort,
	.close = uhci_device_bulk_close,
	.cleartoggle = uhci_device_clear_toggle,
	.done = uhci_device_bulk_done,
};

struct usbd_pipe_methods uhci_device_isoc_methods = {
	.transfer = uhci_device_isoc_transfer,
	.start = uhci_device_isoc_start,
	.abort = uhci_device_isoc_abort,
	.close = uhci_device_isoc_close,
	.done = uhci_device_isoc_done,
};

#define uhci_add_intr_list(sc, ex) \
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ex), inext)
#define uhci_del_intr_list(ex) \
	do { \
		LIST_REMOVE((ex), inext); \
		(ex)->inext.le_prev = NULL; \
	} while (0)
#define uhci_active_intr_list(ex) ((ex)->inext.le_prev != NULL)

__inline__ struct uhci_soft_qh *
uhci_find_prev_qh(struct uhci_soft_qh *pqh, struct uhci_soft_qh *sqh)
{
	DPRINTFN(15,("uhci_find_prev_qh: pqh=%p sqh=%p\n", pqh, sqh));

	for (; pqh->hlink != sqh; pqh = pqh->hlink) {
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)
		if (letoh32(pqh->qh.qh_hlink) & UHCI_PTR_T) {
			printf("uhci_find_prev_qh: QH not found\n");
			return (NULL);
		}
#endif
	}
	return (pqh);
}

void
uhci_globalreset(struct uhci_softc *sc)
{
	UHCICMD(sc, UHCI_CMD_GRESET);	/* global reset */
	usb_delay_ms(&sc->sc_bus, USB_BUS_RESET_DELAY); /* wait a little */
	UHCICMD(sc, 0);			/* do nothing */
}

usbd_status
uhci_init(struct uhci_softc *sc)
{
	usbd_status err;
	int i, j;
	struct uhci_soft_qh *clsqh, *chsqh, *bsqh, *sqh, *lsqh;
	struct uhci_soft_td *std;

	DPRINTFN(1,("uhci_init: start\n"));

#ifdef UHCI_DEBUG
	thesc = sc;

	if (uhcidebug > 2)
		uhci_dumpregs(sc);
#endif

	/* Save SOF over HC reset. */
	sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);

	UWRITE2(sc, UHCI_INTR, 0);		/* disable interrupts */
	uhci_globalreset(sc);			/* reset the controller */
	uhci_reset(sc);

	if (uhcixfer == NULL) {
		uhcixfer = malloc(sizeof(struct pool), M_DEVBUF, M_NOWAIT);
		if (uhcixfer == NULL) {
			printf("%s: unable to allocate pool descriptor\n",
			    sc->sc_bus.bdev.dv_xname);
			return (ENOMEM);
		}
		pool_init(uhcixfer, sizeof(struct uhci_xfer), 0, IPL_SOFTUSB,
		    0, "uhcixfer", NULL);
	}

	/* Restore saved SOF. */
	UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);

	/* Allocate and initialize real frame array. */
	err = usb_allocmem(&sc->sc_bus,
		  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),
		  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);
	if (err)
		return (err);
	sc->sc_pframes = KERNADDR(&sc->sc_dma, 0);
	UWRITE2(sc, UHCI_FRNUM, 0);		/* set frame number to 0 */
	UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma, 0)); /* set frame list*/

	/*
	 * Allocate a TD, inactive, that hangs from the last QH.
	 * This is to avoid a bug in the PIIX that makes it run berserk
	 * otherwise.
	 */
	std = uhci_alloc_std(sc);
	if (std == NULL)
		return (USBD_NOMEM);
	std->link.std = NULL;
	std->td.td_link = htole32(UHCI_PTR_T);
	std->td.td_status = htole32(0); /* inactive */
	std->td.td_token = htole32(0);
	std->td.td_buffer = htole32(0);

	/* Allocate the dummy QH marking the end and used for looping the QHs.*/
	lsqh = uhci_alloc_sqh(sc);
	if (lsqh == NULL)
		return (USBD_NOMEM);
	lsqh->hlink = NULL;
	lsqh->qh.qh_hlink = htole32(UHCI_PTR_T);	/* end of QH chain */
	lsqh->elink = std;
	lsqh->qh.qh_elink = htole32(std->physaddr | UHCI_PTR_TD);
	sc->sc_last_qh = lsqh;

	/* Allocate the dummy QH where bulk traffic will be queued. */
	bsqh = uhci_alloc_sqh(sc);
	if (bsqh == NULL)
		return (USBD_NOMEM);
	bsqh->hlink = lsqh;
	bsqh->qh.qh_hlink = htole32(lsqh->physaddr | UHCI_PTR_QH);
	bsqh->elink = NULL;
	bsqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_bulk_start = sc->sc_bulk_end = bsqh;

	/* Allocate dummy QH where high speed control traffic will be queued. */
	chsqh = uhci_alloc_sqh(sc);
	if (chsqh == NULL)
		return (USBD_NOMEM);
	chsqh->hlink = bsqh;
	chsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_QH);
	chsqh->elink = NULL;
	chsqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_hctl_start = sc->sc_hctl_end = chsqh;

	/* Allocate dummy QH where control traffic will be queued. */
	clsqh = uhci_alloc_sqh(sc);
	if (clsqh == NULL)
		return (USBD_NOMEM);
	clsqh->hlink = chsqh;
	clsqh->qh.qh_hlink = htole32(chsqh->physaddr | UHCI_PTR_QH);
	clsqh->elink = NULL;
	clsqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_lctl_start = sc->sc_lctl_end = clsqh;

	/*
	 * Make all (virtual) frame list pointers point to the interrupt
	 * queue heads and the interrupt queue heads at the control
	 * queue head and point the physical frame list to the virtual.
	 */
	for(i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {
		std = uhci_alloc_std(sc);
		sqh = uhci_alloc_sqh(sc);
		if (std == NULL || sqh == NULL)
			return (USBD_NOMEM);
		std->link.sqh = sqh;
		std->td.td_link = htole32(sqh->physaddr | UHCI_PTR_QH);
		std->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */
		std->td.td_token = htole32(0);
		std->td.td_buffer = htole32(0);
		sqh->hlink = clsqh;
		sqh->qh.qh_hlink = htole32(clsqh->physaddr | UHCI_PTR_QH);
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		sc->sc_vframes[i].htd = std;
		sc->sc_vframes[i].etd = std;
		sc->sc_vframes[i].hqh = sqh;
		sc->sc_vframes[i].eqh = sqh;
		for (j = i;
		     j < UHCI_FRAMELIST_COUNT;
		     j += UHCI_VFRAMELIST_COUNT)
			sc->sc_pframes[j] = htole32(std->physaddr);
	}

	LIST_INIT(&sc->sc_intrhead);

	timeout_set(&sc->sc_root_intr, uhci_poll_hub, sc);

	/* Set up the bus struct. */
	sc->sc_bus.methods = &uhci_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct uhci_pipe);

	sc->sc_suspend = DVACT_RESUME;

	UHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */

	DPRINTFN(1,("uhci_init: enabling\n"));
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
		UHCI_INTR_IOCE | UHCI_INTR_SPIE);	/* enable interrupts */

	return (uhci_run(sc, 1));		/* and here we go... */
}

int
uhci_activate(struct device *self, int act)
{
	struct uhci_softc *sc = (struct uhci_softc *)self;
	int cmd, rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
#ifdef UHCI_DEBUG
		if (uhcidebug > 2)
			uhci_dumpregs(sc);
#endif
		rv = config_activate_children(self, act);
		sc->sc_bus.use_polling++;
		uhci_run(sc, 0); /* stop the controller */

		/* save some state if BIOS doesn't */
		sc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);

		UWRITE2(sc, UHCI_INTR, 0); /* disable intrs */

		cmd = UREAD2(sc, UHCI_CMD);
		UHCICMD(sc, cmd | UHCI_CMD_EGSM); /* enter global suspend */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_suspend = act;
		sc->sc_bus.use_polling--;
		DPRINTF(("uhci_activate: cmd=0x%x\n", UREAD2(sc, UHCI_CMD)));
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		uhci_run(sc, 0); /* stop the controller */
		break;
	case DVACT_RESUME:
#ifdef DIAGNOSTIC
		if (sc->sc_suspend == DVACT_RESUME)
			printf("uhci_powerhook: weird, resume without suspend.\n");
#endif
		sc->sc_bus.use_polling++;
		sc->sc_suspend = act;
		cmd = UREAD2(sc, UHCI_CMD);
		if (cmd & UHCI_CMD_RS)
			uhci_run(sc, 0); /* in case BIOS has started it */

		/* restore saved state */
		UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma, 0));
		UWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);
		UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);

		UHCICMD(sc, cmd | UHCI_CMD_FGR); /* force global resume */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		UHCICMD(sc, cmd & ~UHCI_CMD_EGSM); /* back to normal */
		UHCICMD(sc, UHCI_CMD_MAXP);
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
			UHCI_INTR_IOCE | UHCI_INTR_SPIE); /* re-enable intrs */
		uhci_run(sc, 1); /* and start traffic again */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_bus.use_polling--;
#ifdef UHCI_DEBUG
		if (uhcidebug > 2)
			uhci_dumpregs(sc);
#endif
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
uhci_detach(struct device *self, int flags)
{
#ifdef DIAGNOSTIC
	struct uhci_softc *sc = (struct uhci_softc *)self;
#endif
	int rv;

	rv = config_detach_children(self, flags);
	if (rv != 0)
		return (rv);

	KASSERT(sc->sc_intrxfer == NULL);

	/* XXX free other data structures XXX */

	return (rv);
}

struct usbd_xfer *
uhci_allocx(struct usbd_bus *bus)
{
	struct uhci_xfer *ux;

	ux = pool_get(uhcixfer, PR_NOWAIT | PR_ZERO);
#ifdef DIAGNOSTIC
	if (ux != NULL)
		ux->isdone = 1;
#endif
	return ((struct usbd_xfer *)ux);
}

void
uhci_freex(struct usbd_bus *bus, struct usbd_xfer *xfer)
{
	struct uhci_xfer *ux = (struct uhci_xfer*)xfer;

#ifdef DIAGNOSTIC
	if (!ux->isdone) {
		printf("%s: !isdone\n", __func__);
		return;
	}
#endif
	pool_put(uhcixfer, ux);
}

#ifdef UHCI_DEBUG
void
uhci_dumpregs(struct uhci_softc *sc)
{
	DPRINTFN(-1,("%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
		     "flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n",
		     sc->sc_bus.bdev.dv_xname,
		     UREAD2(sc, UHCI_CMD),
		     UREAD2(sc, UHCI_STS),
		     UREAD2(sc, UHCI_INTR),
		     UREAD2(sc, UHCI_FRNUM),
		     UREAD4(sc, UHCI_FLBASEADDR),
		     UREAD1(sc, UHCI_SOF),
		     UREAD2(sc, UHCI_PORTSC1),
		     UREAD2(sc, UHCI_PORTSC2)));
}

void
uhci_dump_td(struct uhci_soft_td *p)
{
	char sbuf[128], sbuf2[128];

	DPRINTFN(-1,("TD(%p) at %08lx = link=0x%08lx status=0x%08lx "
		     "token=0x%08lx buffer=0x%08lx\n",
		     p, (long)p->physaddr,
		     (long)letoh32(p->td.td_link),
		     (long)letoh32(p->td.td_status),
		     (long)letoh32(p->td.td_token),
		     (long)letoh32(p->td.td_buffer)));

	bitmask_snprintf((u_int32_t)letoh32(p->td.td_link), "\20\1T\2Q\3VF",
			 sbuf, sizeof(sbuf));
	bitmask_snprintf((u_int32_t)letoh32(p->td.td_status),
			 "\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
			 "STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD",
			 sbuf2, sizeof(sbuf2));

	DPRINTFN(-1,("  %s %s,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
		     "D=%d,maxlen=%d\n", sbuf, sbuf2,
		     UHCI_TD_GET_ERRCNT(letoh32(p->td.td_status)),
		     UHCI_TD_GET_ACTLEN(letoh32(p->td.td_status)),
		     UHCI_TD_GET_PID(letoh32(p->td.td_token)),
		     UHCI_TD_GET_DEVADDR(letoh32(p->td.td_token)),
		     UHCI_TD_GET_ENDPT(letoh32(p->td.td_token)),
		     UHCI_TD_GET_DT(letoh32(p->td.td_token)),
		     UHCI_TD_GET_MAXLEN(letoh32(p->td.td_token))));
}

void
uhci_dump_qh(struct uhci_soft_qh *sqh)
{
	DPRINTFN(-1,("QH(%p) at %08x: hlink=%08x elink=%08x\n", sqh,
	    (int)sqh->physaddr, letoh32(sqh->qh.qh_hlink),
	    letoh32(sqh->qh.qh_elink)));
}


void
uhci_dump(void)
{
	uhci_dump_all(thesc);
}

void
uhci_dump_all(struct uhci_softc *sc)
{
	uhci_dumpregs(sc);
	printf("intrs=%d\n", sc->sc_bus.no_intrs);
	/*printf("framelist[i].link = %08x\n", sc->sc_framelist[0].link);*/
	uhci_dump_qh(sc->sc_lctl_start);
}


void
uhci_dump_qhs(struct uhci_soft_qh *sqh)
{
	uhci_dump_qh(sqh);

	/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards
	 * Traverses sideways first, then down.
	 *
	 * QH1
	 * QH2
	 * No QH
	 * TD2.1
	 * TD2.2
	 * TD1.1
	 * etc.
	 *
	 * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.
	 */


	if (sqh->hlink != NULL && !(letoh32(sqh->qh.qh_hlink) & UHCI_PTR_T))
		uhci_dump_qhs(sqh->hlink);
	else
		DPRINTF(("No QH\n"));

	if (sqh->elink != NULL && !(letoh32(sqh->qh.qh_elink) & UHCI_PTR_T))
		uhci_dump_tds(sqh->elink);
	else
		DPRINTF(("No TD\n"));
}

void
uhci_dump_tds(struct uhci_soft_td *std)
{
	struct uhci_soft_td *td;

	for(td = std; td != NULL; td = td->link.std) {
		uhci_dump_td(td);

		/* Check whether the link pointer in this TD marks
		 * the link pointer as end of queue. This avoids
		 * printing the free list in case the queue/TD has
		 * already been moved there (seatbelt).
		 */
		if (letoh32(td->td.td_link) & UHCI_PTR_T ||
		    letoh32(td->td.td_link) == 0)
			break;
	}
}

void
uhci_dump_xfer(struct uhci_xfer *ex)
{
	struct usbd_pipe *pipe;
	usb_endpoint_descriptor_t *ed;
	struct usbd_device *dev;

#ifdef DIAGNOSTIC
#define DONE ex->isdone
#else
#define DONE 0
#endif
        if (ex == NULL) {
                printf("ex NULL\n");
                return;
        }
        pipe = ex->xfer.pipe;
        if (pipe == NULL) {
		printf("ex %p: done=%d pipe=NULL\n",
		       ex, DONE);
                return;
	}
        if (pipe->endpoint == NULL) {
		printf("ex %p: done=%d pipe=%p pipe->endpoint=NULL\n",
		       ex, DONE, pipe);
                return;
	}
        if (pipe->device == NULL) {
		printf("ex %p: done=%d pipe=%p pipe->device=NULL\n",
		       ex, DONE, pipe);
                return;
	}
        ed = pipe->endpoint->edesc;
        dev = pipe->device;
	printf("ex %p: done=%d dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n",
	       ex, DONE, dev,
	       UGETW(dev->ddesc.idVendor),
	       UGETW(dev->ddesc.idProduct),
	       dev->address, pipe,
	       ed->bEndpointAddress, ed->bmAttributes);
#undef DONE
}

void uhci_dump_xfers(struct uhci_softc *sc);
void
uhci_dump_xfers(struct uhci_softc *sc)
{
	struct uhci_xfer *ex;

	printf("ex list:\n");
	for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = LIST_NEXT(ex, inext))
		uhci_dump_xfer(ex);
}

void exdump(void);
void exdump(void) { uhci_dump_xfers(thesc); }

#endif

/*
 * This routine is executed periodically and simulates interrupts
 * from the root controller interrupt pipe for port status change.
 */
void
uhci_poll_hub(void *addr)
{
	struct uhci_softc *sc = addr;
	struct usbd_xfer *xfer;
	int s;
	u_char *p;

	if (sc->sc_bus.dying)
		return;

	xfer = sc->sc_intrxfer;
	if (xfer == NULL)
		return;

	p = KERNADDR(&xfer->dmabuf, 0);
	p[0] = 0;
	if (UREAD2(sc, UHCI_PORTSC1) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))
		p[0] |= 1<<1;
	if (UREAD2(sc, UHCI_PORTSC2) & (UHCI_PORTSC_CSC|UHCI_PORTSC_OCIC))
		p[0] |= 1<<2;
	if (p[0] == 0) {
		/* No change, try again in a while */
		timeout_add_msec(&sc->sc_root_intr, 255);
		return;
	}

	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	s = splusb();
	xfer->device->bus->intr_context++;
	usb_transfer_complete(xfer);
	xfer->device->bus->intr_context--;
	splx(s);
}

void
uhci_root_ctrl_done(struct usbd_xfer *xfer)
{
}

/*
 * Let the last QH loop back to the high speed control transfer QH.
 * This is what intel calls "bandwidth reclamation" and improves
 * USB performance a lot for some devices.
 * If we are already looping, just count it.
 */
void
uhci_add_loop(struct uhci_softc *sc) {
#ifdef UHCI_DEBUG
	if (uhcinoloop)
		return;
#endif
	if (++sc->sc_loops == 1) {
		DPRINTFN(5,("uhci_add_loop\n"));
		/* Note, we don't loop back the soft pointer. */
		sc->sc_last_qh->qh.qh_hlink =
		    htole32(sc->sc_hctl_start->physaddr | UHCI_PTR_QH);
	}
}

void
uhci_rem_loop(struct uhci_softc *sc) {
#ifdef UHCI_DEBUG
	if (uhcinoloop)
		return;
#endif
	if (--sc->sc_loops == 0) {
		DPRINTFN(5,("uhci_rem_loop\n"));
		sc->sc_last_qh->qh.qh_hlink = htole32(UHCI_PTR_T);
	}
}

/* Add high speed control QH, called at splusb(). */
void
uhci_add_hs_ctrl(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *eqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_add_hs_ctrl: sqh=%p\n", sqh));
	eqh = sc->sc_hctl_end;
	sqh->hlink       = eqh->hlink;
	sqh->qh.qh_hlink = eqh->qh.qh_hlink;
	eqh->hlink       = sqh;
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	sc->sc_hctl_end = sqh;
#ifdef UHCI_CTL_LOOP
	uhci_add_loop(sc);
#endif
}

/* Remove high speed control QH, called at splusb(). */
void
uhci_remove_hs_ctrl(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *pqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_remove_hs_ctrl: sqh=%p\n", sqh));
#ifdef UHCI_CTL_LOOP
	uhci_rem_loop(sc);
#endif
	/*
	 * The T bit should be set in the elink of the QH so that the HC
	 * doesn't follow the pointer.  This condition may fail if the
	 * the transferred packet was short so that the QH still points
	 * at the last used TD.
	 * In this case we set the T bit and wait a little for the HC
	 * to stop looking at the TD.
	 */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}

	pqh = uhci_find_prev_qh(sc->sc_hctl_start, sqh);
	pqh->hlink = sqh->hlink;
	pqh->qh.qh_hlink = sqh->qh.qh_hlink;
	delay(UHCI_QH_REMOVE_DELAY);
	if (sc->sc_hctl_end == sqh)
		sc->sc_hctl_end = pqh;
}

/* Add low speed control QH, called at splusb(). */
void
uhci_add_ls_ctrl(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *eqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_add_ls_ctrl: sqh=%p\n", sqh));
	eqh = sc->sc_lctl_end;
	sqh->hlink = eqh->hlink;
	sqh->qh.qh_hlink = eqh->qh.qh_hlink;
	eqh->hlink = sqh;
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	sc->sc_lctl_end = sqh;
}

/* Remove low speed control QH, called at splusb(). */
void
uhci_remove_ls_ctrl(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *pqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_remove_ls_ctrl: sqh=%p\n", sqh));
	/* See comment in uhci_remove_hs_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}
	pqh = uhci_find_prev_qh(sc->sc_lctl_start, sqh);
	pqh->hlink = sqh->hlink;
	pqh->qh.qh_hlink = sqh->qh.qh_hlink;
	delay(UHCI_QH_REMOVE_DELAY);
	if (sc->sc_lctl_end == sqh)
		sc->sc_lctl_end = pqh;
}

/* Add bulk QH, called at splusb(). */
void
uhci_add_bulk(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *eqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_add_bulk: sqh=%p\n", sqh));
	eqh = sc->sc_bulk_end;
	sqh->hlink = eqh->hlink;
	sqh->qh.qh_hlink = eqh->qh.qh_hlink;
	eqh->hlink = sqh;
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	sc->sc_bulk_end = sqh;
	uhci_add_loop(sc);
}

/* Remove bulk QH, called at splusb(). */
void
uhci_remove_bulk(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_soft_qh *pqh;

	splsoftassert(IPL_SOFTUSB);

	DPRINTFN(10, ("uhci_remove_bulk: sqh=%p\n", sqh));
	uhci_rem_loop(sc);
	/* See comment in uhci_remove_hs_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}
	pqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);
	pqh->hlink       = sqh->hlink;
	pqh->qh.qh_hlink = sqh->qh.qh_hlink;
	delay(UHCI_QH_REMOVE_DELAY);
	if (sc->sc_bulk_end == sqh)
		sc->sc_bulk_end = pqh;
}

int uhci_intr1(struct uhci_softc *);

int
uhci_intr(void *arg)
{
	struct uhci_softc *sc = arg;

	if (sc->sc_bus.dying)
		return (0);
	if (sc->sc_bus.use_polling)
		return (0);
	return (uhci_intr1(sc));
}

int
uhci_intr1(struct uhci_softc *sc)
{
	int status;
	int ack;

	status = UREAD2(sc, UHCI_STS);
	if (status == 0xffff) {
		sc->sc_bus.dying = 1;
		return (0);
	}
	status &= UHCI_STS_ALLINTRS;
	if (status == 0)	/* The interrupt was not for us. */
		return (0);

#ifdef UHCI_DEBUG
	if (uhcidebug > 15) {
		DPRINTF(("%s: uhci_intr1\n", sc->sc_bus.bdev.dv_xname));
		uhci_dumpregs(sc);
	}
#endif

	if (sc->sc_suspend != DVACT_RESUME) {
		printf("%s: interrupt while not operating ignored\n",
		       sc->sc_bus.bdev.dv_xname);
		return (0);
	}

	ack = 0;
	if (status & UHCI_STS_USBINT)
		ack |= UHCI_STS_USBINT;
	if (status & UHCI_STS_USBEI)
		ack |= UHCI_STS_USBEI;
	if (status & UHCI_STS_RD) {
		ack |= UHCI_STS_RD;
#ifdef UHCI_DEBUG
		printf("%s: resume detect\n", sc->sc_bus.bdev.dv_xname);
#endif
	}
	if (status & UHCI_STS_HSE) {
		ack |= UHCI_STS_HSE;
		printf("%s: host system error\n", sc->sc_bus.bdev.dv_xname);
	}
	if (status & UHCI_STS_HCPE) {
		ack |= UHCI_STS_HCPE;
		printf("%s: host controller process error\n",
		       sc->sc_bus.bdev.dv_xname);
	}
	if (status & UHCI_STS_HCH) {
		/* no acknowledge needed */
		if (!sc->sc_bus.dying) {
			printf("%s: host controller halted\n",
			    sc->sc_bus.bdev.dv_xname);
#ifdef UHCI_DEBUG
			uhci_dump_all(sc);
#endif
		}
		sc->sc_bus.dying = 1;
	}

	if (!ack)
		return (0);	/* nothing to acknowledge */
	UWRITE2(sc, UHCI_STS, ack); /* acknowledge the ints */

	sc->sc_bus.no_intrs++;
	usb_schedsoftintr(&sc->sc_bus);

	DPRINTFN(15, ("%s: uhci_intr1: exit\n", sc->sc_bus.bdev.dv_xname));

	return (1);
}

void
uhci_softintr(void *v)
{
	struct uhci_softc *sc = v;
	struct uhci_xfer *ux, *nextex;

	DPRINTFN(10,("%s: uhci_softintr (%d)\n", sc->sc_bus.bdev.dv_xname,
		     sc->sc_bus.intr_context));

	if (sc->sc_bus.dying)
		return;

	sc->sc_bus.intr_context++;

	/*
	 * Interrupts on UHCI really suck.  When the host controller
	 * interrupts because a transfer is completed there is no
	 * way of knowing which transfer it was.  You can scan down
	 * the TDs and QHs of the previous frame to limit the search,
	 * but that assumes that the interrupt was not delayed by more
	 * than 1 ms, which may not always be true (e.g. after debug
	 * output on a slow console).
	 * We scan all interrupt descriptors to see if any have
	 * completed.
	 */
	for (ux = LIST_FIRST(&sc->sc_intrhead); ux; ux = nextex) {
		nextex = LIST_NEXT(ux, inext);
		uhci_check_intr(sc, &ux->xfer);
	}

	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}

	sc->sc_bus.intr_context--;
}

void
uhci_check_intr(struct uhci_softc *sc, struct usbd_xfer *xfer)
{
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_td *std, *lstd;
	u_int32_t status;

	DPRINTFN(15, ("%s: ux=%p\n", __func__, ux));
#ifdef DIAGNOSTIC
	if (ux == NULL) {
		printf("%s: no ux? %p\n", __func__, ux);
		return;
	}
#endif
	if (xfer->status == USBD_CANCELLED || xfer->status == USBD_TIMEOUT) {
		DPRINTF(("%s: aborted xfer=%p\n", __func__, xfer));
		return;
	}

	if (ux->stdstart == NULL)
		return;
	lstd = ux->stdend;
#ifdef DIAGNOSTIC
	if (lstd == NULL) {
		printf("%s: std==0\n", __func__);
		return;
	}
#endif
	/*
	 * If the last TD is still active we need to check whether there
	 * is an error somewhere in the middle, or whether there was a
	 * short packet (SPD and not ACTIVE).
	 */
	if (letoh32(lstd->td.td_status) & UHCI_TD_ACTIVE) {
		DPRINTFN(12, ("%s: active ux=%p\n", __func__, ux));
		for (std = ux->stdstart; std != lstd; std = std->link.std) {
			status = letoh32(std->td.td_status);
			/* If there's an active TD the xfer isn't done. */
			if (status & UHCI_TD_ACTIVE)
				break;
			/* Any kind of error makes the xfer done. */
			if (status & UHCI_TD_STALLED)
				goto done;
			/* We want short packets, and it is short: it's done */
			if ((status & UHCI_TD_SPD) &&
			      UHCI_TD_GET_ACTLEN(status) <
			      UHCI_TD_GET_MAXLEN(letoh32(std->td.td_token)))
				goto done;
		}
		DPRINTFN(12, ("%s: ux=%p std=%p still active\n", __func__,
			      ux, ux->stdstart));
		return;
	}
 done:
	DPRINTFN(12, ("uhci_check_intr: ux=%p done\n", ux));
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->pipe->device, &xfer->abort_task);
	uhci_idone(xfer);
}

/* Called at splusb() */
void
uhci_idone(struct usbd_xfer *xfer)
{
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_soft_td *std;
	u_int32_t status = 0, nstatus;
	int actlen;

	DPRINTFN(12, ("uhci_idone: ux=%p\n", ux));
#ifdef DIAGNOSTIC
	{
		int s = splhigh();
		if (ux->isdone) {
			splx(s);
#ifdef UHCI_DEBUG
			printf("uhci_idone: ux is done!\n   ");
			uhci_dump_xfer(ux);
#else
			printf("uhci_idone: ux=%p is done!\n", ux);
#endif
			return;
		}
		ux->isdone = 1;
		splx(s);
	}
#endif

	if (xfer->nframes != 0) {
		/* Isoc transfer, do things differently. */
		struct uhci_soft_td **stds = upipe->u.iso.stds;
		int i, n, nframes, len;

		DPRINTFN(5,("uhci_idone: ux=%p isoc ready\n", ux));

		nframes = xfer->nframes;
		actlen = 0;
		n = ux->curframe;
		for (i = 0; i < nframes; i++) {
			std = stds[n];
#ifdef UHCI_DEBUG
			if (uhcidebug > 5) {
				DPRINTFN(-1,("uhci_idone: isoc TD %d\n", i));
				uhci_dump_td(std);
			}
#endif
			if (++n >= UHCI_VFRAMELIST_COUNT)
				n = 0;
			status = letoh32(std->td.td_status);
			len = UHCI_TD_GET_ACTLEN(status);
			xfer->frlengths[i] = len;
			actlen += len;
		}
		upipe->u.iso.inuse -= nframes;
		xfer->actlen = actlen;
		xfer->status = USBD_NORMAL_COMPLETION;
		goto end;
	}

#ifdef UHCI_DEBUG
	DPRINTFN(10, ("uhci_idone: ux=%p, xfer=%p, pipe=%p ready\n",
		      ux, xfer, upipe));
	if (uhcidebug > 10)
		uhci_dump_tds(ux->stdstart);
#endif

	/* The transfer is done, compute actual length and status. */
	actlen = 0;
	for (std = ux->stdstart; std != NULL; std = std->link.std) {
		nstatus = letoh32(std->td.td_status);
		if (nstatus & UHCI_TD_ACTIVE)
			break;

		status = nstatus;
		if (UHCI_TD_GET_PID(letoh32(std->td.td_token)) !=
		    UHCI_TD_PID_SETUP)
			actlen += UHCI_TD_GET_ACTLEN(status);
		else {
			/*
			 * UHCI will report CRCTO in addition to a STALL or NAK
			 * for a SETUP transaction.  See section 3.2.2, "TD
			 * CONTROL AND STATUS".
			 */
			if (status & (UHCI_TD_STALLED | UHCI_TD_NAK))
				status &= ~UHCI_TD_CRCTO;
		}
	}
	/* If there are left over TDs we need to update the toggle. */
	if (std != NULL)
		upipe->nexttoggle = UHCI_TD_GET_DT(letoh32(std->td.td_token));

	status &= UHCI_TD_ERROR;
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n",
		      actlen, status));
	xfer->actlen = actlen;
	if (status != 0) {
#ifdef UHCI_DEBUG
		char sbuf[128];

		bitmask_snprintf((u_int32_t)status,
				 "\20\22BITSTUFF\23CRCTO\24NAK\25"
				 "BABBLE\26DBUFFER\27STALLED\30ACTIVE",
				 sbuf, sizeof(sbuf));

		DPRINTFN((status == UHCI_TD_STALLED)*10,
			 ("uhci_idone: error, addr=%d, endpt=0x%02x, "
			  "status 0x%s\n",
			  xfer->device->address,
			  xfer->pipe->endpoint->edesc->bEndpointAddress,
			  sbuf));
#endif

		if (status == UHCI_TD_STALLED)
			xfer->status = USBD_STALLED;
		else
			xfer->status = USBD_IOERROR; /* more info XXX */
	} else {
		xfer->status = USBD_NORMAL_COMPLETION;
	}

 end:
	usb_transfer_complete(xfer);
	DPRINTFN(12, ("uhci_idone: ux=%p done\n", ux));
}

void
uhci_timeout(void *addr)
{
	struct usbd_xfer *xfer = addr;
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying) {
		uhci_timeout_task(addr);
		return;
	}

	usb_init_task(&xfer->abort_task, uhci_timeout_task, addr,
	    USB_TASK_TYPE_ABORT);
	usb_add_task(xfer->device, &xfer->abort_task);
}

void
uhci_timeout_task(void *addr)
{
	struct usbd_xfer *xfer = addr;
	int s;

	DPRINTF(("%s: xfer=%p\n", __func__, xfer));

	s = splusb();
	uhci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

void
uhci_poll(struct usbd_bus *bus)
{
	struct uhci_softc *sc = (struct uhci_softc *)bus;

	if (UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS)
		uhci_intr1(sc);
}

void
uhci_reset(struct uhci_softc *sc)
{
	int n;

	UHCICMD(sc, UHCI_CMD_HCRESET);
	/* The reset bit goes low when the controller is done. */
	for (n = 0; n < UHCI_RESET_TIMEOUT &&
		    (UREAD2(sc, UHCI_CMD) & UHCI_CMD_HCRESET); n++)
		usb_delay_ms(&sc->sc_bus, 1);
	if (n >= UHCI_RESET_TIMEOUT)
		printf("%s: controller did not reset\n",
		       sc->sc_bus.bdev.dv_xname);
}

usbd_status
uhci_run(struct uhci_softc *sc, int run)
{
	int s, n, running;
	u_int16_t cmd;

	run = run != 0;
	s = splhardusb();
	DPRINTF(("uhci_run: setting run=%d\n", run));
	cmd = UREAD2(sc, UHCI_CMD);
	if (run)
		cmd |= UHCI_CMD_RS;
	else
		cmd &= ~UHCI_CMD_RS;
	UHCICMD(sc, cmd);
	for(n = 0; n < 10; n++) {
		running = !(UREAD2(sc, UHCI_STS) & UHCI_STS_HCH);
		/* return when we've entered the state we want */
		if (run == running) {
			splx(s);
			DPRINTF(("uhci_run: done cmd=0x%x sts=0x%x\n",
				 UREAD2(sc, UHCI_CMD), UREAD2(sc, UHCI_STS)));
			return (USBD_NORMAL_COMPLETION);
		}
		usb_delay_ms(&sc->sc_bus, 1);
	}
	splx(s);
	printf("%s: cannot %s\n", sc->sc_bus.bdev.dv_xname,
	       run ? "start" : "stop");
	return (USBD_IOERROR);
}

/*
 * Memory management routines.
 *  uhci_alloc_std allocates TDs
 *  uhci_alloc_sqh allocates QHs
 * These two routines do their own free list management,
 * partly for speed, partly because allocating DMAable memory
 * has page size granularaity so much memory would be wasted if
 * only one TD/QH (32 bytes) was placed in each allocated chunk.
 */

struct uhci_soft_td *
uhci_alloc_std(struct uhci_softc *sc)
{
	struct uhci_soft_td *std = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freetds == NULL) {
		DPRINTFN(2,("uhci_alloc_std: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, UHCI_STD_SIZE * UHCI_STD_CHUNK,
			  UHCI_TD_ALIGN, &dma);
		if (err)
			goto out;
		for(i = 0; i < UHCI_STD_CHUNK; i++) {
			offs = i * UHCI_STD_SIZE;
			std = KERNADDR(&dma, offs);
			std->physaddr = DMAADDR(&dma, offs);
			std->link.std = sc->sc_freetds;
			sc->sc_freetds = std;
		}
	}

	std = sc->sc_freetds;
	sc->sc_freetds = std->link.std;
	memset(&std->td, 0, sizeof(struct uhci_td));

out:
	splx(s);
	return (std);
}

void
uhci_free_std(struct uhci_softc *sc, struct uhci_soft_td *std)
{
	int s;

#ifdef DIAGNOSTIC
#define TD_IS_FREE 0x12345678
	if (letoh32(std->td.td_token) == TD_IS_FREE) {
		printf("uhci_free_std: freeing free TD %p\n", std);
		return;
	}
	std->td.td_token = htole32(TD_IS_FREE);
#endif

	s = splusb();
	std->link.std = sc->sc_freetds;
	sc->sc_freetds = std;
	splx(s);
}

struct uhci_soft_qh *
uhci_alloc_sqh(struct uhci_softc *sc)
{
	struct uhci_soft_qh *sqh = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freeqhs == NULL) {
		DPRINTFN(2, ("uhci_alloc_sqh: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, UHCI_SQH_SIZE * UHCI_SQH_CHUNK,
			  UHCI_QH_ALIGN, &dma);
		if (err)
			goto out;
		for (i = 0; i < UHCI_SQH_CHUNK; i++) {
			offs = i * UHCI_SQH_SIZE;
			sqh = KERNADDR(&dma, offs);
			sqh->physaddr = DMAADDR(&dma, offs);
			sqh->hlink = sc->sc_freeqhs;
			sc->sc_freeqhs = sqh;
		}
	}
	sqh = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh->hlink;
	memset(&sqh->qh, 0, sizeof(struct uhci_qh));

out:
	splx(s);
	return (sqh);
}

void
uhci_free_sqh(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	sqh->hlink = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh;
}

void
uhci_free_std_chain(struct uhci_softc *sc, struct uhci_soft_td *std,
    struct uhci_soft_td *stdend)
{
	struct uhci_soft_td *p;

	for (; std != stdend; std = p) {
		p = std->link.std;
		uhci_free_std(sc, std);
	}
}

usbd_status
uhci_alloc_std_chain(struct uhci_softc *sc, u_int len, struct usbd_xfer *xfer,
    struct uhci_soft_td **sp, struct uhci_soft_td **ep)
{
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_soft_td *p, *lastp;
	uhci_physaddr_t lastlink;
	int i, ntd, l, tog, mps;
	u_int32_t status;
	u_int16_t flags = xfer->flags;
	int rd = usbd_xfer_isread(xfer);
	struct usb_dma *dma = &xfer->dmabuf;
	int addr = xfer->device->address;
	int endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;

	DPRINTFN(8, ("%s: addr=%d endpt=%d len=%u speed=%d flags=0x%x\n",
	    __func__, addr, UE_GET_ADDR(endpt), len, xfer->device->speed,
	    flags));

	mps = UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
	if (mps == 0) {
		printf("uhci_alloc_std_chain: mps=0\n");
		return (USBD_INVAL);
	}
	ntd = (len + mps - 1) / mps;
	if (len == 0)
		flags |= USBD_FORCE_SHORT_XFER;
	if ((flags & USBD_FORCE_SHORT_XFER) && len % mps == 0)
		ntd++;
	DPRINTFN(10, ("%s: mps=%d ntd=%d\n", __func__, mps, ntd));
	tog = upipe->nexttoggle;
	if (ntd % 2 == 0)
		tog ^= 1;
	upipe->nexttoggle = tog ^ 1;
	lastp = NULL;
	lastlink = UHCI_PTR_T;
	ntd--;
	status = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(3) | UHCI_TD_ACTIVE);
	if (xfer->pipe->device->speed == USB_SPEED_LOW)
		status |= UHCI_TD_LS;
	if (flags & USBD_SHORT_XFER_OK)
		status |= UHCI_TD_SPD;
	for (i = ntd; i >= 0; i--) {
		p = uhci_alloc_std(sc);
		if (p == NULL) {
			uhci_free_std_chain(sc, lastp, NULL);
			return (USBD_NOMEM);
		}
		p->link.std = lastp;
		p->td.td_link = htole32(lastlink | UHCI_PTR_VF | UHCI_PTR_TD);
		lastp = p;
		lastlink = p->physaddr;
		p->td.td_status = htole32(status);
		if (i == ntd) {
			/* last TD */
			l = len % mps;
			if (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))
				l = mps;
			*ep = p;
		} else
			l = mps;
		p->td.td_token =
		    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :
				 UHCI_TD_OUT(l, endpt, addr, tog));
		p->td.td_buffer = htole32(DMAADDR(dma, i * mps));
		tog ^= 1;
	}
	*sp = lastp;
	DPRINTFN(10, ("%s: nexttog=%d\n", __func__, upipe->nexttoggle));
	return (USBD_NORMAL_COMPLETION);
}

void
uhci_device_clear_toggle(struct usbd_pipe *pipe)
{
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	upipe->nexttoggle = 0;
}

usbd_status
uhci_device_bulk_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
uhci_device_bulk_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_td *data, *dataend;
	struct uhci_soft_qh *sqh;
	usbd_status err;
	u_int len;
	int s;

	DPRINTFN(3, ("uhci_device_bulk_start: xfer=%p len=%u flags=%d ux=%p\n",
		     xfer, xfer->length, xfer->flags, ux));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("uhci_device_bulk_start: a request");
#endif

	len = xfer->length;
	sqh = upipe->u.bulk.sqh;

	err = uhci_alloc_std_chain(sc, len, xfer, &data, &dataend);
	if (err)
		return (err);
	dataend->td.td_status |= htole32(UHCI_TD_IOC);

#ifdef UHCI_DEBUG
	if (uhcidebug > 8) {
		DPRINTF(("uhci_device_bulk_start: data(1)\n"));
		uhci_dump_tds(data);
	}
#endif

	/* Set up interrupt info. */
	ux->stdstart = data;
	ux->stdend = dataend;
#ifdef DIAGNOSTIC
	if (!ux->isdone) {
		printf("uhci_device_bulk_start: not done, ux=%p\n", ux);
	}
	ux->isdone = 0;
#endif

	sqh->elink = data;
	sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);

	s = splusb();
	uhci_add_bulk(sc, sqh);
	uhci_add_intr_list(sc, ux);

	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_del(&xfer->timeout_handle);
		timeout_set(&xfer->timeout_handle, uhci_timeout, xfer);
		timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

#ifdef UHCI_DEBUG
	if (uhcidebug > 10) {
		DPRINTF(("uhci_device_bulk_start: data(2)\n"));
		uhci_dump_tds(data);
	}
#endif

	return (USBD_IN_PROGRESS);
}

/* Abort a device bulk request. */
void
uhci_device_bulk_abort(struct usbd_xfer *xfer)
{
	DPRINTF(("uhci_device_bulk_abort:\n"));
	uhci_abort_xfer(xfer, USBD_CANCELLED);
}

/*
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
 */
void
uhci_abort_xfer(struct usbd_xfer *xfer, usbd_status status)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_td *std;
	int s;

	DPRINTFN(1,("uhci_abort_xfer: xfer=%p, status=%d\n", xfer, status));

	if (sc->sc_bus.dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);
#ifdef DIAGNOSTIC
		ux->isdone = 1;
#endif
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}

	if (xfer->device->bus->intr_context || !curproc)
		panic("uhci_abort_xfer: not in process context");

	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);
	DPRINTFN(1,("uhci_abort_xfer: stop ux=%p\n", ux));
	for (std = ux->stdstart; std != NULL; std = std->link.std)
		std->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
	splx(s);

	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(&sc->sc_bus, 2); /* Hardware finishes in 1ms */
	s = splusb();
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	DPRINTFN(1,("uhci_abort_xfer: tsleep\n"));
	tsleep(&sc->sc_softwake, PZERO, "uhciab", 0);
	splx(s);

	/*
	 * Step 3: Execute callback.
	 */
	DPRINTFN(1,("uhci_abort_xfer: callback\n"));
	s = splusb();
#ifdef DIAGNOSTIC
	ux->isdone = 1;
#endif
	usb_transfer_complete(xfer);
	splx(s);
}

/* Close a device bulk pipe. */
void
uhci_device_bulk_close(struct usbd_pipe *pipe)
{
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;

	uhci_free_sqh(sc, upipe->u.bulk.sqh);
	pipe->endpoint->savedtoggle = upipe->nexttoggle;
}

usbd_status
uhci_device_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
uhci_device_ctrl_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	usbd_status err;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		panic("uhci_device_ctrl_transfer: not a request");
#endif

	err = uhci_device_request(xfer);
	if (err)
		return (err);

	return (USBD_IN_PROGRESS);
}

usbd_status
uhci_device_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
uhci_device_intr_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_td *data, *dataend;
	struct uhci_soft_qh *sqh;
	usbd_status err;
	int i, s;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	DPRINTFN(3,("uhci_device_intr_start: xfer=%p len=%u flags=%d\n",
		    xfer, xfer->length, xfer->flags));

#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("uhci_device_intr_start: a request");
#endif

	upipe->u.intr.isread = usbd_xfer_isread(xfer);

	err = uhci_alloc_std_chain(sc, xfer->length, xfer, &data, &dataend);

	if (err)
		return (err);
	dataend->td.td_status |= htole32(UHCI_TD_IOC);

#ifdef UHCI_DEBUG
	if (uhcidebug > 10) {
		DPRINTF(("uhci_device_intr_start: data(1)\n"));
		uhci_dump_tds(data);
		uhci_dump_qh(upipe->u.intr.qhs[0]);
	}
#endif

	s = splusb();
	/* Set up interrupt info. */
	ux->stdstart = data;
	ux->stdend = dataend;
#ifdef DIAGNOSTIC
	if (!ux->isdone) {
		printf("uhci_device_intr_transfer: not done, ux=%p\n", ux);
	}
	ux->isdone = 0;
#endif

	DPRINTFN(10,("uhci_device_intr_start: qhs[0]=%p\n",
		     upipe->u.intr.qhs[0]));
	for (i = 0; i < upipe->u.intr.npoll; i++) {
		sqh = upipe->u.intr.qhs[i];
		sqh->elink = data;
		sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);
	}
	uhci_add_intr_list(sc, ux);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

#ifdef UHCI_DEBUG
	if (uhcidebug > 10) {
		DPRINTF(("uhci_device_intr_start: data(2)\n"));
		uhci_dump_tds(data);
		uhci_dump_qh(upipe->u.intr.qhs[0]);
	}
#endif

	return (USBD_IN_PROGRESS);
}

/* Abort a device control request. */
void
uhci_device_ctrl_abort(struct usbd_xfer *xfer)
{
	DPRINTF(("uhci_device_ctrl_abort:\n"));
	uhci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device control pipe. */
void
uhci_device_ctrl_close(struct usbd_pipe *pipe)
{
}

void
uhci_device_intr_abort(struct usbd_xfer *xfer)
{
	KASSERT(!xfer->pipe->repeat || xfer->pipe->intrxfer == xfer);

	uhci_abort_xfer(xfer, USBD_CANCELLED);
}

/* Close a device interrupt pipe. */
void
uhci_device_intr_close(struct usbd_pipe *pipe)
{
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
	int i, npoll;
	int s;

	/* Unlink descriptors from controller data structures. */
	npoll = upipe->u.intr.npoll;
	s = splusb();
	for (i = 0; i < npoll; i++)
		uhci_remove_intr(sc, upipe->u.intr.qhs[i]);
	splx(s);

	/*
	 * We now have to wait for any activity on the physical
	 * descriptors to stop.
	 */
	usb_delay_ms(&sc->sc_bus, 2);

	for(i = 0; i < npoll; i++)
		uhci_free_sqh(sc, upipe->u.intr.qhs[i]);
	free(upipe->u.intr.qhs, M_USBHC, 0);

	/* XXX free other resources */
}

usbd_status
uhci_device_request(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	usb_device_request_t *req = &xfer->request;
	int addr = xfer->device->address;
	int endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	struct uhci_soft_td *setup, *data, *stat, *next, *dataend;
	struct uhci_soft_qh *sqh;
	u_int len;
	u_int32_t ls;
	usbd_status err;
	int s;

	DPRINTFN(3,("uhci_device_request type=0x%02x, request=0x%02x, "
		    "wValue=0x%04x, wIndex=0x%04x len=%u, addr=%d, endpt=%d\n",
		    req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), UGETW(req->wLength),
		    addr, endpt));

	ls = xfer->device->speed == USB_SPEED_LOW ? UHCI_TD_LS : 0;
	len = UGETW(req->wLength);

	setup = upipe->u.ctl.setup;
	stat = upipe->u.ctl.stat;
	sqh = upipe->u.ctl.sqh;

	/* Set up data transaction */
	if (len != 0) {
		upipe->nexttoggle = 1;
		err = uhci_alloc_std_chain(sc, len, xfer, &data, &dataend);
		if (err)
			return (err);
		next = data;
		dataend->link.std = stat;
		dataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF | UHCI_PTR_TD);
	} else {
		next = stat;
	}
	upipe->u.ctl.length = len;

	memcpy(KERNADDR(&upipe->u.ctl.reqdma, 0), req, sizeof *req);

	setup->link.std = next;
	setup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF | UHCI_PTR_TD);
	setup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
		UHCI_TD_ACTIVE);
	setup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));
	setup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma, 0));

	stat->link.std = NULL;
	stat->td.td_link = htole32(UHCI_PTR_T);
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
		UHCI_TD_ACTIVE | UHCI_TD_IOC);
	stat->td.td_token = htole32(usbd_xfer_isread(xfer) ?
	    UHCI_TD_OUT(0, endpt, addr, 1) : UHCI_TD_IN (0, endpt, addr, 1));
	stat->td.td_buffer = htole32(0);

#ifdef UHCI_DEBUG
	if (uhcidebug > 10) {
		DPRINTF(("uhci_device_request: before transfer\n"));
		uhci_dump_tds(setup);
	}
#endif

	/* Set up interrupt info. */
	ux->stdstart = setup;
	ux->stdend = stat;
#ifdef DIAGNOSTIC
	if (!ux->isdone) {
		printf("%s: not done, ux=%p\n", __func__, ux);
	}
	ux->isdone = 0;
#endif

	sqh->elink = setup;
	sqh->qh.qh_elink = htole32(setup->physaddr | UHCI_PTR_TD);

	s = splusb();
	if (xfer->device->speed == USB_SPEED_LOW)
		uhci_add_ls_ctrl(sc, sqh);
	else
		uhci_add_hs_ctrl(sc, sqh);
	uhci_add_intr_list(sc, ux);
#ifdef UHCI_DEBUG
	if (uhcidebug > 12) {
		struct uhci_soft_td *std;
		struct uhci_soft_qh *xqh;
		struct uhci_soft_qh *sxqh;
		int maxqh = 0;
		uhci_physaddr_t link;
		DPRINTF(("uhci_device_request: follow from [0]\n"));
		for (std = sc->sc_vframes[0].htd, link = 0;
		     (link & UHCI_PTR_QH) == 0;
		     std = std->link.std) {
			link = letoh32(std->td.td_link);
			uhci_dump_td(std);
		}
		sxqh = (struct uhci_soft_qh *)std;
		uhci_dump_qh(sxqh);
		for (xqh = sxqh;
		     xqh != NULL;
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh ||
                            xqh->hlink == xqh ? NULL : xqh->hlink)) {
			uhci_dump_qh(xqh);
		}
		DPRINTF(("Enqueued QH:\n"));
		uhci_dump_qh(sqh);
		uhci_dump_tds(sqh->elink);
	}
#endif
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_del(&xfer->timeout_handle);
		timeout_set(&xfer->timeout_handle, uhci_timeout, xfer);
		timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uhci_device_isoc_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTFN(5,("uhci_device_isoc_transfer: xfer=%p\n", xfer));

	/* Put it on our queue, */
	err = usb_insert_transfer(xfer);

	/* bail out on error, */
	if (err && err != USBD_IN_PROGRESS)
		return (err);

	/* XXX should check inuse here */

	/* insert into schedule, */
	uhci_device_isoc_enter(xfer);

	/* and start if the pipe wasn't running */
	if (!err)
		uhci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));

	return (err);
}

void
uhci_device_isoc_enter(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct iso *iso = &upipe->u.iso;
	struct uhci_soft_td *std;
	u_int32_t buf, len, status;
	int s, i, next, nframes;

	DPRINTFN(5,("uhci_device_isoc_enter: used=%d next=%d xfer=%p "
		    "nframes=%d\n",
		    iso->inuse, iso->next, xfer, xfer->nframes));

	if (sc->sc_bus.dying)
		return;

	if (xfer->status == USBD_IN_PROGRESS) {
		/* This request has already been entered into the frame list */
		printf("uhci_device_isoc_enter: xfer=%p in frame list\n", xfer);
		/* XXX */
	}

#ifdef DIAGNOSTIC
	if (iso->inuse >= UHCI_VFRAMELIST_COUNT)
		printf("uhci_device_isoc_enter: overflow!\n");
#endif

	next = iso->next;
	if (next == -1) {
		/* Not in use yet, schedule it a few frames ahead. */
		next = (UREAD2(sc, UHCI_FRNUM) + 3) % UHCI_VFRAMELIST_COUNT;
		DPRINTFN(2,("uhci_device_isoc_enter: start next=%d\n", next));
	}

	xfer->status = USBD_IN_PROGRESS;
	((struct uhci_xfer *)xfer)->curframe = next;

	buf = DMAADDR(&xfer->dmabuf, 0);
	status = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |
				     UHCI_TD_ACTIVE |
				     UHCI_TD_IOS);
	nframes = xfer->nframes;
	s = splusb();
	for (i = 0; i < nframes; i++) {
		std = iso->stds[next];
		if (++next >= UHCI_VFRAMELIST_COUNT)
			next = 0;
		len = xfer->frlengths[i];
		std->td.td_buffer = htole32(buf);
		if (i == nframes - 1)
			status |= UHCI_TD_IOC;
		std->td.td_status = htole32(status);
		std->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);
		std->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));
#ifdef UHCI_DEBUG
		if (uhcidebug > 5) {
			DPRINTFN(5,("uhci_device_isoc_enter: TD %d\n", i));
			uhci_dump_td(std);
		}
#endif
		buf += len;
	}
	iso->next = next;
	iso->inuse += xfer->nframes;

	splx(s);
}

usbd_status
uhci_device_isoc_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_td *end;
	int s, i;

	DPRINTFN(5,("uhci_device_isoc_start: xfer=%p\n", xfer));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (xfer->status != USBD_IN_PROGRESS)
		printf("uhci_device_isoc_start: not in progress %p\n", xfer);
#endif

	/* Find the last TD */
	i = ux->curframe + xfer->nframes;
	if (i >= UHCI_VFRAMELIST_COUNT)
		i -= UHCI_VFRAMELIST_COUNT;
	end = upipe->u.iso.stds[i];

#ifdef DIAGNOSTIC
	if (end == NULL) {
		printf("uhci_device_isoc_start: end == NULL\n");
		return (USBD_INVAL);
	}
#endif

	s = splusb();

	/* Set up interrupt info. */
	ux->stdstart = end;
	ux->stdend = end;
#ifdef DIAGNOSTIC
	if (!ux->isdone)
		printf("%s: not done, ux=%p\n", __func__, ux);
	ux->isdone = 0;
#endif
	uhci_add_intr_list(sc, ux);

	splx(s);

	return (USBD_IN_PROGRESS);
}

void
uhci_device_isoc_abort(struct usbd_xfer *xfer)
{
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_soft_td **stds = upipe->u.iso.stds;
	struct uhci_soft_td *std;
	int i, n, s, nframes, maxlen, len;

	s = splusb();

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED &&
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
		return;
	}

	/* Give xfer the requested abort code. */
	xfer->status = USBD_CANCELLED;

	/* make hardware ignore it, */
	nframes = xfer->nframes;
	n = ux->curframe;
	maxlen = 0;
	for (i = 0; i < nframes; i++) {
		std = stds[n];
		std->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
		len = UHCI_TD_GET_MAXLEN(letoh32(std->td.td_token));
		if (len > maxlen)
			maxlen = len;
		if (++n >= UHCI_VFRAMELIST_COUNT)
			n = 0;
	}

	/* and wait until we are sure the hardware has finished. */
	delay(maxlen);

#ifdef DIAGNOSTIC
	ux->isdone = 1;
#endif
	/* Run callback and remove from interrupt list. */
	usb_transfer_complete(xfer);

	splx(s);
}

void
uhci_device_isoc_close(struct usbd_pipe *pipe)
{
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	struct uhci_soft_td *std, *vstd;
	struct iso *iso;
	int i, s;

	/*
	 * Make sure all TDs are marked as inactive.
	 * Wait for completion.
	 * Unschedule.
	 * Deallocate.
	 */
	iso = &upipe->u.iso;

	for (i = 0; i < UHCI_VFRAMELIST_COUNT; i++)
		iso->stds[i]->td.td_status &= htole32(~UHCI_TD_ACTIVE);
	usb_delay_ms(&sc->sc_bus, 2); /* wait for completion */

	s = splusb();
	for (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {
		std = iso->stds[i];
		for (vstd = sc->sc_vframes[i].htd;
		     vstd != NULL && vstd->link.std != std;
		     vstd = vstd->link.std)
			;
		if (vstd == NULL) {
			/*panic*/
			printf("uhci_device_isoc_close: %p not found\n", std);
			splx(s);
			return;
		}
		vstd->link = std->link;
		vstd->td.td_link = std->td.td_link;
		uhci_free_std(sc, std);
	}
	splx(s);

	free(iso->stds, M_USBHC, 0);
}

usbd_status
uhci_setup_isoc(struct usbd_pipe *pipe)
{
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	int addr = pipe->device->address;
	int endpt = pipe->endpoint->edesc->bEndpointAddress;
	int rd = UE_GET_DIR(endpt) == UE_DIR_IN;
	struct uhci_soft_td *std, *vstd;
	u_int32_t token;
	struct iso *iso;
	int i, s;

	iso = &upipe->u.iso;
	iso->stds = malloc(UHCI_VFRAMELIST_COUNT *
			   sizeof (struct uhci_soft_td *),
			   M_USBHC, M_WAITOK);

	token = rd ? UHCI_TD_IN (0, endpt, addr, 0) :
		     UHCI_TD_OUT(0, endpt, addr, 0);

	/* Allocate the TDs and mark as inactive; */
	for (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {
		std = uhci_alloc_std(sc);
		if (std == 0)
			goto bad;
		std->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */
		std->td.td_token = htole32(token);
		iso->stds[i] = std;
	}

	/* Insert TDs into schedule. */
	s = splusb();
	for (i = 0; i < UHCI_VFRAMELIST_COUNT; i++) {
		std = iso->stds[i];
		vstd = sc->sc_vframes[i].htd;
		std->link = vstd->link;
		std->td.td_link = vstd->td.td_link;
		vstd->link.std = std;
		vstd->td.td_link = htole32(std->physaddr | UHCI_PTR_TD);
	}
	splx(s);

	iso->next = -1;
	iso->inuse = 0;

	return (USBD_NORMAL_COMPLETION);

 bad:
	while (--i >= 0)
		uhci_free_std(sc, iso->stds[i]);
	free(iso->stds, M_USBHC, 0);
	return (USBD_NOMEM);
}

void
uhci_device_isoc_done(struct usbd_xfer *xfer)
{
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;

	DPRINTFN(4, ("uhci_device_isoc_done: length=%d\n", xfer->actlen));

	if (!uhci_active_intr_list(ux))
		return;

#ifdef DIAGNOSTIC
        if (ux->stdend == NULL) {
                printf("uhci_device_isoc_done: xfer=%p stdend==NULL\n", xfer);
#ifdef UHCI_DEBUG
		uhci_dump_xfer(ux);
#endif
		return;
	}
#endif

	/* Turn off the interrupt since it is active even if the TD is not. */
	ux->stdend->td.td_status &= htole32(~UHCI_TD_IOC);

	uhci_del_intr_list(ux);	/* remove from active list */
}

void
uhci_device_intr_done(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;
	struct uhci_soft_qh *sqh;
	int i, npoll;

	DPRINTFN(5, ("uhci_device_intr_done: length=%d\n", xfer->actlen));

	npoll = upipe->u.intr.npoll;
	for(i = 0; i < npoll; i++) {
		sqh = upipe->u.intr.qhs[i];
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
	}
	uhci_free_std_chain(sc, ux->stdstart, NULL);

	/* XXX Wasteful. */
	if (xfer->pipe->repeat) {
		struct uhci_soft_td *data, *dataend;

		DPRINTFN(5,("uhci_device_intr_done: requeuing\n"));

		/* This alloc cannot fail since we freed the chain above. */
		uhci_alloc_std_chain(sc, xfer->length, xfer, &data, &dataend);
		dataend->td.td_status |= htole32(UHCI_TD_IOC);

#ifdef UHCI_DEBUG
		if (uhcidebug > 10) {
			DPRINTF(("uhci_device_intr_done: data(1)\n"));
			uhci_dump_tds(data);
			uhci_dump_qh(upipe->u.intr.qhs[0]);
		}
#endif

		ux->stdstart = data;
		ux->stdend = dataend;
#ifdef DIAGNOSTIC
		if (!ux->isdone) {
			printf("%s: not done, ux=%p\n", __func__, ux);
		}
		ux->isdone = 0;
#endif
		for (i = 0; i < npoll; i++) {
			sqh = upipe->u.intr.qhs[i];
			sqh->elink = data;
			sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);
		}
		xfer->status = USBD_IN_PROGRESS;
		/* The ux is already on the examined list, just leave it. */
	} else {
		DPRINTFN(5,("uhci_device_intr_done: removing\n"));
		if (uhci_active_intr_list(ux))
			uhci_del_intr_list(ux);
	}
}

/* Deallocate request data structures */
void
uhci_device_ctrl_done(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		panic("uhci_device_ctrl_done: not a request");
#endif

	if (!uhci_active_intr_list(ux))
		return;

	uhci_del_intr_list(ux);	/* remove from active list */

	if (xfer->device->speed == USB_SPEED_LOW)
		uhci_remove_ls_ctrl(sc, upipe->u.ctl.sqh);
	else
		uhci_remove_hs_ctrl(sc, upipe->u.ctl.sqh);

	if (upipe->u.ctl.length != 0)
		uhci_free_std_chain(sc, ux->stdstart->link.std, ux->stdend);

	DPRINTFN(5, ("uhci_device_ctrl_done: length=%d\n", xfer->actlen));
}

/* Deallocate request data structures */
void
uhci_device_bulk_done(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_xfer *ux = (struct uhci_xfer *)xfer;

	DPRINTFN(5,("uhci_device_bulk_done: xfer=%p ux=%p sc=%p upipe=%p\n",
		    xfer, ux, sc, upipe));

	if (!uhci_active_intr_list(ux))
		return;

	uhci_del_intr_list(ux);	/* remove from active list */

	uhci_remove_bulk(sc, upipe->u.bulk.sqh);

	uhci_free_std_chain(sc, ux->stdstart, NULL);

	DPRINTFN(5, ("uhci_device_bulk_done: length=%d\n", xfer->actlen));
}

/* Add interrupt QH, called with vflock. */
void
uhci_add_intr(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];
	struct uhci_soft_qh *eqh;

	DPRINTFN(4, ("uhci_add_intr: n=%d sqh=%p\n", sqh->pos, sqh));

	eqh = vf->eqh;
	sqh->hlink       = eqh->hlink;
	sqh->qh.qh_hlink = eqh->qh.qh_hlink;
	eqh->hlink       = sqh;
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	vf->eqh = sqh;
	vf->bandwidth++;
}

/* Remove interrupt QH. */
void
uhci_remove_intr(struct uhci_softc *sc, struct uhci_soft_qh *sqh)
{
	struct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];
	struct uhci_soft_qh *pqh;

	DPRINTFN(4, ("uhci_remove_intr: n=%d sqh=%p\n", sqh->pos, sqh));

	/* See comment in uhci_remove_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}

	pqh = uhci_find_prev_qh(vf->hqh, sqh);
	pqh->hlink       = sqh->hlink;
	pqh->qh.qh_hlink = sqh->qh.qh_hlink;
	delay(UHCI_QH_REMOVE_DELAY);
	if (vf->eqh == sqh)
		vf->eqh = pqh;
	vf->bandwidth--;
}

usbd_status
uhci_device_setintr(struct uhci_softc *sc, struct uhci_pipe *upipe, int ival)
{
	struct uhci_soft_qh *sqh, **qhs;
	int i, npoll, s;
	u_int bestbw, bw, bestoffs, offs;

	DPRINTFN(2, ("uhci_device_setintr: pipe=%p\n", upipe));
	if (ival == 0) {
		printf("uhci_device_setintr: 0 interval\n");
		return (USBD_INVAL);
	}

	if (ival > UHCI_VFRAMELIST_COUNT)
		ival = UHCI_VFRAMELIST_COUNT;
	npoll = (UHCI_VFRAMELIST_COUNT + ival - 1) / ival;
	DPRINTFN(2, ("uhci_device_setintr: ival=%d npoll=%d\n", ival, npoll));

	qhs = mallocarray(npoll, sizeof(struct uhci_soft_qh *), M_USBHC,
	    M_NOWAIT);
	if (qhs == NULL)
		return (USBD_NOMEM);

	/*
	 * Figure out which offset in the schedule that has most
	 * bandwidth left over.
	 */
#define MOD(i) ((i) & (UHCI_VFRAMELIST_COUNT-1))
	for (bestoffs = offs = 0, bestbw = ~0; offs < ival; offs++) {
		for (bw = i = 0; i < npoll; i++)
			bw += sc->sc_vframes[MOD(i * ival + offs)].bandwidth;
		if (bw < bestbw) {
			bestbw = bw;
			bestoffs = offs;
		}
	}
	DPRINTFN(1, ("uhci_device_setintr: bw=%d offs=%d\n", bestbw, bestoffs));

	for(i = 0; i < npoll; i++) {
		sqh = uhci_alloc_sqh(sc);
		if (sqh == NULL) {
			while (i > 0)
				uhci_free_sqh(sc, qhs[--i]);
			free(qhs, M_USBHC, 0);
			return (USBD_NOMEM);
		}
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		sqh->pos = MOD(i * ival + bestoffs);
		qhs[i] = sqh;
	}
#undef MOD

	upipe->u.intr.npoll = npoll;
	upipe->u.intr.qhs = qhs;

	s = splusb();
	/* Enter QHs into the controller data structures. */
	for(i = 0; i < npoll; i++)
		uhci_add_intr(sc, upipe->u.intr.qhs[i]);
	splx(s);

	DPRINTFN(5, ("uhci_device_setintr: returns %p\n", upipe));
	return (USBD_NORMAL_COMPLETION);
}

/* Open a new pipe. */
usbd_status
uhci_open(struct usbd_pipe *pipe)
{
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	usbd_status err;
	int ival;

	DPRINTFN(1, ("uhci_open: pipe=%p, addr=%d, endpt=%d\n",
		     pipe, pipe->device->address, ed->bEndpointAddress));

	upipe->nexttoggle = pipe->endpoint->savedtoggle;

	/* Root Hub */
	if (pipe->device->depth == 0) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &uhci_root_ctrl_methods;
			break;
		case UE_DIR_IN | UHCI_INTR_ENDPT:
			pipe->methods = &uhci_root_intr_methods;
			break;
		default:
			return (USBD_INVAL);
		}
	} else {
		switch (ed->bmAttributes & UE_XFERTYPE) {
		case UE_CONTROL:
			pipe->methods = &uhci_device_ctrl_methods;
			upipe->u.ctl.sqh = uhci_alloc_sqh(sc);
			if (upipe->u.ctl.sqh == NULL)
				goto bad;
			upipe->u.ctl.setup = uhci_alloc_std(sc);
			if (upipe->u.ctl.setup == NULL) {
				uhci_free_sqh(sc, upipe->u.ctl.sqh);
				goto bad;
			}
			upipe->u.ctl.stat = uhci_alloc_std(sc);
			if (upipe->u.ctl.stat == NULL) {
				uhci_free_sqh(sc, upipe->u.ctl.sqh);
				uhci_free_std(sc, upipe->u.ctl.setup);
				goto bad;
			}
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
				  0, &upipe->u.ctl.reqdma);
			if (err) {
				uhci_free_sqh(sc, upipe->u.ctl.sqh);
				uhci_free_std(sc, upipe->u.ctl.setup);
				uhci_free_std(sc, upipe->u.ctl.stat);
				goto bad;
			}
			break;
		case UE_INTERRUPT:
			pipe->methods = &uhci_device_intr_methods;
			ival = pipe->interval;
			if (ival == USBD_DEFAULT_INTERVAL)
				ival = ed->bInterval;
			return (uhci_device_setintr(sc, upipe, ival));
		case UE_ISOCHRONOUS:
			pipe->methods = &uhci_device_isoc_methods;
			return (uhci_setup_isoc(pipe));
		case UE_BULK:
			pipe->methods = &uhci_device_bulk_methods;
			upipe->u.bulk.sqh = uhci_alloc_sqh(sc);
			if (upipe->u.bulk.sqh == NULL)
				goto bad;
			break;
		}
	}
	return (USBD_NORMAL_COMPLETION);

 bad:
	return (USBD_NOMEM);
}

/*
 * Data structures and routines to emulate the root hub.
 */
usb_device_descriptor_t uhci_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x01},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,		/* protocol */
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indices */
	1			/* # of configurations */
};

usb_config_descriptor_t uhci_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_SELF_POWERED,
	0			/* max power */
};

usb_interface_descriptor_t uhci_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_FSHUB,
	0
};

usb_endpoint_descriptor_t uhci_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | UHCI_INTR_ENDPT,
	UE_INTERRUPT,
	{8},
	255
};

usb_hub_descriptor_t uhci_hubd_piix = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	2,
	{ UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL, 0 },
	50,			/* power on to power good */
	0,
	{ 0x00 },		/* both ports are removable */
};

/*
 * The USB hub protocol requires that SET_FEATURE(PORT_RESET) also
 * enables the port, and also states that SET_FEATURE(PORT_ENABLE)
 * should not be used by the USB subsystem.  As we cannot issue a
 * SET_FEATURE(PORT_ENABLE) externally, we must ensure that the port
 * will be enabled as part of the reset.
 *
 * On the VT83C572, the port cannot be successfully enabled until the
 * outstanding "port enable change" and "connection status change"
 * events have been reset.
 */
usbd_status
uhci_portreset(struct uhci_softc *sc, int index)
{
	int lim, port, x;

	if (index == 1)
		port = UHCI_PORTSC1;
	else if (index == 2)
		port = UHCI_PORTSC2;
	else
		return (USBD_IOERROR);

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x | UHCI_PORTSC_PR);

	usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);

	DPRINTFN(3,("uhci port %d reset, status0 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);

	delay(100);

	DPRINTFN(3,("uhci port %d reset, status1 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x  | UHCI_PORTSC_PE);

	for (lim = 10; --lim > 0;) {
		usb_delay_ms(&sc->sc_bus, USB_PORT_RESET_DELAY);

		x = UREAD2(sc, port);

		DPRINTFN(3,("uhci port %d iteration %u, status = 0x%04x\n",
			    index, lim, x));

		if (!(x & UHCI_PORTSC_CCS)) {
			/*
			 * No device is connected (or was disconnected
			 * during reset).  Consider the port reset.
			 * The delay must be long enough to ensure on
			 * the initial iteration that the device
			 * connection will have been registered.  50ms
			 * appears to be sufficient, but 20ms is not.
			 */
			DPRINTFN(3,("uhci port %d loop %u, device detached\n",
				    index, lim));
			break;
		}

		if (x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC)) {
			/*
			 * Port enabled changed and/or connection
			 * status changed were set.  Reset either or
			 * both raised flags (by writing a 1 to that
			 * bit), and wait again for state to settle.
			 */
			UWRITE2(sc, port, URWMASK(x) |
				(x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC)));
			continue;
		}

		if (x & UHCI_PORTSC_PE)
			/* Port is enabled */
			break;

		UWRITE2(sc, port, URWMASK(x) | UHCI_PORTSC_PE);
	}

	DPRINTFN(3,("uhci port %d reset, status2 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	if (lim <= 0) {
		DPRINTFN(1,("uhci port %d reset timed out\n", index));
		return (USBD_TIMEOUT);
	}
	
	sc->sc_isreset = 1;
	return (USBD_NORMAL_COMPLETION);
}

/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
usbd_status
uhci_root_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
uhci_root_ctrl_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port, x;
	int s, len, value, index, status, change, l, totlen = 0;
	usb_port_status_t ps;
	usbd_status err;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		panic("uhci_root_ctrl_start: not a request");
#endif
	req = &xfer->request;

	DPRINTFN(2,("uhci_root_ctrl_start type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(2,("uhci_root_ctrl_start wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			USETW(uhci_devd.idVendor, sc->sc_id_vendor);
			memcpy(buf, &uhci_devd, l);
			break;
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
			memcpy(buf, &uhci_confd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &uhci_ifcd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &uhci_endpd, l);
			break;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
			case 0: /* Language table */
				totlen = usbd_str(buf, len, "\001");
				break;
			case 1: /* Vendor */
				totlen = usbd_str(buf, len, sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = usbd_str(buf, len, "UHCI root hub");
				break;
			}
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
		DPRINTFN(3, ("uhci_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
			     "port=%d feature=%d\n",
			     index, value));
		if (index == 1)
			port = UHCI_PORTSC1;
		else if (index == 2)
			port = UHCI_PORTSC2;
		else {
			err = USBD_IOERROR;
			goto ret;
		}
		switch(value) {
		case UHF_PORT_ENABLE:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x & ~UHCI_PORTSC_PE);
			break;
		case UHF_PORT_SUSPEND:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x & ~UHCI_PORTSC_SUSP);
			break;
		case UHF_PORT_RESET:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);
			break;
		case UHF_C_PORT_CONNECTION:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_CSC);
			break;
		case UHF_C_PORT_ENABLE:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_POEDC);
			break;
		case UHF_C_PORT_OVER_CURRENT:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_OCIC);
			break;
		case UHF_C_PORT_RESET:
			sc->sc_isreset = 0;
			err = USBD_NORMAL_COMPLETION;
			goto ret;
		case UHF_PORT_CONNECTION:
		case UHF_PORT_OVER_CURRENT:
		case UHF_PORT_POWER:
		case UHF_PORT_LOW_SPEED:
		case UHF_C_PORT_SUSPEND:
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_BUS_STATE, UT_READ_CLASS_OTHER):
		if (index == 1)
			port = UHCI_PORTSC1;
		else if (index == 2)
			port = UHCI_PORTSC2;
		else {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len > 0) {
			*(u_int8_t *)buf =
				(UREAD2(sc, port) & UHCI_PORTSC_LS) >>
				UHCI_PORTSC_LS_SHIFT;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
		if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		l = min(len, USB_HUB_DESCRIPTOR_SIZE);
		totlen = l;
		memcpy(buf, &uhci_hubd_piix, l);
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len);
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
		if (index == 1)
			port = UHCI_PORTSC1;
		else if (index == 2)
			port = UHCI_PORTSC2;
		else {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		x = UREAD2(sc, port);
		status = change = 0;
		if (x & UHCI_PORTSC_CCS)
			status |= UPS_CURRENT_CONNECT_STATUS;
		if (x & UHCI_PORTSC_CSC)
			change |= UPS_C_CONNECT_STATUS;
		if (x & UHCI_PORTSC_PE)
			status |= UPS_PORT_ENABLED;
		if (x & UHCI_PORTSC_POEDC)
			change |= UPS_C_PORT_ENABLED;
		if (x & UHCI_PORTSC_OCI)
			status |= UPS_OVERCURRENT_INDICATOR;
		if (x & UHCI_PORTSC_OCIC)
			change |= UPS_C_OVERCURRENT_INDICATOR;
		if (x & UHCI_PORTSC_SUSP)
			status |= UPS_SUSPEND;
		if (x & UHCI_PORTSC_LSDA)
			status |= UPS_LOW_SPEED;
		status |= UPS_PORT_POWER;
		if (sc->sc_isreset)
			change |= UPS_C_PORT_RESET;
		USETW(ps.wPortStatus, status);
		USETW(ps.wPortChange, change);
		l = min(len, sizeof ps);
		memcpy(buf, &ps, l);
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index == 1)
			port = UHCI_PORTSC1;
		else if (index == 2)
			port = UHCI_PORTSC2;
		else {
			err = USBD_IOERROR;
			goto ret;
		}
		switch(value) {
		case UHF_PORT_ENABLE:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_PE);
			break;
		case UHF_PORT_SUSPEND:
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_SUSP);
			break;
		case UHF_PORT_RESET:
			err = uhci_portreset(sc, index);
			goto ret;
		case UHF_PORT_POWER:
			/* Pretend we turned on power */
			err = USBD_NORMAL_COMPLETION;
			goto ret;
		case UHF_PORT_DISOWN_TO_1_1:
			/* accept, but do nothing */
			err = USBD_NORMAL_COMPLETION;
			goto ret;
		case UHF_C_PORT_CONNECTION:
		case UHF_C_PORT_ENABLE:
		case UHF_C_PORT_OVER_CURRENT:
		case UHF_PORT_CONNECTION:
		case UHF_PORT_OVER_CURRENT:
		case UHF_PORT_LOW_SPEED:
		case UHF_C_PORT_SUSPEND:
		case UHF_C_PORT_RESET:
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (err);
}

/* Abort a root control request. */
void
uhci_root_ctrl_abort(struct usbd_xfer *xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}

/* Close the root pipe. */
void
uhci_root_ctrl_close(struct usbd_pipe *pipe)
{
	DPRINTF(("uhci_root_ctrl_close\n"));
}

void
uhci_root_intr_abort(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
	int s;

	timeout_del(&sc->sc_root_intr);
	sc->sc_intrxfer = NULL;

	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

usbd_status
uhci_root_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
	 */
	return (uhci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

/* Start a transfer on the root interrupt pipe */
usbd_status
uhci_root_intr_start(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;
	timeout_add_msec(&sc->sc_root_intr, 255);

	return (USBD_IN_PROGRESS);
}

void
uhci_root_intr_close(struct usbd_pipe *pipe)
{
}

void
uhci_root_intr_done(struct usbd_xfer *xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;

	if (xfer->pipe->repeat)
		timeout_add_msec(&sc->sc_root_intr, 255);
}
@


1.142
log
@Fix a use-after-free when sending root hub control transfers.

*_root_ctrl_start() routines are synchronous and all end up calling
usb_transfer_complete() in the non-error case.  After calling this
function it is unsafe to dereference ``xfer'' since the transfer
callback has been called.  So returning USBD_IN_PROGRESS is wrong in
this case since transfers are always completed at this point.

So return USBD_NORMAL_COMPLETION or the corresponding error code if
something wrong happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.141 2017/03/10 09:14:06 mpi Exp $	*/
d873 1
a873 1
	SPLUSBCHECK;
d893 1
a893 1
	SPLUSBCHECK;
d926 1
a926 1
	SPLUSBCHECK;
d943 1
a943 1
	SPLUSBCHECK;
d965 1
a965 1
	SPLUSBCHECK;
d983 1
a983 1
	SPLUSBCHECK;
@


1.141
log
@Move per HC polling code to the stack.

This code contains a use-after-free which be addressed in an upcoming
diff.

This fix xhci(4) polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.140 2017/02/02 22:31:05 chl Exp $	*/
d3187 1
a3187 1
	return (USBD_IN_PROGRESS);
@


1.140
log
@Remove dead assignments and now unused variables.

Found by LLVM/Clang Static Analyzer.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.139 2016/09/15 02:00:17 dlg Exp $	*/
a121 1
void		uhci_waitintr(struct uhci_softc *, struct usbd_xfer *);
a1338 32
/*
 * Wait here until controller claims to have an interrupt.
 * Then call uhci_intr and return.  Use timeout to avoid waiting
 * too long.
 * Only used during boot when interrupts are not enabled yet.
 */
void
uhci_waitintr(struct uhci_softc *sc, struct usbd_xfer *xfer)
{
	int timo;
	u_int32_t intrs;

	xfer->status = USBD_IN_PROGRESS;
	for (timo = xfer->timeout; timo >= 0; timo--) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_bus.dying)
			break;
		intrs = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
		DPRINTFN(15,("uhci_waitintr: 0x%04x\n", intrs));
		if (intrs) {
			uhci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	DPRINTF(("uhci_waitintr: timeout\n"));
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
}

a1676 3
	if (sc->sc_bus.use_polling)
		uhci_waitintr(sc, xfer);

a1807 3
	if (sc->sc_bus.use_polling)
		uhci_waitintr(sc, xfer);

a1895 3
	if (sc->sc_bus.use_polling)
		uhci_waitintr(sc, xfer);

a2213 5

	if (sc->sc_bus.use_polling) {
		DPRINTF(("Starting uhci isoc xfer with polling. Bad idea?\n"));
		uhci_waitintr(sc, xfer);
	}
@


1.139
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.138 2015/06/26 11:17:34 mpi Exp $	*/
a1649 1
	int endpt;
a1663 1
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
a1875 1
	int endpt;
a1887 2

	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
@


1.138
log
@Revert previous.  uvideo checks the transfered length of every frame and
this break some devices.

As found the hardway by Hugo Sastre via sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.137 2015/06/22 12:56:55 mpi Exp $	*/
d373 2
a374 3
		pool_init(uhcixfer, sizeof(struct uhci_xfer), 0, 0, 0,
		    "uhcixfer", NULL);
		pool_setipl(uhcixfer, IPL_SOFTUSB);
@


1.137
log
@Do not update frame lengths to reflect what has really been transfered
when an isochronous transfer is done.

Frame lengths are just input values and no driver mess with them.

ok ratchov@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.136 2015/03/14 03:38:50 jsg Exp $	*/
d1237 1
@


1.136
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.135 2014/12/19 22:44:59 guenther Exp $	*/
a1236 1
			xfer->frlengths[i] = len;
@


1.135
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.134 2014/12/17 15:27:50 kettenis Exp $	*/
a36 1
#include <sys/kernel.h>
@


1.134
log
@Avoid premature masking in the interrupt handler code that checks for removed
hardware.

ok mpi@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.133 2014/12/09 07:05:06 doug Exp $	*/
d43 1
a45 1
#include <machine/endian.h>
@


1.133
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.132 2014/10/30 23:50:25 mpi Exp $	*/
d1023 2
a1024 4
	status = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
	if (status == 0)	/* The interrupt was not for us. */
		return (0);
	if (status == 0xffffffff) {
d1028 3
@


1.132
log
@XFER_FREE is not used, ciao.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.131 2014/08/10 11:18:57 mpi Exp $	*/
d2613 2
a2614 1
	qhs = malloc(npoll * sizeof(struct uhci_soft_qh *), M_USBHC, M_NOWAIT);
@


1.131
log
@Since USB xfer pools are accessed in interrupt context, initialize them
with the correct ipl to prevent your CPU from locking against itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.130 2014/08/10 11:00:36 mpi Exp $	*/
a2426 5
	if (xfer->busy_free == XFER_FREE) {
		printf("uhci_device_isoc_done: xfer=%p is free\n", xfer);
		return;
	}

@


1.130
log
@Set and check for XFER_BUSY in the common methods instead of doing it
in every HC driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.129 2014/08/05 20:26:15 mpi Exp $	*/
d376 1
@


1.129
log
@Only check if the abort transfer is the interrupt one if the pipe is
opened with a callback.

If a driver opens an interrupt pipe without callback function, like
umct(4) does with one of its bulk in endpoints being reported as an
interrupt endpoint, then we can end up aborting a transfer which is
different from the interrupt one.

Issue reported by Roberto E. Vargas Caballero, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.128 2014/07/12 20:13:48 mpi Exp $	*/
d589 1
a589 1
	if (ux != NULL) {
a590 2
		ux->xfer.busy_free = XFER_BUSY;
	}
a600 5
	if (xfer->busy_free != XFER_BUSY) {
		printf("%s: xfer=%p not busy, 0x%08x\n", __func__, xfer,
		    xfer->busy_free);
		return;
	}
@


1.128
log
@Protect the freelists of transfer descriptors with the appropriate spl
so that we do not end up allocating two times new descriptors.

This happens if a thread finds an empty list, start allocating, got
interrupted and the interrupt also finds an empty list.

Fix an issue reported by Nils Frohberg.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.127 2014/07/12 18:48:52 tedu Exp $	*/
d1970 1
a1970 1
	KASSERT(xfer->pipe->intrxfer == xfer);
@


1.127
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.126 2014/07/10 20:57:40 mpi Exp $	*/
d1448 1
a1448 1
	struct uhci_soft_td *std;
d1454 1
d1460 1
a1460 2
			return (0);
		s = splusb();
a1467 1
		splx(s);
a1469 1
	s = splusb();
d1473 2
a1475 1

d1502 1
a1502 1
	struct uhci_soft_qh *sqh;
d1506 1
d1508 1
d1514 2
a1515 2
			return (0);
		for(i = 0; i < UHCI_SQH_CHUNK; i++) {
d1526 3
@


1.126
log
@Do not set the bus dying flag during DVACT_DEACTIVATE otherwise the
explore thread will not disconnect the root hub.  The flag will be
set before detaching the children, like it is done during a suspend-
resume cycle.

Fix a panic when unplugging a cardbus *hci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.125 2014/07/09 15:47:54 mpi Exp $	*/
d1995 1
a1995 1
	free(upipe->u.intr.qhs, M_USBHC);
d2360 1
a2360 1
	free(iso->stds, M_USBHC);
d2414 1
a2414 1
	free(iso->stds, M_USBHC);
d2644 1
a2644 1
			free(qhs, M_USBHC);
@


1.125
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.124 2014/06/04 13:52:30 mpi Exp $	*/
a554 4
		break;
	case DVACT_DEACTIVATE:
		rv = config_activate_children(self, act);
		sc->sc_bus.dying = 1;
@


1.124
log
@Clearing the data toggle bit only makes sense for endpoints that use it,
since this function is optional get rid of the no-op ones.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.123 2014/06/04 12:28:21 mpi Exp $	*/
d253 1
@


1.123
log
@Use C99 initializers for pipe and bus methods.

Apart from improving readability, this will help us reduce the number of
no-op functions now that some of them are optional.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.122 2014/05/30 13:24:59 mpi Exp $	*/
a193 1
void		uhci_noop(struct usbd_pipe *pipe);
a263 1
	.cleartoggle = uhci_noop,
a271 1
	.cleartoggle = uhci_noop,
a279 1
	.cleartoggle = uhci_noop,
a305 1
	.cleartoggle = uhci_noop,
a1626 5
}

void
uhci_noop(struct usbd_pipe *pipe)
{
@


1.122
log
@Remove unused fields from the pipes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.121 2014/05/25 09:59:12 mpi Exp $	*/
d253 5
a257 5
	uhci_open,
	uhci_softintr,
	uhci_poll,
	uhci_allocx,
	uhci_freex,
d261 6
a266 6
	uhci_root_ctrl_transfer,
	uhci_root_ctrl_start,
	uhci_root_ctrl_abort,
	uhci_root_ctrl_close,
	uhci_noop,
	uhci_root_ctrl_done,
d270 6
a275 6
	uhci_root_intr_transfer,
	uhci_root_intr_start,
	uhci_root_intr_abort,
	uhci_root_intr_close,
	uhci_noop,
	uhci_root_intr_done,
d279 6
a284 6
	uhci_device_ctrl_transfer,
	uhci_device_ctrl_start,
	uhci_device_ctrl_abort,
	uhci_device_ctrl_close,
	uhci_noop,
	uhci_device_ctrl_done,
d288 6
a293 6
	uhci_device_intr_transfer,
	uhci_device_intr_start,
	uhci_device_intr_abort,
	uhci_device_intr_close,
	uhci_device_clear_toggle,
	uhci_device_intr_done,
d297 6
a302 6
	uhci_device_bulk_transfer,
	uhci_device_bulk_start,
	uhci_device_bulk_abort,
	uhci_device_bulk_close,
	uhci_device_clear_toggle,
	uhci_device_bulk_done,
d306 6
a311 6
	uhci_device_isoc_transfer,
	uhci_device_isoc_start,
	uhci_device_isoc_abort,
	uhci_device_isoc_close,
	uhci_noop,
	uhci_device_isoc_done,
@


1.121
log
@The default case in uhci_deactivate() was missing.  Because of that,
DVACT_QUIESCE was not passed to usb(4) and a new uhub(4) device was
reattached at every resume.

Problem reported by mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.120 2014/05/19 06:54:34 jsg Exp $	*/
a79 4
	u_char aborting;
	struct usbd_xfer *abortstart, *abortend;

	/* Info needed for different pipe kinds. */
a1683 3
	upipe->u.bulk.isread = usbd_xfer_isread(xfer);
	upipe->u.bulk.length = len;

a2692 1
	upipe->aborting = 0;
@


1.120
log
@unbreak the build when DIAGNOSTIC is not defined
allows ramdisk kernels to build again
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.119 2014/05/18 17:10:27 mpi Exp $	*/
d567 3
@


1.119
log
@Do not pass an xfer pointer to the timeout routine checking for root hub
status changes because it might be freed when detaching the root uhub(4).

Also do not reschedule a timeout if the pipe is being aborted.

Finally do not add more code to retrieve the 'bInterval' value of the
root hub endpoint descriptor since this value is hardcoded in the uhci(4)
driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.118 2014/05/16 19:00:18 mpi Exp $	*/
d575 1
d577 1
@


1.118
log
@Reduce the difference between HC drivers by always passing a generic
usbd_xfer pointer to the routines processing finished transfers to make
it crystal clear that the timeout and abort logic is the same everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.117 2014/05/16 18:17:03 mpi Exp $	*/
d484 1
a484 1
	timeout_set(&sc->sc_poll_handle, NULL, NULL);
a513 2
		if (sc->sc_intr_xfer != NULL)
			timeout_del(&sc->sc_poll_handle);
a557 6
		if (sc->sc_intr_xfer != NULL) {
			timeout_del(&sc->sc_poll_handle);
			timeout_set(&sc->sc_poll_handle, uhci_poll_hub,
			    sc->sc_intr_xfer);
			timeout_add_msec(&sc->sc_poll_handle, sc->sc_ival);
		}
d582 1
a582 4
	if (sc->sc_intr_xfer != NULL) {
		timeout_del(&sc->sc_poll_handle);
		sc->sc_intr_xfer = NULL;
	}
d812 2
a813 2
	struct usbd_xfer *xfer = addr;
	struct uhci_softc *sc = (struct uhci_softc *)xfer->device->bus;
a816 2
	DPRINTFN(20, ("uhci_poll_hub\n"));

d820 3
a822 3
	timeout_del(&sc->sc_poll_handle);
	timeout_set(&sc->sc_poll_handle, uhci_poll_hub, xfer);
	timeout_add_msec(&sc->sc_poll_handle, sc->sc_ival);
d830 1
a830 1
	if (p[0] == 0)
d832 1
d834 1
d836 1
a836 1
	xfer->actlen = 1;
d838 1
a846 5
uhci_root_intr_done(struct usbd_xfer *xfer)
{
}

void
d3285 2
a3286 2
	timeout_del(&sc->sc_poll_handle);
	sc->sc_intr_xfer = NULL;
a3315 3
	DPRINTFN(3, ("uhci_root_intr_start: xfer=%p len=%u flags=%d\n",
		     xfer, xfer->length, xfer->flags));

d3319 3
a3321 5
	sc->sc_ival = xfer->pipe->endpoint->edesc->bInterval;
	timeout_del(&sc->sc_poll_handle);
	timeout_set(&sc->sc_poll_handle, uhci_poll_hub, xfer);
	timeout_add_msec(&sc->sc_poll_handle, sc->sc_ival);
	sc->sc_intr_xfer = xfer;
a3324 1
/* Close the root interrupt pipe. */
d3328 6
a3333 1
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
d3335 2
a3336 3
	timeout_del(&sc->sc_poll_handle);
	sc->sc_intr_xfer = NULL;
	DPRINTF(("uhci_root_intr_close\n"));
@


1.117
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.116 2014/05/09 11:01:06 mpi Exp $	*/
d128 2
a129 2
void		uhci_check_intr(struct uhci_softc *, struct uhci_xfer *);
void		uhci_idone(struct uhci_xfer *);
d1120 1
a1120 1
	struct uhci_xfer *ex, *nextex;
d1141 3
a1143 3
	for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = nextex) {
		nextex = LIST_NEXT(ex, inext);
		uhci_check_intr(sc, ex);
a1153 1
/* Check for an interrupt. */
d1155 1
a1155 1
uhci_check_intr(struct uhci_softc *sc, struct uhci_xfer *ex)
d1157 1
d1161 1
a1161 1
	DPRINTFN(15, ("uhci_check_intr: ex=%p\n", ex));
d1163 2
a1164 2
	if (ex == NULL) {
		printf("uhci_check_intr: no ex? %p\n", ex);
d1168 2
a1169 3
	if (ex->xfer.status == USBD_CANCELLED ||
	    ex->xfer.status == USBD_TIMEOUT) {
		DPRINTF(("uhci_check_intr: aborted xfer=%p\n", ex->xfer));
d1173 1
a1173 1
	if (ex->stdstart == NULL)
d1175 1
a1175 1
	lstd = ex->stdend;
d1178 1
a1178 1
		printf("uhci_check_intr: std==0\n");
d1188 2
a1189 2
		DPRINTFN(12, ("uhci_check_intr: active ex=%p\n", ex));
		for (std = ex->stdstart; std != lstd; std = std->link.std) {
d1203 2
a1204 2
		DPRINTFN(12, ("uhci_check_intr: ex=%p std=%p still active\n",
			      ex, ex->stdstart));
d1208 4
a1211 4
	DPRINTFN(12, ("uhci_check_intr: ex=%p done\n", ex));
	timeout_del(&ex->xfer.timeout_handle);
	usb_rem_task(ex->xfer.pipe->device, &ex->xfer.abort_task);
	uhci_idone(ex);
d1216 1
a1216 1
uhci_idone(struct uhci_xfer *ux)
d1218 1
a1218 1
	struct usbd_xfer *xfer = &ux->xfer;
@


1.116
log
@Plug an xfer leak when detaching root hubs.

This leak is similar to the public xfer leak #1 that was affecting
device interrupt pipes except that root hubs are rarely detached.

Note that this xfer is never associated to any TD and is just used
to indicate that some of the HC ports has changed status, so there
is no need to flag it as "done" before completing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.115 2014/05/08 14:00:52 mpi Exp $	*/
d573 1
a573 2
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
d581 1
a581 1
uhci_detach(struct uhci_softc *sc, int flags)
d583 2
a584 4
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
d586 1
@


1.115
log
@Plug one more xfer leak.

Now that aborting interrupt pipes does not prevent us from freeing
the associated xfer, make sure to flag this xfer as "done" even if
there's no need to abort it in hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.114 2014/05/04 14:42:36 mpi Exp $	*/
a3296 1
/* Abort a root interrupt request. */
d3301 1
a3305 4
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("uhci_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = 0;
	}
d3307 1
a3307 3
#ifdef DIAGNOSTIC
	((struct uhci_xfer *)xfer)->isdone = 1;
#endif
d3309 1
@


1.114
log
@Make use of usbd_xfer_isread() instead of rerolling it everywhere.

This has the side effect of simplifying and reducing the differences
between the various *hci_alloc_*_chain() functions since they are the
principal place where we want to known if the transfer is a read or a
write.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.113 2014/04/29 21:51:18 mpi Exp $	*/
d1788 3
@


1.113
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.112 2014/04/29 14:11:23 mpi Exp $	*/
d123 2
a124 3
usbd_status	uhci_alloc_std_chain(struct uhci_pipe *,
		    struct uhci_softc *, u_int, int, u_int16_t,
		    struct usb_dma *, struct uhci_soft_td **,
d1573 1
a1573 2
uhci_alloc_std_chain(struct uhci_pipe *upipe, struct uhci_softc *sc, u_int len,
    int rd, u_int16_t flags, struct usb_dma *dma,
d1576 1
d1579 1
a1579 1
	int i, ntd, l, tog, maxp;
d1581 5
a1585 2
	int addr = upipe->pipe.device->address;
	int endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
d1587 7
a1593 6
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%u speed=%d "
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len,
		      upipe->pipe.device->speed, flags));
	maxp = UGETW(upipe->pipe.endpoint->edesc->wMaxPacketSize);
	if (maxp == 0) {
		printf("uhci_alloc_std_chain: maxp=0\n");
d1596 1
a1596 1
	ntd = (len + maxp - 1) / maxp;
d1599 1
a1599 1
	if ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)
d1601 1
a1601 1
	DPRINTFN(10, ("uhci_alloc_std_chain: maxp=%d ntd=%d\n", maxp, ntd));
d1610 1
a1610 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d1627 1
a1627 1
			l = len % maxp;
d1629 1
a1629 1
				l = maxp;
d1632 1
a1632 1
			l = maxp;
d1636 1
a1636 1
		p->td.td_buffer = htole32(DMAADDR(dma, i * maxp));
d1640 1
a1640 2
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n",
		      upipe->nexttoggle));
d1683 1
a1683 1
	int isread, endpt;
a1698 1
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d1701 1
a1701 1
	upipe->u.bulk.isread = isread;
d1704 1
a1704 2
	err = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,
				   &xfer->dmabuf, &data, &dataend);
d1911 1
a1911 1
	int isread, endpt;
a1925 1
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d1927 1
a1927 1
	upipe->u.intr.isread = isread;
d1929 1
a1929 3
	err = uhci_alloc_std_chain(upipe, sc, xfer->length, isread,
				   xfer->flags, &xfer->dmabuf, &data,
				   &dataend);
a2043 1
	int isread;
a2052 1
	isread = req->bmRequestType & UT_READ;
d2062 1
a2062 2
		err = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,
					   &xfer->dmabuf, &data, &dataend);
d2086 2
a2087 3
	stat->td.td_token =
		htole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :
		                 UHCI_TD_IN (0, endpt, addr, 1));
d2505 1
a2505 3
		uhci_alloc_std_chain(upipe, sc, xfer->length,
				     upipe->u.intr.isread, xfer->flags,
				     &xfer->dmabuf, &data, &dataend);
@


1.112
log
@Finally plug the public xfer leak #1 in our USB stack.

Every call to usbd_abort_pipe() on an interrupt pipe would simply
reset the intrxfer pointer, which would prevent usbd_close_pipe()
to free it.  Since we abort pipes in a lot of situations: when a
device is detached, when a USB-to-serial adapter is closed, when
an error occurs, when the machine is suspended, etc, this would
result in hundreds of leaked xfers in most of my machines.

xhci(4) is not affected, but you can't enable it right now since
the stack is not ready :)

While here put a KASSERT() to make sure drivers are only calling
the interrupt abort method for intrxfer, if that's not the case,
please let met know.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.111 2014/04/27 14:48:10 mpi Exp $	*/
a39 1
#include <sys/selinfo.h>
d41 2
a50 1
#include <dev/usb/usb_quirks.h>
d74 1
a74 4
/*
 * The UHCI controller is little endian, so on big endian machines
 * the data stored in memory needs to be swapped.
 */
d376 11
a484 2
	SIMPLEQ_INIT(&sc->sc_free_xfers);

a584 1
	struct usbd_xfer *xfer;
a597 9
	/* Free all xfers associated with this HC. */
	for (;;) {
		xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
		if (xfer == NULL)
			break;
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
		free(xfer, M_USB);
	}

d606 1
a606 2
	struct uhci_softc *sc = (struct uhci_softc *)bus;
	struct usbd_xfer *xfer;
d608 1
a608 3
	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
d610 3
a612 7
		if (xfer->busy_free != XFER_FREE) {
			printf("uhci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
#endif
	} else {
		xfer = malloc(sizeof(struct uhci_xfer), M_USB, M_NOWAIT);
a613 5
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct uhci_xfer));
#ifdef DIAGNOSTIC
		((struct uhci_xfer *)xfer)->isdone = 1;
		xfer->busy_free = XFER_BUSY;
d615 1
a615 2
	}
	return (xfer);
d621 1
a621 1
	struct uhci_softc *sc = (struct uhci_softc *)bus;
d625 2
a626 2
		printf("uhci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
d629 2
a630 3
	xfer->busy_free = XFER_FREE;
	if (!((struct uhci_xfer *)xfer)->isdone) {
		printf("uhci_freex: !isdone\n");
d634 1
a634 1
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
@


1.111
log
@Start de-obfuscating the HC drivers.

Since pipe methods have an xfer argument, always use it to get acces to
various data structure (pipe, bus, device) instead of having a different
way to get a pointer to these descriptors in every function.

Also kill the {E,U}XFER() macro and use a consistent name accross all the
methods for {e,u}hci_xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.110 2014/03/25 20:27:37 mpi Exp $	*/
a2013 1
/* Abort a device interrupt request. */
d2017 2
a2018 5
	DPRINTFN(1,("uhci_device_intr_abort: xfer=%p\n", xfer));
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTFN(1,("uhci_device_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
@


1.110
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.109 2014/03/15 09:49:28 mpi Exp $	*/
d628 1
a628 1
		UXFER(xfer)->isdone = 1;
d647 1
a647 1
	if (!UXFER(xfer)->isdone) {
d1238 1
a1238 1
uhci_idone(struct uhci_xfer *ex)
d1240 1
a1240 1
	struct usbd_xfer *xfer = &ex->xfer;
d1246 1
a1246 1
	DPRINTFN(12, ("uhci_idone: ex=%p\n", ex));
d1250 1
a1250 1
		if (ex->isdone) {
d1253 2
a1254 2
			printf("uhci_idone: ex is done!\n   ");
			uhci_dump_xfer(ex);
d1256 1
a1256 1
			printf("uhci_idone: ex=%p is done!\n", ex);
d1260 1
a1260 1
		ex->isdone = 1;
d1270 1
a1270 1
		DPRINTFN(5,("uhci_idone: ex=%p isoc ready\n", ex));
d1274 1
a1274 1
		n = UXFER(xfer)->curframe;
d1297 2
a1298 2
	DPRINTFN(10, ("uhci_idone: ex=%p, xfer=%p, pipe=%p ready\n",
		      ex, xfer, upipe));
d1300 1
a1300 1
		uhci_dump_tds(ex->stdstart);
d1305 1
a1305 1
	for (std = ex->stdstart; std != NULL; std = std->link.std) {
d1359 1
a1359 1
	DPRINTFN(12, ("uhci_idone: ex=%p done\n", ex));
d1692 1
d1694 1
a1694 3
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
	struct uhci_xfer *ex = UXFER(xfer);
d1702 2
a1703 2
	DPRINTFN(3, ("uhci_device_bulk_start: xfer=%p len=%u flags=%d ex=%p\n",
		     xfer, xfer->length, xfer->flags, ex));
d1714 1
a1714 1
	endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
d1735 2
a1736 2
	ex->stdstart = data;
	ex->stdend = dataend;
d1738 2
a1739 2
	if (!ex->isdone) {
		printf("uhci_device_bulk_start: not done, ex=%p\n", ex);
d1741 1
a1741 1
	ex->isdone = 0;
d1749 1
a1749 1
	uhci_add_intr_list(sc, ex);
d1753 1
a1753 1
		timeout_set(&xfer->timeout_handle, uhci_timeout, ex);
d1793 2
a1794 3
	struct uhci_xfer *ex = UXFER(xfer);
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	struct uhci_softc *sc = (struct uhci_softc *)upipe->pipe.device->bus;
d1821 2
a1822 2
	DPRINTFN(1,("uhci_abort_xfer: stop ex=%p\n", ex));
	for (std = ex->stdstart; std != NULL; std = std->link.std)
d1831 1
a1831 1
	usb_delay_ms(upipe->pipe.device->bus, 2); /* Hardware finishes in 1ms */
d1845 1
a1845 1
	ex->isdone = 1;
d1855 1
a1856 2
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
d1923 1
d1925 1
a1925 3
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
	struct uhci_xfer *ex = UXFER(xfer);
d1943 1
a1943 1
	endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
d1966 2
a1967 2
	ex->stdstart = data;
	ex->stdend = dataend;
d1969 2
a1970 2
	if (!ex->isdone) {
		printf("uhci_device_intr_transfer: not done, ex=%p\n", ex);
d1972 1
a1972 1
	ex->isdone = 0;
d1982 1
a1982 1
	uhci_add_intr_list(sc, ex);
d2058 1
d2060 1
d2062 2
a2063 5
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
	int addr = dev->address;
	int endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
	struct uhci_xfer *ex = UXFER(xfer);
d2078 1
a2078 1
	ls = dev->speed == USB_SPEED_LOW ? UHCI_TD_LS : 0;
d2127 2
a2128 2
	ex->stdstart = setup;
	ex->stdend = stat;
d2130 2
a2131 2
	if (!ex->isdone) {
		printf("uhci_device_request: not done, ex=%p\n", ex);
d2133 1
a2133 1
	ex->isdone = 0;
d2140 1
a2140 1
	if (dev->speed == USB_SPEED_LOW)
d2144 1
a2144 1
	uhci_add_intr_list(sc, ex);
d2174 1
a2174 1
		timeout_set(&xfer->timeout_handle, uhci_timeout, ex);
d2212 1
a2213 2
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
d2245 1
a2245 1
	UXFER(xfer)->curframe = next;
d2281 1
d2283 1
a2283 2
	struct uhci_softc *sc = (struct uhci_softc *)upipe->pipe.device->bus;
	struct uhci_xfer *ex = UXFER(xfer);
d2298 1
a2298 1
	i = UXFER(xfer)->curframe + xfer->nframes;
d2313 2
a2314 2
	ex->stdstart = end;
	ex->stdend = end;
d2316 3
a2318 3
	if (!ex->isdone)
		printf("uhci_device_isoc_start: not done, ex=%p\n", ex);
	ex->isdone = 0;
d2320 1
a2320 1
	uhci_add_intr_list(sc, ex);
d2335 1
d2355 1
a2355 1
	n = UXFER(xfer)->curframe;
d2371 1
a2371 1
	UXFER(xfer)->isdone = 1;
d2382 1
a2383 2
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
d2425 1
d2427 2
a2428 4
	struct usbd_device *dev = upipe->pipe.device;
	struct uhci_softc *sc = (struct uhci_softc *)dev->bus;
	int addr = upipe->pipe.device->address;
	int endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
d2480 1
a2480 1
	struct uhci_xfer *ex = UXFER(xfer);
d2484 1
a2484 1
	if (!uhci_active_intr_list(ex))
d2493 1
a2493 1
        if (ex->stdend == NULL) {
d2496 1
a2496 1
		uhci_dump_xfer(ex);
d2503 1
a2503 1
	ex->stdend->td.td_status &= htole32(~UHCI_TD_IOC);
d2505 1
a2505 1
	uhci_del_intr_list(ex);	/* remove from active list */
a2510 1
	struct uhci_xfer *ex = UXFER(xfer);
d2513 1
d2525 1
a2525 1
	uhci_free_std_chain(sc, ex->stdstart, NULL);
d2547 2
a2548 2
		ex->stdstart = data;
		ex->stdend = dataend;
d2550 2
a2551 2
		if (!ex->isdone) {
			printf("uhci_device_intr_done: not done, ex=%p\n", ex);
d2553 1
a2553 1
		ex->isdone = 0;
d2561 1
a2561 1
		/* The ex is already on the examined list, just leave it. */
d2564 2
a2565 2
		if (uhci_active_intr_list(ex))
			uhci_del_intr_list(ex);
a2572 1
	struct uhci_xfer *ex = UXFER(xfer);
d2575 1
d2582 1
a2582 1
	if (!uhci_active_intr_list(ex))
d2585 1
a2585 1
	uhci_del_intr_list(ex);	/* remove from active list */
d2587 1
a2587 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d2593 1
a2593 1
		uhci_free_std_chain(sc, ex->stdstart->link.std, ex->stdend);
a2601 1
	struct uhci_xfer *ex = UXFER(xfer);
d2604 1
d2606 2
a2607 2
	DPRINTFN(5,("uhci_device_bulk_done: xfer=%p ex=%p sc=%p upipe=%p\n",
		    xfer, ex, sc, upipe));
d2609 1
a2609 1
	if (!uhci_active_intr_list(ex))
d2612 1
a2612 1
	uhci_del_intr_list(ex);	/* remove from active list */
d2616 1
a2616 1
	uhci_free_std_chain(sc, ex->stdstart, NULL);
d3340 1
a3340 1
	UXFER(xfer)->isdone = 1;
@


1.109
log
@Unify the *hci_timeout() functions, there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.108 2014/03/11 10:24:42 mpi Exp $	*/
d2745 2
a2746 3
	DPRINTFN(1, ("uhci_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
		     pipe, pipe->device->address,
		     ed->bEndpointAddress, sc->sc_addr));
d2751 2
a2752 1
	if (pipe->device->address == sc->sc_addr) {
a3110 1
		sc->sc_addr = value;
@


1.108
log
@Kill dead links.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.107 2014/03/07 09:51:50 mpi Exp $	*/
a1361 3
/*
 * Called when a request does not complete.
 */
d1365 2
a1366 5
	struct uhci_xfer *uxfer = addr;
	struct uhci_pipe *upipe = (struct uhci_pipe *)uxfer->xfer.pipe;
	struct uhci_softc *sc = (struct uhci_softc *)upipe->pipe.device->bus;

	DPRINTF(("uhci_timeout: uxfer=%p\n", uxfer));
d1369 1
a1369 1
		uhci_abort_xfer(&uxfer->xfer, USBD_TIMEOUT);
d1373 1
a1373 2
	/* Execute the abort in a process context. */
	usb_init_task(&uxfer->xfer.abort_task, uhci_timeout_task, &uxfer->xfer,
d1375 1
a1375 1
	usb_add_task(uxfer->xfer.pipe->device, &uxfer->xfer.abort_task);
d1384 1
a1384 1
	DPRINTF(("uhci_timeout_task: xfer=%p\n", xfer));
@


1.107
log
@Transfer descriptors already have a back pointer to the USB device
descriptor they are linked to, so no need to dereference their pipe
pointer.  Simplify a lot of affectations, no functional change.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.106 2014/03/07 09:38:14 mpi Exp $	*/
a32 10
 */

/*
 * USB Universal Host Controller driver.
 * Handles e.g. PIIX3 and PIIX4.
 *
 * UHCI spec: http://download.intel.com/technology/usb/UHCI11D.pdf
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
 * PIIXn spec: ftp://download.intel.com/design/intarch/datashts/29055002.pdf
 *             ftp://download.intel.com/design/intarch/datashts/29056201.pdf
@


1.106
log
@We already have three identical copies of the *hci_str() function,
so merge them into usbd_str() to not introduce other copies with
the upcoming HC drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.105 2013/12/09 01:02:06 brad Exp $	*/
d855 1
a855 2
	struct usbd_pipe *pipe = xfer->pipe;
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
d1354 1
a1354 1
			  xfer->pipe->device->address,
d1824 1
a1824 1
		usb_rem_task(xfer->pipe->device, &xfer->abort_task);
d1839 1
a1839 1
	usb_rem_task(xfer->pipe->device, &xfer->abort_task);
d1902 1
a1902 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d2536 1
a2536 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d2598 1
a2598 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d2627 1
a2627 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d3009 1
a3009 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d3354 1
a3354 1
	struct uhci_softc *sc = (struct uhci_softc *)xfer->pipe->device->bus;
d3390 1
a3390 2
	struct usbd_pipe *pipe = xfer->pipe;
	struct uhci_softc *sc = (struct uhci_softc *)pipe->device->bus;
@


1.105
log
@Mark a few functions with __unused.

ohci.c:193:1: error: unused function 'OREAD1' [-Werror,-Wunused-function]
ohci.c:200:1: error: unused function 'OREAD2' [-Werror,-Wunused-function]
uhci.c:256:1: error: unused function 'UREAD4' [-Werror,-Wunused-function]

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.104 2013/11/09 08:46:05 mpi Exp $	*/
a154 1
int		uhci_str(usb_string_descriptor_t *, int, char *);
a2891 17
int
uhci_str(usb_string_descriptor_t *p, int l, char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

d3090 1
a3090 1
				totlen = uhci_str(buf, len, "\001");
d3093 1
a3093 1
				totlen = uhci_str(buf, len, sc->sc_vendor);
d3096 1
a3096 1
				totlen = uhci_str(buf, len, "UHCI root hub");
@


1.104
log
@In our USB world, timeouts are in milliseconds, so use timeout_add_msec()
coherently through all our controller drivers and kill the mstohz() macro.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.103 2013/11/07 20:37:33 mpi Exp $	*/
d241 1
a241 1
static __inline u_int8_t
d248 1
a248 1
static __inline u_int16_t
d255 1
a255 1
static __inline u_int32_t
@


1.103
log
@In polling mode since r1.101 we could end up dereferencing an
uninitialized variable in case the transfer we were waiting for
timed out; problem reported by oga@@bitrig.

So bring uhci_waitintr() in sync with its equivalent in ohci(4)
and ehci(4), stop using an uhci_xfer, do not dereference it and
set the correct status of the transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.102 2013/11/07 10:16:27 mpi Exp $	*/
a83 2
#define mstohz(ms) ((ms) * hz / 1000)

d570 1
a570 1
			timeout_add(&sc->sc_poll_handle, sc->sc_ival);
d868 1
a868 1
	timeout_add(&sc->sc_poll_handle, sc->sc_ival);
d3418 1
a3418 1
	sc->sc_ival = mstohz(xfer->pipe->endpoint->edesc->bInterval);
d3421 1
a3421 1
	timeout_add(&sc->sc_poll_handle, sc->sc_ival);
@


1.102
log
@Make sure to mark the controller as dying in order to stop processing
any transfer when autoconf(9) asks for it.

This brings uhci(4) in sync with ohci(4) and ehci(4).

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.101 2013/11/01 17:29:01 mpi Exp $	*/
d1421 2
a1422 4
	int timo = xfer->timeout;
	struct uhci_xfer *ex;

	DPRINTFN(10,("uhci_waitintr: timeout = %dms\n", timo));
d1425 1
a1425 1
	for (; timo >= 0; timo--) {
d1427 5
a1431 2
		DPRINTFN(20,("uhci_waitintr: 0x%04x\n", UREAD2(sc, UHCI_STS)));
		if (UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS) {
d1440 2
a1441 1
	uhci_idone(ex);
@


1.101
log
@Reduce the differences with ehci(4)'s transfer decriptors.  This is a
first step to merge the code of our controllers that deal with usbd
transfers.

Tested with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.100 2013/11/01 12:00:54 mpi Exp $	*/
d583 1
@


1.100
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.99 2013/06/25 09:24:34 mpi Exp $	*/
a134 5
#if 0
void		uhci_enter_ctl_q(struct uhci_softc *, struct uhci_soft_qh *,
		    struct uhci_intr_info *);
void		uhci_exit_ctl_q(struct uhci_softc *, struct uhci_soft_qh *);
#endif
d144 2
a145 2
void		uhci_check_intr(struct uhci_softc *, struct uhci_intr_info *);
void		uhci_idone(struct uhci_intr_info *);
d227 2
a228 2
void		uhci_dump_ii(struct uhci_intr_info *ii);
void		    uhci_dump(void);
d335 3
a337 3
#define uhci_add_intr_info(sc, ii) \
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ii), list)
#define uhci_del_intr_info(ii) \
d339 2
a340 2
		LIST_REMOVE((ii), list); \
		(ii)->list.le_prev = NULL; \
d342 1
a342 1
#define uhci_active_intr_info(ii) ((ii)->list.le_prev != NULL)
a638 1
		UXFER(xfer)->iinfo.sc = sc;
d640 1
a640 1
		UXFER(xfer)->iinfo.isdone = 1;
d659 1
a659 1
	if (!UXFER(xfer)->iinfo.isdone) {
d791 1
a791 1
uhci_dump_ii(struct uhci_intr_info *ii)
d798 1
a798 1
#define DONE ii->isdone
d802 2
a803 7
        if (ii == NULL) {
                printf("ii NULL\n");
                return;
        }
        if (ii->xfer == NULL) {
		printf("ii %p: done=%d xfer=NULL\n",
		       ii, DONE);
d806 1
a806 1
        pipe = ii->xfer->pipe;
d808 2
a809 2
		printf("ii %p: done=%d xfer=%p pipe=NULL\n",
		       ii, DONE, ii->xfer);
d813 2
a814 2
		printf("ii %p: done=%d xfer=%p pipe=%p pipe->endpoint=NULL\n",
		       ii, DONE, ii->xfer, pipe);
d818 2
a819 2
		printf("ii %p: done=%d xfer=%p pipe=%p pipe->device=NULL\n",
		       ii, DONE, ii->xfer, pipe);
d824 2
a825 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n",
	       ii, DONE, ii->xfer, dev,
d833 1
a833 1
void uhci_dump_iis(struct uhci_softc *sc);
d835 1
a835 1
uhci_dump_iis(struct uhci_softc *sc)
d837 1
a837 1
	struct uhci_intr_info *ii;
d839 3
a841 3
	printf("intr_info list:\n");
	for (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))
		uhci_dump_ii(ii);
d844 2
a845 2
void iidump(void);
void iidump(void) { uhci_dump_iis(thesc); }
d1154 1
a1154 1
	struct uhci_intr_info *ii, *nextii;
d1175 3
a1177 3
	for (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = nextii) {
		nextii = LIST_NEXT(ii, list);
		uhci_check_intr(sc, ii);
d1190 1
a1190 1
uhci_check_intr(struct uhci_softc *sc, struct uhci_intr_info *ii)
d1195 1
a1195 1
	DPRINTFN(15, ("uhci_check_intr: ii=%p\n", ii));
d1197 2
a1198 2
	if (ii == NULL) {
		printf("uhci_check_intr: no ii? %p\n", ii);
d1202 3
a1204 3
	if (ii->xfer->status == USBD_CANCELLED ||
	    ii->xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_check_intr: aborted xfer=%p\n", ii->xfer));
d1208 1
a1208 1
	if (ii->stdstart == NULL)
d1210 1
a1210 1
	lstd = ii->stdend;
d1223 2
a1224 2
		DPRINTFN(12, ("uhci_check_intr: active ii=%p\n", ii));
		for (std = ii->stdstart; std != lstd; std = std->link.std) {
d1238 2
a1239 2
		DPRINTFN(12, ("uhci_check_intr: ii=%p std=%p still active\n",
			      ii, ii->stdstart));
d1243 4
a1246 4
	DPRINTFN(12, ("uhci_check_intr: ii=%p done\n", ii));
	timeout_del(&ii->xfer->timeout_handle);
	usb_rem_task(ii->xfer->pipe->device, &ii->xfer->abort_task);
	uhci_idone(ii);
d1251 1
a1251 1
uhci_idone(struct uhci_intr_info *ii)
d1253 1
a1253 1
	struct usbd_xfer *xfer = ii->xfer;
d1259 1
a1259 1
	DPRINTFN(12, ("uhci_idone: ii=%p\n", ii));
d1263 1
a1263 1
		if (ii->isdone) {
d1266 2
a1267 2
			printf("uhci_idone: ii is done!\n   ");
			uhci_dump_ii(ii);
d1269 1
a1269 1
			printf("uhci_idone: ii=%p is done!\n", ii);
d1273 1
a1273 1
		ii->isdone = 1;
d1283 1
a1283 1
		DPRINTFN(5,("uhci_idone: ii=%p isoc ready\n", ii));
d1310 2
a1311 2
	DPRINTFN(10, ("uhci_idone: ii=%p, xfer=%p, pipe=%p ready\n",
		      ii, xfer, upipe));
d1313 1
a1313 1
		uhci_dump_tds(ii->stdstart);
d1318 1
a1318 1
	for (std = ii->stdstart; std != NULL; std = std->link.std) {
d1372 1
a1372 1
	DPRINTFN(12, ("uhci_idone: ii=%p done\n", ii));
d1381 1
a1381 2
	struct uhci_intr_info *ii = addr;
	struct uhci_xfer *uxfer = UXFER(ii->xfer);
d1393 1
a1393 1
	usb_init_task(&ii->xfer->abort_task, uhci_timeout_task, ii->xfer,
d1395 1
a1395 1
	usb_add_task(uxfer->xfer.pipe->device, &ii->xfer->abort_task);
d1421 1
a1421 1
	struct uhci_intr_info *ii;
d1438 1
a1438 9
	for (ii = LIST_FIRST(&sc->sc_intrhead);
	     ii != NULL && ii->xfer != xfer;
	     ii = LIST_NEXT(ii, list))
		;
#ifdef DIAGNOSTIC
	if (ii == NULL)
		panic("uhci_waitintr: lost intr_info");
#endif
	uhci_idone(ii);
d1713 1
a1713 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d1721 2
a1722 2
	DPRINTFN(3, ("uhci_device_bulk_start: xfer=%p len=%u flags=%d ii=%p\n",
		     xfer, xfer->length, xfer->flags, ii));
d1754 2
a1755 3
	ii->xfer = xfer;
	ii->stdstart = data;
	ii->stdend = dataend;
d1757 2
a1758 2
	if (!ii->isdone) {
		printf("uhci_device_bulk_start: not done, ii=%p\n", ii);
d1760 1
a1760 1
	ii->isdone = 0;
d1768 1
a1768 1
	uhci_add_intr_info(sc, ii);
d1772 1
a1772 1
		timeout_set(&xfer->timeout_handle, uhci_timeout, ii);
d1812 1
a1812 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d1841 2
a1842 2
	DPRINTFN(1,("uhci_abort_xfer: stop ii=%p\n", ii));
	for (std = ii->stdstart; std != NULL; std = std->link.std)
d1865 1
a1865 1
	ii->isdone = 1;
d1947 1
a1947 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d1988 2
a1989 3
	ii->xfer = xfer;
	ii->stdstart = data;
	ii->stdend = dataend;
d1991 2
a1992 2
	if (!ii->isdone) {
		printf("uhci_device_intr_transfer: not done, ii=%p\n", ii);
d1994 1
a1994 1
	ii->isdone = 0;
d2004 1
a2004 1
	uhci_add_intr_info(sc, ii);
d2086 1
a2086 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d2150 2
a2151 3
	ii->xfer = xfer;
	ii->stdstart = setup;
	ii->stdend = stat;
d2153 2
a2154 2
	if (!ii->isdone) {
		printf("uhci_device_request: not done, ii=%p\n", ii);
d2156 1
a2156 1
	ii->isdone = 0;
d2167 1
a2167 1
	uhci_add_intr_info(sc, ii);
d2197 1
a2197 1
		timeout_set(&xfer->timeout_handle, uhci_timeout, ii);
d2307 1
a2307 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d2337 6
a2342 7
	ii->xfer = xfer;
	ii->stdstart = end;
	ii->stdend = end;
#ifdef DIAGNOSTIC
	if (!ii->isdone)
		printf("uhci_device_isoc_start: not done, ii=%p\n", ii);
	ii->isdone = 0;
d2344 1
a2344 1
	uhci_add_intr_info(sc, ii);
d2394 1
a2394 1
	UXFER(xfer)->iinfo.isdone = 1;
d2505 1
a2505 1
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
d2509 1
a2509 5
	if (ii->xfer != xfer)
		/* Not on interrupt list, ignore it. */
		return;

	if (!uhci_active_intr_info(ii))
d2518 1
a2518 1
        if (ii->stdend == NULL) {
d2521 1
a2521 1
		uhci_dump_ii(ii);
d2528 1
a2528 1
	ii->stdend->td.td_status &= htole32(~UHCI_TD_IOC);
d2530 1
a2530 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2536 2
a2537 2
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
	struct uhci_softc *sc = ii->sc;
d2550 1
a2550 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d2572 2
a2573 2
		ii->stdstart = data;
		ii->stdend = dataend;
d2575 2
a2576 2
		if (!ii->isdone) {
			printf("uhci_device_intr_done: not done, ii=%p\n", ii);
d2578 1
a2578 1
		ii->isdone = 0;
d2586 1
a2586 1
		/* The ii is already on the examined list, just leave it. */
d2589 2
a2590 2
		if (uhci_active_intr_info(ii))
			uhci_del_intr_info(ii);
d2598 2
a2599 2
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
	struct uhci_softc *sc = ii->sc;
d2607 1
a2607 1
	if (!uhci_active_intr_info(ii))
d2610 1
a2610 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2618 1
a2618 1
		uhci_free_std_chain(sc, ii->stdstart->link.std, ii->stdend);
d2627 2
a2628 2
	struct uhci_intr_info *ii = &UXFER(xfer)->iinfo;
	struct uhci_softc *sc = ii->sc;
d2631 2
a2632 2
	DPRINTFN(5,("uhci_device_bulk_done: xfer=%p ii=%p sc=%p upipe=%p\n",
		    xfer, ii, sc, upipe));
d2634 1
a2634 1
	if (!uhci_active_intr_info(ii))
d2637 1
a2637 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2641 1
a2641 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d3383 1
a3383 1
	UXFER(xfer)->iinfo.isdone = 1;
@


1.99
log
@Bring ohci(4) and uhci(4) in sync with ehci(4) by ensuring that a
transfer is submitted when a zero-length bulk or interrupt transfer
is requested.

This is the missing part of FreeBSD's svn r159024 that should have
been committed with ehci's r1.57.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.98 2013/05/30 16:15:02 deraadt Exp $	*/
d1256 1
a1256 1
	usb_rem_task(ii->xfer->pipe->device, &UXFER(ii->xfer)->abort_task);
d1405 1
a1405 1
	usb_init_task(&uxfer->abort_task, uhci_timeout_task, ii->xfer,
d1407 1
a1407 1
	usb_add_task(uxfer->xfer.pipe->device, &uxfer->abort_task);
d1846 1
a1846 1
		usb_rem_task(xfer->pipe->device, &UXFER(xfer)->abort_task);
d1861 1
a1861 1
	usb_rem_task(xfer->pipe->device, &UXFER(xfer)->abort_task);
@


1.98
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.97 2013/05/20 08:19:47 yasuoka Exp $	*/
d1650 2
a1654 5
	if (ntd == 0) {
		*sp = *ep = 0;
		DPRINTFN(-1,("uhci_alloc_std_chain: ntd=0\n"));
		return (USBD_NORMAL_COMPLETION);
	}
@


1.97
log
@Remove `abort_task' from usb task queue before recycling a `struct
usbd_xfer object' which includes the `abort_task'.  Otherwise
usb_abort_task_thread() may try to dequeue the recycled task then it
causes panic with page fault.

reported by Edd Barrett and Wade, Daniel.
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.96 2013/04/19 08:58:53 mpi Exp $	*/
a129 1
void		uhci_shutdown(void *v);
a503 1
	sc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);
d526 1
d544 4
d583 1
a604 3
	if (sc->sc_shutdownhook != NULL)
		shutdownhook_disestablish(sc->sc_shutdownhook);

a670 12
}

/*
 * Shut down the controller when the system is going down.
 */
void
uhci_shutdown(void *v)
{
	struct uhci_softc *sc = v;

	DPRINTF(("uhci_shutdown: stopping the HC\n"));
	uhci_run(sc, 0); /* stop the controller */
@


1.96
log
@Remove allocm() and freem() from the USB bus interface now that they
are only used as wrappers around usb_{alloc,free}mem().

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.95 2013/04/16 12:22:49 mpi Exp $	*/
d1267 1
d1860 1
d1875 1
@


1.95
log
@Don't be too clever when allocating a buffer for a transfer and do not
pre-allocate TDs to put them in the free list.

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.94 2013/04/15 09:23:02 mglocker Exp $	*/
a169 3
usbd_status	uhci_allocm(struct usbd_bus *, struct usb_dma *, u_int32_t);
void		uhci_freem(struct usbd_bus *, struct usb_dma *);

a282 2
	uhci_allocm,
	uhci_freem,
a620 14
}

usbd_status
uhci_allocm(struct usbd_bus *bus, struct usb_dma *dma, u_int32_t size)
{
	struct uhci_softc *sc = (struct uhci_softc *)bus;

	return (usb_allocmem(&sc->sc_bus, size, 0, dma));
}

void
uhci_freem(struct usbd_bus *bus, struct usb_dma *dma)
{
	usb_freemem(&((struct uhci_softc *)bus)->sc_bus, dma);
@


1.94
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.93 2013/03/28 03:58:03 tedu Exp $	*/
a631 25
	u_int32_t n;

	/*
	 * XXX
	 * Since we are allocating a buffer we can assume that we will
	 * need TDs for it.  Since we don't want to allocate those from
	 * an interrupt context, we allocate them here and free them again.
	 * This is no guarantee that we'll get the TDs next time...
	 */
	n = size / 8;
	if (n > 16) {
		u_int32_t i;
		struct uhci_soft_td **stds;
		DPRINTF(("uhci_allocm: get %d TDs\n", n));
		stds = malloc(sizeof(struct uhci_soft_td *) * n, M_TEMP,
			      M_NOWAIT | M_ZERO);
		if (stds == NULL)
			panic("uhci_allocm");
		for(i=0; i < n; i++)
			stds[i] = uhci_alloc_std(sc);
		for(i=0; i < n; i++)
			if (stds[i] != NULL)
				uhci_free_std(sc, stds[i]);
		free(stds, M_TEMP);
	}
d1563 1
d1571 1
d1579 1
d1581 2
d1586 3
a1588 1
	return std;
d1594 2
d1604 2
d1608 1
@


1.93
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.92 2012/08/17 17:29:00 krw Exp $	*/
d73 1
a73 1
uhci_softc_t *thesc;
d96 1
a96 1
	usbd_xfer_handle abortstart, abortend;
d102 3
a104 3
			uhci_soft_qh_t *sqh;
			usb_dma_t reqdma;
			uhci_soft_td_t *setup, *stat;
d111 1
a111 1
			uhci_soft_qh_t **qhs;
d115 1
a115 1
			uhci_soft_qh_t *sqh;
d121 1
a121 1
			uhci_soft_td_t **stds;
d127 3
a129 3
void		uhci_globalreset(uhci_softc_t *);
usbd_status	uhci_portreset(uhci_softc_t*, int);
void		uhci_reset(uhci_softc_t *);
d131 5
a135 5
usbd_status	uhci_run(uhci_softc_t *, int run);
uhci_soft_td_t  *uhci_alloc_std(uhci_softc_t *);
void		uhci_free_std(uhci_softc_t *, uhci_soft_td_t *);
uhci_soft_qh_t  *uhci_alloc_sqh(uhci_softc_t *);
void		uhci_free_sqh(uhci_softc_t *, uhci_soft_qh_t *);
d137 3
a139 3
void		uhci_enter_ctl_q(uhci_softc_t *, uhci_soft_qh_t *,
					 uhci_intr_info_t *);
void		uhci_exit_ctl_q(uhci_softc_t *, uhci_soft_qh_t *);
d142 2
a143 2
void		uhci_free_std_chain(uhci_softc_t *,
					    uhci_soft_td_t *, uhci_soft_td_t *);
d145 3
a147 2
			    uhci_softc_t *, u_int, int, u_int16_t, usb_dma_t *,
			    uhci_soft_td_t **, uhci_soft_td_t **);
d149 3
a151 3
void		uhci_waitintr(uhci_softc_t *, usbd_xfer_handle);
void		uhci_check_intr(uhci_softc_t *, uhci_intr_info_t *);
void		uhci_idone(uhci_intr_info_t *);
d153 1
a153 1
void		uhci_abort_xfer(usbd_xfer_handle, usbd_status status);
d157 6
a162 6
void		uhci_add_ls_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
void		uhci_add_hs_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
void		uhci_add_bulk(uhci_softc_t *, uhci_soft_qh_t *);
void		uhci_remove_ls_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
void		uhci_remove_hs_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
void		uhci_remove_bulk(uhci_softc_t *,uhci_soft_qh_t *);
d164 2
a165 2
void		uhci_add_loop(uhci_softc_t *sc);
void		uhci_rem_loop(uhci_softc_t *sc);
d167 2
a168 2
usbd_status	uhci_setup_isoc(usbd_pipe_handle pipe);
void		uhci_device_isoc_enter(usbd_xfer_handle);
d170 2
a171 2
usbd_status	uhci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
void		uhci_freem(struct usbd_bus *, usb_dma_t *);
d173 38
a210 38
usbd_xfer_handle	uhci_allocx(struct usbd_bus *);
void		uhci_freex(struct usbd_bus *, usbd_xfer_handle);

usbd_status	uhci_device_ctrl_transfer(usbd_xfer_handle);
usbd_status	uhci_device_ctrl_start(usbd_xfer_handle);
void		uhci_device_ctrl_abort(usbd_xfer_handle);
void		uhci_device_ctrl_close(usbd_pipe_handle);
void		uhci_device_ctrl_done(usbd_xfer_handle);

usbd_status	uhci_device_intr_transfer(usbd_xfer_handle);
usbd_status	uhci_device_intr_start(usbd_xfer_handle);
void		uhci_device_intr_abort(usbd_xfer_handle);
void		uhci_device_intr_close(usbd_pipe_handle);
void		uhci_device_intr_done(usbd_xfer_handle);

usbd_status	uhci_device_bulk_transfer(usbd_xfer_handle);
usbd_status	uhci_device_bulk_start(usbd_xfer_handle);
void		uhci_device_bulk_abort(usbd_xfer_handle);
void		uhci_device_bulk_close(usbd_pipe_handle);
void		uhci_device_bulk_done(usbd_xfer_handle);

usbd_status	uhci_device_isoc_transfer(usbd_xfer_handle);
usbd_status	uhci_device_isoc_start(usbd_xfer_handle);
void		uhci_device_isoc_abort(usbd_xfer_handle);
void		uhci_device_isoc_close(usbd_pipe_handle);
void		uhci_device_isoc_done(usbd_xfer_handle);

usbd_status	uhci_root_ctrl_transfer(usbd_xfer_handle);
usbd_status	uhci_root_ctrl_start(usbd_xfer_handle);
void		uhci_root_ctrl_abort(usbd_xfer_handle);
void		uhci_root_ctrl_close(usbd_pipe_handle);
void		uhci_root_ctrl_done(usbd_xfer_handle);

usbd_status	uhci_root_intr_transfer(usbd_xfer_handle);
usbd_status	uhci_root_intr_start(usbd_xfer_handle);
void		uhci_root_intr_abort(usbd_xfer_handle);
void		uhci_root_intr_close(usbd_pipe_handle);
void		uhci_root_intr_done(usbd_xfer_handle);
d212 1
a212 1
usbd_status	uhci_open(usbd_pipe_handle);
d216 1
a216 1
usbd_status	uhci_device_request(usbd_xfer_handle xfer);
d218 20
a237 20
void		uhci_add_intr(uhci_softc_t *, uhci_soft_qh_t *);
void		uhci_remove_intr(uhci_softc_t *, uhci_soft_qh_t *);
usbd_status	uhci_device_setintr(uhci_softc_t *sc,
			    struct uhci_pipe *pipe, int ival);

void		uhci_device_clear_toggle(usbd_pipe_handle pipe);
void		uhci_noop(usbd_pipe_handle pipe);

__inline__ uhci_soft_qh_t *uhci_find_prev_qh(uhci_soft_qh_t *,
						    uhci_soft_qh_t *);

#ifdef UHCI_DEBUG
void		uhci_dump_all(uhci_softc_t *);
void		uhci_dumpregs(uhci_softc_t *);
void		uhci_dump_qhs(uhci_soft_qh_t *);
void		uhci_dump_qh(uhci_soft_qh_t *);
void		uhci_dump_tds(uhci_soft_td_t *);
void		uhci_dump_td(uhci_soft_td_t *);
void		uhci_dump_ii(uhci_intr_info_t *ii);
void			uhci_dump(void);
d253 1
a253 1
UREAD1(uhci_softc_t *sc, bus_size_t r)
d260 1
a260 1
UREAD2(uhci_softc_t *sc, bus_size_t r)
d267 1
a267 1
UREAD4(uhci_softc_t *sc, bus_size_t r)
d355 2
a356 2
__inline__ uhci_soft_qh_t *
uhci_find_prev_qh(uhci_soft_qh_t *pqh, uhci_soft_qh_t *sqh)
d372 1
a372 1
uhci_globalreset(uhci_softc_t *sc)
d380 1
a380 1
uhci_init(uhci_softc_t *sc)
d384 2
a385 2
	uhci_soft_qh_t *clsqh, *chsqh, *bsqh, *sqh, *lsqh;
	uhci_soft_td_t *std;
d597 1
a597 1
	usbd_xfer_handle xfer;
d629 1
a629 1
uhci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
d644 1
a644 1
		uhci_soft_td_t **stds;
d646 1
a646 1
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP,
d662 1
a662 1
uhci_freem(struct usbd_bus *bus, usb_dma_t *dma)
d667 1
a667 1
usbd_xfer_handle
d671 1
a671 1
	usbd_xfer_handle xfer;
d697 1
a697 1
uhci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
d722 1
a722 1
	uhci_softc_t *sc = v;
d730 1
a730 1
uhci_dumpregs(uhci_softc_t *sc)
d746 1
a746 1
uhci_dump_td(uhci_soft_td_t *p)
d777 1
a777 1
uhci_dump_qh(uhci_soft_qh_t *sqh)
d792 1
a792 1
uhci_dump_all(uhci_softc_t *sc)
d802 1
a802 1
uhci_dump_qhs(uhci_soft_qh_t *sqh)
d833 1
a833 1
uhci_dump_tds(uhci_soft_td_t *std)
d835 1
a835 1
	uhci_soft_td_t *td;
d852 1
a852 1
uhci_dump_ii(uhci_intr_info_t *ii)
d854 1
a854 1
	usbd_pipe_handle pipe;
d856 1
a856 1
	usbd_device_handle dev;
d903 1
a903 1
	uhci_intr_info_t *ii;
d922 3
a924 3
	usbd_xfer_handle xfer = addr;
	usbd_pipe_handle pipe = xfer->pipe;
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
d957 1
a957 1
uhci_root_intr_done(usbd_xfer_handle xfer)
d962 1
a962 1
uhci_root_ctrl_done(usbd_xfer_handle xfer)
d973 1
a973 1
uhci_add_loop(uhci_softc_t *sc) {
d987 1
a987 1
uhci_rem_loop(uhci_softc_t *sc) {
d1000 1
a1000 1
uhci_add_hs_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1002 1
a1002 1
	uhci_soft_qh_t *eqh;
d1020 1
a1020 1
uhci_remove_hs_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1022 1
a1022 1
	uhci_soft_qh_t *pqh;
d1053 1
a1053 1
uhci_add_ls_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1055 1
a1055 1
	uhci_soft_qh_t *eqh;
d1070 1
a1070 1
uhci_remove_ls_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1072 1
a1072 1
	uhci_soft_qh_t *pqh;
d1092 1
a1092 1
uhci_add_bulk(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1094 1
a1094 1
	uhci_soft_qh_t *eqh;
d1110 1
a1110 1
uhci_remove_bulk(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1112 1
a1112 1
	uhci_soft_qh_t *pqh;
d1131 1
a1131 1
int uhci_intr1(uhci_softc_t *);
d1136 1
a1136 1
	uhci_softc_t *sc = arg;
d1146 1
a1146 1
uhci_intr1(uhci_softc_t *sc)
d1219 2
a1220 2
	uhci_softc_t *sc = v;
	uhci_intr_info_t *ii, *nextii;
d1256 1
a1256 1
uhci_check_intr(uhci_softc_t *sc, uhci_intr_info_t *ii)
d1258 1
a1258 1
	uhci_soft_td_t *std, *lstd;
d1316 1
a1316 1
uhci_idone(uhci_intr_info_t *ii)
d1318 1
a1318 1
	usbd_xfer_handle xfer = ii->xfer;
d1320 1
a1320 1
	uhci_soft_td_t *std;
d1345 1
a1345 1
		uhci_soft_td_t **stds = upipe->u.iso.stds;
d1446 1
a1446 1
	uhci_intr_info_t *ii = addr;
d1449 1
a1449 1
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
d1467 1
a1467 1
	usbd_xfer_handle xfer = addr;
d1484 1
a1484 1
uhci_waitintr(uhci_softc_t *sc, usbd_xfer_handle xfer)
d1487 1
a1487 1
	uhci_intr_info_t *ii;
d1518 1
a1518 1
	uhci_softc_t *sc = (uhci_softc_t *)bus;
d1525 1
a1525 1
uhci_reset(uhci_softc_t *sc)
d1540 1
a1540 1
uhci_run(uhci_softc_t *sc, int run)
d1581 2
a1582 2
uhci_soft_td_t *
uhci_alloc_std(uhci_softc_t *sc)
d1584 1
a1584 1
	uhci_soft_td_t *std;
d1587 1
a1587 1
	usb_dma_t dma;
d1605 1
a1605 1
	memset(&std->td, 0, sizeof(uhci_td_t));
d1610 1
a1610 1
uhci_free_std(uhci_softc_t *sc, uhci_soft_td_t *std)
d1624 2
a1625 2
uhci_soft_qh_t *
uhci_alloc_sqh(uhci_softc_t *sc)
d1627 1
a1627 1
	uhci_soft_qh_t *sqh;
d1630 1
a1630 1
	usb_dma_t dma;
d1648 1
a1648 1
	memset(&sqh->qh, 0, sizeof(uhci_qh_t));
d1653 1
a1653 1
uhci_free_sqh(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1660 2
a1661 2
uhci_free_std_chain(uhci_softc_t *sc, uhci_soft_td_t *std,
		    uhci_soft_td_t *stdend)
d1663 1
a1663 1
	uhci_soft_td_t *p;
d1672 3
a1674 3
uhci_alloc_std_chain(struct uhci_pipe *upipe, uhci_softc_t *sc, u_int len,
		     int rd, u_int16_t flags, usb_dma_t *dma,
		     uhci_soft_td_t **sp, uhci_soft_td_t **ep)
d1676 1
a1676 1
	uhci_soft_td_t *p, *lastp;
d1744 1
a1744 1
uhci_device_clear_toggle(usbd_pipe_handle pipe)
d1751 1
a1751 1
uhci_noop(usbd_pipe_handle pipe)
d1756 1
a1756 1
uhci_device_bulk_transfer(usbd_xfer_handle xfer)
d1773 1
a1773 1
uhci_device_bulk_start(usbd_xfer_handle xfer)
d1776 5
a1780 5
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_soft_td_t *data, *dataend;
	uhci_soft_qh_t *sqh;
d1859 1
a1859 1
uhci_device_bulk_abort(usbd_xfer_handle xfer)
d1876 1
a1876 1
uhci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d1878 1
a1878 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d1880 2
a1881 2
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
	uhci_soft_td_t *std;
d1937 1
a1937 1
uhci_device_bulk_close(usbd_pipe_handle pipe)
d1940 2
a1941 2
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
d1948 1
a1948 1
uhci_device_ctrl_transfer(usbd_xfer_handle xfer)
d1965 1
a1965 1
uhci_device_ctrl_start(usbd_xfer_handle xfer)
d1967 1
a1967 1
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
d1989 1
a1989 1
uhci_device_intr_transfer(usbd_xfer_handle xfer)
d2006 1
a2006 1
uhci_device_intr_start(usbd_xfer_handle xfer)
d2009 5
a2013 5
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_soft_td_t *data, *dataend;
	uhci_soft_qh_t *sqh;
d2089 1
a2089 1
uhci_device_ctrl_abort(usbd_xfer_handle xfer)
d2097 1
a2097 1
uhci_device_ctrl_close(usbd_pipe_handle pipe)
d2103 1
a2103 1
uhci_device_intr_abort(usbd_xfer_handle xfer)
d2115 1
a2115 1
uhci_device_intr_close(usbd_pipe_handle pipe)
d2118 1
a2118 1
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
d2143 1
a2143 1
uhci_device_request(usbd_xfer_handle xfer)
d2147 2
a2148 2
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
d2151 3
a2153 3
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_soft_td_t *setup, *data, *stat, *next, *dataend;
	uhci_soft_qh_t *sqh;
d2236 3
a2238 3
		uhci_soft_td_t *std;
		uhci_soft_qh_t *xqh;
		uhci_soft_qh_t *sxqh;
d2248 1
a2248 1
		sxqh = (uhci_soft_qh_t *)std;
d2273 1
a2273 1
uhci_device_isoc_transfer(usbd_xfer_handle xfer)
d2299 1
a2299 1
uhci_device_isoc_enter(usbd_xfer_handle xfer)
d2302 2
a2303 2
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
d2305 1
a2305 1
	uhci_soft_td_t *std;
d2369 1
a2369 1
uhci_device_isoc_start(usbd_xfer_handle xfer)
d2372 3
a2374 3
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_soft_td_t *end;
d2424 1
a2424 1
uhci_device_isoc_abort(usbd_xfer_handle xfer)
d2427 2
a2428 2
	uhci_soft_td_t **stds = upipe->u.iso.stds;
	uhci_soft_td_t *std;
d2470 1
a2470 1
uhci_device_isoc_close(usbd_pipe_handle pipe)
d2473 3
a2475 3
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
	uhci_soft_td_t *std, *vstd;
d2514 1
a2514 1
uhci_setup_isoc(usbd_pipe_handle pipe)
d2517 2
a2518 2
	usbd_device_handle dev = upipe->pipe.device;
	uhci_softc_t *sc = (uhci_softc_t *)dev->bus;
d2522 1
a2522 1
	uhci_soft_td_t *std, *vstd;
d2528 2
a2529 1
	iso->stds = malloc(UHCI_VFRAMELIST_COUNT * sizeof (uhci_soft_td_t *),
d2570 1
a2570 1
uhci_device_isoc_done(usbd_xfer_handle xfer)
d2572 1
a2572 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d2605 1
a2605 1
uhci_device_intr_done(usbd_xfer_handle xfer)
d2607 2
a2608 2
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_softc_t *sc = ii->sc;
d2610 1
a2610 1
	uhci_soft_qh_t *sqh;
d2625 1
a2625 1
		uhci_soft_td_t *data, *dataend;
d2667 1
a2667 1
uhci_device_ctrl_done(usbd_xfer_handle xfer)
d2669 2
a2670 2
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_softc_t *sc = ii->sc;
d2696 1
a2696 1
uhci_device_bulk_done(usbd_xfer_handle xfer)
d2698 2
a2699 2
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
	uhci_softc_t *sc = ii->sc;
d2719 1
a2719 1
uhci_add_intr(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d2722 1
a2722 1
	uhci_soft_qh_t *eqh;
d2737 1
a2737 1
uhci_remove_intr(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d2740 1
a2740 1
	uhci_soft_qh_t *pqh;
d2760 1
a2760 1
uhci_device_setintr(uhci_softc_t *sc, struct uhci_pipe *upipe, int ival)
d2762 1
a2762 1
	uhci_soft_qh_t *sqh, **qhs;
d2777 1
a2777 1
	qhs = malloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_NOWAIT);
d2826 1
a2826 1
uhci_open(usbd_pipe_handle pipe)
d2828 1
a2828 1
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
d2992 1
a2992 1
uhci_portreset(uhci_softc_t *sc, int index)
d3079 1
a3079 1
uhci_root_ctrl_transfer(usbd_xfer_handle xfer)
d3096 1
a3096 1
uhci_root_ctrl_start(usbd_xfer_handle xfer)
d3098 1
a3098 1
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
d3427 1
a3427 1
uhci_root_ctrl_abort(usbd_xfer_handle xfer)
d3434 1
a3434 1
uhci_root_ctrl_close(usbd_pipe_handle pipe)
d3441 1
a3441 1
uhci_root_intr_abort(usbd_xfer_handle xfer)
d3443 1
a3443 1
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
d3460 1
a3460 1
uhci_root_intr_transfer(usbd_xfer_handle xfer)
d3477 1
a3477 1
uhci_root_intr_start(usbd_xfer_handle xfer)
d3479 2
a3480 2
	usbd_pipe_handle pipe = xfer->pipe;
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
d3498 1
a3498 1
uhci_root_intr_close(usbd_pipe_handle pipe)
d3500 1
a3500 1
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
@


1.92
log
@Fix typos in DPRINTF() so error messages refer to correct *hci.

Spotted by Artturi Alm. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.91 2012/08/07 23:51:36 krw Exp $	*/
a50 1
#include <sys/proc.h>
@


1.91
log
@Make all *_device_*_start() functions (e.g. ohci_device_intr_start())
wait for an interrupt when the bus is in polling mode. Otherwise
some devices like my YE-Data USB Floppy take a short sharp trip to
ddb> at 'halt -p'.

Most of the functions were already doing the wait.

ok miod@@. With modification that printf's become DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.90 2011/07/03 15:47:17 matthew Exp $	*/
d2416 1
a2416 1
		DPRINTF(("Starting ohci isoc xfer with polling. Bad idea?\n"));
@


1.90
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.89 2010/12/14 16:13:16 jakemsr Exp $	*/
d1984 1
d2081 3
d2414 5
@


1.89
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.88 2010/12/06 06:09:08 jakemsr Exp $	*/
a527 2
	case DVACT_ACTIVATE:
		break;
@


1.88
log
@* if we got an undercoverable error, set the dying flag
* check the dying flag in timeout and interrupt handlers

fixes crash when disconnecting cardbus usb adapters
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.87 2010/12/06 05:48:56 jakemsr Exp $	*/
d932 1
a932 1
	if (sc->sc_dying)
d1140 1
a1140 1
	if (sc->sc_dying)
d1157 1
a1157 1
		sc->sc_dying = 1;
d1196 1
a1196 1
		if (!sc->sc_dying) {
d1203 1
a1203 1
		sc->sc_dying = 1;
d1227 1
a1227 1
	if (sc->sc_dying)
d1455 1
a1455 1
	if (sc->sc_dying) {
d1791 1
a1791 1
	if (sc->sc_dying)
d1888 1
a1888 1
	if (sc->sc_dying) {
d1972 1
a1972 1
	if (sc->sc_dying)
d2019 1
a2019 1
	if (sc->sc_dying)
d2311 1
a2311 1
	if (sc->sc_dying)
d2377 1
a2377 1
	if (sc->sc_dying)
d3098 1
a3098 1
	if (sc->sc_dying)
d3477 1
a3477 1
	if (sc->sc_dying)
@


1.87
log
@as in ehci and ohci, delete the interrupt timeout in the detach
routine
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.86 2010/11/21 01:29:07 matthew Exp $	*/
d932 3
d1226 3
@


1.86
log
@Properly handle when uhci_alloc_sqh() fails to allocate memory in
uhci_device_setintr().

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.85 2010/11/19 18:42:27 miod Exp $	*/
d610 5
@


1.85
log
@Do not allow malloc() to wait in uhci_device_setintr(), instead check for
failure and return USBD_NOMEM, callers will do TRT.
ok jakemser@@ deraadt@@ kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.84 2010/10/23 15:42:09 jakemsr Exp $	*/
d2743 1
a2743 1
	uhci_soft_qh_t *sqh;
d2758 2
a2759 4
	upipe->u.intr.npoll = npoll;
	upipe->u.intr.qhs =
	    malloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_NOWAIT);
	if (upipe->u.intr.qhs == NULL)
d2778 7
a2784 1
		upipe->u.intr.qhs[i] = sqh = uhci_alloc_sqh(sc);
d2788 1
d2791 3
@


1.84
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.83 2010/09/20 06:54:10 deraadt Exp $	*/
d2760 3
a2762 1
		malloc(npoll * sizeof(uhci_soft_qh_t *), M_USBHC, M_WAITOK);
@


1.83
log
@If during resume we get an interrupt, sure, be a bit noisy about it
for now.  But since it is not being handled, do not ack it on the
chip.
Discussed with kettenis a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.82 2010/09/20 03:28:48 jsg Exp $	*/
d1450 2
a1451 1
	usb_init_task(&uxfer->abort_task, uhci_timeout_task, ii->xfer);
@


1.82
log
@Fix unitialised variable access in the suspend/resume case
that crept in with rev 1.77, spotted by the clang static analyser.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.81 2010/09/07 16:21:46 deraadt Exp $	*/
a1162 1
		UWRITE2(sc, UHCI_STS, status); /* acknowledge the ints */
@


1.81
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.80 2010/09/06 19:20:24 deraadt Exp $	*/
d545 1
d559 1
@


1.80
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.79 2010/08/31 16:47:36 deraadt Exp $	*/
a131 1
void		uhci_powerhook(int, void *);
a509 1
	sc->sc_powerhook = powerhook_establish(uhci_powerhook, sc);
d549 1
a549 1
		DPRINTF(("uhci_powerhook: cmd=0x%x\n", UREAD2(sc, UHCI_CMD)));
a605 2
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
a720 13
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an interrupt context.  This is all right since we
 * are almost suspended anyway.
 */
void
uhci_powerhook(int why, void *v)
{
	uhci_activate(v, why);
@


1.79
log
@sort DVACT_ actions according to the order likely to be used
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.78 2010/08/31 03:50:15 deraadt Exp $	*/
d510 1
a510 1
	sc->sc_suspend = PWR_RESUME;
d555 1
a555 1
		if (sc->sc_suspend == PWR_RESUME)
d1175 1
a1175 1
	if (sc->sc_suspend != PWR_RESUME) {
@


1.78
log
@uhci is apparently is unaware that it could be on a shared interrupt
It is OK to return 0 in that case, but it is not OK to print a
diagnostic.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.77 2010/08/30 21:30:17 deraadt Exp $	*/
a531 4
	case DVACT_DEACTIVATE:
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
		break;
d587 4
@


1.77
log
@Change powerhooks into activate functions, and provide stub powerhook
functions
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.76 2010/08/27 04:09:21 deraadt Exp $	*/
d1149 1
a1149 5

	if (sc->sc_bus.use_polling) {
#ifdef DIAGNOSTIC
		DPRINTFN(16, ("uhci_intr: ignored interrupt while polling\n"));
#endif
a1150 1
	}
@


1.76
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.75 2010/05/01 19:43:57 jsg Exp $	*/
d132 1
a132 1
void		uhci_power(int, void *);
d511 1
a511 1
	sc->sc_powerhook = powerhook_establish(uhci_power, sc);
d527 1
a527 1
	int rv = 0;
a531 1

d537 19
a555 1
		uhci_power(PWR_SUSPEND, sc);
d558 33
a590 1
		uhci_power(PWR_RESUME, sc);
d735 1
a735 1
uhci_power(int why, void *v)
d737 1
a737 69
	uhci_softc_t *sc = v;
	int cmd;
	int s;

	s = splhardusb();
	cmd = UREAD2(sc, UHCI_CMD);

	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n",
		 sc, why, sc->sc_suspend, cmd));

	switch (why) {
	case PWR_SUSPEND:
#ifdef UHCI_DEBUG
		if (uhcidebug > 2)
			uhci_dumpregs(sc);
#endif
		if (sc->sc_intr_xfer != NULL)
			timeout_del(&sc->sc_poll_handle);
		sc->sc_bus.use_polling++;
		uhci_run(sc, 0); /* stop the controller */

		/* save some state if BIOS doesn't */
		sc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);

		UWRITE2(sc, UHCI_INTR, 0); /* disable intrs */

		UHCICMD(sc, cmd | UHCI_CMD_EGSM); /* enter global suspend */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
		sc->sc_suspend = why;
		sc->sc_bus.use_polling--;
		DPRINTF(("uhci_power: cmd=0x%x\n", UREAD2(sc, UHCI_CMD)));
		break;
	case PWR_RESUME:
#ifdef DIAGNOSTIC
		if (sc->sc_suspend == PWR_RESUME)
			printf("uhci_power: weird, resume without suspend.\n");
#endif
		sc->sc_bus.use_polling++;
		sc->sc_suspend = why;
		if (cmd & UHCI_CMD_RS)
			uhci_run(sc, 0); /* in case BIOS has started it */

		/* restore saved state */
		UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma, 0));
		UWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);
		UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);

		UHCICMD(sc, cmd | UHCI_CMD_FGR); /* force global resume */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		UHCICMD(sc, cmd & ~UHCI_CMD_EGSM); /* back to normal */
		UHCICMD(sc, UHCI_CMD_MAXP);
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
			UHCI_INTR_IOCE | UHCI_INTR_SPIE); /* re-enable intrs */
		uhci_run(sc, 1); /* and start traffic again */
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_bus.use_polling--;
		if (sc->sc_intr_xfer != NULL) {
			timeout_del(&sc->sc_poll_handle);
			timeout_set(&sc->sc_poll_handle, uhci_poll_hub,
			    sc->sc_intr_xfer);
			timeout_add(&sc->sc_poll_handle, sc->sc_ival);
		}
#ifdef UHCI_DEBUG
		if (uhcidebug > 2)
			uhci_dumpregs(sc);
#endif
		break;
	}
	splx(s);
@


1.75
log
@put the read macros into functions so gcc4 doesn't whinge.
ok marco@@ oga@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.74 2009/11/26 12:27:48 deraadt Exp $	*/
a699 1
	case PWR_STANDBY:
@


1.74
log
@Call the existing power functions with our activate function for
the suspend and resume operations
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.73 2009/11/04 19:14:10 kettenis Exp $	*/
d252 21
a272 3
#define UREAD1(sc, r) (UBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
#define UREAD2(sc, r) (UBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
#define UREAD4(sc, r) (UBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
@


1.73
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.72 2009/10/13 19:33:17 pirofti Exp $	*/
d518 6
@


1.72
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.71 2009/07/24 08:15:38 blambert Exp $	*/
a1253 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1257 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a1923 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1924 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a1925 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1927 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
@


1.71
log
@timeout_add -> timeout_add_msec

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.70 2009/06/02 23:49:33 deraadt Exp $	*/
d506 1
a506 1
uhci_activate(struct device *self, enum devact act)
@


1.70
log
@ehci_alloc_sqtd_chain() was doing signed math on len, thus the great code
	curlen -= curlen % mps;
can for very large transfers result in an intermediate variable growing
larger than it should.  Probably can't really happen in the real world.
Do the same u_int repairs to the other matching drivers
ok blambert kjell miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.69 2008/11/21 17:08:42 deraadt Exp $	*/
d1848 1
a1848 1
		timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
d2273 1
a2273 1
		timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
@


1.69
log
@if interrupt register is all 1s, we know we are dead; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.68 2008/06/29 10:04:15 yuo Exp $	*/
d147 1
a147 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *,
d1681 1
a1681 1
uhci_alloc_std_chain(struct uhci_pipe *upipe, uhci_softc_t *sc, int len,
d1692 1
a1692 1
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%d speed=%d "
d1791 2
a1792 1
	int len, isread, endpt;
d1795 1
a1795 1
	DPRINTFN(3, ("uhci_device_bulk_start: xfer=%p len=%d flags=%d ii=%p\n",
d2033 1
a2033 1
	DPRINTFN(3,("uhci_device_intr_start: xfer=%p len=%d flags=%d\n",
d2163 1
a2163 1
	int len;
d2170 1
a2170 1
		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
d3475 1
a3475 1
	DPRINTFN(3, ("uhci_root_intr_start: xfer=%p len=%d flags=%d\n",
@


1.68
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.67 2008/06/26 05:42:18 ray Exp $	*/
d1164 4
@


1.67
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.66 2008/06/22 19:00:51 fgsch Exp $	*/
d3380 4
@


1.66
log
@correct function names on some debug and panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.65 2008/06/21 02:40:39 fgsch Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.65
log
@fix probable cut and paste error when for the virtual QH link.
from netbsd via dragonfly. pointed by theo. ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.64 2007/11/25 16:40:03 jmc Exp $	*/
d991 1
a991 1
		DPRINTFN(5,("uhci_start_loop: add\n"));
d1005 1
a1005 1
		DPRINTFN(5,("uhci_end_loop: remove\n"));
d1018 1
a1018 1
	DPRINTFN(10, ("uhci_add_ctrl: sqh=%p\n", sqh));
d1225 1
a1225 1
	DPRINTFN(15, ("%s: uhci_intr: exit\n", sc->sc_bus.bdev.dv_xname));
d1805 1
a1805 1
		panic("uhci_device_bulk_transfer: a request");
d1824 1
a1824 1
		DPRINTF(("uhci_device_bulk_transfer: data(1)\n"));
d1835 1
a1835 1
		printf("uhci_device_bulk_transfer: not done, ii=%p\n", ii);
d1857 1
a1857 1
		DPRINTF(("uhci_device_bulk_transfer: data(2)\n"));
d2035 1
a2035 1
	DPRINTFN(3,("uhci_device_intr_transfer: xfer=%p len=%d flags=%d\n",
d2040 1
a2040 1
		panic("uhci_device_intr_transfer: a request");
d2058 1
a2058 1
		DPRINTF(("uhci_device_intr_transfer: data(1)\n"));
d2076 1
a2076 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n",
d2089 1
a2089 1
		DPRINTF(("uhci_device_intr_transfer: data(2)\n"));
d2171 1
a2171 1
	DPRINTFN(3,("uhci_device_control type=0x%02x, request=0x%02x, "
d2252 1
a2252 1
		DPRINTF(("uhci_enter_ctl_q: follow from [0]\n"));
d2579 1
a2579 1
	DPRINTFN(4, ("uhci_isoc_done: length=%d\n", xfer->actlen));
d3106 1
a3106 1
		panic("uhci_root_ctrl_transfer: not a request");
d3110 1
a3110 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n",
d3137 1
a3137 1
		DPRINTFN(2,("uhci_root_ctrl_control wValue=0x%04x\n", value));
d3236 1
a3236 1
		DPRINTFN(3, ("uhci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
@


1.64
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.63 2007/09/11 13:39:34 gilles Exp $	*/
d454 1
a454 1
	clsqh->hlink = bsqh;
@


1.63
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.62 2007/09/10 16:29:28 fgsch Exp $	*/
d2632 1
a2632 1
		DPRINTFN(5,("uhci_device_intr_done: requeing\n"));
@


1.62
log
@more M_ZERO usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.61 2007/07/20 14:31:17 mbalmer Exp $	*/
d580 1
a580 1
			      M_NOWAIT|M_ZERO);
@


1.61
log
@Don't show debug output when an interrupt is not for us.

From Marc Winiger <mw@@msys.ch>

ok dlg, claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.60 2007/06/15 11:41:48 mbalmer Exp $	*/
d580 1
a580 1
			      M_NOWAIT);
a582 1
		memset(stds, 0, sizeof(uhci_soft_td_t *) * n);
@


1.60
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.59 2007/06/14 12:58:09 mbalmer Exp $	*/
d1169 4
a1178 4

	status = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
	if (status == 0)	/* The interrupt was not for us. */
		return (0);
@


1.59
log
@Move the mstohz macro out of ubs_port.h and to the three places where it is
used.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.58 2007/06/12 16:26:36 mbalmer Exp $	*/
d1258 1
a1258 1
#ifdef USB_USE_SOFTINTR
d1263 1
a1263 1
#endif /* USB_USE_SOFTINTR */
d1929 1
a1929 1
#ifdef USB_USE_SOFTINTR
d1931 1
a1931 1
#endif /* USB_USE_SOFTINTR */
d1933 1
a1933 1
#ifdef USB_USE_SOFTINTR
d1936 1
a1936 1
#endif /* USB_USE_SOFTINTR */
@


1.58
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.57 2007/06/10 14:49:01 mbalmer Exp $	*/
d91 2
@


1.57
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.56 2007/06/10 10:15:35 mbalmer Exp $	*/
d511 1
a511 1
uhci_activate(device_ptr_t self, enum devact act)
@


1.56
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.55 2007/06/05 08:43:55 mbalmer Exp $	*/
d748 1
a748 1
		     USBDEVNAME(sc->sc_bus.bdev),
d1169 1
a1169 1
		DPRINTF(("%s: uhci_intr1\n", USBDEVNAME(sc->sc_bus.bdev)));
d1180 1
a1180 1
		       USBDEVNAME(sc->sc_bus.bdev));
d1193 1
a1193 1
		printf("%s: resume detect\n", USBDEVNAME(sc->sc_bus.bdev));
d1198 1
a1198 1
		printf("%s: host system error\n", USBDEVNAME(sc->sc_bus.bdev));
d1203 1
a1203 1
		       USBDEVNAME(sc->sc_bus.bdev));
d1209 1
a1209 1
			    USBDEVNAME(sc->sc_bus.bdev));
d1224 1
a1224 1
	DPRINTFN(15, ("%s: uhci_intr: exit\n", USBDEVNAME(sc->sc_bus.bdev)));
d1235 1
a1235 1
	DPRINTFN(10,("%s: uhci_softintr (%d)\n", USBDEVNAME(sc->sc_bus.bdev),
d1547 1
a1547 1
		       USBDEVNAME(sc->sc_bus.bdev));
d1577 1
a1577 1
	printf("%s: cannot %s\n", USBDEVNAME(sc->sc_bus.bdev),
@


1.55
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.54 2007/05/21 06:10:43 jsg Exp $	*/
d491 1
a491 1
	usb_callout_init(sc->sc_poll_handle);
d688 1
a688 2
			usb_uncallout(sc->sc_poll_handle, uhci_poll_hub,
			    sc->sc_intr_xfer);
d727 6
a732 3
		if (sc->sc_intr_xfer != NULL)
			usb_callout(sc->sc_poll_handle, sc->sc_ival,
				    uhci_poll_hub, sc->sc_intr_xfer);
d944 3
a946 1
	usb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);
d1322 1
a1322 1
	usb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);
d1847 3
a1849 2
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    uhci_timeout, ii);
d1900 1
a1900 1
		usb_uncallout(xfer->timeout_handle, uhci_timeout, xfer);
d1914 1
a1914 1
	usb_uncallout(xfer->timeout_handle, uhci_timeout, ii);
d2272 3
a2274 2
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
			    uhci_timeout, ii);
d3435 1
a3435 1
	usb_uncallout(sc->sc_poll_handle, uhci_poll_hub, xfer);
d3479 3
a3481 1
	usb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);
d3492 1
a3492 1
	usb_uncallout(sc->sc_poll_handle, uhci_poll_hub, sc->sc_intr_xfer);
@


1.54
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.53 2007/05/21 04:55:14 jsg Exp $	*/
d133 10
a142 10
Static void		uhci_globalreset(uhci_softc_t *);
Static usbd_status	uhci_portreset(uhci_softc_t*, int);
Static void		uhci_reset(uhci_softc_t *);
Static void		uhci_shutdown(void *v);
Static void		uhci_power(int, void *);
Static usbd_status	uhci_run(uhci_softc_t *, int run);
Static uhci_soft_td_t  *uhci_alloc_std(uhci_softc_t *);
Static void		uhci_free_std(uhci_softc_t *, uhci_soft_td_t *);
Static uhci_soft_qh_t  *uhci_alloc_sqh(uhci_softc_t *);
Static void		uhci_free_sqh(uhci_softc_t *, uhci_soft_qh_t *);
d144 1
a144 1
Static void		uhci_enter_ctl_q(uhci_softc_t *, uhci_soft_qh_t *,
d146 1
a146 1
Static void		uhci_exit_ctl_q(uhci_softc_t *, uhci_soft_qh_t *);
d149 1
a149 1
Static void		uhci_free_std_chain(uhci_softc_t *,
d151 1
a151 1
Static usbd_status	uhci_alloc_std_chain(struct uhci_pipe *,
d154 73
a226 73
Static void		uhci_poll_hub(void *);
Static void		uhci_waitintr(uhci_softc_t *, usbd_xfer_handle);
Static void		uhci_check_intr(uhci_softc_t *, uhci_intr_info_t *);
Static void		uhci_idone(uhci_intr_info_t *);

Static void		uhci_abort_xfer(usbd_xfer_handle, usbd_status status);

Static void		uhci_timeout(void *);
Static void		uhci_timeout_task(void *);
Static void		uhci_add_ls_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_add_hs_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_add_bulk(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_remove_ls_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
Static void		uhci_remove_hs_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
Static void		uhci_remove_bulk(uhci_softc_t *,uhci_soft_qh_t *);
Static int		uhci_str(usb_string_descriptor_t *, int, char *);
Static void		uhci_add_loop(uhci_softc_t *sc);
Static void		uhci_rem_loop(uhci_softc_t *sc);

Static usbd_status	uhci_setup_isoc(usbd_pipe_handle pipe);
Static void		uhci_device_isoc_enter(usbd_xfer_handle);

Static usbd_status	uhci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		uhci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	uhci_allocx(struct usbd_bus *);
Static void		uhci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	uhci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_ctrl_start(usbd_xfer_handle);
Static void		uhci_device_ctrl_abort(usbd_xfer_handle);
Static void		uhci_device_ctrl_close(usbd_pipe_handle);
Static void		uhci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	uhci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_intr_start(usbd_xfer_handle);
Static void		uhci_device_intr_abort(usbd_xfer_handle);
Static void		uhci_device_intr_close(usbd_pipe_handle);
Static void		uhci_device_intr_done(usbd_xfer_handle);

Static usbd_status	uhci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_bulk_start(usbd_xfer_handle);
Static void		uhci_device_bulk_abort(usbd_xfer_handle);
Static void		uhci_device_bulk_close(usbd_pipe_handle);
Static void		uhci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	uhci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_isoc_start(usbd_xfer_handle);
Static void		uhci_device_isoc_abort(usbd_xfer_handle);
Static void		uhci_device_isoc_close(usbd_pipe_handle);
Static void		uhci_device_isoc_done(usbd_xfer_handle);

Static usbd_status	uhci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	uhci_root_ctrl_start(usbd_xfer_handle);
Static void		uhci_root_ctrl_abort(usbd_xfer_handle);
Static void		uhci_root_ctrl_close(usbd_pipe_handle);
Static void		uhci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	uhci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	uhci_root_intr_start(usbd_xfer_handle);
Static void		uhci_root_intr_abort(usbd_xfer_handle);
Static void		uhci_root_intr_close(usbd_pipe_handle);
Static void		uhci_root_intr_done(usbd_xfer_handle);

Static usbd_status	uhci_open(usbd_pipe_handle);
Static void		uhci_poll(struct usbd_bus *);
Static void		uhci_softintr(void *);

Static usbd_status	uhci_device_request(usbd_xfer_handle xfer);

Static void		uhci_add_intr(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_remove_intr(uhci_softc_t *, uhci_soft_qh_t *);
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc,
d229 2
a230 2
Static void		uhci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		uhci_noop(usbd_pipe_handle pipe);
d232 1
a232 1
Static __inline__ uhci_soft_qh_t *uhci_find_prev_qh(uhci_soft_qh_t *,
d236 7
a242 7
Static void		uhci_dump_all(uhci_softc_t *);
Static void		uhci_dumpregs(uhci_softc_t *);
Static void		uhci_dump_qhs(uhci_soft_qh_t *);
Static void		uhci_dump_qh(uhci_soft_qh_t *);
Static void		uhci_dump_tds(uhci_soft_td_t *);
Static void		uhci_dump_td(uhci_soft_td_t *);
Static void		uhci_dump_ii(uhci_intr_info_t *ii);
d343 1
a343 1
Static __inline__ uhci_soft_qh_t *
d741 1
a741 1
Static void
d863 1
a863 1
Static void
d1138 1
a1138 1
Static int uhci_intr1(uhci_softc_t *);
d2979 1
a2979 1
Static usbd_status
@


1.53
log
@Remove ifdef __otherbsd__ mess; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.52 2007/04/01 23:30:44 jsg Exp $	*/
d350 1
a350 1
		if (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {
d765 4
a768 4
		     (long)le32toh(p->td.td_link),
		     (long)le32toh(p->td.td_status),
		     (long)le32toh(p->td.td_token),
		     (long)le32toh(p->td.td_buffer)));
d770 1
a770 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
d772 1
a772 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_status),
d779 7
a785 7
		     UHCI_TD_GET_ERRCNT(le32toh(p->td.td_status)),
		     UHCI_TD_GET_ACTLEN(le32toh(p->td.td_status)),
		     UHCI_TD_GET_PID(le32toh(p->td.td_token)),
		     UHCI_TD_GET_DEVADDR(le32toh(p->td.td_token)),
		     UHCI_TD_GET_ENDPT(le32toh(p->td.td_token)),
		     UHCI_TD_GET_DT(le32toh(p->td.td_token)),
		     UHCI_TD_GET_MAXLEN(le32toh(p->td.td_token))));
d792 2
a793 2
	    (int)sqh->physaddr, le32toh(sqh->qh.qh_hlink),
	    le32toh(sqh->qh.qh_elink)));
d833 1
a833 1
	if (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))
d838 1
a838 1
	if (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))
d857 2
a858 2
		if (le32toh(td->td.td_link) & UHCI_PTR_T ||
		    le32toh(td->td.td_link) == 0)
d1296 1
a1296 1
	if (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {
d1299 1
a1299 1
			status = le32toh(std->td.td_status);
d1309 1
a1309 1
			      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))
d1371 1
a1371 1
			status = le32toh(std->td.td_status);
d1392 1
a1392 1
		nstatus = le32toh(std->td.td_status);
d1397 1
a1397 1
		if (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=
d1412 1
a1412 1
		upipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));
d1621 1
a1621 1
	if (le32toh(std->td.td_token) == TD_IS_FREE) {
d2250 1
a2250 1
			link = le32toh(std->td.td_link);
d2449 1
a2449 1
		len = UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token));
@


1.52
log
@Correct URL to UHCI spec.
From dunceor@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.51 2007/03/22 05:47:16 pascoe Exp $	*/
a55 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a57 8
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <machine/bus_pio.h>
#if defined(DIAGNOSTIC) && defined(__i386__)
#include <machine/cpu.h>
#endif
#endif
a75 7
#if defined(__FreeBSD__)
#include <machine/clock.h>

#define delay(d)		DELAY(d)
#endif

#if defined(__OpenBSD__)
a78 1
#endif
a85 1
#ifndef __NetBSD__
a86 1
#endif
a95 9
#if defined(__FreeBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
#endif
a496 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a499 1
#endif
a509 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a539 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a543 1
#endif
a557 1
#endif
a735 6
#if defined(__NetBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
@


1.51
log
@Reapplication of rev 1.49.

Save SOF (frame timing adjustment) before the very first host controller
reset, rather than at suspend/resume, otherwise any BIOS inserted value
is lost immediately.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.50 2007/03/18 20:14:51 mglocker Exp $	*/
d46 1
a46 1
 * UHCI spec: http://developer.intel.com/design/USB/UHCI11D.htm
@


1.50
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.48 2006/06/23 06:27:11 miod Exp $	*/
d412 3
d419 3
a728 1
		sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);
@


1.49
log
@Save SOF (frame timing adjustment) before the very first host controller
reset, rather than at suspend/resume, otherwise any BIOS inserted value
is lost immediately.

ok dlg@@
@
text
@a411 3
	/* Save SOF over HC reset. */
	sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);

a415 3
	/* Restore saved SOF. */
	UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);

d723 1
@


1.48
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.47 2006/05/31 06:18:09 pascoe Exp $	*/
d412 3
d419 3
a728 1
		sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);
@


1.47
log
@Save and restore the data toggle value when a pipe to an endpoint
is closed and then reopened.  This may be necessary now that
we no longer clear endpoint stalls every time a pipe is opened.
Previously we could assume an initial toggle value of zero because
a clear-stall operation resets the device's toggle state.

Derived from work in FreeBSD.

This is most likely to affect devices like printers, which open
pipes for short periods of time and close them again.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.46 2006/05/29 04:15:49 pascoe Exp $	*/
d543 1
a543 1
		return (EOPNOTSUPP);
@


1.46
log
@Fix a comment, remove a stray variable assignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.45 2006/05/29 03:15:05 pascoe Exp $	*/
d1988 1
d2862 1
a2862 1
	upipe->nexttoggle = 0;
@


1.45
log
@Only do the software part of an abort if we are dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.44 2006/05/22 20:35:12 krw Exp $	*/
d1328 1
a1328 1
	 * is a an error somewhere in the middle, or whether there was a
a2072 1
	sqh = upipe->u.bulk.sqh;
@


1.44
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.43 2006/04/21 07:29:11 jolan Exp $	*/
d1933 1
@


1.43
log
@implement outgoing interrupt pipes, lets my creative voip blaster work

from freebsd, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.42 2005/12/03 03:40:52 brad Exp $	*/
d566 4
a569 2
	powerhook_disestablish(sc->sc_powerhook);
	shutdownhook_disestablish(sc->sc_shutdownhook);
@


1.42
log
@Allow strings descriptor 0 to be fetched.  It's the default language index.

From augustss NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.41 2005/11/21 18:16:43 millert Exp $	*/
d144 1
d2054 1
d2068 10
a2077 2
	err = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,
				   &xfer->dmabuf, &data, &dataend);
d2660 2
a2661 1
		uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,
@


1.41
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.40 2005/11/15 07:02:37 miod Exp $	*/
d3186 3
@


1.40
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.39 2005/10/04 22:55:30 brad Exp $	*/
d58 1
a58 1
#include <sys/select.h>
@


1.39
log
@Make sure we don't enable host controller interrupts until all
initialization is finished.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.38 2005/04/19 08:33:26 damien Exp $	*/
d2924 1
a2924 1
	1,2,0,			/* string indicies */
@


1.38
log
@fix for isochronous pipes:
xfer's busy_free status can be XFER_ONQU when uhci_device_isoc_done()
is called. this happens when the xfer is queued in the driver supplied
callback function that is called before uhci_device_isoc_done().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.37 2004/11/11 12:15:48 dlg Exp $	*/
d524 2
a528 2

	UHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */
@


1.37
log
@Handle all types of interrupts when operating in polled mode.

from Danovitsch@@vitsch.net
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.36 2004/08/11 04:25:53 dlg Exp $	*/
d2604 2
a2605 3
	if (xfer->busy_free != XFER_BUSY) {
		printf("uhci_device_isoc_done: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
@


1.36
log
@from netbsd, uhci.c revision 1.175, 1.179, 1.181
log message for 1.175:
Tweak a debugging printf().

log message for 1.179:
Make one message dependent on ohcidebug, so it doesn't interfere with polled
operation; e.g. when entering a root device or in DDB.

log message for 1.181:
typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.35 2004/08/11 04:24:27 dlg Exp $	*/
d1534 1
a1534 1
		if (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT) {
d1559 1
a1559 1
	if (UREAD2(sc, UHCI_STS) & UHCI_STS_USBINT)
@


1.35
log
@from netbsd, uhci.c revision 1.180

hcpriv is not actually used here.  Remove references to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.34 2004/08/11 04:23:15 dlg Exp $	*/
d113 1
a113 1
 * the data strored in memory needs to be swapped.
a1179 1
	DPRINTFN(15,("uhci_intr: real interrupt\n"));
d1182 1
a1182 1
		printf("uhci_intr: ignored interrupt while polling\n");
d1252 1
a1252 1
	DPRINTFN(10, ("%s: uhci_intr: exit\n", USBDEVNAME(sc->sc_bus.bdev)));
@


1.34
log
@from netbsd, uhci.c revision 1.178

Interrupt descriptors might become invalid while being processed in
uhci_check_intr - so remember their next pointer before calling it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.33 2004/08/11 04:21:44 dlg Exp $	*/
a1966 2
	xfer->hcpriv = ii;

@


1.33
log
@from netbsd, uhci.c revision 1.176

Ignore a CRCTO error on a SETUP transaction in combination with STALLED or NAK.
This fixes problems with the GL641.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.32 2004/07/11 05:29:16 deraadt Exp $	*/
d1262 1
a1262 1
	uhci_intr_info_t *ii;
d1280 2
a1281 1
	for (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))
d1283 1
@


1.32
log
@from netbsd via loki@@animata.net
uhub.c revision 1.65, ohci.c revision 1.146, uhci.c revision 1.177
Use the correct wValue to get hub desriptors.
Also, make wValue checks of root hub codes less strict.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.31 2004/05/04 16:59:32 grange Exp $	*/
d1429 1
a1429 1
			UHCI_TD_PID_SETUP)
d1431 9
@


1.31
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.30 2003/08/23 15:16:07 fgsch Exp $	*/
d3307 1
a3307 1
		if (value != 0) {
@


1.30
log
@correct function names; from NetBSD.
krw@@ and tdeval@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.28 2003/05/19 04:17:53 nate Exp $	*/
d574 1
a574 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
d632 1
a632 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
@


1.29
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d2626 1
a2626 1
	DPRINTFN(5, ("uhci_intr_done: length=%d\n", xfer->actlen));
d2687 1
a2687 1
		panic("uhci_ctrl_done: not a request");
d2703 1
a2703 1
	DPRINTFN(5, ("uhci_ctrl_done: length=%d\n", xfer->actlen));
d2714 1
a2714 1
	DPRINTFN(5,("uhci_device_ctrl_done: xfer=%p ii=%p sc=%p upipe=%p\n",
d2726 1
a2726 1
	DPRINTFN(5, ("uhci_bulk_done: length=%d\n", xfer->actlen));
d2778 1
a2778 1
	DPRINTFN(2, ("uhci_setintr: pipe=%p\n", upipe));
d2780 1
a2780 1
		printf("uhci_setintr: 0 interval\n");
d2787 1
a2787 1
	DPRINTFN(2, ("uhci_setintr: ival=%d npoll=%d\n", ival, npoll));
d2806 1
a2806 1
	DPRINTFN(1, ("uhci_setintr: bw=%d offs=%d\n", bestbw, bestoffs));
d2822 1
a2822 1
	DPRINTFN(5, ("uhci_setintr: returns %p\n", upipe));
d3477 1
a3477 1
	DPRINTFN(3, ("uhci_root_intr_transfer: xfer=%p len=%d flags=%d\n",
@


1.28
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.27 2002/10/12 01:09:44 krw Exp $	*/
/*	$NetBSD: uhci.c,v 1.142 2001/10/25 02:08:13 augustss Exp $	*/
a90 2
#define MS_TO_TICKS(ms) ((ms) * hz / 1000)

d161 1
d189 1
d252 1
a252 1
Static void		uhci_remove_intr(uhci_softc_t*, uhci_soft_qh_t*);
d276 2
a277 1
 do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
d279 2
a280 1
 do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
d282 2
a283 1
 do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
d362 1
a362 1
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ii), list);
d364 5
a368 1
	LIST_REMOVE((ii), list)
a410 1
	uhci_run(sc, 0);			/* stop the controller */
d421 1
a421 1
	sc->sc_pframes = KERNADDR(&sc->sc_dma);
d423 1
a423 1
	UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list*/
a542 1
		break;
d593 1
a593 1
	 * need TDs for it.  Since we don't want to alolocate those from
d602 2
a603 1
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP, M_NOWAIT);
d741 1
a741 1
		UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma));
d748 1
d802 1
a802 1
	bitmask_snprintf((int)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
d804 1
a804 1
	bitmask_snprintf((int)le32toh(p->td.td_status),
d976 1
a976 1
	p = KERNADDR(&xfer->dmabuf);
d1083 1
a1083 1
	pqh->hlink       = sqh->hlink;
d1100 1
a1100 1
	sqh->hlink       = eqh->hlink;
d1102 1
a1102 1
	eqh->hlink       = sqh;
d1122 1
a1122 1
	pqh->hlink       = sqh->hlink;
d1139 1
a1139 1
	sqh->hlink       = eqh->hlink;
d1141 1
a1141 1
	eqh->hlink       = sqh;
d1177 3
d1203 1
a1203 1
	status = UREAD2(sc, UHCI_STS);
a1206 5
#if defined(DIAGNOSTIC) && defined(__NetBSD__)
	if (sc->sc_suspend != PWR_RESUME)
		printf("uhci_intr: suspended sts=0x%x\n", status);
#endif

d1283 7
d1307 6
a1381 6
	if (xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_idone: aborted xfer=%p\n", xfer));
		return;
	}

d1444 2
a1445 1
		bitmask_snprintf((int)status, "\20\22BITSTUFF\23CRCTO\24NAK\25"
d1477 5
d1483 4
a1486 1
	DPRINTF(("uhci_timeout: ii=%p\n", ii));
d1488 12
a1499 4
#ifdef UHCI_DEBUG
	if (uhcidebug > 10)
		uhci_dump_tds(ii->stdstart);
#endif
d1501 3
a1503 3
	ii->xfer->device->bus->intr_context++;
	uhci_abort_xfer(ii->xfer, USBD_TIMEOUT);
	ii->xfer->device->bus->intr_context--;
d1626 2
a1627 2
			std = (uhci_soft_td_t *)((char *)KERNADDR(&dma) +offs);
			std->physaddr = DMAADDR(&dma) + offs;
d1669 2
a1670 2
			sqh = (uhci_soft_qh_t *)((char *)KERNADDR(&dma) +offs);
			sqh->physaddr = DMAADDR(&dma) + offs;
d1712 1
a1712 1
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d "
d1714 1
a1714 1
		      upipe->pipe.device->lowspeed, flags));
d1737 1
a1737 1
	if (upipe->pipe.device->lowspeed)
d1744 1
a1744 1
			uhci_free_std_chain(sc, lastp, 0);
d1763 1
a1763 1
		p->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);
d1814 2
a1815 2
	DPRINTFN(3, ("uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\n",
		     xfer, xfer->length, xfer->flags));
d1865 1
a1865 1
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d1893 8
a1900 3
 * XXX This way of aborting is neither safe, nor good.
 * But it will have to do until I figure out what to do.
 * I apologize for the delay().
d1906 2
d1913 6
a1918 5
	s = splusb();

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED &&
	    xfer->status != USBD_IN_PROGRESS) {
a1919 1
		return;
d1922 2
a1923 2
	/* Make interrupt routine ignore it, */
	xfer->status = status;
d1925 5
a1929 1
	/* don't timeout, */
d1931 1
a1931 2

	/* make hardware ignore it, */
d1934 1
d1936 15
a1950 2
	xfer->hcpriv = ii;

d1953 4
a1956 1
	delay(1000);
d1958 1
d2127 1
a2127 1
		xfer->pipe->intrxfer = 0;
d2185 1
a2185 1
	ls = dev->lowspeed ? UHCI_TD_LS : 0;
d2208 1
a2208 1
	memcpy(KERNADDR(&upipe->u.ctl.reqdma), req, sizeof *req);
d2215 1
a2215 1
	setup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));
d2248 1
a2248 1
	if (dev->lowspeed)
d2281 1
a2281 1
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d2355 1
a2355 1
	buf = DMAADDR(&xfer->dmabuf);
d2592 3
d2634 1
a2634 1
	uhci_free_std_chain(sc, ii->stdstart, 0);
d2672 2
a2673 1
		uhci_del_intr_info(ii);
d2690 3
d2695 1
a2695 1
	if (upipe->pipe.device->lowspeed)
d2714 6
d2724 1
a2724 1
	uhci_free_std_chain(sc, ii->stdstart, 0);
d2914 1
a2914 1
	0,			/* protocol */
d2942 1
a2942 1
	0,
d2983 95
d3125 1
a3125 1
		buf = KERNADDR(&xfer->dmabuf);
d3387 2
a3388 12
			x = URWMASK(UREAD2(sc, port));
			UWRITE2(sc, port, x | UHCI_PORTSC_PR);
			usb_delay_ms(&sc->sc_bus, 50); /*XXX USB v1.1 7.1.7.3 */
			UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);
			delay(100);
			x = UREAD2(sc, port);
			UWRITE2(sc, port, x  | UHCI_PORTSC_PE);
			usb_delay_ms(&sc->sc_bus, 10); /* XXX */
			DPRINTFN(3,("uhci port %d reset, status = 0x%04x\n",
				    index, UREAD2(sc, port)));
			sc->sc_isreset = 1;
			break;
d3483 1
a3483 1
	sc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);
@


1.27
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.26 2002/07/09 18:19:58 nate Exp $	*/
d47 1
a47 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
@


1.26
log
@kill trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.25 2002/05/07 18:29:18 nate Exp $	*/
d1510 1
a1510 1
		panic("uhci_waitintr: lost intr_info\n");
d1793 1
a1793 1
		panic("uhci_device_bulk_transfer: a request\n");
d1949 1
a1949 1
		panic("uhci_device_ctrl_transfer: not a request\n");
d1998 1
a1998 1
		panic("uhci_device_intr_transfer: a request\n");
d2626 1
a2626 1
		panic("uhci_ctrl_done: not a request\n");
d2948 1
a2948 1
		panic("uhci_root_ctrl_transfer: not a request\n");
@


1.25
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.23 2002/01/10 00:46:36 nordin Exp $	*/
d177 1
a177 1
Static void		uhci_free_std_chain(uhci_softc_t *, 
d180 1
a180 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, 
d253 1
a253 1
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc, 
d304 1
a304 1
struct usbd_pipe_methods uhci_root_ctrl_methods = {	
d313 1
a313 1
struct usbd_pipe_methods uhci_root_intr_methods = {	
d369 1
a369 1
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
d410 1
a410 1
	err = usb_allocmem(&sc->sc_bus, 
d419 1
a419 1
	/* 
d473 1
a473 1
	/* 
d496 2
a497 2
		for (j = i; 
		     j < UHCI_FRAMELIST_COUNT; 
d519 1
a519 1
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | 
d555 1
a555 1
	
d571 1
a571 1
	}			
d585 1
a585 1
	/* 
d696 1
a696 1
	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n", 
d742 1
a742 1
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | 
d894 1
a894 1
	
d927 2
a928 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n", 
	       ii, DONE, ii->xfer, dev, 
d1013 1
a1013 1
		sc->sc_last_qh->qh.qh_hlink = 
d1226 1
a1226 1
		printf("%s: host controller process error\n", 
d1232 1
a1232 1
			printf("%s: host controller halted\n", 
d1304 1
a1304 1
	/* 
d1321 1
a1321 1
			      UHCI_TD_GET_ACTLEN(status) < 
d1425 1
a1425 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n", 
d1505 1
a1505 1
	     ii != NULL && ii->xfer != xfer; 
d1531 1
a1531 1
	for (n = 0; n < UHCI_RESET_TIMEOUT && 
d1535 1
a1535 1
		printf("%s: controller did not reset\n", 
d1684 1
a1684 1
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len, 
d1731 1
a1731 1
		p->td.td_token = 
d1738 1
a1738 1
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n", 
d1765 1
a1765 1
	/* 
d1880 1
a1880 1
	if (xfer->status != USBD_NOT_STARTED && 
d1931 1
a1931 1
	/* 
d1971 1
a1971 1
	/* 
d2027 1
a2027 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n", 
d2091 1
a2091 1
	/* 
d2162 1
a2162 1
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | 
d2164 1
a2164 1
	stat->td.td_token = 
d2214 1
a2214 1
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh || 
d2266 1
a2266 1
	uhci_soft_td_t *std;	
d2362 1
a2362 1
	
d2373 1
a2373 1
	
d2390 1
a2390 1
	if (xfer->status != USBD_NOT_STARTED && 
d2720 1
a2720 1
	upipe->u.intr.qhs = 
d2723 1
a2723 1
	/* 
d2767 1
a2767 1
		     pipe, pipe->device->address, 
d2802 2
a2803 2
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
d2925 1
a2925 1
	/* 
d2952 1
a2952 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n", 
d2967 1
a2967 1
		/* 
d3135 1
a3135 1
			*(u_int8_t *)buf = 
d3175 1
a3175 1
		if (x & UHCI_PORTSC_CSC) 
d3177 1
a3177 1
		if (x & UHCI_PORTSC_PE) 
d3179 1
a3179 1
		if (x & UHCI_PORTSC_POEDC) 
d3181 1
a3181 1
		if (x & UHCI_PORTSC_OCI) 
d3183 1
a3183 1
		if (x & UHCI_PORTSC_OCIC) 
d3185 1
a3185 1
		if (x & UHCI_PORTSC_SUSP) 
d3187 1
a3187 1
		if (x & UHCI_PORTSC_LSDA) 
@


1.24
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uhci.c,v 1.158 2002/03/17 18:02:53 augustss Exp $	*/
d177 1
a177 1
Static void		uhci_free_std_chain(uhci_softc_t *,
d180 1
a180 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *,
a189 1
Static void		uhci_timeout_task(void *);
d252 2
a253 2
Static void		uhci_remove_intr(uhci_softc_t *, uhci_soft_qh_t *);
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc,
d304 1
a304 1
struct usbd_pipe_methods uhci_root_ctrl_methods = {
d313 1
a313 1
struct usbd_pipe_methods uhci_root_intr_methods = {
d369 1
a369 1
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)
d404 1
d410 1
a410 1
	err = usb_allocmem(&sc->sc_bus,
d419 1
a419 1
	/*
d473 1
a473 1
	/*
d496 2
a497 2
		for (j = i;
		     j < UHCI_FRAMELIST_COUNT;
d519 1
a519 1
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d555 1
a555 1

d571 1
a571 1
	}
d585 1
a585 1
	/*
d588 1
a588 1
	 * need TDs for it.  Since we don't want to allocate those from
d597 1
a597 2
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP,
			      M_NOWAIT);
d696 1
a696 1
	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n",
d742 1
a742 1
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d795 1
a795 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
d797 1
a797 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_status),
d894 1
a894 1

d927 2
a928 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n",
	       ii, DONE, ii->xfer, dev,
d1013 1
a1013 1
		sc->sc_last_qh->qh.qh_hlink =
d1076 1
a1076 1
	pqh->hlink = sqh->hlink;
d1093 1
a1093 1
	sqh->hlink = eqh->hlink;
d1095 1
a1095 1
	eqh->hlink = sqh;
d1115 1
a1115 1
	pqh->hlink = sqh->hlink;
d1132 1
a1132 1
	sqh->hlink = eqh->hlink;
d1134 1
a1134 1
	eqh->hlink = sqh;
a1169 3
	if (sc->sc_dying)
		return (0);

d1193 1
a1193 1
	status = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
d1197 5
d1226 1
a1226 1
		printf("%s: host controller process error\n",
d1232 1
a1232 1
			printf("%s: host controller halted\n",
a1277 5
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}

a1294 6
	if (ii->xfer->status == USBD_CANCELLED ||
	    ii->xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_check_intr: aborted xfer=%p\n", ii->xfer));
		return;
	}

d1304 1
a1304 1
	/*
d1321 1
a1321 1
			      UHCI_TD_GET_ACTLEN(status) <
d1364 6
d1425 1
a1425 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n",
d1432 1
a1432 2
		bitmask_snprintf((u_int32_t)status,
				 "\20\22BITSTUFF\23CRCTO\24NAK\25"
a1463 3
	struct uhci_xfer *uxfer = UXFER(ii->xfer);
	struct uhci_pipe *upipe = (struct uhci_pipe *)uxfer->xfer.pipe;
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
d1465 1
a1465 1
	DPRINTF(("uhci_timeout: uxfer=%p\n", uxfer));
d1467 4
a1470 17
	if (sc->sc_dying) {
		uhci_abort_xfer(&uxfer->xfer, USBD_TIMEOUT);
		return;
	}

	/* Execute the abort in a process context. */
	usb_init_task(&uxfer->abort_task, uhci_timeout_task, ii->xfer);
	usb_add_task(uxfer->xfer.pipe->device, &uxfer->abort_task);
}

void
uhci_timeout_task(void *addr)
{
	usbd_xfer_handle xfer = addr;
	int s;

	DPRINTF(("uhci_timeout_task: xfer=%p\n", xfer));
d1472 3
a1474 3
	s = splusb();
	uhci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
d1505 1
a1505 1
	     ii != NULL && ii->xfer != xfer;
d1531 1
a1531 1
	for (n = 0; n < UHCI_RESET_TIMEOUT &&
d1535 1
a1535 1
		printf("%s: controller did not reset\n",
d1683 3
a1685 3
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%d speed=%d "
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len,
		      upipe->pipe.device->speed, flags));
d1708 1
a1708 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d1715 1
a1715 1
			uhci_free_std_chain(sc, lastp, NULL);
d1731 1
a1731 1
		p->td.td_token =
d1738 1
a1738 1
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n",
d1765 1
a1765 1
	/*
d1864 3
a1866 8
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
a1871 2
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
d1877 5
a1881 6
	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		usb_uncallout(xfer->timeout_handle, uhci_timeout, xfer);
		usb_transfer_complete(xfer);
d1883 1
d1886 2
a1887 2
	if (xfer->device->bus->intr_context || !curproc)
		panic("uhci_abort_xfer: not in process context\n");
d1889 1
a1889 5
	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
d1891 2
a1892 1
	DPRINTFN(1,("uhci_abort_xfer: stop ii=%p\n", ii));
d1895 3
d1900 1
a1900 17
	/* 
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(upipe->pipe.device->bus, 2); /* Hardware finishes in 1ms */
	s = splusb();
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	DPRINTFN(1,("uhci_abort_xfer: tsleep\n"));
	tsleep(&sc->sc_softwake, PZERO, "uhciab", 0);
	splx(s);
		
	/*
	 * Step 3: Execute callback.
	 */
	xfer->hcpriv = ii;
a1901 1
	DPRINTFN(1,("uhci_abort_xfer: callback\n"));
d1931 1
a1931 1
	/*
d1971 1
a1971 1
	/*
d2027 1
a2027 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n",
d2070 1
a2070 1
		xfer->pipe->intrxfer = NULL;
d2091 1
a2091 1
	/*
d2128 1
a2128 1
	ls = dev->speed == USB_SPEED_LOW ? UHCI_TD_LS : 0;
d2162 1
a2162 1
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
d2164 1
a2164 1
	stat->td.td_token =
d2191 1
a2191 1
	if (dev->speed == USB_SPEED_LOW)
d2214 1
a2214 1
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh ||
d2266 1
a2266 1
	uhci_soft_td_t *std;
d2362 1
a2362 1

d2373 1
a2373 1

d2390 1
a2390 1
	if (xfer->status != USBD_NOT_STARTED &&
d2574 1
a2574 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d2631 1
a2631 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d2654 1
a2654 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d2720 1
a2720 1
	upipe->u.intr.qhs =
d2723 1
a2723 1
	/*
d2767 1
a2767 1
		     pipe, pipe->device->address,
d2802 2
a2803 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d2844 1
a2844 1
	UDPROTO_FSHUB,		/* protocol */
d2872 1
a2872 1
	UIPROTO_FSHUB,
d2925 1
a2925 1
	/*
d2952 1
a2952 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n",
d2967 1
a2967 1
		/*
d3135 1
a3135 1
			*(u_int8_t *)buf =
d3175 1
a3175 1
		if (x & UHCI_PORTSC_CSC)
d3177 1
a3177 1
		if (x & UHCI_PORTSC_PE)
d3179 1
a3179 1
		if (x & UHCI_PORTSC_POEDC)
d3181 1
a3181 1
		if (x & UHCI_PORTSC_OCI)
d3183 1
a3183 1
		if (x & UHCI_PORTSC_OCIC)
d3185 1
a3185 1
		if (x & UHCI_PORTSC_SUSP)
d3187 1
a3187 1
		if (x & UHCI_PORTSC_LSDA)
d3224 1
a3224 1
			usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);
@


1.23
log
@Check result from malloc(9) when using M_NOWAIT. nate@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.22 2001/10/31 04:24:44 nate Exp $	*/
/*	$NetBSD: uhci.c,v 1.142 2001/10/25 02:08:13 augustss Exp $	*/
d177 1
a177 1
Static void		uhci_free_std_chain(uhci_softc_t *, 
d180 1
a180 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, 
d190 1
d253 2
a254 2
Static void		uhci_remove_intr(uhci_softc_t*, uhci_soft_qh_t*);
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc, 
d305 1
a305 1
struct usbd_pipe_methods uhci_root_ctrl_methods = {	
d314 1
a314 1
struct usbd_pipe_methods uhci_root_intr_methods = {	
d370 1
a370 1
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
a404 1
	uhci_run(sc, 0);			/* stop the controller */
d410 1
a410 1
	err = usb_allocmem(&sc->sc_bus, 
d419 1
a419 1
	/* 
d473 1
a473 1
	/* 
d496 2
a497 2
		for (j = i; 
		     j < UHCI_FRAMELIST_COUNT; 
d519 1
a519 1
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | 
d555 1
a555 1
	
d571 1
a571 1
	}			
d585 1
a585 1
	/* 
d588 1
a588 1
	 * need TDs for it.  Since we don't want to alolocate those from
d597 2
a598 1
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP, M_NOWAIT);
d697 1
a697 1
	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n", 
d743 1
a743 1
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE | 
d796 1
a796 1
	bitmask_snprintf((int)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
d798 1
a798 1
	bitmask_snprintf((int)le32toh(p->td.td_status),
d895 1
a895 1
	
d928 2
a929 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n", 
	       ii, DONE, ii->xfer, dev, 
d1014 1
a1014 1
		sc->sc_last_qh->qh.qh_hlink = 
d1077 1
a1077 1
	pqh->hlink       = sqh->hlink;
d1094 1
a1094 1
	sqh->hlink       = eqh->hlink;
d1096 1
a1096 1
	eqh->hlink       = sqh;
d1116 1
a1116 1
	pqh->hlink       = sqh->hlink;
d1133 1
a1133 1
	sqh->hlink       = eqh->hlink;
d1135 1
a1135 1
	eqh->hlink       = sqh;
d1171 3
d1197 1
a1197 1
	status = UREAD2(sc, UHCI_STS);
a1200 5
#if defined(DIAGNOSTIC) && defined(__NetBSD__)
	if (sc->sc_suspend != PWR_RESUME)
		printf("uhci_intr: suspended sts=0x%x\n", status);
#endif

d1225 1
a1225 1
		printf("%s: host controller process error\n", 
d1231 1
a1231 1
			printf("%s: host controller halted\n", 
d1277 5
d1299 6
d1314 1
a1314 1
	/* 
d1331 1
a1331 1
			      UHCI_TD_GET_ACTLEN(status) < 
a1373 6
	if (xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_idone: aborted xfer=%p\n", xfer));
		return;
	}

d1429 1
a1429 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n", 
d1436 2
a1437 1
		bitmask_snprintf((int)status, "\20\22BITSTUFF\23CRCTO\24NAK\25"
d1469 3
d1473 1
a1473 1
	DPRINTF(("uhci_timeout: ii=%p\n", ii));
d1475 17
a1491 4
#ifdef UHCI_DEBUG
	if (uhcidebug > 10)
		uhci_dump_tds(ii->stdstart);
#endif
d1493 3
a1495 3
	ii->xfer->device->bus->intr_context++;
	uhci_abort_xfer(ii->xfer, USBD_TIMEOUT);
	ii->xfer->device->bus->intr_context--;
d1526 1
a1526 1
	     ii != NULL && ii->xfer != xfer; 
d1552 1
a1552 1
	for (n = 0; n < UHCI_RESET_TIMEOUT && 
d1556 1
a1556 1
		printf("%s: controller did not reset\n", 
d1704 3
a1706 3
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%d ls=%d "
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len, 
		      upipe->pipe.device->lowspeed, flags));
d1729 1
a1729 1
	if (upipe->pipe.device->lowspeed)
d1736 1
a1736 1
			uhci_free_std_chain(sc, lastp, 0);
d1752 1
a1752 1
		p->td.td_token = 
d1759 1
a1759 1
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n", 
d1786 1
a1786 1
	/* 
d1885 8
a1892 3
 * XXX This way of aborting is neither safe, nor good.
 * But it will have to do until I figure out what to do.
 * I apologize for the delay().
d1898 2
d1905 6
a1910 5
	s = splusb();

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED && 
	    xfer->status != USBD_IN_PROGRESS) {
a1911 1
		return;
d1914 2
a1915 2
	/* Make interrupt routine ignore it, */
	xfer->status = status;
d1917 5
a1921 1
	/* don't timeout, */
d1923 1
a1923 2

	/* make hardware ignore it, */
d1926 1
d1928 16
d1946 1
a1946 4
	splx(s);

	delay(1000);

d1976 1
a1976 1
	/* 
d2016 1
a2016 1
	/* 
d2072 1
a2072 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n", 
d2115 1
a2115 1
		xfer->pipe->intrxfer = 0;
d2136 1
a2136 1
	/* 
d2173 1
a2173 1
	ls = dev->lowspeed ? UHCI_TD_LS : 0;
d2207 1
a2207 1
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | 
d2209 1
a2209 1
	stat->td.td_token = 
d2236 1
a2236 1
	if (dev->lowspeed)
d2259 1
a2259 1
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh || 
d2311 1
a2311 1
	uhci_soft_td_t *std;	
d2407 1
a2407 1
	
d2418 1
a2418 1
	
d2435 1
a2435 1
	if (xfer->status != USBD_NOT_STARTED && 
d2619 1
a2619 1
	uhci_free_std_chain(sc, ii->stdstart, 0);
d2676 1
a2676 1
	if (upipe->pipe.device->lowspeed)
d2699 1
a2699 1
	uhci_free_std_chain(sc, ii->stdstart, 0);
d2765 1
a2765 1
	upipe->u.intr.qhs = 
d2768 1
a2768 1
	/* 
d2812 1
a2812 1
		     pipe, pipe->device->address, 
d2847 2
a2848 2
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
d2889 1
a2889 1
	0,			/* protocol */
d2917 1
a2917 1
	0,
d2970 1
a2970 1
	/* 
d2997 1
a2997 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n", 
d3012 1
a3012 1
		/* 
d3180 1
a3180 1
			*(u_int8_t *)buf = 
d3220 1
a3220 1
		if (x & UHCI_PORTSC_CSC) 
d3222 1
a3222 1
		if (x & UHCI_PORTSC_PE) 
d3224 1
a3224 1
		if (x & UHCI_PORTSC_POEDC) 
d3226 1
a3226 1
		if (x & UHCI_PORTSC_OCI) 
d3228 1
a3228 1
		if (x & UHCI_PORTSC_OCIC) 
d3230 1
a3230 1
		if (x & UHCI_PORTSC_SUSP) 
d3232 1
a3232 1
		if (x & UHCI_PORTSC_LSDA) 
d3269 1
a3269 1
			usb_delay_ms(&sc->sc_bus, 50); /*XXX USB v1.1 7.1.7.3 */
@


1.22
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.21 2001/06/12 19:11:58 mickey Exp $	*/
d598 2
@


1.22.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.23 2002/01/10 00:46:36 nordin Exp $	*/
a597 2
		if (stds == NULL)
			panic("uhci_allocm");
@


1.22.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.22.2.1 2002/01/31 22:55:39 niklas Exp $	*/
@


1.22.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.22.2.2 2002/06/11 03:42:30 art Exp $	*/
d177 1
a177 1
Static void		uhci_free_std_chain(uhci_softc_t *,
d180 1
a180 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *,
d253 1
a253 1
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc,
d304 1
a304 1
struct usbd_pipe_methods uhci_root_ctrl_methods = {
d313 1
a313 1
struct usbd_pipe_methods uhci_root_intr_methods = {
d369 1
a369 1
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)
d410 1
a410 1
	err = usb_allocmem(&sc->sc_bus,
d419 1
a419 1
	/*
d473 1
a473 1
	/*
d496 2
a497 2
		for (j = i;
		     j < UHCI_FRAMELIST_COUNT;
d519 1
a519 1
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d555 1
a555 1

d571 1
a571 1
	}
d585 1
a585 1
	/*
d696 1
a696 1
	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n",
d742 1
a742 1
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d894 1
a894 1

d927 2
a928 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n",
	       ii, DONE, ii->xfer, dev,
d1013 1
a1013 1
		sc->sc_last_qh->qh.qh_hlink =
d1226 1
a1226 1
		printf("%s: host controller process error\n",
d1232 1
a1232 1
			printf("%s: host controller halted\n",
d1304 1
a1304 1
	/*
d1321 1
a1321 1
			      UHCI_TD_GET_ACTLEN(status) <
d1425 1
a1425 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n",
d1505 1
a1505 1
	     ii != NULL && ii->xfer != xfer;
d1510 1
a1510 1
		panic("uhci_waitintr: lost intr_info");
d1531 1
a1531 1
	for (n = 0; n < UHCI_RESET_TIMEOUT &&
d1535 1
a1535 1
		printf("%s: controller did not reset\n",
d1684 1
a1684 1
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len,
d1731 1
a1731 1
		p->td.td_token =
d1738 1
a1738 1
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n",
d1765 1
a1765 1
	/*
d1793 1
a1793 1
		panic("uhci_device_bulk_transfer: a request");
d1880 1
a1880 1
	if (xfer->status != USBD_NOT_STARTED &&
d1931 1
a1931 1
	/*
d1949 1
a1949 1
		panic("uhci_device_ctrl_transfer: not a request");
d1971 1
a1971 1
	/*
d1998 1
a1998 1
		panic("uhci_device_intr_transfer: a request");
d2027 1
a2027 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n",
d2091 1
a2091 1
	/*
d2162 1
a2162 1
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
d2164 1
a2164 1
	stat->td.td_token =
d2214 1
a2214 1
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh ||
d2266 1
a2266 1
	uhci_soft_td_t *std;
d2362 1
a2362 1

d2373 1
a2373 1

d2390 1
a2390 1
	if (xfer->status != USBD_NOT_STARTED &&
d2626 1
a2626 1
		panic("uhci_ctrl_done: not a request");
d2720 1
a2720 1
	upipe->u.intr.qhs =
d2723 1
a2723 1
	/*
d2767 1
a2767 1
		     pipe, pipe->device->address,
d2802 2
a2803 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d2925 1
a2925 1
	/*
d2948 1
a2948 1
		panic("uhci_root_ctrl_transfer: not a request");
d2952 1
a2952 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n",
d2967 1
a2967 1
		/*
d3135 1
a3135 1
			*(u_int8_t *)buf =
d3175 1
a3175 1
		if (x & UHCI_PORTSC_CSC)
d3177 1
a3177 1
		if (x & UHCI_PORTSC_PE)
d3179 1
a3179 1
		if (x & UHCI_PORTSC_POEDC)
d3181 1
a3181 1
		if (x & UHCI_PORTSC_OCI)
d3183 1
a3183 1
		if (x & UHCI_PORTSC_OCIC)
d3185 1
a3185 1
		if (x & UHCI_PORTSC_SUSP)
d3187 1
a3187 1
		if (x & UHCI_PORTSC_LSDA)
@


1.21
log
@interrupts cannot happen before
*hci cannot receive interrupts before it has been initialized.
this was changed to accomodate the pcibios strategy change back
in pre-2.9 times since *hci_init enables interrupts at it's end
and thus unmapped pci interrupt hangs the machine in the
endless loop trying to deliver it (and no hci handler to ack it).
this new way we disable interrupts by hands before we map 'em
on pci and thus ensure that they will not crash an uninitialized
*hci which, in turn, will run right after the interrupt map/establish
and by the time it enables *hci interrupts all gonna be just fine.
please allow us to end this stretched remark for cvs
is getting a power outage in less than 20 minutes.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.20 2001/05/03 02:20:33 aaron Exp $	*/
/*	$NetBSD: uhci.c,v 1.135 2001/04/01 14:59:52 augustss Exp $	*/
d162 2
a163 1
Static void		uhci_busreset(uhci_softc_t *);
d166 1
d247 1
a247 1
Static void		uhci_softintr(struct usbd_bus *);
d288 1
a288 1
#define UHCI_RESET_TIMEOUT 100	/* reset timeout */
d380 1
a380 1
uhci_busreset(uhci_softc_t *sc)
d406 2
a407 2

	uhci_busreset(sc);
a819 1
#if 1
a824 1
#endif
d913 10
d1161 2
d1167 14
d1186 1
a1186 1
		DPRINTF(("%s: uhci_intr\n", USBDEVNAME(sc->sc_bus.bdev)));
d1195 5
a1206 5
#if defined(DIAGNOSTIC) && defined(__NetBSD__)
	if (sc->sc_suspend != PWR_RESUME)
		printf("uhci_intr: suspended sts=0x%x\n", status);
#endif

d1229 1
a1229 1
		if (!sc->sc_dying)
a1231 1
		sc->sc_dying = 1;
d1233 1
a1233 1
		uhci_dump_all(sc);
d1235 2
a1236 1

d1252 1
a1252 1
uhci_softintr(struct usbd_bus *bus)
d1254 1
a1254 1
	uhci_softc_t *sc = (uhci_softc_t *)bus;
d1257 2
a1258 1
	DPRINTFN(10,("%s: uhci_softintr\n", USBDEVNAME(sc->sc_bus.bdev)));
d1343 1
d1396 1
a1396 2
		usb_transfer_complete(xfer);
		return;
d1423 1
a1423 1
	DPRINTFN(10, ("uhci_check_intr: actlen=%d, status=0x%x\n", 
d1449 2
d1452 1
d1494 1
a1494 1
			uhci_intr(sc);
d1519 1
a1519 1
		uhci_intr(sc);
a1521 1
#if 0
a1535 1
#endif
d3086 1
a3086 1
			x = UREAD2(sc, port);
d3090 1
a3090 1
			x = UREAD2(sc, port);
d3094 1
a3094 1
			x = UREAD2(sc, port);
d3098 1
a3098 1
			x = UREAD2(sc, port);
d3102 1
a3102 1
			x = UREAD2(sc, port);
d3106 1
a3106 1
			x = UREAD2(sc, port);
d3171 1
a3171 1
		if (x & UHCI_PORTSC_CCS  )
d3173 1
a3173 1
		if (x & UHCI_PORTSC_CSC  ) 
d3175 1
a3175 1
		if (x & UHCI_PORTSC_PE   ) 
d3179 1
a3179 1
		if (x & UHCI_PORTSC_OCI  ) 
d3181 1
a3181 1
		if (x & UHCI_PORTSC_OCIC ) 
d3183 1
a3183 1
		if (x & UHCI_PORTSC_SUSP ) 
d3185 1
a3185 1
		if (x & UHCI_PORTSC_LSDA ) 
d3212 1
a3212 1
			x = UREAD2(sc, port);
d3216 1
a3216 1
			x = UREAD2(sc, port);
d3220 1
a3220 1
			x = UREAD2(sc, port);
@


1.20
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.19 2001/03/25 04:26:58 csapuntz Exp $	*/
a164 1
Static usbd_status	uhci_run(uhci_softc_t *, int run);
@


1.19
log
@Avoid dereferencing a null pointer
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.18 2001/01/28 09:43:41 aaron Exp $	*/
/*	$NetBSD: uhci.c,v 1.125 2000/09/23 21:00:10 augustss Exp $	*/
d690 1
a690 1
	s = splusb();
d713 2
d1173 1
d1214 3
a1216 4
	if (ack)	/* acknowledge the ints */
		UWRITE2(sc, UHCI_STS, ack);
	else	/* nothing to acknowledge */
		return (0);
d1517 1
a1517 1
	s = splusb();
@


1.18
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.17 2000/12/11 04:23:20 ho Exp $	*/
d638 1
a640 3
#ifdef DIAGNOSTIC
	xfer->busy_free = XFER_BUSY;
#endif
@


1.17
log
@Avoid repeated 'host controlled halted' messages. (jakob@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.16 2000/11/11 16:23:30 drahn Exp $	*/
d46 2
a47 2
 * UHCI spec: http://www.intel.com/design/usb/uhci11d.pdf
 * USB spec: http://www.usb.org/developers/data/usb11.pdf
d113 14
d698 3
a700 1
	if (why != PWR_RESUME) {
d720 2
a721 1
	} else {
d751 7
d1166 4
a1175 4
	status = UREAD2(sc, UHCI_STS);
	if (status == 0)	/* The interrupt was not for us. */
		return (0);

d1205 1
a1205 1
			       USBDEVNAME(sc->sc_bus.bdev));
d1344 1
a1344 1
		int i, n, nframes;
d1362 3
a1364 1
			actlen += UHCI_TD_GET_ACTLEN(status);
d2377 1
a2377 1
		len = UHCI_TD_GET_MAXLEN(std->td.td_token);
@


1.16
log
@Change the le32toh() le16toh() macros back to the previous defintion.
This change is more portable, redefine the macros to use the host
letoh32/letoh16 instead of using possibly less efficient bswap routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.15 2000/11/08 18:10:38 aaron Exp $	*/
d1179 3
a1181 2
		printf("%s: host controller halted\n", 
		       USBDEVNAME(sc->sc_bus.bdev));
@


1.15
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.14 2000/09/06 22:42:10 rahnds Exp $	*/
a110 14
#endif

/*
 * The UHCI controller is little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
@


1.14
log
@Match Free/Net macros for le32toh/letoh32, define in terms of the other.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.13 2000/07/04 11:44:23 fgsch Exp $	*/
/*	$NetBSD: uhci.c,v 1.110 2000/04/14 14:11:36 augustss Exp $	*/
d82 3
d104 4
d113 14
d162 8
a169 8
Static void		uhci_busreset __P((uhci_softc_t *));
Static void		uhci_shutdown __P((void *v));
Static void		uhci_power __P((int, void *));
Static usbd_status	uhci_run __P((uhci_softc_t *, int run));
Static uhci_soft_td_t *uhci_alloc_std __P((uhci_softc_t *));
Static void		uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));
Static uhci_soft_qh_t *uhci_alloc_sqh __P((uhci_softc_t *));
Static void		uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));
d171 3
a173 3
Static void		uhci_enter_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *,
				      uhci_intr_info_t *));
Static void		uhci_exit_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *));
d176 3
a178 3
Static void		uhci_free_std_chain __P((uhci_softc_t *, 
					 uhci_soft_td_t *, uhci_soft_td_t *));
Static usbd_status	uhci_alloc_std_chain __P((struct uhci_pipe *,
d180 103
a282 98
			    uhci_soft_td_t **, uhci_soft_td_t **));
Static void		uhci_poll_hub __P((void *));
Static void		uhci_waitintr __P((uhci_softc_t *,
			    usbd_xfer_handle));
Static void		uhci_check_intr __P((uhci_softc_t *,
			    uhci_intr_info_t *));
Static void		uhci_idone __P((uhci_intr_info_t *));

Static void		uhci_abort_xfer __P((usbd_xfer_handle,
			    usbd_status status));

Static void		uhci_timeout __P((void *));
Static void		uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));
Static void		uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));
Static void		uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));
Static void		uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));
Static int		uhci_str __P((usb_string_descriptor_t *, int, char *));

Static usbd_status	uhci_setup_isoc __P((usbd_pipe_handle pipe));
Static void		uhci_device_isoc_enter __P((usbd_xfer_handle));

Static usbd_status	uhci_allocm __P((struct usbd_bus *, usb_dma_t *,
			    u_int32_t));
Static void		uhci_freem __P((struct usbd_bus *, usb_dma_t *));

Static usbd_xfer_handle	uhci_allocx __P((struct usbd_bus *));
Static void		uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));

Static usbd_status	uhci_device_ctrl_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_device_ctrl_start __P((usbd_xfer_handle));
Static void		uhci_device_ctrl_abort __P((usbd_xfer_handle));
Static void		uhci_device_ctrl_close __P((usbd_pipe_handle));
Static void		uhci_device_ctrl_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_device_intr_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_device_intr_start __P((usbd_xfer_handle));
Static void		uhci_device_intr_abort __P((usbd_xfer_handle));
Static void		uhci_device_intr_close __P((usbd_pipe_handle));
Static void		uhci_device_intr_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_device_bulk_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_device_bulk_start __P((usbd_xfer_handle));
Static void		uhci_device_bulk_abort __P((usbd_xfer_handle));
Static void		uhci_device_bulk_close __P((usbd_pipe_handle));
Static void		uhci_device_bulk_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_device_isoc_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_device_isoc_start __P((usbd_xfer_handle));
Static void		uhci_device_isoc_abort __P((usbd_xfer_handle));
Static void		uhci_device_isoc_close __P((usbd_pipe_handle));
Static void		uhci_device_isoc_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_root_ctrl_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_root_ctrl_start __P((usbd_xfer_handle));
Static void		uhci_root_ctrl_abort __P((usbd_xfer_handle));
Static void		uhci_root_ctrl_close __P((usbd_pipe_handle));
Static void		uhci_root_ctrl_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_root_intr_transfer __P((usbd_xfer_handle));
Static usbd_status	uhci_root_intr_start __P((usbd_xfer_handle));
Static void		uhci_root_intr_abort __P((usbd_xfer_handle));
Static void		uhci_root_intr_close __P((usbd_pipe_handle));
Static void		uhci_root_intr_done  __P((usbd_xfer_handle));

Static usbd_status	uhci_open __P((usbd_pipe_handle));
Static void		uhci_poll __P((struct usbd_bus *));
Static void		uhci_softintr __P((struct usbd_bus *));

Static usbd_status	uhci_device_request __P((usbd_xfer_handle xfer));

Static void		uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));
Static void		uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));
Static usbd_status	uhci_device_setintr __P((uhci_softc_t *sc, 
			    struct uhci_pipe *pipe, int ival));

Static void		uhci_device_clear_toggle __P((usbd_pipe_handle pipe));
Static void		uhci_noop __P((usbd_pipe_handle pipe));

Static __inline__ uhci_soft_qh_t *uhci_find_prev_qh
    __P((uhci_soft_qh_t *, uhci_soft_qh_t *));

#ifdef UHCI_DEBUG
Static void		uhci_dump_all __P((uhci_softc_t *));
Static void		uhci_dumpregs __P((uhci_softc_t *));
Static void		uhci_dump_qhs __P((uhci_soft_qh_t *));
Static void		uhci_dump_qh __P((uhci_soft_qh_t *));
Static void		uhci_dump_tds __P((uhci_soft_td_t *));
Static void		uhci_dump_td __P((uhci_soft_td_t *));
Static void		uhci_dump_ii __P((uhci_intr_info_t *ii));
Static void		uhci_dump __P((void));
#endif

#define UWRITE1(sc, r, x) bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x))
#define UWRITE2(sc, r, x) bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
#define UWRITE4(sc, r, x) bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x))
#define UREAD1(sc, r) bus_space_read_1((sc)->iot, (sc)->ioh, (r))
#define UREAD2(sc, r) bus_space_read_2((sc)->iot, (sc)->ioh, (r))
#define UREAD4(sc, r) bus_space_read_4((sc)->iot, (sc)->ioh, (r))
d363 1
a363 2
uhci_find_prev_qh(pqh, sqh)
	uhci_soft_qh_t *pqh, *sqh;
d379 1
a379 2
uhci_busreset(sc)
	uhci_softc_t *sc;
d387 1
a387 2
uhci_init(sc)
	uhci_softc_t *sc;
d391 1
a391 1
	uhci_soft_qh_t *csqh, *bsqh, *sqh;
d418 24
d446 3
a448 1
	bsqh->qh.qh_hlink = htole32(UHCI_PTR_T);	/* end of QH chain */
d452 3
a454 3
	/* Allocate the dummy QH where control traffic will be queued. */
	csqh = uhci_alloc_sqh(sc);
	if (csqh == NULL)
d456 15
a470 4
	csqh->hlink = bsqh;
	csqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_Q);
	csqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_ctl_start = sc->sc_ctl_end = csqh;
d483 1
a483 1
		std->td.td_link = htole32(sqh->physaddr | UHCI_PTR_Q);
d487 3
a489 3
		sqh->hlink = csqh;
		sqh->qh.qh_hlink = htole32(csqh->physaddr | UHCI_PTR_Q);
		sqh->elink = 0;
d528 1
a528 3
uhci_activate(self, act)
	device_ptr_t self;
	enum devact act;
d547 1
a547 3
uhci_detach(sc, flags)
	struct uhci_softc *sc;
	int flags;
d579 1
a579 4
uhci_allocm(bus, dma, size)
	struct usbd_bus *bus;
	usb_dma_t *dma;
	u_int32_t size;
d610 1
a610 3
uhci_freem(bus, dma)
	struct usbd_bus *bus;
	usb_dma_t *dma;
d616 1
a616 2
uhci_allocx(bus)
	struct usbd_bus *bus;
d647 1
a647 3
uhci_freex(bus, xfer)
	struct usbd_bus *bus;
	usbd_xfer_handle xfer;
d670 1
a670 2
uhci_shutdown(v)
	void *v;
d686 1
a686 3
uhci_power(why, v)
	int why;
	void *v;
d754 1
a754 2
uhci_dumpregs(sc)
	uhci_softc_t *sc;
d770 1
a770 2
uhci_dump_td(p)
	uhci_soft_td_t *p;
d772 2
d781 10
a790 7
	DPRINTFN(-1,("  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
		     "D=%d,maxlen=%d\n",
		     (int)le32toh(p->td.td_link),
		     "\20\1T\2Q\3VF",
		     (int)le32toh(p->td.td_status),
		     "\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
		     "STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD",
d801 1
a801 2
uhci_dump_qh(sqh)
	uhci_soft_qh_t *sqh;
d811 1
a811 1
uhci_dump()
d818 1
a818 2
uhci_dump_all(sc)
	uhci_softc_t *sc;
d823 1
a823 1
	uhci_dump_qh(sc->sc_ctl_start);
d828 1
a828 2
uhci_dump_qhs(sqh)
	uhci_soft_qh_t *sqh;
d859 1
a859 2
uhci_dump_tds(std)
	uhci_soft_td_t *std;
d878 1
a878 2
uhci_dump_ii(ii)
	uhci_intr_info_t *ii;
d915 1
a915 1
void uhci_dump_iis(struct uhci_softc *);
d917 1
a917 2
uhci_dump_iis(sc)
	struct uhci_softc *sc;
d927 1
a927 1
void iidump() { uhci_dump_iis(thesc); }
d936 1
a936 2
uhci_poll_hub(addr)
	void *addr;
d968 1
a968 2
uhci_root_intr_done(xfer)
	usbd_xfer_handle xfer;
d973 1
a973 2
uhci_root_ctrl_done(xfer)
	usbd_xfer_handle xfer;
d977 20
a996 1
/* Add control QH, called at splusb(). */
d998 14
a1011 3
uhci_add_ctrl(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d1018 54
a1071 1
	eqh = sc->sc_ctl_end;
d1075 2
a1076 2
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
	sc->sc_ctl_end = sqh;
d1079 1
a1079 1
/* Remove control QH, called at splusb(). */
d1081 1
a1081 3
uhci_remove_ctrl(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d1087 7
a1093 2
	DPRINTFN(10, ("uhci_remove_ctrl: sqh=%p\n", sqh));
	pqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);
d1096 3
a1098 2
	if (sc->sc_ctl_end == sqh)
		sc->sc_ctl_end = pqh;
d1103 1
a1103 3
uhci_add_bulk(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d1114 1
a1114 1
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
d1116 1
d1121 1
a1121 3
uhci_remove_bulk(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d1128 6
d1137 1
d1143 1
a1143 2
uhci_intr(arg)
	void *arg;
d1178 1
d1180 1
d1216 1
a1216 2
uhci_softintr(bus)
	struct usbd_bus *bus;
d1244 1
a1244 3
uhci_check_intr(sc, ii)
	uhci_softc_t *sc;
	uhci_intr_info_t *ii;
d1298 1
a1298 2
uhci_idone(ii)
	uhci_intr_info_t *ii;
d1388 7
d1397 1
a1397 1
			  "status 0x%b\n",
d1400 3
a1402 3
			  (int)status, 
			  "\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
			  "STALLED\30ACTIVE"));
d1417 1
a1417 2
uhci_timeout(addr)
	void *addr;
d1440 1
a1440 3
uhci_waitintr(sc, xfer)
	uhci_softc_t *sc;
	usbd_xfer_handle xfer;
d1472 1
a1472 2
uhci_poll(bus)
	struct usbd_bus *bus;
d1482 1
a1482 2
uhci_reset(sc)
	uhci_softc_t *sc;
d1498 1
a1498 3
uhci_run(sc, run)
	uhci_softc_t *sc;
	int run;
d1540 1
a1540 2
uhci_alloc_std(sc)
	uhci_softc_t *sc;
d1568 1
a1568 3
uhci_free_std(sc, std)
	uhci_softc_t *sc;
	uhci_soft_td_t *std;
d1583 1
a1583 2
uhci_alloc_sqh(sc)
	uhci_softc_t *sc;
d1611 1
a1611 3
uhci_free_sqh(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d1618 2
a1619 4
uhci_free_std_chain(sc, std, stdend)
	uhci_softc_t *sc;
	uhci_soft_td_t *std;
	uhci_soft_td_t *stdend;
d1630 3
a1632 7
uhci_alloc_std_chain(upipe, sc, len, rd, flags, dma, sp, ep)
	struct uhci_pipe *upipe;
	uhci_softc_t *sc;
	int len, rd;
	u_int16_t flags;
	usb_dma_t *dma;
	uhci_soft_td_t **sp, **ep;
d1662 1
a1662 1
	lastp = 0;
d1677 1
a1677 4
		if (lastlink == UHCI_PTR_T)
			p->td.td_link = htole32(lastlink);
		else
			p->td.td_link = htole32(lastlink|UHCI_PTR_VF);
d1702 1
a1702 2
uhci_device_clear_toggle(pipe)
	usbd_pipe_handle pipe;
d1709 1
a1709 2
uhci_noop(pipe)
	usbd_pipe_handle pipe;
d1714 1
a1714 2
uhci_device_bulk_transfer(xfer)
	usbd_xfer_handle xfer;
d1731 1
a1731 2
uhci_device_bulk_start(xfer)
	usbd_xfer_handle xfer;
d1787 1
a1787 1
	sqh->qh.qh_elink = htole32(data->physaddr);
d1815 1
a1815 2
uhci_device_bulk_abort(xfer)
	usbd_xfer_handle xfer;
d1827 1
a1827 3
uhci_abort_xfer(xfer, status)
	usbd_xfer_handle xfer;
	usbd_status status;
d1870 1
a1870 2
uhci_device_bulk_close(pipe)
	usbd_pipe_handle pipe;
d1880 1
a1880 2
uhci_device_ctrl_transfer(xfer)
	usbd_xfer_handle xfer;
d1897 1
a1897 2
uhci_device_ctrl_start(xfer)
	usbd_xfer_handle xfer;
d1920 1
a1920 2
uhci_device_intr_transfer(xfer)
	usbd_xfer_handle xfer;
d1937 1
a1937 2
uhci_device_intr_start(xfer)
	usbd_xfer_handle xfer;
d1990 1
a1990 1
		sqh->qh.qh_elink = htole32(data->physaddr);
d2009 1
a2009 2
uhci_device_ctrl_abort(xfer)
	usbd_xfer_handle xfer;
d2017 1
a2017 2
uhci_device_ctrl_close(pipe)
	usbd_pipe_handle pipe;
d2023 1
a2023 2
uhci_device_intr_abort(xfer)
	usbd_xfer_handle xfer;
d2035 1
a2035 2
uhci_device_intr_close(pipe)
	usbd_pipe_handle pipe;
d2063 1
a2063 2
uhci_device_request(xfer)
	usbd_xfer_handle xfer;
d2103 1
a2103 1
		dataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF);
d2112 1
a2112 1
	setup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF);
d2146 1
a2146 1
	sqh->qh.qh_elink = htole32(setup->physaddr);
d2149 4
a2152 1
	uhci_add_ctrl(sc, sqh);
d2163 1
a2163 1
		     (link & UHCI_PTR_Q) == 0;
d2172 2
a2173 2
		     xqh = (maxqh++ == 5 || xqh->hlink==sxqh || 
                            xqh->hlink==xqh ? NULL : xqh->hlink)) {
d2192 1
a2192 2
uhci_device_isoc_transfer(xfer)
	usbd_xfer_handle xfer;
d2218 1
a2218 2
uhci_device_isoc_enter(xfer)
	usbd_xfer_handle xfer;
d2288 1
a2288 2
uhci_device_isoc_start(xfer)
	usbd_xfer_handle xfer;
d2338 1
a2338 2
uhci_device_isoc_abort(xfer)
	usbd_xfer_handle xfer;
d2384 1
a2384 2
uhci_device_isoc_close(pipe)
	usbd_pipe_handle pipe;
d2428 1
a2428 2
uhci_setup_isoc(pipe)
	usbd_pipe_handle pipe;
d2466 1
a2466 1
		vstd->td.td_link = htole32(std->physaddr);
d2483 1
a2483 2
uhci_device_isoc_done(xfer)
	usbd_xfer_handle xfer;
d2516 1
a2516 2
uhci_device_intr_done(xfer)
	usbd_xfer_handle xfer;
d2529 1
a2529 1
		sqh->elink = 0;
d2564 1
a2564 1
			sqh->qh.qh_elink = htole32(data->physaddr);
d2576 1
a2576 2
uhci_device_ctrl_done(xfer)
	usbd_xfer_handle xfer;
d2589 4
a2592 1
	uhci_remove_ctrl(sc, upipe->u.ctl.sqh);
d2602 1
a2602 2
uhci_device_bulk_done(xfer)
	usbd_xfer_handle xfer;
d2619 1
a2619 3
uhci_add_intr(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d2630 1
a2630 1
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
d2637 1
a2637 3
uhci_remove_intr(sc, sqh)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
d2644 6
d2653 1
d2660 1
a2660 4
uhci_device_setintr(sc, upipe, ival)
	uhci_softc_t *sc;
	struct uhci_pipe *upipe;
	int ival;
d2698 1
a2698 1
		sqh->elink = 0;
d2716 1
a2716 2
uhci_open(pipe)
	usbd_pipe_handle pipe;
d2854 1
a2854 4
uhci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d2874 1
a2874 2
uhci_root_ctrl_transfer(xfer)
	usbd_xfer_handle xfer;
d2891 1
a2891 2
uhci_root_ctrl_start(xfer)
	usbd_xfer_handle xfer;
d3182 1
a3182 1
			usb_delay_ms(&sc->sc_bus, 10);
d3187 1
a3187 1
			delay(100);
d3225 1
a3225 2
uhci_root_ctrl_abort(xfer)
	usbd_xfer_handle xfer;
d3232 1
a3232 2
uhci_root_ctrl_close(pipe)
	usbd_pipe_handle pipe;
d3239 1
a3239 2
uhci_root_intr_abort(xfer)
	usbd_xfer_handle xfer;
d3258 1
a3258 2
uhci_root_intr_transfer(xfer)
	usbd_xfer_handle xfer;
d3275 1
a3275 2
uhci_root_intr_start(xfer)
	usbd_xfer_handle xfer;
d3294 1
a3294 2
uhci_root_intr_close(pipe)
	usbd_pipe_handle pipe;
@


1.13
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.12 2000/04/14 22:50:25 aaron Exp $	*/
a103 14
#endif

/*
 * The UHCI controller is little endian, so on big endian machines
 * the data strored in memory needs to be swapped.
 */
#if defined(__FreeBSD__) || defined(__OpenBSD__)
#if BYTE_ORDER == BIG_ENDIAN
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
#else
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
@


1.12
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.11 2000/03/30 16:19:33 aaron Exp $	*/
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d1041 6
d2560 1
a2560 1
/* Remove interrupt QH, called with vflock. */
d3121 4
a3129 1
		case UHF_PORT_POWER:
@


1.11
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.10 2000/03/28 19:37:49 aaron Exp $	*/
/*	$NetBSD: uhci.c,v 1.108 2000/03/29 18:55:36 augustss Exp $	*/
d255 1
d262 1
d359 1
a359 1
			printf("uhci_find_qh: QH not found\n");
d590 1
a590 1
			printf("uhci_freex: xfer=%p not free, 0x%08x\n", xfer,
d649 1
a649 1
 * called from an intterupt context.  This is all right since we
d776 1
a776 1
#if 0
d780 3
a782 1
	uhci_softc_t *sc = thesc;
d784 4
d790 2
a791 2
	printf("framelist[i].link = %08x\n", sc->sc_framelist[0].link);
	uhci_dump_qh(sc->sc_ctl_start->qh.hlink);
a792 1
#endif
d1073 4
@


1.10
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.9 2000/03/26 21:47:51 aaron Exp $	*/
/*	$NetBSD: uhci.c,v 1.100 2000/03/27 09:41:36 augustss Exp $	*/
d155 8
a162 8
static void		uhci_busreset __P((uhci_softc_t *));
static void		uhci_shutdown __P((void *v));
static void		uhci_power __P((int, void *));
static usbd_status	uhci_run __P((uhci_softc_t *, int run));
static uhci_soft_td_t *uhci_alloc_std __P((uhci_softc_t *));
static void		uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));
static uhci_soft_qh_t *uhci_alloc_sqh __P((uhci_softc_t *));
static void		uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));
d164 1
a164 1
static void		uhci_enter_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *,
d166 1
a166 1
static void		uhci_exit_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *));
d169 1
a169 1
static void		uhci_free_std_chain __P((uhci_softc_t *, 
d171 1
a171 1
static usbd_status	uhci_alloc_std_chain __P((struct uhci_pipe *,
d174 2
a175 2
static void		uhci_poll_hub __P((void *));
static void		uhci_waitintr __P((uhci_softc_t *,
d177 1
a177 1
static void		uhci_check_intr __P((uhci_softc_t *,
d179 1
a179 1
static void		uhci_idone __P((uhci_intr_info_t *));
d181 1
a181 1
static void		uhci_abort_xfer __P((usbd_xfer_handle,
a182 11
static void		uhci_abort_xfer_end __P((void *v));
static void		uhci_abort_unlink_qh __P((struct uhci_pipe *));
static void		uhci_abort_relink_qh __P((struct uhci_pipe *));
static void		uhci_cancel_abort __P((usbd_pipe_handle));

static void		uhci_timeout __P((void *));
static void		uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));
static void		uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));
static void		uhci_remove_ctrl __P((uhci_softc_t *,uhci_soft_qh_t *));
static void		uhci_remove_bulk __P((uhci_softc_t *,uhci_soft_qh_t *));
static int		uhci_str __P((usb_string_descriptor_t *, int, char *));
d184 6
a189 2
static usbd_status	uhci_setup_isoc __P((usbd_pipe_handle pipe));
static void		uhci_device_isoc_enter __P((usbd_xfer_handle));
d191 4
a194 1
static usbd_status	uhci_allocm __P((struct usbd_bus *, usb_dma_t *,
d196 1
a196 1
static void		uhci_freem __P((struct usbd_bus *, usb_dma_t *));
d198 2
a199 2
static usbd_xfer_handle	uhci_allocx __P((struct usbd_bus *));
static void		uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));
d201 45
a245 45
static usbd_status	uhci_device_ctrl_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_device_ctrl_start __P((usbd_xfer_handle));
static void		uhci_device_ctrl_abort __P((usbd_xfer_handle));
static void		uhci_device_ctrl_close __P((usbd_pipe_handle));
static void		uhci_device_ctrl_done  __P((usbd_xfer_handle));

static usbd_status	uhci_device_intr_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_device_intr_start __P((usbd_xfer_handle));
static void		uhci_device_intr_abort __P((usbd_xfer_handle));
static void		uhci_device_intr_close __P((usbd_pipe_handle));
static void		uhci_device_intr_done  __P((usbd_xfer_handle));

static usbd_status	uhci_device_bulk_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_device_bulk_start __P((usbd_xfer_handle));
static void		uhci_device_bulk_abort __P((usbd_xfer_handle));
static void		uhci_device_bulk_close __P((usbd_pipe_handle));
static void		uhci_device_bulk_done  __P((usbd_xfer_handle));

static usbd_status	uhci_device_isoc_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_device_isoc_start __P((usbd_xfer_handle));
static void		uhci_device_isoc_abort __P((usbd_xfer_handle));
static void		uhci_device_isoc_close __P((usbd_pipe_handle));
static void		uhci_device_isoc_done  __P((usbd_xfer_handle));

static usbd_status	uhci_root_ctrl_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_root_ctrl_start __P((usbd_xfer_handle));
static void		uhci_root_ctrl_abort __P((usbd_xfer_handle));
static void		uhci_root_ctrl_close __P((usbd_pipe_handle));
static void		uhci_root_ctrl_done  __P((usbd_xfer_handle));

static usbd_status	uhci_root_intr_transfer __P((usbd_xfer_handle));
static usbd_status	uhci_root_intr_start __P((usbd_xfer_handle));
static void		uhci_root_intr_abort __P((usbd_xfer_handle));
static void		uhci_root_intr_close __P((usbd_pipe_handle));
static void		uhci_root_intr_done  __P((usbd_xfer_handle));

static usbd_status	uhci_open __P((usbd_pipe_handle));
static void		uhci_poll __P((struct usbd_bus *));
static void		uhci_softintr __P((struct usbd_bus *));

static usbd_status	uhci_device_request __P((usbd_xfer_handle xfer));

static void		uhci_add_intr __P((uhci_softc_t *, uhci_soft_qh_t *));
static void		uhci_remove_intr __P((uhci_softc_t*, uhci_soft_qh_t*));
static usbd_status	uhci_device_setintr __P((uhci_softc_t *sc, 
d248 2
a249 2
static void		uhci_device_clear_toggle __P((usbd_pipe_handle pipe));
static void		uhci_noop __P((usbd_pipe_handle pipe));
d251 1
a251 1
static __inline__ uhci_soft_qh_t *uhci_find_prev_qh
d255 6
a260 6
static void		uhci_dumpregs __P((uhci_softc_t *));
static void		uhci_dump_qhs __P((uhci_soft_qh_t *));
static void		uhci_dump_qh __P((uhci_soft_qh_t *));
static void		uhci_dump_tds __P((uhci_soft_td_t *));
static void		uhci_dump_td __P((uhci_soft_td_t *));
static void		uhci_dump_ii __P((uhci_intr_info_t *ii));
d348 1
a348 1
static __inline__ uhci_soft_qh_t *
d540 26
a565 2
	return (usb_allocmem(&((struct uhci_softc *)bus)->sc_bus, size, 0,
			     dma));
d622 1
a622 1
	if (!UXFER(xfer)->iinfo.isdone)
d624 2
d720 1
a720 1
static void
d840 1
a840 1
static void
d1644 1
a1644 1
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
d1712 3
a1714 52
 * Aborting a xfer on the UHCI host controller is tricky.
 * The problem is that the HC can asynchronously manipulate
 * the very fields in the QH and TD that we need to abort a
 * xfer.
 * The problematic field are qh_elink (which points to the first
 * TD) and td_status which contains the active flag.
 * 
 * Here's my current (convoluted) strategy:
 * - Block HC interrupt.  We need this to check if the xfer
 *   might already be over.  If called outside splusb() this can
 *   happen.
 * - Check if an abort is already in progress (see below), if so
 *   just link out the xfer, run the callback, and return.
 * - Otherwise, flag that abort is in progress.
 * - Remove the QH for the xfer from the list of QHs (this
 *   can be done safely).
 * - Remove the transaction from the list of transactions examined
 *   when the HC interrupts.
 *     At this point we know that the transaction will never be considered
 *     by the interrupt routine.  The trouble we have is that the HC might
 *     be following the chain of TDs rooted at the unlinked QH because it
 *     started before the unlink.
 *     We would like to run the xfer callback function at this point
 *     to inform it that the xfer has been aborted, but running the
 *     callback might result in freeing the xfer.  This would be bad
 *     since the HC might still use it.  So we need to avoid this by:
 * - Disable the active flag in all TD belonging to the xfer.
 *   If we do this we can guarantee that the HC will execute at most one 
 *   TD after we turn off the flag in the last TD.
 * - Busy-wait until the HC has finished with the TD.  We do this by
 *   keeping track of the longest TD and using delay() for the time it
 *   takes to complete it (one byte takes a little less than 1 (LS 6) us).
 * - Run the callback routine, since at this point the HC can not be
 *   using any TDs in the xfer.
 *     We still cannot manipulate the qh_elink field in the QH since the
 *     HC might be following TDs further down the chain for another 1 ms.
 *     So...
 * - Set up a timeout 1 ms into the future.
 * - Turn on interrupts.
 * - Return.
 *
 * When the timeout happens we do the following:
 * - Check if the qh_elink field points anywhere in the TD chain we had
 *   when the timeout was set up.  If it is, leave qh_elink alone,
 *   otherwise set qh_elink pointing to the next (if any) xfer in
 *   the TD chain.
 * - Link the QH back where we got it.
 * - Turn off flag about abort in progress.
 * Done!
 *
 * The timeout is associated with the pipe and it must be cancelled if
 * the pipe is closed.
a1715 1

a1720 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
a1723 1
	int len, maxlen;
d1725 1
a1725 2
	DPRINTFN(1,("uhci_abort_xfer: xfer=%p, xfer->status=%d, status=%d\n", 
		    xfer, xfer->status, status));
d1736 1
a1736 1
	/* Give xfer the requested abort code. */
d1739 2
a1740 10
	/* If already aborting, bail out early. */
	if (upipe->aborting) {
		/* Unlink the xfer from HC */
		/*XXX only one xfer for now*/
		printf("uhci_abort_xfer: abort while aborting\n");
		/* Finalize xfer. */
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}
d1742 2
a1743 12
	upipe->aborting = 1;
	upipe->abortstart = SIMPLEQ_NEXT(xfer, next);
	upipe->abortend = NULL;	/* XXX only one xfer for now */

	/* Remove QH(s) from HC schedule. */
	uhci_abort_unlink_qh(upipe);

	/* Remove intr_info from list is done by usb_transfer_complete() .*/
	
	/* Disable active bit. */
	maxlen = 0;
	for (std = ii->stdstart; std != NULL; std = std->link.std) {
a1744 18
		len = UHCI_TD_GET_MAXLEN(std->td.td_token);
		if (len > maxlen)
			maxlen = len;
	}
	/* compute delay in us */
	if (upipe->pipe.device->lowspeed)
		maxlen *= 6;
	/* wait for HC to complete TDs */
	delay(maxlen);

	/* Don't timeout, */
	usb_uncallout(xfer->timeout_handle, uhci_timeout, ii);

#ifdef DIAGNOSTIC
	UXFER(xfer)->iinfo.isdone = 1;
#endif
	/* Run callback and remove from interrupt list. */
	usb_transfer_complete(xfer);
d1746 1
a1746 3
	/* Set up final processing. */
	usb_callout(xfer->pipe->abort_handle, hz / USB_FRAMES_PER_SECOND,
		    uhci_abort_xfer_end, upipe);
a1747 1
	/* And return. */
a1748 12
}

void
uhci_abort_xfer_end(v)
	void *v;
{
	struct uhci_pipe *upipe = v;
	usbd_xfer_handle xf;
	uhci_soft_td_t *std;
	uhci_soft_qh_t *sqh, **qhs;
	int s;
	int i, nqhs;
d1750 1
a1750 25
	DPRINTFN(5,("uhci_abort_xfer_end: upipe=%p\n", upipe));

	switch (UE_GET_XFERTYPE(upipe->pipe.endpoint->edesc->bmAttributes)) {
	case UE_CONTROL:
#if 0
		qhs = &upipe->u.ctl.sqh;
		nqhs = 1;
#else
/* only one ctl transfer; qh unlinked by usb_transfer_complete() */
		nqhs = 0;
#endif
		break;
	case UE_ISOCHRONOUS:
		printf("uhci_abort_xfer_end: iso\n");
		nqhs = 0;
		break;
	case UE_BULK:
		qhs = &upipe->u.bulk.sqh;
		nqhs = 1;
		break;
	case UE_INTERRUPT:
		qhs = upipe->u.intr.qhs;
		nqhs = upipe->u.intr.npoll;
		break;
	}
a1752 56

	for (i = 0; i < nqhs; i++) {
		sqh = qhs[i];
		/* Check if inside remaining TD chain. */
		for (xf = upipe->abortstart; xf != NULL; 
		     xf = SIMPLEQ_NEXT(xf, next)) {
			for (std = UXFER(xf)->iinfo.stdstart; std != NULL; 
			     std = std->link.std) {
				if (std->physaddr == le32toh(sqh->qh.qh_elink))
					goto outside;
			}
			if (xf == upipe->abortend)
				break;
		}
		if (upipe->abortstart != NULL) {
			std = UXFER(upipe->abortstart)->iinfo.stdstart;
			DPRINTFN(5,("uhci_abort_xfer_end: new std=%p\n", std));
			sqh->elink = std;
			sqh->qh.qh_elink = htole32(std->physaddr);
		} else {
			DPRINTFN(5,("uhci_abort_xfer_end: new std=NULL\n"));
			sqh->elink = NULL;
			sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		}
	}

outside:

	/* Insert QH again. */
	uhci_abort_relink_qh(upipe);

	/* No longer aborting */
	upipe->aborting = 0;

	splx(s);
}

void
uhci_abort_unlink_qh(upipe)
	struct uhci_pipe *upipe;
{
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
	uhci_soft_qh_t *sqh, *pqh, **qhs;
	int i, npoll;

	DPRINTFN(5,("uhci_abort_unlink_qh: sc=%p pipe=%p\n", sc, upipe));

	switch (UE_GET_XFERTYPE(upipe->pipe.endpoint->edesc->bmAttributes)) {
	case UE_CONTROL:
#if 0
/* At the moment the done routine removes the QH */
		sqh = upipe->u.ctl.sqh;
		pqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);
		pqh->qh.qh_hlink = sqh->qh.qh_hlink;
#endif
		break;
d1754 1
a1754 3
	case UE_ISOCHRONOUS:
		printf("uhci_abort_unlink_qh: iso\n");
		break;
d1756 1
a1756 76
	case UE_BULK:
#if 0
/* At the moment the done routine removes the QH */
		sqh = upipe->u.bulk.sqh;
		pqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);
		pqh->qh.qh_hlink = sqh->qh.qh_hlink;
#endif
		break;
	case UE_INTERRUPT:
		npoll = upipe->u.intr.npoll;
		qhs = upipe->u.intr.qhs;
		for (i = 0; i < npoll; i++) {
			sqh = qhs[i];
			pqh = uhci_find_prev_qh(sc->sc_vframes[sqh->pos].hqh,
						sqh);
			pqh->qh.qh_hlink = sqh->qh.qh_hlink;
		}
		break;
	}
}

void
uhci_abort_relink_qh(upipe)
	struct uhci_pipe *upipe;
{
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
	uhci_soft_qh_t *sqh, *pqh, **qhs;
	int i, npoll;

	switch (UE_GET_XFERTYPE(upipe->pipe.endpoint->edesc->bmAttributes)) {
	case UE_CONTROL:
#if 0
/* At the moment the done routine removes the QH */
		sqh = upipe->u.ctl.sqh;
		pqh = uhci_find_prev_qh(sc->sc_ctl_start, sqh);
		pqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
#endif
		break;
#ifdef DIAGNOSTIC
	case UE_ISOCHRONOUS:
		printf("uhci_abort_relink_qh: iso\n");
		break;
#endif
	case UE_BULK:
#if 0
/* At the moment the done routine removes the QH */
		sqh = upipe->u.bulk.sqh;
		pqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);
		pqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
#endif
		break;
	case UE_INTERRUPT:
		npoll = upipe->u.intr.npoll;
		qhs = upipe->u.intr.qhs;
		for (i = 0; i < npoll; i++) {
			sqh = qhs[i];
			pqh = uhci_find_prev_qh(sc->sc_vframes[sqh->pos].hqh,
						sqh);
			pqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_Q);
		}
		break;
	}
}

void
uhci_cancel_abort(pipe)
	usbd_pipe_handle pipe;
{
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	int s;

	s = splusb();
	if (upipe->aborting) {
		usb_uncallout(pipe->abort_handle, uhci_abort_xfer_end, upipe);
		upipe->aborting = 0;
	}
a1759 1

a1768 1
	uhci_cancel_abort(pipe);
a1917 1
	uhci_cancel_abort(pipe);
a1942 2
	uhci_cancel_abort(pipe);

d2110 1
a2110 1
	/* and put on interrupt list if the pipe wasn't running */
d2228 1
a2228 1
	if (!ii->isdone) {
a2229 1
	}
@


1.9
log
@Fix typos.
@
text
@d1 3
a3 2
/*	$OpenBSD: uhci.c,v 1.8 2000/03/26 15:53:07 aaron Exp $	*/
/*	$NetBSD: uhci.c,v 1.87 2000/02/29 21:37:01 augustss Exp $	*/
d97 1
d110 1
d112 2
a113 1
#define LE(x) (bswap32(x))
d115 3
a117 1
#define LE(x) (x)
a121 1
	uhci_intr_info_t *iinfo;
d123 4
d155 8
a162 16
/* 
 * The uhci_intr_info free list can be global since they contain
 * no dma specific data.  The other free lists do.
 */
LIST_HEAD(, uhci_intr_info) uhci_ii_free;

void		uhci_busreset __P((uhci_softc_t *));
void		uhci_shutdown __P((void *v));
void		uhci_power __P((int, void *));
usbd_status	uhci_run __P((uhci_softc_t *, int run));
uhci_soft_td_t *uhci_alloc_std __P((uhci_softc_t *));
void		uhci_free_std __P((uhci_softc_t *, uhci_soft_td_t *));
uhci_soft_qh_t *uhci_alloc_sqh __P((uhci_softc_t *));
void		uhci_free_sqh __P((uhci_softc_t *, uhci_soft_qh_t *));
uhci_intr_info_t *uhci_alloc_intr_info __P((uhci_softc_t *));
void		uhci_free_intr_info __P((uhci_intr_info_t *ii));
d164 1
a164 1
void		uhci_enter_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *,
d166 1
a166 1
void		uhci_exit_ctl_q __P((uhci_softc_t *, uhci_soft_qh_t *));
d169 1
a169 1
void		uhci_free_std_chain __P((uhci_softc_t *, 
d171 83
a253 77
usbd_status	uhci_alloc_std_chain __P((struct uhci_pipe *, uhci_softc_t *,
					  int, int, u_int16_t, usb_dma_t *, 
					  uhci_soft_td_t **,
					  uhci_soft_td_t **));
void		uhci_timo __P((void *));
void		uhci_waitintr __P((uhci_softc_t *, usbd_xfer_handle));
void		uhci_check_intr __P((uhci_softc_t *, uhci_intr_info_t *));
void		uhci_idone __P((uhci_intr_info_t *));
void		uhci_abort_xfer __P((usbd_xfer_handle, usbd_status status));
void		uhci_abort_xfer_end __P((void *v));
void		uhci_timeout __P((void *));
void		uhci_wakeup_ctrl __P((void *, int, int, void *, int));
void		uhci_lock_frames __P((uhci_softc_t *));
void		uhci_unlock_frames __P((uhci_softc_t *));
void		uhci_add_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));
void		uhci_add_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));
void		uhci_remove_ctrl __P((uhci_softc_t *, uhci_soft_qh_t *));
void		uhci_remove_bulk __P((uhci_softc_t *, uhci_soft_qh_t *));
int		uhci_str __P((usb_string_descriptor_t *, int, char *));

usbd_status	uhci_setup_isoc __P((usbd_pipe_handle pipe));
void		uhci_device_isoc_enter __P((usbd_xfer_handle));

void		uhci_wakeup_cb __P((usbd_xfer_handle xfer));

usbd_status	uhci_allocm __P((struct usbd_bus *, usb_dma_t *, u_int32_t));
void		uhci_freem __P((struct usbd_bus *, usb_dma_t *));

usbd_xfer_handle uhci_allocx __P((struct usbd_bus *));
void		uhci_freex __P((struct usbd_bus *, usbd_xfer_handle));

usbd_status	uhci_device_ctrl_transfer __P((usbd_xfer_handle));
usbd_status	uhci_device_ctrl_start __P((usbd_xfer_handle));
void		uhci_device_ctrl_abort __P((usbd_xfer_handle));
void		uhci_device_ctrl_close __P((usbd_pipe_handle));
void		uhci_device_ctrl_done  __P((usbd_xfer_handle));

usbd_status	uhci_device_intr_transfer __P((usbd_xfer_handle));
usbd_status	uhci_device_intr_start __P((usbd_xfer_handle));
void		uhci_device_intr_abort __P((usbd_xfer_handle));
void		uhci_device_intr_close __P((usbd_pipe_handle));
void		uhci_device_intr_done  __P((usbd_xfer_handle));

usbd_status	uhci_device_bulk_transfer __P((usbd_xfer_handle));
usbd_status	uhci_device_bulk_start __P((usbd_xfer_handle));
void		uhci_device_bulk_abort __P((usbd_xfer_handle));
void		uhci_device_bulk_close __P((usbd_pipe_handle));
void		uhci_device_bulk_done  __P((usbd_xfer_handle));

usbd_status	uhci_device_isoc_transfer __P((usbd_xfer_handle));
usbd_status	uhci_device_isoc_start __P((usbd_xfer_handle));
void		uhci_device_isoc_abort __P((usbd_xfer_handle));
void		uhci_device_isoc_close __P((usbd_pipe_handle));
void		uhci_device_isoc_done  __P((usbd_xfer_handle));

usbd_status	uhci_root_ctrl_transfer __P((usbd_xfer_handle));
usbd_status	uhci_root_ctrl_start __P((usbd_xfer_handle));
void		uhci_root_ctrl_abort __P((usbd_xfer_handle));
void		uhci_root_ctrl_close __P((usbd_pipe_handle));
void		uhci_root_ctrl_done __P((usbd_xfer_handle));

usbd_status	uhci_root_intr_transfer __P((usbd_xfer_handle));
usbd_status	uhci_root_intr_start __P((usbd_xfer_handle));
void		uhci_root_intr_abort __P((usbd_xfer_handle));
void		uhci_root_intr_close __P((usbd_pipe_handle));
void		uhci_root_intr_done  __P((usbd_xfer_handle));

usbd_status	uhci_open __P((usbd_pipe_handle));
void		uhci_poll __P((struct usbd_bus *));
void		uhci_softintr __P((struct usbd_bus *));

usbd_status	uhci_device_request __P((usbd_xfer_handle xfer));

void		uhci_add_intr __P((uhci_softc_t *, int, uhci_soft_qh_t *));
void		uhci_remove_intr __P((uhci_softc_t *, int, uhci_soft_qh_t *));
usbd_status	uhci_device_setintr __P((uhci_softc_t *sc, 
					 struct uhci_pipe *pipe, int ival));
d255 2
a256 2
void		uhci_device_clear_toggle __P((usbd_pipe_handle pipe));
void		uhci_noop __P((usbd_pipe_handle pipe));
d259 6
a264 6
static void	uhci_dumpregs __P((uhci_softc_t *));
void		uhci_dump_qhs __P((uhci_soft_qh_t *));
void		uhci_dump_qh __P((uhci_soft_qh_t *));
void		uhci_dump __P((void));
void		uhci_dump_tds __P((uhci_soft_td_t *));
void		uhci_dump_td __P((uhci_soft_td_t *));
d347 22
d390 2
d403 2
a404 2
			 UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),
			 UHCI_FRAMELIST_ALIGN, &sc->sc_dma);
d415 2
a416 2
	bsqh->qh.qh_hlink = LE(UHCI_PTR_T);	/* end of QH chain */
	bsqh->qh.qh_elink = LE(UHCI_PTR_T);
d424 2
a425 2
	csqh->qh.qh_hlink = LE(bsqh->physaddr | UHCI_PTR_Q);
	csqh->qh.qh_elink = LE(UHCI_PTR_T);
d439 4
a442 4
		std->td.td_link = LE(sqh->physaddr | UHCI_PTR_Q);
		std->td.td_status = LE(UHCI_TD_IOS);	/* iso, inactive */
		std->td.td_token = LE(0);
		std->td.td_buffer = LE(0);
d444 1
a444 1
		sqh->qh.qh_hlink = LE(csqh->physaddr | UHCI_PTR_Q);
d446 1
a446 1
		sqh->qh.qh_elink = LE(UHCI_PTR_T);
d454 1
a454 1
			sc->sc_pframes[j] = LE(std->physaddr);
d461 2
d467 1
a469 1

d471 1
d518 1
d521 1
d530 1
a530 1
	}
d564 1
a564 1
	if (xfer != NULL)
d566 19
a584 4
	else
		xfer = malloc(sizeof(*xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		memset(xfer, 0, sizeof *xfer);
d595 10
d648 3
a650 3
		if (sc->sc_has_timo != NULL)
			usb_untimeout(uhci_timo, sc->sc_has_timo, 
				      sc->sc_has_timo->timo_handle);
d686 3
a688 3
		if (sc->sc_has_timo != NULL)
			usb_timeout(uhci_timo, sc->sc_has_timo, 
				    sc->sc_ival, sc->sc_has_timo->timo_handle);
d722 4
a725 4
		     (long)LE(p->td.td_link),
		     (long)LE(p->td.td_status),
		     (long)LE(p->td.td_token),
		     (long)LE(p->td.td_buffer)));
d728 1
a728 1
		     (int)LE(p->td.td_link),
d730 1
a730 1
		     (int)LE(p->td.td_status),
d733 7
a739 7
		     UHCI_TD_GET_ERRCNT(LE(p->td.td_status)),
		     UHCI_TD_GET_ACTLEN(LE(p->td.td_status)),
		     UHCI_TD_GET_PID(LE(p->td.td_token)),
		     UHCI_TD_GET_DEVADDR(LE(p->td.td_token)),
		     UHCI_TD_GET_ENDPT(LE(p->td.td_token)),
		     UHCI_TD_GET_DT(LE(p->td.td_token)),
		     UHCI_TD_GET_MAXLEN(LE(p->td.td_token))));
d747 2
a748 1
	    (int)sqh->physaddr, LE(sqh->qh.qh_hlink), LE(sqh->qh.qh_elink)));
d751 1
d756 1
a756 1
	uhci_softc_t *sc = uhci;
d765 1
d786 2
a787 1
	if (sqh->hlink != NULL && !(sqh->qh.qh_hlink & UHCI_PTR_T))
d792 1
a792 1
	if (sqh->elink != NULL && !(sqh->qh.qh_elink & UHCI_PTR_T))
d812 2
a813 1
		if (td->td.td_link & UHCI_PTR_T || td->td.td_link == 0)
d817 55
d879 1
a879 1
uhci_timo(addr)
d888 1
a888 1
	DPRINTFN(20, ("uhci_timo\n"));
d890 1
a890 1
	usb_timeout(uhci_timo, xfer, sc->sc_ival, xfer->timo_handle);
a904 1
	xfer->hcpriv = 0;
a922 58

void
uhci_lock_frames(sc)
	uhci_softc_t *sc;
{
	int s = splusb();

	while (sc->sc_vflock & UHCI_HAS_LOCK) {
		sc->sc_vflock |= UHCI_WANT_LOCK;
		tsleep(&sc->sc_vflock, PRIBIO, "uhcqhl", 0);
	}
	sc->sc_vflock = UHCI_HAS_LOCK;
	splx(s);
}

void
uhci_unlock_frames(sc)
	uhci_softc_t *sc;
{
	int s = splusb();

	sc->sc_vflock &= ~UHCI_HAS_LOCK;
	if (sc->sc_vflock & UHCI_WANT_LOCK)
		wakeup(&sc->sc_vflock);
	splx(s);
}

/*
 * Allocate an interrupt information struct.  A free list is kept
 * for fast allocation.
 */
uhci_intr_info_t *
uhci_alloc_intr_info(sc)
	uhci_softc_t *sc;
{
	uhci_intr_info_t *ii;

	ii = LIST_FIRST(&uhci_ii_free);
	if (ii)
		LIST_REMOVE(ii, list);
	else {
		ii = malloc(sizeof(uhci_intr_info_t), M_USBHC, M_NOWAIT);
	}
	ii->sc = sc;
#if defined(__FreeBSD__)
	callout_handle_init(&ii->timeout_handle);
#endif

	return ii;
}

void
uhci_free_intr_info(ii)
	uhci_intr_info_t *ii;
{
	LIST_INSERT_HEAD(&uhci_ii_free, ii, list); /* and put on free list */
}

d938 1
a938 1
	eqh->qh.qh_hlink = LE(sqh->physaddr | UHCI_PTR_Q);
d953 1
a953 9
	for (pqh = sc->sc_ctl_start; pqh->hlink != sqh; pqh=pqh->hlink)
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
		if (LE(pqh->qh.qh_hlink) & UHCI_PTR_T) {
			printf("uhci_remove_ctrl: QH not found\n");
			return;
		}
#else
		;
#endif
d975 1
a975 1
	eqh->qh.qh_hlink = LE(sqh->physaddr | UHCI_PTR_Q);
d990 1
a990 9
	for (pqh = sc->sc_bulk_start; pqh->hlink != sqh; pqh = pqh->hlink)
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
		if (LE(pqh->qh.qh_hlink) & UHCI_PTR_T) {
			printf("uhci_remove_bulk: QH not found\n");
			return;
		}
#else
		;
#endif
d1016 1
a1016 1
#if defined(DIAGNOSTIC) && (defined(__NetBSD__) || defined(__OpenBSD__))
d1036 1
a1036 1
		printf("%s: host controller process error\n",
d1117 2
a1118 2
	if (LE(lstd->td.td_status) & UHCI_TD_ACTIVE) {
		DPRINTFN(15, ("uhci_check_intr: active ii=%p\n", ii));
d1120 1
a1120 1
			status = LE(std->td.td_status);
d1129 2
a1130 2
			    UHCI_TD_GET_ACTLEN(status) <
			    UHCI_TD_GET_MAXLEN(LE(std->td.td_token)))
d1133 1
a1133 1
		DPRINTFN(15, ("uhci_check_intr: ii=%p std=%p still active\n",
d1138 2
a1139 2
	DPRINTFN(15, ("uhci_check_intr: ii=%p done\n", ii));
	usb_untimeout(uhci_timeout, ii, ii->timeout_handle);
d1159 4
d1164 1
d1187 1
a1187 1
		n = xfer->hcprivint;
d1198 1
a1198 1
			status = LE(std->td.td_status);
a1203 1
		xfer->hcpriv = ii;
a1215 1
	/* XXX Is this correct for control xfers? */
d1218 1
a1218 1
		nstatus = LE(std->td.td_status);
d1223 2
a1224 1
		if (UHCI_TD_GET_PID(LE(std->td.td_token)) != UHCI_TD_PID_SETUP)
d1229 1
a1229 1
		upipe->nexttoggle = UHCI_TD_GET_DT(LE(std->td.td_token));
a1250 1
	xfer->hcpriv = ii;
d1327 2
a1328 2
uhci_reset(p)
	void *p;
a1329 1
	uhci_softc_t *sc = p;
d1336 1
a1336 1
		delay(100);
d1399 1
a1399 1
				 UHCI_TD_ALIGN, &dma);
d1423 1
a1423 1
	if (std->td.td_token == LE(TD_IS_FREE)) {
d1427 1
a1427 1
	std->td.td_token = LE(TD_IS_FREE);
d1445 1
a1445 1
				 UHCI_QH_ALIGN, &dma);
a1470 16
#if 0
/* 
 * Enter a list of transfers onto a control queue.
 * Called at splusb() 
 */
void
uhci_enter_ctl_q(sc, sqh, ii)
	uhci_softc_t *sc;
	uhci_soft_qh_t *sqh;
	uhci_intr_info_t *ii;
{
	DPRINTFN(5, ("uhci_enter_ctl_q: sqh=%p\n", sqh));

}
#endif

d1502 2
a1503 2
		     "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len,
		     upipe->pipe.device->lowspeed, flags));
d1538 1
a1538 1
			p->td.td_link = LE(lastlink);
d1540 1
a1540 1
			p->td.td_link = LE(lastlink|UHCI_PTR_VF);
d1543 1
a1543 1
		p->td.td_status = LE(status);
d1553 3
a1555 3
		    LE(rd ? UHCI_TD_IN (l, endpt, addr, tog) :
			    UHCI_TD_OUT(l, endpt, addr, tog));
		p->td.td_buffer = LE(DMAADDR(dma) + i * maxp);
d1589 3
a1591 2
	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
d1603 1
a1603 1
	uhci_intr_info_t *ii = upipe->iinfo;
d1630 1
a1630 1
				 &xfer->dmabuf, &data, &dataend);
d1633 1
a1633 1
	dataend->td.td_status |= LE(UHCI_TD_IOC);
a1645 3
#if defined(__FreeBSD__)
	callout_handle_init(&ii->timeout_handle);
#endif
d1654 1
a1654 2
	sqh->qh.qh_elink = LE(data->physaddr);
	sqh->intr_info = ii;
d1658 1
a1658 1
	LIST_INSERT_HEAD(&sc->sc_intrhead, ii, list);
d1661 2
a1662 2
		usb_timeout(uhci_timeout, ii, MS_TO_TICKS(xfer->timeout),
			    ii->timeout_handle);
d1664 1
d1689 55
d1750 1
a1750 1
	uhci_intr_info_t *ii = upipe->iinfo;
d1752 7
d1760 6
a1765 1
	DPRINTFN(1,("uhci_abort_xfer: xfer=%p, status=%d\n", xfer, status));
d1767 1
a1767 1
	/* Make interrupt routine ignore it, */
d1770 10
a1779 2
	/* don't timeout, */
	usb_untimeout(uhci_timeout, ii, ii->timeout_handle);
d1781 3
a1783 3
	/* make hardware ignore it, */
	for (std = ii->stdstart; std != 0; std = std->link.std)
		std->td.td_status &= LE(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
d1785 2
a1786 1
	xfer->hcpriv = ii;
d1788 9
a1796 13
#if 1
	/* Make sure hardware has completed, */
	if (xfer->device->bus->intr_context) {
		/* We have no process context, so we can't use tsleep(). */
		timeout(uhci_abort_xfer_end, xfer, hz / USB_FRAMES_PER_SECOND);
	} else {
#if defined(DIAGNOSTIC) && defined(__i386__) && defined(__FreeBSD__)
		KASSERT(intr_nesting_level == 0,
			("ohci_abort_req in interrupt context"));
#endif
		usb_delay_ms(xfer->pipe->device->bus, 1);
		/* and call final part of interrupt handler. */
		uhci_abort_xfer_end(xfer);
d1798 11
a1808 3
#else
	delay(1000);
	uhci_abort_xfer_end(xfer);
d1810 9
d1825 164
a1988 1
	usbd_xfer_handle xfer = v;
d1992 4
a1995 1
	usb_transfer_complete(xfer);
d1999 1
d2009 1
a2010 2
	uhci_free_intr_info(upipe->iinfo);
	/* XXX free other resources? */
d2024 3
a2026 2
	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
d2066 3
a2068 2
	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
d2080 1
a2080 1
	uhci_intr_info_t *ii = upipe->iinfo;
d2098 1
a2098 1
				 &xfer->dmabuf, &data, &dataend);
d2101 1
a2101 1
	dataend->td.td_status |= LE(UHCI_TD_IOC);
a2115 3
#if defined(__FreeBSD__)
	callout_handle_init(&ii->timeout_handle);
#endif
d2128 1
a2128 1
		sqh->qh.qh_elink = LE(data->physaddr);
d2130 2
d2159 1
a2159 4
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;

	uhci_free_intr_info(upipe->iinfo);
	/* XXX free other resources */
d2182 2
a2183 1
	int i, s, npoll;
d2185 1
a2185 1
	upipe->iinfo->stdstart = 0;		/* inactive */
d2189 1
a2189 1
	uhci_lock_frames(sc);
d2191 2
a2192 3
		uhci_remove_intr(sc, upipe->u.intr.qhs[i]->pos, 
				 upipe->u.intr.qhs[i]);
	uhci_unlock_frames(sc);
a2203 5
	s = splusb();
	LIST_REMOVE(upipe->iinfo, list);	/* remove from active list */
	splx(s);
	uhci_free_intr_info(upipe->iinfo);

d2217 1
a2217 1
	uhci_intr_info_t *ii = upipe->iinfo;
d2244 1
a2244 1
					 &xfer->dmabuf, &data, &dataend);
d2249 1
a2249 1
		dataend->td.td_link = LE(stat->physaddr | UHCI_PTR_VF);
d2258 9
a2266 8
	setup->td.td_link = LE(next->physaddr | UHCI_PTR_VF);
	setup->td.td_status = LE(UHCI_TD_SET_ERRCNT(3) | ls | UHCI_TD_ACTIVE);
	setup->td.td_token = LE(UHCI_TD_SETUP(sizeof *req, endpt, addr));
	setup->td.td_buffer = LE(DMAADDR(&upipe->u.ctl.reqdma));

	stat->link.std = 0;
	stat->td.td_link = LE(UHCI_PTR_T);
	stat->td.td_status = LE(UHCI_TD_SET_ERRCNT(3) | ls | 
d2269 3
a2271 3
		LE(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :
		            UHCI_TD_IN (0, endpt, addr, 1));
	stat->td.td_buffer = LE(0);
a2283 3
#if defined(__FreeBSD__)
	callout_handle_init(&ii->timeout_handle);
#endif
d2292 1
a2292 2
	sqh->qh.qh_elink = LE(setup->physaddr);
	sqh->intr_info = ii;
d2296 1
a2296 1
	LIST_INSERT_HEAD(&sc->sc_intrhead, ii, list);
d2308 1
a2308 1
			link = LE(std->td.td_link);
d2325 2
a2326 2
		usb_timeout(uhci_timeout, ii,
                            MS_TO_TICKS(xfer->timeout), ii->timeout_handle);
d2328 1
d2382 1
d2399 1
a2399 1
	xfer->hcprivint = next;
d2402 3
a2404 3
	status = LE(UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |
					UHCI_TD_ACTIVE |
					UHCI_TD_IOS));
d2412 1
a2412 1
		std->td.td_buffer = LE(buf);
d2414 4
a2417 4
			status |= LE(UHCI_TD_IOC);
		std->td.td_status = status;
		std->td.td_token &= LE(~UHCI_TD_MAXLEN_MASK);
		std->td.td_token |= LE(UHCI_TD_SET_MAXLEN(len));
d2438 1
a2438 1
	uhci_intr_info_t *ii = upipe->iinfo;
d2442 2
d2453 1
a2453 1
	i = xfer->hcprivint + xfer->nframes;
d2458 7
a2470 3
#if defined(__FreeBSD__)
	callout_handle_init(&ii->timeout_handle);
#endif
d2477 1
a2477 1
	LIST_INSERT_HEAD(&sc->sc_intrhead, ii, list);
a2488 1
	uhci_intr_info_t *ii = upipe->iinfo;
d2491 10
a2500 1
	int i, n, nframes;
d2502 1
a2502 1
	/* Make interrupt routine ignore it, */
d2507 2
a2508 1
	n = xfer->hcprivint;
d2511 4
a2514 1
		std->td.td_status &= LE(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
d2519 8
a2526 1
	xfer->hcpriv = ii;
d2528 1
a2528 9
	/* make sure hardware has completed, */
	if (xfer->device->bus->intr_context) {
		/* We have no process context, so we can't use tsleep(). */
		timeout(uhci_abort_xfer_end, xfer, hz / USB_FRAMES_PER_SECOND);
	} else {
		usb_delay_ms(xfer->pipe->device->bus, 1);
		/* and call final part of interrupt handler. */
		uhci_abort_xfer_end(xfer);
	}
d2540 1
a2540 1
	int i;
d2551 1
a2551 1
		iso->stds[i]->td.td_status &= LE(~UHCI_TD_ACTIVE);
d2554 1
a2554 1
	uhci_lock_frames(sc);
d2564 1
a2564 1
			uhci_unlock_frames(sc);
d2571 1
a2571 1
	uhci_unlock_frames(sc);
d2589 1
a2589 1
	int i;
d2595 2
a2596 2
	token = LE(rd ? UHCI_TD_IN (0, endpt, addr, 0) :
			UHCI_TD_OUT(0, endpt, addr, 0));
d2603 2
a2604 2
		std->td.td_status = LE(UHCI_TD_IOS);	/* iso, inactive */
		std->td.td_token = token;
d2609 1
a2609 1
	uhci_lock_frames(sc);
d2616 1
a2616 1
		vstd->td.td_link = LE(std->physaddr);
d2618 1
a2618 1
	uhci_unlock_frames(sc);
d2636 1
a2636 1
	uhci_intr_info_t *ii = xfer->hcpriv;
d2640 20
d2661 1
a2661 1
	ii->stdend->td.td_status &= LE(~UHCI_TD_IOC);
d2663 1
a2663 1
	LIST_REMOVE(ii, list);	/* remove from active list */
d2670 1
a2670 1
	uhci_intr_info_t *ii = xfer->hcpriv;
d2682 1
a2682 1
		sqh->qh.qh_elink = LE(UHCI_PTR_T);
d2690 2
d2695 1
a2695 1
		dataend->td.td_status |= LE(UHCI_TD_IOC);
a2706 3
#if defined(__FreeBSD__)
		callout_handle_init(&ii->timeout_handle);
#endif
d2716 1
a2716 1
			sqh->qh.qh_elink = LE(data->physaddr);
d2718 2
d2721 2
a2722 1
		ii->stdstart = 0;	/* mark as inactive */
d2731 1
a2731 1
	uhci_intr_info_t *ii = xfer->hcpriv;
d2740 1
a2740 1
	LIST_REMOVE(ii, list);	/* remove from active list */
d2755 1
a2755 1
	uhci_intr_info_t *ii = xfer->hcpriv;
d2759 1
a2759 1
	LIST_REMOVE(ii, list);	/* remove from active list */
d2770 1
a2770 1
uhci_add_intr(sc, n, sqh)
a2771 1
	int n;
d2774 1
a2774 1
	struct uhci_vframe *vf = &sc->sc_vframes[n];
d2777 2
a2778 1
	DPRINTFN(4, ("uhci_add_intr: n=%d sqh=%p\n", n, sqh));
d2783 1
a2783 1
	eqh->qh.qh_hlink = LE(sqh->physaddr | UHCI_PTR_Q);
d2790 1
a2790 1
uhci_remove_intr(sc, n, sqh)
a2791 1
	int n;
d2794 1
a2794 1
	struct uhci_vframe *vf = &sc->sc_vframes[n];
d2797 1
a2797 1
	DPRINTFN(4, ("uhci_remove_intr: n=%d sqh=%p\n", n, sqh));
d2799 1
a2799 9
	for (pqh = vf->hqh; pqh->hlink != sqh; pqh = pqh->hlink)
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
		if (LE(pqh->qh.qh_hlink) & UHCI_PTR_T) {
			DPRINTF(("uhci_remove_intr: QH not found\n"));
			return;
		}
#else
		;
#endif
a2846 1
	upipe->iinfo->stdstart = 0;
d2850 1
a2850 1
		sqh->qh.qh_elink = LE(UHCI_PTR_T);
a2851 1
		sqh->intr_info = upipe->iinfo;
a2855 4
	LIST_INSERT_HEAD(&sc->sc_intrhead, upipe->iinfo, list);
	splx(s);

	uhci_lock_frames(sc);
d2858 2
a2859 3
		uhci_add_intr(sc, upipe->u.intr.qhs[i]->pos, 
			      upipe->u.intr.qhs[i]);
	uhci_unlock_frames(sc);
d2879 4
a2894 3
		upipe->iinfo = uhci_alloc_intr_info(sc);
		if (upipe->iinfo == 0)
			return (USBD_NOMEM);
d2913 2
a2914 2
					 sizeof(usb_device_request_t), 
					 0, &upipe->u.ctl.reqdma);
a2941 1
	uhci_free_intr_info(upipe->iinfo);
d3039 3
a3041 2
	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
a3370 1
	xfer->hcpriv = 0;
d3400 2
a3401 2
	usb_untimeout(uhci_timo, xfer, xfer->timo_handle);
	sc->sc_has_timo = NULL;
d3408 3
d3446 2
a3447 2
	usb_timeout(uhci_timo, xfer, sc->sc_ival, xfer->timo_handle);
	sc->sc_has_timo = xfer;
d3458 2
a3459 2
	usb_untimeout(uhci_timo, pipe->intrxfer, pipe->intrxfer->timo_handle);
	sc->sc_has_timo = NULL;
a3461 1

@


1.8
log
@Fix an obvious typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.7 2000/03/26 08:39:45 aaron Exp $	*/
d62 1
a62 1
#if defined(DIAGNOSTIC) && defined(__i386)
d708 1
a708 1
	/* uhci_dump_sqh displays all the QHs and TDs from the given QH onwards
d1399 1
a1399 1
			return 0;
@


1.7
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
d260 1
a260 1
#define UWRITE1(sc, r, x) bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x))
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhci.c,v 1.62 1999/10/23 00:21:01 augustss Exp $	*/
a44 2
 * Data sheets: ftp://download.intel.com/design/intarch/datashts/29055002.pdf
 *              ftp://download.intel.com/design/intarch/datashts/29056201.pdf
d47 2
d57 1
d61 4
a67 1
#include <sys/select.h>
a68 3
#if defined(__FreeBSD__)
#include <machine/bus_pio.h>
#endif
d95 1
a95 1
#ifdef USB_DEBUG
d98 1
a98 1
extern int uhcidebug;
d153 1
d171 1
a171 1
					  int, int, int, usb_dma_t *, 
d175 1
a175 1
void		uhci_waitintr __P((uhci_softc_t *, usbd_request_handle));
d178 2
a179 2
void		uhci_abort_req __P((usbd_request_handle, usbd_status status));
void		uhci_abort_req_end __P((void *v));
d189 1
d191 1
a191 1
void		uhci_device_isoc_enter __P((usbd_request_handle));
d193 1
a193 1
void		uhci_wakeup_cb __P((usbd_request_handle reqh));
d198 6
a203 3
usbd_status	uhci_device_ctrl_transfer __P((usbd_request_handle));
usbd_status	uhci_device_ctrl_start __P((usbd_request_handle));
void		uhci_device_ctrl_abort __P((usbd_request_handle));
d205 1
a205 1
void		uhci_device_ctrl_done  __P((usbd_request_handle));
d207 3
a209 3
usbd_status	uhci_device_intr_transfer __P((usbd_request_handle));
usbd_status	uhci_device_intr_start __P((usbd_request_handle));
void		uhci_device_intr_abort __P((usbd_request_handle));
d211 1
a211 1
void		uhci_device_intr_done  __P((usbd_request_handle));
d213 3
a215 3
usbd_status	uhci_device_bulk_transfer __P((usbd_request_handle));
usbd_status	uhci_device_bulk_start __P((usbd_request_handle));
void		uhci_device_bulk_abort __P((usbd_request_handle));
d217 1
a217 1
void		uhci_device_bulk_done  __P((usbd_request_handle));
d219 3
a221 3
usbd_status	uhci_device_isoc_transfer __P((usbd_request_handle));
usbd_status	uhci_device_isoc_start __P((usbd_request_handle));
void		uhci_device_isoc_abort __P((usbd_request_handle));
d223 1
a223 1
void		uhci_device_isoc_done  __P((usbd_request_handle));
d225 3
a227 3
usbd_status	uhci_root_ctrl_transfer __P((usbd_request_handle));
usbd_status	uhci_root_ctrl_start __P((usbd_request_handle));
void		uhci_root_ctrl_abort __P((usbd_request_handle));
d229 1
d231 3
a233 3
usbd_status	uhci_root_intr_transfer __P((usbd_request_handle));
usbd_status	uhci_root_intr_start __P((usbd_request_handle));
void		uhci_root_intr_abort __P((usbd_request_handle));
d235 1
a235 1
void		uhci_root_intr_done  __P((usbd_request_handle));
d239 1
d241 1
a241 1
usbd_status	uhci_device_request __P((usbd_request_handle reqh));
d253 1
a253 1
void		uhci_dump_tds __P((uhci_soft_td_t *));
d256 1
d260 1
d278 1
d282 2
d292 1
a292 1
	0,
d353 1
a353 1
	usbd_status r;
d360 1
a360 1
#if defined(UHCI_DEBUG)
d371 1
a371 1
	r = usb_allocmem(&sc->sc_bus, 
d374 2
a375 2
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d382 1
a382 1
	if (!bsqh)
d390 1
a390 1
	if (!csqh)
d405 1
a405 1
		if (!std || !sqh)
d428 2
d437 2
d443 2
d448 1
d475 1
d485 12
a496 1
	/* free data structures XXX */
d500 1
d508 16
a523 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d525 1
a525 1
#endif
d527 8
a534 1
	return (usb_allocmem(&sc->sc_bus, size, 0, dma));
d538 1
a538 1
uhci_freem(bus, dma)
d540 1
a540 1
	usb_dma_t *dma;
a541 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a542 1
#endif
d544 14
a557 1
	usb_freemem(&sc->sc_bus, dma);
a559 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d583 1
a583 1
#if defined(UHCI_DEBUG)
d587 1
a587 1
		if (sc->sc_has_timo)
d592 5
a602 5
		/*
		 * XXX We should really do much more here in case the
		 * controller registers have been lost and BIOS has
		 * not restored them.
		 */
d611 6
d625 1
a625 1
		if (sc->sc_has_timo)
d628 1
a628 1
#if defined(UHCI_DEBUG)
a634 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d682 2
a683 2
uhci_dump_qh(p)
	uhci_soft_qh_t *p;
d685 2
a686 2
	DPRINTFN(-1,("QH(%p) at %08x: hlink=%08x elink=%08x\n", p, 
		    (int)p->physaddr, LE(p->qh.qh_hlink), LE(p->qh.qh_elink)));
a688 1

d703 31
d737 4
a740 1
	uhci_soft_td_t *p;
d742 8
a749 2
	for(p = std; p; p = p->link.std)
		uhci_dump_td(p);
d761 2
a762 2
	usbd_request_handle reqh = addr;
	usbd_pipe_handle pipe = reqh->pipe;
d767 1
a767 1
	DPRINTFN(15, ("uhci_timo\n"));
d769 1
a769 1
	usb_timeout(uhci_timo, reqh, sc->sc_ival, reqh->timo_handle);
d771 1
a771 1
	p = KERNADDR(&reqh->dmabuf);
d781 2
a782 2
	reqh->actlen = 1;
	reqh->status = USBD_NORMAL_COMPLETION;
d784 4
a787 4
	reqh->hcpriv = 0;
	reqh->device->bus->intr_context++;
	usb_transfer_complete(reqh);
	reqh->device->bus->intr_context--;
d792 8
a799 2
uhci_root_intr_done(reqh)
	usbd_request_handle reqh;
d809 2
a810 1
	while (sc->sc_vflock) {
d823 1
a957 1
	uhci_intr_info_t *ii;
d959 1
a959 1
#if defined(UHCI_DEBUG)
d986 1
a986 2
		printf("%s: host controller process error\n", 
		       USBDEVNAME(sc->sc_bus.bdev));
d990 2
a991 1
		printf("%s: host system error\n", USBDEVNAME(sc->sc_bus.bdev));
d997 1
d1005 17
a1022 1
	sc->sc_bus.no_intrs++;
a1037 2
	DPRINTFN(10, ("uhci_intr: exit\n"));

a1038 2

	return (1);
d1052 1
a1052 1
	if (!ii) {
d1057 1
a1057 1
	if (!ii->stdstart)
d1061 1
a1061 1
	if (!lstd) {
d1075 10
a1084 3
			if ((status & UHCI_TD_STALLED) ||
			     (status & (UHCI_TD_SPD | UHCI_TD_ACTIVE)) == 
			     UHCI_TD_SPD)
d1092 1
d1102 2
a1103 2
	usbd_request_handle reqh = ii->reqh;
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d1105 1
a1105 1
	u_int32_t status;
d1121 3
a1123 3
	if (reqh->status == USBD_CANCELLED ||
	    reqh->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_idone: aborted reqh=%p\n", reqh));
d1127 1
a1127 1
	if (reqh->nframes) {
d1134 1
a1134 1
		nframes = reqh->nframes;
d1136 1
a1136 1
		n = reqh->hcprivint;
d1151 4
a1154 4
		reqh->actlen = actlen;
		reqh->status = USBD_NORMAL_COMPLETION;
		reqh->hcpriv = ii;
		usb_transfer_complete(reqh);
d1159 2
a1160 1
	DPRINTFN(10, ("uhci_idone: ii=%p ready\n", ii));
d1168 3
a1170 3
	for (std = ii->stdstart; std; std = std->link.std) {
		status = LE(std->td.td_status);
		if (status & UHCI_TD_ACTIVE)
d1172 3
a1174 2
		if (UHCI_TD_GET_PID(LE(std->td.td_token)) != 
		    UHCI_TD_PID_SETUP)
d1178 1
a1178 1
	if (std)
d1184 1
a1184 1
	reqh->actlen = actlen;
d1186 1
a1186 1
		DPRINTFN(-1+((status&UHCI_TD_STALLED)!=0),
d1189 2
a1190 2
			  reqh->pipe->device->address,
			  reqh->pipe->endpoint->edesc->bEndpointAddress,
d1195 1
a1195 1
			reqh->status = USBD_STALLED;
d1197 1
a1197 1
			reqh->status = USBD_IOERROR; /* more info XXX */
d1199 1
a1199 1
		reqh->status = USBD_NORMAL_COMPLETION;
d1201 2
a1202 2
	reqh->hcpriv = ii;
	usb_transfer_complete(reqh);
d1216 8
a1223 3
	ii->reqh->device->bus->intr_context++;
	uhci_abort_req(ii->reqh, USBD_TIMEOUT);
	ii->reqh->device->bus->intr_context--;
d1233 1
a1233 1
uhci_waitintr(sc, reqh)
d1235 1
a1235 1
	usbd_request_handle reqh;
d1237 1
a1237 1
	int timo = reqh->timeout;
d1242 1
a1242 1
	reqh->status = USBD_IN_PROGRESS;
d1248 1
a1248 1
			if (reqh->status != USBD_IN_PROGRESS)
d1256 1
a1256 1
	     ii && ii->reqh != reqh; 
d1260 1
a1260 1
	if (!ii)
d1301 1
d1306 6
a1311 1
	UHCICMD(sc, run ? UHCI_CMD_RS : 0);
d1344 1
a1344 1
	usbd_status r;
d1348 1
a1348 1
	if (!sc->sc_freetds) {
d1350 1
a1350 1
		r = usb_allocmem(&sc->sc_bus, UHCI_STD_SIZE * UHCI_STD_CHUNK,
d1352 1
a1352 1
		if (r != USBD_NORMAL_COMPLETION)
d1375 1
a1375 1
	if (LE(std->td.td_token) == TD_IS_FREE) {
d1390 1
a1390 1
	usbd_status r;
d1394 1
a1394 1
	if (!sc->sc_freeqhs) {
d1396 1
a1396 1
		r = usb_allocmem(&sc->sc_bus, UHCI_SQH_SIZE * UHCI_SQH_CHUNK,
d1398 1
a1398 1
		if (r != USBD_NORMAL_COMPLETION)
d1454 1
a1454 1
uhci_alloc_std_chain(upipe, sc, len, rd, shortok, dma, sp, ep)
d1457 2
a1458 1
	int len, rd, shortok;
d1470 2
a1471 7
		      "shortok=%d\n", addr, UE_GET_ADDR(endpt), len, 
		      upipe->pipe.device->lowspeed, shortok));
	if (len == 0) {
		*sp = *ep = 0;
		DPRINTFN(-1,("uhci_alloc_std_chain: len=0\n"));
		return (USBD_NORMAL_COMPLETION);
	}
d1478 2
d1481 5
d1496 1
a1496 1
	if (shortok)
d1500 1
a1500 1
		if (!p) {
d1505 4
a1508 1
		p->td.td_link = LE(lastlink);
d1515 2
a1516 1
			if (l == 0) l = maxp;
d1547 2
a1548 2
uhci_device_bulk_transfer(reqh)
	usbd_request_handle reqh;
d1550 1
a1550 1
	usbd_status r;
d1553 3
a1555 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1557 4
a1560 2
	/* Pipe isn't running, start first */
	return (uhci_device_bulk_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d1564 2
a1565 2
uhci_device_bulk_start(reqh)
	usbd_request_handle reqh;
d1567 1
a1567 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d1573 1
a1573 1
	usbd_status r;
d1577 5
a1581 2
	DPRINTFN(3, ("uhci_device_bulk_transfer: reqh=%p len=%d flags=%d\n",
		     reqh, reqh->length, reqh->flags));
d1584 1
a1584 1
	if (reqh->rqflags & URQ_REQUEST)
d1588 2
a1589 2
	len = reqh->length;
	endpt = reqh->pipe->endpoint->edesc->bEndpointAddress;
d1596 4
a1599 5
	r = uhci_alloc_std_chain(upipe, sc, len, isread, 
				 reqh->flags & USBD_SHORT_XFER_OK,
				 &reqh->dmabuf, &data, &dataend);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1610 1
a1610 1
	ii->reqh = reqh;
d1617 3
d1631 2
a1632 2
	if (reqh->timeout && !sc->sc_bus.use_polling) {
		usb_timeout(uhci_timeout, ii, MS_TO_TICKS(reqh->timeout),
d1645 1
a1645 1
		uhci_waitintr(sc, reqh);
d1652 2
a1653 2
uhci_device_bulk_abort(reqh)
	usbd_request_handle reqh;
d1656 1
a1656 1
	uhci_abort_req(reqh, USBD_CANCELLED);
d1660 2
a1661 2
uhci_abort_req(reqh, status)
	usbd_request_handle reqh;
d1664 1
a1664 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d1668 2
d1671 1
a1671 1
	reqh->status = status;
d1680 1
a1680 1
	reqh->hcpriv = ii;
d1682 3
a1684 2
	/* make sure hardware has completed, */
	if (reqh->device->bus->intr_context) {
d1686 1
a1686 1
		timeout(uhci_abort_req_end, reqh, hz / USB_FRAMES_PER_SECOND);
d1688 5
a1692 1
		usb_delay_ms(reqh->pipe->device->bus, 1);
d1694 1
a1694 1
		uhci_abort_req_end(reqh);
d1696 4
d1703 1
a1703 1
uhci_abort_req_end(v)
d1706 1
a1706 1
	usbd_request_handle reqh = v;
d1710 1
a1710 1
	usb_transfer_complete(reqh);
d1725 1
a1725 1
	/* XXX free other resources */
d1729 2
a1730 2
uhci_device_ctrl_transfer(reqh)
	usbd_request_handle reqh;
d1732 1
a1732 1
	usbd_status r;
d1735 3
a1737 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1739 4
a1742 2
	/* Pipe isn't running, start first */
	return (uhci_device_ctrl_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d1746 2
a1747 2
uhci_device_ctrl_start(reqh)
	usbd_request_handle reqh;
d1749 5
a1753 2
	uhci_softc_t *sc = (uhci_softc_t *)reqh->pipe->device->bus;
	usbd_status r;
d1756 1
a1756 1
	if (!(reqh->rqflags & URQ_REQUEST))
d1760 3
a1762 3
	r = uhci_device_request(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1765 1
a1765 1
		uhci_waitintr(sc, reqh);
d1770 2
a1771 2
uhci_device_intr_transfer(reqh)
	usbd_request_handle reqh;
d1773 1
a1773 1
	usbd_status r;
d1776 3
a1778 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1780 4
a1783 2
	/* Pipe isn't running, start first */
	return (uhci_device_intr_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d1787 2
a1788 2
uhci_device_intr_start(reqh)
	usbd_request_handle reqh;
d1790 1
a1790 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d1796 1
a1796 1
	usbd_status r;
d1799 5
a1803 2
	DPRINTFN(3,("uhci_device_intr_transfer: reqh=%p len=%d flags=%d\n",
		    reqh, reqh->length, reqh->flags));
d1806 1
a1806 1
	if (reqh->rqflags & URQ_REQUEST)
d1810 4
a1813 5
	r = uhci_alloc_std_chain(upipe, sc, reqh->length, 1,
 				 reqh->flags & USBD_SHORT_XFER_OK,
				 &reqh->dmabuf, &data, &dataend);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1826 1
a1826 1
	ii->reqh = reqh;
d1833 3
d1861 2
a1862 2
uhci_device_ctrl_abort(reqh)
	usbd_request_handle reqh;
d1865 1
a1865 1
	uhci_abort_req(reqh, USBD_CANCELLED);
d1881 2
a1882 2
uhci_device_intr_abort(reqh)
	usbd_request_handle reqh;
d1884 2
a1885 2
	DPRINTFN(1,("uhci_device_intr_abort: reqh=%p\n", reqh));
	if (reqh->pipe->intrreqh == reqh) {
d1887 1
a1887 1
		reqh->pipe->intrreqh = 0;
d1889 1
a1889 1
	uhci_abort_req(reqh, USBD_CANCELLED);
d1930 2
a1931 2
uhci_device_request(reqh)
	usbd_request_handle reqh;
d1933 2
a1934 2
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
	usb_device_request_t *req = &reqh->request;
d1944 1
a1944 1
	usbd_status r;
d1965 4
a1968 5
		r = uhci_alloc_std_chain(upipe, sc, len, isread, 
					 reqh->flags & USBD_SHORT_XFER_OK,
					 &reqh->dmabuf, &data, &dataend);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d1971 1
a1971 1
		dataend->td.td_link = LE(stat->physaddr);
d1980 1
a1980 1
	setup->td.td_link = LE(next->physaddr);
d1995 1
a1995 1
	if (uhcidebug > 20) {
d2002 1
a2002 1
	ii->reqh = reqh;
d2009 3
d2036 4
a2039 2
		for (sxqh = xqh = (uhci_soft_qh_t *)std;
		     xqh;
a2042 1
			uhci_dump_qh(sxqh);
d2049 1
a2049 1
	if (reqh->timeout && !sc->sc_bus.use_polling) {
d2051 1
a2051 1
                            MS_TO_TICKS(reqh->timeout), ii->timeout_handle);
d2059 2
a2060 2
uhci_device_isoc_transfer(reqh)
	usbd_request_handle reqh;
d2062 1
a2062 1
	usbd_status r;
d2064 1
a2064 1
	DPRINTFN(5,("uhci_device_isoc_transfer: reqh=%p\n", reqh));
d2067 1
a2067 1
	r = usb_insert_transfer(reqh);
d2070 2
a2071 2
	if (r != USBD_NORMAL_COMPLETION && r != USBD_IN_PROGRESS)
		return (r);
d2076 1
a2076 1
	uhci_device_isoc_enter(reqh);
d2079 2
a2080 2
	if (r == USBD_NORMAL_COMPLETION)
		uhci_device_isoc_start(SIMPLEQ_FIRST(&reqh->pipe->queue));
d2082 1
a2082 1
	return (r);
d2086 2
a2087 2
uhci_device_isoc_enter(reqh)
	usbd_request_handle reqh;
d2089 1
a2089 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2097 1
a2097 1
	DPRINTFN(5,("uhci_device_isoc_enter: used=%d next=%d reqh=%p "
d2099 4
a2102 1
		    iso->inuse, iso->next, reqh, reqh->nframes));
d2104 1
a2104 1
	if (reqh->status == USBD_IN_PROGRESS) {
d2106 1
d2121 2
a2122 2
	reqh->status = USBD_IN_PROGRESS;
	reqh->hcprivint = next;
d2124 1
a2124 1
	buf = DMAADDR(&reqh->dmabuf);
d2128 1
a2128 1
	nframes = reqh->nframes;
d2134 1
a2134 1
		len = reqh->frlengths[i];
d2150 1
a2150 1
	iso->inuse += reqh->nframes;
d2156 2
a2157 2
uhci_device_isoc_start(reqh)
	usbd_request_handle reqh;
d2159 1
a2159 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2165 3
d2169 2
a2170 2
	if (reqh->status != USBD_IN_PROGRESS)
		printf("uhci_device_isoc_start: not in progress %p\n", reqh);
d2174 1
a2174 1
	i = reqh->hcprivint + reqh->nframes;
d2182 1
a2182 1
	ii->reqh = reqh;
d2189 3
d2202 2
a2203 2
uhci_device_isoc_abort(reqh)
	usbd_request_handle reqh;
d2205 1
a2205 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2212 1
a2212 1
	reqh->status = USBD_CANCELLED;
d2215 2
a2216 2
	nframes = reqh->nframes;
	n = reqh->hcprivint;
d2224 1
a2224 1
	reqh->hcpriv = ii;
d2227 1
a2227 1
	if (reqh->device->bus->intr_context) {
d2229 1
a2229 1
		timeout(uhci_abort_req_end, reqh, hz / USB_FRAMES_PER_SECOND);
d2231 1
a2231 1
		usb_delay_ms(reqh->pipe->device->bus, 1);
d2233 1
a2233 1
		uhci_abort_req_end(reqh);
d2264 1
a2264 1
		     vstd && vstd->link.std != std;
d2267 1
a2267 1
		if (!vstd) {
d2339 2
a2340 2
uhci_device_isoc_done(reqh)
	usbd_request_handle reqh;
d2342 1
a2342 1
	uhci_intr_info_t *ii = reqh->hcpriv;
d2344 1
a2344 1
	DPRINTFN(4, ("uhci_isoc_done: length=%d\n", reqh->actlen));
d2353 2
a2354 2
uhci_device_intr_done(reqh)
	usbd_request_handle reqh;
d2356 1
a2356 1
	uhci_intr_info_t *ii = reqh->hcpriv;
d2358 1
a2358 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2362 1
a2362 1
	DPRINTFN(5, ("uhci_intr_done: length=%d\n", reqh->actlen));
d2373 1
a2373 1
	if (reqh->pipe->repeat) {
d2377 2
a2378 3
		uhci_alloc_std_chain(upipe, sc, reqh->length, 1,
				     reqh->flags & USBD_SHORT_XFER_OK,
				     &reqh->dmabuf, &data, &dataend);
d2395 3
d2412 2
a2413 2
uhci_device_ctrl_done(reqh)
	usbd_request_handle reqh;
d2415 1
a2415 1
	uhci_intr_info_t *ii = reqh->hcpriv;
d2417 1
a2417 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2420 1
a2420 1
	if (!(reqh->rqflags & URQ_REQUEST))
d2431 1
a2431 1
	DPRINTFN(5, ("uhci_ctrl_done: length=%d\n", reqh->actlen));
d2436 2
a2437 2
uhci_device_bulk_done(reqh)
	usbd_request_handle reqh;
d2439 1
a2439 1
	uhci_intr_info_t *ii = reqh->hcpriv;
d2441 1
a2441 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)reqh->pipe;
d2449 1
a2449 1
	DPRINTFN(5, ("uhci_bulk_done: length=%d\n", reqh->actlen));
d2573 2
a2574 1
	usbd_status r;
d2598 1
a2598 1
			if (upipe->u.ctl.sqh == 0)
d2601 1
a2601 1
			if (upipe->u.ctl.setup == 0) {
d2606 1
a2606 1
			if (upipe->u.ctl.stat == 0) {
d2611 1
a2611 1
			r = usb_allocmem(&sc->sc_bus, 
d2614 1
a2614 1
			if (r != USBD_NORMAL_COMPLETION) {
d2623 4
a2626 1
			return (uhci_device_setintr(sc, upipe, ed->bInterval));
d2633 1
a2633 1
			if (upipe->u.bulk.sqh == 0)
d2652 2
a2653 2
	UCLASS_HUB,		/* class */
	USUBCLASS_HUB,		/* subclass */
d2680 2
a2681 2
	UCLASS_HUB,
	USUBCLASS_HUB,
d2729 2
a2730 2
uhci_root_ctrl_transfer(reqh)
	usbd_request_handle reqh;
d2732 1
a2732 1
	usbd_status r;
d2735 3
a2737 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d2739 4
a2742 2
	/* Pipe isn't running, start first */
	return (uhci_root_ctrl_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d2746 2
a2747 2
uhci_root_ctrl_start(reqh)
	usbd_request_handle reqh;
d2749 1
a2749 1
	uhci_softc_t *sc = (uhci_softc_t *)reqh->pipe->device->bus;
d2755 4
a2758 1
	usbd_status r;
d2761 1
a2761 1
	if (!(reqh->rqflags & URQ_REQUEST))
d2764 1
a2764 1
	req = &reqh->request;
d2774 1
a2774 1
		buf = KERNADDR(&reqh->dmabuf);
d2797 1
a2797 1
				r = USBD_IOERROR;
d2806 1
a2806 1
				r = USBD_IOERROR;
d2837 1
a2837 1
			r = USBD_IOERROR;
d2862 1
a2862 1
			r = USBD_IOERROR;
d2869 1
a2869 1
			r = USBD_IOERROR;
d2879 1
a2879 1
		r = USBD_IOERROR;
d2897 1
a2897 1
			r = USBD_IOERROR;
d2927 1
a2927 1
			r = USBD_NORMAL_COMPLETION;
d2935 1
a2935 1
			r = USBD_IOERROR;
d2945 1
a2945 1
			r = USBD_IOERROR;
d2957 1
a2957 1
			r = USBD_IOERROR;
d2966 1
a2966 1
			r = USBD_IOERROR;
d2978 1
a2978 1
			r = USBD_IOERROR;
d2982 1
a2982 1
			r = USBD_IOERROR;
d3013 1
a3013 1
		r = USBD_IOERROR;
d3023 1
a3023 1
			r = USBD_IOERROR;
d3058 1
a3058 1
			r = USBD_IOERROR;
d3063 1
a3063 1
		r = USBD_IOERROR;
d3066 2
a3067 2
	reqh->actlen = totlen;
	r = USBD_NORMAL_COMPLETION;
d3069 2
a3070 2
	reqh->status = r;
	reqh->hcpriv = 0;
d3072 1
a3072 1
	usb_transfer_complete(reqh);
d3079 2
a3080 2
uhci_root_ctrl_abort(reqh)
	usbd_request_handle reqh;
d3082 1
a3082 1
	/* Nothing to do, all transfers are syncronous. */
a3089 3
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;

	sc->sc_has_timo = 0;
d3095 2
a3096 2
uhci_root_intr_abort(reqh)
	usbd_request_handle reqh;
d3098 1
a3098 1
	uhci_softc_t *sc = (uhci_softc_t *)reqh->pipe->device->bus;
d3100 2
a3101 2
	usb_untimeout(uhci_timo, reqh, reqh->timo_handle);
	sc->sc_has_timo = 0;
d3103 1
a3103 1
	if (reqh->pipe->intrreqh == reqh) {
d3105 1
a3105 1
		reqh->pipe->intrreqh = 0;
d3107 2
a3108 2
	reqh->status = USBD_CANCELLED;
	usb_transfer_complete(reqh);
d3112 2
a3113 2
uhci_root_intr_transfer(reqh)
	usbd_request_handle reqh;
d3115 1
a3115 1
	usbd_status r;
d3118 3
a3120 3
	r = usb_insert_transfer(reqh);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d3122 4
a3125 2
	/* Pipe isn't running, start first */
	return (uhci_root_intr_start(SIMPLEQ_FIRST(&reqh->pipe->queue)));
d3130 2
a3131 2
uhci_root_intr_start(reqh)
	usbd_request_handle reqh;
d3133 1
a3133 1
	usbd_pipe_handle pipe = reqh->pipe;
d3136 5
a3140 2
	DPRINTFN(3, ("uhci_root_intr_transfer: reqh=%p len=%d flags=%d\n",
		     reqh, reqh->length, reqh->flags));
d3142 3
a3144 3
	sc->sc_ival = MS_TO_TICKS(reqh->pipe->endpoint->edesc->bInterval);
	usb_timeout(uhci_timo, reqh, sc->sc_ival, reqh->timo_handle);
	sc->sc_has_timo = reqh;
d3155 2
a3156 2
	usb_untimeout(uhci_timo, pipe->intrreqh, pipe->intrreqh->timo_handle);
	sc->sc_has_timo = 0;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: uhci.c,v 1.19 2001/03/25 04:26:58 csapuntz Exp $	*/
/*	$NetBSD: uhci.c,v 1.125 2000/09/23 21:00:10 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhci.c,v 1.33 1999/11/17 22:33:41 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d45 4
a48 4
 * UHCI spec: http://developer.intel.com/design/USB/UHCI11D.htm
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
 * PIIXn spec: ftp://download.intel.com/design/intarch/datashts/29055002.pdf
 *             ftp://download.intel.com/design/intarch/datashts/29056201.pdf
a56 1
#include <sys/select.h>
a59 4
#include <machine/bus_pio.h>
#if defined(DIAGNOSTIC) && defined(__i386__)
#include <machine/cpu.h>
#endif
d63 1
d65 3
a79 3
/* Use bandwidth reclamation for control transfers. Some devices choke on it. */
/*#define UHCI_CTL_LOOP */

d94 1
a94 2
#ifdef UHCI_DEBUG
uhci_softc_t *thesc;
d97 1
a97 5
int uhcidebug = 0;
int uhcinoloop = 0;
#ifndef __NetBSD__
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#endif
a106 1
#if defined(__FreeBSD__)
d108 1
a108 2
#define htole32(x) (bswap32(x))
#define le32toh(x) (bswap32(x))
d110 1
a110 3
#define htole32(x) (x)
#define le32toh(x) (x)
#endif
d115 1
a116 4

	u_char aborting;
	usbd_xfer_handle abortstart, abortend;

d145 15
a159 8
Static void		uhci_busreset(uhci_softc_t *);
Static void		uhci_shutdown(void *v);
Static void		uhci_power(int, void *);
Static usbd_status	uhci_run(uhci_softc_t *, int run);
Static uhci_soft_td_t  *uhci_alloc_std(uhci_softc_t *);
Static void		uhci_free_std(uhci_softc_t *, uhci_soft_td_t *);
Static uhci_soft_qh_t  *uhci_alloc_sqh(uhci_softc_t *);
Static void		uhci_free_sqh(uhci_softc_t *, uhci_soft_qh_t *);
d161 95
a255 112
Static void		uhci_enter_ctl_q(uhci_softc_t *, uhci_soft_qh_t *,
					 uhci_intr_info_t *);
Static void		uhci_exit_ctl_q(uhci_softc_t *, uhci_soft_qh_t *);
#endif

Static void		uhci_free_std_chain(uhci_softc_t *, 
					    uhci_soft_td_t *, uhci_soft_td_t *);
Static usbd_status	uhci_alloc_std_chain(struct uhci_pipe *,
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *, 
			    uhci_soft_td_t **, uhci_soft_td_t **);
Static void		uhci_poll_hub(void *);
Static void		uhci_waitintr(uhci_softc_t *, usbd_xfer_handle);
Static void		uhci_check_intr(uhci_softc_t *, uhci_intr_info_t *);
Static void		uhci_idone(uhci_intr_info_t *);

Static void		uhci_abort_xfer(usbd_xfer_handle, usbd_status status);

Static void		uhci_timeout(void *);
Static void		uhci_add_ls_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_add_hs_ctrl(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_add_bulk(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_remove_ls_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
Static void		uhci_remove_hs_ctrl(uhci_softc_t *,uhci_soft_qh_t *);
Static void		uhci_remove_bulk(uhci_softc_t *,uhci_soft_qh_t *);
Static int		uhci_str(usb_string_descriptor_t *, int, char *);
Static void		uhci_add_loop(uhci_softc_t *sc);
Static void		uhci_rem_loop(uhci_softc_t *sc);

Static usbd_status	uhci_setup_isoc(usbd_pipe_handle pipe);
Static void		uhci_device_isoc_enter(usbd_xfer_handle);

Static usbd_status	uhci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		uhci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	uhci_allocx(struct usbd_bus *);
Static void		uhci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	uhci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_ctrl_start(usbd_xfer_handle);
Static void		uhci_device_ctrl_abort(usbd_xfer_handle);
Static void		uhci_device_ctrl_close(usbd_pipe_handle);
Static void		uhci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	uhci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_intr_start(usbd_xfer_handle);
Static void		uhci_device_intr_abort(usbd_xfer_handle);
Static void		uhci_device_intr_close(usbd_pipe_handle);
Static void		uhci_device_intr_done(usbd_xfer_handle);

Static usbd_status	uhci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_bulk_start(usbd_xfer_handle);
Static void		uhci_device_bulk_abort(usbd_xfer_handle);
Static void		uhci_device_bulk_close(usbd_pipe_handle);
Static void		uhci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	uhci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	uhci_device_isoc_start(usbd_xfer_handle);
Static void		uhci_device_isoc_abort(usbd_xfer_handle);
Static void		uhci_device_isoc_close(usbd_pipe_handle);
Static void		uhci_device_isoc_done(usbd_xfer_handle);

Static usbd_status	uhci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	uhci_root_ctrl_start(usbd_xfer_handle);
Static void		uhci_root_ctrl_abort(usbd_xfer_handle);
Static void		uhci_root_ctrl_close(usbd_pipe_handle);
Static void		uhci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	uhci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	uhci_root_intr_start(usbd_xfer_handle);
Static void		uhci_root_intr_abort(usbd_xfer_handle);
Static void		uhci_root_intr_close(usbd_pipe_handle);
Static void		uhci_root_intr_done(usbd_xfer_handle);

Static usbd_status	uhci_open(usbd_pipe_handle);
Static void		uhci_poll(struct usbd_bus *);
Static void		uhci_softintr(struct usbd_bus *);

Static usbd_status	uhci_device_request(usbd_xfer_handle xfer);

Static void		uhci_add_intr(uhci_softc_t *, uhci_soft_qh_t *);
Static void		uhci_remove_intr(uhci_softc_t*, uhci_soft_qh_t*);
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc, 
			    struct uhci_pipe *pipe, int ival);

Static void		uhci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		uhci_noop(usbd_pipe_handle pipe);

Static __inline__ uhci_soft_qh_t *uhci_find_prev_qh(uhci_soft_qh_t *,
						    uhci_soft_qh_t *);

#ifdef UHCI_DEBUG
Static void		uhci_dump_all(uhci_softc_t *);
Static void		uhci_dumpregs(uhci_softc_t *);
Static void		uhci_dump_qhs(uhci_soft_qh_t *);
Static void		uhci_dump_qh(uhci_soft_qh_t *);
Static void		uhci_dump_tds(uhci_soft_td_t *);
Static void		uhci_dump_td(uhci_soft_td_t *);
Static void		uhci_dump_ii(uhci_intr_info_t *ii);
void			uhci_dump(void);
#endif

#define UBARR(sc) bus_space_barrier((sc)->iot, (sc)->ioh, 0, (sc)->sc_size, \
			BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE)
#define UWRITE1(sc, r, x) \
 do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define UWRITE2(sc, r, x) \
 do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define UWRITE4(sc, r, x) \
 do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); } while (0)
#define UREAD1(sc, r) (UBARR(sc), bus_space_read_1((sc)->iot, (sc)->ioh, (r)))
#define UREAD2(sc, r) (UBARR(sc), bus_space_read_2((sc)->iot, (sc)->ioh, (r)))
#define UREAD4(sc, r) (UBARR(sc), bus_space_read_4((sc)->iot, (sc)->ioh, (r)))
a267 1
	uhci_softintr,
a270 2
	uhci_allocx,
	uhci_freex,
d279 1
a279 1
	uhci_root_ctrl_done,
a326 21
#define uhci_add_intr_info(sc, ii) \
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ii), list);
#define uhci_del_intr_info(ii) \
	LIST_REMOVE((ii), list)

Static __inline__ uhci_soft_qh_t *
uhci_find_prev_qh(uhci_soft_qh_t *pqh, uhci_soft_qh_t *sqh)
{
	DPRINTFN(15,("uhci_find_prev_qh: pqh=%p sqh=%p\n", pqh, sqh));

	for (; pqh->hlink != sqh; pqh = pqh->hlink) {
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)		
		if (le32toh(pqh->qh.qh_hlink) & UHCI_PTR_T) {
			printf("uhci_find_prev_qh: QH not found\n");
			return (NULL);
		}
#endif
	}
	return (pqh);
}

d328 2
a329 1
uhci_busreset(uhci_softc_t *sc)
d337 2
a338 1
uhci_init(uhci_softc_t *sc)
d340 1
a340 1
	usbd_status err;
d342 1
a342 1
	uhci_soft_qh_t *clsqh, *chsqh, *bsqh, *sqh, *lsqh;
d347 1
a347 3
#ifdef UHCI_DEBUG
	thesc = sc;

d358 5
a362 5
	err = usb_allocmem(&sc->sc_bus, 
		  UHCI_FRAMELIST_COUNT * sizeof(uhci_physaddr_t),
		  UHCI_FRAMELIST_ALIGN, &sc->sc_dma);
	if (err)
		return (err);
a366 24
	/* 
	 * Allocate a TD, inactive, that hangs from the last QH.
	 * This is to avoid a bug in the PIIX that makes it run berserk
	 * otherwise.
	 */
	std = uhci_alloc_std(sc);
	if (std == NULL)
		return (USBD_NOMEM);
	std->link.std = NULL;
	std->td.td_link = htole32(UHCI_PTR_T);
	std->td.td_status = htole32(0); /* inactive */
	std->td.td_token = htole32(0);
	std->td.td_buffer = htole32(0);

	/* Allocate the dummy QH marking the end and used for looping the QHs.*/
	lsqh = uhci_alloc_sqh(sc);
	if (lsqh == NULL)
		return (USBD_NOMEM);
	lsqh->hlink = NULL;
	lsqh->qh.qh_hlink = htole32(UHCI_PTR_T);	/* end of QH chain */
	lsqh->elink = std;
	lsqh->qh.qh_elink = htole32(std->physaddr | UHCI_PTR_TD);
	sc->sc_last_qh = lsqh;

d369 1
a369 1
	if (bsqh == NULL)
d371 2
a372 4
	bsqh->hlink = lsqh;
	bsqh->qh.qh_hlink = htole32(lsqh->physaddr | UHCI_PTR_QH);
	bsqh->elink = NULL;
	bsqh->qh.qh_elink = htole32(UHCI_PTR_T);
d375 3
a377 13
	/* Allocate dummy QH where high speed control traffic will be queued. */
	chsqh = uhci_alloc_sqh(sc);
	if (chsqh == NULL)
		return (USBD_NOMEM);
	chsqh->hlink = bsqh;
	chsqh->qh.qh_hlink = htole32(bsqh->physaddr | UHCI_PTR_QH);
	chsqh->elink = NULL;
	chsqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_hctl_start = sc->sc_hctl_end = chsqh;

	/* Allocate dummy QH where control traffic will be queued. */
	clsqh = uhci_alloc_sqh(sc);
	if (clsqh == NULL)
d379 4
a382 5
	clsqh->hlink = bsqh;
	clsqh->qh.qh_hlink = htole32(chsqh->physaddr | UHCI_PTR_QH);
	clsqh->elink = NULL;
	clsqh->qh.qh_elink = htole32(UHCI_PTR_T);
	sc->sc_lctl_start = sc->sc_lctl_end = clsqh;
d392 1
a392 1
		if (std == NULL || sqh == NULL)
d395 8
a402 8
		std->td.td_link = htole32(sqh->physaddr | UHCI_PTR_QH);
		std->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */
		std->td.td_token = htole32(0);
		std->td.td_buffer = htole32(0);
		sqh->hlink = clsqh;
		sqh->qh.qh_hlink = htole32(clsqh->physaddr | UHCI_PTR_QH);
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
d410 1
a410 1
			sc->sc_pframes[j] = htole32(std->physaddr);
a414 4
	SIMPLEQ_INIT(&sc->sc_free_xfers);

	usb_callout_init(sc->sc_poll_handle);

a418 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a420 2
	sc->sc_shutdownhook = shutdownhook_establish(uhci_shutdown, sc);
#endif
a425 2
	UHCICMD(sc, UHCI_CMD_MAXP); /* Assume 64 byte packets at frame end */

a428 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d430 3
a432 1
uhci_activate(device_ptr_t self, enum devact act)
d451 3
a453 1
uhci_detach(struct uhci_softc *sc, int flags)
a454 1
	usbd_xfer_handle xfer;
a462 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d464 1
a464 13
	shutdownhook_disestablish(sc->sc_shutdownhook);
#endif

	/* Free all xfers associated with this HC. */
	for (;;) {
		xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
		if (xfer == NULL)
			break;
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
		free(xfer, M_USB);
	}			

	/* XXX free other data structures XXX */
a467 1
#endif
d470 4
a473 1
uhci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
d475 1
d477 1
a477 23
	u_int32_t n;

	/* 
	 * XXX
	 * Since we are allocating a buffer we can assume that we will
	 * need TDs for it.  Since we don't want to alolocate those from
	 * an interrupt context, we allocate them here and free them again.
	 * This is no guarantee that we'll get the TDs next time...
	 */
	n = size / 8;
	if (n > 16) {
		u_int32_t i;
		uhci_soft_td_t **stds;
		DPRINTF(("uhci_allocm: get %d TDs\n", n));
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP, M_NOWAIT);
		memset(stds, 0, sizeof(uhci_soft_td_t *) * n);
		for(i=0; i < n; i++)
			stds[i] = uhci_alloc_std(sc);
		for(i=0; i < n; i++)
			if (stds[i] != NULL)
				uhci_free_std(sc, stds[i]);
		free(stds, M_TEMP);
	}
d483 3
a485 7
uhci_freem(struct usbd_bus *bus, usb_dma_t *dma)
{
	usb_freemem(&((struct uhci_softc *)bus)->sc_bus, dma);
}

usbd_xfer_handle
uhci_allocx(struct usbd_bus *bus)
d487 1
a488 10
	usbd_xfer_handle xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
#ifdef DIAGNOSTIC
		if (xfer->busy_free != XFER_FREE) {
			printf("uhci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
a489 13
	} else {
		xfer = malloc(sizeof(struct uhci_xfer), M_USB, M_NOWAIT);
	}
	if (xfer != NULL) {
		memset(xfer, 0, sizeof (struct uhci_xfer));
		UXFER(xfer)->iinfo.sc = sc;
#ifdef DIAGNOSTIC
		UXFER(xfer)->iinfo.isdone = 1;
		xfer->busy_free = XFER_BUSY;
#endif
	}
	return (xfer);
}
d491 1
a491 30
void
uhci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
{
	struct uhci_softc *sc = (struct uhci_softc *)bus;

#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("uhci_freex: xfer=%p not busy, 0x%08x\n", xfer,
		       xfer->busy_free);
		return;
	}
	xfer->busy_free = XFER_FREE;
	if (!UXFER(xfer)->iinfo.isdone) {
		printf("uhci_freex: !isdone\n");
		return;
	}
#endif
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

/*
 * Shut down the controller when the system is going down.
 */
void
uhci_shutdown(void *v)
{
	uhci_softc_t *sc = v;

	DPRINTF(("uhci_shutdown: stopping the HC\n"));
	uhci_run(sc, 0); /* stop the controller */
d494 1
d499 1
a499 1
 * called from an interrupt context.  This is all right since we
d503 3
a505 1
uhci_power(int why, void *v)
d517 2
a518 4
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
#ifdef UHCI_DEBUG
d522 3
a524 3
		if (sc->sc_intr_xfer != NULL)
			usb_uncallout(sc->sc_poll_handle, uhci_poll_hub,
			    sc->sc_intr_xfer);
a526 5

		/* save some state if BIOS doesn't */
		sc->sc_saved_frnum = UREAD2(sc, UHCI_FRNUM);
		sc->sc_saved_sof = UREAD1(sc, UHCI_SOF);

d532 6
a537 2
		break;
	case PWR_RESUME:
a545 6

		/* restore saved state */
		UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma));
		UWRITE2(sc, UHCI_FRNUM, sc->sc_saved_frnum);
		UWRITE1(sc, UHCI_SOF, sc->sc_saved_sof);

d554 4
a557 4
		if (sc->sc_intr_xfer != NULL)
			usb_callout(sc->sc_poll_handle, sc->sc_ival,
				    uhci_poll_hub, sc->sc_intr_xfer);
#ifdef UHCI_DEBUG
a560 7
		break;
#if defined(__NetBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
d564 1
d567 3
a569 2
Static void
uhci_dumpregs(uhci_softc_t *sc)
d585 2
a586 1
uhci_dump_td(uhci_soft_td_t *p)
a587 2
	char sbuf[128], sbuf2[128];

d591 18
a608 21
		     (long)le32toh(p->td.td_link),
		     (long)le32toh(p->td.td_status),
		     (long)le32toh(p->td.td_token),
		     (long)le32toh(p->td.td_buffer)));

	bitmask_snprintf((int)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
			 sbuf, sizeof(sbuf));
	bitmask_snprintf((int)le32toh(p->td.td_status),
			 "\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
			 "STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD",
			 sbuf2, sizeof(sbuf2));

	DPRINTFN(-1,("  %s %s,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
		     "D=%d,maxlen=%d\n", sbuf, sbuf2,
		     UHCI_TD_GET_ERRCNT(le32toh(p->td.td_status)),
		     UHCI_TD_GET_ACTLEN(le32toh(p->td.td_status)),
		     UHCI_TD_GET_PID(le32toh(p->td.td_token)),
		     UHCI_TD_GET_DEVADDR(le32toh(p->td.td_token)),
		     UHCI_TD_GET_ENDPT(le32toh(p->td.td_token)),
		     UHCI_TD_GET_DT(le32toh(p->td.td_token)),
		     UHCI_TD_GET_MAXLEN(le32toh(p->td.td_token))));
d612 2
a613 1
uhci_dump_qh(uhci_soft_qh_t *sqh)
d615 2
a616 3
	DPRINTFN(-1,("QH(%p) at %08x: hlink=%08x elink=%08x\n", sqh,
	    (int)sqh->physaddr, le32toh(sqh->qh.qh_hlink),
	    le32toh(sqh->qh.qh_elink)));
d620 1
a620 1
#if 1
d622 1
a622 1
uhci_dump(void)
d624 1
a624 3
	uhci_dump_all(thesc);
}
#endif
a625 3
void
uhci_dump_all(uhci_softc_t *sc)
{
d628 2
a629 34
	/*printf("framelist[i].link = %08x\n", sc->sc_framelist[0].link);*/
	uhci_dump_qh(sc->sc_lctl_start);
}


void
uhci_dump_qhs(uhci_soft_qh_t *sqh)
{
	uhci_dump_qh(sqh);

	/* uhci_dump_qhs displays all the QHs and TDs from the given QH onwards
	 * Traverses sideways first, then down.
	 *
	 * QH1
	 * QH2
	 * No QH
	 * TD2.1
	 * TD2.2
	 * TD1.1
	 * etc.
	 *
	 * TD2.x being the TDs queued at QH2 and QH1 being referenced from QH1.
	 */


	if (sqh->hlink != NULL && !(le32toh(sqh->qh.qh_hlink) & UHCI_PTR_T))
		uhci_dump_qhs(sqh->hlink);
	else
		DPRINTF(("No QH\n"));

	if (sqh->elink != NULL && !(le32toh(sqh->qh.qh_elink) & UHCI_PTR_T))
		uhci_dump_tds(sqh->elink);
	else
		DPRINTF(("No TD\n"));
a630 31

void
uhci_dump_tds(uhci_soft_td_t *std)
{
	uhci_soft_td_t *td;

	for(td = std; td != NULL; td = td->link.std) {
		uhci_dump_td(td);

		/* Check whether the link pointer in this TD marks
		 * the link pointer as end of queue. This avoids
		 * printing the free list in case the queue/TD has
		 * already been moved there (seatbelt).
		 */
		if (le32toh(td->td.td_link) & UHCI_PTR_T ||
		    le32toh(td->td.td_link) == 0)
			break;
	}
}

Static void
uhci_dump_ii(uhci_intr_info_t *ii)
{
	usbd_pipe_handle pipe;
	usb_endpoint_descriptor_t *ed;
	usbd_device_handle dev;
	
#ifdef DIAGNOSTIC
#define DONE ii->isdone
#else
#define DONE 0
a631 25
        if (ii == NULL) {
                printf("ii NULL\n");
                return;
        }
        if (ii->xfer == NULL) {
		printf("ii %p: done=%d xfer=NULL\n",
		       ii, DONE);
                return;
        }
        pipe = ii->xfer->pipe;
        if (pipe == NULL) {
		printf("ii %p: done=%d xfer=%p pipe=NULL\n",
		       ii, DONE, ii->xfer);
                return;
	}
        ed = pipe->endpoint->edesc;
        dev = pipe->device;
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n", 
	       ii, DONE, ii->xfer, dev, 
	       UGETW(dev->ddesc.idVendor),
	       UGETW(dev->ddesc.idProduct),
	       dev->address, pipe,
	       ed->bEndpointAddress, ed->bmAttributes);
#undef DONE
}
a632 1
void uhci_dump_iis(struct uhci_softc *sc);
d634 2
a635 1
uhci_dump_iis(struct uhci_softc *sc)
d637 1
a637 1
	uhci_intr_info_t *ii;
d639 2
a640 3
	printf("intr_info list:\n");
	for (ii = LIST_FIRST(&sc->sc_intrhead); ii; ii = LIST_NEXT(ii, list))
		uhci_dump_ii(ii);
a641 4

void iidump(void);
void iidump(void) { uhci_dump_iis(thesc); }

d649 2
a650 1
uhci_poll_hub(void *addr)
d652 2
a653 2
	usbd_xfer_handle xfer = addr;
	usbd_pipe_handle pipe = xfer->pipe;
d658 1
a658 1
	DPRINTFN(20, ("uhci_poll_hub\n"));
d660 1
a660 1
	usb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);
d662 1
a662 1
	p = KERNADDR(&xfer->dmabuf);
d672 2
a673 2
	xfer->actlen = 1;
	xfer->status = USBD_NORMAL_COMPLETION;
d675 4
a678 3
	xfer->device->bus->intr_context++;
	usb_transfer_complete(xfer);
	xfer->device->bus->intr_context--;
d683 2
a684 1
uhci_root_intr_done(usbd_xfer_handle xfer)
d688 1
d690 2
a691 1
uhci_root_ctrl_done(usbd_xfer_handle xfer)
d693 4
a696 19
}

/*
 * Let the last QH loop back to the high speed control transfer QH.
 * This is what intel calls "bandwidth reclamation" and improves
 * USB performance a lot for some devices.
 * If we are already looping, just count it.
 */
void
uhci_add_loop(uhci_softc_t *sc) {
#ifdef UHCI_DEBUG
	if (uhcinoloop)
		return;
#endif
	if (++sc->sc_loops == 1) {
		DPRINTFN(5,("uhci_start_loop: add\n"));
		/* Note, we don't loop back the soft pointer. */
		sc->sc_last_qh->qh.qh_hlink = 
		    htole32(sc->sc_hctl_start->physaddr | UHCI_PTR_QH);
d698 2
d703 8
a710 9
uhci_rem_loop(uhci_softc_t *sc) {
#ifdef UHCI_DEBUG
	if (uhcinoloop)
		return;
#endif
	if (--sc->sc_loops == 0) {
		DPRINTFN(5,("uhci_end_loop: remove\n"));
		sc->sc_last_qh->qh.qh_hlink = htole32(UHCI_PTR_T);
	}
d713 7
a719 3
/* Add high speed control QH, called at splusb(). */
void
uhci_add_hs_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d721 1
a721 1
	uhci_soft_qh_t *eqh;
d723 10
a732 1
	SPLUSBCHECK;
d734 1
a734 10
	DPRINTFN(10, ("uhci_add_ctrl: sqh=%p\n", sqh));
	eqh = sc->sc_hctl_end;
	sqh->hlink       = eqh->hlink;
	sqh->qh.qh_hlink = eqh->qh.qh_hlink;
	eqh->hlink       = sqh;
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	sc->sc_hctl_end = sqh;
#ifdef UHCI_CTL_LOOP
	uhci_add_loop(sc);
#endif
a736 1
/* Remove high speed control QH, called at splusb(). */
d738 2
a739 1
uhci_remove_hs_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d741 1
a741 27
	uhci_soft_qh_t *pqh;

	SPLUSBCHECK;

	DPRINTFN(10, ("uhci_remove_hs_ctrl: sqh=%p\n", sqh));
#ifdef UHCI_CTL_LOOP
	uhci_rem_loop(sc);
#endif
	/*
	 * The T bit should be set in the elink of the QH so that the HC
	 * doesn't follow the pointer.  This condition may fail if the
	 * the transferred packet was short so that the QH still points
	 * at the last used TD.
	 * In this case we set the T bit and wait a little for the HC
	 * to stop looking at the TD.
	 */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}

	pqh = uhci_find_prev_qh(sc->sc_hctl_start, sqh);
	pqh->hlink       = sqh->hlink;
	pqh->qh.qh_hlink = sqh->qh.qh_hlink;
	delay(UHCI_QH_REMOVE_DELAY);
	if (sc->sc_hctl_end == sqh)
		sc->sc_hctl_end = pqh;
d744 1
a744 1
/* Add low speed control QH, called at splusb(). */
d746 3
a748 1
uhci_add_ls_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d754 2
a755 2
	DPRINTFN(10, ("uhci_add_ls_ctrl: sqh=%p\n", sqh));
	eqh = sc->sc_lctl_end;
d759 2
a760 2
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
	sc->sc_lctl_end = sqh;
d763 1
a763 1
/* Remove low speed control QH, called at splusb(). */
d765 3
a767 1
uhci_remove_ls_ctrl(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d773 10
a782 7
	DPRINTFN(10, ("uhci_remove_ls_ctrl: sqh=%p\n", sqh));
	/* See comment in uhci_remove_hs_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}
	pqh = uhci_find_prev_qh(sc->sc_lctl_start, sqh);
d785 2
a786 3
	delay(UHCI_QH_REMOVE_DELAY);
	if (sc->sc_lctl_end == sqh)
		sc->sc_lctl_end = pqh;
d791 3
a793 1
uhci_add_bulk(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d804 1
a804 1
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
a805 1
	uhci_add_loop(sc);
d810 3
a812 1
uhci_remove_bulk(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d819 9
a827 7
	uhci_rem_loop(sc);
	/* See comment in uhci_remove_hs_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}
	pqh = uhci_find_prev_qh(sc->sc_bulk_start, sqh);
a829 1
	delay(UHCI_QH_REMOVE_DELAY);
d835 2
a836 1
uhci_intr(void *arg)
d841 1
d843 1
a843 1
#ifdef UHCI_DEBUG
d854 1
a854 7
	if (sc->sc_suspend != PWR_RESUME) {
		printf("%s: interrupt while not operating ignored\n",
		       USBDEVNAME(sc->sc_bus.bdev));
		return (0);
	}

#if defined(DIAGNOSTIC) && defined(__NetBSD__)
a865 1
#ifdef UHCI_DEBUG
a866 1
#endif
d870 2
a871 1
		printf("%s: host system error\n", USBDEVNAME(sc->sc_bus.bdev));
d875 1
a875 2
		printf("%s: host controller process error\n", 
		       USBDEVNAME(sc->sc_bus.bdev));
d879 2
a880 8
		if (!sc->sc_dying)
			printf("%s: host controller halted\n", 
			    USBDEVNAME(sc->sc_bus.bdev));
		sc->sc_dying = 1;
#ifdef UHCI_DEBUG
		uhci_dump_all(sc);
#endif

d888 1
a889 16
	usb_schedsoftintr(&sc->sc_bus);

	DPRINTFN(10, ("%s: uhci_intr: exit\n", USBDEVNAME(sc->sc_bus.bdev)));

	return (1);
}

void
uhci_softintr(struct usbd_bus *bus)
{
	uhci_softc_t *sc = (uhci_softc_t *)bus;
	uhci_intr_info_t *ii;

	DPRINTFN(10,("%s: uhci_softintr\n", USBDEVNAME(sc->sc_bus.bdev)));

	sc->sc_bus.intr_context++;
d905 2
d908 2
d914 3
a916 1
uhci_check_intr(uhci_softc_t *sc, uhci_intr_info_t *ii)
d923 1
a923 1
	if (ii == NULL) {
d928 1
a928 1
	if (ii->stdstart == NULL)
d932 1
a932 1
	if (lstd == NULL) {
d942 2
a943 2
	if (le32toh(lstd->td.td_status) & UHCI_TD_ACTIVE) {
		DPRINTFN(12, ("uhci_check_intr: active ii=%p\n", ii));
d945 4
a948 11
			status = le32toh(std->td.td_status);
			/* If there's an active TD the xfer isn't done. */
			if (status & UHCI_TD_ACTIVE)
				break;
			/* Any kind of error makes the xfer done. */
			if (status & UHCI_TD_STALLED)
				goto done;
			/* We want short packets, and it is short: it's done */
			if ((status & UHCI_TD_SPD) &&
			      UHCI_TD_GET_ACTLEN(status) < 
			      UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token)))
d951 1
a951 1
		DPRINTFN(12, ("uhci_check_intr: ii=%p std=%p still active\n",
d956 1
a956 2
	DPRINTFN(12, ("uhci_check_intr: ii=%p done\n", ii));
	usb_uncallout(ii->xfer->timeout_handle, uhci_timeout, ii);
d962 2
a963 1
uhci_idone(uhci_intr_info_t *ii)
d965 2
a966 2
	usbd_xfer_handle xfer = ii->xfer;
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d968 1
a968 1
	u_int32_t status = 0, nstatus;
a975 4
#ifdef UHCI_DEBUG
			printf("uhci_idone: ii is done!\n   ");
			uhci_dump_ii(ii);
#else
a976 1
#endif
d984 3
a986 3
	if (xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_idone: aborted xfer=%p\n", xfer));
d990 1
a990 1
	if (xfer->nframes != 0) {
d993 1
a993 1
		int i, n, nframes, len;
d997 1
a997 1
		nframes = xfer->nframes;
d999 1
a999 1
		n = UXFER(xfer)->curframe;
d1010 2
a1011 4
			status = le32toh(std->td.td_status);
			len = UHCI_TD_GET_ACTLEN(status);
			xfer->frlengths[i] = len;
			actlen += len;
d1014 4
a1017 3
		xfer->actlen = actlen;
		xfer->status = USBD_NORMAL_COMPLETION;
		usb_transfer_complete(xfer);
d1022 1
a1022 2
	DPRINTFN(10, ("uhci_idone: ii=%p, xfer=%p, pipe=%p ready\n",
		      ii, xfer, upipe));
d1028 1
d1030 3
a1032 3
	for (std = ii->stdstart; std != NULL; std = std->link.std) {
		nstatus = le32toh(std->td.td_status);
		if (nstatus & UHCI_TD_ACTIVE)
d1034 2
a1035 4

		status = nstatus;
		if (UHCI_TD_GET_PID(le32toh(std->td.td_token)) !=
			UHCI_TD_PID_SETUP)
d1039 2
a1040 2
	if (std != NULL)
		upipe->nexttoggle = UHCI_TD_GET_DT(le32toh(std->td.td_token));
d1045 1
a1045 1
	xfer->actlen = actlen;
d1047 1
a1047 8
#ifdef UHCI_DEBUG
		char sbuf[128];

		bitmask_snprintf((int)status, "\20\22BITSTUFF\23CRCTO\24NAK\25"
				 "BABBLE\26DBUFFER\27STALLED\30ACTIVE",
				 sbuf, sizeof(sbuf));

		DPRINTFN((status == UHCI_TD_STALLED)*10,
d1049 6
a1054 6
			  "status 0x%s\n",
			  xfer->pipe->device->address,
			  xfer->pipe->endpoint->edesc->bEndpointAddress,
			  sbuf));
#endif

d1056 1
a1056 1
			xfer->status = USBD_STALLED;
d1058 1
a1058 1
			xfer->status = USBD_IOERROR; /* more info XXX */
d1060 1
a1060 1
		xfer->status = USBD_NORMAL_COMPLETION;
d1062 2
a1063 1
	usb_transfer_complete(xfer);
d1070 2
a1071 1
uhci_timeout(void *addr)
d1077 3
a1079 8
#ifdef UHCI_DEBUG
	if (uhcidebug > 10)
		uhci_dump_tds(ii->stdstart);
#endif

	ii->xfer->device->bus->intr_context++;
	uhci_abort_xfer(ii->xfer, USBD_TIMEOUT);
	ii->xfer->device->bus->intr_context--;
d1089 3
a1091 1
uhci_waitintr(uhci_softc_t *sc, usbd_xfer_handle xfer)
d1093 1
a1093 1
	int timo = xfer->timeout;
d1098 1
a1098 1
	xfer->status = USBD_IN_PROGRESS;
d1104 1
a1104 1
			if (xfer->status != USBD_IN_PROGRESS)
d1112 1
a1112 1
	     ii != NULL && ii->xfer != xfer; 
d1116 1
a1116 1
	if (ii == NULL)
d1123 2
a1124 1
uhci_poll(struct usbd_bus *bus)
d1134 2
a1135 1
uhci_reset(uhci_softc_t *sc)
d1137 1
d1144 1
a1144 1
		usb_delay_ms(&sc->sc_bus, 1);
d1152 3
a1154 1
uhci_run(uhci_softc_t *sc, int run)
a1156 1
	u_int16_t cmd;
d1161 1
a1161 6
	cmd = UREAD2(sc, UHCI_CMD);
	if (run)
		cmd |= UHCI_CMD_RS;
	else
		cmd &= ~UHCI_CMD_RS;
	UHCICMD(sc, cmd);
d1190 2
a1191 1
uhci_alloc_std(uhci_softc_t *sc)
d1194 1
a1194 1
	usbd_status err;
d1198 1
a1198 1
	if (sc->sc_freetds == NULL) {
d1200 3
a1202 3
		err = usb_allocmem(&sc->sc_bus, UHCI_STD_SIZE * UHCI_STD_CHUNK,
			  UHCI_TD_ALIGN, &dma);
		if (err)
d1219 3
a1221 1
uhci_free_std(uhci_softc_t *sc, uhci_soft_td_t *std)
d1225 1
a1225 1
	if (le32toh(std->td.td_token) == TD_IS_FREE) {
d1229 1
a1229 1
	std->td.td_token = htole32(TD_IS_FREE);
d1236 2
a1237 1
uhci_alloc_sqh(uhci_softc_t *sc)
d1240 1
a1240 1
	usbd_status err;
d1244 1
a1244 1
	if (sc->sc_freeqhs == NULL) {
d1246 4
a1249 4
		err = usb_allocmem(&sc->sc_bus, UHCI_SQH_SIZE * UHCI_SQH_CHUNK,
			  UHCI_QH_ALIGN, &dma);
		if (err)
			return (0);
d1265 3
a1267 1
uhci_free_sqh(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d1273 16
d1290 4
a1293 2
uhci_free_std_chain(uhci_softc_t *sc, uhci_soft_td_t *std,
		    uhci_soft_td_t *stdend)
d1304 6
a1309 3
uhci_alloc_std_chain(struct uhci_pipe *upipe, uhci_softc_t *sc, int len,
		     int rd, u_int16_t flags, usb_dma_t *dma,
		     uhci_soft_td_t **sp, uhci_soft_td_t **ep)
d1319 7
a1325 2
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len, 
		      upipe->pipe.device->lowspeed, flags));
a1331 2
	if ((flags & USBD_FORCE_SHORT_XFER) && len % maxp == 0)
		ntd++;
a1332 5
	if (ntd == 0) {
		*sp = *ep = 0;
		DPRINTFN(-1,("uhci_alloc_std_chain: ntd=0\n"));
		return (USBD_NORMAL_COMPLETION);
	}
d1337 1
a1337 1
	lastp = NULL;
d1343 1
a1343 1
	if (flags & USBD_SHORT_XFER_OK)
d1347 1
a1347 1
		if (p == NULL) {
d1352 1
a1352 1
		p->td.td_link = htole32(lastlink | UHCI_PTR_VF | UHCI_PTR_TD);
d1355 1
a1355 1
		p->td.td_status = htole32(status);
d1359 1
a1359 2
			if (l == 0 && !(flags & USBD_FORCE_SHORT_XFER))
				l = maxp;
d1364 3
a1366 3
		    htole32(rd ? UHCI_TD_IN (l, endpt, addr, tog) :
				 UHCI_TD_OUT(l, endpt, addr, tog));
		p->td.td_buffer = htole32(DMAADDR(dma) + i * maxp);
d1376 2
a1377 1
uhci_device_clear_toggle(usbd_pipe_handle pipe)
d1384 2
a1385 1
uhci_noop(usbd_pipe_handle pipe)
d1390 2
a1391 1
uhci_device_bulk_transfer(usbd_xfer_handle xfer)
d1393 1
a1393 1
	usbd_status err;
d1396 3
a1398 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d1400 2
a1401 5
	/* 
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d1405 2
a1406 1
uhci_device_bulk_start(usbd_xfer_handle xfer)
d1408 1
a1408 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d1411 1
a1411 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d1414 1
a1414 1
	usbd_status err;
d1418 2
a1419 5
	DPRINTFN(3, ("uhci_device_bulk_transfer: xfer=%p len=%d flags=%d\n",
		     xfer, xfer->length, xfer->flags));

	if (sc->sc_dying)
		return (USBD_IOERROR);
d1422 1
a1422 1
	if (xfer->rqflags & URQ_REQUEST)
d1426 2
a1427 2
	len = xfer->length;
	endpt = upipe->pipe.endpoint->edesc->bEndpointAddress;
d1434 6
a1439 5
	err = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,
				   &xfer->dmabuf, &data, &dataend);
	if (err)
		return (err);
	dataend->td.td_status |= htole32(UHCI_TD_IOC);
d1449 1
a1449 1
	ii->xfer = xfer;
d1452 3
a1455 3
	if (!ii->isdone) {
		printf("uhci_device_bulk_transfer: not done, ii=%p\n", ii);
	}
d1460 2
a1461 1
	sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);
d1465 1
a1465 1
	uhci_add_intr_info(sc, ii);
d1467 3
a1469 3
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    uhci_timeout, ii);
a1470 1
	xfer->status = USBD_IN_PROGRESS;
d1481 1
a1481 1
		uhci_waitintr(sc, xfer);
d1488 2
a1489 1
uhci_device_bulk_abort(usbd_xfer_handle xfer)
d1492 1
a1492 1
	uhci_abort_xfer(xfer, USBD_CANCELLED);
a1494 5
/*
 * XXX This way of aborting is neither safe, nor good.
 * But it will have to do until I figure out what to do.
 * I apologize for the delay().
 */
d1496 3
a1498 1
uhci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d1500 2
a1501 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
a1502 12
	int s;

	DPRINTFN(1,("uhci_abort_xfer: xfer=%p, status=%d\n", xfer, status));

	s = splusb();

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED && 
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
		return;
	}
d1505 1
a1505 1
	xfer->status = status;
d1508 1
a1508 1
	usb_uncallout(xfer->timeout_handle, uhci_timeout, ii);
d1511 2
a1512 2
	for (std = ii->stdstart; std != NULL; std = std->link.std)
		std->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
d1514 1
a1514 1
	xfer->hcpriv = ii;
d1516 10
a1525 1
	splx(s);
d1527 6
a1532 1
	delay(1000);
d1535 1
a1535 4
#ifdef DIAGNOSTIC
	ii->isdone = 1;
#endif
	usb_transfer_complete(xfer);
d1541 2
a1542 1
uhci_device_bulk_close(usbd_pipe_handle pipe)
d1549 2
d1554 2
a1555 1
uhci_device_ctrl_transfer(usbd_xfer_handle xfer)
d1557 1
a1557 1
	usbd_status err;
d1560 3
a1562 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d1564 2
a1565 5
	/* 
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d1569 2
a1570 1
uhci_device_ctrl_start(usbd_xfer_handle xfer)
d1572 2
a1573 5
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);
d1576 1
a1576 1
	if (!(xfer->rqflags & URQ_REQUEST))
d1580 3
a1582 3
	err = uhci_device_request(xfer);
	if (err)
		return (err);
d1585 1
a1585 1
		uhci_waitintr(sc, xfer);
d1590 2
a1591 1
uhci_device_intr_transfer(usbd_xfer_handle xfer)
d1593 1
a1593 1
	usbd_status err;
d1596 3
a1598 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d1600 2
a1601 5
	/* 
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d1605 2
a1606 1
uhci_device_intr_start(usbd_xfer_handle xfer)
d1608 1
a1608 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d1611 1
a1611 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d1614 1
a1614 1
	usbd_status err;
d1617 2
a1618 5
	if (sc->sc_dying)
		return (USBD_IOERROR);

	DPRINTFN(3,("uhci_device_intr_transfer: xfer=%p len=%d flags=%d\n",
		    xfer, xfer->length, xfer->flags));
d1621 1
a1621 1
	if (xfer->rqflags & URQ_REQUEST)
d1625 6
a1630 5
	err = uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,
				   &xfer->dmabuf, &data, &dataend);
	if (err)
		return (err);
	dataend->td.td_status |= htole32(UHCI_TD_IOC);
d1642 1
a1642 1
	ii->xfer = xfer;
d1645 3
a1648 3
	if (!ii->isdone) {
		printf("uhci_device_intr_transfer: not done, ii=%p\n", ii);
	}
d1657 1
a1657 1
		sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);
a1658 2
	uhci_add_intr_info(sc, ii);
	xfer->status = USBD_IN_PROGRESS;
d1674 2
a1675 1
uhci_device_ctrl_abort(usbd_xfer_handle xfer)
d1678 1
a1678 1
	uhci_abort_xfer(xfer, USBD_CANCELLED);
d1683 2
a1684 1
uhci_device_ctrl_close(usbd_pipe_handle pipe)
d1686 4
d1694 2
a1695 1
uhci_device_intr_abort(usbd_xfer_handle xfer)
d1697 2
a1698 2
	DPRINTFN(1,("uhci_device_intr_abort: xfer=%p\n", xfer));
	if (xfer->pipe->intrxfer == xfer) {
d1700 1
a1700 1
		xfer->pipe->intrxfer = 0;
d1702 1
a1702 1
	uhci_abort_xfer(xfer, USBD_CANCELLED);
d1707 2
a1708 1
uhci_device_intr_close(usbd_pipe_handle pipe)
d1712 3
a1714 2
	int i, npoll;
	int s;
d1718 1
a1718 1
	s = splusb();
d1720 3
a1722 2
		uhci_remove_intr(sc, upipe->u.intr.qhs[i]);
	splx(s);
d1734 5
d1743 2
a1744 1
uhci_device_request(usbd_xfer_handle xfer)
d1746 2
a1747 2
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	usb_device_request_t *req = &xfer->request;
d1752 1
a1752 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d1757 1
a1757 1
	usbd_status err;
d1778 5
a1782 4
		err = uhci_alloc_std_chain(upipe, sc, len, isread, xfer->flags,
					   &xfer->dmabuf, &data, &dataend);
		if (err)
			return (err);
d1785 1
a1785 1
		dataend->td.td_link = htole32(stat->physaddr | UHCI_PTR_VF | UHCI_PTR_TD);
d1794 8
a1801 9
	setup->td.td_link = htole32(next->physaddr | UHCI_PTR_VF | UHCI_PTR_TD);
	setup->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
		UHCI_TD_ACTIVE);
	setup->td.td_token = htole32(UHCI_TD_SETUP(sizeof *req, endpt, addr));
	setup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma));

	stat->link.std = NULL;
	stat->td.td_link = htole32(UHCI_PTR_T);
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls | 
d1804 3
a1806 3
		htole32(isread ? UHCI_TD_OUT(0, endpt, addr, 1) :
		                 UHCI_TD_IN (0, endpt, addr, 1));
	stat->td.td_buffer = htole32(0);
d1809 1
a1809 1
	if (uhcidebug > 10) {
d1816 1
a1816 1
	ii->xfer = xfer;
d1819 3
a1822 3
	if (!ii->isdone) {
		printf("uhci_device_request: not done, ii=%p\n", ii);
	}
d1827 2
a1828 1
	sqh->qh.qh_elink = htole32(setup->physaddr | UHCI_PTR_TD);
d1831 2
a1832 5
	if (dev->lowspeed)
		uhci_add_ls_ctrl(sc, sqh);
	else
		uhci_add_hs_ctrl(sc, sqh);
	uhci_add_intr_info(sc, ii);
d1842 1
a1842 1
		     (link & UHCI_PTR_QH) == 0;
d1844 1
a1844 1
			link = le32toh(std->td.td_link);
d1847 4
a1850 6
		sxqh = (uhci_soft_qh_t *)std;
		uhci_dump_qh(sxqh);
		for (xqh = sxqh;
		     xqh != NULL;
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh || 
                            xqh->hlink == xqh ? NULL : xqh->hlink)) {
d1852 1
d1859 3
a1861 3
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
			    uhci_timeout, ii);
a1862 1
	xfer->status = USBD_IN_PROGRESS;
d1869 2
a1870 1
uhci_device_isoc_transfer(usbd_xfer_handle xfer)
d1872 1
a1872 1
	usbd_status err;
d1874 1
a1874 1
	DPRINTFN(5,("uhci_device_isoc_transfer: xfer=%p\n", xfer));
d1877 1
a1877 1
	err = usb_insert_transfer(xfer);
d1880 2
a1881 2
	if (err && err != USBD_IN_PROGRESS)
		return (err);
d1886 1
a1886 1
	uhci_device_isoc_enter(xfer);
d1888 3
a1890 3
	/* and start if the pipe wasn't running */
	if (!err)
		uhci_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
d1892 1
a1892 1
	return (err);
d1896 2
a1897 1
uhci_device_isoc_enter(usbd_xfer_handle xfer)
d1899 1
a1899 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d1907 1
a1907 1
	DPRINTFN(5,("uhci_device_isoc_enter: used=%d next=%d xfer=%p "
d1909 1
a1909 4
		    iso->inuse, iso->next, xfer, xfer->nframes));

	if (sc->sc_dying)
		return;
d1911 1
a1911 1
	if (xfer->status == USBD_IN_PROGRESS) {
a1912 2
		printf("uhci_device_isoc_enter: xfer=%p in frame list\n", xfer);
		/* XXX */
d1927 2
a1928 2
	xfer->status = USBD_IN_PROGRESS;
	UXFER(xfer)->curframe = next;
d1930 5
a1934 5
	buf = DMAADDR(&xfer->dmabuf);
	status = UHCI_TD_ZERO_ACTLEN(UHCI_TD_SET_ERRCNT(0) |
				     UHCI_TD_ACTIVE |
				     UHCI_TD_IOS);
	nframes = xfer->nframes;
d1940 2
a1941 2
		len = xfer->frlengths[i];
		std->td.td_buffer = htole32(buf);
d1943 4
a1946 4
			status |= UHCI_TD_IOC;
		std->td.td_status = htole32(status);
		std->td.td_token &= htole32(~UHCI_TD_MAXLEN_MASK);
		std->td.td_token |= htole32(UHCI_TD_SET_MAXLEN(len));
d1956 1
a1956 1
	iso->inuse += xfer->nframes;
d1962 2
a1963 1
uhci_device_isoc_start(usbd_xfer_handle xfer)
d1965 1
a1965 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d1967 1
a1967 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
a1970 5
	DPRINTFN(5,("uhci_device_isoc_start: xfer=%p\n", xfer));

	if (sc->sc_dying)
		return (USBD_IOERROR);

d1972 2
a1973 2
	if (xfer->status != USBD_IN_PROGRESS)
		printf("uhci_device_isoc_start: not in progress %p\n", xfer);
d1977 1
a1977 1
	i = UXFER(xfer)->curframe + xfer->nframes;
a1981 7
#ifdef DIAGNOSTIC
	if (end == NULL) {
		printf("uhci_device_isoc_start: end == NULL\n");
		return (USBD_INVAL);
	}
#endif

d1985 1
a1985 1
	ii->xfer = xfer;
d1988 3
a1991 2
	if (!ii->isdone)
		printf("uhci_device_isoc_start: not done, ii=%p\n", ii);
d1994 1
a1994 1
	uhci_add_intr_info(sc, ii);
d2002 2
a2003 1
uhci_device_isoc_abort(usbd_xfer_handle xfer)
d2005 2
a2006 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d2009 1
a2009 1
	int i, n, s, nframes, maxlen, len;
d2011 2
a2012 11
	s = splusb();

	/* Transfer is already done. */
	if (xfer->status != USBD_NOT_STARTED && 
	    xfer->status != USBD_IN_PROGRESS) {
		splx(s);
		return;
	}

	/* Give xfer the requested abort code. */
	xfer->status = USBD_CANCELLED;
d2015 2
a2016 3
	nframes = xfer->nframes;
	n = UXFER(xfer)->curframe;
	maxlen = 0;
d2019 1
a2019 4
		std->td.td_status &= htole32(~(UHCI_TD_ACTIVE | UHCI_TD_IOC));
		len = UHCI_TD_GET_MAXLEN(le32toh(std->td.td_token));
		if (len > maxlen)
			maxlen = len;
d2024 1
a2024 2
	/* and wait until we are sure the hardware has finished. */
	delay(maxlen);
d2026 9
a2034 7
#ifdef DIAGNOSTIC
	UXFER(xfer)->iinfo.isdone = 1;
#endif
	/* Run callback and remove from interrupt list. */
	usb_transfer_complete(xfer);

	splx(s);
d2038 2
a2039 1
uhci_device_isoc_close(usbd_pipe_handle pipe)
d2046 1
a2046 1
	int i, s;
d2057 1
a2057 1
		iso->stds[i]->td.td_status &= htole32(~UHCI_TD_ACTIVE);
d2060 1
a2060 1
	s = splusb();
d2064 1
a2064 1
		     vstd != NULL && vstd->link.std != std;
d2067 1
a2067 1
		if (vstd == NULL) {
d2070 1
a2070 1
			splx(s);
d2077 1
a2077 1
	splx(s);
d2083 2
a2084 1
uhci_setup_isoc(usbd_pipe_handle pipe)
d2095 1
a2095 1
	int i, s;
d2101 2
a2102 2
	token = rd ? UHCI_TD_IN (0, endpt, addr, 0) :
		     UHCI_TD_OUT(0, endpt, addr, 0);
d2109 2
a2110 2
		std->td.td_status = htole32(UHCI_TD_IOS); /* iso, inactive */
		std->td.td_token = htole32(token);
d2115 1
a2115 1
	s = splusb();
d2122 1
a2122 1
		vstd->td.td_link = htole32(std->physaddr | UHCI_PTR_TD);
d2124 1
a2124 1
	splx(s);
d2139 2
a2140 1
uhci_device_isoc_done(usbd_xfer_handle xfer)
d2142 1
a2142 7
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;

	DPRINTFN(4, ("uhci_isoc_done: length=%d\n", xfer->actlen));

	if (ii->xfer != xfer)
		/* Not on interrupt list, ignore it. */
		return;
d2144 1
a2144 15
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("uhci_device_isoc_done: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return;
	}

        if (ii->stdend == NULL) {
                printf("uhci_device_isoc_done: xfer=%p stdend==NULL\n", xfer);
#ifdef UHCI_DEBUG
		uhci_dump_ii(ii);
#endif
		return;
	}
#endif
d2147 1
a2147 1
	ii->stdend->td.td_status &= htole32(~UHCI_TD_IOC);
d2149 1
a2149 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2153 2
a2154 1
uhci_device_intr_done(usbd_xfer_handle xfer)
d2156 1
a2156 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d2158 1
a2158 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d2162 1
a2162 1
	DPRINTFN(5, ("uhci_intr_done: length=%d\n", xfer->actlen));
d2167 2
a2168 2
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
d2173 1
a2173 1
	if (xfer->pipe->repeat) {
a2175 2
		DPRINTFN(5,("uhci_device_intr_done: requeing\n"));

d2177 4
a2180 3
		uhci_alloc_std_chain(upipe, sc, xfer->length, 1, xfer->flags,
				     &xfer->dmabuf, &data, &dataend);
		dataend->td.td_status |= htole32(UHCI_TD_IOC);
d2192 3
a2195 3
		if (!ii->isdone) {
			printf("uhci_device_intr_done: not done, ii=%p\n", ii);
		}
d2201 1
a2201 1
			sqh->qh.qh_elink = htole32(data->physaddr | UHCI_PTR_TD);
a2202 2
		xfer->status = USBD_IN_PROGRESS;
		/* The ii is already on the examined list, just leave it. */
d2204 1
a2204 2
		DPRINTFN(5,("uhci_device_intr_done: removing\n"));
		uhci_del_intr_info(ii);
d2210 2
a2211 1
uhci_device_ctrl_done(usbd_xfer_handle xfer)
d2213 1
a2213 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d2215 1
a2215 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d2218 1
a2218 1
	if (!(xfer->rqflags & URQ_REQUEST))
d2222 1
a2222 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2224 1
a2224 4
	if (upipe->pipe.device->lowspeed)
		uhci_remove_ls_ctrl(sc, upipe->u.ctl.sqh);
	else
		uhci_remove_hs_ctrl(sc, upipe->u.ctl.sqh);
d2229 1
a2229 1
	DPRINTFN(5, ("uhci_ctrl_done: length=%d\n", xfer->actlen));
d2234 2
a2235 1
uhci_device_bulk_done(usbd_xfer_handle xfer)
d2237 1
a2237 1
	uhci_intr_info_t *ii = &UXFER(xfer)->iinfo;
d2239 1
a2239 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
d2241 1
a2241 1
	uhci_del_intr_info(ii);	/* remove from active list */
d2247 1
a2247 1
	DPRINTFN(5, ("uhci_bulk_done: length=%d\n", xfer->actlen));
d2252 4
a2255 1
uhci_add_intr(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d2257 1
a2257 1
	struct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];
d2260 1
a2260 2
	DPRINTFN(4, ("uhci_add_intr: n=%d sqh=%p\n", sqh->pos, sqh));

d2265 1
a2265 1
	eqh->qh.qh_hlink = htole32(sqh->physaddr | UHCI_PTR_QH);
d2270 1
a2270 1
/* Remove interrupt QH. */
d2272 4
a2275 1
uhci_remove_intr(uhci_softc_t *sc, uhci_soft_qh_t *sqh)
d2277 1
a2277 1
	struct uhci_vframe *vf = &sc->sc_vframes[sqh->pos];
d2280 1
a2280 1
	DPRINTFN(4, ("uhci_remove_intr: n=%d sqh=%p\n", sqh->pos, sqh));
d2282 9
a2290 7
	/* See comment in uhci_remove_ctrl() */
	if (!(sqh->qh.qh_elink & htole32(UHCI_PTR_T))) {
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
		delay(UHCI_QH_REMOVE_DELAY);
	}

	pqh = uhci_find_prev_qh(vf->hqh, sqh);
a2292 1
	delay(UHCI_QH_REMOVE_DELAY);
d2299 4
a2302 1
uhci_device_setintr(uhci_softc_t *sc, struct uhci_pipe *upipe, int ival)
d2338 1
d2341 2
a2342 2
		sqh->elink = NULL;
		sqh->qh.qh_elink = htole32(UHCI_PTR_T);
d2344 1
d2349 4
d2355 3
a2357 2
		uhci_add_intr(sc, upipe->u.intr.qhs[i]);
	splx(s);
d2365 2
a2366 1
uhci_open(usbd_pipe_handle pipe)
d2371 1
a2371 2
	usbd_status err;
	int ival;
a2375 4

	upipe->aborting = 0;
	upipe->nexttoggle = 0;

d2388 3
d2395 1
a2395 1
			if (upipe->u.ctl.sqh == NULL)
d2398 1
a2398 1
			if (upipe->u.ctl.setup == NULL) {
d2403 1
a2403 1
			if (upipe->u.ctl.stat == NULL) {
d2408 4
a2411 4
			err = usb_allocmem(&sc->sc_bus, 
				  sizeof(usb_device_request_t), 
				  0, &upipe->u.ctl.reqdma);
			if (err) {
d2420 1
a2420 4
			ival = pipe->interval;
			if (ival == USBD_DEFAULT_INTERVAL)
				ival = ed->bInterval;
			return (uhci_device_setintr(sc, upipe, ival));
d2427 1
a2427 1
			if (upipe->u.bulk.sqh == NULL)
d2435 1
d2446 2
a2447 2
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
d2474 2
a2475 2
	UICLASS_HUB,
	UISUBCLASS_HUB,
d2500 4
a2503 1
uhci_str(usb_string_descriptor_t *p, int l, char *s)
d2523 2
a2524 1
uhci_root_ctrl_transfer(usbd_xfer_handle xfer)
d2526 1
a2526 1
	usbd_status err;
d2529 3
a2531 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2533 2
a2534 5
	/* 
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (uhci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2538 2
a2539 1
uhci_root_ctrl_start(usbd_xfer_handle xfer)
d2541 1
a2541 1
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
d2547 1
a2547 4
	usbd_status err;

	if (sc->sc_dying)
		return (USBD_IOERROR);
d2550 1
a2550 1
	if (!(xfer->rqflags & URQ_REQUEST))
d2553 1
a2553 1
	req = &xfer->request;
d2563 1
a2563 1
		buf = KERNADDR(&xfer->dmabuf);
d2586 1
a2586 1
				err = USBD_IOERROR;
d2595 1
a2595 1
				err = USBD_IOERROR;
d2626 1
a2626 1
			err = USBD_IOERROR;
d2651 1
a2651 1
			err = USBD_IOERROR;
d2658 1
a2658 1
			err = USBD_IOERROR;
d2668 1
a2668 1
		err = USBD_IOERROR;
d2686 1
a2686 1
			err = USBD_IOERROR;
d2716 1
a2716 1
			err = USBD_NORMAL_COMPLETION;
d2724 1
a2724 1
			err = USBD_IOERROR;
d2734 1
a2734 1
			err = USBD_IOERROR;
d2746 1
a2746 1
			err = USBD_IOERROR;
d2755 1
a2755 1
			err = USBD_IOERROR;
d2767 1
a2767 1
			err = USBD_IOERROR;
d2771 1
a2771 1
			err = USBD_IOERROR;
d2802 1
a2802 1
		err = USBD_IOERROR;
d2812 1
a2812 1
			err = USBD_IOERROR;
d2827 1
a2827 1
			usb_delay_ms(&sc->sc_bus, 50); /*XXX USB v1.1 7.1.7.3 */
d2832 1
a2832 1
			usb_delay_ms(&sc->sc_bus, 10); /* XXX */
a2836 4
		case UHF_PORT_POWER:
			/* Pretend we turned on power */
			err = USBD_NORMAL_COMPLETION;
			goto ret;
d2842 1
d2847 1
a2847 1
			err = USBD_IOERROR;
d2852 1
a2852 1
		err = USBD_IOERROR;
d2855 2
a2856 2
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
d2858 2
a2859 1
	xfer->status = err;
d2861 1
a2861 1
	usb_transfer_complete(xfer);
d2868 2
a2869 1
uhci_root_ctrl_abort(usbd_xfer_handle xfer)
d2871 1
a2871 1
	/* Nothing to do, all transfers are synchronous. */
d2876 2
a2877 1
uhci_root_ctrl_close(usbd_pipe_handle pipe)
d2879 3
d2887 2
a2888 1
uhci_root_intr_abort(usbd_xfer_handle xfer)
d2890 1
a2890 1
	uhci_softc_t *sc = (uhci_softc_t *)xfer->pipe->device->bus;
d2892 2
a2893 2
	usb_uncallout(sc->sc_poll_handle, uhci_poll_hub, xfer);
	sc->sc_intr_xfer = NULL;
d2895 1
a2895 1
	if (xfer->pipe->intrxfer == xfer) {
d2897 1
a2897 1
		xfer->pipe->intrxfer = 0;
d2899 2
a2900 5
	xfer->status = USBD_CANCELLED;
#ifdef DIAGNOSTIC
	UXFER(xfer)->iinfo.isdone = 1;
#endif
	usb_transfer_complete(xfer);
d2904 2
a2905 1
uhci_root_intr_transfer(usbd_xfer_handle xfer)
d2907 1
a2907 1
	usbd_status err;
d2910 3
a2912 3
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);
d2914 2
a2915 4
	/* Pipe isn't running (otherwise err would be USBD_INPROG),
	 * start first
	 */
	return (uhci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
d2920 2
a2921 1
uhci_root_intr_start(usbd_xfer_handle xfer)
d2923 1
a2923 1
	usbd_pipe_handle pipe = xfer->pipe;
d2926 2
a2927 2
	DPRINTFN(3, ("uhci_root_intr_transfer: xfer=%p len=%d flags=%d\n",
		     xfer, xfer->length, xfer->flags));
d2929 3
a2931 6
	if (sc->sc_dying)
		return (USBD_IOERROR);

	sc->sc_ival = MS_TO_TICKS(xfer->pipe->endpoint->edesc->bInterval);
	usb_callout(sc->sc_poll_handle, sc->sc_ival, uhci_poll_hub, xfer);
	sc->sc_intr_xfer = xfer;
d2937 2
a2938 1
uhci_root_intr_close(usbd_pipe_handle pipe)
d2942 2
a2943 2
	usb_uncallout(sc->sc_poll_handle, uhci_poll_hub, sc->sc_intr_xfer);
	sc->sc_intr_xfer = NULL;
d2946 1
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhci.c,v 1.135 2001/04/01 14:59:52 augustss Exp $	*/
d165 1
d690 1
a690 1
	s = splhardusb();
a712 2
		UWRITE2(sc, UHCI_INTR, 0); /* disable intrs */

a1170 1
		UWRITE2(sc, UHCI_STS, status); /* acknowledge the ints */
d1211 4
a1214 3
	if (!ack)
		return (0);	/* nothing to acknowledge */
	UWRITE2(sc, UHCI_STS, ack); /* acknowledge the ints */
d1515 1
a1515 1
	s = splhardusb();
@


1.6.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uhci.c,v 1.142 2001/10/25 02:08:13 augustss Exp $	*/
d162 1
a162 2
Static void		uhci_globalreset(uhci_softc_t *);
Static void		uhci_reset(uhci_softc_t *);
a164 1
Static usbd_status	uhci_run(uhci_softc_t *, int run);
d245 1
a245 1
Static void		uhci_softintr(void *);
d286 1
a286 1
#define UHCI_RESET_TIMEOUT 100	/* ms, reset timeout */
d378 1
a378 1
uhci_globalreset(uhci_softc_t *sc)
d404 2
a405 2
	uhci_globalreset(sc);			/* reset the controller */
	uhci_reset(sc);
d818 1
d824 1
a912 10
        if (pipe->endpoint == NULL) {
		printf("ii %p: done=%d xfer=%p pipe=%p pipe->endpoint=NULL\n",
		       ii, DONE, ii->xfer, pipe);
                return;
	}
        if (pipe->device == NULL) {
		printf("ii %p: done=%d xfer=%p pipe=%p pipe->device=NULL\n",
		       ii, DONE, ii->xfer, pipe);
                return;
	}
a1150 2
Static int uhci_intr1(uhci_softc_t *);

a1154 14

	DPRINTFN(15,("uhci_intr: real interrupt\n"));
	if (sc->sc_bus.use_polling) {
#ifdef DIAGNOSTIC
		printf("uhci_intr: ignored interrupt while polling\n");
#endif
		return (0);
	}
	return (uhci_intr1(sc));
}

int
uhci_intr1(uhci_softc_t *sc)
{
d1160 1
a1160 1
		DPRINTF(("%s: uhci_intr1\n", USBDEVNAME(sc->sc_bus.bdev)));
a1168 5
#if defined(DIAGNOSTIC) && defined(__NetBSD__)
	if (sc->sc_suspend != PWR_RESUME)
		printf("uhci_intr: suspended sts=0x%x\n", status);
#endif

d1176 5
d1203 1
a1203 1
		if (!sc->sc_dying) {
d1206 1
d1208 1
a1208 1
			uhci_dump_all(sc);
d1210 1
a1210 2
		}
		sc->sc_dying = 1;
d1226 1
a1226 1
uhci_softintr(void *v)
d1228 1
a1228 1
	uhci_softc_t *sc = v;
d1231 1
a1231 2
	DPRINTFN(10,("%s: uhci_softintr (%d)\n", USBDEVNAME(sc->sc_bus.bdev),
		     sc->sc_bus.intr_context));
a1315 1
	DPRINTFN(12, ("uhci_idone: ii=%p\n", ii));
d1368 2
a1369 1
		goto end;
d1396 1
a1396 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n", 
a1421 2

 end:
a1422 1
	DPRINTFN(12, ("uhci_idone: ii=%p done\n", ii));
d1464 1
a1464 1
			uhci_intr1(sc);
d1489 1
a1489 1
		uhci_intr1(sc);
d1492 1
d1507 1
d3058 1
a3058 1
			x = URWMASK(UREAD2(sc, port));
d3062 1
a3062 1
			x = URWMASK(UREAD2(sc, port));
d3066 1
a3066 1
			x = URWMASK(UREAD2(sc, port));
d3070 1
a3070 1
			x = URWMASK(UREAD2(sc, port));
d3074 1
a3074 1
			x = URWMASK(UREAD2(sc, port));
d3078 1
a3078 1
			x = URWMASK(UREAD2(sc, port));
d3143 1
a3143 1
		if (x & UHCI_PORTSC_CCS)
d3145 1
a3145 1
		if (x & UHCI_PORTSC_CSC) 
d3147 1
a3147 1
		if (x & UHCI_PORTSC_PE) 
d3151 1
a3151 1
		if (x & UHCI_PORTSC_OCI) 
d3153 1
a3153 1
		if (x & UHCI_PORTSC_OCIC) 
d3155 1
a3155 1
		if (x & UHCI_PORTSC_SUSP) 
d3157 1
a3157 1
		if (x & UHCI_PORTSC_LSDA) 
d3184 1
a3184 1
			x = URWMASK(UREAD2(sc, port));
d3188 1
a3188 1
			x = URWMASK(UREAD2(sc, port));
d3192 1
a3192 1
			x = URWMASK(UREAD2(sc, port));
@


1.6.2.4
log
@Merge in trunk
@
text
@a597 2
		if (stds == NULL)
			panic("uhci_allocm");
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@d177 1
a177 1
Static void		uhci_free_std_chain(uhci_softc_t *,
d180 1
a180 1
			    uhci_softc_t *, int, int, u_int16_t, usb_dma_t *,
d253 1
a253 1
Static usbd_status	uhci_device_setintr(uhci_softc_t *sc,
d304 1
a304 1
struct usbd_pipe_methods uhci_root_ctrl_methods = {
d313 1
a313 1
struct usbd_pipe_methods uhci_root_intr_methods = {
d369 1
a369 1
#if defined(DIAGNOSTIC) || defined(UHCI_DEBUG)
d410 1
a410 1
	err = usb_allocmem(&sc->sc_bus,
d419 1
a419 1
	/*
d473 1
a473 1
	/*
d496 2
a497 2
		for (j = i;
		     j < UHCI_FRAMELIST_COUNT;
d519 1
a519 1
	UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d555 1
a555 1

d571 1
a571 1
	}
d585 1
a585 1
	/*
d696 1
a696 1
	DPRINTF(("uhci_power: sc=%p, why=%d (was %d), cmd=0x%x\n",
d742 1
a742 1
		UWRITE2(sc, UHCI_INTR, UHCI_INTR_TOCRCIE | UHCI_INTR_RIE |
d894 1
a894 1

d927 2
a928 2
	printf("ii %p: done=%d xfer=%p dev=%p vid=0x%04x pid=0x%04x addr=%d pipe=%p ep=0x%02x attr=0x%02x\n",
	       ii, DONE, ii->xfer, dev,
d1013 1
a1013 1
		sc->sc_last_qh->qh.qh_hlink =
d1226 1
a1226 1
		printf("%s: host controller process error\n",
d1232 1
a1232 1
			printf("%s: host controller halted\n",
d1304 1
a1304 1
	/*
d1321 1
a1321 1
			      UHCI_TD_GET_ACTLEN(status) <
d1425 1
a1425 1
	DPRINTFN(10, ("uhci_idone: actlen=%d, status=0x%x\n",
d1505 1
a1505 1
	     ii != NULL && ii->xfer != xfer;
d1510 1
a1510 1
		panic("uhci_waitintr: lost intr_info");
d1531 1
a1531 1
	for (n = 0; n < UHCI_RESET_TIMEOUT &&
d1535 1
a1535 1
		printf("%s: controller did not reset\n",
d1684 1
a1684 1
		      "flags=0x%x\n", addr, UE_GET_ADDR(endpt), len,
d1731 1
a1731 1
		p->td.td_token =
d1738 1
a1738 1
	DPRINTFN(10, ("uhci_alloc_std_chain: nexttog=%d\n",
d1765 1
a1765 1
	/*
d1793 1
a1793 1
		panic("uhci_device_bulk_transfer: a request");
d1880 1
a1880 1
	if (xfer->status != USBD_NOT_STARTED &&
d1931 1
a1931 1
	/*
d1949 1
a1949 1
		panic("uhci_device_ctrl_transfer: not a request");
d1971 1
a1971 1
	/*
d1998 1
a1998 1
		panic("uhci_device_intr_transfer: a request");
d2027 1
a2027 1
	DPRINTFN(10,("uhci_device_intr_transfer: qhs[0]=%p\n",
d2091 1
a2091 1
	/*
d2162 1
a2162 1
	stat->td.td_status = htole32(UHCI_TD_SET_ERRCNT(3) | ls |
d2164 1
a2164 1
	stat->td.td_token =
d2214 1
a2214 1
		     xqh = (maxqh++ == 5 || xqh->hlink == sxqh ||
d2266 1
a2266 1
	uhci_soft_td_t *std;
d2362 1
a2362 1

d2373 1
a2373 1

d2390 1
a2390 1
	if (xfer->status != USBD_NOT_STARTED &&
d2626 1
a2626 1
		panic("uhci_ctrl_done: not a request");
d2720 1
a2720 1
	upipe->u.intr.qhs =
d2723 1
a2723 1
	/*
d2767 1
a2767 1
		     pipe, pipe->device->address,
d2802 2
a2803 2
			err = usb_allocmem(&sc->sc_bus,
				  sizeof(usb_device_request_t),
d2925 1
a2925 1
	/*
d2948 1
a2948 1
		panic("uhci_root_ctrl_transfer: not a request");
d2952 1
a2952 1
	DPRINTFN(2,("uhci_root_ctrl_control type=0x%02x request=%02x\n",
d2967 1
a2967 1
		/*
d3135 1
a3135 1
			*(u_int8_t *)buf =
d3175 1
a3175 1
		if (x & UHCI_PORTSC_CSC)
d3177 1
a3177 1
		if (x & UHCI_PORTSC_PE)
d3179 1
a3179 1
		if (x & UHCI_PORTSC_POEDC)
d3181 1
a3181 1
		if (x & UHCI_PORTSC_OCI)
d3183 1
a3183 1
		if (x & UHCI_PORTSC_OCIC)
d3185 1
a3185 1
		if (x & UHCI_PORTSC_SUSP)
d3187 1
a3187 1
		if (x & UHCI_PORTSC_LSDA)
@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.6.2.5 2003/03/28 00:38:31 niklas Exp $	*/
d47 1
a47 1
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhci.c,v 1.172 2003/02/23 04:19:26 simonb Exp $	*/
d91 2
a162 1
Static usbd_status	uhci_portreset(uhci_softc_t*, int);
a189 1
Static void		uhci_timeout_task(void *);
d252 1
a252 1
Static void		uhci_remove_intr(uhci_softc_t *, uhci_soft_qh_t *);
d276 1
a276 2
 do { UBARR(sc); bus_space_write_1((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)
d278 1
a278 2
 do { UBARR(sc); bus_space_write_2((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)
d280 1
a280 2
 do { UBARR(sc); bus_space_write_4((sc)->iot, (sc)->ioh, (r), (x)); \
 } while (/*CONSTCOND*/0)
d359 1
a359 1
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ii), list)
d361 1
a361 5
	do { \
		LIST_REMOVE((ii), list); \
		(ii)->list.le_prev = NULL; \
	} while (0)
#define uhci_active_intr_info(ii) ((ii)->list.le_prev != NULL)
d404 1
d415 1
a415 1
	sc->sc_pframes = KERNADDR(&sc->sc_dma, 0);
d417 1
a417 1
	UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma, 0)); /* set frame list*/
d537 1
d588 1
a588 1
	 * need TDs for it.  Since we don't want to allocate those from
d597 1
a597 2
		stds = malloc(sizeof(uhci_soft_td_t *) * n, M_TEMP,
			      M_NOWAIT);
d735 1
a735 1
		UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma, 0));
a741 1
		UHCICMD(sc, UHCI_CMD_MAXP);
d795 1
a795 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_link), "\20\1T\2Q\3VF",
d797 1
a797 1
	bitmask_snprintf((u_int32_t)le32toh(p->td.td_status),
d969 1
a969 1
	p = KERNADDR(&xfer->dmabuf, 0);
d1076 1
a1076 1
	pqh->hlink = sqh->hlink;
d1093 1
a1093 1
	sqh->hlink = eqh->hlink;
d1095 1
a1095 1
	eqh->hlink = sqh;
d1115 1
a1115 1
	pqh->hlink = sqh->hlink;
d1132 1
a1132 1
	sqh->hlink = eqh->hlink;
d1134 1
a1134 1
	eqh->hlink = sqh;
a1169 3
	if (sc->sc_dying)
		return (0);

d1193 1
a1193 1
	status = UREAD2(sc, UHCI_STS) & UHCI_STS_ALLINTRS;
d1197 5
a1277 7
#ifdef USB_USE_SOFTINTR
	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}
#endif /* USB_USE_SOFTINTR */

a1294 6
	if (ii->xfer->status == USBD_CANCELLED ||
	    ii->xfer->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_check_intr: aborted xfer=%p\n", ii->xfer));
		return;
	}

d1364 6
d1432 1
a1432 2
		bitmask_snprintf((u_int32_t)status,
				 "\20\22BITSTUFF\23CRCTO\24NAK\25"
a1463 3
	struct uhci_xfer *uxfer = UXFER(ii->xfer);
	struct uhci_pipe *upipe = (struct uhci_pipe *)uxfer->xfer.pipe;
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
d1465 1
a1465 1
	DPRINTF(("uhci_timeout: uxfer=%p\n", uxfer));
d1467 4
a1470 4
	if (sc->sc_dying) {
		uhci_abort_xfer(&uxfer->xfer, USBD_TIMEOUT);
		return;
	}
d1472 3
a1474 16
	/* Execute the abort in a process context. */
	usb_init_task(&uxfer->abort_task, uhci_timeout_task, ii->xfer);
	usb_add_task(uxfer->xfer.pipe->device, &uxfer->abort_task);
}

void
uhci_timeout_task(void *addr)
{
	usbd_xfer_handle xfer = addr;
	int s;

	DPRINTF(("uhci_timeout_task: xfer=%p\n", xfer));

	s = splusb();
	uhci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
d1597 2
a1598 2
			std = KERNADDR(&dma, offs);
			std->physaddr = DMAADDR(&dma, offs);
d1640 2
a1641 2
			sqh = KERNADDR(&dma, offs);
			sqh->physaddr = DMAADDR(&dma, offs);
d1683 1
a1683 1
	DPRINTFN(8, ("uhci_alloc_std_chain: addr=%d endpt=%d len=%d speed=%d "
d1685 1
a1685 1
		      upipe->pipe.device->speed, flags));
d1708 1
a1708 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d1715 1
a1715 1
			uhci_free_std_chain(sc, lastp, NULL);
d1734 1
a1734 1
		p->td.td_buffer = htole32(DMAADDR(dma, i * maxp));
d1785 2
a1786 2
	DPRINTFN(3, ("uhci_device_bulk_start: xfer=%p len=%d flags=%d ii=%p\n",
		     xfer, xfer->length, xfer->flags, ii));
d1836 1
a1836 1
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
d1864 3
a1866 8
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
a1871 2
	struct uhci_pipe *upipe = (struct uhci_pipe *)xfer->pipe;
	uhci_softc_t *sc = (uhci_softc_t *)upipe->pipe.device->bus;
d1877 5
a1881 6
	if (sc->sc_dying) {
		/* If we're dying, just do the software part. */
		s = splusb();
		xfer->status = status;	/* make software ignore it */
		usb_uncallout(xfer->timeout_handle, uhci_timeout, xfer);
		usb_transfer_complete(xfer);
d1883 1
d1886 2
a1887 2
	if (xfer->device->bus->intr_context || !curproc)
		panic("uhci_abort_xfer: not in process context");
d1889 1
a1889 5
	/*
	 * Step 1: Make interrupt routine and hardware ignore xfer.
	 */
	s = splusb();
	xfer->status = status;	/* make software ignore it */
d1891 2
a1892 1
	DPRINTFN(1,("uhci_abort_xfer: stop ii=%p\n", ii));
a1894 1
	splx(s);
d1896 2
a1897 15
	/*
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
	 */
	usb_delay_ms(upipe->pipe.device->bus, 2); /* Hardware finishes in 1ms */
	s = splusb();
#ifdef USB_USE_SOFTINTR
	sc->sc_softwake = 1;
#endif /* USB_USE_SOFTINTR */
	usb_schedsoftintr(&sc->sc_bus);
#ifdef USB_USE_SOFTINTR
	DPRINTFN(1,("uhci_abort_xfer: tsleep\n"));
	tsleep(&sc->sc_softwake, PZERO, "uhciab", 0);
#endif /* USB_USE_SOFTINTR */
d1900 1
a1900 4
	/*
	 * Step 3: Execute callback.
	 */
	xfer->hcpriv = ii;
a1901 1
	DPRINTFN(1,("uhci_abort_xfer: callback\n"));
d2070 1
a2070 1
		xfer->pipe->intrxfer = NULL;
d2128 1
a2128 1
	ls = dev->speed == USB_SPEED_LOW ? UHCI_TD_LS : 0;
d2151 1
a2151 1
	memcpy(KERNADDR(&upipe->u.ctl.reqdma, 0), req, sizeof *req);
d2158 1
a2158 1
	setup->td.td_buffer = htole32(DMAADDR(&upipe->u.ctl.reqdma, 0));
d2191 1
a2191 1
	if (dev->speed == USB_SPEED_LOW)
d2224 1
a2224 1
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
d2298 1
a2298 1
	buf = DMAADDR(&xfer->dmabuf, 0);
a2534 3
	if (!uhci_active_intr_info(ii))
		return;

d2566 1
a2566 1
	DPRINTFN(5, ("uhci_device_intr_done: length=%d\n", xfer->actlen));
d2574 1
a2574 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d2612 1
a2612 2
		if (uhci_active_intr_info(ii))
			uhci_del_intr_info(ii);
d2626 1
a2626 1
		panic("uhci_device_ctrl_done: not a request");
a2628 3
	if (!uhci_active_intr_info(ii))
		return;

d2631 1
a2631 1
	if (upipe->pipe.device->speed == USB_SPEED_LOW)
d2639 1
a2639 1
	DPRINTFN(5, ("uhci_device_ctrl_done: length=%d\n", xfer->actlen));
a2649 6
	DPRINTFN(5,("uhci_device_bulk_done: xfer=%p ii=%p sc=%p upipe=%p\n",
		    xfer, ii, sc, upipe));

	if (!uhci_active_intr_info(ii))
		return;

d2654 1
a2654 1
	uhci_free_std_chain(sc, ii->stdstart, NULL);
d2656 1
a2656 1
	DPRINTFN(5, ("uhci_device_bulk_done: length=%d\n", xfer->actlen));
d2708 1
a2708 1
	DPRINTFN(2, ("uhci_device_setintr: pipe=%p\n", upipe));
d2710 1
a2710 1
		printf("uhci_device_setintr: 0 interval\n");
d2717 1
a2717 1
	DPRINTFN(2, ("uhci_device_setintr: ival=%d npoll=%d\n", ival, npoll));
d2736 1
a2736 1
	DPRINTFN(1, ("uhci_device_setintr: bw=%d offs=%d\n", bestbw, bestoffs));
d2752 1
a2752 1
	DPRINTFN(5, ("uhci_device_setintr: returns %p\n", upipe));
d2844 1
a2844 1
	UDPROTO_FSHUB,		/* protocol */
d2872 1
a2872 1
	UIPROTO_FSHUB,
a2912 95
 * The USB hub protocol requires that SET_FEATURE(PORT_RESET) also
 * enables the port, and also states that SET_FEATURE(PORT_ENABLE)
 * should not be used by the USB subsystem.  As we cannot issue a
 * SET_FEATURE(PORT_ENABLE) externally, we must ensure that the port
 * will be enabled as part of the reset.
 *
 * On the VT83C572, the port cannot be successfully enabled until the
 * outstanding "port enable change" and "connection status change"
 * events have been reset.
 */
Static usbd_status
uhci_portreset(uhci_softc_t *sc, int index)
{
	int lim, port, x;

	if (index == 1)
		port = UHCI_PORTSC1;
	else if (index == 2)
		port = UHCI_PORTSC2;
	else
		return (USBD_IOERROR);

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x | UHCI_PORTSC_PR);

	usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);

	DPRINTFN(3,("uhci port %d reset, status0 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x & ~UHCI_PORTSC_PR);

	delay(100);

	DPRINTFN(3,("uhci port %d reset, status1 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	x = URWMASK(UREAD2(sc, port));
	UWRITE2(sc, port, x  | UHCI_PORTSC_PE);

	for (lim = 10; --lim > 0;) {
		usb_delay_ms(&sc->sc_bus, USB_PORT_RESET_DELAY);

		x = UREAD2(sc, port);

		DPRINTFN(3,("uhci port %d iteration %u, status = 0x%04x\n",
			    index, lim, x));

		if (!(x & UHCI_PORTSC_CCS)) {
			/*
			 * No device is connected (or was disconnected
			 * during reset).  Consider the port reset.
			 * The delay must be long enough to ensure on
			 * the initial iteration that the device
			 * connection will have been registered.  50ms
			 * appears to be sufficient, but 20ms is not.
			 */
			DPRINTFN(3,("uhci port %d loop %u, device detached\n",
				    index, lim));
			break;
		}

		if (x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC)) {
			/*
			 * Port enabled changed and/or connection
			 * status changed were set.  Reset either or
			 * both raised flags (by writing a 1 to that
			 * bit), and wait again for state to settle.
			 */
			UWRITE2(sc, port, URWMASK(x) |
				(x & (UHCI_PORTSC_POEDC | UHCI_PORTSC_CSC)));
			continue;
		}

		if (x & UHCI_PORTSC_PE)
			/* Port is enabled */
			break;

		UWRITE2(sc, port, URWMASK(x) | UHCI_PORTSC_PE);
	}

	DPRINTFN(3,("uhci port %d reset, status2 = 0x%04x\n",
		    index, UREAD2(sc, port)));

	if (lim <= 0) {
		DPRINTFN(1,("uhci port %d reset timed out\n", index));
		return (USBD_TIMEOUT);
	}
	
	sc->sc_isreset = 1;
	return (USBD_NORMAL_COMPLETION);
}

/*
d2960 1
a2960 1
		buf = KERNADDR(&xfer->dmabuf, 0);
d3222 12
a3233 2
			err = uhci_portreset(sc, index);
			goto ret;
d3322 1
a3322 1
	DPRINTFN(3, ("uhci_root_intr_start: xfer=%p len=%d flags=%d\n",
d3328 1
a3328 1
	sc->sc_ival = mstohz(xfer->pipe->endpoint->edesc->bInterval);
@


1.6.2.8
log
@Merge with the trunk
@
text
@d574 1
a574 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
d632 1
a632 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: uhci.c,v 1.55 1999/09/15 21:12:29 augustss Exp $	*/
d94 9
d243 1
a243 1
#ifdef USB_DEBUG
d347 1
a347 1
#if defined(USB_DEBUG)
a418 1
#if !defined(__OpenBSD__)
a419 1
#endif
d451 2
a452 2
uhci_detach(self, flags)
	device_ptr_t self;
a454 1
	struct uhci_softc *sc = (struct uhci_softc *)self;
d475 1
d477 1
d487 1
d489 1
d494 1
a494 1
#if !defined(__OpenBSD__)
d518 1
a518 1
#if defined(USB_DEBUG)
d530 1
d538 5
d557 1
a557 1
#if defined(USB_DEBUG)
d564 1
a564 1
#endif /* !defined(__OpenBSD__) */
d566 1
a566 1
#ifdef USB_DEBUG
d730 4
d775 1
a775 1
#if defined(DIAGNOSTIC) || defined(USB_DEBUG)		
d820 1
a820 1
#if defined(DIAGNOSTIC) || defined(USB_DEBUG)		
d843 1
a843 1
#if defined(USB_DEBUG)
d850 5
a854 1
#if defined(DIAGNOSTIC) && defined(__NetBSD__)
a858 1
	status = UREAD2(sc, UHCI_STS);
d1002 1
a1002 1
#ifdef USB_DEBUG
d1021 1
a1021 1
#ifdef USB_DEBUG
d1441 1
a1441 1
#ifdef USB_DEBUG
d1452 3
d1473 1
a1473 1
#ifdef USB_DEBUG
d1632 1
a1632 1
#ifdef USB_DEBUG
d1645 3
d1661 1
a1661 1
#ifdef USB_DEBUG
d1808 1
a1808 1
#ifdef USB_DEBUG
d1819 3
d1833 1
a1833 1
#ifdef USB_DEBUG
d1947 1
a1947 1
#ifdef USB_DEBUG
d1988 3
d2182 1
a2182 1
#ifdef USB_DEBUG
d2192 3
d2283 1
a2283 1
#if defined(DIAGNOSTIC) || defined(USB_DEBUG)		
d2543 1
a2543 1
	void *buf;
a2563 4
#ifdef DIAGNOSTIC
	else
		buf = 0;
#endif
d2894 7
@


1.4
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d2 1
a2 1
/*	$NetBSD: uhci.c,v 1.43 1999/08/22 23:41:00 augustss Exp $	*/
a113 1
			usb_dma_t datadma;
a118 1
			usb_dma_t datadma;
a124 1
			usb_dma_t datadma;
a129 3
			u_int bufsize;
			u_int nbuf;
			usb_dma_t *bufs;
d131 1
d178 2
d183 3
a208 1
usbd_status	uhci_device_isoc_setbuf __P((usbd_pipe_handle, u_int, u_int));
d257 8
a264 1
struct usbd_methods uhci_root_ctrl_methods = {	
a270 1
	0,
d273 1
a273 1
struct usbd_methods uhci_root_intr_methods = {	
a279 1
	0,
d282 1
a282 1
struct usbd_methods uhci_device_ctrl_methods = {
a288 1
	0,
d291 1
a291 1
struct usbd_methods uhci_device_intr_methods = {
a297 1
	0,
d300 1
a300 1
struct usbd_methods uhci_device_bulk_methods = {
a306 1
	0,
d309 1
a309 1
struct usbd_methods uhci_device_isoc_methods = {
a315 1
	uhci_device_isoc_setbuf,
d349 1
a349 1
	r = usb_allocmem(sc->sc_dmatag, 
d407 1
a407 1
	sc->sc_bus.open_pipe = uhci_open;
a408 1
	sc->sc_bus.do_poll = uhci_poll;
d413 1
a413 1
	powerhook_establish(uhci_power, sc);
d422 62
d515 1
a515 1
		sc->sc_bus.use_polling = 1;
d537 1
a537 1
		sc->sc_bus.use_polling = 0;
d555 11
a565 11
	printf("%s regs: cmd=%04x, sts=%04x, intr=%04x, frnum=%04x, "
	       "flbase=%08x, sof=%04x, portsc1=%04x, portsc2=%04x\n",
	       USBDEVNAME(sc->sc_bus.bdev),
	       UREAD2(sc, UHCI_CMD),
	       UREAD2(sc, UHCI_STS),
	       UREAD2(sc, UHCI_INTR),
	       UREAD2(sc, UHCI_FRNUM),
	       UREAD4(sc, UHCI_FLBASEADDR),
	       UREAD1(sc, UHCI_SOF),
	       UREAD2(sc, UHCI_PORTSC1),
	       UREAD2(sc, UHCI_PORTSC2));
a567 2
int uhci_longtd = 1;

d572 21
a592 22
	printf("TD(%p) at %08lx = link=0x%08lx status=0x%08lx "
	       "token=0x%08lx buffer=0x%08lx\n",
	       p, (long)p->physaddr,
	       (long)LE(p->td.td_link),
	       (long)LE(p->td.td_status),
	       (long)LE(p->td.td_token),
	       (long)LE(p->td.td_buffer));
	if (uhci_longtd)
		printf("  %b %b,errcnt=%d,actlen=%d pid=%02x,addr=%d,endpt=%d,"
		       "D=%d,maxlen=%d\n",
		       (int)LE(p->td.td_link),
		       "\20\1T\2Q\3VF",
		       (int)LE(p->td.td_status),
		       "\20\22BITSTUFF\23CRCTO\24NAK\25BABBLE\26DBUFFER\27"
		       "STALLED\30ACTIVE\31IOC\32ISO\33LS\36SPD",
		       UHCI_TD_GET_ERRCNT(LE(p->td.td_status)),
		       UHCI_TD_GET_ACTLEN(LE(p->td.td_status)),
		       UHCI_TD_GET_PID(LE(p->td.td_token)),
		       UHCI_TD_GET_DEVADDR(LE(p->td.td_token)),
		       UHCI_TD_GET_ENDPT(LE(p->td.td_token)),
		       UHCI_TD_GET_DT(LE(p->td.td_token)),
		       UHCI_TD_GET_MAXLEN(LE(p->td.td_token)));
d599 2
a600 2
	printf("QH(%p) at %08x: hlink=%08x elink=%08x\n", p, (int)p->physaddr,
	       LE(p->qh.qh_hlink), LE(p->qh.qh_elink));
d611 1
a611 1
	printf("intrs=%d\n", sc->sc_intrs);
a638 1
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
d646 1
a646 1
	p = KERNADDR(&upipe->u.intr.datadma);
d660 1
d662 1
a669 6
	usbd_pipe_handle pipe = reqh->pipe;
	uhci_softc_t *sc = (uhci_softc_t *)pipe->device->bus;
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;

	if (!reqh->pipe->repeat)
		usb_freemem(sc->sc_dmatag, &upipe->u.intr.datadma);
d732 2
d751 2
d777 2
d796 2
d815 2
a816 2
uhci_intr(p)
	void *p;
d818 3
a820 2
	uhci_softc_t *sc = p;
	int status, ret;
a822 1
	sc->sc_intrs++;
d824 2
a825 2
	if (uhcidebug > 9) {
		printf("uhci_intr %p\n", sc);
d829 2
a830 2
	status = UREAD2(sc, UHCI_STS);
#if defined(DIAGNOSTIC) && !defined(__OpenBSD__)
d834 7
a840 9
	ret = 0;
	if (status & UHCI_STS_USBINT) {
		UWRITE2(sc, UHCI_STS, UHCI_STS_USBINT); /* acknowledge */
		ret = 1;
	}
	if (status & UHCI_STS_USBEI) {
		UWRITE2(sc, UHCI_STS, UHCI_STS_USBEI); /* acknowledge */
		ret = 1;
	}
d842 1
a842 1
		UWRITE2(sc, UHCI_STS, UHCI_STS_RD); /* acknowledge */
a843 1
		ret = 1;
d846 3
a848 3
		UWRITE2(sc, UHCI_STS, UHCI_STS_HSE); /* acknowledge */
		printf("%s: Host System Error\n", USBDEVNAME(sc->sc_bus.bdev));
		ret = 1;
d851 16
a866 8
		UWRITE2(sc, UHCI_STS, UHCI_STS_HCPE); /* acknowledge */
		printf("%s: Host System Error\n", USBDEVNAME(sc->sc_bus.bdev));
		ret = 1;
	}
	if (status & UHCI_STS_HCH)
		printf("%s: controller halted\n", USBDEVNAME(sc->sc_bus.bdev));
	if (!ret)
		return 0;
d883 4
a886 1
	return 1;
d921 1
a921 1
		for (std = ii->stdstart; std != lstd; std = std->link.std){
d937 1
a947 12
#ifdef USB_DEBUG
	DPRINTFN(10, ("uhci_idone: ii=%p ready\n", ii));
	if (uhcidebug > 10)
		uhci_dump_tds(ii->stdstart);
#endif

	if (reqh->status == USBD_CANCELLED ||
	    reqh->status == USBD_TIMEOUT) {
		DPRINTF(("uhci_idone: aborted reqh=%p\n", reqh));
		return;
	}

d961 43
d1053 2
d1056 1
d1177 1
a1177 1
		r = usb_allocmem(sc->sc_dmatag, UHCI_STD_SIZE * UHCI_STD_CHUNK,
d1223 1
a1223 1
		r = usb_allocmem(sc->sc_dmatag, UHCI_SQH_SIZE * UHCI_SQH_CHUNK,
a1369 1
	int s;
d1372 1
a1372 1
	s = splusb();
a1373 1
	splx(s);
d1376 3
a1378 2
	else
		return (uhci_device_bulk_start(reqh));
d1389 1
a1389 1
	uhci_soft_td_t *xfer, *xferend;
a1390 1
	usb_dma_t *dmap;
d1392 1
a1392 1
	int len, isread;
d1395 2
a1396 3
	DPRINTFN(3, ("uhci_device_bulk_transfer: reqh=%p buf=%p len=%d "
		     "flags=%d\n",
		     reqh, reqh->buffer, reqh->length, reqh->flags));
d1398 2
a1399 1
	if (reqh->isreq)
d1401 1
d1404 2
a1405 2
	dmap = &upipe->u.bulk.datadma;
	isread = reqh->pipe->endpoint->edesc->bEndpointAddress & UE_IN;
a1410 3
	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		goto ret1;
d1413 1
a1413 1
				 dmap, &xfer, &xferend);
d1415 2
a1416 5
		goto ret2;
	xferend->td.td_status |= LE(UHCI_TD_IOC);

	if (!isread && len != 0)
		memcpy(KERNADDR(dmap), reqh->buffer, len);
d1420 2
a1421 2
		printf("uhci_device_bulk_transfer: xfer(1)\n");
		uhci_dump_tds(xfer);
d1427 2
a1428 2
	ii->stdstart = xfer;
	ii->stdend = xferend;
d1433 2
a1434 2
	sqh->elink = xfer;
	sqh->qh.qh_elink = LE(xfer->physaddr);
d1442 2
a1443 2
		usb_timeout(uhci_timeout, ii,
                            MS_TO_TICKS(reqh->timeout), ii->timeout_handle);
d1449 2
a1450 2
		printf("uhci_device_bulk_transfer: xfer(2)\n");
		uhci_dump_tds(xfer);
a1457 6

 ret2:
	if (len != 0)
		usb_freemem(sc->sc_dmatag, dmap);
 ret1:
	return (r);
d1486 1
a1486 1
		std->td.td_status &= LE(~UHCI_TD_ACTIVE);
d1491 4
a1494 1
	if (curproc) {
a1497 3
	} else {
		/* We have no process context, so we can't use tsleep(). */
		timeout(uhci_abort_req_end, reqh, hz / USB_FRAMES_PER_SECOND);
a1530 1
	int s;
d1533 1
a1533 1
	s = splusb();
a1534 1
	splx(s);
d1537 3
a1539 2
	else
		return (uhci_device_ctrl_start(reqh));
d1549 2
a1550 1
	if (!reqh->isreq)
d1552 1
a1566 1
	int s;
d1569 1
a1569 1
	s = splusb();
a1570 1
	splx(s);
d1573 3
a1575 2
	else
		return (uhci_device_intr_start(reqh));
d1586 1
a1586 1
	uhci_soft_td_t *xfer, *xferend;
a1587 1
	usb_dma_t *dmap;
d1589 1
a1589 2
	int len, i;
	int s;
d1591 2
a1592 3
	DPRINTFN(3, ("uhci_device_intr_transfer: reqh=%p buf=%p len=%d "
		     "flags=%d\n",
		     reqh, reqh->buffer, reqh->length, reqh->flags));
d1594 2
a1595 1
	if (reqh->isreq)
d1597 1
d1599 1
a1599 9
	len = reqh->length;
	dmap = &upipe->u.intr.datadma;
	if (len == 0)
		return (USBD_INVAL); /* XXX should it be? */

	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		goto ret1;
	r = uhci_alloc_std_chain(upipe, sc, len, 1,
d1601 1
a1601 1
				 dmap, &xfer, &xferend);
d1603 2
a1604 2
		goto ret2;
	xferend->td.td_status |= LE(UHCI_TD_IOC);
d1608 2
a1609 2
		printf("uhci_device_intr_transfer: xfer(1)\n");
		uhci_dump_tds(xfer);
d1617 2
a1618 2
	ii->stdstart = xfer;
	ii->stdend = xferend;
d1627 2
a1628 2
		sqh->elink = xfer;
		sqh->qh.qh_elink = LE(xfer->physaddr);
d1634 2
a1635 2
		printf("uhci_device_intr_transfer: xfer(2)\n");
		uhci_dump_tds(xfer);
a1640 6

 ret2:
	if (len != 0)
		usb_freemem(sc->sc_dmatag, dmap);
 ret1:
	return (r);
d1724 1
a1724 1
	uhci_soft_td_t *setup, *xfer, *stat, *next, *xferend;
a1725 1
	usb_dma_t *dmap;
a1744 1
	dmap = &upipe->u.ctl.datadma;
a1747 3
		r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
		if (r != USBD_NORMAL_COMPLETION)
			goto ret1;
d1751 1
a1751 1
					 dmap, &xfer, &xferend);
d1753 4
a1756 4
			goto ret2;
		next = xfer;
		xferend->link.std = stat;
		xferend->td.td_link = LE(stat->physaddr);
a1762 2
	if (!isread && len != 0)
		memcpy(KERNADDR(dmap), reqh->buffer, len);
d1781 1
a1781 1
		printf("uhci_device_request: before transfer\n");
d1808 1
a1808 1
		printf("uhci_enter_ctl_q: follow from [0]\n");
d1822 1
a1822 1
		printf("Enqueued QH:\n");
d1834 25
a1859 4
 ret2:
	if (len != 0)
		usb_freemem(sc->sc_dmatag, dmap);
 ret1:
d1863 2
a1864 2
usbd_status
uhci_device_isoc_transfer(reqh)
a1867 1
#ifdef USB_DEBUG
d1870 16
d1888 37
a1924 3
	DPRINTFN(1,("uhci_device_isoc_transfer: sc=%p\n", sc));
	if (upipe->u.iso.bufsize == 0)
		return (USBD_INVAL);
d1926 1
a1926 2
	/* XXX copy data */
	return (USBD_XXX);
d1933 31
a1963 1
	return (USBD_XXX);
d1970 30
a1999 1
	/* XXX Can't abort this. */
d2009 1
a2026 2
		uhci_soft_td_t *std, *vstd;

d2028 1
a2028 1
		for (vstd = sc->sc_vframes[i % UHCI_VFRAMELIST_COUNT].htd;
a2043 2
	for (i = 0; i < iso->nbuf; i++)
		usb_freemem(sc->sc_dmatag, &iso->bufs[i]);
a2044 3
	free(iso->bufs, M_USBHC);

	/* XXX what else? */
d2048 1
a2048 1
uhci_device_isoc_setbuf(pipe, bufsize, nbuf)
a2049 2
	u_int bufsize;
	u_int nbuf;
d2056 3
a2058 1
	int rd = upipe->pipe.endpoint->edesc->bEndpointAddress & UE_IN;
a2060 8
	usbd_status r;

	/* 
	 * For simplicity the number of buffers must fit nicely in the frame
	 * list.
	 */
	if (UHCI_VFRAMELIST_COUNT % nbuf != 0)
		return (USBD_INVAL);
a2062 5
	iso->bufsize = bufsize;
	iso->nbuf = nbuf;

	/* Allocate memory for buffers. */
	iso->bufs = malloc(nbuf * sizeof(usb_dma_t), M_USBHC, M_WAITOK);
d2066 2
a2067 7
	for (i = 0; i < nbuf; i++) {
		r = usb_allocmem(sc->sc_dmatag, bufsize, 0, &iso->bufs[i]);
		if (r != USBD_NORMAL_COMPLETION) {
			nbuf = i;
			goto bad1;
		}
	}
d2069 1
a2069 1
	/* Allocate the TDs. */
d2071 6
a2076 3
		iso->stds[i] = uhci_alloc_std(sc);
		if (iso->stds[i] == 0)
			goto bad2;
d2079 1
a2079 5
	/* XXX check schedule */

	/* XXX interrupts */

	/* Insert TDs into schedule, all marked inactive. */
a2081 2
		uhci_soft_td_t *std, *vstd;

d2083 1
a2083 7
		std->td.td_status = LE(UHCI_TD_IOS);	/* iso, inactive */
		std->td.td_token =
		    LE(rd ? UHCI_TD_IN (0, endpt, addr, 0) :
			    UHCI_TD_OUT(0, endpt, addr, 0));
		std->td.td_buffer = LE(DMAADDR(&iso->bufs[i % nbuf]));

		vstd = sc->sc_vframes[i % UHCI_VFRAMELIST_COUNT].htd;
d2091 3
d2096 1
a2096 1
 bad2:
a2098 3
 bad1:
	for (i = 0; i < nbuf; i++)
		usb_freemem(sc->sc_dmatag, &iso->bufs[i]);
a2099 1
	free(iso->bufs, M_USBHC);
d2107 8
a2114 1
	/*uhci_intr_info_t *ii = v;*/
a2123 1
	usb_dma_t *dma;
a2128 2
	dma = &upipe->u.intr.datadma;
	memcpy(reqh->buffer, KERNADDR(dma), reqh->actlen);
d2139 1
a2139 1
		uhci_soft_td_t *xfer, *xferend;
d2144 2
a2145 2
				     dma, &xfer, &xferend);
		xferend->td.td_status |= LE(UHCI_TD_IOC);
d2149 2
a2150 2
			printf("uhci_device_intr_done: xfer(1)\n");
			uhci_dump_tds(xfer);
d2155 2
a2156 2
		ii->stdstart = xfer;
		ii->stdend = xferend;
d2162 2
a2163 2
			sqh->elink = xfer;
			sqh->qh.qh_elink = LE(xfer->physaddr);
a2165 1
		usb_freemem(sc->sc_dmatag, dma);
a2177 2
	u_int len = upipe->u.ctl.length;
	usb_dma_t *dma;
d2180 1
a2180 1
	if (!reqh->isreq)
d2188 1
a2188 4
	if (len != 0) {
		dma = &upipe->u.ctl.datadma;
		if (reqh->request.bmRequestType & UT_READ)
			memcpy(reqh->buffer, KERNADDR(dma), len);
d2190 1
a2190 2
		usb_freemem(sc->sc_dmatag, dma);
	}
a2201 2
	u_int datalen = upipe->u.bulk.length;
	usb_dma_t *dma;
a2206 4
	/* copy the data from dma memory to userland storage */
	dma = &upipe->u.bulk.datadma;
	if (upipe->u.bulk.isread)
		memcpy(reqh->buffer, KERNADDR(dma), datalen);
a2207 1
	usb_freemem(sc->sc_dmatag, dma);
d2209 1
a2209 1
	DPRINTFN(4, ("uhci_bulk_done: length=%d\n", reqh->actlen));
d2247 1
a2247 1
			printf("uhci_remove_intr: QH not found\n");
d2343 1
a2343 1
		case UE_IN | UHCI_INTR_ENDPT:
d2370 1
a2370 1
			r = usb_allocmem(sc->sc_dmatag, 
d2385 1
a2385 2
			upipe->u.iso.nbuf = 0;
			return (USBD_NORMAL_COMPLETION);
d2445 1
a2445 1
	UE_IN | UHCI_INTR_ENDPT,
a2487 1
	int s;
d2490 1
a2490 1
	s = splusb();
a2491 1
	splx(s);
d2494 3
a2496 2
	else
		return (uhci_root_ctrl_start(reqh));
d2507 1
a2507 1
	int len, value, index, status, change, l, totlen = 0;
d2511 2
a2512 1
	if (!reqh->isreq)
d2514 1
a2515 1
	buf = reqh->buffer;
d2523 8
d2826 1
d2828 1
a2865 1
	int s;
d2868 1
a2868 1
	s = splusb();
a2869 1
	splx(s);
d2872 3
a2874 2
	else
		return (uhci_root_intr_start(reqh));
a2883 8
	struct uhci_pipe *upipe = (struct uhci_pipe *)pipe;
	usb_dma_t *dmap;
	usbd_status r;
	int len;

	DPRINTFN(3, ("uhci_root_intr_transfer: reqh=%p buf=%p len=%d "
		     "flags=%d\n",
		     reqh, reqh->buffer, reqh->length, reqh->flags));
d2885 2
a2886 8
	len = reqh->length;
	dmap = &upipe->u.intr.datadma;
	if (len == 0)
		return (USBD_INVAL); /* XXX should it be? */

	r = usb_allocmem(sc->sc_dmatag, len, 0, dmap);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
@


1.3
log
@Sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhci.c,v 1.2 1999/08/16 22:08:48 fgsch Exp $	*/
/*	$NetBSD: uhci.c,v 1.34 1999/08/02 23:35:55 augustss Exp $	*/
d69 1
d94 10
a171 1
void		uhci_done __P((uhci_intr_info_t *));
d173 1
d190 2
d196 2
d202 2
d208 1
d215 1
d220 1
a225 2
void		uhci_ctrl_done __P((uhci_intr_info_t *ii));
void		uhci_bulk_done __P((uhci_intr_info_t *ii));
a230 2
void		uhci_intr_done __P((uhci_intr_info_t *ii));
void		uhci_isoc_done __P((uhci_intr_info_t *ii));
d265 1
d274 1
d284 1
d294 1
d304 1
d314 1
d356 1
a356 1
	UWRITE4(sc, UHCI_FLBASEADDR, DMAADDR(&sc->sc_dma)); /* set frame list */
d362 2
a363 2
	bsqh->qh->qh_hlink = UHCI_PTR_T;	/* end of QH chain */
	bsqh->qh->qh_elink = UHCI_PTR_T;
d370 3
a372 3
	csqh->qh->hlink = bsqh;
	csqh->qh->qh_hlink = bsqh->physaddr | UHCI_PTR_Q;
	csqh->qh->qh_elink = UHCI_PTR_T;
d385 9
a393 9
		std->td->link.sqh = sqh;
		std->td->td_link = sqh->physaddr | UHCI_PTR_Q;
		std->td->td_status = UHCI_TD_IOS;	/* iso, inactive */
		std->td->td_token = 0;
		std->td->td_buffer = 0;
		sqh->qh->hlink = csqh;
		sqh->qh->qh_hlink = csqh->physaddr | UHCI_PTR_Q;
		sqh->qh->elink = 0;
		sqh->qh->qh_elink = UHCI_PTR_T;
d401 1
a401 1
			sc->sc_pframes[j] = std->physaddr;
d427 3
a429 3
 * Must use delay() here since we are called from an interrupt
 * context, but since we are close to being inactive anyway
 * it doesn't matter.
d454 1
d457 1
a457 1
		delay(USB_RESUME_WAIT * 1000);
d470 1
a470 1
		delay(USB_RESUME_DELAY * 1000);
d475 2
a476 1
		delay(USB_RESUME_RECOVERY * 1000);
d516 4
a519 4
	       (long)p->td->td_link,
	       (long)p->td->td_status,
	       (long)p->td->td_token,
	       (long)p->td->td_buffer);
d523 1
a523 1
		       (int)p->td->td_link,
d525 1
a525 1
		       (int)p->td->td_status,
d528 7
a534 7
		       UHCI_TD_GET_ERRCNT(p->td->td_status),
		       UHCI_TD_GET_ACTLEN(p->td->td_status),
		       UHCI_TD_GET_PID(p->td->td_token),
		       UHCI_TD_GET_DEVADDR(p->td->td_token),
		       UHCI_TD_GET_ENDPT(p->td->td_token),
		       UHCI_TD_GET_DT(p->td->td_token),
		       UHCI_TD_GET_MAXLEN(p->td->td_token));
d542 1
a542 1
	       p->qh->qh_hlink, p->qh->qh_elink);
d555 1
a555 1
	uhci_dump_qh(sc->sc_ctl_start->qh->hlink);
d565 1
a565 1
	for(p = std; p; p = p->td->link.std)
d587 2
d595 6
d602 13
a615 9
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);
	if (p[0] != 0) {
		reqh->actlen = 1;
		reqh->status = USBD_NORMAL_COMPLETION;
		reqh->xfercb(reqh);
	}
	if (reqh->pipe->repeat) {
		usb_timeout(uhci_timo, reqh, sc->sc_ival, reqh->timo_handle);
	} else {
a616 3
		usb_start_next(reqh->pipe);
	}
	splx(s);
d677 1
a677 1
	uhci_qh_t *eqh;
d680 5
a684 5
	eqh = sc->sc_ctl_end->qh;
	sqh->qh->hlink     = eqh->hlink;
	sqh->qh->qh_hlink  = eqh->qh_hlink;
	eqh->hlink         = sqh;
	eqh->qh_hlink      = sqh->physaddr | UHCI_PTR_Q;
d697 1
a697 1
	for (pqh = sc->sc_ctl_start; pqh->qh->hlink != sqh; pqh=pqh->qh->hlink)
d699 1
a699 1
		if (pqh->qh->qh_hlink & UHCI_PTR_T) {
d706 2
a707 2
	pqh->qh->hlink    = sqh->qh->hlink;
	pqh->qh->qh_hlink = sqh->qh->qh_hlink;
d718 1
a718 1
	uhci_qh_t *eqh;
d721 5
a725 5
	eqh = sc->sc_bulk_end->qh;
	sqh->qh->hlink     = eqh->hlink;
	sqh->qh->qh_hlink  = eqh->qh_hlink;
	eqh->hlink         = sqh;
	eqh->qh_hlink      = sqh->physaddr | UHCI_PTR_Q;
d738 1
a738 3
	for (pqh = sc->sc_bulk_start; 
	     pqh->qh->hlink != sqh; 
	     pqh = pqh->qh->hlink)
d740 1
a740 1
		if (pqh->qh->qh_hlink & UHCI_PTR_T) {
d747 2
a748 2
	pqh->qh->hlink    = sqh->qh->hlink;
	pqh->qh->qh_hlink = sqh->qh->qh_hlink;
a825 1
	struct uhci_pipe *upipe;
d850 1
a850 1
	if (lstd->td->td_status & UHCI_TD_ACTIVE) {
d852 2
a853 2
		for (std = ii->stdstart; std != lstd; std = std->td->link.std){
			status = std->td->td_status;
a864 1
	upipe = (struct uhci_pipe *)ii->reqh->pipe;
d906 2
a907 2
	for (std = ii->stdstart; std; std = std->td->link.std) {
		status = std->td->td_status;
d910 2
a911 1
		if (UHCI_TD_GET_PID(std->td->td_token) != UHCI_TD_PID_SETUP)
d916 1
a916 1
		upipe->nexttoggle = UHCI_TD_GET_DT(std->td->td_token);
d938 2
a939 35

	uhci_done(ii);
	if (ii->reqh->pipe->intrreqh != ii->reqh)
		usb_start_next(ii->reqh->pipe);
}

void
uhci_done(ii)
	uhci_intr_info_t *ii;
{
	usbd_request_handle reqh = ii->reqh;
	usbd_pipe_handle pipe = reqh->pipe;

	DPRINTFN(5, ("uhci_ii_finish: calling handler ii=%p\n", ii));

	switch (pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) {
	case UE_CONTROL:
		uhci_ctrl_done(ii);
		break;
	case UE_ISOCHRONOUS:
		uhci_isoc_done(ii);
		break;
	case UE_BULK:
		uhci_bulk_done(ii);
		break;
	case UE_INTERRUPT:
		uhci_intr_done(ii);
		break;
	}

	/* Remove request from queue. */
	SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);

	/* And finally execute callback. */
	reqh->xfercb(reqh);
d988 2
a989 3
	if (ii)
		uhci_idone(ii);
	else
d991 2
d1068 1
a1068 1
	int i;
d1073 1
a1073 5
		std = malloc(sizeof(uhci_soft_td_t) * UHCI_TD_CHUNK, 
			     M_USBHC, M_NOWAIT);
		if (!std)
			return (0);
		r = usb_allocmem(sc->sc_dmatag, UHCI_TD_SIZE * UHCI_TD_CHUNK,
d1075 1
a1075 2
		if (r != USBD_NORMAL_COMPLETION) {
			free(std, M_USBHC);
d1077 5
a1081 6
		}
		for(i = 0; i < UHCI_TD_CHUNK; i++, std++) {
			std->physaddr = DMAADDR(&dma) + i * UHCI_TD_SIZE;
			std->td = (uhci_td_t *)
				((char *)KERNADDR(&dma) + i * UHCI_TD_SIZE);
			std->td->link.std = sc->sc_freetds;
d1086 2
a1087 2
	sc->sc_freetds = std->td->link.std;
	memset(std->td, 0, UHCI_TD_SIZE);
d1098 1
a1098 1
	if (std->td->td_token == TD_IS_FREE) {
d1102 1
a1102 1
	std->td->td_token = TD_IS_FREE;
d1104 1
a1104 1
	std->td->link.std = sc->sc_freetds;
d1119 1
a1119 5
		sqh = malloc(sizeof(uhci_soft_qh_t) * UHCI_QH_CHUNK, 
			     M_USBHC, M_NOWAIT);
		if (!sqh)
			return 0;
		r = usb_allocmem(sc->sc_dmatag, UHCI_QH_SIZE * UHCI_QH_CHUNK,
d1121 1
a1121 2
		if (r != USBD_NORMAL_COMPLETION) {
			free(sqh, M_USBHC);
d1123 3
a1125 3
		}
		for(i = 0; i < UHCI_QH_CHUNK; i++, sqh++) {
			offs = i * UHCI_QH_SIZE;
d1127 1
a1127 3
			sqh->qh = (uhci_qh_t *)
					((char *)KERNADDR(&dma) + offs);
			sqh->qh->hlink = sc->sc_freeqhs;
d1132 2
a1133 2
	sc->sc_freeqhs = sqh->qh->hlink;
	memset(sqh->qh, 0, UHCI_QH_SIZE);
d1142 1
a1142 1
	sqh->qh->hlink = sc->sc_freeqhs;
d1171 1
a1171 1
		p = std->td->link.std;
d1205 1
d1224 2
a1225 2
		p->td->link.std = lastp;
		p->td->td_link = lastlink;
d1228 1
a1228 1
		p->td->td_status = status;
d1236 4
a1239 4
		p->td->td_token = 
		    rd ? UHCI_TD_IN (l, endpt, addr, tog) :
			 UHCI_TD_OUT(l, endpt, addr, tog);
		p->td->td_buffer = DMAADDR(dma) + i * maxp;
d1316 1
a1316 1
	xferend->td->td_status |= UHCI_TD_IOC;
d1336 2
a1337 2
	sqh->qh->elink = xfer;
	sqh->qh->qh_elink = xfer->physaddr;
a1385 1
	int s;
d1388 4
a1391 1
	reqh->status = USBD_CANCELLED;
d1394 5
a1398 2
	for (std = ii->stdstart; std != 0; std = std->td->link.std)
		std->td->td_status &= ~UHCI_TD_ACTIVE;
d1400 16
a1415 1
	usb_delay_ms(reqh->pipe->device->bus, 1);
a1416 1
	/* and call final part of interrupt handler. */
d1418 1
a1418 1
	uhci_done(ii);
d1522 1
a1522 1
	xferend->td->td_status |= UHCI_TD_IOC;
d1545 2
a1546 2
		sqh->qh->elink = xfer;
		sqh->qh->qh_elink = xfer->physaddr;
d1684 2
a1685 2
		xferend->td->link.std = stat;
		xferend->td->td_link = stat->physaddr;
d1695 14
a1708 14
	setup->td->link.std = next;
	setup->td->td_link = next->physaddr;
	setup->td->td_status = UHCI_TD_SET_ERRCNT(2) | ls | UHCI_TD_ACTIVE;
	setup->td->td_token = UHCI_TD_SETUP(sizeof *req, endpt, addr);
	setup->td->td_buffer = DMAADDR(&upipe->u.ctl.reqdma);

	stat->td->link.std = 0;
	stat->td->td_link = UHCI_PTR_T;
	stat->td->td_status = UHCI_TD_SET_ERRCNT(2) | ls | 
		UHCI_TD_ACTIVE | UHCI_TD_IOC;
	stat->td->td_token = 
		isread ? UHCI_TD_OUT(0, endpt, addr, 1) :
		         UHCI_TD_IN (0, endpt, addr, 1);
	stat->td->td_buffer = 0;
d1712 2
a1713 4
		printf("uhci_device_request: setup\n");
		uhci_dump_td(setup);
		printf("uhci_device_request: stat\n");
		uhci_dump_td(stat);
d1725 2
a1726 2
	sqh->qh->elink = setup;
	sqh->qh->qh_elink = setup->physaddr;
d1742 2
a1743 2
		     std = std->td->link.std) {
			link = std->td->td_link;
d1748 2
a1749 2
		     xqh = (maxqh++ == 5 || xqh->qh->hlink==sxqh || 
                            xqh->qh->hlink==xqh ? NULL : xqh->qh->hlink)) {
d1755 1
a1755 1
		uhci_dump_tds(sqh->qh->elink);
d1824 1
a1824 1
		iso->stds[i]->td->td_status &= ~UHCI_TD_ACTIVE;
d1833 2
a1834 2
		     vstd && vstd->td->link.std != std;
		     vstd = vstd->td->link.std)
d1842 2
a1843 2
		vstd->td->link = std->td->link;
		vstd->td->td_link = std->td->td_link;
d1913 5
a1917 5
		std->td->td_status = UHCI_TD_IOS;	/* iso, inactive */
		std->td->td_token =
		    rd ? UHCI_TD_IN (0, endpt, addr, 0) :
			 UHCI_TD_OUT(0, endpt, addr, 0);
		std->td->td_buffer = DMAADDR(&iso->bufs[i % nbuf]);
d1920 4
a1923 4
		std->td->link = vstd->td->link;
		std->td->td_link = vstd->td->td_link;
		vstd->td->link.std = std;
		vstd->td->td_link = std->physaddr;
d1941 2
a1942 2
uhci_isoc_done(ii)
	uhci_intr_info_t *ii;
d1944 1
d1948 2
a1949 2
uhci_intr_done(ii)
	uhci_intr_info_t *ii;
d1951 1
a1952 1
	usbd_request_handle reqh = ii->reqh;
d1965 2
a1966 2
		sqh->qh->elink = 0;
		sqh->qh->qh_elink = UHCI_PTR_T;
d1978 1
a1978 1
		xferend->td->td_status |= UHCI_TD_IOC;
d1995 2
a1996 2
			sqh->qh->elink = xfer;
			sqh->qh->qh_elink = xfer->physaddr;
d2006 2
a2007 2
uhci_ctrl_done(ii)
	uhci_intr_info_t *ii;
d2009 1
a2010 1
	usbd_request_handle reqh = ii->reqh;
a2013 1
	uhci_td_t *htd = ii->stdstart->td;
d2028 1
a2028 1
		uhci_free_std_chain(sc, htd->link.std, ii->stdend);
d2036 2
a2037 2
uhci_bulk_done(ii)
	uhci_intr_info_t *ii;
d2039 1
a2040 1
	usbd_request_handle reqh = ii->reqh;
d2067 1
a2067 1
	uhci_qh_t *eqh;
d2070 5
a2074 5
	eqh = vf->eqh->qh;
	sqh->qh->hlink     = eqh->hlink;
	sqh->qh->qh_hlink  = eqh->qh_hlink;
	eqh->hlink         = sqh;
	eqh->qh_hlink      = sqh->physaddr | UHCI_PTR_Q;
d2091 1
a2091 1
	for (pqh = vf->hqh; pqh->qh->hlink != sqh; pqh = pqh->qh->hlink)
d2093 1
a2093 1
		if (pqh->qh->qh_hlink & UHCI_PTR_T) {
d2100 2
a2101 2
	pqh->qh->hlink    = sqh->qh->hlink;
	pqh->qh->qh_hlink = sqh->qh->qh_hlink;
d2150 2
a2151 2
		sqh->qh->elink = 0;
		sqh->qh->qh_elink = UHCI_PTR_T;
a2663 1
	SIMPLEQ_REMOVE_HEAD(&reqh->pipe->queue, reqh, next);
d2665 2
a2666 2
	reqh->xfercb(reqh);
	usb_start_next(reqh->pipe);
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhci.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
d160 2
a161 2
void		uhci_ii_done __P((uhci_intr_info_t *));
void		uhci_ii_finish __P((uhci_intr_info_t *));
d216 3
d247 1
d256 1
d265 1
d274 1
d283 1
d292 1
a390 1
	(void)powerhook_establish(uhci_power, sc);
d392 1
d463 1
a463 1
#endif
d570 2
d738 1
a738 2
#if !defined(__OpenBSD__)
#ifdef DIAGNOSTIC
a741 1
#endif
d836 1
a836 2
	uhci_ii_done(ii);
	upipe->pipe.endpoint->toggle = upipe->nexttoggle;
d840 1
a840 1
uhci_ii_done(ii)
d844 1
d850 1
a850 1
	DPRINTFN(10, ("uhci_ii_done: ii=%p ready\n", ii));
d857 1
a857 1
		DPRINTF(("uhci_ii_done: aborted reqh=%p\n", reqh));
d866 1
a866 1
			printf("uhci_ii_done: ii=%p is done!\n", ii);
d884 4
d894 1
a894 1
			 ("uhci_ii_done: error, addr=%d, endpt=0x%02x, "
d908 4
a911 1
	uhci_ii_finish(ii);
d915 1
a915 1
uhci_ii_finish(ii)
d919 1
d923 1
a923 1
	switch (reqh->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) {
a925 1
		usb_start_next(reqh->pipe);
a928 1
		usb_start_next(reqh->pipe);
a931 1
		usb_start_next(reqh->pipe);
d938 3
d992 1
a992 1
		uhci_ii_done(ii);
d1220 1
a1220 1
	tog = upipe->pipe.endpoint->toggle;
d1257 2
a1258 3
	/*upipe->pipe.endpoint->toggle = tog;*/
	DPRINTFN(10, ("uhci_alloc_std_chain: oldtog=%d nexttog=%d\n", 
		      upipe->pipe.endpoint->toggle, upipe->nexttoggle));
d1262 14
d1413 1
a1413 1
	uhci_ii_finish(ii);
d1587 4
a1590 10
	struct uhci_pipe *upipe;

	DPRINTFN(1, ("uhci_device_intr_abort: reqh=%p\n", reqh));
	/* XXX inactivate */
	usb_delay_ms(reqh->pipe->device->bus, 2); /* make sure it is done */
	if (reqh->pipe->repeat) {
		DPRINTF(("uhci_device_intr_abort: remove\n"));
		reqh->pipe->repeat = 0;
		upipe = (struct uhci_pipe *)reqh->pipe;
		uhci_intr_done(upipe->u.intr.qhs[0]->intr_info);
d1592 1
d1672 1
a1672 1
		upipe->pipe.endpoint->toggle = 1;
a1996 1
		usb_start_next(reqh->pipe);
a2038 1
	uhci_soft_td_t *std;
a2045 8
	/* find the toggle for the last transfer and invert it */
	for (std = ii->stdstart; std; std = std->td->link.std) {
		if (std->td->td_status & UHCI_TD_ACTIVE)
			break;
		upipe->nexttoggle = UHCI_TD_GET_DT(std->td->td_token);
	}
	upipe->nexttoggle ^= 1;

d2661 1
a2682 1
	usb_untimeout(uhci_timo, pipe->intrreqh, pipe->intrreqh->timo_handle);
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 3
a223 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d226 1
a228 6
#elif defined(__FreeBSD__)
#define UWRITE2(sc,r,x)	outw((sc)->sc_iobase + (r), (x))
#define UWRITE4(sc,r,x)	outl((sc)->sc_iobase + (r), (x))
#define UREAD2(sc,r)	inw((sc)->sc_iobase + (r))
#define UREAD4(sc,r)	inl((sc)->sc_iobase + (r))
#endif
d469 1
a469 1
	       UREAD2(sc, UHCI_SOF),
@

