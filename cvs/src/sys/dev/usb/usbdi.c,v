head	1.96;
access;
symbols
	OPENBSD_6_1:1.90.0.4
	OPENBSD_6_1_BASE:1.90
	OPENBSD_6_0:1.84.0.4
	OPENBSD_6_0_BASE:1.84
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.44.0.6
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.43.0.4
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.4
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.4
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.21
	UBC:1.14.0.4
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.96
date	2017.09.21.07.44.06;	author mpi;	state Exp;
branches;
next	1.95;
commitid	9UVFJU4lHbhMl1Ij;

1.95
date	2017.05.15.10.52.08;	author mpi;	state Exp;
branches;
next	1.94;
commitid	cyblrmsSmLeFugC0;

1.94
date	2017.05.10.17.35.40;	author mpi;	state Exp;
branches;
next	1.93;
commitid	hsQD7hWZyfDzbqM7;

1.93
date	2017.05.10.15.47.34;	author mpi;	state Exp;
branches;
next	1.92;
commitid	UJiCv3lLCTUTAEX2;

1.92
date	2017.05.05.11.28.48;	author jsg;	state Exp;
branches;
next	1.91;
commitid	53XKsuSTFthRd3sz;

1.91
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	6s3MfY9d6ZKdL2Uz;

1.90
date	2017.03.17.09.25.59;	author mpi;	state Exp;
branches;
next	1.89;
commitid	qf9yHdHokiYhpK0B;

1.89
date	2017.03.10.11.18.48;	author mpi;	state Exp;
branches;
next	1.88;
commitid	KVR8Na3SYXI1y1RS;

1.88
date	2017.03.10.09.14.06;	author mpi;	state Exp;
branches;
next	1.87;
commitid	3KSzSoIpPvZCUNqm;

1.87
date	2017.03.06.12.13.58;	author mpi;	state Exp;
branches;
next	1.86;
commitid	Z2yMWUkbSlYkJGBk;

1.86
date	2017.03.06.09.04.58;	author mpi;	state Exp;
branches;
next	1.85;
commitid	H0uYHlLLo5zYrO4v;

1.85
date	2016.10.04.14.12.05;	author mpi;	state Exp;
branches;
next	1.84;
commitid	NLEPWk9nQ8L8hBz6;

1.84
date	2016.06.13.11.04.44;	author mglocker;	state Exp;
branches;
next	1.83;
commitid	Q8rje5nbr7DFD1ag;

1.83
date	2015.07.10.15.47.48;	author mpi;	state Exp;
branches;
next	1.82;
commitid	BjEcbAHow6xga6pa;

1.82
date	2015.06.15.15.45.28;	author mpi;	state Exp;
branches;
next	1.81;
commitid	fJDSm2PsdeBQgvgI;

1.81
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.80;
commitid	p4LJxGKbi0BU2cG6;

1.80
date	2015.02.12.05.07.52;	author uebayasi;	state Exp;
branches;
next	1.79;
commitid	A0qGYdYjHNUfrLyb;

1.79
date	2015.01.22.10.27.47;	author mpi;	state Exp;
branches;
next	1.78;
commitid	lKfM5ejoPYfCitV4;

1.78
date	2015.01.11.15.41.16;	author mpi;	state Exp;
branches;
next	1.77;
commitid	9KVEuISegDwQu735;

1.77
date	2015.01.09.12.15.48;	author mpi;	state Exp;
branches;
next	1.76;
commitid	XU8KzH1JXZGzVtOj;

1.76
date	2015.01.09.12.07.50;	author mpi;	state Exp;
branches;
next	1.75;
commitid	SbnTte7ZSgPxxJ3B;

1.75
date	2014.11.01.00.41.33;	author mpi;	state Exp;
branches;
next	1.74;
commitid	GHOKyieN6YjrmnZf;

1.74
date	2014.10.31.12.43.33;	author mpi;	state Exp;
branches;
next	1.73;
commitid	louylZALyxXoJWVz;

1.73
date	2014.09.26.09.31.08;	author guenther;	state Exp;
branches;
next	1.72;
commitid	LbR1hPwxcbXjhHjK;

1.72
date	2014.08.10.11.00.36;	author mpi;	state Exp;
branches;
next	1.71;
commitid	EhRr39ksGEEyKpMd;

1.71
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.70;
commitid	OBNa5kfxQ2UXoiIw;

1.70
date	2014.03.07.09.38.14;	author mpi;	state Exp;
branches;
next	1.69;

1.69
date	2014.03.06.23.53.11;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.06.23.28.01;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.66;

1.66
date	2013.11.13.13.48.08;	author pirofti;	state Exp;
branches;
next	1.65;

1.65
date	2013.11.06.15.55.15;	author jeremy;	state Exp;
branches;
next	1.64;

1.64
date	2013.11.02.01.41.17;	author jeremy;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.31.20.06.59;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.31.10.12.19;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.14.08.27.54;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.09.24.09.01.41;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2013.09.06.08.29.58;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2013.08.13.09.26.04;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2013.08.08.09.37.02;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.26.14.19.25;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.26.14.05.24;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.26.13.46.40;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.19.08.58.53;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.04.19.08.54.49;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.12.13.05.56;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.11.07.50.56;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.09.08.47.56;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.16.00.04.37;	author fgsch;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.30.05.10.35;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.06.04.25.27;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.23.05.44.15;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.23.04.58.02;	author jakemsr;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.05.17.28.54;	author mk;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.11.13.51.35;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.21.22.24.45;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.11.18.30.50;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.18.11.37.04;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.31.18.20.22;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.31.19.46.44;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.14.00.32.10;	author pascoe;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.20.08.03.59;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.17.05.33.45;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.01.21.47.07;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.11.44.25;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.28.19.37.52;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.11.07.21.30.20;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.29.10.35.35;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.05;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.26;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.44.02;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.06.05.23.12.59;	author niklas;	state Exp;
branches;
next	;

1.14.4.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.96
log
@Disable a splsoftassert() at least until ohci(4) has been fixed.

This assert triggers because of the floor check on amd64/sparc64
when ohci(4) processes its root-hub status change transfers at
IPL_BIO.

Previous to the removal of IPL_SOFTNET, the SPLUSBCHECK macro didn't
do anything, so it is safe to disable this check.

Issue reported by espie@@ and krw@@
@
text
@/*	$OpenBSD: usbdi.c,v 1.95 2017/05/15 10:52:08 mpi Exp $ */
/*	$NetBSD: usbdi.c,v 1.103 2002/09/27 15:37:38 provos Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi.c,v 1.28 1999/11/17 22:33:49 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (usbdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) printf x; } while (0)
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

void usbd_request_async_cb(struct usbd_xfer *, void *, usbd_status);
void usbd_start_next(struct usbd_pipe *pipe);
usbd_status usbd_open_pipe_ival(struct usbd_interface *, u_int8_t, u_int8_t,
    struct usbd_pipe **, int);

int
usbd_is_dying(struct usbd_device *dev)
{
	return (dev->dying || dev->bus->dying);
}

void
usbd_deactivate(struct usbd_device *dev)
{
	dev->dying = 1;
}

void
usbd_ref_incr(struct usbd_device *dev)
{
	dev->ref_cnt++;
}

void
usbd_ref_decr(struct usbd_device *dev)
{
	if (--dev->ref_cnt == 0)
		wakeup(&dev->ref_cnt);
}

void
usbd_ref_wait(struct usbd_device *dev)
{
	while (dev->ref_cnt > 0)
		tsleep(&dev->ref_cnt, PWAIT, "usbref", hz * 60);
}

int
usbd_get_devcnt(struct usbd_device *dev)
{
	return (dev->ndevs);
}

void
usbd_claim_iface(struct usbd_device *dev, int ifaceidx)
{
	dev->ifaces[ifaceidx].claimed = 1;
}

int
usbd_iface_claimed(struct usbd_device *dev, int ifaceidx)
{
	return (dev->ifaces[ifaceidx].claimed);
}

#ifdef USB_DEBUG
void
usbd_dump_iface(struct usbd_interface *iface)
{
	printf("usbd_dump_iface: iface=%p\n", iface);
	if (iface == NULL)
		return;
	printf(" device=%p idesc=%p index=%d altindex=%d priv=%p\n",
	    iface->device, iface->idesc, iface->index, iface->altindex,
	    iface->priv);
}

void
usbd_dump_device(struct usbd_device *dev)
{
	printf("usbd_dump_device: dev=%p\n", dev);
	if (dev == NULL)
		return;
	printf(" bus=%p default_pipe=%p\n", dev->bus, dev->default_pipe);
	printf(" address=%d config=%d depth=%d speed=%d self_powered=%d "
	    "power=%d langid=%d\n", dev->address, dev->config, dev->depth,
	    dev->speed, dev->self_powered, dev->power, dev->langid);
}

void
usbd_dump_endpoint(struct usbd_endpoint *endp)
{
	printf("usbd_dump_endpoint: endp=%p\n", endp);
	if (endp == NULL)
		return;
	printf(" edesc=%p refcnt=%d\n", endp->edesc, endp->refcnt);
	if (endp->edesc)
		printf(" bEndpointAddress=0x%02x\n",
		    endp->edesc->bEndpointAddress);
}

void
usbd_dump_queue(struct usbd_pipe *pipe)
{
	struct usbd_xfer *xfer;

	printf("usbd_dump_queue: pipe=%p\n", pipe);
	SIMPLEQ_FOREACH(xfer, &pipe->queue, next) {
		printf("  xfer=%p\n", xfer);
	}
}

void
usbd_dump_pipe(struct usbd_pipe *pipe)
{
	printf("usbd_dump_pipe: pipe=%p\n", pipe);
	if (pipe == NULL)
		return;
	usbd_dump_iface(pipe->iface);
	usbd_dump_device(pipe->device);
	usbd_dump_endpoint(pipe->endpoint);
	printf(" (usbd_dump_pipe:)\n running=%d aborting=%d\n",
	    pipe->running, pipe->aborting);
	printf(" intrxfer=%p, repeat=%d, interval=%d\n", pipe->intrxfer,
	    pipe->repeat, pipe->interval);
}
#endif

usbd_status
usbd_open_pipe(struct usbd_interface *iface, u_int8_t address, u_int8_t flags,
    struct usbd_pipe **pipe)
{
	return (usbd_open_pipe_ival(iface, address, flags, pipe,
	    USBD_DEFAULT_INTERVAL));
}

usbd_status
usbd_open_pipe_ival(struct usbd_interface *iface, u_int8_t address,
    u_int8_t flags, struct usbd_pipe **pipe, int ival)
{
	struct usbd_pipe *p;
	struct usbd_endpoint *ep;
	usbd_status err;
	int i;

	DPRINTFN(3,("usbd_open_pipe: iface=%p address=0x%x flags=0x%x\n",
	    iface, address, flags));

	for (i = 0; i < iface->idesc->bNumEndpoints; i++) {
		ep = &iface->endpoints[i];
		if (ep->edesc == NULL)
			return (USBD_IOERROR);
		if (ep->edesc->bEndpointAddress == address)
			goto found;
	}
	return (USBD_BAD_ADDRESS);
 found:
	if ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)
		return (USBD_IN_USE);
	err = usbd_setup_pipe(iface->device, iface, ep, ival, &p);
	if (err)
		return (err);
	LIST_INSERT_HEAD(&iface->pipes, p, next);
	*pipe = p;
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_open_pipe_intr(struct usbd_interface *iface, u_int8_t address,
    u_int8_t flags, struct usbd_pipe **pipe, void *priv,
    void *buffer, u_int32_t len, usbd_callback cb, int ival)
{
	usbd_status err;
	struct usbd_xfer *xfer;
	struct usbd_pipe *ipipe;

	DPRINTFN(3,("usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\n",
	    address, flags, len));

	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, &ipipe,
	    ival);
	if (err)
		return (err);
	xfer = usbd_alloc_xfer(iface->device);
	if (xfer == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	usbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,
	    USBD_NO_TIMEOUT, cb);
	ipipe->intrxfer = xfer;
	ipipe->repeat = 1;
	err = usbd_transfer(xfer);
	*pipe = ipipe;
	if (err != USBD_IN_PROGRESS)
		goto bad2;
	return (USBD_NORMAL_COMPLETION);

 bad2:
	ipipe->intrxfer = NULL;
	ipipe->repeat = 0;
	usbd_free_xfer(xfer);
 bad1:
	usbd_close_pipe(ipipe);
	return (err);
}

usbd_status
usbd_close_pipe(struct usbd_pipe *pipe)
{
#ifdef DIAGNOSTIC
	if (pipe == NULL) {
		printf("usbd_close_pipe: pipe==NULL\n");
		return (USBD_NORMAL_COMPLETION);
	}
#endif

	if (!SIMPLEQ_EMPTY(&pipe->queue))
		usbd_abort_pipe(pipe);

	/* Default pipes are never linked */
	if (pipe->iface != NULL)
		LIST_REMOVE(pipe, next);
	pipe->endpoint->refcnt--;
	pipe->methods->close(pipe);
	if (pipe->intrxfer != NULL)
		usbd_free_xfer(pipe->intrxfer);
	free(pipe, M_USB, pipe->pipe_size);
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
usbd_transfer(struct usbd_xfer *xfer)
{
	struct usbd_pipe *pipe = xfer->pipe;
	struct usbd_bus *bus = pipe->device->bus;
	int polling = bus->use_polling;
	usbd_status err;
	int flags, s;

	if (usbd_is_dying(pipe->device))
		return (USBD_IOERROR);

	DPRINTFN(5,("usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\n",
	    xfer, xfer->flags, pipe, pipe->running));
#ifdef USB_DEBUG
	if (usbdebug > 5)
		usbd_dump_queue(pipe);
#endif
	xfer->done = 0;

	if (pipe->aborting)
		return (USBD_CANCELLED);

	/* If there is no buffer, allocate one. */
	if ((xfer->rqflags & URQ_DEV_DMABUF) == 0) {
#ifdef DIAGNOSTIC
		if (xfer->rqflags & URQ_AUTO_DMABUF)
			printf("usbd_transfer: has old buffer!\n");
#endif
		err = usb_allocmem(bus, xfer->length, 0, &xfer->dmabuf);
		if (err)
			return (err);
		xfer->rqflags |= URQ_AUTO_DMABUF;
	}

	if (!usbd_xfer_isread(xfer)) {
		if ((xfer->flags & USBD_NO_COPY) == 0)
			memcpy(KERNADDR(&xfer->dmabuf, 0), xfer->buffer,
			    xfer->length);
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    BUS_DMASYNC_PREWRITE);
	} else
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    BUS_DMASYNC_PREREAD);

	err = pipe->methods->transfer(xfer);

	if (err != USBD_IN_PROGRESS && err != USBD_NORMAL_COMPLETION) {
		/* The transfer has not been queued, so free buffer. */
		if (xfer->rqflags & URQ_AUTO_DMABUF) {
			usb_freemem(bus, &xfer->dmabuf);
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
		}
	}

	if (!(xfer->flags & USBD_SYNCHRONOUS))
		return (err);

	/* Sync transfer, wait for completion. */
	if (err != USBD_IN_PROGRESS)
		return (err);

	s = splusb();
	if (polling) {
		int timo;

		for (timo = xfer->timeout; timo >= 0; timo--) {
			usb_delay_ms(bus, 1);
			if (bus->dying) {
				xfer->status = USBD_IOERROR;
				usb_transfer_complete(xfer);
				break;
			}

			usbd_dopoll(pipe->device);
			if (xfer->done)
				break;
		}

		if (timo < 0) {
			xfer->status = USBD_TIMEOUT;
			usb_transfer_complete(xfer);
		}
	} else {
		while (!xfer->done) {
			flags = PRIBIO|(xfer->flags & USBD_CATCH ? PCATCH : 0);

			err = tsleep(xfer, flags, "usbsyn", 0);
			if (err && !xfer->done) {
				usbd_abort_pipe(pipe);
				if (err == EINTR)
					xfer->status = USBD_INTERRUPTED;
				else
					xfer->status = USBD_TIMEOUT;
			}
		}
	}
	splx(s);
	return (xfer->status);
}

void *
usbd_alloc_buffer(struct usbd_xfer *xfer, u_int32_t size)
{
	struct usbd_bus *bus = xfer->device->bus;
	usbd_status err;

#ifdef DIAGNOSTIC
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		printf("usbd_alloc_buffer: xfer already has a buffer\n");
#endif
	err = usb_allocmem(bus, size, 0, &xfer->dmabuf);
	if (err)
		return (NULL);
	xfer->rqflags |= URQ_DEV_DMABUF;
	return (KERNADDR(&xfer->dmabuf, 0));
}

void
usbd_free_buffer(struct usbd_xfer *xfer)
{
#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {
		printf("usbd_free_buffer: no buffer\n");
		return;
	}
#endif
	xfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);
	usb_freemem(xfer->device->bus, &xfer->dmabuf);
}

struct usbd_xfer *
usbd_alloc_xfer(struct usbd_device *dev)
{
	struct usbd_xfer *xfer;

	xfer = dev->bus->methods->allocx(dev->bus);
	if (xfer == NULL)
		return (NULL);
#ifdef DIAGNOSTIC
	xfer->busy_free = XFER_FREE;
#endif
	xfer->device = dev;
	timeout_set(&xfer->timeout_handle, NULL, NULL);
	DPRINTFN(5,("usbd_alloc_xfer() = %p\n", xfer));
	return (xfer);
}

void
usbd_free_xfer(struct usbd_xfer *xfer)
{
	DPRINTFN(5,("usbd_free_xfer: %p\n", xfer));
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		usbd_free_buffer(xfer);
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_FREE) {
		printf("%s: xfer=%p not free\n", __func__, xfer);
		return;
	}
#endif
	xfer->device->bus->methods->freex(xfer->device->bus, xfer);
}

void
usbd_setup_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    void *priv, void *buffer, u_int32_t length, u_int16_t flags,
    u_int32_t timeout, usbd_callback callback)
{
	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->nframes = 0;
}

void
usbd_setup_default_xfer(struct usbd_xfer *xfer, struct usbd_device *dev,
    void *priv, u_int32_t timeout, usb_device_request_t *req,
    void *buffer, u_int32_t length, u_int16_t flags, usbd_callback callback)
{
	xfer->pipe = dev->default_pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->request = *req;
	xfer->rqflags |= URQ_REQUEST;
	xfer->nframes = 0;
}

void
usbd_setup_isoc_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    void *priv, u_int16_t *frlengths, u_int32_t nframes,
    u_int16_t flags, usbd_callback callback)
{
	int i;

	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = 0;
	xfer->length = 0;
	for (i = 0; i < nframes; i++)
		xfer->length += frlengths[i];
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = USBD_NO_TIMEOUT;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->frlengths = frlengths;
	xfer->nframes = nframes;
}

void
usbd_get_xfer_status(struct usbd_xfer *xfer, void **priv,
    void **buffer, u_int32_t *count, usbd_status *status)
{
	if (priv != NULL)
		*priv = xfer->priv;
	if (buffer != NULL)
		*buffer = xfer->buffer;
	if (count != NULL)
		*count = xfer->actlen;
	if (status != NULL)
		*status = xfer->status;
}

usb_config_descriptor_t *
usbd_get_config_descriptor(struct usbd_device *dev)
{
#ifdef DIAGNOSTIC
	if (dev == NULL) {
		printf("usbd_get_config_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
	return (dev->cdesc);
}

usb_interface_descriptor_t *
usbd_get_interface_descriptor(struct usbd_interface *iface)
{
#ifdef DIAGNOSTIC
	if (iface == NULL) {
		printf("usbd_get_interface_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
	return (iface->idesc);
}

usb_device_descriptor_t *
usbd_get_device_descriptor(struct usbd_device *dev)
{
	return (&dev->ddesc);
}

usb_endpoint_descriptor_t *
usbd_interface2endpoint_descriptor(struct usbd_interface *iface, u_int8_t index)
{
	if (index >= iface->idesc->bNumEndpoints)
		return (0);
	return (iface->endpoints[index].edesc);
}

void
usbd_abort_pipe(struct usbd_pipe *pipe)
{
	struct usbd_xfer *xfer;
	int s;

#ifdef DIAGNOSTIC
	if (pipe == NULL) {
		printf("usbd_abort_pipe: pipe==NULL\n");
		return;
	}
#endif
	s = splusb();
	DPRINTFN(2,("%s: pipe=%p\n", __func__, pipe));
#ifdef USB_DEBUG
	if (usbdebug > 5)
		usbd_dump_queue(pipe);
#endif
	pipe->repeat = 0;
	pipe->aborting = 1;
	while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
		DPRINTFN(2,("%s: pipe=%p xfer=%p (methods=%p)\n", __func__,
		    pipe, xfer, pipe->methods));
		/* Make the HC abort it (and invoke the callback). */
		pipe->methods->abort(xfer);
		/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */
	}
	pipe->aborting = 0;
	splx(s);
}

usbd_status
usbd_clear_endpoint_stall(struct usbd_pipe *pipe)
{
	struct usbd_device *dev = pipe->device;
	usb_device_request_t req;
	usbd_status err;

	DPRINTFN(8, ("usbd_clear_endpoint_stall\n"));

	/*
	 * Clearing en endpoint stall resets the endpoint toggle, so
	 * do the same to the HC toggle.
	 */
	usbd_clear_endpoint_toggle(pipe);

	req.bmRequestType = UT_WRITE_ENDPOINT;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, UF_ENDPOINT_HALT);
	USETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);
	USETW(req.wLength, 0);
	err = usbd_do_request(dev, &req, 0);

	return (err);
}

usbd_status
usbd_clear_endpoint_stall_async(struct usbd_pipe *pipe)
{
	struct usbd_device *dev = pipe->device;
	struct usbd_xfer *xfer;
	usb_device_request_t req;
	usbd_status err;

	usbd_clear_endpoint_toggle(pipe);

	req.bmRequestType = UT_WRITE_ENDPOINT;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, UF_ENDPOINT_HALT);
	USETW(req.wIndex, pipe->endpoint->edesc->bEndpointAddress);
	USETW(req.wLength, 0);

	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
		return (USBD_NOMEM);

	err = usbd_request_async(xfer, &req, NULL, NULL);
	return (err);
}

void
usbd_clear_endpoint_toggle(struct usbd_pipe *pipe)
{
	if (pipe->methods->cleartoggle != NULL)
		pipe->methods->cleartoggle(pipe);
}

usbd_status
usbd_device2interface_handle(struct usbd_device *dev, u_int8_t ifaceno,
    struct usbd_interface **iface)
{
	if (dev->cdesc == NULL)
		return (USBD_NOT_CONFIGURED);
	if (ifaceno >= dev->cdesc->bNumInterface)
		return (USBD_INVAL);
	*iface = &dev->ifaces[ifaceno];
	return (USBD_NORMAL_COMPLETION);
}

/* XXXX use altno */
usbd_status
usbd_set_interface(struct usbd_interface *iface, int altidx)
{
	usb_device_request_t req;
	usbd_status err;
	void *endpoints;

	if (LIST_FIRST(&iface->pipes) != 0)
		return (USBD_IN_USE);

	endpoints = iface->endpoints;
	err = usbd_fill_iface_data(iface->device, iface->index, altidx);
	if (err)
		return (err);

	/* new setting works, we can free old endpoints */
	if (endpoints != NULL)
		free(endpoints, M_USB, 0);

#ifdef DIAGNOSTIC
	if (iface->idesc == NULL) {
		printf("usbd_set_interface: NULL pointer\n");
		return (USBD_INVAL);
	}
#endif

	req.bmRequestType = UT_WRITE_INTERFACE;
	req.bRequest = UR_SET_INTERFACE;
	USETW(req.wValue, iface->idesc->bAlternateSetting);
	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
	USETW(req.wLength, 0);
	return (usbd_do_request(iface->device, &req, 0));
}

int
usbd_get_no_alts(usb_config_descriptor_t *cdesc, int ifaceno)
{
	char *p = (char *)cdesc;
	char *end = p + UGETW(cdesc->wTotalLength);
	usb_interface_descriptor_t *d;
	int n;

	for (n = 0; p < end; p += d->bLength) {
		d = (usb_interface_descriptor_t *)p;
		if (p + d->bLength <= end &&
		    d->bDescriptorType == UDESC_INTERFACE &&
		    d->bInterfaceNumber == ifaceno)
			n++;
	}
	return (n);
}

int
usbd_get_interface_altindex(struct usbd_interface *iface)
{
	return (iface->altindex);
}

/*** Internal routines ***/

/* Called at splusb() */
void
usb_transfer_complete(struct usbd_xfer *xfer)
{
	struct usbd_pipe *pipe = xfer->pipe;
	int polling = pipe->device->bus->use_polling;
	int status, flags;

#if 0
	/* XXX ohci_intr1() calls usb_transfer_complete() for RHSC. */
	splsoftassert(IPL_SOFTUSB);
#endif

	DPRINTFN(5, ("usb_transfer_complete: pipe=%p xfer=%p status=%d "
		     "actlen=%d\n", pipe, xfer, xfer->status, xfer->actlen));
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_ONQU) {
		printf("%s: xfer=%p not on queue\n", __func__, xfer);
		return;
	}
#endif

	/* XXXX */
	if (polling)
		pipe->running = 0;

#ifdef DIAGNOSTIC
	if (xfer->actlen > xfer->length) {
		printf("%s: actlen > len %u > %u\n", __func__, xfer->actlen,
		    xfer->length);
		xfer->actlen = xfer->length;
	}
#endif

	if (xfer->actlen != 0) {
		if (usbd_xfer_isread(xfer)) {
			usb_syncmem(&xfer->dmabuf, 0, xfer->actlen,
			    BUS_DMASYNC_POSTREAD);
			if (!(xfer->flags & USBD_NO_COPY))
				memcpy(xfer->buffer, KERNADDR(&xfer->dmabuf, 0),
				    xfer->actlen);
		} else
			usb_syncmem(&xfer->dmabuf, 0, xfer->actlen,
			    BUS_DMASYNC_POSTWRITE);
	}

	/* if we allocated the buffer in usbd_transfer() we free it here. */
	if (xfer->rqflags & URQ_AUTO_DMABUF) {
		if (!pipe->repeat) {
			usb_freemem(pipe->device->bus, &xfer->dmabuf);
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
		}
	}

	if (!pipe->repeat) {
		/* Remove request from queue. */
#ifdef DIAGNOSTIC
		if (xfer != SIMPLEQ_FIRST(&pipe->queue))
			printf("usb_transfer_complete: bad dequeue %p != %p\n",
			    xfer, SIMPLEQ_FIRST(&pipe->queue));
		xfer->busy_free = XFER_FREE;
#endif
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, next);
	}
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
	    pipe->repeat, SIMPLEQ_FIRST(&pipe->queue)));

	/* Count completed transfers. */
	++pipe->device->bus->stats.uds_requests
		[pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE];

	xfer->done = 1;
	if (!xfer->status && xfer->actlen < xfer->length &&
	    !(xfer->flags & USBD_SHORT_XFER_OK)) {
		DPRINTFN(-1,("usb_transfer_complete: short transfer %d<%d\n",
		    xfer->actlen, xfer->length));
		xfer->status = USBD_SHORT_XFER;
	}

	/*
	 * We cannot dereference ``xfer'' after calling the callback as
	 * it might free it.
	 */
	status = xfer->status;
	flags = xfer->flags;

	if (pipe->repeat) {
		if (xfer->callback)
			xfer->callback(xfer, xfer->priv, xfer->status);
		pipe->methods->done(xfer);
	} else {
		pipe->methods->done(xfer);
		if (xfer->callback)
			xfer->callback(xfer, xfer->priv, xfer->status);
	}

	if ((flags & USBD_SYNCHRONOUS) && !polling)
		wakeup(xfer);

	if (!pipe->repeat) {
		/* XXX should we stop the queue on all errors? */
		if ((status == USBD_CANCELLED || status == USBD_IOERROR ||
		     status == USBD_TIMEOUT) &&
		    pipe->iface != NULL)		/* not control pipe */
			pipe->running = 0;
		else
			usbd_start_next(pipe);
	}
}

usbd_status
usb_insert_transfer(struct usbd_xfer *xfer)
{
	struct usbd_pipe *pipe = xfer->pipe;
	usbd_status err;
	int s;

	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d timeout=%d\n",
	    pipe, pipe->running, xfer->timeout));
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_FREE) {
		printf("%s: xfer=%p not free\n", __func__, xfer);
		return (USBD_INVAL);
	}
	xfer->busy_free = XFER_ONQU;
#endif
	s = splusb();
	SIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);
	if (pipe->running)
		err = USBD_IN_PROGRESS;
	else {
		pipe->running = 1;
		err = USBD_NORMAL_COMPLETION;
	}
	splx(s);
	return (err);
}

/* Called at splusb() */
void
usbd_start_next(struct usbd_pipe *pipe)
{
	struct usbd_xfer *xfer;
	usbd_status err;

	splsoftassert(IPL_SOFTUSB);

#ifdef DIAGNOSTIC
	if (pipe == NULL) {
		printf("usbd_start_next: pipe == NULL\n");
		return;
	}
	if (pipe->methods == NULL || pipe->methods->start == NULL) {
		printf("usbd_start_next: pipe=%p no start method\n", pipe);
		return;
	}
#endif

	/* Get next request in queue. */
	xfer = SIMPLEQ_FIRST(&pipe->queue);
	DPRINTFN(5, ("usbd_start_next: pipe=%p, xfer=%p\n", pipe, xfer));
	if (xfer == NULL) {
		pipe->running = 0;
	} else {
		err = pipe->methods->start(xfer);
		if (err != USBD_IN_PROGRESS) {
			printf("usbd_start_next: error=%d\n", err);
			pipe->running = 0;
			/* XXX do what? */
		}
	}
}

usbd_status
usbd_do_request(struct usbd_device *dev, usb_device_request_t *req, void *data)
{
	return (usbd_do_request_flags(dev, req, data, 0, 0,
	    USBD_DEFAULT_TIMEOUT));
}

usbd_status
usbd_do_request_flags(struct usbd_device *dev, usb_device_request_t *req,
    void *data, uint16_t flags, int *actlen, uint32_t timeout)
{
	struct usbd_xfer *xfer;
	usbd_status err;

#ifdef DIAGNOSTIC
	if (dev->bus->intr_context) {
		printf("usbd_do_request: not in process context\n");
		return (USBD_INVAL);
	}
#endif

	/* If the bus is gone, don't go any further. */
	if (usbd_is_dying(dev))
		return (USBD_IOERROR);

	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
		return (USBD_NOMEM);
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req, data,
	    UGETW(req->wLength), flags | USBD_SYNCHRONOUS, 0);
	err = usbd_transfer(xfer);
	if (actlen != NULL)
		*actlen = xfer->actlen;
	if (err == USBD_STALLED) {
		/*
		 * The control endpoint has stalled.  Control endpoints
		 * should not halt, but some may do so anyway so clear
		 * any halt condition.
		 */
		usb_device_request_t treq;
		usb_status_t status;
		u_int16_t s;
		usbd_status nerr;

		treq.bmRequestType = UT_READ_ENDPOINT;
		treq.bRequest = UR_GET_STATUS;
		USETW(treq.wValue, 0);
		USETW(treq.wIndex, 0);
		USETW(treq.wLength, sizeof(usb_status_t));
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
		    &treq, &status, sizeof(usb_status_t), USBD_SYNCHRONOUS, 0);
		nerr = usbd_transfer(xfer);
		if (nerr)
			goto bad;
		s = UGETW(status.wStatus);
		DPRINTF(("usbd_do_request: status = 0x%04x\n", s));
		if (!(s & UES_HALT))
			goto bad;
		treq.bmRequestType = UT_WRITE_ENDPOINT;
		treq.bRequest = UR_CLEAR_FEATURE;
		USETW(treq.wValue, UF_ENDPOINT_HALT);
		USETW(treq.wIndex, 0);
		USETW(treq.wLength, 0);
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
		    &treq, &status, 0, USBD_SYNCHRONOUS, 0);
		nerr = usbd_transfer(xfer);
		if (nerr)
			goto bad;
	}

 bad:
	usbd_free_xfer(xfer);
	return (err);
}

void
usbd_request_async_cb(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	usbd_free_xfer(xfer);
}

/*
 * Execute a request without waiting for completion.
 * Can be used from interrupt context.
 */
usbd_status
usbd_request_async(struct usbd_xfer *xfer, usb_device_request_t *req,
    void *priv, usbd_callback callback)
{
	usbd_status err;

	if (callback == NULL)
		callback = usbd_request_async_cb;

	usbd_setup_default_xfer(xfer, xfer->device, priv,
	    USBD_DEFAULT_TIMEOUT, req, NULL, UGETW(req->wLength),
	    USBD_NO_COPY, callback);
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		usbd_free_xfer(xfer);
		return (err);
	}
	return (USBD_NORMAL_COMPLETION);
}

const struct usbd_quirks *
usbd_get_quirks(struct usbd_device *dev)
{
#ifdef DIAGNOSTIC
	if (dev == NULL) {
		printf("usbd_get_quirks: dev == NULL\n");
		return 0;
	}
#endif
	return (dev->quirks);
}

/* XXX do periodic free() of free list */

/*
 * Called from keyboard driver when in polling mode.
 */
void
usbd_dopoll(struct usbd_device *udev)
{
	udev->bus->methods->do_poll(udev->bus);
}

void
usbd_set_polling(struct usbd_device *dev, int on)
{
	if (on)
		dev->bus->use_polling++;
	else
		dev->bus->use_polling--;
	/* When polling we need to make sure there is nothing pending to do. */
	if (dev->bus->use_polling)
		dev->bus->methods->soft_intr(dev->bus);
}

usb_endpoint_descriptor_t *
usbd_get_endpoint_descriptor(struct usbd_interface *iface, u_int8_t address)
{
	struct usbd_endpoint *ep;
	int i;

	for (i = 0; i < iface->idesc->bNumEndpoints; i++) {
		ep = &iface->endpoints[i];
		if (ep->edesc->bEndpointAddress == address)
			return (iface->endpoints[i].edesc);
	}
	return (0);
}

/*
 * usbd_ratecheck() can limit the number of error messages that occurs.
 * When a device is unplugged it may take up to 0.25s for the hub driver
 * to notice it.  If the driver continuously tries to do I/O operations
 * this can generate a large number of messages.
 */
int
usbd_ratecheck(struct timeval *last)
{
	static struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/

	return (ratecheck(last, &errinterval));
}

/*
 * Search for a vendor/product pair in an array.  The item size is
 * given as an argument.
 */
const struct usb_devno *
usbd_match_device(const struct usb_devno *tbl, u_int nentries, u_int sz,
    u_int16_t vendor, u_int16_t product)
{
	while (nentries-- > 0) {
		u_int16_t tproduct = tbl->ud_product;
		if (tbl->ud_vendor == vendor &&
		    (tproduct == product || tproduct == USB_PRODUCT_ANY))
			return (tbl);
		tbl = (const struct usb_devno *)((const char *)tbl + sz);
	}
	return (NULL);
}

void
usbd_desc_iter_init(struct usbd_device *dev, struct usbd_desc_iter *iter)
{
	const usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);

	iter->cur = (const uByte *)cd;
	iter->end = (const uByte *)cd + UGETW(cd->wTotalLength);
}

const usb_descriptor_t *
usbd_desc_iter_next(struct usbd_desc_iter *iter)
{
	const usb_descriptor_t *desc;

	if (iter->cur + sizeof(usb_descriptor_t) >= iter->end) {
		if (iter->cur != iter->end)
			printf("usbd_desc_iter_next: bad descriptor\n");
		return NULL;
	}
	desc = (const usb_descriptor_t *)iter->cur;
	if (desc->bLength == 0) {
		printf("usbd_desc_iter_next: descriptor length = 0\n");
		return NULL;
	}
	iter->cur += desc->bLength;
	if (iter->cur > iter->end) {
		printf("usbd_desc_iter_next: descriptor length too large\n");
		return NULL;
	}
	return desc;
}

int
usbd_str(usb_string_descriptor_t *p, int l, const char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2 * i + 2);
}
@


1.95
log
@Replace remaining SPLUSBCHECK by a splsoftassert(IPL_SOFTUSB).

USB is the last real user of IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.94 2017/05/10 17:35:40 mpi Exp $ */
d721 2
d724 1
@


1.94
log
@It is unsafe to dereference ``xfer'' after calling the callback as it
might free it.

Prevent a use-after-free in various aynchronous cases.  Found while
looking at another user-after-free pointed out by ehrhardt@@.

Committing now to find if other drivers rely on this use-after-free.

tb@@ confirmed ubcmtp(4) is now fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.93 2017/05/10 15:47:34 mpi Exp $ */
d721 1
a721 1
	SPLUSBCHECK;
d855 1
a855 1
	SPLUSBCHECK;
@


1.93
log
@Revert r1.61 and partially 1.60.  The resulting logic is currently a
noop and prevent us from fixing real use-after-free.

Since xfer->status is reset by *_device_intr_done(), checking for
USBD_IOERROR cannot be true.

Problem reported by tb@@ because ubcmtp(4) triggers some I/O errors
when multiple fingers are used.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.92 2017/05/05 11:28:48 jsg Exp $ */
d719 1
d789 7
d806 1
a806 1
	if ((xfer->flags & USBD_SYNCHRONOUS) && !polling)
d811 2
a812 3
		if ((xfer->status == USBD_CANCELLED ||
		     xfer->status == USBD_IOERROR ||
		     xfer->status == USBD_TIMEOUT) &&
@


1.92
log
@Remove a DIAGNOSTIC test for a NULL pipe value inside a transfer,
mpi says a transfer can't exist without a pipe.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.91 2017/04/08 02:57:25 deraadt Exp $ */
a796 9

	/*
	 * If we already got an I/O error that generally means the
	 * device is gone or not responding, so don't try to enqueue
	 * a new transfer as it will more likely results in the same
	 * error.
	 */
	if (xfer->status == USBD_IOERROR)
		pipe->repeat = 0;
@


1.91
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.90 2017/03/17 09:25:59 mpi Exp $ */
a730 6
#ifdef DIAGNOSTIC
	if (pipe == NULL) {
		printf("usb_transfer_complete: pipe==0, xfer=%p\n", xfer);
		return;
	}
#endif
@


1.90
log
@ubcmtp(4) works because of a use-after-free.  Many more drivers are
certainly doing the same.

So revert r1.85 for the moment, we're too close from the release and
these bugs have been there for years.

Regression reported by tb@@ on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.89 2017/03/10 11:18:48 mpi Exp $ */
d274 1
a274 1
	free(pipe, M_USB, 0);
a1124 1

@


1.89
log
@Fix a use-after-free when sending root hub control transfers.

*_root_ctrl_start() routines are synchronous and all end up calling
usb_transfer_complete() in the non-error case.  After calling this
function it is unsafe to dereference ``xfer'' since the transfer
callback has been called.  So returning USBD_IN_PROGRESS is wrong in
this case since transfers are always completed at this point.

So return USBD_NORMAL_COMPLETION or the corresponding error code if
something wrong happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.88 2017/03/10 09:14:06 mpi Exp $ */
a718 1
	int status, flags;
a793 7
	/*
	 * We cannot dereference ``xfer'' after calling the callback as
	 * it might free it.
	 */
	status = xfer->status;
	flags = xfer->flags;

d810 1
a810 1
	if (status == USBD_IOERROR)
d813 1
a813 1
	if ((flags & USBD_SYNCHRONOUS) && !polling)
d818 3
a820 2
		if ((status == USBD_CANCELLED || status == USBD_IOERROR ||
		     status == USBD_TIMEOUT) &&
@


1.88
log
@Move per HC polling code to the stack.

This code contains a use-after-free which be addressed in an upcoming
diff.

This fix xhci(4) polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.87 2017/03/06 12:13:58 mpi Exp $ */
d325 1
a325 1
	if (err != USBD_IN_PROGRESS && err) {
@


1.87
log
@Do not print uninitialized variable in DPRINTFN().

From Christian Ludwig.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.86 2017/03/06 09:04:58 mpi Exp $ */
d282 2
a302 2
		struct usbd_bus *bus = pipe->device->bus;

a327 2
			struct usbd_bus *bus = pipe->device->bus;

d339 1
d341 32
a372 12
	while (!xfer->done) {
		if (pipe->device->bus->use_polling)
			panic("usbd_transfer: not done");
		flags = PRIBIO | (xfer->flags & USBD_CATCH ? PCATCH : 0);

		err = tsleep(xfer, flags, "usbsyn", 0);
		if (err && !xfer->done) {
			usbd_abort_pipe(pipe);
			if (err == EINTR)
				xfer->status = USBD_INTERRUPTED;
			else
				xfer->status = USBD_TIMEOUT;
@


1.86
log
@It is unsafe to dereference ``xfer'' after calling the callback as it
might free it.

Prevent a use-after-free in various aynchronous cases.  Found while
looking at another user-after-free pointed out by ehrhardt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.85 2016/10/04 14:12:05 mpi Exp $ */
d705 1
a705 1
		     "actlen=%d\n", pipe, xfer, status, xfer->actlen));
@


1.85
log
@Let the stack perform DMA synchronization instead of doing it (partially)
in HC drivers.

Only ehci(4) was performing pre & post synchronization completly.  Now
pre-synchronization is done in usbd_transfer() and post-synchronization
in usbd_transfer_complete().  This will allow us to remove the partial
synchronization primitives from the pipe handlers.

This is similar to what FreeBSD did in r158998, r164519 and r176203.

From Marius Strobl.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.84 2016/06/13 11:04:44 mglocker Exp $ */
d699 2
a700 1
	int polling;
d705 1
a705 1
		     "actlen=%d\n", pipe, xfer, xfer->status, xfer->actlen));
a718 1
	polling = pipe->device->bus->use_polling;
d776 7
d799 1
a799 1
	if (xfer->status == USBD_IOERROR)
d802 1
a802 1
	if ((xfer->flags & USBD_SYNCHRONOUS) && !polling)
d807 2
a808 3
		if ((xfer->status == USBD_CANCELLED ||
		     xfer->status == USBD_IOERROR ||
		     xfer->status == USBD_TIMEOUT) &&
@


1.84
log
@Remove the restriction for the usbd_ref_* functions to work just in case
of dev->dying.  With this we also can use them on device closing, not just
detaching.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.83 2015/07/10 15:47:48 mpi Exp $ */
d313 9
a321 3
	/* Copy data if going out. */
	if (((xfer->flags & USBD_NO_COPY) == 0) && !usbd_xfer_isread(xfer))
		memcpy(KERNADDR(&xfer->dmabuf, 0), xfer->buffer, xfer->length);
d730 11
a740 3
	if (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&
	    usbd_xfer_isread(xfer)) {
		memcpy(xfer->buffer, KERNADDR(&xfer->dmabuf, 0), xfer->actlen);
@


1.83
log
@usbd_{endpoint,interface}_count() are no longer used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.82 2015/06/15 15:45:28 mpi Exp $ */
d83 1
a83 1
	if (--dev->ref_cnt == 0 && dev->dying)
@


1.82
log
@Set the length of isochronous transfers as the sum of the frames lengths.

This reduces differences between non-isoch and isoch transfers submissions,
makes the generic DMA buffer overrun check work with isoch transfers and
will allow some code simplifications in HC drivers.

Since short-transfers were never checked for isoch transfers, we now need to
pass the USBD_SHORT_XFER_OK flag to not change this behavior.  This might be
revisited later.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.81 2015/03/14 03:38:50 jsg Exp $ */
a612 22
}

int
usbd_endpoint_count(struct usbd_interface *iface, u_int8_t *count)
{
#ifdef DIAGNOSTIC
	if (iface == NULL || iface->idesc == NULL) {
		printf("usbd_endpoint_count: NULL pointer\n");
		return (1);
	}
#endif
	*count = iface->idesc->bNumEndpoints;
	return (0);
}

int
usbd_interface_count(struct usbd_device *dev, u_int8_t *count)
{
	if (dev->cdesc == NULL)
		return (1);
	*count = dev->cdesc->bNumInterface;
	return (0);
@


1.81
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.80 2015/02/12 05:07:52 uebayasi Exp $ */
a282 1
	u_int size;
a298 1
	size = xfer->length;
d300 1
a300 1
	if (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {
d307 1
a307 1
		err = usb_allocmem(bus, size, 0, &xfer->dmabuf);
d314 2
a315 3
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 &&
	    !usbd_xfer_isread(xfer))
		memcpy(KERNADDR(&xfer->dmabuf, 0), xfer->buffer, size);
d458 2
d464 2
d740 1
a740 1
	if (xfer->actlen > xfer->length && xfer->length != 0) {
@


1.80
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a44 1
#include <dev/usb/usbdi_util.h>
@


1.79
log
@Reduce the number of intermediate buffers by pre-allocating DMA buffers
in the report functions instead of letting the stack do it magically for
us.

Reviewed and tested by David Higgs, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.78 2015/01/11 15:41:16 mpi Exp $ */
d1113 1
a1113 1
	return (2*i+2);
@


1.78
log
@There's no simple way so check for DMA buffer overrun with isochronous
transfers, so skip the check for such xfers for the moment.

Issue reported by Ingo Feinerer and fix confirmed by Jan Stary.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.77 2015/01/09 12:15:48 mpi Exp $ */
d58 1
a58 2
void usbd_do_request_async_cb(struct usbd_xfer *, void *,
    usbd_status);
d588 1
d599 6
a604 1
	err = usbd_do_request_async(dev, &req, 0, 0, 0);
d957 1
a957 2
usbd_do_request_async_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
d967 2
a968 2
usbd_do_request_async(struct usbd_device *dev, usb_device_request_t *req,
    void *data, void *priv, usbd_callback callback)
a969 1
	struct usbd_xfer *xfer;
a971 3
	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
		return (USBD_NOMEM);
d973 5
a977 3
		callback = usbd_do_request_async_cb;
	usbd_setup_default_xfer(xfer, dev, priv, USBD_DEFAULT_TIMEOUT, req,
	    data, UGETW(req->wLength), 0, callback);
@


1.77
log
@Always check for DMA buffer overrun, not just for some specific xfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.76 2015/01/09 12:07:50 mpi Exp $ */
d735 1
a735 1
	if (xfer->actlen > xfer->length) {
@


1.76
log
@Add an asynchronous version of uhidev_get_report(), from David Higgs
with some tweaks.

Nothing use it for the moment, but upcoming upd(4) improvements need
it.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.75 2014/11/01 00:41:33 mpi Exp $ */
d734 7
a742 7
#ifdef DIAGNOSTIC
		if (xfer->actlen > xfer->length) {
			printf("usb_transfer_complete: actlen > len %u > %u\n",
			    xfer->actlen, xfer->length);
			xfer->actlen = xfer->length;
		}
#endif
a906 9
#if defined(USB_DEBUG) || defined(DIAGNOSTIC)
	if (xfer->actlen > xfer->length)
		DPRINTF(("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
		    "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
		    dev->address, xfer->request.bmRequestType,
		    xfer->request.bRequest, UGETW(xfer->request.wValue),
		    UGETW(xfer->request.wIndex), UGETW(xfer->request.wLength),
		    xfer->length, xfer->actlen));
#endif
a954 9
#if defined(USB_DEBUG) || defined(DIAGNOSTIC)
	if (xfer->actlen > xfer->length)
		DPRINTF(("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
		    "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
		    xfer->pipe->device->address, xfer->request.bmRequestType,
		    xfer->request.bRequest, UGETW(xfer->request.wValue),
		    UGETW(xfer->request.wIndex), UGETW(xfer->request.wLength),
		    xfer->length, xfer->actlen));
#endif
@


1.75
log
@Make it clear that dma buffers are link to xfers, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.74 2014/10/31 12:43:33 mpi Exp $ */
d599 1
a599 1
	err = usbd_do_request_async(dev, &req, 0);
d982 1
a982 1
    void *data)
d990 4
a993 2
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
	    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);
@


1.74
log
@Use understandable messages when the per-xfer poison value is incorrect.
Prodded by a comment from stsp@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.73 2014/09/26 09:31:08 guenther Exp $ */
a283 1
	struct usb_dma *dmap = &xfer->dmabuf;
d311 1
a311 1
		err = usb_allocmem(bus, size, 0, dmap);
d320 1
a320 1
		memcpy(KERNADDR(dmap, 0), xfer->buffer, size);
a709 1
	struct usb_dma *dmap = &xfer->dmabuf;
d743 1
a743 1
		memcpy(xfer->buffer, KERNADDR(dmap, 0), xfer->actlen);
d749 1
a749 2
			struct usbd_bus *bus = pipe->device->bus;
			usb_freemem(bus, dmap);
@


1.73
log
@Fix format signedness

ok blambert@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.72 2014/08/10 11:00:36 mpi Exp $ */
d399 1
a399 1
	xfer->busy_free = XFER_BUSY;
d414 2
a415 3
	if (xfer->busy_free != XFER_BUSY) {
		printf("%s: xfer=%p not busy, 0x%08x\n", __func__, xfer,
		    xfer->busy_free);
d720 1
a720 2
		printf("usb_transfer_complete: xfer=%p not busy 0x%08x\n",
		    xfer, xfer->busy_free);
d763 1
a763 1
		xfer->busy_free = XFER_BUSY;
d826 2
a827 3
	if (xfer->busy_free != XFER_BUSY) {
		printf("usb_insert_transfer: xfer=%p not busy 0x%08x\n", xfer,
		    xfer->busy_free);
@


1.72
log
@Set and check for XFER_BUSY in the common methods instead of doing it
in every HC driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.71 2014/07/12 18:48:53 tedu Exp $ */
d742 1
a742 1
			printf("usb_transfer_complete: actlen > len %d > %d\n",
@


1.71
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.70 2014/03/07 09:38:14 mpi Exp $ */
d398 3
d413 7
a420 1
	return;
@


1.70
log
@We already have three identical copies of the *hci_str() function,
so merge them into usbd_str() to not introduce other copies with
the upcoming HC drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.69 2014/03/06 23:53:11 mpi Exp $ */
d276 1
a276 1
	free(pipe, M_USB);
d655 1
a655 1
		free(endpoints, M_USB);
@


1.69
log
@Turn usbd_xfer_isread() into a public function so that we can use
it in various drivers, mainly HC, instead of always rerolling our
own.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.68 2014/03/06 23:28:01 mpi Exp $ */
d1109 18
@


1.68
log
@Makes the "cleartoggle" function provided by HC drivers optional
because upcoming xhci(4) driver won't use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.67 2013/11/15 10:17:39 pirofti Exp $ */
a111 10
}

static __inline int
usbd_xfer_isread(struct usbd_xfer *xfer)
{
	if (xfer->rqflags & URQ_REQUEST)
		return (xfer->request.bmRequestType & UT_READ);
	else
		return (xfer->pipe->endpoint->edesc->bEndpointAddress &
		    UE_DIR_IN);
@


1.67
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.66 2013/11/13 13:48:08 pirofti Exp $ */
d576 1
a576 1
	pipe->methods->cleartoggle(pipe);
d595 1
a595 1
	pipe->methods->cleartoggle(pipe);
d609 2
a610 1
	pipe->methods->cleartoggle(pipe);
@


1.66
log
@Polling is done per controller not per interface.

The controllers are linked through device->bus so the iface is redundant.

So fixing usbd_dopoll() to take the device as argument and making
usbd_interface2device_handle() private (for now) inside usbdi_util.

Tested and okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.65 2013/11/06 15:55:15 jeremy Exp $ */
d532 1
a532 1
usbd_status
d541 1
a541 1
		return (USBD_NORMAL_COMPLETION);
a560 2

	return (USBD_NORMAL_COMPLETION);
@


1.65
log
@Make usbd_free_xfer return void, since no callers use the return value.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.64 2013/11/02 01:41:17 jeremy Exp $ */
a635 7
void
usbd_interface2device_handle(struct usbd_interface *iface,
    struct usbd_device **dev)
{
	*dev = iface->device;
}

d1026 1
a1026 1
usbd_dopoll(struct usbd_interface *iface)
d1028 1
a1028 1
	iface->device->bus->methods->do_poll(iface->device->bus);
@


1.64
log
@Begin conversion of USB stack to return int instead of usbd_status,
starting with usbd_endpoint_count and usbd_interface_count.  usbd_status
should only be used to indicate the status of a USB transfer, it should
not be used for generic error codes.

Idea from and much hand-holding by mpi@@

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.63 2013/10/31 20:06:59 mpi Exp $ */
d414 1
a414 1
usbd_status
d421 1
a421 1
	return (USBD_NORMAL_COMPLETION);
@


1.63
log
@Pipe don't have states. Kill an useless & commented out chunk of code.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.62 2013/10/31 10:12:19 mpi Exp $ */
d614 1
a614 1
usbd_status
d620 1
a620 1
		return (USBD_INVAL);
d624 1
a624 1
	return (USBD_NORMAL_COMPLETION);
d627 1
a627 1
usbd_status
d631 1
a631 1
		return (USBD_NOT_CONFIGURED);
d633 1
a633 1
	return (USBD_NORMAL_COMPLETION);
@


1.62
log
@usbd_pipe2device_handle() is not used, should not be used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.61 2013/10/14 08:27:54 mpi Exp $ */
d586 1
a586 7
#if 0
XXX should we do this?
	if (!err) {
		pipe->state = USBD_PIPE_ACTIVE;
		/* XXX activate pipe */
	}
#endif
@


1.61
log
@If a transfer terminates with an I/O error status, do not modify the
pipe to stop enquening the next transfer before the done() function
has been called.

This should fix the hangs seen when unplugging a USB keyboard attached
to uhci(4).

Problem reported by dcoppa@@ and Peter Kane
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.60 2013/09/24 09:01:41 mpi Exp $ */
a658 6
}

struct usbd_device *
usbd_pipe2device_handle(struct usbd_pipe *pipe)
{
	return (pipe->device);
@


1.60
log
@Stop generating traffic for a given endpoint when a transfer reported
an I/O error.

When such thing happens, the device is more likely to be already gone
or non responding, but the task responsible for aborting the pipe has
not been executed.

Fix a problem where the ehci(4) controller would vomit^Wprint a lot of
"ehci_idone:" messages in loop leaving the machine unusable, initially
reported by ajacoutot@@ and later by RD Thrush.

Fix tested by RD Thrush and Markus Bergkvist, thanks!

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.59 2013/09/20 15:34:51 mpi Exp $ */
a805 9
		/*
		 * If we already got an I/O error that generally means
		 * the device is gone or not responding, so don't try
		 * to enqueue a new transfer as it will more likely
		 * results in the same error.
		 */
		if (xfer->status == USBD_IOERROR)
			pipe->repeat = 0;

d814 9
@


1.59
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.58 2013/09/06 08:29:58 mpi Exp $ */
a733 1
	int repeat = pipe->repeat;
d773 1
a773 1
		if (!repeat) {
d780 1
a780 1
	if (!repeat) {
d790 2
a791 2
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n", repeat,
	    SIMPLEQ_FIRST(&pipe->queue)));
d805 10
a814 1
	if (repeat) {
d827 1
a827 1
	if (!repeat) {
d830 1
@


1.58
log
@Fix build with USB_DEBUG defined, pipes don't have refcounters anymore.

From Nils Frohberg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.57 2013/08/13 09:26:04 mpi Exp $ */
d297 1
a297 1
	int s;
d355 10
a364 1
		tsleep(xfer, PRIBIO, "usbsyn", 0);
@


1.57
log
@Remove bogus and useless refcounting of usbd pipes that could lead to
memory leaks and abort the pipe if requests are still pending because
most of our drivers don't do anything if usbd_close_pipe() fails.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.56 2013/08/08 09:37:02 mpi Exp $ */
d180 2
a181 2
	printf(" (usbd_dump_pipe:)\n refcnt=%d running=%d aborting=%d\n",
	    pipe->refcnt, pipe->running, pipe->aborting);
@


1.56
log
@Use the same functions to abort and close the control pipe of a device
as for every other pipes instead of having another function calling the
host controller method.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.55 2013/04/26 14:19:25 mpi Exp $ */
d276 3
a278 4
	if (--pipe->refcnt != 0)
		return (USBD_NORMAL_COMPLETION);
	if (! SIMPLEQ_EMPTY(&pipe->queue))
		return (USBD_PENDING_REQUESTS);
@


1.55
log
@Remove unused and ambiguous usbd_get_interface() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.54 2013/04/26 14:05:24 mpi Exp $ */
d280 3
a282 1
	LIST_REMOVE(pipe, next);
@


1.54
log
@Give back to usb(4) what is usb(4)'s. In other words use the usb_* prefix
for functions related to the usb(4) driver and keep usbd_* for generic
USB layer functions.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.53 2013/04/26 13:46:40 mglocker Exp $ */
a713 13
}

usbd_status
usbd_get_interface(struct usbd_interface *iface, u_int8_t *aiface)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_INTERFACE;
	req.bRequest = UR_GET_INTERFACE;
	USETW(req.wValue, 0);
	USETW(req.wIndex, iface->idesc->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(iface->device, &req, aiface));
@


1.53
log
@Rename three functions in usbdi.c to their right prefix (usb_* to usbd_*).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.52 2013/04/19 08:58:53 mpi Exp $ */
a39 1
#include <sys/rwlock.h>
a62 21

int usbd_nbuses = 0;

struct rwlock usbpalock;

void
usbd_init(void)
{
	if (usbd_nbuses == 0) {
		rw_init(&usbpalock, "usbpalock");
		usb_begin_tasks();
	}
	usbd_nbuses++;
}

void
usbd_finish(void)
{
	if (--usbd_nbuses == 0)
		usb_end_tasks();
}
@


1.52
log
@Remove allocm() and freem() from the USB bus interface now that they
are only used as wrappers around usb_{alloc,free}mem().

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.51 2013/04/19 08:54:49 mpi Exp $ */
d1111 1
a1111 1
usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int sz,
d1125 1
a1125 1
usb_desc_iter_init(struct usbd_device *dev, struct usbd_desc_iter *iter)
d1134 1
a1134 1
usb_desc_iter_next(struct usbd_desc_iter *iter)
d1140 1
a1140 1
			printf("usb_desc_iter_next: bad descriptor\n");
d1145 1
a1145 1
		printf("usb_desc_iter_next: descriptor length = 0\n");
d1150 1
a1150 1
		printf("usb_desc_iter_next: descriptor length too large\n");
@


1.51
log
@Remove unused usbd_get_buffer() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.50 2013/04/15 09:23:02 mglocker Exp $ */
d343 1
a343 1
		err = bus->methods->allocm(bus, dmap, size);
d361 1
a361 1
			bus->methods->freem(bus, &xfer->dmabuf);
d392 1
a392 1
	err = bus->methods->allocm(bus, &xfer->dmabuf, size);
d409 1
a409 1
	xfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);
d801 1
a801 1
			bus->methods->freem(bus, dmap);
@


1.50
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.49 2013/04/12 13:05:56 mpi Exp $ */
a409 8
}

void *
usbd_get_buffer(struct usbd_xfer *xfer)
{
	if (!(xfer->rqflags & URQ_DEV_DMABUF))
		return (0);
	return (KERNADDR(&xfer->dmabuf, 0));
@


1.49
log
@usbd_setup_default_xfer() already use the default device's pipe so there's
no need to reset it afterward.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.48 2013/04/12 12:58:39 mpi Exp $ */
d59 1
a59 1
void usbd_do_request_async_cb(usbd_xfer_handle, usbd_private_handle,
d61 3
a63 3
void usbd_start_next(usbd_pipe_handle pipe);
usbd_status usbd_open_pipe_ival(usbd_interface_handle, u_int8_t, u_int8_t,
    usbd_pipe_handle *, int);
d87 1
a87 1
usbd_is_dying(usbd_device_handle dev)
d93 1
a93 1
usbd_deactivate(usbd_device_handle dev)
d99 1
a99 1
usbd_ref_incr(usbd_device_handle dev)
d105 1
a105 1
usbd_ref_decr(usbd_device_handle dev)
d112 1
a112 1
usbd_ref_wait(usbd_device_handle dev)
d119 1
a119 1
usbd_get_devcnt(usbd_device_handle dev)
d125 1
a125 1
usbd_claim_iface(usbd_device_handle dev, int ifaceidx)
d131 1
a131 1
usbd_iface_claimed(usbd_device_handle dev, int ifaceidx)
d137 1
a137 1
usbd_xfer_isread(usbd_xfer_handle xfer)
d183 1
a183 1
usbd_dump_queue(usbd_pipe_handle pipe)
d185 1
a185 1
	usbd_xfer_handle xfer;
d194 1
a194 1
usbd_dump_pipe(usbd_pipe_handle pipe)
d210 2
a211 2
usbd_open_pipe(usbd_interface_handle iface, u_int8_t address, u_int8_t flags,
    usbd_pipe_handle *pipe)
d218 2
a219 2
usbd_open_pipe_ival(usbd_interface_handle iface, u_int8_t address,
    u_int8_t flags, usbd_pipe_handle *pipe, int ival)
d221 1
a221 1
	usbd_pipe_handle p;
d249 2
a250 2
usbd_open_pipe_intr(usbd_interface_handle iface, u_int8_t address,
    u_int8_t flags, usbd_pipe_handle *pipe, usbd_private_handle priv,
d254 2
a255 2
	usbd_xfer_handle xfer;
	usbd_pipe_handle ipipe;
d289 1
a289 1
usbd_close_pipe(usbd_pipe_handle pipe)
d312 1
a312 1
usbd_transfer(usbd_xfer_handle xfer)
d314 2
a315 2
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
d383 1
a383 1
usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size)
d400 1
a400 1
usbd_free_buffer(usbd_xfer_handle xfer)
d413 1
a413 1
usbd_get_buffer(usbd_xfer_handle xfer)
d420 2
a421 2
usbd_xfer_handle
usbd_alloc_xfer(usbd_device_handle dev)
d423 1
a423 1
	usbd_xfer_handle xfer;
d435 1
a435 1
usbd_free_xfer(usbd_xfer_handle xfer)
d445 2
a446 2
usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
    usbd_private_handle priv, void *buffer, u_int32_t length, u_int16_t flags,
d463 2
a464 2
usbd_setup_default_xfer(usbd_xfer_handle xfer, usbd_device_handle dev,
    usbd_private_handle priv, u_int32_t timeout, usb_device_request_t *req,
d482 2
a483 2
usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
    usbd_private_handle priv, u_int16_t *frlengths, u_int32_t nframes,
d501 1
a501 1
usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle *priv,
d515 1
a515 1
usbd_get_config_descriptor(usbd_device_handle dev)
d527 1
a527 1
usbd_get_interface_descriptor(usbd_interface_handle iface)
d539 1
a539 1
usbd_get_device_descriptor(usbd_device_handle dev)
d545 1
a545 1
usbd_interface2endpoint_descriptor(usbd_interface_handle iface, u_int8_t index)
d553 1
a553 1
usbd_abort_pipe(usbd_pipe_handle pipe)
d555 1
a555 1
	usbd_xfer_handle xfer;
d586 1
a586 1
usbd_clear_endpoint_stall(usbd_pipe_handle pipe)
d588 1
a588 1
	usbd_device_handle dev = pipe->device;
d617 1
a617 1
usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe)
d619 1
a619 1
	usbd_device_handle dev = pipe->device;
d635 1
a635 1
usbd_clear_endpoint_toggle(usbd_pipe_handle pipe)
d641 1
a641 1
usbd_endpoint_count(usbd_interface_handle iface, u_int8_t *count)
d654 1
a654 1
usbd_interface_count(usbd_device_handle dev, u_int8_t *count)
d663 2
a664 2
usbd_interface2device_handle(usbd_interface_handle iface,
    usbd_device_handle *dev)
d670 2
a671 2
usbd_device2interface_handle(usbd_device_handle dev, u_int8_t ifaceno,
    usbd_interface_handle *iface)
d681 2
a682 2
usbd_device_handle
usbd_pipe2device_handle(usbd_pipe_handle pipe)
d689 1
a689 1
usbd_set_interface(usbd_interface_handle iface, int altidx)
d741 1
a741 1
usbd_get_interface_altindex(usbd_interface_handle iface)
d747 1
a747 1
usbd_get_interface(usbd_interface_handle iface, u_int8_t *aiface)
d763 1
a763 1
usb_transfer_complete(usbd_xfer_handle xfer)
d765 2
a766 2
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
d864 1
a864 1
usb_insert_transfer(usbd_xfer_handle xfer)
d866 1
a866 1
	usbd_pipe_handle pipe = xfer->pipe;
d894 1
a894 1
usbd_start_next(usbd_pipe_handle pipe)
d896 1
a896 1
	usbd_xfer_handle xfer;
d928 1
a928 1
usbd_do_request(usbd_device_handle dev, usb_device_request_t *req, void *data)
d935 1
a935 1
usbd_do_request_flags(usbd_device_handle dev, usb_device_request_t *req,
d938 1
a938 1
	usbd_xfer_handle xfer;
d1012 1
a1012 1
usbd_do_request_async_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d1032 1
a1032 1
usbd_do_request_async(usbd_device_handle dev, usb_device_request_t *req,
d1035 1
a1035 1
	usbd_xfer_handle xfer;
d1052 1
a1052 1
usbd_get_quirks(usbd_device_handle dev)
d1069 1
a1069 1
usbd_dopoll(usbd_interface_handle iface)
d1075 1
a1075 1
usbd_set_polling(usbd_device_handle dev, int on)
d1087 1
a1087 1
usbd_get_endpoint_descriptor(usbd_interface_handle iface, u_int8_t address)
d1133 1
a1133 1
usb_desc_iter_init(usbd_device_handle dev, usbd_desc_iter_t *iter)
d1142 1
a1142 1
usb_desc_iter_next(usbd_desc_iter_t *iter)
@


1.48
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.47 2013/04/11 07:50:56 mpi Exp $ */
a937 1
	usbd_pipe_handle pipe = dev->default_pipe;
a956 1
	xfer->pipe = pipe;
@


1.47
log
@Merge usbd_ar_pipe in usbd_abort_pipe, no functional change.

ok ratchov@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.46 2013/04/09 08:47:56 mpi Exp $ */
a381 8
/* Like usbd_transfer(), but waits for completion. */
usbd_status
usbd_sync_transfer(usbd_xfer_handle xfer)
{
	xfer->flags |= USBD_SYNCHRONOUS;
	return (usbd_transfer(xfer));
}

d957 1
a957 1
	    UGETW(req->wLength), flags, 0);
d959 1
a959 1
	err = usbd_sync_transfer(xfer);
d988 2
a989 2
		    &treq, &status,sizeof(usb_status_t), 0, 0);
		nerr = usbd_sync_transfer(xfer);
d1002 2
a1003 2
		    &treq, &status, 0, 0, 0);
		nerr = usbd_sync_transfer(xfer);
@


1.46
log
@When submitting a request the device's default pipe is always
used, so do not pretend to support a different one and get rid
of the unused usbd_do_request_flags_pipe() function.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.45 2013/03/28 03:58:03 tedu Exp $ */
a58 1
usbd_status usbd_ar_pipe(usbd_pipe_handle pipe);
d563 1
a563 1
	usbd_status err;
d573 15
a587 1
	err = usbd_ar_pipe(pipe);
d589 2
a590 1
	return (err);
a767 26

/* Dequeue all pipe operations, called at splusb(). */
usbd_status
usbd_ar_pipe(usbd_pipe_handle pipe)
{
	usbd_xfer_handle xfer;

	SPLUSBCHECK;

	DPRINTFN(2,("usbd_ar_pipe: pipe=%p\n", pipe));
#ifdef USB_DEBUG
	if (usbdebug > 5)
		usbd_dump_queue(pipe);
#endif
	pipe->repeat = 0;
	pipe->aborting = 1;
	while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
		    pipe, xfer, pipe->methods));
		/* Make the HC abort it (and invoke the callback). */
		pipe->methods->abort(xfer);
		/* XXX only for non-0 usbd_clear_endpoint_stall(pipe); */
	}
	pipe->aborting = 0;
	return (USBD_NORMAL_COMPLETION);
}
@


1.45
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.44 2011/12/16 00:04:37 fgsch Exp $ */
d956 1
a956 10
    void *data, u_int16_t flags, int *actlen, u_int32_t timo)
{
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req, data,
	    flags, actlen, timo));
}

usbd_status
usbd_do_request_flags_pipe(usbd_device_handle dev, usbd_pipe_handle pipe,
    usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
    u_int32_t timeout)
d958 1
@


1.44
log
@fix function names on diagnostic messages.
from Tobias Ulmer (tobiasu-at-tmux-dot-org)
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.43 2011/01/16 22:35:29 jakemsr Exp $ */
a39 1
#include <sys/proc.h>
@


1.43
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.42 2010/12/30 05:10:35 jakemsr Exp $ */
d805 1
a805 1
		printf("usbd_transfer_complete: pipe==0, xfer=%p\n", xfer);
d855 1
a855 1
		DPRINTFN(-1,("usbd_transfer_complete: short transfer %d<%d\n",
@


1.42
log
@* add a process reference counting variable to struct usbd_device
* add functions to increment and decrement the reference count, and a
  function to wait until the reference count is zero
ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.41 2010/12/06 04:25:27 jakemsr Exp $ */
d118 18
@


1.41
log
@* add dying flag to struct usbd_device
* add usbd_deactivate(), which should be use to set the dying flag in
  struct usbd_device
* add usbd_is_dying(), which can be used to check if either the device
  or the associated bus dying flag has been set
* use usbd_is_dying() to check if the deivce or bus is dying before
  issuing transfers or requests
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.40 2010/09/23 05:44:15 jakemsr Exp $ */
d98 20
@


1.40
log
@add a 'dying' flag to struct usbd_bus.  use this to signify the bus
is dying, instead of setting a flag in struct usb_softc.  as
usbd_device_handle has a pointer to the usbd_bus it's attached to,
usb devices, and functions they run or functions run on their behalf,
can now easily check if their bus is dying.  use this to stop
usbd_do_request* from running and the usb task thread from adding
new tasks when a device's bus is dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.39 2010/09/23 04:58:02 jakemsr Exp $ */
d88 12
d284 3
d941 1
a941 1
	if (dev->bus->dying)
@


1.39
log
@instead of running usb_explore() from individual kthreads for each
USB bus, make usb_explore() a usb_task.  reduces races during normal
USB device detach, since now usb_tasks and detach happen in the same
process.
ok yuo@@, matthew@@ helped with the task thread loop
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.38 2010/03/05 17:28:54 mk Exp $ */
d924 4
@


1.38
log
@Fix spelling in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.37 2008/10/11 13:51:35 mglocker Exp $ */
d74 1
a74 1
	if (usbd_nbuses == 0)
d76 2
d84 2
a85 1
	--usbd_nbuses;
@


1.37
log
@For none interrupt endpoints call the xfer done function before
calling the xfer callback function to allow a device driver to
immediately reschedule the same xfer.

This e.g. improves performance for isoc high- fullspeed xfers (ehci).

From NetBSD.  OK phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.36 2008/06/26 05:42:19 ray Exp $ */
d1074 1
a1074 1
 * to notice it.  If the driver continuosly tries to do I/O operations
@


1.36
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.35 2008/06/21 22:24:45 fgsch Exp $ */
d804 5
a808 5
	if (xfer->callback)
		xfer->callback(xfer, xfer->priv, xfer->status);

#ifdef DIAGNOSTIC
	if (pipe->methods->done != NULL)
d810 3
a812 5
	else
		printf("usb_transfer_complete: pipe->methods->done == NULL\n");
#else
	pipe->methods->done(xfer);
#endif
@


1.35
log
@print the correct function name.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.34 2007/10/11 18:30:50 deraadt Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.34
log
@serialize usbd_probe_and_attach(); only let one usb device be match'd and
attached at a time; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.33 2007/06/18 11:37:04 mbalmer Exp $ */
d756 1
a756 1
		printf("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer);
d806 1
a806 1
		DPRINTFN(-1,("usbd_transfer_cb: short transfer %d<%d\n",
@


1.33
log
@KNF, especially re-indent prototypes.  No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.32 2007/06/10 10:15:35 mbalmer Exp $ */
d48 1
d76 2
d81 2
@


1.32
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.31 2007/06/05 08:43:56 mbalmer Exp $ */
d67 2
a68 2
void usbd_do_request_async_cb
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d70 2
a71 2
usbd_status usbd_open_pipe_ival
	(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d94 1
a94 1
			UE_DIR_IN);
d105 2
a106 2
	       iface->device, iface->idesc, iface->index, iface->altindex,
	       iface->priv);
d117 2
a118 3
	       "power=%d langid=%d\n",
	       dev->address, dev->config, dev->depth, dev->speed,
	       dev->self_powered, dev->power, dev->langid);
d130 1
a130 1
		       endp->edesc->bEndpointAddress);
d154 3
a156 3
	       pipe->refcnt, pipe->running, pipe->aborting);
	printf(" intrxfer=%p, repeat=%d, interval=%d\n",
	       pipe->intrxfer, pipe->repeat, pipe->interval);
d161 2
a162 2
usbd_open_pipe(usbd_interface_handle iface, u_int8_t address,
	       u_int8_t flags, usbd_pipe_handle *pipe)
d165 1
a165 1
				    USBD_DEFAULT_INTERVAL));
d170 1
a170 1
		    u_int8_t flags, usbd_pipe_handle *pipe, int ival)
d178 1
a178 1
		    iface, address, flags));
d201 2
a202 3
		    u_int8_t flags, usbd_pipe_handle *pipe,
		    usbd_private_handle priv, void *buffer, u_int32_t len,
		    usbd_callback cb, int ival)
d209 1
a209 1
		    address, flags, len));
d211 2
a212 2
	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE,
				  &ipipe, ival);
d272 1
a272 1
		    xfer, xfer->flags, pipe, pipe->running));
d402 2
a403 3
		usbd_private_handle priv, void *buffer, u_int32_t length,
		u_int16_t flags, u_int32_t timeout,
		usbd_callback callback)
d420 2
a421 4
			usbd_private_handle priv, u_int32_t timeout,
			usb_device_request_t *req, void *buffer,
			u_int32_t length, u_int16_t flags,
			usbd_callback callback)
d439 2
a440 2
		     usbd_private_handle priv, u_int16_t *frlengths,
		     u_int32_t nframes, u_int16_t flags, usbd_callback callback)
d458 1
a458 1
		     void **buffer, u_int32_t *count, usbd_status *status)
d605 1
a605 1
			     usbd_device_handle *dev)
d611 2
a612 2
usbd_device2interface_handle(usbd_device_handle dev,
			     u_int8_t ifaceno, usbd_interface_handle *iface)
d719 1
a719 1
			    pipe, xfer, pipe->methods));
d744 1
a744 1
		       xfer, xfer->busy_free);
d765 1
a765 1
			       xfer->actlen, xfer->length);
d786 1
a786 1
			       xfer, SIMPLEQ_FIRST(&pipe->queue));
d791 2
a792 2
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
		    repeat, SIMPLEQ_FIRST(&pipe->queue)));
d802 1
a802 1
			     xfer->actlen, xfer->length));
d840 1
a840 1
		    pipe, pipe->running, xfer->timeout));
d843 2
a844 2
		printf("usb_insert_transfer: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
d900 1
a900 1
				      USBD_DEFAULT_TIMEOUT));
d905 1
a905 1
		      void *data, u_int16_t flags, int *actlen, u_int32_t timo)
d907 2
a908 2
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req,
					   data, flags, actlen, timo));
d913 2
a914 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t timeout)
d929 2
a930 2
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req,
				data, UGETW(req->wLength), flags, 0);
d936 5
a940 6
			 "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
			 dev->address, xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
			 xfer->length, xfer->actlen));
d961 1
a961 2
					   &treq, &status,sizeof(usb_status_t),
					   0, 0);
d975 1
a975 1
					   &treq, &status, 0, 0, 0);
d988 1
a988 1
			 usbd_status status)
d993 5
a997 7
			 "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
			 xfer->pipe->device->address,
			 xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
			 xfer->length, xfer->actlen));
d1008 1
a1008 1
		      void *data)
d1095 1
a1095 1
		 u_int16_t vendor, u_int16_t product)
@


1.31
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.30 2007/05/31 18:20:22 mbalmer Exp $ */
d387 1
a387 1
	usb_callout_init(xfer->timeout_handle);
@


1.30
log
@Remove more #ifdef/#endif's that checked for other bsds.  No binary
change, no functionality change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.29 2007/05/21 05:40:28 jsg Exp $ */
d66 2
a67 2
Static usbd_status usbd_ar_pipe(usbd_pipe_handle pipe);
Static void usbd_do_request_async_cb
d69 2
a70 2
Static void usbd_start_next(usbd_pipe_handle pipe);
Static usbd_status usbd_open_pipe_ival
d73 1
a73 1
Static int usbd_nbuses = 0;
d708 1
a708 1
Static usbd_status
@


1.29
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.28 2007/03/31 19:46:44 bluhm Exp $ */
a43 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a45 9
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/conf.h>
#include "usb_if.h"
#if defined(DIAGNOSTIC) && defined(__i386__)
#include <machine/cpu.h>
#endif
#endif
a56 4
#if defined(__FreeBSD__)
#include "usb_if.h"
#endif

a397 6
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&xfer->timeout_handle)) {
		callout_stop(&xfer->timeout_handle);
		printf("usbd_free_xfer: timout_handle pending");
	}
#endif
a924 4
#if defined(__i386__) && defined(__FreeBSD__)
	KASSERT(intr_nesting_level == 0,
	       	("usbd_do_request: in interrupt context"));
#endif
a1146 11

#if defined(__FreeBSD__)
int
usbd_driver_load(module_t mod, int what, void *arg)
{
	/* XXX should implement something like a function that removes all generic devices */

 	return (0);
}

#endif
@


1.28
log
@Print correct function name in diagnostic output.
ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.27 2006/08/14 00:32:10 pascoe Exp $ */
d72 2
a73 2
#define DPRINTF(x)	do { if (usbdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) logprintf x; } while (0)
@


1.27
log
@Handle interrupted tsleep when waiting for synchronous transfer completion.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.26 2005/09/20 08:03:59 dlg Exp $ */
d541 1
a541 1
		printf("usbd_close_pipe: pipe==NULL\n");
@


1.26
log
@add iterators for usb descriptors. from Tony Lambris and Staffan Ulfberg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.25 2004/07/08 22:18:45 deraadt Exp $ */
d337 1
a337 1
	if (!xfer->done) {
@


1.25
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.24 2004/05/04 16:59:32 grange Exp $ */
d1138 32
@


1.24
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.23 2003/07/08 13:19:09 nate Exp $ */
d72 2
a73 2
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
@


1.23
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.22 2003/05/17 05:33:45 nate Exp $ */
d814 1
a814 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);
@


1.22
log
@make this function available to others
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.c,v 1.21 2002/10/12 01:09:44 krw Exp $ */
/*	$NetBSD: usbdi.c,v 1.81 2001/04/17 00:05:33 augustss Exp $	*/
d82 1
a82 1
(usbd_xfer_handle, usbd_private_handle, usbd_status);
d85 1
a85 1
(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d112 36
a147 1
void usbd_dump_queue(usbd_pipe_handle pipe);
d154 1
a154 3
	for (xfer = SIMPLEQ_FIRST(&pipe->queue);
	     xfer;
	     xfer = SIMPLEQ_NEXT(xfer, next)) {
d158 15
d267 1
a267 1
	if (SIMPLEQ_FIRST(&pipe->queue) != 0)
a271 6
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&pipe->abort_handle)) {
		callout_stop(&pipe->abort_handle);
		printf("usbd_close_pipe: abort_handle pending");
	}
#endif
d316 1
a316 1
		memcpy(KERNADDR(dmap), xfer->buffer, size);
d360 4
d366 1
a366 1
		return (0);
d368 1
a368 1
	return (KERNADDR(&xfer->dmabuf));
d389 1
a389 1
	return (KERNADDR(&xfer->dmabuf));
d561 1
a561 1
	 * Clearing en endpoint stall resets the enpoint toggle, so
d628 1
a628 1
usbd_status
a632 1
	return (USBD_NORMAL_COMPLETION);
d766 7
d794 1
a794 1
		memcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);
d812 1
d866 8
d1089 3
a1093 1

d1135 1
a1135 1
		tbl = (struct usb_devno *)((char *)tbl + sz);
@


1.21
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.20 2002/07/25 02:18:11 nate Exp $ */
a553 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe); /* XXXXX */
@


1.20
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.19 2002/07/09 17:41:02 nate Exp $ */
d297 1
a297 1
			panic("usbd_transfer: not done\n");
@


1.19
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.18 2002/05/07 18:29:19 nate Exp $ */
d81 1
a81 1
Static void usbd_do_request_async_cb 
d127 1
a127 1
usbd_status 
d130 2
a131 2
{ 
	return (usbd_open_pipe_ival(iface, address, flags, pipe, 
d135 1
a135 1
usbd_status 
d138 1
a138 1
{ 
d166 1
a166 1
usbd_status 
d179 1
a179 1
	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, 
d272 1
a272 1
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 && 
d346 1
a346 1
usbd_xfer_handle 
d360 1
a360 1
usbd_status 
d487 1
a487 1
usbd_status 
d504 2
a505 2
	
usbd_status 
d514 1
a514 1
	/* 
d536 1
a536 1
usbd_status 
d561 1
a561 1
usbd_status 
d574 1
a574 1
usbd_status 
d583 1
a583 1
usbd_status 
d591 1
a591 1
usbd_status 
d654 1
a654 1
		if (p + d->bLength <= end && 
d699 1
a699 1
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n", 
d764 1
a764 1
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n", 
d812 1
a812 1
	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d timeout=%d\n", 
d872 1
a872 1
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req, 
d908 2
a909 2
			 UGETW(xfer->request.wIndex), 
			 UGETW(xfer->request.wLength), 
d915 1
a915 1
		/* 
d965 1
a965 1
			 xfer->pipe->device->address, 
d968 2
a969 2
			 UGETW(xfer->request.wIndex), 
			 UGETW(xfer->request.wLength), 
d1083 1
a1083 1
 
@


1.18
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.16 2002/05/02 20:08:04 nate Exp $ */
d864 2
a865 1
	return (usbd_do_request_flags(dev, req, data, 0, 0));
d870 1
a870 1
		      void *data, u_int16_t flags, int *actlen)
d873 1
a873 1
					   data, flags, actlen));
d878 2
a879 1
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen)
d898 1
a898 1
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
@


1.17
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.c,v 1.99 2002/02/28 04:49:16 thorpej Exp $	*/
d82 1
a82 1
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d85 1
a85 1
	(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d112 1
a112 36
void
usbd_dump_iface(struct usbd_interface *iface)
{
	printf("usbd_dump_iface: iface=%p\n", iface);
	if (iface == NULL)
		return;
	printf(" device=%p idesc=%p index=%d altindex=%d priv=%p\n",
	       iface->device, iface->idesc, iface->index, iface->altindex,
	       iface->priv);
}

void
usbd_dump_device(struct usbd_device *dev)
{
	printf("usbd_dump_device: dev=%p\n", dev);
	if (dev == NULL)
		return;
	printf(" bus=%p default_pipe=%p\n", dev->bus, dev->default_pipe);
	printf(" address=%d config=%d depth=%d speed=%d self_powered=%d "
	       "power=%d langid=%d\n",
	       dev->address, dev->config, dev->depth, dev->speed,
	       dev->self_powered, dev->power, dev->langid);
}

void
usbd_dump_endpoint(struct usbd_endpoint *endp)
{
	printf("usbd_dump_endpoint: endp=%p\n", endp);
	if (endp == NULL)
		return;
	printf(" edesc=%p refcnt=%d\n", endp->edesc, endp->refcnt);
	if (endp->edesc)
		printf(" bEndpointAddress=0x%02x\n",
		       endp->edesc->bEndpointAddress);
}

a124 15

void
usbd_dump_pipe(usbd_pipe_handle pipe)
{
	printf("usbd_dump_pipe: pipe=%p\n", pipe);
	if (pipe == NULL)
		return;
	usbd_dump_iface(pipe->iface);
	usbd_dump_device(pipe->device);
	usbd_dump_endpoint(pipe->endpoint);
	printf(" (usbd_dump_pipe:)\n refcnt=%d running=%d aborting=%d\n",
	       pipe->refcnt, pipe->running, pipe->aborting);
	printf(" intrxfer=%p, repeat=%d, interval=%d\n",
	       pipe->intrxfer, pipe->repeat, pipe->interval);
}
d224 6
a317 4
#ifdef DIAGNOSTIC
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		printf("usbd_alloc_buffer: xfer already has a buffer\n");
#endif
d320 1
a320 1
		return (NULL);
d515 1
a515 1
	 * Clearing en endpoint stall resets the endpoint toggle, so
d554 1
d583 1
a583 1
void
d588 1
a721 7
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_ONQU) {
		printf("usb_transfer_complete: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return;
	}
#endif
a760 1
		xfer->busy_free = XFER_BUSY;
a813 8
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("usb_insert_transfer: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return (USBD_INVAL);
	}
	xfer->busy_free = XFER_ONQU;
#endif
d864 1
a864 2
	return (usbd_do_request_flags(dev, req, data, 0, 0,
				      USBD_DEFAULT_TIMEOUT));
d869 1
a869 1
		      void *data, u_int16_t flags, int *actlen, u_int32_t timo)
d872 1
a872 1
					   data, flags, actlen, timo));
d877 1
a877 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t timeout)
d896 1
a896 1
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req,
a1026 3
	/* When polling we need to make sure there is nothing pending to do. */
	if (dev->bus->use_polling)
		dev->bus->methods->soft_intr(dev->bus);
d1071 1
a1071 1
		tbl = (const struct usb_devno *)((const char *)tbl + sz);
@


1.16
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.c,v 1.15 2002/04/01 21:47:07 nate Exp $ */
/*	$NetBSD: usbdi.c,v 1.81 2001/04/17 00:05:33 augustss Exp $	*/
d82 1
a82 1
(usbd_xfer_handle, usbd_private_handle, usbd_status);
d85 1
a85 1
(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d112 36
a147 1
void usbd_dump_queue(usbd_pipe_handle pipe);
d160 15
a273 6
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&pipe->abort_handle)) {
		callout_stop(&pipe->abort_handle);
		printf("usbd_close_pipe: abort_handle pending");
	}
#endif
d362 4
d368 1
a368 1
		return (0);
d563 1
a563 1
	 * Clearing en endpoint stall resets the enpoint toggle, so
a601 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe); /* XXXXX */
d630 1
a630 1
usbd_status 
a634 1
	return (USBD_NORMAL_COMPLETION);
d768 7
d814 1
d868 8
d926 2
a927 1
	return (usbd_do_request_flags(dev, req, data, 0, 0));
d932 1
a932 1
		      void *data, u_int16_t flags, int *actlen)
d935 1
a935 1
					   data, flags, actlen));
d940 2
a941 1
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen)
d960 1
a960 1
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
d1091 3
d1138 1
a1138 1
		tbl = (struct usb_devno *)((char *)tbl + sz);
@


1.15
log
@Add support for a bunch of new adapters.
Sync with NetBSD.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.14 2001/05/03 02:20:34 aaron Exp $ */
d768 1
a768 1
	++pipe->device->bus->stats.requests
@


1.14
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.13 2001/01/28 09:43:42 aaron Exp $ */
d1056 18
@


1.14.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.14 2001/05/03 02:20:34 aaron Exp $ */
d768 1
a768 1
	++pipe->device->bus->stats.uds_requests
a1055 18
}

/*
 * Search for a vendor/product pair in an array.  The item size is
 * given as an argument.
 */
const struct usb_devno *
usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int sz,
		 u_int16_t vendor, u_int16_t product)
{
	while (nentries-- > 0) {
		u_int16_t tproduct = tbl->ud_product;
		if (tbl->ud_vendor == vendor &&
		    (tproduct == product || tproduct == USB_PRODUCT_ANY))
			return (tbl);
		tbl = (struct usb_devno *)((char *)tbl + sz);
	}
	return (NULL);
@


1.14.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.14.4.1 2002/06/11 03:42:31 art Exp $ */
d81 1
a81 1
Static void usbd_do_request_async_cb
d127 1
a127 1
usbd_status
d130 2
a131 2
{
	return (usbd_open_pipe_ival(iface, address, flags, pipe,
d135 1
a135 1
usbd_status
d138 1
a138 1
{
d166 1
a166 1
usbd_status
d179 1
a179 1
	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE,
d272 1
a272 1
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 &&
d297 1
a297 1
			panic("usbd_transfer: not done");
d346 1
a346 1
usbd_xfer_handle
d360 1
a360 1
usbd_status
d487 1
a487 1
usbd_status
d504 2
a505 2

usbd_status
d514 1
a514 1
	/*
d536 1
a536 1
usbd_status
d561 1
a561 1
usbd_status
d574 1
a574 1
usbd_status
d583 1
a583 1
usbd_status
d591 1
a591 1
usbd_status
d654 1
a654 1
		if (p + d->bLength <= end &&
d699 1
a699 1
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
d764 1
a764 1
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
d812 1
a812 1
	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d timeout=%d\n",
d864 1
a864 2
	return (usbd_do_request_flags(dev, req, data, 0, 0,
				      USBD_DEFAULT_TIMEOUT));
d869 1
a869 1
		      void *data, u_int16_t flags, int *actlen, u_int32_t timo)
d871 2
a872 2
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req,
					   data, flags, actlen, timo));
d877 1
a877 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t timeout)
d896 1
a896 1
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req,
d906 2
a907 2
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
d913 1
a913 1
		/*
d963 1
a963 1
			 xfer->pipe->device->address,
d966 2
a967 2
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
d1081 1
a1081 1

@


1.14.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d554 1
@


1.13
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.c,v 1.12 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi.c,v 1.77 2000/09/23 21:02:04 augustss Exp $	*/
d298 1
a298 19
		/* XXX Temporary hack XXX */
		if (xfer->flags & USBD_NO_TSLEEP) {
			int i;
			usbd_bus_handle bus = pipe->device->bus;
			int to = xfer->timeout * 1000;
			for (i = 0; i < to; i += 10) {
				delay(10);
				bus->methods->do_poll(bus);
				if (xfer->done)
					break;
			}
			/* XXX Is this right, what about the HC timeout? */
			if (!xfer->done) {
				pipe->methods->abort(xfer);
				xfer->status = USBD_TIMEOUT;
			}
		} else
		/* XXX End hack XXX */
			tsleep(xfer, PRIBIO, "usbsyn", 0);
d1000 6
@


1.12
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.11 2000/07/04 11:44:25 fgsch Exp $ */
d1015 1
a1015 1
struct usbd_quirks *
@


1.11
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.c,v 1.10 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: usbdi.c,v 1.71 2000/03/29 01:45:21 augustss Exp $	*/
d80 1
a80 1
Static usbd_status usbd_ar_pipe  __P((usbd_pipe_handle pipe));
d82 2
a83 2
    __P((usbd_xfer_handle, usbd_private_handle, usbd_status));
Static void usbd_start_next __P((usbd_pipe_handle pipe));
d85 1
a85 1
    __P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));
d90 1
a90 1
usbd_init()
d96 1
a96 1
usbd_finish()
d101 2
a102 4
Static __inline int usbd_xfer_isread __P((usbd_xfer_handle xfer));
Static __inline int
usbd_xfer_isread(xfer)
	usbd_xfer_handle xfer;
d112 1
a112 2
void usbd_dump_queue __P((usbd_pipe_handle));

d114 1
a114 2
usbd_dump_queue(pipe)
	usbd_pipe_handle pipe;
d128 2
a129 5
usbd_open_pipe(iface, address, flags, pipe)
	usbd_interface_handle iface;
	u_int8_t address;
	u_int8_t flags;
	usbd_pipe_handle *pipe;
d136 2
a137 6
usbd_open_pipe_ival(iface, address, flags, pipe, ival)
	usbd_interface_handle iface;
	u_int8_t address;
	u_int8_t flags;
	usbd_pipe_handle *pipe;
	int ival;
d167 4
a170 10
usbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, len, cb, ival)
	usbd_interface_handle iface;
	u_int8_t address;
	u_int8_t flags;
	usbd_pipe_handle *pipe;
	usbd_private_handle priv;
	void *buffer;
	u_int32_t len;
	usbd_callback cb;
	int ival;
d208 1
a208 2
usbd_close_pipe(pipe)
	usbd_pipe_handle pipe;
d237 1
a237 2
usbd_transfer(xfer)
	usbd_xfer_handle xfer;
d324 1
a324 2
usbd_sync_transfer(xfer)
	usbd_xfer_handle xfer;
d331 1
a331 3
usbd_alloc_buffer(xfer, size)
	usbd_xfer_handle xfer;
	u_int32_t size;
d344 1
a344 2
usbd_free_buffer(xfer)
	usbd_xfer_handle xfer;
d357 1
a357 2
usbd_get_buffer(xfer)
	usbd_xfer_handle xfer;
d365 1
a365 2
usbd_alloc_xfer(dev)
	usbd_device_handle dev;
d379 1
a379 2
usbd_free_xfer(xfer)
	usbd_xfer_handle xfer;
d395 4
a398 11
usbd_setup_xfer(xfer, pipe, priv, buffer, length, flags, timeout, callback)
	usbd_xfer_handle xfer;
	usbd_pipe_handle pipe;
	usbd_private_handle priv;
	void *buffer;
	u_int32_t length;
	u_int16_t flags;
	u_int32_t timeout;
	void (*callback) __P((usbd_xfer_handle,
			      usbd_private_handle,
			      usbd_status));
d414 5
a418 13
usbd_setup_default_xfer(xfer, dev, priv, timeout, req, buffer, 
			   length, flags, callback)
	usbd_xfer_handle xfer;
	usbd_device_handle dev;
	usbd_private_handle priv;
	u_int32_t timeout;
	usb_device_request_t *req;
	void *buffer;
	u_int32_t length;
	u_int16_t flags;
	void (*callback) __P((usbd_xfer_handle,
			      usbd_private_handle,
			      usbd_status));
d435 3
a437 8
usbd_setup_isoc_xfer(xfer, pipe, priv, frlengths, nframes, flags, callback)
	usbd_xfer_handle xfer;
	usbd_pipe_handle pipe;
	usbd_private_handle priv;
	u_int16_t *frlengths;
	u_int32_t nframes;
	u_int16_t flags;
	usbd_callback callback;
d454 2
a455 6
usbd_get_xfer_status(xfer, priv, buffer, count, status)
	usbd_xfer_handle xfer;
	usbd_private_handle *priv;
	void **buffer;
	u_int32_t *count;
	usbd_status *status;
d468 1
a468 2
usbd_get_config_descriptor(dev)
	usbd_device_handle dev;
d480 1
a480 2
usbd_get_interface_descriptor(iface)
	usbd_interface_handle iface;
d492 1
a492 2
usbd_get_device_descriptor(dev)
	usbd_device_handle dev;
d498 1
a498 3
usbd_interface2endpoint_descriptor(iface, index)
	usbd_interface_handle iface;
	u_int8_t index;
d506 1
a506 2
usbd_abort_pipe(pipe)
	usbd_pipe_handle pipe;
d524 1
a524 2
usbd_clear_endpoint_stall(pipe)
	usbd_pipe_handle pipe;
d555 1
a555 2
usbd_clear_endpoint_stall_async(pipe)
	usbd_pipe_handle pipe;
d574 1
a574 2
usbd_clear_endpoint_toggle(pipe)
	usbd_pipe_handle pipe;
d580 1
a580 3
usbd_endpoint_count(iface, count)
	usbd_interface_handle iface;
	u_int8_t *count;
d593 1
a593 3
usbd_interface_count(dev, count)
	usbd_device_handle dev;
	u_int8_t *count;
d602 2
a603 3
usbd_interface2device_handle(iface, dev)
	usbd_interface_handle iface;
	usbd_device_handle *dev;
d610 2
a611 4
usbd_device2interface_handle(dev, ifaceno, iface)
	usbd_device_handle dev;
	u_int8_t ifaceno;
	usbd_interface_handle *iface;
d622 1
a622 2
usbd_pipe2device_handle(pipe)
	usbd_pipe_handle pipe;
d629 1
a629 3
usbd_set_interface(iface, altidx)
	usbd_interface_handle iface;
	int altidx;
d663 1
a663 3
usbd_get_no_alts(cdesc, ifaceno)
	usb_config_descriptor_t *cdesc;
	int ifaceno;
d681 1
a681 2
usbd_get_interface_altindex(iface)
	usbd_interface_handle iface;
d687 1
a687 3
usbd_get_interface(iface, aiface)
	usbd_interface_handle iface;
	u_int8_t *aiface;
d703 1
a703 2
usbd_ar_pipe(pipe)
	usbd_pipe_handle pipe;
d729 1
a729 2
usb_transfer_complete(xfer)
	usbd_xfer_handle xfer;
d824 1
a824 2
usb_insert_transfer(xfer)
	usbd_xfer_handle xfer;
d846 1
a846 2
usbd_start_next(pipe)
	usbd_pipe_handle pipe;
d880 1
a880 4
usbd_do_request(dev, req, data)
	usbd_device_handle dev;
	usb_device_request_t *req;
	void *data;
d886 10
a895 6
usbd_do_request_flags(dev, req, data, flags, actlen)
	usbd_device_handle dev;
	usb_device_request_t *req;
	void *data;
	u_int16_t flags;
	int *actlen;
d915 2
a916 1
				   data, UGETW(req->wLength), flags, 0);
d974 2
a975 4
usbd_do_request_async_cb(xfer, priv, status)
	usbd_xfer_handle xfer;
	usbd_private_handle priv;
	usbd_status status;
d996 2
a997 4
usbd_do_request_async(dev, req, data)
	usbd_device_handle dev;
	usb_device_request_t *req;
	void *data;
d1016 1
a1016 2
usbd_get_quirks(dev)
	usbd_device_handle dev;
d1027 1
a1027 2
usbd_dopoll(iface)
	usbd_interface_handle iface;
d1033 1
a1033 3
usbd_set_polling(dev, on)
	usbd_device_handle dev;
	int on;
d1043 1
a1043 3
usbd_get_endpoint_descriptor(iface, address)
	usbd_interface_handle iface;
	u_int8_t address;
d1063 1
a1063 2
usbd_ratecheck(last)
	struct timeval *last;
@


1.10
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.9 2000/03/28 19:37:52 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d643 6
d702 1
d707 1
a707 5
	if (iface->endpoints)
		free(iface->endpoints, M_USB);
	iface->endpoints = 0;
	iface->idesc = 0;

d711 11
@


1.9
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi.c,v 1.68 2000/03/25 18:02:33 augustss Exp $	*/
d80 2
a81 2
static usbd_status usbd_ar_pipe  __P((usbd_pipe_handle pipe));
static void usbd_do_request_async_cb 
d83 2
a84 2
static void usbd_start_next __P((usbd_pipe_handle pipe));
static usbd_status usbd_open_pipe_ival
d87 1
a87 1
static int usbd_nbuses = 0;
d101 2
a102 2
static __inline int usbd_xfer_isread __P((usbd_xfer_handle xfer));
static __inline int
d272 3
d328 1
d762 1
a762 1
static usbd_status
d776 1
d784 1
@


1.8
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usbdi.c,v 1.7 1999/11/07 21:30:20 fgsch Exp $	*/
/*	$NetBSD: usbdi.c,v 1.65 2000/03/08 15:34:10 augustss Exp $	*/
d81 5
a85 5
void usbd_do_request_async_cb 
	__P((usbd_xfer_handle, usbd_private_handle, usbd_status));
void usbd_start_next __P((usbd_pipe_handle pipe));
usbd_status usbd_open_pipe_ival
	__P((usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int));
d138 1
a138 1
	return (usbd_open_pipe_ival(iface, address, flags, pipe,
d142 1
a142 1
usbd_status
d149 1
a149 1
{
d196 1
a196 1
	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE,
d206 1
a206 1
			   USBD_NO_TIMEOUT, cb);
d216 1
a216 1
	ipipe->intrxfer = 0;
d242 6
d391 1
a391 1
	if (!xfer)
d394 1
d406 6
d794 2
a795 2
	DPRINTFN(5, ("usb_transfer_complete: pipe=%p xfer=%p status=%d actlen=%d\n",
		     pipe, xfer, xfer->status, xfer->actlen));
d838 1
a838 1
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
d846 1
a846 1
	if (xfer->status && xfer->actlen < xfer->length &&
d848 2
a849 2
		DPRINTFN(-1, ("usbd_transfer_cb: short xfer %d<%d (bytes)\n",
			      xfer->actlen, xfer->length));
d871 2
a872 2
		    xfer->status == USBD_TIMEOUT) &&
		   pipe->iface != NULL)			/* not control pipe */
d960 1
a960 1
		("usbd_do_request: in interrupt context"));
d1065 2
a1066 3
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req, data, 
				   UGETW(req->wLength), 0, 
				   usbd_do_request_async_cb);
d1125 1
a1125 1
 * to notice it.  If the driver continuously tries to do I/O operations
d1132 1
a1132 1
	struct timeval errinterval = { 0, 250000 }; /* 0.25s */
d1143 1
a1143 1
 	return 0;
@


1.7
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usbdi.c,v 1.47 1999/10/13 23:46:10 augustss Exp $	*/
d43 1
a44 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d51 3
d66 4
d81 1
a81 1
	__P((usbd_request_handle, usbd_private_handle, usbd_status));
d83 2
a84 3

static SIMPLEQ_HEAD(, usbd_request) usbd_free_requests =
	SIMPLEQ_HEAD_INITIALIZER(usbd_free_requests);
d97 1
a97 12
	usbd_request_handle reqh;

	if (--usbd_nbuses == 0) {
		/* Last controller is gone, free all requests. */
		for (;;) {
			reqh = SIMPLEQ_FIRST(&usbd_free_requests);
			if (reqh == NULL)
				break;
			SIMPLEQ_REMOVE_HEAD(&usbd_free_requests, reqh, next);
			free(reqh, M_USB);
		}			
	}
d100 1
a100 1
static __inline int usbd_reqh_isread __P((usbd_request_handle reqh));
d102 2
a103 2
usbd_reqh_isread(reqh)
	usbd_request_handle reqh;
d105 2
a106 2
	if (reqh->rqflags & URQ_REQUEST)
		return (reqh->request.bmRequestType & UT_READ);
d108 1
a108 1
		return (reqh->pipe->endpoint->edesc->bEndpointAddress &
d119 1
a119 1
	usbd_request_handle reqh;
d122 4
a125 4
	for (reqh = SIMPLEQ_FIRST(&pipe->queue);
	     reqh;
	     reqh = SIMPLEQ_NEXT(reqh, next)) {
		printf("  reqh=%p\n", reqh);
d137 12
d151 1
a151 1
	usbd_status r;
d154 3
d159 2
d166 1
a166 2
	if ((flags & USBD_EXCLUSIVE_USE) &&
	    ep->refcnt != 0)
d168 3
a170 3
	r = usbd_setup_pipe(iface->device, iface, ep, &p);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d177 1
a177 1
usbd_open_pipe_intr(iface, address, flags, pipe, priv, buffer, length, cb)
d184 1
a184 1
	u_int32_t length;
d186 1
d188 2
a189 2
	usbd_status r;
	usbd_request_handle reqh;
d192 10
a201 6
	r = usbd_open_pipe(iface, address, USBD_EXCLUSIVE_USE, &ipipe);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	reqh = usbd_alloc_request(iface->device);
	if (reqh == 0) {
		r = USBD_NOMEM;
d204 1
a204 1
	usbd_setup_request(reqh, ipipe, priv, buffer, length, flags,
d206 1
a206 1
	ipipe->intrreqh = reqh;
d208 1
a208 1
	r = usbd_transfer(reqh);
d210 1
a210 1
	if (r != USBD_IN_PROGRESS)
d215 1
a215 1
	ipipe->intrreqh = 0;
d217 1
a217 1
	usbd_free_request(reqh);
d220 1
a220 1
	return r;
d228 1
a228 1
	if (pipe == 0) {
d241 2
a242 2
	if (pipe->intrreqh)
		usbd_free_request(pipe->intrreqh);
d248 2
a249 2
usbd_transfer(reqh)
	usbd_request_handle reqh;
d251 3
a253 3
	usbd_pipe_handle pipe = reqh->pipe;
	usb_dma_t *dmap = &reqh->dmabuf;
	usbd_status r;
d257 2
a258 2
	DPRINTFN(5,("usbd_transfer: reqh=%p, flags=%d, pipe=%p, running=%d\n",
		    reqh, reqh->flags, pipe, pipe->running));
d263 1
a263 1
	reqh->done = 0;
d265 1
a265 1
	size = reqh->length;
d267 1
a267 1
	if (!(reqh->rqflags & URQ_DEV_DMABUF) && size != 0) {
d271 1
a271 1
		if (reqh->rqflags & URQ_AUTO_DMABUF)
d274 4
a277 4
		r = bus->methods->allocm(bus, dmap, size);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
		reqh->rqflags |= URQ_AUTO_DMABUF;
d281 3
a283 3
	if (!(reqh->flags & USBD_NO_COPY) && size != 0 && 
	    !usbd_reqh_isread(reqh))
		memcpy(KERNADDR(dmap), reqh->buffer, size);
d285 1
a285 1
	r = pipe->methods->transfer(reqh);
d287 1
a287 1
	if (r != USBD_IN_PROGRESS && r != USBD_NORMAL_COMPLETION) {
d289 1
a289 1
		if (reqh->rqflags & URQ_AUTO_DMABUF) {
d292 2
a293 2
			bus->methods->freem(bus, &reqh->dmabuf);
			reqh->rqflags &= ~URQ_AUTO_DMABUF;
d297 2
a298 2
	if (!(reqh->flags & USBD_SYNCHRONOUS))
		return (r);
d301 2
a302 2
	if (r != USBD_IN_PROGRESS)
		return (r);
d304 1
a304 1
	if (!reqh->done) {
d307 18
a324 1
		tsleep(reqh, PRIBIO, "usbsyn", 0);
d327 1
a327 1
	return (reqh->status);
d332 2
a333 2
usbd_sync_transfer(reqh)
	usbd_request_handle reqh;
d335 2
a336 2
	reqh->flags |= USBD_SYNCHRONOUS;
	return (usbd_transfer(reqh));
d340 2
a341 2
usbd_alloc_buffer(reqh, size)
	usbd_request_handle reqh;
d344 2
a345 2
	struct usbd_bus *bus = reqh->device->bus;
	usbd_status r;
d347 2
a348 2
	r = bus->methods->allocm(bus, &reqh->dmabuf, size);
	if (r != USBD_NORMAL_COMPLETION)
d350 2
a351 2
	reqh->rqflags |= URQ_DEV_DMABUF;
	return (KERNADDR(&reqh->dmabuf));
d355 2
a356 2
usbd_free_buffer(reqh)
	usbd_request_handle reqh;
d359 1
a359 1
	if (!(reqh->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {
d364 2
a365 2
	reqh->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);
	reqh->device->bus->methods->freem(reqh->device->bus, &reqh->dmabuf);
d369 2
a370 2
usbd_get_buffer(reqh)
	usbd_request_handle reqh;
d372 1
a372 1
	if (!(reqh->rqflags & URQ_DEV_DMABUF))
d374 1
a374 1
	return (KERNADDR(&reqh->dmabuf));
d377 2
a378 2
usbd_request_handle 
usbd_alloc_request(dev)
d381 1
a381 1
	usbd_request_handle reqh;
d383 6
a388 11
	reqh = SIMPLEQ_FIRST(&usbd_free_requests);
	if (reqh)
		SIMPLEQ_REMOVE_HEAD(&usbd_free_requests, reqh, next);
	else
		reqh = malloc(sizeof(*reqh), M_USB, M_NOWAIT);
	if (!reqh)
		return (0);
	memset(reqh, 0, sizeof *reqh);
	reqh->device = dev;
	DPRINTFN(5,("usbd_alloc_request() = %p\n", reqh));
	return (reqh);
d392 2
a393 2
usbd_free_request(reqh)
	usbd_request_handle reqh;
d395 4
a398 4
	DPRINTFN(5,("usbd_free_request: %p\n", reqh));
	if (reqh->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		usbd_free_buffer(reqh);
	SIMPLEQ_INSERT_HEAD(&usbd_free_requests, reqh, next);
d403 2
a404 2
usbd_setup_request(reqh, pipe, priv, buffer, length, flags, timeout, callback)
	usbd_request_handle reqh;
d411 1
a411 1
	void (*callback) __P((usbd_request_handle,
d415 11
a425 11
	reqh->pipe = pipe;
	reqh->priv = priv;
	reqh->buffer = buffer;
	reqh->length = length;
	reqh->actlen = 0;
	reqh->flags = flags;
	reqh->timeout = timeout;
	reqh->status = USBD_NOT_STARTED;
	reqh->callback = callback;
	reqh->rqflags &= ~URQ_REQUEST;
	reqh->nframes = 0;
d429 1
a429 1
usbd_setup_default_request(reqh, dev, priv, timeout, req, buffer, 
d431 1
a431 1
	usbd_request_handle reqh;
d439 1
a439 1
	void (*callback) __P((usbd_request_handle,
d443 12
a454 12
	reqh->pipe = dev->default_pipe;
	reqh->priv = priv;
	reqh->buffer = buffer;
	reqh->length = length;
	reqh->actlen = 0;
	reqh->flags = flags;
	reqh->timeout = timeout;
	reqh->status = USBD_NOT_STARTED;
	reqh->callback = callback;
	reqh->request = *req;
	reqh->rqflags |= URQ_REQUEST;
	reqh->nframes = 0;
d458 2
a459 2
usbd_setup_isoc_request(reqh, pipe, priv, frlengths, nframes, flags, callback)
	usbd_request_handle reqh;
d467 12
a478 12
	reqh->pipe = pipe;
	reqh->priv = priv;
	reqh->buffer = 0;
	reqh->length = 0;
	reqh->actlen = 0;
	reqh->flags = flags;
	reqh->timeout = USBD_NO_TIMEOUT;
	reqh->status = USBD_NOT_STARTED;
	reqh->callback = callback;
	reqh->rqflags &= ~URQ_REQUEST;
	reqh->frlengths = frlengths;
	reqh->nframes = nframes;
d482 2
a483 2
usbd_get_request_status(reqh, priv, buffer, count, status)
	usbd_request_handle reqh;
d489 8
a496 8
	if (priv)
		*priv = reqh->priv;
	if (buffer)
		*buffer = reqh->buffer;
	if (count)
		*count = reqh->actlen;
	if (status)
		*status = reqh->status;
d503 6
d516 6
d546 1
a546 1
	usbd_status r;
d550 1
a550 1
	if (pipe == 0) {
d556 1
a556 1
	r = usbd_ar_pipe(pipe);
d558 1
a558 1
	return (r);
d567 1
a567 1
	usbd_status r;
d582 1
a582 1
	r = usbd_do_request(dev, &req, 0);
d585 1
a585 1
	if (r == USBD_NORMAL_COMPLETION) {
d590 1
a590 1
	return (r);
d599 1
a599 1
	usbd_status r;
d608 10
a617 2
	r = usbd_do_request_async(dev, &req, 0);
	return (r);
d634 1
a634 1
	if (!dev->cdesc)
d655 1
a655 1
	if (!dev->cdesc)
d677 1
a677 1
	usbd_status r;
d687 3
a689 3
	r = usbd_fill_iface_data(iface->device, iface->index, altidx);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d696 1
a696 1
	return usbd_do_request(iface->device, &req, 0);
d738 1
a738 1
	return usbd_do_request(iface->device, &req, aiface);
d748 1
a748 1
	usbd_request_handle reqh;
d758 3
a760 3
	while ((reqh = SIMPLEQ_FIRST(&pipe->queue))) {
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p reqh=%p (methods=%p)\n", 
			    pipe, reqh, pipe->methods));
d762 1
a762 1
		pipe->methods->abort(reqh);
d770 2
a771 2
usb_transfer_complete(reqh)
	usbd_request_handle reqh;
d773 2
a774 2
	usbd_pipe_handle pipe = reqh->pipe;
	usb_dma_t *dmap = &reqh->dmabuf;
d780 2
a781 2
	DPRINTFN(5, ("usb_transfer_complete: pipe=%p reqh=%p status=%d actlen=%d\n",
		     pipe, reqh, reqh->status, reqh->actlen));
d784 2
a785 2
	if (!pipe) {
		printf("usbd_transfer_cb: pipe==0, reqh=%p\n", reqh);
d794 2
a795 2
	if (!(reqh->flags & USBD_NO_COPY) && reqh->actlen != 0 &&
	    usbd_reqh_isread(reqh)) {
d797 1
a797 1
		if (reqh->actlen > reqh->length) {
d799 2
a800 2
			       reqh->actlen, reqh->length);
			reqh->actlen = reqh->length;
d803 1
a803 1
		memcpy(reqh->buffer, KERNADDR(dmap), reqh->actlen);
d807 1
a807 1
	if (reqh->rqflags & URQ_AUTO_DMABUF) {
d811 1
a811 1
			reqh->rqflags &= ~URQ_AUTO_DMABUF;
a814 3
	if (pipe->methods->done)
		pipe->methods->done(reqh);

d818 1
a818 1
		if (reqh != SIMPLEQ_FIRST(&pipe->queue))
d820 1
a820 1
			       reqh, SIMPLEQ_FIRST(&pipe->queue));
d822 1
a822 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);
d824 2
d831 3
a833 4
	reqh->done = 1;
	if (reqh->status == USBD_NORMAL_COMPLETION &&
	    reqh->actlen < reqh->length &&
	    !(reqh->flags & USBD_SHORT_XFER_OK)) {
d835 2
a836 2
			      reqh->actlen, reqh->length));
		reqh->status = USBD_SHORT_XFER;
d839 11
a849 2
	if (reqh->callback)
		reqh->callback(reqh, reqh->priv, reqh->status);
d851 2
a852 2
	if ((reqh->flags & USBD_SYNCHRONOUS) && !polling)
		wakeup(reqh);
d856 3
a858 2
		if (reqh->status == USBD_CANCELLED ||
		    reqh->status == USBD_TIMEOUT)
d866 2
a867 2
usb_insert_transfer(reqh)
	usbd_request_handle reqh;
d869 2
a870 2
	usbd_pipe_handle pipe = reqh->pipe;
	usbd_status r;
d874 1
a874 1
		    pipe, pipe->running, reqh->timeout));
d876 1
a876 1
	SIMPLEQ_INSERT_TAIL(&pipe->queue, reqh, next);
d878 1
a878 1
		r = USBD_IN_PROGRESS;
d881 1
a881 1
		r = USBD_NORMAL_COMPLETION;
d884 1
a884 1
	return (r);
d892 2
a893 2
	usbd_request_handle reqh;
	usbd_status r;
a896 2
	DPRINTFN(10, ("usbd_start_next: pipe=%p\n", pipe));
	
d898 2
a899 2
	if (!pipe) {
		printf("usbd_start_next: pipe == 0\n");
d902 2
a903 2
	if (!pipe->methods || !pipe->methods->start) {
		printf("usbd_start_next:  no start method\n");
d909 3
a911 3
	reqh = SIMPLEQ_FIRST(&pipe->queue);
	DPRINTFN(5, ("usbd_start_next: pipe=%p start reqh=%p\n", pipe, reqh));
	if (!reqh)
d913 4
a916 4
	else {
		r = pipe->methods->start(reqh);
		if (r != USBD_IN_PROGRESS) {
			printf("usbd_start_next: error=%d\n", r);
d940 2
a941 2
	usbd_request_handle reqh;
	usbd_status r;
d944 4
d954 2
a955 2
	reqh = usbd_alloc_request(dev);
	if (reqh == 0)
d957 1
a957 1
	usbd_setup_default_request(reqh, dev, 0, USBD_DEFAULT_TIMEOUT, req,
d959 1
a959 1
	r = usbd_sync_transfer(reqh);
d961 1
a961 1
	if (reqh->actlen > reqh->length)
d964 9
a972 9
			 dev->address, reqh->request.bmRequestType,
			 reqh->request.bRequest, UGETW(reqh->request.wValue),
			 UGETW(reqh->request.wIndex), 
			 UGETW(reqh->request.wLength), 
			 reqh->length, reqh->actlen));
#endif
	if (actlen)
		*actlen = reqh->actlen;
	if (r == USBD_STALLED) {
d981 1
a981 1
		usbd_status nr;
d988 1
a988 1
		usbd_setup_default_request(reqh, dev, 0, USBD_DEFAULT_TIMEOUT,
d991 2
a992 2
		nr = usbd_sync_transfer(reqh);
		if (nr != USBD_NORMAL_COMPLETION)
d1003 1
a1003 1
		usbd_setup_default_request(reqh, dev, 0, USBD_DEFAULT_TIMEOUT,
d1005 2
a1006 2
		nr = usbd_sync_transfer(reqh);
		if (nr != USBD_NORMAL_COMPLETION)
d1011 2
a1012 2
	usbd_free_request(reqh);
	return (r);
d1016 2
a1017 2
usbd_do_request_async_cb(reqh, priv, status)
	usbd_request_handle reqh;
d1022 1
a1022 1
	if (reqh->actlen > reqh->length)
d1025 6
a1030 6
			 reqh->pipe->device->address, 
			 reqh->request.bmRequestType,
			 reqh->request.bRequest, UGETW(reqh->request.wValue),
			 UGETW(reqh->request.wIndex), 
			 UGETW(reqh->request.wLength), 
			 reqh->length, reqh->actlen));
d1032 1
a1032 1
	usbd_free_request(reqh);
d1045 2
a1046 2
	usbd_request_handle reqh;
	usbd_status r;
d1048 2
a1049 2
	reqh = usbd_alloc_request(dev);
	if (reqh == 0)
d1051 1
a1051 1
	usbd_setup_default_request(reqh, dev, 0, USBD_DEFAULT_TIMEOUT, req, data, 
d1054 4
a1057 4
	r = usbd_transfer(reqh);
	if (r != USBD_IN_PROGRESS) {
		usbd_free_request(reqh);
		return (r);
d1082 2
a1083 2
usbd_set_polling(iface, on)
	usbd_interface_handle iface;
d1087 1
a1087 1
		iface->device->bus->use_polling++;
d1089 1
a1089 1
		iface->device->bus->use_polling--;
d1107 15
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usbdi.c,v 1.13 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: usbdi.c,v 1.77 2000/09/23 21:02:04 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi.c,v 1.28 1999/11/17 22:33:49 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d43 1
a44 1
#include <sys/kernel.h>
a50 3
#if defined(DIAGNOSTIC) && defined(__i386__)
#include <machine/cpu.h>
#endif
a62 4
#if defined(__FreeBSD__)
#include "usb_if.h"
#endif

d72 4
a75 6
Static usbd_status usbd_ar_pipe(usbd_pipe_handle pipe);
Static void usbd_do_request_async_cb 
(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void usbd_start_next(usbd_pipe_handle pipe);
Static usbd_status usbd_open_pipe_ival
(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d77 4
a80 1
Static int usbd_nbuses = 0;
d83 1
a83 1
usbd_init(void)
d89 1
a89 1
usbd_finish(void)
d91 12
a102 1
	--usbd_nbuses;
d105 1
d107 2
a108 1
usbd_xfer_isread(usbd_xfer_handle xfer)
d110 2
a111 2
	if (xfer->rqflags & URQ_REQUEST)
		return (xfer->request.bmRequestType & UT_READ);
d113 1
a113 1
		return (xfer->pipe->endpoint->edesc->bEndpointAddress &
d118 2
a119 1
void usbd_dump_queue(usbd_pipe_handle pipe);
d121 2
a122 1
usbd_dump_queue(usbd_pipe_handle pipe)
d124 1
a124 1
	usbd_xfer_handle xfer;
d127 4
a130 4
	for (xfer = SIMPLEQ_FIRST(&pipe->queue);
	     xfer;
	     xfer = SIMPLEQ_NEXT(xfer, next)) {
		printf("  xfer=%p\n", xfer);
d136 5
a140 10
usbd_open_pipe(usbd_interface_handle iface, u_int8_t address,
	       u_int8_t flags, usbd_pipe_handle *pipe)
{ 
	return (usbd_open_pipe_ival(iface, address, flags, pipe, 
				    USBD_DEFAULT_INTERVAL));
}

usbd_status 
usbd_open_pipe_ival(usbd_interface_handle iface, u_int8_t address,
		    u_int8_t flags, usbd_pipe_handle *pipe, int ival)
d144 1
a144 1
	usbd_status err;
a146 3
	DPRINTFN(3,("usbd_open_pipe: iface=%p address=0x%x flags=0x%x\n",
		    iface, address, flags));

a148 2
		if (ep->edesc == NULL)
			return (USBD_IOERROR);
d154 2
a155 1
	if ((flags & USBD_EXCLUSIVE_USE) && ep->refcnt != 0)
d157 3
a159 3
	err = usbd_setup_pipe(iface->device, iface, ep, ival, &p);
	if (err)
		return (err);
d166 9
a174 4
usbd_open_pipe_intr(usbd_interface_handle iface, u_int8_t address,
		    u_int8_t flags, usbd_pipe_handle *pipe,
		    usbd_private_handle priv, void *buffer, u_int32_t len,
		    usbd_callback cb, int ival)
d176 2
a177 2
	usbd_status err;
	usbd_xfer_handle xfer;
d180 6
a185 10
	DPRINTFN(3,("usbd_open_pipe_intr: address=0x%x flags=0x%x len=%d\n",
		    address, flags, len));

	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE, 
				  &ipipe, ival);
	if (err)
		return (err);
	xfer = usbd_alloc_xfer(iface->device);
	if (xfer == NULL) {
		err = USBD_NOMEM;
d188 3
a190 3
	usbd_setup_xfer(xfer, ipipe, priv, buffer, len, flags,
	    USBD_NO_TIMEOUT, cb);
	ipipe->intrxfer = xfer;
d192 1
a192 1
	err = usbd_transfer(xfer);
d194 1
a194 1
	if (err != USBD_IN_PROGRESS)
d199 1
a199 1
	ipipe->intrxfer = NULL;
d201 1
a201 1
	usbd_free_xfer(xfer);
d204 1
a204 1
	return (err);
d208 2
a209 1
usbd_close_pipe(usbd_pipe_handle pipe)
d212 1
a212 1
	if (pipe == NULL) {
d225 2
a226 8
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&pipe->abort_handle)) {
		callout_stop(&pipe->abort_handle);
		printf("usbd_close_pipe: abort_handle pending");
	}
#endif
	if (pipe->intrxfer != NULL)
		usbd_free_xfer(pipe->intrxfer);
d232 2
a233 1
usbd_transfer(usbd_xfer_handle xfer)
d235 3
a237 3
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
	usbd_status err;
d241 2
a242 2
	DPRINTFN(5,("usbd_transfer: xfer=%p, flags=%d, pipe=%p, running=%d\n",
		    xfer, xfer->flags, pipe, pipe->running));
d247 1
a247 1
	xfer->done = 0;
d249 1
a249 4
	if (pipe->aborting)
		return (USBD_CANCELLED);

	size = xfer->length;
d251 1
a251 1
	if (!(xfer->rqflags & URQ_DEV_DMABUF) && size != 0) {
d255 1
a255 1
		if (xfer->rqflags & URQ_AUTO_DMABUF)
d258 4
a261 4
		err = bus->methods->allocm(bus, dmap, size);
		if (err)
			return (err);
		xfer->rqflags |= URQ_AUTO_DMABUF;
d265 3
a267 3
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 && 
	    !usbd_xfer_isread(xfer))
		memcpy(KERNADDR(dmap), xfer->buffer, size);
d269 1
a269 1
	err = pipe->methods->transfer(xfer);
d271 1
a271 1
	if (err != USBD_IN_PROGRESS && err) {
d273 1
a273 1
		if (xfer->rqflags & URQ_AUTO_DMABUF) {
d276 2
a277 2
			bus->methods->freem(bus, &xfer->dmabuf);
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
d281 2
a282 2
	if (!(xfer->flags & USBD_SYNCHRONOUS))
		return (err);
d285 2
a286 2
	if (err != USBD_IN_PROGRESS)
		return (err);
d288 1
a288 1
	if (!xfer->done) {
d291 1
a291 19
		/* XXX Temporary hack XXX */
		if (xfer->flags & USBD_NO_TSLEEP) {
			int i;
			usbd_bus_handle bus = pipe->device->bus;
			int to = xfer->timeout * 1000;
			for (i = 0; i < to; i += 10) {
				delay(10);
				bus->methods->do_poll(bus);
				if (xfer->done)
					break;
			}
			/* XXX Is this right, what about the HC timeout? */
			if (!xfer->done) {
				pipe->methods->abort(xfer);
				xfer->status = USBD_TIMEOUT;
			}
		} else
		/* XXX End hack XXX */
			tsleep(xfer, PRIBIO, "usbsyn", 0);
d294 1
a294 1
	return (xfer->status);
d299 2
a300 1
usbd_sync_transfer(usbd_xfer_handle xfer)
d302 2
a303 2
	xfer->flags |= USBD_SYNCHRONOUS;
	return (usbd_transfer(xfer));
d307 3
a309 1
usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size)
d311 2
a312 2
	struct usbd_bus *bus = xfer->device->bus;
	usbd_status err;
d314 2
a315 2
	err = bus->methods->allocm(bus, &xfer->dmabuf, size);
	if (err)
d317 2
a318 2
	xfer->rqflags |= URQ_DEV_DMABUF;
	return (KERNADDR(&xfer->dmabuf));
d322 2
a323 1
usbd_free_buffer(usbd_xfer_handle xfer)
d326 1
a326 1
	if (!(xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))) {
d331 2
a332 2
	xfer->rqflags &= ~(URQ_DEV_DMABUF | URQ_AUTO_DMABUF);
	xfer->device->bus->methods->freem(xfer->device->bus, &xfer->dmabuf);
d336 2
a337 1
usbd_get_buffer(usbd_xfer_handle xfer)
d339 1
a339 1
	if (!(xfer->rqflags & URQ_DEV_DMABUF))
d341 1
a341 1
	return (KERNADDR(&xfer->dmabuf));
d344 3
a346 2
usbd_xfer_handle 
usbd_alloc_xfer(usbd_device_handle dev)
d348 1
a348 1
	usbd_xfer_handle xfer;
d350 11
a360 7
	xfer = dev->bus->methods->allocx(dev->bus);
	if (xfer == NULL)
		return (NULL);
	xfer->device = dev;
	usb_callout_init(xfer->timeout_handle);
	DPRINTFN(5,("usbd_alloc_xfer() = %p\n", xfer));
	return (xfer);
d364 2
a365 1
usbd_free_xfer(usbd_xfer_handle xfer)
d367 4
a370 10
	DPRINTFN(5,("usbd_free_xfer: %p\n", xfer));
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		usbd_free_buffer(xfer);
#if defined(__NetBSD__) && defined(DIAGNOSTIC)
	if (callout_pending(&xfer->timeout_handle)) {
		callout_stop(&xfer->timeout_handle);
		printf("usbd_free_xfer: timout_handle pending");
	}
#endif
	xfer->device->bus->methods->freex(xfer->device->bus, xfer);
d375 23
a397 16
usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		usbd_private_handle priv, void *buffer, u_int32_t length,
		u_int16_t flags, u_int32_t timeout,
		usbd_callback callback)
{
	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->nframes = 0;
d401 26
a426 18
usbd_setup_default_xfer(usbd_xfer_handle xfer, usbd_device_handle dev,
			usbd_private_handle priv, u_int32_t timeout,
			usb_device_request_t *req, void *buffer,
			u_int32_t length, u_int16_t flags,
			usbd_callback callback)
{
	xfer->pipe = dev->default_pipe;
	xfer->priv = priv;
	xfer->buffer = buffer;
	xfer->length = length;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = timeout;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->request = *req;
	xfer->rqflags |= URQ_REQUEST;
	xfer->nframes = 0;
d430 21
a450 16
usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		     usbd_private_handle priv, u_int16_t *frlengths,
		     u_int32_t nframes, u_int16_t flags, usbd_callback callback)
{
	xfer->pipe = pipe;
	xfer->priv = priv;
	xfer->buffer = 0;
	xfer->length = 0;
	xfer->actlen = 0;
	xfer->flags = flags;
	xfer->timeout = USBD_NO_TIMEOUT;
	xfer->status = USBD_NOT_STARTED;
	xfer->callback = callback;
	xfer->rqflags &= ~URQ_REQUEST;
	xfer->frlengths = frlengths;
	xfer->nframes = nframes;
d454 15
a468 11
usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle *priv,
		     void **buffer, u_int32_t *count, usbd_status *status)
{
	if (priv != NULL)
		*priv = xfer->priv;
	if (buffer != NULL)
		*buffer = xfer->buffer;
	if (count != NULL)
		*count = xfer->actlen;
	if (status != NULL)
		*status = xfer->status;
d472 2
a473 1
usbd_get_config_descriptor(usbd_device_handle dev)
a474 6
#ifdef DIAGNOSTIC
	if (dev == NULL) {
		printf("usbd_get_config_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
d479 2
a480 1
usbd_get_interface_descriptor(usbd_interface_handle iface)
a481 6
#ifdef DIAGNOSTIC
	if (iface == NULL) {
		printf("usbd_get_interface_descriptor: dev == NULL\n");
		return (NULL);
	}
#endif
d486 2
a487 1
usbd_get_device_descriptor(usbd_device_handle dev)
d493 3
a495 1
usbd_interface2endpoint_descriptor(usbd_interface_handle iface, u_int8_t index)
d503 2
a504 1
usbd_abort_pipe(usbd_pipe_handle pipe)
d506 1
a506 1
	usbd_status err;
d510 1
a510 1
	if (pipe == NULL) {
d516 1
a516 1
	err = usbd_ar_pipe(pipe);
d518 1
a518 1
	return (err);
d522 2
a523 1
usbd_clear_endpoint_stall(usbd_pipe_handle pipe)
d527 1
a527 1
	usbd_status err;
d542 1
a542 1
	err = usbd_do_request(dev, &req, 0);
d545 1
a545 1
	if (!err) {
d550 1
a550 1
	return (err);
d554 2
a555 1
usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe)
d559 1
a559 1
	usbd_status err;
d568 2
a569 9
	err = usbd_do_request_async(dev, &req, 0);
	return (err);
}

void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe); /* XXXXX */
void
usbd_clear_endpoint_toggle(usbd_pipe_handle pipe)
{
	pipe->methods->cleartoggle(pipe);
d573 3
a575 1
usbd_endpoint_count(usbd_interface_handle iface, u_int8_t *count)
a576 6
#ifdef DIAGNOSTIC
	if (iface == NULL || iface->idesc == NULL) {
		printf("usbd_endpoint_count: NULL pointer\n");
		return (USBD_INVAL);
	}
#endif
d582 3
a584 1
usbd_interface_count(usbd_device_handle dev, u_int8_t *count)
d586 1
a586 1
	if (dev->cdesc == NULL)
d593 3
a595 2
usbd_interface2device_handle(usbd_interface_handle iface,
			     usbd_device_handle *dev)
d602 4
a605 2
usbd_device2interface_handle(usbd_device_handle dev,
			     u_int8_t ifaceno, usbd_interface_handle *iface)
d607 1
a607 1
	if (dev->cdesc == NULL)
d616 2
a617 1
usbd_pipe2device_handle(usbd_pipe_handle pipe)
d624 3
a626 1
usbd_set_interface(usbd_interface_handle iface, int altidx)
d629 1
a629 2
	usbd_status err;
	void *endpoints;
d634 8
a641 15
	endpoints = iface->endpoints;
	err = usbd_fill_iface_data(iface->device, iface->index, altidx);
	if (err)
		return (err);

	/* new setting works, we can free old endpoints */
	if (endpoints != NULL)
		free(endpoints, M_USB);

#ifdef DIAGNOSTIC
	if (iface->idesc == NULL) {
		printf("usbd_set_interface: NULL pointer\n");
		return (USBD_INVAL);
	}
#endif
d648 1
a648 1
	return (usbd_do_request(iface->device, &req, 0));
d652 3
a654 1
usbd_get_no_alts(usb_config_descriptor_t *cdesc, int ifaceno)
d672 2
a673 1
usbd_get_interface_altindex(usbd_interface_handle iface)
d679 3
a681 1
usbd_get_interface(usbd_interface_handle iface, u_int8_t *aiface)
d690 1
a690 1
	return (usbd_do_request(iface->device, &req, aiface));
d696 3
a698 2
Static usbd_status
usbd_ar_pipe(usbd_pipe_handle pipe)
d700 1
a700 1
	usbd_xfer_handle xfer;
d710 3
a712 4
	pipe->aborting = 1;
	while ((xfer = SIMPLEQ_FIRST(&pipe->queue)) != NULL) {
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n", 
			    pipe, xfer, pipe->methods));
d714 1
a714 1
		pipe->methods->abort(xfer);
a716 1
	pipe->aborting = 0;
d722 2
a723 1
usb_transfer_complete(usbd_xfer_handle xfer)
d725 2
a726 2
	usbd_pipe_handle pipe = xfer->pipe;
	usb_dma_t *dmap = &xfer->dmabuf;
d732 2
a733 2
	DPRINTFN(5, ("usb_transfer_complete: pipe=%p xfer=%p status=%d "
		     "actlen=%d\n", pipe, xfer, xfer->status, xfer->actlen));
d736 2
a737 2
	if (pipe == NULL) {
		printf("usbd_transfer_cb: pipe==0, xfer=%p\n", xfer);
d746 2
a747 2
	if (!(xfer->flags & USBD_NO_COPY) && xfer->actlen != 0 &&
	    usbd_xfer_isread(xfer)) {
d749 1
a749 1
		if (xfer->actlen > xfer->length) {
d751 2
a752 2
			       xfer->actlen, xfer->length);
			xfer->actlen = xfer->length;
d755 1
a755 1
		memcpy(xfer->buffer, KERNADDR(dmap), xfer->actlen);
d759 1
a759 1
	if (xfer->rqflags & URQ_AUTO_DMABUF) {
d763 1
a763 1
			xfer->rqflags &= ~URQ_AUTO_DMABUF;
d767 3
d773 1
a773 1
		if (xfer != SIMPLEQ_FIRST(&pipe->queue))
d775 1
a775 1
			       xfer, SIMPLEQ_FIRST(&pipe->queue));
d777 1
a777 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, xfer, next);
a778 2
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n", 
		    repeat, SIMPLEQ_FIRST(&pipe->queue)));
d784 7
a790 6
	xfer->done = 1;
	if (!xfer->status && xfer->actlen < xfer->length &&
	    !(xfer->flags & USBD_SHORT_XFER_OK)) {
		DPRINTFN(-1,("usbd_transfer_cb: short transfer %d<%d\n",
			     xfer->actlen, xfer->length));
		xfer->status = USBD_SHORT_XFER;
d793 2
a794 2
	if (xfer->callback)
		xfer->callback(xfer, xfer->priv, xfer->status);
d796 2
a797 11
#ifdef DIAGNOSTIC
	if (pipe->methods->done != NULL)
		pipe->methods->done(xfer);
	else
		printf("usb_transfer_complete: pipe->methods->done == NULL\n");
#else
	pipe->methods->done(xfer);
#endif

	if ((xfer->flags & USBD_SYNCHRONOUS) && !polling)
		wakeup(xfer);
d801 2
a802 3
		if ((xfer->status == USBD_CANCELLED ||
		     xfer->status == USBD_TIMEOUT) &&
		    pipe->iface != NULL)		/* not control pipe */
d810 2
a811 1
usb_insert_transfer(usbd_xfer_handle xfer)
d813 2
a814 2
	usbd_pipe_handle pipe = xfer->pipe;
	usbd_status err;
d818 1
a818 1
		    pipe, pipe->running, xfer->timeout));
d820 1
a820 1
	SIMPLEQ_INSERT_TAIL(&pipe->queue, xfer, next);
d822 1
a822 1
		err = USBD_IN_PROGRESS;
d825 1
a825 1
		err = USBD_NORMAL_COMPLETION;
d828 1
a828 1
	return (err);
d833 2
a834 1
usbd_start_next(usbd_pipe_handle pipe)
d836 2
a837 2
	usbd_xfer_handle xfer;
	usbd_status err;
d841 2
d844 2
a845 2
	if (pipe == NULL) {
		printf("usbd_start_next: pipe == NULL\n");
d848 2
a849 2
	if (pipe->methods == NULL || pipe->methods->start == NULL) {
		printf("usbd_start_next: pipe=%p no start method\n", pipe);
d855 3
a857 3
	xfer = SIMPLEQ_FIRST(&pipe->queue);
	DPRINTFN(5, ("usbd_start_next: pipe=%p, xfer=%p\n", pipe, xfer));
	if (xfer == NULL) {
d859 4
a862 4
	} else {
		err = pipe->methods->start(xfer);
		if (err != USBD_IN_PROGRESS) {
			printf("usbd_start_next: error=%d\n", err);
d870 4
a873 1
usbd_do_request(usbd_device_handle dev, usb_device_request_t *req, void *data)
d879 6
a884 10
usbd_do_request_flags(usbd_device_handle dev, usb_device_request_t *req,
		      void *data, u_int16_t flags, int *actlen)
{
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req, 
					   data, flags, actlen));
}

usbd_status
usbd_do_request_flags_pipe(usbd_device_handle dev, usbd_pipe_handle pipe,
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen)
d886 2
a887 2
	usbd_xfer_handle xfer;
	usbd_status err;
a889 4
#if defined(__i386__) && defined(__FreeBSD__)
	KASSERT(intr_nesting_level == 0,
	       	("usbd_do_request: in interrupt context"));
#endif
d896 2
a897 2
	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
d899 3
a901 4
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
				data, UGETW(req->wLength), flags, 0);
	xfer->pipe = pipe;
	err = usbd_sync_transfer(xfer);
d903 1
a903 1
	if (xfer->actlen > xfer->length)
d906 9
a914 9
			 dev->address, xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex), 
			 UGETW(xfer->request.wLength), 
			 xfer->length, xfer->actlen));
#endif
	if (actlen != NULL)
		*actlen = xfer->actlen;
	if (err == USBD_STALLED) {
d923 1
a923 1
		usbd_status nerr;
d930 1
a930 1
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
d933 2
a934 2
		nerr = usbd_sync_transfer(xfer);
		if (nerr)
d945 1
a945 1
		usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT,
d947 2
a948 2
		nerr = usbd_sync_transfer(xfer);
		if (nerr)
d953 2
a954 2
	usbd_free_xfer(xfer);
	return (err);
d958 4
a961 2
usbd_do_request_async_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
			 usbd_status status)
d964 1
a964 1
	if (xfer->actlen > xfer->length)
d967 6
a972 6
			 xfer->pipe->device->address, 
			 xfer->request.bmRequestType,
			 xfer->request.bRequest, UGETW(xfer->request.wValue),
			 UGETW(xfer->request.wIndex), 
			 UGETW(xfer->request.wLength), 
			 xfer->length, xfer->actlen));
d974 1
a974 1
	usbd_free_xfer(xfer);
d982 4
a985 2
usbd_do_request_async(usbd_device_handle dev, usb_device_request_t *req,
		      void *data)
d987 2
a988 2
	usbd_xfer_handle xfer;
	usbd_status err;
d990 2
a991 2
	xfer = usbd_alloc_xfer(dev);
	if (xfer == NULL)
d993 7
a999 6
	usbd_setup_default_xfer(xfer, dev, 0, USBD_DEFAULT_TIMEOUT, req,
	    data, UGETW(req->wLength), 0, usbd_do_request_async_cb);
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		usbd_free_xfer(xfer);
		return (err);
d1004 3
a1006 2
const struct usbd_quirks *
usbd_get_quirks(usbd_device_handle dev)
d1017 2
a1018 1
usbd_dopoll(usbd_interface_handle iface)
d1024 3
a1026 1
usbd_set_polling(usbd_device_handle dev, int on)
d1029 1
a1029 1
		dev->bus->use_polling++;
d1031 1
a1031 1
		dev->bus->use_polling--;
d1036 3
a1038 1
usbd_get_endpoint_descriptor(usbd_interface_handle iface, u_int8_t address)
a1050 14
/*
 * usbd_ratecheck() can limit the number of error messages that occurs.
 * When a device is unplugged it may take up to 0.25s for the hub driver
 * to notice it.  If the driver continuosly tries to do I/O operations
 * this can generate a large number of messages.
 */
int
usbd_ratecheck(struct timeval *last)
{
	static struct timeval errinterval = { 0, 250000 }; /* 0.25 s*/

	return (ratecheck(last, &errinterval));
}

d1057 1
a1057 1
 	return (0);
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi.c,v 1.81 2001/04/17 00:05:33 augustss Exp $	*/
d298 19
a316 1
		tsleep(xfer, PRIBIO, "usbsyn", 0);
a1017 6
#ifdef DIAGNOSTIC
	if (dev == NULL) {
		printf("usbd_get_quirks: dev == NULL\n");
		return 0;
	}
#endif
@


1.7.2.3
log
@Sync the SMP branch with 3.3
@
text
@d81 1
a81 1
Static void usbd_do_request_async_cb
d127 1
a127 1
usbd_status
d130 2
a131 2
{
	return (usbd_open_pipe_ival(iface, address, flags, pipe,
d135 1
a135 1
usbd_status
d138 1
a138 1
{
d166 1
a166 1
usbd_status
d179 1
a179 1
	err = usbd_open_pipe_ival(iface, address, USBD_EXCLUSIVE_USE,
d272 1
a272 1
	if (!(xfer->flags & USBD_NO_COPY) && size != 0 &&
d297 1
a297 1
			panic("usbd_transfer: not done");
d346 1
a346 1
usbd_xfer_handle
d360 1
a360 1
usbd_status
d487 1
a487 1
usbd_status
d504 2
a505 2

usbd_status
d514 1
a514 1
	/*
d536 1
a536 1
usbd_status
d561 1
a561 1
usbd_status
d574 1
a574 1
usbd_status
d583 1
a583 1
usbd_status
d591 1
a591 1
usbd_status
d654 1
a654 1
		if (p + d->bLength <= end &&
d699 1
a699 1
		DPRINTFN(2,("usbd_ar_pipe: pipe=%p xfer=%p (methods=%p)\n",
d764 1
a764 1
	DPRINTFN(5,("usb_transfer_complete: repeat=%d new head=%p\n",
d768 1
a768 1
	++pipe->device->bus->stats.uds_requests
d812 1
a812 1
	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d timeout=%d\n",
d864 1
a864 2
	return (usbd_do_request_flags(dev, req, data, 0, 0,
				      USBD_DEFAULT_TIMEOUT));
d869 1
a869 1
		      void *data, u_int16_t flags, int *actlen, u_int32_t timo)
d871 2
a872 2
	return (usbd_do_request_flags_pipe(dev, dev->default_pipe, req,
					   data, flags, actlen, timo));
d877 1
a877 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t timeout)
d896 1
a896 1
	usbd_setup_default_xfer(xfer, dev, 0, timeout, req,
d906 2
a907 2
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
d913 1
a913 1
		/*
d963 1
a963 1
			 xfer->pipe->device->address,
d966 2
a967 2
			 UGETW(xfer->request.wIndex),
			 UGETW(xfer->request.wLength),
a1057 18
/*
 * Search for a vendor/product pair in an array.  The item size is
 * given as an argument.
 */
const struct usb_devno *
usb_match_device(const struct usb_devno *tbl, u_int nentries, u_int sz,
		 u_int16_t vendor, u_int16_t product)
{
	while (nentries-- > 0) {
		u_int16_t tproduct = tbl->ud_product;
		if (tbl->ud_vendor == vendor &&
		    (tproduct == product || tproduct == USB_PRODUCT_ANY))
			return (tbl);
		tbl = (struct usb_devno *)((char *)tbl + sz);
	}
	return (NULL);
}

d1063 1
a1063 1

@


1.7.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.c,v 1.7.2.3 2003/03/28 00:38:32 niklas Exp $ */
d554 1
@


1.7.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi.c,v 1.103 2002/09/27 15:37:38 provos Exp $	*/
d82 1
a82 1
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d85 1
a85 1
	(usbd_interface_handle, u_int8_t, u_int8_t, usbd_pipe_handle *, int);
d112 1
a112 36
void
usbd_dump_iface(struct usbd_interface *iface)
{
	printf("usbd_dump_iface: iface=%p\n", iface);
	if (iface == NULL)
		return;
	printf(" device=%p idesc=%p index=%d altindex=%d priv=%p\n",
	       iface->device, iface->idesc, iface->index, iface->altindex,
	       iface->priv);
}

void
usbd_dump_device(struct usbd_device *dev)
{
	printf("usbd_dump_device: dev=%p\n", dev);
	if (dev == NULL)
		return;
	printf(" bus=%p default_pipe=%p\n", dev->bus, dev->default_pipe);
	printf(" address=%d config=%d depth=%d speed=%d self_powered=%d "
	       "power=%d langid=%d\n",
	       dev->address, dev->config, dev->depth, dev->speed,
	       dev->self_powered, dev->power, dev->langid);
}

void
usbd_dump_endpoint(struct usbd_endpoint *endp)
{
	printf("usbd_dump_endpoint: endp=%p\n", endp);
	if (endp == NULL)
		return;
	printf(" edesc=%p refcnt=%d\n", endp->edesc, endp->refcnt);
	if (endp->edesc)
		printf(" bEndpointAddress=0x%02x\n",
		       endp->edesc->bEndpointAddress);
}

d119 3
a121 1
	SIMPLEQ_FOREACH(xfer, &pipe->queue, next) {
a124 15

void
usbd_dump_pipe(usbd_pipe_handle pipe)
{
	printf("usbd_dump_pipe: pipe=%p\n", pipe);
	if (pipe == NULL)
		return;
	usbd_dump_iface(pipe->iface);
	usbd_dump_device(pipe->device);
	usbd_dump_endpoint(pipe->endpoint);
	printf(" (usbd_dump_pipe:)\n refcnt=%d running=%d aborting=%d\n",
	       pipe->refcnt, pipe->running, pipe->aborting);
	printf(" intrxfer=%p, repeat=%d, interval=%d\n",
	       pipe->intrxfer, pipe->repeat, pipe->interval);
}
d219 1
a219 1
	if (! SIMPLEQ_EMPTY(&pipe->queue))
d224 6
d274 1
a274 1
		memcpy(KERNADDR(dmap, 0), xfer->buffer, size);
a317 4
#ifdef DIAGNOSTIC
	if (xfer->rqflags & (URQ_DEV_DMABUF | URQ_AUTO_DMABUF))
		printf("usbd_alloc_buffer: xfer already has a buffer\n");
#endif
d320 1
a320 1
		return (NULL);
d322 1
a322 1
	return (KERNADDR(&xfer->dmabuf, 0));
d343 1
a343 1
	return (KERNADDR(&xfer->dmabuf, 0));
d515 1
a515 1
	 * Clearing en endpoint stall resets the endpoint toggle, so
d582 1
a582 1
void
d587 1
a720 7
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_ONQU) {
		printf("usb_transfer_complete: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return;
	}
#endif
d742 1
a742 1
		memcpy(xfer->buffer, KERNADDR(dmap, 0), xfer->actlen);
a759 1
		xfer->busy_free = XFER_BUSY;
a812 8
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
		printf("usb_insert_transfer: xfer=%p not busy 0x%08x\n",
		       xfer, xfer->busy_free);
		return (USBD_INVAL);
	}
	xfer->busy_free = XFER_ONQU;
#endif
a1027 3
	/* When polling we need to make sure there is nothing pending to do. */
	if (dev->bus->use_polling)
		dev->bus->methods->soft_intr(dev->bus);
d1030 1
d1072 1
a1072 1
		tbl = (const struct usb_devno *)((const char *)tbl + sz);
@


1.7.2.6
log
@Merge with the trunk
@
text
@d814 1
a814 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, next);
@


1.6
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.c,v 1.43 1999/09/15 21:08:59 augustss Exp $	*/
d46 1
a46 1
#else
d50 1
a62 4
#if defined(__FreeBSD__)
#include "usb_if.h"
#endif
 
d77 10
a86 1
static SIMPLEQ_HEAD(, usbd_request) usbd_free_requests;
d88 4
a91 2
#if defined(__FreeBSD__)
#define USB_CDEV_MAJOR	108
d93 11
a103 2
extern struct cdevsw usb_cdevsw;
#endif
d709 1
a719 19
void
usbd_init()
{
	static int usbd_global_init_done = 0;
#if defined(__FreeBSD__)
	dev_t dev;
#endif
	
	if (!usbd_global_init_done) {
		usbd_global_init_done = 1;
		SIMPLEQ_INIT(&usbd_free_requests);

#if defined(__FreeBSD__)
		dev = makedev(USB_CDEV_MAJOR, 0);
		cdevsw_add(&dev, &usb_cdevsw, NULL);
#endif
	}
}

d727 1
d760 1
a760 1
		if (!pipe->repeat) {
d770 9
a778 2
	/* Remove request from queue. */
	SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);
d799 1
a799 1
	if (!pipe->repeat) {
a1051 27
void
usbd_print_child(device_t parent, device_t child)
{
	/*
	struct usb_softc *sc = device_get_softc(child);
	*/

	printf(" at %s%d", device_get_name(parent), device_get_unit(parent));

	/* XXX How do we get to the usbd_device_handle???
	usbd_device_handle dev = invalidadosch;

	printf(" addr %d", dev->addr);

	if (bootverbose) {
		if (dev->lowspeed)
			printf(", lowspeed");
		if (dev->self_powered)
			printf(", self powered");
		else
			printf(", %dmA", dev->power);
		printf(", config %d", dev->config);
	}
	 */
}

/* Reconfigure all the USB busses in the system. */
d1055 3
a1057 64
	devclass_t usb_devclass = devclass_find("usb");
	devclass_t ugen_devclass = devclass_find("ugen");
	device_t *devlist;
	int devcount;
	int error;

	switch (what) { 
	case MOD_LOAD:
	case MOD_UNLOAD:
		if (!usb_devclass)
			return 0;	/* just ignore call */

		if (ugen_devclass) {
			/* detach devices from generic driver if possible */
			error = devclass_get_devices(ugen_devclass, &devlist,
						     &devcount);
			if (!error)
				for (devcount--; devcount >= 0; devcount--)
					(void)DEVICE_DETACH(devlist[devcount]);
		}

		error = devclass_get_devices(usb_devclass, &devlist, &devcount);
		if (error)
			return 0;	/* XXX maybe transient, or error? */

		for (devcount--; devcount >= 0; devcount--)
			USB_RECONFIGURE(devlist[devcount]);

		free(devlist, M_TEMP);
		return 0;
	}

	return 0;			/* nothing to do by us */
}

/* Set the description of the device including a malloc and copy. */
void
usbd_device_set_desc(device_t device, char *devinfo)
{
	size_t l;
	char *desc;

	if ( devinfo ) {
		l = strlen(devinfo);
		desc = malloc(l+1, M_USB, M_NOWAIT);
		if (desc)
			memcpy(desc, devinfo, l+1);
	} else
		desc = NULL;

	device_set_desc(device, desc);
}

char *
usbd_devname(device_t bdev)
{
	static char buf[20];
	/* 
	 * A static buffer is a loss if this routine is used from an interrupt,
	 * but it's not fatal.
	 */

	sprintf(buf, "%s%d", device_get_name(bdev), device_get_unit(bdev));
	return (buf);
@


1.5
log
@Sync with NetBSD;
Add some comments.  Change a type name.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.c,v 1.33 1999/08/28 10:04:01 augustss Exp $	*/
d54 2
a56 1

d60 1
d88 12
a162 3
	reqh = usbd_alloc_request();
	if (reqh == 0)
		return (USBD_NOMEM);
d165 4
d170 3
a172 4
	r = usbd_setup_request(reqh, ipipe, priv, buffer, length, 
			       USBD_XFER_IN | flags, USBD_NO_TIMEOUT, cb);
	if (r != USBD_NORMAL_COMPLETION)
		goto bad2;
d178 1
a178 1
		goto bad3;
d181 1
a181 1
 bad3:
d184 2
a185 1
 bad2:
a186 31
 bad1:
	usbd_free_request(reqh);
	return r;
}

usbd_status 
usbd_open_pipe_iso(iface, address, flags, pipe, priv, bufsize, nbuf)
	usbd_interface_handle iface;
	u_int8_t address;
	u_int8_t flags;
	usbd_pipe_handle *pipe;
	usbd_private_handle priv;
	u_int32_t bufsize;
	u_int32_t nbuf;
{
	usbd_status r;
	usbd_pipe_handle p;

	r = usbd_open_pipe(iface, address, USBD_EXCLUSIVE_USE, &p);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!p->methods->isobuf) {
		usbd_close_pipe(p);
		return (USBD_INVAL);
	}
	r = p->methods->isobuf(p, bufsize, nbuf);
	if (r != USBD_NORMAL_COMPLETION) {
		usbd_close_pipe(p);
		return (r);
	}	
	*pipe = p;
d219 1
d221 1
d232 20
d253 11
d265 1
a265 1
		return r;
d272 1
a272 1
		if (reqh->pipe->device->bus->use_polling)
d289 38
d328 2
a329 1
usbd_alloc_request()
d341 2
a342 1
	DPRINTFN(1,("usbd_alloc_request() = %p\n", reqh));
d350 3
a352 1
	DPRINTFN(1,("usbd_free_request: %p\n", reqh));
d357 1
a357 1
usbd_status 
d379 2
a380 2
	reqh->isreq = 0;
	return (USBD_NORMAL_COMPLETION);
d383 1
a383 1
usbd_status 
d408 26
a433 2
	reqh->isreq = 1;
	return (USBD_NORMAL_COMPLETION);
d598 7
d685 2
a701 2
static int usbd_global_init_done = 0;

d705 1
d721 1
d727 1
d730 4
a733 2
	DPRINTFN(5, ("usb_transfer_complete: pipe=%p reqh=%p actlen=%d\n",
		     pipe, reqh, reqh->actlen));
d741 1
a741 1
	polling = reqh->pipe->device->bus->use_polling;
d746 23
a768 2
	if (reqh->pipe->methods->done)
		reqh->pipe->methods->done(reqh);
d792 8
a799 3
	if (!pipe->repeat && 
	    reqh->status != USBD_CANCELLED && reqh->status != USBD_TIMEOUT)
		usbd_start_next(pipe);
d807 2
d810 3
a812 2
	DPRINTFN(5,("usb_insert_transfer: pipe=%p running=%d\n", pipe,
		    pipe->running));
d815 7
a821 3
		return (USBD_IN_PROGRESS);
	pipe->running = 1;
	return (USBD_NORMAL_COMPLETION);
d824 1
d832 2
d883 1
a883 1
	if (!curproc) {
d885 1
a885 1
		return (USBD_XXX);
d889 1
a889 1
	reqh = usbd_alloc_request();
d892 2
a893 5
	r = usbd_setup_default_request(
		reqh, dev, 0, USBD_DEFAULT_TIMEOUT, req, data, 
		UGETW(req->wLength), flags, 0);
	if (r != USBD_NORMAL_COMPLETION)
		goto bad;
d897 7
a903 7
		printf("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
		       "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
		       dev->address, reqh->request.bmRequestType,
		       reqh->request.bRequest, UGETW(reqh->request.wValue),
		       UGETW(reqh->request.wIndex), 
		       UGETW(reqh->request.wLength), 
		       reqh->length, reqh->actlen);
d923 3
a925 5
		nr = usbd_setup_default_request(
			reqh, dev, 0, USBD_DEFAULT_TIMEOUT, &treq, &status, 
			sizeof(usb_status_t), 0, 0);
		if (nr != USBD_NORMAL_COMPLETION)
			goto bad;
d938 2
a939 5
		nr = usbd_setup_default_request(
			reqh, dev, 0, USBD_DEFAULT_TIMEOUT, &treq, &status, 
			0, 0, 0);
		if (nr != USBD_NORMAL_COMPLETION)
			goto bad;
d958 8
a965 8
		printf("usbd_do_request: overrun addr=%d type=0x%02x req=0x"
		       "%02x val=%d index=%d rlen=%d length=%d actlen=%d\n",
		       reqh->pipe->device->address, 
		       reqh->request.bmRequestType,
		       reqh->request.bRequest, UGETW(reqh->request.wValue),
		       UGETW(reqh->request.wIndex), 
		       UGETW(reqh->request.wLength), 
		       reqh->length, reqh->actlen);
d983 1
a983 1
	reqh = usbd_alloc_request();
d986 5
a990 4
	r = usbd_setup_default_request(
		reqh, dev, 0, USBD_DEFAULT_TIMEOUT, req, data, 
		UGETW(req->wLength), 0, usbd_do_request_async_cb);
	if (r != USBD_NORMAL_COMPLETION) {
a993 3
	r = usbd_transfer(reqh);
	if (r != USBD_IN_PROGRESS)
		return (r);
d1013 1
a1013 1
	iface->device->bus->do_poll(iface->device->bus);
d1021 4
a1024 1
	iface->device->bus->use_polling = on;
d1129 1
a1129 1
usbd_devname(bdevice *bdev)
d1137 1
a1137 1
	sprintf(buf, "%s%d", device_get_name(*bdev), device_get_unit(*bdev));
@


1.4
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.c,v 1.32 1999/08/23 22:55:14 augustss Exp $	*/
d430 5
d436 1
d462 1
d605 1
@


1.3
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.c,v 1.30 1999/08/17 20:59:04 augustss Exp $	*/
a73 3
static void usbd_transfer_cb __P((usbd_request_handle reqh));
static void usbd_sync_transfer_cb __P((usbd_request_handle reqh));
static usbd_status usbd_do_transfer __P((usbd_request_handle reqh));
d76 1
d230 1
a230 1
usbd_status 
a233 8
	reqh->xfercb = usbd_transfer_cb;
	return (usbd_do_transfer(reqh));
}

static usbd_status
usbd_do_transfer(reqh)
	usbd_request_handle reqh;
{
d235 2
d238 2
a239 1
	DPRINTFN(5,("usbd_do_transfer: reqh=%p\n", reqh));
d245 25
a269 1
	return (pipe->methods->transfer(reqh));
a319 1
	reqh->retries = 1;
a348 1
	reqh->retries = 1;
d353 1
a353 1
usbd_status 
d361 8
a368 5
	*priv = reqh->priv;
	*buffer = reqh->buffer;
	*count = reqh->actlen;
	*status = reqh->status;
	return (USBD_NORMAL_COMPLETION);
d622 2
a623 2
static void
usbd_transfer_cb(reqh)
d627 4
a631 2
	DPRINTFN(10, ("usbd_transfer_cb: reqh=%p\n", reqh));
	/* Count completed transfers. */
d633 1
a633 1
	if (!pipe)
d635 2
a636 1
	else
d638 12
a652 1
	/* XXX check retry count */
d661 1
d664 7
d673 2
a674 2
static void
usbd_sync_transfer_cb(reqh)
d677 9
a685 4
	DPRINTFN(10, ("usbd_sync_transfer_cb: reqh=%p\n", reqh));
	usbd_transfer_cb(reqh);
	if (!reqh->pipe->device->bus->use_polling)
		wakeup(reqh);
d688 4
a691 3
/* Like usbd_transfer(), but waits for completion. */
usbd_status
usbd_sync_transfer(reqh)
a692 1
{
a693 1
	int s;
d695 25
a719 9
	reqh->xfercb = usbd_sync_transfer_cb;
	r = usbd_do_transfer(reqh);
	if (r != USBD_IN_PROGRESS)
		return (r);
	s = splusb();
	if (!reqh->done) {
		if (reqh->pipe->device->bus->use_polling)
			panic("usbd_sync_transfer: not done\n");
		tsleep(reqh, PRIBIO, "usbsyn", 0);
a720 2
	splx(s);
	return (reqh->status);
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.c,v 1.1 1999/08/13 05:28:05 fgsch Exp $	*/
/*	$NetBSD: usbdi.c,v 1.26 1999/07/06 07:12:03 augustss Exp $	*/
d88 18
d246 5
a250 1
	DPRINTFN(10,("usbd_do_transfer: reqh=%p\n", reqh));
d412 1
d437 1
a569 11
#if 0
	for (;;) {
		reqh = SIMPLEQ_FIRST(&pipe->queue);
		if (reqh == 0)
			break;
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);
		reqh->status = USBD_CANCELLED;
		if (reqh->callback)
			reqh->callback(reqh, reqh->priv, reqh->status);
	}
#else
d571 4
d576 3
a578 2
		DPRINTFN(2,("usbd_ar_pipe: reqh=%p (methods=%p)\n", 
			    pipe, pipe->methods));
a579 1
		SIMPLEQ_REMOVE_HEAD(&pipe->queue, reqh, next);
a580 1
#endif
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 2
a66 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
d162 1
a162 1
usbd_open_pipe_iso(iface, address, flags, pipe, priv, bufsize, nbuf, cb)
a169 1
	usbd_callback cb;
@

