head	1.73;
access;
symbols
	OPENBSD_6_2:1.73.0.2
	OPENBSD_6_2_BASE:1.73
	OPENBSD_6_1:1.73.0.4
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.70.0.2
	OPENBSD_5_9_BASE:1.70
	OPENBSD_5_8:1.67.0.4
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.51.0.2
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.2
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.43.0.4
	OPENBSD_4_8_BASE:1.43
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.42.0.6
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.12
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.73
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.72;
commitid	VyLWTsbepAOk7VQM;

1.72
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.71;
commitid	xlY19nmD0cBL53l1;

1.71
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.70;
commitid	gWZDkudwxydTq8x4;

1.70
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.69;
commitid	f4dx5ry1aOiKJw33;

1.69
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.68;
commitid	B0kwmVGiD5DVx4kv;

1.68
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.67;
commitid	eYnPulzvLjDImPCa;

1.67
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.66;
commitid	fE8TgA9vpwdUU5Wy;

1.66
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.65;
commitid	MVWrtktB46JRxFWT;

1.65
date	2015.05.21.09.22.39;	author mpi;	state Exp;
branches;
next	1.64;
commitid	idqtT786bGPil6QW;

1.64
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.63;
commitid	aqezguXMYUVIGMPW;

1.63
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.62;
commitid	p4LJxGKbi0BU2cG6;

1.62
date	2015.02.04.05.12.13;	author mpi;	state Exp;
branches;
next	1.61;
commitid	kJMgw6D3PQCR1sKa;

1.61
date	2014.12.29.02.39.33;	author brad;	state Exp;
branches;
next	1.60;
commitid	kCWawqejKkHRtIYa;

1.60
date	2014.12.29.00.46.01;	author brad;	state Exp;
branches;
next	1.59;
commitid	SM9KMLJl0ldt1ocU;

1.59
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.58;
commitid	yM2VFFhpDTeFQlve;

1.58
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.57;
commitid	Pclvgy2Z4XV9hveD;

1.57
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.56;
commitid	b0VSac5dnnsxcDao;

1.56
date	2014.01.07.09.54.18;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.06.17.33.26;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2013.10.29.10.01.20;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.51;

1.51
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2013.02.07.13.35.18;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2012.11.28.01.15.33;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.12.17.13.48.06;	author jasper;	state Exp;
branches;
next	1.45;

1.45
date	2010.12.06.05.46.17;	author jakemsr;	state Exp;
branches;
next	1.44;

1.44
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.03.03.13.09;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.40;

1.40
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.01.06.12.20;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.29.02.56.56;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.30.13.04.36;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.26.11.29.55;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.07.06.26.28;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.06.15.03.38.35;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.20.19.39.47;	author mickey;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.01.28.17.45.18;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.26.19;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.43.45;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_upl.c,v 1.72 2016/11/06 12:58:01 mpi Exp $ */
/*	$NetBSD: if_upl.c,v 1.19 2002/07/11 21:14:26 augustss Exp $	*/
/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Prolific PL2301/PL2302 driver
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <net/if.h>
#include <net/if_types.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

/*
 * 7  6  5  4  3  2  1  0
 * tx rx 1  0
 * 1110 0000 rxdata
 * 1010 0000 idle
 * 0010 0000 tx over
 * 0110      tx over + rxd
 */

#define UPL_RXDATA		0x40
#define UPL_TXOK		0x80

#define UPL_INTR_PKTLEN		1

#define UPL_CONFIG_NO		1
#define UPL_IFACE_IDX		0

/***/

#define UPL_INTR_INTERVAL	20

#define UPL_BUFSZ		1024

#define UPL_RX_FRAMES		1
#define UPL_TX_FRAMES		1

#define UPL_RX_LIST_CNT		1
#define UPL_TX_LIST_CNT		1

#define UPL_ENDPT_RX		0x0
#define UPL_ENDPT_TX		0x1
#define UPL_ENDPT_INTR		0x2
#define UPL_ENDPT_MAX		0x3

struct upl_softc;

struct upl_chain {
	struct upl_softc	*upl_sc;
	struct usbd_xfer	*upl_xfer;
	char			*upl_buf;
	struct mbuf		*upl_mbuf;
	int			upl_idx;
};

struct upl_cdata {
	struct upl_chain	upl_tx_chain[UPL_TX_LIST_CNT];
	struct upl_chain	upl_rx_chain[UPL_RX_LIST_CNT];
	int			upl_tx_prod;
	int			upl_tx_cons;
	int			upl_tx_cnt;
	int			upl_rx_prod;
};

struct upl_softc {
	struct device		sc_dev;

	struct ifnet		sc_if;
	struct timeout		sc_stat_ch;

	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;
	int			sc_ed[UPL_ENDPT_MAX];
	struct usbd_pipe	*sc_ep[UPL_ENDPT_MAX];
	struct upl_cdata	sc_cdata;

	uByte			sc_ibuf;

	u_int			sc_rx_errs;
	struct timeval		sc_rx_notice;
	u_int			sc_intr_errs;
};

#ifdef UPL_DEBUG
#define DPRINTF(x)	do { if (upldebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (upldebug >= (n)) printf x; } while (0)
int	upldebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
struct usb_devno upl_devs[] = {
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2301 },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2302 }
};

int upl_match(struct device *, void *, void *);
void upl_attach(struct device *, struct device *, void *);
int upl_detach(struct device *, int);

struct cfdriver upl_cd = {
	NULL, "upl", DV_IFNET
};

const struct cfattach upl_ca = {
	sizeof(struct upl_softc), upl_match, upl_attach, upl_detach
};

int upl_openpipes(struct upl_softc *);
int upl_tx_list_init(struct upl_softc *);
int upl_rx_list_init(struct upl_softc *);
int upl_newbuf(struct upl_softc *, struct upl_chain *, struct mbuf *);
int upl_send(struct upl_softc *, struct mbuf *, int);
void upl_intr(struct usbd_xfer *, void *, usbd_status);
void upl_rxeof(struct usbd_xfer *, void *, usbd_status);
void upl_txeof(struct usbd_xfer *, void *, usbd_status);
void upl_start(struct ifnet *);
int upl_ioctl(struct ifnet *, u_long, caddr_t);
void upl_init(void *);
void upl_stop(struct upl_softc *);
void upl_watchdog(struct ifnet *);

int upl_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		      struct rtentry *);

/*
 * Probe for a Prolific chip.
 */
int
upl_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg		*uaa = aux;

	if (uaa->iface == NULL || uaa->configno != UPL_CONFIG_NO)
		return (UMATCH_NONE);

	return (usb_lookup(upl_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
upl_attach(struct device *parent, struct device *self, void *aux)
{
	struct upl_softc	*sc = (struct upl_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	int			s;
	struct usbd_device	*dev = uaa->device;
	struct usbd_interface	*iface;
	usbd_status		err;
	struct ifnet		*ifp;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int			i;

	DPRINTFN(5,(" : upl_attach: sc=%p, dev=%p", sc, dev));

	sc->sc_udev = dev;

	err = usbd_device2interface_handle(dev, UPL_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_ed[UPL_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_ed[UPL_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_ed[UPL_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	if (sc->sc_ed[UPL_ENDPT_RX] == 0 || sc->sc_ed[UPL_ENDPT_TX] == 0 ||
	    sc->sc_ed[UPL_ENDPT_INTR] == 0) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		return;
	}

	s = splnet();

	/* Initialize interface info.*/
	ifp = &sc->sc_if;
	ifp->if_softc = sc;
	ifp->if_mtu = UPL_BUFSZ;
	ifp->if_hardmtu = UPL_BUFSZ;
	ifp->if_flags = IFF_POINTOPOINT | IFF_NOARP | IFF_SIMPLEX;
	ifp->if_ioctl = upl_ioctl;
	ifp->if_start = upl_start;
	ifp->if_watchdog = upl_watchdog;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	ifp->if_type = IFT_OTHER;
	ifp->if_addrlen = 0;
	ifp->if_hdrlen = 0;
	ifp->if_output = upl_output;
	ifp->if_baudrate = IF_Mbps(12);

	/* Attach the interface. */
	if_attach(ifp);
	if_alloc_sadl(ifp);

	splx(s);
}

int
upl_detach(struct device *self, int flags)
{
	struct upl_softc	*sc = (struct upl_softc *)self;
	struct ifnet		*ifp = &sc->sc_if;
	int			s;

	DPRINTFN(2,("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	s = splusb();

	if (ifp->if_flags & IFF_RUNNING)
		upl_stop(sc);

	if (ifp->if_softc != NULL)
		if_detach(ifp);

#ifdef DIAGNOSTIC
	if (sc->sc_ep[UPL_ENDPT_TX] != NULL ||
	    sc->sc_ep[UPL_ENDPT_RX] != NULL ||
	    sc->sc_ep[UPL_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		       sc->sc_dev.dv_xname);
#endif

	splx(s);

	return (0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
upl_newbuf(struct upl_softc *sc, struct upl_chain *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	DPRINTFN(8,("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
			return (ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->sc_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	c->upl_mbuf = m_new;

	return (0);
}

int
upl_rx_list_init(struct upl_softc *sc)
{
	struct upl_cdata	*cd;
	struct upl_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < UPL_RX_LIST_CNT; i++) {
		c = &cd->upl_rx_chain[i];
		c->upl_sc = sc;
		c->upl_idx = i;
		if (upl_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->upl_xfer == NULL) {
			c->upl_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->upl_xfer == NULL)
				return (ENOBUFS);
			c->upl_buf = usbd_alloc_buffer(c->upl_xfer, UPL_BUFSZ);
			if (c->upl_buf == NULL) {
				usbd_free_xfer(c->upl_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
upl_tx_list_init(struct upl_softc *sc)
{
	struct upl_cdata	*cd;
	struct upl_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < UPL_TX_LIST_CNT; i++) {
		c = &cd->upl_tx_chain[i];
		c->upl_sc = sc;
		c->upl_idx = i;
		c->upl_mbuf = NULL;
		if (c->upl_xfer == NULL) {
			c->upl_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->upl_xfer == NULL)
				return (ENOBUFS);
			c->upl_buf = usbd_alloc_buffer(c->upl_xfer, UPL_BUFSZ);
			if (c->upl_buf == NULL) {
				usbd_free_xfer(c->upl_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
upl_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct upl_chain	*c = priv;
	struct upl_softc	*sc = c->upl_sc;
	struct ifnet		*ifp = &sc->sc_if;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	int			total_len = 0;
	int			s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->sc_rx_errs++;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->sc_dev.dv_xname, sc->sc_rx_errs,
			    usbd_errstr(status));
			sc->sc_rx_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ep[UPL_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	DPRINTFN(9,("%s: %s: enter status=%d length=%d\n",
		    sc->sc_dev.dv_xname, __func__, status, total_len));

	m = c->upl_mbuf;
	memcpy(mtod(c->upl_mbuf, char *), c->upl_buf, total_len);

	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (upl_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);
 done:
#if 1
	/* Setup new transfer. */
	usbd_setup_xfer(c->upl_xfer, sc->sc_ep[UPL_ENDPT_RX],
	    c, c->upl_buf, UPL_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, upl_rxeof);
	usbd_transfer(c->upl_xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->sc_dev.dv_xname,
		    __func__));
#endif
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void
upl_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct upl_chain	*c = priv;
	struct upl_softc	*sc = c->upl_sc;
	struct ifnet		*ifp = &sc->sc_if;
	int			s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->sc_dev.dv_xname,
		    __func__, status));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->sc_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ep[UPL_ENDPT_TX]);
		splx(s);
		return;
	}

	m_freem(c->upl_mbuf);
	c->upl_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		upl_start(ifp);

	splx(s);
}

int
upl_send(struct upl_softc *sc, struct mbuf *m, int idx)
{
	int			total_len;
	struct upl_chain	*c;
	usbd_status		err;

	c = &sc->sc_cdata.upl_tx_chain[idx];

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving two
	 * bytes at the beginning to hold the frame length.
	 */
	m_copydata(m, 0, m->m_pkthdr.len, c->upl_buf);
	c->upl_mbuf = m;

	total_len = m->m_pkthdr.len;

	DPRINTFN(10,("%s: %s: total_len=%d\n",
		     sc->sc_dev.dv_xname, __func__, total_len));

	usbd_setup_xfer(c->upl_xfer, sc->sc_ep[UPL_ENDPT_TX],
	    c, c->upl_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT,
	    upl_txeof);

	/* Transmit */
	err = usbd_transfer(c->upl_xfer);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: upl_send error=%s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(err));
		upl_stop(sc);
		return (EIO);
	}

	sc->sc_cdata.upl_tx_cnt++;

	return (0);
}

void
upl_start(struct ifnet *ifp)
{
	struct upl_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTFN(10,("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (upl_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
upl_init(void *xsc)
{
	struct upl_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->sc_if;
	int			s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTFN(10,("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	s = splnet();

	/* Init TX ring. */
	if (upl_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init RX ring. */
	if (upl_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	if (sc->sc_ep[UPL_ENDPT_RX] == NULL) {
		if (upl_openpipes(sc)) {
			splx(s);
			return;
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

int
upl_openpipes(struct upl_softc *sc)
{
	struct upl_chain	*c;
	usbd_status		err;
	int			i;

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->sc_iface, sc->sc_ed[UPL_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->sc_ep[UPL_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}
	err = usbd_open_pipe(sc->sc_iface, sc->sc_ed[UPL_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->sc_ep[UPL_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ed[UPL_ENDPT_INTR],
	    USBD_EXCLUSIVE_USE, &sc->sc_ep[UPL_ENDPT_INTR], sc,
	    &sc->sc_ibuf, UPL_INTR_PKTLEN, upl_intr,
	    UPL_INTR_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}


#if 1
	/* Start up the receive pipe. */
	for (i = 0; i < UPL_RX_LIST_CNT; i++) {
		c = &sc->sc_cdata.upl_rx_chain[i];
		usbd_setup_xfer(c->upl_xfer, sc->sc_ep[UPL_ENDPT_RX],
		    c, c->upl_buf, UPL_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		    upl_rxeof);
		usbd_transfer(c->upl_xfer);
	}
#endif

	return (0);
}

void
upl_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct upl_softc	*sc = priv;
	struct ifnet		*ifp = &sc->sc_if;
	uByte			stat;

	DPRINTFN(15,("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			return;
		}
		sc->sc_intr_errs++;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			printf("%s: %u usb errors on intr: %s\n",
			    sc->sc_dev.dv_xname, sc->sc_rx_errs,
			    usbd_errstr(status));
			sc->sc_intr_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ep[UPL_ENDPT_RX]);
		return;
	}

	stat = sc->sc_ibuf;

	if (stat == 0)
		return;

	DPRINTFN(10,("%s: %s: stat=0x%02x\n", sc->sc_dev.dv_xname,
		     __func__, stat));

}

int
upl_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct upl_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTFN(5,("%s: %s: cmd=0x%08lx\n",
		    sc->sc_dev.dv_xname, __func__, command));

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			upl_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				upl_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				upl_stop(sc);
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	default:
		error = ENOTTY;
	}

	if (error == ENETRESET)
		error = 0;

	splx(s);
	return (error);
}

void
upl_watchdog(struct ifnet *ifp)
{
	struct upl_softc	*sc = ifp->if_softc;

	DPRINTFN(5,("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	upl_stop(sc);
	upl_init(sc);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		upl_start(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
upl_stop(struct upl_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	DPRINTFN(10,("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	ifp = &sc->sc_if;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Stop transfers. */
	if (sc->sc_ep[UPL_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_RX]);
		err = usbd_close_pipe(sc->sc_ep[UPL_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[UPL_ENDPT_RX] = NULL;
	}

	if (sc->sc_ep[UPL_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_TX]);
		err = usbd_close_pipe(sc->sc_ep[UPL_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[UPL_ENDPT_TX] = NULL;
	}

	if (sc->sc_ep[UPL_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_INTR]);
		err = usbd_close_pipe(sc->sc_ep[UPL_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[UPL_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < UPL_RX_LIST_CNT; i++) {
		if (sc->sc_cdata.upl_rx_chain[i].upl_mbuf != NULL) {
			m_freem(sc->sc_cdata.upl_rx_chain[i].upl_mbuf);
			sc->sc_cdata.upl_rx_chain[i].upl_mbuf = NULL;
		}
		if (sc->sc_cdata.upl_rx_chain[i].upl_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.upl_rx_chain[i].upl_xfer);
			sc->sc_cdata.upl_rx_chain[i].upl_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < UPL_TX_LIST_CNT; i++) {
		if (sc->sc_cdata.upl_tx_chain[i].upl_mbuf != NULL) {
			m_freem(sc->sc_cdata.upl_tx_chain[i].upl_mbuf);
			sc->sc_cdata.upl_tx_chain[i].upl_mbuf = NULL;
		}
		if (sc->sc_cdata.upl_tx_chain[i].upl_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.upl_tx_chain[i].upl_xfer);
			sc->sc_cdata.upl_tx_chain[i].upl_xfer = NULL;
		}
	}
}

int
upl_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
	   struct rtentry *rt0)
{
	return (if_enqueue(ifp, m));
}
@


1.72
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.71 2016/04/13 11:03:37 mpi Exp $ */
a508 2

	ifp->if_opackets++;
@


1.71
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.70 2015/11/25 11:20:38 mpi Exp $ */
d190 1
a190 1
	if (uaa->iface != NULL)
a211 7

	err = usbd_set_config_no(dev, UPL_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.70
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.69 2015/11/25 03:10:00 dlg Exp $ */
a275 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.69
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.68 2015/11/20 03:35:23 dlg Exp $ */
a50 1
#include <net/netisr.h>
@


1.68
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.67 2015/06/30 13:54:42 mpi Exp $ */
d503 1
a503 1
	ifp->if_flags &= ~IFF_OACTIVE;
d580 1
a580 1
	if (ifp->if_flags & IFF_OACTIVE)
d589 1
a589 1
		ifp->if_flags |= IFF_OACTIVE;
d604 1
a604 1
	ifp->if_flags |= IFF_OACTIVE;
d648 1
a648 1
	ifp->if_flags &= ~IFF_OACTIVE;
d829 2
a830 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.67
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.66 2015/06/24 09:40:54 mpi Exp $ */
d583 1
a583 1
	IFQ_POLL(&ifp->if_snd, m_head);
d588 1
d593 1
a593 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.66
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.65 2015/05/21 09:22:39 mpi Exp $ */
d890 1
a890 1
	return (if_output(ifp, m));
@


1.65
log
@Convert to if_output().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.64 2015/04/10 08:41:43 mpi Exp $ */
a457 1
	ifp->if_ipackets++;
@


1.64
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.63 2015/03/14 03:38:49 jsg Exp $ */
d891 1
a891 24
	int s, len, error;

	DPRINTFN(10,("%s: %s: enter\n",
		     ((struct upl_softc *)ifp->if_softc)->sc_dev.dv_xname,
		     __func__));

	len = m->m_pkthdr.len;
	s = splnet();
	/*
	 * Queue message on interface, and start output if interface
	 * not yet active.
	 */
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error) {
		/* mbuf is already freed */
		splx(s);
		return (error);
	}
	ifp->if_obytes += len;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
	splx(s);

	return (0);
@


1.63
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.62 2015/02/04 05:12:13 mpi Exp $ */
d424 1
d460 1
a461 5
	m->m_pkthdr.rcvif = ifp;

	s = splnet();

	/* XXX ugly */
d464 1
a464 1
		goto done1;
d467 2
a468 12
#if NBPFILTER > 0
	if (ifp->if_bpf) {
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
	}
#endif

	DPRINTFN(10,("%s: %s: deliver %d\n", sc->sc_dev.dv_xname,
		    __func__, m->m_len));

	ether_input_mbuf(ifp, m);

 done1:
a469 1

@


1.62
log
@Kill annoying comments about ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.61 2014/12/29 02:39:33 brad Exp $ */
a50 1
#include <net/if_dl.h>
@


1.61
log
@Some missing break's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.60 2014/12/29 00:46:01 brad Exp $ */
a471 6
	/*
	 * Handle BPF listeners. Let the BPF user see the packet, but
	 * don't pass it up to the ether_input() layer unless it's
	 * a broadcast packet, multicast packet, matches our ethernet
	 * address or the interface is in promiscuous mode.
	 */
@


1.60
log
@Some cleaning up of the ioctl handling bits to bring things in line
with the other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.59 2014/12/22 02:28:52 tedu Exp $ */
d783 1
d802 1
a805 1
		break;
@


1.59
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.58 2014/07/13 15:52:49 mpi Exp $ */
d266 1
a644 3
	if (ifp->if_flags & IFF_RUNNING)
		return;

a766 1
	struct ifaddr 		*ifa = (struct ifaddr *)data;
d781 2
a782 1
		upl_init(sc);
d784 9
a792 3
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			break;
d797 1
a797 1
		if (ifr->ifr_mtu > UPL_BUFSZ)
a800 1
		break;
a801 10
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				upl_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				upl_stop(sc);
		}
		error = 0;
		break;
d806 3
@


1.58
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.57 2014/07/12 07:59:23 mpi Exp $ */
a786 1
#ifdef INET
a788 1
#endif /* INET */
@


1.57
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.56 2014/01/07 09:54:18 mpi Exp $ */
a57 1
#ifdef INET
a58 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a59 3
#else
#error upl without INET?
#endif
@


1.56
log
@Remove unused fields.

ok sasano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.55 2013/11/15 10:17:39 pirofti Exp $ */
d161 10
a170 15
int upl_match(struct device *, void *, void *); 
void upl_attach(struct device *, struct device *, void *); 
int upl_detach(struct device *, int); 
int upl_activate(struct device *, int); 

struct cfdriver upl_cd = { 
	NULL, "upl", DV_IFNET 
}; 

const struct cfattach upl_ca = { 
	sizeof(struct upl_softc), 
	upl_match, 
	upl_attach, 
	upl_detach, 
	upl_activate, 
a318 15
	return (0);
}

int
upl_activate(struct device *self, int act)
{
	struct upl_softc *sc = (struct upl_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.55
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.54 2013/11/06 17:33:26 pirofti Exp $ */
a132 2
	u_int16_t		sc_vendor;
	u_int16_t		sc_product;
a233 2
	sc->sc_product = uaa->product;
	sc->sc_vendor = uaa->vendor;
@


1.54
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.53 2013/10/29 10:01:20 mpi Exp $ */
d889 1
a889 5
		err = usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err));
		}
d899 1
a899 5
		err = usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err));
		}
d909 1
a909 5
		err = usbd_abort_pipe(sc->sc_ep[UPL_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err));
		}
@


1.53
log
@Kill sc_attached, attach and detach events for USB devices are triggered
by the same explore task and cannot happen in parallel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.52 2013/08/07 01:06:42 bluhm Exp $ */
a140 1
	char			sc_dying;
d340 1
a340 1
		sc->sc_dying = 1;
d458 1
a458 1
	if (sc->sc_dying)
d545 1
a545 1
	if (sc->sc_dying)
d626 1
a626 1
	if (sc->sc_dying)
d669 1
a669 1
	if (sc->sc_dying)
d763 1
a763 1
	if (sc->sc_dying)
d803 1
a803 1
	if (sc->sc_dying)
d857 1
a857 1
	if (sc->sc_dying)
@


1.52
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.51 2013/04/15 09:23:01 mglocker Exp $ */
a141 1
	char			sc_attached;
a298 1
	sc->sc_attached = 1;
a310 4
	/* Detached before attached finished, so just bail out. */
	if (!sc->sc_attached)
		return (0);

a326 1
	sc->sc_attached = 0;
@


1.51
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.50 2013/02/07 13:35:18 mpi Exp $ */
a59 1
#include <netinet/in_var.h>
@


1.50
log
@Remove dead code.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.49 2012/11/28 01:15:33 brad Exp $ */
d111 1
a111 1
	usbd_xfer_handle	upl_xfer;
d132 2
a133 2
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
d137 1
a137 1
	usbd_pipe_handle	sc_ep[UPL_ENDPT_MAX];
d188 3
a190 3
void upl_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
void upl_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void upl_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d221 2
a222 2
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
d458 1
a458 1
upl_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d547 1
a547 1
upl_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d764 1
a764 1
upl_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.49
log
@- Use IF_Gbps(1) instead of IF_Mbps(1000)
- Use IF_Mbps() instead of multiplying the link speed by a bare value
- Remove a useless comment as baudrate is already handled properly
- Remove some commented out bits of code
- Use IF_Mbps() instead of the bare value

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.48 2011/07/03 15:47:17 matthew Exp $ */
a198 1
void upl_input(struct ifnet *, struct mbuf *);
a991 28
}

void
upl_input(struct ifnet *ifp, struct mbuf *m)
{
	struct ifqueue *inq;
	int s;

	/* XXX Assume all traffic is IP */

	schednetisr(NETISR_IP);
	inq = &ipintrq;

	s = splnet();
	if (IF_QFULL(inq)) {
		IF_DROP(inq);
		splx(s);
#if 0
		if (sc->sc_flags & SC_DEBUG)
			printf("%s: input queue full\n", ifp->if_xname);
#endif
		ifp->if_iqdrops++;
		return;
	}
	IF_ENQUEUE(inq, m);
	splx(s);
	ifp->if_ipackets++;
	ifp->if_ibytes += m->m_len;
@


1.48
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.47 2011/01/25 20:03:35 jakemsr Exp $ */
d295 1
a295 1
	ifp->if_baudrate = 12000000;
@


1.47
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.46 2010/12/17 13:48:06 jasper Exp $ */
a348 3
	case DVACT_ACTIVATE:
		break;

@


1.46
log
@- use usb_lookup() instead of handrolled macro.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.45 2010/12/06 05:46:17 jakemsr Exp $ */
a303 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
a336 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.45
log
@a couple unchecked if_detach() in detach routines that were missed
in previous sweep (avoid NULL deref if the device didn't fully attach)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.44 2010/09/24 08:33:59 yuo Exp $ */
a106 5
struct upl_type {
	u_int16_t		upl_vid;
	u_int16_t		upl_did;
};

d161 1
a161 1
struct upl_type sc_devs[] = {
d163 1
a163 2
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2302 },
	{ 0, 0 }
a207 1
	struct upl_type			*t;
d212 2
a213 5
	for (t = sc_devs; t->upl_vid != 0; t++)
		if (uaa->vendor == t->upl_vid && uaa->product == t->upl_did)
			return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
@


1.44
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.43 2009/10/13 19:33:17 pirofti Exp $ */
d337 2
a338 1
	if_detach(ifp);
@


1.43
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.42 2008/10/03 03:13:09 brad Exp $ */
d328 4
a332 6

	if (!sc->sc_attached) {
		/* Detached before attached finished, so just bail out. */
		splx(s);
		return (0);
	}
@


1.42
log
@Return ENOTTY for unknown ioctl's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.41 2008/06/26 05:42:18 ray Exp $ */
d175 1
a175 1
int upl_activate(struct device *, enum devact); 
d359 1
a359 1
upl_activate(struct device *self, enum devact act)
@


1.41
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.40 2007/10/11 18:33:14 deraadt Exp $ */
d872 1
a872 1
		error = EINVAL;
a876 1

@


1.40
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.39 2007/09/17 01:40:38 fgsch Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.39
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.38 2007/06/14 10:11:15 mbalmer Exp $ */
a237 1
	char			*devinfop;
a247 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.38
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.37 2007/06/13 11:15:29 mbalmer Exp $ */
a50 1
#include <sys/malloc.h>
@


1.37
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.36 2007/06/12 16:26:36 mbalmer Exp $ */
d180 16
a195 1
USB_DECLARE_DRIVER_CLASS(upl, DV_IFNET);
@


1.36
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.35 2007/06/10 14:49:00 mbalmer Exp $ */
d543 1
a543 1
	IF_INPUT(ifp, m);
@


1.35
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.34 2007/06/10 10:53:48 mbalmer Exp $ */
d357 1
a357 1
upl_activate(device_ptr_t self, enum devact act)
@


1.34
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.33 2007/06/10 10:15:35 mbalmer Exp $ */
d237 1
a237 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d243 1
a243 1
		    USBDEVNAME(sc->sc_dev));
d254 1
a254 1
		    USBDEVNAME(sc->sc_dev));
d266 1
a266 1
			    USBDEVNAME(sc->sc_dev), i);
d283 1
a283 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
d297 1
a297 1
	strlcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d324 1
a324 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d344 1
a344 1
		       USBDEVNAME(sc->sc_dev));
d361 1
a361 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d382 1
a382 1
	DPRINTFN(8,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d388 1
a388 1
			    "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d395 1
a395 1
			    "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d418 1
a418 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d449 1
a449 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d498 1
a498 1
			    USBDEVNAME(sc->sc_dev), sc->sc_rx_errs,
d510 1
a510 1
		    USBDEVNAME(sc->sc_dev), __func__, status, total_len));
d540 1
a540 1
	DPRINTFN(10,("%s: %s: deliver %d\n", USBDEVNAME(sc->sc_dev),
d556 1
a556 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->sc_dev),
d578 1
a578 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->sc_dev),
d590 1
a590 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->sc_dev),
d628 1
a628 1
		     USBDEVNAME(sc->sc_dev), __func__, total_len));
d637 1
a637 1
		printf("%s: upl_send error=%s\n", USBDEVNAME(sc->sc_dev),
d657 1
a657 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d700 1
a700 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d709 1
a709 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->sc_dev));
d716 1
a716 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->sc_dev));
d746 1
a746 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d753 1
a753 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d762 1
a762 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d789 1
a789 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d804 1
a804 1
			    USBDEVNAME(sc->sc_dev), sc->sc_rx_errs,
d818 1
a818 1
	DPRINTFN(10,("%s: %s: stat=0x%02x\n", USBDEVNAME(sc->sc_dev),
d835 1
a835 1
		    USBDEVNAME(sc->sc_dev), __func__, command));
d884 1
a884 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d890 1
a890 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->sc_dev));
d910 1
a910 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d921 1
a921 1
			USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d926 1
a926 1
			USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d935 1
a935 1
			USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d940 1
a940 1
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d949 1
a949 1
			USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d954 1
a954 1
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d991 1
a991 1
		     USBDEVNAME(((struct upl_softc *)ifp->if_softc)->sc_dev),
@


1.33
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.32 2007/06/09 12:22:53 mbalmer Exp $ */
d314 1
a314 1
	    USBDEV(sc->sc_dev));
d351 1
a351 1
	    USBDEV(sc->sc_dev));
@


1.32
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.31 2007/06/06 19:25:49 mk Exp $ */
d143 1
a143 1
	usb_callout_t		sc_stat_ch;
@


1.31
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.30 2007/06/05 08:43:55 mbalmer Exp $ */
a367 2
		/* Deactivate the interface. */
		if_deactivate(&sc->sc_if);
@


1.30
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.29 2007/06/01 06:12:20 mbalmer Exp $ */
d140 1
a140 1
	USBBASEDEVICE		sc_dev;
@


1.29
log
@Remove more Free(?)BSD and NetBSD #ifdef/#endifs.  No functional nor
binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.28 2007/05/27 04:00:25 jsg Exp $ */
d174 1
a174 1
Static struct upl_type sc_devs[] = {
d182 13
a194 13
Static int upl_openpipes(struct upl_softc *);
Static int upl_tx_list_init(struct upl_softc *);
Static int upl_rx_list_init(struct upl_softc *);
Static int upl_newbuf(struct upl_softc *, struct upl_chain *, struct mbuf *);
Static int upl_send(struct upl_softc *, struct mbuf *, int);
Static void upl_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void upl_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void upl_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void upl_start(struct ifnet *);
Static int upl_ioctl(struct ifnet *, u_long, caddr_t);
Static void upl_init(void *);
Static void upl_stop(struct upl_softc *);
Static void upl_watchdog(struct ifnet *);
d196 1
a196 1
Static int upl_output(struct ifnet *, struct mbuf *, struct sockaddr *,
d198 1
a198 1
Static void upl_input(struct ifnet *, struct mbuf *);
d379 1
a379 1
Static int
d413 1
a413 1
Static int
d444 1
a444 1
Static int
d478 1
a478 1
Static void
d567 1
a567 1
Static void
d611 1
a611 1
Static int
d650 1
a650 1
Static void
d692 1
a692 1
Static void
d736 1
a736 1
Static int
d784 1
a784 1
Static void
d825 1
a825 1
Static int
d881 1
a881 1
Static void
d905 1
a905 1
Static void
d986 1
a986 1
Static int
d1016 1
a1016 1
Static void
@


1.28
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.27 2007/05/21 05:40:27 jsg Exp $ */
a47 3
#if defined(__NetBSD__) || defined(__FreeBSD__)
#include <sys/callout.h>
#else
a48 1
#endif
a68 3
#if defined(__NetBSD__)
#include <netinet/if_inarp.h>
#elif defined(__OpenBSD__)
a71 1
#endif
a303 4
#if defined(__NetBSD__)
	ifp->if_input = upl_input;
	ifp->if_dlt = DLT_RAW;
#endif
a309 3
#if defined(__NetBSD__) && NBPFILTER > 0
	bpfattach(ifp, DLT_RAW, 0);
#endif
a544 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a545 3
#else
	upl_input(ifp, m);
#endif
@


1.27
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.26 2007/02/11 20:29:22 miod Exp $ */
d211 2
a212 1
USB_MATCH(upl)
d214 1
a214 1
	USB_MATCH_START(upl, uaa);
d227 2
a228 1
USB_ATTACH(upl)
d230 2
a231 1
	USB_ATTACH_START(upl, sc, uaa);
d245 1
a245 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d252 1
a252 1
		USB_ATTACH_ERROR_RETURN;
d263 1
a263 1
		USB_ATTACH_ERROR_RETURN;
d275 1
a275 1
			USB_ATTACH_ERROR_RETURN;
d292 1
a292 1
		USB_ATTACH_ERROR_RETURN;
a329 2

	USB_ATTACH_SUCCESS_RETURN;
d332 2
a333 1
USB_DETACH(upl)
d335 1
a335 1
	USB_DETACH_START(upl, sc);
@


1.26
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.25 2006/06/23 06:27:11 miod Exp $ */
d171 2
a172 2
#define DPRINTF(x)	do { if (upldebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (upldebug >= (n)) logprintf x; } while (0)
@


1.25
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.24 2006/03/25 22:41:47 djm Exp $ */
a42 6

#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
#include "rnd.h"
#endif
@


1.24
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.23 2006/03/07 04:41:19 krw Exp $ */
a384 1
		return (EOPNOTSUPP);
@


1.23
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.22 2006/01/29 03:22:52 brad Exp $ */
a71 2
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))

d559 1
a559 1
		BPF_MTAP(ifp, m);
d706 1
a706 1
		BPF_MTAP(ifp, m_head);
@


1.22
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.21 2006/01/04 06:04:41 canacar Exp $ */
a65 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a158 4
#if NRND > 0
	rndsource_element_t	sc_rnd_source;
#endif

a330 5
#if NRND > 0
	rnd_attach_source(&sc->sc_rnd_source, USBDEVNAME(sc->sc_dev),
	    RND_TYPE_NET, 0);
#endif

a357 4

#if NRND > 0
	rnd_detach_source(&sc->sc_rnd_source);
#endif
@


1.21
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.20 2005/08/01 05:36:48 brad Exp $ */
d544 1
a544 1
			usbd_clear_endpoint_stall(sc->sc_ep[UPL_ENDPT_RX]);
d638 1
a638 1
			usbd_clear_endpoint_stall(sc->sc_ep[UPL_ENDPT_TX]);
d854 1
a854 1
			usbd_clear_endpoint_stall(sc->sc_ep[UPL_ENDPT_RX]);
@


1.20
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.19 2005/07/02 22:21:12 brad Exp $ */
a372 3
#endif
#if NBPFILTER > 0
	bpfdetach(ifp);
@


1.19
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.18 2005/06/08 17:03:02 henning Exp $ */
d244 1
a244 1
	char			devinfo[1024];
d256 1
a256 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d258 2
a259 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.18
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.17 2004/11/10 10:14:48 grange Exp $ */
d961 1
a1028 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.17
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.16 2004/07/08 22:18:44 deraadt Exp $ */
a94 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a895 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.16
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.15 2003/12/15 23:36:14 cedric Exp $ */
d322 1
a322 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
@


1.15
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.14 2003/05/07 04:33:33 deraadt Exp $ */
d191 2
a192 2
#define DPRINTF(x)	if (upldebug) logprintf x
#define DPRINTFN(n,x)	if (upldebug >= (n)) logprintf x
@


1.14
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.13 2003/01/07 09:00:34 kjc Exp $ */
d208 1
a208 1
USB_DECLARE_DRIVER(upl);
@


1.13
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.12 2002/07/29 02:56:56 nate Exp $ */
d261 1
a261 1
	usbd_devinfo(dev, 0, devinfo);
@


1.12
log
@Make code more portable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.11 2002/07/25 02:18:10 nate Exp $ */
a1056 1
	ALTQ_DECL(struct altq_pktattr pktattr;)
a1061 6
	/*
	 * if the queueing discipline needs packet classification,
	 * do it now.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

d1068 1
a1068 1
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
@


1.11
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: if_upl.c,v 1.10 2002/06/30 13:04:36 itojun Exp $ */
/*	$NetBSD: if_upl.c,v 1.15 2001/06/14 05:44:27 itojun Exp $	*/
a80 1
#if defined(__NetBSD__)
d84 1
d86 1
a86 8
#else
#error upl without INET?
#endif
#endif

#if defined(__OpenBSD__)
#ifdef INET
#include <netinet/in.h>
a87 1
#include <netinet/in_var.h>
d90 1
a93 1
#endif
d328 1
d331 1
a332 1
	ifp->if_baudrate = 12000000;
d339 1
a339 2
#if NBPFILTER > 0
#if defined(__NetBSD__) || defined(__FreeBSD__)
a340 1
#endif
@


1.10
log
@allocate sockaddr_dl for ifnet in if_alloc_sadl(), as we don't always know
the size of sockaddr_dl on if_attach() - for instance, see ether_ifattach().
from netbsd.  fgs ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.9 2002/06/26 11:29:55 espie Exp $ */
d83 2
a84 2
#include <netinet/in.h> 
#include <netinet/in_var.h> 
d819 1
a819 1
	    &sc->sc_ibuf, UPL_INTR_PKTLEN, upl_intr, 
@


1.9
log
@Kill __FUNCTION__.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.8 2002/06/07 06:26:28 fgsch Exp $ */
d344 1
@


1.8
log
@use IF_INPUT macro for us as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.7 2002/05/07 18:29:18 nate Exp $ */
d370 1
a370 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d414 1
a414 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d438 1
a438 1
	DPRINTFN(8,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d474 1
a474 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d505 1
a505 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d566 1
a566 1
		    USBDEVNAME(sc->sc_dev), __FUNCTION__, status, total_len));
d597 1
a597 1
		    __FUNCTION__, m->m_len));
d617 1
a617 1
		    __FUNCTION__));
d639 1
a639 1
		    __FUNCTION__, status));
d688 1
a688 1
		     USBDEVNAME(sc->sc_dev), __FUNCTION__, total_len));
d717 1
a717 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d760 1
a760 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d849 1
a849 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d879 1
a879 1
		     __FUNCTION__, stat));
d895 1
a895 1
		    USBDEVNAME(sc->sc_dev), __FUNCTION__, command));
d959 1
a959 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d985 1
a985 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d1069 1
a1069 1
		     __FUNCTION__));
@


1.7
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.5 2002/03/12 09:51:20 kjc Exp $ */
d599 1
a599 1
#if defined(__NetBSD__)
@


1.6
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: if_upl.c,v 1.17 2002/03/05 04:12:59 itojun Exp $	*/
d81 1
a84 1
#if defined(__NetBSD__)
d86 8
a93 1
#elif defined(__OpenBSD__)
d95 1
a97 1
#endif
d101 1
a335 1
	ifp->if_baudrate = 12000000;
a337 1
	ifp->if_dlt = DLT_RAW;
d339 1
a343 3
#if defined(__NetBSD__)
	if_alloc_sadl(ifp);
#endif
d345 2
a346 1
#if defined(__NetBSD__) && NBPFILTER > 0
d348 1
@


1.5
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 2
a2 2
/*	$OpenBSD: if_upl.c,v 1.4 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: if_upl.c,v 1.15 2001/06/14 05:44:27 itojun Exp $	*/
a80 1
#if defined(__NetBSD__)
d84 1
d86 1
a86 8
#else
#error upl without INET?
#endif
#endif

#if defined(__OpenBSD__)
#ifdef INET
#include <netinet/in.h>
a87 1
#include <netinet/in_var.h>
d90 1
a93 1
#endif
d328 1
d331 1
a332 1
	ifp->if_baudrate = 12000000;
d337 3
d341 1
a341 2
#if NBPFILTER > 0
#if defined(__NetBSD__) || defined(__FreeBSD__)
a342 1
#endif
@


1.4
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.3 2001/06/15 03:38:35 itojun Exp $ */
d340 1
d663 1
a663 1
	if (ifp->if_snd.ifq_head != NULL)
d722 1
a722 1
	IF_DEQUEUE(&ifp->if_snd, m_head);
a726 1
		IF_PREPEND(&ifp->if_snd, m_head);
d731 2
d970 1
a970 1
	if (ifp->if_snd.ifq_head != NULL)
d1064 2
a1065 1
	int s;
d1071 7
d1083 3
a1085 2
	if (IF_QFULL(&ifp->if_snd)) {
		IF_DROP(&ifp->if_snd);
d1087 1
a1087 1
		return (ENOBUFS);
d1089 1
a1089 2
	ifp->if_obytes += m->m_pkthdr.len;
	IF_ENQUEUE(&ifp->if_snd, m);
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.4 2001/10/31 04:24:44 nate Exp $ */
a339 1
	IFQ_SET_READY(&ifp->if_snd);
d598 1
a598 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d662 1
a662 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d721 1
a721 1
	IFQ_POLL(&ifp->if_snd, m_head);
d726 1
a730 2
	IFQ_DEQUEUE(&ifp->if_snd, m_head);

d968 1
a968 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1062 1
a1062 2
	int s, len, error;
	ALTQ_DECL(struct altq_pktattr pktattr;)
a1067 7
	/*
	 * if the queueing discipline needs packet classification,
	 * do it now.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

	len = m->m_pkthdr.len;
d1073 2
a1074 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d1076 1
a1076 1
		return (error);
d1078 2
a1079 1
	ifp->if_obytes += len;
@


1.4.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_upl.c,v 1.19 2002/07/11 21:14:26 augustss Exp $	*/
d81 11
d94 1
a95 4
#if defined(__NetBSD__)
#include <netinet/if_inarp.h>
#elif defined(__OpenBSD__)
#include <netinet/in_systm.h>
a97 1
#endif
d101 1
a335 1
	ifp->if_baudrate = 12000000;
a337 1
	ifp->if_dlt = DLT_RAW;
d339 1
a343 1
	if_alloc_sadl(ifp);
d345 2
a346 1
#if defined(__NetBSD__) && NBPFILTER > 0
d349 1
d370 1
a370 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d414 1
a414 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d438 1
a438 1
	DPRINTFN(8,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d474 1
a474 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d505 1
a505 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d566 1
a566 1
		    USBDEVNAME(sc->sc_dev), __func__, status, total_len));
d597 1
a597 1
		    __func__, m->m_len));
d617 1
a617 1
		    __func__));
d639 1
a639 1
		    __func__, status));
d688 1
a688 1
		     USBDEVNAME(sc->sc_dev), __func__, total_len));
d717 1
a717 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d760 1
a760 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d818 1
a818 1
	    &sc->sc_ibuf, UPL_INTR_PKTLEN, upl_intr,
d849 1
a849 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d879 1
a879 1
		     __func__, stat));
d895 1
a895 1
		    USBDEVNAME(sc->sc_dev), __func__, command));
d959 1
a959 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d985 1
a985 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d1069 1
a1069 1
		     __func__));
@


1.4.2.3
log
@sync
@
text
@d261 1
a261 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d1057 1
d1063 6
d1075 1
a1075 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.3
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_upl.c,v 1.2 2001/02/20 19:39:47 mickey Exp $ */
/*	$NetBSD: if_upl.c,v 1.10 2000/12/08 02:24:07 augustss Exp $	*/
d320 1
a320 1
	s = splimp();
d346 1
a346 1
	bpfattach(ifp, DLT_EN10MB, 0);
d575 1
a575 1
	s = splimp();
d635 1
a635 1
	s = splimp();
d763 1
a763 1
	s = splimp();
d895 1
a895 1
	s = splimp();
d1068 1
a1068 1
	s = splimp();
d1098 1
a1098 1
	s = splimp();
@


1.2
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.1 2001/01/28 17:45:18 aaron Exp $ */
a1112 1
	ifp->if_lastchange = time;
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.2 2001/02/20 19:39:47 mickey Exp $ */
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.2.4.1 2001/05/14 22:26:19 niklas Exp $ */
d1113 1
@


1.2.4.3
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_upl.c,v 1.15 2001/06/14 05:44:27 itojun Exp $	*/
d320 1
a320 1
	s = splnet();
d346 1
a346 1
	bpfattach(ifp, DLT_RAW, 0);
d575 1
a575 1
	s = splnet();
d635 1
a635 1
	s = splnet();
d763 1
a763 1
	s = splnet();
d895 1
a895 1
	s = splnet();
d1068 1
a1068 1
	s = splnet();
d1098 1
a1098 1
	s = splnet();
@


1.2.4.4
log
@Merge in -current from roughly a week ago
@
text
@a339 1
	IFQ_SET_READY(&ifp->if_snd);
d662 1
a662 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d721 1
a721 1
	IFQ_POLL(&ifp->if_snd, m_head);
d726 1
a730 2
	IFQ_DEQUEUE(&ifp->if_snd, m_head);

d968 1
a968 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1062 1
a1062 2
	int s, len, error;
	ALTQ_DECL(struct altq_pktattr pktattr;)
a1067 7
	/*
	 * if the queueing discipline needs packet classification,
	 * do it now.
	 */
	IFQ_CLASSIFY(&ifp->if_snd, m, dst->sa_family, &pktattr);

	len = m->m_pkthdr.len;
d1073 2
a1074 3
	IFQ_ENQUEUE(&ifp->if_snd, m, &pktattr, error);
	if (error) {
		/* mbuf is already freed */
d1076 1
a1076 1
		return (error);
d1078 2
a1079 1
	ifp->if_obytes += len;
@


1.2.4.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: if_upl.c,v 1.19 2002/07/11 21:14:26 augustss Exp $	*/
d81 11
d94 1
a95 4
#if defined(__NetBSD__)
#include <netinet/if_inarp.h>
#elif defined(__OpenBSD__)
#include <netinet/in_systm.h>
a97 1
#endif
d101 1
a335 1
	ifp->if_baudrate = 12000000;
a337 1
	ifp->if_dlt = DLT_RAW;
d339 1
a343 1
	if_alloc_sadl(ifp);
d345 2
a346 1
#if defined(__NetBSD__) && NBPFILTER > 0
d349 1
d370 1
a370 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d414 1
a414 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d438 1
a438 1
	DPRINTFN(8,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d474 1
a474 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d505 1
a505 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d566 1
a566 1
		    USBDEVNAME(sc->sc_dev), __func__, status, total_len));
d597 1
a597 1
		    __func__, m->m_len));
d599 1
a599 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d617 1
a617 1
		    __func__));
d639 1
a639 1
		    __func__, status));
d688 1
a688 1
		     USBDEVNAME(sc->sc_dev), __func__, total_len));
d717 1
a717 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d760 1
a760 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d818 1
a818 1
	    &sc->sc_ibuf, UPL_INTR_PKTLEN, upl_intr,
d849 1
a849 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d879 1
a879 1
		     __func__, stat));
d895 1
a895 1
		    USBDEVNAME(sc->sc_dev), __func__, command));
d959 1
a959 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d985 1
a985 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d1065 1
d1069 7
a1075 1
		     __func__));
d1083 1
a1083 1
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
@


1.2.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upl.c,v 1.2.4.5 2003/03/28 00:38:31 niklas Exp $ */
d261 1
a261 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.2.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d208 1
a208 1
USB_DECLARE_DRIVER_CLASS(upl, DV_IFNET);
@


1.1
log
@Add driver for Prolific PL2301/PL2302 host-to-host adapter. From NetBSD.
/* XXX - untested */

Note: just reminding myself that I need to create a nice diff for Lennart
to further portablize the USB code (I fell behind in doing this). In
particular, for this driver, the IF_INPUT() macro just does ether_input()
in OpenBSD, but we really want to call the local upl_input() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a346 2
#else
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
@

