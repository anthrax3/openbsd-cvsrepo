head	1.78;
access;
symbols
	OPENBSD_6_2:1.78.0.4
	OPENBSD_6_2_BASE:1.78
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.76.0.6
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.71.0.4
	OPENBSD_5_8_BASE:1.71
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.58.0.4
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.2
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.54.0.2
	OPENBSD_4_9_BASE:1.54
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.17
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.6.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.78
date	2017.05.12.09.16.55;	author mpi;	state Exp;
branches;
next	1.77;
commitid	X2MJ0BBsPUZMUK2x;

1.77
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.76;
commitid	eXDj5wwfsbdFBB4L;

1.76
date	2016.01.12.19.16.21;	author jcs;	state Exp;
branches;
next	1.75;
commitid	Sn97Jww24us5dd5Z;

1.75
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.74;
commitid	KAeCDAijcgEnOtfF;

1.74
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.73;
commitid	kI4H556ZKYkRQGw5;

1.73
date	2015.12.25.20.28.48;	author jung;	state Exp;
branches;
next	1.72;
commitid	KIgomOtnkmDysr5o;

1.72
date	2015.12.09.09.23.21;	author jung;	state Exp;
branches;
next	1.71;
commitid	okhWSruHSh7B8x8b;

1.71
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.70;
commitid	p4LJxGKbi0BU2cG6;

1.70
date	2015.01.19.20.16.10;	author miod;	state Exp;
branches;
next	1.69;
commitid	m6vvxNizIh90KWwo;

1.69
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.68;
commitid	L2P5oN9ppxqXZsYS;

1.68
date	2014.08.21.14.52.55;	author mpi;	state Exp;
branches;
next	1.67;
commitid	nyUgTgf8DHNH5RDf;

1.67
date	2014.05.12.09.50.44;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2014.04.27.13.32.04;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.24.09.40.28;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.26.17.48.08;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2013.11.15.08.17.44;	author pirofti;	state Exp;
branches;
next	1.61;

1.61
date	2013.11.13.13.48.08;	author pirofti;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.26.07.53.20;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.13.12.33.08;	author shadchin;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.29.11.04.19;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2011.12.04.15.09.35;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.29.15.28.11;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2010.08.02.23.17.34;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2010.07.31.16.04.50;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2010.02.22.17.24.20;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2009.11.25.13.36.53;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.25.11.39.45;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.13.20.56.50;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.31.11.01.48;	author blambert;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.21.18.18.33;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.08.20.59.29;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.19.18.09.06;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.16.16.08.39;	author mk;	state Exp;
branches;
next	1.39;

1.39
date	2008.01.24.14.50.38;	author robert;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.23.19.21.40;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.13.07.43.15;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.26.22.14.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.18.07.41.38;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.30.21.11.41;	author matthieu;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.05.16.56.45;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.29.20.03.05;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.11.08.15.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.03.17.27.58;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.10.25.15.20.07;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.25.14.36.11;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.25.04.54.37;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.03.07.20.42.38;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.28.21.14.08;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.11.13.15.27.43;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.06.22.46.01;	author rahnds;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.22;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.43.55;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.78
log
@Introduce a new keyboard console hook to enter ddb(4) and make ukbd(4)
use it.

Instead of defering every input of a USB console keyboard to a timeout
via a queue of one element, only differ entering ddb(4) once a matching
control sequenece has been typed.

This prevent loosing inputs when a USB console keyboard is "too fast".

Fix a problem reported by matthieu@@, Adam McDougall and Hrvoje Popovski.

ok stsp@@, dlg@@
@
text
@/*	$OpenBSD: ukbd.c,v 1.77 2017/03/11 11:55:03 mpi Exp $	*/
/*      $NetBSD: ukbd.c,v 1.85 2003/03/11 16:44:00 augustss Exp $        */

/*
 * Copyright (c) 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/ioctl.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h> /* needs_reattach() */
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>
#include <dev/usb/uhidev.h>
#include <dev/usb/ukbdvar.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>

#include <dev/hid/hidkbdsc.h>

#ifdef UKBD_DEBUG
#define DPRINTF(x)	do { if (ukbddebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (ukbddebug>(n)) printf x; } while (0)
int	ukbddebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

const kbd_t ukbd_countrylayout[1 + HCC_MAX] = {
	(kbd_t)-1,
	(kbd_t)-1,	/* arabic */
	KB_BE,		/* belgian */
	(kbd_t)-1,	/* canadian bilingual */
	KB_CF,		/* canadian french */
	(kbd_t)-1,	/* czech */
	KB_DK,		/* danish */
	(kbd_t)-1,	/* finnish */
	KB_FR,		/* french */
	KB_DE,		/* german */
	(kbd_t)-1,	/* greek */
	(kbd_t)-1,	/* hebrew */
	KB_HU,		/* hungary */
	(kbd_t)-1,	/* international (iso) */
	KB_IT,		/* italian */
	KB_JP,		/* japanese (katakana) */
	(kbd_t)-1,	/* korean */
	KB_LA,		/* latin american */
	(kbd_t)-1,	/* netherlands/dutch */
	KB_NO,		/* norwegian */
	(kbd_t)-1,	/* persian (farsi) */
	KB_PL,		/* polish */
	KB_PT,		/* portuguese */
	KB_RU,		/* russian */
	(kbd_t)-1,	/* slovakia */
	KB_ES,		/* spanish */
	KB_SV,		/* swedish */
	KB_SF,		/* swiss french */
	KB_SG,		/* swiss german */
	(kbd_t)-1,	/* switzerland */
	(kbd_t)-1,	/* taiwan */
	KB_TR,		/* turkish Q */
	KB_UK,		/* uk */
	KB_US,		/* us */
	(kbd_t)-1,	/* yugoslavia */
	(kbd_t)-1	/* turkish F */
};

struct ukbd_softc {
	struct uhidev		sc_hdev;
#define sc_ledsize		sc_hdev.sc_osize

	struct hidkbd		sc_kbd;
	int			sc_spl;
	struct hid_location	sc_apple_fn;
	void			(*sc_munge)(void *, uint8_t *, u_int);

#ifdef DDB
	struct timeout		sc_ddb;	/* for entering DDB */
#endif
};

void	ukbd_cngetc(void *, u_int *, int *);
void	ukbd_cnpollc(void *, int);
void	ukbd_cnbell(void *, u_int, u_int, u_int);
void	ukbd_debugger(void *);

const struct wskbd_consops ukbd_consops = {
	ukbd_cngetc,
	ukbd_cnpollc,
	ukbd_cnbell,
#ifdef DDB
	ukbd_debugger,
#endif
};

void	ukbd_intr(struct uhidev *addr, void *ibuf, u_int len);

void	ukbd_db_enter(void *);
int	ukbd_enable(void *, int);
void	ukbd_set_leds(void *, int);
int	ukbd_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wskbd_accessops ukbd_accessops = {
	ukbd_enable,
	ukbd_set_leds,
	ukbd_ioctl,
};

int	ukbd_match(struct device *, void *, void *);
void	ukbd_attach(struct device *, struct device *, void *);
int	ukbd_detach(struct device *, int);

struct cfdriver ukbd_cd = {
	NULL, "ukbd", DV_DULL
};

const struct cfattach ukbd_ca = {
	sizeof(struct ukbd_softc), ukbd_match, ukbd_attach, ukbd_detach
};

struct ukbd_translation {
	uint8_t original;
	uint8_t translation;
};

#ifdef __loongson__
void	ukbd_gdium_munge(void *, uint8_t *, u_int);
#endif
void	ukbd_apple_munge(void *, uint8_t *, u_int);
void	ukbd_apple_mba_munge(void *, uint8_t *, u_int);
void	ukbd_apple_iso_munge(void *, uint8_t *, u_int);
void	ukbd_apple_iso_mba_munge(void *, uint8_t *, u_int);
void	ukbd_apple_translate(void *, uint8_t *, u_int,
	    const struct ukbd_translation *, u_int);
uint8_t	ukbd_translate(const struct ukbd_translation *, size_t, uint8_t);

int
ukbd_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	int size;
	void *desc;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
		return (UMATCH_NONE);

	return (UMATCH_IFACECLASS);
}

void
ukbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct ukbd_softc *sc = (struct ukbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	struct usb_hid_descriptor *hid;
	u_int32_t quirks, qflags = 0;
	int dlen, repid;
	int console = 1;
	void *desc;
	kbd_t layout = (kbd_t)-1;

	sc->sc_hdev.sc_intr = ukbd_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_udev = uha->uaa->device;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &dlen);
	repid = uha->reportid;
	sc->sc_hdev.sc_isize = hid_report_size(desc, dlen, hid_input, repid);
	sc->sc_hdev.sc_osize = hid_report_size(desc, dlen, hid_output, repid);
	sc->sc_hdev.sc_fsize = hid_report_size(desc, dlen, hid_feature, repid);

	 /*
	  * Since the HID-Proxy is always detected before any
	  * real keyboard, do not let it grab the console.
	  */
	if (uha->uaa->vendor == USB_VENDOR_APPLE &&
	    uha->uaa->product == USB_PRODUCT_APPLE_BLUETOOTH_HCI)
		console = 0;

	quirks = usbd_get_quirks(sc->sc_hdev.sc_udev)->uq_flags;
	if (quirks & UQ_SPUR_BUT_UP)
		qflags |= HIDKBD_SPUR_BUT_UP;

	if (hidkbd_attach(self, kbd, console, qflags, repid, desc, dlen) != 0)
		return;

	if (uha->uaa->vendor == USB_VENDOR_APPLE) {
		if (hid_locate(desc, dlen, HID_USAGE2(HUP_APPLE, HUG_FN_KEY),
		    uha->reportid, hid_input, &sc->sc_apple_fn, &qflags)) {
			if (qflags & HIO_VARIABLE) {
				switch (uha->uaa->product) {
				case USB_PRODUCT_APPLE_FOUNTAIN_ISO:
				case USB_PRODUCT_APPLE_GEYSER_ISO:
				case USB_PRODUCT_APPLE_WELLSPRING6_ISO:
				case USB_PRODUCT_APPLE_WELLSPRING8_ISO:
					sc->sc_munge = ukbd_apple_iso_munge;
					break;
				case USB_PRODUCT_APPLE_WELLSPRING_ISO:
				case USB_PRODUCT_APPLE_WELLSPRING4_ISO:
				case USB_PRODUCT_APPLE_WELLSPRING4A_ISO:
					sc->sc_munge = ukbd_apple_iso_mba_munge;
					break;
				case USB_PRODUCT_APPLE_WELLSPRING_ANSI:
				case USB_PRODUCT_APPLE_WELLSPRING_JIS:
				case USB_PRODUCT_APPLE_WELLSPRING4_ANSI:
				case USB_PRODUCT_APPLE_WELLSPRING4_JIS:
				case USB_PRODUCT_APPLE_WELLSPRING4A_ANSI:
				case USB_PRODUCT_APPLE_WELLSPRING4A_JIS:
					sc->sc_munge = ukbd_apple_mba_munge;
					break;
				default:
					sc->sc_munge = ukbd_apple_munge;
					break;
				}
			}
		}
	}

	if (uha->uaa->vendor == USB_VENDOR_TOPRE &&
	    uha->uaa->product == USB_PRODUCT_TOPRE_HHKB) {
		/* ignore country code on purpose */
	} else {
		usb_interface_descriptor_t *id;

		id = usbd_get_interface_descriptor(uha->uaa->iface);
		hid = usbd_get_hid_descriptor(uha->uaa->device, id);

		if (hid->bCountryCode <= HCC_MAX)
			layout = ukbd_countrylayout[hid->bCountryCode];
#ifdef DIAGNOSTIC
		if (hid->bCountryCode != 0)
			printf(", country code %d", hid->bCountryCode);
#endif
	}
	if (layout == (kbd_t)-1) {
#ifdef UKBD_LAYOUT
		layout = UKBD_LAYOUT;
#else
		layout = KB_US | KB_DEFAULT;
#endif
	}

	printf("\n");

#ifdef __loongson__
	if (uha->uaa->vendor == USB_VENDOR_CYPRESS &&
	    uha->uaa->product == USB_PRODUCT_CYPRESS_LPRDK)
		sc->sc_munge = ukbd_gdium_munge;
#endif

	if (kbd->sc_console_keyboard) {
		extern struct wskbd_mapdata ukbd_keymapdata;

		DPRINTF(("ukbd_attach: console keyboard sc=%p\n", sc));
		ukbd_keymapdata.layout = layout;
		wskbd_cnattach(&ukbd_consops, sc, &ukbd_keymapdata);
		ukbd_enable(sc, 1);
	}

	/* Flash the leds; no real purpose, just shows we're alive. */
	ukbd_set_leds(sc, WSKBD_LED_SCROLL | WSKBD_LED_NUM |
		          WSKBD_LED_CAPS | WSKBD_LED_COMPOSE);
	usbd_delay_ms(sc->sc_hdev.sc_udev, 400);
	ukbd_set_leds(sc, 0);

	hidkbd_attach_wskbd(kbd, layout, &ukbd_accessops);

#ifdef DDB
	timeout_set(&sc->sc_ddb, ukbd_db_enter, sc);
#endif
}

int
ukbd_detach(struct device *self, int flags)
{
	struct ukbd_softc *sc = (struct ukbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;
	int rv;

	rv = hidkbd_detach(kbd, flags);

	/* The console keyboard does not get a disable call, so check pipe. */
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);

	return (rv);
}

void
ukbd_intr(struct uhidev *addr, void *ibuf, u_int len)
{
	struct ukbd_softc *sc = (struct ukbd_softc *)addr;
	struct hidkbd *kbd = &sc->sc_kbd;

	if (kbd->sc_enabled != 0) {
		if (sc->sc_munge != NULL)
			(*sc->sc_munge)(sc, (uint8_t *)ibuf, len);
		hidkbd_input(kbd, (uint8_t *)ibuf, len);
	}
}

int
ukbd_enable(void *v, int on)
{
	struct ukbd_softc *sc = v;
	struct hidkbd *kbd = &sc->sc_kbd;
	int rv;

	if (on && usbd_is_dying(sc->sc_hdev.sc_udev))
		return EIO;

	if ((rv = hidkbd_enable(kbd, on)) != 0)
		return rv;

	if (on) {
		return uhidev_open(&sc->sc_hdev);
	} else {
		uhidev_close(&sc->sc_hdev);
		return 0;
	}
}

void
ukbd_set_leds(void *v, int leds)
{
	struct ukbd_softc *sc = v;
	struct hidkbd *kbd = &sc->sc_kbd;
	u_int8_t res;

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return;

	if (sc->sc_ledsize && hidkbd_set_leds(kbd, leds, &res) != 0)
		uhidev_set_report_async(sc->sc_hdev.sc_parent,
		    UHID_OUTPUT_REPORT, sc->sc_hdev.sc_report_id, &res, 1);
}

int
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct ukbd_softc *sc = v;
	struct hidkbd *kbd = &sc->sc_kbd;
	int rc;

	switch (cmd) {
	case WSKBDIO_GTYPE:
		*(int *)data = WSKBD_TYPE_USB;
		return (0);
	case WSKBDIO_SETLEDS:
		ukbd_set_leds(v, *(int *)data);
		return (0);
	default:
		rc = uhidev_ioctl(&sc->sc_hdev, cmd, data, flag, p);
		if (rc != -1)
			return rc;
		else
			return hidkbd_ioctl(kbd, cmd, data, flag, p);
	}
}

/* Console interface. */
void
ukbd_cngetc(void *v, u_int *type, int *data)
{
	struct ukbd_softc *sc = v;
	struct hidkbd *kbd = &sc->sc_kbd;

	DPRINTFN(0,("ukbd_cngetc: enter\n"));
	kbd->sc_polling = 1;
	while (kbd->sc_npollchar <= 0)
		usbd_dopoll(sc->sc_hdev.sc_udev);
	kbd->sc_polling = 0;
	hidkbd_cngetc(kbd, type, data);
	DPRINTFN(0,("ukbd_cngetc: return 0x%02x\n", *data));
}

void
ukbd_cnpollc(void *v, int on)
{
	struct ukbd_softc *sc = v;

	DPRINTFN(2,("ukbd_cnpollc: sc=%p on=%d\n", v, on));

	if (on)
		sc->sc_spl = splusb();
	else
		splx(sc->sc_spl);
	usbd_set_polling(sc->sc_hdev.sc_udev, on);
}

void
ukbd_cnbell(void *v, u_int pitch, u_int period, u_int volume)
{
	hidkbd_bell(pitch, period, volume, 1);
}

#ifdef DDB
void
ukbd_debugger(void *v)
{
	struct ukbd_softc *sc = v;

	/*
	 * For the console keyboard we can't deliver CTL-ALT-ESC
	 * from the interrupt routine.  Doing so would start
	 * polling from inside the interrupt routine and that
	 * loses bigtime.
	 */
	timeout_add(&sc->sc_ddb, 1);
}

void
ukbd_db_enter(void *xsc)
{
	db_enter();
}
#endif

int
ukbd_cnattach(void)
{
	struct ukbd_softc *sc;
	int i;

	/*
	 * XXX USB requires too many parts of the kernel to be running
	 * XXX in order to work, so we can't do much for the console
	 * XXX keyboard until autconfiguration has run its course.
	 */
	hidkbd_is_console = 1;

	if (!cold) {
		/*
		 * When switching console dynamically force all USB keyboards
		 * to re-attach and possibly became the 'console' keyboard.
		 */
		for (i = 0; i < ukbd_cd.cd_ndevs; i++) {
			if ((sc = ukbd_cd.cd_devs[i]) != NULL) {
				usb_needs_reattach(sc->sc_hdev.sc_udev);
				break;
			}
		}
	}

	return (0);
}

uint8_t
ukbd_translate(const struct ukbd_translation *table, size_t tsize,
    uint8_t keycode)
{
	for (; tsize != 0; table++, tsize--)
		if (table->original == keycode)
			return table->translation;
	return 0;
}

void
ukbd_apple_translate(void *vsc, uint8_t *ibuf, u_int ilen,
    const struct ukbd_translation* trans, u_int tlen)
{
	struct ukbd_softc *sc = vsc;
	struct hidkbd *kbd = &sc->sc_kbd;
	uint8_t *pos, *spos, *epos, xlat;

	spos = ibuf + kbd->sc_keycodeloc.pos / 8;
	epos = spos + kbd->sc_nkeycode;

	for (pos = spos; pos != epos; pos++) {
		xlat = ukbd_translate(trans, tlen, *pos);
		if (xlat != 0)
			*pos = xlat;
	}
}

void
ukbd_apple_munge(void *vsc, uint8_t *ibuf, u_int ilen)
{
	struct ukbd_softc *sc = vsc;

	static const struct ukbd_translation apple_fn_trans[] = {
		{ 40, 73 },	/* return -> insert */
		{ 42, 76 },	/* backspace -> delete */
#ifdef notyet
		{ 58, 0 },	/* F1 -> screen brightness down */
		{ 59, 0 },	/* F2 -> screen brightness up */
		{ 60, 0 },	/* F3 */
		{ 61, 0 },	/* F4 */
		{ 62, 0 },	/* F5 -> keyboard backlight down */
		{ 63, 0 },	/* F6 -> keyboard backlight up */
		{ 64, 0 },	/* F7 -> audio back */
		{ 65, 0 },	/* F8 -> audio pause/play */
		{ 66, 0 },	/* F9 -> audio next */
#endif
#ifdef __macppc__
		{ 60, 127 },	/* F3 -> audio mute */
		{ 61, 129 },	/* F4 -> audio lower */
		{ 62, 128 },	/* F5 -> audio raise */
#else
		{ 67, 127 },	/* F10 -> audio mute */
		{ 68, 129 },	/* F11 -> audio lower */
		{ 69, 128 },	/* F12 -> audio raise */
#endif
		{ 79, 77 },	/* right -> end */
		{ 80, 74 },	/* left -> home */
		{ 81, 78 },	/* down -> page down */
		{ 82, 75 }	/* up -> page up */
	};

	if (!hid_get_data(ibuf, ilen, &sc->sc_apple_fn))
		return;

	ukbd_apple_translate(vsc, ibuf, ilen, apple_fn_trans,
	    nitems(apple_fn_trans));
}

void
ukbd_apple_mba_munge(void *vsc, uint8_t *ibuf, u_int ilen)
{
	struct ukbd_softc *sc = vsc;

	static const struct ukbd_translation apple_fn_trans[] = {
		{ 40, 73 },	/* return -> insert */
		{ 42, 76 },	/* backspace -> delete */
#ifdef notyet
		{ 58, 0 },	/* F1 -> screen brightness down */
		{ 59, 0 },	/* F2 -> screen brightness up */
		{ 60, 0 },	/* F3 */
		{ 61, 0 },	/* F4 */
		{ 62, 0 },	/* F5 */
		{ 63, 0 },	/* F6 -> audio back */
		{ 64, 0 },	/* F7 -> audio pause/play */
		{ 65, 0 },	/* F8 -> audio next */
#endif
		{ 66, 127 },	/* F9 -> audio mute */
		{ 67, 129 },	/* F10 -> audio lower */
		{ 68, 128 },	/* F11 -> audio raise */
#ifdef notyet
		{ 69, 0 },	/* F12 -> eject */
#endif
		{ 79, 77 },	/* right -> end */
		{ 80, 74 },	/* left -> home */
		{ 81, 78 },	/* down -> page down */
		{ 82, 75 }	/* up -> page up */
	};

	if (!hid_get_data(ibuf, ilen, &sc->sc_apple_fn))
		return;

	ukbd_apple_translate(vsc, ibuf, ilen, apple_fn_trans,
	    nitems(apple_fn_trans));
}

void
ukbd_apple_iso_munge(void *vsc, uint8_t *ibuf, u_int ilen)
{
	static const struct ukbd_translation apple_iso_trans[] = {
		{ 53, 100 },	/* less -> grave */
		{ 100, 53 },
	};

	ukbd_apple_translate(vsc, ibuf, ilen, apple_iso_trans,
	    nitems(apple_iso_trans));
	ukbd_apple_munge(vsc, ibuf, ilen);
}

void
ukbd_apple_iso_mba_munge(void *vsc, uint8_t *ibuf, u_int ilen)
{
	static const struct ukbd_translation apple_iso_trans[] = {
		{ 53, 100 },	/* less -> grave */
		{ 100, 53 },
	};

	ukbd_apple_translate(vsc, ibuf, ilen, apple_iso_trans,
	    nitems(apple_iso_trans));
	ukbd_apple_mba_munge(vsc, ibuf, ilen);
}

#ifdef __loongson__
/*
 * Software Fn- translation for Gdium Liberty keyboard.
 */
#define	GDIUM_FN_CODE	0x82
void
ukbd_gdium_munge(void *vsc, uint8_t *ibuf, u_int ilen)
{
	struct ukbd_softc *sc = vsc;
	struct hidkbd *kbd = &sc->sc_kbd;
	uint8_t *pos, *spos, *epos, xlat;
	int fn;

	static const struct ukbd_translation gdium_fn_trans[] = {
#ifdef notyet
		{ 58, 0 },	/* F1 -> toggle camera */
		{ 59, 0 },	/* F2 -> toggle wireless */
#endif
		{ 60, 127 },	/* F3 -> audio mute */
		{ 61, 128 },	/* F4 -> audio raise */
		{ 62, 129 },	/* F5 -> audio lower */
#ifdef notyet
		{ 63, 0 },	/* F6 -> toggle ext. video */
		{ 64, 0 },	/* F7 -> toggle mouse */
		{ 65, 0 },	/* F8 -> brightness up */
		{ 66, 0 },	/* F9 -> brightness down */
		{ 67, 0 },	/* F10 -> suspend */
		{ 68, 0 },	/* F11 -> user1 */
		{ 69, 0 },	/* F12 -> user2 */
		{ 70, 0 },	/* print screen -> sysrq */
#endif
		{ 76, 71 },	/* delete -> scroll lock */
		{ 81, 78 },	/* down -> page down */
		{ 82, 75 }	/* up -> page up */
	};

	spos = ibuf + kbd->sc_keycodeloc.pos / 8;
	epos = spos + kbd->sc_nkeycode;

	/*
	 * Check for Fn key being down and remove it from the report.
	 */

	fn = 0;
	for (pos = spos; pos != epos; pos++)
		if (*pos == GDIUM_FN_CODE) {
			fn = 1;
			*pos = 0;
			break;
		}

	/*
	 * Rewrite keycodes on the fly to perform Fn-key translation.
	 * Keycodes without a translation are passed unaffected.
	 */

	if (fn != 0)
		for (pos = spos; pos != epos; pos++) {
			xlat = ukbd_translate(gdium_fn_trans,
			    nitems(gdium_fn_trans), *pos);
			if (xlat != 0)
				*pos = xlat;
		}

}
#endif
@


1.77
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.76 2016/01/12 19:16:21 jcs Exp $	*/
a132 1

a133 1

d135 1
d137 3
a139 1
	void			(*sc_munge)(void *, uint8_t *, u_int);
d145 1
d151 3
d158 1
d331 4
d460 22
@


1.76
log
@properly initialize quirks before sending them to hid layer, broken
during hid abstraction

problem noticed and fix tested by abieber
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.75 2016/01/09 04:14:42 jcs Exp $	*/
d60 2
d66 1
d454 3
d463 14
@


1.75
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.74 2016/01/08 15:54:14 jcs Exp $	*/
d210 1
a210 1
	u_int32_t quirks, qflags;
@


1.74
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.73 2015/12/25 20:28:48 jung Exp $	*/
a74 1
#include <dev/hid/hid.h>
@


1.73
log
@enable iso keyboard munge fix for macbookair6,2

ok jcs
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.72 2015/12/09 09:23:21 jung Exp $	*/
a67 1
#include <dev/usb/hid.h>
d75 2
a76 1
#include <dev/usb/hidkbdsc.h>
d211 1
a211 1
	u_int32_t qflags;
d236 4
a239 1
	qflags = usbd_get_quirks(sc->sc_hdev.sc_udev)->uq_flags;
@


1.72
log
@cleanup macbook air iso keyboard support
also some KNF and whitespace cleanup while here

initial diff from William Orr with some tweaks by me

ok jcs mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.71 2015/03/14 03:38:50 jsg Exp $	*/
d248 1
@


1.71
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.70 2015/01/19 20:16:10 miod Exp $	*/
d161 7
a167 7
int ukbd_match(struct device *, void *, void *); 
void ukbd_attach(struct device *, struct device *, void *); 
int ukbd_detach(struct device *, int); 

struct cfdriver ukbd_cd = { 
	NULL, "ukbd", DV_DULL 
}; 
d184 3
d247 1
d250 2
a251 1
				case USB_PRODUCT_APPLE_WELLSPRING4A_ANSI:
d253 4
a256 1
				case USB_PRODUCT_APPLE_WELLSPRING4A_JIS:
a257 1
				case USB_PRODUCT_APPLE_WELLSPRING4_ISO:
d259 2
a260 3
				case USB_PRODUCT_APPLE_WELLSPRING_ANSI:
				case USB_PRODUCT_APPLE_WELLSPRING_ISO:
				case USB_PRODUCT_APPLE_WELLSPRING_JIS:
d440 1
a440 1
ukbd_cnbell(void *v, u_int pitch, u_int period, u_int volume) 
d443 1
a443 1
}	
a447 1

d468 2
a469 1
ukbd_apple_munge(void *vsc, uint8_t *ibuf, u_int ilen)
d475 15
d522 2
a523 9
	spos = ibuf + kbd->sc_keycodeloc.pos / 8;
	epos = spos + kbd->sc_nkeycode;

	for (pos = spos; pos != epos; pos++) {
		xlat = ukbd_translate(apple_fn_trans,
		    nitems(apple_fn_trans), *pos);
		if (xlat != 0)
			*pos = xlat;
	}
a529 2
	struct hidkbd *kbd = &sc->sc_kbd;
	uint8_t *pos, *spos, *epos, xlat;
d559 2
a560 9
	spos = ibuf + kbd->sc_keycodeloc.pos / 8;
	epos = spos + kbd->sc_nkeycode;

	for (pos = spos; pos != epos; pos++) {
		xlat = ukbd_translate(apple_fn_trans,
		    nitems(apple_fn_trans), *pos);
		if (xlat != 0)
			*pos = xlat;
	}
a565 4
	struct ukbd_softc *sc = vsc;
	struct hidkbd *kbd = &sc->sc_kbd;
	uint8_t *pos, *spos, *epos, xlat;

d571 4
a574 2
	spos = ibuf + kbd->sc_keycodeloc.pos / 8;
	epos = spos + kbd->sc_nkeycode;
d576 7
a582 6
	for (pos = spos; pos != epos; pos++) {
		xlat = ukbd_translate(apple_iso_trans,
		    nitems(apple_iso_trans), *pos);
		if (xlat != 0)
			*pos = xlat;
	}
d584 3
a586 1
	ukbd_apple_munge(vsc, ibuf, ilen);
@


1.70
log
@`wellspring' Apple keyboards found on Macbook Air need slightly different
processing for Fn-key chords. From William Orr <will@@worrbase.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.69 2014/12/11 18:39:27 mpi Exp $	*/
a76 1
#include <dev/usb/hidkbdvar.h>
@


1.69
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.68 2014/08/21 14:52:55 mpi Exp $	*/
d183 1
a238 6
		int iso = 0;

		if ((uha->uaa->product == USB_PRODUCT_APPLE_FOUNTAIN_ISO) ||
 		    (uha->uaa->product == USB_PRODUCT_APPLE_GEYSER_ISO))
 		    	iso = 1;

d242 3
a244 1
				if (iso)
d246 13
a258 1
				else
d260 2
d492 46
@


1.68
log
@Now that DVACT_DEACTIVATE is propagated to the children of a device when
a driver does not implement a specific *_activate() handler and that our
USB stack sets the dying flag before detaching a device, these specific
handlers can die.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.67 2014/05/12 09:50:44 mpi Exp $	*/
d366 2
a367 2
		uhidev_set_report_async(&sc->sc_hdev, UHID_OUTPUT_REPORT,
		    sc->sc_hdev.sc_report_id, &res, 1);
@


1.67
log
@Backport FreeBSD's HID parser in order to properly parse `moderm'
input device descriptors, notably if they include an Item with an
Usage array (Min-Max range) and others single Usage elements.

Tested by many, thanks!  ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.66 2014/04/27 13:32:04 mpi Exp $	*/
a164 1
int ukbd_activate(struct device *, int); 
d170 2
a171 6
const struct cfattach ukbd_ca = { 
	sizeof(struct ukbd_softc), 
	ukbd_match, 
	ukbd_attach, 
	ukbd_detach, 
	ukbd_activate, 
a302 16
}

int
ukbd_activate(struct device *self, int act)
{
	struct ukbd_softc *sc = (struct ukbd_softc *)self;
	struct hidkbd *kbd = &sc->sc_kbd;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (kbd->sc_wskbddev != NULL)
			rv = config_deactivate(kbd->sc_wskbddev);
		break;
	}
	return (rv);
@


1.66
log
@Do not let the bluetooth HID device, present in Apple machines with USB,
grab the console.

This makes ddb(4) usable with any simple wired USB keyboard on G3/G4
machines that do not have adb(4) input devices, on G5s and certainly on
some MacBooks too.

ok andre@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.65 2014/04/24 09:40:28 mpi Exp $	*/
d509 1
a509 1
	if (!hid_get_data(ibuf, &sc->sc_apple_fn))
@


1.65
log
@Change the usbd_*_report() family of functions to take a usbd_device
and a infaceno argument instead of an iface pointer.  While here,
remove some unused functions and inlined usbd_read_report_desc since
it is used only once.

This is part of plumbing required to convert the various USB HID devices
to handle multiples report IDs.

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.64 2014/04/15 09:14:27 mpi Exp $	*/
d215 1
d230 8
d239 1
a239 1
	if (hidkbd_attach(self, kbd, 1, qflags, repid, desc, dlen) != 0)
@


1.64
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.63 2014/01/26 17:48:08 miod Exp $	*/
d255 4
a258 1
		hid = usbd_get_hid_descriptor(uha->uaa->iface);
@


1.63
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.62 2013/11/15 08:17:44 pirofti Exp $	*/
d376 1
a376 1
		    &res, 1);
@


1.62
log
@Clean-up the HID environment.


This set of drivers were very very dirty.

i/ Clean-up the match/attach multi-casting hackjob
	- stop casting aux to every attach arg in existance
	- be consistent about casting it only to uhidev_attach_arg
	- fetch the usb_attach_arg from above where needed

ii/ Sort out the activate routines
	- leave the deactivation to the parent (uhidev(4))
	- ditch the sc_dying flag in favour of usbd_is_dying()

iii/ Get closer to keeping all the usb hid information in the uhidev
     structure (one uhidev per reportID)
	- store the usbd_device in the uhidev
	- use it consistently instead of always peaking at the parent's
 	  soft state

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.61 2013/11/13 13:48:08 pirofti Exp $	*/
d268 1
a268 1
		layout = KB_US;
@


1.61
log
@Polling is done per controller not per interface.

The controllers are linked through device->bus so the iface is redundant.

So fixing usbd_dopoll() to take the device as argument and making
usbd_interface2device_handle() private (for now) inside usbdi_util.

Tested and okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.60 2013/06/26 07:53:20 mpi Exp $	*/
a134 2
	u_char			sc_dying;

d194 1
a194 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d211 1
a211 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d220 1
d229 1
a229 1
	qflags = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d292 1
a292 1
	usbd_delay_ms(uha->parent->sc_udev, 400);
a308 1
		sc->sc_dying = 1;
d350 1
a350 1
	if (on && sc->sc_dying)
d371 1
a371 1
	if (sc->sc_dying)
d412 1
a412 1
		usbd_dopoll(sc->sc_hdev.sc_parent->sc_udev);
d429 1
a429 1
	usbd_set_polling(sc->sc_hdev.sc_parent->sc_udev, on);
@


1.60
log
@Flash the LEDs only if the output report size is non null.

This prevent some Logitech Mice, at least G500 and G9x, that
contain various HID devices including a keyboard without LEDs
to keep disconnecting right after being attached.

Problem reported by abieber@@ and Damien Couderc, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.59 2013/04/15 09:23:02 mglocker Exp $	*/
d416 1
a416 1
		usbd_dopoll(sc->sc_hdev.sc_parent->sc_iface);
a425 1
	struct usbd_device *dev;
a428 1
	usbd_interface2device_handle(sc->sc_hdev.sc_parent->sc_iface, &dev);
d433 1
a433 1
	usbd_set_polling(dev, on);
@


1.59
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.58 2012/07/13 12:33:08 shadchin Exp $	*/
d129 2
d378 1
a378 1
	if (hidkbd_set_leds(kbd, leds, &res) != 0)
@


1.58
log
@Add support compose LED on a usb keyboard

ok mpi@@, from Alexander Polakov <polachok at gmail dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.57 2012/01/29 11:04:19 mpi Exp $	*/
d214 1
a214 1
	usb_hid_descriptor_t *hid;
d424 1
a424 1
	usbd_device_handle dev;
@


1.57
log
@Swap the keycodes of the two swapped keys of Apple ISO keyboards.
This fix the US layout on ISO keyboards and the swapped keys issue under X11.

ok miod@@, shadchin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.56 2011/12/04 15:09:35 mpi Exp $	*/
d291 2
a292 1
	ukbd_set_leds(sc, WSKBD_LED_SCROLL | WSKBD_LED_NUM | WSKBD_LED_CAPS);
@


1.56
log
@Add support for Apple fn keys

based on a diff from jcs@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.55 2011/07/03 15:47:17 matthew Exp $	*/
d188 1
d235 6
d243 6
a248 2
			if (qflags & HIO_VARIABLE)
				sc->sc_munge = ukbd_apple_munge;
d512 25
@


1.55
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.54 2010/08/29 15:28:11 miod Exp $	*/
d135 2
d187 1
d233 8
d451 50
@


1.54
log
@Translation code for Fn-key sequences on the Gdium Liberty internal keyboard,
which reports Fn as a regular key.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.53 2010/08/02 23:17:34 miod Exp $	*/
a283 3
	case DVACT_ACTIVATE:
		break;

@


1.53
log
@Handle USB_GET_REPORT, USB_GET_REPORT_DESC, USB_GET_REPORT_ID and
USB_SET_REPORT ioctls in ukbd and ums.
This allows usbhidctl to be used on these devices e.g. to dump the report
descriptor of troublesome models.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.52 2010/07/31 16:04:50 miod Exp $	*/
d5 15
d128 8
a135 4
	struct uhidev	sc_hdev;
	struct hidkbd	sc_kbd;
	u_char		sc_dying;
	int		sc_spl;
d177 10
d197 1
a197 1
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
d253 6
d318 3
a320 1
	if (kbd->sc_enabled != 0)
d322 1
d434 77
@


1.52
log
@Factorization of the bluetooth and usb hid input driver logic, to reduce code
duplication and divergence.
Thanks to mlarkin@@ for bluetooth devices tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.51 2010/02/22 17:24:20 miod Exp $	*/
d183 1
a183 1
	int dlen;
d192 5
d198 1
a198 1
	if (hidkbd_attach(self, kbd, 1, qflags, uha->reportid, desc, dlen) != 0)
d328 1
d338 5
a342 1
		return hidkbd_ioctl(kbd, cmd, data, flag, p);
@


1.51
log
@Undo 1.48 and 1.49 for now, and go back to the drawing board; PR #6320
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.50 2009/11/25 13:36:53 miod Exp $	*/
a43 6
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/poll.h>
d61 3
a72 56
#define MAXKEYCODE 6
#define MAXMOD 8		/* max 32 */

struct ukbd_data {
	u_int32_t	modifiers;
	u_int8_t	keycode[MAXKEYCODE];
};

#define PRESS    0x000
#define RELEASE  0x100
#define CODEMASK 0x0ff

#if defined(WSDISPLAY_COMPAT_RAWKBD)
#define NN 0			/* no translation */
/*
 * Translate USB keycodes to US keyboard XT scancodes.
 * Scancodes >= 0x80 represent EXTENDED keycodes.
 *
 * See http://www.microsoft.com/whdc/device/input/Scancode.mspx
 */
const u_int8_t ukbd_trtab[256] = {
      NN,   NN,   NN,   NN, 0x1e, 0x30, 0x2e, 0x20, /* 00 - 07 */
    0x12, 0x21, 0x22, 0x23, 0x17, 0x24, 0x25, 0x26, /* 08 - 0f */
    0x32, 0x31, 0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, /* 10 - 17 */
    0x16, 0x2f, 0x11, 0x2d, 0x15, 0x2c, 0x02, 0x03, /* 18 - 1f */
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, /* 20 - 27 */
    0x1c, 0x01, 0x0e, 0x0f, 0x39, 0x0c, 0x0d, 0x1a, /* 28 - 2f */
    0x1b, 0x2b, 0x2b, 0x27, 0x28, 0x29, 0x33, 0x34, /* 30 - 37 */
    0x35, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, /* 38 - 3f */
    0x41, 0x42, 0x43, 0x44, 0x57, 0x58, 0xaa, 0x46, /* 40 - 47 */
    0x7f, 0xd2, 0xc7, 0xc9, 0xd3, 0xcf, 0xd1, 0xcd, /* 48 - 4f */
    0xcb, 0xd0, 0xc8, 0x45, 0xb5, 0x37, 0x4a, 0x4e, /* 50 - 57 */
    0x9c, 0x4f, 0x50, 0x51, 0x4b, 0x4c, 0x4d, 0x47, /* 58 - 5f */
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd, 0x84, 0x59, /* 60 - 67 */
    0x5d, 0x5e, 0x5f,   NN,   NN,   NN,   NN,   NN, /* 68 - 6f */
      NN,   NN,   NN,   NN, 0x97,   NN, 0x93, 0x95, /* 70 - 77 */
    0x91, 0x92, 0x94, 0x9a, 0x96, 0x98, 0x99, 0xa0, /* 78 - 7f */
    0xb0, 0xae,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
    0x70, 0x7d, 0x79, 0x7b, 0x5c,   NN,   NN,   NN, /* 88 - 8f */
      NN,   NN, 0x78, 0x77, 0x76,   NN,   NN,   NN, /* 90 - 97 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 98 - 9f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a0 - a7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a8 - af */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b0 - b7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b8 - bf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c0 - c7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c8 - cf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d0 - d7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d8 - df */
    0x1d, 0x2a, 0x38, 0xdb, 0x9d, 0x36, 0xb8, 0xdc, /* e0 - e7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* e8 - ef */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f0 - f7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f8 - ff */
};
#endif /* defined(WSDISPLAY_COMPAT_RAWKBD) */

a111 4
#define KEY_ERROR 0x01

#define MAXKEYS (MAXMOD+2*MAXKEYCODE)

d113 4
a116 44
	struct uhidev sc_hdev;

	struct ukbd_data sc_ndata;
	struct ukbd_data sc_odata;
	struct hid_location sc_modloc[MAXMOD];
	u_int sc_nmod;
	struct {
		u_int32_t mask;
		u_int8_t key;
	} sc_mods[MAXMOD];

	struct hid_location sc_keycodeloc;
	u_int sc_nkeycode;

	char sc_enabled;

	int sc_console_keyboard;	/* we are the console keyboard */

	char sc_debounce;		/* for quirk handling */
	struct timeout sc_delay;	/* for quirk handling */
	struct ukbd_data sc_data;	/* for quirk handling */

	struct hid_location sc_numloc;
	struct hid_location sc_capsloc;
	struct hid_location sc_scroloc;
	int sc_leds;

	struct timeout sc_rawrepeat_ch;

	struct device *sc_wskbddev;
#if defined(WSDISPLAY_COMPAT_RAWKBD)
#define REP_DELAY1 400
#define REP_DELAYN 100
	int sc_rawkbd;
	int sc_nrep;
	char sc_rep[MAXKEYS];
#endif /* defined(WSDISPLAY_COMPAT_RAWKBD) */

	int sc_spl;
	int sc_polling;
	int sc_npollchar;
	u_int16_t sc_pollchars[MAXKEYS];

	u_char sc_dying;
a118 33
#ifdef UKBD_DEBUG
#define UKBDTRACESIZE 64
struct ukbdtraceinfo {
	int unit;
	struct timeval tv;
	struct ukbd_data ud;
};
struct ukbdtraceinfo ukbdtracedata[UKBDTRACESIZE];
int ukbdtraceindex = 0;
int ukbdtrace = 0;
void ukbdtracedump(void);
void
ukbdtracedump(void)
{
	int i;
	for (i = 0; i < UKBDTRACESIZE; i++) {
		struct ukbdtraceinfo *p =
		    &ukbdtracedata[(i+ukbdtraceindex)%UKBDTRACESIZE];
		printf("%lu.%06lu: mod=0x%02x key0=0x%02x key1=0x%02x "
		       "key2=0x%02x key3=0x%02x\n",
		       p->tv.tv_sec, p->tv.tv_usec,
		       p->ud.modifiers, p->ud.keycode[0], p->ud.keycode[1],
		       p->ud.keycode[2], p->ud.keycode[3]);
	}
}
#endif

#define	UKBDUNIT(dev)	(minor(dev))
#define	UKBD_CHUNK	128	/* chunk size for read */
#define	UKBD_BSIZE	1020	/* buffer size */

int	ukbd_is_console;

a128 7
const char *ukbd_parse_desc(struct ukbd_softc *sc);

void	(*ukbd_bell_fn)(void *, u_int, u_int, u_int, int);
void	*ukbd_bell_fn_arg;

void	ukbd_bell(u_int, u_int, u_int, int);

a129 2
void	ukbd_decode(struct ukbd_softc *sc, struct ukbd_data *ud);
void	ukbd_delayed_decode(void *addr);
a132 1

a133 3
#ifdef WSDISPLAY_COMPAT_RAWKBD
void	ukbd_rawrepeat(void *v);
#endif
a140 6
extern const struct wscons_keydesc ukbd_keydesctab[];

struct wskbd_mapdata ukbd_keymapdata = {
	ukbd_keydesctab
};

d178 1
d183 2
a184 1
	const char *parseerr;
a185 1
	struct wskbddev_attach_args a;
d191 3
a193 4
	parseerr = ukbd_parse_desc(sc);
	if (parseerr != NULL) {
		printf("\n%s: attach failed, %s\n",
		       sc->sc_hdev.sc_dev.dv_xname, parseerr);
a194 22
	}

	hid = usbd_get_hid_descriptor(uha->uaa->iface);

#ifdef DIAGNOSTIC
	printf(": %d modifier keys, %d key codes",
	    sc->sc_nmod, sc->sc_nkeycode);
#endif

	qflags = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
	sc->sc_debounce = (qflags & UQ_SPUR_BUT_UP) != 0;

	/*
	 * Remember if we're the console keyboard.
	 *
	 * XXX This always picks the first keyboard on the
	 * first USB bus, but what else can we really do?
	 */
	if ((sc->sc_console_keyboard = ukbd_is_console) != 0) {
		/* Don't let any other keyboard have it. */
		ukbd_is_console = 0;
	}
d200 2
a215 1
	ukbd_keymapdata.layout = layout;
d219 3
a221 1
	if (sc->sc_console_keyboard) {
d223 1
a227 12
	a.console = sc->sc_console_keyboard;

	a.keymap = &ukbd_keymapdata;

	a.accessops = &ukbd_accessops;
	a.accesscookie = sc;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	timeout_set(&sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
#endif
	timeout_set(&sc->sc_delay, ukbd_delayed_decode, sc);

d233 1
a233 26
	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);
}

int
ukbd_enable(void *v, int on)
{
	struct ukbd_softc *sc = v;

	if (on && sc->sc_dying)
		return (EIO);

	/* Should only be called to change state */
	if (sc->sc_enabled == on) {
		DPRINTF(("ukbd_enable: %s: bad call on=%d\n",
			 sc->sc_hdev.sc_dev.dv_xname, on));
		return (EBUSY);
	}

	DPRINTF(("ukbd_enable: sc=%p on=%d\n", sc, on));
	sc->sc_enabled = on;
	if (on) {
		return (uhidev_open(&sc->sc_hdev));
	} else {
		uhidev_close(&sc->sc_hdev);
		return (0);
	}
d240 1
d248 2
a249 2
		if (sc->sc_wskbddev != NULL)
			rv = config_deactivate(sc->sc_wskbddev);
d260 2
a261 1
	int rv = 0;
d263 1
a263 30
	DPRINTF(("ukbd_detach: sc=%p flags=%d\n", sc, flags));

	if (sc->sc_console_keyboard) {
#if 0
		/*
		 * XXX Should probably disconnect our consops,
		 * XXX and either notify some other keyboard that
		 * XXX it can now be the console, or if there aren't
		 * XXX any more USB keyboards, set ukbd_is_console
		 * XXX back to 1 so that the next USB keyboard attached
		 * XXX to the system will get it.
		 */
		panic("ukbd_detach: console keyboard");
#else
		/*
		 * Disconnect our consops and set ukbd_is_console
		 * back to 1 so that the next USB keyboard attached
		 * to the system will get it.
		 * XXX Should notify some other keyboard that it can be
		 * XXX console, if there are any other keyboards.
		 */
		printf("%s: was console keyboard\n",
		       sc->sc_hdev.sc_dev.dv_xname);
		wskbd_cndetach();
		ukbd_is_console = 1;
#endif
	}
	/* No need to do reference counting of ukbd, wskbd has all the goo. */
	if (sc->sc_wskbddev != NULL)
		rv = config_detach(sc->sc_wskbddev, flags);
d276 1
a276 2
	struct ukbd_data *ud = &sc->sc_ndata;
	int i;
d278 2
a279 41
#ifdef UKBD_DEBUG
	if (ukbddebug > 5) {
		printf("ukbd_intr: data");
		for (i = 0; i < len; i++)
			printf(" 0x%02x", ((u_char *)ibuf)[i]);
		printf("\n");
	}
#endif

	ud->modifiers = 0;
	for (i = 0; i < sc->sc_nmod; i++)
		if (hid_get_data(ibuf, &sc->sc_modloc[i]))
			ud->modifiers |= sc->sc_mods[i].mask;
	memcpy(ud->keycode, (char *)ibuf + sc->sc_keycodeloc.pos / 8,
	       sc->sc_nkeycode);

	if (sc->sc_debounce && !sc->sc_polling) {
		/*
		 * Some keyboards have a peculiar quirk.  They sometimes
		 * generate a key up followed by a key down for the same
		 * key after about 10 ms.
		 * We avoid this bug by holding off decoding for 20 ms.
		 */
		sc->sc_data = *ud;
		timeout_add_msec(&sc->sc_delay, 20);
#ifdef DDB
	} else if (sc->sc_console_keyboard && !sc->sc_polling) {
		/*
		 * For the console keyboard we can't deliver CTL-ALT-ESC
		 * from the interrupt routine.  Doing so would start
		 * polling from inside the interrupt routine and that
		 * loses bigtime.
		 */
		/* if (!timeout_pending(&sc->sc_delay)) */ {
			sc->sc_data = *ud;
			timeout_add(&sc->sc_delay, 1);
		}
#endif
	} else {
		ukbd_decode(sc, ud);
	}
d282 2
a283 2
void
ukbd_delayed_decode(void *addr)
d285 3
a287 1
	struct ukbd_softc *sc = addr;
d289 2
a290 2
	ukbd_decode(sc, &sc->sc_data);
}
d292 2
a293 9
void
ukbd_decode(struct ukbd_softc *sc, struct ukbd_data *ud)
{
	int mod, omod;
	u_int16_t ibuf[MAXKEYS];	/* chars events */
	int s;
	int nkeys, i, j;
	int key;
#define ADDKEY(c) ibuf[nkeys++] = (c)
d295 5
a299 131
#ifdef UKBD_DEBUG
	/*
	 * Keep a trace of the last events.  Using printf changes the
	 * timing, so this can be useful sometimes.
	 */
	if (ukbdtrace) {
		struct ukbdtraceinfo *p = &ukbdtracedata[ukbdtraceindex];
		p->unit = sc->sc_hdev.sc_dev.dv_unit;
		microtime(&p->tv);
		p->ud = *ud;
		if (++ukbdtraceindex >= UKBDTRACESIZE)
			ukbdtraceindex = 0;
	}
	if (ukbddebug > 5) {
		struct timeval tv;
		microtime(&tv);
		DPRINTF((" at %lu.%06lu  mod=0x%02x key0=0x%02x key1=0x%02x "
			 "key2=0x%02x key3=0x%02x\n",
			 tv.tv_sec, tv.tv_usec,
			 ud->modifiers, ud->keycode[0], ud->keycode[1],
			 ud->keycode[2], ud->keycode[3]));
	}
#endif

	if (ud->keycode[0] == KEY_ERROR) {
		DPRINTF(("ukbd_intr: KEY_ERROR\n"));
		return;		/* ignore  */
	}
	nkeys = 0;
	mod = ud->modifiers;
	omod = sc->sc_odata.modifiers;
	if (mod != omod)
		for (i = 0; i < sc->sc_nmod; i++)
			if (( mod & sc->sc_mods[i].mask) !=
			    (omod & sc->sc_mods[i].mask))
				ADDKEY(sc->sc_mods[i].key |
				       (mod & sc->sc_mods[i].mask
					  ? PRESS : RELEASE));
	if (memcmp(ud->keycode, sc->sc_odata.keycode, sc->sc_nkeycode) != 0) {
		/* Check for released keys. */
		for (i = 0; i < sc->sc_nkeycode; i++) {
			key = sc->sc_odata.keycode[i];
			if (key == 0)
				continue;
			for (j = 0; j < sc->sc_nkeycode; j++)
				if (key == ud->keycode[j])
					goto rfound;
			DPRINTFN(3,("ukbd_intr: relse key=0x%02x\n", key));
			ADDKEY(key | RELEASE);
		rfound:
			;
		}

		/* Check for pressed keys. */
		for (i = 0; i < sc->sc_nkeycode; i++) {
			key = ud->keycode[i];
			if (key == 0)
				continue;
			for (j = 0; j < sc->sc_nkeycode; j++)
				if (key == sc->sc_odata.keycode[j])
					goto pfound;
			DPRINTFN(2,("ukbd_intr: press key=0x%02x\n", key));
			ADDKEY(key | PRESS);
		pfound:
			;
		}
	}
	sc->sc_odata = *ud;

	if (nkeys == 0)
		return;

	if (sc->sc_polling) {
		DPRINTFN(1,("ukbd_intr: pollchar = 0x%03x\n", ibuf[0]));
		memcpy(sc->sc_pollchars, ibuf, nkeys * sizeof(u_int16_t));
		sc->sc_npollchar = nkeys;
		return;
	}
#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (sc->sc_rawkbd) {
		u_char cbuf[MAXKEYS * 2];
		int c;
		int npress;

		for (npress = i = j = 0; i < nkeys; i++) {
			key = ibuf[i];
			c = ukbd_trtab[key & CODEMASK];
			if (c == NN)
				continue;
			if (c & 0x80)
				cbuf[j++] = 0xe0;
			cbuf[j] = c & 0x7f;
			if (key & RELEASE)
				cbuf[j] |= 0x80;
			else {
				/* remember pressed keys for autorepeat */
				if (c & 0x80)
					sc->sc_rep[npress++] = 0xe0;
				sc->sc_rep[npress++] = c & 0x7f;
			}
			DPRINTFN(1,("ukbd_intr: raw = %s0x%02x\n",
				    c & 0x80 ? "0xe0 " : "",
				    cbuf[j]));
			j++;
		}
		s = spltty();
		wskbd_rawinput(sc->sc_wskbddev, cbuf, j);
		if (npress != 0) {
			sc->sc_nrep = npress;
			timeout_add_msec(&sc->sc_rawrepeat_ch, REP_DELAY1);
		} else
			timeout_del(&sc->sc_rawrepeat_ch);

		/*
		 * Pass audio keys to wskbd_input anyway.
		 */
		for (i = 0; i < nkeys; i++) {
			key = ibuf[i];
			switch (key & CODEMASK) {
			case 127:
			case 128:
			case 129:
				wskbd_input(sc->sc_wskbddev,
				    key & RELEASE ?  WSCONS_EVENT_KEY_UP :
				      WSCONS_EVENT_KEY_DOWN, key & CODEMASK);
				break;
			}
		}
		splx(s);

		return;
a300 10
#endif

	s = spltty();
	for (i = 0; i < nkeys; i++) {
		key = ibuf[i];
		wskbd_input(sc->sc_wskbddev,
		    key&RELEASE ? WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN,
		    key&CODEMASK);
	}
	splx(s);
d307 1
a309 3
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d, sc_leds=%d\n",
		 sc, leds, sc->sc_leds));

d313 3
a315 25
	if (sc->sc_leds == leds)
		return;
	sc->sc_leds = leds;
	res = 0;
	/* XXX not really right */
	if ((leds & WSKBD_LED_SCROLL) && sc->sc_scroloc.size == 1)
		res |= 1 << sc->sc_scroloc.pos;
	if ((leds & WSKBD_LED_NUM) && sc->sc_numloc.size == 1)
		res |= 1 << sc->sc_numloc.pos;
	if ((leds & WSKBD_LED_CAPS) && sc->sc_capsloc.size == 1)
		res |= 1 << sc->sc_capsloc.pos;
	uhidev_set_report_async(&sc->sc_hdev, UHID_OUTPUT_REPORT, &res, 1);
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
void
ukbd_rawrepeat(void *v)
{
	struct ukbd_softc *sc = v;
	int s;

	s = spltty();
	wskbd_rawinput(sc->sc_wskbddev, sc->sc_rep, sc->sc_nrep);
	splx(s);
	timeout_add_msec(&sc->sc_rawrepeat_ch, REP_DELAYN);
a316 1
#endif
d322 1
d331 2
a332 33
	case WSKBDIO_GETLEDS:
		*(int *)data = sc->sc_leds;
		return (0);
	case WSKBDIO_COMPLEXBELL:
#define d ((struct wskbd_bell_data *)data)
		ukbd_bell(d->pitch, d->period, d->volume, 0);
#undef d
		return (0);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
		DPRINTF(("ukbd_ioctl: set raw = %d\n", *(int *)data));
		sc->sc_rawkbd = *(int *)data == WSKBD_RAW;
		timeout_del(&sc->sc_rawrepeat_ch);
		return (0);
#endif
	}
	return (-1);
}

void
ukbd_bell(u_int pitch, u_int period, u_int volume, int poll)
{
	if (ukbd_bell_fn != NULL)
		(*ukbd_bell_fn)(ukbd_bell_fn_arg, pitch, period,
		    volume, poll);
}

void
ukbd_hookup_bell(void (*fn)(void *, u_int, u_int, u_int, int), void *arg)
{
	if (ukbd_bell_fn == NULL) {
		ukbd_bell_fn = fn;
		ukbd_bell_fn_arg = arg;
d341 1
a341 1
	int c;
d344 2
a345 2
	sc->sc_polling = 1;
	while(sc->sc_npollchar <= 0)
d347 3
a349 8
	sc->sc_polling = 0;
	c = sc->sc_pollchars[0];
	sc->sc_npollchar--;
	memcpy(sc->sc_pollchars, sc->sc_pollchars+1,
	       sc->sc_npollchar * sizeof(u_int16_t));
	*type = c & RELEASE ? WSCONS_EVENT_KEY_UP : WSCONS_EVENT_KEY_DOWN;
	*data = c & CODEMASK;
	DPRINTFN(0,("ukbd_cngetc: return 0x%02x\n", c));
d371 1
a371 1
	ukbd_bell(pitch, period, volume, 1);
d383 1
a383 1
	ukbd_is_console = 1;
a384 61
}

const char *
ukbd_parse_desc(struct ukbd_softc *sc)
{
	struct hid_data *d;
	struct hid_item h;
	int size;
	void *desc;
	int imod;

	uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
	imod = 0;
	sc->sc_nkeycode = 0;
	d = hid_start_parse(desc, size, hid_input);
	while (hid_get_item(d, &h)) {
		/*printf("ukbd: id=%d kind=%d usage=0x%x flags=0x%x pos=%d size=%d cnt=%d\n",
		  h.report_ID, h.kind, h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count);*/
		if (h.kind != hid_input || (h.flags & HIO_CONST) ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_KEYBOARD ||
		    h.report_ID != sc->sc_hdev.sc_report_id)
			continue;
		DPRINTF(("ukbd: imod=%d usage=0x%x flags=0x%x pos=%d size=%d "
			 "cnt=%d\n", imod,
			 h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count));
		if (h.flags & HIO_VARIABLE) {
			if (h.loc.size != 1)
				return ("bad modifier size");
			/* Single item */
			if (imod < MAXMOD) {
				sc->sc_modloc[imod] = h.loc;
				sc->sc_mods[imod].mask = 1 << imod;
				sc->sc_mods[imod].key = HID_GET_USAGE(h.usage);
				imod++;
			} else
				return ("too many modifier keys");
		} else {
			/* Array */
			if (h.loc.size != 8)
				return ("key code size != 8");
			if (h.loc.count > MAXKEYCODE)
				return ("too many key codes");
			if (h.loc.pos % 8 != 0)
				return ("key codes not on byte boundary");
			if (sc->sc_nkeycode != 0)
				return ("multiple key code arrays\n");
			sc->sc_keycodeloc = h.loc;
			sc->sc_nkeycode = h.loc.count;
		}
	}
	sc->sc_nmod = imod;
	hid_end_parse(d);

	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_NUM_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_numloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_CAPS_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_capsloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_SCROLL_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_scroloc, NULL);

	return (NULL);
@


1.50
log
@Simpler logic to ignore the Naturetech keyboard babbling; discard extra
data if we already have pending data to process in the timeout handler.

help kettenis@@; commited from the Naturetech #$@@!&! machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.49 2009/11/25 11:39:45 miod Exp $	*/
d549 1
a549 1
		if (!timeout_pending(&sc->sc_delay)) {
@


1.49
log
@Ignore repeated data in ukbd_intr(), for keyboards who flood us on a regular
basis even in the absence of keyboard events; Naturetech onboard keyboard
no longer loses keystrokes.
Joint work with kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.48 2009/10/13 20:56:50 miod Exp $	*/
a531 4
	/* ignore duplicate data */
	if (memcmp(ud, &sc->sc_odata, sizeof *ud) == 0)
		return;

d549 4
a552 2
		sc->sc_data = *ud;
		timeout_add(&sc->sc_delay, 1);
@


1.48
log
@Pass audio keys to the audio layer even when the keyboard is in raw mode,
to match what pckbd does; reported by mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.47 2009/10/13 19:33:19 pirofti Exp $	*/
d195 1
a195 1
	struct timeout sc_delay;		/* for quirk handling */
d531 4
@


1.47
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.46 2009/07/31 11:01:48 blambert Exp $	*/
a681 1
		splx(s);
d687 18
@


1.46
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.45 2009/01/21 21:54:00 grange Exp $	*/
d299 1
a299 1
int ukbd_activate(struct device *, enum devact); 
d447 1
a447 1
ukbd_activate(struct device *self, enum devact act)
@


1.45
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.44 2009/01/21 18:18:33 miod Exp $	*/
d540 1
a540 1
		timeout_add(&sc->sc_delay, hz / 50);
@


1.44
log
@It turns out that Sun USB keyboards really follow the HID specification for
its country code, but I had forgotten one line in the layout table.

This now picks the correct layout for swedish and british (uk) sun keyboards.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.43 2008/06/26 05:42:18 ray Exp $	*/
d685 1
a685 2
			timeout_add(&sc->sc_rawrepeat_ch,
			    hz * REP_DELAY1 / 1000);
d738 1
a738 1
	timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000);
@


1.43
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.42 2008/06/08 20:59:29 miod Exp $	*/
d132 1
a132 1
const kbd_t ukbd_countrylayout[HCC_MAX] = {
d159 1
a170 36
#define	SUN_HCC_MIN	0x21
#define	SUN_HCC_MAX	0x3f
const kbd_t ukbd_sunlayout[1 + SUN_HCC_MAX - SUN_HCC_MIN] = {
	KB_US,	/* 021 USA */
	KB_US,	/* 022 UNIX */
	KB_FR,	/* 023 France */
	KB_DK,	/* 024 Denmark */
	KB_DE,	/* 025 Germany */
	KB_IT,	/* 026 Italy */
	KB_NL,	/* 027 The Netherlands */
	KB_NO,	/* 028 Norway */
	KB_PT,	/* 029 Portugal */
	KB_ES,	/* 02a Spain */
	KB_SV,	/* 02b Sweden */
	KB_SF,	/* 02c Switzerland/French */
	KB_SG,	/* 02d Switzerland/German */
	KB_UK,	/* 02e Great Britain */
	-1,	/* 02f Korea */
	-1,	/* 030 Taiwan */
	KB_JP,	/* 031 Japan */
	-1,	/* 032 Canada/French */
	-1,	/* 033 Hungary */
	-1,	/* 034 Poland */
	-1,	/* 035 Czech */
	-1,	/* 036 Russia */
	-1,	/* 037 Latvia */
	-1,	/* 038 Turkey-Q5 */
	-1,	/* 039 Greece */
	-1,	/* 03a Arabic */
	-1,	/* 03b Lithuania */
	-1,	/* 03c Belgium */
	-1,	/* 03d unaffected */
	-1,	/* 03e Turkey-F5 */
	-1,	/* 03f Canada/French */
};

d373 6
a378 7
	if (uha->uaa->vendor == USB_VENDOR_SUN &&
	    (uha->uaa->product == USB_PRODUCT_SUN_KEYBOARD6 ||
	     uha->uaa->product == USB_PRODUCT_SUN_KEYBOARD7)) {
		/* Sun keyboard use Sun-style layout codes */
		if (hid->bCountryCode >= SUN_HCC_MIN &&
		    hid->bCountryCode <= SUN_HCC_MAX)
			layout = ukbd_sunlayout[hid->bCountryCode - SUN_HCC_MIN];
d381 1
a381 12
			printf(", layout %d", hid->bCountryCode);
#endif
	} else {
		if (uha->uaa->vendor == USB_VENDOR_TOPRE &&
		    uha->uaa->product == USB_PRODUCT_TOPRE_HHKB) {
			/* ignore country code on purpose */
		} else {
			if (hid->bCountryCode <= HCC_MAX)
				layout = ukbd_countrylayout[hid->bCountryCode];
#ifdef DIAGNOSTIC
			if (hid->bCountryCode != 0)
				printf(", country code %d", hid->bCountryCode);
a382 1
		}
@


1.42
log
@Now that all ports behave, remove the safety code doing cnpollc behind
the scene around cngetc calls and whining loudly about it. This will save
room on floppies (-:
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.41 2008/05/19 18:09:06 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.41
log
@Add the Sun extended keys (L keys, volume keys) to the console mode layouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.40 2008/04/16 16:08:39 mk Exp $	*/
a845 6
/*
 * This is a hack to work around some broken ports that don't call
 * cnpollc() before cngetc().
 */
static int pollenter, warned;

a851 13
	int broken;

	if (pollenter == 0) {
		if (!warned) {
			printf("\n"
"This port is broken, it does not call cnpollc() before calling cngetc().\n"
"This should be fixed, but it will work anyway (for now).\n");
			warned = 1;
		}
		broken = 1;
		ukbd_cnpollc(v, 1);
	} else
		broken = 0;
a864 2
	if (broken)
		ukbd_cnpollc(v, 0);
d876 1
a876 1
	if (on) {
d878 1
a878 2
		pollenter++;
	} else {
a879 2
		pollenter--;
	}
@


1.40
log
@Use the timeout(9) API the right way:  Don't initialize the timeout
cookie all the time, and only call timeout_del if we're not going to
timeout_add right away.

Testing by johan@@, oga@@, sthen@@, and possibly some more people (thanks).

Ok krw@@, oga@@, sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.39 2008/01/24 14:50:38 robert Exp $	*/
d116 1
a116 1
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd,   NN, 0x59, /* 60 - 67 */
d119 2
a120 2
    0x91, 0x92, 0x94, 0x9a, 0x96, 0x98, 0x99,   NN, /* 78 - 7f */
      NN,   NN,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
@


1.39
log
@provide an external hook for beeper devices just like pckbd(4) does

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.38 2007/11/23 19:21:40 deraadt Exp $	*/
a737 1
		timeout_del(&sc->sc_rawrepeat_ch);
d742 2
a743 1
		}
@


1.38
log
@ukbd_rawrepeat only there if WSDISPLAY_COMPAT_RAWKBD
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.37 2007/11/23 15:43:02 mbalmer Exp $	*/
d299 1
d304 1
d309 5
d813 5
d829 17
d906 6
@


1.37
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.36 2007/06/14 10:11:16 mbalmer Exp $	*/
d456 1
d458 1
@


1.36
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.35 2007/06/12 16:26:36 mbalmer Exp $	*/
d456 2
a457 2
	timeout_set(&sc->sc_rawrepeat_ch, NULL, NULL);
	timeout_set(&sc->sc_delay, NULL, NULL);
a585 2
		timeout_del(&sc->sc_delay);
		timeout_set(&sc->sc_delay, ukbd_delayed_decode, sc);
a595 2
		timeout_del(&sc->sc_delay);
		timeout_set(&sc->sc_delay, ukbd_delayed_decode, sc);
a731 2
			timeout_del(&sc->sc_rawrepeat_ch);
			timeout_set(&sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
a784 2
	timeout_del(&sc->sc_rawrepeat_ch);
	timeout_set(&sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
@


1.35
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.34 2007/06/11 16:30:31 mbalmer Exp $	*/
d331 16
a346 1
USB_DECLARE_DRIVER(ukbd);
@


1.34
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.33 2007/06/10 14:49:01 mbalmer Exp $	*/
d478 1
a478 1
ukbd_activate(device_ptr_t self, enum devact act)
@


1.33
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.32 2007/06/10 10:15:35 mbalmer Exp $	*/
d314 1
a314 1
int	ukbd_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr );
d783 1
a783 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.32
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.31 2007/06/05 08:43:55 mbalmer Exp $	*/
d463 1
a463 1
			 USBDEVNAME(sc->sc_hdev.sc_dev), on));
d524 1
a524 1
		       USBDEVNAME(sc->sc_hdev.sc_dev));
@


1.31
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.30 2007/06/04 10:34:04 mbalmer Exp $	*/
d237 1
a237 1
	usb_callout_t sc_delay;		/* for quirk handling */
d245 1
a245 1
	usb_callout_t sc_rawrepeat_ch;
d441 2
a442 2
	usb_callout_init(sc->sc_rawrepeat_ch);
	usb_callout_init(sc->sc_delay);
d571 3
a573 1
		usb_callout(sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
d583 3
a585 1
		usb_callout(sc->sc_delay, 1, ukbd_delayed_decode, sc);
d718 1
a718 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
d721 4
a724 2
			usb_callout(sc->sc_rawrepeat_ch,
			    hz * REP_DELAY1 / 1000, ukbd_rawrepeat, sc);
d776 3
a778 2
	usb_callout(sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
	    ukbd_rawrepeat, sc);
d801 1
a801 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
@


1.30
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.29 2007/05/27 04:00:25 jsg Exp $	*/
d103 1
a103 1
Static const u_int8_t ukbd_trtab[256] = {
d295 1
a295 1
Static int	ukbd_is_console;
d297 2
a298 2
Static void	ukbd_cngetc(void *, u_int *, int *);
Static void	ukbd_cnpollc(void *, int);
d305 1
a305 1
Static const char *ukbd_parse_desc(struct ukbd_softc *sc);
d307 3
a309 3
Static void	ukbd_intr(struct uhidev *addr, void *ibuf, u_int len);
Static void	ukbd_decode(struct ukbd_softc *sc, struct ukbd_data *ud);
Static void	ukbd_delayed_decode(void *addr);
d311 2
a312 2
Static int	ukbd_enable(void *, int);
Static void	ukbd_set_leds(void *, int);
d314 1
a314 1
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr );
d316 1
a316 1
Static void	ukbd_rawrepeat(void *v);
@


1.29
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.28 2007/05/21 05:40:28 jsg Exp $	*/
a46 1
#if defined(__OpenBSD__)
a47 3
#else
#include <sys/callout.h>
#endif
@


1.28
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.27 2007/02/11 20:29:22 miod Exp $	*/
d337 2
a338 1
USB_MATCH(ukbd)
d340 1
a340 1
	USB_MATCH_START(ukbd, uaa);
d353 2
a354 1
USB_ATTACH(ukbd)
d356 2
a357 1
	USB_ATTACH_START(ukbd, sc, uaa);
d373 1
a373 1
		USB_ATTACH_ERROR_RETURN;
a453 2

	USB_ATTACH_SUCCESS_RETURN;
d500 2
a501 1
USB_DETACH(ukbd)
d503 1
a503 1
	USB_DETACH_START(ukbd, sc);
@


1.27
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.26 2007/01/13 07:43:15 miod Exp $	*/
d79 2
a80 2
#define DPRINTF(x)	do { if (ukbddebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (ukbddebug>(n)) logprintf x; } while (0)
@


1.26
log
@Ignore country code on happy hacking keyboard, it reports itself as japanse.
Spotted by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.25 2006/06/26 22:14:12 miod Exp $	*/
a76 5

#if defined(__NetBSD__)
#include "opt_wsdisplay_compat.h"
#include "opt_ddb.h"
#endif
@


1.25
log
@When attaching an USB keyboard, check the HID interface for its country code
id, and if it is non-zero, try to select the appropriate layout.
Of course, Sun USB keyboards still use the Sun layout encoding, which is
completely different, so we have to check for them.
Tested on a variety of keyboards by krw@@ matthieu@@ and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.24 2006/06/23 06:27:11 miod Exp $	*/
d411 6
a416 2
		if (hid->bCountryCode <= HCC_MAX)
			layout = ukbd_countrylayout[hid->bCountryCode];
d418 2
a419 2
		if (hid->bCountryCode != 0)
			printf(", country code %d", hid->bCountryCode);
d421 1
@


1.24
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.23 2005/11/21 18:16:44 millert Exp $	*/
d148 74
d336 2
a337 7
const struct wskbd_mapdata ukbd_keymapdata = {
	ukbd_keydesctab,
#ifdef UKBD_LAYOUT
	UKBD_LAYOUT,
#else
	KB_US,
#endif
d361 1
d364 1
d378 2
d381 2
a382 2
	printf(": %d modifier keys, %d key codes", sc->sc_nmod,
	       sc->sc_nkeycode);
a383 2
	printf("\n");

d398 30
@


1.23
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.22 2005/07/18 07:41:38 jsg Exp $	*/
d387 1
a387 1
		return (EOPNOTSUPP);
@


1.22
log
@Correct scancode mapping URL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.21 2004/11/30 21:11:41 matthieu Exp $	*/
d57 1
a57 1
#include <sys/select.h>
@


1.21
log
@Make Sun type 6 USB keyboards return extended keycodes for 'L' keys
ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.20 2004/07/08 22:18:44 deraadt Exp $	*/
d110 1
a110 1
 * See http://www.microsoft.com/HWDEV/TECH/input/Scancode.asp
@


1.20
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.19 2003/07/05 16:56:45 nate Exp $	*/
d127 2
a128 2
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 70 - 77 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 78 - 7f */
@


1.19
log
@sync with netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.18 2003/05/19 04:17:53 nate Exp $	*/
d84 2
a85 2
#define DPRINTF(x)	if (ukbddebug) logprintf x
#define DPRINTFN(n,x)	if (ukbddebug>(n)) logprintf x
@


1.18
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: ukbd.c,v 1.17 2002/07/29 20:03:05 nate Exp $	*/
/*      $NetBSD: ukbd.c,v 1.82 2002/07/11 21:14:30 augustss Exp $        */
d191 1
a387 1
		break;
a712 1
	int s;
a728 1
	s = splusb();
a738 1
	splx(s);
d753 7
a759 1
	if (on) pollenter++; else pollenter--;
@


1.17
log
@this should be a DPRINTF
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.16 2002/07/25 02:18:10 nate Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/devclass/hid1_1.pdf
@


1.16
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: ukbd.c,v 1.15 2002/05/11 08:15:24 deraadt Exp $	*/
/*      $NetBSD: ukbd.c,v 1.79 2001/12/30 19:37:43 augustss Exp $        */
d363 2
a364 4
#ifdef UKBD_DEBUG
		printf("ukbd_enable: %s: bad call on=%d\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), on);
#endif
@


1.15
log
@I HATE it when things that we fix come back from bad merges
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.14 2002/05/09 15:06:29 nate Exp $	*/
d106 1
a106 1
/* 
d214 1
a214 1
		struct ukbdtraceinfo *p = 
d278 1
a278 1
	
d294 1
a294 1
	
d305 1
a305 1
		
d364 1
a364 1
		printf("ukbd_enable: %s: bad call on=%d\n", 
d510 1
a510 1
	/* 
d542 1
a542 1
			if (( mod & sc->sc_mods[i].mask) != 
d544 2
a545 2
				ADDKEY(sc->sc_mods[i].key | 
				       (mod & sc->sc_mods[i].mask 
d561 1
a561 1
		
d609 1
a609 1
			DPRINTFN(1,("ukbd_intr: raw = %s0x%02x\n", 
d630 1
a630 1
		wskbd_input(sc->sc_wskbddev, 
d739 1
a739 1
	memcpy(sc->sc_pollchars, sc->sc_pollchars+1, 
@


1.14
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.13 2002/05/07 18:29:18 nate Exp $	*/
d363 1
a363 1
#ifdef DIAGNOSTIC
@


1.13
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: ukbd.c,v 1.11 2002/04/03 17:27:58 jason Exp $	*/
/*      $NetBSD: ukbd.c,v 1.69 2001/10/24 21:02:18 augustss Exp $        */
d69 1
d92 2
a93 5
#define NKEYCODE 6

#define NUM_LOCK 0x01
#define CAPS_LOCK 0x02
#define SCROLL_LOCK 0x04
d96 2
a97 11
	u_int8_t	modifiers;
#define MOD_CONTROL_L	0x01
#define MOD_CONTROL_R	0x10
#define MOD_SHIFT_L	0x02
#define MOD_SHIFT_R	0x20
#define MOD_ALT_L	0x04
#define MOD_ALT_R	0x40
#define MOD_WIN_L	0x08
#define MOD_WIN_R	0x80
	u_int8_t	reserved;
	u_int8_t	keycode[NKEYCODE];
a103 15
/* Translate USB bitmap to USB keycode. */
#define NMOD 8
Static const struct {
	int mask, key;
} ukbd_mods[NMOD] = {
	{ MOD_CONTROL_L, 224 },
	{ MOD_CONTROL_R, 228 },
	{ MOD_SHIFT_L,   225 },
	{ MOD_SHIFT_R,   229 },
	{ MOD_ALT_L,     226 },
	{ MOD_ALT_R,     230 },
	{ MOD_WIN_L,     227 },
	{ MOD_WIN_R,     231 },
};

d108 3
a110 1
 * Scancodes >= 128 represent EXTENDED keycodes.
d113 32
a144 32
	  NN,  NN,  NN,  NN,  30,  48,  46,  32, /* 00 - 07 */
	  18,  33,  34,  35,  23,  36,  37,  38, /* 08 - 0F */
	  50,  49,  24,  25,  16,  19,  31,  20, /* 10 - 17 */
	  22,  47,  17,  45,  21,  44,   2,   3, /* 18 - 1F */
	   4,   5,   6,   7,   8,   9,  10,  11, /* 20 - 27 */
	  28,   1,  14,  15,  57,  12,  13,  26, /* 28 - 2F */
	  27,  43,  43,  39,  40,  41,  51,  52, /* 30 - 37 */
	  53,  58,  59,  60,  61,  62,  63,  64, /* 38 - 3F */
	  65,  66,  67,  68,  87,  88, 170,  70, /* 40 - 47 */
	 127, 210, 199, 201, 211, 207, 209, 205, /* 48 - 4F */
	 203, 208, 200,  69, 181,  55,  74,  78, /* 50 - 57 */
	 156,  79,  80,  81,  75,  76,  77,  71, /* 58 - 5F */
          72,  73,  82,  83,  86, 221,  NN,  NN, /* 60 - 67 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 68 - 6F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 70 - 77 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 78 - 7F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 80 - 87 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 88 - 8F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 90 - 97 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 98 - 9F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A0 - A7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A8 - AF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B0 - B7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B8 - BF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C0 - C7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C8 - CF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D0 - D7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D8 - DF */
          29,  42,  56, 219,  157, 54,  184,220, /* E0 - E7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* E8 - EF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F0 - F7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F8 - FF */
d150 1
a150 1
#define MAXKEYS (NMOD+2*NKEYCODE)
d153 1
a153 5
	USBBASEDEVICE	sc_dev;		/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;
d157 9
d172 1
d175 3
d180 1
a180 7
#if defined(__OpenBSD__)
	struct timeout sc_delay;	/* for quirk handling */
	struct timeout sc_rawrepeat_ch;
#else
	struct callout sc_delay;	/* for quirk handling */
	struct callout sc_rawrepeat_ch;
#endif
a181 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a193 1
#endif
a233 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a237 1
#endif
d239 3
a241 1
Static void	ukbd_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d248 1
a248 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
a268 1
#endif
d275 3
a277 1
	usb_interface_descriptor_t *id;
d279 3
a281 2
	/* Check that this is a keyboard that speaks the boot protocol. */
	if (uaa->iface == NULL)
d283 2
a284 7
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL ||
	    id->bInterfaceClass != UICLASS_HID || 
	    id->bInterfaceSubClass != UISUBCLASS_BOOT ||
	    id->bInterfaceProtocol != UIPROTO_BOOT_KEYBOARD)
		return (UMATCH_NONE);
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
d290 1
a290 4
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status err;
d292 1
a292 2
	char devinfo[1024];
#if defined(__NetBSD__) || defined(__OpenBSD__)
a293 3
#else
	int i;
#endif
d295 8
a302 12
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);

	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
d305 6
a311 15
	DPRINTFN(10,("ukbd_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d313 1
a313 10
	qflags = usbd_get_quirks(uaa->device)->uq_flags;
	if ((qflags & UQ_NO_SET_PROTO) == 0) {
		err = usbd_set_protocol(iface, 0);
		DPRINTFN(5, ("ukbd_attach: protocol set\n"));
		if (err) {
			printf("%s: set protocol failed\n",
			    USBDEVNAME(sc->sc_dev));
			USB_ATTACH_ERROR_RETURN;
		}
	}
a315 5
	/* Ignore if SETIDLE fails since it is not crucial. */
	(void)usbd_set_idle(iface, 0, 0);

	sc->sc_ep_addr = ed->bEndpointAddress;

d340 2
a341 11
#if defined(__OpenBSD__)
#ifdef WSDISPLAY_COMPAT_RAWKBD
	timeout_set(&sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
#endif
	timeout_set(&sc->sc_delay, ukbd_delayed_decode, sc);
#endif

#if defined(__NetBSD__)
	callout_init(&sc->sc_rawrepeat_ch);
	callout_init(&sc->sc_delay);
#endif
d345 1
a345 1
	usbd_delay_ms(uaa->device, 400);
a347 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

a356 1
	usbd_status err;
d363 1
a363 1
#ifdef UKBD_DEBUG
d365 1
a365 1
		       USBDEVNAME(sc->sc_dev), on);
d371 1
d373 1
a373 7
		/* Set up interrupt pipe. */
		err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
			  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
			  &sc->sc_ndata, sizeof(sc->sc_ndata), ukbd_intr,
			  USBD_DEFAULT_INTERVAL);
		if (err)
			return (EIO);
d375 2
a376 4
		/* Disable interrupts. */
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
a377 3
	sc->sc_enabled = on;

	return (0);
d426 2
a427 1
		printf("%s: was console keyboard\n", USBDEVNAME(sc->sc_dev));
d437 2
a438 8
	if (sc->sc_intrpipe != NULL) {
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
	}

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d444 1
a444 4
ukbd_intr(xfer, addr, status)
	usbd_xfer_handle xfer;
	usbd_private_handle addr;
	usbd_status status;
d446 1
a446 1
	struct ukbd_softc *sc = addr;
d448 1
d450 8
a457 3
	DPRINTFN(5, ("ukbd_intr: status=%d\n", status));
	if (status == USBD_CANCELLED)
		return;
d459 6
a464 6
	if (status) {
		DPRINTF(("ukbd_intr: status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
		return;
	}
d474 2
a475 6
#if defined(__OpenBSD__)
		timeout_add(&sc->sc_delay, hz / 50);
#else
		callout_reset(&sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
#endif
#if DDB
d484 1
a484 5
#if defined(__OpenBSD__)
		timeout_add(&sc->sc_delay, 1);  /* NOT an immediate timeout */
#else
		callout_reset(&sc->sc_delay, 0, ukbd_delayed_decode, sc);
#endif
d516 1
a516 1
		p->unit = sc->sc_dev.dv_unit;
d541 5
a545 5
		for (i = 0; i < NMOD; i++)
			if (( mod & ukbd_mods[i].mask) != 
			    (omod & ukbd_mods[i].mask))
				ADDKEY(ukbd_mods[i].key | 
				       (mod & ukbd_mods[i].mask 
d547 1
a547 1
	if (memcmp(ud->keycode, sc->sc_odata.keycode, NKEYCODE) != 0) {
d549 1
a549 1
		for (i = 0; i < NKEYCODE; i++) {
d553 1
a553 1
			for (j = 0; j < NKEYCODE; j++)
d563 1
a563 1
		for (i = 0; i < NKEYCODE; i++) {
d567 1
a567 1
			for (j = 0; j < NKEYCODE; j++)
d589 1
a589 1
		char cbuf[MAXKEYS * 2];
d617 1
a617 5
#if defined(__OpenBSD__) 
		timeout_del(&sc->sc_rawrepeat_ch);
#else
		callout_stop(&sc->sc_rawrepeat_ch);
#endif
d620 1
a620 4
#if defined(__OpenBSD__)
			timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAY1/1000);
#else
			callout_reset(&sc->sc_rawrepeat_ch,
a621 1
#endif
d643 2
a644 1
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d\n", sc, leds));
d649 2
d653 8
a660 8
	if (leds & WSKBD_LED_SCROLL)
		res |= SCROLL_LOCK;
	if (leds & WSKBD_LED_NUM)
		res |= NUM_LOCK;
	if (leds & WSKBD_LED_CAPS)
		res |= CAPS_LOCK;
	res |= leds & 0xf8;
	usbd_set_report_async(sc->sc_iface, UHID_OUTPUT_REPORT, 0, &res, 1);
d673 1
a673 4
#if defined(__OpenBSD__)
	timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000);
#else
	callout_reset(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
a674 1
#endif
d679 1
a679 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d697 1
a697 5
#if defined(__OpenBSD__)
		timeout_del(&sc->sc_rawrepeat_ch);
#else
		callout_stop(&sc->sc_rawrepeat_ch);
#endif
d704 6
d717 13
d735 1
a735 1
		usbd_dopoll(sc->sc_iface);
d745 2
d757 2
a758 1
	(void)usbd_interface2device_handle(sc->sc_iface,&dev);
d773 61
@


1.12
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*      $NetBSD: ukbd.c,v 1.79 2001/12/30 19:37:43 augustss Exp $        */
a68 1
#include <dev/usb/uhidev.h>
d91 5
a95 2
#define MAXKEYCODE 6
#define MAXMOD 8		/* max 32 */
d98 11
a108 2
	u_int32_t	modifiers;
	u_int8_t	keycode[MAXKEYCODE];
d115 15
d134 1
a134 3
 * Scancodes >= 0x80 represent EXTENDED keycodes.
 *
 * See http://www.microsoft.com/HWDEV/TECH/input/Scancode.asp
d137 32
a168 32
      NN,   NN,   NN,   NN, 0x1e, 0x30, 0x2e, 0x20, /* 00 - 07 */
    0x12, 0x21, 0x22, 0x23, 0x17, 0x24, 0x25, 0x26, /* 08 - 0f */
    0x32, 0x31, 0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, /* 10 - 17 */
    0x16, 0x2f, 0x11, 0x2d, 0x15, 0x2c, 0x02, 0x03, /* 18 - 1f */
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, /* 20 - 27 */
    0x1c, 0x01, 0x0e, 0x0f, 0x39, 0x0c, 0x0d, 0x1a, /* 28 - 2f */
    0x1b, 0x2b, 0x2b, 0x27, 0x28, 0x29, 0x33, 0x34, /* 30 - 37 */
    0x35, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, /* 38 - 3f */
    0x41, 0x42, 0x43, 0x44, 0x57, 0x58, 0xaa, 0x46, /* 40 - 47 */
    0x7f, 0xd2, 0xc7, 0xc9, 0xd3, 0xcf, 0xd1, 0xcd, /* 48 - 4f */
    0xcb, 0xd0, 0xc8, 0x45, 0xb5, 0x37, 0x4a, 0x4e, /* 50 - 57 */
    0x9c, 0x4f, 0x50, 0x51, 0x4b, 0x4c, 0x4d, 0x47, /* 58 - 5f */
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd,   NN, 0x59, /* 60 - 67 */
    0x5d, 0x5e, 0x5f,   NN,   NN,   NN,   NN,   NN, /* 68 - 6f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 70 - 77 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 78 - 7f */
      NN,   NN,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
    0x70, 0x7d, 0x79, 0x7b, 0x5c,   NN,   NN,   NN, /* 88 - 8f */
      NN,   NN, 0x78, 0x77, 0x76,   NN,   NN,   NN, /* 90 - 97 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 98 - 9f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a0 - a7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a8 - af */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b0 - b7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b8 - bf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c0 - c7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c8 - cf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d0 - d7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d8 - df */
    0x1d, 0x2a, 0x38, 0xdb, 0x9d, 0x36, 0xb8, 0xdc, /* e0 - e7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* e8 - ef */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f0 - f7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f8 - ff */
d174 1
a174 1
#define MAXKEYS (MAXMOD+2*MAXKEYCODE)
d177 5
a181 1
	struct uhidev sc_hdev;
a184 9
	struct hid_location sc_modloc[MAXMOD];
	u_int sc_nmod;
	struct {
		u_int32_t mask;
		u_int8_t key;
	} sc_mods[MAXMOD];

	struct hid_location sc_keycodeloc;
	u_int sc_nkeycode;
a190 1
	usb_callout_t sc_delay;		/* for quirk handling */
a192 3
	struct hid_location sc_numloc;
	struct hid_location sc_capsloc;
	struct hid_location sc_scroloc;
d195 7
a201 1
	usb_callout_t sc_rawrepeat_ch;
d203 1
d216 1
d257 1
d262 1
d264 1
a264 3
Static const char *ukbd_parse_desc(struct ukbd_softc *sc);

Static void	ukbd_intr(struct uhidev *addr, void *ibuf, u_int len);
d271 2
a272 1
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr );
d293 1
d300 1
a300 3
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
	void *desc;
d302 8
a309 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
d311 1
a311 2

	return (UMATCH_IFACECLASS);
d317 4
a320 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d322 2
a323 1
	const char *parseerr;
d325 3
d329 12
a340 8
	sc->sc_hdev.sc_intr = ukbd_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	parseerr = ukbd_parse_desc(sc);
	if (parseerr != NULL) {
		printf("\n%s: attach failed, %s\n",
		       sc->sc_hdev.sc_dev.dv_xname, parseerr);
a342 6
		
#ifdef DIAGNOSTIC
	printf(": %d modifier keys, %d key codes", sc->sc_nmod,
	       sc->sc_nkeycode);
#endif
	printf("\n");
d344 15
d360 10
a369 1
	qflags = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d372 5
d401 11
a411 2
	usb_callout_init(sc->sc_rawrepeat_ch);
	usb_callout_init(sc->sc_delay);
d415 1
a415 1
	usbd_delay_ms(uha->parent->sc_udev, 400);
d418 3
d430 1
d437 1
a437 1
#ifdef DIAGNOSTIC
d439 1
a439 1
		       USBDEVNAME(sc->sc_hdev.sc_dev), on);
a444 1
	sc->sc_enabled = on;
d446 7
a452 1
		return (uhidev_open(&sc->sc_hdev));
d454 4
a457 2
		uhidev_close(&sc->sc_hdev);
		return (0);
d459 3
d510 1
a510 2
		printf("%s: was console keyboard\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d520 8
a527 2
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);
d533 4
a536 1
ukbd_intr(struct uhidev *addr, void *ibuf, u_int len)
d538 1
a538 1
	struct ukbd_softc *sc = (struct ukbd_softc *)addr;
a539 1
	int i;
d541 9
a549 6
#ifdef UKBD_DEBUG
	if (ukbddebug > 5) {
		printf("ukbd_intr: data");
		for (i = 0; i < len; i++)
			printf(" 0x%02x", ((u_char *)ibuf)[i]);
		printf("\n");
a550 8
#endif

	ud->modifiers = 0;
	for (i = 0; i < sc->sc_nmod; i++)
		if (hid_get_data(ibuf, &sc->sc_modloc[i]))
			ud->modifiers |= sc->sc_mods[i].mask;
	memcpy(ud->keycode, (char *)ibuf + sc->sc_keycodeloc.pos / 8,
	       sc->sc_nkeycode);
d560 6
a565 2
		usb_callout(sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
#ifdef DDB
d574 5
a578 1
		usb_callout(sc->sc_delay, 1, ukbd_delayed_decode, sc);
d610 1
a610 1
		p->unit = sc->sc_hdev.sc_dev.dv_unit;
d635 5
a639 5
		for (i = 0; i < sc->sc_nmod; i++)
			if (( mod & sc->sc_mods[i].mask) != 
			    (omod & sc->sc_mods[i].mask))
				ADDKEY(sc->sc_mods[i].key | 
				       (mod & sc->sc_mods[i].mask 
d641 1
a641 1
	if (memcmp(ud->keycode, sc->sc_odata.keycode, sc->sc_nkeycode) != 0) {
d643 1
a643 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d647 1
a647 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d657 1
a657 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d661 1
a661 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d683 1
a683 1
		u_char cbuf[MAXKEYS * 2];
d711 5
a715 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
d718 4
a721 1
			usb_callout(sc->sc_rawrepeat_ch,
d723 1
d745 1
a745 2
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d, sc_leds=%d\n",
		 sc, leds, sc->sc_leds));
a749 2
	if (sc->sc_leds == leds)
		return;
d752 8
a759 8
	/* XXX not really right */
	if ((leds & WSKBD_LED_SCROLL) && sc->sc_scroloc.size == 1)
		res |= 1 << sc->sc_scroloc.pos;
	if ((leds & WSKBD_LED_NUM) && sc->sc_numloc.size == 1)
		res |= 1 << sc->sc_numloc.pos;
	if ((leds & WSKBD_LED_CAPS) && sc->sc_capsloc.size == 1)
		res |= 1 << sc->sc_capsloc.pos;
	uhidev_set_report_async(&sc->sc_hdev, UHID_OUTPUT_REPORT, &res, 1);
d772 4
a775 1
	usb_callout(sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
d777 1
d782 1
a782 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d800 5
a804 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
a810 6
/*
 * This is a hack to work around some broken ports that don't call
 * cnpollc() before cngetc().
 */
static int pollenter, warned;

a817 13
	int broken;

	if (pollenter == 0) {
		if (!warned) {
			printf("\n"
"This port is broken, it does not call cnpollc() before calling cngetc().\n"
"This should be fixed, but it will work anyway (for now).\n");
			warned = 1;
		}
		broken = 1;
		ukbd_cnpollc(v, 1);
	} else
		broken = 0;
d823 1
a823 1
		usbd_dopoll(sc->sc_hdev.sc_parent->sc_iface);
a832 2
	if (broken)
		ukbd_cnpollc(v, 0);
d843 1
a843 2
	usbd_interface2device_handle(sc->sc_hdev.sc_parent->sc_iface, &dev);
	if (on) pollenter++; else pollenter--;
a857 61
}

const char *
ukbd_parse_desc(struct ukbd_softc *sc)
{
	struct hid_data *d;
	struct hid_item h;
	int size;
	void *desc;
	int imod;

	uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
	imod = 0;
	sc->sc_nkeycode = 0;
	d = hid_start_parse(desc, size, hid_input);
	while (hid_get_item(d, &h)) {
		/*printf("ukbd: id=%d kind=%d usage=0x%x flags=0x%x pos=%d size=%d cnt=%d\n",
		  h.report_ID, h.kind, h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count);*/
		if (h.kind != hid_input || (h.flags & HIO_CONST) ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_KEYBOARD ||
		    h.report_ID != sc->sc_hdev.sc_report_id)
			continue;
		DPRINTF(("ukbd: imod=%d usage=0x%x flags=0x%x pos=%d size=%d "
			 "cnt=%d\n", imod,
			 h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count));
		if (h.flags & HIO_VARIABLE) {
			if (h.loc.size != 1)
				return ("bad modifier size");
			/* Single item */
			if (imod < MAXMOD) {
				sc->sc_modloc[imod] = h.loc;
				sc->sc_mods[imod].mask = 1 << imod;
				sc->sc_mods[imod].key = HID_GET_USAGE(h.usage);
				imod++;
			} else
				return ("too many modifier keys");
		} else {
			/* Array */
			if (h.loc.size != 8)
				return ("key code size != 8");
			if (h.loc.count > MAXKEYCODE)
				return ("too many key codes");
			if (h.loc.pos % 8 != 0)
				return ("key codes not on byte boundary");
			if (sc->sc_nkeycode != 0)
				return ("multiple key code arrays\n");
			sc->sc_keycodeloc = h.loc;
			sc->sc_nkeycode = h.loc.count;
		}
	}
	sc->sc_nmod = imod;
	hid_end_parse(d);

	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_NUM_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_numloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_CAPS_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_capsloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_SCROLL_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_scroloc, NULL);

	return (NULL);
@


1.11
log
@move the "ukbd_enable: %s: bad call on=%d" from DIAGNOSTIC to UKBD_DEBUG
@
text
@d1 2
a2 2
/*	$OpenBSD: ukbd.c,v 1.10 2001/10/31 04:24:44 nate Exp $	*/
/*      $NetBSD: ukbd.c,v 1.69 2001/10/24 21:02:18 augustss Exp $        */
d69 1
d92 2
a93 5
#define NKEYCODE 6

#define NUM_LOCK 0x01
#define CAPS_LOCK 0x02
#define SCROLL_LOCK 0x04
d96 2
a97 11
	u_int8_t	modifiers;
#define MOD_CONTROL_L	0x01
#define MOD_CONTROL_R	0x10
#define MOD_SHIFT_L	0x02
#define MOD_SHIFT_R	0x20
#define MOD_ALT_L	0x04
#define MOD_ALT_R	0x40
#define MOD_WIN_L	0x08
#define MOD_WIN_R	0x80
	u_int8_t	reserved;
	u_int8_t	keycode[NKEYCODE];
a103 15
/* Translate USB bitmap to USB keycode. */
#define NMOD 8
Static const struct {
	int mask, key;
} ukbd_mods[NMOD] = {
	{ MOD_CONTROL_L, 224 },
	{ MOD_CONTROL_R, 228 },
	{ MOD_SHIFT_L,   225 },
	{ MOD_SHIFT_R,   229 },
	{ MOD_ALT_L,     226 },
	{ MOD_ALT_R,     230 },
	{ MOD_WIN_L,     227 },
	{ MOD_WIN_R,     231 },
};

d108 3
a110 1
 * Scancodes >= 128 represent EXTENDED keycodes.
d113 32
a144 32
	  NN,  NN,  NN,  NN,  30,  48,  46,  32, /* 00 - 07 */
	  18,  33,  34,  35,  23,  36,  37,  38, /* 08 - 0F */
	  50,  49,  24,  25,  16,  19,  31,  20, /* 10 - 17 */
	  22,  47,  17,  45,  21,  44,   2,   3, /* 18 - 1F */
	   4,   5,   6,   7,   8,   9,  10,  11, /* 20 - 27 */
	  28,   1,  14,  15,  57,  12,  13,  26, /* 28 - 2F */
	  27,  43,  43,  39,  40,  41,  51,  52, /* 30 - 37 */
	  53,  58,  59,  60,  61,  62,  63,  64, /* 38 - 3F */
	  65,  66,  67,  68,  87,  88, 170,  70, /* 40 - 47 */
	 127, 210, 199, 201, 211, 207, 209, 205, /* 48 - 4F */
	 203, 208, 200,  69, 181,  55,  74,  78, /* 50 - 57 */
	 156,  79,  80,  81,  75,  76,  77,  71, /* 58 - 5F */
          72,  73,  82,  83,  86, 221,  NN,  NN, /* 60 - 67 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 68 - 6F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 70 - 77 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 78 - 7F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 80 - 87 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 88 - 8F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 90 - 97 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* 98 - 9F */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A0 - A7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* A8 - AF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B0 - B7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* B8 - BF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C0 - C7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* C8 - CF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D0 - D7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* D8 - DF */
          29,  42,  56, 219,  157, 54,  184,220, /* E0 - E7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* E8 - EF */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F0 - F7 */
          NN,  NN,  NN,  NN,  NN,  NN,  NN,  NN, /* F8 - FF */
d150 1
a150 1
#define MAXKEYS (NMOD+2*NKEYCODE)
d153 1
a153 5
	USBBASEDEVICE	sc_dev;		/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;
d157 9
d172 1
d175 3
d180 1
a180 7
#if defined(__OpenBSD__)
	struct timeout sc_delay;	/* for quirk handling */
	struct timeout sc_rawrepeat_ch;
#else
	struct callout sc_delay;	/* for quirk handling */
	struct callout sc_rawrepeat_ch;
#endif
a181 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a193 1
#endif
a233 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a237 1
#endif
d239 3
a241 1
Static void	ukbd_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d248 1
a248 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
a268 1
#endif
d275 3
a277 1
	usb_interface_descriptor_t *id;
d279 3
a281 2
	/* Check that this is a keyboard that speaks the boot protocol. */
	if (uaa->iface == NULL)
d283 2
a284 7
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL ||
	    id->bInterfaceClass != UICLASS_HID || 
	    id->bInterfaceSubClass != UISUBCLASS_BOOT ||
	    id->bInterfaceProtocol != UIPROTO_BOOT_KEYBOARD)
		return (UMATCH_NONE);
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
d290 1
a290 4
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status err;
d292 1
a292 2
	char devinfo[1024];
#if defined(__NetBSD__) || defined(__OpenBSD__)
a293 3
#else
	int i;
#endif
d295 8
a302 12
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);

	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
d305 6
a311 15
	DPRINTFN(10,("ukbd_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d313 1
a313 10
	qflags = usbd_get_quirks(uaa->device)->uq_flags;
	if ((qflags & UQ_NO_SET_PROTO) == 0) {
		err = usbd_set_protocol(iface, 0);
		DPRINTFN(5, ("ukbd_attach: protocol set\n"));
		if (err) {
			printf("%s: set protocol failed\n",
			    USBDEVNAME(sc->sc_dev));
			USB_ATTACH_ERROR_RETURN;
		}
	}
a315 5
	/* Ignore if SETIDLE fails since it is not crucial. */
	(void)usbd_set_idle(iface, 0, 0);

	sc->sc_ep_addr = ed->bEndpointAddress;

d340 2
a341 11
#if defined(__OpenBSD__)
#ifdef WSDISPLAY_COMPAT_RAWKBD
	timeout_set(&sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
#endif
	timeout_set(&sc->sc_delay, ukbd_delayed_decode, sc);
#endif

#if defined(__NetBSD__)
	callout_init(&sc->sc_rawrepeat_ch);
	callout_init(&sc->sc_delay);
#endif
d345 1
a345 1
	usbd_delay_ms(uaa->device, 400);
a347 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

a356 1
	usbd_status err;
d363 1
a363 1
#ifdef UKBD_DEBUG
d365 1
a365 1
		       USBDEVNAME(sc->sc_dev), on);
d371 1
d373 1
a373 7
		/* Set up interrupt pipe. */
		err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
			  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc,
			  &sc->sc_ndata, sizeof(sc->sc_ndata), ukbd_intr,
			  USBD_DEFAULT_INTERVAL);
		if (err)
			return (EIO);
d375 2
a376 4
		/* Disable interrupts. */
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
a377 3
	sc->sc_enabled = on;

	return (0);
d426 2
a427 1
		printf("%s: was console keyboard\n", USBDEVNAME(sc->sc_dev));
d437 2
a438 8
	if (sc->sc_intrpipe != NULL) {
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
	}

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d444 1
a444 4
ukbd_intr(xfer, addr, status)
	usbd_xfer_handle xfer;
	usbd_private_handle addr;
	usbd_status status;
d446 1
a446 1
	struct ukbd_softc *sc = addr;
d448 1
d450 8
a457 3
	DPRINTFN(5, ("ukbd_intr: status=%d\n", status));
	if (status == USBD_CANCELLED)
		return;
d459 6
a464 6
	if (status) {
		DPRINTF(("ukbd_intr: status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
		return;
	}
d474 2
a475 6
#if defined(__OpenBSD__)
		timeout_add(&sc->sc_delay, hz / 50);
#else
		callout_reset(&sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
#endif
#if DDB
d484 1
a484 5
#if defined(__OpenBSD__)
		timeout_add(&sc->sc_delay, 1);  /* NOT an immediate timeout */
#else
		callout_reset(&sc->sc_delay, 0, ukbd_delayed_decode, sc);
#endif
d516 1
a516 1
		p->unit = sc->sc_dev.dv_unit;
d541 5
a545 5
		for (i = 0; i < NMOD; i++)
			if (( mod & ukbd_mods[i].mask) != 
			    (omod & ukbd_mods[i].mask))
				ADDKEY(ukbd_mods[i].key | 
				       (mod & ukbd_mods[i].mask 
d547 1
a547 1
	if (memcmp(ud->keycode, sc->sc_odata.keycode, NKEYCODE) != 0) {
d549 1
a549 1
		for (i = 0; i < NKEYCODE; i++) {
d553 1
a553 1
			for (j = 0; j < NKEYCODE; j++)
d563 1
a563 1
		for (i = 0; i < NKEYCODE; i++) {
d567 1
a567 1
			for (j = 0; j < NKEYCODE; j++)
d589 1
a589 1
		char cbuf[MAXKEYS * 2];
d617 1
a617 5
#if defined(__OpenBSD__) 
		timeout_del(&sc->sc_rawrepeat_ch);
#else
		callout_stop(&sc->sc_rawrepeat_ch);
#endif
d620 1
a620 4
#if defined(__OpenBSD__)
			timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAY1/1000);
#else
			callout_reset(&sc->sc_rawrepeat_ch,
a621 1
#endif
d643 2
a644 1
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d\n", sc, leds));
d649 2
d653 8
a660 8
	if (leds & WSKBD_LED_SCROLL)
		res |= SCROLL_LOCK;
	if (leds & WSKBD_LED_NUM)
		res |= NUM_LOCK;
	if (leds & WSKBD_LED_CAPS)
		res |= CAPS_LOCK;
	res |= leds & 0xf8;
	usbd_set_report_async(sc->sc_iface, UHID_OUTPUT_REPORT, 0, &res, 1);
d673 1
a673 4
#if defined(__OpenBSD__)
	timeout_add(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000);
#else
	callout_reset(&sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
a674 1
#endif
d679 1
a679 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
d697 1
a697 5
#if defined(__OpenBSD__)
		timeout_del(&sc->sc_rawrepeat_ch);
#else
		callout_stop(&sc->sc_rawrepeat_ch);
#endif
d704 6
d717 13
d735 1
a735 1
		usbd_dopoll(sc->sc_iface);
d745 2
d757 2
a758 1
	(void)usbd_interface2device_handle(sc->sc_iface,&dev);
d773 61
@


1.10
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.9 2001/10/25 15:20:07 drahn Exp $	*/
d437 1
a437 1
#ifdef DIAGNOSTIC
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: ukbd.c,v 1.79 2001/12/30 19:37:43 augustss Exp $        */
a68 1
#include <dev/usb/uhidev.h>
d91 5
a95 2
#define MAXKEYCODE 6
#define MAXMOD 8		/* max 32 */
d98 11
a108 2
	u_int32_t	modifiers;
	u_int8_t	keycode[MAXKEYCODE];
d115 15
d134 1
a134 3
 * Scancodes >= 0x80 represent EXTENDED keycodes.
 *
 * See http://www.microsoft.com/HWDEV/TECH/input/Scancode.asp
d137 32
a168 32
      NN,   NN,   NN,   NN, 0x1e, 0x30, 0x2e, 0x20, /* 00 - 07 */
    0x12, 0x21, 0x22, 0x23, 0x17, 0x24, 0x25, 0x26, /* 08 - 0f */
    0x32, 0x31, 0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, /* 10 - 17 */
    0x16, 0x2f, 0x11, 0x2d, 0x15, 0x2c, 0x02, 0x03, /* 18 - 1f */
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, /* 20 - 27 */
    0x1c, 0x01, 0x0e, 0x0f, 0x39, 0x0c, 0x0d, 0x1a, /* 28 - 2f */
    0x1b, 0x2b, 0x2b, 0x27, 0x28, 0x29, 0x33, 0x34, /* 30 - 37 */
    0x35, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, /* 38 - 3f */
    0x41, 0x42, 0x43, 0x44, 0x57, 0x58, 0xaa, 0x46, /* 40 - 47 */
    0x7f, 0xd2, 0xc7, 0xc9, 0xd3, 0xcf, 0xd1, 0xcd, /* 48 - 4f */
    0xcb, 0xd0, 0xc8, 0x45, 0xb5, 0x37, 0x4a, 0x4e, /* 50 - 57 */
    0x9c, 0x4f, 0x50, 0x51, 0x4b, 0x4c, 0x4d, 0x47, /* 58 - 5f */
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd,   NN, 0x59, /* 60 - 67 */
    0x5d, 0x5e, 0x5f,   NN,   NN,   NN,   NN,   NN, /* 68 - 6f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 70 - 77 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 78 - 7f */
      NN,   NN,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
    0x70, 0x7d, 0x79, 0x7b, 0x5c,   NN,   NN,   NN, /* 88 - 8f */
      NN,   NN, 0x78, 0x77, 0x76,   NN,   NN,   NN, /* 90 - 97 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 98 - 9f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a0 - a7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a8 - af */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b0 - b7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b8 - bf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c0 - c7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c8 - cf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d0 - d7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d8 - df */
    0x1d, 0x2a, 0x38, 0xdb, 0x9d, 0x36, 0xb8, 0xdc, /* e0 - e7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* e8 - ef */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f0 - f7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f8 - ff */
d174 1
a174 1
#define MAXKEYS (MAXMOD+2*MAXKEYCODE)
d177 5
a181 1
	struct uhidev sc_hdev;
a184 9
	struct hid_location sc_modloc[MAXMOD];
	u_int sc_nmod;
	struct {
		u_int32_t mask;
		u_int8_t key;
	} sc_mods[MAXMOD];

	struct hid_location sc_keycodeloc;
	u_int sc_nkeycode;
a190 1
	usb_callout_t sc_delay;		/* for quirk handling */
a192 3
	struct hid_location sc_numloc;
	struct hid_location sc_capsloc;
	struct hid_location sc_scroloc;
d195 7
a201 1
	usb_callout_t sc_rawrepeat_ch;
d203 1
d216 1
d257 1
d262 1
d264 1
a264 3
Static const char *ukbd_parse_desc(struct ukbd_softc *sc);

Static void	ukbd_intr(struct uhidev *addr, void *ibuf, u_int len);
d271 2
a272 1
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr );
d293 1
d300 1
a300 3
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
	void *desc;
d302 8
a309 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
d311 1
a311 2

	return (UMATCH_IFACECLASS);
d317 4
a320 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d322 2
a323 1
	const char *parseerr;
d325 3
d329 12
a340 8
	sc->sc_hdev.sc_intr = ukbd_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	parseerr = ukbd_parse_desc(sc);
	if (parseerr != NULL) {
		printf("\n%s: attach failed, %s\n",
		       sc->sc_hdev.sc_dev.dv_xname, parseerr);
a342 6
		
#ifdef DIAGNOSTIC
	printf(": %d modifier keys, %d key codes", sc->sc_nmod,
	       sc->sc_nkeycode);
#endif
	printf("\n");
d344 15
d360 10
a369 1
	qflags = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d372 5
d401 11
a411 2
	usb_callout_init(sc->sc_rawrepeat_ch);
	usb_callout_init(sc->sc_delay);
d415 1
a415 1
	usbd_delay_ms(uha->parent->sc_udev, 400);
d418 3
d430 1
d437 1
a437 1
#ifdef UKBD_DEBUG
d439 1
a439 1
		       USBDEVNAME(sc->sc_hdev.sc_dev), on);
a444 1
	sc->sc_enabled = on;
d446 7
a452 1
		return (uhidev_open(&sc->sc_hdev));
d454 4
a457 2
		uhidev_close(&sc->sc_hdev);
		return (0);
d459 3
d510 1
a510 2
		printf("%s: was console keyboard\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d520 8
a527 2
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);
d533 4
a536 1
ukbd_intr(struct uhidev *addr, void *ibuf, u_int len)
d538 1
a538 1
	struct ukbd_softc *sc = (struct ukbd_softc *)addr;
a539 1
	int i;
d541 9
a549 6
#ifdef UKBD_DEBUG
	if (ukbddebug > 5) {
		printf("ukbd_intr: data");
		for (i = 0; i < len; i++)
			printf(" 0x%02x", ((u_char *)ibuf)[i]);
		printf("\n");
a550 8
#endif

	ud->modifiers = 0;
	for (i = 0; i < sc->sc_nmod; i++)
		if (hid_get_data(ibuf, &sc->sc_modloc[i]))
			ud->modifiers |= sc->sc_mods[i].mask;
	memcpy(ud->keycode, (char *)ibuf + sc->sc_keycodeloc.pos / 8,
	       sc->sc_nkeycode);
d560 6
a565 2
		usb_callout(sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
#ifdef DDB
d574 5
a578 1
		usb_callout(sc->sc_delay, 1, ukbd_delayed_decode, sc);
d610 1
a610 1
		p->unit = sc->sc_hdev.sc_dev.dv_unit;
d635 5
a639 5
		for (i = 0; i < sc->sc_nmod; i++)
			if (( mod & sc->sc_mods[i].mask) != 
			    (omod & sc->sc_mods[i].mask))
				ADDKEY(sc->sc_mods[i].key | 
				       (mod & sc->sc_mods[i].mask 
d641 1
a641 1
	if (memcmp(ud->keycode, sc->sc_odata.keycode, sc->sc_nkeycode) != 0) {
d643 1
a643 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d647 1
a647 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d657 1
a657 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d661 1
a661 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d683 1
a683 1
		u_char cbuf[MAXKEYS * 2];
d711 5
a715 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
d718 4
a721 1
			usb_callout(sc->sc_rawrepeat_ch,
d723 1
d745 1
a745 2
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d, sc_leds=%d\n",
		 sc, leds, sc->sc_leds));
a749 2
	if (sc->sc_leds == leds)
		return;
d752 8
a759 8
	/* XXX not really right */
	if ((leds & WSKBD_LED_SCROLL) && sc->sc_scroloc.size == 1)
		res |= 1 << sc->sc_scroloc.pos;
	if ((leds & WSKBD_LED_NUM) && sc->sc_numloc.size == 1)
		res |= 1 << sc->sc_numloc.pos;
	if ((leds & WSKBD_LED_CAPS) && sc->sc_capsloc.size == 1)
		res |= 1 << sc->sc_capsloc.pos;
	uhidev_set_report_async(&sc->sc_hdev, UHID_OUTPUT_REPORT, &res, 1);
d772 4
a775 1
	usb_callout(sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
d777 1
d782 1
a782 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d800 5
a804 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
a810 6
/*
 * This is a hack to work around some broken ports that don't call
 * cnpollc() before cngetc().
 */
static int pollenter, warned;

a817 13
	int broken;

	if (pollenter == 0) {
		if (!warned) {
			printf("\n"
"This port is broken, it does not call cnpollc() before calling cngetc().\n"
"This should be fixed, but it will work anyway (for now).\n");
			warned = 1;
		}
		broken = 1;
		ukbd_cnpollc(v, 1);
	} else
		broken = 0;
d823 1
a823 1
		usbd_dopoll(sc->sc_hdev.sc_parent->sc_iface);
a832 2
	if (broken)
		ukbd_cnpollc(v, 0);
d843 1
a843 2
	usbd_interface2device_handle(sc->sc_hdev.sc_parent->sc_iface, &dev);
	if (on) pollenter++; else pollenter--;
a857 61
}

const char *
ukbd_parse_desc(struct ukbd_softc *sc)
{
	struct hid_data *d;
	struct hid_item h;
	int size;
	void *desc;
	int imod;

	uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
	imod = 0;
	sc->sc_nkeycode = 0;
	d = hid_start_parse(desc, size, hid_input);
	while (hid_get_item(d, &h)) {
		/*printf("ukbd: id=%d kind=%d usage=0x%x flags=0x%x pos=%d size=%d cnt=%d\n",
		  h.report_ID, h.kind, h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count);*/
		if (h.kind != hid_input || (h.flags & HIO_CONST) ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_KEYBOARD ||
		    h.report_ID != sc->sc_hdev.sc_report_id)
			continue;
		DPRINTF(("ukbd: imod=%d usage=0x%x flags=0x%x pos=%d size=%d "
			 "cnt=%d\n", imod,
			 h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count));
		if (h.flags & HIO_VARIABLE) {
			if (h.loc.size != 1)
				return ("bad modifier size");
			/* Single item */
			if (imod < MAXMOD) {
				sc->sc_modloc[imod] = h.loc;
				sc->sc_mods[imod].mask = 1 << imod;
				sc->sc_mods[imod].key = HID_GET_USAGE(h.usage);
				imod++;
			} else
				return ("too many modifier keys");
		} else {
			/* Array */
			if (h.loc.size != 8)
				return ("key code size != 8");
			if (h.loc.count > MAXKEYCODE)
				return ("too many key codes");
			if (h.loc.pos % 8 != 0)
				return ("key codes not on byte boundary");
			if (sc->sc_nkeycode != 0)
				return ("multiple key code arrays\n");
			sc->sc_keycodeloc = h.loc;
			sc->sc_nkeycode = h.loc.count;
		}
	}
	sc->sc_nmod = imod;
	hid_end_parse(d);

	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_NUM_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_numloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_CAPS_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_capsloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_SCROLL_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_scroloc, NULL);

	return (NULL);
@


1.10.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*      $NetBSD: ukbd.c,v 1.82 2002/07/11 21:14:30 augustss Exp $        */
d106 1
a106 1
/*
d214 1
a214 1
		struct ukbdtraceinfo *p =
d278 1
a278 1

d294 1
a294 1

d305 1
a305 1

d363 4
a366 2
		DPRINTF(("ukbd_enable: %s: bad call on=%d\n",
			 USBDEVNAME(sc->sc_hdev.sc_dev), on));
d510 1
a510 1
	/*
d542 1
a542 1
			if (( mod & sc->sc_mods[i].mask) !=
d544 2
a545 2
				ADDKEY(sc->sc_mods[i].key |
				       (mod & sc->sc_mods[i].mask
d561 1
a561 1

d609 1
a609 1
			DPRINTFN(1,("ukbd_intr: raw = %s0x%02x\n",
d630 1
a630 1
		wskbd_input(sc->sc_wskbddev,
d739 1
a739 1
	memcpy(sc->sc_pollchars, sc->sc_pollchars+1,
@


1.9
log
@ddb entry support using usb (console) keyboard.
Do not send characters directly from usb interrupt handler for
console keyboard. entering ddb from within the usb interrupt handler
is _bad_. Instead delay until next timeout check and deliver characters
then. Tested on mappc.
From NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ukbd.c,v 1.8 2001/10/25 14:36:11 drahn Exp $	*/
/*      $NetBSD: ukbd.c,v 1.66 2001/04/06 22:54:15 augustss Exp $        */
d79 1
d547 2
a548 1
		usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
d565 1
d567 1
a567 1
		/* 
d569 2
a570 2
		 * from the interrupt routine. Doing so would start
		 * polling from iside the interrupt routine and that
d579 1
a579 1

@


1.8
log
@If a usb keyboard is detached, check if the intrpipe is still active.
Console keyboard will still be active and must be shut down for successful
detach. This change and previous change to wskbd.c both from NetBSD.
Tested by miod@@ and myself.

Hot plug/unplug on USB console keyboard now works on macppc.
(this and wskbd.c may be errata candidates).
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.7 2001/07/25 04:54:37 mickey Exp $	*/
d550 1
a550 1
	if (sc->sc_debounce) {
d563 14
@


1.7
log
@be carefull about initializing timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.6 2001/05/03 02:20:33 aaron Exp $	*/
d456 1
d517 7
@


1.6
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.5 2001/03/07 20:42:38 maja Exp $	*/
d400 2
a401 1
#if defined(__OpenBSD__) && defined(WSDISPLAY_COMPAT_RAWKBD)
d403 1
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*      $NetBSD: ukbd.c,v 1.60 2000/06/01 14:29:00 augustss Exp $        */
d116 1
a116 1
Static struct {
d135 1
a135 1
Static u_int8_t ukbd_trtab[256] = {
a414 2
	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);

d417 2
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: ukbd.c,v 1.66 2001/04/06 22:54:15 augustss Exp $        */
d116 1
a116 1
Static const struct {
d135 1
a135 1
Static const u_int8_t ukbd_trtab[256] = {
d415 2
a418 2

	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.6.2.2 2001/07/04 10:43:55 niklas Exp $	*/
d400 1
a400 2
#if defined(__OpenBSD__)
#ifdef WSDISPLAY_COMPAT_RAWKBD
a401 1
#endif
a453 1
		sc->sc_intrpipe = NULL;
a514 7
	/* The console keyboard does not get a disable call, so check pipe. */
	if (sc->sc_intrpipe != NULL) {
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
	}

d540 1
a540 1
	if (sc->sc_debounce && !sc->sc_polling) {
a552 14
	} else if (sc->sc_console_keyboard && !sc->sc_polling) {
		/* 
		 * For the console keyboard we can't deliver CTL-ALT-ESC
		 * from the interrupt routine. Doing so would start
		 * polling from iside the interrupt routine and that
		 * loses bigtime.
		 */
		sc->sc_data = *ud;
#if defined(__OpenBSD__)
		timeout_add(&sc->sc_delay, 1);  /* NOT an immediate timeout */
#else
		callout_reset(&sc->sc_delay, 0, ukbd_delayed_decode, sc);
#endif

@


1.6.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: ukbd.c,v 1.69 2001/10/24 21:02:18 augustss Exp $        */
a78 1
#include "opt_ddb.h"
d546 1
a546 2
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
a562 1
#if DDB
d564 1
a564 1
		/*
d566 2
a567 2
		 * from the interrupt routine.  Doing so would start
		 * polling from inside the interrupt routine and that
d576 1
a576 1
#endif
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*      $NetBSD: ukbd.c,v 1.82 2002/07/11 21:14:30 augustss Exp $        */
a68 1
#include <dev/usb/uhidev.h>
d91 5
a95 2
#define MAXKEYCODE 6
#define MAXMOD 8		/* max 32 */
d98 11
a108 2
	u_int32_t	modifiers;
	u_int8_t	keycode[MAXKEYCODE];
d115 15
d132 1
a132 1
/*
d134 1
a134 3
 * Scancodes >= 0x80 represent EXTENDED keycodes.
 *
 * See http://www.microsoft.com/HWDEV/TECH/input/Scancode.asp
d137 32
a168 32
      NN,   NN,   NN,   NN, 0x1e, 0x30, 0x2e, 0x20, /* 00 - 07 */
    0x12, 0x21, 0x22, 0x23, 0x17, 0x24, 0x25, 0x26, /* 08 - 0f */
    0x32, 0x31, 0x18, 0x19, 0x10, 0x13, 0x1f, 0x14, /* 10 - 17 */
    0x16, 0x2f, 0x11, 0x2d, 0x15, 0x2c, 0x02, 0x03, /* 18 - 1f */
    0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, /* 20 - 27 */
    0x1c, 0x01, 0x0e, 0x0f, 0x39, 0x0c, 0x0d, 0x1a, /* 28 - 2f */
    0x1b, 0x2b, 0x2b, 0x27, 0x28, 0x29, 0x33, 0x34, /* 30 - 37 */
    0x35, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, /* 38 - 3f */
    0x41, 0x42, 0x43, 0x44, 0x57, 0x58, 0xaa, 0x46, /* 40 - 47 */
    0x7f, 0xd2, 0xc7, 0xc9, 0xd3, 0xcf, 0xd1, 0xcd, /* 48 - 4f */
    0xcb, 0xd0, 0xc8, 0x45, 0xb5, 0x37, 0x4a, 0x4e, /* 50 - 57 */
    0x9c, 0x4f, 0x50, 0x51, 0x4b, 0x4c, 0x4d, 0x47, /* 58 - 5f */
    0x48, 0x49, 0x52, 0x53, 0x56, 0xdd,   NN, 0x59, /* 60 - 67 */
    0x5d, 0x5e, 0x5f,   NN,   NN,   NN,   NN,   NN, /* 68 - 6f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 70 - 77 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 78 - 7f */
      NN,   NN,   NN,   NN,   NN, 0x7e,   NN, 0x73, /* 80 - 87 */
    0x70, 0x7d, 0x79, 0x7b, 0x5c,   NN,   NN,   NN, /* 88 - 8f */
      NN,   NN, 0x78, 0x77, 0x76,   NN,   NN,   NN, /* 90 - 97 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* 98 - 9f */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a0 - a7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* a8 - af */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b0 - b7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* b8 - bf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c0 - c7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* c8 - cf */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d0 - d7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* d8 - df */
    0x1d, 0x2a, 0x38, 0xdb, 0x9d, 0x36, 0xb8, 0xdc, /* e0 - e7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* e8 - ef */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f0 - f7 */
      NN,   NN,   NN,   NN,   NN,   NN,   NN,   NN, /* f8 - ff */
d174 1
a174 1
#define MAXKEYS (MAXMOD+2*MAXKEYCODE)
d177 5
a181 1
	struct uhidev sc_hdev;
a184 9
	struct hid_location sc_modloc[MAXMOD];
	u_int sc_nmod;
	struct {
		u_int32_t mask;
		u_int8_t key;
	} sc_mods[MAXMOD];

	struct hid_location sc_keycodeloc;
	u_int sc_nkeycode;
a190 1
	usb_callout_t sc_delay;		/* for quirk handling */
a192 3
	struct hid_location sc_numloc;
	struct hid_location sc_capsloc;
	struct hid_location sc_scroloc;
d195 7
a201 1
	usb_callout_t sc_rawrepeat_ch;
d203 1
d216 1
d237 1
a237 1
		struct ukbdtraceinfo *p =
d257 1
d262 1
d264 1
a264 3
Static const char *ukbd_parse_desc(struct ukbd_softc *sc);

Static void	ukbd_intr(struct uhidev *addr, void *ibuf, u_int len);
d271 2
a272 1
Static int	ukbd_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr );
d293 1
d300 10
a309 7
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
	void *desc;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_KEYBOARD)))
d311 1
a311 2

	return (UMATCH_IFACECLASS);
d317 4
a320 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d322 2
a323 1
	const char *parseerr;
d325 18
d344 13
a356 8
	sc->sc_hdev.sc_intr = ukbd_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	parseerr = ukbd_parse_desc(sc);
	if (parseerr != NULL) {
		printf("\n%s: attach failed, %s\n",
		       sc->sc_hdev.sc_dev.dv_xname, parseerr);
d360 11
a370 5
#ifdef DIAGNOSTIC
	printf(": %d modifier keys, %d key codes", sc->sc_nmod,
	       sc->sc_nkeycode);
#endif
	printf("\n");
d372 2
d375 1
a375 2
	qflags = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
	sc->sc_debounce = (qflags & UQ_SPUR_BUT_UP) != 0;
d401 11
a411 2
	usb_callout_init(sc->sc_rawrepeat_ch);
	usb_callout_init(sc->sc_delay);
d415 1
a415 1
	usbd_delay_ms(uha->parent->sc_udev, 400);
d418 3
d430 1
d437 4
a440 2
		DPRINTF(("ukbd_enable: %s: bad call on=%d\n",
			 USBDEVNAME(sc->sc_hdev.sc_dev), on));
a444 1
	sc->sc_enabled = on;
d446 7
a452 1
		return (uhidev_open(&sc->sc_hdev));
d454 4
a457 2
		uhidev_close(&sc->sc_hdev);
		return (0);
d459 3
d510 1
a510 2
		printf("%s: was console keyboard\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d520 8
a527 2
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);
d533 4
a536 1
ukbd_intr(struct uhidev *addr, void *ibuf, u_int len)
d538 1
a538 1
	struct ukbd_softc *sc = (struct ukbd_softc *)addr;
a539 1
	int i;
d541 9
a549 6
#ifdef UKBD_DEBUG
	if (ukbddebug > 5) {
		printf("ukbd_intr: data");
		for (i = 0; i < len; i++)
			printf(" 0x%02x", ((u_char *)ibuf)[i]);
		printf("\n");
a550 8
#endif

	ud->modifiers = 0;
	for (i = 0; i < sc->sc_nmod; i++)
		if (hid_get_data(ibuf, &sc->sc_modloc[i]))
			ud->modifiers |= sc->sc_mods[i].mask;
	memcpy(ud->keycode, (char *)ibuf + sc->sc_keycodeloc.pos / 8,
	       sc->sc_nkeycode);
d560 6
a565 2
		usb_callout(sc->sc_delay, hz / 50, ukbd_delayed_decode, sc);
#ifdef DDB
d574 5
a578 1
		usb_callout(sc->sc_delay, 1, ukbd_delayed_decode, sc);
d604 1
a604 1
	/*
d610 1
a610 1
		p->unit = sc->sc_hdev.sc_dev.dv_unit;
d635 5
a639 5
		for (i = 0; i < sc->sc_nmod; i++)
			if (( mod & sc->sc_mods[i].mask) !=
			    (omod & sc->sc_mods[i].mask))
				ADDKEY(sc->sc_mods[i].key |
				       (mod & sc->sc_mods[i].mask
d641 1
a641 1
	if (memcmp(ud->keycode, sc->sc_odata.keycode, sc->sc_nkeycode) != 0) {
d643 1
a643 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d647 1
a647 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d655 1
a655 1

d657 1
a657 1
		for (i = 0; i < sc->sc_nkeycode; i++) {
d661 1
a661 1
			for (j = 0; j < sc->sc_nkeycode; j++)
d683 1
a683 1
		u_char cbuf[MAXKEYS * 2];
d703 1
a703 1
			DPRINTFN(1,("ukbd_intr: raw = %s0x%02x\n",
d711 5
a715 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
d718 4
a721 1
			usb_callout(sc->sc_rawrepeat_ch,
d723 1
d732 1
a732 1
		wskbd_input(sc->sc_wskbddev,
d745 1
a745 2
	DPRINTF(("ukbd_set_leds: sc=%p leds=%d, sc_leds=%d\n",
		 sc, leds, sc->sc_leds));
a749 2
	if (sc->sc_leds == leds)
		return;
d752 8
a759 8
	/* XXX not really right */
	if ((leds & WSKBD_LED_SCROLL) && sc->sc_scroloc.size == 1)
		res |= 1 << sc->sc_scroloc.pos;
	if ((leds & WSKBD_LED_NUM) && sc->sc_numloc.size == 1)
		res |= 1 << sc->sc_numloc.pos;
	if ((leds & WSKBD_LED_CAPS) && sc->sc_capsloc.size == 1)
		res |= 1 << sc->sc_capsloc.pos;
	uhidev_set_report_async(&sc->sc_hdev, UHID_OUTPUT_REPORT, &res, 1);
d772 4
a775 1
	usb_callout(sc->sc_rawrepeat_ch, hz * REP_DELAYN / 1000,
d777 1
d782 1
a782 1
ukbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d800 5
a804 1
		usb_uncallout(sc->sc_rawrepeat_ch, ukbd_rawrepeat, sc);
a810 6
/*
 * This is a hack to work around some broken ports that don't call
 * cnpollc() before cngetc().
 */
static int pollenter, warned;

a817 13
	int broken;

	if (pollenter == 0) {
		if (!warned) {
			printf("\n"
"This port is broken, it does not call cnpollc() before calling cngetc().\n"
"This should be fixed, but it will work anyway (for now).\n");
			warned = 1;
		}
		broken = 1;
		ukbd_cnpollc(v, 1);
	} else
		broken = 0;
d823 1
a823 1
		usbd_dopoll(sc->sc_hdev.sc_parent->sc_iface);
d827 1
a827 1
	memcpy(sc->sc_pollchars, sc->sc_pollchars+1,
a832 2
	if (broken)
		ukbd_cnpollc(v, 0);
d843 1
a843 2
	usbd_interface2device_handle(sc->sc_hdev.sc_parent->sc_iface, &dev);
	if (on) pollenter++; else pollenter--;
a857 61
}

const char *
ukbd_parse_desc(struct ukbd_softc *sc)
{
	struct hid_data *d;
	struct hid_item h;
	int size;
	void *desc;
	int imod;

	uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
	imod = 0;
	sc->sc_nkeycode = 0;
	d = hid_start_parse(desc, size, hid_input);
	while (hid_get_item(d, &h)) {
		/*printf("ukbd: id=%d kind=%d usage=0x%x flags=0x%x pos=%d size=%d cnt=%d\n",
		  h.report_ID, h.kind, h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count);*/
		if (h.kind != hid_input || (h.flags & HIO_CONST) ||
		    HID_GET_USAGE_PAGE(h.usage) != HUP_KEYBOARD ||
		    h.report_ID != sc->sc_hdev.sc_report_id)
			continue;
		DPRINTF(("ukbd: imod=%d usage=0x%x flags=0x%x pos=%d size=%d "
			 "cnt=%d\n", imod,
			 h.usage, h.flags, h.loc.pos, h.loc.size, h.loc.count));
		if (h.flags & HIO_VARIABLE) {
			if (h.loc.size != 1)
				return ("bad modifier size");
			/* Single item */
			if (imod < MAXMOD) {
				sc->sc_modloc[imod] = h.loc;
				sc->sc_mods[imod].mask = 1 << imod;
				sc->sc_mods[imod].key = HID_GET_USAGE(h.usage);
				imod++;
			} else
				return ("too many modifier keys");
		} else {
			/* Array */
			if (h.loc.size != 8)
				return ("key code size != 8");
			if (h.loc.count > MAXKEYCODE)
				return ("too many key codes");
			if (h.loc.pos % 8 != 0)
				return ("key codes not on byte boundary");
			if (sc->sc_nkeycode != 0)
				return ("multiple key code arrays\n");
			sc->sc_keycodeloc = h.loc;
			sc->sc_nkeycode = h.loc.count;
		}
	}
	sc->sc_nmod = imod;
	hid_end_parse(d);

	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_NUM_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_numloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_CAPS_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_capsloc, NULL);
	hid_locate(desc, size, HID_USAGE2(HUP_LEDS, HUD_LED_SCROLL_LOCK),
		   sc->sc_hdev.sc_report_id, hid_output, &sc->sc_scroloc, NULL);

	return (NULL);
@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ukbd.c,v 1.6.2.5 2003/03/28 00:38:32 niklas Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: ukbd.c,v 1.85 2003/03/11 16:44:00 augustss Exp $        */
a190 1
	int sc_spl;
d387 1
d713 1
d730 1
d741 1
d756 1
a756 7
	if (on) {
		sc->sc_spl = splusb();
		pollenter++;
	} else {
		splx(sc->sc_spl);
		pollenter--;
	}
@


1.5
log
@Add some non US encodings. Add option UKBD_LAYOUT. -moj ok @@aaron
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*      $NetBSD: ukbd.c,v 1.60 2000/06/01 14:29:00 augustss Exp $        */
d116 1
a116 1
Static struct {
d135 1
a135 1
Static u_int8_t ukbd_trtab[256] = {
a414 2
	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);

d417 2
@


1.4
log
@Fix callout/timeout difference that did not quite get merged correctly.
Uses were correct, just definition did not get moved appropriately.
@
text
@d1 1
d286 3
d290 1
@


1.3
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@a188 1
	struct callout sc_delay;	/* for quirk handling */
d194 1
d197 1
@


1.2
log
@- Convert to new timeouts.
- Allow it to compile with option WSDISPLAY_COMPAT_RAWKBD.
@
text
@d41 1
a41 1
 * HID spec: http://www.usb.org/developers/data/usbhid10.pdf
d80 1
a80 1
#ifdef USB_DEBUG
d141 1
a141 1
	  27,  43,  NN,  39,  40,  41,  51,  52, /* 30 - 37 */
d147 1
a147 1
          72,  73,  82,  83,  NN, 221,  NN,  NN, /* 60 - 67 */
d188 4
d218 27
d249 1
a249 2
Static int	ukbd_is_console = 0;

d262 2
d314 1
d353 2
a354 1
	if ((usbd_get_quirks(uaa->device)->uq_flags & UQ_NO_SET_PROTO) == 0) {
d363 1
d366 1
a366 1
	usbd_set_idle(iface, 0, 0);
d396 1
d401 1
a522 6
	int mod, omod;
	u_int16_t ibuf[MAXKEYS];	/* chars events */
	int s;
	int nkeys, i, j;
	int key;
#define ADDKEY(c) ibuf[nkeys++] = (c)
d534 59
a592 2
	DPRINTFN(5, ("          mod=0x%02x key0=0x%02x key1=0x%02x\n",
		     ud->modifiers, ud->keycode[0], ud->keycode[1]));
d617 1
@


1.1
log
@Add usb keyboard. from NetBSD.
@
text
@d46 3
a48 1
/*
d50 1
a50 1
*/
d78 1
a78 1
#endif /* __NetBSD__ */
d128 1
a128 1
#if defined(__NetBSD__) && defined(WSDISPLAY_COMPAT_RAWKBD)
d168 1
a168 1
#endif /* defined(__NetBSD__) && defined(WSDISPLAY_COMPAT_RAWKBD) */
d189 4
a192 1
#if defined(__NetBSD__) 
d194 1
a194 1
#endif /* __NetBSD__ */
a196 1

d209 1
a209 1
#endif /* defined(__NetBSD__) */
d359 5
a363 1
#if defined(__NetBSD__) 
d365 1
a365 1
#endif /* __NetBSD__ */
d589 3
a591 1
#if defined(__NetBSD__) 
d593 1
a593 1
#endif /* __NetBSD__ */
d596 3
a598 1
#if defined(__NetBSD__) 
d601 1
a601 1
#endif /* __NetBSD__ */
d650 3
a652 1
#if defined(__NetBSD__) 
d655 1
a655 1
#endif /* __NetBSD__ */
d678 3
a680 1
#if defined(__NetBSD__) 
d682 1
a682 1
#endif /* __NetBSD__ */
@

