head	1.43;
access;
symbols
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.10
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.8
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.6
	OPENBSD_5_0:1.27.0.4
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11;
locks; strict;
comment	@ * @;


1.43
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.42;
commitid	gWZDkudwxydTq8x4;

1.42
date	2016.04.12.10.15.25;	author mpi;	state Exp;
branches;
next	1.41;
commitid	qnT2zx5QZlYWGbAS;

1.41
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.40;
commitid	B0kwmVGiD5DVx4kv;

1.40
date	2015.11.22.23.56.10;	author dlg;	state Exp;
branches;
next	1.39;
commitid	jF4QDaw5SgKCdtgM;

1.39
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.38;
commitid	eYnPulzvLjDImPCa;

1.38
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.37;
commitid	pwYnMC1gOKohmeGw;

1.37
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.36;
commitid	MVWrtktB46JRxFWT;

1.36
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.35;
commitid	aqezguXMYUVIGMPW;

1.35
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.34;
commitid	yM2VFFhpDTeFQlve;

1.34
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.33;
commitid	Pclvgy2Z4XV9hveD;

1.33
date	2013.12.07.20.17.42;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2013.12.04.00.52.52;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.11.11.10.09.40;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.29.10.01.20;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2010.12.30.03.06.31;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.27.03.03.50;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.29.07.12.31;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.07.18.47.08;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.29.10.24.33;	author matthieu;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.25.16.40.03;	author jmc;	state Exp;
branches;
next	1.19;

1.19
date	2007.11.13.01.15.43;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.14.06.55.10;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.05.27.10.24.51;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.19.24.27;	author ckuethe;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.26.15.41.28;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.24.21.57.27;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.23.06.10.08;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.15.20.39.05;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.15.07.00.28;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.15.05.09.15;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.15.04.34.44;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.13.18.32.56;	author drahn;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.07.16.26.49;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.18.10.29;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.43
log
@G/C IFQ_SET_READY().
@
text
@/*	$OpenBSD: if_cdcef.c,v 1.42 2016/04/12 10:15:25 mpi Exp $	*/

/*
 * Copyright (c) 2007 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * USB Communication Device Class Ethernet Emulation Model function driver
 * (counterpart of the host-side cdce(4) driver)
 */
#include <bpfilter.h>


#include <sys/param.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbf.h>
#include <dev/usb/usbcdc.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>


#define CDCEF_VENDOR_ID		0x0001
#define CDCEF_PRODUCT_ID	0x0001
#define CDCEF_DEVICE_CODE	0x0100
#define CDCEF_VENDOR_STRING	"OpenBSD.org"
#define CDCEF_PRODUCT_STRING	"CDC Ethernet Emulation"
#define CDCEF_SERIAL_STRING	"1.00"

#define CDCEF_BUFSZ		1600


struct cdcef_softc {
	struct usbf_function	sc_dev;
	struct usbf_config	*sc_config;
	struct usbf_interface	*sc_iface;
	struct usbf_endpoint	*sc_ep_in;
	struct usbf_endpoint	*sc_ep_out;
	struct usbf_pipe	*sc_pipe_in;
	struct usbf_pipe	*sc_pipe_out;
	struct usbf_xfer	*sc_xfer_in;
	struct usbf_xfer	*sc_xfer_out;
	void			*sc_buffer_in;
	void			*sc_buffer_out;

	struct timeout		start_to;

	struct mbuf		*sc_xmit_mbuf;

	struct arpcom           sc_arpcom;
#define GET_IFP(sc) (&(sc)->sc_arpcom.ac_if)

	int			sc_rxeof_errors;
	int			sc_listening;
};

int		cdcef_match(struct device *, void *, void *);
void		cdcef_attach(struct device *, struct device *, void *);

usbf_status	cdcef_do_request(struct usbf_function *,
				 usb_device_request_t *, void **);

void		cdcef_start(struct ifnet *);

void		cdcef_txeof(struct usbf_xfer *, void *,
			    usbf_status);
void		cdcef_rxeof(struct usbf_xfer *, void *,
			    usbf_status);
int		cdcef_ioctl(struct ifnet *ifp, u_long command, caddr_t data);
void		cdcef_watchdog(struct ifnet *ifp);
void		cdcef_init(struct cdcef_softc *);
void		cdcef_stop(struct cdcef_softc *);
int		cdcef_encap(struct cdcef_softc *sc, struct mbuf *m, int idx);
struct mbuf *	cdcef_newbuf(void);
void		cdcef_start_timeout (void *);

struct cfattach cdcef_ca = {
	sizeof(struct cdcef_softc), cdcef_match, cdcef_attach
};

struct cfdriver cdcef_cd = {
	NULL, "cdcef", DV_IFNET
};

struct usbf_function_methods cdcef_methods = {
	NULL,			/* set_config */
	cdcef_do_request
};

#ifndef CDCEF_DEBUG
#define DPRINTF(x)	do {} while (0)
#else
#define DPRINTF(x)	printf x
#endif

#define DEVNAME(sc)	((sc)->sc_dev.bdev.dv_xname)

/*
 * USB function match/attach/detach
 */

int
cdcef_match(struct device *parent, void *match, void *aux)
{
	return UMATCH_GENERIC;
}

void
cdcef_attach(struct device *parent, struct device *self, void *aux)
{
	struct cdcef_softc *sc = (struct cdcef_softc *)self;
	struct usbf_attach_arg *uaa = aux;
	struct usbf_device *dev = uaa->device;
	struct ifnet *ifp = GET_IFP(sc);
	usbf_status err;
	struct usb_cdc_union_descriptor udesc;
	int s;


	/* Set the device identification according to the function. */
	usbf_devinfo_setup(dev, UDCLASS_IN_INTERFACE, 0, 0, CDCEF_VENDOR_ID,
	    CDCEF_PRODUCT_ID, CDCEF_DEVICE_CODE, CDCEF_VENDOR_STRING,
	    CDCEF_PRODUCT_STRING, CDCEF_SERIAL_STRING);

	/* Fill in the fields needed by the parent device. */
	sc->sc_dev.methods = &cdcef_methods;

	/* timeout to start delayed transfers */
	timeout_set(&sc->start_to, cdcef_start_timeout, sc);

	/*
	 * Build descriptors according to the device class specification.
	 */
	err = usbf_add_config(dev, &sc->sc_config);
	if (err) {
		printf(": usbf_add_config failed\n");
		return;
	}
	err = usbf_add_interface(sc->sc_config, UICLASS_CDC,
	    UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL, 0, NULL,
	    &sc->sc_iface);
	if (err) {
		printf(": usbf_add_interface failed\n");
		return;
	}
	/* XXX don't use hard-coded values 128 and 16. */
	err = usbf_add_endpoint(sc->sc_iface, UE_DIR_IN | 2, UE_BULK,
	    64, 16, &sc->sc_ep_in) ||
	    usbf_add_endpoint(sc->sc_iface, UE_DIR_OUT | 1, UE_BULK,
	    64, 16, &sc->sc_ep_out);
	if (err) {
		printf(": usbf_add_endpoint failed\n");
		return;
	}

	/* Append a CDC union descriptor. */
	bzero(&udesc, sizeof udesc);
	udesc.bLength = sizeof udesc;
	udesc.bDescriptorType = UDESC_CS_INTERFACE;
	udesc.bDescriptorSubtype = UDESCSUB_CDC_UNION;
	udesc.bSlaveInterface[0] = usbf_interface_number(sc->sc_iface);
	err = usbf_add_config_desc(sc->sc_config,
	    (usb_descriptor_t *)&udesc, NULL);
	if (err) {
		printf(": usbf_add_config_desc failed\n");
		return;
	}

	/*
	 * Close the configuration and build permanent descriptors.
	 */
	err = usbf_end_config(sc->sc_config);
	if (err) {
		printf(": usbf_end_config failed\n");
		return;
	}

	/* Preallocate xfers and data buffers. */
	sc->sc_xfer_in = usbf_alloc_xfer(dev);
	sc->sc_xfer_out = usbf_alloc_xfer(dev);
	sc->sc_buffer_in = usbf_alloc_buffer(sc->sc_xfer_in,
	    CDCEF_BUFSZ);
	sc->sc_buffer_out = usbf_alloc_buffer(sc->sc_xfer_out,
	    CDCEF_BUFSZ);
	if (sc->sc_buffer_in == NULL || sc->sc_buffer_out == NULL) {
		printf(": usbf_alloc_buffer failed\n");
		return;
	}

	/* Open the bulk pipes. */
	err = usbf_open_pipe(sc->sc_iface,
	    usbf_endpoint_address(sc->sc_ep_out), &sc->sc_pipe_out) ||
	    usbf_open_pipe(sc->sc_iface,
	    usbf_endpoint_address(sc->sc_ep_in), &sc->sc_pipe_in);
	if (err) {
		printf(": usbf_open_pipe failed\n");
		return;
	}

	/* Get ready to receive packets. */
	usbf_setup_xfer(sc->sc_xfer_out, sc->sc_pipe_out, sc,
	    sc->sc_buffer_out, CDCEF_BUFSZ, USBD_SHORT_XFER_OK, 0, cdcef_rxeof);
	err = usbf_transfer(sc->sc_xfer_out);
	if (err && err != USBF_IN_PROGRESS) {
		printf(": usbf_transfer failed\n");
		return;
	}

	s = splnet();

	ether_fakeaddr(ifp);
	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = cdcef_ioctl;
	ifp->if_start = cdcef_start;
	ifp->if_watchdog = cdcef_watchdog;
	strlcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);

	if_attach(ifp);
	ether_ifattach(ifp);

	splx(s);
}

usbf_status
cdcef_do_request(struct usbf_function *fun, usb_device_request_t *req,
    void **data)
{
	printf("cdcef_do_request\n");
	return USBF_STALLED;
}

void
cdcef_start(struct ifnet *ifp)
{
	struct cdcef_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL) {
		return;
	}

	if (sc->sc_listening == 0 || m_head->m_pkthdr.len > CDCEF_BUFSZ) {
		/*
		 * drop packet because receiver is not listening,
		 * or if packet is larger than xmit buffer
		 */
		ifq_deq_commit(&ifp->if_snd, m_head);
		m_freem(m_head);
		return;
	}

	if (cdcef_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
					
	ifq_set_oactive(&ifp->if_snd);

	ifp->if_timer = 6;
}

void
cdcef_txeof(struct usbf_xfer *xfer, void *priv,
    usbf_status err)
{
	struct cdcef_softc *sc = priv;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	s = splnet();
#if 0
	printf("cdcef_txeof: xfer=%p, priv=%p, %s\n", xfer, priv,
	    usbf_errstr(err));
#endif

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (sc->sc_xmit_mbuf != NULL) {
		m_freem(sc->sc_xmit_mbuf);
		sc->sc_xmit_mbuf = NULL;
	}

	if (err)
		ifp->if_oerrors++;
	else
		ifp->if_opackets++;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		timeout_add(&sc->start_to, 1); /* XXX  */

	splx(s);
}
void
cdcef_start_timeout (void *v)
{
	struct cdcef_softc *sc = v;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	s = splnet();
	cdcef_start(ifp);
	splx(s);
}


void
cdcef_rxeof(struct usbf_xfer *xfer, void *priv,
    usbf_status status)
{
	struct cdcef_softc	*sc = priv;
	int total_len = 0;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m = NULL;


	int s;

#if 0
	printf("cdcef_rxeof: xfer=%p, priv=%p, %s\n", xfer, priv,
	    usbf_errstr(status));
#endif

	if (status != USBF_NORMAL_COMPLETION) {
		if (status == USBF_NOT_STARTED || status == USBF_CANCELLED)	
			return;
		if (sc->sc_rxeof_errors == 0)
			printf("%s: usb error on rx: %s\n",
			    DEVNAME(sc), usbf_errstr(status));
		/* XXX - no stalls on client */
		if (sc->sc_rxeof_errors++ > 10) {
			printf("%s: too many errors, disabling\n",
			    DEVNAME(sc));
		}
		goto done;
	}
	sc->sc_rxeof_errors = 0;

	/* upon first incoming packet we know the host is listening */
	if (sc->sc_listening == 0) {
		sc->sc_listening = 1;
	}


	usbf_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	/* total_len -= 4; Strip off CRC added for Zaurus - XXX*/
	if (total_len <= 1)
		goto done;

	if (total_len < sizeof(struct ether_header)) {
		ifp->if_ierrors++;
		goto done;
	}

	if (ifp->if_flags & IFF_RUNNING) {
		m = cdcef_newbuf();
		if (m == NULL) {
			/* message? */
			ifp->if_ierrors++;
			goto done;
		}

		m->m_pkthdr.len = m->m_len = total_len;
		bcopy(sc->sc_buffer_out, mtod(m, char *), total_len);

		ml_enqueue(&ml, m);
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);
done:
	/* Setup another xfer. */
	usbf_setup_xfer(xfer, sc->sc_pipe_out, sc, sc->sc_buffer_out,
	    CDCEF_BUFSZ, USBD_SHORT_XFER_OK, 0, cdcef_rxeof);

	status = usbf_transfer(xfer);
	if (status && status != USBF_IN_PROGRESS) {
		printf("%s: usbf_transfer failed\n", DEVNAME(sc));
		return;
	}
}

struct mbuf *
cdcef_newbuf(void)
{
	struct mbuf		*m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	m->m_len = m->m_pkthdr.len = MCLBYTES;
	m_adj(m, ETHER_ALIGN);

	return (m);
}

int
cdcef_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct cdcef_softc	*sc = ifp->if_softc;
	int			 s, error = 0;

	s = splnet();

	switch (command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			cdcef_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				cdcef_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cdcef_stop(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET)
		error = 0;

	splx(s);
	return (error);
}

void
cdcef_watchdog(struct ifnet *ifp)
{
	struct cdcef_softc	*sc = ifp->if_softc;
	int s;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", DEVNAME(sc));

	s = splusb();
	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	/* cancel receive pipe? */
	usbf_abort_pipe(sc->sc_pipe_in); /* in is tx pipe */
	splx(s);
}

void
cdcef_init(struct cdcef_softc *sc)
{
	struct ifnet    *ifp = GET_IFP(sc);
	int s;

	s = splnet();

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

int
cdcef_encap(struct cdcef_softc *sc, struct mbuf *m, int idx)
{
	usbf_status err;

	m_copydata(m, 0, m->m_pkthdr.len, sc->sc_buffer_in);
	/* NO CRC */

	usbf_setup_xfer(sc->sc_xfer_in, sc->sc_pipe_in, sc, sc->sc_buffer_in,
	    m->m_pkthdr.len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    10000, cdcef_txeof);

	err = usbf_transfer(sc->sc_xfer_in);
	if (err && err != USBD_IN_PROGRESS) {
		printf("encap error\n");
		cdcef_stop(sc);
		return (EIO);
	}
	sc->sc_xmit_mbuf = m;

	return (0);
}


void
cdcef_stop(struct cdcef_softc *sc)
{
	struct ifnet    *ifp = GET_IFP(sc);

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* cancel receive pipe? */

	if (sc->sc_xmit_mbuf != NULL) {
		m_freem(sc->sc_xmit_mbuf);
		sc->sc_xmit_mbuf = NULL;
	}
}
@


1.42
log
@Call ether_fakeaddr() instead of faking Ethernet addresses manually.

Input from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.41 2015/11/25 03:10:00 dlg Exp $	*/
a245 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.41
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.40 2015/11/22 23:56:10 dlg Exp $	*/
a123 2
extern int ticks;

d140 1
a140 1
	struct ifnet *ifp;
a143 1
	u_int16_t macaddr_hi;
d237 1
a237 5
	macaddr_hi = htons(0x2acb);
	bcopy(&macaddr_hi, &sc->sc_arpcom.ac_enaddr[0], sizeof(u_int16_t));
	bcopy(&ticks, &sc->sc_arpcom.ac_enaddr[2], sizeof(u_int32_t));
	sc->sc_arpcom.ac_enaddr[5] = (u_int8_t)(sc->sc_dev.bdev.dv_unit);

a239 1
	ifp = GET_IFP(sc);
@


1.40
log
@too many arguments to function 'ifq_deq_begin'

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.39 2015/11/20 03:35:23 dlg Exp $	*/
d277 1
a277 1
	if(ifp->if_flags & IFF_OACTIVE)
d297 1
a297 1
		ifp->if_flags |= IFF_OACTIVE;
d308 1
a308 1
	ifp->if_flags |= IFF_OACTIVE;
d328 1
a328 1
	ifp->if_flags &= ~IFF_OACTIVE;
d507 1
a507 1
	ifp->if_flags &= ~IFF_OACTIVE;
d523 1
a523 1
	ifp->if_flags &= ~IFF_OACTIVE;
d558 2
a559 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.39
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.38 2015/10/25 12:11:56 mpi Exp $	*/
d280 1
a280 1
	m_head = ifq_deq_begin(&ifp->if_snd, m_head);
@


1.38
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.37 2015/06/24 09:40:54 mpi Exp $	*/
d280 1
a280 1
	IFQ_POLL(&ifp->if_snd, m_head);
d290 1
a290 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d296 1
d301 1
a301 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.37
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.36 2015/04/10 08:41:43 mpi Exp $	*/
a460 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a469 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.36
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.35 2014/12/22 02:28:52 tedu Exp $	*/
a417 1
		ifp->if_ipackets++;
@


1.35
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.34 2014/07/13 15:52:49 mpi Exp $	*/
d364 1
a406 1
	s = splnet();
d412 1
a412 1
			goto done1;
a416 1
		m->m_pkthdr.rcvif = ifp;
d419 1
a419 7

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		ether_input_mbuf(ifp, m);
d422 2
a423 1
done1:
a424 1

@


1.34
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.33 2013/12/07 20:17:42 brad Exp $	*/
a478 1
#ifdef INET
a480 1
#endif
@


1.33
log
@Some cleaning up of the ioctl handling bits to bring things in line
with the other drivers. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.32 2013/12/04 00:52:52 deraadt Exp $	*/
a45 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.32
log
@use dv_unit rather than storing (or forgetting to store...) a local
version
noted by uaa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.31 2013/11/11 10:09:40 mpi Exp $	*/
d479 4
a482 3
		cdcef_init(sc);
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d484 1
a484 2
			break;
		}
d489 3
a491 1
			if (!(ifp->if_flags & IFF_RUNNING))
a496 1
		error = 0;
d531 1
d533 1
a533 3
	struct ifnet    *ifp = GET_IFP(sc);
	if (ifp->if_flags & IFF_RUNNING)
		return;
@


1.31
log
@Kill commented out code dealing with a non existent sc_dying variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.30 2013/10/29 10:01:20 mpi Exp $	*/
a81 1
	int			sc_unit;
d245 1
a245 1
	sc->sc_arpcom.ac_enaddr[5] = (u_int8_t)(sc->sc_unit);
@


1.30
log
@Kill sc_attached, attach and detach events for USB devices are triggered
by the same explore task and cannot happen in parallel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.29 2013/08/07 01:06:41 bluhm Exp $	*/
a386 2
			/* sc->sc_dying = 1; */
			// return;
a514 5

#if 0
	if (sc->sc_dying)
		return;
#endif
@


1.29
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.28 2013/04/15 09:23:01 mglocker Exp $	*/
a82 1
	int			sc_attached;
a262 1
	sc->sc_attached = 1;
@


1.28
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.27 2010/12/30 03:06:31 jakemsr Exp $	*/
a46 1
#include <netinet/in_var.h>
@


1.27
log
@backout previous.  this is not a regular usb device driver, and thus
has no usbd_device.

found the hard way by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.25 2010/06/29 07:12:31 matthew Exp $	*/
d64 8
a71 8
	usbf_config_handle	sc_config;
	usbf_interface_handle	sc_iface;
	usbf_endpoint_handle	sc_ep_in;
	usbf_endpoint_handle	sc_ep_out;
	usbf_pipe_handle	sc_pipe_in;
	usbf_pipe_handle	sc_pipe_out;
	usbf_xfer_handle	sc_xfer_in;
	usbf_xfer_handle	sc_xfer_out;
d91 1
a91 1
usbf_status	cdcef_do_request(usbf_function_handle,
d96 1
a96 1
void		cdcef_txeof(usbf_xfer_handle, usbf_private_handle,
d98 1
a98 1
void		cdcef_rxeof(usbf_xfer_handle, usbf_private_handle,
d146 1
a146 1
	usbf_device_handle dev = uaa->device;
d149 1
a149 1
	usb_cdc_union_descriptor_t udesc;
d270 1
a270 1
cdcef_do_request(usbf_function_handle fun, usb_device_request_t *req,
d319 1
a319 1
cdcef_txeof(usbf_xfer_handle xfer, usbf_private_handle priv,
d364 1
a364 1
cdcef_rxeof(usbf_xfer_handle xfer, usbf_private_handle priv,
@


1.26
log
@* add cfattach activate functions and call usbd_deactivate() in the
  DVACT_DEACTIVATE case for drivers that don't have activate finctions
* fill out cfattach activate functions and call usbd_deactivate() in
  the DVACT_DEACTIVATE case for drivers that don't have a dying flag

"ok with the intent" miod@@
@
text
@a89 1
int		cdcef_activate(struct device *, int);
d109 1
a109 2
	sizeof(struct cdcef_softc), cdcef_match, cdcef_attach, NULL,
	    cdcef_activate
a266 17
}

int
cdcef_activate(struct device *self, int act)
{
	struct cdcef_softc *sc = (struct cdcef_softc *)self;

	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return 0;
@


1.25
log
@Interface drivers should use DV_IFNET, not DV_DULL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.24 2008/12/07 18:47:08 matthieu Exp $	*/
d90 1
d110 2
a111 1
	sizeof(struct cdcef_softc), cdcef_match, cdcef_attach
d269 17
@


1.24
log
@typos in comments: recieve -> receive.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.23 2008/11/29 10:24:33 matthieu Exp $	*/
d113 1
a113 1
	NULL, "cdcef", DV_DULL
@


1.23
log
@Fix damage done by brad@@ and dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.22 2008/11/28 02:44:18 brad Exp $	*/
d293 1
a293 1
		 * drop packet because reciever is not listening,
d533 1
a533 1
	/* cancel recieve pipe? */
d585 1
a585 1
	/* cancel recieve pipe? */
@


1.22
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.21 2008/10/02 20:21:14 brad Exp $	*/
d129 2
a477 1
	struct ifreq		*ifr = (struct ifreq *)data;
d508 1
a508 1
	if (error = ENETRESET)
@


1.21
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.20 2007/11/25 16:40:03 jmc Exp $	*/
a491 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

a502 10
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET)
			error = 0;
		break;

d506 3
@


1.20
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.19 2007/11/13 01:15:43 dlg Exp $	*/
d521 1
a521 2
		error = EINVAL;
		break;
a524 1

@


1.19
log
@fix output after deraadts fixes in usb. prints attach and address info on
one line now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.18 2007/10/11 18:33:14 deraadt Exp $	*/
d160 1
a160 1
	/* timeout to start delayed tranfers */
@


1.18
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.17 2007/06/14 06:55:10 mbalmer Exp $	*/
d168 1
a168 1
		printf("%s: usbf_add_config failed\n", DEVNAME(sc));
d175 1
a175 1
		printf("%s: usbf_add_interface failed\n", DEVNAME(sc));
d184 1
a184 1
		printf("%s: usbf_add_endpoint failed\n", DEVNAME(sc));
d197 1
a197 1
		printf("%s: usbf_add_config_desc failed\n", DEVNAME(sc));
d206 1
a206 1
		printf("%s: usbf_end_config failed\n", DEVNAME(sc));
d218 1
a218 1
		printf("%s: usbf_alloc_buffer failed\n", DEVNAME(sc));
d228 1
a228 1
		printf("%s: usbf_open_pipe failed\n", DEVNAME(sc));
d237 1
a237 1
		printf("%s: usbf_transfer failed\n", DEVNAME(sc));
d248 1
a248 2
	printf("%s: address %s\n", DEVNAME(sc),
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.17
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.16 2007/06/13 11:15:29 mbalmer Exp $	*/
a144 1
	char *devinfop;
a155 4

	devinfop = usbf_devinfo_alloc(dev);
	printf(": %s\n", devinfop);
	usbf_devinfo_free(devinfop);
@


1.16
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.15 2007/06/10 14:49:00 mbalmer Exp $	*/
d32 1
@


1.15
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.14 2007/05/27 10:24:51 jsg Exp $	*/
d437 1
a437 1
		IF_INPUT(ifp, m);
@


1.14
log
@Some other missed bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.13 2007/05/27 04:00:24 jsg Exp $	*/
d126 1
a126 1
#define DEVNAME(sc)	USBDEVNAME((sc)->sc_dev.bdev)
@


1.13
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.12 2007/05/21 05:18:56 jsg Exp $	*/
d451 1
a451 1
		USB_ATTACH_ERROR_RETURN;
@


1.12
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.11 2007/02/26 19:24:27 ckuethe Exp $	*/
d132 2
a133 1
USB_MATCH(cdcef)
d138 2
a139 1
USB_ATTACH(cdcef)
d173 1
a173 1
		USB_ATTACH_ERROR_RETURN;
d180 1
a180 1
		USB_ATTACH_ERROR_RETURN;
d189 1
a189 1
		USB_ATTACH_ERROR_RETURN;
d202 1
a202 1
		USB_ATTACH_ERROR_RETURN;
d211 1
a211 1
		USB_ATTACH_ERROR_RETURN;
d223 1
a223 1
		USB_ATTACH_ERROR_RETURN;
d233 1
a233 1
		USB_ATTACH_ERROR_RETURN;
d242 1
a242 1
		USB_ATTACH_ERROR_RETURN;
a269 2

	USB_ATTACH_SUCCESS_RETURN;
@


1.11
log
@Fix typo, allowing this to compile again. Committed over cdcef0
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.10 2007/02/26 15:41:28 drahn Exp $	*/
d264 1
a264 1
	Ether_ifattach(ifp, sc->cdcef_arpcom.ac_enaddr);
@


1.10
log
@Make the buffer size more reasonable, drop packets that dont fit in buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.9 2007/02/24 21:57:27 drahn Exp $	*/
d294 1
a294 1
	if (sc->sc_listening == 0 || m_head->mpkthdr.len > CDCEF_BUFSZ) {
@


1.9
log
@Add myself to copyright since I took the skeleton driver and made it complete.
Work around a transmit hang problem by setting a delay on transmitting
back-to-back packets. Count dropped packets as input errors.
Abort pipe if a watchdog occurs to clean up state better.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.8 2007/02/23 06:10:08 drahn Exp $	*/
d58 2
a59 1
#define CDCEF_BUFSZ		65536
d294 5
a298 3

	if (sc->sc_listening == 0) {
		/* drop packet because reciever is not listening */
@


1.8
log
@Use FORCE_SHORT_XFER on tx, hardware driver doesn't use it yet, but will.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.7 2007/02/15 20:39:05 drahn Exp $	*/
d4 1
d73 2
d104 1
d161 3
d346 10
a355 1
		cdcef_start(ifp);
d357 2
d362 1
d419 1
a422 1
		/* XXX - buffer big enough? */
d536 1
d546 1
d551 2
a552 5

	if (sc->sc_xmit_mbuf != NULL) {
		m_freem(sc->sc_xmit_mbuf);
		sc->sc_xmit_mbuf = NULL;
	}
@


1.7
log
@Reorder endpoints so that endpoint numbers match, remove more debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.6 2007/02/15 07:00:28 drahn Exp $	*/
d561 2
a562 1
	    m->m_pkthdr.len, USBD_NO_COPY, 10000, cdcef_txeof);
@


1.6
log
@Dont hang completely on watchdog.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.5 2007/02/15 05:09:15 drahn Exp $	*/
d218 1
a218 1
	    usbf_endpoint_address(sc->sc_ep_in), &sc->sc_pipe_in) ||
d220 1
a220 1
	    usbf_endpoint_address(sc->sc_ep_out), &sc->sc_pipe_out);
a225 4
	printf("input pipe %x output pipe %x\n",
	    usbf_endpoint_address(sc->sc_ep_in),
	    usbf_endpoint_address(sc->sc_ep_out));

d320 1
d323 1
a385 2
	printf("recieved %d bytes\n", total_len);

a556 1
	printf("encap len %x m %x\n", m->m_pkthdr.len, m);
a569 1
	printf("encap finished\n");
@


1.5
log
@It is not valid to have the input endpoint and output endpoint the same.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.4 2007/02/15 04:34:44 drahn Exp $	*/
d529 10
@


1.4
log
@USB host is not scanning for packets if attached but cdce is not up.
As an initial workaround for this, do not attempt to send any packets
until a packet has been recieved.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.3 2007/02/13 18:32:56 drahn Exp $	*/
d173 1
a173 1
	err = usbf_add_endpoint(sc->sc_iface, UE_DIR_IN | 1, UE_BULK,
@


1.3
log
@USB client mode with cdce function driver is coming along, RX and TX kinda work.
Limitations include failing to recieve packets that are a multiple of 64 bytes
and sending packets longer than 128 bytes appears to be messed up.
Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.2 2007/02/07 16:26:49 drahn Exp $	*/
d80 1
a264 1

d284 1
d290 8
d379 6
@


1.2
log
@Several improvements to the usb client code. Still not working.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdcef.c,v 1.1 2006/11/25 18:10:29 uwe Exp $	*/
d23 2
d30 1
d39 11
d71 9
d94 6
d137 1
d140 3
d230 2
a231 2
	usbf_setup_xfer(sc->sc_xfer_out, sc->sc_pipe_out, (void *)sc,
	    sc->sc_buffer_out, CDCEF_BUFSZ, 0, 0, cdcef_rxeof);
d238 27
d279 25
d311 2
d314 1
d318 6
a323 7
	/* Setup another xfer. */
	usbf_setup_xfer(xfer, sc->sc_pipe_in, (void *)sc,
	    sc->sc_buffer_in, CDCEF_BUFSZ, 0, 0, cdcef_txeof);
	err = usbf_transfer(xfer);
	if (err && err != USBF_IN_PROGRESS) {
		printf("%s: usbf_transfer failed\n", DEVNAME(sc));
		USB_ATTACH_ERROR_RETURN;
d325 10
d339 1
a339 1
    usbf_status err)
d341 7
a347 1
	struct cdcef_softc *sc = priv;
d349 1
d351 58
a408 1
	    usbf_errstr(err));
d410 1
d412 5
a416 4
	usbf_setup_xfer(xfer, sc->sc_pipe_out, (void *)sc,
	    sc->sc_buffer_out, CDCEF_BUFSZ, 0, 0, cdcef_rxeof);
	err = usbf_transfer(xfer);
	if (err && err != USBF_IN_PROGRESS) {
d419 150
@


1.1
log
@
Initial USB device controller (UDC) and USB CDC Ethernet function support
for PXA27x/Zaurus, not enabled yet; for dlg and dale :)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d139 4
a142 4
	err = usbf_add_endpoint(sc->sc_iface, UE_DIR_IN, UE_BULK,
	    128, 16, &sc->sc_ep_in) ||
	    usbf_add_endpoint(sc->sc_iface, UE_DIR_OUT, UE_BULK,
	    128, 16, &sc->sc_ep_out);
d192 4
d212 1
d232 1
a232 1
	    sc->sc_buffer_in, CDCEF_BUFSZ, 0, 0, cdcef_rxeof);
d246 1
a246 1
	printf("cdcef_txeof: xfer=%p, priv=%p, %s\n", xfer, priv,
@

