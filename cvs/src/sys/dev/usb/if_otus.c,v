head	1.58;
access;
symbols
	OPENBSD_6_1:1.56.0.4
	OPENBSD_6_1_BASE:1.56
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.52.0.2
	OPENBSD_5_9_BASE:1.52
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.10.0.4
	OPENBSD_4_6_BASE:1.10;
locks; strict;
comment	@ * @;


1.58
date	2017.07.03.09.21.09;	author kevlo;	state Exp;
branches;
next	1.57;
commitid	Ssa221KhuyTS2oq4;

1.57
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	6s3MfY9d6ZKdL2Uz;

1.56
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	x5RWYO05Q3UFL5Oq;

1.55
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.54;
commitid	VyLWTsbepAOk7VQM;

1.54
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.53;
commitid	xlY19nmD0cBL53l1;

1.53
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.52;
commitid	gWZDkudwxydTq8x4;

1.52
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.51;
commitid	fbhqfhfdKxBcsetK;

1.51
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.50;
commitid	B0kwmVGiD5DVx4kv;

1.50
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.49;
commitid	FuSD2mFDJWATHIDx;

1.49
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5DvsamK0GblTp8ww;

1.48
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.47;
commitid	YT6fyIEviv9qwbl6;

1.47
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.46;
commitid	pwYnMC1gOKohmeGw;

1.46
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.45;
commitid	p4LJxGKbi0BU2cG6;

1.45
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.44;
commitid	Hly9lJn6CNMylcFu;

1.44
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.43;
commitid	yM2VFFhpDTeFQlve;

1.43
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.42;
commitid	LS2TNeCue5R9L67C;

1.42
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.41;
commitid	Pclvgy2Z4XV9hveD;

1.41
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.40;
commitid	OBNa5kfxQ2UXoiIw;

1.40
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.39;
commitid	b0VSac5dnnsxcDao;

1.39
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2013.11.26.20.33.18;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.05.10.20.04;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.12.19.53.24;	author haesbaert;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2011.02.10.17.26.40;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2011.02.09.04.25.31;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2011.02.05.18.10.44;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.06.19.49.58;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2010.12.27.03.03.50;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.30.18.03.43;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2010.10.30.11.52.29;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.30.11.47.53;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2010.10.30.11.46.47;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.19;

1.19
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.14.20.01.07;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.20.09.18.34;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.17.18.07.09;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.03.17.36.58;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.15.18.44.55;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2009.08.10.17.23.55;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2009.05.23.18.03.41;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.11.20.11.54;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.11.18.06.25;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.06.18.17.01;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.02.19.03.40;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.26.19.54.16;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.26.19.52.51;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.24.19.28.31;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.24.19.18.28;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.23.21.53.57;	author damien;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Replace slot time durations with macros.

ok stsp@@
@
text
@/*	$OpenBSD: if_otus.c,v 1.57 2017/04/08 02:57:25 deraadt Exp $	*/

/*-
 * Copyright (c) 2009 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Atheros AR9001U chipset.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_otusreg.h>

#ifdef OTUS_DEBUG
#define DPRINTF(x)	do { if (otus_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (otus_debug >= (n)) printf x; } while (0)
int otus_debug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

static const struct usb_devno otus_devs[] = {
	{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_WN7512 },
	{ USB_VENDOR_ATHEROS2,		USB_PRODUCT_ATHEROS2_3CRUSBN275 },
	{ USB_VENDOR_ATHEROS2,		USB_PRODUCT_ATHEROS2_TG121N },
	{ USB_VENDOR_ATHEROS2,		USB_PRODUCT_ATHEROS2_AR9170 },
	{ USB_VENDOR_ATHEROS2,		USB_PRODUCT_ATHEROS2_WN612 },
	{ USB_VENDOR_ATHEROS2,		USB_PRODUCT_ATHEROS2_WN821NV2 },
	{ USB_VENDOR_AVM,		USB_PRODUCT_AVM_FRITZWLAN },
	{ USB_VENDOR_CACE,		USB_PRODUCT_CACE_AIRPCAPNX },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWA130D1 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWA160A1 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWA160A2 },
	{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_WNGDNUS2 },
	{ USB_VENDOR_NEC,		USB_PRODUCT_NEC_WL300NUG },
	{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_WN111V2 },
	{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_WNA1000 },
	{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_WNDA3100 },
	{ USB_VENDOR_PLANEX2,		USB_PRODUCT_PLANEX2_GW_US300 },
	{ USB_VENDOR_WISTRONNEWEB,	USB_PRODUCT_WISTRONNEWEB_O8494 },
	{ USB_VENDOR_WISTRONNEWEB,	USB_PRODUCT_WISTRONNEWEB_WNC0600 },
	{ USB_VENDOR_ZCOM,		USB_PRODUCT_ZCOM_UB81 },
	{ USB_VENDOR_ZCOM,		USB_PRODUCT_ZCOM_UB82 },
	{ USB_VENDOR_ZYDAS,		USB_PRODUCT_ZYDAS_ZD1221 },
	{ USB_VENDOR_ZYXEL,		USB_PRODUCT_ZYXEL_NWD271N }
};

int		otus_match(struct device *, void *, void *);
void		otus_attach(struct device *, struct device *, void *);
int		otus_detach(struct device *, int);
void		otus_attachhook(struct device *);
void		otus_get_chanlist(struct otus_softc *);
int		otus_load_firmware(struct otus_softc *, const char *,
		    uint32_t);
int		otus_open_pipes(struct otus_softc *);
void		otus_close_pipes(struct otus_softc *);
int		otus_alloc_tx_cmd(struct otus_softc *);
void		otus_free_tx_cmd(struct otus_softc *);
int		otus_alloc_tx_data_list(struct otus_softc *);
void		otus_free_tx_data_list(struct otus_softc *);
int		otus_alloc_rx_data_list(struct otus_softc *);
void		otus_free_rx_data_list(struct otus_softc *);
void		otus_next_scan(void *);
void		otus_task(void *);
void		otus_do_async(struct otus_softc *,
		    void (*)(struct otus_softc *, void *), void *, int);
int		otus_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
void		otus_newstate_cb(struct otus_softc *, void *);
int		otus_cmd(struct otus_softc *, uint8_t, const void *, int,
		    void *);
void		otus_write(struct otus_softc *, uint32_t, uint32_t);
int		otus_write_barrier(struct otus_softc *);
struct		ieee80211_node *otus_node_alloc(struct ieee80211com *);
int		otus_media_change(struct ifnet *);
int		otus_read_eeprom(struct otus_softc *);
void		otus_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
void		otus_intr(struct usbd_xfer *, void *, usbd_status);
void		otus_cmd_rxeof(struct otus_softc *, uint8_t *, int);
void		otus_sub_rxeof(struct otus_softc *, uint8_t *, int);
void		otus_rxeof(struct usbd_xfer *, void *, usbd_status);
void		otus_txeof(struct usbd_xfer *, void *, usbd_status);
int		otus_tx(struct otus_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		otus_start(struct ifnet *);
void		otus_watchdog(struct ifnet *);
int		otus_ioctl(struct ifnet *, u_long, caddr_t);
int		otus_set_multi(struct otus_softc *);
void		otus_updateedca(struct ieee80211com *);
void		otus_updateedca_cb(struct otus_softc *, void *);
void		otus_updateslot(struct ieee80211com *);
void		otus_updateslot_cb(struct otus_softc *, void *);
int		otus_init_mac(struct otus_softc *);
uint32_t	otus_phy_get_def(struct otus_softc *, uint32_t);
int		otus_set_board_values(struct otus_softc *,
		    struct ieee80211_channel *);
int		otus_program_phy(struct otus_softc *,
		    struct ieee80211_channel *);
int		otus_set_rf_bank4(struct otus_softc *,
		    struct ieee80211_channel *);
void		otus_get_delta_slope(uint32_t, uint32_t *, uint32_t *);
int		otus_set_chan(struct otus_softc *, struct ieee80211_channel *,
		    int);
int		otus_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		otus_set_key_cb(struct otus_softc *, void *);
void		otus_delete_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		otus_delete_key_cb(struct otus_softc *, void *);
void		otus_calibrate_to(void *);
int		otus_set_bssid(struct otus_softc *, const uint8_t *);
int		otus_set_macaddr(struct otus_softc *, const uint8_t *);
void		otus_led_newstate_type1(struct otus_softc *);
void		otus_led_newstate_type2(struct otus_softc *);
void		otus_led_newstate_type3(struct otus_softc *);
int		otus_init(struct ifnet *);
void		otus_stop(struct ifnet *);

struct cfdriver otus_cd = {
	NULL, "otus", DV_IFNET
};

const struct cfattach otus_ca = {
	sizeof (struct otus_softc), otus_match, otus_attach, otus_detach
};

int
otus_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return UMATCH_NONE;

	return (usb_lookup(otus_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
otus_attach(struct device *parent, struct device *self, void *aux)
{
	struct otus_softc *sc = (struct otus_softc *)self;
	struct usb_attach_arg *uaa = aux;
	int error;

	sc->sc_udev = uaa->device;

	usb_init_task(&sc->sc_task, otus_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, otus_next_scan, sc);
	timeout_set(&sc->calib_to, otus_calibrate_to, sc);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 10;

	/* Get the first interface handle. */
	error = usbd_device2interface_handle(sc->sc_udev, 0, &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	if ((error = otus_open_pipes(sc)) != 0) {
		printf("%s: could not open pipes\n", sc->sc_dev.dv_xname);
		return;
	}

	config_mountroot(self, otus_attachhook);
}

int
otus_detach(struct device *self, int flags)
{
	struct otus_softc *sc = (struct otus_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->calib_to))
		timeout_del(&sc->calib_to);

	/* Wait for all queued asynchronous commands to complete. */
	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

	if (ifp->if_softc != NULL) {
		ifp->if_flags &= ~IFF_RUNNING;
		ifq_clr_oactive(&ifp->if_snd);
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}

	otus_close_pipes(sc);

	splx(s);

	return 0;
}

void
otus_attachhook(struct device *self)
{
	struct otus_softc *sc = (struct otus_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usb_device_request_t req;
	uint32_t in, out;
	int error;

	error = otus_load_firmware(sc, "otus-init", AR_FW_INIT_ADDR);
	if (error != 0) {
		printf("%s: could not load %s firmware\n",
		    sc->sc_dev.dv_xname, "init");
		return;
	}

	usbd_delay_ms(sc->sc_udev, 1000);

	error = otus_load_firmware(sc, "otus-main", AR_FW_MAIN_ADDR);
	if (error != 0) {
		printf("%s: could not load %s firmware\n",
		    sc->sc_dev.dv_xname, "main");
		return;
	}

	/* Tell device that firmware transfer is complete. */
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = AR_FW_DOWNLOAD_COMPLETE;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	if (usbd_do_request(sc->sc_udev, &req, NULL) != 0) {
		printf("%s: firmware initialization failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Send an ECHO command to check that everything is settled. */
	in = 0xbadc0ffe;
	if (otus_cmd(sc, AR_CMD_ECHO, &in, sizeof in, &out) != 0) {
		printf("%s: echo command failed\n", sc->sc_dev.dv_xname);
		return;
	}
	if (in != out) {
		printf("%s: echo reply mismatch: 0x%08x!=0x%08x\n",
		    sc->sc_dev.dv_xname, in, out);
		return;
	}

	/* Read entire EEPROM. */
	if (otus_read_eeprom(sc) != 0) {
		printf("%s: could not read EEPROM\n", sc->sc_dev.dv_xname);
		return;
	}

	sc->txmask = sc->eeprom.baseEepHeader.txMask;
	sc->rxmask = sc->eeprom.baseEepHeader.rxMask;
	sc->capflags = sc->eeprom.baseEepHeader.opCapFlags;
	IEEE80211_ADDR_COPY(ic->ic_myaddr, sc->eeprom.baseEepHeader.macAddr);
	sc->sc_led_newstate = otus_led_newstate_type3;	/* XXX */

	printf("%s: MAC/BBP AR9170, RF AR%X, MIMO %dT%dR, address %s\n",
	    sc->sc_dev.dv_xname, (sc->capflags & AR5416_OPFLAGS_11A) ?
	        0x9104 : ((sc->txmask == 0x5) ? 0x9102 : 0x9101),
	    (sc->txmask == 0x5) ? 2 : 1, (sc->rxmask == 0x5) ? 2 : 1,
	    ether_sprintf(ic->ic_myaddr));

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	if (sc->eeprom.baseEepHeader.opCapFlags & AR5416_OPFLAGS_11G) {
		/* Set supported .11b and .11g rates. */
		ic->ic_sup_rates[IEEE80211_MODE_11B] =
		    ieee80211_std_rateset_11b;
		ic->ic_sup_rates[IEEE80211_MODE_11G] =
		    ieee80211_std_rateset_11g;
	}
	if (sc->eeprom.baseEepHeader.opCapFlags & AR5416_OPFLAGS_11A) {
		/* Set supported .11a rates. */
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;
	}

	/* Build the list of supported channels. */
	otus_get_chanlist(sc);

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = otus_ioctl;
	ifp->if_start = otus_start;
	ifp->if_watchdog = otus_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_node_alloc = otus_node_alloc;
	ic->ic_newassoc = otus_newassoc;
	ic->ic_updateslot = otus_updateslot;
	ic->ic_updateedca = otus_updateedca;
#ifdef notyet
	ic->ic_set_key = otus_set_key;
	ic->ic_delete_key = otus_delete_key;
#endif
	/* Override state transition machine. */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = otus_newstate;
	ieee80211_media_init(ifp, otus_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(OTUS_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(OTUS_TX_RADIOTAP_PRESENT);
#endif
}

void
otus_get_chanlist(struct otus_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t domain;
	uint8_t chan;
	int i;

	/* XXX regulatory domain. */
	domain = letoh16(sc->eeprom.baseEepHeader.regDmn[0]);
	DPRINTF(("regdomain=0x%04x\n", domain));

	if (sc->eeprom.baseEepHeader.opCapFlags & AR5416_OPFLAGS_11G) {
		for (i = 0; i < 14; i++) {
			chan = ar_chans[i];
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_2GHZ);
			ic->ic_channels[chan].ic_flags =
			    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
			    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
		}
	}
	if (sc->eeprom.baseEepHeader.opCapFlags & AR5416_OPFLAGS_11A) {
		for (i = 14; i < nitems(ar_chans); i++) {
			chan = ar_chans[i];
			ic->ic_channels[chan].ic_freq =
			    ieee80211_ieee2mhz(chan, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[chan].ic_flags = IEEE80211_CHAN_A;
		}
	}
}

int
otus_load_firmware(struct otus_softc *sc, const char *name, uint32_t addr)
{
	usb_device_request_t req;
	size_t fwsize, size;
	u_char *fw, *ptr;
	int mlen, error;

	/* Read firmware image from the filesystem. */
	if ((error = loadfirmware(name, &fw, &fwsize)) != 0) {
		printf("%s: failed loadfirmware of file %s (error %d)\n",
		    sc->sc_dev.dv_xname, name, error);
		return error;
	}
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = AR_FW_DOWNLOAD;
	USETW(req.wIndex, 0);

	ptr = fw;
	size = fwsize;
	addr >>= 8;
	while (size > 0) {
		mlen = MIN(size, 4096);

		USETW(req.wValue, addr);
		USETW(req.wLength, mlen);
		if (usbd_do_request(sc->sc_udev, &req, ptr) != 0) {
			error = EIO;
			break;
		}
		addr += mlen >> 8;
		ptr  += mlen;
		size -= mlen;
	}
	free(fw, M_DEVBUF, fwsize);
	return error;
}

int
otus_open_pipes(struct otus_softc *sc)
{
	usb_endpoint_descriptor_t *ed;
	int i, isize, error;

	error = usbd_open_pipe(sc->sc_iface, AR_EPT_BULK_RX_NO, 0,
	    &sc->data_rx_pipe);
	if (error != 0) {
		printf("%s: could not open Rx bulk pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	ed = usbd_get_endpoint_descriptor(sc->sc_iface, AR_EPT_INTR_RX_NO);
	if (ed == NULL) {
		printf("%s: could not retrieve Rx intr pipe descriptor\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	isize = UGETW(ed->wMaxPacketSize);
	if (isize == 0) {
		printf("%s: invalid Rx intr pipe descriptor\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	sc->ibuf = malloc(isize, M_USBDEV, M_NOWAIT);
	if (sc->ibuf == NULL) {
		printf("%s: could not allocate Rx intr buffer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	sc->ibuflen = isize;
	error = usbd_open_pipe_intr(sc->sc_iface, AR_EPT_INTR_RX_NO,
	    USBD_SHORT_XFER_OK, &sc->cmd_rx_pipe, sc, sc->ibuf, isize,
	    otus_intr, USBD_DEFAULT_INTERVAL);
	if (error != 0) {
		printf("%s: could not open Rx intr pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_open_pipe(sc->sc_iface, AR_EPT_BULK_TX_NO, 0,
	    &sc->data_tx_pipe);
	if (error != 0) {
		printf("%s: could not open Tx bulk pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	error = usbd_open_pipe(sc->sc_iface, AR_EPT_INTR_TX_NO, 0,
	    &sc->cmd_tx_pipe);
	if (error != 0) {
		printf("%s: could not open Tx intr pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	if (otus_alloc_tx_cmd(sc) != 0) {
		printf("%s: could not allocate command xfer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	if (otus_alloc_tx_data_list(sc) != 0) {
		printf("%s: could not allocate Tx xfers\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	if (otus_alloc_rx_data_list(sc) != 0) {
		printf("%s: could not allocate Rx xfers\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	for (i = 0; i < OTUS_RX_DATA_LIST_COUNT; i++) {
		struct otus_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->data_rx_pipe, data, data->buf,
		    OTUS_RXBUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, otus_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != USBD_IN_PROGRESS && error != 0) {
			printf("%s: could not queue Rx xfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}
	return 0;

 fail:	otus_close_pipes(sc);
	return error;
}

void
otus_close_pipes(struct otus_softc *sc)
{
	otus_free_tx_cmd(sc);
	otus_free_tx_data_list(sc);
	otus_free_rx_data_list(sc);

	if (sc->data_rx_pipe != NULL)
		usbd_close_pipe(sc->data_rx_pipe);
	if (sc->cmd_rx_pipe != NULL) {
		usbd_abort_pipe(sc->cmd_rx_pipe);
		usbd_close_pipe(sc->cmd_rx_pipe);
	}
	if (sc->ibuf != NULL)
		free(sc->ibuf, M_USBDEV, sc->ibuflen);
	if (sc->data_tx_pipe != NULL)
		usbd_close_pipe(sc->data_tx_pipe);
	if (sc->cmd_tx_pipe != NULL)
		usbd_close_pipe(sc->cmd_tx_pipe);
}

int
otus_alloc_tx_cmd(struct otus_softc *sc)
{
	struct otus_tx_cmd *cmd = &sc->tx_cmd;

	cmd->xfer = usbd_alloc_xfer(sc->sc_udev);
	if (cmd->xfer == NULL) {
		printf("%s: could not allocate xfer\n",
		    sc->sc_dev.dv_xname);
		return ENOMEM;
	}
	cmd->buf = usbd_alloc_buffer(cmd->xfer, OTUS_MAX_TXCMDSZ);
	if (cmd->buf == NULL) {
		printf("%s: could not allocate xfer buffer\n",
		    sc->sc_dev.dv_xname);
		usbd_free_xfer(cmd->xfer);
		return ENOMEM;
	}
	return 0;
}

void
otus_free_tx_cmd(struct otus_softc *sc)
{
	/* Make sure no transfers are pending. */
	usbd_abort_pipe(sc->cmd_tx_pipe);

	if (sc->tx_cmd.xfer != NULL)
		usbd_free_xfer(sc->tx_cmd.xfer);
}

int
otus_alloc_tx_data_list(struct otus_softc *sc)
{
	struct otus_tx_data *data;
	int i, error;

	for (i = 0; i < OTUS_TX_DATA_LIST_COUNT; i++) {
		data = &sc->tx_data[i];

		data->sc = sc;  /* Backpointer for callbacks. */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer, OTUS_TXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	otus_free_tx_data_list(sc);
	return error;
}

void
otus_free_tx_data_list(struct otus_softc *sc)
{
	int i;

	/* Make sure no transfers are pending. */
	usbd_abort_pipe(sc->data_tx_pipe);

	for (i = 0; i < OTUS_TX_DATA_LIST_COUNT; i++)
		if (sc->tx_data[i].xfer != NULL)
			usbd_free_xfer(sc->tx_data[i].xfer);
}

int
otus_alloc_rx_data_list(struct otus_softc *sc)
{
	struct otus_rx_data *data;
	int i, error;

	for (i = 0; i < OTUS_RX_DATA_LIST_COUNT; i++) {
		data = &sc->rx_data[i];

		data->sc = sc;	/* Backpointer for callbacks. */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer, OTUS_RXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}
	return 0;

fail:	otus_free_rx_data_list(sc);
	return error;
}

void
otus_free_rx_data_list(struct otus_softc *sc)
{
	int i;

	/* Make sure no transfers are pending. */
	usbd_abort_pipe(sc->data_rx_pipe);

	for (i = 0; i < OTUS_RX_DATA_LIST_COUNT; i++)
		if (sc->rx_data[i].xfer != NULL)
			usbd_free_xfer(sc->rx_data[i].xfer);
}

void
otus_next_scan(void *arg)
{
	struct otus_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	if (sc->sc_ic.ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(&sc->sc_ic.ic_if);

	usbd_ref_decr(sc->sc_udev);
}

void
otus_task(void *arg)
{
	struct otus_softc *sc = arg;
	struct otus_host_cmd_ring *ring = &sc->cmdq;
	struct otus_host_cmd *cmd;
	int s;

	/* Process host commands. */
	s = splusb();
	while (ring->next != ring->cur) {
		cmd = &ring->cmd[ring->next];
		splx(s);
		/* Callback. */
		cmd->cb(sc, cmd->data);
		s = splusb();
		ring->queued--;
		ring->next = (ring->next + 1) % OTUS_HOST_CMD_RING_COUNT;
	}
	splx(s);
}

void
otus_do_async(struct otus_softc *sc, void (*cb)(struct otus_softc *, void *),
    void *arg, int len)
{
	struct otus_host_cmd_ring *ring = &sc->cmdq;
	struct otus_host_cmd *cmd;
	int s;

	s = splusb();
	cmd = &ring->cmd[ring->cur];
	cmd->cb = cb;
	KASSERT(len <= sizeof (cmd->data));
	memcpy(cmd->data, arg, len);
	ring->cur = (ring->cur + 1) % OTUS_HOST_CMD_RING_COUNT;

	/* If there is no pending command already, schedule a task. */
	if (++ring->queued == 1)
		usb_add_task(sc->sc_udev, &sc->sc_task);
	splx(s);
}

int
otus_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct otus_softc *sc = ic->ic_softc;
	struct otus_cmd_newstate cmd;

	/* Do it in a process context. */
	cmd.state = nstate;
	cmd.arg = arg;
	otus_do_async(sc, otus_newstate_cb, &cmd, sizeof cmd);
	return 0;
}

void
otus_newstate_cb(struct otus_softc *sc, void *arg)
{
	struct otus_cmd_newstate *cmd = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	int s;

	s = splnet();

	switch (cmd->state) {
	case IEEE80211_S_INIT:
		break;

	case IEEE80211_S_SCAN:
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan, 0);
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan, 0);
		break;

	case IEEE80211_S_RUN:
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan, 1);

		ni = ic->ic_bss;

		if (ic->ic_opmode == IEEE80211_M_STA) {
			otus_updateslot(ic);
			otus_set_bssid(sc, ni->ni_bssid);

			/* Fake a join to init the Tx rate. */
			otus_newassoc(ic, ni, 1);

			/* Start calibration timer. */
			if (!usbd_is_dying(sc->sc_udev))
				timeout_add_sec(&sc->calib_to, 1);
		}
		break;
	}

	sc->sc_led_newstate(sc);
	(void)sc->sc_newstate(ic, cmd->state, cmd->arg);

	splx(s);
}

int
otus_cmd(struct otus_softc *sc, uint8_t code, const void *idata, int ilen,
    void *odata)
{
	struct otus_tx_cmd *cmd = &sc->tx_cmd;
	struct ar_cmd_hdr *hdr;
	int s, xferlen, error;

	/* Always bulk-out a multiple of 4 bytes. */
	xferlen = (sizeof (*hdr) + ilen + 3) & ~3;

	hdr = (struct ar_cmd_hdr *)cmd->buf;
	hdr->code  = code;
	hdr->len   = ilen;
	hdr->token = ++cmd->token;	/* Don't care about endianness. */
	memcpy((uint8_t *)&hdr[1], idata, ilen);

	DPRINTFN(2, ("sending command code=0x%02x len=%d token=%d\n",
	    code, ilen, hdr->token));

	s = splusb();
	cmd->odata = odata;
	cmd->done = 0;

	usbd_setup_xfer(cmd->xfer, sc->cmd_tx_pipe, cmd, cmd->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY | USBD_SYNCHRONOUS,
	    OTUS_CMD_TIMEOUT, NULL);
	error = usbd_transfer(cmd->xfer);
	if (error != 0) {
		splx(s);
		printf("%s: could not send command 0x%x (error=%s)\n",
		    sc->sc_dev.dv_xname, code, usbd_errstr(error));
		return EIO;
	}
	if (!cmd->done)
		error = tsleep(cmd, PCATCH, "otuscmd", hz);
	cmd->odata = NULL;	/* In case answer is received too late. */
	splx(s);
	if (error != 0) {
		printf("%s: timeout waiting for command 0x%02x reply\n",
		    sc->sc_dev.dv_xname, code);
	}
	return error;
}

void
otus_write(struct otus_softc *sc, uint32_t reg, uint32_t val)
{
	sc->write_buf[sc->write_idx].reg = htole32(reg);
	sc->write_buf[sc->write_idx].val = htole32(val);

	if (++sc->write_idx > AR_MAX_WRITE_IDX)
		(void)otus_write_barrier(sc);
}

int
otus_write_barrier(struct otus_softc *sc)
{
	int error;

	if (sc->write_idx == 0)
		return 0;	/* Nothing to flush. */

	error = otus_cmd(sc, AR_CMD_WREG, sc->write_buf,
	    sizeof (sc->write_buf[0]) * sc->write_idx, NULL);
	sc->write_idx = 0;
	return error;
}

struct ieee80211_node *
otus_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof (struct otus_node), M_DEVBUF, M_NOWAIT | M_ZERO);
}

int
otus_media_change(struct ifnet *ifp)
{
	struct otus_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t rate, ridx;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
		for (ridx = 0; ridx <= OTUS_RIDX_MAX; ridx++)
			if (otus_rates[ridx].rate == rate)
				break;
		sc->fixed_ridx = ridx;
	}

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		error = otus_init(ifp);

	return error;
}

int
otus_read_eeprom(struct otus_softc *sc)
{
	uint32_t regs[8], reg;
	uint8_t *eep;
	int i, j, error;

	/* Read EEPROM by blocks of 32 bytes. */
	eep = (uint8_t *)&sc->eeprom;
	reg = AR_EEPROM_OFFSET;
	for (i = 0; i < sizeof (sc->eeprom) / 32; i++) {
		for (j = 0; j < 8; j++, reg += 4)
			regs[j] = htole32(reg);
		error = otus_cmd(sc, AR_CMD_RREG, regs, sizeof regs, eep);
		if (error != 0)
			break;
		eep += 32;
	}
	return error;
}

void
otus_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct otus_softc *sc = ic->ic_softc;
	struct otus_node *on = (void *)ni;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	uint8_t rate;
	int ridx, i;

	DPRINTF(("new assoc isnew=%d addr=%s\n",
	    isnew, ether_sprintf(ni->ni_macaddr)));

	ieee80211_amrr_node_init(&sc->amrr, &on->amn);
	/* Start at lowest available bit-rate, AMRR will raise. */
	ni->ni_txrate = 0;

	for (i = 0; i < rs->rs_nrates; i++) {
		rate = rs->rs_rates[i] & IEEE80211_RATE_VAL;
		/* Convert 802.11 rate to hardware rate index. */
		for (ridx = 0; ridx <= OTUS_RIDX_MAX; ridx++)
			if (otus_rates[ridx].rate == rate)
				break;
		on->ridx[i] = ridx;
		DPRINTF(("rate=0x%02x ridx=%d\n",
		    rs->rs_rates[i], on->ridx[i]));
	}
}

/* ARGSUSED */
void
otus_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
#if 0
	struct otus_softc *sc = priv;
	int len;

	/*
	 * The Rx intr pipe is unused with current firmware.  Notifications
	 * and replies to commands are sent through the Rx bulk pipe instead
	 * (with a magic PLCP header.)
	 */
	if (__predict_false(status != USBD_NORMAL_COMPLETION)) {
		DPRINTF(("intr status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cmd_rx_pipe);
		return;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	otus_cmd_rxeof(sc, sc->ibuf, len);
#endif
}

void
otus_cmd_rxeof(struct otus_softc *sc, uint8_t *buf, int len)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct otus_tx_cmd *cmd;
	struct ar_cmd_hdr *hdr;
	int s;

	if (__predict_false(len < sizeof (*hdr))) {
		DPRINTF(("cmd too small %d\n", len));
		return;
	}
	hdr = (struct ar_cmd_hdr *)buf;
	if (__predict_false(sizeof (*hdr) + hdr->len > len ||
	    sizeof (*hdr) + hdr->len > 64)) {
		DPRINTF(("cmd too large %d\n", hdr->len));
		return;
	}

	if ((hdr->code & 0xc0) != 0xc0) {
		DPRINTFN(2, ("received reply code=0x%02x len=%d token=%d\n",
		    hdr->code, hdr->len, hdr->token));
		cmd = &sc->tx_cmd;
		if (__predict_false(hdr->token != cmd->token))
			return;
		/* Copy answer into caller's supplied buffer. */
		if (cmd->odata != NULL)
			memcpy(cmd->odata, &hdr[1], hdr->len);
		cmd->done = 1;
		wakeup(cmd);
		return;
	}

	/* Received unsolicited notification. */
	DPRINTF(("received notification code=0x%02x len=%d\n",
	    hdr->code, hdr->len));
	switch (hdr->code & 0x3f) {
	case AR_EVT_BEACON:
		break;
	case AR_EVT_TX_COMP:
	{
		struct ar_evt_tx_comp *tx = (struct ar_evt_tx_comp *)&hdr[1];
		struct ieee80211_node *ni;
		struct otus_node *on;

		DPRINTF(("tx completed %s status=%d phy=0x%x\n",
		    ether_sprintf(tx->macaddr), letoh16(tx->status),
		    letoh32(tx->phy)));
		s = splnet();
#ifdef notyet
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_STA) {
			ni = ieee80211_find_node(ic, tx->macaddr);
			if (__predict_false(ni == NULL)) {
				splx(s);
				break;
			}
		} else
#endif
#endif
			ni = ic->ic_bss;
		/* Update rate control statistics. */
		on = (void *)ni;
		/* NB: we do not set the TX_MAC_RATE_PROBING flag. */
		if (__predict_true(tx->status != 0))
			on->amn.amn_retrycnt++;
		splx(s);
		break;
	}
	case AR_EVT_TBTT:
		break;
	}
}

void
otus_sub_rxeof(struct otus_softc *sc, uint8_t *buf, int len)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct ar_rx_tail *tail;
	struct ieee80211_frame *wh;
	struct mbuf *m;
	uint8_t *plcp;
	int s, mlen, align;

	if (__predict_false(len < AR_PLCP_HDR_LEN)) {
		DPRINTF(("sub-xfer too short %d\n", len));
		return;
	}
	plcp = buf;

	/* All bits in the PLCP header are set to 1 for non-MPDU. */
	if (memcmp(plcp, AR_PLCP_HDR_INTR, AR_PLCP_HDR_LEN) == 0) {
		otus_cmd_rxeof(sc, plcp + AR_PLCP_HDR_LEN,
		    len - AR_PLCP_HDR_LEN);
		return;
	}

	/* Received MPDU. */
	if (__predict_false(len < AR_PLCP_HDR_LEN + sizeof (*tail))) {
		DPRINTF(("MPDU too short %d\n", len));
		ifp->if_ierrors++;
		return;
	}
	tail = (struct ar_rx_tail *)(plcp + len - sizeof (*tail));

	/* Discard error frames. */
	if (__predict_false(tail->error != 0)) {
		DPRINTF(("error frame 0x%02x\n", tail->error));
		if (tail->error & AR_RX_ERROR_FCS) {
			DPRINTFN(3, ("bad FCS\n"));
		} else if (tail->error & AR_RX_ERROR_MMIC) {
			/* Report Michael MIC failures to net80211. */
			ic->ic_stats.is_rx_locmicfail++;
			ieee80211_michael_mic_failure(ic, 0);
		}
		ifp->if_ierrors++;
		return;
	}
	/* Compute MPDU's length. */
	mlen = len - AR_PLCP_HDR_LEN - sizeof (*tail);
	/* Make sure there's room for an 802.11 header + FCS. */
	if (__predict_false(mlen < IEEE80211_MIN_LEN)) {
		ifp->if_ierrors++;
		return;
	}
	mlen -= IEEE80211_CRC_LEN;	/* strip 802.11 FCS */

	wh = (struct ieee80211_frame *)(plcp + AR_PLCP_HDR_LEN);
	/* Provide a 32-bit aligned protocol header to the stack. */
	align = (ieee80211_has_qos(wh) ^ ieee80211_has_addr4(wh)) ? 2 : 0;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (__predict_false(m == NULL)) {
		ifp->if_ierrors++;
		return;
	}
	if (align + mlen > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if (__predict_false(!(m->m_flags & M_EXT))) {
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
	}
	/* Finalize mbuf. */
	m->m_data += align;
	memcpy(mtod(m, caddr_t), wh, mlen);
	m->m_pkthdr.len = m->m_len = mlen;

#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct otus_rx_radiotap_header *tap = &sc->sc_rxtap;
		struct mbuf mb;

		tap->wr_flags = 0;
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wr_antsignal = tail->rssi;
		tap->wr_rate = 2;	/* In case it can't be found below. */
		switch (tail->status & AR_RX_STATUS_MT_MASK) {
		case AR_RX_STATUS_MT_CCK:
			switch (plcp[0]) {
			case  10: tap->wr_rate =   2; break;
			case  20: tap->wr_rate =   4; break;
			case  55: tap->wr_rate =  11; break;
			case 110: tap->wr_rate =  22; break;
			}
			if (tail->status & AR_RX_STATUS_SHPREAMBLE)
				tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
			break;
		case AR_RX_STATUS_MT_OFDM:
			switch (plcp[0] & 0xf) {
			case 0xb: tap->wr_rate =  12; break;
			case 0xf: tap->wr_rate =  18; break;
			case 0xa: tap->wr_rate =  24; break;
			case 0xe: tap->wr_rate =  36; break;
			case 0x9: tap->wr_rate =  48; break;
			case 0xd: tap->wr_rate =  72; break;
			case 0x8: tap->wr_rate =  96; break;
			case 0xc: tap->wr_rate = 108; break;
			}
			break;
		}
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	s = splnet();
	ni = ieee80211_find_rxnode(ic, wh);
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = tail->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* Node is no longer needed. */
	ieee80211_release_node(ic, ni);
	splx(s);
}

void
otus_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct otus_rx_data *data = priv;
	struct otus_softc *sc = data->sc;
	caddr_t buf = data->buf;
	struct ar_rx_head *head;
	uint16_t hlen;
	int len;

	if (__predict_false(status != USBD_NORMAL_COMPLETION)) {
		DPRINTF(("RX status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->data_rx_pipe);
		if (status != USBD_CANCELLED)
			goto resubmit;
		return;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	while (len >= sizeof (*head)) {
		head = (struct ar_rx_head *)buf;
		if (__predict_false(head->tag != htole16(AR_RX_HEAD_TAG))) {
			DPRINTF(("tag not valid 0x%x\n", letoh16(head->tag)));
			break;
		}
		hlen = letoh16(head->len);
		if (__predict_false(sizeof (*head) + hlen > len)) {
			DPRINTF(("xfer too short %d/%d\n", len, hlen));
			break;
		}
		/* Process sub-xfer. */
		otus_sub_rxeof(sc, (uint8_t *)&head[1], hlen);

		/* Next sub-xfer is aligned on a 32-bit boundary. */
		hlen = (sizeof (*head) + hlen + 3) & ~3;
		buf += hlen;
		len -= hlen;
	}

 resubmit:
	usbd_setup_xfer(xfer, sc->data_rx_pipe, data, data->buf, OTUS_RXBUFSZ,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, otus_rxeof);
	(void)usbd_transfer(data->xfer);
}

void
otus_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct otus_tx_data *data = priv;
	struct otus_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	s = splnet();
	sc->tx_queued--;
	if (__predict_false(status != USBD_NORMAL_COMPLETION)) {
		DPRINTF(("TX status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->data_tx_pipe);
		ifp->if_oerrors++;
		splx(s);
		return;
	}
	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	otus_start(ifp);
	splx(s);
}

int
otus_tx(struct otus_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct otus_node *on = (void *)ni;
	struct otus_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct ar_tx_head *head;
	uint32_t phyctl;
	uint16_t macctl, qos;
	uint8_t tid, qid;
	int error, ridx, hasqos, xferlen;

	wh = mtod(m, struct ieee80211_frame *);
	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);
		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return ENOBUFS;
		wh = mtod(m, struct ieee80211_frame *);
	}

	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		qid = ieee80211_up_to_ac(ic, tid);
	} else {
		qos = 0;
		qid = EDCA_AC_BE;
	}

	/* Pickup a rate index. */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_DATA)
		ridx = (ic->ic_curmode == IEEE80211_MODE_11A) ?
		    OTUS_RIDX_OFDM6 : OTUS_RIDX_CCK1;
	else if (ic->ic_fixed_rate != -1)
		ridx = sc->fixed_ridx;
	else
		ridx = on->ridx[ni->ni_txrate];

	phyctl = 0;
	macctl = AR_TX_MAC_BACKOFF | AR_TX_MAC_HW_DUR | AR_TX_MAC_QID(qid);

	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (hasqos && ((qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
	     IEEE80211_QOS_ACK_POLICY_NOACK)))
		macctl |= AR_TX_MAC_NOACK;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		if (m->m_pkthdr.len + IEEE80211_CRC_LEN >= ic->ic_rtsthreshold)
			macctl |= AR_TX_MAC_RTS;
		else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    ridx >= OTUS_RIDX_OFDM6) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				macctl |= AR_TX_MAC_CTS;
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				macctl |= AR_TX_MAC_RTS;
		}
	}

	phyctl |= AR_TX_PHY_MCS(otus_rates[ridx].mcs);
	if (ridx >= OTUS_RIDX_OFDM6) {
		phyctl |= AR_TX_PHY_MT_OFDM;
		if (ridx <= OTUS_RIDX_OFDM24)
			phyctl |= AR_TX_PHY_ANTMSK(sc->txmask);
		else
			phyctl |= AR_TX_PHY_ANTMSK(1);
	} else {	/* CCK */
		phyctl |= AR_TX_PHY_MT_CCK;
		phyctl |= AR_TX_PHY_ANTMSK(sc->txmask);
	}

	/* Update rate control stats for frames that are ACK'ed. */
	if (!(macctl & AR_TX_MAC_NOACK))
		((struct otus_node *)ni)->amn.amn_txcnt++;

	data = &sc->tx_data[sc->tx_cur];
	/* Fill Tx descriptor. */
	head = (struct ar_tx_head *)data->buf;
	head->len = htole16(m->m_pkthdr.len + IEEE80211_CRC_LEN);
	head->macctl = htole16(macctl);
	head->phyctl = htole32(phyctl);

#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct otus_tx_radiotap_header *tap = &sc->sc_txtap;
		struct mbuf mb;

		tap->wt_flags = 0;
		tap->wt_rate = otus_rates[ridx].rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	xferlen = sizeof (*head) + m->m_pkthdr.len;
	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&head[1]);
	m_freem(m);

	DPRINTFN(5, ("tx queued=%d len=%d mac=0x%04x phy=0x%08x rate=%d\n",
	    sc->tx_queued, head->len, head->macctl, head->phyctl,
	    otus_rates[ridx].rate));
	usbd_setup_xfer(data->xfer, sc->data_tx_pipe, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, OTUS_TX_TIMEOUT, otus_txeof);
	error = usbd_transfer(data->xfer);
	if (__predict_false(error != USBD_IN_PROGRESS && error != 0))
		return error;

	ieee80211_release_node(ic, ni);

	sc->tx_queued++;
	sc->tx_cur = (sc->tx_cur + 1) % OTUS_TX_DATA_LIST_COUNT;

	return 0;
}

void
otus_start(struct ifnet *ifp)
{
	struct otus_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->tx_queued >= OTUS_TX_DATA_LIST_COUNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* Send pending management frames first. */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* Encapsulate and send data frames. */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (otus_tx(sc, m, ni) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
otus_watchdog(struct ifnet *ifp)
{
	struct otus_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/* otus_init(ifp); XXX needs a process context! */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}
	ieee80211_watchdog(ifp);
}

int
otus_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct otus_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
				otus_set_multi(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
				otus_init(ifp);

		} else if (ifp->if_flags & IFF_RUNNING)
			otus_stop(ifp);

		sc->sc_if_flags = ifp->if_flags;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				otus_set_chan(sc, ic->ic_ibss_chan, 0);
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			otus_init(ifp);
		error = 0;
	}

	splx(s);

	usbd_ref_decr(sc->sc_udev);

	return error;
}

int
otus_set_multi(struct otus_softc *sc)
{
	struct arpcom *ac = &sc->sc_ic.ic_ac;
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	uint32_t lo, hi;
	uint8_t bit;

	if (ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if ((ifp->if_flags & (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
		lo = hi = 0xffffffff;
		goto done;
	}
	lo = hi = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		bit = enm->enm_addrlo[5] >> 2;
		if (bit < 32)
			lo |= 1 << bit;
		else
			hi |= 1 << (bit - 32);
		ETHER_NEXT_MULTI(step, enm);
	}
 done:
	hi |= 1U << 31;	/* Make sure the broadcast bit is set. */
	otus_write(sc, AR_MAC_REG_GROUP_HASH_TBL_L, lo);
	otus_write(sc, AR_MAC_REG_GROUP_HASH_TBL_H, hi);
	return otus_write_barrier(sc);
}

void
otus_updateedca(struct ieee80211com *ic)
{
	/* Do it in a process context. */
	otus_do_async(ic->ic_softc, otus_updateedca_cb, NULL, 0);
}

/* ARGSUSED */
void
otus_updateedca_cb(struct otus_softc *sc, void *arg)
{
#define EXP2(val)	((1 << (val)) - 1)
#define AIFS(val)	((val) * 9 + 10)
	struct ieee80211com *ic = &sc->sc_ic;
	const struct ieee80211_edca_ac_params *edca;
	int s;

	s = splnet();

	edca = (ic->ic_flags & IEEE80211_F_QOS) ?
	    ic->ic_edca_ac : otus_edca_def;

	/* Set CWmin/CWmax values. */
	otus_write(sc, AR_MAC_REG_AC0_CW,
	    EXP2(edca[EDCA_AC_BE].ac_ecwmax) << 16 |
	    EXP2(edca[EDCA_AC_BE].ac_ecwmin));
	otus_write(sc, AR_MAC_REG_AC1_CW,
	    EXP2(edca[EDCA_AC_BK].ac_ecwmax) << 16 |
	    EXP2(edca[EDCA_AC_BK].ac_ecwmin));
	otus_write(sc, AR_MAC_REG_AC2_CW,
	    EXP2(edca[EDCA_AC_VI].ac_ecwmax) << 16 |
	    EXP2(edca[EDCA_AC_VI].ac_ecwmin));
	otus_write(sc, AR_MAC_REG_AC3_CW,
	    EXP2(edca[EDCA_AC_VO].ac_ecwmax) << 16 |
	    EXP2(edca[EDCA_AC_VO].ac_ecwmin));
	otus_write(sc, AR_MAC_REG_AC4_CW,		/* Special TXQ. */
	    EXP2(edca[EDCA_AC_VO].ac_ecwmax) << 16 |
	    EXP2(edca[EDCA_AC_VO].ac_ecwmin));

	/* Set AIFSN values. */
	otus_write(sc, AR_MAC_REG_AC1_AC0_AIFS,
	    AIFS(edca[EDCA_AC_VI].ac_aifsn) << 24 |
	    AIFS(edca[EDCA_AC_BK].ac_aifsn) << 12 |
	    AIFS(edca[EDCA_AC_BE].ac_aifsn));
	otus_write(sc, AR_MAC_REG_AC3_AC2_AIFS,
	    AIFS(edca[EDCA_AC_VO].ac_aifsn) << 16 |	/* Special TXQ. */
	    AIFS(edca[EDCA_AC_VO].ac_aifsn) <<  4 |
	    AIFS(edca[EDCA_AC_VI].ac_aifsn) >>  8);

	/* Set TXOP limit. */
	otus_write(sc, AR_MAC_REG_AC1_AC0_TXOP,
	    edca[EDCA_AC_BK].ac_txoplimit << 16 |
	    edca[EDCA_AC_BE].ac_txoplimit);
	otus_write(sc, AR_MAC_REG_AC3_AC2_TXOP,
	    edca[EDCA_AC_VO].ac_txoplimit << 16 |
	    edca[EDCA_AC_VI].ac_txoplimit);

	splx(s);

	(void)otus_write_barrier(sc);
#undef AIFS
#undef EXP2
}

void
otus_updateslot(struct ieee80211com *ic)
{
	/* Do it in a process context. */
	otus_do_async(ic->ic_softc, otus_updateslot_cb, NULL, 0);
}

/* ARGSUSED */
void
otus_updateslot_cb(struct otus_softc *sc, void *arg)
{
	uint32_t slottime;

	slottime = (sc->sc_ic.ic_flags & IEEE80211_F_SHSLOT) ?
	    IEEE80211_DUR_DS_SHSLOT: IEEE80211_DUR_DS_SLOT;
	otus_write(sc, AR_MAC_REG_SLOT_TIME, slottime << 10);
	(void)otus_write_barrier(sc);
}

int
otus_init_mac(struct otus_softc *sc)
{
	int error;

	otus_write(sc, AR_MAC_REG_ACK_EXTENSION, 0x40);
	otus_write(sc, AR_MAC_REG_RETRY_MAX, 0);
	otus_write(sc, AR_MAC_REG_SNIFFER, 0x2000000);
	otus_write(sc, AR_MAC_REG_RX_THRESHOLD, 0xc1f80);
	otus_write(sc, AR_MAC_REG_RX_PE_DELAY, 0x70);
	otus_write(sc, AR_MAC_REG_EIFS_AND_SIFS, 0xa144000);
	otus_write(sc, AR_MAC_REG_SLOT_TIME, 9 << 10);
	otus_write(sc, 0x1c3b2c, 0x19000000);
	/* NAV protects ACK only (in TXOP). */
	otus_write(sc, 0x1c3b38, 0x201);
	/* Set beacon Tx power to 0x7. */
	otus_write(sc, AR_MAC_REG_BCN_HT1, 0x8000170);
	otus_write(sc, AR_MAC_REG_BACKOFF_PROTECT, 0x105);
	otus_write(sc, 0x1c3b9c, 0x10000a);
	/* Filter any control frames, BAR is bit 24. */
	otus_write(sc, 0x1c368c, 0x0500ffff);
	otus_write(sc, 0x1c3c40, 0x1);
	otus_write(sc, AR_MAC_REG_BASIC_RATE, 0x150f);
	otus_write(sc, AR_MAC_REG_MANDATORY_RATE, 0x150f);
	otus_write(sc, AR_MAC_REG_RTS_CTS_RATE, 0x10b01bb);
	otus_write(sc, 0x1c3694, 0x4003c1e);
	/* Enable LED0 and LED1. */
	otus_write(sc, 0x1d0100, 0x3);
	otus_write(sc, 0x1d0104, 0x3);
	/* Switch MAC to OTUS interface. */
	otus_write(sc, 0x1c3600, 0x3);
	otus_write(sc, 0x1c3c50, 0xffff);
	otus_write(sc, 0x1c3680, 0xf00008);
	/* Disable Rx timeout (workaround). */
	otus_write(sc, 0x1c362c, 0);

	/* Set USB Rx stream mode maximum frame number to 2. */
	otus_write(sc, 0x1e1110, 0x4);
	/* Set USB Rx stream mode timeout to 10us. */
	otus_write(sc, 0x1e1114, 0x80);

	/* Set clock frequency to 88/80MHz. */
	otus_write(sc, 0x1d4008, 0x73);
	/* Set WLAN DMA interrupt mode: generate intr per packet. */
	otus_write(sc, 0x1c3d7c, 0x110011);
	otus_write(sc, 0x1c3bb0, 0x4);
	otus_write(sc, AR_MAC_REG_TXOP_NOT_ENOUGH_INDICATION, 0x141e0f48);

	/* Disable HW decryption for now. */
	otus_write(sc, 0x1c3678, 0x78);

	if ((error = otus_write_barrier(sc)) != 0)
		return error;

	/* Set default EDCA parameters. */
	otus_updateedca_cb(sc, NULL);

	return 0;
}

/*
 * Return default value for PHY register based on current operating mode.
 */
uint32_t
otus_phy_get_def(struct otus_softc *sc, uint32_t reg)
{
	int i;

	for (i = 0; i < nitems(ar5416_phy_regs); i++)
		if (AR_PHY(ar5416_phy_regs[i]) == reg)
			return sc->phy_vals[i];
	return 0;	/* Register not found. */
}

/*
 * Update PHY's programming based on vendor-specific data stored in EEPROM.
 * This is for FEM-type devices only.
 */
int
otus_set_board_values(struct otus_softc *sc, struct ieee80211_channel *c)
{
	const struct ModalEepHeader *eep;
	uint32_t tmp, offset;

	if (IEEE80211_IS_CHAN_5GHZ(c))
		eep = &sc->eeprom.modalHeader[0];
	else
		eep = &sc->eeprom.modalHeader[1];

	/* Offset of chain 2. */
	offset = 2 * 0x1000;

	tmp = letoh32(eep->antCtrlCommon);
	otus_write(sc, AR_PHY_SWITCH_COM, tmp);

	tmp = letoh32(eep->antCtrlChain[0]);
	otus_write(sc, AR_PHY_SWITCH_CHAIN_0, tmp);

	tmp = letoh32(eep->antCtrlChain[1]);
	otus_write(sc, AR_PHY_SWITCH_CHAIN_0 + offset, tmp);

	if (1 /* sc->sc_sco == AR_SCO_SCN */) {
		tmp = otus_phy_get_def(sc, AR_PHY_SETTLING);
		tmp &= ~(0x7f << 7);
		tmp |= (eep->switchSettling & 0x7f) << 7;
		otus_write(sc, AR_PHY_SETTLING, tmp);
	}

	tmp = otus_phy_get_def(sc, AR_PHY_DESIRED_SZ);
	tmp &= ~0xffff;
	tmp |= eep->pgaDesiredSize << 8 | eep->adcDesiredSize;
	otus_write(sc, AR_PHY_DESIRED_SZ, tmp);

	tmp = eep->txEndToXpaOff << 24 | eep->txEndToXpaOff << 16 |
	      eep->txFrameToXpaOn << 8 | eep->txFrameToXpaOn;
	otus_write(sc, AR_PHY_RF_CTL4, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_RF_CTL3);
	tmp &= ~(0xff << 16);
	tmp |= eep->txEndToRxOn << 16;
	otus_write(sc, AR_PHY_RF_CTL3, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_CCA);
	tmp &= ~(0x7f << 12);
	tmp |= (eep->thresh62 & 0x7f) << 12;
	otus_write(sc, AR_PHY_CCA, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_RXGAIN);
	tmp &= ~(0x3f << 12);
	tmp |= (eep->txRxAttenCh[0] & 0x3f) << 12;
	otus_write(sc, AR_PHY_RXGAIN, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_RXGAIN + offset);
	tmp &= ~(0x3f << 12);
	tmp |= (eep->txRxAttenCh[1] & 0x3f) << 12;
	otus_write(sc, AR_PHY_RXGAIN + offset, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_GAIN_2GHZ);
	tmp &= ~(0x3f << 18);
	tmp |= (eep->rxTxMarginCh[0] & 0x3f) << 18;
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		tmp &= ~(0xf << 10);
		tmp |= (eep->bswMargin[0] & 0xf) << 10;
	}
	otus_write(sc, AR_PHY_GAIN_2GHZ, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_GAIN_2GHZ + offset);
	tmp &= ~(0x3f << 18);
	tmp |= (eep->rxTxMarginCh[1] & 0x3f) << 18;
	otus_write(sc, AR_PHY_GAIN_2GHZ + offset, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_TIMING_CTRL4);
	tmp &= ~(0x3f << 5 | 0x1f);
	tmp |= (eep->iqCalICh[0] & 0x3f) << 5 | (eep->iqCalQCh[0] & 0x1f);
	otus_write(sc, AR_PHY_TIMING_CTRL4, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_TIMING_CTRL4 + offset);
	tmp &= ~(0x3f << 5 | 0x1f);
	tmp |= (eep->iqCalICh[1] & 0x3f) << 5 | (eep->iqCalQCh[1] & 0x1f);
	otus_write(sc, AR_PHY_TIMING_CTRL4 + offset, tmp);

	tmp = otus_phy_get_def(sc, AR_PHY_TPCRG1);
	tmp &= ~(0xf << 16);
	tmp |= (eep->xpd & 0xf) << 16;
	otus_write(sc, AR_PHY_TPCRG1, tmp);

	return otus_write_barrier(sc);
}

int
otus_program_phy(struct otus_softc *sc, struct ieee80211_channel *c)
{
	const uint32_t *vals;
	int error, i;

	/* Select PHY programming based on band and bandwidth. */
	if (IEEE80211_IS_CHAN_2GHZ(c))
		vals = ar5416_phy_vals_2ghz_20mhz;
	else
		vals = ar5416_phy_vals_5ghz_20mhz;
	for (i = 0; i < nitems(ar5416_phy_regs); i++)
		otus_write(sc, AR_PHY(ar5416_phy_regs[i]), vals[i]);
	sc->phy_vals = vals;

	if (sc->eeprom.baseEepHeader.deviceType == 0x80)	/* FEM */
		if ((error = otus_set_board_values(sc, c)) != 0)
			return error;

	/* Initial Tx power settings. */
	otus_write(sc, AR_PHY_POWER_TX_RATE_MAX, 0x7f);
	otus_write(sc, AR_PHY_POWER_TX_RATE1, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE2, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE3, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE4, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE5, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE6, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE7, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE8, 0x3f3f3f3f);
	otus_write(sc, AR_PHY_POWER_TX_RATE9, 0x3f3f3f3f);

	if (IEEE80211_IS_CHAN_2GHZ(c))
		otus_write(sc, 0x1d4014, 0x5163);
	else
		otus_write(sc, 0x1d4014, 0x5143);

	return otus_write_barrier(sc);
}

static __inline uint8_t
otus_reverse_bits(uint8_t v)
{
	v = ((v >> 1) & 0x55) | ((v & 0x55) << 1);
	v = ((v >> 2) & 0x33) | ((v & 0x33) << 2);
	v = ((v >> 4) & 0x0f) | ((v & 0x0f) << 4);
	return v;
}

int
otus_set_rf_bank4(struct otus_softc *sc, struct ieee80211_channel *c)
{
	uint8_t chansel, d0, d1;
	uint16_t data;
	int error;

	d0 = 0;
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		chansel = (c->ic_freq - 4800) / 5;
		if (chansel & 1)
			d0 |= AR_BANK4_AMODE_REFSEL(2);
		else
			d0 |= AR_BANK4_AMODE_REFSEL(1);
	} else {
		d0 |= AR_BANK4_AMODE_REFSEL(2);
		if (c->ic_freq == 2484) {	/* CH 14 */
			d0 |= AR_BANK4_BMODE_LF_SYNTH_FREQ;
			chansel = 10 + (c->ic_freq - 2274) / 5;
		} else
			chansel = 16 + (c->ic_freq - 2272) / 5;
		chansel <<= 2;
	}
	d0 |= AR_BANK4_ADDR(1) | AR_BANK4_CHUP;
	d1 = otus_reverse_bits(chansel);

	/* Write bits 0-4 of d0 and d1. */
	data = (d1 & 0x1f) << 5 | (d0 & 0x1f);
	otus_write(sc, AR_PHY(44), data);
	/* Write bits 5-7 of d0 and d1. */
	data = (d1 >> 5) << 5 | (d0 >> 5);
	otus_write(sc, AR_PHY(58), data);

	if ((error = otus_write_barrier(sc)) == 0)
		usbd_delay_ms(sc->sc_udev, 10);
	return error;
}

void
otus_get_delta_slope(uint32_t coeff, uint32_t *exponent, uint32_t *mantissa)
{
#define COEFF_SCALE_SHIFT	24
	uint32_t exp, man;

	/* exponent = 14 - floor(log2(coeff)) */
	for (exp = 31; exp > 0; exp--)
		if (coeff & (1 << exp))
			break;
	KASSERT(exp != 0);
	exp = 14 - (exp - COEFF_SCALE_SHIFT);

	/* mantissa = floor(coeff * 2^exponent + 0.5) */
	man = coeff + (1 << (COEFF_SCALE_SHIFT - exp - 1));

	*mantissa = man >> (COEFF_SCALE_SHIFT - exp);
	*exponent = exp - 16;
#undef COEFF_SCALE_SHIFT
}

int
otus_set_chan(struct otus_softc *sc, struct ieee80211_channel *c, int assoc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ar_cmd_frequency cmd;
	struct ar_rsp_frequency rsp;
	const uint32_t *vals;
	uint32_t coeff, exp, man, tmp;
	uint8_t code;
	int error, chan, i;

	chan = ieee80211_chan2ieee(ic, c);
	DPRINTF(("setting channel %d (%dMHz)\n", chan, c->ic_freq));

	tmp = IEEE80211_IS_CHAN_2GHZ(c) ? 0x105 : 0x104;
	otus_write(sc, AR_MAC_REG_DYNAMIC_SIFS_ACK, tmp);
	if ((error = otus_write_barrier(sc)) != 0)
		return error;

	/* Disable BB Heavy Clip. */
	otus_write(sc, AR_PHY_HEAVY_CLIP_ENABLE, 0x200);
	if ((error = otus_write_barrier(sc)) != 0)
		return error;

	/* XXX Is that FREQ_START ? */
	error = otus_cmd(sc, AR_CMD_FREQ_STRAT, NULL, 0, NULL);
	if (error != 0)
		return error;

	/* Reprogram PHY and RF on channel band or bandwidth changes. */
	if (sc->bb_reset || c->ic_flags != sc->sc_curchan->ic_flags) {
		DPRINTF(("band switch\n"));

		/* Cold/Warm reset BB/ADDA. */
		otus_write(sc, 0x1d4004, sc->bb_reset ? 0x800 : 0x400);
		if ((error = otus_write_barrier(sc)) != 0)
			return error;
		otus_write(sc, 0x1d4004, 0);
		if ((error = otus_write_barrier(sc)) != 0)
			return error;
		sc->bb_reset = 0;

		if ((error = otus_program_phy(sc, c)) != 0) {
			printf("%s: could not program PHY\n",
			    sc->sc_dev.dv_xname);
			return error;
		}

		/* Select RF programming based on band. */
		if (IEEE80211_IS_CHAN_5GHZ(c))
			vals = ar5416_banks_vals_5ghz;
		else
			vals = ar5416_banks_vals_2ghz;
		for (i = 0; i < nitems(ar5416_banks_regs); i++)
			otus_write(sc, AR_PHY(ar5416_banks_regs[i]), vals[i]);
		if ((error = otus_write_barrier(sc)) != 0) {
			printf("%s: could not program RF\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
		code = AR_CMD_RF_INIT;
	} else {
		code = AR_CMD_FREQUENCY;
	}

	if ((error = otus_set_rf_bank4(sc, c)) != 0)
		return error;

	tmp = (sc->txmask == 0x5) ? 0x340 : 0x240;
	otus_write(sc, AR_PHY_TURBO, tmp);
	if ((error = otus_write_barrier(sc)) != 0)
		return error;

	/* Send firmware command to set channel. */
	cmd.freq = htole32((uint32_t)c->ic_freq * 1000);
	cmd.dynht2040 = htole32(0);
	cmd.htena = htole32(1);
	/* Set Delta Slope (exponent and mantissa). */
	coeff = (100 << 24) / c->ic_freq;
	otus_get_delta_slope(coeff, &exp, &man);
	cmd.dsc_exp = htole32(exp);
	cmd.dsc_man = htole32(man);
	DPRINTF(("ds coeff=%u exp=%u man=%u\n", coeff, exp, man));
	/* For Short GI, coeff is 9/10 that of normal coeff. */
	coeff = (9 * coeff) / 10;
	otus_get_delta_slope(coeff, &exp, &man);
	cmd.dsc_shgi_exp = htole32(exp);
	cmd.dsc_shgi_man = htole32(man);
	DPRINTF(("ds shgi coeff=%u exp=%u man=%u\n", coeff, exp, man));
	/* Set wait time for AGC and noise calibration (100 or 200ms). */
	cmd.check_loop_count = assoc ? htole32(2000) : htole32(1000);
	DPRINTF(("%s\n", (code == AR_CMD_RF_INIT) ? "RF_INIT" : "FREQUENCY"));
	error = otus_cmd(sc, code, &cmd, sizeof cmd, &rsp);
	if (error != 0)
		return error;
	if ((rsp.status & htole32(AR_CAL_ERR_AGC | AR_CAL_ERR_NF_VAL)) != 0) {
		DPRINTF(("status=0x%x\n", letoh32(rsp.status)));
		/* Force cold reset on next channel. */
		sc->bb_reset = 1;
	}
#ifdef OTUS_DEBUG
	if (otus_debug) {
		printf("calibration status=0x%x\n", letoh32(rsp.status));
		for (i = 0; i < 2; i++) {	/* 2 Rx chains */
			/* Sign-extend 9-bit NF values. */
			printf("noisefloor chain %d=%d\n", i,
			    (((int32_t)letoh32(rsp.nf[i])) << 4) >> 23);
			printf("noisefloor ext chain %d=%d\n", i,
			    ((int32_t)letoh32(rsp.nf_ext[i])) >> 23);
		}
	}
#endif
	sc->sc_curchan = c;
	return 0;
}

#ifdef notyet
int
otus_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct otus_softc *sc = ic->ic_softc;
	struct otus_cmd_key cmd;

	/* Defer setting of WEP keys until interface is brought up. */
	if ((ic->ic_if.if_flags & (IFF_UP | IFF_RUNNING)) !=
	    (IFF_UP | IFF_RUNNING))
		return 0;

	/* Do it in a process context. */
	cmd.key = *k;
	cmd.associd = (ni != NULL) ? ni->ni_associd : 0;
	otus_do_async(sc, otus_set_key_cb, &cmd, sizeof cmd);
	return 0;
}

void
otus_set_key_cb(struct otus_softc *sc, void *arg)
{
	struct otus_cmd_key *cmd = arg;
	struct ieee80211_key *k = &cmd->key;
	struct ar_cmd_ekey key;
	uint16_t cipher;
	int error;

	memset(&key, 0, sizeof key);
	if (k->k_flags & IEEE80211_KEY_GROUP) {
		key.uid = htole16(k->k_id);
		IEEE80211_ADDR_COPY(key.macaddr, sc->sc_ic.ic_myaddr);
		key.macaddr[0] |= 0x80;
	} else {
		key.uid = htole16(OTUS_UID(cmd->associd));
		IEEE80211_ADDR_COPY(key.macaddr, ni->ni_macaddr);
	}
	key.kix = htole16(0);
	/* Map net80211 cipher to hardware. */
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		cipher = AR_CIPHER_WEP64;
		break;
	case IEEE80211_CIPHER_WEP104:
		cipher = AR_CIPHER_WEP128;
		break;
	case IEEE80211_CIPHER_TKIP:
		cipher = AR_CIPHER_TKIP;
		break;
	case IEEE80211_CIPHER_CCMP:
		cipher = AR_CIPHER_AES;
		break;
	default:
		return;
	}
	key.cipher = htole16(cipher);
	memcpy(key.key, k->k_key, MIN(k->k_len, 16));
	error = otus_cmd(sc, AR_CMD_EKEY, &key, sizeof key, NULL);
	if (error != 0 || k->k_cipher != IEEE80211_CIPHER_TKIP)
		return;

	/* TKIP: set Tx/Rx MIC Key. */
	key.kix = htole16(1);
	memcpy(key.key, k->k_key + 16, 16);
	(void)otus_cmd(sc, AR_CMD_EKEY, &key, sizeof key, NULL);
}

void
otus_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct otus_softc *sc = ic->ic_softc;
	struct otus_cmd_key cmd;

	if (!(ic->ic_if.if_flags & IFF_RUNNING) ||
	    ic->ic_state != IEEE80211_S_RUN)
		return;	/* Nothing to do. */

	/* Do it in a process context. */
	cmd.key = *k;
	cmd.associd = (ni != NULL) ? ni->ni_associd : 0;
	otus_do_async(sc, otus_delete_key_cb, &cmd, sizeof cmd);
}

void
otus_delete_key_cb(struct otus_softc *sc, void *arg)
{
	struct otus_cmd_key *cmd = arg;
	struct ieee80211_key *k = &cmd->key;
	uint32_t uid;

	if (k->k_flags & IEEE80211_KEY_GROUP)
		uid = htole32(k->k_id);
	else
		uid = htole32(OTUS_UID(cmd->associd));
	(void)otus_cmd(sc, AR_CMD_DKEY, &uid, sizeof uid, NULL);
}
#endif

void
otus_calibrate_to(void *arg)
{
	struct otus_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	s = splnet();
	ni = ic->ic_bss;
	ieee80211_amrr_choose(&sc->amrr, ni, &((struct otus_node *)ni)->amn);
	splx(s);

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->calib_to, 1);

	usbd_ref_decr(sc->sc_udev);
}

int
otus_set_bssid(struct otus_softc *sc, const uint8_t *bssid)
{
	otus_write(sc, AR_MAC_REG_BSSID_L,
	    bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24);
	otus_write(sc, AR_MAC_REG_BSSID_H,
	    bssid[4] | bssid[5] << 8);
	return otus_write_barrier(sc);
}

int
otus_set_macaddr(struct otus_softc *sc, const uint8_t *addr)
{
	otus_write(sc, AR_MAC_REG_MAC_ADDR_L,
	    addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24);
	otus_write(sc, AR_MAC_REG_MAC_ADDR_H,
	    addr[4] | addr[5] << 8);
	return otus_write_barrier(sc);
}

/* Default single-LED. */
void
otus_led_newstate_type1(struct otus_softc *sc)
{
	/* TBD */
}

/* NETGEAR, dual-LED. */
void
otus_led_newstate_type2(struct otus_softc *sc)
{
	/* TBD */
}

/* NETGEAR, single-LED/3 colors (blue, red, purple.) */
void
otus_led_newstate_type3(struct otus_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t state = sc->led_state;

	if (ic->ic_state == IEEE80211_S_INIT) {
		state = 0;	/* LED off. */
	} else if (ic->ic_state == IEEE80211_S_RUN) {
		/* Associated, LED always on. */
		if (IEEE80211_IS_CHAN_2GHZ(sc->sc_curchan))
			state = AR_LED0_ON;	/* 2GHz=>Red. */
		else
			state = AR_LED1_ON;	/* 5GHz=>Blue. */
	} else {
		/* Scanning, blink LED. */
		state ^= AR_LED0_ON | AR_LED1_ON;
		if (IEEE80211_IS_CHAN_2GHZ(sc->sc_curchan))
			state &= ~AR_LED1_ON;
		else
			state &= ~AR_LED0_ON;
	}
	if (state != sc->led_state) {
		otus_write(sc, 0x1d0104, state);
		if (otus_write_barrier(sc) == 0)
			sc->led_state = state;
	}
}

int
otus_init(struct ifnet *ifp)
{
	struct otus_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int error;

	/* Init host command ring. */
	sc->cmdq.cur = sc->cmdq.next = sc->cmdq.queued = 0;

	if ((error = otus_init_mac(sc)) != 0) {
		printf("%s: could not initialize MAC\n", sc->sc_dev.dv_xname);
		return error;
	}

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	(void)otus_set_macaddr(sc, ic->ic_myaddr);

	switch (ic->ic_opmode) {
#ifdef notyet
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_HOSTAP:
		otus_write(sc, 0x1c3700, 0x0f0000a1);
		otus_write(sc, 0x1c3c40, 0x1);
		break;
	case IEEE80211_M_IBSS:
		otus_write(sc, 0x1c3700, 0x0f000000);
		otus_write(sc, 0x1c3c40, 0x1);
		break;
#endif
#endif
	case IEEE80211_M_STA:
		otus_write(sc, 0x1c3700, 0x0f000002);
		otus_write(sc, 0x1c3c40, 0x1);
		break;
	default:
		break;
	}
	otus_write(sc, AR_MAC_REG_SNIFFER,
	    (ic->ic_opmode == IEEE80211_M_MONITOR) ? 0x2000001 : 0x2000000);
	(void)otus_write_barrier(sc);

	sc->bb_reset = 1;	/* Force cold reset. */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	if ((error = otus_set_chan(sc, ic->ic_ibss_chan, 0)) != 0) {
		printf("%s: could not set channel\n", sc->sc_dev.dv_xname);
		return error;
	}

	/* Start Rx. */
	otus_write(sc, 0x1c3d30, 0x100);
	(void)otus_write_barrier(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;
}

void
otus_stop(struct ifnet *ifp)
{
	struct otus_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->scan_to);
	timeout_del(&sc->calib_to);

	s = splusb();
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	/* Wait for all queued asynchronous commands to complete. */
	usb_wait_task(sc->sc_udev, &sc->sc_task);
	splx(s);

	/* Stop Rx. */
	otus_write(sc, 0x1c3d30, 0);
	(void)otus_write_barrier(sc);

	sc->tx_queued = 0;
}
@


1.57
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.56 2017/03/26 15:31:15 deraadt Exp $	*/
d1643 2
a1644 1
	slottime = (sc->sc_ic.ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
@


1.56
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.55 2017/01/22 10:17:39 dlg Exp $	*/
d485 1
d562 1
a562 1
		free(sc->ibuf, M_USBDEV, 0);
@


1.55
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.54 2016/11/06 12:58:01 mpi Exp $	*/
d419 1
a419 1
	size_t size;
d424 1
a424 1
	if ((error = loadfirmware(name, &fw, &size)) != 0) {
d434 1
d449 1
a449 1
	free(fw, M_DEVBUF, 0);
@


1.54
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.53 2016/04/13 11:03:37 mpi Exp $	*/
a1259 1
	ifp->if_opackets++;
@


1.53
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.52 2015/12/11 16:07:02 mpi Exp $	*/
d179 1
a179 1
	if (uaa->iface != NULL)
a200 6

	if (usbd_set_config_no(sc->sc_udev, 1, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.52
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.51 2015/11/25 03:10:00 dlg Exp $	*/
a357 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.51
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.50 2015/11/24 13:45:06 mpi Exp $	*/
d97 1
a97 1
void		otus_attachhook(void *);
d221 1
a221 4
	if (rootvp == NULL)
		mountroothook_establish(otus_attachhook, sc);
	else
		otus_attachhook(sc);
d258 1
a258 1
otus_attachhook(void *xsc)
d260 1
a260 1
	struct otus_softc *sc = xsc;
@


1.50
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.49 2015/11/24 13:33:18 mpi Exp $	*/
d247 2
a248 1
		ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1271 1
a1271 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1409 1
a1409 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1414 1
a1414 1
			ifp->if_flags |= IFF_OACTIVE;
a2289 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2291 1
d2310 2
a2311 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.49
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.48 2015/11/04 12:12:00 dlg Exp $	*/
a41 1
#include <net/if_arp.h>
@


1.48
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.47 2015/10/25 12:11:56 mpi Exp $	*/
a44 1
#include <net/if_types.h>
@


1.47
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.46 2015/03/14 03:38:49 jsg Exp $	*/
d1419 1
a1419 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.46
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.45 2015/02/10 23:25:46 mpi Exp $	*/
a1476 1
	struct ifaddr *ifa;
a1488 1
		ifa = (struct ifaddr *)data;
a1489 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.45
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.44 2014/12/22 02:28:52 tedu Exp $	*/
a35 1
#include <machine/bus.h>
@


1.44
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.43 2014/12/19 22:44:59 guenther Exp $	*/
a1145 1
	m->m_pkthdr.rcvif = ifp;
@


1.43
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.42 2014/07/13 15:52:49 mpi Exp $	*/
a1493 1
#ifdef INET
a1495 1
#endif
@


1.42
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.41 2014/07/12 18:48:52 tedu Exp $	*/
d34 1
a36 1
#include <machine/endian.h>
@


1.41
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.40 2014/07/12 07:59:23 mpi Exp $	*/
a48 1
#include <netinet/in_systm.h>
a49 1
#include <netinet/ip.h>
@


1.40
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.39 2014/03/19 10:09:19 mpi Exp $	*/
d462 1
a462 1
	free(fw, M_DEVBUF);
d574 1
a574 1
		free(sc->ibuf, M_USBDEV);
@


1.39
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.38 2014/03/07 18:39:02 mpi Exp $	*/
a101 1
int		otus_activate(struct device *, int);
d176 1
a176 2
	sizeof (struct otus_softc), otus_match, otus_attach, otus_detach,
	    otus_activate
a259 14

	return 0;
}

int
otus_activate(struct device *self, int act)
{
	struct otus_softc *sc = (struct otus_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.38
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.37 2013/11/26 20:33:18 deraadt Exp $	*/
d1441 1
a1441 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.37
log
@1 << 31 cleanup.  Eitan Adler pointed out that there has been a
resurrection of the bad idiom in the tree.
sufficient review by miod, kettenis, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.36 2013/11/05 10:20:04 mpi Exp $	*/
a62 4

#ifdef USB_DEBUG
#define OTUS_DEBUG
#endif
@


1.36
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.35 2013/08/07 01:06:41 bluhm Exp $	*/
d1600 1
a1600 1
	hi |= 1 << 31;	/* Make sure the broadcast bit is set. */
@


1.35
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.34 2013/04/15 09:23:01 mglocker Exp $	*/
d1582 3
a1591 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			lo = hi = 0xffffffff;
			goto done;
		}
@


1.34
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.33 2013/04/12 12:58:39 mpi Exp $	*/
a49 1
#include <netinet/in_var.h>
@


1.33
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.32 2012/10/12 19:53:24 haesbaert Exp $	*/
d136 1
a136 1
void		otus_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d139 2
a140 2
void		otus_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		otus_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d998 1
a998 1
otus_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1231 1
a1231 1
otus_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1277 1
a1277 1
otus_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.32
log
@Cleanup false positives for uninitialized uses.
Part of the work to remove -Wno-uninitialized.

ok blambert jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.31 2011/07/03 15:47:17 matthew Exp $	*/
d870 3
a872 2
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, OTUS_CMD_TIMEOUT, NULL);
	error = usbd_sync_transfer(cmd->xfer);
@


1.31
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.30 2011/02/10 17:26:40 jakemsr Exp $	*/
d1327 2
a1328 1
	} else
d1330 1
@


1.30
log
@now that usb_wait_task() is back, bring back recently reverted
changes:

* use usb_ref_{incr,decr,wait}() to avoid detaching the driver while a
  process is still using the hardware.
* don't add timeout(9)s if the device is detached.
* add checks to see if the device has been detached before running
  ioctls, timeouts, and tasks.
* use usb_wait_task() to wait for tasks to complete.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.29 2011/02/09 04:25:31 jakemsr Exp $	*/
a276 3
	case DVACT_ACTIVATE:
		break;

@


1.29
log
@revert usb.c to r1.72, and all subsequent changes that depend on it.
this is causing problems with suspend/resume for some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.28 2011/02/05 18:10:44 jakemsr Exp $	*/
d246 1
a246 5
	s = splnet();

	/* Wait for all queued asynchronous commands to complete. */
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
d253 5
d731 5
d738 2
a760 1
	wakeup(ring);
d814 2
a815 1
		timeout_add_msec(&sc->scan_to, 200);
d836 2
a837 1
			timeout_add_sec(&sc->calib_to, 1);
d1506 5
d1567 3
d2191 5
d2201 4
a2204 1
	timeout_add_sec(&sc->calib_to, 1);
d2352 1
a2352 2
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
@


1.28
log
@* use usb_ref_{incr,decr,wait}() to avoid detaching the driver while a
  process is still using the hardware.
* don't add timeout(9)s if the device is detached.
* add checks to see if the device has been detached before running
  ioctls, timeouts, and tasks.
* use usb_wait_task() to wait for tasks to complete.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.27 2011/01/25 20:03:35 jakemsr Exp $	*/
d246 5
a250 1
	s = splusb();
a256 5
	/* Wait for all queued asynchronous commands to complete. */
	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

a729 5
	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

a731 2

	usbd_ref_decr(sc->sc_udev);
d753 1
d807 1
a807 2
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
d828 1
a828 2
			if (!usbd_is_dying(sc->sc_udev))
				timeout_add_sec(&sc->calib_to, 1);
a1496 5
	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);

a1552 3

	usbd_ref_decr(sc->sc_udev);

a2173 5
	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

d2179 1
a2179 4
	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->calib_to, 1);

	usbd_ref_decr(sc->sc_udev);
d2327 2
a2328 1
	usb_wait_task(sc->sc_udev, &sc->sc_task);
@


1.27
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.26 2011/01/06 19:49:58 damien Exp $	*/
d246 1
a246 5
	s = splnet();

	/* Wait for all queued asynchronous commands to complete. */
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
d253 5
d731 5
d738 2
a760 1
	wakeup(ring);
d814 2
a815 1
		timeout_add_msec(&sc->scan_to, 200);
d836 2
a837 1
			timeout_add_sec(&sc->calib_to, 1);
d1506 5
d1567 3
d2191 5
d2201 4
a2204 1
	timeout_add_sec(&sc->calib_to, 1);
d2352 1
a2352 2
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
@


1.26
log
@Remove dead links.
Atheros have reworked their website.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.25 2010/12/27 03:03:50 jakemsr Exp $	*/
a236 2

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);
a265 2

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.25
log
@* add cfattach activate functions and call usbd_deactivate() in the
  DVACT_DEACTIVATE case for drivers that don't have activate finctions
* fill out cfattach activate functions and call usbd_deactivate() in
  the DVACT_DEACTIVATE case for drivers that don't have a dying flag

"ok with the intent" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.24 2010/10/30 18:03:43 damien Exp $	*/
d19 1
a19 1
/*-
a20 1
 * http://www.atheros.com/pt/bulletins/AR9001USBBulletin.pdf
@


1.24
log
@in otus, tx() can return on error without releasing the node
so release the node in the caller (if_start) instead and do
the same in run(4) for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.23 2010/10/30 11:52:29 damien Exp $	*/
d108 1
d183 2
a184 1
	sizeof (struct otus_softc), otus_match, otus_attach, otus_detach
d271 17
@


1.23
log
@always decrement the number of xfers queued in txeof() even
if transfer failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.22 2010/10/30 11:47:53 damien Exp $	*/
a1385 1
	ieee80211_release_node(ic, ni);
d1396 2
d1445 1
@


1.22
log
@don't release the node twice if tx() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.21 2010/10/30 11:46:47 damien Exp $	*/
d1264 2
d1271 1
a1273 2
	s = splnet();
	sc->tx_queued--;
d1275 1
@


1.21
log
@use (ifp->if_softc != NULL) instead of (ifp->if_flags != 0) to check
if interface was attached.
both are correct but this is for consistency with other drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.20 2010/10/23 16:14:07 jakemsr Exp $	*/
a1441 1
			ieee80211_release_node(ic, ni);
@


1.20
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.19 2010/10/23 15:42:09 jakemsr Exp $	*/
d258 1
a258 1
	if (ifp->if_flags != 0) {	/* if_attach() has been called. */
@


1.19
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.18 2010/08/27 17:08:00 jsg Exp $	*/
d253 4
a256 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->calib_to);
@


1.18
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.17 2010/04/20 22:05:43 tedu Exp $	*/
d206 1
a206 1
	usb_init_task(&sc->sc_task, otus_task, sc);
@


1.17
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.16 2010/04/14 20:01:07 damien Exp $	*/
a368 1
	ifp->if_init = otus_init;
@


1.16
log
@more otus(4) ids
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.15 2010/03/20 09:18:34 damien Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.15
log
@NEC Aterm WL300NU-G
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.14 2009/11/17 18:07:09 damien Exp $	*/
d81 23
a103 18
	{ USB_VENDOR_ACCTON,	USB_PRODUCT_ACCTON_WN7512 },
	{ USB_VENDOR_ATHEROS2,	USB_PRODUCT_ATHEROS2_TG121N },
	{ USB_VENDOR_ATHEROS2,	USB_PRODUCT_ATHEROS2_AR9170 },
	{ USB_VENDOR_ATHEROS2,	USB_PRODUCT_ATHEROS2_WN821NV2 },
	{ USB_VENDOR_AVM,	USB_PRODUCT_AVM_FRITZWLAN },
	{ USB_VENDOR_CACE,	USB_PRODUCT_CACE_AIRPCAPNX },
	{ USB_VENDOR_DLINK2,	USB_PRODUCT_DLINK2_DWA130D1 },
	{ USB_VENDOR_DLINK2,	USB_PRODUCT_DLINK2_DWA160A1 },
	{ USB_VENDOR_DLINK2,	USB_PRODUCT_DLINK2_DWA160A2 },
	{ USB_VENDOR_IODATA,	USB_PRODUCT_IODATA_WNGDNUS2 },
	{ USB_VENDOR_NEC,	USB_PRODUCT_NEC_WL300NUG },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_WN111V2 },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_WNDA3100 },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_GW_US300 },
	{ USB_VENDOR_ZCOM,	USB_PRODUCT_ZCOM_UB81 },
	{ USB_VENDOR_ZCOM,	USB_PRODUCT_ZCOM_UB82 },
	{ USB_VENDOR_ZYDAS,	USB_PRODUCT_ZYDAS_ZD1221 },
	{ USB_VENDOR_ZYXEL,	USB_PRODUCT_ZYXEL_NWD271N }
@


1.14
log
@the D-Link DWA-160 rev A2 is an otus(4) too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.13 2009/11/03 17:36:58 damien Exp $	*/
d91 1
@


1.13
log
@setting of WEP keys is defered until interface is brought up,
so do nothing in set_key() if the interface is not up and running.

fixes a panic reported by Steph (frlinux at gmail dot com) with
run(4) on misc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.12 2009/09/15 18:44:55 damien Exp $	*/
d88 2
a89 1
	{ USB_VENDOR_DLINK2,	USB_PRODUCT_DLINK2_DWA160A },
@


1.12
log
@TP-LINK TL-WN821N
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.11 2009/08/10 17:23:55 damien Exp $	*/
d2049 5
@


1.11
log
@undef OTUS_DEBUG.
can't believe this made it into 4.6 :-(
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.10 2009/05/23 18:03:41 jsg Exp $	*/
d84 1
@


1.10
log
@match on D-Link DWA-130 rev D1
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.9 2009/05/11 20:11:54 damien Exp $	*/
a69 2

#define OTUS_DEBUG
@


1.9
log
@attach to more shits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.8 2009/05/11 18:06:25 damien Exp $	*/
d88 1
@


1.8
log
@better scan.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.7 2009/04/06 18:17:01 damien Exp $	*/
d86 1
d95 2
a96 1
	{ USB_VENDOR_ZYDAS,	USB_PRODUCT_ZYDAS_ZD1221 }
@


1.7
log
@do not panic when the device is unplugged.
fix 802.11a rate set for dual-band devices (spotted by Fukaumi Naoki).
+ usual cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.6 2009/04/02 19:03:40 damien Exp $	*/
d149 2
d152 2
a153 1
int		otus_set_chan(struct otus_softc *, struct ieee80211_channel *);
d321 1
d325 4
a328 2
	printf("%s: MIMO %dT%dR, address %s\n", sc->sc_dev.dv_xname,
	    (sc->txmask == 1) ? 1 : 2, (sc->rxmask == 1) ? 1 : 2,
d783 1
a783 1
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan);
d789 1
a789 1
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan);
d793 1
a793 1
		(void)otus_set_chan(sc, ic->ic_bss->ni_chan);
d1511 1
a1511 1
				otus_set_chan(sc, ic->ic_ibss_chan);
d1865 38
d1925 1
a1925 1
otus_set_chan(struct otus_softc *sc, struct ieee80211_channel *c)
d1932 1
a1932 2
	uint16_t data;
	uint8_t code, chansel, d0, d1;
d1936 1
a1936 1
	DPRINTF(("setting channel %d\n", chan));
d1940 2
a1941 1
	(void)otus_write_barrier(sc);
d1945 2
a1946 1
	(void)otus_write_barrier(sc);
d1948 1
d1954 1
a1954 1
	if (1 || c->ic_flags != sc->sc_curchan->ic_flags) {
d1957 4
a1960 3
		/* Reset BB/ADDA. */
		otus_write(sc, 0x1d4004, 0x400);	/* XXX cold/warm */
		(void)otus_write_barrier(sc);
d1962 3
a1964 1
		(void)otus_write_barrier(sc);
d1979 3
a1981 1
		if ((error = otus_write_barrier(sc)) != 0)
d1983 1
a1983 1

d1989 1
a1989 27
	d0 = 0;
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		chansel = (c->ic_freq - 4800) / 5;
		if (chansel & 1)
			d0 |= AR_BANK4_AMODE_REFSEL(2);
		else
			d0 |= AR_BANK4_AMODE_REFSEL(1);
	} else {
		d0 |= AR_BANK4_AMODE_REFSEL(2);
		if (chan == 14) {
			d0 |= AR_BANK4_BMODE_LF_SYNTH_FREQ;
			chansel = 10 + (c->ic_freq - 2274) / 5;
		} else
			chansel = 16 + (c->ic_freq - 2272) / 5;
		chansel <<= 2;
	}
	d0 |= AR_BANK4_ADDR(1) | AR_BANK4_CHUP;
	d1 = otus_reverse_bits(chansel);

	/* Write bits 0-4 of d0 and d1. */
	data = (d1 & 0x1f) << 5 | (d0 & 0x1f);
	otus_write(sc, AR_PHY(44), data);
	/* Write bits 5-7 of d0 and d1. */
	data = (d1 >> 5) << 5 | (d0 >> 5);
	otus_write(sc, AR_PHY(58), data);

	if ((error = otus_write_barrier(sc)) != 0)
a1990 1
	usbd_delay_ms(sc->sc_udev, 10);
d1994 2
a1995 1
	(void)otus_write_barrier(sc);
d2004 4
a2007 4
	cmd.delta_slope_coeff_exp = htole32(exp);
	cmd.delta_slope_coeff_man = htole32(man);
	DPRINTF(("delta slope exp=%u man=%u\n", exp, man));
	/* For Short GI, coeff is 9/10 of normal coeff. */
d2010 5
a2014 5
	cmd.delta_slope_coeff_exp_shgi = htole32(exp);
	cmd.delta_slope_coeff_man_shgi = htole32(man);
	DPRINTF(("delta slope shgi exp=%u man=%u\n", exp, man));
	/* Set wait time for AGC and noise calibration (100ms). */
	cmd.check_loop_count = htole32(1000);
d2016 1
a2016 1
	error = otus_cmd(sc, code, &cmd, sizeof (cmd), &rsp);
d2019 17
a2035 2

	DPRINTF(("status=0x%x\n", letoh32(rsp.status)));
a2036 1

d2154 1
a2154 1
	otus_write(sc, 0x1c3618,
d2156 1
a2156 1
	otus_write(sc, 0x1c361c,
d2257 1
d2259 1
a2259 2
	sc->sc_curchan = &ic->ic_channels[0];	/* Force band switch. */
	if ((error = otus_set_chan(sc, ic->ic_ibss_chan)) != 0) {
@


1.6
log
@get rid of otus_phy_write().
unobfuscate things a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.5 2009/03/26 19:54:16 damien Exp $	*/
d337 12
a348 3
	/* Set supported .11b and .11g rates. */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;
d557 4
d563 2
a564 1
	if (sc->cmd_rx_pipe != NULL)
d566 1
a572 4

	otus_free_tx_cmd(sc);
	otus_free_tx_data_list(sc);
	otus_free_rx_data_list(sc);
d599 1
a599 1
	/* Make sure no transfer is pending. */
d643 1
a643 1
	/* make sure no transfers are pending */
d1096 3
a1098 1
		if (tail->error & AR_RX_ERROR_MMIC) {
d1304 1
a1304 2
	macctl = AR_TX_MAC_BACKOFF | AR_TX_MAC_HW_DUR;
	macctl |= AR_TX_MAC_QID(qid);
d1981 1
d1987 1
d1990 1
a1990 6
	DPRINTF(("%s: exp=%d man=%d exp_shgi=%d man_shgi=%d\n",
	    (code == AR_CMD_RF_INIT) ? "RF_INIT" : "FREQUENCY",
	    letoh32(cmd.delta_slope_coeff_exp),
	    letoh32(cmd.delta_slope_coeff_man),
	    letoh32(cmd.delta_slope_coeff_exp_shgi),
	    letoh32(cmd.delta_slope_coeff_man_shgi)));
d2029 1
d2034 1
a2034 1
	key.kid = htole16(0);
d2059 1
a2059 1
	key.kid = htole16(1);
@


1.5
log
@fix RTS/CTS and CTS-to-self protection.
cleanup prototypes while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.3 2009/03/24 19:28:31 damien Exp $	*/
d316 2
d319 1
d321 2
a322 4
/* XXX */
	sc->sc_led_newstate = otus_led_newstate_type3;

	printf("%s: address %s\n", sc->sc_dev.dv_xname,
d909 1
a909 1
	reg = 0x1600;
d1315 1
a1315 1
			phyctl |= AR_TX_PHY_ANTMSK(5);
d1320 1
a1320 1
		phyctl |= AR_TX_PHY_ANTMSK(5);
a1689 6
static __inline void
otus_phy_write(struct otus_softc *sc, uint32_t reg, uint32_t val)
{
	otus_write(sc, 0x1bc000 + reg, val);
}

d1723 1
a1723 1
	otus_phy_write(sc, AR_PHY_SWITCH_COM, tmp);
d1726 1
a1726 1
	otus_phy_write(sc, AR_PHY_SWITCH_CHAIN_0, tmp);
d1729 1
a1729 1
	otus_phy_write(sc, AR_PHY_SWITCH_CHAIN_0 + offset, tmp);
d1735 1
a1735 1
		otus_phy_write(sc, AR_PHY_SETTLING, tmp);
d1741 1
a1741 1
	otus_phy_write(sc, AR_PHY_DESIRED_SZ, tmp);
d1745 1
a1745 1
	otus_phy_write(sc, AR_PHY_RF_CTL4, tmp);
d1750 1
a1750 1
	otus_phy_write(sc, AR_PHY_RF_CTL3, tmp);
d1755 1
a1755 1
	otus_phy_write(sc, AR_PHY_CCA, tmp);
d1760 1
a1760 1
	otus_phy_write(sc, AR_PHY_RXGAIN, tmp);
d1765 1
a1765 1
	otus_phy_write(sc, AR_PHY_RXGAIN + offset, tmp);
d1774 1
a1774 1
	otus_phy_write(sc, AR_PHY_GAIN_2GHZ, tmp);
d1779 1
a1779 1
	otus_phy_write(sc, AR_PHY_GAIN_2GHZ + offset, tmp);
d1784 1
a1784 1
	otus_phy_write(sc, AR_PHY_TIMING_CTRL4, tmp);
d1789 1
a1789 1
	otus_phy_write(sc, AR_PHY_TIMING_CTRL4 + offset, tmp);
d1791 1
a1791 1
	tmp = otus_phy_get_def(sc, 0xa258);
d1794 1
a1794 1
	otus_phy_write(sc, 0xa258, tmp);
d1811 1
a1811 1
		otus_phy_write(sc, AR_PHY(ar5416_phy_regs[i]), vals[i]);
d1819 10
a1828 10
	otus_phy_write(sc, AR_PHY( 79), 0x7f);
	otus_phy_write(sc, AR_PHY( 77), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY( 78), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(653), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(654), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(739), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(740), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(755), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(756), 0x3f3f3f3f);
	otus_phy_write(sc, AR_PHY(757), 0x3f3f3f3f);
d1888 1
a1888 1
	otus_phy_write(sc, 0x99e0, 0x200);
d1916 2
a1917 4
		for (i = 0; i < nitems(ar5416_banks_regs); i++) {
			otus_phy_write(sc, AR_PHY(ar5416_banks_regs[i]),
			    vals[i]);
		}
d1947 1
a1947 1
	otus_phy_write(sc, AR_PHY(44), data);
d1950 1
a1950 1
	otus_phy_write(sc, AR_PHY(58), data);
d1956 2
a1957 1
	otus_phy_write(sc, AR_PHY(1), 0x100 | 0x240);	/* XXX UB83 */
@


1.4
log
@attach CACE AirPcap Nx.
@
text
@d102 4
a111 11
int		otus_load_firmware(struct otus_softc *, const char *,
		    uint32_t);
int		otus_open_pipes(struct otus_softc *);
void		otus_close_pipes(struct otus_softc *);
int		otus_cmd(struct otus_softc *, uint8_t, const void *, int,
		    void *);
void		otus_write(struct otus_softc *, uint32_t, uint32_t);
int		otus_write_barrier(struct otus_softc *);
void		otus_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
struct		ieee80211_node *otus_node_alloc(struct ieee80211com *);
int		otus_media_change(struct ifnet *);
d119 6
d128 1
a137 1
int		otus_set_beacon(struct otus_softc *);
d305 2
a306 1
		printf("%s: echo reply mismatch\n", sc->sc_dev.dv_xname);
a865 11
/* ARGSUSED */
void
otus_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
{
	/*
	 * The Rx intr pipe is unused with current firmware.  Notifications
	 * and replies to commands are sent through the Rx bulk pipe instead
	 * (with a magic PLCP header.)
	 */
}

d948 25
d1298 2
a1299 8
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    m->m_pkthdr.len + IEEE80211_CRC_LEN >= ic->ic_rtsthreshold)
		macctl |= AR_TX_MAC_RTS;
	else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
	    ridx >= OTUS_RIDX_OFDM6) {
		if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
			macctl |= AR_TX_MAC_CTS;
		else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
d1301 7
d1322 1
a1322 1
	/* Update rate control stats for frames that need an ACK. */
d2223 1
a2223 1
	otus_write_barrier(sc);
@


1.3
log
@report Michael MIC failures to net80211 (can't happen yet since we do
crypto in software.)
increment if_ierrors in Rx error paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.2 2009/03/24 19:18:28 damien Exp $	*/
d86 1
@


1.2
log
@fix Rx rate in radiotap.
implement SIOCS80211CHANNEL ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_otus.c,v 1.1 2009/03/23 21:53:57 damien Exp $	*/
d1061 1
d1069 6
d1080 2
a1081 1
	if (__predict_false(mlen < IEEE80211_MIN_LEN))
d1083 1
@


1.1
log
@otus(4), a driver for Atheros AR9001U USB IEEE 802.11 devices.
more work is required but basic operations work.
requires a non-free firmware to operate.

partly based on source code released under the ISC by Atheros
Communications for Linux, although I had to rewrite almost everything
(actually I only used some .h files from the Atheros driver.)
there also exists a rewrite of the Atheros driver for Linux (ar9170)
but the guy decided to make the code less free by wrapping the GPL
around the ISC.

committed over a NETGEAR WNDA3100.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d245 1
a245 1
	if (ifp->if_flags != 0) {	/* if_attach() has been called */
d1049 1
a1049 1
	plcp = (uint8_t *)buf;
d1113 4
a1116 4
			case 0x0: tap->wr_rate =   2; break;
			case 0x1: tap->wr_rate =   4; break;
			case 0x2: tap->wr_rate =  11; break;
			case 0x3: tap->wr_rate =  22; break;
d1237 1
d1248 1
a1248 1
	if ((hasqos = ieee80211_has_qos(wh)))
d1250 4
d1267 1
a1267 4
#if 0
	/* XXX this can be used to get Tx notifications of success. */
	macctl |= AR_TX_MAC_RATE_PROBING;
#endif
d1461 10
d1516 1
a1516 1
	hi |= 1 << 31;	/* make sure the broadcast bit is set */
d1681 1
a1681 1
	return 0;	/* register not found */
d1867 1
a1867 1
	/* clear bb_heavy_clip_enable */
d1875 1
a1875 1
	/* Reprogram PHY and RF on band or channel bandwidth changes. */
d1927 1
a1927 1
	/* write bits 0-4 of d0 and d1 */
d1930 1
a1930 1
	/* write bits 5-7 of d0 and d1 */
@

