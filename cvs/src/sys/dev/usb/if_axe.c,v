head	1.138;
access;
symbols
	OPENBSD_6_2:1.138.0.2
	OPENBSD_6_2_BASE:1.138
	OPENBSD_6_1:1.138.0.4
	OPENBSD_6_1_BASE:1.138
	OPENBSD_6_0:1.137.0.4
	OPENBSD_6_0_BASE:1.137
	OPENBSD_5_9:1.136.0.2
	OPENBSD_5_9_BASE:1.136
	OPENBSD_5_8:1.132.0.4
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.129.0.2
	OPENBSD_5_7_BASE:1.129
	OPENBSD_5_6:1.126.0.4
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.123.0.4
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.121.0.2
	OPENBSD_5_4_BASE:1.121
	OPENBSD_5_3:1.115.0.2
	OPENBSD_5_3_BASE:1.115
	OPENBSD_5_2:1.109.0.2
	OPENBSD_5_2_BASE:1.109
	OPENBSD_5_1_BASE:1.107
	OPENBSD_5_1:1.107.0.2
	OPENBSD_5_0:1.106.0.2
	OPENBSD_5_0_BASE:1.106
	OPENBSD_4_9:1.105.0.2
	OPENBSD_4_9_BASE:1.105
	OPENBSD_4_8:1.96.0.4
	OPENBSD_4_8_BASE:1.96
	OPENBSD_4_7:1.96.0.2
	OPENBSD_4_7_BASE:1.96
	OPENBSD_4_6:1.92.0.4
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.91.0.2
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.82.0.2
	OPENBSD_4_3_BASE:1.82
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.54.0.4
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.24.0.2
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.138
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.137;
commitid	VyLWTsbepAOk7VQM;

1.137
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.136;
commitid	gWZDkudwxydTq8x4;

1.136
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.135;
commitid	B0kwmVGiD5DVx4kv;

1.135
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.134;
commitid	5gdEnqVoJuTuwdTu;

1.134
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.133;
commitid	eYnPulzvLjDImPCa;

1.133
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.132;
commitid	pwYnMC1gOKohmeGw;

1.132
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.131;
commitid	MVWrtktB46JRxFWT;

1.131
date	2015.06.12.15.47.31;	author mpi;	state Exp;
branches;
next	1.130;
commitid	t0sjCnxjbRqHxJe2;

1.130
date	2015.05.17.02.44.38;	author canacar;	state Exp;
branches;
next	1.129;
commitid	qwMkRBiEn0eRXsn1;

1.129
date	2015.02.12.22.39.27;	author mpi;	state Exp;
branches;
next	1.128;
commitid	KHFldl0qeaWtUFCH;

1.128
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.127;
commitid	yM2VFFhpDTeFQlve;

1.127
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.126;
commitid	Wmnzf8bGQILqXRTG;

1.126
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.125;
commitid	Pclvgy2Z4XV9hveD;

1.125
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.124;
commitid	b0VSac5dnnsxcDao;

1.124
date	2014.04.12.14.02.19;	author jsg;	state Exp;
branches;
next	1.123;

1.123
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.122;

1.122
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.121;

1.121
date	2013.07.02.19.27.15;	author brad;	state Exp;
branches;
next	1.120;

1.120
date	2013.06.03.22.36.15;	author yuo;	state Exp;
branches;
next	1.119;

1.119
date	2013.05.31.15.20.49;	author yuo;	state Exp;
branches;
next	1.118;

1.118
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.117;

1.117
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.04.13.08.06;	author sthen;	state Exp;
branches;
next	1.115;

1.115
date	2012.12.05.23.20.21;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2012.11.28.01.15.33;	author brad;	state Exp;
branches;
next	1.113;

1.113
date	2012.11.21.05.26.18;	author kirby;	state Exp;
branches;
next	1.112;

1.112
date	2012.11.14.17.00.23;	author jcs;	state Exp;
branches;
next	1.111;

1.111
date	2012.11.10.18.46.21;	author brad;	state Exp;
branches;
next	1.110;

1.110
date	2012.09.12.23.35.06;	author jcs;	state Exp;
branches;
next	1.109;

1.109
date	2012.04.01.13.25.13;	author jsg;	state Exp;
branches;
next	1.108;

1.108
date	2012.03.01.04.33.15;	author jsg;	state Exp;
branches;
next	1.107;

1.107
date	2011.09.16.17.20.07;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.104;

1.104
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.103;

1.103
date	2010.11.14.20.38.43;	author weerd;	state Exp;
branches;
next	1.102;

1.102
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.100;

1.100
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.24.03.21.21;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.23.16.58.28;	author yuo;	state Exp;
branches;
next	1.97;

1.97
date	2010.09.21.08.02.49;	author jsg;	state Exp;
branches;
next	1.96;

1.96
date	2010.01.09.05.33.08;	author jsg;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.22.22.13.51;	author jsg;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.93;

1.93
date	2009.09.20.12.53.36;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.13.16.46.55;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.06.02.32.28;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2008.11.02.10.46.10;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.87;

1.87
date	2008.09.21.23.59.20;	author brad;	state Exp;
branches;
next	1.86;

1.86
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.85;

1.85
date	2008.05.14.01.41.10;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.11.09.20.31;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.06.12.51.17;	author mpf;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.22.12.42.40;	author jsg;	state Exp;
branches;
next	1.81;

1.81
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.80;

1.80
date	2007.10.27.22.12.41;	author jsg;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.11.05.42.53;	author mbalmer;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.14.00.46.21;	author jsg;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.05.13.43.25;	author jsg;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.26.17.00.28;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.09.08.57.51;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.09.08.42.55;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.09.08.12.59;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.17.02.19.59;	author jsg;	state Exp;
branches;
next	1.59;

1.59
date	2007.01.18.06.28.11;	author jsg;	state Exp;
branches;
next	1.58;

1.58
date	2007.01.18.04.36.57;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.07.18.24.49;	author reyk;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.04.17.12.07;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.03.19.46.08;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.09.22.46.38;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.06.01.04.27.02;	author pascoe;	state Exp;
branches;
next	1.51;

1.51
date	2006.06.01.04.23.13;	author pascoe;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.01.04.07.46;	author pascoe;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.23.20.21.31;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2006.04.13.15.27.49;	author jolan;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.10.10.15.22;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2005.12.21.12.33.07;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.09.04.51.55;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.29.23.16.58;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.27.21.14.40;	author jolan;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.29.09.21.14;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.28.03.34.33;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2005.08.28.02.55.18;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2005.08.28.02.53.49;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.28.02.51.05;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.28.02.49.25;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.28.02.46.12;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.12.11.56.16;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.11.05.24.17;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2005.08.10.23.07.33;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.18.07.38.43;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.02.22.17.57;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.14.04.08.49;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.12.10.21.04;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.31.02.21.32;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.11.13.01.45;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.11.12.58.45;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.11.12.57.19;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.11.12.38.48;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.11.12.32.57;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.11.12.19.12;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.10.14.01.25;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.04.13.01.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.01.04.08.46;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.18.20.26.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.30.07.28.15;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.20.02.23.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.20.02.15.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.06.17.56.37;	author mcbride;	state Exp;
branches;
next	1.3;

1.3
date	2004.04.25.18.32.11;	author deraadt;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.04.02.08.31.08;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2004.04.02.01.10.09;	author deraadt;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2004.06.07.20.41.31;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.138
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_axe.c,v 1.137 2016/04/13 11:03:37 mpi Exp $	*/

/*
 * Copyright (c) 2005, 2006, 2007 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 1997, 1998, 1999, 2000-2003
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * ASIX Electronics AX88172 USB 2.0 ethernet driver. Used in the
 * LinkSys USB200M and various other adapters.
 *
 * Manuals available from:
 * http://www.asix.com.tw/datasheet/mac/Ax88172.PDF
 * Note: you need the manual for the AX88170 chip (USB 1.x ethernet
 * controller) to find the definitions for the RX control register.
 * http://www.asix.com.tw/datasheet/mac/Ax88170.PDF
 *
 * Written by Bill Paul <wpaul@@windriver.com>
 * Senior Engineer
 * Wind River Systems
 */

/*
 * The AX88172 provides USB ethernet supports at 10 and 100Mbps.
 * It uses an external PHY (reference designs use a Realtek chip),
 * and has a 64-bit multicast hash filter. There is some information
 * missing from the manual which one needs to know in order to make
 * the chip function:
 *
 * - You must set bit 7 in the RX control register, otherwise the
 *   chip won't receive any packets.
 * - You must initialize all 3 IPG registers, or you won't be able
 *   to send any packets.
 *
 * Note that this device appears to only support loading the station
 * address via autoload from the EEPROM (i.e. there's no way to manually
 * set it).
 *
 * (Adam Weinberger wanted me to name this driver if_gir.c.)
 */

/*
 * Ported to OpenBSD 3/28/2004 by Greg Taleck <taleck@@oz.net>
 * with bits and pieces from the aue and url drivers.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_axereg.h>

#ifdef AXE_DEBUG
#define DPRINTF(x)	do { if (axedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (axedebug >= (n)) printf x; } while (0)
int	axedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
const struct axe_type axe_devs[] = {
	{ { USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_UF200}, 0 },
	{ { USB_VENDOR_ACERCM, USB_PRODUCT_ACERCM_EP1427X2}, 0 },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_ETHERNET }, AX772 },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88172}, 0 },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88772}, AX772 },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88772A}, AX772 },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88772B}, AX772 | AX772B },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88772B_1}, AX772 | AX772B },
	{ { USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88178}, AX178 },
	{ { USB_VENDOR_ATEN, USB_PRODUCT_ATEN_UC210T}, 0 },
	{ { USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5D5055 }, AX178 },
	{ { USB_VENDOR_BILLIONTON, USB_PRODUCT_BILLIONTON_USB2AR}, 0},
	{ { USB_VENDOR_CISCOLINKSYS, USB_PRODUCT_CISCOLINKSYS_USB200MV2}, AX772 },
	{ { USB_VENDOR_COREGA, USB_PRODUCT_COREGA_FETHER_USB2_TX }, 0},
	{ { USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DUBE100}, 0 },
	{ { USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DUBE100B1 }, AX772 },
	{ { USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DUBE100C1 }, AX772 | AX772B },
	{ { USB_VENDOR_GOODWAY, USB_PRODUCT_GOODWAY_GWUSB2E}, 0 },
	{ { USB_VENDOR_IODATA, USB_PRODUCT_IODATA_ETGUS2 }, AX178 },
	{ { USB_VENDOR_JVC, USB_PRODUCT_JVC_MP_PRX1}, 0 },
	{ { USB_VENDOR_LENOVO, USB_PRODUCT_LENOVO_ETHERNET }, AX772 | AX772B },
	{ { USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_HG20F9}, AX772 | AX772B },
	{ { USB_VENDOR_LINKSYS2, USB_PRODUCT_LINKSYS2_USB200M}, 0 },
	{ { USB_VENDOR_LINKSYS4, USB_PRODUCT_LINKSYS4_USB1000 }, AX178 },
	{ { USB_VENDOR_LOGITEC, USB_PRODUCT_LOGITEC_LAN_GTJU2}, AX178 },
	{ { USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUAU2GT}, AX178 },
	{ { USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUAU2KTX}, 0 },
	{ { USB_VENDOR_MSI, USB_PRODUCT_MSI_AX88772A}, AX772 },
	{ { USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_FA120}, 0 },
	{ { USB_VENDOR_OQO, USB_PRODUCT_OQO_ETHER01PLUS }, AX772 },
	{ { USB_VENDOR_PLANEX3, USB_PRODUCT_PLANEX3_GU1000T }, AX178 },
	{ { USB_VENDOR_SYSTEMTALKS, USB_PRODUCT_SYSTEMTALKS_SGCX2UL}, 0 },
	{ { USB_VENDOR_SITECOM, USB_PRODUCT_SITECOM_LN029}, 0 },
	{ { USB_VENDOR_SITECOMEU, USB_PRODUCT_SITECOMEU_LN028 }, AX178 }
};

#define axe_lookup(v, p) ((struct axe_type *)usb_lookup(axe_devs, v, p))

int axe_match(struct device *, void *, void *);
void axe_attach(struct device *, struct device *, void *);
int axe_detach(struct device *, int);

struct cfdriver axe_cd = {
	NULL, "axe", DV_IFNET
};

const struct cfattach axe_ca = {
	sizeof(struct axe_softc), axe_match, axe_attach, axe_detach
};

int axe_tx_list_init(struct axe_softc *);
int axe_rx_list_init(struct axe_softc *);
struct mbuf *axe_newbuf(void);
int axe_encap(struct axe_softc *, struct mbuf *, int);
void axe_rxeof(struct usbd_xfer *, void *, usbd_status);
void axe_txeof(struct usbd_xfer *, void *, usbd_status);
void axe_tick(void *);
void axe_tick_task(void *);
void axe_start(struct ifnet *);
int axe_ioctl(struct ifnet *, u_long, caddr_t);
void axe_init(void *);
void axe_stop(struct axe_softc *);
void axe_watchdog(struct ifnet *);
int axe_miibus_readreg(struct device *, int, int);
void axe_miibus_writereg(struct device *, int, int, int);
void axe_miibus_statchg(struct device *);
int axe_cmd(struct axe_softc *, int, int, int, void *);
int axe_ifmedia_upd(struct ifnet *);
void axe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void axe_reset(struct axe_softc *sc);

void axe_iff(struct axe_softc *);
void axe_lock_mii(struct axe_softc *sc);
void axe_unlock_mii(struct axe_softc *sc);

void axe_ax88178_init(struct axe_softc *);
void axe_ax88772_init(struct axe_softc *);

/* Get exclusive access to the MII registers */
void
axe_lock_mii(struct axe_softc *sc)
{
	sc->axe_refcnt++;
	rw_enter_write(&sc->axe_mii_lock);
}

void
axe_unlock_mii(struct axe_softc *sc)
{
	rw_exit_write(&sc->axe_mii_lock);
	if (--sc->axe_refcnt < 0)
		usb_detach_wakeup(&sc->axe_dev);
}

int
axe_cmd(struct axe_softc *sc, int cmd, int index, int val, void *buf)
{
	usb_device_request_t	req;
	usbd_status		err;

	if (usbd_is_dying(sc->axe_udev))
		return(0);

	if (AXE_CMD_DIR(cmd))
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	else
		req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = AXE_CMD_CMD(cmd);
	USETW(req.wValue, val);
	USETW(req.wIndex, index);
	USETW(req.wLength, AXE_CMD_LEN(cmd));

	err = usbd_do_request(sc->axe_udev, &req, buf);

	if (err) {
		DPRINTF(("axe_cmd err: cmd: %d\n", cmd));
		return(-1);
	}

	return(0);
}

int
axe_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct axe_softc	*sc = (void *)dev;
	usbd_status		err;
	uWord			val;
	int			ival;

	if (usbd_is_dying(sc->axe_udev)) {
		DPRINTF(("axe: dying\n"));
		return(0);
	}

#ifdef notdef
	/*
	 * The chip tells us the MII address of any supported
	 * PHYs attached to the chip, so only read from those.
	 */

	DPRINTF(("axe_miibus_readreg: phy 0x%x reg 0x%x\n", phy, reg));

	if (sc->axe_phyaddrs[0] != AXE_NOPHY && phy != sc->axe_phyaddrs[0])
		return (0);

	if (sc->axe_phyaddrs[1] != AXE_NOPHY && phy != sc->axe_phyaddrs[1])
		return (0);
#endif
	if (sc->axe_phyno != phy)
		return (0);

	USETW(val, 0);

	axe_lock_mii(sc);
	axe_cmd(sc, AXE_CMD_MII_OPMODE_SW, 0, 0, NULL);
	err = axe_cmd(sc, AXE_CMD_MII_READ_REG, reg, phy, val);
	axe_cmd(sc, AXE_CMD_MII_OPMODE_HW, 0, 0, NULL);
	axe_unlock_mii(sc);

	if (err) {
		printf("axe%d: read PHY failed\n", sc->axe_unit);
		return(-1);
	}
	DPRINTF(("axe_miibus_readreg: phy 0x%x reg 0x%x val 0x%x\n",
	    phy, reg, UGETW(val)));

	ival = UGETW(val);
	if ((sc->axe_flags & AX772) != 0 && reg == MII_BMSR) {
		/*
		* BMSR of AX88772 indicates that it supports extended
		* capability but the extended status register is
		* revered for embedded ethernet PHY. So clear the
		* extended capability bit of BMSR.
		*/
		ival &= ~BMSR_EXTCAP;
	}

	return (ival);
}

void
axe_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct axe_softc	*sc = (void *)dev;
	usbd_status		err;
	uWord			uval;

	if (usbd_is_dying(sc->axe_udev))
		return;
	if (sc->axe_phyno != phy)
		return;

	USETW(uval, val);

	axe_lock_mii(sc);
	axe_cmd(sc, AXE_CMD_MII_OPMODE_SW, 0, 0, NULL);
	err = axe_cmd(sc, AXE_CMD_MII_WRITE_REG, reg, phy, uval);
	axe_cmd(sc, AXE_CMD_MII_OPMODE_HW, 0, 0, NULL);
	axe_unlock_mii(sc);

	if (err) {
		printf("axe%d: write PHY failed\n", sc->axe_unit);
		return;
	}
}

void
axe_miibus_statchg(struct device *dev)
{
	struct axe_softc	*sc = (void *)dev;
	struct mii_data		*mii = GET_MII(sc);
	struct ifnet		*ifp;
	int			val, err;

	ifp = GET_IFP(sc);
	if (mii == NULL || ifp == NULL ||
	    (ifp->if_flags & IFF_RUNNING) == 0)
		return;

	sc->axe_link = 0;
	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
	    (IFM_ACTIVE | IFM_AVALID)) {
		switch (IFM_SUBTYPE(mii->mii_media_active)) {
		    case IFM_10_T:
		    case IFM_100_TX:
			sc->axe_link++;
			break;
		    case IFM_1000_T:
			if ((sc->axe_flags & AX178) == 0)
			    break;
			sc->axe_link++;
			break;
		    default:
			break;
		}
	}

	/* Lost link, do nothing. */
	if (sc->axe_link == 0)
		return;

	val = 0;
	if ((IFM_OPTIONS(mii->mii_media_active) & IFM_FDX) != 0)
		val |= AXE_MEDIA_FULL_DUPLEX;

	if (sc->axe_flags & AX178 || sc->axe_flags & AX772) {
		val |= (AXE_178_MEDIA_RX_EN | AXE_178_MEDIA_MAGIC);
		if (sc->axe_flags & AX178)
			val |= AXE_178_MEDIA_ENCK;

		switch (IFM_SUBTYPE(mii->mii_media_active)) {
		case IFM_1000_T:
			val |= AXE_178_MEDIA_GMII | AXE_178_MEDIA_ENCK;
			break;
		case IFM_100_TX:
			val |= AXE_178_MEDIA_100TX;
			break;
		case IFM_10_T:
			/* doesn't need to be handled */
			break;
		}
	}

	DPRINTF(("axe_miibus_statchg: val=0x%x\n", val));
	err = axe_cmd(sc, AXE_CMD_WRITE_MEDIA, 0, val, NULL);
	if (err) {
		printf("%s: media change failed\n", sc->axe_dev.dv_xname);
		return;
	}
}

/*
 * Set media options.
 */
int
axe_ifmedia_upd(struct ifnet *ifp)
{
	struct axe_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return (0);
}

/*
 * Report current media status.
 */
void
axe_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct axe_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

void
axe_iff(struct axe_softc *sc)
{
	struct ifnet		*ifp = GET_IFP(sc);
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t		h = 0;
	uWord			urxmode;
	u_int16_t		rxmode;
	u_int8_t		hashtbl[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };

	if (usbd_is_dying(sc->axe_udev))
		return;

	axe_cmd(sc, AXE_CMD_RXCTL_READ, 0, 0, urxmode);
	rxmode = UGETW(urxmode);
	rxmode &= ~(AXE_RXCMD_ALLMULTI | AXE_RXCMD_MULTICAST |
	    AXE_RXCMD_PROMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 * Always accept frames destined to our station address.
	 */
	rxmode |= AXE_RXCMD_BROADCAST;
	if ((sc->axe_flags & (AX178 | AX772)) == 0)
		rxmode |= AXE_172_RXCMD_UNICAST;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= AXE_RXCMD_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxmode |= AXE_RXCMD_PROMISC;
	} else {
		rxmode |= AXE_RXCMD_MULTICAST;

		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			hashtbl[h / 8] |= 1 << (h % 8);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	axe_cmd(sc, AXE_CMD_WRITE_MCAST, 0, 0, (void *)&hashtbl);
	axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, rxmode, NULL);
}

void
axe_reset(struct axe_softc *sc)
{
	if (usbd_is_dying(sc->axe_udev))
		return;
	/* XXX What to reset? */

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);
	return;
}

#define AXE_GPIO_WRITE(x,y) do {                                \
	axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, (x), NULL);          \
	usbd_delay_ms(sc->axe_udev, (y));			\
} while (0)

void
axe_ax88178_init(struct axe_softc *sc)
{
	int gpio0 = 0, phymode = 0, ledmode;
	u_int16_t eeprom, val;

	axe_cmd(sc, AXE_CMD_SROM_WR_ENABLE, 0, 0, NULL);
	/* XXX magic */
	axe_cmd(sc, AXE_CMD_SROM_READ, 0, 0x0017, &eeprom);
	axe_cmd(sc, AXE_CMD_SROM_WR_DISABLE, 0, 0, NULL);

	eeprom = letoh16(eeprom);

	DPRINTF((" EEPROM is 0x%x\n", eeprom));

	/* if EEPROM is invalid we have to use to GPIO0 */
	if (eeprom == 0xffff) {
		phymode = AXE_PHY_MODE_MARVELL;
		gpio0 = 1;
		ledmode = 0;
	} else {
		phymode = eeprom & 0x7f;
		gpio0 = (eeprom & 0x80) ? 0 : 1;
		ledmode = eeprom >> 8;
	}

	DPRINTF(("use gpio0: %d, phymode 0x%02x, eeprom 0x%04x\n",
	    gpio0, phymode, eeprom));

	/* power up external phy */
	AXE_GPIO_WRITE(AXE_GPIO1|AXE_GPIO1_EN | AXE_GPIO_RELOAD_EEPROM, 40);
	if (ledmode == 1) {
		AXE_GPIO_WRITE(AXE_GPIO1_EN, 30);
		AXE_GPIO_WRITE(AXE_GPIO1_EN | AXE_GPIO1, 30);
	} else {
		val = gpio0 == 1 ? AXE_GPIO0 | AXE_GPIO0_EN : 
	    	    AXE_GPIO1 | AXE_GPIO1_EN;
		AXE_GPIO_WRITE(val | AXE_GPIO2 | AXE_GPIO2_EN, 30);
		AXE_GPIO_WRITE(val | AXE_GPIO2_EN, 300);
		AXE_GPIO_WRITE(val | AXE_GPIO2 | AXE_GPIO2_EN, 30);
	}

	/* initialize phy */
	if (phymode == AXE_PHY_MODE_REALTEK_8211CL) {
		axe_miibus_writereg(&sc->axe_dev, sc->axe_phyno, 0x1f, 0x0005);
		axe_miibus_writereg(&sc->axe_dev, sc->axe_phyno, 0x0c, 0x0000);
		val = axe_miibus_readreg(&sc->axe_dev, sc->axe_phyno, 0x0001);
		axe_miibus_writereg(&sc->axe_dev, sc->axe_phyno, 0x01,
		    val | 0x0080);
		axe_miibus_writereg(&sc->axe_dev, sc->axe_phyno, 0x1f, 0x0000);
	}

	/* soft reset */
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, AXE_SW_RESET_CLEAR, NULL);
	usbd_delay_ms(sc->axe_udev, 150);
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0,
	    AXE_SW_RESET_PRL | AXE_178_RESET_MAGIC, NULL);
	usbd_delay_ms(sc->axe_udev, 150);
	/* Enable MII/GMII/RGMII for external PHY */
	axe_cmd(sc, AXE_CMD_SW_PHY_SELECT, 0, 0, NULL);
	usbd_delay_ms(sc->axe_udev, 10);
	axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, 0, NULL);
}

/* Read Ethernet Address from EEPROM if it is zero */
void
axe_ax88772b_nodeid(struct axe_softc *sc, u_char *eaddr)
{
	int i;
	uint16_t val;

	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		if (eaddr[i] != 0)
			break;
	}

	/* We already have an ethernet address */
	if (i != ETHER_ADDR_LEN)
		return;

	/* read from EEPROM */
	for (i = 0; i < ETHER_ADDR_LEN/2; i++) {
		axe_cmd(sc, AXE_CMD_SROM_READ, 0, AXE_EEPROM_772B_NODEID + i, &val);
		val = ntohs(val);
		*eaddr++ = (u_char)((val >> 8) & 0xff);
		*eaddr++ = (u_char)(val & 0xff);
	}
}

void
axe_ax88772_init(struct axe_softc *sc)
{
	axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x00b0, NULL);
	usbd_delay_ms(sc->axe_udev, 40);

	if (sc->axe_phyno == AXE_PHY_NO_AX772_EPHY) {
		/* ask for the embedded PHY */
		axe_cmd(sc, AXE_CMD_SW_PHY_SELECT, 0, 0x01, NULL);
		usbd_delay_ms(sc->axe_udev, 10);

		/* power down and reset state, pin reset state */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, AXE_SW_RESET_CLEAR, NULL);
		usbd_delay_ms(sc->axe_udev, 60);

		/* power down/reset state, pin operating state */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0,
		    AXE_SW_RESET_IPPD | AXE_SW_RESET_PRL, NULL);
		usbd_delay_ms(sc->axe_udev, 150);

		/* power up, reset */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, AXE_SW_RESET_PRL, NULL);

		/* power up, operating */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0,
		    AXE_SW_RESET_IPRL | AXE_SW_RESET_PRL, NULL);
	} else {
		/* ask for external PHY */
		axe_cmd(sc, AXE_CMD_SW_PHY_SELECT, 0, 0x00, NULL);
		usbd_delay_ms(sc->axe_udev, 10);

		/* power down internal PHY */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0,
		    AXE_SW_RESET_IPPD | AXE_SW_RESET_PRL, NULL);
	}

	usbd_delay_ms(sc->axe_udev, 150);
	axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, 0, NULL);
}

static int
axe_get_phyno(struct axe_softc *sc, int sel)
{
	int phyno = -1;

	switch (AXE_PHY_TYPE(sc->axe_phyaddrs[sel])) {
	case PHY_TYPE_100_HOME:
	case PHY_TYPE_GIG:
		phyno  = AXE_PHY_NO(sc->axe_phyaddrs[sel]);
		break;
	case PHY_TYPE_SPECIAL:
		/* FALLTHROUGH */
	case PHY_TYPE_RSVD:
		/* FALLTHROUGH */
	case PHY_TYPE_NON_SUP:
		/* FALLTHROUGH */
	default:
		break;
	}

	return (phyno);
}

/*
 * Probe for a AX88172 chip.
 */
int
axe_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return (axe_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
axe_attach(struct device *parent, struct device *self, void *aux)
{
	struct axe_softc *sc = (struct axe_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct mii_data	*mii;
	u_char eaddr[ETHER_ADDR_LEN];
	char *devname = sc->axe_dev.dv_xname;
	struct ifnet *ifp;
	int i, s;

	sc->axe_unit = self->dv_unit; /*device_get_unit(self);*/
	sc->axe_udev = uaa->device;
	sc->axe_iface = uaa->iface;
	sc->axe_flags = axe_lookup(uaa->vendor, uaa->product)->axe_flags;

	usb_init_task(&sc->axe_tick_task, axe_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->axe_mii_lock, "axemii");
	usb_init_task(&sc->axe_stop_task, (void (*)(void *))axe_stop, sc,
	    USB_TASK_TYPE_GENERIC);

	sc->axe_product = uaa->product;
	sc->axe_vendor = uaa->vendor;

	id = usbd_get_interface_descriptor(sc->axe_iface);

	/* decide on what our bufsize will be */
	if (sc->axe_flags & (AX178 | AX772))
		sc->axe_bufsz = (sc->axe_udev->speed == USB_SPEED_HIGH) ?
		    AXE_178_MAX_BUFSZ : AXE_178_MIN_BUFSZ;
	else
		sc->axe_bufsz = AXE_172_BUFSZ;

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->axe_iface, i);
		if (!ed) {
			printf("%s: couldn't get ep %d\n",
			    sc->axe_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->axe_ed[AXE_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->axe_ed[AXE_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->axe_ed[AXE_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	s = splnet();

	/* We need the PHYID for init dance in some cases */
	axe_cmd(sc, AXE_CMD_READ_PHYID, 0, 0, (void *)&sc->axe_phyaddrs);

	DPRINTF((" phyaddrs[0]: %x phyaddrs[1]: %x\n",
	    sc->axe_phyaddrs[0], sc->axe_phyaddrs[1]));

	sc->axe_phyno = axe_get_phyno(sc, AXE_PHY_SEL_PRI);
	if (sc->axe_phyno == -1)
		sc->axe_phyno = axe_get_phyno(sc, AXE_PHY_SEL_SEC);
	if (sc->axe_phyno == -1) {
		printf("%s:", sc->axe_dev.dv_xname);
		printf(" no valid PHY address found, assuming PHY address 0\n");
		sc->axe_phyno = 0;
	}

	DPRINTF((" get_phyno %d\n", sc->axe_phyno));

	if (sc->axe_flags & AX178)
		axe_ax88178_init(sc);
	else if (sc->axe_flags & AX772)
		axe_ax88772_init(sc);

	/*
	 * Get station address.
	 */
	if (sc->axe_flags & (AX178 | AX772))
		axe_cmd(sc, AXE_178_CMD_READ_NODEID, 0, 0, &eaddr);
	else
		axe_cmd(sc, AXE_172_CMD_READ_NODEID, 0, 0, &eaddr);

	if (sc->axe_flags & AX772B)
		axe_ax88772b_nodeid(sc, eaddr);

	/*
	 * Load IPG values
	 */
	axe_cmd(sc, AXE_CMD_READ_IPG012, 0, 0, (void *)&sc->axe_ipgs);

	/*
	 * An ASIX chip was detected. Inform the world.
	 */
	printf("%s:", sc->axe_dev.dv_xname);
	if (sc->axe_flags & AX178)
		printf(" AX88178");
	else if (sc->axe_flags & AX772B)
		printf(" AX88772B");
	else if (sc->axe_flags & AX772)
		printf(" AX88772");
	else
		printf(" AX88172");
	printf(", address %s\n", ether_sprintf(eaddr));

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	/* Initialize interface info.*/
	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, devname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = axe_ioctl;
	ifp->if_start = axe_start;
	ifp->if_watchdog = axe_watchdog;

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize MII/media info. */
	mii = &sc->axe_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = axe_miibus_readreg;
	mii->mii_writereg = axe_miibus_writereg;
	mii->mii_statchg = axe_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;

	ifmedia_init(&mii->mii_media, 0, axe_ifmedia_upd, axe_ifmedia_sts);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->axe_stat_ch, axe_tick, sc);

	splx(s);
}

int
axe_detach(struct device *self, int flags)
{
	struct axe_softc	*sc = (struct axe_softc *)self;
	int			s;
	struct ifnet		*ifp = GET_IFP(sc);

	DPRINTFN(2,("%s: %s: enter\n", sc->axe_dev.dv_xname, __func__));

	if (timeout_initialized(&sc->axe_stat_ch))
		timeout_del(&sc->axe_stat_ch);

	if (sc->axe_ep[AXE_ENDPT_TX] != NULL)
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_TX]);
	if (sc->axe_ep[AXE_ENDPT_RX] != NULL)
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_RX]);
	if (sc->axe_ep[AXE_ENDPT_INTR] != NULL)
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_INTR]);

	/*
	 * Remove any pending tasks.  They cannot be executing because they run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->axe_udev, &sc->axe_tick_task);
	usb_rem_task(sc->axe_udev, &sc->axe_stop_task);

	s = splusb();

	if (--sc->axe_refcnt >= 0) {
		/* Wait for processes to go away */
		usb_detach_wait(&sc->axe_dev);
	}

	if (ifp->if_flags & IFF_RUNNING)
		axe_stop(sc);

	mii_detach(&sc->axe_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->axe_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->axe_ep[AXE_ENDPT_TX] != NULL ||
	    sc->axe_ep[AXE_ENDPT_RX] != NULL ||
	    sc->axe_ep[AXE_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		    sc->axe_dev.dv_xname);
#endif

	if (--sc->axe_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->axe_dev);
	}
	splx(s);

	return (0);
}

struct mbuf *
axe_newbuf(void)
{
	struct mbuf		*m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	m->m_len = m->m_pkthdr.len = MCLBYTES;
	m_adj(m, ETHER_ALIGN);

	return (m);
}

int
axe_rx_list_init(struct axe_softc *sc)
{
	struct axe_cdata *cd;
	struct axe_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->axe_dev.dv_xname, __func__));

	cd = &sc->axe_cdata;
	for (i = 0; i < AXE_RX_LIST_CNT; i++) {
		c = &cd->axe_rx_chain[i];
		c->axe_sc = sc;
		c->axe_idx = i;
		c->axe_mbuf = NULL;
		if (c->axe_xfer == NULL) {
			c->axe_xfer = usbd_alloc_xfer(sc->axe_udev);
			if (c->axe_xfer == NULL)
				return (ENOBUFS);
			c->axe_buf = usbd_alloc_buffer(c->axe_xfer,
			    sc->axe_bufsz);
			if (c->axe_buf == NULL) {
				usbd_free_xfer(c->axe_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
axe_tx_list_init(struct axe_softc *sc)
{
	struct axe_cdata *cd;
	struct axe_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->axe_dev.dv_xname, __func__));

	cd = &sc->axe_cdata;
	for (i = 0; i < AXE_TX_LIST_CNT; i++) {
		c = &cd->axe_tx_chain[i];
		c->axe_sc = sc;
		c->axe_idx = i;
		c->axe_mbuf = NULL;
		if (c->axe_xfer == NULL) {
			c->axe_xfer = usbd_alloc_xfer(sc->axe_udev);
			if (c->axe_xfer == NULL)
				return (ENOBUFS);
			c->axe_buf = usbd_alloc_buffer(c->axe_xfer,
			    sc->axe_bufsz);
			if (c->axe_buf == NULL) {
				usbd_free_xfer(c->axe_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
axe_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct axe_chain	*c = (struct axe_chain *)priv;
	struct axe_softc	*sc = c->axe_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	u_char			*buf = c->axe_buf;
	u_int32_t		total_len;
	u_int16_t		pktlen = 0;
	struct mbuf		*m;
	struct axe_sframe_hdr	hdr;
	int			s;

	DPRINTFN(10,("%s: %s: enter\n", sc->axe_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->axe_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (usbd_ratecheck(&sc->axe_rx_notice)) {
			printf("%s: usb errors on rx: %s\n",
			    sc->axe_dev.dv_xname, usbd_errstr(status));
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->axe_ep[AXE_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	do {
		if (sc->axe_flags & (AX178 | AX772)) {
			if (total_len < sizeof(hdr)) {
				ifp->if_ierrors++;
				goto done;
			}

			buf += pktlen;

			memcpy(&hdr, buf, sizeof(hdr));
			total_len -= sizeof(hdr);

			if (((letoh16(hdr.len) & AXE_RH1M_RXLEN_MASK) ^
			    (letoh16(hdr.ilen) & AXE_RH1M_RXLEN_MASK)) !=
			    AXE_RH1M_RXLEN_MASK) {
				ifp->if_ierrors++;
				goto done;
			}
			pktlen = letoh16(hdr.len) & AXE_RH1M_RXLEN_MASK;
			if (pktlen > total_len) {
				ifp->if_ierrors++;
				goto done;
			}

			buf += sizeof(hdr);

			if ((pktlen % 2) != 0)
				pktlen++;

			if (total_len < pktlen)
				total_len = 0;
			else
				total_len -= pktlen;
		} else {
			pktlen = total_len; /* crc on the end? */
			total_len = 0;
		}

		m = axe_newbuf();
		if (m == NULL) {
			ifp->if_ierrors++;
			goto done;
		}

		m->m_pkthdr.len = m->m_len = pktlen;

		memcpy(mtod(m, char *), buf, pktlen);

		ml_enqueue(&ml, m);

	} while (total_len > 0);

done:
	/* push the packet up */
	s = splnet();
	if_input(ifp, &ml);
	splx(s);

	memset(c->axe_buf, 0, sc->axe_bufsz);

	/* Setup new transfer. */
	usbd_setup_xfer(xfer, sc->axe_ep[AXE_ENDPT_RX],
	    c, c->axe_buf, sc->axe_bufsz,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, axe_rxeof);
	usbd_transfer(xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->axe_dev.dv_xname, __func__));

	return;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
axe_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct axe_softc	*sc;
	struct axe_chain	*c;
	struct ifnet		*ifp;
	int			s;

	c = priv;
	sc = c->axe_sc;
	ifp = &sc->arpcom.ac_if;

	if (usbd_is_dying(sc->axe_udev))
		return;

	s = splnet();

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("axe%d: usb error on tx: %s\n", sc->axe_unit,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->axe_ep[AXE_ENDPT_TX]);
		splx(s);
		return;
	}

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	m_freem(c->axe_mbuf);
	c->axe_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		axe_start(ifp);

	splx(s);
	return;
}

void
axe_tick(void *xsc)
{
	struct axe_softc *sc = xsc;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->axe_dev.dv_xname,
			__func__));

	if (usbd_is_dying(sc->axe_udev))
		return;

	/* Perform periodic stuff in process context */
	usb_add_task(sc->axe_udev, &sc->axe_tick_task);

}

void
axe_tick_task(void *xsc)
{
	int			s;
	struct axe_softc	*sc;
	struct ifnet		*ifp;
	struct mii_data		*mii;

	sc = xsc;

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->axe_udev))
		return;

	ifp = GET_IFP(sc);
	mii = GET_MII(sc);
	if (mii == NULL)
		return;

	s = splnet();

	mii_tick(mii);
	if (sc->axe_link == 0)
		axe_miibus_statchg(&sc->axe_dev);
	timeout_add_sec(&sc->axe_stat_ch, 1);

	splx(s);
}

int
axe_encap(struct axe_softc *sc, struct mbuf *m, int idx)
{
	struct axe_chain	*c;
	usbd_status		err;
	struct axe_sframe_hdr	hdr;
	int			length, boundary;

	c = &sc->axe_cdata.axe_tx_chain[idx];

	if (sc->axe_flags & (AX178 | AX772)) {
		boundary = (sc->axe_udev->speed == USB_SPEED_HIGH) ? 512 : 64;

		hdr.len = htole16(m->m_pkthdr.len);
		hdr.ilen = ~hdr.len;

		memcpy(c->axe_buf, &hdr, sizeof(hdr));
		length = sizeof(hdr);

		m_copydata(m, 0, m->m_pkthdr.len, c->axe_buf + length);
		length += m->m_pkthdr.len;

		if ((length % boundary) == 0) {
			hdr.len = 0x0000;
			hdr.ilen = 0xffff;
			memcpy(c->axe_buf + length, &hdr, sizeof(hdr));
			length += sizeof(hdr);
		}

	} else {
		m_copydata(m, 0, m->m_pkthdr.len, c->axe_buf);
		length = m->m_pkthdr.len;
	}

	c->axe_mbuf = m;

	usbd_setup_xfer(c->axe_xfer, sc->axe_ep[AXE_ENDPT_TX],
	    c, c->axe_buf, length, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    10000, axe_txeof);

	/* Transmit */
	err = usbd_transfer(c->axe_xfer);
	if (err != USBD_IN_PROGRESS) {
		axe_stop(sc);
		return(EIO);
	}

	sc->axe_cdata.axe_tx_cnt++;

	return(0);
}

void
axe_start(struct ifnet *ifp)
{
	struct axe_softc	*sc;
	struct mbuf		*m_head = NULL;

	sc = ifp->if_softc;

	if (!sc->axe_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (axe_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}
	ifq_deq_commit(&ifp->if_snd, m_head);

	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	return;
}

void
axe_init(void *xsc)
{
	struct axe_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct axe_chain	*c;
	usbd_status		err;
	uWord			urxmode;
	int			rxmode;
	int			i, s;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	axe_reset(sc);

	/* set MAC address */
	if (sc->axe_flags & (AX178 | AX772))
		axe_cmd(sc, AXE_178_CMD_WRITE_NODEID, 0, 0,
		    &sc->arpcom.ac_enaddr);

	/* Enable RX logic. */

	/* Init RX ring. */
	if (axe_rx_list_init(sc) == ENOBUFS) {
		printf("axe%d: rx list init failed\n", sc->axe_unit);
		splx(s);
		return;
	}

	/* Init TX ring. */
	if (axe_tx_list_init(sc) == ENOBUFS) {
		printf("axe%d: tx list init failed\n", sc->axe_unit);
		splx(s);
		return;
	}

	/* Set transmitter IPG values */
	if (sc->axe_flags & (AX178 | AX772))
		axe_cmd(sc, AXE_178_CMD_WRITE_IPG012, sc->axe_ipgs[2],
		    (sc->axe_ipgs[1] << 8) | (sc->axe_ipgs[0]), NULL);
	else {
		axe_cmd(sc, AXE_172_CMD_WRITE_IPG0, 0, sc->axe_ipgs[0], NULL);
		axe_cmd(sc, AXE_172_CMD_WRITE_IPG1, 0, sc->axe_ipgs[1], NULL);
		axe_cmd(sc, AXE_172_CMD_WRITE_IPG2, 0, sc->axe_ipgs[2], NULL);
	}

	/* Program promiscuous mode and multicast filters. */
	axe_iff(sc);

	/* Enable receiver, set RX mode */
	axe_cmd(sc, AXE_CMD_RXCTL_READ, 0, 0, urxmode);
	rxmode = UGETW(urxmode);
	rxmode |= AXE_RXCMD_ENABLE;
	if (sc->axe_flags & AX772B)
		rxmode |= AXE_772B_RXCMD_RH1M;
	else if (sc->axe_flags & (AX178 | AX772)) {
		if (sc->axe_udev->speed == USB_SPEED_HIGH) {
			/* largest possible USB buffer size for AX88178 */
			rxmode |= AXE_178_RXCMD_MFB;
		}
	}
	axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, rxmode, NULL);

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->axe_iface, sc->axe_ed[AXE_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->axe_ep[AXE_ENDPT_RX]);
	if (err) {
		printf("axe%d: open rx pipe failed: %s\n",
		    sc->axe_unit, usbd_errstr(err));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->axe_iface, sc->axe_ed[AXE_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->axe_ep[AXE_ENDPT_TX]);
	if (err) {
		printf("axe%d: open tx pipe failed: %s\n",
		    sc->axe_unit, usbd_errstr(err));
		splx(s);
		return;
	}

	/* Start up the receive pipe. */
	for (i = 0; i < AXE_RX_LIST_CNT; i++) {
		c = &sc->axe_cdata.axe_rx_chain[i];
		usbd_setup_xfer(c->axe_xfer, sc->axe_ep[AXE_ENDPT_RX],
		    c, c->axe_buf, sc->axe_bufsz,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, axe_rxeof);
		usbd_transfer(c->axe_xfer);
	}

	sc->axe_link = 0;
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->axe_stat_ch, 1);
	return;
}

int
axe_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct axe_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			axe_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				axe_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				axe_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->axe_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			axe_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
axe_watchdog(struct ifnet *ifp)
{
	struct axe_softc	*sc;
	struct axe_chain	*c;
	usbd_status		stat;
	int			s;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("axe%d: watchdog timeout\n", sc->axe_unit);

	s = splusb();
	c = &sc->axe_cdata.axe_tx_chain[0];
	usbd_get_xfer_status(c->axe_xfer, NULL, NULL, NULL, &stat);
	axe_txeof(c->axe_xfer, c, stat);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		axe_start(ifp);
	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
axe_stop(struct axe_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	axe_reset(sc);

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->axe_stat_ch);

	/* Stop transfers. */
	if (sc->axe_ep[AXE_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_RX]);
		err = usbd_close_pipe(sc->axe_ep[AXE_ENDPT_RX]);
		if (err) {
			printf("axe%d: close rx pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
		sc->axe_ep[AXE_ENDPT_RX] = NULL;
	}

	if (sc->axe_ep[AXE_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_TX]);
		err = usbd_close_pipe(sc->axe_ep[AXE_ENDPT_TX]);
		if (err) {
			printf("axe%d: close tx pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
		sc->axe_ep[AXE_ENDPT_TX] = NULL;
	}

	if (sc->axe_ep[AXE_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_INTR]);
		err = usbd_close_pipe(sc->axe_ep[AXE_ENDPT_INTR]);
		if (err) {
			printf("axe%d: close intr pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
		sc->axe_ep[AXE_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < AXE_RX_LIST_CNT; i++) {
		if (sc->axe_cdata.axe_rx_chain[i].axe_mbuf != NULL) {
			m_freem(sc->axe_cdata.axe_rx_chain[i].axe_mbuf);
			sc->axe_cdata.axe_rx_chain[i].axe_mbuf = NULL;
		}
		if (sc->axe_cdata.axe_rx_chain[i].axe_xfer != NULL) {
			usbd_free_xfer(sc->axe_cdata.axe_rx_chain[i].axe_xfer);
			sc->axe_cdata.axe_rx_chain[i].axe_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < AXE_TX_LIST_CNT; i++) {
		if (sc->axe_cdata.axe_tx_chain[i].axe_mbuf != NULL) {
			m_freem(sc->axe_cdata.axe_tx_chain[i].axe_mbuf);
			sc->axe_cdata.axe_tx_chain[i].axe_mbuf = NULL;
		}
		if (sc->axe_cdata.axe_tx_chain[i].axe_xfer != NULL) {
			usbd_free_xfer(sc->axe_cdata.axe_tx_chain[i].axe_xfer);
			sc->axe_cdata.axe_tx_chain[i].axe_xfer = NULL;
		}
	}

	sc->axe_link = 0;
}

@


1.137
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.136 2015/11/25 03:10:00 dlg Exp $	*/
a1132 1
	ifp->if_opackets++;
@


1.136
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.135 2015/11/24 17:11:40 mpi Exp $	*/
a803 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.135
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.134 2015/11/20 03:35:23 dlg Exp $	*/
d1126 1
a1126 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1252 1
a1252 1
	if (ifp->if_flags & IFF_OACTIVE)
d1261 1
a1261 1
		ifp->if_flags |= IFF_OACTIVE;
d1275 1
a1275 1
	ifp->if_flags |= IFF_OACTIVE;
d1382 1
a1382 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1475 2
a1476 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.134
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.133 2015/10/25 12:11:56 mpi Exp $	*/
a104 1
#include <net/if_dl.h>
@


1.133
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.132 2015/06/24 09:40:54 mpi Exp $	*/
d1256 1
a1256 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1261 1
d1265 1
a1265 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.132
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.131 2015/06/12 15:47:31 mpi Exp $	*/
a1394 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a1403 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.131
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tests & ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.130 2015/05/17 02:44:38 canacar Exp $	*/
a1061 1
		ifp->if_ipackets++;
@


1.130
log
@Read ethernet address from EEPROM on AX88772B based on FreeBSD
ok djm@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.129 2015/02/12 22:39:27 mpi Exp $	*/
d674 2
a675 2
	if (!uaa->iface)
		return(UMATCH_NONE);
d678 1
a678 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a689 2
	struct usbd_device *dev = uaa->device;
	usbd_status err;
d699 2
a700 9
	sc->axe_udev = dev;

	err = usbd_set_config_no(dev, AXE_CONFIG_NO, 1);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->axe_dev.dv_xname);
		return;
	}

a707 7

	err = usbd_device2interface_handle(dev, AXE_IFACE_IDX, &sc->axe_iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->axe_dev.dv_xname);
		return;
	}
@


1.129
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.128 2014/12/22 02:28:52 tedu Exp $	*/
d578 25
d788 3
@


1.128
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.127 2014/11/24 02:03:37 brad Exp $	*/
d976 1
a1050 1
		m->m_pkthdr.rcvif = ifp;
d1055 1
a1055 10
		/* push the packet up */
		s = splnet();
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		ether_input_mbuf(ifp, m);

		splx(s);
d1060 5
@


1.127
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.126 2014/07/13 15:52:49 mpi Exp $	*/
a1397 1
#ifdef INET
a1399 1
#endif
@


1.126
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.125 2014/07/12 07:59:23 mpi Exp $	*/
d68 1
a68 1
 * It uses an external PHY (reference designs use a RealTek chip),
@


1.125
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.124 2014/04/12 14:02:19 jsg Exp $	*/
a111 1
#ifdef INET
a112 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a113 1
#endif
@


1.124
log
@simplify flag tests
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.123 2013/11/15 10:17:39 pirofti Exp $	*/
d181 10
a190 15
int axe_match(struct device *, void *, void *); 
void axe_attach(struct device *, struct device *, void *); 
int axe_detach(struct device *, int); 
int axe_activate(struct device *, int); 

struct cfdriver axe_cd = { 
	NULL, "axe", DV_IFNET 
}; 

const struct cfattach axe_ca = { 
	sizeof(struct axe_softc), 
	axe_match, 
	axe_attach, 
	axe_detach, 
	axe_activate, 
a883 15
	return (0);
}

int
axe_activate(struct device *self, int act)
{
	struct axe_softc *sc = (struct axe_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->axe_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->axe_udev);
		break;
	}
@


1.123
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.122 2013/08/07 01:06:41 bluhm Exp $	*/
d479 1
a479 1
	if (!sc->axe_flags & AX178 && !sc->axe_flags & AX772)
d715 1
a715 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772)
d768 1
a768 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772)
d1030 1
a1030 1
		if (sc->axe_flags & AX178 || sc->axe_flags & AX772) {
d1217 1
a1217 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772) {
d1321 1
a1321 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772)
d1342 1
a1342 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772)
d1360 1
a1360 1
	else if (sc->axe_flags & AX178 || sc->axe_flags & AX772) {
@


1.122
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.121 2013/07/02 19:27:15 brad Exp $	*/
d1503 1
a1503 5
		err = usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_RX]);
		if (err) {
			printf("axe%d: abort rx pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
d1513 1
a1513 5
		err = usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_TX]);
		if (err) {
			printf("axe%d: abort tx pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
d1523 1
a1523 5
		err = usbd_abort_pipe(sc->axe_ep[AXE_ENDPT_INTR]);
		if (err) {
			printf("axe%d: abort intr pipe failed: %s\n",
			    sc->axe_unit, usbd_errstr(err));
		}
@


1.121
log
@Rearrange the inequalities.

Pointed out by LLVM.

if_axe.c:1059:29: error: comparison of unsigned expression < 0 is always false
if_smsc.c:1250:28: error: comparison of unsigned expression < 0 is always false

ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.120 2013/06/03 22:36:15 yuo Exp $	*/
a114 1
#include <netinet/in_var.h>
@


1.120
log
@remove unless lines

ok reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.119 2013/05/31 15:20:49 yuo Exp $	*/
d1059 1
a1059 1
			if ((total_len - pktlen) < 0)
@


1.119
log
@enable REALTEK 8211C(L) GbE phy with axe(4).

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.118 2013/04/15 09:23:01 mglocker Exp $	*/
a362 5

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
		val = AXE_MEDIA_FULL_DUPLEX;
	else
		val = 0;
@


1.118
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.117 2013/03/28 03:58:03 tedu Exp $	*/
d524 5
d532 2
a533 2
	int gpio0 = 0, phymode = 0;
	u_int16_t eeprom;
d546 1
a546 1
		phymode = 0;
d548 1
d550 1
a550 1
		phymode = eeprom & 7;
d552 1
d555 2
a556 1
	DPRINTF(("use gpio0: %d, phymode %d\n", gpio0, phymode));
d558 12
a569 5
	axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x008c, NULL);
	usbd_delay_ms(sc->axe_udev, 40);
	if ((eeprom >> 8) != 1) {
		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
		usbd_delay_ms(sc->axe_udev, 30);
d571 8
a578 11
		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x001c, NULL);
		usbd_delay_ms(sc->axe_udev, 300);

		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
		usbd_delay_ms(sc->axe_udev, 30);
	} else {
		DPRINTF(("axe gpio phymode == 1 path\n"));
		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x0004, NULL);
		usbd_delay_ms(sc->axe_udev, 30);
		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x000c, NULL);
		usbd_delay_ms(sc->axe_udev, 30);
@


1.117
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.116 2013/03/04 13:08:06 sthen Exp $	*/
d203 2
a204 2
void axe_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void axe_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d668 1
a668 1
	usbd_device_handle dev = uaa->device;
d989 1
a989 1
axe_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1107 1
a1107 1
axe_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.116
log
@Add HG20F9 usb ethernet, from Chuck Guzis, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.115 2012/12/05 23:20:21 deraadt Exp $	*/
a97 1
#include <sys/proc.h>
@


1.115
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.114 2012/11/28 01:15:33 brad Exp $	*/
d166 1
@


1.114
log
@- Use IF_Gbps(1) instead of IF_Mbps(1000)
- Use IF_Mbps() instead of multiplying the link speed by a bare value
- Remove a useless comment as baudrate is already handled properly
- Remove some commented out bits of code
- Use IF_Mbps() instead of the bare value

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.113 2012/11/21 05:26:18 kirby Exp $	*/
a49 2

#include <sys/cdefs.h>
@


1.113
log
@Hook D-Link DUB-E100 rev C1 to axe(4)
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.112 2012/11/14 17:00:23 jcs Exp $	*/
a796 1

a797 4

/*	ifp->if_baudrate = 10000000; */
/*	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;*/

@


1.112
log
@add support for the lenovo usb 2.0 ethernet adapter
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.111 2012/11/10 18:46:21 brad Exp $	*/
d163 1
@


1.111
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.110 2012/09/12 23:35:06 jcs Exp $	*/
d166 1
@


1.110
log
@match on another axis AX88772B that comes with the asus ux21/ux31a
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.109 2012/04/01 13:25:13 jsg Exp $	*/
d220 1
a220 1
void axe_setmulti(struct axe_softc *);
d460 1
a460 1
axe_setmulti(struct axe_softc *sc)
d462 2
a463 1
	struct ifnet		*ifp;
a473 2
	ifp = GET_IFP(sc);

d476 11
d488 2
a489 2
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
d491 12
a502 4
		axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, rxmode, NULL);
		return;
	} else
		rxmode &= ~AXE_RXCMD_ALLMULTI;
d504 2
a505 10
	/* now program new ones */
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
			   ETHER_ADDR_LEN) != 0)
			goto allmulti;

		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
		hashtbl[h / 8] |= 1 << (h % 8);
		ETHER_NEXT_MULTI(step, enm);
a507 1
	ifp->if_flags &= ~IFF_ALLMULTI;
a509 1
	return;
d1308 1
d1350 3
d1354 3
a1356 1
	rxmode = AXE_RXCMD_MULTICAST|AXE_RXCMD_ENABLE;
d1364 1
a1364 10
	} else
		rxmode |= AXE_172_RXCMD_UNICAST;

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		rxmode |= AXE_RXCMD_PROMISC;

	if (ifp->if_flags & IFF_BROADCAST)
		rxmode |= AXE_RXCMD_BROADCAST;

a1366 3
	/* Load the multicast filter. */
	axe_setmulti(sc);

a1411 2
	struct mii_data		*mii;
	uWord			rxmode;
d1429 3
a1431 17
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->axe_if_flags & IFF_PROMISC)) {

				axe_cmd(sc, AXE_CMD_RXCTL_READ, 0, 0, rxmode);
				axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0,
				    UGETW(rxmode) | AXE_RXCMD_PROMISC, NULL);

				axe_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->axe_if_flags & IFF_PROMISC) {
				axe_cmd(sc, AXE_CMD_RXCTL_READ, 0, 0, rxmode);
				axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0,
				    UGETW(rxmode) & ~AXE_RXCMD_PROMISC, NULL);
				axe_setmulti(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
a1436 1
		sc->axe_if_flags = ifp->if_flags;
d1441 1
a1441 2
		mii = GET_MII(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
d1450 1
a1450 1
			axe_setmulti(sc);
@


1.109
log
@make this work on big endian archs again, broken in the last commit.
fixes breakage noticed by landry@@ on macppc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.108 2012/03/01 04:33:15 jsg Exp $	*/
d154 1
@


1.108
log
@add support for AX88772B
tweaked version of a diff from jcs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.107 2011/09/16 17:20:07 miod Exp $	*/
d1031 2
a1032 2
			if (((hdr.len & AXE_RH1M_RXLEN_MASK) ^
			    (hdr.ilen & AXE_RH1M_RXLEN_MASK)) !=
d1037 1
a1037 1
			pktlen = letoh16(hdr.len & AXE_RH1M_RXLEN_MASK);
@


1.107
log
@Fix a bunch of typos: manaul, monnitor, machiune, autload.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.106 2011/07/03 15:47:17 matthew Exp $	*/
d153 1
d769 2
d1031 3
a1033 1
			if ((hdr.len ^ hdr.ilen) != 0xffff) {
d1037 1
a1037 1
			pktlen = letoh16(hdr.len);
d1342 3
a1344 1
	if (sc->axe_flags & AX178 || sc->axe_flags & AX772) {
@


1.106
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.105 2011/01/25 20:03:35 jakemsr Exp $	*/
d81 1
a81 1
 * address via autload from the EEPROM (i.e. there's no way to manaully
@


1.105
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.104 2010/12/06 04:41:39 jakemsr Exp $	*/
a886 3
	case DVACT_ACTIVATE:
		break;

@


1.104
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.103 2010/11/14 20:38:43 weerd Exp $	*/
a816 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->axe_udev,
			   &sc->axe_dev);
a874 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->axe_udev,
			   &sc->axe_dev);
@


1.103
log
@Cleanup dmesg a bit, do not print the device name twice when attaching
axe(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.102 2010/10/27 17:51:11 jakemsr Exp $	*/
d247 1
a247 1
	if (sc->axe_dying)
d277 1
a277 1
	if (sc->axe_dying) {
d335 1
a335 1
	if (sc->axe_dying)
d468 1
a468 1
	if (sc->axe_dying)
d505 1
a505 1
	if (sc->axe_dying)
d669 1
a692 1
	sc->axe_udev = dev;
a815 1
	sc->axe_attached = 1;
a830 4
	/* Detached before attached finished, so just bail out. */
	if (!sc->axe_attached)
		return (0);

a872 2
	sc->axe_attached = 0;

d897 1
a897 1
		sc->axe_dying = 1;
d1005 1
a1005 1
	if (sc->axe_dying)
d1118 1
a1118 1
	if (sc->axe_dying)
d1162 1
a1162 1
	if (sc->axe_dying)
d1183 1
a1183 1
	if (sc->axe_dying)
@


1.102
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.101 2010/10/23 16:14:07 jakemsr Exp $	*/
a725 2

	printf("%s:", sc->axe_dev.dv_xname);
@


1.101
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.100 2010/10/23 15:42:09 jakemsr Exp $	*/
d867 4
a870 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.100
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.99 2010/09/24 03:21:21 deraadt Exp $	*/
d838 2
a839 1
	timeout_del(&sc->axe_stat_ch);
@


1.99
log
@try to print the attach dmesg line in one unit, rather than intermixing
it with slow operations.
ok jsg yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.98 2010/09/23 16:58:28 yuo Exp $	*/
d679 2
a680 1
	usb_init_task(&sc->axe_tick_task, axe_tick_task, sc);
d682 2
a683 1
	usb_init_task(&sc->axe_stop_task, (void (*)(void *))axe_stop, sc);
@


1.98
log
@remove dying flag in the detach() function.
the device driver which has DEACTIVATE processing seems to no need to
set dying flag in the detach() function because the flag will be set
in the DEACTIVATE process before detach().

ok jsg@@, ok for experiment deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.97 2010/09/21 08:02:49 jsg Exp $	*/
d316 1
a316 1
	       /*
d322 2
a323 2
	       ival &= ~BMSR_EXTCAP;
       }
d614 1
a614 1
       int             phyno;
d616 14
a629 15
       phyno = -1;
       switch (AXE_PHY_TYPE(sc->axe_phyaddrs[sel])) {
       case PHY_TYPE_100_HOME:
       case PHY_TYPE_GIG:
               phyno  = AXE_PHY_NO(sc->axe_phyaddrs[sel]);
               break;
       case PHY_TYPE_SPECIAL:
               /* FALLTHROUGH */
       case PHY_TYPE_RSVD:
               /* FALLTHROUGH */
       case PHY_TYPE_NON_SUP:
               /* FALLTHROUGH */
       default:
               break;
       }
d631 1
a631 1
       return (phyno);
d733 8
a740 7
       sc->axe_phyno = axe_get_phyno(sc, AXE_PHY_SEL_PRI);
       if (sc->axe_phyno == -1)
               sc->axe_phyno = axe_get_phyno(sc, AXE_PHY_SEL_SEC);
       if (sc->axe_phyno == -1) {
               printf(" no valid PHY address found, assuming PHY address 0\n");
               sc->axe_phyno = 0;
       }
d744 1
a744 1
	if (sc->axe_flags & AX178) {
d746 1
a746 2
		printf(" AX88178");
	} else if (sc->axe_flags & AX772) {
a747 3
		printf(" AX88772");
	} else
		printf(" AX88172");
d765 7
@


1.97
log
@Better PHY probing adapted from FreeBSD by Laurent Ghigonis
fixes problems seen with Linksys USB300M.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.96 2010/01/09 05:33:08 jsg Exp $	*/
a833 2

	sc->axe_dying = 1;
@


1.96
log
@Explicitly turn on mii/gmii/rgmii for the 178/gigabit devices
from FreeBSD and confirmed with the datasheet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.95 2009/11/22 22:13:51 jsg Exp $	*/
d275 1
d296 1
a296 1
	if (sc->axe_phyaddrs[0] != 0xFF && sc->axe_phyaddrs[0] != phy)
d314 10
a323 2
	if (UGETW(val) && UGETW(val) != 0xffff)
		sc->axe_phyaddrs[0] = phy;
d325 1
a325 1
	return (UGETW(val));
d337 2
d359 1
d367 31
d400 2
a432 1
	sc->axe_link = 0;
d577 1
a577 1
	if (sc->axe_phyaddrs[1] == AXE_INTPHY) {
d611 24
d734 10
a766 6
	 * Work around broken adapters that appear to lie about
	 * their PHY addresses.
	 */
	sc->axe_phyaddrs[0] = sc->axe_phyaddrs[1] = 0xFF;

	/*
d1197 2
a1198 9
	if (!sc->axe_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		DPRINTF(("%s: %s: got link\n",
			 sc->axe_dev.dv_xname, __func__));
		sc->axe_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			   axe_start(ifp);
	}

d1398 1
@


1.95
log
@add a bunch of devices found in linux drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.94 2009/10/13 19:33:17 pirofti Exp $	*/
d521 3
@


1.94
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.93 2009/09/20 12:53:36 deraadt Exp $	*/
d169 1
@


1.93
log
@Support the AX88772A model (found while shopping today); tested by mtu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.92 2009/05/13 16:46:55 jsg Exp $	*/
d182 1
a182 1
int axe_activate(struct device *, enum devact); 
d813 1
a813 1
axe_activate(struct device *self, enum devact act)
@


1.92
log
@Support setting a different MAC address from the one in EEPROM
on newer chips now the hardware can apparently cope with it.
Tested by Walter Haidinger.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.91 2008/11/28 02:44:18 brad Exp $	*/
d152 1
@


1.91
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.90 2008/11/06 02:32:28 brad Exp $	*/
d1245 5
@


1.90
log
@Set the IFCAP_VLAN_MTU capabilities flag so these interfaces are allowed
to transmit full sized VLAN tagged frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.89 2008/11/02 10:46:10 jsg Exp $	*/
a1354 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;

d1381 1
a1381 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				axe_setmulti(sc);
			error = 0;
		}
		break;
d1390 6
@


1.89
log
@Remove duplicate call to ether_ifdetach() in axe_detach()
which has been there since rev 1.1.
Spotted by Johann Christian Rode <jcrode@@gmx.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.88 2008/10/02 20:21:14 brad Exp $	*/
d710 2
@


1.88
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.87 2008/09/21 23:59:20 brad Exp $	*/
a756 2

	ether_ifdetach(ifp);
@


1.87
log
@Add missing splnet to the ioctl handler.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.86 2008/09/10 14:01:23 blambert Exp $	*/
d1411 1
a1411 2
		error = EINVAL;
		break;
@


1.86
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.85 2008/05/14 01:41:10 brad Exp $	*/
d1340 3
a1342 1
	int			error = 0;
d1415 1
@


1.85
log
@Remove the duplicate Billionton id.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.84 2008/05/11 09:20:31 brad Exp $	*/
d1129 1
a1129 1
	timeout_add(&sc->axe_stat_ch, hz);
d1328 1
a1328 1
	timeout_add(&sc->axe_stat_ch, hz);
@


1.84
log
@Add the Buffalo (MELCO) LUA-U2-GT id.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.83 2008/05/06 12:51:17 mpf Exp $	*/
a154 1
	{ { USB_VENDOR_BILLIONTON, USB_PRODUCT_BILLIONTON_SNAPPORT}, 0 },
@


1.83
log
@Add support for the Apple USB Ethernet adapter.
Work around the "latch in at the first working PHY address hack",
that fails for this adapter because it returns 0xffff when reading
from lower PHY addresses. Also add more debugging printfs.
Testing and OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.82 2008/02/22 12:42:40 jsg Exp $	*/
d167 1
@


1.82
log
@Simon Dick in FreeBSD PR 96714
* Fossil Abacus Wrist PDA

Thorsten Trampisch in FreeBSD PR 113384
* Expert ISDN Control
* RS232 OptoBridge

Jonathan Charest in FreeBSD PR 110992
* Several Tactrix OpenPort (ECU) devices.

Y.Okabe in FreeBSD PR 119981
* Logitec LAN-GTJ/U2 Ethernet

HAGIMORI 'buggy' Masashige in FreeBSD PR 115933
* RATOC REX-USB60F serial
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.81 2007/11/23 15:43:02 mbalmer Exp $	*/
d149 1
d259 2
a260 1
	if (err)
d262 1
d308 2
d311 1
a311 1
	if (UGETW(val))
@


1.81
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.80 2007/10/27 22:12:41 jsg Exp $	*/
d165 1
@


1.80
log
@Deal with usb string printing changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.79 2007/10/11 18:33:14 deraadt Exp $	*/
d726 1
a726 1
	timeout_set(&sc->axe_stat_ch, NULL, NULL);
a1122 2
	timeout_del(&sc->axe_stat_ch);
	timeout_set(&sc->axe_stat_ch, axe_tick, sc);
a1321 2
	timeout_del(&sc->axe_stat_ch);
	timeout_set(&sc->axe_stat_ch, axe_tick, sc);
@


1.79
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.78 2007/06/14 10:11:15 mbalmer Exp $	*/
d629 2
a630 1
			printf(", couldn't get ep %d\n", i);
d647 2
d657 1
a657 1
		printf(", AX88178");
d660 1
a660 1
		printf(", AX88772");
d662 1
a662 1
		printf(", AX88172");
@


1.78
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.77 2007/06/13 11:15:29 mbalmer Exp $	*/
a585 1
	char *devinfop;
a589 3
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n");

d594 2
a595 3
		printf("axe%d: getting interface handle failed\n",
		    sc->axe_unit);
		usbd_devinfo_free(devinfop);
d607 2
a608 3
		printf("axe%d: getting interface handle failed\n",
		    sc->axe_unit);
		usbd_devinfo_free(devinfop);
a617 3
	printf("%s: %s", sc->axe_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);

d629 1
a629 1
			printf(" couldn't get ep %d\n", i);
@


1.77
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.76 2007/06/12 16:26:36 mbalmer Exp $	*/
d176 16
a191 1
USB_DECLARE_DRIVER_CLASS(axe, DV_IFNET);
@


1.76
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.75 2007/06/11 05:42:53 mbalmer Exp $	*/
d991 1
a991 1
		IF_INPUT(ifp, m);
@


1.75
log
@Remove the definition and usage of the USBGETSOFTC macro, which was really
only a cast to (void *).

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.74 2007/06/10 14:49:00 mbalmer Exp $	*/
d191 3
a193 3
int axe_miibus_readreg(device_ptr_t, int, int);
void axe_miibus_writereg(device_ptr_t, int, int, int);
void axe_miibus_statchg(device_ptr_t);
d249 1
a249 1
axe_miibus_readreg(device_ptr_t dev, int phy, int reg)
d297 1
a297 1
axe_miibus_writereg(device_ptr_t dev, int phy, int reg, int val)
d321 1
a321 1
axe_miibus_statchg(device_ptr_t dev)
d797 1
a797 1
axe_activate(device_ptr_t self, enum devact act)
@


1.74
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.73 2007/06/10 10:53:48 mbalmer Exp $	*/
d251 1
a251 1
	struct axe_softc	*sc = USBGETSOFTC(dev);
d299 1
a299 1
	struct axe_softc	*sc = USBGETSOFTC(dev);
d323 1
a323 1
	struct axe_softc	*sc = USBGETSOFTC(dev);
@


1.73
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.72 2007/06/10 10:15:35 mbalmer Exp $	*/
d351 1
a351 1
		printf("%s: media change failed\n", USBDEVNAME(sc->axe_dev));
d572 1
a572 1
	char *devname = USBDEVNAME(sc->axe_dev);
d609 1
a609 1
	printf("%s: %s", USBDEVNAME(sc->axe_dev), devinfop);
d733 1
a733 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->axe_dev), __func__));
d779 1
a779 1
		    USBDEVNAME(sc->axe_dev));
d801 1
a801 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->axe_dev), __func__));
d842 1
a842 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->axe_dev), __func__));
d873 1
a873 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->axe_dev), __func__));
d914 1
a914 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->axe_dev),__func__));
d927 1
a927 1
			    USBDEVNAME(sc->axe_dev), usbd_errstr(status));
d1007 1
a1007 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->axe_dev), __func__));
d1070 1
a1070 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->axe_dev),
d1108 1
a1108 1
			 USBDEVNAME(sc->axe_dev), __func__));
@


1.72
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.71 2007/06/09 12:22:53 mbalmer Exp $	*/
d219 1
a219 1
		usb_detach_wakeup(USBDEV(sc->axe_dev));
d723 1
a723 1
			   USBDEV(sc->axe_dev));
d763 1
a763 1
		usb_detach_wait(USBDEV(sc->axe_dev));
d786 1
a786 1
		usb_detach_wait(USBDEV(sc->axe_dev));
d791 1
a791 1
			   USBDEV(sc->axe_dev));
@


1.71
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.70 2007/06/05 08:43:55 mbalmer Exp $	*/
d717 1
a717 1
	usb_callout_init(sc->axe_stat_ch);
d739 1
a739 1
	usb_uncallout(sc->axe_stat_ch, axe_tick, sc);
d1114 3
a1116 1
	usb_callout(sc->axe_stat_ch, hz, axe_tick, sc);
d1315 3
a1317 1
	usb_callout(sc->axe_stat_ch, hz, axe_tick, sc);
d1445 1
a1445 1
	usb_uncallout(sc->axe_stat_ch, axe_tick, sc);
@


1.70
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.69 2007/05/27 04:00:24 jsg Exp $	*/
a807 1
		if_deactivate(&sc->axe_ec.ec_if);
@


1.69
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.68 2007/05/21 05:40:27 jsg Exp $	*/
d146 1
a146 1
Static const struct axe_type axe_devs[] = {
d178 24
a201 24
Static int axe_tx_list_init(struct axe_softc *);
Static int axe_rx_list_init(struct axe_softc *);
Static struct mbuf *axe_newbuf(void);
Static int axe_encap(struct axe_softc *, struct mbuf *, int);
Static void axe_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void axe_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void axe_tick(void *);
Static void axe_tick_task(void *);
Static void axe_start(struct ifnet *);
Static int axe_ioctl(struct ifnet *, u_long, caddr_t);
Static void axe_init(void *);
Static void axe_stop(struct axe_softc *);
Static void axe_watchdog(struct ifnet *);
Static int axe_miibus_readreg(device_ptr_t, int, int);
Static void axe_miibus_writereg(device_ptr_t, int, int, int);
Static void axe_miibus_statchg(device_ptr_t);
Static int axe_cmd(struct axe_softc *, int, int, int, void *);
Static int axe_ifmedia_upd(struct ifnet *);
Static void axe_ifmedia_sts(struct ifnet *, struct ifmediareq *);
Static void axe_reset(struct axe_softc *sc);

Static void axe_setmulti(struct axe_softc *);
Static void axe_lock_mii(struct axe_softc *sc);
Static void axe_unlock_mii(struct axe_softc *sc);
d203 2
a204 2
Static void axe_ax88178_init(struct axe_softc *);
Static void axe_ax88772_init(struct axe_softc *);
d207 1
a207 1
Static void
d214 1
a214 1
Static void
d222 1
a222 1
Static int
d248 1
a248 1
Static int
d296 1
a296 1
Static void
d320 1
a320 1
Static void
d359 1
a359 1
Static int
d379 1
a379 1
Static void
d390 1
a390 1
Static void
d435 1
a435 1
Static void
d447 1
a447 1
Static void
d501 1
a501 1
Static void
d815 1
a815 1
Static struct mbuf *
d836 1
a836 1
Static int
d867 1
a867 1
Static int
d902 1
a902 1
Static void
d1018 1
a1018 1
Static void
d1063 1
a1063 1
Static void
d1082 1
a1082 1
Static void
d1120 1
a1120 1
Static int
d1172 1
a1172 1
Static void
d1215 1
a1215 1
Static void
d1318 1
a1318 1
Static int
d1402 1
a1402 1
Static void
d1429 1
a1429 1
Static void
@


1.68
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.67 2007/05/21 05:18:56 jsg Exp $	*/
d544 2
a545 1
USB_MATCH(axe)
d547 1
a547 1
	USB_MATCH_START(axe, uaa);
d560 2
a561 1
USB_ATTACH(axe)
d563 2
a564 1
	USB_ATTACH_START(axe, sc, uaa);
d577 1
a577 1
	USB_ATTACH_SETUP;
d586 1
a586 1
		USB_ATTACH_ERROR_RETURN;
d600 1
a600 1
		USB_ATTACH_ERROR_RETURN;
d624 1
a624 1
			USB_ATTACH_ERROR_RETURN;
a723 2

	USB_ATTACH_SUCCESS_RETURN;
d726 2
a727 1
USB_DETACH(axe)
d729 1
a729 1
	USB_DETACH_START(axe, sc);
@


1.67
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.66 2007/05/14 00:46:21 jsg Exp $	*/
d135 2
a136 2
#define DPRINTF(x)	do { if (axedebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (axedebug >= (n)) logprintf x; } while (0)
@


1.66
log
@Convert from lockmgr to rwlock.
Initial diff from krw@@, uneeded lock_mii()/unlock_mii() on all commands
in existing code removed by me so it doesn't try to recurse.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.65 2007/05/05 13:43:25 jsg Exp $	*/
d712 1
a712 1
	Ether_ifattach(ifp, eaddr);
@


1.65
log
@Remove axe_rxstart() which is an uneeded leftover from the FreeBSD version.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.64 2007/04/26 17:00:28 miod Exp $	*/
d97 1
a97 1
#include <sys/lock.h>
d211 1
a211 1
	usb_lockmgr(&sc->axe_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d217 1
a217 1
	usb_lockmgr(&sc->axe_mii_lock, LK_RELEASE, NULL, curproc);
a230 1
	axe_lock_mii(sc);
a240 1
	axe_unlock_mii(sc);
d589 1
a589 1
	lockinit(&sc->axe_mii_lock, PZERO, "axemii", 0, LK_CANRECURSE);
@


1.64
log
@USB device lists do not need a terminating sentinel, so don't provide any;
this should prevent phantom devices from attaching axe or uberry on
some machines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.63 2007/04/09 08:57:51 jsg Exp $	*/
a185 1
Static void axe_rxstart(struct ifnet *);
a895 23
}

Static void
axe_rxstart(struct ifnet *ifp)
{
	struct axe_softc	*sc;
	struct axe_chain	*c;

	sc = ifp->if_softc;
	axe_lock_mii(sc);
	c = &sc->axe_cdata.axe_rx_chain[sc->axe_cdata.axe_rx_prod];

	memset(c->axe_buf, 0, sc->axe_bufsz);

	/* Setup new transfer. */
	usbd_setup_xfer(c->axe_xfer, sc->axe_ep[AXE_ENDPT_RX],
	    c, c->axe_buf, sc->axe_bufsz,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, axe_rxeof);
	usbd_transfer(c->axe_xfer);
	axe_unlock_mii(sc);

	return;
@


1.63
log
@Assert my copyright for the AX88178/AX88772 bits over the last few years.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.62 2007/04/09 08:42:55 jsg Exp $	*/
d171 1
a171 2
	{ { USB_VENDOR_SITECOMEU, USB_PRODUCT_SITECOMEU_LN028 }, AX178 },
	{ { 0, 0}, 0 }
@


1.62
log
@Remove any possibility of of an underflow happening when
pulling packets out of the usb buffer in rxeof.

Potential issue pointed out by Hans Petter Selasky <hselasky@@c2i.net>
@
text
@d1 17
a17 1
/*	$OpenBSD: if_axe.c,v 1.61 2007/04/09 08:12:59 jsg Exp $	*/
@


1.61
log
@Add missing letoh16() for eeprom value.
Pointed out by Hans Petter Selasky <hselasky@@c2i.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.60 2007/02/17 02:19:59 jsg Exp $	*/
a952 3
			if ((pktlen % 2) != 0)
				pktlen++;

d969 8
a976 1
			total_len -= pktlen + (pktlen % 2);
@


1.60
log
@Add some additional device ids found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.59 2007/01/18 06:28:11 jsg Exp $	*/
d445 2
@


1.59
log
@Add a bunch of as yet untested AX88178 devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.58 2007/01/18 04:36:57 jsg Exp $	*/
d145 1
d151 1
@


1.58
log
@Add support for AX88772 devices with external PHY.

Thanks to Marco S Hyman for sending me hardware to play with.
Committed over DUB-E100 rev B1 with external IC Plus PHY.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.57 2006/12/07 18:24:49 reyk Exp $	*/
d137 1
d147 1
d150 1
d153 1
@


1.57
log
@some cleanup for axe(4):
- remove IFF_RUNNING check from axe_init() and check for the
appropriate condition before calling axe_init().
- check for MTU too small, as done everywhere else.
- remove unnecessary setting of error to 0, its initialized to 0 in
axe_ioctl().
- use the IFQ_IS_EMPTY macro in axe_watchdog().

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.56 2006/12/04 17:12:07 damien Exp $	*/
d142 1
d473 1
a473 1
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0, NULL);
d476 1
a476 1
	    AXE_178_RESET_PRL | AXE_178_RESET_MAGIC, NULL);
d487 29
a515 7
	/* ask for embedded PHY */
	axe_cmd(sc, AXE_CMD_SW_PHY_SELECT, 0, 0x01, NULL);
	usbd_delay_ms(sc->axe_udev, 10);

	/* power down and reset state, pin reset state */
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0x00, NULL);
	usbd_delay_ms(sc->axe_udev, 60);
a516 2
	/* power down/reset state, pin operating state */
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0x48, NULL);
a517 7

	/* power up, reset */
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0x08, NULL);

	/* power up, operating */
	axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0x28, NULL);

d617 6
d641 1
a641 1
	 * Load IPG values and PHY indexes.
a643 4
	axe_cmd(sc, AXE_CMD_READ_PHYID, 0, 0, (void *)&sc->axe_phyaddrs);

	DPRINTF((" phyaddrs[0]: %x phyaddrs[1]: %x\n",
	    sc->axe_phyaddrs[0], sc->axe_phyaddrs[1]));
@


1.56
log
@avoid unnecessary copies (memcpy(x, x, n)) in the TX path.

"works fine, even under high load" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.55 2006/10/03 19:46:08 damien Exp $	*/
a1205 3
	if (ifp->if_flags & IFF_RUNNING)
		return;

d1312 2
a1313 3
		axe_init(sc);

		switch (ifa->ifa_addr->sa_family) {
d1315 1
a1315 1
		case AF_INET:
d1317 1
a1317 3
			break;
#endif /* INET */
		}
d1321 1
a1321 1
		if (ifr->ifr_mtu > ETHERMTU)
d1323 1
a1323 1
		else
a1351 1
		error = 0;
d1401 1
a1401 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.55
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).

tested by jolan@@ on macppc
"diffs look ok" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.54 2006/07/09 22:46:38 dlg Exp $	*/
d1138 2
a1139 2
	    c, c->axe_buf, length, USBD_FORCE_SHORT_XFER, 10000,
	    axe_txeof);
@


1.54
log
@get rid of some ifdef __otherbsd__ goo. no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.53 2006/06/23 06:27:11 miod Exp $	*/
d1167 1
a1167 1
	IF_DEQUEUE(&ifp->if_snd, m_head);
a1171 1
		IF_PREPEND(&ifp->if_snd, m_head);
d1175 1
@


1.53
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.52 2006/06/01 04:27:02 pascoe Exp $	*/
a75 6
#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
#include "rnd.h"
#endif

a83 1
#if defined(__OpenBSD__)
a84 1
#endif
a91 3
#if defined(__NetBSD__)
#include <net/if_arp.h>
#endif
a98 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined(__NetBSD__) */

#if defined(__OpenBSD__)
a105 1
#endif /* defined(__OpenBSD__) */
@


1.52
log
@Pass the value of IPG2 to the AX88178 in the index register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.51 2006/06/01 04:23:13 pascoe Exp $	*/
a787 1
		return (EOPNOTSUPP);
@


1.51
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.50 2006/06/01 04:07:46 pascoe Exp $	*/
d1256 2
a1257 3
		axe_cmd(sc, AXE_178_CMD_WRITE_IPG012, 0,
		    (sc->axe_ipgs[0]) | (sc->axe_ipgs[1] << 8) |
		    (sc->axe_ipgs[2] << 16), NULL);
@


1.50
log
@Whitespace cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.49 2006/04/23 20:21:31 krw Exp $	*/
d333 1
a333 1
	
d364 2
a365 2
        struct axe_softc        *sc = ifp->if_softc;
        struct mii_data         *mii = GET_MII(sc);
d367 7
a373 7
        sc->axe_link = 0;
        if (mii->mii_instance) {
                struct mii_softc        *miisc;
                LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
                         mii_phy_reset(miisc);
        }
        mii_mediachg(mii);
d375 1
a375 1
        return (0);
d384 2
a385 2
        struct axe_softc        *sc = ifp->if_softc;
        struct mii_data         *mii = GET_MII(sc);
d387 3
a389 3
        mii_pollstat(mii);
        ifmr->ifm_active = mii->mii_media_active;
        ifmr->ifm_status = mii->mii_media_status;
d535 1
a535 1
	if (!uaa->iface) {
a536 1
	}
d762 1
a762 1
		       USBDEVNAME(sc->axe_dev));
d1183 1
a1183 1
	if (!sc->axe_link) {
a1184 1
	}
d1186 1
a1186 1
	if (ifp->if_flags & IFF_OACTIVE) {
a1187 1
	}
d1190 1
a1190 1
	if (m_head == NULL) {
a1191 1
	}
d1204 2
a1205 2
	 if (ifp->if_bpf)
	 	bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
d1460 1
a1460 1
		    	sc->axe_unit, usbd_errstr(err));
d1465 1
a1465 1
		    	sc->axe_unit, usbd_errstr(err));
d1474 1
a1474 1
		    	sc->axe_unit, usbd_errstr(err));
d1488 1
a1488 1
		    	sc->axe_unit, usbd_errstr(err));
@


1.49
log
@Remove superfluous use of usb_callout_init() (== timeout_set()).

Superfluous because the immediately following usb_callout() does the
same timeout_set(). And superfluous because the same usb_callout_init
was done during attach.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.48 2006/04/13 15:27:49 jolan Exp $	*/
d342 1
a342 1
			val |=  AXE_178_MEDIA_100TX;
d539 1
a539 1
	return (axe_lookup(uaa->vendor, uaa->product) != NULL ? 
d599 2
a600 2
		sc->axe_bufsz = (sc->axe_udev->speed == USB_SPEED_HIGH) ? 
		    AXE_178_MAX_BUFSZ : AXE_178_MIN_BUFSZ; 
d1274 1
a1274 1
			rxmode |= AXE_178_RXCMD_MFB;  
@


1.48
log
@free mem if attach fails; netbsd coverity cid 2329

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.47 2006/03/25 22:41:46 djm Exp $	*/
a1324 1
	usb_callout_init(sc->axe_stat_ch);
@


1.47
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.46 2006/03/07 04:41:19 krw Exp $	*/
d570 1
d583 2
a584 1
			       sc->axe_unit);
@


1.46
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.45 2006/01/29 03:22:52 brad Exp $	*/
a105 2
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))

d991 1
a991 1
			BPF_MTAP(ifp, m);
d1207 1
a1207 1
	 	BPF_MTAP(ifp, m_head);
@


1.45
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.44 2006/01/10 10:15:22 dlg Exp $	*/
a95 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a698 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, USBDEVNAME(sc->axe_dev),
	    RND_TYPE_NET, 0);
#endif
a752 5
#if defined(__NetBSD__)
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
#endif /* __NetBSD__ */
@


1.44
log
@fix axe on big endian archs. for jolan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.43 2005/12/21 12:33:07 jsg Exp $	*/
d951 1
a951 1
			usbd_clear_endpoint_stall(sc->axe_ep[AXE_ENDPT_RX]);
d1060 1
a1060 1
			usbd_clear_endpoint_stall(sc->axe_ep[AXE_ENDPT_TX]);
@


1.43
log
@Don't try to predict what different eeprom settings mean
so much, makes the Level One AX88178 adapter work.

Interestingly enough the Level One adapter seems to work fine
without stalls.  Though it uses ukphy, I think the correct phy
types are supposed to be written in by the driver based on the
values in the eeprom...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.42 2005/12/09 04:51:55 jsg Exp $	*/
d972 6
a977 2
			if ((hdr.len ^ hdr.ilen) != 0xffff ||
			    (hdr.len > total_len)) {
a981 1
			pktlen = hdr.len;
d1149 1
a1149 1
		hdr.len = m->m_pkthdr.len;
@


1.42
log
@Mention which chipset devices use on attach.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.41 2005/11/29 23:16:58 jsg Exp $	*/
d473 1
a473 2
		if (eeprom & 0x80)
			gpio0 = 0;
d478 17
a494 22
	/* GPIO voodoo required to turn on PHY */
	if (gpio0)
		printf("gpio0 path not done! PHY not enabled\n");
	else {
		axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x008c, NULL);
		usbd_delay_ms(sc->axe_udev, 40);
		if (phymode != 1) {
			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
			usbd_delay_ms(sc->axe_udev, 30);

			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x001c, NULL);
			usbd_delay_ms(sc->axe_udev, 300);

			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
			usbd_delay_ms(sc->axe_udev, 30);
		} else {
			DPRINTF(("axe gpio phymode == 1 path\n"));
			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x0004, NULL);
			usbd_delay_ms(sc->axe_udev, 30);
			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x000c, NULL);
			usbd_delay_ms(sc->axe_udev, 30);
		}
a503 2
	/* XXX is a delay this long required for PHY to work? */
	usbd_delay_ms(sc->axe_udev, 1500);
@


1.41
log
@Add support for ASIX AX88772 10/100 based adapters which are very similiar
to the gigabit AX88178 but with a different initialisation routine
because the PHY is not external.

Man page changes reviewed by jmc@@ and oxford commas added per his
sugestion.

Thanks to Bruno Scap for donating an adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.40 2005/09/27 21:14:40 jolan Exp $	*/
d636 1
a636 1
	if (sc->axe_flags & AX178)
d638 2
a639 1
	else if (sc->axe_flags & AX772)
d641 3
@


1.40
log
@enable support for gigabit adapters; it works reliably with USB1 but
seems to stall under some conditions with USB2 so you may wish to
disable ehci in the mean time

ok dlg@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.39 2005/08/29 09:21:14 jsg Exp $	*/
d160 1
d165 1
d208 3
d339 1
a339 1
	if (sc->axe_flags & AX178) {
d454 87
a567 1
	u_int16_t eeprom;
d572 1
a572 1
	int i, s, gpio0 = 0, phymode = 0;
d609 1
a609 1
	if (sc->axe_flags & AX178)
d636 4
a639 54
	if (sc->axe_flags & AX178) {
		axe_cmd(sc, AXE_CMD_SROM_WR_ENABLE, 0, 0, NULL);
		/* XXX magic */
		axe_cmd(sc, AXE_CMD_SROM_READ, 0, 0x0017, &eeprom);
		axe_cmd(sc, AXE_CMD_SROM_WR_DISABLE, 0, 0, NULL);

		DPRINTF((" EEPROM is 0x%x\n", eeprom));

		/* if EEPROM is invalid we have to use to GPIO0 */
		if (eeprom == 0xffff) {
			phymode = 0;
			gpio0 = 1;
		} else {
			phymode = eeprom & 7;
			if (eeprom & 0x80)
				gpio0 = 0;
		}

		DPRINTF(("use gpio0: %d, phymode %d\n", gpio0, phymode));

		/* GPIO voodoo required to turn on PHY */
		if (gpio0)
			printf("gpio0 path not done! PHY not enabled\n");
		else {
			axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x008c, NULL);
			usbd_delay_ms(sc->axe_udev, 40);
			if (phymode != 1) {
				axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
				usbd_delay_ms(sc->axe_udev, 30);

				axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x001c, NULL);
				usbd_delay_ms(sc->axe_udev, 300);

				axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x003c, NULL);
				usbd_delay_ms(sc->axe_udev, 30);
			} else {
				DPRINTF(("axe gpio phymode == 1 path\n"));
				axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x0004, NULL);
				usbd_delay_ms(sc->axe_udev, 30);
				axe_cmd(sc, AXE_CMD_WRITE_GPIO, 0, 0x000c, NULL);
				usbd_delay_ms(sc->axe_udev, 30);
			}
		}

		/* soft reset */
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0, 0, NULL);
		usbd_delay_ms(sc->axe_udev, 150);
		axe_cmd(sc, AXE_CMD_SW_RESET_REG, 0,
		    AXE_178_RESET_PRL | AXE_178_RESET_MAGIC, NULL);
		usbd_delay_ms(sc->axe_udev, 150);
		axe_cmd(sc, AXE_CMD_RXCTL_WRITE, 0, 0, NULL);
		/* XXX is a delay this long required for PHY to work? */
		usbd_delay_ms(sc->axe_udev, 1500);
	}
d644 1
a644 1
	if (sc->axe_flags & AX178)
d962 1
a962 1
		if (sc->axe_flags & AX178) {
d1147 1
a1147 1
	if (sc->axe_flags & AX178) {
d1272 1
a1272 1
	if (sc->axe_flags & AX178)
d1284 6
a1289 1
	if (!(sc->axe_flags & AX178))
a1290 3
	else if (sc->axe_udev->speed == USB_SPEED_HIGH)
		/* largest possible USB buffer size for AX88178 */
		rxmode |= AXE_178_RXCMD_MFB;
@


1.39
log
@Handle AX88178 on 12 Mbit USB controllers such as ohci & uhci more
gracefully. ok dlg@@ permission granted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.38 2005/08/28 03:34:33 jsg Exp $	*/
a159 1
#ifdef AXE_DEBUG
a160 1
#endif
@


1.38
log
@The AX88178 sends multiple frames per USB transfer
and has extra bytes and rules to deal with this.

Initial rxeof/encap changes by me, dlg@@ rewrote
axe_rxeof and axe_newbuf from scratch and cleaned up encap
so they can jump over buildings in a single bound
and be more elegant/readable.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.37 2005/08/28 02:55:18 jsg Exp $	*/
d100 2
d139 1
d521 2
a522 1
		sc->axe_bufsz = AXE_178_MAX_BUFSZ;
d1104 1
a1104 1
	int			length;
d1109 2
d1120 1
a1120 1
		if ((length % 512) == 0) {
d1247 1
a1247 1
	else
@


1.37
log
@We don't need to do a PHY select for AX88178 but we should
do a generic soft reset before doing a specific one.
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.36 2005/08/28 02:53:49 jsg Exp $	*/
d181 1
a181 1
Static int axe_newbuf(struct axe_softc *, struct axe_chain *, struct mbuf *);
d773 2
a774 5
/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
Static int
axe_newbuf(struct axe_softc *sc, struct axe_chain *c, struct mbuf *m)
d776 1
a776 1
	struct mbuf		*m_new = NULL;
d778 3
a780 9
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->axe_dev),__func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", USBDEVNAME(sc->axe_dev));
			return (ENOBUFS);
		}
d782 4
a785 12
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", USBDEVNAME(sc->axe_dev));
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
d788 2
a789 2
	m_adj(m_new, ETHER_ALIGN);
	c->axe_mbuf = m_new;
d791 1
a791 1
	return (0);
d808 1
a808 2
		if (axe_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
d866 1
a866 5
	if (axe_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		axe_unlock_mii(sc);
		return;
	}
d886 6
a891 3
	struct axe_softc	*sc;
	struct axe_chain	*c;
	struct ifnet		*ifp;
d893 1
a893 1
	u_int32_t		total_len;
a895 4
	c = priv;
	sc = c->axe_sc;
	ifp = GET_IFP(sc);

d918 9
a926 1
	m = c->axe_mbuf;
d928 1
a928 4
	if (total_len <= sizeof(struct ether_header)) {
		ifp->if_ierrors++;
		goto done;
	}
d930 2
a931 3
	ifp->if_ipackets++;
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = m->m_len = total_len;
d933 5
d939 7
a945 1
	memcpy(mtod(c->axe_mbuf, char *), c->axe_buf, total_len);
d947 5
a951 2
	/* No errors; receive the packet. */
	total_len -= ETHER_CRC_LEN + 4;
d953 3
a955 1
	s = splnet();
d957 1
a957 5
	/* XXX ugly */
	if (axe_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done1;
	}
d959 2
d962 2
a963 2
	if (ifp->if_bpf)
		BPF_MTAP(ifp, m);
d966 5
a970 5
	DPRINTFN(10,("%s: %s: deliver %d\n", USBDEVNAME(sc->axe_dev),
		    __func__, m->m_len));
	IF_INPUT(ifp, m);
 done1:
	splx(s);
d972 2
a973 1
 done:
d982 2
a983 2
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->axe_dev),
		    __func__));
d1099 2
d1104 22
a1125 5
	/*
	 * Copy the mbuf data into a contiguous buffer, leaving two
	 * bytes at the beginning to hold the frame length.
	 */
	m_copydata(m, 0, m->m_pkthdr.len, c->axe_buf);
d1129 1
a1129 1
	    c, c->axe_buf, m->m_pkthdr.len, USBD_FORCE_SHORT_XFER, 10000,
@


1.36
log
@Write back IPG values in a manner more likely to work.
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.35 2005/08/28 02:51:05 jsg Exp $	*/
d587 2
a588 1
		axe_cmd(sc, AXE_CMD_SW_PHY_SELECT, 0, 0, NULL);
a589 1
		/* soft reset */
@


1.35
log
@Tell the AX88178 to give us the full transaction size.
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.34 2005/08/28 02:49:25 jsg Exp $	*/
d1214 2
a1215 2
		    (sc->axe_ipgs[0] << 2) | (sc->axe_ipgs[1] << 1) |
		    (sc->axe_ipgs[2]), NULL);
@


1.34
log
@Account for larger USB transaction size of AX88178 by
making the size a member of the softc.
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.33 2005/08/28 02:46:12 jsg Exp $	*/
d1226 3
@


1.33
log
@We have to do some extra hand holding on link state change
on the AX88178 because of the external PHY.
ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.32 2005/08/12 11:56:16 jsg Exp $	*/
d516 6
d831 2
a832 1
			c->axe_buf = usbd_alloc_buffer(c->axe_xfer, AXE_BUFSZ);
d862 2
a863 1
			c->axe_buf = usbd_alloc_buffer(c->axe_xfer, AXE_BUFSZ);
d892 1
a892 1
	    c, c->axe_buf, AXE_BUFSZ,
d981 1
a981 1
	    c, c->axe_buf, AXE_BUFSZ,
d1262 1
a1262 1
		    c, c->axe_buf, AXE_BUFSZ,
@


1.32
log
@Add some delays in the GPIO code so AX88178 phy gets powered up.
Suggested by ASIX.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.31 2005/08/11 05:24:17 jsg Exp $	*/
d333 15
a347 3
	if (sc->axe_flags & AX178)
		val |= (AXE_178_MEDIA_RX_EN | AXE_178_MEDIA_MAGIC |
		    AXE_178_MEDIA_ENCK);
@


1.31
log
@Only match AX88178 if AXE_DEBUG is defined for the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.30 2005/08/10 23:07:33 jsg Exp $	*/
d550 1
d553 2
d556 2
d559 1
d561 1
d563 1
d565 1
d570 1
d574 1
a574 1
		delay(500);
d576 2
@


1.30
log
@Some of the bits that will be required for AX88178.
PHY doesn't attach possibly due to not twiddling GPIO
pins correctly, rx and tx pipes being swapped not dealt
with yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.29 2005/08/01 05:36:48 brad Exp $	*/
d157 1
d159 1
@


1.29
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.28 2005/07/18 07:38:43 jsg Exp $	*/
d157 1
d265 2
d330 5
d461 1
d466 1
a466 1
	int i, s;
d480 2
d523 43
d569 4
a572 1
	axe_cmd(sc, AXE_CMD_READ_NODEID, 0, 0, &eaddr);
d580 3
d1178 9
a1186 3
	axe_cmd(sc, AXE_CMD_WRITE_IPG0, 0, sc->axe_ipgs[0], NULL);
	axe_cmd(sc, AXE_CMD_WRITE_IPG1, 0, sc->axe_ipgs[1], NULL);
	axe_cmd(sc, AXE_CMD_WRITE_IPG2, 0, sc->axe_ipgs[2], NULL);
d1189 3
a1191 1
	rxmode = AXE_RXCMD_UNICAST|AXE_RXCMD_MULTICAST|AXE_RXCMD_ENABLE;
@


1.28
log
@Good Way GWUSB2E Ethernet, found in Good Way USB docking stations.
ID from <david-b () pacbell ! net> via Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.27 2005/07/02 22:21:12 brad Exp $	*/
d454 1
a454 1
	char devinfo[1024];
d459 1
a459 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo); 
d488 2
a489 1
	printf("%s: %s", USBDEVNAME(sc->axe_dev), devinfo);
@


1.27
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.26 2005/07/02 22:17:57 brad Exp $	*/
d162 1
@


1.26
log
@don't call mii_pollstat() right after mii_tick() in foo_tick_task()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.25 2005/06/08 17:03:01 henning Exp $	*/
d1300 1
a1371 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.25
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.24 2005/03/14 04:08:49 deraadt Exp $	*/
d988 7
a994 10
	if (!sc->axe_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			DPRINTF(("%s: %s: got link\n",
				 USBDEVNAME(sc->axe_dev), __func__));
			sc->axe_link++;
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				   axe_start(ifp);
		}
@


1.24
log
@support jvc mp-prx1; iedowse
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.23 2005/02/12 10:21:04 jsg Exp $	*/
a130 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1197 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.23
log
@Additional axe devices found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.22 2005/01/03 22:45:52 brad Exp $	*/
d167 1
@


1.22
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.21 2004/12/31 02:21:32 dlg Exp $	*/
d159 2
d162 1
d164 1
@


1.21
log
@fixes so axe can work on big endian machines
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.20 2004/11/11 13:01:45 dlg Exp $	*/
d1255 1
@


1.20
log
@from netbsd, if_axe.c revision 1.6
When adding/deleting multicast addresses, only whack the address
filter if the interface is marked RUNNING.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.19 2004/11/11 12:58:45 dlg Exp $	*/
d250 1
a250 1
	u_int16_t		val;
d272 1
a272 1
	val = 0;
d276 1
a276 1
	err = axe_cmd(sc, AXE_CMD_MII_READ_REG, reg, phy, (void *)&val);
d285 1
a285 1
	if (val)
d288 1
a288 1
	return (val);
d296 1
d301 2
d305 1
a305 1
	err = axe_cmd(sc, AXE_CMD_MII_WRITE_REG, reg, phy, (void *)&val);
d375 1
d384 2
a385 1
	axe_cmd(sc, AXE_CMD_RXCTL_READ, 0, 0, (void *)&rxmode);
d388 1
a388 1
	allmulti:
d1184 1
a1184 1
	u_int16_t		rxmode;
d1229 3
a1231 5
				axe_cmd(sc, AXE_CMD_RXCTL_READ,
					0, 0, (void *)&rxmode);
				rxmode |= AXE_RXCMD_PROMISC;
				axe_cmd(sc, AXE_CMD_RXCTL_WRITE,
					0, rxmode, NULL);
d1237 3
a1239 5
				axe_cmd(sc, AXE_CMD_RXCTL_READ,
					0, 0, (void *)&rxmode);
				rxmode &= ~AXE_RXCMD_PROMISC;
				axe_cmd(sc, AXE_CMD_RXCTL_WRITE,
					0, rxmode, NULL);
@


1.19
log
@the other half of the changes from netbsds if_axe.c revision 1.5:
Set full duplex mode when status tells us to.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.17 2004/11/11 12:38:48 dlg Exp $	*/
d1259 2
a1260 1
			axe_setmulti(sc);
@


1.18
log
@half of the changes from netbsds if_axe.c revision 1.5:
Protect MII reads and writes properly against multiple access.
@
text
@a314 1
#ifdef notdef
d317 12
a328 3
#endif
	/* doesn't seem to be necessary */
	return;
@


1.17
log
@from netbsd, if_axe.c revision 1.5
Dont use lockmgr() from interrupt context.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.16 2004/11/11 12:32:57 dlg Exp $	*/
d272 1
d274 1
d278 1
d300 1
d304 1
a309 2

	return;
d458 1
a458 1
	lockinit(&sc->axe_mii_lock, PZERO, "axemii", 0, 0);
@


1.16
log
@from netbsd revisions 1.2 and 1.3

revision 1.2
Alphabetize the supported device list.

revision 1.3
Get rid of an oddly placed assert().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.15 2004/11/11 12:19:12 dlg Exp $	*/
d1272 1
a1274 1
	axe_lock_mii(sc);
d1279 1
a1283 2
	axe_unlock_mii(sc);

d1286 1
a1286 2

	return;
@


1.15
log
@make setup of the rx transfers consistent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.14 2004/11/10 14:01:25 dlg Exp $	*/
d161 1
d164 1
a165 1
	{ { USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUAU2KTX}, 0 },
a167 1
	{ { USB_VENDOR_COREGA, USB_PRODUCT_COREGA_FETHER_USB2_TX }, 0},
a717 1
assert(sc->axe_udev);
@


1.14
log
@add support for the Conceptronic SnapPort USB 2.0 LAN Adapter

thanks go to Paul de Weerd for providing the hardware
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.13 2004/11/10 10:14:48 grange Exp $	*/
d781 2
a782 1
	    c, mtod(c->axe_mbuf, char *), AXE_BUFSZ, USBD_SHORT_XFER_OK,
d1146 3
a1148 2
		    c, mtod(c->axe_mbuf, char *), AXE_BUFSZ,
		    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, axe_rxeof);
@


1.13
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.12 2004/10/04 13:01:29 deraadt Exp $	*/
d160 1
@


1.12
log
@COREGA_FETHER_USB2_TX; tested by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_axe.c,v 1.11 2004/10/01 04:08:46 jsg Exp $	*/
d520 1
a520 1
	strncpy(ifp->if_xname, devname, IFNAMSIZ);
@


1.11
log
@add some missing $, ok djm@@ 'That looks fine to me' millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
d470 1
a470 1
	printf("%s: %s\n", USBDEVNAME(sc->axe_dev), devinfo);
d476 1
a476 2
			printf("axe%d: couldn't get ep %d\n",
			    sc->axe_unit, i);
d513 1
a513 2
	printf("axe%d: Ethernet address: %s\n", sc->axe_unit,
	    ether_sprintf(eaddr));
@


1.10
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 2
@


1.9
log
@match the new ID
@
text
@a518 1
	ifp->if_mtu = ETHERMTU;
@


1.8
log
@from freebsd via Jonathan Gray
"Use the USBD_FORCE_SHORT_XFER flag when setting up transmit transfers.
Without this, the device cannot detect the end of ethernet packets
whose size is a multiple of the USB packat size.

ok deraadt@@
@
text
@d157 8
a164 7
	{{ USB_VENDOR_ASIX, USB_PRODUCT_ASIX_AX88172 }, 0 },
	{{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DUBE100 }, 0 },
	{{ USB_VENDOR_LINKSYS2, USB_PRODUCT_LINKSYS2_USB200M }, 0 },
	{{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_FA120 }, 0 },
	{{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUAU2KTX }, 0},
	{{ USB_VENDOR_SYSTEMTALKS, USB_PRODUCT_SYSTEMTALKS_SGCX2UL}, 0},
	{{ 0, 0 }, 0 }
@


1.7
log
@typo
@
text
@d1003 2
a1004 1
	    c, c->axe_buf, m->m_pkthdr.len, 0, 10000, axe_txeof);
@


1.6
log
@another new device; shin@@happynet.co.jp
@
text
@d162 1
a162 1
	{{ USB_VENDOR_SYSTEMTALKS, USB_PRODUCT_SYSTEMTALKS_SGX2UL}, 0},
@


1.5
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d162 1
@


1.4
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d145 2
a146 2
#define DPRINTF(x)	if (axedebug) logprintf x
#define DPRINTFN(n,x)	if (axedebug >= (n)) logprintf x
@


1.3
log
@new axe; freebsd
@
text
@a191 1
Static u_int32_t axe_mchash(caddr_t);
a347 23
Static u_int32_t
axe_mchash(caddr_t addr)
{
	u_int32_t	crc, carry;
	int		idx, bit;
	u_int8_t	data;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (data & 0x01);
			crc <<= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return((crc >> 26) & 0x0000003F);
}

d380 1
a380 1
		h = axe_mchash(enm->enm_addrlo);
d1235 11
a1245 2
		axe_setmulti(sc);
		error = 0;
@


1.3.2.1
log
@Merge with the trunk
@
text
@@


1.3.2.2
log
@sync to head
@
text
@d192 1
d349 23
d404 1
a404 1
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
d1259 2
a1260 11
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			axe_setmulti(sc);
			error = 0;
		}
@


1.2
log
@Do not define AXE_DEBUG by default.
@
text
@d161 1
@


1.1
log
@axe usb ethernet driver hacked into the tree by taleck@@oz.net
@
text
@a143 2
#define AXE_DEBUG 1

@

