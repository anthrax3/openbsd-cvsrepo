head	1.69;
access;
symbols
	OPENBSD_6_2:1.69.0.4
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.68.0.4
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.67.0.4
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.62.0.4
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.59.0.2
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.56.0.8
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.6
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.52.0.4
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.8
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.4
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.2.0.4
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.7
	UBC:1.2.0.2
	UBC_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_3_0:1.1.0.2
	OPENBSD_3_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.69
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	6s3MfY9d6ZKdL2Uz;

1.68
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.67;
commitid	blfE5YU3eGM81J65;

1.67
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches;
next	1.66;
commitid	zkpZsVIWMnE2TPgn;

1.66
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.65;
commitid	p4LJxGKbi0BU2cG6;

1.65
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.64;
commitid	Qb045HZ5OhQfU69H;

1.64
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.63;
commitid	AGVMSdzbrCHVAlSG;

1.63
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.62;
commitid	OBNa5kfxQ2UXoiIw;

1.62
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.61;

1.61
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.06.16.59.02;	author pirofti;	state Exp;
branches;
next	1.59;

1.59
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2010.11.16.22.28.55;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.03.20.58.43;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2008.02.22.10.46.57;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.22.17.53.05;	author okan;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.14.14.37.40;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.13.02.02.20;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.09.12.18.06.11;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.23.15.40.38;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.04.06.49.13;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.07.01.04.23.31;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.15.04.37.52;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.16.10.37.51;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2006.02.11.09.32.48;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.02.07.23.35.11;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.04.00.37.21;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.23.21.20.14;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.28.22.35.16;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.16.06.18.12;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.16.05.56.55;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.10.12.05.08;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.10.11.58.52;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.26.00.37.07;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.20.21.34.46;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.20.06.01.04;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.26.22.25.54;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.07.20.22.35;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.19.08.06.17;	author cedric;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.10.03.02.50;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.10.02.01.37.36;	author millert;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.2.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.69
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: uplcom.c,v 1.68 2016/09/02 09:14:59 mpi Exp $	*/
/*	$NetBSD: uplcom.c,v 1.29 2002/09/23 05:51:23 simonb Exp $	*/
/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ichiro FUKUHARA (ichiro@@ichiro.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Simple datasheet
 * http://www.prolific.com.tw/PDF/PL-2303%20Market%20Spec.pdf
 * http://www.hitachi-hitec.com/jyouhou/prolific/2303.pdf
 * 	(english)
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#ifdef UPLCOM_DEBUG
#define DPRINTFN(n, x)  do { if (uplcomdebug > (n)) printf x; } while (0)
int	uplcomdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define	UPLCOM_IFACE_INDEX	0
#define	UPLCOM_SECOND_IFACE_INDEX	1

#define	UPLCOM_SET_REQUEST	0x01
#define	UPLCOM_SET_CRTSCTS	0x41
#define	UPLCOM_HX_SET_CRTSCTS	0x61
#define RSAQ_STATUS_CTS		0x80
#define RSAQ_STATUS_DSR		0x02
#define RSAQ_STATUS_DCD		0x01

struct	uplcom_softc {
	struct device		 sc_dev;	/* base device */
	struct usbd_device	*sc_udev;	/* USB device */
	struct usbd_interface	*sc_iface;	/* interface */
	int			 sc_iface_number;	/* interface number */

	struct usbd_interface	*sc_intr_iface;	/* interrupt interface */
	int			 sc_intr_number;	/* interrupt number */
	struct usbd_pipe	*sc_intr_pipe;	/* interrupt pipe */
	u_char			*sc_intr_buf;	/* interrupt buffer */
	int			 sc_isize;

	struct usb_cdc_line_state sc_line_state;/* current line state */
	int			 sc_dtr;	/* current DTR state */
	int			 sc_rts;	/* current RTS state */

	struct device		*sc_subdev;	/* ucom device */

	u_char			 sc_lsr;	/* Local status register */
	u_char			 sc_msr;	/* uplcom status register */
	int			 sc_type_hx;	/* HX variant */
};

/*
 * These are the maximum number of bytes transferred per frame.
 * The output buffer size cannot be increased due to the size encoding.
 */
#define UPLCOMIBUFSIZE 256
#define UPLCOMOBUFSIZE 256

usbd_status uplcom_reset(struct uplcom_softc *);
usbd_status uplcom_set_line_coding(struct uplcom_softc *sc,
    struct usb_cdc_line_state *state);
usbd_status uplcom_set_crtscts(struct uplcom_softc *);
void uplcom_intr(struct usbd_xfer *, void *, usbd_status);

void uplcom_set(void *, int, int, int);
void uplcom_dtr(struct uplcom_softc *, int);
void uplcom_rts(struct uplcom_softc *, int);
void uplcom_break(struct uplcom_softc *, int);
void uplcom_set_line_state(struct uplcom_softc *);
void uplcom_get_status(void *, int portno, u_char *lsr, u_char *msr);
int  uplcom_param(void *, int, struct termios *);
int  uplcom_open(void *, int);
void uplcom_close(void *, int);

struct	ucom_methods uplcom_methods = {
	uplcom_get_status,
	uplcom_set,
	uplcom_param,
	NULL,
	uplcom_open,
	uplcom_close,
	NULL,
	NULL,
};

static const struct usb_devno uplcom_devs[] = {
	{ USB_VENDOR_ALCATEL, USB_PRODUCT_ALCATEL_OT535 },
	{ USB_VENDOR_ANCHOR, USB_PRODUCT_ANCHOR_SERIAL },
	{ USB_VENDOR_ATEN, USB_PRODUCT_ATEN_UC232A },
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U257 },
	{ USB_VENDOR_ELECOM, USB_PRODUCT_ELECOM_UCSGT },
	{ USB_VENDOR_ELECOM, USB_PRODUCT_ELECOM_UCSGT0 },
	{ USB_VENDOR_HAL, USB_PRODUCT_HAL_IMR001 },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBRSAQ },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBRSAQ5 },
	{ USB_VENDOR_LEADTEK, USB_PRODUCT_LEADTEK_9531 },
	{ USB_VENDOR_MICROSOFT, USB_PRODUCT_MICROSOFT_700WX },
	{ USB_VENDOR_MOBILEACTION, USB_PRODUCT_MOBILEACTION_MA620 },
	{ USB_VENDOR_NOKIA, USB_PRODUCT_NOKIA_CA42 },
	{ USB_VENDOR_OTI, USB_PRODUCT_OTI_DKU5 },
	{ USB_VENDOR_PLX, USB_PRODUCT_PLX_CA42 },
	{ USB_VENDOR_PANASONIC, USB_PRODUCT_PANASONIC_TYTP50P6S },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303 },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303X },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303X2 },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_RSAQ2 },
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303BENQ },
	{ USB_VENDOR_PROLIFIC2, USB_PRODUCT_PROLIFIC2_PL2303 },
	{ USB_VENDOR_RADIOSHACK, USB_PRODUCT_RADIOSHACK_PL2303 },
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60 },
	{ USB_VENDOR_SAGEM, USB_PRODUCT_SAGEM_SERIAL },
	{ USB_VENDOR_SAMSUNG2, USB_PRODUCT_SAMSUNG2_I330 },
	{ USB_VENDOR_SIEMENS3, USB_PRODUCT_SIEMENS3_SX1 },
	{ USB_VENDOR_SIEMENS3, USB_PRODUCT_SIEMENS3_X65 },
	{ USB_VENDOR_SIEMENS3, USB_PRODUCT_SIEMENS3_X75 },
	{ USB_VENDOR_SITECOM, USB_PRODUCT_SITECOM_CN104 },
	{ USB_VENDOR_SOURCENEXT, USB_PRODUCT_SOURCENEXT_KEIKAI8 },
	{ USB_VENDOR_SOURCENEXT, USB_PRODUCT_SOURCENEXT_KEIKAI8_CHG },
	{ USB_VENDOR_SPEEDDRAGON, USB_PRODUCT_SPEEDDRAGON_MS3303H },
	{ USB_VENDOR_SUSTEEN, USB_PRODUCT_SUSTEEN_DCU11 },
	{ USB_VENDOR_SYNTECH, USB_PRODUCT_SYNTECH_SERIAL },
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UHA6400 },
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UPA9664 },
	{ USB_VENDOR_TRIPPLITE, USB_PRODUCT_TRIPPLITE_U209 },
	{ USB_VENDOR_SMART, USB_PRODUCT_SMART_PL2303 },
	{ USB_VENDOR_YCCABLE, USB_PRODUCT_YCCABLE_PL2303 }
};
#define uplcom_lookup(v, p) usb_lookup(uplcom_devs, v, p)

int uplcom_match(struct device *, void *, void *);
void uplcom_attach(struct device *, struct device *, void *);
int uplcom_detach(struct device *, int);

struct cfdriver uplcom_cd = {
	NULL, "uplcom", DV_DULL
};

const struct cfattach uplcom_ca = {
	sizeof(struct uplcom_softc), uplcom_match, uplcom_attach, uplcom_detach
};

int
uplcom_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	return (uplcom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uplcom_attach(struct device *parent, struct device *self, void *aux)
{
	struct uplcom_softc *sc = (struct uplcom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	usb_config_descriptor_t *cdesc;
	usb_device_descriptor_t *ddesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	char *devname = sc->sc_dev.dv_xname;
	usbd_status err;
	int i;
	struct ucom_attach_args uca;

	sc->sc_udev = dev;

	DPRINTF(("\n\nuplcom attach: sc=%p\n", sc));

	/* initialize endpoints */
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);

	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* get the device descriptor */
	ddesc = usbd_get_device_descriptor(sc->sc_udev);
	if (ddesc == NULL) {
		printf("%s: failed to get device descriptor\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/*
	 * The Linux driver suggest this will only be true for the HX
	 * variants. The datasheets disagree.
	 */
	if (ddesc->bDeviceClass == 0x02)
		sc->sc_type_hx = 0;
	else if (ddesc->bMaxPacketSize == 0x40)
		sc->sc_type_hx = 1;
	else
		sc->sc_type_hx = 0;

#ifdef USB_DEBUG
	/* print the chip type */
	if (sc->sc_type_hx) {
		DPRINTF(("uplcom_attach: chiptype 2303X\n"));
	} else {
		DPRINTF(("uplcom_attach: chiptype 2303\n"));
	}
#endif
	/* get the (first/common) interface */
	err = usbd_device2interface_handle(dev, UPLCOM_IFACE_INDEX,
							&sc->sc_iface);
	if (err) {
		printf("\n%s: failed to get interface, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Find the interrupt endpoints */

	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
		}
	}

	if (sc->sc_intr_number== -1) {
		printf("%s: Could not find interrupt in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* keep interface for interrupt */
	sc->sc_intr_iface = sc->sc_iface;

	/*
	 * USB-RSAQ1 has two interface
	 *
	 *  USB-RSAQ1       | USB-RSAQ2
	 * -----------------+-----------------
	 * Interface 0      |Interface 0
	 *  Interrupt(0x81) | Interrupt(0x81)
	 * -----------------+ BulkIN(0x02)
	 * Interface 1	    | BulkOUT(0x83)
	 *   BulkIN(0x02)   |
	 *   BulkOUT(0x83)  |
	 */
	if (cdesc->bNumInterface == 2) {
		err = usbd_device2interface_handle(dev,
				UPLCOM_SECOND_IFACE_INDEX, &sc->sc_iface);
		if (err) {
			printf("\n%s: failed to get second interface, err=%s\n",
			    devname, usbd_errstr(err));
			usbd_deactivate(sc->sc_udev);
			return;
		}
	}

	/* Find the bulk{in,out} endpoints */

	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkin = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
		}
	}

	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	sc->sc_dtr = sc->sc_rts = -1;
	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
	uca.ibufsize = UPLCOMIBUFSIZE;
	uca.obufsize = UPLCOMOBUFSIZE;
	uca.ibufsizepad = UPLCOMIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = sc->sc_iface;
	uca.methods = &uplcom_methods;
	uca.arg = sc;
	uca.info = NULL;

	err = uplcom_reset(sc);

	if (err) {
		printf("%s: reset failed, %s\n", sc->sc_dev.dv_xname,
			usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	DPRINTF(("uplcom: in=0x%x out=0x%x intr=0x%x\n",
			uca.bulkin, uca.bulkout, sc->sc_intr_number ));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
}

int
uplcom_detach(struct device *self, int flags)
{
	struct uplcom_softc *sc = (struct uplcom_softc *)self;
	int rv = 0;

	DPRINTF(("uplcom_detach: sc=%p flags=%d\n", sc, flags));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

usbd_status
uplcom_reset(struct uplcom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UPLCOM_SET_REQUEST;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, 0);
	if (err)
		return (EIO);

	return (0);
}

void
uplcom_set_line_state(struct uplcom_softc *sc)
{
	usb_device_request_t req;
	int ls;

	/* Make sure we have initialized state for sc_dtr and sc_rts */
	if (sc->sc_dtr == -1)
		sc->sc_dtr = 0;
	if (sc->sc_rts == -1)
		sc->sc_rts = 0;

	ls = (sc->sc_dtr ? UCDC_LINE_DTR : 0) |
	    (sc->sc_rts ? UCDC_LINE_RTS : 0);

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_CONTROL_LINE_STATE;
	USETW(req.wValue, ls);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, 0);

	(void)usbd_do_request(sc->sc_udev, &req, 0);

}

void
uplcom_set(void *addr, int portno, int reg, int onoff)
{
	struct uplcom_softc *sc = addr;

	switch (reg) {
	case UCOM_SET_DTR:
		uplcom_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		uplcom_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		uplcom_break(sc, onoff);
		break;
	default:
		break;
	}
}

void
uplcom_dtr(struct uplcom_softc *sc, int onoff)
{

	DPRINTF(("uplcom_dtr: onoff=%d\n", onoff));

	if (sc->sc_dtr != -1 && !sc->sc_dtr == !onoff)
		return;

	sc->sc_dtr = !!onoff;

	uplcom_set_line_state(sc);
}

void
uplcom_rts(struct uplcom_softc *sc, int onoff)
{
	DPRINTF(("uplcom_rts: onoff=%d\n", onoff));

	if (sc->sc_rts == -1 && !sc->sc_rts == !onoff)
		return;

	sc->sc_rts = !!onoff;

	uplcom_set_line_state(sc);
}

void
uplcom_break(struct uplcom_softc *sc, int onoff)
{
	usb_device_request_t req;

	DPRINTF(("uplcom_break: onoff=%d\n", onoff));

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SEND_BREAK;
	USETW(req.wValue, onoff ? UCDC_BREAK_ON : UCDC_BREAK_OFF);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, 0);

	(void)usbd_do_request(sc->sc_udev, &req, 0);
}

usbd_status
uplcom_set_crtscts(struct uplcom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("uplcom_set_crtscts: on\n"));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UPLCOM_SET_REQUEST;
	USETW(req.wValue, 0);
	USETW(req.wIndex,
	    (sc->sc_type_hx ? UPLCOM_HX_SET_CRTSCTS : UPLCOM_SET_CRTSCTS));
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, 0);
	if (err) {
		DPRINTF(("uplcom_set_crtscts: failed, err=%s\n",
			usbd_errstr(err)));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uplcom_set_line_coding(struct uplcom_softc *sc,
    struct usb_cdc_line_state *state)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("uplcom_set_line_coding: rate=%d fmt=%d parity=%d bits=%d\n",
		UGETDW(state->dwDTERate), state->bCharFormat,
		state->bParityType, state->bDataBits));

	if (memcmp(state, &sc->sc_line_state, UCDC_LINE_STATE_LENGTH) == 0) {
		DPRINTF(("uplcom_set_line_coding: already set\n"));
		return (USBD_NORMAL_COMPLETION);
	}

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_LINE_CODING;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, UCDC_LINE_STATE_LENGTH);

	err = usbd_do_request(sc->sc_udev, &req, state);
	if (err) {
		DPRINTF(("uplcom_set_line_coding: failed, err=%s\n",
			usbd_errstr(err)));
		return (err);
	}

	sc->sc_line_state = *state;

	return (USBD_NORMAL_COMPLETION);
}

int
uplcom_param(void *addr, int portno, struct termios *t)
{
	struct uplcom_softc *sc = addr;
	usbd_status err;
	struct usb_cdc_line_state ls;

	DPRINTF(("uplcom_param: sc=%p\n", sc));

	USETDW(ls.dwDTERate, t->c_ospeed);
	if (ISSET(t->c_cflag, CSTOPB))
		ls.bCharFormat = UCDC_STOP_BIT_2;
	else
		ls.bCharFormat = UCDC_STOP_BIT_1;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			ls.bParityType = UCDC_PARITY_ODD;
		else
			ls.bParityType = UCDC_PARITY_EVEN;
	} else
		ls.bParityType = UCDC_PARITY_NONE;
	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		ls.bDataBits = 5;
		break;
	case CS6:
		ls.bDataBits = 6;
		break;
	case CS7:
		ls.bDataBits = 7;
		break;
	case CS8:
		ls.bDataBits = 8;
		break;
	}

	err = uplcom_set_line_coding(sc, &ls);
	if (err) {
		DPRINTF(("uplcom_param: err=%s\n", usbd_errstr(err)));
		return (EIO);
	}

	if (ISSET(t->c_cflag, CRTSCTS))
		uplcom_set_crtscts(sc);

	if (sc->sc_rts == -1 || sc->sc_dtr == -1)
		uplcom_set_line_state(sc);

	if (err) {
		DPRINTF(("uplcom_param: err=%s\n", usbd_errstr(err)));
		return (EIO);
	}

	return (0);
}

int
uplcom_open(void *addr, int portno)
{
	struct uplcom_softc *sc = addr;
	usb_device_request_t req;
	usbd_status uerr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("uplcom_open: sc=%p\n", sc));

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_intr_iface, sc->sc_intr_number,
			USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc,
			sc->sc_intr_buf, sc->sc_isize,
			uplcom_intr, USBD_DEFAULT_INTERVAL);
		if (err) {
			DPRINTF(("%s: cannot open interrupt pipe (addr %d)\n",
				sc->sc_dev.dv_xname, sc->sc_intr_number));
					return (EIO);
		}
	}

	if (sc->sc_type_hx == 1) {
		/*
		 * Undocumented (vendor unresponsive) - possibly changes
		 * flow control semantics. It is needed for HX variant devices.
		 */
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
		req.bRequest = UPLCOM_SET_REQUEST;
		USETW(req.wValue, 2);
		USETW(req.wIndex, 0x44);
		USETW(req.wLength, 0);

		uerr = usbd_do_request(sc->sc_udev, &req, 0);
		if (uerr)
			return (EIO);

		/* Reset upstream data pipes */
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
		req.bRequest = UPLCOM_SET_REQUEST;
		USETW(req.wValue, 8);
		USETW(req.wIndex, 0);
		USETW(req.wLength, 0);

		uerr = usbd_do_request(sc->sc_udev, &req, 0);
		if (uerr)
			return (EIO);

		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
		req.bRequest = UPLCOM_SET_REQUEST;
		USETW(req.wValue, 9);
		USETW(req.wIndex, 0);
		USETW(req.wLength, 0);

		uerr = usbd_do_request(sc->sc_udev, &req, 0);
		if (uerr)
			return (EIO);
	}

	return (0);
}

void
uplcom_close(void *addr, int portno)
{
	struct uplcom_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(("uplcom_close: close\n"));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}
}

void
uplcom_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct uplcom_softc *sc = priv;
	u_char *buf = sc->sc_intr_buf;
	u_char pstatus;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: abnormal status: %s\n", sc->sc_dev.dv_xname,
			usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	DPRINTF(("%s: uplcom status = %02x\n", sc->sc_dev.dv_xname, buf[8]));

	sc->sc_lsr = sc->sc_msr = 0;
	pstatus = buf[8];
	if (ISSET(pstatus, RSAQ_STATUS_CTS))
		sc->sc_msr |= UMSR_CTS;
	else
		sc->sc_msr &= ~UMSR_CTS;
	if (ISSET(pstatus, RSAQ_STATUS_DSR))
		sc->sc_msr |= UMSR_DSR;
	else
		sc->sc_msr &= ~UMSR_DSR;
	if (ISSET(pstatus, RSAQ_STATUS_DCD))
		sc->sc_msr |= UMSR_DCD;
	else
		sc->sc_msr &= ~UMSR_DCD;
	ucom_status_change((struct ucom_softc *) sc->sc_subdev);
}

void
uplcom_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct uplcom_softc *sc = addr;

	DPRINTF(("uplcom_get_status:\n"));

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}
@


1.68
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.67 2016/05/24 05:35:01 mpi Exp $	*/
d219 1
a219 1
        sc->sc_udev = dev;
d311 1
a311 1
 	 * -----------------+-----------------
d402 6
a407 6
        if (sc->sc_intr_pipe != NULL) {
                usbd_abort_pipe(sc->sc_intr_pipe);
                usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, 0);
                sc->sc_intr_pipe = NULL;
        }
d420 1
a420 1
        usb_device_request_t req;
d423 5
a427 5
        req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
        req.bRequest = UPLCOM_SET_REQUEST;
        USETW(req.wValue, 0);
        USETW(req.wIndex, sc->sc_iface_number);
        USETW(req.wLength, 0);
d429 1
a429 1
        err = usbd_do_request(sc->sc_udev, &req, 0);
d722 1
a722 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
@


1.67
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.66 2015/03/14 03:38:50 jsg Exp $	*/
a68 1
#define	UPLCOM_CONFIG_INDEX	0
d197 1
a197 1
	if (uaa->iface != NULL)
a226 9

	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UPLCOM_CONFIG_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}
@


1.66
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.65 2014/11/18 23:55:01 krw Exp $	*/
a121 3
#if TODO
int  uplcom_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
#endif
d130 1
a130 1
	NULL, /* uplcom_ioctl, TODO */
a787 31

#if TODO
int
uplcom_ioctl(void *addr, int portno, u_long cmd, caddr_t data, int flag,
	     struct proc *p)
{
	struct uplcom_softc *sc = addr;
	int error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("uplcom_ioctl: cmd=0x%08lx\n", cmd));

	switch (cmd) {
	case TIOCNOTTY:
	case TIOCMGET:
	case TIOCMSET:
	case USB_GET_CM_OVER_DATA:
	case USB_SET_CM_OVER_DATA:
		break;

	default:
		DPRINTF(("uplcom_ioctl: unknown\n"));
		error = ENOTTY;
		break;
	}

	return (error);
}
#endif
@


1.65
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.64 2014/07/12 21:24:33 mpi Exp $	*/
a57 1
#include <dev/usb/usb_quirks.h>
@


1.64
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.63 2014/07/12 18:48:52 tedu Exp $	*/
a59 1
#include <dev/usb/usbdevs.h>
@


1.63
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.62 2013/11/15 10:17:39 pirofti Exp $	*/
d186 10
a195 15
int uplcom_match(struct device *, void *, void *); 
void uplcom_attach(struct device *, struct device *, void *); 
int uplcom_detach(struct device *, int); 
int uplcom_activate(struct device *, int); 

struct cfdriver uplcom_cd = { 
	NULL, "uplcom", DV_DULL 
}; 

const struct cfattach uplcom_ca = { 
	sizeof(struct uplcom_softc), 
	uplcom_match, 
	uplcom_attach, 
	uplcom_detach, 
	uplcom_activate, 
a429 13
}

int
uplcom_activate(struct device *self, int act)
{
	struct uplcom_softc *sc = (struct uplcom_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.62
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.61 2013/11/15 08:25:31 pirofti Exp $	*/
d425 1
a425 1
		free(sc->sc_intr_buf, M_USBDEV);
d755 1
a755 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.61
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.60 2013/11/06 16:59:02 pirofti Exp $	*/
d750 1
a750 4
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.60
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Tested and okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.59 2013/04/15 09:23:02 mglocker Exp $	*/
a440 1
	int rv = 0;
a443 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d447 1
a447 1
	return (rv);
@


1.59
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.58 2013/03/28 03:58:03 tedu Exp $	*/
a99 2
	u_char			 sc_dying;	/* disconnecting */

d244 1
a244 1
		sc->sc_dying = 1;
d254 1
a254 1
		sc->sc_dying = 1;
d263 1
a263 1
		sc->sc_dying = 1;
d292 1
a292 1
		sc->sc_dying = 1;
d306 1
a306 1
			sc->sc_dying = 1;
d320 1
a320 1
		sc->sc_dying = 1;
d344 2
a345 2
							devname, usbd_errstr(err));
			sc->sc_dying = 1;
d360 1
a360 1
			sc->sc_dying = 1;
d376 1
a376 1
		sc->sc_dying = 1;
d383 1
a383 1
		sc->sc_dying = 1;
d405 1
a405 1
		sc->sc_dying = 1;
d447 1
a447 1
		sc->sc_dying = 1;
d683 1
a683 1
	if (sc->sc_dying)
d747 1
a747 1
	if (sc->sc_dying)
d773 1
a773 1
	if (sc->sc_dying)
d826 1
a826 1
	if (sc->sc_dying)
@


1.58
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.57 2013/03/28 03:31:55 tedu Exp $	*/
d84 2
a85 2
	usbd_device_handle	 sc_udev;	/* USB device */
	usbd_interface_handle	 sc_iface;	/* interface */
d88 1
a88 1
	usbd_interface_handle	 sc_intr_iface;	/* interrupt interface */
d90 1
a90 1
	usbd_pipe_handle	 sc_intr_pipe;	/* interrupt pipe */
d94 1
a94 1
	usb_cdc_line_state_t	 sc_line_state;	/* current line state */
d116 1
a116 1
					   usb_cdc_line_state_t *state);
d118 1
a118 1
void uplcom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d222 1
a222 1
	usbd_device_handle dev = uaa->device;
d588 2
a589 1
uplcom_set_line_coding(struct uplcom_softc *sc, usb_cdc_line_state_t *state)
d626 1
a626 1
	usb_cdc_line_state_t ls;
d769 1
a769 1
uplcom_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.57
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.56 2011/07/03 15:47:17 matthew Exp $	*/
a48 1
#include <sys/proc.h>
@


1.56
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.55 2011/01/25 20:03:36 jakemsr Exp $	*/
a49 1
#include <sys/vnode.h>
@


1.55
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.54 2010/11/16 22:28:55 deraadt Exp $	*/
a447 3
	case DVACT_ACTIVATE:
		break;

@


1.54
log
@BenQ M32 GSM/GPRS modem uses a custom product ID prolific PL2303; Mark Peoples
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.53 2010/09/24 08:33:59 yuo Exp $	*/
a412 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a436 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.53
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.52 2009/10/13 19:33:19 pirofti Exp $	*/
d167 1
@


1.52
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.51 2008/06/26 05:42:19 ray Exp $	*/
a434 1
	sc->sc_dying = 1;
@


1.51
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.50 2008/03/03 20:58:43 jsg Exp $	*/
d192 1
a192 1
int uplcom_activate(struct device *, enum devact); 
d448 1
a448 1
uplcom_activate(struct device *self, enum devact act)
@


1.50
log
@Palm 700WX from and tested by todd@@
discussed with deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.49 2008/02/22 10:46:57 jsg Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.49
log
@I-O Data USB-RSAQ5 serial from Masao Uebayashi in NetBSD.
Corega CG-WLUSB2GL WLAN from KIYOHARA Takashi in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.48 2008/01/22 17:53:05 okan Exp $	*/
d164 1
@


1.48
log
@add Y.C. Cable USB-Serial adapter

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.47 2007/10/11 18:33:15 deraadt Exp $	*/
d162 1
@


1.47
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.46 2007/09/14 14:37:40 deraadt Exp $	*/
d189 2
a190 1
	{ USB_VENDOR_SMART, USB_PRODUCT_SMART_PL2303 }
@


1.46
log
@correct type printing
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.45 2007/09/13 02:02:20 deraadt Exp $	*/
a231 2

	char *devinfop;
a236 4
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);

d249 1
a249 1
		printf("\n%s: failed to set configuration, err=%s\n",
@


1.45
log
@adapt to new hx/non-hx type-selection algorithm from linux/dragonfly; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.44 2007/09/12 18:06:11 deraadt Exp $	*/
d293 1
a293 1
	if (sc->sc_type_hx == TYPE_PL2303X) {
@


1.44
log
@new product
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.43 2007/06/14 10:11:16 mbalmer Exp $	*/
d284 3
a286 2
	if (ddesc->bMaxPacketSize == 0x40) {
		DPRINTF(("%s: Assuming HX variant\n", sc->sc_dev.dv_xname));
d288 1
a288 1
	} else
d291 8
@


1.43
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.42 2007/06/13 06:25:03 mbalmer Exp $	*/
d188 2
a189 1
	{ USB_VENDOR_TRIPPLITE, USB_PRODUCT_TRIPPLITE_U209 }
@


1.42
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.41 2007/06/12 16:26:37 mbalmer Exp $	*/
d192 16
a207 1
USB_DECLARE_DRIVER(uplcom);
@


1.41
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.40 2007/06/11 16:30:31 mbalmer Exp $	*/
d92 8
a99 8
	struct device		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;	/* USB device */
	usbd_interface_handle	sc_iface;	/* interface */
	int			sc_iface_number;	/* interface number */

	usbd_interface_handle	sc_intr_iface;	/* interrupt interface */
	int			sc_intr_number;	/* interrupt number */
	usbd_pipe_handle	sc_intr_pipe;	/* interrupt pipe */
d101 1
a101 1
	int			sc_isize;
d103 3
a105 3
	usb_cdc_line_state_t	sc_line_state;	/* current line state */
	int			sc_dtr;		/* current DTR state */
	int			sc_rts;		/* current RTS state */
d107 1
a107 1
	struct device *		sc_subdev;	/* ucom device */
d109 1
a109 1
	u_char			sc_dying;	/* disconnecting */
d111 3
a113 3
	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* uplcom status register */
	int			sc_type_hx;	/* HX variant */
@


1.40
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.39 2007/06/10 14:49:01 mbalmer Exp $	*/
d107 1
a107 1
	device_ptr_t		sc_subdev;	/* ucom device */
d433 1
a433 1
uplcom_activate(device_ptr_t self, enum devact act)
@


1.39
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.38 2007/06/10 10:53:48 mbalmer Exp $	*/
d136 1
a136 1
int  uplcom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d818 1
a818 1
	     usb_proc_ptr p)
@


1.38
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.37 2007/06/06 19:25:49 mk Exp $	*/
d218 1
a218 1
	char *devname = USBDEVNAME(sc->sc_dev);
d250 1
a250 1
			USBDEVNAME(sc->sc_dev));
d259 1
a259 1
		    USBDEVNAME(sc->sc_dev));
d269 1
a269 1
		DPRINTF(("%s: Assuming HX variant\n", USBDEVNAME(sc->sc_dev)));
d293 1
a293 1
				USBDEVNAME(sc->sc_dev), i);
d307 1
a307 1
			USBDEVNAME(sc->sc_dev));
d347 1
a347 1
				USBDEVNAME(sc->sc_dev), i);
d363 1
a363 1
			USBDEVNAME(sc->sc_dev));
d370 1
a370 1
			USBDEVNAME(sc->sc_dev));
d391 1
a391 1
		printf("%s: reset failed, %s\n", USBDEVNAME(sc->sc_dev),
d693 1
a693 1
				USBDEVNAME(sc->sc_dev), sc->sc_intr_number));
d753 1
a753 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d757 1
a757 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d777 1
a777 1
		DPRINTF(("%s: abnormal status: %s\n", USBDEVNAME(sc->sc_dev),
d783 1
a783 1
	DPRINTF(("%s: uplcom status = %02x\n", USBDEVNAME(sc->sc_dev), buf[8]));
@


1.37
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.36 2007/06/05 08:43:56 mbalmer Exp $	*/
d398 1
a398 1
			   USBDEV(sc->sc_dev));
d427 1
a427 1
			   USBDEV(sc->sc_dev));
@


1.36
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.35 2007/05/27 04:00:25 jsg Exp $	*/
d92 1
a92 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.35
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.34 2007/05/21 05:40:28 jsg Exp $	*/
d123 2
a124 2
Static	usbd_status uplcom_reset(struct uplcom_softc *);
Static	usbd_status uplcom_set_line_coding(struct uplcom_softc *sc,
d126 2
a127 2
Static	usbd_status uplcom_set_crtscts(struct uplcom_softc *);
Static	void uplcom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d129 6
a134 6
Static	void uplcom_set(void *, int, int, int);
Static	void uplcom_dtr(struct uplcom_softc *, int);
Static	void uplcom_rts(struct uplcom_softc *, int);
Static	void uplcom_break(struct uplcom_softc *, int);
Static	void uplcom_set_line_state(struct uplcom_softc *);
Static	void uplcom_get_status(void *, int portno, u_char *lsr, u_char *msr);
d136 1
a136 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d138 3
a140 3
Static	int  uplcom_param(void *, int, struct termios *);
Static	int  uplcom_open(void *, int);
Static	void uplcom_close(void *, int);
@


1.34
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.33 2007/04/23 15:40:38 jsg Exp $	*/
d194 2
a195 1
USB_MATCH(uplcom)
d197 1
a197 1
	USB_MATCH_START(uplcom, uaa);
d206 2
a207 1
USB_ATTACH(uplcom)
d209 2
a210 1
	USB_ATTACH_START(uplcom, sc, uaa);
d224 1
a224 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d242 1
a242 1
		USB_ATTACH_ERROR_RETURN;
d252 1
a252 1
		USB_ATTACH_ERROR_RETURN;
d261 1
a261 1
		USB_ATTACH_ERROR_RETURN;
d281 1
a281 1
		USB_ATTACH_ERROR_RETURN;
d295 1
a295 1
			USB_ATTACH_ERROR_RETURN;
d309 1
a309 1
		USB_ATTACH_ERROR_RETURN;
d334 1
a334 1
			USB_ATTACH_ERROR_RETURN;
d349 1
a349 1
			USB_ATTACH_ERROR_RETURN;
d365 1
a365 1
		USB_ATTACH_ERROR_RETURN;
d372 1
a372 1
		USB_ATTACH_ERROR_RETURN;
d394 1
a394 1
		USB_ATTACH_ERROR_RETURN;
a402 2

	USB_ATTACH_SUCCESS_RETURN;
d405 2
a406 1
USB_DETACH(uplcom)
d408 1
a408 1
	USB_DETACH_START(uplcom, sc);
@


1.33
log
@Add an unbranded device I have, chip says its a PL-2303HX.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.32 2006/08/04 06:49:13 brad Exp $	*/
d73 1
a73 1
#define DPRINTFN(n, x)  do { if (uplcomdebug > (n)) logprintf x; } while (0)
@


1.32
log
@add the Belkin serial adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.31 2006/07/01 04:23:31 jsg Exp $	*/
d172 1
@


1.31
log
@Remove comments in device list that duplicate man page,
sort device list while here.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.30 2006/06/23 06:27:12 miod Exp $	*/
d157 1
@


1.30
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.29 2006/04/15 04:37:52 jsg Exp $	*/
d154 2
a155 5
	/* I/O DATA USB-RSAQ2 */
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_RSAQ2 },
	/* I/O DATA USB-RSAQ */
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBRSAQ },
	/* PLANEX USB-RS232 URS-03 */
a156 5
	/* IOGEAR/ATEN UC-232A */
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303 },
	/* IOGEAR/ATENTRIPPLITE U209 */
	{ USB_VENDOR_TRIPPLITE, USB_PRODUCT_TRIPPLITE_U209 },
	/* ELECOM UC-SGT */
a158 21
	/* Panasonic 50" Touch Panel */
	{ USB_VENDOR_PANASONIC, USB_PRODUCT_PANASONIC_TYTP50P6S },
	/* RATOC REX-USB60 */
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60 },
	/* TDK USB-PHS Adapter UHA6400 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UHA6400 },
	/* TDK USB-PDC Adapter UPA9664 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UPA9664 },
	/* Ericsson DCU-10 & DCU-11, made by Susteen, Inc. */
	{ USB_VENDOR_SUSTEEN, USB_PRODUCT_SUSTEEN_DCU11 },
	/* Sitecom USB to Serial. */
	{ USB_VENDOR_SITECOM, USB_PRODUCT_SITECOM_CN104 },
	/* Pharos USB GPS - Microsoft version */
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303X },
	/* IODATA USB-RSAQ3 */
	{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2303X2 },
	/* SOURCENEXT KeikaiDenwa 8 */
	{ USB_VENDOR_SOURCENEXT, USB_PRODUCT_SOURCENEXT_KEIKAI8 },
	/* SOURCENEXT KeikaiDenwa 8 with charger */
	{ USB_VENDOR_SOURCENEXT, USB_PRODUCT_SOURCENEXT_KEIKAI8_CHG },
	/* HAL Corporation Crossam2+USB */
d160 1
a160 2
	{ USB_VENDOR_ALCATEL, USB_PRODUCT_ALCATEL_OT535 },
	{ USB_VENDOR_ANCHOR, USB_PRODUCT_ANCHOR_SERIAL },
d166 5
d172 1
d178 3
d182 5
a186 1
	{ USB_VENDOR_SYNTECH, USB_PRODUCT_SYNTECH_SERIAL }
@


1.29
log
@Add a bunch more uplcom devices found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.28 2006/02/16 10:37:51 jsg Exp $	*/
d454 1
a454 1
		return (EOPNOTSUPP);
@


1.28
log
@AirPrime EVDO does not work with uplcom as suspected.
Noticed by Ben Lovett.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.27 2006/02/11 09:32:48 brad Exp $	*/
d188 16
a203 1
	{ USB_VENDOR_HAL, USB_PRODUCT_HAL_IMR001 }
@


1.27
log
@Back out the "it is not completely clear" part of revision 1.18 - it
effectively swapped RTS and DTR, apparently on all versions of the chip.

From NetBSD

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.26 2006/02/07 23:35:11 brad Exp $	*/
d188 1
a188 3
	{ USB_VENDOR_HAL, USB_PRODUCT_HAL_IMR001 },
	/* AirPrime CDMA Wireless EVDO card */
	{ USB_VENDOR_AIRPRIME, USB_PRODUCT_AIRPRIME_PC5220 },
@


1.26
log
@add Panasonic 50" touch panel

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.25 2005/11/21 18:16:44 millert Exp $	*/
a90 9
#define UPLCOM_FLOW_OUT_CTS	0x0001
#define UPLCOM_FLOW_OUT_DSR	0x0002
#define UPLCOM_FLOW_IN_DSR	0x0004
#define UPLCOM_FLOW_IN_DTR	0x0008
#define UPLCOM_FLOW_IN_RTS	0x0010
#define UPLCOM_FLOW_OUT_RTS	0x0020
#define UPLCOM_FLOW_OUT_XON	0x0080
#define UPLCOM_FLOW_IN_XON	0x0100

d483 2
a484 2
	ls = (sc->sc_dtr ? UPLCOM_FLOW_OUT_DSR : 0) |
	    (sc->sc_rts ? UPLCOM_FLOW_OUT_CTS : 0);
@


1.25
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.24 2005/08/01 05:36:49 brad Exp $	*/
d176 2
@


1.24
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.23 2005/07/04 00:37:21 deraadt Exp $	*/
d55 1
a55 1
#include <sys/select.h>
@


1.23
log
@new uplcom; Tomokazu Hirai
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.22 2005/05/23 21:20:14 deraadt Exp $	*/
d223 1
a223 1
	char devinfo[1024];
d229 4
a232 3
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
        USB_ATTACH_SETUP;
        printf("%s: %s\n", devname, devinfo);
@


1.22
log
@suspected airprime pc5220 EVDO support
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.21 2005/01/28 22:35:16 djm Exp $	*/
d188 2
@


1.21
log
@fix merge errors from r1.18; tested hshoexer & henning; ok henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.20 2005/01/16 06:18:12 dlg Exp $	*/
d194 2
@


1.20
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.19 2005/01/16 05:56:55 dlg Exp $	*/
d527 1
a527 1
	sc->sc_dtr = !onoff;
d537 1
a537 1
	if (sc->sc_rts == -1 && !sc->sc_dtr == !onoff)
d540 1
a540 1
	sc->sc_rts = !onoff;
@


1.19
log
@add support for the HX variant of the pl2303 from Pedro la Peu via
Waldemar Brodkorb.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.18 2005/01/10 12:05:08 dlg Exp $	*/
d270 1
a270 1
	if (ddesc->bMaxPacketSize = 0x40) {
@


1.18
log
@from netbsd uplcom.c revision 1.37:
Make sure that we call uplcom_set_line_state() to get consistent state
between our idea of flow controll settings and the chips one.
In uplcom_set_line_state use the same value as the manufacturer suggests,
since the previously used (umodem based) values do not seem to work.
It is not completely clear what happened here - either the "not calling
uplcom_set_line_state" due to luck prevented the non working state to
be discovered or there are variants of the chip that need the old values.
During testing none such chips have been found - if they ever apear we
might have to make this function more intelligent, depending on the chip
in use.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.17 2005/01/10 11:58:52 dlg Exp $	*/
d86 1
d122 1
d215 1
d257 19
d572 2
a573 1
	USETW(req.wIndex, UPLCOM_SET_CRTSCTS);
d679 2
d699 37
@


1.17
log
@from freebsd, uplcom.c revision 1.23:
Add support for CTS modemsignal as well.
RI does not seem to be supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.16 2004/10/26 00:37:07 jsg Exp $	*/
d90 9
d112 2
a113 3
	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */
	u_char			sc_status;
d457 9
a465 2
	ls = (sc->sc_dtr ? UCDC_LINE_DTR : 0) |
		(sc->sc_rts ? UCDC_LINE_RTS : 0);
d502 1
a502 1
	if (sc->sc_dtr == onoff)
d504 2
a505 1
	sc->sc_dtr = onoff;
d515 1
a515 1
	if (sc->sc_rts == onoff)
d517 2
a518 1
	sc->sc_rts = onoff;
d641 3
a663 1
		sc->sc_status = 0; /* clear status bit */
@


1.16
log
@Add Pharos GPS. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.15 2004/09/20 21:34:46 deraadt Exp $	*/
d86 1
d709 4
d715 2
d719 2
@


1.15
log
@more uplcom and umct; jsg@@goblin.cx pulled from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.14 2004/09/20 06:01:04 deraadt Exp $	*/
d175 2
@


1.14
log
@another unit; http://www2.elecom.co.jp/products/UC-SGT.html
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.13 2004/07/08 22:18:44 deraadt Exp $	*/
d160 2
d175 6
@


1.13
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.12 2004/05/26 22:25:54 markus Exp $	*/
d162 1
@


1.12
log
@add Sitecom usb-serial (CN104)
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.11 2003/11/07 20:22:35 jmc Exp $	*/
d73 1
a73 1
#define DPRINTFN(n, x)  if (uplcomdebug > (n)) logprintf x
@


1.11
log
@more updated URLs from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.10 2003/07/19 08:06:17 cedric Exp $	*/
d170 2
@


1.10
log
@Ericsson DCU-10 & DCU-11 is a simple USB->Serial device.
ok+thanks todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.9 2003/05/07 04:33:33 deraadt Exp $	*/
d41 2
a42 2
 * http://www.prolific.com.tw/download/DataSheet/pl2303_ds11.PDF
 * http://www.nisseisg.co.jp/jyouhou/_cp/@@gif/2303.pdf
@


1.9
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.8 2002/11/11 02:32:32 nate Exp $	*/
d168 2
@


1.8
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.7 2002/07/25 04:07:33 nate Exp $	*/
d198 1
a198 1
        usbd_devinfo(dev, 0, devinfo);
@


1.7
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: uplcom.c,v 1.6 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: uplcom.c,v 1.28 2002/07/11 21:14:33 augustss Exp $ */
a397 1
		break;
@


1.6
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uplcom.c,v 1.5 2002/07/10 03:02:50 nate Exp $	*/
/*	$NetBSD: uplcom.c,v 1.27 2002/03/16 16:10:19 ichiro Exp $	*/
@


1.5
log
@New device support
use table lookup
use usb_proc_ptr

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.4 2002/05/07 18:29:18 nate Exp $	*/
d191 1
a191 1
	
d206 1
a206 1
	/* initialize endpoints */ 
d231 1
a231 1
	err = usbd_device2interface_handle(dev, UPLCOM_IFACE_INDEX, 
d258 1
a258 1
		} 
d280 1
a280 1
	 *   BulkIN(0x02)   | 
d284 1
a284 1
		err = usbd_device2interface_handle(dev, 
d292 1
a292 1
	} 
d419 3
a421 3
        USETW(req.wLength, 0); 
 
        err = usbd_do_request(sc->sc_udev, &req, 0); 
d622 1
a622 1
	
d646 1
a646 1
uplcom_close(void *addr, int portno) 
@


1.4
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: uplcom.c,v 1.2 2001/10/31 04:24:44 nate Exp $	*/
/*	$NetBSD: uplcom.c,v 1.20 2001/07/31 12:33:11 ichiro Exp $	*/
d134 1
a134 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
d151 1
a151 4
static const struct uplcom_product {
	uint16_t	vendor;
	uint16_t	product;
} uplcom_products [] = {
d160 8
a167 1
	{ 0, 0 }
d169 1
a175 1
	int i;
d180 2
a181 7
	for (i = 0; uplcom_products[i].vendor != 0; i++) {
		if (uplcom_products[i].vendor == uaa->vendor &&
 		    uplcom_products[i].product == uaa->product) {
			return (UMATCH_VENDOR_PRODUCT);
		}
	}
	return (UMATCH_NONE);
d717 1
a717 1
	     struct proc *p)
@


1.3
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uplcom.c,v 1.27 2002/03/16 16:10:19 ichiro Exp $	*/
d134 1
a134 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d151 4
a154 1
static const struct usb_devno uplcom_devs[] = {
d163 1
a163 8
	/* ELECOM UC-SGT */
	{ USB_VENDOR_ELECOM, USB_PRODUCT_ELECOM_UCSGT },
	/* RATOC REX-USB60 */
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60 },
	/* TDK USB-PHS Adapter UHA6400 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UHA6400 },
	/* TDK USB-PDC Adapter UPA9664 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UPA9664 },
a164 1
#define uplcom_lookup(v, p) usb_lookup(uplcom_devs, v, p)
d171 1
d176 7
a182 2
	return (uplcom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d718 1
a718 1
	     usb_proc_ptr p)
@


1.2
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uplcom.c,v 1.1 2001/10/02 01:37:36 millert Exp $	*/
/*	$NetBSD: uplcom.c,v 1.20 2001/07/31 12:33:11 ichiro Exp $	*/
d134 1
a134 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
d151 1
a151 4
static const struct uplcom_product {
	uint16_t	vendor;
	uint16_t	product;
} uplcom_products [] = {
d160 8
a167 1
	{ 0, 0 }
d169 1
a175 1
	int i;
d180 2
a181 7
	for (i = 0; uplcom_products[i].vendor != 0; i++) {
		if (uplcom_products[i].vendor == uaa->vendor &&
 		    uplcom_products[i].product == uaa->product) {
			return (UMATCH_VENDOR_PRODUCT);
		}
	}
	return (UMATCH_NONE);
d717 1
a717 1
	     struct proc *p)
@


1.2.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.2 2001/10/31 04:24:44 nate Exp $	*/
@


1.2.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uplcom.c,v 1.28 2002/07/11 21:14:33 augustss Exp $ */
d134 1
a134 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d151 4
a154 1
static const struct usb_devno uplcom_devs[] = {
d163 1
a163 8
	/* ELECOM UC-SGT */
	{ USB_VENDOR_ELECOM, USB_PRODUCT_ELECOM_UCSGT },
	/* RATOC REX-USB60 */
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60 },
	/* TDK USB-PHS Adapter UHA6400 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UHA6400 },
	/* TDK USB-PDC Adapter UPA9664 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UPA9664 },
a164 1
#define uplcom_lookup(v, p) usb_lookup(uplcom_devs, v, p)
d171 1
d176 7
a182 2
	return (uplcom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d192 1
a192 1

d207 1
a207 1
	/* initialize endpoints */
d232 1
a232 1
	err = usbd_device2interface_handle(dev, UPLCOM_IFACE_INDEX,
d259 1
a259 1
		}
d281 1
a281 1
	 *   BulkIN(0x02)   |
d285 1
a285 1
		err = usbd_device2interface_handle(dev,
d293 1
a293 1
	}
d420 3
a422 3
        USETW(req.wLength, 0);

        err = usbd_do_request(sc->sc_udev, &req, 0);
d623 1
a623 1

d647 1
a647 1
uplcom_close(void *addr, int portno)
d718 1
a718 1
	     usb_proc_ptr p)
@


1.2.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uplcom.c,v 1.29 2002/09/23 05:51:23 simonb Exp $	*/
d198 1
a198 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d398 1
@


1.1
log
@Add support for I/O DATA USB-RSAQ2 serial adapter; ichiro@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a2 1

@


1.1.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@@


1.1.4.2
log
@Merge in -current
@
text
@d3 1
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: uplcom.c,v 1.29 2002/09/23 05:51:23 simonb Exp $	*/
d134 1
a134 1
Static	int  uplcom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d151 4
a154 1
static const struct usb_devno uplcom_devs[] = {
d163 1
a163 8
	/* ELECOM UC-SGT */
	{ USB_VENDOR_ELECOM, USB_PRODUCT_ELECOM_UCSGT },
	/* RATOC REX-USB60 */
	{ USB_VENDOR_RATOC, USB_PRODUCT_RATOC_REXUSB60 },
	/* TDK USB-PHS Adapter UHA6400 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UHA6400 },
	/* TDK USB-PDC Adapter UPA9664 */
	{ USB_VENDOR_TDK, USB_PRODUCT_TDK_UPA9664 },
a164 1
#define uplcom_lookup(v, p) usb_lookup(uplcom_devs, v, p)
d171 1
d176 7
a182 2
	return (uplcom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d192 1
a192 1

d207 1
a207 1
	/* initialize endpoints */
d232 1
a232 1
	err = usbd_device2interface_handle(dev, UPLCOM_IFACE_INDEX,
d259 1
a259 1
		}
d281 1
a281 1
	 *   BulkIN(0x02)   |
d285 1
a285 1
		err = usbd_device2interface_handle(dev,
d293 1
a293 1
	}
d399 1
d420 3
a422 3
        USETW(req.wLength, 0);

        err = usbd_do_request(sc->sc_udev, &req, 0);
d623 1
a623 1

d647 1
a647 1
uplcom_close(void *addr, int portno)
d718 1
a718 1
	     usb_proc_ptr p)
@


1.1.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uplcom.c,v 1.1.4.3 2003/03/28 00:38:32 niklas Exp $	*/
d198 1
a198 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 2
a42 2
 * http://www.prolific.com.tw/PDF/PL-2303%20Market%20Spec.pdf
 * http://www.hitachi-hitec.com/jyouhou/prolific/2303.pdf
a167 2
	/* Ericsson DCU-10 & DCU-11, made by Susteen, Inc. */
	{ USB_VENDOR_SUSTEEN, USB_PRODUCT_SUSTEEN_DCU11 },
@


1.1.4.6
log
@Merge with the trunk
@
text
@a169 2
	/* Sitecom USB to Serial. */
	{ USB_VENDOR_SITECOM, USB_PRODUCT_SITECOM_CN104 },
@


