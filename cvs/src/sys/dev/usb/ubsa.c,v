head	1.65;
access;
symbols
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.64.0.10
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.8
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	UBC:1.3.0.2
	UBC_SYNC_A:1.2
	SMP:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.65
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	6s3MfY9d6ZKdL2Uz;

1.64
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.63;
commitid	p4LJxGKbi0BU2cG6;

1.63
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.62;
commitid	PSjXNz8dGohZ6ZSK;

1.62
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.61;
commitid	OBNa5kfxQ2UXoiIw;

1.61
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.07.07.32.36;	author pirofti;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.05.23.20.21;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.22.19.47.30;	author mk;	state Exp;
branches;
next	1.48;

1.48
date	2010.02.22.23.35.10;	author mpf;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.02.12.32.08;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.24.13.23.03;	author yuo;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.18.17.15.21;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.11.10.46.33;	author fkr;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.04.00.23.00;	author fkr;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.23.14.32.34;	author fkr;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.21.21.10.03;	author fkr;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.08.17.17.15;	author yuo;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.03.15.10.02;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.03.15.07.31;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.20.14.24.49;	author yuo;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.02.15.12.18;	author yuo;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.02.08.54.08;	author fkr;	state Exp;
branches;
next	1.32;

1.32
date	2008.02.26.18.32.06;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.01.06.12.20;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.27.11.02.34;	author fkr;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.21.05.41.57;	author fkr;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.07.21.25.37;	author fkr;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.07.18.16.10;	author fkr;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.07.16.22.44;	author fkr;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.11.09.33.45;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.29.23.35.20;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.18.00.33.28;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.16.04.53.00;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.12.11.15.10;	author moritz;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.03.23.15.50;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.03.20.33.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.11.15.14.56;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.19.00.29.34;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.30.19.29.29;	author nate;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.65
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: ubsa.c,v 1.64 2015/03/14 03:38:49 jsg Exp $ 	*/
/*	$NetBSD: ubsa.c,v 1.5 2002/11/25 00:51:33 fvdl Exp $	*/
/*-
 * Copyright (c) 2002, Alexander Kabaev <kan.FreeBSD.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ichiro FUKUHARA (ichiro@@ichiro.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioccom.h>
#include <sys/fcntl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#ifdef UBSA_DEBUG
int	ubsadebug = 0;

#define	DPRINTFN(n, x)	do { if (ubsadebug > (n)) printf x; } while (0)
#else
#define	DPRINTFN(n, x)
#endif
#define	DPRINTF(x) DPRINTFN(0, x)

#define	UBSA_MODVER		1	/* module version */

#define	UBSA_CONFIG_INDEX	1
#define	UBSA_IFACE_INDEX	0

#define	UBSA_INTR_INTERVAL	100	/* ms */

#define	UBSA_SET_BAUDRATE  	0x00
#define	UBSA_SET_STOP_BITS	0x01
#define	UBSA_SET_DATA_BITS	0x02
#define	UBSA_SET_PARITY		0x03
#define	UBSA_SET_DTR		0x0A
#define	UBSA_SET_RTS		0x0B
#define	UBSA_SET_BREAK		0x0C
#define	UBSA_SET_FLOW_CTRL	0x10

#define	UBSA_PARITY_NONE	0x00
#define	UBSA_PARITY_EVEN	0x01
#define	UBSA_PARITY_ODD		0x02
#define	UBSA_PARITY_MARK	0x03
#define	UBSA_PARITY_SPACE	0x04

#define	UBSA_FLOW_NONE		0x0000
#define	UBSA_FLOW_OCTS		0x0001
#define	UBSA_FLOW_ODSR		0x0002
#define	UBSA_FLOW_IDSR		0x0004
#define	UBSA_FLOW_IDTR		0x0008
#define	UBSA_FLOW_IRTS		0x0010
#define	UBSA_FLOW_ORTS		0x0020
#define	UBSA_FLOW_UNKNOWN	0x0040
#define	UBSA_FLOW_OXON		0x0080
#define	UBSA_FLOW_IXON		0x0100

/* line status register */
#define	UBSA_LSR_TSRE		0x40	/* Transmitter empty: byte sent */
#define	UBSA_LSR_TXRDY		0x20	/* Transmitter buffer empty */
#define	UBSA_LSR_BI		0x10	/* Break detected */
#define	UBSA_LSR_FE		0x08	/* Framing error: bad stop bit */
#define	UBSA_LSR_PE		0x04	/* Parity error */
#define	UBSA_LSR_OE		0x02	/* Overrun, lost incoming byte */
#define	UBSA_LSR_RXRDY		0x01	/* Byte ready in Receive Buffer */
#define	UBSA_LSR_RCV_MASK	0x1f	/* Mask for incoming data or error */

/* modem status register */
/* All deltas are from the last read of the MSR. */
#define	UBSA_MSR_DCD		0x80	/* Current Data Carrier Detect */
#define	UBSA_MSR_RI		0x40	/* Current Ring Indicator */
#define	UBSA_MSR_DSR		0x20	/* Current Data Set Ready */
#define	UBSA_MSR_CTS		0x10	/* Current Clear to Send */
#define	UBSA_MSR_DDCD		0x08	/* DCD has changed state */
#define	UBSA_MSR_TERI		0x04	/* RI has toggled low to high */
#define	UBSA_MSR_DDSR		0x02	/* DSR has changed state */
#define	UBSA_MSR_DCTS		0x01	/* CTS has changed state */

struct	ubsa_softc {
	struct device		 sc_dev;	/* base device */
	struct usbd_device	*sc_udev;	/* USB device */
	struct usbd_interface	*sc_iface;	/* interface */

	int			 sc_iface_number;	/* interface number */

	int			 sc_intr_number;	/* interrupt number */
	struct usbd_pipe	*sc_intr_pipe;	/* interrupt pipe */
	u_char			*sc_intr_buf;	/* interrupt buffer */
	int			 sc_isize;

	u_char			 sc_dtr;	/* current DTR state */
	u_char			 sc_rts;	/* current RTS state */

	u_char			 sc_lsr;	/* Local status register */
	u_char			 sc_msr;	/* ubsa status register */

	struct device		*sc_subdev;	/* ucom device */

};

void ubsa_intr(struct usbd_xfer *, void *, usbd_status);

void ubsa_get_status(void *, int, u_char *, u_char *);
void ubsa_set(void *, int, int, int);
int  ubsa_param(void *, int, struct termios *);
int  ubsa_open(void *, int);
void ubsa_close(void *, int);

void ubsa_break(struct ubsa_softc *sc, int onoff);
int  ubsa_request(struct ubsa_softc *, u_int8_t, u_int16_t);
void ubsa_dtr(struct ubsa_softc *, int);
void ubsa_rts(struct ubsa_softc *, int);
void ubsa_baudrate(struct ubsa_softc *, speed_t);
void ubsa_parity(struct ubsa_softc *, tcflag_t);
void ubsa_databits(struct ubsa_softc *, tcflag_t);
void ubsa_stopbits(struct ubsa_softc *, tcflag_t);
void ubsa_flow(struct ubsa_softc *, tcflag_t, tcflag_t);

struct	ucom_methods ubsa_methods = {
	ubsa_get_status,
	ubsa_set,
	ubsa_param,
	NULL,
	ubsa_open,
	ubsa_close,
	NULL,
	NULL
};

const struct usb_devno ubsa_devs[] = {
	/* Axesstel MV100H */
	{ USB_VENDOR_AXESSTEL, USB_PRODUCT_AXESSTEL_DATAMODEM },
	/* BELKIN F5U103 */
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U103 },
	/* BELKIN F5U120 */
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U120 },
	/* GoHubs GO-COM232 , Belkin F5U003 */
	{ USB_VENDOR_ETEK, USB_PRODUCT_ETEK_1COM },
	/* GoHubs GO-COM232 */
	{ USB_VENDOR_GOHUBS, USB_PRODUCT_GOHUBS_GOCOM232 },
	/* Peracom */
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_SERIAL1 },
	/* ZTE Inc. CMDMA MSM modem */
	{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_CDMA_MSM },
	/* ZTE Inc. AC8700 */
	{ USB_VENDOR_ZTE, USB_PRODUCT_ZTE_AC8700 },
};

int ubsa_match(struct device *, void *, void *);
void ubsa_attach(struct device *, struct device *, void *);
int ubsa_detach(struct device *, int);

struct cfdriver ubsa_cd = {
	NULL, "ubsa", DV_DULL
};

const struct cfattach ubsa_ca = {
	sizeof(struct ubsa_softc), ubsa_match, ubsa_attach, ubsa_detach
};

int
ubsa_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface != NULL)
		return (UMATCH_NONE);

	return (usb_lookup(ubsa_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
ubsa_attach(struct device *parent, struct device *self, void *aux)
{
	struct ubsa_softc *sc = (struct ubsa_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	const char *devname = sc->sc_dev.dv_xname;
	usbd_status err;
	struct ucom_attach_args uca;
	int i;

	sc->sc_udev = dev;

	/*
	 * initialize rts, dtr variables to something
	 * different from boolean 0, 1
	 */
	sc->sc_dtr = -1;
	sc->sc_rts = -1;

	DPRINTF(("ubsa attach: sc = %p\n", sc));

	/* initialize endpoints */
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;

	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UBSA_CONFIG_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration: %s\n",
		    devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);

	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    devname);
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	/* get the first interface */
	err = usbd_device2interface_handle(dev, UBSA_IFACE_INDEX,
	    &sc->sc_iface);
	if (err) {
		printf("%s: failed to get interface: %s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	/* Find the endpoints */

	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			goto error;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkin = ed->bEndpointAddress;
			uca.ibufsize = UGETW(ed->wMaxPacketSize);
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
			uca.obufsize = UGETW(ed->wMaxPacketSize);
		}
	}

	if (sc->sc_intr_number == -1) {
		printf("%s: Could not find interrupt in\n", devname);
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n", devname);
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n", devname);
		usbd_deactivate(sc->sc_udev);
		goto error;
	}

	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
	uca.ibufsizepad = uca.ibufsize;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = sc->sc_iface;
	uca.methods = &ubsa_methods;
	uca.arg = sc;
	uca.info = NULL;

	DPRINTF(("ubsa: in = 0x%x, out = 0x%x, intr = 0x%x\n",
	    uca.bulkin, uca.bulkout, sc->sc_intr_number));

	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);

error:
	return;
}

int
ubsa_detach(struct device *self, int flags)
{
	struct ubsa_softc *sc = (struct ubsa_softc *)self;
	int rv = 0;


	DPRINTF(("ubsa_detach: sc = %p\n", sc));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

int
ubsa_request(struct ubsa_softc *sc, u_int8_t request, u_int16_t value)
{
	usb_device_request_t req;
	usbd_status err;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = request;
	USETW(req.wValue, value);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, 0);
	if (err && err != USBD_STALLED)
		printf("%s: ubsa_request: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
	return (err);
}

void
ubsa_dtr(struct ubsa_softc *sc, int onoff)
{

	DPRINTF(("ubsa_dtr: onoff = %d\n", onoff));

	if (sc->sc_dtr == onoff)
		return;
	sc->sc_dtr = onoff;

	ubsa_request(sc, UBSA_SET_DTR, onoff ? 1 : 0);
}

void
ubsa_rts(struct ubsa_softc *sc, int onoff)
{

	DPRINTF(("ubsa_rts: onoff = %d\n", onoff));

	if (sc->sc_rts == onoff)
		return;
	sc->sc_rts = onoff;

	ubsa_request(sc, UBSA_SET_RTS, onoff ? 1 : 0);
}

void
ubsa_break(struct ubsa_softc *sc, int onoff)
{

	DPRINTF(("ubsa_rts: onoff = %d\n", onoff));

	ubsa_request(sc, UBSA_SET_BREAK, onoff ? 1 : 0);
}

void
ubsa_set(void *addr, int portno, int reg, int onoff)
{
	struct ubsa_softc *sc;

	sc = addr;
	switch (reg) {
	case UCOM_SET_DTR:
		ubsa_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		ubsa_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		ubsa_break(sc, onoff);
		break;
	default:
		break;
	}
}

void
ubsa_baudrate(struct ubsa_softc *sc, speed_t speed)
{
	u_int16_t value = 0;

	DPRINTF(("ubsa_baudrate: speed = %d\n", speed));

	switch(speed) {
	case B0:
		break;
	case B300:
	case B600:
	case B1200:
	case B2400:
	case B4800:
	case B9600:
	case B19200:
	case B38400:
	case B57600:
	case B115200:
	case B230400:
		value = B230400 / speed;
		break;
	default:
		DPRINTF(("%s: ubsa_param: unsupported baudrate, "
		    "forcing default of 9600\n",
		    sc->sc_dev.dv_xname));
		value = B230400 / B9600;
		break;
	};

	if (speed == B0) {
		ubsa_flow(sc, 0, 0);
		ubsa_dtr(sc, 0);
		ubsa_rts(sc, 0);
	} else
		ubsa_request(sc, UBSA_SET_BAUDRATE, value);
}

void
ubsa_parity(struct ubsa_softc *sc, tcflag_t cflag)
{
	int value;

	DPRINTF(("ubsa_parity: cflag = 0x%x\n", cflag));

	if (cflag & PARENB)
		value = (cflag & PARODD) ? UBSA_PARITY_ODD : UBSA_PARITY_EVEN;
	else
		value = UBSA_PARITY_NONE;

	ubsa_request(sc, UBSA_SET_PARITY, value);
}

void
ubsa_databits(struct ubsa_softc *sc, tcflag_t cflag)
{
	int value;

	DPRINTF(("ubsa_databits: cflag = 0x%x\n", cflag));

	switch (cflag & CSIZE) {
	case CS5: value = 0; break;
	case CS6: value = 1; break;
	case CS7: value = 2; break;
	case CS8: value = 3; break;
	default:
		DPRINTF(("%s: ubsa_param: unsupported databits requested, "
		    "forcing default of 8\n",
		    sc->sc_dev.dv_xname));
		value = 3;
	}

	ubsa_request(sc, UBSA_SET_DATA_BITS, value);
}

void
ubsa_stopbits(struct ubsa_softc *sc, tcflag_t cflag)
{
	int value;

	DPRINTF(("ubsa_stopbits: cflag = 0x%x\n", cflag));

	value = (cflag & CSTOPB) ? 1 : 0;

	ubsa_request(sc, UBSA_SET_STOP_BITS, value);
}

void
ubsa_flow(struct ubsa_softc *sc, tcflag_t cflag, tcflag_t iflag)
{
	int value;

	DPRINTF(("ubsa_flow: cflag = 0x%x, iflag = 0x%x\n", cflag, iflag));

	value = 0;
	if (cflag & CRTSCTS)
		value |= UBSA_FLOW_OCTS | UBSA_FLOW_IRTS;
	if (iflag & (IXON|IXOFF))
		value |= UBSA_FLOW_OXON | UBSA_FLOW_IXON;

	ubsa_request(sc, UBSA_SET_FLOW_CTRL, value);
}

int
ubsa_param(void *addr, int portno, struct termios *ti)
{
	struct ubsa_softc *sc = addr;

	DPRINTF(("ubsa_param: sc = %p\n", sc));

	ubsa_baudrate(sc, ti->c_ospeed);
	ubsa_parity(sc, ti->c_cflag);
	ubsa_databits(sc, ti->c_cflag);
	ubsa_stopbits(sc, ti->c_cflag);
	ubsa_flow(sc, ti->c_cflag, ti->c_iflag);

	return (0);
}

int
ubsa_open(void *addr, int portno)
{
	struct ubsa_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	DPRINTF(("ubsa_open: sc = %p\n", sc));

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_iface,
		    sc->sc_intr_number,
		    USBD_SHORT_XFER_OK,
		    &sc->sc_intr_pipe,
		    sc,
		    sc->sc_intr_buf,
		    sc->sc_isize,
		    ubsa_intr,
		    UBSA_INTR_INTERVAL);
		if (err) {
			printf("%s: cannot open interrupt pipe (addr %d)\n",
			    sc->sc_dev.dv_xname,
			    sc->sc_intr_number);
			return (EIO);
		}
	}

	return (0);
}

void
ubsa_close(void *addr, int portno)
{
	struct ubsa_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(("ubsa_close: close\n"));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname,
			    usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}
}

void
ubsa_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ubsa_softc *sc = priv;
	u_char *buf;
	struct usb_cdc_notification *cdcbuf;

	buf = sc->sc_intr_buf;
	cdcbuf = (struct usb_cdc_notification *)sc->sc_intr_buf;
	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: ubsa_intr: abnormal status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

#if 1 /* test */
	if (cdcbuf->bmRequestType == UCDC_NOTIFICATION) {
		printf("%s: this device is using CDC notify message in" 
		    " intr pipe.\n"
		    "Please send your dmesg to <bugs@@openbsd.org>, thanks.\n",
		    sc->sc_dev.dv_xname);
		printf("%s: intr buffer 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
		    sc->sc_dev.dv_xname,
		    buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);

		/* check the buffer data */
		if (cdcbuf->bNotification == UCDC_N_SERIAL_STATE)
			printf("%s:notify serial state, len=%d, data=0x%02x\n",
			    sc->sc_dev.dv_xname,
			    UGETW(cdcbuf->wLength), cdcbuf->data[0]);
	}
#endif

	/* incidentally, Belkin adapter status bits match UART 16550 bits */
	sc->sc_lsr = buf[2];
	sc->sc_msr = buf[3];

	DPRINTF(("%s: ubsa lsr = 0x%02x, msr = 0x%02x\n",
	    sc->sc_dev.dv_xname, sc->sc_lsr, sc->sc_msr));

	ucom_status_change((struct ucom_softc *)sc->sc_subdev);
}

void
ubsa_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct ubsa_softc *sc = addr;

	DPRINTF(("ubsa_get_status\n"));

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}
@


1.64
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.63 2014/07/12 20:26:33 mpi Exp $ 	*/
d373 1
a373 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
d631 1
a631 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
@


1.63
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.62 2014/07/12 18:48:52 tedu Exp $ 	*/
a75 1
#include <dev/usb/usb_quirks.h>
@


1.62
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.61 2014/03/07 18:39:02 mpi Exp $ 	*/
d213 10
a222 15
int ubsa_match(struct device *, void *, void *); 
void ubsa_attach(struct device *, struct device *, void *); 
int ubsa_detach(struct device *, int); 
int ubsa_activate(struct device *, int); 

struct cfdriver ubsa_cd = { 
	NULL, "ubsa", DV_DULL 
}; 

const struct cfattach ubsa_ca = { 
	sizeof(struct ubsa_softc), 
	ubsa_match, 
	ubsa_attach, 
	ubsa_detach, 
	ubsa_activate, 
a383 13
}

int
ubsa_activate(struct device *self, int act)
{
	struct ubsa_softc *sc = (struct ubsa_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.61
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.60 2013/11/15 10:17:39 pirofti Exp $ 	*/
d379 1
a379 1
		free(sc->sc_intr_buf, M_USBDEV);
d650 1
a650 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.60
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.59 2013/11/15 08:25:31 pirofti Exp $ 	*/
a78 4

#ifdef USB_DEBUG
#define UBSA_DEBUG
#endif
@


1.59
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.58 2013/11/07 07:32:36 pirofti Exp $ 	*/
d648 1
a648 5
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname,
			    usbd_errstr(err));
@


1.58
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.57 2013/04/15 09:23:02 mglocker Exp $ 	*/
a398 1
	int rv = 0;
a401 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d405 1
a405 1
	return (rv);
@


1.57
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.56 2013/03/28 03:58:03 tedu Exp $ 	*/
a166 2
	u_char			 sc_dying;	/* disconnecting */

d281 1
a281 1
		sc->sc_dying = 1;
d291 1
a291 1
		sc->sc_dying = 1;
d301 1
a301 1
		sc->sc_dying = 1;
d315 1
a315 1
			sc->sc_dying = 1;
d336 1
a336 1
		sc->sc_dying = 1;
d342 1
a342 1
		sc->sc_dying = 1;
d348 1
a348 1
		sc->sc_dying = 1;
d405 1
a405 1
		sc->sc_dying = 1;
d612 1
a612 1
	if (sc->sc_dying)
d645 1
a645 1
	if (sc->sc_dying)
d675 1
a675 1
	if (sc->sc_dying)
@


1.56
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.55 2013/03/28 03:31:55 tedu Exp $ 	*/
d149 2
a150 2
	usbd_device_handle	 sc_udev;	/* USB device */
	usbd_interface_handle	 sc_iface;	/* interface */
d155 1
a155 1
	usbd_pipe_handle	 sc_intr_pipe;	/* interrupt pipe */
d171 1
a171 1
void ubsa_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d253 1
a253 1
	usbd_device_handle dev = uaa->device;
d669 1
a669 1
ubsa_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d673 1
a673 1
	usb_cdc_notification_t *cdcbuf;
d676 1
a676 1
	cdcbuf = (usb_cdc_notification_t *)sc->sc_intr_buf;
@


1.55
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.54 2012/12/05 23:20:21 deraadt Exp $ 	*/
a67 1
#include <sys/proc.h>
@


1.54
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.53 2011/07/03 15:47:17 matthew Exp $ 	*/
a68 1
#include <sys/vnode.h>
@


1.53
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.52 2011/01/25 20:03:36 jakemsr Exp $ 	*/
a55 2

#include <sys/cdefs.h>
@


1.52
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.51 2010/12/17 21:53:34 jasper Exp $ 	*/
a407 3
	case DVACT_ACTIVATE:
		break;

@


1.51
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.50 2010/09/24 08:33:59 yuo Exp $ 	*/
a367 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a396 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.50
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.49 2010/04/22 19:47:30 mk Exp $ 	*/
a221 1
#define ubsa_lookup(v, p) usb_lookup(ubsa_devs, v, p)
d248 2
a249 2
	return (ubsa_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.49
log
@Remove unused sysctl.h include.  Inspired by claudio's commit the other day.

ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.48 2010/02/22 23:35:10 mpf Exp $ 	*/
a396 1
	sc->sc_dying = 1;
@


1.48
log
@0x19d2 is most likely a ZTE and not a Qualcomm vendor ID.
Too bad usb.org doesn't like to keep their lists updated,
so we have to resort to guessing here...
OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.47 2009/10/13 19:33:17 pirofti Exp $ 	*/
a72 1
#include <sys/sysctl.h>
@


1.47
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.46 2009/06/02 12:32:08 deraadt Exp $ 	*/
d218 4
a221 4
	/* Qualcomm Inc. ZTE CMDMA MSM modem */
	{ USB_VENDOR_QUALCOMM3, USB_PRODUCT_QUALCOMM3_CDMA_MSM },
	/* Qualcomm Inc. AC8700 */
	{ USB_VENDOR_QUALCOMM3, USB_PRODUCT_QUALCOMM3_AC8700 },
@


1.46
log
@Fix some minor format string problems found in a maze of false positives
provided by Parfait
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.45 2009/02/24 13:23:03 yuo Exp $ 	*/
d228 1
a228 1
int ubsa_activate(struct device *, enum devact); 
d411 1
a411 1
ubsa_activate(struct device *self, enum devact act)
@


1.45
log
@move AnyDATA ADU-E100H to umsm(4) from ubsa(4) as it uses msm chipset.

reported by denis1482
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.44 2009/02/18 17:15:21 deraadt Exp $ 	*/
d720 1
a720 1
			    cdcbuf->wLength, cdcbuf->data[0]);
@


1.44
log
@Make the best guesses possible about newer usb modems and in which modes
they need to be started up.  Some limited discussion with yuo@@ and fkr@@,
who to a large degree I think have punted on even trying to stay ahead
of the curve here.  Come on guys.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.43 2008/12/11 10:46:33 fkr Exp $ 	*/
a205 2
	/* AnyDATA ADU-E100H */
	{ USB_VENDOR_ANYDATA, USB_PRODUCT_ANYDATA_ADU_E100H },
@


1.43
log
@hook Qualcomm AC8700 modem into ubsa(4), from freebsd
discussed with yuo@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.42 2008/12/04 00:23:00 fkr Exp $ 	*/
a217 2
	/* Novatel Wireless U740 */
	{ USB_VENDOR_NOVATEL, USB_PRODUCT_NOVATEL_MERLINU740 },
@


1.42
log
@move Option GlobeTrotter 3G Quad / 3G Quad Plus and the
Vodafone Mobile Connect from ubsa(4) to umsm(4) as these should work
better with that driver.
discussed with yuo@@, jsg@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.41 2008/11/23 14:32:34 fkr Exp $ 	*/
d224 2
@


1.41
log
@move another Option modem from ubsa(4) to umsm(4), as umsm(4) supports
this much better.
ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.40 2008/11/21 21:10:03 fkr Exp $ 	*/
a219 6
	/* Option Vodafone Mobile Connect 3G */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_VODAFONEMC3G },
	/* Option GlobeTrotter 3G QUAD */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GQUAD },
	/* Option GlobeTrotter 3G QUAD PLUS */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GQUADPLUS },
@


1.40
log
@move Option Globetrotter GT Fusion from ubsa(4) to umsm(4) since it
does CDC. discussed with yuo@@ and jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.39 2008/10/08 17:17:15 yuo Exp $ 	*/
a225 2
	/* Option GlobeTrotter MAX 3.6/7.2 */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GTMAX36 },
@


1.39
log
@As the Option N.V. Globetrotter HSDPA Modem is not compatible
with ubsa(4), it is moved to umsm(4).

ok jsg@@, reported by Daniele Pilenga
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.38 2008/10/03 15:10:02 deraadt Exp $ 	*/
a221 2
	/* Option GlobeTrotter 3G FUSION */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_GT3GFUSION },
@


1.38
log
@and.. another option device..
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.37 2008/10/03 15:07:31 deraadt Exp $ 	*/
a227 2
	/* Option GlobeTrotter HSDPA */
	{ USB_VENDOR_OPTION, USB_PRODUCT_OPTION_SCORPION },
@


1.37
log
@another option hdspa
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.36 2008/07/20 14:24:49 yuo Exp $ 	*/
d230 2
@


1.36
log
@Huawei E618 and E620 is not compatible with ubsa(4).
This patch moves these device to umsm(4).

reported by Aleksander Piotrowski, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.35 2008/07/02 15:12:18 yuo Exp $ 	*/
d228 2
@


1.35
log
@As some modem devices in ubsa(4) are possible to be incompatible with
the native ubsa device, the patch notifies when it finds such a kind of
device.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.34 2008/06/26 05:42:18 ray Exp $ 	*/
a217 2
	/* HUAWEI Mobile */
	{ USB_VENDOR_HUAWEI, USB_PRODUCT_HUAWEI_E618 },
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.33 2008/04/02 08:54:08 fkr Exp $ 	*/
d701 1
d704 1
d717 18
@


1.33
log
@attach the ZTE CMDMA MSM modem from qualcomm.
from freebsd, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.32 2008/02/26 18:32:06 deraadt Exp $ 	*/
a42 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@Add support for Axesstel MV100H, as used on CDMA network operated by O2 CZ;
from Pav Lucistnik <pav@@FreeBSD.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.31 2007/10/11 18:33:14 deraadt Exp $ 	*/
d239 2
@


1.31
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.30 2007/06/14 10:11:15 mbalmer Exp $ 	*/
d215 2
@


1.30
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.29 2007/06/13 06:25:03 mbalmer Exp $ 	*/
a277 1
	char *devinfop;
a281 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.29
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.28 2007/06/12 16:26:36 mbalmer Exp $ 	*/
d240 16
a255 1
USB_DECLARE_DRIVER(ubsa);
@


1.28
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.27 2007/06/10 14:49:00 mbalmer Exp $ 	*/
d160 3
a162 3
	struct device		sc_dev;		/* base device */
	usbd_device_handle	sc_udev;	/* USB device */
	usbd_interface_handle	sc_iface;	/* interface */
d164 1
a164 1
	int			sc_iface_number;	/* interface number */
d166 2
a167 2
	int			sc_intr_number;	/* interrupt number */
	usbd_pipe_handle	sc_intr_pipe;	/* interrupt pipe */
d169 1
a169 1
	int			sc_isize;
d171 2
a172 2
	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */
d174 2
a175 2
	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* ubsa status register */
d177 1
a177 1
	struct device *		sc_subdev;	/* ucom device */
d179 1
a179 1
	u_char			sc_dying;	/* disconnecting */
@


1.27
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.26 2007/06/10 10:53:48 mbalmer Exp $ 	*/
d177 1
a177 1
	device_ptr_t		sc_subdev;	/* ucom device */
d416 1
a416 1
ubsa_activate(device_ptr_t self, enum devact act)
@


1.26
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.25 2007/06/06 19:25:49 mk Exp $ 	*/
d264 1
a264 1
	const char *devname = USBDEVNAME(sc->sc_dev);
d327 1
a327 1
			    USBDEVNAME(sc->sc_dev), i);
d449 1
a449 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d535 1
a535 1
		    USBDEVNAME(sc->sc_dev)));
d578 1
a578 1
		    USBDEVNAME(sc->sc_dev)));
d653 1
a653 1
			    USBDEVNAME(sc->sc_dev),
d677 1
a677 1
			    USBDEVNAME(sc->sc_dev),
d682 1
a682 1
			    USBDEVNAME(sc->sc_dev),
d704 1
a704 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status)));
d714 1
a714 1
	    USBDEVNAME(sc->sc_dev), sc->sc_lsr, sc->sc_msr));
@


1.25
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.24 2007/06/05 08:43:55 mbalmer Exp $ 	*/
d376 1
a376 1
			   USBDEV(sc->sc_dev));
d410 1
a410 1
			   USBDEV(sc->sc_dev));
@


1.24
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.23 2007/06/01 06:12:20 mbalmer Exp $ 	*/
d160 1
a160 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.23
log
@Remove more Free(?)BSD and NetBSD #ifdef/#endifs.  No functional nor
binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.22 2007/05/27 04:00:25 jsg Exp $ 	*/
d97 1
a97 1
Static int	ubsadebug = 0;
d183 1
a183 1
Static	void ubsa_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d185 15
a199 15
Static	void ubsa_get_status(void *, int, u_char *, u_char *);
Static	void ubsa_set(void *, int, int, int);
Static	int  ubsa_param(void *, int, struct termios *);
Static	int  ubsa_open(void *, int);
Static	void ubsa_close(void *, int);

Static	void ubsa_break(struct ubsa_softc *sc, int onoff);
Static	int  ubsa_request(struct ubsa_softc *, u_int8_t, u_int16_t);
Static	void ubsa_dtr(struct ubsa_softc *, int);
Static	void ubsa_rts(struct ubsa_softc *, int);
Static	void ubsa_baudrate(struct ubsa_softc *, speed_t);
Static	void ubsa_parity(struct ubsa_softc *, tcflag_t);
Static	void ubsa_databits(struct ubsa_softc *, tcflag_t);
Static	void ubsa_stopbits(struct ubsa_softc *, tcflag_t);
Static	void ubsa_flow(struct ubsa_softc *, tcflag_t, tcflag_t);
d212 1
a212 1
Static const struct usb_devno ubsa_devs[] = {
d434 1
a434 1
Static int
d453 1
a453 1
Static void
d466 1
a466 1
Static void
d479 1
a479 1
Static void
d488 1
a488 1
Static void
d509 1
a509 1
Static void
d548 1
a548 1
Static void
d563 1
a563 1
Static void
d585 1
a585 1
Static void
d597 1
a597 1
Static void
d613 1
a613 1
Static int
d629 1
a629 1
Static int
d662 1
a662 1
Static void
d689 1
a689 1
Static void
d719 1
a719 1
Static void
@


1.22
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.21 2007/05/21 05:40:28 jsg Exp $ 	*/
a69 1
#if defined(__OpenBSD__)
a70 3
#elif defined(__FreeBSD__)
#include <sys/bus.h>
#endif
a97 5
#ifdef __FreeBSD__
SYSCTL_NODE(_hw_usb, OID_AUTO, ubsa, CTLFLAG_RW, 0, "USB ubsa");
SYSCTL_INT(_hw_usb_ubsa, OID_AUTO, debug, CTLFLAG_RW,
	   &ubsadebug, 0, "ubsa debug level");
#endif
@


1.21
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.20 2007/02/27 11:02:34 fkr Exp $ 	*/
d251 2
a252 1
USB_MATCH(ubsa)
d254 1
a254 1
	USB_MATCH_START(ubsa, uaa);
d263 2
a264 1
USB_ATTACH(ubsa)
d266 2
a267 1
	USB_ATTACH_START(ubsa, sc, uaa);
d279 1
a279 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
a391 2
	USB_ATTACH_SUCCESS_RETURN;

d393 1
a393 1
	USB_ATTACH_ERROR_RETURN;
d396 2
a397 1
USB_DETACH(ubsa)
d399 1
a399 1
	USB_DETACH_START(ubsa, sc);
@


1.20
log
@attach AnyDATA E100H to ubsa.
from netbsd, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.19 2007/02/21 05:41:57 fkr Exp $ 	*/
d108 1
a108 1
#define	DPRINTFN(n, x)	do { if (ubsadebug > (n)) logprintf x; } while (0)
@


1.19
log
@let the Globetrotter 3G+ attach to ubsa, from Victor Meghesan through bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.18 2006/12/07 21:25:37 fkr Exp $ 	*/
d222 2
@


1.18
log
@attach Novatel Merlin U740 to ubsa
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.17 2006/08/07 18:16:10 fkr Exp $ 	*/
d240 2
@


1.17
log
@small whitespace nit
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.16 2006/08/07 16:22:44 fkr Exp $ 	*/
d232 2
a233 2
	/* Peracom */
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_SERIAL1 },
d240 2
@


1.16
log
@attach the HUAWEI Mobile E618 umts adapter
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.15 2006/06/23 06:27:11 miod Exp $ 	*/
d200 1
a200 1
Static  void ubsa_break(struct ubsa_softc *sc, int onoff);
d274 1
a274 1
        sc->sc_udev = dev;
@


1.15
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.14 2006/02/11 09:33:45 brad Exp $ 	*/
d230 2
@


1.14
log
@Simplify code a bit.

From NetBSD

ok fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.13 2005/11/21 18:16:43 millert Exp $ 	*/
d423 1
a423 1
		return (EOPNOTSUPP);
@


1.13
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.12 2005/10/29 23:35:20 deraadt Exp $ 	*/
a174 1
	usbd_interface_handle	sc_intr_iface;	/* interrupt interface */
a351 3
	/* keep interface for interrupt */
	sc->sc_intr_iface = sc->sc_iface;

d642 1
a642 1
		err = usbd_open_pipe_intr(sc->sc_intr_iface,
@


1.12
log
@comment fix: Two vendors sold same thing
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.11 2005/08/01 05:36:48 brad Exp $ 	*/
a79 1
#if __FreeBSD_version >= 500014
a80 3
#else
#include <sys/select.h>
#endif
@


1.11
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.10 2005/03/18 00:33:28 reyk Exp $ 	*/
d231 1
a231 1
	/* GoHubs GO-COM232 */
@


1.10
log
@sync and cleanup in ubsa(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.9 2005/01/16 04:53:00 dlg Exp $ 	*/
d266 1
a266 1
	char devinfo[1024];
d272 4
a275 3
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
        USB_ATTACH_SETUP;
        printf("%s: %s\n", devname, devinfo);
@


1.9
log
@USB_DEBUG should imply UBSA_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.8 2005/01/12 11:15:10 moritz Exp $ 	*/
d237 6
a242 2
	/* Vodafone */
	{ USB_VENDOR_VODAFONE, USB_PRODUCT_VODAFONE_MOBILE_3G }
d454 1
a454 1
	if (err)
d540 1
a540 1
		printf("%s: ubsa_param: unsupported baudrate, "
d542 1
a542 1
		    USBDEVNAME(sc->sc_dev));
d583 1
a583 1
		printf("%s: ubsa_param: unsupported databits requested, "
d585 1
a585 1
		    USBDEVNAME(sc->sc_dev));
@


1.8
log
@fix kernel building with option UBSA_DEBUG.

ok dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.7 2005/01/03 23:15:50 reyk Exp $ 	*/
d99 4
@


1.7
log
@Add support for the Vodafone Mobile Connect 3G adapter.
The MC3G is a cardbus device with an integrated OHCI usb
controller. The GRPS/UMTS modem is attached via an internal
Belkin serial adapter (ubsa(4)).

Thanks to sh at horzela dot com.

ok deraadt@@ and dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.6 2005/01/03 20:33:46 deraadt Exp $ 	*/
d377 1
a377 1
	    uca.bulkin_no, uca.bulkout_no, sc->sc_intr_number));
d703 1
a703 2
		    USBDEVNAME(sc->sc_ucom.sc_dev),
		    usbd_errstr(status)));
d713 1
a713 1
	    USBDEVNAME(sc->sc_ucom.sc_dev), sc->sc_lsr, sc->sc_msr));
@


1.6
log
@do not print device info twice
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.5 2004/07/08 22:18:44 deraadt Exp $ 	*/
d233 2
d347 3
@


1.5
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.4 2003/11/11 15:14:56 miod Exp $ 	*/
a273 2

	printf("%s: %s\n", devname, devinfo);
@


1.4
log
@Do not free() stack variables; reported by Mario Lang (mlang at delysid dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.3 2003/05/19 00:29:34 nate Exp $ 	*/
d108 1
a108 4
#define	DPRINTFN(n, x)	do { \
				if (ubsadebug > (n)) \
					logprintf x; \
			} while (0)
@


1.3
log
@initialize variable to match NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.2 2003/05/07 04:33:33 deraadt Exp $ 	*/
a383 1
	free(devinfo, M_USBDEV);
@


1.2
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ubsa.c,v 1.1 2002/11/30 19:29:29 nate Exp $ 	*/
/*	$NetBSD: ubsa.c,v 1.3 2002/10/27 20:16:41 augustss Exp $	*/
d391 1
a391 1
	int rv;
@


1.1
log
@Add driver for Belkin usb serial adapters.
Driver from Alexander Kabaev <kan.FreeBSD.org> and Ichiro FUKUHARA
<ichiro@@ichiro.org>
@
text
@d1 1
a1 1
/*	$OpenBSD$ 	*/
d265 1
a265 1
        usbd_devinfo(dev, 0, devinfo);
@


1.1.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ubsa.c,v 1.1 2002/11/30 19:29:29 nate Exp $ 	*/
d265 1
a265 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.1.4.2
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ 	*/
/*	$NetBSD: ubsa.c,v 1.5 2002/11/25 00:51:33 fvdl Exp $	*/
d391 1
a391 1
	int rv = 0;
@


1.1.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d384 1
@


