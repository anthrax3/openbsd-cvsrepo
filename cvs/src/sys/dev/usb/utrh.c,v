head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.6
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.4.0.2
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	6s3MfY9d6ZKdL2Uz;

1.20
date	2016.03.19.11.41.56;	author mpi;	state Exp;
branches;
next	1.19;
commitid	YKz4aSf7zOPIkVrc;

1.19
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.18;
commitid	KAeCDAijcgEnOtfF;

1.18
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.17;
commitid	kI4H556ZKYkRQGw5;

1.17
date	2014.12.11.18.39.28;	author mpi;	state Exp;
branches;
next	1.16;
commitid	L2P5oN9ppxqXZsYS;

1.16
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.15;
commitid	OBNa5kfxQ2UXoiIw;

1.15
date	2014.05.07.08.17.21;	author mpi;	state Exp;
branches;
next	1.14;

1.14
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.13;

1.13
date	2014.03.19.08.59.37;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.17.08.34.45;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.6;

1.6
date	2010.12.19.21.32.58;	author jasper;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.15.09.40.46;	author yuo;	state Exp;
branches;
next	1.3;

1.3
date	2010.02.18.23.34.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2009.12.19.05.49.58;	author yuo;	state Exp;
branches;
next	1.1;

1.1
date	2009.12.18.04.16.14;	author yuo;	state Exp;
branches;
next	;


desc
@@


1.21
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: utrh.c,v 1.20 2016/03/19 11:41:56 mpi Exp $   */

/*
 * Copyright (c) 2009 Yojiro UO <yuo@@nui.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for Strawberry linux USBRH Temerature/Humidity sensor */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/sensors.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>

#ifdef UTRH_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

/* sensors */
#define UTRH_TEMP		0
#define UTRH_HUMIDITY		1
#define UTRH_MAX_SENSORS	2

struct utrh_softc {
	struct uhidev		 sc_hdev;
	struct usbd_device	*sc_udev;

	/* uhidev parameters */
	size_t			 sc_flen;	/* feature report length */
	size_t			 sc_ilen;	/* input report length */
	size_t			 sc_olen;	/* output report length */

	uint8_t			*sc_ibuf;

	/* sensor framework */
	struct ksensor		 sc_sensor[UTRH_MAX_SENSORS];
	struct ksensordev	 sc_sensordev;
	struct sensor_task	*sc_sensortask;

	uint8_t			 sc_num_sensors;
};

const struct usb_devno utrh_devs[] = {
	{ USB_VENDOR_STRAWBERRYLINUX, USB_PRODUCT_STRAWBERRYLINUX_USBRH},
};

int utrh_match(struct device *, void *, void *);
void utrh_attach(struct device *, struct device *, void *);
int utrh_detach(struct device *, int);

int utrh_sht1x_temp(unsigned int);
int utrh_sht1x_rh(unsigned int, int);

void utrh_intr(struct uhidev *, void *, u_int);
void utrh_refresh(void *);

struct cfdriver utrh_cd = {
	NULL, "utrh", DV_DULL
};

const struct cfattach utrh_ca = {
	sizeof(struct utrh_softc),
	utrh_match,
	utrh_attach,
	utrh_detach
};

int
utrh_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;

	if (uha->reportid == UHIDEV_CLAIM_ALLREPORTID)
		return (UMATCH_NONE);

	return (usb_lookup(utrh_devs, uha->uaa->vendor, uha->uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
utrh_attach(struct device *parent, struct device *self, void *aux)
{
	struct utrh_softc *sc = (struct utrh_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct usbd_device *dev = uha->parent->sc_udev;
	int size, repid, err;
	void *desc;

	sc->sc_udev = dev;
	sc->sc_hdev.sc_intr = utrh_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;
	sc->sc_num_sensors = 0;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_ilen = hid_report_size(desc, size, hid_input, repid);
	sc->sc_olen = hid_report_size(desc, size, hid_output, repid);
	sc->sc_flen = hid_report_size(desc, size, hid_feature, repid);

	err = uhidev_open(&sc->sc_hdev);
	if (err) {
		printf("utrh_open: uhidev_open %d\n", err);
		return;
	}
	sc->sc_ibuf = malloc(sc->sc_ilen, M_USBDEV, M_WAITOK);

	printf("\n");

	/* attach sensor */
	strlcpy(sc->sc_sensordev.xname, sc->sc_hdev.sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor[UTRH_TEMP].type = SENSOR_TEMP;
	sc->sc_sensor[UTRH_TEMP].flags = SENSOR_FINVALID;

	strlcpy(sc->sc_sensor[UTRH_HUMIDITY].desc, "RH",
	    sizeof(sc->sc_sensor[UTRH_HUMIDITY].desc));
	sc->sc_sensor[UTRH_HUMIDITY].type = SENSOR_HUMIDITY;
	sc->sc_sensor[UTRH_HUMIDITY].flags = SENSOR_FINVALID;

	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[UTRH_TEMP]);
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[UTRH_HUMIDITY]);
	sc->sc_num_sensors = 2;

	if (sc->sc_num_sensors > 0) {
		sc->sc_sensortask = sensor_task_register(sc, utrh_refresh, 6);
		if (sc->sc_sensortask == NULL) {
			printf(", unable to register update task\n");
			return;
		}
		sensordev_install(&sc->sc_sensordev);
	}

	DPRINTF(("utrh_attach: complete\n"));
}

int
utrh_detach(struct device *self, int flags)
{
	struct utrh_softc *sc = (struct utrh_softc *)self;
	int i, rv = 0;

	if (sc->sc_num_sensors > 0) {
		wakeup(&sc->sc_sensortask);
		sensordev_deinstall(&sc->sc_sensordev);
		for (i = 0; i < sc->sc_num_sensors; i++)
			sensor_detach(&sc->sc_sensordev, &sc->sc_sensor[i]);
		if (sc->sc_sensortask != NULL)
			sensor_task_unregister(sc->sc_sensortask);
	}

	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);

	if (sc->sc_ibuf != NULL) {
		free(sc->sc_ibuf, M_USBDEV, sc->sc_ilen);
		sc->sc_ibuf = NULL;
	}

	return (rv);
}

void
utrh_intr(struct uhidev *addr, void *ibuf, u_int len)
{
	struct utrh_softc *sc = (struct utrh_softc *)addr;

	if (sc->sc_ibuf == NULL)
		return;

	/* receive sensor data */
	memcpy(sc->sc_ibuf, ibuf, len);
	return;
}

void
utrh_refresh(void *arg)
{
	struct utrh_softc *sc = arg;
	unsigned int temp_tick, humidity_tick;
	int temp, rh;
	uint8_t ledbuf[7];

	/* turn on LED 1*/
	bzero(ledbuf, sizeof(ledbuf));
	ledbuf[0] = 0x3;
	ledbuf[1] = 0x1;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, ledbuf, sc->sc_flen) != sc->sc_flen)
		printf("LED request failed\n");

	/* issue query */
	uint8_t cmdbuf[] = {0x31, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00};
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen) != sc->sc_flen)
		return;

	/* wait till sensor data are updated, 1s will be enough */
	tsleep(&sc->sc_sensortask, 0, "utrh", (1*hz));

	/* turn off LED 1 */
	ledbuf[1] = 0x0;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, ledbuf, sc->sc_flen) != sc->sc_flen)
		printf("LED request failed\n");

	temp_tick = (sc->sc_ibuf[2] * 256 + sc->sc_ibuf[3]) & 0x3fff;
	humidity_tick = (sc->sc_ibuf[0] * 256 + sc->sc_ibuf[1]) & 0x0fff;

	temp = utrh_sht1x_temp(temp_tick);
	rh = utrh_sht1x_rh(humidity_tick, temp);

	sc->sc_sensor[UTRH_TEMP].value = (temp * 10000) + 273150000;
	sc->sc_sensor[UTRH_TEMP].flags &= ~SENSOR_FINVALID;
	sc->sc_sensor[UTRH_HUMIDITY].value = rh;
	sc->sc_sensor[UTRH_HUMIDITY].flags &= ~SENSOR_FINVALID;
}

/* return C-degree * 100 value */
int
utrh_sht1x_temp(unsigned int nticks)
{
	return (nticks - 4010);
}

/* return %RH * 1000 */
int
utrh_sht1x_rh(unsigned int nticks, int temp)
{
	int rh_l, rh;

	rh_l = (-40000 + 405 * nticks) - ((7 * nticks * nticks) / 250);
	rh = ((temp - 2500) * (1 + (nticks >> 7)) + rh_l) / 10;
	return rh;
}
@


1.20
log
@Reduces the noise around the global ``ticks''  variable by renaming all
local ones to ``nticks''.

(missed in previous)

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.19 2016/01/09 04:14:42 jcs Exp $   */
d181 1
a181 1
		free(sc->sc_ibuf, M_USBDEV, 0);
@


1.19
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.18 2016/01/08 15:54:14 jcs Exp $   */
d246 1
a246 1
utrh_sht1x_temp(unsigned int ticks)
d248 1
a248 1
	return (ticks - 4010);
d253 1
a253 1
utrh_sht1x_rh(unsigned int ticks, int temp)
d257 2
a258 2
	rh_l = (-40000 + 405 * ticks) - ((7 * ticks * ticks) / 250);
	rh = ((temp - 2500) * (1 + (ticks >> 7)) + rh_l) / 10;
@


1.18
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.17 2014/12/11 18:39:28 mpi Exp $   */
a34 2

#include <dev/hid/hid.h>
@


1.17
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.16 2014/07/12 18:48:53 tedu Exp $   */
d35 2
a36 1
#include <dev/usb/hid.h>
@


1.16
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.15 2014/05/07 08:17:21 mpi Exp $   */
d214 2
a215 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, ledbuf, sc->sc_flen))
d220 2
a221 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen))
d229 2
a230 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, ledbuf, sc->sc_flen))
@


1.15
log
@Make sure to call uhidev_close() upon detach for every HID driver calling
uhidev_open() at attach time.  This plugs up to 3 xfer leaks and a buffer
one.

ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.14 2014/04/15 09:14:27 mpi Exp $   */
d182 1
a182 1
		free(sc->sc_ibuf, M_USBDEV);
@


1.14
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.13 2014/03/19 08:59:37 mpi Exp $   */
d177 3
@


1.13
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.12 2014/03/07 18:39:02 mpi Exp $   */
d212 1
a212 1
	    ledbuf, sc->sc_flen))
d218 1
a218 1
	    cmdbuf, sc->sc_olen))
d227 1
a227 1
	    ledbuf, sc->sc_flen))
@


1.12
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.11 2013/08/17 08:34:45 sthen Exp $   */
d95 4
a98 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
@


1.11
log
@Remove unnecessary activate functions and unused DPRINTFN macros.
Req by and OK mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.10 2013/04/15 09:23:02 mglocker Exp $   */
a35 4

#ifdef USB_DEBUG
#define UTRH_DEBUG
#endif
@


1.10
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.9 2013/03/28 03:58:03 tedu Exp $   */
d42 1
a42 2
int	utrhdebug = 0;
#define DPRINTFN(n, x)	do { if (utrhdebug > (n)) printf x; } while (0)
d44 1
a44 1
#define DPRINTFN(n, x)
a46 2
#define DPRINTF(x) DPRINTFN(0, x)

a54 2
	u_char			 sc_dying;
	uint16_t		 sc_flag;
a77 1
int utrh_activate(struct device *, int);
d93 1
a93 2
	utrh_detach,
	utrh_activate,
a185 13
}

int
utrh_activate(struct device *self, int act)
{
	struct utrh_softc *sc = (struct utrh_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.9
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.8 2011/07/03 15:47:17 matthew Exp $   */
d57 1
a57 1
	usbd_device_handle	 sc_udev;
d119 1
a119 1
	usbd_device_handle dev = uha->parent->sc_udev;
@


1.8
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.7 2011/01/25 20:03:36 jakemsr Exp $   */
a21 1
#include <sys/proc.h>
@


1.7
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.6 2010/12/19 21:32:58 jasper Exp $   */
a201 3
	case DVACT_ACTIVATE:
		break;

@


1.6
log
@- use usb_lookup(), these should be the last drivers that rolled their own
unneeded macro around it.
- fix a reference to the previous driver name utwitch while here

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.5 2010/09/24 08:33:59 yuo Exp $   */
a142 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
a191 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
@


1.5
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.4 2010/04/15 09:40:46 yuo Exp $   */
a79 1
#define utrh_lookup(v, p) usb_lookup(utrh_devs, v, p)
d110 2
a111 4
	if (utrh_lookup(uha->uaa->vendor, uha->uaa->product) == NULL)
		return UMATCH_NONE;

	return (UMATCH_VENDOR_PRODUCT);
@


1.4
log
@use SENSOR_HUMIDITY instead of SENSOR_PERCENT.
and add LED blink routine.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.3 2010/02/18 23:34:05 deraadt Exp $   */
a182 2

	sc->sc_dying = 1;
@


1.3
log
@do not zero fields which are already zero; from cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.2 2009/12/19 05:49:58 yuo Exp $   */
d157 1
a157 1
	strlcpy(sc->sc_sensor[UTRH_HUMIDITY].desc, "humidity",
d159 1
a159 1
	sc->sc_sensor[UTRH_HUMIDITY].type = SENSOR_PERCENT;
d241 9
d259 6
@


1.2
log
@fix tsleep parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: utrh.c,v 1.1 2009/12/18 04:16:14 yuo Exp $   */
a153 2
	strlcpy(sc->sc_sensor[UTRH_TEMP].desc, "temp",
	    sizeof(sc->sc_sensor[UTRH_TEMP].desc));
a154 1
	sc->sc_sensor[UTRH_TEMP].status = SENSOR_S_UNSPEC;
a159 2
	sc->sc_sensor[UTRH_HUMIDITY].value = 0;
	sc->sc_sensor[UTRH_HUMIDITY].status = SENSOR_S_UNSPEC;
@


1.1
log
@add utrh(4): USBRH temperature / humidity sensor driver

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD:$   */
d253 2
a254 2
	/* wait till sensor data are updated, 1000ms will be enough */
	tsleep(&sc->sc_sensortask, 0, "utrh", 1000);
@

