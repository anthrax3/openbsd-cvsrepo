head	1.75;
access;
symbols
	OPENBSD_6_2_BASE:1.75
	OPENBSD_6_1:1.69.0.4
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.48.0.4
	OPENBSD_5_8_BASE:1.48
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.2
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16;
locks; strict;
comment	@ * @;


1.75
date	2017.08.23.09.25.17;	author kevlo;	state Exp;
branches;
next	1.74;
commitid	PdNPq9nA6wBZrZX0;

1.74
date	2017.08.16.01.26.46;	author kevlo;	state Exp;
branches;
next	1.73;
commitid	1rp8I4dQTU8rS4Wn;

1.73
date	2017.08.12.14.08.44;	author stsp;	state Exp;
branches;
next	1.72;
commitid	Em2RfIKTuLyMWs6R;

1.72
date	2017.06.23.14.41.54;	author kevlo;	state Exp;
branches;
next	1.71;
commitid	xWVG1OM9roi5QWCx;

1.71
date	2017.06.16.14.57.51;	author kevlo;	state Exp;
branches;
next	1.70;
commitid	8jwmrfgoYCuKt0bI;

1.70
date	2017.05.08.12.28.39;	author stsp;	state Exp;
branches;
next	1.69;
commitid	lKWH0uUZQSLUouGI;

1.69
date	2017.01.30.21.54.30;	author stsp;	state Exp;
branches;
next	1.68;
commitid	Gi00kQrNZo1HNvpa;

1.68
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.67;
commitid	VyLWTsbepAOk7VQM;

1.67
date	2017.01.08.05.48.27;	author stsp;	state Exp;
branches;
next	1.66;
commitid	LFu1DLew9OBcvmQp;

1.66
date	2016.07.21.08.38.33;	author stsp;	state Exp;
branches;
next	1.65;
commitid	IBBsfEsDJWc1dm6T;

1.65
date	2016.06.17.10.53.55;	author stsp;	state Exp;
branches;
next	1.64;
commitid	wpzelyaGh6bAmql3;

1.64
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.63;
commitid	gWZDkudwxydTq8x4;

1.63
date	2016.03.21.22.12.06;	author stsp;	state Exp;
branches;
next	1.62;
commitid	ZXu3psL3p4iRj2AC;

1.62
date	2016.03.09.22.07.46;	author stsp;	state Exp;
branches;
next	1.61;
commitid	QjAK3V68fxDQ1RLI;

1.61
date	2016.03.07.19.41.50;	author stsp;	state Exp;
branches;
next	1.60;
commitid	Ba7FxziQTvdZ6Q1J;

1.60
date	2016.03.07.18.05.41;	author stsp;	state Exp;
branches;
next	1.59;
commitid	yHXDHZoM9XUw22jk;

1.59
date	2016.03.07.16.17.36;	author stsp;	state Exp;
branches;
next	1.58;
commitid	wd5rvat9pE5BITxT;

1.58
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.57;
commitid	2QagMjdMhQhIaQgu;

1.57
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.56;
commitid	B0kwmVGiD5DVx4kv;

1.56
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.55;
commitid	FuSD2mFDJWATHIDx;

1.55
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.54;
commitid	5DvsamK0GblTp8ww;

1.54
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.53;
commitid	YT6fyIEviv9qwbl6;

1.53
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.52;
commitid	pwYnMC1gOKohmeGw;

1.52
date	2015.09.18.11.24.15;	author mpi;	state Exp;
branches;
next	1.51;
commitid	3K63k1ijMnawIJRO;

1.51
date	2015.09.10.11.53.05;	author stsp;	state Exp;
branches;
next	1.50;
commitid	jOpEoOibYigWiHxJ;

1.50
date	2015.08.24.04.07.38;	author jsg;	state Exp;
branches;
next	1.49;
commitid	OPoATfLdhkPrTwbr;

1.49
date	2015.08.22.15.19.33;	author stsp;	state Exp;
branches;
next	1.48;
commitid	8Ab4k3LKmWbJQk4C;

1.48
date	2015.06.12.15.47.31;	author mpi;	state Exp;
branches;
next	1.47;
commitid	t0sjCnxjbRqHxJe2;

1.47
date	2015.05.12.11.46.15;	author stsp;	state Exp;
branches;
next	1.46;
commitid	1surlJgmWBOcCSrj;

1.46
date	2015.05.10.19.40.56;	author stsp;	state Exp;
branches;
next	1.45;
commitid	6Wv77OKzhxlqpeD9;

1.45
date	2015.05.10.15.10.46;	author stsp;	state Exp;
branches;
next	1.44;
commitid	LfjbYhHYNegRFpez;

1.44
date	2015.05.04.11.46.29;	author stsp;	state Exp;
branches;
next	1.43;
commitid	oe0TV8uhBd2RJaAI;

1.43
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.41;
commitid	Hly9lJn6CNMylcFu;

1.41
date	2015.02.07.21.21.44;	author mpi;	state Exp;
branches;
next	1.40;
commitid	y32rtwJ7pRajoUYL;

1.40
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.39;
commitid	yM2VFFhpDTeFQlve;

1.39
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.38;
commitid	LS2TNeCue5R9L67C;

1.38
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.37;
commitid	Pclvgy2Z4XV9hveD;

1.37
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.36;
commitid	OBNa5kfxQ2UXoiIw;

1.36
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.35;
commitid	b0VSac5dnnsxcDao;

1.35
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2014.03.14.15.00.47;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.09.30.05.18.57;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2013.09.30.03.59.56;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.20.04.52.00;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2013.08.19.14.12.44;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2013.07.21.15.19.52;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.16.09.31.55;	author sthen;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.29.07.43.52;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.17.15.14.14;	author yasuoka;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.08.12.17.20;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2012.04.08.03.09.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.26.06.39.33;	author ckuethe;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.29.12.18.14;	author gsoares;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.19.17.55.37;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2011.02.10.17.26.40;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2011.02.09.04.25.32;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.05.18.10.44;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.31.20.50.14;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.27.03.03.50;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.11.21.07.38;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.11.13.27.27;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.07.17.03.19;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.16.19.28.56;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.16.18.02.59;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2010.11.15.18.56.13;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2010.11.06.12.27.43;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.05.17.57.10;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2010.11.05.17.26.38;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2010.11.05.16.58.12;	author damien;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Fix up rssi calculations and r88e_rx_cck structure for RTL8188EU.
Tested with TL-WN725N v2 (rtl8188eu) on amd64.

ok stsp@@
@
text
@/*	$OpenBSD: if_urtwn.c,v 1.74 2017/08/16 01:26:46 kevlo Exp $	*/

/*-
 * Copyright (c) 2010 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2014 Kevin Lo <kevlo@@FreeBSD.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Realtek RTL8188CE-VAU/RTL8188CUS/RTL8188EU/RTL8188RU/RTL8192CU.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/ic/r92creg.h>
#include <dev/ic/rtwnvar.h>

/* Maximum number of output pipes is 3. */
#define R92C_MAX_EPOUT	3

#define R92C_HQ_NPAGES		12
#define R92C_LQ_NPAGES		2
#define R92C_NQ_NPAGES		2
#define R92C_TXPKTBUF_COUNT	256
#define R92C_TX_PAGE_COUNT	248
#define R92C_TX_PAGE_BOUNDARY	(R92C_TX_PAGE_COUNT + 1)
#define R92C_MAX_RX_DMA_SIZE	0x2800
#define R88E_HQ_NPAGES		0
#define R88E_LQ_NPAGES		9
#define R88E_NQ_NPAGES		0
#define R88E_TXPKTBUF_COUNT	177
#define R88E_TX_PAGE_COUNT	168
#define R88E_TX_PAGE_BOUNDARY	(R88E_TX_PAGE_COUNT + 1)
#define R88E_MAX_RX_DMA_SIZE	0x2400

/* USB Requests. */
#define R92C_REQ_REGS	0x05

/*
 * Driver definitions.
 */
#define URTWN_RX_LIST_COUNT		1
#define URTWN_TX_LIST_COUNT		8
#define URTWN_HOST_CMD_RING_COUNT	32

#define URTWN_RXBUFSZ	(16 * 1024)
#define URTWN_TXBUFSZ	(sizeof(struct r92c_tx_desc_usb) + IEEE80211_MAX_LEN)

#define URTWN_RIDX_COUNT	28

#define URTWN_TX_TIMEOUT	5000	/* ms */

#define URTWN_LED_LINK	0
#define URTWN_LED_DATA	1

struct urtwn_rx_radiotap_header {
	struct ieee80211_radiotap_header wr_ihdr;
	uint8_t		wr_flags;
	uint8_t		wr_rate;
	uint16_t	wr_chan_freq;
	uint16_t	wr_chan_flags;
	uint8_t		wr_dbm_antsignal;
} __packed;

#define URTWN_RX_RADIOTAP_PRESENT			\
	(1 << IEEE80211_RADIOTAP_FLAGS |		\
	 1 << IEEE80211_RADIOTAP_RATE |			\
	 1 << IEEE80211_RADIOTAP_CHANNEL |		\
	 1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL)

struct urtwn_tx_radiotap_header {
	struct ieee80211_radiotap_header wt_ihdr;
	uint8_t		wt_flags;
	uint16_t	wt_chan_freq;
	uint16_t	wt_chan_flags;
} __packed;

#define URTWN_TX_RADIOTAP_PRESENT			\
	(1 << IEEE80211_RADIOTAP_FLAGS |		\
	 1 << IEEE80211_RADIOTAP_CHANNEL)

struct urtwn_softc;

struct urtwn_rx_data {
	struct urtwn_softc	*sc;
	struct usbd_xfer	*xfer;
	uint8_t			*buf;
};

struct urtwn_tx_data {
	struct urtwn_softc		*sc;
	struct usbd_pipe		*pipe;
	struct usbd_xfer		*xfer;
	uint8_t				*buf;
	TAILQ_ENTRY(urtwn_tx_data)	next;
};

struct urtwn_host_cmd {
	void	(*cb)(struct urtwn_softc *, void *);
	uint8_t	data[256];
};

struct urtwn_cmd_newstate {
	enum ieee80211_state	state;
	int			arg;
};

struct urtwn_cmd_key {
	struct ieee80211_key	key;
	struct ieee80211_node	*ni;
};

struct urtwn_host_cmd_ring {
	struct urtwn_host_cmd	cmd[URTWN_HOST_CMD_RING_COUNT];
	int			cur;
	int			next;
	int			queued;
};

struct urtwn_softc {
	struct device			sc_dev;
	struct rtwn_softc		sc_sc;

	struct usbd_device		*sc_udev;
	struct usbd_interface		*sc_iface;
	struct usb_task			sc_task;

	struct timeout			scan_to;
	struct timeout			calib_to;

	int				ntx;
	struct usbd_pipe		*rx_pipe;
	struct usbd_pipe		*tx_pipe[R92C_MAX_EPOUT];
	int				ac2idx[EDCA_NUM_AC];

	struct urtwn_host_cmd_ring	cmdq;
	struct urtwn_rx_data		rx_data[URTWN_RX_LIST_COUNT];
	struct urtwn_tx_data		tx_data[URTWN_TX_LIST_COUNT];
	TAILQ_HEAD(, urtwn_tx_data)	tx_free_list;

	struct ieee80211_amrr		amrr;
	struct ieee80211_amrr_node	amn;

#if NBPFILTER > 0
	caddr_t				sc_drvbpf;

	union {
		struct urtwn_rx_radiotap_header th;
		uint8_t	pad[64];
	}				sc_rxtapu;
#define sc_rxtap	sc_rxtapu.th
	int				sc_rxtap_len;

	union {
		struct urtwn_tx_radiotap_header th;
		uint8_t	pad[64];
	}				sc_txtapu;
#define sc_txtap	sc_txtapu.th
	int				sc_txtap_len;
#endif
};

#ifdef URTWN_DEBUG
#define DPRINTF(x)	do { if (urtwn_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (urtwn_debug >= (n)) printf x; } while (0)
int urtwn_debug = 4;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

/*
 * Various supported device vendors/products.
 */
#define URTWN_DEV(v, p, f)					\
        { { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, (f) | RTWN_CHIP_USB }
#define URTWN_DEV_8192CU(v, p)	URTWN_DEV(v, p, RTWN_CHIP_92C | RTWN_CHIP_88C)
#define URTWN_DEV_8188EU(v, p)	URTWN_DEV(v, p, RTWN_CHIP_88E)
static const struct urtwn_type {
	struct usb_devno        dev;
	uint32_t		chip;
} urtwn_devs[] = {
	URTWN_DEV_8192CU(ABOCOM,	RTL8188CU_1),
	URTWN_DEV_8192CU(ABOCOM,	RTL8188CU_1),
	URTWN_DEV_8192CU(ABOCOM,	RTL8188CU_2),
	URTWN_DEV_8192CU(ABOCOM,	RTL8192CU),
	URTWN_DEV_8192CU(ASUS,		RTL8192CU),
	URTWN_DEV_8192CU(ASUS,		RTL8192CU_2),
	URTWN_DEV_8192CU(ASUS,		RTL8192CU_3),
	URTWN_DEV_8192CU(AZUREWAVE,	RTL8188CE_1),
	URTWN_DEV_8192CU(AZUREWAVE,	RTL8188CE_2),
	URTWN_DEV_8192CU(AZUREWAVE,	RTL8188CU),
	URTWN_DEV_8192CU(BELKIN,	F7D2102),
	URTWN_DEV_8192CU(BELKIN,	F9L1004V1),
	URTWN_DEV_8192CU(BELKIN,	RTL8188CU),
	URTWN_DEV_8192CU(BELKIN,	RTL8188CUS),
	URTWN_DEV_8192CU(BELKIN,	RTL8192CU),
	URTWN_DEV_8192CU(BELKIN,	RTL8192CU_1),
	URTWN_DEV_8192CU(BELKIN,	RTL8192CU_2),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_1),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_2),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_3),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_4),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_5),
	URTWN_DEV_8192CU(CHICONY,	RTL8188CUS_6),
	URTWN_DEV_8192CU(COMPARE,	RTL8192CU),
	URTWN_DEV_8192CU(COREGA,	RTL8192CU),
	URTWN_DEV_8192CU(DLINK,		DWA131B),
	URTWN_DEV_8192CU(DLINK,		RTL8188CU),
	URTWN_DEV_8192CU(DLINK,		RTL8192CU_1),
	URTWN_DEV_8192CU(DLINK,		RTL8192CU_2),
	URTWN_DEV_8192CU(DLINK,		RTL8192CU_3),
	URTWN_DEV_8192CU(DLINK,		RTL8192CU_4),
	URTWN_DEV_8192CU(EDIMAX,	EW7811UN),
	URTWN_DEV_8192CU(EDIMAX,	RTL8192CU),
	URTWN_DEV_8192CU(FEIXUN,	RTL8188CU),
	URTWN_DEV_8192CU(FEIXUN,	RTL8192CU),
	URTWN_DEV_8192CU(GUILLEMOT,	HWNUP150),
	URTWN_DEV_8192CU(GUILLEMOT,	RTL8192CU),
	URTWN_DEV_8192CU(HAWKING,	RTL8192CU),
	URTWN_DEV_8192CU(HAWKING,	RTL8192CU_2),
	URTWN_DEV_8192CU(HP3,		RTL8188CU),
	URTWN_DEV_8192CU(IODATA,	WNG150UM),
	URTWN_DEV_8192CU(IODATA,	RTL8192CU),
	URTWN_DEV_8192CU(NETGEAR,	N300MA),
	URTWN_DEV_8192CU(NETGEAR,	WNA1000M),
	URTWN_DEV_8192CU(NETGEAR,	WNA1000Mv2),
	URTWN_DEV_8192CU(NETGEAR,	RTL8192CU),
	URTWN_DEV_8192CU(NETGEAR4,	RTL8188CU),
	URTWN_DEV_8192CU(NETWEEN,	RTL8192CU),
	URTWN_DEV_8192CU(NOVATECH,	RTL8188CU),
	URTWN_DEV_8192CU(PLANEX2,	RTL8188CU_1),
	URTWN_DEV_8192CU(PLANEX2,	RTL8188CU_2),
	URTWN_DEV_8192CU(PLANEX2,	RTL8188CU_3),
	URTWN_DEV_8192CU(PLANEX2,	RTL8188CU_4),
	URTWN_DEV_8192CU(PLANEX2,	RTL8188CUS),
	URTWN_DEV_8192CU(PLANEX2,	RTL8192CU),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CE_0),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CE_1),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CTV),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_0),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_1),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_2),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_3),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_4),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_5),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CU_COMBO),
	URTWN_DEV_8192CU(REALTEK,	RTL8188CUS),
	URTWN_DEV_8192CU(REALTEK,	RTL8188RU),
	URTWN_DEV_8192CU(REALTEK,	RTL8188RU_2),
	URTWN_DEV_8192CU(REALTEK,	RTL8188RU_3),
	URTWN_DEV_8192CU(REALTEK,	RTL8191CU),
	URTWN_DEV_8192CU(REALTEK,	RTL8192CE),
	URTWN_DEV_8192CU(REALTEK,	RTL8192CE_VAU),
	URTWN_DEV_8192CU(REALTEK,	RTL8192CU),
	URTWN_DEV_8192CU(SITECOMEU,	RTL8188CU),
	URTWN_DEV_8192CU(SITECOMEU,	RTL8188CU_2),
	URTWN_DEV_8192CU(SITECOMEU,	RTL8192CU),
	URTWN_DEV_8192CU(SITECOMEU,	RTL8192CU_2),
	URTWN_DEV_8192CU(SITECOMEU,	WLA2100V2),
	URTWN_DEV_8192CU(TPLINK,	RTL8192CU),
	URTWN_DEV_8192CU(TRENDNET,	RTL8188CU),
	URTWN_DEV_8192CU(TRENDNET,	RTL8192CU),
	URTWN_DEV_8192CU(ZYXEL,		RTL8192CU),
	/* URTWN_RTL8188E */
	URTWN_DEV_8188EU(DLINK,		DWA123D1),
	URTWN_DEV_8188EU(DLINK,		DWA125D1),
	URTWN_DEV_8188EU(ELECOM,	WDC150SU2M),
	URTWN_DEV_8188EU(REALTEK,	RTL8188ETV),
	URTWN_DEV_8188EU(REALTEK,	RTL8188EU)
};

#define urtwn_lookup(v, p)	\
	((const struct urtwn_type *)usb_lookup(urtwn_devs, v, p))

int		urtwn_match(struct device *, void *, void *);
void		urtwn_attach(struct device *, struct device *, void *);
int		urtwn_detach(struct device *, int);
int		urtwn_open_pipes(struct urtwn_softc *);
void		urtwn_close_pipes(struct urtwn_softc *);
int		urtwn_alloc_rx_list(struct urtwn_softc *);
void		urtwn_free_rx_list(struct urtwn_softc *);
int		urtwn_alloc_tx_list(struct urtwn_softc *);
void		urtwn_free_tx_list(struct urtwn_softc *);
void		urtwn_task(void *);
void		urtwn_do_async(struct urtwn_softc *,
		    void (*)(struct urtwn_softc *, void *), void *, int);
void		urtwn_wait_async(void *); 
int		urtwn_write_region_1(struct urtwn_softc *, uint16_t, uint8_t *,
		    int);
void		urtwn_write_1(void *, uint16_t, uint8_t);
void		urtwn_write_2(void *, uint16_t, uint16_t);
void		urtwn_write_4(void *, uint16_t, uint32_t);
int		urtwn_read_region_1(struct urtwn_softc *, uint16_t, uint8_t *,
		    int);
uint8_t		urtwn_read_1(void *, uint16_t);
uint16_t	urtwn_read_2(void *, uint16_t);
uint32_t	urtwn_read_4(void *, uint16_t);
int		urtwn_llt_write(struct urtwn_softc *, uint32_t, uint32_t);
void		urtwn_calib_to(void *);
void		urtwn_calib_cb(struct urtwn_softc *, void *);
void		urtwn_scan_to(void *);
void		urtwn_next_scan(void *);
void		urtwn_cancel_scan(void *);
int		urtwn_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
void		urtwn_newstate_cb(struct urtwn_softc *, void *);
void		urtwn_updateslot(struct ieee80211com *);
void		urtwn_updateslot_cb(struct urtwn_softc *, void *);
void		urtwn_updateedca(struct ieee80211com *);
void		urtwn_updateedca_cb(struct urtwn_softc *, void *);
int		urtwn_set_key(struct ieee80211com *, struct ieee80211_node *,
		    struct ieee80211_key *);
void		urtwn_set_key_cb(struct urtwn_softc *, void *);
void		urtwn_delete_key(struct ieee80211com *,
		    struct ieee80211_node *, struct ieee80211_key *);
void		urtwn_delete_key_cb(struct urtwn_softc *, void *);
void		urtwn_rx_frame(struct urtwn_softc *, uint8_t *, int);
void		urtwn_rxeof(struct usbd_xfer *, void *,
		    usbd_status);
void		urtwn_txeof(struct usbd_xfer *, void *,
		    usbd_status);
int		urtwn_tx(void *, struct mbuf *, struct ieee80211_node *);
int		urtwn_ioctl(struct ifnet *, u_long, caddr_t);
int		urtwn_power_on(void *);
int		urtwn_alloc_buffers(void *);
int		urtwn_r92c_power_on(struct urtwn_softc *);
int		urtwn_r88e_power_on(struct urtwn_softc *);
int		urtwn_llt_init(struct urtwn_softc *, int);
int		urtwn_fw_loadpage(void *, int, uint8_t *, int);
int		urtwn_load_firmware(void *, u_char **, size_t *);
int		urtwn_dma_init(void *);
void		urtwn_mac_init(void *);
void		urtwn_bb_init(void *);
int		urtwn_init(void *);
void		urtwn_stop(void *);
int		urtwn_is_oactive(void *);
void		urtwn_next_calib(void *);
void		urtwn_cancel_calib(void *);

/* Aliases. */
#define	urtwn_bb_write	urtwn_write_4
#define urtwn_bb_read	urtwn_read_4

struct cfdriver urtwn_cd = {
	NULL, "urtwn", DV_IFNET
};

const struct cfattach urtwn_ca = {
	sizeof(struct urtwn_softc), urtwn_match, urtwn_attach, urtwn_detach
};

int
urtwn_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return ((urtwn_lookup(uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}

void
urtwn_attach(struct device *parent, struct device *self, void *aux)
{
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ifnet *ifp;
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;

	sc->sc_sc.chip = urtwn_lookup(uaa->vendor, uaa->product)->chip;

	usb_init_task(&sc->sc_task, urtwn_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, urtwn_scan_to, sc);
	timeout_set(&sc->calib_to, urtwn_calib_to, sc);
	if (urtwn_open_pipes(sc) != 0)
		return;

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 10;

	/* Attach the bus-agnostic driver. */
	sc->sc_sc.sc_ops.cookie = sc;
	sc->sc_sc.sc_ops.write_1 = urtwn_write_1;
	sc->sc_sc.sc_ops.write_2 = urtwn_write_2;
	sc->sc_sc.sc_ops.write_4 = urtwn_write_4;
	sc->sc_sc.sc_ops.read_1 = urtwn_read_1;
	sc->sc_sc.sc_ops.read_2 = urtwn_read_2;
	sc->sc_sc.sc_ops.read_4 = urtwn_read_4;
	sc->sc_sc.sc_ops.tx = urtwn_tx;
	sc->sc_sc.sc_ops.power_on = urtwn_power_on;
	sc->sc_sc.sc_ops.dma_init = urtwn_dma_init;
	sc->sc_sc.sc_ops.fw_loadpage = urtwn_fw_loadpage;
	sc->sc_sc.sc_ops.load_firmware = urtwn_load_firmware;
	sc->sc_sc.sc_ops.mac_init = urtwn_mac_init;
	sc->sc_sc.sc_ops.bb_init = urtwn_bb_init;
	sc->sc_sc.sc_ops.alloc_buffers = urtwn_alloc_buffers;
	sc->sc_sc.sc_ops.init = urtwn_init;
	sc->sc_sc.sc_ops.stop = urtwn_stop;
	sc->sc_sc.sc_ops.is_oactive = urtwn_is_oactive;
	sc->sc_sc.sc_ops.next_calib = urtwn_next_calib;
	sc->sc_sc.sc_ops.cancel_calib = urtwn_cancel_calib;
	sc->sc_sc.sc_ops.next_scan = urtwn_next_scan;
	sc->sc_sc.sc_ops.cancel_scan = urtwn_cancel_scan;
	sc->sc_sc.sc_ops.wait_async = urtwn_wait_async;
	if (rtwn_attach(&sc->sc_dev, &sc->sc_sc) != 0) {
		urtwn_close_pipes(sc);
		return;
	}

	/* ifp is now valid */
	ifp = &sc->sc_sc.sc_ic.ic_if;
	ifp->if_ioctl = urtwn_ioctl;

	ic->ic_updateslot = urtwn_updateslot;
	ic->ic_updateedca = urtwn_updateedca;
#ifdef notyet
	ic->ic_set_key = urtwn_set_key;
	ic->ic_delete_key = urtwn_delete_key;
#endif
	/* Override state transition machine. */
	ic->ic_newstate = urtwn_newstate;

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(URTWN_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(URTWN_TX_RADIOTAP_PRESENT);
#endif
}

int
urtwn_detach(struct device *self, int flags)
{
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	int s;

	s = splusb();

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->calib_to))
		timeout_del(&sc->calib_to);

	/* Wait for all async commands to complete. */
	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

	rtwn_detach(&sc->sc_sc, flags);

	/* Abort and close Tx/Rx pipes. */
	urtwn_close_pipes(sc);

	/* Free Tx/Rx buffers. */
	urtwn_free_tx_list(sc);
	urtwn_free_rx_list(sc);
	splx(s);

	return (0);
}

int
urtwn_open_pipes(struct urtwn_softc *sc)
{
	/* Bulk-out endpoints addresses (from highest to lowest prio). */
	uint8_t epaddr[R92C_MAX_EPOUT] = { 0, 0, 0 };
	uint8_t rx_no;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int i, error, nrx = 0;

	/* Find all bulk endpoints. */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL || UE_GET_XFERTYPE(ed->bmAttributes) != UE_BULK)
			continue;

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN) {
			rx_no = ed->bEndpointAddress;
			nrx++;
		} else {
			epaddr[sc->ntx] = ed->bEndpointAddress;
			sc->ntx++;
		}
	}
	if (nrx == 0) {
		printf("%s: %d: invalid number of Rx bulk pipes\n",
		    sc->sc_dev.dv_xname, nrx);
		return (EIO);
	}
	DPRINTF(("found %d bulk-out pipes\n", sc->ntx));
	if (sc->ntx == 0 || sc->ntx > R92C_MAX_EPOUT) {
		printf("%s: %d: invalid number of Tx bulk pipes\n",
		    sc->sc_dev.dv_xname, sc->ntx);
		return (EIO);
	}

	/* Open bulk-in pipe. */
	error = usbd_open_pipe(sc->sc_iface, rx_no, 0, &sc->rx_pipe);
	if (error != 0) {
		printf("%s: could not open Rx bulk pipe\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/* Open bulk-out pipes (up to 3). */
	for (i = 0; i < sc->ntx; i++) {
		error = usbd_open_pipe(sc->sc_iface, epaddr[i], 0,
		    &sc->tx_pipe[i]);
		if (error != 0) {
			printf("%s: could not open Tx bulk pipe 0x%02x\n",
			    sc->sc_dev.dv_xname, epaddr[i]);
			goto fail;
		}
	}

	/* Map 802.11 access categories to USB pipes. */
	sc->ac2idx[EDCA_AC_BK] =
	sc->ac2idx[EDCA_AC_BE] = (sc->ntx == 3) ? 2 : ((sc->ntx == 2) ? 1 : 0);
	sc->ac2idx[EDCA_AC_VI] = (sc->ntx == 3) ? 1 : 0;
	sc->ac2idx[EDCA_AC_VO] = 0;	/* Always use highest prio. */

	if (error != 0)
 fail:		urtwn_close_pipes(sc);
	return (error);
}

void
urtwn_close_pipes(struct urtwn_softc *sc)
{
	int i;

	/* Close Rx pipe. */
	if (sc->rx_pipe != NULL) {
		usbd_abort_pipe(sc->rx_pipe);
		usbd_close_pipe(sc->rx_pipe);
	}
	/* Close Tx pipes. */
	for (i = 0; i < R92C_MAX_EPOUT; i++) {
		if (sc->tx_pipe[i] == NULL)
			continue;
		usbd_abort_pipe(sc->tx_pipe[i]);
		usbd_close_pipe(sc->tx_pipe[i]);
	}
}

int
urtwn_alloc_rx_list(struct urtwn_softc *sc)
{
	struct urtwn_rx_data *data;
	int i, error = 0;

	for (i = 0; i < URTWN_RX_LIST_COUNT; i++) {
		data = &sc->rx_data[i];

		data->sc = sc;	/* Backpointer for callbacks. */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			break;
		}
		data->buf = usbd_alloc_buffer(data->xfer, URTWN_RXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			break;
		}
	}
	if (error != 0)
		urtwn_free_rx_list(sc);
	return (error);
}

void
urtwn_free_rx_list(struct urtwn_softc *sc)
{
	int i;

	/* NB: Caller must abort pipe first. */
	for (i = 0; i < URTWN_RX_LIST_COUNT; i++) {
		if (sc->rx_data[i].xfer != NULL)
			usbd_free_xfer(sc->rx_data[i].xfer);
		sc->rx_data[i].xfer = NULL;
	}
}

int
urtwn_alloc_tx_list(struct urtwn_softc *sc)
{
	struct urtwn_tx_data *data;
	int i, error = 0;

	TAILQ_INIT(&sc->tx_free_list);
	for (i = 0; i < URTWN_TX_LIST_COUNT; i++) {
		data = &sc->tx_data[i];

		data->sc = sc;	/* Backpointer for callbacks. */

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			break;
		}
		data->buf = usbd_alloc_buffer(data->xfer, URTWN_TXBUFSZ);
		if (data->buf == NULL) {
			printf("%s: could not allocate xfer buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			break;
		}
		/* Append this Tx buffer to our free list. */
		TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);
	}
	if (error != 0)
		urtwn_free_tx_list(sc);
	return (error);
}

void
urtwn_free_tx_list(struct urtwn_softc *sc)
{
	int i;

	/* NB: Caller must abort pipe first. */
	for (i = 0; i < URTWN_TX_LIST_COUNT; i++) {
		if (sc->tx_data[i].xfer != NULL)
			usbd_free_xfer(sc->tx_data[i].xfer);
		sc->tx_data[i].xfer = NULL;
	}
}

void
urtwn_task(void *arg)
{
	struct urtwn_softc *sc = arg;
	struct urtwn_host_cmd_ring *ring = &sc->cmdq;
	struct urtwn_host_cmd *cmd;
	int s;

	/* Process host commands. */
	s = splusb();
	while (ring->next != ring->cur) {
		cmd = &ring->cmd[ring->next];
		splx(s);
		/* Invoke callback. */
		cmd->cb(sc, cmd->data);
		s = splusb();
		ring->queued--;
		ring->next = (ring->next + 1) % URTWN_HOST_CMD_RING_COUNT;
	}
	splx(s);
}

void
urtwn_do_async(struct urtwn_softc *sc,
    void (*cb)(struct urtwn_softc *, void *), void *arg, int len)
{
	struct urtwn_host_cmd_ring *ring = &sc->cmdq;
	struct urtwn_host_cmd *cmd;
	int s;

	s = splusb();
	cmd = &ring->cmd[ring->cur];
	cmd->cb = cb;
	KASSERT(len <= sizeof(cmd->data));
	memcpy(cmd->data, arg, len);
	ring->cur = (ring->cur + 1) % URTWN_HOST_CMD_RING_COUNT;

	/* If there is no pending command already, schedule a task. */
	if (++ring->queued == 1)
		usb_add_task(sc->sc_udev, &sc->sc_task);
	splx(s);
}

void
urtwn_wait_async(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	int s;

	s = splusb();
	/* Wait for all queued asynchronous commands to complete. */
	usb_wait_task(sc->sc_udev, &sc->sc_task);
	splx(s);
}

int
urtwn_write_region_1(struct urtwn_softc *sc, uint16_t addr, uint8_t *buf,
    int len)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = R92C_REQ_REGS;
	USETW(req.wValue, addr);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(sc->sc_udev, &req, buf));
}

void
urtwn_write_1(void *cookie, uint16_t addr, uint8_t val)
{
	struct urtwn_softc *sc = cookie;

	urtwn_write_region_1(sc, addr, &val, 1);
}

void
urtwn_write_2(void *cookie, uint16_t addr, uint16_t val)
{
	struct urtwn_softc *sc = cookie;

	val = htole16(val);
	urtwn_write_region_1(sc, addr, (uint8_t *)&val, 2);
}

void
urtwn_write_4(void *cookie, uint16_t addr, uint32_t val)
{
	struct urtwn_softc *sc = cookie;

	val = htole32(val);
	urtwn_write_region_1(sc, addr, (uint8_t *)&val, 4);
}

int
urtwn_read_region_1(struct urtwn_softc *sc, uint16_t addr, uint8_t *buf,
    int len)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = R92C_REQ_REGS;
	USETW(req.wValue, addr);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(sc->sc_udev, &req, buf));
}

uint8_t
urtwn_read_1(void *cookie, uint16_t addr)
{
	struct urtwn_softc *sc = cookie;
	uint8_t val;

	if (urtwn_read_region_1(sc, addr, &val, 1) != 0)
		return (0xff);
	return (val);
}

uint16_t
urtwn_read_2(void *cookie, uint16_t addr)
{
	struct urtwn_softc *sc = cookie;
	uint16_t val;

	if (urtwn_read_region_1(sc, addr, (uint8_t *)&val, 2) != 0)
		return (0xffff);
	return (letoh16(val));
}

uint32_t
urtwn_read_4(void *cookie, uint16_t addr)
{
	struct urtwn_softc *sc = cookie;
	uint32_t val;

	if (urtwn_read_region_1(sc, addr, (uint8_t *)&val, 4) != 0)
		return (0xffffffff);
	return (letoh32(val));
}

int
urtwn_llt_write(struct urtwn_softc *sc, uint32_t addr, uint32_t data)
{
	int ntries;

	urtwn_write_4(sc, R92C_LLT_INIT,
	    SM(R92C_LLT_INIT_OP, R92C_LLT_INIT_OP_WRITE) |
	    SM(R92C_LLT_INIT_ADDR, addr) |
	    SM(R92C_LLT_INIT_DATA, data));
	/* Wait for write operation to complete. */
	for (ntries = 0; ntries < 20; ntries++) {
		if (MS(urtwn_read_4(sc, R92C_LLT_INIT), R92C_LLT_INIT_OP) ==
		    R92C_LLT_INIT_OP_NO_ACTIVE)
			return (0);
		DELAY(5);
	}
	return (ETIMEDOUT);
}

void
urtwn_calib_to(void *arg)
{
	struct urtwn_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	/* Do it in a process context. */
	urtwn_do_async(sc, urtwn_calib_cb, NULL, 0);

	usbd_ref_decr(sc->sc_udev);
}

/* ARGSUSED */
void
urtwn_calib_cb(struct urtwn_softc *sc, void *arg)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;
	int s;

	s = splnet();
	if (ic->ic_opmode == IEEE80211_M_STA) {
		ieee80211_amrr_choose(&sc->amrr, ic->ic_bss, &sc->amn);
	}
	splx(s);

	rtwn_calib(&sc->sc_sc);
}

void
urtwn_next_calib(void *cookie)
{
	struct urtwn_softc *sc = cookie;

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->calib_to, 2);
}

void
urtwn_cancel_calib(void *cookie)
{
	struct urtwn_softc *sc = cookie;

	if (timeout_initialized(&sc->calib_to))
		timeout_del(&sc->calib_to);
}

void
urtwn_scan_to(void *arg)
{
	struct urtwn_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);
	rtwn_next_scan(&sc->sc_sc);
	usbd_ref_decr(sc->sc_udev);
}

void
urtwn_next_scan(void *arg)
{
	struct urtwn_softc *sc = arg;

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_msec(&sc->scan_to, 200);
}

void
urtwn_cancel_scan(void *cookie)
{
	struct urtwn_softc *sc = cookie;

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
}

int
urtwn_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct rtwn_softc *sc_sc = ic->ic_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	struct urtwn_cmd_newstate cmd;

	/* Do it in a process context. */
	cmd.state = nstate;
	cmd.arg = arg;
	urtwn_do_async(sc, urtwn_newstate_cb, &cmd, sizeof(cmd));
	return (0);
}

void
urtwn_newstate_cb(struct urtwn_softc *sc, void *arg)
{
	struct urtwn_cmd_newstate *cmd = arg;
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;

	rtwn_newstate(ic, cmd->state, cmd->arg);
}

void
urtwn_updateslot(struct ieee80211com *ic)
{
	struct rtwn_softc *sc_sc = ic->ic_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;

	/* Do it in a process context. */
	urtwn_do_async(sc, urtwn_updateslot_cb, NULL, 0);
}

/* ARGSUSED */
void
urtwn_updateslot_cb(struct urtwn_softc *sc, void *arg)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;

	rtwn_updateslot(ic);
}

void
urtwn_updateedca(struct ieee80211com *ic)
{
	struct rtwn_softc *sc_sc = ic->ic_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;

	/* Do it in a process context. */
	urtwn_do_async(sc, urtwn_updateedca_cb, NULL, 0);
}

/* ARGSUSED */
void
urtwn_updateedca_cb(struct urtwn_softc *sc, void *arg)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;

	rtwn_updateedca(ic);
}

int
urtwn_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct rtwn_softc *sc_sc = ic->ic_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	struct urtwn_cmd_key cmd;

	/* Defer setting of WEP keys until interface is brought up. */
	if ((ic->ic_if.if_flags & (IFF_UP | IFF_RUNNING)) !=
	    (IFF_UP | IFF_RUNNING))
		return (0);

	/* Do it in a process context. */
	cmd.key = *k;
	cmd.ni = ni;
	urtwn_do_async(sc, urtwn_set_key_cb, &cmd, sizeof(cmd));
	return (0);
}

void
urtwn_set_key_cb(struct urtwn_softc *sc, void *arg)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;
	struct urtwn_cmd_key *cmd = arg;

	rtwn_set_key(ic, cmd->ni, &cmd->key);
}

void
urtwn_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	struct rtwn_softc *sc_sc = ic->ic_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	struct urtwn_cmd_key cmd;

	if (!(ic->ic_if.if_flags & IFF_RUNNING) ||
	    ic->ic_state != IEEE80211_S_RUN)
		return;	/* Nothing to do. */

	/* Do it in a process context. */
	cmd.key = *k;
	cmd.ni = ni;
	urtwn_do_async(sc, urtwn_delete_key_cb, &cmd, sizeof(cmd));
}

void
urtwn_delete_key_cb(struct urtwn_softc *sc, void *arg)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;
	struct urtwn_cmd_key *cmd = arg;

	rtwn_delete_key(ic, cmd->ni, &cmd->key);
}

void
urtwn_rx_frame(struct urtwn_softc *sc, uint8_t *buf, int pktlen)
{
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_frame *wh;
	struct ieee80211_node *ni;
	struct r92c_rx_desc_usb *rxd;
	uint32_t rxdw0, rxdw3;
	struct mbuf *m;
	uint8_t rate;
	int8_t rssi = 0;
	int s, infosz;

	rxd = (struct r92c_rx_desc_usb *)buf;
	rxdw0 = letoh32(rxd->rxdw0);
	rxdw3 = letoh32(rxd->rxdw3);

	if (__predict_false(rxdw0 & (R92C_RXDW0_CRCERR | R92C_RXDW0_ICVERR))) {
		/*
		 * This should not happen since we setup our Rx filter
		 * to not receive these frames.
		 */
		ifp->if_ierrors++;
		return;
	}
	if (__predict_false(pktlen < sizeof(*wh) || pktlen > MCLBYTES)) {
		ifp->if_ierrors++;
		return;
	}

	rate = MS(rxdw3, R92C_RXDW3_RATE);
	infosz = MS(rxdw0, R92C_RXDW0_INFOSZ) * 8;

	/* Get RSSI from PHY status descriptor if present. */
	if (infosz != 0 && (rxdw0 & R92C_RXDW0_PHYST)) {
		rssi = rtwn_get_rssi(&sc->sc_sc, rate, &rxd[1]);
		/* Update our average RSSI. */
		rtwn_update_avgrssi(&sc->sc_sc, rate, rssi);
	}

	DPRINTFN(5, ("Rx frame len=%d rate=%d infosz=%d rssi=%d\n",
	    pktlen, rate, infosz, rssi));

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (__predict_false(m == NULL)) {
		ifp->if_ierrors++;
		return;
	}
	if (pktlen > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if (__predict_false(!(m->m_flags & M_EXT))) {
			ifp->if_ierrors++;
			m_freem(m);
			return;
		}
	}
	/* Finalize mbuf. */
	wh = (struct ieee80211_frame *)((uint8_t *)&rxd[1] + infosz);
	memcpy(mtod(m, uint8_t *), wh, pktlen);
	m->m_pkthdr.len = m->m_len = pktlen;

	s = splnet();
#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct urtwn_rx_radiotap_header *tap = &sc->sc_rxtap;
		struct mbuf mb;

		tap->wr_flags = 0;
		/* Map HW rate index to 802.11 rate. */
		if (!(rxdw3 & R92C_RXDW3_HT)) {
			switch (rate) {
			/* CCK. */
			case  0: tap->wr_rate =   2; break;
			case  1: tap->wr_rate =   4; break;
			case  2: tap->wr_rate =  11; break;
			case  3: tap->wr_rate =  22; break;
			/* OFDM. */
			case  4: tap->wr_rate =  12; break;
			case  5: tap->wr_rate =  18; break;
			case  6: tap->wr_rate =  24; break;
			case  7: tap->wr_rate =  36; break;
			case  8: tap->wr_rate =  48; break;
			case  9: tap->wr_rate =  72; break;
			case 10: tap->wr_rate =  96; break;
			case 11: tap->wr_rate = 108; break;
			}
			if (rate <= 3)
				tap->wr_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;
		} else if (rate >= 12) {	/* MCS0~15. */
			/* Bit 7 set means HT MCS instead of rate. */
			tap->wr_rate = 0x80 | (rate - 12);
		}
		tap->wr_dbm_antsignal = rssi;
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	ni = ieee80211_find_rxnode(ic, wh);
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = rssi;
	rxi.rxi_tstamp = 0;	/* Unused. */
	ieee80211_input(ifp, m, ni, &rxi);
	/* Node is no longer needed. */
	ieee80211_release_node(ic, ni);
	splx(s);
}

void
urtwn_rxeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct urtwn_rx_data *data = priv;
	struct urtwn_softc *sc = data->sc;
	struct r92c_rx_desc_usb *rxd;
	uint32_t rxdw0;
	uint8_t *buf;
	int len, totlen, pktlen, infosz, npkts, error;

	if (__predict_false(status != USBD_NORMAL_COMPLETION)) {
		DPRINTF(("RX status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->rx_pipe);
		if (status != USBD_CANCELLED)
			goto resubmit;
		return;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (__predict_false(len < sizeof(*rxd))) {
		DPRINTF(("xfer too short %d\n", len));
		goto resubmit;
	}
	buf = data->buf;

	/* Get the number of encapsulated frames. */
	rxd = (struct r92c_rx_desc_usb *)buf;
	npkts = MS(letoh32(rxd->rxdw2), R92C_RXDW2_PKTCNT);
	DPRINTFN(4, ("Rx %d frames in one chunk\n", npkts));

	if (sc->sc_sc.chip & RTWN_CHIP_88E) {
		int ntries, type;
		struct r88e_tx_rpt_ccx *rxstat;

		type = MS(letoh32(rxd->rxdw3), R88E_RXDW3_RPT);

		if (type == R88E_RXDW3_RPT_TX1) {
			buf += sizeof(struct r92c_rx_desc_usb);
			rxstat = (struct r88e_tx_rpt_ccx *)buf;
			ntries = MS(letoh32(rxstat->rptb2),
			    R88E_RPTB2_RETRY_CNT);

			if (rxstat->rptb1 & R88E_RPTB1_PKT_OK)
				sc->amn.amn_txcnt++;
			if (ntries > 0)
				sc->amn.amn_retrycnt++;

			goto resubmit;
		}
	}

	/* Process all of them. */
	while (npkts-- > 0) {
		if (__predict_false(len < sizeof(*rxd)))
			break;
		rxd = (struct r92c_rx_desc_usb *)buf;
		rxdw0 = letoh32(rxd->rxdw0);

		pktlen = MS(rxdw0, R92C_RXDW0_PKTLEN);
		if (__predict_false(pktlen == 0))
			break;

		infosz = MS(rxdw0, R92C_RXDW0_INFOSZ) * 8;

		/* Make sure everything fits in xfer. */
		totlen = sizeof(*rxd) + infosz + pktlen;
		if (__predict_false(totlen > len))
			break;

		/* Process 802.11 frame. */
		urtwn_rx_frame(sc, buf, pktlen);

		/* Next chunk is 128-byte aligned. */
		totlen = (totlen + 127) & ~127;
		buf += totlen;
		len -= totlen;
	}

 resubmit:
	/* Setup a new transfer. */
	usbd_setup_xfer(xfer, sc->rx_pipe, data, data->buf, URTWN_RXBUFSZ,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT, urtwn_rxeof);
	error = usbd_transfer(data->xfer);
	if (error != 0 && error != USBD_IN_PROGRESS)
		DPRINTF(("could not set up new transfer: %d\n", error));
}

void
urtwn_txeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct urtwn_tx_data *data = priv;
	struct urtwn_softc *sc = data->sc;
	struct ifnet *ifp = &sc->sc_sc.sc_ic.ic_if;
	int s;

	s = splnet();
	/* Put this Tx buffer back to our free list. */
	TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);

	if (__predict_false(status != USBD_NORMAL_COMPLETION)) {
		DPRINTF(("TX status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(data->pipe);
		ifp->if_oerrors++;
		splx(s);
		return;
	}
	sc->sc_sc.sc_tx_timer = 0;

	/* We just released a Tx buffer, notify Tx. */
	if (ifq_is_oactive(&ifp->if_snd)) {
		ifq_clr_oactive(&ifp->if_snd);
		rtwn_start(ifp);
	}
	splx(s);
}

int
urtwn_tx(void *cookie, struct mbuf *m, struct ieee80211_node *ni)
{
	struct urtwn_softc *sc = cookie;
	struct ieee80211com *ic = &sc->sc_sc.sc_ic;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k = NULL;
	struct urtwn_tx_data *data;
	struct r92c_tx_desc_usb *txd;
	struct usbd_pipe *pipe;
	uint16_t qos, sum;
	uint8_t raid, type, tid, qid;
	int i, hasqos, xferlen, error;

	wh = mtod(m, struct ieee80211_frame *);
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);
		if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
			return (ENOBUFS);
		wh = mtod(m, struct ieee80211_frame *);
	}

	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
		qid = ieee80211_up_to_ac(ic, tid);
	} else if (type != IEEE80211_FC0_TYPE_DATA) {
		/* Use AC VO for management frames. */
		qid = EDCA_AC_VO;
	} else
		qid = EDCA_AC_BE;

	/* Get the USB pipe to use for this AC. */
	pipe = sc->tx_pipe[sc->ac2idx[qid]];

	/* Grab a Tx buffer from our free list. */
	data = TAILQ_FIRST(&sc->tx_free_list);
	TAILQ_REMOVE(&sc->tx_free_list, data, next);

	/* Fill Tx descriptor. */
	txd = (struct r92c_tx_desc_usb *)data->buf;
	memset(txd, 0, sizeof(*txd));

	txd->txdw0 |= htole32(
	    SM(R92C_TXDW0_PKTLEN, m->m_pkthdr.len) |
	    SM(R92C_TXDW0_OFFSET, sizeof(*txd)) |
	    R92C_TXDW0_OWN | R92C_TXDW0_FSG | R92C_TXDW0_LSG);
	if (IEEE80211_IS_MULTICAST(wh->i_addr1))
		txd->txdw0 |= htole32(R92C_TXDW0_BMCAST);

#ifdef notyet
	if (k != NULL) {
		switch (k->k_cipher) {
		case IEEE80211_CIPHER_WEP40:
		case IEEE80211_CIPHER_WEP104:
		case IEEE80211_CIPHER_TKIP:
			cipher = R92C_TXDW1_CIPHER_RC4;
			break;
		case IEEE80211_CIPHER_CCMP:
			cipher = R92C_TXDW1_CIPHER_AES;
			break;
		default:
			cipher = R92C_TXDW1_CIPHER_NONE;
		}
		txd->txdw1 |= htole32(SM(R92C_TXDW1_CIPHER, cipher));
	}
#endif
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    type == IEEE80211_FC0_TYPE_DATA) {
		if (ic->ic_curmode == IEEE80211_MODE_11B ||
		    (sc->sc_sc.sc_flags & RTWN_FLAG_FORCE_RAID_11B))
			raid = R92C_RAID_11B;
		else
			raid = R92C_RAID_11BG;
		if (sc->sc_sc.chip & RTWN_CHIP_88E) {
			txd->txdw1 |= htole32(
			    SM(R88E_TXDW1_MACID, R92C_MACID_BSS) |
			    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |
			    SM(R92C_TXDW1_RAID, raid));
			txd->txdw2 |= htole32(R88E_TXDW2_AGGBK);
			/* Request TX status report for AMRR */
			txd->txdw2 |= htole32(R92C_TXDW2_CCX_RPT);
		} else {
			txd->txdw1 |= htole32(
			    SM(R92C_TXDW1_MACID, R92C_MACID_BSS) |
			    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |
			    SM(R92C_TXDW1_RAID, raid) | R92C_TXDW1_AGGBK);
		}

		if (m->m_pkthdr.len + IEEE80211_CRC_LEN > ic->ic_rtsthreshold) {
			txd->txdw4 |= htole32(R92C_TXDW4_RTSEN |
			    R92C_TXDW4_HWRTSEN);
		} else if (ic->ic_flags & IEEE80211_F_USEPROT) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY) {
				txd->txdw4 |= htole32(R92C_TXDW4_CTS2SELF |
				    R92C_TXDW4_HWRTSEN);
			} else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS) {
				txd->txdw4 |= htole32(R92C_TXDW4_RTSEN |
				    R92C_TXDW4_HWRTSEN);
			}
		}
		txd->txdw5 |= htole32(0x0001ff00);

		if (sc->sc_sc.chip & RTWN_CHIP_88E) {
			/* Use AMRR */
			txd->txdw4 |= htole32(R92C_TXDW4_DRVRATE);
			txd->txdw4 |= htole32(SM(R92C_TXDW4_RTSRATE,
			    ni->ni_txrate));
			txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE,
			    ni->ni_txrate));
		} else {
			/* Send RTS at OFDM24 and data at OFDM54. */
			txd->txdw4 |= htole32(SM(R92C_TXDW4_RTSRATE, 8));
			txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 11));
		}
	} else {
		txd->txdw1 |= htole32(
		    SM(R92C_TXDW1_MACID, 0) |
		    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_MGNT) |
		    SM(R92C_TXDW1_RAID, R92C_RAID_11B));

		/* Force CCK1. */
		txd->txdw4 |= htole32(R92C_TXDW4_DRVRATE);
		txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 0));
	}
	/* Set sequence number (already little endian). */
	txd->txdseq |= *(uint16_t *)wh->i_seq;

	if (!hasqos) {
		/* Use HW sequence numbering for non-QoS frames. */
		txd->txdw4  |= htole32(R92C_TXDW4_HWSEQ);
		txd->txdseq |= htole16(0x8000);		/* WTF? */
	} else
		txd->txdw4 |= htole32(R92C_TXDW4_QOS);

	/* Compute Tx descriptor checksum. */
	sum = 0;
	for (i = 0; i < sizeof(*txd) / 2; i++)
		sum ^= ((uint16_t *)txd)[i];
	txd->txdsum = sum;	/* NB: already little endian. */

#if NBPFILTER > 0
	if (__predict_false(sc->sc_drvbpf != NULL)) {
		struct urtwn_tx_radiotap_header *tap = &sc->sc_txtap;
		struct mbuf mb;

		tap->wt_flags = 0;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	xferlen = sizeof(*txd) + m->m_pkthdr.len;
	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&txd[1]);
	m_freem(m);

	data->pipe = pipe;
	usbd_setup_xfer(data->xfer, pipe, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, URTWN_TX_TIMEOUT,
	    urtwn_txeof);
	error = usbd_transfer(data->xfer);
	if (__predict_false(error != USBD_IN_PROGRESS && error != 0)) {
		/* Put this Tx buffer back to our free list. */
		TAILQ_INSERT_TAIL(&sc->tx_free_list, data, next);
		return (error);
	}
	ieee80211_release_node(ic, ni);
	return (0);
}

int
urtwn_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rtwn_softc *sc_sc = ifp->if_softc;
	struct device *self = sc_sc->sc_pdev;
	struct urtwn_softc *sc = (struct urtwn_softc *)self;
	int error;

	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);
	error = rtwn_ioctl(ifp, cmd, data);
	usbd_ref_decr(sc->sc_udev);

	return (error);
}

int
urtwn_r92c_power_on(struct urtwn_softc *sc)
{
	uint32_t reg;
	int ntries;

	/* Wait for autoload done bit. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (urtwn_read_1(sc, R92C_APS_FSMCO) & R92C_APS_FSMCO_PFM_ALDN)
			break;
		DELAY(5);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for chip autoload\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* Unlock ISO/CLK/Power control register. */
	urtwn_write_1(sc, R92C_RSV_CTRL, 0);
	/* Move SPS into PWM mode. */
	urtwn_write_1(sc, R92C_SPS0_CTRL, 0x2b);
	DELAY(100);

	reg = urtwn_read_1(sc, R92C_LDOV12D_CTRL);
	if (!(reg & R92C_LDOV12D_CTRL_LDV12_EN)) {
		urtwn_write_1(sc, R92C_LDOV12D_CTRL,
		    reg | R92C_LDOV12D_CTRL_LDV12_EN);
		DELAY(100);
		urtwn_write_1(sc, R92C_SYS_ISO_CTRL,
		    urtwn_read_1(sc, R92C_SYS_ISO_CTRL) &
		    ~R92C_SYS_ISO_CTRL_MD2PP);
	}

	/* Auto enable WLAN. */
	urtwn_write_2(sc, R92C_APS_FSMCO,
	    urtwn_read_2(sc, R92C_APS_FSMCO) | R92C_APS_FSMCO_APFM_ONMAC);
	for (ntries = 0; ntries < 1000; ntries++) {
		if (!(urtwn_read_2(sc, R92C_APS_FSMCO) &
		    R92C_APS_FSMCO_APFM_ONMAC))
			break;
		DELAY(5);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for MAC auto ON\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* Enable radio, GPIO and LED functions. */
	urtwn_write_2(sc, R92C_APS_FSMCO,
	    R92C_APS_FSMCO_AFSM_HSUS |
	    R92C_APS_FSMCO_PDN_EN |
	    R92C_APS_FSMCO_PFM_ALDN);
	/* Release RF digital isolation. */
	urtwn_write_2(sc, R92C_SYS_ISO_CTRL,
	    urtwn_read_2(sc, R92C_SYS_ISO_CTRL) & ~R92C_SYS_ISO_CTRL_DIOR);

	/* Initialize MAC. */
	urtwn_write_1(sc, R92C_APSD_CTRL,
	    urtwn_read_1(sc, R92C_APSD_CTRL) & ~R92C_APSD_CTRL_OFF);
	for (ntries = 0; ntries < 200; ntries++) {
		if (!(urtwn_read_1(sc, R92C_APSD_CTRL) &
		    R92C_APSD_CTRL_OFF_STATUS))
			break;
		DELAY(5);
	}
	if (ntries == 200) {
		printf("%s: timeout waiting for MAC initialization\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* Enable MAC DMA/WMAC/SCHEDULE/SEC blocks. */
	reg = urtwn_read_2(sc, R92C_CR);
	reg |= R92C_CR_HCI_TXDMA_EN | R92C_CR_HCI_RXDMA_EN |
	    R92C_CR_TXDMA_EN | R92C_CR_RXDMA_EN | R92C_CR_PROTOCOL_EN |
	    R92C_CR_SCHEDULE_EN | R92C_CR_MACTXEN | R92C_CR_MACRXEN |
	    R92C_CR_ENSEC;
	urtwn_write_2(sc, R92C_CR, reg);

	urtwn_write_1(sc, 0xfe10, 0x19);
	return (0);
}

int
urtwn_r88e_power_on(struct urtwn_softc *sc)
{
	uint32_t reg;
	int ntries;

	/* Wait for power ready bit. */
	for (ntries = 0; ntries < 5000; ntries++) {
		if (urtwn_read_4(sc, R92C_APS_FSMCO) & R92C_APS_FSMCO_SUS_HOST)
			break;
		DELAY(10);
	}
	if (ntries == 5000) {
		printf("%s: timeout waiting for chip power up\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* Reset BB. */
	urtwn_write_1(sc, R92C_SYS_FUNC_EN,
	    urtwn_read_1(sc, R92C_SYS_FUNC_EN) & ~(R92C_SYS_FUNC_EN_BBRSTB |
	    R92C_SYS_FUNC_EN_BB_GLB_RST));

	urtwn_write_1(sc, R92C_AFE_XTAL_CTRL + 2,
	    urtwn_read_1(sc, R92C_AFE_XTAL_CTRL + 2) | 0x80);

	/* Disable HWPDN. */
	urtwn_write_2(sc, R92C_APS_FSMCO,
	    urtwn_read_2(sc, R92C_APS_FSMCO) & ~R92C_APS_FSMCO_APDM_HPDN);
	/* Disable WL suspend. */
	urtwn_write_2(sc, R92C_APS_FSMCO,
	    urtwn_read_2(sc, R92C_APS_FSMCO) &
	    ~(R92C_APS_FSMCO_AFSM_HSUS | R92C_APS_FSMCO_AFSM_PCIE));

	/* Auto enable WLAN. */
	urtwn_write_2(sc, R92C_APS_FSMCO,
	    urtwn_read_2(sc, R92C_APS_FSMCO) | R92C_APS_FSMCO_APFM_ONMAC);
	for (ntries = 0; ntries < 5000; ntries++) {
		if (!(urtwn_read_2(sc, R92C_APS_FSMCO) &
		    R92C_APS_FSMCO_APFM_ONMAC))
			break;
		DELAY(10);
	}
	if (ntries == 5000) {
		printf("%s: timeout waiting for MAC auto ON\n",
		    sc->sc_dev.dv_xname);
		return (ETIMEDOUT);
	}

	/* Enable LDO normal mode. */
	urtwn_write_1(sc, R92C_LPLDO_CTRL,
	    urtwn_read_1(sc, R92C_LPLDO_CTRL) & ~0x10);

	/* Enable MAC DMA/WMAC/SCHEDULE/SEC blocks. */
	urtwn_write_2(sc, R92C_CR, 0);
	reg = urtwn_read_2(sc, R92C_CR);
	reg |= R92C_CR_HCI_TXDMA_EN | R92C_CR_HCI_RXDMA_EN |
	    R92C_CR_TXDMA_EN | R92C_CR_RXDMA_EN | R92C_CR_PROTOCOL_EN |
	    R92C_CR_SCHEDULE_EN | R92C_CR_ENSEC | R92C_CR_CALTMR_EN;
	urtwn_write_2(sc, R92C_CR, reg);
	return (0);
}

int
urtwn_llt_init(struct urtwn_softc *sc, int page_count)
{
	int i, error, pktbuf_count;

	pktbuf_count = (sc->sc_sc.chip & RTWN_CHIP_88E) ?
	    R88E_TXPKTBUF_COUNT : R92C_TXPKTBUF_COUNT;

	/* Reserve pages [0; page_count]. */
	for (i = 0; i < page_count; i++) {
		if ((error = urtwn_llt_write(sc, i, i + 1)) != 0)
			return (error);
	}
	/* NB: 0xff indicates end-of-list. */
	if ((error = urtwn_llt_write(sc, i, 0xff)) != 0)
		return (error);
	/*
	 * Use pages [page_count + 1; pktbuf_count - 1]
	 * as ring buffer.
	 */
	for (++i; i < pktbuf_count - 1; i++) {
		if ((error = urtwn_llt_write(sc, i, i + 1)) != 0)
			return (error);
	}
	/* Make the last page point to the beginning of the ring buffer. */
	error = urtwn_llt_write(sc, i, page_count + 1);
	return (error);
}

int
urtwn_fw_loadpage(void *cookie, int page, uint8_t *buf, int len)
{
	struct urtwn_softc *sc = cookie;
	uint32_t reg;
	int off, mlen, error = 0;

	reg = urtwn_read_4(sc, R92C_MCUFWDL);
	reg = RW(reg, R92C_MCUFWDL_PAGE, page);
	urtwn_write_4(sc, R92C_MCUFWDL, reg);

	off = R92C_FW_START_ADDR;
	while (len > 0) {
		if (len > 196)
			mlen = 196;
		else if (len > 4)
			mlen = 4;
		else
			mlen = 1;
		error = urtwn_write_region_1(sc, off, buf, mlen);
		if (error != 0)
			break;
		off += mlen;
		buf += mlen;
		len -= mlen;
	}
	return (error);
}

int
urtwn_load_firmware(void *cookie, u_char **fw, size_t *len)
{
	struct urtwn_softc *sc = cookie;
	const char *name;
	int error;

	if (sc->sc_sc.chip & RTWN_CHIP_88E)
		name = "urtwn-rtl8188eufw";
	else if ((sc->sc_sc.chip & (RTWN_CHIP_UMC_A_CUT | RTWN_CHIP_92C)) ==
		    RTWN_CHIP_UMC_A_CUT)
		name = "urtwn-rtl8192cfwU";
	else
		name = "urtwn-rtl8192cfwT";

	error = loadfirmware(name, fw, len);
	if (error)
		printf("%s: could not read firmware %s (error %d)\n",
		    sc->sc_dev.dv_xname, name, error);
	return (error);
}

int
urtwn_dma_init(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	uint32_t reg;
	uint16_t dmasize;
	int hqpages, lqpages, nqpages, pagecnt, boundary;
	int error, hashq, haslq, hasnq;

	/* Default initialization of chipset values. */
	if (sc->sc_sc.chip & RTWN_CHIP_88E) {
		hqpages = R88E_HQ_NPAGES;
		lqpages = R88E_LQ_NPAGES;
		nqpages = R88E_NQ_NPAGES;
		pagecnt = R88E_TX_PAGE_COUNT;
		boundary = R88E_TX_PAGE_BOUNDARY;
		dmasize = R88E_MAX_RX_DMA_SIZE;
	} else {
		hqpages = R92C_HQ_NPAGES;
		lqpages = R92C_LQ_NPAGES;
		nqpages = R92C_NQ_NPAGES;
		pagecnt = R92C_TX_PAGE_COUNT;
		boundary = R92C_TX_PAGE_BOUNDARY;
		dmasize = R92C_MAX_RX_DMA_SIZE;
	}

	/* Initialize LLT table. */
	error = urtwn_llt_init(sc, pagecnt);
	if (error != 0)
		return (error);

	/* Get Tx queues to USB endpoints mapping. */
	hashq = hasnq = haslq = 0;
	switch (sc->ntx) {
	case 3:
		haslq = 1;
		pagecnt -= lqpages;
		/* FALLTHROUGH */
	case 2:
		hasnq = 1;
		pagecnt -= nqpages;
		/* FALLTHROUGH */
	case 1:
		hashq = 1;
		pagecnt -= hqpages;
		break;
	}

	/* Set number of pages for normal priority queue. */
	urtwn_write_1(sc, R92C_RQPN_NPQ, hasnq ? nqpages : 0);
	urtwn_write_4(sc, R92C_RQPN,
	    /* Set number of pages for public queue. */
	    SM(R92C_RQPN_PUBQ, pagecnt) |
	    /* Set number of pages for high priority queue. */
	    SM(R92C_RQPN_HPQ, hashq ? hqpages : 0) |
	    /* Set number of pages for low priority queue. */
	    SM(R92C_RQPN_LPQ, haslq ? lqpages : 0) |
	    /* Load values. */
	    R92C_RQPN_LD);

	urtwn_write_1(sc, R92C_TXPKTBUF_BCNQ_BDNY, boundary);
	urtwn_write_1(sc, R92C_TXPKTBUF_MGQ_BDNY, boundary);
	urtwn_write_1(sc, R92C_TXPKTBUF_WMAC_LBK_BF_HD, boundary);
	urtwn_write_1(sc, R92C_TRXFF_BNDY, boundary);
	urtwn_write_1(sc, R92C_TDECTRL + 1, boundary);

	/* Set queue to USB pipe mapping. */
	reg = urtwn_read_2(sc, R92C_TRXDMA_CTRL);
	reg &= ~R92C_TRXDMA_CTRL_QMAP_M;
	if (haslq)
		reg |= R92C_TRXDMA_CTRL_QMAP_3EP;
	else if (hashq) {
		if (!hasnq)
			reg |= R92C_TRXDMA_CTRL_QMAP_HQ;
		else
			reg |= R92C_TRXDMA_CTRL_QMAP_HQ_NQ;
	}
	urtwn_write_2(sc, R92C_TRXDMA_CTRL, reg);

	/* Set Tx/Rx transfer page boundary. */
	urtwn_write_2(sc, R92C_TRXFF_BNDY + 2, dmasize - 1);

	/* Set Tx/Rx transfer page size. */
	urtwn_write_1(sc, R92C_PBP,
	    SM(R92C_PBP_PSRX, R92C_PBP_128) |
	    SM(R92C_PBP_PSTX, R92C_PBP_128));
	return (error);
}

void
urtwn_mac_init(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	int i;

	/* Write MAC initialization values. */
	if (sc->sc_sc.chip & RTWN_CHIP_88E) {
		for (i = 0; i < nitems(rtl8188eu_mac); i++) {
			urtwn_write_1(sc, rtl8188eu_mac[i].reg,
			    rtl8188eu_mac[i].val);
		}
		urtwn_write_1(sc, R92C_MAX_AGGR_NUM, 0x07);
	} else {
		for (i = 0; i < nitems(rtl8192cu_mac); i++)
			urtwn_write_1(sc, rtl8192cu_mac[i].reg,
			    rtl8192cu_mac[i].val);
	}
}

void
urtwn_bb_init(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	const struct r92c_bb_prog *prog;
	uint32_t reg;
	uint8_t xtal;
	int i;

	/* Enable BB and RF. */
	urtwn_write_2(sc, R92C_SYS_FUNC_EN,
	    urtwn_read_2(sc, R92C_SYS_FUNC_EN) |
	    R92C_SYS_FUNC_EN_BBRSTB | R92C_SYS_FUNC_EN_BB_GLB_RST |
	    R92C_SYS_FUNC_EN_DIO_RF);

	if (!(sc->sc_sc.chip & RTWN_CHIP_88E))
		urtwn_write_2(sc, R92C_AFE_PLL_CTRL, 0xdb83);

	urtwn_write_1(sc, R92C_RF_CTRL,
	    R92C_RF_CTRL_EN | R92C_RF_CTRL_RSTB | R92C_RF_CTRL_SDMRSTB);
	urtwn_write_1(sc, R92C_SYS_FUNC_EN,
	    R92C_SYS_FUNC_EN_USBA | R92C_SYS_FUNC_EN_USBD |
	    R92C_SYS_FUNC_EN_BB_GLB_RST | R92C_SYS_FUNC_EN_BBRSTB);

	if (!(sc->sc_sc.chip & RTWN_CHIP_88E)) {
		urtwn_write_1(sc, R92C_LDOHCI12_CTRL, 0x0f);
		urtwn_write_1(sc, 0x15, 0xe9);
		urtwn_write_1(sc, R92C_AFE_XTAL_CTRL + 1, 0x80);
	}

	/* Select BB programming based on board type. */
	if (sc->sc_sc.chip & RTWN_CHIP_88E)
		prog = &rtl8188eu_bb_prog;
	else if (!(sc->sc_sc.chip & RTWN_CHIP_92C)) {
		if (sc->sc_sc.board_type == R92C_BOARD_TYPE_MINICARD)
			prog = &rtl8188ce_bb_prog;
		else if (sc->sc_sc.board_type == R92C_BOARD_TYPE_HIGHPA)
			prog = &rtl8188ru_bb_prog;
		else
			prog = &rtl8188cu_bb_prog;
	} else {
		if (sc->sc_sc.board_type == R92C_BOARD_TYPE_MINICARD)
			prog = &rtl8192ce_bb_prog;
		else
			prog = &rtl8192cu_bb_prog;
	}
	/* Write BB initialization values. */
	for (i = 0; i < prog->count; i++) {
		urtwn_bb_write(sc, prog->regs[i], prog->vals[i]);
		DELAY(1);
	}

	if (sc->sc_sc.chip & RTWN_CHIP_92C_1T2R) {
		/* 8192C 1T only configuration. */
		reg = urtwn_bb_read(sc, R92C_FPGA0_TXINFO);
		reg = (reg & ~0x00000003) | 0x2;
		urtwn_bb_write(sc, R92C_FPGA0_TXINFO, reg);

		reg = urtwn_bb_read(sc, R92C_FPGA1_TXINFO);
		reg = (reg & ~0x00300033) | 0x00200022;
		urtwn_bb_write(sc, R92C_FPGA1_TXINFO, reg);

		reg = urtwn_bb_read(sc, R92C_CCK0_AFESETTING);
		reg = (reg & ~0xff000000) | 0x45 << 24;
		urtwn_bb_write(sc, R92C_CCK0_AFESETTING, reg);

		reg = urtwn_bb_read(sc, R92C_OFDM0_TRXPATHENA);
		reg = (reg & ~0x000000ff) | 0x23;
		urtwn_bb_write(sc, R92C_OFDM0_TRXPATHENA, reg);

		reg = urtwn_bb_read(sc, R92C_OFDM0_AGCPARAM1);
		reg = (reg & ~0x00000030) | 1 << 4;
		urtwn_bb_write(sc, R92C_OFDM0_AGCPARAM1, reg);

		reg = urtwn_bb_read(sc, 0xe74);
		reg = (reg & ~0x0c000000) | 2 << 26;
		urtwn_bb_write(sc, 0xe74, reg);
		reg = urtwn_bb_read(sc, 0xe78);
		reg = (reg & ~0x0c000000) | 2 << 26;
		urtwn_bb_write(sc, 0xe78, reg);
		reg = urtwn_bb_read(sc, 0xe7c);
		reg = (reg & ~0x0c000000) | 2 << 26;
		urtwn_bb_write(sc, 0xe7c, reg);
		reg = urtwn_bb_read(sc, 0xe80);
		reg = (reg & ~0x0c000000) | 2 << 26;
		urtwn_bb_write(sc, 0xe80, reg);
		reg = urtwn_bb_read(sc, 0xe88);
		reg = (reg & ~0x0c000000) | 2 << 26;
		urtwn_bb_write(sc, 0xe88, reg);
	}

	/* Write AGC values. */
	for (i = 0; i < prog->agccount; i++) {
		urtwn_bb_write(sc, R92C_OFDM0_AGCRSSITABLE,
		    prog->agcvals[i]);
		DELAY(1);
	}

	if (sc->sc_sc.chip & RTWN_CHIP_88E) {
		urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(0), 0x69553422);
		DELAY(1);
		urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(0), 0x69553420);
		DELAY(1);

		xtal = sc->sc_sc.crystal_cap & 0x3f;
		reg = urtwn_bb_read(sc, R92C_AFE_XTAL_CTRL);
		urtwn_bb_write(sc, R92C_AFE_XTAL_CTRL,
		    RW(reg, R92C_AFE_XTAL_CTRL_ADDR, xtal | xtal << 6));
	}

	if (urtwn_bb_read(sc, R92C_HSSI_PARAM2(0)) & R92C_HSSI_PARAM2_CCK_HIPWR)
		sc->sc_sc.sc_flags |= RTWN_FLAG_CCK_HIPWR;
}

int
urtwn_power_on(void *cookie)
{
	struct urtwn_softc *sc = cookie;

	if (sc->sc_sc.chip & RTWN_CHIP_88E)
		return (urtwn_r88e_power_on(sc));

	return (urtwn_r92c_power_on(sc));
}

int
urtwn_alloc_buffers(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	int error;

	/* Init host async commands ring. */
	sc->cmdq.cur = sc->cmdq.next = sc->cmdq.queued = 0;

	/* Allocate Tx/Rx buffers. */
	error = urtwn_alloc_rx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Rx buffers\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
	error = urtwn_alloc_tx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Tx buffers\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	return (0);
}

int
urtwn_init(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	int i, error;

	/* Queue Rx xfers. */
	for (i = 0; i < URTWN_RX_LIST_COUNT; i++) {
		struct urtwn_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->rx_pipe, data, data->buf,
		    URTWN_RXBUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, urtwn_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS)
			return (error);
	}

	ieee80211_amrr_node_init(&sc->amrr, &sc->amn);

	/*
	 * Enable TX reports for AMRR.
	 * In order to get reports we need to explicitly reset the register.
	 */
	if (sc->sc_sc.chip & RTWN_CHIP_88E)
		urtwn_write_1(sc, R88E_TX_RPT_CTRL, (urtwn_read_1(sc,
		    R88E_TX_RPT_CTRL) & ~0) | R88E_TX_RPT_CTRL_EN);

	return (0);
}

void
urtwn_stop(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	int i;

	/* Abort Tx. */
	for (i = 0; i < R92C_MAX_EPOUT; i++) {
		if (sc->tx_pipe[i] != NULL)
			usbd_abort_pipe(sc->tx_pipe[i]);
	}
	/* Stop Rx pipe. */
	usbd_abort_pipe(sc->rx_pipe);
	/* Free Tx/Rx buffers. */
	urtwn_free_tx_list(sc);
	urtwn_free_rx_list(sc);
}

int
urtwn_is_oactive(void *cookie)
{
	struct urtwn_softc *sc = cookie;
	
	return (TAILQ_EMPTY(&sc->tx_free_list));
}
@


1.74
log
@Mostly cosmetic changes to make things a bit more consistant:
- rename bit definition of R88E_TX_RPT1_ENA to reflect reality
- no need to set R92C_FPGA0_ANAPARAM2 for 40mhz for rtl8188eu
- in rtwn_write_txpower(), writing to MCS8-15 power registers if the WNIC
  has 2 spatial streams

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.73 2017/08/12 14:08:44 stsp Exp $	*/
a1128 1
		tap->wr_flags = 2;
d1146 2
@


1.73
log
@Fix Coverity CID 1452915: urtwn(4) would use an uninitialized array index
if a hypothetical and malicious USB device reports no Rx endpoints.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.72 2017/06/23 14:41:54 kevlo Exp $	*/
d2007 1
a2007 1
		    R88E_TX_RPT_CTRL) & ~0) | R88E_TX_RPT1_ENA);
@


1.72
log
@- Fix Tx queues to USB endpoints mapping and merge urtwn_r92c_dma_init()
  and urtwn_r88e_dma_init() into one; from FreeBSD r291902.

- Change the way the number of pages for public queue is calculated;
  Based on the vendor driver's _InitQueueReservedPage(), the formula for
  calculation of the number of pages for public priority queue is as follows:

  if the device has 3 endpoints:
  PUBQ = total number of Tx pages - HQ - LQ - NQ

  if the device has 2 endpoints (i.e. has high and normal priority queues):
  PUBQ = total number of Tx pages - HQ - NQ

- Don't write MCS8..MCS15 Tx power if the WNIC is a 1-stream Tx;

- Set R88E_TX_PAGE_COUNT to a correct value;

- Minimal enhancement in urtwn_open_pipes() for upcoming rtl8192eu chipset
  support;

Tested with USB-N10 Nano (rtl8188cu), DWA-131 rev B (rtl8192cu), and
TL-WN725N v2 (rtl8188eu) on amd64.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.71 2017/06/16 14:57:51 kevlo Exp $	*/
d525 1
a525 1
	int i, error;
d534 1
a534 1
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
d536 2
a537 1
		else {
d541 5
@


1.71
log
@- Fix incorrect values in the computation of transmit power for the
  rtl8188eu chipset.
- Small code refactoring:
  - replace hardcoded rate indexes with their name, like athn(4).
  - replace fields offsets with the structure; from FreeBSD r294198.
  - be compliant with definitions of the efuse in vendor hal_pg.h and
    rename struct r92c_rom member names: s/channel_plan/reserved5/,
    s/xtal_calib/channel_plan.
  - no need to disable HWPDN twice in urtwn_r88e_power_on().

Tested by stsp@@ and myself with RTL8188CUS, RTL8192CU, RTL8188EU, and
RTL8188CE devices.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.70 2017/05/08 12:28:39 stsp Exp $	*/
d64 3
a66 1
#define R92C_PUBQ_NPAGES	231
d70 4
d75 1
a75 1
#define R88E_TX_PAGE_COUNT	169
d77 1
d174 1
d372 1
a372 1
int		urtwn_llt_init(struct urtwn_softc *);
a375 2
int		urtwn_r92c_dma_init(struct urtwn_softc *);
int		urtwn_r88e_dma_init(struct urtwn_softc *);
d521 2
a522 1
	const uint8_t epaddr[] = { 0x02, 0x03, 0x05 };
d525 1
a525 1
	int i, ntx = 0, error;
d527 1
a527 1
	/* Determine the number of bulk-out pipes. */
d531 9
a539 4
		if (ed != NULL &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK &&
		    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT)
			ntx++;
d541 2
a542 2
	DPRINTF(("found %d bulk-out pipes\n", ntx));
	if (ntx == 0 || ntx > R92C_MAX_EPOUT) {
d544 1
a544 1
		    sc->sc_dev.dv_xname, ntx);
d548 2
a549 2
	/* Open bulk-in pipe at address 0x81. */
	error = usbd_open_pipe(sc->sc_iface, 0x81, 0, &sc->rx_pipe);
d557 1
a557 1
	for (i = 0; i < ntx; i++) {
d569 2
a570 2
	sc->ac2idx[EDCA_AC_BE] = (ntx == 3) ? 2 : ((ntx == 2) ? 1 : 0);
	sc->ac2idx[EDCA_AC_VI] = (ntx == 3) ? 1 : 0;
a1600 1

d1606 1
d1615 3
a1617 1
	if (ntries == 5000)
d1619 1
a1631 1

d1636 1
a1636 1
urtwn_llt_init(struct urtwn_softc *sc)
d1638 1
a1638 1
	int i, error, page_count, pktbuf_count;
a1639 2
	page_count = (sc->sc_sc.chip & RTWN_CHIP_88E) ?
	    R88E_TX_PAGE_COUNT : R92C_TX_PAGE_COUNT;
d1719 4
d1724 16
a1739 12
	if (sc->sc_sc.chip & RTWN_CHIP_88E)
		return urtwn_r88e_dma_init(sc);

	return urtwn_r92c_dma_init(sc);
}

int
urtwn_r92c_dma_init(struct urtwn_softc *sc)
{
	int hashq, hasnq, haslq, nqueues, nqpages, nrempages;
	uint32_t reg;
	int error;
d1742 1
a1742 1
	error = urtwn_llt_init(sc);
d1748 10
a1757 3
	reg = urtwn_read_2(sc, R92C_USB_EP + 1);
	DPRINTFN(2, ("USB endpoints mapping 0x%x\n", reg));
	if (MS(reg, R92C_USB_EP_HQ) != 0)
d1759 3
a1761 11
	if (MS(reg, R92C_USB_EP_NQ) != 0)
		hasnq = 1;
	if (MS(reg, R92C_USB_EP_LQ) != 0)
		haslq = 1;
	nqueues = hashq + hasnq + haslq;
	if (nqueues == 0)
		return (EIO);
	/* Get the number of pages for each queue. */
	nqpages = (R92C_TX_PAGE_COUNT - R92C_PUBQ_NPAGES) / nqueues;
	/* The remaining pages are assigned to the high priority queue. */
	nrempages = (R92C_TX_PAGE_COUNT - R92C_PUBQ_NPAGES) % nqueues;
d1767 1
a1767 1
	    SM(R92C_RQPN_PUBQ, R92C_PUBQ_NPAGES) |
d1769 1
a1769 1
	    SM(R92C_RQPN_HPQ, hashq ? nqpages + nrempages : 0) |
d1771 1
a1771 1
	    SM(R92C_RQPN_LPQ, haslq ? nqpages : 0) |
d1775 5
a1779 5
	urtwn_write_1(sc, R92C_TXPKTBUF_BCNQ_BDNY, R92C_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TXPKTBUF_MGQ_BDNY, R92C_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TXPKTBUF_WMAC_LBK_BF_HD, R92C_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TRXFF_BNDY, R92C_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TDECTRL + 1, R92C_TX_PAGE_BOUNDARY);
d1784 4
a1787 2
	if (nqueues == 1) {
		if (hashq)
a1788 2
		else if (hasnq)
			reg |= R92C_TRXDMA_CTRL_QMAP_NQ;
a1789 6
			reg |= R92C_TRXDMA_CTRL_QMAP_LQ;
	} else if (nqueues == 2) {
		/* All 2-endpoints configs have a high priority queue. */
		if (!hashq)
			return (EIO);
		if (hasnq)
d1791 1
a1791 4
		else
			reg |= R92C_TRXDMA_CTRL_QMAP_HQ_LQ;
	} else
		reg |= R92C_TRXDMA_CTRL_QMAP_3EP;
d1795 1
a1795 1
	urtwn_write_2(sc, R92C_TRXFF_BNDY + 2, 0x27ff);
d1801 1
a1801 50
	return (0);
}

int
urtwn_r88e_dma_init(struct urtwn_softc *sc)
{
	usb_interface_descriptor_t      *id;
	uint32_t reg;
	int nqueues = 1;
	int error;

	/* Initialize LLT table. */
	error = urtwn_llt_init(sc);
	if (error != 0)
		return (error);

	/* Get Tx queues to USB endpoints mapping. */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	nqueues = id->bNumEndpoints - 1;

	/* Set number of pages for normal priority queue. */
	urtwn_write_2(sc, R92C_RQPN_NPQ, 0x000d);
	urtwn_write_4(sc, R92C_RQPN, 0x808e000d);

	urtwn_write_1(sc, R92C_TXPKTBUF_BCNQ_BDNY, R88E_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TXPKTBUF_MGQ_BDNY, R88E_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TXPKTBUF_WMAC_LBK_BF_HD, R88E_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TRXFF_BNDY, R88E_TX_PAGE_BOUNDARY);
	urtwn_write_1(sc, R92C_TDECTRL + 1, R88E_TX_PAGE_BOUNDARY);

	/* Set queue to USB pipe mapping. */
	reg = urtwn_read_2(sc, R92C_TRXDMA_CTRL);
	reg &= ~R92C_TRXDMA_CTRL_QMAP_M;
	if (nqueues == 1)
		reg |= R92C_TRXDMA_CTRL_QMAP_LQ;
	else if (nqueues == 2)
		reg |= R92C_TRXDMA_CTRL_QMAP_HQ_NQ;
	else
		reg |= R92C_TRXDMA_CTRL_QMAP_3EP;
	urtwn_write_2(sc, R92C_TRXDMA_CTRL, reg);

	/* Set Tx/Rx transfer page boundary. */
	urtwn_write_2(sc, R92C_TRXFF_BNDY + 2, 0x23ff);

	/* Set Tx/Rx transfer page size. */
	urtwn_write_1(sc, R92C_PBP,
	    SM(R92C_PBP_PSRX, R92C_PBP_128) |
	    SM(R92C_PBP_PSTX, R92C_PBP_128));

	return (0);
@


1.70
log
@For 8188EU chips, read the R92C_HSSI_PARAM2(0) register to detect whether
the driver needs to enable the CCK high power feature, as already done for
other chips supported by urtwn(4).

Same change as FreeBSD r311347.
Patch submitted by Kevin Lo. Tested by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.69 2017/01/30 21:54:30 stsp Exp $	*/
d207 93
a299 82
static const struct usb_devno urtwn_devs[] = {
	{ USB_VENDOR_ABOCOM,	USB_PRODUCT_ABOCOM_RTL8188CU_1 },
	{ USB_VENDOR_ABOCOM,	USB_PRODUCT_ABOCOM_RTL8188CU_2 },
	{ USB_VENDOR_ABOCOM,	USB_PRODUCT_ABOCOM_RTL8192CU },
	{ USB_VENDOR_ASUS,	USB_PRODUCT_ASUS_RTL8192CU },
	{ USB_VENDOR_ASUS,	USB_PRODUCT_ASUS_RTL8192CU_2 },
	{ USB_VENDOR_ASUS,	USB_PRODUCT_ASUS_RTL8192CU_3 },
	{ USB_VENDOR_AZUREWAVE,	USB_PRODUCT_AZUREWAVE_RTL8188CE_1 },
	{ USB_VENDOR_AZUREWAVE,	USB_PRODUCT_AZUREWAVE_RTL8188CE_2 },
	{ USB_VENDOR_AZUREWAVE,	USB_PRODUCT_AZUREWAVE_RTL8188CU },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_F7D2102 },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_F9L1004V1 },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_RTL8188CU },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_RTL8188CUS },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_RTL8192CU },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_RTL8192CU_1 },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_RTL8192CU_2 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_1 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_2 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_3 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_4 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_5 },
	{ USB_VENDOR_CHICONY,	USB_PRODUCT_CHICONY_RTL8188CUS_6 },
	{ USB_VENDOR_COMPARE,	USB_PRODUCT_COMPARE_RTL8192CU },
	{ USB_VENDOR_COREGA,	USB_PRODUCT_COREGA_RTL8192CU },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_DWA131B },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_RTL8188CU },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_RTL8192CU_1 },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_RTL8192CU_2 },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_RTL8192CU_3 },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_RTL8192CU_4 },
	{ USB_VENDOR_EDIMAX,	USB_PRODUCT_EDIMAX_EW7811UN },
	{ USB_VENDOR_EDIMAX,	USB_PRODUCT_EDIMAX_RTL8192CU },
	{ USB_VENDOR_FEIXUN,	USB_PRODUCT_FEIXUN_RTL8188CU },
	{ USB_VENDOR_FEIXUN,	USB_PRODUCT_FEIXUN_RTL8192CU },
	{ USB_VENDOR_GUILLEMOT,	USB_PRODUCT_GUILLEMOT_HWNUP150 },
	{ USB_VENDOR_GUILLEMOT,	USB_PRODUCT_GUILLEMOT_RTL8192CU },
	{ USB_VENDOR_HAWKING,	USB_PRODUCT_HAWKING_RTL8192CU },
	{ USB_VENDOR_HAWKING,	USB_PRODUCT_HAWKING_RTL8192CU_2 },
	{ USB_VENDOR_HP3,	USB_PRODUCT_HP3_RTL8188CU },
	{ USB_VENDOR_IODATA,	USB_PRODUCT_IODATA_WNG150UM },
	{ USB_VENDOR_IODATA,	USB_PRODUCT_IODATA_RTL8192CU },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_N300MA },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_WNA1000M },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_WNA1000Mv2 },
	{ USB_VENDOR_NETGEAR,	USB_PRODUCT_NETGEAR_RTL8192CU },
	{ USB_VENDOR_NETGEAR4,	USB_PRODUCT_NETGEAR4_RTL8188CU },
	{ USB_VENDOR_NETWEEN,	USB_PRODUCT_NETWEEN_RTL8192CU },
	{ USB_VENDOR_NOVATECH,	USB_PRODUCT_NOVATECH_RTL8188CU },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8188CU_1 },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8188CU_2 },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8188CU_3 },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8188CU_4 },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8188CUS },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_RTL8192CU },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CE_0 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CE_1 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CTV },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_0 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_1 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_2 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_3 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_4 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_5 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CU_COMBO },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188CUS },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188RU },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188RU_2 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188RU_3 },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8191CU },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8192CE },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8192CE_VAU },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8192CU },
	{ USB_VENDOR_SITECOMEU,	USB_PRODUCT_SITECOMEU_RTL8188CU },
	{ USB_VENDOR_SITECOMEU,	USB_PRODUCT_SITECOMEU_RTL8188CU_2 },
	{ USB_VENDOR_SITECOMEU,	USB_PRODUCT_SITECOMEU_RTL8192CU },
	{ USB_VENDOR_SITECOMEU,	USB_PRODUCT_SITECOMEU_RTL8192CU_2 },
	{ USB_VENDOR_SITECOMEU,	USB_PRODUCT_SITECOMEU_WLA2100V2 },
	{ USB_VENDOR_TPLINK,	USB_PRODUCT_TPLINK_RTL8192CU },
	{ USB_VENDOR_TRENDNET,	USB_PRODUCT_TRENDNET_RTL8188CU },
	{ USB_VENDOR_TRENDNET,	USB_PRODUCT_TRENDNET_RTL8192CU },
	{ USB_VENDOR_ZYXEL,	USB_PRODUCT_ZYXEL_RTL8192CU },
d301 5
a305 5
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_DWA123D1 },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_DWA125D1 },
	{ USB_VENDOR_ELECOM,	USB_PRODUCT_ELECOM_WDC150SU2M },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188ETV },
	{ USB_VENDOR_REALTEK,	USB_PRODUCT_REALTEK_RTL8188EU }
d308 3
d398 1
a398 1
	return ((usb_lookup(urtwn_devs, uaa->vendor, uaa->product) != NULL) ?
a408 1
	uint32_t chip_type;
d413 2
a420 10
	chip_type = RTWN_CHIP_USB;
	if (uaa->product == USB_PRODUCT_DLINK_DWA123D1 ||
	    uaa->product == USB_PRODUCT_DLINK_DWA125D1 ||
	    uaa->product == USB_PRODUCT_ELECOM_WDC150SU2M ||
	    uaa->product == USB_PRODUCT_REALTEK_RTL8188EU ||
	    uaa->product == USB_PRODUCT_REALTEK_RTL8188ETV)
		chip_type |= RTWN_CHIP_88E;
	else
		chip_type |= (RTWN_CHIP_92C | RTWN_CHIP_88C);

d448 1
a448 1
	if (rtwn_attach(&sc->sc_dev, &sc->sc_sc, chip_type) != 0) {
a1586 1
	urtwn_write_1(sc, 0x5, urtwn_read_1(sc, 0x5) & ~0x80);
d1869 1
a1869 1
	uint8_t crystalcap;
d1967 1
a1967 4
		crystalcap = sc->sc_sc.r88e_rom[0xb9];
		if (crystalcap == 0xff)
			crystalcap = 0x20;
		crystalcap &= 0x3f;
d1970 1
a1970 2
		    RW(reg, R92C_AFE_XTAL_CTRL_ADDR,
		    crystalcap | crystalcap << 6));
d1983 1
a1983 1
		return urtwn_r88e_power_on(sc);
d1985 1
a1985 1
	return urtwn_r92c_power_on(sc);
@


1.69
log
@Make urtwn(4) run slot time updates from a USB task.
Fixes 'usbd_do_request: not in process context' warnings introduced recently.
Fix reported and confirmed by Mikhail aka mp39590 aka misha
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.68 2017/01/22 10:17:39 dlg Exp $	*/
a1970 4
	} else {
		if (urtwn_bb_read(sc, R92C_HSSI_PARAM2(0)) &
		    R92C_HSSI_PARAM2_CCK_HIPWR)
			sc->sc_sc.sc_flags |= RTWN_FLAG_CCK_HIPWR;
d1972 3
@


1.68
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.67 2017/01/08 05:48:27 stsp Exp $	*/
d329 2
d452 1
d935 20
@


1.67
log
@Make urtwn(4) use AMRR instead of letting the firmware handle rate scaling.
For now this only affects RTL8188EU chips, perhaps because the author of this
patch does not own any devices containing any of the other chips (hint hint).
Patch by misha aka Mikhail / mp39590 at gmail
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.66 2016/07/21 08:38:33 stsp Exp $	*/
a1239 1
	ifp->if_opackets++;
@


1.66
log
@Make rtwn(4) and urtwn(4) respect the RTS threshold set by net80211.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.65 2016/06/17 10:53:55 stsp Exp $	*/
d50 1
d176 3
d413 4
a416 1
		
d849 9
d1161 21
d1332 2
a1352 2
		/* Send RTS at OFDM24. */
		txd->txdw4 |= htole32(SM(R92C_TXDW4_RTSRATE, 8));
a1353 2
		/* Send data at OFDM54. */
		txd->txdw5 |= htole32(SM(R92C_TXDW5_DATARATE, 11));
d1355 12
d2010 10
@


1.65
log
@Merge a lot of code from urtwn(4) into rtwn(4). Both drivers now share code
in the file sys/dev/ic/rtwn.c. This reduces kernel bloat and will make it
easier to have both drivers benefit from future enhancements.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.64 2016/04/13 11:03:37 mpi Exp $	*/
d1302 4
a1305 1
		if (ic->ic_flags & IEEE80211_F_USEPROT) {
@


1.64
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.63 2016/03/21 22:12:06 stsp Exp $	*/
d58 1
d145 1
a145 1
	uint16_t		associd;
d157 2
a158 3
	struct ieee80211com		sc_ic;
	int				(*sc_newstate)(struct ieee80211com *,
					    enum ieee80211_state, int);
d162 1
d165 1
a168 20
	u_int				sc_flags;
#define URTWN_FLAG_CCK_HIPWR		0x01
#define URTWN_FLAG_FORCE_RAID_11B	0x02

	u_int				chip;
#define	URTWN_CHIP_92C		0x01
#define	URTWN_CHIP_92C_1T2R	0x02
#define	URTWN_CHIP_UMC		0x04
#define	URTWN_CHIP_UMC_A_CUT	0x08
#define	URTWN_CHIP_88E		0x10

	uint8_t				board_type;
	uint8_t				regulatory;
	uint8_t				pa_setting;
	int				avg_pwdb;
	int				thcal_state;
	int				thcal_lctemp;
	int				ntxchains;
	int				nrxchains;
	int				ledlink;
a169 1
	int				sc_tx_timer;
a170 1
	int				fwcur;
a173 6
	struct r92c_rom			rom;
	uint8_t				r88e_rom[512];
	uint8_t				cck_tx_pwr[6];
	uint8_t				ht40_tx_pwr[5];
	int8_t				bw20_tx_pwr_diff;
	int8_t				ofdm_tx_pwr_diff;
a174 1
	uint32_t			rf_chnlbw[R92C_MAX_CHAINS];
d305 1
a305 1
void		urtwn_wait_async(struct urtwn_softc *);
d308 3
a310 3
void		urtwn_write_1(struct urtwn_softc *, uint16_t, uint8_t);
void		urtwn_write_2(struct urtwn_softc *, uint16_t, uint16_t);
void		urtwn_write_4(struct urtwn_softc *, uint16_t, uint32_t);
d313 3
a315 7
uint8_t		urtwn_read_1(struct urtwn_softc *, uint16_t);
uint16_t	urtwn_read_2(struct urtwn_softc *, uint16_t);
uint32_t	urtwn_read_4(struct urtwn_softc *, uint16_t);
int		urtwn_fw_cmd(struct urtwn_softc *, uint8_t, const void *, int);
void		urtwn_rf_write(struct urtwn_softc *, int, uint8_t, uint32_t);
uint32_t	urtwn_rf_read(struct urtwn_softc *, int, uint8_t);
void		urtwn_cam_write(struct urtwn_softc *, uint32_t, uint32_t);
a316 14
uint8_t		urtwn_efuse_read_1(struct urtwn_softc *, uint16_t);
void		urtwn_efuse_read(struct urtwn_softc *);
void		urtwn_efuse_switch_power(struct urtwn_softc *);
int		urtwn_read_chipid(struct urtwn_softc *);
void		urtwn_read_rom(struct urtwn_softc *);
void		urtwn_r88e_read_rom(struct urtwn_softc *);
int		urtwn_media_change(struct ifnet *);
int		urtwn_ra_init(struct urtwn_softc *);
int		urtwn_r92c_ra_init(struct urtwn_softc *, u_int8_t, u_int32_t,
		    int, uint32_t, int);
int		urtwn_r88e_ra_init(struct urtwn_softc *, u_int8_t, u_int32_t,
		    int, uint32_t, int);
void		urtwn_tsf_sync_enable(struct urtwn_softc *);
void		urtwn_set_led(struct urtwn_softc *, int, int);
d319 1
d321 1
a332 3
void		urtwn_update_avgrssi(struct urtwn_softc *, int, int8_t);
int8_t		urtwn_get_rssi(struct urtwn_softc *, int, void *);
int8_t		urtwn_r88e_get_rssi(struct urtwn_softc *, int, void *);
d338 1
a338 4
int		urtwn_tx(struct urtwn_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		urtwn_start(struct ifnet *);
void		urtwn_watchdog(struct ifnet *);
d340 2
d345 3
a347 4
void		urtwn_fw_reset(struct urtwn_softc *);
void		urtwn_r88e_fw_reset(struct urtwn_softc *);
int		urtwn_fw_loadpage(struct urtwn_softc *, int, uint8_t *, int);
int		urtwn_load_firmware(struct urtwn_softc *);
d350 7
a356 25
void		urtwn_mac_init(struct urtwn_softc *);
void		urtwn_bb_init(struct urtwn_softc *);
void		urtwn_rf_init(struct urtwn_softc *);
void		urtwn_cam_init(struct urtwn_softc *);
void		urtwn_pa_bias_init(struct urtwn_softc *);
void		urtwn_rxfilter_init(struct urtwn_softc *);
void		urtwn_edca_init(struct urtwn_softc *);
void		urtwn_write_txpower(struct urtwn_softc *, int, uint16_t[]);
void		urtwn_get_txpower(struct urtwn_softc *, int,
		    struct ieee80211_channel *, struct ieee80211_channel *,
		    uint16_t[]);
void		urtwn_r88e_get_txpower(struct urtwn_softc *, int,
		    struct ieee80211_channel *,
		    struct ieee80211_channel *, uint16_t[]);
void		urtwn_set_txpower(struct urtwn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
void		urtwn_set_chan(struct urtwn_softc *,
		    struct ieee80211_channel *, struct ieee80211_channel *);
int		urtwn_iq_calib_chain(struct urtwn_softc *, int, uint16_t[],
		    uint16_t[]);
void		urtwn_iq_calib(struct urtwn_softc *);
void		urtwn_lc_calib(struct urtwn_softc *);
void		urtwn_temp_calib(struct urtwn_softc *);
int		urtwn_init(struct ifnet *);
void		urtwn_stop(struct ifnet *);
d387 3
a389 3
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int i, error;
d395 1
a395 1
	timeout_set(&sc->scan_to, urtwn_next_scan, sc);
d397 2
d400 1
d406 1
a406 19
		sc->chip |= URTWN_CHIP_88E;

	error = urtwn_read_chipid(sc);
	if (error != 0) {
		printf("%s: unsupported test chip\n", sc->sc_dev.dv_xname);
		return;
	}

	/* Determine number of Tx/Rx chains. */
	if (sc->chip & URTWN_CHIP_92C) {
		sc->ntxchains = (sc->chip & URTWN_CHIP_92C_1T2R) ? 1 : 2;
		sc->nrxchains = 2;
	} else {
		sc->ntxchains = 1;
		sc->nrxchains = 1;
	}

	if (sc->chip & URTWN_CHIP_88E)
		urtwn_r88e_read_rom(sc);
d408 28
a435 12
		urtwn_read_rom(sc);

	printf("%s: MAC/BB RTL%s, RF 6052 %dT%dR, address %s\n",
	    sc->sc_dev.dv_xname,
	    (sc->chip & URTWN_CHIP_92C) ? "8192CU" :
	    (sc->chip & URTWN_CHIP_88E) ? "8188EU" :
	    (sc->board_type == R92C_BOARD_TYPE_HIGHPA) ? "8188RU" :
	    (sc->board_type == R92C_BOARD_TYPE_MINICARD) ? "8188CE-VAU" :
	    "8188CUS", sc->ntxchains, sc->nrxchains,
	    ether_sprintf(ic->ic_myaddr));

	if (urtwn_open_pipes(sc) != 0)
a436 32

	ic->ic_phytype = IEEE80211_T_OFDM;	/* Not only, but not used. */
	ic->ic_opmode = IEEE80211_M_STA;	/* Default to BSS mode. */
	ic->ic_state = IEEE80211_S_INIT;

	/* Set device capabilities. */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* Monitor mode supported. */
	    IEEE80211_C_SHPREAMBLE |	/* Short preamble supported. */
	    IEEE80211_C_SHSLOT |	/* Short slot time supported. */
	    IEEE80211_C_WEP |		/* WEP. */
	    IEEE80211_C_RSN;		/* WPA/RSN. */

	/* Set HT capabilities. */
	ic->ic_htcaps =
	    IEEE80211_HTCAP_CBW20_40 |
	    IEEE80211_HTCAP_DSSSCCK40;
	/* Set supported HT rates. */
	for (i = 0; i < sc->nrxchains; i++)
		ic->ic_sup_mcs[i] = 0xff;

	/* Set supported .11b and .11g rates. */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* Set supported .11b and .11g channels (1 through 14). */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
a437 7
	/*
	 * The number of STAs that we can support is limited by the number
	 * of CAM entries used for hardware crypto.
	 */
	ic->ic_max_nnodes = R92C_CAM_ENTRY_COUNT - 4;
	if (ic->ic_max_nnodes > IEEE80211_CACHE_SIZE)
		ic->ic_max_nnodes = IEEE80211_CACHE_SIZE;
d439 2
a440 2
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
a441 3
	ifp->if_start = urtwn_start;
	ifp->if_watchdog = urtwn_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
a442 2
	if_attach(ifp);
	ieee80211_ifattach(ifp);
a448 1
	sc->sc_newstate = ic->ic_newstate;
a449 1
	ieee80211_media_init(ifp, urtwn_media_change, ieee80211_media_status);
a468 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d483 1
a483 4
	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}
d705 1
a705 1
urtwn_wait_async(struct urtwn_softc *sc)
d707 4
d713 1
d731 1
a731 1
urtwn_write_1(struct urtwn_softc *sc, uint16_t addr, uint8_t val)
d733 2
d739 1
a739 1
urtwn_write_2(struct urtwn_softc *sc, uint16_t addr, uint16_t val)
d741 2
d748 1
a748 1
urtwn_write_4(struct urtwn_softc *sc, uint16_t addr, uint32_t val)
d750 2
d771 1
a771 1
urtwn_read_1(struct urtwn_softc *sc, uint16_t addr)
d773 1
d782 1
a782 1
urtwn_read_2(struct urtwn_softc *sc, uint16_t addr)
d784 1
d793 1
a793 1
urtwn_read_4(struct urtwn_softc *sc, uint16_t addr)
d795 1
a803 86
urtwn_fw_cmd(struct urtwn_softc *sc, uint8_t id, const void *buf, int len)
{
	struct r92c_fw_cmd cmd;
	int ntries;

	/* Wait for current FW box to be empty. */
	for (ntries = 0; ntries < 100; ntries++) {
		if (!(urtwn_read_1(sc, R92C_HMETFR) & (1 << sc->fwcur)))
			break;
		DELAY(1);
	}
	if (ntries == 100) {
		printf("%s: could not send firmware command %d\n",
		    sc->sc_dev.dv_xname, id);
		return (ETIMEDOUT);
	}
	memset(&cmd, 0, sizeof(cmd));
	cmd.id = id;
	if (len > 3)
		cmd.id |= R92C_CMD_FLAG_EXT;
	KASSERT(len <= sizeof(cmd.msg));
	memcpy(cmd.msg, buf, len);

	/* Write the first word last since that will trigger the FW. */
	urtwn_write_region_1(sc, R92C_HMEBOX_EXT(sc->fwcur),
	    (uint8_t *)&cmd + 4, 2);
	urtwn_write_region_1(sc, R92C_HMEBOX(sc->fwcur),
	    (uint8_t *)&cmd + 0, 4);

	sc->fwcur = (sc->fwcur + 1) % R92C_H2C_NBOX;
	return (0);
}

void
urtwn_rf_write(struct urtwn_softc *sc, int chain, uint8_t addr, uint32_t val)
{
	uint32_t param_addr;

	if (sc->chip & URTWN_CHIP_88E)
		param_addr = SM(R88E_LSSI_PARAM_ADDR, addr);
	else
		param_addr = SM(R92C_LSSI_PARAM_ADDR, addr);

	urtwn_bb_write(sc, R92C_LSSI_PARAM(chain),
	    param_addr | SM(R92C_LSSI_PARAM_DATA, val));
}

uint32_t
urtwn_rf_read(struct urtwn_softc *sc, int chain, uint8_t addr)
{
	uint32_t reg[R92C_MAX_CHAINS], val;

	reg[0] = urtwn_bb_read(sc, R92C_HSSI_PARAM2(0));
	if (chain != 0)
		reg[chain] = urtwn_bb_read(sc, R92C_HSSI_PARAM2(chain));

	urtwn_bb_write(sc, R92C_HSSI_PARAM2(0),
	    reg[0] & ~R92C_HSSI_PARAM2_READ_EDGE);
	DELAY(1000);

	urtwn_bb_write(sc, R92C_HSSI_PARAM2(chain),
	    RW(reg[chain], R92C_HSSI_PARAM2_READ_ADDR, addr) |
	    R92C_HSSI_PARAM2_READ_EDGE);
	DELAY(1000);

	urtwn_bb_write(sc, R92C_HSSI_PARAM2(0),
	    reg[0] | R92C_HSSI_PARAM2_READ_EDGE);
	DELAY(1000);

	if (urtwn_bb_read(sc, R92C_HSSI_PARAM1(chain)) & R92C_HSSI_PARAM1_PI)
		val = urtwn_bb_read(sc, R92C_HSPI_READBACK(chain));
	else
		val = urtwn_bb_read(sc, R92C_LSSI_READBACK(chain));
	return (MS(val, R92C_LSSI_READBACK_DATA));
}

void
urtwn_cam_write(struct urtwn_softc *sc, uint32_t addr, uint32_t data)
{
	urtwn_write_4(sc, R92C_CAMWRITE, data);
	urtwn_write_4(sc, R92C_CAMCMD,
	    R92C_CAMCMD_POLLING | R92C_CAMCMD_WRITE |
	    SM(R92C_CAMCMD_ADDR, addr));
}

int
a821 22
uint8_t
urtwn_efuse_read_1(struct urtwn_softc *sc, uint16_t addr)
{
	uint32_t reg;
	int ntries;

	reg = urtwn_read_4(sc, R92C_EFUSE_CTRL);
	reg = RW(reg, R92C_EFUSE_CTRL_ADDR, addr);
	reg &= ~R92C_EFUSE_CTRL_VALID;
	urtwn_write_4(sc, R92C_EFUSE_CTRL, reg);
	/* Wait for read operation to complete. */
	for (ntries = 0; ntries < 100; ntries++) {
		reg = urtwn_read_4(sc, R92C_EFUSE_CTRL);
		if (reg & R92C_EFUSE_CTRL_VALID)
			return (MS(reg, R92C_EFUSE_CTRL_DATA));
		DELAY(5);
	}
	printf("%s: could not read efuse byte at address 0x%x\n",
	    sc->sc_dev.dv_xname, addr);
	return (0xff);
}

d823 1
a823 1
urtwn_efuse_read(struct urtwn_softc *sc)
d825 1
a825 5
	uint8_t *rom = (uint8_t *)&sc->rom;
	uint16_t addr = 0;
	uint32_t reg;
	uint8_t off, msk;
	int i;
d827 2
a828 1
	urtwn_efuse_switch_power(sc);
d830 1
a830 28
	memset(&sc->rom, 0xff, sizeof(sc->rom));
	while (addr < 512) {
		reg = urtwn_efuse_read_1(sc, addr);
		if (reg == 0xff)
			break;
		addr++;
		off = reg >> 4;
		msk = reg & 0xf;
		for (i = 0; i < 4; i++) {
			if (msk & (1 << i))
				continue;
			rom[off * 8 + i * 2 + 0] =
			    urtwn_efuse_read_1(sc, addr);
			addr++;
			rom[off * 8 + i * 2 + 1] =
			    urtwn_efuse_read_1(sc, addr);
			addr++;
		}
	}
#ifdef URTWN_DEBUG
	if (urtwn_debug >= 2) {
		/* Dump ROM content. */
		printf("\n");
		for (i = 0; i < sizeof(sc->rom); i++)
			printf("%02x:", rom[i]);
		printf("\n");
	}
#endif
d832 2
a833 2
	urtwn_write_1(sc, R92C_EFUSE_ACCESS, R92C_EFUSE_ACCESS_OFF);
}
d835 1
a835 51
void
urtwn_efuse_switch_power(struct urtwn_softc *sc)
{
	uint32_t reg;

	urtwn_write_1(sc, R92C_EFUSE_ACCESS, R92C_EFUSE_ACCESS_ON);

	reg = urtwn_read_2(sc, R92C_SYS_ISO_CTRL);
	if (!(reg & R92C_SYS_ISO_CTRL_PWC_EV12V)) {
		urtwn_write_2(sc, R92C_SYS_ISO_CTRL,
		    reg | R92C_SYS_ISO_CTRL_PWC_EV12V);
	}
	reg = urtwn_read_2(sc, R92C_SYS_FUNC_EN);
	if (!(reg & R92C_SYS_FUNC_EN_ELDR)) {
		urtwn_write_2(sc, R92C_SYS_FUNC_EN,
		    reg | R92C_SYS_FUNC_EN_ELDR);
	}
	reg = urtwn_read_2(sc, R92C_SYS_CLKR);
	if ((reg & (R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M)) !=
	    (R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M)) {
		urtwn_write_2(sc, R92C_SYS_CLKR,
		    reg | R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M);
	}
}

int
urtwn_read_chipid(struct urtwn_softc *sc)
{
	uint32_t reg;

	if (sc->chip & URTWN_CHIP_88E)
		return (0);

	reg = urtwn_read_4(sc, R92C_SYS_CFG);
	if (reg & R92C_SYS_CFG_TRP_VAUX_EN)
		return (EIO);

	if (reg & R92C_SYS_CFG_TYPE_92C) {
		sc->chip |= URTWN_CHIP_92C;
		/* Check if it is a castrated 8192C. */
		if (MS(urtwn_read_4(sc, R92C_HPON_FSM),
		    R92C_HPON_FSM_CHIP_BONDING_ID) ==
		    R92C_HPON_FSM_CHIP_BONDING_ID_92C_1T2R)
			sc->chip |= URTWN_CHIP_92C_1T2R;
	}
	if (reg & R92C_SYS_CFG_VENDOR_UMC) {
		sc->chip |= URTWN_CHIP_UMC;
		if (MS(reg, R92C_SYS_CFG_CHIP_VER_RTL) == 0)
			sc->chip |= URTWN_CHIP_UMC_A_CUT;
	}
	return (0);
d838 1
d840 1
a840 1
urtwn_read_rom(struct urtwn_softc *sc)
d842 1
a842 15
	struct ieee80211com *ic = &sc->sc_ic;
	struct r92c_rom *rom = &sc->rom;

	/* Read full ROM image. */
	urtwn_efuse_read(sc);

	/* XXX Weird but this is what the vendor driver does. */
	sc->pa_setting = urtwn_efuse_read_1(sc, 0x1fa);
	DPRINTF(("PA setting=0x%x\n", sc->pa_setting));

	sc->board_type = MS(rom->rf_opt1, R92C_ROM_RF1_BOARD_TYPE);

	sc->regulatory = MS(rom->rf_opt1, R92C_ROM_RF1_REGULATORY);
	DPRINTF(("regulatory type=%d\n", sc->regulatory));
	IEEE80211_ADDR_COPY(ic->ic_myaddr, rom->macaddr);
d846 1
a846 1
urtwn_r88e_read_rom(struct urtwn_softc *sc)
d848 1
a848 6
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t *rom = sc->r88e_rom;
	uint16_t addr = 0;
	uint32_t reg;
	uint8_t off, msk, tmp;
	int i;
d850 2
a851 175
	off = 0;
	urtwn_efuse_switch_power(sc);

	/* Read full ROM image. */
	memset(&sc->r88e_rom, 0xff, sizeof(sc->r88e_rom));
	while (addr < 512) {
		reg = urtwn_efuse_read_1(sc, addr);
		if (reg == 0xff)
			break;
		addr++;
		if ((reg & 0x1f) == 0x0f) {
			tmp = (reg & 0xe0) >> 5;
			reg = urtwn_efuse_read_1(sc, addr);
			if ((reg & 0x0f) != 0x0f)
				off = ((reg & 0xf0) >> 1) | tmp;
			addr++;
		} else
			off = reg >> 4;
		msk = reg & 0xf;
		for (i = 0; i < 4; i++) {
			if (msk & (1 << i))
				continue;
			rom[off * 8 + i * 2 + 0] =
			    urtwn_efuse_read_1(sc, addr);
			addr++;
			rom[off * 8 + i * 2 + 1] =
			    urtwn_efuse_read_1(sc, addr);
			addr++;
		}
	}

	urtwn_write_1(sc, R92C_EFUSE_ACCESS, R92C_EFUSE_ACCESS_OFF);

	addr = 0x10;
	for (i = 0; i < 6; i++)
		sc->cck_tx_pwr[i] = sc->r88e_rom[addr++];
	for (i = 0; i < 5; i++)
		sc->ht40_tx_pwr[i] = sc->r88e_rom[addr++];
	sc->bw20_tx_pwr_diff = (sc->r88e_rom[addr] & 0xf0) >> 4;
	if (sc->bw20_tx_pwr_diff & 0x08)
		sc->bw20_tx_pwr_diff |= 0xf0;
	sc->ofdm_tx_pwr_diff = (sc->r88e_rom[addr] & 0xf);
	if (sc->ofdm_tx_pwr_diff & 0x08)
		sc->ofdm_tx_pwr_diff |= 0xf0;
	sc->regulatory = MS(sc->r88e_rom[0xc1], R92C_ROM_RF1_REGULATORY);
	IEEE80211_ADDR_COPY(ic->ic_myaddr, &sc->r88e_rom[0xd7]);
}

int
urtwn_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return (error);

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING)) {
		urtwn_stop(ifp);
		urtwn_init(ifp);
	}
	return (0);
}

/*
 * Initialize rate adaptation in firmware.
 */
int
urtwn_ra_init(struct urtwn_softc *sc)
{
	static const uint8_t map[] =
	    { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 };
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct ieee80211_rateset *rs = &ni->ni_rates;
	uint32_t rates, basicrates;
	uint8_t mode;
	int maxrate, maxbasicrate, error, i, j;

	/* Get normal and basic rates mask. */
	rates = basicrates = 0;
	maxrate = maxbasicrate = 0;
	for (i = 0; i < rs->rs_nrates; i++) {
		/* Convert 802.11 rate to HW rate index. */
		for (j = 0; j < nitems(map); j++)
			if ((rs->rs_rates[i] & IEEE80211_RATE_VAL) == map[j])
				break;
		if (j == nitems(map))	/* Unknown rate, skip. */
			continue;
		rates |= 1 << j;
		if (j > maxrate)
			maxrate = j;
		if (rs->rs_rates[i] & IEEE80211_RATE_BASIC) {
			basicrates |= 1 << j;
			if (j > maxbasicrate)
				maxbasicrate = j;
		}
	}
	if (ic->ic_curmode == IEEE80211_MODE_11B)
		mode = R92C_RAID_11B;
	else
		mode = R92C_RAID_11BG;
	DPRINTF(("mode=0x%x rates=0x%08x, basicrates=0x%08x\n",
	    mode, rates, basicrates));

	if (sc->chip & URTWN_CHIP_88E)
		error = urtwn_r88e_ra_init(sc, mode, rates, maxrate,
		    basicrates, maxbasicrate);
	else
		error = urtwn_r92c_ra_init(sc, mode, rates, maxrate,
		    basicrates, maxbasicrate);

	/* Indicate highest supported rate. */
	ni->ni_txrate = rs->rs_nrates - 1;
	return (error);
}

int urtwn_r92c_ra_init(struct urtwn_softc *sc, u_int8_t mode, u_int32_t rates,
    int maxrate, uint32_t basicrates, int maxbasicrate)
{
	struct r92c_fw_cmd_macid_cfg cmd;
	int error;

	/* Set rates mask for group addressed frames. */
	cmd.macid = R92C_MACID_BC | R92C_MACID_VALID;
	cmd.mask = htole32(mode << 28 | basicrates);
	error = urtwn_fw_cmd(sc, R92C_CMD_MACID_CONFIG, &cmd, sizeof(cmd));
	if (error != 0) {
		printf("%s: could not add broadcast station\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
	/* Set initial MRR rate. */
	DPRINTF(("maxbasicrate=%d\n", maxbasicrate));
	urtwn_write_1(sc, R92C_INIDATA_RATE_SEL(R92C_MACID_BC),
	    maxbasicrate);

	/* Set rates mask for unicast frames. */
	cmd.macid = R92C_MACID_BSS | R92C_MACID_VALID;
	cmd.mask = htole32(mode << 28 | rates);
	error = urtwn_fw_cmd(sc, R92C_CMD_MACID_CONFIG, &cmd, sizeof(cmd));
	if (error != 0) {
		printf("%s: could not add BSS station\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}
	/* Set initial MRR rate. */
	DPRINTF(("maxrate=%d\n", maxrate));
	urtwn_write_1(sc, R92C_INIDATA_RATE_SEL(R92C_MACID_BSS),
	    maxrate);

	return (0);
}

int
urtwn_r88e_ra_init(struct urtwn_softc *sc, u_int8_t mode, u_int32_t rates,
    int maxrate, uint32_t basicrates, int maxbasicrate)
{
	u_int32_t reg;

	urtwn_write_1(sc, R92C_INIRTS_RATE_SEL, maxbasicrate);

	reg = urtwn_read_4(sc, R92C_RRSR);
	reg = RW(reg, R92C_RRSR_RATE_BITMAP, rates);
	urtwn_write_4(sc, R92C_RRSR, reg);

	/*
	 * Workaround for performance problems with firmware rate adaptation:
	 * If the AP only supports 11b rates, disable mixed B/G mode.
	 */
	if (mode != R92C_RAID_11B && maxrate <= 3 /* 11M */)
		sc->sc_flags |= URTWN_FLAG_FORCE_RAID_11B;

	return (0);
d855 1
a855 1
urtwn_tsf_sync_enable(struct urtwn_softc *sc)
d857 1
a857 2
	struct ieee80211_node *ni = sc->sc_ic.ic_bss;
	uint64_t tsf;
d859 2
a860 17
	/* Enable TSF synchronization. */
	urtwn_write_1(sc, R92C_BCN_CTRL,
	    urtwn_read_1(sc, R92C_BCN_CTRL) & ~R92C_BCN_CTRL_DIS_TSF_UDT0);

	urtwn_write_1(sc, R92C_BCN_CTRL,
	    urtwn_read_1(sc, R92C_BCN_CTRL) & ~R92C_BCN_CTRL_EN_BCN);

	/* Set initial TSF. */
	memcpy(&tsf, ni->ni_tstamp, 8);
	tsf = letoh64(tsf);
	tsf = tsf - (tsf % (ni->ni_intval * IEEE80211_DUR_TU));
	tsf -= IEEE80211_DUR_TU;
	urtwn_write_4(sc, R92C_TSFTR + 0, tsf);
	urtwn_write_4(sc, R92C_TSFTR + 4, tsf >> 32);

	urtwn_write_1(sc, R92C_BCN_CTRL,
	    urtwn_read_1(sc, R92C_BCN_CTRL) | R92C_BCN_CTRL_EN_BCN);
d864 1
a864 28
urtwn_set_led(struct urtwn_softc *sc, int led, int on)
{
	uint8_t reg;

	if (led == URTWN_LED_LINK) {
		if (sc->chip & URTWN_CHIP_88E) {
			reg = urtwn_read_1(sc, R92C_LEDCFG2) & 0xf0;
			urtwn_write_1(sc, R92C_LEDCFG2, reg | R92C_LEDCFG2_EN);
			if (!on) {
				reg = urtwn_read_1(sc, R92C_LEDCFG2) & 0x90;
				urtwn_write_1(sc, R92C_LEDCFG2,
				    reg | R92C_LEDCFG0_DIS);
				urtwn_write_1(sc, R92C_MAC_PINMUX_CFG,
				    urtwn_read_1(sc, R92C_MAC_PINMUX_CFG) &
				    0xfe);
			}
		} else {
			reg = urtwn_read_1(sc, R92C_LEDCFG0) & 0x70;
			if (!on)
				reg |= R92C_LEDCFG0_DIS;
			urtwn_write_1(sc, R92C_LEDCFG0, reg);
		}
		sc->ledlink = on;       /* Save LED state. */
	}
}

void
urtwn_calib_to(void *arg)
d872 1
a872 4

	/* Do it in a process context. */
	urtwn_do_async(sc, urtwn_calib_cb, NULL, 0);

a875 1
/* ARGSUSED */
d877 1
a877 1
urtwn_calib_cb(struct urtwn_softc *sc, void *arg)
d879 1
a879 13
	struct r92c_fw_cmd_rssi cmd;

	if (sc->avg_pwdb != -1) {
		/* Indicate Rx signal strength to FW for rate adaptation. */
		memset(&cmd, 0, sizeof(cmd));
		cmd.macid = 0;	/* BSS. */
		cmd.pwdb = sc->avg_pwdb;
		DPRINTFN(3, ("sending RSSI command avg=%d\n", sc->avg_pwdb));
		urtwn_fw_cmd(sc, R92C_CMD_RSSI_SETTING, &cmd, sizeof(cmd));
	}

	/* Do temperature compensation. */
	urtwn_temp_calib(sc);
d882 1
a882 1
		timeout_add_sec(&sc->calib_to, 2);
d886 1
a886 1
urtwn_next_scan(void *arg)
d888 1
a888 3
	struct urtwn_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	int s;
d890 2
a891 11
	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(&ic->ic_if);
	splx(s);

	usbd_ref_decr(sc->sc_udev);
d897 3
a899 1
	struct urtwn_softc *sc = ic->ic_softc;
d913 1
a913 106
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	enum ieee80211_state ostate;
	uint32_t reg;
	int s;

	s = splnet();
	ostate = ic->ic_state;
	DPRINTF(("newstate %d -> %d\n", ostate, cmd->state));

	if (ostate == IEEE80211_S_RUN) {
		/* Stop calibration. */
		timeout_del(&sc->calib_to);

		/* Turn link LED off. */
		urtwn_set_led(sc, URTWN_LED_LINK, 0);

		/* Set media status to 'No Link'. */
		reg = urtwn_read_4(sc, R92C_CR);
		reg = RW(reg, R92C_CR_NETTYPE, R92C_CR_NETTYPE_NOLINK);
		urtwn_write_4(sc, R92C_CR, reg);

		/* Stop Rx of data frames. */
		urtwn_write_2(sc, R92C_RXFLTMAP2, 0);

		/* Rest TSF. */
		urtwn_write_1(sc, R92C_DUAL_TSF_RST, 0x03);

		/* Disable TSF synchronization. */
		urtwn_write_1(sc, R92C_BCN_CTRL,
		    urtwn_read_1(sc, R92C_BCN_CTRL) |
		    R92C_BCN_CTRL_DIS_TSF_UDT0);

		/* Reset EDCA parameters. */
		urtwn_write_4(sc, R92C_EDCA_VO_PARAM, 0x002f3217);
		urtwn_write_4(sc, R92C_EDCA_VI_PARAM, 0x005e4317);
		urtwn_write_4(sc, R92C_EDCA_BE_PARAM, 0x00105320);
		urtwn_write_4(sc, R92C_EDCA_BK_PARAM, 0x0000a444);

		/* Disable 11b-only AP workaround (see urtwn_r88e_ra_init). */
		sc->sc_flags &= ~URTWN_FLAG_FORCE_RAID_11B;
	}
	switch (cmd->state) {
	case IEEE80211_S_INIT:
		/* Turn link LED off. */
		urtwn_set_led(sc, URTWN_LED_LINK, 0);
		break;
	case IEEE80211_S_SCAN:
		if (ostate != IEEE80211_S_SCAN) {
			/* Allow Rx from any BSSID. */
			urtwn_write_4(sc, R92C_RCR,
			    urtwn_read_4(sc, R92C_RCR) &
			    ~(R92C_RCR_CBSSID_DATA | R92C_RCR_CBSSID_BCN));

			/* Set gain for scanning. */
			reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(0));
			reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x20);
			urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(0), reg);

			if (!(sc->chip & URTWN_CHIP_88E)) {
				reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(1));
				reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x20);
				urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(1), reg);
			}
		}

		/* Make link LED blink during scan. */
		urtwn_set_led(sc, URTWN_LED_LINK, !sc->ledlink);

		/* Pause AC Tx queues. */
		urtwn_write_1(sc, R92C_TXPAUSE,
		    urtwn_read_1(sc, R92C_TXPAUSE) | 0x0f);

		urtwn_set_chan(sc, ic->ic_bss->ni_chan, NULL);
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
		/* Set initial gain under link. */
		reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(0));
		reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x32);
		urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(0), reg);

		if (!(sc->chip & URTWN_CHIP_88E)) {
			reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(1));
			reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x32);
			urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(1), reg);
		}

		urtwn_set_chan(sc, ic->ic_bss->ni_chan, NULL);
		break;
	case IEEE80211_S_ASSOC:
		break;
	case IEEE80211_S_RUN:
		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			urtwn_set_chan(sc, ic->ic_ibss_chan, NULL);

			/* Enable Rx of data frames. */
			urtwn_write_2(sc, R92C_RXFLTMAP2, 0xffff);

			/* Turn link LED on. */
			urtwn_set_led(sc, URTWN_LED_LINK, 1);
			break;
		}
		ni = ic->ic_bss;
d915 1
a915 55
		/* Set media status to 'Associated'. */
		reg = urtwn_read_4(sc, R92C_CR);
		reg = RW(reg, R92C_CR_NETTYPE, R92C_CR_NETTYPE_INFRA);
		urtwn_write_4(sc, R92C_CR, reg);

		/* Set BSSID. */
		urtwn_write_4(sc, R92C_BSSID + 0, LE_READ_4(&ni->ni_bssid[0]));
		urtwn_write_4(sc, R92C_BSSID + 4, LE_READ_2(&ni->ni_bssid[4]));

		if (ic->ic_curmode == IEEE80211_MODE_11B)
			urtwn_write_1(sc, R92C_INIRTS_RATE_SEL, 0);
		else	/* 802.11b/g */
			urtwn_write_1(sc, R92C_INIRTS_RATE_SEL, 3);

		/* Enable Rx of data frames. */
		urtwn_write_2(sc, R92C_RXFLTMAP2, 0xffff);

		/* Flush all AC queues. */
		urtwn_write_1(sc, R92C_TXPAUSE, 0);

		/* Set beacon interval. */
		urtwn_write_2(sc, R92C_BCN_INTERVAL, ni->ni_intval);

		/* Allow Rx from our BSSID only. */
		urtwn_write_4(sc, R92C_RCR,
		    urtwn_read_4(sc, R92C_RCR) |
		    R92C_RCR_CBSSID_DATA | R92C_RCR_CBSSID_BCN);

		/* Enable TSF synchronization. */
		urtwn_tsf_sync_enable(sc);

		urtwn_write_1(sc, R92C_SIFS_CCK + 1, 10);
		urtwn_write_1(sc, R92C_SIFS_OFDM + 1, 10);
		urtwn_write_1(sc, R92C_SPEC_SIFS + 1, 10);
		urtwn_write_1(sc, R92C_MAC_SPEC_SIFS + 1, 10);
		urtwn_write_1(sc, R92C_R2T_SIFS + 1, 10);
		urtwn_write_1(sc, R92C_T2T_SIFS + 1, 10);

		/* Intialize rate adaptation. */
		urtwn_ra_init(sc);

		/* Turn link LED on. */
		urtwn_set_led(sc, URTWN_LED_LINK, 1);

		sc->avg_pwdb = -1;	/* Reset average RSSI. */
		/* Reset temperature calibration state machine. */
		sc->thcal_state = 0;
		sc->thcal_lctemp = 0;
		/* Start periodic calibration. */
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_sec(&sc->calib_to, 2);
		break;
	}
	(void)sc->sc_newstate(ic, cmd->state, cmd->arg);
	splx(s);
d921 4
d926 1
a926 1
	urtwn_do_async(ic->ic_softc, urtwn_updateedca_cb, NULL, 0);
d933 1
a933 9
	const uint16_t aci2reg[EDCA_NUM_AC] = {
		R92C_EDCA_BE_PARAM,
		R92C_EDCA_BK_PARAM,
		R92C_EDCA_VI_PARAM,
		R92C_EDCA_VO_PARAM
	};
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_edca_ac_params *ac;
	int s, aci, aifs, slottime;
d935 1
a935 13
	s = splnet();
	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		ac = &ic->ic_edca_ac[aci];
		/* AIFS[AC] = AIFSN[AC] * aSlotTime + aSIFSTime. */
		aifs = ac->ac_aifsn * slottime + 10;
		urtwn_write_4(sc, aci2reg[aci],
		    SM(R92C_EDCA_PARAM_TXOP, ac->ac_txoplimit) |
		    SM(R92C_EDCA_PARAM_ECWMIN, ac->ac_ecwmin) |
		    SM(R92C_EDCA_PARAM_ECWMAX, ac->ac_ecwmax) |
		    SM(R92C_EDCA_PARAM_AIFS, aifs));
	}
	splx(s);
d942 3
a944 1
	struct urtwn_softc *sc = ic->ic_softc;
d954 1
a954 1
	cmd.associd = (ni != NULL) ? ni->ni_associd : 0;
d962 1
a962 2
	static const uint8_t etherzeroaddr[6] = { 0 };
	struct ieee80211com *ic = &sc->sc_ic;
d964 2
a965 44
	struct ieee80211_key *k = &cmd->key;
	const uint8_t *macaddr;
	uint8_t keybuf[16], algo;
	int i, entry;

	/* Map net80211 cipher to HW crypto algorithm. */
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		algo = R92C_CAM_ALGO_WEP40;
		break;
	case IEEE80211_CIPHER_WEP104:
		algo = R92C_CAM_ALGO_WEP104;
		break;
	case IEEE80211_CIPHER_TKIP:
		algo = R92C_CAM_ALGO_TKIP;
		break;
	case IEEE80211_CIPHER_CCMP:
		algo = R92C_CAM_ALGO_AES;
		break;
	default:
		return;
	}
	if (k->k_flags & IEEE80211_KEY_GROUP) {
		macaddr = etherzeroaddr;
		entry = k->k_id;
	} else {
		macaddr = ic->ic_bss->ni_macaddr;
		entry = 4;
	}
	/* Write key. */
	memset(keybuf, 0, sizeof(keybuf));
	memcpy(keybuf, k->k_key, MIN(k->k_len, sizeof(keybuf)));
	for (i = 0; i < 4; i++) {
		urtwn_cam_write(sc, R92C_CAM_KEY(entry, i),
		    LE_READ_4(&keybuf[i * 4]));
	}
	/* Write CTL0 last since that will validate the CAM entry. */
	urtwn_cam_write(sc, R92C_CAM_CTL1(entry),
	    LE_READ_4(&macaddr[2]));
	urtwn_cam_write(sc, R92C_CAM_CTL0(entry),
	    SM(R92C_CAM_ALGO, algo) |
	    SM(R92C_CAM_KEYID, k->k_id) |
	    SM(R92C_CAM_MACLO, LE_READ_2(&macaddr[0])) |
	    R92C_CAM_VALID);
d972 3
a974 1
	struct urtwn_softc *sc = ic->ic_softc;
d983 1
a983 1
	cmd.associd = (ni != NULL) ? ni->ni_associd : 0;
d990 1
a991 2
	struct ieee80211_key *k = &cmd->key;
	int i, entry;
d993 1
a993 9
	if (k->k_flags & IEEE80211_KEY_GROUP)
		entry = k->k_id;
	else
		entry = 4;
	urtwn_cam_write(sc, R92C_CAM_CTL0(entry), 0);
	urtwn_cam_write(sc, R92C_CAM_CTL1(entry), 0);
	/* Clear key. */
	for (i = 0; i < 4; i++)
		urtwn_cam_write(sc, R92C_CAM_KEY(entry, i), 0);
d997 1
a997 1
urtwn_update_avgrssi(struct urtwn_softc *sc, int rate, int8_t rssi)
d999 11
a1009 125
	int pwdb;

	/* Convert antenna signal to percentage. */
	if (rssi <= -100 || rssi >= 20)
		pwdb = 0;
	else if (rssi >= 0)
		pwdb = 100;
	else
		pwdb = 100 + rssi;
	if (!(sc->chip & URTWN_CHIP_88E)) {
		if (rate <= 3) {
			/* CCK gain is smaller than OFDM/MCS gain. */
			pwdb += 6;
			if (pwdb > 100)
				pwdb = 100;
			if (pwdb <= 14)
				pwdb -= 4;
			else if (pwdb <= 26)
				pwdb -= 8;
			else if (pwdb <= 34)
				pwdb -= 6;
			else if (pwdb <= 42)
				pwdb -= 2;
		}
	}
	if (sc->avg_pwdb == -1)	/* Init. */
		sc->avg_pwdb = pwdb;
	else if (sc->avg_pwdb < pwdb)
		sc->avg_pwdb = ((sc->avg_pwdb * 19 + pwdb) / 20) + 1;
	else
		sc->avg_pwdb = ((sc->avg_pwdb * 19 + pwdb) / 20);
	DPRINTFN(4, ("PWDB=%d EMA=%d\n", pwdb, sc->avg_pwdb));
}

int8_t
urtwn_get_rssi(struct urtwn_softc *sc, int rate, void *physt)
{
	static const int8_t cckoff[] = { 16, -12, -26, -46 };
	struct r92c_rx_phystat *phy;
	struct r92c_rx_cck *cck;
	uint8_t rpt;
	int8_t rssi;

	if (rate <= 3) {
		cck = (struct r92c_rx_cck *)physt;
		if (sc->sc_flags & URTWN_FLAG_CCK_HIPWR) {
			rpt = (cck->agc_rpt >> 5) & 0x3;
			rssi = (cck->agc_rpt & 0x1f) << 1;
		} else {
			rpt = (cck->agc_rpt >> 6) & 0x3;
			rssi = cck->agc_rpt & 0x3e;
		}
		rssi = cckoff[rpt] - rssi;
	} else {	/* OFDM/HT. */
		phy = (struct r92c_rx_phystat *)physt;
		rssi = ((letoh32(phy->phydw1) >> 1) & 0x7f) - 110;
	}
	return (rssi);
}

int8_t
urtwn_r88e_get_rssi(struct urtwn_softc *sc, int rate, void *physt)
{
	struct r92c_rx_phystat *phy;
	struct r88e_rx_cck *cck;
	uint8_t cck_agc_rpt, lna_idx, vga_idx;
	int8_t rssi;

	rssi = 0;
	if (rate <= 3) {
		cck = (struct r88e_rx_cck *)physt;
		cck_agc_rpt = cck->agc_rpt;
		lna_idx = (cck_agc_rpt & 0xe0) >> 5;
		vga_idx = cck_agc_rpt & 0x1f; 
		switch (lna_idx) {
		case 7:
			if (vga_idx <= 27)
				rssi = -100 + 2* (27 - vga_idx);
			else
				rssi = -100;
			break;
		case 6:
			rssi = -48 + 2 * (2 - vga_idx);
			break;
		case 5:
			rssi = -42 + 2 * (7 - vga_idx);
			break;
		case 4:
			rssi = -36 + 2 * (7 - vga_idx);
			break;
		case 3:
			rssi = -24 + 2 * (7 - vga_idx);
			break;
		case 2:
			rssi = -12 + 2 * (5 - vga_idx);
			break;
		case 1:
			rssi = 8 - (2 * vga_idx);
			break;
		case 0:
			rssi = 14 - (2 * vga_idx);
			break;
		}
		rssi += 6;
	} else {	/* OFDM/HT. */
		phy = (struct r92c_rx_phystat *)physt;
		rssi = ((le32toh(phy->phydw1) >> 1) & 0x7f) - 110;
	}
	return (rssi);
}

void
urtwn_rx_frame(struct urtwn_softc *sc, uint8_t *buf, int pktlen)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_frame *wh;
	struct ieee80211_node *ni;
	struct r92c_rx_desc_usb *rxd;
	uint32_t rxdw0, rxdw3;
	struct mbuf *m;
	uint8_t rate;
	int8_t rssi = 0;
	int s, infosz;
d1033 1
a1033 4
		if (sc->chip & URTWN_CHIP_88E)
			rssi = urtwn_r88e_get_rssi(sc, rate, &rxd[1]);
		else
			rssi = urtwn_get_rssi(sc, rate, &rxd[1]);
d1035 1
a1035 1
		urtwn_update_avgrssi(sc, rate, rssi);
d1122 1
a1122 1
	int len, totlen, pktlen, infosz, npkts;
d1143 1
a1143 1
	DPRINTFN(6, ("Rx %d frames in one chunk\n", npkts));
d1176 3
a1178 1
	(void)usbd_transfer(xfer);
d1187 1
a1187 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d1202 1
a1202 1
	sc->sc_tx_timer = 0;
d1208 1
a1208 1
		urtwn_start(ifp);
d1214 1
a1214 1
urtwn_tx(struct urtwn_softc *sc, struct mbuf *m, struct ieee80211_node *ni)
d1216 2
a1217 1
	struct ieee80211com *ic = &sc->sc_ic;
d1285 1
a1285 1
		    (sc->sc_flags & URTWN_FLAG_FORCE_RAID_11B))
d1289 1
a1289 1
		if (sc->chip & URTWN_CHIP_88E) {
a1379 70
void
urtwn_start(struct ifnet *ifp)
{
	struct urtwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (TAILQ_EMPTY(&sc->tx_free_list)) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}
		/* Send pending management frames first. */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;
			goto sendit;
		}
		if (ic->ic_state != IEEE80211_S_RUN)
			break;

		/* Encapsulate and send data frames. */
		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;
#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		if ((m = ieee80211_encap(ifp, m, &ni)) == NULL)
			continue;
sendit:
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		if (urtwn_tx(sc, m, ni) != 0) {
			ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
urtwn_watchdog(struct ifnet *ifp)
{
	struct urtwn_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/* urtwn_init(ifp); XXX needs a process context! */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}
	ieee80211_watchdog(ifp);
}

d1383 4
a1386 4
	struct urtwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;
d1392 1
a1392 49

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (!(ifp->if_flags & IFF_RUNNING))
				urtwn_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				urtwn_stop(ifp);
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				urtwn_set_chan(sc, ic->ic_ibss_chan, NULL);
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING)) {
			urtwn_stop(ifp);
			urtwn_init(ifp);
		}
		error = 0;
	}
	splx(s);

d1550 1
a1550 1
	page_count = (sc->chip & URTWN_CHIP_88E) ?
d1552 1
a1552 1
	pktbuf_count = (sc->chip & URTWN_CHIP_88E) ?
a1575 31
void
urtwn_fw_reset(struct urtwn_softc *sc)
{
	uint16_t reg;
	int ntries;

	/* Tell 8051 to reset itself. */
	urtwn_write_1(sc, R92C_HMETFR + 3, 0x20);

	/* Wait until 8051 resets by itself. */
	for (ntries = 0; ntries < 100; ntries++) {
		reg = urtwn_read_2(sc, R92C_SYS_FUNC_EN);
		if (!(reg & R92C_SYS_FUNC_EN_CPUEN))
			return;
		DELAY(50);
	}
	/* Force 8051 reset. */
	urtwn_write_2(sc, R92C_SYS_FUNC_EN, reg & ~R92C_SYS_FUNC_EN_CPUEN);
}


void
urtwn_r88e_fw_reset(struct urtwn_softc *sc)
{
	uint16_t reg;

	reg = urtwn_read_2(sc, R92C_SYS_FUNC_EN);
	urtwn_write_2(sc, R92C_SYS_FUNC_EN, reg & ~R92C_SYS_FUNC_EN_CPUEN);
	urtwn_write_2(sc, R92C_SYS_FUNC_EN, reg | R92C_SYS_FUNC_EN_CPUEN);
}

d1577 1
a1577 1
urtwn_fw_loadpage(struct urtwn_softc *sc, int page, uint8_t *buf, int len)
d1579 1
d1606 1
a1606 1
urtwn_load_firmware(struct urtwn_softc *sc)
d1608 1
a1608 1
	const struct r92c_fw_hdr *hdr;
d1610 1
a1610 4
	u_char *fw, *ptr;
	size_t len;
	uint32_t reg;
	int mlen, ntries, page, error;
d1612 1
a1612 2
	/* Read firmware image from the filesystem. */
	if (sc->chip & URTWN_CHIP_88E)
d1614 2
a1615 2
	else if ((sc->chip & (URTWN_CHIP_UMC_A_CUT | URTWN_CHIP_92C)) ==
		    URTWN_CHIP_UMC_A_CUT)
d1619 4
a1622 2
	if ((error = loadfirmware(name, &fw, &len)) != 0) {
		printf("%s: failed loadfirmware of file %s (error %d)\n",
d1624 7
a1630 55
		return (error);
	}
	if (len < sizeof(*hdr)) {
		printf("%s: firmware too short\n", sc->sc_dev.dv_xname);
		error = EINVAL;
		goto fail;
	}
	ptr = fw;
	hdr = (const struct r92c_fw_hdr *)ptr;
	/* Check if there is a valid FW header and skip it. */
	if ((letoh16(hdr->signature) >> 4) == 0x88c ||
	    (le16toh(hdr->signature) >> 4) == 0x88e ||
	    (letoh16(hdr->signature) >> 4) == 0x92c) {
		DPRINTF(("FW V%d.%d %02d-%02d %02d:%02d\n",
		    letoh16(hdr->version), letoh16(hdr->subversion),
		    hdr->month, hdr->date, hdr->hour, hdr->minute));
		ptr += sizeof(*hdr);
		len -= sizeof(*hdr);
	}

	if (urtwn_read_1(sc, R92C_MCUFWDL) & R92C_MCUFWDL_RAM_DL_SEL) {
		if (sc->chip & URTWN_CHIP_88E)
			urtwn_r88e_fw_reset(sc);
		else
			urtwn_fw_reset(sc);
		urtwn_write_1(sc, R92C_MCUFWDL, 0);
	}
	if (!(sc->chip & URTWN_CHIP_88E))
		urtwn_write_2(sc, R92C_SYS_FUNC_EN,
		    urtwn_read_2(sc, R92C_SYS_FUNC_EN) |
		    R92C_SYS_FUNC_EN_CPUEN);

	urtwn_write_1(sc, R92C_MCUFWDL,
	    urtwn_read_1(sc, R92C_MCUFWDL) | R92C_MCUFWDL_EN);
	urtwn_write_1(sc, R92C_MCUFWDL + 2,
	    urtwn_read_1(sc, R92C_MCUFWDL + 2) & ~0x08);

	/* Reset the FWDL checksum. */
	urtwn_write_1(sc, R92C_MCUFWDL,
	    urtwn_read_1(sc, R92C_MCUFWDL) | R92C_MCUFWDL_CHKSUM_RPT);

	for (page = 0; len > 0; page++) {
		mlen = MIN(len, R92C_FW_PAGE_SIZE);
		error = urtwn_fw_loadpage(sc, page, ptr, mlen);
		if (error != 0) {
			printf("%s: could not load firmware page %d "
			    "(error %d)\n", sc->sc_dev.dv_xname, page, error);
			goto fail;
		}
		ptr += mlen;
		len -= mlen;
	}
	urtwn_write_1(sc, R92C_MCUFWDL,
	    urtwn_read_1(sc, R92C_MCUFWDL) & ~R92C_MCUFWDL_EN);
	urtwn_write_1(sc, R92C_MCUFWDL + 1, 0);
d1632 2
a1633 12
	/* Wait for checksum report. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (urtwn_read_4(sc, R92C_MCUFWDL) & R92C_MCUFWDL_CHKSUM_RPT)
			break;
		DELAY(5);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for checksum report\n",
		    sc->sc_dev.dv_xname);
		error = ETIMEDOUT;
		goto fail;
	}
d1635 1
a1635 20
	reg = urtwn_read_4(sc, R92C_MCUFWDL);
	reg = (reg & ~R92C_MCUFWDL_WINTINI_RDY) | R92C_MCUFWDL_RDY;
	urtwn_write_4(sc, R92C_MCUFWDL, reg);
	if (sc->chip & URTWN_CHIP_88E)
		urtwn_r88e_fw_reset(sc);
	/* Wait for firmware readiness. */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (urtwn_read_4(sc, R92C_MCUFWDL) & R92C_MCUFWDL_WINTINI_RDY)
			break;
		DELAY(5);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for firmware readiness\n",
		    sc->sc_dev.dv_xname);
		error = ETIMEDOUT;
		goto fail;
	}
 fail:
	free(fw, M_DEVBUF, 0);
	return (error);
d1768 1
a1768 1
urtwn_mac_init(struct urtwn_softc *sc)
d1770 1
d1774 1
a1774 1
	if (sc->chip & URTWN_CHIP_88E) {
d1788 1
a1788 1
urtwn_bb_init(struct urtwn_softc *sc)
d1790 1
d1802 1
a1802 1
	if (!(sc->chip & URTWN_CHIP_88E))
d1811 1
a1811 1
	if (!(sc->chip & URTWN_CHIP_88E)) {
d1818 1
a1818 1
	if (sc->chip & URTWN_CHIP_88E)
d1820 2
a1821 2
	else if (!(sc->chip & URTWN_CHIP_92C)) {
		if (sc->board_type == R92C_BOARD_TYPE_MINICARD)
d1823 1
a1823 1
		else if (sc->board_type == R92C_BOARD_TYPE_HIGHPA)
d1828 1
a1828 1
		if (sc->board_type == R92C_BOARD_TYPE_MINICARD)
d1839 1
a1839 1
	if (sc->chip & URTWN_CHIP_92C_1T2R) {
d1885 1
a1885 1
	if (sc->chip & URTWN_CHIP_88E) {
d1891 1
a1891 1
		crystalcap = sc->r88e_rom[0xb9];
d1902 1
a1902 466
			sc->sc_flags |= URTWN_FLAG_CCK_HIPWR;
	}
}

void
urtwn_rf_init(struct urtwn_softc *sc)
{
	const struct r92c_rf_prog *prog;
	uint32_t reg, type;
	int i, j, idx, off;

	/* Select RF programming based on board type. */
	if (sc->chip & URTWN_CHIP_88E)
		prog = rtl8188eu_rf_prog;
	else if (!(sc->chip & URTWN_CHIP_92C)) {
		if (sc->board_type == R92C_BOARD_TYPE_MINICARD)
			prog = rtl8188ce_rf_prog;
		else if (sc->board_type == R92C_BOARD_TYPE_HIGHPA)
			prog = rtl8188ru_rf_prog;
		else
			prog = rtl8188cu_rf_prog;
	} else
		prog = rtl8192ce_rf_prog;

	for (i = 0; i < sc->nrxchains; i++) {
		/* Save RF_ENV control type. */
		idx = i / 2;
		off = (i % 2) * 16;
		reg = urtwn_bb_read(sc, R92C_FPGA0_RFIFACESW(idx));
		type = (reg >> off) & 0x10;

		/* Set RF_ENV enable. */
		reg = urtwn_bb_read(sc, R92C_FPGA0_RFIFACEOE(i));
		reg |= 0x100000;
		urtwn_bb_write(sc, R92C_FPGA0_RFIFACEOE(i), reg);
		DELAY(1);
		/* Set RF_ENV output high. */
		reg = urtwn_bb_read(sc, R92C_FPGA0_RFIFACEOE(i));
		reg |= 0x10;
		urtwn_bb_write(sc, R92C_FPGA0_RFIFACEOE(i), reg);
		DELAY(1);
		/* Set address and data lengths of RF registers. */
		reg = urtwn_bb_read(sc, R92C_HSSI_PARAM2(i));
		reg &= ~R92C_HSSI_PARAM2_ADDR_LENGTH;
		urtwn_bb_write(sc, R92C_HSSI_PARAM2(i), reg);
		DELAY(1);
		reg = urtwn_bb_read(sc, R92C_HSSI_PARAM2(i));
		reg &= ~R92C_HSSI_PARAM2_DATA_LENGTH;
		urtwn_bb_write(sc, R92C_HSSI_PARAM2(i), reg);
		DELAY(1);

		/* Write RF initialization values for this chain. */
		for (j = 0; j < prog[i].count; j++) {
			if (prog[i].regs[j] >= 0xf9 &&
			    prog[i].regs[j] <= 0xfe) {
				/*
				 * These are fake RF registers offsets that
				 * indicate a delay is required.
				 */
				usbd_delay_ms(sc->sc_udev, 50);
				continue;
			}
			urtwn_rf_write(sc, i, prog[i].regs[j],
			    prog[i].vals[j]);
			DELAY(1);
		}

		/* Restore RF_ENV control type. */
		reg = urtwn_bb_read(sc, R92C_FPGA0_RFIFACESW(idx));
		reg &= ~(0x10 << off) | (type << off);
		urtwn_bb_write(sc, R92C_FPGA0_RFIFACESW(idx), reg);

		/* Cache RF register CHNLBW. */
		sc->rf_chnlbw[i] = urtwn_rf_read(sc, i, R92C_RF_CHNLBW);
	}

	if ((sc->chip & (URTWN_CHIP_UMC_A_CUT | URTWN_CHIP_92C)) ==
	    URTWN_CHIP_UMC_A_CUT) {
		urtwn_rf_write(sc, 0, R92C_RF_RX_G1, 0x30255);
		urtwn_rf_write(sc, 0, R92C_RF_RX_G2, 0x50a00);
	}
}

void
urtwn_cam_init(struct urtwn_softc *sc)
{
	/* Invalidate all CAM entries. */
	urtwn_write_4(sc, R92C_CAMCMD,
	    R92C_CAMCMD_POLLING | R92C_CAMCMD_CLR);
}

void
urtwn_pa_bias_init(struct urtwn_softc *sc)
{
	uint8_t reg;
	int i;

	for (i = 0; i < sc->nrxchains; i++) {
		if (sc->pa_setting & (1 << i))
			continue;
		urtwn_rf_write(sc, i, R92C_RF_IPA, 0x0f406);
		urtwn_rf_write(sc, i, R92C_RF_IPA, 0x4f406);
		urtwn_rf_write(sc, i, R92C_RF_IPA, 0x8f406);
		urtwn_rf_write(sc, i, R92C_RF_IPA, 0xcf406);
	}
	if (!(sc->pa_setting & 0x10)) {
		reg = urtwn_read_1(sc, 0x16);
		reg = (reg & ~0xf0) | 0x90;
		urtwn_write_1(sc, 0x16, reg);
	}
}

void
urtwn_rxfilter_init(struct urtwn_softc *sc)
{
	/* Initialize Rx filter. */
	/* TODO: use better filter for monitor mode. */
	urtwn_write_4(sc, R92C_RCR,
	    R92C_RCR_AAP | R92C_RCR_APM | R92C_RCR_AM | R92C_RCR_AB |
	    R92C_RCR_APP_ICV | R92C_RCR_AMF | R92C_RCR_HTC_LOC_CTRL |
	    R92C_RCR_APP_MIC | R92C_RCR_APP_PHYSTS);
	/* Accept all multicast frames. */
	urtwn_write_4(sc, R92C_MAR + 0, 0xffffffff);
	urtwn_write_4(sc, R92C_MAR + 4, 0xffffffff);
	/* Accept all management frames. */
	urtwn_write_2(sc, R92C_RXFLTMAP0, 0xffff);
	/* Reject all control frames. */
	urtwn_write_2(sc, R92C_RXFLTMAP1, 0x0000);
	/* Accept all data frames. */
	urtwn_write_2(sc, R92C_RXFLTMAP2, 0xffff);
}

void
urtwn_edca_init(struct urtwn_softc *sc)
{
	urtwn_write_2(sc, R92C_SPEC_SIFS, 0x100a);
	urtwn_write_2(sc, R92C_MAC_SPEC_SIFS, 0x100a);
	urtwn_write_2(sc, R92C_SIFS_CCK, 0x100a);
	urtwn_write_2(sc, R92C_SIFS_OFDM, 0x100a);
	urtwn_write_4(sc, R92C_EDCA_BE_PARAM, 0x005ea42b);
	urtwn_write_4(sc, R92C_EDCA_BK_PARAM, 0x0000a44f);
	urtwn_write_4(sc, R92C_EDCA_VI_PARAM, 0x005ea324);
	urtwn_write_4(sc, R92C_EDCA_VO_PARAM, 0x002fa226);
}

void
urtwn_write_txpower(struct urtwn_softc *sc, int chain,
    uint16_t power[URTWN_RIDX_COUNT])
{
	uint32_t reg;

	/* Write per-CCK rate Tx power. */
	if (chain == 0) {
		reg = urtwn_bb_read(sc, R92C_TXAGC_A_CCK1_MCS32);
		reg = RW(reg, R92C_TXAGC_A_CCK1,  power[0]);
		urtwn_bb_write(sc, R92C_TXAGC_A_CCK1_MCS32, reg);
		reg = urtwn_bb_read(sc, R92C_TXAGC_B_CCK11_A_CCK2_11);
		reg = RW(reg, R92C_TXAGC_A_CCK2,  power[1]);
		reg = RW(reg, R92C_TXAGC_A_CCK55, power[2]);
		reg = RW(reg, R92C_TXAGC_A_CCK11, power[3]);
		urtwn_bb_write(sc, R92C_TXAGC_B_CCK11_A_CCK2_11, reg);
	} else {
		reg = urtwn_bb_read(sc, R92C_TXAGC_B_CCK1_55_MCS32);
		reg = RW(reg, R92C_TXAGC_B_CCK1,  power[0]);
		reg = RW(reg, R92C_TXAGC_B_CCK2,  power[1]);
		reg = RW(reg, R92C_TXAGC_B_CCK55, power[2]);
		urtwn_bb_write(sc, R92C_TXAGC_B_CCK1_55_MCS32, reg);
		reg = urtwn_bb_read(sc, R92C_TXAGC_B_CCK11_A_CCK2_11);
		reg = RW(reg, R92C_TXAGC_B_CCK11, power[3]);
		urtwn_bb_write(sc, R92C_TXAGC_B_CCK11_A_CCK2_11, reg);
	}
	/* Write per-OFDM rate Tx power. */
	urtwn_bb_write(sc, R92C_TXAGC_RATE18_06(chain),
	    SM(R92C_TXAGC_RATE06, power[ 4]) |
	    SM(R92C_TXAGC_RATE09, power[ 5]) |
	    SM(R92C_TXAGC_RATE12, power[ 6]) |
	    SM(R92C_TXAGC_RATE18, power[ 7]));
	urtwn_bb_write(sc, R92C_TXAGC_RATE54_24(chain),
	    SM(R92C_TXAGC_RATE24, power[ 8]) |
	    SM(R92C_TXAGC_RATE36, power[ 9]) |
	    SM(R92C_TXAGC_RATE48, power[10]) |
	    SM(R92C_TXAGC_RATE54, power[11]));
	/* Write per-MCS Tx power. */
	urtwn_bb_write(sc, R92C_TXAGC_MCS03_MCS00(chain),
	    SM(R92C_TXAGC_MCS00,  power[12]) |
	    SM(R92C_TXAGC_MCS01,  power[13]) |
	    SM(R92C_TXAGC_MCS02,  power[14]) |
	    SM(R92C_TXAGC_MCS03,  power[15]));
	urtwn_bb_write(sc, R92C_TXAGC_MCS07_MCS04(chain),
	    SM(R92C_TXAGC_MCS04,  power[16]) |
	    SM(R92C_TXAGC_MCS05,  power[17]) |
	    SM(R92C_TXAGC_MCS06,  power[18]) |
	    SM(R92C_TXAGC_MCS07,  power[19]));
	urtwn_bb_write(sc, R92C_TXAGC_MCS11_MCS08(chain),
	    SM(R92C_TXAGC_MCS08,  power[20]) |
	    SM(R92C_TXAGC_MCS09,  power[21]) |
	    SM(R92C_TXAGC_MCS10,  power[22]) |
	    SM(R92C_TXAGC_MCS11,  power[23]));
	urtwn_bb_write(sc, R92C_TXAGC_MCS15_MCS12(chain),
	    SM(R92C_TXAGC_MCS12,  power[24]) |
	    SM(R92C_TXAGC_MCS13,  power[25]) |
	    SM(R92C_TXAGC_MCS14,  power[26]) |
	    SM(R92C_TXAGC_MCS15,  power[27]));
}

void
urtwn_get_txpower(struct urtwn_softc *sc, int chain,
    struct ieee80211_channel *c, struct ieee80211_channel *extc,
    uint16_t power[URTWN_RIDX_COUNT])
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct r92c_rom *rom = &sc->rom;
	uint16_t cckpow, ofdmpow, htpow, diff, max;
	const struct r92c_txpwr *base;
	int ridx, chan, group;

	/* Determine channel group. */
	chan = ieee80211_chan2ieee(ic, c);	/* XXX center freq! */
	if (chan <= 3)
		group = 0;
	else if (chan <= 9)
		group = 1;
	else
		group = 2;

	/* Get original Tx power based on board type and RF chain. */
	if (!(sc->chip & URTWN_CHIP_92C)) {
		if (sc->board_type == R92C_BOARD_TYPE_HIGHPA)
			base = &rtl8188ru_txagc[chain];
		else
			base = &rtl8192cu_txagc[chain];
	} else
		base = &rtl8192cu_txagc[chain];

	memset(power, 0, URTWN_RIDX_COUNT * sizeof(power[0]));
	if (sc->regulatory == 0) {
		for (ridx = 0; ridx <= 3; ridx++)
			power[ridx] = base->pwr[0][ridx];
	}
	for (ridx = 4; ridx < URTWN_RIDX_COUNT; ridx++) {
		if (sc->regulatory == 3) {
			power[ridx] = base->pwr[0][ridx];
			/* Apply vendor limits. */
			if (extc != NULL)
				max = rom->ht40_max_pwr[group];
			else
				max = rom->ht20_max_pwr[group];
			max = (max >> (chain * 4)) & 0xf;
			if (power[ridx] > max)
				power[ridx] = max;
		} else if (sc->regulatory == 1) {
			if (extc == NULL)
				power[ridx] = base->pwr[group][ridx];
		} else if (sc->regulatory != 2)
			power[ridx] = base->pwr[0][ridx];
	}

	/* Compute per-CCK rate Tx power. */
	cckpow = rom->cck_tx_pwr[chain][group];
	for (ridx = 0; ridx <= 3; ridx++) {
		power[ridx] += cckpow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}

	htpow = rom->ht40_1s_tx_pwr[chain][group];
	if (sc->ntxchains > 1) {
		/* Apply reduction for 2 spatial streams. */
		diff = rom->ht40_2s_tx_pwr_diff[group];
		diff = (diff >> (chain * 4)) & 0xf;
		htpow = (htpow > diff) ? htpow - diff : 0;
	}

	/* Compute per-OFDM rate Tx power. */
	diff = rom->ofdm_tx_pwr_diff[group];
	diff = (diff >> (chain * 4)) & 0xf;
	ofdmpow = htpow + diff;	/* HT->OFDM correction. */
	for (ridx = 4; ridx <= 11; ridx++) {
		power[ridx] += ofdmpow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}

	/* Compute per-MCS Tx power. */
	if (extc == NULL) {
		diff = rom->ht20_tx_pwr_diff[group];
		diff = (diff >> (chain * 4)) & 0xf;
		htpow += diff;	/* HT40->HT20 correction. */
	}
	for (ridx = 12; ridx <= 27; ridx++) {
		power[ridx] += htpow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}
#ifdef URTWN_DEBUG
	if (urtwn_debug >= 4) {
		/* Dump per-rate Tx power values. */
		printf("Tx power for chain %d:\n", chain);
		for (ridx = 0; ridx < URTWN_RIDX_COUNT; ridx++)
			printf("Rate %d = %u\n", ridx, power[ridx]);
	}
#endif
}

void
urtwn_r88e_get_txpower(struct urtwn_softc *sc, int chain,
    struct ieee80211_channel *c, struct ieee80211_channel *extc,
    uint16_t power[URTWN_RIDX_COUNT])
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t cckpow, ofdmpow, bw20pow, htpow;
	const struct r88e_txpwr *base;
	int ridx, chan, group;

	/* Determine channel group. */
	chan = ieee80211_chan2ieee(ic, c);	/* XXX center freq! */
	if (chan <= 2)
		group = 0;
	else if (chan <= 5)
		group = 1;
	else if (chan <= 8)
		group = 2;
	else if (chan <= 11)
		group = 3;
	else if (chan <= 13)
		group = 4;
	else
		group = 5;

	/* Get original Tx power based on board type and RF chain. */
	base = &rtl8188eu_txagc[chain];

	memset(power, 0, URTWN_RIDX_COUNT * sizeof(power[0]));
	if (sc->regulatory == 0) {
		for (ridx = 0; ridx <= 3; ridx++)
			power[ridx] = base->pwr[0][ridx];
	}
	for (ridx = 4; ridx < URTWN_RIDX_COUNT; ridx++) {
		if (sc->regulatory == 3)
			power[ridx] = base->pwr[0][ridx];
		else if (sc->regulatory == 1) {
			if (extc == NULL)
				power[ridx] = base->pwr[group][ridx];
		} else if (sc->regulatory != 2)
			power[ridx] = base->pwr[0][ridx];
	}

	/* Compute per-CCK rate Tx power. */
	cckpow = sc->cck_tx_pwr[group];
	for (ridx = 0; ridx <= 3; ridx++) {
		power[ridx] += cckpow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}

	htpow = sc->ht40_tx_pwr[group];

	/* Compute per-OFDM rate Tx power. */
	ofdmpow = htpow + sc->ofdm_tx_pwr_diff;
	for (ridx = 4; ridx <= 11; ridx++) {
		power[ridx] += ofdmpow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}

	bw20pow = htpow + sc->bw20_tx_pwr_diff;
	for (ridx = 12; ridx <= 27; ridx++) {
		power[ridx] += bw20pow;
		if (power[ridx] > R92C_MAX_TX_PWR)
			power[ridx] = R92C_MAX_TX_PWR;
	}
}

void
urtwn_set_txpower(struct urtwn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	uint16_t power[URTWN_RIDX_COUNT];
	int i;

	for (i = 0; i < sc->ntxchains; i++) {
		/* Compute per-rate Tx power values. */
		if (sc->chip & URTWN_CHIP_88E)
			urtwn_r88e_get_txpower(sc, i, c, extc, power);
		else
			urtwn_get_txpower(sc, i, c, extc, power);
		/* Write per-rate Tx power values to hardware. */
		urtwn_write_txpower(sc, i, power);
	}
}

void
urtwn_set_chan(struct urtwn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int chan;
	int i;

	chan = ieee80211_chan2ieee(ic, c);	/* XXX center freq! */

	/* Set Tx power for this new channel. */
	urtwn_set_txpower(sc, c, extc);

	for (i = 0; i < sc->nrxchains; i++) {
		urtwn_rf_write(sc, i, R92C_RF_CHNLBW,
		    RW(sc->rf_chnlbw[i], R92C_RF_CHNLBW_CHNL, chan));
	}
	if (extc != NULL) {
		uint32_t reg;

		/* Is secondary channel below or above primary? */
		int prichlo = c->ic_freq < extc->ic_freq;

		urtwn_write_1(sc, R92C_BWOPMODE,
		    urtwn_read_1(sc, R92C_BWOPMODE) & ~R92C_BWOPMODE_20MHZ);

		reg = urtwn_read_1(sc, R92C_RRSR + 2);
		reg = (reg & ~0x6f) | (prichlo ? 1 : 2) << 5;
		urtwn_write_1(sc, R92C_RRSR + 2, reg);

		urtwn_bb_write(sc, R92C_FPGA0_RFMOD,
		    urtwn_bb_read(sc, R92C_FPGA0_RFMOD) | R92C_RFMOD_40MHZ);
		urtwn_bb_write(sc, R92C_FPGA1_RFMOD,
		    urtwn_bb_read(sc, R92C_FPGA1_RFMOD) | R92C_RFMOD_40MHZ);

		/* Set CCK side band. */
		reg = urtwn_bb_read(sc, R92C_CCK0_SYSTEM);
		reg = (reg & ~0x00000010) | (prichlo ? 0 : 1) << 4;
		urtwn_bb_write(sc, R92C_CCK0_SYSTEM, reg);

		reg = urtwn_bb_read(sc, R92C_OFDM1_LSTF);
		reg = (reg & ~0x00000c00) | (prichlo ? 1 : 2) << 10;
		urtwn_bb_write(sc, R92C_OFDM1_LSTF, reg);

		urtwn_bb_write(sc, R92C_FPGA0_ANAPARAM2,
		    urtwn_bb_read(sc, R92C_FPGA0_ANAPARAM2) &
		    ~R92C_FPGA0_ANAPARAM2_CBW20);

		reg = urtwn_bb_read(sc, 0x818);
		reg = (reg & ~0x0c000000) | (prichlo ? 2 : 1) << 26;
		urtwn_bb_write(sc, 0x818, reg);

		/* Select 40MHz bandwidth. */
		urtwn_rf_write(sc, 0, R92C_RF_CHNLBW,
		    (sc->rf_chnlbw[0] & ~0xfff) | chan);
	} else {
		urtwn_write_1(sc, R92C_BWOPMODE,
		    urtwn_read_1(sc, R92C_BWOPMODE) | R92C_BWOPMODE_20MHZ);

		urtwn_bb_write(sc, R92C_FPGA0_RFMOD,
		    urtwn_bb_read(sc, R92C_FPGA0_RFMOD) & ~R92C_RFMOD_40MHZ);
		urtwn_bb_write(sc, R92C_FPGA1_RFMOD,
		    urtwn_bb_read(sc, R92C_FPGA1_RFMOD) & ~R92C_RFMOD_40MHZ);

		if (!(sc->chip & URTWN_CHIP_88E)) {
			urtwn_bb_write(sc, R92C_FPGA0_ANAPARAM2,
			    urtwn_bb_read(sc, R92C_FPGA0_ANAPARAM2) |
			    R92C_FPGA0_ANAPARAM2_CBW20);
		}

		/* Select 20MHz bandwidth. */
		urtwn_rf_write(sc, 0, R92C_RF_CHNLBW,
		    (sc->rf_chnlbw[0] & ~0xfff) | chan | 
		    ((sc->chip & URTWN_CHIP_88E) ? R88E_RF_CHNLBW_BW20 :
		    R92C_RF_CHNLBW_BW20));
d1907 1
a1907 2
urtwn_iq_calib_chain(struct urtwn_softc *sc, int chain, uint16_t tx[2],
    uint16_t rx[2])
d1909 1
a1909 33
	uint32_t status;
	int offset = chain * 0x20;

	if (chain == 0) {	/* IQ calibration for chain 0. */
		/* IQ calibration settings for chain 0. */
		urtwn_bb_write(sc, 0xe30, 0x10008c1f);
		urtwn_bb_write(sc, 0xe34, 0x10008c1f);
		urtwn_bb_write(sc, 0xe38, 0x82140102);

		if (sc->ntxchains > 1) {
			urtwn_bb_write(sc, 0xe3c, 0x28160202);	/* 2T */
			/* IQ calibration settings for chain 1. */
			urtwn_bb_write(sc, 0xe50, 0x10008c22);
			urtwn_bb_write(sc, 0xe54, 0x10008c22);
			urtwn_bb_write(sc, 0xe58, 0x82140102);
			urtwn_bb_write(sc, 0xe5c, 0x28160202);
		} else
			urtwn_bb_write(sc, 0xe3c, 0x28160502);	/* 1T */

		/* LO calibration settings. */
		urtwn_bb_write(sc, 0xe4c, 0x001028d1);
		/* We're doing LO and IQ calibration in one shot. */
		urtwn_bb_write(sc, 0xe48, 0xf9000000);
		urtwn_bb_write(sc, 0xe48, 0xf8000000);

	} else {		/* IQ calibration for chain 1. */
		/* We're doing LO and IQ calibration in one shot. */
		urtwn_bb_write(sc, 0xe60, 0x00000002);
		urtwn_bb_write(sc, 0xe60, 0x00000000);
	}

	/* Give LO and IQ calibrations the time to complete. */
	usbd_delay_ms(sc->sc_udev, 1);
d1911 2
a1912 2
	/* Read IQ calibration status. */
	status = urtwn_bb_read(sc, 0xeac);
d1914 1
a1914 101
	if (status & (1 << (28 + chain * 3)))
		return (0);	/* Tx failed. */
	/* Read Tx IQ calibration results. */
	tx[0] = (urtwn_bb_read(sc, 0xe94 + offset) >> 16) & 0x3ff;
	tx[1] = (urtwn_bb_read(sc, 0xe9c + offset) >> 16) & 0x3ff;
	if (tx[0] == 0x142 || tx[1] == 0x042)
		return (0);	/* Tx failed. */

	if (status & (1 << (27 + chain * 3)))
		return (1);	/* Rx failed. */
	/* Read Rx IQ calibration results. */
	rx[0] = (urtwn_bb_read(sc, 0xea4 + offset) >> 16) & 0x3ff;
	rx[1] = (urtwn_bb_read(sc, 0xeac + offset) >> 16) & 0x3ff;
	if (rx[0] == 0x132 || rx[1] == 0x036)
		return (1);	/* Rx failed. */

	return (3);	/* Both Tx and Rx succeeded. */
}

void
urtwn_iq_calib(struct urtwn_softc *sc)
{
	/* TODO */
}

void
urtwn_lc_calib(struct urtwn_softc *sc)
{
	uint32_t rf_ac[2];
	uint8_t txmode;
	int i;

	txmode = urtwn_read_1(sc, R92C_OFDM1_LSTF + 3);
	if ((txmode & 0x70) != 0) {
		/* Disable all continuous Tx. */
		urtwn_write_1(sc, R92C_OFDM1_LSTF + 3, txmode & ~0x70);

		/* Set RF mode to standby mode. */
		for (i = 0; i < sc->nrxchains; i++) {
			rf_ac[i] = urtwn_rf_read(sc, i, R92C_RF_AC);
			urtwn_rf_write(sc, i, R92C_RF_AC,
			    RW(rf_ac[i], R92C_RF_AC_MODE,
				R92C_RF_AC_MODE_STANDBY));
		}
	} else {
		/* Block all Tx queues. */
		urtwn_write_1(sc, R92C_TXPAUSE, 0xff);
	}
	/* Start calibration. */
	urtwn_rf_write(sc, 0, R92C_RF_CHNLBW,
	    urtwn_rf_read(sc, 0, R92C_RF_CHNLBW) | R92C_RF_CHNLBW_LCSTART);

	/* Give calibration the time to complete. */
	usbd_delay_ms(sc->sc_udev, 100);

	/* Restore configuration. */
	if ((txmode & 0x70) != 0) {
		/* Restore Tx mode. */
		urtwn_write_1(sc, R92C_OFDM1_LSTF + 3, txmode);
		/* Restore RF mode. */
		for (i = 0; i < sc->nrxchains; i++)
			urtwn_rf_write(sc, i, R92C_RF_AC, rf_ac[i]);
	} else {
		/* Unblock all Tx queues. */
		urtwn_write_1(sc, R92C_TXPAUSE, 0x00);
	}
}

void
urtwn_temp_calib(struct urtwn_softc *sc)
{
	int temp;

	if (sc->thcal_state == 0) {
		/* Start measuring temperature. */
		urtwn_rf_write(sc, 0, R92C_RF_T_METER, 0x60);
		sc->thcal_state = 1;
		return;
	}
	sc->thcal_state = 0;

	/* Read measured temperature. */
	temp = urtwn_rf_read(sc, 0, R92C_RF_T_METER) & 0x1f;
	if (temp == 0)	/* Read failed, skip. */
		return;
	DPRINTFN(2, ("temperature=%d\n", temp));

	/*
	 * Redo LC calibration if temperature changed significantly since
	 * last calibration.
	 */
	if (sc->thcal_lctemp == 0) {
		/* First LC calibration is performed in urtwn_init(). */
		sc->thcal_lctemp = temp;
	} else if (abs(temp - sc->thcal_lctemp) > 1) {
		DPRINTF(("LC calib triggered by temp: %d -> %d\n",
		    sc->thcal_lctemp, temp));
		urtwn_lc_calib(sc);
		/* Record temperature of last LC calibration. */
		sc->thcal_lctemp = temp;
	}
d1918 1
a1918 1
urtwn_init(struct ifnet *ifp)
d1920 2
a1921 5
	struct urtwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct urtwn_rx_data *data;
	uint32_t reg;
	int i, error;
a1924 2
	/* Init firmware commands ring. */
	sc->fwcur = 0;
d1931 1
a1931 1
		goto fail;
d1937 1
a1937 1
		goto fail;
d1940 2
a1941 7
	/* Power on adapter. */
	if (sc->chip & URTWN_CHIP_88E)
		error = urtwn_r88e_power_on(sc);
	else
		error = urtwn_r92c_power_on(sc);
	if (error != 0)
		goto fail;
d1943 5
a1947 153
	/* Initialize DMA. */
	if (sc->chip & URTWN_CHIP_88E)
		error = urtwn_r88e_dma_init(sc);
	else
		error = urtwn_r92c_dma_init(sc);
	if (error != 0)
		goto fail;

	/* Set info size in Rx descriptors (in 64-bit words). */
	urtwn_write_1(sc, R92C_RX_DRVINFO_SZ, 4);

	/* Init interrupts. */
	if (sc->chip & URTWN_CHIP_88E) {
		urtwn_write_4(sc, R88E_HISR, 0xffffffff);
		urtwn_write_4(sc, R88E_HIMR, R88E_HIMR_CPWM | R88E_HIMR_CPWM2 |
		    R88E_HIMR_TBDER | R88E_HIMR_PSTIMEOUT);
		urtwn_write_4(sc, R88E_HIMRE, R88E_HIMRE_RXFOVW |
		    R88E_HIMRE_TXFOVW | R88E_HIMRE_RXERR | R88E_HIMRE_TXERR);
		urtwn_write_1(sc, R92C_USB_SPECIAL_OPTION,
		    urtwn_read_1(sc, R92C_USB_SPECIAL_OPTION) |
		    R92C_USB_SPECIAL_OPTION_INT_BULK_SEL);
	} else {
		urtwn_write_4(sc, R92C_HISR, 0xffffffff);
		urtwn_write_4(sc, R92C_HIMR, 0xffffffff);
	}

	/* Set MAC address. */
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	urtwn_write_region_1(sc, R92C_MACID, ic->ic_myaddr,
	    IEEE80211_ADDR_LEN);

	/* Set initial network type. */
	reg = urtwn_read_4(sc, R92C_CR);
	reg = RW(reg, R92C_CR_NETTYPE, R92C_CR_NETTYPE_INFRA);
	urtwn_write_4(sc, R92C_CR, reg);

	urtwn_rxfilter_init(sc);

	reg = urtwn_read_4(sc, R92C_RRSR);
	reg = RW(reg, R92C_RRSR_RATE_BITMAP, R92C_RRSR_RATE_CCK_ONLY_1M);
	urtwn_write_4(sc, R92C_RRSR, reg);

	/* Set short/long retry limits. */
	urtwn_write_2(sc, R92C_RL,
	    SM(R92C_RL_SRL, 0x30) | SM(R92C_RL_LRL, 0x30));

	/* Initialize EDCA parameters. */
	urtwn_edca_init(sc);

	/* Setup rate fallback. */
	if (!(sc->chip & URTWN_CHIP_88E)) {
		urtwn_write_4(sc, R92C_DARFRC + 0, 0x00000000);
		urtwn_write_4(sc, R92C_DARFRC + 4, 0x10080404);
		urtwn_write_4(sc, R92C_RARFRC + 0, 0x04030201);
		urtwn_write_4(sc, R92C_RARFRC + 4, 0x08070605);
	}

	urtwn_write_1(sc, R92C_FWHW_TXQ_CTRL,
	    urtwn_read_1(sc, R92C_FWHW_TXQ_CTRL) |
	    R92C_FWHW_TXQ_CTRL_AMPDU_RTY_NEW);
	/* Set ACK timeout. */
	urtwn_write_1(sc, R92C_ACKTO, 0x40);

	/* Setup USB aggregation. */
	reg = urtwn_read_4(sc, R92C_TDECTRL);
	reg = RW(reg, R92C_TDECTRL_BLK_DESC_NUM, 6);
	urtwn_write_4(sc, R92C_TDECTRL, reg);
	urtwn_write_1(sc, R92C_TRXDMA_CTRL,
	    urtwn_read_1(sc, R92C_TRXDMA_CTRL) |
	    R92C_TRXDMA_CTRL_RXDMA_AGG_EN);
	urtwn_write_1(sc, R92C_RXDMA_AGG_PG_TH, 48);
	if (sc->chip & URTWN_CHIP_88E)
		urtwn_write_1(sc, R92C_RXDMA_AGG_PG_TH + 1, 4);
	else {
		urtwn_write_1(sc, R92C_USB_DMA_AGG_TO, 4);
		urtwn_write_1(sc, R92C_USB_SPECIAL_OPTION,
		    urtwn_read_1(sc, R92C_USB_SPECIAL_OPTION) |
		    R92C_USB_SPECIAL_OPTION_AGG_EN);
		urtwn_write_1(sc, R92C_USB_AGG_TH, 8);
		urtwn_write_1(sc, R92C_USB_AGG_TO, 6);
	}

	/* Initialize beacon parameters. */
	urtwn_write_2(sc, R92C_BCN_CTRL, 0x1010);
	urtwn_write_2(sc, R92C_TBTT_PROHIBIT, 0x6404);
	urtwn_write_1(sc, R92C_DRVERLYINT, 0x05);
	urtwn_write_1(sc, R92C_BCNDMATIM, 0x02);
	urtwn_write_2(sc, R92C_BCNTCFG, 0x660f);

	if (!(sc->chip & URTWN_CHIP_88E)) {
		/* Setup AMPDU aggregation. */
		urtwn_write_4(sc, R92C_AGGLEN_LMT, 0x99997631);	/* MCS7~0 */
		urtwn_write_1(sc, R92C_AGGR_BREAK_TIME, 0x16);
		urtwn_write_2(sc, R92C_MAX_AGGR_NUM, 0x0708);

		urtwn_write_1(sc, R92C_BCN_MAX_ERR, 0xff);
	}

	/* Load 8051 microcode. */
	error = urtwn_load_firmware(sc);
	if (error != 0)
		goto fail;

	/* Initialize MAC/BB/RF blocks. */
	urtwn_mac_init(sc);
	urtwn_bb_init(sc);
	urtwn_rf_init(sc);

	if (sc->chip & URTWN_CHIP_88E) {
		urtwn_write_2(sc, R92C_CR,
		    urtwn_read_2(sc, R92C_CR) | R92C_CR_MACTXEN |
		    R92C_CR_MACRXEN);
	}

	/* Turn CCK and OFDM blocks on. */
	reg = urtwn_bb_read(sc, R92C_FPGA0_RFMOD);
	reg |= R92C_RFMOD_CCK_EN;
	urtwn_bb_write(sc, R92C_FPGA0_RFMOD, reg);
	reg = urtwn_bb_read(sc, R92C_FPGA0_RFMOD);
	reg |= R92C_RFMOD_OFDM_EN;
	urtwn_bb_write(sc, R92C_FPGA0_RFMOD, reg);

	/* Clear per-station keys table. */
	urtwn_cam_init(sc);

	/* Enable hardware sequence numbering. */
	urtwn_write_1(sc, R92C_HWSEQ_CTRL, 0xff);

	/* Perform LO and IQ calibrations. */
	urtwn_iq_calib(sc);
	/* Perform LC calibration. */
	urtwn_lc_calib(sc);

	/* Fix USB interference issue. */
	if (!(sc->chip & URTWN_CHIP_88E)) {
		urtwn_write_1(sc, 0xfe40, 0xe0);
		urtwn_write_1(sc, 0xfe41, 0x8d);
		urtwn_write_1(sc, 0xfe42, 0x80);

		urtwn_pa_bias_init(sc);
	}

	/* Initialize GPIO setting. */
	urtwn_write_1(sc, R92C_GPIO_MUXCFG,
	    urtwn_read_1(sc, R92C_GPIO_MUXCFG) & ~R92C_GPIO_MUXCFG_ENBT);

	/* Fix for lower temperature. */
	if (!(sc->chip & URTWN_CHIP_88E))
		urtwn_write_1(sc, 0x15, 0xe9);

	/* Set default channel. */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	urtwn_set_chan(sc, ic->ic_ibss_chan, NULL);
d1951 1
a1951 1
		data = &sc->rx_data[i];
d1958 1
a1958 1
			goto fail;
a1960 16
	/* We're ready to go. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

#ifdef notyet
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		/* Install WEP keys. */
		for (i = 0; i < IEEE80211_WEP_NKID; i++)
			urtwn_set_key(ic, NULL, &ic->ic_nw_keys[i]);
		urtwn_wait_async(sc);
	}
#endif
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
a1961 3
 fail:
	urtwn_stop(ifp);
	return (error);
d1965 1
a1965 1
urtwn_stop(struct ifnet *ifp)
d1967 2
a1968 17
	struct urtwn_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	int i, s;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	s = splusb();
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	/* Wait for all async commands to complete. */
	urtwn_wait_async(sc);
	splx(s);

	timeout_del(&sc->scan_to);
	timeout_del(&sc->calib_to);
d1980 8
@


1.63
log
@Replace magic number in urtwn(4) with corresponding macro from ic/r92creg.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.62 2016/03/09 22:07:46 stsp Exp $	*/
a547 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.62
log
@Remove pointless function pointers from urtwn(4) softc. They didn't serve
any purpose and the code is shorter when calling the functions directly.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.61 2016/03/07 19:41:50 stsp Exp $	*/
d1368 1
a1368 1
			urtwn_write_1(sc, R92C_LEDCFG2, reg | 0x60);
@


1.61
log
@For rtwn(4) and urtwn(4) inline driver-specific definitions in their
respective .c files.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.60 2016/03/07 18:05:41 stsp Exp $	*/
a177 5
	void				(*sc_rf_write)(struct urtwn_softc *,
					    int, uint8_t, uint32_t);
	int				(*sc_power_on)(struct urtwn_softc *);
	int				(*sc_dma_init)(struct urtwn_softc *);

d344 1
a344 2
void		urtwn_r92c_rf_write(struct urtwn_softc *, int, uint8_t, uint32_t);
void		urtwn_r88e_rf_write(struct urtwn_softc *, int, uint8_t, uint32_t);
d939 1
a939 1
__inline void
d942 1
d944 4
a947 2
	sc->sc_rf_write(sc, chain, addr, val);
}
a948 4
void
urtwn_r92c_rf_write(struct urtwn_softc *sc, int chain, uint8_t addr,
    uint32_t val)
{
d950 1
a950 11
	    SM(R92C_LSSI_PARAM_ADDR, addr) |
	    SM(R92C_LSSI_PARAM_DATA, val));
}

void
urtwn_r88e_rf_write(struct urtwn_softc *sc, int chain, uint8_t addr,
uint32_t val)
{
	urtwn_bb_write(sc, R92C_LSSI_PARAM(chain),
	    SM(R88E_LSSI_PARAM_ADDR, addr) |
	    SM(R92C_LSSI_PARAM_DATA, val));
a1145 4

	sc->sc_rf_write = urtwn_r92c_rf_write;
	sc->sc_power_on = urtwn_r92c_power_on;
	sc->sc_dma_init = urtwn_r92c_dma_init;
a1203 4

	sc->sc_rf_write = urtwn_r88e_rf_write;
	sc->sc_power_on = urtwn_r88e_power_on;
	sc->sc_dma_init = urtwn_r88e_dma_init;
a2401 7
__inline int
urtwn_power_on(struct urtwn_softc *sc)
{

	return sc->sc_power_on(sc);
}

a2750 7
__inline int
urtwn_dma_init(struct urtwn_softc *sc)
{

	return sc->sc_dma_init(sc);
}

d3655 4
a3658 1
	error = urtwn_power_on(sc);
d3663 4
a3666 1
	error = urtwn_dma_init(sc);
@


1.60
log
@Merge TX/RX descriptors used by rtwn(4) and urtwn(4) into common header file.
Based on a larger diff by Mikhail, with small differences in naming things.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.59 2016/03/07 16:17:36 stsp Exp $	*/
d58 167
a224 1
#include <dev/usb/if_urtwnreg.h>
@


1.59
log
@Merge rtwn(4) and urtwn(4) register definitions into a common header file.
Based on a larger diff by Mikhail.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.58 2016/01/05 18:41:16 stsp Exp $	*/
d1749 1
a1749 1
	struct r92c_rx_stat *stat;
d1756 3
a1758 3
	stat = (struct r92c_rx_stat *)buf;
	rxdw0 = letoh32(stat->rxdw0);
	rxdw3 = letoh32(stat->rxdw3);
d1779 1
a1779 1
			rssi = urtwn_r88e_get_rssi(sc, rate, &stat[1]);
d1781 1
a1781 1
			rssi = urtwn_get_rssi(sc, rate, &stat[1]);
d1803 1
a1803 1
	wh = (struct ieee80211_frame *)((uint8_t *)&stat[1] + infosz);
d1867 1
a1867 1
	struct r92c_rx_stat *stat;
d1882 1
a1882 1
	if (__predict_false(len < sizeof(*stat))) {
d1889 2
a1890 2
	stat = (struct r92c_rx_stat *)buf;
	npkts = MS(letoh32(stat->rxdw2), R92C_RXDW2_PKTCNT);
d1895 1
a1895 1
		if (__predict_false(len < sizeof(*stat)))
d1897 2
a1898 2
		stat = (struct r92c_rx_stat *)buf;
		rxdw0 = letoh32(stat->rxdw0);
d1907 1
a1907 1
		totlen = sizeof(*stat) + infosz + pktlen;
d1966 1
a1966 1
	struct r92c_tx_desc *txd;
d2000 1
a2000 1
	txd = (struct r92c_tx_desc *)data->buf;
@


1.58
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.57 2015/11/25 03:10:00 dlg Exp $	*/
d57 1
d1142 1
a1142 1
	cmd.macid = URTWN_MACID_BC | URTWN_MACID_VALID;
d1152 1
a1152 1
	urtwn_write_1(sc, R92C_INIDATA_RATE_SEL(URTWN_MACID_BC),
d1156 1
a1156 1
	cmd.macid = URTWN_MACID_BSS | URTWN_MACID_VALID;
d1166 1
a1166 1
	urtwn_write_1(sc, R92C_INIDATA_RATE_SEL(URTWN_MACID_BSS),
d2036 1
a2036 1
			    SM(R88E_TXDW1_MACID, URTWN_MACID_BSS) |
d2042 1
a2042 1
			    SM(R92C_TXDW1_MACID, URTWN_MACID_BSS) |
d2775 1
a2775 1
	const struct urtwn_bb_prog *prog;
d2893 1
a2893 1
	const struct urtwn_rf_prog *prog;
d3099 1
a3099 1
	const struct urtwn_txpwr *base;
d3197 1
a3197 1
	const struct urtwn_r88e_txpwr *base;
@


1.57
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.56 2015/11/24 13:45:07 mpi Exp $	*/
a353 1
#ifndef IEEE80211_NO_HT
a360 1
#endif
a3292 1
#ifndef IEEE80211_NO_HT
d3331 1
a3331 3
	} else
#endif
	{
@


1.56
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.55 2015/11/24 13:33:18 mpi Exp $	*/
d1953 2
a1954 2
	if (ifp->if_flags & IFF_OACTIVE) {
		ifp->if_flags &= ~IFF_OACTIVE;
d2134 1
a2134 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d2139 1
a2139 1
			ifp->if_flags |= IFF_OACTIVE;
a3699 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3701 1
d3730 2
a3731 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.55
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.54 2015/11/04 12:12:00 dlg Exp $	*/
a42 1
#include <net/if_arp.h>
@


1.54
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.53 2015/10/25 12:11:56 mpi Exp $	*/
a45 1
#include <net/if_types.h>
@


1.53
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.52 2015/09/18 11:24:15 mpi Exp $	*/
d2145 1
a2145 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.52
log
@Remove unused variables, from Michael McConville.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.51 2015/09/10 11:53:05 stsp Exp $	*/
a2202 1
	struct ifaddr *ifa;
a2214 1
		ifa = (struct ifaddr *)data;
a2215 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.51
log
@Show usb stack error code if a firmware page fails to load in urtwn(4).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.50 2015/08/24 04:07:38 jsg Exp $	*/
d2716 1
a2716 1
	int nrempages, nqpages, nqueues = 1;
a2726 5

	/* Get the number of pages for each queue. */
	nqpages = (R92C_TX_PAGE_COUNT - R92C_PUBQ_NPAGES) / nqueues;
	/* The remaining pages are assigned to the high priority queue. */
	nrempages = (R92C_TX_PAGE_COUNT - R92C_PUBQ_NPAGES) % nqueues;
@


1.50
log
@Add some additional urtwn ids found in the linux rtl8192cu driver.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.49 2015/08/22 15:19:33 stsp Exp $	*/
d2578 2
a2579 2
			printf("%s: could not load firmware page %d\n",
			    sc->sc_dev.dv_xname, page);
@


1.49
log
@Make urtwn(4) attach to Netgear WNA1000Mv2. From Mark Willson.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.48 2015/06/12 15:47:31 mpi Exp $	*/
d112 1
d132 2
d141 1
d147 1
@


1.48
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tests & ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.47 2015/05/12 11:46:15 stsp Exp $	*/
d113 1
@


1.47
log
@Merge various urtwn(4) fixes from FreeBSD:
Match additional devices (RTL8188CU_3, DWA123D1, DWA125D1).
Fix efuse reading (fixes potential error in MAC address read from efuse).
Replace some magic numbers with macros.

Based on FreeBSD r270191, r273589, r281918, r281592, r282119, and r282623
via Mikhail mp39590@@gmail on tech@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.46 2015/05/10 19:40:56 stsp Exp $	*/
d276 1
a276 1
	if (uaa->iface != NULL)
d280 1
a280 1
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d293 1
a297 14

	if (usbd_set_config_no(sc->sc_udev, 1, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Get the first interface handle. */
	error = usbd_device2interface_handle(sc->sc_udev, 0, &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.46
log
@Fix urtwn(4) 11b performance for RTL8188EU devices.
With 11b APs the firmware retries excessively unless we force it into
11b-only mode instead of mixed b/g. Perhaps a firmware bug, perhaps
a bug in our code elsewhere. For now, this makes it work.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.45 2015/05/10 15:10:46 stsp Exp $	*/
d129 1
d147 3
d312 4
a315 1
	if (uaa->product == USB_PRODUCT_REALTEK_RTL8188EU ||
d932 2
d941 2
d1028 1
a1028 1
	while (addr < 1024) {
d1054 2
d1194 1
a1194 1
	/* 
a2369 1
	uint8_t val;
d2375 1
a2375 2
		val = urtwn_read_1(sc, 0x6) & 0x2;
		if (val == 0x2)
d2390 2
a2391 1
	urtwn_write_1(sc, 0x26, urtwn_read_1(sc, 0x26) | 0x80);
d2395 2
d2399 3
a2401 1
	urtwn_write_1(sc, 0x5, urtwn_read_1(sc, 0x5) & ~0x18);
d2403 2
a2404 1
	urtwn_write_1(sc, 0x5, urtwn_read_1(sc, 0x5) | 0x1);
d2406 2
a2407 1
		if (!(urtwn_read_1(sc, 0x5) & 0x1))
d2415 2
a2416 1
	urtwn_write_1(sc, 0x23, urtwn_read_1(sc, 0x23) & ~0x10);
@


1.45
log
@My commit adding RTL8188EU did introduce a regression after all.
Repair firmware reset on RTL8188CUS devices (and perhaps others) by
restoring the proper register write order in the non-8188EU code path.
Fixes "urtwn0: timeout waiting for firmware readiness" after device reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.44 2015/05/04 11:46:29 stsp Exp $	*/
d187 4
a1089 1
	struct r92c_fw_cmd_macid_cfg cmd;
d1120 18
d1166 22
a1187 2
	/* Indicate highest supported rate. */
	ni->ni_txrate = rs->rs_nrates - 1;
d1356 3
d1464 2
a1465 4
		if (sc->chip & URTWN_CHIP_88E)
			ni->ni_txrate = ni->ni_rates.rs_nrates-1;
		else
			urtwn_ra_init(sc);
d2026 2
a2027 1
		if (ic->ic_curmode == IEEE80211_MODE_11B)
@


1.44
log
@Add support for RTL8188EU chips to urtwn(4).

Patch by Mikhail <mp39590@@gmail.com>, based on FreeBSD r264912 by kevlo.

Tested with 8188EU (TP-Link TL-WN725N). No regression on 8188CUS.
There are performance problems with 8188EU devices, cause unknown.
These will hopefully be resolved soon.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.43 2015/03/14 03:38:49 jsg Exp $	*/
a2415 3
	urtwn_write_2(sc, R92C_SYS_FUNC_EN,
	    urtwn_read_2(sc, R92C_SYS_FUNC_EN) |
	    R92C_SYS_FUNC_EN_CPUEN);
d2505 4
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.42 2015/02/10 23:25:46 mpi Exp $	*/
d5 1
d21 1
a21 1
 * Driver for Realtek RTL8188CE-VAU/RTL8188CUS/RTL8188RU/RTL8192CU.
d144 4
a147 1
	{ USB_VENDOR_ZYXEL,	USB_PRODUCT_ZYXEL_RTL8192CU }
d174 2
a175 1
void		urtwn_rf_write(struct urtwn_softc *, int, uint8_t, uint32_t);
d181 1
d184 1
d205 1
d216 2
a217 1
int		urtwn_power_on(struct urtwn_softc *);
d220 1
d223 2
a224 1
int		urtwn_dma_init(struct urtwn_softc *);
d236 3
d304 4
d322 5
a326 1
	urtwn_read_rom(sc);
d331 1
d778 7
d786 2
a787 1
urtwn_rf_write(struct urtwn_softc *sc, int chain, uint8_t addr, uint32_t val)
d794 9
d891 2
a892 16
	reg = urtwn_read_2(sc, R92C_SYS_ISO_CTRL);
	if (!(reg & R92C_SYS_ISO_CTRL_PWC_EV12V)) {
		urtwn_write_2(sc, R92C_SYS_ISO_CTRL,
		    reg | R92C_SYS_ISO_CTRL_PWC_EV12V);
	}
	reg = urtwn_read_2(sc, R92C_SYS_FUNC_EN);
	if (!(reg & R92C_SYS_FUNC_EN_ELDR)) {
		urtwn_write_2(sc, R92C_SYS_FUNC_EN,
		    reg | R92C_SYS_FUNC_EN_ELDR);
	}
	reg = urtwn_read_2(sc, R92C_SYS_CLKR);
	if ((reg & (R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M)) !=
	    (R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M)) {
		urtwn_write_2(sc, R92C_SYS_CLKR,
		    reg | R92C_SYS_CLKR_LOADER_EN | R92C_SYS_CLKR_ANA8M);
	}
d923 23
d951 3
d991 1
d993 63
a1055 1
	IEEE80211_ADDR_COPY(ic->ic_myaddr, rom->macaddr);
d1181 18
a1198 5
		reg = urtwn_read_1(sc, R92C_LEDCFG0) & 0x70;
		if (!on)
			reg |= R92C_LEDCFG0_DIS;
		urtwn_write_1(sc, R92C_LEDCFG0, reg);
		sc->ledlink = on;	/* Save LED state. */
d1333 5
a1337 3
			reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(1));
			reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x20);
			urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(1), reg);
d1358 5
a1362 3
		reg = urtwn_bb_read(sc, R92C_OFDM0_AGCCORE1(1));
		reg = RW(reg, R92C_OFDM0_AGCCORE1_GAIN, 0x32);
		urtwn_bb_write(sc, R92C_OFDM0_AGCCORE1(1), reg);
d1420 4
a1423 1
		urtwn_ra_init(sc);
d1594 15
a1608 13
	if (rate <= 3) {
		/* CCK gain is smaller than OFDM/MCS gain. */
		pwdb += 6;
		if (pwdb > 100)
			pwdb = 100;
		if (pwdb <= 14)
			pwdb -= 4;
		else if (pwdb <= 26)
			pwdb -= 8;
		else if (pwdb <= 34)
			pwdb -= 6;
		else if (pwdb <= 42)
			pwdb -= 2;
d1645 51
d1733 4
a1736 1
		rssi = urtwn_get_rssi(sc, rate, &stat[1]);
d1988 12
a1999 5
		txd->txdw1 |= htole32(
		    SM(R92C_TXDW1_MACID, URTWN_MACID_BSS) |
		    SM(R92C_TXDW1_QSEL, R92C_TXDW1_QSEL_BE) |
		    SM(R92C_TXDW1_RAID, raid) |
		    R92C_TXDW1_AGGBK);
d2219 7
d2227 1
a2227 1
urtwn_power_on(struct urtwn_softc *sc)
d2312 56
d2370 6
a2375 1
	int i, error;
d2377 2
a2378 2
	/* Reserve pages [0; R92C_TX_PAGE_COUNT]. */
	for (i = 0; i < R92C_TX_PAGE_COUNT; i++) {
d2386 1
a2386 1
	 * Use pages [R92C_TX_PAGE_COUNT + 1; R92C_TXPKTBUF_COUNT - 1]
d2389 1
a2389 1
	for (++i; i < R92C_TXPKTBUF_COUNT - 1; i++) {
d2394 1
a2394 1
	error = urtwn_llt_write(sc, i, R92C_TX_PAGE_COUNT + 1);
d2416 14
d2471 4
a2474 2
	if ((sc->chip & (URTWN_CHIP_UMC_A_CUT | URTWN_CHIP_92C)) ==
	    URTWN_CHIP_UMC_A_CUT)
d2492 1
d2501 5
a2505 2
	if (urtwn_read_1(sc, R92C_MCUFWDL) & 0x80) {
		urtwn_fw_reset(sc);
d2508 1
a2508 3
	urtwn_write_2(sc, R92C_SYS_FUNC_EN,
	    urtwn_read_2(sc, R92C_SYS_FUNC_EN) |
	    R92C_SYS_FUNC_EN_CPUEN);
d2549 2
d2568 7
d2576 1
a2576 1
urtwn_dma_init(struct urtwn_softc *sc)
d2655 54
d2715 11
a2725 2
	for (i = 0; i < nitems(rtl8192cu_mac); i++)
		urtwn_write_1(sc, rtl8192cu_mac[i].reg, rtl8192cu_mac[i].val);
d2733 1
d2742 2
a2743 1
	urtwn_write_2(sc, R92C_AFE_PLL_CTRL, 0xdb83);
d2751 5
a2755 3
	urtwn_write_1(sc, R92C_LDOHCI12_CTRL, 0x0f);
	urtwn_write_1(sc, 0x15, 0xe9);
	urtwn_write_1(sc, R92C_AFE_XTAL_CTRL + 1, 0x80);
d2758 3
a2760 1
	if (!(sc->chip & URTWN_CHIP_92C)) {
d2825 19
a2843 3
	if (urtwn_bb_read(sc, R92C_HSSI_PARAM2(0)) &
	    R92C_HSSI_PARAM2_CCK_HIPWR)
		sc->sc_flags |= URTWN_FLAG_CCK_HIPWR;
d2854 3
a2856 1
	if (!(sc->chip & URTWN_CHIP_92C)) {
d3147 69
d3224 4
a3227 1
		urtwn_get_txpower(sc, i, c, extc, power);
d3300 5
a3304 3
		urtwn_bb_write(sc, R92C_FPGA0_ANAPARAM2,
		    urtwn_bb_read(sc, R92C_FPGA0_ANAPARAM2) |
		    R92C_FPGA0_ANAPARAM2_CBW20);
d3308 3
a3310 1
		    (sc->rf_chnlbw[0] & ~0xfff) | R92C_RF_CHNLBW_BW20 | chan);
d3485 1
d3500 13
a3512 2
	urtwn_write_4(sc, R92C_HISR, 0xffffffff);
	urtwn_write_4(sc, R92C_HIMR, 0xffffffff);
d3538 6
a3543 4
	urtwn_write_4(sc, R92C_DARFRC + 0, 0x00000000);
	urtwn_write_4(sc, R92C_DARFRC + 4, 0x10080404);
	urtwn_write_4(sc, R92C_RARFRC + 0, 0x04030201);
	urtwn_write_4(sc, R92C_RARFRC + 4, 0x08070605);
a3557 3
	urtwn_write_1(sc, R92C_USB_SPECIAL_OPTION,
	    urtwn_read_1(sc, R92C_USB_SPECIAL_OPTION) |
	    R92C_USB_SPECIAL_OPTION_AGG_EN);
d3559 10
a3568 3
	urtwn_write_1(sc, R92C_USB_DMA_AGG_TO, 4);
	urtwn_write_1(sc, R92C_USB_AGG_TH, 8);
	urtwn_write_1(sc, R92C_USB_AGG_TO, 6);
d3571 1
d3577 5
a3581 4
	/* Setup AMPDU aggregation. */
	urtwn_write_4(sc, R92C_AGGLEN_LMT, 0x99997631);	/* MCS7~0 */
	urtwn_write_1(sc, R92C_AGGR_BREAK_TIME, 0x16);
	urtwn_write_2(sc, 0x4ca, 0x0708);
d3583 2
a3584 2
	urtwn_write_1(sc, R92C_BCN_MAX_ERR, 0xff);
	urtwn_write_1(sc, R92C_BCN_CTRL, R92C_BCN_CTRL_DIS_TSF_UDT0);
d3596 6
d3622 4
a3625 3
	urtwn_write_1(sc, 0xfe40, 0xe0);
	urtwn_write_1(sc, 0xfe41, 0x8d);
	urtwn_write_1(sc, 0xfe42, 0x80);
d3627 2
a3628 1
	urtwn_pa_bias_init(sc);
d3635 2
a3636 1
	urtwn_write_1(sc, 0x15, 0xe9);
@


1.42
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.41 2015/02/07 21:21:44 mpi Exp $	*/
a35 1
#include <machine/bus.h>
@


1.41
log
@Fix a logic error when enabling MAC and reset the checksum report bit
before loading page, from FreBSD r262822 and r263154.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.40 2014/12/22 02:28:52 tedu Exp $	*/
a1567 1
	m->m_pkthdr.rcvif = ifp;
@


1.40
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.39 2014/12/19 22:44:59 guenther Exp $	*/
d2061 2
a2062 2
		if (urtwn_read_2(sc, R92C_APS_FSMCO) &
		    R92C_APS_FSMCO_APFM_ONMAC)
d2231 4
@


1.39
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.38 2014/07/13 15:52:49 mpi Exp $	*/
a1972 1
#ifdef INET
a1974 1
#endif
@


1.38
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.37 2014/07/12 18:48:52 tedu Exp $	*/
d34 1
a36 1
#include <machine/endian.h>
@


1.37
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.36 2014/07/12 07:59:23 mpi Exp $	*/
a48 1
#include <netinet/in_systm.h>
a49 1
#include <netinet/ip.h>
@


1.36
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.35 2014/03/19 10:09:19 mpi Exp $	*/
d2280 1
a2280 1
	free(fw, M_DEVBUF);
@


1.35
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.34 2014/03/14 15:00:47 mpi Exp $	*/
a151 1
int		urtwn_activate(struct device *, int);
d249 1
a249 5
	sizeof(struct urtwn_softc),
	urtwn_match,
	urtwn_attach,
	urtwn_detach,
	urtwn_activate
a427 13
	return (0);
}

int
urtwn_activate(struct device *self, int act)
{
	struct urtwn_softc *sc = (struct urtwn_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.34
log
@Add the ISY IWL 4000 a new urtwn(4) device, from Fabian Raetz and
Peter J. Philipp.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.33 2014/03/07 18:39:02 mpi Exp $	*/
d1922 1
a1922 1
			ni = (void *)m->m_pkthdr.rcvif;
@


1.33
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.32 2013/09/30 05:18:57 jsg Exp $	*/
d87 1
@


1.32
log
@add some additional run(4)/urtwn(4) devices found in FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.31 2013/09/30 03:59:56 jsg Exp $	*/
a61 4

#ifdef USB_DEBUG
#define URTWN_DEBUG
#endif
@


1.31
log
@Add ISY IWL 2000, another RTL8188CUS/urtwn(4)
from Maximilian Fillinger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.30 2013/08/20 04:52:00 jsg Exp $	*/
d100 1
d106 1
a106 1
	{ USB_VENDOR_EDIMAX,	USB_PRODUCT_EDIMAX_RTL8188CU },
@


1.30
log
@add some urtwn device ids found in the windows driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.29 2013/08/19 14:12:44 jsg Exp $	*/
d89 1
@


1.29
log
@Add IO-DATA WN-G150UM from William Dunand.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.28 2013/08/07 01:06:43 bluhm Exp $	*/
d81 2
d90 1
d96 2
d103 1
d109 1
d111 1
d114 1
d118 1
d143 2
@


1.28
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.27 2013/07/21 15:19:52 deraadt Exp $	*/
d105 1
@


1.27
log
@Belkin N300 XR; Daryl Turner
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.26 2013/05/16 09:31:55 sthen Exp $	*/
a49 1
#include <netinet/in_var.h>
@


1.26
log
@attach to new RTL8188RU id, from Sigi Rudzio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.25 2013/04/15 09:23:01 mglocker Exp $	*/
d86 1
@


1.25
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.24 2013/03/29 07:43:52 brad Exp $	*/
d125 1
@


1.24
log
@Fix building on the RAMDISK media. This was exposed by SMALL_KERNEL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.23 2012/09/17 15:14:14 yasuoka Exp $	*/
d190 1
a190 1
void		urtwn_rxeof(usbd_xfer_handle, usbd_private_handle,
d192 1
a192 1
void		urtwn_txeof(usbd_xfer_handle, usbd_private_handle,
d1635 1
a1635 1
urtwn_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d1701 1
a1701 1
urtwn_txeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d1740 1
a1740 1
	usbd_pipe_handle pipe;
@


1.23
log
@Bit field name was confused.  Not MCS08 but MCS09.

diff from Masanobu SAITOH.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.22 2012/04/08 12:17:20 jsg Exp $	*/
a2792 1
	uint32_t reg;
d2807 2
@


1.22
log
@additional urtwn device ids found in the linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.21 2012/04/08 03:09:59 deraadt Exp $	*/
d2664 1
a2664 1
	    SM(R92C_TXAGC_MCS08,  power[21]) |
@


1.21
log
@match BELKIN F7D2102; from Seth Jackson
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.20 2011/11/26 06:39:33 ckuethe Exp $	*/
d81 1
d84 1
d87 6
d103 1
d106 2
d111 3
d117 1
d121 2
d124 1
d129 2
d132 1
@


1.20
log
@add Netgear WNA100M
urtwn0 at uhub0 port 1 "Realtek 802.11n WLAN Adapter" rev 2.00/2.00 addr 2
urtwn0: MAC/BB RTL8188CUS, RF 6052 1T1R, address c4:3d:c7:....
ok gray
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.19 2011/10/29 12:18:14 gsoares Exp $	*/
d83 1
@


1.19
log
@avoid an out-of-bounds array access in urtwn_iq_calib_chain();
(this function is not yet called)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.18 2011/07/03 15:47:17 matthew Exp $	*/
d95 1
@


1.18
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.17 2011/06/19 17:55:37 jsg Exp $	*/
d2893 3
a2895 3
	rx[2] = (urtwn_bb_read(sc, 0xea4 + offset) >> 16) & 0x3ff;
	rx[3] = (urtwn_bb_read(sc, 0xeac + offset) >> 16) & 0x3ff;
	if (rx[2] == 0x132 || rx[3] == 0x036)
@


1.17
log
@fix up unbalanced format strings
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.16 2011/02/10 17:26:40 jakemsr Exp $	*/
a405 2
	case DVACT_ACTIVATE:
		break;
@


1.16
log
@now that usb_wait_task() is back, bring back recently reverted
changes:

* use usb_ref_{incr,decr,wait}() to avoid detaching the driver while a
  process is still using the hardware.
* don't add timeout(9)s if the device is detached.
* add checks to see if the device has been detached before running
  ioctls, timeouts, and tasks.
* use usb_wait_task() to wait for tasks to complete.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.15 2011/02/09 04:25:32 jakemsr Exp $	*/
d2225 1
a2225 1
			    sc->sc_dev.dv_xname);
@


1.15
log
@revert usb.c to r1.72, and all subsequent changes that depend on it.
this is causing problems with suspend/resume for some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.14 2011/02/05 18:10:44 jakemsr Exp $	*/
d372 1
a372 3
	s = splnet();
	/* Wait for all async commands to complete. */
	urtwn_wait_async(sc);
d378 6
a598 1
	wakeup(ring);
d627 1
a627 2
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
d1066 5
d1073 2
d1095 2
a1096 1
	timeout_add_sec(&sc->calib_to, 2);
d1106 5
d1115 2
d1205 2
a1206 1
		timeout_add_msec(&sc->scan_to, 200);
d1284 2
a1285 1
		timeout_add_sec(&sc->calib_to, 2);
d1948 5
d2005 3
@


1.14
log
@* use usb_ref_{incr,decr,wait}() to avoid detaching the driver while a
  process is still using the hardware.
* don't add timeout(9)s if the device is detached.
* add checks to see if the device has been detached before running
  ioctls, timeouts, and tasks.
* use usb_wait_task() to wait for tasks to complete.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.13 2011/01/25 20:03:35 jakemsr Exp $	*/
d372 3
a374 1
	s = splusb();
a379 6

	/* Wait for all async commands to complete. */
	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

d595 1
d624 2
a625 1
	usb_wait_task(sc->sc_udev, &sc->sc_task);
a1063 5
	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

a1065 2

	usbd_ref_decr(sc->sc_udev);
d1086 1
a1086 2
	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->calib_to, 2);
a1095 5
	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

a1099 2

	usbd_ref_decr(sc->sc_udev);
d1188 1
a1188 2
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
d1266 1
a1266 2
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_sec(&sc->calib_to, 2);
a1928 5
	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);

a1980 3

	usbd_ref_decr(sc->sc_udev);

@


1.13
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.12 2010/12/31 20:50:14 damien Exp $	*/
d372 1
a372 3
	s = splnet();
	/* Wait for all async commands to complete. */
	urtwn_wait_async(sc);
d378 6
a598 1
	wakeup(ring);
d627 1
a627 2
	while (sc->cmdq.queued > 0)
		tsleep(&sc->cmdq, 0, "cmdq", 0);
d1066 5
d1073 2
d1095 2
a1096 1
	timeout_add_sec(&sc->calib_to, 2);
d1106 5
d1115 2
d1205 2
a1206 1
		timeout_add_msec(&sc->scan_to, 200);
d1284 2
a1285 1
		timeout_add_sec(&sc->calib_to, 2);
d1948 5
d2005 3
@


1.12
log
@grrr... use the same style in the activate functions than in the
surrounding code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.11 2010/12/27 03:03:50 jakemsr Exp $	*/
a362 2

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);
a392 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.11
log
@* add cfattach activate functions and call usbd_deactivate() in the
  DVACT_DEACTIVATE case for drivers that don't have activate finctions
* fill out cfattach activate functions and call usbd_deactivate() in
  the DVACT_DEACTIVATE case for drivers that don't have a dying flag

"ok with the intent" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.10 2010/12/11 21:07:38 damien Exp $	*/
a406 1

d411 1
a411 2

	return 0;
@


1.10
log
@drop Rx'd frames larger than MCLBYTES.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.9 2010/12/11 13:27:27 damien Exp $	*/
d116 1
d217 2
a218 1
	urtwn_detach
d397 17
@


1.9
log
@rxi_flags was used uninitialized, and in some cases, received frames
were dropped.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.8 2010/12/07 17:03:19 damien Exp $	*/
d1489 1
a1489 2
	if (__predict_false(pktlen < sizeof(*wh))) {
		ic->ic_stats.is_rx_tooshort++;
@


1.8
log
@remove useless #include
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.7 2010/11/16 19:28:56 damien Exp $	*/
d1572 1
@


1.7
log
@attach FeiXun products.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.6 2010/11/16 18:02:59 damien Exp $	*/
a54 1
#include <net80211/ieee80211_amrr.h>
@


1.6
log
@periodically measure temperature and redo LC calibration if temperature
changes significantly since last LC calibration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.5 2010/11/15 18:56:13 damien Exp $	*/
d92 2
d2936 1
a2936 1
		/* LC calibration was performed in urtwn_init(). */
@


1.5
log
@print board type in human readable form in dmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.4 2010/11/06 12:27:43 damien Exp $	*/
d199 1
d1068 3
d1247 3
d2907 35
@


1.4
log
@print the MAC address on the second line like with the other USB
802.11 drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.3 2010/11/05 17:57:10 damien Exp $	*/
d274 7
a280 3
	printf("%s: board type 0x%x, RF 6052 %dT%dR, address %s\n",
	    sc->sc_dev.dv_xname, sc->board_type, sc->ntxchains,
	    sc->nrxchains, ether_sprintf(ic->ic_myaddr));
d1022 1
a1022 1
	urtwn_write_4(sc, R92C_TSFTR, tsf);
d2521 1
a2521 1
	urtwn_write_4(sc, R92C_MAR, 0xffffffff);
@


1.3
log
@s/urtw_devs/urtwn_devs/
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.2 2010/11/05 17:26:38 damien Exp $	*/
d245 2
a246 1
		printf(": could not set configuration no\n");
d253 2
a254 1
		printf(": could not get interface handle\n");
d260 1
a260 1
		printf(": unsupported test chip\n");
d274 3
a276 4
	printf(", %s\n", ether_sprintf(ic->ic_myaddr));
	printf("%s: board type 0x%x, ROM ver %d, RF 6052 %dT%dR\n",
	    sc->sc_dev.dv_xname, sc->board_type, sc->rom.version,
	    sc->ntxchains, sc->nrxchains);
d731 1
a731 1
	uint32_t reg[2], val;
@


1.2
log
@double \n\n in dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtwn.c,v 1.1 2010/11/05 16:58:12 damien Exp $	*/
d78 1
a78 1
static const struct usb_devno urtw_devs[] = {
d225 1
a225 1
	return ((usb_lookup(urtw_devs, uaa->vendor, uaa->product) != NULL) ?
@


1.1
log
@urtwn(4), a driver for Realtek RTL8188CU/RTL8192CU 802.11n USB devices.
these devices are different from the RTL8191SU/RTL8192SU ones that are
not supported by this driver.
requires a firmware (urtwn-firmware-1.0)

committed over a Hercules HWNUp-150 (RTL8188CU).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d273 1
a273 1
	printf("%s: board type 0x%x, ROM ver %d, RF 6052 %dT%dR\n\n",
@

