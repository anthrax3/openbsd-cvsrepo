head	1.82;
access;
symbols
	OPENBSD_6_2_BASE:1.82
	OPENBSD_6_1:1.82.0.4
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.79.0.2
	OPENBSD_5_9_BASE:1.79
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.66.0.2
	OPENBSD_5_4_BASE:1.66
	OPENBSD_5_3:1.64.0.2
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.63.0.6
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.4
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.61.0.2
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.55.0.4
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.6
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.2
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.50.0.4
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.33.0.4
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	SMP:1.10.0.4
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	UBC_SYNC_B:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	UBC:1.4.0.2;
locks; strict;
comment	@ * @;


1.82
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.81;
commitid	VyLWTsbepAOk7VQM;

1.81
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.80;
commitid	xlY19nmD0cBL53l1;

1.80
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.79;
commitid	gWZDkudwxydTq8x4;

1.79
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.78;
commitid	B0kwmVGiD5DVx4kv;

1.78
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.77;
commitid	5gdEnqVoJuTuwdTu;

1.77
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.76;
commitid	eYnPulzvLjDImPCa;

1.76
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.75;
commitid	pwYnMC1gOKohmeGw;

1.75
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.74;
commitid	MVWrtktB46JRxFWT;

1.74
date	2015.03.27.19.20.56;	author uaa;	state Exp;
branches;
next	1.73;
commitid	kiMNzSBgGkmFbj4r;

1.73
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.72;
commitid	p4LJxGKbi0BU2cG6;

1.72
date	2015.02.12.09.08.47;	author mpi;	state Exp;
branches;
next	1.71;
commitid	aRXIfiDqABgFwngb;

1.71
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.70;
commitid	yM2VFFhpDTeFQlve;

1.70
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.69;
commitid	Pclvgy2Z4XV9hveD;

1.69
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.68;
commitid	b0VSac5dnnsxcDao;

1.68
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.67;

1.67
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2013.01.29.11.06.38;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.59;

1.59
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.58;

1.58
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2010.08.27.07.08.22;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.06.02.32.29;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2008.10.03.20.25.29;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.50;

1.50
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.11.05.42.54;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.06.04.08.47;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2006.07.14.23.07.26;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.30;

1.30
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.06.17.29.11;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.23.10.24.51;	author grunk;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.19.11.42.37;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.02.22.17.58;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.03.07.16.53;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.17.05.00.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.16.01.28.45;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.29.09.51.07;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.23.09.16.11;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.27.20.10.52;	author jason;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.29.22.49.10;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.26.11.29.55;	author espie;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.09.16.13.31;	author nate;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.05.07.19.32.49;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;

1.10.4.1
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.82
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_url.c,v 1.81 2016/11/06 12:58:01 mpi Exp $ */
/*	$NetBSD: if_url.c,v 1.6 2002/09/29 10:19:21 martin Exp $	*/
/*
 * Copyright (c) 2001, 2002
 *     Shingo WATANABE <nabe@@nabechan.org>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * The RTL8150L(Realtek USB to fast ethernet controller) spec can be found at
 *   ftp://ftp.realtek.com.tw/lancard/data_sheet/8150/8150v14.pdf
 *   ftp://152.104.125.40/lancard/data_sheet/8150/8150v14.pdf
 */

/*
 * TODO:
 *	Interrupt Endpoint support
 *	External PHYs
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/urlphyreg.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_urlreg.h>

int url_match(struct device *, void *, void *);
void url_attach(struct device *, struct device *, void *);
int url_detach(struct device *, int);

struct cfdriver url_cd = {
	NULL, "url", DV_IFNET
};

const struct cfattach url_ca = {
	sizeof(struct url_softc), url_match, url_attach, url_detach
};

int url_openpipes(struct url_softc *);
int url_rx_list_init(struct url_softc *);
int url_tx_list_init(struct url_softc *);
int url_newbuf(struct url_softc *, struct url_chain *, struct mbuf *);
void url_start(struct ifnet *);
int url_send(struct url_softc *, struct mbuf *, int);
void url_txeof(struct usbd_xfer *, void *, usbd_status);
void url_rxeof(struct usbd_xfer *, void *, usbd_status);
void url_tick(void *);
void url_tick_task(void *);
int url_ioctl(struct ifnet *, u_long, caddr_t);
void url_stop_task(struct url_softc *);
void url_stop(struct ifnet *, int);
void url_watchdog(struct ifnet *);
int url_ifmedia_change(struct ifnet *);
void url_ifmedia_status(struct ifnet *, struct ifmediareq *);
void url_lock_mii(struct url_softc *);
void url_unlock_mii(struct url_softc *);
int url_int_miibus_readreg(struct device *, int, int);
void url_int_miibus_writereg(struct device *, int, int, int);
void url_miibus_statchg(struct device *);
int url_init(struct ifnet *);
void url_iff(struct url_softc *);
void url_reset(struct url_softc *);

int url_csr_read_1(struct url_softc *, int);
int url_csr_read_2(struct url_softc *, int);
int url_csr_write_1(struct url_softc *, int, int);
int url_csr_write_2(struct url_softc *, int, int);
int url_csr_write_4(struct url_softc *, int, int);
int url_mem(struct url_softc *, int, int, void *, int);

/* Macros */
#ifdef URL_DEBUG
#define DPRINTF(x)	do { if (urldebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (urldebug >= (n)) printf x; } while (0)
int urldebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define	URL_SETBIT(sc, reg, x)	\
	url_csr_write_1(sc, reg, url_csr_read_1(sc, reg) | (x))

#define	URL_SETBIT2(sc, reg, x)	\
	url_csr_write_2(sc, reg, url_csr_read_2(sc, reg) | (x))

#define	URL_CLRBIT(sc, reg, x)	\
	url_csr_write_1(sc, reg, url_csr_read_1(sc, reg) & ~(x))

#define	URL_CLRBIT2(sc, reg, x)	\
	url_csr_write_2(sc, reg, url_csr_read_2(sc, reg) & ~(x))

static const struct url_type {
	struct usb_devno url_dev;
	u_int16_t url_flags;
#define URL_EXT_PHY	0x0001
} url_devs [] = {
	{{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_LCS8138TX}, 0},
	{{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_RTL8151}, 0},
	{{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUAKTX }, 0},
	{{ USB_VENDOR_MICRONET, USB_PRODUCT_MICRONET_SP128AR}, 0},
	{{ USB_VENDOR_OQO, USB_PRODUCT_OQO_ETHER01}, 0},
	{{ USB_VENDOR_REALTEK, USB_PRODUCT_REALTEK_RTL8150}, 0},
	{{ USB_VENDOR_REALTEK, USB_PRODUCT_REALTEK_RTL8151}, 0},
	{{ USB_VENDOR_ZYXEL, USB_PRODUCT_ZYXEL_PRESTIGE}, 0}
};
#define url_lookup(v, p) ((struct url_type *)usb_lookup(url_devs, v, p))


/* Probe */
int
url_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != URL_CONFIG_NO)
		return (UMATCH_NONE);

	return (url_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}
/* Attach */
void
url_attach(struct device *parent, struct device *self, void *aux)
{
	struct url_softc *sc = (struct url_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	struct usbd_interface *iface;
	usbd_status err;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	char *devname = sc->sc_dev.dv_xname;
	struct ifnet *ifp;
	struct mii_data *mii;
	u_char eaddr[ETHER_ADDR_LEN];
	int i, s;

	sc->sc_udev = dev;

	usb_init_task(&sc->sc_tick_task, url_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->sc_mii_lock, "urlmii");
	usb_init_task(&sc->sc_stop_task, (void (*)(void *)) url_stop_task, sc,
	    USB_TASK_TYPE_GENERIC);

	/* get control interface */
	err = usbd_device2interface_handle(dev, URL_IFACE_INDEX, &iface);
	if (err) {
		printf("%s: failed to get interface, err=%s\n", devname,
		       usbd_errstr(err));
		goto bad;
	}

	sc->sc_ctl_iface = iface;
	sc->sc_flags = url_lookup(uaa->vendor, uaa->product)->url_flags;

	/* get interface descriptor */
	id = usbd_get_interface_descriptor(sc->sc_ctl_iface);

	/* find endpoints */
	sc->sc_bulkin_no = sc->sc_bulkout_no = sc->sc_intrin_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_ctl_iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get endpoint %d\n", devname, i);
			goto bad;
		}
		if ((ed->bmAttributes & UE_XFERTYPE) == UE_BULK &&
		    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
			sc->sc_bulkin_no = ed->bEndpointAddress; /* RX */
		else if ((ed->bmAttributes & UE_XFERTYPE) == UE_BULK &&
			 UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT)
			sc->sc_bulkout_no = ed->bEndpointAddress; /* TX */
		else if ((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT &&
			 UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
			sc->sc_intrin_no = ed->bEndpointAddress; /* Status */
	}

	if (sc->sc_bulkin_no == -1 || sc->sc_bulkout_no == -1 ||
	    sc->sc_intrin_no == -1) {
		printf("%s: missing endpoint\n", devname);
		goto bad;
	}

	s = splnet();

	/* reset the adapter */
	url_reset(sc);

	/* Get Ethernet Address */
	err = url_mem(sc, URL_CMD_READMEM, URL_IDR0, (void *)eaddr,
		      ETHER_ADDR_LEN);
	if (err) {
		printf("%s: read MAC address failed\n", devname);
		splx(s);
		goto bad;
	}

	/* Print Ethernet Address */
	printf("%s: address %s\n", devname, ether_sprintf(eaddr));

	bcopy(eaddr, (char *)&sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
	/* initialize interface information */
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, devname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = url_start;
	ifp->if_ioctl = url_ioctl;
	ifp->if_watchdog = url_watchdog;

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/*
	 * Do ifmedia setup.
	 */
	mii = &sc->sc_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = url_int_miibus_readreg;
	mii->mii_writereg = url_int_miibus_writereg;
#if 0
	if (sc->sc_flags & URL_EXT_PHY) {
		mii->mii_readreg = url_ext_miibus_readreg;
		mii->mii_writereg = url_ext_miibus_writereg;
	}
#endif
	mii->mii_statchg = url_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;
	ifmedia_init(&mii->mii_media, 0,
		     url_ifmedia_change, url_ifmedia_status);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	/* attach the interface */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_stat_ch, url_tick, sc);

	splx(s);

	return;

 bad:
	usbd_deactivate(sc->sc_udev);
}

/* detach */
int
url_detach(struct device *self, int flags)
{
	struct url_softc *sc = (struct url_softc *)self;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (timeout_initialized(&sc->sc_stat_ch))
		timeout_del(&sc->sc_stat_ch);

	/* Remove any pending tasks */
	usb_rem_task(sc->sc_udev, &sc->sc_tick_task);
	usb_rem_task(sc->sc_udev, &sc->sc_stop_task);

	s = splusb();

	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away */
		usb_detach_wait(&sc->sc_dev);
	}

	if (ifp->if_flags & IFF_RUNNING)
		url_stop(GET_IFP(sc), 1);

	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->sc_pipe_tx != NULL)
		printf("%s: detach has active tx endpoint.\n",
		       sc->sc_dev.dv_xname);
	if (sc->sc_pipe_rx != NULL)
		printf("%s: detach has active rx endpoint.\n",
		       sc->sc_dev.dv_xname);
	if (sc->sc_pipe_intr != NULL)
		printf("%s: detach has active intr endpoint.\n",
		       sc->sc_dev.dv_xname);
#endif

	splx(s);

	return (0);
}

/* read/write memory */
int
url_mem(struct url_softc *sc, int cmd, int offset, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	if (cmd == URL_CMD_READMEM)
		req.bmRequestType = UT_READ_VENDOR_DEVICE;
	else
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URL_REQ_MEM;
	USETW(req.wValue, offset);
	USETW(req.wIndex, 0x0000);
	USETW(req.wLength, len);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, buf);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: url_mem(): %s failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname,
			 cmd == URL_CMD_READMEM ? "read" : "write",
			 offset, err));
	}

	return (err);
}

/* read 1byte from register */
int
url_csr_read_1(struct url_softc *sc, int reg)
{
	u_int8_t val = 0;

	DPRINTFN(0x100,
		 ("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	return (url_mem(sc, URL_CMD_READMEM, reg, &val, 1) ? 0 : val);
}

/* read 2bytes from register */
int
url_csr_read_2(struct url_softc *sc, int reg)
{
	uWord val;

	DPRINTFN(0x100,
		 ("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	USETW(val, 0);
	return (url_mem(sc, URL_CMD_READMEM, reg, &val, 2) ? 0 : UGETW(val));
}

/* write 1byte to register */
int
url_csr_write_1(struct url_softc *sc, int reg, int aval)
{
	u_int8_t val = aval;

	DPRINTFN(0x100,
		 ("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	return (url_mem(sc, URL_CMD_WRITEMEM, reg, &val, 1) ? -1 : 0);
}

/* write 2bytes to register */
int
url_csr_write_2(struct url_softc *sc, int reg, int aval)
{
	uWord val;

	DPRINTFN(0x100,
		 ("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	USETW(val, aval);

	return (url_mem(sc, URL_CMD_WRITEMEM, reg, &val, 2) ? -1 : 0);
}

/* write 4bytes to register */
int
url_csr_write_4(struct url_softc *sc, int reg, int aval)
{
	uDWord val;

	DPRINTFN(0x100,
		 ("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	USETDW(val, aval);

	return (url_mem(sc, URL_CMD_WRITEMEM, reg, &val, 4) ? -1 : 0);
}

int
url_init(struct ifnet *ifp)
{
	struct url_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);
	u_char *eaddr;
	int i, s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	s = splnet();

	/* Cancel pending I/O and free all TX/RX buffers */
	url_stop(ifp, 1);

	eaddr = sc->sc_ac.ac_enaddr;
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		url_csr_write_1(sc, URL_IDR0 + i, eaddr[i]);

	/* Init transmission control register */
	URL_CLRBIT(sc, URL_TCR,
		   URL_TCR_TXRR1 | URL_TCR_TXRR0 |
		   URL_TCR_IFG1 | URL_TCR_IFG0 |
		   URL_TCR_NOCRC);

	/* Init receive control register */
	URL_SETBIT2(sc, URL_RCR, URL_RCR_TAIL);

	/* Initialize transmit ring */
	if (url_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return (EIO);
	}

	/* Initialize receive ring */
	if (url_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return (EIO);
	}

	/* Program promiscuous mode and multicast filters */
	url_iff(sc);

	/* Enable RX and TX */
	URL_SETBIT(sc, URL_CR, URL_CR_TE | URL_CR_RE);

	mii_mediachg(mii);

	if (sc->sc_pipe_tx == NULL || sc->sc_pipe_rx == NULL) {
		if (url_openpipes(sc)) {
			splx(s);
			return (EIO);
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->sc_stat_ch, 1);

	return (0);
}

void
url_reset(struct url_softc *sc)
{
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	URL_SETBIT(sc, URL_CR, URL_CR_SOFT_RST);

	for (i = 0; i < URL_TX_TIMEOUT; i++) {
		if (!(url_csr_read_1(sc, URL_CR) & URL_CR_SOFT_RST))
			break;
		delay(10);	/* XXX */
	}

	delay(10000);		/* XXX */
}

void
url_iff(struct url_softc *sc)
{
	struct ifnet *ifp = GET_IFP(sc);
	struct arpcom *ac = &sc->sc_ac;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int32_t hashes[2];
	u_int16_t rcr;
	int h = 0;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	rcr = url_csr_read_2(sc, URL_RCR);
	rcr &= ~(URL_RCR_AAM | URL_RCR_AAP | URL_RCR_AB | URL_RCR_AD |
	    URL_RCR_AM);
	bzero(hashes, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 * Always accept frames destined to our station address.
	 */
	rcr |= URL_RCR_AB | URL_RCR_AD;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rcr |= URL_RCR_AAM;
		if (ifp->if_flags & IFF_PROMISC)
			rcr |= URL_RCR_AAP;
	} else {
		rcr |= URL_RCR_AM;

		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	url_csr_write_4(sc, URL_MAR0, hashes[0]);
	url_csr_write_4(sc, URL_MAR4, hashes[1]);
	url_csr_write_2(sc, URL_RCR, rcr);
}

int
url_openpipes(struct url_softc *sc)
{
	struct url_chain *c;
	usbd_status err;
	int i;
	int error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	sc->sc_refcnt++;

	/* Open RX pipe */
	err = usbd_open_pipe(sc->sc_ctl_iface, sc->sc_bulkin_no,
			     USBD_EXCLUSIVE_USE, &sc->sc_pipe_rx);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

	/* Open TX pipe */
	err = usbd_open_pipe(sc->sc_ctl_iface, sc->sc_bulkout_no,
			     USBD_EXCLUSIVE_USE, &sc->sc_pipe_tx);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

#if 0
	/* XXX: interrupt endpoint is not yet supported */
	/* Open Interrupt pipe */
	err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_intrin_no,
				  USBD_EXCLUSIVE_USE, &sc->sc_pipe_intr, sc,
				  &sc->sc_cdata.url_ibuf, URL_INTR_PKGLEN,
				  url_intr, URL_INTR_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}
#endif


	/* Start up the receive pipe. */
	for (i = 0; i < URL_RX_LIST_CNT; i++) {
		c = &sc->sc_cdata.url_rx_chain[i];
		usbd_setup_xfer(c->url_xfer, sc->sc_pipe_rx,
				c, c->url_buf, URL_BUFSZ,
				USBD_SHORT_XFER_OK | USBD_NO_COPY,
				USBD_NO_TIMEOUT, url_rxeof);
		(void)usbd_transfer(c->url_xfer);
		DPRINTF(("%s: %s: start read\n", sc->sc_dev.dv_xname,
			 __func__));
	}

 done:
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
url_newbuf(struct url_softc *sc, struct url_chain *c, struct mbuf *m)
{
	struct mbuf *m_new = NULL;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dev.dv_xname);
			return (ENOBUFS);
		}
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);
	c->url_mbuf = m_new;

	return (0);
}


int
url_rx_list_init(struct url_softc *sc)
{
	struct url_cdata *cd;
	struct url_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < URL_RX_LIST_CNT; i++) {
		c = &cd->url_rx_chain[i];
		c->url_sc = sc;
		c->url_idx = i;
		if (url_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->url_xfer == NULL) {
			c->url_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->url_xfer == NULL)
				return (ENOBUFS);
			c->url_buf = usbd_alloc_buffer(c->url_xfer, URL_BUFSZ);
			if (c->url_buf == NULL) {
				usbd_free_xfer(c->url_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
url_tx_list_init(struct url_softc *sc)
{
	struct url_cdata *cd;
	struct url_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < URL_TX_LIST_CNT; i++) {
		c = &cd->url_tx_chain[i];
		c->url_sc = sc;
		c->url_idx = i;
		c->url_mbuf = NULL;
		if (c->url_xfer == NULL) {
			c->url_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->url_xfer == NULL)
				return (ENOBUFS);
			c->url_buf = usbd_alloc_buffer(c->url_xfer, URL_BUFSZ);
			if (c->url_buf == NULL) {
				usbd_free_xfer(c->url_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

void
url_start(struct ifnet *ifp)
{
	struct url_softc *sc = ifp->if_softc;
	struct mbuf *m_head = NULL;

	DPRINTF(("%s: %s: enter, link=%d\n", sc->sc_dev.dv_xname,
		 __func__, sc->sc_link));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (!sc->sc_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (url_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/* Set a timeout in case the chip goes out to lunch. */
	ifp->if_timer = 5;
}

int
url_send(struct url_softc *sc, struct mbuf *m, int idx)
{
	int total_len;
	struct url_chain *c;
	usbd_status err;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	c = &sc->sc_cdata.url_tx_chain[idx];

	/* Copy the mbuf data into a contiguous buffer */
	m_copydata(m, 0, m->m_pkthdr.len, c->url_buf);
	c->url_mbuf = m;
	total_len = m->m_pkthdr.len;

	if (total_len < URL_MIN_FRAME_LEN) {
		bzero(c->url_buf + total_len, URL_MIN_FRAME_LEN - total_len);
		total_len = URL_MIN_FRAME_LEN;
	}
	usbd_setup_xfer(c->url_xfer, sc->sc_pipe_tx, c, c->url_buf, total_len,
			USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
			URL_TX_TIMEOUT, url_txeof);

	/* Transmit */
	sc->sc_refcnt++;
	err = usbd_transfer(c->url_xfer);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: url_send error=%s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(err));
		/* Stop the interface */
		usb_add_task(sc->sc_udev, &sc->sc_stop_task);
		return (EIO);
	}

	DPRINTF(("%s: %s: send %d bytes\n", sc->sc_dev.dv_xname,
		 __func__, total_len));

	sc->sc_cdata.url_tx_cnt++;

	return (0);
}

void
url_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct url_chain *c = priv;
	struct url_softc *sc = c->url_sc;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splnet();

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(status));
		if (status == USBD_STALLED) {
			sc->sc_refcnt++;
			usbd_clear_endpoint_stall_async(sc->sc_pipe_tx);
			if (--sc->sc_refcnt < 0)
				usb_detach_wakeup(&sc->sc_dev);
		}
		splx(s);
		return;
	}

	m_freem(c->url_mbuf);
	c->url_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		url_start(ifp);

	splx(s);
}

void
url_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct url_chain *c = priv;
	struct url_softc *sc = c->url_sc;
	struct ifnet *ifp = GET_IFP(sc);
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int32_t total_len;
	url_rxhdr_t rxhdr;
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->sc_rx_errs++;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			       sc->sc_dev.dv_xname, sc->sc_rx_errs,
			       usbd_errstr(status));
			sc->sc_rx_errs = 0;
		}
		if (status == USBD_STALLED) {
			sc->sc_refcnt++;
			usbd_clear_endpoint_stall_async(sc->sc_pipe_rx);
			if (--sc->sc_refcnt < 0)
				usb_detach_wakeup(&sc->sc_dev);
		}
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	memcpy(mtod(c->url_mbuf, char *), c->url_buf, total_len);

	if (total_len <= ETHER_CRC_LEN) {
		ifp->if_ierrors++;
		goto done;
	}

	memcpy(&rxhdr, c->url_buf + total_len - ETHER_CRC_LEN, sizeof(rxhdr));

	DPRINTF(("%s: RX Status: %dbytes%s%s%s%s packets\n",
		 sc->sc_dev.dv_xname,
		 UGETW(rxhdr) & URL_RXHDR_BYTEC_MASK,
		 UGETW(rxhdr) & URL_RXHDR_VALID_MASK ? ", Valid" : "",
		 UGETW(rxhdr) & URL_RXHDR_RUNTPKT_MASK ? ", Runt" : "",
		 UGETW(rxhdr) & URL_RXHDR_PHYPKT_MASK ? ", Physical match" : "",
		 UGETW(rxhdr) & URL_RXHDR_MCASTPKT_MASK ? ", Multicast" : ""));

	if ((UGETW(rxhdr) & URL_RXHDR_VALID_MASK) == 0) {
		ifp->if_ierrors++;
		goto done;
	}

	total_len -= ETHER_CRC_LEN;

	m = c->url_mbuf;
	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (url_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	DPRINTF(("%s: %s: deliver %d\n", sc->sc_dev.dv_xname,
		 __func__, m->m_len));

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

 done:
	/* Setup new transfer */
	usbd_setup_xfer(xfer, sc->sc_pipe_rx, c, c->url_buf, URL_BUFSZ,
			USBD_SHORT_XFER_OK | USBD_NO_COPY,
			USBD_NO_TIMEOUT, url_rxeof);
	sc->sc_refcnt++;
	usbd_transfer(xfer);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	DPRINTF(("%s: %s: start rx\n", sc->sc_dev.dv_xname, __func__));
}

int
url_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct url_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			url_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				url_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				url_stop(ifp, 1);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			url_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
url_watchdog(struct ifnet *ifp)
{
	struct url_softc *sc = ifp->if_softc;
	struct url_chain *c;
	usbd_status stat;
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	s = splusb();
	c = &sc->sc_cdata.url_tx_chain[0];
	usbd_get_xfer_status(c->url_xfer, NULL, NULL, NULL, &stat);
	url_txeof(c->url_xfer, c, stat);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		url_start(ifp);
	splx(s);
}

void
url_stop_task(struct url_softc *sc)
{
	url_stop(GET_IFP(sc), 1);
}

/* Stop the adapter and free any mbufs allocated to the RX and TX lists. */
void
url_stop(struct ifnet *ifp, int disable)
{
	struct url_softc *sc = ifp->if_softc;
	usbd_status err;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	url_reset(sc);

	timeout_del(&sc->sc_stat_ch);

	/* Stop transfers */
	/* RX endpoint */
	if (sc->sc_pipe_rx != NULL) {
		usbd_abort_pipe(sc->sc_pipe_rx);
		err = usbd_close_pipe(sc->sc_pipe_rx);
		if (err)
			printf("%s: close rx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_rx = NULL;
	}

	/* TX endpoint */
	if (sc->sc_pipe_tx != NULL) {
		usbd_abort_pipe(sc->sc_pipe_tx);
		err = usbd_close_pipe(sc->sc_pipe_tx);
		if (err)
			printf("%s: close tx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_tx = NULL;
	}

#if 0
	/* XXX: Interrupt endpoint is not yet supported!! */
	/* Interrupt endpoint */
	if (sc->sc_pipe_intr != NULL) {
		usbd_abort_pipe(sc->sc_pipe_intr);
		err = usbd_close_pipe(sc->sc_pipe_intr);
		if (err)
			printf("%s: close intr pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_intr = NULL;
	}
#endif

	/* Free RX resources. */
	for (i = 0; i < URL_RX_LIST_CNT; i++) {
		if (sc->sc_cdata.url_rx_chain[i].url_mbuf != NULL) {
			m_freem(sc->sc_cdata.url_rx_chain[i].url_mbuf);
			sc->sc_cdata.url_rx_chain[i].url_mbuf = NULL;
		}
		if (sc->sc_cdata.url_rx_chain[i].url_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.url_rx_chain[i].url_xfer);
			sc->sc_cdata.url_rx_chain[i].url_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < URL_TX_LIST_CNT; i++) {
		if (sc->sc_cdata.url_tx_chain[i].url_mbuf != NULL) {
			m_freem(sc->sc_cdata.url_tx_chain[i].url_mbuf);
			sc->sc_cdata.url_tx_chain[i].url_mbuf = NULL;
		}
		if (sc->sc_cdata.url_tx_chain[i].url_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.url_tx_chain[i].url_xfer);
			sc->sc_cdata.url_tx_chain[i].url_xfer = NULL;
		}
	}

	sc->sc_link = 0;
}

/* Set media options */
int
url_ifmedia_change(struct ifnet *ifp)
{
	struct url_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	sc->sc_link = 0;
	if (mii->mii_instance) {
		struct mii_softc *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list))
			mii_phy_reset(miisc);
	}

	return (mii_mediachg(mii));
}

/* Report current media status. */
void
url_ifmedia_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct url_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		ifmr->ifm_active = IFM_ETHER | IFM_NONE;
		ifmr->ifm_status = 0;
		return;
	}

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

void
url_tick(void *xsc)
{
	struct url_softc *sc = xsc;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/* Perform periodic stuff in process context */
	usb_add_task(sc->sc_udev, &sc->sc_tick_task);
}

void
url_tick_task(void *xsc)
{
	struct url_softc *sc = xsc;
	struct ifnet *ifp;
	struct mii_data *mii;
	int s;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	ifp = GET_IFP(sc);
	mii = GET_MII(sc);

	if (mii == NULL)
		return;

	s = splnet();

	mii_tick(mii);
	if (!sc->sc_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		DPRINTF(("%s: %s: got link\n",
			 sc->sc_dev.dv_xname, __func__));
		sc->sc_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			   url_start(ifp);
	}

	timeout_add_sec(&sc->sc_stat_ch, 1);

	splx(s);
}

/* Get exclusive access to the MII registers */
void
url_lock_mii(struct url_softc *sc)
{
	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	sc->sc_refcnt++;
	rw_enter_write(&sc->sc_mii_lock);
}

void
url_unlock_mii(struct url_softc *sc)
{
	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
		       __func__));

	rw_exit_write(&sc->sc_mii_lock);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
}

int
url_int_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct url_softc *sc;
	u_int16_t val;

	if (dev == NULL)
		return (0);

	sc = (void *)dev;

	DPRINTFN(0xff, ("%s: %s: enter, phy=%d reg=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return (0);
	}

	/* XXX: one PHY only for the RTL8150 internal PHY */
	if (phy != 0) {
		DPRINTFN(0xff, ("%s: %s: phy=%d is not supported\n",
			 sc->sc_dev.dv_xname, __func__, phy));
		return (0);
	}

	url_lock_mii(sc);

	switch (reg) {
	case MII_BMCR:		/* Control Register */
		reg = URL_BMCR;
		break;
	case MII_BMSR:		/* Status Register */
		reg = URL_BMSR;
		break;
	case MII_PHYIDR1:
	case MII_PHYIDR2:
		val = 0;
		goto R_DONE;
		break;
	case MII_ANAR:		/* Autonegotiation advertisement */
		reg = URL_ANAR;
		break;
	case MII_ANLPAR:	/* Autonegotiation link partner abilities */
		reg = URL_ANLP;
		break;
	case URLPHY_MSR:	/* Media Status Register */
		reg = URL_MSR;
		break;
	default:
		printf("%s: %s: bad register %04x\n",
		       sc->sc_dev.dv_xname, __func__, reg);
		val = 0;
		goto R_DONE;
		break;
	}

	if (reg == URL_MSR)
		val = url_csr_read_1(sc, reg);
	else
		val = url_csr_read_2(sc, reg);

 R_DONE:
	DPRINTFN(0xff, ("%s: %s: phy=%d reg=0x%04x => 0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, val));

	url_unlock_mii(sc);
	return (val);
}

void
url_int_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct url_softc *sc;

	if (dev == NULL)
		return;

	sc = (void *)dev;

	DPRINTFN(0xff, ("%s: %s: enter, phy=%d reg=0x%04x data=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, data));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return;
	}

	/* XXX: one PHY only for the RTL8150 internal PHY */
	if (phy != 0) {
		DPRINTFN(0xff, ("%s: %s: phy=%d is not supported\n",
			 sc->sc_dev.dv_xname, __func__, phy));
		return;
	}

	url_lock_mii(sc);

	switch (reg) {
	case MII_BMCR:		/* Control Register */
		reg = URL_BMCR;
		break;
	case MII_BMSR:		/* Status Register */
		reg = URL_BMSR;
		break;
	case MII_PHYIDR1:
	case MII_PHYIDR2:
		goto W_DONE;
		break;
	case MII_ANAR:		/* Autonegotiation advertisement */
		reg = URL_ANAR;
		break;
	case MII_ANLPAR:	/* Autonegotiation link partner abilities */
		reg = URL_ANLP;
		break;
	case URLPHY_MSR:	/* Media Status Register */
		reg = URL_MSR;
		break;
	default:
		printf("%s: %s: bad register %04x\n",
		       sc->sc_dev.dv_xname, __func__, reg);
		goto W_DONE;
		break;
	}

	if (reg == URL_MSR)
		url_csr_write_1(sc, reg, data);
	else
		url_csr_write_2(sc, reg, data);
 W_DONE:

	url_unlock_mii(sc);
	return;
}

void
url_miibus_statchg(struct device *dev)
{
#ifdef URL_DEBUG
	struct url_softc *sc;

	if (dev == NULL)
		return;

	sc = (void *)dev;
	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));
#endif
	/* Nothing to do */
}

#if 0
/*
 * external PHYs support, but not test.
 */
int
url_ext_miibus_redreg(struct device *dev, int phy, int reg)
{
	struct url_softc *sc = (void *)dev;
	u_int16_t val;

	DPRINTF(("%s: %s: enter, phy=%d reg=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return (0);
	}

	url_lock_mii(sc);

	url_csr_write_1(sc, URL_PHYADD, phy & URL_PHYADD_MASK);
	/*
	 * RTL8150L will initiate a MII management data transaction
	 * if PHYCNT_OWN bit is set 1 by software. After transaction,
	 * this bit is auto cleared by TRL8150L.
	 */
	url_csr_write_1(sc, URL_PHYCNT,
			(reg | URL_PHYCNT_PHYOWN) & ~URL_PHYCNT_RWCR);
	for (i = 0; i < URL_TIMEOUT; i++) {
		if ((url_csr_read_1(sc, URL_PHYCNT) & URL_PHYCNT_PHYOWN) == 0)
			break;
	}
	if (i == URL_TIMEOUT) {
		printf("%s: MII read timed out\n", sc->sc_dev.dv_xname);
	}

	val = url_csr_read_2(sc, URL_PHYDAT);

	DPRINTF(("%s: %s: phy=%d reg=0x%04x => 0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, val));

	url_unlock_mii(sc);
	return (val);
}

void
url_ext_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct url_softc *sc = (void *)dev;

	DPRINTF(("%s: %s: enter, phy=%d reg=0x%04x data=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, data));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return;
	}

	url_lock_mii(sc);

	url_csr_write_2(sc, URL_PHYDAT, data);
	url_csr_write_1(sc, URL_PHYADD, phy);
	url_csr_write_1(sc, URL_PHYCNT, reg | URL_PHYCNT_RWCR);	/* Write */

	for (i=0; i < URL_TIMEOUT; i++) {
		if (url_csr_read_1(sc, URL_PHYCNT) & URL_PHYCNT_PHYOWN)
			break;
	}

	if (i == URL_TIMEOUT) {
		printf("%s: MII write timed out\n",
		       sc->sc_dev.dv_xname);
	}

	url_unlock_mii(sc);
	return;
}
#endif

@


1.81
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.80 2016/04/13 11:03:37 mpi Exp $ */
a886 2

	ifp->if_opackets++;
@


1.80
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.79 2015/11/25 03:10:00 dlg Exp $ */
d166 1
a166 1
	if (uaa->iface != NULL)
a189 7

	/* Move the device into the configured state. */
	err = usbd_set_config_no(dev, URL_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n", devname);
		goto bad;
	}
@


1.79
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.78 2015/11/24 17:11:40 mpi Exp $ */
a268 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.78
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.77 2015/11/20 03:35:23 dlg Exp $ */
d525 1
a525 1
	ifp->if_flags &= ~IFF_OACTIVE;
d790 1
a790 1
	if (ifp->if_flags & IFF_OACTIVE)
d799 1
a799 1
		ifp->if_flags |= IFF_OACTIVE;
d810 1
a810 1
	ifp->if_flags |= IFF_OACTIVE;
d877 1
a877 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1091 2
a1092 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.77
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.76 2015/10/25 12:11:56 mpi Exp $ */
a56 1
#include <net/if_dl.h>
@


1.76
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.75 2015/06/24 09:40:54 mpi Exp $ */
d794 1
a794 1
	IFQ_POLL(&ifp->if_snd, m_head);
d799 1
d804 1
a804 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.75
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.74 2015/03/27 19:20:56 uaa Exp $ */
a1002 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1017 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.74
log
@simply do if_input() between splnet() and splx(), like other drivers
(such as if_udav.c).

ok by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.73 2015/03/14 03:38:49 jsg Exp $ */
a967 1
	ifp->if_ipackets++;
@


1.73
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.72 2015/02/12 09:08:47 mpi Exp $ */
a974 2
	s = splnet();

d977 1
a977 1
		goto done1;
d982 2
a984 2

 done1:
@


1.72
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.71 2014/12/22 02:28:52 tedu Exp $ */
a56 1
#include <net/if_arp.h>
@


1.71
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.70 2014/07/13 15:52:49 mpi Exp $ */
d915 1
d974 1
a974 1
	m->m_pkthdr.rcvif = ifp;
a982 5
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

d985 1
a985 1
	ether_input_mbuf(ifp, m);
@


1.70
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.69 2014/07/12 07:59:23 mpi Exp $ */
a1026 1
#ifdef INET
a1028 1
#endif
@


1.69
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.68 2013/11/15 10:17:39 pirofti Exp $ */
a64 1
#ifdef INET
a65 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a66 1
#endif
@


1.68
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.67 2013/08/07 01:06:43 bluhm Exp $ */
d83 3
d87 6
a92 16
/* Function declarations */
int url_match(struct device *, void *, void *); 
void url_attach(struct device *, struct device *, void *); 
int url_detach(struct device *, int); 
int url_activate(struct device *, int); 

struct cfdriver url_cd = { 
	NULL, "url", DV_IFNET 
}; 

const struct cfattach url_ca = { 
	sizeof(struct url_softc), 
	url_match, 
	url_attach, 
	url_detach, 
	url_activate, 
a558 17
}

int
url_activate(struct device *self, int act)
{
	struct url_softc *sc = (struct url_softc *)self;

	DPRINTF(("%s: %s: enter, act=%d\n", sc->sc_dev.dv_xname,
		 __func__, act));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return (0);
@


1.67
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.66 2013/04/15 09:23:01 mglocker Exp $ */
d1141 1
a1141 4
		err = usbd_abort_pipe(sc->sc_pipe_rx);
		if (err)
			printf("%s: abort rx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
d1151 1
a1151 4
		err = usbd_abort_pipe(sc->sc_pipe_tx);
		if (err)
			printf("%s: abort tx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
d1163 1
a1163 4
		err = usbd_abort_pipe(sc->sc_pipe_intr);
		if (err)
			printf("%s: abort intr pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.66
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.65 2013/03/28 03:58:03 tedu Exp $ */
a67 1
#include <netinet/in_var.h>
@


1.65
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.64 2013/01/29 11:06:38 brad Exp $ */
d109 2
a110 2
void url_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void url_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d192 2
a193 2
	usbd_device_handle dev = uaa->device;
	usbd_interface_handle iface;
d892 1
a892 1
url_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d939 1
a939 1
url_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.64
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.63 2011/07/03 15:47:17 matthew Exp $ */
a51 1
#include <sys/proc.h>
@


1.63
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.62 2011/06/23 16:31:16 deraadt Exp $ */
d126 1
a126 1
void url_setmulti(struct url_softc *);
d508 1
a508 12
	URL_SETBIT2(sc, URL_RCR, URL_RCR_TAIL | URL_RCR_AD);
	if (ifp->if_flags & IFF_BROADCAST)
		URL_SETBIT2(sc, URL_RCR, URL_RCR_AB);
	else
		URL_CLRBIT2(sc, URL_RCR, URL_RCR_AB);

	/* If we want promiscuous mode, accept all physical frames. */
	if (ifp->if_flags & IFF_PROMISC)
		URL_SETBIT2(sc, URL_RCR, URL_RCR_AAM|URL_RCR_AAP);
	else
		URL_CLRBIT2(sc, URL_RCR, URL_RCR_AAM|URL_RCR_AAP);

d524 2
a525 2
	/* Load the multicast filter */
	url_setmulti(sc);
a586 3
#define url_calchash(addr) (ether_crc32_be((addr), ETHER_ADDR_LEN) >> 26)


d588 1
a588 1
url_setmulti(struct url_softc *sc)
d590 2
a591 1
	struct ifnet *ifp;
d594 2
a595 1
	u_int32_t hashes[2] = { 0, 0 };
a596 1
	int mcnt = 0;
d603 11
a613 1
	ifp = GET_IFP(sc);
d615 1
a615 5
	if (ifp->if_flags & IFF_PROMISC) {
		URL_SETBIT2(sc, URL_RCR, URL_RCR_AAM|URL_RCR_AAP);
		return;
	} else if (ifp->if_flags & IFF_ALLMULTI) {
	allmulti:
d617 16
a632 4
		URL_SETBIT2(sc, URL_RCR, URL_RCR_AAM);
		URL_CLRBIT2(sc, URL_RCR, URL_RCR_AAP);
		return;
	}
d634 2
a635 18
	/* first, zot all the existing hash bits */
	url_csr_write_4(sc, URL_MAR0, 0);
	url_csr_write_4(sc, URL_MAR4, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
			   ETHER_ADDR_LEN) != 0)
			goto allmulti;

		h = url_calchash(enm->enm_addrlo);
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h -32));
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
a637 9
	ifp->if_flags &= ~IFF_ALLMULTI;

	URL_CLRBIT2(sc, URL_RCR, URL_RCR_AAM|URL_RCR_AAP);

	if (mcnt){
		URL_SETBIT2(sc, URL_RCR, URL_RCR_AM);
	} else {
		URL_CLRBIT2(sc, URL_RCR, URL_RCR_AM);
	}
d640 1
a1042 1
	struct mii_data *mii;
d1055 2
a1056 3
		url_init(ifp);

		switch (ifa->ifa_addr->sa_family) {
d1058 1
a1058 1
		case AF_INET:
d1060 1
a1060 3
			break;
#endif /* INET */
		}
d1065 3
a1067 9
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC) {
				URL_SETBIT2(sc, URL_RCR,
					    URL_RCR_AAM|URL_RCR_AAP);
			} else if (ifp->if_flags & IFF_RUNNING &&
				   !(ifp->if_flags & IFF_PROMISC)) {
				URL_CLRBIT2(sc, URL_RCR,
					    URL_RCR_AAM|URL_RCR_AAP);
			} else if (!(ifp->if_flags & IFF_RUNNING))
a1072 1
		error = 0;
d1077 1
a1077 2
		mii = GET_MII(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
d1086 1
a1086 1
			url_setmulti(sc);
@


1.62
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.61 2011/01/25 20:03:35 jakemsr Exp $ */
a589 3
	case DVACT_ACTIVATE:
		break;

@


1.61
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.60 2010/12/06 04:41:39 jakemsr Exp $ */
a1057 6

#if 0
void url_intr()
{
}
#endif
@


1.60
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.59 2010/10/27 17:51:11 jakemsr Exp $ */
a320 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, &sc->sc_dev);

a373 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.59
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.58 2010/10/23 16:14:07 jakemsr Exp $ */
d204 2
a226 1
	sc->sc_udev = dev;
d318 1
a318 1
	sc->sc_attached = 1;
d326 1
a326 1
	sc->sc_dying = 1;
a338 4
	/* Detached before attached finished */
	if (!sc->sc_attached)
		return (0);

a374 2
	sc->sc_attached = 0;

d396 1
a396 1
	if (sc->sc_dying)
a430 3
	if (sc->sc_dying)
		return (0);

a442 3
	if (sc->sc_dying)
		return (0);

a455 3
	if (sc->sc_dying)
		return (0);

a469 3
	if (sc->sc_dying)
		return (0);

a483 3
	if (sc->sc_dying)
		return (0);

a496 3
	if (sc->sc_dying)
		return (EIO);

d572 1
a572 1
	if (sc->sc_dying)
d599 1
a599 1
		sc->sc_dying = 1;
d621 1
a621 1
	if (sc->sc_dying)
d678 1
a678 1
	if (sc->sc_dying)
d843 1
a843 1
	if (sc->sc_dying)
d927 1
a927 1
	if (sc->sc_dying)
d979 1
a979 1
	if (sc->sc_dying)
d1081 1
a1081 1
	if (sc->sc_dying)
d1264 1
a1264 1
	if (sc->sc_dying)
d1287 1
a1287 1
	if (sc->sc_dying)
d1312 1
a1312 1
	if (sc->sc_dying)
d1333 1
a1333 1
	if (sc->sc_dying)
d1395 1
a1395 1
	if (sc->sc_dying) {
d1467 1
a1467 1
	if (sc->sc_dying) {
d1549 1
a1549 1
	if (sc->sc_dying) {
d1592 1
a1592 1
	if (sc->sc_dying) {
@


1.58
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.57 2010/10/23 15:42:09 jakemsr Exp $ */
d361 4
a364 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.57
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.56 2010/08/27 07:08:22 deraadt Exp $ */
d342 2
a343 1
	timeout_del(&sc->sc_stat_ch);
@


1.56
log
@Delete comments about these drivers needing powerhook support; they don't.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.55 2009/10/13 19:33:17 pirofti Exp $ */
d211 2
a212 1
	usb_init_task(&sc->sc_tick_task, url_tick_task, sc);
d214 2
a215 1
	usb_init_task(&sc->sc_stop_task, (void (*)(void *)) url_stop_task, sc);
@


1.55
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.54 2008/11/28 02:44:18 brad Exp $ */
a42 1
 *	powerhook() support?
@


1.54
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.53 2008/11/06 02:32:29 brad Exp $ */
d91 1
a91 1
int url_activate(struct device *, enum devact); 
d606 1
a606 1
url_activate(struct device *self, enum devact act)
@


1.53
log
@Set the IFCAP_VLAN_MTU capabilities flag so these interfaces are allowed
to transmit full sized VLAN tagged frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.52 2008/10/03 20:25:29 brad Exp $ */
a1118 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

a1136 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
			ether_addmulti(ifr, &sc->sc_ac) :
			ether_delmulti(ifr, &sc->sc_ac);
a1137 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				url_setmulti(sc);
			error = 0;
		}
		break;
d1143 1
d1146 6
@


1.52
log
@Use ether_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.51 2008/09/10 14:01:23 blambert Exp $ */
d284 2
@


1.51
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.50 2007/11/23 15:43:02 mbalmer Exp $ */
d1160 1
a1160 2
		error = EINVAL;
		break;
a1163 1

@


1.50
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.49 2007/10/11 18:33:14 deraadt Exp $ */
d577 1
a577 1
	timeout_add(&sc->sc_stat_ch, hz);
d1384 1
a1384 1
	timeout_add(&sc->sc_stat_ch, hz);
@


1.49
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.48 2007/06/14 10:11:15 mbalmer Exp $ */
d313 1
a313 1
	timeout_set(&sc->sc_stat_ch, NULL, NULL);
a576 2
	timeout_del(&sc->sc_stat_ch);
	timeout_set(&sc->sc_stat_ch, url_tick, sc);
a1383 2
	timeout_del(&sc->sc_stat_ch);
	timeout_set(&sc->sc_stat_ch, url_tick, sc);
@


1.48
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.47 2007/06/13 11:15:29 mbalmer Exp $ */
a198 1
	char *devinfop;
a203 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.47
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.46 2007/06/12 16:26:36 mbalmer Exp $ */
d88 16
a103 1
USB_DECLARE_DRIVER_CLASS(url, DV_IFNET);
@


1.46
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.45 2007/06/11 05:42:54 mbalmer Exp $ */
d1055 1
a1055 1
	IF_INPUT(ifp, m);
@


1.45
log
@Remove the definition and usage of the USBGETSOFTC macro, which was really
only a cast to (void *).

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.44 2007/06/10 14:49:00 mbalmer Exp $ */
d108 3
a110 3
int url_int_miibus_readreg(device_ptr_t, int, int);
void url_int_miibus_writereg(device_ptr_t, int, int, int);
void url_miibus_statchg(device_ptr_t);
d596 1
a596 1
url_activate(device_ptr_t self, enum devact act)
d1406 1
a1406 1
url_int_miibus_readreg(device_ptr_t dev, int phy, int reg)
d1479 1
a1479 1
url_int_miibus_writereg(device_ptr_t dev, int phy, int reg, int data)
d1546 1
a1546 1
url_miibus_statchg(device_ptr_t dev)
d1565 1
a1565 1
url_ext_miibus_redreg(device_ptr_t dev, int phy, int reg)
d1609 1
a1609 1
url_ext_miibus_writereg(device_ptr_t dev, int phy, int reg, int data)
@


1.44
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.43 2007/06/10 10:53:48 mbalmer Exp $ */
d1414 1
a1414 1
	sc = USBGETSOFTC(dev);
d1486 1
a1486 1
	sc = USBGETSOFTC(dev);
d1554 1
a1554 1
	sc = USBGETSOFTC(dev);
d1567 1
a1567 1
	struct url_softc *sc = USBGETSOFTC(dev);
d1611 1
a1611 1
	struct url_softc *sc = USBGETSOFTC(dev);
@


1.43
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.42 2007/06/10 10:15:35 mbalmer Exp $ */
d185 1
a185 1
	char *devname = USBDEVNAME(sc->sc_dev);
d323 1
a323 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d353 1
a353 1
		       USBDEVNAME(sc->sc_dev));
d356 1
a356 1
		       USBDEVNAME(sc->sc_dev));
d359 1
a359 1
		       USBDEVNAME(sc->sc_dev));
d383 1
a383 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d403 1
a403 1
			 USBDEVNAME(sc->sc_dev),
d418 1
a418 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d433 1
a433 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d449 1
a449 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d464 1
a464 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d481 1
a481 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d499 1
a499 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d535 1
a535 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->sc_dev));
d542 1
a542 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->sc_dev));
d579 1
a579 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d600 1
a600 1
	DPRINTF(("%s: %s: enter, act=%d\n", USBDEVNAME(sc->sc_dev),
d628 1
a628 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d697 1
a697 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d707 1
a707 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d721 1
a721 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d736 1
a736 1
		DPRINTF(("%s: %s: start read\n", USBDEVNAME(sc->sc_dev),
d752 1
a752 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d758 1
a758 1
			       "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d764 1
a764 1
			       "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d789 1
a789 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d820 1
a820 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d849 1
a849 1
	DPRINTF(("%s: %s: enter, link=%d\n", USBDEVNAME(sc->sc_dev),
d890 1
a890 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d913 1
a913 1
		printf("%s: url_send error=%s\n", USBDEVNAME(sc->sc_dev),
d920 1
a920 1
	DPRINTF(("%s: %s: send %d bytes\n", USBDEVNAME(sc->sc_dev),
d941 1
a941 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d952 1
a952 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->sc_dev),
d986 1
a986 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d997 1
a997 1
			       USBDEVNAME(sc->sc_dev), sc->sc_rx_errs,
d1022 1
a1022 1
		 USBDEVNAME(sc->sc_dev),
d1053 1
a1053 1
	DPRINTF(("%s: %s: deliver %d\n", USBDEVNAME(sc->sc_dev),
d1070 1
a1070 1
	DPRINTF(("%s: %s: start rx\n", USBDEVNAME(sc->sc_dev), __func__));
d1088 1
a1088 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1169 1
a1169 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1172 1
a1172 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->sc_dev));
d1198 1
a1198 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1213 1
a1213 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1217 1
a1217 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1226 1
a1226 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1230 1
a1230 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1241 1
a1241 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1245 1
a1245 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1284 1
a1284 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1307 1
a1307 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1331 1
a1331 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1352 1
a1352 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1370 1
a1370 1
			 USBDEVNAME(sc->sc_dev), __func__));
d1387 1
a1387 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1397 1
a1397 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1417 1
a1417 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg));
d1421 1
a1421 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1430 1
a1430 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1459 1
a1459 1
		       USBDEVNAME(sc->sc_dev), __func__, reg);
d1472 1
a1472 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, val));
d1489 1
a1489 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data));
d1493 1
a1493 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1502 1
a1502 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1530 1
a1530 1
		       USBDEVNAME(sc->sc_dev), __func__, reg);
d1555 1
a1555 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1571 1
a1571 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg));
d1575 1
a1575 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1596 1
a1596 1
		printf("%s: MII read timed out\n", USBDEVNAME(sc->sc_dev));
d1602 1
a1602 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, val));
d1614 1
a1614 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data));
d1618 1
a1618 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1637 1
a1637 1
		       USBDEVNAME(sc->sc_dev));
@


1.42
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.41 2007/06/09 12:22:53 mbalmer Exp $ */
d307 1
a307 1
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, USBDEV(sc->sc_dev));
d339 1
a339 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d367 1
a367 1
			   USBDEV(sc->sc_dev));
d400 1
a400 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d742 1
a742 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d911 1
a911 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d958 1
a958 1
				usb_detach_wakeup(USBDEV(sc->sc_dev));
d1005 1
a1005 1
				usb_detach_wakeup(USBDEV(sc->sc_dev));
d1068 1
a1068 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d1402 1
a1402 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.41
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.40 2007/06/05 08:43:55 mbalmer Exp $ */
d303 1
a303 1
	usb_callout_init(sc->sc_stat_ch);
d329 1
a329 1
	usb_uncallout(sc->sc_stat_ch, url_tick, sc);
d567 3
a569 1
	usb_callout(sc->sc_stat_ch, hz, url_tick, sc);
d1205 1
a1205 1
	usb_uncallout(sc->sc_stat_ch, url_tick, sc);
d1376 3
a1378 1
	usb_callout(sc->sc_stat_ch, hz, url_tick, sc);
@


1.40
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.39 2007/06/04 10:34:04 mbalmer Exp $ */
a605 1
		if_deactivate(GET_IFP(sc));
@


1.39
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.38 2007/05/27 04:00:25 jsg Exp $ */
d90 31
a120 31
Static int url_openpipes(struct url_softc *);
Static int url_rx_list_init(struct url_softc *);
Static int url_tx_list_init(struct url_softc *);
Static int url_newbuf(struct url_softc *, struct url_chain *, struct mbuf *);
Static void url_start(struct ifnet *);
Static int url_send(struct url_softc *, struct mbuf *, int);
Static void url_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void url_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void url_tick(void *);
Static void url_tick_task(void *);
Static int url_ioctl(struct ifnet *, u_long, caddr_t);
Static void url_stop_task(struct url_softc *);
Static void url_stop(struct ifnet *, int);
Static void url_watchdog(struct ifnet *);
Static int url_ifmedia_change(struct ifnet *);
Static void url_ifmedia_status(struct ifnet *, struct ifmediareq *);
Static void url_lock_mii(struct url_softc *);
Static void url_unlock_mii(struct url_softc *);
Static int url_int_miibus_readreg(device_ptr_t, int, int);
Static void url_int_miibus_writereg(device_ptr_t, int, int, int);
Static void url_miibus_statchg(device_ptr_t);
Static int url_init(struct ifnet *);
Static void url_setmulti(struct url_softc *);
Static void url_reset(struct url_softc *);

Static int url_csr_read_1(struct url_softc *, int);
Static int url_csr_read_2(struct url_softc *, int);
Static int url_csr_write_1(struct url_softc *, int, int);
Static int url_csr_write_2(struct url_softc *, int, int);
Static int url_csr_write_4(struct url_softc *, int, int);
Static int url_mem(struct url_softc *, int, int, void *, int);
d373 1
a373 1
Static int
d412 1
a412 1
Static int
d427 1
a427 1
Static int
d443 1
a443 1
Static int
d458 1
a458 1
Static int
d475 1
a475 1
Static int
d491 1
a491 1
Static int
d572 1
a572 1
Static void
d617 1
a617 1
Static void
d678 1
a678 1
Static int
d746 1
a746 1
Static int
d781 1
a781 1
Static int
d812 1
a812 1
Static int
d842 1
a842 1
Static void
d882 1
a882 1
Static int
d927 1
a927 1
Static void
d974 1
a974 1
Static void
d1073 1
a1073 1
Static void url_intr()
d1078 1
a1078 1
Static int
d1160 1
a1160 1
Static void
d1183 1
a1183 1
Static void
d1190 1
a1190 1
Static void
d1277 1
a1277 1
Static int
d1300 1
a1300 1
Static void
d1322 1
a1322 1
Static void
d1340 1
a1340 1
Static void
d1381 1
a1381 1
Static void
d1391 1
a1391 1
Static void
d1402 1
a1402 1
Static int
d1475 1
a1475 1
Static void
d1542 1
a1542 1
Static void
d1561 1
a1561 1
Static int
d1605 1
a1605 1
Static void
@


1.38
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.37 2007/05/21 05:40:27 jsg Exp $ */
a52 1
#if defined(__OpenBSD__)
a53 1
#endif
a66 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined(__NetBSD__) */

#if defined(__OpenBSD__)
a73 1
#endif /* defined(__OpenBSD__) */
a262 1
#if defined(__OpenBSD__)
a263 1
#endif
a271 4
#if defined(__NetBSD__)
	ifp->if_init = url_init;
	ifp->if_stop = url_stop;
#endif
a508 1
#if defined(__OpenBSD__)
a509 3
#elif defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
#endif
@


1.37
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.36 2007/05/21 05:18:56 jsg Exp $ */
d174 2
a175 1
USB_MATCH(url)
d177 1
a177 1
	USB_MATCH_START(url, uaa);
d186 2
a187 1
USB_ATTACH(url)
d189 2
a190 1
	USB_ATTACH_START(url, sc, uaa);
d204 1
a204 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d327 1
a327 1
	USB_ATTACH_SUCCESS_RETURN;
a330 1
	USB_ATTACH_ERROR_RETURN;
d334 2
a335 1
USB_DETACH(url)
d337 1
a337 1
	USB_DETACH_START(url, sc);
@


1.36
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.35 2007/05/06 04:08:47 krw Exp $ */
d136 2
a137 2
#define DPRINTF(x)	do { if (urldebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (urldebug >= (n)) logprintf x; } while (0)
@


1.35
log
@More lockmgr -> rwlock low hanging fruit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.34 2007/02/11 20:29:22 miod Exp $ */
d317 1
a317 1
	Ether_ifattach(ifp, eaddr);
@


1.34
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.33 2006/07/14 23:07:26 brad Exp $ */
d50 1
a50 1
#include <sys/lock.h>
d213 1
a213 1
	lockinit(&sc->sc_mii_lock, PZERO, "urlmii", 0, 0);
d1408 1
a1408 1
	usb_lockmgr(&sc->sc_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d1417 1
a1417 1
	usb_lockmgr(&sc->sc_mii_lock, LK_RELEASE, NULL, curproc);
@


1.33
log
@add ZyXEL USB id, remove useless comments and reorder USB devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.32 2006/06/23 06:27:11 miod Exp $ */
a44 6

#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
#include "rnd.h"
#endif
@


1.32
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.31 2006/03/25 22:41:47 djm Exp $ */
d167 2
a168 1
	/* MELCO LUA-KTX */
d170 2
a171 1
	/* GREEN HOUSE USBKR100 */
a172 1
	/* GREEN HOUSE USBKR100PNA */
d174 1
a174 8
	/* Longshine LCS-8138TX */
	{{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_LCS8138TX}, 0},
	/* Micronet SP128AR */
	{{ USB_VENDOR_MICRONET, USB_PRODUCT_MICRONET_SP128AR}, 0},
	/* Abocom RTL8151 and TRENDnet TU-ET100C */
	{{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_RTL8151}, 0},
	/* OQO model 01 */
	{{ USB_VENDOR_OQO, USB_PRODUCT_OQO_ETHER01}, 0}
@


1.31
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.30 2006/03/07 04:41:19 krw Exp $ */
a634 1
		return (EOPNOTSUPP);
@


1.30
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.29 2006/02/06 17:29:11 jmc Exp $ */
a73 1
#define	BPF_MTAP(ifp, m)	bpf_mtap((ifp)->if_bpf, (m))
d906 1
a906 1
		bpf_mtap(ifp->if_bpf, m_head);
d1082 1
a1082 1
		BPF_MTAP(ifp, m);
@


1.29
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.28 2006/01/29 03:22:52 brad Exp $ */
a64 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a331 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, devname, RND_TYPE_NET, 0);
#endif

a373 3
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
@


1.28
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.27 2005/09/23 10:24:51 grunk Exp $ */
d292 1
a292 1
	/* initialize interface infomation */
@


1.27
log
@{TrendNet,Trendware} -> TRENDnet, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.26 2005/08/01 05:36:48 brad Exp $ */
d999 1
a999 1
			usbd_clear_endpoint_stall(sc->sc_pipe_tx);
d1046 1
a1046 1
			usbd_clear_endpoint_stall(sc->sc_pipe_rx);
@


1.26
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.25 2005/07/19 11:42:37 jsg Exp $ */
d181 1
a181 1
	/* Abocom RTL8151 and TrendNet TU-ET100C */
@


1.25
log
@Update for GREENHOUSE2 -> REALTEK USB vid change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.24 2005/07/02 22:21:12 brad Exp $ */
d209 1
a209 1
	char devinfo[1024];
d216 1
a216 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d218 2
a219 1
	printf("%s: %s\n", devname, devinfo);
@


1.24
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.23 2005/07/02 22:17:58 brad Exp $ */
d174 1
a174 1
	{{ USB_VENDOR_GREENHOUSE2, USB_PRODUCT_GREENHOUSE2_USBKR100}, 0},
d176 1
a176 1
	{{ USB_VENDOR_GREENHOUSE2, USB_PRODUCT_GREENHOUSE2_USBKR100PNA}, 0},
@


1.23
log
@don't call mii_pollstat() right after mii_tick() in foo_tick_task()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.22 2005/06/08 17:03:02 henning Exp $ */
d1243 1
a1316 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.22
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.21 2005/03/03 07:16:53 itojun Exp $ */
d1409 7
a1415 10
	if (!sc->sc_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			DPRINTF(("%s: %s: got link\n",
				 USBDEVNAME(sc->sc_dev), __func__));
			sc->sc_link++;
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				   url_start(ifp);
		}
@


1.21
log
@ethernet on OQO model 01 device cable. dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.20 2005/01/03 22:45:52 brad Exp $ */
a96 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1147 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.20
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.19 2004/11/17 05:00:28 deraadt Exp $ */
d187 3
a189 1
	{{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_RTL8151}, 0}
@


1.19
log
@Three mode devices found in the wild, I think
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.18 2004/11/10 10:14:48 grange Exp $ */
d1199 1
d1201 3
a1203 1
			url_init(ifp);
a1204 2
		url_setmulti(sc);
		error = 0;
@


1.18
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.17 2004/10/16 01:28:45 jsg Exp $ */
d180 2
d185 3
a187 1
	{{ USB_VENDOR_MICRONET, USB_PRODUCT_MICRONET_SP128AR}, 0}
@


1.17
log
@Add Longshine LCS-8138TX and Micronet SP128AR found in linux driver
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.16 2004/09/29 09:51:07 dlg Exp $ */
d293 1
a293 1
	strncpy(ifp->if_xname, devname, IFNAMSIZ);
@


1.16
log
@from netbsd: if_url.c 1.8, if_urlreg.h 1.2, urlphy.c 1.9 and urlphyreg.h 1.2
via Jonathan Gray
log message:

Remove advertising clauses from code written by Shingo WATANABE.
He has kindly consented it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.15 2004/09/23 17:45:17 brad Exp $ */
d179 5
a183 1
	{{ USB_VENDOR_GREENHOUSE2, USB_PRODUCT_GREENHOUSE2_USBKR100}, 0}
@


1.15
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.14 2004/07/08 22:18:44 deraadt Exp $ */
d15 1
a15 4
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Shingo WATANABE.
 * 4. Neither the name of the author nor the names of any co-contributors
@


1.14
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.13 2003/12/23 09:16:11 deraadt Exp $ */
a291 1
	ifp->if_mtu = ETHERMTU;
@


1.13
log
@init ether address correctly, since our Ether_ifattach macro does not do
that job; 3612, rspmn@@arcor.de
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.12 2003/12/15 23:36:14 cedric Exp $ */
d154 2
a155 2
#define DPRINTF(x)	if (urldebug) logprintf x
#define DPRINTFN(n,x)	if (urldebug >= (n)) logprintf x
@


1.12
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.11 2003/05/07 04:33:33 deraadt Exp $ */
d286 3
@


1.11
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.10 2003/01/27 20:10:52 jason Exp $ */
d118 1
a118 1
USB_DECLARE_DRIVER(url);
@


1.10
log
@pad minimum frames with 0's; based on netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.9 2002/11/11 02:32:32 nate Exp $ */
d214 1
a214 1
	usbd_devinfo(dev, 0, devinfo);
@


1.10.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.10 2003/01/27 20:10:52 jason Exp $ */
d214 1
a214 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.10.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d118 1
a118 1
USB_DECLARE_DRIVER_CLASS(url, DV_IFNET);
a285 3
#if defined(__OpenBSD__)
	bcopy(eaddr, (char *)&sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);
#endif
@


1.9
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.8 2002/09/29 22:49:10 jason Exp $ */
d937 2
a938 1
	if (total_len < URL_MIN_FRAME_LEN)
d940 1
@


1.8
log
@Plug memory leak; nyar-junk@@int0rnet.net
@
text
@d1 2
a2 2
/*	$OpenBSD: if_url.c,v 1.7 2002/07/25 02:18:10 nate Exp $ */
/*	$NetBSD: if_url.c,v 1.2 2002/03/28 21:49:19 ichiro Exp $	*/
d295 4
d547 1
a547 1
#endif /* defined(__NetBSD__) */
d645 1
a645 1
		if_deactivate(&sc->sc_ac.ec_if);
@


1.7
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.6 2002/07/10 18:08:13 deraadt Exp $ */
d998 1
a998 1
	m_free(c->url_mbuf);
@


1.6
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.5 2002/06/26 11:29:55 espie Exp $ */
d85 1
a85 1
#include <netinet/in.h> 
d436 1
a436 1
	}	
d452 1
a452 1
	
d467 1
a467 1
	
d483 1
a483 1
	
d500 1
a500 1
	
d517 1
a517 1
	
d530 1
a530 1
	
d566 1
a566 1
	
d610 1
a610 1
	
d723 1
a723 1
	
d735 1
a735 1
	
d777 1
a777 1
	
d814 1
a814 1
	
d843 1
a843 1
	
d873 1
a873 1
	
d882 1
a882 1
	
d1214 1
a1214 1
	
d1243 1
a1243 1
	
d1645 1
a1645 1
	
@


1.5
log
@Kill __FUNCTION__.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.4 2002/05/09 16:13:31 nate Exp $ */
d284 1
a284 1
	printf("%s: Ethernet address %s\n", devname, ether_sprintf(eaddr));
@


1.4
log
@Fix ioctl handling
Add default MTU
fix typo

errors noted by Jason Ackley <jason@@ackley.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.3 2002/05/07 19:32:49 nate Exp $ */
d350 1
a350 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d413 1
a413 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d448 1
a448 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d463 1
a463 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d479 1
a479 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d494 1
a494 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d511 1
a511 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d529 1
a529 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d611 1
a611 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d633 1
a633 1
		 __FUNCTION__, act));
d662 1
a662 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d771 1
a771 1
			 __FUNCTION__));
d786 1
a786 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d823 1
a823 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d854 1
a854 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d884 1
a884 1
		 __FUNCTION__, sc->sc_link));
d924 1
a924 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d953 1
a953 1
		 __FUNCTION__, total_len));
d973 1
a973 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1018 1
a1018 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__FUNCTION__));
d1086 1
a1086 1
		 __FUNCTION__, m->m_len));
d1102 1
a1102 1
	DPRINTF(("%s: %s: start rx\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1120 1
a1120 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1215 1
a1215 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1244 1
a1244 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1330 1
a1330 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1353 1
a1353 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1378 1
a1378 1
			__FUNCTION__));
d1399 1
a1399 1
			__FUNCTION__));
d1418 1
a1418 1
				 USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1435 1
a1435 1
			__FUNCTION__));
d1445 1
a1445 1
		       __FUNCTION__));
d1464 1
a1464 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg));
d1469 1
a1469 1
		       __FUNCTION__);
d1477 1
a1477 1
			 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy));
d1506 1
a1506 1
		       USBDEVNAME(sc->sc_dev), __FUNCTION__, reg);
d1519 1
a1519 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg, val));
d1536 1
a1536 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg, data));
d1541 1
a1541 1
		       __FUNCTION__);
d1549 1
a1549 1
			 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy));
d1577 1
a1577 1
		       USBDEVNAME(sc->sc_dev), __FUNCTION__, reg);
d1602 1
a1602 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __FUNCTION__));
d1618 1
a1618 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg));
d1623 1
a1623 1
		       __FUNCTION__);
d1649 1
a1649 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg, val));
d1661 1
a1661 1
		 USBDEVNAME(sc->sc_dev), __FUNCTION__, phy, reg, data));
d1666 1
a1666 1
		       __FUNCTION__);
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.4.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.4.2.1 2002/06/11 03:42:30 art Exp $ */
d85 1
a85 1
#include <netinet/in.h>
d284 1
a284 1
	printf("%s: address %s\n", devname, ether_sprintf(eaddr));
d350 1
a350 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d413 1
a413 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d436 1
a436 1
	}
d448 1
a448 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d452 1
a452 1

d463 1
a463 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d467 1
a467 1

d479 1
a479 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d483 1
a483 1

d494 1
a494 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d500 1
a500 1

d511 1
a511 1
		 ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d517 1
a517 1

d529 2
a530 2
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));

d566 1
a566 1

d610 2
a611 2

	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d633 1
a633 1
		 __func__, act));
d662 1
a662 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d723 1
a723 1

d735 1
a735 1

d771 1
a771 1
			 __func__));
d777 1
a777 1

d786 1
a786 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d814 1
a814 1

d823 1
a823 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d843 1
a843 1

d854 1
a854 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d873 1
a873 1

d882 1
a882 1

d884 1
a884 1
		 __func__, sc->sc_link));
d924 1
a924 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d953 1
a953 1
		 __func__, total_len));
d973 1
a973 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d998 1
a998 1
	m_freem(c->url_mbuf);
d1018 1
a1018 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d1086 1
a1086 1
		 __func__, m->m_len));
d1102 1
a1102 1
	DPRINTF(("%s: %s: start rx\n", USBDEVNAME(sc->sc_dev), __func__));
d1120 1
a1120 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1214 2
a1215 2

	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1243 2
a1244 2

	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1330 1
a1330 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1353 1
a1353 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1378 1
a1378 1
			__func__));
d1399 1
a1399 1
			__func__));
d1418 1
a1418 1
				 USBDEVNAME(sc->sc_dev), __func__));
d1435 1
a1435 1
			__func__));
d1445 1
a1445 1
		       __func__));
d1464 1
a1464 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg));
d1469 1
a1469 1
		       __func__);
d1477 1
a1477 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1506 1
a1506 1
		       USBDEVNAME(sc->sc_dev), __func__, reg);
d1519 1
a1519 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, val));
d1536 1
a1536 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data));
d1541 1
a1541 1
		       __func__);
d1549 1
a1549 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1577 1
a1577 1
		       USBDEVNAME(sc->sc_dev), __func__, reg);
d1602 1
a1602 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1618 1
a1618 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg));
d1623 1
a1623 1
		       __func__);
d1645 1
a1645 1

d1649 1
a1649 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, val));
d1661 1
a1661 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data));
d1666 1
a1666 1
		       __func__);
@


1.4.2.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_url.c,v 1.6 2002/09/29 10:19:21 martin Exp $	*/
d214 1
a214 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
a294 4
#if defined(__NetBSD__)
	ifp->if_init = url_init;
	ifp->if_stop = url_stop;
#endif
d543 1
a543 1
#endif
d641 1
a641 1
		if_deactivate(GET_IFP(sc));
d933 1
a933 2
	if (total_len < URL_MIN_FRAME_LEN) {
		bzero(c->url_buf + total_len, URL_MIN_FRAME_LEN - total_len);
a934 1
	}
@


1.3
log
@Add a driver for Realtek RTL8150L based ethernet devices
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d278 1
a278 1
		printf("%s: read MAC address faild\n", devname);
d289 1
d1115 1
d1128 64
a1196 1

d1198 1
a1198 5
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
		if (error == ENETRESET) {
			url_setmulti(sc);
			error = 0;
		}
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: if_url.c,v 1.1 2002/05/07 18:08:04 nate Exp $ */
d49 1
d52 3
a55 1
#include "rnd.h"
d62 3
d82 1
d85 7
d93 4
a96 1
#include <netinet/if_inarp.h>
d98 2
a293 2
	ifp->if_init = url_init;
	ifp->if_stop = url_stop;
d538 3
d542 1
d640 1
a640 1
		if_deactivate(&sc->sc_ec.ec_if);
d684 1
a684 1
	ETHER_FIRST_MULTI(step, &sc->sc_ec, enm);
d1133 1
a1133 1
		error = ether_ioctl(ifp, cmd, data);
d1377 1
a1377 1
	lockmgr(&sc->sc_mii_lock, LK_EXCLUSIVE, NULL);
d1386 1
a1386 1
	lockmgr(&sc->sc_mii_lock, LK_RELEASE, NULL);
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@

