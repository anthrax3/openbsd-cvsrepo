head	1.42;
access;
symbols
	OPENBSD_6_2:1.42.0.2
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.4
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.41.0.8
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.26.0.10
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.8
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.6
	OPENBSD_5_0:1.26.0.4
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.17.0.10
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.42
date	2017.01.09.14.44.28;	author mpi;	state Exp;
branches;
next	1.41;
commitid	UdDbQS8WFHHpnq1k;

1.41
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.40;
commitid	p4LJxGKbi0BU2cG6;

1.40
date	2014.12.08.22.00.11;	author mpi;	state Exp;
branches;
next	1.39;
commitid	S4AL2dWdKDpjf5ru;

1.39
date	2014.11.07.13.56.29;	author mpi;	state Exp;
branches;
next	1.38;
commitid	gYNQMCaIWvIlAGBb;

1.38
date	2014.08.08.14.20.05;	author mpi;	state Exp;
branches;
next	1.37;
commitid	HPvxK5z15RUEsAkp;

1.37
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.36;
commitid	d8ZHVs7unt3KxWXc;

1.36
date	2014.04.24.09.40.28;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2014.03.07.18.57.23;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.13.13.48.08;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.02.12.23.58;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.10.07.48.36;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2013.04.10.07.37.32;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.09.08.42.48;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.17.23.14.00;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.18.11.53.11;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.10.17.46.27;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.09.12.03.39;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.31.18.20.22;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.21.00.01.08;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.31.04.24.45;	author nate;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.04.11.44.26;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.28.19.37.52;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.11.07.21.30.20;	author fgsch;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.05;	author fgsch;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.26;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove unneeded <sys/malloc.h> from Michael W. Bombardieri.
@
text
@/*	$OpenBSD: usbdi_util.c,v 1.41 2015/03/14 03:38:50 jsg Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.40 2002/07/11 21:14:36 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi_util.c,v 1.14 1999/11/17 22:33:50 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (usbdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) printf x; } while (0)
extern int usbdebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

usbd_status
usbd_get_desc(struct usbd_device *dev, int type, int index, int len, void *desc)
{
	usb_device_request_t req;

	DPRINTFN(3,("usbd_get_desc: type=%d, index=%d, len=%d\n", type, index,
	    len));

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, type, index);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, desc));
}

usbd_status
usbd_get_device_status(struct usbd_device *dev, usb_status_t *st)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(usb_status_t));
	return (usbd_do_request(dev, &req, st));
}

usbd_status
usbd_get_hub_status(struct usbd_device *dev, usb_hub_status_t *st)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(usb_hub_status_t));
	return (usbd_do_request(dev, &req, st));
}

usbd_status
usbd_get_hub_descriptor(struct usbd_device *dev, usb_hub_descriptor_t *hd,
    uint8_t nports)
{
	usb_device_request_t req;
	uint16_t len = USB_HUB_DESCRIPTOR_SIZE + (nports + 1) / 8;

	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_HUB, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, hd));
}

usbd_status
usbd_get_hub_ss_descriptor(struct usbd_device *dev, usb_hub_ss_descriptor_t *hd,
    uint8_t nports)
{
	usb_device_request_t req;
	uint16_t len = USB_HUB_SS_DESCRIPTOR_SIZE + (nports + 1) / 8;

	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_SS_HUB, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, hd));
}

usbd_status
usbd_get_port_status(struct usbd_device *dev, int port, usb_port_status_t *ps)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_CLASS_OTHER;
	req.bRequest = UR_GET_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, port);
	USETW(req.wLength, sizeof *ps);
	return (usbd_do_request(dev, &req, ps));
}

usbd_status
usbd_clear_hub_feature(struct usbd_device *dev, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_hub_feature(struct usbd_device *dev, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_hub_depth(struct usbd_device *dev, int depth)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_DEVICE;
	req.bRequest = UR_SET_DEPTH;
	USETW(req.wValue, depth);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return usbd_do_request(dev, &req, 0);
}

usbd_status
usbd_clear_port_feature(struct usbd_device *dev, int port, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_CLEAR_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_port_feature(struct usbd_device *dev, int port, int sel)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_CLASS_OTHER;
	req.bRequest = UR_SET_FEATURE;
	USETW(req.wValue, sel);
	USETW(req.wIndex, port);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_idle(struct usbd_device *dev, int ifaceno, int duration, int id)
{
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_idle: %d %d\n", duration, id));
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_IDLE;
	USETW2(req.wValue, duration, id);
	USETW(req.wIndex, ifaceno);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_get_report_descriptor(struct usbd_device *dev, int ifaceno,
    void *data, int len)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_INTERFACE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_REPORT, 0); /* report id should be 0 */
	USETW(req.wIndex, ifaceno);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, data));
}

struct usb_hid_descriptor *
usbd_get_hid_descriptor(struct usbd_device *dev, usb_interface_descriptor_t *id)
{
	usb_config_descriptor_t *cdesc = usbd_get_config_descriptor(dev);
	struct usb_hid_descriptor *hd;
	char *p, *end;

	p = (char *)id + id->bLength;
	end = (char *)cdesc + UGETW(cdesc->wTotalLength);

	for (; p < end; p += hd->bLength) {
		hd = (struct usb_hid_descriptor *)p;
		if (p + hd->bLength <= end && hd->bDescriptorType == UDESC_HID)
			return (hd);
		if (hd->bDescriptorType == UDESC_INTERFACE)
			break;
	}
	return (0);
}

usbd_status
usbd_get_config(struct usbd_device *dev, u_int8_t *conf)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_DEVICE;
	req.bRequest = UR_GET_CONFIG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, conf));
}

void
usb_detach_wait(struct device *dv)
{
	DPRINTF(("usb_detach_wait: waiting for %s\n", dv->dv_xname));
	if (tsleep(dv, PZERO, "usbdet", hz * 60))
		printf("usb_detach_wait: %s didn't detach\n", dv->dv_xname);
	DPRINTF(("usb_detach_wait: %s done\n", dv->dv_xname));
}

void
usb_detach_wakeup(struct device *dv)
{
	DPRINTF(("usb_detach_wakeup: for %s\n", dv->dv_xname));
	wakeup(dv);
}
@


1.41
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.40 2014/12/08 22:00:11 mpi Exp $ */
a37 1
#include <sys/malloc.h>
@


1.40
log
@Deprecate usb_*_report().  USB HID devices are always attached below
an uhidev(4) on OpenBSD and there is not point in rerolling your own
reportID handling.  Simply use uhidev_*_report().

This is a first step towards better error handling required to deal
with broken upd(4) firmwares.

Tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.39 2014/11/07 13:56:29 mpi Exp $ */
a47 1
#include <dev/usb/usbdivar.h>
@


1.39
log
@Give Super-Speed hubs a chance to route USB 3.0 transfers.

Without knowing their depth, hubs couldn't find the bits correspdonding
to their downstream port in the route-string.  Now USB 3.0 devices just
work(tm) anywhere in your hub chain.

This commit would not have been possible without the cheese provided by
miod@@ at #HAMoween.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.38 2014/08/08 14:20:05 mpi Exp $ */
a206 45
}

usbd_status
usbd_set_report(struct usbd_device *dev, int ifaceno, int type, int id,
    void *data, int len)
{
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_report: len=%d\n", len));
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifaceno);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, data));
}

usbd_status
usbd_set_report_async(struct usbd_device *dev, int ifaceno, int type, int id,
    void *data, int len)
{
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_report_async: len=%d\n", len));
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifaceno);
	USETW(req.wLength, len);
	return (usbd_do_request_async(dev, &req, data));
}

usbd_status
usbd_get_report(struct usbd_device *dev, int ifaceno, int type, int id,
    void *data, int len)
{
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_report: len=%d\n", len));
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, ifaceno);
	USETW(req.wLength, len);
	return (usbd_do_request(dev, &req, data));
@


1.38
log
@Super Speed hub descriptor definition and routine, required for upcoming
external USB 3.0 hub support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.37 2014/07/09 15:47:54 mpi Exp $ */
d168 13
@


1.37
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.36 2014/04/24 09:40:28 mpi Exp $ */
d111 15
@


1.36
log
@Change the usbd_*_report() family of functions to take a usbd_device
and a infaceno argument instead of an iface pointer.  While here,
remove some unused functions and inlined usbd_read_report_desc since
it is used only once.

This is part of plumbing required to convert the various USB HID devices
to handle multiples report IDs.

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.35 2014/03/07 18:57:23 mpi Exp $ */
a113 13
}

usbd_status
usbd_set_address(struct usbd_device *dev, int addr)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_DEVICE;
	req.bRequest = UR_SET_ADDRESS;
	USETW(req.wValue, addr);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	return usbd_do_request(dev, &req, 0);
@


1.35
log
@Indtroduce usbd_get_hub_descriptor() to start cleaning uhub(4)'s mess.
This will help us deal with the different hub device descriptors used
by super speed devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.34 2013/11/13 13:48:08 pirofti Exp $ */
a58 7
static void
usbd_interface2device_handle(struct usbd_interface *iface,
    struct usbd_device **dev)
{
	*dev = iface->device;
}

d195 2
a196 21
usbd_get_protocol(struct usbd_interface *iface, u_int8_t *report)
{
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_protocol: iface=%p, endpt=%d\n", iface,
	    id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_PROTOCOL;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, report));
}

usbd_status
usbd_set_protocol(struct usbd_interface *iface, int report)
a197 23
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_set_protocol: iface=%p, report=%d, endpt=%d\n",
	    iface, report, id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_PROTOCOL;
	USETW(req.wValue, report);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 0);
	return (usbd_do_request(dev, &req, 0));
}

usbd_status
usbd_set_report(struct usbd_interface *iface, int type, int id, void *data,
    int len)
{
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
a200 3
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
d204 1
a204 1
	USETW(req.wIndex, ifd->bInterfaceNumber);
d210 1
a210 1
usbd_set_report_async(struct usbd_interface *iface, int type, int id,
a212 2
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
a215 3
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
d219 1
a219 1
	USETW(req.wIndex, ifd->bInterfaceNumber);
d225 2
a226 2
usbd_get_report(struct usbd_interface *iface, int type, int id, void *data,
    int len)
a227 2
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
a230 3
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
d234 1
a234 1
	USETW(req.wIndex, ifd->bInterfaceNumber);
d240 1
a240 1
usbd_set_idle(struct usbd_interface *iface, int duration, int id)
a241 2
	usb_interface_descriptor_t *ifd = usbd_get_interface_descriptor(iface);
	struct usbd_device *dev;
a244 3
	if (ifd == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
d248 1
a248 1
	USETW(req.wIndex, ifd->bInterfaceNumber);
d254 2
a255 2
usbd_get_report_descriptor(struct usbd_device *dev, int ifcno, int size,
    void *d)
d262 3
a264 3
	USETW(req.wIndex, ifcno);
	USETW(req.wLength, size);
	return (usbd_do_request(dev, &req, d));
d268 1
a268 1
usbd_get_hid_descriptor(struct usbd_interface *ifc)
d270 1
a270 3
	usb_interface_descriptor_t *idesc = usbd_get_interface_descriptor(ifc);
	struct usbd_device *dev;
	usb_config_descriptor_t *cdesc;
d274 1
a274 6
	if (idesc == NULL)
		return (0);
	usbd_interface2device_handle(ifc, &dev);
	cdesc = usbd_get_config_descriptor(dev);

	p = (char *)idesc + idesc->bLength;
a284 30
}

usbd_status
usbd_read_report_desc(struct usbd_interface *ifc, void **descp, int *sizep,
    int mem)
{
	usb_interface_descriptor_t *id;
	struct usb_hid_descriptor *hid;
	struct usbd_device *dev;
	usbd_status err;

	usbd_interface2device_handle(ifc, &dev);
	id = usbd_get_interface_descriptor(ifc);
	if (id == NULL)
		return (USBD_INVAL);
	hid = usbd_get_hid_descriptor(ifc);
	if (hid == NULL)
		return (USBD_IOERROR);
	*sizep = UGETW(hid->descrs[0].wDescriptorLength);
	*descp = malloc(*sizep, mem, M_NOWAIT);
	if (*descp == NULL)
		return (USBD_NOMEM);
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber, *sizep,
	    *descp);
	if (err) {
		free(*descp, mem);
		*descp = NULL;
		return (err);
	}
	return (USBD_NORMAL_COMPLETION);
@


1.34
log
@Polling is done per controller not per interface.

The controllers are linked through device->bus so the iface is redundant.

So fixing usbd_dopoll() to take the device as argument and making
usbd_interface2device_handle() private (for now) inside usbdi_util.

Tested and okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.33 2013/11/02 12:23:58 mpi Exp $ */
d106 15
@


1.33
log
@Remove a layer of abstraction for fetching a configuration descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.32 2013/09/20 15:34:51 mpi Exp $ */
d41 2
d48 1
d58 7
@


1.32
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.31 2013/04/15 09:23:02 mglocker Exp $ */
a69 20
}

usbd_status
usbd_get_config_desc(struct usbd_device *dev, int confidx,
    usb_config_descriptor_t *d)
{
	usbd_status err;

	DPRINTFN(3,("usbd_get_config_desc: confidx=%d\n", confidx));
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx,
	    USB_CONFIG_DESCRIPTOR_SIZE, d);
	if (err)
		return (err);
	if (d->bDescriptorType != UDESC_CONFIG) {
		DPRINTFN(-1,("usbd_get_config_desc: confidx=%d, bad desc "
		    "len=%d type=%d\n", confidx, d->bLength,
		    d->bDescriptorType));
		return (USBD_INVAL);
	}
	return (USBD_NORMAL_COMPLETION);
@


1.31
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.30 2013/04/10 07:48:36 mpi Exp $ */
a396 84
}

void usbd_bulk_transfer_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void
usbd_bulk_transfer_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	wakeup(xfer);
}

usbd_status
usbd_bulk_transfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    u_int16_t flags, u_int32_t timeout, void *buf, u_int32_t *size, char *lbl)
{
	usbd_status err;
	int s, error, pri;

	usbd_setup_xfer(xfer, pipe, 0, buf, *size, flags, timeout,
	    usbd_bulk_transfer_cb);
	DPRINTFN(1, ("usbd_bulk_transfer: start transfer %d bytes\n", *size));
	s = splusb();		/* don't want callback until tsleep() */
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		splx(s);
		return (err);
	}
	pri = timeout == 0 ? (PZERO | PCATCH) : PZERO;
	error = tsleep((caddr_t)xfer, pri, lbl, 0);
	splx(s);
	if (error) {
		DPRINTF(("usbd_bulk_transfer: tsleep=%d\n", error));
		usbd_abort_pipe(pipe);
		return (USBD_INTERRUPTED);
	}
	usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
	DPRINTFN(1,("usbd_bulk_transfer: transferred %d\n", *size));
	if (err) {
		DPRINTF(("usbd_bulk_transfer: error=%d\n", err));
		usbd_clear_endpoint_stall(pipe);
	}
	return (err);
}

void usbd_intr_transfer_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void
usbd_intr_transfer_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	wakeup(xfer);
}

usbd_status
usbd_intr_transfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    u_int16_t flags, u_int32_t timeout, void *buf, u_int32_t *size, char *lbl)
{
	usbd_status err;
	int s, error, pri;

	usbd_setup_xfer(xfer, pipe, 0, buf, *size, flags, timeout,
	    usbd_intr_transfer_cb);
	DPRINTFN(1, ("usbd_intr_transfer: start transfer %d bytes\n", *size));
	s = splusb();		/* don't want callback until tsleep() */
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
		splx(s);
		return (err);
	}
	pri = timeout == 0 ? (PZERO | PCATCH) : PZERO;
	error = tsleep(xfer, pri, lbl, 0);
	splx(s);
	if (error) {
		DPRINTF(("usbd_intr_transfer: tsleep=%d\n", error));
		usbd_abort_pipe(pipe);
		return (USBD_INTERRUPTED);
	}
	usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
	DPRINTFN(1,("usbd_intr_transfer: transferred %d\n", *size));
	if (err) {
		DPRINTF(("usbd_intr_transfer: error=%d\n", err));
		usbd_clear_endpoint_stall(pipe);
	}
	return (err);
@


1.30
log
@Merge usbd_get_device_desc() into the only function using them.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.29 2013/04/10 07:37:32 mpi Exp $ */
d57 1
a57 1
usbd_get_desc(usbd_device_handle dev, int type, int index, int len, void *desc)
d73 1
a73 1
usbd_get_config_desc(usbd_device_handle dev, int confidx,
d93 1
a93 1
usbd_get_device_status(usbd_device_handle dev, usb_status_t *st)
d106 1
a106 1
usbd_get_hub_status(usbd_device_handle dev, usb_hub_status_t *st)
d119 1
a119 1
usbd_set_address(usbd_device_handle dev, int addr)
d132 1
a132 1
usbd_get_port_status(usbd_device_handle dev, int port, usb_port_status_t *ps)
d145 1
a145 1
usbd_clear_hub_feature(usbd_device_handle dev, int sel)
d158 1
a158 1
usbd_set_hub_feature(usbd_device_handle dev, int sel)
d171 1
a171 1
usbd_clear_port_feature(usbd_device_handle dev, int port, int sel)
d184 1
a184 1
usbd_set_port_feature(usbd_device_handle dev, int port, int sel)
d197 1
a197 1
usbd_get_protocol(usbd_interface_handle iface, u_int8_t *report)
d200 1
a200 1
	usbd_device_handle dev;
d217 1
a217 1
usbd_set_protocol(usbd_interface_handle iface, int report)
d220 1
a220 1
	usbd_device_handle dev;
d237 1
a237 1
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data,
d241 1
a241 1
	usbd_device_handle dev;
d257 1
a257 1
usbd_set_report_async(usbd_interface_handle iface, int type, int id,
d261 1
a261 1
	usbd_device_handle dev;
d277 1
a277 1
usbd_get_report(usbd_interface_handle iface, int type, int id, void *data,
d281 1
a281 1
	usbd_device_handle dev;
d297 1
a297 1
usbd_set_idle(usbd_interface_handle iface, int duration, int id)
d300 1
a300 1
	usbd_device_handle dev;
d316 1
a316 1
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno, int size,
d329 2
a330 2
usb_hid_descriptor_t *
usbd_get_hid_descriptor(usbd_interface_handle ifc)
d333 1
a333 1
	usbd_device_handle dev;
d335 1
a335 1
	usb_hid_descriptor_t *hd;
d347 1
a347 1
		hd = (usb_hid_descriptor_t *)p;
d357 1
a357 1
usbd_read_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
d361 2
a362 2
	usb_hid_descriptor_t *hid;
	usbd_device_handle dev;
d387 1
a387 1
usbd_get_config(usbd_device_handle dev, u_int8_t *conf)
d399 1
a399 1
void usbd_bulk_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d402 1
a402 1
usbd_bulk_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d409 1
a409 1
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
d441 1
a441 1
void usbd_intr_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d444 1
a444 1
usbd_intr_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
d451 1
a451 1
usbd_intr_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
@


1.29
log
@Remove unused function usb_find_desc().
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.28 2013/04/09 08:42:48 mpi Exp $ */
a89 8
}

usbd_status
usbd_get_device_desc(usbd_device_handle dev, usb_device_descriptor_t *d)
{
	DPRINTFN(3,("usbd_get_device_desc:\n"));
	return (usbd_get_desc(dev, UDESC_DEVICE, 0, USB_DEVICE_DESCRIPTOR_SIZE,
	    d));
@


1.28
log
@There's no need for usbd_get_config_desc_full() so just call usbd_get_desc()
directly this also makes it easier to understand which function actually
generates IO.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.27 2013/03/28 03:58:03 tedu Exp $ */
a504 18
}

usb_descriptor_t *
usb_find_desc(usbd_device_handle dev, int type)
{
	usb_descriptor_t *desc;
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
        uByte *p = (uByte *)cd;
        uByte *end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type)
			return (desc);
		p += desc->bLength;
	}

	return (NULL);
@


1.27
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.26 2010/12/17 23:14:00 jakemsr Exp $ */
a89 7
}

usbd_status
usbd_get_config_desc_full(usbd_device_handle dev, int conf, void *d, int size)
{
	DPRINTFN(3,("usbd_get_config_desc_full: conf=%d\n", conf));
	return (usbd_get_desc(dev, UDESC_CONFIG, conf, size, d));
@


1.26
log
@don't catch signals in usbd_{bulk,intr}_transfer if a timeout is
set.  no other transfer methods catch signals, and it is not possible
to restart these transfers reliably.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.25 2008/06/26 05:42:19 ray Exp $ */
a38 1
#include <sys/proc.h>
@


1.25
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.24 2007/06/18 11:53:11 mbalmer Exp $ */
d429 1
a429 1
	int s, error;
d440 2
a441 1
	error = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);
d471 1
a471 1
	int s, error;
d482 2
a483 1
	error = tsleep(xfer, PZERO | PCATCH, lbl, 0);
@


1.24
log
@KNF after macro removals, no binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.23 2007/06/12 16:26:37 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.23
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.22 2007/06/10 17:46:27 mbalmer Exp $ */
d69 2
a70 2
	DPRINTFN(3,("usbd_get_desc: type=%d, index=%d, len=%d\n",
		    type, index, len));
d82 1
a82 1
		     usb_config_descriptor_t *d)
d88 1
a88 1
			    USB_CONFIG_DESCRIPTOR_SIZE, d);
d93 2
a94 2
			     "len=%d type=%d\n",
			     confidx, d->bLength, d->bDescriptorType));
d111 2
a112 2
	return (usbd_get_desc(dev, UDESC_DEVICE,
			     0, USB_DEVICE_DESCRIPTOR_SIZE, d));
d226 2
a227 2
	DPRINTFN(4, ("usbd_get_protocol: iface=%p, endpt=%d\n",
		     iface, id->bInterfaceNumber));
d247 1
a247 1
		     iface, report, id->bInterfaceNumber));
d261 1
a261 1
		int len)
d281 1
a281 1
		      void *data, int len)
d301 1
a301 1
		int len)
d339 2
a340 2
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
			   int size, void *d)
d381 1
a381 1
		       int mem)
d399 2
a400 2
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber,
					 *sizep, *descp);
d422 2
a423 2
void usbd_bulk_transfer_cb(usbd_xfer_handle xfer,
				  usbd_private_handle priv, usbd_status status);
d426 1
a426 1
		      usbd_status status)
d433 1
a433 2
		   u_int16_t flags, u_int32_t timeout, void *buf,
		   u_int32_t *size, char *lbl)
d438 2
a439 2
	usbd_setup_xfer(xfer, pipe, 0, buf, *size,
			flags, timeout, usbd_bulk_transfer_cb);
d463 2
a464 2
void usbd_intr_transfer_cb(usbd_xfer_handle xfer,
				  usbd_private_handle priv, usbd_status status);
d467 1
a467 1
		      usbd_status status)
d474 1
a474 2
		   u_int16_t flags, u_int32_t timeout, void *buf,
		   u_int32_t *size, char *lbl)
d479 2
a480 2
	usbd_setup_xfer(xfer, pipe, 0, buf, *size,
			flags, timeout, usbd_intr_transfer_cb);
d509 1
a509 2
		printf("usb_detach_wait: %s didn't detach\n",
		        dv->dv_xname);
@


1.22
log
@Get rid of the USBDEVPTRNAME macro.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.21 2007/06/09 12:03:39 mbalmer Exp $ */
d507 1
a507 1
usb_detach_wait(device_ptr_t dv)
d517 1
a517 1
usb_detach_wakeup(device_ptr_t dv)
@


1.21
log
@Remove the definition and use of usb_malloc_type which is really int.
While here, reindent the function prototypes in usbdi_util.h

No binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.20 2007/06/05 08:43:56 mbalmer Exp $ */
d509 1
a509 1
	DPRINTF(("usb_detach_wait: waiting for %s\n", USBDEVPTRNAME(dv)));
d512 2
a513 2
		        USBDEVPTRNAME(dv));
	DPRINTF(("usb_detach_wait: %s done\n", USBDEVPTRNAME(dv)));
d519 1
a519 1
	DPRINTF(("usb_detach_wakeup: for %s\n", USBDEVPTRNAME(dv)));
@


1.20
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.19 2007/05/31 18:20:22 mbalmer Exp $ */
d381 1
a381 1
		       usb_malloc_type mem)
@


1.19
log
@Remove more #ifdef/#endif's that checked for other bsds.  No binary
change, no functionality change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.18 2007/05/21 05:40:28 jsg Exp $ */
d422 1
a422 1
Static void usbd_bulk_transfer_cb(usbd_xfer_handle xfer,
d424 1
a424 1
Static void
d464 1
a464 1
Static void usbd_intr_transfer_cb(usbd_xfer_handle xfer,
d466 1
a466 1
Static void
@


1.18
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.17 2004/07/21 00:01:08 dlg Exp $ */
a45 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a47 3
#elif defined(__FreeBSD__)
#include <sys/bus.h>
#endif
@


1.17
log
@from freebsd, ugen.c 1.68 usbdi_util.c 1.27 usbdi_util.h 1.15
log message:
Implement outgoing interrupt pipes. It is part of the USB 1.1 spec.
The Lego Infrared Tower use it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.16 2004/07/08 22:18:45 deraadt Exp $ */
d60 2
a61 2
#define DPRINTF(x)	do { if (usbdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) logprintf x; } while (0)
@


1.16
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.15 2003/07/08 13:19:09 nate Exp $ */
d463 42
@


1.15
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.14 2002/07/25 02:18:11 nate Exp $ */
d60 2
a61 2
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
@


1.14
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.c,v 1.13 2002/05/07 18:29:19 nate Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.35 2001/10/26 17:58:21 augustss Exp $	*/
d223 19
a248 1
	usbd_status err;
d254 1
a254 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a269 1
	usbd_status err;
d274 1
a274 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d284 2
a285 2
usbd_set_report_async(usbd_interface_handle iface, int type, int id, void *data,
		      int len)
a289 1
	usbd_status err;
d294 1
a294 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a309 1
	usbd_status err;
d314 1
a314 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a328 1
	usbd_status err;
d333 1
a333 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a363 1
	usbd_status err;
d367 1
a367 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (0);
d392 1
a392 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (err);
d483 18
@


1.13
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.11 2001/10/31 04:24:45 nate Exp $ */
d85 1
a85 1
usbd_get_config_desc(usbd_device_handle dev, int confidx, 
d91 1
a91 1
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx, 
d115 1
a115 1
	return (usbd_get_desc(dev, UDESC_DEVICE, 
d130 1
a130 1
}	
d143 1
a143 1
}	
d248 1
a248 1
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data, 
d414 1
a414 1
usbd_status 
d437 1
a437 1
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe, 
d477 1
a477 1
}       
d484 1
a484 1
}       
@


1.12
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi_util.c,v 1.39 2001/12/27 11:24:42 augustss Exp $	*/
a222 19
usbd_status
usbd_get_protocol(usbd_interface_handle iface, u_int8_t *report)
{
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_protocol: iface=%p, endpt=%d\n",
		     iface, id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_PROTOCOL;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, report));
}
d230 1
d236 3
a238 1
	usbd_interface2device_handle(iface, &dev);
d254 1
d259 3
a261 1
	usbd_interface2device_handle(iface, &dev);
d271 2
a272 2
usbd_set_report_async(usbd_interface_handle iface, int type, int id,
		      void *data, int len)
d277 1
d282 3
a284 1
	usbd_interface2device_handle(iface, &dev);
d300 1
d305 3
a307 1
	usbd_interface2device_handle(iface, &dev);
d322 1
d327 3
a329 1
	usbd_interface2device_handle(iface, &dev);
d360 1
d364 3
a366 1
	usbd_interface2device_handle(ifc, &dev);
d391 3
a393 1
	usbd_interface2device_handle(ifc, &dev);
a484 18

usb_descriptor_t *
usb_find_desc(usbd_device_handle dev, int type)
{
	usb_descriptor_t *desc;
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
        uByte *p = (uByte *)cd;
        uByte *end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type)
			return (desc);
		p += desc->bLength;
	}

	return (NULL);
}
@


1.11
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.c,v 1.10 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.35 2001/10/26 17:58:21 augustss Exp $	*/
d223 19
a248 1
	usbd_status err;
d254 1
a254 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a269 1
	usbd_status err;
d274 1
a274 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d284 2
a285 2
usbd_set_report_async(usbd_interface_handle iface, int type, int id, void *data,
		      int len)
a289 1
	usbd_status err;
d294 1
a294 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a309 1
	usbd_status err;
d314 1
a314 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a328 1
	usbd_status err;
d333 1
a333 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
a363 1
	usbd_status err;
d367 1
a367 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (0);
d392 1
a392 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (err);
d484 18
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.11 2001/10/31 04:24:45 nate Exp $ */
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.11.2.1 2002/06/11 03:42:31 art Exp $ */
d85 1
a85 1
usbd_get_config_desc(usbd_device_handle dev, int confidx,
d91 1
a91 1
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx,
d115 1
a115 1
	return (usbd_get_desc(dev, UDESC_DEVICE,
d130 1
a130 1
}
d143 1
a143 1
}
d248 1
a248 1
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data,
d414 1
a414 1
usbd_status
d437 1
a437 1
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
d477 1
a477 1
}
d484 1
a484 1
}
@


1.10
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.c,v 1.9 2000/07/04 11:44:26 fgsch Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.33 2000/06/01 15:51:27 augustss Exp $	*/
d339 1
a339 1
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno, int repid,
d346 1
a346 1
	USETW2(req.wValue, UDESC_REPORT, repid);
d383 1
a383 1
usbd_alloc_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
d404 2
a405 3
	/* XXX should not use 0 Report ID */
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber, 0, 
				       *sizep, *descp);
d408 1
@


1.9
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.c,v 1.8 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.29 2000/03/27 12:33:59 augustss Exp $	*/
d69 1
a69 5
usbd_get_desc(dev, type, index, len, desc)
	usbd_device_handle dev;
	int type, index;
	int len;
	void *desc;
d85 2
a86 4
usbd_get_config_desc(dev, confidx, d)
	usbd_device_handle dev;
	int confidx;
	usb_config_descriptor_t *d;
d105 1
a105 5
usbd_get_config_desc_full(dev, conf, d, size)
	usbd_device_handle dev;
	int conf;
	void *d;
	int size;
d112 1
a112 3
usbd_get_device_desc(dev, d)
	usbd_device_handle dev;
	usb_device_descriptor_t *d;
d120 1
a120 3
usbd_get_device_status(dev, st)
	usbd_device_handle dev;
	usb_status_t *st;
d133 1
a133 3
usbd_get_hub_status(dev, st)
	usbd_device_handle dev;
	usb_hub_status_t *st;
d146 1
a146 3
usbd_set_address(dev, addr)
	usbd_device_handle dev;
	int addr;
d159 1
a159 4
usbd_get_port_status(dev, port, ps)
	usbd_device_handle dev;
	int port;
	usb_port_status_t *ps;
d172 1
a172 3
usbd_clear_hub_feature(dev, sel)
	usbd_device_handle dev;
	int sel;
d185 1
a185 3
usbd_set_hub_feature(dev, sel)
	usbd_device_handle dev;
	int sel;
d198 1
a198 3
usbd_clear_port_feature(dev, port, sel)
	usbd_device_handle dev;
	int port, sel;
d211 1
a211 3
usbd_set_port_feature(dev, port, sel)
	usbd_device_handle dev;
	int port, sel;
d225 1
a225 3
usbd_set_protocol(iface, report)
	usbd_interface_handle iface;
	int report;
d248 2
a249 6
usbd_set_report(iface, type, id, data, len)
	usbd_interface_handle iface;
	int type;
	int id;
	void *data;
	int len;
d271 2
a272 6
usbd_set_report_async(iface, type, id, data, len)
	usbd_interface_handle iface;
	int type;
	int id;
	void *data;
	int len;
d294 2
a295 6
usbd_get_report(iface, type, id, data, len)
	usbd_interface_handle iface;
	int type;
	int id;
	void *data;
	int len;
d317 1
a317 4
usbd_set_idle(iface, duration, id)
	usbd_interface_handle iface;
	int duration;
	int id;
d339 2
a340 6
usbd_get_report_descriptor(dev, ifcno, repid, size, d)
	usbd_device_handle dev;
	int ifcno;
	int repid;
	int size;
	void *d;
d353 1
a353 2
usbd_get_hid_descriptor(ifc)
	usbd_interface_handle ifc;
d383 2
a384 5
usbd_alloc_report_desc(ifc, descp, sizep, mem)
	usbd_interface_handle ifc;
	void **descp;
	int *sizep;
	usb_malloc_type mem;
d415 1
a415 3
usbd_get_config(dev, conf)
	usbd_device_handle dev;
	u_int8_t *conf;
d427 2
a428 2
Static void usbd_bulk_transfer_cb __P((usbd_xfer_handle xfer, 
		usbd_private_handle priv, usbd_status status));
d430 2
a431 4
usbd_bulk_transfer_cb(xfer, priv, status)
	usbd_xfer_handle xfer;
	usbd_private_handle priv;
	usbd_status status;
d437 3
a439 8
usbd_bulk_transfer(xfer, pipe, flags, timeout, buf, size, lbl)
	usbd_xfer_handle xfer;
	usbd_pipe_handle pipe;
	u_int16_t flags;
	u_int32_t timeout;
	void *buf;
	u_int32_t *size;
	char *lbl;
d470 1
a470 2
usb_detach_wait(dv)
	device_ptr_t dv;
d480 1
a480 2
usb_detach_wakeup(dv)
	device_ptr_t dv;
@


1.8
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.7 2000/03/28 19:37:52 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d438 1
a438 6
#if defined(__NetBSD__) || defined(__OpenBSD__)
	int mem;
#elif defined(__FreeBSD__)
	struct malloc_type *mem;
#endif
	
@


1.7
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi_util.c,v 1.28 2000/02/22 11:25:06 augustss Exp $	*/
d488 1
a488 1
static void usbd_bulk_transfer_cb __P((usbd_xfer_handle xfer, 
d490 1
a490 1
static void
@


1.6
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.5 1999/11/07 21:30:20 fgsch Exp $	*/
d3 1
d97 1
a97 1
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx,
d102 1
a102 1
		DPRINTFN(-1,("usbd_get_config_desc: confidx=%d, bad desc ",
d488 1
a488 1
static void usbd_bulk_transfer_cb __P((usbd_xfer_handle xfer,
d530 1
a530 1
	if (err != USBD_NORMAL_COMPLETION) {
@


1.5
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usbdi_util.c,v 1.22 1999/10/13 08:10:59 augustss Exp $	*/
d45 1
a47 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/device.h>
d76 3
d88 1
a88 1
usbd_get_config_desc(dev, conf, d)
d90 1
a90 1
	int conf;
d93 1
a93 1
	usbd_status r;
d95 5
a99 5
	DPRINTFN(3,("usbd_get_config_desc: conf=%d\n", conf));
	r = usbd_get_desc(dev, UDESC_CONFIG, conf, 
			  USB_CONFIG_DESCRIPTOR_SIZE, d);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d101 3
a103 2
		DPRINTFN(-1,("usbd_get_config_desc: conf %d, bad desc %d\n",
			     conf, d->bDescriptorType));
d260 1
a260 1
	usbd_status r;
d264 1
a264 1
	if (!id)
d266 3
a268 5
	r = usbd_interface2device_handle(iface, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!id)
		return (USBD_INVAL);
d288 1
a288 1
	usbd_status r;
d291 1
a291 1
	if (!ifd)
d293 3
a295 5
	r = usbd_interface2device_handle(iface, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!ifd)
		return (USBD_INVAL);
d315 1
a315 1
	usbd_status r;
d318 1
a318 1
	if (!ifd)
d320 3
a322 5
	r = usbd_interface2device_handle(iface, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!ifd)
		return (USBD_INVAL);
d342 1
a342 1
	usbd_status r;
d344 2
a345 2
	DPRINTFN(4, ("usbd_set_report: len=%d\n", len));
	if (!id)
d347 3
a349 5
	r = usbd_interface2device_handle(iface, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!ifd)
		return (USBD_INVAL);
d367 1
a367 1
	usbd_status r;
d370 1
a370 1
	if (!ifd)
d372 3
a374 5
	r = usbd_interface2device_handle(iface, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	if (!ifd)
		return (USBD_INVAL);
d410 1
a410 1
	usbd_status r;
d412 1
a412 1
	if (!idesc)
d414 2
a415 2
	r = usbd_interface2device_handle(ifc, &dev);
	if (r != USBD_NORMAL_COMPLETION)
d447 1
a447 1
	usbd_status r;
d449 3
a451 3
	r = usbd_interface2device_handle(ifc, &dev);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d453 1
a453 1
	if (!id)
d456 1
a456 1
	if (!hid)
d460 1
a460 1
	if (!*descp)
d463 1
a463 1
	r = usbd_get_report_descriptor(dev, id->bInterfaceNumber, 0, 
d465 1
a465 1
	if (r != USBD_NORMAL_COMPLETION) {
d467 1
a467 1
		return (r);
d487 1
a487 1
static void usbd_bulk_transfer_cb __P((usbd_request_handle reqh, 
d490 2
a491 2
usbd_bulk_transfer_cb(reqh, priv, status)
	usbd_request_handle reqh;
d495 1
a495 1
	wakeup(reqh);
d499 2
a500 2
usbd_bulk_transfer(reqh, pipe, flags, timeout, buf, size, lbl)
	usbd_request_handle reqh;
d508 1
a508 1
	usbd_status r;
d511 2
a512 2
	usbd_setup_request(reqh, pipe, 0, buf, *size,
			   flags, timeout, usbd_bulk_transfer_cb);
d515 2
a516 2
	r = usbd_transfer(reqh);
	if (r != USBD_IN_PROGRESS) {
d518 1
a518 1
		return (r);
d520 1
a520 1
	error = tsleep((caddr_t)reqh, PZERO | PCATCH, lbl, 0);
d527 1
a527 1
	usbd_get_request_status(reqh, 0, 0, size, &r);
d529 2
a530 2
	if (r != USBD_NORMAL_COMPLETION) {
		DPRINTF(("usbd_bulk_transfer: error=%d\n", r));
d533 1
a533 1
	return (r);
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usbdi_util.c,v 1.10 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi_util.c,v 1.33 2000/06/01 15:51:27 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi_util.c,v 1.14 1999/11/17 22:33:50 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d45 2
a47 1
#include <sys/proc.h>
d69 5
a73 1
usbd_get_desc(usbd_device_handle dev, int type, int index, int len, void *desc)
a76 3
	DPRINTFN(3,("usbd_get_desc: type=%d, index=%d, len=%d\n",
		    type, index, len));

d86 4
a89 2
usbd_get_config_desc(usbd_device_handle dev, int confidx, 
		     usb_config_descriptor_t *d)
d91 1
a91 1
	usbd_status err;
d93 5
a97 5
	DPRINTFN(3,("usbd_get_config_desc: confidx=%d\n", confidx));
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx, 
			    USB_CONFIG_DESCRIPTOR_SIZE, d);
	if (err)
		return (err);
d99 2
a100 3
		DPRINTFN(-1,("usbd_get_config_desc: confidx=%d, bad desc "
			     "len=%d type=%d\n",
			     confidx, d->bLength, d->bDescriptorType));
d107 5
a111 1
usbd_get_config_desc_full(usbd_device_handle dev, int conf, void *d, int size)
d118 3
a120 1
usbd_get_device_desc(usbd_device_handle dev, usb_device_descriptor_t *d)
d128 3
a130 1
usbd_get_device_status(usbd_device_handle dev, usb_status_t *st)
d143 3
a145 1
usbd_get_hub_status(usbd_device_handle dev, usb_hub_status_t *st)
d158 3
a160 1
usbd_set_address(usbd_device_handle dev, int addr)
d173 4
a176 1
usbd_get_port_status(usbd_device_handle dev, int port, usb_port_status_t *ps)
d189 3
a191 1
usbd_clear_hub_feature(usbd_device_handle dev, int sel)
d204 3
a206 1
usbd_set_hub_feature(usbd_device_handle dev, int sel)
d219 3
a221 1
usbd_clear_port_feature(usbd_device_handle dev, int port, int sel)
d234 3
a236 1
usbd_set_port_feature(usbd_device_handle dev, int port, int sel)
d250 3
a252 1
usbd_set_protocol(usbd_interface_handle iface, int report)
d257 1
a257 1
	usbd_status err;
d261 1
a261 1
	if (id == NULL)
d263 5
a267 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d277 6
a282 2
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data, 
		int len)
d287 1
a287 1
	usbd_status err;
d290 1
a290 1
	if (ifd == NULL)
d292 5
a296 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d306 6
a311 2
usbd_set_report_async(usbd_interface_handle iface, int type, int id, void *data,
		      int len)
d316 1
a316 1
	usbd_status err;
d319 1
a319 1
	if (ifd == NULL)
d321 5
a325 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d335 6
a340 2
usbd_get_report(usbd_interface_handle iface, int type, int id, void *data,
		int len)
d345 1
a345 1
	usbd_status err;
d347 2
a348 2
	DPRINTFN(4, ("usbd_get_report: len=%d\n", len));
	if (ifd == NULL)
d350 5
a354 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d364 4
a367 1
usbd_set_idle(usbd_interface_handle iface, int duration, int id)
d372 1
a372 1
	usbd_status err;
d375 1
a375 1
	if (ifd == NULL)
d377 5
a381 3
	err = usbd_interface2device_handle(iface, &dev);
	if (err)
		return (err);
d391 6
a396 2
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno, int repid,
			   int size, void *d)
d409 2
a410 1
usbd_get_hid_descriptor(usbd_interface_handle ifc)
d417 1
a417 1
	usbd_status err;
d419 1
a419 1
	if (idesc == NULL)
d421 2
a422 2
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
d440 10
a449 2
usbd_alloc_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
		       usb_malloc_type mem)
d454 1
a454 1
	usbd_status err;
d456 3
a458 3
	err = usbd_interface2device_handle(ifc, &dev);
	if (err)
		return (err);
d460 1
a460 1
	if (id == NULL)
d463 1
a463 1
	if (hid == NULL)
d467 1
a467 1
	if (*descp == NULL)
d470 1
a470 1
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber, 0, 
d472 1
a472 1
	if (err) {
d474 1
a474 1
		return (err);
d480 3
a482 1
usbd_get_config(usbd_device_handle dev, u_int8_t *conf)
d494 9
a502 7
Static void usbd_bulk_transfer_cb(usbd_xfer_handle xfer,
				  usbd_private_handle priv, usbd_status status);
Static void
usbd_bulk_transfer_cb(usbd_xfer_handle xfer, usbd_private_handle priv,
		      usbd_status status)
{
	wakeup(xfer);
d506 8
a513 3
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe, 
		   u_int16_t flags, u_int32_t timeout, void *buf,
		   u_int32_t *size, char *lbl)
d515 1
a515 1
	usbd_status err;
d518 2
a519 2
	usbd_setup_xfer(xfer, pipe, 0, buf, *size,
			flags, timeout, usbd_bulk_transfer_cb);
d522 2
a523 2
	err = usbd_transfer(xfer);
	if (err != USBD_IN_PROGRESS) {
d525 1
a525 1
		return (err);
d527 1
a527 1
	error = tsleep((caddr_t)xfer, PZERO | PCATCH, lbl, 0);
d534 1
a534 1
	usbd_get_xfer_status(xfer, NULL, NULL, size, &err);
d536 2
a537 2
	if (err) {
		DPRINTF(("usbd_bulk_transfer: error=%d\n", err));
d540 1
a540 1
	return (err);
d544 2
a545 1
usb_detach_wait(device_ptr_t dv)
d555 2
a556 1
usb_detach_wakeup(device_ptr_t dv)
@


1.5.2.2
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi_util.c,v 1.35 2001/10/26 17:58:21 augustss Exp $	*/
d339 1
a339 1
usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
d346 1
a346 1
	USETW2(req.wValue, UDESC_REPORT, 0); /* report id should be 0 */
d383 1
a383 1
usbd_read_report_desc(usbd_interface_handle ifc, void **descp, int *sizep,
d404 3
a406 2
	err = usbd_get_report_descriptor(dev, id->bInterfaceNumber,
					 *sizep, *descp);
a408 1
		*descp = NULL;
@


1.5.2.3
log
@Sync the SMP branch with 3.3
@
text
@d85 1
a85 1
usbd_get_config_desc(usbd_device_handle dev, int confidx,
d91 1
a91 1
	err = usbd_get_desc(dev, UDESC_CONFIG, confidx,
d115 1
a115 1
	return (usbd_get_desc(dev, UDESC_DEVICE,
d130 1
a130 1
}
d143 1
a143 1
}
d248 1
a248 1
usbd_set_report(usbd_interface_handle iface, int type, int id, void *data,
d414 1
a414 1
usbd_status
d437 1
a437 1
usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
d477 1
a477 1
}
d484 1
a484 1
}
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi_util.c,v 1.40 2002/07/11 21:14:36 augustss Exp $	*/
a222 19
usbd_status
usbd_get_protocol(usbd_interface_handle iface, u_int8_t *report)
{
	usb_interface_descriptor_t *id = usbd_get_interface_descriptor(iface);
	usbd_device_handle dev;
	usb_device_request_t req;

	DPRINTFN(4, ("usbd_get_protocol: iface=%p, endpt=%d\n",
		     iface, id->bInterfaceNumber));
	if (id == NULL)
		return (USBD_IOERROR);
	usbd_interface2device_handle(iface, &dev);
	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_PROTOCOL;
	USETW(req.wValue, 0);
	USETW(req.wIndex, id->bInterfaceNumber);
	USETW(req.wLength, 1);
	return (usbd_do_request(dev, &req, report));
}
d230 1
d236 3
a238 1
	usbd_interface2device_handle(iface, &dev);
d254 1
d259 3
a261 1
	usbd_interface2device_handle(iface, &dev);
d271 2
a272 2
usbd_set_report_async(usbd_interface_handle iface, int type, int id,
		      void *data, int len)
d277 1
d282 3
a284 1
	usbd_interface2device_handle(iface, &dev);
d300 1
d305 3
a307 1
	usbd_interface2device_handle(iface, &dev);
d322 1
d327 3
a329 1
	usbd_interface2device_handle(iface, &dev);
d360 1
d364 3
a366 1
	usbd_interface2device_handle(ifc, &dev);
d391 3
a393 1
	usbd_interface2device_handle(ifc, &dev);
a483 18
}

usb_descriptor_t *
usb_find_desc(usbd_device_handle dev, int type)
{
	usb_descriptor_t *desc;
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
        uByte *p = (uByte *)cd;
        uByte *end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type)
			return (desc);
		p += desc->bLength;
	}

	return (NULL);
@


1.4
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi_util.c,v 1.21 1999/09/09 12:26:48 augustss Exp $	*/
d47 3
a49 1
#if defined(__FreeBSD__)
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.c,v 1.2 1999/08/16 22:08:49 fgsch Exp $	*/
/*	$NetBSD: usbdi_util.c,v 1.16 1999/08/07 23:14:17 augustss Exp $	*/
d516 2
a517 4
	r = usbd_setup_request(reqh, pipe, 0, buf, *size,
			       flags, timeout, usbd_bulk_transfer_cb);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d543 1
a543 1
	bdevice *dv;
d545 1
a545 1
	DPRINTF(("usb_detach_wait: waiting for %s\n", USBDEVNAME(*dv)));
d548 2
a549 2
		        USBDEVNAME(*dv));
	DPRINTF(("usb_detach_wait: %s done\n", USBDEVNAME(*dv)));
d554 1
a554 1
	bdevice *dv;
d556 1
a556 1
	DPRINTF(("usb_detach_wakeup: for %s\n", USBDEVNAME(*dv)));
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.c,v 1.1 1999/08/13 05:28:05 fgsch Exp $	*/
d504 1
a504 1
usbd_bulk_transfer(reqh, pipe, flags, buf, size, lbl)
d508 1
a512 2
	usbd_private_handle priv;
	void *buffer;
d517 1
a517 1
			       flags, USBD_NO_TIMEOUT, usbd_bulk_transfer_cb);
d534 1
a534 1
	usbd_get_request_status(reqh, &priv, &buffer, size, &r);
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 2
a59 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
@

