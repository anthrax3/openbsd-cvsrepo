head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.18
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.16
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.10
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.12
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.4
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.8
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.10
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.8
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.31.0.12
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.8
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.10
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.6
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23;
locks; strict;
comment	@ * @;


1.33
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.09.11.06.53;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.18.18.20.17;	author mk;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.27.04.21.13;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.27.03.58.07;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.07.22.47.08;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.23.20.09.31;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.08.12.15.12;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.03.11.42.48;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.23.13.19.38;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.20.12.11.57;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.13.08.09.51;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.12.05.30.48;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.08.21.04.44;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.08.21.01.33;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.05.12.25.59;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.05.01.51.20;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.05.00.16.14;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.04.23.56.50;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.04.23.36.15;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.04.08.29.42;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.04.08.02.02;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.23.02.40.34;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.21.04.55.36;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.17.14.00.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.16.08.57.29;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.15.12.50.08;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.12.12.12.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.09.14.42.26;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.08.22.09.11;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@/*	$OpenBSD: if_atureg.h,v 1.32 2010/12/06 04:41:39 jakemsr Exp $ */
/*
 * Copyright (c) 2003
 *	Daan Vreeken <Danovitsch@@Vitsch.net>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Daan Vreeken.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY DAAN VREEKEN AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Daan Vreeken OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#define ATU_CONFIG_NO		1
#define ATU_IFACE_IDX		0

/* the number of simultaneously requested RX transfers */
#define ATU_RX_LIST_CNT	1

/*
 * the number of simultaneously started TX transfers
 * my measurements :
 * 1		430.82 KB/sec
 * 2		534.66 KB/sec
 * 3		536.23 KB/sec
 * 4		537.80 KB/sec
 * 6		537.30 KB/sec
 * 8		535.31 KB/sec
 * 16		535.68 KB/sec
 * 128		535.67 KB/sec (before you ask : yes, 128 is silly :)
 * (+/- 24% increase)
 */
#define ATU_TX_LIST_CNT	8

/*
 * According to the 802.11 spec (7.1.2) the frame body can be up to 2312 bytes
 */
#define ATU_RX_BUFSZ		(ATU_RX_HDRLEN + \
				 sizeof(struct ieee80211_frame_addr4) + 2312 + 4)
/* BE CAREFUL! should add ATU_TX_PADDING */
#define ATU_TX_BUFSZ		(ATU_TX_HDRLEN + \
				 sizeof(struct ieee80211_frame_addr4) + 2312)

#define ATU_MIN_FRAMELEN	60

/*
 * Sending packets of more than 1500 bytes confuses some access points, so the
 * default MTU is set to 1500 but can be increased up to 2310 bytes using
 * ifconfig
 */
#define ATU_DEFAULT_MTU	1500
#define ATU_MAX_MTU		(2312 - 2)

#define ATU_ENDPT_RX		0x0
#define ATU_ENDPT_TX		0x1
#define ATU_ENDPT_MAX		0x2

#define ATU_TX_TIMEOUT		10000
#define ATU_JOIN_TIMEOUT	2000

#define ATU_NO_QUIRK		0x0000
#define ATU_QUIRK_NO_REMAP	0x0001
#define ATU_QUIRK_FW_DELAY	0x0002

#define ATU_DEFAULT_SSID	""
#define ATU_DEFAULT_CHANNEL	10

enum atu_radio_type {
	RadioRFMD = 0,
	RadioRFMD2958,
	RadioRFMD2958_SMC,
	RadioIntersil,
	AT76C503_i3863,
	AT76C503_rfmd_acc,
	AT76C505_rfmd
};

struct atu_type {
	u_int16_t		atu_vid;
	u_int16_t		atu_pid;
	enum atu_radio_type	atu_radio;
	u_int16_t		atu_quirk;
};

struct atu_softc;

struct atu_chain {
	struct atu_softc	*atu_sc;
	struct usbd_xfer	*atu_xfer;
	char			*atu_buf;
	struct mbuf		*atu_mbuf;
	u_int8_t		atu_idx;
	u_int16_t		atu_length;
	int			atu_in_xfer;
	SLIST_ENTRY(atu_chain)	atu_list;
};

/* Radio capture format */

#define ATU_RX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_TSFT)			|	\
	 (1 << IEEE80211_RADIOTAP_FLAGS)		|	\
	 (1 << IEEE80211_RADIOTAP_RATE)			|	\
	 (1 << IEEE80211_RADIOTAP_CHANNEL)		|	\
	 (1 << IEEE80211_RADIOTAP_LOCK_QUALITY)		|	\
	 (1 << IEEE80211_RADIOTAP_RSSI)			|	\
	 0)

struct atu_rx_radiotap_header {
	struct ieee80211_radiotap_header	rr_ihdr;
	u_int64_t				rr_tsft;
	u_int8_t				rr_flags;
	u_int8_t				rr_rate;
	u_int16_t				rr_chan_freq;
	u_int16_t				rr_chan_flags;
	u_int16_t				rr_barker_lock;
	u_int8_t				rr_rssi;
	u_int8_t				rr_max_rssi;
} __packed;

#define ATU_TX_RADIOTAP_PRESENT				\
	((1 << IEEE80211_RADIOTAP_FLAGS)	|	\
	 (1 << IEEE80211_RADIOTAP_RATE)		|	\
	 (1 << IEEE80211_RADIOTAP_CHANNEL)	|	\
	 0)

struct atu_tx_radiotap_header {
	struct ieee80211_radiotap_header	rt_ihdr;
	u_int8_t				rt_flags;
	u_int8_t				rt_rate;
	u_int16_t				rt_chan_freq;
	u_int16_t				rt_chan_flags;
} __packed;

struct atu_cdata {
	struct atu_chain	atu_tx_chain[ATU_TX_LIST_CNT];
	struct atu_chain	atu_rx_chain[ATU_RX_LIST_CNT];

	SLIST_HEAD(atu_list_head, atu_chain)	atu_rx_free;
	struct atu_list_head	atu_tx_free;

	u_int8_t		atu_tx_inuse;
	u_int8_t		atu_tx_last_idx;	
};

#define MAX_SSID_LEN		32
#define ATU_AVG_TIME		20

struct atu_softc {
	struct device           atu_dev;
	struct ieee80211com	sc_ic;
	int			(*sc_newstate)(struct ieee80211com *,
				    enum ieee80211_state, int);

	char			sc_cmd;
#define ATU_C_NONE		0
#define ATU_C_SCAN		1
#define ATU_C_JOIN		2
	struct usb_task		sc_task;

	struct usbd_device	*atu_udev;
	struct usbd_interface	*atu_iface;
	struct ifmedia		atu_media;
	int			atu_ed[ATU_ENDPT_MAX];
	struct usbd_pipe	*atu_ep[ATU_ENDPT_MAX];
	int			atu_unit;
	int			atu_if_flags;

	struct atu_cdata	atu_cdata;

	struct timeval		atu_rx_notice;
	
	u_int8_t		atu_bssid[ETHER_ADDR_LEN];
	enum atu_radio_type	atu_radio;
	u_int16_t		atu_quirk;
	
	u_int8_t		atu_channel;
	u_int16_t		atu_desired_channel;
	u_int8_t		atu_mode;
#define NO_MODE_YET		0
#define AD_HOC_MODE		1
#define INFRASTRUCTURE_MODE	2

	u_int8_t		atu_radio_on;
	caddr_t			sc_radiobpf;

	union {
		struct atu_rx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_rxtapu;
	union {
		struct atu_tx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_txtapu;

};

#define sc_rxtap	sc_rxtapu.tap
#define sc_txtap	sc_txtapu.tap

/* Commands for uploading the firmware (standard DFU interface) */
#define DFU_DNLOAD		UT_WRITE_CLASS_INTERFACE, 0x01
#define DFU_GETSTATUS		UT_READ_CLASS_INTERFACE, 0x03
#define DFU_GETSTATE		UT_READ_CLASS_INTERFACE, 0x05
#define DFU_REMAP		UT_WRITE_VENDOR_INTERFACE, 0x0a

/* DFU states */
#define DFUState_AppIdle	0
#define DFUState_AppDetach	1
#define DFUState_DFUIdle	2
#define DFUState_DnLoadSync	3
#define DFUState_DnLoadBusy	4
#define DFUState_DnLoadIdle	5
#define DFUState_ManifestSync	6
#define DFUState_Manifest	7
#define DFUState_ManifestWait	8
#define DFUState_UploadIdle	9
#define DFUState_DFUError	10

#define DFU_MaxBlockSize	1024

/* AT76c503 operating modes */
#define MODE_NONE			0x00
#define MODE_NETCARD			0x01
#define MODE_CONFIG			0x02
#define MODE_DFU			0x03
#define MODE_NOFLASHNETCARD		0x04

/* AT76c503 commands */
#define CMD_SET_MIB			0x01
#define CMD_START_SCAN			0x03
#define CMD_JOIN			0x04
#define CMD_START_IBSS			0x05
#define CMD_RADIO			0x06
#define CMD_RADIO_ON			0x06
#define CMD_RADIO_OFF			0x07
#define CMD_STARTUP			0x0b

/* AT76c503 status messages -  used in atu_wait_completion */
#define STATUS_IDLE			0x00
#define STATUS_COMPLETE			0x01
#define STATUS_UNKNOWN			0x02
#define STATUS_INVALID_PARAMETER	0x03
#define STATUS_FUNCTION_NOT_SUPPORTED	0x04
#define STATUS_TIME_OUT			0x07
#define STATUS_IN_PROGRESS		0x08
#define STATUS_HOST_FAILURE		0xff
#define STATUS_SCAN_FAILED		0xf0

/* AT76c503 command header */
struct atu_cmd {
	uByte			Cmd;
	uByte			Reserved;
	uWord			Size;
} __packed;

/* CMD_SET_MIB command (0x01) */
struct atu_cmd_set_mib {
	/* AT76c503 command header */
	uByte		AtCmd;
	uByte		AtReserved;
	uWord		AtSize;

	/* MIB header */
	uByte		MIBType;
	uByte		MIBSize;
	uByte		MIBIndex;
	uByte		MIBReserved;

	/* MIB data */
	uByte		data[72];
} __packed;

/* CMD_STARTUP command (0x0b) */
struct atu_cmd_card_config {
	uByte			Cmd;
	uByte			Reserved;
	uWord			Size;
		
	uByte			ExcludeUnencrypted;
	uByte			PromiscuousMode;
	uByte			ShortRetryLimit;
	uByte			EncryptionType;
	uWord			RTS_Threshold;
	uWord			FragThreshold;		/* 256 .. 2346 */
	uByte			BasicRateSet[4];
	uByte			AutoRateFallback;
	uByte			Channel;
	uByte			PrivacyInvoked;		/* wep */
	uByte			WEP_DefaultKeyID;	/* 0 .. 3 */
	uByte			SSID[MAX_SSID_LEN];
	uByte			WEP_DefaultKey[4][13];
	uByte			SSID_Len;
	uByte			ShortPreamble;
	uWord			BeaconPeriod;
} __packed;

/* CMD_SCAN command (0x03) */
struct atu_cmd_do_scan {
	uByte			Cmd;
	uByte			Reserved;
	uWord			Size;
	
	uByte			BSSID[ETHER_ADDR_LEN];
	uByte			SSID[MAX_SSID_LEN];
	uByte			ScanType;
	uByte			Channel;
	uWord			ProbeDelay;
	uWord			MinChannelTime;
	uWord			MaxChannelTime;
	uByte			SSID_Len;
	uByte			InternationalScan;  
} __packed;

#define ATU_SCAN_ACTIVE		0x00
#define ATU_SCAN_PASSIVE	0x01

/* CMD_JOIN command (0x04) */
struct atu_cmd_join {
	uByte			Cmd;
	uByte			Reserved;
	uWord			Size;
	
	uByte			bssid[ETHER_ADDR_LEN];
	uByte			essid[32];
	uByte			bss_type;
	uByte			channel;
	uWord			timeout;
	uByte			essid_size;
	uByte			reserved;
} __packed;

/* CMD_START_IBSS (0x05) */
struct atu_cmd_start_ibss {
	uByte		Cmd;
	uByte		Reserved;
	uWord		Size;
	
	uByte		BSSID[ETHER_ADDR_LEN];
	uByte		SSID[32];
	uByte		BSSType; 
	uByte		Channel; 
	uByte		SSIDSize;
	uByte		Res[3];  
} __packed;

/*
 * The At76c503 adapters come with different types of radios on them.
 * At this moment the driver supports adapters with RFMD and Intersil radios.
 */

/* The config structure of an RFMD radio */
struct atu_rfmd_conf {
	u_int8_t		CR20[14];
	u_int8_t		CR21[14];
	u_int8_t		BB_CR[14];
	u_int8_t		PidVid[4];
	u_int8_t		MACAddr[ETHER_ADDR_LEN];
	u_int8_t		RegulatoryDomain;
	u_int8_t		LowPowerValues[14];
	u_int8_t		NormalPowerValues[14];
	u_int8_t		Reserved[3];
	/* then we have 84 bytes, somehow Windows reads 95?? */
	u_int8_t		Rest[11];
} __packed;

/* The config structure of an Intersil radio */
struct atu_intersil_conf {
	u_int8_t		MACAddr[ETHER_ADDR_LEN];
	/* From the HFA3861B manual : */
	/* Manual TX power control (7bit : -64 to 63) */
	u_int8_t		CR31[14];
	/* TX power measurement */
	u_int8_t		CR58[14];
	u_int8_t		PidVid[4];
	u_int8_t		RegulatoryDomain;
	u_int8_t		Reserved[1];
} __packed;


/* Firmware information request */
struct atu_fw {
	u_int8_t		major;
	u_int8_t		minor;
	u_int8_t		patch;
	u_int8_t		build;
} __packed;
        
/*
 * The header the AT76c503 puts in front of RX packets (for both managment &
 * data)
 */
struct atu_rx_hdr {
	uWord			length;
	uByte			rx_rate;
	uByte			newbss;
	uByte			fragmentation;
	uByte			rssi;
	uByte			link_quality;
	uByte			noise_level;
	uDWord			rx_time;
} __packed;
#define ATU_RX_HDRLEN sizeof(struct atu_rx_hdr)

/*
 * The header we have to put in front of a TX packet before sending it to the
 * AT76c503
 */
struct atu_tx_hdr {
	uWord				length;
	uByte				tx_rate;
	uByte				padding;
	uByte				reserved[4];
} __packed;
#define ATU_TX_HDRLEN sizeof(struct atu_tx_hdr)

#define NR(x)		(void *)((long)x)

/*
 * The linux driver uses separate routines for every mib request they do
 * (eg. set_radio / set_preamble / set_frag / etc etc )
 * We just define a list of types, sizes and offsets and use those
 */

/*	Name				Type		Size	Index	*/
#define MIB_LOCAL			0x01
#define  MIB_LOCAL__BEACON_ENABLE	MIB_LOCAL,	1,	2
#define  MIB_LOCAL__AUTO_RATE_FALLBACK	MIB_LOCAL,	1,	3
#define  MIB_LOCAL__SSID_SIZE		MIB_LOCAL,	1,	5
#define  MIB_LOCAL__PREAMBLE		MIB_LOCAL,	1,	9
#define MIB_MAC_ADDR			0x02
#define  MIB_MAC_ADDR__ADDR		MIB_MAC_ADDR,	6,	0
#define MIB_MAC				0x03
#define  MIB_MAC__FRAG			MIB_MAC,	2,	8
#define  MIB_MAC__RTS			MIB_MAC,	2,	10
#define  MIB_MAC__DESIRED_SSID		MIB_MAC,	32,	28
#define MIB_MAC_MGMT			0x05
#define  MIB_MAC_MGMT__BEACON_PERIOD	MIB_MAC_MGMT,	2,	0
#define  MIB_MAC_MGMT__CURRENT_BSSID	MIB_MAC_MGMT,	6,	14
#define  MIB_MAC_MGMT__CURRENT_ESSID	MIB_MAC_MGMT,	32,	20
#define  MIB_MAC_MGMT__POWER_MODE	MIB_MAC_MGMT,	1,	53
#define  MIB_MAC_MGMT__IBSS_CHANGE	MIB_MAC_MGMT,	1,	54
#define MIB_MAC_WEP			0x06
#define  MIB_MAC_WEP__PRIVACY_INVOKED	MIB_MAC_WEP,	1,	0
#define  MIB_MAC_WEP__KEY_ID		MIB_MAC_WEP,	1,	1
#define  MIB_MAC_WEP__ICV_ERROR_COUNT	MIB_MAC_WEP,	4,	4
#define  MIB_MAC_WEP__EXCLUDED_COUNT	MIB_MAC_WEP,	4,	8
#define  MIB_MAC_WEP__KEYS(nr)		MIB_MAC_WEP,	13,	12+(nr)*13
#define  MIB_MAC_WEP__ENCR_LEVEL	MIB_MAC_WEP,	1,	64
#define MIB_PHY				0x07
#define  MIB_PHY__CHANNEL		MIB_PHY,	1,	20
#define  MIB_PHY__REG_DOMAIN		MIB_PHY,	1,	23
#define MIB_FW_VERSION			0x08
#define MIB_DOMAIN			0x09
#define  MIB_DOMAIN__POWER_LEVELS	MIB_DOMAIN,	14,	0
#define  MIB_DOMAIN__CHANNELS		MIB_DOMAIN,	14,	14

#define ATU_WEP_OFF			0
#define ATU_WEP_40BITS			1
#define ATU_WEP_104BITS			2

#define POWER_MODE_ACTIVE		1
#define POWER_MODE_SAVE			2
#define POWER_MODE_SMART		3

#define PREAMBLE_SHORT			1
#define PREAMBLE_LONG			0
@


1.32
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.31 2007/11/27 16:22:13 martynas Exp $ */
d110 1
a110 1
	usbd_xfer_handle	atu_xfer;
d182 2
a183 2
	usbd_device_handle	atu_udev;
	usbd_interface_handle	atu_iface;
d186 1
a186 1
	usbd_pipe_handle	atu_ep[ATU_ENDPT_MAX];
@


1.31
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.30 2007/06/09 11:06:53 mbalmer Exp $ */
a175 4
	char			sc_state;
#define ATU_S_DEAD		0
#define ATU_S_OK		1
#define ATU_S_UNCONFIG		2
@


1.30
log
@Remove the definition and use of UPACKED and replace it with our own __packed
(to which UPACKED was define'd before anway).  No binary change, just one layer
of confusion less in the sourcecode.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.29 2007/06/06 19:25:49 mk Exp $ */
d445 1
a445 1
 * The linux driver uses seperate routines for every mib request they do
@


1.29
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.28 2006/07/18 18:20:17 mk Exp $ */
d280 1
a280 1
} UPACKED;
d297 1
a297 1
} UPACKED;
d321 1
a321 1
} UPACKED;
d338 1
a338 1
} UPACKED;
d356 1
a356 1
} UPACKED;
d370 1
a370 1
} UPACKED;
d390 1
a390 1
} UPACKED;
d403 1
a403 1
} UPACKED;
d412 1
a412 1
} UPACKED;
d427 1
a427 1
} UPACKED;
d439 1
a439 1
} UPACKED;
@


1.28
log
@Tyops: simultaniously and carefull
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.27 2006/06/27 04:21:13 jsg Exp $ */
d171 1
a171 1
	USBBASEDEVICE           atu_dev;
@


1.27
log
@__attribute__((__packed__)) -> __packed
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.26 2006/06/27 03:58:07 jsg Exp $ */
d38 1
a38 1
/* the number of simultaniuously requested RX transfers */
d42 1
a42 1
 * the number of simultaniously started TX transfers
d61 1
a61 1
/* BE CAREFULL! should add ATU_TX_PADDING */
@


1.26
log
@Add support for max rssi/signal strength percentage on RFMD 2958
based adapters.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.25 2005/07/07 22:47:08 dlg Exp $ */
d140 1
a140 1
} __attribute__((__packed__));
d154 1
a154 1
} __attribute__((__packed__));
@


1.25
log
@extend what jcs did a bit further by removing atus storage for the ssid.
now there is no confusion since it is only provided by net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.24 2005/05/23 20:09:31 jsg Exp $ */
d127 1
a127 1
	 (1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL)		|	\
d138 2
a139 1
	u_int8_t				rr_antsignal;
@


1.24
log
@Initial radiotap support. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.23 2005/03/08 12:15:12 dlg Exp $ */
a200 2
	u_int8_t		atu_ssid[MAX_SSID_LEN];
	u_int8_t		atu_ssidlen;
@


1.23
log
@add support for the new firmwares and the devices that use them
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.22 2005/03/03 11:42:48 dlg Exp $ */
d119 36
d211 11
d223 3
@


1.22
log
@properly implement hardware wep support. mostly done by jesse off with
some minor cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.21 2004/12/23 13:19:38 dlg Exp $ */
d93 4
a96 1
	RadioIntersil
@


1.21
log
@turn padding of tx packets on since it appears it may be needed by certain
firmwares or revisions of the chip. also remove the option to turn it off.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.20 2004/12/20 12:11:57 deraadt Exp $ */
a171 7
	u_int8_t		atu_encrypt;
#define ATU_WEP_RX		0x01
#define ATU_WEP_TX		0x02
#define ATU_WEP_TXRX		(ATU_WEP_RX | ATU_WEP_TX)
	int			atu_wepkey;
	int			atu_wepkeylen;
	u_int8_t		atu_wepkeys[4][13];
@


1.20
log
@lots of minor tweaking and cleanup, removal of unused junk, etc; dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.19 2004/12/13 08:09:51 dlg Exp $ */
a54 14

/*
 * Whether or not we pad usb packets transfered to the adapter. looking at
 * drivers on other platforms there seems to be something magic about the
 * padding.
 * my measurements :
 * on	- 532.55 KB/sec
 * off	- 536.74 KB/sec
 * I don't see the reason why we should pad bytes here. The adapter seems
 * to be transmitting packets just fine without the padding. So the default is
 * to have no padding, but it's at least supplied as an option. This seems to
 * be necessary with newer firmware versions, but I haven't tested that yet.
 */
/* #define ATU_TX_PADDING */
@


1.19
log
@endian fixes, ie, atu will now work on big endian architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.18 2004/12/12 05:30:48 dlg Exp $ */
d21 1
a21 1
 * THIS SOFTWARE IS PROVIDED BY Daan Vreeken AND CONTRIBUTORS ``AS IS'' AND
a34 15
/* $ATUWI: $Id: if_atureg.h,v 1.18 2004/12/12 05:30:48 dlg Exp $ */

/************ 		driver options 		************/

/*
 * If you want to disable Intersil or RFMD support in the driver, uncomment
 * one of the following line. This will make the driver about 30 KB smaller
 * since the firmware-images will be left out. (Yes, leaving both out saves
 * 60KB, but that leaves you with a driver that doesn't support any devices :)
 */
/* #define ATU_NO_INTERSIL */
/* #define ATU_NO_RFMD */
/* #define ATU_NO_RFMD2958 */
/* #define ATU_NO_RFMD2958_SMC */

a37 19
/************ various performance optimizations ************/

/*
 * setting ATU_NO_OPTIMIZATIONS will set all further options to default
 * values...
 *
 * no optimizations	392.78 KB/sec
 * with optimizations	485.64 KB/sec
 * (+/- 23.6% increase)
 *
 * Disclaimer : Most speed tests were done by transferring a large file over
 * FTP with an MTU of 1500. The tests are done on slow (Pentium-133) machines
 * so small changes in driver-overhead would be easilly noticeable. These
 * numbers are different for every other PC, I have just put them here to show
 * in what order of magnitude the differences are.
 */
/* #define ATU_NO_OPTIMIZATIONS */


d57 1
a57 34
 * Normally, when a packet arrives at the driver (with a call to atu_start)
 * we start up a USB transfer and transfer the packet to the adapter. Then
 * atu_txeof gets called on interrupt and we hand over the mbuf to
 * usb_tx_done. usb_tx_done will queue the mbuf and schedules a net-isr.
 * After the interrupt the scheduler will call the net-isr. There the mbuf
 * is free'd and atu_start is called (if there are packets on the TX queue).
 * This means that on average 2 task-switches are performed for every single
 * packet we transmit. 
 * If we simply NOT call usb_tx_done when a single transfer is done, but wait
 * for the other transfers we started simultaneously to complete, we can save
 * the overhead of the extra task-switching.
 *
 * measurements :
 * off		465.55 KB/sec
 * on		487.57 KB/sec
 * (+/- 4.7% increase)
 */
#define ATU_LAZY_TX_NETISR

/*
 * Minimum number of simultaneous transfers before we start being lazy.
 * Setting this to 0 will make us so lazy we could keep mbuf's around forever
 * (which you do not want)
 */
#define ATU_LAZY_TX_MIN		1

/*
 * Maximum number of queued mbufs before we call usb_tx_done (should never
 * be higher than ATU_TX_LIST_CNT)
 */
#define ATU_LAZY_TX_MAX		8

/*
 * Whether or not we padd usb packets transfered to the adapter. looking at
d63 1
a63 1
 * I don't see the reason why we should padd bytes here. The adapter seems
a70 25
 * ATU_PROFILING isn't a real optimization. it adds s bunch of sysctl
 * variables that count the number of function calls and data transfers we
 * make. with some shell scripts around it you can easilly measure the
 * performance of the driver and see where bottlenecks might be.
 */
/* #define ATU_PROFILING */




/**** NO user configurable options beyond this point ****/


#ifdef ATU_NO_OPTIMIZATIONS
#undef ATU_LAZY_TX_NETISR
#undef ATU_TX_PADDING
#undef ATU_TX_LIST_CNT
#define ATU_TX_LIST_CNT		1
#undef ATU_RX_LIST_CNT
#define ATU_RX_LIST_CNT		1
#endif



/*
a88 1

a126 3
#ifdef ATU_LAZY_TX_NETISR
	u_int8_t		atu_not_freed;
#endif /* ATU_LAZY_TX_NETISR */
a140 1

a143 1

a145 1

a146 1

a169 5
#ifdef ATU_LAZY_TX_NETISR
	int			atu_lazy_tx_cnt;
	/* struct mbuf		*atu_lazy_tx_list[ATU_LAZY_TX_MAX]; */
#endif /* ATU_LAZY_TX_NETISR */

d189 1
a189 1
#define ATU_WEP_TXRX		(0x01 | 0x02)
a340 1

a382 1

@


1.18
log
@do a better reattachement of this device
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.17 2004/12/08 21:04:44 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.17 2004/12/08 21:04:44 dlg Exp $ */
a195 2


a209 1

a299 5





a305 1

a320 1

d322 5
a326 8
#define MODE_NONE		0x00
#define MODE_NETCARD		0x01
#define MODE_CONFIG		0x02
#define MODE_DFU		0x03
#define MODE_NOFLASHNETCARD	0x04



a348 2


d351 4
a354 4
	u_int8_t		Cmd;
	u_int8_t		Reserved;
	u_int16_t		Size;
};
d359 3
a361 3
	u_int8_t	AtCmd;
	u_int8_t	AtReserved;
	u_int16_t	AtSize;
d364 4
a367 4
	u_int8_t	MIBType;
	u_int8_t	MIBSize;
	u_int8_t	MIBIndex;
	u_int8_t	MIBReserved;
d370 2
a371 2
	u_int8_t	data[72];
};
d375 3
a377 3
	u_int8_t		Cmd;
	u_int8_t		Reserved;
	u_int16_t		Size;
d379 17
a395 17
	u_int8_t		ExcludeUnencrypted;
	u_int8_t		PromiscuousMode;
	u_int8_t		ShortRetryLimit;
	u_int8_t		EncryptionType;
	u_int16_t		RTS_Threshold;
	u_int16_t		FragThreshold;		/* 256 .. 2346 */
	u_int8_t		BasicRateSet[4];
	u_int8_t		AutoRateFallback;
	u_int8_t		Channel;
	u_int8_t		PrivacyInvoked;		/* wep */
	u_int8_t		WEP_DefaultKeyID;	/* 0 .. 3 */
	u_int8_t		SSID[MAX_SSID_LEN];
	u_int8_t		WEP_DefaultKey[4][13];
	u_int8_t		SSID_Len;
	u_int8_t		ShortPreamble;
	u_int16_t		BeaconPeriod;
};
d399 3
a401 3
	u_int8_t		Cmd;
	u_int8_t		Reserved;
	u_int16_t		Size;
d403 10
a412 10
	u_int8_t		BSSID[ETHER_ADDR_LEN];
	u_int8_t		SSID[MAX_SSID_LEN];
	u_int8_t		ScanType;
	u_int8_t		Channel;
	u_int16_t		ProbeDelay;
	u_int16_t		MinChannelTime;
	u_int16_t		MaxChannelTime;
	u_int8_t		SSID_Len;
	u_int8_t		InternationalScan;  
};
d414 1
a414 1
#define ATU_SCAN_ACTIVE	0x00
d419 3
a421 3
	u_int8_t		Cmd;
	u_int8_t		Reserved;
	u_int16_t		Size;
d423 8
a430 8
	u_int8_t		bssid[ETHER_ADDR_LEN];
	u_int8_t		essid[32];
	u_int8_t		bss_type;
	u_int8_t		channel;
	u_int16_t		timeout;
	u_int8_t		essid_size;
	u_int8_t		reserved;
};
d434 3
a436 3
	u_int8_t	Cmd;
	u_int8_t	Reserved;
	u_int16_t	Size;
d438 7
a444 7
	u_int8_t	BSSID[ETHER_ADDR_LEN];
	u_int8_t	SSID[32];
	u_int8_t	BSSType; 
	u_int8_t	Channel; 
	u_int8_t	SSIDSize;
	u_int8_t	Res[3];  
};
d465 1
a465 1
};
d478 1
a478 1
};
d487 1
a487 1
};
d495 9
a503 9
	u_int16_t		length;
	u_int8_t		rx_rate;
	u_int8_t		newbss;
	u_int8_t		fragmentation;
	u_int8_t		rssi;
	u_int8_t		link_quality;
	u_int8_t		noise_level;
	u_int32_t		rx_time;
};
d511 5
a515 5
	u_int16_t			length;
	u_int8_t			tx_rate;
	u_int8_t			padding;
	u_int8_t			reserved[4];
};
d560 2
a561 2
#define ATU_WEP_40BITS		1
#define ATU_WEP_104BITS		2
@


1.17
log
@remove the variables that used to make up the signal cache. nothing in atu
is using this now.

from daan vreeken
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.16 2004/12/08 21:01:33 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.16 2004/12/08 21:01:33 dlg Exp $ */
d253 8
a260 4
	int			sc_cmd;
#define ATU_C_NONE 0
#define ATU_C_SCAN 1
#define ATU_C_JOIN 2
a277 1
	char			atu_dying;
@


1.16
log
@remove some defines for timeouts that are no longer used thanks to net80211

from daan vreeken
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.15 2004/12/05 12:25:59 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.15 2004/12/05 12:25:59 dlg Exp $ */
a279 5
	
	/* used for debug : FLAG_SIGNAL */
	u_int8_t		atu_signalarr[ATU_AVG_TIME];
	u_int8_t		atu_signalptr;
	u_int16_t		atu_signaltotal;
@


1.15
log
@do a scan for networks when net80211 thinks we should rather than doing it
only when we bring the interface up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.14 2004/12/05 01:51:20 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.14 2004/12/05 01:51:20 dlg Exp $ */
d186 1
a186 2
#define ATU_TX_TIMEOUT	10000

a187 7

#define ATU_MGMT_INTERVAL	1000 * hz / 1000
#define ATU_SCAN_RETRIES	2
#define ATU_JOIN_RETRIES	1
#define ATU_AUTH_RETRIES	3
#define ATU_ASSOC_RETRIES	3
#define ATU_IBSS_RETRIES	0
@


1.14
log
@clean up some more of the old state machine
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.13 2004/12/05 00:16:14 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.13 2004/12/05 00:16:14 dlg Exp $ */
d260 6
@


1.13
log
@remove the dependance on code from wi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.12 2004/12/04 23:56:50 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.12 2004/12/04 23:56:50 dlg Exp $ */
a89 3
/* number of simultaniously MGMT TX transfers (always 1, don't change) */
#define ATU_MGMT_LIST_CNT	1

a169 1
#define ATU_MGMT_BUFSZ	(ATU_TX_HDRLEN + 300)
a239 1
	struct atu_chain	atu_mgmt_chain[ATU_MGMT_LIST_CNT];
d243 1
a243 2
	struct atu_list_head	atu_mgmt_free;
		
a252 28

enum atu_mgmt_state {
	STATE_NONE = 0,
	STATE_LISTENING,
	STATE_JOINING,
	
	STATE_AUTHENTICATING,           /* infra mode */
	STATE_ASSOCIATING,
	
	STATE_CREATING_IBSS,            /* adhoc mode */
	
	STATE_HAPPY_NETWORKING,
	STATE_GIVEN_UP
};

#ifdef ATU_DEBUG  
u_int8_t	*atu_mgmt_statename[] = {"NONE", "LISTENING", "JOINING",
    "AUTHENTICATING", "ASSOCIATING", "CREATING IBSS", "HAPPY NETWORKING :)",
    "GIVEN UP"};
#endif /* ATU_DEBUG */

struct atu_mgmt {
	enum atu_mgmt_state	state;
	int			retry;
};



a304 13

	struct proc		*atu_mgmt_thread;
	struct atu_mgmt		atu_mgmt_vars;
	u_int16_t		atu_mgmt_flags;
#define ATU_TASK_RUNNING	0x01
#define ATU_CHANGED_SETTINGS	0x02
#define ATU_SEARCHING		0x04
#define ATU_FOUND_BSSID		0x08
#define ATU_AUTH_OK		0x10
#define ATU_RE_AUTH		0x20
#define ATU_ASSOC_OK		0x40
#define ATU_RE_ASSOC		0x80
#define ATU_NETWORK_OK		0x100
@


1.12
log
@remove code that is now unused because of the move to net80211 and the
rx/tx cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.11 2004/12/04 23:36:15 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.11 2004/12/04 23:36:15 dlg Exp $ */
d169 1
a169 1
				 sizeof(struct wi_80211_hdr) + 2312 + 4)
d172 1
a172 1
				 sizeof(struct wi_80211_hdr) + 2312)
@


1.11
log
@clean up the tx path
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.10 2004/12/04 08:29:42 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.10 2004/12/04 08:29:42 dlg Exp $ */
d168 1
a168 1
#define ATU_RX_BUFSZ		(sizeof(struct at76c503_rx_buffer) +	\
d171 1
a171 1
#define ATU_TX_BUFSZ		(sizeof(struct at76c503_tx_buffer) +	\
d173 1
a173 1
#define ATU_MGMT_BUFSZ	(sizeof(struct at76c503_tx_buffer) + 300)
a571 18
struct at76c503_rx_buffer {
	u_int16_t		wlength;
	u_int8_t		rx_rate;
	u_int8_t		newbss;
	u_int8_t		fragmentation;
	u_int8_t		rssi;
	u_int8_t		link_quality;
	u_int8_t		noise_level;
	u_int32_t		rx_time;
};

/* The total packet the AT76c503 spits out looks like this */
struct atu_rxpkt {
	struct at76c503_rx_buffer	AtHeader;
	struct wi_80211_hdr		WiHeader;
	u_int8_t			Packet[2312 + 4];
};

a582 61

struct at76c503_tx_buffer {
	u_int16_t			wlength;
	u_int8_t			tx_rate;
	u_int8_t			padding;
	u_int8_t			reserved[4];
};

/* The total packet we send to the AT76c503 looks like this */
struct atu_txpkt {
	struct at76c503_tx_buffer	AtHeader;
	struct wi_80211_hdr		WiHeader;
	/* TODO - change this to a more correct value */
	u_int8_t			Packet[2312];
};

/* Managment packet */
struct atu_mgmt_packet {
	struct at76c503_tx_buffer	athdr;
	struct wi_mgmt_hdr		mgmt_hdr;
	
	u_int8_t			payload[0];
};

/* Authentication packet */
struct atu_auth_packet {
	struct at76c503_tx_buffer	athdr;
	struct wi_mgmt_hdr		mgmt_hdr;
	struct wi_mgmt_auth_hdr		auth_hdr;
	
	u_int8_t			challenge[0];
};

/* Association packet */
struct atu_assoc_packet {
	struct at76c503_tx_buffer	athdr;
	struct wi_mgmt_hdr		mgmt_hdr;
	u_int16_t			capability;
	u_int16_t			listen_interval;
	
	u_int8_t			data[0];
};


struct wi_80211_beacon {
	u_int8_t		timestamp[8];
	u_int16_t		interval;
	u_int16_t		flags;
	u_int8_t		data[1500];
};

struct tlv {
	u_int8_t		type;
	u_int8_t		length;
	u_int8_t		value[255];
};

#define TYPE_MASK		0x000c



@


1.10
log
@clean up the rx path
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.9 2004/12/04 08:02:02 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.9 2004/12/04 08:02:02 dlg Exp $ */
d594 8
@


1.9
log
@disable the state machine in atu in favour of the net80211 framework. lots of
cleanup to follow.

partly from daan vreeken, partly from me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.8 2004/11/23 02:40:34 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.8 2004/11/23 02:40:34 dlg Exp $ */
d560 12
@


1.8
log
@use ieee80211com to store the mac
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.7 2004/11/21 04:55:36 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.7 2004/11/21 04:55:36 dlg Exp $ */
d291 3
@


1.7
log
@introduce the net80211 framework to atu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.6 2004/11/17 14:00:10 deraadt Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.6 2004/11/17 14:00:10 deraadt Exp $ */
a309 1
	u_int8_t		atu_mac_addr[ETHER_ADDR_LEN];
@


1.6
log
@stuff after #endif
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.5 2004/11/16 08:57:29 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.5 2004/11/16 08:57:29 dlg Exp $ */
d290 2
a291 1
	struct arpcom		arpcom;
@


1.5
log
@get rid of the ATU_NO_COPY_TX knob. we always want it on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.4 2004/11/15 12:50:08 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.4 2004/11/15 12:50:08 dlg Exp $ */
d278 1
a278 1
#endif ATU_DEBUG
@


1.4
log
@remove some debug cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.3 2004/11/12 12:12:29 deraadt Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.3 2004/11/12 12:12:29 deraadt Exp $ */
a93 12
 * save a memcpy on TX by directly constructing packets into a self-allocated
 * DMA buffer. (normally usbd allocates them and memcpy's data in on transfer)
 *
 * measurements :
 * off		507.50 KB/sec
 * on		530.14 KB/sec
 * (+/- 4.5% increase)
 */
#define ATU_NO_COPY_TX


/*
a156 1
#undef ATU_NO_COPY_TX
@


1.3
log
@support SIOCG80211BSSID SIOCS80211CHANNEL SIOCG80211POWER; from daan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.2 2004/11/09 14:42:26 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.2 2004/11/09 14:42:26 dlg Exp $ */
a49 20

/* debug flags used in the driver - don't change */
#define FLAG_COMMANDS           0x00001 /* Atmel USB commands */  
#define FLAG_BEACONS            0x00002 /* reception of beacons */
#define FLAG_BEACONSFULL        0x00004 /*   verbose */
#define FLAG_SIGNAL             0x00008 /* signal strength of packets */
#define FLAG_TX                 0x00010 /* transmittion of packets */ 
#define FLAG_RX                 0x00020 /* reception of packets */
#define FLAG_RXFULL             0x00040 /*   verbose */
#define FLAG_MGMT               0x00080 /* managment packets */
#define FLAG_MGMTFULL           0x00100 /*   verbose */
#define FLAG_STATE              0x00200 /* scan/join/auth/assoc state */
#define FLAG_INIT               0x00400 /* device initialisation / tear down */
#define FLAG_FW                 0x00800 /* firmware loader */
#define FLAG_FWFULL             0x01000 /*   verbose */
#define FLAG_IOCTL              0x02000 /* ioctls */
#define FLAG_BPF                0x04000 /* bpf */
#define FLAG_ALL		0x07fff /* all of the above */


d287 1
a287 1
  
d291 1
a291 1

@


1.2
log
@remove useless bpf code. removes dependancy on code from an(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atureg.h,v 1.1 2004/11/08 22:09:11 dlg Exp $ */
d35 1
a35 1
/* $ATUWI: $Id: if_atureg.h,v 1.1 2004/11/08 22:09:11 dlg Exp $ */
d239 1
d355 1
d673 1
a673 1
#define NR(x)		(void *)(x)
@


1.1
log
@Atmel AT76c503 / AT76c503a / AT76c505 / AT76c505a  USB WLAN driver

originally the atuwi driver from Daan Vreeken, but with enough changes by
deraadt@@ and me to warrant a name change.

there are still plenty of issues to resolve, but at least i can get packets
over it now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d35 1
a35 1
/* $ATUWI: $Id: if_atuwireg.h,v 1.12 2004/10/05 21:32:50 daan Exp $ */
a339 2
	caddr_t			atu_rawbpf;
	caddr_t			atu_airobpf;
@

