head	1.74;
access;
symbols
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.73.0.2
	OPENBSD_5_9_BASE:1.73
	OPENBSD_5_8:1.70.0.6
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.52.0.4
	OPENBSD_5_5_BASE:1.52
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.42.0.8
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.6
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.42.0.2
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.34.0.4
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.2
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	SMP:1.6.0.4
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	UBC_SYNC_B:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5
	UBC:1.3.0.2;
locks; strict;
comment	@ * @;


1.74
date	2016.06.13.10.15.03;	author mpi;	state Exp;
branches;
next	1.73;
commitid	hv5QP0cstvtSKoHi;

1.73
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.72;
commitid	KAeCDAijcgEnOtfF;

1.72
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.71;
commitid	kI4H556ZKYkRQGw5;

1.71
date	2015.12.08.09.49.22;	author mpi;	state Exp;
branches;
next	1.70;
commitid	P7LboKnTYLTVuJRa;

1.70
date	2015.02.28.08.42.41;	author mpi;	state Exp;
branches;
next	1.69;
commitid	ct5HHam4QV0yOZ5v;

1.69
date	2015.01.22.10.27.47;	author mpi;	state Exp;
branches;
next	1.68;
commitid	lKfM5ejoPYfCitV4;

1.68
date	2015.01.09.12.09.51;	author mpi;	state Exp;
branches;
next	1.67;
commitid	yBHogXUBAwMdIWqb;

1.67
date	2015.01.09.12.07.50;	author mpi;	state Exp;
branches;
next	1.66;
commitid	SbnTte7ZSgPxxJ3B;

1.66
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.65;
commitid	20ZyHa9gTJxHxhwD;

1.65
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.64;
commitid	L2P5oN9ppxqXZsYS;

1.64
date	2014.12.08.22.00.11;	author mpi;	state Exp;
branches;
next	1.63;
commitid	S4AL2dWdKDpjf5ru;

1.63
date	2014.08.10.12.48.43;	author mpi;	state Exp;
branches;
next	1.62;
commitid	oIOKbbZQEr5KMUDs;

1.62
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.61;
commitid	OBNa5kfxQ2UXoiIw;

1.61
date	2014.07.10.08.56.40;	author mpi;	state Exp;
branches;
next	1.60;
commitid	W9MXABn1cDjAOzYs;

1.60
date	2014.04.29.12.47.33;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2014.04.24.09.40.28;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.23.12.20.14;	author andre;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.19.08.59.37;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.16.10.54.40;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.15.10.13.24;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2014.03.15.09.50.26;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2014.02.25.15.49.10;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.19.14.04.07;	author pirofti;	state Exp;
branches;
next	1.50;

1.50
date	2013.11.11.09.16.03;	author pirofti;	state Exp;
branches;
next	1.49;

1.49
date	2013.11.01.17.42.59;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.01.12.05.26;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.25.03.09.59;	author jeremy;	state Exp;
branches;
next	1.46;

1.46
date	2013.09.20.15.34.50;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.09.19.09.54.42;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.05.07.08.44.38;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.31.16.38.42;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.02.23.17.34;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.23.19.26.54;	author yuo;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.23.07.37.44;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.02.21.43.41;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.14.02.40.23;	author todd;	state Exp;
branches;
next	1.31;

1.31
date	2007.11.12.04.18.09;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.09.01.00.35;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.26.15.01.01;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.22.21.53.16;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.18.02.54.11;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.17.16.27.58;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.14.12.00.04;	author matthieu;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.06.03.36.32;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.05.16.52.04;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.05.19.22.24.08;	author tedu;	state Exp;
branches;
next	;

1.6.4.1
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Do not execute the callback if the device is beeing detached.

Should prevent a race triggering a use-after-free reported by
martijn@@ on bugs@@
@
text
@/*	$OpenBSD: uhidev.c,v 1.73 2016/01/09 04:14:42 jcs Exp $	*/
/*	$NetBSD: uhidev.c,v 1.14 2003/03/11 16:44:00 augustss Exp $	*/

/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/signalvar.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdevs.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>
#include <dev/usb/usb_quirks.h>

#include <dev/usb/uhidev.h>

#ifndef SMALL_KERNEL
/* Replacement report descriptors for devices shipped with broken ones */
#include <dev/usb/uhid_rdesc.h>
int uhidev_use_rdesc(struct uhidev_softc *, usb_interface_descriptor_t *,
		int, int, void **, int *);
#define UISUBCLASS_XBOX360_CONTROLLER 0x5d
#define UIPROTO_XBOX360_GAMEPAD 0x01
#endif /* !SMALL_KERNEL */

#define DEVNAME(sc)		((sc)->sc_dev.dv_xname)

#ifdef UHIDEV_DEBUG
#define DPRINTF(x)	do { if (uhidevdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhidevdebug>(n)) printf x; } while (0)
int	uhidevdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct uhidev_async_info {
	void (*callback)(void *priv, int id, void *data, int len);
	void *priv;
	void *data;
	int id;
};

void uhidev_intr(struct usbd_xfer *, void *, usbd_status);

int uhidev_maxrepid(void *buf, int len);
int uhidevprint(void *aux, const char *pnp);
int uhidevsubmatch(struct device *parent, void *cf, void *aux);

int uhidev_match(struct device *, void *, void *);
void uhidev_attach(struct device *, struct device *, void *);
int uhidev_detach(struct device *, int);
int uhidev_activate(struct device *, int);

void uhidev_get_report_async_cb(struct usbd_xfer *, void *, usbd_status);

struct cfdriver uhidev_cd = {
	NULL, "uhidev", DV_DULL
};

const struct cfattach uhidev_ca = {
	sizeof(struct uhidev_softc), uhidev_match, uhidev_attach,
	uhidev_detach, uhidev_activate,
};

int
uhidev_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return (UMATCH_NONE);
#ifndef SMALL_KERNEL
	if (id->bInterfaceClass == UICLASS_VENDOR &&
	    id->bInterfaceSubClass == UISUBCLASS_XBOX360_CONTROLLER &&
	    id->bInterfaceProtocol == UIPROTO_XBOX360_GAMEPAD)
		return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
#endif /* !SMALL_KERNEL */
	if (id->bInterfaceClass != UICLASS_HID)
		return (UMATCH_NONE);
	if (usbd_get_quirks(uaa->device)->uq_flags & UQ_BAD_HID)
		return (UMATCH_NONE);

	return (UMATCH_IFACECLASS_GENERIC);
}

void
uhidev_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhidev_softc *sc = (struct uhidev_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct uhidev_attach_arg uha;
	int size, nrepid, repid, repsz;
	int i, repsizes[256];
	void *desc = NULL;
	struct device *dev;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_ifaceno = uaa->ifaceno;
	id = usbd_get_interface_descriptor(sc->sc_iface);

	usbd_set_idle(sc->sc_udev, sc->sc_ifaceno, 0, 0);

	sc->sc_iep_addr = sc->sc_oep_addr = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: could not read endpoint descriptor\n",
			    DEVNAME(sc));
			return;
		}

		DPRINTFN(10,("uhidev_attach: bLength=%d bDescriptorType=%d "
		    "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		    " bInterval=%d\n",
		    ed->bLength, ed->bDescriptorType,
		    ed->bEndpointAddress & UE_ADDR,
		    UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		    ed->bmAttributes & UE_XFERTYPE,
		    UGETW(ed->wMaxPacketSize), ed->bInterval));

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
			sc->sc_iep_addr = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
			sc->sc_oep_addr = ed->bEndpointAddress;
		} else {
			printf("%s: unexpected endpoint\n", DEVNAME(sc));
			return;
		}
	}

	/*
	 * Check that we found an input interrupt endpoint.
	 * The output interrupt endpoint is optional
	 */
	if (sc->sc_iep_addr == -1) {
		printf("%s: no input interrupt endpoint\n", DEVNAME(sc));
		return;
	}

#ifndef SMALL_KERNEL
	if (uhidev_use_rdesc(sc, id, uaa->vendor, uaa->product, &desc, &size))
		return;
#endif /* !SMALL_KERNEL */

	if (desc == NULL) {
		struct usb_hid_descriptor *hid;

		hid = usbd_get_hid_descriptor(sc->sc_udev, id);
		if (hid == NULL) {
			printf("%s: no HID descriptor\n", DEVNAME(sc));
			return;
		}
		size = UGETW(hid->descrs[0].wDescriptorLength);
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL) {
			printf("%s: no memory\n", DEVNAME(sc));
			return;
		}
		if (usbd_get_report_descriptor(sc->sc_udev, sc->sc_ifaceno,
		    desc, size)) {
			printf("%s: no report descriptor\n", DEVNAME(sc));
			free(desc, M_USBDEV, 0);
			return;
		}
	}

	sc->sc_repdesc = desc;
	sc->sc_repdesc_size = size;

	nrepid = uhidev_maxrepid(desc, size);
	if (nrepid < 0)
		return;
	printf("%s: iclass %d/%d", DEVNAME(sc), id->bInterfaceClass,
	    id->bInterfaceSubClass);
	if (nrepid > 0)
		printf(", %d report id%s", nrepid, nrepid > 1 ? "s" : "");
	printf("\n");
	nrepid++;
	sc->sc_subdevs = mallocarray(nrepid, sizeof(struct uhidev *),
	    M_USBDEV, M_NOWAIT | M_ZERO);
	if (sc->sc_subdevs == NULL) {
		printf("%s: no memory\n", DEVNAME(sc));
		return;
	}
	sc->sc_nrepid = nrepid;
	sc->sc_isize = 0;

	for (repid = 0; repid < nrepid; repid++) {
		repsz = hid_report_size(desc, size, hid_input, repid);
		DPRINTF(("uhidev_match: repid=%d, repsz=%d\n", repid, repsz));
		repsizes[repid] = repsz;
		if (repsz > sc->sc_isize)
			sc->sc_isize = repsz;
	}
	sc->sc_isize += (nrepid != 1);	/* one byte for the report ID */
	DPRINTF(("uhidev_attach: isize=%d\n", sc->sc_isize));

	uha.uaa = uaa;
	uha.parent = sc;
	uha.reportid = UHIDEV_CLAIM_ALLREPORTID;

	/* Look for a driver claiming all report IDs first. */
	dev = config_found_sm(self, &uha, NULL, uhidevsubmatch);
	if (dev != NULL) {
		for (repid = 0; repid < nrepid; repid++)
			sc->sc_subdevs[repid] = (struct uhidev *)dev;
		return;
	}

	for (repid = 0; repid < nrepid; repid++) {
		DPRINTF(("%s: try repid=%d\n", __func__, repid));
		if (hid_report_size(desc, size, hid_input, repid) == 0 &&
		    hid_report_size(desc, size, hid_output, repid) == 0 &&
		    hid_report_size(desc, size, hid_feature, repid) == 0)
			continue;

		uha.reportid = repid;
		dev = config_found_sm(self, &uha, uhidevprint, uhidevsubmatch);
		sc->sc_subdevs[repid] = (struct uhidev *)dev;
	}
}

#ifndef SMALL_KERNEL
int
uhidev_use_rdesc(struct uhidev_softc *sc, usb_interface_descriptor_t *id,
		int vendor, int product, void **descp, int *sizep)
{
	static uByte reportbuf[] = {2, 2};
	const void *descptr = NULL;
	void *desc;
	int size;

	if (vendor == USB_VENDOR_WACOM) {
		/* The report descriptor for the Wacom Graphire is broken. */
		switch (product) {
		case USB_PRODUCT_WACOM_GRAPHIRE:
			size = sizeof(uhid_graphire_report_descr);
			descptr = uhid_graphire_report_descr;
			break;
		case USB_PRODUCT_WACOM_GRAPHIRE3_4X5:
		case USB_PRODUCT_WACOM_GRAPHIRE4_4X5:
			uhidev_set_report(sc, UHID_FEATURE_REPORT,
			    2, &reportbuf, sizeof(reportbuf));
			size = sizeof(uhid_graphire3_4x5_report_descr);
			descptr = uhid_graphire3_4x5_report_descr;
			break;
		default:
			break;
		}
	} else if ((id->bInterfaceClass == UICLASS_VENDOR &&
		   id->bInterfaceSubClass == UISUBCLASS_XBOX360_CONTROLLER &&
		   id->bInterfaceProtocol == UIPROTO_XBOX360_GAMEPAD)) {
		/* The Xbox 360 gamepad has no report descriptor. */
		size = sizeof(uhid_xb360gp_report_descr);
		descptr = uhid_xb360gp_report_descr;
	}

	if (descptr) {
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL)
			return (ENOMEM);

		memcpy(desc, descptr, size);

		*descp = desc;
		*sizep = size;
	}

	return (0);
}
#endif /* !SMALL_KERNEL */

int
uhidev_maxrepid(void *buf, int len)
{
	struct hid_data *d;
	struct hid_item h;
	int maxid;

	maxid = -1;
	h.report_ID = 0;
	for (d = hid_start_parse(buf, len, hid_none); hid_get_item(d, &h); )
		if (h.report_ID > maxid)
			maxid = h.report_ID;
	hid_end_parse(d);
	return (maxid);
}

int
uhidevprint(void *aux, const char *pnp)
{
	struct uhidev_attach_arg *uha = aux;

	if (pnp)
		printf("uhid at %s", pnp);
	if (uha->reportid != 0 && uha->reportid != UHIDEV_CLAIM_ALLREPORTID)
		printf(" reportid %d", uha->reportid);
	return (UNCONF);
}

int uhidevsubmatch(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;
        struct cfdata *cf = match;

	if (cf->uhidevcf_reportid != UHIDEV_UNK_REPORTID &&
	    cf->uhidevcf_reportid != uha->reportid)
		return (0);
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

int
uhidev_activate(struct device *self, int act)
{
	struct uhidev_softc *sc = (struct uhidev_softc *)self;
	int i, rv = 0, r;

	switch (act) {
	case DVACT_DEACTIVATE:
		for (i = 0; i < sc->sc_nrepid; i++)
			if (sc->sc_subdevs[i] != NULL) {
				r = config_deactivate(
				    &sc->sc_subdevs[i]->sc_dev);
				if (r && r != EOPNOTSUPP)
					rv = r;
			}
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (rv);
}

int
uhidev_detach(struct device *self, int flags)
{
	struct uhidev_softc *sc = (struct uhidev_softc *)self;
	int i, rv = 0;

	DPRINTF(("uhidev_detach: sc=%p flags=%d\n", sc, flags));

	if (sc->sc_opipe != NULL) {
		usbd_abort_pipe(sc->sc_opipe);
		usbd_close_pipe(sc->sc_opipe);
		sc->sc_opipe = NULL;
	}

	if (sc->sc_ipipe != NULL) {
		usbd_abort_pipe(sc->sc_ipipe);
		usbd_close_pipe(sc->sc_ipipe);
		sc->sc_ipipe = NULL;
	}

	if (sc->sc_repdesc != NULL)
		free(sc->sc_repdesc, M_USBDEV, 0);

	/*
	 * XXX Check if we have only one children claiming all the Report
	 * IDs, this is a hack since we need a dev -> Report ID mapping
	 * for uhidev_intr().
	 */
	if (sc->sc_nrepid > 1 && sc->sc_subdevs[0] != NULL &&
	    sc->sc_subdevs[0] == sc->sc_subdevs[1])
		return (config_detach(&sc->sc_subdevs[0]->sc_dev, flags));

	for (i = 0; i < sc->sc_nrepid; i++) {
		if (sc->sc_subdevs[i] != NULL) {
			rv |= config_detach(&sc->sc_subdevs[i]->sc_dev, flags);
			sc->sc_subdevs[i] = NULL;
		}
	}

	return (rv);
}

void
uhidev_intr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct uhidev_softc *sc = addr;
	struct uhidev *scd;
	u_char *p;
	u_int rep;
	u_int32_t cc;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);

#ifdef UHIDEV_DEBUG
	if (uhidevdebug > 5) {
		u_int32_t i;

		DPRINTF(("uhidev_intr: status=%d cc=%d\n", status, cc));
		DPRINTF(("uhidev_intr: data ="));
		for (i = 0; i < cc; i++)
			DPRINTF((" %02x", sc->sc_ibuf[i]));
		DPRINTF(("\n"));
	}
#endif

	if (status == USBD_CANCELLED || status == USBD_IOERROR)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("%s: interrupt status=%d\n", DEVNAME(sc), status));
		usbd_clear_endpoint_stall_async(sc->sc_ipipe);
		return;
	}

	p = sc->sc_ibuf;
	if (sc->sc_nrepid != 1)
		rep = *p++, cc--;
	else
		rep = 0;
	if (rep >= sc->sc_nrepid) {
		printf("uhidev_intr: bad repid %d\n", rep);
		return;
	}
	scd = sc->sc_subdevs[rep];
	DPRINTFN(5,("uhidev_intr: rep=%d, scd=%p state=0x%x\n",
		    rep, scd, scd ? scd->sc_state : 0));
	if (scd == NULL || !(scd->sc_state & UHIDEV_OPEN))
		return;

	scd->sc_intr(scd, p, cc);
}

void
uhidev_get_report_desc(struct uhidev_softc *sc, void **desc, int *size)
{
	*desc = sc->sc_repdesc;
	*size = sc->sc_repdesc_size;
}

int
uhidev_open(struct uhidev *scd)
{
	struct uhidev_softc *sc = scd->sc_parent;
	usbd_status err;
	int error;

	DPRINTF(("uhidev_open: open pipe, state=%d refcnt=%d\n",
		 scd->sc_state, sc->sc_refcnt));

	if (scd->sc_state & UHIDEV_OPEN)
		return (EBUSY);
	scd->sc_state |= UHIDEV_OPEN;
	if (sc->sc_refcnt++)
		return (0);

	if (sc->sc_isize == 0)
		return (0);

	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);

	/* Set up input interrupt pipe. */
	DPRINTF(("uhidev_open: isize=%d, ep=0x%02x\n", sc->sc_isize,
	    sc->sc_iep_addr));

	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_iep_addr,
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_ibuf,
		  sc->sc_isize, uhidev_intr, USBD_DEFAULT_INTERVAL);
	if (err != USBD_NORMAL_COMPLETION) {
		DPRINTF(("uhidopen: usbd_open_pipe_intr failed, "
		    "error=%d\n", err));
		error = EIO;
		goto out1;
	}

	DPRINTF(("uhidev_open: sc->sc_ipipe=%p\n", sc->sc_ipipe));

	sc->sc_ixfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->sc_ixfer == NULL) {
		DPRINTF(("uhidev_open: couldn't allocate an xfer\n"));
		error = ENOMEM;
		goto out1; // xxxx
	}

	/*
	 * Set up output interrupt pipe if an output interrupt endpoint
	 * exists.
	 */
	if (sc->sc_oep_addr != -1) {
		DPRINTF(("uhidev_open: oep=0x%02x\n", sc->sc_oep_addr));

		err = usbd_open_pipe(sc->sc_iface, sc->sc_oep_addr,
		    0, &sc->sc_opipe);

		if (err != USBD_NORMAL_COMPLETION) {
			DPRINTF(("uhidev_open: usbd_open_pipe failed, "
			    "error=%d\n", err));
			error = EIO;
			goto out2;
		}
		DPRINTF(("uhidev_open: sc->sc_opipe=%p\n", sc->sc_opipe));

		sc->sc_oxfer = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_oxfer == NULL) {
			DPRINTF(("uhidev_open: couldn't allocate an xfer\n"));
			error = ENOMEM;
			goto out3;
		}

		sc->sc_owxfer = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_owxfer == NULL) {
			DPRINTF(("uhidev_open: couldn't allocate owxfer\n"));
			error = ENOMEM;
			goto out3;
		}
	}

	return (0);

out3:
	/* Abort output pipe */
	usbd_close_pipe(sc->sc_opipe);
out2:
	/* Abort input pipe */
	usbd_close_pipe(sc->sc_ipipe);
out1:
	DPRINTF(("uhidev_open: failed in someway"));
	free(sc->sc_ibuf, M_USBDEV, 0);
	scd->sc_state &= ~UHIDEV_OPEN;
	sc->sc_refcnt = 0;
	sc->sc_ipipe = NULL;
	sc->sc_opipe = NULL;
	if (sc->sc_oxfer != NULL) {
		usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
	}
	if (sc->sc_owxfer != NULL) {
		usbd_free_xfer(sc->sc_owxfer);
		sc->sc_owxfer = NULL;
	}
	if (sc->sc_ixfer != NULL) {
		usbd_free_xfer(sc->sc_ixfer);
		sc->sc_ixfer = NULL;
	}
	return (error);
}

void
uhidev_close(struct uhidev *scd)
{
	struct uhidev_softc *sc = scd->sc_parent;

	if (!(scd->sc_state & UHIDEV_OPEN))
		return;
	scd->sc_state &= ~UHIDEV_OPEN;
	if (--sc->sc_refcnt)
		return;
	DPRINTF(("uhidev_close: close pipe\n"));

	if (sc->sc_oxfer != NULL) {
		usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
	}

	if (sc->sc_owxfer != NULL) {
		usbd_free_xfer(sc->sc_owxfer);
		sc->sc_owxfer = NULL;
	}

	if (sc->sc_ixfer != NULL) {
		usbd_free_xfer(sc->sc_ixfer);
		sc->sc_ixfer = NULL;
	}

	/* Disable interrupts. */
	if (sc->sc_opipe != NULL) {
		usbd_abort_pipe(sc->sc_opipe);
		usbd_close_pipe(sc->sc_opipe);
		sc->sc_opipe = NULL;
	}

	if (sc->sc_ipipe != NULL) {
		usbd_abort_pipe(sc->sc_ipipe);
		usbd_close_pipe(sc->sc_ipipe);
		sc->sc_ipipe = NULL;
	}

	if (sc->sc_ibuf != NULL) {
		free(sc->sc_ibuf, M_USBDEV, 0);
		sc->sc_ibuf = NULL;
	}
}

int
uhidev_set_report(struct uhidev_softc *sc, int type, int id, void *data,
    int len)
{
	usb_device_request_t req;
	char *buf = data;
	int actlen = len;

	/* Prepend the reportID. */
	if (id > 0) {
		len++;
		buf = malloc(len, M_TEMP, M_WAITOK);
		buf[0] = id;
		memcpy(buf + 1, data, len - 1);
	}

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, len);

	if (usbd_do_request(sc->sc_udev, &req, buf))
		actlen = -1;

	if (id > 0)
		free(buf, M_TEMP, len);

	return (actlen);
}

int
uhidev_set_report_async(struct uhidev_softc *sc, int type, int id, void *data,
    int len)
{
	struct usbd_xfer *xfer;
	usb_device_request_t req;
	int actlen = len;
	char *buf;

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return (-1);

	if (id > 0)
		len++;

	buf = usbd_alloc_buffer(xfer, len);
	if (buf == NULL) {
		usbd_free_xfer(xfer);
		return (-1);
	}

	/* Prepend the reportID. */
	if (id > 0) {
		buf[0] = id;
		memcpy(buf + 1, data, len - 1);
	} else {
		memcpy(buf, data, len);
	}

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UR_SET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, len);

	if (usbd_request_async(xfer, &req, NULL, NULL))
		actlen = -1;

	return (actlen);
}

int
uhidev_get_report(struct uhidev_softc *sc, int type, int id, void *data,
    int len)
{
	usb_device_request_t req;
	char *buf = data;
	usbd_status err;
	int actlen;

	if (id > 0) {
		len++;
		buf = malloc(len, M_TEMP, M_WAITOK|M_ZERO);
	}

	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, len);

	err = usbd_do_request_flags(sc->sc_udev, &req, buf, 0, &actlen,
	    USBD_DEFAULT_TIMEOUT);
	if (err != USBD_NORMAL_COMPLETION && err != USBD_SHORT_XFER)
		actlen = -1;

	/* Skip the reportID. */
	if (id > 0) {
		memcpy(data, buf + 1, len - 1);
		free(buf, M_TEMP, len);
	}

	return (actlen);
}

void
uhidev_get_report_async_cb(struct usbd_xfer *xfer, void *priv, usbd_status err)
{
	struct uhidev_async_info *info = priv;
	char *buf;
	int len = -1;

	if (!usbd_is_dying(xfer->pipe->device)) {
		if (err == USBD_NORMAL_COMPLETION || err == USBD_SHORT_XFER) {
			len = xfer->actlen;
			buf = KERNADDR(&xfer->dmabuf, 0);
			if (info->id > 0) {
				len--;
				memcpy(info->data, buf + 1, len);
			} else {
				memcpy(info->data, buf, len);
			}
		}
		info->callback(info->priv, info->id, info->data, len);
	}
	free(info, M_TEMP, sizeof(*info));
	usbd_free_xfer(xfer);
}

int
uhidev_get_report_async(struct uhidev_softc *sc, int type, int id, void *data,
    int len, void *priv, void (*callback)(void *, int, void *, int))
{
	struct usbd_xfer *xfer;
	usb_device_request_t req;
	struct uhidev_async_info *info;
	int actlen = len;
	char *buf;

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return (-1);

	if (id > 0)
		len++;

	buf = usbd_alloc_buffer(xfer, len);
	if (buf == NULL) {
		usbd_free_xfer(xfer);
		return (-1);
	}

	info = malloc(sizeof(*info), M_TEMP, M_NOWAIT);
	if (info == NULL) {
		usbd_free_xfer(xfer);
		return (-1);
	}

	info->callback = callback;
	info->priv = priv;
	info->data = data;
	info->id = id;

	req.bmRequestType = UT_READ_CLASS_INTERFACE;
	req.bRequest = UR_GET_REPORT;
	USETW2(req.wValue, type, id);
	USETW(req.wIndex, sc->sc_ifaceno);
	USETW(req.wLength, len);

	if (usbd_request_async(xfer, &req, info, uhidev_get_report_async_cb)) {
		free(info, M_TEMP, sizeof(*info));
		actlen = -1;
	}

	return (actlen);
}

usbd_status
uhidev_write(struct uhidev_softc *sc, void *data, int len)
{
	usbd_status error;

	DPRINTF(("uhidev_write: data=%p, len=%d\n", data, len));

	if (sc->sc_opipe == NULL)
		return USBD_INVAL;

#ifdef UHIDEV_DEBUG
	if (uhidevdebug > 50) {

		u_int32_t i;
		u_int8_t *d = data;

		DPRINTF(("uhidev_write: data ="));
		for (i = 0; i < len; i++)
			DPRINTF((" %02x", d[i]));
		DPRINTF(("\n"));
	}
#endif
	usbd_setup_xfer(sc->sc_owxfer, sc->sc_opipe, 0, data, len,
	    USBD_SYNCHRONOUS | USBD_CATCH, 0, NULL);
	error = usbd_transfer(sc->sc_owxfer);
	if (error)
		usbd_clear_endpoint_stall(sc->sc_opipe);

	return (error);
}

int
uhidev_ioctl(struct uhidev *sc, u_long cmd, caddr_t addr, int flag,
    struct proc *p)
{
	struct usb_ctl_report_desc *rd;
	struct usb_ctl_report *re;
	int size;
	void *desc;

	switch (cmd) {
	case USB_GET_REPORT_DESC:
		uhidev_get_report_desc(sc->sc_parent, &desc, &size);
		rd = (struct usb_ctl_report_desc *)addr;
		size = min(size, sizeof rd->ucrd_data);
		rd->ucrd_size = size;
		memcpy(rd->ucrd_data, desc, size);
		break;
	case USB_GET_REPORT:
		re = (struct usb_ctl_report *)addr;
		switch (re->ucr_report) {
		case UHID_INPUT_REPORT:
			size = sc->sc_isize;
			break;
		case UHID_OUTPUT_REPORT:
			size = sc->sc_osize;
			break;
		case UHID_FEATURE_REPORT:
			size = sc->sc_fsize;
			break;
		default:
			return EINVAL;
		}
		if (uhidev_get_report(sc->sc_parent, re->ucr_report,
		    sc->sc_report_id, re->ucr_data, size) != size)
			return EIO;
		break;
	case USB_SET_REPORT:
		re = (struct usb_ctl_report *)addr;
		switch (re->ucr_report) {
		case UHID_INPUT_REPORT:
			size = sc->sc_isize;
			break;
		case UHID_OUTPUT_REPORT:
			size = sc->sc_osize;
			break;
		case UHID_FEATURE_REPORT:
			size = sc->sc_fsize;
			break;
		default:
			return EINVAL;
		}
		if (uhidev_set_report(sc->sc_parent, re->ucr_report,
		    sc->sc_report_id, re->ucr_data, size) != size)
			return EIO;
		break;
	case USB_GET_REPORT_ID:
		*(int *)addr = sc->sc_report_id;
		break;
	default:
		return -1;
	}
	return 0;
}
@


1.73
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.72 2016/01/08 15:54:14 jcs Exp $	*/
d99 1
a99 2
void uhidev_get_report_async_cb(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
d756 10
a765 8
	if (err == USBD_NORMAL_COMPLETION || err == USBD_SHORT_XFER) {
		len = xfer->actlen;
		buf = KERNADDR(&xfer->dmabuf, 0);
		if (info->id > 0) {
			len--;
			memcpy(info->data, buf + 1, len);
		} else {
			memcpy(info->data, buf, len);
d767 1
a768 1
	info->callback(info->priv, info->id, info->data, len);
@


1.72
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.71 2015/12/08 09:49:22 mpi Exp $	*/
a59 2

#include <dev/hid/hid.h>
@


1.71
log
@Match 3rd party Xbox 360 controllers, from Christian Heckendorf.

Tested by jeremy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.70 2015/02/28 08:42:41 mpi Exp $	*/
a56 1
#include <dev/usb/hid.h>
d60 2
@


1.70
log
@Fix uhidev_get_report_async() from David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.69 2015/01/22 10:27:47 mpi Exp $	*/
d65 4
a68 1
int uhidev_use_rdesc(struct uhidev_softc *, int, int, void **, int *);
d124 4
a127 4
	if (uaa->vendor == USB_VENDOR_MICROSOFT &&
	    uaa->product == USB_PRODUCT_MICROSOFT_XBOX360_CONTROLLER &&
	    id->bInterfaceNumber == 0)
		return (UMATCH_VENDOR_PRODUCT);
d197 1
a197 1
	if (uhidev_use_rdesc(sc, uaa->vendor, uaa->product, &desc, &size))
d281 2
a282 2
uhidev_use_rdesc(struct uhidev_softc *sc, int vendor, int product,
    void **descp, int *sizep)
d306 3
a308 2
	} else if (vendor == USB_VENDOR_MICROSOFT &&
	    product == USB_PRODUCT_MICROSOFT_XBOX360_CONTROLLER) {
@


1.69
log
@Reduce the number of intermediate buffers by pre-allocating DMA buffers
in the report functions instead of letting the stack do it magically for
us.

Reviewed and tested by David Higgs, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.68 2015/01/09 12:09:51 mpi Exp $	*/
d56 1
d751 1
d756 1
d759 1
a759 1
			memcpy(info->data, xfer->buffer + 1, len);
d761 1
a761 1
			memcpy(info->data, xfer->buffer, len);
d809 1
a809 1
	if (usbd_request_async(xfer, &req, priv, uhidev_get_report_async_cb)) {
@


1.68
log
@Correctly report memory allocation failure in uhidev_set_report_async().
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.66 2014/12/13 21:05:33 doug Exp $	*/
d674 1
a675 1
	char *buf = data;
d677 14
a693 4
		len++;
		buf = malloc(len, M_TEMP, M_NOWAIT);
		if (buf == NULL)
			return (-1);
d696 2
d706 1
a706 1
	if (usbd_do_request_async(sc->sc_udev, &req, buf, NULL, NULL))
a708 8
	/*
	 * Since report requests are write-only it is safe to free
	 * the buffer right after submitting the transfer because
	 * it won't be used afterward.
	 */
	if (id > 0)
		free(buf, M_TEMP, len);

d757 2
a761 2
	if (info->id > 0)
		free(xfer->buffer, M_TEMP, xfer->length);
d770 1
a772 1
	char *buf = data;
d774 14
d790 2
a791 1
	if (info == NULL)
d793 1
a799 9
	if (id > 0) {
		len++;
		buf = malloc(len, M_TEMP, M_NOWAIT|M_ZERO);
		if (buf == NULL) {
			free(info, M_TEMP, sizeof(*info));
			return (-1);
		}
	}

d806 1
a806 2
	if (usbd_do_request_async(sc->sc_udev, &req, buf, priv,
	    uhidev_get_report_async_cb)) {
a807 2
		if (id > 0)
			free(buf, M_TEMP, len);
d810 1
@


1.67
log
@Add an asynchronous version of uhidev_get_report(), from David Higgs
with some tweaks.

Nothing use it for the moment, but upcoming upd(4) improvements need
it.
@
text
@d683 1
a683 1
			return (USBD_NOMEM);
@


1.66
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.65 2014/12/11 18:39:27 mpi Exp $	*/
d47 2
d55 1
d78 7
d96 3
d694 1
a694 1
	if (usbd_do_request_async(sc->sc_udev, &req, buf))
d739 63
@


1.65
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.64 2014/12/08 22:00:11 mpi Exp $	*/
d218 1
a218 1
	sc->sc_subdevs = malloc(nrepid * sizeof(struct uhidev *),
@


1.64
log
@Deprecate usb_*_report().  USB HID devices are always attached below
an uhidev(4) on OpenBSD and there is not point in rerolling your own
reportID handling.  Simply use uhidev_*_report().

This is a first step towards better error handling required to deal
with broken upd(4) firmwares.

Tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.63 2014/08/10 12:48:43 mpi Exp $	*/
a272 5
		struct uhidev wacom;

		/* XXX until we pass the parent directly. */
		wacom.sc_parent = sc;

d281 1
a281 1
			uhidev_set_report(&wacom, UHID_FEATURE_REPORT,
d626 3
a628 2
usbd_status
uhidev_set_report(struct uhidev *scd, int type, int id, void *data, int len)
a629 1
	struct uhidev_softc *sc = scd->sc_parent;
a630 1
	usbd_status err;
d632 1
d648 2
a649 1
	err = usbd_do_request(sc->sc_udev, &req, buf);
d654 1
a654 1
	return (err);
d657 2
a658 2
usbd_status
uhidev_set_report_async(struct uhidev *scd, int type, int id, void *data,
a660 1
	struct uhidev_softc *sc = scd->sc_parent;
a661 1
	usbd_status err;
d663 1
d681 2
a682 1
	err = usbd_do_request_async(sc->sc_udev, &req, buf);
d692 1
a692 1
	return (err);
d695 3
a697 2
usbd_status
uhidev_get_report(struct uhidev *scd, int type, int id, void *data, int len)
a698 1
	struct uhidev_softc *sc = scd->sc_parent;
d700 8
d715 12
a726 1
	return (usbd_do_request(sc->sc_udev, &req, data));
d766 1
a766 2
	int size, extra;
	usbd_status err;
d792 2
a793 6
		extra = sc->sc_report_id != 0;
		err = uhidev_get_report(sc, re->ucr_report, sc->sc_report_id,
		    re->ucr_data, size + extra);
		if (extra)
			memcpy(re->ucr_data, re->ucr_data + 1, size);
		if (err)
d811 2
a812 3
		err = uhidev_set_report(sc, re->ucr_report,
		    sc->sc_report_id, re->ucr_data, size);
		if (err)
@


1.63
log
@sizeof() a pointer of the right struct to appease clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.62 2014/07/12 18:48:52 tedu Exp $	*/
d267 1
a267 1
	static uByte reportbuf[] = {2, 2, 2};
d273 4
d286 2
a287 3
			usbd_set_report(sc->sc_udev, sc->sc_ifaceno,
			    UHID_FEATURE_REPORT, 2, &reportbuf,
			    sizeof(reportbuf));
d635 3
a637 2
	char *buf;
	usbd_status retstat;
d639 7
a645 3
	if (id == 0)
		return usbd_set_report(sc->sc_udev, sc->sc_ifaceno, type,
				       id, data, len);
d647 5
a651 3
	buf = malloc(len + 1, M_TEMP, M_WAITOK);
	buf[0] = id;
	memcpy(buf+1, data, len);
d653 1
a653 2
	retstat = usbd_set_report(sc->sc_udev, sc->sc_ifaceno, type,
				  id, buf, len + 1);
d655 2
a656 1
	free(buf, M_TEMP, 0);
d658 1
a658 1
	return retstat;
d666 3
a668 2
	char *buf;
	usbd_status retstat;
d670 15
a684 9
	if (id == 0)
		return usbd_set_report_async(sc->sc_udev, sc->sc_ifaceno, type,
					     id, data, len);

	buf = malloc(len + 1, M_TEMP, M_NOWAIT);
	if (buf == NULL)
		return (USBD_NOMEM);
	buf[0] = id;
	memcpy(buf+1, data, len);
d686 1
a686 2
	retstat = usbd_set_report_async(sc->sc_udev, sc->sc_ifaceno, type,
					id, buf, len + 1);
d693 2
a694 1
	free(buf, M_TEMP, 0);
d696 1
a696 1
	return retstat;
d703 7
d711 1
a711 2
	return usbd_get_report(sc->sc_udev, sc->sc_ifaceno, type,
			       id, data, len);
@


1.62
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.61 2014/07/10 08:56:40 mpi Exp $	*/
d218 1
a218 1
	sc->sc_subdevs = malloc(nrepid * sizeof(struct device *),
@


1.61
log
@Print an understandable error message when we fail to read the report
descriptor.

Pointed out by benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.60 2014/04/29 12:47:33 mpi Exp $	*/
d201 1
a201 1
			free(desc, M_USBDEV);
d394 1
a394 1
		free(sc->sc_repdesc, M_USBDEV);
d562 1
a562 1
	free(sc->sc_ibuf, M_USBDEV);
d623 1
a623 1
		free(sc->sc_ibuf, M_USBDEV);
d646 1
a646 1
	free(buf, M_TEMP);
d677 1
a677 1
	free(buf, M_TEMP);
@


1.60
log
@Plug an xfer leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.59 2014/04/24 09:40:28 mpi Exp $	*/
d189 1
a189 1
			printf("%s: no report descriptor\n", DEVNAME(sc));
d200 1
a200 1
			printf("%s: XXX\n", DEVNAME(sc));
@


1.59
log
@Change the usbd_*_report() family of functions to take a usbd_device
and a infaceno argument instead of an iface pointer.  While here,
remove some unused functions and inlined usbd_read_report_desc since
it is used only once.

This is part of plumbing required to convert the various USB HID devices
to handle multiples report IDs.

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.58 2014/04/15 09:14:27 mpi Exp $	*/
d575 4
d594 1
a594 1
	if (sc->sc_oxfer != NULL)
d596 2
d599 1
a599 1
	if (sc->sc_owxfer != NULL)
d601 7
@


1.58
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.57 2014/03/23 12:20:14 andre Exp $	*/
d135 1
d138 1
a138 6
	usbd_set_idle(sc->sc_iface, 0, 0);
#if 0
	if ((usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_NO_SET_PROTO) == 0 &&
	    id->bInterfaceSubClass != UISUBCLASS_BOOT)
		usbd_set_protocol(sc->sc_iface, 1);
#endif
d185 4
a188 2
		if (usbd_read_report_desc(sc->sc_iface, &desc, &size,
		    M_USBDEV)) {
d192 12
d282 3
a284 2
			usbd_set_report(sc->sc_iface, UHID_FEATURE_REPORT, 2,
			    &reportbuf, sizeof(reportbuf));
d618 1
d623 1
a623 1
		return usbd_set_report(scd->sc_parent->sc_iface, type,
d630 1
a630 1
	retstat = usbd_set_report(scd->sc_parent->sc_iface, type,
d642 1
d647 1
a647 1
		return usbd_set_report_async(scd->sc_parent->sc_iface, type,
d656 1
a656 1
	retstat = usbd_set_report_async(scd->sc_parent->sc_iface, type,
d672 4
a675 1
	return usbd_get_report(scd->sc_parent->sc_iface, type, id, data, len);
@


1.57
log
@Fix uhidev_detach() when detaching a device which did not claimed for all
report IDs, on those cases some positions on sc_subdevs[] can be null.
Initial analysis by guenther@@.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.56 2014/03/19 08:59:37 mpi Exp $	*/
d605 1
a605 1
uhidev_set_report(struct uhidev *scd, int type, void *data, int len)
d610 1
a610 1
	if (scd->sc_report_id == 0)
d612 1
a612 1
				       scd->sc_report_id, data, len);
d615 1
a615 1
	buf[0] = scd->sc_report_id;
d619 1
a619 1
				  scd->sc_report_id, buf, len + 1);
d627 2
a628 1
uhidev_set_report_async(struct uhidev *scd, int type, void *data, int len)
d633 1
a633 1
	if (scd->sc_report_id == 0)
d635 1
a635 1
					     scd->sc_report_id, data, len);
d640 1
a640 1
	buf[0] = scd->sc_report_id;
d644 1
a644 1
					scd->sc_report_id, buf, len + 1);
d657 1
a657 1
uhidev_get_report(struct uhidev *scd, int type, void *data, int len)
d659 1
a659 2
	return usbd_get_report(scd->sc_parent->sc_iface, type,
			       scd->sc_report_id, data, len);
d727 2
a728 2
		err = uhidev_get_report(sc, re->ucr_report, re->ucr_data,
		    size + extra);
d749 2
a750 1
		err = uhidev_set_report(sc, re->ucr_report, re->ucr_data, size);
@


1.56
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.55 2014/03/16 10:54:40 mpi Exp $	*/
d390 2
a391 1
	if (sc->sc_nrepid > 0 && sc->sc_subdevs[0] == sc->sc_subdevs[1])
@


1.55
log
@Move the logic to deal with devices with broken descriptors into its
own function and don't leave the driver half-configured if a children
doesn't set the interrupt function.

tested by jeremy@@, ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.54 2014/03/15 10:13:24 mpi Exp $	*/
d131 1
d221 2
a222 4
		if (repsz > 0) {
			if (repsz > sc->sc_isize)
				sc->sc_isize = repsz;
		}
d224 1
a224 1
	sc->sc_isize += nrepid != 1;	/* space for report ID */
d229 10
a239 2
		struct device *dev;

d325 1
a325 1
	if (uha->reportid != 0)
d366 1
a366 1
	int i, rv;
d385 8
a392 1
	rv = 0;
@


1.54
log
@Starting the spring cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.53 2014/03/15 09:50:26 mpi Exp $	*/
d61 1
a127 1
	struct uhidev *dev;
d129 2
a130 5
	int repsizes[256];
	int i;
	void *desc;
	const void *descptr;
	usbd_status err;
a181 2
	/* XXX need to extend this */
	descptr = NULL;
d183 2
a184 26
	if (uaa->vendor == USB_VENDOR_WACOM) {
		static uByte reportbuf[] = {2, 2, 2};

		/* The report descriptor for the Wacom Graphire is broken. */
		switch (uaa->product) {
		case USB_PRODUCT_WACOM_GRAPHIRE:
			size = sizeof uhid_graphire_report_descr;
			descptr = uhid_graphire_report_descr;
			break;
		case USB_PRODUCT_WACOM_GRAPHIRE3_4X5:
		case USB_PRODUCT_WACOM_GRAPHIRE4_4X5:
			usbd_set_report(sc->sc_iface, UHID_FEATURE_REPORT, 2,
			    &reportbuf, sizeof reportbuf);
			size = sizeof uhid_graphire3_4x5_report_descr;
			descptr = uhid_graphire3_4x5_report_descr;
			break;
		default:
			/* Keep descriptor */
			break;
		}
	} else if (uaa->vendor == USB_VENDOR_MICROSOFT &&
	    uaa->product == USB_PRODUCT_MICROSOFT_XBOX360_CONTROLLER) {
		/* The Xbox 360 gamepad has no report descriptor. */
		size = sizeof uhid_xb360gp_report_descr;
		descptr = uhid_xb360gp_report_descr;
	}
d187 5
a191 7
	if (descptr) {
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL)
			err = USBD_NOMEM;
		else {
			err = USBD_NORMAL_COMPLETION;
			memcpy(desc, descptr, size);
a192 8
	} else {
		desc = NULL;
		err = usbd_read_report_desc(sc->sc_iface, &desc, &size,
		    M_USBDEV);
	}
	if (err) {
		printf("%s: no report descriptor\n", DEVNAME(sc));
		return;
d231 3
a233 1
		DPRINTF(("uhidev_match: try repid=%d\n", repid));
d236 36
a271 18
		    hid_report_size(desc, size, hid_feature, repid) == 0) {
			;	/* already NULL in sc->sc_subdevs[repid] */
		} else {
			uha.reportid = repid;
			dev = (struct uhidev *)config_found_sm(self, &uha,
			                           uhidevprint, uhidevsubmatch);
			sc->sc_subdevs[repid] = dev;
			if (dev != NULL) {
#ifdef DIAGNOSTIC
				DPRINTF(("uhidev_match: repid=%d dev=%p\n",
					 repid, dev));
				if (dev->sc_intr == NULL) {
					DPRINTF(("%s: sc_intr == NULL\n",
					       DEVNAME(sc)));
					return;
				}
#endif
			}
d273 16
d290 2
d293 1
@


1.53
log
@Remove debug leftover.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.52 2014/02/25 15:49:10 mpi Exp $	*/
d63 2
a123 1
	struct usbd_interface *iface = uaa->iface;
d136 2
a137 2
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
d139 1
a139 1
	(void)usbd_set_idle(iface, 0, 0);
d141 1
a141 3

	qflags = usbd_get_quirks(sc->sc_udev)->uq_flags;
	if ((qflags & UQ_NO_SET_PROTO) == 0 &&
d143 1
a143 1
		(void)usbd_set_protocol(iface, 1);
d148 1
a148 1
		ed = usbd_interface2endpoint_descriptor(iface, i);
d151 1
a151 1
			    sc->sc_dev.dv_xname);
d171 1
a171 1
			printf("%s: unexpected endpoint\n", sc->sc_dev.dv_xname);
d181 1
a181 1
		printf("%s: no input interrupt endpoint\n", sc->sc_dev.dv_xname);
d199 1
a199 1
			usbd_set_report(uaa->iface, UHID_FEATURE_REPORT, 2,
d226 2
a227 1
		err = usbd_read_report_desc(uaa->iface, &desc, &size, M_USBDEV);
d230 1
a230 1
		printf("%s: no report descriptor\n", sc->sc_dev.dv_xname);
a236 1
	uha.uaa = uaa;
d240 2
a241 2
	printf("%s: iclass %d/%d", sc->sc_dev.dv_xname,
	    id->bInterfaceClass, id->bInterfaceSubClass);
d243 1
a243 2
		printf(", %d report id%s", nrepid,
		    nrepid > 1 ? "s" : "");
d249 1
a249 1
		printf("%s: no memory\n", sc->sc_dev.dv_xname);
d267 1
d286 1
a286 1
					       sc->sc_dev.dv_xname));
d419 1
a419 2
		DPRINTF(("%s: interrupt status=%d\n", sc->sc_dev.dv_xname,
			 status));
@


1.52
log
@Abort and close all the interrupt pipes when detaching HID devices since
drivers attaching to uhidev(4) do not always do it.  Seems to fix one of
the transfer aborting races triggering a lot of "ehci_idone: ..." vomit
upon resume.

Reported by and fix tested by Ville Valkonen, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.51 2013/11/19 14:04:07 pirofti Exp $	*/
a281 1
				dev->sc_in_rep_size = repsizes[repid];
d440 1
a440 5
#ifdef UHIDEV_DEBUG
	if (scd->sc_in_rep_size != cc)
		printf("%s: bad input length %d != %d\n",sc->sc_dev.dv_xname,
		       scd->sc_in_rep_size, cc);
#endif
@


1.51
log
@Kill matchlvl usage throughout the usb stack.

Allows us to move forward on cleaning.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.50 2013/11/11 09:16:03 pirofti Exp $	*/
d365 7
a371 1
	if (sc->sc_ipipe != NULL)
d373 3
@


1.50
log
@Clean-up the activate routines from the uoak*(4) drivers.

Leave the deactivate bits to the parent.
Simplify by making a single dying check in uhidev(4) interrupt routine
instead of having each child doing it.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.49 2013/11/01 17:42:59 mpi Exp $	*/
a112 2
	if (uaa->matchlvl)
		return (uaa->matchlvl);
a332 4
	if (cf->uhidevcf_reportid == uha->reportid)
		uha->matchlvl = UMATCH_VENDOR_PRODUCT;
	else
		uha->matchlvl = 0;
@


1.49
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.48 2013/11/01 12:05:26 mpi Exp $	*/
d357 1
d396 3
@


1.48
log
@Do not abuse the stack of the current process to prepend a report ID
to the report request, use malloc(9) with the appropriate size like
it is done in the synchronous version.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.47 2013/10/25 03:09:59 jeremy Exp $	*/
d78 12
a89 15
int uhidev_match(struct device *, void *, void *); 
void uhidev_attach(struct device *, struct device *, void *); 
int uhidev_detach(struct device *, int); 
int uhidev_activate(struct device *, int); 

struct cfdriver uhidev_cd = { 
	NULL, "uhidev", DV_DULL 
}; 

const struct cfattach uhidev_ca = { 
	sizeof(struct uhidev_softc), 
	uhidev_match, 
	uhidev_attach, 
	uhidev_detach, 
	uhidev_activate, 
d180 2
a181 2
	 * Check that we found an input interrupt endpoint. The output interrupt
	 * endpoint is optional
d473 1
a473 1
		
d525 1
a525 1
	
@


1.47
log
@Add support for Microsoft XBox 360 controller as a uhid. It doesn't use
the standard interface class and doesn't have a report descriptor, so
use a manually created one.

The controller shows up as multiple devices with different interface
numbers, so only match the first one as a uhid.  The controller shows up
as both a uhid and a ugen.

Rename ugraphire_rdesc.h to uhid_rdesc.h and add the manually created
Xbox 360 report descriptor to the file.

Add ifndef SMALL_KERNEL around the related blocks for the XBox 360
controller and Wacom Graphire, so this should actually shrink the
ramdisks.

Manual report descriptor taken from a 2005 FreeBSD commit.  Much help
from mpi@@ for getting this suitable for commit to OpenBSD.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.46 2013/09/20 15:34:50 mpi Exp $	*/
d614 1
a614 1
void
d617 22
a638 15
	/* XXX */
	char buf[100];
	if (scd->sc_report_id) {
		buf[0] = scd->sc_report_id;
		if ((uint)len > sizeof(buf) - 1) {
#ifdef DIAGNOSTIC
			printf("%s: report length too large (%d)\n",
			    scd->sc_dev.dv_xname, len);
#endif
			return;
		}
		memcpy(buf+1, data, len);
		len++;
		data = buf;
	}
d640 1
a640 2
	usbd_set_report_async(scd->sc_parent->sc_iface, type,
			      scd->sc_report_id, data, len);
@


1.46
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.45 2013/09/19 09:54:42 mpi Exp $	*/
d58 4
a61 2
/* Report descriptor for broken Wacom Graphire */
#include <dev/usb/ugraphire_rdesc.h>
d104 9
a112 1
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
d193 1
d214 5
d220 1
@


1.45
log
@Do no try to clear the endpoint, as it if has stalled, if the
USB transfer reported an I/O error.

This is more likely to have no effect apart generating more
errors because when this happens, the device is generally
already physically detached but the *detach() task has not
run yet.  So simply return and wait for the device to be
removed like ucom(4) does.

Partially fix an issue reported by RD Thrush rt at thrush.com.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.44 2013/05/07 08:44:38 mpi Exp $	*/
d630 1
d649 7
a655 2
	return usbd_intr_transfer(sc->sc_owxfer, sc->sc_opipe, 0,
	    USBD_NO_TIMEOUT, data, &len, "uhidevwi");
@


1.44
log
@When deactivating child devices do not panic if their driver does
not implement an *activate() function.  This could receive more love
but is good enough for the moment to start cleaning useless *activate()
functions.

While here remove unused sc_dying argument.

Tested by and ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.43 2013/04/15 09:23:02 mglocker Exp $	*/
d396 1
a396 1
	if (status == USBD_CANCELLED)
@


1.43
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.42 2011/07/03 15:47:17 matthew Exp $	*/
a147 1
			sc->sc_dying = 1;
a167 1
			sc->sc_dying = 1;
a177 1
		sc->sc_dying = 1;
a218 1
		sc->sc_dying = 1;
d340 1
a340 1
				if (r)
a342 1
		sc->sc_dying = 1;
@


1.42
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.41 2011/01/25 20:03:36 jakemsr Exp $	*/
d70 1
a70 1
void uhidev_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d117 1
a117 1
	usbd_interface_handle iface = uaa->iface;
d379 1
a379 1
uhidev_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
@


1.41
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.40 2010/09/24 08:33:59 yuo Exp $	*/
a338 2
	case DVACT_ACTIVATE:
		break;
@


1.40
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.39 2010/08/31 16:38:42 deraadt Exp $	*/
a248 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a375 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.39
log
@In xxactivate() DVACT_DEACTIVATE, when calling a series of config_deactivate()
for sub-devices, return the last error return value instead of |'ing the
failures together and creating some value that is non-0 (bravo!) but
potentially loses the specific error value...
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.38 2010/08/02 23:17:34 miod Exp $	*/
a365 1
	sc->sc_dying = 1;
@


1.38
log
@Handle USB_GET_REPORT, USB_GET_REPORT_DESC, USB_GET_REPORT_ID and
USB_SET_REPORT ioctls in ukbd and ums.
This allows usbhidctl to be used on these devices e.g. to dump the report
descriptor of troublesome models.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.37 2009/11/23 19:26:54 yuo Exp $	*/
d339 1
a339 1
	int i, rv = 0;
a343 1

d346 6
a351 3
			if (sc->sc_subdevs[i] != NULL)
				rv |= config_deactivate(
					&sc->sc_subdevs[i]->sc_dev);
@


1.37
log
@suppress warning massage for polling only HID devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.36 2009/10/13 19:33:19 pirofti Exp $	*/
d662 69
@


1.36
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.35 2009/07/23 07:37:44 jsg Exp $	*/
d282 2
a283 2
					printf("%s: sc_intr == NULL\n",
					       sc->sc_dev.dv_xname);
@


1.35
log
@Use the correct buffer for non-zero report IDs in uhidev_set_report().
From Dave Huang via NetBSD rev 1.18.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.34 2009/06/02 21:43:41 miod Exp $	*/
d79 1
a79 1
int uhidev_activate(struct device *, enum devact); 
d336 1
a336 1
uhidev_activate(struct device *self, enum devact act)
@


1.34
log
@Avoid a buf oflow in uhidev_set_report_async() if we have to prepend the
report id and the data to report is too long (this should probably
use dynamic allocation for large reports).
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.33 2008/06/26 05:42:18 ray Exp $	*/
d602 1
a602 1
				  scd->sc_report_id, data, len + 1);
@


1.33
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.32 2008/06/14 02:40:23 todd Exp $	*/
d616 7
@


1.32
log
@remove #ifdef __macppc__ due to a misunderstanding:
 - the wskbd/wsmouse is not phantom, but actually is pre-paired keyboard/mice
   talking wskbd/wsmouse to the os
this permits the bluetooth device to attach as wskbd/wsmouse using bluetooth
 keyboards for ddb> and in general if you have paired them in an os that
 supports flipping the funny bluetooth device into full bluetooth mode
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.31 2007/11/12 04:18:09 deraadt Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.31
log
@fewer lines of dmesg output spew (matters more on newer sony laptops with... 15 lines of usb devices..
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.30 2007/10/11 18:33:15 deraadt Exp $	*/
a114 12

#ifdef __macppc__
	/*
	 * Some Apple laptops have USB phantom devices which match
	 * the ADB devices.  We want to ignore them to avoid
	 * confusing users, as the real hardware underneath is adb
	 * and has already attached.
	 */
	if (uaa->vendor == USB_VENDOR_APPLE &&
	    uaa->product == USB_PRODUCT_APPLE_ADB)
		return (UMATCH_NONE);
#endif
@


1.30
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.29 2007/09/11 13:39:34 gilles Exp $	*/
a151 3
	printf("%s: iclass %d/%d\n", sc->sc_dev.dv_xname,
	    id->bInterfaceClass, id->bInterfaceSubClass);

d252 2
d255 3
a257 1
		printf("%s: %d report ids\n", sc->sc_dev.dv_xname, nrepid);
@


1.29
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.28 2007/09/09 01:00:35 fgsch Exp $	*/
a146 1
	char *devinfop;
d152 2
a153 4
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s, iclass %d/%d\n", sc->sc_dev.dv_xname,
	       devinfop, id->bInterfaceClass, id->bInterfaceSubClass);
	usbd_devinfo_free(devinfop);
@


1.28
log
@more M_ZERO conversions; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.27 2007/06/14 10:11:16 mbalmer Exp $	*/
d262 1
a262 1
	    M_USBDEV, M_NOWAIT|M_ZERO);
@


1.27
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.26 2007/06/12 16:26:36 mbalmer Exp $	*/
d262 1
a262 1
	    M_USBDEV, M_NOWAIT);
a266 1
	bzero(sc->sc_subdevs, nrepid * sizeof(struct device *));
@


1.26
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.25 2007/06/10 14:49:01 mbalmer Exp $	*/
d83 16
a98 1
USB_DECLARE_DRIVER(uhidev);
@


1.25
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.24 2007/06/10 10:53:48 mbalmer Exp $	*/
d246 1
a246 1
	sc->sc_subdevs = malloc(nrepid * sizeof(device_ptr_t),
d252 1
a252 1
	bzero(sc->sc_subdevs, nrepid * sizeof(device_ptr_t));
d343 1
a343 1
uhidev_activate(device_ptr_t self, enum devact act)
@


1.24
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.23 2007/06/05 08:43:55 mbalmer Exp $	*/
d139 1
a139 1
	printf("\n%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
d157 1
a157 1
			    USBDEVNAME(sc->sc_dev));
d178 1
a178 1
			printf("%s: unexpected endpoint\n", USBDEVNAME(sc->sc_dev));
d189 1
a189 1
		printf("%s: no input interrupt endpoint\n", USBDEVNAME(sc->sc_dev));
d231 1
a231 1
		printf("%s: no report descriptor\n", USBDEVNAME(sc->sc_dev));
d244 1
a244 1
		printf("%s: %d report ids\n", USBDEVNAME(sc->sc_dev), nrepid);
d249 1
a249 1
		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
d290 1
a290 1
					       USBDEVNAME(sc->sc_dev));
d419 1
a419 1
		DPRINTF(("%s: interrupt status=%d\n", USBDEVNAME(sc->sc_dev),
d441 1
a441 1
		printf("%s: bad input length %d != %d\n",USBDEVNAME(sc->sc_dev),
@


1.23
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.22 2007/06/04 10:34:04 mbalmer Exp $	*/
d257 1
a257 1
			   USBDEV(sc->sc_dev));
d387 1
a387 1
			   USBDEV(sc->sc_dev));
@


1.22
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.21 2007/05/27 04:00:25 jsg Exp $	*/
d77 1
a77 1
Static void uhidev_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d79 3
a81 3
Static int uhidev_maxrepid(void *buf, int len);
Static int uhidevprint(void *aux, const char *pnp);
Static int uhidevsubmatch(struct device *parent, void *cf, void *aux);
d327 1
a327 1
Static int uhidevsubmatch(struct device *parent, void *match, void *aux)
@


1.21
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.20 2007/05/21 05:40:28 jsg Exp $	*/
a80 3
#if defined(__NetBSD__)
Static int uhidevsubmatch(struct device *parent, struct cfdata *cf, void *aux);
#else
a81 1
#endif
a326 3
#if defined(__NetBSD__)
Static int uhidevsubmatch(struct device *parent, struct cfdata *cf, void *aux)
#else
a327 1
#endif
a329 1
#if defined(__OpenBSD__)
a330 1
#endif
@


1.20
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.19 2006/11/26 15:01:01 deraadt Exp $	*/
d89 2
a90 1
USB_MATCH(uhidev)
d92 1
a92 1
	USB_MATCH_START(uhidev, uaa);
d120 2
a121 1
USB_ATTACH(uhidev)
d123 2
a124 1
	USB_ATTACH_START(uhidev, sc, uaa);
d143 1
a143 2
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
d163 1
a163 1
			USB_ATTACH_ERROR_RETURN;
d184 1
a184 1
			USB_ATTACH_ERROR_RETURN;
d195 1
a195 1
		USB_ATTACH_ERROR_RETURN;
d237 1
a237 1
		USB_ATTACH_ERROR_RETURN;
d246 1
a246 1
		USB_ATTACH_SUCCESS_RETURN;
d254 1
a254 1
		USB_ATTACH_ERROR_RETURN;
d295 1
a295 1
					USB_ATTACH_ERROR_RETURN;
a300 2

	USB_ATTACH_SUCCESS_RETURN;
d373 2
a374 1
USB_DETACH(uhidev)
d376 1
a376 1
	USB_DETACH_START(uhidev, sc);
@


1.19
log
@cover up a bug (resulting in noise in dmesg) that we still do not
understand, happens on the sun x4100 virtual console; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.18 2006/08/22 21:53:16 marco Exp $	*/
d69 2
a70 2
#define DPRINTF(x)	do { if (uhidevdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhidevdebug>(n)) logprintf x; } while (0)
@


1.18
log
@Fix possible NULL deref from Alexey V. Vatchenko <avv@@mail.zp.ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.17 2006/08/18 02:54:11 jason Exp $	*/
d448 1
a448 1
#ifdef DIAGNOSTIC
@


1.17
log
@support for ucycom:
- teach ucom that not all i/o is done via bulk pipes
- teach uhidev that i/o interrupt pipes are distinct
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.16 2006/06/23 06:27:11 miod Exp $	*/
d249 1
a249 2
				M_USBDEV, M_NOWAIT);
	bzero(sc->sc_subdevs, nrepid * sizeof(device_ptr_t));
d254 1
@


1.16
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.15 2006/06/17 16:27:58 miod Exp $	*/
d129 1
d154 30
a183 6
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
d186 6
a191 12
	DPRINTFN(10,("uhidev_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType,
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n", USBDEVNAME(sc->sc_dev));
a195 2
	sc->sc_ep_addr = ed->bEndpointAddress;

d381 2
a382 2
	if (sc->sc_intrpipe != NULL)
		usbd_abort_pipe(sc->sc_intrpipe);
d430 1
a430 1
		usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
d468 1
d484 1
a484 1
	/* Set up interrupt pipe. */
d486 4
a489 3
		 sc->sc_ep_addr));
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf,
d491 1
a491 1
	if (err) {
d493 45
a537 6
			 "error=%d\n",err));
		free(sc->sc_ibuf, M_USBDEV);
		scd->sc_state &= ~UHIDEV_OPEN;
		sc->sc_refcnt = 0;
		sc->sc_intrpipe = NULL;
		return (EIO);
d539 1
d541 23
d578 6
d585 10
a594 4
	if (sc->sc_intrpipe != NULL) {
		usbd_abort_pipe(sc->sc_intrpipe);
		usbd_close_pipe(sc->sc_intrpipe);
		sc->sc_intrpipe = NULL;
d646 25
@


1.15
log
@Recent Powerbook systems have their on-board keyboard and mouse devices
also showing up as usb devices, but both devices are tied.
To make things less confusing, do not attach the usb phantoms at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.14 2006/05/14 12:00:04 matthieu Exp $	*/
d339 1
a339 1
	int i, rv;
d343 1
a343 1
		return (EOPNOTSUPP);
a345 1
		rv = 0;
@


1.14
log
@Add a quirk to force the Wi-spy spectrum analyser to attach as ugen.
It claims to be a HID device, but it's not really one. ok miod@@, jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.13 2006/03/07 04:41:19 krw Exp $	*/
d103 13
@


1.13
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.12 2006/01/06 03:36:32 brad Exp $	*/
d98 2
@


1.12
log
@add Wacom Graphire3 and Graphire4 support.

From NetBSD via Michael Knudsen

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.11 2005/08/01 05:36:48 brad Exp $	*/
a263 5
#if defined(__NetBSD__) && NRND > 0
				rnd_attach_source(&dev->rnd_source, 
						  USBDEVNAME(dev->sc_dev), 
						  RND_TYPE_TTY, 0);
#endif
a358 3
#if defined(__NetBSD__) && NRND > 0
			rnd_detach_source(&sc->sc_subdevs[i]->rnd_source);
#endif
a420 3
#endif
#if defined(__NetBSD__) && NRND > 0
	rnd_add_uint32(&scd->rnd_source, (uintptr_t)(sc->sc_ibuf));
@


1.11
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.10 2004/07/08 22:18:44 deraadt Exp $	*/
d115 1
d165 4
a168 3
	if (uaa->vendor == USB_VENDOR_WACOM &&
	    uaa->product == USB_PRODUCT_WACOM_GRAPHIRE /* &&
	    uaa->revision == 0x???? */) { /* XXX should use revision */
d170 19
a188 1
		size = sizeof uhid_graphire_report_descr;
d194 1
a194 1
			memcpy(desc, uhid_graphire_report_descr, size);
@


1.10
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.9 2003/07/05 16:52:04 nate Exp $	*/
d116 1
a116 1
	char devinfo[1024];
d121 2
a122 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d125 2
a126 1
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
@


1.9
log
@sync with NetBSD
remove unused global.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.8 2003/05/19 04:17:53 nate Exp $	*/
d69 2
a70 2
#define DPRINTF(x)	if (uhidevdebug) logprintf x
#define DPRINTFN(n,x)	if (uhidevdebug>(n)) logprintf x
@


1.8
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uhidev.c,v 1.7 2003/05/07 04:33:33 deraadt Exp $	*/
/*	$NetBSD: uhidev.c,v 1.10 2002/10/09 06:27:09 fair Exp $	*/
a103 2
int repproto = 1;

d487 15
a501 8
	/* XXX */
	char buf[100];
	if (scd->sc_report_id) {
		buf[0] = scd->sc_report_id;
		memcpy(buf+1, data, len);
		len++;
		data = buf;
	}
d503 1
a503 2
	return usbd_set_report(scd->sc_parent->sc_iface, type,
			       scd->sc_report_id, data, len);
@


1.7
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.6 2002/11/11 02:32:32 nate Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/devclass/hid1_1.pdf
@


1.6
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.5 2002/07/25 04:07:33 nate Exp $	*/
d123 1
a123 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.6.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.6 2002/11/11 02:32:32 nate Exp $	*/
d123 1
a123 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.6.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.6.4.1 2003/05/13 19:35:12 ho Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
@


1.6.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhidev.c,v 1.14 2003/03/11 16:44:00 augustss Exp $	*/
d104 2
d489 8
a496 15
	char *buf;
	usbd_status retstat;

	if (scd->sc_report_id == 0)
		return usbd_set_report(scd->sc_parent->sc_iface, type,
				       scd->sc_report_id, data, len);

	buf = malloc(len + 1, M_TEMP, M_WAITOK);
	buf[0] = scd->sc_report_id;
	memcpy(buf+1, data, len);

	retstat = usbd_set_report(scd->sc_parent->sc_iface, type,
				  scd->sc_report_id, data, len + 1);

	free(buf, M_TEMP);
d498 2
a499 1
	return retstat;
@


1.5
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: uhidev.c,v 1.4 2002/07/25 02:18:10 nate Exp $	*/
/*	$NetBSD: uhidev.c,v 1.6 2002/07/11 21:14:29 augustss Exp $	*/
d244 5
a313 1
		break;
d344 3
d409 3
@


1.4
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uhidev.c,v 1.3 2002/05/09 15:06:29 nate Exp $	*/
/*	$NetBSD: uhidev.c,v 1.5 2002/02/27 01:30:50 augustss Exp $	*/
@


1.3
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
	
d119 1
a119 1
	
d148 1
a148 1
		     ed->bLength, ed->bDescriptorType, 
d185 1
a185 1
	
d365 1
a365 1
		
d436 2
a437 2
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, 
d488 1
a488 1
	return usbd_set_report(scd->sc_parent->sc_iface, type, 
d504 1
a504 1
	usbd_set_report_async(scd->sc_parent->sc_iface, type, 
d511 1
a511 1
	return usbd_get_report(scd->sc_parent->sc_iface, type, 
@


1.3.2.1
log
@Sync UBC branch to -current
@
text
@@


1.3.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: uhidev.c,v 1.6 2002/07/11 21:14:29 augustss Exp $	*/
d93 1
a93 1

d119 1
a119 1

d148 1
a148 1
		     ed->bLength, ed->bDescriptorType,
d185 1
a185 1

d365 1
a365 1

d436 2
a437 2
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr,
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf,
d488 1
a488 1
	return usbd_set_report(scd->sc_parent->sc_iface, type,
d504 1
a504 1
	usbd_set_report_async(scd->sc_parent->sc_iface, type,
d511 1
a511 1
	return usbd_get_report(scd->sc_parent->sc_iface, type,
@


1.3.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uhidev.c,v 1.10 2002/10/09 06:27:09 fair Exp $	*/
d123 1
a123 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
a243 5
#if defined(__NetBSD__) && NRND > 0
				rnd_attach_source(&dev->rnd_source, 
						  USBDEVNAME(dev->sc_dev), 
						  RND_TYPE_TTY, 0);
#endif
d309 1
a339 3
#if defined(__NetBSD__) && NRND > 0
			rnd_detach_source(&sc->sc_subdevs[i]->rnd_source);
#endif
a401 3
#endif
#if defined(__NetBSD__) && NRND > 0
	rnd_add_uint32(&scd->rnd_source, (uintptr_t)(sc->sc_ibuf));
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: uhidev.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

