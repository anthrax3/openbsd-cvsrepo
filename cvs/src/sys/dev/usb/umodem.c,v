head	1.62;
access;
symbols
	OPENBSD_6_0:1.60.0.4
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.59.0.4
	OPENBSD_5_8_BASE:1.59
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.45.0.6
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.4
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.7.0.8
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.12
	UBC:1.7.0.6
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	SMP:1.7.0.2
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.62
date	2017.03.29.01.27.40;	author jsg;	state Exp;
branches;
next	1.61;
commitid	lz8Mspkzzme5aLxA;

1.61
date	2017.03.29.00.18.51;	author jsg;	state Exp;
branches;
next	1.60;
commitid	2wnbo81sCyJadOCX;

1.60
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches;
next	1.59;
commitid	zkpZsVIWMnE2TPgn;

1.59
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.58;
commitid	p4LJxGKbi0BU2cG6;

1.58
date	2015.02.16.14.52.39;	author sthen;	state Exp;
branches;
next	1.57;
commitid	jYAFb9JDsnVtxKY0;

1.57
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.56;
commitid	PSjXNz8dGohZ6ZSK;

1.56
date	2014.05.01.03.45.08;	author sasano;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.30.20.37.03;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2013.12.14.09.48.04;	author yuo;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.07.12.53.14;	author pirofti;	state Exp;
branches;
next	1.50;

1.50
date	2013.07.05.07.56.36;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.26.13.46.40;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.09.01.16.39;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.22.16.31.19;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2011.02.17.16.12.22;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2010.12.02.01.37.45;	author jakemsr;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.18.09.55.58;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.12.05.43.34;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.26.00.38.38;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.09.28.00.20.12;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.11.12.16.46;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.07.11.10.47;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.11.02.59.15;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches
	1.7.2.1
	1.7.6.1;
next	1.6;

1.6
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.11.44.24;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.22.50.28;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.08.20.03.34;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.05.00.29.14;	author aaron;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.58;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Remove quirks for two devices that are known to be CDC ACM protocol 0
that are now covered by the generic class matching.
@
text
@/*	$OpenBSD: umodem.c,v 1.61 2017/03/29 00:18:51 jsg Exp $ */
/*	$NetBSD: umodem.c,v 1.45 2002/09/23 05:51:23 simonb Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Comm Class spec:  http://www.usb.org/developers/devclass_docs/usbccs10.pdf
 *                   http://www.usb.org/developers/devclass_docs/usbcdc11.pdf
 */

/*
 * TODO:
 * - Add error recovery in various places; the big problem is what
 *   to do in a callback if there is an error.
 * - Implement a Call Device for modems without multiplexed commands.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>

#include <dev/usb/ucomvar.h>

#ifdef UMODEM_DEBUG
#define DPRINTFN(n, x)	do { if (umodemdebug > (n)) printf x; } while (0)
int	umodemdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

/*
 * These are the maximum number of bytes transferred per frame.
 * Buffers are this large to deal with high speed wireless devices.
 * Capped at 1024 as ttymalloc() is limited to this amount.
 */
#define UMODEMIBUFSIZE 1024
#define UMODEMOBUFSIZE 1024

struct umodem_softc {
	struct device		 sc_dev;	/* base device */

	struct usbd_device	*sc_udev;	/* USB device */

	int			 sc_ctl_iface_no;
	struct usbd_interface	*sc_ctl_iface;	/* control interface */
	struct usbd_interface	*sc_data_iface;	/* data interface */

	int			 sc_cm_cap;	/* CM capabilities */
	int			 sc_acm_cap;	/* ACM capabilities */

	int			 sc_cm_over_data;

	struct usb_cdc_line_state sc_line_state;/* current line state */
	u_char			 sc_dtr;	/* current DTR state */
	u_char			 sc_rts;	/* current RTS state */

	struct device		*sc_subdev;	/* ucom device */

	u_char			 sc_opening;	/* lock during open */

	int			 sc_ctl_notify;	/* Notification endpoint */
	struct usbd_pipe	*sc_notify_pipe; /* Notification pipe */
	struct usb_cdc_notification sc_notify_buf; /* Notification structure */
	u_char			 sc_lsr;	/* Local status register */
	u_char			 sc_msr;	/* Modem status register */
};

usbd_status umodem_set_comm_feature(struct umodem_softc *sc,
					   int feature, int state);
usbd_status umodem_set_line_coding(struct umodem_softc *sc,
					  struct usb_cdc_line_state *state);

void	umodem_get_status(void *, int portno, u_char *lsr, u_char *msr);
void	umodem_set(void *, int, int, int);
void	umodem_dtr(struct umodem_softc *, int);
void	umodem_rts(struct umodem_softc *, int);
void	umodem_break(struct umodem_softc *, int);
void	umodem_set_line_state(struct umodem_softc *);
int	umodem_param(void *, int, struct termios *);
int	umodem_open(void *, int portno);
void	umodem_close(void *, int portno);
void	umodem_intr(struct usbd_xfer *, void *, usbd_status);

struct ucom_methods umodem_methods = {
	umodem_get_status,
	umodem_set,
	umodem_param,
	NULL,
	umodem_open,
	umodem_close,
	NULL,
	NULL,
};

int umodem_match(struct device *, void *, void *);
void umodem_attach(struct device *, struct device *, void *);
int umodem_detach(struct device *, int);

void umodem_get_caps(struct usb_attach_arg *, int, int *, int *, int *);

struct cfdriver umodem_cd = {
	NULL, "umodem", DV_DULL
};

const struct cfattach umodem_ca = {
	sizeof(struct umodem_softc), umodem_match, umodem_attach, umodem_detach
};

void
umodem_get_caps(struct usb_attach_arg *uaa, int ctl_iface_no,
    int *data_iface_idx, int *cm_cap, int *acm_cap)
{
	const usb_descriptor_t *desc;
	const usb_interface_descriptor_t *id;
	const struct usb_cdc_cm_descriptor *cmd;
	const struct usb_cdc_acm_descriptor *acmd;
	const struct usb_cdc_union_descriptor *uniond;
	struct usbd_desc_iter iter;
	int current_iface_no = -1;
	int data_iface_no = -1;
	int i;

	*data_iface_idx = -1;
	*cm_cap = *acm_cap = 0;
	usbd_desc_iter_init(uaa->device, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType == UDESC_INTERFACE) {
			id = (usb_interface_descriptor_t *)desc;
			current_iface_no = id->bInterfaceNumber;
			if (current_iface_no != ctl_iface_no &&
			    id->bInterfaceClass == UICLASS_CDC_DATA &&
			    id->bInterfaceSubClass == UISUBCLASS_DATA &&
			    data_iface_no == -1)
				data_iface_no = current_iface_no;
		}
		if (current_iface_no == ctl_iface_no &&
		    desc->bDescriptorType == UDESC_CS_INTERFACE) {
			switch(desc->bDescriptorSubtype) {
			case UDESCSUB_CDC_CM:
				cmd = (struct usb_cdc_cm_descriptor *)desc;
				*cm_cap = cmd->bmCapabilities;
				data_iface_no = cmd->bDataInterface;
				break;
			case UDESCSUB_CDC_ACM:
				acmd = (struct usb_cdc_acm_descriptor *)desc;
				*acm_cap = acmd->bmCapabilities;
				break;
			case UDESCSUB_CDC_UNION:
				uniond =
				    (struct usb_cdc_union_descriptor *)desc;
				data_iface_no = uniond->bSlaveInterface[0];
				break;
			}
		}
		desc = usbd_desc_iter_next(&iter);
	}

	/*
	 * If we got a data interface number, make sure the corresponding
	 * interface exists and is not already claimed.
	 */
	if (data_iface_no != -1) {
		for (i = 0; i < uaa->nifaces; i++) {
			id = usbd_get_interface_descriptor(uaa->ifaces[i]);

			if (id == NULL)
				continue;

			if (id->bInterfaceNumber == data_iface_no) {
				if (!usbd_iface_claimed(uaa->device, i))
					*data_iface_idx = i;
				break;
			}
		}
	}
}

int
umodem_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_device_descriptor_t *dd;
	int data_iface_idx, cm_cap, acm_cap, ret = UMATCH_NONE;

	if (uaa->iface == NULL)
		return (ret);

	id = usbd_get_interface_descriptor(uaa->iface);
	dd = usbd_get_device_descriptor(uaa->device);
	if (id == NULL || dd == NULL)
		return (ret);

	ret = UMATCH_NONE;

	if (UGETW(dd->idVendor) == USB_VENDOR_KYOCERA &&
	    UGETW(dd->idProduct) == USB_PRODUCT_KYOCERA_AHK3001V &&
	    id->bInterfaceNumber == 0)
		ret = UMATCH_VENDOR_PRODUCT;

	if (ret == UMATCH_NONE &&
	    id->bInterfaceClass == UICLASS_CDC &&
	    id->bInterfaceSubClass == UISUBCLASS_ABSTRACT_CONTROL_MODEL &&
	    (id->bInterfaceProtocol == UIPROTO_CDC_AT ||
	    id->bInterfaceProtocol == UIPROTO_CDC_NOCLASS))
		ret = UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO;

	if (ret == UMATCH_NONE)
		return (ret);

	/* umodem doesn't support devices without a data iface */
	umodem_get_caps(uaa, id->bInterfaceNumber, &data_iface_idx,
	    &cm_cap, &acm_cap);
	if (data_iface_idx == -1)
		ret = UMATCH_NONE;

	return (ret);
}

void
umodem_attach(struct device *parent, struct device *self, void *aux)
{
	struct umodem_softc *sc = (struct umodem_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status err;
	int data_iface_idx = -1;
	int i;
	struct ucom_attach_args uca;

	sc->sc_udev = dev;
	sc->sc_ctl_iface = uaa->iface;

	id = usbd_get_interface_descriptor(sc->sc_ctl_iface);
	//printf("%s: iclass %d/%d\n", sc->sc_dev.dv_xname,
	//    id->bInterfaceClass, id->bInterfaceSubClass);
	sc->sc_ctl_iface_no = id->bInterfaceNumber;

	/* Get the capabilities. */
	umodem_get_caps(uaa, id->bInterfaceNumber, &data_iface_idx,
	    &sc->sc_cm_cap, &sc->sc_acm_cap);

	usbd_claim_iface(sc->sc_udev, data_iface_idx);
	sc->sc_data_iface = uaa->ifaces[data_iface_idx];
	id = usbd_get_interface_descriptor(sc->sc_data_iface);

	printf("%s: data interface %d, has %sCM over data, has %sbreak\n",
	       sc->sc_dev.dv_xname, id->bInterfaceNumber,
	       sc->sc_cm_cap & USB_CDC_CM_OVER_DATA ? "" : "no ",
	       sc->sc_acm_cap & USB_CDC_ACM_HAS_BREAK ? "" : "no ");

	/*
	 * Find the bulk endpoints.
	 * Iterate over all endpoints in the data interface and take note.
	 */
	uca.bulkin = uca.bulkout = -1;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_data_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			goto bad;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
                        uca.bulkin = ed->bEndpointAddress;
                } else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
                        uca.bulkout = ed->bEndpointAddress;
                }
        }

	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
		       sc->sc_dev.dv_xname);
		goto bad;
	}
	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
			sc->sc_dev.dv_xname);
		goto bad;
	}

	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_ASSUME_CM_OVER_DATA) {
		sc->sc_cm_over_data = 1;
	} else {
		if (sc->sc_cm_cap & USB_CDC_CM_OVER_DATA) {
			if (sc->sc_acm_cap & USB_CDC_ACM_HAS_FEATURE)
				err = umodem_set_comm_feature(sc,
				    UCDC_ABSTRACT_STATE, UCDC_DATA_MULTIPLEXED);
			else
				err = 0;
			if (err) {
				printf("%s: could not set data multiplex mode\n",
				       sc->sc_dev.dv_xname);
				goto bad;
			}
			sc->sc_cm_over_data = 1;
		}
	}

	/*
	 * The standard allows for notification messages (to indicate things
	 * like a modem hangup) to come in via an interrupt endpoint
	 * off of the control interface.  Iterate over the endpoints on
	 * the control interface and see if there are any interrupt
	 * endpoints; if there are, then register it.
	 */

	sc->sc_ctl_notify = -1;
	sc->sc_notify_pipe = NULL;

	id = usbd_get_interface_descriptor(sc->sc_ctl_iface);
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_ctl_iface, i);
		if (ed == NULL)
			continue;

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
			printf("%s: status change notification available\n",
			       sc->sc_dev.dv_xname);
			sc->sc_ctl_notify = ed->bEndpointAddress;
		}
	}

	sc->sc_dtr = -1;

	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
	uca.ibufsize = UMODEMIBUFSIZE;
	uca.obufsize = UMODEMOBUFSIZE;
	uca.ibufsizepad = UMODEMIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = sc->sc_udev;
	uca.iface = sc->sc_data_iface;
	uca.methods = &umodem_methods;
	uca.arg = sc;
	uca.info = NULL;

	DPRINTF(("umodem_attach: sc=%p\n", sc));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);

	return;

 bad:
	usbd_deactivate(sc->sc_udev);
}

int
umodem_open(void *addr, int portno)
{
	struct umodem_softc *sc = addr;
	int err;

	DPRINTF(("umodem_open: sc=%p\n", sc));

	if (sc->sc_ctl_notify != -1 && sc->sc_notify_pipe == NULL) {
		err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_ctl_notify,
		    USBD_SHORT_XFER_OK, &sc->sc_notify_pipe, sc,
		    &sc->sc_notify_buf, sizeof(sc->sc_notify_buf),
		    umodem_intr, USBD_DEFAULT_INTERVAL);

		if (err) {
			DPRINTF(("Failed to establish notify pipe: %s\n",
				usbd_errstr(err)));
			return EIO;
		}
	}

	return 0;
}

void
umodem_close(void *addr, int portno)
{
	struct umodem_softc *sc = addr;
	int err;

	DPRINTF(("umodem_close: sc=%p\n", sc));

	if (sc->sc_notify_pipe != NULL) {
		usbd_abort_pipe(sc->sc_notify_pipe);
		err = usbd_close_pipe(sc->sc_notify_pipe);
		if (err)
			printf("%s: close notify pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_notify_pipe = NULL;
	}
}

void
umodem_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct umodem_softc *sc = priv;
	u_char mstatus;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		DPRINTF(("%s: abnormal status: %s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_notify_pipe);
		return;
	}

	if (sc->sc_notify_buf.bmRequestType != UCDC_NOTIFICATION) {
		DPRINTF(("%s: unknown message type (%02x) on notify pipe\n",
			 sc->sc_dev.dv_xname,
			 sc->sc_notify_buf.bmRequestType));
		return;
	}

	switch (sc->sc_notify_buf.bNotification) {
	case UCDC_N_SERIAL_STATE:
		/*
		 * Set the serial state in ucom driver based on
		 * the bits from the notify message
		 */
		if (UGETW(sc->sc_notify_buf.wLength) != 2) {
			printf("%s: Invalid notification length! (%d)\n",
			       sc->sc_dev.dv_xname,
			       UGETW(sc->sc_notify_buf.wLength));
			break;
		}
		DPRINTF(("%s: notify bytes = %02x%02x\n",
			 sc->sc_dev.dv_xname,
			 sc->sc_notify_buf.data[0],
			 sc->sc_notify_buf.data[1]));
		/* Currently, lsr is always zero. */
		sc->sc_lsr = sc->sc_msr = 0;
		mstatus = sc->sc_notify_buf.data[0];

		if (ISSET(mstatus, UCDC_N_SERIAL_RI))
			sc->sc_msr |= UMSR_RI;
		if (ISSET(mstatus, UCDC_N_SERIAL_DSR))
			sc->sc_msr |= UMSR_DSR;
		if (ISSET(mstatus, UCDC_N_SERIAL_DCD))
			sc->sc_msr |= UMSR_DCD;
		ucom_status_change((struct ucom_softc *)sc->sc_subdev);
		break;
	default:
		DPRINTF(("%s: unknown notify message: %02x\n",
			 sc->sc_dev.dv_xname,
			 sc->sc_notify_buf.bNotification));
		break;
	}
}

void
umodem_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct umodem_softc *sc = addr;

	DPRINTF(("umodem_get_status:\n"));

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}

int
umodem_param(void *addr, int portno, struct termios *t)
{
	struct umodem_softc *sc = addr;
	usbd_status err;
	struct usb_cdc_line_state ls;

	DPRINTF(("umodem_param: sc=%p\n", sc));

	USETDW(ls.dwDTERate, t->c_ospeed);
	if (ISSET(t->c_cflag, CSTOPB))
		ls.bCharFormat = UCDC_STOP_BIT_2;
	else
		ls.bCharFormat = UCDC_STOP_BIT_1;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			ls.bParityType = UCDC_PARITY_ODD;
		else
			ls.bParityType = UCDC_PARITY_EVEN;
	} else
		ls.bParityType = UCDC_PARITY_NONE;
	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		ls.bDataBits = 5;
		break;
	case CS6:
		ls.bDataBits = 6;
		break;
	case CS7:
		ls.bDataBits = 7;
		break;
	case CS8:
		ls.bDataBits = 8;
		break;
	}

	err = umodem_set_line_coding(sc, &ls);
	if (err) {
		DPRINTF(("umodem_param: err=%s\n", usbd_errstr(err)));
		return (1);
	}
	return (0);
}

void
umodem_dtr(struct umodem_softc *sc, int onoff)
{
	DPRINTF(("umodem_dtr: onoff=%d\n", onoff));

	if (sc->sc_dtr == onoff)
		return;
	sc->sc_dtr = onoff;

	umodem_set_line_state(sc);
}

void
umodem_rts(struct umodem_softc *sc, int onoff)
{
	DPRINTF(("umodem_rts: onoff=%d\n", onoff));

	if (sc->sc_rts == onoff)
		return;
	sc->sc_rts = onoff;

	umodem_set_line_state(sc);
}

void
umodem_set_line_state(struct umodem_softc *sc)
{
	usb_device_request_t req;
	int ls;

	ls = (sc->sc_dtr ? UCDC_LINE_DTR : 0) |
	     (sc->sc_rts ? UCDC_LINE_RTS : 0);
	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_CONTROL_LINE_STATE;
	USETW(req.wValue, ls);
	USETW(req.wIndex, sc->sc_ctl_iface_no);
	USETW(req.wLength, 0);

	(void)usbd_do_request(sc->sc_udev, &req, 0);

}

void
umodem_break(struct umodem_softc *sc, int onoff)
{
	usb_device_request_t req;

	DPRINTF(("umodem_break: onoff=%d\n", onoff));

	if (!(sc->sc_acm_cap & USB_CDC_ACM_HAS_BREAK))
		return;

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SEND_BREAK;
	USETW(req.wValue, onoff ? UCDC_BREAK_ON : UCDC_BREAK_OFF);
	USETW(req.wIndex, sc->sc_ctl_iface_no);
	USETW(req.wLength, 0);

	(void)usbd_do_request(sc->sc_udev, &req, 0);
}

void
umodem_set(void *addr, int portno, int reg, int onoff)
{
	struct umodem_softc *sc = addr;

	switch (reg) {
	case UCOM_SET_DTR:
		umodem_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		umodem_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		umodem_break(sc, onoff);
		break;
	default:
		break;
	}
}

usbd_status
umodem_set_line_coding(struct umodem_softc *sc,
    struct usb_cdc_line_state *state)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("umodem_set_line_coding: rate=%d fmt=%d parity=%d bits=%d\n",
		 UGETDW(state->dwDTERate), state->bCharFormat,
		 state->bParityType, state->bDataBits));

	if (memcmp(state, &sc->sc_line_state, UCDC_LINE_STATE_LENGTH) == 0) {
		DPRINTF(("umodem_set_line_coding: already set\n"));
		return (USBD_NORMAL_COMPLETION);
	}

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_LINE_CODING;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_ctl_iface_no);
	USETW(req.wLength, UCDC_LINE_STATE_LENGTH);

	err = usbd_do_request(sc->sc_udev, &req, state);
	if (err) {
		DPRINTF(("umodem_set_line_coding: failed, err=%s\n",
			 usbd_errstr(err)));
		return (err);
	}

	sc->sc_line_state = *state;

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
umodem_set_comm_feature(struct umodem_softc *sc, int feature, int state)
{
	usb_device_request_t req;
	usbd_status err;
	struct usb_cdc_abstract_state ast;

	DPRINTF(("umodem_set_comm_feature: feature=%d state=%d\n", feature,
		 state));

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = UCDC_SET_COMM_FEATURE;
	USETW(req.wValue, feature);
	USETW(req.wIndex, sc->sc_ctl_iface_no);
	USETW(req.wLength, UCDC_ABSTRACT_STATE_LENGTH);
	USETW(ast.wState, state);

	err = usbd_do_request(sc->sc_udev, &req, &ast);
	if (err) {
		DPRINTF(("umodem_set_comm_feature: feature=%d, err=%s\n",
			 feature, usbd_errstr(err)));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

int
umodem_detach(struct device *self, int flags)
{
	struct umodem_softc *sc = (struct umodem_softc *)self;
	int rv = 0;

	DPRINTF(("umodem_detach: sc=%p flags=%d\n", sc, flags));

	if (sc->sc_notify_pipe != NULL) {
		usbd_abort_pipe(sc->sc_notify_pipe);
		usbd_close_pipe(sc->sc_notify_pipe);
		sc->sc_notify_pipe = NULL;
	}

	if (sc->sc_subdev != NULL)
		rv = config_detach(sc->sc_subdev, flags);

	return (rv);
}
@


1.61
log
@Match on class communications subclass abstract control model protocol
0 "No class specific protocol required" in addition to the existing
protocol 1 "AT Commands: V.250 etc" match.

This lets umodem(4) attach to the serial console on the overdrive 1000
which is a usb type-b socket on the back of the box not a db9 like the
overdrive 3000.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.60 2016/05/24 05:35:01 mpi Exp $ */
a239 5
	/* protocol of 0 so won't match the test below */
	if (UGETW(dd->idVendor) == USB_VENDOR_ATMEL &&
	    UGETW(dd->idProduct) == USB_PRODUCT_ATMEL_AT91_CDC_ACM)
		ret = UMATCH_VENDOR_PRODUCT;

a243 4

	if (UGETW(dd->idVendor) == USB_VENDOR_ARDUINO &&
	    UGETW(dd->idProduct) == USB_PRODUCT_ARDUINO_LEONARDO)
	    ret = UMATCH_VENDOR_PRODUCT;
@


1.60
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.59 2015/03/14 03:38:50 jsg Exp $ */
d257 2
a258 1
	    id->bInterfaceProtocol == UIPROTO_CDC_AT)
@


1.59
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.58 2015/02/16 14:52:39 sthen Exp $ */
a49 1
#include <sys/ioctl.h>
a122 1
int	umodem_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
d131 1
a131 1
	umodem_ioctl,
a562 32
}

int
umodem_ioctl(void *addr, int portno, u_long cmd, caddr_t data, int flag,
	     struct proc *p)
{
	struct umodem_softc *sc = addr;
	int error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("umodem_ioctl: cmd=0x%08lx\n", cmd));

	switch (cmd) {
	case USB_GET_CM_OVER_DATA:
		*(int *)data = sc->sc_cm_over_data;
		break;

	case USB_SET_CM_OVER_DATA:
		if (*(int *)data != sc->sc_cm_over_data) {
			/* XXX change it */
		}
		break;

	default:
		DPRINTF(("umodem_ioctl: unknown\n"));
		error = ENOTTY;
		break;
	}

	return (error);
@


1.58
log
@allow Arduino Leonardo to attach to umodem(4), from Gregor Best
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.57 2014/07/12 20:26:33 mpi Exp $ */
a61 1
#include <dev/usb/usbdi_util.h>
@


1.57
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.56 2014/05/01 03:45:08 sasano Exp $ */
d252 4
@


1.56
log
@fixed some debug messages
ok by dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.55 2014/01/30 20:37:03 mpi Exp $ */
d141 3
a143 4
int umodem_match(struct device *, void *, void *); 
void umodem_attach(struct device *, struct device *, void *); 
int umodem_detach(struct device *, int); 
int umodem_activate(struct device *, int); 
d147 6
a152 10
struct cfdriver umodem_cd = { 
	NULL, "umodem", DV_DULL 
}; 

const struct cfattach umodem_ca = { 
	sizeof(struct umodem_softc), 
	umodem_match, 
	umodem_attach, 
	umodem_detach, 
	umodem_activate, 
a735 13
}

int
umodem_activate(struct device *self, int act)
{
	struct umodem_softc *sc = (struct umodem_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.55
log
@Do not match control interfaces if their associated data interface is
missing or already claimed.

This fixes a problem with the Ericsson F3507g embedded in the x200s
that has a broken configuration descriptor reporting too few
interfaces.

Problem reported and fix tested by Harald Hellmuth and florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.54 2013/12/14 09:48:04 yuo Exp $ */
d579 1
a579 1
	DPRINTF(("umodemioctl: cmd=0x%08lx\n", cmd));
d593 1
a593 1
		DPRINTF(("umodemioctl: unknown\n"));
d604 1
a604 1
	DPRINTF(("umodem_modem: onoff=%d\n", onoff));
d616 1
a616 1
	DPRINTF(("umodem_modem: onoff=%d\n", onoff));
@


1.54
log
@remove a duplicated includ file.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.53 2013/11/15 10:17:39 pirofti Exp $ */
d162 1
a162 1
    int *data_iface_no, int *cm_cap, int *acm_cap)
d171 2
d174 1
a174 1
	*data_iface_no = -1;
d185 2
a186 2
			    *data_iface_no == -1)
				*data_iface_no = current_iface_no;
d194 1
a194 1
				*data_iface_no = cmd->bDataInterface;
d203 1
a203 1
				*data_iface_no = uniond->bSlaveInterface[0];
d209 19
d236 1
a236 1
	int data_iface_no, cm_cap, acm_cap, ret = UMATCH_NONE;
d268 1
a268 1
	umodem_get_caps(uaa, id->bInterfaceNumber, &data_iface_no,
d270 1
a270 1
	if (data_iface_no == -1)
d285 1
a285 1
	int data_iface_no = 0;
d298 1
a298 1
	umodem_get_caps(uaa, id->bInterfaceNumber, &data_iface_no,
d300 4
a303 5
	if (data_iface_no == -1) {
		printf("%s: no data interface\n",
		       sc->sc_dev.dv_xname);
		goto bad;
	}
d306 1
a306 1
	       sc->sc_dev.dv_xname, data_iface_no,
a309 16
	/* Get the data interface too. */
	for (i = 0; i < uaa->nifaces; i++) {
		if (!usbd_iface_claimed(sc->sc_udev, i)) {
			id = usbd_get_interface_descriptor(uaa->ifaces[i]);
			if (id != NULL &&
                            id->bInterfaceNumber == data_iface_no) {
				sc->sc_data_iface = uaa->ifaces[i];
				usbd_claim_iface(sc->sc_udev, i);
			}
		}
	}
	if (sc->sc_data_iface == NULL) {
		printf("%s: no data interface\n", sc->sc_dev.dv_xname);
		goto bad;
	}

a315 1
	id = usbd_get_interface_descriptor(sc->sc_data_iface);
@


1.53
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.52 2013/11/15 08:25:31 pirofti Exp $ */
a65 1
#include <dev/usb/usbdevs.h>
@


1.52
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.51 2013/11/07 12:53:14 pirofti Exp $ */
d440 1
a440 4
		err = usbd_abort_pipe(sc->sc_notify_pipe);
		if (err)
			printf("%s: abort notify pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.51
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.50 2013/07/05 07:56:36 mpi Exp $ */
a747 1
	int rv = 0;
a751 2
		if (sc->sc_subdev)
			rv = config_deactivate(sc->sc_subdev);
d754 1
a754 1
	return (rv);
@


1.50
log
@Correctly abort and free the pipe when detaching the device. Found the
hard way by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.49 2013/04/26 13:46:40 mglocker Exp $ */
a105 1
	u_char			 sc_dying;	/* disconnecting */
d404 1
a404 1
	sc->sc_dying = 1;
d458 1
a458 1
	if (sc->sc_dying)
d577 1
a577 1
	if (sc->sc_dying)
d752 1
a752 1
		sc->sc_dying = 1;
@


1.49
log
@Rename three functions in usbdi.c to their right prefix (usb_* to usbd_*).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.48 2013/04/15 09:23:02 mglocker Exp $ */
d768 6
@


1.48
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.47 2013/03/28 03:58:03 tedu Exp $ */
d176 2
a177 2
	usb_desc_iter_init(uaa->device, &iter);
	desc = usb_desc_iter_next(&iter);
d207 1
a207 1
		desc = usb_desc_iter_next(&iter);
@


1.47
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.46 2013/03/28 03:31:55 tedu Exp $ */
d88 1
a88 1
	usbd_device_handle	 sc_udev;	/* USB device */
d91 2
a92 2
	usbd_interface_handle	 sc_ctl_iface;	/* control interface */
	usbd_interface_handle	 sc_data_iface;	/* data interface */
d99 1
a99 1
	usb_cdc_line_state_t	 sc_line_state;	/* current line state */
d109 2
a110 2
	usbd_pipe_handle	 sc_notify_pipe; /* Notification pipe */
	usb_cdc_notification_t	 sc_notify_buf;	/* Notification structure */
d118 1
a118 1
					  usb_cdc_line_state_t *state);
d130 1
a130 1
void	umodem_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d168 4
a171 4
	const usb_cdc_cm_descriptor_t *cmd;
	const usb_cdc_acm_descriptor_t *acmd;
	const usb_cdc_union_descriptor_t *uniond;
	usbd_desc_iter_t iter;
d192 1
a192 1
				cmd = (usb_cdc_cm_descriptor_t *)desc;
d197 1
a197 1
				acmd = (usb_cdc_acm_descriptor_t *)desc;
d201 2
a202 1
				uniond = (usb_cdc_union_descriptor_t *)desc;
d262 1
a262 1
	usbd_device_handle dev = uaa->device;
d454 1
a454 1
umodem_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d532 1
a532 1
	usb_cdc_line_state_t ls;
d685 2
a686 1
umodem_set_line_coding(struct umodem_softc *sc, usb_cdc_line_state_t *state)
d723 1
a723 1
	usb_cdc_abstract_state_t ast;
@


1.46
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.45 2012/02/09 01:16:39 jsg Exp $ */
a54 1
#include <sys/proc.h>
@


1.45
log
@Match on Atmel AT91 CDC ACM explicitly as it reports a protocol of 0
so fails to match on class.

Tested by LEVAI Daniel. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.44 2011/07/03 15:47:17 matthew Exp $ */
a55 1
#include <sys/vnode.h>
@


1.44
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.43 2011/03/22 16:31:19 deraadt Exp $ */
d229 6
@


1.43
log
@silently clear the endpoint when the device has failed; ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.42 2011/02/17 16:12:22 jakemsr Exp $ */
a745 3
	case DVACT_ACTIVATE:
		break;

@


1.42
log
@allow interfaces other than slaves of the union interface to be the
data interface.  lets an "MTK GPS Receiver" work, as reported by
Daniel C. Sinclair.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.41 2011/01/25 20:03:36 jakemsr Exp $ */
d460 3
a462 2
		printf("%s: abnormal status: %s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(status));
@


1.41
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.40 2011/01/16 22:35:29 jakemsr Exp $ */
d176 1
d182 7
a188 2
		    id = (usb_interface_descriptor_t *)desc;
		    current_iface_no = id->bInterfaceNumber;
d243 1
a243 1
	/* umodem doesn't yet support devices without a data iface */
d246 1
a246 1
	if (data_iface_no == 0)
d276 2
a277 2
	if (data_iface_no == 0) {
		printf("%s: no pointer to data interface\n",
@


1.40
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.39 2010/12/02 01:37:45 jakemsr Exp $ */
a387 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a760 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.39
log
@don't match/attach devices without a data endpoint, since this driver
can't use them anyway.
tested with working umodem by sthen@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.38 2010/09/24 08:33:59 yuo Exp $ */
d283 1
a283 1
		if (uaa->ifaces[i] != NULL) {
d288 1
a288 1
				uaa->ifaces[i] = NULL;
@


1.38
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.37 2009/10/13 19:33:19 pirofti Exp $ */
a93 1
	int			 sc_data_iface_no;
d150 2
d164 42
d212 1
a212 1
	int ret;
d215 1
a215 1
		return (UMATCH_NONE);
d220 1
a220 1
		return (UMATCH_NONE);
d234 9
a253 6
	usb_cdc_cm_descriptor_t *cmd;      
	usb_interface_descriptor_t *idesc;
	const usb_cdc_acm_descriptor_t *acmd;
	const usb_cdc_union_descriptor_t *uniond;
	const usb_descriptor_t *desc;
	usbd_desc_iter_t iter;
d255 1
a255 1
	int current_iface_no = -1;
d267 4
a270 34
	/* Get the data interface no. and capabilities */
	sc->sc_cm_cap = 0;
	sc->sc_data_iface_no = 0;
	sc->sc_acm_cap = 0;
	usb_desc_iter_init(dev, &iter);
	desc = usb_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType == UDESC_INTERFACE) {
		    idesc = (usb_interface_descriptor_t *)desc;
		    current_iface_no = idesc->bInterfaceNumber;
		}
		if (current_iface_no == sc->sc_ctl_iface_no &&
		    desc->bDescriptorType == UDESC_CS_INTERFACE) {
			switch(desc->bDescriptorSubtype) {
			case UDESCSUB_CDC_CM:
				cmd = (usb_cdc_cm_descriptor_t *)desc;
				sc->sc_cm_cap = cmd->bmCapabilities;
				sc->sc_data_iface_no = cmd->bDataInterface;
				break;
			case UDESCSUB_CDC_ACM:
				acmd = (usb_cdc_acm_descriptor_t *)desc;
				sc->sc_acm_cap = acmd->bmCapabilities;
				break;
			case UDESCSUB_CDC_UNION:
				uniond = (usb_cdc_union_descriptor_t *)desc;
				sc->sc_data_iface_no =
				    uniond->bSlaveInterface[0];
				break;
			}
		}
		desc = usb_desc_iter_next(&iter);
	}

	if (sc->sc_data_iface_no == 0) {
d277 1
a277 1
	       sc->sc_dev.dv_xname, sc->sc_data_iface_no,
d286 1
a286 1
                            id->bInterfaceNumber == sc->sc_data_iface_no) {
@


1.37
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.36 2008/06/26 05:42:19 ray Exp $ */
a744 2

	sc->sc_dying = 1;
@


1.36
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.35 2007/10/11 18:33:15 deraadt Exp $ */
d149 1
a149 1
int umodem_activate(struct device *, enum devact); 
d720 1
a720 1
umodem_activate(struct device *self, enum devact act)
@


1.35
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.34 2007/06/18 09:55:58 mbalmer Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.34
log
@Use the right interface id when iterating over the control interface
endpoints.

bug found and patch provided by Marc Winiger <mw@@msys.ch>.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.33 2007/06/14 10:11:16 mbalmer Exp $ */
a214 1
	char *devinfop;
a219 3
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n");

d224 2
a225 3
	printf("%s: %s, iclass %d/%d\n", sc->sc_dev.dv_xname,
	       devinfop, id->bInterfaceClass, id->bInterfaceSubClass);
	usbd_devinfo_free(devinfop);
@


1.33
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.32 2007/06/13 06:25:03 mbalmer Exp $ */
d356 1
@


1.32
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.31 2007/06/12 16:26:36 mbalmer Exp $ */
d153 16
a168 1
USB_DECLARE_DRIVER(umodem);
@


1.31
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.30 2007/06/11 16:30:31 mbalmer Exp $ */
d95 1
a95 1
	struct device		sc_dev;		/* base device */
d97 1
a97 1
	usbd_device_handle	sc_udev;	/* USB device */
d99 4
a102 4
	int			sc_ctl_iface_no;
	usbd_interface_handle	sc_ctl_iface;	/* control interface */
	int			sc_data_iface_no;
	usbd_interface_handle	sc_data_iface;	/* data interface */
d104 2
a105 2
	int			sc_cm_cap;	/* CM capabilities */
	int			sc_acm_cap;	/* ACM capabilities */
d107 1
a107 1
	int			sc_cm_over_data;
d109 3
a111 3
	usb_cdc_line_state_t	sc_line_state;	/* current line state */
	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */
d113 1
a113 1
	struct device *		sc_subdev;	/* ucom device */
d115 2
a116 2
	u_char			sc_opening;	/* lock during open */
	u_char			sc_dying;	/* disconnecting */
d118 5
a122 5
	int			sc_ctl_notify;	/* Notification endpoint */
	usbd_pipe_handle	sc_notify_pipe; /* Notification pipe */
	usb_cdc_notification_t	sc_notify_buf;	/* Notification structure */
	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* Modem status register */
@


1.30
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.29 2007/06/10 14:49:01 mbalmer Exp $ */
d113 1
a113 1
	device_ptr_t		sc_subdev;	/* ucom device */
d716 1
a716 1
umodem_activate(device_ptr_t self, enum devact act)
@


1.29
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.28 2007/06/10 10:53:48 mbalmer Exp $ */
d137 1
a137 1
int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d544 1
a544 1
	     usb_proc_ptr p)
@


1.28
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.27 2007/06/06 19:25:49 mk Exp $ */
d213 1
a213 1
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
d253 1
a253 1
		       USBDEVNAME(sc->sc_dev));
d258 1
a258 1
	       USBDEVNAME(sc->sc_dev), sc->sc_data_iface_no,
d274 1
a274 1
		printf("%s: no data interface\n", USBDEVNAME(sc->sc_dev));
d289 1
a289 1
				USBDEVNAME(sc->sc_dev), i);
d303 1
a303 1
		       USBDEVNAME(sc->sc_dev));
d308 1
a308 1
			USBDEVNAME(sc->sc_dev));
d323 1
a323 1
				       USBDEVNAME(sc->sc_dev));
d349 1
a349 1
			       USBDEVNAME(sc->sc_dev));
d416 1
a416 1
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d420 1
a420 1
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d437 1
a437 1
		printf("%s: abnormal status: %s\n", USBDEVNAME(sc->sc_dev),
d444 1
a444 1
			 USBDEVNAME(sc->sc_dev),
d457 1
a457 1
			       USBDEVNAME(sc->sc_dev),
d462 1
a462 1
			 USBDEVNAME(sc->sc_dev),
d479 1
a479 1
			 USBDEVNAME(sc->sc_dev),
@


1.27
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.26 2007/06/05 08:43:56 mbalmer Exp $ */
d369 1
a369 1
			   USBDEV(sc->sc_dev));
d748 1
a748 1
			   USBDEV(sc->sc_dev));
@


1.26
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.25 2007/05/27 04:00:25 jsg Exp $ */
d95 1
a95 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.25
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.24 2007/05/21 05:40:28 jsg Exp $ */
d125 1
a125 1
Static usbd_status umodem_set_comm_feature(struct umodem_softc *sc,
d127 1
a127 1
Static usbd_status umodem_set_line_coding(struct umodem_softc *sc,
d130 11
a140 11
Static void	umodem_get_status(void *, int portno, u_char *lsr, u_char *msr);
Static void	umodem_set(void *, int, int, int);
Static void	umodem_dtr(struct umodem_softc *, int);
Static void	umodem_rts(struct umodem_softc *, int);
Static void	umodem_break(struct umodem_softc *, int);
Static void	umodem_set_line_state(struct umodem_softc *);
Static int	umodem_param(void *, int, struct termios *);
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
Static int	umodem_open(void *, int portno);
Static void	umodem_close(void *, int portno);
Static void	umodem_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d142 1
a142 1
Static struct ucom_methods umodem_methods = {
d380 1
a380 1
Static int
d404 1
a404 1
Static void
d425 1
a425 1
Static void
@


1.24
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.23 2007/03/12 05:43:34 deraadt Exp $ */
d155 2
a156 1
USB_MATCH(umodem)
d158 1
a158 1
	USB_MATCH_START(umodem, uaa);
d186 2
a187 1
USB_ATTACH(umodem)
d189 2
a190 1
	USB_ATTACH_START(umodem, sc, uaa);
d207 1
a207 1
	USB_ATTACH_SETUP;
d374 1
a374 1
	USB_ATTACH_SUCCESS_RETURN;
a377 1
	USB_ATTACH_ERROR_RETURN;
d734 2
a735 1
USB_DETACH(umodem)
d737 1
a737 1
	USB_DETACH_START(umodem, sc);
@


1.23
log
@very ugly indent
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.22 2006/07/26 00:38:38 jsg Exp $ */
d79 1
a79 1
#define DPRINTFN(n, x)	do { if (umodemdebug > (n)) logprintf x; } while (0)
@


1.22
log
@Crank buffer sizes to the 1024 limit imposed by ttymalloc()
which should allow high speed devices to work better.
tested by fkr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.21 2006/06/23 06:27:12 miod Exp $ */
d233 1
a233 1
			break;
d237 1
a237 1
			break;
d242 1
a242 1
			break;
@


1.21
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.20 2005/11/21 18:16:44 millert Exp $ */
d88 2
a89 2
 * If some really high speed devices should use this driver they
 * may need to be increased, but this is good enough for normal modems.
d91 2
a92 2
#define UMODEMIBUFSIZE 64
#define UMODEMOBUFSIZE 256
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.19 2005/09/28 00:20:12 dlg Exp $ */
d721 1
a721 1
		return (EOPNOTSUPP);
@


1.19
log
@add support for the nokia 6680 with a ca-42 cable.

When looping over all the descriptors to fund functional
descriptors for CM, ACM, and UNION, I make sure to only look for
these descriptors in the interface number we are using.  At least
on the 6680, there are lots of interfaces, and more than one of
them have UNION and ACM functional descriptors.  Only the ones at
the CDC/ACM/AT interface are the ones to use...

diff from Staffan Ulberg, on top of a diff from Tony Lambiris
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.18 2005/08/01 05:36:49 brad Exp $ */
d61 1
a61 1
#include <sys/select.h>
@


1.18
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.17 2004/07/11 12:16:46 deraadt Exp $ */
a124 1
Static void	*umodem_get_desc(usbd_device_handle dev, int type, int subtype);
a129 2
Static void	umodem_get_caps(usbd_device_handle, int *, int *);

d160 1
a160 1
	int cm, acm, ret;
a181 9
	if (ret == UMATCH_NONE)
		return (ret);

	umodem_get_caps(uaa->device, &cm, &acm);
	if (!(cm & USB_CDC_CM_DOES_CM) ||
	    !(cm & USB_CDC_CM_OVER_DATA) ||
	    !(acm & USB_CDC_ACM_HAS_LINE))
		return (UMATCH_NONE);

d191 6
a196 1
	usb_cdc_cm_descriptor_t *cmd;
d199 1
a199 1
	int data_ifcno;
d215 32
a246 1
	umodem_get_caps(dev, &sc->sc_cm_cap, &sc->sc_acm_cap);
d248 3
a250 4
	/* Get the data interface no. */
	cmd = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_CM);
	if (cmd == NULL) {
		printf("%s: no CM descriptor\n", USBDEVNAME(sc->sc_dev));
a252 1
	sc->sc_data_iface_no = data_ifcno = cmd->bDataInterface;
d255 1
a255 1
	       USBDEVNAME(sc->sc_dev), data_ifcno,
d263 2
a264 1
			if (id != NULL && id->bInterfaceNumber == data_ifcno) {
a483 23
umodem_get_caps(usbd_device_handle dev, int *cm, int *acm)
{
	usb_cdc_cm_descriptor_t *cmd;
	usb_cdc_acm_descriptor_t *cad;

	*cm = *acm = 0;

	cmd = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_CM);
	if (cmd == NULL) {
		DPRINTF(("umodem_get_desc: no CM desc\n"));
		return;
	}
	*cm = cmd->bmCapabilities;

	cad = umodem_get_desc(dev, UDESC_CS_INTERFACE, UDESCSUB_CDC_ACM);
	if (cad == NULL) {
		DPRINTF(("umodem_get_desc: no ACM desc\n"));
		return;
	}
	*acm = cad->bmCapabilities;
}

void
a683 19
}

void *
umodem_get_desc(usbd_device_handle dev, int type, int subtype)
{
	usb_descriptor_t *desc;
	usb_config_descriptor_t *cd = usbd_get_config_descriptor(dev);
        uByte *p = (uByte *)cd;
        uByte *end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type &&
		    desc->bDescriptorSubtype == subtype)
			return (desc);
		p += desc->bLength;
	}

	return (0);
@


1.17
log
@special case of a non-CDC_AT device tha belongs here; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.16 2004/07/08 22:18:44 deraadt Exp $ */
d204 1
a204 1
	char devinfo[1024];
d210 1
a210 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d218 2
a219 1
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
@


1.16
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.15 2003/11/07 11:10:47 jmc Exp $ */
d162 2
a163 1
	int cm, acm;
d169 2
a170 4
	if (id == NULL ||
	    id->bInterfaceClass != UICLASS_CDC ||
	    id->bInterfaceSubClass != UISUBCLASS_ABSTRACT_CONTROL_MODEL ||
	    id->bInterfaceProtocol != UIPROTO_CDC_AT)
d173 15
d194 1
a194 1
	return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
@


1.15
log
@updated URLs from Jared Yanovich;

however, I did not apply the diff exactly. After hunting around I
found URLs for the missing files, and the ../index.html link appears
not to work. I replaced it with a more suitable link.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.14 2003/05/07 04:33:33 deraadt Exp $ */
d79 1
a79 1
#define DPRINTFN(n, x)	if (umodemdebug > (n)) logprintf x
@


1.14
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.13 2002/11/11 02:32:32 nate Exp $ */
d42 2
a43 2
 * Comm Class spec:  http://www.usb.org/developers/data/devclass/usbcdc10.pdf
 *                   http://www.usb.org/developers/data/devclass/usbcdc11.pdf
@


1.13
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.12 2002/07/25 04:07:33 nate Exp $ */
d196 1
a196 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.12
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.11 2002/07/25 02:18:11 nate Exp $ */
/*	$NetBSD: umodem.c,v 1.44 2002/07/11 21:14:33 augustss Exp $ */
a725 1
		break;
@


1.11
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.10 2002/06/11 02:59:15 nate Exp $ */
/*	$NetBSD: umodem.c,v 1.41 2001/11/13 06:24:56 lukem Exp $	*/
@


1.10
log
@use usb_proc_ptr.  (From NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.9 2002/05/07 18:29:18 nate Exp $ */
d237 2
a238 2
	/* 
	 * Find the bulk endpoints. 
d466 1
a466 1
} 
d534 1
a534 1
 
d661 1
a661 1
		DPRINTF(("umodem_set_line_coding: failed, err=%s\n", 
@


1.9
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.7 2001/05/03 02:20:34 aaron Exp $ */
/*	$NetBSD: umodem.c,v 1.40 2001/03/25 23:02:34 augustss Exp $	*/
d140 1
a140 1
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
d527 1
a527 1
	     struct proc *p)
@


1.8
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: umodem.c,v 1.41 2001/11/13 06:24:56 lukem Exp $	*/
d140 1
a140 1
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d527 1
a527 1
	     usb_proc_ptr p)
@


1.7
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.6 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: umodem.c,v 1.40 2001/03/25 23:02:34 augustss Exp $	*/
d140 1
a140 1
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, struct proc *);
d527 1
a527 1
	     struct proc *p)
@


1.7.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.7 2001/05/03 02:20:34 aaron Exp $ */
@


1.7.6.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umodem.c,v 1.44 2002/07/11 21:14:33 augustss Exp $ */
d140 1
a140 1
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d237 2
a238 2
	/*
	 * Find the bulk endpoints.
d466 1
a466 1
}
d527 1
a527 1
	     usb_proc_ptr p)
d534 1
a534 1

d661 1
a661 1
		DPRINTF(("umodem_set_line_coding: failed, err=%s\n",
@


1.7.6.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: umodem.c,v 1.45 2002/09/23 05:51:23 simonb Exp $	*/
d196 1
a196 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d726 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: umodem.c,v 1.31 2000/10/22 08:20:09 explorer Exp $	*/
d117 6
d141 3
d150 2
a151 2
	NULL,
	NULL,
a221 1

d288 25
d325 4
a332 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d340 105
d471 2
d476 1
a476 1
		*lsr = 0;	/* XXX */
d478 1
a478 1
		*msr = 0;	/* XXX */
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umodem.c,v 1.40 2001/03/25 23:02:34 augustss Exp $	*/
a116 6

	int			sc_ctl_notify;	/* Notification endpoint */
	usbd_pipe_handle	sc_notify_pipe; /* Notification pipe */
	usb_cdc_notification_t	sc_notify_buf;	/* Notification structure */
	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* Modem status register */
a134 3
Static int	umodem_open(void *, int portno);
Static void	umodem_close(void *, int portno);
Static void	umodem_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d141 2
a142 2
	umodem_open,
	umodem_close,
d213 1
a279 25

	/*
	 * The standard allows for notification messages (to indicate things
	 * like a modem hangup) to come in via an interrupt endpoint
	 * off of the control interface.  Iterate over the endpoints on
	 * the control interface and see if there are any interrupt
	 * endpoints; if there are, then register it.
	 */

	sc->sc_ctl_notify = -1;
	sc->sc_notify_pipe = NULL;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_ctl_iface, i);
		if (ed == NULL)
			continue;

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    (ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT) {
			printf("%s: status change notification available\n",
			       USBDEVNAME(sc->sc_dev));
			sc->sc_ctl_notify = ed->bEndpointAddress;
		}
	}

d292 3
a294 1
	uca.info = NULL;
a298 3
	DPRINTF(("umodem_attach: sc=%p\n", sc));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);

a305 105
Static int
umodem_open(void *addr, int portno)
{
	struct umodem_softc *sc = addr;
	int err;

	DPRINTF(("umodem_open: sc=%p\n", sc));

	if (sc->sc_ctl_notify != -1 && sc->sc_notify_pipe == NULL) {
		err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_ctl_notify,
		    USBD_SHORT_XFER_OK, &sc->sc_notify_pipe, sc,
		    &sc->sc_notify_buf, sizeof(sc->sc_notify_buf),
		    umodem_intr, USBD_DEFAULT_INTERVAL);

		if (err) {
			DPRINTF(("Failed to establish notify pipe: %s\n",
				usbd_errstr(err)));
			return EIO;
		}
	}

	return 0;
}

Static void
umodem_close(void *addr, int portno)
{
	struct umodem_softc *sc = addr;
	int err;

	DPRINTF(("umodem_close: sc=%p\n", sc));

	if (sc->sc_notify_pipe != NULL) {
		err = usbd_abort_pipe(sc->sc_notify_pipe);
		if (err)
			printf("%s: abort notify pipe failed: %s\n",
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		err = usbd_close_pipe(sc->sc_notify_pipe);
		if (err)
			printf("%s: close notify pipe failed: %s\n",
			    USBDEVNAME(sc->sc_dev), usbd_errstr(err));
		sc->sc_notify_pipe = NULL;
	}
}

Static void
umodem_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
{
	struct umodem_softc *sc = priv;
	u_char mstatus;

	if (sc->sc_dying)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		printf("%s: abnormal status: %s\n", USBDEVNAME(sc->sc_dev),
		       usbd_errstr(status));
		return;
	}

	if (sc->sc_notify_buf.bmRequestType != UCDC_NOTIFICATION) {
		DPRINTF(("%s: unknown message type (%02x) on notify pipe\n",
			 USBDEVNAME(sc->sc_dev),
			 sc->sc_notify_buf.bmRequestType));
		return;
	}

	switch (sc->sc_notify_buf.bNotification) {
	case UCDC_N_SERIAL_STATE:
		/*
		 * Set the serial state in ucom driver based on
		 * the bits from the notify message
		 */
		if (UGETW(sc->sc_notify_buf.wLength) != 2) {
			printf("%s: Invalid notification length! (%d)\n",
			       USBDEVNAME(sc->sc_dev),
			       UGETW(sc->sc_notify_buf.wLength));
			break;
		}
		DPRINTF(("%s: notify bytes = %02x%02x\n",
			 USBDEVNAME(sc->sc_dev),
			 sc->sc_notify_buf.data[0],
			 sc->sc_notify_buf.data[1]));
		/* Currently, lsr is always zero. */
		sc->sc_lsr = sc->sc_msr = 0;
		mstatus = sc->sc_notify_buf.data[0];

		if (ISSET(mstatus, UCDC_N_SERIAL_RI))
			sc->sc_msr |= UMSR_RI;
		if (ISSET(mstatus, UCDC_N_SERIAL_DSR))
			sc->sc_msr |= UMSR_DSR;
		if (ISSET(mstatus, UCDC_N_SERIAL_DCD))
			sc->sc_msr |= UMSR_DCD;
		ucom_status_change((struct ucom_softc *)sc->sc_subdev);
		break;
	default:
		DPRINTF(("%s: unknown notify message: %02x\n",
			 USBDEVNAME(sc->sc_dev),
			 sc->sc_notify_buf.bNotification));
		break;
	}
}

a331 2
	struct umodem_softc *sc = addr;

d335 1
a335 1
		*lsr = sc->sc_lsr;
d337 1
a337 1
		*msr = sc->sc_msr;
@


1.7.2.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: umodem.c,v 1.45 2002/09/23 05:51:23 simonb Exp $	*/
d140 1
a140 1
Static int	umodem_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
d237 2
a238 2
	/*
	 * Find the bulk endpoints.
d466 1
a466 1
}
d527 1
a527 1
	     usb_proc_ptr p)
d534 1
a534 1

d661 1
a661 1
		DPRINTF(("umodem_set_line_coding: failed, err=%s\n",
d726 1
@


1.7.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.7.2.3 2003/03/28 00:38:32 niklas Exp $ */
d196 1
a196 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.7.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d42 2
a43 2
 * Comm Class spec:  http://www.usb.org/developers/devclass_docs/usbccs10.pdf
 *                   http://www.usb.org/developers/devclass_docs/usbcdc11.pdf
@


1.6
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.5 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: umodem.c,v 1.31 2000/10/22 08:20:09 explorer Exp $	*/
d117 6
d141 3
d150 2
a151 2
	NULL,
	NULL,
a221 1

d288 25
d325 4
a332 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d340 105
d471 2
d476 1
a476 1
		*lsr = 0;	/* XXX */
d478 1
a478 1
		*msr = 0;	/* XXX */
@


1.5
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.4 2000/07/04 11:44:24 fgsch Exp $ */
d42 2
a43 1
 * Comm Class spec: http://www.usb.org/developers/data/usbcdc11.pdf
d267 5
a271 2
			err = umodem_set_comm_feature(sc, UCDC_ABSTRACT_STATE,
						      UCDC_DATA_MULTIPLEXED);
@


1.4
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: umodem.c,v 1.3 2000/04/14 22:50:28 aaron Exp $ */
/*	$NetBSD: umodem.c,v 1.27 2000/04/14 14:21:55 augustss Exp $	*/
d118 16
a133 19
Static void	*umodem_get_desc
		__P((usbd_device_handle dev, int type, int subtype));
Static usbd_status umodem_set_comm_feature
		__P((struct umodem_softc *sc, int feature, int state));
Static usbd_status umodem_set_line_coding
		__P((struct umodem_softc *sc, usb_cdc_line_state_t *state));

Static void	umodem_get_caps	__P((usbd_device_handle, int *, int *));

Static void	umodem_get_status
		__P((void *, int portno, u_char *lsr, u_char *msr));
Static void	umodem_set	__P((void *, int, int, int));
Static void	umodem_dtr	__P((struct umodem_softc *, int));
Static void	umodem_rts	__P((struct umodem_softc *, int));
Static void	umodem_break	__P((struct umodem_softc *, int));
Static void	umodem_set_line_state __P((struct umodem_softc *));
Static int	umodem_param	__P((void *, int, struct termios *));
Static int	umodem_ioctl	__P((void *, int, u_long, caddr_t, int,
				     struct proc *));
d153 1
a153 1
	
d163 1
a163 1
	
d262 12
a273 7
	if (sc->sc_cm_cap & USB_CDC_CM_OVER_DATA) {
		err = umodem_set_comm_feature(sc, UCDC_ABSTRACT_STATE,
					      UCDC_DATA_MULTIPLEXED);
		if (err) {
			printf("%s: could not set data multiplex mode\n",
			       USBDEVNAME(sc->sc_dev));
			goto bad;
a274 1
		sc->sc_cm_over_data = 1;
a275 1

d283 1
a283 1
	uca.obufsizepad = UMODEMOBUFSIZE;
d303 1
a303 3
umodem_get_caps(dev, cm, acm)
	usbd_device_handle dev;
	int *cm, *acm;
d326 1
a326 4
umodem_get_status(addr, portno, lsr, msr)
	void *addr;
	int portno;
	u_char *lsr, *msr;
d337 1
a337 4
umodem_param(addr, portno, t)
	void *addr;
	int portno;
	struct termios *t;
d381 2
a382 7
umodem_ioctl(addr, portno, cmd, data, flag, p)
	void *addr;
	int portno;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d413 1
a413 3
umodem_dtr(sc, onoff)
	struct umodem_softc *sc;
	int onoff;
d425 1
a425 3
umodem_rts(sc, onoff)
	struct umodem_softc *sc;
	int onoff;
d437 1
a437 2
umodem_set_line_state(sc)
	struct umodem_softc *sc;
d455 1
a455 3
umodem_break(sc, onoff)
	struct umodem_softc *sc;
	int onoff;
d474 1
a474 5
umodem_set(addr, portno, reg, onoff)
	void *addr;
	int portno;
	int reg;
	int onoff;
d494 1
a494 3
umodem_set_line_coding(sc, state)
	struct umodem_softc *sc;
	usb_cdc_line_state_t *state;
d527 1
a527 4
umodem_get_desc(dev, type, subtype)
	usbd_device_handle dev;
	int type;
	int subtype;
d546 1
a546 4
umodem_set_comm_feature(sc, feature, state)
	struct umodem_softc *sc;
	int feature;
	int state;
d573 1
a573 3
umodem_activate(self, act)
	device_ptr_t self;
	enum devact act;
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: umodem.c,v 1.2 2000/04/08 20:03:34 aaron Exp $ */
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.2
log
@Add RCSids.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: umodem.c,v 1.25 2000/03/27 12:33:57 augustss Exp $	*/
d85 8
d145 2
d280 4
d497 1
@


1.1
log
@Add USB modem driver stubs; from NetBSD. Not yet tested.
@
text
@d1 1
@

