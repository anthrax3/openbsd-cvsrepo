head	1.113;
access;
symbols
	OPENBSD_6_1:1.111.0.6
	OPENBSD_6_1_BASE:1.111
	OPENBSD_6_0:1.111.0.4
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.109.0.2
	OPENBSD_5_9_BASE:1.109
	OPENBSD_5_8:1.107.0.4
	OPENBSD_5_8_BASE:1.107
	OPENBSD_5_7:1.106.0.2
	OPENBSD_5_7_BASE:1.106
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.93.0.4
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.92.0.2
	OPENBSD_5_4_BASE:1.92
	OPENBSD_5_3:1.81.0.4
	OPENBSD_5_3_BASE:1.81
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.79
	OPENBSD_5_1:1.79.0.2
	OPENBSD_5_0:1.77.0.2
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.62.0.4
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.58.0.6
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.57.0.2
	OPENBSD_4_4_BASE:1.57
	OPENBSD_4_3:1.56.0.4
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.33.0.4
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.30.0.4
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.29.0.4
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.16.0.4
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.23
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.113
date	2017.07.21.20.13.41;	author ians;	state Exp;
branches;
next	1.112;
commitid	gv3Xov7L0BpjRczA;

1.112
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	6s3MfY9d6ZKdL2Uz;

1.111
date	2016.05.18.18.28.58;	author patrick;	state Exp;
branches;
next	1.110;
commitid	SQX964uLUjZqy5aw;

1.110
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.109;
commitid	KhGZngmPmcr1rX2x;

1.109
date	2016.01.22.13.31.47;	author bluhm;	state Exp;
branches;
next	1.108;
commitid	IVdGrfMcgNfzLA8O;

1.108
date	2015.09.01.10.00.26;	author mpi;	state Exp;
branches;
next	1.107;
commitid	1AdK1ZeQE5rp5KXt;

1.107
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.106;
commitid	p4LJxGKbi0BU2cG6;

1.106
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.105;
commitid	C5iGb36LQxjM60Q3;

1.105
date	2015.02.09.12.45.12;	author uebayasi;	state Exp;
branches;
next	1.104;
commitid	MBdFMiVc9NiIoShi;

1.104
date	2015.01.13.16.03.18;	author mpi;	state Exp;
branches;
next	1.103;
commitid	frP0H8qEVVVl3Zqj;

1.103
date	2014.12.18.10.44.17;	author mpi;	state Exp;
branches;
next	1.102;
commitid	jE3DJAWNka7o2UPE;

1.102
date	2014.08.10.11.18.57;	author mpi;	state Exp;
branches;
next	1.101;
commitid	soKLg6qedOsGZg3L;

1.101
date	2014.08.09.09.45.14;	author mpi;	state Exp;
branches;
next	1.100;
commitid	MwiYUakpkX4F7pXj;

1.100
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.99;
commitid	OBNa5kfxQ2UXoiIw;

1.99
date	2014.07.11.08.43.38;	author mpi;	state Exp;
branches;
next	1.98;
commitid	NeaB0285VPRjKSLw;

1.98
date	2014.07.09.18.15.04;	author mpi;	state Exp;
branches;
next	1.97;
commitid	7bxb660ER7iHPxAL;

1.97
date	2014.05.28.11.20.55;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2014.05.11.16.33.21;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.31.16.18.06;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2014.03.08.11.49.19;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2013.12.06.21.03.05;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2013.05.17.09.09.11;	author mpi;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.26.14.05.24;	author mpi;	state Exp;
branches;
next	1.89;

1.89
date	2013.04.19.19.07.45;	author mglocker;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.18.08.44.39;	author mglocker;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.17.11.53.10;	author mglocker;	state Exp;
branches;
next	1.86;

1.86
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.85;

1.85
date	2013.04.08.10.34.20;	author mglocker;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2013.03.28.03.31.56;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2013.03.16.09.58.40;	author mpi;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.15.12.48.32;	author mpi;	state Exp;
branches;
next	1.80;

1.80
date	2012.05.12.17.27.44;	author mpi;	state Exp;
branches;
next	1.79;

1.79
date	2012.01.28.00.40.23;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2011.09.18.23.24.12;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.28.07.35.15;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2011.02.09.20.24.39;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2011.02.09.04.25.32;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2011.02.04.08.21.39;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.15.23.58.43;	author jakemsr;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.06.04.28.41;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2010.09.23.06.30.37;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.23.05.44.15;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.23.05.28.57;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.23.04.58.02;	author jakemsr;	state Exp;
branches;
next	1.64;

1.64
date	2010.09.23.00.46.08;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.31.16.38.42;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.61;

1.61
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2008.12.09.03.08.07;	author yuo;	state Exp;
branches;
next	1.57;

1.57
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.11.12.36.52;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.11.09.26.55;	author mk;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.10.17.46.27;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.10.15.33.16;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.22.05.45.57;	author pascoe;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.18.06.00.45;	author pascoe;	state Exp;
branches;
next	1.35;

1.35
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2006.09.18.10.55.51;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.11.09.09.21;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.12.05.17.40;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.07.11.10.47;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.11.03.11.17;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.10.21.41.51;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.04.11.44.24;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.26.21.47.51;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.11.11.15.57.40;	author ho;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.59;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Do not permit USB ioctl handler malloc(9)'s to block as this interferes
with expected behavior.

OK mpi@@ patrick@@
@
text
@/*	$OpenBSD: usb.c,v 1.112 2017/04/08 02:57:25 deraadt Exp $	*/
/*	$NetBSD: usb.c,v 1.77 2003/01/01 00:10:26 thorpej Exp $	*/

/*
 * Copyright (c) 1998, 2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB specifications and other documentation can be found at
 * http://www.usb.org/developers/docs/ and
 * http://www.usb.org/developers/devclass_docs/
 */

#include "ohci.h"
#include "uhci.h"
#include "ehci.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/kthread.h>
#include <sys/conf.h>
#include <sys/fcntl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>
#include <sys/signalvar.h>
#include <sys/time.h>
#include <sys/rwlock.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <machine/bus.h>

#include <dev/usb/usbdivar.h>

#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (usbdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) printf x; } while (0)
int	usbdebug = 0;
#if defined(UHCI_DEBUG) && NUHCI > 0
extern int	uhcidebug;
#endif
#if defined(OHCI_DEBUG) && NOHCI > 0
extern int	ohcidebug;
#endif
#if defined(EHCI_DEBUG) && NEHCI > 0
extern int	ehcidebug;
#endif
/*
 * 0  - do usual exploration
 * !0 - do no exploration
 */
int	usb_noexplore = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct usb_softc {
	struct device	 sc_dev;	/* base device */
	struct usbd_bus  *sc_bus;	/* USB controller */
	struct usbd_port sc_port;	/* dummy port for root hub */
	int		 sc_speed;

	struct usb_task	 sc_explore_task;

	struct timeval	 sc_ptime;
};

struct rwlock usbpalock;

TAILQ_HEAD(, usb_task) usb_abort_tasks;
TAILQ_HEAD(, usb_task) usb_explore_tasks;
TAILQ_HEAD(, usb_task) usb_generic_tasks;

static int usb_nbuses = 0;
static int usb_run_tasks, usb_run_abort_tasks;
int explore_pending;
const char *usbrev_str[] = USBREV_STR;

void		 usb_explore(void *);
void		 usb_create_task_threads(void *);
void		 usb_task_thread(void *);
struct proc	*usb_task_thread_proc = NULL;
void		 usb_abort_task_thread(void *);
struct proc	*usb_abort_task_thread_proc = NULL;

void		 usb_fill_di_task(void *);
void		 usb_fill_udc_task(void *);
void		 usb_fill_udf_task(void *);

int		 usb_match(struct device *, void *, void *);
void		 usb_attach(struct device *, struct device *, void *);
int		 usb_detach(struct device *, int);
int		 usb_activate(struct device *, int);

int		 usb_attach_roothub(struct usb_softc *);
void		 usb_detach_roothub(struct usb_softc *);

struct cfdriver usb_cd = {
	NULL, "usb", DV_DULL
};

const struct cfattach usb_ca = {
	sizeof(struct usb_softc), usb_match, usb_attach, usb_detach,
	usb_activate,
};

int
usb_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
usb_attach(struct device *parent, struct device *self, void *aux)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	int usbrev;

	if (usb_nbuses == 0) {
		rw_init(&usbpalock, "usbpalock");
		TAILQ_INIT(&usb_abort_tasks);
		TAILQ_INIT(&usb_explore_tasks);
		TAILQ_INIT(&usb_generic_tasks);
		usb_run_tasks = usb_run_abort_tasks = 1;
		kthread_create_deferred(usb_create_task_threads, NULL);
	}
	usb_nbuses++;

	sc->sc_bus = aux;
	sc->sc_bus->usbctl = self;
	sc->sc_port.power = USB_MAX_POWER;

	usbrev = sc->sc_bus->usbrev;
	printf(": USB revision %s", usbrev_str[usbrev]);
	switch (usbrev) {
	case USBREV_1_0:
	case USBREV_1_1:
		sc->sc_speed = USB_SPEED_FULL;
		break;
	case USBREV_2_0:
		sc->sc_speed = USB_SPEED_HIGH;
		break;
	case USBREV_3_0:
		sc->sc_speed = USB_SPEED_SUPER;
		break;
	default:
		printf(", not supported\n");
		sc->sc_bus->dying = 1;
		return;
	}
	printf("\n");

	/* Make sure not to use tsleep() if we are cold booting. */
	if (cold)
		sc->sc_bus->use_polling++;

	/* Don't let hub interrupts cause explore until ready. */
	sc->sc_bus->flags |= USB_BUS_CONFIG_PENDING;

	/* explore task */
	usb_init_task(&sc->sc_explore_task, usb_explore, sc,
	    USB_TASK_TYPE_EXPLORE);

	sc->sc_bus->soft = softintr_establish(IPL_SOFTUSB,
	    sc->sc_bus->methods->soft_intr, sc->sc_bus);
	if (sc->sc_bus->soft == NULL) {
		printf("%s: can't register softintr\n", sc->sc_dev.dv_xname);
		sc->sc_bus->dying = 1;
		return;
	}

	if (!usb_attach_roothub(sc)) {
		struct usbd_device *dev = sc->sc_bus->root_hub;
#if 1
		/*
		 * Turning this code off will delay attachment of USB devices
		 * until the USB task thread is running, which means that
		 * the keyboard will not work until after cold boot.
		 */
		if (cold && (sc->sc_dev.dv_cfdata->cf_flags & 1))
			dev->hub->explore(sc->sc_bus->root_hub);
#endif
	}

	if (cold)
		sc->sc_bus->use_polling--;

	if (!sc->sc_bus->dying) {
		getmicrouptime(&sc->sc_ptime);
		if (sc->sc_bus->usbrev == USBREV_2_0)
			explore_pending++;
		config_pending_incr();
		usb_needs_explore(sc->sc_bus->root_hub, 1);
	}
}

int
usb_attach_roothub(struct usb_softc *sc)
{
	struct usbd_device *dev;

	if (usbd_new_device(&sc->sc_dev, sc->sc_bus, 0, sc->sc_speed, 0,
	    &sc->sc_port)) {
		printf("%s: root hub problem\n", sc->sc_dev.dv_xname);
		sc->sc_bus->dying = 1;
		return (1);
	}

	dev = sc->sc_port.device;
	if (dev->hub == NULL) {
		printf("%s: root device is not a hub\n", sc->sc_dev.dv_xname);
		sc->sc_bus->dying = 1;
		return (1);
	}
	sc->sc_bus->root_hub = dev;

	return (0);
}

void
usb_detach_roothub(struct usb_softc *sc)
{
	/*
	 * To avoid races with the usb task thread, mark the root hub
	 * as disconnecting and schedule an exploration task to detach
	 * it.
	 */
	sc->sc_bus->flags |= USB_BUS_DISCONNECTING;
	/*
	 * Reset the dying flag in case it has been set by the interrupt
	 * handler when unplugging an HC card otherwise the task wont be
	 * scheduled.  This is safe since a dead HC should not trigger
	 * new interrupt.
	 */
	sc->sc_bus->dying = 0;
	usb_needs_explore(sc->sc_bus->root_hub, 0);

	usb_wait_task(sc->sc_bus->root_hub, &sc->sc_explore_task);

	sc->sc_bus->root_hub = NULL;
}

void
usb_create_task_threads(void *arg)
{
	if (kthread_create(usb_abort_task_thread, NULL,
	    &usb_abort_task_thread_proc, "usbatsk"))
		panic("unable to create usb abort task thread");

	if (kthread_create(usb_task_thread, NULL,
	    &usb_task_thread_proc, "usbtask"))
		panic("unable to create usb task thread");
}

/*
 * Add a task to be performed by the task thread.  This function can be
 * called from any context and the task will be executed in a process
 * context ASAP.
 */
void
usb_add_task(struct usbd_device *dev, struct usb_task *task)
{
	int s;

	/*
	 * If the thread detaching ``dev'' is sleeping, waiting
	 * for all submitted transfers to finish, we must be able
	 * to enqueue abort tasks.  Otherwise timeouts can't give
	 * back submitted transfers to the stack.
	 */
	if (usbd_is_dying(dev) && (task->type != USB_TASK_TYPE_ABORT))
		return;

	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

	s = splusb();
	if (!(task->state & USB_TASK_STATE_ONQ)) {
		switch (task->type) {
		case USB_TASK_TYPE_ABORT:
			TAILQ_INSERT_TAIL(&usb_abort_tasks, task, next);
			break;
		case USB_TASK_TYPE_EXPLORE:
			TAILQ_INSERT_TAIL(&usb_explore_tasks, task, next);
			break;
		case USB_TASK_TYPE_GENERIC:
			TAILQ_INSERT_TAIL(&usb_generic_tasks, task, next);
			break;
		}
		task->state |= USB_TASK_STATE_ONQ;
		task->dev = dev;
	}
	if (task->type == USB_TASK_TYPE_ABORT)
		wakeup(&usb_run_abort_tasks);
	else
		wakeup(&usb_run_tasks);
	splx(s);
}

void
usb_rem_task(struct usbd_device *dev, struct usb_task *task)
{
	int s;

	if (!(task->state & USB_TASK_STATE_ONQ))
		return;

	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

	s = splusb();

	switch (task->type) {
	case USB_TASK_TYPE_ABORT:
		TAILQ_REMOVE(&usb_abort_tasks, task, next);
		break;
	case USB_TASK_TYPE_EXPLORE:
		TAILQ_REMOVE(&usb_explore_tasks, task, next);
		break;
	case USB_TASK_TYPE_GENERIC:
		TAILQ_REMOVE(&usb_generic_tasks, task, next);
		break;
	}
	task->state &= ~USB_TASK_STATE_ONQ;
	if (task->state == USB_TASK_STATE_NONE)
		wakeup(task);

	splx(s);
}

void
usb_wait_task(struct usbd_device *dev, struct usb_task *task)
{
	int s;

	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

	if (task->state == USB_TASK_STATE_NONE)
		return;

	s = splusb();
	while (task->state != USB_TASK_STATE_NONE) {
		DPRINTF(("%s: waiting for task to complete\n", __func__));
		tsleep(task, PWAIT, "endtask", 0);
	}
	splx(s);
}

void
usb_rem_wait_task(struct usbd_device *dev, struct usb_task *task)
{
	usb_rem_task(dev, task);
	usb_wait_task(dev, task);
}

void
usb_task_thread(void *arg)
{
	struct usb_task *task;
	int s;

	DPRINTF(("usb_task_thread: start\n"));

	s = splusb();
	while (usb_run_tasks) {
		if ((task = TAILQ_FIRST(&usb_explore_tasks)) != NULL)
			TAILQ_REMOVE(&usb_explore_tasks, task, next);
		else if ((task = TAILQ_FIRST(&usb_generic_tasks)) != NULL)
			TAILQ_REMOVE(&usb_generic_tasks, task, next);
		else {
			tsleep(&usb_run_tasks, PWAIT, "usbtsk", 0);
			continue;
		}
		/*
		 * Set the state run bit before clearing the onq bit.
		 * This avoids state == none between dequeue and
		 * execution, which could cause usb_wait_task() to do
		 * the wrong thing.
		 */
		task->state |= USB_TASK_STATE_RUN;
		task->state &= ~USB_TASK_STATE_ONQ;
		/* Don't actually execute the task if dying. */
		if (!usbd_is_dying(task->dev)) {
			splx(s);
			task->fun(task->arg);
			s = splusb();
		}
		task->state &= ~USB_TASK_STATE_RUN;
		if (task->state == USB_TASK_STATE_NONE)
			wakeup(task);
	}
	splx(s);

	kthread_exit(0);
}

/*
 * This thread is ONLY for the HCI drivers to be able to abort xfers.
 * Synchronous xfers sleep the task thread, so the aborts need to happen
 * in a different thread.
 */
void
usb_abort_task_thread(void *arg)
{
	struct usb_task *task;
	int s;

	DPRINTF(("usb_xfer_abort_thread: start\n"));

	s = splusb();
	while (usb_run_abort_tasks) {
		if ((task = TAILQ_FIRST(&usb_abort_tasks)) != NULL)
			TAILQ_REMOVE(&usb_abort_tasks, task, next);
		else {
			tsleep(&usb_run_abort_tasks, PWAIT, "usbatsk", 0);
			continue;
		}
		/*
		 * Set the state run bit before clearing the onq bit.
		 * This avoids state == none between dequeue and
		 * execution, which could cause usb_wait_task() to do
		 * the wrong thing.
		 */
		task->state |= USB_TASK_STATE_RUN;
		task->state &= ~USB_TASK_STATE_ONQ;
		splx(s);
		task->fun(task->arg);
		s = splusb();
		task->state &= ~USB_TASK_STATE_RUN;
		if (task->state == USB_TASK_STATE_NONE)
			wakeup(task);
	}
	splx(s);

	kthread_exit(0);
}

int
usbctlprint(void *aux, const char *pnp)
{
	/* only "usb"es can attach to host controllers */
	if (pnp)
		printf("usb at %s", pnp);

	return (UNCONF);
}

int
usbopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = minor(dev);
	struct usb_softc *sc;

	if (unit >= usb_cd.cd_ndevs)
		return (ENXIO);
	sc = usb_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_bus->dying)
		return (EIO);

	return (0);
}

int
usbclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

void
usb_fill_di_task(void *arg)
{
	struct usb_device_info *di = (struct usb_device_info *)arg;
	struct usb_softc *sc;
	struct usbd_device *dev;

	/* check that the bus and device are still present */
	if (di->udi_bus >= usb_cd.cd_ndevs)
		return;
	sc = usb_cd.cd_devs[di->udi_bus];
	if (sc == NULL)
		return;
	dev = sc->sc_bus->devices[di->udi_addr];
	if (dev == NULL)
		return;

	usbd_fill_deviceinfo(dev, di, 0);
}

void
usb_fill_udc_task(void *arg)
{
	struct usb_device_cdesc *udc = (struct usb_device_cdesc *)arg;
	struct usb_softc *sc;
	struct usbd_device *dev;
	int addr = udc->udc_addr;
	usb_config_descriptor_t *cdesc;

	/* check that the bus and device are still present */
	if (udc->udc_bus >= usb_cd.cd_ndevs)
		return;
	sc = usb_cd.cd_devs[udc->udc_bus];
	if (sc == NULL)
		return;
	dev = sc->sc_bus->devices[udc->udc_addr];
	if (dev == NULL)
		return;

	cdesc = usbd_get_cdesc(sc->sc_bus->devices[addr],
	    udc->udc_config_index, 0);
	if (cdesc == NULL)
		return;
	udc->udc_desc = *cdesc;
	free(cdesc, M_TEMP, 0);
}

void
usb_fill_udf_task(void *arg)
{
	struct usb_device_fdesc *udf = (struct usb_device_fdesc *)arg;
	struct usb_softc *sc;
	struct usbd_device *dev;
	int addr = udf->udf_addr;
	usb_config_descriptor_t *cdesc;

	/* check that the bus and device are still present */
	if (udf->udf_bus >= usb_cd.cd_ndevs)
		return;
	sc = usb_cd.cd_devs[udf->udf_bus];
	if (sc == NULL)
		return;
	dev = sc->sc_bus->devices[udf->udf_addr];
	if (dev == NULL)
		return;

	cdesc = usbd_get_cdesc(sc->sc_bus->devices[addr],
	    udf->udf_config_index, &udf->udf_size);
	udf->udf_data = (char *)cdesc;
}

int
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct usb_softc *sc;
	int unit = minor(devt);
	int error;

	sc = usb_cd.cd_devs[unit];

	if (sc->sc_bus->dying)
		return (EIO);

	error = 0;
	switch (cmd) {
#ifdef USB_DEBUG
	case USB_SETDEBUG:
		/* only root can access to these debug flags */
		if ((error = suser(curproc, 0)) != 0)
			return (error);
		if (!(flag & FWRITE))
			return (EBADF);
		usbdebug  = ((*(unsigned int *)data) & 0x000000ff);
#if defined(UHCI_DEBUG) && NUHCI > 0
		uhcidebug = ((*(unsigned int *)data) & 0x0000ff00) >> 8;
#endif
#if defined(OHCI_DEBUG) && NOHCI > 0
		ohcidebug = ((*(unsigned int *)data) & 0x00ff0000) >> 16;
#endif
#if defined(EHCI_DEBUG) && NEHCI > 0
		ehcidebug = ((*(unsigned int *)data) & 0xff000000) >> 24;
#endif
		break;
#endif /* USB_DEBUG */
	case USB_REQUEST:
	{
		struct usb_ctl_request *ur = (void *)data;
		size_t len = UGETW(ur->ucr_request.wLength), mlen;
		struct iovec iov;
		struct uio uio;
		void *ptr = NULL;
		int addr = ur->ucr_addr;
		usbd_status err;
		int error = 0;

		if (!(flag & FWRITE))
			return (EBADF);

		DPRINTF(("usbioctl: USB_REQUEST addr=%d len=%zu\n", addr, len));
		/* Avoid requests that would damage the bus integrity. */
		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
			return (EINVAL);

		if (len > 32767)
			return (EINVAL);
		if (addr < 0 || addr >= USB_MAX_DEVICES)
			return (EINVAL);
		if (sc->sc_bus->devices[addr] == NULL)
			return (ENXIO);
		if (len != 0) {
			iov.iov_base = (caddr_t)ur->ucr_data;
			iov.iov_len = len;
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_resid = len;
			uio.uio_offset = 0;
			uio.uio_segflg = UIO_USERSPACE;
			uio.uio_rw =
				ur->ucr_request.bmRequestType & UT_READ ?
				UIO_READ : UIO_WRITE;
			uio.uio_procp = p;
			if ((ptr = malloc(len, M_TEMP, M_NOWAIT)) == NULL) {
				error = ENOMEM;
				goto ret;
			}
			if (uio.uio_rw == UIO_WRITE) {
				error = uiomove(ptr, len, &uio);
				if (error)
					goto ret;
			}
		}
		err = usbd_do_request_flags(sc->sc_bus->devices[addr],
			  &ur->ucr_request, ptr, ur->ucr_flags,
			  &ur->ucr_actlen, USBD_DEFAULT_TIMEOUT);
		if (err) {
			error = EIO;
			goto ret;
		}
		/* Only if USBD_SHORT_XFER_OK is set. */
		mlen = len;
		if (mlen > ur->ucr_actlen)
			mlen = ur->ucr_actlen;
		if (mlen != 0) {
			if (uio.uio_rw == UIO_READ) {
				error = uiomove(ptr, mlen, &uio);
				if (error)
					goto ret;
			}
		}
	ret:
		if (ptr)
			free(ptr, M_TEMP, len);
		return (error);
	}

	case USB_DEVICEINFO:
	{
		struct usb_device_info *di = (void *)data;
		int addr = di->udi_addr;
		struct usb_task di_task;
		struct usbd_device *dev;

		if (addr < 1 || addr >= USB_MAX_DEVICES)
			return (EINVAL);

		dev = sc->sc_bus->devices[addr];
		if (dev == NULL)
			return (ENXIO);

		di->udi_bus = unit;

		/* All devices get a driver, thanks to ugen(4).  If the
		 * task ends without adding a driver name, there was an error.
		 */
		di->udi_devnames[0][0] = '\0';

		usb_init_task(&di_task, usb_fill_di_task, di,
		    USB_TASK_TYPE_GENERIC);
		usb_add_task(sc->sc_bus->root_hub, &di_task);
		usb_wait_task(sc->sc_bus->root_hub, &di_task);

		if (di->udi_devnames[0][0] == '\0')
			return (ENXIO);

		break;
	}

	case USB_DEVICESTATS:
		*(struct usb_device_stats *)data = sc->sc_bus->stats;
		break;

	case USB_DEVICE_GET_DDESC:
	{
		struct usb_device_ddesc *udd = (struct usb_device_ddesc *)data;
		int addr = udd->udd_addr;
		struct usbd_device *dev;

		if (addr < 1 || addr >= USB_MAX_DEVICES)
			return (EINVAL);

		dev = sc->sc_bus->devices[addr];
		if (dev == NULL)
			return (ENXIO);

		udd->udd_bus = unit;

		udd->udd_desc = *usbd_get_device_descriptor(dev);
		break;
	}

	case USB_DEVICE_GET_CDESC:
	{
		struct usb_device_cdesc *udc = (struct usb_device_cdesc *)data;
		int addr = udc->udc_addr;
		struct usb_task udc_task;

		if (addr < 1 || addr >= USB_MAX_DEVICES)
			return (EINVAL);
		if (sc->sc_bus->devices[addr] == NULL)
			return (ENXIO);

		udc->udc_bus = unit;

		udc->udc_desc.bLength = 0;
		usb_init_task(&udc_task, usb_fill_udc_task, udc,
		    USB_TASK_TYPE_GENERIC);
		usb_add_task(sc->sc_bus->root_hub, &udc_task);
		usb_wait_task(sc->sc_bus->root_hub, &udc_task);
		if (udc->udc_desc.bLength == 0)
			return (EINVAL);
		break;
	}

	case USB_DEVICE_GET_FDESC:
	{
		struct usb_device_fdesc *udf = (struct usb_device_fdesc *)data;
		int addr = udf->udf_addr;
		struct usb_task udf_task;
		struct usb_device_fdesc save_udf;
		usb_config_descriptor_t *cdesc;
		struct iovec iov;
		struct uio uio;
		size_t len;
		int error;

		if (addr < 1 || addr >= USB_MAX_DEVICES)
			return (EINVAL);
		if (sc->sc_bus->devices[addr] == NULL)
			return (ENXIO);

		udf->udf_bus = unit;

		save_udf = *udf;
		udf->udf_data = NULL;
		usb_init_task(&udf_task, usb_fill_udf_task, udf,
		    USB_TASK_TYPE_GENERIC);
		usb_add_task(sc->sc_bus->root_hub, &udf_task);
		usb_wait_task(sc->sc_bus->root_hub, &udf_task);
		len = udf->udf_size;
		cdesc = (usb_config_descriptor_t *)udf->udf_data;
		*udf = save_udf;
		if (cdesc == NULL)
			return (EINVAL);
		if (len > udf->udf_size)
			len = udf->udf_size;
		iov.iov_base = (caddr_t)udf->udf_data;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_resid = len;
		uio.uio_offset = 0;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = p;
		error = uiomove((void *)cdesc, len, &uio);
		free(cdesc, M_TEMP, 0);
		return (error);
	}

	default:
		return (EINVAL);
	}
	return (0);
}

/*
 * Explore device tree from the root.  We need mutual exclusion to this
 * hub while traversing the device tree, but this is guaranteed since this
 * function is only called from the task thread, with one exception:
 * usb_attach() calls this function, but there shouldn't be anything else
 * trying to explore this hub at that time.
 */
void
usb_explore(void *v)
{
	struct usb_softc *sc = v;
	struct timeval now, waited;
	int pwrdly, waited_ms;

	DPRINTFN(2,("%s: %s\n", __func__, sc->sc_dev.dv_xname));
#ifdef USB_DEBUG
	if (usb_noexplore)
		return;
#endif

	if (sc->sc_bus->dying)
		return;

	if (sc->sc_bus->flags & USB_BUS_CONFIG_PENDING) {
		/*
		 * If this is a low/full speed hub and there is a high
		 * speed hub that hasn't explored yet, reshedule this
		 * task, allowing the high speed explore task to run.
		 */
		if (sc->sc_bus->usbrev < USBREV_2_0 && explore_pending > 0) {
			usb_add_task(sc->sc_bus->root_hub,
			    &sc->sc_explore_task);
			return;
		}

		/*
		 * Wait for power to stabilize.
		 */
		getmicrouptime(&now);
		timersub(&now, &sc->sc_ptime, &waited);
		waited_ms = waited.tv_sec * 1000 + waited.tv_usec / 1000;

		pwrdly = sc->sc_bus->root_hub->hub->powerdelay +
		    USB_EXTRA_POWER_UP_TIME;
		if (pwrdly > waited_ms)
			usb_delay_ms(sc->sc_bus, pwrdly - waited_ms);
	}

	if (sc->sc_bus->flags & USB_BUS_DISCONNECTING) {
		/* Prevent new tasks from being scheduled. */
		sc->sc_bus->dying = 1;

		/* Make all devices disconnect. */
		if (sc->sc_port.device != NULL) {
			usbd_detach(sc->sc_port.device, (struct device *)sc);
			sc->sc_port.device = NULL;
		}

		sc->sc_bus->flags &= ~USB_BUS_DISCONNECTING;
	} else {
		sc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);
	}

	if (sc->sc_bus->flags & USB_BUS_CONFIG_PENDING) {
		DPRINTF(("%s: %s: first explore done\n", __func__,
		    sc->sc_dev.dv_xname));
		if (sc->sc_bus->usbrev == USBREV_2_0 && explore_pending)
			explore_pending--;
		config_pending_decr();
		sc->sc_bus->flags &= ~(USB_BUS_CONFIG_PENDING);
	}
}

void
usb_needs_explore(struct usbd_device *dev, int first_explore)
{
	struct usb_softc *usbctl = (struct usb_softc *)dev->bus->usbctl;

	DPRINTFN(3,("%s: %s\n", usbctl->sc_dev.dv_xname, __func__));

	if (!first_explore && (dev->bus->flags & USB_BUS_CONFIG_PENDING)) {
		DPRINTF(("%s: %s: not exploring before first explore\n",
		    __func__, usbctl->sc_dev.dv_xname));
		return;
	}

	usb_add_task(dev, &usbctl->sc_explore_task);
}

void
usb_needs_reattach(struct usbd_device *dev)
{
	DPRINTFN(2,("usb_needs_reattach\n"));
	dev->powersrc->reattach = 1;
	usb_needs_explore(dev, 0);
}

void
usb_schedsoftintr(struct usbd_bus *bus)
{
	DPRINTFN(10,("usb_schedsoftintr: polling=%d\n", bus->use_polling));

	if (bus->use_polling) {
		bus->methods->soft_intr(bus);
	} else {
		softintr_schedule(bus->soft);
	}
}

int
usb_activate(struct device *self, int act)
{
	struct usb_softc *sc = (struct usb_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
		if (sc->sc_bus->root_hub != NULL)
			usb_detach_roothub(sc);
		break;
	case DVACT_RESUME:
		sc->sc_bus->dying = 0;

		/*
		 * Make sure the root hub is present before interrupts
		 * get enabled.   As long as the bus is in polling mode
		 * it is safe to call usbd_new_device() now since root
		 * hub transfers do not need to sleep.
		 */
		sc->sc_bus->use_polling++;
		if (!usb_attach_roothub(sc))
			usb_needs_explore(sc->sc_bus->root_hub, 0);
		sc->sc_bus->use_polling--;
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
usb_detach(struct device *self, int flags)
{
	struct usb_softc *sc = (struct usb_softc *)self;

	if (sc->sc_bus->root_hub != NULL) {
		usb_detach_roothub(sc);

		if (--usb_nbuses == 0) {
			usb_run_tasks = usb_run_abort_tasks = 0;
			wakeup(&usb_run_abort_tasks);
			wakeup(&usb_run_tasks);
		}
	}

	if (sc->sc_bus->soft != NULL) {
		softintr_disestablish(sc->sc_bus->soft);
		sc->sc_bus->soft = NULL;
	}

	return (0);
}
@


1.112
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.111 2016/05/18 18:28:58 patrick Exp $	*/
d652 4
a655 1
			ptr = malloc(len, M_TEMP, M_WAITOK);
@


1.111
log
@Cache vendor, product and serial info for each usb device.  This allows
ioctl(USB_DEVICEINFO) not to issue any further requests to gather
information.  Thus reducing stress on connected usb devices.
This fixes an issue where usbdevs called in a loop causes a USB mass
storage device to halt operation.

Adapted from a similar commit in NetBSD.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.110 2016/03/03 18:13:24 stefan Exp $	*/
d613 1
a613 1
		size_t len = UGETW(ur->ucr_request.wLength);
d616 1
a616 1
		void *ptr = 0;
d667 4
a670 3
		if (len > ur->ucr_actlen)
			len = ur->ucr_actlen;
		if (len != 0) {
d672 1
a672 1
				error = uiomove(ptr, len, &uio);
d679 1
a679 1
			free(ptr, M_TEMP, 0);
@


1.110
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.109 2016/01/22 13:31:47 bluhm Exp $	*/
d523 1
a523 1
	usbd_fill_deviceinfo(dev, di, 1);
@


1.109
log
@If usb_fill_udf_task() failed to fill the struct, udf_data still
contained the pointer it received from user land.  usbioctl() has
to reset it, otherwise user supplied data is passed to free().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.108 2015/09/01 10:00:26 mpi Exp $	*/
d613 1
a613 1
		int len = UGETW(ur->ucr_request.wLength);
d624 1
a624 1
		DPRINTF(("usbioctl: USB_REQUEST addr=%d len=%d\n", addr, len));
d634 1
a634 1
		if (len < 0 || len > 32767)
d654 1
a654 1
				error = uiomovei(ptr, len, &uio);
d671 1
a671 1
				error = uiomovei(ptr, len, &uio);
d769 2
a770 1
		int len, error;
d801 1
a801 1
		error = uiomovei((void *)cdesc, len, &uio);
@


1.108
log
@Reject USB requests that could damage the bus integrity, just like it
is done in ugen(4).

Found by Grant Czajkowski during the GSoC 2015.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.107 2015/03/14 03:38:50 jsg Exp $	*/
d779 1
@


1.107
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.106 2015/02/10 21:56:09 miod Exp $	*/
d625 10
a634 1
		if (len < 0 || len > 32768)
@


1.106
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.105 2015/02/09 12:45:12 uebayasi Exp $	*/
a65 1
#include <dev/usb/usb_quirks.h>
@


1.105
log
@Trim blank lines.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d646 1
a646 1
				error = uiomove(ptr, len, &uio);
d663 1
a663 1
				error = uiomove(ptr, len, &uio);
d791 1
a791 1
		error = uiomove((void *)cdesc, len, &uio);
@


1.104
log
@Always allow abort tasks to be scheduled, even if the device is beeing
detached, in order to prevent a deadlock situation.

This situation can occur if the thread detaching a device is sleeping,
waiting for all submitted transfers to finish, and the device's pipes
have not yet been aborted.  This can happen when a USB Ethernet device
is being detached while a userland program is doing an ioctl(2).

Abort tasks need to be able to run in such case since timed out transfers
rely on them to be properly completed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.103 2014/12/18 10:44:17 mpi Exp $	*/
a204 2


@


1.103
log
@If a host controller has been detached or reported a halt condition it
should be considered as dead.  In such condition the stack no longer
submits I/O or schedules any USB task for its bus.

However we need an explore task to detach the root hub since only the
task thread is supposed to discover buses and attach/detach devices in
order to avoid races.

So reset the bus' dying flag when marking it as disconnecting in order
to let the task be scheduled.  This should be safe because a detached
or halted HC should not trigger any new interrupt.

Fix a panic when detaching USB PCMCIA cards reported by Tilo Stritzky.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.102 2014/08/10 11:18:57 mpi Exp $	*/
d301 7
a307 2
	/* Don't add task if the device's root hub is dying. */
	if (usbd_is_dying(dev))
d463 3
a465 6
		/* Don't actually execute the task if dying. */
		if (!usbd_is_dying(task->dev)) {
			splx(s);
			task->fun(task->arg);
			s = splusb();
		}
@


1.102
log
@Since USB xfer pools are accessed in interrupt context, initialize them
with the correct ipl to prevent your CPU from locking against itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.101 2014/08/09 09:45:14 mpi Exp $	*/
d265 7
@


1.101
log
@Do not store the whole USB hub descriptor in the "struct usbd_hub"
to help integrating super speed hubs that use a different descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.100 2014/07/12 18:48:52 tedu Exp $	*/
d198 1
a198 2
	/* XXX we should have our own level */
	sc->sc_bus->soft = softintr_establish(IPL_SOFTNET,
@


1.100
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.99 2014/07/11 08:43:38 mpi Exp $	*/
d838 2
a839 2
		pwrdly = sc->sc_bus->root_hub->hub->hubdesc.bPwrOn2PwrGood * 
		    UHD_PWRON_FACTOR + USB_EXTRA_POWER_UP_TIME;
@


1.99
log
@Be less verbose with task debug messages and kill some trailing
whitespaces while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.98 2014/07/09 18:15:04 mpi Exp $	*/
d545 1
a545 1
	free(cdesc, M_TEMP);
d664 1
a664 1
			free(ptr, M_TEMP);
d786 1
a786 1
		free(cdesc, M_TEMP);
@


1.98
log
@autoconf(9) is your friend and it knows you more than you think.  It
even knows your children!  So let him handle the seperation correctly.

Do not rewrite your own custom config_detach_children(9) and as a bonus
start removing the usbd_port tentacles from the stack.

ok pirofti@@, yuo@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.97 2014/05/28 11:20:55 mpi Exp $	*/
d124 4
a127 4
int		 usb_match(struct device *, void *, void *); 
void		 usb_attach(struct device *, struct device *, void *); 
int		 usb_detach(struct device *, int); 
int		 usb_activate(struct device *, int); 
d132 7
a138 10
struct cfdriver usb_cd = { 
	NULL, "usb", DV_DULL 
}; 

const struct cfattach usb_ca = { 
	sizeof(struct usb_softc), 
	usb_match, 
	usb_attach, 
	usb_detach, 
	usb_activate, 
a294 3
	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

d299 3
d330 3
a334 3

	if (!(task->state & USB_TASK_STATE_ONQ))
		return;
@


1.97
log
@Apart from the early exploration done to find a console keyboard during
the boot process, USB devices must be attached or detached from the usb
task thread in order to avoid races with periodical explorations issued
by uhub(4) interrupts.

Respect this rule when detaching root hubs during a suspend/resume cycle
and avoid some hangs due to the aforementioned race.

Tested by Mattieu Baptiste, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.96 2014/05/11 16:33:21 mpi Exp $	*/
d852 4
a855 2
		if (sc->sc_port.device != NULL)
			usb_disconnect_port(&sc->sc_port, (struct device *)sc);
@


1.96
log
@The relation between uhci(4), ohci(4) and their root hub device is
delicate.  HC drivers do not always accept to be left alone.

I don't know if it is a love crisis, but apparently receiving a root
hub status change interrupt before having an uhub(4) attached breaks
resume.

So make sure the root hub is re-attached before interrupt get enabled.
It is safe to do it during DVACT_RESUME since attaching root hubs do
not require any USB transfer.

Based on a diff from yasuoka@@, fix a regression introduced in last
commit an reported by Abel Abraham Camarillo Ojeda on tech@@ and Nils
R on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.95 2014/03/31 16:18:06 mpi Exp $	*/
d263 7
a269 3
	/* Make all devices disconnect. */
	if (sc->sc_port.device != NULL)
		usb_disconnect_port(&sc->sc_port, (struct device *)sc);
d271 1
a271 1
	usb_rem_wait_task(sc->sc_bus->root_hub, &sc->sc_explore_task);
d847 12
a858 1
	sc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);
a913 1
		sc->sc_bus->dying = 1;
a930 4
	case DVACT_DEACTIVATE:
		rv = config_activate_children(self, act);
		sc->sc_bus->dying = 1;
		break;
a941 4

	DPRINTF(("usb_detach: start\n"));

	sc->sc_bus->dying = 1;
@


1.95
log
@Force the detach of all USB devices by disconnecting the root hubs
before suspending the machine.

Prior to this commit, devices were logically disconnected after
resuming the machine leading to funny races since the controller
was reset in between.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.94 2014/03/08 11:49:19 mpi Exp $	*/
d903 1
a903 1
	case DVACT_WAKEUP:
d905 8
d915 1
@


1.94
log
@Attach to host controller drivers advertising USB 3.0 support and assign
the correct speed.  This has no effect for the moment since there is no
such driver in our tree, but something tells me it might change soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.93 2013/12/06 21:03:05 deraadt Exp $	*/
d95 1
d129 3
a153 2
	struct usbd_device *dev;
	usbd_status err;
a154 1
	int speed;
d175 1
a175 1
		speed = USB_SPEED_FULL;
d178 1
a178 1
		speed = USB_SPEED_HIGH;
d181 1
a181 1
		speed = USB_SPEED_SUPER;
d210 4
a213 11
	err = usbd_new_device(&sc->sc_dev, sc->sc_bus, 0, speed, 0,
		  &sc->sc_port);
	if (!err) {
		dev = sc->sc_port.device;
		if (dev->hub == NULL) {
			sc->sc_bus->dying = 1;
			printf("%s: root device is not a hub\n",
			       sc->sc_dev.dv_xname);
			return;
		}
		sc->sc_bus->root_hub = dev;
a222 4
	} else {
		printf("%s: root hub problem, error=%d\n",
		       sc->sc_dev.dv_xname, err);
		sc->sc_bus->dying = 1;
d224 1
d237 35
d895 1
a895 2
	struct usbd_device *dev = sc->sc_port.device;
	int i, rv = 0, r;
d898 10
d909 1
a910 11
		if (dev != NULL && dev->cdesc != NULL &&
		    dev->subdevs != NULL) {
			for (i = 0; dev->subdevs[i]; i++) {
				r = config_deactivate(dev->subdevs[i]);
				if (r)
					rv = r;
			}
		}
		break;
	case DVACT_RESUME:
		usb_needs_explore(sc->sc_bus->root_hub, 0);
d929 1
a929 5
		/* Make all devices disconnect. */
		if (sc->sc_port.device != NULL)
			usb_disconnect_port(&sc->sc_port, self);

		usb_rem_wait_task(sc->sc_bus->root_hub, &sc->sc_explore_task);
@


1.93
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.92 2013/05/30 16:15:02 deraadt Exp $	*/
d143 1
a143 2
	DPRINTF(("usbd_match\n"));
	return (UMATCH_GENERIC);
a154 2
	DPRINTF(("usbd_attach\n"));

d178 3
@


1.92
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.91 2013/05/17 09:09:11 mpi Exp $	*/
a883 7
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
	case DVACT_POWERDOWN:
		break;
d886 3
@


1.91
log
@Don't leak information to userland in case the actual transfer length is
smaller than the requested one. From ws@@NetBSD via miod@@.

This problem can only occur when the USBD_SHORT_XFER_OK flag is set,
otherwise completed transfers with a length smaller than the one
submitted are treated as errors.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.90 2013/04/26 14:05:24 mpi Exp $	*/
d883 7
@


1.90
log
@Give back to usb(4) what is usb(4)'s. In other words use the usb_* prefix
for functions related to the usb(4) driver and keep usbd_* for generic
USB layer functions.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.89 2013/04/19 19:07:45 mglocker Exp $	*/
d625 3
@


1.89
log
@Rename usbd_fill_*_task() to usb_fill_*_task().
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.88 2013/04/18 08:44:39 mglocker Exp $	*/
d57 1
d101 2
d107 2
a108 1
int usb_run_tasks, usb_run_abort_tasks;
d158 10
a167 1
	usbd_init();
a245 24
/*
 * Called by usbd_init when first usb is attached.
 */
void
usb_begin_tasks(void)
{
	TAILQ_INIT(&usb_abort_tasks);
	TAILQ_INIT(&usb_explore_tasks);
	TAILQ_INIT(&usb_generic_tasks);
	usb_run_tasks = usb_run_abort_tasks = 1;
	kthread_create_deferred(usb_create_task_threads, NULL);
}

/*
 * Called by usbd_finish when last usb is detached.
 */
void
usb_end_tasks(void)
{
	usb_run_tasks = usb_run_abort_tasks = 0;
	wakeup(&usb_run_abort_tasks);
	wakeup(&usb_run_tasks);
}

d904 5
a908 1
		usbd_finish();
@


1.88
log
@Move over function prototypes from ubsdi.h to usb.c which just get used
there.  Some spacing while here.

Suggested and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.87 2013/04/17 11:53:10 mglocker Exp $	*/
d115 3
a117 3
void		 usbd_fill_di_task(void *);
void		 usbd_fill_udc_task(void *);
void		 usbd_fill_udf_task(void *);
d486 1
a486 1
usbd_fill_di_task(void *arg)
d506 1
a506 1
usbd_fill_udc_task(void *arg)
d533 1
a533 1
usbd_fill_udf_task(void *arg)
d670 1
a670 1
		usb_init_task(&di_task, usbd_fill_di_task, di,
d718 1
a718 1
		usb_init_task(&udc_task, usbd_fill_udc_task, udc,
d746 1
a746 1
		usb_init_task(&udf_task, usbd_fill_udf_task, udf,
@


1.87
log
@Add new ioctl command USB_DEVICE_GET_DDESC to usb(4) to retrieve the
device descriptor.

Help and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.86 2013/04/15 09:23:02 mglocker Exp $	*/
a105 8

void	usb_explore(void *);
void	usb_create_task_threads(void *);
void	usb_task_thread(void *);
struct proc *usb_task_thread_proc = NULL;
void	usb_abort_task_thread(void *);
struct proc *usb_abort_task_thread_proc = NULL;

d108 15
a122 4
int usb_match(struct device *, void *, void *); 
void usb_attach(struct device *, struct device *, void *); 
int usb_detach(struct device *, int); 
int usb_activate(struct device *, int); 
@


1.86
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.85 2013/04/08 10:34:20 mglocker Exp $	*/
d681 19
@


1.85
log
@Add new ioctl's USB_DEVICE_GET_CDESC and USB_DEVICE_GET_FDESC to usb(4).
Those are the equivalents for ugen(4)'s USB_GET_CONFIG_DESC and
USB_GET_FULL_DESC.

Help and OK mpi@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.84 2013/03/28 03:58:03 tedu Exp $	*/
d92 1
a92 1
	usbd_bus_handle  sc_bus;	/* USB controller */
d144 1
a144 1
	usbd_device_handle dev;
d272 1
a272 1
usb_add_task(usbd_device_handle dev, struct usb_task *task)
d307 1
a307 1
usb_rem_task(usbd_device_handle dev, struct usb_task *task)
d338 1
a338 1
usb_wait_task(usbd_device_handle dev, struct usb_task *task)
d357 1
a357 1
usb_rem_wait_task(usbd_device_handle dev, struct usb_task *task)
d487 1
a487 1
	usbd_device_handle dev;
d507 1
a507 1
	usbd_device_handle dev;
d534 1
a534 1
	usbd_device_handle dev;
d651 1
a651 1
		usbd_device_handle dev;
d816 1
a816 1
usb_needs_explore(usbd_device_handle dev, int first_explore)
d832 1
a832 1
usb_needs_reattach(usbd_device_handle dev)
d840 1
a840 1
usb_schedsoftintr(usbd_bus_handle bus)
d855 1
a855 1
	usbd_device_handle dev = sc->sc_port.device;
@


1.84
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.83 2013/03/28 03:31:56 tedu Exp $	*/
d502 51
d681 67
@


1.83
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.82 2013/03/16 09:58:40 mpi Exp $	*/
a50 1
#include <sys/proc.h>
@


1.82
log
@Remove the 4.8 version of the USB device info ioctl.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.81 2012/05/15 12:48:32 mpi Exp $	*/
a55 1
#include <sys/vnode.h>
@


1.81
log
@Don't use a pointer to an opaque softc, we'll need to access its unit
number. No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.80 2012/05/12 17:27:44 mpi Exp $	*/
a625 20
		break;
	}

	case USB_DEVICEINFO_48:
	{
		struct usb_device_info_48 *di_48 = (void *)data;
		struct usb_device_info di_tmp;
		int addr = di_48->udi_addr;
		usbd_device_handle dev;

		if (addr < 1 || addr >= USB_MAX_DEVICES)
			return (EINVAL);
		dev = sc->sc_bus->devices[addr];
		if (dev == NULL)
			return (ENXIO);

		bzero(&di_tmp, sizeof(struct usb_device_info));
		bcopy(di_48, &di_tmp, sizeof(struct usb_device_info_48));
		usbd_fill_deviceinfo(dev, &di_tmp, 1);
		bcopy(&di_tmp, di_48, sizeof(struct usb_device_info_48));
@


1.80
log
@Returns different errors for USB_REQUEST if the address specified
is invalid or valid but with no device found.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.79 2012/01/28 00:40:23 deraadt Exp $	*/
d155 1
a155 1
	sc->sc_bus->usbctl = sc;
d722 1
a722 1
	DPRINTFN(3,("%s: %s\n", dev->bus->usbctl->sc_dev.dv_xname, __func__));
d724 3
a726 2
	if (!first_explore &&
	    (dev->bus->flags & USB_BUS_CONFIG_PENDING)) {
d728 1
a728 1
		    __func__, dev->bus->usbctl->sc_dev.dv_xname));
d732 1
a732 1
	usb_add_task(dev, &dev->bus->usbctl->sc_explore_task);
@


1.79
log
@Force usb_needs_explore() at DVACT_RESUME time; from Alexander Polakov
Might help a few laptops resume their usb devices better.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.78 2011/09/18 23:24:12 krw Exp $	*/
d554 1
a554 2
		if (addr < 0 || addr >= USB_MAX_DEVICES ||
		    sc->sc_bus->devices[addr] == 0)
d556 2
@


1.78
log
@usbdivar.h needs struct timeout. But don't get it indirectly via
sys/kthread.h,  use sys/timeout.h explicitly. Noted by Michael
Knudsen.

ok deraadt@@ kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.77 2011/07/03 15:47:17 matthew Exp $	*/
d771 3
@


1.77
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.76 2011/04/28 07:35:15 jakemsr Exp $	*/
d49 1
@


1.76
log
@remove horrible abuse of kthread_create_deferred(9).  this was being
used to "do things later" and was potentially sleeping in swapper
context.  the latter is really bad, because it might never wake up.

instead, move the things that usb_first_explore() was doing to the
first run of the explore task.  since tasks are run in a kthread,
they are in process context and ok to sleep.

fixes boot hang noticed by jsg@@, which mikeb@@ debugged and found
usb_first_explore() to be sleeping swapper context
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.75 2011/02/09 20:24:39 jakemsr Exp $	*/
a759 2
	case DVACT_ACTIVATE:
		break;
@


1.75
log
@bring back changes in usb.c revision 1.73
date: 2011/02/04 08:21:39;  author: jakemsr;  state: Exp;  lines: +85 -34
* merge 'onqueue' and 'running' members of struct usb_task into
  a new member, 'state'.
* add new function 'usb_wait_task()', which waits for queued or running
  usb_tasks to complete.
* in the USB_DEVICEINFO ioctl, fill struct usb_device_info in a
  usb_task, thereby avoiding races against driver attach/detach.

but this time make the state a bitmask, since it is valid to be added
to the task queue while the task is running.  also be more careful
about waking up the task when state changes.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.74 2011/02/09 04:25:32 jakemsr Exp $	*/
a108 1
void	usb_first_explore(void *);
d208 1
a208 1
		 * until the USB event thread is running, which means that
d227 1
a227 1
		kthread_create_deferred(usb_first_explore, sc);
a364 40
usb_first_explore(void *arg)
{
	struct usb_softc *sc = arg;
	struct timeval now, waited;
	int pwrdly, waited_ms;

	getmicrouptime(&now);
	timersub(&now, &sc->sc_ptime, &waited);
	waited_ms = waited.tv_sec * 1000 + waited.tv_usec / 1000;

	/* Wait for power to come good. */
	pwrdly = sc->sc_bus->root_hub->hub->hubdesc.bPwrOn2PwrGood * 
	    UHD_PWRON_FACTOR + USB_EXTRA_POWER_UP_TIME;
	if (pwrdly > waited_ms)
		usb_delay_ms(sc->sc_bus, pwrdly - waited_ms);

	/*
	 * USB1 waits for USB2 to finish their first probe.
	 * We only really need to have "companion" USB1 controllers
	 * wait, but it's hard to determine what's a companion and
	 * what isn't.
	 */
	while (sc->sc_bus->usbrev != USBREV_2_0 && explore_pending)
		(void)tsleep((void *)&explore_pending, PWAIT, "config", 0);

	/*
	 * Add first explore task to the queue.  The tasks are run in order
	 * in a single thread, so adding tasks to the queue in the correct
	 * order means they will run in the correct order.
	 */
	usb_needs_explore(sc->sc_bus->root_hub, 1);

	/* Wake up any companions waiting for handover before their probes. */
	if (sc->sc_bus->usbrev == USBREV_2_0) {
		explore_pending--;
		wakeup((void *)&explore_pending);
 	}
}

void
d668 2
d677 29
a705 2
	if (!sc->sc_bus->dying)
		sc->sc_bus->root_hub->hub->explore(sc->sc_bus->root_hub);
d710 2
@


1.74
log
@revert usb.c to r1.72, and all subsequent changes that depend on it.
this is causing problems with suspend/resume for some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.73 2011/02/04 08:21:39 jakemsr Exp $	*/
d278 2
a279 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d286 1
a286 1
	if (!task->onqueue) {
d298 1
a298 1
		task->onqueue = 1;
d313 5
a317 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d320 11
a330 13
	if (task->onqueue) {
		switch (task->type) {
		case USB_TASK_TYPE_ABORT:
			TAILQ_REMOVE(&usb_abort_tasks, task, next);
			break;
		case USB_TASK_TYPE_EXPLORE:
			TAILQ_REMOVE(&usb_explore_tasks, task, next);
			break;
		case USB_TASK_TYPE_GENERIC:
			TAILQ_REMOVE(&usb_generic_tasks, task, next);
			break;
		}
		task->onqueue = 0;
d332 4
d340 1
a340 1
usb_rem_wait_task(usbd_device_handle dev, struct usb_task *task)
d344 5
a348 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d351 1
a351 2
	usb_rem_task(dev, task);
	while (task->running) {
d359 7
d423 17
a439 10
		task->onqueue = 0;
		/* Don't execute the task if the root hub is gone. */
		if (usbd_is_dying(task->dev))
			continue;
		task->running = 1;
		splx(s);
		task->fun(task->arg);
		s = splusb();
		task->running = 0;
		wakeup(task);
d467 17
a483 10
		task->onqueue = 0;
		/* Don't execute the task if the root hub is gone. */
		if (usbd_is_dying(task->dev))
			continue;
		task->running = 1;
		splx(s);
		task->fun(task->arg);
		s = splusb();
		task->running = 0;
		wakeup(task);
d524 20
d640 1
d645 1
d649 16
a664 1
		usbd_fill_deviceinfo(dev, di, 1);
@


1.73
log
@* merge 'onqueue' and 'running' members of struct usb_task into
  a new member, 'state'.
* add new function 'usb_wait_task()', which waits for queued or running
  usb_tasks to complete.
* in the USB_DEVICEINFO ioctl, fill struct usb_device_info in a
  usb_task, thereby avoiding races against driver attach/detach.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.72 2011/01/25 20:03:36 jakemsr Exp $	*/
d278 2
a279 2
	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));
d286 1
a286 1
	if (task->state != USB_TASK_STATE_ONQ) {
d298 1
a298 1
		task->state = USB_TASK_STATE_ONQ;
d313 2
a314 5
	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

	if (task->state != USB_TASK_STATE_ONQ)
		return;
d317 13
a329 11

	switch (task->type) {
	case USB_TASK_TYPE_ABORT:
		TAILQ_REMOVE(&usb_abort_tasks, task, next);
		break;
	case USB_TASK_TYPE_EXPLORE:
		TAILQ_REMOVE(&usb_explore_tasks, task, next);
		break;
	case USB_TASK_TYPE_GENERIC:
		TAILQ_REMOVE(&usb_generic_tasks, task, next);
		break;
a330 2
	task->state = USB_TASK_STATE_NONE;

d335 1
a335 1
usb_wait_task(usbd_device_handle dev, struct usb_task *task)
d339 2
a340 5
	DPRINTFN(2,("%s: task=%p state=%d type=%d\n", __func__, task,
	    task->state, task->type));

	if (task->state == USB_TASK_STATE_NONE)
		return;
d343 2
a344 1
	while (task->state != USB_TASK_STATE_NONE) {
a351 7
usb_rem_wait_task(usbd_device_handle dev, struct usb_task *task)
{
	usb_rem_task(dev, task);
	usb_wait_task(dev, task);
}

void
d409 1
d411 1
a411 2
		if (usbd_is_dying(task->dev)) {
			task->state = USB_TASK_STATE_NONE;
d413 1
a413 2
		}
		task->state = USB_TASK_STATE_RUN;
d417 1
a417 1
		task->state = USB_TASK_STATE_NONE;
d446 1
d448 1
a448 2
		if (usbd_is_dying(task->dev)) {
			task->state = USB_TASK_STATE_NONE;
d450 1
a450 2
		}
		task->state = USB_TASK_STATE_RUN;
d454 1
a454 1
		task->state = USB_TASK_STATE_NONE;
a495 20
void
usbd_fill_di_task(void *arg)
{
	struct usb_device_info *di = (struct usb_device_info *)arg;
	struct usb_softc *sc;
	usbd_device_handle dev;

	/* check that the bus and device are still present */
	if (di->udi_bus >= usb_cd.cd_ndevs)
		return;
	sc = usb_cd.cd_devs[di->udi_bus];
	if (sc == NULL)
		return;
	dev = sc->sc_bus->devices[di->udi_addr];
	if (dev == NULL)
		return;

	usbd_fill_deviceinfo(dev, di, 1);
}

a591 1
		struct usb_task di_task;
a595 1

d599 1
a599 16

		di->udi_bus = unit;

		/* All devices get a driver, thanks to ugen(4).  If the
		 * task ends without adding a driver name, there was an error.
		 */
		di->udi_devnames[0][0] = '\0';

		usb_init_task(&di_task, usbd_fill_di_task, di,
		    USB_TASK_TYPE_GENERIC);
		usb_add_task(sc->sc_bus->root_hub, &di_task);
		usb_wait_task(sc->sc_bus->root_hub, &di_task);

		if (di->udi_devnames[0][0] == '\0')
			return (ENXIO);

@


1.72
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.71 2011/01/15 23:58:43 jakemsr Exp $	*/
d278 2
a279 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d286 1
a286 1
	if (!task->onqueue) {
d298 1
a298 1
		task->onqueue = 1;
d313 5
a317 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d320 11
a330 13
	if (task->onqueue) {
		switch (task->type) {
		case USB_TASK_TYPE_ABORT:
			TAILQ_REMOVE(&usb_abort_tasks, task, next);
			break;
		case USB_TASK_TYPE_EXPLORE:
			TAILQ_REMOVE(&usb_explore_tasks, task, next);
			break;
		case USB_TASK_TYPE_GENERIC:
			TAILQ_REMOVE(&usb_generic_tasks, task, next);
			break;
		}
		task->onqueue = 0;
d332 2
d338 1
a338 1
usb_rem_wait_task(usbd_device_handle dev, struct usb_task *task)
d342 5
a346 2
	DPRINTFN(2,("%s: task=%p onqueue=%d type=%d\n", __func__, task,
	    task->onqueue, task->type));
d349 1
a349 2
	usb_rem_task(dev, task);
	while (task->running) {
d357 7
a420 1
		task->onqueue = 0;
d422 2
a423 1
		if (usbd_is_dying(task->dev))
d425 2
a426 1
		task->running = 1;
d430 1
a430 1
		task->running = 0;
a458 1
		task->onqueue = 0;
d460 2
a461 1
		if (usbd_is_dying(task->dev))
d463 2
a464 1
		task->running = 1;
d468 1
a468 1
		task->running = 0;
d510 20
d626 1
d631 1
d635 16
a650 1
		usbd_fill_deviceinfo(dev, di, 1);
@


1.71
log
@* add 'udi_serial' to struct usb_device_info.
* fill 'udi_serial' with the serial number in usbd_fill_deviceinfo().
* add compatability ioctl/struct so old binaries continue to work.

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.70 2010/12/06 04:28:41 jakemsr Exp $	*/
a62 2
#define USB_DEV_MINOR 255

a115 15
#define USB_MAX_EVENTS 100
struct usb_event_q {
	struct usb_event ue;
	SIMPLEQ_ENTRY(usb_event_q) next;
};
SIMPLEQ_HEAD(, usb_event_q) usb_events =
	SIMPLEQ_HEAD_INITIALIZER(usb_events);
int usb_nevents = 0;
struct selinfo usb_selevent;
struct proc *usb_async_proc;  /* process that wants USB SIGIO */
int usb_dev_open = 0;
void usb_add_event(int, struct usb_event *);

int usb_get_next_event(struct usb_event *);

a149 1
	struct usb_event ue;
a185 3
	ue.u.ue_ctrlr.ue_bus = sc->sc_dev.dv_unit;
	usb_add_event(USB_EVENT_CTRLR_ATTACH, &ue);

a477 8
	if (unit == USB_DEV_MINOR) {
		if (usb_dev_open)
			return (EBUSY);
		usb_dev_open = 1;
		usb_async_proc = 0;
		return (0);
	}

a490 33
usbread(dev_t dev, struct uio *uio, int flag)
{
	struct usb_event ue;
	int s, error, n;

	if (minor(dev) != USB_DEV_MINOR)
		return (ENXIO);

	if (uio->uio_resid != sizeof(struct usb_event))
		return (EINVAL);

	error = 0;
	s = splusb();
	for (;;) {
		n = usb_get_next_event(&ue);
		if (n != 0)
			break;
		if (flag & IO_NDELAY) {
			error = EWOULDBLOCK;
			break;
		}
		error = tsleep(&usb_events, PZERO | PCATCH, "usbrea", 0);
		if (error)
			break;
	}
	splx(s);
	if (!error)
		error = uiomove((void *)&ue, uio->uio_resid, uio);

	return (error);
}

int
a492 7
	int unit = minor(dev);

	if (unit == USB_DEV_MINOR) {
		usb_async_proc = 0;
		usb_dev_open = 0;
	}

a502 18
	if (unit == USB_DEV_MINOR) {
		switch (cmd) {
		case FIONBIO:
			/* All handled in the upper FS layer. */
			return (0);

		case FIOASYNC:
			if (*(int *)data)
				usb_async_proc = p;
			else
				usb_async_proc = 0;
			return (0);

		default:
			return (EINVAL);
		}
	}

a632 77
int
usbpoll(dev_t dev, int events, struct proc *p)
{
	int revents, mask, s;

	if (minor(dev) == USB_DEV_MINOR) {
		revents = 0;
		mask = POLLIN | POLLRDNORM;

		s = splusb();
		if (events & mask && usb_nevents > 0)
			revents |= events & mask;
		if (revents == 0 && events & mask)
			selrecord(p, &usb_selevent);
		splx(s);

		return (revents);
	} else {
		return (POLLERR);
	}
}

void filt_usbrdetach(struct knote *);
int filt_usbread(struct knote *, long);
int usbkqfilter(dev_t, struct knote *);

void
filt_usbrdetach(struct knote *kn)
{
	int s;

	s = splusb();
	SLIST_REMOVE(&usb_selevent.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_usbread(struct knote *kn, long hint)
{

	if (usb_nevents == 0)
		return (0);

	kn->kn_data = sizeof(struct usb_event);
	return (1);
}

struct filterops usbread_filtops =
	{ 1, NULL, filt_usbrdetach, filt_usbread };

int
usbkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		if (minor(dev) != USB_DEV_MINOR)
			return (1);
		klist = &usb_selevent.si_note;
		kn->kn_fop = &usbread_filtops;
		break;

	default:
		return (1);
	}

	kn->kn_hook = NULL;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

a684 72
/* Called at splusb() */
int
usb_get_next_event(struct usb_event *ue)
{
	struct usb_event_q *ueq;

	if (usb_nevents <= 0)
		return (0);
	ueq = SIMPLEQ_FIRST(&usb_events);
#ifdef DIAGNOSTIC
	if (ueq == NULL) {
		printf("usb: usb_nevents got out of sync! %d\n", usb_nevents);
		usb_nevents = 0;
		return (0);
	}
#endif
	*ue = ueq->ue;
	SIMPLEQ_REMOVE_HEAD(&usb_events, next);
	free(ueq, M_USBDEV);
	usb_nevents--;
	return (1);
}

void
usbd_add_dev_event(int type, usbd_device_handle udev)
{
	struct usb_event ue;

	usbd_fill_deviceinfo(udev, &ue.u.ue_device, USB_EVENT_IS_ATTACH(type));
	usb_add_event(type, &ue);
}

void
usbd_add_drv_event(int type, usbd_device_handle udev, struct device *dev)
{
	struct usb_event ue;

	ue.u.ue_driver.ue_cookie = udev->cookie;
	strncpy(ue.u.ue_driver.ue_devname, dev->dv_xname,
	    sizeof ue.u.ue_driver.ue_devname);
	usb_add_event(type, &ue);
}

void
usb_add_event(int type, struct usb_event *uep)
{
	struct usb_event_q *ueq;
	struct usb_event ue;
	struct timespec thetime;
	int s;

	nanotime(&thetime);
	/* Don't want to wait here inside splusb() */
	ueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);
	ueq->ue = *uep;
	ueq->ue.ue_type = type;
	ueq->ue.ue_time = thetime;

	s = splusb();
	if (++usb_nevents >= USB_MAX_EVENTS) {
		/* Too many queued events, drop an old one. */
		DPRINTFN(-1,("usb: event dropped\n"));
		(void)usb_get_next_event(&ue);
	}
	SIMPLEQ_INSERT_TAIL(&usb_events, ueq, next);
	wakeup(&usb_events);
	selwakeup(&usb_selevent);
	if (usb_async_proc != NULL)
		psignal(usb_async_proc, SIGIO);
	splx(s);
}

a725 1
	struct usb_event ue;
a744 3

	ue.u.ue_ctrlr.ue_bus = sc->sc_dev.dv_unit;
	usb_add_event(USB_EVENT_CTRLR_DETACH, &ue);
@


1.70
log
@* check that the root hub has been configured before trying to
  free it's resources
* use usbd_is_dying() instead of directly checking the device's
  bus dying flag
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.69 2010/10/23 15:42:09 jakemsr Exp $	*/
d687 20
@


1.69
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.68 2010/09/23 06:30:37 jakemsr Exp $	*/
d303 1
a303 1
	if (dev->bus->dying)
d432 1
a432 1
		if (task->dev->bus->dying)
d469 1
a469 1
		if (task->dev->bus->dying)
d948 4
a951 3
	/* Make all devices disconnect. */
	if (sc->sc_port.device != NULL)
		usb_disconnect_port(&sc->sc_port, self);
d953 1
a953 1
	usb_rem_wait_task(sc->sc_bus->root_hub, &sc->sc_explore_task);
d955 2
a956 1
	usbd_finish();
@


1.68
log
@add two members to struct usb_task
* usbd_device_handle dev - the device responsible for the task.  use
this to not run the task if the device's hub is dying.
* int running - a flag to be set when the task is running.

add usb_rem_wait_task(), a wrapper for usb_rem_task() that waits for
the task to complete if the task is already running.

s/usb_rem_task/usb_rem_wait_task/ in usb_detach().  probably most
drivers using usb_tasks should do this as well.  although device
attach/detach is serialized in normal cases, in the special case
where the usb bus is hotpluggable (like cardbus/pcmcia), devices
are not detached in the task thread.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.67 2010/09/23 05:44:15 jakemsr Exp $	*/
d103 1
d105 1
a105 1
TAILQ_HEAD(, usb_task) usb_tasks;
d107 1
a107 1
int usb_run_tasks;
d112 1
a112 1
void	usb_create_task_thread(void *);
d115 2
d201 2
a202 1
	usb_init_task(&sc->sc_explore_task, usb_explore, sc);
d259 1
d261 3
a263 3
	TAILQ_INIT(&usb_tasks);
	usb_run_tasks = 1;
	kthread_create_deferred(usb_create_task_thread, NULL);
d272 2
a273 1
	usb_run_tasks = 0;
d278 1
a278 1
usb_create_task_thread(void *arg)
d280 4
d299 2
a300 1
	DPRINTFN(2,("%s: task=%p onqueue=%d\n", __func__, task, task->onqueue));
d308 5
a312 1
		if (task->fun == usb_explore)
d314 5
a318 2
		else
			TAILQ_INSERT_TAIL(&usb_tasks, task, next);
d322 4
a325 1
	wakeup(&usb_run_tasks);
d334 2
a335 1
	DPRINTFN(2,("%s: task=%p onqueue=%d\n", __func__, task, task->onqueue));
d339 5
a343 1
		if (task->fun == usb_explore)
d345 5
a349 2
		else
			TAILQ_REMOVE(&usb_tasks, task, next);
d360 2
a361 1
	DPRINTFN(2,("%s: task=%p onqueue=%d\n", __func__, task, task->onqueue));
d424 2
a425 2
		else if ((task = TAILQ_FIRST(&usb_tasks)) != NULL)
			TAILQ_REMOVE(&usb_tasks, task, next);
d428 37
@


1.67
log
@add a 'dying' flag to struct usbd_bus.  use this to signify the bus
is dying, instead of setting a flag in struct usb_softc.  as
usbd_device_handle has a pointer to the usbd_bus it's attached to,
usb devices, and functions they run or functions run on their behalf,
can now easily check if their bus is dying.  use this to stop
usbd_do_request* from running and the usb task thread from adding
new tasks when a device's bus is dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.66 2010/09/23 05:28:57 jakemsr Exp $	*/
d302 1
d327 16
d401 4
d408 2
d885 1
a885 1
	usb_rem_task(sc->sc_bus->root_hub, &sc->sc_explore_task);
@


1.66
log
@instead of waiting the full power-up-to-power-steady time for root
hubs before their first port explore, check how long it's actually
been since power up and only wait as necessary.  saves a little time
on boot, especially now that explore tasks are serialized.
ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.65 2010/09/23 04:58:02 jakemsr Exp $	*/
a99 1
	char		 sc_dying;
d185 1
a185 1
		sc->sc_dying = 1;
d208 1
a208 1
		sc->sc_dying = 1;
d217 1
a217 1
			sc->sc_dying = 1;
d235 1
a235 1
		sc->sc_dying = 1;
d240 1
a240 1
	if (!sc->sc_dying) {
d291 4
d423 1
a423 1
	if (sc->sc_dying)
d502 1
a502 1
	if (sc->sc_dying)
d705 1
a705 1
	if (!sc->sc_dying)
d834 1
a834 1
		sc->sc_dying = 1;
d856 1
a856 1
	sc->sc_dying = 1;
@


1.65
log
@instead of running usb_explore() from individual kthreads for each
USB bus, make usb_explore() a usb_task.  reduces races during normal
USB device detach, since now usb_tasks and detach happen in the same
process.
ok yuo@@, matthew@@ helped with the task thread loop
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.64 2010/09/23 00:46:08 jakemsr Exp $	*/
d57 1
d101 1
d242 1
d326 6
a331 1
	int pwrdly;
d336 2
a337 1
	usb_delay_ms(sc->sc_bus, pwrdly);
@


1.64
log
@rename usb_discover to usb_explore for consistency.
OK krw
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.63 2010/08/31 16:38:42 deraadt Exp $	*/
d84 1
a84 2
 * 1  - do not use timeout exploration
 * >1 - do no exploration
d97 1
a97 1
	struct proc	*sc_event_thread;
d102 2
a103 1
TAILQ_HEAD(, usb_task) usb_all_tasks;
d105 2
a106 1
volatile int threads_pending = 0;
d109 2
a110 2
void	usb_create_event_thread(void *);
void	usb_event_thread(void *);
d193 6
d239 6
a244 2
	config_pending_incr();
	kthread_create_deferred(usb_create_event_thread, sc);
d247 3
d251 1
a251 1
usb_create_event_thread(void *arg)
d253 5
a257 2
	struct usb_softc *sc = arg;
	static int created = 0;
d259 9
a267 2
	if (sc->sc_bus->usbrev == USBREV_2_0)
		threads_pending++;
d269 6
a274 12
	if (kthread_create(usb_event_thread, sc, &sc->sc_event_thread,
	    "%s", sc->sc_dev.dv_xname))
		panic("unable to create event thread for %s",
		    sc->sc_dev.dv_xname);

	if (!created) {
		created = 1;
		TAILQ_INIT(&usb_all_tasks);
		if (kthread_create(usb_task_thread, NULL,
		    &usb_task_thread_proc, "usbtask"))
			panic("unable to create usb task thread");
	}
d287 2
d291 4
a294 2
		DPRINTFN(2,("usb_add_task: task=%p\n", task));
		TAILQ_INSERT_TAIL(&usb_all_tasks, task, next);
a295 2
	} else {
		DPRINTFN(3,("usb_add_task: task=%p on q\n", task));
d297 1
a297 1
	wakeup(&usb_all_tasks);
d306 2
d310 4
a313 1
		TAILQ_REMOVE(&usb_all_tasks, task, next);
d320 1
a320 1
usb_event_thread(void *arg)
a324 2
	DPRINTF(("usb_event_thread: start\n"));

d330 15
a344 8
	/* USB1 threads wait for USB2 threads to finish their first probe. */
	while (sc->sc_bus->usbrev != USBREV_2_0 && threads_pending)
		(void)tsleep((void *)&threads_pending, PWAIT, "config", 0);

	/* Make sure first explore does something. */
	sc->sc_bus->needs_explore = 1;
	usb_explore(sc);
	config_pending_decr();
d348 3
a350 25
		threads_pending--;
		wakeup((void *)&threads_pending);
	}

	while (!sc->sc_dying) {
#ifdef USB_DEBUG
		if (usb_noexplore < 2)
#endif
		usb_explore(sc);
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
		DPRINTFN(2,("usb_event_thread: woke up\n"));
	}
	sc->sc_event_thread = NULL;

	/* In case parent is waiting for us to exit. */
	wakeup(sc);

	DPRINTF(("usb_event_thread: exit\n"));
	kthread_exit(0);
d362 8
a369 13
	for (;;) {
		task = TAILQ_FIRST(&usb_all_tasks);
		if (task == NULL) {
			tsleep(&usb_all_tasks, PWAIT, "usbtsk", 0);
			task = TAILQ_FIRST(&usb_all_tasks);
		}
		DPRINTFN(2,("usb_task_thread: woke up task=%p\n", task));
		if (task != NULL) {
			TAILQ_REMOVE(&usb_all_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
			s = splusb();
d371 4
d376 3
d675 7
a681 1
/* Explore device tree from the root. */
d687 1
a687 1
	DPRINTFN(2,("usb_explore\n"));
d689 1
a689 1
	if (usb_noexplore > 1)
d692 2
a693 7
	/*
	 * We need mutual exclusion while traversing the device tree,
	 * but this is guaranteed since this function is only called
	 * from the event thread for the controller.
	 */
	while (sc->sc_bus->needs_explore && !sc->sc_dying) {
		sc->sc_bus->needs_explore = 0;
d695 6
d705 1
a705 1
usb_needs_explore(usbd_device_handle dev)
d707 10
a716 3
	DPRINTFN(2,("usb_needs_explore\n"));
	dev->bus->needs_explore = 1;
	wakeup(&dev->bus->needs_explore);
d724 1
a724 2
	dev->bus->needs_explore = 1;
	wakeup(&dev->bus->needs_explore);
d850 1
a850 8
	/* Kill off event thread. */
	if (sc->sc_event_thread != NULL) {
		wakeup(&sc->sc_bus->needs_explore);
		if (tsleep(sc, PWAIT, "usbdet", hz * 60))
			printf("%s: event thread didn't die\n",
			       sc->sc_dev.dv_xname);
		DPRINTF(("usb_detach: event thread dead\n"));
	}
@


1.63
log
@In xxactivate() DVACT_DEACTIVATE, when calling a series of config_deactivate()
for sub-devices, return the last error return value instead of |'ing the
failures together and creating some value that is non-0 (bravo!) but
potentially loses the specific error value...
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.62 2009/11/09 17:53:39 nicm Exp $	*/
d107 1
a107 1
void	usb_discover(void *);
d311 1
a311 1
	/* Make sure first discover does something. */
d313 1
a313 1
	usb_discover(sc);
d326 1
a326 1
		usb_discover(sc);
d667 1
a667 1
usb_discover(void *v)
d671 1
a671 1
	DPRINTFN(2,("usb_discover\n"));
@


1.62
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.61 2009/11/04 19:14:10 kettenis Exp $	*/
d793 1
a793 1
	int i, rv = 0;
a797 1

d802 5
a806 2
			for (i = 0; dev->subdevs[i]; i++)
				rv |= config_deactivate(dev->subdevs[i]);
@


1.61
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.60 2009/10/31 06:40:17 deraadt Exp $	*/
a770 1
	KNOTE(&usb_selevent.si_note, 0);
@


1.60
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.59 2009/10/13 19:33:19 pirofti Exp $	*/
a194 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a202 1
#endif
d781 1
a781 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a786 3
#else
	bus->methods->soft_intr(bus);
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a836 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a840 1
#endif
@


1.59
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.58 2008/12/09 03:08:07 yuo Exp $	*/
d773 1
@


1.58
log
@assign ehcidebug to USB_DEBUG ioctl argument.

add priv check to the ioctl.
only root priv should access these debug flags.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.57 2008/06/26 05:42:19 ray Exp $	*/
d133 1
a133 1
int usb_activate(struct device *, enum devact); 
d794 1
a794 1
usb_activate(struct device *self, enum devact act)
@


1.57
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.56 2007/06/15 11:41:48 mbalmer Exp $	*/
d42 1
d79 3
d460 1
d485 1
d489 3
d494 1
a494 1
		usbdebug  = ((*(int *)data) & 0x000000ff);
d496 1
a496 1
		uhcidebug = ((*(int *)data) & 0x0000ff00) >> 8;
d499 4
a502 1
		ohcidebug = ((*(int *)data) & 0x00ff0000) >> 16;
@


1.56
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.55 2007/06/14 10:11:16 mbalmer Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.55
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.54 2007/06/13 06:25:03 mbalmer Exp $	*/
a197 1
#ifdef USB_USE_SOFTINTR
a206 3
#else
	timeout_set(&sc->sc_bus->softi, NULL, NULL);
#endif
d777 1
a777 1
#ifdef USB_USE_SOFTINTR
a780 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a781 7
#else
		if (!timeout_pending(&bus->softi)) {
			timeout_del(&bus->softi);
			timeout_set(&bus->softi, bus->methods->soft_intr, bus);
			timeout_add(&bus->softi, 0);
		}
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
d785 1
a785 1
#endif /* USB_USE_SOFTINTR */
a835 1
#ifdef USB_USE_SOFTINTR
a840 3
#else
	timeout_del(&sc->sc_bus->softi);
#endif
@


1.54
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.53 2007/06/12 16:26:37 mbalmer Exp $	*/
d133 16
a148 1
USB_DECLARE_DRIVER(usb);
@


1.53
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.52 2007/06/11 16:30:31 mbalmer Exp $	*/
d97 2
a98 2
	struct device	sc_dev;		/* base device */
	usbd_bus_handle sc_bus;		/* USB controller */
d101 1
a101 1
	struct proc *	sc_event_thread;
d103 1
a103 1
	char		sc_dying;
@


1.52
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.51 2007/06/11 12:36:52 mbalmer Exp $	*/
d723 1
a723 1
usbd_add_drv_event(int type, usbd_device_handle udev, device_ptr_t dev)
d786 1
a786 1
usb_activate(device_ptr_t self, enum devact act)
d809 1
a809 1
usb_detach(device_ptr_t self, int flags)
@


1.51
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.50 2007/06/11 10:58:21 mbalmer Exp $	*/
d101 1
a101 1
	usb_proc_ptr	sc_event_thread;
d114 1
a114 1
usb_proc_ptr usb_task_thread_proc = NULL;
d125 1
a125 1
usb_proc_ptr usb_async_proc;  /* process that wants USB SIGIO */
d376 1
a376 1
usbopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d435 1
a435 1
usbclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d448 1
a448 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d575 1
a575 1
usbpoll(dev_t dev, int events, usb_proc_ptr p)
@


1.50
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.49 2007/06/11 09:26:55 mk Exp $	*/
d389 5
a393 1
	USB_GET_SC_OPEN(usb, unit, sc);
@


1.49
log
@More USB cleanup:  In usb_port.h, get rid of the sel_klist #define
(which was there twice without gcc complaining) and update all uses of
it.

ok jsg mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.48 2007/06/10 17:46:27 mbalmer Exp $	*/
d467 1
a467 1
	USB_GET_SC(usb, unit, sc);
@


1.48
log
@Get rid of the USBDEVPTRNAME macro.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.47 2007/06/10 15:33:16 mbalmer Exp $	*/
d602 1
a602 1
	SLIST_REMOVE(&usb_selevent.sel_klist, kn, knote, kn_selnext);
d630 1
a630 1
		klist = &usb_selevent.sel_klist;
@


1.47
log
@Remove the definition and use of USBDEVUNIT.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.46 2007/06/10 14:49:01 mbalmer Exp $	*/
d724 1
a724 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
@


1.46
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.45 2007/06/10 10:53:48 mbalmer Exp $	*/
d180 1
a180 1
	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
d840 1
a840 1
	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
@


1.45
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.44 2007/06/10 10:15:35 mbalmer Exp $	*/
d189 1
a189 1
		printf("%s: can't register softintr\n", USBDEVNAME(sc->sc_dev));
d205 1
a205 1
			       USBDEVNAME(sc->sc_dev));
d220 1
a220 1
		       USBDEVNAME(sc->sc_dev), err);
d823 1
a823 1
			       USBDEVNAME(sc->sc_dev));
@


1.44
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.43 2007/06/06 19:25:49 mk Exp $	*/
d198 1
a198 1
	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, speed, 0,
@


1.43
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.42 2007/06/05 08:43:56 mbalmer Exp $	*/
d194 1
a194 1
	usb_callout_init(sc->sc_bus->softi);
d769 5
a773 3
		if (!usb_callout_pending(bus->softi))
			usb_callout(bus->softi, 0, bus->methods->soft_intr,
				    bus);
d836 1
a836 1
	usb_uncallout(sc->sc_bus->softi, bus->methods->soft_intr, bus);
@


1.42
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.41 2007/06/04 10:34:04 mbalmer Exp $	*/
d97 1
a97 1
	USBBASEDEVICE	sc_dev;		/* base device */
@


1.41
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.40 2007/05/27 04:00:25 jsg Exp $	*/
d108 1
a108 1
Static volatile int threads_pending = 0;
d110 5
a114 5
Static void	usb_discover(void *);
Static void	usb_create_event_thread(void *);
Static void	usb_event_thread(void *);
Static void	usb_task_thread(void *);
Static usb_proc_ptr usb_task_thread_proc = NULL;
d121 1
a121 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events =
d123 5
a127 5
Static int usb_nevents = 0;
Static struct selinfo usb_selevent;
Static usb_proc_ptr usb_async_proc;  /* process that wants USB SIGIO */
Static int usb_dev_open = 0;
Static void usb_add_event(int, struct usb_event *);
d129 1
a129 1
Static int usb_get_next_event(struct usb_event *);
d131 1
a131 1
Static const char *usbrev_str[] = USBREV_STR;
d592 2
a593 2
Static void filt_usbrdetach(struct knote *);
Static int filt_usbread(struct knote *, long);
d596 1
a596 1
Static void
d606 1
a606 1
Static int
d617 1
a617 1
Static struct filterops usbread_filtops =
d648 1
a648 1
Static void
d729 1
a729 1
Static void
@


1.40
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.39 2007/05/21 05:40:28 jsg Exp $	*/
a107 14
#if defined(__NetBSD__)
dev_type_open(usbopen);
dev_type_close(usbclose);
dev_type_read(usbread);
dev_type_ioctl(usbioctl);
dev_type_poll(usbpoll);
dev_type_kqfilter(usbkqfilter);

const struct cdevsw usb_cdevsw = {
	usbopen, usbclose, usbread, nowrite, usbioctl,
	nostop, notty, usbpoll, nommap, usbkqfilter,
};
#endif

a229 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a373 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
@


1.39
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.38 2007/03/22 05:45:57 pascoe Exp $	*/
d149 2
a150 1
USB_MATCH(usb)
d156 2
a157 1
USB_ATTACH(usb)
d186 1
a186 1
		USB_ATTACH_ERROR_RETURN;
d205 1
a205 1
		USB_ATTACH_ERROR_RETURN;
d220 1
a220 1
			USB_ATTACH_ERROR_RETURN;
a241 2

	USB_ATTACH_SUCCESS_RETURN;
@


1.38
log
@Reapplication of rev 1.36.

Wait the stable power delay on a USB hub only once per hub (not per port),
and defer the delay for root hubs until the host controller event thread
starts, permitting some concurrency.  Speeds up the boot process dramatically
when you have lots of host controllers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.37 2007/03/18 20:14:51 mglocker Exp $	*/
d76 2
a77 2
#define DPRINTF(x)	do { if (usbdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (usbdebug>(n)) logprintf x; } while (0)
@


1.37
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.35 2006/11/01 03:37:24 tedu Exp $	*/
d307 1
d310 5
@


1.36
log
@Wait the stable power delay on a USB hub only once per hub (not per port),
and defer the delay for root hubs until the host controller event thread
starts, permitting some concurrency.  Speeds up the boot process dramatically
when you have lots of host controllers.

ok dlg@@
@
text
@a306 1
	int pwrdly;
a308 5

	/* Wait for power to come good. */
	pwrdly = sc->sc_bus->root_hub->hub->hubdesc.bPwrOn2PwrGood * 
	    UHD_PWRON_FACTOR + USB_EXTRA_POWER_UP_TIME;
	usb_delay_ms(sc->sc_bus, pwrdly);
@


1.35
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.34 2006/09/18 10:55:51 dlg Exp $	*/
d307 1
d310 5
@


1.34
log
@get rid of the usb_port.h macros that wrap our kthread create functions.

looks ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.33 2006/06/23 06:27:12 miod Exp $	*/
d598 1
a598 1
		return (ENXIO);
@


1.33
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.32 2005/11/21 18:16:44 millert Exp $	*/
d239 1
a239 1
	usb_kthread_create(usb_create_event_thread, sc);
d254 5
a258 6
	if (usb_kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,
			   "%s", sc->sc_dev.dv_xname)) {
		printf("%s: unable to create event thread for\n",
		       sc->sc_dev.dv_xname);
		panic("usb_create_event_thread");
	}
d262 3
a264 5
		if (usb_kthread_create1(usb_task_thread, NULL,
					&usb_task_thread_proc, "usbtask")) {
			printf("unable to create task thread\n");
			panic("usb_create_event_thread task");
		}
@


1.32
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.31 2005/10/11 09:09:21 dlg Exp $	*/
d801 1
a801 1
		return (EOPNOTSUPP);
@


1.31
log
@make all usb1 controllers sleep until all the usb2 controllers have probed
and handed over any usb1 devices to the companion. without this usb1
devices didnt appear till after root was mounted, which is frustrating if
you want to use a usb keyboard to enter the root device.

tested by kettenis@@ and drahn@@
ok drahn@@ go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.30 2004/12/12 05:17:40 dlg Exp $	*/
d60 1
a60 1
#include <sys/select.h>
@


1.30
log
@better way to do the reattachement of a device
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.29 2004/07/08 22:18:44 deraadt Exp $	*/
d122 2
d251 3
d313 4
d321 6
@


1.29
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.28 2004/06/24 19:35:24 tholo Exp $	*/
d671 9
@


1.28
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.27 2004/05/04 16:59:32 grange Exp $	*/
d76 2
a77 2
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
@


1.27
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.26 2003/11/07 11:10:47 jmc Exp $	*/
d723 1
a723 1
	struct timeval thetime;
d726 1
a726 1
	microtime(&thetime);
d731 1
a731 1
	TIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);
@


1.26
log
@updated URLs from Jared Yanovich;

however, I did not apply the diff exactly. After hunting around I
found URLs for the missing files, and the ../index.html link appears
not to work. I replaced it with a more suitable link.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.25 2003/07/08 13:19:09 nate Exp $	*/
d692 1
a692 1
	SIMPLEQ_REMOVE_HEAD(&usb_events, ueq, next);
@


1.25
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.24 2003/06/27 16:57:14 nate Exp $	*/
d43 2
a44 2
 * http://www.usb.org/developers/data/ and
 * http://www.usb.org/developers/index.html .
@


1.24
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 2
a2 3
/*	$OpenBSD: usb.c,v 1.23 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: usb.c,v 1.53 2001/01/23 17:04:30 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.c,v 1.20 1999/11/17 22:33:46 n_hibma Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d47 3
d58 1
d79 2
a80 2
#ifdef UHCI_DEBUG
int	uhcidebug;
d82 2
a83 2
#ifdef OHCI_DEBUG
int	ohcidebug;
d101 1
a101 4
	TAILQ_HEAD(, usb_task) sc_tasks;
	struct proc    *sc_event_thread;

	struct usb_task sc_exp_task;
d106 2
d109 11
a119 1
cdev_decl(usb);
d125 2
d137 1
a137 1
Static struct proc *usb_async_proc;  /* process that wants USB SIGIO */
d159 1
a167 3
	TAILQ_INIT(&sc->sc_tasks);

	usb_init_task(&sc->sc_exp_task, usb_discover, sc);
d171 9
a179 1
	if (usbrev != USBREV_1_0 && usbrev != USBREV_1_1) {
d181 1
d193 16
a208 1
	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, 0, 0,
d247 1
d255 9
d267 1
a267 1
 * Add a task to be performed by the event thread.  This function can be
a273 1
	struct usb_softc *sc = dev->bus->usbctl;
d278 2
a279 2
		DPRINTFN(2,("usb_add_task: sc=%p task=%p\n", sc, task));
		TAILQ_INSERT_TAIL(&sc->sc_tasks, task, next);
d281 4
a284 3
	} else
		DPRINTFN(3,("usb_add_task: sc=%p task=%p on q\n", sc, task));
	wakeup(&sc->sc_tasks);
a290 1
	struct usb_softc *sc = dev->bus->usbctl;
d295 1
a295 1
		TAILQ_REMOVE(&sc->sc_tasks, task, next);
a304 2
	struct usb_task *task;
	int s;
d314 12
a325 14
		s = splusb();
		task = TAILQ_FIRST(&sc->sc_tasks);
		if (task == NULL) {
			tsleep(&sc->sc_tasks, PWAIT, "usbevt", 0);
			task = TAILQ_FIRST(&sc->sc_tasks);
		}
		DPRINTFN(2,("usb_event_thread: woke up task=%p\n", task));
		if (task != NULL && !sc->sc_dying) {
			TAILQ_REMOVE(&sc->sc_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
		} else
			splx(s);
d336 26
d374 1
a374 1
usbopen(dev_t dev, int flag, int mode, struct proc *p)
d429 1
a429 1
usbclose(dev_t dev, int flag, int mode, struct proc *p)
d442 1
a442 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, struct proc *p)
d473 2
d476 1
a476 1
#ifdef UHCI_DEBUG
d479 1
a479 1
#ifdef OHCI_DEBUG
d483 1
a483 1
#endif
d495 3
d569 1
a569 1
usbpoll(dev_t dev, int events, struct proc *p)
d672 1
a672 1
	usb_add_task(dev, &dev->bus->usbctl->sc_exp_task);
d684 7
d746 1
d748 1
a748 1
usb_schedsoftintr(struct usbd_bus *bus)
d750 14
d765 1
a777 1
		break;
d781 2
a782 1
		if (dev && dev->cdesc && dev->subdevs) {
d802 1
a802 1
	if (sc->sc_port.device)
d806 2
a807 2
	if (sc->sc_event_thread) {
		wakeup(&sc->sc_tasks);
d815 11
@


1.23
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.22 2002/07/11 03:11:17 nate Exp $	*/
d516 55
@


1.22
log
@Please be more portable in usb land
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.21 2002/07/10 21:41:51 mickey Exp $	*/
d82 1
a82 1
/* 
d119 1
a119 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events = 
d146 1
a146 1
	
d178 1
a178 1
			printf("%s: root device is not a hub\n", 
d184 1
a184 1
		/* 
d193 2
a194 2
		printf("%s: root hub problem, error=%d\n", 
		       USBDEVNAME(sc->sc_dev), err); 
d385 1
a385 1
			
d429 1
a429 1
		if (addr < 0 || addr >= USB_MAX_DEVICES || 
d441 1
a441 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d504 1
a504 1
		
d511 1
a511 1
		
d529 1
a529 1
	/* 
d579 1
a579 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), 
@


1.21
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.20 2002/07/09 17:41:02 nate Exp $	*/
d105 4
@


1.20
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.19 2002/05/07 18:29:18 nate Exp $	*/
a104 2

cdev_decl(usb);
@


1.19
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.17 2002/05/02 20:08:04 nate Exp $	*/
d451 1
a451 1
			  &ur->ucr_actlen);
@


1.18
log
@Sync ulpt driver with NetBSD
@
text
@d2 2
a3 1
/*	$NetBSD: usb.c,v 1.69 2002/04/23 06:34:11 augustss Exp $	*/
d6 1
a6 1
 * Copyright (c) 1998, 2002 The NetBSD Foundation, Inc.
a55 1
#include <sys/fcntl.h>
d82 1
a82 1
/*
d98 4
a101 1
	usb_proc_ptr	sc_event_thread;
a105 2
TAILQ_HEAD(, usb_task) usb_all_tasks;

a110 2
Static void	usb_task_thread(void *);
Static usb_proc_ptr usb_task_thread_proc = NULL;
d117 1
a117 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events =
d121 1
a121 1
Static usb_proc_ptr usb_async_proc;  /* process that wants USB SIGIO */
a142 1
	int speed;
d144 1
a144 1

d151 3
d157 1
a157 9
	switch (usbrev) {
	case USBREV_1_0:
	case USBREV_1_1:
		speed = USB_SPEED_FULL;
		break;
	case USBREV_2_0:
		speed = USB_SPEED_HIGH;
		break;
	default:
a158 1
		sc->sc_dying = 1;
d170 1
a170 16
#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	/* XXX we should have our own level */
	sc->sc_bus->soft = softintr_establish(IPL_SOFTNET,
	    sc->sc_bus->methods->soft_intr, sc->sc_bus);
	if (sc->sc_bus->soft == NULL) {
		printf("%s: can't register softintr\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
#else
	usb_callout_init(&sc->sc_bus->softi);
#endif
#endif

	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, speed, 0,
d176 1
a176 1
			printf("%s: root device is not a hub\n",
d182 1
a182 1
		/*
d191 2
a192 2
		printf("%s: root hub problem, error=%d\n",
		       USBDEVNAME(sc->sc_dev), err);
a208 1
	static int created = 0;
a215 9
	if (!created) {
		created = 1;
		TAILQ_INIT(&usb_all_tasks);
		if (usb_kthread_create1(usb_task_thread, NULL,
					&usb_task_thread_proc, "usbtask")) {
			printf("unable to create task thread\n");
			panic("usb_create_event_thread task");
		}
	}
d219 1
a219 1
 * Add a task to be performed by the task thread.  This function can be
d226 1
d231 2
a232 2
		DPRINTFN(2,("usb_add_task: task=%p\n", task));
		TAILQ_INSERT_TAIL(&usb_all_tasks, task, next);
d234 3
a236 4
	} else {
		DPRINTFN(3,("usb_add_task: task=%p on q\n", task));
	}
	wakeup(&usb_all_tasks);
d243 1
d248 1
a248 1
		TAILQ_REMOVE(&usb_all_tasks, task, next);
d258 2
a262 10
	/*
	 * In case this controller is a companion controller to an
	 * EHCI controller we need to wait until the EHCI controller
	 * has grabbed the port.
	 * XXX It would be nicer to do this with a tsleep(), but I don't
	 * know how to synchronize the creation of the threads so it
	 * will work.
	 */
	usb_delay_ms(sc->sc_bus, 500);

d269 14
a282 12
#ifdef USB_DEBUG
		if (usb_noexplore < 2)
#endif
		usb_discover(sc);
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
		DPRINTFN(2,("usb_event_thread: woke up\n"));
a292 26
void
usb_task_thread(void *arg)
{
	struct usb_task *task;
	int s;

	DPRINTF(("usb_task_thread: start\n"));

	s = splusb();
	for (;;) {
		task = TAILQ_FIRST(&usb_all_tasks);
		if (task == NULL) {
			tsleep(&usb_all_tasks, PWAIT, "usbtsk", 0);
			task = TAILQ_FIRST(&usb_all_tasks);
		}
		DPRINTFN(2,("usb_task_thread: woke up task=%p\n", task));
		if (task != NULL) {
			TAILQ_REMOVE(&usb_all_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
			s = splusb();
		}
	}
}

d305 1
a305 1
usbopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d360 1
a360 1
usbclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d373 1
a373 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d383 1
a383 1

a403 2
		if (!(flag & FWRITE))
			return (EBADF);
d412 1
a412 1
#endif /* USB_DEBUG */
a423 3
		if (!(flag & FWRITE))
			return (EBADF);

d427 1
a427 1
		if (addr < 0 || addr >= USB_MAX_DEVICES ||
d439 1
a439 1
				ur->ucr_request.bmRequestType & UT_READ ?
d450 2
a451 2
			  &ur->ucr_request, ptr, ur->ucr_flags, &ur->ucr_actlen,
			  USBD_DEFAULT_TIMEOUT);
d495 1
a495 1
usbpoll(dev_t dev, int events, usb_proc_ptr p)
d502 1
a502 1

d509 1
a509 1

d527 1
a527 1
	/*
d543 1
a543 1
	wakeup(&dev->bus->needs_explore);
a554 7
#ifdef DIAGNOSTIC
	if (ueq == NULL) {
		printf("usb: usb_nevents got out of sync! %d\n", usb_nevents);
		usb_nevents = 0;
		return (0);
	}
#endif
d577 1
a577 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
a609 1

d611 1
a611 1
usb_schedsoftintr(usbd_bus_handle bus)
a612 14
	DPRINTFN(10,("usb_schedsoftintr: polling=%d\n", bus->use_polling));
#ifdef USB_USE_SOFTINTR
	if (bus->use_polling) {
		bus->methods->soft_intr(bus);
	} else {
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
		softintr_schedule(bus->soft);
#else
		if (!usb_callout_pending(bus->softi))
			usb_callout(bus->softi, 0, bus->methods->soft_intr,
				    bus);
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
	}
#else
a613 1
#endif /* USB_USE_SOFTINTR */
d630 1
a630 2
		if (dev != NULL && dev->cdesc != NULL &&
		    dev->subdevs != NULL) {
d650 1
a650 1
	if (sc->sc_port.device != NULL)
d654 2
a655 2
	if (sc->sc_event_thread != NULL) {
		wakeup(&sc->sc_bus->needs_explore);
a662 11

#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	if (sc->sc_bus->soft != NULL) {
		softintr_disestablish(sc->sc_bus->soft);
		sc->sc_bus->soft = NULL;
	}
#else
	usb_uncallout(sc->sc_bus->softi, bus->methods->soft_intr, bus);
#endif
#endif
@


1.17
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 3
/*	$OpenBSD: usb.c,v 1.16 2001/10/31 04:24:44 nate Exp $	*/
/*	$NetBSD: usb.c,v 1.53 2001/01/23 17:04:30 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.c,v 1.20 1999/11/17 22:33:46 n_hibma Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d55 1
d82 1
a82 1
/* 
d98 1
a98 4
	TAILQ_HEAD(, usb_task) sc_tasks;
	struct proc    *sc_event_thread;

	struct usb_task sc_exp_task;
d103 2
d110 2
d118 1
a118 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events = 
d122 1
a122 1
Static struct proc *usb_async_proc;  /* process that wants USB SIGIO */
d144 1
d146 1
a146 1
	
a152 3
	TAILQ_INIT(&sc->sc_tasks);

	usb_init_task(&sc->sc_exp_task, usb_discover, sc);
d156 9
a164 1
	if (usbrev != USBREV_1_0 && usbrev != USBREV_1_1) {
d166 1
d178 16
a193 1
	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, 0, 0,
d199 1
a199 1
			printf("%s: root device is not a hub\n", 
d205 1
a205 1
		/* 
d214 2
a215 2
		printf("%s: root hub problem, error=%d\n", 
		       USBDEVNAME(sc->sc_dev), err); 
d232 1
d240 9
d252 1
a252 1
 * Add a task to be performed by the event thread.  This function can be
a258 1
	struct usb_softc *sc = dev->bus->usbctl;
d263 2
a264 2
		DPRINTFN(2,("usb_add_task: sc=%p task=%p\n", sc, task));
		TAILQ_INSERT_TAIL(&sc->sc_tasks, task, next);
d266 4
a269 3
	} else
		DPRINTFN(3,("usb_add_task: sc=%p task=%p on q\n", sc, task));
	wakeup(&sc->sc_tasks);
a275 1
	struct usb_softc *sc = dev->bus->usbctl;
d280 1
a280 1
		TAILQ_REMOVE(&sc->sc_tasks, task, next);
a289 2
	struct usb_task *task;
	int s;
d293 10
d309 12
a320 14
		s = splusb();
		task = TAILQ_FIRST(&sc->sc_tasks);
		if (task == NULL) {
			tsleep(&sc->sc_tasks, PWAIT, "usbevt", 0);
			task = TAILQ_FIRST(&sc->sc_tasks);
		}
		DPRINTFN(2,("usb_event_thread: woke up task=%p\n", task));
		if (task != NULL && !sc->sc_dying) {
			TAILQ_REMOVE(&sc->sc_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
		} else
			splx(s);
d331 26
d369 1
a369 1
usbopen(dev_t dev, int flag, int mode, struct proc *p)
d424 1
a424 1
usbclose(dev_t dev, int flag, int mode, struct proc *p)
d437 1
a437 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, struct proc *p)
d447 1
a447 1
			
d468 2
d478 1
a478 1
#endif
d490 3
d496 1
a496 1
		if (addr < 0 || addr >= USB_MAX_DEVICES || 
d508 1
a508 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d519 2
a520 2
			  &ur->ucr_request, ptr, ur->ucr_flags,
			  &ur->ucr_actlen);
d564 1
a564 1
usbpoll(dev_t dev, int events, struct proc *p)
d571 1
a571 1
		
d578 1
a578 1
		
d596 1
a596 1
	/* 
d612 1
a612 1
	usb_add_task(dev, &dev->bus->usbctl->sc_exp_task);
d624 7
d653 1
a653 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), 
d686 1
d688 1
a688 1
usb_schedsoftintr(struct usbd_bus *bus)
d690 14
d705 1
d722 2
a723 1
		if (dev && dev->cdesc && dev->subdevs) {
d743 1
a743 1
	if (sc->sc_port.device)
d747 2
a748 2
	if (sc->sc_event_thread) {
		wakeup(&sc->sc_tasks);
d756 11
@


1.16
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.15 2001/05/03 02:20:34 aaron Exp $	*/
d416 1
a416 1
		int len = UGETW(ur->request.wLength);
d420 1
a420 1
		int addr = ur->addr;
d431 1
a431 1
			iov.iov_base = (caddr_t)ur->data;
d439 1
a439 1
				ur->request.bmRequestType & UT_READ ? 
d450 2
a451 1
			  &ur->request, ptr, ur->flags, &ur->actlen);
d472 1
a472 1
		int addr = di->addr;
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.16 2001/10/31 04:24:44 nate Exp $	*/
d416 1
a416 1
		int len = UGETW(ur->ucr_request.wLength);
d420 1
a420 1
		int addr = ur->ucr_addr;
d431 1
a431 1
			iov.iov_base = (caddr_t)ur->ucr_data;
d439 1
a439 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d450 1
a450 2
			  &ur->ucr_request, ptr, ur->ucr_flags,
			  &ur->ucr_actlen);
d471 1
a471 1
		int addr = di->udi_addr;
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.16.2.1 2002/06/11 03:42:31 art Exp $	*/
d82 1
a82 1
/*
a105 1
#if defined(__NetBSD__)
a106 1
#endif
d117 1
a117 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events =
d144 1
a144 1

d176 1
a176 1
			printf("%s: root device is not a hub\n",
d182 1
a182 1
		/*
d191 2
a192 2
		printf("%s: root hub problem, error=%d\n",
		       USBDEVNAME(sc->sc_dev), err);
d383 1
a383 1

d427 1
a427 1
		if (addr < 0 || addr >= USB_MAX_DEVICES ||
d439 1
a439 1
				ur->ucr_request.bmRequestType & UT_READ ?
d451 1
a451 1
			  &ur->ucr_actlen, USBD_DEFAULT_TIMEOUT);
d502 1
a502 1

d509 1
a509 1

d527 1
a527 1
	/*
d577 1
a577 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
@


1.15
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.14 2001/01/28 09:43:42 aaron Exp $	*/
d235 1
a235 1
	DPRINTFN(3,("usb_add_task: sc=%p task=%p on q\n", sc, task));
@


1.14
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.13 2000/11/08 18:10:38 aaron Exp $	*/
/*	$NetBSD: usb.c,v 1.47 2000/08/24 14:12:34 augustss Exp $	*/
a51 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a54 6
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/filio.h>
#include <sys/uio.h>
#endif
a66 8
#if defined(__FreeBSD__)
MALLOC_DEFINE(M_USB, "USB", "USB");
MALLOC_DEFINE(M_USBDEV, "USBdev", "USB device");
MALLOC_DEFINE(M_USBHC, "USBHC", "USB host controller");

#include "usb_if.h"
#endif /* defined(__FreeBSD__) */

d98 1
a98 4
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
	struct selinfo	sc_consel;	/* waiting for connect change */
#else
d100 2
a101 1
#endif
a105 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a106 24
#elif defined(__FreeBSD__)
d_open_t  usbopen; 
d_close_t usbclose;
d_read_t usbread;
d_ioctl_t usbioctl;
int usbpoll(dev_t, int, struct proc *);

struct cdevsw usb_cdevsw = {
	/* open */      usbopen,
	/* close */     usbclose,
	/* read */      noread,
	/* write */     nowrite,
	/* ioctl */     usbioctl,
	/* poll */      usbpoll,
	/* mmap */      nommap,
	/* strategy */  nostrategy,
	/* name */      "usb",
	/* maj */       USB_CDEV_MAJOR,
	/* dump */      nodump,
	/* psize */     nopsize,
	/* flags */     0,
	/* bmaj */      -1
};
#endif
d108 1
a108 1
Static usbd_status usb_discover(struct usb_softc *);
a138 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a139 4
#elif defined(__FreeBSD__)
	struct usb_softc *sc = device_get_softc(self);
	void *aux = device_get_ivars(self);
#endif
a144 5
#if defined(__FreeBSD__)
	printf("%s", USBDEVNAME(sc->sc_dev));
	sc->sc_dev = self;
#endif

d151 3
a200 5
#if defined(__FreeBSD__)
	make_dev(&usb_cdevsw, device_get_unit(self), UID_ROOT, GID_OPERATOR,
		 0644, "usb%d", device_get_unit(self));
#endif

d218 36
d258 2
a259 1
	int first = 1;
d265 2
d269 5
a273 7
#ifdef USB_DEBUG
		if (usb_noexplore < 2)
#endif
		usb_discover(sc);
		if (first) {
			config_pending_decr();
			first = 0;
d275 8
a282 8
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
		DPRINTFN(2,("usb_event_thread: woke up\n"));
d284 1
a284 1
	sc->sc_event_thread = 0;
a401 6
#if defined(__FreeBSD__) 
	/* This part should be deleted when kthreads is available */
  	case USB_DISCOVER:
  		usb_discover(sc);
  		break;
#endif
a510 19
#if defined(__FreeBSD__)
		/* This part should be deleted when kthreads is available */
		struct usb_softc *sc;
		int unit = minor(dev);

		USB_GET_SC(usb, unit, sc);

		revents = 0;
		mask = POLLOUT | POLLRDNORM;

		s = splusb();
		if (events & mask && sc->sc_bus->needs_explore)
			revents |= events & mask;
		if (revents == 0 && events & mask)
			selrecord(p, &sc->sc_consel);
		splx(s);

		return (revents);
#else
a511 1
#endif
d516 2
a517 2
usbd_status
usb_discover(struct usb_softc *sc)
d519 6
a524 3
#if defined(__FreeBSD__)
	/* The splxxx parts should be deleted when kthreads is available */
	int s;
a525 1

a530 3
#if defined(__FreeBSD__)
	s = splusb();
#endif
a532 3
#if defined(__FreeBSD__)
		splx(s);
#endif
a533 3
#if defined(__FreeBSD__)
		s = splusb();
#endif
a534 5
#if defined(__FreeBSD__)
	splx(s);
#endif

	return (USBD_NORMAL_COMPLETION);
d538 1
a538 1
usb_needs_explore(usbd_bus_handle bus)
d540 3
a542 6
	bus->needs_explore = 1;
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
	selwakeup(&bus->usbctl->sc_consel);
#endif
	wakeup(&bus->needs_explore);
a614 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d654 1
a654 1
		wakeup(&sc->sc_bus->needs_explore);
a667 15
#elif defined(__FreeBSD__)
int
usb_detach(device_t self)
{
	DPRINTF(("%s: unload, prevented\n", USBDEVNAME(self)));

	return (EINVAL);
}
#endif


#if defined(__FreeBSD__)
DRIVER_MODULE(usb, ohci, usb_driver, usb_devclass, 0, 0);
DRIVER_MODULE(usb, uhci, usb_driver, usb_devclass, 0, 0);
#endif
@


1.13
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.12 2000/07/04 11:44:24 fgsch Exp $	*/
d502 1
a502 1
		usbd_fill_deviceinfo(dev, di);
d624 1
a624 1
	usbd_fill_deviceinfo(udev, &ue.u.ue_device);
@


1.12
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.11 2000/03/30 16:19:33 aaron Exp $	*/
/*	$NetBSD: usb.c,v 1.43 2000/03/29 18:24:53 augustss Exp $	*/
d130 1
a130 1
int usbpoll __P((dev_t, int, struct proc *));
d150 3
a152 3
Static usbd_status usb_discover __P((struct usb_softc *));
Static void	usb_create_event_thread __P((void *));
Static void	usb_event_thread __P((void *));
d163 1
a163 1
Static struct proc *usb_async_proc;  /* process who wants USB SIGIO */
d165 1
a165 1
Static void usb_add_event __P((int, struct usb_event *));
d167 1
a167 6
Static int usb_get_next_event __P((struct usb_event *));

#if defined(__NetBSD__) || defined(__OpenBSD__)
/* Flag to see if we are in the cold boot process. */
extern int cold;
#endif
d260 1
a260 2
usb_create_event_thread(arg)
	void *arg;
d273 1
a273 2
usb_event_thread(arg)
	void *arg;
d311 1
a311 3
usbctlprint(aux, pnp)
	void *aux;
	const char *pnp;
d322 1
a322 4
usbopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d344 1
a344 4
usbread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d377 1
a377 4
usbclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d390 1
a390 6
usbioctl(devt, cmd, data, flag, p)
	dev_t devt;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d517 1
a517 4
usbpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d560 1
a560 2
usb_discover(sc)
	struct usb_softc *sc;
d593 1
a593 2
usb_needs_explore(bus)
	usbd_bus_handle bus;
d605 1
a605 2
usb_get_next_event(ue)
	struct usb_event *ue;
d620 1
a620 3
usbd_add_dev_event(type, udev)
	int type;
	usbd_device_handle udev;
d629 1
a629 4
usbd_add_drv_event(type, udev, dev)
	int type;
	usbd_device_handle udev;
	device_ptr_t dev;
d640 1
a640 3
usb_add_event(type, uep)
	int type;
	struct usb_event *uep;
d668 1
a668 2
usb_schedsoftintr(bus)
	struct usbd_bus *bus;
d675 1
a675 3
usb_activate(self, act)
	device_ptr_t self;
	enum devact act;
d698 1
a698 3
usb_detach(self, flags)
	device_ptr_t self;
	int flags;
@


1.11
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.10 2000/03/28 19:37:50 aaron Exp $	*/
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d299 4
d304 1
a304 2
#ifdef USB_DEBUG
			     usb_noexplore ? 0 :
a305 2
			     hz*60
			);
@


1.10
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.9 2000/03/26 21:47:51 aaron Exp $	*/
/*	$NetBSD: usb.c,v 1.41 2000/03/16 00:46:38 augustss Exp $	*/
d150 3
a152 3
static usbd_status usb_discover __P((struct usb_softc *));
static void	usb_create_event_thread __P((void *));
static void	usb_event_thread __P((void *));
d159 1
a159 1
static SIMPLEQ_HEAD(, usb_event_q) usb_events = 
d161 5
a165 5
static int usb_nevents = 0;
static struct selinfo usb_selevent;
static struct proc *usb_async_proc;  /* process who wants USB SIGIO */
static int usb_dev_open = 0;
static void usb_add_event __P((int, struct usb_event *));
d167 1
a167 1
static int usb_get_next_event __P((struct usb_event *));
d174 1
a174 1
static const char *usbrev_str[] = USBREV_STR;
a251 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
d253 1
a253 4
	kthread_create(usb_create_event_thread, sc);
#else
	kthread_create_deferred(usb_create_event_thread, sc);
#endif
d270 1
a270 1
	if (kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,
a282 1
#if defined(__NetBSD__)
a283 1
#endif
a294 1
#if defined(__NetBSD__)
a298 1
#endif
d672 1
a672 1
static void
@


1.9
log
@Fix typos.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.8 2000/03/26 08:39:46 aaron Exp $	*/
d3 1
d92 1
a92 1
int uhcidebug;
d95 1
a95 1
int ohcidebug;
d97 1
a97 1
/*
d113 1
a113 1
#if defined (__FreeBSD__)
d150 3
a152 3
usbd_status usb_discover __P((struct usb_softc *));
void	usb_create_event_thread __P((void *));
void	usb_event_thread __P((void *));
d159 7
a165 6
SIMPLEQ_HEAD(, usb_event_q) usb_events = SIMPLEQ_HEAD_INITIALIZER(usb_events);
int usb_nevents = 0;
struct selinfo usb_selevent;
struct proc *usb_async_proc;  /* process who wants USB SIGIO */
int usb_dev_open = 0;
void usb_add_event __P((int, struct usb_event *));
d167 1
a167 1
int usb_get_next_event __P((struct usb_event *));
d196 1
a196 1

d225 1
a225 1
			    &sc->sc_port);
d235 1
a235 1
#if 0
d246 1
a246 1
		       USBDEVNAME(sc->sc_dev), err);
d252 4
d257 1
a273 1
#if defined(__NetBSD__)
a274 3
#else
	if (kthread_create(usb_event_thread, sc, &sc->sc_event_thread,
#endif
d287 3
d301 6
d393 1
a393 1
		error = uiomove((caddr_t)&ue, uio->uio_resid, uio);
d457 1
a457 1
		usbdebug = ((*(int *)data) & 0x000000ff);
d503 1
a503 1
		    &ur->request, ptr, ur->flags, &ur->actlen);
d557 1
a557 1

d564 1
a564 1

d600 1
d675 1
a675 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
d680 1
a680 1
void
@


1.8
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usb.c,v 1.7 1999/11/11 15:57:40 ho Exp $	*/
d239 1
a239 1
		if (cold && (sc->sc_dev.dv_cfdata->cf_flags & 1)
d542 1
a542 1
	if (minor(dev) != USB_DEV_MINOR) {
d553 1
a553 1
		return(revents);
d609 1
@


1.7
log
@Delay USB device attachment to prevent lost interrupts when probing uaudio.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: usb.c,v 1.28 1999/10/13 08:10:57 augustss Exp $	*/
d54 1
d58 1
a58 1
#include <sys/ioccom.h>
a62 1
#include <sys/proc.h>
d90 11
a100 2
int	uhcidebug;
int	ohcidebug;
d112 2
d115 1
d117 1
d127 1
d153 1
a153 1
#define USB_MAX_EVENTS 50
d163 1
d167 1
d170 3
d191 6
a196 5
	usbd_status r;
	
#if defined(__NetBSD__) || defined(__OpenBSD__)
	printf("\n");
#elif defined(__FreeBSD__)
d201 1
d206 17
a222 1
	r = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, 0, 0,
d224 1
a224 2

	if (r == USBD_NORMAL_COMPLETION) {
d226 1
a226 1
		if (!dev->hub) {
d239 1
a239 2
		if (cold) {
			sc->sc_bus->use_polling++;
a240 2
			sc->sc_bus->use_polling--;
		}
d244 1
a244 1
		       USBDEVNAME(sc->sc_dev), r); 
d247 2
a249 3
#if defined(__NetBSD__) 
	kthread_create(usb_create_event_thread, sc);
#elif defined(__OpenBSD__)
a250 1
#endif
d287 3
d292 1
a292 1
		if (!usb_noexplore)
d295 6
a300 2
		(void)tsleep(&sc->sc_bus->needs_explore, 
			     PWAIT, "usbevt", hz*60);
d438 1
d445 7
a451 1
		usbdebug = uhcidebug = ohcidebug = *(int *)data;
d462 1
a462 1
		usbd_status r;
d490 3
a492 4
		r = usbd_do_request_flags(sc->sc_bus->devices[addr],
					  &ur->request, ptr, 
					  ur->flags, &ur->actlen);
		if (r != USBD_NORMAL_COMPLETION) {
d513 1
a513 1
		usbd_device_handle devh;
d517 2
a518 2
		devh = sc->sc_bus->devices[addr];
		if (devh == 0)
d520 1
a520 1
		usbd_fill_deviceinfo(devh, di);
d542 22
a563 2
	if (minor(dev) != USB_DEV_MINOR)
		return (ENXIO);
d565 2
a566 5
	revents = 0;
	s = splusb();
	mask = POLLIN | POLLRDNORM;
	if (events & mask)
		if (usb_nevents > 0)
d568 3
d572 4
a575 6
	DPRINTFN(2, ("usbpoll: revents=0x%x\n", revents));
	if (revents == 0) {
		if (events & mask) {
			DPRINTFN(2, ("usbpoll: selrecord\n"));
			selrecord(p, &usb_selevent);
		}
a576 2
	splx(s);
	return (revents);
d584 4
d593 4
a596 1
	do {
d598 3
d602 7
a608 1
	} while (sc->sc_bus->needs_explore && !sc->sc_dying);
d617 4
d642 12
a653 1
usbd_add_event(type, devh)
d655 15
a669 1
	usbd_device_handle devh;
d676 7
a688 12
	/* Don't want to wait here inside splusb() */
	ueq = malloc(sizeof *ueq, M_USBDEV, M_NOWAIT);
	if (ueq == 0) {
		printf("usb: no memory, event dropped\n");
		splx(s);
		return;
	}
	ueq->ue.ue_type = type;
	ueq->ue.ue_cookie = devh->cookie;
	usbd_fill_deviceinfo(devh, &ueq->ue.ue_device);
	microtime(&thetime);
	TIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);
d692 1
a692 1
	if (usb_async_proc)
d696 6
d735 1
d755 4
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usb.c,v 1.14 2001/01/28 09:43:42 aaron Exp $	*/
/*	$NetBSD: usb.c,v 1.47 2000/08/24 14:12:34 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usb.c,v 1.20 1999/11/17 22:33:46 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a53 1
#include <sys/proc.h>
d57 1
a57 1
#include <sys/filio.h>
d62 1
a89 1
#ifdef UHCI_DEBUG
a90 2
#endif
#ifdef OHCI_DEBUG
a91 6
#endif
/* 
 * 0  - do usual exploration
 * 1  - do not use timeout exploration
 * >1 - do no exploration
 */
a102 2
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
a103 1
#else
a104 1
#endif
a113 1
d_read_t usbread;
d115 1
a115 1
int usbpoll(dev_t, int, struct proc *);
d135 3
a137 3
Static usbd_status usb_discover(struct usb_softc *);
Static void	usb_create_event_thread(void *);
Static void	usb_event_thread(void *);
d139 1
a139 1
#define USB_MAX_EVENTS 100
d144 5
a148 7
Static SIMPLEQ_HEAD(, usb_event_q) usb_events = 
	SIMPLEQ_HEAD_INITIALIZER(usb_events);
Static int usb_nevents = 0;
Static struct selinfo usb_selevent;
Static struct proc *usb_async_proc;  /* process that wants USB SIGIO */
Static int usb_dev_open = 0;
Static void usb_add_event(int, struct usb_event *);
d150 1
a150 1
Static int usb_get_next_event(struct usb_event *);
d152 2
a153 1
Static const char *usbrev_str[] = USBREV_STR;
d172 1
a172 3
	usbd_status err;
	int usbrev;
	struct usb_event ue;
d174 3
a176 2
#if defined(__FreeBSD__)
	printf("%s", USBDEVNAME(sc->sc_dev));
a180 1

d185 2
d188 1
a188 18
	usbrev = sc->sc_bus->usbrev;
	printf(": USB revision %s", usbrev_str[usbrev]);
	if (usbrev != USBREV_1_0 && usbrev != USBREV_1_1) {
		printf(", not supported\n");
		USB_ATTACH_ERROR_RETURN;
	}
	printf("\n");

	/* Make sure not to use tsleep() if we are cold booting. */
	if (cold)
		sc->sc_bus->use_polling++;

	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
	usb_add_event(USB_EVENT_CTRLR_ATTACH, &ue);

	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, 0, 0,
		  &sc->sc_port);
	if (!err) {
d190 1
a190 1
		if (dev->hub == NULL) {
d197 1
a197 1
#if 1
d203 2
a204 1
		if (cold && (sc->sc_dev.dv_cfdata->cf_flags & 1))
d206 2
d211 1
a211 1
		       USBDEVNAME(sc->sc_dev), err); 
a213 2
	if (cold)
		sc->sc_bus->use_polling--;
d215 5
a219 2
	config_pending_incr();
	usb_kthread_create(usb_create_event_thread, sc);
d231 2
a232 1
usb_create_event_thread(void *arg)
d236 5
a240 1
	if (usb_kthread_create1(usb_event_thread, sc, &sc->sc_event_thread,
d249 2
a250 1
usb_event_thread(void *arg)
a252 1
	int first = 1;
a255 3
	/* Make sure first discover does something. */
	sc->sc_bus->needs_explore = 1;

d258 1
a258 1
		if (usb_noexplore < 2)
d261 2
a262 11
		if (first) {
			config_pending_decr();
			first = 0;
		}
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
d275 3
a277 1
usbctlprint(void *aux, const char *pnp)
d288 4
a291 1
usbopen(dev_t dev, int flag, int mode, struct proc *p)
d313 4
a316 1
usbread(dev_t dev, struct uio *uio, int flag)
d343 1
a343 1
		error = uiomove((void *)&ue, uio->uio_resid, uio);
d349 4
a352 1
usbclose(dev_t dev, int flag, int mode, struct proc *p)
d365 6
a370 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, struct proc *p)
a399 1
	/* This part should be deleted when kthreads is available */
d406 1
a406 7
		usbdebug  = ((*(int *)data) & 0x000000ff);
#ifdef UHCI_DEBUG
		uhcidebug = ((*(int *)data) & 0x0000ff00) >> 8;
#endif
#ifdef OHCI_DEBUG
		ohcidebug = ((*(int *)data) & 0x00ff0000) >> 16;
#endif
d417 1
a417 1
		usbd_status err;
d445 4
a448 3
		err = usbd_do_request_flags(sc->sc_bus->devices[addr],
			  &ur->request, ptr, ur->flags, &ur->actlen);
		if (err) {
d469 1
a469 1
		usbd_device_handle dev;
d473 2
a474 2
		dev = sc->sc_bus->devices[addr];
		if (dev == NULL)
d476 1
a476 1
		usbd_fill_deviceinfo(dev, di, 1);
d491 4
a494 1
usbpoll(dev_t dev, int events, struct proc *p)
d498 2
a499 17
	if (minor(dev) == USB_DEV_MINOR) {
		revents = 0;
		mask = POLLIN | POLLRDNORM;
		
		s = splusb();
		if (events & mask && usb_nevents > 0)
			revents |= events & mask;
		if (revents == 0 && events & mask)
			selrecord(p, &usb_selevent);
		splx(s);
		
		return (revents);
	} else {
#if defined(__FreeBSD__)
		/* This part should be deleted when kthreads is available */
		struct usb_softc *sc;
		int unit = minor(dev);
d501 5
a505 7
		USB_GET_SC(usb, unit, sc);

		revents = 0;
		mask = POLLOUT | POLLRDNORM;

		s = splusb();
		if (events & mask && sc->sc_bus->needs_explore)
a506 3
		if (revents == 0 && events & mask)
			selrecord(p, &sc->sc_consel);
		splx(s);
d508 6
a513 4
		return (revents);
#else
		return (ENXIO);
#endif
d515 2
d521 2
a522 1
usb_discover(struct usb_softc *sc)
a523 5
#if defined(__FreeBSD__)
	/* The splxxx parts should be deleted when kthreads is available */
	int s;
#endif

d529 1
a529 4
#if defined(__FreeBSD__)
	s = splusb();
#endif
	while (sc->sc_bus->needs_explore && !sc->sc_dying) {
a530 3
#if defined(__FreeBSD__)
		splx(s);
#endif
d532 1
a532 8
#if defined(__FreeBSD__)
		s = splusb();
#endif
	}
#if defined(__FreeBSD__)
	splx(s);
#endif

d537 2
a538 1
usb_needs_explore(usbd_bus_handle bus)
a540 4
#if defined(__FreeBSD__)
	/* This part should be deleted when kthreads is available */
	selwakeup(&bus->usbctl->sc_consel);
#endif
d546 2
a547 1
usb_get_next_event(struct usb_event *ue)
d562 3
a564 21
usbd_add_dev_event(int type, usbd_device_handle udev)
{
	struct usb_event ue;

	usbd_fill_deviceinfo(udev, &ue.u.ue_device, USB_EVENT_IS_ATTACH(type));
	usb_add_event(type, &ue);
}

void
usbd_add_drv_event(int type, usbd_device_handle udev, device_ptr_t dev)
{
	struct usb_event ue;

	ue.u.ue_driver.ue_cookie = udev->cookie;
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev), 
	    sizeof ue.u.ue_driver.ue_devname);
	usb_add_event(type, &ue);
}

Static void
usb_add_event(int type, struct usb_event *uep)
a570 7
	microtime(&thetime);
	/* Don't want to wait here inside splusb() */
	ueq = malloc(sizeof *ueq, M_USBDEV, M_WAITOK);
	ueq->ue = *uep;
	ueq->ue.ue_type = type;
	TIMEVAL_TO_TIMESPEC(&thetime, &ueq->ue.ue_time);

d577 12
d592 1
a592 1
	if (usb_async_proc != NULL)
a595 5
void
usb_schedsoftintr(struct usbd_bus *bus)
{
	bus->methods->soft_intr(bus);
}
d599 3
a601 1
usb_activate(device_ptr_t self, enum devact act)
d624 3
a626 1
usb_detach(device_ptr_t self, int flags)
a628 1
	struct usb_event ue;
a647 4

	ue.u.ue_ctrlr.ue_bus = USBDEVUNIT(sc->sc_dev);
	usb_add_event(USB_EVENT_CTRLR_DETACH, &ue);

@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usb.c,v 1.53 2001/01/23 17:04:30 augustss Exp $	*/
d52 1
d56 6
d74 8
d113 4
a116 1
	TAILQ_HEAD(, usb_task) sc_tasks;
d118 1
a118 2

	struct usb_task sc_exp_task;
d123 1
d125 24
d150 1
a150 1
Static void	usb_discover(void *);
d181 1
d183 4
d192 5
a202 3
	TAILQ_INIT(&sc->sc_tasks);

	usb_init_task(&sc->sc_exp_task, usb_discover, sc);
d250 5
a271 36
/*
 * Add a task to be performed by the event thread.  This function can be
 * called from any context and the task will be executed in a process
 * context ASAP.
 */
void
usb_add_task(usbd_device_handle dev, struct usb_task *task)
{
	struct usb_softc *sc = dev->bus->usbctl;
	int s;

	s = splusb();
	if (!task->onqueue) {
		DPRINTFN(2,("usb_add_task: sc=%p task=%p\n", sc, task));
		TAILQ_INSERT_TAIL(&sc->sc_tasks, task, next);
		task->onqueue = 1;
	} else
	DPRINTFN(3,("usb_add_task: sc=%p task=%p on q\n", sc, task));
	wakeup(&sc->sc_tasks);
	splx(s);
}

void
usb_rem_task(usbd_device_handle dev, struct usb_task *task)
{
	struct usb_softc *sc = dev->bus->usbctl;
	int s;

	s = splusb();
	if (task->onqueue) {
		TAILQ_REMOVE(&sc->sc_tasks, task, next);
		task->onqueue = 0;
	}
	splx(s);
}

d276 1
a276 2
	struct usb_task *task;
	int s;
a281 2
	usb_discover(sc);
	config_pending_decr();
d284 7
a290 5
		s = splusb();
		task = TAILQ_FIRST(&sc->sc_tasks);
		if (task == NULL) {
			tsleep(&sc->sc_tasks, PWAIT, "usbevt", 0);
			task = TAILQ_FIRST(&sc->sc_tasks);
d292 8
a299 8
		DPRINTFN(2,("usb_event_thread: woke up task=%p\n", task));
		if (task != NULL && !sc->sc_dying) {
			TAILQ_REMOVE(&sc->sc_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
		} else
			splx(s);
d301 1
a301 1
	sc->sc_event_thread = NULL;
d419 6
d534 19
d554 1
d559 2
a560 2
Static void
usb_discover(void *v)
d562 4
a565 1
	struct usb_softc *sc = v;
a566 5
	DPRINTFN(2,("usb_discover\n"));
#ifdef USB_DEBUG
	if (usb_noexplore > 1)
		return;
#endif
d572 3
d577 3
d581 3
d585 5
d593 1
a593 1
usb_needs_explore(usbd_device_handle dev)
d595 6
a600 3
	DPRINTFN(2,("usb_needs_explore\n"));
	dev->bus->needs_explore = 1;
	usb_add_task(dev, &dev->bus->usbctl->sc_exp_task);
d673 1
d713 1
a713 1
		wakeup(&sc->sc_tasks);
d727 15
@


1.7.2.3
log
@Merge in -current
@
text
@d235 1
a235 1
		DPRINTFN(3,("usb_add_task: sc=%p task=%p on q\n", sc, task));
@


1.7.2.4
log
@Sync the SMP branch with 3.3
@
text
@d82 1
a82 1
/*
a105 1
#if defined(__NetBSD__)
a106 1
#endif
d117 1
a117 1
Static SIMPLEQ_HEAD(, usb_event_q) usb_events =
d144 1
a144 1

d176 1
a176 1
			printf("%s: root device is not a hub\n",
d182 1
a182 1
		/*
d191 2
a192 2
		printf("%s: root hub problem, error=%d\n",
		       USBDEVNAME(sc->sc_dev), err);
d383 1
a383 1

d416 1
a416 1
		int len = UGETW(ur->ucr_request.wLength);
d420 1
a420 1
		int addr = ur->ucr_addr;
d427 1
a427 1
		if (addr < 0 || addr >= USB_MAX_DEVICES ||
d431 1
a431 1
			iov.iov_base = (caddr_t)ur->ucr_data;
d439 1
a439 1
				ur->ucr_request.bmRequestType & UT_READ ?
d450 1
a450 2
			  &ur->ucr_request, ptr, ur->ucr_flags,
			  &ur->ucr_actlen, USBD_DEFAULT_TIMEOUT);
d471 1
a471 1
		int addr = di->udi_addr;
d501 1
a501 1

d508 1
a508 1

d526 1
a526 1
	/*
d576 1
a576 1
	strncpy(ue.u.ue_driver.ue_devname, USBDEVPTRNAME(dev),
@


1.7.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 2
a3 1
/*	$NetBSD: usb.c,v 1.77 2003/01/01 00:10:26 thorpej Exp $	*/
d6 1
a6 1
 * Copyright (c) 1998, 2002 The NetBSD Foundation, Inc.
d44 2
a45 2
 * http://www.usb.org/developers/docs/ and
 * http://www.usb.org/developers/devclass_docs/
a47 3
#include "ohci.h"
#include "uhci.h"

a55 1
#include <sys/fcntl.h>
d76 2
a77 2
#if defined(UHCI_DEBUG) && NUHCI > 0
extern int	uhcidebug;
d79 2
a80 2
#if defined(OHCI_DEBUG) && NOHCI > 0
extern int	ohcidebug;
d98 4
a101 1
	usb_proc_ptr	sc_event_thread;
a105 2
TAILQ_HEAD(, usb_task) usb_all_tasks;

d107 1
a107 11
dev_type_open(usbopen);
dev_type_close(usbclose);
dev_type_read(usbread);
dev_type_ioctl(usbioctl);
dev_type_poll(usbpoll);
dev_type_kqfilter(usbkqfilter);

const struct cdevsw usb_cdevsw = {
	usbopen, usbclose, usbread, nowrite, usbioctl,
	nostop, notty, usbpoll, nommap, usbkqfilter,
};
a112 2
Static void	usb_task_thread(void *);
Static usb_proc_ptr usb_task_thread_proc = NULL;
d123 1
a123 1
Static usb_proc_ptr usb_async_proc;  /* process that wants USB SIGIO */
a144 1
	int speed;
d153 3
d159 1
a159 9
	switch (usbrev) {
	case USBREV_1_0:
	case USBREV_1_1:
		speed = USB_SPEED_FULL;
		break;
	case USBREV_2_0:
		speed = USB_SPEED_HIGH;
		break;
	default:
a160 1
		sc->sc_dying = 1;
d172 1
a172 16
#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	/* XXX we should have our own level */
	sc->sc_bus->soft = softintr_establish(IPL_SOFTNET,
	    sc->sc_bus->methods->soft_intr, sc->sc_bus);
	if (sc->sc_bus->soft == NULL) {
		printf("%s: can't register softintr\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
#else
	usb_callout_init(sc->sc_bus->softi);
#endif
#endif

	err = usbd_new_device(USBDEV(sc->sc_dev), sc->sc_bus, 0, speed, 0,
a210 1
	static int created = 0;
a217 9
	if (!created) {
		created = 1;
		TAILQ_INIT(&usb_all_tasks);
		if (usb_kthread_create1(usb_task_thread, NULL,
					&usb_task_thread_proc, "usbtask")) {
			printf("unable to create task thread\n");
			panic("usb_create_event_thread task");
		}
	}
d221 1
a221 1
 * Add a task to be performed by the task thread.  This function can be
d228 1
d233 2
a234 2
		DPRINTFN(2,("usb_add_task: task=%p\n", task));
		TAILQ_INSERT_TAIL(&usb_all_tasks, task, next);
d236 3
a238 4
	} else {
		DPRINTFN(3,("usb_add_task: task=%p on q\n", task));
	}
	wakeup(&usb_all_tasks);
d245 1
d250 1
a250 1
		TAILQ_REMOVE(&usb_all_tasks, task, next);
d260 2
d271 14
a284 12
#ifdef USB_DEBUG
		if (usb_noexplore < 2)
#endif
		usb_discover(sc);
#ifdef USB_DEBUG
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    usb_noexplore ? 0 : hz * 60);
#else
		(void)tsleep(&sc->sc_bus->needs_explore, PWAIT, "usbevt",
		    hz * 60);
#endif
		DPRINTFN(2,("usb_event_thread: woke up\n"));
a294 26
void
usb_task_thread(void *arg)
{
	struct usb_task *task;
	int s;

	DPRINTF(("usb_task_thread: start\n"));

	s = splusb();
	for (;;) {
		task = TAILQ_FIRST(&usb_all_tasks);
		if (task == NULL) {
			tsleep(&usb_all_tasks, PWAIT, "usbtsk", 0);
			task = TAILQ_FIRST(&usb_all_tasks);
		}
		DPRINTFN(2,("usb_task_thread: woke up task=%p\n", task));
		if (task != NULL) {
			TAILQ_REMOVE(&usb_all_tasks, task, next);
			task->onqueue = 0;
			splx(s);
			task->fun(task->arg);
			s = splusb();
		}
	}
}

d307 1
a307 1
usbopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d362 1
a362 1
usbclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d375 1
a375 1
usbioctl(dev_t devt, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
a405 2
		if (!(flag & FWRITE))
			return (EBADF);
d407 1
a407 1
#if defined(UHCI_DEBUG) && NUHCI > 0
d410 1
a410 1
#if defined(OHCI_DEBUG) && NOHCI > 0
d414 1
a414 1
#endif /* USB_DEBUG */
a425 3
		if (!(flag & FWRITE))
			return (EBADF);

d497 1
a497 1
usbpoll(dev_t dev, int events, usb_proc_ptr p)
a517 55
Static void filt_usbrdetach(struct knote *);
Static int filt_usbread(struct knote *, long);
int usbkqfilter(dev_t, struct knote *);

Static void
filt_usbrdetach(struct knote *kn)
{
	int s;

	s = splusb();
	SLIST_REMOVE(&usb_selevent.sel_klist, kn, knote, kn_selnext);
	splx(s);
}

Static int
filt_usbread(struct knote *kn, long hint)
{

	if (usb_nevents == 0)
		return (0);

	kn->kn_data = sizeof(struct usb_event);
	return (1);
}

Static struct filterops usbread_filtops =
	{ 1, NULL, filt_usbrdetach, filt_usbread };

int
usbkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		if (minor(dev) != USB_DEV_MINOR)
			return (1);
		klist = &usb_selevent.sel_klist;
		kn->kn_fop = &usbread_filtops;
		break;

	default:
		return (1);
	}

	kn->kn_hook = NULL;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

d545 1
a545 1
	wakeup(&dev->bus->needs_explore);
a556 7
#ifdef DIAGNOSTIC
	if (ueq == NULL) {
		printf("usb: usb_nevents got out of sync! %d\n", usb_nevents);
		usb_nevents = 0;
		return (0);
	}
#endif
a611 1

d613 1
a613 1
usb_schedsoftintr(usbd_bus_handle bus)
a614 14
	DPRINTFN(10,("usb_schedsoftintr: polling=%d\n", bus->use_polling));
#ifdef USB_USE_SOFTINTR
	if (bus->use_polling) {
		bus->methods->soft_intr(bus);
	} else {
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
		softintr_schedule(bus->soft);
#else
		if (!usb_callout_pending(bus->softi))
			usb_callout(bus->softi, 0, bus->methods->soft_intr,
				    bus);
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
	}
#else
a615 1
#endif /* USB_USE_SOFTINTR */
d628 1
d632 1
a632 2
		if (dev != NULL && dev->cdesc != NULL &&
		    dev->subdevs != NULL) {
d652 1
a652 1
	if (sc->sc_port.device != NULL)
d656 2
a657 2
	if (sc->sc_event_thread != NULL) {
		wakeup(&sc->sc_bus->needs_explore);
a664 11

#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	if (sc->sc_bus->soft != NULL) {
		softintr_disestablish(sc->sc_bus->soft);
		sc->sc_bus->soft = NULL;
	}
#else
	usb_uncallout(sc->sc_bus->softi, bus->methods->soft_intr, bus);
#endif
#endif
@


1.7.2.6
log
@Merge with the trunk
@
text
@d692 1
a692 1
	SIMPLEQ_REMOVE_HEAD(&usb_events, next);
@


1.6
log
@sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d197 1
a197 1
#if 1
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usb.c,v 1.24 1999/09/15 21:10:11 augustss Exp $	*/
a58 1
#include <sys/conf.h>
d64 2
d71 2
a97 4
int usb_nbus = 0;

#define USBUNIT(dev) (minor(dev))

d118 14
a131 4
	usbopen,     usbclose,    noread,         nowrite,
	usbioctl,    nullstop,    nullreset,      nodevtotty,
	usbpoll,     nommap,      nostrat,
	"usb",        NULL,   -1
d139 13
d155 1
a155 1
USB_DECLARE_DRIVER_INIT(usb, DEVMETHOD(bus_print_child, usbd_print_child));
d215 3
a217 1
#if defined(__OpenBSD__)
a218 2
#else
	kthread_create(usb_create_event_thread, sc);
d221 5
a225 1
	usb_nbus++;
d229 1
d236 1
a236 1
#if !defined(__OpenBSD__)
d254 2
d270 1
a273 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d285 1
a285 1
#endif
d293 12
a304 1
	USB_GET_SC_OPEN(usb, USBUNIT(dev), sc);
a305 2
	if (sc == 0)
		return (ENXIO);
d313 36
d354 7
d365 2
a366 2
usbioctl(dev, cmd, data, flag, p)
	dev_t dev;
d372 22
a393 1
	USB_GET_SC(usb, USBUNIT(dev), sc);
d399 5
d469 1
a469 1
		usbd_device_handle dev;
d473 2
a474 2
		dev = sc->sc_bus->devices[addr];
		if (dev == 0)
d476 1
a476 1
		usbd_fill_deviceinfo(dev, di);
d485 1
a485 1
		return (ENXIO);
d496 1
a496 2
	int revents, s;
	USB_GET_SC(usb, USBUNIT(dev), sc);
d498 2
a499 2
	if (sc->sc_dying)
		return (EIO);
d501 1
a501 1
	DPRINTFN(2, ("usbpoll: sc=%p events=0x%x\n", sc, events));
d503 5
a507 4
	revents = 0;
	if (events & (POLLOUT | POLLWRNORM))
		if (sc->sc_bus->needs_explore)
			revents |= events & (POLLOUT | POLLWRNORM);
d510 1
a510 1
		if (events & (POLLOUT | POLLWRNORM)) {
d512 1
a512 1
			selrecord(p, &sc->sc_consel);
a540 1
	selwakeup(&bus->usbctl->sc_consel);
d544 54
d630 2
d636 1
a636 1
		usb_disconnect_port(&sc->sc_port);
d644 1
d647 1
a647 1
	usb_nbus--;
d650 1
a650 1

d652 1
a652 4
usbread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d654 3
a656 2
	/* XXX */
	return (0);
d658 2
d662 2
a663 1
DRIVER_MODULE(usb, root, usb_driver, usb_devclass, 0, 0);
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.3 1999/08/19 08:18:39 fgsch Exp $	*/
/*	$NetBSD: usb.c,v 1.17 1999/08/17 16:06:21 augustss Exp $	*/
d61 1
d78 2
d89 1
d95 2
d100 1
a100 1
	bdevice sc_dev;			/* base device */
d103 5
a107 5
	char sc_running;
	char sc_exploring;
	struct selinfo sc_consel;	/* waiting for connect change */
	int shutdown;
	struct proc *event_thread;
d111 1
a111 5
int usbopen __P((dev_t, int, int, struct proc *));
int usbclose __P((dev_t, int, int, struct proc *));
int usbioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int usbpoll __P((dev_t, int, struct proc *));

d130 3
a161 2
	sc->sc_running = 1;
	sc->sc_bus->use_polling = 1;
d163 2
a164 1
	r = usbd_new_device(&sc->sc_dev, sc->sc_bus, 0,0,0, &sc->sc_port);
d169 1
a169 1
			sc->sc_running = 0;
d175 12
a186 1
		dev->hub->explore(sc->sc_bus->root_hub);
d190 1
a190 1
		sc->sc_running = 0;
a191 1
	sc->sc_bus->use_polling = 0;
d199 1
d210 1
a210 1
	if (kthread_create1(usb_event_thread, sc, &sc->event_thread,
d212 1
a212 1
	if (kthread_create(usb_event_thread, sc, &sc->event_thread,
d227 5
a231 1
	while (!sc->shutdown) {
d233 1
a233 1
			     PWAIT, "usbevt", hz*30);
a234 1
		usb_discover(sc);
d236 1
a236 1
	sc->event_thread = 0;
d266 1
a266 1
	if (sc == 0 || !sc->sc_running)
d268 2
d293 3
a295 2
	if (sc == 0 || !sc->sc_running)
		return (ENXIO);
a301 5
#if 0
	case USB_DISCOVER:
		usb_discover(sc);
		break;
#endif
d392 3
d412 1
a412 30
#if 0
int
usb_bus_count()
{
	int i, n;

	for (i = n = 0; i < usb_cd.cd_ndevs; i++)
		if (usb_cd.cd_devs[i])
			n++;
	return (n);
}
#endif

#if 0
usbd_status
usb_get_bus_handle(n, h)
	int n;
	usbd_bus_handle *h;
{
	int i;

	for (i = 0; i < usb_cd.cd_ndevs; i++)
		if (usb_cd.cd_devs[i] && n-- == 0) {
			*h = usb_cd.cd_devs[i];
			return (USBD_NORMAL_COMPLETION);
		}
	return (USBD_INVAL);
}
#endif

d417 5
a421 4
	int s;

	/* Explore device tree from the root */
	/* We need mutual exclusion while traversing the device tree. */
a422 4
		s = splusb();
		while (sc->sc_exploring)
			tsleep(&sc->sc_exploring, PRIBIO, "usbdis", 0);
		sc->sc_exploring = 1;
a423 2
		splx(s);
		
d425 1
a425 6
		
		s = splusb();
		sc->sc_exploring = 0;
		wakeup(&sc->sc_exploring);
		splx(s);
	} while (sc->sc_bus->needs_explore);
d440 1
a440 1
	bdevice *self;
d443 18
a460 2
	panic("usb_activate\n");
	return (0);
d465 1
a465 1
	bdevice *self;
d468 27
a494 1
	panic("usb_detach\n");
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d460 1
a460 1
	struct device *self;
d469 1
a469 1
	struct device  *self;
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: usb.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: usb.c,v 1.15 1999/08/02 19:36:48 augustss Exp $	*/
d194 3
a196 1
#if defined(__OpenBSD__)
a197 2
#else
	if (kthread_create1(usb_event_thread, sc, &sc->event_thread,
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 2
a82 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
@

