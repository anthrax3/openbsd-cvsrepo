head	1.65;
access;
symbols
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.65
date	2017.07.03.09.21.09;	author kevlo;	state Exp;
branches;
next	1.64;
commitid	Ssa221KhuyTS2oq4;

1.64
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.63;
commitid	VyLWTsbepAOk7VQM;

1.63
date	2017.01.09.14.44.28;	author mpi;	state Exp;
branches;
next	1.62;
commitid	UdDbQS8WFHHpnq1k;

1.62
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.61;
commitid	gWZDkudwxydTq8x4;

1.61
date	2015.12.18.19.43.14;	author stsp;	state Exp;
branches;
next	1.60;
commitid	AuzbUgPYIryNDtBs;

1.60
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.59;
commitid	B0kwmVGiD5DVx4kv;

1.59
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.58;
commitid	FuSD2mFDJWATHIDx;

1.58
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.57;
commitid	5DvsamK0GblTp8ww;

1.57
date	2015.11.13.10.36.29;	author mpi;	state Exp;
branches;
next	1.56;
commitid	pVgZpZmw966Haagb;

1.56
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.55;
commitid	YT6fyIEviv9qwbl6;

1.55
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.54;
commitid	pwYnMC1gOKohmeGw;

1.54
date	2015.07.15.17.52.08;	author stsp;	state Exp;
branches;
next	1.53;
commitid	if6ldOoBsZ7MNbdx;

1.53
date	2015.06.12.15.47.31;	author mpi;	state Exp;
branches;
next	1.52;
commitid	t0sjCnxjbRqHxJe2;

1.52
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.51;
commitid	p4LJxGKbi0BU2cG6;

1.51
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.50;
commitid	Hly9lJn6CNMylcFu;

1.50
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.49;
commitid	yM2VFFhpDTeFQlve;

1.49
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.48;
commitid	LS2TNeCue5R9L67C;

1.48
date	2014.09.01.16.02.06;	author mpi;	state Exp;
branches;
next	1.47;
commitid	HSLuGBijD1eAB82C;

1.47
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.46;
commitid	Pclvgy2Z4XV9hveD;

1.46
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.45;
commitid	b0VSac5dnnsxcDao;

1.45
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.42;

1.42
date	2013.07.10.05.59.02;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.11.21.04.46;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.30.05.22.51;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.21.21.30.42;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.29.18.14.57;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.29.18.08.44;	author martynas;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.29.18.01.31;	author martynas;	state Exp;
branches;
next	1.23;

1.23
date	2009.06.24.01.07.12;	author martynas;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.21.00.49.13;	author martynas;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.06.12.06.28;	author martynas;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.05.01.21.02;	author martynas;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.04.23.42.02;	author martynas;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.04.21.52.10;	author martynas;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.04.21.21.15;	author martynas;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.04.21.06.52;	author martynas;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.04.20.51.44;	author martynas;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.04.20.07.34;	author martynas;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.04.19.53.17;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.04.19.45.36;	author martynas;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.04.19.37.26;	author martynas;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.04.19.30.19;	author martynas;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.04.19.27.27;	author martynas;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.04.19.11.48;	author martynas;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.10.09.48.46;	author kevlo;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.03.07.49.27;	author kevlo;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.11.10.44.36;	author kevlo;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.27.21.14.35;	author martynas;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.10.01.31.31;	author kevlo;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.03.10.44.17;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.27.14.08.07;	author kevlo;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Replace slot time durations with macros.

ok stsp@@
@
text
@/*	$OpenBSD: if_urtw.c,v 1.64 2017/01/22 10:17:39 dlg Exp $	*/

/*-
 * Copyright (c) 2009 Martynas Venckus <martynas@@openbsd.org>
 * Copyright (c) 2008 Weongyo Jeong <weongyo@@FreeBSD.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_urtwreg.h>

#ifdef URTW_DEBUG
#define	DPRINTF(x)	do { if (urtw_debug) printf x; } while (0)
#define	DPRINTFN(n, x)	do { if (urtw_debug >= (n)) printf x; } while (0)
int urtw_debug = 0;
#else
#define	DPRINTF(x)
#define	DPRINTFN(n, x)
#endif

/*
 * Recognized device vendors/products.
 */
static const struct urtw_type {
	struct usb_devno	dev;
	uint8_t			rev;
} urtw_devs[] = {
#define	URTW_DEV_RTL8187(v, p)	\
	    { { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, URTW_HWREV_8187 }
#define	URTW_DEV_RTL8187B(v, p)	\
	    { { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }, URTW_HWREV_8187B }
	/* Realtek RTL8187 devices. */
	URTW_DEV_RTL8187(ASUS,		P5B_WIFI),
	URTW_DEV_RTL8187(DICKSMITH,	RTL8187),
	URTW_DEV_RTL8187(LINKSYS4,	WUSB54GCV2),
	URTW_DEV_RTL8187(LOGITEC,	RTL8187),
	URTW_DEV_RTL8187(NETGEAR,	WG111V2),
	URTW_DEV_RTL8187(REALTEK,	RTL8187),
	URTW_DEV_RTL8187(SITECOMEU,	WL168V1),
	URTW_DEV_RTL8187(SPHAIRON,	RTL8187),
	URTW_DEV_RTL8187(SURECOM,	EP9001G2A),
	/* Realtek RTL8187B devices. */
	URTW_DEV_RTL8187B(BELKIN,	F5D7050E),
	URTW_DEV_RTL8187B(NETGEAR,	WG111V3),
	URTW_DEV_RTL8187B(REALTEK,	RTL8187B_0),
	URTW_DEV_RTL8187B(REALTEK,	RTL8187B_1),
	URTW_DEV_RTL8187B(REALTEK,	RTL8187B_2),
	URTW_DEV_RTL8187B(SITECOMEU,	WL168V4)
#undef	URTW_DEV_RTL8187
#undef	URTW_DEV_RTL8187B
};
#define	urtw_lookup(v, p)	\
	    ((const struct urtw_type *)usb_lookup(urtw_devs, v, p))

/*
 * Helper read/write macros.
 */
#define urtw_read8_m(sc, val, data)	do {			\
	error = urtw_read8_c(sc, val, data, 0);			\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_read8_idx_m(sc, val, data, idx)	do {		\
	error = urtw_read8_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write8_m(sc, val, data)	do {			\
	error = urtw_write8_c(sc, val, data, 0);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write8_idx_m(sc, val, data, idx)	do {		\
	error = urtw_write8_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_read16_m(sc, val, data)	do {			\
	error = urtw_read16_c(sc, val, data, 0);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_read16_idx_m(sc, val, data, idx)	do {		\
	error = urtw_read16_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write16_m(sc, val, data)	do {			\
	error = urtw_write16_c(sc, val, data, 0);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write16_idx_m(sc, val, data, idx)	do {		\
	error = urtw_write16_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_read32_m(sc, val, data)	do {			\
	error = urtw_read32_c(sc, val, data, 0);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_read32_idx_m(sc, val, data, idx)	do {		\
	error = urtw_read32_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write32_m(sc, val, data)	do {			\
	error = urtw_write32_c(sc, val, data, 0);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_write32_idx_m(sc, val, data, idx)	do {		\
	error = urtw_write32_c(sc, val, data, idx);		\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_8187_write_phy_ofdm(sc, val, data)	do {		\
	error = urtw_8187_write_phy_ofdm_c(sc, val, data);	\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_8187_write_phy_cck(sc, val, data)	do {		\
	error = urtw_8187_write_phy_cck_c(sc, val, data);	\
	if (error != 0)						\
		goto fail;					\
} while (0)
#define urtw_8225_write(sc, val, data)	do {			\
	error = urtw_8225_write_c(sc, val, data);		\
	if (error != 0)						\
		goto fail;					\
} while (0)

struct urtw_pair {
	uint32_t	reg;
	uint32_t	val;
};

struct urtw_pair_idx {
	uint8_t		reg;
	uint8_t		val;
	uint8_t		idx;
};

static struct urtw_pair_idx urtw_8187b_regtbl[] = {
	{ 0xf0, 0x32, 0 }, { 0xf1, 0x32, 0 }, { 0xf2, 0x00, 0 },
	{ 0xf3, 0x00, 0 }, { 0xf4, 0x32, 0 }, { 0xf5, 0x43, 0 },
	{ 0xf6, 0x00, 0 }, { 0xf7, 0x00, 0 }, { 0xf8, 0x46, 0 },
	{ 0xf9, 0xa4, 0 }, { 0xfa, 0x00, 0 }, { 0xfb, 0x00, 0 },
	{ 0xfc, 0x96, 0 }, { 0xfd, 0xa4, 0 }, { 0xfe, 0x00, 0 },
	{ 0xff, 0x00, 0 },

	{ 0x58, 0x4b, 1 }, { 0x59, 0x00, 1 }, { 0x5a, 0x4b, 1 },
	{ 0x5b, 0x00, 1 }, { 0x60, 0x4b, 1 }, { 0x61, 0x09, 1 },
	{ 0x62, 0x4b, 1 }, { 0x63, 0x09, 1 }, { 0xce, 0x0f, 1 },
	{ 0xcf, 0x00, 1 }, { 0xe0, 0xff, 1 }, { 0xe1, 0x0f, 1 },
	{ 0xe2, 0x00, 1 }, { 0xf0, 0x4e, 1 }, { 0xf1, 0x01, 1 },
	{ 0xf2, 0x02, 1 }, { 0xf3, 0x03, 1 }, { 0xf4, 0x04, 1 },
	{ 0xf5, 0x05, 1 }, { 0xf6, 0x06, 1 }, { 0xf7, 0x07, 1 },
	{ 0xf8, 0x08, 1 },

	{ 0x4e, 0x00, 2 }, { 0x0c, 0x04, 2 }, { 0x21, 0x61, 2 },
	{ 0x22, 0x68, 2 }, { 0x23, 0x6f, 2 }, { 0x24, 0x76, 2 },
	{ 0x25, 0x7d, 2 }, { 0x26, 0x84, 2 }, { 0x27, 0x8d, 2 },
	{ 0x4d, 0x08, 2 }, { 0x50, 0x05, 2 }, { 0x51, 0xf5, 2 },
	{ 0x52, 0x04, 2 }, { 0x53, 0xa0, 2 }, { 0x54, 0x1f, 2 },
	{ 0x55, 0x23, 2 }, { 0x56, 0x45, 2 }, { 0x57, 0x67, 2 },
	{ 0x58, 0x08, 2 }, { 0x59, 0x08, 2 }, { 0x5a, 0x08, 2 },
	{ 0x5b, 0x08, 2 }, { 0x60, 0x08, 2 }, { 0x61, 0x08, 2 },
	{ 0x62, 0x08, 2 }, { 0x63, 0x08, 2 }, { 0x64, 0xcf, 2 },
	{ 0x72, 0x56, 2 }, { 0x73, 0x9a, 2 },

	{ 0x34, 0xf0, 0 }, { 0x35, 0x0f, 0 }, { 0x5b, 0x40, 0 },
	{ 0x84, 0x88, 0 }, { 0x85, 0x24, 0 }, { 0x88, 0x54, 0 },
	{ 0x8b, 0xb8, 0 }, { 0x8c, 0x07, 0 }, { 0x8d, 0x00, 0 },
	{ 0x94, 0x1b, 0 }, { 0x95, 0x12, 0 }, { 0x96, 0x00, 0 },
	{ 0x97, 0x06, 0 }, { 0x9d, 0x1a, 0 }, { 0x9f, 0x10, 0 },
	{ 0xb4, 0x22, 0 }, { 0xbe, 0x80, 0 }, { 0xdb, 0x00, 0 },
	{ 0xee, 0x00, 0 }, { 0x91, 0x03, 0 },

	{ 0x4c, 0x00, 2 }, { 0x9f, 0x00, 3 }, { 0x8c, 0x01, 0 },
	{ 0x8d, 0x10, 0 }, { 0x8e, 0x08, 0 }, { 0x8f, 0x00, 0 }
};

static uint8_t urtw_8225_agc[] = {
	0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9e, 0x9d, 0x9c, 0x9b,
	0x9a, 0x99, 0x98, 0x97, 0x96, 0x95, 0x94, 0x93, 0x92, 0x91, 0x90,
	0x8f, 0x8e, 0x8d, 0x8c, 0x8b, 0x8a, 0x89, 0x88, 0x87, 0x86, 0x85,
	0x84, 0x83, 0x82, 0x81, 0x80, 0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a,
	0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2f,
	0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24,
	0x23, 0x22, 0x21, 0x20, 0x1f, 0x1e, 0x1d, 0x1c, 0x1b, 0x1a, 0x19,
	0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0f, 0x0e,
	0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03,
	0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
};

static uint32_t urtw_8225_channel[] = {
	0x0000,		/* dummy channel 0 */
	0x085c,		/* 1 */
	0x08dc,		/* 2 */
	0x095c,		/* 3 */
	0x09dc,		/* 4 */
	0x0a5c,		/* 5 */
	0x0adc,		/* 6 */
	0x0b5c,		/* 7 */
	0x0bdc,		/* 8 */
	0x0c5c,		/* 9 */
	0x0cdc,		/* 10 */
	0x0d5c,		/* 11 */
	0x0ddc,		/* 12 */
	0x0e5c,		/* 13 */
	0x0f72,		/* 14 */
};

static uint8_t urtw_8225_gain[] = {
	0x23, 0x88, 0x7c, 0xa5,		/* -82dbm */
	0x23, 0x88, 0x7c, 0xb5,		/* -82dbm */
	0x23, 0x88, 0x7c, 0xc5,		/* -82dbm */
	0x33, 0x80, 0x79, 0xc5,		/* -78dbm */
	0x43, 0x78, 0x76, 0xc5,		/* -74dbm */
	0x53, 0x60, 0x73, 0xc5,		/* -70dbm */
	0x63, 0x58, 0x70, 0xc5,		/* -66dbm */
};

static struct urtw_pair urtw_8225_rf_part1[] = {
	{ 0x00, 0x0067 }, { 0x01, 0x0fe0 }, { 0x02, 0x044d }, { 0x03, 0x0441 },
	{ 0x04, 0x0486 }, { 0x05, 0x0bc0 }, { 0x06, 0x0ae6 }, { 0x07, 0x082a },
	{ 0x08, 0x001f }, { 0x09, 0x0334 }, { 0x0a, 0x0fd4 }, { 0x0b, 0x0391 },
	{ 0x0c, 0x0050 }, { 0x0d, 0x06db }, { 0x0e, 0x0029 }, { 0x0f, 0x0914 }
};

static struct urtw_pair urtw_8225_rf_part2[] = {
	{ 0x00, 0x01 }, { 0x01, 0x02 }, { 0x02, 0x42 }, { 0x03, 0x00 },
	{ 0x04, 0x00 }, { 0x05, 0x00 }, { 0x06, 0x40 }, { 0x07, 0x00 },
	{ 0x08, 0x40 }, { 0x09, 0xfe }, { 0x0a, 0x09 }, { 0x0b, 0x80 },
	{ 0x0c, 0x01 }, { 0x0e, 0xd3 }, { 0x0f, 0x38 }, { 0x10, 0x84 },
	{ 0x11, 0x06 }, { 0x12, 0x20 }, { 0x13, 0x20 }, { 0x14, 0x00 },
	{ 0x15, 0x40 }, { 0x16, 0x00 }, { 0x17, 0x40 }, { 0x18, 0xef },
	{ 0x19, 0x19 }, { 0x1a, 0x20 }, { 0x1b, 0x76 }, { 0x1c, 0x04 },
	{ 0x1e, 0x95 }, { 0x1f, 0x75 }, { 0x20, 0x1f }, { 0x21, 0x27 },
	{ 0x22, 0x16 }, { 0x24, 0x46 }, { 0x25, 0x20 }, { 0x26, 0x90 },
	{ 0x27, 0x88 }
};

static struct urtw_pair urtw_8225_rf_part3[] = {
	{ 0x00, 0x98 }, { 0x03, 0x20 }, { 0x04, 0x7e }, { 0x05, 0x12 },
	{ 0x06, 0xfc }, { 0x07, 0x78 }, { 0x08, 0x2e }, { 0x10, 0x9b },
	{ 0x11, 0x88 }, { 0x12, 0x47 }, { 0x13, 0xd0 }, { 0x19, 0x00 },
	{ 0x1a, 0xa0 }, { 0x1b, 0x08 }, { 0x40, 0x86 }, { 0x41, 0x8d },
	{ 0x42, 0x15 }, { 0x43, 0x18 }, { 0x44, 0x1f }, { 0x45, 0x1e },
	{ 0x46, 0x1a }, { 0x47, 0x15 }, { 0x48, 0x10 }, { 0x49, 0x0a },
	{ 0x4a, 0x05 }, { 0x4b, 0x02 }, { 0x4c, 0x05 }
};

static uint16_t urtw_8225_rxgain[] = {
	0x0400, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0408, 0x0409,
	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,
	0x0542, 0x0543, 0x0544, 0x0545, 0x0580, 0x0581, 0x0582, 0x0583,
	0x0584, 0x0585, 0x0588, 0x0589, 0x058a, 0x058b, 0x0643, 0x0644,
	0x0645, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684, 0x0685, 0x0688,
	0x0689, 0x068a, 0x068b, 0x068c, 0x0742, 0x0743, 0x0744, 0x0745,
	0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0788, 0x0789,
	0x078a, 0x078b, 0x078c, 0x078d, 0x0790, 0x0791, 0x0792, 0x0793,
	0x0794, 0x0795, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,
	0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a8, 0x07a9,
	0x07aa, 0x07ab, 0x07ac, 0x07ad, 0x07b0, 0x07b1, 0x07b2, 0x07b3,
	0x07b4, 0x07b5, 0x07b8, 0x07b9, 0x07ba, 0x07bb, 0x07bb
};

static uint8_t urtw_8225_threshold[] = {
	0x8d, 0x8d, 0x8d, 0x8d, 0x9d, 0xad, 0xbd
};

static uint8_t urtw_8225_tx_gain_cck_ofdm[] = {
	0x02, 0x06, 0x0e, 0x1e, 0x3e, 0x7e
};

static uint8_t urtw_8225_txpwr_cck[] = {
	0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02,
	0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02,
	0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02,
	0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02,
	0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03,
	0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03
};

static uint8_t urtw_8225_txpwr_cck_ch14[] = {
	0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00,
	0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00,
	0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00,
	0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00,
	0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00
};

static uint8_t urtw_8225_txpwr_ofdm[] = {
	0x80, 0x90, 0xa2, 0xb5, 0xcb, 0xe4
};

static uint8_t urtw_8225v2_agc[] = {
	0x5e, 0x5e, 0x5e, 0x5e, 0x5d, 0x5b, 0x59, 0x57,
	0x55, 0x53, 0x51, 0x4f, 0x4d, 0x4b, 0x49, 0x47,
	0x45, 0x43, 0x41, 0x3f, 0x3d, 0x3b, 0x39, 0x37,
	0x35, 0x33, 0x31, 0x2f, 0x2d, 0x2b, 0x29, 0x27,
	0x25, 0x23, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x17,
	0x15, 0x13, 0x11, 0x0f, 0x0d, 0x0b, 0x09, 0x07,
	0x05, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19, 0x19,
	0x19, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
	0x26, 0x27, 0x27, 0x28, 0x28, 0x29, 0x2a, 0x2a,
	0x2a, 0x2b, 0x2b, 0x2b, 0x2c, 0x2c, 0x2c, 0x2d,
	0x2d, 0x2d, 0x2d, 0x2e, 0x2e, 0x2e, 0x2e, 0x2f,
	0x2f, 0x2f, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31
};

static uint8_t urtw_8225v2_ofdm[] = {
	0x10, 0x0d, 0x01, 0x00, 0x14, 0xfb, 0xfb, 0x60,
	0x00, 0x60, 0x00, 0x00, 0x00, 0x5c, 0x00, 0x00,
	0x40, 0x00, 0x40, 0x00, 0x00, 0x00, 0xa8, 0x26,
	0x32, 0x33, 0x07, 0xa5, 0x6f, 0x55, 0xc8, 0xb3,
	0x0a, 0xe1, 0x2c, 0x8a, 0x86, 0x83, 0x34, 0x0f,
	0x4f, 0x24, 0x6f, 0xc2, 0x6b, 0x40, 0x80, 0x00,
	0xc0, 0xc1, 0x58, 0xf1, 0x00, 0xe4, 0x90, 0x3e,
	0x6d, 0x3c, 0xfb, 0x07
};

static uint8_t urtw_8225v2_gain_bg[] = {
	0x23, 0x15, 0xa5,		/* -82-1dbm */
	0x23, 0x15, 0xb5,		/* -82-2dbm */
	0x23, 0x15, 0xc5,		/* -82-3dbm */
	0x33, 0x15, 0xc5,		/* -78dbm */
	0x43, 0x15, 0xc5,		/* -74dbm */
	0x53, 0x15, 0xc5,		/* -70dbm */
	0x63, 0x15, 0xc5,		/* -66dbm */
};

static struct urtw_pair urtw_8225v2_rf_part1[] = {
	{ 0x00, 0x02bf }, { 0x01, 0x0ee0 }, { 0x02, 0x044d }, { 0x03, 0x0441 },
	{ 0x04, 0x08c3 }, { 0x05, 0x0c72 }, { 0x06, 0x00e6 }, { 0x07, 0x082a },
	{ 0x08, 0x003f }, { 0x09, 0x0335 }, { 0x0a, 0x09d4 }, { 0x0b, 0x07bb },
	{ 0x0c, 0x0850 }, { 0x0d, 0x0cdf }, { 0x0e, 0x002b }, { 0x0f, 0x0114 }
};

static struct urtw_pair urtw_8225v2_rf_part2[] = {
	{ 0x00, 0x01 }, { 0x01, 0x02 }, { 0x02, 0x42 }, { 0x03, 0x00 },
	{ 0x04, 0x00 }, { 0x05, 0x00 }, { 0x06, 0x40 }, { 0x07, 0x00 },
	{ 0x08, 0x40 }, { 0x09, 0xfe }, { 0x0a, 0x08 }, { 0x0b, 0x80 },
	{ 0x0c, 0x01 }, { 0x0d, 0x43 }, { 0x0e, 0xd3 }, { 0x0f, 0x38 },
	{ 0x10, 0x84 }, { 0x11, 0x07 }, { 0x12, 0x20 }, { 0x13, 0x20 },
	{ 0x14, 0x00 }, { 0x15, 0x40 }, { 0x16, 0x00 }, { 0x17, 0x40 },
	{ 0x18, 0xef }, { 0x19, 0x19 }, { 0x1a, 0x20 }, { 0x1b, 0x15 },
	{ 0x1c, 0x04 }, { 0x1d, 0xc5 }, { 0x1e, 0x95 }, { 0x1f, 0x75 },
	{ 0x20, 0x1f }, { 0x21, 0x17 }, { 0x22, 0x16 }, { 0x23, 0x80 },
	{ 0x24, 0x46 }, { 0x25, 0x00 }, { 0x26, 0x90 }, { 0x27, 0x88 }
};

static struct urtw_pair urtw_8225v2_rf_part3[] = {
	{ 0x00, 0x98 }, { 0x03, 0x20 }, { 0x04, 0x7e }, { 0x05, 0x12 },
	{ 0x06, 0xfc }, { 0x07, 0x78 }, { 0x08, 0x2e }, { 0x09, 0x11 },
	{ 0x0a, 0x17 }, { 0x0b, 0x11 }, { 0x10, 0x9b }, { 0x11, 0x88 },
	{ 0x12, 0x47 }, { 0x13, 0xd0 }, { 0x19, 0x00 }, { 0x1a, 0xa0 },
	{ 0x1b, 0x08 }, { 0x1d, 0x00 }, { 0x40, 0x86 }, { 0x41, 0x9d },
	{ 0x42, 0x15 }, { 0x43, 0x18 }, { 0x44, 0x36 }, { 0x45, 0x35 },
	{ 0x46, 0x2e }, { 0x47, 0x25 }, { 0x48, 0x1c }, { 0x49, 0x12 },
	{ 0x4a, 0x09 }, { 0x4b, 0x04 }, { 0x4c, 0x05 }
};

static uint16_t urtw_8225v2_rxgain[] = {
	0x0400, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0408, 0x0409,
	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,
	0x0542, 0x0543, 0x0544, 0x0545, 0x0580, 0x0581, 0x0582, 0x0583,
	0x0584, 0x0585, 0x0588, 0x0589, 0x058a, 0x058b, 0x0643, 0x0644,
	0x0645, 0x0680, 0x0681, 0x0682, 0x0683, 0x0684, 0x0685, 0x0688,
	0x0689, 0x068a, 0x068b, 0x068c, 0x0742, 0x0743, 0x0744, 0x0745,
	0x0780, 0x0781, 0x0782, 0x0783, 0x0784, 0x0785, 0x0788, 0x0789,
	0x078a, 0x078b, 0x078c, 0x078d, 0x0790, 0x0791, 0x0792, 0x0793,
	0x0794, 0x0795, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,
	0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a8, 0x07a9,
	0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03b2, 0x03b3,
	0x03b4, 0x03b5, 0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bb
};

static uint8_t urtw_8225v2_tx_gain_cck_ofdm[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
	0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
	0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11,
	0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
	0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23
};

static uint8_t urtw_8225v2_txpwr_cck[] = {
	0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04,
	0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03,
	0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03,
	0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03
};

static uint8_t urtw_8225v2_txpwr_cck_ch14[] = {
	0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x2f, 0x29, 0x15, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x2f, 0x29, 0x15, 0x00, 0x00, 0x00, 0x00,
	0x30, 0x2f, 0x29, 0x15, 0x00, 0x00, 0x00, 0x00
};

static struct urtw_pair urtw_8225v2_b_rf[] = {
	{ 0x00, 0x00b7 }, { 0x01, 0x0ee0 }, { 0x02, 0x044d }, { 0x03, 0x0441 },
	{ 0x04, 0x08c3 }, { 0x05, 0x0c72 }, { 0x06, 0x00e6 }, { 0x07, 0x082a },
	{ 0x08, 0x003f }, { 0x09, 0x0335 }, { 0x0a, 0x09d4 }, { 0x0b, 0x07bb },
	{ 0x0c, 0x0850 }, { 0x0d, 0x0cdf }, { 0x0e, 0x002b }, { 0x0f, 0x0114 },
	{ 0x00, 0x01b7 }
};

static struct urtw_pair urtw_ratetable[] = {
	{  2,  0 }, {   4,  1 }, { 11, 2 }, { 12, 4 }, { 18, 5 },
	{ 22,  3 }, {  24,  6 }, { 36, 7 }, { 48, 8 }, { 72, 9 },
	{ 96, 10 }, { 108, 11 }
};

int		urtw_init(struct ifnet *);
void		urtw_stop(struct ifnet *, int);
int		urtw_ioctl(struct ifnet *, u_long, caddr_t);
void		urtw_start(struct ifnet *);
int		urtw_alloc_rx_data_list(struct urtw_softc *);
void		urtw_free_rx_data_list(struct urtw_softc *);
int		urtw_alloc_tx_data_list(struct urtw_softc *);
void		urtw_free_tx_data_list(struct urtw_softc *);
void		urtw_rxeof(struct usbd_xfer *, void *,
		    usbd_status);
int		urtw_tx_start(struct urtw_softc *,
		    struct ieee80211_node *, struct mbuf *, int);
void		urtw_txeof_low(struct usbd_xfer *, void *,
		    usbd_status);
void		urtw_txeof_normal(struct usbd_xfer *, void *,
		    usbd_status);
void		urtw_next_scan(void *);
void		urtw_task(void *);
void		urtw_ledusbtask(void *);
void		urtw_ledtask(void *);
int		urtw_media_change(struct ifnet *);
int		urtw_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		urtw_watchdog(struct ifnet *);
void		urtw_set_multi(struct urtw_softc *);
void		urtw_set_chan(struct urtw_softc *, struct ieee80211_channel *);
int		urtw_isbmode(uint16_t);
uint16_t	urtw_rate2rtl(int rate);
uint16_t	urtw_rtl2rate(int);
usbd_status	urtw_set_rate(struct urtw_softc *);
usbd_status	urtw_update_msr(struct urtw_softc *);
usbd_status	urtw_read8_c(struct urtw_softc *, int, uint8_t *, uint8_t);
usbd_status	urtw_read16_c(struct urtw_softc *, int, uint16_t *, uint8_t);
usbd_status	urtw_read32_c(struct urtw_softc *, int, uint32_t *, uint8_t);
usbd_status	urtw_write8_c(struct urtw_softc *, int, uint8_t, uint8_t);
usbd_status	urtw_write16_c(struct urtw_softc *, int, uint16_t, uint8_t);
usbd_status	urtw_write32_c(struct urtw_softc *, int, uint32_t, uint8_t);
usbd_status	urtw_eprom_cs(struct urtw_softc *, int);
usbd_status	urtw_eprom_ck(struct urtw_softc *);
usbd_status	urtw_eprom_sendbits(struct urtw_softc *, int16_t *,
		    int);
usbd_status	urtw_eprom_read32(struct urtw_softc *, uint32_t,
		    uint32_t *);
usbd_status	urtw_eprom_readbit(struct urtw_softc *, int16_t *);
usbd_status	urtw_eprom_writebit(struct urtw_softc *, int16_t);
usbd_status	urtw_get_macaddr(struct urtw_softc *);
usbd_status	urtw_get_txpwr(struct urtw_softc *);
usbd_status	urtw_get_rfchip(struct urtw_softc *);
usbd_status	urtw_led_init(struct urtw_softc *);
usbd_status	urtw_8185_rf_pins_enable(struct urtw_softc *);
usbd_status	urtw_8185_tx_antenna(struct urtw_softc *, uint8_t);
usbd_status	urtw_8187_write_phy(struct urtw_softc *, uint8_t, uint32_t);
usbd_status	urtw_8187_write_phy_ofdm_c(struct urtw_softc *, uint8_t,
		    uint32_t);
usbd_status	urtw_8187_write_phy_cck_c(struct urtw_softc *, uint8_t,
		    uint32_t);
usbd_status	urtw_8225_setgain(struct urtw_softc *, int16_t);
usbd_status	urtw_8225_usb_init(struct urtw_softc *);
usbd_status	urtw_8225_write_c(struct urtw_softc *, uint8_t, uint16_t);
usbd_status	urtw_8225_write_s16(struct urtw_softc *, uint8_t, int,
		    uint16_t);
usbd_status	urtw_8225_read(struct urtw_softc *, uint8_t, uint32_t *);
usbd_status	urtw_8225_rf_init(struct urtw_rf *);
usbd_status	urtw_8225_rf_set_chan(struct urtw_rf *, int);
usbd_status	urtw_8225_rf_set_sens(struct urtw_rf *);
usbd_status	urtw_8225_set_txpwrlvl(struct urtw_softc *, int);
usbd_status	urtw_8225v2_rf_init(struct urtw_rf *);
usbd_status	urtw_8225v2_rf_set_chan(struct urtw_rf *, int);
usbd_status	urtw_8225v2_set_txpwrlvl(struct urtw_softc *, int);
usbd_status	urtw_8225v2_setgain(struct urtw_softc *, int16_t);
usbd_status	urtw_8225_isv2(struct urtw_softc *, int *);
usbd_status	urtw_read8e(struct urtw_softc *, int, uint8_t *);
usbd_status	urtw_write8e(struct urtw_softc *, int, uint8_t);
usbd_status	urtw_8180_set_anaparam(struct urtw_softc *, uint32_t);
usbd_status	urtw_8185_set_anaparam2(struct urtw_softc *, uint32_t);
usbd_status	urtw_open_pipes(struct urtw_softc *);
usbd_status	urtw_close_pipes(struct urtw_softc *);
usbd_status	urtw_intr_enable(struct urtw_softc *);
usbd_status	urtw_intr_disable(struct urtw_softc *);
usbd_status	urtw_reset(struct urtw_softc *);
usbd_status	urtw_led_on(struct urtw_softc *, int);
usbd_status	urtw_led_ctl(struct urtw_softc *, int);
usbd_status	urtw_led_blink(struct urtw_softc *);
usbd_status	urtw_led_mode0(struct urtw_softc *, int);
usbd_status	urtw_led_mode1(struct urtw_softc *, int);
usbd_status	urtw_led_mode2(struct urtw_softc *, int);
usbd_status	urtw_led_mode3(struct urtw_softc *, int);
usbd_status	urtw_rx_setconf(struct urtw_softc *);
usbd_status	urtw_rx_enable(struct urtw_softc *);
usbd_status	urtw_tx_enable(struct urtw_softc *);
usbd_status	urtw_8187b_update_wmm(struct urtw_softc *);
usbd_status	urtw_8187b_reset(struct urtw_softc *);
int		urtw_8187b_init(struct ifnet *);
usbd_status	urtw_8225v2_b_config_mac(struct urtw_softc *);
usbd_status	urtw_8225v2_b_init_rfe(struct urtw_softc *);
usbd_status	urtw_8225v2_b_update_chan(struct urtw_softc *);
usbd_status	urtw_8225v2_b_rf_init(struct urtw_rf *);
usbd_status	urtw_8225v2_b_rf_set_chan(struct urtw_rf *, int);
usbd_status	urtw_8225v2_b_set_txpwrlvl(struct urtw_softc *, int);
int		urtw_set_bssid(struct urtw_softc *, const uint8_t *);
int		urtw_set_macaddr(struct urtw_softc *, const uint8_t *);

int urtw_match(struct device *, void *, void *);
void urtw_attach(struct device *, struct device *, void *);
int urtw_detach(struct device *, int);

struct cfdriver urtw_cd = {
	NULL, "urtw", DV_IFNET
};

const struct cfattach urtw_ca = {
	sizeof(struct urtw_softc), urtw_match, urtw_attach, urtw_detach
};

int
urtw_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return ((urtw_lookup(uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}

void
urtw_attach(struct device *parent, struct device *self, void *aux)
{
	struct urtw_softc *sc = (struct urtw_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usbd_status error;
	uint8_t data8;
	uint32_t data;
	int i;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;
	sc->sc_hwrev = urtw_lookup(uaa->vendor, uaa->product)->rev;

	printf("%s: ", sc->sc_dev.dv_xname);

	if (sc->sc_hwrev & URTW_HWREV_8187) {
		urtw_read32_m(sc, URTW_TX_CONF, &data);
		data &= URTW_TX_HWREV_MASK;
		switch (data) {
		case URTW_TX_HWREV_8187_D:
			sc->sc_hwrev |= URTW_HWREV_8187_D;
			printf("RTL8187 rev D");
			break;
		case URTW_TX_HWREV_8187B_D:
			/*
			 * Detect Realtek RTL8187B devices that use
			 * USB IDs of RTL8187.
			 */
			sc->sc_hwrev = URTW_HWREV_8187B | URTW_HWREV_8187B_B;
			printf("RTL8187B rev B (early)");
			break;
		default:
			sc->sc_hwrev |= URTW_HWREV_8187_B;
			printf("RTL8187 rev 0x%02x", data >> 25);
			break;
		}
	} else {
		/* RTL8187B hwrev register. */
		urtw_read8_m(sc, URTW_8187B_HWREV, &data8);
		switch (data8) {
		case URTW_8187B_HWREV_8187B_B:
			sc->sc_hwrev |= URTW_HWREV_8187B_B;
			printf("RTL8187B rev B");
			break;
		case URTW_8187B_HWREV_8187B_D:
			sc->sc_hwrev |= URTW_HWREV_8187B_D;
			printf("RTL8187B rev D");
			break;
		case URTW_8187B_HWREV_8187B_E:
			sc->sc_hwrev |= URTW_HWREV_8187B_E;
			printf("RTL8187B rev E");
			break;
		default:
			sc->sc_hwrev |= URTW_HWREV_8187B_B;
			printf("RTL8187B rev 0x%02x", data8);
			break;
		}
	}

	urtw_read32_m(sc, URTW_RX, &data);
	sc->sc_epromtype = (data & URTW_RX_9356SEL) ? URTW_EEPROM_93C56 :
	    URTW_EEPROM_93C46;

	error = urtw_get_rfchip(sc);
	if (error != 0)
		goto fail;
	error = urtw_get_macaddr(sc);
	if (error != 0)
		goto fail;
	error = urtw_get_txpwr(sc);
	if (error != 0)
		goto fail;
	error = urtw_led_init(sc);		/* XXX incompleted */
	if (error != 0)
		goto fail;

	sc->sc_rts_retry = URTW_DEFAULT_RTS_RETRY;
	sc->sc_tx_retry = URTW_DEFAULT_TX_RETRY;
	sc->sc_currate = 3;
	/* XXX for what? */
	sc->sc_preamble_mode = 2;

	usb_init_task(&sc->sc_task, urtw_task, sc, USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->sc_ledtask, urtw_ledusbtask, sc,
	    USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, urtw_next_scan, sc);
	timeout_set(&sc->sc_led_ch, urtw_ledtask, sc);

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	if (sc->sc_hwrev & URTW_HWREV_8187) {
		sc->sc_init = urtw_init;
	} else {
		sc->sc_init = urtw_8187b_init;
	}
	ifp->if_ioctl = urtw_ioctl;
	ifp->if_start = urtw_start;
	ifp->if_watchdog = urtw_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = urtw_newstate;
	ieee80211_media_init(ifp, urtw_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(URTW_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(URTW_TX_RADIOTAP_PRESENT);
#endif

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	return;
fail:
	printf(": %s failed!\n", __func__);
}

int
urtw_detach(struct device *self, int flags)
{
	struct urtw_softc *sc = (struct urtw_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->sc_led_ch))
		timeout_del(&sc->sc_led_ch);

	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);
	usb_rem_wait_task(sc->sc_udev, &sc->sc_ledtask);

	usbd_ref_wait(sc->sc_udev);

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);	/* free all nodes */
		if_detach(ifp);
	}

	/* abort and free xfers */
	urtw_free_tx_data_list(sc);
	urtw_free_rx_data_list(sc);
	urtw_close_pipes(sc);

	splx(s);

	return (0);
}

usbd_status
urtw_close_pipes(struct urtw_softc *sc)
{
	usbd_status error = 0;

	if (sc->sc_rxpipe != NULL) {
		error = usbd_close_pipe(sc->sc_rxpipe);
		if (error != 0)
			goto fail;
		sc->sc_rxpipe = NULL;
	}
	if (sc->sc_txpipe_low != NULL) {
		error = usbd_close_pipe(sc->sc_txpipe_low);
		if (error != 0)
			goto fail;
		sc->sc_txpipe_low = NULL;
	}
	if (sc->sc_txpipe_normal != NULL) {
		error = usbd_close_pipe(sc->sc_txpipe_normal);
		if (error != 0)
			goto fail;
		sc->sc_txpipe_normal = NULL;
	}
fail:
	return (error);
}

usbd_status
urtw_open_pipes(struct urtw_softc *sc)
{
	usbd_status error;

	/*
	 * NB: there is no way to distinguish each pipes so we need to hardcode
	 * pipe numbers
	 */

	/* tx pipe - low priority packets */
	if (sc->sc_hwrev & URTW_HWREV_8187)
		error = usbd_open_pipe(sc->sc_iface, 0x2,
		    USBD_EXCLUSIVE_USE, &sc->sc_txpipe_low);
	else
		error = usbd_open_pipe(sc->sc_iface, 0x6,
		    USBD_EXCLUSIVE_USE, &sc->sc_txpipe_low);
	if (error != 0) {
		printf("%s: could not open Tx low pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	/* tx pipe - normal priority packets */
	if (sc->sc_hwrev & URTW_HWREV_8187)
		error = usbd_open_pipe(sc->sc_iface, 0x3,
		    USBD_EXCLUSIVE_USE, &sc->sc_txpipe_normal);
	else
		error = usbd_open_pipe(sc->sc_iface, 0x7,
		    USBD_EXCLUSIVE_USE, &sc->sc_txpipe_normal);
	if (error != 0) {
		printf("%s: could not open Tx normal pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	/* rx pipe */
	if (sc->sc_hwrev & URTW_HWREV_8187)
		error = usbd_open_pipe(sc->sc_iface, 0x81,
		    USBD_EXCLUSIVE_USE, &sc->sc_rxpipe);
	else
		error = usbd_open_pipe(sc->sc_iface, 0x83,
		    USBD_EXCLUSIVE_USE, &sc->sc_rxpipe);
	if (error != 0) {
		printf("%s: could not open Rx pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	return (0);
fail:
	(void)urtw_close_pipes(sc);
	return (error);
}

int
urtw_alloc_rx_data_list(struct urtw_softc *sc)
{
	int i, error;

	for (i = 0; i < URTW_RX_DATA_LIST_COUNT; i++) {
		struct urtw_rx_data *data = &sc->sc_rx_data[i];

		data->sc = sc;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		if (usbd_alloc_buffer(data->xfer, URTW_RX_MAXSIZE) == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = mtod(data->m, uint8_t *);
	}

	return (0);

fail:
	urtw_free_rx_data_list(sc);
	return (error);
}

void
urtw_free_rx_data_list(struct urtw_softc *sc)
{
	int i;

	/* Make sure no transfers are pending. */
	if (sc->sc_rxpipe != NULL)
		usbd_abort_pipe(sc->sc_rxpipe);

	for (i = 0; i < URTW_RX_DATA_LIST_COUNT; i++) {
		struct urtw_rx_data *data = &sc->sc_rx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		if (data->m != NULL) {
			m_freem(data->m);
			data->m = NULL;
		}
	}
}

int
urtw_alloc_tx_data_list(struct urtw_softc *sc)
{
	int i, error;

	for (i = 0; i < URTW_TX_DATA_LIST_COUNT; i++) {
		struct urtw_tx_data *data = &sc->sc_tx_data[i];

		data->sc = sc;
		data->ni = NULL;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		data->buf = usbd_alloc_buffer(data->xfer, URTW_TX_MAXSIZE);
		if (data->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		if (((unsigned long)data->buf) % 4)
			printf("%s: warn: unaligned buffer %p\n",
			    sc->sc_dev.dv_xname, data->buf);
	}

	return (0);

fail:
	urtw_free_tx_data_list(sc);
	return (error);
}

void
urtw_free_tx_data_list(struct urtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i;

	/* Make sure no transfers are pending. */
	if (sc->sc_txpipe_low != NULL)
		usbd_abort_pipe(sc->sc_txpipe_low);
	if (sc->sc_txpipe_normal != NULL)
		usbd_abort_pipe(sc->sc_txpipe_normal);

	for (i = 0; i < URTW_TX_DATA_LIST_COUNT; i++) {
		struct urtw_tx_data *data = &sc->sc_tx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
	}
}

int
urtw_media_change(struct ifnet *ifp)
{
	struct urtw_softc *sc = ifp->if_softc;
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return (error);

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
	    (IFF_UP | IFF_RUNNING))
		sc->sc_init(ifp);

	return (0);
}

int
urtw_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct urtw_softc *sc = ic->ic_if.if_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	timeout_del(&sc->scan_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task);

	return (0);
}

usbd_status
urtw_led_init(struct urtw_softc *sc)
{
	uint32_t rev;
	usbd_status error;

	urtw_read8_m(sc, URTW_PSR, &sc->sc_psr);
	error = urtw_eprom_read32(sc, URTW_EPROM_SWREV, &rev);
	if (error != 0)
		goto fail;

	switch (rev & URTW_EPROM_CID_MASK) {
	case URTW_EPROM_CID_ALPHA0:
		sc->sc_strategy = URTW_SW_LED_MODE1;
		break;
	case URTW_EPROM_CID_SERCOMM_PS:
		sc->sc_strategy = URTW_SW_LED_MODE3;
		break;
	case URTW_EPROM_CID_HW_LED:
		sc->sc_strategy = URTW_HW_LED;
		break;
	case URTW_EPROM_CID_RSVD0:
	case URTW_EPROM_CID_RSVD1:
	default:
		sc->sc_strategy = URTW_SW_LED_MODE0;
		break;
	}

	sc->sc_gpio_ledpin = URTW_LED_PIN_GPIO0;

fail:
	return (error);
}

usbd_status
urtw_8225_write_s16(struct urtw_softc *sc, uint8_t addr, int index,
    uint16_t data)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URTW_8187_SETREGS_REQ;
	USETW(req.wValue, addr);
	USETW(req.wIndex, index);
	USETW(req.wLength, sizeof(uint16_t));

	data = htole16(data);	
	return (usbd_do_request(sc->sc_udev, &req, &data));
}

usbd_status
urtw_8225_read(struct urtw_softc *sc, uint8_t addr, uint32_t *data)
{
	int i;
	int16_t bit;
	uint8_t rlen = 12, wlen = 6;
	uint16_t o1, o2, o3, tmp;
	uint32_t d2w = ((uint32_t)(addr & 0x1f)) << 27;
	uint32_t mask = 0x80000000, value = 0;
	usbd_status error;

	urtw_read16_m(sc, URTW_RF_PINS_OUTPUT, &o1);
	urtw_read16_m(sc, URTW_RF_PINS_ENABLE, &o2);
	urtw_read16_m(sc, URTW_RF_PINS_SELECT, &o3);
	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, o2 | 0xf);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, o3 | 0xf);
	o1 &= ~0xf;
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, o1 | URTW_BB_HOST_BANG_EN);
	DELAY(5);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, o1);
	DELAY(5);

	for (i = 0; i < (wlen / 2); i++, mask = mask >> 1) {
		bit = ((d2w & mask) != 0) ? 1 : 0;

		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 |
		    URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 |
		    URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		mask = mask >> 1;
		if (i == 2)
			break;
		bit = ((d2w & mask) != 0) ? 1 : 0;
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 |
		    URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 |
		    URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1);
		DELAY(1);
	}
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 | URTW_BB_HOST_BANG_RW |
	    URTW_BB_HOST_BANG_CLK);
	DELAY(2);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, bit | o1 | URTW_BB_HOST_BANG_RW);
	DELAY(2);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, o1 | URTW_BB_HOST_BANG_RW);
	DELAY(2);

	mask = 0x800;
	for (i = 0; i < rlen; i++, mask = mask >> 1) {
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT,
		    o1 | URTW_BB_HOST_BANG_RW);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT,
		    o1 | URTW_BB_HOST_BANG_RW | URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT,
		    o1 | URTW_BB_HOST_BANG_RW | URTW_BB_HOST_BANG_CLK);
		DELAY(2);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT,
		    o1 | URTW_BB_HOST_BANG_RW | URTW_BB_HOST_BANG_CLK);
		DELAY(2);

		urtw_read16_m(sc, URTW_RF_PINS_INPUT, &tmp);
		value |= ((tmp & URTW_BB_HOST_BANG_CLK) ? mask : 0);
		urtw_write16_m(sc, URTW_RF_PINS_OUTPUT,
		    o1 | URTW_BB_HOST_BANG_RW);
		DELAY(2);
	}

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, o1 | URTW_BB_HOST_BANG_EN |
	    URTW_BB_HOST_BANG_RW);
	DELAY(2);

	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, o2);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, o3);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, 0x3a0);

	if (data != NULL)
		*data = value;
fail:
	return (error);
}

usbd_status
urtw_8225_write_c(struct urtw_softc *sc, uint8_t addr, uint16_t data)
{
	uint16_t d80, d82, d84;
	usbd_status error;

	urtw_read16_m(sc, URTW_RF_PINS_OUTPUT, &d80);
	d80 &= 0xfff3;
	urtw_read16_m(sc, URTW_RF_PINS_ENABLE, &d82);
	urtw_read16_m(sc, URTW_RF_PINS_SELECT, &d84);
	d84 &= 0xfff0;
	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, d82 | 0x0007);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, d84 | 0x0007);
	DELAY(10);

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, d80 | URTW_BB_HOST_BANG_EN);
	DELAY(2);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, d80);
	DELAY(10);

	error = urtw_8225_write_s16(sc, addr, 0x8225, data);
	if (error != 0)
		goto fail;

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, d80 | URTW_BB_HOST_BANG_EN);
	DELAY(10);
	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, d80 | URTW_BB_HOST_BANG_EN);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, d84);
	usbd_delay_ms(sc->sc_udev, 2);
fail:
	return (error);
}

usbd_status
urtw_8225_isv2(struct urtw_softc *sc, int *ret)
{
	uint32_t data;
	usbd_status error;

	*ret = 1;

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, 0x0080);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, 0x0080);
	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, 0x0080);
	usbd_delay_ms(sc->sc_udev, 500);

	urtw_8225_write(sc, 0x0, 0x1b7);

	error = urtw_8225_read(sc, 0x8, &data);
	if (error != 0)
		goto fail;
	if (data != 0x588)
		*ret = 0;
	else {
		error = urtw_8225_read(sc, 0x9, &data);
		if (error != 0)
			goto fail;
		if (data != 0x700)
			*ret = 0;
	}

	urtw_8225_write(sc, 0x0, 0xb7);
fail:
	return (error);
}

usbd_status
urtw_get_rfchip(struct urtw_softc *sc)
{
	struct urtw_rf *rf = &sc->sc_rf;
	int ret;
	uint32_t data;
	usbd_status error;

	rf->rf_sc = sc;

	if (sc->sc_hwrev & URTW_HWREV_8187) {
		error = urtw_eprom_read32(sc, URTW_EPROM_RFCHIPID, &data);
		if (error != 0)
			goto fail;
		switch (data & 0xff) {
		case URTW_EPROM_RFCHIPID_RTL8225U:
			error = urtw_8225_isv2(sc, &ret);
			if (error != 0)
				goto fail;
			if (ret == 0) {
				rf->init = urtw_8225_rf_init;
				rf->set_chan = urtw_8225_rf_set_chan;
				rf->set_sens = urtw_8225_rf_set_sens;
				printf(", RFv1");
			} else {
				rf->init = urtw_8225v2_rf_init;
				rf->set_chan = urtw_8225v2_rf_set_chan;
				rf->set_sens = NULL;
				printf(", RFv2");
			}
			break;
		default:
			goto fail;
		}
	} else {
		rf->init = urtw_8225v2_b_rf_init;
		rf->set_chan = urtw_8225v2_b_rf_set_chan;
		rf->set_sens = NULL;
	}

	rf->max_sens = URTW_8225_RF_MAX_SENS;
	rf->sens = URTW_8225_RF_DEF_SENS;

	return (0);

fail:
	printf("unsupported RF chip %d", data & 0xff);
	return (error);
}

usbd_status
urtw_get_txpwr(struct urtw_softc *sc)
{
	int i, j;
	uint32_t data;
	usbd_status error;

	error = urtw_eprom_read32(sc, URTW_EPROM_TXPW_BASE, &data);
	if (error != 0)
		goto fail;
	sc->sc_txpwr_cck_base = data & 0xf;
	sc->sc_txpwr_ofdm_base = (data >> 4) & 0xf;

	for (i = 1, j = 0; i < 6; i += 2, j++) {
		error = urtw_eprom_read32(sc, URTW_EPROM_TXPW0 + j, &data);
		if (error != 0)
			goto fail;
		sc->sc_txpwr_cck[i] = data & 0xf;
		sc->sc_txpwr_cck[i + 1] = (data & 0xf00) >> 8;
		sc->sc_txpwr_ofdm[i] = (data & 0xf0) >> 4;
		sc->sc_txpwr_ofdm[i + 1] = (data & 0xf000) >> 12;
	}
	for (i = 1, j = 0; i < 4; i += 2, j++) {
		error = urtw_eprom_read32(sc, URTW_EPROM_TXPW1 + j, &data);
		if (error != 0)
			goto fail;
		sc->sc_txpwr_cck[i + 6] = data & 0xf;
		sc->sc_txpwr_cck[i + 6 + 1] = (data & 0xf00) >> 8;
		sc->sc_txpwr_ofdm[i + 6] = (data & 0xf0) >> 4;
		sc->sc_txpwr_ofdm[i + 6 + 1] = (data & 0xf000) >> 12;
	}
	if (sc->sc_hwrev & URTW_HWREV_8187) {
		for (i = 1, j = 0; i < 4; i += 2, j++) {
			error = urtw_eprom_read32(sc, URTW_EPROM_TXPW2 + j,
			    &data);
			if (error != 0)
				goto fail;
			sc->sc_txpwr_cck[i + 6 + 4] = data & 0xf;
			sc->sc_txpwr_cck[i + 6 + 4 + 1] = (data & 0xf00) >> 8;
			sc->sc_txpwr_ofdm[i + 6 + 4] = (data & 0xf0) >> 4;
			sc->sc_txpwr_ofdm[i + 6 + 4 + 1] =
			    (data & 0xf000) >> 12;
		}
	} else {
		/* Channel 11. */
		error = urtw_eprom_read32(sc, 0x1b, &data);
		if (error != 0)
			goto fail;
		sc->sc_txpwr_cck[11] = data & 0xf;
		sc->sc_txpwr_ofdm[11] = (data & 0xf0) >> 4;

		/* Channel 12. */
		error = urtw_eprom_read32(sc, 0xa, &data);
		if (error != 0)
			goto fail;
		sc->sc_txpwr_cck[12] = data & 0xf;
		sc->sc_txpwr_ofdm[12] = (data & 0xf0) >> 4;

		/* Channel 13, 14. */
		error = urtw_eprom_read32(sc, 0x1c, &data);
		if (error != 0)
			goto fail;
		sc->sc_txpwr_cck[13] = data & 0xf;
		sc->sc_txpwr_ofdm[13] = (data & 0xf0) >> 4;
		sc->sc_txpwr_cck[14] = (data & 0xf00) >> 8;
		sc->sc_txpwr_ofdm[14] = (data & 0xf000) >> 12;
	}
fail:
	return (error);
}

usbd_status
urtw_get_macaddr(struct urtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	usbd_status error;
	uint32_t data;

	error = urtw_eprom_read32(sc, URTW_EPROM_MACADDR, &data);
	if (error != 0)
		goto fail;
	ic->ic_myaddr[0] = data & 0xff;
	ic->ic_myaddr[1] = (data & 0xff00) >> 8;
	error = urtw_eprom_read32(sc, URTW_EPROM_MACADDR + 1, &data);
	if (error != 0)
		goto fail;
	ic->ic_myaddr[2] = data & 0xff;
	ic->ic_myaddr[3] = (data & 0xff00) >> 8;
	error = urtw_eprom_read32(sc, URTW_EPROM_MACADDR + 2, &data);
	if (error != 0)
		goto fail;
	ic->ic_myaddr[4] = data & 0xff;
	ic->ic_myaddr[5] = (data & 0xff00) >> 8;
fail:
	return (error);
}

usbd_status
urtw_eprom_read32(struct urtw_softc *sc, uint32_t addr, uint32_t *data)
{
#define URTW_READCMD_LEN		3
	int addrlen, i;
	int16_t addrstr[8], data16, readcmd[] = { 1, 1, 0 };
	usbd_status error;

	/* NB: make sure the buffer is initialized */
	*data = 0;

	/* enable EPROM programming */
	urtw_write8_m(sc, URTW_EPROM_CMD, URTW_EPROM_CMD_PROGRAM_MODE);
	DELAY(URTW_EPROM_DELAY);

	error = urtw_eprom_cs(sc, URTW_EPROM_ENABLE);
	if (error != 0)
		goto fail;
	error = urtw_eprom_ck(sc);
	if (error != 0)
		goto fail;
	error = urtw_eprom_sendbits(sc, readcmd, URTW_READCMD_LEN);
	if (error != 0)
		goto fail;
	if (sc->sc_epromtype == URTW_EEPROM_93C56) {
		addrlen = 8;
		addrstr[0] = addr & (1 << 7);
		addrstr[1] = addr & (1 << 6);
		addrstr[2] = addr & (1 << 5);
		addrstr[3] = addr & (1 << 4);
		addrstr[4] = addr & (1 << 3);
		addrstr[5] = addr & (1 << 2);
		addrstr[6] = addr & (1 << 1);
		addrstr[7] = addr & (1 << 0);
	} else {
		addrlen=6;
		addrstr[0] = addr & (1 << 5);
		addrstr[1] = addr & (1 << 4);
		addrstr[2] = addr & (1 << 3);
		addrstr[3] = addr & (1 << 2);
		addrstr[4] = addr & (1 << 1);
		addrstr[5] = addr & (1 << 0);
	}
	error = urtw_eprom_sendbits(sc, addrstr, addrlen);
	if (error != 0)
		goto fail;

	error = urtw_eprom_writebit(sc, 0);
	if (error != 0)
		goto fail;

	for (i = 0; i < 16; i++) {
		error = urtw_eprom_ck(sc);
		if (error != 0)
			goto fail;
		error = urtw_eprom_readbit(sc, &data16);
		if (error != 0)
			goto fail;

		(*data) |= (data16 << (15 - i));
	}

	error = urtw_eprom_cs(sc, URTW_EPROM_DISABLE);
	if (error != 0)
		goto fail;
	error = urtw_eprom_ck(sc);
	if (error != 0)
		goto fail;

	/* now disable EPROM programming */
	urtw_write8_m(sc, URTW_EPROM_CMD, URTW_EPROM_CMD_NORMAL_MODE);
fail:
	return (error);
#undef URTW_READCMD_LEN
}

usbd_status
urtw_eprom_readbit(struct urtw_softc *sc, int16_t *data)
{
	uint8_t data8;
	usbd_status error;

	urtw_read8_m(sc, URTW_EPROM_CMD, &data8);
	*data = (data8 & URTW_EPROM_READBIT) ? 1 : 0;
	DELAY(URTW_EPROM_DELAY);

fail:
	return (error);
}

usbd_status
urtw_eprom_sendbits(struct urtw_softc *sc, int16_t *buf, int buflen)
{
	int i = 0;
	usbd_status error = 0;

	for (i = 0; i < buflen; i++) {
		error = urtw_eprom_writebit(sc, buf[i]);
		if (error != 0)
			goto fail;
		error = urtw_eprom_ck(sc);
		if (error != 0)
			goto fail;
	}
fail:
	return (error);
}

usbd_status
urtw_eprom_writebit(struct urtw_softc *sc, int16_t bit)
{
	uint8_t data;
	usbd_status error;

	urtw_read8_m(sc, URTW_EPROM_CMD, &data);
	if (bit != 0)
		urtw_write8_m(sc, URTW_EPROM_CMD, data | URTW_EPROM_WRITEBIT);
	else
		urtw_write8_m(sc, URTW_EPROM_CMD, data & ~URTW_EPROM_WRITEBIT);
	DELAY(URTW_EPROM_DELAY);
fail:
	return (error);
}

usbd_status
urtw_eprom_ck(struct urtw_softc *sc)
{
	uint8_t data;
	usbd_status error;

	/* masking */
	urtw_read8_m(sc, URTW_EPROM_CMD, &data);
	urtw_write8_m(sc, URTW_EPROM_CMD, data | URTW_EPROM_CK);
	DELAY(URTW_EPROM_DELAY);
	/* unmasking */
	urtw_read8_m(sc, URTW_EPROM_CMD, &data);
	urtw_write8_m(sc, URTW_EPROM_CMD, data & ~URTW_EPROM_CK);
	DELAY(URTW_EPROM_DELAY);
fail:
	return (error);
}

usbd_status
urtw_eprom_cs(struct urtw_softc *sc, int able)
{
	uint8_t data;
	usbd_status error;

	urtw_read8_m(sc, URTW_EPROM_CMD, &data);
	if (able == URTW_EPROM_ENABLE)
		urtw_write8_m(sc, URTW_EPROM_CMD, data | URTW_EPROM_CS);
	else
		urtw_write8_m(sc, URTW_EPROM_CMD, data & ~URTW_EPROM_CS);
	DELAY(URTW_EPROM_DELAY);
fail:
	return (error);
}

usbd_status
urtw_read8_c(struct urtw_softc *sc, int val, uint8_t *data, uint8_t idx)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = URTW_8187_GETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint8_t));

	error = usbd_do_request(sc->sc_udev, &req, data);
	return (error);
}

usbd_status
urtw_read8e(struct urtw_softc *sc, int val, uint8_t *data)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = URTW_8187_GETREGS_REQ;
	USETW(req.wValue, val | 0xfe00);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(uint8_t));

	error = usbd_do_request(sc->sc_udev, &req, data);
	return (error);
}

usbd_status
urtw_read16_c(struct urtw_softc *sc, int val, uint16_t *data, uint8_t idx)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = URTW_8187_GETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint16_t));

	error = usbd_do_request(sc->sc_udev, &req, data);
	*data = letoh16(*data);
	return (error);
}

usbd_status
urtw_read32_c(struct urtw_softc *sc, int val, uint32_t *data, uint8_t idx)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = URTW_8187_GETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint32_t));

	error = usbd_do_request(sc->sc_udev, &req, data);
	*data = letoh32(*data);
	return (error);
}

usbd_status
urtw_write8_c(struct urtw_softc *sc, int val, uint8_t data, uint8_t idx)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URTW_8187_SETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint8_t));

	return (usbd_do_request(sc->sc_udev, &req, &data));
}

usbd_status
urtw_write8e(struct urtw_softc *sc, int val, uint8_t data)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URTW_8187_SETREGS_REQ;
	USETW(req.wValue, val | 0xfe00);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(uint8_t));

	return (usbd_do_request(sc->sc_udev, &req, &data));
}

usbd_status
urtw_write16_c(struct urtw_softc *sc, int val, uint16_t data, uint8_t idx)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URTW_8187_SETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint16_t));

	data = htole16(data);	
	return (usbd_do_request(sc->sc_udev, &req, &data));
}

usbd_status
urtw_write32_c(struct urtw_softc *sc, int val, uint32_t data, uint8_t idx)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = URTW_8187_SETREGS_REQ;
	USETW(req.wValue, val | 0xff00);
	USETW(req.wIndex, idx & 0x03);
	USETW(req.wLength, sizeof(uint32_t));

	data = htole32(data);	
	return (usbd_do_request(sc->sc_udev, &req, &data));
}

static usbd_status
urtw_set_mode(struct urtw_softc *sc, uint32_t mode)
{
	uint8_t data;
	usbd_status error;

	urtw_read8_m(sc, URTW_EPROM_CMD, &data);
	data = (data & ~URTW_EPROM_CMD_MASK) | (mode << URTW_EPROM_CMD_SHIFT);
	data = data & ~(URTW_EPROM_CS | URTW_EPROM_CK);
	urtw_write8_m(sc, URTW_EPROM_CMD, data);
fail:
	return (error);
}

usbd_status
urtw_8180_set_anaparam(struct urtw_softc *sc, uint32_t val)
{
	uint8_t data;
	usbd_status error;

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;

	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data | URTW_CONFIG3_ANAPARAM_WRITE);
	urtw_write32_m(sc, URTW_ANAPARAM, val);
	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data & ~URTW_CONFIG3_ANAPARAM_WRITE);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;
fail:
	return (error);
}

usbd_status
urtw_8185_set_anaparam2(struct urtw_softc *sc, uint32_t val)
{
	uint8_t data;
	usbd_status error;

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;

	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data | URTW_CONFIG3_ANAPARAM_WRITE);
	urtw_write32_m(sc, URTW_ANAPARAM2, val);
	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data & ~URTW_CONFIG3_ANAPARAM_WRITE);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;
fail:
	return (error);
}

usbd_status
urtw_intr_disable(struct urtw_softc *sc)
{
	usbd_status error;

	urtw_write16_m(sc, URTW_INTR_MASK, 0);
fail:
	return (error);
}

usbd_status
urtw_reset(struct urtw_softc *sc)
{
	uint8_t data;
	usbd_status error;

	error = urtw_8180_set_anaparam(sc, URTW_8187_8225_ANAPARAM_ON);
	if (error)
		goto fail;
	error = urtw_8185_set_anaparam2(sc, URTW_8187_8225_ANAPARAM2_ON);
	if (error)
		goto fail;

	error = urtw_intr_disable(sc);
	if (error)
		goto fail;
	usbd_delay_ms(sc->sc_udev, 100);

	error = urtw_write8e(sc, 0x18, 0x10);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x18, 0x11);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x18, 0x00);
	if (error != 0)
		goto fail;
	usbd_delay_ms(sc->sc_udev, 100);

	urtw_read8_m(sc, URTW_CMD, &data);
	data = (data & 2) | URTW_CMD_RST;
	urtw_write8_m(sc, URTW_CMD, data);
	usbd_delay_ms(sc->sc_udev, 100);

	urtw_read8_m(sc, URTW_CMD, &data);
	if (data & URTW_CMD_RST) {
		printf("%s: reset timeout\n", sc->sc_dev.dv_xname);
		goto fail;
	}

	error = urtw_set_mode(sc, URTW_EPROM_CMD_LOAD);
	if (error)
		goto fail;
	usbd_delay_ms(sc->sc_udev, 100);

	error = urtw_8180_set_anaparam(sc, URTW_8187_8225_ANAPARAM_ON);
	if (error)
		goto fail;
	error = urtw_8185_set_anaparam2(sc, URTW_8187_8225_ANAPARAM2_ON);
	if (error)
		goto fail;
fail:
	return (error);
}

usbd_status
urtw_led_on(struct urtw_softc *sc, int type)
{
	usbd_status error = 0;

	if (type == URTW_LED_GPIO) {
		switch (sc->sc_gpio_ledpin) {
		case URTW_LED_PIN_GPIO0:
			urtw_write8_m(sc, URTW_GPIO, 0x01);
			urtw_write8_m(sc, URTW_GP_ENABLE, 0x00);
			break;
		default:
			break;
		}
	}

	sc->sc_gpio_ledon = 1;
fail:
	return (error);
}

static usbd_status
urtw_led_off(struct urtw_softc *sc, int type)
{
	usbd_status error = 0;

	if (type == URTW_LED_GPIO) {
		switch (sc->sc_gpio_ledpin) {
		case URTW_LED_PIN_GPIO0:
			urtw_write8_m(sc, URTW_GPIO, 0x01);
			urtw_write8_m(sc, URTW_GP_ENABLE, 0x01);
			break;
		default:
			break;
		}
	}

	sc->sc_gpio_ledon = 0;

fail:
	return (error);
}

usbd_status
urtw_led_mode0(struct urtw_softc *sc, int mode)
{
	struct timeval t;

	switch (mode) {
	case URTW_LED_CTL_POWER_ON:
		sc->sc_gpio_ledstate = URTW_LED_POWER_ON_BLINK;
		break;
	case URTW_LED_CTL_TX:
		if (sc->sc_gpio_ledinprogress == 1)
			return (0);

		sc->sc_gpio_ledstate = URTW_LED_BLINK_NORMAL;
		sc->sc_gpio_blinktime = 2;
		break;
	case URTW_LED_CTL_LINK:
		sc->sc_gpio_ledstate = URTW_LED_ON;
		break;
	default:
		break;
	}

	switch (sc->sc_gpio_ledstate) {
	case URTW_LED_ON:
		if (sc->sc_gpio_ledinprogress != 0)
			break;
		urtw_led_on(sc, URTW_LED_GPIO);
		break;
	case URTW_LED_BLINK_NORMAL:
		if (sc->sc_gpio_ledinprogress != 0)
			break;
		sc->sc_gpio_ledinprogress = 1;
		sc->sc_gpio_blinkstate = (sc->sc_gpio_ledon != 0) ?
			URTW_LED_OFF : URTW_LED_ON;
		t.tv_sec = 0;
		t.tv_usec = 100 * 1000L;
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add(&sc->sc_led_ch, tvtohz(&t));
		break;
	case URTW_LED_POWER_ON_BLINK:
		urtw_led_on(sc, URTW_LED_GPIO);
		usbd_delay_ms(sc->sc_udev, 100);
		urtw_led_off(sc, URTW_LED_GPIO);
		break;
	default:
		break;
	}
	return (0);
}

usbd_status
urtw_led_mode1(struct urtw_softc *sc, int mode)
{
	return (USBD_INVAL);
}

usbd_status
urtw_led_mode2(struct urtw_softc *sc, int mode)
{
	return (USBD_INVAL);
}

usbd_status
urtw_led_mode3(struct urtw_softc *sc, int mode)
{
	return (USBD_INVAL);
}

void
urtw_ledusbtask(void *arg)
{
	struct urtw_softc *sc = arg;

	if (sc->sc_strategy != URTW_SW_LED_MODE0)
		return;

	urtw_led_blink(sc);
}

void
urtw_ledtask(void *arg)
{
	struct urtw_softc *sc = arg;

	/*
	 * NB: to change a status of the led we need at least a sleep so we
	 * can't do it here
	 */
	usb_add_task(sc->sc_udev, &sc->sc_ledtask);
}

usbd_status
urtw_led_ctl(struct urtw_softc *sc, int mode)
{
	usbd_status error = 0;

	switch (sc->sc_strategy) {
	case URTW_SW_LED_MODE0:
		error = urtw_led_mode0(sc, mode);
		break;
	case URTW_SW_LED_MODE1:
		error = urtw_led_mode1(sc, mode);
		break;
	case URTW_SW_LED_MODE2:
		error = urtw_led_mode2(sc, mode);
		break;
	case URTW_SW_LED_MODE3:
		error = urtw_led_mode3(sc, mode);
		break;
	default:
		break;
	}

	return (error);
}

usbd_status
urtw_led_blink(struct urtw_softc *sc)
{
	struct timeval t;
	uint8_t ing = 0;
	usbd_status error;

	if (sc->sc_gpio_blinkstate == URTW_LED_ON)
		error = urtw_led_on(sc, URTW_LED_GPIO);
	else
		error = urtw_led_off(sc, URTW_LED_GPIO);
	sc->sc_gpio_blinktime--;
	if (sc->sc_gpio_blinktime == 0)
		ing = 1;
	else {
		if (sc->sc_gpio_ledstate != URTW_LED_BLINK_NORMAL &&
		    sc->sc_gpio_ledstate != URTW_LED_BLINK_SLOWLY &&
		    sc->sc_gpio_ledstate != URTW_LED_BLINK_CM3)
			ing = 1;
	}
	if (ing == 1) {
		if (sc->sc_gpio_ledstate == URTW_LED_ON &&
		    sc->sc_gpio_ledon == 0)
			error = urtw_led_on(sc, URTW_LED_GPIO);
		else if (sc->sc_gpio_ledstate == URTW_LED_OFF &&
		    sc->sc_gpio_ledon == 1)
			error = urtw_led_off(sc, URTW_LED_GPIO);

		sc->sc_gpio_blinktime = 0;
		sc->sc_gpio_ledinprogress = 0;
		return (0);
	}

	sc->sc_gpio_blinkstate = (sc->sc_gpio_blinkstate != URTW_LED_ON) ?
	    URTW_LED_ON : URTW_LED_OFF;

	switch (sc->sc_gpio_ledstate) {
	case URTW_LED_BLINK_NORMAL:
		t.tv_sec = 0;
		t.tv_usec = 100 * 1000L;
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add(&sc->sc_led_ch, tvtohz(&t));
		break;
	default:
		break;
	}
	return (0);
}

usbd_status
urtw_update_msr(struct urtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t data;
	usbd_status error;

	urtw_read8_m(sc, URTW_MSR, &data);
	data &= ~URTW_MSR_LINK_MASK;

	/* Should always be set. */
	if (sc->sc_hwrev & URTW_HWREV_8187B)
		data |= URTW_MSR_LINK_ENEDCA;

	if (sc->sc_state == IEEE80211_S_RUN) {
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
		case IEEE80211_M_MONITOR:
			data |= URTW_MSR_LINK_STA;
			break;
		default:
			break;
		}
	} else
		data |= URTW_MSR_LINK_NONE;

	urtw_write8_m(sc, URTW_MSR, data);
fail:
	return (error);
}

uint16_t
urtw_rate2rtl(int rate)
{
	int i;

	for (i = 0; i < nitems(urtw_ratetable); i++) {
		if (rate == urtw_ratetable[i].reg)
			return (urtw_ratetable[i].val);
	}

	return (3);
}

uint16_t
urtw_rtl2rate(int rate)
{
	int i;

	for (i = 0; i < nitems(urtw_ratetable); i++) {
		if (rate == urtw_ratetable[i].val)
			return (urtw_ratetable[i].reg);
	}

	return (0);
}

usbd_status
urtw_set_rate(struct urtw_softc *sc)
{
	int i, basic_rate, min_rr_rate, max_rr_rate;
	uint16_t data;
	usbd_status error;

	basic_rate = urtw_rate2rtl(48);
	min_rr_rate = urtw_rate2rtl(12);
	max_rr_rate = urtw_rate2rtl(48);

	urtw_write8_m(sc, URTW_RESP_RATE,
	    max_rr_rate << URTW_RESP_MAX_RATE_SHIFT |
	    min_rr_rate << URTW_RESP_MIN_RATE_SHIFT);

	urtw_read16_m(sc, URTW_8187_BRSR, &data);
	data &= ~URTW_BRSR_MBR_8185;

	for (i = 0; i <= basic_rate; i++)
		data |= (1 << i);

	urtw_write16_m(sc, URTW_8187_BRSR, data);
fail:
	return (error);
}

usbd_status
urtw_intr_enable(struct urtw_softc *sc)
{
	usbd_status error;

	urtw_write16_m(sc, URTW_INTR_MASK, 0xffff);
fail:
	return (error);
}

usbd_status
urtw_rx_setconf(struct urtw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t data;
	usbd_status error;

	urtw_read32_m(sc, URTW_RX, &data);
	data = data &~ URTW_RX_FILTER_MASK;
#if 0
	data = data | URTW_RX_FILTER_CTL;
#endif
	data = data | URTW_RX_FILTER_MNG | URTW_RX_FILTER_DATA;
	data = data | URTW_RX_FILTER_BCAST | URTW_RX_FILTER_MCAST;

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		data = data | URTW_RX_FILTER_ICVERR;
		data = data | URTW_RX_FILTER_PWR;
	}
	if (sc->sc_crcmon == 1 && ic->ic_opmode == IEEE80211_M_MONITOR)
		data = data | URTW_RX_FILTER_CRCERR;

	if (ic->ic_opmode == IEEE80211_M_MONITOR ||
	    (ifp->if_flags & (IFF_ALLMULTI | IFF_PROMISC))) {
		data = data | URTW_RX_FILTER_ALLMAC;
	} else {
		data = data | URTW_RX_FILTER_NICMAC;
		data = data | URTW_RX_CHECK_BSSID;
	}

	data = data &~ URTW_RX_FIFO_THRESHOLD_MASK;
	data = data | URTW_RX_FIFO_THRESHOLD_NONE | URTW_RX_AUTORESETPHY;
	data = data &~ URTW_MAX_RX_DMA_MASK;
	data = data | URTW_MAX_RX_DMA_2048 | URTW_RCR_ONLYERLPKT;

	urtw_write32_m(sc, URTW_RX, data);
fail:
	return (error);
}

usbd_status
urtw_rx_enable(struct urtw_softc *sc)
{
	int i;
	struct urtw_rx_data *rx_data;
	uint8_t data;
	usbd_status error;

	/*
	 * Start up the receive pipe.
	 */
	for (i = 0; i < URTW_RX_DATA_LIST_COUNT; i++) {
		rx_data = &sc->sc_rx_data[i];

		usbd_setup_xfer(rx_data->xfer, sc->sc_rxpipe, rx_data,
		    rx_data->buf, MCLBYTES, USBD_SHORT_XFER_OK,
		    USBD_NO_TIMEOUT, urtw_rxeof);
		error = usbd_transfer(rx_data->xfer);
		if (error != USBD_IN_PROGRESS && error != 0) {
			printf("%s: could not queue Rx transfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	error = urtw_rx_setconf(sc);
	if (error != 0)
		goto fail;

	urtw_read8_m(sc, URTW_CMD, &data);
	urtw_write8_m(sc, URTW_CMD, data | URTW_CMD_RX_ENABLE);
fail:
	return (error);
}

usbd_status
urtw_tx_enable(struct urtw_softc *sc)
{
	uint8_t data8;
	uint32_t data;
	usbd_status error;

	if (sc->sc_hwrev & URTW_HWREV_8187) {
		urtw_read8_m(sc, URTW_CW_CONF, &data8);
		data8 &= ~(URTW_CW_CONF_PERPACKET_CW |
		    URTW_CW_CONF_PERPACKET_RETRY);
		urtw_write8_m(sc, URTW_CW_CONF, data8);

 		urtw_read8_m(sc, URTW_TX_AGC_CTL, &data8);
		data8 &= ~URTW_TX_AGC_CTL_PERPACKET_GAIN;
		data8 &= ~URTW_TX_AGC_CTL_PERPACKET_ANTSEL;
		data8 &= ~URTW_TX_AGC_CTL_FEEDBACK_ANT;
		urtw_write8_m(sc, URTW_TX_AGC_CTL, data8);

		urtw_read32_m(sc, URTW_TX_CONF, &data);
		data &= ~URTW_TX_LOOPBACK_MASK;
		data |= URTW_TX_LOOPBACK_NONE;
		data &= ~(URTW_TX_DPRETRY_MASK | URTW_TX_RTSRETRY_MASK);
		data |= sc->sc_tx_retry << URTW_TX_DPRETRY_SHIFT;
		data |= sc->sc_rts_retry << URTW_TX_RTSRETRY_SHIFT;
		data &= ~(URTW_TX_NOCRC | URTW_TX_MXDMA_MASK);
		data |= URTW_TX_MXDMA_2048 | URTW_TX_CWMIN | URTW_TX_DISCW;
		data &= ~URTW_TX_SWPLCPLEN;
		data |= URTW_TX_NOICV;
		urtw_write32_m(sc, URTW_TX_CONF, data);
	} else {
		data = URTW_TX_DURPROCMODE | URTW_TX_DISREQQSIZE |
		    URTW_TX_MXDMA_2048 | URTW_TX_SHORTRETRY |
		    URTW_TX_LONGRETRY;
		urtw_write32_m(sc, URTW_TX_CONF, data);
	}

	urtw_read8_m(sc, URTW_CMD, &data8);
	urtw_write8_m(sc, URTW_CMD, data8 | URTW_CMD_TX_ENABLE);
fail:
	return (error);
}

int
urtw_init(struct ifnet *ifp)
{
	struct urtw_softc *sc = ifp->if_softc;
	struct urtw_rf *rf = &sc->sc_rf;
	struct ieee80211com *ic = &sc->sc_ic;
	usbd_status error;
	int ret;

	urtw_stop(ifp, 0);

	error = urtw_reset(sc);
	if (error)
		goto fail;

	urtw_write8_m(sc, 0x85, 0);
	urtw_write8_m(sc, URTW_GPIO, 0);

	/* for led */
	urtw_write8_m(sc, 0x85, 4);
	error = urtw_led_ctl(sc, URTW_LED_CTL_POWER_ON);
	if (error != 0)
		goto fail;

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;

	/* applying MAC address again. */
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	error = urtw_set_macaddr(sc, ic->ic_myaddr);
	if (error)
		goto fail;
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	error = urtw_update_msr(sc);
	if (error)
		goto fail;

	urtw_write32_m(sc, URTW_INT_TIMEOUT, 0);
	urtw_write8_m(sc, URTW_WPA_CONFIG, 0);
	urtw_write8_m(sc, URTW_RATE_FALLBACK, 0x81);
	error = urtw_set_rate(sc);
	if (error != 0)
		goto fail;

	error = rf->init(rf);
	if (error != 0)
		goto fail;
	if (rf->set_sens != NULL)
		rf->set_sens(rf);

	urtw_write16_m(sc, 0x5e, 1);
	urtw_write16_m(sc, 0xfe, 0x10);
	urtw_write8_m(sc, URTW_TALLY_SEL, 0x80);
	urtw_write8_m(sc, 0xff, 0x60);
	urtw_write16_m(sc, 0x5e, 0);
	urtw_write8_m(sc, 0x85, 4);

	error = urtw_intr_enable(sc);
	if (error != 0)
		goto fail;

	/* reset softc variables */
	sc->sc_txidx = sc->sc_tx_low_queued = sc->sc_tx_normal_queued = 0;
	sc->sc_txtimer = 0;

	if (!(sc->sc_flags & URTW_INIT_ONCE)) {
		error = urtw_open_pipes(sc);
		if (error != 0)
			goto fail;
		ret = urtw_alloc_rx_data_list(sc);
		if (error != 0)
			goto fail;
		ret = urtw_alloc_tx_data_list(sc);
		if (error != 0)
			goto fail;
		sc->sc_flags |= URTW_INIT_ONCE;
	}

	error = urtw_rx_enable(sc);
	if (error != 0)
		goto fail;
	error = urtw_tx_enable(sc);
	if (error != 0)
		goto fail;

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	ifp->if_timer = 1;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return (0);
fail:
	return (error);
}

void
urtw_set_multi(struct urtw_softc *sc)
{
	struct arpcom *ac = &sc->sc_ic.ic_ac;
	struct ifnet *ifp = &ac->ac_if;

	/*
	 * XXX don't know how to set a device.  Lack of docs.  Just try to set
	 * IFF_ALLMULTI flag here.
	 */
	ifp->if_flags |= IFF_ALLMULTI;
}

int
urtw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct urtw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	usbd_ref_incr(sc->sc_udev);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			/*
			 * If only the PROMISC or ALLMULTI flag changes, then
			 * don't do a full re-init of the chip, just update
			 * the Rx filter.
			 */
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			    (IFF_ALLMULTI | IFF_PROMISC)) != 0) {
				urtw_set_multi(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					sc->sc_init(ifp);
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				urtw_stop(ifp, 1);
		}
		sc->sc_if_flags = ifp->if_flags;
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				urtw_set_multi(sc);
			error = 0;
		}
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			urtw_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) ==
		    (IFF_RUNNING | IFF_UP))
			sc->sc_init(ifp);
		error = 0;
	}

	splx(s);

	usbd_ref_decr(sc->sc_udev);

	return (error);
}

void
urtw_start(struct ifnet *ifp)
{
	struct urtw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m0;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->sc_tx_low_queued >= URTW_TX_DATA_LIST_COUNT ||
		    sc->sc_tx_normal_queued >= URTW_TX_DATA_LIST_COUNT) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (urtw_tx_start(sc, ni, m0, URTW_PRIORITY_NORMAL)
			    != 0)
				break;
		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (urtw_tx_start(sc, ni, m0, URTW_PRIORITY_NORMAL)
			    != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}
		sc->sc_txtimer = 5;
	}
}

void
urtw_watchdog(struct ifnet *ifp)
{
	struct urtw_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_txtimer > 0) {
		if (--sc->sc_txtimer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

void
urtw_txeof_low(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct urtw_tx_data *data = priv;
	struct urtw_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_txpipe_low);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->sc_txtimer = 0;

	sc->sc_tx_low_queued--;
	ifq_clr_oactive(&ifp->if_snd);
	urtw_start(ifp);

	splx(s);
}

void
urtw_txeof_normal(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct urtw_tx_data *data = priv;
	struct urtw_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_txpipe_normal);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->sc_txtimer = 0;

	sc->sc_tx_normal_queued--;
	ifq_clr_oactive(&ifp->if_snd);
	urtw_start(ifp);

	splx(s);
}

int
urtw_tx_start(struct urtw_softc *sc, struct ieee80211_node *ni, struct mbuf *m0,
    int prior)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct urtw_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	usbd_status error;
	int xferlen;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return (ENOBUFS);

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct urtw_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = 0;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	if (sc->sc_hwrev & URTW_HWREV_8187)
		xferlen = m0->m_pkthdr.len + 4 * 3;
	else
		xferlen = m0->m_pkthdr.len + 4 * 8;

	if ((0 == xferlen % 64) || (0 == xferlen % 512))
		xferlen += 1;

	data = &sc->sc_tx_data[sc->sc_txidx];
	sc->sc_txidx = (sc->sc_txidx + 1) % URTW_TX_DATA_LIST_COUNT;

	bzero(data->buf, URTW_TX_MAXSIZE);
	data->buf[0] = m0->m_pkthdr.len & 0xff;
	data->buf[1] = (m0->m_pkthdr.len & 0x0f00) >> 8;
	data->buf[1] |= (1 << 7);

	/* XXX sc_preamble_mode is always 2. */
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE) &&
	    (sc->sc_preamble_mode == 1) && (sc->sc_currate != 0))
		data->buf[2] |= 1;
	if ((m0->m_pkthdr.len > ic->ic_rtsthreshold) &&
	    prior == URTW_PRIORITY_LOW)
		return ENOTSUP; /* TODO */
	if (wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG)
		data->buf[2] |= (1 << 1);
	/* RTS rate - 10 means we use a basic rate. */
	data->buf[2] |= (urtw_rate2rtl(2) << 3);
	/*
	 * XXX currently TX rate control depends on the rate value of
	 * RX descriptor because I don't know how to we can control TX rate
	 * in more smart way.  Please fix me you find a thing.
	 */
	data->buf[3] = sc->sc_currate;
	if (prior == URTW_PRIORITY_NORMAL) {
		if (IEEE80211_IS_MULTICAST(wh->i_addr1))
			data->buf[3] = urtw_rate2rtl(ni->ni_rates.rs_rates[0]);
		else if (ic->ic_fixed_rate != -1)
			data->buf[3] = urtw_rate2rtl(ic->ic_fixed_rate);
	}

	if (sc->sc_hwrev & URTW_HWREV_8187) {
		data->buf[8] = 3;		/* CW minimum */
		data->buf[8] |= (7 << 4);	/* CW maximum */
		data->buf[9] |= 11;		/* retry limitation */
		m_copydata(m0, 0, m0->m_pkthdr.len, (uint8_t *)&data->buf[12]);
	} else {
		data->buf[21] |= 11;		/* retry limitation */
		m_copydata(m0, 0, m0->m_pkthdr.len, (uint8_t *)&data->buf[32]);
	}

	data->ni = ni;

	/* mbuf is no longer needed. */
	m_freem(m0);

	usbd_setup_xfer(data->xfer,
	    (prior == URTW_PRIORITY_LOW) ? sc->sc_txpipe_low :
	    sc->sc_txpipe_normal, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, URTW_DATA_TIMEOUT,
	    (prior == URTW_PRIORITY_LOW) ? urtw_txeof_low : urtw_txeof_normal);
	error = usbd_transfer(data->xfer);
	if (error != USBD_IN_PROGRESS && error != USBD_NORMAL_COMPLETION) {
		printf("%s: could not send frame: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		return (EIO);
	}

	error = urtw_led_ctl(sc, URTW_LED_CTL_TX);
	if (error != 0)
		printf("%s: could not control LED (%d)\n",
		    sc->sc_dev.dv_xname, error);

	if (prior == URTW_PRIORITY_LOW)
		sc->sc_tx_low_queued++;
	else
		sc->sc_tx_normal_queued++;

	return (0);
}

usbd_status
urtw_8225_usb_init(struct urtw_softc *sc)
{
	uint8_t data;
	usbd_status error;

	urtw_write8_m(sc, URTW_RF_PINS_SELECT + 1, 0);
	urtw_write8_m(sc, URTW_GPIO, 0);
	error = urtw_read8e(sc, 0x53, &data);
	if (error)
		goto fail;
	error = urtw_write8e(sc, 0x53, data | (1 << 7));
	if (error)
		goto fail;
	urtw_write8_m(sc, URTW_RF_PINS_SELECT + 1, 4);
	urtw_write8_m(sc, URTW_GPIO, 0x20);
	urtw_write8_m(sc, URTW_GP_ENABLE, 0);

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, 0x80);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, 0x80);
	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, 0x80);

	usbd_delay_ms(sc->sc_udev, 500);
fail:
	return (error);
}

usbd_status
urtw_8185_rf_pins_enable(struct urtw_softc *sc)
{
	usbd_status error = 0;

	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, 0x1ff7);
fail:
	return (error);
}

usbd_status
urtw_8187_write_phy(struct urtw_softc *sc, uint8_t addr, uint32_t data)
{
	uint32_t phyw;
	usbd_status error;

	phyw = ((data << 8) | (addr | 0x80));
	urtw_write8_m(sc, 0x7f, ((phyw & 0xff000000) >> 24));
	urtw_write8_m(sc, 0x7e, ((phyw & 0x00ff0000) >> 16));
	urtw_write8_m(sc, 0x7d, ((phyw & 0x0000ff00) >> 8));
	urtw_write8_m(sc, 0x7c, ((phyw & 0x000000ff)));
	/*
	 * Delay removed from 8185 to 8187.
	 * usbd_delay_ms(sc->sc_udev, 1);
	 */
fail:
	return (error);
}

usbd_status
urtw_8187_write_phy_ofdm_c(struct urtw_softc *sc, uint8_t addr, uint32_t data)
{
	data = data & 0xff;
	return (urtw_8187_write_phy(sc, addr, data));
}

usbd_status
urtw_8187_write_phy_cck_c(struct urtw_softc *sc, uint8_t addr, uint32_t data)
{
	data = data & 0xff;
	return (urtw_8187_write_phy(sc, addr, data | 0x10000));
}

usbd_status
urtw_8225_setgain(struct urtw_softc *sc, int16_t gain)
{
	usbd_status error;

	urtw_8187_write_phy_ofdm(sc, 0x0d, urtw_8225_gain[gain * 4]);
	urtw_8187_write_phy_ofdm(sc, 0x1b, urtw_8225_gain[gain * 4 + 2]);
	urtw_8187_write_phy_ofdm(sc, 0x1d, urtw_8225_gain[gain * 4 + 3]);
	urtw_8187_write_phy_ofdm(sc, 0x23, urtw_8225_gain[gain * 4 + 1]);
fail:
	return (error);
}

usbd_status
urtw_8225_set_txpwrlvl(struct urtw_softc *sc, int chan)
{
	int i, idx, set;
	uint8_t *cck_pwltable;
	uint8_t cck_pwrlvl_max, ofdm_pwrlvl_min, ofdm_pwrlvl_max;
	uint8_t cck_pwrlvl = sc->sc_txpwr_cck[chan] & 0xff;
	uint8_t ofdm_pwrlvl = sc->sc_txpwr_ofdm[chan] & 0xff;
	usbd_status error;

	cck_pwrlvl_max = 11;
	ofdm_pwrlvl_max = 25;	/* 12 -> 25 */
	ofdm_pwrlvl_min = 10;

	/* CCK power setting */
	cck_pwrlvl = (cck_pwrlvl > cck_pwrlvl_max) ? cck_pwrlvl_max : cck_pwrlvl;
	idx = cck_pwrlvl % 6;
	set = cck_pwrlvl / 6;
	cck_pwltable = (chan == 14) ? urtw_8225_txpwr_cck_ch14 :
	    urtw_8225_txpwr_cck;

	urtw_write8_m(sc, URTW_TX_GAIN_CCK,
	    urtw_8225_tx_gain_cck_ofdm[set] >> 1);
	for (i = 0; i < 8; i++) {
		urtw_8187_write_phy_cck(sc, 0x44 + i,
		    cck_pwltable[idx * 8 + i]);
	}
	usbd_delay_ms(sc->sc_udev, 1);

	/* OFDM power setting */
	ofdm_pwrlvl = (ofdm_pwrlvl > (ofdm_pwrlvl_max - ofdm_pwrlvl_min)) ?
	    ofdm_pwrlvl_max : ofdm_pwrlvl + ofdm_pwrlvl_min;
	ofdm_pwrlvl = (ofdm_pwrlvl > 35) ? 35 : ofdm_pwrlvl;

	idx = ofdm_pwrlvl % 6;
	set = ofdm_pwrlvl / 6;

	error = urtw_8185_set_anaparam2(sc, URTW_8187_8225_ANAPARAM2_ON);
	if (error)
		goto fail;
	urtw_8187_write_phy_ofdm(sc, 2, 0x42);
	urtw_8187_write_phy_ofdm(sc, 6, 0);
	urtw_8187_write_phy_ofdm(sc, 8, 0);

	urtw_write8_m(sc, URTW_TX_GAIN_OFDM,
	    urtw_8225_tx_gain_cck_ofdm[set] >> 1);
	urtw_8187_write_phy_ofdm(sc, 0x5, urtw_8225_txpwr_ofdm[idx]);
	urtw_8187_write_phy_ofdm(sc, 0x7, urtw_8225_txpwr_ofdm[idx]);
	usbd_delay_ms(sc->sc_udev, 1);
fail:
	return (error);
}

usbd_status
urtw_8185_tx_antenna(struct urtw_softc *sc, uint8_t ant)
{
	usbd_status error;

	urtw_write8_m(sc, URTW_TX_ANTENNA, ant);
	usbd_delay_ms(sc->sc_udev, 1);
fail:
	return (error);
}

usbd_status
urtw_8225_rf_init(struct urtw_rf *rf)
{
	struct urtw_softc *sc = rf->rf_sc;
	int i;
	uint16_t data;
	usbd_status error;

	error = urtw_8180_set_anaparam(sc, URTW_8187_8225_ANAPARAM_ON);
	if (error)
		goto fail;

	error = urtw_8225_usb_init(sc);
	if (error)
		goto fail;

	urtw_write32_m(sc, URTW_RF_TIMING, 0x000a8008);
	urtw_read16_m(sc, URTW_8187_BRSR, &data);	/* XXX ??? */
	urtw_write16_m(sc, URTW_8187_BRSR, 0xffff);
	urtw_write32_m(sc, URTW_RF_PARA, 0x100044);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;
	urtw_write8_m(sc, URTW_CONFIG3, 0x44);
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	error = urtw_8185_rf_pins_enable(sc);
	if (error)
		goto fail;

	usbd_delay_ms(sc->sc_udev, 500);

	for (i = 0; i < nitems(urtw_8225_rf_part1); i++) {
		urtw_8225_write(sc, urtw_8225_rf_part1[i].reg,
		    urtw_8225_rf_part1[i].val);
	}
	usbd_delay_ms(sc->sc_udev, 50);
	urtw_8225_write(sc, 0x2, 0xc4d);
	usbd_delay_ms(sc->sc_udev, 200);
	urtw_8225_write(sc, 0x2, 0x44d);
	usbd_delay_ms(sc->sc_udev, 200);
	urtw_8225_write(sc, 0x0, 0x127);

	for (i = 0; i < nitems(urtw_8225_rxgain); i++) {
		urtw_8225_write(sc, 0x1, (uint8_t)(i + 1));
		urtw_8225_write(sc, 0x2, urtw_8225_rxgain[i]);
	}

	urtw_8225_write(sc, 0x0, 0x27);
	urtw_8225_write(sc, 0x0, 0x22f);

	for (i = 0; i < nitems(urtw_8225_agc); i++) {
		urtw_8187_write_phy_ofdm(sc, 0xb, urtw_8225_agc[i]);
		urtw_8187_write_phy_ofdm(sc, 0xa, (uint8_t)i + 0x80);
	}

	for (i = 0; i < nitems(urtw_8225_rf_part2); i++) {
		urtw_8187_write_phy_ofdm(sc, urtw_8225_rf_part2[i].reg,
		    urtw_8225_rf_part2[i].val);
		usbd_delay_ms(sc->sc_udev, 1);
	}

	error = urtw_8225_setgain(sc, 4);
	if (error)
		goto fail;

	for (i = 0; i < nitems(urtw_8225_rf_part3); i++) {
		urtw_8187_write_phy_cck(sc, urtw_8225_rf_part3[i].reg,
		    urtw_8225_rf_part3[i].val);
		usbd_delay_ms(sc->sc_udev, 1);
	}

	urtw_write8_m(sc, 0x5b, 0x0d);

	error = urtw_8225_set_txpwrlvl(sc, 1);
	if (error)
		goto fail;

	urtw_8187_write_phy_cck(sc, 0x10, 0x9b);
	usbd_delay_ms(sc->sc_udev, 1);
	urtw_8187_write_phy_ofdm(sc, 0x26, 0x90);
	usbd_delay_ms(sc->sc_udev, 1);

	/* TX ant A, 0x0 for B */
	error = urtw_8185_tx_antenna(sc, 0x3);
	if (error)
		goto fail;
	urtw_write32_m(sc, 0x94, 0x3dc00002);

	error = urtw_8225_rf_set_chan(rf, 1);
fail:
	return (error);
}

usbd_status
urtw_8225_rf_set_chan(struct urtw_rf *rf, int chan)
{
	struct urtw_softc *sc = rf->rf_sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c = ic->ic_ibss_chan;
	usbd_status error;

	error = urtw_8225_set_txpwrlvl(sc, chan);
	if (error)
		goto fail;
	urtw_8225_write(sc, 0x7, urtw_8225_channel[chan]);
	usbd_delay_ms(sc->sc_udev, 10);

	urtw_write8_m(sc, URTW_SIFS, 0x22);

	if (sc->sc_state == IEEE80211_S_ASSOC &&
	    ic->ic_flags & IEEE80211_F_SHSLOT)
		urtw_write8_m(sc, URTW_SLOT, IEEE80211_DUR_DS_SHSLOT);
	else
		urtw_write8_m(sc, URTW_SLOT, IEEE80211_DUR_DS_SLOT);

	if (IEEE80211_IS_CHAN_G(c)) {
		urtw_write8_m(sc, URTW_DIFS, 0x14);
		urtw_write8_m(sc, URTW_8187_EIFS, 0x5b - 0x14);
		urtw_write8_m(sc, URTW_CW_VAL, 0x73);
	} else {
		urtw_write8_m(sc, URTW_DIFS, 0x24);
		urtw_write8_m(sc, URTW_8187_EIFS, 0x5b - 0x24);
		urtw_write8_m(sc, URTW_CW_VAL, 0xa5);
	}

fail:
	return (error);
}

usbd_status
urtw_8225_rf_set_sens(struct urtw_rf *rf)
{
	struct urtw_softc *sc = rf->rf_sc;
	usbd_status error;

	if (rf->sens > 6)
		return (-1);

	if (rf->sens > 4)
		urtw_8225_write(sc, 0x0c, 0x850);
	else
		urtw_8225_write(sc, 0x0c, 0x50);

	rf->sens = 6 - rf->sens;
	error = urtw_8225_setgain(sc, rf->sens);
	if (error)
		goto fail;

	urtw_8187_write_phy_cck(sc, 0x41, urtw_8225_threshold[rf->sens]);

fail:
	return (error);
}

void
urtw_stop(struct ifnet *ifp, int disable)
{
	struct urtw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t data;
	usbd_status error;

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	timeout_del(&sc->scan_to);
	timeout_del(&sc->sc_led_ch);

	urtw_intr_disable(sc);
	urtw_read8_m(sc, URTW_CMD, &data);
	data &= ~URTW_CMD_TX_ENABLE;
	data &= ~URTW_CMD_RX_ENABLE;
	urtw_write8_m(sc, URTW_CMD, data);

	if (sc->sc_rxpipe != NULL)
		usbd_abort_pipe(sc->sc_rxpipe);
	if (sc->sc_txpipe_low != NULL)
		usbd_abort_pipe(sc->sc_txpipe_low);
	if (sc->sc_txpipe_normal != NULL)
		usbd_abort_pipe(sc->sc_txpipe_normal);

fail:
	return;
}

int
urtw_isbmode(uint16_t rate)
{
	rate = urtw_rtl2rate(rate);

	return (((rate <= 22 && rate != 12 && rate != 18) ||
	    rate == 44) ? (1) : (0));
}

void
urtw_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct urtw_rx_data *data = priv;
	struct urtw_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct ieee80211_node *ni;
	struct ieee80211_rxinfo rxi;
	struct mbuf *m, *mnew;
	uint8_t *desc, quality, rate;
	int actlen, flen, len, nf, rssi, s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_rxpipe);
		ifp->if_ierrors++;
		goto skip;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &actlen, NULL);
	if (actlen < URTW_MIN_RXBUFSZ) {
		ifp->if_ierrors++;
		goto skip;
	}

	if (sc->sc_hwrev & URTW_HWREV_8187)
		/* 4 dword and 4 byte CRC */
		len = actlen - (4 * 4);
	else
		/* 5 dword and 4 byte CRC */
		len = actlen - (4 * 5);

	desc = data->buf + len;
	flen = ((desc[1] & 0x0f) << 8) + (desc[0] & 0xff);
	if (flen > actlen) {
		ifp->if_ierrors++;
		goto skip;
	}

	rate = (desc[2] & 0xf0) >> 4;
	if (sc->sc_hwrev & URTW_HWREV_8187) {
		quality = desc[4] & 0xff;
		rssi = (desc[6] & 0xfe) >> 1;

		/* XXX correct? */
		if (!urtw_isbmode(rate)) {
			rssi = (rssi > 90) ? 90 : ((rssi < 25) ? 25 : rssi);
			rssi = ((90 - rssi) * 100) / 65;
		} else {
			rssi = (rssi > 90) ? 95 : ((rssi < 30) ? 30 : rssi);
			rssi = ((95 - rssi) * 100) / 65;
		}
	} else {
		quality = desc[12];
		rssi = 14 - desc[14] / 2;
	}

	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		goto skip;
	}
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		m_freem(mnew);
		ifp->if_ierrors++;
		goto skip;
	}

	m = data->m;
	data->m = mnew;
	data->buf = mtod(mnew, uint8_t *);

	/* finalize mbuf */
	m->m_pkthdr.len = m->m_len = flen - 4;

	s = splnet();

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct urtw_rx_radiotap_header *tap = &sc->sc_rxtap;

		/* XXX Are variables correct? */
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
		tap->wr_dbm_antsignal = (int8_t)rssi;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif
	wh = mtod(m, struct ieee80211_frame *);
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_DATA)
		sc->sc_currate = (rate > 0) ? rate : sc->sc_currate;
	ni = ieee80211_find_rxnode(ic, wh);

	/* XXX correct? */
	if (!urtw_isbmode(rate)) {
		if (quality > 127)
			quality = 0;
		else if (quality < 27)
			quality = 100;
		else
			quality = 127 - quality;
	} else
		quality = (quality > 64) ? 0 : ((64 - quality) * 100) / 64;

	nf = quality;

	/* send the frame to the 802.11 layer */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = rssi;
	rxi.rxi_tstamp = 0;
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);

	splx(s);

skip:	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->sc_rxpipe, data, data->buf, MCLBYTES,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, urtw_rxeof);
	(void)usbd_transfer(xfer);
}

usbd_status
urtw_8225v2_setgain(struct urtw_softc *sc, int16_t gain)
{
	uint8_t *gainp;
	usbd_status error;

	/* XXX for A? */
	gainp = urtw_8225v2_gain_bg;
	urtw_8187_write_phy_ofdm(sc, 0x0d, gainp[gain * 3]);
	usbd_delay_ms(sc->sc_udev, 1);
	urtw_8187_write_phy_ofdm(sc, 0x1b, gainp[gain * 3 + 1]);
	usbd_delay_ms(sc->sc_udev, 1);
	urtw_8187_write_phy_ofdm(sc, 0x1d, gainp[gain * 3 + 2]);
	usbd_delay_ms(sc->sc_udev, 1);
	urtw_8187_write_phy_ofdm(sc, 0x21, 0x17);
	usbd_delay_ms(sc->sc_udev, 1);
fail:
	return (error);
}

usbd_status
urtw_8225v2_set_txpwrlvl(struct urtw_softc *sc, int chan)
{
	int i;
	uint8_t *cck_pwrtable;
	uint8_t cck_pwrlvl_max = 15, ofdm_pwrlvl_max = 25, ofdm_pwrlvl_min = 10;
	uint8_t cck_pwrlvl = sc->sc_txpwr_cck[chan] & 0xff;
	uint8_t ofdm_pwrlvl = sc->sc_txpwr_ofdm[chan] & 0xff;
	usbd_status error;

	/* CCK power setting */
	cck_pwrlvl = (cck_pwrlvl > cck_pwrlvl_max) ? cck_pwrlvl_max : cck_pwrlvl;
	cck_pwrlvl += sc->sc_txpwr_cck_base;
	cck_pwrlvl = (cck_pwrlvl > 35) ? 35 : cck_pwrlvl;
	cck_pwrtable = (chan == 14) ? urtw_8225v2_txpwr_cck_ch14 :
	    urtw_8225v2_txpwr_cck;

	for (i = 0; i < 8; i++) {
		urtw_8187_write_phy_cck(sc, 0x44 + i, cck_pwrtable[i]);
	}
	urtw_write8_m(sc, URTW_TX_GAIN_CCK,
	    urtw_8225v2_tx_gain_cck_ofdm[cck_pwrlvl]);
	usbd_delay_ms(sc->sc_udev, 1);

	/* OFDM power setting */
	ofdm_pwrlvl = (ofdm_pwrlvl > (ofdm_pwrlvl_max - ofdm_pwrlvl_min)) ?
		ofdm_pwrlvl_max : ofdm_pwrlvl + ofdm_pwrlvl_min;
	ofdm_pwrlvl += sc->sc_txpwr_ofdm_base;
	ofdm_pwrlvl = (ofdm_pwrlvl > 35) ? 35 : ofdm_pwrlvl;

	error = urtw_8185_set_anaparam2(sc, URTW_8187_8225_ANAPARAM2_ON);
	if (error)
		goto fail;

	urtw_8187_write_phy_ofdm(sc, 2, 0x42);
	urtw_8187_write_phy_ofdm(sc, 5, 0x0);
	urtw_8187_write_phy_ofdm(sc, 6, 0x40);
	urtw_8187_write_phy_ofdm(sc, 7, 0x0);
	urtw_8187_write_phy_ofdm(sc, 8, 0x40);

	urtw_write8_m(sc, URTW_TX_GAIN_OFDM,
	    urtw_8225v2_tx_gain_cck_ofdm[ofdm_pwrlvl]);
	usbd_delay_ms(sc->sc_udev, 1);
fail:
	return (error);
}

usbd_status
urtw_8225v2_rf_init(struct urtw_rf *rf)
{
	struct urtw_softc *sc = rf->rf_sc;
	int i;
	uint16_t data;
	uint32_t data32;
	usbd_status error;

	error = urtw_8180_set_anaparam(sc, URTW_8187_8225_ANAPARAM_ON);
	if (error)
		goto fail;

	error = urtw_8225_usb_init(sc);
	if (error)
		goto fail;

	urtw_write32_m(sc, URTW_RF_TIMING, 0x000a8008);
	urtw_read16_m(sc, URTW_8187_BRSR, &data);	/* XXX ??? */
	urtw_write16_m(sc, URTW_8187_BRSR, 0xffff);
	urtw_write32_m(sc, URTW_RF_PARA, 0x100044);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;
	urtw_write8_m(sc, URTW_CONFIG3, 0x44);
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	error = urtw_8185_rf_pins_enable(sc);
	if (error)
		goto fail;

	usbd_delay_ms(sc->sc_udev, 1000);

	for (i = 0; i < nitems(urtw_8225v2_rf_part1); i++) {
		urtw_8225_write(sc, urtw_8225v2_rf_part1[i].reg,
		    urtw_8225v2_rf_part1[i].val);
		usbd_delay_ms(sc->sc_udev, 1);
	}
	usbd_delay_ms(sc->sc_udev, 50);

	urtw_8225_write(sc, 0x0, 0x1b7);

	for (i = 0; i < nitems(urtw_8225v2_rxgain); i++) {
		urtw_8225_write(sc, 0x1, (uint8_t)(i + 1));
		urtw_8225_write(sc, 0x2, urtw_8225v2_rxgain[i]);
	}

	urtw_8225_write(sc, 0x3, 0x2);
	urtw_8225_write(sc, 0x5, 0x4);
	urtw_8225_write(sc, 0x0, 0xb7);
	urtw_8225_write(sc, 0x2, 0xc4d);
	usbd_delay_ms(sc->sc_udev, 100);
	urtw_8225_write(sc, 0x2, 0x44d);
	usbd_delay_ms(sc->sc_udev, 100);

	error = urtw_8225_read(sc, 0x6, &data32);
	if (error != 0)
		goto fail;
	if (data32 != 0xe6)
		printf("%s: expect 0xe6!! (0x%x)\n", sc->sc_dev.dv_xname,
		    data32);
	if (!(data32 & 0x80)) {
		urtw_8225_write(sc, 0x02, 0x0c4d);
		usbd_delay_ms(sc->sc_udev, 200);
		urtw_8225_write(sc, 0x02, 0x044d);
		usbd_delay_ms(sc->sc_udev, 100);
		error = urtw_8225_read(sc, 0x6, &data32);
		if (error != 0)
			goto fail;
		if (!(data32 & 0x80))
			printf("%s: RF calibration failed\n",
			    sc->sc_dev.dv_xname);
	}
	usbd_delay_ms(sc->sc_udev, 100);

	urtw_8225_write(sc, 0x0, 0x2bf);
	for (i = 0; i < nitems(urtw_8225_agc); i++) {
		urtw_8187_write_phy_ofdm(sc, 0xb, urtw_8225_agc[i]);
		urtw_8187_write_phy_ofdm(sc, 0xa, (uint8_t)i + 0x80);
	}

	for (i = 0; i < nitems(urtw_8225v2_rf_part2); i++) {
		urtw_8187_write_phy_ofdm(sc, urtw_8225v2_rf_part2[i].reg,
		    urtw_8225v2_rf_part2[i].val);
	}

	error = urtw_8225v2_setgain(sc, 4);
	if (error)
		goto fail;

	for (i = 0; i < nitems(urtw_8225v2_rf_part3); i++) {
		urtw_8187_write_phy_cck(sc, urtw_8225v2_rf_part3[i].reg,
		    urtw_8225v2_rf_part3[i].val);
	}

	urtw_write8_m(sc, 0x5b, 0x0d);

	error = urtw_8225v2_set_txpwrlvl(sc, 1);
	if (error)
		goto fail;

	urtw_8187_write_phy_cck(sc, 0x10, 0x9b);
	urtw_8187_write_phy_ofdm(sc, 0x26, 0x90);

	/* TX ant A, 0x0 for B */
	error = urtw_8185_tx_antenna(sc, 0x3);
	if (error)
		goto fail;
	urtw_write32_m(sc, 0x94, 0x3dc00002);

	error = urtw_8225_rf_set_chan(rf, 1);
fail:
	return (error);
}

usbd_status
urtw_8225v2_rf_set_chan(struct urtw_rf *rf, int chan)
{
	struct urtw_softc *sc = rf->rf_sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c = ic->ic_ibss_chan;
	usbd_status error;

	error = urtw_8225v2_set_txpwrlvl(sc, chan);
	if (error)
		goto fail;

	urtw_8225_write(sc, 0x7, urtw_8225_channel[chan]);
	usbd_delay_ms(sc->sc_udev, 10);

	urtw_write8_m(sc, URTW_SIFS, 0x22);

	if(sc->sc_state == IEEE80211_S_ASSOC &&
	    ic->ic_flags & IEEE80211_F_SHSLOT)
		urtw_write8_m(sc, URTW_SLOT, IEEE80211_DUR_DS_SHSLOT);
	else
		urtw_write8_m(sc, URTW_SLOT, IEEE80211_DUR_DS_SLOT);

	if (IEEE80211_IS_CHAN_G(c)) {
		urtw_write8_m(sc, URTW_DIFS, 0x14);
		urtw_write8_m(sc, URTW_8187_EIFS, 0x5b - 0x14);
		urtw_write8_m(sc, URTW_CW_VAL, 0x73);
	} else {
		urtw_write8_m(sc, URTW_DIFS, 0x24);
		urtw_write8_m(sc, URTW_8187_EIFS, 0x5b - 0x24);
		urtw_write8_m(sc, URTW_CW_VAL, 0xa5);
	}

fail:
	return (error);
}

void
urtw_set_chan(struct urtw_softc *sc, struct ieee80211_channel *c)
{
	struct urtw_rf *rf = &sc->sc_rf;
	struct ieee80211com *ic = &sc->sc_ic;
	usbd_status error = 0;
	uint32_t data;
	u_int chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;
	/*
	 * During changing the channel we need to temporary disable
	 * TX.
	 */
	urtw_read32_m(sc, URTW_TX_CONF, &data);
	data &= ~URTW_TX_LOOPBACK_MASK;
	urtw_write32_m(sc, URTW_TX_CONF, data | URTW_TX_LOOPBACK_MAC);
	error = rf->set_chan(rf, chan);
	if (error != 0) {
		printf("%s could not change the channel\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	usbd_delay_ms(sc->sc_udev, 10);
	urtw_write32_m(sc, URTW_TX_CONF, data | URTW_TX_LOOPBACK_NONE);

fail:	return;

}

void
urtw_next_scan(void *arg)
{
	struct urtw_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);

	usbd_ref_decr(sc->sc_udev);
}

void
urtw_task(void *arg)
{
	struct urtw_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	enum ieee80211_state ostate;
	usbd_status error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return;

	ostate = ic->ic_state;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* turn link LED off */
			(void)urtw_led_off(sc, URTW_LED_GPIO);
		}
		break;

	case IEEE80211_S_SCAN:
		urtw_set_chan(sc, ic->ic_bss->ni_chan);
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
	case IEEE80211_S_ASSOC:
		urtw_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		ni = ic->ic_bss;

		/* setting bssid. */
		error = urtw_set_bssid(sc, ni->ni_bssid);
		if (error != 0)
			goto fail;
		urtw_update_msr(sc);
		/* XXX maybe the below would be incorrect. */
		urtw_write16_m(sc, URTW_ATIM_WND, 2);
		urtw_write16_m(sc, URTW_ATIM_TR_ITV, 100);
		urtw_write16_m(sc, URTW_BEACON_INTERVAL, 0x64);
		urtw_write16_m(sc, URTW_BEACON_INTERVAL_TIME, 0x3ff);
		error = urtw_led_ctl(sc, URTW_LED_CTL_LINK);
		if (error != 0)
			printf("%s: could not control LED (%d)\n",
			    sc->sc_dev.dv_xname, error);
		break;
	}

	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);

fail:
	if (error != 0)
		DPRINTF(("%s: error duing processing RUN state.",
		    sc->sc_dev.dv_xname));
}

usbd_status
urtw_8187b_update_wmm(struct urtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c = ic->ic_ibss_chan;
	uint32_t data;
	uint8_t aifs, sifs, slot, ecwmin, ecwmax;
	usbd_status error;

	sifs = 0xa;
	if (IEEE80211_IS_CHAN_G(c))
		slot = 0x9;
	else
		slot = 0x14;

	aifs = (2 * slot) + sifs;
	ecwmin = 3;
	ecwmax = 7;

	data = ((uint32_t)aifs << 0) |		/* AIFS, offset 0 */
	    ((uint32_t)ecwmin << 8) |		/* ECW minimum, offset 8 */
	    ((uint32_t)ecwmax << 12);		/* ECW maximum, offset 16 */

	urtw_write32_m(sc, URTW_AC_VO, data);
	urtw_write32_m(sc, URTW_AC_VI, data);
	urtw_write32_m(sc, URTW_AC_BE, data);
	urtw_write32_m(sc, URTW_AC_BK, data);

fail:
	return (error);
}

usbd_status
urtw_8187b_reset(struct urtw_softc *sc)
{
	uint8_t data;
	usbd_status error;

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;

	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data | URTW_CONFIG3_ANAPARAM_WRITE |
		URTW_CONFIG3_GNT_SELECT);

	urtw_write32_m(sc, URTW_ANAPARAM2, URTW_8187B_8225_ANAPARAM2_ON);
	urtw_write32_m(sc, URTW_ANAPARAM, URTW_8187B_8225_ANAPARAM_ON);
	urtw_write8_m(sc, URTW_ANAPARAM3, URTW_8187B_8225_ANAPARAM3_ON);

	urtw_write8_m(sc, 0x61, 0x10);
	urtw_read8_m(sc, 0x62, &data);
	urtw_write8_m(sc, 0x62, data & ~(1 << 5));
	urtw_write8_m(sc, 0x62, data | (1 << 5));

	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data & ~URTW_CONFIG3_ANAPARAM_WRITE);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	urtw_read8_m(sc, URTW_CMD, &data);
	data = (data & 2) | URTW_CMD_RST;
	urtw_write8_m(sc, URTW_CMD, data);
	usbd_delay_ms(sc->sc_udev, 100);

	urtw_read8_m(sc, URTW_CMD, &data);
	if (data & URTW_CMD_RST) {
		printf("%s: reset timeout\n", sc->sc_dev.dv_xname);
		goto fail;
	}

fail:
	return (error);
}

int
urtw_8187b_init(struct ifnet *ifp)
{
	struct urtw_softc *sc = ifp->if_softc;
	struct urtw_rf *rf = &sc->sc_rf;
	struct ieee80211com *ic = &sc->sc_ic;
	int ret;
	uint8_t data;
	usbd_status error;

	urtw_stop(ifp, 0);

	error = urtw_8187b_update_wmm(sc);
	if (error != 0)
		goto fail;
	error = urtw_8187b_reset(sc);
	if (error)
		goto fail;

	/* Applying MAC address again. */
	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	error = urtw_set_macaddr(sc, ic->ic_myaddr);
	if (error)
		goto fail;
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	error = urtw_update_msr(sc);
	if (error)
		goto fail;

	error = rf->init(rf);
	if (error != 0)
		goto fail;

	urtw_write8_m(sc, URTW_CMD, URTW_CMD_TX_ENABLE |
		URTW_CMD_RX_ENABLE);
	error = urtw_intr_enable(sc);
	if (error != 0)
		goto fail;

	error = urtw_write8e(sc, 0x41, 0xf4);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x40, 0x00);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x42, 0x00);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x42, 0x01);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x40, 0x0f);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x42, 0x00);
	if (error != 0)
		goto fail;
	error = urtw_write8e(sc, 0x42, 0x01);
	if (error != 0)
		goto fail;

	urtw_read8_m(sc, 0xdb, &data);
	urtw_write8_m(sc, 0xdb, data | (1 << 2));
	urtw_write16_idx_m(sc, 0x72, 0x59fa, 3);
	urtw_write16_idx_m(sc, 0x74, 0x59d2, 3);
	urtw_write16_idx_m(sc, 0x76, 0x59d2, 3);
	urtw_write16_idx_m(sc, 0x78, 0x19fa, 3);
	urtw_write16_idx_m(sc, 0x7a, 0x19fa, 3);
	urtw_write16_idx_m(sc, 0x7c, 0x00d0, 3);
	urtw_write8_m(sc, 0x61, 0);
	urtw_write8_idx_m(sc, 0x80, 0x0f, 1);
	urtw_write8_idx_m(sc, 0x83, 0x03, 1);
	urtw_write8_m(sc, 0xda, 0x10);
	urtw_write8_idx_m(sc, 0x4d, 0x08, 2);

	urtw_write32_m(sc, URTW_HSSI_PARA, 0x0600321b);

	urtw_write16_idx_m(sc, 0xec, 0x0800, 1);

	urtw_write8_m(sc, URTW_ACM_CONTROL, 0);

	/* Reset softc variables. */
	sc->sc_txidx = sc->sc_tx_low_queued = sc->sc_tx_normal_queued = 0;
	sc->sc_txtimer = 0;

	if (!(sc->sc_flags & URTW_INIT_ONCE)) {
		error = urtw_open_pipes(sc);
		if (error != 0)
			goto fail;
		ret = urtw_alloc_rx_data_list(sc);
		if (error != 0)
			goto fail;
		ret = urtw_alloc_tx_data_list(sc);
		if (error != 0)
			goto fail;
		sc->sc_flags |= URTW_INIT_ONCE;
	}

	error = urtw_rx_enable(sc);
	if (error != 0)
		goto fail;
	error = urtw_tx_enable(sc);
	if (error != 0)
		goto fail;

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ifp->if_timer = 1;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

fail:
	return (error);
}

usbd_status
urtw_8225v2_b_config_mac(struct urtw_softc *sc)
{
	int i;
	usbd_status error;

	for (i = 0; i < nitems(urtw_8187b_regtbl); i++) {
		urtw_write8_idx_m(sc, urtw_8187b_regtbl[i].reg,
		    urtw_8187b_regtbl[i].val, urtw_8187b_regtbl[i].idx);
	}

	urtw_write16_m(sc, URTW_TID_AC_MAP, 0xfa50);
	urtw_write16_m(sc, URTW_INT_MIG, 0);

	urtw_write32_idx_m(sc, 0xf0, 0, 1);
	urtw_write32_idx_m(sc, 0xf4, 0, 1);
	urtw_write8_idx_m(sc, 0xf8, 0, 1);

	urtw_write32_m(sc, URTW_RF_TIMING, 0x00004001);

fail:
	return (error);
}

usbd_status
urtw_8225v2_b_init_rfe(struct urtw_softc *sc)
{
	usbd_status error;

	urtw_write16_m(sc, URTW_RF_PINS_OUTPUT, 0x0480);
	urtw_write16_m(sc, URTW_RF_PINS_SELECT, 0x2488);
	urtw_write16_m(sc, URTW_RF_PINS_ENABLE, 0x1fff);
	usbd_delay_ms(sc->sc_udev, 100);

fail:
	return (error);
}

usbd_status
urtw_8225v2_b_update_chan(struct urtw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_channel *c = ic->ic_ibss_chan;
	uint8_t aifs, difs, eifs, sifs, slot;
	usbd_status error;

	urtw_write8_m(sc, URTW_SIFS, 0x22);

	sifs = 0xa;
	if (IEEE80211_IS_CHAN_G(c)) {
		slot = 0x9;
		difs = 0x1c;
		eifs = 0x5b;
	} else {
		slot = 0x14;
		difs = 0x32;
		eifs = 0x5b;
	}
	aifs = (2 * slot) + sifs;

	urtw_write8_m(sc, URTW_SLOT, slot);

	urtw_write8_m(sc, URTW_AC_VO, aifs);
	urtw_write8_m(sc, URTW_AC_VI, aifs);
	urtw_write8_m(sc, URTW_AC_BE, aifs);
	urtw_write8_m(sc, URTW_AC_BK, aifs);

	urtw_write8_m(sc, URTW_DIFS, difs);
	urtw_write8_m(sc, URTW_8187B_EIFS, eifs);

fail:
	return (error);
}

usbd_status
urtw_8225v2_b_rf_init(struct urtw_rf *rf)
{
	struct urtw_softc *sc = rf->rf_sc;
	int i;
	uint8_t data;
	usbd_status error;

	/* Set up ACK rate, retry limit, TX AGC, TX antenna. */
	urtw_write16_m(sc, URTW_8187B_BRSR, 0x0fff);
	urtw_read8_m(sc, URTW_CW_CONF, &data);
	urtw_write8_m(sc, URTW_CW_CONF, data |
		URTW_CW_CONF_PERPACKET_RETRY);
	urtw_read8_m(sc, URTW_TX_AGC_CTL, &data);
	urtw_write8_m(sc, URTW_TX_AGC_CTL, data |
		URTW_TX_AGC_CTL_PERPACKET_GAIN |
		URTW_TX_AGC_CTL_PERPACKET_ANTSEL);

	/* Auto rate fallback control. */
	urtw_write16_idx_m(sc, URTW_ARFR, 0x0fff, 1);	/* 1M ~ 54M */
	urtw_read8_m(sc, URTW_RATE_FALLBACK, &data);
	urtw_write8_m(sc, URTW_RATE_FALLBACK, data |
		URTW_RATE_FALLBACK_ENABLE);

	urtw_write16_m(sc, URTW_BEACON_INTERVAL, 100);
	urtw_write16_m(sc, URTW_ATIM_WND, 2);
	urtw_write16_idx_m(sc, URTW_FEMR, 0xffff, 1);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;
	urtw_read8_m(sc, URTW_CONFIG1, &data);
	urtw_write8_m(sc, URTW_CONFIG1, (data & 0x3f) | 0x80);
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	urtw_write8_m(sc, URTW_WPA_CONFIG, 0);
	urtw_8225v2_b_config_mac(sc);
	urtw_write16_idx_m(sc, URTW_RFSW_CTRL, 0x569a, 2);

	error = urtw_set_mode(sc, URTW_EPROM_CMD_CONFIG);
	if (error)
		goto fail;
	urtw_read8_m(sc, URTW_CONFIG3, &data);
	urtw_write8_m(sc, URTW_CONFIG3, data | URTW_CONFIG3_ANAPARAM_WRITE);
	error = urtw_set_mode(sc, URTW_EPROM_CMD_NORMAL);
	if (error)
		goto fail;

	urtw_8225v2_b_init_rfe(sc);

	for (i = 0; i < nitems(urtw_8225v2_b_rf); i++) {
		urtw_8225_write(sc, urtw_8225v2_b_rf[i].reg,
		    urtw_8225v2_b_rf[i].val);
	}

	for (i = 0; i < nitems(urtw_8225v2_rxgain); i++) {
		urtw_8225_write(sc, 0x1, (uint8_t)(i + 1));
		urtw_8225_write(sc, 0x2, urtw_8225v2_rxgain[i]);
	}

	urtw_8225_write(sc, 0x03, 0x080);
	urtw_8225_write(sc, 0x05, 0x004);
	urtw_8225_write(sc, 0x00, 0x0b7);
	urtw_8225_write(sc, 0x02, 0xc4d);
	urtw_8225_write(sc, 0x02, 0x44d);
	urtw_8225_write(sc, 0x00, 0x2bf);

	urtw_write8_m(sc, URTW_TX_GAIN_CCK, 0x03);
	urtw_write8_m(sc, URTW_TX_GAIN_OFDM, 0x07);
	urtw_write8_m(sc, URTW_TX_ANTENNA, 0x03);

	urtw_8187_write_phy_ofdm(sc, 0x80, 0x12);
	for (i = 0; i < nitems(urtw_8225v2_agc); i++) {
		urtw_8187_write_phy_ofdm(sc, 0x0f, urtw_8225v2_agc[i]);
		urtw_8187_write_phy_ofdm(sc, 0x0e, (uint8_t)i + 0x80);
		urtw_8187_write_phy_ofdm(sc, 0x0e, 0);
	}
	urtw_8187_write_phy_ofdm(sc, 0x80, 0x10);

	for (i = 0; i < nitems(urtw_8225v2_ofdm); i++)
		urtw_8187_write_phy_ofdm(sc, i, urtw_8225v2_ofdm[i]);

	urtw_8225v2_b_update_chan(sc);

	urtw_8187_write_phy_ofdm(sc, 0x97, 0x46);
	urtw_8187_write_phy_ofdm(sc, 0xa4, 0xb6);
	urtw_8187_write_phy_ofdm(sc, 0x85, 0xfc);
	urtw_8187_write_phy_cck(sc, 0xc1, 0x88);

	error = urtw_8225v2_b_rf_set_chan(rf, 1);
fail:
	return (error);
}

usbd_status
urtw_8225v2_b_rf_set_chan(struct urtw_rf *rf, int chan)
{
	struct urtw_softc *sc = rf->rf_sc;
	usbd_status error;

	error = urtw_8225v2_b_set_txpwrlvl(sc, chan);
	if (error)
		goto fail;

	urtw_8225_write(sc, 0x7, urtw_8225_channel[chan]);
	/*
	 * Delay removed from 8185 to 8187.
	 * usbd_delay_ms(sc->sc_udev, 10);
	 */

	urtw_write16_m(sc, URTW_AC_VO, 0x5114);
	urtw_write16_m(sc, URTW_AC_VI, 0x5114);
	urtw_write16_m(sc, URTW_AC_BE, 0x5114);
	urtw_write16_m(sc, URTW_AC_BK, 0x5114);

fail:
	return (error);
}

usbd_status
urtw_8225v2_b_set_txpwrlvl(struct urtw_softc *sc, int chan)
{
	int i;
	uint8_t *cck_pwrtable;
	uint8_t cck_pwrlvl_min, cck_pwrlvl_max, ofdm_pwrlvl_min,
	    ofdm_pwrlvl_max;
	int8_t cck_pwrlvl = sc->sc_txpwr_cck[chan] & 0xff;
	int8_t ofdm_pwrlvl = sc->sc_txpwr_ofdm[chan] & 0xff;
	usbd_status error;

	if (sc->sc_hwrev & URTW_HWREV_8187B_B) {
		cck_pwrlvl_min = 0;
		cck_pwrlvl_max = 15;
		ofdm_pwrlvl_min = 2;
		ofdm_pwrlvl_max = 17;
	} else {
		cck_pwrlvl_min = 7;
		cck_pwrlvl_max = 22;
		ofdm_pwrlvl_min = 10;
		ofdm_pwrlvl_max = 25;
	}

	/* CCK power setting */
	cck_pwrlvl = (cck_pwrlvl > (cck_pwrlvl_max - cck_pwrlvl_min)) ?
	    cck_pwrlvl_max : (cck_pwrlvl + cck_pwrlvl_min);

	cck_pwrlvl += sc->sc_txpwr_cck_base;
	cck_pwrlvl = (cck_pwrlvl > 35) ? 35 : cck_pwrlvl;
	cck_pwrlvl = (cck_pwrlvl < 0) ? 0 : cck_pwrlvl;

	cck_pwrtable = (chan == 14) ? urtw_8225v2_txpwr_cck_ch14 :
	    urtw_8225v2_txpwr_cck;

	if (sc->sc_hwrev & URTW_HWREV_8187B_B) {
		if (cck_pwrlvl <= 6)
			; /* do nothing */
		else if (cck_pwrlvl <= 11)
			cck_pwrtable += 8;
		else
			cck_pwrtable += 16;
	} else {
		if (cck_pwrlvl <= 5)
			; /* do nothing */
		else if (cck_pwrlvl <= 11)
			cck_pwrtable += 8;
		else if (cck_pwrlvl <= 17)
			cck_pwrtable += 16;
		else
			cck_pwrtable += 24;
	}

	for (i = 0; i < 8; i++) {
		urtw_8187_write_phy_cck(sc, 0x44 + i, cck_pwrtable[i]);
	}

	urtw_write8_m(sc, URTW_TX_GAIN_CCK,
	    urtw_8225v2_tx_gain_cck_ofdm[cck_pwrlvl] << 1);
	/*
	 * Delay removed from 8185 to 8187.
	 * usbd_delay_ms(sc->sc_udev, 1);
	 */

	/* OFDM power setting */
	ofdm_pwrlvl = (ofdm_pwrlvl > (ofdm_pwrlvl_max - ofdm_pwrlvl_min)) ?
	    ofdm_pwrlvl_max : ofdm_pwrlvl + ofdm_pwrlvl_min;

	ofdm_pwrlvl += sc->sc_txpwr_ofdm_base;
	ofdm_pwrlvl = (ofdm_pwrlvl > 35) ? 35 : ofdm_pwrlvl;
	ofdm_pwrlvl = (ofdm_pwrlvl < 0) ? 0 : ofdm_pwrlvl;

	urtw_write8_m(sc, URTW_TX_GAIN_OFDM,
	    urtw_8225v2_tx_gain_cck_ofdm[ofdm_pwrlvl] << 1);

	if (sc->sc_hwrev & URTW_HWREV_8187B_B) {
		if (ofdm_pwrlvl <= 11) {
			urtw_8187_write_phy_ofdm(sc, 0x87, 0x60);
			urtw_8187_write_phy_ofdm(sc, 0x89, 0x60);
		} else {
			urtw_8187_write_phy_ofdm(sc, 0x87, 0x5c);
			urtw_8187_write_phy_ofdm(sc, 0x89, 0x5c);
		}
	} else {
		if (ofdm_pwrlvl <= 11) {
			urtw_8187_write_phy_ofdm(sc, 0x87, 0x5c);
			urtw_8187_write_phy_ofdm(sc, 0x89, 0x5c);
		} else if (ofdm_pwrlvl <= 17) {
			urtw_8187_write_phy_ofdm(sc, 0x87, 0x54);
			urtw_8187_write_phy_ofdm(sc, 0x89, 0x54);
		} else {
			urtw_8187_write_phy_ofdm(sc, 0x87, 0x50);
			urtw_8187_write_phy_ofdm(sc, 0x89, 0x50);
		}
	}

	/*
	 * Delay removed from 8185 to 8187.
	 * usbd_delay_ms(sc->sc_udev, 1);
	 */
fail:
	return (error);
}

int
urtw_set_bssid(struct urtw_softc *sc, const uint8_t *bssid)
{
	int error;

	urtw_write32_m(sc, URTW_BSSID,
	    bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24);
	urtw_write16_m(sc, URTW_BSSID + 4,
	    bssid[4] | bssid[5] << 8);

	return 0;

fail:
	return error;
}

int
urtw_set_macaddr(struct urtw_softc *sc, const uint8_t *addr)
{
	int error;

	urtw_write32_m(sc, URTW_MAC0,
	    addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24);
	urtw_write16_m(sc, URTW_MAC4,
	    addr[4] | addr[5] << 8);

	return 0;

fail:
	return error;
}
@


1.64
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.63 2017/01/09 14:44:28 mpi Exp $	*/
d2959 1
a2959 1
		urtw_write8_m(sc, URTW_SLOT, 0x9);
d2961 1
a2961 1
		urtw_write8_m(sc, URTW_SLOT, 0x14);
d3389 1
a3389 1
		urtw_write8_m(sc, URTW_SLOT, 0x9);
d3391 1
a3391 1
		urtw_write8_m(sc, URTW_SLOT, 0x14);
@


1.63
log
@Remove unneeded <sys/malloc.h> from Michael W. Bombardieri.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.62 2016/04/13 11:03:37 mpi Exp $	*/
a2526 1
	ifp->if_opackets++;
a2564 1
	ifp->if_opackets++;
@


1.62
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.61 2015/12/18 19:43:14 stsp Exp $	*/
a27 1
#include <sys/malloc.h>
@


1.61
log
@Fix urtw(4) on big-endian architectures. Patch by Cedric Tessier.
Tested by Cedric on macppc/i386, and by myself on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.60 2015/11/25 03:10:00 dlg Exp $	*/
a719 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.60
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.59 2015/11/24 13:45:07 mpi Exp $	*/
d1081 1
d1591 1
d1608 1
d1651 1
d1666 1
@


1.59
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.58 2015/11/24 13:33:18 mpi Exp $	*/
d2300 1
a2300 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2426 1
a2426 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d2432 1
a2432 1
			ifp->if_flags |= IFF_OACTIVE;
d2527 1
a2527 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2566 1
a2566 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3009 2
a3010 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
a3704 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3706 1
@


1.58
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.57 2015/11/13 10:36:29 mpi Exp $	*/
a37 1
#include <net/if_arp.h>
@


1.57
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.56 2015/11/04 12:12:00 dlg Exp $	*/
a40 1
#include <net/if_types.h>
@


1.56
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.55 2015/10/25 12:11:56 mpi Exp $	*/
d2432 6
a2439 7
			if (sc->sc_tx_low_queued >= URTW_TX_DATA_LIST_COUNT ||
			    sc->sc_tx_normal_queued >=
			    URTW_TX_DATA_LIST_COUNT) {
				mq_requeue(&ic->ic_mgtq, m0);
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
d2451 1
a2451 1
			IFQ_POLL(&ifp->if_snd, m0);
a2453 7
			if (sc->sc_tx_low_queued >= URTW_TX_DATA_LIST_COUNT ||
			    sc->sc_tx_normal_queued >=
			    URTW_TX_DATA_LIST_COUNT) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.55
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.54 2015/07/15 17:52:08 stsp Exp $	*/
d2432 1
a2432 1
		IF_POLL(&ic->ic_mgtq, m0);
d2437 1
a2440 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.54
log
@Fix urtw(4) error code paths to not panic the kernel. Makes the driver work
with a somewhat flaky urtw(4) device of mine.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.53 2015/06/12 15:47:31 mpi Exp $	*/
a2334 1
	struct ifaddr *ifa;
a2346 1
		ifa = (struct ifaddr *)data;
a2347 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.53
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tests & ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.52 2015/03/14 03:38:49 jsg Exp $	*/
d1255 1
a1255 2
			panic("unsupported RF chip");
			/* NOTREACHED */
d1288 2
a1289 2
	panic("unsupported RF chip %d", data & 0xff);
	/* NOTREACHED */
d1795 1
a1795 1
	usbd_status error;
d1804 1
a1804 3
			panic("unsupported LED PIN type 0x%x",
			    sc->sc_gpio_ledpin);
			/* NOTREACHED */
a1805 3
	} else {
		panic("unsupported LED type 0x%x", type);
		/* NOTREACHED */
d1816 1
a1816 1
	usbd_status error;
d1825 1
a1825 3
			panic("unsupported LED PIN type 0x%x",
			    sc->sc_gpio_ledpin);
			/* NOTREACHED */
a1826 3
	} else {
		panic("unsupported LED type 0x%x", type);
		/* NOTREACHED */
d1855 1
a1855 2
		panic("unsupported LED mode 0x%x", mode);
		/* NOTREACHED */
d1881 1
a1881 2
		panic("unknown LED status 0x%x", sc->sc_gpio_ledstate);
		/* NOTREACHED */
d1910 1
a1910 1
		panic("could not process a LED strategy 0x%x", sc->sc_strategy);
d1946 1
a1946 2
		panic("unsupported LED mode %d", sc->sc_strategy);
		/* NOTREACHED */
d1996 1
a1996 2
		panic("unknown LED status 0x%x", sc->sc_gpio_ledstate);
		/* NOTREACHED */
d2022 1
a2022 3
			panic("unsupported operation mode 0x%x",
			    ic->ic_opmode);
			/* NOTREACHED */
d2652 1
a2652 1
		panic("TODO tx.");
@


1.52
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.51 2015/02/10 23:25:46 mpi Exp $	*/
d588 1
a588 1
	if (uaa->iface != NULL)
d592 1
a592 1
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d608 1
a609 13

	if (usbd_set_config_no(sc->sc_udev, 1, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Get the first interface handle. */
	if (usbd_device2interface_handle(sc->sc_udev, 0, &sc->sc_iface) != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.51
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.50 2014/12/22 02:28:52 tedu Exp $	*/
a33 1
#include <machine/bus.h>
@


1.50
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.49 2014/12/19 22:44:59 guenther Exp $	*/
a3168 1
	m->m_pkthdr.rcvif = ifp;
@


1.49
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.48 2014/09/01 16:02:06 mpi Exp $	*/
a2379 1
#ifdef INET
a2381 1
#endif
@


1.48
log
@Set the configuration number and get the interface handle in attach(),
like urtwn(4) does, to prevent a null dereference of the configuration
descriptor.

Issue reported and fix tested by Ludovic Coues on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.47 2014/07/13 15:52:49 mpi Exp $	*/
d32 1
a34 1
#include <machine/endian.h>
@


1.47
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.46 2014/07/12 07:59:23 mpi Exp $	*/
d611 13
a2312 14
		error = usbd_set_config_no(sc->sc_udev, URTW_CONFIG_NO, 0);
		if (error != 0) {
			printf("%s: could not set configuration no\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		/* get the first interface handle */
		error = usbd_device2interface_handle(sc->sc_udev,
		    URTW_IFACE_INDEX, &sc->sc_iface);
		if (error != 0) {
			printf("%s: could not get interface handle\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
a3731 14
		error = usbd_set_config_no(sc->sc_udev, URTW_CONFIG_NO, 0);
		if (error != 0) {
			printf("%s: could not set configuration no\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
		/* Get the first interface handle. */
		error = usbd_device2interface_handle(sc->sc_udev,
		    URTW_IFACE_INDEX, &sc->sc_iface);
		if (error != 0) {
			printf("%s: could not get interface handle\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
@


1.46
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.45 2014/03/19 10:09:19 mpi Exp $	*/
a44 1
#include <netinet/in_systm.h>
a45 1
#include <netinet/ip.h>
@


1.45
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.44 2014/03/07 18:39:02 mpi Exp $	*/
a576 1
int urtw_activate(struct device *, int);
d583 1
a583 5
	sizeof(struct urtw_softc),
	urtw_match,
	urtw_attach,
	urtw_detach,
	urtw_activate,
a784 14

	return (0);
}

int
urtw_activate(struct device *self, int act)
{
	struct urtw_softc *sc = (struct urtw_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.44
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.43 2013/08/07 01:06:43 bluhm Exp $	*/
d2499 1
a2499 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.43
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.42 2013/07/10 05:59:02 brad Exp $	*/
a57 4

#ifdef USB_DEBUG
#define	URTW_DEBUG
#endif
@


1.42
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.41 2013/04/15 09:23:01 mglocker Exp $	*/
a45 1
#include <netinet/in_var.h>
@


1.41
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.40 2013/03/28 03:58:03 tedu Exp $	*/
d3056 1
a3056 1
	if (rf->sens < 0 || rf->sens > 6)
@


1.40
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.39 2011/07/03 15:47:17 matthew Exp $	*/
d486 1
a486 1
void		urtw_rxeof(usbd_xfer_handle, usbd_private_handle,
d490 1
a490 1
void		urtw_txeof_low(usbd_xfer_handle, usbd_private_handle,
d492 1
a492 1
void		urtw_txeof_normal(usbd_xfer_handle, usbd_private_handle,
d2569 1
a2569 1
urtw_txeof_low(usbd_xfer_handle xfer, usbd_private_handle priv,
d2608 1
a2608 1
urtw_txeof_normal(usbd_xfer_handle xfer, usbd_private_handle priv,
d3117 1
a3117 1
urtw_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.39
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.38 2011/01/25 20:03:35 jakemsr Exp $	*/
a23 1
#include <sys/proc.h>
@


1.38
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.37 2011/01/11 21:04:46 damien Exp $	*/
a805 2
	case DVACT_ACTIVATE:
		break;
@


1.37
log
@use ic->ic_ibss_chan instead of ic->ic_bss->ni_chan for Rx radiotap
since the latter is not initialized in monitor mode.

should fix a panic reported by Benjamin Nadland with kismet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.36 2010/12/30 05:22:51 jakemsr Exp $	*/
a758 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);

a795 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.36
log
@* do not add timeouts if the driver is dying
* use usbd_ref_{incr,decr,wait} to not detach while another process/thread
  is using the driver
* s/usb_rem_task/usb_rem_wait_task/ in detach functions because detach
  doesn't always happen in the task thread; otherwise a task could be
  running while the driver detaches
* in detach functions, first delete pending timeouts, then wait for
  processes to be done with the driver before freeing resources

ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.35 2010/12/06 04:41:39 jakemsr Exp $	*/
d3219 2
a3220 2
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
@


1.35
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.34 2010/10/27 17:51:11 jakemsr Exp $	*/
d778 10
a792 7
	usb_rem_task(sc->sc_udev, &sc->sc_task);
	usb_rem_task(sc->sc_udev, &sc->sc_ledtask);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->sc_led_ch))
		timeout_del(&sc->sc_led_ch);

d1919 2
a1920 1
		timeout_add(&sc->sc_led_ch, tvtohz(&t));
d2041 2
a2042 1
		timeout_add(&sc->sc_led_ch, tvtohz(&t));
d2405 5
d2483 2
d3528 5
d3535 2
d3548 3
d3563 2
a3564 1
		timeout_add_msec(&sc->scan_to, 200);
@


1.34
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.33 2010/10/23 16:14:07 jakemsr Exp $	*/
d806 2
d812 1
@


1.33
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.32 2010/10/23 15:42:09 jakemsr Exp $	*/
d778 4
a781 2
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);
@


1.32
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.31 2010/08/27 17:08:01 jsg Exp $	*/
d783 4
a786 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->sc_led_ch);
@


1.31
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.30 2010/08/07 03:50:02 krw Exp $	*/
d693 3
a695 2
	usb_init_task(&sc->sc_task, urtw_task, sc);
	usb_init_task(&sc->sc_ledtask, urtw_ledusbtask, sc);
@


1.30
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.29 2010/01/21 21:30:42 miod Exp $	*/
d727 1
a727 1
		ifp->if_init = urtw_init;
d729 1
a729 1
		ifp->if_init = urtw_8187b_init;
d1031 1
d1040 1
a1040 1
		ifp->if_init(ifp);
d2416 1
a2416 1
					ifp->if_init(ifp);
d2459 1
a2459 1
			ifp->if_init(ifp);
@


1.29
log
@Do not assume mac address and bss id are stored at 32-bit aligned addresses;
inspired by other wireless drivers, makes urtw work on strict alignment
architectures.

ok jsg@@ martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.28 2009/10/13 19:33:17 pirofti Exp $	*/
d1312 1
a1312 1
	panic("unsupported RF chip %d\n", data & 0xff);
d1981 1
a1981 1
		panic("unsupported LED mode %d\n", sc->sc_strategy);
d2058 1
a2058 1
			panic("unsupported operation mode 0x%x\n",
@


1.28
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.27 2009/08/02 10:38:34 miod Exp $	*/
d577 2
d2281 3
a2283 2
	urtw_write32_m(sc, URTW_MAC0, ((uint32_t *)ic->ic_myaddr)[0]);
	urtw_write16_m(sc, URTW_MAC4, ((uint32_t *)ic->ic_myaddr)[1] & 0xffff);
d3544 3
a3546 3
		urtw_write32_m(sc, URTW_BSSID, ((uint32_t *)ni->ni_bssid)[0]);
		urtw_write16_m(sc, URTW_BSSID + 4,
		    ((uint16_t *)ni->ni_bssid)[2]);
d3669 3
a3671 2
	urtw_write32_m(sc, URTW_MAC0, ((uint32_t *)ic->ic_myaddr)[0]);
	urtw_write16_m(sc, URTW_MAC4, ((uint32_t *)ic->ic_myaddr)[1] & 0xffff);
d4082 31
@


1.27
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.26 2009/07/29 18:14:57 blambert Exp $	*/
d581 1
a581 1
int urtw_activate(struct device *, enum devact);
d797 1
a797 1
urtw_activate(struct device *self, enum devact act)
@


1.26
log
@timeout_add -> timeout_add_msec

ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.25 2009/07/29 18:08:44 martynas Exp $	*/
d801 2
a802 2
		return (EOPNOTSUPP);
	case (DVACT_DEACTIVATE):
@


1.25
log
@sitecom needs comma
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.24 2009/07/29 18:01:31 martynas Exp $	*/
d3529 1
a3529 1
		timeout_add(&sc->scan_to, hz / 5);
@


1.24
log
@- WL168 -> WL168V4
- P5B, WUSB54GCV2, WL168V1
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.23 2009/06/24 01:07:12 martynas Exp $	*/
d92 1
a92 1
	URTW_DEV_RTL8187(SITECOMEU,	WL168V1)
@


1.23
log
@print RFv1/RFv2 for 8187L dmesgs;  since code paths are very different
also print 8187B/8187L rev. ids for unknown revisions and remove dots
as suggested by jsg@@.  ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.22 2009/06/21 00:49:13 martynas Exp $	*/
d86 1
d88 1
d92 1
d101 1
a101 1
	URTW_DEV_RTL8187B(SITECOMEU,	WL168)
@


1.22
log
@simplify write_s16 routine and just use memory stack instead of two
buffers.  ok jsg@@.  tested by kevlo@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.21 2009/06/06 12:06:28 martynas Exp $	*/
a614 1
	const char *urtw_name = NULL;
d617 1
d619 1
a619 1
	sc->sc_hwrev = urtw_lookup(uaa->vendor, uaa->product)->rev;
d627 1
a627 1
			urtw_name = "RTL8187 rev. D";
d635 1
a635 1
			urtw_name = "RTL8187B rev. B (early)";
d639 1
a639 1
			urtw_name = "RTL8187 rev. B (default)";
d648 1
a648 1
			urtw_name = "RTL8187B rev. B";
d652 1
a652 1
			urtw_name = "RTL8187B rev. D";
d656 1
a656 1
			urtw_name = "RTL8187B rev. E";
d660 1
a660 1
			urtw_name = "RTL8187B rev. B (default)";
a664 2
	printf("%s: %s", sc->sc_dev.dv_xname, urtw_name);

d1284 1
d1289 1
@


1.21
log
@- implement support for rtl8187b
- change state properly in urtw_stop.  disable interrupts, rx, and
tx.  fixes scanning, ifconfig down, and some other issues
- fix rxgain;  for ver. 2
- remove delays;  that have been removed 8185 -> 8187
new one tested by jsg@@, a bunch of people on tech@@, and myself
old one tested by nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.5 2009/02/11 10:44:36 kevlo Exp $	*/
d535 1
a535 1
		    uint16_t *);
a1090 1
/* XXX why we should allocalte memory buffer instead of using memory stack? */
d1093 1
a1093 1
    uint16_t *data)
d1095 1
a1095 4
	uint8_t *buf;
	uint16_t data16;
	usb_device_request_t *req;
	usbd_status error = 0;
d1097 5
a1101 14
	data16 = *data;
	req = (usb_device_request_t *)malloc(sizeof(usb_device_request_t),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (req == NULL) {
		printf("%s: could not allocate a memory\n",
		    sc->sc_dev.dv_xname);
		goto fail0;
	}
	buf = (uint8_t *)malloc(2, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (req == NULL) {
		printf("%s: could not allocate a memory\n",
		    sc->sc_dev.dv_xname);
		goto fail1;
	}
d1103 1
a1103 13
	req->bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req->bRequest = URTW_8187_SETREGS_REQ;
	USETW(req->wValue, addr);
	USETW(req->wIndex, index);
	USETW(req->wLength, sizeof(uint16_t));
	buf[0] = (data16 & 0x00ff);
	buf[1] = (data16 & 0xff00) >> 8;

	error = usbd_do_request(sc->sc_udev, req, buf);

	free(buf, M_DEVBUF);
fail1:	free(req, M_DEVBUF);
fail0:	return (error);
d1216 1
a1216 1
	error = urtw_8225_write_s16(sc, addr, 0x8225, &data);
@


1.20
log
@reduce diff i will send in a minute
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.19 2009/06/04 23:42:02 martynas Exp $	*/
d4 1
d83 2
d92 7
d100 1
d189 46
d353 30
d425 10
a434 10
	0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0008, 0x0009,
	0x000a, 0x000b, 0x0102, 0x0103, 0x0104, 0x0105, 0x0140, 0x0141,
	0x0142, 0x0143, 0x0144, 0x0145, 0x0180, 0x0181, 0x0182, 0x0183,
	0x0184, 0x0185, 0x0188, 0x0189, 0x018a, 0x018b, 0x0243, 0x0244,
	0x0245, 0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0285, 0x0288,
	0x0289, 0x028a, 0x028b, 0x028c, 0x0342, 0x0343, 0x0344, 0x0345,
	0x0380, 0x0381, 0x0382, 0x0383, 0x0384, 0x0385, 0x0388, 0x0389,
	0x038a, 0x038b, 0x038c, 0x038d, 0x0390, 0x0391, 0x0392, 0x0393,
	0x0394, 0x0395, 0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d,
	0x03a0, 0x03a1, 0x03a2, 0x03a3, 0x03a4, 0x03a5, 0x03a8, 0x03a9,
d449 4
a452 1
	0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04
d456 12
a467 1
	0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00
d565 9
d612 1
d634 2
a635 1
			urtw_name = "RTL8187B rev. B (not supported)";
d643 20
a662 1
		urtw_name = "RTL8187B (not supported)";
d723 5
a727 1
	ifp->if_init = urtw_init;
d846 6
a851 2
	error = usbd_open_pipe(sc->sc_iface, 0x2, USBD_EXCLUSIVE_USE,
	    &sc->sc_txpipe_low);
d858 6
a863 2
	error = usbd_open_pipe(sc->sc_iface, 0x3, USBD_EXCLUSIVE_USE,
	    &sc->sc_txpipe_normal);
d870 6
a875 2
	error = usbd_open_pipe(sc->sc_iface, 0x81, USBD_EXCLUSIVE_USE,
	    &sc->sc_rxpipe);
d1297 2
a1298 6
	error = urtw_eprom_read32(sc, URTW_EPROM_RFCHIPID, &data);
	if (error != 0)
		goto fail;
	switch (data & 0xff) {
	case URTW_EPROM_RFCHIPID_RTL8225U:
		error = urtw_8225_isv2(sc, &ret);
d1300 18
a1318 8
		if (ret == 0) {
			rf->init = urtw_8225_rf_init;
			rf->set_sens = urtw_8225_rf_set_sens;
			rf->set_chan = urtw_8225_rf_set_chan;
		} else {
			rf->init = urtw_8225v2_rf_init;
			rf->set_chan = urtw_8225v2_rf_set_chan;
			rf->set_sens = NULL;
d1320 4
a1323 6
		rf->max_sens = URTW_8225_RF_MAX_SENS;
		rf->sens = URTW_8225_RF_DEF_SENS;
		break;
	default:
		panic("unsupported RF chip %d\n", data & 0xff);
		/* NOTREACHED */
d1326 5
d1332 2
a1333 1
	return (error);
d1367 29
a1395 2
	for (i = 1, j = 0; i < 4; i += 2, j++) {
		error = urtw_eprom_read32(sc, URTW_EPROM_TXPW2 + j, &data);
d1398 4
a1401 4
		sc->sc_txpwr_cck[i + 6 + 4] = data & 0xf;
		sc->sc_txpwr_cck[i + 6 + 4 + 1] = (data & 0xf00) >> 8;
		sc->sc_txpwr_ofdm[i + 6 + 4] = (data & 0xf0) >> 4;
		sc->sc_txpwr_ofdm[i + 6 + 4 + 1] = (data & 0xf000) >> 12;
d2067 4
d2235 11
a2245 9
	urtw_read8_m(sc, URTW_CW_CONF, &data8);
	data8 &= ~(URTW_CW_CONF_PERPACKET_CW | URTW_CW_CONF_PERPACKET_RETRY);
	urtw_write8_m(sc, URTW_CW_CONF, data8);

	urtw_read8_m(sc, URTW_TX_AGC_CTL, &data8);
	data8 &= ~URTW_TX_AGC_CTL_PERPACKET_GAIN;
	data8 &= ~URTW_TX_AGC_CTL_PERPACKET_ANTSEL;
	data8 &= ~URTW_TX_AGC_CTL_FEEDBACK_ANT;
	urtw_write8_m(sc, URTW_TX_AGC_CTL, data8);
d2247 17
a2263 11
	urtw_read32_m(sc, URTW_TX_CONF, &data);
	data &= ~URTW_TX_LOOPBACK_MASK;
	data |= URTW_TX_LOOPBACK_NONE;
	data &= ~(URTW_TX_DPRETRY_MASK | URTW_TX_RTSRETRY_MASK);
	data |= sc->sc_tx_retry << URTW_TX_DPRETRY_SHIFT;
	data |= sc->sc_rts_retry << URTW_TX_RTSRETRY_SHIFT;
	data &= ~(URTW_TX_NOCRC | URTW_TX_MXDMA_MASK);
	data |= URTW_TX_MXDMA_2048 | URTW_TX_CWMIN | URTW_TX_DISCW;
	data &= ~URTW_TX_SWPLCPLEN;
	data |= URTW_TX_NOICV;
	urtw_write32_m(sc, URTW_TX_CONF, data);
d2696 5
a2700 1
	xferlen = m0->m_pkthdr.len + 4 * 3;
a2735 3
	data->buf[8] = 3;		/* CW minimum */
	data->buf[8] |= (7 << 4);	/* CW maximum */
	data->buf[9] |= 11;		/* retry limitation */
d2737 10
a2746 1
	m_copydata(m0, 0, m0->m_pkthdr.len, (uint8_t *)&data->buf[12]);
d2825 4
a2828 1
	usbd_delay_ms(sc->sc_udev, 1);
d3086 3
d3092 2
d3097 6
d3109 3
d3153 7
a3159 2
	/* 4 dword and 4 byte CRC */
	len = actlen - (4 * 4);
d3168 12
a3179 6
	quality = desc[4] & 0xff;
	/* XXX correct? */
	rssi = (desc[6] & 0xfe) >> 1;
	if (!urtw_isbmode(rate)) {
		rssi = (rssi > 90) ? 90 : ((rssi < 25) ? 25 : rssi);
		rssi = ((90 - rssi) * 100) / 65;
d3181 2
a3182 2
		rssi = (rssi > 90) ? 95 : ((rssi < 30) ? 30 : rssi);
		rssi = ((95 - rssi) * 100) / 65;
d3236 11
a3246 1
	nf = (quality > 64) ? 0 : ((64 - quality) * 100) / 64;
d3571 1
a3571 1
		urtw_write16_m(sc, URTW_BEACON_INTERVAL_TIME, 100);
d3585 513
@


1.19
log
@- factor out rf into its own structure
- clean up the softc a bit
- remove unused SET_CHANNEL
- init set sens
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.18 2009/06/04 21:52:10 martynas Exp $	*/
d747 1
a747 1
		struct urtw_rx_data *data = &sc->sc_rxdata[i];
d759 7
d800 1
a800 1
		struct urtw_rx_data *data = &sc->sc_rxdata[i];
d819 1
a819 1
		struct urtw_tx_data *data = &sc->sc_txdata[i];
d865 1
a865 1
		struct urtw_tx_data *data = &sc->sc_txdata[i];
d2009 1
a2009 1
	struct urtw_rx_data *rxdata;
d2017 1
a2017 1
		rxdata = &sc->sc_rxdata[i];
d2019 4
a2022 4
		usbd_setup_xfer(rxdata->xfer, sc->sc_rxpipe, rxdata,
		    rxdata->buf, MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT,
		    urtw_rxeof);
		error = usbd_transfer(rxdata->xfer);
d2504 1
a2504 1
	data = &sc->sc_txdata[sc->sc_txidx];
@


1.18
log
@- 8187 uses different anaparam values
- use function pointer we've saved;  that'll make things easier for 8187b.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.17 2009/06/04 21:21:15 martynas Exp $	*/
d436 3
a438 3
usbd_status	urtw_8225_rf_init(struct urtw_softc *);
usbd_status	urtw_8225_rf_set_chan(struct urtw_softc *, int);
usbd_status	urtw_8225_rf_set_sens(struct urtw_softc *, int);
d440 2
a441 2
usbd_status	urtw_8225v2_rf_init(struct urtw_softc *);
usbd_status	urtw_8225v2_rf_set_chan(struct urtw_softc *, int);
d1136 1
d1141 2
d1152 3
a1154 3
			sc->sc_rf_init = urtw_8225_rf_init;
			sc->sc_rf_set_sens = urtw_8225_rf_set_sens;
			sc->sc_rf_set_chan = urtw_8225_rf_set_chan;
d1156 3
a1158 2
			sc->sc_rf_init = urtw_8225v2_rf_init;
			sc->sc_rf_set_chan = urtw_8225v2_rf_set_chan;
d1160 2
a1161 2
		sc->sc_max_sens = URTW_8225_RF_MAX_SENS;
		sc->sc_sens = URTW_8225_RF_DEF_SENS;
d2072 1
d2115 1
a2115 1
	error = sc->sc_rf_init(sc);
d2118 2
a2119 2
	if (sc->sc_rf_set_sens != NULL)
		sc->sc_rf_set_sens(sc, sc->sc_sens);
d2709 1
a2709 1
urtw_8225_rf_init(struct urtw_softc *sc)
d2711 1
d2800 1
a2800 1
	error = urtw_8225_rf_set_chan(sc, 1);
d2806 1
a2806 1
urtw_8225_rf_set_chan(struct urtw_softc *sc, int chan)
d2808 1
d2842 1
a2842 1
urtw_8225_rf_set_sens(struct urtw_softc *sc, int sens)
d2844 1
d2847 1
a2847 1
	if (sens < 0 || sens > 6)
d2850 1
a2850 1
	if (sens > 4)
d2855 2
a2856 2
	sens = 6 - sens;
	error = urtw_8225_setgain(sc, sens);
d2860 1
a2860 1
	urtw_8187_write_phy_cck(sc, 0x41, urtw_8225_threshold[sens]);
a2886 1

d3082 1
a3082 1
urtw_8225v2_rf_init(struct urtw_softc *sc)
d3084 1
d3194 1
a3194 1
	error = urtw_8225_rf_set_chan(sc, 1);
d3200 1
a3200 1
urtw_8225v2_rf_set_chan(struct urtw_softc *sc, int chan)
d3202 1
d3239 1
d3255 1
a3255 1
	error = sc->sc_rf_set_chan(sc, chan);
@


1.17
log
@detect & print the revision (rev. d, b) of rtl8187l chip using the
tx_conf register.  if you get "not supported" in your dmesg;  it's
actually an (early) rtl8187b that's using rtl8187l id;  so you
should test the diff on tech@@.
otherwise;  rtl8187b devices not matched yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.16 2009/06/04 21:06:52 martynas Exp $	*/
d880 3
a882 2
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		urtw_init(ifp);
d1592 1
a1592 1
	error = urtw_8180_set_anaparam(sc, URTW_8225_ANAPARAM_ON);
d1595 1
a1595 1
	error = urtw_8185_set_anaparam2(sc, URTW_8225_ANAPARAM2_ON);
d1631 1
a1631 1
	error = urtw_8180_set_anaparam(sc, URTW_8225_ANAPARAM_ON);
d1634 1
a1634 1
	error = urtw_8185_set_anaparam2(sc, URTW_8225_ANAPARAM2_ON);
d2226 1
a2226 1
					urtw_init(ifp);
d2269 1
a2269 1
			urtw_init(ifp);
d2676 1
a2676 1
	error = urtw_8185_set_anaparam2(sc, URTW_8225_ANAPARAM2_ON);
d2710 1
a2710 1
	error = urtw_8180_set_anaparam(sc, URTW_8225_ANAPARAM_ON);
d3057 1
a3057 1
	error = urtw_8185_set_anaparam2(sc, URTW_8225_ANAPARAM2_ON);
d3082 1
a3082 1
	error = urtw_8180_set_anaparam(sc, URTW_8225_ANAPARAM_ON);
d3239 1
a3239 1
	 * During changing the channel we need to temporary be disable
@


1.16
log
@- prepare for multiple revisions;  urtw_lookup stuff
- fix some comments
- remove var from a declaration;  for consistency
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.15 2009/06/04 20:51:44 martynas Exp $	*/
d504 1
d508 28
d623 1
a623 2
	printf("%s: address %s\n",
	    sc->sc_dev.dv_xname, ether_sprintf(ic->ic_myaddr));
d627 1
a627 1
	printf("%s: %s failed!\n", sc->sc_dev.dv_xname, __func__);
@


1.15
log
@- make comments understandable by lint
- reduce diff a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.14 2009/06/04 20:07:34 martynas Exp $	*/
d73 17
a89 10
/* recognized device vendors/products */
static const struct usb_devno urtw_devs[] = {
#define	URTW_DEV(v,p) { USB_VENDOR_##v, USB_PRODUCT_##v##_##p }
	URTW_DEV(DICKSMITH, RTL8187),
	URTW_DEV(LOGITEC, RTL8187),
	URTW_DEV(REALTEK, RTL8187),
	URTW_DEV(SPHAIRON, RTL8187),
	URTW_DEV(SURECOM, EP9001G2A),
	URTW_DEV(NETGEAR, WG111V2)
#undef URTW_DEV
d91 2
d292 1
a292 1
static uint8_t urtw_8225_txpwr_ofdm[]={
d296 1
a296 1
static uint8_t urtw_8225v2_gain_bg[]={
d463 1
a463 1
usbd_status	urtw_tx_enable(struct urtw_softc *sc);
d488 1
a488 1
		return UMATCH_NONE;
d490 1
a490 1
	return ((usb_lookup(urtw_devs, uaa->vendor, uaa->product) != NULL) ?
@


1.14
log
@difs&eifs are 8187 regs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.13 2009/06/04 19:53:17 martynas Exp $	*/
d216 1
a216 1
	{ 0x0c, 0x0050 }, { 0x0d, 0x06db }, { 0x0e, 0x0029 }, { 0x0f, 0x0914 },
d258 1
a258 1
	0x8d, 0x8d, 0x8d, 0x8d, 0x9d, 0xad, 0xbd,
d349 1
a349 1
	0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
d1123 1
a1123 1
		/* never reach */
d1617 1
a1617 1
			/* never reach */
d1621 1
a1621 1
		/* never reach */
d1643 1
a1643 1
			/* never reach */
d1647 1
a1647 1
		/* never reach */
d1677 1
a1677 1
		/* never reach */
d1703 1
a1703 1
		/* never reach */
a1710 1

a1716 1

a1722 1

d1769 1
a1769 1
		/* never reach */
d1819 1
a1819 1
		/* never reach */
d1843 1
a1843 1
			/* never reach */
d2097 1
a2097 1
			     sc->sc_dev.dv_xname);
d2185 1
a2185 1
			    	urtw_set_multi(sc);
d2219 1
a2219 1
		    	urtw_set_chan(sc, ic->ic_ibss_chan);
d2261 1
a2261 1
			    	ifp->if_flags |= IFF_OACTIVE;
d2283 1
a2283 1
			    	ifp->if_flags |= IFF_OACTIVE;
a2576 1

a2583 1

d2696 1
@


1.13
log
@- KNF
- nitemize
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.12 2009/06/04 19:45:36 martynas Exp $	*/
d1897 1
a1897 1
	urtw_read16_m(sc, URTW_BRSR, &data);
d1903 1
a1903 1
	urtw_write16_m(sc, URTW_BRSR, data);
d2686 2
a2687 2
	urtw_read16_m(sc, URTW_BRSR, &data);		/* XXX ??? */
	urtw_write16_m(sc, URTW_BRSR, 0xffff);
d2788 1
a2788 1
		urtw_write8_m(sc, URTW_EIFS, 0x5b - 0x14);
d2792 1
a2792 1
		urtw_write8_m(sc, URTW_EIFS, 0x5b - 0x24);
d3057 2
a3058 2
	urtw_read16_m(sc, URTW_BRSR, &data);		/* XXX ??? */
	urtw_write16_m(sc, URTW_BRSR, 0xffff);
d3181 1
a3181 1
		urtw_write8_m(sc, URTW_EIFS, 0x5b - 0x14);
d3185 1
a3185 1
		urtw_write8_m(sc, URTW_EIFS, 0x5b - 0x24);
@


1.12
log
@- update io functions to support index
- add index macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.11 2009/06/04 19:37:26 martynas Exp $	*/
d185 15
a199 15
	0x0000,		/* dummy channel 0  */
	0x085c,		/* 1  */
	0x08dc,		/* 2  */
	0x095c,		/* 3  */
	0x09dc,		/* 4  */
	0x0a5c,		/* 5  */
	0x0adc,		/* 6  */
	0x0b5c,		/* 7  */
	0x0bdc,		/* 8  */
	0x0c5c,		/* 9  */
	0x0cdc,		/* 10  */
	0x0d5c,		/* 11  */
	0x0ddc,		/* 12  */
	0x0e5c,		/* 13  */
	0x0f72,		/* 14  */
d203 7
a209 7
	0x23, 0x88, 0x7c, 0xa5,		/* -82dbm  */
	0x23, 0x88, 0x7c, 0xb5,		/* -82dbm  */
	0x23, 0x88, 0x7c, 0xc5,		/* -82dbm  */
	0x33, 0x80, 0x79, 0xc5,		/* -78dbm  */
	0x43, 0x78, 0x76, 0xc5,		/* -74dbm  */
	0x53, 0x60, 0x73, 0xc5,		/* -70dbm  */
	0x63, 0x58, 0x70, 0xc5,		/* -66dbm  */
d288 7
a294 7
	0x23, 0x15, 0xa5,		/* -82-1dbm  */
	0x23, 0x15, 0xb5,		/* -82-2dbm  */
	0x23, 0x15, 0xc5,		/* -82-3dbm  */
	0x33, 0x15, 0xc5,		/* -78dbm  */
	0x43, 0x15, 0xc5,		/* -74dbm  */
	0x53, 0x15, 0xc5,		/* -70dbm  */
	0x63, 0x15, 0xc5,		/* -66dbm  */
d481 2
a482 2
	return (usb_lookup(urtw_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
d511 1
a511 1
	error = urtw_led_init(sc);		/* XXX incompleted  */
d518 1
a518 1
	/* XXX for what?  */
d673 1
a673 1
	/* tx pipe - low priority packets  */
d681 1
a681 1
	/* tx pipe - normal priority packets  */
d689 1
a689 1
	/* rx pipe  */
d899 1
a899 1
/* XXX why we should allocalte memory buffer instead of using memory stack?  */
d1123 1
a1123 1
		/* never reach  */
d1208 1
a1208 1
	/* NB: make sure the buffer is initialized  */
d1330 1
a1330 1
	/* masking  */
d1334 1
a1334 1
	/* unmasking  */
d1617 1
a1617 1
			/* never reach  */
d1621 1
a1621 1
		/* never reach  */
d1643 1
a1643 1
			/* never reach  */
d1647 1
a1647 1
		/* never reach  */
d1677 1
a1677 1
		/* never reach  */
d1703 1
a1703 1
		/* never reach  */
d1772 1
a1772 1
		/* never reach  */
d1822 1
a1822 1
		/* never reach  */
d1846 1
a1846 1
			/* never reach  */
d1863 1
a1863 1
			return urtw_ratetable[i].val;
d1876 1
a1876 1
			return urtw_ratetable[i].reg;
d2046 1
a2046 1
	/* for led  */
d2056 1
a2056 1
	/* applying MAC address again.  */
d2092 1
a2092 1
	/* reset softc variables  */
d2465 1
a2465 1
	/* XXX sc_preamble_mode is always 2.  */
d2475 1
a2475 1
	/* RTS rate - 10 means we use a basic rate.  */
d2489 3
a2491 3
	data->buf[8] = 3;		/* CW minimum  */
	data->buf[8] |= (7 << 4);	/* CW maximum  */
	data->buf[9] |= 11;		/* retry limitation  */
d2617 1
a2617 1
	ofdm_pwrlvl_max = 25;	/* 12 -> 25  */
d2714 1
a2714 1
	for (i = 0; i < 95; i++) {
d2722 1
a2722 1
	for (i = 0; i < 128; i++) {
d2806 1
a2806 1
		return -1;
d2848 2
a2849 2
	return ((rate <= 22 && rate != 12 && rate != 18) ||
	    rate == 44) ? (1) : (0);
d2882 1
a2882 1
	/* 4 dword and 4 byte CRC  */
d2893 1
a2893 1
	/* XXX correct?  */
d2934 1
a2934 1
		/* XXX Are variables correct?  */
d2953 1
a2953 1
	/* XXX correct?  */
d2979 1
a2979 1
	/* XXX for A?  */
d3084 1
a3084 1
	for (i = 0; i < 95; i++) {
d3118 1
a3118 1
	for (i = 0; i < 128; i++) {
d3267 1
a3267 1
		/* setting bssid.  */
d3272 1
a3272 1
		/* XXX maybe the below would be incorrect.  */
@


1.11
log
@- fix some comments
- remove some unused fields from softc
- spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.10 2009/06/04 19:30:19 martynas Exp $	*/
d85 3
d89 6
a94 1
	error = urtw_read8_c(sc, val, data);			\
d99 6
a104 1
	error = urtw_write8_c(sc, val, data);			\
d109 6
a114 1
	error = urtw_read16_c(sc, val, data);			\
d119 6
a124 1
	error = urtw_write16_c(sc, val, data);			\
d129 6
a134 1
	error = urtw_read32_c(sc, val, data);			\
d139 6
a144 1
	error = urtw_write32_c(sc, val, data);			\
d396 6
a401 6
usbd_status	urtw_read8_c(struct urtw_softc *, int, uint8_t *);
usbd_status	urtw_read16_c(struct urtw_softc *, int, uint16_t *);
usbd_status	urtw_read32_c(struct urtw_softc *, int, uint32_t *);
usbd_status	urtw_write8_c(struct urtw_softc *, int, uint8_t);
usbd_status	urtw_write16_c(struct urtw_softc *, int, uint16_t);
usbd_status	urtw_write32_c(struct urtw_softc *, int, uint32_t);
d1359 1
a1359 1
urtw_read8_c(struct urtw_softc *sc, int val, uint8_t *data)
d1367 1
a1367 1
	USETW(req.wIndex, 0);
d1391 1
a1391 1
urtw_read16_c(struct urtw_softc *sc, int val, uint16_t *data)
d1399 1
a1399 1
	USETW(req.wIndex, 0);
d1407 1
a1407 1
urtw_read32_c(struct urtw_softc *sc, int val, uint32_t *data)
d1415 1
a1415 1
	USETW(req.wIndex, 0);
d1423 1
a1423 1
urtw_write8_c(struct urtw_softc *sc, int val, uint8_t data)
d1430 1
a1430 1
	USETW(req.wIndex, 0);
d1451 1
a1451 1
urtw_write16_c(struct urtw_softc *sc, int val, uint16_t data)
d1458 1
a1458 1
	USETW(req.wIndex, 0);
d1465 1
a1465 1
urtw_write32_c(struct urtw_softc *sc, int val, uint32_t data)
d1472 1
a1472 1
	USETW(req.wIndex, 0);
@


1.10
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.9 2009/06/04 19:27:27 martynas Exp $	*/
d209 1
a209 1
static uint16_t urtw_8225_rxgain[] = {	
d1043 1
a1043 1
	
d1147 1
a1147 1
	
d1554 1
a1554 1
	
d1780 1
a1780 1
	
d1859 1
a1859 1
	
d1915 1
a1915 1
	
d2582 1
a2582 1
	
d2601 1
a2601 1
	
d2606 1
a2606 1
	
d2680 1
a2680 1
	
d2688 1
a2688 1
	
d2699 1
a2699 1
	
d2715 1
a2715 1
	
d2752 1
a2752 1
	
d2777 1
a2777 1
	else	
d2784 1
a2784 1
	
d2885 1
a2885 1
		
d2983 1
a2983 1
	
d3094 1
a3094 1
	
d3109 1
a3109 1
	
d3145 1
a3145 1
	
d3172 1
a3172 1
	 * during changing th channel we need to temporarily be disable
d3225 1
a3225 1
	
d3241 1
a3241 1
		urtw_write16_m(sc, URTW_ATIM_TR_ITV, 100);	
d3258 1
@


1.9
log
@instead of having some 'generic' data str. with "NB: don't use it
for tx" for some fields, and functions trying to do everything;
split it into rx_data & tx_data.  this way it's less error-prone.
i've actually fixed a bug doing this.
"please start comitting this stuff" jsg@@
@
text
@d1 2
a2 1
/*	$OpenBSD: if_urtw.c,v 1.8 2009/06/04 19:11:48 martynas Exp $	*/
d211 1
a211 1
	0x040a, 0x040b, 0x0502, 0x0503, 0x0504, 0x0505, 0x0540, 0x0541,  
d213 1
a213 1
	0x0584, 0x0585, 0x0588, 0x0589, 0x058a, 0x058b, 0x0643, 0x0644, 
d218 3
a220 3
	0x0794, 0x0795, 0x0798, 0x0799, 0x079a, 0x079b, 0x079c, 0x079d,  
	0x07a0, 0x07a1, 0x07a2, 0x07a3, 0x07a4, 0x07a5, 0x07a8, 0x07a9,  
	0x07aa, 0x07ab, 0x07ac, 0x07ad, 0x07b0, 0x07b1, 0x07b2, 0x07b3,  
d256 6
a261 6
        0x23, 0x15, 0xb5,		/* -82-2dbm  */
        0x23, 0x15, 0xc5,		/* -82-3dbm  */
        0x33, 0x15, 0xc5,		/* -78dbm  */
        0x43, 0x15, 0xc5,		/* -74dbm  */
        0x53, 0x15, 0xc5,		/* -70dbm  */
        0x63, 0x15, 0xc5,		/* -66dbm  */
d273 1
a273 1
	{ 0x04, 0x00 },	{ 0x05, 0x00 }, { 0x06, 0x40 }, { 0x07, 0x00 },
d296 6
a301 6
        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0008, 0x0009,
	0x000a,	0x000b, 0x0102, 0x0103, 0x0104, 0x0105, 0x0140, 0x0141,	  
        0x0142,	0x0143, 0x0144, 0x0145, 0x0180, 0x0181, 0x0182, 0x0183,
	0x0184,	0x0185, 0x0188, 0x0189, 0x018a, 0x018b, 0x0243, 0x0244,	 
	0x0245,	0x0280, 0x0281, 0x0282, 0x0283, 0x0284, 0x0285, 0x0288,
        0x0289, 0x028a, 0x028b, 0x028c, 0x0342, 0x0343, 0x0344, 0x0345,
d304 3
a306 3
	0x0394, 0x0395, 0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d,	  
	0x03a0, 0x03a1, 0x03a2, 0x03a3, 0x03a4, 0x03a5, 0x03a8, 0x03a9,	  
	0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03b0, 0x03b1, 0x03b2, 0x03b3,	
d384 1
a384 1
usbd_status	urtw_8187_write_phy_ofdm_c(struct urtw_softc *, uint8_t, 
d386 1
a386 1
usbd_status	urtw_8187_write_phy_cck_c(struct urtw_softc *, uint8_t, 
d391 1
a391 1
usbd_status	urtw_8225_write_s16(struct urtw_softc *, uint8_t, int, 
d644 1
a644 1
		printf("%s: could not open Tx low pipe: %s\n", 
d886 1
a886 1
		printf("%s: could not allocate a memory\n", 
d2229 1
a2229 1
			    sc->sc_tx_normal_queued >= 
d2241 1
a2241 1
			if (urtw_tx_start(sc, ni, m0, URTW_PRIORITY_NORMAL) 
d2268 1
a2268 1
			if (urtw_tx_start(sc, ni, m0, URTW_PRIORITY_NORMAL) 
d2480 1
a2480 1
		printf("%s: could not control LED (%d)\n", 
d3068 1
a3068 1
		printf("%s: expect 0xe6!! (0x%x)\n", sc->sc_dev.dv_xname, 
d3079 1
a3079 1
			printf("%s: RF calibration failed\n", 
d3172 1
a3172 1
	 * during changing th channel we need to temporarily be disable 
d3256 1
a3256 1
  		    sc->sc_dev.dv_xname));
@


1.8
log
@trying to split some parts;
- tx_start never actually free'd mbufs;  oops
report/test/ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.7 2009/03/10 09:48:46 kevlo Exp $	*/
a335 2
int		urtw_alloc_data_list(struct urtw_softc *, struct urtw_data [],
		    int, int, int);
a339 3
void		urtw_free_data_list(struct urtw_softc *,
		    usbd_pipe_handle, usbd_pipe_handle,
		    struct urtw_data data[], int);
d671 1
a671 2
urtw_alloc_data_list(struct urtw_softc *sc, struct urtw_data data[],
	int ndata, int maxsz, int fillmbuf)
d675 12
a686 2
	for (i = 0; i < ndata; i++) {
		struct urtw_data *dp = &data[i];
d688 3
a690 4
		dp->sc = sc;
		dp->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (dp->xfer == NULL) {
			printf("%s: could not allocate xfer\n", 
d695 6
a700 28
		if (fillmbuf) {
			MGETHDR(dp->m, M_DONTWAIT, MT_DATA);
			if (dp->m == NULL) {
				printf("%s: could not allocate rx mbuf\n",
				    sc->sc_dev.dv_xname);
				error = ENOMEM;
				goto fail;
			}
			MCLGET(dp->m, M_DONTWAIT);
			if (!(dp->m->m_flags & M_EXT)) {
				printf("%s: could not allocate rx mbuf cluster"
				    "\n", sc->sc_dev.dv_xname);
				error = ENOMEM;
				goto fail;
			}
			dp->buf = mtod(dp->m, uint8_t *);
		} else {
			dp->m = NULL;
			dp->buf = usbd_alloc_buffer(dp->xfer, maxsz);
			if (dp->buf == NULL) {
				printf("%s: could not allocate buffer\n",
				    sc->sc_dev.dv_xname);
				error = ENOMEM;
				goto fail;
			}
			if (((unsigned long)dp->buf) % 4)
				printf("%s: warn: unaligned buffer %p\n",
				    sc->sc_dev.dv_xname, dp->buf);
d702 1
a702 1
		dp->ni = NULL;
d707 2
a708 1
fail:	urtw_free_data_list(sc, NULL, NULL, data, ndata);
d713 1
a713 2
urtw_free_data_list(struct urtw_softc *sc, usbd_pipe_handle pipe1,
    usbd_pipe_handle pipe2, struct urtw_data data[], int ndata)
a714 1
	struct ieee80211com *ic = &sc->sc_ic;
d717 14
a730 20
	/* make sure no transfers are pending */
	if (pipe1 != NULL)
		usbd_abort_pipe(pipe1);
	if (pipe2 != NULL)
		usbd_abort_pipe(pipe2);

	for (i = 0; i < ndata; i++) {
		struct urtw_data *dp = &data[i];

		if (dp->xfer != NULL) {
			usbd_free_xfer(dp->xfer);
			dp->xfer = NULL;
		}
		if (dp->m != NULL) {
			m_freem(dp->m);
			dp->m = NULL;
		}
		if (dp->ni != NULL) {
			ieee80211_release_node(ic, dp->ni);
			dp->ni = NULL;
d736 1
a736 1
urtw_alloc_rx_data_list(struct urtw_softc *sc)
d738 1
d740 13
a752 3
	return urtw_alloc_data_list(sc,
	    sc->sc_rxdata, URTW_RX_DATA_LIST_COUNT, MCLBYTES, 1 /* mbufs */);
}
d754 7
a760 3
void
urtw_free_rx_data_list(struct urtw_softc *sc)
{
d762 4
a765 3
	urtw_free_data_list(sc, sc->sc_rxpipe, NULL, sc->sc_rxdata,
	    URTW_RX_DATA_LIST_COUNT);
}
d767 1
a767 3
int
urtw_alloc_tx_data_list(struct urtw_softc *sc)
{
d769 3
a771 3
	return urtw_alloc_data_list(sc,
	    sc->sc_txdata, URTW_TX_DATA_LIST_COUNT, URTW_TX_MAXSIZE,
	    0 /* no mbufs */);
d777 2
d780 18
a797 2
	urtw_free_data_list(sc, sc->sc_txpipe_low, sc->sc_txpipe_normal,
	    sc->sc_txdata, URTW_TX_DATA_LIST_COUNT);
d1929 1
a1929 1
	struct urtw_data *rxdata;
d2302 1
a2302 1
	struct urtw_data *data = priv;
d2341 1
a2341 1
	struct urtw_data *data = priv;
d2381 1
a2381 1
	struct urtw_data *data;
a2460 1
	data->m = NULL;
d2821 1
a2821 1
	struct urtw_data *data = priv;
@


1.7
log
@remove IBSS and HostAP modes since these aren't advertised in ic->ic_caps

pointed out by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.6 2009/03/03 07:49:27 kevlo Exp $	*/
d2455 4
a2458 1
	data->m = m0;
@


1.6
log
@more RealTek RTL8187 based devices

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.5 2009/02/11 10:44:36 kevlo Exp $	*/
a1801 6
			break;
		case IEEE80211_M_IBSS:
			data |= URTW_MSR_LINK_ADHOC;
			break;
		case IEEE80211_M_HOSTAP:
			data |= URTW_MSR_LINK_HOSTAP;
@


1.5
log
@- add a missing break
- stop the device before the initialization
- reduce delays

>From FreeBSD

ok jsg@@, martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.4 2009/01/27 21:14:35 martynas Exp $	*/
d75 2
d78 2
@


1.4
log
@rum -> urtw.  ok jsg@@, kevlo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.3 2008/12/10 01:31:31 kevlo Exp $	*/
a688 1
			/* XXX check maxsz */
a760 3
	/* XXX todo  */
	printf("%s: WARNING: rx buffer is smaller than %d\n",
	    sc->sc_dev.dv_xname, URTW_RX_MAXSIZE);
d1029 1
a1029 1
	usbd_delay_ms(sc->sc_udev, 1100);
d1032 1
a1032 1

d1520 1
a1520 1
	usbd_delay_ms(sc->sc_udev, 200);
d1531 1
a1531 1
	usbd_delay_ms(sc->sc_udev, 200);
d1536 1
a1536 1
	usbd_delay_ms(sc->sc_udev, 200);
d1547 1
a1547 1
	usbd_delay_ms(sc->sc_udev, 200);
d1801 1
d1999 2
d2506 1
a2506 2
	usbd_delay_ms(sc->sc_udev, 100);
	usbd_delay_ms(sc->sc_udev, 1000);
d2661 1
a2661 1
	usbd_delay_ms(sc->sc_udev, 1000);
a2665 1
		usbd_delay_ms(sc->sc_udev, 1);
d2667 1
a2667 1
	usbd_delay_ms(sc->sc_udev, 100);
a2683 1
		usbd_delay_ms(sc->sc_udev, 1);
a2684 1
		usbd_delay_ms(sc->sc_udev, 1);
d3040 1
a3040 1
	usbd_delay_ms(sc->sc_udev, 100);
a3045 1
		usbd_delay_ms(sc->sc_udev, 1);
a3046 1
		usbd_delay_ms(sc->sc_udev, 1);
a3049 1
	usbd_delay_ms(sc->sc_udev, 1);
a3050 1
	usbd_delay_ms(sc->sc_udev, 1);
a3051 1
	usbd_delay_ms(sc->sc_udev, 1);
d3053 1
a3053 1
	usbd_delay_ms(sc->sc_udev, 200);
d3055 1
a3055 1
	usbd_delay_ms(sc->sc_udev, 200);
d3075 1
a3075 1
	usbd_delay_ms(sc->sc_udev, 200);
a3079 1
		usbd_delay_ms(sc->sc_udev, 1);
a3080 1
		usbd_delay_ms(sc->sc_udev, 1);
a3081 1
	usbd_delay_ms(sc->sc_udev, 1);
a3085 1
		usbd_delay_ms(sc->sc_udev, 1);
a3094 1
		usbd_delay_ms(sc->sc_udev, 1);
a3103 1
	usbd_delay_ms(sc->sc_udev, 1);
a3104 1
	usbd_delay_ms(sc->sc_udev, 1);
@


1.3
log
@sizeofa -> nitems

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.2 2008/12/03 10:44:17 jsg Exp $	*/
d64 2
a65 2
#define	DPRINTF(x)	do { if (rum_debug) printf x; } while (0)
#define	DPRINTFN(n, x)	do { if (rum_debug >= (n)) printf x; } while (0)
@


1.2
log
@Weongyo Jeong has consented to switch from an inappropriate license
to license.template
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urtw.c,v 1.1 2008/11/27 14:08:07 kevlo Exp $	*/
a1823 1
#define N(a)	(sizeof(a) / sizeof((a)[0]))
d1826 1
a1826 1
	for (i = 0; i < N(urtw_ratetable); i++) {
a1831 1
#undef N
a1836 1
#define N(a)	(sizeof(a) / sizeof((a)[0]))
d1839 1
a1839 1
	for (i = 0; i < N(urtw_ratetable); i++) {
a1844 1
#undef N
a2634 1
#define N(a)	(sizeof(a) / sizeof((a)[0]))
d2665 1
a2665 1
	for (i = 0; i < N(urtw_8225_rf_part1); i++) {
d2692 1
a2692 1
	for (i = 0; i < N(urtw_8225_rf_part2); i++) {
d2702 1
a2702 1
	for (i = 0; i < N(urtw_8225_rf_part3); i++) {
a2727 1
#undef N
a3007 1
#define N(a)	(sizeof(a) / sizeof((a)[0]))
d3040 1
a3040 1
	for (i = 0; i < N(urtw_8225v2_rf_part1); i++) {
d3096 1
a3096 1
	for (i = 0; i < N(urtw_8225v2_rf_part2); i++) {
d3106 1
a3106 1
	for (i = 0; i < N(urtw_8225v2_rf_part3); i++) {
a3131 1
#undef N
@


1.1
log
@initial import of Weongyo Jeon's FreeBSD driver for the RealTek RTL8187L
802.11 devices.

currently it has issues scanning.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 2
 * Copyright (c) 2008 Weongyo Jeong
 * All rights reserved.
d5 3
a7 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer,
 *    without modification.
 * 2. Redistributions in binary form must reproduce at minimum a disclaimer
 *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any
 *    redistribution must be conditioned upon including a substantially
 *    similar Disclaimer requirement for further binary redistribution.
d9 7
a15 12
 * NO WARRANTY
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGES.
@

