head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.8
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.27
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	6s3MfY9d6ZKdL2Uz;

1.26
date	2017.04.06.04.48.54;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	NjLNzmb74PcRT1Se;

1.25
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.24;
commitid	blfE5YU3eGM81J65;

1.24
date	2015.04.14.07.57.33;	author mpi;	state Exp;
branches;
next	1.23;
commitid	vEOg3FgnAeDBLomV;

1.23
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.21;
commitid	PSjXNz8dGohZ6ZSK;

1.21
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.20;
commitid	OBNa5kfxQ2UXoiIw;

1.20
date	2014.05.16.14.05.39;	author sasano;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.07.10.33.27;	author pirofti;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.17.22.38.54;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.10;

1.10
date	2010.02.20.11.44.56;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.8;

1.8
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.20.21.06.58;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.11.11.23.50;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.09.09.06.22.05;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2007.09.08.04.05.36;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2007.09.08.02.15.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.27
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: uchcom.c,v 1.26 2017/04/06 04:48:54 deraadt Exp $	*/
/*	$NetBSD: uchcom.c,v 1.1 2007/09/03 17:57:37 tshiozak Exp $	*/

/*
 * Copyright (c) 2007 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Takuya SHIOZAKI (tshiozak@@netbsd.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * driver for WinChipHead CH341/340, the worst USB-serial chip in the world.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/device.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/ucomvar.h>

#ifdef UCHCOM_DEBUG
#define DPRINTFN(n, x)  do { if (uchcomdebug > (n)) printf x; } while (0)
int	uchcomdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define	UCHCOM_IFACE_INDEX	0

#define UCHCOM_REV_CH340	0x0250
#define UCHCOM_INPUT_BUF_SIZE	8

#define UCHCOM_REQ_GET_VERSION	0x5F
#define UCHCOM_REQ_READ_REG	0x95
#define UCHCOM_REQ_WRITE_REG	0x9A
#define UCHCOM_REQ_RESET	0xA1
#define UCHCOM_REQ_SET_DTRRTS	0xA4

#define UCHCOM_REG_STAT1	0x06
#define UCHCOM_REG_STAT2	0x07
#define UCHCOM_REG_BPS_PRE	0x12
#define UCHCOM_REG_BPS_DIV	0x13
#define UCHCOM_REG_BPS_MOD	0x14
#define UCHCOM_REG_BPS_PAD	0x0F
#define UCHCOM_REG_BREAK1	0x05
#define UCHCOM_REG_BREAK2	0x18
#define UCHCOM_REG_LCR1		0x18
#define UCHCOM_REG_LCR2		0x25

#define UCHCOM_VER_20		0x20

#define UCHCOM_BASE_UNKNOWN	0
#define UCHCOM_BPS_MOD_BASE	20000000
#define UCHCOM_BPS_MOD_BASE_OFS	1100

#define UCHCOM_DTR_MASK		0x20
#define UCHCOM_RTS_MASK		0x40

#define UCHCOM_BRK1_MASK	0x01
#define UCHCOM_BRK2_MASK	0x40

#define UCHCOM_INTR_STAT1	0x02
#define UCHCOM_INTR_STAT2	0x03
#define UCHCOM_INTR_LEAST	4

/*
 * XXX - these magic numbers come from Linux (drivers/usb/serial/ch341.c).
 * The manufacturer was unresponsive when asked for documentation.
 */
#define UCHCOM_RESET_VALUE	0x501F	/* line mode? */
#define UCHCOM_RESET_INDEX	0xD90A	/* baud rate? */

#define UCHCOMIBUFSIZE 256
#define UCHCOMOBUFSIZE 256

struct uchcom_softc
{
	struct device		 sc_dev;
	struct usbd_device	*sc_udev;
	struct device		*sc_subdev;
	struct usbd_interface	*sc_iface;
	/* */
	int			 sc_intr_endpoint;
	struct usbd_pipe	*sc_intr_pipe;
	u_char			*sc_intr_buf;
	int			 sc_isize;
	/* */
	uint8_t			 sc_version;
	int			 sc_dtr;
	int			 sc_rts;
	u_char			 sc_lsr;
	u_char			 sc_msr;
	int			 sc_lcr1;
	int			 sc_lcr2;
};

struct uchcom_endpoints
{
	int		ep_bulkin;
	int		ep_bulkout;
	int		ep_intr;
	int		ep_intr_size;
};

struct uchcom_divider
{
	uint8_t		dv_prescaler;
	uint8_t		dv_div;
	uint8_t		dv_mod;
};

struct uchcom_divider_record
{
	uint32_t		dvr_high;
	uint32_t		dvr_low;
	uint32_t		dvr_base_clock;
	struct uchcom_divider	dvr_divider;
};

static const struct uchcom_divider_record dividers[] =
{
	{  307200, 307200, UCHCOM_BASE_UNKNOWN, { 7, 0xD9, 0 } },
	{  921600, 921600, UCHCOM_BASE_UNKNOWN, { 7, 0xF3, 0 } },
	{ 2999999,  23530,             6000000, { 3,    0, 0 } },
	{   23529,   2942,              750000, { 2,    0, 0 } },
	{    2941,    368,               93750, { 1,    0, 0 } },
	{     367,      1,               11719, { 0,    0, 0 } },
};

void		uchcom_get_status(void *, int, u_char *, u_char *);
void		uchcom_set(void *, int, int, int);
int		uchcom_param(void *, int, struct termios *);
int		uchcom_open(void *, int);
void		uchcom_close(void *, int);
void		uchcom_intr(struct usbd_xfer *, void *, usbd_status);

int		uchcom_find_ifaces(struct uchcom_softc *,
		    struct usbd_interface **);
int		uchcom_find_endpoints(struct uchcom_softc *,
		    struct uchcom_endpoints *);
void		uchcom_close_intr_pipe(struct uchcom_softc *);


usbd_status 	uchcom_generic_control_out(struct uchcom_softc *sc,
		    uint8_t reqno, uint16_t value, uint16_t index);
usbd_status	uchcom_generic_control_in(struct uchcom_softc *, uint8_t, 
		    uint16_t, uint16_t, void *, int, int *);
usbd_status	uchcom_write_reg(struct uchcom_softc *, uint8_t, uint8_t,
		    uint8_t, uint8_t);
usbd_status	uchcom_read_reg(struct uchcom_softc *, uint8_t, uint8_t *,
		    uint8_t, uint8_t *);
usbd_status	uchcom_get_version(struct uchcom_softc *, uint8_t *); 
usbd_status	uchcom_read_status(struct uchcom_softc *, uint8_t *);
usbd_status	uchcom_set_dtrrts_10(struct uchcom_softc *, uint8_t);
usbd_status	uchcom_set_dtrrts_20(struct uchcom_softc *, uint8_t);
int		uchcom_update_version(struct uchcom_softc *);
void		uchcom_convert_status(struct uchcom_softc *, uint8_t);
int		uchcom_update_status(struct uchcom_softc *);
int		uchcom_set_dtrrts(struct uchcom_softc *, int, int);
int		uchcom_set_break(struct uchcom_softc *, int);
int		uchcom_calc_divider_settings(struct uchcom_divider *, uint32_t);
int		uchcom_set_dte_rate(struct uchcom_softc *, uint32_t);
int		uchcom_set_line_control(struct uchcom_softc *, tcflag_t);
int		uchcom_clear_chip(struct uchcom_softc *);
int		uchcom_reset_chip(struct uchcom_softc *);
int		uchcom_setup_comm(struct uchcom_softc *);
int		uchcom_setup_intr_pipe(struct uchcom_softc *);


int		uchcom_match(struct device *, void *, void *);
void		uchcom_attach(struct device *, struct device *, void *);
int		uchcom_detach(struct device *, int);

struct	ucom_methods uchcom_methods = {
	uchcom_get_status,
	uchcom_set,
	uchcom_param,
	NULL,
	uchcom_open,
	uchcom_close,
	NULL,
	NULL,
};

static const struct usb_devno uchcom_devs[] = {
	{ USB_VENDOR_WCH, USB_PRODUCT_WCH_CH341 },
	{ USB_VENDOR_WCH2, USB_PRODUCT_WCH2_CH340 },
	{ USB_VENDOR_WCH2, USB_PRODUCT_WCH2_CH341A }
};

struct cfdriver uchcom_cd = {
	NULL, "uchcom", DV_DULL
};

const struct cfattach uchcom_ca = {
	sizeof(struct uchcom_softc), uchcom_match, uchcom_attach, uchcom_detach
};

/* ----------------------------------------------------------------------
 * driver entry points
 */

int
uchcom_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return UMATCH_NONE;

	return (usb_lookup(uchcom_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uchcom_attach(struct device *parent, struct device *self, void *aux)
{
	struct uchcom_softc *sc = (struct uchcom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ucom_attach_args uca;
	struct usbd_device *dev = uaa->device;
	struct uchcom_endpoints endpoints;

        sc->sc_udev = dev;
	sc->sc_dtr = sc->sc_rts = -1;

	DPRINTF(("\n\nuchcom attach: sc=%p\n", sc));

	switch (uaa->release) {
	case UCHCOM_REV_CH340:
		printf("%s: CH340\n", sc->sc_dev.dv_xname);
		break;
	default:
		printf("%s: CH341\n", sc->sc_dev.dv_xname);
		break;
	}

	if (uchcom_find_ifaces(sc, &sc->sc_iface))
		goto failed;

	if (uchcom_find_endpoints(sc, &endpoints))
		goto failed;

	sc->sc_intr_endpoint = endpoints.ep_intr;
	sc->sc_isize = endpoints.ep_intr_size;

	/* setup ucom layer */
	uca.portno = UCOM_UNK_PORTNO;
	uca.bulkin = endpoints.ep_bulkin;
	uca.bulkout = endpoints.ep_bulkout;
	uca.ibufsize = UCHCOMIBUFSIZE;
	uca.obufsize = UCHCOMOBUFSIZE;
	uca.ibufsizepad = UCHCOMIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = sc->sc_iface;
	uca.methods = &uchcom_methods;
	uca.arg = sc;
	uca.info = NULL;
	
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);

	return;

failed:
	usbd_deactivate(sc->sc_udev);
}

int
uchcom_detach(struct device *self, int flags)
{
	struct uchcom_softc *sc = (struct uchcom_softc *)self;
	int rv = 0;

	DPRINTF(("uchcom_detach: sc=%p flags=%d\n", sc, flags));

	uchcom_close_intr_pipe(sc);

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return rv;
}

int
uchcom_find_ifaces(struct uchcom_softc *sc, struct usbd_interface **riface)
{
	usbd_status err;

	err = usbd_device2interface_handle(sc->sc_udev, UCHCOM_IFACE_INDEX,
					   riface);
	if (err) {
		printf("\n%s: failed to get interface: %s\n",
			sc->sc_dev.dv_xname, usbd_errstr(err));
		return -1;
	}

	return 0;
}

int
uchcom_find_endpoints(struct uchcom_softc *sc,
    struct uchcom_endpoints *endpoints)
{
	int i, bin=-1, bout=-1, intr=-1, isize=0;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;

	id = usbd_get_interface_descriptor(sc->sc_iface);

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			return -1;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			intr = ed->bEndpointAddress;
			isize = UGETW(ed->wMaxPacketSize);
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			bin = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			bout = ed->bEndpointAddress;
		}
	}

	if (intr == -1 || bin == -1 || bout == -1) {
		if (intr == -1) {
			printf("%s: no interrupt end point\n",
			       sc->sc_dev.dv_xname);
		}
		if (bin == -1) {
			printf("%s: no data bulk in end point\n",
			       sc->sc_dev.dv_xname);
		}
		if (bout == -1) {
			printf("%s: no data bulk out end point\n",
			       sc->sc_dev.dv_xname);
		}
		return -1;
	}
	if (isize < UCHCOM_INTR_LEAST) {
		printf("%s: intr pipe is too short", sc->sc_dev.dv_xname);
		return -1;
	}

	DPRINTF(("%s: bulkin=%d, bulkout=%d, intr=%d, isize=%d\n",
		 sc->sc_dev.dv_xname, bin, bout, intr, isize));

	endpoints->ep_intr = intr;
	endpoints->ep_intr_size = isize;
	endpoints->ep_bulkin = bin;
	endpoints->ep_bulkout = bout;

	return 0;
}


/* ----------------------------------------------------------------------
 * low level i/o
 */

usbd_status
uchcom_generic_control_out(struct uchcom_softc *sc, uint8_t reqno,
    uint16_t value, uint16_t index)
{
	usb_device_request_t req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = reqno;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, 0);

	return usbd_do_request(sc->sc_udev, &req, 0);
}

usbd_status
uchcom_generic_control_in(struct uchcom_softc *sc, uint8_t reqno,
    uint16_t value, uint16_t index, void *buf, int buflen, int *actlen)
{
	usb_device_request_t req;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = reqno;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, (uint16_t)buflen);

	return usbd_do_request_flags(sc->sc_udev, &req, buf,
				     USBD_SHORT_XFER_OK, actlen,
				     USBD_DEFAULT_TIMEOUT);
}

usbd_status
uchcom_write_reg(struct uchcom_softc *sc,
    uint8_t reg1, uint8_t val1, uint8_t reg2, uint8_t val2)
{
	DPRINTF(("uchcom: write reg 0x%02X<-0x%02X, 0x%02X<-0x%02X\n",
		 (unsigned)reg1, (unsigned)val1,
		 (unsigned)reg2, (unsigned)val2));
	return uchcom_generic_control_out(
		sc, UCHCOM_REQ_WRITE_REG,
		reg1|((uint16_t)reg2<<8), val1|((uint16_t)val2<<8));
}

usbd_status
uchcom_read_reg(struct uchcom_softc *sc,
    uint8_t reg1, uint8_t *rval1, uint8_t reg2, uint8_t *rval2)
{
	uint8_t buf[UCHCOM_INPUT_BUF_SIZE];
	usbd_status err;
	int actin;

	err = uchcom_generic_control_in(
		sc, UCHCOM_REQ_READ_REG,
		reg1|((uint16_t)reg2<<8), 0, buf, sizeof buf, &actin);
	if (err)
		return err;

	DPRINTF(("uchcom: read reg 0x%02X->0x%02X, 0x%02X->0x%02X\n",
		 (unsigned)reg1, (unsigned)buf[0],
		 (unsigned)reg2, (unsigned)buf[1]));

	if (rval1) *rval1 = buf[0];
	if (rval2) *rval2 = buf[1];

	return USBD_NORMAL_COMPLETION;
}

usbd_status
uchcom_get_version(struct uchcom_softc *sc, uint8_t *rver)
{
	uint8_t buf[UCHCOM_INPUT_BUF_SIZE];
	usbd_status err;
	int actin;

	err = uchcom_generic_control_in(
		sc, UCHCOM_REQ_GET_VERSION, 0, 0, buf, sizeof buf, &actin);
	if (err)
		return err;

	if (rver) *rver = buf[0];

	return USBD_NORMAL_COMPLETION;
}

usbd_status
uchcom_read_status(struct uchcom_softc *sc, uint8_t *rval)
{
	return uchcom_read_reg(sc, UCHCOM_REG_STAT1, rval, UCHCOM_REG_STAT2,
	    NULL);
}

usbd_status
uchcom_set_dtrrts_10(struct uchcom_softc *sc, uint8_t val)
{
	return uchcom_write_reg(sc, UCHCOM_REG_STAT1, val, UCHCOM_REG_STAT1,
	    val);
}

usbd_status
uchcom_set_dtrrts_20(struct uchcom_softc *sc, uint8_t val)
{
	return uchcom_generic_control_out(sc, UCHCOM_REQ_SET_DTRRTS, val, 0);
}


/* ----------------------------------------------------------------------
 * middle layer
 */

int
uchcom_update_version(struct uchcom_softc *sc)
{
	usbd_status err;

	err = uchcom_get_version(sc, &sc->sc_version);
	if (err) {
		printf("%s: cannot get version: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}

	return 0;
}

void
uchcom_convert_status(struct uchcom_softc *sc, uint8_t cur)
{
	sc->sc_dtr = !(cur & UCHCOM_DTR_MASK);
	sc->sc_rts = !(cur & UCHCOM_RTS_MASK);

	cur = ~cur & 0x0F;
	sc->sc_msr = (cur << 4) | ((sc->sc_msr >> 4) ^ cur);
}

int
uchcom_update_status(struct uchcom_softc *sc)
{
	usbd_status err;
	uint8_t cur;

	err = uchcom_read_status(sc, &cur);
	if (err) {
		printf("%s: cannot update status: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}
	uchcom_convert_status(sc, cur);

	return 0;
}


int
uchcom_set_dtrrts(struct uchcom_softc *sc, int dtr, int rts)
{
	usbd_status err;
	uint8_t val = 0;

	if (dtr) val |= UCHCOM_DTR_MASK;
	if (rts) val |= UCHCOM_RTS_MASK;

	if (sc->sc_version < UCHCOM_VER_20)
		err = uchcom_set_dtrrts_10(sc, ~val);
	else
		err = uchcom_set_dtrrts_20(sc, ~val);

	if (err) {
		printf("%s: cannot set DTR/RTS: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}

	return 0;
}

int
uchcom_set_break(struct uchcom_softc *sc, int onoff)
{
	usbd_status err;
	uint8_t brk1, brk2;

	err = uchcom_read_reg(sc, UCHCOM_REG_BREAK1, &brk1, UCHCOM_REG_BREAK2,
	    &brk2);
	if (err)
		return EIO;
	if (onoff) {
		/* on - clear bits */
		brk1 &= ~UCHCOM_BRK1_MASK;
		brk2 &= ~UCHCOM_BRK2_MASK;
	} else {
		/* off - set bits */
		brk1 |= UCHCOM_BRK1_MASK;
		brk2 |= UCHCOM_BRK2_MASK;
	}
	err = uchcom_write_reg(sc, UCHCOM_REG_BREAK1, brk1, UCHCOM_REG_BREAK2,
	    brk2);
	if (err)
		return EIO;

	return 0;
}

int
uchcom_calc_divider_settings(struct uchcom_divider *dp, uint32_t rate)
{
	int i;
	const struct uchcom_divider_record *rp;
	uint32_t div, rem, mod;

	/* find record */
	for (i=0; i<nitems(dividers); i++) {
		if (dividers[i].dvr_high >= rate &&
		    dividers[i].dvr_low <= rate) {
			rp = &dividers[i];
			goto found;
		}
	}
	return -1;

found:
	dp->dv_prescaler = rp->dvr_divider.dv_prescaler;
	if (rp->dvr_base_clock == UCHCOM_BASE_UNKNOWN)
		dp->dv_div = rp->dvr_divider.dv_div;
	else {
		div = rp->dvr_base_clock / rate;
		rem = rp->dvr_base_clock % rate;
		if (div==0 || div>=0xFF)
			return -1;
		if ((rem<<1) >= rate)
			div += 1;
		dp->dv_div = (uint8_t)-div;
	}

	mod = UCHCOM_BPS_MOD_BASE/rate + UCHCOM_BPS_MOD_BASE_OFS;
	mod = mod + mod/2;

	dp->dv_mod = mod / 0x100;

	return 0;
}

int
uchcom_set_dte_rate(struct uchcom_softc *sc, uint32_t rate)
{
	usbd_status err;
	struct uchcom_divider dv;

	if (uchcom_calc_divider_settings(&dv, rate))
		return EINVAL;

	if ((err = uchcom_write_reg(sc,
			     UCHCOM_REG_BPS_PRE, dv.dv_prescaler,
			     UCHCOM_REG_BPS_DIV, dv.dv_div)) ||
	    (err = uchcom_write_reg(sc,
			     UCHCOM_REG_BPS_MOD, dv.dv_mod,
			     UCHCOM_REG_BPS_PAD, 0))) {
		printf("%s: cannot set DTE rate: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}

	return 0;
}

int
uchcom_set_line_control(struct uchcom_softc *sc, tcflag_t cflag)
{
	/*
	 * XXX: it is difficult to handle the line control appropriately:
	 *   work as chip default - CS8, no parity, !CSTOPB
	 *   other modes are not supported.
	 */

	switch (ISSET(cflag, CSIZE)) {
	case CS5:
	case CS6:
	case CS7:
		return EINVAL;
	case CS8:
		break;
	}

	if (ISSET(cflag, PARENB) || ISSET(cflag, CSTOPB))
		return EINVAL;

	return 0;
}

int
uchcom_clear_chip(struct uchcom_softc *sc)
{
	usbd_status err;

	DPRINTF(("%s: clear\n", sc->sc_dev.dv_xname));
	err = uchcom_generic_control_out(sc, UCHCOM_REQ_RESET, 0, 0);
	if (err) {
		printf("%s: cannot clear: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}

	return 0;
}

int
uchcom_reset_chip(struct uchcom_softc *sc)
{
	usbd_status err;

	DPRINTF(("%s: reset\n", sc->sc_dev.dv_xname));

	err = uchcom_generic_control_out(sc, UCHCOM_REQ_RESET,
					 UCHCOM_RESET_VALUE,
					 UCHCOM_RESET_INDEX);
	if (err)
		goto failed;

	return 0;

failed:
	printf("%s: cannot reset: %s\n",
	       sc->sc_dev.dv_xname, usbd_errstr(err));
	return EIO;
}

int
uchcom_setup_comm(struct uchcom_softc *sc)
{
	int ret;

	ret = uchcom_update_version(sc);
	if (ret)
		return ret;

	ret = uchcom_clear_chip(sc);
	if (ret)
		return ret;

	ret = uchcom_set_dte_rate(sc, TTYDEF_SPEED);
	if (ret)
		return ret;

	ret = uchcom_set_line_control(sc, CS8);
	if (ret)
		return ret;

	ret = uchcom_update_status(sc);
	if (ret)
		return ret;

	ret = uchcom_reset_chip(sc);
	if (ret)
		return ret;

	ret = uchcom_set_dte_rate(sc, TTYDEF_SPEED); /* XXX */
	if (ret)
		return ret;

	sc->sc_dtr = sc->sc_rts = 1;
	ret = uchcom_set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
	if (ret)
		return ret;

	return 0;
}

int
uchcom_setup_intr_pipe(struct uchcom_softc *sc)
{
	usbd_status err;

	if (sc->sc_intr_endpoint != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_iface,
					  sc->sc_intr_endpoint,
					  USBD_SHORT_XFER_OK,
					  &sc->sc_intr_pipe, sc,
					  sc->sc_intr_buf,
					  sc->sc_isize,
					  uchcom_intr, USBD_DEFAULT_INTERVAL);
		if (err) {
			printf("%s: cannot open interrupt pipe: %s\n",
			       sc->sc_dev.dv_xname,
			       usbd_errstr(err));
			return EIO;
		}
	}
	return 0;
}

void
uchcom_close_intr_pipe(struct uchcom_softc *sc)
{
	usbd_status err;

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}
}


/* ----------------------------------------------------------------------
 * methods for ucom
 */
void
uchcom_get_status(void *arg, int portno, u_char *rlsr, u_char *rmsr)
{
	struct uchcom_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return;

	*rlsr = sc->sc_lsr;
	*rmsr = sc->sc_msr;
}

void
uchcom_set(void *arg, int portno, int reg, int onoff)
{
	struct uchcom_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return;

	switch (reg) {
	case UCOM_SET_DTR:
		sc->sc_dtr = !!onoff;
		uchcom_set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
		break;
	case UCOM_SET_RTS:
		sc->sc_rts = !!onoff;
		uchcom_set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
		break;
	case UCOM_SET_BREAK:
		uchcom_set_break(sc, onoff);
		break;
	}
}

int
uchcom_param(void *arg, int portno, struct termios *t)
{
	struct uchcom_softc *sc = arg;
	int ret;

	if (usbd_is_dying(sc->sc_udev))
		return 0;

	ret = uchcom_set_line_control(sc, t->c_cflag);
	if (ret)
		return ret;

	ret = uchcom_set_dte_rate(sc, t->c_ospeed);
	if (ret)
		return ret;

	return 0;
}

int
uchcom_open(void *arg, int portno)
{
	int ret;
	struct uchcom_softc *sc = arg;

	if (usbd_is_dying(sc->sc_udev))
		return EIO;

	ret = uchcom_setup_intr_pipe(sc);
	if (ret)
		return ret;

	ret = uchcom_setup_comm(sc);
	if (ret)
		return ret;

	return 0;
}

void
uchcom_close(void *arg, int portno)
{
	struct uchcom_softc *sc = arg;

	uchcom_close_intr_pipe(sc);
}


/* ----------------------------------------------------------------------
 * callback when the modem status is changed.
 */
void
uchcom_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct uchcom_softc *sc = priv;
	u_char *buf = sc->sc_intr_buf;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: abnormal status: %s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}
	DPRINTF(("%s: intr: 0x%02X 0x%02X 0x%02X 0x%02X "
		 "0x%02X 0x%02X 0x%02X 0x%02X\n",
		 sc->sc_dev.dv_xname,
		 (unsigned)buf[0], (unsigned)buf[1],
		 (unsigned)buf[2], (unsigned)buf[3],
		 (unsigned)buf[4], (unsigned)buf[5],
		 (unsigned)buf[6], (unsigned)buf[7]));

	uchcom_convert_status(sc, buf[UCHCOM_INTR_STAT1]);
	ucom_status_change((struct ucom_softc *) sc->sc_subdev);
}
@


1.26
log
@Unify a few attach-time patterns between usb *com drivers, and remove
extra zero'ing of variables not needed because softc is pre-zero'd.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.25 2016/09/02 09:14:59 mpi Exp $	*/
a113 1
	int			 sc_intr_size;
d116 1
d275 1
a275 1
	sc->sc_intr_size = endpoints.ep_intr_size;
d773 1
a773 1
		sc->sc_intr_buf = malloc(sc->sc_intr_size, M_USBDEV, M_WAITOK);
d779 1
a779 1
					  sc->sc_intr_size,
d802 1
a802 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
@


1.25
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.24 2015/04/14 07:57:33 mpi Exp $	*/
a255 1
	sc->sc_lsr = sc->sc_msr = 0;
@


1.24
log
@Make sure we close the interrupt pipe when the device is detached.

Bug reported and fix tested by Thomas Pfaff, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.23 2015/03/14 03:38:49 jsg Exp $	*/
a58 1
#define	UCHCOM_CONFIG_INDEX	0
a166 1
int		uchcom_set_config(struct uchcom_softc *);
d238 1
a238 1
	if (uaa->iface != NULL)
a259 3
	if (uchcom_set_config(sc))
		goto failed;

a315 15
}

int
uchcom_set_config(struct uchcom_softc *sc)
{
	usbd_status err;

	err = usbd_set_config_index(sc->sc_udev, UCHCOM_CONFIG_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return -1;
	}

	return 0;
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.22 2014/07/12 20:26:33 mpi Exp $	*/
a816 3
	if (usbd_is_dying(sc->sc_udev))
		return;

a910 3

	if (usbd_is_dying(sc->sc_udev))
		return;
@


1.22
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.21 2014/07/12 18:48:52 tedu Exp $	*/
a40 1
#include <sys/conf.h>
@


1.21
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.20 2014/05/16 14:05:39 sasano Exp $	*/
d203 3
a205 4
int		uchcom_match(struct device *, void *, void *); 
void		uchcom_attach(struct device *, struct device *, void *); 
int		uchcom_detach(struct device *, int); 
int		uchcom_activate(struct device *, int);
d224 6
a229 10
struct cfdriver uchcom_cd = { 
	NULL, "uchcom", DV_DULL 
}; 

const struct cfattach uchcom_ca = { 
	sizeof(struct uchcom_softc), 
	uchcom_match, 
	uchcom_attach, 
	uchcom_detach, 
	uchcom_activate, 
a321 14
}

int
uchcom_activate(struct device *self, int act)
{
	struct uchcom_softc *sc = (struct uchcom_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		uchcom_close_intr_pipe(sc);
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return 0;
@


1.20
log
@It seems that there is new and old revision of CH340.
Previous uchcom(4) driver targeted old one, and new one could not work
because of uchcom_set_line_control() broke the value of
UCHCOM_REG_LCR1(0x18).

To support new CH340, uchcom_set_line_control() and uchcom_reset_chip()
have been overhauled. Current uchcom(4) does not change the value of
UCHCOM_REG_LCR1 register, it means even/odd parity mode is no longer
supported with old CH340.

ok by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.19 2013/11/15 10:17:39 pirofti Exp $	*/
d846 1
a846 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.19
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.18 2013/11/15 08:25:31 pirofti Exp $	*/
a93 8
#define UCHCOM_LCR1_MASK	0xAF
#define UCHCOM_LCR2_MASK	0x07
#define UCHCOM_LCR1_PARENB	0x80
#define UCHCOM_LCR2_PAREVEN	0x07
#define UCHCOM_LCR2_PARODD	0x06
#define UCHCOM_LCR2_PARMARK	0x05
#define UCHCOM_LCR2_PARSPACE	0x04

d98 7
a708 14
	usbd_status err;
	uint8_t lcr1 = 0, lcr2 = 0;

	err = uchcom_read_reg(sc, UCHCOM_REG_LCR1, &lcr1, UCHCOM_REG_LCR2,
	    &lcr2);
	if (err) {
		printf("%s: cannot get LCR: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}

	lcr1 &= ~UCHCOM_LCR1_MASK;
	lcr2 &= ~UCHCOM_LCR2_MASK;

d711 2
a712 5
	 *   - CS8, !CSTOPB and any parity mode seems ok, but
	 *   - the chip doesn't have the function to calculate parity
	 *     in !CS8 mode.
	 *   - it is unclear that the chip supports CS5,6 mode.
	 *   - it is unclear how to handle stop bits.
d724 2
a725 15
	if (ISSET(cflag, PARENB)) {
		lcr1 |= UCHCOM_LCR1_PARENB;
		if (ISSET(cflag, PARODD))
			lcr2 |= UCHCOM_LCR2_PARODD;
		else
			lcr2 |= UCHCOM_LCR2_PAREVEN;
	}

	err = uchcom_write_reg(sc, UCHCOM_REG_LCR1, lcr1, UCHCOM_REG_LCR2,
	    lcr2);
	if (err) {
		printf("%s: cannot set LCR: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return EIO;
	}
a749 27
	uint8_t lcr1, lcr2, pre, div, mod;
	uint16_t val=0, idx=0;

	err = uchcom_read_reg(sc, UCHCOM_REG_LCR1, &lcr1, UCHCOM_REG_LCR2, &lcr2);
	if (err)
		goto failed;

	err = uchcom_read_reg(sc, UCHCOM_REG_BPS_PRE, &pre, UCHCOM_REG_BPS_DIV,
	    &div);
	if (err)
		goto failed;

	err = uchcom_read_reg(sc, UCHCOM_REG_BPS_MOD, &mod, UCHCOM_REG_BPS_PAD,
	    NULL);
	if (err)
		goto failed;

	val |= (uint16_t)(lcr1&0xF0) << 8;
	val |= 0x01;
	val |= (uint16_t)(lcr2&0x0F) << 8;
	val |= 0x02;
	idx |= pre & 0x07;
	val |= 0x04;
	idx |= (uint16_t)div << 8;
	val |= 0x08;
	idx |= mod & 0xF8;
	val |= 0x10;
d751 1
a751 2
	DPRINTF(("%s: reset v=0x%04X, i=0x%04X\n",
		 sc->sc_dev.dv_xname, val, idx));
d753 3
a755 1
	err = uchcom_generic_control_out(sc, UCHCOM_REQ_RESET, val, idx);
@


1.18
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.17 2013/11/07 10:33:27 pirofti Exp $	*/
d898 1
a898 4
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.17
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.16 2013/04/15 09:23:02 mglocker Exp $	*/
a333 1
	int rv = 0;
a338 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d341 1
a341 1
	return rv;
@


1.16
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.15 2011/07/03 15:47:17 matthew Exp $	*/
a114 1
	int			 sc_dying;
a263 1
	sc->sc_dying = 0;
d309 1
a309 1
	sc->sc_dying = 1;
d339 1
a339 1
		sc->sc_dying = 1;
d897 1
a897 1
	if (sc->sc_dying)
d923 1
a923 1
	if (sc->sc_dying)
d935 1
a935 1
	if (sc->sc_dying)
d959 1
a959 1
	if (sc->sc_dying)
d979 1
a979 1
	if (sc->sc_dying)
d998 1
a998 1
	if (sc->sc_dying)
d1014 1
a1014 1
	if (sc->sc_dying)
@


1.15
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.14 2011/01/25 20:03:36 jakemsr Exp $	*/
d112 1
a112 1
	usbd_device_handle	 sc_udev;
d114 1
a114 1
	usbd_interface_handle	 sc_iface;
d119 1
a119 1
	usbd_pipe_handle	 sc_intr_pipe;
d169 1
a169 2
void		uchcom_intr(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d173 1
a173 1
		    usbd_interface_handle *);
d261 1
a261 1
	usbd_device_handle dev = uaa->device;
d365 1
a365 1
uchcom_find_ifaces(struct uchcom_softc *sc, usbd_interface_handle *riface)
d1011 1
a1011 2
uchcom_intr(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
@


1.14
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.13 2010/12/17 22:38:54 jasper Exp $	*/
a339 2
	case DVACT_ACTIVATE:
		break;
@


1.13
log
@- use nitems()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.12 2010/12/17 21:53:34 jasper Exp $	*/
a305 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
a328 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.12
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.11 2010/09/24 08:33:59 yuo Exp $	*/
a162 1
#define NUM_DIVIDERS	(sizeof (dividers) / sizeof (dividers[0]))
d667 1
a667 1
	for (i=0; i<NUM_DIVIDERS; i++) {
@


1.11
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.10 2010/02/20 11:44:56 jsg Exp $	*/
a227 1
#define uchcom_lookup(v, p)	usb_lookup(uchcom_devs, v, p)
d253 2
a254 2
	return (uchcom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.10
log
@Match on new CH341A in uchcom and correctly name the CH340 device,
from looking at the windows driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.9 2009/10/13 19:33:17 pirofti Exp $	*/
a328 2

	sc->sc_dying = 1;
@


1.9
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.8 2009/08/02 10:38:34 miod Exp $	*/
d225 2
a226 1
	{ USB_VENDOR_WCH2, USB_PRODUCT_WCH2_CH341 },
@


1.8
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.7 2008/06/26 05:42:18 ray Exp $	*/
d210 1
a210 1
int		uchcom_activate(struct device *, enum devact);
d343 1
a343 1
uchcom_activate(struct device *self, enum devact act)
@


1.7
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.6 2008/06/20 21:06:58 jsg Exp $	*/
a349 1
		rv = EOPNOTSUPP;
@


1.6
log
@Another uchcom product found in the Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.5 2008/04/11 11:23:50 jsg Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@ditch c99 style struct initialisers that should have been removed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.4 2007/10/11 18:33:14 deraadt Exp $	*/
d232 1
@


1.4
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.3 2007/09/09 06:22:05 jsg Exp $	*/
d220 8
a227 8
	.ucom_get_status	= uchcom_get_status,
	.ucom_set		= uchcom_set,
	.ucom_param		= uchcom_param,
	.ucom_ioctl		= NULL,
	.ucom_open		= uchcom_open,
	.ucom_close		= uchcom_close,
	.ucom_read		= NULL,
	.ucom_write		= NULL,
@


1.3
log
@Properly prefix all functions with driver name.
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.2 2007/09/08 04:05:36 jsg Exp $	*/
a269 1
	char *devinfop;
a271 4
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);

d284 1
a284 1
		printf(": CH340\n");
d287 1
a287 1
		printf(": CH341\n");
@


1.2
log
@Wrap DPRINTFN() macro up in do { } while(0).
@
text
@d1 1
a1 1
/*	$OpenBSD: uchcom.c,v 1.1 2007/09/08 02:15:52 jsg Exp $	*/
d180 4
a183 3
int		set_config(struct uchcom_softc *);
int		find_ifaces(struct uchcom_softc *, usbd_interface_handle *);
int		find_endpoints(struct uchcom_softc *,
d185 1
a185 1
void		close_intr_pipe(struct uchcom_softc *);
d188 3
a190 3
usbd_status 	generic_control_out(struct uchcom_softc *sc, uint8_t reqno,
		    uint16_t value, uint16_t index);
usbd_status	generic_control_in(struct uchcom_softc *, uint8_t, 
d192 20
a211 20
usbd_status	write_reg(struct uchcom_softc *, uint8_t, uint8_t, uint8_t,
		    uint8_t); 
usbd_status	read_reg(struct uchcom_softc *, uint8_t, uint8_t *, uint8_t,
		    uint8_t *);
usbd_status	get_version(struct uchcom_softc *, uint8_t *); 
usbd_status	get_status(struct uchcom_softc *, uint8_t *);
usbd_status	set_dtrrts_10(struct uchcom_softc *, uint8_t);
usbd_status	set_dtrrts_20(struct uchcom_softc *, uint8_t);
int		update_version(struct uchcom_softc *);
void		convert_status(struct uchcom_softc *, uint8_t);
int		update_status(struct uchcom_softc *);
int		set_dtrrts(struct uchcom_softc *, int, int);
int		set_break(struct uchcom_softc *, int);
int		calc_divider_settings(struct uchcom_divider *, uint32_t);
int		set_dte_rate(struct uchcom_softc *, uint32_t);
int		set_line_control(struct uchcom_softc *, tcflag_t);
int		clear_chip(struct uchcom_softc *);
int		reset_chip(struct uchcom_softc *);
int		setup_comm(struct uchcom_softc *);
int		setup_intr_pipe(struct uchcom_softc *);
d284 1
a284 1
	if (set_config(sc))
d296 1
a296 1
	if (find_ifaces(sc, &sc->sc_iface))
d299 1
a299 1
	if (find_endpoints(sc, &endpoints))
d338 1
a338 1
	close_intr_pipe(sc);
d364 1
a364 1
		close_intr_pipe(sc);
d374 1
a374 1
set_config(struct uchcom_softc *sc)
d389 1
a389 1
find_ifaces(struct uchcom_softc *sc, usbd_interface_handle *riface)
d405 2
a406 1
find_endpoints(struct uchcom_softc *sc, struct uchcom_endpoints *endpoints)
d472 1
a472 1
generic_control_out(struct uchcom_softc *sc, uint8_t reqno,
d487 1
a487 1
generic_control_in(struct uchcom_softc *sc, uint8_t reqno,
d504 1
a504 1
write_reg(struct uchcom_softc *sc,
d510 1
a510 1
	return generic_control_out(
d516 1
a516 1
read_reg(struct uchcom_softc *sc,
d523 1
a523 1
	err = generic_control_in(
d540 1
a540 1
get_version(struct uchcom_softc *sc, uint8_t *rver)
d546 1
a546 1
	err = generic_control_in(
d557 1
a557 1
get_status(struct uchcom_softc *sc, uint8_t *rval)
d559 2
a560 1
	return read_reg(sc, UCHCOM_REG_STAT1, rval, UCHCOM_REG_STAT2, NULL);
d564 1
a564 1
set_dtrrts_10(struct uchcom_softc *sc, uint8_t val)
d566 2
a567 1
	return write_reg(sc, UCHCOM_REG_STAT1, val, UCHCOM_REG_STAT1, val);
d571 1
a571 1
set_dtrrts_20(struct uchcom_softc *sc, uint8_t val)
d573 1
a573 1
	return generic_control_out(sc, UCHCOM_REQ_SET_DTRRTS, val, 0);
d582 1
a582 1
update_version(struct uchcom_softc *sc)
d586 1
a586 1
	err = get_version(sc, &sc->sc_version);
d597 1
a597 1
convert_status(struct uchcom_softc *sc, uint8_t cur)
d607 1
a607 1
update_status(struct uchcom_softc *sc)
d612 1
a612 1
	err = get_status(sc, &cur);
d618 1
a618 1
	convert_status(sc, cur);
d625 1
a625 1
set_dtrrts(struct uchcom_softc *sc, int dtr, int rts)
d634 1
a634 1
		err = set_dtrrts_10(sc, ~val);
d636 1
a636 1
		err = set_dtrrts_20(sc, ~val);
d648 1
a648 1
set_break(struct uchcom_softc *sc, int onoff)
d653 2
a654 1
	err = read_reg(sc, UCHCOM_REG_BREAK1, &brk1, UCHCOM_REG_BREAK2, &brk2);
d666 2
a667 1
	err = write_reg(sc, UCHCOM_REG_BREAK1, brk1, UCHCOM_REG_BREAK2, brk2);
d675 1
a675 1
calc_divider_settings(struct uchcom_divider *dp, uint32_t rate)
d714 1
a714 1
set_dte_rate(struct uchcom_softc *sc, uint32_t rate)
d719 1
a719 1
	if (calc_divider_settings(&dv, rate))
d722 1
a722 1
	if ((err = write_reg(sc,
d725 1
a725 1
	    (err = write_reg(sc,
d737 1
a737 1
set_line_control(struct uchcom_softc *sc, tcflag_t cflag)
d742 2
a743 1
	err = read_reg(sc, UCHCOM_REG_LCR1, &lcr1, UCHCOM_REG_LCR2, &lcr2);
d779 2
a780 1
	err = write_reg(sc, UCHCOM_REG_LCR1, lcr1, UCHCOM_REG_LCR2, lcr2);
d791 1
a791 1
clear_chip(struct uchcom_softc *sc)
d796 1
a796 1
	err = generic_control_out(sc, UCHCOM_REQ_RESET, 0, 0);
d807 1
a807 1
reset_chip(struct uchcom_softc *sc)
d813 1
a813 1
	err = read_reg(sc, UCHCOM_REG_LCR1, &lcr1, UCHCOM_REG_LCR2, &lcr2);
d817 2
a818 1
	err = read_reg(sc, UCHCOM_REG_BPS_PRE, &pre, UCHCOM_REG_BPS_DIV, &div);
d822 2
a823 1
	err = read_reg(sc, UCHCOM_REG_BPS_MOD, &mod, UCHCOM_REG_BPS_PAD, NULL);
d841 1
a841 1
	err = generic_control_out(sc, UCHCOM_REQ_RESET, val, idx);
d854 1
a854 1
setup_comm(struct uchcom_softc *sc)
d858 1
a858 1
	ret = update_version(sc);
d862 1
a862 1
	ret = clear_chip(sc);
d866 1
a866 1
	ret = set_dte_rate(sc, TTYDEF_SPEED);
d870 1
a870 1
	ret = set_line_control(sc, CS8);
d874 1
a874 1
	ret = update_status(sc);
d878 1
a878 1
	ret = reset_chip(sc);
d882 1
a882 1
	ret = set_dte_rate(sc, TTYDEF_SPEED); /* XXX */
d887 1
a887 1
	ret = set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
d895 1
a895 1
setup_intr_pipe(struct uchcom_softc *sc)
d919 1
a919 1
close_intr_pipe(struct uchcom_softc *sc)
d967 1
a967 1
		set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
d971 1
a971 1
		set_dtrrts(sc, sc->sc_dtr, sc->sc_rts);
d974 1
a974 1
		set_break(sc, onoff);
d988 1
a988 1
	ret = set_line_control(sc, t->c_cflag);
d992 1
a992 1
	ret = set_dte_rate(sc, t->c_ospeed);
d1008 1
a1008 1
	ret = setup_intr_pipe(sc);
d1012 1
a1012 1
	ret = setup_comm(sc);
d1027 1
a1027 1
	close_intr_pipe(sc);
d1061 1
a1061 1
	convert_status(sc, buf[UCHCOM_INTR_STAT1]);
@


1.1
log
@Driver for WinChipHead CH341/340 USB serial adapters.
originally written by Takuya SHIOZAKI <tshiozak@@netbsd.org>

Currently untested due to lack of hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
#define DPRINTFN(n, x)  if (uchcomdebug > (n)) logprintf x
@

