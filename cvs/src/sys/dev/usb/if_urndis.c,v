head	1.67;
access;
symbols
	OPENBSD_6_2:1.67.0.4
	OPENBSD_6_2_BASE:1.67
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.61.0.4
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.46.0.4
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.34.0.2
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.29.0.2
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18;
locks; strict;
comment	@ * @;


1.67
date	2017.07.19.16.31.56;	author mikeb;	state Exp;
branches;
next	1.66;
commitid	bmP7dZ42JvomxSOr;

1.66
date	2017.06.10.12.58.37;	author kevlo;	state Exp;
branches;
next	1.65;
commitid	gDyOjh7RCI0xcMi7;

1.65
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	6s3MfY9d6ZKdL2Uz;

1.64
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	x5RWYO05Q3UFL5Oq;

1.63
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.62;
commitid	VyLWTsbepAOk7VQM;

1.62
date	2016.09.16.11.13.37;	author mikeb;	state Exp;
branches;
next	1.61;
commitid	3p5sLyRWGR6PDmnl;

1.61
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.60;
commitid	gWZDkudwxydTq8x4;

1.60
date	2016.03.16.21.04.40;	author stsp;	state Exp;
branches;
next	1.59;
commitid	fjGIoeY3vkilgQtN;

1.59
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.58;
commitid	B0kwmVGiD5DVx4kv;

1.58
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.57;
commitid	5gdEnqVoJuTuwdTu;

1.57
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.56;
commitid	eYnPulzvLjDImPCa;

1.56
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.55;
commitid	pwYnMC1gOKohmeGw;

1.55
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.54;
commitid	MVWrtktB46JRxFWT;

1.54
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.53;
commitid	p4LJxGKbi0BU2cG6;

1.53
date	2015.03.11.16.07.22;	author mpi;	state Exp;
branches;
next	1.52;
commitid	SkX4dzmGHM47YcIB;

1.52
date	2015.01.09.20.45.40;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	QmYkiKyFWC160Ch0;

1.51
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.50;
commitid	yM2VFFhpDTeFQlve;

1.50
date	2014.11.30.21.45.04;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	KEiarHiw5dB5uYDm;

1.49
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.48;
commitid	Pclvgy2Z4XV9hveD;

1.48
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.47;
commitid	OBNa5kfxQ2UXoiIw;

1.47
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.46;
commitid	b0VSac5dnnsxcDao;

1.46
date	2013.12.09.15.45.29;	author pirofti;	state Exp;
branches;
next	1.45;

1.45
date	2013.12.07.20.17.42;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.21.14.08.05;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.08.10.12.20;	author pirofti;	state Exp;
branches;
next	1.41;

1.41
date	2013.10.29.10.01.20;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2013.10.01.20.06.03;	author sf;	state Exp;
branches;
next	1.39;

1.39
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2013.02.02.15.03.58;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2012.12.05.23.20.21;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2012.06.20.10.51.27;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.24.08.33.08;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.20.13.11.41;	author jasper;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2011.05.05.17.00.43;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.31.11.51.45;	author mk;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.31.10.59.37;	author mk;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.14.20.44.17;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.14.20.21.55;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.06.17.53.31;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.05.08.11.34;	author armani;	state Exp;
branches;
next	1.19;

1.19
date	2010.03.25.19.39.34;	author mk;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.15.11.13.40;	author fabien;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.14.22.50.41;	author mk;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.11.10.23.08;	author armani;	state Exp;
branches;
next	1.15;

1.15
date	2010.03.07.17.17.33;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.07.16.20.32;	author fabien;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.07.16.06.29;	author fabien;	state Exp;
branches;
next	1.12;

1.12
date	2010.03.07.16.03.29;	author mk;	state Exp;
branches;
next	1.11;

1.11
date	2010.03.07.14.43.06;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.06.15.43.31;	author armani;	state Exp;
branches;
next	1.9;

1.9
date	2010.03.05.18.20.50;	author armani;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.04.20.23.45;	author armani;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.03.23.37.01;	author mk;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.03.23.26.56;	author mk;	state Exp;
branches;
next	1.5;

1.5
date	2010.03.03.19.01.03;	author mk;	state Exp;
branches;
next	1.4;

1.4
date	2010.03.03.18.44.30;	author mk;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.02.20.54.27;	author mk;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.02.20.27.25;	author mk;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.01.23.35.56;	author mk;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Add a handler for RNDIS status messages

RNDIS status messages may indicate various conditions reported by
the hardware, including link status events. They're not supposed
to be universally treated as errors.

Issue reported by Artturi Alm, ok armani
@
text
@/*	$OpenBSD: if_urndis.c,v 1.66 2017/06/10 12:58:37 kevlo Exp $ */

/*
 * Copyright (c) 2010 Jonathan Armani <armani@@openbsd.org>
 * Copyright (c) 2010 Fabien Romano <fabien@@openbsd.org>
 * Copyright (c) 2010 Michael Knudsen <mk@@openbsd.org>
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>

#include <dev/rndis.h>

#include <dev/usb/if_urndisreg.h>

#ifdef URNDIS_DEBUG
#define DPRINTF(x)      do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

#define DEVNAME(sc)	((sc)->sc_dev.dv_xname)

int urndis_newbuf(struct urndis_softc *, struct urndis_chain *);

int urndis_ioctl(struct ifnet *, u_long, caddr_t);
#if 0
void urndis_watchdog(struct ifnet *);
#endif

void urndis_start(struct ifnet *);
void urndis_rxeof(struct usbd_xfer *, void *, usbd_status);
void urndis_txeof(struct usbd_xfer *, void *, usbd_status);
int urndis_rx_list_init(struct urndis_softc *);
int urndis_tx_list_init(struct urndis_softc *);

void urndis_init(struct urndis_softc *);
void urndis_stop(struct urndis_softc *);

usbd_status urndis_ctrl_msg(struct urndis_softc *, uint8_t, uint8_t,
    uint16_t, uint16_t, void *, size_t);
usbd_status urndis_ctrl_send(struct urndis_softc *, void *, size_t);
struct rndis_comp_hdr *urndis_ctrl_recv(struct urndis_softc *);

u_int32_t urndis_ctrl_handle(struct urndis_softc *,
    struct rndis_comp_hdr *, void **, size_t *);
u_int32_t urndis_ctrl_handle_init(struct urndis_softc *,
    const struct rndis_comp_hdr *);
u_int32_t urndis_ctrl_handle_query(struct urndis_softc *,
    const struct rndis_comp_hdr *, void **, size_t *);
u_int32_t urndis_ctrl_handle_reset(struct urndis_softc *,
    const struct rndis_comp_hdr *);
u_int32_t urndis_ctrl_handle_status(struct urndis_softc *,
    const struct rndis_comp_hdr *);

u_int32_t urndis_ctrl_init(struct urndis_softc *);
u_int32_t urndis_ctrl_halt(struct urndis_softc *);
u_int32_t urndis_ctrl_query(struct urndis_softc *, u_int32_t, void *, size_t,
    void **, size_t *);
u_int32_t urndis_ctrl_set(struct urndis_softc *, u_int32_t, void *, size_t);
u_int32_t urndis_ctrl_set_param(struct urndis_softc *, const char *, u_int32_t,
    void *, size_t);
#if 0
u_int32_t urndis_ctrl_reset(struct urndis_softc *);
u_int32_t urndis_ctrl_keepalive(struct urndis_softc *);
#endif

int urndis_encap(struct urndis_softc *, struct mbuf *, int);
void urndis_decap(struct urndis_softc *, struct urndis_chain *, u_int32_t);

const struct urndis_class *urndis_lookup(usb_interface_descriptor_t *);

int urndis_match(struct device *, void *, void *);
void urndis_attach(struct device *, struct device *, void *);
int urndis_detach(struct device *, int);

struct cfdriver urndis_cd = {
	NULL, "urndis", DV_IFNET
};

struct cfattach urndis_ca = {
	sizeof(struct urndis_softc), urndis_match, urndis_attach, urndis_detach
};

const struct urndis_class {
	u_int8_t class;
	u_int8_t subclass;
	u_int8_t protocol;
	const char *typestr;
} urndis_class[] = {
	{ UICLASS_CDC, UISUBCLASS_ABSTRACT_CONTROL_MODEL, 0xff, "Vendor" },
	{ UICLASS_WIRELESS, UISUBCLASS_RF, UIPROTO_RNDIS, "RNDIS" },
	{ UICLASS_MISC, UISUBCLASS_SYNC, UIPROTO_ACTIVESYNC, "Activesync" }
};

usbd_status
urndis_ctrl_msg(struct urndis_softc *sc, uint8_t rt, uint8_t r,
    uint16_t index, uint16_t value, void *buf, size_t buflen)
{
	usb_device_request_t req;

	req.bmRequestType = rt;
	req.bRequest = r;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, buflen);

	return usbd_do_request(sc->sc_udev, &req, buf);
}

usbd_status
urndis_ctrl_send(struct urndis_softc *sc, void *buf, size_t len)
{
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return(0);

	err = urndis_ctrl_msg(sc, UT_WRITE_CLASS_INTERFACE, UR_GET_STATUS,
	    sc->sc_ifaceno_ctl, 0, buf, len);

	if (err != USBD_NORMAL_COMPLETION)
		printf("%s: %s\n", DEVNAME(sc), usbd_errstr(err));

	return err;
}

struct rndis_comp_hdr *
urndis_ctrl_recv(struct urndis_softc *sc)
{
#define RNDIS_RESPONSE_LEN 0x400
	struct rndis_comp_hdr	*hdr;
	char			*buf;
	usbd_status		 err;

	buf = malloc(RNDIS_RESPONSE_LEN, M_TEMP, M_WAITOK | M_CANFAIL);
	if (buf == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return NULL;
	}

	err = urndis_ctrl_msg(sc, UT_READ_CLASS_INTERFACE, UR_CLEAR_FEATURE,
	    sc->sc_ifaceno_ctl, 0, buf, RNDIS_RESPONSE_LEN);

	if (err != USBD_NORMAL_COMPLETION && err != USBD_SHORT_XFER) {
		printf("%s: %s\n", DEVNAME(sc), usbd_errstr(err));
		free(buf, M_TEMP, RNDIS_RESPONSE_LEN);
		return NULL;
	}

	hdr = (struct rndis_comp_hdr *)buf;
	DPRINTF(("%s: urndis_ctrl_recv: type 0x%x len %u\n",
	    DEVNAME(sc),
	    letoh32(hdr->rm_type),
	    letoh32(hdr->rm_len)));

	if (letoh32(hdr->rm_len) > RNDIS_RESPONSE_LEN) {
		printf("%s: ctrl message error: wrong size %u > %u\n",
		    DEVNAME(sc),
		    letoh32(hdr->rm_len),
		    RNDIS_RESPONSE_LEN);
		free(buf, M_TEMP, RNDIS_RESPONSE_LEN);
		return NULL;
	}

	return hdr;
}

u_int32_t
urndis_ctrl_handle(struct urndis_softc *sc, struct rndis_comp_hdr *hdr,
    void **buf, size_t *bufsz)
{
	u_int32_t rval;

	DPRINTF(("%s: urndis_ctrl_handle\n", DEVNAME(sc)));

	if (buf && bufsz) {
		*buf = NULL;
		*bufsz = 0;
	}

	switch (letoh32(hdr->rm_type)) {
		case REMOTE_NDIS_INITIALIZE_CMPLT:
			rval = urndis_ctrl_handle_init(sc, hdr);
			break;

		case REMOTE_NDIS_QUERY_CMPLT:
			rval = urndis_ctrl_handle_query(sc, hdr, buf, bufsz);
			break;

		case REMOTE_NDIS_RESET_CMPLT:
			rval = urndis_ctrl_handle_reset(sc, hdr);
			break;

		case REMOTE_NDIS_KEEPALIVE_CMPLT:
		case REMOTE_NDIS_SET_CMPLT:
			rval = letoh32(hdr->rm_status);
			break;

		case REMOTE_NDIS_INDICATE_STATUS_MSG:
			rval = urndis_ctrl_handle_status(sc, hdr);
			break;

		default:
			printf("%s: ctrl message error: unknown event 0x%x\n",
			    DEVNAME(sc), letoh32(hdr->rm_type));
			rval = RNDIS_STATUS_FAILURE;
	}

	free(hdr, M_TEMP, RNDIS_RESPONSE_LEN);

	return rval;
}

u_int32_t
urndis_ctrl_handle_init(struct urndis_softc *sc,
    const struct rndis_comp_hdr *hdr)
{
	const struct rndis_init_comp	*msg;

	msg = (struct rndis_init_comp *) hdr;

	DPRINTF(("%s: urndis_ctrl_handle_init: len %u rid %u status 0x%x "
	    "ver_major %u ver_minor %u devflags 0x%x medium 0x%x pktmaxcnt %u "
	    "pktmaxsz %u align %u aflistoffset %u aflistsz %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid),
	    letoh32(msg->rm_status),
	    letoh32(msg->rm_ver_major),
	    letoh32(msg->rm_ver_minor),
	    letoh32(msg->rm_devflags),
	    letoh32(msg->rm_medium),
	    letoh32(msg->rm_pktmaxcnt),
	    letoh32(msg->rm_pktmaxsz),
	    letoh32(msg->rm_align),
	    letoh32(msg->rm_aflistoffset),
	    letoh32(msg->rm_aflistsz)));

	if (letoh32(msg->rm_status) != RNDIS_STATUS_SUCCESS) {
		printf("%s: init failed 0x%x\n",
		    DEVNAME(sc),
		    letoh32(msg->rm_status));

		return letoh32(msg->rm_status);
	}

	if (letoh32(msg->rm_devflags) != RNDIS_DF_CONNECTIONLESS) {
		printf("%s: wrong device type (current type: 0x%x)\n",
		    DEVNAME(sc),
		    letoh32(msg->rm_devflags));

		return RNDIS_STATUS_FAILURE;
	}

	if (letoh32(msg->rm_medium) != RNDIS_MEDIUM_802_3) {
		printf("%s: medium not 802.3 (current medium: 0x%x)\n",
		    DEVNAME(sc), letoh32(msg->rm_medium));

		return RNDIS_STATUS_FAILURE;
	}

	sc->sc_lim_pktsz = letoh32(msg->rm_pktmaxsz);

	return letoh32(msg->rm_status);
}

u_int32_t
urndis_ctrl_handle_query(struct urndis_softc *sc,
    const struct rndis_comp_hdr *hdr, void **buf, size_t *bufsz)
{
	const struct rndis_query_comp	*msg;

	msg = (struct rndis_query_comp *) hdr;

	DPRINTF(("%s: urndis_ctrl_handle_query: len %u rid %u status 0x%x "
	    "buflen %u bufoff %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid),
	    letoh32(msg->rm_status),
	    letoh32(msg->rm_infobuflen),
	    letoh32(msg->rm_infobufoffset)));

	if (buf && bufsz) {
		*buf = NULL;
		*bufsz = 0;
	}

	if (letoh32(msg->rm_status) != RNDIS_STATUS_SUCCESS) {
		printf("%s: query failed 0x%x\n",
		    DEVNAME(sc),
		    letoh32(msg->rm_status));

		return letoh32(msg->rm_status);
	}

	if (letoh32(msg->rm_infobuflen) + letoh32(msg->rm_infobufoffset) +
	    RNDIS_HEADER_OFFSET > letoh32(msg->rm_len)) {
		printf("%s: ctrl message error: invalid query info "
		    "len/offset/end_position(%u/%u/%zu) -> "
		    "go out of buffer limit %u\n",
		    DEVNAME(sc),
		    letoh32(msg->rm_infobuflen),
		    letoh32(msg->rm_infobufoffset),
		    letoh32(msg->rm_infobuflen) +
		    letoh32(msg->rm_infobufoffset) + RNDIS_HEADER_OFFSET,
		    letoh32(msg->rm_len));
		return RNDIS_STATUS_FAILURE;
	}

	if (buf && bufsz) {
		*buf = malloc(letoh32(msg->rm_infobuflen),
		    M_TEMP, M_WAITOK | M_CANFAIL);
		if (*buf == NULL) {
			printf("%s: out of memory\n", DEVNAME(sc));
			return RNDIS_STATUS_FAILURE;
		} else {
			char *p;
			*bufsz = letoh32(msg->rm_infobuflen);

			p = (char *)&msg->rm_rid;
			p += letoh32(msg->rm_infobufoffset);
			memcpy(*buf, p, letoh32(msg->rm_infobuflen));
		}
	}

	return letoh32(msg->rm_status);
}

u_int32_t
urndis_ctrl_handle_reset(struct urndis_softc *sc,
    const struct rndis_comp_hdr *hdr)
{
	const struct rndis_reset_comp	*msg;
	u_int32_t			 rval;

	msg = (struct rndis_reset_comp *) hdr;

	rval = letoh32(msg->rm_status);

	DPRINTF(("%s: urndis_ctrl_handle_reset: len %u status 0x%x "
	    "adrreset %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_len),
	    rval,
	    letoh32(msg->rm_adrreset)));

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: reset failed 0x%x\n", DEVNAME(sc), rval);
		return rval;
	}

	if (letoh32(msg->rm_adrreset) != 0) {
		u_int32_t filter;

		filter = htole32(sc->sc_filter);
		rval = urndis_ctrl_set(sc, OID_GEN_CURRENT_PACKET_FILTER,
		    &filter, sizeof(filter));
		if (rval != RNDIS_STATUS_SUCCESS) {
			printf("%s: unable to reset data filters\n",
			    DEVNAME(sc));
			return rval;
		}
	}

	return rval;
}

u_int32_t
urndis_ctrl_handle_status(struct urndis_softc *sc,
    const struct rndis_comp_hdr *hdr)
{
	const struct rndis_status_msg	*msg;
	u_int32_t			 rval;

	msg = (struct rndis_status_msg *)hdr;

	rval = letoh32(msg->rm_status);

	DPRINTF(("%s: urndis_ctrl_handle_status: len %u status 0x%x "
	    "stbuflen %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_len),
	    rval,
	    letoh32(msg->rm_stbuflen)));

	switch (rval) {
		case RNDIS_STATUS_MEDIA_CONNECT:
		case RNDIS_STATUS_MEDIA_DISCONNECT:
		case RNDIS_STATUS_OFFLOAD_CURRENT_CONFIG:
			rval = RNDIS_STATUS_SUCCESS;
			break;

		default:
			printf("%s: status 0x%x\n", DEVNAME(sc), rval);
	}

	return rval;
}

u_int32_t
urndis_ctrl_init(struct urndis_softc *sc)
{
	struct rndis_init_req	*msg;
	u_int32_t		 rval;
	struct rndis_comp_hdr	*hdr;

	msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK | M_CANFAIL);
	if (msg == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	msg->rm_type = htole32(REMOTE_NDIS_INITIALIZE_MSG);
	msg->rm_len = htole32(sizeof(*msg));
	msg->rm_rid = htole32(0);
	msg->rm_ver_major = htole32(1);
	msg->rm_ver_minor = htole32(1);
	msg->rm_max_xfersz = htole32(RNDIS_BUFSZ);

	DPRINTF(("%s: urndis_ctrl_init send: type %u len %u rid %u ver_major %u "
	    "ver_minor %u max_xfersz %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_type),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid),
	    letoh32(msg->rm_ver_major),
	    letoh32(msg->rm_ver_minor),
	    letoh32(msg->rm_max_xfersz)));

	rval = urndis_ctrl_send(sc, msg, sizeof(*msg));
	free(msg, M_TEMP, sizeof *msg);

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: init failed\n", DEVNAME(sc));
		return rval;
	}

	if ((hdr = urndis_ctrl_recv(sc)) == NULL) {
		printf("%s: unable to get init response\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}
	rval = urndis_ctrl_handle(sc, hdr, NULL, NULL);

	return rval;
}

u_int32_t
urndis_ctrl_halt(struct urndis_softc *sc)
{
	struct rndis_halt_req	*msg;
	u_int32_t		 rval;

	msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK | M_CANFAIL);
	if (msg == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	msg->rm_type = htole32(REMOTE_NDIS_HALT_MSG);
	msg->rm_len = htole32(sizeof(*msg));
	msg->rm_rid = 0;

	DPRINTF(("%s: urndis_ctrl_halt send: type %u len %u rid %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_type),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid)));

	rval = urndis_ctrl_send(sc, msg, sizeof(*msg));
	free(msg, M_TEMP, sizeof *msg);

	if (rval != RNDIS_STATUS_SUCCESS)
		printf("%s: halt failed\n", DEVNAME(sc));

	return rval;
}

u_int32_t
urndis_ctrl_query(struct urndis_softc *sc, u_int32_t oid,
    void *qbuf, size_t qlen,
    void **rbuf, size_t *rbufsz)
{
	struct rndis_query_req	*msg;
	u_int32_t		 rval;
	struct rndis_comp_hdr	*hdr;

	msg = malloc(sizeof(*msg) + qlen, M_TEMP, M_WAITOK | M_CANFAIL);
	if (msg == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	msg->rm_type = htole32(REMOTE_NDIS_QUERY_MSG);
	msg->rm_len = htole32(sizeof(*msg) + qlen);
	msg->rm_rid = 0; /* XXX */
	msg->rm_oid = htole32(oid);
	msg->rm_infobuflen = htole32(qlen);
	if (qlen != 0) {
		msg->rm_infobufoffset = htole32(20);
		memcpy((char*)msg + 20, qbuf, qlen);
	} else
		msg->rm_infobufoffset = 0;
	msg->rm_devicevchdl = 0;

	DPRINTF(("%s: urndis_ctrl_query send: type %u len %u rid %u oid 0x%x "
	    "infobuflen %u infobufoffset %u devicevchdl %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_type),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid),
	    letoh32(msg->rm_oid),
	    letoh32(msg->rm_infobuflen),
	    letoh32(msg->rm_infobufoffset),
	    letoh32(msg->rm_devicevchdl)));

	rval = urndis_ctrl_send(sc, msg, sizeof(*msg));
	free(msg, M_TEMP, sizeof *msg + qlen);

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: query failed\n", DEVNAME(sc));
		return rval;
	}

	if ((hdr = urndis_ctrl_recv(sc)) == NULL) {
		printf("%s: unable to get query response\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}
	rval = urndis_ctrl_handle(sc, hdr, rbuf, rbufsz);

	return rval;
}

u_int32_t
urndis_ctrl_set(struct urndis_softc *sc, u_int32_t oid, void *buf, size_t len)
{
	struct rndis_set_req	*msg;
	u_int32_t		 rval;
	struct rndis_comp_hdr	*hdr;

	msg = malloc(sizeof(*msg) + len, M_TEMP, M_WAITOK | M_CANFAIL);
	if (msg == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	msg->rm_type = htole32(REMOTE_NDIS_SET_MSG);
	msg->rm_len = htole32(sizeof(*msg) + len);
	msg->rm_rid = 0; /* XXX */
	msg->rm_oid = htole32(oid);
	msg->rm_infobuflen = htole32(len);
	if (len != 0) {
		msg->rm_infobufoffset = htole32(20);
		memcpy((char*)msg + 28, buf, len);
	} else
		msg->rm_infobufoffset = 0;
	msg->rm_devicevchdl = 0;

	DPRINTF(("%s: urndis_ctrl_set send: type %u len %u rid %u oid 0x%x "
	    "infobuflen %u infobufoffset %u devicevchdl %u\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_type),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_rid),
	    letoh32(msg->rm_oid),
	    letoh32(msg->rm_infobuflen),
	    letoh32(msg->rm_infobufoffset),
	    letoh32(msg->rm_devicevchdl)));

	rval = urndis_ctrl_send(sc, msg, sizeof(*msg) + len);
	free(msg, M_TEMP, sizeof *msg + len);

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: set failed\n", DEVNAME(sc));
		return rval;
	}

	if ((hdr = urndis_ctrl_recv(sc)) == NULL) {
		printf("%s: unable to get set response\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}
	rval = urndis_ctrl_handle(sc, hdr, NULL, NULL);
	if (rval != RNDIS_STATUS_SUCCESS)
		printf("%s: set failed 0x%x\n", DEVNAME(sc), rval);

	return rval;
}

u_int32_t
urndis_ctrl_set_param(struct urndis_softc *sc,
    const char *name,
    u_int32_t type,
    void *buf,
    size_t len)
{
	struct rndis_set_parameter	*param;
	u_int32_t			 rval;
	size_t				 namelen, tlen;

	if (name)
		namelen = strlen(name);
	else
		namelen = 0;
	tlen = sizeof(*param) + len + namelen;
	param = malloc(tlen, M_TEMP, M_WAITOK | M_CANFAIL);
	if (param == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	param->rm_namelen = htole32(namelen);
	param->rm_valuelen = htole32(len);
	param->rm_type = htole32(type);
	if (namelen != 0) {
		param->rm_nameoffset = htole32(20);
		memcpy(param + 20, name, namelen);
	} else
		param->rm_nameoffset = 0;
	if (len != 0) {
		param->rm_valueoffset = htole32(20 + namelen);
		memcpy(param + 20 + namelen, buf, len);
	} else
		param->rm_valueoffset = 0;

	DPRINTF(("%s: urndis_ctrl_set_param send: nameoffset %u namelen %u "
	    "type 0x%x valueoffset %u valuelen %u\n",
	    DEVNAME(sc),
	    letoh32(param->rm_nameoffset),
	    letoh32(param->rm_namelen),
	    letoh32(param->rm_type),
	    letoh32(param->rm_valueoffset),
	    letoh32(param->rm_valuelen)));

	rval = urndis_ctrl_set(sc, OID_GEN_RNDIS_CONFIG_PARAMETER, param, tlen);
	free(param, M_TEMP, tlen);
	if (rval != RNDIS_STATUS_SUCCESS)
		printf("%s: set param failed 0x%x\n", DEVNAME(sc), rval);

	return rval;
}

#if 0
/* XXX : adrreset, get it from response */
u_int32_t
urndis_ctrl_reset(struct urndis_softc *sc)
{
	struct rndis_reset_req		*reset;
	u_int32_t			 rval;
	struct rndis_comp_hdr		*hdr;

	reset = malloc(sizeof(*reset), M_TEMP, M_WAITOK | M_CANFAIL);
	if (reset == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	reset->rm_type = htole32(REMOTE_NDIS_RESET_MSG);
	reset->rm_len = htole32(sizeof(*reset));
	reset->rm_rid = 0; /* XXX rm_rid == reserved ... remove ? */

	DPRINTF(("%s: urndis_ctrl_reset send: type %u len %u rid %u\n",
	    DEVNAME(sc),
	    letoh32(reset->rm_type),
	    letoh32(reset->rm_len),
	    letoh32(reset->rm_rid)));

	rval = urndis_ctrl_send(sc, reset, sizeof(*reset));
	free(reset, M_TEMP, sizeof *reset);

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: reset failed\n", DEVNAME(sc));
		return rval;
	}

	if ((hdr = urndis_ctrl_recv(sc)) == NULL) {
		printf("%s: unable to get reset response\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}
	rval = urndis_ctrl_handle(sc, hdr, NULL, NULL);

	return rval;
}

u_int32_t
urndis_ctrl_keepalive(struct urndis_softc *sc)
{
	struct rndis_keepalive_req	*keep;
	u_int32_t			 rval;
	struct rndis_comp_hdr		*hdr;

	keep = malloc(sizeof(*keep), M_TEMP, M_WAITOK | M_CANFAIL);
	if (keep == NULL) {
		printf("%s: out of memory\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}

	keep->rm_type = htole32(REMOTE_NDIS_KEEPALIVE_MSG);
	keep->rm_len = htole32(sizeof(*keep));
	keep->rm_rid = 0; /* XXX rm_rid == reserved ... remove ? */

	DPRINTF(("%s: urndis_ctrl_keepalive: type %u len %u rid %u\n",
	    DEVNAME(sc),
	    letoh32(keep->rm_type),
	    letoh32(keep->rm_len),
	    letoh32(keep->rm_rid)));

	rval = urndis_ctrl_send(sc, keep, sizeof(*keep));
	free(keep, M_TEMP, sizeof *keep);

	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: keepalive failed\n", DEVNAME(sc));
		return rval;
	}

	if ((hdr = urndis_ctrl_recv(sc)) == NULL) {
		printf("%s: unable to get keepalive response\n", DEVNAME(sc));
		return RNDIS_STATUS_FAILURE;
	}
	rval = urndis_ctrl_handle(sc, hdr, NULL, NULL);
	if (rval != RNDIS_STATUS_SUCCESS) {
		printf("%s: keepalive failed 0x%x\n", DEVNAME(sc), rval);
		urndis_ctrl_reset(sc);
	}

	return rval;
}
#endif

int
urndis_encap(struct urndis_softc *sc, struct mbuf *m, int idx)
{
	struct urndis_chain		*c;
	usbd_status			 err;
	struct rndis_packet_msg		*msg;

	c = &sc->sc_data.sc_tx_chain[idx];

	msg = (struct rndis_packet_msg *)c->sc_buf;

	memset(msg, 0, sizeof(*msg));
	msg->rm_type = htole32(REMOTE_NDIS_PACKET_MSG);
	msg->rm_len = htole32(sizeof(*msg) + m->m_pkthdr.len);

	msg->rm_dataoffset = htole32(RNDIS_DATA_OFFSET);
	msg->rm_datalen = htole32(m->m_pkthdr.len);

	m_copydata(m, 0, m->m_pkthdr.len,
	    ((char*)msg + RNDIS_DATA_OFFSET + RNDIS_HEADER_OFFSET));

	DPRINTF(("%s: urndis_encap type 0x%x len %u data(off %u len %u)\n",
	    DEVNAME(sc),
	    letoh32(msg->rm_type),
	    letoh32(msg->rm_len),
	    letoh32(msg->rm_dataoffset),
	    letoh32(msg->rm_datalen)));

	c->sc_mbuf = m;

	usbd_setup_xfer(c->sc_xfer, sc->sc_bulkout_pipe, c, c->sc_buf,
	    letoh32(msg->rm_len), USBD_FORCE_SHORT_XFER | USBD_NO_COPY, 10000,
	    urndis_txeof);

	/* Transmit */
	err = usbd_transfer(c->sc_xfer);
	if (err != USBD_IN_PROGRESS) {
		urndis_stop(sc);
		return(EIO);
	}

	sc->sc_data.sc_tx_cnt++;

	return(0);
}

void
urndis_decap(struct urndis_softc *sc, struct urndis_chain *c, u_int32_t len)
{
	struct mbuf		*m;
	struct mbuf_list	 ml = MBUF_LIST_INITIALIZER();
	struct rndis_packet_msg	*msg;
	struct ifnet		*ifp;
	int			 s;
	int			 offset;

	ifp = GET_IFP(sc);
	offset = 0;

	while (len > 0) {
		msg = (struct rndis_packet_msg *)((char*)c->sc_buf + offset);
		m = c->sc_mbuf;

		DPRINTF(("%s: urndis_decap buffer size left %u\n", DEVNAME(sc),
		    len));

		if (len < sizeof(*msg)) {
			printf("%s: urndis_decap invalid buffer len %u < "
			    "minimum header %zu\n",
			    DEVNAME(sc),
			    len,
			    sizeof(*msg));
			return;
		}

		DPRINTF(("%s: urndis_decap len %u data(off:%u len:%u) "
		    "oobdata(off:%u len:%u nb:%u) perpacket(off:%u len:%u)\n",
		    DEVNAME(sc),
		    letoh32(msg->rm_len),
		    letoh32(msg->rm_dataoffset),
		    letoh32(msg->rm_datalen),
		    letoh32(msg->rm_oobdataoffset),
		    letoh32(msg->rm_oobdatalen),
		    letoh32(msg->rm_oobdataelements),
		    letoh32(msg->rm_pktinfooffset),
		    letoh32(msg->rm_pktinfooffset)));

		if (letoh32(msg->rm_type) != REMOTE_NDIS_PACKET_MSG) {
			printf("%s: urndis_decap invalid type 0x%x != 0x%x\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_type),
			    REMOTE_NDIS_PACKET_MSG);
			return;
		}
		if (letoh32(msg->rm_len) < sizeof(*msg)) {
			printf("%s: urndis_decap invalid msg len %u < %zu\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_len),
			    sizeof(*msg));
			return;
		}
		if (letoh32(msg->rm_len) > len) {
			printf("%s: urndis_decap invalid msg len %u > buffer "
			    "len %u\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_len),
			    len);
			return;
		}

		if (letoh32(msg->rm_dataoffset) +
		    letoh32(msg->rm_datalen) + RNDIS_HEADER_OFFSET
			> letoh32(msg->rm_len)) {
			printf("%s: urndis_decap invalid data "
			    "len/offset/end_position(%u/%u/%zu) -> "
			    "go out of receive buffer limit %u\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_datalen),
			    letoh32(msg->rm_dataoffset),
			    letoh32(msg->rm_dataoffset) +
			    letoh32(msg->rm_datalen) + RNDIS_HEADER_OFFSET,
			    letoh32(msg->rm_len));
			return;
		}

		if (letoh32(msg->rm_datalen) < sizeof(struct ether_header)) {
			ifp->if_ierrors++;
			DPRINTF(("%s: urndis_decap invalid ethernet size "
			    "%u < %zu\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_datalen),
			    sizeof(struct ether_header)));
			return;
		}

		memcpy(mtod(m, char*),
		    ((char*)&msg->rm_dataoffset + letoh32(msg->rm_dataoffset)),
		    letoh32(msg->rm_datalen));
		m->m_pkthdr.len = m->m_len = letoh32(msg->rm_datalen);

		if (urndis_newbuf(sc, c) == ENOBUFS) {
			ifp->if_ierrors++;
		} else {
			ml_enqueue(&ml, m);
		}

		offset += letoh32(msg->rm_len);
		len -= letoh32(msg->rm_len);
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);
}

int
urndis_newbuf(struct urndis_softc *sc, struct urndis_chain *c)
{
	struct mbuf *m_new = NULL;

	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL) {
		printf("%s: no memory for rx list -- packet dropped!\n",
		    DEVNAME(sc));
		return (ENOBUFS);
	}
	MCLGET(m_new, M_DONTWAIT);
	if (!(m_new->m_flags & M_EXT)) {
		printf("%s: no memory for rx list -- packet dropped!\n",
		    DEVNAME(sc));
		m_freem(m_new);
		return (ENOBUFS);
	}
	m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;

	m_adj(m_new, ETHER_ALIGN);
	c->sc_mbuf = m_new;
	return (0);
}

int
urndis_rx_list_init(struct urndis_softc *sc)
{
	struct urndis_cdata	*cd;
	struct urndis_chain	*c;
	int			 i;

	cd = &sc->sc_data;
	for (i = 0; i < RNDIS_RX_LIST_CNT; i++) {
		c = &cd->sc_rx_chain[i];
		c->sc_softc = sc;
		c->sc_idx = i;

		if (urndis_newbuf(sc, c) == ENOBUFS)
			return (ENOBUFS);

		if (c->sc_xfer == NULL) {
			c->sc_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->sc_xfer == NULL)
				return (ENOBUFS);
			c->sc_buf = usbd_alloc_buffer(c->sc_xfer,
			    RNDIS_BUFSZ);
			if (c->sc_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

int
urndis_tx_list_init(struct urndis_softc *sc)
{
	struct urndis_cdata	*cd;
	struct urndis_chain	*c;
	int			 i;

	cd = &sc->sc_data;
	for (i = 0; i < RNDIS_TX_LIST_CNT; i++) {
		c = &cd->sc_tx_chain[i];
		c->sc_softc = sc;
		c->sc_idx = i;
		c->sc_mbuf = NULL;
		if (c->sc_xfer == NULL) {
			c->sc_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->sc_xfer == NULL)
				return (ENOBUFS);
			c->sc_buf = usbd_alloc_buffer(c->sc_xfer,
			    RNDIS_BUFSZ);
			if (c->sc_buf == NULL)
				return (ENOBUFS);
		}
	}
	return (0);
}

int
urndis_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct urndis_softc	*sc = ifp->if_softc;
	int			 s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			urndis_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				urndis_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				urndis_stop(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
		break;
	}

	if (error == ENETRESET)
		error = 0;

	splx(s);
	return (error);
}

#if 0
void
urndis_watchdog(struct ifnet *ifp)
{
	struct urndis_softc *sc;

	sc = ifp->if_softc;

	if (usbd_is_dying(sc->sc_udev))
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", DEVNAME(sc));

	urndis_ctrl_keepalive(sc);
}
#endif

void
urndis_init(struct urndis_softc *sc)
{
	struct ifnet		*ifp = GET_IFP(sc);
	int			 i, s;
	usbd_status		 err;

	if (urndis_ctrl_init(sc) != RNDIS_STATUS_SUCCESS)
		return;

	s = splnet();

	if (urndis_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n",
		    DEVNAME(sc));
		splx(s);
		return;
	}

	if (urndis_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n",
		    DEVNAME(sc));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->sc_iface_data, sc->sc_bulkin_no,
	    USBD_EXCLUSIVE_USE, &sc->sc_bulkin_pipe);
	if (err) {
		printf("%s: open rx pipe failed: %s\n", DEVNAME(sc),
		    usbd_errstr(err));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->sc_iface_data, sc->sc_bulkout_no,
	    USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
	if (err) {
		printf("%s: open tx pipe failed: %s\n", DEVNAME(sc),
		    usbd_errstr(err));
		splx(s);
		return;
	}

	for (i = 0; i < RNDIS_RX_LIST_CNT; i++) {
		struct urndis_chain *c;

		c = &sc->sc_data.sc_rx_chain[i];
		usbd_setup_xfer(c->sc_xfer, sc->sc_bulkin_pipe, c,
		    c->sc_buf, RNDIS_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, urndis_rxeof);
		usbd_transfer(c->sc_xfer);
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

void
urndis_stop(struct urndis_softc *sc)
{
	usbd_status	 err;
	struct ifnet	*ifp;
	int		 i;

	ifp = GET_IFP(sc);
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (sc->sc_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		err = usbd_close_pipe(sc->sc_bulkin_pipe);
		if (err)
			printf("%s: close rx pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
		sc->sc_bulkin_pipe = NULL;
	}

	if (sc->sc_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		err = usbd_close_pipe(sc->sc_bulkout_pipe);
		if (err)
			printf("%s: close tx pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
		sc->sc_bulkout_pipe = NULL;
	}

	for (i = 0; i < RNDIS_RX_LIST_CNT; i++) {
		if (sc->sc_data.sc_rx_chain[i].sc_mbuf != NULL) {
			m_freem(sc->sc_data.sc_rx_chain[i].sc_mbuf);
			sc->sc_data.sc_rx_chain[i].sc_mbuf = NULL;
		}
		if (sc->sc_data.sc_rx_chain[i].sc_xfer != NULL) {
			usbd_free_xfer(sc->sc_data.sc_rx_chain[i].sc_xfer);
			sc->sc_data.sc_rx_chain[i].sc_xfer = NULL;
		}
	}

	for (i = 0; i < RNDIS_TX_LIST_CNT; i++) {
		if (sc->sc_data.sc_tx_chain[i].sc_mbuf != NULL) {
			m_freem(sc->sc_data.sc_tx_chain[i].sc_mbuf);
			sc->sc_data.sc_tx_chain[i].sc_mbuf = NULL;
		}
		if (sc->sc_data.sc_tx_chain[i].sc_xfer != NULL) {
			usbd_free_xfer(sc->sc_data.sc_tx_chain[i].sc_xfer);
			sc->sc_data.sc_tx_chain[i].sc_xfer = NULL;
		}
	}
}

void
urndis_start(struct ifnet *ifp)
{
	struct urndis_softc	*sc;
	struct mbuf		*m_head = NULL;

	sc = ifp->if_softc;

	if (usbd_is_dying(sc->sc_udev) || ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (urndis_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}
	ifq_deq_commit(&ifp->if_snd, m_head);

	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	return;
}

void
urndis_rxeof(struct usbd_xfer *xfer,
    void *priv,
    usbd_status status)
{
	struct urndis_chain	*c;
	struct urndis_softc	*sc;
	struct ifnet		*ifp;
	u_int32_t		 total_len;

	c = priv;
	sc = c->sc_softc;
	ifp = GET_IFP(sc);
	total_len = 0;

	if (usbd_is_dying(sc->sc_udev) || !(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			DPRINTF(("%s: usb errors on rx: %s\n",
			    DEVNAME(sc), usbd_errstr(status)));
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);

		ifp->if_ierrors++;
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);
	urndis_decap(sc, c, total_len);

done:
	/* Setup new transfer. */
	usbd_setup_xfer(c->sc_xfer, sc->sc_bulkin_pipe, c, c->sc_buf,
	    RNDIS_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
	    urndis_rxeof);
	usbd_transfer(c->sc_xfer);
}

void
urndis_txeof(struct usbd_xfer *xfer,
    void *priv,
    usbd_status status)
{
	struct urndis_chain	*c;
	struct urndis_softc	*sc;
	struct ifnet		*ifp;
	usbd_status		 err;
	int			 s;

	c = priv;
	sc = c->sc_softc;
	ifp = GET_IFP(sc);

	DPRINTF(("%s: urndis_txeof\n", DEVNAME(sc)));

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splnet();

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		DPRINTF(("%s: usb error on tx: %s\n", DEVNAME(sc),
		    usbd_errstr(status)));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_bulkout_pipe);
		splx(s);
		return;
	}

	usbd_get_xfer_status(c->sc_xfer, NULL, NULL, NULL, &err);

	if (c->sc_mbuf != NULL) {
		m_freem(c->sc_mbuf);
		c->sc_mbuf = NULL;
	}

	if (err)
		ifp->if_oerrors++;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		urndis_start(ifp);

	splx(s);
}

const struct urndis_class *
urndis_lookup(usb_interface_descriptor_t *id)
{
	const struct urndis_class	*uc;
	int				 i;

	uc = urndis_class;
	for (i = 0; i < nitems(urndis_class); i++, uc++) {
		if (uc->class == id->bInterfaceClass &&
		    uc->subclass == id->bInterfaceSubClass &&
		    uc->protocol == id->bInterfaceProtocol)
			return (uc);
	}
	return (NULL);
}

int
urndis_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg		*uaa = aux;
	usb_interface_descriptor_t	*id;

	/* Advertises both RNDIS and CDC Ethernet, but RNDIS doesn't work. */
	if (uaa->vendor == USB_VENDOR_FUJITSUCOMP &&
	    uaa->product == USB_PRODUCT_FUJITSUCOMP_VIRTETH)
		return (UMATCH_NONE);

	if (!uaa->iface)
		return (UMATCH_NONE);

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return (UMATCH_NONE);

	return (urndis_lookup(id) ?
	    UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO : UMATCH_NONE);
}

void
urndis_attach(struct device *parent, struct device *self, void *aux)
{
	const struct urndis_class	*uc;
	struct urndis_softc		*sc;
	struct usb_attach_arg		*uaa;
	struct ifnet			*ifp;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	usb_config_descriptor_t		*cd;
	int				 i, j, altcnt;
	int				 s;
	u_char				 eaddr[ETHER_ADDR_LEN];
	void				*buf;
	size_t				 bufsz;
	u_int32_t			 filter;

	sc = (void *)self;
	uaa = aux;

	sc->sc_attached = 0;
	sc->sc_udev = uaa->device;
	id = usbd_get_interface_descriptor(uaa->iface);
	sc->sc_ifaceno_ctl = id->bInterfaceNumber;

	for (i = 0; i < uaa->nifaces; i++) {
		if (usbd_iface_claimed(sc->sc_udev, i))
			continue;

		if (uaa->ifaces[i] != uaa->iface) {
			sc->sc_iface_data = uaa->ifaces[i];
			usbd_claim_iface(sc->sc_udev, i);
			break;
		}
	}

	if (sc->sc_iface_data == NULL) {
		printf("%s: no data interface\n", DEVNAME(sc));
		return;
	}

	uc = urndis_lookup(id);
	printf("%s: using %s", DEVNAME(sc), uc->typestr);

	id = usbd_get_interface_descriptor(sc->sc_iface_data);
	cd = usbd_get_config_descriptor(sc->sc_udev);
	altcnt = usbd_get_no_alts(cd, id->bInterfaceNumber);

	for (j = 0; j < altcnt; j++) {
		if (usbd_set_interface(sc->sc_iface_data, j)) {
			printf(": interface alternate setting %u failed\n", j);
			return;
		}
		/* Find endpoints. */
		id = usbd_get_interface_descriptor(sc->sc_iface_data);
		sc->sc_bulkin_no = sc->sc_bulkout_no = -1;
		for (i = 0; i < id->bNumEndpoints; i++) {
			ed = usbd_interface2endpoint_descriptor(
			    sc->sc_iface_data, i);
			if (!ed) {
				printf(": no descriptor for bulk endpoint "
				    "%u\n", i);
				return;
			}
			if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
				sc->sc_bulkin_no = ed->bEndpointAddress;
			}
			else if (
			    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
				sc->sc_bulkout_no = ed->bEndpointAddress;
			}
		}

		if (sc->sc_bulkin_no != -1 && sc->sc_bulkout_no != -1) {
			DPRINTF(("%s: in=0x%x, out=0x%x\n",
			    DEVNAME(sc),
			    sc->sc_bulkin_no,
			    sc->sc_bulkout_no));
			goto found;
		}
	}

	if (sc->sc_bulkin_no == -1)
		printf(": could not find data bulk in\n");
	if (sc->sc_bulkout_no == -1 )
		printf(": could not find data bulk out\n");
	return;

	found:

	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = urndis_start;
	ifp->if_ioctl = urndis_ioctl;
#if 0
	ifp->if_watchdog = urndis_watchdog;
#endif

	strlcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);

	s = splnet();

	if (urndis_ctrl_query(sc, OID_802_3_PERMANENT_ADDRESS, NULL, 0,
	    &buf, &bufsz) != RNDIS_STATUS_SUCCESS) {
		printf(": unable to get hardware address\n");
		splx(s);
		return;
	}

	if (bufsz == ETHER_ADDR_LEN) {
		memcpy(eaddr, buf, ETHER_ADDR_LEN);
		printf(", address %s\n", ether_sprintf(eaddr));
		free(buf, M_TEMP, bufsz);
	} else {
		printf(", invalid address\n");
		free(buf, M_TEMP, bufsz);
		splx(s);
		return;
	}

	/* Initialize packet filter */
	sc->sc_filter = NDIS_PACKET_TYPE_BROADCAST;
	sc->sc_filter |= NDIS_PACKET_TYPE_ALL_MULTICAST;
	filter = htole32(sc->sc_filter);
	if (urndis_ctrl_set(sc, OID_GEN_CURRENT_PACKET_FILTER, &filter,
	    sizeof(filter)) != RNDIS_STATUS_SUCCESS) {
		printf("%s: unable to set data filters\n", DEVNAME(sc));
		splx(s);
		return;
	}

	bcopy(eaddr, (char *)&sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	if_attach(ifp);
	ether_ifattach(ifp);
	sc->sc_attached = 1;

	splx(s);
}

int
urndis_detach(struct device *self, int flags)
{
	struct urndis_softc	*sc;
	struct ifnet		*ifp;
	int			 s;

	sc = (void*)self;

	DPRINTF(("urndis_detach: %s flags %u\n", DEVNAME(sc),
	    flags));

	if (!sc->sc_attached)
		return 0;

	s = splusb();

	ifp = GET_IFP(sc);

	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

	urndis_stop(sc);
	sc->sc_attached = 0;

	splx(s);

	return 0;
}
@


1.66
log
@Pass M_CANFAIL to malloc(9) calls which use M_WAITOK but are tested
for failure.

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.65 2017/04/08 02:57:25 deraadt Exp $ */
d93 2
d240 4
d405 32
@


1.65
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.64 2017/03/26 15:31:15 deraadt Exp $ */
d411 1
a411 1
	msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK);
d457 1
a457 1
	msg = malloc(sizeof(*msg), M_TEMP, M_WAITOK);
d491 1
a491 1
	msg = malloc(sizeof(*msg) + qlen, M_TEMP, M_WAITOK);
d544 1
a544 1
	msg = malloc(sizeof(*msg) + len, M_TEMP, M_WAITOK);
d608 1
a608 1
	param = malloc(tlen, M_TEMP, M_WAITOK);
d654 1
a654 1
	reset = malloc(sizeof(*reset), M_TEMP, M_WAITOK);
d694 1
a694 1
	keep = malloc(sizeof(*keep), M_TEMP, M_WAITOK);
@


1.64
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.63 2017/01/22 10:17:39 dlg Exp $ */
d244 1
a244 1
	free(hdr, M_TEMP, 0);
d1434 1
a1434 1
		free(buf, M_TEMP, 0);
d1437 1
a1437 1
		free(buf, M_TEMP, 0);
@


1.63
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.62 2016/09/16 11:13:37 mikeb Exp $ */
d185 1
a185 1
		free(buf, M_TEMP, 0);
d200 1
a200 1
		free(buf, M_TEMP, 0);
d435 1
a435 1
	free(msg, M_TEMP, 0);
d474 1
a474 1
	free(msg, M_TEMP, 0);
d521 1
a521 1
	free(msg, M_TEMP, 0);
d574 1
a574 1
	free(msg, M_TEMP, 0);
d638 1
a638 1
	free(param, M_TEMP, 0);
d671 1
a671 1
	free(reset, M_TEMP, 0);
d711 1
a711 1
	free(keep, M_TEMP, 0);
@


1.62
log
@Switch urndis(4) over to the generic RNDIS header
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.61 2016/04/13 11:03:37 mpi Exp $ */
a1273 2
	else
		ifp->if_opackets++;
@


1.61
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.60 2016/03/16 21:04:40 stsp Exp $ */
d52 2
d83 1
a83 1
struct urndis_comp_hdr *urndis_ctrl_recv(struct urndis_softc *);
d86 1
a86 1
    struct urndis_comp_hdr *, void **, size_t *);
d88 1
a88 1
    const struct urndis_comp_hdr *);
d90 1
a90 1
    const struct urndis_comp_hdr *, void **, size_t *);
d92 1
a92 1
    const struct urndis_comp_hdr *);
d166 1
a166 1
struct urndis_comp_hdr *
d170 1
a170 1
	struct urndis_comp_hdr	*hdr;
d189 1
a189 1
	hdr = (struct urndis_comp_hdr *)buf;
d208 1
a208 1
urndis_ctrl_handle(struct urndis_softc *sc, struct urndis_comp_hdr *hdr,
d251 1
a251 1
    const struct urndis_comp_hdr *hdr)
d253 1
a253 1
	const struct urndis_init_comp	*msg;
d255 1
a255 1
	msg = (struct urndis_init_comp *) hdr;
d304 1
a304 1
    const struct urndis_comp_hdr *hdr, void **buf, size_t *bufsz)
d306 1
a306 1
	const struct urndis_query_comp	*msg;
d308 1
a308 1
	msg = (struct urndis_query_comp *) hdr;
d339 1
a339 1
		    letoh32(msg->rm_infobufoffset), 
d367 1
a367 1
    const struct urndis_comp_hdr *hdr)
d369 1
a369 1
	const struct urndis_reset_comp	*msg;
d372 1
a372 1
	msg = (struct urndis_reset_comp *) hdr;
d407 1
a407 1
	struct urndis_init_req	*msg;
d409 1
a409 1
	struct urndis_comp_hdr	*hdr;
d454 1
a454 1
	struct urndis_halt_req	*msg;
d487 1
a487 1
	struct urndis_query_req	*msg;
d489 1
a489 1
	struct urndis_comp_hdr	*hdr;
d540 1
a540 1
	struct urndis_set_req	*msg;
d542 1
a542 1
	struct urndis_comp_hdr	*hdr;
d588 1
a588 1
 
d599 1
a599 1
	struct urndis_set_parameter	*param;
d650 1
a650 1
	struct urndis_reset_req		*reset;
d652 1
a652 1
	struct urndis_comp_hdr		*hdr;
d690 1
a690 1
	struct urndis_keepalive_req	*keep;
d692 1
a692 1
	struct urndis_comp_hdr		*hdr;
d737 1
a737 1
	struct urndis_packet_msg		*msg;
d741 1
a741 1
	msg = (struct urndis_packet_msg *)c->sc_buf;
d783 1
a783 1
	struct urndis_packet_msg	*msg;
d790 1
a790 1
	
d792 1
a792 1
		msg = (struct urndis_packet_msg *)((char*)c->sc_buf + offset);
d843 2
a844 2
		    letoh32(msg->rm_datalen) + RNDIS_HEADER_OFFSET 
		        > letoh32(msg->rm_len)) {
d1317 1
a1317 1
	return (urndis_lookup(id) ? 
d1445 2
a1446 2
	sc->sc_filter = RNDIS_PACKET_TYPE_BROADCAST; 
	sc->sc_filter |= RNDIS_PACKET_TYPE_ALL_MULTICAST;
d1475 1
a1475 1
	
@


1.60
log
@Make urndis(4) print tx/rx errors only if compiled in DEBUG mode.
These printfs were causing too much noise in dmesg during regular operation.
And don't forget to count input errors.
ok sthen@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.59 2015/11/25 03:10:00 dlg Exp $ */
a1420 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.59
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.58 2015/11/24 17:11:40 mpi Exp $ */
d857 1
a857 1
			printf("%s: urndis_decap invalid ethernet size "
d861 1
a861 1
			    sizeof(struct ether_header));
d1203 2
a1204 2
			printf("%s: usb errors on rx: %s\n",
			    DEVNAME(sc), usbd_errstr(status));
d1209 1
d1255 2
a1256 2
		printf("%s: usb error on tx: %s\n", DEVNAME(sc),
		    usbd_errstr(status));
@


1.58
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.57 2015/11/20 03:35:23 dlg Exp $ */
d1082 1
a1082 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1096 2
a1097 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1148 1
a1148 1
	if (usbd_is_dying(sc->sc_udev) || (ifp->if_flags & IFF_OACTIVE))
d1157 1
a1157 1
		ifp->if_flags |= IFF_OACTIVE;
d1171 1
a1171 1
	ifp->if_flags |= IFF_OACTIVE;
d1246 1
a1246 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.57
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.56 2015/10/25 12:11:56 mpi Exp $ */
a36 1
#include <net/if_dl.h>
@


1.56
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.55 2015/06/24 09:40:54 mpi Exp $ */
d1151 1
a1151 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1156 1
d1160 1
a1160 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.55
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.54 2015/03/14 03:38:49 jsg Exp $ */
a970 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a982 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.54
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.53 2015/03/11 16:07:22 mpi Exp $ */
a869 2

		ifp->if_ipackets++;
@


1.53
log
@Convert to if_input().

Tested and ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.52 2015/01/09 20:45:40 kettenis Exp $ */
a51 1
#include <dev/usb/usbcdc.h>
@


1.52
log
@The "SunMicro Virtual Eth Device" found on Oracle's more recent SPARC systems
claims to support both RNDIS and CDC Ethernet.  However, RNDIS doesn't seem
to work, at least not with our driver.  So blacklist it here such that cdce(4)
takes over.

ok miod@@, armani@@ (both a while back)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.51 2014/12/22 02:28:52 tedu Exp $ */
d782 1
a872 3
		m->m_pkthdr.rcvif = ifp;

		s = splnet();
d877 1
a877 8

#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

			ether_input_mbuf(ifp, m);

a878 1
		splx(s);
d883 4
@


1.51
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.50 2014/11/30 21:45:04 kettenis Exp $ */
d1310 1
a1310 1
	struct usb_attach_arg		*uaa;
d1313 4
a1316 1
	uaa = aux;
@


1.50
log
@Don't overwrite fields in the message when setting up the REMOTE_NDIS_SET_MSG
command in urndis_ctrl_set().  Seems many RNDIS hardware doesn't care about
the overwritten fields, but the SunMicro Virtual Eth Device found in newer
Oracle SPARC hardware does.

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.49 2014/07/13 15:52:49 mpi Exp $ */
a992 1
#ifdef INET
a994 1
#endif
@


1.49
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.48 2014/07/12 18:48:52 tedu Exp $ */
d557 1
a557 1
		memcpy((char*)msg + 20, buf, len);
d573 1
a573 1
	rval = urndis_ctrl_send(sc, msg, sizeof(*msg));
@


1.48
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.47 2014/07/12 07:59:23 mpi Exp $ */
a43 1
#ifdef INET
a44 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a45 1
#endif
@


1.47
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.46 2013/12/09 15:45:29 pirofti Exp $ */
d189 1
a189 1
		free(buf, M_TEMP);
d204 1
a204 1
		free(buf, M_TEMP);
d248 1
a248 1
	free(hdr, M_TEMP);
d439 1
a439 1
	free(msg, M_TEMP);
d478 1
a478 1
	free(msg, M_TEMP);
d525 1
a525 1
	free(msg, M_TEMP);
d578 1
a578 1
	free(msg, M_TEMP);
d642 1
a642 1
	free(param, M_TEMP);
d675 1
a675 1
	free(reset, M_TEMP);
d715 1
a715 1
	free(keep, M_TEMP);
d1449 1
a1449 1
		free(buf, M_TEMP);
d1452 1
a1452 1
		free(buf, M_TEMP);
@


1.46
log
@Fix crash on urndis(4) detach


When detaching my nokia c2-01 dohooks in if_detach would panic.

This was due to a failure to setup a pipe in urndis_ctrl_init()
which results in a TIMEOUT on receive with side-effects later on
during detach due to assumptions regarding the existence of interface
hooks during dohooks on if_detach tear-down.

That resulted on dereferencing a NULL function pointer which triggered
a panic.


Discussed with mpi@@, tested and okay giovanni@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.45 2013/12/07 20:17:42 brad Exp $ */
a117 1
int urndis_activate(struct device *, int);
d124 1
a124 5
	sizeof(struct urndis_softc),
	urndis_match,
	urndis_attach,
	urndis_detach,
	urndis_activate,
a1507 17

int
urndis_activate(struct device *self, int devact)
{
	struct urndis_softc *sc;

	sc = (struct urndis_softc *)self;

	switch (devact) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return 0;
}

@


1.45
log
@Some cleaning up of the ioctl handling bits to bring things in line
with the other drivers. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.44 2013/11/21 14:08:05 mpi Exp $ */
d1357 1
a1441 2
	urndis_init(sc);

a1446 1
		urndis_stop(sc);
a1457 1
		urndis_stop(sc);
a1468 1
		urndis_stop(sc);
@


1.44
log
@Revert r1.41, in this driver sc_attached does not indicate that the
driver is not yet attached, it is here to prevent the driver to free
unitialized structures in case something wrong happened during the
the initialization...

Found the hard way and ok giovanni@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.43 2013/11/15 10:17:39 pirofti Exp $ */
d988 3
a990 7
	struct urndis_softc	*sc;
	struct ifaddr		*ifa;
	int			 s, error;

	sc = ifp->if_softc;
	ifa = (struct ifaddr *)data;
	error = 0;
d1000 4
a1003 4
		urndis_init(sc);

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d1005 1
a1005 2
			break;
		}
d1010 3
a1012 1
			if (!(ifp->if_flags & IFF_RUNNING))
a1017 1
		error = 0;
d1053 1
a1053 1
	struct ifnet		*ifp;
a1055 5


	ifp = GET_IFP(sc);
	if (ifp->if_flags & IFF_RUNNING)
		return;
@


1.43
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.42 2013/11/08 10:12:20 pirofti Exp $ */
d1490 1
d1506 3
d1520 1
@


1.42
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.41 2013/10/29 10:01:20 mpi Exp $ */
d1132 1
a1132 4
		err = usbd_abort_pipe(sc->sc_bulkin_pipe);
		if (err)
			printf("%s: abort rx pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
d1141 1
a1141 4
		err = usbd_abort_pipe(sc->sc_bulkout_pipe);
		if (err)
			printf("%s: abort tx pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
@


1.41
log
@Kill sc_attached, attach and detach events for USB devices are triggered
by the same explore task and cannot happen in parallel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.40 2013/10/01 20:06:03 sf Exp $ */
d163 1
a163 1
	if (sc->sc_dying)
d996 1
a996 1
	if (sc->sc_dying)
d1044 1
a1044 1
	if (sc->sc_dying)
d1186 1
a1186 1
	if (sc->sc_dying || (ifp->if_flags & IFF_OACTIVE))
d1233 1
a1233 1
	if (sc->sc_dying || !(ifp->if_flags & IFF_RUNNING))
d1277 1
a1277 1
	if (sc->sc_dying)
d1537 1
a1537 1
		sc->sc_dying = 1;
@


1.40
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.39 2013/08/07 01:06:43 bluhm Exp $ */
a1495 1
	sc->sc_attached = 1;
a1510 3
	
	if (!sc->sc_attached)
		return 0;
a1521 1
	sc->sc_attached = 0;
@


1.39
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.38 2013/04/15 09:23:01 mglocker Exp $ */
d344 2
a345 2
		    "len/offset/end_position(%d/%d/%d) -> "
		    "go out of buffer limit %d\n",
d808 1
a808 1
			    "minimum header %u\n",
d835 1
a835 1
			printf("%s: urndis_decap invalid msg len %u < %u\n",
d854 1
a854 1
			    "len/offset/end_position(%u/%u/%u) -> "
d868 1
a868 1
			    "%d < %d\n",
@


1.38
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.37 2013/03/28 03:58:03 tedu Exp $ */
a46 1
#include <netinet/in_var.h>
@


1.37
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.36 2013/02/02 15:03:58 fgsch Exp $ */
d77 2
a78 2
void urndis_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void urndis_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d1220 2
a1221 2
urndis_rxeof(usbd_xfer_handle xfer,
    usbd_private_handle priv,
d1262 2
a1263 2
urndis_txeof(usbd_xfer_handle xfer,
    usbd_private_handle priv,
@


1.36
log
@- remove product/vendor table and let the driver attach based on class, etc.
- print what type of device is.

tested by sthen@@. similar diff tested by jasper@@ and gonzalo@@.
ok mpi@@ and sthen@@

if you have one of these devices please give it a try and mail the details.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.35 2012/12/05 23:20:21 deraadt Exp $ */
a29 1
#include <sys/proc.h>
@


1.35
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.34 2012/06/20 10:51:27 fgsch Exp $ */
d115 2
d134 1
a134 1
struct urndis_class {
d138 1
d140 3
a142 12
	{ UICLASS_CDC, UISUBCLASS_ABSTRACT_CONTROL_MODEL, 0xff },
	{ UICLASS_WIRELESS, UISUBCLASS_RF, UIPROTO_RNDIS },
	{ UICLASS_MISC, UISUBCLASS_SYNC, UIPROTO_ACTIVESYNC }
};

/*
 * Supported devices that we can't match by class IDs.
 */
static const struct usb_devno urndis_devs[] = {
	{ USB_VENDOR_HTC,	USB_PRODUCT_HTC_ANDROID },
	{ USB_VENDOR_SAMSUNG2,	USB_PRODUCT_SAMSUNG2_ANDROID },
	{ USB_VENDOR_SAMSUNG2,	USB_PRODUCT_SAMSUNG2_ANDROID2 }
d1319 16
a1339 1
	int				 i;
d1350 2
a1351 9
	for (i = 0; i < nitems(urndis_class); i++) {
		if (urndis_class[i].class == id->bInterfaceClass &&
		    urndis_class[i].subclass == id->bInterfaceSubClass &&
		    urndis_class[i].protocol == id->bInterfaceProtocol)
			return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
	}

	return (usb_lookup(urndis_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
d1357 1
d1394 3
d1403 1
a1403 2
			printf("%s: interface alternate setting %u failed\n",
			    DEVNAME(sc), j);
d1413 2
a1414 2
				printf("%s: no descriptor for bulk endpoint "
				    "%u\n", DEVNAME(sc), i);
d1438 1
a1438 1
		printf("%s: could not find data bulk in\n", DEVNAME(sc));
d1440 1
a1440 1
		printf("%s: could not find data bulk out\n", DEVNAME(sc));
d1464 1
a1464 1
		printf("%s: unable to get hardware address\n", DEVNAME(sc));
d1472 1
a1472 1
		printf("%s: address %s\n", DEVNAME(sc), ether_sprintf(eaddr));
d1475 1
a1475 1
		printf("%s: invalid address\n", DEVNAME(sc));
@


1.34
log
@- urndis_match() should support multiple interface descriptors.
- in urndis_attach() use the first interface descriptor that's different
  from the control interface as the data interface.

from armani's colleague with some tweaks by me.
kettenis@@ sthen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.33 2012/03/24 08:33:08 fgsch Exp $ */
a20 2

#include <sys/cdefs.h>
@


1.33
log
@add ZTE HSUSB.
committed over it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.32 2011/07/20 13:11:41 jasper Exp $ */
d134 10
d150 1
a150 2
	{ USB_VENDOR_SAMSUNG2,	USB_PRODUCT_SAMSUNG2_ANDROID2 },
	{ USB_VENDOR_ZTE,	USB_PRODUCT_ZTE_HSUSB }
d1332 1
d1343 6
a1348 4
	if (id->bInterfaceClass == UICLASS_WIRELESS &&
	    id->bInterfaceSubClass == UISUBCLASS_RF &&
	    id->bInterfaceProtocol == UIPROTO_RNDIS)
		return (UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO);
a1362 4
	usb_cdc_union_descriptor_t	*ud;
	const usb_descriptor_t		*desc;
	usbd_desc_iter_t		 iter;
	int				 if_ctl, if_data;
d1374 2
a1375 5
	sc->sc_iface_ctl = uaa->iface;
	id = usbd_get_interface_descriptor(sc->sc_iface_ctl);
	if_ctl = id->bInterfaceNumber;
	sc->sc_ifaceno_ctl = if_ctl;
	if_data = -1;
d1377 3
a1379 2
	usb_desc_iter_init(sc->sc_udev, &iter);
	while ((desc = usb_desc_iter_next(&iter)) != NULL) {
d1381 3
a1383 9
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			continue;
		}
		switch (desc->bDescriptorSubtype) {
		case UDESCSUB_CDC_UNION:
			ud = (usb_cdc_union_descriptor_t *)desc;
			/* XXX bail out when found first? */
			if (if_data == -1)
				if_data = ud->bSlaveInterface[0];
a1384 17
		}
	}

	if (if_data == -1) {
		DPRINTF(("urndis_attach: no union interface\n"));
		sc->sc_iface_data = sc->sc_iface_ctl;
	} else {
		DPRINTF(("urndis_attach: union interface: ctl %u, data %u\n",
		    if_ctl, if_data));
		for (i = 0; i < uaa->nifaces; i++) {
			if (usbd_iface_claimed(sc->sc_udev, i))
				continue;
			id = usbd_get_interface_descriptor(uaa->ifaces[i]);
			if (id && id->bInterfaceNumber == if_data) {
				sc->sc_iface_data = uaa->ifaces[i];
				usbd_claim_iface(sc->sc_udev, i);
			}
@


1.32
log
@this works on the galaxy s2 too.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.31 2011/07/03 15:47:17 matthew Exp $ */
d140 2
a141 1
	{ USB_VENDOR_SAMSUNG2,	USB_PRODUCT_SAMSUNG2_ANDROID2 }
@


1.31
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.30 2011/05/05 17:00:43 sthen Exp $ */
d139 2
a140 1
	{ USB_VENDOR_SAMSUNG2,	USB_PRODUCT_SAMSUNG2_ANDROID }
@


1.30
log
@Attach to Samsung Galaxy S, from Erik Mugele. ok jsg@@ mk@@

It may be possible to use better heuristics to detect compatible devices
(Linux driver appears to hand over from CDC to urndis) which would avoid
listing IDs, but this gets tethering working on this phone for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.29 2011/01/25 20:03:35 jakemsr Exp $ */
a1554 3
	case DVACT_ACTIVATE:
		break;

@


1.29
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.28 2011/01/16 22:35:29 jakemsr Exp $ */
d138 2
a139 1
	{ USB_VENDOR_HTC,	USB_PRODUCT_HTC_ANDROID }
@


1.28
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.27 2010/10/27 17:51:11 jakemsr Exp $ */
a1511 2

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);
a1541 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.27
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.26 2010/09/24 08:33:59 yuo Exp $ */
d1392 1
a1392 1
			if (uaa->ifaces[i] == NULL)
d1397 1
a1397 1
				uaa->ifaces[i] = NULL;
@


1.26
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.25 2010/07/31 11:51:45 mk Exp $ */
d1535 4
a1538 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.25
log
@The code referencing urndis_watchdog() is #if 0'd out, but the actual
function is not.

This change #if 0's urndis_watchdog() and some functions that are only
called from here.

At some point we probably want to use the watchdog functionality but the
current code is completely untested so disable it entirely rather than
enabling it this close to release.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.24 2010/07/31 10:59:37 mk Exp $ */
a1523 1
	s = splusb();
d1528 1
a1528 2
	if (!sc->sc_attached) {
		splx(s);
a1529 1
	}
d1531 1
a1531 1
	sc->sc_dying = 1;
@


1.24
log
@Break some really long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.23 2010/07/14 20:44:17 mk Exp $ */
d75 1
d77 1
d109 1
d112 1
d652 1
d737 1
d1034 1
d1050 1
@


1.23
log
@In urndis_decap(), delay the memcpy() for as long as possible.  There is
no point in copying before having done the final sanity check (we copied
before the last one).

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.22 2010/07/14 20:21:55 mk Exp $ */
d253 2
a254 1
urndis_ctrl_handle_init(struct urndis_softc *sc, const struct urndis_comp_hdr *hdr)
d596 5
a600 2
urndis_ctrl_set_param(struct urndis_softc *sc, const char *name, u_int32_t type,
    void *buf, size_t len)
d1209 3
a1211 1
urndis_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1251 3
a1253 1
urndis_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1562 1
@


1.22
log
@urndis_newbuf() is only called with NULL as it's third argument so just
get rid of it.

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.21 2010/06/06 17:53:31 miod Exp $ */
d853 1
a853 6
		memcpy(mtod(m, char*),
		    ((char*)&msg->rm_dataoffset + letoh32(msg->rm_dataoffset)),
		    letoh32(msg->rm_datalen));
		m->m_pkthdr.len = m->m_len = letoh32(msg->rm_datalen);

		if (m->m_len < sizeof(struct ether_header)) {
d858 1
a858 1
			    m->m_len,
d862 6
@


1.21
log
@Use usb_lookup() instead of rolling our own. ok armani@@ fabien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.20 2010/04/05 08:11:34 armani Exp $ */
d72 1
a72 1
int urndis_newbuf(struct urndis_softc *, struct urndis_chain *, struct mbuf *);
d872 1
a872 1
		if (urndis_newbuf(sc, c, NULL) == ENOBUFS) {
d892 1
a892 1
urndis_newbuf(struct urndis_softc *sc, struct urndis_chain *c, struct mbuf *m)
d896 12
a907 21
	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n",
			    DEVNAME(sc));
			return (ENOBUFS);
		}
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n",
			    DEVNAME(sc));
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
d909 1
d929 1
a929 1
		if (urndis_newbuf(sc, c, NULL) == ENOBUFS)
@


1.20
log
@Remove a useless usbd_get_interface_descriptor.

"iff you commit over the Hero" mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.19 2010/03/25 19:39:34 mk Exp $ */
d133 2
a134 5
struct urndis_type {
	u_int16_t	urndis_vid;
	u_int16_t	urndis_pid;
} urndis_devs[] = {
	{ USB_VENDOR_HTC,	USB_PRODUCT_HTC_ANDROID },
a1310 1
	int				 i;
d1326 2
a1327 11
	for (i = 0; i < sizeof(urndis_devs) / sizeof(urndis_devs[0]); i++) {
		struct urndis_type *t;

		t = &urndis_devs[i];

		if (uaa->vendor == t->urndis_vid &&
		    uaa->product == t->urndis_pid)
			return UMATCH_VENDOR_PRODUCT;
	}

	return (UMATCH_NONE);
@


1.19
log
@Update to match renamed product id.

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.18 2010/03/15 11:13:40 fabien Exp $ */
a1409 2

	id = usbd_get_interface_descriptor(sc->sc_iface_ctl);
@


1.18
log
@Correct return from attach on error, add splx() and urndis_stop().
This fix a crash on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.17 2010/03/14 22:50:41 mk Exp $ */
d137 1
a137 1
	{ USB_VENDOR_HTC,	USB_PRODUCT_HTC_HERO },
@


1.17
log
@Rewrite urndis_match() logic for the HTC Hero to match on vendor and
product ID.  The former code was a bit promiscuous and would attempt to
attach urndis(4) to e.g. E71 (as noticed by jmc) and then fail.

ok fabien armani deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.16 2010/03/11 10:23:08 armani Exp $ */
d1482 2
d1495 1
d1498 1
a1498 1
	
d1507 1
@


1.16
log
@Correct a wrong printf and move a check than should be before the debug.
Found when looking at ckuethe problem.

with and ok fabien@@, "definitivly" mk@@, "that diff can go in" kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.15 2010/03/07 17:17:33 mk Exp $ */
d130 10
d1314 1
d1330 4
a1333 4
	/* XXX Hack for HTC Hero for now */
	if (id->bInterfaceClass == UICLASS_CDC &&
	    id->bInterfaceSubClass == UISUBCLASS_ABSTRACT_CONTROL_MODEL)
		return (UMATCH_IFACECLASS_GENERIC);
d1335 4
@


1.15
log
@Garbage collect a softc member that we don't use because we don't do
multipacket tx.

ok fabien "if you commit over urndis" armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.14 2010/03/07 16:20:32 fabien Exp $ */
d787 9
a807 8
		if (len < sizeof(*msg)) {
			printf("%s: urndis_decap invalid buffer len %u < "
			    "minimum header %u\n",
			    DEVNAME(sc),
			    letoh32(msg->rm_len),
			    sizeof(*msg));
			return;
		}
@


1.14
log
@Update my address, while there update armani's too per his request.

ok armani, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.13 2010/03/07 16:06:29 fabien Exp $ */
a292 1
	sc->sc_pktalign = letoh32(msg->rm_align);
@


1.13
log
@Rename RNDIS_DEBUG to match device name.
Now option to debug is URNDIS_DEBUG.

ok mk, armani.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.12 2010/03/07 16:03:29 mk Exp $ */
d4 2
a5 2
 * Copyright (c) 2010 Jonathan Armani <dbd@@asystant.net>
 * Copyright (c) 2010 Fabien Romano <fromano@@asystant.net>
@


1.12
log
@Some cleanup and dead code removal to bring us in line with other
usb ethernet drivers.

ok armani
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.11 2010/03/07 14:43:06 mk Exp $ */
d64 1
a64 1
#ifdef RNDIS_DEBUG
@


1.11
log
@We're only sending one packet at a time, so garbage collect sc_lim_pktcnt
that shows how many packets the device will accept in one transfer.

ok armani fabien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.10 2010/03/06 15:43:31 armani Exp $ */
d786 1
a786 1
		    (int)len));
d1223 4
a1226 5
#if 0
		if (sc->sc_rxeof_errors == 0)
			printf("%s: usb error on rx: %s\n", DEVNAME(sc),
			    usbd_errstr(status));
#endif
a1229 9
#if 0
		DELAY(sc->sc_rxeof_errors * 10000);
		if (sc->sc_rxeof_errors++ > 10) {
			printf("%s: too many errors, disabling\n",
			    DEVNAME(sc));
			sc->sc_dying = 1;
			return;
		}
#endif
a1232 4
#if 0
	sc->sc_rxeof_errors = 0;
#endif

d1447 13
a1492 16
	
	
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;
	ifp->if_start = urndis_start;
	ifp->if_ioctl = urndis_ioctl;
#if 0
	ifp->if_watchdog = urndis_watchdog;
#endif

	strlcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);

	IFQ_SET_READY(&ifp->if_snd);
@


1.10
log
@Add a flag to know if the interface successfully attached like
other drivers do otherwise we panic trying to remove an unexistent
ifp during detach.

looks good to fabien@@, with comments from mk@@, ok mk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.9 2010/03/05 18:20:50 armani Exp $ */
a291 1
	sc->sc_lim_pktcnt = letoh32(msg->rm_pktmaxcnt);
@


1.9
log
@Correct a wrong printf message, from fabien, ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.8 2010/03/04 20:23:45 armani Exp $ */
d1479 1
d1490 1
d1514 1
d1533 5
d1547 1
@


1.8
log
@Add defines for header and data offset, offsetof() uses from mk@@.

ok mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.7 2010/03/03 23:37:01 mk Exp $ */
d697 1
a697 1
	DPRINTF(("%s: urndis_ctrl_reset send: type %u len %u rid %u\n",
@


1.7
log
@Change third parameter for urndis_decap() to be of type u_int32_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.6 2010/03/03 23:26:56 mk Exp $ */
d328 1
a328 1
	/* XXX : 8 -> rid offset in struct */
d330 1
a330 1
	    8 > letoh32(msg->rm_len)) {
d338 1
a338 1
		    letoh32(msg->rm_infobufoffset) + 8,
d739 1
a739 2
	/* XXX : 36 -> dataoffset corresponding in this struct */
	msg->rm_dataoffset = htole32(36);
a741 1
	/* XXX : 8 -> dataoffset offset in struct */
d743 1
a743 1
	    ((char*)msg + 36 + 8));
d831 1
a831 1
		/* XXX : 8 -> dataoffset offset in struct */
d833 2
a834 1
		    letoh32(msg->rm_datalen) + 8 > letoh32(msg->rm_len)) {
d842 1
a842 1
			    letoh32(msg->rm_datalen) + 8,
@


1.6
log
@In urndis_ctrl_recv(), don't copy the received data to a newly allocated
buffer of the exact response when we can just pass on the buffer.  It's
going to be released right away anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.5 2010/03/03 19:01:03 mk Exp $ */
d111 1
a111 1
void urndis_decap(struct urndis_softc *, struct urndis_chain *, size_t);
d773 1
a773 1
urndis_decap(struct urndis_softc *sc, struct urndis_chain *c, size_t len)
d1212 1
a1212 1
	size_t			 total_len;
d1249 1
a1249 1
	usbd_get_xfer_status(xfer, NULL, NULL, (u_int32_t*)&total_len, NULL);
@


1.5
log
@When I first started on urndis, I didn't realise that all values were
u_int32_ts, so I made some typedefs for certain types.  It's just
pointless, so get rid of them.

Jonathan and Fabien agree.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.4 2010/03/03 18:44:30 mk Exp $ */
d165 2
a166 2
#define RNDIS_RESPONSE_LEN 0x400 /* XXX seriously? */
	struct urndis_comp_hdr	*hdr, *pkt;
d200 1
a200 16
	if (letoh32(hdr->rm_len) < 128) {
		pkt = malloc(letoh32(hdr->rm_len),
		    M_TEMP, M_WAITOK | M_CANFAIL);
		if (pkt == NULL) {
			printf("%s: out of memory\n", DEVNAME(sc));
			/* XXX just use buf? */
			free(buf, M_TEMP);
		} else {
			memcpy(pkt, hdr, letoh32(hdr->rm_len));
			free(buf, M_TEMP);
		}
	} else {
		pkt = hdr;
	}

	return pkt;
@


1.4
log
@Remove XXX that's no longer valid.

From Jonathan Armani.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.3 2010/03/02 20:54:27 mk Exp $ */
d91 1
a91 1
urndis_status urndis_ctrl_handle(struct urndis_softc *,
d93 1
a93 1
urndis_status urndis_ctrl_handle_init(struct urndis_softc *,
d95 1
a95 1
urndis_status urndis_ctrl_handle_query(struct urndis_softc *,
d97 1
a97 1
urndis_status urndis_ctrl_handle_reset(struct urndis_softc *,
d100 3
a102 3
urndis_status urndis_ctrl_init(struct urndis_softc *);
urndis_status urndis_ctrl_halt(struct urndis_softc *);
urndis_status urndis_ctrl_query(struct urndis_softc *, urndis_oid, void *, size_t,
d104 2
a105 2
urndis_status urndis_ctrl_set(struct urndis_softc *, urndis_oid, void *, size_t);
urndis_status urndis_ctrl_set_param(struct urndis_softc *, const char *, u_int32_t,
d107 2
a108 2
urndis_status urndis_ctrl_reset(struct urndis_softc *);
urndis_status urndis_ctrl_keepalive(struct urndis_softc *);
d218 1
a218 1
urndis_status
d222 1
a222 1
	urndis_status rval;
d260 1
a260 1
urndis_status
d314 1
a314 1
urndis_status
d377 1
a377 1
urndis_status
d382 1
a382 1
	urndis_status			 rval;
d416 1
a416 1
urndis_status
d420 1
a420 1
	urndis_status		 rval;
d463 1
a463 1
urndis_status
d467 1
a467 1
	urndis_status		 rval;
d494 2
a495 2
urndis_status
urndis_ctrl_query(struct urndis_softc *sc, urndis_oid oid,
d500 1
a500 1
	urndis_status		 rval;
d549 2
a550 2
urndis_status
urndis_ctrl_set(struct urndis_softc *sc, urndis_oid oid, void *buf, size_t len)
d553 1
a553 1
	urndis_status		 rval;
d604 1
a604 1
urndis_status
d609 1
a609 1
	urndis_status			 rval;
d655 1
a655 1
urndis_status
d659 1
a659 1
	urndis_status			 rval;
d695 1
a695 1
urndis_status
d699 1
a699 1
	urndis_status			 rval;
@


1.3
log
@Rename sc_sc to sc_softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.2 2010/03/02 20:27:25 mk Exp $ */
a786 1
/* XXX draft, must implement Multi-Packets Transfer ... :( */
@


1.2
log
@Get rid of the code that deals with the interrupt pipe.  The current
code doesn't do anything at the moment, so no point in keeping it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_urndis.c,v 1.1 2010/03/01 23:35:56 mk Exp $ */
d945 1
a945 1
		c->sc_sc = sc;
d975 1
a975 1
		c->sc_sc = sc;
d1231 1
a1231 1
	sc = c->sc_sc;
d1286 1
a1286 1
	sc = c->sc_sc;
@


1.1
log
@Add urndis(4), a driver for RNDIS Ethernet over USB.

It provides an Ethernet transport typically over EDGE or 3G on
cellphones similar to what cdce(4) does on other phones.  It is
likely to work with most of HTC's recent and coming Android based
phones but a bunch of other things (phones in particular) may use
it.

Started by me; brought to a working state by Jonathan Armani and
Fabien Romano over the past week, with some input and additions
from me.

Tested on i386 and macppc by me (HTC Hero), amd64 by Jonathan and
Fabien (HTC Hero), and by gilles@@ (HTC Magic) on i386 or amd64.

It still has a few kinks to work out, but it works well enough that
I can commit this over my HTC Hero.

`commit it!' deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a73 1
void urndis_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
a990 39
void
urndis_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
{
	struct urndis_softc	*sc;
	u_int32_t		 count;

	sc = (struct urndis_softc *)priv;

	if (status == USBD_CANCELLED || sc->sc_dying)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("urndis_intr: status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);

	if (count != sizeof(sc->sc_intr_buf)) {
		printf("%s: intr input failure: %u bytes\n", DEVNAME(sc),
		    count);
		return;
	}

	sc->sc_intr_buf.notification = UGETDW(&sc->sc_intr_buf.notification);
	switch (sc->sc_intr_buf.notification) {
		case 0x1:
			DPRINTF(("%s: RESPONSE_AVAILABLE\n", DEVNAME(sc)));
			break;

		default:
			printf("%s: intr input failure: notification 0x%04x\n",
			    DEVNAME(sc), sc->sc_intr_buf.notification);
			break;
	}
}

a1074 17
	if (sc->sc_intr_no != -1 && sc->sc_intr_pipe == NULL) {
		usbd_status err;

		DPRINTF(("urndis_init: establish interrupt pipe\n"));
		err = usbd_open_pipe_intr(sc->sc_iface_ctl,
		    sc->sc_intr_no,
		    USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc,
		    &sc->sc_intr_buf, sizeof(sc->sc_intr_buf),
		    urndis_intr, USBD_DEFAULT_INTERVAL);
		if (err) {
			printf("%s: open interrupt pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
			splx(s);
			return;
		}
	}

a1158 12
	if (sc->sc_intr_pipe != NULL) {
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			    DEVNAME(sc), usbd_errstr(err));
		sc->sc_intr_pipe = NULL;
	}

a1428 17
	sc->sc_intr_no = -1;
	for (i = 0; i < id->bNumEndpoints && sc->sc_intr_no == -1; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface_ctl, i);
		if (!ed) {
			printf("%s: no descriptor for interrupt endpoint %u\n",
			    DEVNAME(sc));
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_no = ed->bEndpointAddress;
			break;
		}
	}
	DPRINTF(("%s: found intr endpoint %u\n", DEVNAME(sc),
	    sc->sc_intr_no));
d1463 1
a1463 1
			DPRINTF(("%s: intr=0x%x, in=0x%x, out=0x%x\n",
d1465 1
a1465 1
			    sc->sc_intr_no, sc->sc_bulkin_no,
@

