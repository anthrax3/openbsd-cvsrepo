head	1.32;
access;
symbols
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.32
date	2017.01.09.14.44.28;	author mpi;	state Exp;
branches;
next	1.31;
commitid	UdDbQS8WFHHpnq1k;

1.31
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.30;
commitid	15xZY6veDWwRM6Iq;

1.30
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.29;
commitid	KAeCDAijcgEnOtfF;

1.29
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.28;
commitid	kI4H556ZKYkRQGw5;

1.28
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.27;
commitid	L2P5oN9ppxqXZsYS;

1.27
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.19.08.59.37;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2013.09.28.11.22.09;	author sasano;	state Exp;
branches;
next	1.23;

1.23
date	2013.05.08.08.26.25;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.08.01.06.34;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.04.21.55.56;	author sthen;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.04.12.22.14;	author sthen;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.20.14.37.38;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.20.14.37.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.16.04.44.26;	author yuo;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.15.16.20.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.15.16.02.11;	author yuo;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.15.09.42.51;	author yuo;	state Exp;
branches;
next	1.8;

1.8
date	2010.02.18.23.34.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2010.02.17.14.06.10;	author yuo;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.03.18.43.02;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.12.17.08.28.03;	author yuo;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.10.04.44.27;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.29.17.32.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2009.11.24.08.28.53;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.23.19.35.54;	author yuo;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Remove unneeded <sys/malloc.h> from Michael W. Bombardieri.
@
text
@/*	$OpenBSD: uthum.c,v 1.31 2016/03/19 11:34:22 mpi Exp $   */

/*
 * Copyright (c) 2009, 2010 Yojiro UO <yuo@@nui.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for HID base TEMPer seriese Temperature(/Humidity) sensors */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/sensors.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>

#ifdef UTHUM_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

/* Device types */
#define UTHUM_TYPE_TEMPERHUM	0x535a
#define UTHUM_TYPE_TEMPERHUM_2	0x575a /* alternative TEMPerHUM */
#define UTHUM_TYPE_TEMPER1	0x5758 /* TEMPer1 and HID TEMPer */
#define UTHUM_TYPE_TEMPER2	0x5759
#define UTHUM_TYPE_TEMPERNTC	0x575b
#define UTHUM_TYPE_UNKNOWN	0xffff

/* Common */
#define UTHUM_CAL_OFFSET	0x14
#define UTHUM_MAX_SENSORS	2
#define CMD_DEVTYPE		0x52
#define DEVTYPE_EOF		0x53

/* query commands */
#define CMD_GETDATA_NTC		0x41 /* TEMPerNTC NTC part */
#define CMD_RESET0		0x43 /* TEMPer, TEMPer[12], TEMPerNTC */
#define CMD_RESET1		0x44 /* TEMPer, TEMPer[12] */
#define CMD_GETDATA		0x48 /* TEMPerHUM */
#define CMD_GETDATA_OUTER	0x53 /* TEMPer, TEMPer[12], TEMPerNTC */
#define CMD_GETDATA_INNER	0x54 /* TEMPer, TEMPer[12], TEMPerNTC */
#define CMD_GETDATA_EOF		0x31
#define CMD_GETDATA_EOF2	0xaa

/* temperntc mode */
#define TEMPERNTC_MODE_BASE	0x61 /* 0x61 - 0x68 */
#define TEMPERNTC_MODE_MAX	0x68
#define CMD_TEMPERNTC_MODE_DONE	0x69
#define UTHUM_NTC_MIN_THRESHOLD	0xb300
#define UTHUM_NTC_MAX_THRESHOLD	0xf200

/* sensor name */
#define UTHUM_TEMPER_INNER	0
#define UTHUM_TEMPER_OUTER	1
#define UTHUM_TEMPER_NTC	1
#define UTHUM_TEMPERHUM_TEMP	0
#define UTHUM_TEMPERHUM_HUM	1

enum uthum_sensor_type {
	UTHUM_SENSOR_UNKNOWN,
	UTHUM_SENSOR_SHT1X,
	UTHUM_SENSOR_DS75,
	UTHUM_SENSOR_NTC,
	UTHUM_SENSOR_MAXTYPES,
};

static const char * const uthum_sensor_type_s[UTHUM_SENSOR_MAXTYPES] = {
	"unknown",
	"sht1x",
	"ds75/12bit",
	"NTC"
};

static uint8_t cmd_issue[8] =
	{ 0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x02, 0x00 };
static uint8_t cmd_query[8] =
	{ 0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x01, 0x00 };

struct uthum_sensor {
	struct ksensor sensor;
	int cal_offset;	/* mC or m%RH */
	int attached;
	enum uthum_sensor_type dev_type;
	int cur_state;	/* for TEMPerNTC */
};

struct uthum_softc {
	struct uhidev		 sc_hdev;
	struct usbd_device	*sc_udev;
	int			 sc_device_type;
	int			 sc_num_sensors;

	/* uhidev parameters */
	size_t			 sc_flen;	/* feature report length */
	size_t			 sc_ilen;	/* input report length */
	size_t			 sc_olen;	/* output report length */

	/* sensor framework */
	struct uthum_sensor	 sc_sensor[UTHUM_MAX_SENSORS];
	struct ksensordev	 sc_sensordev;
	struct sensor_task	*sc_sensortask;
};

const struct usb_devno uthum_devs[] = {
	/* XXX: various TEMPer variants are using same VID/PID */
	{ USB_VENDOR_TENX, USB_PRODUCT_TENX_TEMPER},
};
#define uthum_lookup(v, p) usb_lookup(uthum_devs, v, p)

int  uthum_match(struct device *, void *, void *);
void uthum_attach(struct device *, struct device *, void *);
int  uthum_detach(struct device *, int);

int  uthum_issue_cmd(struct uthum_softc *, uint8_t, int);
int  uthum_read_data(struct uthum_softc *, uint8_t, uint8_t *, size_t, int);
int  uthum_check_device_info(struct uthum_softc *);
void uthum_reset_device(struct uthum_softc *);
void uthum_setup_sensors(struct uthum_softc *);

void uthum_intr(struct uhidev *, void *, u_int);
void uthum_refresh(void *);
void uthum_refresh_temper(struct uthum_softc *, int);
void uthum_refresh_temperhum(struct uthum_softc *);
void uthum_refresh_temperntc(struct uthum_softc *, int);

int  uthum_ntc_getdata(struct uthum_softc *, int *);
int  uthum_ntc_tuning(struct uthum_softc *, int, int *);
int64_t uthum_ntc_temp(int64_t, int);
int  uthum_sht1x_temp(uint8_t, uint8_t);
int  uthum_sht1x_rh(uint8_t, uint8_t, int);
int  uthum_ds75_temp(uint8_t, uint8_t);
void uthum_print_sensorinfo(struct uthum_softc *, int);

struct cfdriver uthum_cd = {
	NULL, "uthum", DV_DULL
};

const struct cfattach uthum_ca = {
	sizeof(struct uthum_softc),
	uthum_match,
	uthum_attach,
	uthum_detach
};

int
uthum_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;

	if (uha->reportid == UHIDEV_CLAIM_ALLREPORTID)
		return (UMATCH_NONE);

	if (uthum_lookup(uha->uaa->vendor, uha->uaa->product) == NULL)
		return UMATCH_NONE;

#if 0 /* attach only sensor part of HID as uthum* */
#define HUG_UNKNOWN_3	0x0003
	void *desc;
	int size;
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_UNKNOWN_3)))
		return (UMATCH_NONE);
#undef HUG_UNKNOWN_3
#endif

	return (UMATCH_VENDOR_PRODUCT);
}

void
uthum_attach(struct device *parent, struct device *self, void *aux)
{
	struct uthum_softc *sc = (struct uthum_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct usbd_device *dev = uha->parent->sc_udev;
	int i, size, repid;
	void *desc;

	sc->sc_udev = dev;
	sc->sc_hdev.sc_intr = uthum_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;
	sc->sc_num_sensors = 0;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_ilen = hid_report_size(desc, size, hid_input, repid);
	sc->sc_olen = hid_report_size(desc, size, hid_output, repid);
	sc->sc_flen = hid_report_size(desc, size, hid_feature, repid);

	printf("\n");

	if (sc->sc_flen < 32) {
		/* not sensor interface, just attach */
		return;
	}

	/* maybe unsupported device */
	if (uthum_check_device_info(sc) < 0) {
		DPRINTF(("uthum: unknown device\n"));
		return;
	};

	/* attach sensor */
	strlcpy(sc->sc_sensordev.xname, sc->sc_hdev.sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	uthum_setup_sensors(sc);

	/* attach sensors */
	for (i = 0; i < UTHUM_MAX_SENSORS; i++) {
		if (sc->sc_sensor[i].dev_type == UTHUM_SENSOR_UNKNOWN)
			continue;
		uthum_print_sensorinfo(sc, i);
		sc->sc_sensor[i].sensor.flags |= SENSOR_FINVALID;
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[i].sensor);
		sc->sc_sensor[i].attached = 1;
		sc->sc_num_sensors++;
	}

	if (sc->sc_num_sensors > 0) {
		/* 0.1Hz */
		sc->sc_sensortask = sensor_task_register(sc, uthum_refresh, 6);
		if (sc->sc_sensortask == NULL) {
			printf(", unable to register update task\n");
			return;
		}
		sensordev_install(&sc->sc_sensordev);
	}

	DPRINTF(("uthum_attach: complete\n"));
}

int
uthum_detach(struct device *self, int flags)
{
	struct uthum_softc *sc = (struct uthum_softc *)self;
	int i, rv = 0;

	if (sc->sc_num_sensors > 0) {
		wakeup(&sc->sc_sensortask);
		sensordev_deinstall(&sc->sc_sensordev);
		for (i = 0; i < UTHUM_MAX_SENSORS; i++) {
			if (sc->sc_sensor[i].attached)
				sensor_detach(&sc->sc_sensordev,
					&sc->sc_sensor[i].sensor);
		}
		if (sc->sc_sensortask != NULL)
			sensor_task_unregister(sc->sc_sensortask);
	}

	uthum_reset_device(sc);

	return (rv);
}

void
uthum_intr(struct uhidev *addr, void *ibuf, u_int len)
{
	/* do nothing */
}

int
uthum_issue_cmd(struct uthum_softc *sc, uint8_t target_cmd, int delay)
{
	uint8_t cmdbuf[32];
	int i, actlen;

	bzero(cmdbuf, sizeof(cmdbuf));
	memcpy(cmdbuf, cmd_issue, sizeof(cmd_issue));
	actlen = uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen);
	if (actlen != sc->sc_olen)
		return EIO;

	bzero(cmdbuf, sizeof(cmdbuf));
	cmdbuf[0] = target_cmd;
	actlen = uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen);
	if (actlen != sc->sc_olen)
		return EIO;

	bzero(cmdbuf, sizeof(cmdbuf));
	for (i = 0; i < 7; i++) {
		actlen = uhidev_set_report(sc->sc_hdev.sc_parent,
		    UHID_OUTPUT_REPORT, sc->sc_hdev.sc_report_id, cmdbuf,
		    sc->sc_olen);
		if (actlen != sc->sc_olen)
			return EIO;
	}

	/* wait if required */
	if (delay > 0)
		tsleep(&sc->sc_sensortask, 0, "uthum", (delay*hz+999)/1000 + 1);

	return 0;
}

int
uthum_read_data(struct uthum_softc *sc, uint8_t target_cmd, uint8_t *buf,
	size_t len, int delay)
{
	uint8_t cmdbuf[32], report[256];

	/* if return buffer is null, do nothing */
	if ((buf == NULL) || len == 0)
		return 0;

	if (uthum_issue_cmd(sc, target_cmd, 50))
		return 0;

	bzero(cmdbuf, sizeof(cmdbuf));
	memcpy(cmdbuf, cmd_query, sizeof(cmd_query));
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen) != sc->sc_olen)
		return EIO;

	/* wait if required */
	if (delay > 0)
		tsleep(&sc->sc_sensortask, 0, "uthum", (delay*hz+999)/1000 + 1);

	/* get answer */
	if (uhidev_get_report(sc->sc_hdev.sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, report, sc->sc_flen) != sc->sc_flen)
		return EIO;
	memcpy(buf, report, len);
	return 0;
}

int
uthum_check_device_info(struct uthum_softc *sc)
{
	struct uthum_dev_info {
		uint16_t dev_type;
		uint8_t	 cal[2][2];  /* calibration offsets */
		uint8_t  footer;
		uint8_t  padding[25];
	} dinfo;
	int val, dev_type;
	int retry = 3;

	/* issue query to device */
	while (retry) {
		if (uthum_read_data(sc, CMD_DEVTYPE, (void *)&dinfo,
		    sizeof(struct uthum_dev_info), 0) != 0) {
			DPRINTF(("uthum: device information query fail.\n"));
			retry--;
			continue;
		}
		if (dinfo.footer !=  DEVTYPE_EOF) {
			/* it will be a bogus entry, retry. */
			retry--;
		} else
			break;
	}

	if (retry <= 0)
		return EIO;

	dev_type = betoh16(dinfo.dev_type);
	/* TEMPerHUM has 2 different device identifiers, unify them */
	if (dev_type == UTHUM_TYPE_TEMPERHUM_2)
		dev_type = UTHUM_TYPE_TEMPERHUM;

	/* check device type and calibration offset*/
	switch (dev_type) {
	case UTHUM_TYPE_TEMPER2:
	case UTHUM_TYPE_TEMPERHUM:
	case UTHUM_TYPE_TEMPERNTC:
		val = (dinfo.cal[1][0] - UTHUM_CAL_OFFSET) * 100;
		val += dinfo.cal[1][1] * 10;
		sc->sc_sensor[1].cal_offset = val;
		/* fall down, don't break */
	case UTHUM_TYPE_TEMPER1:
		val = (dinfo.cal[0][0] - UTHUM_CAL_OFFSET) * 100;
		val += dinfo.cal[0][1] * 10;
		sc->sc_sensor[0].cal_offset = val;
		sc->sc_device_type = dev_type;
		break;
	default:
		sc->sc_device_type = UTHUM_TYPE_UNKNOWN;
		printf("uthum: unknown device (devtype = 0x%.2x)\n",
		    dev_type);
		return EIO;
	}

	/* device specific init process */
	switch (dev_type) {
	case UTHUM_TYPE_TEMPERHUM:
		sc->sc_sensor[UTHUM_TEMPER_NTC].cur_state = 0;
		break;
	};

	uthum_reset_device(sc);

	return 0;
};

void
uthum_reset_device(struct uthum_softc *sc)
{
	switch (sc->sc_device_type) {
	case UTHUM_TYPE_TEMPER1:
	case UTHUM_TYPE_TEMPERNTC:
		uthum_issue_cmd(sc, CMD_RESET0, 200);
		break;
	case UTHUM_TYPE_TEMPER2:
		uthum_issue_cmd(sc, CMD_RESET0, 200);
		uthum_issue_cmd(sc, CMD_RESET1, 200);
		break;
	}
}

void
uthum_setup_sensors(struct uthum_softc *sc)
{
	int i;

	for (i = 0; i < UTHUM_MAX_SENSORS; i++)
		sc->sc_sensor[i].dev_type = UTHUM_SENSOR_UNKNOWN;

	switch (sc->sc_device_type) {
	case UTHUM_TYPE_TEMPER2:	/* 2 temperature sensors */
		sc->sc_sensor[UTHUM_TEMPER_OUTER].dev_type =
		    UTHUM_SENSOR_DS75;
		sc->sc_sensor[UTHUM_TEMPER_OUTER].sensor.type =
		    SENSOR_TEMP;
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_OUTER].sensor.desc,
		    "outer",
		    sizeof(sc->sc_sensor[UTHUM_TEMPER_OUTER].sensor.desc));
		/* fall down */
	case UTHUM_TYPE_TEMPER1:	/* 1 temperature sensor */
		sc->sc_sensor[UTHUM_TEMPER_INNER].dev_type =
		    UTHUM_SENSOR_DS75;
		sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.type =
		    SENSOR_TEMP;
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc,
		    "inner",
		    sizeof(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc));
		break;
	case UTHUM_TYPE_TEMPERHUM:
		/* 1 temperature sensor and 1 humidity sensor */
		for (i = 0; i < 2; i++)
			sc->sc_sensor[i].dev_type = UTHUM_SENSOR_SHT1X;
		sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].sensor.type = SENSOR_TEMP;
		sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.type =
		    SENSOR_HUMIDITY;
		strlcpy(sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.desc,
		    "RH",
		    sizeof(sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.desc));
		break;
	case UTHUM_TYPE_TEMPERNTC:
		/* 2 temperature sensors */
		for (i = 0; i < 2; i++)
			sc->sc_sensor[i].sensor.type = SENSOR_TEMP;
		sc->sc_sensor[UTHUM_TEMPER_INNER].dev_type =
		    UTHUM_SENSOR_DS75;
		sc->sc_sensor[UTHUM_TEMPER_NTC].dev_type =
		    UTHUM_SENSOR_NTC;
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc,
		    "inner",
		    sizeof(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc));
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_NTC].sensor.desc,
		    "outer/ntc",
		    sizeof(sc->sc_sensor[UTHUM_TEMPER_NTC].sensor.desc));

		/* sensor state tuning */
		for (i = 0; i < 4; i++)
			uthum_issue_cmd(sc, TEMPERNTC_MODE_BASE, 50);
		sc->sc_sensor[UTHUM_TEMPER_NTC].cur_state = TEMPERNTC_MODE_BASE;
		if (uthum_ntc_tuning(sc, UTHUM_TEMPER_NTC, NULL))
			DPRINTF(("uthum: NTC sensor tuning failed\n"));
		uthum_issue_cmd(sc, CMD_TEMPERNTC_MODE_DONE, 100);
		break;
	default:
		/* do nothing */
		break;
	}
}

int
uthum_ntc_getdata(struct uthum_softc *sc, int *val)
{
	uint8_t buf[8];

	if (val == NULL)
		return EIO;

	/* get sensor value */
	if (uthum_read_data(sc, CMD_GETDATA_NTC, buf, sizeof(buf), 10) != 0) {
		DPRINTF(("uthum: data read fail\n"));
		return EIO;
	}

	/* check data integrity */
	if (buf[2] !=  CMD_GETDATA_EOF2) {
		DPRINTF(("uthum: broken ntc data 0x%.2x 0x%.2x 0x%.2x\n",
		    buf[0], buf[1], buf[2]));
		return EIO;
	}

	*val = (buf[0] << 8) + buf[1];
	return 0;
}

int
uthum_ntc_tuning(struct uthum_softc *sc, int sensor, int *val)
{
	struct uthum_sensor *s;
	int done, state, ostate, curval;
	int retry = 3;

	s = &sc->sc_sensor[sensor];
	state = s->cur_state;

	/* get current sensor value */
	if (val == NULL) {
		while (retry) {
			if (uthum_ntc_getdata(sc, &curval)) {
				retry--;
				continue;
			} else
				break;
		}
		if (retry <= 0)
			return EIO;
	} else {
		curval = *val;
	}

	/* no state change is required */
	if ((curval >= UTHUM_NTC_MIN_THRESHOLD) &&
	    (curval <= UTHUM_NTC_MAX_THRESHOLD)) {
		return 0;
	}

	if (((curval < UTHUM_NTC_MIN_THRESHOLD) &&
	     (state == TEMPERNTC_MODE_MAX)) ||
	    ((curval > UTHUM_NTC_MAX_THRESHOLD) &&
	     (state == TEMPERNTC_MODE_BASE)))
		return 0;

	DPRINTF(("uthum: ntc tuning start. cur state = 0x%.2x, val = 0x%.4x\n",
	    state, curval));

	/* tuning loop */
	ostate = state;
	done = 0;
	while (!done) {
		if (curval < UTHUM_NTC_MIN_THRESHOLD) {
			if (state == TEMPERNTC_MODE_MAX)
				done++;
			else
				state++;
		} else if (curval > UTHUM_NTC_MAX_THRESHOLD) {
			if (state == TEMPERNTC_MODE_BASE)
				done++;
			else
				state--;
		} else {
			uthum_ntc_getdata(sc, &curval);
			if ((curval >= UTHUM_NTC_MIN_THRESHOLD) &&
			    (curval <= UTHUM_NTC_MAX_THRESHOLD))
				done++;
		}

		/* update state */
		if (state != ostate) {
			uthum_issue_cmd(sc, state, 50);
			uthum_issue_cmd(sc, state, 50);
			uthum_ntc_getdata(sc, &curval);
		}
		ostate = state;
	}

	DPRINTF(("uthum: ntc tuning done. state change: 0x%.2x->0x%.2x\n",
	    s->cur_state, state));
	s->cur_state = state;
	if (val != NULL)
		*val = curval;

	return 0;
}

void
uthum_refresh(void *arg)
{
	struct uthum_softc *sc = arg;
	int i;

	switch (sc->sc_device_type) {
	case UTHUM_TYPE_TEMPER1:
	case UTHUM_TYPE_TEMPER2:
	case UTHUM_TYPE_TEMPERNTC:
		for (i = 0; i < sc->sc_num_sensors; i++) {
			if (sc->sc_sensor[i].dev_type == UTHUM_SENSOR_DS75)
				uthum_refresh_temper(sc, i);
			else if (sc->sc_sensor[i].dev_type == UTHUM_SENSOR_NTC)
				uthum_refresh_temperntc(sc, i);
		}
		break;
	case UTHUM_TYPE_TEMPERHUM:
		uthum_refresh_temperhum(sc);
		break;
	default:
		break;
		/* never reach */
	}
}

void
uthum_refresh_temperhum(struct uthum_softc *sc)
{
	uint8_t buf[8];
	int temp, rh;

	if (uthum_read_data(sc, CMD_GETDATA, buf, sizeof(buf), 1000) != 0) {
		DPRINTF(("uthum: data read fail\n"));
		sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].sensor.flags
		    |= SENSOR_FINVALID;
		sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.flags
		    |= SENSOR_FINVALID;
		return;
	}

	temp = uthum_sht1x_temp(buf[0], buf[1]);
	rh = uthum_sht1x_rh(buf[2], buf[3], temp);

	/* apply calibration offsets */
	temp += sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].cal_offset;
	rh += sc->sc_sensor[UTHUM_TEMPERHUM_HUM].cal_offset;

	sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].sensor.value =
	    (temp * 10000) + 273150000;
	sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].sensor.flags &= ~SENSOR_FINVALID;
	sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.value = rh;
	sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.flags &= ~SENSOR_FINVALID;
}

void
uthum_refresh_temper(struct uthum_softc *sc, int sensor)
{
	uint8_t buf[8];
	uint8_t cmd;
	int temp;

	if (sensor == UTHUM_TEMPER_INNER)
		cmd = CMD_GETDATA_INNER;
	else if (sensor == UTHUM_TEMPER_OUTER)
		cmd = CMD_GETDATA_OUTER;
	else
		return;

	/* get sensor value */
	if (uthum_read_data(sc, cmd, buf, sizeof(buf), 1000) != 0) {
		DPRINTF(("uthum: data read fail\n"));
		sc->sc_sensor[sensor].sensor.flags |= SENSOR_FINVALID;
		return;
	}

	/* check integrity */
	if (buf[2] !=  CMD_GETDATA_EOF) {
		DPRINTF(("uthum: broken ds75 data: 0x%.2x 0x%.2x 0x%.2x\n",
		    buf[0], buf[1], buf[2]));
		sc->sc_sensor[sensor].sensor.flags |= SENSOR_FINVALID;
		return;
	}
	temp = uthum_ds75_temp(buf[0], buf[1]);

	/* apply calibration offset */
	temp += sc->sc_sensor[sensor].cal_offset;

	sc->sc_sensor[sensor].sensor.value = (temp * 10000) + 273150000;
	sc->sc_sensor[sensor].sensor.flags &= ~SENSOR_FINVALID;
}

void
uthum_refresh_temperntc(struct uthum_softc *sc, int sensor)
{
	int val;
	int64_t temp;

	/* get sensor data */
	if (uthum_ntc_getdata(sc, &val)) {
		DPRINTF(("uthum: ntc data read fail\n"));
		sc->sc_sensor[sensor].sensor.flags |= SENSOR_FINVALID;
		return;
	}

	/* adjust sensor state */
	if ((val < UTHUM_NTC_MIN_THRESHOLD) ||
	    (val > UTHUM_NTC_MAX_THRESHOLD)) {
		if (uthum_ntc_tuning(sc, UTHUM_TEMPER_NTC, &val)) {
			DPRINTF(("uthum: NTC sensor tuning failed\n"));
			sc->sc_sensor[sensor].sensor.flags |= SENSOR_FINVALID;
			return;
		}
	}

	temp = uthum_ntc_temp(val, sc->sc_sensor[sensor].cur_state);
	if (temp == 0) {
		/* XXX: work around. */
		sc->sc_sensor[sensor].sensor.flags |= SENSOR_FINVALID;
	} else {
		/* apply calibration offset */
		temp += sc->sc_sensor[sensor].cal_offset * 10000;
		sc->sc_sensor[sensor].sensor.value = temp;
		sc->sc_sensor[sensor].sensor.flags &= ~SENSOR_FINVALID;
	}
}

/* return C-degree * 100 value */
int
uthum_ds75_temp(uint8_t msb, uint8_t lsb)
{
	/* DS75: 12bit precision mode : 0.0625 degrees Celsius ticks */
	return (msb * 100) + ((lsb >> 4) * 25 / 4);
}

/* return C-degree * 100 value */
int
uthum_sht1x_temp(uint8_t msb, uint8_t lsb)
{
	int nticks;

	/* sensor device VDD-bias value table
	 * ----------------------------------------------
	 * VDD	2.5V	3.0V	3.5V	4.0V	5.0V
	 * bias	-3940	-3960	-3970	-3980	-4010
	 * ----------------------------------------------
	 *
	 * as the VDD of the SHT10 on my TEMPerHUM is 3.43V +/- 0.05V,
	 * bias -3970 will be best for that device.
	 */

	nticks = (msb * 256 + lsb) & 0x3fff;
	return (nticks - 3970);
}

/* return %RH * 1000 */
int
uthum_sht1x_rh(uint8_t msb, uint8_t lsb, int temp)
{
	int nticks, rh_l;

	nticks = (msb * 256 + lsb) & 0x0fff;
	rh_l = (-40000 + 405 * nticks) - ((7 * nticks * nticks) / 250);

	return ((temp - 2500) * (1 + (nticks >> 7)) + rh_l) / 10;
}

/* return muK */
int64_t
uthum_ntc_temp(int64_t val, int state)
{
	int64_t temp = 0;

	switch (state) {
	case TEMPERNTC_MODE_BASE:	/* 0x61 */
	case TEMPERNTC_MODE_BASE+1:	/* 0x62 */
	case TEMPERNTC_MODE_BASE+2:	/* 0x63 */
	case TEMPERNTC_MODE_BASE+3:	/* 0x64 */
		/* XXX, no data */
		temp = -273150000;
		break;
	case TEMPERNTC_MODE_BASE+4:	/* 0x65 */
		temp = ((val * val * 2977) / 100000) - (val * 4300) + 152450000;
		break;
	case TEMPERNTC_MODE_BASE+5:	/* 0x66 */
		temp = ((val * val * 3887) / 100000) - (val * 5300) + 197590000;
		break;
	case TEMPERNTC_MODE_BASE+6:	/* 0x67 */
		temp = ((val * val * 3495) / 100000) - (val * 5000) + 210590000;
		break;
	case TEMPERNTC_MODE_BASE+7:	/* 0x68 */
		if (val < UTHUM_NTC_MIN_THRESHOLD)
			temp = (val * -1700) + 149630000;
		else
			temp = ((val * val * 3257) / 100000) - (val * 4900) +
			    230470000;
		break;
	default:
		DPRINTF(("NTC state error, unknown state 0x%.2x\n", state));
		break;
	}

	/* convert muC->muK value */
	return temp + 273150000;
}

void
uthum_print_sensorinfo(struct uthum_softc *sc, int num)
{
	struct uthum_sensor *s;
	s = &sc->sc_sensor[num];

	printf("%s: ", sc->sc_hdev.sc_dev.dv_xname);
	switch (s->sensor.type) {
	case SENSOR_TEMP:
		printf("type %s (temperature)",
		    uthum_sensor_type_s[s->dev_type]);
		if (s->cal_offset)
			printf(", calibration offset %c%d.%d degC",
			    (s->cal_offset < 0) ? '-' : '+',
			    abs(s->cal_offset / 100),
			    abs(s->cal_offset % 100));
		break;
	case SENSOR_HUMIDITY:
		printf("type %s (humidity)",
		    uthum_sensor_type_s[s->dev_type]);
		if (s->cal_offset)
			printf("calibration offset %c%d.%d %%RH",
			    (s->cal_offset < 0) ? '-' : '+',
			    abs(s->cal_offset / 100),
			    abs(s->cal_offset % 100));
		break;
	default:
		printf("unknown");
	}
	printf("\n");
}
@


1.31
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.30 2016/01/09 04:14:42 jcs Exp $   */
a23 1
#include <sys/malloc.h>
@


1.30
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.29 2016/01/08 15:54:14 jcs Exp $   */
d745 1
a745 1
	int ticks;
d757 2
a758 2
	ticks = (msb * 256 + lsb) & 0x3fff;
	return (ticks - 3970);
d765 1
a765 1
	int ticks, rh_l;
d767 2
a768 2
	ticks = (msb * 256 + lsb) & 0x0fff;
	rh_l = (-40000 + 405 * ticks) - ((7 * ticks * ticks) / 250);
d770 1
a770 1
	return ((temp - 2500) * (1 + (ticks >> 7)) + rh_l) / 10;
@


1.29
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.28 2014/12/11 18:39:27 mpi Exp $   */
a34 2

#include <dev/hid/hid.h>
@


1.28
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.27 2014/04/15 09:14:27 mpi Exp $   */
d35 2
a36 1
#include <dev/usb/hid.h>
@


1.27
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.26 2014/03/19 08:59:37 mpi Exp $   */
a287 1
	int i;
d289 1
d293 3
a295 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen))
d300 3
a302 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen))
d307 4
a310 2
		if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
		    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen))
d336 2
a337 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, cmdbuf, sc->sc_olen))
d345 2
a346 2
	if (uhidev_get_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, report, sc->sc_flen))
@


1.26
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.25 2014/03/07 18:39:02 mpi Exp $   */
d294 1
a294 1
	    cmdbuf, sc->sc_olen))
d300 1
a300 1
	    cmdbuf, sc->sc_olen))
d306 1
a306 1
		    cmdbuf, sc->sc_olen))
d333 1
a333 1
	    cmdbuf, sc->sc_olen))
d342 1
a342 1
	    report, sc->sc_flen))
@


1.25
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.24 2013/09/28 11:22:09 sasano Exp $   */
d170 4
a173 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
@


1.24
log
@Fix the message of uthum(4)'s calibration offset is incorrect
when the offset is -1 < degC < 0.

ok by yuo@@ and mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.23 2013/05/08 08:26:25 mglocker Exp $   */
a35 4

#ifdef USB_DEBUG
#define UTHUM_DEBUG
#endif
@


1.23
log
@Move reset commands from that attach path to an own function.
Reset device on detach (required for planed usb device claiming).
Tested with my uthum(4) device
"TEMPer sensor(0x660c), Ten X Technology, Inc.(0x1130)".

ok yuo@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.22 2013/05/08 01:06:34 sthen Exp $   */
d823 4
a826 2
			printf(", calibration offset %d.%d degC",
			    s->cal_offset / 100, abs(s->cal_offset % 100));
d832 4
a835 2
			printf("calibration offset %d.%d %%RH",
			    s->cal_offset / 100, abs(s->cal_offset % 100));
@


1.22
log
@re-commit uthum_activate() removal, now that uhidev(4) can handle it.
testing by myself and mglocker@@, ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.21 2013/05/04 21:55:56 sthen Exp $   */
d143 1
d276 2
d409 14
d431 2
a432 7
	case UTHUM_TYPE_TEMPERHUM:
		sc->sc_sensor[UTHUM_TEMPER_NTC].cur_state = 0;
		break;
	};

	return 0;
};
@


1.21
log
@revert uthum_activate removal, it is needed in the detach path as found the
hard way by mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.20 2013/05/04 12:22:14 sthen Exp $   */
a115 1
	u_char			 sc_dying;
a138 1
int  uthum_activate(struct device *, int);
d167 1
a167 2
	uthum_detach,
	uthum_activate
a275 13
}

int
uthum_activate(struct device *self, int act)
{
	struct uthum_softc *sc = (struct uthum_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.20
log
@- remove unused DPRINTFN, simple DPRINTF is enough
- sc_dying is unused, remove it and the uthum_activate() function

suggested by mpi (for ugold, but applicable here too), ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.19 2013/04/15 09:23:02 mglocker Exp $   */
d116 1
d140 1
d169 2
a170 1
	uthum_detach
d279 13
@


1.19
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.18 2013/03/28 03:58:03 tedu Exp $   */
d42 1
a42 2
int	uthumdebug = 0;
#define DPRINTFN(n, x)	do { if (uthumdebug > (n)) printf x; } while (0)
d44 1
a44 1
#define DPRINTFN(n, x)
a46 2
#define DPRINTF(x) DPRINTFN(0, x)

a115 2
	u_char			 sc_dying;
	uint16_t		 sc_flag;
a138 1
int  uthum_activate(struct device *, int);
d167 1
a167 2
	uthum_detach,
	uthum_activate,
a275 13
}

int
uthum_activate(struct device *self, int act)
{
	struct uthum_softc *sc = (struct uthum_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.18
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.17 2011/07/03 15:47:17 matthew Exp $   */
d118 1
a118 1
	usbd_device_handle	 sc_udev;
d206 1
a206 1
	usbd_device_handle dev = uha->parent->sc_udev;
@


1.17
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.16 2011/01/25 20:03:36 jakemsr Exp $   */
a21 1
#include <sys/proc.h>
@


1.16
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.15 2010/09/24 08:33:59 yuo Exp $   */
a291 3
	case DVACT_ACTIVATE:
		break;

@


1.15
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.14 2010/04/20 14:37:38 deraadt Exp $   */
a222 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
a281 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
@


1.14
log
@some misc cleanup of dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.13 2010/04/20 14:37:13 deraadt Exp $   */
a271 2

	sc->sc_dying = 1;
@


1.13
log
@start the sensors off invalid... ok yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.12 2010/04/16 04:44:26 yuo Exp $   */
d516 1
a516 1
		;;
d823 2
a824 2
		;;
	};
d836 2
a837 2
	printf("%s: sensor%d: ", sc->sc_hdev.sc_dev.dv_xname,  num);
	switch(s->sensor.type) {
d839 1
a839 1
		printf("Temperature sensor (%s), ",
d841 3
a843 2
		printf("calibration offset = %d.%d deg-C",
		    s->cal_offset / 100, abs(s->cal_offset % 100));
d846 1
a846 1
		printf("Humidity sensor (%s), ",
d848 3
a850 2
		printf("calibration offset = %d.%d %%RH",
		    s->cal_offset / 100, abs(s->cal_offset % 100));
@


1.12
log
@fix condition of retry counter.

reported by enami-san
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.11 2010/04/15 16:20:31 deraadt Exp $   */
d248 1
@


1.11
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.10 2010/04/15 16:02:11 yuo Exp $   */
d404 1
a404 1
	if (retry < 0)
d563 1
a563 1
		if (retry < 0)
@


1.10
log
@add yet another TEMPerHUM device identifier.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.9 2010/04/15 09:42:51 yuo Exp $   */
d62 1
a62 1
#define CMD_DEVTYPE		0x52 
d77 1
a77 1
#define TEMPERNTC_MODE_MAX	0x68 
d98 1
a98 1
        "unknown",
d232 1
a232 1
	/* maybe unsupported device */ 
d245 1
a245 1
		if (sc->sc_sensor[i].dev_type == UTHUM_SENSOR_UNKNOWN) 
d279 1
a279 1
				sensor_detach(&sc->sc_sensordev, 
d356 1
a356 1
	if (uthum_issue_cmd(sc, target_cmd, 50)) 
d381 1
a381 1
		uint16_t dev_type; 
d391 1
a391 1
		if (uthum_read_data(sc, CMD_DEVTYPE, (void *)&dinfo, 
d429 1
a429 1
		printf("uthum: unknown device (devtype = 0x%.2x)\n", 
d464 1
a464 1
		sc->sc_sensor[UTHUM_TEMPER_OUTER].sensor.type = 
d466 1
a466 1
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_OUTER].sensor.desc, 
d473 1
a473 1
		sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.type = 
d475 1
a475 1
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc, 
d481 1
a481 1
		for (i = 0; i < 2; i++) 
d484 1
a484 1
		sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.type = 
d486 1
a486 1
		strlcpy(sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.desc, 
d494 1
a494 1
		sc->sc_sensor[UTHUM_TEMPER_INNER].dev_type = 
d498 1
a498 1
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_INNER].sensor.desc, 
d501 1
a501 1
		strlcpy(sc->sc_sensor[UTHUM_TEMPER_NTC].sensor.desc, 
d507 1
a507 1
	 		uthum_issue_cmd(sc, TEMPERNTC_MODE_BASE, 50);
d531 1
a531 1
	} 
d556 1
a556 1
		while (retry) {	
d575 1
a575 1
	if (((curval < UTHUM_NTC_MIN_THRESHOLD) && 
d577 1
a577 1
	    ((curval > UTHUM_NTC_MAX_THRESHOLD) && 
d581 2
a582 2
	DPRINTF(("uthum: ntc tuning start. cur state = 0x%.2x, val = 0x%.4x\n", 
		state, curval));
d617 1
a617 1
	if (val != NULL) 
d659 1
a659 1
		sc->sc_sensor[UTHUM_TEMPERHUM_HUM].sensor.flags 
d671 1
a671 1
	sc->sc_sensor[UTHUM_TEMPERHUM_TEMP].sensor.value =  
d689 1
a689 1
	else 
d697 1
a697 1
	} 
d726 2
a727 2
	} 
		
d735 1
a735 1
		} 
d750 1
a750 1
/* return C-degree * 100 value */ 
d758 1
a758 1
/* return C-degree * 100 value */ 
d800 1
a800 1
	case TEMPERNTC_MODE_BASE+3:	/* 0x64 */	
d817 1
a817 1
			temp = ((val * val * 3257) / 100000) - (val * 4900) + 
@


1.9
log
@use SENSOR_HUMIDITY instead of SENSOR_PERCENT.
support new TEMPer sensors: TEMPer, TEMPer1, TEMPer2, TEMPerNTC

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.8 2010/02/18 23:34:05 deraadt Exp $   */
d53 1
d408 3
@


1.8
log
@do not zero fields which are already zero; from cnst
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.7 2010/02/17 14:06:10 yuo Exp $   */
d4 1
a4 1
 * Copyright (c) 2009 Yojiro UO <yuo@@nui.org>
d19 1
a19 1
/* Driver for TEMPerHUM HID */
d51 6
d58 46
a103 4
/* TEMPerHUM */
#define CMD_DEVTYPE 0x52 /* XXX */
#define CMD_GETDATA 0x48 /* XXX */
static uint8_t cmd_start[8] =
d105 1
a105 1
static uint8_t cmd_end[8] =
d108 7
a114 7
/* sensors */
#define UTHUM_TEMP		0
#define UTHUM_HUMIDITY		1
#define UTHUM_MAX_SENSORS	2

#define UTHUM_TYPE_UNKNOWN	0
#define UTHUM_TYPE_SHT1x	1
d121 2
a122 1
	int			 sc_sensortype;
d130 1
a130 1
	struct ksensor		 sc_sensor[UTHUM_MAX_SENSORS];
a132 2

	uint8_t			 sc_num_sensors;
a134 1

d136 1
a136 1
	/* XXX: various TEMPer variants using same VID/PID */
d141 1
a141 1
int uthum_match(struct device *, void *, void *);
d143 2
a144 2
int uthum_detach(struct device *, int);
int uthum_activate(struct device *, int);
d146 4
a149 4
int uthum_read_data(struct uthum_softc *, uint8_t, uint8_t *, size_t, int);
int uthum_check_sensortype(struct uthum_softc *);
int uthum_sht1x_temp(unsigned int);
int uthum_sht1x_rh(unsigned int, int);
d153 11
d207 1
a207 1
	int size, repid;
d231 5
a235 1
	sc->sc_sensortype = uthum_check_sensortype(sc);
d240 1
d242 8
a249 19
	switch (sc->sc_sensortype) {
	case UTHUM_TYPE_SHT1x:
		sc->sc_sensor[UTHUM_TEMP].type = SENSOR_TEMP;
		sc->sc_sensor[UTHUM_TEMP].flags = SENSOR_FINVALID;

		strlcpy(sc->sc_sensor[UTHUM_HUMIDITY].desc, "humidity",
		    sizeof(sc->sc_sensor[UTHUM_HUMIDITY].desc));
		sc->sc_sensor[UTHUM_HUMIDITY].type = SENSOR_PERCENT;
		sc->sc_sensor[UTHUM_HUMIDITY].flags = SENSOR_FINVALID;

		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[UTHUM_TEMP]);
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensor[UTHUM_HUMIDITY]);
		sc->sc_num_sensors = 2;
		DPRINTF(("%s: sensor type: SHT1x\n"));
		break;
	case UTHUM_TYPE_UNKNOWN:
		DPRINTF(("%s: sensor type: unknown, give up to attach sensors\n"));
	default:
		break;
d253 2
a254 1
		sc->sc_sensortask = sensor_task_register(sc, uthum_refresh, 20);
d276 5
a280 2
		for (i = 0; i < sc->sc_num_sensors; i++)
			sensor_detach(&sc->sc_sensordev, &sc->sc_sensor[i]);
d314 1
a314 2
uthum_read_data(struct uthum_softc *sc, uint8_t target_cmd, uint8_t *buf,
	size_t len, int delay)
d317 1
a317 5
	uint8_t cmdbuf[32], report[256];

	/* if return buffer is null, do nothing */
	if ((buf == NULL) || len == 0)
		return 0;
a318 1
	/* issue query */
d320 1
a320 1
	memcpy(cmdbuf, cmd_start, sizeof(cmd_start));
d337 23
a359 1
	memcpy(cmdbuf, cmd_end, sizeof(cmd_end));
d377 140
a516 1
uthum_check_sensortype(struct uthum_softc *sc)
a518 2
	static uint8_t sht1x_sig[] =
	    { 0x57, 0x5a, 0x13, 0x00, 0x14, 0x00, 0x53, 0x00 };
d520 88
a607 3
	if (uthum_read_data(sc, CMD_DEVTYPE, buf, sizeof(buf), 0) != 0) {
		DPRINTF(("uthum: read fail\n"));
		return UTHUM_TYPE_UNKNOWN;
d610 5
a614 8
	/*
	 * currently we have not enough information about the return value,
	 * therefore, compare full bytes.
	 * TEMPerHUM HID (SHT1x version) will return:
	 *   { 0x57, 0x5a, 0x13, 0x00, 0x14, 0x00, 0x53, 0x00 }
	 */
	if (memcmp(buf, sht1x_sig, sizeof(sht1x_sig)))
		return UTHUM_TYPE_SHT1x;
d616 1
a616 1
	return UTHUM_TYPE_UNKNOWN;
a618 1

d623 25
a648 1
	unsigned int temp_tick, humidity_tick;
d653 47
a699 2
		sc->sc_sensor[UTHUM_TEMP].flags |= SENSOR_FINVALID;
		sc->sc_sensor[UTHUM_HUMIDITY].flags |= SENSOR_FINVALID;
d702 8
d711 5
a715 4
	switch (sc->sc_sensortype) {
	case UTHUM_TYPE_SHT1x:
		temp_tick = (buf[0] * 256 + buf[1]) & 0x3fff;
		humidity_tick = (buf[2] * 256 + buf[3]) & 0x0fff;
d717 4
a720 5
		temp = uthum_sht1x_temp(temp_tick);
		rh = uthum_sht1x_rh(humidity_tick, temp);
		break;
	default:
		/* do nothing */
d722 21
d744 9
d754 12
a765 20
	sc->sc_sensor[UTHUM_TEMP].value = (temp * 10000) + 273150000;
	sc->sc_sensor[UTHUM_TEMP].flags &= ~SENSOR_FINVALID;
	sc->sc_sensor[UTHUM_HUMIDITY].value = rh;
	sc->sc_sensor[UTHUM_HUMIDITY].flags &= ~SENSOR_FINVALID;
}

/* return C-degree * 100 value */
int
uthum_sht1x_temp(unsigned int ticks)
{
	/* 
	 * VDD		constant
	 *-----------------------
	 * 5.0V		-4010
	 * 4.0V		-3980
	 * 3.5V		-3970
	 * 3.0V		-3960
	 * 2.5V		-3940
	 */
	/*
d767 1
a767 1
	 * I choose -3970 as the constant of this formula.
d769 2
d776 1
a776 1
uthum_sht1x_rh(unsigned int ticks, int temp)
d778 1
a778 1
	int rh_l, rh;
d780 1
d782 67
a848 2
	rh = ((temp - 2500) * (1 + (ticks >> 7)) + rh_l) / 10;
	return rh;
@


1.7
log
@change constant of convert formulra of SHT1X sensor to fit
TEMPerHUM hardware. (It uses 3.38-3.48V as SHT1X's VDD).

mentiond by Michael Fuckner
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.6 2010/01/03 18:43:02 deraadt Exp $   */
a181 2
		strlcpy(sc->sc_sensor[UTHUM_TEMP].desc, "temp",
		    sizeof(sc->sc_sensor[UTHUM_TEMP].desc));
a182 1
		sc->sc_sensor[UTHUM_TEMP].status = SENSOR_S_UNSPEC;
a187 2
		sc->sc_sensor[UTHUM_HUMIDITY].value = 0;
		sc->sc_sensor[UTHUM_HUMIDITY].status = SENSOR_S_UNSPEC;
@


1.6
log
@delete unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.5 2009/12/17 08:28:03 yuo Exp $   */
d207 1
a207 1
		sc->sc_sensortask = sensor_task_register(sc, uthum_refresh, 6);
d373 14
a386 1
	return (ticks - 4010);
@


1.5
log
@fix softc structure to fit as uhid sub device.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.4 2009/12/10 04:44:27 deraadt Exp $   */
a79 2
	uint8_t			*sc_ibuf;

d260 1
a260 6
	struct uthum_softc *sc = (struct uthum_softc *)addr;
	if (sc->sc_ibuf == NULL)
		return;

	/* nothing to do? */
	return;
@


1.4
log
@various bits of knf; ok yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.3 2009/11/29 17:32:06 deraadt Exp $   */
a68 1
	struct device		 sc_dev;
d179 1
a179 1
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
@


1.3
log
@On any sensor the SENSOR_FINVALID flag indicates whether we are able to
read a value from the sensor properly.  The .status field, on the other
hand, indicates whether the location that sensor is at, is OK, failed,
on fire, or whatnot.  In the case of uthum we have no idea whether that
temperature is ok or not, so we must leave it SENSOR_S_UNSPEC
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.2 2009/11/24 08:28:53 deraadt Exp $   */
d43 2
a44 2
int     uthumdebug = 0;
#define DPRINTFN(n, x)  do { if (uthumdebug > (n)) printf x; } while (0)
d55 2
a56 2
static uint8_t cmd_start[8] = 
	{0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x02, 0x00};
d58 1
a58 1
	{0x0a, 0x0b, 0x0c, 0x0d, 0x00, 0x00, 0x01, 0x00};
d85 1
a85 1
	struct ksensordev        sc_sensordev;
d94 1
a94 1
	{ USB_VENDOR_TENX, USB_PRODUCT_TENX_TEMPER}, 
d98 4
a101 4
int uthum_match(struct device *, void *, void *); 
void uthum_attach(struct device *, struct device *, void *); 
int uthum_detach(struct device *, int); 
int uthum_activate(struct device *, int); 
d111 3
d115 6
a120 10
struct cfdriver uthum_cd = { 
	NULL, "uthum", DV_DULL 
}; 

const struct cfattach uthum_ca = { 
	sizeof(struct uthum_softc), 
	uthum_match, 
	uthum_attach, 
	uthum_detach, 
	uthum_activate, 
d129 1
a129 1
	if (uthum_lookup(uha->uaa->vendor, uha->uaa->product) == NULL) {
a130 1
	} 
d132 1
a132 1
#if 0 /* attach only sensor part of HID as uthum* */ 
d138 1
a138 1
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_UNKNOWN_3)))
d169 1
a169 1
		&sc->sc_hdev.sc_dev);
d181 1
a181 1
		sizeof(sc->sc_sensordev.xname));
d186 1
a186 1
			sizeof(sc->sc_sensor[UTHUM_TEMP].desc));
d192 1
a192 1
			sizeof(sc->sc_sensor[UTHUM_HUMIDITY].desc));
d232 1
a232 1
		for (i = 0; i < sc->sc_num_sensors; i++) {
a233 1
		}
d239 1
a239 1
			   &sc->sc_hdev.sc_dev);
d272 1
a272 1
uthum_read_data(struct uthum_softc *sc, uint8_t target_cmd, uint8_t *buf, 
d279 1
a279 1
	if ((buf == NULL) || len == 0) {
a280 1
	}
d285 2
a286 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, 
		cmdbuf, sc->sc_olen)) {
d288 1
a288 1
	}
d291 2
a292 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, 
		cmdbuf, sc->sc_olen)) {
d294 1
a294 1
	}
d297 2
a298 2
		if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, 
			cmdbuf, sc->sc_olen)) {
a299 1
		}		
d302 2
a303 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, 
		cmdbuf, sc->sc_olen)) {
a304 1
	}
d307 1
a307 1
	if (delay > 0) {
a308 1
	}
d312 1
a312 1
		report, sc->sc_flen)) {
a313 2
	}

a314 1

d322 2
a323 2
	static uint8_t sht1x_sig[] = 
		{0x57, 0x5a, 0x13, 0x00, 0x14, 0x00, 0x53, 0x00};
d330 1
a330 1
	/* 
d334 1
a334 1
	 *   {0x57, 0x5a, 0x13, 0x00, 0x14, 0x00, 0x53, 0x00}
d336 1
a336 1
	if (memcmp(buf, sht1x_sig, sizeof(sht1x_sig))) {
a337 1
	}
d391 1
a391 1
	rh   = ((temp - 2500) * (1 + (ticks >> 7)) + rh_l) / 10;
@


1.2
log
@Toggle SENSOR_FINVALID based on sensor data validity
@
text
@d1 1
a1 1
/*	$OpenBSD: uthum.c,v 1.1 2009/11/23 19:35:54 yuo Exp $   */
d190 1
a190 1
		sc->sc_sensor[UTHUM_TEMP].status = SENSOR_S_UNKNOWN;
d197 1
a197 1
		sc->sc_sensor[UTHUM_HUMIDITY].status = SENSOR_S_UNKNOWN;
a363 2
		sc->sc_sensor[UTHUM_TEMP].status = SENSOR_S_UNKNOWN;
		sc->sc_sensor[UTHUM_HUMIDITY].status = SENSOR_S_UNKNOWN;
a382 1
	sc->sc_sensor[UTHUM_TEMP].status = SENSOR_S_OK;
a384 1
	sc->sc_sensor[UTHUM_HUMIDITY].status = SENSOR_S_OK;
@


1.1
log
@Add uthum(4) device driver for TEMPerHUM USB temperature and
humidity sensor.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD:$   */
d185 1
a185 1
	switch (sc->sc_sensortype){
d190 2
d198 1
d366 2
d371 1
a371 1
	switch (sc->sc_sensortype){
d381 1
a381 1
		break;
d386 1
d389 1
@

