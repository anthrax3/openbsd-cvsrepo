head	1.34;
access;
symbols
	OPENBSD_6_1:1.34.0.2
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.28.0.10
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.12
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.10
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.8
	OPENBSD_5_0:1.27.0.6
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.16
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.14
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.12
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.10
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.8
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.6
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.20
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.03.11.10.12.45;	author ratchov;	state Exp;
branches;
next	1.33;
commitid	lYK2Pvw6qiuQyEex;

1.33
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.32;
commitid	qGgYgJTgEFuAoGj4;

1.32
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.31;
commitid	pi1a9KN0itEngOc4;

1.31
date	2016.08.31.07.22.43;	author ratchov;	state Exp;
branches;
next	1.30;
commitid	u524ZaNwqXxsCXa2;

1.30
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.29;
commitid	EA6IpjJSgQH2WTCf;

1.29
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	RaOGL5SyOGOZylwx;

1.28
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.16.04.53.17;	author pvalchev;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.24.20.42.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.31.15.21.18;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.28.09.47.21;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.01.25.06.14.33;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.26.16.20.04;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.23.17.53.25;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.30.20.28.31;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.06.23.07.25;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.52;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.10.01.06.09.24;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.19.09.04.37;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.24.13.44.17;	author ho;	state Exp;
branches;
next	1.9;

1.9
date	99.07.23.13.18.04;	author niklas;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.01.02.00.02.39;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.11.03.21.00.10;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	98.04.26.21.03.08;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.07.10.23.06.30;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.46.58;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.02.00.29.20;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.29;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.05.14.22.23.00;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.10.31.03.22.40;	author nate;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.03.28.12.29.44;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.03.28.00.38.09;	author niklas;	state Exp;
branches;
next	1.9.4.7;

1.9.4.7
date	2003.05.13.19.34.56;	author ho;	state Exp;
branches;
next	1.9.4.8;

1.9.4.8
date	2004.02.19.10.56.13;	author niklas;	state Exp;
branches;
next	1.9.4.9;

1.9.4.9
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.06.11.03.42.15;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.05.19.22.01.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@AUDIO_ENCODING_{S,U}LINEAR constants are neither used by low level
drivers nor exposed to user-land. Remove definitions and code to
handle convertions.
@
text
@/*	$OpenBSD: audio_if.h,v 1.33 2016/09/19 06:46:44 ratchov Exp $	*/
/*	$NetBSD: audio_if.h,v 1.24 1998/01/10 14:07:25 tv Exp $	*/

/*
 * Copyright (c) 1994 Havard Eidnes.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _SYS_DEV_AUDIO_IF_H_
#define _SYS_DEV_AUDIO_IF_H_

#include <sys/mutex.h>

/*
 * get_props
 */
#define AUDIO_PROP_FULLDUPLEX	0x01
#define AUDIO_PROP_MMAP		0x02
#define AUDIO_PROP_INDEPENDENT	0x04

#define AUDIO_BPS(bits)		(bits) <= 8 ? 1 : ((bits) <= 16 ? 2 : 4)

/*
 * Generic interface to hardware driver.
 */

struct mixer_devinfo;
struct mixer_ctrl;

struct audio_params {
	u_long	sample_rate;			/* sample rate */
#define	AUDIO_ENCODING_NONE		0 /* no encoding assigned */
#define	AUDIO_ENCODING_ULAW		1 /* ITU G.711 mu-law */
#define	AUDIO_ENCODING_ALAW		2 /* ITU G.711 A-law */
#define AUDIO_ENCODING_SLINEAR_LE	6
#define AUDIO_ENCODING_SLINEAR_BE	7
#define AUDIO_ENCODING_ULINEAR_LE	8
#define AUDIO_ENCODING_ULINEAR_BE	9
	u_int	encoding;			/* mu-law, linear, etc */
	u_int	precision;			/* bits/sample */
	u_int	bps;				/* bytes/sample */
	u_int	msb;				/* data alignment */
	u_int	channels;			/* mono(1), stereo(2) */
};

struct audio_hw_if {
	int	(*open)(void *, int);	/* open hardware */
	void	(*close)(void *);		/* close hardware */

	/* Set the audio encoding parameters (record and play).
	 * Return 0 on success, or an error code if the
	 * requested parameters are impossible.
	 * The values in the params struct may be changed (e.g. rounding
	 * to the nearest sample rate.)
	 */
	int	(*set_params)(void *, int, int, struct audio_params *,
		    struct audio_params *);

	/* Hardware may have some say in the blocksize to choose */
	int	(*round_blocksize)(void *, int);

	/*
	 * Changing settings may require taking device out of "data mode",
	 * which can be quite expensive.  Also, audiosetinfo() may
	 * change several settings in quick succession.  To avoid
	 * having to take the device in/out of "data mode", we provide
	 * this function which indicates completion of settings
	 * adjustment.
	 */
	int	(*commit_settings)(void *);

	/* Start input/output routines. These usually control DMA. */
	int	(*init_output)(void *, void *, int);
	int	(*init_input)(void *, void *, int);
	int	(*start_output)(void *, void *, int, void (*)(void *), void *);
	int	(*start_input)(void *, void *, int, void (*)(void *), void *);
	int	(*halt_output)(void *);
	int	(*halt_input)(void *);

	int	(*speaker_ctl)(void *, int);
#define SPKR_ON		1
#define SPKR_OFF	0

	int	(*setfd)(void *, int);

	/* Mixer (in/out ports) */
	int	(*set_port)(void *, struct mixer_ctrl *);
	int	(*get_port)(void *, struct mixer_ctrl *);

	int	(*query_devinfo)(void *, struct mixer_devinfo *);

	/* Allocate/free memory for the ring buffer. Usually malloc/free. */
	/* The _old interfaces have been deprecated and will not be
	   called in newer kernels if the new interfaces are present */
	void	*(*allocm)(void *, int, size_t, int, int);
	void	(*freem)(void *, void *, int);
	size_t	(*round_buffersize)(void *, int, size_t);

	int	(*get_props)(void *); /* device properties */

	int	(*trigger_output)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
	int	(*trigger_input)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
};

struct audio_attach_args {
	int	type;
	void	*hwif;		/* either audio_hw_if * or midi_hw_if * */
	void	*hdl;
};
#define	AUDIODEV_TYPE_AUDIO	0
#define	AUDIODEV_TYPE_MIDI	1
#define AUDIODEV_TYPE_OPL	2
#define AUDIODEV_TYPE_MPU	3
#define AUDIODEV_TYPE_RADIO	4

/* Attach the MI driver(s) to the MD driver. */
struct device *audio_attach_mi(struct audio_hw_if *, void *, struct device *);
int	       audioprint(void *, const char *);

extern struct mutex audio_lock;

#endif /* _SYS_DEV_AUDIO_IF_H_ */
@


1.33
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.32 2016/09/14 06:12:19 ratchov Exp $	*/
a67 2
#define AUDIO_ENCODING_SLINEAR		10
#define AUDIO_ENCODING_ULINEAR		11
@


1.32
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.29 2015/05/11 06:46:21 ratchov Exp $	*/
a55 1
struct audio_device;
a114 1
	int	(*getdev)(void *, struct audio_device *);
@


1.31
log
@Delete unused ioctls and associated macros. Move macros that are still
used internally by low-level drivers from sys/audioio.h to
dev/audio_if.h instead of deleting them.
@
text
@a56 1
struct audio_encoding;
a61 14
	u_int	encoding;			/* mu-law, linear, etc */
	u_int	precision;			/* bits/sample */
	u_int	bps;				/* bytes/sample */
	u_int	msb;				/* data alignment */
	u_int	channels;			/* mono(1), stereo(2) */
};

/*
 * query_encoding argument
 */
typedef struct audio_encoding {
	int	index;
#define MAX_AUDIO_DEV_LEN		16
	char	name[MAX_AUDIO_DEV_LEN];
a64 1
#define	AUDIO_ENCODING_ADPCM		5 /* adaptive differential PCM */
d71 6
a76 7
	int	encoding;
	int	precision;
	int	bps;
	int	msb;
	int	flags;
#define AUDIO_ENCODINGFLAG_EMULATED 1 /* software emulation mode */
} audio_encoding_t;
a80 5
	int	(*drain)(void *);		/* Optional: drain buffers */

	/* Encoding. */
	/* XXX should we have separate in/out? */
	int	(*query_encoding)(void *, struct audio_encoding *);
a130 1
	paddr_t	(*mappage)(void *, void *, off_t, int);
a137 1
	void	(*get_default_params)(void *, int, struct audio_params *);
@


1.30
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@d43 7
d69 25
@


1.29
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.28 2013/05/15 08:29:24 ratchov Exp $	*/
a48 1
struct audio_softc;
a62 3
/* The default audio mode: 8 kHz mono mu-law */
extern struct audio_params audio_default;

a146 20
/* Device identity flags */
#define SOUND_DEVICE		0
#define AUDIO_DEVICE		0x80
#define AUDIOCTL_DEVICE		0xc0
#define MIXER_DEVICE		0x10

#define AUDIOUNIT(x)		(minor(x)&0x0f)
#define AUDIODEV(x)		(minor(x)&0xf0)

#define ISDEVSOUND(x)		(AUDIODEV((x)) == SOUND_DEVICE)
#define ISDEVAUDIO(x)		(AUDIODEV((x)) == AUDIO_DEVICE)
#define ISDEVAUDIOCTL(x)	(AUDIODEV((x)) == AUDIOCTL_DEVICE)
#define ISDEVMIXER(x)		(AUDIODEV((x)) == MIXER_DEVICE)

/*
 * USB Audio specification defines 12 channels:
 *	L R C LFE Ls Rs Lc Rc S Sl Sr T
 */
#define AUDIO_MAX_CHANNELS	12

a149 1

@


1.28
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.27 2010/07/15 03:43:11 jakemsr Exp $	*/
a61 3
	/* Software en/decode functions, set if SW coding required by HW */
	void	(*sw_code)(void *, u_char *, int);
	int	factor;				/* coding space change */
@


1.27
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.26 2008/04/21 00:32:42 jakemsr Exp $	*/
d41 2
d173 2
@


1.26
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.25 2004/04/16 04:53:17 pvalchev Exp $	*/
d41 2
d57 2
@


1.25
log
@remote splaudio hack, now that all architectures that need it,
have it in MI includes; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.24 2004/02/24 20:42:40 deraadt Exp $	*/
d130 1
@


1.24
log
@same gory splaudio hack for amd64, sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.23 2004/01/31 15:21:18 drahn Exp $	*/
a159 5

#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__) && !defined(__arm__) && !defined(__x86_64__)
#define splaudio splbio		/* XXX */
#define IPL_AUDIO IPL_BIO	/* XXX */
#endif
@


1.23
log
@Arm provides audio interrupt bits, do not default them here. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.22 2003/03/28 09:47:21 jmc Exp $	*/
d161 1
a161 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__) && !defined(__arm__)
@


1.22
log
@mu-law and A-law spelling;
mu-law and u-law are the same, so used mu-law for consistency;

ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.21 2003/01/25 06:14:33 jason Exp $	*/
d161 1
a161 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__)
@


1.21
log
@hppa provides its own IPL_AUDIO, too
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.20 2002/08/26 16:20:04 mickey Exp $	*/
d53 1
a53 1
	u_int	encoding;			/* e.g. ulaw, linear, etc */
d61 1
a61 1
/* The default audio mode: 8 kHz mono ulaw */
@


1.20
log
@space cleanup; some from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.19 2002/07/23 17:53:25 drahn Exp $	*/
d161 1
a161 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__)
@


1.19
log
@Cardbus/pcmcia support for macppc. parts borrowed from NetBSD, and other
portions of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.18 2002/05/30 20:28:31 mickey Exp $	*/
d68 1
a68 1
	
d74 1
a74 1
	 * Return 0 on success, or an error code if the 
d79 1
a79 1
        int	(*set_params)(void *, int, int, struct audio_params *,
d81 1
a81 1
  
d109 1
a109 1
	
d115 1
a115 1
	
d124 1
a124 1
	int 	(*get_props)(void *); /* device properties */
d144 1
a144 2
struct device *audio_attach_mi(struct audio_hw_if *, void *, 
				    struct device *);
@


1.18
log
@fallout from the radio attachment fix
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.17 2002/05/06 23:07:25 nate Exp $	*/
d162 1
a162 1
#if !defined(__i386__) && !defined(__sparc64__)
@


1.17
log
@sync uaudio with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.16 2002/03/14 03:16:03 millert Exp $	*/
d46 4
d111 2
a112 2
	int	(*set_port)(void *, mixer_ctrl_t *);
	int	(*get_port)(void *, mixer_ctrl_t *);
d114 1
a114 1
	int	(*query_devinfo)(void *, mixer_devinfo_t *);
d141 1
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.15 2002/03/14 01:26:52 millert Exp $	*/
d161 6
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.14 2002/01/20 19:56:53 ericj Exp $	*/
d94 2
a95 4
	int	(*start_output)__P((void *, void *, int,
				    void (*)(void *), void *));
	int	(*start_input)__P((void *, void *, int,
				   void (*)(void *), void *));
d122 4
a125 4
	int	(*trigger_output)__P((void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *));
	int	(*trigger_input)__P((void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *));
@


1.14
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.13 2001/10/31 11:00:24 art Exp $	*/
d53 1
a53 1
	void	(*sw_code)__P((void *, u_char *, int));
d61 3
a63 3
	int	(*open)__P((void *, int));	/* open hardware */
	void	(*close)__P((void *));		/* close hardware */
	int	(*drain)__P((void *));		/* Optional: drain buffers */
d67 1
a67 1
	int	(*query_encoding)__P((void *, struct audio_encoding *));
d75 2
a76 2
        int	(*set_params)__P((void *, int, int, struct audio_params *,
		    struct audio_params *));
d79 1
a79 1
	int	(*round_blocksize)__P((void *, int));
d89 1
a89 1
	int	(*commit_settings)__P((void *));
d92 2
a93 2
	int	(*init_output)__P((void *, void *, int));
	int	(*init_input)__P((void *, void *, int));
d98 2
a99 2
	int	(*halt_output)__P((void *));
	int	(*halt_input)__P((void *));
d101 1
a101 1
	int	(*speaker_ctl)__P((void *, int));
d105 2
a106 2
	int	(*getdev)__P((void *, struct audio_device *));
	int	(*setfd)__P((void *, int));
d109 2
a110 2
	int	(*set_port)__P((void *, mixer_ctrl_t *));
	int	(*get_port)__P((void *, mixer_ctrl_t *));
d112 1
a112 1
	int	(*query_devinfo)__P((void *, mixer_devinfo_t *));
d117 4
a120 4
	void	*(*allocm)__P((void *, int, size_t, int, int));
	void	(*freem)__P((void *, void *, int));
	size_t	(*round_buffersize)__P((void *, int, size_t));
	paddr_t	(*mappage)__P((void *, void *, off_t, int));
d122 1
a122 1
	int 	(*get_props)__P((void *)); /* device properties */
d141 3
a143 3
struct device *audio_attach_mi __P((struct audio_hw_if *, void *, 
				    struct device *));
int	       audioprint __P((void *, const char *));
@


1.13
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.12 2001/10/01 06:09:24 jason Exp $	*/
d117 1
a117 1
	void	*(*allocm_old)__P((void *, unsigned long, int, int));
d119 1
a119 1
	unsigned long (*round_buffersize_old)__P((void *, unsigned long));
a127 3

	void	*(*allocm)__P((void *, int, size_t, int, int));
	size_t  (*round_buffersize)__P((void *, int, size_t));
@


1.13.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.14 2002/01/20 19:56:53 ericj Exp $	*/
d117 1
a117 1
	void	*(*allocm)__P((void *, int, size_t, int, int));
d119 1
a119 1
	size_t	(*round_buffersize)__P((void *, int, size_t));
d128 3
@


1.13.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.13.2.1 2002/01/31 22:55:29 niklas Exp $	*/
a45 4
struct audio_device;
struct audio_encoding;
struct mixer_devinfo;
struct mixer_ctrl;
d53 1
a53 1
	void	(*sw_code)(void *, u_char *, int);
d61 3
a63 3
	int	(*open)(void *, int);	/* open hardware */
	void	(*close)(void *);		/* close hardware */
	int	(*drain)(void *);		/* Optional: drain buffers */
d67 1
a67 1
	int	(*query_encoding)(void *, struct audio_encoding *);
d75 2
a76 2
        int	(*set_params)(void *, int, int, struct audio_params *,
		    struct audio_params *);
d79 1
a79 1
	int	(*round_blocksize)(void *, int);
d89 1
a89 1
	int	(*commit_settings)(void *);
d92 8
a99 6
	int	(*init_output)(void *, void *, int);
	int	(*init_input)(void *, void *, int);
	int	(*start_output)(void *, void *, int, void (*)(void *), void *);
	int	(*start_input)(void *, void *, int, void (*)(void *), void *);
	int	(*halt_output)(void *);
	int	(*halt_input)(void *);
d101 1
a101 1
	int	(*speaker_ctl)(void *, int);
d105 2
a106 2
	int	(*getdev)(void *, struct audio_device *);
	int	(*setfd)(void *, int);
d109 2
a110 2
	int	(*set_port)(void *, struct mixer_ctrl *);
	int	(*get_port)(void *, struct mixer_ctrl *);
d112 1
a112 1
	int	(*query_devinfo)(void *, struct mixer_devinfo *);
d117 11
a127 11
	void	*(*allocm)(void *, int, size_t, int, int);
	void	(*freem)(void *, void *, int);
	size_t	(*round_buffersize)(void *, int, size_t);
	paddr_t	(*mappage)(void *, void *, off_t, int);

	int 	(*get_props)(void *); /* device properties */

	int	(*trigger_output)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
	int	(*trigger_input)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
a138 1
#define AUDIODEV_TYPE_RADIO	4
d141 3
a143 3
struct device *audio_attach_mi(struct audio_hw_if *, void *, 
				    struct device *);
int	       audioprint(void *, const char *);
a162 6

/*
 * USB Audio specification defines 12 channels:
 *	L R C LFE Ls Rs Lc Rc S Sl Sr T
 */
#define AUDIO_MAX_CHANNELS	12
@


1.13.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.13.2.2 2002/06/11 03:42:15 art Exp $	*/
d68 1
a68 1

d74 1
a74 1
	 * Return 0 on success, or an error code if the
d79 1
a79 1
	int	(*set_params)(void *, int, int, struct audio_params *,
d81 1
a81 1

d109 1
a109 1

d115 1
a115 1

d124 1
a124 1
	int	(*get_props)(void *); /* device properties */
d144 2
a145 1
struct device *audio_attach_mi(struct audio_hw_if *, void *, struct device *);
d162 1
a162 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__)
@


1.13.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
	u_int	encoding;			/* mu-law, linear, etc */
d61 1
a61 1
/* The default audio mode: 8 kHz mono mu-law */
d161 1
a161 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__)
@


1.12
log
@sparc64 doesn't need splaudio()/IPL_AUDIO provided here, either
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.11 2000/07/19 09:04:37 csapuntz Exp $	*/
d120 1
a120 1
	int	(*mappage)__P((void *, void *, int, int));
@


1.11
log
@

As in NetBSD, added direction to allocm/round_buffer_size APIs.
Accomplished by adding functions to audio_hw_if instead of redoing
current ones so as to minimize need to change drivers.

For Neomagic, tell the AC97 subsystem that we don't support reads.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.10 2000/05/24 13:44:17 ho Exp $	*/
d162 1
a162 1
#ifndef __i386__
@


1.10
log
@Permit detach of audio devices, such as uaudio. Selected code
from NetBSD/Lennart Augustsson. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.9 1999/07/23 13:18:04 niklas Exp $	*/
d115 3
a117 1
	void	*(*allocm)__P((void *, unsigned long, int, int));
d119 1
a119 1
	unsigned long (*round_buffersize)__P((void *, unsigned long));
d128 3
@


1.9
log
@From NetBSD; let i386 run audio at a high IPL
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.8 1999/01/02 00:02:39 niklas Exp $	*/
d139 3
a141 2
void	audio_attach_mi __P((struct audio_hw_if *, void *, struct device *));
int	audioprint __P((void *, const char *));
@


1.9.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.11 2000/07/19 09:04:37 csapuntz Exp $	*/
d115 1
a115 3
	/* The _old interfaces have been deprecated and will not be
	   called in newer kernels if the new interfaces are present */
	void	*(*allocm_old)__P((void *, unsigned long, int, int));
d117 1
a117 1
	unsigned long (*round_buffersize_old)__P((void *, unsigned long));
a125 3

	void	*(*allocm)__P((void *, int, size_t, int, int));
	size_t  (*round_buffersize)__P((void *, int, size_t));
d139 2
a140 3
struct device *audio_attach_mi __P((struct audio_hw_if *, void *, 
				    struct device *));
int	       audioprint __P((void *, const char *));
@


1.9.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.9.4.1 2001/05/14 22:23:00 niklas Exp $	*/
d162 1
a162 1
#if !defined(__i386__) && !defined(__sparc64__)
@


1.9.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 1
a120 1
	paddr_t	(*mappage)__P((void *, void *, off_t, int));
@


1.9.4.4
log
@Merge in trunk
@
text
@d117 1
a117 1
	void	*(*allocm)__P((void *, int, size_t, int, int));
d119 1
a119 1
	size_t	(*round_buffersize)__P((void *, int, size_t));
d128 3
@


1.9.4.5
log
@Merge in -current from about a week ago
@
text
@d53 1
a53 1
	void	(*sw_code)(void *, u_char *, int);
d61 3
a63 3
	int	(*open)(void *, int);	/* open hardware */
	void	(*close)(void *);		/* close hardware */
	int	(*drain)(void *);		/* Optional: drain buffers */
d67 1
a67 1
	int	(*query_encoding)(void *, struct audio_encoding *);
d75 2
a76 2
        int	(*set_params)(void *, int, int, struct audio_params *,
		    struct audio_params *);
d79 1
a79 1
	int	(*round_blocksize)(void *, int);
d89 1
a89 1
	int	(*commit_settings)(void *);
d92 8
a99 6
	int	(*init_output)(void *, void *, int);
	int	(*init_input)(void *, void *, int);
	int	(*start_output)(void *, void *, int, void (*)(void *), void *);
	int	(*start_input)(void *, void *, int, void (*)(void *), void *);
	int	(*halt_output)(void *);
	int	(*halt_input)(void *);
d101 1
a101 1
	int	(*speaker_ctl)(void *, int);
d105 2
a106 2
	int	(*getdev)(void *, struct audio_device *);
	int	(*setfd)(void *, int);
d109 2
a110 2
	int	(*set_port)(void *, mixer_ctrl_t *);
	int	(*get_port)(void *, mixer_ctrl_t *);
d112 1
a112 1
	int	(*query_devinfo)(void *, mixer_devinfo_t *);
d117 11
a127 11
	void	*(*allocm)(void *, int, size_t, int, int);
	void	(*freem)(void *, void *, int);
	size_t	(*round_buffersize)(void *, int, size_t);
	paddr_t	(*mappage)(void *, void *, off_t, int);

	int 	(*get_props)(void *); /* device properties */

	int	(*trigger_output)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
	int	(*trigger_input)(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
d141 3
a143 3
struct device *audio_attach_mi(struct audio_hw_if *, void *, 
				    struct device *);
int	       audioprint(void *, const char *);
@


1.9.4.6
log
@Sync the SMP branch with 3.3
@
text
@a45 4
struct audio_device;
struct audio_encoding;
struct mixer_devinfo;
struct mixer_ctrl;
d64 1
a64 1

d70 1
a70 1
	 * Return 0 on success, or an error code if the
d75 1
a75 1
	int	(*set_params)(void *, int, int, struct audio_params *,
d77 1
a77 1

d105 1
a105 1

d107 2
a108 4
	int	(*set_port)(void *, struct mixer_ctrl *);
	int	(*get_port)(void *, struct mixer_ctrl *);

	int	(*query_devinfo)(void *, struct mixer_devinfo *);
d110 2
d120 1
a120 1
	int	(*get_props)(void *); /* device properties */
a136 1
#define AUDIODEV_TYPE_RADIO	4
d139 2
a140 1
struct device *audio_attach_mi(struct audio_hw_if *, void *, struct device *);
d157 1
a157 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__)
a160 6

/*
 * USB Audio specification defines 12 channels:
 *	L R C LFE Ls Rs Lc Rc S Sl Sr T
 */
#define AUDIO_MAX_CHANNELS	12
@


1.9.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.9.4.6 2003/03/28 00:38:09 niklas Exp $	*/
d53 1
a53 1
	u_int	encoding;			/* mu-law, linear, etc */
d61 1
a61 1
/* The default audio mode: 8 kHz mono mu-law */
@


1.9.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
a161 1
#if !defined(__i386__) && !defined(__sparc64__) && !defined(__powerpc__) && !defined(__hppa__) && !defined(__arm__)
@


1.9.4.9
log
@Merge with the trunk
@
text
@d161 5
@


1.8
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.7 1998/11/03 21:00:10 downsj Exp $	*/
d156 1
a156 1
/*#ifndef __i386__*/
d159 1
a159 1
/*#endif*/
@


1.7
log
@Partial sync with NetBSD, adds new trigger methods.
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.6 1998/04/26 21:03:08 provos Exp $	*/
a127 17
struct midi_info {
	char	*name;		/* Name of MIDI hardware */
	int	props;
};
#define MIDI_PROP_OUT_INTR 1

struct midi_hw_if {
	int	(*open)__P((void *, int, 	/* open hardware */
			    void (*)__P((void *, int)),
			    void (*)__P((void *)),
			    void *));
	void	(*close)__P((void *));		/* close hardware */
	int	(*output)__P((void *, int));	/* output a byte */
	void	(*getinfo)__P((void *, struct midi_info *));
	int	(*ioctl)__P((u_long, caddr_t, int, struct proc *));
};

d135 2
d139 2
a140 1
extern void	audio_attach_mi __P((struct audio_hw_if *, struct midi_hw_if *, void *, struct device *));
@


1.6
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: audio_if.h,v 1.21 1997/09/06 01:14:49 augustss Exp $	*/
d38 3
d75 2
a76 1
        int	(*set_params)__P((void *, int, int, struct audio_params *, struct audio_params *));
d115 2
a116 2
	void	*(*alloc)__P((void *, unsigned long, int, int));
	void	(*free)__P((void *, void *, int));
d121 5
d174 2
@


1.5
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 2
a2 2
/*	$OpenBSD: audio_if.h,v 1.3 1996/03/02 00:29:20 niklas Exp $	*/
/*	$NetBSD: audio_if.h,v 1.7 1996/03/07 15:00:10 christos Exp $	*/
d44 13
d58 1
a58 1
	int	(*open)__P((dev_t, int));	/* open hardware */
a61 6
	/* Sample rate */
	int	(*set_in_sr)__P((void *, u_long));
	u_long	(*get_in_sr)__P((void *));
	int	(*set_out_sr)__P((void *, u_long));
	u_long	(*get_out_sr)__P((void *));

a62 1
	/* Precision = bits/sample, usually 8 or 16 */
a64 7
	int	(*set_format)__P((void *, u_int, u_int));
	int	(*get_encoding)__P((void *));
	int	(*get_precision)__P((void *));

	/* Channels - mono(1), stereo(2) */
	int	(*set_channels)__P((void *, int));
	int	(*get_channels)__P((void *));
d66 8
a76 6
	/* Ports (in/out ports) */
	int	(*set_out_port)__P((void *, int));
	int	(*get_out_port)__P((void *));
	int	(*set_in_port)__P((void *, int));
	int	(*get_in_port)__P((void *));

a86 4
	/* Software en/decode functions, set if SW coding required by HW */
	void	(*sw_encode)__P((void *, int, u_char *, int));
	void	(*sw_decode)__P((void *, int, u_char *, int));

d88 2
a95 2
	int	(*cont_output)__P((void *));
	int	(*cont_input)__P((void *));
d110 7
a116 2
	int full_duplex; /* non-null if HW is able to do full-duplex */
	int audio_unit;
d119 27
a145 3
/* Register / deregister hardware driver */
extern int	audio_hardware_attach __P((struct audio_hw_if *, void *));
extern int	audio_hardware_detach __P((struct audio_hw_if *));
d150 1
a152 4
#define ISDEVAUDIO(x)		((minor(x)&0xf0) == AUDIO_DEVICE)
#define ISDEVSOUND(x)		((minor(x)&0xf0) == SOUND_DEVICE)
#define ISDEVMIXER(x)		((minor(x)&0xf0) == MIXER_DEVICE)

d156 6
d164 2
@


1.4
log
@NetBSD 960317 merge
@
text
@d56 1
d59 1
a59 1
	int	(*set_encoding)__P((void *, u_int));
a60 4

	/* Precision = bits/sample, usually 8 or 16 */
	/* XXX should we have separate in/out? */
	int	(*set_precision)__P((void *, u_int));
a84 3

	/* Return silence value for encoding */
	u_int	(*get_silence)__P((int));
@


1.3
log
@From NetBSD: sync with 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: audio_if.h,v 1.6 1995/12/24 02:30:58 mycroft Exp $	*/
d42 2
d97 4
a100 2
	int	(*start_output)__P((void *, void *, int, void (*)(), void *));
	int	(*start_input)__P((void *, void *, int, void (*)(), void *));
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 2
a2 1
/*	$NetBSD: audio_if.h,v 1.5 1995/07/19 19:58:23 brezak Exp $	*/
@


1.1
log
@Initial revision
@
text
@d135 1
a135 1
#define ISA_IPL_AUDIO ISA_IPL_BIO /* XXX */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
