head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.34
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.30
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.20
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.28
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.26
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.24
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.22
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.18
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.16
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.14
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.12
	OPENBSD_5_0:1.3.0.10
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.8
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.6
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.4
	OPENBSD_4_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.3
date	2009.06.06.03.45.05;	author matthieu;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.06.03.20.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.06.00.35.00;	author pirofti;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Fix RCSIds
@
text
@/*	$NetBSD: x86emu.h,v 1.1 2007/12/01 20:14:10 joerg Exp $	*/
/*	$OpenBSD$ */

/****************************************************************************
*
*  Realmode X86 Emulator Library
*
*  Copyright (C) 1996-1999 SciTech Software, Inc.
*  Copyright (C) David Mosberger-Tang
*  Copyright (C) 1999 Egbert Eich
*  Copyright (C) 2007 Joerg Sonnenberger
*
*  ========================================================================
*
*  Permission to use, copy, modify, distribute, and sell this software and
*  its documentation for any purpose is hereby granted without fee,
*  provided that the above copyright notice appear in all copies and that
*  both that copyright notice and this permission notice appear in
*  supporting documentation, and that the name of the authors not be used
*  in advertising or publicity pertaining to distribution of the software
*  without specific, written prior permission.  The authors makes no
*  representations about the suitability of this software for any purpose.
*  It is provided "as is" without express or implied warranty.
*
*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
*  PERFORMANCE OF THIS SOFTWARE.
*
****************************************************************************/

#ifndef __X86EMU_X86EMU_H
#define __X86EMU_X86EMU_H

#include <sys/types.h>
#include <sys/endian.h>

#ifdef _KERNEL
#include <sys/systm.h>
#else
#include <setjmp.h>
#endif

/*
 * General EAX, EBX, ECX, EDX type registers.  Note that for
 * portability, and speed, the issue of byte swapping is not addressed
 * in the registers.  All registers are stored in the default format
 * available on the host machine.  The only critical issue is that the
 * registers should line up EXACTLY in the same manner as they do in
 * the 386.  That is:
 *
 * EAX & 0xff  === AL
 * EAX & 0xffff == AX
 *
 * etc.  The result is that alot of the calculations can then be
 * done using the native instruction set fully.
 */

#ifdef	__BIG_ENDIAN__

struct x86emu_register32 {
	uint32_t e_reg;
};

struct x86emu_register16 {
	uint16_t filler0;
	uint16_t x_reg;
};

struct x86emu_register8 {
	uint8_t filler0, filler1;
	uint8_t h_reg, l_reg;
};

#else /* !__BIG_ENDIAN__ */

struct x86emu_register32 {
	uint32_t e_reg;
};

struct x86emu_register16 {
	uint16_t x_reg;
};

struct x86emu_register8 {
	uint8_t l_reg, h_reg;
};

#endif /* BIG_ENDIAN */

union x86emu_register {
	struct x86emu_register32	I32_reg;
	struct x86emu_register16	I16_reg;
	struct x86emu_register8		I8_reg;
};

struct x86emu_regs {
	uint16_t		register_cs;
	uint16_t		register_ds;
	uint16_t		register_es;
	uint16_t		register_fs;
	uint16_t		register_gs;
	uint16_t		register_ss;
	uint32_t		register_flags;
	union x86emu_register	register_a;
	union x86emu_register	register_b;
	union x86emu_register	register_c;
	union x86emu_register	register_d;

	union x86emu_register	register_sp;
	union x86emu_register	register_bp;
	union x86emu_register	register_si;
	union x86emu_register	register_di;
	union x86emu_register	register_ip;

	/*
	 * MODE contains information on:
	 *  REPE prefix             2 bits  repe,repne
	 *  SEGMENT overrides       5 bits  normal,DS,SS,CS,ES
	 *  Delayed flag set        3 bits  (zero, signed, parity)
	 *  reserved                6 bits
	 *  interrupt #             8 bits  instruction raised interrupt
	 *  BIOS video segregs      4 bits  
	 *  Interrupt Pending       1 bits  
	 *  Extern interrupt        1 bits
	 *  Halted                  1 bits
	 */
	uint32_t		mode;
	volatile int		intr;   /* mask of pending interrupts */
	uint8_t			intno;
	uint8_t			__pad[3];
};

struct x86emu {
	char			*mem_base;
	size_t			mem_size;
	void        		*sys_private;
	struct x86emu_regs	x86;

#ifdef _KERNEL
	label_t		exec_state;
#else
	jmp_buf		exec_state;
#endif

	uint64_t	cur_cycles;

	unsigned int	cur_mod:2;
	unsigned int	cur_rl:3;
	unsigned int	cur_rh:3;
	uint32_t	cur_offset;

	uint8_t  	(*emu_rdb)(struct x86emu *, uint32_t addr);
	uint16_t 	(*emu_rdw)(struct x86emu *, uint32_t addr);
	uint32_t 	(*emu_rdl)(struct x86emu *, uint32_t addr);
	void		(*emu_wrb)(struct x86emu *, uint32_t addr,uint8_t val);
	void		(*emu_wrw)(struct x86emu *, uint32_t addr, uint16_t val);
	void		(*emu_wrl)(struct x86emu *, uint32_t addr, uint32_t val);

	uint8_t  	(*emu_inb)(struct x86emu *, uint16_t addr);
	uint16_t 	(*emu_inw)(struct x86emu *, uint16_t addr);
	uint32_t 	(*emu_inl)(struct x86emu *, uint16_t addr);
	void		(*emu_outb)(struct x86emu *, uint16_t addr, uint8_t val);
	void		(*emu_outw)(struct x86emu *, uint16_t addr, uint16_t val);
	void		(*emu_outl)(struct x86emu *, uint16_t addr, uint32_t val);

	void 		(*_x86emu_intrTab[256])(struct x86emu *, int);
};

__BEGIN_DECLS

void	x86emu_init_default(struct x86emu *);

/* decode.c */

void 	x86emu_exec(struct x86emu *);
void	x86emu_exec_call(struct x86emu *, uint16_t, uint16_t);
void	x86emu_exec_intr(struct x86emu *, uint8_t);
void 	x86emu_halt_sys(struct x86emu *) __dead;

__END_DECLS

#endif /* __X86EMU_X86EMU_H */
@


1.2
log
@option X86EMU is how this subsystem is brought into a kernel
@
text
@d2 1
a2 1
/* $OpenBSD */
@


1.1
log
@Add vga bios repost support. Fetched from the NetBSD tree mostly.

Tested on multiple i386 and it works, amd64 works also with a few
exceptions that will get fixed.

The initial effort of importing was done by oga@@, thanks!

Lots of testing and debugging by mlarkin@@ and me.
Okay deraadt@@, oga@@, mlarkin@@.
@
text
@d64 1
a64 1
struct X86EMU_register32 {
d68 1
a68 1
struct X86EMU_register16 {
d73 1
a73 1
struct X86EMU_register8 {
d80 1
a80 1
struct X86EMU_register32 {
d84 1
a84 1
struct X86EMU_register16 {
d88 1
a88 1
struct X86EMU_register8 {
d94 4
a97 4
union X86EMU_register {
	struct X86EMU_register32	I32_reg;
	struct X86EMU_register16	I16_reg;
	struct X86EMU_register8		I8_reg;
d100 1
a100 1
struct X86EMU_regs {
d108 10
a117 10
	union X86EMU_register	register_a;
	union X86EMU_register	register_b;
	union X86EMU_register	register_c;
	union X86EMU_register	register_d;

	union X86EMU_register	register_sp;
	union X86EMU_register	register_bp;
	union X86EMU_register	register_si;
	union X86EMU_register	register_di;
	union X86EMU_register	register_ip;
d137 1
a137 1
struct X86EMU {
d141 1
a141 1
	struct X86EMU_regs	x86;
d156 13
a168 13
	uint8_t  	(*emu_rdb)(struct X86EMU *, uint32_t addr);
	uint16_t 	(*emu_rdw)(struct X86EMU *, uint32_t addr);
	uint32_t 	(*emu_rdl)(struct X86EMU *, uint32_t addr);
	void		(*emu_wrb)(struct X86EMU *, uint32_t addr,uint8_t val);
	void		(*emu_wrw)(struct X86EMU *, uint32_t addr, uint16_t val);
	void		(*emu_wrl)(struct X86EMU *, uint32_t addr, uint32_t val);

	uint8_t  	(*emu_inb)(struct X86EMU *, uint16_t addr);
	uint16_t 	(*emu_inw)(struct X86EMU *, uint16_t addr);
	uint32_t 	(*emu_inl)(struct X86EMU *, uint16_t addr);
	void		(*emu_outb)(struct X86EMU *, uint16_t addr, uint8_t val);
	void		(*emu_outw)(struct X86EMU *, uint16_t addr, uint16_t val);
	void		(*emu_outl)(struct X86EMU *, uint16_t addr, uint32_t val);
d170 1
a170 1
	void 		(*_X86EMU_intrTab[256])(struct X86EMU *, int);
d175 1
a175 1
void	X86EMU_init_default(struct X86EMU *);
d179 4
a182 4
void 	X86EMU_exec(struct X86EMU *);
void	X86EMU_exec_call(struct X86EMU *, uint16_t, uint16_t);
void	X86EMU_exec_intr(struct X86EMU *, uint8_t);
void 	X86EMU_halt_sys(struct X86EMU *) __dead;
@

