head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.28
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.24
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.14
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.22
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.20
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.18
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.16
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.12
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.10
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.18.0.8
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.4
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.6
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.9.0.24
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.22
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.20
	OPENBSD_2_8:1.9.0.18
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.16
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.14
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.12
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.10
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.8
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.20
date	2010.11.11.17.54.54;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.22.12.36.32;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.09.16.42.30;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.25.14.13.40;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.13.22.00.31;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.28.02.28.43;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.03.20.27.44;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.12.08.01.03.05;	author niklas;	state Exp;
branches
	1.9.14.1
	1.9.24.1;
next	1.8;

1.8
date	96.11.23.21.47.10;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.31.01.05.13;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.00.27.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.07.31.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.13.51.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.26.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.48.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.26.18.19.32;	author deraadt;	state Exp;
branches;
next	;

1.9.14.1
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.9.14.2;

1.9.14.2
date	2003.03.28.00.38.30;	author niklas;	state Exp;
branches;
next	1.9.14.3;

1.9.14.3
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	;

1.9.24.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.9.24.2;

1.9.24.2
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.20
log
@DEC 3000/400 has a 22.5MHz TURBOchannel bus instead of the usual 25MHz;
correctly report this.

Then, in asc@@tc, compute synchronous transfer periods (involving the bus
clock) with a better accuracy.

ok krw@@
@
text
@/*	$OpenBSD: tc.c,v 1.19 2010/09/22 12:36:32 miod Exp $	*/
/*	$NetBSD: tc.c,v 1.29 2001/11/13 06:26:10 lukem Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 *
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <dev/tc/tcreg.h>
#include <dev/tc/tcvar.h>


/* Definition of the driver for autoconfig. */
int	tcmatch(struct device *, void *, void *);
void	tcattach(struct device *, struct device *, void *);

struct cfattach tc_ca = {
	sizeof(struct tc_softc), tcmatch, tcattach
};

struct cfdriver tc_cd = {
	NULL, "tc", DV_DULL
};

int	tcprint(void *, const char *);
int	tcsubmatch(struct device *, void *, void *);
int	tc_checkslot(tc_addr_t, char *);
void	tc_devinfo(const char *, char *, size_t);

int
tcmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct tcbus_attach_args *tba = aux;
	struct cfdata *cf = vcf;

	if (strcmp(tba->tba_busname, cf->cf_driver->cd_name))
		return (0);

	return (1);
}

void
tcattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct tc_softc *sc = (struct tc_softc *)self;
	struct tcbus_attach_args *tba = aux;
	struct tc_attach_args ta;
	const struct tc_builtin *builtin;
	struct tc_slotdesc *slot;
	tc_addr_t tcaddr;
	int i;

	if (tba->tba_speed & 1)
		printf(": %d.5 MHz clock\n", tba->tba_speed / 2);
	else
		printf(": %d MHz clock\n", tba->tba_speed / 2);

	/*
	 * Save important CPU/chipset information.
	 */
	sc->sc_speed = tba->tba_speed;
	sc->sc_nslots = tba->tba_nslots;
	sc->sc_slots = tba->tba_slots;
	sc->sc_intr_establish = tba->tba_intr_establish;
	sc->sc_intr_disestablish = tba->tba_intr_disestablish;
	sc->sc_get_dma_tag = tba->tba_get_dma_tag;

	/*
	 * Try to configure each built-in device
	 */
	for (i = 0; i < tba->tba_nbuiltins; i++) {
		builtin = &tba->tba_builtins[i];

		/* sanity check! */
		if (builtin->tcb_slot > sc->sc_nslots)
			panic("tcattach: builtin %d slot > nslots", i);

		/*
		 * Make sure device is really there, because some
		 * built-in devices are really optional.
		 */
		tcaddr = sc->sc_slots[builtin->tcb_slot].tcs_addr +
		    builtin->tcb_offset;
		if (tc_badaddr(tcaddr))
			continue;

		/*
		 * Set up the device attachment information.
		 */
		strncpy(ta.ta_modname, builtin->tcb_modname, TC_ROM_LLEN);
		ta.ta_memt = tba->tba_memt;
		ta.ta_dmat = (*sc->sc_get_dma_tag)(builtin->tcb_slot);
		ta.ta_modname[TC_ROM_LLEN] = '\0';
		ta.ta_slot = builtin->tcb_slot;
		ta.ta_offset = builtin->tcb_offset;
		ta.ta_addr = tcaddr;
		ta.ta_cookie = builtin->tcb_cookie;
		ta.ta_busspeed = sc->sc_speed;

		/*
		 * Mark the slot as used, so we don't check it later.
		 */
		sc->sc_slots[builtin->tcb_slot].tcs_used = 1;

		/*
		 * Attach the device.
		 */
		config_found_sm(self, &ta, tcprint, tcsubmatch);
	}

	/*
	 * Try to configure each unused slot, last to first.
	 */
	for (i = sc->sc_nslots - 1; i >= 0; i--) {
		slot = &sc->sc_slots[i];

		/* If already checked above, don't look again now. */
		if (slot->tcs_used)
			continue;

		/*
		 * Make sure something is there, and find out what it is.
		 */
		tcaddr = slot->tcs_addr;
		if (tc_badaddr(tcaddr))
			continue;
		if (tc_checkslot(tcaddr, ta.ta_modname) == 0)
			continue;

		/*
		 * Set up the rest of the attachment information.
		 */
		ta.ta_memt = tba->tba_memt;
		ta.ta_dmat = (*sc->sc_get_dma_tag)(i);
		ta.ta_slot = i;
		ta.ta_offset = 0;
		ta.ta_addr = tcaddr;
		ta.ta_cookie = slot->tcs_cookie;

		/*
		 * Mark the slot as used.
		 */
		slot->tcs_used = 1;

		/*
		 * Attach the device.
		 */
		config_found_sm(self, &ta, tcprint, tcsubmatch);
	}
}

int
tcprint(aux, pnp)
	void *aux;
	const char *pnp;
{
	struct tc_attach_args *ta = aux;
	char devinfo[256];

	if (pnp) {
		tc_devinfo(ta->ta_modname, devinfo, sizeof devinfo);
		printf("%s at %s", devinfo, pnp);
	}
	printf(" slot %d offset 0x%lx", ta->ta_slot,
	    (long)ta->ta_offset);
	return (UNCONF);
}

int
tcsubmatch(parent, vcf, aux)
	struct device *parent;
	void *vcf, *aux;
{
	struct tc_attach_args *d = aux;
	struct cfdata *cf = vcf;

	if ((cf->tccf_slot != TCCF_SLOT_UNKNOWN) &&
	    (cf->tccf_slot != d->ta_slot))
		return 0;
	if ((cf->tccf_offset != TCCF_SLOT_UNKNOWN) &&
	    (cf->tccf_offset != d->ta_offset))
		return 0;

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}


#define	NTC_ROMOFFS	2
static tc_offset_t tc_slot_romoffs[NTC_ROMOFFS] = {
	TC_SLOT_ROM,
	TC_SLOT_PROTOROM,
};

int
tc_checkslot(slotbase, namep)
	tc_addr_t slotbase;
	char *namep;
{
	struct tc_rommap *romp;
	int i, j;

	for (i = 0; i < NTC_ROMOFFS; i++) {
		romp = (struct tc_rommap *)
		    (slotbase + tc_slot_romoffs[i]);

		switch (romp->tcr_width.v) {
		case 1:
		case 2:
		case 4:
			break;

		default:
			continue;
		}

		if (romp->tcr_stride.v != 4)
			continue;

		for (j = 0; j < 4; j++)
			if (romp->tcr_test[j+0*romp->tcr_stride.v] != 0x55 ||
			    romp->tcr_test[j+1*romp->tcr_stride.v] != 0x00 ||
			    romp->tcr_test[j+2*romp->tcr_stride.v] != 0xaa ||
			    romp->tcr_test[j+3*romp->tcr_stride.v] != 0xff)
				continue;

		for (j = 0; j < TC_ROM_LLEN; j++)
			namep[j] = romp->tcr_modname[j].v;
		namep[j] = '\0';
		return (1);
	}
	return (0);
}

void
tc_intr_establish(dev, cookie, level, handler, arg, name)
	struct device *dev;
	void *cookie, *arg;
	int level;
	int (*handler)(void *);
	const char *name;
{
	struct tc_softc *sc = tc_cd.cd_devs[0];

	(*sc->sc_intr_establish)(dev, cookie, level, handler, arg, name);
}

void
tc_intr_disestablish(dev, cookie, name)
	struct device *dev;
	void *cookie;
	const char *name;
{
	struct tc_softc *sc = tc_cd.cd_devs[0];

	(*sc->sc_intr_disestablish)(dev, cookie, name);
}

#ifdef TCVERBOSE
/*
 * Descriptions of known devices.
 */
struct tc_knowndev {
	const char *id, *description;
};

#include <dev/tc/tcdevs_data.h>
#endif /* TCVERBOSE */

void
tc_devinfo(const char *id, char *cp, size_t cp_len)
{
#ifdef TCVERBOSE
	struct tc_knowndev *tdp;
	const char *description;

	/* find the device in the table, if possible. */
	description = NULL;
	for (tdp = tc_knowndevs; tdp->id != NULL; tdp++) {
		/* check this entry for a match */
		if (strcmp(tdp->id, id) == 0) {
			description = tdp->description;
			break;
		}
	}
	if (description != NULL)
		snprintf(cp, cp_len, "\"%s\" (%s)", id, description);
	else
#endif
		snprintf(cp, cp_len, "\"%s\"", id);
}
@


1.19
log
@Revert previous and let drivers register counterless interrupts;
tc_intr_disestablish() prototype is changed to carry information whether the
counter needs to be detached or not.

This does not matter much since no driver ever calls tc_intr_disestablish().
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.18 2008/08/09 16:42:30 miod Exp $	*/
d84 4
a87 2
	printf(": %s MHz clock\n",
	    tba->tba_speed == TC_SPEED_25_MHZ ? "25" : "12.5");
@


1.18
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.17 2007/06/25 14:13:40 tom Exp $	*/
d277 1
a277 1
tc_intr_disestablish(dev, cookie)
d280 1
d284 1
a284 1
	(*sc->sc_intr_disestablish)(dev, cookie);
@


1.17
log
@Fix a couple of "of of"s in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.16 2006/03/13 22:00:31 miod Exp $	*/
d264 1
a264 1
tc_intr_establish(dev, cookie, level, handler, arg)
d269 1
d273 1
a273 1
	(*sc->sc_intr_establish)(dev, cookie, level, handler, arg);
@


1.16
log
@Conforming to the party's line, report unconfigured devices as
"TC identifier" (description) at tc0 ... unconfigured
instead of
drivername (description) at tc0 ... unconfigured

Plus this allows us to shrinken the description structure and get rid of
a generated file. Only affects TCVERBOSE kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.15 2004/06/28 02:28:43 aaron Exp $	*/
d287 1
a287 1
 * Descriptions of of known devices.
@


1.15
log
@Use new event counter API for interrupt counting on alpha.  By me, with some
edits by Theo.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.14 2003/04/27 11:22:54 ho Exp $	*/
a36 1
#include <dev/tc/tcdevs.h>
d290 1
a290 1
	const char *id, *driver, *description;
a298 1
	const char *driver;
a300 1
	int match;
a301 3
#endif

	driver = NULL;
a302 1
#ifdef TCVERBOSE
d305 1
a305 2
	tdp = tc_knowndevs;
	while (tdp->id != NULL) {
d307 1
a307 3
		match = !strcmp(tdp->id, id);
		if (match) {
			driver = tdp->driver;
a310 1
		tdp++;
d312 2
a313 2
	if (driver != NULL)
		snprintf(cp, cp_len, "%s (%s)", driver, description);
d316 1
a316 1
		snprintf(cp, cp_len, "%s", id);
@


1.14
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.13 2002/05/03 20:27:44 miod Exp $	*/
a93 1
	sc->sc_intr_evcnt = tba->tba_intr_evcnt;
a261 8
}

const struct evcnt *
tc_intr_evcnt(struct device *dev, void *cookie)
{
	struct tc_softc *sc = tc_cd.cd_devs[0];

	return ((*sc->sc_intr_evcnt)(dev, cookie));
@


1.13
log
@Add more cards and device names, and print better looking probe messages for
unknown cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.12 2002/05/02 22:56:06 miod Exp $	*/
d55 1
a55 1
void	tc_devinfo(const char *, char *);
d192 1
a192 1
		tc_devinfo(ta->ta_modname, devinfo);
d307 1
a307 3
tc_devinfo(id, cp)
	const char *id;
	char *cp;
d333 1
a333 1
		cp += sprintf(cp, "%s (%s)", driver, description);
d336 1
a336 1
		cp += sprintf(cp, "%s", id);
@


1.12
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d311 1
a311 1
	const char *driver, *description;
d315 1
a315 3
	const char *unmatched = "unknown ";
#else
	const char *unmatched = "";
a318 1
	description = id;
d322 1
d334 3
d338 1
a338 5

	if (driver == NULL)
		cp += sprintf(cp, "%sdevice %s", unmatched, id);
	else
		cp += sprintf(cp, "%s (%s)", driver, description);
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: tc.c,v 1.10 2002/03/14 01:27:03 millert Exp $	*/
/*	$NetBSD: tc.c,v 1.20 1996/10/22 21:37:29 cgd Exp $	*/
a38 13
#include <machine/autoconf.h>	/* for the proto of badaddr() */

struct tc_softc {
	struct	device sc_dv;

	int	sc_speed;
	int	sc_nslots;
	struct tc_slotdesc *sc_slots;

	void	(*sc_intr_establish)(struct device *, void *,
		    tc_intrlevel_t, int (*)(void *), void *);
	void	(*sc_intr_disestablish)(struct device *, void *);
};
d58 1
a58 1
tcmatch(parent, cfdata, aux)
d60 1
a60 2
	void *cfdata;
	void *aux;
a61 1
	struct cfdata *cf = cfdata;
d63 1
d94 1
d97 1
a121 1
#ifdef __alpha__ /* XXX */
d123 1
a123 1
#endif
d164 2
d201 1
a201 1
tcsubmatch(parent, match, aux)
d203 1
a203 1
	void *match, *aux;
a204 1
	struct cfdata *cf = match;
d206 1
d215 1
a215 1
	return ((*cf->cf_attach->ca_match)(parent, match, aux));
d265 8
d277 1
a277 1
	tc_intrlevel_t level;
d280 1
a280 1
	struct tc_softc *sc = (struct tc_softc *)dev;
d282 1
a282 2
	(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level,
	    handler, arg);
d290 1
a290 1
	struct tc_softc *sc = (struct tc_softc *)dev;
d292 1
a292 1
	(*sc->sc_intr_disestablish)(sc->sc_dv.dv_parent, cookie);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.9 1996/12/08 01:03:05 niklas Exp $	*/
d48 2
a49 2
	void	(*sc_intr_establish) __P((struct device *, void *,
		    tc_intrlevel_t, int (*)(void *), void *));
@


1.9
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.8 1996/11/23 21:47:10 kstailey Exp $	*/
d50 1
a50 1
	void	(*sc_intr_disestablish) __P((struct device *, void *));
d54 2
a55 2
int	tcmatch __P((struct device *, void *, void *));
void	tcattach __P((struct device *, struct device *, void *));
d65 4
a68 4
int	tcprint __P((void *, const char *));
int	tcsubmatch __P((struct device *, void *, void *));
int	tc_checkslot __P((tc_addr_t, char *));
void	tc_devinfo __P((const char *, char *));
d281 1
a281 1
	int (*handler) __P((void *));
@


1.9.24.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tc.c,v 1.29 2001/11/13 06:26:10 lukem Exp $	*/
d39 13
d54 2
a55 2
int	tcmatch(struct device *, void *, void *);
void	tcattach(struct device *, struct device *, void *);
d65 4
a68 4
int	tcprint(void *, const char *);
int	tcsubmatch(struct device *, void *, void *);
int	tc_checkslot(tc_addr_t, char *);
void	tc_devinfo(const char *, char *);
d71 1
a71 1
tcmatch(parent, vcf, aux)
d73 2
a74 1
	void *vcf, *aux;
d76 1
a77 1
	struct cfdata *cf = vcf;
a107 1
	sc->sc_intr_evcnt = tba->tba_intr_evcnt;
a109 1
	sc->sc_get_dma_tag = tba->tba_get_dma_tag;
d134 1
d136 1
a136 1
		ta.ta_dmat = (*sc->sc_get_dma_tag)(builtin->tcb_slot);
a176 2
		ta.ta_memt = tba->tba_memt;
		ta.ta_dmat = (*sc->sc_get_dma_tag)(i);
d212 1
a212 1
tcsubmatch(parent, vcf, aux)
d214 1
a214 1
	void *vcf, *aux;
d216 1
a217 1
	struct cfdata *cf = vcf;
d226 1
a226 1
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
a275 8
const struct evcnt *
tc_intr_evcnt(struct device *dev, void *cookie)
{
	struct tc_softc *sc = tc_cd.cd_devs[0];

	return ((*sc->sc_intr_evcnt)(dev, cookie));
}

d280 2
a281 2
	int level;
	int (*handler)(void *);
d283 1
a283 1
	struct tc_softc *sc = tc_cd.cd_devs[0];
d285 2
a286 1
	(*sc->sc_intr_establish)(dev, cookie, level, handler, arg);
d294 1
a294 1
	struct tc_softc *sc = tc_cd.cd_devs[0];
d296 1
a296 1
	(*sc->sc_intr_disestablish)(dev, cookie);
d315 1
a315 1
	const char *driver;
d319 3
a321 1
	const char *description;
d325 1
a328 1
	description = NULL;
d340 5
a344 1
	if (driver != NULL)
a345 3
	else
#endif
		cp += sprintf(cp, "%s", id);
@


1.9.24.2
log
@sync
@
text
@d55 1
a55 1
void	tc_devinfo(const char *, char *, size_t);
d192 1
a192 1
		tc_devinfo(ta->ta_modname, devinfo, sizeof devinfo);
d307 3
a309 1
tc_devinfo(const char *id, char *cp, size_t cp_len)
d335 1
a335 1
		snprintf(cp, cp_len, "%s (%s)", driver, description);
d338 1
a338 1
		snprintf(cp, cp_len, "%s", id);
@


1.9.14.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 3
a50 3
	void	(*sc_intr_establish)(struct device *, void *,
		    tc_intrlevel_t, int (*)(void *), void *);
	void	(*sc_intr_disestablish)(struct device *, void *);
d54 2
a55 2
int	tcmatch(struct device *, void *, void *);
void	tcattach(struct device *, struct device *, void *);
d65 4
a68 4
int	tcprint(void *, const char *);
int	tcsubmatch(struct device *, void *, void *);
int	tc_checkslot(tc_addr_t, char *);
void	tc_devinfo(const char *, char *);
d281 1
a281 1
	int (*handler)(void *);
@


1.9.14.2
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: tc.c,v 1.29 2001/11/13 06:26:10 lukem Exp $	*/
d39 13
d71 1
a71 1
tcmatch(parent, vcf, aux)
d73 2
a74 1
	void *vcf, *aux;
d76 1
a77 1
	struct cfdata *cf = vcf;
a107 1
	sc->sc_intr_evcnt = tba->tba_intr_evcnt;
a109 1
	sc->sc_get_dma_tag = tba->tba_get_dma_tag;
d134 1
d136 1
a136 1
		ta.ta_dmat = (*sc->sc_get_dma_tag)(builtin->tcb_slot);
a176 2
		ta.ta_memt = tba->tba_memt;
		ta.ta_dmat = (*sc->sc_get_dma_tag)(i);
d212 1
a212 1
tcsubmatch(parent, vcf, aux)
d214 1
a214 1
	void *vcf, *aux;
d216 1
a217 1
	struct cfdata *cf = vcf;
d226 1
a226 1
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
a275 8
const struct evcnt *
tc_intr_evcnt(struct device *dev, void *cookie)
{
	struct tc_softc *sc = tc_cd.cd_devs[0];

	return ((*sc->sc_intr_evcnt)(dev, cookie));
}

d280 1
a280 1
	int level;
d283 1
a283 1
	struct tc_softc *sc = tc_cd.cd_devs[0];
d285 2
a286 1
	(*sc->sc_intr_establish)(dev, cookie, level, handler, arg);
d294 1
a294 1
	struct tc_softc *sc = tc_cd.cd_devs[0];
d296 1
a296 1
	(*sc->sc_intr_disestablish)(dev, cookie);
d315 1
a315 1
	const char *driver;
d319 3
a321 1
	const char *description;
d325 1
a328 1
	description = NULL;
d340 5
a344 1
	if (driver != NULL)
a345 3
	else
#endif
		cp += sprintf(cp, "%s", id);
@


1.9.14.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.9.14.2 2003/03/28 00:38:30 niklas Exp $	*/
d55 1
a55 1
void	tc_devinfo(const char *, char *, size_t);
d192 1
a192 1
		tc_devinfo(ta->ta_modname, devinfo, sizeof devinfo);
d307 3
a309 1
tc_devinfo(const char *id, char *cp, size_t cp_len)
d335 1
a335 1
		snprintf(cp, cp_len, "%s (%s)", driver, description);
d338 1
a338 1
		snprintf(cp, cp_len, "%s", id);
@


1.8
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: tc.c,v 1.7 1996/10/31 01:05:13 niklas Exp $	*/
/*	$NetBSD: tc.c,v 1.16 1996/05/17 23:39:19 cgd Exp $	*/
d135 1
a135 1
		ta.ta_bc = tba->tba_bc;
@


1.7
log
@-Wall fixes needed by alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.6 1996/05/26 00:27:54 deraadt Exp $	*/
d65 1
a65 1
int	tcprint __P((void *, char *));
d197 1
a197 1
	char *pnp;
@


1.6
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: tc.c,v 1.5 1996/05/07 07:31:39 deraadt Exp $	*/
d38 2
@


1.5
log
@add :
@
text
@d1 2
a2 2
/*	$OpenBSD: tc.c,v 1.3 1996/04/21 22:26:28 deraadt Exp $	*/
/*	$NetBSD: tc.c,v 1.15 1996/04/29 16:06:38 cgd Exp $	*/
d132 3
@


1.4
log
@make these work together
@
text
@d2 1
a2 1
/*	$NetBSD: tc.c,v 1.14 1996/04/18 01:12:41 cgd Exp $	*/
d97 1
a97 1
	printf("%s MHz clock\n",
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: tc.c,v 1.2 1996/04/18 23:48:22 niklas Exp $	*/
/*	$NetBSD: tc.c,v 1.13 1996/04/09 20:50:06 jonathan Exp $	*/
d9 1
a9 1
 * 
d15 3
a17 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d19 1
a19 1
 * 
a38 2
#include <machine/autoconf.h>

a79 2
	/* XXX check other indicators */

d138 1
a138 1
	
d199 1
a199 1
		printf("%s at %s", devinfo, pnp);  
d206 4
a209 4
int   
tcsubmatch(parent, match, aux) 
        struct device *parent;
        void *match, *aux; 
d280 1
a280 1
	(*sc->sc_intr_establish)(sc->sc_dv.dv_parent, cookie, level, 
d295 1
a295 1
/*      
d297 1
a297 1
 */     
d300 1
a300 1
};      
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tc.c,v 1.10 1996/03/05 23:15:07 cgd Exp $	*/
d32 1
d39 2
d56 8
a63 2
struct cfdriver tccd =
    { NULL, "tc", tcmatch, tcattach, DV_DULL, sizeof (struct tc_softc) };
a98 1
	void *match;
d225 1
a225 1
	return ((*cf->cf_driver->cd_match)(parent, match, aux));
@


1.1
log
@from netbsd:
machine-independent TurboChannel bus configuration.  These files
deal with stuff like:
        (1) configuring built-in devices,
        (2) looking at TC slots configuring any devices found.
The lists of slots, slot locations, etc. and built-in devices
are provided by machine-dependent code.  Interrupt handling
is also provided by machine-dependent code, but the MD code provides
hooks so that standard names for 'establish' and 'disestablish'
can be used in drivers.
@
text
@d1 2
a2 1
/*	$NetBSD: tc.c,v 1.1 1995/12/20 00:48:32 cgd Exp $	*/
d36 1
d41 1
d57 1
d59 1
d67 7
d85 2
a86 2
	struct tc_attach_args *tc = aux;
	struct tcdev_attach_args tcdev;
d90 1
d93 2
a94 1
	printf("\n");
d99 5
a103 4
	sc->sc_nslots = tc->tca_nslots;
	sc->sc_slots = tc->tca_slots;
	sc->sc_intr_establish = tc->tca_intr_establish;
	sc->sc_intr_disestablish = tc->tca_intr_disestablish;
d108 2
a109 2
	for (i = 0; i < tc->tca_nbuiltins; i++) {
		builtin = &tc->tca_builtins[i];
d127 7
a133 6
		strncpy(tcdev.tcda_modname, builtin->tcb_modname, TC_ROM_LLEN);
		tcdev.tcda_modname[TC_ROM_LLEN] = '\0';
		tcdev.tcda_slot = builtin->tcb_slot;
		tcdev.tcda_offset = builtin->tcb_offset;
		tcdev.tcda_addr = tcaddr;
		tcdev.tcda_cookie = builtin->tcb_cookie;
d143 1
a143 1
		config_found(self, &tcdev, tcprint);
d162 1
a162 1
		if (tc_checkslot(tcaddr, tcdev.tcda_modname) == 0)
d168 4
a171 4
		tcdev.tcda_slot = i;
		tcdev.tcda_offset = 0;
		tcdev.tcda_addr = tcaddr;
		tcdev.tcda_cookie = slot->tcs_cookie;
d181 1
a181 1
		config_found(self, &tcdev, tcprint);
d190 2
a191 1
	struct tcdev_attach_args *tcdev = aux;
d193 7
a199 5
        if (pnp)
                printf("%s at %s", tcdev->tcda_modname, pnp);	/* XXX */
        printf(" slot %d offset 0x%lx", tcdev->tcda_slot,
	    (long)tcdev->tcda_offset);
        return (UNCONF);
d202 4
a205 4
int
tc_submatch(match, d)
	struct cfdata *match;
	struct tcdev_attach_args *d;
d207 2
d210 8
a217 4
	return (((match->tccf_slot == d->tcda_slot) ||
		 (match->tccf_slot == TCCF_SLOT_UNKNOWN)) &&
		((match->tccf_offset == d->tcda_offset) ||
		 (match->tccf_offset == TCCF_OFFSET_UNKNOWN)));
d288 49
@
