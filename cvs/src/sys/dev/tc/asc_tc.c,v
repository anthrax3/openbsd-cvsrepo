head	1.12;
access;
symbols
	OPENBSD_6_0:1.12.0.12
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.10
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.8
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.6
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.4
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.22
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.20
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.18
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.16
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.14
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.12
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.10
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.8
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	UBC_SYNC_B:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	UBC:1.6.0.2
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.14
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2010.11.11.17.54.54;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.09.16.42.30;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.06.27.20.23.37;	author miod;	state dead;
branches;
next	1.4;

1.4
date	2001.06.25.15.27.59;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	98.05.18.00.25.09;	author millert;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	97.11.07.08.07.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.12.08.14.13.08;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2001.07.04.10.43.35;	author niklas;	state dead;
branches;
next	1.3.8.2;

1.3.8.2
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.12
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@/* $OpenBSD: asc_tc.c,v 1.11 2010/11/11 17:54:54 miod Exp $ */
/* $NetBSD: asc_tc.c,v 1.19 2001/11/15 09:48:19 lukem Exp $ */

/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tohru Nishimura.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>

#include <machine/bus.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>
#include <dev/tc/ascvar.h>

#include <dev/tc/tcvar.h>

struct asc_tc_softc {
	struct asc_softc asc;

	/* XXX XXX XXX */
	caddr_t sc_base, sc_bounce, sc_target;
};

int  asc_tc_match(struct device *, void *, void *);
void asc_tc_attach(struct device *, struct device *, void *);

struct cfattach asc_tc_ca = {
	sizeof(struct asc_tc_softc), asc_tc_match, asc_tc_attach
};

int	asc_dma_isintr(struct ncr53c9x_softc *);
void	asc_tc_reset(struct ncr53c9x_softc *);
int	asc_tc_intr(struct ncr53c9x_softc *);
int	asc_tc_setup(struct ncr53c9x_softc *, caddr_t *,
						size_t *, int, size_t *);
void	asc_tc_go(struct ncr53c9x_softc *);
void	asc_tc_stop(struct ncr53c9x_softc *);
int	asc_dma_isactive(struct ncr53c9x_softc *);
void	asc_clear_latched_intr(struct ncr53c9x_softc *);

struct ncr53c9x_glue asc_tc_glue = {
        asc_read_reg,
        asc_write_reg,
        asc_dma_isintr,
        asc_tc_reset,
        asc_tc_intr,
        asc_tc_setup,
        asc_tc_go,
        asc_tc_stop,
        asc_dma_isactive,
        asc_clear_latched_intr,
};

/*
 * Parameters specific to PMAZ-A TC option card.
 */
#define PMAZ_OFFSET_53C94	0x0		/* from module base */
#define PMAZ_OFFSET_DMAR	0x40000		/* DMA Address Register */
#define PMAZ_OFFSET_RAM		0x80000		/* 128KB SRAM buffer */
#define PMAZ_OFFSET_ROM		0xc0000		/* diagnostic ROM */

#define PMAZ_RAM_SIZE		0x20000		/* 128k (32k*32) */
#define PER_TGT_DMA_SIZE	((PMAZ_RAM_SIZE/7) & ~(sizeof(int)-1))

#define PMAZ_DMAR_WRITE		0x80000000	/* DMA direction bit */
#define PMAZ_DMAR_MASK		0x1ffff		/* 17 bits, 128k */
#define PMAZ_DMA_ADDR(x)	((unsigned long)(x) & PMAZ_DMAR_MASK)

int
asc_tc_match(parent, cfdata, aux)
	struct device *parent;
	void *cfdata, *aux;
{
	struct tc_attach_args *d = aux;
	
	if (strncmp("PMAZ-AA ", d->ta_modname, TC_ROM_LLEN))
		return (0);

	return (1);
}

void
asc_tc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct tc_attach_args *ta = aux;
	struct asc_tc_softc *asc = (struct asc_tc_softc *)self;	
	struct ncr53c9x_softc *sc = &asc->asc.sc_ncr53c9x;

	/*
	 * Set up glue for MI code early; we use some of it here.
	 */
	sc->sc_glue = &asc_tc_glue;
	asc->asc.sc_bst = ta->ta_memt;
	asc->asc.sc_dmat = ta->ta_dmat;
	if (bus_space_map(asc->asc.sc_bst, ta->ta_addr,
		PMAZ_OFFSET_RAM + PMAZ_RAM_SIZE, 0, &asc->asc.sc_bsh)) {
		printf("%s: unable to map device\n", sc->sc_dev.dv_xname);
		return;
	}
	asc->sc_base = (caddr_t)ta->ta_addr;	/* XXX XXX XXX */

	tc_intr_establish(parent, ta->ta_cookie, IPL_BIO, ncr53c9x_intr, sc,
	    self->dv_xname);
	
	sc->sc_id = 7;
	sc->sc_freq = TC_SPEED_TO_KHZ(ta->ta_busspeed);	/* in kHz so far */

	/*
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
	 */

	/*
	 * Set up static configuration info.
	 */
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2;
	sc->sc_cfg3 = 0;
	sc->sc_rev = NCR_VARIANT_NCR53C94;

	/*
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
	 */

	/*
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in kHz, we have the following
	 * formula: 4 * period = (1000000 / freq) * 4
	 */
	sc->sc_minsync = (1000000 / sc->sc_freq) * 5 / 4;

	sc->sc_maxxfer = 64 * 1024;

	/* convert sc_freq to MHz */
	sc->sc_freq /= 1000;

	/* Do the common parts of attachment. */
	ncr53c9x_attach(sc);
}

void
asc_tc_reset(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	asc->asc.sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);
}

int
asc_tc_intr(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	int trans, resid;

	resid = 0;
	if ((asc->asc.sc_flags & ASC_ISPULLUP) == 0 &&
	    (resid = (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		NCR_DMA(("asc_tc_intr: empty FIFO of %d ", resid));
		DELAY(1);
	}

	resid += NCR_READ_REG(sc, NCR_TCL);
	resid += NCR_READ_REG(sc, NCR_TCM) << 8;

	trans = asc->asc.sc_dmasize - resid;

	if (asc->asc.sc_flags & ASC_ISPULLUP)
		memcpy(asc->sc_target, asc->sc_bounce, trans);
	*asc->asc.sc_dmalen -= trans;
	*asc->asc.sc_dmaaddr += trans;
	asc->asc.sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);

	return (0);
}

int
asc_tc_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	u_int32_t tc_dmar;
	size_t size;

	asc->asc.sc_dmaaddr = addr;
	asc->asc.sc_dmalen = len;
	asc->asc.sc_flags = (datain) ? ASC_ISPULLUP : 0;

	NCR_DMA(("asc_tc_setup: start %ld@@%p, %s\n", (long)*asc->asc.sc_dmalen,
		*asc->asc.sc_dmaaddr, datain ? "IN" : "OUT"));

	size = *dmasize;
	if (size > PER_TGT_DMA_SIZE)
		size = PER_TGT_DMA_SIZE;
	*dmasize = asc->asc.sc_dmasize = size;

	NCR_DMA(("asc_tc_setup: dmasize = %ld\n", (long)asc->asc.sc_dmasize));

	asc->sc_bounce = asc->sc_base + PMAZ_OFFSET_RAM;
	asc->sc_bounce += PER_TGT_DMA_SIZE *
	    sc->sc_nexus->xs->sc_link->target;
	asc->sc_target = *addr;

	if ((asc->asc.sc_flags & ASC_ISPULLUP) == 0)
		memcpy(asc->sc_bounce, asc->sc_target, size);

#if 1
	if (asc->asc.sc_flags & ASC_ISPULLUP)
		tc_dmar = PMAZ_DMA_ADDR(asc->sc_bounce);
	else
		tc_dmar = PMAZ_DMAR_WRITE | PMAZ_DMA_ADDR(asc->sc_bounce);
	bus_space_write_4(asc->asc.sc_bst, asc->asc.sc_bsh, PMAZ_OFFSET_DMAR,
	    tc_dmar);
	asc->asc.sc_flags |= ASC_MAPLOADED|ASC_DMAACTIVE;
#endif
	return (0);
}

void
asc_tc_go(sc)
	struct ncr53c9x_softc *sc;
{
#if 0
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	u_int32_t tc_dmar;

	if (asc->asc.sc_flags & ASC_ISPULLUP)
		tc_dmar = PMAZ_DMA_ADDR(asc->sc_bounce);
	else
		tc_dmar = PMAZ_DMAR_WRITE | PMAZ_DMA_ADDR(asc->sc_bounce);
	bus_space_write_4(asc->asc.sc_bst, asc->asc.sc_bsh, PMAZ_OFFSET_DMAR,
	    tc_dmar);
	asc->asc.sc_flags |= ASC_DMAACTIVE;
#endif
}

/* NEVER CALLED BY MI 53C9x ENGINE INDEED */
void
asc_tc_stop(sc)
	struct ncr53c9x_softc *sc;
{
#if 0
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	if (asc->asc.sc_flags & ASC_ISPULLUP)
		memcpy(asc->sc_target, asc->sc_bounce, asc->sc_dmasize);
	asc->asc.sc_flags &= ~ASC_DMAACTIVE;
#endif
}

/*
 * Glue functions.
 */
int
asc_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
{
	return !!(NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT);
}

int
asc_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	return !!(asc->asc.sc_flags & ASC_DMAACTIVE);
}

void
asc_clear_latched_intr(sc)
	struct ncr53c9x_softc *sc;
{
}
@


1.11
log
@DEC 3000/400 has a 22.5MHz TURBOchannel bus instead of the usual 25MHz;
correctly report this.

Then, in asc@@tc, compute synchronous transfer periods (involving the bus
clock) with a better accuracy.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: asc_tc.c,v 1.10 2010/06/28 18:31:02 krw Exp $ */
a63 2
extern struct scsi_adapter asc_switch;

d180 1
a180 1
	ncr53c9x_attach(sc, &asc_switch);
@


1.10
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asc_tc.c,v 1.9 2008/08/09 16:42:30 miod Exp $ */
d143 1
a143 4
	sc->sc_freq = (ta->ta_busspeed) ? 25000000 : 12500000;

	/* gimme MHz */
	sc->sc_freq /= 1000000;
d171 2
a172 2
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
d174 1
a174 1
	sc->sc_minsync = (1000 / sc->sc_freq) * 5 / 4;
d177 3
@


1.9
log
@Pass a device name to {tc,tcds,ioasic}_intr_establish in order to get
meaningful names associated to the interrupt counters.
@
text
@d1 1
a1 1
/* $OpenBSD: asc_tc.c,v 1.8 2008/06/26 05:42:18 ray Exp $ */
a64 1
extern struct scsi_device asc_dev;
d182 1
a182 1
	ncr53c9x_attach(sc, &asc_switch, &asc_dev);
@


1.8
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: asc_tc.c,v 1.7 2003/02/11 19:20:28 mickey Exp $ */
d140 2
a141 1
	tc_intr_establish(parent, ta->ta_cookie, IPL_BIO, ncr53c9x_intr, sc);
@


1.7
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/* $OpenBSD: asc_tc.c,v 1.6 2002/05/02 22:56:06 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.6
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d152 1
a152 1
	/* gimme Mhz */
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@@


1.6.2.2
log
@sync
@
text
@d152 1
a152 1
	/* gimme MHz */
@


1.5
log
@More pmax files are leaving the party.
@
text
@d1 2
a2 2
/*	$OpenBSD: asc_tc.c,v 1.4 2001/06/25 15:27:59 aaron Exp $	*/
/*	$NetBSD: asc_tc.c,v 1.8 1997/10/31 06:29:59 jonathan Exp $	*/
d4 6
a9 3
/*
 * Copyright 1996 The Board of Trustees of The Leland Stanford
 * Junior University. All Rights Reserved.
d11 15
a25 7
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  Stanford University
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
d27 11
a41 2
#include <sys/timeout.h>
#include <sys/types.h>
d43 5
a47 3
#include <dev/tc/tcvar.h>
#include <machine/autoconf.h>
#include <dev/tc/ioasicvar.h>
d49 1
a49 2
#include <pmax/dev/device.h>	/* XXX */
#include <pmax/dev/scsi.h>	/* XXX */
d51 2
a52 1
#include <pmax/dev/ascreg.h>	/* XXX */
d55 4
a58 1
/*XXX*/
d60 3
d64 2
a65 5
/*
 * Autoconfiguration data for config.
 */
int asc_tc_match __P((struct device *, void *, void *));
void asc_tc_attach __P((struct device *, struct device *, void *));
d68 27
a94 1
	sizeof(struct asc_softc), asc_tc_match, asc_tc_attach
d98 1
a98 1
 * DMA callbacks
d100 11
a110 9

static int
tc_dma_start __P((struct asc_softc *asc, struct scsi_state *state,
		  caddr_t cp, int flag, int len, int off));

static void
tc_dma_end __P((struct asc_softc *asc, struct scsi_state *state,
		int flag));

d113 1
a113 1
asc_tc_match(parent, match, aux)
d115 1
a115 2
	void *match;
	void *aux;
d117 3
a119 9
	struct tc_attach_args *t = aux;
	void *ascaddr;

	if (strncmp(t->ta_modname, "PMAZ-AA ", TC_ROM_LLEN))
		return (0);

	ascaddr = (void*)t->ta_addr;

	if (tc_badaddr(ascaddr + ASC_OFFSET_53C94))
a124 2


d127 1
a127 2
	struct device *parent;
	struct device *self;
d130 4
a133 12
	register struct tc_attach_args *t = aux;
	register asc_softc_t asc = (asc_softc_t) self;
	u_char *buff;
	int i, speed;

	void *ascaddr;
	int unit;

	/* Use uncached address for chip registers.  */
	ascaddr = (void*)MIPS_PHYS_TO_KSEG1(t->ta_addr);
	unit = asc->sc_dev.dv_unit;
	
d135 1
a135 1
	 * Initialize hw descriptor, cache some pointers
d137 17
a153 1
	asc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);
d156 3
a158 3
	 * Set up machine dependencies.
	 * (1) how to do dma
	 * (2) timing based on turbochannel frequency
d162 1
a162 1
	 * Fall through for turbochannel option.
d164 4
a167 2
	asc->dmar = (volatile int *)(ascaddr + ASC_OFFSET_DMAR);
	buff = (u_char *)(ascaddr + ASC_OFFSET_RAM);
d170 3
a172 3
	 * Statically partition the DMA buffer between targets.
	 * This way we will eventually be able to attach/detach
	 * drives on-fly.  And 18k/target is plenty for normal use.
d176 7
a182 2
	 * Give each target its own DMA buffer region.
	 * We may want to try ping ponging buffers later.
d184 41
a224 2
	for (i = 0; i < ASC_NCMD; i++)
		asc->st[i].dmaBufAddr = buff + PER_TGT_DMA_SIZE * i;
d226 48
a273 2
	asc->dma_start = tc_dma_start;
	asc->dma_end = tc_dma_end;
d275 7
a281 5
	/*
	 * Now for timing. The 3max has a 25Mhz tb whereas the 3min and
	 * maxine are 12.5Mhz.
	 */
	printf(" (bus speed: %s MHz) ", t->ta_busspeed? "25"  : "12.5");
d283 8
a290 18
	switch (t->ta_busspeed) {
	case TC_SPEED_25_MHZ:
		speed = ASC_SPEED_25_MHZ;
		break;

	default:
		printf(" (unknown TC speed, assuming 12.5MHz) ");
		/* FALLTHROUGH*/
	case TC_SPEED_12_5_MHZ:
		speed = ASC_SPEED_12_5_MHZ;
		break;
	};

	ascattach(asc, speed);

	/* tie pseudo-slot to device */
	tc_intr_establish(parent, t->ta_cookie, TC_IPL_BIO,
			  asc_intr, asc);
d293 13
d308 1
a308 2
 * DMA handling routines. For a turbochannel device, just set the dmar.
 * For the I/O ASIC, handle the actual DMA interface.
d310 14
a323 19
static int
tc_dma_start(asc, state, cp, flag, len, off)
	asc_softc_t asc;
	State *state;
	caddr_t cp;
	int flag;
	int len;
	int off;
{

	if (len > PER_TGT_DMA_SIZE)
		len = PER_TGT_DMA_SIZE;
	if (flag == ASCDMA_WRITE)
		bcopy(cp, state->dmaBufAddr + off, len);
	if (flag == ASCDMA_WRITE)
		*asc->dmar = ASC_DMAR_WRITE | ASC_DMA_ADDR(state->dmaBufAddr + off);
	else
		*asc->dmar = ASC_DMA_ADDR(state->dmaBufAddr + off);
	return (len);
d326 3
a328 5
static void
tc_dma_end(asc, state, flag)
	asc_softc_t asc;
	State *state;
	int flag;
a329 2
	if (flag == ASCDMA_READ)
		bcopy(state->dmaBufAddr, state->buf, state->dmalen);
@


1.4
log
@Convert to new timeouts; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_tc.c,v 1.3 1998/05/18 00:25:09 millert Exp $	*/
@


1.3
log
@newer asc driver from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_tc.c,v 1.2 1997/11/07 08:07:44 niklas Exp $	*/
d20 1
@


1.3.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_tc.c,v 1.3 1998/05/18 00:25:09 millert Exp $	*/
@


1.3.8.2
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: asc_tc.c,v 1.19 2001/11/15 09:48:19 lukem Exp $ */
d4 3
a6 6
/*-
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Tohru Nishimura.
d8 7
a14 15
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
a15 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d20 1
d22 3
a24 5
#include <sys/buf.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_message.h>
d26 2
a27 1
#include <machine/bus.h>
d29 1
a29 2
#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>
d32 1
a32 1
#include <dev/tc/tcvar.h>
a33 2
struct asc_tc_softc {
	struct asc_softc asc;
d35 5
a39 6
	/* XXX XXX XXX */
	caddr_t sc_base, sc_bounce, sc_target;
};

int  asc_tc_match(struct device *, void *, void *);
void asc_tc_attach(struct device *, struct device *, void *);
d42 1
a42 1
	sizeof(struct asc_tc_softc), asc_tc_match, asc_tc_attach
d45 3
a47 2
extern struct scsi_adapter asc_switch;
extern struct scsi_device asc_dev;
d49 7
a55 22
int	asc_dma_isintr(struct ncr53c9x_softc *);
void	asc_tc_reset(struct ncr53c9x_softc *);
int	asc_tc_intr(struct ncr53c9x_softc *);
int	asc_tc_setup(struct ncr53c9x_softc *, caddr_t *,
						size_t *, int, size_t *);
void	asc_tc_go(struct ncr53c9x_softc *);
void	asc_tc_stop(struct ncr53c9x_softc *);
int	asc_dma_isactive(struct ncr53c9x_softc *);
void	asc_clear_latched_intr(struct ncr53c9x_softc *);

struct ncr53c9x_glue asc_tc_glue = {
        asc_read_reg,
        asc_write_reg,
        asc_dma_isintr,
        asc_tc_reset,
        asc_tc_intr,
        asc_tc_setup,
        asc_tc_go,
        asc_tc_stop,
        asc_dma_isactive,
        asc_clear_latched_intr,
};
a56 14
/*
 * Parameters specific to PMAZ-A TC option card.
 */
#define PMAZ_OFFSET_53C94	0x0		/* from module base */
#define PMAZ_OFFSET_DMAR	0x40000		/* DMA Address Register */
#define PMAZ_OFFSET_RAM		0x80000		/* 128KB SRAM buffer */
#define PMAZ_OFFSET_ROM		0xc0000		/* diagnostic ROM */

#define PMAZ_RAM_SIZE		0x20000		/* 128k (32k*32) */
#define PER_TGT_DMA_SIZE	((PMAZ_RAM_SIZE/7) & ~(sizeof(int)-1))

#define PMAZ_DMAR_WRITE		0x80000000	/* DMA direction bit */
#define PMAZ_DMAR_MASK		0x1ffff		/* 17 bits, 128k */
#define PMAZ_DMA_ADDR(x)	((unsigned long)(x) & PMAZ_DMAR_MASK)
d59 1
a59 1
asc_tc_match(parent, cfdata, aux)
d61 2
a62 1
	void *cfdata, *aux;
d64 9
a72 3
	struct tc_attach_args *d = aux;
	
	if (strncmp("PMAZ-AA ", d->ta_modname, TC_ROM_LLEN))
d78 2
d82 2
a83 1
	struct device *parent, *self;
d86 12
a97 4
	struct tc_attach_args *ta = aux;
	struct asc_tc_softc *asc = (struct asc_tc_softc *)self;	
	struct ncr53c9x_softc *sc = &asc->asc.sc_ncr53c9x;

d99 1
a99 1
	 * Set up glue for MI code early; we use some of it here.
d101 1
a101 17
	sc->sc_glue = &asc_tc_glue;
	asc->asc.sc_bst = ta->ta_memt;
	asc->asc.sc_dmat = ta->ta_dmat;
	if (bus_space_map(asc->asc.sc_bst, ta->ta_addr,
		PMAZ_OFFSET_RAM + PMAZ_RAM_SIZE, 0, &asc->asc.sc_bsh)) {
		printf("%s: unable to map device\n", sc->sc_dev.dv_xname);
		return;
	}
	asc->sc_base = (caddr_t)ta->ta_addr;	/* XXX XXX XXX */

	tc_intr_establish(parent, ta->ta_cookie, IPL_BIO, ncr53c9x_intr, sc);
	
	sc->sc_id = 7;
	sc->sc_freq = (ta->ta_busspeed) ? 25000000 : 12500000;

	/* gimme MHz */
	sc->sc_freq /= 1000000;
d104 3
a106 3
	 * XXX More of this should be in ncr53c9x_attach(), but
	 * XXX should we really poke around the chip that much in
	 * XXX the MI code?  Think about this more...
d110 1
a110 1
	 * Set up static configuration info.
d112 2
a113 4
	sc->sc_cfg1 = sc->sc_id | NCRCFG1_PARENB;
	sc->sc_cfg2 = NCRCFG2_SCSI2;
	sc->sc_cfg3 = 0;
	sc->sc_rev = NCR_VARIANT_NCR53C94;
d116 3
a118 3
	 * XXX minsync and maxxfer _should_ be set up in MI code,
	 * XXX but it appears to have some dependency on what sort
	 * XXX of DMA we're hooked up to, etc.
d122 2
a123 7
	 * This is the value used to start sync negotiations
	 * Note that the NCR register "SYNCTP" is programmed
	 * in "clocks per byte", and has a minimum value of 4.
	 * The SCSI period used in negotiation is one-fourth
	 * of the time (in nanoseconds) needed to transfer one byte.
	 * Since the chip's clock is given in MHz, we have the following
	 * formula: 4 * period = (1000 / freq) * 4
d125 2
a126 1
	sc->sc_minsync = (1000 / sc->sc_freq) * 5 / 4;
d128 2
a129 1
	sc->sc_maxxfer = 64 * 1024;
d131 5
a135 94
	/* Do the common parts of attachment. */
	ncr53c9x_attach(sc, &asc_switch, &asc_dev);
}

void
asc_tc_reset(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	asc->asc.sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);
}

int
asc_tc_intr(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	int trans, resid;

	resid = 0;
	if ((asc->asc.sc_flags & ASC_ISPULLUP) == 0 &&
	    (resid = (NCR_READ_REG(sc, NCR_FFLAG) & NCRFIFO_FF)) != 0) {
		NCR_DMA(("asc_tc_intr: empty FIFO of %d ", resid));
		DELAY(1);
	}

	resid += NCR_READ_REG(sc, NCR_TCL);
	resid += NCR_READ_REG(sc, NCR_TCM) << 8;

	trans = asc->asc.sc_dmasize - resid;

	if (asc->asc.sc_flags & ASC_ISPULLUP)
		memcpy(asc->sc_target, asc->sc_bounce, trans);
	*asc->asc.sc_dmalen -= trans;
	*asc->asc.sc_dmaaddr += trans;
	asc->asc.sc_flags &= ~(ASC_DMAACTIVE|ASC_MAPLOADED);

	return (0);
}

int
asc_tc_setup(sc, addr, len, datain, dmasize)
	struct ncr53c9x_softc *sc;
	caddr_t *addr;
	size_t *len;
	int datain;
	size_t *dmasize;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	u_int32_t tc_dmar;
	size_t size;

	asc->asc.sc_dmaaddr = addr;
	asc->asc.sc_dmalen = len;
	asc->asc.sc_flags = (datain) ? ASC_ISPULLUP : 0;

	NCR_DMA(("asc_tc_setup: start %ld@@%p, %s\n", (long)*asc->asc.sc_dmalen,
		*asc->asc.sc_dmaaddr, datain ? "IN" : "OUT"));

	size = *dmasize;
	if (size > PER_TGT_DMA_SIZE)
		size = PER_TGT_DMA_SIZE;
	*dmasize = asc->asc.sc_dmasize = size;

	NCR_DMA(("asc_tc_setup: dmasize = %ld\n", (long)asc->asc.sc_dmasize));

	asc->sc_bounce = asc->sc_base + PMAZ_OFFSET_RAM;
	asc->sc_bounce += PER_TGT_DMA_SIZE *
	    sc->sc_nexus->xs->sc_link->target;
	asc->sc_target = *addr;

	if ((asc->asc.sc_flags & ASC_ISPULLUP) == 0)
		memcpy(asc->sc_bounce, asc->sc_target, size);

#if 1
	if (asc->asc.sc_flags & ASC_ISPULLUP)
		tc_dmar = PMAZ_DMA_ADDR(asc->sc_bounce);
	else
		tc_dmar = PMAZ_DMAR_WRITE | PMAZ_DMA_ADDR(asc->sc_bounce);
	bus_space_write_4(asc->asc.sc_bst, asc->asc.sc_bsh, PMAZ_OFFSET_DMAR,
	    tc_dmar);
	asc->asc.sc_flags |= ASC_MAPLOADED|ASC_DMAACTIVE;
#endif
	return (0);
}

void
asc_tc_go(sc)
	struct ncr53c9x_softc *sc;
{
#if 0
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;
	u_int32_t tc_dmar;
d137 18
a154 8
	if (asc->asc.sc_flags & ASC_ISPULLUP)
		tc_dmar = PMAZ_DMA_ADDR(asc->sc_bounce);
	else
		tc_dmar = PMAZ_DMAR_WRITE | PMAZ_DMA_ADDR(asc->sc_bounce);
	bus_space_write_4(asc->asc.sc_bst, asc->asc.sc_bsh, PMAZ_OFFSET_DMAR,
	    tc_dmar);
	asc->asc.sc_flags |= ASC_DMAACTIVE;
#endif
a156 13
/* NEVER CALLED BY MI 53C9x ENGINE INDEED */
void
asc_tc_stop(sc)
	struct ncr53c9x_softc *sc;
{
#if 0
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	if (asc->asc.sc_flags & ASC_ISPULLUP)
		memcpy(asc->sc_target, asc->sc_bounce, asc->sc_dmasize);
	asc->asc.sc_flags &= ~ASC_DMAACTIVE;
#endif
}
d159 2
a160 1
 * Glue functions.
d162 19
a180 14
int
asc_dma_isintr(sc)
	struct ncr53c9x_softc *sc;
{
	return !!(NCR_READ_REG(sc, NCR_STAT) & NCRSTAT_INT);
}

int
asc_dma_isactive(sc)
	struct ncr53c9x_softc *sc;
{
	struct asc_tc_softc *asc = (struct asc_tc_softc *)sc;

	return !!(asc->asc.sc_flags & ASC_DMAACTIVE);
d183 5
a187 3
void
asc_clear_latched_intr(sc)
	struct ncr53c9x_softc *sc;
d189 2
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: asc_tc.c,v 1.4 1996/10/13 01:38:37 christos Exp $	*/
/*	$NetBSD: asc_tc.c,v 1.4 1996/10/13 01:38:37 christos Exp $	*/
d49 1
a49 1
static void
d51 1
a51 1
		  caddr_t cp, int flag));
d88 2
a89 1
	int bufsiz, speed;
d94 2
a95 1
	ascaddr = (void*)MACH_PHYS_TO_UNCACHED(t->ta_addr);
d113 15
a127 2
	asc->buff = (u_char *)(ascaddr + ASC_OFFSET_RAM);
	bufsiz = PER_TGT_DMA_SIZE;
d135 1
a135 1
	printf(" (bus speed: %d) ", t->ta_busspeed);
d150 1
a150 1
	ascattach(asc, bufsiz, speed);
d162 2
a163 2
static void
tc_dma_start(asc, state, cp, flag)
d168 2
d172 2
d175 3
a177 1
		*asc->dmar = ASC_DMAR_WRITE | ASC_DMA_ADDR(cp);
d179 2
a180 1
		*asc->dmar = ASC_DMA_ADDR(cp);
d189 2
a190 1

@


1.1
log
@Forgotten files from NetBSD merge
@
text
@d1 1
@
