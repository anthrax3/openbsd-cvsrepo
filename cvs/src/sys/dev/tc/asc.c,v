head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.16
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.12
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.10
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.8
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.6
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.25.0.14
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.12
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.10
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.8
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.20
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.18
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.16
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.14
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.12
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.10
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	UBC_SYNC_B:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	UBC:1.21.0.2
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.14.0.10
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.8
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.4
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.26
date	2014.01.18.22.33.59;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.05.12.27.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.06.27.20.23.37;	author miod;	state dead;
branches;
next	1.19;

1.19
date	2001.06.25.15.27.59;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.11.07.28.26;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.01.01.07.50;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.25.03.50.52;	author todd;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.10.01.11.52;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	98.05.18.00.25.06;	author millert;	state Exp;
branches
	1.14.8.1;
next	1.13;

1.13
date	97.07.08.05.29.11;	author mhitch;	state Exp;
branches;
next	1.12;

1.12
date	97.02.01.23.46.02;	author graichen;	state Exp;
branches;
next	1.11;

1.11
date	97.01.13.10.53.26;	author graichen;	state Exp;
branches;
next	1.10;

1.10
date	96.12.08.01.03.02;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.23.21.47.09;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.10.04.02.03.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.27.11.13.21;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.18.10.25.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.34.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.00.27.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.26.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.15.55.11;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.30.08.43.42;	author deraadt;	state Exp;
branches;
next	;

1.14.8.1
date	2001.05.14.22.26.17;	author niklas;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2001.07.04.10.43.34;	author niklas;	state dead;
branches;
next	1.14.8.3;

1.14.8.3
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	1.14.8.4;

1.14.8.4
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@instead of having every bit of glue set up and attach an identical
scsi_adapter struct, just do it once in the chip code.

ok krw@@
@
text
@/* $OpenBSD: asc.c,v 1.25 2010/06/28 18:31:02 krw Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994 Peter Galbavy.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>
#include <dev/tc/ascvar.h>

struct cfdriver asc_cd = {
	NULL, "asc", DV_DULL,
};

/*
 * Glue functions
 */
u_char
asc_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
{
	struct asc_softc *asc = (struct asc_softc *)sc;
	u_char v;

	v = bus_space_read_4(asc->sc_bst, asc->sc_bsh,
	    reg * sizeof(u_int32_t)) & 0xff;

	return (v);
}

void
asc_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
{
	struct asc_softc *asc = (struct asc_softc *)sc;

	bus_space_write_4(asc->sc_bst, asc->sc_bsh,
	    reg * sizeof(u_int32_t), val);
}

@


1.25
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: asc.c,v 1.24 2009/02/16 21:19:07 miod Exp $ */
a70 7
};

struct scsi_adapter asc_switch = {
	ncr53c9x_scsi_cmd,
	scsi_minphys,		/* no max at this level; handled by DMA code */
	NULL,
	NULL,
@


1.24
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: asc.c,v 1.23 2008/06/26 05:42:18 ray Exp $ */
a77 7
};

struct scsi_device asc_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default `done' routine */
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: asc.c,v 1.22 2003/06/05 12:27:02 deraadt Exp $ */
d75 1
a75 1
	minphys,		/* no max at this level; handled by DMA code */
@


1.22
log
@3/4 knockout for peter galbavy
@
text
@d1 1
a1 1
/* $OpenBSD: asc.c,v 1.21 2002/05/02 22:56:06 miod Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a50 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@@


1.20
log
@More pmax files are leaving the party.
@
text
@d1 1
a1 2
/*	$OpenBSD: asc.c,v 1.19 2001/06/25 15:27:59 aaron Exp $	*/
/*	$NetBSD: asc.c,v 1.46 1998/05/08 15:39:01 mhitch Exp $	*/
d4 2
a5 2
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
d7 3
a9 2
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
d21 17
a37 72
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)asc.c	8.3 (Berkeley) 7/3/94
 */

/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * HISTORY
 * Log:	scsi_53C94_hdw.c,v
 * Revision 2.5  91/02/05  17:45:07  mrt
 * 	Added author notices
 * 	[91/02/04  11:18:43  mrt]
 * 
 * 	Changed to use new Mach copyright
 * 	[91/02/02  12:17:20  mrt]
 * 
 * Revision 2.4  91/01/08  15:48:24  rpd
 * 	Added continuation argument to thread_block.
 * 	[90/12/27            rpd]
 * 
 * Revision 2.3  90/12/05  23:34:48  af
 * 	Recovered from pmax merge.. and from the destruction of a disk.
 * 	[90/12/03  23:40:40  af]
 * 
 * Revision 2.1.1.1  90/11/01  03:39:09  af
 * 	Created, from the DEC specs:
 * 	"PMAZ-AA TURBOchannel SCSI Module Functional Specification"
 * 	Workstation Systems Engineering, Palo Alto, CA. Aug 27, 1990.
 * 	And from the NCR data sheets
 * 	"NCR 53C94, 53C95, 53C96 Advances SCSI Controller"
 * 	[90/09/03            af]
d41 1
a41 24
 *	File: scsi_53C94_hdw.h
 * 	Author: Alessandro Forin, Carnegie Mellon University
 *	Date:	9/90
 *
 *	Bottom layer of the SCSI driver: chip-dependent functions
 *
 *	This file contains the code that is specific to the NCR 53C94
 *	SCSI chip (Host Bus Adapter in SCSI parlance): probing, start
 *	operation, and interrupt routine.
 */

/*
 * This layer works based on small simple 'scripts' that are installed
 * at the start of the command and drive the chip to completion.
 * The idea comes from the specs of the NCR 53C700 'script' processor.
 *
 * There are various reasons for this, mainly
 * - Performance: identify the common (successful) path, and follow it;
 *   at interrupt time no code is needed to find the current status
 * - Code size: it should be easy to compact common operations
 * - Adaptability: the code skeleton should adapt to different chips without
 *   terrible complications.
 * - Error handling: and it is easy to modify the actions performed
 *   by the scripts to cope with strange but well identified sequences
d43 24
a68 3
#include <asc.h>
#if NASC > 0

d71 1
a71 2
#include <sys/timeout.h>
#include <sys/dkstat.h>
a72 8
#include <sys/conf.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/reboot.h>

#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>
d77 3
a79 3
#include <machine/cpu.h>
#include <machine/autoconf.h>
#include <machine/bus.h>
d81 2
a82 256
#include <pmax/dev/device.h>
#include <pmax/dev/scsi.h>
#include <pmax/dev/ascreg.h>

#include <pmax/pmax/asic.h>
#include <pmax/pmax/kmin.h>


/*#define	readback(a)	{ register int foo; wbflush(); foo = (a); }*/
#define	readback(a)	{ register int foo;  foo = (a); }

/*
 * In 4ns ticks.
 */
int	asc_to_scsi_period[] = {
	32,
	33,
	34,
	35,
	5,
	5,
	6,
	7,
	8,
	9,
	10,
	11,
	12,
	13,
	14,
	15,
	16,
	17,
	18,
	19,
	20,
	21,
	22,
	23,
	24,
	25,
	26,
	27,
	28,
	29,
	30,
	31,
};

/*
 * Debugging log of SCSI operations.
 */

#ifdef DEBUG
int	asc_debug = 1;
int	asc_debug_cmd;
int	asc_debug_bn;
int	asc_debug_sz;
#define NLOG 32
struct asc_log {
	u_int	status;
	u_char	state;
	u_char	msg;
	int	target;
	int	resid;
} asc_log[NLOG], *asc_logp = asc_log;
#define PACK(unit, status, ss, ir) \
	((unit << 24) | (status << 16) | (ss << 8) | ir)
void asc_DumpLog __P((char *str));
#endif


/*
 * Script, scsi state, and device softc structure declarations.
 * script pointers occur in both scsi state and the  softc,
 * so they are defined first.
 */


/*
 * Scripts are entries in a state machine table.
 * A script has four parts: a pre-condition, an action, a command to the chip,
 * and an index into asc_scripts for the next state. The first triggers error
 * handling if not satisfied and in our case it is formed by the
 * values of the interrupt register and status register, this
 * basically captures the phase of the bus and the TC and BS
 * bits.  The action part is just a function pointer, and the
 * command is what the 53C94 should be told to do at the end
 * of the action processing.  This command is only issued and the
 * script proceeds if the action routine returns TRUE.
 * See asc_intr() for how and where this is all done.
 */
struct asc_softc;
typedef struct script {
	int		condition;	/* expected state at interrupt time */
		
	int		(*action)	/* extra operations */
		 __P((register struct asc_softc *asc, register int status, 
			 register int  ss, register int ir));
	int		command;	/* command to the chip */
	struct script	*next;		/* index into asc_scripts for next state */
} script_t;


/*
 * script definitions
 */

/* Matching on the condition value */
#define	SCRIPT_MATCH(ir, csr)		((ir) | (((csr) & 0x67) << 8))

/*
 * A typedef for a script function, to use in forward declarations.
 */
typedef int
script_fn_t __P((register struct asc_softc *asc, register int status, 
		 register int  ss, register int ir));


/* forward decls of script actions */
static script_fn_t script_nop;		/* when nothing needed */
static script_fn_t asc_end;		/* all come to an end */
static script_fn_t asc_get_status;	/* get status from target */
static script_fn_t asc_dma_in;		/* start reading data from target */
static script_fn_t asc_last_dma_in;	/* cleanup after all data is read */
static script_fn_t asc_resume_in;	/* resume data in after a message */
static script_fn_t asc_resume_dma_in;	/* resume DMA after a disconnect */
static script_fn_t asc_dma_out;		/* send data to target via dma */
static script_fn_t asc_last_dma_out;	/* cleanup after all data is written */
static script_fn_t asc_resume_out;	/* resume data out after a message */
static script_fn_t asc_resume_dma_out;	/* resume DMA after a disconnect */
static script_fn_t asc_sendsync;	/* negotiate sync xfer */
static script_fn_t asc_replysync;	/* negotiate sync xfer */
static script_fn_t asc_msg_in;		/* process a message byte */
static script_fn_t asc_disconnect;	/* process an expected disconnect */

/* Define the index into asc_scripts for various state transitions */
#define	SCRIPT_DATA_IN		0
#define	SCRIPT_CONTINUE_IN	2
#define	SCRIPT_DATA_OUT		3
#define	SCRIPT_CONTINUE_OUT	5
#define	SCRIPT_SIMPLE		6
#define	SCRIPT_GET_STATUS	7
#define	SCRIPT_DONE		8
#define	SCRIPT_MSG_IN		9
#define	SCRIPT_REPLY_SYNC	11
#define	SCRIPT_TRY_SYNC		12
#define	SCRIPT_DISCONNECT	15
#define	SCRIPT_RESEL		16
#define	SCRIPT_RESUME_IN	17
#define	SCRIPT_RESUME_DMA_IN	18
#define	SCRIPT_RESUME_OUT	19
#define	SCRIPT_RESUME_DMA_OUT	20
#define	SCRIPT_RESUME_NO_DATA	21

/*
 * Scripts
 */
script_t asc_scripts[] = {
	/* start data in */
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, SCSI_PHASE_DATAI),	/*  0 */
		asc_dma_in, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_IN + 1]},
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_STATUS),			/*  1 */
		asc_last_dma_in, ASC_CMD_I_COMPLETE,
		&asc_scripts[SCRIPT_GET_STATUS]},

	/* continue data in after a chunk is finished */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAI),			/*  2 */
		asc_dma_in, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_IN + 1]},

	/* start data out */
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, SCSI_PHASE_DATAO),	/*  3 */
		asc_dma_out, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_OUT + 1]},
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_STATUS),			/*  4 */
		asc_last_dma_out, ASC_CMD_I_COMPLETE,
		&asc_scripts[SCRIPT_GET_STATUS]},

	/* continue data out after a chunk is finished */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAO),			/*  5 */
		asc_dma_out, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_OUT + 1]},

	/* simple command with no data transfer */
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, SCSI_PHASE_STATUS),	/*  6 */
		script_nop, ASC_CMD_I_COMPLETE,
		&asc_scripts[SCRIPT_GET_STATUS]},

	/* get status and finish command */
	{SCRIPT_MATCH(ASC_INT_FC, SCSI_PHASE_MSG_IN),			/*  7 */
		asc_get_status, ASC_CMD_MSG_ACPT,
		&asc_scripts[SCRIPT_DONE]},
	{SCRIPT_MATCH(ASC_INT_DISC, 0),					/*  8 */
		asc_end, ASC_CMD_NOP,
		&asc_scripts[SCRIPT_DONE]},

	/* message in */
	{SCRIPT_MATCH(ASC_INT_FC, SCSI_PHASE_MSG_IN),			/*  9 */
		asc_msg_in, ASC_CMD_MSG_ACPT,
		&asc_scripts[SCRIPT_MSG_IN + 1]},
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_MSG_IN),			/* 10 */
		script_nop, ASC_CMD_XFER_INFO,
		&asc_scripts[SCRIPT_MSG_IN]},

	/* send synchonous negotiation reply */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_MSG_OUT),			/* 11 */
		asc_replysync, ASC_CMD_XFER_INFO,
		&asc_scripts[SCRIPT_REPLY_SYNC]},

	/* try to negotiate synchonous transfer parameters */
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, SCSI_PHASE_MSG_OUT),	/* 12 */
		asc_sendsync, ASC_CMD_XFER_INFO,
		&asc_scripts[SCRIPT_TRY_SYNC + 1]},
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_MSG_IN),			/* 13 */
		script_nop, ASC_CMD_XFER_INFO,
		&asc_scripts[SCRIPT_MSG_IN]},
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_COMMAND),			/* 14 */
		script_nop, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_RESUME_NO_DATA]},

	/* handle a disconnect */
	{SCRIPT_MATCH(ASC_INT_DISC, SCSI_PHASE_DATAO),			/* 15 */
		asc_disconnect, ASC_CMD_ENABLE_SEL,
		&asc_scripts[SCRIPT_RESEL]},

	/* reselect sequence: this is just a placeholder so match fails */
	{SCRIPT_MATCH(0, SCSI_PHASE_MSG_IN),				/* 16 */
		script_nop, ASC_CMD_MSG_ACPT,
		&asc_scripts[SCRIPT_RESEL]},

	/* resume data in after a message */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAI),			/* 17 */
		asc_resume_in, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_IN + 1]},

	/* resume partial DMA data in after a message */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAI),			/* 18 */
		asc_resume_dma_in, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_IN + 1]},

	/* resume data out after a message */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAO),			/* 19 */
		asc_resume_out, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_OUT + 1]},

	/* resume partial DMA data out after a message */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_DATAO),			/* 20 */
		asc_resume_dma_out, ASC_CMD_XFER_INFO | ASC_CMD_DMA,
		&asc_scripts[SCRIPT_DATA_OUT + 1]},

	/* resume after a message when there is no more data */
	{SCRIPT_MATCH(ASC_INT_BS, SCSI_PHASE_STATUS),			/* 21 */
		script_nop, ASC_CMD_I_COMPLETE,
		&asc_scripts[SCRIPT_GET_STATUS]},
a84 12

#include <dev/tc/ascvar.h>

/*
 * Internal forward declarations.
 */
static void asc_reset __P((asc_softc_t asc, asc_regmap_t *regs));
static void asc_startcmd __P((asc_softc_t asc, int target));
static void asc_timeout __P((void *arg));

#ifdef USE_NEW_SCSI
/* Glue to the machine-independent scsi */
d86 2
a87 2
	NULL, /* XXX - asc_scsi_cmd */
/*XXX*/	minphys,		/* no max transfer size; DMA engine deals */
d93 4
a96 4
/*XXX*/	NULL,			/* Use default error handler */
/*XXX*/	NULL,			/* have a queue, served by this */
/*XXX*/	NULL,			/* have no async handler */
/*XXX*/	NULL,			/* Use default 'done' routine */
a97 1
#endif
d100 1
a100 1
 * Definition of the controller for the old auto-configuration program.
d102 4
a105 20
void	asc_start __P((register ScsiCmd *scsicmd));
int	asc_intr __P ((void *asc));
struct	pmax_driver ascdriver = {
	"asc", NULL, asc_start, 0, asc_intr,
};

void asc_minphys __P((struct buf *bp));

extern struct cfdriver asc_cd;
struct cfdriver asc_cd = {
       NULL, "asc", DV_DULL
};

/*
 * bus-parent shared attach function
 */
void
ascattach(asc, bus_speed)
	register asc_softc_t asc;
	int bus_speed;
d107 2
a108 11
	register asc_regmap_t *regs;
	int id, s;

	int unit;

	unit = asc->sc_dev.dv_unit;
	
	/*
	 * Set up machine dependencies.
	 * (1) timing based on turbochannel frequency
	 */
d110 2
a111 1
	/* dma setup done in parent-specific attach code */
d113 1
a113 77
	/*
	 * Now for timing. The 3max has a 25Mhz tb whereas the 3min and
	 * maxine are 12.5Mhz.
	 */
	switch (bus_speed) {
	case ASC_SPEED_25_MHZ:
		asc->min_period = ASC_MIN_PERIOD25;
		asc->max_period = ASC_MAX_PERIOD25;
		asc->ccf = ASC_CCF(25);
		asc->timeout_250 = ASC_TIMEOUT_250(25, asc->ccf);
		asc->tb_ticks = 10;
		break;

	case ASC_SPEED_12_5_MHZ:
	default:
		asc->min_period = ASC_MIN_PERIOD12;
		asc->max_period = ASC_MAX_PERIOD12;
		asc->ccf = ASC_CCF(13);
		asc->timeout_250 = ASC_TIMEOUT_250(13, asc->ccf);
		asc->tb_ticks = 20;
		break;
	};

	asc->state = ASC_STATE_IDLE;
	asc->target = -1;

	regs = asc->regs;

	/*
	 * Reset chip, fully.  Note that interrupts are already enabled.
	 */
	s = splbio();

	/* preserve our ID for now */
	asc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;
	asc->myidmask = ~(1 << asc->sc_id);

	asc_reset(asc, regs);

	/*
	 * Our SCSI id on the bus.
	 * The user can set this via the prom on 3maxen/pmaxen.
	 * If this changes it is easy to fix: make a default that
	 * can be changed as boot arg.
	 */
#ifdef	unneeded
	regs->asc_cnfg1 = (regs->asc_cnfg1 & ~ASC_CNFG1_MY_BUS_ID) |
			      (scsi_initiator_id[unit] & 0x7);
	asc->sc_id = regs->asc_cnfg1 & ASC_CNFG1_MY_BUS_ID;
#endif

	id = asc->sc_id;
	splx(s);

	/* Hack for old-sytle SCSI-device probe */
	(void) pmax_add_scsi(&ascdriver, unit);

	printf(": target %d\n", id);


#ifdef USE_NEW_SCSI
	/*
	 * fill in the prototype scsi_link.
	 */
	asc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;
	asc->sc_link.adapter_softc = asc;
	asc->sc_link.adapter_target = asc->sc_id;
	asc->sc_link.adapter = &asc_switch;
	asc->sc_link.device = &asc_dev;
	asc->sc_link.openings = 2;

	/*
	 * Now try to attach all the sub-devices.
	 */
	config_found(self, &asc->sc_link, scsiprint);

#endif /* USE_NEW_SCSI */
a115 1584
/*
 *  Per Fogelstrom's SCSI Driver breaks down request transfer size.
 */
void
asc_minphys(bp)
	struct buf *bp;
{
	/*XXX*/
}

/*
 * Start activity on a SCSI device.
 * We maintain information on each device separately since devices can
 * connect/disconnect during an operation.
 */
void
asc_start(scsicmd)
	register ScsiCmd *scsicmd;	/* command to start */
{
	register struct pmax_scsi_device *sdp = scsicmd->sd;
	register asc_softc_t asc = asc_cd.cd_devs[sdp->sd_ctlr];
	int s;

	s = splbio();
	/*
	 * Check if another command is already in progress.
	 * We may have to change this if we allow SCSI devices with
	 * separate LUNs.
	 */
	if (asc->cmd[sdp->sd_drive]) {
		printf("asc %d: device %s busy at start\n",
			sdp->sd_ctlr,	/*XXX*/
			sdp->sd_driver->d_name);
		(*sdp->sd_driver->d_done)(scsicmd->unit, EBUSY,
			scsicmd->buflen, 0);
		splx(s);
	}
	asc->cmd[sdp->sd_drive] = scsicmd;
	/*
	 * Kludge: use a 60 second timeout if data is being transferred,
	 * otherwise use a 30 minute timeout.
	 */
	timeout_set(&asc->asc_timo, asc_timeout, scsicmd);
	timeout_add(&asc->asc_timo, hz * (scsicmd->buflen == 0 ? 1800 : 60));
	asc_startcmd(asc, sdp->sd_drive);
	splx(s);
}


#ifdef USE_NEW_SCSI
int
asc_poll(asc, target)
	struct asc_softc *asc;
	int target;
{
	struct scsi_xfer *scsicmd = asc->cmd[target];
	int count = scsicmd->timeout * 10;

	while(count) {
		if(asc->regs->asc_status &ASC_CSR_INT) {
			asc_intr(asc);
		}
		if(scsicmd->flags & ITSDONE)
			break;
		DELAY(5);
		count--;
	}
	if(count == 0) {
		scsicmd->error = XS_TIMEOUT;
		asc_end(asc, 0, 0, 0);
	}
	return COMPLETE;
}
#endif /*USE_NEW_SCSI*/

static void
asc_reset(asc, regs)
	asc_softc_t asc;
	asc_regmap_t *regs;
{

	/*
	 * Reset chip and wait till done
	 */
	regs->asc_cmd = ASC_CMD_RESET;
	tc_syncbus(); DELAY(25);

	/* spec says this is needed after reset */
	regs->asc_cmd = ASC_CMD_NOP;
	tc_syncbus(); DELAY(25);

	/*
	 * Set up various chip parameters
	 */
	regs->asc_ccf = asc->ccf;
	tc_syncbus(); DELAY(25);
	regs->asc_sel_timo = asc->timeout_250;
	/* restore our ID */
	regs->asc_cnfg1 = asc->sc_id | ASC_CNFG1_P_CHECK;
	/* include ASC_CNFG2_SCSI2 if you want to allow SCSI II commands */
	regs->asc_cnfg2 = /* ASC_CNFG2_RFB | ASC_CNFG2_SCSI2 | */ ASC_CNFG2_EPL;
	regs->asc_cnfg3 = 0;
	/* zero anything else */
	ASC_TC_PUT(regs, 0);
	regs->asc_syn_p = asc->min_period;
	regs->asc_syn_o = 0;	/* async for now */
	tc_mb();
}

/*
 * Start a SCSI command on a target.
 */
static void
asc_startcmd(asc, target)
	asc_softc_t asc;
	int target;
{
	register asc_regmap_t *regs;
	register ScsiCmd *scsicmd;
	register State *state;
	int len;

	/*
	 * See if another target is currently selected on this SCSI bus.
	 */
	if (asc->target >= 0)
		return;

	regs = asc->regs;

	/*
	 * If a reselection is in progress, it is Ok to ignore it since
	 * the ASC will automatically cancel the command and flush
	 * the FIFO if the ASC is reselected before the command starts.
	 * If we try to use ASC_CMD_DISABLE_SEL, we can hang the system if
	 * a reselect occurs before starting the command.
	 */

	asc->state = ASC_STATE_BUSY;
	asc->target = target;

	/* cache some pointers */
	scsicmd = asc->cmd[target];
	state = &asc->st[target];

#ifdef DEBUG
	if (asc_debug > 1) {
		printf("asc_startcmd: %s target %d cmd %x len %d\n",
		    scsicmd->sd->sd_driver->d_name, target,
		    scsicmd->cmd[0], scsicmd->buflen);
	}
#endif

	/* Try to avoid reselect collisions */
	if ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==
	    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {
/*		printf("asc_startcmd: possible reselect in progress\n"); */
		return;
	}

	/*
	 * Init the chip and target state.
	 */
	state->flags = state->flags & DID_SYNC;
	state->error = 0;
	state->script = (script_t *)0;
	state->msg_out = SCSI_NO_OP;

	len = scsicmd->cmdlen;
	state->dmalen = len;

	/* check for simple SCSI command with no data transfer */
	if ((state->buflen = scsicmd->buflen) == 0) {
		/* check for sync negotiation */
		if ((scsicmd->flags & SCSICMD_USE_SYNC) &&
		    !(state->flags & DID_SYNC)) {
			asc->script = &asc_scripts[SCRIPT_TRY_SYNC];
			state->flags |= TRY_SYNC;
		} else
			asc->script = &asc_scripts[SCRIPT_SIMPLE];
		state->buf = (char *)0;
	} else if (scsicmd->flags & SCSICMD_DATA_TO_DEVICE) {
		asc->script = &asc_scripts[SCRIPT_DATA_OUT];
		state->buf = scsicmd->buf;
		state->flags |= DMA_OUT;
	} else {
		asc->script = &asc_scripts[SCRIPT_DATA_IN];
		state->buf = scsicmd->buf;
		state->flags |= DMA_IN;
	}

#ifdef DEBUG
	asc_debug_cmd = scsicmd->cmd[0];
	if (scsicmd->cmd[0] == SCSI_READ_EXT) {
		asc_debug_bn = (scsicmd->cmd[2] << 24) |
			(scsicmd->cmd[3] << 16) |
			(scsicmd->cmd[4] << 8) |
			scsicmd->cmd[5];
		asc_debug_sz = (scsicmd->cmd[7] << 8) | scsicmd->cmd[8];
	}
	asc_logp->status = PACK(asc->sc_dev.dv_unit, 0, 0, asc_debug_cmd);
	asc_logp->target = asc->target;
	asc_logp->state = asc->script - asc_scripts;
	asc_logp->msg = SCSI_DIS_REC_IDENTIFY;
	asc_logp->resid = scsicmd->buflen;
	if (++asc_logp >= &asc_log[NLOG])
		asc_logp = asc_log;
#endif

	/* initialize the DMA */
	len = (*asc->dma_start)(asc, state, scsicmd->cmd, ASCDMA_WRITE,
	   len, 0);
	ASC_TC_PUT(regs, len);
	readback(regs->asc_cmd);

	regs->asc_dbus_id = target;
	readback(regs->asc_dbus_id);
	regs->asc_syn_p = state->sync_period;
	readback(regs->asc_syn_p);
	regs->asc_syn_o = state->sync_offset;
	readback(regs->asc_syn_o);

	/* Try to avoid reselect collisions */
	if ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==
	    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {
/*		printf("asc_startcmd: reselect in progress (before select)\n");*/
		return;
	}

	/* preload the FIFO with the message to be sent */
	regs->asc_fifo = SCSI_DIS_REC_IDENTIFY;
	tc_mb();

	if (state->flags & TRY_SYNC)
		regs->asc_cmd = len = ASC_CMD_SEL_ATN_STOP;
	else
		regs->asc_cmd = len = ASC_CMD_SEL_ATN | ASC_CMD_DMA;
	readback(regs->asc_cmd);

	/* Try to avoid reselect collisions */
	if ((regs->asc_status & (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) ==
	    (ASC_CSR_INT|SCSI_PHASE_MSG_IN)) {
/*		printf("asc_startcmd: reselect in progress after select\n");*/
		return;
	} else {
		/*
		 * Here's a potentially nasty but infrequent problem:  a
		 * reselect may have occurred, but did not interrupt.
		 */
		if (regs->asc_cmd != len &&
		    regs->asc_cmd == (ASC_CMD_NOP|ASC_CMD_DMA)) {
		    	if ((regs->asc_status & ASC_CSR_INT) == 0) {
		    		delay(250);
		    		if (regs->asc_status == SCSI_PHASE_MSG_IN) {
		    			printf("asc_startcmd: reselect failed to interrupt?\n");
		    			/* XXXX THIS NEEDS FIXING */
		    		}
		    	}
		}
	}

}

/*
 * Interrupt routine
 *	Take interrupts from the chip
 *
 * Implementation:
 *	Move along the current command's script if
 *	all is well, invoke error handler if not.
 */
int
asc_intr(sc)
	void *sc;
{
	register asc_softc_t asc = (asc_softc_t) sc;
	register asc_regmap_t *regs = asc->regs;
	register State *state;
	register script_t *scpt;
	register int ss, ir, status;
	register unsigned char cmd_was;
	static int ill_cmd_count = 0;			/* XXX */

	/* collect ephemeral information */
	status = regs->asc_status;
again:
	ss = regs->asc_ss;
	cmd_was = regs->asc_cmd;

	/* drop spurious interrupts */
	if ((status & ASC_CSR_INT) == 0)
		return (-1);		/* XXX */

	ir = regs->asc_intr;	/* this resets the previous two: i.e.,*/
				/* this re-latches CSR (and SSTEP) */
	scpt = asc->script;


#ifdef DEBUG
	asc_logp->status = PACK(asc->sc_dev.dv_unit, status, ss, ir);
	asc_logp->target = (asc->state == ASC_STATE_BUSY) ? asc->target : -1;
	asc_logp->state = scpt - asc_scripts;
	asc_logp->msg = cmd_was;
	asc_logp->resid = 0;
	if (++asc_logp >= &asc_log[NLOG])
		asc_logp = asc_log;
	if (asc_debug > 2)
		printf("asc_intr: status %x ss %x ir %x cond %d:%x\n",
			status, ss, ir, scpt - asc_scripts, scpt->condition);
#endif

	/* This must be done withing 250msec of disconnect */
	if (ir & ASC_INT_DISC) {
		regs->asc_cmd = ASC_CMD_ENABLE_SEL;
		readback(regs->asc_cmd);
	}

	/* check the expected state */
	if (SCRIPT_MATCH(ir, status) == scpt->condition) {
		/*
		 * Perform the appropriate operation, then proceed.
		 */
		if ((*scpt->action)(asc, status, ss, ir)) {
			regs->asc_cmd = scpt->command;
			readback(regs->asc_cmd);
			asc->script = scpt->next;
		}
		goto done;
	}

	/*
	 * Check for parity error.
	 * Hardware will automatically set ATN
	 * to request the device for a MSG_OUT phase.
	 */
	if (status & ASC_CSR_PE) {
		printf("%s: SCSI device %d: incomming parity error seen\n",
			asc->sc_dev.dv_xname, asc->target);
		asc->st[asc->target].flags |= PARITY_ERR;
	}

	/*
	 * Check for gross error.
	 * Probably a bug in a device driver.
	 */
	if (status & ASC_CSR_GE) {
		printf("%s: SCSI device %d: gross error\n",
			asc->sc_dev.dv_xname, asc->target);
		goto abort;
	}

	/* check for message in or out */
	if ((ir & ~ASC_INT_FC) == ASC_INT_BS) {
		register int len, fifo;

		state = &asc->st[asc->target];
		switch (ASC_PHASE(status)) {
		case SCSI_PHASE_DATAI:
		case SCSI_PHASE_DATAO:
			ASC_TC_GET(regs, len);
			fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
			if (len != 0 && (
			    (asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||
			    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN ||
			    (asc->script - asc_scripts) == SCRIPT_DATA_OUT + 1 ||
			    (asc->script - asc_scripts) == SCRIPT_CONTINUE_OUT)) { /*
			    	 * From the Mach driver:
			    	 * After a reconnect and restart dma in/out, we
			    	 * seem to have gotten an interrupt even though
			    	 * the DMA is running.  The Mach driver just
			    	 * ignores this interrupt.
			    	 */
			    	printf("asc_intr: ignoring strange interrupt");
			    	printf(" tc %d fifo residue %d script %d\n",
				    len, fifo, asc->script - asc_scripts);
			    	goto done;
			}
			printf("asc_intr: data overrun: buflen %d dmalen %d tc %d fifo %d\n",
				state->buflen, state->dmalen, len, fifo);
			goto abort;

		case SCSI_PHASE_MSG_IN:
			break;

		case SCSI_PHASE_MSG_OUT:
			/*
			 * Check for parity error.
			 * Hardware will automatically set ATN
			 * to request the device for a MSG_OUT phase.
			 */
			if (state->flags & PARITY_ERR) {
				state->flags &= ~PARITY_ERR;
				state->msg_out = SCSI_MESSAGE_PARITY_ERROR;
				/* reset message in counter */
				state->msglen = 0;
			} else
				state->msg_out = SCSI_NO_OP;
			regs->asc_fifo = state->msg_out;
			regs->asc_cmd = ASC_CMD_XFER_INFO;
			readback(regs->asc_cmd);
			goto done;

		case SCSI_PHASE_STATUS:
			/* probably an error in the SCSI command */
			asc->script = &asc_scripts[SCRIPT_GET_STATUS];
			regs->asc_cmd = ASC_CMD_I_COMPLETE;
			readback(regs->asc_cmd);
			goto done;

		case SCSI_PHASE_COMMAND:
			/*
			 * This seems to occur after the command is sent
			 * following sync negotiation.  The device still
			 * wants more command data.  The fifo appears to
			 * to still have the unsent data - but the 53C94
			 * signaled TC.  If the fifo still contains data,
			 * transfer it, otherwise do a transfer pad.  The
			 * target should then continue through the rest of
			 * the phases and complete normally.
			 */
			printf("asc_intr: tgt %d command phase TC zero",
			    asc->target);
			if ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {
				printf(" with non-empty fifo %d\n",
				    regs->asc_flags & ASC_FLAGS_FIFO_CNT);
				regs->asc_cmd = ASC_CMD_XFER_INFO;
			} else {
				printf("; padding command\n");
				ASC_TC_PUT(regs, 0xff);
				regs->asc_cmd = ASC_CMD_XFER_PAD | ASC_CMD_DMA;
			}
			goto done;

		default:
			printf("asc_intr: target %d, unknown phase 0x%x\n", 
			  	asc->target, status);
			goto abort;
		}

		if (state->script) {
			printf("asc_intr: target %d, incomplete script %p\n", 
			  	asc->target, state->script);
			goto abort;
		}

		/* check for DMA in progress */
		ASC_TC_GET(regs, len);
		fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
		/* flush any data in the FIFO */
		if (fifo) {
			if (state->flags & DMA_OUT) {
#ifdef ASC_DIAGNOSTIC
	 			printf("asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\n",
				    fifo, len, state->flags);
#endif /* ASC_DIAGNOSTIC */
				len += fifo;
			} else if (state->flags & DMA_IN) {
#ifdef ASC_DIAGNOSTIC
				printf("asc_intr: IN: dmalen %d len %d fifo %d\n",
					state->dmalen, len, fifo); /* XXX */
#endif /* ASC_DIAGNOSTIC */
			} else
				printf("asc_intr: dmalen %d len %d fifo %d\n",
					state->dmalen, len, fifo); /* XXX */
			regs->asc_cmd = ASC_CMD_FLUSH;
			tc_mb();
			readback(regs->asc_cmd);
			DELAY(2);
		}
		if (len && (state->flags & DMA_IN_PROGRESS)) {
			/* save number of bytes still to be sent or received */
			state->dmaresid = len;
			state->flags &= ~DMA_IN_PROGRESS;
			ASC_TC_PUT(regs, 0);
#ifdef DEBUG
			if (asc_logp == asc_log)
				asc_log[NLOG - 1].resid = len;
			else
				asc_logp[-1].resid = len;
#endif
			/* setup state to resume to */
			if (state->flags & DMA_IN) {
				/*
				 * Since the ASC_CNFG3_SRB bit of the
				 * cnfg3 register bit is not set,
				 * we just transferred an extra byte.
				 * Since we can't resume on an odd byte
				 * boundary, we copy the valid data out
				 * and resume DMA at the start address.
				 */
				if (len & 1) {
					printf("asc_intr: msg in len %d (fifo %d)\n",
						len, fifo); /* XXX */
					len = state->dmalen - len;
					goto do_in;
				}
				state->script =
					&asc_scripts[SCRIPT_RESUME_DMA_IN];
				state->flags |= DMA_RESUME;
			} else if (state->flags & DMA_OUT) {
				state->script =
					&asc_scripts[SCRIPT_RESUME_DMA_OUT];
				state->flags |= DMA_RESUME;
			} else
				state->script = asc->script;
		} else if (state->flags & DMA_IN) {
#ifdef ASC_DIAGNOSTIC
			if (len) {
				printf("asc_intr: 1: len %d (fifo %d)\n",
					len, fifo); /* XXX */
			}
#endif
			/* setup state to resume to */
			if (state->flags & DMA_IN_PROGRESS) {
				len = state->dmalen;
				state->flags &= ~DMA_IN_PROGRESS;
			do_in:
				state->dmalen = len;	/* dma_end needs actual length */
				(*asc->dma_end)(asc, state, ASCDMA_READ);
				state->buf += len;
				state->buflen -= len;
			}
			if (state->buflen)
				state->script = (state->flags & DMA_RESUME) ?
				    &asc_scripts[SCRIPT_RESUME_DMA_IN] :
				    &asc_scripts[SCRIPT_RESUME_IN];
			else
				state->script =
				    &asc_scripts[SCRIPT_RESUME_NO_DATA];
		} else if (state->flags & DMA_OUT) {
			if (len) {
#ifdef DEBUG
				printf("asc_intr: 2: len %d (fifo %d)\n", len,
					fifo); /* XXX */
#endif
			}
			/*
			 * If this is the last chunk, the next expected
			 * state is to get status.
			 */
			if (state->flags & DMA_IN_PROGRESS) {
				state->flags &= ~DMA_IN_PROGRESS;
				(*asc->dma_end)(asc, state, ASCDMA_WRITE);
				len = state->dmalen;
				state->buf += len;
				state->buflen -= len;
			}
			if (state->buflen)
				state->script = (state->flags & DMA_RESUME) ?
				    &asc_scripts[SCRIPT_RESUME_DMA_OUT] :
				    &asc_scripts[SCRIPT_RESUME_OUT];
			else
				state->script =
				    &asc_scripts[SCRIPT_RESUME_NO_DATA];
		} else if (asc->script == &asc_scripts[SCRIPT_SIMPLE])
			state->script = &asc_scripts[SCRIPT_RESUME_NO_DATA];
		else
			state->script = asc->script;

		/* setup to receive a message */
		asc->script = &asc_scripts[SCRIPT_MSG_IN];
		state->msglen = 0;
		regs->asc_cmd = ASC_CMD_XFER_INFO;
		readback(regs->asc_cmd);
		goto done;
	}

	/* check for SCSI bus reset */
	if (ir & ASC_INT_RESET) {
		register int i;

		printf("%s: SCSI bus reset!!\n", asc->sc_dev.dv_xname);
		/* need to flush any pending commands */
		for (i = 0; i < ASC_NCMD; i++) {
			if (!asc->cmd[i])
				continue;
			asc->st[i].error = EIO;
			asc_end(asc, 0, 0, 0);
		}
		/* rearbitrate synchronous offset */
		for (i = 0; i < ASC_NCMD; i++) {
			asc->st[i].sync_offset = 0;
			asc->st[i].flags = 0;
		}
		asc->target = -1;
		return 0 ; /* XXX ??? */
	}

	/* check for disconnect */
	if (ir & ASC_INT_DISC) {
		state = &asc->st[asc->target];
		switch (asc->script - asc_scripts) {
		case SCRIPT_DONE:
		case SCRIPT_DISCONNECT:
			/*
			 * Disconnects can happen normally when the
			 * command is complete with the phase being
			 * either SCSI_PHASE_DATAO or SCSI_PHASE_MSG_IN.
			 * The SCRIPT_MATCH() only checks for one phase
			 * so we can wind up here.
			 * Perform the appropriate operation, then proceed.
			 */
			if ((*scpt->action)(asc, status, ss, ir)) {
				regs->asc_cmd = scpt->command;
				readback(regs->asc_cmd);
				asc->script = scpt->next;
			}
			goto done;

		case SCRIPT_TRY_SYNC:
		case SCRIPT_SIMPLE:
		case SCRIPT_DATA_IN:
		case SCRIPT_DATA_OUT: /* one of the starting scripts */
			if (ASC_SS(ss) == 0) {
				/* device did not respond */
				if (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {
					regs->asc_cmd = ASC_CMD_FLUSH;
					readback(regs->asc_cmd);
				}
				state->error = ENXIO;
				asc_end(asc, status, ss, ir);
				return 0 ; /* XXX ??? */
			}
			/* FALLTHROUGH */

		default:
			printf("%s: SCSI device %d: unexpected disconnect\n",
				asc->sc_dev.dv_xname, asc->target);
#ifdef DEBUG
			asc_DumpLog("asc_disc");
#endif
			/*
			 * On rare occasions my RZ24 does a disconnect during
			 * data in phase and the following seems to keep it
			 * happy.
			 * XXX Should a scsi disk ever do this??
			 */
			asc->script = &asc_scripts[SCRIPT_RESEL];
			asc->state = ASC_STATE_RESEL;
			state->flags |= DISCONN;
			regs->asc_cmd = ASC_CMD_ENABLE_SEL;
			readback(regs->asc_cmd);
			return 0 ; /* XXX ??? */
		}
	}

	/* mhitch - debug - check select/reselect collision */
	if ((ir & ASC_INT_ILL) && (regs->asc_cmd & ASC_CMD_SEL_ATN)) {
		printf("asc_intr: Illegal command status %x ir %x\n",
		    status, ir);
		/* Should process reselect? */
	}

	/* check for illegal command */
	if (ir & ASC_INT_ILL) {
#ifdef ASC_DIAGNOSTIC
		printf("asc_intr: Illegal command status %x ir %x cmd %x ? %x\n",
		    status, ir, regs->asc_cmd, asc_scripts[SCRIPT_MSG_IN].command);
#endif
		/*
		 * On a 5000/200, I see this frequently when using an RD52
		 * CDROM.  The 53c94 doesn't seem to get the Message Accept
		 * command, and generates an "Illegal Command" interrupt.
		 * Re-issuing the Message Accept at this point seems to keep
		 * things going.  Don't allow this too many times in a row,
		 * just to make sure we don't get hung up.  mhitch
		 */
		if (ill_cmd_count++ != 3) {			/* XXX */
			regs->asc_cmd = ASC_CMD_MSG_ACPT;	/* XXX */
			readback(regs->asc_cmd);		/* XXX */
			goto done;				/* XXX */
		}						/* XXX */
		printf("asc_intr: Illegal command tgt %d\n", asc->target);
		goto abort;	/* XXX */
	}
	ill_cmd_count = 0;					/* XXX */

	/* check for reselect */
	if (ir & ASC_INT_RESEL) {
		unsigned fifo, id, msg;

		fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
		if (fifo < 2) {
			printf("asc_intr: target %d, reselect, fifo %d too small for msg\n", 
			  	asc->target, fifo);

			goto abort;
		}
		/* read unencoded SCSI ID and convert to binary */
		msg = regs->asc_fifo & asc->myidmask;
		for (id = 0; (msg & 1) == 0; id++)
			msg >>= 1;
		/* read identify message */
		msg = regs->asc_fifo;
#ifdef DEBUG
		if (asc_logp == asc_log)
			asc_log[NLOG - 1].msg = msg;
		else
			asc_logp[-1].msg = msg;
#endif
		/*
		 * TC may have been initialized during a selection attempt.
		 * Clear it to prevent possible confusion later.
		 */
		ASC_TC_PUT(regs,0);	/* ensure TC clear */
		asc->state = ASC_STATE_BUSY;
		asc->target = id;
		state = &asc->st[id];
		asc->script = state->script;
		state->script = (script_t *)0;
		if (!(state->flags & DISCONN)) {
			printf("asc_intr: reselect tgt %d, flags 0x%x not disconnected\n",
			       asc->target, state->flags);
			goto abort;
		}
		state->flags &= ~DISCONN;
		regs->asc_syn_p = state->sync_period;
		regs->asc_syn_o = state->sync_offset;
		regs->asc_cmd = ASC_CMD_MSG_ACPT;
		readback(regs->asc_cmd);
		goto done;
	}

	/* check if we are being selected as a target */
	if (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN)) {
			printf("asc_intr: host adaptor selected as target\n");
		goto abort;
	}
	/*
	 * 'ir' must be just ASC_INT_FC.
	 * This is normal if canceling an ASC_ENABLE_SEL.
	 */

done:
	tc_mb();
	/* watch out for HW race conditions and setup & hold time violations */
	ir = regs->asc_status;
	while (ir != (status = regs->asc_status))
		ir = status;
	if (status & ASC_CSR_INT)
		goto again;
	return 0 ; /* XXX ??? */

abort:
#ifdef DEBUG
	asc_DumpLog("asc_intr");
#endif
#if 0
	panic("asc_intr");
#else
	boot(RB_NOSYNC); /* XXX */
#endif
}

/*
 * All the many little things that the interrupt
 * routine might switch to.
 */

/* ARGSUSED */
static int
script_nop(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	return (1);
}

/* ARGSUSED */
static int
asc_get_status(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register int data;

	/*
	 * Get the last two bytes in the FIFO.
	 */
	if ((data = regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 2) {
		printf("asc_get_status: cmdreg %x, fifo cnt %d\n",
		       regs->asc_cmd, data); /* XXX */
#ifdef DEBUG
		asc_DumpLog("get_status"); /* XXX */
#endif
		if (data < 2) {
			asc->regs->asc_cmd = ASC_CMD_MSG_ACPT;
			readback(asc->regs->asc_cmd);
			return (0);
		}
		do {
			data = regs->asc_fifo;
		} while ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) > 2);
	}

	/* save the status byte */
	asc->st[asc->target].statusByte = data = regs->asc_fifo;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].msg = data;
	else
		asc_logp[-1].msg = data;
#endif

	/* get the (presumed) command_complete message */
	if ((data = regs->asc_fifo) == SCSI_COMMAND_COMPLETE)
		return (1);

#ifdef DEBUG
	printf("asc_get_status: status %x cmd %x\n",
		asc->st[asc->target].statusByte, data);
	asc_DumpLog("asc_get_status");
#endif
	return (0);
}

/* ARGSUSED */
static int
asc_end(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register ScsiCmd *scsicmd;
	register State *state;
	register int i, target;

	asc->state = ASC_STATE_IDLE;
	target = asc->target;
	asc->target = -1;
	scsicmd = asc->cmd[target];
	asc->cmd[target] = (ScsiCmd *)0;
	state = &asc->st[target];
	timeout_del(&asc->asc_timo);

#ifdef DEBUG
	if (asc_debug > 1) {
		printf("asc_end: %s target %d cmd %x err %d resid %d\n",
			scsicmd->sd->sd_driver->d_name, target,
			scsicmd->cmd[0], state->error, state->buflen);
	}
#endif
#ifdef DIAGNOSTIC
	if (target < 0 || !scsicmd)
		panic("asc_end");
#endif

	/* look for disconnected devices */
	for (i = 0; i < ASC_NCMD; i++) {
		if (!asc->cmd[i] || !(asc->st[i].flags & DISCONN))
			continue;
		asc->regs->asc_cmd = ASC_CMD_ENABLE_SEL;
		readback(asc->regs->asc_cmd);
		asc->state = ASC_STATE_RESEL;
		asc->script = &asc_scripts[SCRIPT_RESEL];
		break;
	}

#ifdef USE_NEW_SCSI
	if(scsicmd->error == XS_NOERROR && !(state->flags & CHECK_SENSE)) {
		if((state->statusByte & ST_MASK) == SCSI_CHECK) {
			struct scsi_sense *ss = (void *)&state->cmd;
			/* Save return values */
			scsicmd->resid = state->buflen;
			scsicmd->status = state->statusByte;
			/* Set up sense request command */
			bzero(ss, sizeof(*ss));
			ss->opcode = REQUEST_SENSE;
			ss->byte2 = sc_link->lun << 5;
			ss->length = sizeof(struct scsi_sense_data);
			state->cmdlen = sizeof(*ss);
			state->buf = (vm_offset_t)&scsicmd->sense;
			state->buflen = sizeof(struct scsi_sense_data);
			state->flags |= CHECK_SENSE;
			MachFlushDCache(state->buf, state->buflen);
			asc->cmd[target] = scsicmd;
			asc_startcmd(asc, target);
			return(0);
		}
	}
#endif /*USE_NEW_SCSI*/

	/*
	 * Look for another device that is ready.
	 * May want to keep last one started and increment for fairness
	 * rather than always starting at zero.
	 */
	for (i = 0; i < ASC_NCMD; i++) {
		/* don't restart a disconnected command */
		if (!asc->cmd[i] || (asc->st[i].flags & DISCONN))
			continue;
		asc_startcmd(asc, i);
		break;
	}

	/* signal device driver that the command is done */
	(*scsicmd->sd->sd_driver->d_done)(scsicmd->unit, state->error,
		state->buflen, state->statusByte);

	return (0);
}

/* ARGSUSED */
static int
asc_dma_in(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len;

	/* check for previous chunk in buffer */
	if (state->flags & DMA_IN_PROGRESS) {
		/*
		 * Only count bytes that have been copied to memory.
		 * There may be some bytes in the FIFO if synchonous transfers
		 * are in progress.
		 */
		ASC_TC_GET(regs, len);
		len = state->dmalen - len;
		state->dmalen = len;	/* dma_end may need actual length */
		(*asc->dma_end)(asc, state, ASCDMA_READ);
		state->buf += len;
		state->buflen -= len;
	}

	if (!(state->flags & DMA_IN_PROGRESS) &&
	    (regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0) {
	  	volatile int async_fifo_junk = 0;

		/*
		 * If the target is asynchronous, the FIFO contains
		 * a byte of garbage. (see the Mach mk84 53c94 driver,
		 * where this occurs on tk-50s and exabytes.)
		 * It also occurs on  asynch disks like SCSI-1 disks.
		 * Recover by reading the byte of junk from the fifo if,
		 * and only if, the target is async. If the target is
		 * synch, there is no junk, and reading the fifo
		 * deadlocks our SCSI state machine.
		 */
		 if (state->sync_offset == 0)
			async_fifo_junk = regs->asc_fifo;
#ifdef ASC_DIAGNOSTIC
		printf("%s: asc_dma_in: FIFO count %x flags %x sync_offset %d",
		    asc->sc_dev.dv_xname, regs->asc_flags,
		       state->flags, state->sync_offset);
		if (state->sync_offset != 0)
			printf("\n");
		else
			printf(" unexpected fifo data %x\n", async_fifo_junk);
#ifdef DEBUG
		asc_DumpLog("asc_dma_in");
#endif	/* DEBUG */
#endif	/* ASC_DIAGNOSTIC */

	}
	/* setup to start reading the next chunk */
	len = state->buflen;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	len = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);
	state->dmalen = len;
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_dma_in: buflen %d, len %d\n", state->buflen, len);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	if (len != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_IN];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_last_dma_in(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len, fifo;

	ASC_TC_GET(regs, len);
	fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_last_dma_in: buflen %d dmalen %d tc %d fifo %d\n",
			state->buflen, state->dmalen, len, fifo);
#endif
	if (fifo) {
		/* device must be trying to send more than we expect */
		regs->asc_cmd = ASC_CMD_FLUSH;
		readback(regs->asc_cmd);
	}
	state->flags &= ~DMA_IN_PROGRESS;
	len = state->dmalen - len;
	state->dmalen = len;	/* dma_end may need actual length */
	(*asc->dma_end)(asc, state, ASCDMA_READ);
	state->buflen -= len;

	return (1);
}

/* ARGSUSED */
static int
asc_resume_in(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len;

	/* setup to start reading the next chunk */
	len = state->buflen;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	len = (*asc->dma_start)(asc, state, state->buf, ASCDMA_READ, len, 0);
	state->dmalen = len;
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_resume_in: buflen %d, len %d\n", state->buflen,
			len);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	if (len != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_IN];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_resume_dma_in(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len, off;

	/* setup to finish reading the current chunk */
	len = state->dmaresid;
	off = state->dmalen - len;
	if ((off & 1) && state->sync_offset) {
		printf("asc_resume_dma_in: odd xfer dmalen %d len %d off %d\n",
			state->dmalen, len, off); /* XXX */
		regs->asc_res_fifo = state->buf[off];
	}
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	len = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_READ, len, off);
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_resume_dma_in: buflen %d dmalen %d len %d off %d\n",
			state->dmalen, state->buflen, len, off);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	state->flags &= ~DMA_RESUME;
	if (state->dmalen != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_IN];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_dma_out(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len, fifo;

	if (state->flags & DMA_IN_PROGRESS) {
		/* check to be sure previous chunk was finished */
		ASC_TC_GET(regs, len);
		fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
		if (len || fifo)
			printf("asc_dma_out: buflen %d dmalen %d tc %d fifo %d\n",
				state->buflen, state->dmalen, len, fifo); /* XXX */
		len += fifo;
		len = state->dmalen - len;
		state->buf += len;
		state->buflen -= len;
	}

	/*
	 * Flush the fifo - sometimes there seems to be something left
	 * in the fifo.  Since the dma output has not been started,
	 * the fifo is supposed to be empty.
	 */
	if (regs->asc_flags & ASC_FLAGS_FIFO_CNT) {
		while (regs->asc_flags & ASC_FLAGS_FIFO_CNT)
			regs->asc_fifo;
	}
	/* setup for this chunk */
	len = state->buflen;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	len = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);
	state->dmalen = len;
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_dma_out: buflen %d, len %d\n", state->buflen, len);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	if (len != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_last_dma_out(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len, fifo;

	ASC_TC_GET(regs, len);
	fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\n",
			state->buflen, state->dmalen, len, fifo);
#endif
	if (fifo) {
		len += fifo;
		regs->asc_cmd = ASC_CMD_FLUSH;
		readback(regs->asc_cmd);
		printf("asc_last_dma_out: buflen %d dmalen %d tc %d fifo %d\n",
			state->buflen, state->dmalen, len, fifo);
	}
	state->flags &= ~DMA_IN_PROGRESS;
	len = state->dmalen - len;
	state->buflen -= len;
	return (1);
}

/* ARGSUSED */
static int
asc_resume_out(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len;

	/* setup for this chunk */
	len = state->buflen;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	len = (*asc->dma_start)(asc, state, state->buf, ASCDMA_WRITE, len, 0);
	state->dmalen = len;
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_resume_out: buflen %d, len %d\n", state->buflen,
			len);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	if (len != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_resume_dma_out(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int len, off;

	/* setup to finish writing this chunk */
	len = state->dmaresid;
	off = state->dmalen - len;
	if (off & 1) {
		printf("asc_resume_dma_out: odd xfer dmalen %d len %d off %d\n",
			state->dmalen, len, off); /* XXX */
		regs->asc_fifo = state->buf[off];
		off++;
		len--;
	}
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].resid = len;
	else
		asc_logp[-1].resid = len;
#endif
	/* XXX may result in redundant copy of data */
	len = (*asc->dma_start)(asc, state, state->buf + off, ASCDMA_WRITE, len, off);
	ASC_TC_PUT(regs, len);
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_resume_dma_out: buflen %d dmalen %d len %d off %d\n",
			state->dmalen, state->buflen, len, off);
#endif

	/* check for next chunk */
	state->flags |= DMA_IN_PROGRESS;
	state->flags &= ~DMA_RESUME;
	if (state->dmalen != state->buflen) {
		regs->asc_cmd = ASC_CMD_XFER_INFO | ASC_CMD_DMA;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_CONTINUE_OUT];
		return (0);
	}
	return (1);
}

/* ARGSUSED */
static int
asc_sendsync(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];

	/* send the extended synchronous negotiation message */
	regs->asc_fifo = SCSI_EXTENDED_MSG;
	tc_mb();
	regs->asc_fifo = 3;
	tc_mb();
	regs->asc_fifo = SCSI_SYNCHRONOUS_XFER;
	tc_mb();
	regs->asc_fifo = SCSI_MIN_PERIOD;
	tc_mb();
	regs->asc_fifo = ASC_MAX_OFFSET;
	/* state to resume after we see the sync reply message */
	state->script = asc->script + 2;
	state->msglen = 0;
	return (1);
}

/* ARGSUSED */
static int
asc_replysync(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];

#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_replysync: %x %x\n",
			asc_to_scsi_period[state->sync_period] * asc->tb_ticks,
			state->sync_offset);
#endif
	/* send synchronous transfer in response to a request */
	regs->asc_fifo = SCSI_EXTENDED_MSG;
	tc_mb();
	regs->asc_fifo = 3;
	tc_mb();
	regs->asc_fifo = SCSI_SYNCHRONOUS_XFER;
	tc_mb();
	regs->asc_fifo = asc_to_scsi_period[state->sync_period] * asc->tb_ticks;
	tc_mb();
	regs->asc_fifo = state->sync_offset;
	regs->asc_cmd = ASC_CMD_XFER_INFO;
	readback(regs->asc_cmd);

	/* return to the appropriate script */
	if (!state->script) {
#ifdef DEBUG
		asc_DumpLog("asc_replsync");
#endif
		panic("asc_replysync");
	}
	asc->script = state->script;
	state->script = (script_t *)0;
	return (0);
}

/* ARGSUSED */
static int
asc_msg_in(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	register asc_regmap_t *regs = asc->regs;
	register State *state = &asc->st[asc->target];
	register int msg;
	int i;

	/* read one message byte */
	msg = regs->asc_fifo;
#ifdef DEBUG
	if (asc_logp == asc_log)
		asc_log[NLOG - 1].msg = msg;
	else
		asc_logp[-1].msg = msg;
#endif

	/* check for multi-byte message */
	if (state->msglen != 0) {
		/* first byte is the message length */
		if (state->msglen < 0) {
			state->msglen = msg;
			return (1);
		}
		if (state->msgcnt >= state->msglen) {
		  	printf("asc: msg_in too big, msgcnt %d msglen %d\n",
			       state->msgcnt, state->msglen);
			goto abort;
		}
		state->msg_in[state->msgcnt++] = msg;

		/* did we just read the last byte of the message? */
		if (state->msgcnt != state->msglen)
			return (1);

		/* process an extended message */
#ifdef DEBUG
		if (asc_debug > 2)
			printf("asc_msg_in: msg %x %x %x\n",
				state->msg_in[0],
				state->msg_in[1],
				state->msg_in[2]);
#endif
		switch (state->msg_in[0]) {
		case SCSI_SYNCHRONOUS_XFER:
			state->flags |= DID_SYNC;
			state->sync_offset = state->msg_in[2];

			/* convert SCSI period to ASC period */
			i = state->msg_in[1] / asc->tb_ticks;
			if (i < asc->min_period)
				i = asc->min_period;
			else if (i >= asc->max_period) {
				/* can't do sync transfer, period too long */
				printf("%s: SCSI device %d: sync xfer period too long (%d)\n",
					asc->sc_dev.dv_xname, asc->target, i);
				i = asc->max_period;
				state->sync_offset = 0;
			}
			if ((i * asc->tb_ticks) != state->msg_in[1])
				i++;
			state->sync_period = i & 0x1F;

			/*
			 * If this is a request, check minimums and
			 * send back an acknowledge.
			 */
			if (!(state->flags & TRY_SYNC)) {
				regs->asc_cmd = ASC_CMD_SET_ATN;
				readback(regs->asc_cmd);

				if (state->sync_period < asc->min_period)
					state->sync_period =
						asc->min_period;
				if (state->sync_offset > ASC_MAX_OFFSET)
					state->sync_offset =
						ASC_MAX_OFFSET;
				asc->script = &asc_scripts[SCRIPT_REPLY_SYNC];
				regs->asc_syn_p = state->sync_period;
				readback(regs->asc_syn_p);
				regs->asc_syn_o = state->sync_offset;
				readback(regs->asc_syn_o);
				regs->asc_cmd = ASC_CMD_MSG_ACPT;
				readback(regs->asc_cmd);
				return (0);
			}

			regs->asc_syn_p = state->sync_period;
			readback(regs->asc_syn_p);
			regs->asc_syn_o = state->sync_offset;
			readback(regs->asc_syn_o);
			goto done;

		default:
			printf("%s: SCSI device %d: rejecting extended message 0x%x\n",
				asc->sc_dev.dv_xname, asc->target,
				state->msg_in[0]);
			goto reject;
		}
	}

	/* process first byte of a message */
#ifdef DEBUG
	if (asc_debug > 2)
		printf("asc_msg_in: msg %x\n", msg);
#endif
	switch (msg) {
#if 0
	case SCSI_MESSAGE_REJECT:
		printf(" did not like SYNCH xfer "); /* XXX */
		state->flags |= DID_SYNC;
		regs->asc_cmd = ASC_CMD_MSG_ACPT;
		readback(regs->asc_cmd);
		status = asc_wait(regs, ASC_CSR_INT);
		ir = regs->asc_intr;
		/* some just break out here, some dont */
		if (ASC_PHASE(status) == SCSI_PHASE_MSG_OUT) {
			regs->asc_fifo = SCSI_ABORT;
			regs->asc_cmd = ASC_CMD_XFER_INFO;
			readback(regs->asc_cmd);
			status = asc_wait(regs, ASC_CSR_INT);
			ir = regs->asc_intr;
		}
		if (ir & ASC_INT_DISC) {
			asc_end(asc, status, 0, ir);
			return (0);
		}
		goto status;
#endif /*0*/

	case SCSI_EXTENDED_MSG: /* read an extended message */
		/* setup to read message length next */
		state->msglen = -1;
		state->msgcnt = 0;
		return (1);

	case SCSI_NO_OP:
		break;

	case SCSI_SAVE_DATA_POINTER:
		/* expect another message */
		return (1);

	case SCSI_RESTORE_POINTERS:
		/*
		 * Need to do the following if resuming synchonous data in
		 * on an odd byte boundary.
		regs->asc_cnfg2 |= ASC_CNFG2_RFB;
		 */
		break;

	case SCSI_DISCONNECT:
		if (state->flags & DISCONN) {
			printf("asc: disconnected target %d disconnecting again\n",
			    asc->target);
			goto abort;
		}
		state->flags |= DISCONN;
		regs->asc_cmd = ASC_CMD_MSG_ACPT;
		readback(regs->asc_cmd);
		asc->script = &asc_scripts[SCRIPT_DISCONNECT];
		return (0);

	default:
		printf("%s: SCSI device %d: rejecting message 0x%x\n",
			asc->sc_dev.dv_xname, asc->target, msg);
	reject:
		/* request a message out before acknowledging this message */
		state->msg_out = SCSI_MESSAGE_REJECT;
		regs->asc_cmd = ASC_CMD_SET_ATN;
		readback(regs->asc_cmd);
	}

done:
	/* return to original script */
	regs->asc_cmd = ASC_CMD_MSG_ACPT;
	readback(regs->asc_cmd);
	if (!state->script) {
	  	printf("asc_msg_in: target %d, no script?\n", asc->target);

	abort:
#ifdef DEBUG
		asc_DumpLog("asc_msg_in");
#endif
		panic("asc_msg_in");
	}
	asc->script = state->script;
	state->script = (script_t *)0;
	return (0);
}

/* ARGSUSED */
static int
asc_disconnect(asc, status, ss, ir)
	register asc_softc_t asc;
	register int status, ss, ir;
{
	int i;
#ifdef DIAGNOSTIC
	/* later Mach driver checks for late asych disconnect here. */
	register State *state = &asc->st[asc->target];

	if (!(state->flags & DISCONN)) {
		printf("asc_disconnect: device %d: DISCONN not set!\n",
			asc->target);
	}
#endif /*DIAGNOSTIC*/
	asc->target = -1;
	asc->state = ASC_STATE_RESEL;
	/*
	 * Look for another device that is ready.
	 * May want to keep last one started and increment for fairness
	 * rather than always starting at zero.
	 */
	for (i = 0; i < ASC_NCMD; i++) {
		/* don't restart a disconnected command */
		if (!asc->cmd[i] || asc->st[i].flags & DISCONN)
			continue;
		asc_startcmd(asc, i);
		return (0);
	}
	return (1);
}

void
asc_timeout(arg)
	void *arg;
{
	int s = splbio();
	ScsiCmd *scsicmd = (ScsiCmd *) arg;

	printf("asc_timeout: cmd %p drive %d\n", scsicmd, scsicmd->sd->sd_drive);
#ifdef DEBUG
	asc_DumpLog("asc_timeout");
#endif
#if 0
	panic("asc_timeout");
#else
	boot(RB_NOSYNC); /* XXX */
#endif
	splx(s);
}


#ifdef DEBUG
d117 4
a120 2
asc_DumpLog(str)
	char *str;
d122 1
a122 2
	register struct asc_log *lp;
	register u_int status;
d124 2
a125 17
	printf("asc: %s: cmd %x bn %d cnt %d\n", str, asc_debug_cmd,
		asc_debug_bn, asc_debug_sz);
	lp = asc_logp;
	do {
		status = lp->status;
		printf("asc%d tgt %d status %x ss %x ir %x cond %d:%x msg %x resid %d\n",
			status >> 24,
			lp->target,
			(status >> 16) & 0xFF,
			(status >> 8) & 0xFF,
			status & 0XFF,
			lp->state,
			asc_scripts[lp->state].condition,
			lp->msg, lp->resid);
		if (++lp >= &asc_log[NLOG])
			lp = asc_log;
	} while (lp != asc_logp);
a126 1
#endif /*DEBUG*/
a127 1
#endif	/* NASC > 0 */
@


1.19
log
@Convert to new timeouts; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.18 2001/05/11 07:28:26 miod Exp $	*/
@


1.18
log
@Revert previous untested change, until a fix is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.16 2001/01/25 03:50:52 todd Exp $	*/
d128 1
d591 2
a592 2
	timeout(asc_timeout, scsicmd, hz * (scsicmd->buflen == 0 ?
	    1800 : 60));
d1382 1
a1382 1
	untimeout(asc_timeout, scsicmd);
@


1.17
log
@Convert to new timeouts.
@
text
@a127 1
#include <sys/timeout.h>
a525 2
	timeout_set(&asc->asc_timo, asc_timeout, scsicmd);

d590 2
a591 1
	timeout_add(&asc->asc_timo, hz * (scsicmd->buflen == 0 ? 1800 : 60));
d1381 1
a1381 1
	timeout_del(&asc->asc_timo);
@


1.16
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.15 2000/09/10 01:11:52 miod Exp $	*/
d128 1
d527 2
d593 1
a593 2
	timeout(asc_timeout, scsicmd, hz * (scsicmd->buflen == 0 ?
	    1800 : 60));
d1383 1
a1383 1
	untimeout(asc_timeout, scsicmd);
@


1.15
log
@Pull in two asc fixes from NetBSD, makes pmax port on DS5000/200 alive again
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.14 1998/05/18 00:25:06 millert Exp $	*/
d587 1
a587 1
	 * Kludge: use a 60 second timeout if data is being transfered,
@


1.14
log
@newer asc driver from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.13 1997/07/08 05:29:11 mhitch Exp $	*/
a756 4
	/* preload the FIFO with the message to be sent */
	regs->asc_fifo = SCSI_DIS_REC_IDENTIFY;
	tc_mb();

d777 4
d906 8
a913 3
			if ((asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||
			    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN) {
			    	/*
d915 1
a915 1
			    	 * After a reconnect and restart dma in, we
a919 2
				ASC_TC_GET(regs, len);
				fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
d921 2
a922 1
			    	printf(" tc %d fifo residue %d\n", len, fifo);
a924 4
			/* FALLTHROUGH */
		case SCSI_PHASE_DATAO:
			ASC_TC_GET(regs, len);
			fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
@


1.14.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.16 2001/01/25 03:50:52 todd Exp $	*/
d587 1
a587 1
	 * Kludge: use a 60 second timeout if data is being transferred,
d757 4
a780 4
	/* preload the FIFO with the message to be sent */
	regs->asc_fifo = SCSI_DIS_REC_IDENTIFY;
	tc_mb();

d906 3
a908 8
		case SCSI_PHASE_DATAO:
			ASC_TC_GET(regs, len);
			fifo = regs->asc_flags & ASC_FLAGS_FIFO_CNT;
			if (len != 0 && (
			    (asc->script - asc_scripts) == SCRIPT_DATA_IN + 1 ||
			    (asc->script - asc_scripts) == SCRIPT_CONTINUE_IN ||
			    (asc->script - asc_scripts) == SCRIPT_DATA_OUT + 1 ||
			    (asc->script - asc_scripts) == SCRIPT_CONTINUE_OUT)) { /*
d910 1
a910 1
			    	 * After a reconnect and restart dma in/out, we
d915 2
d918 1
a918 2
			    	printf(" tc %d fifo residue %d script %d\n",
				    len, fifo, asc->script - asc_scripts);
d921 4
@


1.14.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc.c,v 1.14.8.1 2001/05/14 22:26:17 niklas Exp $	*/
@


1.14.8.3
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d1 2
a2 1
/* $OpenBSD$ */
d5 2
a6 2
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
d8 2
a9 3
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
d21 72
a92 17
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
d96 24
a119 1
 * Copyright (c) 1994 Peter Galbavy.  All rights reserved.
a120 24
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Peter Galbavy.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d123 3
d128 5
d134 4
a137 1
#include <sys/buf.h>
d142 263
a404 2
#include <dev/ic/ncr53c9xreg.h>
#include <dev/ic/ncr53c9xvar.h>
d407 6
a412 3
struct cfdriver asc_cd = {
	NULL, "asc", DV_DULL,
};
d414 2
d417 2
a418 2
	ncr53c9x_scsi_cmd,
	minphys,		/* no max at this level; handled by DMA code */
d424 4
a427 4
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default `done' routine */
d429 1
d432 1
a432 1
 * Glue functions
d434 20
a453 4
u_char
asc_read_reg(sc, reg)
	struct ncr53c9x_softc *sc;
	int reg;
d455 11
a465 2
	struct asc_softc *asc = (struct asc_softc *)sc;
	u_char v;
d467 1
a467 2
	v = bus_space_read_4(asc->sc_bst, asc->sc_bsh,
	    reg * sizeof(u_int32_t)) & 0xff;
d469 77
a545 1
	return (v);
d548 1584
d2133 2
a2134 4
asc_write_reg(sc, reg, val)
	struct ncr53c9x_softc *sc;
	int reg;
	u_char val;
d2136 2
a2137 1
	struct asc_softc *asc = (struct asc_softc *)sc;
d2139 17
a2155 2
	bus_space_write_4(asc->sc_bst, asc->sc_bsh,
	    reg * sizeof(u_int32_t), val);
d2157 1
d2159 1
@


1.14.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: asc.c,v 1.14.8.3 2003/03/28 14:05:52 niklas Exp $ */
d51 5
@


1.13
log
@Add fix for another quirky behaviour:  sending the command after a sync
negotiation sometimes doesn't send all the command data for some reason.
Transfer remaining fifo data, and if that's not enough, pad the command.
This fixes a system reboot during SCSI device probes.  From my NetBSD fix.

Add missing code to start another device when a disconnect occurs.  Also
from NetBSD.

For all other unknown interrupt conditions, print an explanitory message
before rebooting the system.  This will be useful in determining other
reboots if they happen in the driver.  From jonathan@@netbsd.org.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: asc.c,v 1.31 1996/10/13 01:38:35 christos Exp $	*/
a142 2
#include <machine/machConst.h>	/* XXX */
#include <machine/locore.h>	/* XXX */
d144 1
a413 6
extern struct cfdriver asc_cd;
struct cfdriver asc_cd = {
	NULL, "asc", DV_DULL
};


d442 4
d451 1
a451 1
ascattach(asc, dmabufsize, bus_speed)
d453 1
a453 1
	int dmabufsize;
d456 1
a456 1
	int id, s, i;
a522 15
	/*
	 * Statically partition the DMA buffer between targets.
	 * This way we will eventually be able to attach/detach
	 * drives on-fly.  And 18k/target is plenty for normal use.
	 */

	/*
	 * Give each target its own DMA buffer region.
	 * We may want to try ping ponging buffers later.
	 */
	for (i = 0; i < ASC_NCMD; i++) {
		asc->st[i].dmaBufAddr = asc->buff + dmabufsize * i;
		asc->st[i].dmaBufSize = dmabufsize;
	}

a715 3
	/*
	 * Copy command data to the DMA buffer.
	 */
a717 1
	bcopy(scsicmd->cmd, state->dmaBufAddr, len);
d762 2
a763 1
	(*asc->dma_start)(asc, state, state->dmaBufAddr, ASCDMA_WRITE);
d829 1
d906 2
a907 1
			if ((asc->script - asc_scripts) == SCRIPT_GET_STATUS) {
d999 4
a1002 4
#ifdef DIAGNOSTIC /* XXX - don't exacly know it this should be ifdefed */
	printf("asc: DMA_OUT, fifo resid %d, len %d, flags 0x%x\n",
					fifo, len, state->flags);
#endif
d1005 1
d1008 1
d1046 2
a1047 1
			} else if (state->flags & DMA_OUT)
d1050 2
a1051 1
			else
d1054 1
d1056 3
a1058 3
#ifdef DEBUG
				printf("asc_intr: 1: bn %d len %d (fifo %d)\n",
					asc_debug_bn, len, fifo); /* XXX */
a1059 2
				goto abort;
			}
d1065 1
a1066 1
				bcopy(state->dmaBufAddr, state->buf, len);
d1071 2
a1072 1
				state->script =
d1096 2
a1097 1
				state->script =
d1201 24
d1248 5
d1298 1
a1298 1
	boot(4); /* XXX */
a1466 1
		(*asc->dma_end)(asc, state, ASCDMA_READ);
d1469 2
a1470 1
		bcopy(state->dmaBufAddr, state->buf, len);
d1491 1
a1491 1
#ifdef DEBUG
d1499 1
a1499 1
#ifdef DIAGNOSTIC
a1500 1
#endif	/* DIAGNOSTIC */
d1502 1
d1513 1
a1513 2
	if (len > state->dmaBufSize)
		len = state->dmaBufSize;
a1514 1
	(*asc->dma_start)(asc, state, state->dmaBufAddr, ASCDMA_READ);
a1541 2
	/* copy data from buffer to main memory */
	(*asc->dma_end)(asc, state, ASCDMA_READ);
d1556 2
a1558 1
	bcopy(state->dmaBufAddr, state->buf, len);
d1581 1
a1581 2
	if (len > state->dmaBufSize)
		len = state->dmaBufSize;
a1582 1
	(*asc->dma_start)(asc, state, state->dmaBufAddr, ASCDMA_READ);
d1617 1
a1617 1
		regs->asc_res_fifo = state->dmaBufAddr[off];
d1625 1
a1625 1
	(*asc->dma_start)(asc, state, state->dmaBufAddr + off, ASCDMA_READ);
d1635 1
d1685 1
a1685 2
	if (len > state->dmaBufSize)
		len = state->dmaBufSize;
a1686 2
	bcopy(state->buf, state->dmaBufAddr, len);
	(*asc->dma_start)(asc, state, state->dmaBufAddr, ASCDMA_WRITE);
d1752 1
a1752 2
	if (len > state->dmaBufSize)
		len = state->dmaBufSize;
a1753 2
	bcopy(state->buf, state->dmaBufAddr, len);
	(*asc->dma_start)(asc, state, state->dmaBufAddr, ASCDMA_WRITE);
d1788 1
a1788 1
		regs->asc_fifo = state->dmaBufAddr[off];
d1798 2
a1799 1
	(*asc->dma_start)(asc, state, state->dmaBufAddr + off, ASCDMA_WRITE);
d1809 1
a2110 1

d2125 1
a2125 1
	boot(4); /* XXX */
d2127 1
@


1.12
log
@put an harmless waring behind an DIAGNOSTIC
@
text
@d1 1
d976 24
d1001 2
d1006 3
a1008 1
		if (state->script)
d1010 1
d1220 4
a1223 1
		if (fifo < 2)
d1225 1
d1243 3
a1245 1
		if (!(state->flags & DISCONN))
d1247 1
d1257 2
a1258 1
	if (ir & (ASC_INT_SEL | ASC_INT_SEL_ATN))
d1260 1
a1260 1

d1904 3
a1906 1
		if (state->msgcnt >= state->msglen)
d1908 1
d2032 3
a2034 1
		if (state->flags & DISCONN)
d2036 1
d2058 2
d2077 2
a2078 1
#if  MACH_DDIAGNOSTIC
a2080 1
#endif
a2081 1
#ifdef DIAGNOSTIC
d2089 12
@


1.11
log
@small changes to get it compiled on the pmax (does'nt affect anything else)
@
text
@d988 1
d991 1
@


1.10
log
@Merge to NetBSD 961107, i.e. mostly new bus.h
@
text
@d1243 1
a1243 1
	boot(4, NULL); /* XXX */
d2060 1
a2060 1
	boot(4, NULL); /* XXX */
@


1.9
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.19.2.4 1996/07/17 20:04:38 jtc Exp $	*/
d131 1
a151 1
#include <pmax/pmax/pmaxtype.h>
a155 1
extern int pmax_boardtype;
d196 1
a196 1
 * Internal forward declarations.
a197 2
static void asc_reset();
static void asc_startcmd();
d217 8
d238 1
d241 4
a244 1
	int		(*action)();	/* extra operations */
d249 5
d257 8
d266 15
a280 15
static int script_nop();		/* when nothing needed */
static int asc_end();			/* all come to an end */
static int asc_get_status();		/* get status from target */
static int asc_dma_in();		/* start reading data from target */
static int asc_last_dma_in();		/* cleanup after all data is read */
static int asc_resume_in();		/* resume data in after a message */
static int asc_resume_dma_in();		/* resume DMA after a disconnect */
static int asc_dma_out();		/* send data to target via dma */
static int asc_last_dma_out();		/* cleanup after all data is written */
static int asc_resume_out();		/* resume data out after a message */
static int asc_resume_dma_out();	/* resume DMA after a disconnect */
static int asc_sendsync();		/* negotiate sync xfer */
static int asc_replysync();		/* negotiate sync xfer */
static int asc_msg_in();		/* process a message byte */
static int asc_disconnect();		/* process an expected disconnect */
a403 31
/*
 * State kept for each active SCSI device.
 */
typedef struct scsi_state {
	script_t *script;	/* saved script while processing error */
	int	statusByte;	/* status byte returned during STATUS_PHASE */
	int	error;		/* errno to pass back to device driver */
	u_char	*dmaBufAddr;	/* DMA buffer address */
	u_int	dmaBufSize;	/* DMA buffer size */
	int	dmalen;		/* amount to transfer in this chunk */
	int	dmaresid;	/* amount not transfered if chunk suspended */
	int	buflen;		/* total remaining amount of data to transfer */
	char	*buf;		/* current pointer within scsicmd->buf */
	int	flags;		/* see below */
	int	msglen;		/* number of message bytes to read */
	int	msgcnt;		/* number of message bytes received */
	u_char	sync_period;	/* DMA synchronous period */
	u_char	sync_offset;	/* DMA synchronous xfer offset or 0 if async */
	u_char	msg_out;	/* next MSG_OUT byte to send */
	u_char	msg_in[16];	/* buffer for multibyte messages */
} State;

/* state flags */
#define DISCONN		0x001	/* true if currently disconnected from bus */
#define DMA_IN_PROGRESS	0x002	/* true if data DMA started */
#define DMA_IN		0x004	/* true if reading from SCSI device */
#define DMA_OUT		0x010	/* true if writing to SCSI device */
#define DID_SYNC	0x020	/* true if synchronous offset was negotiated */
#define TRY_SYNC	0x040	/* true if try neg. synchronous offset */
#define PARITY_ERR	0x080	/* true if parity error seen */
#define CHECK_SENSE	0x100	/* true if doing sense command */
d405 1
a405 35
/*
 * State kept for each active SCSI host interface (53C94).
 */
struct asc_softc {
	struct device sc_dev;			/* us as a device */
	asc_regmap_t	*regs;		/* chip address */
	volatile int	*dmar;		/* DMA address register address */
	u_char		*buff;		/* RAM buffer address (uncached) */
	int		sc_id;		/* SCSI ID of this interface */
	int		myidmask;	/* ~(1 << myid) */
	int		state;		/* current SCSI connection state */
	int		target;		/* target SCSI ID if busy */
	script_t	*script;	/* next expected interrupt & action */
	ScsiCmd		*cmd[ASC_NCMD];	/* active command indexed by SCSI ID */
	State		st[ASC_NCMD];	/* state info for each active command */
	void		(*dma_start)();	/* Start dma routine */
	void		(*dma_end)();	/* End dma routine */
	u_char		*dma_next;
	int		dma_xfer;	/* Dma len still to go */
	int		min_period;	/* Min transfer period clk/byte */
	int		max_period;	/* Max transfer period clk/byte */
	int		ccf;		/* CCF, whatever that really is? */
	int		timeout_250;	/* 250ms timeout */
	int		tb_ticks;	/* 4ns. ticks/tb channel ticks */
#ifdef USE_NEW_SCSI
	struct scsi_link sc_link;		/* scsi link struct */
#endif
};

#define	ASC_STATE_IDLE		0	/* idle state */
#define	ASC_STATE_BUSY		1	/* selecting or currently connected */
#define ASC_STATE_TARGET	2	/* currently selected as target */
#define ASC_STATE_RESEL		3	/* currently waiting for reselect */

typedef struct asc_softc *asc_softc_t;
d408 1
a408 10
 * Dma operations.
 */
#define	ASCDMA_READ	1
#define	ASCDMA_WRITE	2
static void tb_dma_start(), tb_dma_end(), asic_dma_start(), asic_dma_end();
extern u_long asc_iomem;


/*
 * Autoconfiguration data for config.
d410 3
a412 7
int	ascmatch  __P((struct device * parent, void *cfdata, void *aux));
void	ascattach __P((struct device *parent, struct device *self, void *aux));
int	ascprint(void*, const char*);

struct cfattach asc_ca = {
	sizeof(struct asc_softc), ascmatch, ascattach
};
d440 1
a440 1
void	asc_start();
d446 1
a447 1
extern struct cfdriver ioasic_cd; /* XXX */
d450 1
a450 1
 * Match driver based on name
a451 26
int
ascmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct ioasicdev_attach_args *d = aux;
	struct tc_attach_args *t = aux;
	void *ascaddr;

	/*if (parent->dv_cfdata->cf_driver == &ioasic_cd) */
	if (strncmp(d->iada_modname, "asc", TC_ROM_LLEN) &&
	    strncmp(d->iada_modname, "PMAZ-AA ", TC_ROM_LLEN))
		return (0);

	if (parent->dv_cfdata->cf_driver == &ioasic_cd)
		ascaddr = (void*)d->iada_addr;
	else
		ascaddr = (void*)t->ta_addr;

	if (badaddr(ascaddr + ASC_OFFSET_53C94, 4))
		return (0);

	return (1);
}

d453 4
a456 8
ascattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct ioasicdev_attach_args *d = aux;
	register struct tc_attach_args *t = aux;
	register asc_softc_t asc = (asc_softc_t) self;
a458 1
	int bufsiz;
a459 1
	void *ascaddr;
a461 5
	if (asc->sc_dev.dv_parent->dv_cfdata->cf_driver == &ioasic_cd) {
		ascaddr = (void*)MACH_PHYS_TO_UNCACHED(d->iada_addr);
	} else {
		ascaddr = (void*)MACH_PHYS_TO_UNCACHED(t->ta_addr);
	}
d465 2
a466 1
	 * Initialize hw descriptor, cache some pointers
a467 1
	asc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);
d469 1
a469 5
	/*
	 * Set up machine dependencies.
	 * (1) how to do dma
	 * (2) timing based on turbochannel frequency
	 */
a470 19
	if (asc->sc_dev.dv_parent->dv_cfdata->cf_driver == &ioasic_cd) {
		asc->buff = (u_char *)MACH_PHYS_TO_UNCACHED(asc_iomem);
		bufsiz = 8192;
		*((volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base)) = -1;
		*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;
		*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;
		asc->dma_start = asic_dma_start;
		asc->dma_end = asic_dma_end;
	} else
	{
	    /*
	     * Fall through for turbochannel option.
	     */
	    asc->dmar = (volatile int *)(ascaddr + ASC_OFFSET_DMAR);
	    asc->buff = (u_char *)(ascaddr + ASC_OFFSET_RAM);
	    bufsiz = PER_TGT_DMA_SIZE;
	    asc->dma_start = tb_dma_start;
	    asc->dma_end = tb_dma_end;
	};
d475 2
a476 3
	switch (pmax_boardtype) {
	case DS_3MAX:
	case DS_3MAXPLUS:
d483 2
a484 2
	case DS_3MIN:
	case DS_MAXINE:
d536 2
a537 2
		asc->st[i].dmaBufAddr = asc->buff + bufsiz * i;
		asc->st[i].dmaBufSize = bufsiz;
a542 8
	/* tie pseudo-slot to device */
	if (asc->sc_dev.dv_parent->dv_cfdata->cf_driver == &ioasic_cd)
		ioasic_intr_establish(parent, d->iada_cookie, TC_IPL_BIO,
		    asc_intr, asc);
	else
		tc_intr_establish(parent, t->ta_cookie, TC_IPL_BIO,
		    asc_intr, asc);

d550 1
d560 1
a560 1
	config_found(self, &asc->sc_link, ascprint);
a565 10
 * Does anyone actually use this, and what for ?
 */
int
ascprint(aux, name)
	void *aux;
	const char *name;
{
	return -1;
}
/*
d603 6
d650 1
a650 1
	wbflush(); DELAY(25);
d654 1
a654 1
	wbflush(); DELAY(25);
d660 1
a660 1
	wbflush(); DELAY(25);
d671 1
a671 1
	wbflush();
d713 2
a714 2
			scsicmd->sd->sd_driver->d_name, target,
			scsicmd->cmd[0], scsicmd->buflen);
d780 1
a780 1
	wbflush();
d936 1
a936 1
			    	printf(" tc %d fifo residue\n", len, fifo);
d998 1
a998 1
			wbflush();
d1227 1
a1227 1
	wbflush();
d1243 1
a1243 1
	boot(4); /* XXX */
d1326 1
a1419 1
#ifdef DEBUG
d1422 27
a1448 2
		printf("asc_dma_in: FIFO count %x flags %x\n",
		    regs->asc_flags, state->flags);
a1449 1
#endif
d1783 1
a1783 1
	wbflush();
d1785 1
a1785 1
	wbflush();
d1787 1
a1787 1
	wbflush();
d1789 1
a1789 1
	wbflush();
d1814 1
a1814 1
	wbflush();
d1816 1
a1816 1
	wbflush();
d1818 1
a1818 1
	wbflush();
d1820 1
a1820 1
	wbflush();
a2044 11
/*
 * DMA handling routines. For a turbochannel device, just set the dmar.
 * For the I/O ASIC, handle the actual DMA interface.
 */
static void
tb_dma_start(asc, state, cp, flag)
	asc_softc_t asc;
	State *state;
	caddr_t cp;
	int flag;
{
d2046 3
a2048 11
	if (flag == ASCDMA_WRITE)
		*asc->dmar = ASC_DMAR_WRITE | ASC_DMA_ADDR(cp);
	else
		*asc->dmar = ASC_DMA_ADDR(cp);
}

static void
tb_dma_end(asc, state, flag)
	asc_softc_t asc;
	State *state;
	int flag;
d2050 2
d2053 9
a2063 98
static void
asic_dma_start(asc, state, cp, flag)
	asc_softc_t asc;
	State *state;
	caddr_t cp;
	int flag;
{
	register volatile u_int *ssr = (volatile u_int *)
		IOASIC_REG_CSR(ioasic_base);
	u_int phys, nphys;

	/* stop DMA engine first */
	*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
	*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;

	phys = MACH_CACHED_TO_PHYS(cp);
	cp = (caddr_t)mips_trunc_page(cp + NBPG);
	nphys = MACH_CACHED_TO_PHYS(cp);

	asc->dma_next = cp;
	asc->dma_xfer = state->dmalen - (nphys - phys);

	*(volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base) =
		IOASIC_DMA_ADDR(phys);
	*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =
		IOASIC_DMA_ADDR(nphys);
	if (flag == ASCDMA_READ)
		*ssr |= IOASIC_CSR_SCSI_DIR | IOASIC_CSR_DMAEN_SCSI;
	else
		*ssr = (*ssr & ~IOASIC_CSR_SCSI_DIR) | IOASIC_CSR_DMAEN_SCSI;
	wbflush();
}

static void
asic_dma_end(asc, state, flag)
	asc_softc_t asc;
	State *state;
	int flag;
{
	register volatile u_int *ssr = (volatile u_int *)
		IOASIC_REG_CSR(ioasic_base);
	register volatile u_int *dmap = (volatile u_int *)
		IOASIC_REG_SCSI_DMAPTR(ioasic_base);
	register u_short *to;
	register int w;
	int nb;

	*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
	to = (u_short *)MACH_PHYS_TO_CACHED(*dmap >> 3);
	*dmap = -1;
	*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;
	wbflush();

	if (flag == ASCDMA_READ) {
		MachFlushDCache(MACH_PHYS_TO_CACHED(
		    MACH_UNCACHED_TO_PHYS(state->dmaBufAddr)), state->dmalen);
		if ( (nb = *((int *)IOASIC_REG_SCSI_SCR(ioasic_base))) != 0) {
			/* pick up last upto6 bytes, sigh. */
	
			/* Last byte really xferred is.. */
			w = *(int *)IOASIC_REG_SCSI_SDR0(ioasic_base);
			*to++ = w;
			if (--nb > 0) {
				w >>= 16;
				*to++ = w;
			}
			if (--nb > 0) {
				w = *(int *)IOASIC_REG_SCSI_SDR1(ioasic_base);
				*to++ = w;
			}
		}
	}
}

#ifdef notdef
/*
 * Called by asic_intr() for scsi dma pointer update interrupts.
 */
void
asc_dma_intr()
{
	asc_softc_t asc =  &asc_cd.cd_devs[0]; /*XXX*/
	u_int next_phys;

	asc->dma_xfer -= NBPG;
	if (asc->dma_xfer <= -NBPG) {
		volatile u_int *ssr = (volatile u_int *)
			IOASIC_REG_CSR(ioasic_base);
		*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
	} else {
		asc->dma_next += NBPG;
		next_phys = MACH_CACHED_TO_PHYS(asc->dma_next);
	}
	*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =
		IOASIC_DMA_ADDR(next_phys);
	wbflush();
}
#endif /*notdef*/
@


1.8
log
@silence warning
@
text
@d464 1
a464 1
int	ascprint(void*, char*);
d695 1
a695 1
	char *name;
@


1.7
log
@mhitch; Don't flush the 53C94 fifo when starting dma_in.  The fifo data is
valid at that point, and flushing the fifo will hang the system.
@
text
@d1190 1
d1193 1
a1193 1
				goto abort;
@


1.6
log
@Try to avoid collisions with reselection when starting a new selection.
Enable reselections as soon as possible after a disconnect - prevents
losing a reselecting device.
Check for and ignore a spurious interrupt during a DMA input (from the
Mach driver).
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.19.2.3 1996/06/11 05:19:49 mhitch Exp $	*/
d1546 1
a1546 4
	/*
	 * If this is the first input (DMA_IN_PROGRESS == 0), make sure
	 * the FIFO is empty.  There shouldn't be any input yet.
	 */
a1550 2
		while ((regs->asc_flags & ASC_FLAGS_FIFO_CNT) != 0)
			regs->asc_fifo;
d1552 1
@


1.5
log
@sync to 0607
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.19.2.2 1996/06/04 21:21:44 mhitch Exp $	*/
d846 7
d922 7
d930 1
a930 1
		regs->asc_cmd = ASC_CMD_SEL_ATN_STOP;
d932 1
a932 1
		regs->asc_cmd = ASC_CMD_SEL_ATN | ASC_CMD_DMA;
d934 23
d1006 6
d1053 15
a1244 4
	/* check for command errors */
	if (ir & ASC_INT_ILL)
		goto abort;

d1301 7
@


1.4
log
@sync 0521
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.19 1996/05/20 09:46:21 jonathan Exp $	*/
d472 1
a472 1
	NULL, "as", DV_DULL
d503 2
d514 2
a515 1
	struct confargs *ca = aux;
d519 2
a520 1
	if (!TC_BUS_MATCHNAME(ca, "asc") && !TC_BUS_MATCHNAME(ca, "PMAZ-AA "))
d523 4
a526 1
	ascaddr = (void*)ca->ca_addr;
a533 2
extern struct cfdriver ioasic_cd; /* XXX */

d540 2
a541 1
	register struct confargs *ca = aux;
d550 5
a554 1
	ascaddr = (void*)MACH_PHYS_TO_UNCACHED(ca->ca_addr);
d661 6
a666 1
	BUS_INTR_ESTABLISH(ca, asc_intr, asc);
a1060 1
/*XXX*/ goto abort;
a1061 2
				u_char *cp;

a1063 5
				len += fifo;
				cp = state->dmaBufAddr + (state->dmalen - len);
				while (fifo-- > 0)
					*cp++ = regs->asc_fifo;
/*XXX*/ goto abort;
d1485 11
d1663 9
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.18 1996/03/18 01:39:47 jonathan Exp $	*/
d132 2
d140 3
a142 1
#include <machine/machConst.h>
d217 1
a511 1
	struct cfdata *cf = match;
d714 2
a715 1
		printf("%s: device %s busy at start\n", sdp->sd_ctlr,
d763 1
a763 1
	MachEmptyWriteBuffer(); DELAY(25);
d767 1
a767 1
	MachEmptyWriteBuffer(); DELAY(25);
d773 1
a773 1
	MachEmptyWriteBuffer(); DELAY(25);
d784 1
a784 1
	MachEmptyWriteBuffer();
d886 1
a886 1
	MachEmptyWriteBuffer();
d934 1
a934 1
		return;
d1046 1
d1056 1
d1061 1
a1061 1
			MachEmptyWriteBuffer();
d1286 1
a1286 1
	MachEmptyWriteBuffer();
d1802 1
a1802 1
	MachEmptyWriteBuffer();
d1804 1
a1804 1
	MachEmptyWriteBuffer();
d1806 1
a1806 1
	MachEmptyWriteBuffer();
d1808 1
a1808 1
	MachEmptyWriteBuffer();
d1833 1
a1833 1
	MachEmptyWriteBuffer();
d1835 1
a1835 1
	MachEmptyWriteBuffer();
d1837 1
a1837 1
	MachEmptyWriteBuffer();
d1839 1
a1839 1
	MachEmptyWriteBuffer();
d2048 2
d2051 1
d2107 1
a2107 1
	cp = (caddr_t)pmax_trunc_page(cp + NBPG);
d2121 1
a2121 1
	MachEmptyWriteBuffer();
d2142 1
a2142 1
	MachEmptyWriteBuffer();
d2147 1
a2147 1
		if (nb = *((int *)IOASIC_REG_SCSI_SCR(ioasic_base))) {
d2186 1
a2186 1
	MachEmptyWriteBuffer();
d2191 1
@


1.2
log
@from netbsd:
Commit trivial changes from Mach MK84 to force sup'ables source to be updated:
Drop spurious interrupts in asc_intr().   Read back the pending SCSI command
so asc_intr() can add it to the asc SCSI log.
@
text
@d1 1
a1 1
/*	$NetBSD: asc.c,v 1.16 1996/01/04 17:43:23 jonathan Exp $	*/
d132 2
d150 2
a151 1
#define	readback(a)	{ register int foo; foo = (a); }
d279 1
a279 1
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, ASC_PHASE_DATAI),	/*  0 */
d282 1
a282 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_STATUS),			/*  1 */
d287 1
a287 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAI),			/*  2 */
d292 1
a292 1
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, ASC_PHASE_DATAO),	/*  3 */
d295 1
a295 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_STATUS),			/*  4 */
d300 1
a300 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAO),			/*  5 */
d305 1
a305 1
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, ASC_PHASE_STATUS),	/*  6 */
d310 1
a310 1
	{SCRIPT_MATCH(ASC_INT_FC, ASC_PHASE_MSG_IN),			/*  7 */
d318 1
a318 1
	{SCRIPT_MATCH(ASC_INT_FC, ASC_PHASE_MSG_IN),			/*  9 */
d321 1
a321 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_MSG_IN),			/* 10 */
d326 1
a326 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_MSG_OUT),			/* 11 */
d331 1
a331 1
	{SCRIPT_MATCH(ASC_INT_FC | ASC_INT_BS, ASC_PHASE_MSG_OUT),	/* 12 */
d334 1
a334 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_MSG_IN),			/* 13 */
d337 1
a337 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_COMMAND),			/* 14 */
d342 1
a342 1
	{SCRIPT_MATCH(ASC_INT_DISC, ASC_PHASE_DATAO),			/* 15 */
d347 1
a347 1
	{SCRIPT_MATCH(0, ASC_PHASE_MSG_IN),				/* 16 */
d352 1
a352 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAI),			/* 17 */
d357 1
a357 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAI),			/* 18 */
d362 1
a362 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAO),			/* 19 */
d367 1
a367 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_DATAO),			/* 20 */
d372 1
a372 1
	{SCRIPT_MATCH(ASC_INT_BS, ASC_PHASE_STATUS),			/* 21 */
d452 1
a452 1
extern u_long asic_base;
d461 7
a467 3
extern struct cfdriver asccd;
struct cfdriver asccd = {
	NULL, "asc", ascmatch, ascattach, DV_DULL, sizeof(struct asc_softc)
d470 1
d509 1
a509 1
	void *sccaddr;
d511 2
a512 1
	if (!BUS_MATCHNAME(ca, "asc") && !BUS_MATCHNAME(ca, "PMAZ-AA "))
d515 1
a515 1
	sccaddr = BUS_CVTADDR(ca);
d517 1
a517 1
	if (badaddr(sccaddr + ASC_OFFSET_53C94, 4))
d523 2
d540 1
a540 1
	ascaddr = (void *)MACH_PHYS_TO_UNCACHED(BUS_CVTADDR(ca));
d553 2
a554 5
	switch (pmax_boardtype) {
	case DS_3MIN:
	case DS_MAXINE:
	case DS_3MAXPLUS:
	    if (unit == 0) {
d557 3
a559 3
		*((volatile int *)ASIC_REG_SCSI_DMAPTR(asic_base)) = -1;
		*((volatile int *)ASIC_REG_SCSI_DMANPTR(asic_base)) = -1;
		*((volatile int *)ASIC_REG_SCSI_SCR(asic_base)) = 0;
d562 2
a563 2
		break;
	    }
a566 2
	case DS_3MAX:
	default:
d648 1
d700 1
a700 1
	register asc_softc_t asc = asccd.cd_devs[sdp->sd_ctlr];
d989 2
a990 2
		case ASC_PHASE_DATAI:
		case ASC_PHASE_DATAO:
d997 1
a997 1
		case ASC_PHASE_MSG_IN:
d1000 1
a1000 1
		case ASC_PHASE_MSG_OUT:
d1018 1
a1018 1
		case ASC_PHASE_STATUS:
d1186 1
a1186 1
			 * either ASC_PHASE_DATAO or ASC_PHASE_MSG_IN.
d1965 1
a1965 1
		if (ASC_PHASE(status) == ASC_PHASE_MSG_OUT) {
d2089 1
a2089 1
		ASIC_REG_CSR(asic_base);
d2093 2
a2094 2
	*ssr &= ~ASIC_CSR_DMAEN_SCSI;
	*((volatile int *)ASIC_REG_SCSI_SCR(asic_base)) = 0;
d2103 4
a2106 4
	*(volatile int *)ASIC_REG_SCSI_DMAPTR(asic_base) =
		ASIC_DMA_ADDR(phys);
	*(volatile int *)ASIC_REG_SCSI_DMANPTR(asic_base) =
		ASIC_DMA_ADDR(nphys);
d2108 1
a2108 1
		*ssr |= ASIC_CSR_SCSI_DIR | ASIC_CSR_DMAEN_SCSI;
d2110 1
a2110 1
		*ssr = (*ssr & ~ASIC_CSR_SCSI_DIR) | ASIC_CSR_DMAEN_SCSI;
d2121 1
a2121 1
		ASIC_REG_CSR(asic_base);
d2123 1
a2123 1
		ASIC_REG_SCSI_DMAPTR(asic_base);
d2128 1
a2128 1
	*ssr &= ~ASIC_CSR_DMAEN_SCSI;
d2131 1
a2131 1
	*((volatile int *)ASIC_REG_SCSI_DMANPTR(asic_base)) = -1;
d2137 1
a2137 1
		if (nb = *((int *)ASIC_REG_SCSI_SCR(asic_base))) {
d2141 1
a2141 1
			w = *(int *)ASIC_REG_SCSI_SDR0(asic_base);
d2148 1
a2148 1
				w = *(int *)ASIC_REG_SCSI_SDR1(asic_base);
d2162 1
a2162 1
	asc_softc_t asc =  &asccd.cd_devs[0]; /*XXX*/
d2168 2
a2169 2
			ASIC_REG_CSR(asic_base);
		*ssr &= ~ASIC_CSR_DMAEN_SCSI;
d2174 2
a2175 2
	*(volatile int *)ASIC_REG_SCSI_DMANPTR(asic_base) =
		ASIC_DMA_ADDR(next_phys);
@


1.1
log
@from netbsd
@
text
@d1 2200
a2200 3
d1 1
a1 1
/*	$NetBSD: asc.c,v 1.15 1995/09/13 19:35:53 jonathan Exp $	*/
@
