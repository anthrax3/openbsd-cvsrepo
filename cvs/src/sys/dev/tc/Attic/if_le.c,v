head	1.6;
access;
symbols
	OPENBSD_5_6:1.5.0.80
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.78
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.74
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.72
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.70
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.68
	OPENBSD_5_0:1.5.0.66
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.64
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.62
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.58
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.60
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.56
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.54
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.52
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.50
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.48
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.46
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.44
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.42
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.40
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.38
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.36
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.34
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.32
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.30
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.28
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.26
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.24
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.22
	OPENBSD_2_8:1.5.0.20
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.18
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.16
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.6
date	2014.10.12.14.11.09;	author jsg;	state dead;
branches;
next	1.5;
commitid	ki4keNKAzYOPtyEg;

1.5
date	96.05.10.12.41.28;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.13.51.48;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.26.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.48.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.26.18.19.00;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove some unused files
ok miod@@
@
text
@/*	$OpenBSD: if_le.c,v 1.5 1996/05/10 12:41:28 deraadt Exp $	*/
@


1.5
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.3 1996/04/21 22:26:24 deraadt Exp $	*/
@


1.4
log
@make these work together
@
text
@a1 169
/*	$NetBSD: if_le.c,v 1.9 1996/04/22 02:54:10 christos Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <dev/tc/if_levar.h>
#include <dev/ic/am7990reg.h>
#define	LE_NEED_BUF_CONTIG
#define	LE_NEED_BUF_GAP2
#define	LE_NEED_BUF_GAP16
#include <dev/ic/am7990var.h>
#include <dev/tc/tcvar.h>

/* access LANCE registers */
void lewritereg __P((volatile u_short *regptr, u_short val));
#define	LERDWR(cntl, src, dst)	{ (dst) = (src); tc_mb(); }
#define	LEWREG(src, dst)	lewritereg(&(dst), (src))

#define	LE_SOFTC(unit)	le_cd.cd_devs[unit]
#define	LE_DELAY(x)	DELAY(x)

struct cfdriver le_cd = {
	NULL, "le", DV_IFNET
};

void
dec_le_common_attach(sc, eap)
	struct le_softc *sc;
	u_char *eap;
{
	int i;

	sc->sc_conf3 = 0;
	sc->sc_addr = 0;
	sc->sc_memsize = 65536;

	/*
	 * Get the ethernet address out of rom
	 */
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {
		sc->sc_arpcom.ac_enaddr[i] = *eap;
		eap += 4;
	}

	sc->sc_arpcom.ac_if.if_name = le_cd.cd_name;
	leconfig(sc);
}

integrate void
lehwinit(sc)
	struct le_softc *sc;
{
}

integrate void
lewrcsr(sc, port, val)
	struct le_softc *sc;
	u_int16_t port, val;
{
	struct lereg1 *ler1 = sc->sc_r1;

	LEWREG(port, ler1->ler1_rap);
	LERDWR(port, val, ler1->ler1_rdp);
}

integrate u_int16_t
lerdcsr(sc, port)
	struct le_softc *sc;
	u_int16_t port;
{
	struct lereg1 *ler1 = sc->sc_r1;
	u_int16_t val;

	LEWREG(port, ler1->ler1_rap);
	LERDWR(0, ler1->ler1_rdp, val);
	return (val);
}

/*
 * Write a lance register port, reading it back to ensure success. This seems
 * to be necessary during initialization, since the chip appears to be a bit
 * pokey sometimes.
 */
void
lewritereg(regptr, val)
	register volatile u_short *regptr;
	register u_short val;
{
	register int i = 0;

	while (*regptr != val) {
		*regptr = val;
		tc_mb();
		if (++i > 10000) {
			printf("le: Reg did not settle (to x%x): x%x\n", val,
			    *regptr);
			return;
		}
		DELAY(100);
	}
}

/*
 * Routines for accessing the transmit and receive buffers are provided
 * by am7990.c, because of the LE_NEED_BUF_* macros defined above.
 * Unfortunately, CPU addressing of these buffers is done in one of
 * 3 ways:
 * - contiguous (for the 3max and turbochannel option card)
 * - gap2, which means shorts (2 bytes) interspersed with short (2 byte)
 *   spaces (for the pmax)
 * - gap16, which means 16bytes interspersed with 16byte spaces
 *   for buffers which must begin on a 32byte boundary (for 3min, maxine,
 *   and alpha)
 * The buffer offset is the logical byte offset, assuming contiguous storage.
 */

#include <dev/ic/am7990.c>
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: if_le.c,v 1.2 1996/04/18 23:48:21 niklas Exp $	*/
/*	$NetBSD: if_le.c,v 1.6 1996/04/08 20:09:56 jonathan Exp $	*/
a42 31

/*
 * Supported busses: DEC IOCTL asic baseboard device, TurboChannel option,
 * plus baseboard device on   "busless"  DECstations.
 */
#ifdef alpha
#define	CAN_HAVE_IOASIC	1
#define	CAN_HAVE_TC	1
#endif
#ifdef pmax
#define	CAN_HAVE_IOASIC	1
#define	CAN_HAVE_TC	1
#define	CAN_HAVE_MAINBUS 1
#endif /* pmax */


/*
 * For each bus on which a LANCE device might appear, determine
 * if that bus was configured into the current kernel.
 */

#ifdef CAN_HAVE_MAINBUS
/*XXX TEST FOR KN01 OR MIPSFAIR? */
#endif
#ifdef CAN_HAVE_TC
#include "tc.h"
#endif
#ifdef CAN_HAVE_IOASIC
#include "ioasic.h"
#endif

a58 14
#include <machine/autoconf.h>

#if CAN_HAVE_TC && (NTC > 0)
#include <dev/tc/tcvar.h>
#endif
#if CAN_HAVE_IOASIC && (NIOASIC > 0)
#include <dev/tc/ioasicvar.h>
#endif
#if CAN_HAVE_MAINBUS
#include <pmax/pmax/kn01.h>
#include <pmax/pmax/kn01var.h>
extern struct cfdriver mainbus_cd; /* XXX */
#endif

d65 1
a71 6
#define LE_OFFSET_RAM		0x0
#define LE_OFFSET_LANCE		0x100000
#define LE_OFFSET_ROM		0x1c0000

extern caddr_t le_iomem;

a74 8
int le_tc_match __P((struct device *, void *, void *));
void le_tc_attach __P((struct device *, struct device *, void *));
int leintr __P((void *));

struct cfattach le_tc_ca = {
	sizeof(struct le_softc), le_tc_match, le_tc_attach
};

d79 29
a129 144
}

int
le_tc_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{

#if CAN_HAVE_IOASIC && (NIOASIC > 0)
	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		struct ioasicdev_attach_args *d = aux;

		if (!ioasic_submatch(match, aux)) {
			return (0);
		}
		if (strncmp("lance", d->iada_modname, TC_ROM_LLEN)) {
			return (0);
		}
	} else
#endif /* IOASIC */

#if CAN_HAVE_TC && (NTC > 0)
	if (parent->dv_cfdata->cf_driver == &tc_cd) {
		struct tc_attach_args *d = aux;

		if (strncmp("PMAD-AA ", d->ta_modname, TC_ROM_LLEN) &&
		    strncmp("PMAD-BA ", d->ta_modname, TC_ROM_LLEN))
			return (0);
	} else
#endif /* TC */

#if CAN_HAVE_MAINBUS && defined(DS3100)
	if (parent->dv_cfdata->cf_driver == &mainbus_cd) {
	  	struct confargs *d = aux;
		if (strcmp("lance", d->ca_name) != 0)
			return (0);
	} else
#endif /* MAINBUS */
		return (0);

	return (1);
}

typedef void (*ie_fn_t) __P((struct device *, void *,
			     tc_intrlevel_t, int (*)(void *), void *));

void
le_tc_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	register struct le_softc *sc = (void *)self;
	ie_fn_t ie_fn;
	u_char *cp;	/* pointer to MAC address */
	int i;

#if CAN_HAVE_IOASIC && (NIOASIC > 0)
	if (parent->dv_cfdata->cf_driver == &ioasic_cd) {
		struct ioasicdev_attach_args *d = aux;

		/* It's on the system IOCTL ASIC */
		sc->sc_r1 = (struct lereg1 *)
			TC_DENSE_TO_SPARSE(TC_PHYS_TO_UNCACHED(d->iada_addr));
		sc->sc_mem = (void *)TC_PHYS_TO_UNCACHED(le_iomem);
		cp = ioasic_lance_ether_address();

		sc->sc_copytodesc = copytobuf_gap2;
		sc->sc_copyfromdesc = copyfrombuf_gap2;
		sc->sc_copytobuf = copytobuf_gap16;
		sc->sc_copyfrombuf = copyfrombuf_gap16;
		sc->sc_zerobuf = zerobuf_gap16;

		ioasic_lance_dma_setup(le_iomem);	/* XXX more thought */
		ie_fn = ioasic_intr_establish;
		sc->sc_cookie = (void*)d->iada_cookie;
	} else
#endif /* IOASIC */
#if CAN_HAVE_TC && (NTC > 0)
	if (parent->dv_cfdata->cf_driver == &tc_cd) {
		struct tc_attach_args *d = aux;

		/*
		 * It's on the turbochannel proper, or a kn02
		 * baseboard implementation of a TC option card.
		 */
		sc->sc_r1 = (struct lereg1 *)(d->ta_addr + LE_OFFSET_LANCE);
		sc->sc_mem = (void *)(d->ta_addr + LE_OFFSET_RAM);
		cp = (u_char *)(d->ta_addr + LE_OFFSET_ROM + 2);

		sc->sc_copytodesc = copytobuf_contig;
		sc->sc_copyfromdesc = copyfrombuf_contig;
		sc->sc_copytobuf = copytobuf_contig;
		sc->sc_copyfrombuf = copyfrombuf_contig;
		sc->sc_zerobuf = zerobuf_contig;

		sc->sc_cookie = d->ta_cookie;
		/*
	 	 * TC lance boards have onboard SRAM buffers.  DMA
		 * between the onbard RAM and main memory is not possible,
		 * so  DMA setup is not required.
		 */
		ie_fn = tc_intr_establish;
	} else
#endif /* TC */
#if CAN_HAVE_MAINBUS && defined(DS3100)
	if (parent->dv_cfdata->cf_driver == &mainbus_cd) {
		struct confargs *ca = aux;

		/*
		 * It's on the baseboeard, with a dedicated interrupt line.
		 */
/*XXX*/		sc->sc_r1 = (struct lereg1 *)(ca->ca_addr);
/*XXX*/		sc->sc_mem = (void *)TC_PHYS_TO_UNCACHED(0x19000000);
/*XXX*/		cp = (u_char *)(TC_PHYS_TO_UNCACHED(KN01_SYS_CLOCK) + 1);

		sc->sc_copytodesc = copytobuf_gap2;
		sc->sc_copyfromdesc = copyfrombuf_gap2;
		sc->sc_copytobuf = copytobuf_gap2;
		sc->sc_copyfrombuf = copyfrombuf_gap2;
		sc->sc_zerobuf = zerobuf_gap2;

		sc->sc_cookie = (void *)ca->ca_slotpri; /*XXX more thought */
		ie_fn = (ie_fn_t) kn01_intr_establish;
	} else
#endif /* MAINBUS */

		panic("le_tc_attach: can't be here");

	sc->sc_conf3 = 0;
	sc->sc_addr = 0;
	sc->sc_memsize = 65536;

	/*
	 * Get the ethernet address out of rom
	 */
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++) {
		sc->sc_arpcom.ac_enaddr[i] = *cp;
		cp += 4;
	}

	sc->sc_arpcom.ac_if.if_name = le_cd.cd_name;
	leconfig(sc);

	(*ie_fn)(parent, sc->sc_cookie, TC_IPL_NET, leintr, sc);
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_le.c,v 1.3 1996/02/26 23:38:38 cgd Exp $	*/
d43 5
d56 7
a62 1
#endif
a63 1
#include "bpfilter.h"
d74 2
d100 2
a101 1
extern struct cfdriver mainbuscd; /* XXX */
d112 1
a112 1
void lewritereg();
d122 1
a122 1
#define	LE_SOFTC(unit)	lecd.cd_devs[unit]
d125 2
a126 2
int lematch __P((struct device *, void *, void *));
void leattach __P((struct device *, struct device *, void *));
d129 6
a134 2
struct cfdriver lecd = {
	NULL, "le", lematch, leattach, DV_IFNET, sizeof (struct le_softc)
d162 1
a162 1
lematch(parent, match, aux)
d168 1
a168 1
	if (parent->dv_cfdata->cf_driver == &ioasiccd) {
d171 1
a171 1
		if (!ioasic_submatch(match, aux))
d173 2
a174 1
		if (strncmp("lance   ", d->iada_modname, TC_ROM_LLEN))
d176 1
d179 1
d181 2
a182 2
	if (parent->dv_cfdata->cf_driver == &tccd) {
		struct tcdev_attach_args *d = aux;
d184 2
a185 2
		if (strncmp("PMAD-AA ", d->tcda_modname, TC_ROM_LLEN) &&
		    strncmp("PMAD-BA ", d->tcda_modname, TC_ROM_LLEN))
d189 6
a194 3
#if CAN_HAVE_MAINBUS /* XXX TEST FOR KN01 OR MIPSFAIR? */
	if (parent->dv_cfdata->cf_driver == &mainbuscd) {
		/* XXX VARIOUS PMAX BASEBOARD CASES? */
d202 3
d206 1
a206 1
leattach(parent, self, aux)
d211 1
a211 2
	void (*ie_fn) __P((struct device *, void *, tc_intrlevel_t,
	    int (*)(void *), void *));
d216 1
a216 1
	if (parent->dv_cfdata->cf_driver == &ioasiccd) {
d237 2
a238 2
	if (parent->dv_cfdata->cf_driver == &tccd) {
		struct tcdev_attach_args *d = aux;
d244 3
a246 3
		sc->sc_r1 = (struct lereg1 *)(d->tcda_addr + LE_OFFSET_LANCE);
		sc->sc_mem = (void *)(d->tcda_addr + LE_OFFSET_RAM);
		cp = (u_char *)(d->tcda_addr + LE_OFFSET_ROM + 2);
d254 1
a254 1
		sc->sc_cookie = d->tcda_cookie;
d263 2
a264 2
#if CAN_HAVE_MAINBUS  /* XXX TEST FOR KN01 OR MIPSFAIR? */
	if (parent->dv_cfdata->cf_driver == &mainbuscd) {
d281 1
a281 1
		/* XXX BASEBOARD INTERRUPT ESTABLISH FUNCTION? */
d285 1
a285 1
		panic("leattach: can't be here");
d299 1
a299 1
	sc->sc_arpcom.ac_if.if_name = lecd.cd_name;
@


1.1
log
@from netbsd:
Machine-independent TurboChannel LANCE driver.  As-is, this driver
should work properly with:
        (1) LANCE chips hanging off the system IOCTL asic,
        (2) LANCE chips TurboChannel option boards.
Support for various PMAX-family baseboard options isn't yet in this
file, but should be easy to add.
@
text
@d1 2
a2 1
/*	$NetBSD: if_le.c,v 1.1 1995/12/20 00:52:16 cgd Exp $	*/
a47 1
/* XXX PMAX BASEBOARD OPTIONS? */
d50 1
d54 3
a56 1
/* XXX PMAX BASEBOARD OPTIONS? */
a79 1
/* XXX PMAX BASEBOARD OPTIONS? */
d86 4
a149 1
	/* XXX VARIOUS PMAX BASEBOARD CASES? */
a163 2
		if (!tc_submatch(match, aux))
			return (0);
d169 5
a189 1
	/* XXX VARIOUS PMAX BASEBOARD CASES? */
d208 1
d211 1
a211 1
#if CAN_HAVE_TC && (NTC > 0)			/* XXX KN02 BASEBOARD CASE? */
d216 2
a217 1
		 * It's on the turbochannel proper.
d229 6
a234 1
		/* XXX DMA setup fn? */
d238 22
@
