head	1.6;
access;
symbols
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	UBC_SYNC_A:1.6
	UBC_SYNC_B:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.14
	OPENBSD_2_8:1.4.0.12
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.8
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.6
date	2001.06.27.20.23.37;	author miod;	state dead;
branches;
next	1.5;

1.5
date	2001.06.25.15.27.59;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.05.18.00.25.08;	author millert;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	97.11.07.08.07.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.01.13.10.53.27;	author graichen;	state Exp;
branches;
next	1.1;

1.1
date	96.12.08.14.13.08;	author niklas;	state Exp;
branches;
next	;

1.4.8.1
date	2001.07.04.10.43.35;	author niklas;	state dead;
branches;
next	;


desc
@@


1.6
log
@More pmax files are leaving the party.
@
text
@/*	$OpenBSD: asc_ioasic.c,v 1.5 2001/06/25 15:27:59 aaron Exp $	*/
/*	$NetBSD: asc_ioasic.c,v 1.12 1998/01/12 09:51:30 thorpej Exp $	*/

/*
 * Copyright 1996 The Board of Trustees of The Leland Stanford
 * Junior University. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies.  Stanford University
 * makes no representations about the suitability of this
 * software for any purpose.  It is provided "as is" without
 * express or implied warranty.
 *
 */
#define USE_CACHED_BUFFER 0

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/device.h>
#include <dev/tc/tcvar.h>
#include <dev/tc/ioasicvar.h>
#include <machine/autoconf.h>

#include <pmax/dev/device.h>		/* XXX */
#include <pmax/dev/scsi.h>		/* XXX */

#include <pmax/dev/ascreg.h>		/* XXX */
#include <dev/tc/ascvar.h>

#include <machine/cpu.h>
#include <machine/bus.h>		/* bus, cache consistency, etc  */

/*XXX*/
#include <pmax/pmax/asic.h>		/* XXX ioasic register defs? */
#include <pmax/pmax/kmin.h>	/* XXX ioasic register defs? */
#include <pmax/pmax/pmaxtype.h>
extern int pmax_boardtype;

extern vm_offset_t kvtophys __P((vm_offset_t));

/*
 * Autoconfiguration data for config.
 */
int asc_ioasic_match __P((struct device *, void *, void *));
void asc_ioasic_attach __P((struct device *, struct device *, void *));

struct cfattach asc_ioasic_ca = {
	sizeof(struct asc_softc), asc_ioasic_match, asc_ioasic_attach
};

#ifdef notdef
extern struct cfdriver asc_cd;
#endif

/*
 * DMA callback declarations
 */

#ifdef ASC_IOASIC_BOUNCE
extern u_long asc_iomem;
#endif
static int
asic_dma_start __P((asc_softc_t asc, State *state, caddr_t cp, int flag,
    int len, int off));

static void
asic_dma_end __P((asc_softc_t asc, State *state, int flag));

int
asc_ioasic_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct ioasicdev_attach_args *d = aux;
	void *ascaddr;

	if (strncmp(d->iada_modname, "asc", TC_ROM_LLEN) &&
	    strncmp(d->iada_modname, "PMAZ-AA ", TC_ROM_LLEN))
		return (0);

	/* probe for chip */
	ascaddr = (void*)d->iada_addr;
	if (tc_badaddr(ascaddr + ASC_OFFSET_53C94))
		return (0);

	return (1);
}

void
asc_ioasic_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	register struct ioasicdev_attach_args *d = aux;
	register asc_softc_t asc = (asc_softc_t) self;
#ifdef ASC_IOASIC_BOUNCE
	u_char *buff;
	int i;
#endif

	void *ascaddr;
	int unit;

	ascaddr = (void*)MIPS_PHYS_TO_KSEG1(d->iada_addr);
	unit = asc->sc_dev.dv_unit;
	
	/*
	 * Initialize hw descriptor, cache some pointers
	 */
	asc->regs = (asc_regmap_t *)(ascaddr + ASC_OFFSET_53C94);

	/*
	 * Set up machine dependencies.
	 * (1) how to do dma
	 * (2) timing based on turbochannel frequency
	 */

#ifdef ASC_IOASIC_BOUNCE
#if USE_CACHED_BUFFER
	/* XXX Use cached address for DMA buffer to increase raw read speed */
	buff = (u_char *)MIPS_PHYS_TO_KSEG0(asc_iomem);
#else
	buff = (u_char *)MIPS_PHYS_TO_KSEG1(asc_iomem);
#endif	/* USE_CACHED_BUFFER */
	/*
	 * Statically partition the DMA buffer between targets.
	 * This way we will eventually be able to attach/detach
	 * drives on-fly.  And 18k/target is plenty for normal use.
	 */

	/*
	 * Give each target its own DMA buffer region.
	 * We may want to try ping ponging buffers later.
	 */
	for (i = 0; i < ASC_NCMD; i++)
		asc->st[i].dmaBufAddr = buff + 8192 * i;

#endif	/* ASC_IOASIC_BOUNCE */
	*((volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base)) = -1;
	*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;
	*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;
	asc->dma_start = asic_dma_start;
	asc->dma_end = asic_dma_end;

	/* digital meters show IOASIC 53c94s are clocked at approx 25MHz */
	ascattach(asc, ASC_SPEED_25_MHZ);

	/* tie pseudo-slot to device */

	ioasic_intr_establish(parent, d->iada_cookie, TC_IPL_BIO,
			      asc_intr, asc);
}


/*
 * DMA handling routines. For a turbochannel device, just set the dmar.
 * For the I/O ASIC, handle the actual DMA interface.
 */
static int
asic_dma_start(asc, state, cp, flag, len, off)
	asc_softc_t asc;
	State *state;
	caddr_t cp;
	int flag;
	int len;
	int off;
{
	register volatile u_int *ssr = (volatile u_int *)
		IOASIC_REG_CSR(ioasic_base);
	u_int phys, nphys;

	/* stop DMA engine first */
	*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
	*((volatile int *)IOASIC_REG_SCSI_SCR(ioasic_base)) = 0;

#ifndef ASC_IOASIC_BOUNCE
	/* restrict len to the maximum the IOASIC can transfer */
	if (len > ((caddr_t)mips_trunc_page(cp + NBPG * 2) - cp))
		len = (caddr_t)mips_trunc_page(cp + NBPG * 2) - cp;

	/* If R4K, writeback and invalidate  the buffer */
	if (CPUISMIPS3)
		mips3_HitFlushDCache((vm_offset_t)cp, len);

	/* Get physical address of buffer start, no next phys addr */
	phys = (u_int)kvtophys((vm_offset_t)cp);
	nphys = -1;

	/* Compute 2nd DMA pointer only if next page is part of this I/O */
	if ((NBPG - (phys & (NBPG - 1))) < len) {
		cp = (caddr_t)mips_trunc_page(cp + NBPG);
		nphys = (u_int)kvtophys((vm_offset_t)cp);
	}

	/* If not R4K, need to invalidate cache lines for both physical segments */
	if (!CPUISMIPS3 && flag == ASCDMA_READ) {
		MachFlushDCache(MIPS_PHYS_TO_KSEG0(phys),
		    nphys == 0xffffffff ?  len : NBPG - (phys & (NBPG - 1)));
		if (nphys != 0xffffffff)
			MachFlushDCache(MIPS_PHYS_TO_KSEG0(nphys),
			    NBPG);	/* XXX */
	}
#else	/* ASC_IOASIC_BOUNCE */
	/* restrict len to the maximum the IOASIC can transfer */
	if (len > ((caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off)))
		len = (caddr_t)mips_trunc_page(state->dmaBufAddr + off + NBPG * 2) - (caddr_t)(state->dmaBufAddr + off);

	if (flag == ASCDMA_WRITE)
		bcopy(cp, state->dmaBufAddr + off, len);
	cp = state->dmaBufAddr + off;
#if USE_CACHED_BUFFER
#ifdef MIPS3
	/* If R4K, need to writeback the bounce buffer */
	if (CPUISMIPS3)
		mips3_HitFlushDCache((vm_offset_t)cp, len);
#endif /* MIPS3 */
	phys = MIPS_KSEG0_TO_PHYS(cp);
	cp = (caddr_t)mips_trunc_page(cp + NBPG);
	nphys = MIPS_KSEG0_TO_PHYS(cp);
#else
	phys = MIPS_KSEG1_TO_PHYS(cp);
	cp = (caddr_t)mips_trunc_page(cp + NBPG);
	nphys = MIPS_KSEG1_TO_PHYS(cp);
#endif	/* USE_CACHED_BUFFER */
#endif	/* ASC_IOASIC_BOUNCE */

#ifdef notyet
	asc->dma_next = cp;
	asc->dma_xfer = state->dmalen - (nphys - phys);
#endif

	*(volatile int *)IOASIC_REG_SCSI_DMAPTR(ioasic_base) =
		IOASIC_DMA_ADDR(phys);
	*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =
		IOASIC_DMA_ADDR(nphys);
	if (flag == ASCDMA_READ)
		*ssr |= IOASIC_CSR_SCSI_DIR | IOASIC_CSR_DMAEN_SCSI;
	else
		*ssr = (*ssr & ~IOASIC_CSR_SCSI_DIR) | IOASIC_CSR_DMAEN_SCSI;
	wbflush();
	return (len);
}

static void
asic_dma_end(asc, state, flag)
	asc_softc_t asc;
	State *state;
	int flag;
{
	register volatile u_int *ssr = (volatile u_int *)
		IOASIC_REG_CSR(ioasic_base);
	register volatile u_int *dmap = (volatile u_int *)
		IOASIC_REG_SCSI_DMAPTR(ioasic_base);
	register u_short *to;
	register int w;
	int nb;

	*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
#if USE_CACHED_BUFFER	/* XXX - Should uncached address always be used? */
	to = (u_short *)MIPS_PHYS_TO_KSEG0(*dmap >> 3);
#else
	to = (u_short *)MIPS_PHYS_TO_KSEG1(*dmap >> 3);
#endif
	*dmap = -1;
	*((volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base)) = -1;
	wbflush();

	if (flag == ASCDMA_READ) {
#if !defined(ASC_IOASIC_BOUNCE) && USE_CACHED_BUFFER
		/* Invalidate cache for the buffer */
#ifdef MIPS3
		if (CPUISMIPS3)
			MachFlushDCache(MIPS_KSEG1_TO_PHYS(state->dmaBufAddr),
			   state->dmalen);
		else
#endif /* MIPS3 */
			MachFlushDCache(MIPS_PHYS_TO_KSEG0(
			    MIPS_KSEG1_TO_PHYS(state->dmaBufAddr)),
			    state->dmalen);
#endif	/* USE_CACHED_BUFFER */
		if ( (nb = *((int *)IOASIC_REG_SCSI_SCR(ioasic_base))) != 0) {
			/* pick up last upto6 bytes, sigh. */
	
			/* Last byte really xferred is.. */
			w = *(int *)IOASIC_REG_SCSI_SDR0(ioasic_base);
			*to++ = w;
			if (--nb > 0) {
				w >>= 16;
				*to++ = w;
			}
			if (--nb > 0) {
				w = *(int *)IOASIC_REG_SCSI_SDR1(ioasic_base);
				*to++ = w;
			}
		}
#ifdef ASC_IOASIC_BOUNCE
		bcopy(state->dmaBufAddr, state->buf, state->dmalen);
#endif
	}
}

#ifdef notdef
/*
 * Called by asic_intr() for scsi dma pointer update interrupts.
 */
void
asc_dma_intr()
{
	asc_softc_t asc =  &asc_cd.cd_devs[0]; /*XXX*/
	u_int next_phys;

	asc->dma_xfer -= NBPG;
	if (asc->dma_xfer <= -NBPG) {
		volatile u_int *ssr = (volatile u_int *)
			IOASIC_REG_CSR(ioasic_base);
		*ssr &= ~IOASIC_CSR_DMAEN_SCSI;
	} else {
		asc->dma_next += NBPG;
		next_phys = MIPS_KSEG0_TO_PHYS(asc->dma_next);
	}
	*(volatile int *)IOASIC_REG_SCSI_DMANPTR(ioasic_base) =
		IOASIC_DMA_ADDR(next_phys);
	wbflush();
}
#endif /*notdef*/
@


1.5
log
@Convert to new timeouts; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_ioasic.c,v 1.4 1998/05/18 00:25:08 millert Exp $	*/
@


1.4
log
@newer asc driver from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_ioasic.c,v 1.3 1997/11/07 08:07:43 niklas Exp $	*/
d21 1
@


1.4.8.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: asc_ioasic.c,v 1.4 1998/05/18 00:25:08 millert Exp $	*/
@


1.3
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: asc_ioasic.c,v 1.3 1996/10/13 01:38:36 christos Exp $	*/
/*	$NetBSD: asc_ioasic.c,v 1.3 1996/10/13 01:38:36 christos Exp $	*/
d17 2
d26 2
a27 2
#include <pmax/dev/device.h>	/* XXX */
#include <pmax/dev/scsi.h>	/* XXX */
d29 1
a29 1
#include <pmax/dev/ascreg.h>	/* XXX */
d32 2
a33 1
#include <machine/locore.h> /* XXX XXX bus.h needs cache-consistency*/
d41 1
d53 4
d61 1
d63 4
a66 2
static void
asic_dma_start __P((asc_softc_t asc, State *state, caddr_t cp, int flag));
d100 4
a103 1
	int bufsiz, speed;
d108 1
a108 1
	ascaddr = (void*)MACH_PHYS_TO_UNCACHED(d->iada_addr);
d122 21
a142 2
	asc->buff = (u_char *)MACH_PHYS_TO_UNCACHED(asc_iomem);
	bufsiz = 8192;
d149 2
a150 20
	/*
	 * Now for timing. The 3max has a 25Mhz tb whereas the 3min and
	 * maxine are 12.5Mhz.
	 */

	/*printf(" (bus speed: %d) ", t->ta_busspeed);*/
	/* XXX don't these run at 25MHz on any ioasic??*/
	switch (pmax_boardtype) {
	case DS_3MAX:
	case DS_3MAXPLUS:
		speed = ASC_SPEED_25_MHZ;
		break;
	case DS_3MIN:
	case DS_MAXINE:
	default:
		speed = ASC_SPEED_12_5_MHZ;
		break;
	};

	ascattach(asc, bufsiz, speed);
d163 2
a164 2
static void
asic_dma_start(asc, state, cp, flag)
d169 2
d180 46
a225 1
	phys = MACH_CACHED_TO_PHYS(cp);
d227 3
a229 1
	nphys = MACH_CACHED_TO_PHYS(cp);
d231 1
d234 1
d245 1
d263 5
a267 1
	to = (u_short *)MACH_PHYS_TO_CACHED(*dmap >> 3);
d273 12
a284 2
		MachFlushDCache(MACH_PHYS_TO_CACHED(
		    MACH_UNCACHED_TO_PHYS(state->dmaBufAddr)), state->dmalen);
d300 3
d323 1
a323 1
		next_phys = MACH_CACHED_TO_PHYS(asc->dma_next);
@


1.2
log
@small changes to get it compiled on the pmax (does'nt affect anything else)
@
text
@d1 1
@


1.1
log
@Forgotten files from NetBSD merge
@
text
@d29 1
a29 1
#include <mips/locore.h> /* XXX XXX bus.h needs cache-consistency*/
@
