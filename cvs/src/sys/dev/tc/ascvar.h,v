head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.62
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.60
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.50
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.58
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.56
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.54
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.52
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.48
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.46
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.44
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.42
	OPENBSD_5_0:1.9.0.40
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.38
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.36
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.32
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.34
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.30
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.28
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.26
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.24
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.22
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.20
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.18
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.16
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.14
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.12
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.10
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	UBC_SYNC_B:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	UBC:1.9.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.12
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.10
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2002.05.02.22.56.06;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.27.20.23.37;	author miod;	state dead;
branches;
next	1.7;

1.7
date	2001.06.25.15.27.59;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.11.07.28.26;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.01.01.07.51;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.25.03.50.52;	author todd;	state Exp;
branches;
next	1.3;

1.3
date	98.05.18.00.25.10;	author millert;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	97.11.07.08.07.45;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.12.08.14.13.09;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2001.05.14.22.26.17;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2001.07.04.10.43.36;	author niklas;	state dead;
branches;
next	1.3.8.3;

1.3.8.3
date	2003.03.28.14.05.52;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.42.29;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Big TURBOchannel support catchup from NetBSD, part 1.
A few local changes and tweaks remain.

This bring DEC 3000 machines back in the game, but framebuffers are still
not supported at the moment.

Thanks to ericj@@ and nate@@ for supplying me a DEC 3000 for testing.
@
text
@/*	$OpenBSD$	*/
/*	$NetBSD: ascvar.h,v 1.7 2000/10/31 15:16:26 simonb Exp $	*/

/*
 * State kept for each active SCSI host interface (53C94).
 */

struct asc_softc {
	struct ncr53c9x_softc sc_ncr53c9x;	/* glue to MI code */
	bus_space_tag_t sc_bst;			/* bus space tag */
	bus_space_handle_t sc_bsh;		/* ASC register handle */
	bus_dma_tag_t sc_dmat;			/* bus dma tag */
	bus_dmamap_t sc_dmamap;			/* bus dmamap */
	caddr_t *sc_dmaaddr;
	size_t *sc_dmalen;
	size_t sc_dmasize;
	unsigned sc_flags;
#define ASC_ISPULLUP		0x01
#define ASC_DMAACTIVE		0x02
#define ASC_MAPLOADED		0x04
};

u_char	asc_read_reg(struct ncr53c9x_softc *, int);
void	asc_write_reg(struct ncr53c9x_softc *, int, u_char);
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@@


1.8
log
@More pmax files are leaving the party.
@
text
@d1 2
a2 38
/*	$OpenBSD: ascvar.h,v 1.7 2001/06/25 15:27:59 aaron Exp $	*/
/*	$NetBSD: ascvar.h,v 1.4 1997/11/28 18:23:40 mhitch Exp $	*/


/*
 * State kept for each active SCSI device.
 */
struct script;

typedef struct scsi_state {
	struct script *script;	/* saved script while processing error */
	int	statusByte;	/* status byte returned during STATUS_PHASE */
	int	error;		/* errno to pass back to device driver */
	u_char	*dmaBufAddr;	/* DMA buffer address */
	int	dmalen;		/* amount to transfer in this chunk */
	int	dmaresid;	/* amount not transferred if chunk suspended */
	int	buflen;		/* total remaining amount of data to transfer */
	char	*buf;		/* current pointer within scsicmd->buf */
	int	flags;		/* see below */
	int	msglen;		/* number of message bytes to read */
	int	msgcnt;		/* number of message bytes received */
	u_char	sync_period;	/* DMA synchronous period */
	u_char	sync_offset;	/* DMA synchronous xfer offset or 0 if async */
	u_char	msg_out;	/* next MSG_OUT byte to send */
	u_char	msg_in[16];	/* buffer for multibyte messages */
} State;

/* state flags */
#define DISCONN		0x001	/* true if currently disconnected from bus */
#define DMA_IN_PROGRESS	0x002	/* true if data DMA started */
#define DMA_IN		0x004	/* true if reading from SCSI device */
#define DMA_RESUME	0x08	/* true if DMA was interrupted by disc. */
#define DMA_OUT		0x010	/* true if writing to SCSI device */
#define DID_SYNC	0x020	/* true if synchronous offset was negotiated */
#define TRY_SYNC	0x040	/* true if try neg. synchronous offset */
#define PARITY_ERR	0x080	/* true if parity error seen */
#define CHECK_SENSE	0x100	/* true if doing sense command */

d9 12
a20 29
	struct device sc_dev;			/* us as a device */
	asc_regmap_t	*regs;		/* chip address */
	volatile int	*dmar;		/* DMA address register address */
	int		sc_id;		/* SCSI ID of this interface */
	int		myidmask;	/* ~(1 << myid) */
	int		state;		/* current SCSI connection state */
	int		target;		/* target SCSI ID if busy */
	struct script	*script;	/* next expected interrupt & action */
	ScsiCmd		*cmd[ASC_NCMD];	/* active command indexed by SCSI ID */
	State		st[ASC_NCMD];	/* state info for each active command */
	/* Start dma routine */
	int  (*dma_start) __P((struct asc_softc *asc,
				struct scsi_state *state,
				caddr_t cp, int flag, int len, int off));
	/* End dma routine */
	void	(*dma_end) __P((struct asc_softc *asc,
				struct scsi_state *state, int flag));

	u_char		*dma_next;
	int		dma_xfer;	/* Dma len still to go */
	int		min_period;	/* Min transfer period clk/byte */
	int		max_period;	/* Max transfer period clk/byte */
	int		ccf;		/* CCF, whatever that really is? */
	int		timeout_250;	/* 250ms timeout */
	int		tb_ticks;	/* 4ns. ticks/tb channel ticks */
	struct timeout	asc_timo;
#ifdef USE_NEW_SCSI
	struct scsi_link sc_link;		/* scsipi link struct */
#endif
a21 10
typedef struct asc_softc *asc_softc_t;

#define	ASC_STATE_IDLE		0	/* idle state */
#define	ASC_STATE_BUSY		1	/* selecting or currently connected */
#define ASC_STATE_TARGET	2	/* currently selected as target */
#define ASC_STATE_RESEL		3	/* currently waiting for reselect */


#define ASC_SPEED_25_MHZ	250
#define ASC_SPEED_12_5_MHZ	125
d23 2
a24 8
void	ascattach __P((struct asc_softc *asc, int bus_speed));
int	asc_intr __P ((void *asc));

/*
 * Dma operations.
 */
#define	ASCDMA_READ	1
#define	ASCDMA_WRITE	2
@


1.7
log
@Convert to new timeouts; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.6 2001/05/11 07:28:26 miod Exp $	*/
@


1.6
log
@Revert previous untested change, until a fix is ready.
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.4 2001/01/25 03:50:52 todd Exp $	*/
d70 1
@


1.5
log
@Convert to new timeouts.
@
text
@a69 1
	struct timeout	asc_timo;
@


1.4
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.3 1998/05/18 00:25:10 millert Exp $	*/
d70 1
@


1.3
log
@newer asc driver from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.2 1997/11/07 08:07:45 niklas Exp $	*/
d16 1
a16 1
	int	dmaresid;	/* amount not transfered if chunk suspended */
@


1.3.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.4 2001/01/25 03:50:52 todd Exp $	*/
d16 1
a16 1
	int	dmaresid;	/* amount not transferred if chunk suspended */
@


1.3.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ascvar.h,v 1.3.8.1 2001/05/14 22:26:17 niklas Exp $	*/
@


1.3.8.3
log
@Sync SMP to 3.3, files that CVS misses due to some bug
@
text
@d1 38
a38 2
/*	$OpenBSD$	*/
/*	$NetBSD: ascvar.h,v 1.7 2000/10/31 15:16:26 simonb Exp $	*/
d45 28
a72 12
	struct ncr53c9x_softc sc_ncr53c9x;	/* glue to MI code */
	bus_space_tag_t sc_bst;			/* bus space tag */
	bus_space_handle_t sc_bsh;		/* ASC register handle */
	bus_dma_tag_t sc_dmat;			/* bus dma tag */
	bus_dmamap_t sc_dmamap;			/* bus dmamap */
	caddr_t *sc_dmaaddr;
	size_t *sc_dmalen;
	size_t sc_dmasize;
	unsigned sc_flags;
#define ASC_ISPULLUP		0x01
#define ASC_DMAACTIVE		0x02
#define ASC_MAPLOADED		0x04
d74 10
d85 8
a92 2
u_char	asc_read_reg(struct ncr53c9x_softc *, int);
void	asc_write_reg(struct ncr53c9x_softc *, int, u_char);
@


1.2
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: ascvar.h,v 1.1 1996/09/25 21:07:56 jonathan Exp $	*/
/*	$NetBSD: ascvar.h,v 1.1 1996/09/25 21:07:56 jonathan Exp $	*/
a14 1
	u_int	dmaBufSize;	/* DMA buffer size */
d32 1
a47 1
	u_char		*buff;		/* RAM buffer address (uncached) */
d56 1
a56 1
	void  (*dma_start) __P((struct asc_softc *asc,
d58 1
a58 1
				caddr_t cp, int flag));
d71 1
a71 1
	struct scsi_link sc_link;		/* scsi link struct */
d85 1
a85 1
void	ascattach __P((struct asc_softc *asc, int dmabufsiz, int bus_speed));
@


1.1
log
@Forgotten files from NetBSD merge
@
text
@d1 1
@
