head	1.41;
access;
symbols
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.2
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.4
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.41
date	2017.02.12.17.12.37;	author chl;	state Exp;
branches;
next	1.40;
commitid	m7ME7E0sQeZWkyb6;

1.40
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.39;
commitid	RlO92XR575sygHqm;

1.39
date	2015.08.27.18.54.02;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	rZI4fhjFycflTQ2K;

1.38
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.37;
commitid	p4LJxGKbi0BU2cG6;

1.37
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.36;
commitid	MyKPm9Q3dQu92BiX;

1.36
date	2015.01.02.10.38.22;	author dlg;	state Exp;
branches;
next	1.35;
commitid	iHVrCY2EixFXvd8m;

1.35
date	2015.01.02.10.32.21;	author dlg;	state Exp;
branches;
next	1.34;
commitid	WkOoQM2Ix03YxlAr;

1.34
date	2014.10.17.02.05.06;	author tedu;	state Exp;
branches;
next	1.33;
commitid	BLOslqePzDqlwGRU;

1.33
date	2014.10.10.09.50.32;	author jmatthew;	state Exp;
branches;
next	1.32;
commitid	I2K73emIFD6aUv5H;

1.32
date	2014.09.22.01.09.29;	author dlg;	state Exp;
branches;
next	1.31;
commitid	4EGw4BVuzYn3dzNp;

1.31
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.30;
commitid	uzzBR7hz9ncd4O6G;

1.30
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.29;
commitid	OBNa5kfxQ2UXoiIw;

1.29
date	2014.04.22.08.48.51;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2014.01.22.01.21.33;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.10.18.33.55;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.02.22.20.07;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.28.11.24.36;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.05.15.28.49;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.25.00.31.31;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.22.04.52.10;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.22.03.51.47;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.21.04.33.35;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.24.20.15.31;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.24.11.53.44;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.23.09.41.16;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.27.03.34.29;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.21.13.47.10;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.21.13.28.09;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.10.05.31.41;	author armani;	state Exp;
branches;
next	1.9;

1.9
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.21.07.02.02;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2010.03.14.01.43.43;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.13.19.51.49;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.03.23.39.32;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Remove dead assignment and now unused variable.

Found by LLVM/Clang Static Analyzer.

ok dlg@@
@
text
@/*	$OpenBSD: vscsi.c,v 1.40 2016/09/15 02:00:17 dlg Exp $ */

/*
 * Copyright (c) 2008 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>  
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/task.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/vscsivar.h>

int		vscsi_match(struct device *, void *, void *);
void		vscsi_attach(struct device *, struct device *, void *);
void		vscsi_shutdown(void *);

struct vscsi_ccb {
	TAILQ_ENTRY(vscsi_ccb)	ccb_entry;
	int			ccb_tag;
	struct scsi_xfer	*ccb_xs;
	size_t			ccb_datalen;
};

TAILQ_HEAD(vscsi_ccb_list, vscsi_ccb);

enum vscsi_state {
	VSCSI_S_CLOSED,
	VSCSI_S_CONFIG,
	VSCSI_S_RUNNING
};

struct vscsi_softc {
	struct device		sc_dev;
	struct scsi_link	sc_link;
	struct scsibus_softc	*sc_scsibus;

	struct mutex		sc_state_mtx;
	enum vscsi_state	sc_state;
	u_int			sc_ref_count;
	struct pool		sc_ccb_pool;

	struct scsi_iopool	sc_iopool;

	struct vscsi_ccb_list	sc_ccb_i2t;
	struct vscsi_ccb_list	sc_ccb_t2i;
	int			sc_ccb_tag;
	struct mutex		sc_poll_mtx;
	struct rwlock		sc_ioc_lock;

	struct selinfo		sc_sel;
	struct mutex		sc_sel_mtx;
};

#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)
#define DEV2SC(_d) ((struct vscsi_softc *)device_lookup(&vscsi_cd, minor(_d)))

struct cfattach vscsi_ca = {
	sizeof(struct vscsi_softc),
	vscsi_match,
	vscsi_attach
};

struct cfdriver vscsi_cd = {
	NULL,
	"vscsi",
	DV_DULL
};

void		vscsi_cmd(struct scsi_xfer *);
int		vscsi_probe(struct scsi_link *);
void		vscsi_free(struct scsi_link *);

struct scsi_adapter vscsi_switch = {
	vscsi_cmd,
	scsi_minphys,
	vscsi_probe,
	vscsi_free
};

int		vscsi_i2t(struct vscsi_softc *, struct vscsi_ioc_i2t *);
int		vscsi_data(struct vscsi_softc *, struct vscsi_ioc_data *, int);
int		vscsi_t2i(struct vscsi_softc *, struct vscsi_ioc_t2i *);
int		vscsi_devevent(struct vscsi_softc *, u_long,
		    struct vscsi_ioc_devevent *);
void		vscsi_devevent_task(void *);
void		vscsi_done(struct vscsi_softc *, struct vscsi_ccb *);

void *		vscsi_ccb_get(void *);
void		vscsi_ccb_put(void *, void *);

void		filt_vscsidetach(struct knote *);
int		filt_vscsiread(struct knote *, long);
  
struct filterops vscsi_filtops = {
	1,
	NULL,
	filt_vscsidetach,
	filt_vscsiread
};


int
vscsi_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
vscsi_attach(struct device *parent, struct device *self, void *aux)
{
	struct vscsi_softc		*sc = (struct vscsi_softc *)self;
	struct scsibus_attach_args	saa;

	printf("\n");

	mtx_init(&sc->sc_state_mtx, IPL_BIO);
	sc->sc_state = VSCSI_S_CLOSED;

	TAILQ_INIT(&sc->sc_ccb_i2t);
	TAILQ_INIT(&sc->sc_ccb_t2i);
	mtx_init(&sc->sc_poll_mtx, IPL_BIO);
	mtx_init(&sc->sc_sel_mtx, IPL_BIO);
	rw_init(&sc->sc_ioc_lock, "vscsiioc");
	scsi_iopool_init(&sc->sc_iopool, sc, vscsi_ccb_get, vscsi_ccb_put);

	sc->sc_link.adapter = &vscsi_switch;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = 256;
	sc->sc_link.adapter_buswidth = 256;
	sc->sc_link.openings = 16;
	sc->sc_link.pool = &sc->sc_iopool;

	memset(&saa, 0, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_scsibus = (struct scsibus_softc *)config_found(&sc->sc_dev,
	    &saa, scsiprint);
}

void
vscsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link		*link = xs->sc_link;
	struct vscsi_softc		*sc = link->adapter_softc;
	struct vscsi_ccb		*ccb = xs->io;
	int				polled = ISSET(xs->flags, SCSI_POLL);
	int				running = 0;

	if (ISSET(xs->flags, SCSI_POLL) && ISSET(xs->flags, SCSI_NOSLEEP)) {
		printf("%s: POLL && NOSLEEP for 0x%02x\n", DEVNAME(sc),
		    xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	ccb->ccb_xs = xs;

	mtx_enter(&sc->sc_state_mtx);
	if (sc->sc_state == VSCSI_S_RUNNING) {
		running = 1;
		TAILQ_INSERT_TAIL(&sc->sc_ccb_i2t, ccb, ccb_entry);
	}
	mtx_leave(&sc->sc_state_mtx);

	if (!running) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	selwakeup(&sc->sc_sel);

	if (polled) {
		mtx_enter(&sc->sc_poll_mtx);
		while (ccb->ccb_xs != NULL)
			msleep(ccb, &sc->sc_poll_mtx, PRIBIO, "vscsipoll", 0);
		mtx_leave(&sc->sc_poll_mtx);
		scsi_done(xs);
	}
}

void
vscsi_done(struct vscsi_softc *sc, struct vscsi_ccb *ccb)
{
	struct scsi_xfer		*xs = ccb->ccb_xs;

	if (ISSET(xs->flags, SCSI_POLL)) {
		mtx_enter(&sc->sc_poll_mtx);
		ccb->ccb_xs = NULL;
		wakeup(ccb);
		mtx_leave(&sc->sc_poll_mtx);
	} else
		scsi_done(xs);
}

int
vscsi_probe(struct scsi_link *link)
{
	struct vscsi_softc		*sc = link->adapter_softc;
	int				rv = 0;

	mtx_enter(&sc->sc_state_mtx);
	if (sc->sc_state == VSCSI_S_RUNNING)
		sc->sc_ref_count++;
	else
		rv = ENXIO;
	mtx_leave(&sc->sc_state_mtx);

	return (rv);
}

void
vscsi_free(struct scsi_link *link)
{
	struct vscsi_softc		*sc = link->adapter_softc;

	mtx_enter(&sc->sc_state_mtx);
	sc->sc_ref_count--;
	if (sc->sc_state != VSCSI_S_RUNNING && sc->sc_ref_count == 0)
		wakeup(&sc->sc_ref_count);
	mtx_leave(&sc->sc_state_mtx);
}

int
vscsiopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct vscsi_softc		*sc = DEV2SC(dev);
	enum vscsi_state		state = VSCSI_S_RUNNING;
	int				rv = 0;

	if (sc == NULL)
		return (ENXIO);

	mtx_enter(&sc->sc_state_mtx);
	if (sc->sc_state != VSCSI_S_CLOSED)
		rv = EBUSY;
	else
		sc->sc_state = VSCSI_S_CONFIG;
	mtx_leave(&sc->sc_state_mtx);

	if (rv != 0) {
		device_unref(&sc->sc_dev);
		return (rv);
	}

	pool_init(&sc->sc_ccb_pool, sizeof(struct vscsi_ccb), 0, IPL_BIO, 0,
	    "vscsiccb", NULL);

	/* we need to guarantee some ccbs will be available for the iopool */
	rv = pool_prime(&sc->sc_ccb_pool, 8);
	if (rv != 0) {
		pool_destroy(&sc->sc_ccb_pool);
		state = VSCSI_S_CLOSED;
	}

	/* commit changes */
	mtx_enter(&sc->sc_state_mtx);
	sc->sc_state = state;
	mtx_leave(&sc->sc_state_mtx);

	device_unref(&sc->sc_dev);
	return (rv);
}

int
vscsiioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	struct vscsi_softc		*sc = DEV2SC(dev);
	int				read = 0;
	int				err = 0;

	if (sc == NULL)
		return (ENXIO);

	rw_enter_write(&sc->sc_ioc_lock);

	switch (cmd) {
	case VSCSI_I2T:
		err = vscsi_i2t(sc, (struct vscsi_ioc_i2t *)addr);
		break;

	case VSCSI_DATA_READ:
		read = 1;
	case VSCSI_DATA_WRITE:
		err = vscsi_data(sc, (struct vscsi_ioc_data *)addr, read);
		break;

	case VSCSI_T2I:
		err = vscsi_t2i(sc, (struct vscsi_ioc_t2i *)addr);
		break;

	case VSCSI_REQPROBE:
	case VSCSI_REQDETACH:
		err = vscsi_devevent(sc, cmd,
		    (struct vscsi_ioc_devevent *)addr);
		break;

	default:
		err = ENOTTY;
		break;
	}

	rw_exit_write(&sc->sc_ioc_lock);

	device_unref(&sc->sc_dev);
	return (err);
}

int
vscsi_i2t(struct vscsi_softc *sc, struct vscsi_ioc_i2t *i2t)
{
	struct vscsi_ccb		*ccb;
	struct scsi_xfer		*xs;
	struct scsi_link		*link;

	mtx_enter(&sc->sc_state_mtx);
	ccb = TAILQ_FIRST(&sc->sc_ccb_i2t);
	if (ccb != NULL)
		TAILQ_REMOVE(&sc->sc_ccb_i2t, ccb, ccb_entry);
	mtx_leave(&sc->sc_state_mtx);

	if (ccb == NULL)
		return (EAGAIN);

	xs = ccb->ccb_xs;
	link = xs->sc_link;

	i2t->tag = ccb->ccb_tag;
	i2t->target = link->target;
	i2t->lun = link->lun;
	memcpy(&i2t->cmd, xs->cmd, xs->cmdlen);
	i2t->cmdlen = xs->cmdlen;
	i2t->datalen = xs->datalen;

	switch (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
	case SCSI_DATA_IN:
		i2t->direction = VSCSI_DIR_READ;
		break;
	case SCSI_DATA_OUT:
		i2t->direction = VSCSI_DIR_WRITE;
		break;
	default:
		i2t->direction = VSCSI_DIR_NONE;
		break;
	}

	TAILQ_INSERT_TAIL(&sc->sc_ccb_t2i, ccb, ccb_entry);

	return (0);
}

int
vscsi_data(struct vscsi_softc *sc, struct vscsi_ioc_data *data, int read)
{
	struct vscsi_ccb		*ccb;
	struct scsi_xfer		*xs;
	int				xsread;
	u_int8_t			*buf;
	int				rv = EINVAL;

	TAILQ_FOREACH(ccb, &sc->sc_ccb_t2i, ccb_entry) {
		if (ccb->ccb_tag == data->tag)
			break;
	}
	if (ccb == NULL)
		return (EFAULT);

	xs = ccb->ccb_xs;

	if (data->datalen > xs->datalen - ccb->ccb_datalen)
		return (ENOMEM);

	switch (xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT)) {
	case SCSI_DATA_IN:
		xsread = 1;
		break;
	case SCSI_DATA_OUT:
		xsread = 0;
		break;
	default:
		return (EINVAL);
	}

	if (read != xsread)
		return (EINVAL);

	buf = xs->data;
	buf += ccb->ccb_datalen;

	if (read)
		rv = copyin(data->data, buf, data->datalen);
	else
		rv = copyout(buf, data->data, data->datalen);

	if (rv == 0)
		ccb->ccb_datalen += data->datalen;

	return (rv);
}

int
vscsi_t2i(struct vscsi_softc *sc, struct vscsi_ioc_t2i *t2i)
{
	struct vscsi_ccb		*ccb;
	struct scsi_xfer		*xs;
	int				rv = 0;

	TAILQ_FOREACH(ccb, &sc->sc_ccb_t2i, ccb_entry) {
		if (ccb->ccb_tag == t2i->tag)
			break;
	}
	if (ccb == NULL)
		return (EFAULT);

	TAILQ_REMOVE(&sc->sc_ccb_t2i, ccb, ccb_entry);

	xs = ccb->ccb_xs;

	xs->resid = xs->datalen - ccb->ccb_datalen;
	xs->status = SCSI_OK;

	switch (t2i->status) {
	case VSCSI_STAT_DONE:
		xs->error = XS_NOERROR;
		break;
	case VSCSI_STAT_SENSE:
		xs->error = XS_SENSE;
		memcpy(&xs->sense, &t2i->sense, sizeof(xs->sense));
		break;
	case VSCSI_STAT_RESET:
		xs->error = XS_RESET;
		break;
	case VSCSI_STAT_ERR:
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	vscsi_done(sc, ccb);

	return (rv);
}

struct vscsi_devevent_task {
	struct vscsi_softc *sc;
	struct task t;
	struct vscsi_ioc_devevent de;
	u_long cmd;
};

int
vscsi_devevent(struct vscsi_softc *sc, u_long cmd,
    struct vscsi_ioc_devevent *de)
{
	struct vscsi_devevent_task *dt;

	dt = malloc(sizeof(*dt), M_TEMP, M_WAITOK | M_CANFAIL);
	if (dt == NULL)
		return (ENOMEM);

	task_set(&dt->t, vscsi_devevent_task, dt);
	dt->sc = sc;
	dt->de = *de;
	dt->cmd = cmd;

	device_ref(&sc->sc_dev);
	task_add(systq, &dt->t);

	return (0);
}

void
vscsi_devevent_task(void *xdt)
{
	struct vscsi_devevent_task *dt = xdt;
	struct vscsi_softc *sc = dt->sc;
	int state;

	mtx_enter(&sc->sc_state_mtx);
	state = sc->sc_state;
	mtx_leave(&sc->sc_state_mtx);

	if (state != VSCSI_S_RUNNING)
		goto gone;

	switch (dt->cmd) {
	case VSCSI_REQPROBE:
		scsi_probe(sc->sc_scsibus, dt->de.target, dt->de.lun);
		break;
	case VSCSI_REQDETACH:
		scsi_detach(sc->sc_scsibus, dt->de.target, dt->de.lun,
		    DETACH_FORCE);
		break;
#ifdef DIAGNOSTIC
	default:
		panic("unexpected vscsi_devevent cmd");
		/* NOTREACHED */
#endif
	}

gone:
	device_unref(&sc->sc_dev);

	free(dt, M_TEMP, sizeof(*dt));
}

int
vscsipoll(dev_t dev, int events, struct proc *p)
{
	struct vscsi_softc		*sc = DEV2SC(dev);
	int				revents = 0;

	if (sc == NULL)
		return (ENXIO);

	if (events & (POLLIN | POLLRDNORM)) {
		mtx_enter(&sc->sc_state_mtx);
		if (!TAILQ_EMPTY(&sc->sc_ccb_i2t))
			revents |= events & (POLLIN | POLLRDNORM);
		mtx_leave(&sc->sc_state_mtx);
	}

	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &sc->sc_sel);
	}

	device_unref(&sc->sc_dev);
	return (revents);
}

int
vscsikqfilter(dev_t dev, struct knote *kn)
{
	struct vscsi_softc *sc = DEV2SC(dev);
	struct klist *klist;

	if (sc == NULL)
		return (ENXIO);

	klist = &sc->sc_sel.si_note;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &vscsi_filtops;
		break;
	default:
		device_unref(&sc->sc_dev);
		return (EINVAL);
	}

	kn->kn_hook = sc;

	mtx_enter(&sc->sc_sel_mtx);
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	mtx_leave(&sc->sc_sel_mtx);

	/* device ref is given to the knote in the klist */

	return (0);
}

void
filt_vscsidetach(struct knote *kn)
{
	struct vscsi_softc *sc = kn->kn_hook;
	struct klist *klist = &sc->sc_sel.si_note;
 
	mtx_enter(&sc->sc_sel_mtx);
	SLIST_REMOVE(klist, kn, knote, kn_selnext);
	mtx_leave(&sc->sc_sel_mtx);

	device_unref(&sc->sc_dev);
}

int
filt_vscsiread(struct knote *kn, long hint)
{
	struct vscsi_softc *sc = kn->kn_hook;
	int event = 0;

	mtx_enter(&sc->sc_state_mtx);
	if (!TAILQ_EMPTY(&sc->sc_ccb_i2t))
		event = 1;
	mtx_leave(&sc->sc_state_mtx);

	return (event);
}

int
vscsiclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct vscsi_softc		*sc = DEV2SC(dev);
	struct vscsi_ccb		*ccb;

	if (sc == NULL)
		return (ENXIO);

	mtx_enter(&sc->sc_state_mtx);
	KASSERT(sc->sc_state == VSCSI_S_RUNNING);
	sc->sc_state = VSCSI_S_CONFIG;
	mtx_leave(&sc->sc_state_mtx);

	scsi_activate(sc->sc_scsibus, -1, -1, DVACT_DEACTIVATE);

	while ((ccb = TAILQ_FIRST(&sc->sc_ccb_t2i)) != NULL) {
		TAILQ_REMOVE(&sc->sc_ccb_t2i, ccb, ccb_entry);
		ccb->ccb_xs->error = XS_RESET;
		vscsi_done(sc, ccb);
	}

	while ((ccb = TAILQ_FIRST(&sc->sc_ccb_i2t)) != NULL) {
		TAILQ_REMOVE(&sc->sc_ccb_i2t, ccb, ccb_entry);
		ccb->ccb_xs->error = XS_RESET;
		vscsi_done(sc, ccb);
	}

	scsi_req_detach(sc->sc_scsibus, -1, -1, DETACH_FORCE);

	mtx_enter(&sc->sc_state_mtx);
	while (sc->sc_ref_count > 0) {
		msleep(&sc->sc_ref_count, &sc->sc_state_mtx,
		    PRIBIO, "vscsiref", 0);
	}
	mtx_leave(&sc->sc_state_mtx);

	pool_destroy(&sc->sc_ccb_pool);

	mtx_enter(&sc->sc_state_mtx);
	sc->sc_state = VSCSI_S_CLOSED;
	mtx_leave(&sc->sc_state_mtx);

	device_unref(&sc->sc_dev);
	return (0);
}

void *
vscsi_ccb_get(void *cookie)
{
	struct vscsi_softc		*sc = cookie;
	struct vscsi_ccb		*ccb = NULL;

	ccb = pool_get(&sc->sc_ccb_pool, PR_NOWAIT);
	if (ccb != NULL) {
		ccb->ccb_tag = sc->sc_ccb_tag++;
		ccb->ccb_datalen = 0;
	}

	return (ccb);
}

void
vscsi_ccb_put(void *cookie, void *io)
{
	struct vscsi_softc		*sc = cookie;
	struct vscsi_ccb		*ccb = io;

	pool_put(&sc->sc_ccb_pool, ccb);
}
@


1.40
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.39 2015/08/27 18:54:02 deraadt Exp $ */
a431 1
	struct scsi_link		*link;
a443 1
	link = xs->sc_link;
@


1.39
log
@fairly simple size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.38 2015/03/14 03:38:46 jsg Exp $ */
d272 1
a272 1
	pool_init(&sc->sc_ccb_pool, sizeof(struct vscsi_ccb), 0, 0, 0,
a273 1
	pool_setipl(&sc->sc_ccb_pool, IPL_BIO);
@


1.38
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.37 2015/01/27 03:17:36 dlg Exp $ */
d533 1
a533 1
	free(dt, M_TEMP, 0);
@


1.37
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.36 2015/01/02 10:38:22 dlg Exp $ */
a20 1
#include <sys/buf.h>
@


1.36
log
@give the device ref taken in vscsikqfilter to the knote, and unref
it in filt_vscsidetach.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.35 2015/01/02 10:32:21 dlg Exp $ */
d111 1
a111 1
void		vscsi_devevent_task(void *, void *);
d491 1
a491 1
	task_set(&dt->t, vscsi_devevent_task, dt, NULL);
d503 1
a503 1
vscsi_devevent_task(void *xdt, void *null)
@


1.35
log
@store all state needed to defer probe/detach events in vscsi_devevent_task.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.34 2014/10/17 02:05:06 tedu Exp $ */
d588 2
a589 1
	device_unref(&sc->sc_dev);
d602 2
@


1.34
log
@convert old b functions to mem functions
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.33 2014/10/10 09:50:32 jmatthew Exp $ */
d475 1
d491 2
a492 1
	task_set(&dt->t, vscsi_devevent_task, sc, dt);
d503 1
a503 1
vscsi_devevent_task(void *xsc, void *xdt)
a504 1
	struct vscsi_softc *sc = xsc;
d506 1
@


1.33
log
@fix compilation without DIAGNOSTIC

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.32 2014/09/22 01:09:29 dlg Exp $ */
d159 1
a159 1
	bzero(&saa, sizeof(saa));
d359 1
a359 1
	bcopy(xs->cmd, &i2t->cmd, xs->cmdlen);
d458 1
a458 1
		bcopy(&t2i->sense, &xs->sense, sizeof(xs->sense));
@


1.32
log
@the kn_hook member of a knote is a void *, so we dont have to cast
to or from it.

ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.31 2014/09/14 14:17:24 jsg Exp $ */
d526 1
a527 1
#endif
@


1.31
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.30 2014/07/12 18:48:51 tedu Exp $ */
d580 1
a580 1
	kn->kn_hook = (caddr_t)sc;
d593 1
a593 1
	struct vscsi_softc *sc = (struct vscsi_softc *)kn->kn_hook;
d604 1
a604 1
	struct vscsi_softc *sc = (struct vscsi_softc *)kn->kn_hook;
@


1.30
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.29 2014/04/22 08:48:51 dlg Exp $ */
a24 1
#include <sys/proc.h>
@


1.29
log
@move vscsi from using scsi_req_probe and scsi_req_detach to using
the newly minted scsi_probe and scsi_detach respectively from a
task it runs itself.

the probe and detach ioctls requests work the same before and after
this change, but this paves the way for vscsi being able to report
the status of these requests back to userland.

discussed with claudio@@
tested with current iscsid and an md3200i
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.28 2014/01/22 01:21:33 dlg Exp $ */
d533 1
a533 1
	free(dt, M_TEMP);
@


1.28
log
@iscsid can handle multiple outstanding commands per lun. with the latency
on iscsi the way it is, you need to get concurrent io up in the air.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.27 2013/05/10 18:33:55 mikeb Exp $ */
d30 1
d110 3
a112 1

a297 1
	struct vscsi_ioc_devevent	*de = (struct vscsi_ioc_devevent *)addr;
a321 3
		err = scsi_req_probe(sc->sc_scsibus, de->target, de->lun);
		break;

d323 2
a324 2
		err = scsi_req_detach(sc->sc_scsibus, de->target, de->lun,
		    DETACH_FORCE);
d473 61
@


1.27
log
@bail if device_lookup doesn't find anything;  brings vscsi(4)
in line with other drivers.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.26 2011/07/17 22:46:48 matthew Exp $ */
d154 1
a154 1
	sc->sc_link.openings = 1;
@


1.26
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.25 2011/07/08 22:09:27 matthew Exp $ */
d299 3
d482 3
d503 1
a503 1
{ 
d505 6
a510 1
	struct klist *klist = &sc->sc_sel.si_note;
d561 3
@


1.25
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.24 2011/07/02 22:20:07 nicm Exp $ */
d153 1
a158 1
	saa.saa_targets = 256;
@


1.24
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.23 2011/04/28 11:24:36 dlg Exp $ */
a152 1
	sc->sc_link.adapter_buswidth = 256;
d158 1
@


1.23
log
@report XS_RESET to the midlayer for any pending commands when vscsi is
closed. if you're using iscsid with mpath, this will let mpath retry the
commands when iscsid comes back.

discussed with claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.22 2011/04/05 15:28:49 dlg Exp $ */
d507 1
a507 1
		return (1);
@


1.22
log
@provide VSCSI_STAT_RESET so userland can tell us that the connection to
the device was reset rather than blindly fail it.

requested by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.21 2010/09/25 00:31:31 dlg Exp $ */
d560 1
a560 1
		ccb->ccb_xs->error = XS_DRIVER_STUFFUP;
d566 1
a566 1
		ccb->ccb_xs->error = XS_DRIVER_STUFFUP;
@


1.21
log
@when vscsi is closed, deactivate all child devices so when we kill the
commands still on the queues the child device wont retry it cos its been
deactivated.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.20 2010/09/22 04:52:10 matthew Exp $ */
d458 3
@


1.20
log
@Call config_deactivate() on SCSI links in vscsiclose().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.19 2010/09/22 03:51:47 dlg Exp $ */
d553 2
a566 1
	scsi_activate(sc->sc_scsibus, -1, -1, DVACT_DEACTIVATE);
@


1.19
log
@when vscsi is closed request a detach of its children devices from
the same thread theyre attached in (syswq) rather than in teh vscsi
process context. this serialises attach and detach so we can avoid
weird races with autoconf.

also, count the devices on the bus rather than the outstanding commands.

fixes some stuff for matthew@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.18 2010/09/21 04:33:35 matthew Exp $ */
d565 1
@


1.18
log
@Add device_unref() calls as appropriate to vscsi(4) to fix reference
counting.  Not really an issue, but dlg@@ was teasing me about not
finding any vscsi(4) bugs in a while. ;)

"i trust you" dlg@@ (without seeing the diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.17 2010/07/24 20:15:31 matthew Exp $ */
d65 1
a65 1
	u_int			sc_ccb_count;
d97 1
d103 1
a103 1
	NULL
d225 1
a225 1
	int				rv;
d228 4
a231 1
	rv = (sc->sc_state == VSCSI_S_RUNNING) ? 0 : ENXIO;
d237 12
d273 1
a546 1
	int				i;
d565 2
d568 3
a570 3
	while (sc->sc_ccb_count > 0) {
		msleep(&sc->sc_ccb_count, &sc->sc_state_mtx,
		    PRIBIO, "vscsiccb", 0);
a575 3
	for (i = 0; i < sc->sc_link.adapter_buswidth; i++)
		scsi_detach_target(sc->sc_scsibus, i, DETACH_FORCE);

d590 2
a591 3
	mtx_enter(&sc->sc_state_mtx);
	if (sc->sc_state == VSCSI_S_RUNNING &&
	    (ccb = pool_get(&sc->sc_ccb_pool, PR_NOWAIT)) != NULL) {
a593 2

		sc->sc_ccb_count++;
a594 1
	mtx_leave(&sc->sc_state_mtx);
a604 2
	mtx_enter(&sc->sc_state_mtx);

a605 7
	sc->sc_ccb_count--;

	if (sc->sc_state != VSCSI_S_RUNNING &&
	    sc->sc_ccb_count == 0)
		wakeup(&sc->sc_ccb_count);

	mtx_leave(&sc->sc_state_mtx);
@


1.17
log
@Restore a needed 'return' removed in the last commit, and stylistic
tweak to eliminate an 'else' clause.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.16 2010/07/24 11:53:44 dlg Exp $ */
d250 2
a251 1
	if (rv != 0)
d253 1
d270 1
d315 1
d471 1
d486 1
d496 1
d565 1
@


1.16
log
@fix another race. vscsi_cmd checked if the adapter was running at
the start and queued the command for processing by userland later.
the adapter could stop running between the check and the queue.
this merges the state and queue mutexes and combines the check and
queue ops in vscsi_cmd into the same critical section.

tweaked by and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.15 2010/07/23 09:41:16 dlg Exp $ */
d170 1
a170 1
	int				running = 1;
d177 1
d183 2
a184 1
	if (sc->sc_state == VSCSI_S_RUNNING)
d186 1
a186 2
	else
		running = 0;
@


1.15
log
@matthew@@ noted a possible misuse of the rwlock used to protect vscsi
from being opened by multiple processes at the same time. then he
pointed out that pool_get can sleep in the middle of scsi_cmd,
during which time the process processing the vscsi requests can go
away.

this uses a state variable to protect vscsi from multiple opens
which is checked by all the process and scsi midlayer entrypoints.
it avoids a potential sleep in the middle of the scsi_cmd handler
by moving to iopools.

lots of tweaks and feedback by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.14 2010/06/28 18:31:01 krw Exp $ */
a72 1
	struct mutex		sc_ccb_mtx;
a104 2
int		vscsi_running(struct vscsi_softc *);

a143 1
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
a162 12
int
vscsi_running(struct vscsi_softc *sc)
{
	int				running;

	mtx_enter(&sc->sc_state_mtx);
	running = (sc->sc_state == VSCSI_S_RUNNING);
	mtx_leave(&sc->sc_state_mtx);

	return (running);
}

d170 1
d172 3
a174 1
	if (!vscsi_running(sc)) {
a176 1
		return;
d179 10
a188 3
	if (ISSET(xs->flags, SCSI_POLL) && ISSET(xs->flags, SCSI_NOSLEEP)) {
		printf("%s: POLL && NOSLEEP for 0x%02x\n", DEVNAME(sc),
		    xs->cmd->opcode);
a193 5
	ccb->ccb_xs = xs;
	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_TAIL(&sc->sc_ccb_i2t, ccb, ccb_entry);
	mtx_leave(&sc->sc_ccb_mtx);

d223 1
d225 3
a227 2
	if (!vscsi_running(sc))
		return (ENXIO);
d229 1
a229 1
	return (0);
d321 1
a321 1
	mtx_enter(&sc->sc_ccb_mtx);
d325 1
a325 1
	mtx_leave(&sc->sc_ccb_mtx);
d455 1
a455 1
		mtx_enter(&sc->sc_ccb_mtx);
d458 1
a458 1
		mtx_leave(&sc->sc_ccb_mtx);
d509 1
a509 1
	mtx_enter(&sc->sc_ccb_mtx);
d512 1
a512 1
	mtx_leave(&sc->sc_ccb_mtx);
@


1.14
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.13 2010/06/27 03:34:29 matthew Exp $ */
d52 6
d63 3
d67 3
d74 2
a75 1
	struct rwlock		sc_ccb_polling;
a78 3

	struct rwlock		sc_open;
	volatile int		sc_opened;
d106 1
a106 2
void		vscsi_xs_stuffup(struct scsi_xfer *);

d112 4
a115 2
struct vscsi_ccb *	vscsi_ccb_get(struct vscsi_softc *, int);
#define vscsi_ccb_put(_s, _c) pool_put(&(_s)->sc_ccb_pool, (_c))
d142 10
a151 2
	rw_init(&sc->sc_open, DEVNAME(sc));
	rw_init(&sc->sc_ccb_polling, DEVNAME(sc));
d158 1
d167 12
d184 1
a184 1
	struct vscsi_ccb		*ccb;
d187 3
a189 2
	if (sc->sc_opened == 0) { 
		vscsi_xs_stuffup(xs);
d196 2
a197 7
		vscsi_xs_stuffup(xs);
		return;
	}

	ccb = vscsi_ccb_get(sc, ISSET(xs->flags, SCSI_NOSLEEP) ? 0 : 1);
	if (ccb == NULL) {
		vscsi_xs_stuffup(xs);
d209 1
a209 1
		rw_enter_read(&sc->sc_ccb_polling);
d211 3
a213 3
			tsleep(ccb, PRIBIO, "vscsipoll", 0);
		vscsi_ccb_put(sc, ccb);
		rw_exit_read(&sc->sc_ccb_polling);
d218 1
a218 1
vscsi_xs_stuffup(struct scsi_xfer *xs)
d220 9
a228 2
	xs->error = XS_DRIVER_STUFFUP;
	scsi_done(xs);
d236 1
a236 1
	if (sc->sc_opened == 0)
d246 2
a247 1
	int				rv;
d252 7
a258 1
	rv = rw_enter(&sc->sc_open, RW_WRITE | RW_NOSLEEP);
a263 5
	pool_setipl(&sc->sc_ccb_pool, IPL_BIO);
	TAILQ_INIT(&sc->sc_ccb_i2t);
	TAILQ_INIT(&sc->sc_ccb_t2i);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	mtx_init(&sc->sc_sel_mtx, IPL_BIO);
d265 11
a275 1
	sc->sc_opened = 1;
d277 1
a277 1
	return (0);
d288 2
d319 2
a422 1
	int				polled;
d453 1
a453 9
	polled = ISSET(xs->flags, SCSI_POLL);

	scsi_done(xs);

	if (polled) {
		ccb->ccb_xs = NULL;
		wakeup(ccb);
	} else
		vscsi_ccb_put(sc, ccb);
a531 1
	int				polled;
d534 4
a537 1
	sc->sc_opened = 0;
d541 2
a542 9
		polled = ISSET(ccb->ccb_xs->flags, SCSI_POLL);

		vscsi_xs_stuffup(ccb->ccb_xs);

		if (polled) {
			ccb->ccb_xs = NULL;
			wakeup(ccb);
		} else
			vscsi_ccb_put(sc, ccb);
d547 3
a549 3
		polled = ISSET(ccb->ccb_xs->flags, SCSI_POLL);

		vscsi_xs_stuffup(ccb->ccb_xs);
d551 4
a554 5
		if (polled) {
			ccb->ccb_xs = NULL;
			wakeup(ccb);
		} else
			vscsi_ccb_put(sc, ccb);
d556 1
a557 1
	rw_enter_write(&sc->sc_ccb_polling);
a558 1
	rw_exit_write(&sc->sc_ccb_polling);
d563 3
a565 1
	rw_exit(&sc->sc_open);
d570 2
a571 2
struct vscsi_ccb *
vscsi_ccb_get(struct vscsi_softc *sc, int waitok)
d573 2
a574 1
	struct vscsi_ccb		*ccb;
d576 5
a580 3
	ccb = pool_get(&sc->sc_ccb_pool, waitok ? PR_WAITOK : PR_NOWAIT);
	if (ccb == NULL)
		return (NULL);
d582 3
a584 2
	ccb->ccb_tag = sc->sc_ccb_tag++;
	ccb->ccb_datalen = 0;
d587 18
@


1.13
log
@"Believe it or not," nothing uses scsi_xfer's req_sense_length field
in any meaningful way, so just get rid of it.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.12 2010/06/21 13:47:10 dlg Exp $ */
a95 4
struct scsi_device vscsi_dev = {
	NULL, NULL, NULL, NULL
};

a133 1
	sc->sc_link.device = &vscsi_dev;
@


1.12
log
@avoid an overflow of the xs sense buffer by ignoring t2i->senselen.

again, found by and fixed by matthew dempsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.11 2010/06/21 13:28:09 dlg Exp $ */
a400 1
		xs->req_sense_length = t2i->senselen;
@


1.11
log
@fix an integer arithmetic overflow.

An attacker can get past the ENOMEM check in vscsi_data() by first
reading/writing 1 byte and then reading/writing 0xffffffff bytes.

found and fixed by matthew dempsky
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.10 2010/06/10 05:31:41 armani Exp $ */
d400 1
a400 1
		bcopy(&t2i->sense, &xs->sense, t2i->senselen);
@


1.10
log
@vscsi just works, as a proof the debug macro is wrong and was never used,
just remove it.

"vscsi is kinda perfect" "you should delete it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.9 2010/05/20 00:55:17 krw Exp $ */
d339 1
a339 1
	if (data->datalen + ccb->ccb_datalen > xs->datalen)
@


1.9
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.8 2010/03/23 01:57:19 krw Exp $ */
a37 13

#ifdef VSCSI_DEBUG
#define VSCSI_D_INIT	(1<<0)

int vscsidebug = 0;

#define DPRINTF(_m, _p...)	do { \
					if (ISSET(vscsidebug, (_m))) \
						printf(p); \
				} while (0)
#else
#define DPRINTF(_m, _p...)	/* _m, _p */
#endif
@


1.8
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.7 2010/03/21 07:02:02 dlg Exp $ */
a209 2
	int				s;

a210 1
	s = splbio();
a211 1
	splx(s);
a390 1
	int				s;
a423 1
	s = splbio();
a424 1
	splx(s);
@


1.7
log
@remove definitions of VSCSI_DEBUG stuff. they were never used.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.6 2010/03/14 01:43:43 dlg Exp $ */
d39 13
d99 1
a99 1
int		vscsi_cmd(struct scsi_xfer *);
d165 1
a165 1
int
d175 1
a175 1
		return (COMPLETE);
d182 1
a182 1
		return (COMPLETE);
d188 1
a188 1
		return (COMPLETE);
a203 1
		return (COMPLETE);
a204 2

	return (SUCCESSFULLY_QUEUED);
@


1.6
log
@when closing, remove commands from the right queues as we iterate over
them, rather than the next queue.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.5 2010/01/09 23:15:06 krw Exp $ */
a37 13

#ifdef VSCSI_DEBUG
#define VSCSI_D_INIT	(1<<0)

int vscsidebug = 0;

#define DPRINTF(_m, _p...)	do { \
					if (ISSET(vscsidebug, (_m))) \
						printf(p); \
				} while (0)
#else
#define DPRINTF(_m, _p...)	/* _m, _p */
#endif
@


1.5
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.4 2009/11/09 17:53:39 nicm Exp $ */
d525 1
a525 1
		TAILQ_REMOVE(&sc->sc_ccb_i2t, ccb, ccb_entry);
@


1.4
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.3 2009/08/13 19:51:49 dlg Exp $ */
a215 1
	xs->flags |= ITSDONE;
a431 1
	xs->flags |= ITSDONE;
@


1.3
log
@add ioctls to allow userland to initiator a probe or detach of devices it
is providing to the kernel. this uses the req api i just added, otherwise
attaches and detaches would be run from the context of the process issuing
the ioctls, which then will not be able to answer them since theyre busy
running the attach/detach in the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.2 2009/02/16 21:19:06 miod Exp $ */
a196 1
	KNOTE(&sc->sc_sel.si_note, 0);
@


1.2
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: vscsi.c,v 1.1 2008/12/03 23:39:32 dlg Exp $ */
d264 1
d281 9
@


1.1
log
@add vscsi(4), a virtual scsi controller that passes all scsi requests up to
userland for handling. this is to scsi what tun(4) is for networks.

this is going into the tree so i can work on some crazy scsi stuff, but its
not being enabled since it is useless unless you're working on some crazy
scsi stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d104 1
a104 1
	minphys,
@

