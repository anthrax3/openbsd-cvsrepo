head	1.39;
access;
symbols
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.39.0.6
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.4
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.6
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14;
locks; strict;
comment	@ * @;


1.39
date	2016.04.24.06.50.58;	author jsg;	state Exp;
branches;
next	1.38;
commitid	RK26UoJ4xncbAIkW;

1.38
date	2016.03.13.11.57.15;	author stsp;	state Exp;
branches;
next	1.37;
commitid	OM3qK2d2aAeGd1n0;

1.37
date	2015.12.07.02.56.36;	author jsg;	state Exp;
branches;
next	1.36;
commitid	WFG8grjpBoS9PhB4;

1.36
date	2015.01.09.07.29.45;	author jsg;	state Exp;
branches;
next	1.35;
commitid	nM2YtwRCeqD1c9uW;

1.35
date	2014.09.23.13.29.30;	author jsg;	state Exp;
branches;
next	1.34;
commitid	3Xsmz1DDM5uWhBVQ;

1.34
date	2014.08.13.07.45.37;	author jsg;	state Exp;
branches;
next	1.33;
commitid	YGAaJF68IQuYIJ8j;

1.33
date	2014.03.10.02.31.12;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2014.02.25.00.18.57;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.11.07.34.49;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.02.06.56.16;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2012.10.05.10.51.28;	author haesbaert;	state Exp;
branches;
next	1.28;

1.28
date	2012.06.29.15.17.32;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2012.05.23.15.36.26;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.21.21.56.53;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2011.04.09.04.33.40;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.27.23.18.32;	author sthen;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.16.04.03.18;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.20.20.51.58;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.17.22.03.47;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.03.09.36.26;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.28.18.19.14;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.19.19.13.33;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.19.19.08.15;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.12.10.23.19;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.05.21.59.01;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.15.10.28.16;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.15.10.06.06;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.05.10.43.15;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.05.08.28.30;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.05.08.16.22;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.02.08.11.25;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.01.20.52.26;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.25.18.46.24;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.25.15.46.14;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2005.12.25.14.54.45;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2005.12.20.05.42.32;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2005.12.19.19.31.56;	author grange;	state Exp;
branches;
next	;


desc
@@


1.39
log
@match on Intel 100 Series LP
@
text
@/*	$OpenBSD: ichiic.c,v 1.38 2016/03/13 11:57:15 stsp Exp $	*/

/*
 * Copyright (c) 2005, 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Intel ICH SMBus controller driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>

#include <machine/bus.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>

#include <dev/pci/ichreg.h>

#include <dev/i2c/i2cvar.h>

#ifdef ICHIIC_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

#define ICHIIC_DELAY	100
#define ICHIIC_TIMEOUT	1

struct ichiic_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	void *			sc_ih;
	int			sc_poll;

	struct i2c_controller	sc_i2c_tag;
	struct rwlock		sc_i2c_lock;
	struct {
		i2c_op_t     op;
		void *       buf;
		size_t       len;
		int          flags;
		volatile int error;
	}			sc_i2c_xfer;
};

int	ichiic_match(struct device *, void *, void *);
void	ichiic_attach(struct device *, struct device *, void *);

int	ichiic_i2c_acquire_bus(void *, int);
void	ichiic_i2c_release_bus(void *, int);
int	ichiic_i2c_exec(void *, i2c_op_t, i2c_addr_t, const void *, size_t,
	    void *, size_t, int);

int	ichiic_intr(void *);

struct cfattach ichiic_ca = {
	sizeof(struct ichiic_softc),
	ichiic_match,
	ichiic_attach
};

struct cfdriver ichiic_cd = {
	NULL, "ichiic", DV_DULL
};

const struct pci_matchid ichiic_ids[] = {
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_3400_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6SERIES_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6300ESB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6321ESB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_7SERIES_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_8SERIES_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_8SERIES_LP_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_9SERIES_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_9SERIES_LP_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801AA_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801AB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801BA_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801CA_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801DB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801E_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801EB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801FB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801H_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801I_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801JD_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801JI_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_ATOMC2000_PCU_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_BAYTRAIL_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_BRASWELL_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C600_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C600_SMB_IDF_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C600_SMB_IDF_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C600_SMB_IDF_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C610_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C610_MS_SMB_1 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C610_MS_SMB_2 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C610_MS_SMB_3 },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_DH8900_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_EP80579_SMBUS },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_100SERIES_SMB },
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_100SERIES_LP_SMB }
};

int
ichiic_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid(aux, ichiic_ids,
	    sizeof(ichiic_ids) / sizeof(ichiic_ids[0])));
}

void
ichiic_attach(struct device *parent, struct device *self, void *aux)
{
	struct ichiic_softc *sc = (struct ichiic_softc *)self;
	struct pci_attach_args *pa = aux;
	struct i2cbus_attach_args iba;
	pcireg_t conf;
	bus_size_t iosize;
	pci_intr_handle_t ih;
	const char *intrstr = NULL;

	/* Read configuration */
	conf = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_SMB_HOSTC);
	DPRINTF((": conf 0x%08x", conf));

	if ((conf & ICH_SMB_HOSTC_HSTEN) == 0) {
		printf(": SMBus disabled\n");
		return;
	}

	/* Map I/O space */
	if (pci_mapreg_map(pa, ICH_SMB_BASE, PCI_MAPREG_TYPE_IO, 0,
	    &sc->sc_iot, &sc->sc_ioh, NULL, &iosize, 0)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_poll = 1;
	if (conf & ICH_SMB_HOSTC_SMIEN) {
		/* No PCI IRQ */
		printf(": SMI");
	} else {
		/* Install interrupt handler */
		if (pci_intr_map(pa, &ih) == 0) {
			intrstr = pci_intr_string(pa->pa_pc, ih);
			sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
			    ichiic_intr, sc, sc->sc_dev.dv_xname);
			if (sc->sc_ih != NULL) {
				printf(": %s", intrstr);
				sc->sc_poll = 0;
			}
		}
		if (sc->sc_poll)
			printf(": polling");
	}

	printf("\n");

	/* Attach I2C bus */
	rw_init(&sc->sc_i2c_lock, "iiclk");
	sc->sc_i2c_tag.ic_cookie = sc;
	sc->sc_i2c_tag.ic_acquire_bus = ichiic_i2c_acquire_bus;
	sc->sc_i2c_tag.ic_release_bus = ichiic_i2c_release_bus;
	sc->sc_i2c_tag.ic_exec = ichiic_i2c_exec;

	bzero(&iba, sizeof(iba));
	iba.iba_name = "iic";
	iba.iba_tag = &sc->sc_i2c_tag;
	config_found(self, &iba, iicbus_print);

	return;
}

int
ichiic_i2c_acquire_bus(void *cookie, int flags)
{
	struct ichiic_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return (0);

	return (rw_enter(&sc->sc_i2c_lock, RW_WRITE | RW_INTR));
}

void
ichiic_i2c_release_bus(void *cookie, int flags)
{
	struct ichiic_softc *sc = cookie;

	if (cold || sc->sc_poll || (flags & I2C_F_POLL))
		return;

	rw_exit(&sc->sc_i2c_lock);
}

int
ichiic_i2c_exec(void *cookie, i2c_op_t op, i2c_addr_t addr,
    const void *cmdbuf, size_t cmdlen, void *buf, size_t len, int flags)
{
	struct ichiic_softc *sc = cookie;
	u_int8_t *b;
	u_int8_t ctl, st;
	int retries;

	DPRINTF(("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
	    "flags 0x%02x\n", sc->sc_dev.dv_xname, op, addr, cmdlen,
	    len, flags));

	/* Wait for bus to be idle */
	for (retries = 100; retries > 0; retries--) {
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS);
		if (!(st & ICH_SMB_HS_BUSY))
			break;
		DELAY(ICHIIC_DELAY);
	}
	DPRINTF(("%s: exec: st 0x%b\n", sc->sc_dev.dv_xname, st,
	    ICH_SMB_HS_BITS));
	if (st & ICH_SMB_HS_BUSY)
		return (1);

	if (cold || sc->sc_poll)
		flags |= I2C_F_POLL;

	if (!I2C_OP_STOP_P(op) || cmdlen > 1 || len > 2)
		return (1);

	/* Setup transfer */
	sc->sc_i2c_xfer.op = op;
	sc->sc_i2c_xfer.buf = buf;
	sc->sc_i2c_xfer.len = len;
	sc->sc_i2c_xfer.flags = flags;
	sc->sc_i2c_xfer.error = 0;

	/* Set slave address and transfer direction */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_TXSLVA,
	    ICH_SMB_TXSLVA_ADDR(addr) |
	    (I2C_OP_READ_P(op) ? ICH_SMB_TXSLVA_READ : 0));

	b = (void *)cmdbuf;
	if (cmdlen > 0)
		/* Set command byte */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HCMD, b[0]);

	if (I2C_OP_WRITE_P(op)) {
		/* Write data */
		b = buf;
		if (len > 0)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    ICH_SMB_HD0, b[0]);
		if (len > 1)
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    ICH_SMB_HD1, b[1]);
	}

	/* Set SMBus command */
	if (len == 0)
		ctl = ICH_SMB_HC_CMD_BYTE;
	else if (len == 1)
		ctl = ICH_SMB_HC_CMD_BDATA;
	else if (len == 2)
		ctl = ICH_SMB_HC_CMD_WDATA;
	else
		panic("%s: unexpected len %zd", __func__, len);

	if ((flags & I2C_F_POLL) == 0)
		ctl |= ICH_SMB_HC_INTREN;

	/* Start transaction */
	ctl |= ICH_SMB_HC_START;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HC, ctl);

	if (flags & I2C_F_POLL) {
		/* Poll for completion */
		DELAY(ICHIIC_DELAY);
		for (retries = 1000; retries > 0; retries--) {
			st = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    ICH_SMB_HS);
			if ((st & ICH_SMB_HS_BUSY) == 0)
				break;
			DELAY(ICHIIC_DELAY);
		}
		if (st & ICH_SMB_HS_BUSY)
			goto timeout;
		ichiic_intr(sc);
	} else {
		/* Wait for interrupt */
		if (tsleep(sc, PRIBIO, "ichiic", ICHIIC_TIMEOUT * hz))
			goto timeout;
	}

	if (sc->sc_i2c_xfer.error)
		return (1);

	return (0);

timeout:
	/*
	 * Transfer timeout. Kill the transaction and clear status bits.
	 */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HC,
	    ICH_SMB_HC_KILL);
	DELAY(ICHIIC_DELAY);
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS);
	if ((st & ICH_SMB_HS_FAILED) == 0)
		printf("%s: abort failed, status 0x%b\n",
		    sc->sc_dev.dv_xname, st, ICH_SMB_HS_BITS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS, st);
	return (1);
}

int
ichiic_intr(void *arg)
{
	struct ichiic_softc *sc = arg;
	u_int8_t st;
	u_int8_t *b;
	size_t len;

	/* Read status */
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS);

	/* Clear status bits */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS, st);

	/* XXX Ignore SMBALERT# for now */
	if ((st & ICH_SMB_HS_BUSY) != 0 || (st & (ICH_SMB_HS_INTR |
	    ICH_SMB_HS_DEVERR | ICH_SMB_HS_BUSERR | ICH_SMB_HS_FAILED |
	    ICH_SMB_HS_BDONE)) == 0)
		/* Interrupt was not for us */
		return (0);

	DPRINTF(("%s: intr st 0x%b\n", sc->sc_dev.dv_xname, st,
	    ICH_SMB_HS_BITS));

	/* Check for errors */
	if (st & (ICH_SMB_HS_DEVERR | ICH_SMB_HS_BUSERR | ICH_SMB_HS_FAILED)) {
		sc->sc_i2c_xfer.error = 1;
		goto done;
	}

	if (st & ICH_SMB_HS_INTR) {
		if (I2C_OP_WRITE_P(sc->sc_i2c_xfer.op))
			goto done;

		/* Read data */
		b = sc->sc_i2c_xfer.buf;
		len = sc->sc_i2c_xfer.len;
		if (len > 0)
			b[0] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    ICH_SMB_HD0);
		if (len > 1)
			b[1] = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
			    ICH_SMB_HD1);
	}

done:
	if ((sc->sc_i2c_xfer.flags & I2C_F_POLL) == 0)
		wakeup(sc);
	return (1);
}
@


1.38
log
@In ichiic(4), ignore the SMBALERT# interrupt. This interrupt has been
observed to fire for spurious reasons with buggy hardware/bios.
It is being ignored by both FreeBSD and Linux as well.

Fixes GENERIC kernel boot on ADI RCC-VE with buggy bios versions, where
ichiic(4) ended up stealing interrupts from ehci(4), rendering the internal
eMMC flash unusable.

Also, always ackknowledge all interrupts by writing status bits back
to avoid a potential SMBALERT# interrupt storm.

with and ok deraadt@@ kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.37 2015/12/07 02:56:36 jsg Exp $	*/
d123 2
a124 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_100SERIES_SMB }
@


1.37
log
@match on intel 100 series
from and tested by daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.36 2015/01/09 07:29:45 jsg Exp $	*/
d343 5
d350 1
a350 1
	    ICH_SMB_HS_SMBAL | ICH_SMB_HS_BDONE)) == 0)
a355 3

	/* Clear status bits */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS, st);
@


1.36
log
@match on C610
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.35 2014/09/23 13:29:30 jsg Exp $	*/
d122 2
a123 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_EP80579_SMBUS }
@


1.35
log
@add Bay Trail and Braswell SMBus
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.34 2014/08/13 07:45:37 jsg Exp $	*/
d117 4
@


1.34
log
@match on Intel 9 series and 9 series LP PCH, and add 8 series KT to puc
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.33 2014/03/10 02:31:12 jsg Exp $	*/
d111 2
@


1.33
log
@match on C600 IDF controllers and DH8900
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.32 2014/02/25 00:18:57 jsg Exp $	*/
d95 2
@


1.32
log
@match on Atom C2000
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.31 2013/10/11 07:34:49 jsg Exp $	*/
d110 4
@


1.31
log
@match Intel 8 Series SMBus (Lynx Point and Lynx Point-LP)
tested by RD Thrush on Lynx Point
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.30 2013/03/02 06:56:16 jsg Exp $	*/
d108 1
@


1.30
log
@match on EP80579, works fine on a machine I have
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.29 2012/10/05 10:51:28 haesbaert Exp $	*/
d93 2
@


1.29
log
@Avoid uninitiliazed use of ctl and corresponding warnings.
Part of the work to remove -Wno-uninitialized.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.28 2012/06/29 15:17:32 jasper Exp $	*/
d106 2
a107 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_C600_SMB }
@


1.28
log
@match on the 7SERIES_SMB

reminded by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.27 2012/05/23 15:36:26 jsg Exp $	*/
d267 2
@


1.27
log
@add C600 SMBus
ok dlg@@ tested by and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.26 2011/04/21 21:56:53 jsg Exp $	*/
d92 1
@


1.26
log
@match on 6 series smbus, tested by Laurence Tratt
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.25 2011/04/09 04:33:40 deraadt Exp $	*/
d104 2
a105 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801JI_SMB }
@


1.25
log
@use unique wait channels
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.24 2010/04/08 00:23:53 tedu Exp $	*/
d89 1
@


1.24
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.23 2009/10/27 23:18:32 sthen Exp $	*/
d287 1
a287 1
		if (tsleep(sc, PRIBIO, "iicexec", ICHIIC_TIMEOUT * hz))
@


1.23
log
@Add another Intel ICH10 variant and the PCH chipset.
From Brad. PCH tested by bwaichu at yahoo com.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.22 2009/03/29 21:53:52 sthen Exp $	*/
a27 1
#include <sys/proc.h>
@


1.22
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.21 2008/10/16 04:03:18 brad Exp $	*/
d89 1
d103 1
@


1.21
log
@Add ICH10.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.20 2008/04/20 20:51:58 deraadt Exp $	*/
d135 1
a135 1
		printf(": can't map I/O space\n");
@


1.20
log
@be quiet even when errors happen; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.19 2007/10/17 22:03:47 brad Exp $	*/
d101 2
a102 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801I_SMB }
@


1.19
log
@Add the Intel ICH9 chipset.

Tested by damien@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.18 2007/05/03 09:36:26 dlg Exp $	*/
a297 4
	printf("%s: exec: op %d, addr 0x%02x, cmdlen %d, len %d, "
	    "flags 0x%02x: timeout, status 0x%b\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags,
	    st, ICH_SMB_HS_BITS);
@


1.18
log
@convert lockmgr style locks to rwlocks.

input from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.17 2006/09/28 18:19:14 grange Exp $	*/
d100 2
a101 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801H_SMB }
@


1.17
log
@Provide more info in error messages so we can see what's going
on. And some cosmetics in debug messages while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.16 2006/08/19 19:13:33 brad Exp $	*/
d27 1
a27 1
#include <sys/lock.h>
d58 1
a58 1
	struct lock		sc_i2c_lock;
d159 1
a159 1
	lockinit(&sc->sc_i2c_lock, PRIBIO | PCATCH, "iiclk", 0, 0);
d181 1
a181 1
	return (lockmgr(&sc->sc_i2c_lock, LK_EXCLUSIVE, NULL));
d192 1
a192 1
	lockmgr(&sc->sc_i2c_lock, LK_RELEASE, NULL);
@


1.16
log
@add the Intel 82801H SMBus controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.15 2006/08/19 19:08:15 brad Exp $	*/
d123 1
a123 1
	DPRINTF((": conf 0x%x", conf));
d204 3
a206 2
	DPRINTF(("%s: exec: op %d, addr 0x%x, cmdlen %d, len %d, flags 0x%x\n",
	    sc->sc_dev.dv_xname, op, addr, cmdlen, len, flags));
d297 4
a300 2
	printf("%s: timeout, status 0x%b\n", sc->sc_dev.dv_xname, st,
	    ICH_SMB_HS_BITS);
d306 1
a306 1
		printf("%s: transaction abort failed, status 0x%b\n",
@


1.15
log
@add the Intel 6321ESB SMBus controller.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.14 2006/02/12 10:23:19 grange Exp $	*/
d99 2
a100 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_SMB }
@


1.14
log
@Revert previous, seems to cause problems on some machines.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.12 2006/01/15 10:28:16 grange Exp $	*/
d90 1
d99 1
a99 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_SMB },
@


1.13
log
@Deal with bus semaphore.
@
text
@a204 10
	/* Acquire bus semaphore */
	for (retries = 100; retries > 0; retries--) {
		st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS);
		if (!(st & ICH_SMB_HS_INUSE))
			break;
		DELAY(ICHIIC_DELAY);
	}
	if (st & ICH_SMB_HS_INUSE)
		return (1);

d215 1
a215 1
		goto fail;
d221 1
a221 1
		goto fail;
a303 6
	return (1);

fail:
	/* Release bus semaphore */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS,
	    ICH_SMB_HS_INUSE);
@


1.12
log
@In iic_exec don't fail immediately if bus is already busy. It might be
running a BIOS' transfer so wait a bit and try again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.11 2006/01/15 10:06:06 grange Exp $	*/
d205 10
d225 1
a225 1
		return (1);
d231 1
a231 1
		return (1);
d314 6
@


1.11
log
@Sync with piixpm: allow driver to continue to work in polling mode
if it failed to install interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.10 2006/01/05 10:43:15 grange Exp $	*/
d205 7
a211 2
	/* Check if there's a transfer already running */
	st = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ICH_SMB_HS);
@


1.10
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.9 2006/01/05 08:28:30 grange Exp $	*/
d135 1
d137 1
a138 1
		sc->sc_poll = 1;
d141 8
a148 3
		if (pci_intr_map(pa, &ih)) {
			printf(": can't map interrupt\n");
			goto fail;
d150 2
a151 11
		intrstr = pci_intr_string(pa->pa_pc, ih);
		sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO,
		    ichiic_intr, sc, sc->sc_dev.dv_xname);
		if (sc->sc_ih == NULL) {
			printf(": can't establish interrupt");
			if (intrstr != NULL)
				printf(" at %s", intrstr);
			printf("\n");
			goto fail;
		}
		printf(": %s", intrstr);
a168 3

fail:
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, iosize);
@


1.9
log
@Happy New Year!
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.8 2006/01/05 08:16:22 grange Exp $	*/
d166 1
a166 1
	bzero(&iba, sizeof iba);
@


1.8
log
@Reliability fixes:

- don't force enabling host controller
- don't start new transfer if bus is busy
- kill transfer on timeout

Some ideas from kettenis@@; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.7 2006/01/02 08:11:25 brad Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005 Alexander Yurchenko <grange@@openbsd.org>
@


1.7
log
@add the 82801E SMBus controller id.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.6 2006/01/01 20:52:26 deraadt Exp $	*/
d119 9
a134 4
	/* Read configuration */
	conf = pci_conf_read(pa->pa_pc, pa->pa_tag, ICH_SMB_HOSTC);
	DPRINTF((": conf 0x%x", conf));

a156 4
	/* Enable controller */
	pci_conf_write(pa->pa_pc, pa->pa_tag, ICH_SMB_HOSTC,
	    conf | ICH_SMB_HOSTC_HSTEN);

d208 9
a216 4
	DPRINTF(("%s: exec op %d, addr 0x%x, cmdlen %d, len %d, "
	    "flags 0x%x, status 0x%b\n", sc->sc_dev.dv_xname, op, addr,
	    cmdlen, len, flags, bus_space_read_1(sc->sc_iot, sc->sc_ioh,
	    ICH_SMB_HS), ICH_SMB_HS_BITS));
d277 2
a278 5
		if (st & ICH_SMB_HS_BUSY) {
			printf("%s: timeout, status 0x%b\n",
			    sc->sc_dev.dv_xname, st, ICH_SMB_HS_BITS);
			return (1);
		}
d283 2
a284 2
			return (1);
	}	
d290 16
@


1.6
log
@switch from macppc-specific maciic(4) driver to the generic iic(4),
after teaching it to use a function pointer to get back to the OFW
scan.. this will also help the sparc64 later; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.5 2005/12/25 18:46:24 grange Exp $	*/
d89 1
d95 1
a96 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_6300ESB_SMB },
d98 1
a98 1
	{ PCI_VENDOR_INTEL, PCI_PRODUCT_INTEL_82801GB_SMB }
@


1.5
log
@Don't allow slave devices to do polling during autoconf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.4 2005/12/25 15:46:14 grange Exp $	*/
d163 2
a166 1
	iba.iba_scan = 1;
@


1.4
log
@Force polling if interrupts not available.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.3 2005/12/25 14:54:45 grange Exp $	*/
d179 1
a179 1
	if (sc->sc_poll || flags & I2C_F_POLL)
d190 1
a190 1
	if (sc->sc_poll || flags & I2C_F_POLL)
d210 1
a210 1
	if (sc->sc_poll)
@


1.3
log
@Do not make the whole sc_i2c_xfer structure volatile, only the
error field which is modified by the interrupt handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.2 2005/12/20 05:42:32 grange Exp $	*/
d55 1
d113 1
d125 24
a148 4
	/* Install interrupt handler */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		goto fail;
a149 11
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_BIO, ichiic_intr,
	    sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail;
	}
	printf(": %s", intrstr);
d153 1
a153 1
	    ICH_SMB_HOSTC_HSTEN);
d179 1
a179 1
	if (flags & I2C_F_POLL)
d190 1
a190 1
	if (flags & I2C_F_POLL)
d206 6
a211 2
	    "flags 0x%x\n", sc->sc_dev.dv_xname, op, addr, cmdlen,
	    len, flags));
d270 2
a271 1
			printf("%s: timeout\n", sc->sc_dev.dv_xname);
@


1.2
log
@Do bus scanning only if underlying controller asked for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ichiic.c,v 1.1 2005/12/19 19:31:56 grange Exp $	*/
d58 6
a63 6
	volatile struct {
		i2c_op_t op;
		void *   buf;
		size_t   len;
		int      flags;
		int      error;
d260 1
@


1.1
log
@New Intel ICH SMBus driver to be used with the iic(4) framework.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
@

