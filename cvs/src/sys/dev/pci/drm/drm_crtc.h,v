head	1.10;
access;
symbols
	OPENBSD_6_1:1.9.0.6
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.4
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2017.07.01.16.00.25;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	aN6GlSqZJXG1gx72;

1.9
date	2016.04.07.20.33.24;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	b7TUPgWhn5cou224;

1.8
date	2016.04.06.21.12.40;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	QO3FDEetxShNl6Ad;

1.7
date	2016.04.06.14.39.19;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	3RYGzl8Nwjgc2QjX;

1.6
date	2015.09.27.11.09.26;	author jsg;	state Exp;
branches;
next	1.5;
commitid	OkoKp05dU7tP7DK3;

1.5
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	lQlppvmETCN49oZe;

1.4
date	2015.07.11.04.00.46;	author jsg;	state Exp;
branches;
next	1.3;
commitid	eVKv6xUxvZe6BPUh;

1.3
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.2;
commitid	C5l5rZ5v9mpRR1eS;

1.2
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright © 2006 Keith Packard
 * Copyright © 2007-2008 Dave Airlie
 * Copyright © 2007-2008 Intel Corporation
 *   Jesse Barnes <jesse.barnes@@intel.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
#ifndef __DRM_CRTC_H__
#define __DRM_CRTC_H__

#ifdef __linux__
#include <linux/i2c.h>
#include <linux/spinlock.h>
#include <linux/types.h>
#include <linux/idr.h>
#include <linux/fb.h>
#include <linux/hdmi.h>
#include <linux/media-bus-format.h>
#include <uapi/drm/drm_mode.h>
#include <uapi/drm/drm_fourcc.h>
#else
#include <dev/pci/drm/linux_hdmi.h>
#include <dev/pci/drm/drm_mode.h>
#include <dev/pci/drm/drm_fourcc.h>
#endif
#include <dev/pci/drm/drm_linux.h>
#include <dev/pci/drm/drm_modeset_lock.h>

struct drm_device;
struct drm_mode_set;
struct drm_framebuffer;
struct drm_object_properties;
struct drm_file;
struct drm_clip_rect;
struct device_node;
struct fence;

#define DRM_MODE_OBJECT_CRTC 0xcccccccc
#define DRM_MODE_OBJECT_CONNECTOR 0xc0c0c0c0
#define DRM_MODE_OBJECT_ENCODER 0xe0e0e0e0
#define DRM_MODE_OBJECT_MODE 0xdededede
#define DRM_MODE_OBJECT_PROPERTY 0xb0b0b0b0
#define DRM_MODE_OBJECT_FB 0xfbfbfbfb
#define DRM_MODE_OBJECT_BLOB 0xbbbbbbbb
#define DRM_MODE_OBJECT_PLANE 0xeeeeeeee
#define DRM_MODE_OBJECT_ANY 0

struct drm_mode_object {
	uint32_t id;
	uint32_t type;
	struct drm_object_properties *properties;
};

#define DRM_OBJECT_MAX_PROPERTY 24
struct drm_object_properties {
	int count, atomic_count;
	/* NOTE: if we ever start dynamically destroying properties (ie.
	 * not at drm_mode_config_cleanup() time), then we'd have to do
	 * a better job of detaching property from mode objects to avoid
	 * dangling property pointers:
	 */
	struct drm_property *properties[DRM_OBJECT_MAX_PROPERTY];
	/* do not read/write values directly, but use drm_object_property_get_value()
	 * and drm_object_property_set_value():
	 */
	uint64_t values[DRM_OBJECT_MAX_PROPERTY];
};

static inline int64_t U642I64(uint64_t val)
{
	return (int64_t)*((int64_t *)&val);
}
static inline uint64_t I642U64(int64_t val)
{
	return (uint64_t)*((uint64_t *)&val);
}

/* rotation property bits */
#define DRM_ROTATE_MASK 0x0f
#define DRM_ROTATE_0	0
#define DRM_ROTATE_90	1
#define DRM_ROTATE_180	2
#define DRM_ROTATE_270	3
#define DRM_REFLECT_MASK (~DRM_ROTATE_MASK)
#define DRM_REFLECT_X	4
#define DRM_REFLECT_Y	5

enum drm_connector_force {
	DRM_FORCE_UNSPECIFIED,
	DRM_FORCE_OFF,
	DRM_FORCE_ON,         /* force on analog part normally */
	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
};

#include <dev/pci/drm/drm_modes.h>

enum drm_connector_status {
	connector_status_connected = 1,
	connector_status_disconnected = 2,
	connector_status_unknown = 3,
};

enum subpixel_order {
	SubPixelUnknown = 0,
	SubPixelHorizontalRGB,
	SubPixelHorizontalBGR,
	SubPixelVerticalRGB,
	SubPixelVerticalBGR,
	SubPixelNone,
};

#define DRM_COLOR_FORMAT_RGB444		(1<<0)
#define DRM_COLOR_FORMAT_YCRCB444	(1<<1)
#define DRM_COLOR_FORMAT_YCRCB422	(1<<2)
/*
 * Describes a given display (e.g. CRT or flat panel) and its limitations.
 */
struct drm_display_info {
	char name[DRM_DISPLAY_INFO_LEN];

	/* Physical size */
        unsigned int width_mm;
	unsigned int height_mm;

	/* Clock limits FIXME: storage format */
	unsigned int min_vfreq, max_vfreq;
	unsigned int min_hfreq, max_hfreq;
	unsigned int pixel_clock;
	unsigned int bpc;

	enum subpixel_order subpixel_order;
	u32 color_formats;

	const u32 *bus_formats;
	unsigned int num_bus_formats;

	/* Mask of supported hdmi deep color modes */
	u8 edid_hdmi_dc_modes;

	u8 cea_rev;
};

/* data corresponds to displayid vend/prod/serial */
struct drm_tile_group {
	struct kref refcount;
	struct drm_device *dev;
	int id;
	u8 group_data[8];
};

struct drm_framebuffer_funcs {
	/* note: use drm_framebuffer_remove() */
	void (*destroy)(struct drm_framebuffer *framebuffer);
	int (*create_handle)(struct drm_framebuffer *fb,
			     struct drm_file *file_priv,
			     unsigned int *handle);
	/*
	 * Optional callback for the dirty fb ioctl.
	 *
	 * Userspace can notify the driver via this callback
	 * that a area of the framebuffer has changed and should
	 * be flushed to the display hardware.
	 *
	 * See documentation in drm_mode.h for the struct
	 * drm_mode_fb_dirty_cmd for more information as all
	 * the semantics and arguments have a one to one mapping
	 * on this function.
	 */
	int (*dirty)(struct drm_framebuffer *framebuffer,
		     struct drm_file *file_priv, unsigned flags,
		     unsigned color, struct drm_clip_rect *clips,
		     unsigned num_clips);
};

struct drm_framebuffer {
	struct drm_device *dev;
	/*
	 * Note that the fb is refcounted for the benefit of driver internals,
	 * for example some hw, disabling a CRTC/plane is asynchronous, and
	 * scanout does not actually complete until the next vblank.  So some
	 * cleanup (like releasing the reference(s) on the backing GEM bo(s))
	 * should be deferred.  In cases like this, the driver would like to
	 * hold a ref to the fb even though it has already been removed from
	 * userspace perspective.
	 */
	struct kref refcount;
	/*
	 * Place on the dev->mode_config.fb_list, access protected by
	 * dev->mode_config.fb_lock.
	 */
	struct list_head head;
	struct drm_mode_object base;
	const struct drm_framebuffer_funcs *funcs;
	unsigned int pitches[4];
	unsigned int offsets[4];
	uint64_t modifier[4];
	unsigned int width;
	unsigned int height;
	/* depth can be 15 or 16 */
	unsigned int depth;
	int bits_per_pixel;
	int flags;
	uint32_t pixel_format; /* fourcc format */
	struct list_head filp_head;
};

struct drm_property_blob {
	struct drm_mode_object base;
	struct drm_device *dev;
	struct kref refcount;
	struct list_head head_global;
	struct list_head head_file;
	size_t length;
	unsigned char data[];
};

struct drm_property_enum {
	uint64_t value;
	struct list_head head;
	char name[DRM_PROP_NAME_LEN];
};

struct drm_property {
	struct list_head head;
	struct drm_mode_object base;
	uint32_t flags;
	char name[DRM_PROP_NAME_LEN];
	uint32_t num_values;
	uint64_t *values;
	struct drm_device *dev;

	struct list_head enum_list;
};

struct drm_crtc;
struct drm_connector;
struct drm_encoder;
struct drm_pending_vblank_event;
struct drm_plane;
struct drm_bridge;
struct drm_atomic_state;

/**
 * struct drm_crtc_state - mutable CRTC state
 * @@crtc: backpointer to the CRTC
 * @@enable: whether the CRTC should be enabled, gates all other state
 * @@active: whether the CRTC is actively displaying (used for DPMS)
 * @@planes_changed: planes on this crtc are updated
 * @@mode_changed: crtc_state->mode or crtc_state->enable has been changed
 * @@active_changed: crtc_state->active has been toggled.
 * @@connectors_changed: connectors to this crtc have been updated
 * @@plane_mask: bitmask of (1 << drm_plane_index(plane)) of attached planes
 * @@last_vblank_count: for helpers and drivers to capture the vblank of the
 * 	update to ensure framebuffer cleanup isn't done too early
 * @@adjusted_mode: for use by helpers and drivers to compute adjusted mode timings
 * @@mode: current mode timings
 * @@event: optional pointer to a DRM event to signal upon completion of the
 * 	state update
 * @@state: backpointer to global drm_atomic_state
 *
 * Note that the distinction between @@enable and @@active is rather subtile:
 * Flipping @@active while @@enable is set without changing anything else may
 * never return in a failure from the ->atomic_check callback. Userspace assumes
 * that a DPMS On will always succeed. In other words: @@enable controls resource
 * assignment, @@active controls the actual hardware state.
 */
struct drm_crtc_state {
	struct drm_crtc *crtc;

	bool enable;
	bool active;

	/* computed state bits used by helpers and drivers */
	bool planes_changed : 1;
	bool mode_changed : 1;
	bool active_changed : 1;
	bool connectors_changed : 1;

	/* attached planes bitmask:
	 * WARNING: transitional helpers do not maintain plane_mask so
	 * drivers not converted over to atomic helpers should not rely
	 * on plane_mask being accurate!
	 */
	u32 plane_mask;

	/* last_vblank_count: for vblank waits before cleanup */
	u32 last_vblank_count;

	/* adjusted_mode: for use by helpers and drivers */
	struct drm_display_mode adjusted_mode;

	struct drm_display_mode mode;

	/* blob property to expose current mode to atomic userspace */
	struct drm_property_blob *mode_blob;

	struct drm_pending_vblank_event *event;

	struct drm_atomic_state *state;
};

/**
 * struct drm_crtc_funcs - control CRTCs for a given device
 * @@save: save CRTC state
 * @@restore: restore CRTC state
 * @@reset: reset CRTC after state has been invalidated (e.g. resume)
 * @@cursor_set: setup the cursor
 * @@cursor_set2: setup the cursor with hotspot, superseeds @@cursor_set if set
 * @@cursor_move: move the cursor
 * @@gamma_set: specify color ramp for CRTC
 * @@destroy: deinit and free object
 * @@set_property: called when a property is changed
 * @@set_config: apply a new CRTC configuration
 * @@page_flip: initiate a page flip
 * @@atomic_duplicate_state: duplicate the atomic state for this CRTC
 * @@atomic_destroy_state: destroy an atomic state for this CRTC
 * @@atomic_set_property: set a property on an atomic state for this CRTC
 *    (do not call directly, use drm_atomic_crtc_set_property())
 * @@atomic_get_property: get a property on an atomic state for this CRTC
 *    (do not call directly, use drm_atomic_crtc_get_property())
 *
 * The drm_crtc_funcs structure is the central CRTC management structure
 * in the DRM.  Each CRTC controls one or more connectors (note that the name
 * CRTC is simply historical, a CRTC may control LVDS, VGA, DVI, TV out, etc.
 * connectors, not just CRTs).
 *
 * Each driver is responsible for filling out this structure at startup time,
 * in addition to providing other modesetting features, like i2c and DDC
 * bus accessors.
 */
struct drm_crtc_funcs {
	/* Save CRTC state */
	void (*save)(struct drm_crtc *crtc); /* suspend? */
	/* Restore CRTC state */
	void (*restore)(struct drm_crtc *crtc); /* resume? */
	/* Reset CRTC state */
	void (*reset)(struct drm_crtc *crtc);

	/* cursor controls */
	int (*cursor_set)(struct drm_crtc *crtc, struct drm_file *file_priv,
			  uint32_t handle, uint32_t width, uint32_t height);
	int (*cursor_set2)(struct drm_crtc *crtc, struct drm_file *file_priv,
			   uint32_t handle, uint32_t width, uint32_t height,
			   int32_t hot_x, int32_t hot_y);
	int (*cursor_move)(struct drm_crtc *crtc, int x, int y);

	/* Set gamma on the CRTC */
	void (*gamma_set)(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,
			  uint32_t start, uint32_t size);
	/* Object destroy routine */
	void (*destroy)(struct drm_crtc *crtc);

	int (*set_config)(struct drm_mode_set *set);

	/*
	 * Flip to the given framebuffer.  This implements the page
	 * flip ioctl described in drm_mode.h, specifically, the
	 * implementation must return immediately and block all
	 * rendering to the current fb until the flip has completed.
	 * If userspace set the event flag in the ioctl, the event
	 * argument will point to an event to send back when the flip
	 * completes, otherwise it will be NULL.
	 */
	int (*page_flip)(struct drm_crtc *crtc,
			 struct drm_framebuffer *fb,
			 struct drm_pending_vblank_event *event,
			 uint32_t flags);

	int (*set_property)(struct drm_crtc *crtc,
			    struct drm_property *property, uint64_t val);

	/* atomic update handling */
	struct drm_crtc_state *(*atomic_duplicate_state)(struct drm_crtc *crtc);
	void (*atomic_destroy_state)(struct drm_crtc *crtc,
				     struct drm_crtc_state *state);
	int (*atomic_set_property)(struct drm_crtc *crtc,
				   struct drm_crtc_state *state,
				   struct drm_property *property,
				   uint64_t val);
	int (*atomic_get_property)(struct drm_crtc *crtc,
				   const struct drm_crtc_state *state,
				   struct drm_property *property,
				   uint64_t *val);
};

/**
 * struct drm_crtc - central CRTC control structure
 * @@dev: parent DRM device
 * @@port: OF node used by drm_of_find_possible_crtcs()
 * @@head: list management
 * @@mutex: per-CRTC locking
 * @@base: base KMS object for ID tracking etc.
 * @@primary: primary plane for this CRTC
 * @@cursor: cursor plane for this CRTC
 * @@cursor_x: current x position of the cursor, used for universal cursor planes
 * @@cursor_y: current y position of the cursor, used for universal cursor planes
 * @@enabled: is this CRTC enabled?
 * @@mode: current mode timings
 * @@hwmode: mode timings as programmed to hw regs
 * @@x: x position on screen
 * @@y: y position on screen
 * @@funcs: CRTC control functions
 * @@gamma_size: size of gamma ramp
 * @@gamma_store: gamma ramp values
 * @@helper_private: mid-layer private data
 * @@properties: property tracking for this CRTC
 * @@state: current atomic state for this CRTC
 * @@acquire_ctx: per-CRTC implicit acquire context used by atomic drivers for
 * 	legacy ioctls
 *
 * Each CRTC may have one or more connectors associated with it.  This structure
 * allows the CRTC to be controlled.
 */
struct drm_crtc {
	struct drm_device *dev;
	struct device_node *port;
	struct list_head head;

	/*
	 * crtc mutex
	 *
	 * This provides a read lock for the overall crtc state (mode, dpms
	 * state, ...) and a write lock for everything which can be update
	 * without a full modeset (fb, cursor data, ...)
	 */
	struct drm_modeset_lock mutex;

	struct drm_mode_object base;

	/* primary and cursor planes for CRTC */
	struct drm_plane *primary;
	struct drm_plane *cursor;

	/* position of cursor plane on crtc */
	int cursor_x;
	int cursor_y;

	bool enabled;

	/* Requested mode from modesetting. */
	struct drm_display_mode mode;

	/* Programmed mode in hw, after adjustments for encoders,
	 * crtc, panel scaling etc. Needed for timestamping etc.
	 */
	struct drm_display_mode hwmode;

	int x, y;
	const struct drm_crtc_funcs *funcs;

	/* CRTC gamma size for reporting to userspace */
	uint32_t gamma_size;
	uint16_t *gamma_store;

	/* if you are using the helper */
	const void *helper_private;

	struct drm_object_properties properties;

	struct drm_crtc_state *state;

	/*
	 * For legacy crtc ioctls so that atomic drivers can get at the locking
	 * acquire context.
	 */
	struct drm_modeset_acquire_ctx *acquire_ctx;
};

/**
 * struct drm_connector_state - mutable connector state
 * @@connector: backpointer to the connector
 * @@crtc: CRTC to connect connector to, NULL if disabled
 * @@best_encoder: can be used by helpers and drivers to select the encoder
 * @@state: backpointer to global drm_atomic_state
 */
struct drm_connector_state {
	struct drm_connector *connector;

	struct drm_crtc *crtc;  /* do not write directly, use drm_atomic_set_crtc_for_connector() */

	struct drm_encoder *best_encoder;

	struct drm_atomic_state *state;
};

/**
 * struct drm_connector_funcs - control connectors on a given device
 * @@dpms: set power state
 * @@save: save connector state
 * @@restore: restore connector state
 * @@reset: reset connector after state has been invalidated (e.g. resume)
 * @@detect: is this connector active?
 * @@fill_modes: fill mode list for this connector
 * @@set_property: property for this connector may need an update
 * @@destroy: make object go away
 * @@force: notify the driver that the connector is forced on
 * @@atomic_duplicate_state: duplicate the atomic state for this connector
 * @@atomic_destroy_state: destroy an atomic state for this connector
 * @@atomic_set_property: set a property on an atomic state for this connector
 *    (do not call directly, use drm_atomic_connector_set_property())
 * @@atomic_get_property: get a property on an atomic state for this connector
 *    (do not call directly, use drm_atomic_connector_get_property())
 *
 * Each CRTC may have one or more connectors attached to it.  The functions
 * below allow the core DRM code to control connectors, enumerate available modes,
 * etc.
 */
struct drm_connector_funcs {
	int (*dpms)(struct drm_connector *connector, int mode);
	void (*save)(struct drm_connector *connector);
	void (*restore)(struct drm_connector *connector);
	void (*reset)(struct drm_connector *connector);

	/* Check to see if anything is attached to the connector.
	 * @@force is set to false whilst polling, true when checking the
	 * connector due to user request. @@force can be used by the driver
	 * to avoid expensive, destructive operations during automated
	 * probing.
	 */
	enum drm_connector_status (*detect)(struct drm_connector *connector,
					    bool force);
	int (*fill_modes)(struct drm_connector *connector, uint32_t max_width, uint32_t max_height);
	int (*set_property)(struct drm_connector *connector, struct drm_property *property,
			     uint64_t val);
	void (*destroy)(struct drm_connector *connector);
	void (*force)(struct drm_connector *connector);

	/* atomic update handling */
	struct drm_connector_state *(*atomic_duplicate_state)(struct drm_connector *connector);
	void (*atomic_destroy_state)(struct drm_connector *connector,
				     struct drm_connector_state *state);
	int (*atomic_set_property)(struct drm_connector *connector,
				   struct drm_connector_state *state,
				   struct drm_property *property,
				   uint64_t val);
	int (*atomic_get_property)(struct drm_connector *connector,
				   const struct drm_connector_state *state,
				   struct drm_property *property,
				   uint64_t *val);
};

/**
 * struct drm_encoder_funcs - encoder controls
 * @@reset: reset state (e.g. at init or resume time)
 * @@destroy: cleanup and free associated data
 *
 * Encoders sit between CRTCs and connectors.
 */
struct drm_encoder_funcs {
	void (*reset)(struct drm_encoder *encoder);
	void (*destroy)(struct drm_encoder *encoder);
};

#define DRM_CONNECTOR_MAX_ENCODER 3

/**
 * struct drm_encoder - central DRM encoder structure
 * @@dev: parent DRM device
 * @@head: list management
 * @@base: base KMS object
 * @@name: encoder name
 * @@encoder_type: one of the %DRM_MODE_ENCODER_<foo> types in drm_mode.h
 * @@possible_crtcs: bitmask of potential CRTC bindings
 * @@possible_clones: bitmask of potential sibling encoders for cloning
 * @@crtc: currently bound CRTC
 * @@bridge: bridge associated to the encoder
 * @@funcs: control functions
 * @@helper_private: mid-layer private data
 *
 * CRTCs drive pixels to encoders, which convert them into signals
 * appropriate for a given connector or set of connectors.
 */
struct drm_encoder {
	struct drm_device *dev;
	struct list_head head;

	struct drm_mode_object base;
	char *name;
	int encoder_type;
	uint32_t possible_crtcs;
	uint32_t possible_clones;

	struct drm_crtc *crtc;
	struct drm_bridge *bridge;
	const struct drm_encoder_funcs *funcs;
	const void *helper_private;
};

/* should we poll this connector for connects and disconnects */
/* hot plug detectable */
#define DRM_CONNECTOR_POLL_HPD (1 << 0)
/* poll for connections */
#define DRM_CONNECTOR_POLL_CONNECT (1 << 1)
/* can cleanly poll for disconnections without flickering the screen */
/* DACs should rarely do this without a lot of testing */
#define DRM_CONNECTOR_POLL_DISCONNECT (1 << 2)

#define MAX_ELD_BYTES	128

/**
 * struct drm_connector - central DRM connector control structure
 * @@dev: parent DRM device
 * @@kdev: kernel device for sysfs attributes
 * @@attr: sysfs attributes
 * @@head: list management
 * @@base: base KMS object
 * @@name: connector name
 * @@connector_type: one of the %DRM_MODE_CONNECTOR_<foo> types from drm_mode.h
 * @@connector_type_id: index into connector type enum
 * @@interlace_allowed: can this connector handle interlaced modes?
 * @@doublescan_allowed: can this connector handle doublescan?
 * @@stereo_allowed: can this connector handle stereo modes?
 * @@modes: modes available on this connector (from fill_modes() + user)
 * @@status: one of the drm_connector_status enums (connected, not, or unknown)
 * @@probed_modes: list of modes derived directly from the display
 * @@display_info: information about attached display (e.g. from EDID)
 * @@funcs: connector control functions
 * @@edid_blob_ptr: DRM property containing EDID if present
 * @@properties: property tracking for this connector
 * @@path_blob_ptr: DRM blob property data for the DP MST path property
 * @@polled: a %DRM_CONNECTOR_POLL_<foo> value for core driven polling
 * @@dpms: current dpms state
 * @@helper_private: mid-layer private data
 * @@cmdline_mode: mode line parsed from the kernel cmdline for this connector
 * @@force: a %DRM_FORCE_<foo> state for forced mode sets
 * @@override_edid: has the EDID been overwritten through debugfs for testing?
 * @@encoder_ids: valid encoders for this connector
 * @@encoder: encoder driving this connector, if any
 * @@eld: EDID-like data, if present
 * @@dvi_dual: dual link DVI, if found
 * @@max_tmds_clock: max clock rate, if found
 * @@latency_present: AV delay info from ELD, if found
 * @@video_latency: video latency info from ELD, if found
 * @@audio_latency: audio latency info from ELD, if found
 * @@null_edid_counter: track sinks that give us all zeros for the EDID
 * @@bad_edid_counter: track sinks that give us an EDID with invalid checksum
 * @@edid_corrupt: indicates whether the last read EDID was corrupt
 * @@debugfs_entry: debugfs directory for this connector
 * @@state: current atomic state for this connector
 * @@has_tile: is this connector connected to a tiled monitor
 * @@tile_group: tile group for the connected monitor
 * @@tile_is_single_monitor: whether the tile is one monitor housing
 * @@num_h_tile: number of horizontal tiles in the tile group
 * @@num_v_tile: number of vertical tiles in the tile group
 * @@tile_h_loc: horizontal location of this tile
 * @@tile_v_loc: vertical location of this tile
 * @@tile_h_size: horizontal size of this tile.
 * @@tile_v_size: vertical size of this tile.
 *
 * Each connector may be connected to one or more CRTCs, or may be clonable by
 * another connector if they can share a CRTC.  Each connector also has a specific
 * position in the broader display (referred to as a 'screen' though it could
 * span multiple monitors).
 */
struct drm_connector {
	struct drm_device *dev;
	struct device *kdev;
	struct device_attribute *attr;
	struct list_head head;

	struct drm_mode_object base;

	char *name;
	int connector_type;
	int connector_type_id;
	bool interlace_allowed;
	bool doublescan_allowed;
	bool stereo_allowed;
	struct list_head modes; /* list of modes on this connector */

	enum drm_connector_status status;

	/* these are modes added by probing with DDC or the BIOS */
	struct list_head probed_modes;

	struct drm_display_info display_info;
	const struct drm_connector_funcs *funcs;

	struct drm_property_blob *edid_blob_ptr;
	struct drm_object_properties properties;

	struct drm_property_blob *path_blob_ptr;

	struct drm_property_blob *tile_blob_ptr;

	uint8_t polled; /* DRM_CONNECTOR_POLL_* */

	/* requested DPMS state */
	int dpms;

	const void *helper_private;

	/* forced on connector */
	struct drm_cmdline_mode cmdline_mode;
	enum drm_connector_force force;
	bool override_edid;
	uint32_t encoder_ids[DRM_CONNECTOR_MAX_ENCODER];
	struct drm_encoder *encoder; /* currently active encoder */

	/* EDID bits */
	uint8_t eld[MAX_ELD_BYTES];
	bool dvi_dual;
	int max_tmds_clock;	/* in MHz */
	bool latency_present[2];
	int video_latency[2];	/* [0]: progressive, [1]: interlaced */
	int audio_latency[2];
	int null_edid_counter; /* needed to workaround some HW bugs where we get all 0s */
	unsigned bad_edid_counter;

	/* Flag for raw EDID header corruption - used in Displayport
	 * compliance testing - * Displayport Link CTS Core 1.2 rev1.1 4.2.2.6
	 */
	bool edid_corrupt;

	struct dentry *debugfs_entry;

	struct drm_connector_state *state;

	/* DisplayID bits */
	bool has_tile;
	struct drm_tile_group *tile_group;
	bool tile_is_single_monitor;

	uint8_t num_h_tile, num_v_tile;
	uint8_t tile_h_loc, tile_v_loc;
	uint16_t tile_h_size, tile_v_size;
};

/**
 * struct drm_plane_state - mutable plane state
 * @@plane: backpointer to the plane
 * @@crtc: currently bound CRTC, NULL if disabled
 * @@fb: currently bound framebuffer
 * @@fence: optional fence to wait for before scanning out @@fb
 * @@crtc_x: left position of visible portion of plane on crtc
 * @@crtc_y: upper position of visible portion of plane on crtc
 * @@crtc_w: width of visible portion of plane on crtc
 * @@crtc_h: height of visible portion of plane on crtc
 * @@src_x: left position of visible portion of plane within
 *	plane (in 16.16)
 * @@src_y: upper position of visible portion of plane within
 *	plane (in 16.16)
 * @@src_w: width of visible portion of plane (in 16.16)
 * @@src_h: height of visible portion of plane (in 16.16)
 * @@state: backpointer to global drm_atomic_state
 */
struct drm_plane_state {
	struct drm_plane *plane;

	struct drm_crtc *crtc;   /* do not write directly, use drm_atomic_set_crtc_for_plane() */
	struct drm_framebuffer *fb;  /* do not write directly, use drm_atomic_set_fb_for_plane() */
	struct fence *fence;

	/* Signed dest location allows it to be partially off screen */
	int32_t crtc_x, crtc_y;
	uint32_t crtc_w, crtc_h;

	/* Source values are 16.16 fixed point */
	uint32_t src_x, src_y;
	uint32_t src_h, src_w;

	/* Plane rotation */
	unsigned int rotation;

	struct drm_atomic_state *state;
};


/**
 * struct drm_plane_funcs - driver plane control functions
 * @@update_plane: update the plane configuration
 * @@disable_plane: shut down the plane
 * @@destroy: clean up plane resources
 * @@reset: reset plane after state has been invalidated (e.g. resume)
 * @@set_property: called when a property is changed
 * @@atomic_duplicate_state: duplicate the atomic state for this plane
 * @@atomic_destroy_state: destroy an atomic state for this plane
 * @@atomic_set_property: set a property on an atomic state for this plane
 *    (do not call directly, use drm_atomic_plane_set_property())
 * @@atomic_get_property: get a property on an atomic state for this plane
 *    (do not call directly, use drm_atomic_plane_get_property())
 */
struct drm_plane_funcs {
	int (*update_plane)(struct drm_plane *plane,
			    struct drm_crtc *crtc, struct drm_framebuffer *fb,
			    int crtc_x, int crtc_y,
			    unsigned int crtc_w, unsigned int crtc_h,
			    uint32_t src_x, uint32_t src_y,
			    uint32_t src_w, uint32_t src_h);
	int (*disable_plane)(struct drm_plane *plane);
	void (*destroy)(struct drm_plane *plane);
	void (*reset)(struct drm_plane *plane);

	int (*set_property)(struct drm_plane *plane,
			    struct drm_property *property, uint64_t val);

	/* atomic update handling */
	struct drm_plane_state *(*atomic_duplicate_state)(struct drm_plane *plane);
	void (*atomic_destroy_state)(struct drm_plane *plane,
				     struct drm_plane_state *state);
	int (*atomic_set_property)(struct drm_plane *plane,
				   struct drm_plane_state *state,
				   struct drm_property *property,
				   uint64_t val);
	int (*atomic_get_property)(struct drm_plane *plane,
				   const struct drm_plane_state *state,
				   struct drm_property *property,
				   uint64_t *val);
};

enum drm_plane_type {
	DRM_PLANE_TYPE_OVERLAY,
	DRM_PLANE_TYPE_PRIMARY,
	DRM_PLANE_TYPE_CURSOR,
};

/**
 * struct drm_plane - central DRM plane control structure
 * @@dev: DRM device this plane belongs to
 * @@head: for list management
 * @@base: base mode object
 * @@possible_crtcs: pipes this plane can be bound to
 * @@format_types: array of formats supported by this plane
 * @@format_count: number of formats supported
 * @@format_default: driver hasn't supplied supported formats for the plane
 * @@crtc: currently bound CRTC
 * @@fb: currently bound fb
 * @@old_fb: Temporary tracking of the old fb while a modeset is ongoing. Used by
 * 	drm_mode_set_config_internal() to implement correct refcounting.
 * @@funcs: helper functions
 * @@properties: property tracking for this plane
 * @@type: type of plane (overlay, primary, cursor)
 * @@state: current atomic state for this plane
 */
struct drm_plane {
	struct drm_device *dev;
	struct list_head head;

	struct drm_modeset_lock mutex;

	struct drm_mode_object base;

	uint32_t possible_crtcs;
	uint32_t *format_types;
	unsigned int format_count;
	bool format_default;

	struct drm_crtc *crtc;
	struct drm_framebuffer *fb;

	struct drm_framebuffer *old_fb;

	const struct drm_plane_funcs *funcs;

	struct drm_object_properties properties;

	enum drm_plane_type type;

	const void *helper_private;

	struct drm_plane_state *state;
};

/**
 * struct drm_bridge_funcs - drm_bridge control functions
 * @@attach: Called during drm_bridge_attach
 * @@mode_fixup: Try to fixup (or reject entirely) proposed mode for this bridge
 * @@disable: Called right before encoder prepare, disables the bridge
 * @@post_disable: Called right after encoder prepare, for lockstepped disable
 * @@mode_set: Set this mode to the bridge
 * @@pre_enable: Called right before encoder commit, for lockstepped commit
 * @@enable: Called right after encoder commit, enables the bridge
 */
struct drm_bridge_funcs {
	int (*attach)(struct drm_bridge *bridge);
	bool (*mode_fixup)(struct drm_bridge *bridge,
			   const struct drm_display_mode *mode,
			   struct drm_display_mode *adjusted_mode);
	void (*disable)(struct drm_bridge *bridge);
	void (*post_disable)(struct drm_bridge *bridge);
	void (*mode_set)(struct drm_bridge *bridge,
			 struct drm_display_mode *mode,
			 struct drm_display_mode *adjusted_mode);
	void (*pre_enable)(struct drm_bridge *bridge);
	void (*enable)(struct drm_bridge *bridge);
};

/**
 * struct drm_bridge - central DRM bridge control structure
 * @@dev: DRM device this bridge belongs to
 * @@encoder: encoder to which this bridge is connected
 * @@next: the next bridge in the encoder chain
 * @@of_node: device node pointer to the bridge
 * @@list: to keep track of all added bridges
 * @@funcs: control functions
 * @@driver_private: pointer to the bridge driver's internal context
 */
struct drm_bridge {
	struct drm_device *dev;
	struct drm_encoder *encoder;
	struct drm_bridge *next;
#ifdef CONFIG_OF
	struct device_node *of_node;
#endif
	struct list_head list;

	const struct drm_bridge_funcs *funcs;
	void *driver_private;
};

/**
 * struct drm_atomic_state - the global state object for atomic updates
 * @@dev: parent DRM device
 * @@allow_modeset: allow full modeset
 * @@legacy_cursor_update: hint to enforce legacy cursor ioctl semantics
 * @@planes: pointer to array of plane pointers
 * @@plane_states: pointer to array of plane states pointers
 * @@crtcs: pointer to array of CRTC pointers
 * @@crtc_states: pointer to array of CRTC states pointers
 * @@num_connector: size of the @@connectors and @@connector_states arrays
 * @@connectors: pointer to array of connector pointers
 * @@connector_states: pointer to array of connector states pointers
 * @@acquire_ctx: acquire context for this atomic modeset state update
 */
struct drm_atomic_state {
	struct drm_device *dev;
	bool allow_modeset : 1;
	bool legacy_cursor_update : 1;
	struct drm_plane **planes;
	struct drm_plane_state **plane_states;
	struct drm_crtc **crtcs;
	struct drm_crtc_state **crtc_states;
	int num_connector;
	struct drm_connector **connectors;
	struct drm_connector_state **connector_states;

	struct drm_modeset_acquire_ctx *acquire_ctx;
};


/**
 * struct drm_mode_set - new values for a CRTC config change
 * @@fb: framebuffer to use for new config
 * @@crtc: CRTC whose configuration we're about to change
 * @@mode: mode timings to use
 * @@x: position of this CRTC relative to @@fb
 * @@y: position of this CRTC relative to @@fb
 * @@connectors: array of connectors to drive with this CRTC if possible
 * @@num_connectors: size of @@connectors array
 *
 * Represents a single crtc the connectors that it drives with what mode
 * and from which framebuffer it scans out from.
 *
 * This is used to set modes.
 */
struct drm_mode_set {
	struct drm_framebuffer *fb;
	struct drm_crtc *crtc;
	struct drm_display_mode *mode;

	uint32_t x;
	uint32_t y;

	struct drm_connector **connectors;
	size_t num_connectors;
};

/**
 * struct drm_mode_config_funcs - basic driver provided mode setting functions
 * @@fb_create: create a new framebuffer object
 * @@output_poll_changed: function to handle output configuration changes
 * @@atomic_check: check whether a given atomic state update is possible
 * @@atomic_commit: commit an atomic state update previously verified with
 * 	atomic_check()
 * @@atomic_state_alloc: allocate a new atomic state
 * @@atomic_state_clear: clear the atomic state
 * @@atomic_state_free: free the atomic state
 *
 * Some global (i.e. not per-CRTC, connector, etc) mode setting functions that
 * involve drivers.
 */
struct drm_mode_config_funcs {
	struct drm_framebuffer *(*fb_create)(struct drm_device *dev,
					     struct drm_file *file_priv,
					     struct drm_mode_fb_cmd2 *mode_cmd);
	void (*output_poll_changed)(struct drm_device *dev);

	int (*atomic_check)(struct drm_device *dev,
			    struct drm_atomic_state *a);
	int (*atomic_commit)(struct drm_device *dev,
			     struct drm_atomic_state *a,
			     bool async);
	struct drm_atomic_state *(*atomic_state_alloc)(struct drm_device *dev);
	void (*atomic_state_clear)(struct drm_atomic_state *state);
	void (*atomic_state_free)(struct drm_atomic_state *state);
};

/**
 * struct drm_mode_config - Mode configuration control structure
 * @@mutex: mutex protecting KMS related lists and structures
 * @@connection_mutex: ww mutex protecting connector state and routing
 * @@acquire_ctx: global implicit acquire context used by atomic drivers for
 * 	legacy ioctls
 * @@idr_mutex: mutex for KMS ID allocation and management
 * @@crtc_idr: main KMS ID tracking object
 * @@fb_lock: mutex to protect fb state and lists
 * @@num_fb: number of fbs available
 * @@fb_list: list of framebuffers available
 * @@num_connector: number of connectors on this device
 * @@connector_list: list of connector objects
 * @@num_encoder: number of encoders on this device
 * @@encoder_list: list of encoder objects
 * @@num_overlay_plane: number of overlay planes on this device
 * @@num_total_plane: number of universal (i.e. with primary/curso) planes on this device
 * @@plane_list: list of plane objects
 * @@num_crtc: number of CRTCs on this device
 * @@crtc_list: list of CRTC objects
 * @@property_list: list of property objects
 * @@min_width: minimum pixel width on this device
 * @@min_height: minimum pixel height on this device
 * @@max_width: maximum pixel width on this device
 * @@max_height: maximum pixel height on this device
 * @@funcs: core driver provided mode setting functions
 * @@fb_base: base address of the framebuffer
 * @@poll_enabled: track polling support for this device
 * @@poll_running: track polling status for this device
 * @@output_poll_work: delayed work for polling in process context
 * @@property_blob_list: list of all the blob property objects
 * @@blob_lock: mutex for blob property allocation and management
 * @@*_property: core property tracking
 * @@preferred_depth: preferred RBG pixel depth, used by fb helpers
 * @@prefer_shadow: hint to userspace to prefer shadow-fb rendering
 * @@async_page_flip: does this device support async flips on the primary plane?
 * @@cursor_width: hint to userspace for max cursor width
 * @@cursor_height: hint to userspace for max cursor height
 *
 * Core mode resource tracking structure.  All CRTC, encoders, and connectors
 * enumerated by the driver are added here, as are global properties.  Some
 * global restrictions are also here, e.g. dimension restrictions.
 */
struct drm_mode_config {
	struct rwlock mutex; /* protects configuration (mode lists etc.) */
	struct drm_modeset_lock connection_mutex; /* protects connector->encoder and encoder->crtc links */
	struct drm_modeset_acquire_ctx *acquire_ctx; /* for legacy _lock_all() / _unlock_all() */
	struct rwlock idr_mutex; /* for IDR management */
	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
	struct idr tile_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
	/* this is limited to one for now */

	struct rwlock fb_lock; /* proctects global and per-file fb lists */
	int num_fb;
	struct list_head fb_list;

	int num_connector;
	struct list_head connector_list;
	int num_encoder;
	struct list_head encoder_list;

	/*
	 * Track # of overlay planes separately from # of total planes.  By
	 * default we only advertise overlay planes to userspace; if userspace
	 * sets the "universal plane" capability bit, we'll go ahead and
	 * expose all planes.
	 */
	int num_overlay_plane;
	int num_total_plane;
	struct list_head plane_list;

	int num_crtc;
	struct list_head crtc_list;

	struct list_head property_list;

	int min_width, min_height;
	int max_width, max_height;
	const struct drm_mode_config_funcs *funcs;
	resource_size_t fb_base;

	/* output poll support */
	bool poll_enabled;
	bool poll_running;
	bool delayed_event;
	struct delayed_work output_poll_work;

	struct rwlock blob_lock;

	/* pointers to standard properties */
	struct list_head property_blob_list;
	struct drm_property *edid_property;
	struct drm_property *dpms_property;
	struct drm_property *path_property;
	struct drm_property *tile_property;
	struct drm_property *plane_type_property;
	struct drm_property *rotation_property;
	struct drm_property *prop_src_x;
	struct drm_property *prop_src_y;
	struct drm_property *prop_src_w;
	struct drm_property *prop_src_h;
	struct drm_property *prop_crtc_x;
	struct drm_property *prop_crtc_y;
	struct drm_property *prop_crtc_w;
	struct drm_property *prop_crtc_h;
	struct drm_property *prop_fb_id;
	struct drm_property *prop_crtc_id;
	struct drm_property *prop_active;
	struct drm_property *prop_mode_id;

	/* DVI-I properties */
	struct drm_property *dvi_i_subconnector_property;
	struct drm_property *dvi_i_select_subconnector_property;

	/* TV properties */
	struct drm_property *tv_subconnector_property;
	struct drm_property *tv_select_subconnector_property;
	struct drm_property *tv_mode_property;
	struct drm_property *tv_left_margin_property;
	struct drm_property *tv_right_margin_property;
	struct drm_property *tv_top_margin_property;
	struct drm_property *tv_bottom_margin_property;
	struct drm_property *tv_brightness_property;
	struct drm_property *tv_contrast_property;
	struct drm_property *tv_flicker_reduction_property;
	struct drm_property *tv_overscan_property;
	struct drm_property *tv_saturation_property;
	struct drm_property *tv_hue_property;

	/* Optional properties */
	struct drm_property *scaling_mode_property;
	struct drm_property *aspect_ratio_property;
	struct drm_property *dirty_info_property;

	/* properties for virtual machine layout */
	struct drm_property *suggested_x_property;
	struct drm_property *suggested_y_property;

	/* dumb ioctl parameters */
	uint32_t preferred_depth, prefer_shadow;

	/* whether async page flip is supported or not */
	bool async_page_flip;

	/* whether the driver supports fb modifiers */
	bool allow_fb_modifiers;

	/* cursor size */
	uint32_t cursor_width, cursor_height;
};

/**
 * drm_for_each_plane_mask - iterate over planes specified by bitmask
 * @@plane: the loop cursor
 * @@dev: the DRM device
 * @@plane_mask: bitmask of plane indices
 *
 * Iterate over all planes specified by bitmask.
 */
#define drm_for_each_plane_mask(plane, dev, plane_mask) \
	list_for_each_entry((plane), &(dev)->mode_config.plane_list, head) \
		if ((plane_mask) & (1 << drm_plane_index(plane)))


#define obj_to_crtc(x) container_of(x, struct drm_crtc, base)
#define obj_to_connector(x) container_of(x, struct drm_connector, base)
#define obj_to_encoder(x) container_of(x, struct drm_encoder, base)
#define obj_to_mode(x) container_of(x, struct drm_display_mode, base)
#define obj_to_fb(x) container_of(x, struct drm_framebuffer, base)
#define obj_to_property(x) container_of(x, struct drm_property, base)
#define obj_to_blob(x) container_of(x, struct drm_property_blob, base)
#define obj_to_plane(x) container_of(x, struct drm_plane, base)

struct drm_prop_enum_list {
	int type;
	char *name;
};

extern int drm_crtc_init_with_planes(struct drm_device *dev,
				     struct drm_crtc *crtc,
				     struct drm_plane *primary,
				     struct drm_plane *cursor,
				     const struct drm_crtc_funcs *funcs);
extern void drm_crtc_cleanup(struct drm_crtc *crtc);
extern unsigned int drm_crtc_index(struct drm_crtc *crtc);

/**
 * drm_crtc_mask - find the mask of a registered CRTC
 * @@crtc: CRTC to find mask for
 *
 * Given a registered CRTC, return the mask bit of that CRTC for an
 * encoder's possible_crtcs field.
 */
static inline uint32_t drm_crtc_mask(struct drm_crtc *crtc)
{
	return 1 << drm_crtc_index(crtc);
}

extern void drm_connector_ida_init(void);
extern void drm_connector_ida_destroy(void);
extern int drm_connector_init(struct drm_device *dev,
			      struct drm_connector *connector,
			      const struct drm_connector_funcs *funcs,
			      int connector_type);
int drm_connector_register(struct drm_connector *connector);
void drm_connector_unregister(struct drm_connector *connector);

extern void drm_connector_cleanup(struct drm_connector *connector);
extern unsigned int drm_connector_index(struct drm_connector *connector);
/* helper to unplug all connectors from sysfs for device */
extern void drm_connector_unplug_all(struct drm_device *dev);

extern int drm_bridge_add(struct drm_bridge *bridge);
extern void drm_bridge_remove(struct drm_bridge *bridge);
extern struct drm_bridge *of_drm_find_bridge(struct device_node *np);
extern int drm_bridge_attach(struct drm_device *dev, struct drm_bridge *bridge);

bool drm_bridge_mode_fixup(struct drm_bridge *bridge,
			const struct drm_display_mode *mode,
			struct drm_display_mode *adjusted_mode);
void drm_bridge_disable(struct drm_bridge *bridge);
void drm_bridge_post_disable(struct drm_bridge *bridge);
void drm_bridge_mode_set(struct drm_bridge *bridge,
			struct drm_display_mode *mode,
			struct drm_display_mode *adjusted_mode);
void drm_bridge_pre_enable(struct drm_bridge *bridge);
void drm_bridge_enable(struct drm_bridge *bridge);

extern int drm_encoder_init(struct drm_device *dev,
			    struct drm_encoder *encoder,
			    const struct drm_encoder_funcs *funcs,
			    int encoder_type);

/**
 * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
 * @@encoder: encoder to test
 * @@crtc: crtc to test
 *
 * Return false if @@encoder can't be driven by @@crtc, true otherwise.
 */
static inline bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
				       struct drm_crtc *crtc)
{
	return !!(encoder->possible_crtcs & drm_crtc_mask(crtc));
}

extern int drm_universal_plane_init(struct drm_device *dev,
				    struct drm_plane *plane,
				    unsigned long possible_crtcs,
				    const struct drm_plane_funcs *funcs,
				    const uint32_t *formats,
				    unsigned int format_count,
				    enum drm_plane_type type);
extern int drm_plane_init(struct drm_device *dev,
			  struct drm_plane *plane,
			  unsigned long possible_crtcs,
			  const struct drm_plane_funcs *funcs,
			  const uint32_t *formats, unsigned int format_count,
			  bool is_primary);
extern void drm_plane_cleanup(struct drm_plane *plane);
extern unsigned int drm_plane_index(struct drm_plane *plane);
extern struct drm_plane * drm_plane_from_index(struct drm_device *dev, int idx);
extern void drm_plane_force_disable(struct drm_plane *plane);
extern int drm_plane_check_pixel_format(const struct drm_plane *plane,
					u32 format);
extern void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
				   int *hdisplay, int *vdisplay);
extern int drm_crtc_check_viewport(const struct drm_crtc *crtc,
				   int x, int y,
				   const struct drm_display_mode *mode,
				   const struct drm_framebuffer *fb);

extern void drm_encoder_cleanup(struct drm_encoder *encoder);

extern const char *drm_get_connector_status_name(enum drm_connector_status status);
extern const char *drm_get_subpixel_order_name(enum subpixel_order order);
extern const char *drm_get_dpms_name(int val);
extern const char *drm_get_dvi_i_subconnector_name(int val);
extern const char *drm_get_dvi_i_select_name(int val);
extern const char *drm_get_tv_subconnector_name(int val);
extern const char *drm_get_tv_select_name(int val);
extern void drm_fb_release(struct drm_file *file_priv);
extern void drm_property_destroy_user_blobs(struct drm_device *dev,
                                            struct drm_file *file_priv);
extern bool drm_probe_ddc(struct i2c_adapter *adapter);
extern struct edid *drm_get_edid(struct drm_connector *connector,
				 struct i2c_adapter *adapter);
extern struct edid *drm_edid_duplicate(const struct edid *edid);
extern int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid);
extern void drm_mode_config_init(struct drm_device *dev);
extern void drm_mode_config_reset(struct drm_device *dev);
extern void drm_mode_config_cleanup(struct drm_device *dev);

extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
						const char *path);
int drm_mode_connector_set_tile_property(struct drm_connector *connector);
extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
						   const struct edid *edid);

extern int drm_display_info_set_bus_formats(struct drm_display_info *info,
					    const u32 *formats,
					    unsigned int num_formats);

static inline bool drm_property_type_is(struct drm_property *property,
		uint32_t type)
{
	/* instanceof for props.. handles extended type vs original types: */
	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
		return (property->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
	return property->flags & type;
}

static inline bool drm_property_type_valid(struct drm_property *property)
{
	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
		return !(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
	return !!(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
}

extern int drm_object_property_set_value(struct drm_mode_object *obj,
					 struct drm_property *property,
					 uint64_t val);
extern int drm_object_property_get_value(struct drm_mode_object *obj,
					 struct drm_property *property,
					 uint64_t *value);
extern int drm_framebuffer_init(struct drm_device *dev,
				struct drm_framebuffer *fb,
				const struct drm_framebuffer_funcs *funcs);
extern struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
						      uint32_t id);
extern void drm_framebuffer_unreference(struct drm_framebuffer *fb);
extern void drm_framebuffer_reference(struct drm_framebuffer *fb);
extern void drm_framebuffer_remove(struct drm_framebuffer *fb);
extern void drm_framebuffer_cleanup(struct drm_framebuffer *fb);
extern void drm_framebuffer_unregister_private(struct drm_framebuffer *fb);

extern void drm_object_attach_property(struct drm_mode_object *obj,
				       struct drm_property *property,
				       uint64_t init_val);
extern struct drm_property *drm_property_create(struct drm_device *dev, int flags,
						const char *name, int num_values);
extern struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
					 const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_values);
struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
					 int flags, const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_props,
					 uint64_t supported_bits);
struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
					 const char *name,
					 uint64_t min, uint64_t max);
struct drm_property *drm_property_create_signed_range(struct drm_device *dev,
					 int flags, const char *name,
					 int64_t min, int64_t max);
struct drm_property *drm_property_create_object(struct drm_device *dev,
					 int flags, const char *name, uint32_t type);
struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
					 const char *name);
struct drm_property_blob *drm_property_create_blob(struct drm_device *dev,
                                                   size_t length,
                                                   const void *data);
struct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,
                                                   uint32_t id);
struct drm_property_blob *drm_property_reference_blob(struct drm_property_blob *blob);
void drm_property_unreference_blob(struct drm_property_blob *blob);
extern void drm_property_destroy(struct drm_device *dev, struct drm_property *property);
extern int drm_property_add_enum(struct drm_property *property, int index,
				 uint64_t value, const char *name);
extern int drm_mode_create_dvi_i_properties(struct drm_device *dev);
extern int drm_mode_create_tv_properties(struct drm_device *dev,
					 unsigned int num_modes,
					 const char * const modes[]);
extern int drm_mode_create_scaling_mode_property(struct drm_device *dev);
extern int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
extern int drm_mode_create_dirty_info_property(struct drm_device *dev);
extern int drm_mode_create_suggested_offset_properties(struct drm_device *dev);
extern bool drm_property_change_valid_get(struct drm_property *property,
					 uint64_t value, struct drm_mode_object **ref);
extern void drm_property_change_valid_put(struct drm_property *property,
		struct drm_mode_object *ref);

extern int drm_mode_connector_attach_encoder(struct drm_connector *connector,
					     struct drm_encoder *encoder);
extern int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
					 int gamma_size);
extern struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
		uint32_t id, uint32_t type);

/* IOCTLs */
extern int drm_mode_getresources(struct drm_device *dev,
				 void *data, struct drm_file *file_priv);
extern int drm_mode_getplane_res(struct drm_device *dev, void *data,
				   struct drm_file *file_priv);
extern int drm_mode_getcrtc(struct drm_device *dev,
			    void *data, struct drm_file *file_priv);
extern int drm_mode_getconnector(struct drm_device *dev,
			      void *data, struct drm_file *file_priv);
extern int drm_mode_set_config_internal(struct drm_mode_set *set);
extern int drm_mode_setcrtc(struct drm_device *dev,
			    void *data, struct drm_file *file_priv);
extern int drm_mode_getplane(struct drm_device *dev,
			       void *data, struct drm_file *file_priv);
extern int drm_mode_setplane(struct drm_device *dev,
			       void *data, struct drm_file *file_priv);
extern int drm_mode_cursor_ioctl(struct drm_device *dev,
				void *data, struct drm_file *file_priv);
extern int drm_mode_cursor2_ioctl(struct drm_device *dev,
				void *data, struct drm_file *file_priv);
extern int drm_mode_addfb(struct drm_device *dev,
			  void *data, struct drm_file *file_priv);
extern int drm_mode_addfb2(struct drm_device *dev,
			   void *data, struct drm_file *file_priv);
extern uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth);
extern int drm_mode_rmfb(struct drm_device *dev,
			 void *data, struct drm_file *file_priv);
extern int drm_mode_getfb(struct drm_device *dev,
			  void *data, struct drm_file *file_priv);
extern int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
				  void *data, struct drm_file *file_priv);

extern int drm_mode_getproperty_ioctl(struct drm_device *dev,
				      void *data, struct drm_file *file_priv);
extern int drm_mode_getblob_ioctl(struct drm_device *dev,
				  void *data, struct drm_file *file_priv);
extern int drm_mode_createblob_ioctl(struct drm_device *dev,
				     void *data, struct drm_file *file_priv);
extern int drm_mode_destroyblob_ioctl(struct drm_device *dev,
				      void *data, struct drm_file *file_priv);
extern int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
					      void *data, struct drm_file *file_priv);
extern int drm_mode_getencoder(struct drm_device *dev,
			       void *data, struct drm_file *file_priv);
extern int drm_mode_gamma_get_ioctl(struct drm_device *dev,
				    void *data, struct drm_file *file_priv);
extern int drm_mode_gamma_set_ioctl(struct drm_device *dev,
				    void *data, struct drm_file *file_priv);
extern u8 drm_match_cea_mode(const struct drm_display_mode *to_match);
extern enum hdmi_picture_aspect drm_get_cea_aspect_ratio(const u8 video_code);
extern bool drm_detect_hdmi_monitor(struct edid *edid);
extern bool drm_detect_monitor_audio(struct edid *edid);
extern bool drm_rgb_quant_range_selectable(struct edid *edid);
extern int drm_mode_page_flip_ioctl(struct drm_device *dev,
				    void *data, struct drm_file *file_priv);
extern int drm_add_modes_noedid(struct drm_connector *connector,
				int hdisplay, int vdisplay);
extern void drm_set_preferred_mode(struct drm_connector *connector,
				   int hpref, int vpref);

extern int drm_edid_header_is_valid(const u8 *raw_edid);
extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid,
				 bool *edid_corrupt);
extern bool drm_edid_is_valid(struct edid *edid);

extern struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
							 char topology[8]);
extern struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
					       char topology[8]);
extern void drm_mode_put_tile_group(struct drm_device *dev,
				   struct drm_tile_group *tg);
struct drm_display_mode *drm_mode_find_dmt(struct drm_device *dev,
					   int hsize, int vsize, int fresh,
					   bool rb);

extern int drm_mode_create_dumb_ioctl(struct drm_device *dev,
				      void *data, struct drm_file *file_priv);
extern int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
				    void *data, struct drm_file *file_priv);
extern int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
				      void *data, struct drm_file *file_priv);
extern int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
					     struct drm_file *file_priv);
extern int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
					   struct drm_file *file_priv);
extern int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
				       struct drm_property *property,
				       uint64_t value);
extern int drm_mode_atomic_ioctl(struct drm_device *dev,
				 void *data, struct drm_file *file_priv);

extern void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
				 int *bpp);
extern int drm_format_num_planes(uint32_t format);
extern int drm_format_plane_cpp(uint32_t format, int plane);
extern int drm_format_horz_chroma_subsampling(uint32_t format);
extern int drm_format_vert_chroma_subsampling(uint32_t format);
extern const char *drm_get_format_name(uint32_t format);
extern struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
							      unsigned int supported_rotations);
extern unsigned int drm_rotation_simplify(unsigned int rotation,
					  unsigned int supported_rotations);

/* Helpers */

static inline struct drm_plane *drm_plane_find(struct drm_device *dev,
		uint32_t id)
{
	struct drm_mode_object *mo;
	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PLANE);
	return mo ? obj_to_plane(mo) : NULL;
}

static inline struct drm_crtc *drm_crtc_find(struct drm_device *dev,
	uint32_t id)
{
	struct drm_mode_object *mo;
	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CRTC);
	return mo ? obj_to_crtc(mo) : NULL;
}

static inline struct drm_encoder *drm_encoder_find(struct drm_device *dev,
	uint32_t id)
{
	struct drm_mode_object *mo;
	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_ENCODER);
	return mo ? obj_to_encoder(mo) : NULL;
}

static inline struct drm_connector *drm_connector_find(struct drm_device *dev,
		uint32_t id)
{
	struct drm_mode_object *mo;
	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_CONNECTOR);
	return mo ? obj_to_connector(mo) : NULL;
}

static inline struct drm_property *drm_property_find(struct drm_device *dev,
		uint32_t id)
{
	struct drm_mode_object *mo;
	mo = drm_mode_object_find(dev, id, DRM_MODE_OBJECT_PROPERTY);
	return mo ? obj_to_property(mo) : NULL;
}

/* Plane list iterator for legacy (overlay only) planes. */
#define drm_for_each_legacy_plane(plane, dev) \
	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head) \
		if (plane->type == DRM_PLANE_TYPE_OVERLAY)

#define drm_for_each_plane(plane, dev) \
	list_for_each_entry(plane, &(dev)->mode_config.plane_list, head)

#define drm_for_each_crtc(crtc, dev) \
	list_for_each_entry(crtc, &(dev)->mode_config.crtc_list, head)

static inline void
assert_drm_connector_list_read_locked(struct drm_mode_config *mode_config)
{
	/*
	 * The connector hotadd/remove code currently grabs both locks when
	 * updating lists. Hence readers need only hold either of them to be
	 * safe and the check amounts to
	 *
	 * WARN_ON(not_holding(A) && not_holding(B)).
	 */
	WARN_ON(!mutex_is_locked(&mode_config->mutex) &&
		!drm_modeset_is_locked(&mode_config->connection_mutex));
}

#define drm_for_each_connector(connector, dev) \
	for (assert_drm_connector_list_read_locked(&(dev)->mode_config),	\
	     connector = list_first_entry(&(dev)->mode_config.connector_list,	\
					  struct drm_connector, head);		\
	     &connector->head != (&(dev)->mode_config.connector_list);		\
	     connector = list_next_entry(connector, head))

#define drm_for_each_encoder(encoder, dev) \
	list_for_each_entry(encoder, &(dev)->mode_config.encoder_list, head)

#define drm_for_each_fb(fb, dev) \
	for (WARN_ON(!mutex_is_locked(&(dev)->mode_config.fb_lock)),		\
	     fb = list_first_entry(&(dev)->mode_config.fb_list,	\
					  struct drm_framebuffer, head);	\
	     &fb->head != (&(dev)->mode_config.fb_list);			\
	     fb = list_next_entry(fb, head))

#endif /* __DRM_CRTC_H__ */
@


1.9
log
@Retry the drm_crtc.c "idr"conversion.  Turns out the xf86-video-intel driver
is buggy and trucates the ids to 8 bits.  So specifymaximum in the idr_alloc()
call until that gets fixed.
@
text
@a0 1
/*	$OpenBSD: drm_crtc.h,v 1.8 2016/04/06 21:12:40 kettenis Exp $	*/
d28 17
a44 7
#include <sys/types.h>
#include <dev/i2c/i2cvar.h>
#include <sys/task.h>
#include "linux_hdmi.h"
#include "drm_mode.h"

#include "drm_fourcc.h"
d52 2
d63 1
a63 1
#define DRM_MODE_OBJECT_BRIDGE 0xbdbdbdbd
d73 10
a82 2
	int count;
	uint32_t ids[DRM_OBJECT_MAX_PROPERTY];
d86 8
a93 60
/*
 * Note on terminology:  here, for brevity and convenience, we refer to connector
 * control chips as 'CRTCs'.  They can control any type of connector, VGA, LVDS,
 * DVI, etc.  And 'screen' refers to the whole of the visible display, which
 * may span multiple monitors (and therefore multiple CRTC and connector
 * structures).
 */

enum drm_mode_status {
    MODE_OK	= 0,	/* Mode OK */
    MODE_HSYNC,		/* hsync out of range */
    MODE_VSYNC,		/* vsync out of range */
    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
    MODE_NOMODE,	/* no mode with a matching name */
    MODE_NO_INTERLACE,	/* interlaced mode not supported */
    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
    MODE_NO_VSCAN,	/* multiscan mode not supported */
    MODE_MEM,		/* insufficient video memory */
    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
    MODE_NOCLOCK,	/* no fixed clock available */
    MODE_CLOCK_HIGH,	/* clock required is too high */
    MODE_CLOCK_LOW,	/* clock required is too low */
    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
    MODE_BAD_VVALUE,	/* vertical timing was out of range */
    MODE_BAD_VSCAN,	/* VScan value out of range */
    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
    MODE_VSYNC_WIDE,	/* vertical sync too wide */
    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
    MODE_PANEL,         /* exceeds panel dimensions */
    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
    MODE_ONE_WIDTH,     /* only one width is supported */
    MODE_ONE_HEIGHT,    /* only one height is supported */
    MODE_ONE_SIZE,      /* only one resolution is supported */
    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
    MODE_NO_STEREO,	/* stereo modes not supported */
    MODE_UNVERIFIED = -3, /* mode needs to reverified */
    MODE_BAD = -2,	/* unspecified reason */
    MODE_ERROR	= -1	/* error condition */
};

#define DRM_MODE_TYPE_CLOCK_CRTC_C (DRM_MODE_TYPE_CLOCK_C | \
				    DRM_MODE_TYPE_CRTC_C)

#define DRM_MODE(nm, t, c, hd, hss, hse, ht, hsk, vd, vss, vse, vt, vs, f) \
	.name = nm, .status = 0, .type = (t), .clock = (c), \
	.hdisplay = (hd), .hsync_start = (hss), .hsync_end = (hse), \
	.htotal = (ht), .hskew = (hsk), .vdisplay = (vd), \
	.vsync_start = (vss), .vsync_end = (vse), .vtotal = (vt), \
	.vscan = (vs), .flags = (f), \
	.base.type = DRM_MODE_OBJECT_MODE
d95 9
a103 2
#define CRTC_INTERLACE_HALVE_V	(1 << 0) /* halve V values for interlacing */
#define CRTC_STEREO_DOUBLE	(1 << 1) /* adjust timings for stereo modes */
d105 5
a109 57
#define DRM_MODE_FLAG_3D_MAX	DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF

struct drm_display_mode {
	/* Header */
	struct list_head head;
	struct drm_mode_object base;

	char name[DRM_DISPLAY_MODE_LEN];

	enum drm_mode_status status;
	unsigned int type;

	/* Proposed mode values */
	int clock;		/* in kHz */
	int hdisplay;
	int hsync_start;
	int hsync_end;
	int htotal;
	int hskew;
	int vdisplay;
	int vsync_start;
	int vsync_end;
	int vtotal;
	int vscan;
	unsigned int flags;

	/* Addressable image size (may be 0 for projectors, etc.) */
	int width_mm;
	int height_mm;

	/* Actual mode we give to hw */
	int crtc_clock;		/* in KHz */
	int crtc_hdisplay;
	int crtc_hblank_start;
	int crtc_hblank_end;
	int crtc_hsync_start;
	int crtc_hsync_end;
	int crtc_htotal;
	int crtc_hskew;
	int crtc_vdisplay;
	int crtc_vblank_start;
	int crtc_vblank_end;
	int crtc_vsync_start;
	int crtc_vsync_end;
	int crtc_vtotal;

	/* Driver private mode info */
	int private_size;
	int *private;
	int private_flags;

	int vrefresh;		/* in Hz */
	int hsync;		/* in kHz */
	enum hdmi_picture_aspect picture_aspect_ratio;

	/* Link for sorting */
	RB_ENTRY(drm_display_mode) sort;
d112 1
a112 4
static inline bool drm_mode_is_stereo(const struct drm_display_mode *mode)
{
	return mode->flags & DRM_MODE_FLAG_3D_MASK;
}
d151 6
d160 8
d174 2
a175 2
	/**
	 * Optinal callback for the dirty fb ioctl.
d213 1
a221 2
	/* if you are using the helper */
	void *helper_private;
d226 5
a230 2
	struct list_head head;
	unsigned int length;
d247 1
d249 1
a249 1
	struct list_head enum_blob_list;
d258 1
d261 60
a320 1
 * drm_crtc_funcs - control CRTCs for a given device
d325 1
d332 6
d388 13
d404 1
a404 1
 * drm_crtc - central CRTC control structure
d406 1
d408 1
d410 4
a416 3
 * @@invert_dimensions: for purposes of error checking crtc vs fb sizes,
 *    invert the width/height of the crtc.  This is used if the driver
 *    is performing 90 or 270 degree rotated scanout
a421 3
 * @@framedur_ns: precise frame timing
 * @@framedur_ns: precise line timing
 * @@pixeldur_ns: precise pixel timing
d424 3
d433 1
d436 1
a436 1
	/**
d443 1
a443 1
	struct rwlock mutex;
d447 7
a453 6
	/* framebuffer the connector is currently bound to */
	struct drm_framebuffer *fb;

	/* Temporary tracking of the old fb while a modeset is ongoing. Used
	 * by drm_mode_set_config_internal to implement correct refcounting. */
	struct drm_framebuffer *old_fb;
a464 2
	bool invert_dimensions;

a471 3
	/* Constants needed for precise vblank and swap timestamping. */
	int framedur_ns, linedur_ns, pixeldur_ns;

d473 1
a473 1
	void *helper_private;
d476 8
d486 16
d504 2
a505 2
 * drm_connector_funcs - control connectors on a given device
 * @@dpms: set power state (see drm_crtc_funcs above)
d514 6
d526 1
a526 1
	void (*dpms)(struct drm_connector *connector, int mode);
d544 13
d560 1
a560 1
 * drm_encoder_funcs - encoder controls
d574 1
a574 1
 * drm_encoder - central DRM encoder structure
d578 1
d595 1
d603 1
a603 8
	void *helper_private;
};

enum drm_connector_force {
	DRM_FORCE_UNSPECIFIED,
	DRM_FORCE_OFF,
	DRM_FORCE_ON,         /* force on analog part normally */
	DRM_FORCE_ON_DIGITAL, /* for DVI-I use digital connector */
d618 1
a618 1
 * drm_connector - central DRM connector control structure
d624 1
d629 1
d637 1
d641 1
d643 1
d653 13
d680 1
d699 4
d708 1
a708 1
	void *helper_private;
d711 1
d713 1
d726 18
d747 41
a787 1
 * drm_plane_funcs - driver plane control functions
d791 1
d793 6
d809 1
d813 19
d835 1
a835 1
 * drm_plane - central DRM plane control structure
d842 1
d845 2
d849 2
d856 2
d862 2
a863 1
	uint32_t format_count;
d868 2
d873 6
d882 2
a883 1
 * drm_bridge_funcs - drm_bridge control functions
a889 1
 * @@destroy: make object go away
d892 1
a902 1
	void (*destroy)(struct drm_bridge *bridge);
d906 1
a906 1
 * drm_bridge - central DRM bridge control structure
d908 4
a911 2
 * @@head: list management
 * @@base: base mode object
d917 6
a922 3
	struct list_head head;

	struct drm_mode_object base;
d929 31
a959 2
 * drm_mode_set - new values for a CRTC config change
 * @@head: list management
d989 6
a1003 20
};

/**
 * drm_mode_group - group of mode setting resources for potential sub-grouping
 * @@num_crtcs: CRTC count
 * @@num_encoders: encoder count
 * @@num_connectors: connector count
 * @@id_list: list of KMS object IDs in this group
 *
 * Currently this simply tracks the global mode setting state.  But in the
 * future it could allow groups of objects to be set aside into independent
 * control groups for use by different user level processes (e.g. two X servers
 * running simultaneously on different heads, each with their own mode
 * configuration and freedom of mode setting).
 */
struct drm_mode_group {
	uint32_t num_crtcs;
	uint32_t num_encoders;
	uint32_t num_connectors;
	uint32_t num_bridges;
d1005 8
a1012 2
	/* list of object IDs for this group */
	uint32_t *id_list;
d1016 1
a1016 1
 * drm_mode_config - Mode configuration control structure
d1018 3
d1023 1
a1027 2
 * @@num_bridge: number of bridges on this device
 * @@bridge_list: list of bridge objects
d1030 3
d1035 1
d1042 2
a1043 1
 * @@poll_enabled: track polling status for this device
d1045 2
d1048 5
d1060 2
d1064 1
d1067 1
a1067 8

	/**
	 * fb_lock - mutex to protect fb state
	 *
	 * Besides the global fb list his also protects the fbs list in the
	 * file_priv
	 */
	struct rwlock fb_lock;
a1072 2
	int num_bridge;
	struct list_head bridge_list;
d1075 9
a1083 1
	int num_plane;
d1094 1
a1094 1
	paddr_t fb_base;
d1099 1
d1102 2
d1108 16
d1146 1
d1149 4
d1159 3
d1166 13
d1193 5
a1197 7
extern void drm_modeset_lock_all(struct drm_device *dev);
extern void drm_modeset_unlock_all(struct drm_device *dev);
extern void drm_warn_on_modeset_not_all_locked(struct drm_device *dev);

extern int drm_crtc_init(struct drm_device *dev,
			 struct drm_crtc *crtc,
			 const struct drm_crtc_funcs *funcs);
d1219 2
d1223 1
d1227 15
a1241 3
extern int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge,
			   const struct drm_bridge_funcs *funcs);
extern void drm_bridge_cleanup(struct drm_bridge *bridge);
d1261 7
d1272 2
a1273 2
			  const uint32_t *formats, uint32_t format_count,
			  bool priv);
d1275 2
d1278 8
a1288 1
extern const char *drm_get_connector_name(const struct drm_connector *connector);
d1290 1
d1296 4
a1299 3
extern void drm_fb_release(struct drm_device *dev, struct drm_file *file_priv);
extern int drm_mode_group_init_legacy_group(struct drm_device *dev, struct drm_mode_group *group);
extern bool drm_probe_ddc(struct i2c_controller *adapter);
d1301 1
a1301 1
				 struct i2c_controller *adapter);
a1303 5
extern void drm_mode_probed_add(struct drm_connector *connector, struct drm_display_mode *mode);
extern void drm_mode_copy(struct drm_display_mode *dst, const struct drm_display_mode *src);
extern struct drm_display_mode *drm_mode_duplicate(struct drm_device *dev,
						   const struct drm_display_mode *mode);
extern void drm_mode_debug_printmodeline(const struct drm_display_mode *mode);
d1307 4
a1310 20
extern void drm_mode_set_name(struct drm_display_mode *mode);
extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
extern bool drm_mode_equal_no_clocks_no_stereo(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
extern int drm_mode_width(const struct drm_display_mode *mode);
extern int drm_mode_height(const struct drm_display_mode *mode);

/* for us by fb module */
extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
extern void drm_mode_validate_size(struct drm_device *dev,
				   struct list_head *mode_list,
				   int maxX, int maxY, int maxPitch);
extern void drm_mode_prune_invalid(struct drm_device *dev,
				   struct list_head *mode_list, bool verbose);
extern void drm_mode_sort(struct list_head *mode_list);
extern int drm_mode_hsync(const struct drm_display_mode *mode);
extern int drm_mode_vrefresh(const struct drm_display_mode *mode);
extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
				  int adjust_flags);
extern void drm_mode_connector_list_update(struct drm_connector *connector);
d1312 22
a1333 1
						struct edid *edid);
d1363 2
a1364 1
					 int num_values);
d1368 14
d1386 3
a1388 2
extern int drm_mode_create_tv_properties(struct drm_device *dev, int num_formats,
				     char *formats[]);
d1390 1
d1392 5
a1396 1
extern const char *drm_get_encoder_name(const struct drm_encoder *encoder);
a1399 2
extern void drm_mode_connector_detach_encoder(struct drm_connector *connector,
					   struct drm_encoder *encoder);
d1404 1
d1441 4
d1454 1
a1459 10
extern struct drm_display_mode *drm_cvt_mode(struct drm_device *dev,
				int hdisplay, int vdisplay, int vrefresh,
				bool reduced, bool interlaced, bool margins);
extern struct drm_display_mode *drm_gtf_mode(struct drm_device *dev,
				int hdisplay, int vdisplay, int vrefresh,
				bool interlaced, int margins);
extern struct drm_display_mode *drm_gtf_mode_complex(struct drm_device *dev,
				int hdisplay, int vdisplay, int vrefresh,
				bool interlaced, int margins, int GTF_M,
				int GTF_2C, int GTF_K, int GTF_2J);
d1466 2
a1467 1
extern bool drm_edid_block_valid(u8 *raw_edid, int block, bool print_bad_edid);
d1469 7
d1490 5
d1503 4
d1509 9
d1533 58
@


1.8
log
@Revert the drm_crt.c "idr" conversion as it breaks X on (at least) the T430s.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.7 2016/04/06 14:39:19 kettenis Exp $	*/
d840 2
a841 3
	struct rwlock idr_rwl; /* for IDR management */
	SPLAY_HEAD(drm_mode_tree, drm_mode_handle) mode_tree; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
	uint32_t		 mode_obj_id;
@


1.7
log
@Another "idr" conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.6 2015/09/27 11:09:26 jsg Exp $	*/
d840 3
a842 2
	struct rwlock idr_mutex; /* for IDR management */
	struct idr crtc_idr; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
@


1.6
log
@Switch remaining users of the FreeBSD refcount apis back to the original
linux kref/kobject use.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.5 2015/09/23 23:12:11 kettenis Exp $	*/
d840 2
a841 3
	struct rwlock idr_rwl; /* for IDR management */
	SPLAY_HEAD(drm_mode_tree, drm_mode_handle) mode_tree; /* use this idr for all IDs, fb, crtc, connector, modes - just makes life easier */
	uint32_t		 mode_obj_id;
@


1.5
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.4 2015/07/11 04:00:46 jsg Exp $	*/
d270 1
a270 1
	int refcount;
@


1.4
log
@Make use of recent drm_linux.h additions to further reduce the
diff to linux.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.3 2015/02/10 03:39:41 jsg Exp $	*/
d32 1
d41 2
a42 1

d52 1
d111 1
d125 1
a125 1
	.vscan = (vs), .flags = (f), .vrefresh = 0, \
d128 4
a131 1
#define CRTC_INTERLACE_HALVE_V 0x1 /* halve V values for interlacing */
d162 1
a162 2
	int clock_index;
	int synth_clock;
d184 2
d190 5
d271 4
d321 1
d327 1
a327 1
 * @@reset: reset CRTC after state has been invalidate (e.g. resume)
d356 3
d380 2
a381 1
			 struct drm_pending_vblank_event *event);
d416 9
d430 4
d454 1
a454 1
	s64 framedur_ns, linedur_ns, pixeldur_ns;
d468 1
a468 1
 * @@reset: reset connector after state has been invalidate (e.g. resume)
d471 1
a471 1
 * @@set_property: property for this connector may need update
d473 1
a473 1
 * @@force: notify the driver the connector is forced on
a511 2
#define DRM_CONNECTOR_MAX_UMODES 16
#define DRM_CONNECTOR_LEN 32
d523 1
d540 1
a578 1
 * @@user_modes: user added mode list
d602 1
a602 1
	struct device kdev;
d612 1
a622 1
	struct list_head user_modes;
a679 3
 * @@gamma_size: size of gamma table
 * @@gamma_store: gamma correction table
 * @@enabled: enabled flag
a680 1
 * @@helper_private: storage for drver layer
d696 28
a723 3
	/* CRTC gamma size for reporting to userspace */
	uint32_t gamma_size;
	uint16_t *gamma_store;
d725 11
a735 1
	bool enabled;
d737 1
a737 2
	const struct drm_plane_funcs *funcs;
	void *helper_private;
d739 2
a740 1
	struct drm_object_properties properties;
d803 1
d818 2
d844 9
d855 1
d858 2
a905 1
	struct drm_property *dithering_mode_property;
d910 6
d932 4
d940 13
d954 2
d965 4
d974 13
d994 1
d998 7
a1004 6
extern char *drm_get_connector_name(struct drm_connector *connector);
extern char *drm_get_dpms_name(int val);
extern char *drm_get_dvi_i_subconnector_name(int val);
extern char *drm_get_dvi_i_select_name(int val);
extern char *drm_get_tv_subconnector_name(int val);
extern char *drm_get_tv_select_name(int val);
d1010 1
a1012 1
extern void drm_mode_remove(struct drm_connector *connector, struct drm_display_mode *mode);
d1022 1
a1026 5
extern int drm_mode_attachmode_crtc(struct drm_device *dev,
				    struct drm_crtc *crtc,
				    const struct drm_display_mode *mode);
extern int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode);

a1028 2
extern void drm_mode_list_concat(struct list_head *head,
				 struct list_head *new);
a1047 3
extern struct drm_display_mode *drm_crtc_mode_create(struct drm_device *dev);
extern void drm_framebuffer_set_object(struct drm_device *dev,
				       unsigned long handle);
d1051 2
d1057 1
a1057 4
extern int drmfb_probe(struct drm_device *dev, struct drm_crtc *crtc);
extern int drmfb_remove(struct drm_device *dev, struct drm_framebuffer *fb);
extern void drm_crtc_probe_connector_modes(struct drm_device *dev, int maxX, int maxY);
extern bool drm_crtc_in_use(struct drm_crtc *crtc);
a1081 1
extern int drm_mode_create_dithering_property(struct drm_device *dev);
d1083 1
a1083 1
extern char *drm_get_encoder_name(struct drm_encoder *encoder);
d1102 1
d1111 2
a1123 8
extern int drm_mode_addmode_ioctl(struct drm_device *dev,
				  void *data, struct drm_file *file_priv);
extern int drm_mode_rmmode_ioctl(struct drm_device *dev,
				 void *data, struct drm_file *file_priv);
extern int drm_mode_attachmode_ioctl(struct drm_device *dev,
				     void *data, struct drm_file *file_priv);
extern int drm_mode_detachmode_ioctl(struct drm_device *dev,
				     void *data, struct drm_file *file_priv);
a1130 4
extern int drm_mode_hotplug_ioctl(struct drm_device *dev,
				  void *data, struct drm_file *file_priv);
extern int drm_mode_replacefb(struct drm_device *dev,
			      void *data, struct drm_file *file_priv);
d1137 1
a1137 2
extern u8 *drm_find_cea_extension(struct edid *edid);
extern u8 drm_match_cea_mode(struct drm_display_mode *to_match);
d1140 1
d1155 2
a1156 1
extern uint8_t drm_mode_cea_vic(const struct drm_display_mode *mode);
d1182 18
@


1.3
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.2 2013/10/29 06:30:57 jsg Exp $	*/
d798 1
a798 2
	struct timeout output_poll_to;
	struct task poll_task;
@


1.2
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.h,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
d771 1
a771 1
	struct rwlock rwl; /* protects configuration (mode lists etc.) */
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 1
a31 1
#include <sys/workq.h>
d799 1
a799 1
	struct workq_task poll_task;
@

