head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	lQlppvmETCN49oZe;

1.23
date	2015.07.15.22.39.20;	author jsg;	state Exp;
branches;
next	1.22;
commitid	bkv3d9ze7CHVB7aP;

1.22
date	2015.03.26.04.38.58;	author jsg;	state Exp;
branches;
next	1.21;
commitid	uqW7UO6VMj9Ytqkd;

1.21
date	2014.08.14.03.57.44;	author jsg;	state Exp;
branches;
next	1.20;
commitid	nNK6GVR6jSA4Fhuw;

1.20
date	2014.01.18.08.25.06;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.15.11.27.59;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.28.05.13.07;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.22.10.36.01;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.22.05.19.21;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.09.10.33.42;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.12;

1.12
date	2011.05.01.15.42.24;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.12.15.13.44;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2010.03.31.06.29.06;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.29.23.17.48;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.23.21.55.57;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.17.00.26.02;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.04.00.47.02;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.04.00.00.23;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.10.31.18.12.39;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.30.21.33.00;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@/* $OpenBSD: i915_drm.h,v 1.23 2015/07/15 22:39:20 jsg Exp $ */
/*
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _I915_DRM_H_
#define _I915_DRM_H_

#include "drm.h"

/* Please note that modifications to all structs defined here are
 * subject to backwards-compatibility constraints.
 */

/**
 * DOC: uevents generated by i915 on it's device node
 *
 * I915_L3_PARITY_UEVENT - Generated when the driver receives a parity mismatch
 *	event from the gpu l3 cache. Additional information supplied is ROW,
 *	BANK, SUBBANK, SLICE of the affected cacheline. Userspace should keep
 *	track of these events and if a specific cache-line seems to have a
 *	persistent error remap it with the l3 remapping tool supplied in
 *	intel-gpu-tools.  The value supplied with the event is always 1.
 *
 * I915_ERROR_UEVENT - Generated upon error detection, currently only via
 *	hangcheck. The error detection event is a good indicator of when things
 *	began to go badly. The value supplied with the event is a 1 upon error
 *	detection, and a 0 upon reset completion, signifying no more error
 *	exists. NOTE: Disabling hangcheck or reset via module parameter will
 *	cause the related events to not be seen.
 *
 * I915_RESET_UEVENT - Event is generated just before an attempt to reset the
 *	the GPU. The value supplied with the event is always 1. NOTE: Disable
 *	reset via module parameter will cause this event to not be seen.
 */
#define I915_L3_PARITY_UEVENT		"L3_PARITY_ERROR"
#define I915_ERROR_UEVENT		"ERROR"
#define I915_RESET_UEVENT		"RESET"

/* Each region is a minimum of 16k, and there are at most 255 of them.
 */
#define I915_NR_TEX_REGIONS 255	/* table size 2k - maximum due to use
				 * of chars for next/prev indices */
#define I915_LOG_MIN_TEX_REGION_SIZE 14

typedef struct _drm_i915_init {
	enum {
		I915_INIT_DMA = 0x01,
		I915_CLEANUP_DMA = 0x02,
		I915_RESUME_DMA = 0x03
	} func;
	unsigned int mmio_offset;
	int sarea_priv_offset;
	unsigned int ring_start;
	unsigned int ring_end;
	unsigned int ring_size;
	unsigned int front_offset;
	unsigned int back_offset;
	unsigned int depth_offset;
	unsigned int w;
	unsigned int h;
	unsigned int pitch;
	unsigned int pitch_bits;
	unsigned int back_pitch;
	unsigned int depth_pitch;
	unsigned int cpp;
	unsigned int chipset;
} drm_i915_init_t;

typedef struct drm_i915_sarea {
	struct drm_tex_region texList[I915_NR_TEX_REGIONS + 1];
	int last_upload;	/* last time texture was uploaded */
	int last_enqueue;	/* last time a buffer was enqueued */
	int last_dispatch;	/* age of the most recently dispatched buffer */
	int ctxOwner;		/* last context to upload state */
	int texAge;
	int pf_enabled;		/* is pageflipping allowed? */
	int pf_active;
	int pf_current_page;	/* which buffer is being displayed? */
	int perf_boxes;		/* performance boxes to be displayed */
	int width, height;      /* screen size in pixels */

	drm_handle_t front_handle;
	int front_offset;
	int front_size;

	drm_handle_t back_handle;
	int back_offset;
	int back_size;

	drm_handle_t depth_handle;
	int depth_offset;
	int depth_size;

	drm_handle_t tex_handle;
	int tex_offset;
	int tex_size;
	int log_tex_granularity;
	int pitch;
	int rotation;           /* 0, 90, 180 or 270 */
	int rotated_offset;
	int rotated_size;
	int rotated_pitch;
	int virtualX, virtualY;

	unsigned int front_tiled;
	unsigned int back_tiled;
	unsigned int depth_tiled;
	unsigned int rotated_tiled;
	unsigned int rotated2_tiled;

	int planeA_x;
	int planeA_y;
	int planeA_w;
	int planeA_h;
	int planeB_x;
	int planeB_y;
	int planeB_w;
	int planeB_h;

	/* Triple buffering */
	drm_handle_t third_handle;
	int third_offset;
	int third_size;
	unsigned int third_tiled;

	/* buffer object handles for the static buffers.  May change
	 * over the lifetime of the client, though it doesn't in our current
	 * implementation.
	 */
	unsigned int front_bo_handle;
	unsigned int back_bo_handle;
	unsigned int third_bo_handle;
	unsigned int depth_bo_handle;
} drm_i915_sarea_t;

/* Flags for perf_boxes
 */
#define I915_BOX_RING_EMPTY    0x1
#define I915_BOX_FLIP          0x2
#define I915_BOX_WAIT          0x4
#define I915_BOX_TEXTURE_LOAD  0x8
#define I915_BOX_LOST_CONTEXT  0x10

/* I915 specific ioctls
 * The device specific ioctl range is 0x40 to 0x79.
 */
#define DRM_I915_INIT		0x00
#define DRM_I915_FLUSH		0x01
#define DRM_I915_FLIP		0x02
#define DRM_I915_BATCHBUFFER	0x03
#define DRM_I915_IRQ_EMIT	0x04
#define DRM_I915_IRQ_WAIT	0x05
#define DRM_I915_GETPARAM	0x06
#define DRM_I915_SETPARAM	0x07
#define DRM_I915_ALLOC		0x08
#define DRM_I915_FREE		0x09
#define DRM_I915_INIT_HEAP	0x0a
#define DRM_I915_CMDBUFFER	0x0b
#define DRM_I915_DESTROY_HEAP	0x0c
#define DRM_I915_SET_VBLANK_PIPE	0x0d
#define DRM_I915_GET_VBLANK_PIPE	0x0e
#define DRM_I915_VBLANK_SWAP	0x0f
#define DRM_I915_HWS_ADDR	0x11
#define DRM_I915_GEM_INIT	0x13
#define DRM_I915_GEM_EXECBUFFER	0x14
#define DRM_I915_GEM_PIN	0x15
#define DRM_I915_GEM_UNPIN	0x16
#define DRM_I915_GEM_BUSY	0x17
#define DRM_I915_GEM_THROTTLE	0x18
#define DRM_I915_GEM_ENTERVT	0x19
#define DRM_I915_GEM_LEAVEVT	0x1a
#define DRM_I915_GEM_CREATE	0x1b
#define DRM_I915_GEM_PREAD	0x1c
#define DRM_I915_GEM_PWRITE	0x1d
#define DRM_I915_GEM_MMAP	0x1e
#define DRM_I915_GEM_SET_DOMAIN	0x1f
#define DRM_I915_GEM_SW_FINISH	0x20
#define DRM_I915_GEM_SET_TILING	0x21
#define DRM_I915_GEM_GET_TILING	0x22
#define DRM_I915_GEM_GET_APERTURE	0x23
#define DRM_I915_GEM_EXECBUFFER2	0x24	/* MMAP_GTT upstream */
#define DRM_I915_GEM_MADVISE	0x25		/* PIPE_FROM_CRTC_ID upstream */
#define DRM_I915_GEM_MMAP_GTT		0x26	/* MADVISE upstream */
#define DRM_I915_OVERLAY_PUT_IMAGE      0x27
#define DRM_I915_OVERLAY_ATTRS  0x28
#define DRM_I915_GET_PIPE_FROM_CRTC_ID  0x29	/* EXECBUFFER2 upstream */
#define DRM_I915_GET_SPRITE_COLORKEY 0x2a
#define DRM_I915_SET_SPRITE_COLORKEY 0x2b
#define DRM_I915_GEM_WAIT	0x2c
#define DRM_I915_GEM_CONTEXT_CREATE	0x2d
#define DRM_I915_GEM_CONTEXT_DESTROY	0x2e
#define DRM_I915_GEM_SET_CACHING	0x2f
#define DRM_I915_GEM_GET_CACHING	0x30
#define DRM_I915_REG_READ		0x31
#define DRM_I915_GET_RESET_STATS	0x32
#define DRM_I915_GEM_USERPTR		0x33
#define DRM_I915_GEM_CONTEXT_GETPARAM	0x34
#define DRM_I915_GEM_CONTEXT_SETPARAM	0x35

#define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)
#define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)
#define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)
#define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)
#define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)
#define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)
#define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)
#define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)
#define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)
#define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)
#define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)
#define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)
#define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)
#define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
#define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)
#define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)
#define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, drm_i915_hws_addr_t)
#define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)
#define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)
#define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)
#define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)
#define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)
#define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)
#define DRM_IOCTL_I915_GEM_SET_CACHING	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_SET_CACHING, struct drm_i915_gem_caching)
#define DRM_IOCTL_I915_GEM_GET_CACHING	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_GET_CACHING, struct drm_i915_gem_caching)
#define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)
#define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)
#define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)
#define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)
#define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)
#define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)
#define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)
#define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)
#define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)
#define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)
#define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)
#define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)
#define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)
#define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_i915_get_pipe_from_crtc_id)
#define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)
#define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)
#define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)
#define DRM_IOCTL_I915_SET_SPRITE_COLORKEY	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
#define DRM_IOCTL_I915_GET_SPRITE_COLORKEY	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)
#define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)
#define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)
#define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)
#define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)
#define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)
#define DRM_IOCTL_I915_GEM_USERPTR			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR, struct drm_i915_gem_userptr)
#define DRM_IOCTL_I915_GEM_CONTEXT_GETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_GETPARAM, struct drm_i915_gem_context_param)
#define DRM_IOCTL_I915_GEM_CONTEXT_SETPARAM	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_SETPARAM, struct drm_i915_gem_context_param)

/* Allow drivers to submit batchbuffers directly to hardware, relying
 * on the security mechanisms provided by hardware.
 */
typedef struct drm_i915_batchbuffer {
	int start;		/* agp offset */
	int used;		/* nr bytes in use */
	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
	int num_cliprects;	/* mulitpass with multiple cliprects? */
	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
} drm_i915_batchbuffer_t;

/* As above, but pass a pointer to userspace buffer which can be
 * validated by the kernel prior to sending to hardware.
 */
typedef struct _drm_i915_cmdbuffer {
	char __user *buf;	/* pointer to userspace command buffer */
	int sz;			/* nr bytes in buf */
	int DR1;		/* hw flags for GFX_OP_DRAWRECT_INFO */
	int DR4;		/* window origin for GFX_OP_DRAWRECT_INFO */
	int num_cliprects;	/* mulitpass with multiple cliprects? */
	struct drm_clip_rect __user *cliprects;	/* pointer to userspace cliprects */
} drm_i915_cmdbuffer_t;

/* Userspace can request & wait on irq's:
 */
typedef struct drm_i915_irq_emit {
	int __user *irq_seq;
} drm_i915_irq_emit_t;

typedef struct drm_i915_irq_wait {
	int irq_seq;
} drm_i915_irq_wait_t;

/* Ioctl to query kernel params:
 */
#define I915_PARAM_IRQ_ACTIVE            1
#define I915_PARAM_ALLOW_BATCHBUFFER     2
#define I915_PARAM_LAST_DISPATCH         3
#define I915_PARAM_CHIPSET_ID            4
#define I915_PARAM_HAS_GEM		 5
#define I915_PARAM_NUM_FENCES_AVAIL      6
#define I915_PARAM_HAS_OVERLAY           7
#define I915_PARAM_HAS_PAGEFLIPPING	 8
#define I915_PARAM_HAS_EXECBUF2          9
#define I915_PARAM_HAS_BSD		 10
#define I915_PARAM_HAS_BLT		 11
#define I915_PARAM_HAS_RELAXED_FENCING	 12
#define I915_PARAM_HAS_COHERENT_RINGS	 13
#define I915_PARAM_HAS_EXEC_CONSTANTS	 14
#define I915_PARAM_HAS_RELAXED_DELTA	 15
#define I915_PARAM_HAS_GEN7_SOL_RESET	 16
#define I915_PARAM_HAS_LLC		 17
#define I915_PARAM_HAS_ALIASING_PPGTT	 18
#define I915_PARAM_HAS_WAIT_TIMEOUT	 19
#define I915_PARAM_HAS_SEMAPHORES	 20
#define I915_PARAM_HAS_PRIME_VMAP_FLUSH	 21
#define I915_PARAM_HAS_VEBOX		 22
#define I915_PARAM_HAS_SECURE_BATCHES	 23
#define I915_PARAM_HAS_PINNED_BATCHES	 24
#define I915_PARAM_HAS_EXEC_NO_RELOC	 25
#define I915_PARAM_HAS_EXEC_HANDLE_LUT	 26
#define I915_PARAM_HAS_WT     	 	 27
#define I915_PARAM_CMD_PARSER_VERSION	 28
#define I915_PARAM_HAS_COHERENT_PHYS_GTT 29
#define I915_PARAM_MMAP_VERSION          30
#define I915_PARAM_HAS_BSD2		 31
#define I915_PARAM_REVISION              32
#define I915_PARAM_SUBSLICE_TOTAL	 33
#define I915_PARAM_EU_TOTAL		 34

typedef struct drm_i915_getparam {
	int param;
	int __user *value;
} drm_i915_getparam_t;

/* Ioctl to set kernel params:
 */
#define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1
#define I915_SETPARAM_TEX_LRU_LOG_GRANULARITY             2
#define I915_SETPARAM_ALLOW_BATCHBUFFER                   3
#define I915_SETPARAM_NUM_USED_FENCES                     4

typedef struct drm_i915_setparam {
	int param;
	int value;
} drm_i915_setparam_t;

/* A memory manager for regions of shared memory:
 */
#define I915_MEM_REGION_AGP 1

typedef struct drm_i915_mem_alloc {
	int region;
	int alignment;
	int size;
	int __user *region_offset;	/* offset from start of fb or agp */
} drm_i915_mem_alloc_t;

typedef struct drm_i915_mem_free {
	int region;
	int region_offset;
} drm_i915_mem_free_t;

typedef struct drm_i915_mem_init_heap {
	int region;
	int size;
	int start;
} drm_i915_mem_init_heap_t;

/* Allow memory manager to be torn down and re-initialized (eg on
 * rotate):
 */
typedef struct drm_i915_mem_destroy_heap {
	int region;
} drm_i915_mem_destroy_heap_t;

/* Allow X server to configure which pipes to monitor for vblank signals
 */
#define	DRM_I915_VBLANK_PIPE_A	1
#define	DRM_I915_VBLANK_PIPE_B	2

typedef struct drm_i915_vblank_pipe {
	int pipe;
} drm_i915_vblank_pipe_t;

/* Schedule buffer swap at given vertical blank:
 */
typedef struct drm_i915_vblank_swap {
	drm_drawable_t drawable;
	enum drm_vblank_seq_type seqtype;
	unsigned int sequence;
} drm_i915_vblank_swap_t;

typedef struct drm_i915_hws_addr {
	uint64_t addr;
} drm_i915_hws_addr_t;

struct drm_i915_gem_init {
	/**
	 * Beginning offset in the GTT to be managed by the DRM memory
	 * manager.
	 */
	uint64_t gtt_start;
	/**
	 * Ending offset in the GTT to be managed by the DRM memory
	 * manager.
	 */
	uint64_t gtt_end;
};

struct drm_i915_gem_create {
	/**
	 * Requested size for the object.
	 *
	 * The (page-aligned) allocated size for the object will be returned.
	 */
	uint64_t size;
	/**
	 * Returned handle for the object.
	 *
	 * Object handles are nonzero.
	 */
	uint32_t handle;
	uint32_t pad;
};

struct drm_i915_gem_pread {
	/** Handle for the object being read. */
	uint32_t handle;
	uint32_t pad;
	/** Offset into the object to read from */
	uint64_t offset;
	/** Length of data to read */
	uint64_t size;
	/**
	 * Pointer to write the data into.
	 *
	 * This is a fixed-size type for 32/64 compatibility.
	 */
	uint64_t data_ptr;
};

struct drm_i915_gem_pwrite {
	/** Handle for the object being written to. */
	uint32_t handle;
	uint32_t pad;
	/** Offset into the object to write to */
	uint64_t offset;
	/** Length of data to write */
	uint64_t size;
	/**
	 * Pointer to read the data from.
	 *
	 * This is a fixed-size type for 32/64 compatibility.
	 */
	uint64_t data_ptr;
};

struct drm_i915_gem_mmap {
	/** Handle for the object being mapped. */
	uint32_t handle;
	uint32_t pad;
	/** Offset in the object to map. */
	uint64_t offset;
	/**
	 * Length of data to map.
	 *
	 * The value will be page-aligned.
	 */
	uint64_t size;
	/**
	 * Returned pointer the data was mapped at.
	 *
	 * This is a fixed-size type for 32/64 compatibility.
	 */
	uint64_t addr_ptr;

	/*
	 * Flags for extended behaviour.
	 *
	 * Added in version 2.
	 */
	uint64_t flags;
#define I915_MMAP_WC 0x1
};

struct drm_i915_gem_mmap_gtt {
	/** Handle for the object being mapped. */
	uint32_t handle;
	uint32_t pad;
	/**
	 * Fake offset to use for subsequent mmap call
	 *
	 * This is a fixed-size type for 32/64 compatibility.
	 */
	uint64_t offset;
};

struct drm_i915_gem_set_domain {
	/** Handle for the object */
	uint32_t handle;

	/** New read domains */
	uint32_t read_domains;

	/** New write domain */
	uint32_t write_domain;
};

struct drm_i915_gem_sw_finish {
	/** Handle for the object */
	uint32_t handle;
};

struct drm_i915_gem_relocation_entry {
	/**
	 * Handle of the buffer being pointed to by this relocation entry.
	 *
	 * It's appealing to make this be an index into the mm_validate_entry
	 * list to refer to the buffer, but this allows the driver to create
	 * a relocation list for state buffers and not re-write it per
	 * exec using the buffer.
	 */
	uint32_t target_handle;

	/**
	 * Value to be added to the offset of the target buffer to make up
	 * the relocation entry.
	 */
	uint32_t delta;

	/** Offset in the buffer the relocation entry will be written into */
	uint64_t offset;

	/**
	 * Offset value of the target buffer that the relocation entry was last
	 * written as.
	 *
	 * If the buffer has the same offset as last time, we can skip syncing
	 * and writing the relocation.  This value is written back out by
	 * the execbuffer ioctl when the relocation is written.
	 */
	uint64_t presumed_offset;

	/**
	 * Target memory domains read by this operation.
	 */
	uint32_t read_domains;

	/**
	 * Target memory domains written by this operation.
	 *
	 * Note that only one domain may be written by the whole
	 * execbuffer operation, so that where there are conflicts,
	 * the application will get -EINVAL back.
	 */
	uint32_t write_domain;
};

/** @@{
 * Intel memory domains
 *
 * Most of these just align with the various caches in
 * the system and are used to flush and invalidate as
 * objects end up cached in different domains.
 */
/** CPU cache */
#define I915_GEM_DOMAIN_CPU		0x00000001
/** Render cache, used by 2D and 3D drawing */
#define I915_GEM_DOMAIN_RENDER		0x00000002
/** Sampler cache, used by texture engine */
#define I915_GEM_DOMAIN_SAMPLER		0x00000004
/** Command queue, used to load batch buffers */
#define I915_GEM_DOMAIN_COMMAND		0x00000008
/** Instruction cache, used by shader programs */
#define I915_GEM_DOMAIN_INSTRUCTION	0x00000010
/** Vertex address cache */
#define I915_GEM_DOMAIN_VERTEX		0x00000020
/** GTT domain - aperture and scanout */
#define I915_GEM_DOMAIN_GTT		0x00000040
/** @@} */

struct drm_i915_gem_exec_object2 {
	/**
	 * User's handle for a buffer to be bound into the GTT for this
	 * operation.
	 */
	u_int32_t handle;

	/** Number of relocations to be performed on this buffer */
	u_int32_t relocation_count;
	/**
	 * Pointer to array of struct drm_i915_gem_relocation_entry containing
	 * the relocations to be performed in this buffer.
	 */
	u_int64_t relocs_ptr;

	/** Required alignment in graphics aperture */
	u_int64_t alignment;

	/**
	 * Returned value of the updated offset of the object, for future
	 * presumed_offset writes.
	 */
	u_int64_t offset;

#define EXEC_OBJECT_NEEDS_FENCE (1<<0)
#define EXEC_OBJECT_NEEDS_GTT	(1<<1)
#define EXEC_OBJECT_WRITE	(1<<2)
#define __EXEC_OBJECT_UNKNOWN_FLAGS -(EXEC_OBJECT_WRITE<<1)
	u_int64_t flags;
	u_int64_t rsvd1;
	u_int64_t rsvd2;
};

struct drm_i915_gem_execbuffer2 {
	/**
	 * List of gem_exec_object2 structs
	 */
	u_int64_t buffers_ptr;
	u_int32_t buffer_count;

	/** Offset in the batchbuffer to start execution from. */
	u_int32_t batch_start_offset;
	/** Bytes used in batchbuffer from batch_start_offset */
	u_int32_t batch_len;
#ifndef __OpenBSD__
	u_int32_t DR1;
	u_int32_t DR4;
	u_int32_t num_cliprects;
	/** This is a struct drm_clip_rect *cliprects */
	u_int64_t cliprects_ptr;
#endif
#define I915_EXEC_RING_MASK              (7<<0)
#define I915_EXEC_DEFAULT                (0<<0)
#define I915_EXEC_RENDER                 (1<<0)
#define I915_EXEC_BSD                    (2<<0)
#define I915_EXEC_BLT                    (3<<0)
#define I915_EXEC_VEBOX                  (4<<0)

/* Used for switching the constants addressing mode on gen4+ RENDER ring.
 * Gen6+ only supports relative addressing to dynamic state (default) and
 * absolute addressing.
 *
 * These flags are ignored for the BSD and BLT rings.
 */
#define I915_EXEC_CONSTANTS_MASK 	(3<<6)
#define I915_EXEC_CONSTANTS_REL_GENERAL (0<<6) /* default */
#define I915_EXEC_CONSTANTS_ABSOLUTE 	(1<<6)
#define I915_EXEC_CONSTANTS_REL_SURFACE (2<<6) /* gen4/5 only */
	u_int64_t flags;
	u_int64_t rsvd1;
	u_int64_t rsvd2;
};

/** Resets the SO write offset registers for transform feedback on gen7. */
#define I915_EXEC_GEN7_SOL_RESET	(1<<8)

/** Request a privileged ("secure") batch buffer. Note only available for
 * DRM_ROOT_ONLY | DRM_MASTER processes.
 */
#define I915_EXEC_SECURE		(1<<9)

/** Inform the kernel that the batch is and will always be pinned. This
 * negates the requirement for a workaround to be performed to avoid
 * an incoherent CS (such as can be found on 830/845). If this flag is
 * not passed, the kernel will endeavour to make sure the batch is
 * coherent with the CS before execution. If this flag is passed,
 * userspace assumes the responsibility for ensuring the same.
 */
#define I915_EXEC_IS_PINNED		(1<<10)

/** Provide a hint to the kernel that the command stream and auxiliary
 * state buffers already holds the correct presumed addresses and so the
 * relocation process may be skipped if no buffers need to be moved in
 * preparation for the execbuffer.
 */
#define I915_EXEC_NO_RELOC		(1<<11)

/** Use the reloc.handle as an index into the exec object array rather
 * than as the per-file handle.
 */
#define I915_EXEC_HANDLE_LUT		(1<<12)

/** Used for switching BSD rings on the platforms with two BSD rings */
#define I915_EXEC_BSD_MASK		(3<<13)
#define I915_EXEC_BSD_DEFAULT		(0<<13) /* default ping-pong mode */
#define I915_EXEC_BSD_RING1		(1<<13)
#define I915_EXEC_BSD_RING2		(2<<13)

#define __I915_EXEC_UNKNOWN_FLAGS -(1<<15)

#define I915_EXEC_CONTEXT_ID_MASK	(0xffffffff)
#define i915_execbuffer2_set_context_id(eb2, context) \
	(eb2).rsvd1 = context & I915_EXEC_CONTEXT_ID_MASK
#define i915_execbuffer2_get_context_id(eb2) \
	((eb2).rsvd1 & I915_EXEC_CONTEXT_ID_MASK)

struct drm_i915_gem_pin {
	/** Handle of the buffer to be pinned. */
	uint32_t handle;
	uint32_t pad;

	/** alignment required within the aperture */
	uint64_t alignment;

	/** Returned GTT offset of the buffer. */
	uint64_t offset;
};

struct drm_i915_gem_unpin {
	/** Handle of the buffer to be unpinned. */
	uint32_t handle;
	uint32_t pad;
};

struct drm_i915_gem_busy {
	/** Handle of the buffer to check for busy */
	uint32_t handle;

	/** Return busy status (1 if busy, 0 if idle) */
	uint32_t busy;
};

/**
 * I915_CACHING_NONE
 *
 * GPU access is not coherent with cpu caches. Default for machines without an
 * LLC.
 */
#define I915_CACHING_NONE		0
/**
 * I915_CACHING_CACHED
 *
 * GPU access is coherent with cpu caches and furthermore the data is cached in
 * last-level caches shared between cpu cores and the gpu GT. Default on
 * machines with HAS_LLC.
 */
#define I915_CACHING_CACHED		1
/**
 * I915_CACHING_DISPLAY
 *
 * Special GPU caching mode which is coherent with the scanout engines.
 * Transparently falls back to I915_CACHING_NONE on platforms where no special
 * cache mode (like write-through or gfdt flushing) is available. The kernel
 * automatically sets this mode when using a buffer as a scanout target.
 * Userspace can manually set this mode to avoid a costly stall and clflush in
 * the hotpath of drawing the first frame.
 */
#define I915_CACHING_DISPLAY		2


struct drm_i915_gem_caching {
	/**
	 * Handle of the buffer to set/get the caching level of. */
	uint32_t handle;

	/**
	 * Cacheing level to apply or return value
	 *
	 * bits0-15 are for generic caching control (i.e. the above defined
	 * values). bits16-31 are reserved for platform-specific variations
	 * (e.g. l3$ caching on gen7). */
	uint32_t caching;
};

#define I915_TILING_NONE	0
#define I915_TILING_X		1
#define I915_TILING_Y		2

#define I915_BIT_6_SWIZZLE_NONE		0
#define I915_BIT_6_SWIZZLE_9		1
#define I915_BIT_6_SWIZZLE_9_10		2
#define I915_BIT_6_SWIZZLE_9_11		3
#define I915_BIT_6_SWIZZLE_9_10_11	4
/* Not seen by userland */
#define I915_BIT_6_SWIZZLE_UNKNOWN	5
/* Seen by userland. */
#define I915_BIT_6_SWIZZLE_9_17		6
#define I915_BIT_6_SWIZZLE_9_10_17	7

struct drm_i915_gem_set_tiling {
	/** Handle of the buffer to have its tiling state updated */
	uint32_t handle;

	/**
	 * Tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
	 * I915_TILING_Y).
	 *
	 * This value is to be set on request, and will be updated by the
	 * kernel on successful return with the actual chosen tiling layout.
	 *
	 * The tiling mode may be demoted to I915_TILING_NONE when the system
	 * has bit 6 swizzling that can't be managed correctly by GEM.
	 *
	 * Buffer contents become undefined when changing tiling_mode.
	 */
	uint32_t tiling_mode;

	/**
	 * Stride in bytes for the object when in I915_TILING_X or
	 * I915_TILING_Y.
	 */
	uint32_t stride;

	/**
	 * Returned address bit 6 swizzling required for CPU access through
	 * mmap mapping.
	 */
	uint32_t swizzle_mode;
};

struct drm_i915_gem_get_tiling {
	/** Handle of the buffer to get tiling state for. */
	uint32_t handle;

	/**
	 * Current tiling mode for the object (I915_TILING_NONE, I915_TILING_X,
	 * I915_TILING_Y).
	 */
	uint32_t tiling_mode;

	/**
	 * Returned address bit 6 swizzling required for CPU access through
	 * mmap mapping.
	 */
	uint32_t swizzle_mode;

	/**
	 * Returned address bit 6 swizzling required for CPU access through
	 * mmap mapping whilst bound.
	 */
	uint32_t phys_swizzle_mode;
};

struct drm_i915_gem_get_aperture {
	/** Total size of the aperture used by i915_gem_execbuffer, in bytes */
	uint64_t aper_size;

	/**
	 * Available space in the aperture used by i915_gem_execbuffer, in
	 * bytes
	 */
	uint64_t aper_available_size;
};

struct drm_i915_get_pipe_from_crtc_id {
	/** ID of CRTC being requested **/
	uint32_t crtc_id;

	/** pipe of requested CRTC **/
	uint32_t pipe;
};

#define I915_MADV_WILLNEED 0
#define I915_MADV_DONTNEED 1
#define __I915_MADV_PURGED 2 /* internal state */

struct drm_i915_gem_madvise {
	/** Handle of the buffer to change the backing store advice */
	u_int32_t handle;

	/* Advice: either the buffer will be needed again in the near future,
	 *         or wont be and could be discarded under memory pressure.
	 */
	u_int32_t madv;

	/** Whether the backing store still exists. */
	u_int32_t retained;
};

#define I915_OVERLAY_TYPE_MASK 		0xff
#define I915_OVERLAY_YUV_PLANAR 	0x01
#define I915_OVERLAY_YUV_PACKED 	0x02
#define I915_OVERLAY_RGB		0x03

#define I915_OVERLAY_DEPTH_MASK		0xff00
#define I915_OVERLAY_RGB24		0x1000
#define I915_OVERLAY_RGB16		0x2000
#define I915_OVERLAY_RGB15		0x3000
#define I915_OVERLAY_YUV422		0x0100
#define I915_OVERLAY_YUV411		0x0200
#define I915_OVERLAY_YUV420		0x0300
#define I915_OVERLAY_YUV410		0x0400

#define I915_OVERLAY_SWAP_MASK		0xff0000
#define I915_OVERLAY_NO_SWAP		0x000000
#define I915_OVERLAY_UV_SWAP		0x010000
#define I915_OVERLAY_Y_SWAP		0x020000
#define I915_OVERLAY_Y_AND_UV_SWAP	0x030000

#define I915_OVERLAY_FLAGS_MASK		0xff000000
#define I915_OVERLAY_ENABLE		0x01000000

struct drm_intel_overlay_put_image {
	/* various flags and src format description */
	uint32_t flags;
	/* source picture description */
	uint32_t bo_handle;
	/* stride values and offsets are in bytes, buffer relative */
	uint16_t stride_Y; /* stride for packed formats */
	uint16_t stride_UV;
	uint32_t offset_Y; /* offset for packet formats */
	uint32_t offset_U;
	uint32_t offset_V;
	/* in pixels */
	uint16_t src_width;
	uint16_t src_height;
	/* to compensate the scaling factors for partially covered surfaces */
	uint16_t src_scan_width;
	uint16_t src_scan_height;
	/* output crtc description */
	uint32_t crtc_id;
	uint16_t dst_x;
	uint16_t dst_y;
	uint16_t dst_width;
	uint16_t dst_height;
};

/* flags */
#define I915_OVERLAY_UPDATE_ATTRS	(1<<0)
#define I915_OVERLAY_UPDATE_GAMMA	(1<<1)
struct drm_intel_overlay_attrs {
	uint32_t flags;
	uint32_t color_key;
	int32_t brightness;
	uint32_t contrast;
	uint32_t saturation;
	uint32_t gamma0;
	uint32_t gamma1;
	uint32_t gamma2;
	uint32_t gamma3;
	uint32_t gamma4;
	uint32_t gamma5;
};

/*
 * Intel sprite handling
 *
 * Color keying works with a min/mask/max tuple.  Both source and destination
 * color keying is allowed.
 *
 * Source keying:
 * Sprite pixels within the min & max values, masked against the color channels
 * specified in the mask field, will be transparent.  All other pixels will
 * be displayed on top of the primary plane.  For RGB surfaces, only the min
 * and mask fields will be used; ranged compares are not allowed.
 *
 * Destination keying:
 * Primary plane pixels that match the min value, masked against the color
 * channels specified in the mask field, will be replaced by corresponding
 * pixels from the sprite plane.
 *
 * Note that source & destination keying are exclusive; only one can be
 * active on a given plane.
 */

#define I915_SET_COLORKEY_NONE		(1<<0) /* disable color key matching */
#define I915_SET_COLORKEY_DESTINATION	(1<<1)
#define I915_SET_COLORKEY_SOURCE	(1<<2)
struct drm_intel_sprite_colorkey {
	uint32_t plane_id;
	uint32_t min_value;
	uint32_t channel_mask;
	uint32_t max_value;
	uint32_t flags;
};

struct drm_i915_gem_wait {
	/** Handle of BO we shall wait on */
	uint32_t bo_handle;
	uint32_t flags;
	/** Number of nanoseconds to wait, Returns time remaining. */
	int64_t timeout_ns;
};

struct drm_i915_gem_context_create {
	/*  output: id of new context*/
	uint32_t ctx_id;
	uint32_t pad;
};

struct drm_i915_gem_context_destroy {
	uint32_t ctx_id;
	uint32_t pad;
};

struct drm_i915_reg_read {
	uint64_t offset;
	uint64_t val; /* Return value */
};

struct drm_i915_reset_stats {
	uint32_t ctx_id;
	uint32_t flags;

	/* All resets since boot/module reload, for all contexts */
	uint32_t reset_count;

	/* Number of batches lost when active in GPU, for this context */
	uint32_t batch_active;

	/* Number of batches lost pending for execution, for this context */
	uint32_t batch_pending;

	uint32_t pad;
};

struct drm_i915_gem_userptr {
	uint64_t user_ptr;
	uint64_t user_size;
	uint32_t flags;
#define I915_USERPTR_READ_ONLY 0x1
#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
	/**
	* Returned handle for the object.
	*
	* Object handles are nonzero.
	*/
	uint32_t handle;
};

struct drm_i915_gem_context_param {
	uint32_t ctx_id;
	uint32_t size;
	uint64_t param;
#define I915_CONTEXT_PARAM_BAN_PERIOD 0x1
	uint64_t value;
};

#endif				/* _I915_DRM_H_ */
@


1.23
log
@add some definitions from libdrm 2.4.62
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.22 2015/03/26 04:38:58 jsg Exp $ */
d624 3
@


1.22
log
@additional params from libdrm 2.4.60
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.21 2014/08/14 03:57:44 jsg Exp $ */
d220 2
d272 3
a274 1
#define DRM_IOCTL_I915_GEM_USERPTR		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR,  struct drm_i915_gem_userptr)
d493 8
d698 7
a704 1
#define __I915_EXEC_UNKNOWN_FLAGS -(I915_EXEC_HANDLE_LUT<<1)
d841 6
d1034 8
@


1.21
log
@add some definitions from libdrm 2.4.56
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.20 2014/01/18 08:25:06 jsg Exp $ */
d336 6
@


1.20
log
@Update the drm headers based on libdrm 2.4.51
but make sure we still reject DRM_MODE_PAGE_FLIP_ASYNC.

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.19 2013/06/15 11:27:59 jsg Exp $ */
d31 2
d37 24
a60 1
#include "drm.h"
d219 1
d270 1
d332 4
d668 14
d714 6
d721 7
d729 12
d990 14
@


1.19
log
@add some definitions from the libdrm version of i915_drm.h
needed to compile recent versions of libdrm
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.18 2013/03/28 05:13:07 jsg Exp $ */
d193 1
d243 1
d905 17
@


1.18
log
@add the ioctls to get/set the caching level of a buffer object
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.17 2013/03/22 10:36:01 jsg Exp $ */
d300 1
a300 1
#define I915_PARAM_RSVD_FOR_FUTURE_USE	 22
d601 1
@


1.17
log
@add some macros needed by newer libdrm
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.16 2013/03/22 05:19:21 jsg Exp $ */
d190 2
a191 2
#define DRM_I915_GEM_SET_CACHEING	0x2f
#define DRM_I915_GEM_GET_CACHEING	0x30
d217 2
d664 17
@


1.16
log
@add some definitions required for recent versions of libdrm
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.15 2013/03/18 12:36:51 jsg Exp $ */
d631 6
@


1.15
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.14 2013/01/09 10:33:42 jsg Exp $ */
d187 6
d236 4
d854 23
@


1.14
log
@Sync the userland facing drm headers with FreeBSD minus some cruft mpi
says has been removed upstream.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: i915_drm.h,v 1.13 2011/06/02 18:22:00 weerd Exp $ */
d284 7
d604 17
@


1.13
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d179 8
a186 2
#define DRM_I915_GEM_EXECBUFFER2	0x24
#define DRM_I915_GEM_MADVISE	0x25
d218 1
d224 1
d226 4
d282 2
d433 12
d570 7
d698 8
d721 97
@


1.12
log
@Add some PARAM and flags defines needed for later version of the intel
DDX, libdrm and mesa. So far the kernel doesn't support them (and will
return an error if inquired) but userland knows how to cope.
@
text
@d1 1
@


1.11
log
@Fix a ton of space and tab violations.  No binary change.

ok oga
@
text
@d260 2
d263 6
d543 17
a559 1
	u_int64_t flags; /* currently unused */
@


1.10
log
@update the inteldrm GEM interface to the newer version.

This adds a couple of new ioctls and remove the I915_GEM_EXECBUFFER
ioctl in exchange for EXECBUFFER2 which supports better tiling
parameters. the original interface is removed since our GEM support will
not support it. This temporarily breaks the build of libdrm_intel, this
will be fixed in the next commit.

discussed with matthieu@@
@
text
@d258 1
a258 1
#define I915_PARAM_HAS_GEM           	 5
@


1.9
log
@Correct a couple of ioctl definitions (GEM ioctls, not used yet). and
add two more {GET,SET}_PARAM arguments that aren't supported yet but are
needed for a libdrm update.
@
text
@d177 3
a179 1
#define DRM_I915_GEM_GET_APERTURE 0x23
d200 1
d216 1
d260 1
d494 1
a494 1
struct drm_i915_gem_exec_object {
d499 1
a499 1
	uint32_t handle;
d502 1
a502 1
	uint32_t relocation_count;
d507 1
a507 1
	uint64_t relocs_ptr;
d510 1
a510 1
	uint64_t alignment;
d516 6
a521 1
	uint64_t offset;
d524 1
a524 1
struct drm_i915_gem_execbuffer {
d526 1
a526 8
	 * List of buffers to be validated with their relocations to be
	 * performend on them.
	 *
	 * This is a pointer to an array of struct drm_i915_gem_validate_entry.
	 *
	 * These buffers must be listed in an order such that all relocations
	 * a buffer is performing refer to buffers that have already appeared
	 * in the validate list.
d528 2
a529 2
	uint64_t buffers_ptr;
	uint32_t buffer_count;
d532 1
a532 1
	uint32_t batch_start_offset;
d534 4
a537 6
	uint32_t batch_len;
	uint32_t DR1;
	uint32_t DR4;
	uint32_t num_cliprects;
	/** This is a struct drm_clip_rect *cliprects */
	uint64_t cliprects_ptr;
d577 3
d638 17
@


1.8
log
@Include the GEM interface in i915_drm.h.

While we don't have code for this (yet!), mean I will be able to update
libdrm, and consequently the xf86-video-intel driver to 2.5.x.

Add PARAM_HAS_GEM to the getparam ioctl, and return no support.
@
text
@d196 2
a197 2
#define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_pin)
#define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_pin)
d255 1
d267 1
@


1.7
log
@rework how we handle ioctls.

Before it was based on a static array with flags. Instead, let the
driver provide an ioctl callback, which deals with things appropriately.
Makes the code a bit easier to read, and also drops just over 5k on an
amd64 kernel build with all drm drivers enabled.

Tested by a few.
@
text
@d161 17
d196 17
d254 1
d321 312
@


1.6
log
@Kill some more ttm only defines. No binary change.
@
text
@d178 1
@


1.5
log
@revert the pageflipping and vblank sync code to the older style that
doesn't handle triple buffering (which has been marked ``don't use this,
it's unstable'' for ever anyway)

While the code just removed is in drm git. it's not planned to go any
further, due to being a horribly ugly hack. Instead a proper fix which
will depend on memory management is planned. So revert this stuff here,
since it's now dead.

Testing shows no regressions.
@
text
@a132 10
/* Driver specific fence types and classes.
 */

/* The only fence class we support */
#define DRM_I915_FENCE_CLASS_ACCEL 0
/* Fence type that guarantees read-write flush */
#define DRM_I915_FENCE_TYPE_RW 2
/* MI_FLUSH programmed just before the fence */
#define DRM_I915_FENCE_FLAG_FLUSHED 0x01000000

@


1.4
log
@Remove another interface (this one for ARB_Occlusion_Query) that we've
never used (mesa did a version check that never passed on our kernel).
The correct way to do this is in mesa master and requires memory
management.
@
text
@d174 1
a174 1
#define DRM_IOCTL_I915_FLIP		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FLIP, drm_i915_flip_t)
a187 12

/* Asynchronous page flipping:
 */
typedef struct drm_i915_flip {
	/*
	 * This is really talking about planes, and we could rename it
	 * except for the fact that some of the duplicated i915_drm.h files
	 * out there check for HAVE_I915_FLIP and so might pick up this
	 * version.
	 */
	int pipes;
} drm_i915_flip_t;
@


1.3
log
@Bunch of cleanup. Kill some dead variables and some stupid code.

Some ideas taken from upstream.
@
text
@a169 1
#define DRM_I915_MMIO		0x10
a187 1
#define DRM_IOCTL_I915_MMIO             DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_MMIO, drm_i915_mmio)
a303 28
#define I915_MMIO_READ	0
#define I915_MMIO_WRITE 1

#define I915_MMIO_MAY_READ	0x1
#define I915_MMIO_MAY_WRITE	0x2

#define MMIO_REGS_IA_PRIMATIVES_COUNT		0
#define MMIO_REGS_IA_VERTICES_COUNT		1
#define MMIO_REGS_VS_INVOCATION_COUNT		2
#define MMIO_REGS_GS_PRIMITIVES_COUNT		3
#define MMIO_REGS_GS_INVOCATION_COUNT		4
#define MMIO_REGS_CL_PRIMITIVES_COUNT		5
#define MMIO_REGS_CL_INVOCATION_COUNT		6
#define MMIO_REGS_PS_INVOCATION_COUNT		7
#define MMIO_REGS_PS_DEPTH_COUNT		8

typedef struct drm_i915_mmio_entry {
	unsigned int flag;
	unsigned int offset;
	unsigned int size;
} drm_i915_mmio_entry_t;

typedef struct drm_i915_mmio {
	unsigned int read_write:1;
	unsigned int reg:31;
	void __user *data;
} drm_i915_mmio_t;

a307 43
/*
 * Relocation header is 4 uint32_ts
 * 0 - 32 bit reloc count
 * 1 - 32-bit relocation type
 * 2-3 - 64-bit user buffer handle ptr for another list of relocs.
 */
#define I915_RELOC_HEADER 4

/*
 * type 0 relocation has 4-uint32_t stride
 * 0 - offset into buffer
 * 1 - delta to add in
 * 2 - buffer handle
 * 3 - reserved (for optimisations later).
 */
/*
 * type 1 relocation has 4-uint32_t stride.
 * Hangs off the first item in the op list.
 * Performed after all valiations are done.
 * Try to group relocs into the same relocatee together for
 * performance reasons.
 * 0 - offset into buffer
 * 1 - delta to add in
 * 2 - buffer index in op list.
 * 3 - relocatee index in op list.
 */
#define I915_RELOC_TYPE_0 0
#define I915_RELOC0_STRIDE 4
#define I915_RELOC_TYPE_1 1
#define I915_RELOC1_STRIDE 4


struct drm_i915_op_arg {
	uint64_t next;
	uint64_t reloc_ptr;
	int handled;
	unsigned int pad64;
	union {
		struct drm_bo_op_req req;
		struct drm_bo_arg_rep rep;
	} d;

};
@


1.2
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d46 1
a46 6
		I915_RESUME_DMA = 0x03,

		/* Since this struct isn't versioned, just used a new
		 * 'func' code to indicate the presence of dri2 sarea
		 * info. */
		I915_INIT_DMA2 = 0x04
a63 1
	unsigned int sarea_handle;
a171 1
#define DRM_I915_EXECBUFFER	0x12
a189 1
#define DRM_IOCTL_I915_EXECBUFFER	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_EXECBUFFER, struct drm_i915_execbuffer)
a380 9

struct drm_i915_execbuffer {
	uint64_t ops_list;
	uint32_t num_buffers;
	struct drm_i915_batchbuffer batch;
	drm_context_t context; /* for lockless use in the future */
	struct drm_fence_arg fence_arg;
};

@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d46 6
a51 1
		I915_RESUME_DMA = 0x03
d69 1
d72 1
a72 1
typedef struct _drm_i915_sarea {
d128 9
d196 1
d214 1
a214 1
typedef struct _drm_i915_batchbuffer {
d250 1
d294 1
a294 1
	        int region;
d334 1
a334 1
}drm_i915_mmio_entry_t;
d348 3
a350 3
 * 0 - (16-bit relocation type << 16)| 16 bit reloc count
 * 1 - buffer handle for another list of relocs
 * 2-3 - spare.
d358 1
a358 1
 * 2 - index into buffer list
d361 11
d374 3
d380 1
a380 1
	uint32_t reloc_handle;
d382 1
d393 2
a394 1
	struct _drm_i915_batchbuffer batch;
@

