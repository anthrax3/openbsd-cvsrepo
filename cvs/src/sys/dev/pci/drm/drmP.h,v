head	1.212;
access;
symbols
	OPENBSD_6_1:1.209.0.4
	OPENBSD_6_1_BASE:1.209
	OPENBSD_6_0:1.208.0.4
	OPENBSD_6_0_BASE:1.208
	OPENBSD_5_9:1.201.0.2
	OPENBSD_5_9_BASE:1.201
	OPENBSD_5_8:1.196.0.4
	OPENBSD_5_8_BASE:1.196
	OPENBSD_5_7:1.181.0.4
	OPENBSD_5_7_BASE:1.181
	OPENBSD_5_6:1.178.0.4
	OPENBSD_5_6_BASE:1.178
	OPENBSD_5_5:1.168.0.4
	OPENBSD_5_5_BASE:1.168
	OPENBSD_5_4:1.139.0.2
	OPENBSD_5_4_BASE:1.139
	OPENBSD_5_3:1.133.0.2
	OPENBSD_5_3_BASE:1.133
	OPENBSD_5_2:1.129.0.2
	OPENBSD_5_2_BASE:1.129
	OPENBSD_5_1_BASE:1.128
	OPENBSD_5_1:1.128.0.4
	OPENBSD_5_0:1.128.0.2
	OPENBSD_5_0_BASE:1.128
	OPENBSD_4_9:1.126.0.4
	OPENBSD_4_9_BASE:1.126
	OPENBSD_4_8:1.126.0.2
	OPENBSD_4_8_BASE:1.126
	OPENBSD_4_7:1.121.0.2
	OPENBSD_4_7_BASE:1.121
	OPENBSD_4_6:1.121.0.4
	OPENBSD_4_6_BASE:1.121
	OPENBSD_4_5:1.91.0.2
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.212
date	2017.07.01.16.00.25;	author kettenis;	state Exp;
branches;
next	1.211;
commitid	aN6GlSqZJXG1gx72;

1.211
date	2017.06.22.05.32.47;	author tom;	state Exp;
branches;
next	1.210;
commitid	LpWsneIZSfBvhVMD;

1.210
date	2017.05.25.03.19.39;	author dlg;	state Exp;
branches;
next	1.209;
commitid	gx8rjMxrMcqYnydg;

1.209
date	2016.10.08.05.52.06;	author guenther;	state Exp;
branches;
next	1.208;
commitid	gFhAhnnQ2SlMacGa;

1.208
date	2016.04.08.08.27.53;	author kettenis;	state Exp;
branches;
next	1.207;
commitid	mS4ttEBzpAfn3sVx;

1.207
date	2016.04.07.20.33.24;	author kettenis;	state Exp;
branches;
next	1.206;
commitid	b7TUPgWhn5cou224;

1.206
date	2016.04.06.21.12.40;	author kettenis;	state Exp;
branches;
next	1.205;
commitid	QO3FDEetxShNl6Ad;

1.205
date	2016.04.06.14.58.43;	author kettenis;	state Exp;
branches;
next	1.204;
commitid	QtEPymaKwwJgK7rF;

1.204
date	2016.04.05.20.46.45;	author kettenis;	state Exp;
branches;
next	1.203;
commitid	BLB92V3xeQqiMrY4;

1.203
date	2016.04.05.20.40.54;	author kettenis;	state Exp;
branches;
next	1.202;
commitid	6Li4Q3Z14vl5FBKL;

1.202
date	2016.04.05.08.22.50;	author kettenis;	state Exp;
branches;
next	1.201;
commitid	4zEfxNVjitzOF81p;

1.201
date	2016.02.05.10.05.12;	author kettenis;	state Exp;
branches;
next	1.200;
commitid	gX0sRFu8RGimO2hC;

1.200
date	2015.11.22.15.35.49;	author kettenis;	state Exp;
branches;
next	1.199;
commitid	sDPS7MogSiSWMILu;

1.199
date	2015.11.21.15.23.44;	author kettenis;	state Exp;
branches;
next	1.198;
commitid	txqmluU6Zd2aixzF;

1.198
date	2015.09.26.19.52.16;	author kettenis;	state Exp;
branches;
next	1.197;
commitid	PpEJMvqmELqAFnQv;

1.197
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.196;
commitid	lQlppvmETCN49oZe;

1.196
date	2015.05.30.18.09.26;	author jsg;	state Exp;
branches;
next	1.195;
commitid	RLEb9ScM5nactkVr;

1.195
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.194;
commitid	c1fUeeFWMNg4COgR;

1.194
date	2015.04.17.00.54.41;	author jsg;	state Exp;
branches;
next	1.193;
commitid	LqdQe79hlknpVtvI;

1.193
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.192;
commitid	syZU9J25izIJ2cm1;

1.192
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.191;
commitid	uVTyY1h8Sggc8pFj;

1.191
date	2015.04.11.04.36.10;	author jsg;	state Exp;
branches;
next	1.190;
commitid	TECQYb9n8eZTOhib;

1.190
date	2015.04.10.12.06.52;	author jsg;	state Exp;
branches;
next	1.189;
commitid	5bVyebI6DOf5FKY3;

1.189
date	2015.04.10.06.00.39;	author jsg;	state Exp;
branches;
next	1.188;
commitid	FsvvOgzRMXgywM01;

1.188
date	2015.04.10.05.52.09;	author jsg;	state Exp;
branches;
next	1.187;
commitid	kbWi2Upg7N1nrCLW;

1.187
date	2015.04.10.05.31.25;	author jsg;	state Exp;
branches;
next	1.186;
commitid	BNr9TiYARwtS3iCu;

1.186
date	2015.04.06.15.43.15;	author jsg;	state Exp;
branches;
next	1.185;
commitid	DCPoYnokQzAg9pjM;

1.185
date	2015.04.06.12.25.10;	author jsg;	state Exp;
branches;
next	1.184;
commitid	CN1fAwudhSb2ckyl;

1.184
date	2015.04.06.10.56.37;	author jsg;	state Exp;
branches;
next	1.183;
commitid	YRwUkzqVtigPPQbt;

1.183
date	2015.04.06.09.23.19;	author jsg;	state Exp;
branches;
next	1.182;
commitid	99nej6bpjNHMCLwr;

1.182
date	2015.04.03.13.10.59;	author jsg;	state Exp;
branches;
next	1.181;
commitid	PZIJ62HYZVx8fbpI;

1.181
date	2015.02.12.08.48.32;	author jsg;	state Exp;
branches;
next	1.180;
commitid	b7XA83Agvw5SEHRi;

1.180
date	2015.02.11.07.01.36;	author jsg;	state Exp;
branches;
next	1.179;
commitid	dLgISW35NAmGN8Xl;

1.179
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.178;
commitid	a8Vt7gSt34kmziIS;

1.178
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.177;
commitid	OBNa5kfxQ2UXoiIw;

1.177
date	2014.05.24.21.09.15;	author miod;	state Exp;
branches;
next	1.176;

1.176
date	2014.04.07.06.43.11;	author jsg;	state Exp;
branches;
next	1.175;

1.175
date	2014.04.01.20.16.50;	author kettenis;	state Exp;
branches;
next	1.174;

1.174
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.173;

1.173
date	2014.03.25.17.44.39;	author mpi;	state Exp;
branches;
next	1.172;

1.172
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.171;

1.171
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.170;

1.170
date	2014.03.13.12.45.04;	author kettenis;	state Exp;
branches;
next	1.169;

1.169
date	2014.03.09.07.42.29;	author jsg;	state Exp;
branches;
next	1.168;

1.168
date	2014.02.23.09.36.52;	author kettenis;	state Exp;
branches;
next	1.167;

1.167
date	2014.02.09.10.50.43;	author jsg;	state Exp;
branches;
next	1.166;

1.166
date	2014.02.04.22.19.53;	author kettenis;	state Exp;
branches;
next	1.165;

1.165
date	2014.02.02.03.53.05;	author jsg;	state Exp;
branches;
next	1.164;

1.164
date	2014.02.02.00.58.35;	author jsg;	state Exp;
branches;
next	1.163;

1.163
date	2014.01.30.15.10.47;	author kettenis;	state Exp;
branches;
next	1.162;

1.162
date	2014.01.22.22.17.34;	author jsg;	state Exp;
branches;
next	1.161;

1.161
date	2014.01.22.05.16.55;	author kettenis;	state Exp;
branches;
next	1.160;

1.160
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.159;

1.159
date	2014.01.21.08.55.24;	author kettenis;	state Exp;
branches;
next	1.158;

1.158
date	2013.12.21.19.36.41;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2013.12.15.22.09.36;	author kettenis;	state Exp;
branches;
next	1.156;

1.156
date	2013.12.05.13.29.56;	author kettenis;	state Exp;
branches;
next	1.155;

1.155
date	2013.12.01.09.13.46;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2013.11.27.20.41.19;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.152;

1.152
date	2013.11.07.05.33.05;	author jsg;	state Exp;
branches;
next	1.151;

1.151
date	2013.11.02.22.58.10;	author kettenis;	state Exp;
branches;
next	1.150;

1.150
date	2013.10.26.20.31.48;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2013.09.08.11.59.44;	author jsg;	state Exp;
branches;
next	1.148;

1.148
date	2013.09.02.07.14.22;	author jsg;	state Exp;
branches;
next	1.147;

1.147
date	2013.09.02.06.25.27;	author jsg;	state Exp;
branches;
next	1.146;

1.146
date	2013.08.27.03.06.02;	author jsg;	state Exp;
branches;
next	1.145;

1.145
date	2013.08.26.05.15.20;	author jsg;	state Exp;
branches;
next	1.144;

1.144
date	2013.08.14.02.49.19;	author jsg;	state Exp;
branches;
next	1.143;

1.143
date	2013.08.14.02.16.54;	author jsg;	state Exp;
branches;
next	1.142;

1.142
date	2013.08.13.10.23.48;	author jsg;	state Exp;
branches;
next	1.141;

1.141
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.140;

1.140
date	2013.08.07.19.49.04;	author kettenis;	state Exp;
branches;
next	1.139;

1.139
date	2013.07.08.09.43.18;	author jsg;	state Exp;
branches;
next	1.138;

1.138
date	2013.06.11.19.39.09;	author kettenis;	state Exp;
branches;
next	1.137;

1.137
date	2013.06.07.20.46.14;	author kettenis;	state Exp;
branches;
next	1.136;

1.136
date	2013.03.28.23.47.37;	author jsg;	state Exp;
branches;
next	1.135;

1.135
date	2013.03.21.19.39.30;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	1.133;

1.133
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.132;

1.132
date	2012.09.08.16.42.20;	author mpi;	state Exp;
branches;
next	1.131;

1.131
date	2012.08.22.08.23.41;	author mpi;	state Exp;
branches;
next	1.130;

1.130
date	2012.08.21.16.38.48;	author mpi;	state Exp;
branches;
next	1.129;

1.129
date	2012.04.11.17.42.53;	author mikeb;	state Exp;
branches;
next	1.128;

1.128
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.02.07.15.45;	author jasper;	state Exp;
branches;
next	1.126;

1.126
date	2010.07.18.21.01.06;	author oga;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.24.01.19.19;	author oga;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.25.21.53.21;	author oga;	state Exp;
branches;
next	1.123;

1.123
date	2010.04.08.11.45.54;	author oga;	state Exp;
branches;
next	1.122;

1.122
date	2010.03.27.00.09.50;	author oga;	state Exp;
branches;
next	1.121;

1.121
date	2009.05.12.19.42.42;	author oga;	state Exp;
branches;
next	1.120;

1.120
date	2009.05.11.00.06.39;	author oga;	state Exp;
branches;
next	1.119;

1.119
date	2009.04.06.21.30.18;	author oga;	state Exp;
branches;
next	1.118;

1.118
date	2009.04.06.04.51.31;	author oga;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.06.04.21.59;	author oga;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.05.04.15.37;	author oga;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.05.00.32.54;	author oga;	state Exp;
branches;
next	1.114;

1.114
date	2009.04.04.16.02.57;	author oga;	state Exp;
branches;
next	1.113;

1.113
date	2009.04.03.15.22.30;	author oga;	state Exp;
branches;
next	1.112;

1.112
date	2009.04.03.15.07.59;	author oga;	state Exp;
branches;
next	1.111;

1.111
date	2009.04.03.15.04.46;	author oga;	state Exp;
branches;
next	1.110;

1.110
date	2009.04.03.14.59.27;	author oga;	state Exp;
branches;
next	1.109;

1.109
date	2009.04.03.14.41.23;	author oga;	state Exp;
branches;
next	1.108;

1.108
date	2009.04.03.14.36.23;	author oga;	state Exp;
branches;
next	1.107;

1.107
date	2009.04.03.14.31.53;	author oga;	state Exp;
branches;
next	1.106;

1.106
date	2009.04.03.14.30.57;	author oga;	state Exp;
branches;
next	1.105;

1.105
date	2009.04.03.14.16.23;	author oga;	state Exp;
branches;
next	1.104;

1.104
date	2009.04.03.13.56.23;	author oga;	state Exp;
branches;
next	1.103;

1.103
date	2009.04.03.13.51.45;	author oga;	state Exp;
branches;
next	1.102;

1.102
date	2009.04.03.13.47.03;	author oga;	state Exp;
branches;
next	1.101;

1.101
date	2009.04.03.11.31.36;	author oga;	state Exp;
branches;
next	1.100;

1.100
date	2009.04.03.01.07.45;	author oga;	state Exp;
branches;
next	1.99;

1.99
date	2009.03.31.20.05.06;	author oga;	state Exp;
branches;
next	1.98;

1.98
date	2009.03.30.00.17.12;	author oga;	state Exp;
branches;
next	1.97;

1.97
date	2009.03.29.03.27.02;	author oga;	state Exp;
branches;
next	1.96;

1.96
date	2009.03.27.19.36.55;	author oga;	state Exp;
branches;
next	1.95;

1.95
date	2009.03.27.19.00.45;	author oga;	state Exp;
branches;
next	1.94;

1.94
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.26.22.40.06;	author oga;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.26.07.25.06;	author oga;	state Exp;
branches;
next	1.91;

1.91
date	2009.02.15.20.21.42;	author oga;	state Exp;
branches;
next	1.90;

1.90
date	2009.02.15.20.10.24;	author oga;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.15.20.03.19;	author oga;	state Exp;
branches;
next	1.88;

1.88
date	2009.02.15.20.00.11;	author oga;	state Exp;
branches;
next	1.87;

1.87
date	2009.02.15.19.58.08;	author oga;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.15.19.56.04;	author oga;	state Exp;
branches;
next	1.85;

1.85
date	2009.02.15.19.52.21;	author oga;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.05.00.25.51;	author oga;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.29.11.50.16;	author oga;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.29.11.44.04;	author oga;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.29.11.38.44;	author oga;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.29.11.18.16;	author oga;	state Exp;
branches;
next	1.79;

1.79
date	2009.01.27.00.29.44;	author oga;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.29.01.23.58;	author oga;	state Exp;
branches;
next	1.77;

1.77
date	2008.11.24.16.56.25;	author oga;	state Exp;
branches;
next	1.76;

1.76
date	2008.11.24.12.22.54;	author oga;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.24.07.06.27;	author oga;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.24.05.51.23;	author oga;	state Exp;
branches;
next	1.73;

1.73
date	2008.11.24.04.21.31;	author oga;	state Exp;
branches;
next	1.72;

1.72
date	2008.11.24.03.49.19;	author oga;	state Exp;
branches;
next	1.71;

1.71
date	2008.11.24.03.27.02;	author oga;	state Exp;
branches;
next	1.70;

1.70
date	2008.11.23.22.56.02;	author oga;	state Exp;
branches;
next	1.69;

1.69
date	2008.11.23.22.01.59;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2008.11.23.21.35.00;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.23.20.46.47;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.22.22.54.48;	author oga;	state Exp;
branches;
next	1.65;

1.65
date	2008.11.22.22.43.53;	author oga;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.22.22.10.42;	author oga;	state Exp;
branches;
next	1.63;

1.63
date	2008.11.22.21.26.48;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.22.20.49.36;	author oga;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.22.14.42.36;	author oga;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.22.05.05.10;	author oga;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.22.04.45.21;	author oga;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.18.15.58.00;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.17.00.30.41;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.17.00.26.02;	author oga;	state Exp;
branches;
next	1.55;

1.55
date	2008.11.11.16.46.42;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.06.16.37.53;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.28.23.41.11;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2008.10.07.22.25.12;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.50;

1.50
date	2008.09.29.22.50.07;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2008.09.18.15.10.57;	author oga;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.10.02.09.56;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2008.09.09.21.02.06;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.07.00.44.05;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2008.09.06.02.54.52;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2008.09.06.01.32.08;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.09.05.23.51.03;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2008.09.02.01.12.04;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.29.15.14.59;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.28.00.19.27;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.21.21.43.56;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.21.18.23.17;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.18.00.01.49;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.08.17.23.49.02;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.17.23.36.22;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.17.19.21.36;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.17.16.56.14;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.13.20.38.26;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.13.20.27.58;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.13.20.22.55;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.13.19.33.29;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.13.19.30.11;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.29.22.23.50;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.29.19.44.13;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.10.00.10.22;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.07.16.29.57;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.26.18.35.24;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.18.17.22;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.26.18.07.02;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.17.01.03;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.12.19.14.53;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.03.17.21.22;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.05.27.19.51.29;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.27.19.45.29;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.27.19.39.52;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.27.19.35.22;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.06.19.24.56;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.16.13.17.58;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.12.14.23.13;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.12.14.14.02;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.12.14.10.21;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.12.13.55.59;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.05.19.34.01;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.212
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/* $OpenBSD: drmP.h,v 1.211 2017/06/22 05:32:47 tom Exp $ */
/* drmP.h -- Private header for Direct Rendering Manager -*- linux-c -*-
 * Created: Mon Jan  4 10:05:05 1999 by faith@@precisioninsight.com
 */
/*-
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *
 */

#ifndef _DRM_P_H_
#define _DRM_P_H_

#if defined(_KERNEL) || defined(__KERNEL__)

//#define DRMDEBUG

#include <sys/param.h>
#include <sys/queue.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/mutex.h>
#include <sys/tree.h>
#include <sys/endian.h>
#include <sys/stdint.h>
#include <sys/memrange.h>
#include <sys/extent.h>
#include <sys/rwlock.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <uvm/uvm_extern.h>
#include <uvm/uvm_object.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/agpvar.h>
#include <machine/bus.h>

#define CONFIG_DRM_FBDEV_EMULATION

#include "drm_linux.h"
#include "drm_linux_list.h"
#include "drm.h"
#include "drm_vma_manager.h"
#include <dev/pci/drm/drm_crtc.h>
#include "drm_mm.h"
#include "drm_linux_atomic.h"
#include "agp.h"

struct fb_cmap;
struct fb_fillrect;
struct fb_copyarea;
struct fb_image;

#define drm_debug	0
#define DRM_UT_KMS	0

/***********************************************************************/
/** \name DRM template customization defaults */
/*@@{*/

/* driver capabilities and requirements mask */
#define DRIVER_USE_AGP     0x1
#define DRIVER_PCI_DMA     0x8
#define DRIVER_SG          0x10
#define DRIVER_HAVE_DMA    0x20
#define DRIVER_HAVE_IRQ    0x40
#define DRIVER_IRQ_SHARED  0x80
#define DRIVER_GEM         0x1000
#define DRIVER_MODESET     0x2000
#define DRIVER_PRIME       0x4000
#define DRIVER_RENDER      0x8000
#define DRIVER_ATOMIC      0x10000

#define	DRM_DEBUGBITS_DEBUG		0x1
#define	DRM_DEBUGBITS_KMS		0x2
#define	DRM_DEBUGBITS_FAILED_IOCTL	0x4

#define __OS_HAS_AGP		(NAGP > 0)

				/* Internal types and structures */
#define DRM_IF_VERSION(maj, min) (maj << 16 | min)

#define DRM_CURRENTPID		curproc->p_p->ps_pid
#define DRM_MAXUNITS		8

/* DRM_SUSER returns true if the user is superuser */
#define DRM_SUSER(p)		(suser(p, 0) == 0)
#define DRM_MTRR_WC		MDF_WRITECOMBINE

#define DRM_WAKEUP(x)		wakeup(x)

extern int ticks;

#define drm_msleep(x)		mdelay(x)

extern struct cfdriver drm_cd;

/* freebsd compat */
#define	TAILQ_CONCAT(head1, head2, field) do {				\
	if (!TAILQ_EMPTY(head2)) {					\
		*(head1)->tqh_last = (head2)->tqh_first;		\
		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
		(head1)->tqh_last = (head2)->tqh_last;			\
		TAILQ_INIT((head2));					\
	}								\
} while (0)

#define DRM_ARRAY_SIZE nitems

/* DRM_READMEMORYBARRIER() prevents reordering of reads.
 * DRM_WRITEMEMORYBARRIER() prevents reordering of writes.
 * DRM_MEMORYBARRIER() prevents reordering of reads and writes.
 */
#if defined(__i386__)
#define DRM_READMEMORYBARRIER()		__asm __volatile( \
					"lock; addl $0,0(%%esp)" : : : "memory");
#define DRM_WRITEMEMORYBARRIER()	__asm __volatile("" : : : "memory");
#define DRM_MEMORYBARRIER()		__asm __volatile( \
					"lock; addl $0,0(%%esp)" : : : "memory");
#elif defined(__alpha__)
#define DRM_READMEMORYBARRIER()		alpha_mb();
#define DRM_WRITEMEMORYBARRIER()	alpha_wmb();
#define DRM_MEMORYBARRIER()		alpha_mb();
#elif defined(__amd64__)
#define DRM_READMEMORYBARRIER()		__asm __volatile( \
					"lock; addl $0,0(%%rsp)" : : : "memory");
#define DRM_WRITEMEMORYBARRIER()	__asm __volatile("" : : : "memory");
#define DRM_MEMORYBARRIER()		__asm __volatile( \
					"lock; addl $0,0(%%rsp)" : : : "memory");
#elif defined(__mips64__)
#define DRM_READMEMORYBARRIER()		DRM_MEMORYBARRIER() 
#define DRM_WRITEMEMORYBARRIER()	DRM_MEMORYBARRIER()
#define DRM_MEMORYBARRIER()		mips_sync()
#elif defined(__powerpc__)
#define DRM_READMEMORYBARRIER()		DRM_MEMORYBARRIER() 
#define DRM_WRITEMEMORYBARRIER()	DRM_MEMORYBARRIER()
#define DRM_MEMORYBARRIER()		__asm __volatile("sync" : : : "memory");
#elif defined(__sparc64__)
#define DRM_READMEMORYBARRIER()		DRM_MEMORYBARRIER() 
#define DRM_WRITEMEMORYBARRIER()	DRM_MEMORYBARRIER()
#define DRM_MEMORYBARRIER()		membar_sync()
#endif

#define smp_mb__before_atomic()		DRM_MEMORYBARRIER()
#define smp_mb__before_atomic_dec()	DRM_MEMORYBARRIER()
#define smp_mb__after_atomic_dec()	DRM_MEMORYBARRIER()
#define smp_mb__before_atomic_inc()	DRM_MEMORYBARRIER()
#define smp_mb__after_atomic_inc()	DRM_MEMORYBARRIER()

#define mb()				DRM_MEMORYBARRIER()
#define rmb()				DRM_READMEMORYBARRIER()
#define wmb()				DRM_WRITEMEMORYBARRIER()
#define smp_rmb()			DRM_READMEMORYBARRIER()
#define smp_wmb()			DRM_WRITEMEMORYBARRIER()
#define mmiowb()			DRM_WRITEMEMORYBARRIER()

#define	DRM_COPY_TO_USER(user, kern, size)	copyout(kern, user, size)
#define	DRM_COPY_FROM_USER(kern, user, size)	copyin(user, kern, size)

#define DRM_UDELAY(udelay)	DELAY(udelay)

static inline bool
drm_can_sleep(void)
{
#if defined(__i386__) || defined(__amd64__)
	if (pagefault_disabled() || in_dbg_master() || irqs_disabled())
#else
	if (in_dbg_master() || irqs_disabled())
#endif
		return false;
	return true;
}

#define DRM_WAIT_ON(ret, wq, timo, condition) do {			\
	ret = wait_event_interruptible_timeout(wq, condition, timo);	\
	if (ret == 0)							\
		ret = -EBUSY;						\
	if (ret > 0)							\
		ret = 0;						\
} while (0)

#define DRM_ERROR(fmt, arg...) \
	printf("error: [" DRM_NAME ":pid%d:%s] *ERROR* " fmt,		\
	    curproc->p_p->ps_pid, __func__ , ## arg)


#ifdef DRMDEBUG
#define DRM_INFO(fmt, arg...)  printf("drm: " fmt, ## arg)
#define DRM_INFO_ONCE(fmt, arg...)  printf("drm: " fmt, ## arg)
#else
#define DRM_INFO(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#define DRM_INFO_ONCE(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#endif

#ifdef DRMDEBUG
#undef DRM_DEBUG
#define DRM_DEBUG(fmt, arg...) do {					\
	if (drm_debug_flag)						\
		printf("[" DRM_NAME ":pid%d:%s] " fmt,			\
		    curproc->p_p->ps_pid, __func__ , ## arg);		\
} while (0)
#else
#define DRM_DEBUG(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#endif

#ifdef DRMDEBUG
#undef DRM_DEBUG_KMS
#define DRM_DEBUG_KMS(fmt, arg...) do {					\
	if (drm_debug_flag)						\
		printf("[" DRM_NAME ":pid%d:%s] " fmt,			\
		    curproc->p_p->ps_pid, __func__ , ## arg);		\
} while (0)
#else
#define DRM_DEBUG_KMS(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#endif

#ifdef DRMDEBUG
#undef DRM_LOG_KMS
#define DRM_LOG_KMS(fmt, arg...) do {					\
	if (drm_debug_flag)						\
		printf(fmt, ## arg);					\
} while (0)
#else
#define DRM_LOG_KMS(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#endif

#ifdef DRMDEBUG
#undef DRM_DEBUG_DRIVER
#define DRM_DEBUG_DRIVER(fmt, arg...) do {					\
	if (drm_debug_flag)						\
		printf("[" DRM_NAME ":pid%d:%s] " fmt,			\
		    curproc->p_p->ps_pid, __func__ , ## arg);		\
} while (0)
#else
#define DRM_DEBUG_DRIVER(fmt, arg...) do { } while(/* CONSTCOND */ 0)
#endif

#ifdef DRMDEBUG
#undef DRM_DEBUG_ATOMIC
#define DRM_DEBUG_ATOMIC(fmt, arg...) do {					\
	if (drm_debug_flag)						\
		printf("[" DRM_NAME ":pid%d:%s] " fmt,			\
		    curproc->p_p->ps_pid, __func__ , ## arg);		\
} while (0)
#else
#define DRM_DEBUG_ATOMIC(fmt, arg...) do { } while(0)
#endif

#define DRM_DEBUG_VBL(fmt, arg...) do {} while(0)

struct drm_pcidev {
	uint16_t vendor;
	uint16_t device;
	uint16_t subvendor;
	uint16_t subdevice;
	uint32_t class;
	uint32_t class_mask;
	unsigned long driver_data;
};

struct drm_file;
struct drm_device;

/**
 * Ioctl function type.
 *
 * \param inode device inode.
 * \param file_priv DRM file private pointer.
 * \param cmd command.
 * \param arg argument.
 */
typedef int drm_ioctl_t(struct drm_device *dev, void *data,
			struct drm_file *file_priv);

typedef int drm_ioctl_compat_t(struct file *filp, unsigned int cmd,
			       unsigned long arg);

#define DRM_AUTH	0x1
#define DRM_MASTER	0x2
#define DRM_ROOT_ONLY	0x4
#define DRM_CONTROL_ALLOW 0x8
#define DRM_UNLOCKED	0x10
#define DRM_RENDER_ALLOW 0x20

struct drm_ioctl_desc {
	unsigned int cmd;
	int flags;
	drm_ioctl_t *func;
	unsigned int cmd_drv;
};

/**
 * Creates a driver or general drm_ioctl_desc array entry for the given
 * ioctl, for use by drm_ioctl().
 */

#define DRM_IOCTL_DEF_DRV(ioctl, _func, _flags)			\
	[DRM_IOCTL_NR(DRM_##ioctl)] = {.cmd = DRM_##ioctl, .func = _func, .flags = _flags, .cmd_drv = DRM_IOCTL_##ioctl}

struct drm_dmamem {
	bus_dmamap_t		map;
	caddr_t			kva;
	bus_size_t		size;
	int			nsegs;
	bus_dma_segment_t	segs[1];
};
typedef struct drm_dmamem drm_dma_handle_t;

struct drm_pending_event {
	struct drm_event *event;
	struct list_head link;
	struct drm_file *file_priv;
	pid_t pid; /* pid of requester, no guarantee it's valid by the time
		      we deliver the event, for tracing only */
	void (*destroy)(struct drm_pending_event *event);
};

/** File private data */
struct drm_file {
	unsigned always_authenticated :1;
	unsigned authenticated :1;
	unsigned is_master :1; /* this file private is a master for a minor */
	/* true when the client has asked us to expose stereo 3D mode flags */
	unsigned stereo_allowed :1;
	/*
	 * true if client understands CRTC primary planes and cursor planes
	 * in the plane list
	 */
	unsigned universal_planes:1;
	/* true if client understands atomic properties */
	unsigned atomic:1;

	drm_magic_t magic;
	int minor;

	/** Mapping of mm object handles to object pointers. */
	struct idr object_idr;
	/** Lock for synchronization of access to object_idr. */
	spinlock_t table_lock;

	struct file *filp;
	void *driver_priv;

	/**
	 * fbs - List of framebuffers associated with this file.
	 *
	 * Protected by fbs_lock. Note that the fbs list holds a reference on
	 * the fb object to prevent it from untimely disappearing.
	 */
	struct list_head fbs;
	struct rwlock fbs_lock;

	/** User-created blob properties; this retains a reference on the
	 *  property. */
	struct list_head blobs;

	wait_queue_head_t event_wait;
	struct list_head event_list;
	int event_space;

	struct selinfo rsel;
	SPLAY_ENTRY(drm_file) link;
};

struct drm_agp_head {
	struct agp_softc			*agpdev;
	const char				*chipset;
	TAILQ_HEAD(agp_memlist, drm_agp_mem)	 memory;
	struct agp_info				 info;
	unsigned long				 base;
	unsigned long				 mode;
	unsigned long				 page_mask;
	int					 acquired;
	int					 cant_use_aperture;
	int					 enabled;
   	int					 mtrr;
};

/* location of GART table */
#define DRM_ATI_GART_MAIN 1
#define DRM_ATI_GART_FB   2

#define DRM_ATI_GART_PCI  1
#define DRM_ATI_GART_PCIE 2
#define DRM_ATI_GART_IGP  3
#define DRM_ATI_GART_R600 4

/**
 * This structure defines the drm_mm memory object, which will be used by the
 * DRM for its buffer objects.
 */
struct drm_gem_object {
	/** Reference count of this object */
	struct kref refcount;

	/**
	 * handle_count - gem file_priv handle count of this object
	 *
	 * Each handle also holds a reference. Note that when the handle_count
	 * drops to 0 any global names (e.g. the id in the flink namespace) will
	 * be cleared.
	 *
	 * Protected by dev->object_name_lock.
	 * */
	unsigned handle_count;

	/** Related drm device */
	struct drm_device *dev;

	/** File representing the shmem storage */
	struct file *filp;

	/* Mapping info for this object */
	struct drm_vma_offset_node vma_node;

	/**
	 * Size of the object, in bytes.  Immutable over the object's
	 * lifetime.
	 */
	size_t size;

	/**
	 * Global name for this object, starts at 1. 0 means unnamed.
	 * Access is covered by the object_name_lock in the related drm_device
	 */
	int name;

	/**
	 * Memory domains. These monitor which caches contain read/write data
	 * related to the object. When transitioning from one set of domains
	 * to another, the driver is called to ensure that caches are suitably
	 * flushed and invalidated
	 */
	uint32_t read_domains;
	uint32_t write_domain;

	/**
	 * While validating an exec operation, the
	 * new read/write domain values are computed here.
	 * They will be transferred to the above values
	 * at the point that any cache flushing occurs
	 */
	uint32_t pending_read_domains;
	uint32_t pending_write_domain;

	struct uvm_object uobj;
	SPLAY_ENTRY(drm_gem_object) entry;
	struct uvm_object *uao;
};

/* Size of ringbuffer for vblank timestamps. Just double-buffer
 * in initial implementation.
 */
#define DRM_VBLANKTIME_RBSIZE 2

/* Flags and return codes for get_vblank_timestamp() driver function. */
#define DRM_CALLED_FROM_VBLIRQ 1
#define DRM_VBLANKTIME_SCANOUTPOS_METHOD (1 << 0)
#define DRM_VBLANKTIME_IN_VBLANK         (1 << 1)

/* get_scanout_position() return flags */
#define DRM_SCANOUTPOS_VALID        (1 << 0)
#define DRM_SCANOUTPOS_IN_VBLANK    (1 << 1)
#define DRM_SCANOUTPOS_ACCURATE     (1 << 2)

struct drm_driver {
	int	(*firstopen)(struct drm_device *);
	int	(*open)(struct drm_device *, struct drm_file *);
	void	(*close)(struct drm_device *, struct drm_file *);
	void	(*preclose)(struct drm_device *, struct drm_file *);
	void	(*postclose)(struct drm_device *, struct drm_file *);
	void	(*lastclose)(struct drm_device *);
	struct uvm_object *(*mmap)(struct drm_device *, voff_t, vsize_t);
	int	(*dma_ioctl)(struct drm_device *, struct drm_dma *,
		    struct drm_file *);
	int	(*irq_handler)(int, void *);
	void	(*irq_preinstall) (struct drm_device *);
	int	(*irq_install)(struct drm_device *);
	int	(*irq_postinstall) (struct drm_device *);
	void	(*irq_uninstall)(struct drm_device *);
	int	vblank_pipes;

	/**
	 * get_vblank_counter - get raw hardware vblank counter
	 * @@dev: DRM device
	 * @@pipe: counter to fetch
	 *
	 * Driver callback for fetching a raw hardware vblank counter for @@crtc.
	 * If a device doesn't have a hardware counter, the driver can simply
	 * return the value of drm_vblank_count. The DRM core will account for
	 * missed vblank events while interrupts where disabled based on system
	 * timestamps.
	 *
	 * Wraparound handling and loss of events due to modesetting is dealt
	 * with in the DRM core code.
	 *
	 * RETURNS
	 * Raw vblank counter value.
	 */
	u32 (*get_vblank_counter) (struct drm_device *dev, unsigned int pipe);

	/**
	 * enable_vblank - enable vblank interrupt events
	 * @@dev: DRM device
	 * @@pipe: which irq to enable
	 *
	 * Enable vblank interrupts for @@crtc.  If the device doesn't have
	 * a hardware vblank counter, this routine should be a no-op, since
	 * interrupts will have to stay on to keep the count accurate.
	 *
	 * RETURNS
	 * Zero on success, appropriate errno if the given @@crtc's vblank
	 * interrupt cannot be enabled.
	 */
	int (*enable_vblank) (struct drm_device *dev, unsigned int pipe);

	/**
	 * disable_vblank - disable vblank interrupt events
	 * @@dev: DRM device
	 * @@pipe: which irq to enable
	 *
	 * Disable vblank interrupts for @@crtc.  If the device doesn't have
	 * a hardware vblank counter, this routine should be a no-op, since
	 * interrupts will have to stay on to keep the count accurate.
	 */
	void (*disable_vblank) (struct drm_device *dev, unsigned int pipe);

	/**
	 * Called by vblank timestamping code.
	 *
	 * Return the current display scanout position from a crtc, and an
	 * optional accurate ktime_get timestamp of when position was measured.
	 *
	 * \param dev  DRM device.
	 * \param pipe Id of the crtc to query.
	 * \param flags Flags from the caller (DRM_CALLED_FROM_VBLIRQ or 0).
	 * \param *vpos Target location for current vertical scanout position.
	 * \param *hpos Target location for current horizontal scanout position.
	 * \param *stime Target location for timestamp taken immediately before
	 *               scanout position query. Can be NULL to skip timestamp.
	 * \param *etime Target location for timestamp taken immediately after
	 *               scanout position query. Can be NULL to skip timestamp.
	 * \param mode Current display timings.
	 *
	 * Returns vpos as a positive number while in active scanout area.
	 * Returns vpos as a negative number inside vblank, counting the number
	 * of scanlines to go until end of vblank, e.g., -1 means "one scanline
	 * until start of active scanout / end of vblank."
	 *
	 * \return Flags, or'ed together as follows:
	 *
	 * DRM_SCANOUTPOS_VALID = Query successful.
	 * DRM_SCANOUTPOS_INVBL = Inside vblank.
	 * DRM_SCANOUTPOS_ACCURATE = Returned position is accurate. A lack of
	 * this flag means that returned position may be offset by a constant
	 * but unknown small number of scanlines wrt. real scanout position.
	 *
	 */
	int (*get_scanout_position) (struct drm_device *dev, unsigned int pipe,
				     unsigned int flags, int *vpos, int *hpos,
				     ktime_t *stime, ktime_t *etime,
				     const struct drm_display_mode *mode);

	/**
	 * Called by \c drm_get_last_vbltimestamp. Should return a precise
	 * timestamp when the most recent VBLANK interval ended or will end.
	 *
	 * Specifically, the timestamp in @@vblank_time should correspond as
	 * closely as possible to the time when the first video scanline of
	 * the video frame after the end of VBLANK will start scanning out,
	 * the time immediately after end of the VBLANK interval. If the
	 * @@crtc is currently inside VBLANK, this will be a time in the future.
	 * If the @@crtc is currently scanning out a frame, this will be the
	 * past start time of the current scanout. This is meant to adhere
	 * to the OpenML OML_sync_control extension specification.
	 *
	 * \param dev dev DRM device handle.
	 * \param pipe crtc for which timestamp should be returned.
	 * \param *max_error Maximum allowable timestamp error in nanoseconds.
	 *                   Implementation should strive to provide timestamp
	 *                   with an error of at most *max_error nanoseconds.
	 *                   Returns true upper bound on error for timestamp.
	 * \param *vblank_time Target location for returned vblank timestamp.
	 * \param flags 0 = Defaults, no special treatment needed.
	 * \param       DRM_CALLED_FROM_VBLIRQ = Function is called from vblank
	 *	        irq handler. Some drivers need to apply some workarounds
	 *              for gpu-specific vblank irq quirks if flag is set.
	 *
	 * \returns
	 * Zero if timestamping isn't supported in current display mode or a
	 * negative number on failure. A positive status code on success,
	 * which describes how the vblank_time timestamp was computed.
	 */
	int (*get_vblank_timestamp) (struct drm_device *dev, unsigned int pipe,
				     int *max_error,
				     struct timeval *vblank_time,
				     unsigned flags);

	/**
	 * Driver-specific constructor for drm_gem_objects, to set up
	 * obj->driver_private.
	 *
	 * Returns 0 on success.
	 */
	void (*gem_free_object) (struct drm_gem_object *obj);
	int (*gem_open_object) (struct drm_gem_object *, struct drm_file *);
	void (*gem_close_object) (struct drm_gem_object *, struct drm_file *);

	int	(*gem_fault)(struct drm_gem_object *, struct uvm_faultinfo *,
		    off_t, vaddr_t, vm_page_t *, int, int, vm_prot_t, int);

	int	(*dumb_create)(struct drm_file *file_priv,
		    struct drm_device *dev, struct drm_mode_create_dumb *args);
	int	(*dumb_map_offset)(struct drm_file *file_priv,
		    struct drm_device *dev, uint32_t handle, uint64_t *offset);
	int	(*dumb_destroy)(struct drm_file *file_priv,
		    struct drm_device *dev, uint32_t handle);

	size_t	gem_size;
	size_t	buf_priv_size;
	size_t	file_priv_size;

	int	major;
	int	minor;
	int	patchlevel;
	const char *name;		/* Simple driver name		   */
	const char *desc;		/* Longer driver name		   */
	const char *date;		/* Date of last major changes.	   */

	u32 driver_features;
	const struct drm_ioctl_desc *ioctls;
	int num_ioctls;

};

enum drm_minor_type {
	DRM_MINOR_LEGACY,
	DRM_MINOR_CONTROL,
	DRM_MINOR_RENDER,
	DRM_MINOR_CNT,
};

#include "drm_crtc.h"

#if 0
/* mode specified on the command line */
struct drm_cmdline_mode {
	bool specified;
	bool refresh_specified;
	bool bpp_specified;
	int xres, yres;
	int bpp;
	int refresh;
	bool rb;
	bool interlace;
	bool cvt;
	bool margins;
	enum drm_connector_force force;
};
#endif

struct drm_minor;

struct drm_pending_vblank_event {
	struct drm_pending_event base;
	int pipe;
	struct drm_event_vblank event;
};

struct drm_vblank_crtc {
	struct drm_device *dev;		/* pointer to the drm_device */
	wait_queue_head_t queue;	/**< VBLANK wait queue */
	struct timeout disable_timer;		/* delayed disable timer */

	/* vblank counter, protected by dev->vblank_time_lock for writes */
	u32 count;
	/* vblank timestamps, protected by dev->vblank_time_lock for writes */
	struct timeval time[DRM_VBLANKTIME_RBSIZE];

	atomic_t refcount;		/* number of users of vblank interruptsper crtc */
	u32 last;			/* protected by dev->vbl_lock, used */
					/* for wraparound handling */
	u32 last_wait;			/* Last vblank seqno waited per CRTC */
	unsigned int inmodeset;		/* Display driver is setting mode */
	unsigned int pipe;		/* crtc index */
	int framedur_ns;		/* frame/field duration in ns */
	int linedur_ns;			/* line duration in ns */
	bool enabled;			/* so we don't call enable more than
					   once per disable */
};

/** 
 * DRM device functions structure
 */
struct drm_device {
	struct device	 device; /* softc is an extension of struct device */
	struct device	*dev;

	struct drm_driver *driver;

	struct pci_dev	_pdev;
	struct pci_dev	*pdev;
	u_int16_t	 pci_device;
	u_int16_t	 pci_vendor;

	pci_chipset_tag_t		 pc;
	pcitag_t	 		*bridgetag;

	bus_dma_tag_t			dmat;
	bus_space_tag_t			bst;

	struct mutex	quiesce_mtx;
	int		quiesce;
	int		quiesce_count;

	char		  *unique;	/* Unique identifier: e.g., busid  */
	int		  unique_len;	/* Length of unique field	   */
	
	int		  if_version;	/* Highest interface version set */
				/* Locks */
	struct rwlock	  struct_mutex;	/* protects everything else */

				/* Usage Counters */
	int		  open_count;	/* Outstanding files open	   */

				/* Authentication */
	SPLAY_HEAD(drm_file_tree, drm_file)	files;
	drm_magic_t	  magicid;

				/* Context support */

	/** \name VBLANK IRQ support */
	/*@@{ */
	bool irq_enabled;
	int irq;

	/*
	 * At load time, disabling the vblank interrupt won't be allowed since
	 * old clients may not call the modeset ioctl and therefore misbehave.
	 * Once the modeset ioctl *has* been called though, we can safely
	 * disable them when unused.
	 */
	bool vblank_disable_allowed;

	/*
	 * If true, vblank interrupt will be disabled immediately when the
	 * refcount drops to zero, as opposed to via the vblank disable
	 * timer.
	 * This can be set to true it the hardware has a working vblank
	 * counter and the driver uses drm_vblank_on() and drm_vblank_off()
	 * appropriately.
	 */
	bool vblank_disable_immediate;

	/* array of size num_crtcs */
	struct drm_vblank_crtc *vblank;

	struct mutex vblank_time_lock;    /**< Protects vblank count and time updates during vblank enable/disable */
	struct mutex vbl_lock;

	u32 max_vblank_count;           /**< size of vblank counter register */

	/**
	 * List of events
	 */
	struct list_head vblank_event_list;
	spinlock_t event_lock;

	/*@@} */

	int			*vblank_enabled;
	int			*vblank_inmodeset;
	u32			*last_vblank_wait;

	int			 num_crtcs;

	pid_t			 buf_pgid;

	struct drm_agp_head	*agp;
	void			*dev_private;
	struct address_space	*dev_mapping;
	struct drm_local_map	*agp_buffer_map;

	struct drm_mode_config	 mode_config; /* Current mode config */

	/* GEM info */
	atomic_t		 obj_count;
	u_int			 obj_name;
	atomic_t		 obj_memory;
	struct pool				objpl;

	/** \name GEM information */
	/*@@{ */
	struct rwlock object_name_lock;
	struct idr object_name_idr;
	struct drm_vma_offset_manager *vma_offset_manager;
	/*@@} */
};

struct drm_attach_args {
	struct drm_driver		*driver;
	char				*busid;
	bus_dma_tag_t			 dmat;
	bus_space_tag_t			 bst;
	size_t				 busid_len;
	int				 is_agp;
	u_int16_t			 pci_vendor;
	u_int16_t			 pci_device;
	u_int16_t			 pci_subvendor;
	u_int16_t			 pci_subdevice;
	u_int8_t			 pci_revision;
	struct pci_attach_args		*pa;
	pci_chipset_tag_t		 pc;
	pcitag_t			 tag;
	pcitag_t			*bridgetag;
	int				 console;
};

#define DRMDEVCF_CONSOLE	0
#define drmdevcf_console	cf_loc[DRMDEVCF_CONSOLE]
/* spec'd as console? */
#define DRMDEVCF_CONSOLE_UNK	-1

extern int	drm_debug_flag;

/* Device setup support (drm_drv.c) */
int	drm_pciprobe(struct pci_attach_args *, const struct drm_pcidev * );
struct device	*drm_attach_pci(struct drm_driver *, 
		     struct pci_attach_args *, int, int, struct device *);
dev_type_ioctl(drmioctl);
dev_type_read(drmread);
dev_type_poll(drmpoll);
dev_type_open(drmopen);
dev_type_close(drmclose);
dev_type_mmap(drmmmap);
struct drm_local_map	*drm_getsarea(struct drm_device *);
struct drm_dmamem	*drm_dmamem_alloc(bus_dma_tag_t, bus_size_t, bus_size_t,
			     int, bus_size_t, int, int);
void			 drm_dmamem_free(bus_dma_tag_t, struct drm_dmamem *);

const struct drm_pcidev	*drm_find_description(int , int ,
			     const struct drm_pcidev *);
int	 drm_order(unsigned long);

/* File operations helpers (drm_fops.c) */
struct drm_file	*drm_find_file_by_minor(struct drm_device *, int);
struct drm_device *drm_get_device_from_kdev(dev_t);

/* Memory management support (drm_memory.c) */
void	*drm_alloc(size_t);
void	*drm_calloc(size_t, size_t);
void	*drm_realloc(void *, size_t, size_t);
void	 drm_free(void *);

#include "drm_mem_util.h"

/* XXX until we get PAT support */
#define drm_core_ioremap_wc drm_core_ioremap
void	drm_core_ioremap(struct drm_local_map *, struct drm_device *);
void	drm_core_ioremapfree(struct drm_local_map *, struct drm_device *);

int	drm_mtrr_add(unsigned long, size_t, int);
int	drm_mtrr_del(int, unsigned long, size_t, int);

/* Misc. IOCTL support (drm_ioctl.c) */
int drm_noop(struct drm_device *dev, void *data,
	     struct drm_file *file_priv);
int drm_invalid_op(struct drm_device *dev, void *data,
		   struct drm_file *file_priv);

/* Cache management (drm_cache.c) */
void drm_clflush_pages(struct vm_page *pages[], unsigned long num_pages);
void drm_clflush_sg(struct sg_table *st);
void drm_clflush_virt_range(void *addr, unsigned long length);

/*
 * These are exported to drivers so that they can implement fencing using
 * DMA quiscent + idle. DMA quiescent usually requires the hardware lock.
 */

				/* IRQ support (drm_irq.h) */
extern int drm_irq_install(struct drm_device *dev, int irq);
extern int drm_irq_uninstall(struct drm_device *dev);

extern int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs);
extern int drm_wait_vblank(struct drm_device *dev, void *data,
			   struct drm_file *filp);
extern u32 drm_vblank_count(struct drm_device *dev, unsigned int pipe);
extern u32 drm_crtc_vblank_count(struct drm_crtc *crtc);
extern u32 drm_vblank_count_and_time(struct drm_device *dev, unsigned int pipe,
				     struct timeval *vblanktime);
extern u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
					  struct timeval *vblanktime);
extern void drm_send_vblank_event(struct drm_device *dev, unsigned int pipe,
				  struct drm_pending_vblank_event *e);
extern void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
				       struct drm_pending_vblank_event *e);
extern void drm_arm_vblank_event(struct drm_device *dev, unsigned int pipe,
				 struct drm_pending_vblank_event *e);
extern void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
				      struct drm_pending_vblank_event *e);
extern bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe);
extern bool drm_crtc_handle_vblank(struct drm_crtc *crtc);
extern int drm_vblank_get(struct drm_device *dev, unsigned int pipe);
extern void drm_vblank_put(struct drm_device *dev, unsigned int pipe);
extern int drm_crtc_vblank_get(struct drm_crtc *crtc);
extern void drm_crtc_vblank_put(struct drm_crtc *crtc);
extern void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe);
extern void drm_crtc_wait_one_vblank(struct drm_crtc *crtc);
extern void drm_vblank_off(struct drm_device *dev, unsigned int pipe);
extern void drm_vblank_on(struct drm_device *dev, unsigned int pipe);
extern void drm_crtc_vblank_off(struct drm_crtc *crtc);
extern void drm_crtc_vblank_reset(struct drm_crtc *crtc);
extern void drm_crtc_vblank_on(struct drm_crtc *crtc);
extern void drm_vblank_cleanup(struct drm_device *dev);
extern u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe);

extern int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
						 unsigned int pipe, int *max_error,
						 struct timeval *vblank_time,
						 unsigned flags,
						 const struct drm_display_mode *mode);
extern void drm_calc_timestamping_constants(struct drm_crtc *crtc,
					    const struct drm_display_mode *mode);

/**
 * drm_crtc_vblank_waitqueue - get vblank waitqueue for the CRTC
 * @@crtc: which CRTC's vblank waitqueue to retrieve
 *
 * This function returns a pointer to the vblank waitqueue for the CRTC.
 * Drivers can use this to implement vblank waits using wait_event() & co.
 */
static inline wait_queue_head_t *drm_crtc_vblank_waitqueue(struct drm_crtc *crtc)
{
	return &crtc->dev->vblank[drm_crtc_index(crtc)].queue;
}

/* Modesetting support */
extern void drm_vblank_pre_modeset(struct drm_device *dev, unsigned int pipe);
extern void drm_vblank_post_modeset(struct drm_device *dev, unsigned int pipe);

bool	drm_mode_parse_command_line_for_connector(const char *,
	    struct drm_connector *, struct drm_cmdline_mode *);
struct drm_display_mode *
	 drm_mode_create_from_cmdline_mode(struct drm_device *,
	     struct drm_cmdline_mode *);

extern unsigned int drm_timestamp_monotonic;

/* AGP/PCI Express/GART support (drm_agpsupport.c) */
struct drm_agp_head *drm_agp_init(void);
void	drm_agp_takedown(struct drm_device *);
int	drm_agp_acquire(struct drm_device *);
int	drm_agp_release(struct drm_device *);
int	drm_agp_info(struct drm_device *, struct drm_agp_info *);
int	drm_agp_enable(struct drm_device *, struct drm_agp_mode);
void	*drm_agp_allocate_memory(size_t, u32);
int	drm_agp_free_memory(void *);
int	drm_agp_bind_memory(void *, off_t);
int	drm_agp_unbind_memory(void *);
int	drm_agp_alloc(struct drm_device *, struct drm_agp_buffer *);
int	drm_agp_free(struct drm_device *, struct drm_agp_buffer *);
int	drm_agp_bind(struct drm_device *, struct drm_agp_binding *);
int	drm_agp_unbind(struct drm_device *, struct drm_agp_binding *);

/* AGP/GART support (drm_agpsupport.c) */
int	drm_agp_acquire_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_release_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_enable_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_info_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_alloc_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_free_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_unbind_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_agp_bind_ioctl(struct drm_device *, void *, struct drm_file *);

static inline int
drm_sysfs_connector_add(struct drm_connector *connector)
{
	return 0;
}

static inline void
drm_sysfs_connector_remove(struct drm_connector *connector)
{
}

static inline void
drm_sysfs_hotplug_event(struct drm_device *dev)
{
}

/* Graphics Execution Manager library functions (drm_gem.c) */
int drm_gem_init(struct drm_device *dev);
void drm_gem_destroy(struct drm_device *dev);
void drm_gem_object_release(struct drm_gem_object *obj);
void drm_gem_object_free(struct kref *kref);
int drm_gem_object_init(struct drm_device *dev,
			struct drm_gem_object *obj, size_t size);
void drm_gem_private_object_init(struct drm_device *dev,
				 struct drm_gem_object *obj, size_t size);

int drm_gem_handle_create_tail(struct drm_file *file_priv,
			       struct drm_gem_object *obj,
			       u32 *handlep);
int drm_gem_handle_create(struct drm_file *file_priv,
			  struct drm_gem_object *obj,
			  u32 *handlep);
int drm_gem_handle_delete(struct drm_file *filp, u32 handle);

void drm_gem_free_mmap_offset(struct drm_gem_object *obj);
int drm_gem_create_mmap_offset(struct drm_gem_object *obj);

struct drm_gem_object *drm_gem_object_lookup(struct drm_device *dev,
					     struct drm_file *filp,
					     u32 handle);
struct drm_gem_object *drm_gem_object_find(struct drm_file *, u32);
int drm_gem_close_ioctl(struct drm_device *dev, void *data,
			struct drm_file *file_priv);
int drm_gem_flink_ioctl(struct drm_device *dev, void *data,
			struct drm_file *file_priv);
int drm_gem_open_ioctl(struct drm_device *dev, void *data,
		       struct drm_file *file_priv);
void drm_gem_open(struct drm_device *dev, struct drm_file *file_private);
void drm_gem_release(struct drm_device *dev,struct drm_file *file_private);

static __inline void
drm_gem_object_reference(struct drm_gem_object *obj)
{
	kref_get(&obj->refcount);
}

static __inline void
drm_gem_object_unreference(struct drm_gem_object *obj)
{
	if (obj != NULL)
		kref_put(&obj->refcount, drm_gem_object_free);
}

static __inline void
drm_gem_object_unreference_unlocked(struct drm_gem_object *obj)
{
	if (obj && !atomic_add_unless(&obj->refcount.refcount, -1, 1)) {
		struct drm_device *dev = obj->dev;

		mutex_lock(&dev->struct_mutex);
		if (likely(atomic_dec_and_test(&obj->refcount.refcount)))
			drm_gem_object_free(&obj->refcount);
		mutex_unlock(&dev->struct_mutex);
	}
}

int drm_gem_dumb_destroy(struct drm_file *file,
			 struct drm_device *dev,
			 uint32_t handle);

static __inline__ int drm_core_check_feature(struct drm_device *dev,
					     int feature)
{
	return ((dev->driver->driver_features & feature) ? 1 : 0);
}

static inline bool drm_is_render_client(const struct drm_file *file_priv)
{
#ifdef notyet
	return file_priv->minor->type == DRM_MINOR_RENDER;
#else
	return 0;
#endif
}

static inline bool drm_is_control_client(const struct drm_file *file_priv)
{
#ifdef notyet
	return file_priv->minor->type == DRM_MINOR_CONTROL;
#else
	return 0;
#endif
}

static inline bool drm_is_primary_client(const struct drm_file *file_priv)
{
#ifdef notyet
	return file_priv->minor->type == DRM_MINOR_LEGACY;
#else
	return 1;
#endif
}

static inline int drm_dev_to_irq(struct drm_device *dev)
{
	return -1;
}

#define DRM_PCIE_SPEED_25 1
#define DRM_PCIE_SPEED_50 2
#define DRM_PCIE_SPEED_80 4

int	 drm_pcie_get_speed_cap_mask(struct drm_device *, u32 *);

#endif /* __KERNEL__ */
#endif /* _DRM_P_H_ */
@


1.211
log
@Fix another ;; in sys/dev
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.210 2017/05/25 03:19:39 dlg Exp $ */
d70 2
d76 1
d78 1
a78 1
#include "drm_atomic.h"
d81 8
d104 1
d176 1
d198 1
a198 1
	if (in_atomic() || in_dbg_master() || irqs_disabled())
d270 13
d357 7
d385 4
d491 1
a491 1
#define DRM_VBLANKTIME_INVBL             (1 << 1)
d495 1
a495 1
#define DRM_SCANOUTPOS_INVBL        (1 << 1)
d498 1
a498 1
struct drm_driver_info {
d514 116
a629 7
	u_int32_t (*get_vblank_counter)(struct drm_device *, int);
	int	(*enable_vblank)(struct drm_device *, int);
	void	(*disable_vblank)(struct drm_device *, int);
	int	(*get_scanout_position)(struct drm_device *, int,
		    unsigned int, int *, int *, ktime_t *, ktime_t *);
	int	(*get_vblank_timestamp)(struct drm_device *, int, int *,
		    struct timeval *, unsigned);
d668 7
d677 1
d692 3
d703 1
d705 7
a711 2
	struct timeval time[DRM_VBLANKTIME_RBSIZE];	/**< timestamp of current count */
	atomic_t count;			/**< number of VBLANK interrupts */
d717 3
d728 2
a729 1
	struct device	  device; /* softc is an extension of struct device */
d731 1
a731 1
	struct drm_driver_info *driver;
a762 1
	int		  irq_enabled;	/* True if the irq handler is enabled */
d766 2
d777 10
a791 1
	struct timeout vblank_disable_timer;
d833 1
a833 1
	struct drm_driver_info		*driver;
d843 2
d860 1
a860 1
struct device	*drm_attach_pci(struct drm_driver_info *, 
d897 53
a949 18
/* IRQ support (drm_irq.c) */
int	drm_irq_install(struct drm_device *);
int	drm_irq_uninstall(struct drm_device *);
void	drm_vblank_cleanup(struct drm_device *);
u32	drm_get_last_vbltimestamp(struct drm_device *, int ,
				  struct timeval *, unsigned);
int	drm_vblank_init(struct drm_device *, int);
u_int32_t drm_vblank_count(struct drm_device *, int);
u_int32_t drm_vblank_count_and_time(struct drm_device *, int, struct timeval *);
int	drm_vblank_get(struct drm_device *, int);
void	drm_vblank_put(struct drm_device *, int);
void	drm_vblank_off(struct drm_device *, int);
void	drm_vblank_pre_modeset(struct drm_device *, int);
void	drm_vblank_post_modeset(struct drm_device *, int);
int	drm_modeset_ctl(struct drm_device *, void *, struct drm_file *);
bool	drm_handle_vblank(struct drm_device *, int);
void	drm_calc_timestamping_constants(struct drm_crtc *,
	    const struct drm_display_mode *);
d951 1
a951 1
						 int crtc, int *max_error,
a953 1
						 const struct drm_crtc *refcrtc,
d955 19
a997 7
/* IRQ support (drm_irq.c) */
int	drm_control(struct drm_device *, void *, struct drm_file *);
int	drm_wait_vblank(struct drm_device *, void *, struct drm_file *);
int	drm_irq_by_busid(struct drm_device *, void *, struct drm_file *);
void	drm_send_vblank_event(struct drm_device *, int,
	    struct drm_pending_vblank_event *);

d1092 27
@


1.210
log
@tweak sparc64 membars as a step toward making them usable in userland.

specifically, dont rely on magic in ctlreg to implement membars. moving
that to atomic.h would add a lot of pollution to the namespace, so
move to passing the membar options to a single __membar macro.

this tweaks everything that was using the ctlreg backend to either use
an appropriate membar_foo(), or to use __membar() in the MD code.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.209 2016/10/08 05:52:06 guenther Exp $ */
d483 1
a483 1
		    struct timeval *, unsigned);;
@


1.209
log
@Various printf claim to report the PID, so actually report that and not the TID

ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.208 2016/04/08 08:27:53 kettenis Exp $ */
d161 1
a161 1
#define DRM_MEMORYBARRIER()		membar(Sync)
@


1.208
log
@Get rid of some infrastrcuture that is now obsolete and synchronize some of
the data structures in drmP.h with Linux 3.14.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.207 2016/04/07 20:33:24 kettenis Exp $ */
d103 1
a103 1
#define DRM_CURRENTPID		curproc->p_pid
d203 1
a203 1
	    curproc->p_pid, __func__ , ## arg)
d218 2
a219 2
		printf("[" DRM_NAME ":pid%d:%s] " fmt, curproc->p_pid,	\
			__func__ , ## arg);				\
d229 2
a230 2
		printf("[" DRM_NAME ":pid%d:%s] " fmt, curproc->p_pid,	\
			__func__ , ## arg);				\
d250 2
a251 2
		printf("[" DRM_NAME ":pid%d:%s] " fmt, curproc->p_pid,	\
			__func__ , ## arg);				\
@


1.207
log
@Retry the drm_crtc.c "idr"conversion.  Turns out the xf86-video-intel driver
is buggy and trucates the ids to 8 bits.  So specifymaximum in the idr_alloc()
call until that gets fixed.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.206 2016/04/06 21:12:40 kettenis Exp $ */
d78 16
a305 12
struct drm_buf {
	int		  idx;	       /* Index into master buflist	     */
	int		  total;       /* Buffer size			     */
	int		  used;	       /* Amount of buffer in use (for DMA)  */
	unsigned long	  offset;      /* Byte offset (used internally)	     */
	void 		  *address;    /* KVA of buffer			     */
	unsigned long	  bus_address; /* Bus address of buffer		     */
	__volatile__ int  pending;     /* On hardware DMA queue		     */
	struct drm_file   *file_priv;  /* Unique identifier of holding process */
	void		  *dev_private;  /* Per-buffer private storage       */
};

a314 9
struct drm_buf_entry {
	struct drm_dmamem	**seglist;
	struct drm_buf		*buflist;
	int			 buf_count;
	int			 buf_size;
	int			 page_order;
	int			 seg_count;
};

d324 1
d326 5
a330 3
	wait_queue_head_t event_wait;
	struct list_head event_list;
	int event_space;
d332 2
a333 13
	struct selinfo				 rsel;
	SPLAY_ENTRY(drm_file)			 link;
	int					 authenticated;
	/* true when the client has asked us to expose stereo 3D mode flags */
	int					 stereo_allowed;
	unsigned long				 ioctl_count;
	dev_t					 kdev;
	drm_magic_t				 magic;
	int					 flags;
	int					 master;
	int					 minor;
	struct list_head			 fbs;
	struct rwlock				 fbs_lock;
a341 1
};
d343 15
a357 28
/* This structure, in the struct drm_device, is always initialized while
 * the device is open.  dev->dma_lock protects the incrementing of
 * dev->buf_use, which when set marks that no further bufs may be allocated
 * until device teardown occurs (when the last open of the device has closed).
 * The high/low watermarks of bufs are only touched by the X Server, and thus
 * not concurrently accessed, so no locking is needed.
 */
struct drm_device_dma {
	struct rwlock	 	 dma_lock;
	struct drm_buf_entry	 bufs[DRM_MAX_ORDER+1];
	struct drm_buf		**buflist;	/* Vector of pointers info bufs*/
	unsigned long		*pagelist;
	unsigned long		 byte_count;
	int			 buf_use;	/* Buffers used no more alloc */
	int			 buf_count;
	int			 page_count;
	int			 seg_count;
	enum {
		_DRM_DMA_USE_AGP = 0x01,
		_DRM_DMA_USE_SG  = 0x02
	} flags;
};

struct drm_agp_mem {
	void               *handle;
	unsigned long      bound; /* address */
	int                pages;
	TAILQ_ENTRY(drm_agp_mem) link;
a373 24
struct drm_local_map {
	TAILQ_ENTRY(drm_local_map)	 link;	/* Link for map list */
	struct drm_dmamem		*dmamem;/* Handle to DMA mem */
	void				*handle;/* KVA, if mapped */
	bus_space_tag_t			 bst;	/* Tag for mapped pci mem */
	bus_space_handle_t		 bsh;	/* Handle to mapped pci mem */
	u_long				 ext;	/* extent for mmap */
	u_long				 offset;/* Physical address */
	u_long				 size;	/* Physical size (bytes) */
	int				 mtrr;	/* Boolean: MTRR used */
	enum drm_map_flags		 flags;	/* Flags */
	enum drm_map_type		 type;	/* Type of memory mapped */
};

/* Heap implementation for radeon and i915 legacy */
TAILQ_HEAD(drm_heap, drm_mem);

struct drm_mem {
	TAILQ_ENTRY(drm_mem)	 link;
	struct drm_file		*file_priv; /* NULL: free, other: real files */
	int			 start;
	int			 size;
};

d516 1
a519 13
#define DRIVER_AGP		0x1
#define DRIVER_AGP_REQUIRE	0x2
#define DRIVER_PCI_DMA     0x8
#define DRIVER_SG          0x10
#define DRIVER_HAVE_DMA    0x20
#define DRIVER_HAVE_IRQ    0x40
#define DRIVER_IRQ_SHARED  0x80
#define DRIVER_GEM         0x1000
#define DRIVER_MODESET     0x2000
#define DRIVER_PRIME	   0x4000

	u_int	flags;
#define driver_features flags
a594 7
	/* Linked list of mappable regions. Protected by struct_mutex */
	struct extent				*handle_ext;
	TAILQ_HEAD(drm_map_list, drm_local_map)	 maplist;

				/* DMA queues (contexts) */
	struct drm_device_dma  *dma;		/* Optional pointer for DMA support */

d866 1
a866 1
	return ((dev->driver->flags & feature) ? 1 : 0);
@


1.206
log
@Revert the drm_crt.c "idr" conversion as it breaks X on (at least) the T430s.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.205 2016/04/06 14:58:43 kettenis Exp $ */
a494 6
};

struct drm_mode_handle {
	SPLAY_ENTRY(drm_mode_handle) entry;
	struct drm_mode_object	*obj;
	uint32_t		 handle;
@


1.205
log
@Remove some pre-idr leftovers.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.204 2016/04/05 20:46:45 kettenis Exp $ */
d495 6
@


1.204
log
@Now that we the "idr" API, we can get rid of a lot of

#ifdef __linux__
...
#else
...
#endif

code in the generic drm GEM code.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.203 2016/04/05 20:40:54 kettenis Exp $ */
a494 12
};

struct drm_handle {
	SPLAY_ENTRY(drm_handle)	 entry;
	struct drm_gem_object	*obj;
	uint32_t		 handle;
};

struct drm_mode_handle {
	SPLAY_ENTRY(drm_mode_handle) entry;
	struct drm_mode_object	*obj;
	uint32_t		 handle;
@


1.203
log
@Remove completely out-of-date comment about locking protocol.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.202 2016/04/05 08:22:50 kettenis Exp $ */
a329 2
	SPLAY_HEAD(drm_obj_tree, drm_handle)	 obj_tree;

a333 1
	struct mutex				 table_lock;
a344 1
	u_int					 obj_id; /*next gem id*/
d348 5
a726 1
	SPLAY_HEAD(drm_name_tree, drm_gem_object) name_tree;
a727 2
	
	/* mode stuff */
d732 1
@


1.202
log
@Split out the generic GEM code (like Linux did) and switch it over to
the vma offset manager.  This brings us a little bit more isolation between
applications as GEM buffers are now tied to a specific /dev/drmX clone.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.201 2016/02/05 10:05:12 kettenis Exp $ */
a431 17

/*
 *  Locking protocol:
 * All drm object are uvm objects, as such they have a reference count and
 * a lock. On the other hand, operations carries out by the drm may involve
 * sleeping (waiting for rendering to finish, say), while you wish to have
 * mutual exclusion on an object. For this reason, all drm-related operations
 * on drm objects must acquire the DRM_BUSY flag on the object as the first
 * thing that they do. If the BUSY flag is already on the object, set DRM_WANTED
 * and sleep until the other locker is done with it. When the BUSY flag is 
 * acquired then only that flag and a reference is required to do most 
 * operations on the drm_object. The uvm object is still bound by uvm locking
 * protocol.
 *
 * Subdrivers (radeon, intel, etc) may have other locking requirement, these
 * requirements will be detailed in those drivers.
 */
@


1.201
log
@Improve Linux PCI compatibility code.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.200 2015/11/22 15:35:49 kettenis Exp $ */
d73 1
d351 3
a353 1
	void					*driver_priv;
d449 5
d455 13
a467 15
	struct uvm_object		 uobj;
	SPLAY_ENTRY(drm_gem_object) 	 entry;
	struct drm_device		*dev;
	struct uvm_object		*uao;
	struct drm_local_map		*map;

	size_t				 size;
	int				 name;
	int				 handlecount;
/* any flags over 0x00000010 are device specific */
#define	DRM_BUSY	0x00000001
#define	DRM_WANTED	0x00000002
	u_int				 do_flags;
	uint32_t			 read_domains;
	uint32_t			 write_domain;
d469 42
a510 2
	uint32_t			 pending_read_domains;
	uint32_t			 pending_write_domain;
d607 1
d610 1
d734 1
a739 1
	struct mutex		 obj_name_lock;
d747 6
d800 1
d900 2
d903 1
d906 2
d909 3
a911 3
void	 drm_unref(struct uvm_object *);
void	 drm_ref(struct uvm_object *);

d924 8
a931 3
int	drm_gem_close_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_gem_flink_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_gem_open_ioctl(struct drm_device *, void *, struct drm_file *);
d936 1
a936 1
	drm_ref(&obj->uobj);
d942 2
a943 1
	drm_unref(&obj->uobj);
d949 2
a950 1
	struct drm_device *dev = obj->dev;
d952 5
a956 3
	mutex_lock(&dev->struct_mutex);
	drm_unref(&obj->uobj);
	mutex_unlock(&dev->struct_mutex);
@


1.200
log
@Remove drm_gem_object_alloc() and associated infrastructure.  It's unused and
has been removed upstream as well.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.199 2015/11/21 15:23:44 kettenis Exp $ */
d609 1
a609 1
	struct pci_dev	 drm_pci;
@


1.199
log
@The drm irq stuff isn't actually used on OpenBSD.  Using the PCI device
interrupt line register as the irq number doesn't really work as the contents
of that register might be 0, and the code has checks for non-zero irq
numbers in places.  Insteadmake drm_dev_to_irq() return -1, which is an
obviously bogus, but non-zero value.

This should fix inteldrm(4) on recent Apple hardware.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.198 2015/09/26 19:52:16 kettenis Exp $ */
a523 1
	int (*gem_init_object) (struct drm_gem_object *obj);
a845 2
struct drm_gem_object *drm_gem_object_alloc(struct drm_device *dev,
					    size_t size);
@


1.198
log
@Update drm_irq.c to the version from Linux 3.14.52.
Disable the DRM_IOCTL_IRQ_BUSID and DRM_IOCTL_CONTROL ioctls.
These are legacy ioctls for DRI1 support, which we no longer support on
OpenBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.197 2015/09/23 23:12:11 kettenis Exp $ */
a646 1
	int		  irq;		/* Interrupt used by board	   */
a708 1
	u_int8_t			 irq;
d905 1
a905 1
	return dev->irq;
@


1.197
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.196 2015/05/30 18:09:26 jsg Exp $ */
d176 7
a182 10
#define DRM_WAIT_ON(ret, queue, lock,  timeout, msg, condition ) do {	\
	mtx_enter(lock);						\
	while ((ret) == 0) {						\
		if (condition)						\
			break;						\
		ret = msleep((queue), (lock), PZERO | PCATCH,		\
		    (msg), (timeout));					\
	}								\
	mtx_leave(lock);						\
} while (/* CONSTCOND */ 0)
d320 6
a325 5
	TAILQ_ENTRY(drm_pending_event)	 link;
	struct drm_event		*event;
	struct drm_file			*file_priv;
	pid_t				 pid;
	void				(*destroy)(struct drm_pending_event *);
d328 2
a329 5
struct drm_pending_vblank_event {
	struct drm_pending_event	base;
	int				pipe;
	struct drm_event_vblank		event;
};
d331 3
a333 1
TAILQ_HEAD(drmevlist, drm_pending_event);
a334 3
struct drm_file {
	SPLAY_HEAD(drm_obj_tree, drm_handle)	 obj_tree;
	struct drmevlist			 evlist;
a343 1
	int					 event_space;
d555 7
a561 7
#define DRIVER_MTRR		0x4
#define DRIVER_DMA		0x8
#define DRIVER_PCI_DMA		0x10
#define DRIVER_SG		0x20
#define DRIVER_IRQ		0x40
#define DRIVER_GEM		0x80
#define DRIVER_MODESET		0x100
d583 19
d650 27
a676 14
	/* VBLANK support */
	struct drmevlist	vbl_events;		/* vblank events */
	int			 vblank_disable_allowed;
	/**< size of vblank counter register */
	uint32_t		 max_vblank_count;
	struct mutex		 event_lock;

	wait_queue_head_t	*vbl_queue;
	atomic_t		*_vblank_count;
	struct timeval		*_vblank_time;
	struct mutex		 vblank_time_lock;
	struct mutex		 vbl_lock;
	atomic_t		*vblank_refcount;
	uint32_t		*last_vblank;
a680 1
	struct timeout		 vblank_disable_timer;
d903 5
@


1.196
log
@DRMDEBUG not DRM_DEBUG.  From frantisek holop.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.195 2015/04/18 14:47:34 jsg Exp $ */
d40 1
d97 1
a97 1
#define drm_msleep(x, msg)	mdelay(x)
d194 1
d197 1
d275 1
d345 2
d356 1
d505 2
d511 1
a511 1
	int	(*irq_handler)(void *);
d520 2
a521 1
	int	(*get_scanout_position)(struct drm_device *, int, int *, int *);
d557 1
a557 1
	struct drm_ioctl_desc *ioctls;
d692 1
d758 8
a765 3
void	drm_calc_timestamping_constants(struct drm_crtc *);
int	drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *,
	    int, int *, struct timeval *, unsigned, struct drm_crtc *);
d844 1
d870 4
@


1.195
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.194 2015/04/17 00:54:41 jsg Exp $ */
d191 1
a191 1
#ifdef DRM_DEBUG
@


1.194
log
@Make drm ioctls table driven.  Further reduces the diff to linux.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.193 2015/04/12 11:26:54 jsg Exp $ */
d91 2
@


1.193
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.192 2015/04/12 03:54:10 jsg Exp $ */
d251 35
a494 2
	int	(*ioctl)(struct drm_device*, u_long, caddr_t,
		    struct drm_file *);
d544 3
@


1.192
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.191 2015/04/11 04:36:10 jsg Exp $ */
d91 2
@


1.191
log
@change back to drm_free_large/drm_malloc_ab
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.190 2015/04/10 12:06:52 jsg Exp $ */
d595 1
a595 1
	int			*vbl_queue;
@


1.190
log
@Move irqs_disabled() and in_dbg_master() out of the i386/amd64 ifdef block
and change drm_can_sleep() to only use in_atomic() on i386/amd64 as
it isn't defined for other archs currently.  Unbreaks the sparc64 build.
Found the hard way by benoit@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.189 2015/04/10 06:00:39 jsg Exp $ */
d680 2
@


1.189
log
@Use mdelay(x) instead of delay(x * 1000) for drm_msleep() to better
deal with long delays.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.188 2015/04/10 05:52:09 jsg Exp $ */
d162 1
d164 3
@


1.188
log
@Make drm_can_sleep() match linux.  No change in behaviour as it's
only ever used to decide between mdelay and drm_msleep and our
drm_msleep delays instead of sleeping.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.187 2015/04/10 05:31:25 jsg Exp $ */
d92 1
a92 1
#define drm_msleep(x, msg)	delay(x * 1000)
@


1.187
log
@add irqs_disabled() and in_dbg_master() using cold and db_is_active
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.186 2015/04/06 15:43:15 jsg Exp $ */
d158 8
a165 1
#define	drm_can_sleep()	(hz & 1)
@


1.186
log
@Move almost all of the linux compat from drmP.h to drm_linux.h.
The exception being the barrier defines that are implemented in terms of
DRM_* defines.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.185 2015/04/06 12:25:10 jsg Exp $ */
d56 4
@


1.185
log
@move some inline linux compat into the dedicated files
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.184 2015/04/06 10:56:37 jsg Exp $ */
a77 6
#if BYTE_ORDER == BIG_ENDIAN
#define __BIG_ENDIAN
#else
#define __LITTLE_ENDIAN
#endif

a87 6
#define PAGE_ALIGN(addr)	(((addr) + PAGE_MASK) & ~PAGE_MASK)
#define roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
#define jiffies_to_msecs(x)	(((int64_t)(x)) * 1000 / hz)
#define msecs_to_jiffies(x)	(((int64_t)(x)) * hz / 1000)
#define time_after(a,b)		((long)(b) - (long)(a) < 0)
#define time_after_eq(a,b)	((long)(b) - (long)(a) <= 0)
a101 20
/* linux compat */
typedef u_int64_t u64;
typedef u_int32_t u32;
typedef u_int16_t u16;
typedef u_int8_t u8;

typedef int32_t s32;
typedef int64_t s64;

typedef uint16_t __le16;
typedef uint16_t __be16;
typedef uint32_t __le32;
typedef uint32_t __be32;

#define EXPORT_SYMBOL(x)
#define MODULE_FIRMWARE(x)
#define __iomem
#define __must_check
#define __init
#define ARRAY_SIZE nitems
a102 156
#define DIV_ROUND_UP(x, y)	(((x) + ((y) - 1)) / (y))
#define DIV_ROUND_CLOSEST(x, y)	(((x) + ((y) / 2)) / (y))

#define ERESTARTSYS EINTR
#define ETIME ETIMEDOUT
#define EREMOTEIO EIO
#define EPROTO EIO
#define ENOTSUPP ENOTSUP

#define unlikely(x)	__builtin_expect(!!(x), 0)
#define likely(x)	__builtin_expect(!!(x), 1)

#define	IS_ALIGNED(x, y)	(((x) & ((y) - 1)) == 0)

#define BUG()								\
do {									\
	panic("BUG at %s:%d", __FILE__, __LINE__);			\
} while (0)

#define BUG_ON(x) KASSERT(!(x))

#define BUILD_BUG_ON(x) CTASSERT(!(x))

#define WARN(condition, fmt...) ({ 					\
	int __ret = !!(condition);					\
	if (__ret)							\
		printf(fmt);						\
	unlikely(__ret);						\
})

#define WARN_ONCE(condition, fmt...) ({					\
	static int __warned;						\
	int __ret = !!(condition);					\
	if (__ret && !__warned) {					\
		printf(fmt);						\
		__warned = 1;						\
	}								\
	unlikely(__ret);						\
})

#define _WARN_STR(x) #x

#define WARN_ON(condition) ({						\
	int __ret = !!(condition);					\
	if (__ret)							\
		printf("WARNING %s failed at %s:%d\n",			\
		    _WARN_STR(condition), __FILE__, __LINE__);		\
	unlikely(__ret);						\
})

#define WARN_ON_ONCE(condition) ({					\
	static int __warned;						\
	int __ret = !!(condition);					\
	if (__ret && !__warned) {					\
		printf("WARNING %s failed at %s:%d\n",			\
		    _WARN_STR(condition), __FILE__, __LINE__);		\
		__warned = 1;						\
	}								\
	unlikely(__ret);						\
})

#define IS_ERR_VALUE(x) unlikely((x) >= (unsigned long)-ELAST)

static inline void *
ERR_PTR(long error)
{
	return (void *) error;
}

static inline long
PTR_ERR(const void *ptr)
{
	return (long) ptr;
}

static inline long
IS_ERR(const void *ptr)
{
        return IS_ERR_VALUE((unsigned long)ptr);
}

static inline long
IS_ERR_OR_NULL(const void *ptr)
{
        return !ptr || IS_ERR_VALUE((unsigned long)ptr);
}

#define container_of(ptr, type, member) ({                      \
	__typeof( ((type *)0)->member ) *__mptr = (ptr);        \
	(type *)( (char *)__mptr - offsetof(type,member) );})

#ifndef __DECONST
#define __DECONST(type, var)    ((type)(__uintptr_t)(const void *)(var))
#endif

#define GFP_ATOMIC	M_NOWAIT
#define GFP_KERNEL	(M_WAITOK | M_CANFAIL)
#define __GFP_NOWARN	0
#define __GFP_NORETRY	0

static inline void *
kmalloc(size_t size, int flags)
{
	return malloc(size, M_DRM, flags);
}

static inline void *
kmalloc_array(size_t n, size_t size, int flags)
{
	if (n == 0 || SIZE_MAX / n < size)
		return NULL;
	return malloc(n * size, M_DRM, flags);
}

static inline void *
kcalloc(size_t n, size_t size, int flags)
{
	if (n == 0 || SIZE_MAX / n < size)
		return NULL;
	return malloc(n * size, M_DRM, flags | M_ZERO);
}

static inline void *
kzalloc(size_t size, int flags)
{
	return malloc(size, M_DRM, flags | M_ZERO);
}

static inline void
kfree(void *objp)
{
	free(objp, M_DRM, 0);
}

static inline void *
vzalloc(unsigned long size)
{
	return malloc(size, M_DRM, M_WAITOK | M_CANFAIL | M_ZERO);
}

static inline void
vfree(void *objp)
{
	free(objp, M_DRM, 0);
}

#define min_t(t, a, b) ({ \
	t __min_a = (a); \
	t __min_b = (b); \
	__min_a < __min_b ? __min_a : __min_b; })

static inline uint64_t
div_u64(uint64_t x, uint32_t y)
{
	return (x / y);
}
a152 27
#define le16_to_cpu(x) letoh16(x)
#define le32_to_cpu(x) letoh32(x)
#define cpu_to_le16(x) htole16(x)
#define cpu_to_le32(x) htole32(x)

#define be32_to_cpup(x) betoh32(*x)

#ifdef __macppc__
static __inline int
of_machine_is_compatible(const char *model)
{
	extern char *hw_prod;
	return (strcmp(model, hw_prod) == 0);
}
#endif

static inline unsigned long
roundup_pow_of_two(unsigned long x)
{
	return (1UL << flsl(x - 1));
}

static inline uint32_t ror32(uint32_t word, unsigned int shift)
{
	return (word >> shift) | (word << (32 - shift));
}

a153 21

static __inline void
udelay(unsigned long usecs)
{
	DELAY(usecs);
}

static __inline void
usleep_range(unsigned long min, unsigned long max)
{
	DELAY(min);
}

static __inline void
mdelay(unsigned long msecs)
{
	int loops = msecs;
	while (loops--)
		DELAY(1000);
}

a220 2
#define PCI_ANY_ID (uint16_t) (~0U)

a375 4
#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : (1ULL<<(n)) -1)
#define lower_32_bits(n)	((u32)(n))
#define upper_32_bits(_val) ((u_int32_t)(((_val) >> 16) >> 16))

a522 7
};

struct pci_dev {
	uint16_t	vendor;
	uint16_t	device;
	uint16_t	subsystem_vendor;
	uint16_t	subsystem_device;
@


1.184
log
@add/use some more errno remapping
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.183 2015/04/06 09:23:19 jsg Exp $ */
a885 38

enum dmi_field {
        DMI_NONE,
        DMI_BIOS_VENDOR,
        DMI_BIOS_VERSION,
        DMI_BIOS_DATE,
        DMI_SYS_VENDOR,
        DMI_PRODUCT_NAME,
        DMI_PRODUCT_VERSION,
        DMI_PRODUCT_SERIAL,
        DMI_PRODUCT_UUID,
        DMI_BOARD_VENDOR,
        DMI_BOARD_NAME,
        DMI_BOARD_VERSION,
        DMI_BOARD_SERIAL,
        DMI_BOARD_ASSET_TAG,
        DMI_CHASSIS_VENDOR,
        DMI_CHASSIS_TYPE,
        DMI_CHASSIS_VERSION,
        DMI_CHASSIS_SERIAL,
        DMI_CHASSIS_ASSET_TAG,
        DMI_STRING_MAX,
};

struct dmi_strmatch {
	unsigned char slot;
	char substr[79];
};

struct dmi_system_id {
        int (*callback)(const struct dmi_system_id *);
        const char *ident;
        struct dmi_strmatch matches[4];
};
#define	DMI_MATCH(a, b) {(a), (b)}
#define	DMI_EXACT_MATCH(a, b) {(a), (b)}
int dmi_check_system(const struct dmi_system_id *);

@


1.183
log
@Add an empty drm_sysfs_hotplug_event() function and use it
and the existing drm_sysfs* functions to remove some ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.182 2015/04/03 13:10:59 jsg Exp $ */
d139 4
@


1.182
log
@resync i915_drv.h to make it diffable to linux
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.181 2015/02/12 08:48:32 jsg Exp $ */
d1025 5
@


1.181
log
@Add and use macros for linux memory barriers.  Fix the call in
i915_gem_object_flush_fence() to be mb() not wmb() while here.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.180 2015/02/11 07:01:36 jsg Exp $ */
d487 1
@


1.180
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.179 2015/02/10 01:39:32 jsg Exp $ */
d326 7
@


1.179
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.178 2014/07/12 18:48:52 tedu Exp $ */
d397 1
d399 3
a444 12

#define dev_warn(dev, fmt, arg...) do {					\
	DRM_ERROR(fmt, ## arg);						\
} while(0)

#define dev_err(dev, fmt, arg...) do {					\
	DRM_ERROR(fmt, ## arg);						\
} while(0)

#define dev_info(dev, fmt, arg...) do {					\
	printf("%s: " fmt, dev.dv_xname, ## arg);			\
} while(0)
@


1.178
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.177 2014/05/24 21:09:15 miod Exp $ */
a87 4
#define DRM_LOCK()		rw_enter_write(&dev->dev_lock)
#define DRM_UNLOCK()		rw_exit_write(&dev->dev_lock)
#define DRM_READLOCK()		rw_enter_read(&dev->dev_lock)
#define DRM_READUNLOCK()	rw_exit_read(&dev->dev_lock)
d798 1
a798 1
	struct rwlock	  dev_lock;	/* protects everything else */
d807 1
a807 1
	/* Linked list of mappable regions. Protected by dev_lock */
d1070 1
a1070 1
	DRM_LOCK();
d1072 1
a1072 1
	DRM_UNLOCK();
@


1.177
log
@Barriers for mips64
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.176 2014/04/07 06:43:11 jsg Exp $ */
d266 1
a266 1
	free(objp, M_DRM);
d278 1
a278 1
	free(objp, M_DRM);
@


1.176
log
@reduce the diff to linux for drm pci vid/pid tests
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.175 2014/04/01 20:16:50 kettenis Exp $ */
d312 4
@


1.175
log
@Move some duplicated code implementing Linux compatibility APIs and stick it
in a seperate header file.  This will become a dumping ground for similar code.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.174 2014/03/26 14:41:41 mpi Exp $ */
d763 7
d778 2
a781 2
	u_int16_t	 pci_subdevice;
	u_int16_t	 pci_subvendor;
@


1.174
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.173 2014/03/25 17:44:39 mpi Exp $ */
d65 1
@


1.173
log
@Remove and shuffle some includes to reduce their number since drmP.h
is included by a lot of files.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.172 2014/03/24 17:06:49 kettenis Exp $ */
d55 1
@


1.172
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.171 2014/03/17 22:01:56 kettenis Exp $ */
d47 1
a48 4
#include <sys/stat.h>
#include <sys/proc.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
a49 4
#include <sys/fcntl.h>
#include <sys/filio.h>
#include <sys/signalvar.h>
#include <sys/poll.h>
a51 1
#include <sys/mman.h>
d55 4
a58 2
#include <sys/vnode.h>
#include <uvm/uvm.h>
a61 1
#include <dev/pci/vga_pcivar.h>
a641 3
#ifdef DRMLOCKDEBUG			/* to tell owner */
	struct proc			*holding_proc;
#endif
@


1.171
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.170 2014/03/13 12:45:04 kettenis Exp $ */
d144 2
a145 1
#define DIV_ROUND_UP howmany
d160 2
@


1.170
log
@Block userland from entering drm code (and make sure it is no longer in there)
before we truly start quiescing the device and don't unblock until we've
finished waking the device up.  Fixes issues with suspend/resume on inteldrm(4)
and perhaps radeondrm(4) as well.

i"it is the right place to stall" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.169 2014/03/09 07:42:29 jsg Exp $ */
a60 1
#include <sys/agpio.h>
@


1.169
log
@remove dri1 interfaces
discussed with kettenis some time last year
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.168 2014/02/23 09:36:52 kettenis Exp $ */
d787 4
@


1.168
log
@Give drm(4) a console locator just like wsdisplay(4) such that we can make
sure /dev/drm0 always matches the primary display.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.167 2014/02/09 10:50:43 jsg Exp $ */
a89 5
#define DRM_KERNEL_CONTEXT    0	 /* Change drm_resctx if changed	  */
#define DRM_RESERVED_CONTEXTS 1	 /* Change drm_resctx if changed	  */

#define DRM_MAX_CTXBITMAP (PAGE_SIZE * 8)

a383 10
#define LOCK_TEST_WITH_RETURN(dev, file_priv)				\
do {									\
	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) ||		\
	     dev->lock.file_priv != file_priv) {			\
		DRM_ERROR("%s called without lock held\n",		\
			   __FUNCTION__);				\
		return EINVAL;						\
	}								\
} while (0)

a535 7
struct drm_lock_data {
	struct mutex		 spinlock;
	struct drm_hw_lock	*hw_lock;	/* Hardware lock */
	/* Unique identifier of holding process (NULL is kernel) */
	struct drm_file		*file_priv;
};

a579 5
struct drm_sg_mem {
	struct drm_dmamem	*mem;
	unsigned long		 handle;
};

a805 3

	struct drm_lock_data  lock;	/* Information on hardware lock	*/

a837 2
	struct drm_sg_mem	*sg;  /* Scatter gather memory */
	atomic_t		*ctx_bitmap;
d933 1
a951 29
/* Context management (DRI1, deprecated) */
int	drm_ctxbitmap_init(struct drm_device *);
void	drm_ctxbitmap_cleanup(struct drm_device *);
void	drm_ctxbitmap_free(struct drm_device *, int);
int	drm_ctxbitmap_next(struct drm_device *);

/* Locking IOCTL support (drm_lock.c) */
int	drm_lock_take(struct drm_lock_data *, unsigned int);
int	drm_lock_free(struct drm_lock_data *, unsigned int);

/* Buffer management and DMA support (drm_bufs.c) */
int	drm_order(unsigned long);
struct drm_local_map *drm_core_findmap(struct drm_device *, unsigned long);
int	drm_rmmap_ioctl(struct drm_device *, void *, struct drm_file *);
void	drm_rmmap(struct drm_device *, struct drm_local_map *);
void	drm_rmmap_locked(struct drm_device *, struct drm_local_map *);
int	drm_addmap_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_addmap(struct drm_device *, unsigned long, unsigned long,
	    enum drm_map_type, enum drm_map_flags, struct drm_local_map **);
int	drm_addbufs(struct drm_device *, struct drm_buf_desc *);
int	drm_freebufs(struct drm_device *, void *, struct drm_file *);
int	drm_mapbufs(struct drm_device *, void *, struct drm_file *);
int	drm_dma(struct drm_device *, void *, struct drm_file *);
int	drm_dma_setup(struct drm_device *);
void	drm_dma_takedown(struct drm_device *);
void	drm_cleanup_buf(struct drm_device *, struct drm_buf_entry *);
void	drm_free_buffer(struct drm_device *, struct drm_buf *);
void	drm_reclaim_buffers(struct drm_device *, struct drm_file *);

a994 14
/* Scatter Gather Support (drm_scatter.c) */
void	drm_sg_cleanup(struct drm_device *, struct drm_sg_mem *);
int	drm_sg_alloc(struct drm_device *, struct drm_scatter_gather *);

/* Locking IOCTL support (drm_drv.c) */
int	drm_lock(struct drm_device *, void *, struct drm_file *);
int	drm_unlock(struct drm_device *, void *, struct drm_file *);

/* Context IOCTL support (drm_context.c) */
int	drm_resctx(struct drm_device *, void *, struct drm_file *);
int	drm_addctx(struct drm_device *, void *, struct drm_file *);
int	drm_getctx(struct drm_device *, void *, struct drm_file *);
int	drm_rmctx(struct drm_device *, void *, struct drm_file *);

a1010 4

/* Scatter Gather Support (drm_scatter.c) */
int	drm_sg_alloc_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_sg_free(struct drm_device *, void *, struct drm_file *);
@


1.167
log
@add some more linux compat functions for memory allocation
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.166 2014/02/04 22:19:53 kettenis Exp $ */
d900 1
d903 5
d951 1
a951 1
		     struct pci_attach_args *, int, struct device *);
@


1.166
log
@Add WARN_ONCE.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.165 2014/02/02 03:53:05 jsg Exp $ */
d250 8
d273 12
@


1.165
log
@add min_t and div_u64 which will be used to reduce the diff to linux
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.164 2014/02/02 00:58:35 jsg Exp $ */
d170 10
@


1.164
log
@add a simple version of usleep_range() that DELAYs for the min value
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.163 2014/01/30 15:10:47 kettenis Exp $ */
d257 11
@


1.163
log
@Get rid of the simple locks; they're lies.  Also get rid of the holding
logic for uvm objects; it's not necessary anymore as far as I can tell, at
least as long as we run all this code under the kernel lock.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.162 2014/01/22 22:17:34 jsg Exp $ */
d330 6
@


1.162
log
@add DMI_EXACT_MATCH macro, handled the same as DMI_MATCH for now
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.161 2014/01/22 05:16:55 kettenis Exp $ */
a1056 8
void	 drm_unref_locked(struct uvm_object *);
void	 drm_ref_locked(struct uvm_object *);
void	drm_hold_object_locked(struct drm_gem_object *);
void	drm_hold_object(struct drm_gem_object *);
void	drm_unhold_object_locked(struct drm_gem_object *);
void	drm_unhold_object(struct drm_gem_object *);
int	drm_try_hold_object(struct drm_gem_object *);
void	drm_unhold_and_unref(struct drm_gem_object *);
a1094 12
static __inline void 
drm_lock_obj(struct drm_gem_object *obj)
{
	simple_lock(&obj->uobj);
}

static __inline void 
drm_unlock_obj(struct drm_gem_object *obj)
{
	simple_unlock(&obj->uobj);
}

a1099 14

#ifdef DRMLOCKDEBUG

#define DRM_ASSERT_HELD(obj)		\
	KASSERT(obj->do_flags & DRM_BUSY && obj->holding_proc == curproc)
#define DRM_OBJ_ASSERT_LOCKED(obj) /* XXX mutexes */
#define DRM_ASSERT_LOCKED(lock) MUTEX_ASSERT_LOCKED(lock)
#else

#define DRM_ASSERT_HELD(obj)
#define DRM_OBJ_ASSERT_LOCKED(obj)
#define DRM_ASSERT_LOCKED(lock) 

#endif
@


1.161
log
@Provide inline dummy implementations of drm_sysfs_connector_add() and
drm_sysfs_connector_remove() and call those instead of #ifdef'ing them out.
Reduces the noise when diffing against Linux.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.160 2014/01/22 04:04:53 kettenis Exp $ */
d891 1
@


1.160
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.159 2014/01/21 08:55:24 kettenis Exp $ */
d1035 11
@


1.159
log
@Add kmalloc/kcalloc/kzalloc/kfree Linux compat functions.

discussed with jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.158 2013/12/21 19:36:41 kettenis Exp $ */
d150 1
@


1.158
log
@Advertise that we provide monotonic timestamps.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.157 2013/12/15 22:09:36 kettenis Exp $ */
d227 30
@


1.157
log
@Fix error handling of ->fb_create() call.  Prevents kernel panic if an
unsupported frame buffer configuration is requested.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.156 2013/12/05 13:29:56 kettenis Exp $ */
d951 2
@


1.156
log
@Rename 'struct drm_obj' to 'struct drm_gem_object' to reduce the diffs with
Linux.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.155 2013/12/01 09:13:46 kettenis Exp $ */
d199 6
@


1.155
log
@Fix WARN() and WARN_ON(); the condition should only be evaluated once.
Properly implement WARN_ON_ONCE() as well.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.154 2013/11/27 20:41:19 kettenis Exp $ */
d576 1
a576 1
struct drm_obj {
d578 1
a578 1
	SPLAY_ENTRY(drm_obj)	 	 entry;
d602 1
a602 1
	struct drm_obj		*obj;
d656 4
a659 4
	int (*gem_init_object) (struct drm_obj *obj);
	void (*gem_free_object) (struct drm_obj *obj);
	int (*gem_open_object) (struct drm_obj *, struct drm_file *);
	void (*gem_close_object) (struct drm_obj *, struct drm_file *);
d661 2
a662 2
	int	(*gem_fault)(struct drm_obj *, struct uvm_faultinfo *, off_t,
		    vaddr_t, vm_page_t *, int, int, vm_prot_t, int);
d796 1
a796 1
	SPLAY_HEAD(drm_name_tree, drm_obj)	name_tree;
d997 7
a1003 3
struct drm_obj *drm_gem_object_alloc(struct drm_device *, size_t);
int	 drm_gem_object_init(struct drm_device *, struct drm_obj *, size_t);
void	 drm_gem_object_release(struct drm_obj *);
d1008 18
a1025 15
void	drm_hold_object_locked(struct drm_obj *);
void	drm_hold_object(struct drm_obj *);
void	drm_unhold_object_locked(struct drm_obj *);
void	drm_unhold_object(struct drm_obj *);
int	drm_try_hold_object(struct drm_obj *);
void	drm_unhold_and_unref(struct drm_obj *);

int	drm_gem_handle_create(struct drm_file *, struct drm_obj *, u32 *);
int	drm_gem_handle_delete(struct drm_file *, u32);

void drm_gem_free_mmap_offset(struct drm_obj *obj);
int drm_gem_create_mmap_offset(struct drm_obj *obj);

struct drm_obj *drm_gem_object_lookup(struct drm_device *,
			    struct drm_file *, u32);
d1031 1
a1031 1
drm_gem_object_reference(struct drm_obj *obj)
d1037 1
a1037 1
drm_gem_object_unreference(struct drm_obj *obj)
d1043 1
a1043 1
drm_gem_object_unreference_unlocked(struct drm_obj *obj)
d1053 1
a1053 1
drm_lock_obj(struct drm_obj *obj)
d1059 1
a1059 1
drm_unlock_obj(struct drm_obj *obj)
@


1.154
log
@Hook up gem_open/close_object methods.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.153 2013/11/19 19:14:09 kettenis Exp $ */
d166 2
a167 1
	if (condition)							\
d169 1
a169 1
	(condition);							\
d175 2
a176 1
	if (condition)							\
d179 1
a179 1
	(condition);							\
d183 8
a190 1
	(condition);							\
@


1.153
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.152 2013/11/07 05:33:05 jsg Exp $ */
d641 5
a645 3
	/*
	 * driver-specific constructor for gem objects to set up private data.
	 * returns 0 on success.
d647 5
a651 2
	int	(*gem_init_object)(struct drm_obj *);
	void	(*gem_free_object)(struct drm_obj *);
@


1.152
log
@add a simplistic version of WARN_ON_ONCE() that doesn't warn
reduces the diff to linux and avoids a clang warning brad mentioned
ok kettenis@@ brad@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.151 2013/11/02 22:58:10 kettenis Exp $ */
d74 1
a781 1
	uint32_t		 gtt_total;
@


1.151
log
@Replace drm_handle_create/delete with drm_gem_handle_create/delete and make
the necessary adjustments to reference counting of GEM objects.  Matches what
Linux does these days.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.150 2013/10/26 20:31:48 kettenis Exp $ */
d176 4
@


1.150
log
@Unstub i915_gem_dumb_destroy() and radeon_mode_dumb_destroy().
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.149 2013/09/08 11:59:44 jsg Exp $ */
d992 3
a994 2
int	drm_handle_create(struct drm_file *, struct drm_obj *, int *);
int	drm_handle_delete(struct drm_file *, int);
d1000 1
a1000 1
			    struct drm_file *, int );
@


1.149
log
@switch to using linux style pci match tables
fixes some omissions and flag errors for radeon
and removes the duplicate table for i915
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.148 2013/09/02 07:14:22 jsg Exp $ */
d993 1
@


1.148
log
@use DRM_MEMORYBARRIER() for smp_mb__*
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.147 2013/09/02 06:25:27 jsg Exp $ */
d374 2
d377 7
a383 3
	int vendor;
	int device;
	long driver_private;
@


1.147
log
@add static back to functions that originally had it
reduces the diff to linux
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.146 2013/08/27 03:06:02 jsg Exp $ */
d237 5
@


1.146
log
@stash pci chipset and bridge tags in the drm_device struct
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.145 2013/08/26 05:15:20 jsg Exp $ */
d896 2
d911 2
@


1.145
log
@Add a stubbed out version of drm_pcie_get_speed_cap_mask() and
enable all the code in the various radeon pcie_gen2_enable() functions.
no functional change
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.144 2013/08/14 02:49:19 jsg Exp $ */
d695 3
d785 2
@


1.144
log
@drm_heap.c is no longer needed
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.143 2013/08/14 02:16:54 jsg Exp $ */
d1037 5
@


1.143
log
@remove references to ati_pcigart
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.142 2013/08/13 10:23:48 jsg Exp $ */
a856 8

/* Heap interface (DEPRECATED) */
int		 drm_init_heap(struct drm_heap *, int, int);
struct drm_mem	*drm_alloc_block(struct drm_heap *, int, int,
		     struct drm_file *);
int		 drm_mem_free(struct drm_heap *, int, struct drm_file *);
void		 drm_mem_release(struct drm_heap *, struct drm_file *);
void		 drm_mem_takedown(struct drm_heap *);
@


1.142
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.141 2013/08/12 04:11:52 jsg Exp $ */
a534 18
struct drm_ati_pcigart_info {
	union pcigart_table {
		struct fb_gart {
			bus_space_tag_t		 bst;
			bus_space_handle_t	 bsh;
		}	fb;
		struct mem_gart {
			struct drm_dmamem	*mem;
			u_int32_t		*addr;
		}	dma;
	}			 tbl;
	bus_addr_t		 bus_addr;
	bus_addr_t		 table_mask;
	bus_size_t		 table_size;
	int			 gart_table_location;
	int			 gart_reg_if;
};

a934 6

/* ATI PCIGART support (ati_pcigart.c) */
int	drm_ati_pcigart_init(struct drm_device *,
	    struct drm_ati_pcigart_info *);
int	drm_ati_pcigart_cleanup(struct drm_device *,
	    struct drm_ati_pcigart_info *);
@


1.141
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.140 2013/08/07 19:49:04 kettenis Exp $ */
d145 2
@


1.140
log
@Another major overhaul of the inteldrm(4) GEM code, bringing us considerably
closer to the Linux 3.8.13 codebase.  Almost certainly squashes a few more
bugs.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.139 2013/07/08 09:43:18 jsg Exp $ */
a103 8
/* D_CLONE only supports one device, this will be fixed eventually */
#define drm_get_device_from_kdev(_kdev)	\
	(drm_cd.cd_ndevs > 0 ? drm_cd.cd_devs[0] : NULL)
#if 0
#define drm_get_device_from_kdev(_kdev)			\
	(minor(_kdev) < drm_cd.cd_ndevs) ? drm_cd.cd_devs[minor(_kdev)] : NULL
#endif

d118 10
d134 1
d138 3
d143 2
d146 3
d151 3
d230 4
d238 2
d241 1
d244 22
d282 2
d310 1
a310 1
#define DRM_INFO(fmt, arg...)  printf("%s: " fmt, dev_priv->dev.dv_xname, ## arg)
d355 12
d530 1
d625 1
d917 1
d928 3
@


1.139
log
@add inline versions of udelay/mdelay
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.138 2013/06/11 19:39:09 kettenis Exp $ */
a719 4
	atomic_t		 pin_count;
	atomic_t		 pin_memory;
	atomic_t		 gtt_count;
	atomic_t		 gtt_memory;
a948 2
int	drm_gem_load_uao(bus_dma_tag_t, bus_dmamap_t, struct uvm_object *,
	    bus_size_t, int, bus_dma_segment_t **);
@


1.138
log
@Turn the allocation of GEM objects upside down and make the driver
responsible for allocating and freeing them.  This is what Linux has been
doing for a while now, and will be needed for radeondrm(4) in the near
future.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.137 2013/06/07 20:46:14 kettenis Exp $ */
d224 14
@


1.137
log
@Add proper mmap(2) support for drm(4)/inteldrm(4).  This changes the
DRM_I915_GEM_MMAP and DRM_I915_GEM_MMAP_GTT ioctls to be compatible with
Linux.  This also is the first step that moves us away from accessing all
graphics memory through the GTT, which should make things faster.

ok tedu@@ (for the uvm bits)
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.136 2013/03/28 23:47:37 jsg Exp $ */
d917 2
@


1.136
log
@as DRM_LOG_KMS is called with partial lines make it a simple printf
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.135 2013/03/21 19:39:30 deraadt Exp $ */
d500 1
d928 4
@


1.135
log
@Do not include machine/param.h since sys/param.h already did so.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.134 2013/03/18 12:36:51 jsg Exp $ */
d275 9
a283 1
#define DRM_LOG_KMS DRM_DEBUG_KMS
@


1.134
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.133 2012/12/06 15:05:21 mpi Exp $ */
a69 1
#include <machine/param.h>
@


1.133
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.132 2012/09/08 16:42:20 mpi Exp $ */
d73 1
d78 4
d118 6
d127 1
d133 60
d265 24
d331 1
d337 1
d358 2
a431 15
struct drm_vblank_info {
	struct mutex		 vb_lock;		/* VBLANK data lock */
	struct timeout		 vb_disable_timer;	/* timer for disable */
	int			 vb_num;		/* number of crtcs */
	u_int32_t		 vb_max;		/* counter reg size */
	struct drm_vblank {
		struct drmevlist vbl_events;		/* vblank events */
		u_int32_t	 vbl_last;		/* Last received */
		u_int32_t	 vbl_count;		/* interrupt no. */
		int		 vbl_refs;		/* Number of users */
		int		 vbl_enabled;		/* Enabled? */
		int		 vbl_inmodeset;		/* in a modeset? */
	}			 vb_crtcs[1];
};

d517 21
d547 2
d550 1
d556 4
d569 7
d595 1
d600 17
d623 6
a628 1
	const struct drm_driver_info *driver;
d662 4
a665 1
	struct drm_vblank_info	*vblank;		/* One per ctrc */
d668 15
d691 2
a702 2
	uint32_t		 invalidate_domains;
	uint32_t		 flush_domains;
d705 2
d710 1
a710 1
	const struct drm_driver_info	*driver;
d717 4
d725 37
d764 1
a764 1
struct device	*drm_attach_pci(const struct drm_driver_info *, 
d842 3
d846 4
a849 1
void	drm_handle_vblank(struct drm_device *, int);
d891 2
d940 10
d961 7
@


1.132
log
@Instead of having yet an other option to compile the drm code without agp
support, wrap all the agp glue with 'if __OS_HAS_AGP' in such form that it
is true if the agp(4) driver is present.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.131 2012/08/22 08:23:41 mpi Exp $ */
d300 1
a300 1
	struct device				*agpdev;
d588 1
a588 1
void	drm_core_ioremapfree(struct drm_local_map *);
@


1.131
log
@Add memory barriers for powerpc.

ok kettenis@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.130 2012/08/21 16:38:48 mpi Exp $ */
d75 3
a91 2

#define __OS_HAS_AGP	1
@


1.130
log
@Define the endianness macro used in drm code corresponding to the
value of BYTE_ORDER, this makes radeondrm(4) usable on big-endian
archs.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.129 2012/04/11 17:42:53 mikeb Exp $ */
d140 4
@


1.129
log
@fix all the suser calls which pass an incorrect p_acflag argument;
figured out by and ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: drmP.h,v 1.128 2011/06/02 18:22:00 weerd Exp $ */
d75 6
@


1.128
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d102 1
a102 1
#define DRM_SUSER(p)		(suser(p, p->p_acflag) == 0)
@


1.127
log
@- change recieved -> received in comments, as well as two unused defines
in pxe.h.

ok deraadt@@ sthen@@
@
text
@d1 1
@


1.126
log
@Support from vblank events in drm.

Previously, if userland wanted to wait on a certain vertical blank, it
had to call an ioctl which slept. Now, they can ask for an even on the
drm fd, which is then read off, and can be poll(4)ed on. For dri2 this
fits better into the workflow since the fd gets added to the xserver
main loop, and replies to the dri2 clients happen upon recieving the
events.

This functionality is only used with xserver 1.8 (and for the intel
driver in our tree, this support is currently #if 0ed out due to bugs
with vblanks on 945 that are still being chased)

matthieu@@ ok.
@
text
@d327 1
a327 1
		u_int32_t	 vbl_last;		/* Last recieved */
@


1.125
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@d219 14
d235 1
d237 1
d243 1
d326 1
d508 1
d551 2
@


1.124
log
@The locking rework/fix that I promised when I commited GEM.

Before, as well as being kinda nasty there was a very definite race, if
the last reference to an object  was removed by uvm (a map going away),
then the free path happened unlocked, this could cause all kinds of
havoc.

In order to deal with this, move to fine-grained locking. Since uvm
object locks are spinlocks, and we need to sleep in operations that will
wait on the gpu, provide a DRM_BUSY flag that is set on a locked object
that then allows us to unlock and sleep (this is similar to several
things done in uvm on pages and some object types).

The rwlock stays around to ensure that execbuffer can have acces to the
whole gtt, so ioctls that bind to the gtt need a read lock, and
execuffer gets a write lock. otherwise most ioctls just need to busy the
object that they operate on. Lists also have their own locks.

Some cleanup could be done to make this a little prettier, but it is
much more correct than previously.

Tested very very vigorously on 855 (x40) and 965 (x61s), this found numerous
bugs. Also, the I can no longer crash the kernel at will.

A bunch of asserts hidden under DRMLOCKDEBUG have been left in the code for
debugging purposes.
@
text
@a72 1
#include "drm_linux_list.h"
a408 2
	void	(*reclaim_buffers_locked)(struct drm_device *,
		    struct drm_file *);
a410 1
	int	(*dma_quiescent)(struct drm_device *);
@


1.123
log
@DRM memory management for inteldrm(4) using the Graphics Execution
Manager api.

This is currently disabled by default under ifdef INTELDRM_GEM (option
INTELDRM_GEM in a kernel config or a patch to i915_drv.h needed to
enable), mostly because the intel X driver currently in tree does not
always play well with GEM and needs to be switched to UXA accelmethod
(which is the only option on later drivers).

While based on the intel drm code in the linux kernel this has come cleanups and
some obvious behaviour changes:

1) mmap through the GTT is entirely coherent with the gpu cache, removing
mappings whenever the cache dirties so you can not race with userland to write
to memory at the same time as the gpu.

2) pread/pwrite access is tiling-correct, so userland does not need to tile
manually (mesa has already been fixed for this a while ago). The straw that
broke the camels back here was the bit17 swizzling stuff on some mobile gpus
meansing that while userland did the swizzle itself, the kernel had to do
*extra* swizzling, this was frankly retarded so the option was dropped.

3) there is no option to map via the cpu from userland, again due to
coherency issues.

4) additional integer overflow checking in some areas.

5) we only support the newer EXECBUFFER2 command submission ioctl. the
old one is not supported at all (libdrm was fixed WRT over a week ago).


now the TODOs:

1) the locking is funky and is only correct due to biglock. it does
however work due to that. This will be fixed in tree, the design in
formulating in my head as I type.

2) there are currently no memory limits on drm memory, this needs to be
changed.

3) we really need PAT support for the machines where MTRRs are useless, else drm
uses quite a lot of cpu (this is a bug that continues from the older code
though, nothing new).

4) gpu resetting support on other than 965 is not written yet.

5) currently a lot of the code is in inteldrm, when memory management
comes to other chipset common code will be factored out into the drm
midlayer.

Tested on: 855 (x40), GM965 and 915 by me. 945 by armani@@ and jkmeuser@@,
gm45 by armani@@ and marco@@. More testing is needed before I enable this
by default though.  Others also provided testing by what they tested
escapes me right now.

In order to test this enable INTELDRM_GEM in a kernel and add the following line
to the driver section in xorg.conf (I am working on a patch to autodetect the X
stuff):

Option "AccelMethod" "UXA"
@
text
@d89 2
d358 16
d383 7
d668 10
a677 2
void	drm_gem_object_reference(struct drm_obj *);
void	drm_gem_object_unreference(struct drm_obj *);
d686 38
@


1.122
log
@DRM for R600 and R700 chipsets.

note, only the pcidevs for those chipsets that have been tested are
enabled for now. Please contact me if you have a r600 or r700 that does
not attach radeondrm. Only the 2D/Xv bits are here. I'm ambivalent about
the implementation of the RADEON_CS ioctl for OpenGL since that was
originally kernel-modesetting only. When we update mesa I shall think
about (and test) it.

Tested by quite a number. Zero bad reports. Nagged perpetually by
robert@@ (and probably others) for months now.
@
text
@d43 1
d103 1
a103 1
#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
d219 11
a229 8
	SPLAY_ENTRY(drm_file)	 link;
	int			 authenticated;
	unsigned long		 ioctl_count;
	dev_t			 kdev;
	drm_magic_t		 magic;
	int			 flags;
	int			 master;
	int			 minor;
d356 22
d396 8
d405 1
d423 1
d477 15
d641 12
@


1.121
log
@Remove the vblank_disable_allowed crud.

it's a linux compat hack for older X drivers that don't use the right
calls. All the drivers capable of turning vblanks off already use the
calls correctly, and this way we avoid problems with not being able to
turn off vblanks until we switch mode (so until then we're stuck at
$REFRESH_RATE interrupts a second from the graphics card, no thanks).
@
text
@d329 1
@


1.120
log
@Rework the pcigart stuff somewhat.

firstly: move the pcigart initialisation in radeon_cp.c into its own
function to avoid the horrible nesting and make it more readable.

secondly: make the pcigart code more intelligent depending on whether
the gart table is in pci memory, or system memory. In the former case we
use the bus_space functions and thus don't need BUS_SPACE_LINEAR, while
i'm here, stop using the drm wrapper functions for mapping (which
require a drm_local_map structure, which will die eventually) and just
use bus_space_map itself.

tested on pcie (in framebuffer memory) here on my x800. tested on an
i386 agp card forced to pci mode by sthen.  Doesn't make IGP chips
worse, doesn't make them better either (tested on a rs690).

basic idea from a commit "upstream" a while ago. All the code from yours
truly.
@
text
@a300 1
	int			 vb_disable_allowed;
@


1.119
log
@factor a bit more functionality into common code instead of repeating it
in both drivers.
@
text
@d335 10
a344 3
	struct drm_local_map	 mapping;
	struct drm_dmamem	*mem;
	void			*addr;
d347 1
a349 1
	int			 table_size;
@


1.118
log
@Remove the context constructor and destructor driver hooks. sisdrm's old
code was the only that that needed them.
@
text
@d485 1
a485 2
struct drm_mem	*drm_find_block(struct drm_heap *, int);
void		 drm_free_block(struct drm_heap *, struct drm_mem *);
@


1.117
log
@merge radeon_mem_release() and radeon_mem_takedown() into the drm_heap
interface as drm_mem_release() and drm_mem_takedown() respectively.

While this interface's days are numbered, I'm about to make another
driver use it to remove even worse code.

Roll on memory management...
@
text
@a356 2
	int	(*context_ctor)(struct drm_device *, int);
	int	(*context_dtor)(struct drm_device *, int);
d490 1
a490 2


@


1.116
log
@Rework the vblank subsystem so that instead of having various bits in
the drm softc, we only have one pointer, with the rest in that struct. This is
so that vblank-less drivers (yes, they exist) don't need to waste space on
useless crud.

While i'm reworking most of this code anyway, accept that on openbsd all
of the #defined atomic functions are not atomic other than set and clear
bit. Also, realise that the vb_lock is held whenever we manipulate these
counts anyway.  With those two facts in mind just remove the
atomic_blah() and just use ++ and --.
@
text
@d484 8
a491 6
int	drm_init_heap(struct drm_heap *, int, int);
struct drm_mem *
	drm_alloc_block(struct drm_heap *, int, int, struct drm_file *);
struct drm_mem *
	drm_find_block(struct drm_heap *, int);
void	drm_free_block(struct drm_heap *, struct drm_mem *);
@


1.115
log
@kill DRM_VERIFYAREA_READ, it's part of a linux optimisation where we can
guarrantee that copyin won't pagefault and use a faster version in that
case.

Since we just use plain copyin, it's stupid.
@
text
@d298 13
a310 6
struct drm_vblank {
	u_int32_t	last_vblank;	/* Last vblank we recieved */
	atomic_t	vbl_count;	/* Number of interrupts */
	atomic_t	vbl_refcount;	/* Number of users */
	int		vbl_enabled;	/* Enabled? */
	int		vbl_inmodeset;	/* is the DDX currently modesetting */
d427 1
a427 6
	int			 num_crtcs;		/* number of crtcs */
	u_int32_t		 max_vblank_count;	/* size of counter reg*/
	struct mutex		 vbl_lock;		/* VBLANK data lock */
	int			 vblank_disable_allowed;
	struct timeout		 vblank_disable_timer;	/* timer for disable */
	struct drm_vblank	*vblank;		/* One per ctrc */
@


1.114
log
@Remove the three inline functions from drmP.h.

deiline drm_core_findmap(), and merge drm_core_ioremap{,free}() into
drm_ioremap{,free}() instead of having an inline that just calls another
function.
@
text
@d88 1
a88 1
#define DRM_MAXUNITS	8
d133 2
a134 14
#define DRM_VERIFYAREA_READ( uaddr, size )				\
	(!uvm_map_checkprot(&(curproc->p_vmspace->vm_map),		\
	    (vaddr_t)uaddr, (vaddr_t)uaddr+size, UVM_PROT_READ))

#define DRM_COPY_TO_USER(user, kern, size) \
	copyout(kern, user, size)
#define DRM_COPY_FROM_USER(kern, user, size) \
	copyin(user, kern, size)
#define DRM_COPY_FROM_USER_UNCHECKED(arg1, arg2, arg3) 	\
	copyin(arg2, arg1, arg3)
#define DRM_COPY_TO_USER_UNCHECKED(arg1, arg2, arg3)	\
	copyout(arg2, arg1, arg3)
#define DRM_GET_USER_UNCHECKED(val, uaddr)		\
	((val) = fuword(uaddr), 0)
@


1.113
log
@detypedef drm_local_map.
@
text
@d484 6
a489 2
void	*drm_ioremap(struct drm_device *, struct drm_local_map *);
void	drm_ioremapfree(struct drm_local_map *);
d513 1
a594 29

/* Inline replacements for DRM_IOREMAP macros */
#define drm_core_ioremap_wc drm_core_ioremap
static __inline__ void
drm_core_ioremap(struct drm_local_map *map, struct drm_device *dev)
{
	map->handle = drm_ioremap(dev, map);
}

static __inline__ void
drm_core_ioremapfree(struct drm_local_map *map)
{
	if ( map->handle && map->size )
		drm_ioremapfree(map);
}

static __inline__ struct drm_local_map *
drm_core_findmap(struct drm_device *dev, unsigned long offset)
{
	struct drm_local_map	*map;

	DRM_LOCK();
	TAILQ_FOREACH(map, &dev->maplist, link) {
		if (offset == map->ext)
			break;
	}
	DRM_UNLOCK();
	return (map);
}
@


1.112
log
@detypedef drm_device_dma_t.
@
text
@d296 1
a296 3
typedef TAILQ_HEAD(drm_map_list, drm_local_map) drm_map_list_t;

typedef struct drm_local_map {
d308 1
a308 1
} drm_local_map_t;
d340 1
a340 1
	drm_local_map_t		 mapping;
d418 3
a420 2
	struct extent	*handle_ext;
	drm_map_list_t	  maplist;
d445 1
a445 1
	drm_local_map_t		*agp_buffer_map;
d468 1
a468 1
extern drm_local_map_t	*drm_getsarea(struct drm_device *);
d471 1
a471 1
void	drm_dmamem_free(bus_dma_tag_t, struct drm_dmamem *);
d484 2
a485 2
void	*drm_ioremap(struct drm_device *, drm_local_map_t *);
void	drm_ioremapfree(drm_local_map_t *);
d510 2
a511 2
void	drm_rmmap(struct drm_device *, drm_local_map_t *);
void	drm_rmmap_locked(struct drm_device *, drm_local_map_t *);
d514 1
a514 1
	    enum drm_map_type, enum drm_map_flags, drm_local_map_t **);
d593 2
a594 1
static __inline__ void drm_core_ioremap(struct drm_local_map *map, struct drm_device *dev)
d598 3
a600 1
static __inline__ void drm_core_ioremapfree(struct drm_local_map *map)
d606 2
a607 1
static __inline__ struct drm_local_map *drm_core_findmap(struct drm_device *dev, unsigned long offset)
d609 1
a609 1
	drm_local_map_t *map;
@


1.111
log
@detypedef drm_buf_entry_t too.
@
text
@d254 1
a254 1
typedef struct drm_device_dma {
d268 1
a268 1
} drm_device_dma_t;
d426 1
a426 1
	drm_device_dma_t  *dma;		/* Optional pointer for DMA support */
@


1.110
log
@detypedef struct drm_buf from the dma_buffers api. Just because it's
dying as soon as I can make it doesn't mean I shouldn't be able to look
at it in the meantime.
@
text
@d220 1
a220 1
typedef struct drm_buf_entry {
d223 1
a224 1
	int			 buf_count;
d227 1
a227 1
} drm_buf_entry_t;
d255 9
a263 9
	struct rwlock	 dma_lock;
	drm_buf_entry_t	 bufs[DRM_MAX_ORDER+1];
	struct drm_buf	**buflist;	/* Vector of pointers info bufs	   */
	unsigned long	*pagelist;
	unsigned long	 byte_count;
	int		 buf_use;	/* Buffers in use -- cannot alloc  */
	int		 buf_count;
	int		 page_count;
	int		 seg_count;
d522 1
a522 1
void	drm_cleanup_buf(struct drm_device *, drm_buf_entry_t *);
@


1.109
log
@Change a bunch of "printk" in commented out debug code into "printf" and
kill the compat define. Should have done this ages ago.
@
text
@a97 2


d200 1
a200 1
typedef struct drm_buf {
d210 1
a210 1
} drm_buf_t;
d222 1
a222 1
	drm_buf_t		*buflist;
d257 1
a257 1
	drm_buf_t	**buflist;	/* Vector of pointers info bufs	   */
d523 1
a523 1
void	drm_free_buffer(struct drm_device *, drm_buf_t *);
@


1.108
log
@More dead typdefs and defines.
@
text
@a89 3
/* Deal with netbsd code where only the print statements differ */
#define printk printf

@


1.107
log
@unused type.
@
text
@a92 7
enum {
	DRM_IS_NOT_AGP,
	DRM_IS_AGP,
	DRM_MIGHT_BE_AGP
};
#define DRM_AGP_MEM		struct agp_memory_info

@


1.106
log
@detypedef drm_pci_id_list_t.
@
text
@a240 1
typedef TAILQ_HEAD(drm_file_list, drm_file) drm_file_list_t;
@


1.105
log
@Sprinkle some const correctness for the pciid lists. From mickey ages
ago.
@
text
@d203 1
a203 2
typedef struct drm_pci_id_list
{
d207 1
a207 1
} drm_pci_id_list_t;
d475 1
a475 1
int	drm_pciprobe(struct pci_attach_args *, const drm_pci_id_list_t * );
d487 2
a488 2
const drm_pci_id_list_t	*drm_find_description(int , int ,
			     const drm_pci_id_list_t *);
@


1.104
log
@More compat crud bites the dust: Remove the IRQ_NONE and IRQ_HANDLED
defines. 0 and 1 are fine for returning from irq handlers so why bother
with the indirection?
@
text
@d476 1
a476 1
int	drm_pciprobe(struct pci_attach_args *, drm_pci_id_list_t * );
d488 2
a489 1
drm_pci_id_list_t *drm_find_description(int , int , drm_pci_id_list_t *);
@


1.103
log
@kill the stupid DRM_IRQ_ARGS macros and irqreturn_t typedef, switch to
the unmacroed/typedefed version.
@
text
@a92 3
#define IRQ_HANDLED		1
#define IRQ_NONE		0

@


1.102
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@a92 2
#define DRM_IRQ_ARGS		void *arg
typedef int			irqreturn_t;
@


1.101
log
@Convert DRM_WAIT_ON to take additional parameters, the wmsg for msleep,
and the lock to manipulate.

first step of removing drm_irq_handler_wrap which just grabs the
irq_lock, and eventually irq_lock. drivers should manage their own.
@
text
@a386 1
	irqreturn_t	(*irq_handler)(DRM_IRQ_ARGS);
a428 1
	struct mutex	  irq_lock;	/* protects irq condition checks */
a546 1
irqreturn_t	drm_irq_handler_wrap(DRM_IRQ_ARGS);
@


1.100
log
@Cleanup. These definitions should have died when I removed the lock_time
member from the lock structure.
@
text
@a166 1
#define DRM_HZ			hz
d179 10
a188 9
#define DRM_WAIT_ON( ret, queue, timeout, condition )	\
mtx_enter(&dev->irq_lock);				\
while ( ret == 0 ) {					\
	if (condition)					\
		break;					\
	ret = msleep((queue), &dev->irq_lock,	 	\
	     PZERO | PCATCH, "drmwtq", (timeout));	\
}							\
mtx_leave(&dev->irq_lock)
@


1.99
log
@remove the drm_read and drm_write functions. instead just do the
conditional on whether we treat the data like memspace or system memory
into the one driver that needs this.

Something similar was done upstream a while back.
@
text
@a116 2
extern int ticks;		/* really should be in a header */
#define jiffies			ticks
@


1.98
log
@Remove the DRM_SPIN lock macros, just expand them to mutex operations.
@
text
@a151 7
#define DRM_READ8(map, offset) drm_read8(map, offset)
#define DRM_READ16(map, offset) drm_read16(map, offset)
#define DRM_READ32(map, offset) drm_read32(map, offset)
#define DRM_WRITE8(map, offset, val) drm_write8(map, offset, val)
#define DRM_WRITE16(map, offset, val) drm_write16(map, offset, val)
#define DRM_WRITE32(map, offset, val) drm_write32(map, offset, val)

a524 6
u_int8_t	drm_read8(drm_local_map_t *, unsigned long);
u_int16_t drm_read16(drm_local_map_t *, unsigned long);
u_int32_t drm_read32(drm_local_map_t *, unsigned long);
void	drm_write8(drm_local_map_t *, unsigned long, u_int8_t);
void	drm_write16(drm_local_map_t *, unsigned long, u_int16_t);
void	drm_write32(drm_local_map_t *, unsigned long, u_int32_t);
@


1.97
log
@Remove the lock_time member from the hardware lock. It's not that
useful, and driver shouldn't need to know about ``ticks''.
@
text
@a85 4
#define DRM_SPINTYPE		struct mutex
#define DRM_SPININIT(l,name)	mtx_init(l,IPL_NONE)
#define DRM_SPINLOCK(l)		mtx_enter(l)
#define DRM_SPINUNLOCK(l)	mtx_leave(l)
d190 1
a190 1
DRM_SPINLOCK(&dev->irq_lock);				\
d197 1
a197 1
DRM_SPINUNLOCK(&dev->irq_lock)
d439 1
a439 1
	DRM_SPINTYPE	  irq_lock;	/* protects irq condition checks */
d465 1
a465 1
	DRM_SPINTYPE		 vbl_lock;		/* VBLANK data lock */
@


1.96
log
@Push the per-driver dma hook a little further down.

All for all the drivers using the dma-bufs interface, their per-driver
ioctl hooks all started out the same way, followed by a call to another
function to actually select the buffer. Save some space by moving that
selection logic into the main dma_ioctl call, and make the second
function the hook.
@
text
@d273 1
a276 2
	unsigned long	 	 lock_time;	/* Time of last lock */
	struct mutex		 spinlock;
@


1.95
log
@Rework the dma buffer api a bit to make it smaller and to have less
duplicated code. Also, switch the dma_lock to a rwlock (it never should
have been a spinlock) and move it and some other accounting data into
the dma structure, not the main softc.

Finally, the funcitons in drm_dma are tiny, move them in with the rest
of the dma_bufs api in drm_bufs and remove the file.
@
text
@d205 2
a206 1
	    DRM_CURRENTPID, __func__ , ## arg)
d214 1
a214 1
		printf("[" DRM_NAME ":pid%d:%s] " fmt, DRM_CURRENTPID,	\
d394 2
a395 1
	int	(*dma_ioctl)(struct drm_device *, void *, struct drm_file *);
d475 1
a475 1
	pid_t		  buf_pgid;
@


1.94
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@d287 9
a295 7
	drm_buf_entry_t	  bufs[DRM_MAX_ORDER+1];
	int		  buf_count;
	drm_buf_t	  **buflist;	/* Vector of pointers info bufs	   */
	int		  seg_count;
	int		  page_count;
	unsigned long	  *pagelist;
	unsigned long	  byte_count;
a441 1
	DRM_SPINTYPE	  dma_lock;	/* protects dev->dma */
a446 1
	int		  buf_use;	/* Buffers in use -- cannot alloc  */
d546 3
a548 1
/* Buffer management support (drm_bufs.c) */
d551 1
a551 1
int	drm_order(unsigned long);
d554 4
a557 5
int	drm_addbufs_pci(struct drm_device *, struct drm_buf_desc *);
int	drm_addbufs_sg(struct drm_device *, struct drm_buf_desc *);
int	drm_addbufs_agp(struct drm_device *, struct drm_buf_desc *);

/* DMA support (drm_dma.c) */
a562 1
#define drm_core_reclaim_buffers drm_reclaim_buffers
a610 10

/* Buffer management support (drm_bufs.c) */
int	drm_addmap_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_rmmap_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_addbufs_ioctl(struct drm_device *, void *, struct drm_file *);
int	drm_freebufs(struct drm_device *, void *, struct drm_file *);
int	drm_mapbufs(struct drm_device *, void *, struct drm_file *);

/* DMA support (drm_dma.c) */
int	drm_dma(struct drm_device *, void *, struct drm_file *);
@


1.93
log
@Rework how we deal with the list of per-open datastructures, and the
auth list.  now we only need the one tree. Makes things a little neater,
and smaller.
@
text
@a80 4
#define DRM_ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
#define DRM_MIN(a,b) ((a)<(b)?(a):(b))
#define DRM_MAX(a,b) ((a)>(b)?(a):(b))

a84 3
#define DRM_WAKEUP(w)		wakeup((void *)w)

#define DRM_CURPROC		curproc
a85 1
#define DRM_NOOP		do {} while(0)
a87 1
#define DRM_SPINUNINIT(l)	DRM_NOOP
a89 6
#define DRM_SPINLOCK_IRQSAVE(l, irqflags) do {		\
	DRM_SPINLOCK(l);				\
	(void)irqflags;					\
} while (0)
#define DRM_SPINUNLOCK_IRQRESTORE(u, irqflags) DRM_SPINUNLOCK(u)
#define DRM_SPINLOCK_ASSERT(l)	DRM_NOOP
a95 1
#define __unused /* nothing */
@


1.92
log
@The drm_* allocation functions have been #defined to not use most of
their arguments for a while. Actually go through the code and remove the
extraneous arguments. Makes things easier to read.
@
text
@a245 6
struct drm_magic_entry {
	drm_magic_t	       magic;
	struct drm_file	       *priv;
	SPLAY_ENTRY(drm_magic_entry) node;
};

d277 1
a277 1
	TAILQ_ENTRY(drm_file)	 link;
d465 1
a465 1
	drm_file_list_t   files;
a466 1
	SPLAY_HEAD(drm_magic_tree, drm_magic_entry)	magiclist;
a620 1
int	drm_version(struct drm_device *, void *, struct drm_file *);
a626 6

/* Authentication IOCTL support (drm_auth.c) */
int	drm_getmagic(struct drm_device *, void *, struct drm_file *);
int	drm_authmagic(struct drm_device *, void *, struct drm_file *);
int	drm_magic_cmp(struct drm_magic_entry *, struct drm_magic_entry *);
SPLAY_PROTOTYPE(drm_magic_tree, drm_magic_entry, node, drm_magic_cmp);
@


1.91
log
@Remove some dead and unneeded defines, types and prototypes.
@
text
@a77 24
#define DRM_MEM_DMA		0
#define DRM_MEM_SAREA		1
#define DRM_MEM_DRIVER		2
#define DRM_MEM_MAGIC		3
#define DRM_MEM_IOCTLS		4
#define DRM_MEM_MAPS		5
#define DRM_MEM_BUFS		6
#define DRM_MEM_SEGS		7
#define DRM_MEM_PAGES		8
#define DRM_MEM_FILES		9
#define DRM_MEM_QUEUES		10
#define DRM_MEM_CMDS		11
#define DRM_MEM_MAPPINGS	12
#define DRM_MEM_BUFLISTS	13
#define DRM_MEM_AGPLISTS	14
#define DRM_MEM_TOTALAGP	15
#define DRM_MEM_BOUNDAGP	16
#define DRM_MEM_CTXBITMAP	17
#define DRM_MEM_CTXLIST		18
#define DRM_MEM_STUB		19
#define DRM_MEM_SGLISTS		20
#define DRM_MEM_DRAWABLE	21
#define DRM_MEM_MM		22

d536 4
a539 9
void	*_drm_alloc(size_t);
#define	drm_alloc(size, area)	_drm_alloc(size)
void	*_drm_calloc(size_t, size_t);
#define	drm_calloc(nmemb, size, area) _drm_calloc(nmemb, size)
void	*_drm_realloc(void *, size_t, size_t);
#define	drm_realloc(old, oldsz, size, area) _drm_realloc(old, oldsz, size)
void	_drm_free(void *);
#define	drm_free(ptr, size, area) do { _drm_free(ptr); (void)(size); \
} while( /*CONSTCOND*/ 0)
@


1.90
log
@Remove drm_pci_alloc and associated definitions.
@
text
@a168 1
typedef unsigned long dma_addr_t;
a269 9
#define DRM_AUTH	0x1
#define DRM_MASTER	0x2
#define DRM_ROOT_ONLY	0x4
typedef struct drm_ioctl_desc {
	unsigned long cmd;
	int (*func)(struct drm_device *, void *, struct drm_file *);
	int flags;
} drm_ioctl_desc_t;

a601 2
drm_local_map_t
	*drm_find_matching_map(struct drm_device *, drm_local_map_t *);
@


1.89
log
@convert drm_scatter code over to using the new dmamem api.

removes the custom code in there, so shrinks the kernel by a few bytes.
Convert other code to deal with data structure changes.
@
text
@a297 9
typedef struct drm_dma_handle {
	void *vaddr;
	bus_addr_t busaddr;
	bus_dmamap_t	dmamap;
	bus_dma_segment_t seg;
	void *addr;
	size_t size;
} drm_dma_handle_t;

a710 5

/* consistent PCI memory functions (drm_pci.c) */
drm_dma_handle_t *drm_pci_alloc(bus_dma_tag_t, size_t, size_t,
		      dma_addr_t);
void	drm_pci_free(bus_dma_tag_t, drm_dma_handle_t *);
@


1.88
log
@convert the pcigart case where the gart table is in system memory over
to use the new api.

More cleanup to this file coming soon.
@
text
@d386 3
a388 7
struct drm_sg_dmamem {
	bus_dma_tag_t		sg_tag;
	bus_dmamap_t		sg_map;
	bus_dma_segment_t	*sg_segs;
	int			sg_nsegs;
	size_t			sg_size;
	caddr_t			sg_kva;
a390 9
typedef struct drm_sg_mem {
	unsigned long   handle;
	void            *virtual;
	int             pages;
	dma_addr_t	*busaddr;
	drm_dma_handle_t *dmah;	/* Handle to PCI memory for ATI PCIGART table */
	struct drm_sg_dmamem *mem;
} drm_sg_mem_t;

d542 1
a542 1
	drm_sg_mem_t		*sg;  /* Scatter gather memory */
d666 1
a666 1
void	drm_sg_cleanup(drm_sg_mem_t *);
@


1.87
log
@Convert CONSISTENT maps over to dmamem api.
@
text
@d450 8
a457 7
	int gart_table_location;
	int gart_reg_if;
	void *addr;
	dma_addr_t bus_addr;
	dma_addr_t table_mask;
	drm_local_map_t mapping;
	int table_size;
@


1.86
log
@convert drm_addbufs_pci over to new dmamem api.
@
text
@d408 1
a408 1
	drm_dma_handle_t		*dmah;	/* Handle to DMA mem */
d413 3
a416 3
	int				 mtrr;	/* Boolean: MTRR used */
	unsigned long			 offset;/* Physical address */
	unsigned long			 size;	/* Physical size (bytes) */
@


1.85
log
@introduce drm_dmamem_alloc() to allocate dma memory with bus_dma.

The next few commits will convert calls to drm_pci_alloc (which I hate)
over to this new api, and convert other handrolled stuff over too.

First part of my cleaning up bus_dma useage in drm.
@
text
@d316 6
a321 6
	int		  buf_size;
	int		  buf_count;
	drm_buf_t	  *buflist;
	int		  seg_count;
	drm_dma_handle_t  **seglist;
	int		  page_order;
@


1.84
log
@Merge the static block allocation code from {i915,radeon}_mem.c into
non-static code that's shared between both.  While i'm here convert them
to TAILQ.

Eventually, both of these will die, but until then I'd rather shave the
space in the kernel.

Tested on radeon and intel.
@
text
@d307 8
d581 3
@


1.83
log
@Similar to my last commit, it's stupid to have a file with two very
small functions in it. Move them to main driver file.
@
text
@d420 10
d593 9
@


1.82
log
@Move drmmmap to the main driver file.  It's stupid to have a file with
one (not particlarly large) function in it.
@
text
@a660 5
int	drm_setversion(struct drm_device *, void *, struct drm_file *);

/* Misc. IOCTL support (drm_ioctl.c) */
int	drm_irq_by_busid(struct drm_device *, void *, struct drm_file *);
int	drm_getunique(struct drm_device *, void *, struct drm_file *);
d687 1
@


1.81
log
@drm_getmap and interface can die too.
@
text
@a560 2
dev_type_read(drmread);
dev_type_poll(drmpoll);
@


1.80
log
@Rip out the drm_drawable support. There is no need for the xserver to
push cliprects into the kernel anymore so no op the ioctls. The only
consumer of this information died a couple of months ago.

When i've got removal of these calls from userland upstream i'm going to
remove them from the interface entirely.
@
text
@a667 1
int	drm_getmap(struct drm_device *, void *, struct drm_file *);
@


1.79
log
@While printing is turned off by default, the debug code was still
compiled into drm. I'd forgotten about that. if DRMDEBUG is defined,
build in the printfs, else no-op them. Shaves a bunch of string from the
kernel

Fix two cases in mach64_irq.c where this would lead to unused variable
warnings.

Reminded by an entirely different comment by djm@@.
@
text
@a73 1
#include "drm_internal.h"
a501 1
	DRM_SPINTYPE	  drw_lock;
a539 4

	u_int		  drw_no;
	/* RB tree of drawable infos */
	RB_HEAD(drawable_tree, bsd_drm_drawable_info) drw_head;
a674 8

/* Drawable IOCTL support (drm_drawable.c) */
int	drm_adddraw(struct drm_device *, void *, struct drm_file *);
int	drm_rmdraw(struct drm_device *, void *, struct drm_file *);
int	drm_update_draw(struct drm_device *, void *, struct drm_file *);
void	drm_drawable_free_all(struct drm_device *);
struct drm_drawable_info	*drm_get_drawable_info(struct drm_device *,
				    unsigned int);
@


1.78
log
@Fix a possible NULL pointer dereference. Spotted by Tobias Ulmer; thanks!
@
text
@d251 1
d258 3
@


1.77
log
@back out the buf_priv change. it made some incorrect assumptions and
broke radeondrm. Fixing it is ugly, so another change will have to be made
later.


I /hate/ the drm_buf api, it will die as soon as it can.
@
text
@d151 2
a152 1
#define drm_get_device_from_kdev(_kdev) drm_cd.cd_devs[0]
@


1.76
log
@Fixup wakeup pointers. interrupts work properly again.
@
text
@d291 1
@


1.75
log
@do the same for struct drm_file (file_priv) as previously done for
dma_bufs; allow the driver to provide the size and not have the private
data pointer.  only radeon only needs this so far, but intel with GEM
also needs it.

Postclose was only used for freeing said private data, so this allows me
to remove the postclose callback and rename preclose to close.
@
text
@d239 1
a239 1
	ret = msleep(&(queue), &dev->irq_lock,	 	\
@


1.74
log
@Instead of having a ``private data'' pointer in the dma buffers, just
ask the driver how large they need the structure we allocate to be, and
use inheritance like we do for struct device. Simplifies things a little
bit and saves us a pointer.
@
text
@a313 1
	void			*driver_priv;
d441 1
a441 2
	void	(*preclose)(struct drm_device *, struct drm_file *);
	void	(*postclose)(struct drm_device *, struct drm_file *);
d457 2
a458 1
	int	buf_priv_size;
@


1.73
log
@change drm_attach_mi to drm_attach_pci. we take the pci_attach_args, and
setup the drm_attach_args with the needed information.

require interface version 1.1 libdrm has been requesting it for ages),
which means that we can set the busid string at attach time. (generated in
drm_attach_pci), also pass in the interrupt line and bst.

Now we don't need dev->pa at all, so remove it, finally.
@
text
@a290 1
	void		  *dev_private;  /* Per-buffer private storage       */
@


1.72
log
@make device works out if it's agp and tells the drm driver, not the
other way round. More dev->pa reduction
@
text
@d489 1
a521 6
	struct pci_attach_args  pa;

	int		  pci_domain;
	int		  pci_bus;
	int		  pci_slot;
	int		  pci_func;
d546 1
a546 2
	struct pci_attach_args		*pa;
	struct vga_pci_softc		*vga;
d548 2
d551 1
d558 2
a559 2
struct device	*drm_attach_mi(const struct drm_driver_info *, bus_dma_tag_t,
		     struct pci_attach_args *pa, int, struct device *);
a669 1
int	drm_setunique(struct drm_device *, void *, struct drm_file *);
@


1.71
log
@instead of functions that just return an error, just inline them into
the ioctl handler.
@
text
@a459 13
	/**
	 * Called by \c drm_device_is_agp.  Typically used to determine if a
	 * card is really attached to AGP or not.
	 *
	 * \param dev  DRM device handle
	 *
	 * \returns 
	 * One of three values is returned depending on whether or not the
	 * card is absolutely \b not AGP (return of 0), absolutely \b is AGP
	 * (return of 1), or may or may not be AGP (return of 2).
	 */
	int	(*device_is_agp) (struct drm_device * dev);

d554 1
d562 1
a562 1
		     struct pci_attach_args *pa, struct device *);
a638 1
int	drm_device_is_agp(struct drm_device *);
@


1.70
log
@pass in the dmat when we attach the drm driver. reduces pci dependancy.
@
text
@a687 3
int	drm_getclient(struct drm_device *, void *, struct drm_file *);
int	drm_getstats(struct drm_device *, void *, struct drm_file *);
int	drm_noop(struct drm_device *, void *, struct drm_file *);
@


1.69
log
@#define away unused arguments for the drm_alloc functions. to save some
size.

kill (empty) drm_mem_{un,}init() while here.
@
text
@d501 2
d566 1
d573 1
a573 1
struct device	*drm_attach_mi(const struct drm_driver_info *,
@


1.68
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d586 9
a594 6
void	drm_mem_init(void);
void	drm_mem_uninit(void);
void	*drm_alloc(size_t, int);
void	*drm_calloc(size_t, size_t, int);
void	*drm_realloc(void *, size_t, size_t, int);
void	drm_free(void *, size_t, int);
@


1.67
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d452 1
a452 2
	void	(*irq_preinstall)(struct drm_device *);
	int	(*irq_postinstall)(struct drm_device *);
a532 2
	int		  unit;		/* drm unit number */
	void		  *irqh;	/* Handle from bus_setup_intr      */
d635 1
a635 4
irqreturn_t drm_irq_handler(DRM_IRQ_ARGS);
void	drm_driver_irq_preinstall(struct drm_device *);
void	drm_driver_irq_postinstall(struct drm_device *);
void	drm_driver_irq_uninstall(struct drm_device *);
@


1.66
log
@using ``wait queues' for sleep is a linuxism. Kill them and just sleep
on the softc.
@
text
@d456 1
@


1.65
log
@Make all drm drivers map their mmio register space on attach instead of
using the drm_maps interface (this was done for inteldrm a few days
ago).  All drivers now ignore the mmio_offset argument that the init
ioctl takes.

This clears up the code and makes sure that drm_ioremap_core() doesn't
need the vga_pci_map inteface anymore, so we don't have to pass in the
vga softc anymore. We also get to kill the drm_resource_{start,length}
linux-alike functions since we just calculate all the requisite offsets
at startup and cache those we need. This now means that technically the
only driver that needs the vga_pci_map api is inteldrm (due to sharing
with intagp issues), though this diff doesn't convert them over.
@
text
@a113 1
#define wait_queue_head_t	atomic_t
a114 1
#define DRM_INIT_WAITQUEUE(queue) do {(void)(queue);} while (0)
@


1.64
log
@drm_device_is_pcie is only needed in one place: radeondrm_attach

so just inline it there.

also remove dev->pci_vendor and dev->pci_device, and insert pci_device
into the one place any of them are needed (inteldrm's interface can give
this info to the X driver. to remove that you'd need to fix X too).
@
text
@a398 1
	struct vga_pci_bar		*bsr;	/* Vga BAR, if applicable */
a494 3
/* Length for the array of resource pointers for drm_get_resource_*. */
#define DRM_MAX_PCI_RESOURCE	3

a504 1
	struct vga_pci_softc *vga_softc;
a537 3
	/* Storage of resource pointers for drm_get_resource_* */
	struct vga_pci_bar	  *pcir[DRM_MAX_PCI_RESOURCE];

d575 1
a575 2
		     struct pci_attach_args *pa, struct device *,
		     struct device *);
a616 2
unsigned long drm_get_resource_start(struct drm_device *, unsigned int);
unsigned long drm_get_resource_len(struct drm_device *, unsigned int);
@


1.63
log
@Move the drm drivers over from:

vga1 at pci0
inteldrm0 at vga1

to

vga1 at pci0
inteldrm0 at vga1
drm0 at inteldrm0

i.e. a similar scheme to audio(4) where the interface attaches on top of
the wildly different drivers. This helps to clean up the code a lot
(more is coming) and help me start to move drm to being essentially bus
independent, which will help in the future.
@
text
@a506 3
	u_int16_t pci_device;		/* PCI device id */
	u_int16_t pci_vendor;		/* PCI vendor id */

a663 1
int	drm_device_is_pcie(struct drm_device *);
@


1.62
log
@Remove the driver->load callback and just do all the initialization in
the attach function. First step towards splitting drm off as it's own
(bus independant) device, as it should be.
@
text
@a134 1
extern struct drm_device *drm_units[];
d153 2
d156 1
a156 6
	drm_units[0]

#if 0 /* D_CLONE only supports on device for now */
#define drm_get_device_from_kdev(_kdev) 		\
	(minor(kdev) < DRM_MAXUNITS) ?			\
	    drm_units[minor(kdev)] : NULL
d208 1
a208 1
		    (vaddr_t)uaddr, (vaddr_t)uaddr+size, UVM_PROT_READ))
d250 1
a250 1
#define DRM_INFO(fmt, arg...)  printf("%s: " fmt, drm_units[0]->device.dv_xname, ## arg)
d267 1
d575 6
d584 4
a587 4
int	drm_probe(struct pci_attach_args *, drm_pci_id_list_t * );
void	drm_attach(struct device *, struct device *, struct pci_attach_args *);
int	drm_detach(struct device *, int );
int	drm_activate(struct device *, enum devact);
@


1.61
log
@reduce the dependancy of drm_pci_alloc upon the drm device softc. Just
pass in the dma tag
@
text
@a444 1
	int	(*load)(struct drm_device *, unsigned long);
a451 1
	int	(*unload)(struct drm_device *);
d582 1
a582 2
void	drm_attach(struct device *, struct device *,
	    struct pci_attach_args *, drm_pci_id_list_t *);
d592 2
@


1.60
log
@Remove dev->id_entry, it is no longer needed.
@
text
@d755 1
a755 1
drm_dma_handle_t *drm_pci_alloc(struct drm_device *, size_t, size_t,
d757 1
a757 1
void	drm_pci_free(struct drm_device *, drm_dma_handle_t *);
d765 1
a765 1
static __inline__ void drm_core_ioremapfree(struct drm_local_map *map, struct drm_device *dev)
@


1.59
log
@Remove the strings from the pcidevs arrays. they are no longer needed and are
just wasting space.
@
text
@a510 1
	drm_pci_id_list_t *id_entry;	/* PCI ID, name, and chipset private */
@


1.58
log
@Remove dev->agp_buffer_token, linux needs it, we do not.
@
text
@a267 1
	char *name;
@


1.57
log
@Instead of using a width-1 bitfield for storing the driver capabilities
in the callback structure, just use a bunch of ORed together bits. This
has been annoying me for ages.
@
text
@a574 1
	unsigned int		 agp_buffer_token;
@


1.56
log
@rework how we handle ioctls.

Before it was based on a static array with flags. Instead, let the
driver provide an ioctl callback, which deals with things appropriately.
Makes the code a bit easier to read, and also drops just over 5k on an
amd64 kernel build with all drm drivers enabled.

Tested by a few.
@
text
@a280 6
/**
 * Creates a driver or general drm_ioctl_desc array entry for the given
 * ioctl, for use by drm_ioctl().
 */
#define DRM_IOCTL_DEF(ioctl, func, flags) \
	[DRM_IOCTL_NR(ioctl)] = {ioctl, func, flags}
d491 9
a499 9
	unsigned use_agp :1;
	unsigned require_agp :1;
	unsigned use_sg :1;
	unsigned use_dma :1;
	unsigned use_pci_dma :1;
	unsigned use_dma_queue :1;
	unsigned use_irq :1;
	unsigned use_vbl_irq :1;
	unsigned use_mtrr :1;
@


1.55
log
@Fix prototype for drm_addmap(), okay oga@@.
@
text
@d455 2
a486 3

	drm_ioctl_desc_t *ioctls;
	int	max_ioctl;
@


1.54
log
@Oops. Forgot to commit this chunk with the last commit.

Remove softc members and prototypes related to the tasklet system.
@
text
@d645 1
a645 1
	    enum drm_map_type, enum drm_lock_flags, drm_local_map_t **);
@


1.53
log
@make DRM_INFO() a bit less gross, though getting all the grossness out at once is impossible; ok oga
@
text
@a533 1
	DRM_SPINTYPE	  tsk_lock;
a587 2

	void		  (*locked_task_call)(struct drm_device *);
a748 1
void	drm_locked_tasklet(struct drm_device *, void (*)(struct drm_device *));
@


1.52
log
@Kill the linux-ready negative return codes in ``shared'' code. We handle
them wrong in several cases that i've noticed and Merging when needed is
still fairly simple, anyway. This shaves another 500 bytes from an amd64
kernel due to not having to flip the sign on some things. It also stops
my eyes bleeding.

Tested by a few along with the last diff that went in.
@
text
@d254 1
a254 1
#define DRM_INFO(fmt, arg...)  printf("info: [" DRM_NAME "] " fmt , ## arg)
@


1.51
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@a239 1
/* Returns -errno to shared code */
d245 1
a245 1
	ret = -msleep(&(queue), &dev->irq_lock,	 	\
@


1.50
log
@Put back the ``address'' field to struct drm_buf, this allows machdrm to
actually compile again (no one's tested it yet, still and I don't have
one).
@
text
@d300 1
a300 1
	void 		  *address;      /* Byte offset (used internally)	     */
a473 2
	drm_pci_id_list_t *id_entry;	/* PCI ID, name, and chipset private */

d519 1
a519 1
	struct drm_driver_info driver;
@


1.49
log
@Rework the drm locking to be at least halfway sane. The freebsd code
held a lock over all driver ioctls in order to be ``mpsafe''. Stop lying
to ourselves for a start. This code is not fully mpsafe, and should not
pretend to be so.  Put the locking around where it should, and rely on
biglock for the rest. This will need to be fixed, but avoids some of the
horrible that we have right now.

Tested by many over a long time and several iterations.
@
text
@d300 1
@


1.48
log
@Kill the max_context member of the softc, it does nothing useful.
@
text
@a115 1
#define DRM_WAKEUP_INT(w)	wakeup(w)
d132 2
a133 2
#define DRM_LOCK()		DRM_SPINLOCK(&dev->dev_lock)
#define DRM_UNLOCK()		DRM_SPINUNLOCK(&dev->dev_lock)
d241 9
a249 14
#define DRM_WAIT_ON( ret, queue, timeout, condition )		\
ret = 0;							\
while ( ret == 0 ) {						\
	DRM_UNLOCK();						\
	DRM_SPINLOCK(&dev->irq_lock);				\
	if (condition) {					\
		DRM_SPINUNLOCK(&dev->irq_lock);			\
		break;						\
	}							\
	ret = -msleep(&(queue), &dev->irq_lock,		 	\
	     PZERO | PCATCH, "drmwtq", (timeout));		\
	DRM_SPINUNLOCK(&dev->irq_lock);				\
	DRM_LOCK();						\
}
a340 1
	int			 lock_queue;	/* Queue of blocked processes */
d342 1
a424 1
	int		vbl_queue;	/* sleep on this when waiting */
d534 1
a534 1
	DRM_SPINTYPE	  dev_lock;	/* protects everything else */
a611 2
int		 drm_open_helper(dev_t, int, int, struct proc *,
		     struct drm_device *);
a638 1
int	drm_lock_transfer(struct drm_lock_data *, unsigned int);
d645 1
d791 1
a791 1
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);
d794 1
a794 1
			return map;
d796 2
a797 1
	return NULL;
@


1.47
log
@Kill some stupid agp api wrapper functions, just use the agp api
directly.  While i'm here, factor out some common functionality into a
separate function, and kill some typedefs (man this code is full of
them...). Shaves another 450 bytes off the kernel.

Tested by ckuethe and Paul de Weerd, thanks.
@
text
@a557 2
	int		  max_context;

@


1.46
log
@Kill some unneeded defines and struct members.
@
text
@a173 6
#ifdef DRM_NO_AGP
#define DRM_AGP_FIND_DEVICE()	0
#else
#define DRM_AGP_FIND_DEVICE()	agp_find_device(0)
#endif

d379 1
a379 1
typedef struct drm_agp_head {
d391 1
a391 1
} drm_agp_head_t;
d590 6
a595 6
	drm_agp_head_t    *agp;
	drm_sg_mem_t      *sg;  /* Scatter gather memory */
	atomic_t          *ctx_bitmap;
	void		  *dev_private;
	unsigned int	  agp_buffer_token;
	drm_local_map_t   *agp_buffer_map;
d692 2
a693 1
drm_agp_head_t *drm_agp_init(void);
@


1.45
log
@Kill some more unused struct fields and the cases for them.
@
text
@a113 4
#define DRM_DEV_MODE	(S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP)
#define DRM_DEV_UID	0
#define DRM_DEV_GID	0

a118 1
#define DRM_CDEV		dev_t
d120 1
a120 3
#define DRM_STRUCTPROC		struct proc
#define DRM_STRUCTCDEVPROC	struct proc
#define DRM_PROC(p)		(p)
a134 4
#define DRM_SLEEPLOCK(v,l,f,s,i)	msleep(v,l,f,s,i);
#define DRM_PID(p)		(p)->p_pid
#define DRM_CURRENTPID		DRM_PID(curproc)
#define DRM_UID(p)		(p)->p_pid
a235 1
#define DRM_TIME_SLICE		(hz/20)  /* Time slice for GLXContexts	  */
a346 2
	pid_t			 pid;
	uid_t			 uid;
d627 2
a628 2
int		drm_open_helper(DRM_CDEV, int, int, 
		    DRM_STRUCTPROC *, struct drm_device *);
@


1.44
log
@Kill the stats data structures and noop some other parts. Nothing in
userland asks for these stats, and we stopped recording anything
interesting a while back.
@
text
@a321 1
	int		  order;       /* log-base-2(total)		     */
a323 1
	void		  *address;    /* Address of buffer		     */
a326 11
	int		  context;     /* Kernel queue for this buffer	     */
	enum {
		DRM_LIST_NONE	 = 0,
		DRM_LIST_FREE	 = 1,
		DRM_LIST_WAIT	 = 2,
		DRM_LIST_PEND	 = 3,
		DRM_LIST_PRIO	 = 4,
		DRM_LIST_RECLAIM = 5
	}		  list;	       /* Which list we're on		     */

	int		  dev_priv_size; /* Size of buffer private stoarge   */
@


1.43
log
@The code for cleaning up errored buffers and for cleaning up at the end
is the same. Factor them into one function. Saves another 450 bytes on
amd64.
@
text
@a581 5
				/* Performance counters */
	unsigned long     counters;
	enum drm_stat_type   types[15];
	atomic_t          counts[15];

@


1.42
log
@detypedef some more. No functional change.
@
text
@d707 1
@


1.41
log
@Build with mtrr support on amd64. This really should have gone in in
edmonton, but I forgot.

ok and extra testing phessler@@.
@
text
@d377 1
a377 1
	drm_hw_lock_t	*hw_lock;	/* Hardware lock */
d379 3
a381 3
	struct drm_file	*file_priv;
	int		 lock_queue;	/* Queue of blocked processes */
	unsigned long	 lock_time;	/* Time of last lock in jiffies */
d454 1
a454 1
	drm_map_flags_t			 flags;	/* Flags */
d458 1
a458 1
	drm_map_type_t			 type;	/* Type of memory mapped */
d584 1
a584 1
	drm_stat_type_t   types[15];
d699 4
a702 4
	    drm_map_type_t, drm_map_flags_t, drm_local_map_t **);
int	drm_addbufs_pci(struct drm_device *, drm_buf_desc_t *);
int	drm_addbufs_sg(struct drm_device *, drm_buf_desc_t *);
int	drm_addbufs_agp(struct drm_device *, drm_buf_desc_t *);
d732 2
a733 2
int	drm_agp_info(struct drm_device *, drm_agp_info_t *);
int	drm_agp_enable(struct drm_device *, drm_agp_mode_t);
d738 4
a741 4
int	drm_agp_alloc(struct drm_device *, drm_agp_buffer_t *);
int	drm_agp_free(struct drm_device *, drm_agp_buffer_t *);
int	drm_agp_bind(struct drm_device *, drm_agp_binding_t *);
int	drm_agp_unbind(struct drm_device *, drm_agp_binding_t *);
d745 1
a745 1
int	drm_sg_alloc(struct drm_device *, drm_scatter_gather_t *);
@


1.40
log
@replace usage of drm_memrange with extent(9). No functional change, but
should shrink the kernel somewhat. For some strange reason I was unaware
of this api when I pulled in these changes.

tested by myself and Paul de Weerd, thanks!
@
text
@a75 4
#ifdef __amd64__
#define DRM_NO_MTRR
#endif /* Until the mtrr apis are merged. */

@


1.39
log
@Rip out the remnants of the vblank signal stuff. Nothing uses it, and
it's stupid anyway. Most of this was ifdefed out.
@
text
@d61 1
a447 20
/*
 * Generic memory range manager structs
 */ 

struct drm_memrange_node {
	TAILQ_ENTRY(drm_memrange_node)	 ml_entry;
	TAILQ_ENTRY(drm_memrange_node)	 fl_entry;
	struct drm_memrange		*mm;
	void				*private;
	int				 free;
	unsigned long			 start;
	unsigned long			 size;
};

TAILQ_HEAD(drm_mmq, drm_memrange_node);
struct drm_memrange {
	struct drm_mmq	ml;
	struct drm_mmq	fl;
};

a454 1
	struct drm_memrange_node 	*mm;	/* mmap offset */
d457 1
d597 1
a597 1
	struct drm_memrange handle_mm;
a825 18
/* Memrange functions for managing aperture space */
struct drm_memrange_node
		*drm_memrange_get_block(struct drm_memrange_node *,
		     unsigned long, unsigned);
void		 drm_memrange_put_block(struct drm_memrange_node *);
struct drm_memrange_node
		*drm_memrange_search_free(const struct drm_memrange *,
		     unsigned long, unsigned, int);
int		 drm_memrange_init(struct drm_memrange *, unsigned long,
		     unsigned long);
void		 drm_memrange_takedown(struct drm_memrange *);
int		 drm_memrange_clean(struct drm_memrange *);
unsigned long	 drm_memrange_tail_space(struct drm_memrange *);
int		 drm_memrange_remove_space_from_tail(struct drm_memrange *,
		     unsigned long);
int		 drm_memrange_add_space_to_tail(struct drm_memrange *,
		     unsigned long );

d844 1
a844 1
		if (offset == map->mm->start)
@


1.38
log
@Instead of having a number of malloced arrays for vblank handling, just
put them in a structure and malloc free an array of those, it is nicer
that way and They're all needed at the same time, anyway.

Idea taken from a suggestion on the dri-devel mailing list.
@
text
@a484 3
#if 0 /* unneeded for now, signal support */
	TAILQ_HEAD(vbl_sigs);
#endif
a492 8
TAILQ_HEAD(drm_vbl_sig_list, drm_vbl_sig);
typedef struct drm_vbl_sig {
	TAILQ_ENTRY(drm_vbl_sig) link;
	unsigned int	sequence;
	int		signo;
	int		pid;
} drm_vbl_sig_t;

a644 1
	atomic_t		 vbl_signal_pending;	/* No. pending sigs */
a740 1
void	drm_vbl_send_signals(struct drm_device *, int);
@


1.37
log
@Another dead struct member.
@
text
@d484 12
d653 7
a659 16
	int		 vblank_disable_allowed;
	int		*vbl_queue;	/* vbl wait channel */
	atomic_t	*_vblank_count;	/* no vblank interrupts */
	DRM_SPINTYPE	vbl_lock;	/* locking for vblank operations */
#if 0 /* unneeded for now */
	TAILQ_HEAD(vbl_sigs);
#endif
	atomic_t	vbl_signal_pending; /* sigs pending on all crtcs */
	atomic_t	*vblank_refcount; /* no. users for vlank interrupts */
	u_int32_t	*last_vblank;	/* locked, used for overflow handling*/
	int		*vblank_enabled; /* make sure we only disable once */
	int		*vblank_inmodeset; /* X DDX is currently setting mode */
	struct timeout	vblank_disable_timer;
	int		num_crtcs;	/* number of crtcs on device */

	u_int32_t	max_vblank_count; /* size of counter reg */
@


1.36
log
@kill struct drm_freelist, after removing markbufs and infobufs nothing
touches it.
@
text
@a329 1
	struct drm_buf	  *next;       /* Kernel-only: used for free list    */
@


1.35
log
@Kill a dead function and a dead struct member.
@
text
@a346 9
typedef struct drm_freelist {
	int		  initialized; /* Freelist in use		   */
	atomic_t	  count;       /* Number of free buffers	   */
	drm_buf_t	  *next;       /* End pointer			   */

	int		  low_mark;    /* Low water mark		   */
	int		  high_mark;   /* High water mark		   */
} drm_freelist_t;

a362 2

	drm_freelist_t	  freelist;
@


1.34
log
@Kill the infobufs and markbufs calls. Nothing uses them.
@
text
@d482 12
a493 15
	unsigned long	offset;	 /* Physical address (0 for SAREA)*/
	unsigned long	size;	 /* Physical size (bytes)	    */
	drm_map_type_t	type;	 /* Type of memory mapped		    */
	drm_map_flags_t flags;	 /* Flags				    */
	void		*handle; /* User-space: "Handle" to pass to mmap    */
				 /* Kernel-space: kernel-virtual address    */
	int		mtrr;	 /* Boolean: MTRR used */
				 /* Private data			    */
	int		rid;	 /* PCI resource ID for bus_space */
	struct vga_pci_bar	*bsr;
	bus_space_tag_t bst;
	bus_space_handle_t bsh;
	drm_dma_handle_t *dmah;
	TAILQ_ENTRY(drm_local_map) link;
	struct drm_memrange_node *mm;
a906 4
}

static __inline__ void drm_core_dropmap(struct drm_map *map)
{
@


1.33
log
@kill the stupid pci capability defines, we have our own. Don't wrap
pci_read_capability while i'm at it.
@
text
@a839 2
int	drm_infobufs(struct drm_device *, void *, struct drm_file *);
int	drm_markbufs(struct drm_device *, void *, struct drm_file *);
@


1.32
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@a195 9
/* Capabilities taken from src/sys/dev/pci/pcireg.h. */
#ifndef PCIY_AGP
#define PCIY_AGP	0x02
#endif

#ifndef PCIY_EXPRESS
#define PCIY_EXPRESS	0x10
#endif

@


1.31
log
@Kill file_priv->refs, it is always 1. Also  move two things from the
softc into file_priv since otherwise the wrong value could rarely be
used.
@
text
@d273 1
a273 1
ret = 0;								\
@


1.30
log
@Change the drm_lock*() api to take a pointer to the struct as a
parameter, this makes things a little cleaner and removes the need to
pass in the softc for some functions.
@
text
@d387 11
a397 10
	TAILQ_ENTRY(drm_file) link;
	int		  authenticated;
	int		  master;
	int		  minor;
	pid_t		  pid;
	uid_t		  uid;
	int		  refs;
	drm_magic_t	  magic;
	unsigned long	  ioctl_count;
	void		 *driver_priv;
a613 1
	dev_t		kdev; 		/* used by uvm_mmap, this is just a placeholder */
a616 3

	int		  flags;	/* Flags to open(2)		   */

@


1.29
log
@idgen32 wasn't really right here. Change back to how it was, but
done a little nicer.

Advice from deraadt@@.
@
text
@d399 7
a405 6
typedef struct drm_lock_data {
	drm_hw_lock_t	  *hw_lock;	/* Hardware lock		   */
	struct drm_file   *file_priv;   /* Unique identifier of holding process (NULL is kernel)*/
	int		  lock_queue;	/* Queue of blocked processes	   */
	unsigned long	  lock_time;	/* Time of last lock in jiffies	   */
} drm_lock_data_t;
d647 1
a647 1
	drm_lock_data_t	  lock;		/* Information on hardware lock	   */
d746 3
a748 5
int	drm_lock_take(__volatile__ unsigned int *, unsigned int);
int	drm_lock_transfer(struct drm_device *, __volatile__ unsigned int *,
	    unsigned int);
int	drm_lock_free(struct drm_device *, __volatile__ unsigned int *,
	    unsigned int);
@


1.28
log
@Generate the magic id using idgen32(). While i'm here fix the locking a
bit so we don't sleep with a spinlock.

ok djm@@.
@
text
@a68 1
#include <crypto/idgen.h>
d637 1
a637 1
	struct idgen32_ctx magicid;
@


1.27
log
@Kill a bunch of the drm context code that nothing uses anymore, the
xserver only actually uses a small part of it nowadays.

Kill a few other dead bits from the drmP.h while i'm here.
@
text
@d69 1
d638 1
@


1.26
log
@Update to DRM git.

Some stability fixes for radeon. The most part of this diff is related
to fixing up the VBLANK (vertical blank interrupt) handling. Now, if the
X driver supports the DRM_IOCTL_MODESET_CTL ioctl, (to be used when
changing the video modes), then allow the vblank to be disabled once
that ioctl has been called. Otherwise, keep the interrupt enabled at all
time, since disabling it otherwise will lead to problems.

Tested by a few. "no problem" on API/ABI deraadt@@.
@
text
@a260 4
#define DRM_GET_PRIV_SAREA(_dev, _ctx, _map) do {	\
	(_map) = (_dev)->context_sareas[_ctx];		\
} while(0)

d523 1
a523 1
#define upper_32_bits(_val) (((u64)(_val)) >> 32)
a545 1
	void	(*dma_ready)(struct drm_device *);
a546 4
	int	(*dma_flush_block_and_flush)(struct drm_device *, int,
		    drm_lock_flags_t);
	int	(*dma_flush_unblock)(struct drm_device *, int,
		    drm_lock_flags_t);
a548 2
	int	(*kernel_context_switch)(struct drm_device *, int, int);
	int	(*kernel_context_switch_unlock)(struct drm_device *);
a642 1
	drm_local_map_t	  **context_sareas;
a664 3
	atomic_t	  context_flag;	/* Context swapping flag	   */
	int		  last_context;	/* Last current context		   */

a731 3
int	drm_context_switch(struct drm_device *, int, int);
int	drm_context_switch_complete(struct drm_device *, int);

a830 1
int	drm_modctx(struct drm_device *, void *, struct drm_file *);
a831 2
int	drm_switchctx(struct drm_device *, void *, struct drm_file *);
int	drm_newctx(struct drm_device *, void *, struct drm_file *);
a832 2
int	drm_setsareactx(struct drm_device *, void *, struct drm_file *);
int	drm_getsareactx(struct drm_device *, void *, struct drm_file *);
@


1.25
log
@Switch all instances of malloc/free in the DRM to drm_alloc, drm_free
and drm_calloc.

With the recent change to check overflow in drm_calloc, this means that
all allocations that require multiplication are now checked. Also use
drm_calloc() when zeroing is needed and drop the bzero/memset
afterwards.  Finally, make drm_free() check for NULL, so we don't need
to do so every time.

ok miod@@, deraadt@@
@
text
@d681 1
d692 1
a692 2
	u_int32_t	*vblank_premodeset; /* compensation for wraparounds */
	int		*vblank_suspend; /* Don't wait while crtc is disabled */
a798 1
void	drm_update_vblank_count(struct drm_device *, int);
d926 1
@


1.24
log
@the DRM_{READ,WRITE}$NUMBER() macros currently use
bus_space_{read,write}(). A bug in the code this was based on means that
this is also used for scatter gather maps, which are bus_dma memory, not
pci memory.  This obviously fails. Pull them out into a function and
Special case scatter gather to use the mapped virtual address to write
instead. Makes writeback test pass on pci and pci express radeon cards.

Tested by, among others ckuethe@@ and sthen@@.
@
text
@d82 23
a104 22
#define DRM_MEM_DMA	   0
#define DRM_MEM_SAREA	   1
#define DRM_MEM_DRIVER	   2
#define DRM_MEM_MAGIC	   3
#define DRM_MEM_IOCTLS	   4
#define DRM_MEM_MAPS	   5
#define DRM_MEM_BUFS	   6
#define DRM_MEM_SEGS	   7
#define DRM_MEM_PAGES	   8
#define DRM_MEM_FILES	  9
#define DRM_MEM_QUEUES	  10
#define DRM_MEM_CMDS	  11
#define DRM_MEM_MAPPINGS  12
#define DRM_MEM_BUFLISTS  13
#define DRM_MEM_AGPLISTS  14
#define DRM_MEM_TOTALAGP  15
#define DRM_MEM_BOUNDAGP  16
#define DRM_MEM_CTXBITMAP 17
#define DRM_MEM_STUB	  18
#define DRM_MEM_SGLISTS	  19
#define DRM_MEM_DRAWABLE  20
#define DRM_MEM_MM	21
a374 1
	bus_addr_t dmaaddr;
@


1.23
log
@The current drm_locked_task*() code sometimes tries to sleep in an
interrupt handler.

This is bad and wrong. So change it so that if we can't immediately grab
the hardware lock, to just leave the task flagged so that we can run it
when we release the lock. The linux implementation uses a similar
scheme.

Tested by guenther@@, landry@@ and bernd@@. Also tested by many a while
ago as part of a larger diff.
@
text
@d232 6
a237 12
#define DRM_READ8(map, offset)		\
	bus_space_read_1( (map)->bst, (map)->bsh, (offset))
#define DRM_READ16(map, offset)		\
	bus_space_read_2( (map)->bst, (map)->bsh, (offset))
#define DRM_READ32(map, offset)		\
	bus_space_read_4( (map)->bst, (map)->bsh, (offset))
#define DRM_WRITE8(map, offset, val)	\
	bus_space_write_1((map)->bst, (map)->bsh, (offset), (val))
#define DRM_WRITE16(map, offset, val)	\
	bus_space_write_2((map)->bst, (map)->bsh, (offset), (val))
#define DRM_WRITE32(map, offset, val)	\
	bus_space_write_4((map)->bst, (map)->bsh, (offset), (val))
d754 6
@


1.22
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d641 1
@


1.21
log
@Kill the device_t and vm_offset_t typedefs.
@
text
@a38 2
typedef struct drm_device drm_device_t;
typedef struct drm_file drm_file_t;
d149 1
a149 1
extern drm_device_t *drm_units[];
d317 2
d324 1
a324 1
	int (*func)(drm_device_t *dev, void *data, struct drm_file *file_priv);
d416 6
a421 6
/* This structure, in the drm_device_t, is always initialized while the device
 * is open.  dev->dma_lock protects the incrementing of dev->buf_use, which
 * when set marks that no further bufs may be allocated until device teardown
 * occurs (when the last open of the device has closed).  The high/low
 * watermarks of bufs are only touched by the X Server, and thus not
 * concurrently accessed, so no locking is needed.
d546 1
a546 1
	int	(*load)(struct drm_device *, unsigned long flags);
d548 3
a550 3
	int	(*open)(struct drm_device *, drm_file_t *);
	void	(*preclose)(struct drm_device *, struct drm_file *file_priv);
	void	(*postclose)(struct drm_device *, drm_file_t *);
d554 2
a555 2
					  struct drm_file *file_priv);
	int	(*dma_ioctl)(drm_device_t *dev, void *data, struct drm_file *file_priv);
d558 11
a568 12
	int	(*dma_flush_block_and_flush)(struct drm_device *, int context,
					     drm_lock_flags_t flags);
	int	(*dma_flush_unblock)(struct drm_device *, int context,
				     drm_lock_flags_t flags);
	int	(*context_ctor)(struct drm_device *dev, int context);
	int	(*context_dtor)(struct drm_device *dev, int context);
	int	(*kernel_context_switch)(struct drm_device *dev, int old,
					 int new);
	int	(*kernel_context_switch_unlock)(struct drm_device *dev);
	void	(*irq_preinstall)(drm_device_t *dev);
	int	(*irq_postinstall)(drm_device_t *dev);
	void	(*irq_uninstall)(drm_device_t *dev);
d716 1
a716 1
	void		  (*locked_task_call)(drm_device_t *dev);
d733 1
a733 1
extern drm_local_map_t	*drm_getsarea(drm_device_t *);
d737 2
a738 2
		    DRM_STRUCTPROC *, drm_device_t *);
drm_file_t	*drm_find_file_by_minor(drm_device_t *, int);
d743 16
a758 17
void	*drm_alloc(size_t size, int area);
void	*drm_calloc(size_t nmemb, size_t size, int area);
void	*drm_realloc(void *oldpt, size_t oldsize, size_t size,
				   int area);
void	drm_free(void *pt, size_t size, int area);
void	*drm_ioremap(drm_device_t *dev, drm_local_map_t *map);
void	drm_ioremapfree(drm_local_map_t *map);
int	drm_mtrr_add(unsigned long offset, size_t size, int flags);
int	drm_mtrr_del(int handle, unsigned long offset, size_t size, int flags);

int	drm_context_switch(drm_device_t *dev, int old, int new);
int	drm_context_switch_complete(drm_device_t *dev, int new);

int	drm_ctxbitmap_init(drm_device_t *dev);
void	drm_ctxbitmap_cleanup(drm_device_t *dev);
void	drm_ctxbitmap_free(drm_device_t *dev, int ctx_handle);
int	drm_ctxbitmap_next(drm_device_t *dev);
d761 5
a765 8
int	drm_lock_take(__volatile__ unsigned int *lock,
				    unsigned int context);
int	drm_lock_transfer(drm_device_t *dev,
					__volatile__ unsigned int *lock,
					unsigned int context);
int	drm_lock_free(drm_device_t *dev,
				    __volatile__ unsigned int *lock,
				    unsigned int context);
d768 4
a771 4
unsigned long drm_get_resource_start(drm_device_t *dev, unsigned int resource);
unsigned long drm_get_resource_len(drm_device_t *dev, unsigned int resource);
void	drm_rmmap(drm_device_t *dev, drm_local_map_t *map);
int	drm_order(unsigned long size);
d774 5
a778 6
int	drm_addmap(drm_device_t * dev, unsigned long offset, unsigned long size,
		   drm_map_type_t type, drm_map_flags_t flags,
		   drm_local_map_t **map_ptr);
int	drm_addbufs_pci(drm_device_t *dev, drm_buf_desc_t *request);
int	drm_addbufs_sg(drm_device_t *dev, drm_buf_desc_t *request);
int	drm_addbufs_agp(drm_device_t *dev, drm_buf_desc_t *request);
d781 4
a784 4
int	drm_dma_setup(drm_device_t *dev);
void	drm_dma_takedown(drm_device_t *dev);
void	drm_free_buffer(drm_device_t *dev, drm_buf_t *buf);
void	drm_reclaim_buffers(drm_device_t *dev, struct drm_file *file_priv);
d788 2
a789 2
int	drm_irq_install(drm_device_t *dev);
int	drm_irq_uninstall(drm_device_t *dev);
d791 4
a794 4
void	drm_driver_irq_preinstall(drm_device_t *dev);
void	drm_driver_irq_postinstall(drm_device_t *dev);
void	drm_driver_irq_uninstall(drm_device_t *dev);
void	drm_vbl_send_signals(drm_device_t *dev, int crtc);
d801 1
a801 1
int	drm_modeset_ctl(struct drm_device *dev, void *, struct drm_file *);
d805 2
a806 2
int	drm_device_is_agp(drm_device_t *dev);
int	drm_device_is_pcie(drm_device_t *dev);
d808 12
a819 12
int	drm_agp_acquire(drm_device_t *dev);
int	drm_agp_release(drm_device_t *dev);
int	drm_agp_info(drm_device_t * dev, drm_agp_info_t *info);
int	drm_agp_enable(drm_device_t *dev, drm_agp_mode_t mode);
void	*drm_agp_allocate_memory(size_t pages, u32 type);
int	drm_agp_free_memory(void *handle);
int	drm_agp_bind_memory(void *handle, off_t start);
int	drm_agp_unbind_memory(void *handle);
int	drm_agp_alloc(drm_device_t *dev, drm_agp_buffer_t *request);
int	drm_agp_free(drm_device_t *dev, drm_agp_buffer_t *request);
int	drm_agp_bind(drm_device_t *dev, drm_agp_binding_t *request);
int	drm_agp_unbind(drm_device_t *dev, drm_agp_binding_t *request);
d822 2
a823 2
void	drm_sg_cleanup(drm_sg_mem_t *entry);
int	drm_sg_alloc(drm_device_t * dev, drm_scatter_gather_t * request);
d826 4
a829 2
int	drm_ati_pcigart_init(drm_device_t *, struct drm_ati_pcigart_info *);
int	drm_ati_pcigart_cleanup(drm_device_t *, struct drm_ati_pcigart_info *);
d832 4
a835 4
int	drm_lock(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_unlock(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_version(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_setversion(drm_device_t *dev, void *data, struct drm_file *file_priv);
d838 7
a844 7
int	drm_irq_by_busid(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getunique(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_setunique(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getmap(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getclient(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getstats(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_noop(drm_device_t *dev, void *data, struct drm_file *file_priv);
d847 9
a855 9
int	drm_resctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_addctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_modctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_switchctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_newctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_rmctx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_setsareactx(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_getsareactx(drm_device_t *dev, void *data, struct drm_file *file_priv);
d858 3
a860 3
int	drm_adddraw(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_rmdraw(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_update_draw(drm_device_t *dev, void *data, struct drm_file *file_priv);
d862 2
a863 2
struct drm_drawable_info	*drm_get_drawable_info(drm_device_t *dev,
				    unsigned int handle);
d866 2
a867 2
int	drm_getmagic(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_authmagic(drm_device_t *dev, void *data, struct drm_file *file_priv);
d872 7
a878 7
int	drm_addmap_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_rmmap_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_addbufs_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_infobufs(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_markbufs(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_freebufs(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_mapbufs(drm_device_t *dev, void *data, struct drm_file *file_priv);
d881 1
a881 1
int	drm_dma(drm_device_t *dev, void *data, struct drm_file *file_priv);
d884 3
a886 3
int	drm_control(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_wait_vblank(drm_device_t *dev, void *data, struct drm_file *file_priv);
void	drm_locked_tasklet(drm_device_t *dev, void (*tasklet)(drm_device_t *dev));
d889 8
a896 8
int	drm_agp_acquire_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_release_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_enable_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_info_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_alloc_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_free_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_unbind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_agp_bind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
d899 2
a900 2
int	drm_sg_alloc_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv);
int	drm_sg_free(drm_device_t *dev, void *data, struct drm_file *file_priv);
d903 3
a905 3
drm_dma_handle_t *drm_pci_alloc(drm_device_t *dev, size_t size, size_t align,
				dma_addr_t maxaddr);
void	drm_pci_free(drm_device_t *dev, drm_dma_handle_t *dmah);
@


1.20
log
@Since we're not ifdefed anymore, change
drm_{open,close,poll,read,mmap,ioctl} into the form that cdev_decl()
likes, and nuke the #defines.
@
text
@a194 1
typedef drm_device_t *device_t;
a233 2
typedef vaddr_t vm_offset_t;

d445 11
a455 11
	device_t	   agpdev;
	struct agp_info    info;
	const char         *chipset;
	TAILQ_HEAD(agp_memlist, drm_agp_mem) memory;
	unsigned long      mode;
	int                enabled;
	int                acquired;
	unsigned long      base;
   	int 		   mtrr;
	int		   cant_use_aperture;
	unsigned long	   page_mask;
@


1.19
log
@Kill the ifdefs in drmP.h too, it's meant to be os specific.

While i'm here cleanup some duplicated #includes and reorder slightly.
@
text
@a155 11
/*
 * cdev_decl() doesn't like underscore separated names.
 * doing this here is easier that ifdefing each of them.
 */
#define drm_ioctl drmioctl
#define drm_open drmopen
#define drm_close drmclose
#define drm_read drmread
#define drm_poll drmpoll
#define drm_mmap drmmmap

d727 11
a737 11
void	drm_attach(struct device *kdev, struct device *parent,
	    struct pci_attach_args *pa, drm_pci_id_list_t *idlist);
int	drm_detach(struct device *self, int flags);
int	drm_activate(struct device *self, enum devact act);
dev_type_ioctl(drm_ioctl);
dev_type_open(drm_open);
dev_type_close(drm_close);
dev_type_read(drm_read);
dev_type_poll(drm_poll);
dev_type_mmap(drm_mmap);
extern drm_local_map_t	*drm_getsarea(drm_device_t *dev);
@


1.18
log
@Kill drm_sysctl.c and all references to it.

All the code was ifdefed out anyway and it wasn't really useful.
@
text
@d52 1
a52 1
#include <sys/lock.h>
a53 1
#include <sys/uio.h>
a57 7
#include <machine/param.h>
#include <machine/bus.h>
#include <machine/param.h>
#include <machine/bus.h>
#if !defined(DRM_NO_MTRR)
#include <machine/sysarch.h>
#endif
a59 2
#include <sys/types.h>
#include <sys/conf.h>
a60 2
#include <sys/malloc.h>
#include <machine/bus.h>
d64 1
a65 1
#include <uvm/uvm.h>
d69 2
a70 1
#include <dev/pci/pcivar.h>
a80 27
#if defined(__FreeBSD__) || defined(__NetBSD__) 
#include <opt_drm.h>
#endif
#ifdef DRM_DEBUG
#undef DRM_DEBUG
#define DRM_DEBUG_DEFAULT_ON 1
#endif /* DRM_DEBUG */

#ifndef __Linux__
/* stop the linux version tests breaking the compile */
#define LINUX_VERSION_CODE 500
#define KERNEL_VERSION(a,b,c)0 
#endif

#if defined(DRM_LINUX) && DRM_LINUX && !defined(__amd64__)
#include <sys/file.h>
#include <sys/proc.h>
#include <machine/../linux/linux.h>
#include <machine/../linux/linux_proto.h>
#else
/* Either it was defined when it shouldn't be (FreeBSD amd64) or it isn't
 * supported on this OS yet.
 */
#undef DRM_LINUX
#define DRM_LINUX 0
#endif

a115 4
#ifndef __OpenBSD__
MALLOC_DECLARE(M_DRM);
#endif

a126 43
#if defined(__FreeBSD__) && __FreeBSD_version < 502109
#define bus_alloc_resource_any(dev, type, rid, flags) \
	bus_alloc_resource(dev, type, rid, 0ul, ~0ul, 1, flags)
#endif

#if defined(__FreeBSD__) && __FreeBSD_version >= 500000
#define DRM_CDEV		struct cdev *
#define DRM_CURPROC		curthread
#define DRM_STRUCTPROC		struct thread
#define DRM_PROC(p)		(p)
#define DRM_SPINTYPE		struct mtx
#define DRM_SPININIT(l,name)	mtx_init(l, name, NULL, MTX_DEF)
#define DRM_SPINUNINIT(l)	mtx_destroy(l)
#define DRM_SPINLOCK(l)		mtx_lock(l)
#define DRM_SPINUNLOCK(u)	mtx_unlock(u)
#define DRM_SPINLOCK_ASSERT(l)	mtx_assert(l, MA_OWNED)
#define DRM_PID(p)		(p)->td_proc->p_pid
#define DRM_CURRENTPID		DRM_PID(curthread)
#define DRM_UID(p)		(p)->td_ucred->cr_svuid
#define DRM_LOCK()		mtx_lock(&dev->dev_lock)
#define DRM_UNLOCK() 		mtx_unlock(&dev->dev_lock)
#define DRM_SYSCTL_HANDLER_ARGS	(SYSCTL_HANDLER_ARGS)
#else /* __FreeBSD__ && __FreeBSD_version >= 500000 */
#ifdef __NetBSD__
#define DRM_CDEV		dev_t
#define DRM_CURPROC		curproc
#define DRM_STRUCTPROC		struct proc
#define DRM_SPINTYPE		struct simplelock
#define DRM_SPININIT(l,name)	simple_lock_init(&l)
#define DRM_SPINUNINIT(l)	DRM_NOOP
#define DRM_SPINLOCK(l)		if(!simple_lock_try(l)) simple_lock(l)
#define DRM_SPINUNLOCK(u)	simple_unlock(u)
#define DRM_SPINLOCK_ASSERT(l)	DRM_NOOP
#define DRM_LOCK()		DRM_SPINLOCK(&dev->dev_lock)
#define DRM_UNLOCK() 		DRM_SPINUNLOCK(&dev->dev_lock)
#define DRM_SLEEPLOCK(v,l,f,s,i)	ltsleep(v,f,s,i,l);
#define spldrm()		spltty()
#define DRM_PID(p)		(p)->p_pid
#define DRM_CURRENTPID		DRM_PID(curproc)
#define DRM_UID(p)		kauth_cred_getsvuid((p)->p_cred)
#define DRM_SYSCTL_HANDLER_ARGS	(SYSCTLFN_ARGS)
#else
#ifdef __OpenBSD__ 
d138 5
a149 1
/* Number of DRM devices at any one time. If you have more than this, i want to see your setup */
d152 1
a152 3
/* XXX fixme */
#define DRM_SYSCTL_HANDLER_ARGS	(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp, \
    size_t newlen, struct proc *p)
d166 1
a166 8
#endif /* __OpenBSD__ */
#endif /* __NetBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */
#define DRM_SPINLOCK_IRQSAVE(l, irqflags) do {		\
	DRM_SPINLOCK(l);				\
	(void)irqflags;					\
} while (0)
#define DRM_SPINUNLOCK_IRQRESTORE(u, irqflags) DRM_SPINUNLOCK(u)
a168 5
#ifdef __FreeBSD__
typedef void			irqreturn_t;
#define IRQ_HANDLED		/* nothing */
#define IRQ_NONE		/* nothing */
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a171 1
#endif
a179 5
#if defined(__FreeBSD__)
#define drm_get_device_from_kdev(_kdev) (_kdev->si_drv1)
#elif defined(__NetBSD__)
#define drm_get_device_from_kdev(_kdev) device_lookup(&drm_cd, minor(_kdev))
#elif defined(__OpenBSD__)
a189 1
#endif /* __FreeBSD__ / __NetBSD__ / __OpenBSD__ */
a190 11
#ifdef __FreeBSD__
#define PAGE_ALIGN(addr) round_page(addr)
#if __FreeBSD_version >= 700000
/* DRM_SUSER returns true if the user is superuser */
#define DRM_SUSER(p)		(priv_check(p, PRIV_DRIVER) == 0)
#else
#define DRM_SUSER(p)		(suser(p) == 0)
#endif
#define DRM_AGP_FIND_DEVICE()	agp_find_device()
#define DRM_MTRR_WC		MDF_WRITECOMBINE
#define jiffies			ticks
a191 10
#else /* __FreeBSD__ */

#if defined(__NetBSD__)
#define DRM_SUSER(p)		(kauth_cred_getsvuid((p)->p_cred) == 0)
#define DRM_MAXUNITS 128
extern drm_device_t *drm_units[];
#define jiffies			hardclock_ticks
#define CDEV_MAJOR		34
#define DRM_MTRR_WC		MTRR_TYPE_WC
#elif defined(__OpenBSD__)
a196 1
#endif /* __OpenBSD__ */
a207 1
#endif /* !__FreeBSD__ */
a245 19
#ifdef __FreeBSD__
#define DRM_READ8(map, offset)						\
	*(volatile u_int8_t *) (((unsigned long)(map)->handle) + (offset))
#define DRM_READ16(map, offset)						\
	*(volatile u_int16_t *) (((unsigned long)(map)->handle) + (offset))
#define DRM_READ32(map, offset)						\
	*(volatile u_int32_t *)(((unsigned long)(map)->handle) + (offset))
#define DRM_WRITE8(map, offset, val)					\
	*(volatile u_int8_t *) (((unsigned long)(map)->handle) + (offset)) = val
#define DRM_WRITE16(map, offset, val)					\
	*(volatile u_int16_t *) (((unsigned long)(map)->handle) + (offset)) = val
#define DRM_WRITE32(map, offset, val)					\
	*(volatile u_int32_t *)(((unsigned long)(map)->handle) + (offset)) = val

#define DRM_VERIFYAREA_READ( uaddr, size )		\
	(!useracc(__DECONST(caddr_t, uaddr), size, VM_PROT_READ))

#else /* __FreeBSD__ */

a263 1
#endif /* !__FreeBSD__ */
a272 4
#if __FreeBSD_version > 500000
#define DRM_GET_USER_UNCHECKED(val, uaddr)		\
	((val) = fuword32(uaddr), 0)
#else
a274 2
#endif
#ifdef __OpenBSD__
a275 3
#else
#define le32_to_cpu(x) le32toh(x)
#endif
a295 1
#if defined(__OpenBSD__) || (defined(__FreeBSD__) && __FreeBSD_version > 500000)
a310 11
#else
/* Returns -errno to shared code */
#define DRM_WAIT_ON( ret, queue, timeout, condition )	\
for ( ret = 0 ; !ret && !(condition) ; ) {		\
        int s = spldrm();				\
	if (!(condition))				\
	   ret = -tsleep( &(queue), PZERO | PCATCH, 	\
			 "drmwtq", (timeout) );		\
	splx(s);					\
}
#endif
a390 4
#if defined(__FreeBSD__)
	bus_dma_tag_t tag;
	bus_dmamap_t map;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a395 1
#endif
a471 1
#ifdef __OpenBSD__
a479 1
#endif
a486 1
#ifdef __OpenBSD__
a487 1
#endif
a521 3
#ifdef __FreeBSD__
	struct resource *bsr;
#else
a522 1
#endif
a633 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a634 1
#endif
a643 5
#ifdef __FreeBSD__
	device_t	  device;	/* Device instance from newbus     */
	struct cdev	  *devnode;	/* Device number for mknod	   */
#endif
#ifdef __OpenBSD__
a645 1
#endif
a651 1
#if (defined(__FreeBSD__) && __FreeBSD_version > 500000) || defined __NetBSD__ || defined __OpenBSD__
a655 1
#endif
a684 4
#ifdef __FreeBSD__
	int		  irqrid;	/* Interrupt used by board */
	struct resource   *irqr;	/* Resource for interrupt used by board	   */
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a686 1
#endif
a689 4
#ifdef __FreeBSD__
	struct resource   *pcir[DRM_MAX_PCI_RESOURCE];
	int		  pcirid[DRM_MAX_PCI_RESOURCE];
#else
a690 1
#endif
a717 3
#ifdef __FreeBSD__
	struct sigio      *buf_sigio;	/* Processes waiting for SIGIO     */
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a718 1
#endif
a726 3
#ifdef __FreeBSD__
	struct unrhdr	  *drw_unrhdr;
#else
a727 1
#endif
a730 3
#if defined(__FreeBSD__)
	struct task	  locked_task;
#endif
a736 11
#ifdef __FreeBSD__
int	drm_probe(device_t nbdev, drm_pci_id_list_t *idlist);
int	drm_attach(device_t nbdev, drm_pci_id_list_t *idlist);
int	drm_detach(device_t nbdev);
d_ioctl_t drm_ioctl;
d_open_t drm_open;
d_close_t drm_close;
d_read_t drm_read;
d_poll_t drm_poll;
d_mmap_t drm_mmap;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a747 1
#endif
a752 1
#ifdef __OpenBSD__
a753 3
#else
drm_file_t	*drm_find_file_by_proc(drm_device_t *, DRM_STRUCTPROC *);
#endif
@


1.17
log
@The mmap offsets for memory buffers currently are the kernel virtual
address.  This is just plain wrong. scatter/gather on amd64 didn't work
here, since char device mmap doesn't take negative offsets so higher
kvas fail.

Instead, prematurely import drm_memrange which is needed for the memory
managers (GEM or TTM), and is used to manage GART space. Then, horribly
abuse it to allocate mmap offsets, fixes up the issues.

"just commit it" art@@.
@
text
@a48 3
#if __FreeBSD_version >= 700000
#include <sys/priv.h>
#endif
d50 2
a55 12
#include <sys/sysctl.h>
#ifdef __FreeBSD__
#include <sys/bus.h>
#include <sys/module.h>
#include <sys/taskqueue.h>
#include <vm/vm.h>
#include <vm/pmap.h>
#include <vm/vm_extern.h>
#include <vm/vm_map.h>
#include <vm/vm_param.h>
#include <machine/resource.h>
#endif
a59 1
#include <machine/pmap.h>
a67 31
#if defined(__FreeBSD__)
#include <sys/rman.h>
#include <dev/pci/agpvar.h>
#include <sys/memrange.h>
#include <sys/agpio.h>
#if __FreeBSD_version >= 500000
#include <sys/mutex.h>
#include <sys/selinfo.h>
#else /* __FreeBSD_version >= 500000 */
#include <dev/pci/pcivar.h>
#include <sys/select.h>
#endif /* __FreeBSD_version < 500000 */
#elif defined(__NetBSD__)
#ifndef DRM_NO_MTRR
#include <machine/mtrr.h>
#endif
#include <sys/vnode.h>
#include <sys/select.h>
#include <sys/device.h>
#include <sys/resourcevar.h>
#include <sys/agpio.h>
#include <sys/ttycom.h>
#include <sys/mman.h>
#include <sys/kauth.h>
#include <sys/types.h>
#include <sys/file.h>
#include <uvm/uvm.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/agpvar.h>
#elif defined(__OpenBSD__)
a81 1
#endif
a922 3
				/* Sysctl support */
	struct drm_sysctl_info *sysctl;

a1069 6

#if defined(__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__)
/* sysctl support (drm_sysctl.h) */
extern int		drm_sysctl_init(drm_device_t *dev);
extern int		drm_sysctl_cleanup(drm_device_t *dev);
#endif /* __FreeBSD__ */
@


1.16
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d189 1
d711 20
d752 1
d906 1
d1066 2
d1206 18
d1241 1
a1241 1
		if (map->offset == offset)
@


1.15
log
@Make *drm(4) use D_CLONE so that the per-open data actually works. Since
i'm modifying this code anyway, prepare for privsep by making it so that
"master" openers must be root, and remove some spurious suser() checks.
For example, every DRM_ROOT_ONLY ioctl is also DRM_MASTER. Without this
change, privsep wouldn't work since the fd is no longer root owned.

With this, X privsep should work as soon as the userland bits are done
(currently unwritten).

Looked over by kettenis@@, ok thib@@.
@
text
@d132 1
d498 2
a499 1
for ( ret = 0 ; !ret && !(condition) ; ) {			\
d502 6
a507 3
	if (!(condition))					\
	   ret = -msleep(&(queue), &dev->irq_lock, 		\
			 PZERO | PCATCH, "drmwtq", (timeout));	\
a740 5
struct drm_drawable_info {
        unsigned int num_rects;
	struct drm_clip_rect *rects;
};

d749 4
a752 1
typedef struct ati_pcigart_info {
d757 1
d760 1
a760 1
} drm_ati_pcigart_info;
d785 1
a785 1
	void	(*irq_postinstall)(drm_device_t *dev);
d788 3
a790 1
	int	(*vblank_wait)(drm_device_t *dev, unsigned int *sequence);
d921 18
a938 3
   	int		  vbl_queue;	/* vbl wait channel */
   	atomic_t          vbl_received;
   	atomic_t          vbl_received2;
d1064 9
a1072 2
int	drm_vblank_wait(drm_device_t *dev, unsigned int *vbl_seq);
void	drm_vbl_send_signals(drm_device_t *dev);
d1102 2
a1103 4
int	drm_ati_pcigart_init(drm_device_t *dev,
			     drm_ati_pcigart_info *gart_info);
int	drm_ati_pcigart_cleanup(drm_device_t *dev,
				drm_ati_pcigart_info *gart_info);
@


1.14
log
@return 1 when an irq's been handled, not 0.
@
text
@d325 5
d335 2
d978 7
a984 4
int		drm_open_helper(DRM_CDEV kdev, int flags, int fmt, 
					 DRM_STRUCTPROC *p, drm_device_t *dev);
extern drm_file_t	*drm_find_file_by_proc(drm_device_t *dev, 
					 DRM_STRUCTPROC *p);
@


1.13
log
@Since the vtophys stuff was nuked, drm now works on amd64 too. Add the
relavent config goo.

DRM_NO_MTRR is still needed on amd64 since the mtrr apis differ between
it and i386.

ok kettenis@@.
@
text
@d309 1
a309 1
#define IRQ_HANDLED		0
@


1.12
log
@When i first ported the drm, i completely misunderstood the FreeBSD taskqueue
api. So drm_locked_tasklet() is wrong.

Fix this up to be at least mostly correct.
@
text
@d133 4
@


1.11
log
@Fix jiffies.
@
text
@d934 1
a935 5
#elif defined(__OpenBSD__)
	void		  (*locked_task_call)(void*, void*);
#else
	/* add for other OSen */
#endif
d1120 1
a1120 7
#ifdef __FreeBSD__
void	drm_locked_tasklet(drm_device_t *dev,
			   void (*tasklet)(drm_device_t *dev));
#else
void 	drm_locked_tasklet(drm_device_t *dev,
		void (*tasklet)(void *dev, void*));
#endif
@


1.10
log
@Kill vtophys in drm.

The code we inherited from FreeBSD used vtophys is a fair few places,
nuke that and replace with bus_dma. technically _DRM_SHM should be
managed with uao_create(), but until we move away from mmap and into an
ioctl to map, this will do.

This also paves the way for amd64 support (it lacks vtophys).

ok kettenis, miod looked at it a while back too.
@
text
@d350 2
a351 1
#define jiffies			0
@


1.9
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d671 11
d688 3
@


1.8
log
@Replace handrolled hashes with a splay tree, while there plug a memleak
inherited from the original drm driver.

input and ok oga@@.
@
text
@a678 12
#if defined(__NetBSD__) || defined(__OpenBSD__)
typedef struct {
	int			mapped;
	int			maptype;
	bus_addr_t		base;
	bus_size_t		size;
	bus_space_handle_t	bsh;
	int			flags;
	void *			vaddr;
} pci_map_data_t;
#endif

d694 1
a694 1
	pci_map_data_t	*bsr;
d823 1
d877 1
d879 1
a879 1
	pci_map_data_t	  *pcir[DRM_MAX_PCI_RESOURCE];
a880 1
	int		  pcirid[DRM_MAX_PCI_RESOURCE];
d942 2
a943 2
void	drm_attach(struct device *kdev, struct pci_attach_args *pa,
		drm_pci_id_list_t *idlist);
@


1.7
log
@just use an incremented int to calculate drawable ids. This is simpler
and causes no pointer size issues on amd64.

Tested by many.
@
text
@a159 1
#define DRM_HASH_SIZE	      16 /* Size of key hash table		  */
a541 1
typedef TAILQ_HEAD(drm_magic_list, drm_magic_entry) drm_magic_head_t;
d545 1
a545 1
	TAILQ_ENTRY(drm_magic_entry) link;
a547 1

d860 1
a860 1
	drm_magic_head_t  magiclist[DRM_HASH_SIZE];
d1102 2
@


1.6
log
@Make sure that the drawables are properly freed when removed, and upon
last close of the device nuke them all. Inspired by similar code in
the linux drm driver.

Tested by many.
@
text
@d1099 2
a1100 1
struct drm_drawable_info *drm_get_drawable_info(drm_device_t *dev, int handle);
@


1.5
log
@Switch part of the magic hashtable over to using a TAILQ instead
of a hand-rolled list. Ideally this code needs more changes, but for
now that'll do.

Tested by many.
@
text
@d1098 1
@


1.4
log
@Convert the list of agp memory over to a TAILQ instead of using a hand-
rolled list.

Tested by many
@
text
@d543 2
a544 1
typedef struct drm_magic_entry {
d547 2
a548 2
	struct drm_magic_entry *next;
} drm_magic_entry_t;
a549 4
typedef struct drm_magic_head {
	struct drm_magic_entry *head;
	struct drm_magic_entry *tail;
} drm_magic_head_t;
@


1.3
log
@drm_pci_alloc allocates memory using bus_dma, but then doesn't use dmamaps.
This is unportable to some architectures, fix it. While i'm here, kill
he defines for netbsd aprint_ and just use the DRM_* macros.

ok miod@@
@
text
@d656 1
a656 1
typedef struct drm_agp_mem {
d660 2
a661 3
	struct drm_agp_mem *prev;
	struct drm_agp_mem *next;
} drm_agp_mem_t;
d667 1
a667 1
	drm_agp_mem_t      *memory;
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@a277 2
#define aprint_error printf
#define aprint_normal printf
d595 1
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d281 1
d296 1
a296 1
	DRM_SPINLOCK(l);					\
d324 3
a326 3
#define drm_get_device_from_kdev(_kdev) 			\
      (drm_device_t *)(minor(kdev) < DRM_MAXUNITS) ?	\
		       drm_units[minor(kdev)] : NULL
@

