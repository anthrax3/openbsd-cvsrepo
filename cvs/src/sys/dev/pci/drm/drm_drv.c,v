head	1.153;
access;
symbols
	OPENBSD_6_1:1.151.0.4
	OPENBSD_6_1_BASE:1.151
	OPENBSD_6_0:1.147.0.4
	OPENBSD_6_0_BASE:1.147
	OPENBSD_5_9:1.145.0.2
	OPENBSD_5_9_BASE:1.145
	OPENBSD_5_8:1.135.0.4
	OPENBSD_5_8_BASE:1.135
	OPENBSD_5_7:1.133.0.4
	OPENBSD_5_7_BASE:1.133
	OPENBSD_5_6:1.129.0.4
	OPENBSD_5_6_BASE:1.129
	OPENBSD_5_5:1.123.0.4
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.108.0.2
	OPENBSD_5_4_BASE:1.108
	OPENBSD_5_3:1.99.0.2
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.96.0.6
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.4
	OPENBSD_5_0:1.96.0.2
	OPENBSD_5_0_BASE:1.96
	OPENBSD_4_9:1.90.0.2
	OPENBSD_4_9_BASE:1.90
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.80.0.4
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.68.0.2
	OPENBSD_4_5_BASE:1.68
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.153
date	2017.07.04.22.27.23;	author kettenis;	state Exp;
branches;
next	1.152;
commitid	CGhPq13mqtqAhxNv;

1.152
date	2017.07.01.16.00.25;	author kettenis;	state Exp;
branches;
next	1.151;
commitid	aN6GlSqZJXG1gx72;

1.151
date	2016.12.01.01.37.17;	author jsg;	state Exp;
branches;
next	1.150;
commitid	jAIt9no9E4Lu61Vs;

1.150
date	2016.11.25.23.33.39;	author jsg;	state Exp;
branches;
next	1.149;
commitid	gtvUvErtXmeQ7LXA;

1.149
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.148;
commitid	RlO92XR575sygHqm;

1.148
date	2016.08.24.09.31.56;	author dlg;	state Exp;
branches;
next	1.147;
commitid	bOHrwaZkgMMKmHmR;

1.147
date	2016.04.08.08.27.53;	author kettenis;	state Exp;
branches;
next	1.146;
commitid	mS4ttEBzpAfn3sVx;

1.146
date	2016.04.05.08.22.50;	author kettenis;	state Exp;
branches;
next	1.145;
commitid	4zEfxNVjitzOF81p;

1.145
date	2016.02.05.10.05.12;	author kettenis;	state Exp;
branches;
next	1.144;
commitid	gX0sRFu8RGimO2hC;

1.144
date	2016.01.09.11.34.57;	author kettenis;	state Exp;
branches;
next	1.143;
commitid	q7lDzA6C6al7MUbK;

1.143
date	2016.01.06.09.09.16;	author kettenis;	state Exp;
branches;
next	1.142;
commitid	nVj87EkrOwcIg67T;

1.142
date	2015.12.31.13.01.00;	author kettenis;	state Exp;
branches;
next	1.141;
commitid	PRTGqV1xSkCKPIeR;

1.141
date	2015.12.20.13.10.09;	author kettenis;	state Exp;
branches;
next	1.140;
commitid	ptgDY8C6OvFb3Of5;

1.140
date	2015.11.22.15.35.49;	author kettenis;	state Exp;
branches;
next	1.139;
commitid	sDPS7MogSiSWMILu;

1.139
date	2015.11.21.15.23.44;	author kettenis;	state Exp;
branches;
next	1.138;
commitid	txqmluU6Zd2aixzF;

1.138
date	2015.09.26.19.52.16;	author kettenis;	state Exp;
branches;
next	1.137;
commitid	PpEJMvqmELqAFnQv;

1.137
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.136;
commitid	lQlppvmETCN49oZe;

1.136
date	2015.09.06.11.17.49;	author kettenis;	state Exp;
branches;
next	1.135;
commitid	xyY49lWSImKXWZ3P;

1.135
date	2015.04.17.00.54.41;	author jsg;	state Exp;
branches;
next	1.134;
commitid	LqdQe79hlknpVtvI;

1.134
date	2015.04.15.09.48.18;	author kettenis;	state Exp;
branches;
next	1.133;
commitid	ZmPBAa9xEK5IPEd0;

1.133
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.132;
commitid	C5iGb36LQxjM60Q3;

1.132
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.131;
commitid	a8Vt7gSt34kmziIS;

1.131
date	2014.09.24.10.35.39;	author jsg;	state Exp;
branches;
next	1.130;
commitid	5THbGKHICACw2hdu;

1.130
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.129;
commitid	jdBY2kKXhfcoQitp;

1.129
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.128;
commitid	OBNa5kfxQ2UXoiIw;

1.128
date	2014.07.02.06.09.49;	author matthew;	state Exp;
branches;
next	1.127;
commitid	mswsoyQHeu5M87iU;

1.127
date	2014.04.07.06.43.11;	author jsg;	state Exp;
branches;
next	1.126;

1.126
date	2014.03.25.17.44.39;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2014.03.13.12.45.04;	author kettenis;	state Exp;
branches;
next	1.124;

1.124
date	2014.03.09.07.42.29;	author jsg;	state Exp;
branches;
next	1.123;

1.123
date	2014.02.23.09.36.52;	author kettenis;	state Exp;
branches;
next	1.122;

1.122
date	2014.01.30.15.10.47;	author kettenis;	state Exp;
branches;
next	1.121;

1.121
date	2014.01.20.09.20.49;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2013.12.21.19.36.42;	author kettenis;	state Exp;
branches;
next	1.119;

1.119
date	2013.12.16.19.57.09;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2013.12.05.13.29.56;	author kettenis;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.27.20.41.19;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2013.11.02.22.58.10;	author kettenis;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.26.20.31.48;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2013.09.30.03.26.21;	author jsg;	state Exp;
branches;
next	1.113;

1.113
date	2013.08.27.03.18.45;	author jsg;	state Exp;
branches;
next	1.112;

1.112
date	2013.08.27.03.06.03;	author jsg;	state Exp;
branches;
next	1.111;

1.111
date	2013.08.26.05.15.20;	author jsg;	state Exp;
branches;
next	1.110;

1.110
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.109;

1.109
date	2013.08.07.19.49.04;	author kettenis;	state Exp;
branches;
next	1.108;

1.108
date	2013.06.17.20.55.41;	author kettenis;	state Exp;
branches;
next	1.107;

1.107
date	2013.06.11.19.39.09;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2013.06.07.20.46.15;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2013.04.22.08.31.46;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.04.14.19.04.37;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.102;

1.102
date	2013.04.03.19.57.17;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.22.07.52.36;	author jsg;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	1.99;

1.99
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.98;

1.98
date	2012.09.08.16.42.20;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2012.08.30.18.01.36;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2011.07.03.18.34.14;	author oga;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.93;

1.93
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.92;

1.92
date	2011.05.02.18.12.47;	author oga;	state Exp;
branches;
next	1.91;

1.91
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2010.11.09.17.59.30;	author jsg;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.21.04.51.10;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.18.21.01.06;	author oga;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.24.01.19.19;	author oga;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.30.21.56.39;	author oga;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.25.21.53.21;	author oga;	state Exp;
branches;
next	1.83;

1.83
date	2010.04.08.11.45.54;	author oga;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.06.07.56.49;	author oga;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.06.07.12.08;	author oga;	state Exp;
branches;
next	1.78;

1.78
date	2009.04.03.15.22.30;	author oga;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.03.15.07.59;	author oga;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.03.14.30.57;	author oga;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.03.14.16.23;	author oga;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.30.01.17.19;	author oga;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.29.03.27.02;	author oga;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.27.19.00.45;	author oga;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.26.22.40.06;	author oga;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.26.07.25.06;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2009.02.15.20.03.19;	author oga;	state Exp;
branches;
next	1.67;

1.67
date	2009.02.15.19.58.08;	author oga;	state Exp;
branches;
next	1.66;

1.66
date	2009.02.15.19.52.21;	author oga;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.08.22.51.49;	author chl;	state Exp;
branches;
next	1.64;

1.64
date	2009.01.29.11.50.16;	author oga;	state Exp;
branches;
next	1.63;

1.63
date	2009.01.29.11.44.04;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.29.11.38.44;	author oga;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.29.11.18.16;	author oga;	state Exp;
branches;
next	1.60;

1.60
date	2008.12.08.19.06.34;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.24.21.20.45;	author dhill;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.24.08.20.34;	author oga;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.24.07.06.27;	author oga;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.24.04.26.50;	author oga;	state Exp;
branches;
next	1.55;

1.55
date	2008.11.24.04.21.31;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.24.03.49.19;	author oga;	state Exp;
branches;
next	1.53;

1.53
date	2008.11.24.03.27.02;	author oga;	state Exp;
branches;
next	1.52;

1.52
date	2008.11.23.22.56.02;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.23.22.02.00;	author oga;	state Exp;
branches;
next	1.50;

1.50
date	2008.11.23.20.46.47;	author oga;	state Exp;
branches;
next	1.49;

1.49
date	2008.11.22.22.43.53;	author oga;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.22.22.10.42;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2008.11.22.21.26.48;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2008.11.22.20.49.36;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2008.11.22.05.05.10;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2008.11.17.00.40.04;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.17.00.30.41;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.17.00.26.02;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.06.14.25.21;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.04.00.42.52;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.23.07.44.01;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.11.20.31.50;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.07.22.25.12;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.18.15.10.57;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.09.21.02.06;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.07.00.44.06;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2008.09.06.01.32.08;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.02.01.12.04;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.28.00.19.27;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.17.19.21.36;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.17.16.13.10;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.17.15.31.39;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.08.13.20.38.26;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.13.20.27.58;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.13.20.22.55;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.13.19.33.29;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.13.19.30.12;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.02.16.03.05;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.29.19.44.13;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.07.16.29.57;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.26.18.17.22;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.17.01.03;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.16.42.47;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.12.19.14.53;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.04.11.55.59;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.03.17.21.22;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.04.16.13.17.58;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.13.00.34.08;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.12.14.14.02;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.12.14.10.21;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.12.13.57.56;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.12.13.55.59;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.153
log
@Ignore entries with specific PCI subvendor/subdevice such that we don't
inadvertedly match the Intel HD Graphics P4000 as a "Quanta transcode"
device.

Thanks to Joe Gidi for figuring out that I inadvertedly brought this back.
Hopefully fixing it this way prevents it from happening again.
@
text
@/* $OpenBSD: drm_drv.c,v 1.152 2017/07/01 16:00:25 kettenis Exp $ */
/*-
 * Copyright 2007-2009 Owain G. Ainsworth <oga@@openbsd.org>
 * Copyright © 2008 Intel Corporation
 * Copyright 2003 Eric Anholt
 * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Daryll Strauss <daryll@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *    Eric Anholt <eric@@anholt.net>
 *    Owain Ainsworth <oga@@openbsd.org>
 *
 */

/** @@file drm_drv.c
 * The catch-all file for DRM device support, including module setup/teardown,
 * open/close, and ioctl dispatch.
 */

#include <sys/param.h>
#include <sys/fcntl.h>
#include <sys/filio.h>
#include <sys/limits.h>
#include <sys/pledge.h>
#include <sys/poll.h>
#include <sys/specdev.h>
#include <sys/systm.h>
#include <sys/ttycom.h> /* for TIOCSGRP */
#include <sys/vnode.h>

#include <uvm/uvm.h>
#include <uvm/uvm_device.h>

#include "drmP.h"
#include "drm.h"
#include "drm_sarea.h"
#include "drm_internal.h"

#ifdef DRMDEBUG
int drm_debug_flag = 1;
#endif

int	 drm_firstopen(struct drm_device *);
int	 drm_lastclose(struct drm_device *);
void	 drm_attach(struct device *, struct device *, void *);
int	 drm_probe(struct device *, void *, void *);
int	 drm_detach(struct device *, int);
void	 drm_quiesce(struct drm_device *);
void	 drm_wakeup(struct drm_device *);
int	 drm_activate(struct device *, int);
int	 drmprint(void *, const char *);
int	 drmsubmatch(struct device *, void *, void *);
int	 drm_do_ioctl(struct drm_device *, int, u_long, caddr_t);
int	 drm_dequeue_event(struct drm_device *, struct drm_file *, size_t,
	     struct drm_pending_event **);

int	 drm_getunique(struct drm_device *, void *, struct drm_file *);
int	 drm_version(struct drm_device *, void *, struct drm_file *);
int	 drm_setversion(struct drm_device *, void *, struct drm_file *);
int	 drm_getmagic(struct drm_device *, void *, struct drm_file *);
int	 drm_authmagic(struct drm_device *, void *, struct drm_file *);
int	 drm_getpciinfo(struct drm_device *, void *, struct drm_file *);
int	 drm_file_cmp(struct drm_file *, struct drm_file *);
SPLAY_PROTOTYPE(drm_file_tree, drm_file, link, drm_file_cmp);

int	 drm_setunique(struct drm_device *, void *, struct drm_file *);
int	 drm_noop(struct drm_device *, void *, struct drm_file *);

int	 drm_getcap(struct drm_device *, void *, struct drm_file *);
int	 drm_setclientcap(struct drm_device *, void *, struct drm_file *);

#define DRM_IOCTL_DEF(ioctl, _func, _flags) \
	[DRM_IOCTL_NR(ioctl)] = {.cmd = ioctl, .func = _func, .flags = _flags, .cmd_drv = 0}

/** Ioctl table */
static struct drm_ioctl_desc drm_ioctls[] = {
	DRM_IOCTL_DEF(DRM_IOCTL_VERSION, drm_version, DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_UNIQUE, drm_getunique, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_MAGIC, drm_getmagic, 0),
#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_IRQ_BUSID, drm_irq_by_busid, DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_MAP, drm_getmap, DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CLIENT, drm_getclient, DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_STATS, drm_getstats, DRM_UNLOCKED),
#endif
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CAP, drm_getcap, DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF(DRM_IOCTL_SET_CLIENT_CAP, drm_setclientcap, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_SET_VERSION, drm_setversion, DRM_MASTER),

	DRM_IOCTL_DEF(DRM_IOCTL_SET_UNIQUE, drm_setunique, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_BLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_UNBLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AUTH_MAGIC, drm_authmagic, DRM_AUTH|DRM_MASTER),

#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_MAP, drm_addmap_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_MAP, drm_rmmap_ioctl, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_setsareactx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_SAREA_CTX, drm_getsareactx, DRM_AUTH),
#else
	DRM_IOCTL_DEF(DRM_IOCTL_GET_PCIINFO, drm_getpciinfo, DRM_UNLOCKED|DRM_RENDER_ALLOW),

	DRM_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_SAREA_CTX, drm_noop, DRM_AUTH),
#endif

#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_SET_MASTER, drm_setmaster_ioctl, DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_DROP_MASTER, drm_dropmaster_ioctl, DRM_ROOT_ONLY),
#else
	/* On OpenBSD xorg privdrop has already occurred before this point */
	DRM_IOCTL_DEF(DRM_IOCTL_SET_MASTER, drm_noop, DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF(DRM_IOCTL_DROP_MASTER, drm_noop, DRM_UNLOCKED|DRM_RENDER_ALLOW),
#endif

#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_CTX, drm_addctx, DRM_AUTH|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_CTX, drm_rmctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#endif
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CTX, drm_getctx, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_switchctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_newctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#else
	DRM_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#endif
#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_RES_CTX, drm_resctx, DRM_AUTH),
#endif

	DRM_IOCTL_DEF(DRM_IOCTL_ADD_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_LOCK, drm_lock, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_UNLOCK, drm_unlock, DRM_AUTH),
#endif

	DRM_IOCTL_DEF(DRM_IOCTL_FINISH, drm_noop, DRM_AUTH),

#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_BUFS, drm_addbufs, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_MARK_BUFS, drm_markbufs, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_INFO_BUFS, drm_infobufs, DRM_AUTH),
#else
	DRM_IOCTL_DEF(DRM_IOCTL_MARK_BUFS, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_INFO_BUFS, drm_noop, DRM_AUTH),
#endif
#ifdef __linux__
	DRM_IOCTL_DEF(DRM_IOCTL_MAP_BUFS, drm_mapbufs, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_FREE_BUFS, drm_freebufs, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_DMA, drm_dma_ioctl, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_CONTROL, drm_control, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

#if __OS_HAS_AGP
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ACQUIRE, drm_agp_acquire_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_RELEASE, drm_agp_release_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ENABLE, drm_agp_enable_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_INFO, drm_agp_info_ioctl, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ALLOC, drm_agp_alloc_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_FREE, drm_agp_free_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_BIND, drm_agp_bind_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_UNBIND, drm_agp_unbind_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#endif

	DRM_IOCTL_DEF(DRM_IOCTL_SG_ALLOC, drm_sg_alloc, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_SG_FREE, drm_sg_free, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
#endif

	DRM_IOCTL_DEF(DRM_IOCTL_WAIT_VBLANK, drm_wait_vblank, DRM_UNLOCKED),

	DRM_IOCTL_DEF(DRM_IOCTL_MODESET_CTL, drm_modeset_ctl, 0),

	DRM_IOCTL_DEF(DRM_IOCTL_UPDATE_DRAW, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_GEM_CLOSE, drm_gem_close_ioctl, DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF(DRM_IOCTL_GEM_FLINK, drm_gem_flink_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_GEM_OPEN, drm_gem_open_ioctl, DRM_AUTH|DRM_UNLOCKED),

	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETRESOURCES, drm_mode_getresources, DRM_CONTROL_ALLOW|DRM_UNLOCKED),

#ifdef notyet
	DRM_IOCTL_DEF(DRM_IOCTL_PRIME_HANDLE_TO_FD, drm_prime_handle_to_fd_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF(DRM_IOCTL_PRIME_FD_TO_HANDLE, drm_prime_fd_to_handle_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
#endif

	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPLANERESOURCES, drm_mode_getplane_res, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETCRTC, drm_mode_getcrtc, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETCRTC, drm_mode_setcrtc, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPLANE, drm_mode_getplane, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETPLANE, drm_mode_setplane, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR, drm_mode_cursor_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETGAMMA, drm_mode_gamma_get_ioctl, DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETGAMMA, drm_mode_gamma_set_ioctl, DRM_MASTER|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETENCODER, drm_mode_getencoder, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETCONNECTOR, drm_mode_getconnector, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ATTACHMODE, drm_noop, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DETACHMODE, drm_noop, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPERTY, drm_mode_getproperty_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_SETPROPERTY, drm_mode_connector_property_set_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETPROPBLOB, drm_mode_getblob_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_GETFB, drm_mode_getfb, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ADDFB, drm_mode_addfb, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ADDFB2, drm_mode_addfb2, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_RMFB, drm_mode_rmfb, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_PAGE_FLIP, drm_mode_page_flip_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DIRTYFB, drm_mode_dirtyfb_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_GETPROPERTIES, drm_mode_obj_get_properties_ioctl, DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_SETPROPERTY, drm_mode_obj_set_property_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR2, drm_mode_cursor2_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
};

#define DRM_CORE_IOCTL_COUNT	ARRAY_SIZE( drm_ioctls )

int
pledge_ioctl_drm(struct proc *p, long com, dev_t device)
{
	struct drm_device *dev = drm_get_device_from_kdev(device);
	unsigned int nr = DRM_IOCTL_NR(com);
	const struct drm_ioctl_desc *ioctl;

	if (dev == NULL)
		return EPERM;

	if (nr < DRM_CORE_IOCTL_COUNT &&
	    ((nr < DRM_COMMAND_BASE || nr >= DRM_COMMAND_END)))
		ioctl = &drm_ioctls[nr];
	else if (nr >= DRM_COMMAND_BASE && nr < DRM_COMMAND_END &&
	    nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)
		ioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];
	else
		return EPERM;

	if (ioctl->flags & DRM_RENDER_ALLOW)
		return 0;

	/*
	 * These are dangerous, but we have to allow them until we
	 * have prime/dma-buf support.
	 */
	switch (com) {
	case DRM_IOCTL_GET_MAGIC:
	case DRM_IOCTL_GEM_OPEN:
		return 0;
	}

	return EPERM;
}

int
drm_setunique(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	/*
	 * Deprecated in DRM version 1.1, and will return EBUSY
	 * when setversion has
	 * requested version 1.1 or greater.
	 */
	return (-EBUSY);
}

/** No-op ioctl. */
int drm_noop(struct drm_device *dev, void *data,
	     struct drm_file *file_priv)
{
	return 0;
}

/*
 * attach drm to a pci-based driver.
 *
 * This function does all the pci-specific calculations for the 
 * drm_attach_args.
 */
struct device *
drm_attach_pci(struct drm_driver *driver, struct pci_attach_args *pa,
    int is_agp, int console, struct device *dev)
{
	struct drm_attach_args arg;
	pcireg_t subsys;

	arg.driver = driver;
	arg.dmat = pa->pa_dmat;
	arg.bst = pa->pa_memt;
	arg.is_agp = is_agp;
	arg.console = console;

	arg.pci_vendor = PCI_VENDOR(pa->pa_id);
	arg.pci_device = PCI_PRODUCT(pa->pa_id);

	subsys = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_SUBSYS_ID_REG);
	arg.pci_subvendor = PCI_VENDOR(subsys);
	arg.pci_subdevice = PCI_PRODUCT(subsys);

	arg.pci_revision = PCI_REVISION(pa->pa_class);

	arg.pa = pa;
	arg.pc = pa->pa_pc;
	arg.tag = pa->pa_tag;
	arg.bridgetag = pa->pa_bridgetag;

	arg.busid_len = 20;
	arg.busid = malloc(arg.busid_len + 1, M_DRM, M_NOWAIT);
	if (arg.busid == NULL) {
		printf("%s: no memory for drm\n", dev->dv_xname);
		return (NULL);
	}
	snprintf(arg.busid, arg.busid_len, "pci:%04x:%02x:%02x.%1x",
	    pa->pa_domain, pa->pa_bus, pa->pa_device, pa->pa_function);

	return (config_found_sm(dev, &arg, drmprint, drmsubmatch));
}

int
drmprint(void *aux, const char *pnp)
{
	if (pnp != NULL)
		printf("drm at %s", pnp);
	return (UNCONF);
}

int
drmsubmatch(struct device *parent, void *match, void *aux)
{
	extern struct cfdriver drm_cd;
	struct cfdata *cf = match;

	/* only allow drm to attach */
	if (cf->cf_driver == &drm_cd)
		return ((*cf->cf_attach->ca_match)(parent, match, aux));
	return (0);
}

int
drm_pciprobe(struct pci_attach_args *pa, const struct drm_pcidev *idlist)
{
	const struct drm_pcidev *id_entry;

	id_entry = drm_find_description(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id), idlist);
	if (id_entry != NULL)
		return 1;

	return 0;
}

int
drm_probe(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct drm_attach_args *da = aux;

	if (cf->drmdevcf_console != DRMDEVCF_CONSOLE_UNK) {
		/*
		 * If console-ness of device specified, either match
		 * exactly (at high priority), or fail.
		 */
		if (cf->drmdevcf_console != 0 && da->console != 0)
			return (10);
		else
			return (0);
	}

	/* If console-ness unspecified, it wins. */
	return (1);
}

void
drm_attach(struct device *parent, struct device *self, void *aux)
{
	struct drm_device *dev = (struct drm_device *)self;
	struct drm_attach_args *da = aux;
	int bus, slot, func;
	int ret;

	dev->dev = self;

	dev->dev_private = parent;
	dev->driver = da->driver;

	dev->dmat = da->dmat;
	dev->bst = da->bst;
	dev->unique = da->busid;
	dev->unique_len = da->busid_len;
	dev->pdev = &dev->_pdev;
	dev->pci_vendor = dev->pdev->vendor = da->pci_vendor;
	dev->pci_device = dev->pdev->device = da->pci_device;
	dev->pdev->subsystem_vendor = da->pci_subvendor;
	dev->pdev->subsystem_device = da->pci_subdevice;
	dev->pdev->revision = da->pci_revision;

	pci_decompose_tag(da->pc, da->tag, &bus, &slot, &func);
	dev->pdev->bus = &dev->pdev->_bus;
	dev->pdev->bus->pc = da->pc;
	dev->pdev->bus->number = bus;
	dev->pdev->devfn = PCI_DEVFN(slot, func);

	dev->pc = da->pc;
	dev->pdev->pc = da->pc;
	dev->bridgetag = da->bridgetag;
	dev->pdev->tag = da->tag;
	dev->pdev->pci = (struct pci_softc *)parent->dv_parent;

	rw_init(&dev->struct_mutex, "drmdevlk");
	mtx_init(&dev->event_lock, IPL_TTY);
	mtx_init(&dev->quiesce_mtx, IPL_NONE);

	SPLAY_INIT(&dev->files);
	INIT_LIST_HEAD(&dev->vblank_event_list);

	if (drm_core_check_feature(dev, DRIVER_USE_AGP)) {
#if __OS_HAS_AGP
		if (da->is_agp)
			dev->agp = drm_agp_init();
#endif
		if (dev->agp != NULL) {
			if (drm_mtrr_add(dev->agp->info.ai_aperture_base,
			    dev->agp->info.ai_aperture_size, DRM_MTRR_WC) == 0)
				dev->agp->mtrr = 1;
		}
	}

	if (dev->driver->gem_size > 0) {
		KASSERT(dev->driver->gem_size >= sizeof(struct drm_gem_object));
		/* XXX unique name */
		pool_init(&dev->objpl, dev->driver->gem_size, 0, IPL_NONE, 0,
		    "drmobjpl", NULL);
	}

	if (dev->driver->driver_features & DRIVER_GEM) {
		ret = drm_gem_init(dev);
		if (ret) {
			DRM_ERROR("Cannot initialize graphics execution manager (GEM)\n");
			goto error;
		}
	}	

	printf("\n");
	return;

error:
	drm_lastclose(dev);
	dev->dev_private = NULL;
}

int
drm_detach(struct device *self, int flags)
{
	struct drm_device *dev = (struct drm_device *)self;

	drm_lastclose(dev);

	if (dev->driver->driver_features & DRIVER_GEM)
		drm_gem_destroy(dev);

	if (dev->driver->driver_features & DRIVER_GEM)
		pool_destroy(&dev->objpl);

	drm_vblank_cleanup(dev);

	if (dev->agp && dev->agp->mtrr) {
		int retcode;

		retcode = drm_mtrr_del(0, dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		DRM_DEBUG("mtrr_del = %d", retcode);
	}


	if (dev->agp != NULL) {
		drm_free(dev->agp);
		dev->agp = NULL;
	}

	return 0;
}

void
drm_quiesce(struct drm_device *dev)
{
	mtx_enter(&dev->quiesce_mtx);
	dev->quiesce = 1;
	while (dev->quiesce_count > 0) {
		msleep(&dev->quiesce_count, &dev->quiesce_mtx,
		    PZERO, "drmqui", 0);
	}
	mtx_leave(&dev->quiesce_mtx);
}

void
drm_wakeup(struct drm_device *dev)
{
	mtx_enter(&dev->quiesce_mtx);
	dev->quiesce = 0;
	wakeup(&dev->quiesce);
	mtx_leave(&dev->quiesce_mtx);
}

int
drm_activate(struct device *self, int act)
{
	struct drm_device *dev = (struct drm_device *)self;

	switch (act) {
	case DVACT_QUIESCE:
		drm_quiesce(dev);
		break;
	case DVACT_WAKEUP:
		drm_wakeup(dev);
		break;
	}

	return (0);
}

struct cfattach drm_ca = {
	sizeof(struct drm_device), drm_probe, drm_attach,
	drm_detach, drm_activate
};

struct cfdriver drm_cd = {
	0, "drm", DV_DULL
};

const struct drm_pcidev *
drm_find_description(int vendor, int device, const struct drm_pcidev *idlist)
{
	int i = 0;
	
	for (i = 0; idlist[i].vendor != 0; i++) {
		if ((idlist[i].vendor == vendor) &&
		    (idlist[i].device == device) &&
		    (idlist[i].subvendor == PCI_ANY_ID) &&
		    (idlist[i].subdevice == PCI_ANY_ID))
			return &idlist[i];
	}
	return NULL;
}

int
drm_file_cmp(struct drm_file *f1, struct drm_file *f2)
{
	return (f1->minor < f2->minor ? -1 : f1->minor > f2->minor);
}

SPLAY_GENERATE(drm_file_tree, drm_file, link, drm_file_cmp);

struct drm_file *
drm_find_file_by_minor(struct drm_device *dev, int minor)
{
	struct drm_file	key;

	key.minor = minor;
	return (SPLAY_FIND(drm_file_tree, &dev->files, &key));
}

struct drm_device *
drm_get_device_from_kdev(dev_t kdev)
{
	int unit = minor(kdev) & ((1 << CLONE_SHIFT) - 1);

	if (unit < drm_cd.cd_ndevs)
		return drm_cd.cd_devs[unit];

	return NULL;
}

int
drm_firstopen(struct drm_device *dev)
{
	if (dev->driver->firstopen)
		dev->driver->firstopen(dev);

	dev->magicid = 1;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		dev->irq_enabled = 0;
	dev->if_version = 0;

	dev->buf_pgid = 0;

	DRM_DEBUG("\n");

	return 0;
}

int
drm_lastclose(struct drm_device *dev)
{
	DRM_DEBUG("\n");

	if (dev->driver->lastclose != NULL)
		dev->driver->lastclose(dev);

	if (!drm_core_check_feature(dev, DRIVER_MODESET) && dev->irq_enabled)
		drm_irq_uninstall(dev);

#if __OS_HAS_AGP
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		drm_agp_takedown(dev);
#endif

	return 0;
}

int
drmopen(dev_t kdev, int flags, int fmt, struct proc *p)
{
	struct drm_device	*dev = NULL;
	struct drm_file		*file_priv;
	int			 ret = 0;

	dev = drm_get_device_from_kdev(kdev);
	if (dev == NULL || dev->dev_private == NULL)
		return (ENXIO);

	DRM_DEBUG("open_count = %d\n", dev->open_count);

	if (flags & O_EXCL)
		return (EBUSY); /* No exclusive opens */

	mutex_lock(&dev->struct_mutex);
	if (dev->open_count++ == 0) {
		mutex_unlock(&dev->struct_mutex);
		if ((ret = drm_firstopen(dev)) != 0)
			goto err;
	} else {
		mutex_unlock(&dev->struct_mutex);
	}

	/* always allocate at least enough space for our data */
	file_priv = drm_calloc(1, max(dev->driver->file_priv_size,
	    sizeof(*file_priv)));
	if (file_priv == NULL) {
		ret = ENOMEM;
		goto err;
	}

	file_priv->filp = (void *)&file_priv;
	file_priv->minor = minor(kdev);
	INIT_LIST_HEAD(&file_priv->fbs);
	INIT_LIST_HEAD(&file_priv->event_list);
	file_priv->event_space = 4096; /* 4k for event buffer */
	DRM_DEBUG("minor = %d\n", file_priv->minor);

	/* for compatibility root is always authenticated */
	file_priv->authenticated = DRM_SUSER(p);

	if (dev->driver->driver_features & DRIVER_GEM)
		drm_gem_open(dev, file_priv);

	if (dev->driver->open) {
		ret = dev->driver->open(dev, file_priv);
		if (ret != 0) {
			goto free_priv;
		}
	}

	mutex_lock(&dev->struct_mutex);
	/* first opener automatically becomes master if root */
	if (SPLAY_EMPTY(&dev->files) && !DRM_SUSER(p)) {
		mutex_unlock(&dev->struct_mutex);
		ret = EPERM;
		goto free_priv;
	}

	file_priv->is_master = SPLAY_EMPTY(&dev->files);

	SPLAY_INSERT(drm_file_tree, &dev->files, file_priv);
	mutex_unlock(&dev->struct_mutex);

	return (0);

free_priv:
	drm_free(file_priv);
err:
	mutex_lock(&dev->struct_mutex);
	--dev->open_count;
	mutex_unlock(&dev->struct_mutex);
	return (ret);
}

int
drmclose(dev_t kdev, int flags, int fmt, struct proc *p)
{
	struct drm_device		*dev = drm_get_device_from_kdev(kdev);
	struct drm_file			*file_priv;
	struct drm_pending_event *e, *et;
	struct drm_pending_vblank_event	*v, *vt;
	int				 retcode = 0;

	if (dev == NULL)
		return (ENXIO);

	DRM_DEBUG("open_count = %d\n", dev->open_count);

	mutex_lock(&dev->struct_mutex);
	file_priv = drm_find_file_by_minor(dev, minor(kdev));
	if (file_priv == NULL) {
		DRM_ERROR("can't find authenticator\n");
		retcode = EINVAL;
		goto done;
	}
	mutex_unlock(&dev->struct_mutex);

	if (dev->driver->close != NULL)
		dev->driver->close(dev, file_priv);
	if (dev->driver->preclose != NULL)
		dev->driver->preclose(dev, file_priv);

	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
	    DRM_CURRENTPID, (long)&dev->device, dev->open_count);

	mtx_enter(&dev->event_lock);

	/* Remove pending flips */
	list_for_each_entry_safe(v, vt, &dev->vblank_event_list, base.link)
		if (v->base.file_priv == file_priv) {
			list_del(&v->base.link);
			drm_vblank_put(dev, v->pipe);
			v->base.destroy(&v->base);
		}

	/* Remove unconsumed events */
	list_for_each_entry_safe(e, et, &file_priv->event_list, link) {
		list_del(&e->link);
		e->destroy(e);
	}

	mtx_leave(&dev->event_lock);

	if (dev->driver->driver_features & DRIVER_MODESET)
		drm_fb_release(file_priv);

	if (dev->driver->driver_features & DRIVER_GEM)
		drm_gem_release(dev, file_priv);

	mutex_lock(&dev->struct_mutex);

	dev->buf_pgid = 0;

	if (dev->driver->postclose)
		dev->driver->postclose(dev, file_priv);

	SPLAY_REMOVE(drm_file_tree, &dev->files, file_priv);
	drm_free(file_priv);

done:
	if (--dev->open_count == 0) {
		mutex_unlock(&dev->struct_mutex);
		retcode = drm_lastclose(dev);
	} else
		mutex_unlock(&dev->struct_mutex);

	return (retcode);
}

int
drm_do_ioctl(struct drm_device *dev, int minor, u_long cmd, caddr_t data)
{
	struct drm_file *file_priv;
	const struct drm_ioctl_desc *ioctl;
	drm_ioctl_t *func;
	unsigned int nr = DRM_IOCTL_NR(cmd);
	int retcode = -EINVAL;
	unsigned int usize, asize;

	mutex_lock(&dev->struct_mutex);
	file_priv = drm_find_file_by_minor(dev, minor);
	mutex_unlock(&dev->struct_mutex);
	if (file_priv == NULL) {
		DRM_ERROR("can't find authenticator\n");
		return -EINVAL;
	}

	DRM_DEBUG("pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
	    DRM_CURRENTPID, cmd, (u_int)DRM_IOCTL_NR(cmd), (long)&dev->device,
	    file_priv->authenticated);

	switch (cmd) {
	case FIONBIO:
	case FIOASYNC:
		return 0;

	case TIOCSPGRP:
		dev->buf_pgid = *(int *)data;
		return 0;

	case TIOCGPGRP:
		*(int *)data = dev->buf_pgid;
		return 0;
	}

	if ((nr >= DRM_CORE_IOCTL_COUNT) &&
	    ((nr < DRM_COMMAND_BASE) || (nr >= DRM_COMMAND_END)))
		return (-EINVAL);
	if ((nr >= DRM_COMMAND_BASE) && (nr < DRM_COMMAND_END) &&
	    (nr < DRM_COMMAND_BASE + dev->driver->num_ioctls)) {
		uint32_t drv_size;
		ioctl = &dev->driver->ioctls[nr - DRM_COMMAND_BASE];
		drv_size = IOCPARM_LEN(ioctl->cmd_drv);
		usize = asize = IOCPARM_LEN(cmd);
		if (drv_size > asize)
			asize = drv_size;
	} else if ((nr >= DRM_COMMAND_END) || (nr < DRM_COMMAND_BASE)) {
		uint32_t drv_size;
		ioctl = &drm_ioctls[nr];

		drv_size = IOCPARM_LEN(ioctl->cmd_drv);
		usize = asize = IOCPARM_LEN(cmd);
		if (drv_size > asize)
			asize = drv_size;
		cmd = ioctl->cmd;
	} else
		return (-EINVAL);

	func = ioctl->func;
	if (!func) {
		DRM_DEBUG("no function\n");
		return (-EINVAL);
	}

	if (((ioctl->flags & DRM_ROOT_ONLY) && !DRM_SUSER(curproc)) ||
	    ((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||
	    ((ioctl->flags & DRM_MASTER) && !file_priv->is_master))
		return (-EACCES);

	if (ioctl->flags & DRM_UNLOCKED)
		retcode = func(dev, data, file_priv);
	else {
		/* XXX lock */
		retcode = func(dev, data, file_priv);
		/* XXX unlock */
	}

	return (retcode);
}

/* drmioctl is called whenever a process performs an ioctl on /dev/drm.
 */
int
drmioctl(dev_t kdev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct drm_device *dev = drm_get_device_from_kdev(kdev);
	int error;

	if (dev == NULL)
		return ENODEV;

	mtx_enter(&dev->quiesce_mtx);
	while (dev->quiesce)
		msleep(&dev->quiesce, &dev->quiesce_mtx, PZERO, "drmioc", 0);
	dev->quiesce_count++;
	mtx_leave(&dev->quiesce_mtx);

	error = -drm_do_ioctl(dev, minor(kdev), cmd, data);
	if (error < 0 && error != ERESTART && error != EJUSTRETURN)
		printf("%s: cmd 0x%lx errno %d\n", __func__, cmd, error);

	mtx_enter(&dev->quiesce_mtx);
	dev->quiesce_count--;
	if (dev->quiesce)
		wakeup(&dev->quiesce_count);
	mtx_leave(&dev->quiesce_mtx);

	return (error);
}

int
drmread(dev_t kdev, struct uio *uio, int ioflag)
{
	struct drm_device		*dev = drm_get_device_from_kdev(kdev);
	struct drm_file			*file_priv;
	struct drm_pending_event	*ev;
	int		 		 error = 0;

	if (dev == NULL)
		return (ENXIO);

	mutex_lock(&dev->struct_mutex);
	file_priv = drm_find_file_by_minor(dev, minor(kdev));
	mutex_unlock(&dev->struct_mutex);
	if (file_priv == NULL)
		return (ENXIO);

	/*
	 * The semantics are a little weird here. We will wait until we
	 * have events to process, but as soon as we have events we will
	 * only deliver as many as we have.
	 * Note that events are atomic, if the read buffer will not fit in
	 * a whole event, we won't read any of it out.
	 */
	mtx_enter(&dev->event_lock);
	while (error == 0 && list_empty(&file_priv->event_list)) {
		if (ioflag & IO_NDELAY) {
			mtx_leave(&dev->event_lock);
			return (EAGAIN);
		}
		error = msleep(&file_priv->event_wait, &dev->event_lock,
		    PWAIT | PCATCH, "drmread", 0);
	}
	if (error) {
		mtx_leave(&dev->event_lock);
		return (error);
	}
	while (drm_dequeue_event(dev, file_priv, uio->uio_resid, &ev)) {
		MUTEX_ASSERT_UNLOCKED(&dev->event_lock);
		/* XXX we always destroy the event on error. */
		error = uiomove(ev->event, ev->event->length, uio);
		ev->destroy(ev);
		if (error)
			break;
		mtx_enter(&dev->event_lock);
	}
	MUTEX_ASSERT_UNLOCKED(&dev->event_lock);

	return (error);
}

/*
 * Deqeue an event from the file priv in question. returning 1 if an
 * event was found. We take the resid from the read as a parameter because
 * we will only dequeue and event if the read buffer has space to fit the
 * entire thing.
 *
 * We are called locked, but we will *unlock* the queue on return so that
 * we may sleep to copyout the event.
 */
int
drm_dequeue_event(struct drm_device *dev, struct drm_file *file_priv,
    size_t resid, struct drm_pending_event **out)
{
	struct drm_pending_event *e = NULL;
	int gotone = 0;

	MUTEX_ASSERT_LOCKED(&dev->event_lock);

	*out = NULL;
	if (list_empty(&file_priv->event_list))
		goto out;
	e = list_first_entry(&file_priv->event_list,
			     struct drm_pending_event, link);
	if (e->event->length > resid)
		goto out;

	file_priv->event_space += e->event->length;
	list_del(&e->link);
	*out = e;
	gotone = 1;

out:
	mtx_leave(&dev->event_lock);

	return (gotone);
}

/* XXX kqfilter ... */
int
drmpoll(dev_t kdev, int events, struct proc *p)
{
	struct drm_device	*dev = drm_get_device_from_kdev(kdev);
	struct drm_file		*file_priv;
	int		 	 revents = 0;

	if (dev == NULL)
		return (POLLERR);

	mutex_lock(&dev->struct_mutex);
	file_priv = drm_find_file_by_minor(dev, minor(kdev));
	mutex_unlock(&dev->struct_mutex);
	if (file_priv == NULL)
		return (POLLERR);

	mtx_enter(&dev->event_lock);
	if (events & (POLLIN | POLLRDNORM)) {
		if (!list_empty(&file_priv->event_list))
			revents |=  events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &file_priv->rsel);
	}
	mtx_leave(&dev->event_lock);

	return (revents);
}

paddr_t
drmmmap(dev_t kdev, off_t offset, int prot)
{
	return -1;
}

/*
 * Beginning in revision 1.1 of the DRM interface, getunique will return
 * a unique in the form pci:oooo:bb:dd.f (o=domain, b=bus, d=device, f=function)
 * before setunique has been called.  The format for the bus-specific part of
 * the unique is not defined for any other bus.
 */
int
drm_getunique(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_unique	 *u = data;

	if (u->unique_len >= dev->unique_len) {
		if (DRM_COPY_TO_USER(u->unique, dev->unique, dev->unique_len))
			return -EFAULT;
	}
	u->unique_len = dev->unique_len;

	return 0;
}

int
drm_getcap(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_get_cap *req = data;

	req->value = 0;
	switch (req->capability) {
	case DRM_CAP_DUMB_BUFFER:
		if (dev->driver->dumb_create)
			req->value = 1;
		break;
	case DRM_CAP_VBLANK_HIGH_CRTC:
		req->value = 1;
		break;
	case DRM_CAP_DUMB_PREFERRED_DEPTH:
		req->value = dev->mode_config.preferred_depth;
		break;
	case DRM_CAP_DUMB_PREFER_SHADOW:
		req->value = dev->mode_config.prefer_shadow;
		break;
#ifdef notyet
	case DRM_CAP_PRIME:
		req->value |= dev->driver->prime_fd_to_handle ? DRM_PRIME_CAP_IMPORT : 0;
		req->value |= dev->driver->prime_handle_to_fd ? DRM_PRIME_CAP_EXPORT : 0;
		break;
#endif
	case DRM_CAP_TIMESTAMP_MONOTONIC:
		req->value = drm_timestamp_monotonic;
		break;
	case DRM_CAP_ASYNC_PAGE_FLIP:
		req->value = dev->mode_config.async_page_flip;
		break;
	case DRM_CAP_CURSOR_WIDTH:
		if (dev->mode_config.cursor_width)
			req->value = dev->mode_config.cursor_width;
		else
			req->value = 64;
		break;
	case DRM_CAP_CURSOR_HEIGHT:
		if (dev->mode_config.cursor_height)
			req->value = dev->mode_config.cursor_height;
		else
			req->value = 64;
		break;
	default:
		return -EINVAL;
	}
	return 0;
}

/**
 * Set device/driver capabilities
 */
int
drm_setclientcap(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_set_client_cap *req = data;

	switch (req->capability) {
	case DRM_CLIENT_CAP_STEREO_3D:
		if (req->value > 1)
			return -EINVAL;
		file_priv->stereo_allowed = req->value;
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

#define DRM_IF_MAJOR	1
#define DRM_IF_MINOR	4

int
drm_version(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_version	*version = data;
	int			 len;

#define DRM_COPY(name, value)						\
	len = strlen( value );						\
	if ( len > name##_len ) len = name##_len;			\
	name##_len = strlen( value );					\
	if ( len && name ) {						\
		if ( DRM_COPY_TO_USER( name, value, len ) )		\
			return -EFAULT;				\
	}

	version->version_major = dev->driver->major;
	version->version_minor = dev->driver->minor;
	version->version_patchlevel = dev->driver->patchlevel;

	DRM_COPY(version->name, dev->driver->name);
	DRM_COPY(version->date, dev->driver->date);
	DRM_COPY(version->desc, dev->driver->desc);

	return 0;
}

int
drm_setversion(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_set_version	ver, *sv = data;
	int			if_version;

	/* Save the incoming data, and set the response before continuing
	 * any further.
	 */
	ver = *sv;
	sv->drm_di_major = DRM_IF_MAJOR;
	sv->drm_di_minor = DRM_IF_MINOR;
	sv->drm_dd_major = dev->driver->major;
	sv->drm_dd_minor = dev->driver->minor;

	/*
	 * We no longer support interface versions less than 1.1, so error
	 * out if the xserver is too old. 1.1 always ties the drm to a
	 * certain busid, this was done on attach
	 */
	if (ver.drm_di_major != -1) {
		if (ver.drm_di_major != DRM_IF_MAJOR || ver.drm_di_minor < 1 ||
		    ver.drm_di_minor > DRM_IF_MINOR) {
			return -EINVAL;
		}
		if_version = DRM_IF_VERSION(ver.drm_di_major, ver.drm_dd_minor);
		dev->if_version = imax(if_version, dev->if_version);
	}

	if (ver.drm_dd_major != -1) {
		if (ver.drm_dd_major != dev->driver->major ||
		    ver.drm_dd_minor < 0 ||
		    ver.drm_dd_minor > dev->driver->minor)
			return -EINVAL;
	}

	return 0;
}

struct drm_dmamem *
drm_dmamem_alloc(bus_dma_tag_t dmat, bus_size_t size, bus_size_t alignment,
    int nsegments, bus_size_t maxsegsz, int mapflags, int loadflags)
{
	struct drm_dmamem	*mem;
	size_t			 strsize;
	/*
	 * segs is the last member of the struct since we modify the size 
	 * to allow extra segments if more than one are allowed.
	 */
	strsize = sizeof(*mem) + (sizeof(bus_dma_segment_t) * (nsegments - 1));
	mem = malloc(strsize, M_DRM, M_NOWAIT | M_ZERO);
	if (mem == NULL)
		return (NULL);

	mem->size = size;

	if (bus_dmamap_create(dmat, size, nsegments, maxsegsz, 0,
	    BUS_DMA_NOWAIT | BUS_DMA_ALLOCNOW, &mem->map) != 0)
		goto strfree;

	if (bus_dmamem_alloc(dmat, size, alignment, 0, mem->segs, nsegments,
	    &mem->nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO) != 0)
		goto destroy;

	if (bus_dmamem_map(dmat, mem->segs, mem->nsegs, size, 
	    &mem->kva, BUS_DMA_NOWAIT | mapflags) != 0)
		goto free;

	if (bus_dmamap_load(dmat, mem->map, mem->kva, size,
	    NULL, BUS_DMA_NOWAIT | loadflags) != 0)
		goto unmap;

	return (mem);

unmap:
	bus_dmamem_unmap(dmat, mem->kva, size);
free:
	bus_dmamem_free(dmat, mem->segs, mem->nsegs);
destroy:
	bus_dmamap_destroy(dmat, mem->map);
strfree:
	free(mem, M_DRM, 0);

	return (NULL);
}

void
drm_dmamem_free(bus_dma_tag_t dmat, struct drm_dmamem *mem)
{
	if (mem == NULL)
		return;

	bus_dmamap_unload(dmat, mem->map);
	bus_dmamem_unmap(dmat, mem->kva, mem->size);
	bus_dmamem_free(dmat, mem->segs, mem->nsegs);
	bus_dmamap_destroy(dmat, mem->map);
	free(mem, M_DRM, 0);
}

/**
 * Called by the client, this returns a unique magic number to be authorized
 * by the master.
 *
 * The master may use its own knowledge of the client (such as the X
 * connection that the magic is passed over) to determine if the magic number
 * should be authenticated.
 */
int
drm_getmagic(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_auth		*auth = data;

	if (dev->magicid == 0)
		dev->magicid = 1;

	/* Find unique magic */
	if (file_priv->magic) {
		auth->magic = file_priv->magic;
	} else {
		mutex_lock(&dev->struct_mutex);
		file_priv->magic = auth->magic = dev->magicid++;
		mutex_unlock(&dev->struct_mutex);
		DRM_DEBUG("%d\n", auth->magic);
	}

	DRM_DEBUG("%u\n", auth->magic);
	return 0;
}

/**
 * Marks the client associated with the given magic number as authenticated.
 */
int
drm_authmagic(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_file	*p;
	struct drm_auth	*auth = data;
	int		 ret = -EINVAL;

	DRM_DEBUG("%u\n", auth->magic);

	if (auth->magic == 0)
		return ret;

	mutex_lock(&dev->struct_mutex);
	SPLAY_FOREACH(p, drm_file_tree, &dev->files) {
		if (p->magic == auth->magic) {
			p->authenticated = 1;
			p->magic = 0;
			ret = 0;
			break;
		}
	}
	mutex_unlock(&dev->struct_mutex);

	return ret;
}

/*
 * Compute order.  Can be made faster.
 */
int
drm_order(unsigned long size)
{
	int order;
	unsigned long tmp;

	for (order = 0, tmp = size; tmp >>= 1; ++order)
		;

	if (size & ~(1 << order))
		++order;

	return order;
}

int drm_pcie_get_speed_cap_mask(struct drm_device *dev, u32 *mask)
{
	pci_chipset_tag_t	pc = dev->pc;
	pcitag_t		tag;
	int			pos ;
	pcireg_t		xcap, lnkcap = 0, lnkcap2 = 0;
	pcireg_t		id;

	*mask = 0;

	if (dev->bridgetag == NULL)
		return -EINVAL;
	tag = *dev->bridgetag;

	if (!pci_get_capability(pc, tag, PCI_CAP_PCIEXPRESS,
	    &pos, NULL)) 
		return -EINVAL;

	id = pci_conf_read(pc, tag, PCI_ID_REG);

	/* we've been informed via and serverworks don't make the cut */
	if (PCI_VENDOR(id) == PCI_VENDOR_VIATECH ||
	    PCI_VENDOR(id) == PCI_VENDOR_RCC)
		return -EINVAL;

	lnkcap = pci_conf_read(pc, tag, pos + PCI_PCIE_LCAP);
	xcap = pci_conf_read(pc, tag, pos + PCI_PCIE_XCAP);
	if (PCI_PCIE_XCAP_VER(xcap) >= 2)
		lnkcap2 = pci_conf_read(pc, tag, pos + PCI_PCIE_LCAP2);

	lnkcap &= 0x0f;
	lnkcap2 &= 0xfe;

	if (lnkcap2) { /* PCIE GEN 3.0 */
		if (lnkcap2 & 2)
			*mask |= DRM_PCIE_SPEED_25;
		if (lnkcap2 & 4)
			*mask |= DRM_PCIE_SPEED_50;
		if (lnkcap2 & 8)
			*mask |= DRM_PCIE_SPEED_80;
	} else {
		if (lnkcap & 1)
			*mask |= DRM_PCIE_SPEED_25;
		if (lnkcap & 2)
			*mask |= DRM_PCIE_SPEED_50;
	}

	DRM_INFO("probing gen 2 caps for device 0x%04x:0x%04x = %x/%x\n",
	    PCI_VENDOR(id), PCI_PRODUCT(id), lnkcap, lnkcap2);
	return 0;
}

int
drm_getpciinfo(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_pciinfo *info = data;

	info->domain = 0;
	info->bus = dev->pdev->bus->number;
	info->dev = PCI_SLOT(dev->pdev->devfn);
	info->func = PCI_FUNC(dev->pdev->devfn);
	info->vendor_id = dev->pdev->vendor;
	info->device_id = dev->pdev->device;
	info->subvendor_id = dev->pdev->subsystem_vendor;
	info->subdevice_id = dev->pdev->subsystem_device;
	info->revision_id = 0;

	return 0;
}
@


1.152
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.151 2016/12/01 01:37:17 jsg Exp $ */
d562 3
a564 1
		    (idlist[i].device == device))
@


1.151
log
@Add noop drm SET_MASTER and DROP_MASTER ioctls.  This will allow
reducing the local diff in libdrm.

We only handle a single master as xorg privdrop has already occurred at
the point where the ioctls are issued.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.150 2016/11/25 23:33:39 jsg Exp $ */
d60 1
d306 1
a306 1
drm_attach_pci(struct drm_driver_info *driver, struct pci_attach_args *pa,
d325 3
d406 2
d420 1
d424 1
d453 1
a453 1
	if (dev->driver->driver_features & DRIVER_GEM) {
d761 1
a761 1
		drm_fb_release(dev, file_priv);
d927 1
a927 1
		error = msleep(&file_priv->event_list, &dev->event_lock,
@


1.150
log
@Add a new DRM_IOCTL_GET_PCIINFO ioctl to have a non driver specific way
to get pci device ids from a drm fd as an ordinary user.

This will be used to provide non-sysfs implementations of functions in
libdrm.  These functions are required for Mesa >= 13.

The ioctl number used is the same as the DRM_IOCTL_ADD_MAP ioctl which
was removed when we removed DRI1 support.  This was chosen to not
collide with new ioctls from linux.

ok kettenis@@ ok mpi@@ on an earlier version
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.149 2016/09/15 02:00:17 dlg Exp $ */
d133 5
d139 1
@


1.149
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.148 2016/08/24 09:31:56 dlg Exp $ */
d84 1
d124 2
d1351 18
@


1.148
log
@pool_setipl for cardbus and drm pools.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.147 2016/04/08 08:27:53 kettenis Exp $ */
d439 1
a439 1
		pool_init(&dev->objpl, dev->driver->gem_size, 0, 0, 0,
a440 1
		pool_setipl(&dev->objpl, IPL_NONE);
@


1.147
log
@Get rid of some infrastrcuture that is now obsolete and synchronize some of
the data structures in drmP.h with Linux 3.14.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.146 2016/04/05 08:22:50 kettenis Exp $ */
d441 1
@


1.146
log
@Split out the generic GEM code (like Linux did) and switch it over to
the vma offset manager.  This brings us a little bit more isolation between
applications as GEM buffers are now tied to a specific /dev/drmX clone.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.145 2016/02/05 10:05:12 kettenis Exp $ */
a420 1
	TAILQ_INIT(&dev->maplist);
d424 1
a424 12
	/*
	 * the dma buffers api is just weird. offset 1Gb to ensure we don't
	 * conflict with it.
	 */
	dev->handle_ext = extent_create("drmext", 1024*1024*1024, LONG_MAX,
	    M_DRM, NULL, 0, EX_NOWAIT | EX_NOCOALESCE);
	if (dev->handle_ext == NULL) {
		DRM_ERROR("Failed to initialise handle extent\n");
		goto error;
	}

	if (dev->driver->flags & DRIVER_AGP) {
a428 5
		if (dev->driver->flags & DRIVER_AGP_REQUIRE &&
		    dev->agp == NULL) {
			printf(": couldn't find agp\n");
			goto error;
		}
d436 1
a436 1
	if (dev->driver->flags & DRIVER_GEM) {
d443 1
a443 1
	if (dev->driver->flags & DRIVER_GEM) {
d466 1
a466 1
	if (dev->driver->flags & DRIVER_GEM)
d469 1
a469 1
	if (dev->driver->flags & DRIVER_GEM)
a471 2
	extent_destroy(dev->handle_ext);

a649 2
	file_priv->kdev = kdev;
	file_priv->flags = flags;
d660 1
a660 1
	if (dev->driver->flags & DRIVER_GEM)
d678 1
a678 1
	file_priv->master = SPLAY_EMPTY(&dev->files);
d743 1
a743 1
	if (dev->driver->flags & DRIVER_MODESET)
d746 1
a746 1
	if (dev->driver->flags & DRIVER_GEM)
a786 2
	++file_priv->ioctl_count;

d836 1
a836 1
	    ((ioctl->flags & DRM_MASTER) && !file_priv->master))
a996 14
struct drm_local_map *
drm_getsarea(struct drm_device *dev)
{
	struct drm_local_map	*map;

	mutex_lock(&dev->struct_mutex);
	TAILQ_FOREACH(map, &dev->maplist, link) {
		if (map->type == _DRM_SHM && (map->flags & _DRM_CONTAINS_LOCK))
			break;
	}
	mutex_unlock(&dev->struct_mutex);
	return (map);
}

d1000 1
a1000 81
	struct drm_device	*dev = drm_get_device_from_kdev(kdev);
	struct drm_local_map	*map;
	struct drm_file		*file_priv;
	enum drm_map_type	 type;

	if (dev == NULL)
		return (-1);

	mutex_lock(&dev->struct_mutex);
	file_priv = drm_find_file_by_minor(dev, minor(kdev));
	mutex_unlock(&dev->struct_mutex);
	if (file_priv == NULL) {
		DRM_ERROR("can't find authenticator\n");
		return (-1);
	}

	if (!file_priv->authenticated)
		return (-1);

	if (dev->dma && offset >= 0 && offset < ptoa(dev->dma->page_count)) {
		struct drm_device_dma *dma = dev->dma;
		paddr_t	phys = -1;

		rw_enter_write(&dma->dma_lock);
		if (dma->pagelist != NULL)
			phys = dma->pagelist[offset >> PAGE_SHIFT];
		rw_exit_write(&dma->dma_lock);

		return (phys);
	}

	/*
	 * A sequential search of a linked list is
 	 * fine here because: 1) there will only be
	 * about 5-10 entries in the list and, 2) a
	 * DRI client only has to do this mapping
	 * once, so it doesn't have to be optimized
	 * for performance, even if the list was a
	 * bit longer.
	 */
	mutex_lock(&dev->struct_mutex);
	TAILQ_FOREACH(map, &dev->maplist, link) {
		if (offset >= map->ext &&
		    offset < map->ext + map->size) {
			offset -= map->ext;
			break;
		}
	}

	if (map == NULL) {
		mutex_unlock(&dev->struct_mutex);
		DRM_DEBUG("can't find map\n");
		return (-1);
	}
	if (((map->flags & _DRM_RESTRICTED) && file_priv->master == 0)) {
		mutex_unlock(&dev->struct_mutex);
		DRM_DEBUG("restricted map\n");
		return (-1);
	}
	type = map->type;
	mutex_unlock(&dev->struct_mutex);

	switch (type) {
#if __OS_HAS_AGP
	case _DRM_AGP:
		return agp_mmap(dev->agp->agpdev,
		    offset + map->offset - dev->agp->base, prot);
#endif
	case _DRM_FRAME_BUFFER:
	case _DRM_REGISTERS:
		return (offset + map->offset);
		break;
	case _DRM_SHM:
	case _DRM_CONSISTENT:
		return (bus_dmamem_mmap(dev->dmat, map->dmamem->segs,
		    map->dmamem->nsegs, offset, prot, BUS_DMA_NOWAIT));
	default:
		DRM_ERROR("bad map type %d\n", type);
		return (-1);	/* This should never happen. */
	}
	/* NOTREACHED */
@


1.145
log
@Improve Linux PCI compatibility code.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.144 2016/01/09 11:34:57 kettenis Exp $ */
a64 1
struct drm_device *drm_get_device_from_kdev(dev_t);
a86 10
/* functions used by the per-open handle  code to grab references to object */
void	 drm_gem_object_handle_reference(struct drm_gem_object *);
void	 drm_gem_object_handle_unreference(struct drm_gem_object *);
void	 drm_gem_object_handle_unreference_unlocked(struct drm_gem_object *);

int	 drm_handle_cmp(struct drm_handle *, struct drm_handle *);
int	 drm_name_cmp(struct drm_gem_object *, struct drm_gem_object *);
int	 drm_fault(struct uvm_faultinfo *, vaddr_t, vm_page_t *, int, int,
	     vm_fault_t, vm_prot_t, int);
boolean_t	 drm_flush(struct uvm_object *, voff_t, voff_t, int);
a89 3
SPLAY_PROTOTYPE(drm_obj_tree, drm_handle, entry, drm_handle_cmp);
SPLAY_PROTOTYPE(drm_name_tree, drm_gem_object, entry, drm_name_cmp);

d391 1
a453 2
		mtx_init(&dev->obj_name_lock, IPL_NONE);
		SPLAY_INIT(&dev->name_tree);
d460 8
d484 3
d671 1
d681 2
a682 4
	if (dev->driver->flags & DRIVER_GEM) {
		SPLAY_INIT(&file_priv->obj_tree);
		mtx_init(&file_priv->table_lock, IPL_NONE);
	}
d767 3
a770 12
	if (dev->driver->flags & DRIVER_GEM) {
		struct drm_handle	*han;
		mtx_enter(&file_priv->table_lock);
		while ((han = SPLAY_ROOT(&file_priv->obj_tree)) != NULL) {
			SPLAY_REMOVE(drm_obj_tree, &file_priv->obj_tree, han);
			mtx_leave(&file_priv->table_lock);
			drm_gem_object_handle_unreference(han->obj);
			drm_free(han);
			mtx_enter(&file_priv->table_lock);
		}
		mtx_leave(&file_priv->table_lock);
	}
a1397 491
struct uvm_pagerops drm_pgops = {
	NULL,
	drm_ref,
	drm_unref,
	drm_fault,
	drm_flush,
};

void
drm_ref(struct uvm_object *uobj)
{
	uobj->uo_refs++;
}

void
drm_unref(struct uvm_object *uobj)
{
	struct drm_gem_object *obj = (struct drm_gem_object *)uobj;
	struct drm_device *dev = obj->dev;

	if (uobj->uo_refs > 1) {
		uobj->uo_refs--;
		return;
	}

	/* We own this thing now. It is on no queues, though it may still
	 * be bound to the aperture (and on the inactive list, in which case
	 * idling the buffer is what triggered the free. Since we know no one 
	 * else can grab it now, we can nuke with impunity.
	 */
	if (dev->driver->gem_free_object != NULL)
		dev->driver->gem_free_object(obj);
}

boolean_t	
drm_flush(struct uvm_object *uobj, voff_t start, voff_t stop, int flags)
{
	return (TRUE);
}

int
drm_fault(struct uvm_faultinfo *ufi, vaddr_t vaddr, vm_page_t *pps,
    int npages, int centeridx, vm_fault_t fault_type,
    vm_prot_t access_type, int flags)
{
	struct vm_map_entry *entry = ufi->entry;
	struct uvm_object *uobj = entry->object.uvm_obj;
	struct drm_gem_object *obj = (struct drm_gem_object *)uobj;
	struct drm_device *dev = obj->dev;
	int ret;

	/*
	 * we do not allow device mappings to be mapped copy-on-write
	 * so we kill any attempt to do so here.
	 */
	
	if (UVM_ET_ISCOPYONWRITE(entry)) {
		uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, uobj, NULL);
		return(VM_PAGER_ERROR);
	}

	/*
	 * We could end up here as the result of a copyin(9) or
	 * copyout(9) while handling an ioctl.  So we must be careful
	 * not to deadlock.  Therefore we only block if the quiesce
	 * count is zero, which guarantees we didn't enter from within
	 * an ioctl code path.
	 */
	mtx_enter(&dev->quiesce_mtx);
	if (dev->quiesce && dev->quiesce_count == 0) {
		mtx_leave(&dev->quiesce_mtx);
		uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, uobj, NULL);
		mtx_enter(&dev->quiesce_mtx);
		while (dev->quiesce) {
			msleep(&dev->quiesce, &dev->quiesce_mtx,
			    PZERO, "drmflt", 0);
		}
		mtx_leave(&dev->quiesce_mtx);
		return(VM_PAGER_REFAULT);
	}
	dev->quiesce_count++;
	mtx_leave(&dev->quiesce_mtx);

	/* Call down into driver to do the magic */
	ret = dev->driver->gem_fault(obj, ufi, entry->offset + (vaddr -
	    entry->start), vaddr, pps, npages, centeridx,
	    access_type, flags);

	mtx_enter(&dev->quiesce_mtx);
	dev->quiesce_count--;
	if (dev->quiesce)
		wakeup(&dev->quiesce_count);
	mtx_leave(&dev->quiesce_mtx);

	return (ret);
}

/*
 * Code to support memory managers based on the GEM (Graphics
 * Execution Manager) api.
 */
int
drm_gem_object_init(struct drm_device *dev, struct drm_gem_object *obj, size_t size)
{
	BUG_ON((size & (PAGE_SIZE -1)) != 0);

	obj->dev = dev;

	/* uao create can't fail in the 0 case, it just sleeps */
	obj->uao = uao_create(size, 0);
	obj->size = size;
	uvm_objinit(&obj->uobj, &drm_pgops, 1);

	atomic_inc(&dev->obj_count);
	atomic_add(obj->size, &dev->obj_memory);
	return 0;
}

void
drm_gem_object_release(struct drm_gem_object *obj)
{
	struct drm_device *dev = obj->dev;

	if (obj->uao)
		uao_detach(obj->uao);

	atomic_dec(&dev->obj_count);
	atomic_sub(obj->size, &dev->obj_memory);
	if (obj->do_flags & DRM_WANTED) /* should never happen, not on lists */
		wakeup(obj);
}

/**
 * Create a handle for this object. This adds a handle reference
 * to the object, which includes a regular reference count. Callers
 * will likely want to dereference the object afterwards.
 */
int
drm_gem_handle_create(struct drm_file *file_priv,
		       struct drm_gem_object *obj,
		       u32 *handlep)
{
	struct drm_device *dev = obj->dev;
	struct drm_handle *han;
	int ret;

	if ((han = drm_calloc(1, sizeof(*han))) == NULL)
		return -ENOMEM;

	han->obj = obj;
	mtx_enter(&file_priv->table_lock);
again:
	*handlep = han->handle = ++file_priv->obj_id;
	/*
	 * Make sure we have no duplicates. this'll hurt once we wrap, 0 is
	 * reserved.
	 */
	if (han->handle == 0 || SPLAY_INSERT(drm_obj_tree,
	    &file_priv->obj_tree, han))
		goto again;
	mtx_leave(&file_priv->table_lock);

	drm_gem_object_handle_reference(obj);

	if (dev->driver->gem_open_object) {
		ret = dev->driver->gem_open_object(obj, file_priv);
		if (ret) {
			drm_gem_handle_delete(file_priv, *handlep);
			return ret;
		}
	}

	return 0;
}

/**
 * Removes the mapping from handle to filp for this object.
 */
int
drm_gem_handle_delete(struct drm_file *filp, u32 handle)
{
	struct drm_device *dev;
	struct drm_gem_object *obj;
	struct drm_handle *han, find;

	find.handle = handle;
	mtx_enter(&filp->table_lock);
	han = SPLAY_FIND(drm_obj_tree, &filp->obj_tree, &find);
	if (han == NULL) {
		mtx_leave(&filp->table_lock);
		return -EINVAL;
	}
	obj = han->obj;
	dev = obj->dev;

	SPLAY_REMOVE(drm_obj_tree, &filp->obj_tree, han);
	mtx_leave(&filp->table_lock);

	drm_free(han);

	if (dev->driver->gem_close_object)
		dev->driver->gem_close_object(obj, filp);
	drm_gem_object_handle_unreference_unlocked(obj);

	return 0;
}

/**
 * drm_gem_dumb_destroy - dumb fb callback helper for gem based drivers
 * 
 * This implements the ->dumb_destroy kms driver callback for drivers which use
 * gem to manage their backing storage.
 */
int
drm_gem_dumb_destroy(struct drm_file *file, struct drm_device *dev,
		     u32 handle)
{
	return drm_gem_handle_delete(file, handle);
}

/** Returns a reference to the object named by the handle. */
struct drm_gem_object *
drm_gem_object_lookup(struct drm_device *dev, struct drm_file *filp,
		      u32 handle)
{
	struct drm_gem_object *obj;
	struct drm_handle *han, search;

	mtx_enter(&filp->table_lock);

	/* Check if we currently have a reference on the object */
	search.handle = handle;
	han = SPLAY_FIND(drm_obj_tree, &filp->obj_tree, &search);
	if (han == NULL) {
		mtx_leave(&filp->table_lock);
		return NULL;
	}
	obj = han->obj;

	drm_gem_object_reference(obj);

	mtx_leave(&filp->table_lock);

	return obj;
}

struct drm_gem_object *
drm_gem_object_find(struct drm_file *filp, u32 handle)
{
	struct drm_handle *han, search;

	MUTEX_ASSERT_LOCKED(&filp->table_lock);

	search.handle = handle;
	han = SPLAY_FIND(drm_obj_tree, &filp->obj_tree, &search);
	if (han == NULL)
		return NULL;

	return han->obj;
}

/**
 * Releases the handle to an mm object.
 */
int
drm_gem_close_ioctl(struct drm_device *dev, void *data,
		    struct drm_file *file_priv)
{
	struct drm_gem_close *args = data;
	int ret;

	if (!(dev->driver->flags & DRIVER_GEM))
		return -ENODEV;

	ret = drm_gem_handle_delete(file_priv, args->handle);

	return ret;
}

int
drm_gem_flink_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_gem_flink	*args = data;
	struct drm_gem_object	*obj;

	if (!(dev->driver->flags & DRIVER_GEM))
		return -ENODEV;

	obj = drm_gem_object_lookup(dev, file_priv, args->handle);
	if (obj == NULL)
		return -ENOENT;

	mtx_enter(&dev->obj_name_lock);
	if (!obj->name) {
again:
		obj->name = ++dev->obj_name; 
		/* 0 is reserved, make sure we don't clash. */
		if (obj->name == 0 || SPLAY_INSERT(drm_name_tree,
		    &dev->name_tree, obj))
			goto again;
		/* name holds a reference to the object */
		drm_ref(&obj->uobj);
	}
	mtx_leave(&dev->obj_name_lock);

	args->name = (uint64_t)obj->name;

	drm_unref(&obj->uobj);

	return 0;
}

/**
 * Open an object using the global name, returning a handle and the size.
 *
 * This handle (of course) holds a reference to the object, so the object
 * will not go away until the handle is deleted.
 */
int
drm_gem_open_ioctl(struct drm_device *dev, void *data,
		   struct drm_file *file_priv)
{
	struct drm_gem_open *args = data;
	struct drm_gem_object *obj, search;
	int ret;
	u32 handle;

	if (!(dev->driver->flags & DRIVER_GEM))
		return -ENODEV;

	mtx_enter(&dev->obj_name_lock);
	search.name = args->name;
	obj = SPLAY_FIND(drm_name_tree, &dev->name_tree, &search);
	if (obj)
		drm_gem_object_reference(obj);
	mtx_leave(&dev->obj_name_lock);
	if (!obj)
		return -ENOENT;

	ret = drm_gem_handle_create(file_priv, obj, &handle);
	drm_gem_object_unreference_unlocked(obj);
	if (ret)
		return ret;

	args->handle = handle;
	args->size = obj->size;

        return 0;
}

void
drm_gem_object_handle_reference(struct drm_gem_object *obj)
{
	drm_gem_object_reference(obj);
	obj->handlecount++;
}

void
drm_gem_object_handle_unreference(struct drm_gem_object *obj)
{
	/* do this first in case this is the last reference */
	if (--obj->handlecount == 0) {
		struct drm_device	*dev = obj->dev;

		mtx_enter(&dev->obj_name_lock);
		if (obj->name) {
			SPLAY_REMOVE(drm_name_tree, &dev->name_tree, obj);
			obj->name = 0;
			mtx_leave(&dev->obj_name_lock);
			/* name held a reference to object */
			drm_gem_object_unreference(obj);
		} else {
			mtx_leave(&dev->obj_name_lock);
		}
	}

	drm_gem_object_unreference(obj);
}

void
drm_gem_object_handle_unreference_unlocked(struct drm_gem_object *obj)
{
	struct drm_device *dev = obj->dev;

	mutex_lock(&dev->struct_mutex);
	drm_gem_object_handle_unreference(obj);
	mutex_unlock(&dev->struct_mutex);
}

/**
 * drm_gem_free_mmap_offset - release a fake mmap offset for an object
 * @@obj: obj in question
 *
 * This routine frees fake offsets allocated by drm_gem_create_mmap_offset().
 */
void
drm_gem_free_mmap_offset(struct drm_gem_object *obj)
{
	struct drm_device *dev = obj->dev;
	struct drm_local_map *map = obj->map;

	TAILQ_REMOVE(&dev->maplist, map, link);
	obj->map = NULL;

	/* NOCOALESCE set, can't fail */
	extent_free(dev->handle_ext, map->ext, map->size, EX_NOWAIT);

	drm_free(map);
}

/**
 * drm_gem_create_mmap_offset - create a fake mmap offset for an object
 * @@obj: obj in question
 *
 * GEM memory mapping works by handing back to userspace a fake mmap offset
 * it can use in a subsequent mmap(2) call.  The DRM core code then looks
 * up the object based on the offset and sets up the various memory mapping
 * structures.
 *
 * This routine allocates and attaches a fake offset for @@obj.
 */
int
drm_gem_create_mmap_offset(struct drm_gem_object *obj)
{
	struct drm_device *dev = obj->dev;
	struct drm_local_map *map;
	int ret;

	/* Set the object up for mmap'ing */
	map = drm_calloc(1, sizeof(*map));
	if (map == NULL)
		return -ENOMEM;

	map->flags = _DRM_DRIVER;
	map->type = _DRM_GEM;
	map->size = obj->size;
	map->handle = obj;

	/* Get a DRM GEM mmap offset allocated... */
	ret = extent_alloc(dev->handle_ext, map->size, PAGE_SIZE, 0,
	    0, EX_NOWAIT, &map->ext);
	if (ret) {
		DRM_ERROR("failed to allocate offset for bo %d\n", obj->name);
		ret = -ENOSPC;
		goto out_free_list;
	}

	TAILQ_INSERT_TAIL(&dev->maplist, map, link);
	obj->map = map;
	return 0;

out_free_list:
	drm_free(map);

	return ret;
}

struct uvm_object *
udv_attach_drm(dev_t device, vm_prot_t accessprot, voff_t off, vsize_t size)
{
	struct drm_device *dev = drm_get_device_from_kdev(device);
	struct drm_local_map *map;
	struct drm_gem_object *obj;

	if (cdevsw[major(device)].d_mmap != drmmmap)
		return NULL;

	if (dev == NULL)
		return NULL;

	if (dev->driver->mmap)
		return dev->driver->mmap(dev, off, size);

	mutex_lock(&dev->struct_mutex);
	TAILQ_FOREACH(map, &dev->maplist, link) {
		if (off >= map->ext && off + size <= map->ext + map->size)
			break;
	}

	if (map == NULL || map->type != _DRM_GEM) {
		mutex_unlock(&dev->struct_mutex);
		return NULL;
	}

	obj = (struct drm_gem_object *)map->handle;
	drm_ref(&obj->uobj);
	mutex_unlock(&dev->struct_mutex);
	return &obj->uobj;
}

a1466 16

int
drm_handle_cmp(struct drm_handle *a, struct drm_handle *b)
{
	return (a->handle < b->handle ? -1 : a->handle > b->handle);
}

int
drm_name_cmp(struct drm_gem_object *a, struct drm_gem_object *b)
{
	return (a->name < b->name ? -1 : a->name > b->name);
}

SPLAY_GENERATE(drm_obj_tree, drm_handle, entry, drm_handle_cmp);

SPLAY_GENERATE(drm_name_tree, drm_gem_object, entry, drm_name_cmp);
@


1.144
log
@Use uiomove(9) instead of uiomovei(9).  From Martin Natano.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.143 2016/01/06 09:09:16 kettenis Exp $ */
d402 3
a404 2
	struct drm_device	*dev = (struct drm_device *)self;
	struct drm_attach_args	*da = aux;
d413 1
a413 1
	dev->pdev = &dev->drm_pci;
d418 5
@


1.143
log
@Add pledge "drm", which allows a subset of the drm(4) ioctls.  These are
basically only the ioctls that Linux allows on the so-called "render nodes".
For now, it also allows DRM_IOCTL_GET_MAGIC and DRM_IOCTL_GEM_OPEN, as we
don't implement prime/dma-buf yet in OpenBSD.  That still leaves a big gaping
hole, so they will be removed as soon as we can.

Based on a diff by robert@@, who did all the heavy lifting by studying the
behaviour of the chromium GPU process, with some further suggestions by
deraadt@@.

ok jsg@@, deraadt@@, robert@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.142 2015/12/31 13:01:00 kettenis Exp $ */
d951 1
a951 1
		error = uiomovei(ev->event, ev->event->length, uio);
@


1.142
log
@Provide a minimal implementation of the Linux vga_get/vga_put API and use it
in inteldrm(4).

The Intel integrated graphics device has a major design flaw where it needs
legacy VGA io access to disable VGA mode completely.  This only works if
legacy VGA io routing is setup such that it actually reaches the IGD.  This
typically isn't the case if the primary VGA device is a discrete graphics
device.  To make sure we don't whack that device we have to temporarily
route legacy VGA io access to the IGD.

Fixes the "black screen" issue reported by Timo Myrra and others.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.141 2015/12/20 13:10:09 kettenis Exp $ */
d47 1
d248 35
@


1.141
log
@Advertise support for DRM version 1.4.  We have support for all the necessary
features, and some code (such as the Xorg modesetting driver) actually checks
the version.  With this change the PCI-based probe method in that driver
works.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.140 2015/11/22 15:35:49 kettenis Exp $ */
d386 1
@


1.140
log
@Remove drm_gem_object_alloc() and associated infrastructure.  It's unused and
has been removed upstream as well.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.139 2015/11/21 15:23:44 kettenis Exp $ */
d1183 1
a1183 1
#define DRM_IF_MINOR	2
@


1.139
log
@The drm irq stuff isn't actually used on OpenBSD.  Using the PCI device
interrupt line register as the irq number doesn't really work as the contents
of that register might be 0, and the code has checks for non-zero irq
numbers in places.  Insteadmake drm_dev_to_irq() return -1, which is an
obviously bogus, but non-zero value.

This should fix inteldrm(4) on recent Apple hardware.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.138 2015/09/26 19:52:16 kettenis Exp $ */
a1469 28
struct drm_gem_object *
drm_gem_object_alloc(struct drm_device *dev, size_t size)
{
	struct drm_gem_object	*obj;

	KASSERT((size & (PAGE_SIZE -1)) == 0);

	if ((obj = pool_get(&dev->objpl, PR_WAITOK | PR_ZERO)) == NULL)
		return (NULL);

	obj->dev = dev;

	/* uao create can't fail in the 0 case, it just sleeps */
	obj->uao = uao_create(size, 0);
	obj->size = size;
	uvm_objinit(&obj->uobj, &drm_pgops, 1);

	if (dev->driver->gem_init_object != NULL &&
	    dev->driver->gem_init_object(obj) != 0) {
		uao_detach(obj->uao);
		pool_put(&dev->objpl, obj);
		return (NULL);
	}
	atomic_inc(&dev->obj_count);
	atomic_add(obj->size, &dev->obj_memory);
	return (obj);
}

@


1.138
log
@Update drm_irq.c to the version from Linux 3.14.52.
Disable the DRM_IOCTL_IRQ_BUSID and DRM_IOCTL_CONTROL ioctls.
These are legacy ioctls for DRI1 support, which we no longer support on
OpenBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.137 2015/09/23 23:12:11 kettenis Exp $ */
a282 1
	arg.irq = pa->pa_intrline;
a373 1
	dev->irq = da->irq;
@


1.137
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.136 2015/09/06 11:17:49 kettenis Exp $ */
d114 1
a115 1
#ifdef __linux__
a181 1
#endif
d185 1
a185 1
#if defined(__linux__) && defined(__OS_HAS_AGP)
a195 1
#ifdef __linux__
d395 1
a395 1
	TAILQ_INIT(&dev->vbl_events);
d636 1
a636 1
	TAILQ_INIT(&file_priv->evlist);
d684 2
a685 2
	struct drm_pending_event	*ev, *evtmp;
	struct drm_pending_vblank_event	*vev;
d711 7
a717 8
	struct drmevlist *list = &dev->vbl_events;
	for (ev = TAILQ_FIRST(list); ev != NULL; ev = evtmp) {
		evtmp = TAILQ_NEXT(ev, link);
		vev = (struct drm_pending_vblank_event *)ev;
		if (ev->file_priv == file_priv) {
			TAILQ_REMOVE(list, ev, link);
			drm_vblank_put(dev, vev->pipe);
			ev->destroy(ev);
d719 5
d725 1
a725 4
	while ((ev = TAILQ_FIRST(&file_priv->evlist)) != NULL) {
		TAILQ_REMOVE(&file_priv->evlist, ev, link);
		ev->destroy(ev);
	}
d901 1
a901 1
	while (error == 0 && TAILQ_EMPTY(&file_priv->evlist)) {
d906 1
a906 1
		error = msleep(&file_priv->evlist, &dev->event_lock,
d940 2
a941 2
	struct drm_pending_event	*ev = NULL;
	int				 gotone = 0;
d944 7
a950 2
	if ((ev = TAILQ_FIRST(&file_priv->evlist)) == NULL ||
	    ev->event->length > resid)
d953 3
a955 3
	TAILQ_REMOVE(&file_priv->evlist, ev, link);
	file_priv->event_space += ev->event->length;
	*out = ev;
d983 1
a983 1
		if (!TAILQ_EMPTY(&file_priv->evlist))
@


1.136
log
@We actually need an interrupt-safe allocator here, as we call pool_put()
with a mutex held, so we can't have it sleep.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.135 2015/04/17 00:54:41 jsg Exp $ */
d104 1
d111 1
a111 1
	DRM_IOCTL_DEF(DRM_IOCTL_VERSION, drm_version, DRM_UNLOCKED),
d120 2
a121 1
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CAP, drm_getcap, DRM_UNLOCKED),
d146 3
a148 1
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_modctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
a152 1
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d181 1
a181 2
	/* The DRM_IOCTL_DMA ioctl should be defined by the driver. */
	DRM_IOCTL_DEF(DRM_IOCTL_DMA, NULL, DRM_AUTH),
d198 1
a198 1
	DRM_IOCTL_DEF(DRM_IOCTL_SG_ALLOC, drm_sg_alloc_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d208 1
a208 1
	DRM_IOCTL_DEF(DRM_IOCTL_GEM_CLOSE, drm_gem_close_ioctl, DRM_UNLOCKED),
d215 2
a216 2
	DRM_IOCTL_DEF(DRM_IOCTL_PRIME_HANDLE_TO_FD, drm_prime_handle_to_fd_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_PRIME_FD_TO_HANDLE, drm_prime_fd_to_handle_ioctl, DRM_AUTH|DRM_UNLOCKED),
d229 2
a230 2
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_ATTACHMODE, drm_mode_attachmode_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DETACHMODE, drm_mode_detachmode_ioctl, DRM_MASTER|DRM_CONTROL_ALLOW|DRM_UNLOCKED),
d245 1
d297 1
d387 1
d389 1
d706 2
d748 3
d768 1
a768 1
	struct drm_ioctl_desc *ioctl;
d1129 6
d1138 15
d1159 21
d1602 13
d1639 15
@


1.135
log
@Make drm ioctls table driven.  Further reduces the diff to linux.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.134 2015/04/15 09:48:18 kettenis Exp $ */
d427 1
a427 1
		    "drmobjpl", &pool_allocator_nointr);
@


1.134
log
@Convert remaining drm ioctl implementation functions to return Linux-style
negative errno values.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.133 2015/02/10 21:56:09 miod Exp $ */
d97 2
d105 161
d757 5
d768 1
a768 1
		return EINVAL;
d789 24
a812 12
	case DRM_IOCTL_VERSION:
		return -drm_version(dev, data, file_priv);
	case DRM_IOCTL_GET_UNIQUE:
		return -drm_getunique(dev, data, file_priv);
	case DRM_IOCTL_GET_MAGIC:
		return -drm_getmagic(dev, data, file_priv);
	case DRM_IOCTL_WAIT_VBLANK:
		return -drm_wait_vblank(dev, data, file_priv);
	case DRM_IOCTL_MODESET_CTL:
		return -drm_modeset_ctl(dev, data, file_priv);
	case DRM_IOCTL_GEM_CLOSE:
		return -drm_gem_close_ioctl(dev, data, file_priv);
d814 17
a830 27
	/*
	 * no-oped ioctls, we don't check permissions on them because
	 * they do nothing. they'll be removed as soon as userland is
	 * definitely purged
	 */
	case DRM_IOCTL_SET_SAREA_CTX:
	case DRM_IOCTL_BLOCK:
	case DRM_IOCTL_UNBLOCK:
	case DRM_IOCTL_MOD_CTX:
	case DRM_IOCTL_MARK_BUFS:
	case DRM_IOCTL_FINISH:
	case DRM_IOCTL_INFO_BUFS:
	case DRM_IOCTL_SWITCH_CTX:
	case DRM_IOCTL_NEW_CTX:
	case DRM_IOCTL_GET_SAREA_CTX:
		return (0);
	}

	if (file_priv->authenticated == 1) {
		switch (cmd) {
		case DRM_IOCTL_GEM_FLINK:
			return -drm_gem_flink_ioctl(dev, data, file_priv);
		case DRM_IOCTL_GEM_OPEN:
			return -drm_gem_open_ioctl(dev, data, file_priv);
		case DRM_IOCTL_GET_CAP:
			return -drm_getcap(dev, data, file_priv);
		}
d833 1
a833 93
	/* master is always root */
	if (file_priv->master == 1) {
		switch(cmd) {
		case DRM_IOCTL_SET_VERSION:
			return -drm_setversion(dev, data, file_priv);
		case DRM_IOCTL_IRQ_BUSID:
			return -drm_irq_by_busid(dev, data, file_priv);
		case DRM_IOCTL_AUTH_MAGIC:
			return -drm_authmagic(dev, data, file_priv);
		case DRM_IOCTL_CONTROL:
			return -drm_control(dev, data, file_priv);
		case DRM_IOCTL_ADD_DRAW:
		case DRM_IOCTL_RM_DRAW:
		case DRM_IOCTL_UPDATE_DRAW:
			/*
			 * Support removed from kernel since it's not used.
			 * just return zero until userland stops calling this
			 * ioctl.
			 */
			return (0);
		case DRM_IOCTL_SET_UNIQUE:
		/*
		 * Deprecated in DRM version 1.1, and will return EBUSY
		 * when setversion has
		 * requested version 1.1 or greater.
		 */
			return (EBUSY);
		case DRM_IOCTL_MODE_GETRESOURCES:
			return -drm_mode_getresources(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETPLANERESOURCES:
			return -drm_mode_getplane_res(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETCRTC:
			return -drm_mode_getcrtc(dev, data, file_priv);
		case DRM_IOCTL_MODE_SETCRTC:
			return -drm_mode_setcrtc(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETPLANE:
			return -drm_mode_getplane(dev, data, file_priv);
		case DRM_IOCTL_MODE_SETPLANE:
			return -drm_mode_setplane(dev, data, file_priv);
		case DRM_IOCTL_MODE_CURSOR:
			return -drm_mode_cursor_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETGAMMA:
			return -drm_mode_gamma_get_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_SETGAMMA:
			return -drm_mode_gamma_set_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETENCODER:
			return -drm_mode_getencoder(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETCONNECTOR:
			return -drm_mode_getconnector(dev, data, file_priv);
		case DRM_IOCTL_MODE_ATTACHMODE:
			return -drm_mode_attachmode_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_DETACHMODE:
			return -drm_mode_detachmode_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETPROPERTY:
			return -drm_mode_getproperty_ioctl(dev, data, 
			    file_priv);
		case DRM_IOCTL_MODE_SETPROPERTY:
			return -drm_mode_connector_property_set_ioctl(dev, 
			    data, file_priv);
		case DRM_IOCTL_MODE_GETPROPBLOB:
			return -drm_mode_getblob_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_GETFB:
			return -drm_mode_getfb(dev, data, file_priv);
		case DRM_IOCTL_MODE_ADDFB:
			return -drm_mode_addfb(dev, data, file_priv);
		case DRM_IOCTL_MODE_ADDFB2:
			return -drm_mode_addfb2(dev, data, file_priv);
		case DRM_IOCTL_MODE_RMFB:
			return -drm_mode_rmfb(dev, data, file_priv);
		case DRM_IOCTL_MODE_PAGE_FLIP:
			return -drm_mode_page_flip_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_DIRTYFB:
			return -drm_mode_dirtyfb_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_CREATE_DUMB:
			return -drm_mode_create_dumb_ioctl(dev, data, 
			    file_priv);
		case DRM_IOCTL_MODE_MAP_DUMB:
			return -drm_mode_mmap_dumb_ioctl(dev, data, file_priv);
		case DRM_IOCTL_MODE_DESTROY_DUMB:
			return -drm_mode_destroy_dumb_ioctl(dev, data, 
			    file_priv);
		case DRM_IOCTL_MODE_OBJ_GETPROPERTIES:
			return -drm_mode_obj_get_properties_ioctl(dev, data,
			    file_priv);
		case DRM_IOCTL_MODE_OBJ_SETPROPERTY:
			return -drm_mode_obj_set_property_ioctl(dev, data,
			    file_priv);
		}
	}
	if (dev->driver->ioctl != NULL)
		return (dev->driver->ioctl(dev, cmd, data, file_priv));
	else
		return (EINVAL);
d853 1
a853 1
	error = drm_do_ioctl(dev, minor(kdev), cmd, data);
@


1.133
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.132 2015/02/10 01:39:32 jsg Exp $ */
d622 1
a622 1
		return (drm_version(dev, data, file_priv));
d624 1
a624 1
		return (drm_getunique(dev, data, file_priv));
d626 1
a626 1
		return (drm_getmagic(dev, data, file_priv));
d628 1
a628 1
		return (drm_wait_vblank(dev, data, file_priv));
d630 1
a630 1
		return (drm_modeset_ctl(dev, data, file_priv));
d655 1
a655 1
			return (drm_gem_flink_ioctl(dev, data, file_priv));
d659 1
a659 1
			return (drm_getcap(dev, data, file_priv));
d667 1
a667 1
			return (drm_setversion(dev, data, file_priv));
d669 1
a669 1
			return (drm_irq_by_busid(dev, data, file_priv));
d671 1
a671 1
			return (drm_authmagic(dev, data, file_priv));
d673 1
a673 1
			return (drm_control(dev, data, file_priv));
d776 2
d1013 1
a1013 1
			return EFAULT;
d1044 1
a1044 1
		return EINVAL;
d1064 1
a1064 1
			return EFAULT;				\
d1101 1
a1101 1
			return EINVAL;
d1111 1
a1111 1
			return EINVAL;
d1204 1
a1204 1
	return (0);
d1215 1
a1215 1
	int		 ret = EINVAL;
d1220 1
a1220 1
		return (ret);
d1233 1
a1233 1
	return (ret);
d1523 1
a1523 1
		return (ENODEV);
d1527 1
a1527 1
		return (ENOENT);
d1546 1
a1546 1
	return (0);
@


1.132
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.131 2014/09/24 10:35:39 jsg Exp $ */
d826 1
a826 1
		error = uiomove(ev->event, ev->event->length, uio);
@


1.131
log
@fix the build when DRMDEBUG is defined
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.130 2014/09/13 16:06:37 doug Exp $ */
d222 1
a222 1
	rw_init(&dev->dev_lock, "drmdevlk");
d448 1
a448 1
	DRM_LOCK();
d450 1
a450 1
		DRM_UNLOCK();
d454 1
a454 1
		DRM_UNLOCK();
d488 1
a488 1
	DRM_LOCK();
d491 1
a491 1
		DRM_UNLOCK();
d499 1
a499 1
	DRM_UNLOCK();
d506 1
a506 1
	DRM_LOCK();
d508 1
a508 1
	DRM_UNLOCK();
d526 1
a526 1
	DRM_LOCK();
d533 1
a533 1
	DRM_UNLOCK();
d561 1
a561 1
	DRM_LOCK();
d582 1
a582 1
		DRM_UNLOCK();
d585 1
a585 1
		DRM_UNLOCK();
d595 1
a595 1
	DRM_LOCK();
d597 1
a597 1
	DRM_UNLOCK();
d797 1
a797 1
	DRM_LOCK();
d799 1
a799 1
	DRM_UNLOCK();
d880 1
a880 1
	DRM_LOCK();
d882 1
a882 1
	DRM_UNLOCK();
d903 1
a903 1
	DRM_LOCK();
d908 1
a908 1
	DRM_UNLOCK();
d923 1
a923 1
	DRM_LOCK();
d925 1
a925 1
	DRM_UNLOCK();
d955 1
a955 1
	DRM_LOCK();
d965 1
a965 1
		DRM_UNLOCK();
d970 1
a970 1
		DRM_UNLOCK();
d975 1
a975 1
	DRM_UNLOCK();
d1195 1
a1195 1
		DRM_LOCK();
d1197 1
a1197 1
		DRM_UNLOCK();
d1220 1
a1220 1
	DRM_LOCK();
d1229 1
a1229 1
	DRM_UNLOCK();
d1619 1
a1619 1
	DRM_LOCK();
d1621 1
a1621 1
	DRM_UNLOCK();
d1708 1
a1708 1
	DRM_LOCK();
d1715 1
a1715 1
		DRM_UNLOCK();
d1721 1
a1721 1
	DRM_UNLOCK();
@


1.130
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.129 2014/07/12 18:48:52 tedu Exp $ */
d606 1
a606 1
	    DRM_CURRENTPID, cmd, DRM_IOCTL_NR(cmd), (long)&dev->device,
@


1.129
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.128 2014/07/02 06:09:49 matthew Exp $ */
d543 1
a543 2
	for (ev = TAILQ_FIRST(list); ev != TAILQ_END(list);
	    ev = evtmp) {
@


1.128
log
@Use real parameter types for u{dv,vn}_attach() instead of void *

ok guenther
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.127 2014/04/07 06:43:11 jsg Exp $ */
d1158 1
a1158 1
	free(mem, M_DRM);
d1173 1
a1173 1
	free(mem, M_DRM);
@


1.127
log
@reduce the diff to linux for drm pci vid/pid tests
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.126 2014/03/25 17:44:39 mpi Exp $ */
d1694 1
a1694 1
udv_attach_drm(void *arg, vm_prot_t accessprot, voff_t off, vsize_t size)
a1695 1
	dev_t device = *((dev_t *)arg);
@


1.126
log
@Remove and shuffle some includes to reduce their number since drmP.h
is included by a lot of files.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.125 2014/03/13 12:45:04 kettenis Exp $ */
d213 5
a217 4
	dev->pci_vendor = da->pci_vendor;
	dev->pci_device = da->pci_device;
	dev->pci_subvendor = da->pci_subvendor;
	dev->pci_subdevice = da->pci_subdevice;
@


1.125
log
@Block userland from entering drm code (and make sure it is no longer in there)
before we truly start quiescing the device and don't unblock until we've
finished waking the device up.  Fixes issues with suspend/resume on inteldrm(4)
and perhaps radeondrm(4) as well.

i"it is the right place to stall" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.124 2014/03/09 07:42:29 jsg Exp $ */
d44 2
d47 1
d50 3
a54 2

#include <sys/ttycom.h> /* for TIOCSGRP */
@


1.124
log
@remove dri1 interfaces
discussed with kettenis some time last year
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.123 2014/02/23 09:36:52 kettenis Exp $ */
d66 3
d71 1
d219 1
d301 38
d341 1
a341 1
	drm_detach
a585 2
/* drmioctl is called whenever a process performs an ioctl on /dev/drm.
 */
d587 1
a587 2
drmioctl(dev_t kdev, u_long cmd, caddr_t data, int flags, 
    struct proc *p)
a588 1
	struct drm_device *dev = drm_get_device_from_kdev(kdev);
a590 3
	if (dev == NULL)
		return ENODEV;

d592 1
a592 1
	file_priv = drm_find_file_by_minor(dev, minor(kdev));
d754 28
d1291 22
d1317 7
@


1.123
log
@Give drm(4) a console locator just like wsdisplay(4) such that we can make
sure /dev/drm0 always matches the primary display.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.122 2014/01/30 15:10:47 kettenis Exp $ */
a213 1
	mtx_init(&dev->lock.spinlock, IPL_NONE);
a247 5
	if (drm_ctxbitmap_init(dev) != 0) {
		printf(": couldn't allocate memory for context bitmap.\n");
		goto error;
	}

a274 2
	drm_ctxbitmap_cleanup(dev);

a348 9
	struct drm_local_map	*map;
	int			 i;

	/* prebuild the SAREA */
	i = drm_addmap(dev, 0, SAREA_MAX, _DRM_SHM,
	    _DRM_CONTAINS_LOCK, &map);
	if (i != 0)
		return i;

a351 6
	if (drm_core_check_feature(dev, DRIVER_DMA) &&
	    !drm_core_check_feature(dev, DRIVER_MODESET)) {
		if ((i = drm_dma_setup(dev)) != 0)
			return (i);
	}

a367 2
	struct drm_local_map	*map, *mapsave;

a379 27
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		drm_dma_takedown(dev);

	DRM_LOCK();
	if (dev->sg != NULL &&
	    !drm_core_check_feature(dev, DRIVER_MODESET)) {
		struct drm_sg_mem *sg = dev->sg; 
		dev->sg = NULL;

		DRM_UNLOCK();
		drm_sg_cleanup(dev, sg);
		DRM_LOCK();
	}

	for (map = TAILQ_FIRST(&dev->maplist); map != TAILQ_END(&dev->maplist);
	    map = mapsave) {
		mapsave = TAILQ_NEXT(map, link);
		if ((map->flags & _DRM_DRIVER) == 0)
			drm_rmmap_locked(dev, map);
	}

	if (dev->lock.hw_lock != NULL) {
		dev->lock.hw_lock = NULL; /* SHM removed */
		dev->lock.file_priv = NULL;
		wakeup(&dev->lock); /* there should be nothing sleeping on it */
	}
	DRM_UNLOCK();
a492 12
	if (dev->lock.hw_lock && _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock)
	    && dev->lock.file_priv == file_priv) {
		DRM_DEBUG("Process %d dead, freeing lock for context %d\n",
		    DRM_CURRENTPID,
		    _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));

		drm_lock_free(&dev->lock,
		    _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
	}
	if (dev->driver->flags & DRIVER_DMA)
		drm_reclaim_buffers(dev, file_priv);

a593 7
	/* removed */
	case DRM_IOCTL_GET_MAP:
		/* FALLTHROUGH */
	case DRM_IOCTL_GET_CLIENT:
		/* FALLTHROUGH */
	case DRM_IOCTL_GET_STATS:
		return (EINVAL);
a613 20
		case DRM_IOCTL_RM_MAP:
			return (drm_rmmap_ioctl(dev, data, file_priv));
		case DRM_IOCTL_GET_CTX:
			return (drm_getctx(dev, data, file_priv));
		case DRM_IOCTL_RES_CTX:
			return (drm_resctx(dev, data, file_priv));
		case DRM_IOCTL_LOCK:
			return (drm_lock(dev, data, file_priv));
		case DRM_IOCTL_UNLOCK:
			return (drm_unlock(dev, data, file_priv));
		case DRM_IOCTL_MAP_BUFS:
			return (drm_mapbufs(dev, data, file_priv));
		case DRM_IOCTL_FREE_BUFS:
			return (drm_freebufs(dev, data, file_priv));
		case DRM_IOCTL_DMA:
			return (drm_dma(dev, data, file_priv));
#if __OS_HAS_AGP
		case DRM_IOCTL_AGP_INFO:
			return (drm_agp_info_ioctl(dev, data, file_priv));
#endif
a619 1

a631 8
		case DRM_IOCTL_ADD_MAP:
			return (drm_addmap_ioctl(dev, data, file_priv));
		case DRM_IOCTL_ADD_CTX:
			return (drm_addctx(dev, data, file_priv));
		case DRM_IOCTL_RM_CTX:
			return (drm_rmctx(dev, data, file_priv));
		case DRM_IOCTL_ADD_BUFS:
			return (drm_addbufs(dev, (struct drm_buf_desc *)data));
a633 20
#if __OS_HAS_AGP
		case DRM_IOCTL_AGP_ACQUIRE:
			return (drm_agp_acquire_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_RELEASE:
			return (drm_agp_release_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_ENABLE:
			return (drm_agp_enable_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_ALLOC:
			return (drm_agp_alloc_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_FREE:
			return (drm_agp_free_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_BIND:
			return (drm_agp_bind_ioctl(dev, data, file_priv));
		case DRM_IOCTL_AGP_UNBIND:
			return (drm_agp_unbind_ioctl(dev, data, file_priv));
#endif
		case DRM_IOCTL_SG_ALLOC:
			return (drm_sg_alloc_ioctl(dev, data, file_priv));
		case DRM_IOCTL_SG_FREE:
			return (drm_sg_free(dev, data, file_priv));
a918 5
	/* XXX unify all the bus_dmamem_mmap bits */
	case _DRM_SCATTER_GATHER:
		return (bus_dmamem_mmap(dev->dmat, dev->sg->mem->segs,
		    dev->sg->mem->nsegs, map->offset - dev->sg->handle +
		    offset, prot, BUS_DMA_NOWAIT));
d1627 18
@


1.122
log
@Get rid of the simple locks; they're lies.  Also get rid of the holding
logic for uvm objects; it's not necessary anymore as far as I can tell, at
least as long as we run all this code under the kernel lock.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.121 2014/01/20 09:20:49 deraadt Exp $ */
d103 1
a103 1
    int is_agp, struct device *dev)
d113 1
d173 1
d176 13
a188 1
	return (da->driver != NULL ? 1 : 0);
@


1.121
log
@drm_activate() serves no purpose; ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.120 2013/12/21 19:36:42 kettenis Exp $ */
a1284 1

d1286 1
a1286 69
drm_hold_object_locked(struct drm_gem_object *obj)
{
	while (obj->do_flags & DRM_BUSY) {
		atomic_setbits_int(&obj->do_flags, DRM_WANTED);
		simple_unlock(&uobj->vmobjlock);
#ifdef DRMLOCKDEBUG
		{
		int ret = 0;
		ret = tsleep(obj, PVM, "drm_hold", 3 * hz); /* XXX msleep */
		if (ret)
			printf("still waiting for obj %p, owned by %p\n",
			    obj, obj->holding_proc);
		}
#else
		tsleep(obj, PVM, "drm_hold", 0); /* XXX msleep */
#endif
		simple_lock(&uobj->vmobjlock);
	}
#ifdef DRMLOCKDEBUG
	obj->holding_proc = curproc;
#endif
	atomic_setbits_int(&obj->do_flags, DRM_BUSY);
}

void
drm_hold_object(struct drm_gem_object *obj)
{
	simple_lock(&obj->uobj->vmobjlock);
	drm_hold_object_locked(obj);
	simple_unlock(&obj->uobj->vmobjlock);
}

int
drm_try_hold_object(struct drm_gem_object *obj)
{
	simple_lock(&obj->uobj->vmobjlock);
	/* if the object is free, grab it */
	if (obj->do_flags & (DRM_BUSY | DRM_WANTED))
		return (0);
	atomic_setbits_int(&obj->do_flags, DRM_BUSY);
#ifdef DRMLOCKDEBUG
	obj->holding_proc = curproc;
#endif
	simple_unlock(&obj->uobj->vmobjlock);
	return (1);
}


void
drm_unhold_object_locked(struct drm_gem_object *obj)
{
	if (obj->do_flags & DRM_WANTED)
		wakeup(obj);
#ifdef DRMLOCKDEBUG
	obj->holding_proc = NULL;
#endif
	atomic_clearbits_int(&obj->do_flags, DRM_WANTED | DRM_BUSY);	
}

void
drm_unhold_object(struct drm_gem_object *obj)
{
	simple_lock(&obj->uobj->vmobjlock);
	drm_unhold_object_locked(obj);
	simple_unlock(&obj->uobj->vmobjlock);
}

void
drm_ref_locked(struct uvm_object *uobj)
a1291 8
drm_ref(struct uvm_object *uobj)
{
	simple_lock(&uobj->vmobjlock);
	drm_ref_locked(uobj);
	simple_unlock(&uobj->vmobjlock);
}

void
d1294 2
a1295 9
	simple_lock(&uobj->vmobjlock);
	drm_unref_locked(uobj);
}

void
drm_unref_locked(struct uvm_object *uobj)
{
	struct drm_gem_object	*obj = (struct drm_gem_object *)uobj;
	struct drm_device	*dev = obj->dev;
a1296 1
again:
a1298 1
		simple_unlock(&uobj->vmobjlock);
d1302 1
a1302 14
	/* inlined version of drm_hold because we want to trylock then sleep */
	if (obj->do_flags & DRM_BUSY) {
		atomic_setbits_int(&obj->do_flags, DRM_WANTED);
		simple_unlock(&uobj->vmobjlock);
		tsleep(obj, PVM, "drm_unref", 0); /* XXX msleep */
		simple_lock(&uobj->vmobjlock);
		goto again;
	}
#ifdef DRMLOCKDEBUG
	obj->holding_proc = curproc;
#endif
	atomic_setbits_int(&obj->do_flags, DRM_BUSY);
	simple_unlock(&obj->vmobjlock);
	/* We own this thing now. it is on no queues, though it may still
a1310 12
/*
 * convenience function to unreference and unhold an object.
 */
void
drm_unhold_and_unref(struct drm_gem_object *obj)
{
	drm_lock_obj(obj);
	drm_unhold_object_locked(obj);
	drm_unref_locked(&obj->uobj);
}


a1316 1

a1722 1
again:
a1734 13
	simple_lock(&uobj->vmobjlock);
	if (obj->do_flags & DRM_BUSY) {
		atomic_setbits_int(&obj->do_flags, DRM_WANTED);
		simple_unlock(&uobj->vmobjlock);
		DRM_UNLOCK();
		tsleep(obj, PVM, "udv_drm", 0); /* XXX msleep */
		goto again;
	}
#ifdef DRMLOCKDEBUG
	obj->holding_proc = curproc;
#endif
	atomic_setbits_int(&obj->do_flags, DRM_BUSY);
	simple_unlock(&obj->vmobjlock);
a1735 1
	drm_unhold_object(obj);
@


1.120
log
@Advertise that we provide monotonic timestamps.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.119 2013/12/16 19:57:09 kettenis Exp $ */
a65 1
int	 drm_activate(struct device *, int);
a289 11
int
drm_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_DEACTIVATE:
		/* FIXME */
		break;
	}
	return (0);
}

d292 1
a292 1
	drm_detach, drm_activate
@


1.119
log
@Switch generic drm modesetting code over to Linux-style negative errno
return values.  Fixes at least one bug where userland would see a negative
errno value and hopefully doesn't introduce any new ones.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.118 2013/12/05 13:29:56 kettenis Exp $ */
d1092 3
@


1.118
log
@Rename 'struct drm_obj' to 'struct drm_gem_object' to reduce the diffs with
Linux.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.117 2013/11/27 20:41:19 kettenis Exp $ */
d769 1
a769 1
			return drm_mode_getresources(dev, data, file_priv);
d771 1
a771 1
			return drm_mode_getplane_res(dev, data, file_priv);
d773 1
a773 1
			return drm_mode_getcrtc(dev, data, file_priv);
d775 1
a775 1
			return drm_mode_setcrtc(dev, data, file_priv);
d777 1
a777 1
			return drm_mode_getplane(dev, data, file_priv);
d779 1
a779 1
			return drm_mode_setplane(dev, data, file_priv);
d781 1
a781 1
			return drm_mode_cursor_ioctl(dev, data, file_priv);
d783 1
a783 1
			return drm_mode_gamma_get_ioctl(dev, data, file_priv);
d785 1
a785 1
			return drm_mode_gamma_set_ioctl(dev, data, file_priv);
d787 1
a787 1
			return drm_mode_getencoder(dev, data, file_priv);
d789 1
a789 1
			return drm_mode_getconnector(dev, data, file_priv);
d791 1
a791 1
			return drm_mode_attachmode_ioctl(dev, data, file_priv);
d793 1
a793 1
			return drm_mode_detachmode_ioctl(dev, data, file_priv);
d795 1
a795 1
			return drm_mode_getproperty_ioctl(dev, data, 
d798 1
a798 1
			return drm_mode_connector_property_set_ioctl(dev, 
d801 1
a801 1
			return drm_mode_getblob_ioctl(dev, data, file_priv);
d803 1
a803 1
			return drm_mode_getfb(dev, data, file_priv);
d805 1
a805 1
			return drm_mode_addfb(dev, data, file_priv);
d807 1
a807 1
			return drm_mode_addfb2(dev, data, file_priv);
d809 1
a809 1
			return drm_mode_rmfb(dev, data, file_priv);
d811 1
a811 1
			return drm_mode_page_flip_ioctl(dev, data, file_priv);
d813 1
a813 1
			return drm_mode_dirtyfb_ioctl(dev, data, file_priv);
d815 1
a815 1
			return drm_mode_create_dumb_ioctl(dev, data, 
d818 1
a818 1
			return drm_mode_mmap_dumb_ioctl(dev, data, file_priv);
d820 1
a820 1
			return drm_mode_destroy_dumb_ioctl(dev, data, 
d823 1
a823 1
			return drm_mode_obj_get_properties_ioctl(dev, data,
d826 1
a826 1
			return drm_mode_obj_set_property_ioctl(dev, data,
@


1.117
log
@Hook up gem_open/close_object methods.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.116 2013/11/02 22:58:10 kettenis Exp $ */
d81 3
a83 3
void	 drm_gem_object_handle_reference(struct drm_obj *);
void	 drm_gem_object_handle_unreference(struct drm_obj *);
void	 drm_gem_object_handle_unreference_unlocked(struct drm_obj *);
d86 1
a86 1
int	 drm_name_cmp(struct drm_obj *, struct drm_obj *);
d92 1
a92 1
SPLAY_PROTOTYPE(drm_name_tree, drm_obj, entry, drm_name_cmp);
d244 1
a244 1
		KASSERT(dev->driver->gem_size >= sizeof(struct drm_obj));
d1296 1
a1296 1
drm_hold_object_locked(struct drm_obj *obj)
d1321 1
a1321 1
drm_hold_object(struct drm_obj *obj)
d1329 1
a1329 1
drm_try_hold_object(struct drm_obj *obj)
d1345 1
a1345 1
drm_unhold_object_locked(struct drm_obj *obj)
d1356 1
a1356 1
drm_unhold_object(struct drm_obj *obj)
d1387 1
a1387 1
	struct drm_obj		*obj = (struct drm_obj *)uobj;
d1423 1
a1423 1
drm_unhold_and_unref(struct drm_obj *obj)
d1445 1
a1445 1
	struct drm_obj *obj = (struct drm_obj *)uobj;
d1470 1
a1470 1
struct drm_obj *
d1473 1
a1473 1
	struct drm_obj	*obj;
d1499 1
a1499 1
drm_gem_object_init(struct drm_device *dev, struct drm_obj *obj, size_t size)
d1516 1
a1516 1
drm_gem_object_release(struct drm_obj *obj)
d1536 1
a1536 1
		       struct drm_obj *obj,
d1579 1
a1579 1
	struct drm_obj *obj;
d1605 1
a1605 1
struct drm_obj *
d1609 1
a1609 1
	struct drm_obj *obj;
d1653 1
a1653 1
	struct drm_obj		*obj;
d1693 1
a1693 1
	struct drm_obj *obj, search;
d1721 1
a1721 1
drm_gem_object_handle_reference(struct drm_obj *obj)
d1728 1
a1728 1
drm_gem_object_handle_unreference(struct drm_obj *obj)
d1750 1
a1750 1
drm_gem_object_handle_unreference_unlocked(struct drm_obj *obj)
d1766 1
a1766 1
drm_gem_free_mmap_offset(struct drm_obj *obj)
d1792 1
a1792 1
drm_gem_create_mmap_offset(struct drm_obj *obj)
d1833 1
a1833 1
	struct drm_obj *obj;
d1856 1
a1856 1
	obj = (struct drm_obj *)map->handle;
d1935 1
a1935 1
drm_name_cmp(struct drm_obj *a, struct drm_obj *b)
d1942 1
a1942 1
SPLAY_GENERATE(drm_name_tree, drm_obj, entry, drm_name_cmp);
@


1.116
log
@Replace drm_handle_create/delete with drm_gem_handle_create/delete and make
the necessary adjustments to reference counting of GEM objects.  Matches what
Linux does these days.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.115 2013/10/26 20:31:48 kettenis Exp $ */
d1539 3
a1541 1
	struct drm_handle	*han;
d1561 8
d1578 1
d1589 2
a1591 1
	obj = han->obj;
d1597 2
@


1.115
log
@Unstub i915_gem_dumb_destroy() and radeon_mode_dumb_destroy().
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.114 2013/09/30 03:26:21 jsg Exp $ */
d81 3
a83 2
void	 drm_handle_ref(struct drm_obj *);
void	 drm_handle_unref(struct drm_obj *);
d583 1
a583 1
			drm_handle_unref(han->obj);
d654 1
a654 1
		return (drm_gem_close_ioctl(dev, data, file_priv));
d706 1
a706 1
			return (drm_gem_open_ioctl(dev, data, file_priv));
d1529 5
d1535 3
a1537 2
drm_handle_create(struct drm_file *file_priv, struct drm_obj *obj,
    int *handlep)
d1542 1
a1542 1
		return (ENOMEM);
d1556 4
a1559 3
	
	drm_handle_ref(obj);
	return (0);
d1562 3
d1566 1
a1566 1
drm_handle_delete(struct drm_file *file_priv, int handle)
d1568 2
a1569 3
	struct drm_handle	*han, find;
	struct drm_obj		*obj;
	struct drm_device	*dev;
d1572 2
a1573 2
	mtx_enter(&file_priv->table_lock);
	han = SPLAY_FIND(drm_obj_tree, &file_priv->obj_tree, &find);
d1575 2
a1576 2
		mtx_leave(&file_priv->table_lock);
		return (EINVAL);
d1580 2
a1581 2
	SPLAY_REMOVE(drm_obj_tree, &file_priv->obj_tree, han);
	mtx_leave(&file_priv->table_lock);
d1585 1
a1585 4
	dev = obj->dev;
	DRM_LOCK();
	drm_handle_unref(obj);
	DRM_UNLOCK();
d1587 1
a1587 1
	return (0);
d1590 1
d1592 2
a1593 2
drm_gem_object_lookup(struct drm_device *dev, struct drm_file *file_priv,
    int handle)
d1595 4
a1598 2
	struct drm_obj		*obj;
	struct drm_handle	*han, search;
d1600 1
d1602 1
a1602 3

	mtx_enter(&file_priv->table_lock);
	han = SPLAY_FIND(drm_obj_tree, &file_priv->obj_tree, &search);
d1604 2
a1605 2
		mtx_leave(&file_priv->table_lock);
		return (NULL);
d1607 3
d1611 1
a1611 3
	obj = han->obj;
	drm_ref(&obj->uobj);
	mtx_leave(&file_priv->table_lock);
d1613 1
a1613 1
	return (obj);
d1616 3
d1621 1
a1621 1
    struct drm_file *file_priv)
d1623 5
a1627 1
	struct drm_gem_close	*args = data;
d1629 1
a1629 2
	if ((dev->driver->flags & DRIVER_GEM) == 0)
		return (ENODEV);
d1631 1
a1631 1
	return (drm_handle_delete(file_priv, args->handle));
d1668 6
d1676 1
a1676 1
    struct drm_file *file_priv)
d1678 4
a1681 3
	struct drm_gem_open	*args = data;
	struct drm_obj		*obj, search;
	int			 ret, handle;
d1684 1
a1684 1
		return (ENODEV);
d1686 1
a1687 1
	mtx_enter(&dev->obj_name_lock);
d1689 2
a1690 2
	if (obj != NULL)
		drm_ref(&obj->uobj);
d1692 2
a1693 2
	if (obj == NULL)
		return (ENOENT);
d1695 4
a1698 6
	/* this gives our reference to the handle */
	ret = drm_handle_create(file_priv, obj, &handle);
	if (ret) {
		drm_unref(&obj->uobj);
		return (ret);
	}
d1703 1
a1703 1
        return (0);
a1705 6
/*
 * grab a reference for a per-open handle. 
 * The object contains a handlecount too because if all handles disappear we
 * need to also remove the global name (names initially are per open unless the
 * flink ioctl is called.
 */
d1707 1
a1707 1
drm_handle_ref(struct drm_obj *obj)
d1709 1
a1709 3
	/* we are given the reference from the caller, so just
	 * crank handlecount.
	 */
a1712 4
/*
 * Remove the reference owned by a per-open handle. If we're the last one,
 * remove the reference from flink, too.
 */
d1714 1
a1714 1
drm_handle_unref(struct drm_obj *obj)
d1726 1
a1726 1
			drm_unref(&obj->uobj);
d1731 12
a1742 1
	drm_unref(&obj->uobj);
@


1.114
log
@drmclose: don't unref objects with a mutex locked.
Some free functions (radeon) grab sleeping locks. Instead when we ahve
taken the object off the tree we unlock and unref, then regrab before
looking again.

from oga in bitrig, ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.113 2013/08/27 03:18:45 jsg Exp $ */
d1554 29
a1610 2
	struct drm_handle	*han, find;
	struct drm_obj		*obj;
d1615 1
a1615 19
	find.handle = args->handle;
	mtx_enter(&file_priv->table_lock);
	han = SPLAY_FIND(drm_obj_tree, &file_priv->obj_tree, &find);
	if (han == NULL) {
		mtx_leave(&file_priv->table_lock);
		return (EINVAL);
	}

	obj = han->obj;
	SPLAY_REMOVE(drm_obj_tree, &file_priv->obj_tree, han);
	mtx_leave(&file_priv->table_lock);

	drm_free(han);

	DRM_LOCK();
	drm_handle_unref(obj);
	DRM_UNLOCK();

	return (0);
@


1.113
log
@implement drm_pcie_get_speed_cap_mask()

non integrated radeon >= r600 parts will now try to enable PCIe 2.0/3.0
speeds when the PCIe root port advertises the relevant speeds.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.112 2013/08/27 03:06:03 jsg Exp $ */
d581 1
d584 1
@


1.112
log
@stash pci chipset and bridge tags in the drm_device struct
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.111 2013/08/26 05:15:20 jsg Exp $ */
d1833 5
a1837 6
	printf("%s stub\n", __func__);
	return -EINVAL;
#ifdef notyet
	struct pci_dev *root;
	int pos;
	u32 lnkcap = 0, lnkcap2 = 0;
d1840 2
a1841 1
	if (!dev->pdev)
d1843 1
d1845 2
a1846 1
	if (!pci_is_pcie(dev->pdev))
d1849 1
a1849 5
	root = dev->pdev->bus->self;

	pos = pci_pcie_cap(root);
	if (!pos)
		return -EINVAL;
d1852 2
a1853 2
	if (root->vendor == PCI_VENDOR_ID_VIA ||
	    root->vendor == PCI_VENDOR_ID_SERVERWORKS)
d1856 4
a1859 2
	pci_read_config_dword(root, pos + PCI_EXP_LNKCAP, &lnkcap);
	pci_read_config_dword(root, pos + PCI_EXP_LNKCAP2, &lnkcap2);
d1861 1
a1861 1
	lnkcap &= PCI_EXP_LNKCAP_SLS;
d1865 1
a1865 1
		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB)
d1867 1
a1867 1
		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB)
d1869 1
a1869 1
		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)
d1878 2
a1879 1
	DRM_INFO("probing gen 2 caps for device %x:%x = %x/%x\n", root->vendor, root->device, lnkcap, lnkcap2);
a1880 1
#endif
@


1.111
log
@Add a stubbed out version of drm_pcie_get_speed_cap_mask() and
enable all the code in the various radeon pcie_gen2_enable() functions.
no functional change
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.110 2013/08/12 04:11:52 jsg Exp $ */
d121 3
d195 3
@


1.110
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.109 2013/08/07 19:49:04 kettenis Exp $ */
d1823 52
@


1.109
log
@Another major overhaul of the inteldrm(4) GEM code, bringing us considerably
closer to the Linux 3.8.13 codebase.  Almost certainly squashes a few more
bugs.

ok jsg@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.108 2013/06/17 20:55:41 kettenis Exp $ */
d45 1
d60 1
d68 1
d130 1
a130 1
	return (config_found(dev, &arg, drmprint));
d142 12
d258 3
d334 11
d1019 1
d1023 1
d1780 1
a1780 1
	struct drm_device *dev = drm_get_device_from_kdev(kdev);
d1789 3
@


1.108
log
@Include <uvm/uvm.h> instead of <uvm/uvm_extern.h> to make sure
"struct uvm_object" gets defined on macppc as well.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.107 2013/06/11 19:39:09 kettenis Exp $ */
a1674 87
}

/*
 * Helper function to load a uvm anonymous object into a dmamap, to be used
 * for binding to a translation-table style sg mechanism (e.g. agp, or intel
 * gtt).
 *
 * For now we ignore maxsegsz.
 */
int
drm_gem_load_uao(bus_dma_tag_t dmat, bus_dmamap_t map, struct uvm_object *uao,
    bus_size_t size, int flags, bus_dma_segment_t **segp)
{
	bus_dma_segment_t	*segs;
	struct vm_page		*pg;
	struct pglist		 plist;
	u_long			 npages = size >> PAGE_SHIFT, i = 0;
	int			 ret;

	TAILQ_INIT(&plist);

	/*
	 * This is really quite ugly, but nothing else would need
	 * bus_dmamap_load_uao() yet.
	 */
	segs = malloc(npages * sizeof(*segs), M_DRM,
	    M_WAITOK | M_CANFAIL | M_ZERO);
	if (segs == NULL)
		return (ENOMEM);

	/* This may sleep, no choice in the matter */
	if (uvm_objwire(uao, 0, size, &plist) != 0) {
		ret = ENOMEM;
		goto free;
	}

	TAILQ_FOREACH(pg, &plist, pageq) {
		paddr_t pa = VM_PAGE_TO_PHYS(pg);

		if (i > 0 && pa == (segs[i - 1].ds_addr +
		    segs[i - 1].ds_len)) {
			/* contiguous, yay */
			segs[i - 1].ds_len += PAGE_SIZE;
			continue;
		}
		segs[i].ds_addr = pa;
		segs[i].ds_len = PAGE_SIZE;
		if (i++ > npages)
			break;
	}
	/* this should be impossible */
	if (pg != TAILQ_END(&plist)) {
		ret = EINVAL;
		goto unwire;
	}

	if ((ret = bus_dmamap_load_raw(dmat, map, segs, i, size, flags)) != 0)
		goto unwire;

#if defined(__amd64__) || defined(__i386__)
	/*
	 * Create a mapping that wraps around once; the second half
	 * maps to the same set of physical pages as the first half.
	 * Used to implement fast vertical scrolling in inteldrm(4).
	 *
	 * XXX This is an ugly hack that wastes pages and abuses the
	 * internals of the scatter gather DMA code.
	 */
	if (flags & BUS_DMA_GTT_WRAPAROUND) {
		struct sg_page_map *spm = map->_dm_cookie;

		for (i = spm->spm_pagecnt / 2; i < spm->spm_pagecnt; i++)
			spm->spm_map[i].spe_pa =
				spm->spm_map[i - spm->spm_pagecnt / 2].spe_pa;
		agp_bus_dma_rebind(dmat, map, flags);
	}
#endif

	*segp = segs;

	return (0);

unwire:
	uvm_objunwire(uao, 0, size);
free:
	free(segs, M_DRM);
	return (ret);
@


1.107
log
@Turn the allocation of GEM objects upside down and make the driver
responsible for allocating and freeing them.  This is what Linux has been
doing for a while now, and will be needed for radeondrm(4) in the near
future.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.106 2013/06/07 20:46:15 kettenis Exp $ */
d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.106
log
@Add proper mmap(2) support for drm(4)/inteldrm(4).  This changes the
DRM_I915_GEM_MMAP and DRM_I915_GEM_MMAP_GTT ioctls to be compatible with
Linux.  This also is the first step that moves us away from accessing all
graphics memory through the GTT, which should make things faster.

ok tedu@@ (for the uvm bits)
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.105 2013/04/22 08:31:46 mpi Exp $ */
a1376 8

	uao_detach(obj->uao);

	atomic_dec(&dev->obj_count);
	atomic_sub(obj->size, &dev->obj_memory);
	if (obj->do_flags & DRM_WANTED) /* should never happen, not on lists */
		wakeup(obj);
	pool_put(&dev->objpl, obj);
d1456 31
@


1.105
log
@Put the code manipulating scatter gather mapping for the framebuffer under
ifdef to be able to compile DRM on macppc.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.104 2013/04/14 19:04:37 kettenis Exp $ */
d47 1
d1739 114
@


1.104
log
@Take a different approach towards framebuffer accelartion.  Instead of using
the blitter, scroll by double-mapping the framebuffer and reprogramming the
registers that determine the first visible pixel, much in the same way as the
vga text console uses the 6845.  This makes scrolling very fast, and since we
no longer need to issue commands to any of the rings, we can enable this when
X is running and safely scroll when printing panic messages or if we've
entered ddb.

Testes by many.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.103 2013/04/10 01:35:55 guenther Exp $ */
d1689 1
a1689 1
		
d1710 1
d1723 2
a1724 1
			spm->spm_map[i].spe_pa = spm->spm_map[i - spm->spm_pagecnt / 2].spe_pa;
d1727 1
@


1.103
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.102 2013/04/03 19:57:17 kettenis Exp $ */
d1709 16
@


1.102
log
@Return ENOENT instead of EBADF if looking up a gem object fails.
Return EINVAL instead of EBADF if the same object is specified twice in
an execbuffer2 call.
This is what Linux does.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.101 2013/03/22 07:52:36 jsg Exp $ */
d1702 1
a1702 1
	if (pg != TAILQ_END(&pageq)) {
@


1.101
log
@wire up the mode object property ioctls
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.100 2013/03/18 12:36:51 jsg Exp $ */
d1558 1
a1558 1
		return (EBADF);
@


1.100
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.99 2012/12/06 15:05:21 mpi Exp $ */
d782 6
@


1.99
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.98 2012/09/08 16:42:20 mpi Exp $ */
d89 2
d98 1
a98 1
drm_attach_pci(const struct drm_driver_info *driver, struct pci_attach_args *pa,
d102 1
d110 7
d172 4
d183 1
a183 6

	if (dev->driver->vblank_pipes != 0 && drm_vblank_init(dev,
	    dev->driver->vblank_pipes)) {
		printf(": failed to allocate vblank data\n");
		goto error;
	}
d330 2
a331 1
	if (dev->driver->flags & DRIVER_DMA) {
d338 2
a339 1
	dev->irq_enabled = 0;
d359 1
a359 1
	if (dev->irq_enabled)
d363 2
a364 1
	drm_agp_takedown(dev);
d366 2
a367 1
	drm_dma_takedown(dev);
d370 2
a371 1
	if (dev->sg != NULL) {
d433 1
d483 2
a484 1
	int				 i, retcode = 0;
d519 9
a527 10
	for (i = 0; i < dev->vblank->vb_num; i++) {
		struct drmevlist *list = &dev->vblank->vb_crtcs[i].vbl_events;
		for (ev = TAILQ_FIRST(list); ev != TAILQ_END(list);
		    ev = evtmp) {
			evtmp = TAILQ_NEXT(ev, link);
			if (ev->file_priv == file_priv) {
				TAILQ_REMOVE(list, ev, link);
				drm_vblank_put(dev, i);
				ev->destroy(ev);
			}
d536 3
d668 2
d729 54
d855 1
a855 1
	struct drm_pending_event	*ev;
d1023 26
@


1.98
log
@Instead of having yet an other option to compile the drm code without agp
support, wrap all the agp glue with 'if __OS_HAS_AGP' in such form that it
is true if the agp(4) driver is present.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.97 2012/08/30 18:01:36 mpi Exp $ */
d909 3
a913 1
	case _DRM_AGP:
@


1.97
log
@Use only one macro instead of two to turn debug printf on.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.96 2011/07/03 18:34:14 oga Exp $ */
d188 1
d191 1
d351 1
d353 1
d642 1
d645 1
d673 1
d688 1
@


1.96
log
@Rip out and burn support for UVM_HIST.

The vm hackers don't use it, don't maintain it and have to look at it all the
time. About time this 800 lines of code hit /dev/null.

``never liked it'' tedu@@. ariane@@ was very happy when i told her i wrote
this diff.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.95 2011/07/03 15:47:17 matthew Exp $ */
d54 1
a54 1
#ifdef DRM_DEBUG_DEFAULT_ON
a55 2
#else
int drm_debug_flag = 0;
@


1.95
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.94 2011/06/17 07:06:47 mk Exp $ */
a1300 2
	UVMHIST_FUNC("udv_fault"); UVMHIST_CALLED(maphist);
	UVMHIST_LOG(maphist,"  flags=%ld", flags,0,0,0);
a1307 2
		UVMHIST_LOG(maphist, "<- failed -- COW entry (etype=0x%lx)", 
		    entry->etype, 0,0,0);
@


1.94
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_drv.c,v 1.93 2011/06/02 18:22:00 weerd Exp $ */
a259 3
	case DVACT_ACTIVATE:
		break;

@


1.93
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1569 2
a1570 1
	segs = malloc(npages * sizeof(*segs), M_DRM, M_WAITOK | M_ZERO);
@


1.92
log
@Some extra paranoia for if we fail to attach.
@
text
@d1 1
@


1.91
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d222 1
d391 1
a391 1
	if (dev == NULL)
@


1.90
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d182 1
a182 1
	    M_DRM, NULL, NULL, EX_NOWAIT | EX_NOCOALESCE);
@


1.89
log
@correct some bit tests spotted by -Wparentheses in newer gcc.
ok oga@@
@
text
@d866 1
a866 1
			phys = atop(dma->pagelist[offset >> PAGE_SHIFT]);
d907 1
a907 1
		return (atop(offset + map->offset));
@


1.88
log
@Avoid double unlocking the DRM lock in drmclose().  Caught by the
strict locking diff.

ok oga@@
@
text
@d1444 1
a1444 1
	if (!dev->driver->flags & DRIVER_GEM)
d1479 1
a1479 1
	if (!dev->driver->flags & DRIVER_GEM)
@


1.87
log
@Support from vblank events in drm.

Previously, if userland wanted to wait on a certain vertical blank, it
had to call an ioctl which slept. Now, they can ask for an even on the
drm fd, which is then read off, and can be poll(4)ed on. For dri2 this
fits better into the workflow since the fd gets added to the xserver
main loop, and replies to the dri2 clients happen upon recieving the
events.

This functionality is only used with xserver 1.8 (and for the intel
driver in our tree, this support is currently #if 0ed out due to bugs
with vblanks on 945 that are still being chased)

matthieu@@ ok.
@
text
@d541 2
a542 1
	}
a543 2
	DRM_UNLOCK();
	
@


1.86
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@d66 2
d166 1
d418 2
d464 4
a467 3
	struct drm_device *dev = drm_get_device_from_kdev(kdev);
	struct drm_file *file_priv;
	int retcode = 0;
d501 19
d711 112
@


1.85
log
@Right now, if anything internal changes with a uvm object, diverse
places in the tree need to be touched to update the object
initialisation with respect to that.

So, make a function (uvm_initobj) that takes the refcount, object and
pager ops and does this initialisation for us. This should save on
maintainance in the future.

looked good to fgs@@. Tedu complained about the British spelling but OKed
it anyway.
@
text
@a487 2
		if (dev->driver->reclaim_buffers_locked != NULL)
			dev->driver->reclaim_buffers_locked(dev, file_priv);
a490 25
	} else if (dev->driver->reclaim_buffers_locked != NULL &&
	    dev->lock.hw_lock != NULL) {
		mtx_enter(&dev->lock.spinlock);
		/* The lock is required to reclaim buffers */
		for (;;) {
			if (dev->lock.hw_lock == NULL) {
				/* Device has been unregistered */
				retcode = EINTR;
				break;
			}
			if (drm_lock_take(&dev->lock, DRM_KERNEL_CONTEXT)) {
				dev->lock.file_priv = file_priv;
				break;	/* Got lock */
			}
				/* Contention */
			retcode = msleep(&dev->lock,
			    &dev->lock.spinlock, PZERO | PCATCH, "drmlk2", 0);
			if (retcode)
				break;
		}
		mtx_leave(&dev->lock.spinlock);
		if (retcode == 0) {
			dev->driver->reclaim_buffers_locked(dev, file_priv);
			drm_lock_free(&dev->lock, DRM_KERNEL_CONTEXT);
		}
d492 1
a492 3

	if (dev->driver->flags & DRIVER_DMA &&
	    !dev->driver->reclaim_buffers_locked)
@


1.84
log
@The locking rework/fix that I promised when I commited GEM.

Before, as well as being kinda nasty there was a very definite race, if
the last reference to an object  was removed by uvm (a map going away),
then the free path happened unlocked, this could cause all kinds of
havoc.

In order to deal with this, move to fine-grained locking. Since uvm
object locks are spinlocks, and we need to sleep in operations that will
wait on the gpu, provide a DRM_BUSY flag that is set on a locked object
that then allows us to unlock and sleep (this is similar to several
things done in uvm on pages and some object types).

The rwlock stays around to ensure that execbuffer can have acces to the
whole gtt, so ioctls that bind to the gtt need a read lock, and
execuffer gets a write lock. otherwise most ioctls just need to busy the
object that they operate on. Lists also have their own locks.

Some cleanup could be done to make this a little prettier, but it is
much more correct than previously.

Tested very very vigorously on 855 (x40) and 965 (x61s), this found numerous
bugs. Also, the I can no longer crash the kernel at will.

A bunch of asserts hidden under DRMLOCKDEBUG have been left in the code for
debugging purposes.
@
text
@d1236 1
a1236 5
	simple_lock_init(&obj->uobj.vmobjlock);
	obj->uobj.pgops = &drm_pgops;
	RB_INIT(&obj->uobj.memt);
	obj->uobj.uo_npages = 0;
	obj->uobj.uo_refs = 1;
@


1.83
log
@DRM memory management for inteldrm(4) using the Graphics Execution
Manager api.

This is currently disabled by default under ifdef INTELDRM_GEM (option
INTELDRM_GEM in a kernel config or a patch to i915_drv.h needed to
enable), mostly because the intel X driver currently in tree does not
always play well with GEM and needs to be switched to UXA accelmethod
(which is the only option on later drivers).

While based on the intel drm code in the linux kernel this has come cleanups and
some obvious behaviour changes:

1) mmap through the GTT is entirely coherent with the gpu cache, removing
mappings whenever the cache dirties so you can not race with userland to write
to memory at the same time as the gpu.

2) pread/pwrite access is tiling-correct, so userland does not need to tile
manually (mesa has already been fixed for this a while ago). The straw that
broke the camels back here was the bit17 swizzling stuff on some mobile gpus
meansing that while userland did the swizzle itself, the kernel had to do
*extra* swizzling, this was frankly retarded so the option was dropped.

3) there is no option to map via the cpu from userland, again due to
coherency issues.

4) additional integer overflow checking in some areas.

5) we only support the newer EXECBUFFER2 command submission ioctl. the
old one is not supported at all (libdrm was fixed WRT over a week ago).


now the TODOs:

1) the locking is funky and is only correct due to biglock. it does
however work due to that. This will be fixed in tree, the design in
formulating in my head as I type.

2) there are currently no memory limits on drm memory, this needs to be
changed.

3) we really need PAT support for the machines where MTRRs are useless, else drm
uses quite a lot of cpu (this is a bug that continues from the older code
though, nothing new).

4) gpu resetting support on other than 965 is not written yet.

5) currently a lot of the code is in inteldrm, when memory management
comes to other chipset common code will be factored out into the drm
midlayer.

Tested on: 855 (x40), GM965 and 915 by me. 945 by armani@@ and jkmeuser@@,
gm45 by armani@@ and marco@@. More testing is needed before I enable this
by default though.  Others also provided testing by what they tested
escapes me right now.

In order to test this enable INTELDRM_GEM in a kernel and add the following line
to the driver section in xorg.conf (I am working on a patch to autodetect the X
stuff):

Option "AccelMethod" "UXA"
@
text
@a80 2
void	 drm_unref(struct uvm_object *);
void	 drm_ref(struct uvm_object *);
d1033 75
d1112 1
a1112 1
	uobj->uo_refs++;
d1119 7
d1129 3
a1131 2
	simple_lock(&uobj->vmobjlock);
	if (--uobj->uo_refs > 0) {
d1136 18
d1161 2
a1162 1
	simple_unlock(&uobj->vmobjlock);
d1166 11
a1213 5

	uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, uobj, NULL);
	pmap_update(ufi->orig_map->pmap);
	if (ret != VM_PAGER_OK)
		uvm_wait("drm_fault");
d1296 1
a1296 1
	drm_gem_object_reference(obj);
d1357 1
a1357 1
		drm_gem_object_reference(obj);
d1363 1
a1363 3
	DRM_LOCK();
	drm_gem_object_unreference(obj);
	DRM_UNLOCK();
d1383 1
a1383 1
		drm_gem_object_reference(obj);
d1388 1
a1389 4
	/* handle has a reference, drop ours. */
	DRM_LOCK();
	drm_gem_object_unreference(obj);
	DRM_UNLOCK();
d1391 1
a1400 13
void
drm_gem_object_reference(struct drm_obj *obj)
{
	drm_ref(&obj->uobj);
}

void
drm_gem_object_unreference(struct drm_obj *obj)
{
	drm_unref(&obj->uobj);
}


d1410 3
a1413 1
	drm_gem_object_reference(obj);
d1433 1
a1433 1
			drm_gem_object_unreference(obj);
d1438 1
a1438 1
	drm_gem_object_unreference(obj);
@


1.82
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d2 2
d32 2
d42 1
d44 3
d75 15
d206 10
d422 5
d526 12
a539 1
	DRM_LOCK();
d602 2
d650 5
a994 1

d1026 406
@


1.81
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d56 1
a56 1
int	 drm_activate(struct device *, enum devact);
d221 1
a221 1
drm_activate(struct device *self, enum devact act)
@


1.80
log
@mechanical rename of ``priv'' to ``file_priv'' in the one function where
it had to be fucking different. This has been irritating me.
@
text
@a224 1
		return (EOPNOTSUPP);
@


1.79
log
@use BUS_DMA_ZERO instead of alloc + bzero.
@
text
@d353 1
a353 1
	struct drm_file		*priv;
d375 3
a377 3
	priv = drm_calloc(1, max(dev->driver->file_priv_size,
	    sizeof(*priv)));
	if (priv == NULL) {
d382 4
a385 4
	priv->kdev = kdev;
	priv->flags = flags;
	priv->minor = minor(kdev);
	DRM_DEBUG("minor = %d\n", priv->minor);
d388 1
a388 1
	priv->authenticated = DRM_SUSER(p);
d391 1
a391 1
		ret = dev->driver->open(dev, priv);
d405 1
a405 1
	priv->master = SPLAY_EMPTY(&dev->files);
d407 1
a407 1
	SPLAY_INSERT(drm_file_tree, &dev->files, priv);
d413 1
a413 1
	drm_free(priv);
d683 1
a683 1
	struct drm_file		*priv;
d690 1
a690 1
	priv = drm_find_file_by_minor(dev, minor(kdev));
d692 1
a692 1
	if (priv == NULL) {
d697 1
a697 1
	if (!priv->authenticated)
d735 1
a735 1
	if (((map->flags & _DRM_RESTRICTED) && priv->master == 0)) {
@


1.78
log
@detypedef drm_local_map.
@
text
@d874 2
a875 2
	if (bus_dmamem_alloc(dmat, size, alignment, 0,
	    mem->segs, nsegments, &mem->nsegs, BUS_DMA_NOWAIT) != 0)
a884 1
	bzero(mem->kva, size);
@


1.77
log
@detypedef drm_device_dma_t.
@
text
@d277 2
a278 2
	drm_local_map_t *map;
	int i;
d309 1
a309 1
	drm_local_map_t *map, *mapsave;
d664 1
a664 1
drm_local_map_t *
d667 1
a667 1
	drm_local_map_t *map;
d682 1
a682 1
	drm_local_map_t		*map;
@


1.76
log
@detypedef drm_pci_id_list_t.
@
text
@d701 1
a701 1
		drm_device_dma_t *dma = dev->dma;
@


1.75
log
@Sprinkle some const correctness for the pciid lists. From mickey ages
ago.
@
text
@d106 1
a106 1
drm_pciprobe(struct pci_attach_args *pa, const drm_pci_id_list_t *idlist)
d108 1
a108 1
	const drm_pci_id_list_t *id_entry;
d244 2
a245 2
const drm_pci_id_list_t *
drm_find_description(int vendor, int device, const drm_pci_id_list_t *idlist)
@


1.74
log
@Zap a superfluous newline in the drmprint function, it messes up output
if you disable the device.

noticed by deraadt@@.
@
text
@d106 1
a106 1
drm_pciprobe(struct pci_attach_args *pa, drm_pci_id_list_t *idlist)
d108 1
a108 1
	drm_pci_id_list_t *id_entry;
d244 2
a245 2
drm_pci_id_list_t *
drm_find_description(int vendor, int device, drm_pci_id_list_t *idlist)
@


1.73
log
@Remove the lock_time member from the hardware lock. It's not that
useful, and driver shouldn't need to know about ``ticks''.
@
text
@d101 1
a101 1
		printf("drm at %s\n", pnp);
@


1.72
log
@Rework the dma buffer api a bit to make it smaller and to have less
duplicated code. Also, switch the dma_lock to a rwlock (it never should
have been a spinlock) and move it and some other accounting data into
the dma structure, not the main softc.

Finally, the funcitons in drm_dma are tiny, move them in with the rest
of the dma_bufs api in drm_bufs and remove the file.
@
text
@a469 1
				dev->lock.lock_time = jiffies;
d503 1
a503 1
	return retcode;
@


1.71
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@d290 2
a291 3
		i = drm_dma_setup(dev);
		if (i != 0)
			return i;
d620 1
a620 1
			return (drm_addbufs_ioctl(dev, data, file_priv));
d703 1
d705 4
a708 1
		DRM_SPINLOCK(&dev->dma_lock);
d710 1
a710 9
		if (dma->pagelist != NULL) {
			paddr_t phys = dma->pagelist[offset >> PAGE_SHIFT];

			DRM_SPINUNLOCK(&dev->dma_lock);
			return (atop(phys));
		} else {
			DRM_SPINUNLOCK(&dev->dma_lock);
			return (-1);
		}
@


1.70
log
@Rework how we deal with the list of per-open datastructures, and the
auth list.  now we only need the one tree. Makes things a little neater,
and smaller.
@
text
@d846 1
a846 1
		dev->if_version = DRM_MAX(if_version, dev->if_version);
@


1.69
log
@The drm_* allocation functions have been #defined to not use most of
their arguments for a while. Actually go through the code and remove the
extraneous arguments. Makes things easier to read.
@
text
@d60 1
d62 4
d145 1
a145 1
	TAILQ_INIT(&dev->files);
d257 8
d268 1
a268 3
	struct drm_file *priv;

	DRM_SPINLOCK_ASSERT(&dev->dev_lock);
d270 2
a271 4
	TAILQ_FOREACH(priv, &dev->files, link)
		if (priv->minor == minor)
			break;
        return (priv);
a295 1
	SPLAY_INIT(&dev->magiclist);
a309 1
	struct drm_magic_entry *pt;
a323 6
	/* Clear pid list */
	while ((pt = SPLAY_ROOT(&dev->magiclist)) != NULL) {
		SPLAY_REMOVE(drm_magic_tree, &dev->magiclist, pt);
		drm_free(pt);
	}

d336 1
a336 1
		if (!(map->flags & _DRM_DRIVER))
a350 26
drm_version(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_version	*version = data;
	int			 len;

#define DRM_COPY(name, value)						\
	len = strlen( value );						\
	if ( len > name##_len ) len = name##_len;			\
	name##_len = strlen( value );					\
	if ( len && name ) {						\
		if ( DRM_COPY_TO_USER( name, value, len ) )		\
			return EFAULT;				\
	}

	version->version_major = dev->driver->major;
	version->version_minor = dev->driver->minor;
	version->version_patchlevel = dev->driver->patchlevel;

	DRM_COPY(version->name, dev->driver->name);
	DRM_COPY(version->date, dev->driver->date);
	DRM_COPY(version->desc, dev->driver->desc);

	return 0;
}

int
d400 1
a400 1
	if (TAILQ_EMPTY(&dev->files) && !DRM_SUSER(p)) {
d406 1
a406 1
	priv->master = TAILQ_EMPTY(&dev->files);
d408 1
a408 1
	TAILQ_INSERT_TAIL(&dev->files, priv, link);
d494 1
a494 1
	TAILQ_REMOVE(&dev->files, file_priv, link);
d795 26
d918 60
@


1.68
log
@convert drm_scatter code over to using the new dmamem api.

removes the custom code in there, so shrinks the kernel by a few bytes.
Convert other code to deal with data structure changes.
@
text
@d208 1
a208 1
		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
d320 1
a320 1
		drm_free(pt, sizeof(*pt), DRM_MEM_MAGIC);
d402 1
a402 1
	    sizeof(*priv)), DRM_MEM_FILES);
d439 1
a439 2
	drm_free(priv, max(dev->driver->file_priv_size,
	    sizeof(*priv)), DRM_MEM_FILES);
d520 1
a520 2
	drm_free(file_priv, max(dev->driver->file_priv_size, 
	    sizeof(*file_priv)), DRM_MEM_FILES);
@


1.67
log
@Convert CONSISTENT maps over to dmamem api.
@
text
@d324 1
a324 1
		drm_sg_mem_t *sg = dev->sg; 
d328 1
a328 1
		drm_sg_cleanup(sg);
d784 2
a785 2
		return (bus_dmamem_mmap(dev->dmat, dev->sg->mem->sg_segs,
		    dev->sg->mem->sg_nsegs, map->offset - dev->sg->handle +
@


1.66
log
@introduce drm_dmamem_alloc() to allocate dma memory with bus_dma.

The next few commits will convert calls to drm_pci_alloc (which I hate)
over to this new api, and convert other handrolled stuff over too.

First part of my cleaning up bus_dma useage in drm.
@
text
@d789 2
a790 2
		return (bus_dmamem_mmap(dev->dmat, &map->dmah->seg, 1,
		    offset, prot, BUS_DMA_NOWAIT));
@


1.65
log
@fix potential null dereferences.

Found by LLVM/Clang Static Analyzer.

ok oga@@
@
text
@d859 61
@


1.64
log
@Similar to my last commit, it's stupid to have a file with two very
small functions in it. Move them to main driver file.
@
text
@d455 3
d714 3
@


1.63
log
@Move drmmmap to the main driver file.  It's stupid to have a file with
one (not particlarly large) function in it.
@
text
@d59 3
d790 62
@


1.62
log
@drm_getmap and interface can die too.
@
text
@d2 1
d699 88
@


1.61
log
@Rip out the drm_drawable support. There is no need for the xserver to
push cliprects into the kernel anymore so no op the ioctls. The only
consumer of this information died a couple of months ago.

When i've got removal of these calls from userland upstream i'm going to
remove them from the interface entirely.
@
text
@a571 2
	case DRM_IOCTL_GET_MAP:
		return (drm_getmap(dev, data, file_priv));
d578 2
d581 1
a581 1
		/*FALLTHROUGH*/
@


1.60
log
@Make the various drm drivers print the interrupt they're using.

ok oga@@
@
text
@a132 1
	mtx_init(&dev->drw_lock, IPL_NONE);
a309 1
	drm_drawable_free_all(dev);
a639 4
		case DRM_IOCTL_ADD_DRAW:
			return (drm_adddraw(dev, data, file_priv));
		case DRM_IOCTL_RM_DRAW:
			return (drm_rmdraw(dev, data, file_priv));
d662 2
d665 6
a670 1
			return (drm_update_draw(dev, data, file_priv));
@


1.59
log
@Make sure we do not DRM_UNLOCK() twice.

ok oga@@
@
text
@d79 1
a79 1
		printf(": no memory for drm\n");
a84 1
	printf("\n");
@


1.58
log
@don't free extent on lastclose, it's static data now.
@
text
@a457 1
	DRM_UNLOCK();
d463 1
@


1.57
log
@do the same for struct drm_file (file_priv) as previously done for
dma_bufs; allow the driver to provide the size and not have the private
data pointer.  only radeon only needs this so far, but intel with GEM
also needs it.

Postclose was only used for freeing said private data, so this allows me
to remove the postclose callback and rename preclose to close.
@
text
@a315 6
	if (dev->unique != NULL) {
		drm_free(dev->unique, dev->unique_len + 1,  DRM_MEM_DRIVER);
		dev->unique = NULL;
		dev->unique_len = 0;
	}

@


1.56
log
@actually set the bus_space_tag
@
text
@d405 3
a407 2

	priv = drm_calloc(1, sizeof(*priv), DRM_MEM_FILES);
d444 2
a445 1
	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
d464 2
a465 2
	if (!file_priv) {
		DRM_UNLOCK();
a469 1
	DRM_UNLOCK();
d471 2
a472 2
	if (dev->driver->preclose != NULL)
		dev->driver->preclose(dev, file_priv);
a520 3
	if (dev->driver->postclose != NULL)
		dev->driver->postclose(dev, file_priv);

d523 2
a524 1
	drm_free(file_priv, sizeof(*file_priv), DRM_MEM_FILES);
@


1.55
log
@change drm_attach_mi to drm_attach_pci. we take the pci_attach_args, and
setup the drm_attach_args with the needed information.

require interface version 1.1 libdrm has been requesting it for ages),
which means that we can set the busid string at attach time. (generated in
drm_attach_pci), also pass in the interrupt line and bst.

Now we don't need dev->pa at all, so remove it, finally.
@
text
@d58 6
d128 1
@


1.54
log
@make device works out if it's agp and tells the drm driver, not the
other way round. More dev->pa reduction
@
text
@d59 2
a60 2
drm_attach_mi(const struct drm_driver_info *driver, bus_dma_tag_t dmat,
    struct pci_attach_args *pa, int is_agp, struct device *dev)
d65 3
a67 2
	arg.pa = pa;
	arg.dmat = dmat;
d70 9
a116 1
	struct pci_attach_args	*pa = da->pa;
a120 3
	/* needed for pci_mapreg_* */
	memcpy(&dev->pa, pa, sizeof(dev->pa));

d122 3
a124 5
	dev->irq = pa->pa_intrline;
	dev->pci_domain = 0;
	dev->pci_bus = pa->pa_bus;
	dev->pci_slot = pa->pa_device;
	dev->pci_func = pa->pa_function;
a634 2
		case DRM_IOCTL_SET_UNIQUE:
			return (drm_setunique(dev, data, file_priv));
d671 7
@


1.53
log
@instead of functions that just return an error, just inline them into
the ioctl handler.
@
text
@d60 1
a60 1
    struct pci_attach_args *pa, struct device *dev)
d67 1
d147 1
a147 1
		if (drm_device_is_agp(dev))
@


1.52
log
@pass in the dmat when we attach the drm driver. reduces pci dependancy.
@
text
@a571 4
	case DRM_IOCTL_GET_CLIENT:
		return (drm_getclient(dev, data, file_priv));
	case DRM_IOCTL_GET_STATS:
		return (drm_getstats(dev, data, file_priv));
d577 5
@


1.51
log
@#define away unused arguments for the drm_alloc functions. to save some
size.

kill (empty) drm_mem_{un,}init() while here.
@
text
@d59 2
a60 2
drm_attach_mi(const struct drm_driver_info *driver, struct pci_attach_args *pa,
    struct device *dev)
d66 1
d114 1
@


1.50
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@a123 2

	drm_mem_init();
a195 1
	drm_mem_uninit();
@


1.49
log
@Make all drm drivers map their mmio register space on attach instead of
using the drm_maps interface (this was done for inteldrm a few days
ago).  All drivers now ignore the mmio_offset argument that the init
ioctl takes.

This clears up the code and makes sure that drm_ioremap_core() doesn't
need the vga_pci_map inteface anymore, so we don't have to pass in the
vga softc anymore. We also get to kill the drm_resource_{start,length}
linux-alike functions since we just calculate all the requisite offsets
at startup and cache those we need. This now means that technically the
only driver that needs the vga_pci_map api is inteldrm (due to sharing
with intagp issues), though this diff doesn't convert them over.
@
text
@d128 6
d176 2
d182 2
a191 1
	drm_lastclose(dev);
@


1.48
log
@drm_device_is_pcie is only needed in one place: radeondrm_attach

so just inline it there.

also remove dev->pci_vendor and dev->pci_device, and insert pci_device
into the one place any of them are needed (inteldrm's interface can give
this info to the X driver. to remove that you'd need to fix X too).
@
text
@d60 1
a60 1
    struct device *vga, struct device *dev)
a65 1
	arg.vga = (struct vga_pci_softc *)vga;
a108 1
	dev->vga_softc = da->vga;
@


1.47
log
@Move the drm drivers over from:

vga1 at pci0
inteldrm0 at vga1

to

vga1 at pci0
inteldrm0 at vga1
drm0 at inteldrm0

i.e. a similar scheme to audio(4) where the interface attaches on top of
the wildly different drivers. This helps to clean up the code a lot
(more is coming) and help me start to move drm to being essentially bus
independent, which will help in the future.
@
text
@a119 2
	dev->pci_vendor = PCI_VENDOR(dev->pa.pa_id);
	dev->pci_device = PCI_PRODUCT(dev->pa.pa_id);
@


1.46
log
@Remove the driver->load callback and just do all the initialization in
the attach function. First step towards splitting drm off as it's own
(bus independant) device, as it should be.
@
text
@d52 11
d64 3
d68 3
a70 1
struct drm_device *drm_units[DRM_MAXUNITS];
d72 7
a78 1
static int init_units = 1;
d81 1
a81 1
drm_probe(struct pci_attach_args *pa, drm_pci_id_list_t *idlist)
a82 1
	int unit;
a84 7
	/* first make sure there is place for the device */
	for (unit=0; unit<DRM_MAXUNITS; unit++)
		if (drm_units[unit] == NULL)
			break;
	if (unit == DRM_MAXUNITS)
		return 0;

d93 2
a94 3
void
drm_attach(struct device *parent, struct device *kdev,
    struct pci_attach_args *pa)
d96 1
a96 2
	int unit;
	struct drm_device *dev;
d98 2
a99 5
	if (init_units) {
		for (unit=0; unit<DRM_MAXUNITS; unit++)
			drm_units[unit] = NULL;
		init_units = 0;
	}
d101 10
a110 9

        for (unit=0; unit<DRM_MAXUNITS; unit++)
		if (drm_units[unit] == NULL)
			break;
	if (unit == DRM_MAXUNITS)
		return;

	dev = drm_units[unit] = (struct drm_device*)kdev;
	dev->unit = unit;
a113 1
	dev->vga_softc = (struct vga_pci_softc *)parent;
d211 9
@


1.45
log
@Remove dev->id_entry, it is no longer needed.
@
text
@a49 2
drm_pci_id_list_t *drm_find_description(int , int ,
	    drm_pci_id_list_t *);
d81 1
a81 1
    struct pci_attach_args *pa, drm_pci_id_list_t *idlist)
a84 1
	drm_pci_id_list_t *id_entry;
a117 3
	id_entry = drm_find_description(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id), idlist);

a133 8
	if (dev->driver->load != NULL) {
		int retcode;

		retcode = dev->driver->load(dev, id_entry->driver_private);
		if (retcode != 0)
			goto error;
	}

a182 3

	if (dev->driver->unload != NULL)
		dev->driver->unload(dev);
@


1.44
log
@drm advertises a read and poll method. this was there to prevent errrors
on rather old xservers. Said old xservers haven't been around in quite a
long time so just remove them.

Since the only function left in drm_fops.c is a small helper function,
just move it to drm_drv.c and nuke the redundant file.

no one objected when I said I was going to do this.
@
text
@a122 1
	dev->id_entry = id_entry;
d143 1
a143 1
		retcode = dev->driver->load(dev, dev->id_entry->driver_private);
@


1.43
log
@Instead of using a width-1 bitfield for storing the driver capabilities
in the callback structure, just use a bunch of ORed together bits. This
has been annoying me for ages.
@
text
@d27 1
d232 13
@


1.42
log
@rework how we handle ioctls.

Before it was based on a static array with flags. Instead, let the
driver provide an ioctl callback, which deals with things appropriately.
Makes the code a bit easier to read, and also drops just over 5k on an
amd64 kernel build with all drm drivers enabled.

Tested by a few.
@
text
@d148 1
a148 1
	if (dev->driver->use_agp) {
d151 3
a153 2
		if (dev->driver->require_agp && dev->agp == NULL) {
			printf(":couldn't find agp\n");
d248 1
a248 1
	if (dev->driver->use_dma) {
d484 2
a485 1
	if (dev->driver->use_dma && !dev->driver->reclaim_buffers_locked)
@


1.41
log
@Remove the drm_locked_tasklet interface. The only consumer that used it
was the i915 vblank swap ioctl, which just went kaput.
@
text
@a53 88
static drm_ioctl_desc_t		  drm_ioctls[256] = {
	DRM_IOCTL_DEF(DRM_IOCTL_VERSION, drm_version, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_UNIQUE, drm_getunique, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_MAGIC, drm_getmagic, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_IRQ_BUSID, drm_irq_by_busid,
	    DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_MAP, drm_getmap, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CLIENT, drm_getclient, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_STATS, drm_getstats, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_SET_VERSION, drm_setversion,
	    DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_SET_UNIQUE, drm_setunique,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_BLOCK, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_UNBLOCK, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AUTH_MAGIC, drm_authmagic,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_ADD_MAP, drm_addmap_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_MAP, drm_rmmap_ioctl, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_SAREA_CTX, drm_noop, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_ADD_CTX, drm_addctx,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_CTX, drm_rmctx,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_CTX, drm_getctx, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_noop,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RES_CTX, drm_resctx, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_ADD_DRAW, drm_adddraw,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_DRAW, drm_rmdraw,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_LOCK, drm_lock, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_UNLOCK, drm_unlock, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_FINISH, drm_noop, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_ADD_BUFS, drm_addbufs_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_MARK_BUFS, drm_noop, DRM_AUTH|DRM_MASTER),
	DRM_IOCTL_DEF(DRM_IOCTL_INFO_BUFS, drm_noop, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_MAP_BUFS, drm_mapbufs, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_FREE_BUFS, drm_freebufs, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_DMA, drm_dma, DRM_AUTH),

	DRM_IOCTL_DEF(DRM_IOCTL_CONTROL, drm_control,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ACQUIRE, drm_agp_acquire_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_RELEASE, drm_agp_release_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ENABLE, drm_agp_enable_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_INFO, drm_agp_info_ioctl, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ALLOC, drm_agp_alloc_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_FREE, drm_agp_free_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_BIND, drm_agp_bind_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_UNBIND, drm_agp_unbind_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_SG_ALLOC, drm_sg_alloc_ioctl,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_SG_FREE, drm_sg_free,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_WAIT_VBLANK, drm_wait_vblank, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_MODESET_CTL, drm_modeset_ctl, 0),
	DRM_IOCTL_DEF(DRM_IOCTL_UPDATE_DRAW, drm_update_draw,
	    DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
};
a512 5
	int retcode = 0;
	drm_ioctl_desc_t *ioctl;
	int (*func)(struct drm_device *, void *, struct drm_file *);
	int nr = DRM_IOCTL_NR(cmd);
	int is_driver_ioctl = 0;
d529 1
a529 1
	    DRM_CURRENTPID, cmd, nr, (long)&dev->device,
d544 16
a559 1
	}
d561 39
a599 3
	if (IOCGROUP(cmd) != DRM_IOCTL_BASE) {
		DRM_DEBUG("Bad ioctl group 0x%x\n", (int)IOCGROUP(cmd));
		return EINVAL;
d602 45
a646 9
	ioctl = &drm_ioctls[nr];
	/* It's not a core DRM ioctl, try driver-specific. */
	if (ioctl->func == NULL && nr >= DRM_COMMAND_BASE) {
		/* The array entries begin at DRM_COMMAND_BASE ioctl nr */
		nr -= DRM_COMMAND_BASE;
		if (nr > dev->driver->max_ioctl) {
			DRM_DEBUG("Bad driver ioctl number, 0x%x (of 0x%x)\n",
			    nr, dev->driver->max_ioctl);
			return EINVAL;
a647 2
		ioctl = &dev->driver->ioctls[nr];
		is_driver_ioctl = 1;
d649 4
a652 20
	func = ioctl->func;

	if (func == NULL) {
		DRM_DEBUG("no function\n");
		return EINVAL;
	}

	/* 
	 * master must be root, and all ioctls that are ROOT_ONLY are
	 * also DRM_MASTER.
	 */
	if (((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||
	    ((ioctl->flags & DRM_MASTER) && !file_priv->master))
		return EACCES;

	retcode = func(dev, data, file_priv);
	if (retcode != 0)
		DRM_DEBUG("    returning %d\n", retcode);

	return retcode;
@


1.40
log
@The drawable spinlock is no longer ever held in interrupt context (and
won't be). It doesn't need to block interrupts anymore so switch to
IPL_NONE.
@
text
@a205 1
	mtx_init(&dev->tsk_lock, IPL_BIO);
@


1.39
log
@Don't print redundant information in dmesg.

Prompted by deraadt, kettenis@@.
@
text
@d205 1
a205 1
	mtx_init(&dev->drw_lock, IPL_BIO);
@


1.38
log
@Fix various printf constructs either missing arguments or format specifiers.
@
text
@a211 1
	printf(" %s(%d)", id_entry->name, dev->unit);
d255 1
a255 3
	printf(", %d.%d.%d %s\n", dev->driver->major, dev->driver->minor,
	    dev->driver->patchlevel, dev->driver->date);

@


1.37
log
@Kill the linux-ready negative return codes in ``shared'' code. We handle
them wrong in several cases that i've noticed and Merging when needed is
still fairly simple, anyway. This shaves another 500 bytes from an amd64
kernel due to not having to flip the sign on some things. It also stops
my eyes bleeding.

Tested by a few along with the last diff that went in.
@
text
@d476 1
a476 1
	DRM_DEBUG("minor = %d\n", DRM_CURRENTPID, priv->minor);
@


1.36
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@d233 1
a233 3
		/* Shared code returns -errno. */
		retcode = -dev->driver->load(dev,
		    dev->id_entry->driver_private);
d482 1
a482 2
		/* shared code returns -errno */
		ret = -dev->driver->open(dev, priv);
d676 1
a676 7
	if (is_driver_ioctl) {
		/* shared code returns -errno */
		retcode = -func(dev, data, file_priv);
	} else {
		retcode = func(dev, data, file_priv);
	}

@


1.35
log
@Rework the drm locking to be at least halfway sane. The freebsd code
held a lock over all driver ioctls in order to be ``mpsafe''. Stop lying
to ourselves for a start. This code is not fully mpsafe, and should not
pretend to be so.  Put the locking around where it should, and rely on
biglock for the rest. This will need to be fixed, but avoids some of the
horrible that we have right now.

Tested by many over a long time and several iterations.
@
text
@a211 1
	dev->driver.id_entry = id_entry;
d230 1
a230 1
	if (dev->driver.load != NULL) {
d234 1
a234 1
		retcode = -dev->driver.load(dev,
d240 1
a240 1
	if (dev->driver.use_agp) {
d243 1
a243 1
		if (dev->driver.require_agp && dev->agp == NULL) {
d258 2
a259 2
	printf(", %d.%d.%d %s\n", dev->driver.major, dev->driver.minor,
	    dev->driver.patchlevel, dev->driver.date);
d291 2
a292 2
	if (dev->driver.unload != NULL)
		dev->driver.unload(dev);
d338 2
a339 2
	if (dev->driver.firstopen)
		dev->driver.firstopen(dev);
d341 1
a341 1
	if (dev->driver.use_dma) {
d368 2
a369 2
	if (dev->driver.lastclose != NULL)
		dev->driver.lastclose(dev);
d432 7
a438 7
	version->version_major = dev->driver.major;
	version->version_minor = dev->driver.minor;
	version->version_patchlevel = dev->driver.patchlevel;

	DRM_COPY(version->name, dev->driver.name);
	DRM_COPY(version->date, dev->driver.date);
	DRM_COPY(version->desc, dev->driver.desc);
d483 1
a483 1
	if (dev->driver.open) {
d485 1
a485 1
		ret = -dev->driver.open(dev, priv);
d534 2
a535 2
	if (dev->driver.preclose != NULL)
		dev->driver.preclose(dev, file_priv);
d545 2
a546 2
		if (dev->driver.reclaim_buffers_locked != NULL)
			dev->driver.reclaim_buffers_locked(dev, file_priv);
d550 1
a550 1
	} else if (dev->driver.reclaim_buffers_locked != NULL &&
d573 1
a573 1
			dev->driver.reclaim_buffers_locked(dev, file_priv);
d578 1
a578 1
	if (dev->driver.use_dma && !dev->driver.reclaim_buffers_locked)
d583 2
a584 2
	if (dev->driver.postclose != NULL)
		dev->driver.postclose(dev, file_priv);
d656 1
a656 1
		if (nr > dev->driver.max_ioctl) {
d658 1
a658 1
			    nr, dev->driver.max_ioctl);
d661 1
a661 1
		ioctl = &dev->driver.ioctls[nr];
@


1.34
log
@Kill some stupid agp api wrapper functions, just use the agp api
directly.  While i'm here, factor out some common functionality into a
separate function, and kill some typedefs (man this code is full of
them...). Shaves another 450 bytes off the kernel.

Tested by ckuethe and Paul de Weerd, thanks.
@
text
@d204 1
a204 1
	DRM_SPININIT(&dev->dev_lock, "drm device");
d207 1
a233 1
		DRM_LOCK();
a236 1
		DRM_UNLOCK();
a264 1
	DRM_LOCK();
a265 2
	DRM_UNLOCK();
	DRM_SPINUNINIT(&dev->dev_lock);
a284 1
	DRM_LOCK();
a285 1
	DRM_UNLOCK();
a295 1
	DRM_SPINUNINIT(&dev->dev_lock);
a332 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

a341 2
	dev->buf_use = 0;

a350 1
	dev->lock.lock_queue = 0;
a366 2
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);

d375 5
a391 6
	DRM_UNLOCK();
	drm_agp_takedown(dev);
	drm_drawable_free_all(dev);
	drm_dma_takedown(dev);
	DRM_LOCK();

d405 1
a405 1
			drm_rmmap(dev, map);
d411 1
a411 1
		DRM_WAKEUP_INT((void *)&dev->lock.lock_queue);
d413 1
d447 3
a449 2
	struct drm_device *dev = NULL;
	int retcode = 0;
d457 34
a490 1
	retcode = drm_open_helper(kdev, flags, fmt, p, dev);
d492 3
a494 4
	if (retcode == 0) {
		DRM_LOCK();
		if (dev->open_count++ == 0)
			retcode = drm_firstopen(dev);
d496 2
d500 14
a513 1
	return retcode;
a525 1

d533 1
a537 4
	/* ========================================================
	 * Begin inline drm_release
	 */

d553 1
d567 2
a568 2
			retcode = msleep((void *)&dev->lock.lock_queue,
			    &dev->dev_lock, PZERO | PCATCH, "drmlk2", 0);
d572 1
d586 2
a590 4
	/* ========================================================
	 * End inline drm_release
	 */

d593 1
a680 1
		DRM_LOCK();
a682 1
		DRM_UNLOCK();
d698 1
a698 1
	DRM_SPINLOCK_ASSERT(&dev->dev_lock);
d701 1
a701 1
			return map;
d703 2
a704 2

	return NULL;
@


1.33
log
@Kill some unneeded defines and struct members.
@
text
@a394 1
	drm_drawable_free_all(dev);
d401 5
a405 15
				/* Clear AGP information */
	if (dev->agp != NULL) {
		struct drm_agp_mem *entry;

		/*
		 * Remove AGP resources, but leave dev->agp intact until
		 * we detach the device
		 */
		while ((entry = TAILQ_FIRST(&dev->agp->memory)) != NULL) {
			if (entry->bound)
				drm_agp_unbind_memory(entry->handle);
			drm_agp_free_memory(entry->handle);
			TAILQ_REMOVE(&dev->agp->memory, entry, link);
			drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
		}
a406 6
		if (dev->agp->acquired)
			drm_agp_release(dev);

		dev->agp->acquired = 0;
		dev->agp->enabled  = 0;
	}
d408 1
a408 1
		drm_sg_cleanup(dev->sg);
d410 4
a422 1
	drm_dma_takedown(dev);
@


1.32
log
@Kill the stats data structures and noop some other parts. Nothing in
userland asks for these stats, and we stopped recording anything
interesting a while back.
@
text
@d473 1
a473 1
drmopen(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d497 1
a497 1
drmclose(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d550 1
a550 1
			retcode = DRM_SLEEPLOCK((void *)&dev->lock.lock_queue,
d588 2
a589 2
drmioctl(DRM_CDEV kdev, u_long cmd, caddr_t data, int flags, 
    DRM_STRUCTPROC *p)
@


1.31
log
@detypedef some more. No functional change.
@
text
@a358 11
	dev->counters = 6;
	dev->types[0] = _DRM_STAT_LOCK;
	dev->types[1] = _DRM_STAT_OPENS;
	dev->types[2] = _DRM_STAT_CLOSES;
	dev->types[3] = _DRM_STAT_IOCTLS;
	dev->types[4] = _DRM_STAT_LOCKS;
	dev->types[5] = _DRM_STAT_UNLOCKS;

	for (i = 0; i < DRM_ARRAY_SIZE(dev->counts); i++)
		atomic_set(&dev->counts[i], 0);

a486 1
		atomic_inc(&dev->counts[_DRM_STAT_OPENS]);
a546 1
                                atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
a575 1
	atomic_inc(&dev->counts[_DRM_STAT_CLOSES]);
a609 1
	atomic_inc(&dev->counts[_DRM_STAT_IOCTLS]);
@


1.30
log
@replace usage of drm_memrange with extent(9). No functional change, but
should shrink the kernel somewhat. For some strange reason I was unaware
of this api when I pulled in these changes.

tested by myself and Paul de Weerd, thanks!
@
text
@d460 2
a461 2
	drm_version_t *version = data;
	int len;
@


1.29
log
@Kill the infobufs and markbufs calls. Nothing uses them.
@
text
@d223 4
a226 2
	if (drm_memrange_init(&dev->handle_mm, 1024*1024*1024, LONG_MAX) != 0) {
		printf(": failed to initialise handle memrange\n");
d279 1
a279 1
	drm_memrange_takedown(&dev->handle_mm);
@


1.28
log
@drm_load() and drm_unload() are a remnant of code meant to be shared
between the bsds. Just put them in attach/detach instead. Kills a little
bit of dead code, too.
@
text
@d107 2
a108 2
	DRM_IOCTL_DEF(DRM_IOCTL_MARK_BUFS, drm_markbufs, DRM_AUTH|DRM_MASTER),
	DRM_IOCTL_DEF(DRM_IOCTL_INFO_BUFS, drm_infobufs, DRM_AUTH),
@


1.27
log
@Kill some redundant ifdefs, they're taken care of elsewhere.
@
text
@a48 2
int	 drm_load(struct drm_device *);
void	 drm_unload(struct drm_device *);
d197 1
d201 3
d212 48
d261 7
a267 2
	printf(": %s(%d)", id_entry->name, dev->unit);
	drm_load(dev);
d273 28
a300 1
	drm_unload((struct drm_device *)self);
d415 3
a417 2
		/* Remove AGP resources, but leave dev->agp intact until
		 * drm_unload is called.
a453 110

int
drm_load(struct drm_device *dev)
{
	int retcode;

	DRM_DEBUG("\n");

	dev->irq = dev->pa.pa_intrline;
	dev->pci_domain = 0;
	dev->pci_bus = dev->pa.pa_bus;
	dev->pci_slot = dev->pa.pa_device;
	dev->pci_func = dev->pa.pa_function;

	dev->pci_vendor = PCI_VENDOR(dev->pa.pa_id);
	dev->pci_device = PCI_PRODUCT(dev->pa.pa_id);

	TAILQ_INIT(&dev->maplist);

	drm_mem_init();
	TAILQ_INIT(&dev->files);

	/*
	 * the dma buffers api is just weird. offset 1Gb to ensure we don't
	 * conflict with it.
	 */
	retcode = drm_memrange_init(&dev->handle_mm, 1024*1024*1024, LONG_MAX);
	if (retcode != 0) {
		DRM_ERROR("Failed to initialise handle memrange\n");
		goto error;
	}

	if (dev->driver.load != NULL) {
		DRM_LOCK();
		/* Shared code returns -errno. */
		retcode = -dev->driver.load(dev,
		    dev->id_entry->driver_private);
		DRM_UNLOCK();
		if (retcode != 0)
			goto error;
	}

	if (dev->driver.use_agp) {
		if (drm_device_is_agp(dev))
			dev->agp = drm_agp_init();
		if (dev->driver.require_agp && dev->agp == NULL) {
			DRM_ERROR("Card isn't AGP, or couldn't initialize "
			    "AGP.\n");
			retcode = ENOMEM;
			goto error;
		}
		if (dev->agp != NULL) {
			if (drm_mtrr_add(dev->agp->info.ai_aperture_base,
			    dev->agp->info.ai_aperture_size, DRM_MTRR_WC) == 0)
				dev->agp->mtrr = 1;
		}
	}

	retcode = drm_ctxbitmap_init(dev);
	if (retcode != 0) {
		DRM_ERROR("Cannot allocate memory for context bitmap.\n");
		goto error;
	}
	printf(", %d.%d.%d %s\n", dev->driver.major, dev->driver.minor,
	    dev->driver.patchlevel, dev->driver.date);

	return 0;

error:
	DRM_LOCK();
	drm_lastclose(dev);
	DRM_UNLOCK();
	DRM_SPINUNINIT(&dev->dev_lock);
	return retcode;
}

void
drm_unload(struct drm_device *dev)
{

	DRM_DEBUG("\n");

	drm_ctxbitmap_cleanup(dev);

	drm_memrange_takedown(&dev->handle_mm);

	if (dev->agp && dev->agp->mtrr) {
		int retcode;

		retcode = drm_mtrr_del(0, dev->agp->info.ai_aperture_base,
		    dev->agp->info.ai_aperture_size, DRM_MTRR_WC);
		DRM_DEBUG("mtrr_del = %d", retcode);
	}

	DRM_LOCK();
	drm_lastclose(dev);
	DRM_UNLOCK();

	if (dev->agp != NULL) {
		drm_free(dev->agp, sizeof(*dev->agp), DRM_MEM_AGPLISTS);
		dev->agp = NULL;
	}

	if (dev->driver.unload != NULL)
		dev->driver.unload(dev);

	drm_mem_uninit();
	DRM_SPINUNINIT(&dev->dev_lock);
}

@


1.26
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@a421 1
#ifndef DRM_NO_MTRR
a426 1
#endif
a456 1
#if !defined(DRM_NO_MTRR) && !defined(DRM_NO_AGP)
a463 1
#endif
@


1.25
log
@Kill file_priv->refs, it is always 1. Also  move two things from the
softc into file_priv since otherwise the wrong value could rarely be
used.
@
text
@d37 2
a41 1
#include <sys/ttycom.h> /* for TIOCSGRP */
d60 2
a61 1
	DRM_IOCTL_DEF(DRM_IOCTL_IRQ_BUSID, drm_irq_by_busid, DRM_MASTER|DRM_ROOT_ONLY),
d65 2
a66 1
	DRM_IOCTL_DEF(DRM_IOCTL_SET_VERSION, drm_setversion, DRM_MASTER|DRM_ROOT_ONLY),
d68 8
a75 4
	DRM_IOCTL_DEF(DRM_IOCTL_SET_UNIQUE, drm_setunique, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_BLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_UNBLOCK, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AUTH_MAGIC, drm_authmagic, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d77 2
a78 1
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_MAP, drm_addmap_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d81 2
a82 1
	DRM_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d85 6
a90 3
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_CTX, drm_addctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_CTX, drm_rmctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d92 4
a95 2
	DRM_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_noop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d98 4
a101 2
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_DRAW, drm_adddraw, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_RM_DRAW, drm_rmdraw, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d107 2
a108 1
	DRM_IOCTL_DEF(DRM_IOCTL_ADD_BUFS, drm_addbufs_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d115 2
a116 1
	DRM_IOCTL_DEF(DRM_IOCTL_CONTROL, drm_control, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d118 6
a123 3
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ACQUIRE, drm_agp_acquire_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_RELEASE, drm_agp_release_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ENABLE, drm_agp_enable_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d125 13
a137 7
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_ALLOC, drm_agp_alloc_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_FREE, drm_agp_free_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_BIND, drm_agp_bind_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_AGP_UNBIND, drm_agp_unbind_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),

	DRM_IOCTL_DEF(DRM_IOCTL_SG_ALLOC, drm_sg_alloc_ioctl, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_SG_FREE, drm_sg_free, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d141 2
a142 1
	DRM_IOCTL_DEF(DRM_IOCTL_UPDATE_DRAW, drm_update_draw, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d156 5
a160 3
	for(unit=0; unit<DRM_MAXUNITS; unit++)
		if(drm_units[unit] == NULL) break;
	if(unit == DRM_MAXUNITS) return 0;
d164 1
a164 1
	if (id_entry != NULL) {
a165 1
	}
d178 2
a179 2
	if(init_units) {
		for(unit=0; unit<DRM_MAXUNITS;unit++)
d185 5
a189 3
        for(unit=0; unit<DRM_MAXUNITS; unit++)
		if(drm_units[unit] == NULL) break;
	if(unit == DRM_MAXUNITS) return;
d244 1
a244 1
		    (idlist[i].device == device)) {
a245 1
		}
d283 2
a284 2
	for ( i = 0 ; i < DRM_ARRAY_SIZE(dev->counts) ; i++ )
		atomic_set( &dev->counts[i], 0 );
d295 1
a295 1
	DRM_DEBUG( "\n" );
d308 1
a308 1
	DRM_DEBUG( "\n" );
d316 1
a316 1
	if ( dev->unique ) {
d323 1
a323 1
				/* Clear pid list */
d330 1
a330 1
	if ( dev->agp ) {
d337 1
a337 1
			if ( entry->bound )
d363 1
a363 1
	if ( dev->lock.hw_lock ) {
d377 1
a377 1
	DRM_DEBUG( "\n" );
d436 2
a437 5
	printf(", %d.%d.%d %s\n",
	    dev->driver.major,
	    dev->driver.minor,
	    dev->driver.patchlevel,
	    dev->driver.date);
d453 1
a453 1
	DRM_DEBUG( "\n" );
d473 1
a473 1
	if ( dev->agp ) {
d492 1
a492 1
#define DRM_COPY( name, value )						\
d501 3
a503 3
	version->version_major		= dev->driver.major;
	version->version_minor		= dev->driver.minor;
	version->version_patchlevel	= dev->driver.patchlevel;
d522 1
a522 1
	DRM_DEBUG( "open_count = %d\n", dev->open_count );
d526 2
a527 2
	if ( !retcode ) {
		atomic_inc( &dev->counts[_DRM_STAT_OPENS] );
d529 1
a529 1
		if ( !dev->open_count++ )
d544 1
a544 1
	DRM_DEBUG( "open_count = %d\n", dev->open_count );
d563 1
a563 1
	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
a575 5
		
				/* FIXME: may require heavy-handed reset of
                                   hardware at this point, possibly
                                   processed via a callback to the X
                                   server. */
d580 1
a580 1
			if ( !dev->lock.hw_lock ) {
d588 1
a588 1
                                atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
d618 1
a618 1
	atomic_inc( &dev->counts[_DRM_STAT_CLOSES] );
d653 1
a653 1
	atomic_inc( &dev->counts[_DRM_STAT_IOCTLS] );
d656 1
a656 1
	DRM_DEBUG( "pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
d658 1
a658 1
	    file_priv->authenticated );
d695 1
a695 1
		DRM_DEBUG( "no function\n" );
@


1.24
log
@Change the drm_lock*() api to take a pointer to the struct as a
parameter, this makes things a little cleaner and removes the need to
pass in the softc for some functions.
@
text
@a494 2
	dev->kdev = kdev; /* hack for now */

a527 3

	if (--file_priv->refs != 0)
		goto done;
@


1.23
log
@idgen32 wasn't really right here. Change back to how it was, but
done a little nicer.

Advice from deraadt@@.
@
text
@d552 1
a552 1
		drm_lock_free(dev, &dev->lock.hw_lock->lock,
d568 1
a568 2
			if (drm_lock_take(&dev->lock.hw_lock->lock,
			    DRM_KERNEL_CONTEXT)) {
d582 1
a582 2
			drm_lock_free(dev, &dev->lock.hw_lock->lock,
			    DRM_KERNEL_CONTEXT);
@


1.22
log
@Generate the magic id using idgen32(). While i'm here fix the locking a
bit so we don't sleep with a spinlock.

ok djm@@.
@
text
@d256 1
a256 1
	idgen32_init(&dev->magicid);
@


1.21
log
@Kill a bunch of the drm context code that nothing uses anymore, the
xserver only actually uses a small part of it nowadays.

Kill a few other dead bits from the drmP.h while i'm here.
@
text
@d256 1
@


1.20
log
@Make the drm attach messages a lot prettier.

the DRM_{INFO,ERROR,DEBUG} printf macros still need some __VA_ARGS__ love.

reyk@@ and marco@@ liked this, prompted by deraadt.
@
text
@d73 2
a74 2
	DRM_IOCTL_DEF(DRM_IOCTL_SET_SAREA_CTX, drm_setsareactx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_GET_SAREA_CTX, drm_getsareactx, DRM_AUTH),
d78 1
a78 1
	DRM_IOCTL_DEF(DRM_IOCTL_MOD_CTX, drm_modctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
d80 2
a81 2
	DRM_IOCTL_DEF(DRM_IOCTL_SWITCH_CTX, drm_switchctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_IOCTL_NEW_CTX, drm_newctx, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
a259 2
	dev->context_flag = 0;
	dev->last_context = 0;
@


1.19
log
@Switch all instances of malloc/free in the DRM to drm_alloc, drm_free
and drm_calloc.

With the recent change to check overflow in drm_calloc, this means that
all allocations that require multiplication are now checked. Also use
drm_calloc() when zeroing is needed and drop the bzero/memset
afterwards.  Finally, make drm_free() check for NULL, so we don't need
to do so every time.

ok miod@@, deraadt@@
@
text
@d180 1
a180 2
	printf("\n");
	DRM_INFO("%s (unit %d)\n", id_entry->name, dev->unit);
d407 1
a407 2
	DRM_INFO("Initialized %s %d.%d.%d %s\n",
	    dev->driver.name,
@


1.18
log
@The current drm_locked_task*() code sometimes tries to sleep in an
interrupt handler.

This is bad and wrong. So change it so that if we can't immediately grab
the hardware lock, to just leave the task flagged so that we can run it
when we release the lock. The linux implementation uses a similar
scheme.

Tested by guenther@@, landry@@ and bernd@@. Also tested by many a while
ago as part of a larger diff.
@
text
@d289 1
a289 1
		free(dev->unique, M_DRM);
d298 1
a298 1
		free(pt, M_DRM);
d313 1
a313 1
			free(entry, M_DRM);
d450 1
a450 1
		free(dev->agp, M_DRM);
d599 1
a599 1
	free(file_priv, M_DRM);
@


1.17
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d172 2
a173 1
	DRM_SPININIT(&dev->drw_lock, "drm drawable lock");
@


1.16
log
@Since we're not ifdefed anymore, change
drm_{open,close,poll,read,mmap,ioctl} into the form that cdev_decl()
likes, and nuke the #defines.
@
text
@d48 2
a49 2
int	 drm_load(drm_device_t *);
void	 drm_unload(drm_device_t *);
d52 2
a53 2
int	 drm_firstopen(drm_device_t *);
int	 drm_lastclose(drm_device_t *);
d117 1
a117 1
drm_device_t *drm_units[DRM_MAXUNITS];
d146 1
a146 1
	drm_device_t *dev;
d160 1
a160 1
	dev = drm_units[unit] = (drm_device_t*)kdev;
d187 1
a187 1
	drm_unload((drm_device_t *)self);
d221 1
a221 1
drm_firstopen(drm_device_t *dev)
d272 1
a272 1
drm_lastclose(drm_device_t *dev)
d344 1
a344 1
drm_load(drm_device_t *dev)
d425 1
a425 1
drm_unload(drm_device_t *dev)
d462 1
a462 1
drm_version(drm_device_t *dev, void *data, struct drm_file *file_priv)
d490 1
a490 1
	drm_device_t *dev = NULL;
d517 2
a518 2
	drm_device_t *dev = drm_get_device_from_kdev(kdev);
	drm_file_t *file_priv;
d621 1
a621 1
	drm_device_t *dev = drm_get_device_from_kdev(kdev);
d624 1
a624 1
	int (*func)(drm_device_t *dev, void *data, struct drm_file *file_priv);
d627 1
a627 1
	drm_file_t *file_priv;
d710 1
a710 1
drm_getsarea(drm_device_t *dev)
@


1.15
log
@Kill drm_sysctl.c and all references to it.

All the code was ifdefed out anyway and it wasn't really useful.
@
text
@d488 1
a488 1
drm_open(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d515 1
a515 1
drm_close(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d615 1
a615 1
/* drm_ioctl is called whenever a process performs an ioctl on /dev/drm.
d618 1
a618 1
drm_ioctl(DRM_CDEV kdev, u_long cmd, caddr_t data, int flags, 
@


1.14
log
@Kill the rest of the ifdef maze in drm_*.c

I was going to do this per file, but decided all it would achieve was
artificially increasing my commit count.

>Kill the ifdef maze. I've been considering doing this for months, it
>doesn't make getting changes to and  from upstream much easier, and just
>makes the code hard to read.
@
text
@a416 1
	drm_sysctl_cleanup(dev);
@


1.13
log
@The mmap offsets for memory buffers currently are the kernel virtual
address.  This is just plain wrong. scatter/gather on amd64 didn't work
here, since char device mmap doesn't take negative offsets so higher
kvas fail.

Instead, prematurely import drm_memrange which is needed for the memory
managers (GEM or TTM), and is used to manage GART space. Then, horribly
abuse it to allocate mmap offsets, fixes up the issues.

"just commit it" art@@.
@
text
@a39 1
#ifdef __OpenBSD__
a40 1
#endif
a54 9
#ifdef __FreeBSD__
MODULE_VERSION(drm, 1);
MODULE_DEPEND(drm, agp, 1, 1, 1);
MODULE_DEPEND(drm, pci, 1, 1, 1);
#if __FreeBSD_version > 502127
MODULE_DEPEND(drm, mem, 1, 1, 1);
#endif
#endif /* __FreeBSD__ */

a116 118
#ifdef __FreeBSD__
static struct cdevsw drm_cdevsw = {
#if __FreeBSD_version >= 502103
	.d_version =	D_VERSION,
#endif
	.d_open =	drm_open,
	.d_close =	drm_close,
	.d_read =	drm_read,
	.d_ioctl =	drm_ioctl,
	.d_poll =	drm_poll,
	.d_mmap =	drm_mmap,
	.d_name =	"drm",
#if __FreeBSD_version >= 502103
	.d_flags =	D_TRACKCLOSE | D_NEEDGIANT,
#else
	.d_maj =	145,
	.d_flags =	D_TRACKCLOSE,
#endif
#if __FreeBSD_version < 500000
	.d_bmaj =	-1
#endif
};

int
drm_probe(device_t dev, drm_pci_id_list_t *idlist)
{
	drm_pci_id_list_t *id_entry;
	int vendor, device;
#if __FreeBSD_version < 700010
	device_t realdev;

	if (!strcmp(device_get_name(dev), "drmsub"))
		realdev = device_get_parent(dev);
	else
		realdev = dev;
	vendor = pci_get_vendor(realdev);
	device = pci_get_device(realdev);
#else
	vendor = pci_get_vendor(dev);
	device = pci_get_device(dev);
#endif

	id_entry = drm_find_description(vendor, device, idlist);
	if (id_entry != NULL) {
		device_set_desc(dev, id_entry->name);
		return 0;
	}

	return ENXIO;
}

int
drm_attach(device_t nbdev, drm_pci_id_list_t *idlist)
{
	drm_device_t *dev;
	drm_pci_id_list_t *id_entry;
	int unit;

	unit = device_get_unit(nbdev);
	dev = device_get_softc(nbdev);

#if __FreeBSD_version < 700010
	if (!strcmp(device_get_name(nbdev), "drmsub"))
		dev->device = device_get_parent(nbdev);
	else
		dev->device = nbdev;
#else
	dev->device = nbdev;
#endif
	dev->devnode = make_dev(&drm_cdevsw,
			unit,
			DRM_DEV_UID,
			DRM_DEV_GID,
			DRM_DEV_MODE,
			"dri/card%d", unit);
#if __FreeBSD_version >= 500000
	mtx_init(&dev->dev_lock, "drm device", NULL, MTX_DEF);
	mtx_init(&dev->drw_lock, "drmdrw", NULL, MTX_DEF);
#endif

	id_entry = drm_find_description(pci_get_vendor(dev->device),
	    pci_get_device(dev->device), idlist);
	dev->id_entry = id_entry;

	return drm_load(dev);
}

int
drm_detach(device_t dev)
{
	drm_unload(device_get_softc(dev));
	return 0;
}

#ifndef DRM_DEV_NAME
#define DRM_DEV_NAME "drm"
#endif

devclass_t drm_devclass;

#elif defined(__NetBSD__) || defined(__OpenBSD__)

#if defined(__NetBSD__)
static struct cdevsw drm_cdevsw = {
	drm_open,
	drm_close,
	drm_read,
	nowrite,
	drm_ioctl,
	nostop,
	notty,
	drm_poll,
	drm_mmap,
	nokqfilter,
	D_TTY
};
#endif

a204 1
#endif /* __NetBSD__ || __OpenBSD__ */
a263 3
#ifdef __FreeBSD__
	dev->buf_sigio = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a264 1
#endif
a325 3
#ifdef __FreeBSD__
	TAILQ_FOREACH_SAFE(map, &dev->maplist, link, mapsave) {
#else
a328 1
#endif
a349 14
#ifdef __FreeBSD__
	dev->irq = pci_get_irq(dev->device);
#if defined(__FreeBSD__) && __FreeBSD_version >= 700053
	dev->pci_domain = pci_get_domain(dev->device);
#else
	dev->pci_domain = 0;
#endif
	dev->pci_bus = pci_get_bus(dev->device);
	dev->pci_slot = pci_get_slot(dev->device);
	dev->pci_func = pci_get_function(dev->device);

	dev->pci_vendor = pci_get_vendor(dev->device);
	dev->pci_device = pci_get_device(dev->device);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a357 1
#endif
a361 3
#ifdef __FreeBSD__
	drm_sysctl_init(dev);
#endif
a406 7
#ifdef __FreeBSD__
	dev->drw_unrhdr = new_unrhdr(1, INT_MAX, NULL);
	if (dev->drw_unrhdr == NULL) {
		DRM_ERROR("Couldn't allocate drawable number allocator\n");
		goto error;
	}
#endif
a420 3
#ifdef __FreeBSD__
	destroy_dev(dev->devnode);
#endif
a427 7
#ifdef __FreeBSD__
	int i;


	drm_sysctl_cleanup(dev);
	destroy_dev(dev->devnode);
#endif
a448 15
	/* Clean up PCI resources allocated by drm_bufs.c.  We're not really
	 * worried about resource consumption while the DRM is inactive (between
	 * lastclose and firstopen or unload) because these aren't actually
	 * taking up KVA, just keeping the PCI resource allocated.
	 */
#ifdef __FreeBSD__
	for (i = 0; i < DRM_MAX_PCI_RESOURCE; i++) {
		if (dev->pcir[i] == NULL)
			continue;
		bus_release_resource(dev->device, SYS_RES_MEMORY,
		    dev->pcirid[i], dev->pcir[i]);
		dev->pcir[i] = NULL;
	}
#endif

a456 5
#ifdef __FreeBSD__
	delete_unrhdr(dev->drw_unrhdr);

#endif

a497 1
#ifdef __OpenBSD__
a498 1
#endif
a506 3
#ifdef __FreeBSD__
		device_busy(dev->device);
#endif
a525 1
#ifdef __OpenBSD__
a526 3
#else
	file_priv = drm_find_file_by_proc(dev, p);
#endif
a543 4
#ifdef __FreeBSD__
	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
	    DRM_CURRENTPID, (long)dev->device, dev->open_count );
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a545 1
#endif
a593 5
#if defined (__FreeBSD__) && (__FreeBSD_version >= 500000)
	funsetown(&dev->buf_sigio);
#elif defined(__FreeBSD__)
	funsetown(dev->buf_sigio);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a594 1
#endif /* __NetBSD__  || __OpenBSD__ */
a606 3
#ifdef __FreeBSD__
	device_unbusy(dev->device);
#endif
a633 1
#ifdef __OpenBSD__
a634 3
#else
	file_priv = drm_find_file_by_proc(dev, p);
#endif
a643 5
#ifdef __FreeBSD__
	DRM_DEBUG( "pid=%d, cmd=0x%02lx, nr=0x%02x, dev 0x%lx, auth=%d\n",
	    DRM_CURRENTPID, cmd, nr, (long)dev->device,
	    file_priv->authenticated );
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a646 1
#endif
a652 23
#ifdef __FreeBSD__
	case FIOSETOWN:
		return fsetown(*(int *)data, &dev->buf_sigio);

	case FIOGETOWN:
#if (__FreeBSD_version >= 500000)
		*(int *) data = fgetown(&dev->buf_sigio);
#else
		*(int *) data = fgetown(dev->buf_sigio);
#endif
		return 0;
#endif /* __FreeBSD__ */
#if defined(__NetBSD__)
	case SIOCSPGRP:
	case TIOCSPGRP:
	case FIOSETOWN:
		return fsetown(p->l_proc, &dev->buf_pgid, cmd, data);

	case SIOCGPGRP:
	case TIOCGPGRP:
	case FIOGETOWN:
		return fgetown(p->l_proc, dev->buf_pgid, cmd, data);
#elif defined(__OpenBSD__)
a659 1
#endif /* __NetBSD__ */
a686 1
#ifdef __OpenBSD__
a692 5
#else
	if (((ioctl->flags & DRM_ROOT_ONLY) && !DRM_SUSER(p)) ||
	    ((ioctl->flags & DRM_AUTH) && !file_priv->authenticated) ||
	    ((ioctl->flags & DRM_MASTER) && !file_priv->master))
#endif
a722 40

#if DRM_LINUX

#include <sys/sysproto.h>

MODULE_DEPEND(DRIVER_NAME, linux, 1, 1, 1);

#define LINUX_IOCTL_DRM_MIN		0x6400
#define LINUX_IOCTL_DRM_MAX		0x64ff

static linux_ioctl_function_t drm_linux_ioctl;
static struct linux_ioctl_handler drm_handler = {drm_linux_ioctl, 
    LINUX_IOCTL_DRM_MIN, LINUX_IOCTL_DRM_MAX};

SYSINIT(drm_register, SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_register_handler, &drm_handler);
SYSUNINIT(drm_unregister, SI_SUB_KLD, SI_ORDER_MIDDLE, 
    linux_ioctl_unregister_handler, &drm_handler);

/* The bits for in/out are switched on Linux */
#define LINUX_IOC_IN	IOC_OUT
#define LINUX_IOC_OUT	IOC_IN

static int
drm_linux_ioctl(DRM_STRUCTPROC *p, struct linux_ioctl_args* args)
{
	int error;
	int cmd = args->cmd;

	args->cmd &= ~(LINUX_IOC_IN | LINUX_IOC_OUT);
	if (cmd & LINUX_IOC_IN)
		args->cmd |= IOC_IN;
	if (cmd & LINUX_IOC_OUT)
		args->cmd |= IOC_OUT;
	
	error = ioctl(p, (struct ioctl_args *)args);

	return error;
}
#endif /* DRM_LINUX */
@


1.12
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d520 10
d605 2
@


1.11
log
@Oops! Add the #endif that vanished here.

Pointed out by landry@@.
@
text
@d124 1
d409 1
a409 4
	drm_local_map_t *map;
#ifdef __FreeBSD__
	drm_local_map_t *mapsave;
#endif
d463 3
a465 1
	while ((map = TAILQ_FIRST(&dev->maplist)) != NULL) {
d467 2
a468 1
		drm_rmmap(dev, map);
@


1.10
log
@Make *drm(4) use D_CLONE so that the per-open data actually works. Since
i'm modifying this code anyway, prepare for privsep by making it so that
"master" openers must be root, and remove some spurious suser() checks.
For example, every DRM_ROOT_ONLY ioctl is also DRM_MASTER. Without this
change, privsep wouldn't work since the fd is no longer root owned.

With this, X privsep should work as soon as the userland bits are done
(currently unwritten).

Looked over by kettenis@@, ok thib@@.
@
text
@d622 1
@


1.9
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d583 1
a585 1
	DRM_DEBUG( "\n" );
a586 1
#ifdef __FreeBSD__
d591 2
a621 15
#elif defined(__NetBSD__) || defined(__OpenBSD__)
	for (i = 0; i < DRM_MAX_PCI_RESOURCE; i++) {
		if (dev->pcir[i] == NULL)
			continue;
		if (dev->pcir[i]->mapped)
		{
			bus_space_unmap(dev->pa.pa_memt,
			    dev->pcir[i]->bsh,
			    dev->pcir[i]->size);
			dev->pcir[i]->mapped = 0;
		}
		free(dev->pcir[i], M_DRM);
		dev->pcir[i] = NULL;
	}
#endif
d710 3
d714 1
d836 3
d840 1
d923 8
d934 1
@


1.8
log
@Replace handrolled hashes with a splay tree, while there plug a memleak
inherited from the original drm driver.

input and ok oga@@.
@
text
@d270 2
a271 2
drm_attach(struct device *kdev, struct pci_attach_args *pa,
    drm_pci_id_list_t *idlist)
d291 1
d293 1
@


1.7
log
@bring back a free call which was left out when moving from handrolled lists
to tailqs. this plugs a tiny memleak.
``nice catch'' and ok oga@@
@
text
@d383 1
a383 3
	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
		TAILQ_INIT(&dev->magiclist[i]);
	}
a409 1
	int i;
d429 3
a431 5
	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
		while ((pt = TAILQ_FIRST(&dev->magiclist[i])) != NULL) {
			TAILQ_REMOVE(&dev->magiclist[i], pt, link);
			free(pt, M_DRM);
		}
@


1.6
log
@Make sure that the drawables are properly freed when removed, and upon
last close of the device nuke them all. Inspired by similar code in
the linux drm driver.

Tested by many.
@
text
@d435 1
@


1.5
log
@Switch part of the magic hashtable over to using a TAILQ instead
of a hand-rolled list. Ideally this code needs more changes, but for
now that'll do.

Tested by many.
@
text
@d429 2
@


1.4
log
@check the softc for null before we use it. Fixes a crash when drm is enabled
but no device attached when the X server tries to use it.

Tested by many.
@
text
@d384 1
a384 2
		dev->magiclist[i].head = NULL;
		dev->magiclist[i].tail = NULL;
d407 1
a407 1
	drm_magic_entry_t *pt, *next;
d431 2
a432 3
		for ( pt = dev->magiclist[i].head ; pt ; pt = next ) {
			next = pt->next;
			free(pt, M_DRM);
a433 1
		dev->magiclist[i].head = dev->magiclist[i].tail = NULL;
@


1.3
log
@Convert the list of agp memory over to a TAILQ instead of using a hand-
rolled list.

Tested by many
@
text
@a57 3
#define DRIVER_SOFTC(unit) \
	((drm_device_t *)devclass_get_softc(drm_devclass, unit))

a65 5
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define DRIVER_SOFTC(unit) \
	((drm_device_t *)device_lookup(&drm_cd, unit))
#endif /* __NetBSD__ || __OpenBSD__ */

d691 3
d844 3
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d449 1
a449 2
		drm_agp_mem_t *entry;
		drm_agp_mem_t *nexte;
d454 1
a454 2
		for ( entry = dev->agp->memory ; entry ; entry = nexte ) {
			nexte = entry->next;
d458 1
a460 1
		dev->agp->memory = NULL;
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d50 6
a55 4
static int drm_load(drm_device_t *dev);
static void drm_unload(drm_device_t *dev);
static drm_pci_id_list_t *drm_find_description(int vendor, int device,
    drm_pci_id_list_t *idlist);
d158 2
a159 1
int drm_probe(device_t dev, drm_pci_id_list_t *idlist)
d186 2
a187 1
int drm_attach(device_t nbdev, drm_pci_id_list_t *idlist)
d222 2
a223 1
int drm_detach(device_t dev)
a250 57
#if __NetBSD_Version__ >= 106080000
MOD_DEV("drm", DRIVER_NAME, NULL, -1, &drm_cdevsw, CDEV_MAJOR);
#else
MOD_DEV("drm", LM_DT_CHAR, CDEV_MAJOR, &drm_cdevsw);
#endif

int drm_lkmentry(struct lkm_table *lkmtp, int cmd, int ver);
static int drm_lkmhandle(struct lkm_table *lkmtp, int cmd);

int drm_modprobe(void);
void drm_attach(struct device *, struct pci_attach_args *,
                drm_pci_id_list_t *);

int drm_lkmentry(struct lkm_table *lkmtp, int cmd, int ver) {
	DISPATCH(lkmtp, cmd, ver, drm_lkmhandle, drm_lkmhandle, drm_lkmhandle);
}

static int drm_lkmhandle(struct lkm_table *lkmtp, int cmd)
{
	int error = 0;

	switch(cmd) {
	case LKM_E_LOAD:
		if (lkmexists(lkmtp))
			return EEXIST;

		if(drm_modprobe())
			return 0;

		return 1;

	case LKM_E_UNLOAD:
		if (drm_refcnt > 0)
			return (EBUSY);
		break;
	case LKM_E_STAT:
		break;

	default:
		error = EIO;
		break;
	}
	
	return error;
}

int drm_modprobe(void)
{
	struct pci_attach_args pa;
	int error;

	error = pci_find_device(&pa, drm_probe, idlist);
	if (error != 0)
		drm_attach(&pa, 0);

	return error;
}
d257 2
a258 1
int drm_probe(struct pci_attach_args *pa, drm_pci_id_list_t *idlist)
d277 3
a279 2
void drm_attach(struct device *kdev, struct pci_attach_args *pa,
                drm_pci_id_list_t *idlist)
a293 1
		/* This should not happen, since drm_probe made sure there was room */
d318 2
a319 1
int drm_detach(struct device *self, int flags)
d325 2
a326 1
int drm_activate(struct device *self, enum devact act)
d341 2
a342 2
drm_pci_id_list_t *drm_find_description(int vendor, int device,
    drm_pci_id_list_t *idlist)
d355 2
a356 1
static int drm_firstopen(drm_device_t *dev)
d365 1
a365 1
		       _DRM_CONTAINS_LOCK, &map);
d380 7
a386 7
	dev->counters  = 6;
	dev->types[0]  = _DRM_STAT_LOCK;
	dev->types[1]  = _DRM_STAT_OPENS;
	dev->types[2]  = _DRM_STAT_CLOSES;
	dev->types[3]  = _DRM_STAT_IOCTLS;
	dev->types[4]  = _DRM_STAT_LOCKS;
	dev->types[5]  = _DRM_STAT_UNLOCKS;
d413 2
a414 1
static int drm_lastclose(drm_device_t *dev)
d493 2
a494 1
static int drm_load(drm_device_t *dev)
d573 5
a577 5
	  	dev->driver.name,
	  	dev->driver.major,
	  	dev->driver.minor,
	  	dev->driver.patchlevel,
	  	dev->driver.date);
d593 2
a594 1
static void drm_unload(drm_device_t *dev)
d641 2
a642 2
					dev->pcir[i]->bsh,
					dev->pcir[i]->size);
d668 2
a669 1
int drm_version(drm_device_t *dev, void *data, struct drm_file *file_priv)
d694 2
a695 1
int drm_open(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d723 2
a724 1
int drm_close(DRM_CDEV kdev, int flags, int fmt, DRM_STRUCTPROC *p)
d754 1
a754 1
		   DRM_CURRENTPID, (long)dev->device, dev->open_count );
d757 1
a757 1
		   DRM_CURRENTPID, (long)&dev->device, dev->open_count);
d763 2
a764 2
			  DRM_CURRENTPID,
			  _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
d840 2
a841 1
int drm_ioctl(DRM_CDEV kdev, u_long cmd, caddr_t data, int flags, 
d956 2
a957 1
drm_local_map_t *drm_getsarea(drm_device_t *dev)
@

