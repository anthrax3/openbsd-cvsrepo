head	1.24;
access;
symbols
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.23;
commitid	GnoPKa34InShCqYl;

1.23
date	2016.04.08.08.27.53;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	mS4ttEBzpAfn3sVx;

1.22
date	2016.04.07.20.33.24;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	b7TUPgWhn5cou224;

1.21
date	2016.04.06.21.12.40;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	QO3FDEetxShNl6Ad;

1.20
date	2016.04.06.14.39.19;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	3RYGzl8Nwjgc2QjX;

1.19
date	2015.09.27.11.09.26;	author jsg;	state Exp;
branches;
next	1.18;
commitid	OkoKp05dU7tP7DK3;

1.18
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	lQlppvmETCN49oZe;

1.17
date	2015.05.05.02.01.10;	author jsg;	state Exp;
branches;
next	1.16;
commitid	IzDhD51qtTqJ1S80;

1.16
date	2015.04.06.09.23.19;	author jsg;	state Exp;
branches;
next	1.15;
commitid	99nej6bpjNHMCLwr;

1.15
date	2015.04.06.08.14.00;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	3FenpHSGCnS2uSz0;

1.14
date	2015.04.05.13.04.41;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	QduPwqvNJHSeaWl5;

1.13
date	2015.04.05.11.53.53;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	3YXcRggXXMDC9Cpg;

1.12
date	2015.02.12.02.12.02;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	cYXtgYH6nnLqDRGU;

1.11
date	2015.02.11.07.01.36;	author jsg;	state Exp;
branches;
next	1.10;
commitid	dLgISW35NAmGN8Xl;

1.10
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.9;
commitid	aHLMSW1RfE1rmMw9;

1.9
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.8;
commitid	C5l5rZ5v9mpRR1eS;

1.8
date	2014.03.09.11.07.18;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.02.13.12.33.08;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.18.08.25.06;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.12.16.19.57.08;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.12.15.22.09.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.02.10.18.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.02.06.25.27;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@/*	$OpenBSD: drm_crtc.c,v 1.23 2016/04/08 08:27:53 kettenis Exp $	*/
/*
 * Copyright (c) 2006-2008 Intel Corporation
 * Copyright (c) 2007 Dave Airlie <airlied@@linux.ie>
 * Copyright (c) 2008 Red Hat Inc.
 *
 * DRM core CRTC related functions
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Authors:
 *      Keith Packard
 *	Eric Anholt <eric@@anholt.net>
 *      Dave Airlie <airlied@@linux.ie>
 *      Jesse Barnes <jesse.barnes@@intel.com>
 */
#include "drmP.h"
#include "drm_crtc.h"
#include "drm_edid.h"
#include "drm_fourcc.h"

/**
 * drm_modeset_lock_all - take all modeset locks
 * @@dev: drm device
 *
 * This function takes all modeset locks, suitable where a more fine-grained
 * scheme isn't (yet) implemented.
 */
void drm_modeset_lock_all(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	mutex_lock(&dev->mode_config.mutex);

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		mutex_lock_nest_lock(&crtc->mutex, &dev->mode_config.mutex);
}
EXPORT_SYMBOL(drm_modeset_lock_all);

/**
 * drm_modeset_unlock_all - drop all modeset locks
 * @@dev: device
 */
void drm_modeset_unlock_all(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		mutex_unlock(&crtc->mutex);

	mutex_unlock(&dev->mode_config.mutex);
}
EXPORT_SYMBOL(drm_modeset_unlock_all);

/**
 * drm_warn_on_modeset_not_all_locked - check that all modeset locks are locked
 * @@dev: device
 */
void drm_warn_on_modeset_not_all_locked(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	/* Locking is currently fubar in the panic handler. */
	if (oops_in_progress)
		return;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		WARN_ON(!mutex_is_locked(&crtc->mutex));

	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
}
EXPORT_SYMBOL(drm_warn_on_modeset_not_all_locked);

/* Avoid boilerplate.  I'm tired of typing. */
#define DRM_ENUM_NAME_FN(fnname, list)				\
	const char *fnname(int val)				\
	{							\
		int i;						\
		for (i = 0; i < ARRAY_SIZE(list); i++) {	\
			if (list[i].type == val)		\
				return list[i].name;		\
		}						\
		return "(unknown)";				\
	}

/*
 * Global properties
 */
static const struct drm_prop_enum_list drm_dpms_enum_list[] =
{	{ DRM_MODE_DPMS_ON, "On" },
	{ DRM_MODE_DPMS_STANDBY, "Standby" },
	{ DRM_MODE_DPMS_SUSPEND, "Suspend" },
	{ DRM_MODE_DPMS_OFF, "Off" }
};

DRM_ENUM_NAME_FN(drm_get_dpms_name, drm_dpms_enum_list)

/*
 * Optional properties
 */
static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] =
{
	{ DRM_MODE_SCALE_NONE, "None" },
	{ DRM_MODE_SCALE_FULLSCREEN, "Full" },
	{ DRM_MODE_SCALE_CENTER, "Center" },
	{ DRM_MODE_SCALE_ASPECT, "Full aspect" },
};

/*
 * Non-global properties, but "required" for certain connectors.
 */
static const struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =
{
	{ DRM_MODE_SUBCONNECTOR_Automatic, "Automatic" }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_DVID,      "DVI-D"     }, /* DVI-I  */
	{ DRM_MODE_SUBCONNECTOR_DVIA,      "DVI-A"     }, /* DVI-I  */
};

DRM_ENUM_NAME_FN(drm_get_dvi_i_select_name, drm_dvi_i_select_enum_list)

static const struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =
{
	{ DRM_MODE_SUBCONNECTOR_Unknown,   "Unknown"   }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_DVID,      "DVI-D"     }, /* DVI-I  */
	{ DRM_MODE_SUBCONNECTOR_DVIA,      "DVI-A"     }, /* DVI-I  */
};

DRM_ENUM_NAME_FN(drm_get_dvi_i_subconnector_name,
		 drm_dvi_i_subconnector_enum_list)

static const struct drm_prop_enum_list drm_tv_select_enum_list[] =
{
	{ DRM_MODE_SUBCONNECTOR_Automatic, "Automatic" }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_Composite, "Composite" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SVIDEO,    "SVIDEO"    }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_Component, "Component" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SCART,     "SCART"     }, /* TV-out */
};

DRM_ENUM_NAME_FN(drm_get_tv_select_name, drm_tv_select_enum_list)

static const struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =
{
	{ DRM_MODE_SUBCONNECTOR_Unknown,   "Unknown"   }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_Composite, "Composite" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SVIDEO,    "SVIDEO"    }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_Component, "Component" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SCART,     "SCART"     }, /* TV-out */
};

DRM_ENUM_NAME_FN(drm_get_tv_subconnector_name,
		 drm_tv_subconnector_enum_list)

static const struct drm_prop_enum_list drm_dirty_info_enum_list[] = {
	{ DRM_MODE_DIRTY_OFF,      "Off"      },
	{ DRM_MODE_DIRTY_ON,       "On"       },
	{ DRM_MODE_DIRTY_ANNOTATE, "Annotate" },
};

struct drm_conn_prop_enum_list {
	int type;
	const char *name;
#ifdef notyet
	struct ida ida;
#else
	int count;
#endif
};

/*
 * Connector and encoder types.
 */
static struct drm_conn_prop_enum_list drm_connector_enum_list[] =
{	{ DRM_MODE_CONNECTOR_Unknown, "Unknown" },
	{ DRM_MODE_CONNECTOR_VGA, "VGA" },
	{ DRM_MODE_CONNECTOR_DVII, "DVI-I" },
	{ DRM_MODE_CONNECTOR_DVID, "DVI-D" },
	{ DRM_MODE_CONNECTOR_DVIA, "DVI-A" },
	{ DRM_MODE_CONNECTOR_Composite, "Composite" },
	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO" },
	{ DRM_MODE_CONNECTOR_LVDS, "LVDS" },
	{ DRM_MODE_CONNECTOR_Component, "Component" },
	{ DRM_MODE_CONNECTOR_9PinDIN, "DIN" },
	{ DRM_MODE_CONNECTOR_DisplayPort, "DP" },
	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI-A" },
	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI-B" },
	{ DRM_MODE_CONNECTOR_TV, "TV" },
	{ DRM_MODE_CONNECTOR_eDP, "eDP" },
	{ DRM_MODE_CONNECTOR_VIRTUAL, "Virtual" },
	{ DRM_MODE_CONNECTOR_DSI, "DSI" },
};

static const struct drm_prop_enum_list drm_encoder_enum_list[] =
{	{ DRM_MODE_ENCODER_NONE, "None" },
	{ DRM_MODE_ENCODER_DAC, "DAC" },
	{ DRM_MODE_ENCODER_TMDS, "TMDS" },
	{ DRM_MODE_ENCODER_LVDS, "LVDS" },
	{ DRM_MODE_ENCODER_TVDAC, "TV" },
	{ DRM_MODE_ENCODER_VIRTUAL, "Virtual" },
	{ DRM_MODE_ENCODER_DSI, "DSI" },
};

void drm_connector_ida_init(void)
{
	printf("%s stub\n", __func__);
#ifdef notyet
	int i;

	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)
		ida_init(&drm_connector_enum_list[i].ida);
#endif
}

void drm_connector_ida_destroy(void)
{
	printf("%s stub\n", __func__);
#ifdef notyet
	int i;

	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)
		ida_destroy(&drm_connector_enum_list[i].ida);
#endif
}

const char *drm_get_encoder_name(const struct drm_encoder *encoder)
{
	static char buf[32];

	snprintf(buf, 32, "%s-%d",
		 drm_encoder_enum_list[encoder->encoder_type].name,
		 encoder->base.id);
	return buf;
}
EXPORT_SYMBOL(drm_get_encoder_name);

const char *drm_get_connector_name(const struct drm_connector *connector)
{
	static char buf[32];

	snprintf(buf, 32, "%s-%d",
		 drm_connector_enum_list[connector->connector_type].name,
		 connector->connector_type_id);
	return buf;
}
EXPORT_SYMBOL(drm_get_connector_name);

const char *drm_get_connector_status_name(enum drm_connector_status status)
{
	if (status == connector_status_connected)
		return "connected";
	else if (status == connector_status_disconnected)
		return "disconnected";
	else
		return "unknown";
}
EXPORT_SYMBOL(drm_get_connector_status_name);

static char printable_char(int c)
{
	return isascii(c) && isprint(c) ? c : '?';
}

const char *drm_get_format_name(uint32_t format)
{
	static char buf[32];

	snprintf(buf, sizeof(buf),
		 "%c%c%c%c %s-endian (0x%08x)",
		 printable_char(format & 0xff),
		 printable_char((format >> 8) & 0xff),
		 printable_char((format >> 16) & 0xff),
		 printable_char((format >> 24) & 0x7f),
		 format & DRM_FORMAT_BIG_ENDIAN ? "big" : "little",
		 format);

	return buf;
}
EXPORT_SYMBOL(drm_get_format_name);

/**
 * drm_mode_object_get - allocate a new modeset identifier
 * @@dev: DRM device
 * @@obj: object pointer, used to generate unique ID
 * @@obj_type: object type
 *
 * Create a unique identifier based on @@ptr in @@dev's identifier space.  Used
 * for tracking modes, CRTCs and connectors.
 *
 * RETURNS:
 * New unique (relative to other objects in @@dev) integer identifier for the
 * object.
 */
static int drm_mode_object_get(struct drm_device *dev,
			       struct drm_mode_object *obj, uint32_t obj_type)
{
	int ret;

	mutex_lock(&dev->mode_config.idr_mutex);
	/* XXX The xf86-video-intel driver truncates to 8 bits. */
	ret = idr_alloc(&dev->mode_config.crtc_idr, obj, 1, 256, GFP_KERNEL);
	if (ret >= 0) {
		/*
		 * Set up the object linking under the protection of the idr
		 * lock so that other users can't see inconsistent state.
		 */
		obj->id = ret;
		obj->type = obj_type;
	}
	mutex_unlock(&dev->mode_config.idr_mutex);

	return ret < 0 ? ret : 0;
}

/**
 * drm_mode_object_put - free a modeset identifer
 * @@dev: DRM device
 * @@object: object to free
 *
 * Free @@id from @@dev's unique identifier pool.
 */
static void drm_mode_object_put(struct drm_device *dev,
				struct drm_mode_object *object)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, object->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
}

/**
 * drm_mode_object_find - look up a drm object with static lifetime
 * @@dev: drm device
 * @@id: id of the mode object
 * @@type: type of the mode object
 *
 * Note that framebuffers cannot be looked up with this functions - since those
 * are reference counted, they need special treatment.
 */
struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
		uint32_t id, uint32_t type)
{
	struct drm_mode_object *obj = NULL;

	/* Framebuffers are reference counted and need their own lookup
	 * function.*/
	WARN_ON(type == DRM_MODE_OBJECT_FB);

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != type) || (obj->id != id))
		obj = NULL;
	mutex_unlock(&dev->mode_config.idr_mutex);

	return obj;
}
EXPORT_SYMBOL(drm_mode_object_find);

/**
 * drm_framebuffer_init - initialize a framebuffer
 * @@dev: DRM device
 * @@fb: framebuffer to be initialized
 * @@funcs: ... with these functions
 *
 * Allocates an ID for the framebuffer's parent mode object, sets its mode
 * functions & device file and adds it to the master fd list.
 *
 * IMPORTANT:
 * This functions publishes the fb and makes it available for concurrent access
 * by other users. Which means by this point the fb _must_ be fully set up -
 * since all the fb attributes are invariant over its lifetime, no further
 * locking but only correct reference counting is required.
 *
 * RETURNS:
 * Zero on success, error code on failure.
 */
int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,
			 const struct drm_framebuffer_funcs *funcs)
{
	int ret;

	mutex_lock(&dev->mode_config.fb_lock);
	kref_init(&fb->refcount);
	INIT_LIST_HEAD(&fb->filp_head);
	fb->dev = dev;
	fb->funcs = funcs;

	ret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);
	if (ret)
		goto out;

	/* Grab the idr reference. */
	drm_framebuffer_reference(fb);

	dev->mode_config.num_fb++;
	list_add(&fb->head, &dev->mode_config.fb_list);
out:
	mutex_unlock(&dev->mode_config.fb_lock);

	return 0;
}
EXPORT_SYMBOL(drm_framebuffer_init);

static void drm_framebuffer_free(struct kref *kref)
{
	struct drm_framebuffer *fb =
			container_of(kref, struct drm_framebuffer, refcount);
	fb->funcs->destroy(fb);
}

static struct drm_framebuffer *__drm_framebuffer_lookup(struct drm_device *dev,
							uint32_t id)
{
	struct drm_mode_object *obj = NULL;
	struct drm_framebuffer *fb;

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != DRM_MODE_OBJECT_FB) || (obj->id != id))
		fb = NULL;
	else
		fb = obj_to_fb(obj);
	mutex_unlock(&dev->mode_config.idr_mutex);

	return fb;
}

/**
 * drm_framebuffer_lookup - look up a drm framebuffer and grab a reference
 * @@dev: drm device
 * @@id: id of the fb object
 *
 * If successful, this grabs an additional reference to the framebuffer -
 * callers need to make sure to eventually unreference the returned framebuffer
 * again.
 */
struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
					       uint32_t id)
{
	struct drm_framebuffer *fb;

	mutex_lock(&dev->mode_config.fb_lock);
	fb = __drm_framebuffer_lookup(dev, id);
	if (fb)
		drm_framebuffer_reference(fb);
	mutex_unlock(&dev->mode_config.fb_lock);

	return fb;
}
EXPORT_SYMBOL(drm_framebuffer_lookup);

/**
 * drm_framebuffer_unreference - unref a framebuffer
 * @@fb: framebuffer to unref
 *
 * This functions decrements the fb's refcount and frees it if it drops to zero.
 */
void drm_framebuffer_unreference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
	kref_put(&fb->refcount, drm_framebuffer_free);
}
EXPORT_SYMBOL(drm_framebuffer_unreference);

/**
 * drm_framebuffer_reference - incr the fb refcnt
 * @@fb: framebuffer
 */
void drm_framebuffer_reference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
	kref_get(&fb->refcount);
}
EXPORT_SYMBOL(drm_framebuffer_reference);

static void drm_framebuffer_free_bug(struct kref *kref)
{
	BUG();
}

static void __drm_framebuffer_unreference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
	kref_put(&fb->refcount, drm_framebuffer_free_bug);
}

/* dev->mode_config.fb_lock must be held! */
static void __drm_framebuffer_unregister(struct drm_device *dev,
					 struct drm_framebuffer *fb)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, fb->base.id);
	mutex_unlock(&dev->mode_config.idr_mutex);

	fb->base.id = 0;

	__drm_framebuffer_unreference(fb);
}

/**
 * drm_framebuffer_unregister_private - unregister a private fb from the lookup idr
 * @@fb: fb to unregister
 *
 * Drivers need to call this when cleaning up driver-private framebuffers, e.g.
 * those used for fbdev. Note that the caller must hold a reference of it's own,
 * i.e. the object may not be destroyed through this call (since it'll lead to a
 * locking inversion).
 */
void drm_framebuffer_unregister_private(struct drm_framebuffer *fb)
{
	struct drm_device *dev = fb->dev;

	mutex_lock(&dev->mode_config.fb_lock);
	/* Mark fb as reaped and drop idr ref. */
	__drm_framebuffer_unregister(dev, fb);
	mutex_unlock(&dev->mode_config.fb_lock);
}
EXPORT_SYMBOL(drm_framebuffer_unregister_private);

/**
 * drm_framebuffer_cleanup - remove a framebuffer object
 * @@fb: framebuffer to remove
 *
 * Cleanup references to a user-created framebuffer. This function is intended
 * to be used from the drivers ->destroy callback.
 *
 * Note that this function does not remove the fb from active usuage - if it is
 * still used anywhere, hilarity can ensue since userspace could call getfb on
 * the id and get back -EINVAL. Obviously no concern at driver unload time.
 *
 * Also, the framebuffer will not be removed from the lookup idr - for
 * user-created framebuffers this will happen in in the rmfb ioctl. For
 * driver-private objects (e.g. for fbdev) drivers need to explicitly call
 * drm_framebuffer_unregister_private.
 */
void drm_framebuffer_cleanup(struct drm_framebuffer *fb)
{
	struct drm_device *dev = fb->dev;

	mutex_lock(&dev->mode_config.fb_lock);
	list_del(&fb->head);
	dev->mode_config.num_fb--;
	mutex_unlock(&dev->mode_config.fb_lock);
}
EXPORT_SYMBOL(drm_framebuffer_cleanup);

/**
 * drm_framebuffer_remove - remove and unreference a framebuffer object
 * @@fb: framebuffer to remove
 *
 * Scans all the CRTCs and planes in @@dev's mode_config.  If they're
 * using @@fb, removes it, setting it to NULL. Then drops the reference to the
 * passed-in framebuffer. Might take the modeset locks.
 *
 * Note that this function optimizes the cleanup away if the caller holds the
 * last reference to the framebuffer. It is also guaranteed to not take the
 * modeset locks in this case.
 */
void drm_framebuffer_remove(struct drm_framebuffer *fb)
{
	struct drm_device *dev = fb->dev;
	struct drm_crtc *crtc;
	struct drm_plane *plane;
	struct drm_mode_set set;
	int ret;

	WARN_ON(!list_empty(&fb->filp_head));

	/*
	 * drm ABI mandates that we remove any deleted framebuffers from active
	 * useage. But since most sane clients only remove framebuffers they no
	 * longer need, try to optimize this away.
	 *
	 * Since we're holding a reference ourselves, observing a refcount of 1
	 * means that we're the last holder and can skip it. Also, the refcount
	 * can never increase from 1 again, so we don't need any barriers or
	 * locks.
	 *
	 * Note that userspace could try to race with use and instate a new
	 * usage _after_ we've cleared all current ones. End result will be an
	 * in-use fb with fb-id == 0. Userspace is allowed to shoot its own foot
	 * in this manner.
	 */
	if (atomic_read(&fb->refcount.refcount) > 1) {
		drm_modeset_lock_all(dev);
		/* remove from any CRTC */
		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
			if (crtc->fb == fb) {
				/* should turn off the crtc */
				memset(&set, 0, sizeof(struct drm_mode_set));
				set.crtc = crtc;
				set.fb = NULL;
				ret = drm_mode_set_config_internal(&set);
				if (ret)
					DRM_ERROR("failed to reset crtc %p when fb was deleted\n", crtc);
			}
		}

		list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
			if (plane->fb == fb)
				drm_plane_force_disable(plane);
		}
		drm_modeset_unlock_all(dev);
	}

	drm_framebuffer_unreference(fb);
}
EXPORT_SYMBOL(drm_framebuffer_remove);

/**
 * drm_crtc_init - Initialise a new CRTC object
 * @@dev: DRM device
 * @@crtc: CRTC object to init
 * @@funcs: callbacks for the new CRTC
 *
 * Inits a new object created as base part of a driver crtc object.
 *
 * RETURNS:
 * Zero on success, error code on failure.
 */
int drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
		   const struct drm_crtc_funcs *funcs)
{
	int ret;

	crtc->dev = dev;
	crtc->funcs = funcs;
	crtc->invert_dimensions = false;

	drm_modeset_lock_all(dev);
	rw_init_flags(&crtc->mutex, "crtcl", RWL_DUPOK);
	mutex_lock_nest_lock(&crtc->mutex, &dev->mode_config.mutex);

	ret = drm_mode_object_get(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);
	if (ret)
		goto out;

	crtc->base.properties = &crtc->properties;

	list_add_tail(&crtc->head, &dev->mode_config.crtc_list);
	dev->mode_config.num_crtc++;

 out:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_crtc_init);

/**
 * drm_crtc_cleanup - Clean up the core crtc usage
 * @@crtc: CRTC to cleanup
 *
 * This function cleans up @@crtc and removes it from the DRM mode setting
 * core. Note that the function does *not* free the crtc structure itself,
 * this is the responsibility of the caller.
 */
void drm_crtc_cleanup(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;

	kfree(crtc->gamma_store);
	crtc->gamma_store = NULL;

	drm_mode_object_put(dev, &crtc->base);
	list_del(&crtc->head);
	dev->mode_config.num_crtc--;
}
EXPORT_SYMBOL(drm_crtc_cleanup);

/**
 * drm_crtc_index - find the index of a registered CRTC
 * @@crtc: CRTC to find index for
 *
 * Given a registered CRTC, return the index of that CRTC within a DRM
 * device's list of CRTCs.
 */
unsigned int drm_crtc_index(struct drm_crtc *crtc)
{
	unsigned int index = 0;
	struct drm_crtc *tmp;

	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head) {
		if (tmp == crtc)
			return index;

		index++;
	}

	BUG();
}
EXPORT_SYMBOL(drm_crtc_index);

/**
 * drm_mode_probed_add - add a mode to a connector's probed mode list
 * @@connector: connector the new mode
 * @@mode: mode data
 *
 * Add @@mode to @@connector's mode list for later use.
 */
void drm_mode_probed_add(struct drm_connector *connector,
			 struct drm_display_mode *mode)
{
	list_add_tail(&mode->head, &connector->probed_modes);
}
EXPORT_SYMBOL(drm_mode_probed_add);

/*
 * drm_mode_remove - remove and free a mode
 * @@connector: connector list to modify
 * @@mode: mode to remove
 *
 * Remove @@mode from @@connector's mode list, then free it.
 */
static void drm_mode_remove(struct drm_connector *connector,
			    struct drm_display_mode *mode)
{
	list_del(&mode->head);
	drm_mode_destroy(connector->dev, mode);
}

/**
 * drm_connector_init - Init a preallocated connector
 * @@dev: DRM device
 * @@connector: the connector to init
 * @@funcs: callbacks for this connector
 * @@connector_type: user visible type of the connector
 *
 * Initialises a preallocated connector. Connectors should be
 * subclassed as part of driver connector objects.
 *
 * RETURNS:
 * Zero on success, error code on failure.
 */
int drm_connector_init(struct drm_device *dev,
		       struct drm_connector *connector,
		       const struct drm_connector_funcs *funcs,
		       int connector_type)
{
	int ret;
#ifdef notyet
	struct ida *connector_ida =
		&drm_connector_enum_list[connector_type].ida;
#endif

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get(dev, &connector->base, DRM_MODE_OBJECT_CONNECTOR);
	if (ret)
		goto out;

	connector->base.properties = &connector->properties;
	connector->dev = dev;
	connector->funcs = funcs;
	connector->connector_type = connector_type;
#ifdef notyet
	connector->connector_type_id =
		ida_simple_get(connector_ida, 1, 0, GFP_KERNEL);
#else
	connector->connector_type_id =
		++drm_connector_enum_list[connector_type].count;
#endif
	if (connector->connector_type_id < 0) {
		ret = connector->connector_type_id;
		drm_mode_object_put(dev, &connector->base);
		goto out;
	}
	INIT_LIST_HEAD(&connector->probed_modes);
	INIT_LIST_HEAD(&connector->modes);
	connector->edid_blob_ptr = NULL;
	connector->status = connector_status_unknown;

	list_add_tail(&connector->head, &dev->mode_config.connector_list);
	dev->mode_config.num_connector++;

	if (connector_type != DRM_MODE_CONNECTOR_VIRTUAL)
		drm_object_attach_property(&connector->base,
					      dev->mode_config.edid_property,
					      0);

	drm_object_attach_property(&connector->base,
				      dev->mode_config.dpms_property, 0);

 out:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_connector_init);

/**
 * drm_connector_cleanup - cleans up an initialised connector
 * @@connector: connector to cleanup
 *
 * Cleans up the connector but doesn't free the object.
 */
void drm_connector_cleanup(struct drm_connector *connector)
{
	struct drm_device *dev = connector->dev;
	struct drm_display_mode *mode, *t;

	list_for_each_entry_safe(mode, t, &connector->probed_modes, head)
		drm_mode_remove(connector, mode);

	list_for_each_entry_safe(mode, t, &connector->modes, head)
		drm_mode_remove(connector, mode);

#ifdef notyet
	ida_remove(&drm_connector_enum_list[connector->connector_type].ida,
		   connector->connector_type_id);
#endif

	drm_mode_object_put(dev, &connector->base);
	list_del(&connector->head);
	dev->mode_config.num_connector--;
}
EXPORT_SYMBOL(drm_connector_cleanup);

void drm_connector_unplug_all(struct drm_device *dev)
{
	struct drm_connector *connector;

	/* taking the mode config mutex ends up in a clash with sysfs */
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
		drm_sysfs_connector_remove(connector);
}
EXPORT_SYMBOL(drm_connector_unplug_all);

int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge,
		const struct drm_bridge_funcs *funcs)
{
	int ret;

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get(dev, &bridge->base, DRM_MODE_OBJECT_BRIDGE);
	if (ret)
		goto out;

	bridge->dev = dev;
	bridge->funcs = funcs;

	list_add_tail(&bridge->head, &dev->mode_config.bridge_list);
	dev->mode_config.num_bridge++;

 out:
	drm_modeset_unlock_all(dev);
	return ret;
}
EXPORT_SYMBOL(drm_bridge_init);

void drm_bridge_cleanup(struct drm_bridge *bridge)
{
	struct drm_device *dev = bridge->dev;

	drm_modeset_lock_all(dev);
	drm_mode_object_put(dev, &bridge->base);
	list_del(&bridge->head);
	dev->mode_config.num_bridge--;
	drm_modeset_unlock_all(dev);
}
EXPORT_SYMBOL(drm_bridge_cleanup);

int drm_encoder_init(struct drm_device *dev,
		      struct drm_encoder *encoder,
		      const struct drm_encoder_funcs *funcs,
		      int encoder_type)
{
	int ret;

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);
	if (ret)
		goto out;

	encoder->dev = dev;
	encoder->encoder_type = encoder_type;
	encoder->funcs = funcs;

	list_add_tail(&encoder->head, &dev->mode_config.encoder_list);
	dev->mode_config.num_encoder++;

 out:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_encoder_init);

void drm_encoder_cleanup(struct drm_encoder *encoder)
{
	struct drm_device *dev = encoder->dev;
	drm_modeset_lock_all(dev);
	drm_mode_object_put(dev, &encoder->base);
	list_del(&encoder->head);
	dev->mode_config.num_encoder--;
	drm_modeset_unlock_all(dev);
}
EXPORT_SYMBOL(drm_encoder_cleanup);

/**
 * drm_plane_init - Initialise a new plane object
 * @@dev: DRM device
 * @@plane: plane object to init
 * @@possible_crtcs: bitmask of possible CRTCs
 * @@funcs: callbacks for the new plane
 * @@formats: array of supported formats (%DRM_FORMAT_*)
 * @@format_count: number of elements in @@formats
 * @@priv: plane is private (hidden from userspace)?
 *
 * Inits a new object created as base part of a driver plane object.
 *
 * RETURNS:
 * Zero on success, error code on failure.
 */
int drm_plane_init(struct drm_device *dev, struct drm_plane *plane,
		   unsigned long possible_crtcs,
		   const struct drm_plane_funcs *funcs,
		   const uint32_t *formats, uint32_t format_count,
		   bool priv)
{
	int ret;

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get(dev, &plane->base, DRM_MODE_OBJECT_PLANE);
	if (ret)
		goto out;

	plane->base.properties = &plane->properties;
	plane->dev = dev;
	plane->funcs = funcs;
	plane->format_types = kmalloc(sizeof(uint32_t) * format_count,
				      GFP_KERNEL);
	if (!plane->format_types) {
		DRM_DEBUG_KMS("out of memory when allocating plane\n");
		drm_mode_object_put(dev, &plane->base);
		ret = -ENOMEM;
		goto out;
	}

	memcpy(plane->format_types, formats, format_count * sizeof(uint32_t));
	plane->format_count = format_count;
	plane->possible_crtcs = possible_crtcs;

	/* private planes are not exposed to userspace, but depending on
	 * display hardware, might be convenient to allow sharing programming
	 * for the scanout engine with the crtc implementation.
	 */
	if (!priv) {
		list_add_tail(&plane->head, &dev->mode_config.plane_list);
		dev->mode_config.num_plane++;
	} else {
		INIT_LIST_HEAD(&plane->head);
	}

 out:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_plane_init);

/**
 * drm_plane_cleanup - Clean up the core plane usage
 * @@plane: plane to cleanup
 *
 * This function cleans up @@plane and removes it from the DRM mode setting
 * core. Note that the function does *not* free the plane structure itself,
 * this is the responsibility of the caller.
 */
void drm_plane_cleanup(struct drm_plane *plane)
{
	struct drm_device *dev = plane->dev;

	drm_modeset_lock_all(dev);
	kfree(plane->format_types);
	drm_mode_object_put(dev, &plane->base);
	/* if not added to a list, it must be a private plane */
	if (!list_empty(&plane->head)) {
		list_del(&plane->head);
		dev->mode_config.num_plane--;
	}
	drm_modeset_unlock_all(dev);
}
EXPORT_SYMBOL(drm_plane_cleanup);

/**
 * drm_plane_force_disable - Forcibly disable a plane
 * @@plane: plane to disable
 *
 * Forces the plane to be disabled.
 *
 * Used when the plane's current framebuffer is destroyed,
 * and when restoring fbdev mode.
 */
void drm_plane_force_disable(struct drm_plane *plane)
{
	int ret;

	if (!plane->fb)
		return;

	ret = plane->funcs->disable_plane(plane);
	if (ret)
		DRM_ERROR("failed to disable plane with busy fb\n");
	/* disconnect the plane from the fb and crtc: */
	__drm_framebuffer_unreference(plane->fb);
	plane->fb = NULL;
	plane->crtc = NULL;
}
EXPORT_SYMBOL(drm_plane_force_disable);

/**
 * drm_mode_create - create a new display mode
 * @@dev: DRM device
 *
 * Create a new drm_display_mode, give it an ID, and return it.
 *
 * RETURNS:
 * Pointer to new mode on success, NULL on error.
 */
struct drm_display_mode *drm_mode_create(struct drm_device *dev)
{
	struct drm_display_mode *nmode;

	nmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);
	if (!nmode)
		return NULL;

	if (drm_mode_object_get(dev, &nmode->base, DRM_MODE_OBJECT_MODE)) {
		kfree(nmode);
		return NULL;
	}

	return nmode;
}
EXPORT_SYMBOL(drm_mode_create);

/**
 * drm_mode_destroy - remove a mode
 * @@dev: DRM device
 * @@mode: mode to remove
 *
 * Free @@mode's unique identifier, then free it.
 */
void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
{
	if (!mode)
		return;

	drm_mode_object_put(dev, &mode->base);

	kfree(mode);
}
EXPORT_SYMBOL(drm_mode_destroy);

static int drm_mode_create_standard_connector_properties(struct drm_device *dev)
{
	struct drm_property *edid;
	struct drm_property *dpms;

	/*
	 * Standard properties (apply to all connectors)
	 */
	edid = drm_property_create(dev, DRM_MODE_PROP_BLOB |
				   DRM_MODE_PROP_IMMUTABLE,
				   "EDID", 0);
	dev->mode_config.edid_property = edid;

	dpms = drm_property_create_enum(dev, 0,
				   "DPMS", drm_dpms_enum_list,
				   ARRAY_SIZE(drm_dpms_enum_list));
	dev->mode_config.dpms_property = dpms;

	return 0;
}

/**
 * drm_mode_create_dvi_i_properties - create DVI-I specific connector properties
 * @@dev: DRM device
 *
 * Called by a driver the first time a DVI-I connector is made.
 */
int drm_mode_create_dvi_i_properties(struct drm_device *dev)
{
	struct drm_property *dvi_i_selector;
	struct drm_property *dvi_i_subconnector;

	if (dev->mode_config.dvi_i_select_subconnector_property)
		return 0;

	dvi_i_selector =
		drm_property_create_enum(dev, 0,
				    "select subconnector",
				    drm_dvi_i_select_enum_list,
				    ARRAY_SIZE(drm_dvi_i_select_enum_list));
	dev->mode_config.dvi_i_select_subconnector_property = dvi_i_selector;

	dvi_i_subconnector = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "subconnector",
				    drm_dvi_i_subconnector_enum_list,
				    ARRAY_SIZE(drm_dvi_i_subconnector_enum_list));
	dev->mode_config.dvi_i_subconnector_property = dvi_i_subconnector;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dvi_i_properties);

/**
 * drm_create_tv_properties - create TV specific connector properties
 * @@dev: DRM device
 * @@num_modes: number of different TV formats (modes) supported
 * @@modes: array of pointers to strings containing name of each format
 *
 * Called by a driver's TV initialization routine, this function creates
 * the TV specific connector properties for a given device.  Caller is
 * responsible for allocating a list of format names and passing them to
 * this routine.
 */
int drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,
				  char *modes[])
{
	struct drm_property *tv_selector;
	struct drm_property *tv_subconnector;
	int i;

	if (dev->mode_config.tv_select_subconnector_property)
		return 0;

	/*
	 * Basic connector properties
	 */
	tv_selector = drm_property_create_enum(dev, 0,
					  "select subconnector",
					  drm_tv_select_enum_list,
					  ARRAY_SIZE(drm_tv_select_enum_list));
	dev->mode_config.tv_select_subconnector_property = tv_selector;

	tv_subconnector =
		drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "subconnector",
				    drm_tv_subconnector_enum_list,
				    ARRAY_SIZE(drm_tv_subconnector_enum_list));
	dev->mode_config.tv_subconnector_property = tv_subconnector;

	/*
	 * Other, TV specific properties: margins & TV modes.
	 */
	dev->mode_config.tv_left_margin_property =
		drm_property_create_range(dev, 0, "left margin", 0, 100);

	dev->mode_config.tv_right_margin_property =
		drm_property_create_range(dev, 0, "right margin", 0, 100);

	dev->mode_config.tv_top_margin_property =
		drm_property_create_range(dev, 0, "top margin", 0, 100);

	dev->mode_config.tv_bottom_margin_property =
		drm_property_create_range(dev, 0, "bottom margin", 0, 100);

	dev->mode_config.tv_mode_property =
		drm_property_create(dev, DRM_MODE_PROP_ENUM,
				    "mode", num_modes);
	for (i = 0; i < num_modes; i++)
		drm_property_add_enum(dev->mode_config.tv_mode_property, i,
				      i, modes[i]);

	dev->mode_config.tv_brightness_property =
		drm_property_create_range(dev, 0, "brightness", 0, 100);

	dev->mode_config.tv_contrast_property =
		drm_property_create_range(dev, 0, "contrast", 0, 100);

	dev->mode_config.tv_flicker_reduction_property =
		drm_property_create_range(dev, 0, "flicker reduction", 0, 100);

	dev->mode_config.tv_overscan_property =
		drm_property_create_range(dev, 0, "overscan", 0, 100);

	dev->mode_config.tv_saturation_property =
		drm_property_create_range(dev, 0, "saturation", 0, 100);

	dev->mode_config.tv_hue_property =
		drm_property_create_range(dev, 0, "hue", 0, 100);

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_tv_properties);

/**
 * drm_mode_create_scaling_mode_property - create scaling mode property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_scaling_mode_property(struct drm_device *dev)
{
	struct drm_property *scaling_mode;

	if (dev->mode_config.scaling_mode_property)
		return 0;

	scaling_mode =
		drm_property_create_enum(dev, 0, "scaling mode",
				drm_scaling_mode_enum_list,
				    ARRAY_SIZE(drm_scaling_mode_enum_list));

	dev->mode_config.scaling_mode_property = scaling_mode;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_scaling_mode_property);

/**
 * drm_mode_create_dirty_property - create dirty property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_dirty_info_property(struct drm_device *dev)
{
	struct drm_property *dirty_info;

	if (dev->mode_config.dirty_info_property)
		return 0;

	dirty_info =
		drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "dirty",
				    drm_dirty_info_enum_list,
				    ARRAY_SIZE(drm_dirty_info_enum_list));
	dev->mode_config.dirty_info_property = dirty_info;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dirty_info_property);

static int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
{
	uint32_t total_objects = 0;

	total_objects += dev->mode_config.num_crtc;
	total_objects += dev->mode_config.num_connector;
	total_objects += dev->mode_config.num_encoder;
	total_objects += dev->mode_config.num_bridge;

	group->id_list = kzalloc(total_objects * sizeof(uint32_t), GFP_KERNEL);
	if (!group->id_list)
		return -ENOMEM;

	group->num_crtcs = 0;
	group->num_connectors = 0;
	group->num_encoders = 0;
	group->num_bridges = 0;
	return 0;
}

int drm_mode_group_init_legacy_group(struct drm_device *dev,
				     struct drm_mode_group *group)
{
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	struct drm_connector *connector;
	struct drm_bridge *bridge;
	int ret;

	if ((ret = drm_mode_group_init(dev, group)))
		return ret;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		group->id_list[group->num_crtcs++] = crtc->base.id;

	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
		group->id_list[group->num_crtcs + group->num_encoders++] =
		encoder->base.id;

	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
		group->id_list[group->num_crtcs + group->num_encoders +
			       group->num_connectors++] = connector->base.id;

	list_for_each_entry(bridge, &dev->mode_config.bridge_list, head)
		group->id_list[group->num_crtcs + group->num_encoders +
			       group->num_connectors + group->num_bridges++] =
					bridge->base.id;

	return 0;
}
EXPORT_SYMBOL(drm_mode_group_init_legacy_group);

/**
 * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo
 * @@out: drm_mode_modeinfo struct to return to the user
 * @@in: drm_display_mode to use
 *
 * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to
 * the user.
 */
static void drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,
				      const struct drm_display_mode *in)
{
	WARN(in->hdisplay > USHRT_MAX || in->hsync_start > USHRT_MAX ||
	     in->hsync_end > USHRT_MAX || in->htotal > USHRT_MAX ||
	     in->hskew > USHRT_MAX || in->vdisplay > USHRT_MAX ||
	     in->vsync_start > USHRT_MAX || in->vsync_end > USHRT_MAX ||
	     in->vtotal > USHRT_MAX || in->vscan > USHRT_MAX,
	     "timing values too large for mode info\n");

	out->clock = in->clock;
	out->hdisplay = in->hdisplay;
	out->hsync_start = in->hsync_start;
	out->hsync_end = in->hsync_end;
	out->htotal = in->htotal;
	out->hskew = in->hskew;
	out->vdisplay = in->vdisplay;
	out->vsync_start = in->vsync_start;
	out->vsync_end = in->vsync_end;
	out->vtotal = in->vtotal;
	out->vscan = in->vscan;
	out->vrefresh = in->vrefresh;
	out->flags = in->flags;
	out->type = in->type;
	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;
}

/**
 * drm_crtc_convert_umode - convert a modeinfo into a drm_display_mode
 * @@out: drm_display_mode to return to the user
 * @@in: drm_mode_modeinfo to use
 *
 * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to
 * the caller.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
static int drm_crtc_convert_umode(struct drm_display_mode *out,
				  const struct drm_mode_modeinfo *in)
{
	if (in->clock > INT_MAX || in->vrefresh > INT_MAX)
		return -ERANGE;

	if ((in->flags & DRM_MODE_FLAG_3D_MASK) > DRM_MODE_FLAG_3D_MAX)
		return -EINVAL;

	out->clock = in->clock;
	out->hdisplay = in->hdisplay;
	out->hsync_start = in->hsync_start;
	out->hsync_end = in->hsync_end;
	out->htotal = in->htotal;
	out->hskew = in->hskew;
	out->vdisplay = in->vdisplay;
	out->vsync_start = in->vsync_start;
	out->vsync_end = in->vsync_end;
	out->vtotal = in->vtotal;
	out->vscan = in->vscan;
	out->vrefresh = in->vrefresh;
	out->flags = in->flags;
	out->type = in->type;
	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;

	return 0;
}

/**
 * drm_mode_getresources - get graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a set of configuration description structures and return
 * them to the user, including CRTC, connector and framebuffer configuration.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_getresources(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	struct drm_mode_card_res *card_res = data;
	struct list_head *lh;
	struct drm_framebuffer *fb;
	struct drm_connector *connector;
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	int ret = 0;
	int connector_count = 0;
	int crtc_count = 0;
	int fb_count = 0;
	int encoder_count = 0;
#ifdef notyet
	int copied = 0, i;
#else
	int copied = 0;
#endif
	uint32_t __user *fb_id;
	uint32_t __user *crtc_id;
	uint32_t __user *connector_id;
	uint32_t __user *encoder_id;
#ifdef notyet
	struct drm_mode_group *mode_group;
#endif

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;


	mutex_lock(&file_priv->fbs_lock);
	/*
	 * For the non-control nodes we need to limit the list of resources
	 * by IDs in the group list for this node
	 */
	list_for_each(lh, &file_priv->fbs)
		fb_count++;

	/* handle this in 4 parts */
	/* FBs */
	if (card_res->count_fbs >= fb_count) {
		copied = 0;
		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
			if (put_user(fb->base.id, fb_id + copied)) {
				mutex_unlock(&file_priv->fbs_lock);
				return -EFAULT;
			}
			copied++;
		}
	}
	card_res->count_fbs = fb_count;
	mutex_unlock(&file_priv->fbs_lock);

	drm_modeset_lock_all(dev);
#ifdef notyet
	mode_group = &file_priv->master->minor->mode_group;
	if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif

		list_for_each(lh, &dev->mode_config.crtc_list)
			crtc_count++;

		list_for_each(lh, &dev->mode_config.connector_list)
			connector_count++;

		list_for_each(lh, &dev->mode_config.encoder_list)
			encoder_count++;
#ifdef notyet
	} else {

		crtc_count = mode_group->num_crtcs;
		connector_count = mode_group->num_connectors;
		encoder_count = mode_group->num_encoders;
	}
#endif

	card_res->max_height = dev->mode_config.max_height;
	card_res->min_height = dev->mode_config.min_height;
	card_res->max_width = dev->mode_config.max_width;
	card_res->min_width = dev->mode_config.min_width;

	/* CRTCs */
	if (card_res->count_crtcs >= crtc_count) {
		copied = 0;
		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(crtc, &dev->mode_config.crtc_list,
					    head) {
				DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);
				if (put_user(crtc->base.id, crtc_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
#ifdef notyet
		} else {
			for (i = 0; i < mode_group->num_crtcs; i++) {
				if (put_user(mode_group->id_list[i],
					     crtc_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
		}
#endif
	}
	card_res->count_crtcs = crtc_count;

	/* Encoders */
	if (card_res->count_encoders >= encoder_count) {
		copied = 0;
		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(encoder,
					    &dev->mode_config.encoder_list,
					    head) {
				DRM_DEBUG_KMS("[ENCODER:%d:%s]\n", encoder->base.id,
						drm_get_encoder_name(encoder));
				if (put_user(encoder->base.id, encoder_id +
					     copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
#ifdef notyet
		} else {
			for (i = mode_group->num_crtcs; i < mode_group->num_crtcs + mode_group->num_encoders; i++) {
				if (put_user(mode_group->id_list[i],
					     encoder_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}

		}
#endif
	}
	card_res->count_encoders = encoder_count;

	/* Connectors */
	if (card_res->count_connectors >= connector_count) {
		copied = 0;
		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(connector,
					    &dev->mode_config.connector_list,
					    head) {
				DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
					connector->base.id,
					drm_get_connector_name(connector));
				if (put_user(connector->base.id,
					     connector_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
#ifdef notyet
		} else {
			int start = mode_group->num_crtcs +
				mode_group->num_encoders;
			for (i = start; i < start + mode_group->num_connectors; i++) {
				if (put_user(mode_group->id_list[i],
					     connector_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
		}
#endif
	}
	card_res->count_connectors = connector_count;

	DRM_DEBUG_KMS("CRTC[%d] CONNECTORS[%d] ENCODERS[%d]\n", card_res->count_crtcs,
		  card_res->count_connectors, card_res->count_encoders);

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_getcrtc - get CRTC configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a CRTC configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_getcrtc(struct drm_device *dev,
		     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc *crtc_resp = data;
	struct drm_crtc *crtc;
	struct drm_mode_object *obj;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);

	obj = drm_mode_object_find(dev, crtc_resp->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);

	crtc_resp->x = crtc->x;
	crtc_resp->y = crtc->y;
	crtc_resp->gamma_size = crtc->gamma_size;
	if (crtc->fb)
		crtc_resp->fb_id = crtc->fb->base.id;
	else
		crtc_resp->fb_id = 0;

	if (crtc->enabled) {

		drm_crtc_convert_to_umode(&crtc_resp->mode, &crtc->mode);
		crtc_resp->mode_valid = 1;

	} else {
		crtc_resp->mode_valid = 0;
	}

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

static bool drm_mode_expose_to_userspace(const struct drm_display_mode *mode,
					 const struct drm_file *file_priv)
{
	/*
	 * If user-space hasn't configured the driver to expose the stereo 3D
	 * modes, don't expose them.
	 */
	if (!file_priv->stereo_allowed && drm_mode_is_stereo(mode))
		return false;

	return true;
}

/**
 * drm_mode_getconnector - get connector configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a connector configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_getconnector(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	struct drm_mode_get_connector *out_resp = data;
	struct drm_mode_object *obj;
	struct drm_connector *connector;
	struct drm_display_mode *mode;
	int mode_count = 0;
	int props_count = 0;
	int encoders_count = 0;
	int ret = 0;
	int copied = 0;
	int i;
	struct drm_mode_modeinfo u_mode;
	struct drm_mode_modeinfo __user *mode_ptr;
	uint32_t __user *prop_ptr;
	uint64_t __user *prop_values;
	uint32_t __user *encoder_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	memset(&u_mode, 0, sizeof(struct drm_mode_modeinfo));

	DRM_DEBUG_KMS("[CONNECTOR:%d:?]\n", out_resp->connector_id);

	mutex_lock(&dev->mode_config.mutex);

	obj = drm_mode_object_find(dev, out_resp->connector_id,
				   DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	connector = obj_to_connector(obj);

	props_count = connector->properties.count;

	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] != 0) {
			encoders_count++;
		}
	}

	if (out_resp->count_modes == 0) {
		connector->funcs->fill_modes(connector,
					     dev->mode_config.max_width,
					     dev->mode_config.max_height);
	}

	/* delayed so we get modes regardless of pre-fill_modes state */
	list_for_each_entry(mode, &connector->modes, head)
		if (drm_mode_expose_to_userspace(mode, file_priv))
			mode_count++;

	out_resp->connector_id = connector->base.id;
	out_resp->connector_type = connector->connector_type;
	out_resp->connector_type_id = connector->connector_type_id;
	out_resp->mm_width = connector->display_info.width_mm;
	out_resp->mm_height = connector->display_info.height_mm;
	out_resp->subpixel = connector->display_info.subpixel_order;
	out_resp->connection = connector->status;
	if (connector->encoder)
		out_resp->encoder_id = connector->encoder->base.id;
	else
		out_resp->encoder_id = 0;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if ((out_resp->count_modes >= mode_count) && mode_count) {
		copied = 0;
		mode_ptr = (struct drm_mode_modeinfo __user *)(unsigned long)out_resp->modes_ptr;
		list_for_each_entry(mode, &connector->modes, head) {
			if (!drm_mode_expose_to_userspace(mode, file_priv))
				continue;

			drm_crtc_convert_to_umode(&u_mode, mode);
			if (copy_to_user(mode_ptr + copied,
					 &u_mode, sizeof(u_mode))) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	out_resp->count_modes = mode_count;

	if ((out_resp->count_props >= props_count) && props_count) {
		copied = 0;
		prop_ptr = (uint32_t __user *)(unsigned long)(out_resp->props_ptr);
		prop_values = (uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr);
		for (i = 0; i < connector->properties.count; i++) {
			if (put_user(connector->properties.ids[i],
				     prop_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}

			if (put_user(connector->properties.values[i],
				     prop_values + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	out_resp->count_props = props_count;

	if ((out_resp->count_encoders >= encoders_count) && encoders_count) {
		copied = 0;
		encoder_ptr = (uint32_t __user *)(unsigned long)(out_resp->encoders_ptr);
		for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
			if (connector->encoder_ids[i] != 0) {
				if (put_user(connector->encoder_ids[i],
					     encoder_ptr + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
		}
	}
	out_resp->count_encoders = encoders_count;

out:
	mutex_unlock(&dev->mode_config.mutex);

	return ret;
}

int drm_mode_getencoder(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	struct drm_mode_get_encoder *enc_resp = data;
	struct drm_mode_object *obj;
	struct drm_encoder *encoder;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, enc_resp->encoder_id,
				   DRM_MODE_OBJECT_ENCODER);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	encoder = obj_to_encoder(obj);

	if (encoder->crtc)
		enc_resp->crtc_id = encoder->crtc->base.id;
	else
		enc_resp->crtc_id = 0;
	enc_resp->encoder_type = encoder->encoder_type;
	enc_resp->encoder_id = encoder->base.id;
	enc_resp->possible_crtcs = encoder->possible_crtcs;
	enc_resp->possible_clones = encoder->possible_clones;

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_getplane_res - get plane info
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Return an plane count and set of IDs.
 */
int drm_mode_getplane_res(struct drm_device *dev, void *data,
			    struct drm_file *file_priv)
{
	struct drm_mode_get_plane_res *plane_resp = data;
	struct drm_mode_config *config;
	struct drm_plane *plane;
	uint32_t __user *plane_ptr;
	int copied = 0, ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	config = &dev->mode_config;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if (config->num_plane &&
	    (plane_resp->count_planes >= config->num_plane)) {
		plane_ptr = (uint32_t __user *)(unsigned long)plane_resp->plane_id_ptr;

		list_for_each_entry(plane, &config->plane_list, head) {
			if (put_user(plane->base.id, plane_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	plane_resp->count_planes = config->num_plane;

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_getplane - get plane info
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Return plane info, including formats supported, gamma size, any
 * current fb, etc.
 */
int drm_mode_getplane(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	struct drm_mode_get_plane *plane_resp = data;
	struct drm_mode_object *obj;
	struct drm_plane *plane;
	uint32_t __user *format_ptr;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, plane_resp->plane_id,
				   DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	plane = obj_to_plane(obj);

	if (plane->crtc)
		plane_resp->crtc_id = plane->crtc->base.id;
	else
		plane_resp->crtc_id = 0;

	if (plane->fb)
		plane_resp->fb_id = plane->fb->base.id;
	else
		plane_resp->fb_id = 0;

	plane_resp->plane_id = plane->base.id;
	plane_resp->possible_crtcs = plane->possible_crtcs;
	plane_resp->gamma_size = 0;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if (plane->format_count &&
	    (plane_resp->count_format_types >= plane->format_count)) {
		format_ptr = (uint32_t __user *)(unsigned long)plane_resp->format_type_ptr;
		if (copy_to_user(format_ptr,
				 plane->format_types,
				 sizeof(uint32_t) * plane->format_count)) {
			ret = -EFAULT;
			goto out;
		}
	}
	plane_resp->count_format_types = plane->format_count;

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_setplane - set up or tear down an plane
 * @@dev: DRM device
 * @@data: ioctl data*
 * @@file_priv: DRM file info
 *
 * Set plane info, including placement, fb, scaling, and other factors.
 * Or pass a NULL fb to disable.
 */
int drm_mode_setplane(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	struct drm_mode_set_plane *plane_req = data;
	struct drm_mode_object *obj;
	struct drm_plane *plane;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb = NULL, *old_fb = NULL;
	int ret = 0;
	unsigned int fb_width, fb_height;
	int i;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	/*
	 * First, find the plane, crtc, and fb objects.  If not available,
	 * we don't bother to call the driver.
	 */
	obj = drm_mode_object_find(dev, plane_req->plane_id,
				   DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown plane ID %d\n",
			      plane_req->plane_id);
		return -ENOENT;
	}
	plane = obj_to_plane(obj);

	/* No fb means shut it down */
	if (!plane_req->fb_id) {
		drm_modeset_lock_all(dev);
		old_fb = plane->fb;
		plane->funcs->disable_plane(plane);
		plane->crtc = NULL;
		plane->fb = NULL;
		drm_modeset_unlock_all(dev);
		goto out;
	}

	obj = drm_mode_object_find(dev, plane_req->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown crtc ID %d\n",
			      plane_req->crtc_id);
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);

	fb = drm_framebuffer_lookup(dev, plane_req->fb_id);
	if (!fb) {
		DRM_DEBUG_KMS("Unknown framebuffer ID %d\n",
			      plane_req->fb_id);
		ret = -ENOENT;
		goto out;
	}

	/* Check whether this plane supports the fb pixel format. */
	for (i = 0; i < plane->format_count; i++)
		if (fb->pixel_format == plane->format_types[i])
			break;
	if (i == plane->format_count) {
		DRM_DEBUG_KMS("Invalid pixel format %s\n",
			      drm_get_format_name(fb->pixel_format));
		ret = -EINVAL;
		goto out;
	}

	fb_width = fb->width << 16;
	fb_height = fb->height << 16;

	/* Make sure source coordinates are inside the fb. */
	if (plane_req->src_w > fb_width ||
	    plane_req->src_x > fb_width - plane_req->src_w ||
	    plane_req->src_h > fb_height ||
	    plane_req->src_y > fb_height - plane_req->src_h) {
		DRM_DEBUG_KMS("Invalid source coordinates "
			      "%u.%06ux%u.%06u+%u.%06u+%u.%06u\n",
			      plane_req->src_w >> 16,
			      ((plane_req->src_w & 0xffff) * 15625) >> 10,
			      plane_req->src_h >> 16,
			      ((plane_req->src_h & 0xffff) * 15625) >> 10,
			      plane_req->src_x >> 16,
			      ((plane_req->src_x & 0xffff) * 15625) >> 10,
			      plane_req->src_y >> 16,
			      ((plane_req->src_y & 0xffff) * 15625) >> 10);
		ret = -ENOSPC;
		goto out;
	}

	/* Give drivers some help against integer overflows */
	if (plane_req->crtc_w > INT_MAX ||
	    plane_req->crtc_x > INT_MAX - (int32_t) plane_req->crtc_w ||
	    plane_req->crtc_h > INT_MAX ||
	    plane_req->crtc_y > INT_MAX - (int32_t) plane_req->crtc_h) {
		DRM_DEBUG_KMS("Invalid CRTC coordinates %ux%u+%d+%d\n",
			      plane_req->crtc_w, plane_req->crtc_h,
			      plane_req->crtc_x, plane_req->crtc_y);
		ret = -ERANGE;
		goto out;
	}

	drm_modeset_lock_all(dev);
	ret = plane->funcs->update_plane(plane, crtc, fb,
					 plane_req->crtc_x, plane_req->crtc_y,
					 plane_req->crtc_w, plane_req->crtc_h,
					 plane_req->src_x, plane_req->src_y,
					 plane_req->src_w, plane_req->src_h);
	if (!ret) {
		old_fb = plane->fb;
		plane->crtc = crtc;
		plane->fb = fb;
		fb = NULL;
	}
	drm_modeset_unlock_all(dev);

out:
	if (fb)
		drm_framebuffer_unreference(fb);
	if (old_fb)
		drm_framebuffer_unreference(old_fb);

	return ret;
}

/**
 * drm_mode_set_config_internal - helper to call ->set_config
 * @@set: modeset config to set
 *
 * This is a little helper to wrap internal calls to the ->set_config driver
 * interface. The only thing it adds is correct refcounting dance.
 */
int drm_mode_set_config_internal(struct drm_mode_set *set)
{
	struct drm_crtc *crtc = set->crtc;
	struct drm_framebuffer *fb;
	struct drm_crtc *tmp;
	int ret;

	/*
	 * NOTE: ->set_config can also disable other crtcs (if we steal all
	 * connectors from it), hence we need to refcount the fbs across all
	 * crtcs. Atomic modeset will have saner semantics ...
	 */
	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head)
		tmp->old_fb = tmp->fb;

	fb = set->fb;

	ret = crtc->funcs->set_config(set);
	if (ret == 0) {
		/* crtc->fb must be updated by ->set_config, enforces this. */
		WARN_ON(fb != crtc->fb);
	}

	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head) {
		if (tmp->fb)
			drm_framebuffer_reference(tmp->fb);
		if (tmp->old_fb)
			drm_framebuffer_unreference(tmp->old_fb);
	}

	return ret;
}
EXPORT_SYMBOL(drm_mode_set_config_internal);

/*
 * Checks that the framebuffer is big enough for the CRTC viewport
 * (x, y, hdisplay, vdisplay)
 */
static int drm_crtc_check_viewport(const struct drm_crtc *crtc,
				   int x, int y,
				   const struct drm_display_mode *mode,
				   const struct drm_framebuffer *fb)

{
	int hdisplay, vdisplay;

	hdisplay = mode->hdisplay;
	vdisplay = mode->vdisplay;

	if (drm_mode_is_stereo(mode)) {
		struct drm_display_mode adjusted = *mode;

		drm_mode_set_crtcinfo(&adjusted, CRTC_STEREO_DOUBLE);
		hdisplay = adjusted.crtc_hdisplay;
		vdisplay = adjusted.crtc_vdisplay;
	}

	if (crtc->invert_dimensions) {
		int tmp = hdisplay;
		hdisplay = vdisplay;
		vdisplay = tmp;
	}

	if (hdisplay > fb->width ||
	    vdisplay > fb->height ||
	    x > fb->width - hdisplay ||
	    y > fb->height - vdisplay) {
		DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
			      fb->width, fb->height, hdisplay, vdisplay, x, y,
			      crtc->invert_dimensions ? " (inverted)" : "");
		return -ENOSPC;
	}

	return 0;
}

/**
 * drm_mode_setcrtc - set CRTC configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Build a new CRTC configuration based on user request.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_setcrtc(struct drm_device *dev, void *data,
		     struct drm_file *file_priv)
{
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_mode_crtc *crtc_req = data;
	struct drm_mode_object *obj;
	struct drm_crtc *crtc;
	struct drm_connector **connector_set = NULL, *connector;
	struct drm_framebuffer *fb = NULL;
	struct drm_display_mode *mode = NULL;
	struct drm_mode_set set;
	uint32_t __user *set_connectors_ptr;
	int ret;
	int i;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	/*
	 * Universal plane src offsets are only 16.16, prevent havoc for
	 * drivers using universal plane code internally.
	 */
	if (crtc_req->x & 0xffff0000 || crtc_req->y & 0xffff0000)
		return -ERANGE;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, crtc_req->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", crtc_req->crtc_id);
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);
	DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);

	if (crtc_req->mode_valid) {
		/* If we have a mode we need a framebuffer. */
		/* If we pass -1, set the mode with the currently bound fb */
		if (crtc_req->fb_id == -1) {
			if (!crtc->fb) {
				DRM_DEBUG_KMS("CRTC doesn't have current FB\n");
				ret = -EINVAL;
				goto out;
			}
			fb = crtc->fb;
			/* Make refcounting symmetric with the lookup path. */
			drm_framebuffer_reference(fb);
		} else {
			fb = drm_framebuffer_lookup(dev, crtc_req->fb_id);
			if (!fb) {
				DRM_DEBUG_KMS("Unknown FB ID%d\n",
						crtc_req->fb_id);
				ret = -ENOENT;
				goto out;
			}
		}

		mode = drm_mode_create(dev);
		if (!mode) {
			ret = -ENOMEM;
			goto out;
		}

		ret = drm_crtc_convert_umode(mode, &crtc_req->mode);
		if (ret) {
			DRM_DEBUG_KMS("Invalid mode\n");
			goto out;
		}

		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);

		ret = drm_crtc_check_viewport(crtc, crtc_req->x, crtc_req->y,
					      mode, fb);
		if (ret)
			goto out;

	}

	if (crtc_req->count_connectors == 0 && mode) {
		DRM_DEBUG_KMS("Count connectors is 0 but mode set\n");
		ret = -EINVAL;
		goto out;
	}

	if (crtc_req->count_connectors > 0 && (!mode || !fb)) {
		DRM_DEBUG_KMS("Count connectors is %d but no mode or fb set\n",
			  crtc_req->count_connectors);
		ret = -EINVAL;
		goto out;
	}

	if (crtc_req->count_connectors > 0) {
		u32 out_id;

		/* Avoid unbounded kernel memory allocation */
		if (crtc_req->count_connectors > config->num_connector) {
			ret = -EINVAL;
			goto out;
		}

		connector_set = kmalloc(crtc_req->count_connectors *
					sizeof(struct drm_connector *),
					GFP_KERNEL);
		if (!connector_set) {
			ret = -ENOMEM;
			goto out;
		}

		for (i = 0; i < crtc_req->count_connectors; i++) {
			set_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;
			if (get_user(out_id, &set_connectors_ptr[i])) {
				ret = -EFAULT;
				goto out;
			}

			obj = drm_mode_object_find(dev, out_id,
						   DRM_MODE_OBJECT_CONNECTOR);
			if (!obj) {
				DRM_DEBUG_KMS("Connector id %d unknown\n",
						out_id);
				ret = -ENOENT;
				goto out;
			}
			connector = obj_to_connector(obj);
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
					connector->base.id,
					drm_get_connector_name(connector));

			connector_set[i] = connector;
		}
	}

	set.crtc = crtc;
	set.x = crtc_req->x;
	set.y = crtc_req->y;
	set.mode = mode;
	set.connectors = connector_set;
	set.num_connectors = crtc_req->count_connectors;
	set.fb = fb;
	ret = drm_mode_set_config_internal(&set);

out:
	if (fb)
		drm_framebuffer_unreference(fb);

	kfree(connector_set);
	drm_mode_destroy(dev, mode);
	drm_modeset_unlock_all(dev);
	return ret;
}

static int drm_mode_cursor_common(struct drm_device *dev,
				  struct drm_mode_cursor2 *req,
				  struct drm_file *file_priv)
{
	struct drm_mode_object *obj;
	struct drm_crtc *crtc;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if (!req->flags || (~DRM_MODE_CURSOR_FLAGS & req->flags))
		return -EINVAL;

	obj = drm_mode_object_find(dev, req->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", req->crtc_id);
		return -ENOENT;
	}
	crtc = obj_to_crtc(obj);

	mutex_lock(&crtc->mutex);
	if (req->flags & DRM_MODE_CURSOR_BO) {
		if (!crtc->funcs->cursor_set && !crtc->funcs->cursor_set2) {
			ret = -ENXIO;
			goto out;
		}
		/* Turns off the cursor if handle is 0 */
		if (crtc->funcs->cursor_set2)
			ret = crtc->funcs->cursor_set2(crtc, file_priv, req->handle,
						      req->width, req->height, req->hot_x, req->hot_y);
		else
			ret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,
						      req->width, req->height);
	}

	if (req->flags & DRM_MODE_CURSOR_MOVE) {
		if (crtc->funcs->cursor_move) {
			ret = crtc->funcs->cursor_move(crtc, req->x, req->y);
		} else {
			ret = -EFAULT;
			goto out;
		}
	}
out:
	mutex_unlock(&crtc->mutex);

	return ret;

}
int drm_mode_cursor_ioctl(struct drm_device *dev,
			void *data, struct drm_file *file_priv)
{
	struct drm_mode_cursor *req = data;
	struct drm_mode_cursor2 new_req;

	memcpy(&new_req, req, sizeof(struct drm_mode_cursor));
	new_req.hot_x = new_req.hot_y = 0;

	return drm_mode_cursor_common(dev, &new_req, file_priv);
}

int drm_mode_cursor2_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_mode_cursor2 *req = data;
	return drm_mode_cursor_common(dev, req, file_priv);
}

/* Original addfb only supported RGB formats, so figure out which one */
uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth)
{
	uint32_t fmt;

	switch (bpp) {
	case 8:
		fmt = DRM_FORMAT_C8;
		break;
	case 16:
		if (depth == 15)
			fmt = DRM_FORMAT_XRGB1555;
		else
			fmt = DRM_FORMAT_RGB565;
		break;
	case 24:
		fmt = DRM_FORMAT_RGB888;
		break;
	case 32:
		if (depth == 24)
			fmt = DRM_FORMAT_XRGB8888;
		else if (depth == 30)
			fmt = DRM_FORMAT_XRGB2101010;
		else
			fmt = DRM_FORMAT_ARGB8888;
		break;
	default:
		DRM_ERROR("bad bpp, assuming x8r8g8b8 pixel format\n");
		fmt = DRM_FORMAT_XRGB8888;
		break;
	}

	return fmt;
}
EXPORT_SYMBOL(drm_mode_legacy_fb_format);

/**
 * drm_mode_addfb - add an FB to the graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Add a new FB to the specified CRTC, given a user request.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_addfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd *or = data;
	struct drm_mode_fb_cmd2 r = {};
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_framebuffer *fb;
	int ret = 0;

	/* Use new struct with format internally */
	r.fb_id = or->fb_id;
	r.width = or->width;
	r.height = or->height;
	r.pitches[0] = or->pitch;
	r.pixel_format = drm_mode_legacy_fb_format(or->bpp, or->depth);
	r.handles[0] = or->handle;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if ((config->min_width > r.width) || (r.width > config->max_width))
		return -EINVAL;

	if ((config->min_height > r.height) || (r.height > config->max_height))
		return -EINVAL;

	fb = dev->mode_config.funcs->fb_create(dev, file_priv, &r);
	if (IS_ERR(fb)) {
		DRM_DEBUG_KMS("could not create framebuffer\n");
		return PTR_ERR(fb);
	}

	mutex_lock(&file_priv->fbs_lock);
	or->fb_id = fb->base.id;
	list_add(&fb->filp_head, &file_priv->fbs);
	DRM_DEBUG_KMS("[FB:%d]\n", fb->base.id);
	mutex_unlock(&file_priv->fbs_lock);

	return ret;
}

static int format_check(const struct drm_mode_fb_cmd2 *r)
{
	uint32_t format = r->pixel_format & ~DRM_FORMAT_BIG_ENDIAN;

	switch (format) {
	case DRM_FORMAT_C8:
	case DRM_FORMAT_RGB332:
	case DRM_FORMAT_BGR233:
	case DRM_FORMAT_XRGB4444:
	case DRM_FORMAT_XBGR4444:
	case DRM_FORMAT_RGBX4444:
	case DRM_FORMAT_BGRX4444:
	case DRM_FORMAT_ARGB4444:
	case DRM_FORMAT_ABGR4444:
	case DRM_FORMAT_RGBA4444:
	case DRM_FORMAT_BGRA4444:
	case DRM_FORMAT_XRGB1555:
	case DRM_FORMAT_XBGR1555:
	case DRM_FORMAT_RGBX5551:
	case DRM_FORMAT_BGRX5551:
	case DRM_FORMAT_ARGB1555:
	case DRM_FORMAT_ABGR1555:
	case DRM_FORMAT_RGBA5551:
	case DRM_FORMAT_BGRA5551:
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_BGR565:
	case DRM_FORMAT_RGB888:
	case DRM_FORMAT_BGR888:
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_RGBX8888:
	case DRM_FORMAT_BGRX8888:
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_RGBA8888:
	case DRM_FORMAT_BGRA8888:
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_RGBX1010102:
	case DRM_FORMAT_BGRX1010102:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_ABGR2101010:
	case DRM_FORMAT_RGBA1010102:
	case DRM_FORMAT_BGRA1010102:
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_AYUV:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 0;
	default:
		DRM_DEBUG_KMS("invalid pixel format %s\n",
			      drm_get_format_name(r->pixel_format));
		return -EINVAL;
	}
}

static int framebuffer_check(const struct drm_mode_fb_cmd2 *r)
{
	int ret, hsub, vsub, num_planes, i;

	ret = format_check(r);
	if (ret) {
		DRM_DEBUG_KMS("bad framebuffer format %s\n",
			      drm_get_format_name(r->pixel_format));
		return ret;
	}

	hsub = drm_format_horz_chroma_subsampling(r->pixel_format);
	vsub = drm_format_vert_chroma_subsampling(r->pixel_format);
	num_planes = drm_format_num_planes(r->pixel_format);

	if (r->width == 0 || r->width % hsub) {
		DRM_DEBUG_KMS("bad framebuffer width %u\n", r->height);
		return -EINVAL;
	}

	if (r->height == 0 || r->height % vsub) {
		DRM_DEBUG_KMS("bad framebuffer height %u\n", r->height);
		return -EINVAL;
	}

	for (i = 0; i < num_planes; i++) {
		unsigned int width = r->width / (i != 0 ? hsub : 1);
		unsigned int height = r->height / (i != 0 ? vsub : 1);
		unsigned int cpp = drm_format_plane_cpp(r->pixel_format, i);

		if (!r->handles[i]) {
			DRM_DEBUG_KMS("no buffer object handle for plane %d\n", i);
			return -EINVAL;
		}

		if ((uint64_t) width * cpp > UINT_MAX)
			return -ERANGE;

		if ((uint64_t) height * r->pitches[i] + r->offsets[i] > UINT_MAX)
			return -ERANGE;

		if (r->pitches[i] < width * cpp) {
			DRM_DEBUG_KMS("bad pitch %u for plane %d\n", r->pitches[i], i);
			return -EINVAL;
		}
	}

	return 0;
}

/**
 * drm_mode_addfb2 - add an FB to the graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Add a new FB to the specified CRTC, given a user request with format.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_addfb2(struct drm_device *dev,
		    void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd2 *r = data;
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_framebuffer *fb;
	int ret;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if (r->flags & ~DRM_MODE_FB_INTERLACED) {
		DRM_DEBUG_KMS("bad framebuffer flags 0x%08x\n", r->flags);
		return -EINVAL;
	}

	if ((config->min_width > r->width) || (r->width > config->max_width)) {
		DRM_DEBUG_KMS("bad framebuffer width %d, should be >= %d && <= %d\n",
			  r->width, config->min_width, config->max_width);
		return -EINVAL;
	}
	if ((config->min_height > r->height) || (r->height > config->max_height)) {
		DRM_DEBUG_KMS("bad framebuffer height %d, should be >= %d && <= %d\n",
			  r->height, config->min_height, config->max_height);
		return -EINVAL;
	}

	ret = framebuffer_check(r);
	if (ret)
		return ret;

	fb = dev->mode_config.funcs->fb_create(dev, file_priv, r);
	if (IS_ERR(fb)) {
		DRM_DEBUG_KMS("could not create framebuffer\n");
		return PTR_ERR(fb);
	}

	mutex_lock(&file_priv->fbs_lock);
	r->fb_id = fb->base.id;
	list_add(&fb->filp_head, &file_priv->fbs);
	DRM_DEBUG_KMS("[FB:%d]\n", fb->base.id);
	mutex_unlock(&file_priv->fbs_lock);


	return ret;
}

/**
 * drm_mode_rmfb - remove an FB from the configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Remove the FB specified by the user.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_rmfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_framebuffer *fb = NULL;
	struct drm_framebuffer *fbl = NULL;
	uint32_t *id = data;
	int found = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&file_priv->fbs_lock);
	mutex_lock(&dev->mode_config.fb_lock);
	fb = __drm_framebuffer_lookup(dev, *id);
	if (!fb)
		goto fail_lookup;

	list_for_each_entry(fbl, &file_priv->fbs, filp_head)
		if (fb == fbl)
			found = 1;
	if (!found)
		goto fail_lookup;

	/* Mark fb as reaped, we still have a ref from fpriv->fbs. */
	__drm_framebuffer_unregister(dev, fb);

	list_del_init(&fb->filp_head);
	mutex_unlock(&dev->mode_config.fb_lock);
	mutex_unlock(&file_priv->fbs_lock);

	drm_framebuffer_remove(fb);

	return 0;

fail_lookup:
	mutex_unlock(&dev->mode_config.fb_lock);
	mutex_unlock(&file_priv->fbs_lock);

	return -ENOENT;
}

/**
 * drm_mode_getfb - get FB info
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Lookup the FB given its ID and return info about it.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_getfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd *r = data;
	struct drm_framebuffer *fb;
	int ret;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	fb = drm_framebuffer_lookup(dev, r->fb_id);
	if (!fb)
		return -ENOENT;

	r->height = fb->height;
	r->width = fb->width;
	r->depth = fb->depth;
	r->bpp = fb->bits_per_pixel;
	r->pitch = fb->pitches[0];
	if (fb->funcs->create_handle) {
		if (file_priv->is_master || capable(CAP_SYS_ADMIN)) {
			ret = fb->funcs->create_handle(fb, file_priv,
						       &r->handle);
		} else {
			/* GET_FB() is an unprivileged ioctl so we must not
			 * return a buffer-handle to non-master processes! For
			 * backwards-compatibility reasons, we cannot make
			 * GET_FB() privileged, so just return an invalid handle
			 * for non-masters. */
			r->handle = 0;
			ret = 0;
		}
	} else {
		ret = -ENODEV;
	}

	drm_framebuffer_unreference(fb);

	return ret;
}

int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_clip_rect __user *clips_ptr;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = data;
	struct drm_framebuffer *fb;
	unsigned flags;
	int num_clips;
	int ret;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	fb = drm_framebuffer_lookup(dev, r->fb_id);
	if (!fb)
		return -ENOENT;

	num_clips = r->num_clips;
	clips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;

	if (!num_clips != !clips_ptr) {
		ret = -EINVAL;
		goto out_err1;
	}

	flags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;

	/* If userspace annotates copy, clips must come in pairs */
	if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {
		ret = -EINVAL;
		goto out_err1;
	}

	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
		if (!clips) {
			ret = -ENOMEM;
			goto out_err1;
		}

		ret = copy_from_user(clips, clips_ptr,
				     num_clips * sizeof(*clips));
		if (ret) {
			ret = -EFAULT;
			goto out_err2;
		}
	}

	if (fb->funcs->dirty) {
		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
				       clips, num_clips);
	} else {
		ret = -ENOSYS;
	}

out_err2:
	kfree(clips);
out_err1:
	drm_framebuffer_unreference(fb);

	return ret;
}


/**
 * drm_fb_release - remove and free the FBs on this file
 * @@priv: drm file for the ioctl
 *
 * Destroy all the FBs associated with @@filp.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
void drm_fb_release(struct drm_device *dev, struct drm_file *priv)
{
	struct drm_framebuffer *fb, *tfb;

	mutex_lock(&priv->fbs_lock);
	list_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {

		mutex_lock(&dev->mode_config.fb_lock);
		/* Mark fb as reaped, we still have a ref from fpriv->fbs. */
		__drm_framebuffer_unregister(dev, fb);
		mutex_unlock(&dev->mode_config.fb_lock);

		list_del_init(&fb->filp_head);

		/* This will also drop the fpriv->fbs reference. */
		drm_framebuffer_remove(fb);
	}
	mutex_unlock(&priv->fbs_lock);
}

struct drm_property *drm_property_create(struct drm_device *dev, int flags,
					 const char *name, int num_values)
{
	struct drm_property *property = NULL;
	int ret;

	property = kzalloc(sizeof(struct drm_property), GFP_KERNEL);
	if (!property)
		return NULL;

	if (num_values) {
		property->values = kzalloc(sizeof(uint64_t)*num_values, GFP_KERNEL);
		if (!property->values)
			goto fail;
	}

	ret = drm_mode_object_get(dev, &property->base, DRM_MODE_OBJECT_PROPERTY);
	if (ret)
		goto fail;

	property->flags = flags;
	property->num_values = num_values;
	INIT_LIST_HEAD(&property->enum_blob_list);

	if (name) {
		strncpy(property->name, name, DRM_PROP_NAME_LEN);
		property->name[DRM_PROP_NAME_LEN-1] = '\0';
	}

	list_add_tail(&property->head, &dev->mode_config.property_list);
	return property;
fail:
	kfree(property->values);
	kfree(property);
	return NULL;
}
EXPORT_SYMBOL(drm_property_create);

struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
					 const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_values)
{
	struct drm_property *property;
	int i, ret;

	flags |= DRM_MODE_PROP_ENUM;

	property = drm_property_create(dev, flags, name, num_values);
	if (!property)
		return NULL;

	for (i = 0; i < num_values; i++) {
		ret = drm_property_add_enum(property, i,
				      props[i].type,
				      props[i].name);
		if (ret) {
			drm_property_destroy(dev, property);
			return NULL;
		}
	}

	return property;
}
EXPORT_SYMBOL(drm_property_create_enum);

struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
					 int flags, const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_values)
{
	struct drm_property *property;
	int i, ret;

	flags |= DRM_MODE_PROP_BITMASK;

	property = drm_property_create(dev, flags, name, num_values);
	if (!property)
		return NULL;

	for (i = 0; i < num_values; i++) {
		ret = drm_property_add_enum(property, i,
				      props[i].type,
				      props[i].name);
		if (ret) {
			drm_property_destroy(dev, property);
			return NULL;
		}
	}

	return property;
}
EXPORT_SYMBOL(drm_property_create_bitmask);

struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
					 const char *name,
					 uint64_t min, uint64_t max)
{
	struct drm_property *property;

	flags |= DRM_MODE_PROP_RANGE;

	property = drm_property_create(dev, flags, name, 2);
	if (!property)
		return NULL;

	property->values[0] = min;
	property->values[1] = max;

	return property;
}
EXPORT_SYMBOL(drm_property_create_range);

int drm_property_add_enum(struct drm_property *property, int index,
			  uint64_t value, const char *name)
{
	struct drm_property_enum *prop_enum;

	if (!(property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)))
		return -EINVAL;

	/*
	 * Bitmask enum properties have the additional constraint of values
	 * from 0 to 63
	 */
	if ((property->flags & DRM_MODE_PROP_BITMASK) && (value > 63))
		return -EINVAL;

	if (!list_empty(&property->enum_blob_list)) {
		list_for_each_entry(prop_enum, &property->enum_blob_list, head) {
			if (prop_enum->value == value) {
				strncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);
				prop_enum->name[DRM_PROP_NAME_LEN-1] = '\0';
				return 0;
			}
		}
	}

	prop_enum = kzalloc(sizeof(struct drm_property_enum), GFP_KERNEL);
	if (!prop_enum)
		return -ENOMEM;

	strncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);
	prop_enum->name[DRM_PROP_NAME_LEN-1] = '\0';
	prop_enum->value = value;

	property->values[index] = value;
	list_add_tail(&prop_enum->head, &property->enum_blob_list);
	return 0;
}
EXPORT_SYMBOL(drm_property_add_enum);

void drm_property_destroy(struct drm_device *dev, struct drm_property *property)
{
	struct drm_property_enum *prop_enum, *pt;

	list_for_each_entry_safe(prop_enum, pt, &property->enum_blob_list, head) {
		list_del(&prop_enum->head);
		kfree(prop_enum);
	}

	if (property->num_values)
		kfree(property->values);
	drm_mode_object_put(dev, &property->base);
	list_del(&property->head);
	kfree(property);
}
EXPORT_SYMBOL(drm_property_destroy);

void drm_object_attach_property(struct drm_mode_object *obj,
				struct drm_property *property,
				uint64_t init_val)
{
	int count = obj->properties->count;

	if (count == DRM_OBJECT_MAX_PROPERTY) {
		WARN(1, "Failed to attach object property (type: 0x%x). Please "
			"increase DRM_OBJECT_MAX_PROPERTY by 1 for each time "
			"you see this message on the same object type.\n",
			obj->type);
		return;
	}

	obj->properties->ids[count] = property->base.id;
	obj->properties->values[count] = init_val;
	obj->properties->count++;
}
EXPORT_SYMBOL(drm_object_attach_property);

int drm_object_property_set_value(struct drm_mode_object *obj,
				  struct drm_property *property, uint64_t val)
{
	int i;

	for (i = 0; i < obj->properties->count; i++) {
		if (obj->properties->ids[i] == property->base.id) {
			obj->properties->values[i] = val;
			return 0;
		}
	}

	return -EINVAL;
}
EXPORT_SYMBOL(drm_object_property_set_value);

int drm_object_property_get_value(struct drm_mode_object *obj,
				  struct drm_property *property, uint64_t *val)
{
	int i;

	for (i = 0; i < obj->properties->count; i++) {
		if (obj->properties->ids[i] == property->base.id) {
			*val = obj->properties->values[i];
			return 0;
		}
	}

	return -EINVAL;
}
EXPORT_SYMBOL(drm_object_property_get_value);

int drm_mode_getproperty_ioctl(struct drm_device *dev,
			       void *data, struct drm_file *file_priv)
{
	struct drm_mode_object *obj;
	struct drm_mode_get_property *out_resp = data;
	struct drm_property *property;
	int enum_count = 0;
	int blob_count = 0;
	int value_count = 0;
	int ret = 0, i;
	int copied;
	struct drm_property_enum *prop_enum;
	struct drm_mode_property_enum __user *enum_ptr;
	struct drm_property_blob *prop_blob;
	uint32_t __user *blob_id_ptr;
	uint64_t __user *values_ptr;
	uint32_t __user *blob_length_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);
	if (!obj) {
		ret = -ENOENT;
		goto done;
	}
	property = obj_to_property(obj);

	if (property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)) {
		list_for_each_entry(prop_enum, &property->enum_blob_list, head)
			enum_count++;
	} else if (property->flags & DRM_MODE_PROP_BLOB) {
		list_for_each_entry(prop_blob, &property->enum_blob_list, head)
			blob_count++;
	}

	value_count = property->num_values;

	strncpy(out_resp->name, property->name, DRM_PROP_NAME_LEN);
	out_resp->name[DRM_PROP_NAME_LEN-1] = 0;
	out_resp->flags = property->flags;

	if ((out_resp->count_values >= value_count) && value_count) {
		values_ptr = (uint64_t __user *)(unsigned long)out_resp->values_ptr;
		for (i = 0; i < value_count; i++) {
			if (copy_to_user(values_ptr + i, &property->values[i], sizeof(uint64_t))) {
				ret = -EFAULT;
				goto done;
			}
		}
	}
	out_resp->count_values = value_count;

	if (property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)) {
		if ((out_resp->count_enum_blobs >= enum_count) && enum_count) {
			copied = 0;
			enum_ptr = (struct drm_mode_property_enum __user *)(unsigned long)out_resp->enum_blob_ptr;
			list_for_each_entry(prop_enum, &property->enum_blob_list, head) {

				if (copy_to_user(&enum_ptr[copied].value, &prop_enum->value, sizeof(uint64_t))) {
					ret = -EFAULT;
					goto done;
				}

				if (copy_to_user(&enum_ptr[copied].name,
						 &prop_enum->name, DRM_PROP_NAME_LEN)) {
					ret = -EFAULT;
					goto done;
				}
				copied++;
			}
		}
		out_resp->count_enum_blobs = enum_count;
	}

	if (property->flags & DRM_MODE_PROP_BLOB) {
		if ((out_resp->count_enum_blobs >= blob_count) && blob_count) {
			copied = 0;
			blob_id_ptr = (uint32_t __user *)(unsigned long)out_resp->enum_blob_ptr;
			blob_length_ptr = (uint32_t __user *)(unsigned long)out_resp->values_ptr;

			list_for_each_entry(prop_blob, &property->enum_blob_list, head) {
				if (put_user(prop_blob->base.id, blob_id_ptr + copied)) {
					ret = -EFAULT;
					goto done;
				}

				if (put_user(prop_blob->length, blob_length_ptr + copied)) {
					ret = -EFAULT;
					goto done;
				}

				copied++;
			}
		}
		out_resp->count_enum_blobs = blob_count;
	}
done:
	drm_modeset_unlock_all(dev);
	return ret;
}

static struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,
							  void *data)
{
	struct drm_property_blob *blob;
	int ret;

	if (!length || !data)
		return NULL;

	blob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);
	if (!blob)
		return NULL;

	ret = drm_mode_object_get(dev, &blob->base, DRM_MODE_OBJECT_BLOB);
	if (ret) {
		kfree(blob);
		return NULL;
	}

	blob->length = length;

	memcpy(blob->data, data, length);

	list_add_tail(&blob->head, &dev->mode_config.property_blob_list);
	return blob;
}

static void drm_property_destroy_blob(struct drm_device *dev,
			       struct drm_property_blob *blob)
{
	drm_mode_object_put(dev, &blob->base);
	list_del(&blob->head);
	kfree(blob);
}

int drm_mode_getblob_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_mode_object *obj;
	struct drm_mode_get_blob *out_resp = data;
	struct drm_property_blob *blob;
	int ret = 0;
	void __user *blob_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, out_resp->blob_id, DRM_MODE_OBJECT_BLOB);
	if (!obj) {
		ret = -ENOENT;
		goto done;
	}
	blob = obj_to_blob(obj);

	if (out_resp->length == blob->length) {
		blob_ptr = (void __user *)(unsigned long)out_resp->data;
		if (copy_to_user(blob_ptr, blob->data, blob->length)){
			ret = -EFAULT;
			goto done;
		}
	}
	out_resp->length = blob->length;

done:
	drm_modeset_unlock_all(dev);
	return ret;
}

int drm_mode_connector_update_edid_property(struct drm_connector *connector,
					    struct edid *edid)
{
	struct drm_device *dev = connector->dev;
	int ret, size;

	if (connector->edid_blob_ptr)
		drm_property_destroy_blob(dev, connector->edid_blob_ptr);

	/* Delete edid, when there is none. */
	if (!edid) {
		connector->edid_blob_ptr = NULL;
		ret = drm_object_property_set_value(&connector->base, dev->mode_config.edid_property, 0);
		return ret;
	}

	size = EDID_LENGTH * (1 + edid->extensions);
	connector->edid_blob_ptr = drm_property_create_blob(connector->dev,
							    size, edid);
	if (!connector->edid_blob_ptr)
		return -EINVAL;

	ret = drm_object_property_set_value(&connector->base,
					       dev->mode_config.edid_property,
					       connector->edid_blob_ptr->base.id);

	return ret;
}
EXPORT_SYMBOL(drm_mode_connector_update_edid_property);

static bool drm_property_change_is_valid(struct drm_property *property,
					 uint64_t value)
{
	if (property->flags & DRM_MODE_PROP_IMMUTABLE)
		return false;
	if (property->flags & DRM_MODE_PROP_RANGE) {
		if (value < property->values[0] || value > property->values[1])
			return false;
		return true;
	} else if (property->flags & DRM_MODE_PROP_BITMASK) {
		int i;
		uint64_t valid_mask = 0;
		for (i = 0; i < property->num_values; i++)
			valid_mask |= (1ULL << property->values[i]);
		return !(value & ~valid_mask);
	} else if (property->flags & DRM_MODE_PROP_BLOB) {
		/* Only the driver knows */
		return true;
	} else {
		int i;
		for (i = 0; i < property->num_values; i++)
			if (property->values[i] == value)
				return true;
		return false;
	}
}

int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
				       void *data, struct drm_file *file_priv)
{
	struct drm_mode_connector_set_property *conn_set_prop = data;
	struct drm_mode_obj_set_property obj_set_prop = {
		.value = conn_set_prop->value,
		.prop_id = conn_set_prop->prop_id,
		.obj_id = conn_set_prop->connector_id,
		.obj_type = DRM_MODE_OBJECT_CONNECTOR
	};

	/* It does all the locking and checking we need */
	return drm_mode_obj_set_property_ioctl(dev, &obj_set_prop, file_priv);
}

static int drm_mode_connector_set_obj_prop(struct drm_mode_object *obj,
					   struct drm_property *property,
					   uint64_t value)
{
	int ret = -EINVAL;
	struct drm_connector *connector = obj_to_connector(obj);

	/* Do DPMS ourselves */
	if (property == connector->dev->mode_config.dpms_property) {
		if (connector->funcs->dpms)
			(*connector->funcs->dpms)(connector, (int)value);
		ret = 0;
	} else if (connector->funcs->set_property)
		ret = connector->funcs->set_property(connector, property, value);

	/* store the property value if successful */
	if (!ret)
		drm_object_property_set_value(&connector->base, property, value);
	return ret;
}

static int drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,
				      struct drm_property *property,
				      uint64_t value)
{
	int ret = -EINVAL;
	struct drm_crtc *crtc = obj_to_crtc(obj);

	if (crtc->funcs->set_property)
		ret = crtc->funcs->set_property(crtc, property, value);
	if (!ret)
		drm_object_property_set_value(obj, property, value);

	return ret;
}

static int drm_mode_plane_set_obj_prop(struct drm_mode_object *obj,
				      struct drm_property *property,
				      uint64_t value)
{
	int ret = -EINVAL;
	struct drm_plane *plane = obj_to_plane(obj);

	if (plane->funcs->set_property)
		ret = plane->funcs->set_property(plane, property, value);
	if (!ret)
		drm_object_property_set_value(obj, property, value);

	return ret;
}

int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
				      struct drm_file *file_priv)
{
	struct drm_mode_obj_get_properties *arg = data;
	struct drm_mode_object *obj;
	int ret = 0;
	int i;
	int copied = 0;
	int props_count = 0;
	uint32_t __user *props_ptr;
	uint64_t __user *prop_values_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);

	obj = drm_mode_object_find(dev, arg->obj_id, arg->obj_type);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	if (!obj->properties) {
		ret = -EINVAL;
		goto out;
	}

	props_count = obj->properties->count;

	/* This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it. */
	if ((arg->count_props >= props_count) && props_count) {
		copied = 0;
		props_ptr = (uint32_t __user *)(unsigned long)(arg->props_ptr);
		prop_values_ptr = (uint64_t __user *)(unsigned long)
				  (arg->prop_values_ptr);
		for (i = 0; i < props_count; i++) {
			if (put_user(obj->properties->ids[i],
				     props_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
			if (put_user(obj->properties->values[i],
				     prop_values_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	arg->count_props = props_count;
out:
	drm_modeset_unlock_all(dev);
	return ret;
}

int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
				    struct drm_file *file_priv)
{
	struct drm_mode_obj_set_property *arg = data;
	struct drm_mode_object *arg_obj;
	struct drm_mode_object *prop_obj;
	struct drm_property *property;
	int ret = -EINVAL;
	int i;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);

	arg_obj = drm_mode_object_find(dev, arg->obj_id, arg->obj_type);
	if (!arg_obj) {
		ret = -ENOENT;
		goto out;
	}
	if (!arg_obj->properties)
		goto out;

	for (i = 0; i < arg_obj->properties->count; i++)
		if (arg_obj->properties->ids[i] == arg->prop_id)
			break;

	if (i == arg_obj->properties->count)
		goto out;

	prop_obj = drm_mode_object_find(dev, arg->prop_id,
					DRM_MODE_OBJECT_PROPERTY);
	if (!prop_obj) {
		ret = -ENOENT;
		goto out;
	}
	property = obj_to_property(prop_obj);

	if (!drm_property_change_is_valid(property, arg->value))
		goto out;

	switch (arg_obj->type) {
	case DRM_MODE_OBJECT_CONNECTOR:
		ret = drm_mode_connector_set_obj_prop(arg_obj, property,
						      arg->value);
		break;
	case DRM_MODE_OBJECT_CRTC:
		ret = drm_mode_crtc_set_obj_prop(arg_obj, property, arg->value);
		break;
	case DRM_MODE_OBJECT_PLANE:
		ret = drm_mode_plane_set_obj_prop(arg_obj, property, arg->value);
		break;
	}

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

int drm_mode_connector_attach_encoder(struct drm_connector *connector,
				      struct drm_encoder *encoder)
{
	int i;

	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] == 0) {
			connector->encoder_ids[i] = encoder->base.id;
			return 0;
		}
	}
	return -ENOMEM;
}
EXPORT_SYMBOL(drm_mode_connector_attach_encoder);

void drm_mode_connector_detach_encoder(struct drm_connector *connector,
				    struct drm_encoder *encoder)
{
	int i;
	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] == encoder->base.id) {
			connector->encoder_ids[i] = 0;
			if (connector->encoder == encoder)
				connector->encoder = NULL;
			break;
		}
	}
}
EXPORT_SYMBOL(drm_mode_connector_detach_encoder);

int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
				  int gamma_size)
{
	crtc->gamma_size = gamma_size;

	crtc->gamma_store = kzalloc(gamma_size * sizeof(uint16_t) * 3, GFP_KERNEL);
	if (!crtc->gamma_store) {
		crtc->gamma_size = 0;
		return -ENOMEM;
	}

	return 0;
}
EXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);

int drm_mode_gamma_set_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_lut *crtc_lut = data;
	struct drm_mode_object *obj;
	struct drm_crtc *crtc;
	void *r_base, *g_base, *b_base;
	int size;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);

	if (crtc->funcs->gamma_set == NULL) {
		ret = -ENOSYS;
		goto out;
	}

	/* memcpy into gamma store */
	if (crtc_lut->gamma_size != crtc->gamma_size) {
		ret = -EINVAL;
		goto out;
	}

	size = crtc_lut->gamma_size * (sizeof(uint16_t));
	r_base = crtc->gamma_store;
	if (copy_from_user(r_base, (void __user *)(unsigned long)crtc_lut->red, size)) {
		ret = -EFAULT;
		goto out;
	}

	g_base = r_base + size;
	if (copy_from_user(g_base, (void __user *)(unsigned long)crtc_lut->green, size)) {
		ret = -EFAULT;
		goto out;
	}

	b_base = g_base + size;
	if (copy_from_user(b_base, (void __user *)(unsigned long)crtc_lut->blue, size)) {
		ret = -EFAULT;
		goto out;
	}

	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size);

out:
	drm_modeset_unlock_all(dev);
	return ret;

}

int drm_mode_gamma_get_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_lut *crtc_lut = data;
	struct drm_mode_object *obj;
	struct drm_crtc *crtc;
	void *r_base, *g_base, *b_base;
	int size;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);

	/* memcpy into gamma store */
	if (crtc_lut->gamma_size != crtc->gamma_size) {
		ret = -EINVAL;
		goto out;
	}

	size = crtc_lut->gamma_size * (sizeof(uint16_t));
	r_base = crtc->gamma_store;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->red, r_base, size)) {
		ret = -EFAULT;
		goto out;
	}

	g_base = r_base + size;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->green, g_base, size)) {
		ret = -EFAULT;
		goto out;
	}

	b_base = g_base + size;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->blue, b_base, size)) {
		ret = -EFAULT;
		goto out;
	}
out:
	drm_modeset_unlock_all(dev);
	return ret;
}

int drm_mode_page_flip_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_page_flip *page_flip = data;
	struct drm_mode_object *obj;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb = NULL, *old_fb = NULL;
	struct drm_pending_vblank_event *e = NULL;
	unsigned long flags;
	int ret = -EINVAL;

	if (page_flip->flags & ~DRM_MODE_PAGE_FLIP_FLAGS ||
	    page_flip->reserved != 0)
		return -EINVAL;

	if ((page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC) && !dev->mode_config.async_page_flip)
		return -EINVAL;

	obj = drm_mode_object_find(dev, page_flip->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj)
		return -ENOENT;
	crtc = obj_to_crtc(obj);

	mutex_lock(&crtc->mutex);
	if (crtc->fb == NULL) {
		/* The framebuffer is currently unbound, presumably
		 * due to a hotplug event, that userspace has not
		 * yet discovered.
		 */
		ret = -EBUSY;
		goto out;
	}

	if (crtc->funcs->page_flip == NULL)
		goto out;

	fb = drm_framebuffer_lookup(dev, page_flip->fb_id);
	if (!fb) {
		ret = -ENOENT;
		goto out;
	}

	ret = drm_crtc_check_viewport(crtc, crtc->x, crtc->y, &crtc->mode, fb);
	if (ret)
		goto out;

	if (crtc->fb->pixel_format != fb->pixel_format) {
		DRM_DEBUG_KMS("Page flip is not allowed to change frame buffer format.\n");
		ret = -EINVAL;
		goto out;
	}

	if (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {
		ret = -ENOMEM;
		spin_lock_irqsave(&dev->event_lock, flags);
		if (file_priv->event_space < sizeof e->event) {
			spin_unlock_irqrestore(&dev->event_lock, flags);
			goto out;
		}
		file_priv->event_space -= sizeof e->event;
		spin_unlock_irqrestore(&dev->event_lock, flags);

		e = kzalloc(sizeof *e, GFP_KERNEL);
		if (e == NULL) {
			spin_lock_irqsave(&dev->event_lock, flags);
			file_priv->event_space += sizeof e->event;
			spin_unlock_irqrestore(&dev->event_lock, flags);
			goto out;
		}

		e->event.base.type = DRM_EVENT_FLIP_COMPLETE;
		e->event.base.length = sizeof e->event;
		e->event.user_data = page_flip->user_data;
		e->base.event = &e->event.base;
		e->base.file_priv = file_priv;
		e->base.destroy =
			(void (*) (struct drm_pending_event *)) kfree;
	}

	old_fb = crtc->fb;
	ret = crtc->funcs->page_flip(crtc, fb, e, page_flip->flags);
	if (ret) {
		if (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {
			spin_lock_irqsave(&dev->event_lock, flags);
			file_priv->event_space += sizeof e->event;
			spin_unlock_irqrestore(&dev->event_lock, flags);
			kfree(e);
		}
		/* Keep the old fb, don't unref it. */
		old_fb = NULL;
	} else {
		/*
		 * Warn if the driver hasn't properly updated the crtc->fb
		 * field to reflect that the new framebuffer is now used.
		 * Failing to do so will screw with the reference counting
		 * on framebuffers.
		 */
		WARN_ON(crtc->fb != fb);
		/* Unref only the old framebuffer. */
		fb = NULL;
	}

out:
	if (fb)
		drm_framebuffer_unreference(fb);
	if (old_fb)
		drm_framebuffer_unreference(old_fb);
	mutex_unlock(&crtc->mutex);

	return ret;
}

void drm_mode_config_reset(struct drm_device *dev)
{
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	struct drm_connector *connector;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		if (crtc->funcs->reset)
			crtc->funcs->reset(crtc);

	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
		if (encoder->funcs->reset)
			encoder->funcs->reset(encoder);

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		connector->status = connector_status_unknown;

		if (connector->funcs->reset)
			connector->funcs->reset(connector);
	}
}
EXPORT_SYMBOL(drm_mode_config_reset);

int drm_mode_create_dumb_ioctl(struct drm_device *dev,
			       void *data, struct drm_file *file_priv)
{
	struct drm_mode_create_dumb *args = data;

	if (!dev->driver->dumb_create)
		return -ENOSYS;
	return dev->driver->dumb_create(file_priv, dev, args);
}

int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_map_dumb *args = data;

	/* call driver ioctl to get mmap offset */
	if (!dev->driver->dumb_map_offset)
		return -ENOSYS;

	return dev->driver->dumb_map_offset(file_priv, dev, args->handle, &args->offset);
}

int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
				void *data, struct drm_file *file_priv)
{
	struct drm_mode_destroy_dumb *args = data;

	if (!dev->driver->dumb_destroy)
		return -ENOSYS;

	return dev->driver->dumb_destroy(file_priv, dev, args->handle);
}

/*
 * Just need to support RGB formats here for compat with code that doesn't
 * use pixel formats directly yet.
 */
void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
			  int *bpp)
{
	switch (format) {
	case DRM_FORMAT_C8:
	case DRM_FORMAT_RGB332:
	case DRM_FORMAT_BGR233:
		*depth = 8;
		*bpp = 8;
		break;
	case DRM_FORMAT_XRGB1555:
	case DRM_FORMAT_XBGR1555:
	case DRM_FORMAT_RGBX5551:
	case DRM_FORMAT_BGRX5551:
	case DRM_FORMAT_ARGB1555:
	case DRM_FORMAT_ABGR1555:
	case DRM_FORMAT_RGBA5551:
	case DRM_FORMAT_BGRA5551:
		*depth = 15;
		*bpp = 16;
		break;
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_BGR565:
		*depth = 16;
		*bpp = 16;
		break;
	case DRM_FORMAT_RGB888:
	case DRM_FORMAT_BGR888:
		*depth = 24;
		*bpp = 24;
		break;
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_RGBX8888:
	case DRM_FORMAT_BGRX8888:
		*depth = 24;
		*bpp = 32;
		break;
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_RGBX1010102:
	case DRM_FORMAT_BGRX1010102:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_ABGR2101010:
	case DRM_FORMAT_RGBA1010102:
	case DRM_FORMAT_BGRA1010102:
		*depth = 30;
		*bpp = 32;
		break;
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_RGBA8888:
	case DRM_FORMAT_BGRA8888:
		*depth = 32;
		*bpp = 32;
		break;
	default:
		DRM_DEBUG_KMS("unsupported pixel format %s\n",
			      drm_get_format_name(format));
		*depth = 0;
		*bpp = 0;
		break;
	}
}
EXPORT_SYMBOL(drm_fb_get_bpp_depth);

/**
 * drm_format_num_planes - get the number of planes for format
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * RETURNS:
 * The number of planes used by the specified pixel format.
 */
int drm_format_num_planes(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 3;
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_num_planes);

/**
 * drm_format_plane_cpp - determine the bytes per pixel value
 * @@format: pixel format (DRM_FORMAT_*)
 * @@plane: plane index
 *
 * RETURNS:
 * The bytes per pixel value for the specified plane.
 */
int drm_format_plane_cpp(uint32_t format, int plane)
{
	unsigned int depth;
	int bpp;

	if (plane >= drm_format_num_planes(format))
		return 0;

	switch (format) {
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
		return 2;
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
		return plane ? 2 : 1;
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 1;
	default:
		drm_fb_get_bpp_depth(format, &depth, &bpp);
		return bpp >> 3;
	}
}
EXPORT_SYMBOL(drm_format_plane_cpp);

/**
 * drm_format_horz_chroma_subsampling - get the horizontal chroma subsampling factor
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * RETURNS:
 * The horizontal chroma subsampling factor for the
 * specified pixel format.
 */
int drm_format_horz_chroma_subsampling(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
		return 4;
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_horz_chroma_subsampling);

/**
 * drm_format_vert_chroma_subsampling - get the vertical chroma subsampling factor
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * RETURNS:
 * The vertical chroma subsampling factor for the
 * specified pixel format.
 */
int drm_format_vert_chroma_subsampling(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
		return 4;
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_vert_chroma_subsampling);

/**
 * drm_mode_config_init - initialize DRM mode_configuration structure
 * @@dev: DRM device
 *
 * Initialize @@dev's mode_config structure, used for tracking the graphics
 * configuration of @@dev.
 *
 * Since this initializes the modeset locks, no locking is possible. Which is no
 * problem, since this should happen single threaded at init time. It is the
 * driver's problem to ensure this guarantee.
 *
 */
void drm_mode_config_init(struct drm_device *dev)
{
	rw_init(&dev->mode_config.mutex, "mcrwl");
	rw_init(&dev->mode_config.idr_mutex, "idrwl");
	rw_init(&dev->mode_config.fb_lock, "fblk");
	INIT_LIST_HEAD(&dev->mode_config.fb_list);
	INIT_LIST_HEAD(&dev->mode_config.crtc_list);
	INIT_LIST_HEAD(&dev->mode_config.connector_list);
	INIT_LIST_HEAD(&dev->mode_config.bridge_list);
	INIT_LIST_HEAD(&dev->mode_config.encoder_list);
	INIT_LIST_HEAD(&dev->mode_config.property_list);
	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
	INIT_LIST_HEAD(&dev->mode_config.plane_list);
	idr_init(&dev->mode_config.crtc_idr);

	drm_modeset_lock_all(dev);
	drm_mode_create_standard_connector_properties(dev);
	drm_modeset_unlock_all(dev);

	/* Just to be sure */
	dev->mode_config.num_fb = 0;
	dev->mode_config.num_connector = 0;
	dev->mode_config.num_crtc = 0;
	dev->mode_config.num_encoder = 0;
}
EXPORT_SYMBOL(drm_mode_config_init);

/**
 * drm_mode_config_cleanup - free up DRM mode_config info
 * @@dev: DRM device
 *
 * Free up all the connectors and CRTCs associated with this DRM device, then
 * free up the framebuffers and associated buffer objects.
 *
 * Note that since this /should/ happen single-threaded at driver/device
 * teardown time, no locking is required. It's the driver's job to ensure that
 * this guarantee actually holds true.
 *
 * FIXME: cleanup any dangling user buffer objects too
 */
void drm_mode_config_cleanup(struct drm_device *dev)
{
	struct drm_connector *connector, *ot;
	struct drm_crtc *crtc, *ct;
	struct drm_encoder *encoder, *enct;
	struct drm_bridge *bridge, *brt;
	struct drm_framebuffer *fb, *fbt;
	struct drm_property *property, *pt;
	struct drm_property_blob *blob, *bt;
	struct drm_plane *plane, *plt;

	list_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,
				 head) {
		encoder->funcs->destroy(encoder);
	}

	list_for_each_entry_safe(bridge, brt,
				 &dev->mode_config.bridge_list, head) {
		bridge->funcs->destroy(bridge);
	}

	list_for_each_entry_safe(connector, ot,
				 &dev->mode_config.connector_list, head) {
		connector->funcs->destroy(connector);
	}

	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
				 head) {
		drm_property_destroy(dev, property);
	}

	list_for_each_entry_safe(blob, bt, &dev->mode_config.property_blob_list,
				 head) {
		drm_property_destroy_blob(dev, blob);
	}

	/*
	 * Single-threaded teardown context, so it's not required to grab the
	 * fb_lock to protect against concurrent fb_list access. Contrary, it
	 * would actually deadlock with the drm_framebuffer_cleanup function.
	 *
	 * Also, if there are any framebuffers left, that's a driver leak now,
	 * so politely WARN about this.
	 */
	WARN_ON(!list_empty(&dev->mode_config.fb_list));
	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
		drm_framebuffer_remove(fb);
	}

	list_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,
				 head) {
		plane->funcs->destroy(plane);
	}

	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
		crtc->funcs->destroy(crtc);
	}

	idr_destroy(&dev->mode_config.crtc_idr);
}
EXPORT_SYMBOL(drm_mode_config_cleanup);
@


1.23
log
@Get rid of some infrastrcuture that is now obsolete and synchronize some of
the data structures in drmP.h with Linux 3.14.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.22 2016/04/07 20:33:24 kettenis Exp $	*/
d645 1
a645 1
	rw_init(&crtc->mutex, "crtcl");
@


1.22
log
@Retry the drm_crtc.c "idr"conversion.  Turns out the xf86-video-intel driver
is buggy and trucates the ids to 8 bits.  So specifymaximum in the idr_alloc()
call until that gets fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.21 2016/04/06 21:12:40 kettenis Exp $	*/
d2762 1
a2762 1
		if (file_priv->master || capable(CAP_SYS_ADMIN)) {
@


1.21
log
@Revert the drm_crt.c "idr" conversion as it breaks X on (at least) the T430s.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.20 2016/04/06 14:39:19 kettenis Exp $	*/
a101 4
int	 drm_mode_handle_cmp(struct drm_mode_handle *, struct drm_mode_handle *);

SPLAY_PROTOTYPE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);

d312 14
a325 2
	struct drm_mode_handle *han;
	int new_id = 0;
d327 1
a327 18
	if ((han = drm_calloc(1, sizeof(*han))) == NULL)
		return -ENOMEM;
	han->obj = obj;
	rw_enter_write(&dev->mode_config.idr_rwl);
	
again:
	new_id = han->handle = ++dev->mode_config.mode_obj_id;
	/*
	 * Make sure we have no duplicates. this'll hurt once we wrap, 0 is
	 * reserved.
	 */
	obj->id = new_id;
	obj->type = obj_type;
	if (han->handle == 0 || SPLAY_INSERT(drm_mode_tree,
		&dev->mode_config.mode_tree, han))
		goto again;
	rw_exit_write(&dev->mode_config.idr_rwl);
	return 0;
d340 3
a342 7
	struct drm_mode_handle han;
	han.obj = object;
	han.handle = object->id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
a357 1
	struct drm_mode_handle *han, search;
d359 7
a365 10
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}
	
	obj = han->obj;
	if (obj->type != type) {
d367 1
a367 2
	}
	rw_exit_write(&dev->mode_config.idr_rwl);
a428 1
	struct drm_mode_handle *han, search;
d431 2
a432 9
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}

	obj = han->obj;
d437 1
a437 1
	rw_exit_write(&dev->mode_config.idr_rwl);
d505 3
a507 7
	struct drm_mode_handle han;
	han.obj = &fb->base;
	han.handle = fb->base.id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
d4062 1
a4062 1
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
d4072 1
a4072 1
	SPLAY_INIT(&dev->mode_config.mode_tree);
a4156 1
#ifdef __linux__
a4157 3
#else
	/* XXX destroy idr/SPLAY tree */
#endif
a4159 8

int      
drm_mode_handle_cmp(struct drm_mode_handle *a, struct drm_mode_handle *b)
{
	return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);
@


1.20
log
@Another "idr" conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.19 2015/09/27 11:09:26 jsg Exp $	*/
d102 4
d316 2
a317 1
	int ret;
d319 18
a336 13
	mutex_lock(&dev->mode_config.idr_mutex);
	ret = idr_alloc(&dev->mode_config.crtc_idr, obj, 1, 0, GFP_KERNEL);
	if (ret >= 0) {
		/*
		 * Set up the object linking under the protection of the idr
		 * lock so that other users can't see inconsistent state.
		 */
		obj->id = ret;
		obj->type = obj_type;
	}
	mutex_unlock(&dev->mode_config.idr_mutex);

	return ret < 0 ? ret : 0;
d349 7
a355 3
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, object->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
d371 1
d373 10
a382 7
	/* Framebuffers are reference counted and need their own lookup
	 * function.*/
	WARN_ON(type == DRM_MODE_OBJECT_FB);

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != type) || (obj->id != id))
d384 2
a385 1
	mutex_unlock(&dev->mode_config.idr_mutex);
d447 1
d450 9
a458 2
	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
d463 1
a463 1
	mutex_unlock(&dev->mode_config.idr_mutex);
d531 7
a537 3
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, fb->base.id);
	mutex_unlock(&dev->mode_config.idr_mutex);
d4092 1
a4092 1
	rw_init(&dev->mode_config.idr_mutex, "idrwl");
d4102 1
a4102 1
	idr_init(&dev->mode_config.crtc_idr);
d4187 1
d4189 3
d4194 8
@


1.19
log
@Switch remaining users of the FreeBSD refcount apis back to the original
linux kref/kobject use.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.18 2015/09/23 23:12:11 kettenis Exp $	*/
a101 4
int	 drm_mode_handle_cmp(struct drm_mode_handle *, struct drm_mode_handle *);

SPLAY_PROTOTYPE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);

d312 13
a324 2
	struct drm_mode_handle *han;
	int new_id = 0;
d326 1
a326 18
	if ((han = drm_calloc(1, sizeof(*han))) == NULL)
		return -ENOMEM;
	han->obj = obj;
	rw_enter_write(&dev->mode_config.idr_rwl);
	
again:
	new_id = han->handle = ++dev->mode_config.mode_obj_id;
	/*
	 * Make sure we have no duplicates. this'll hurt once we wrap, 0 is
	 * reserved.
	 */
	obj->id = new_id;
	obj->type = obj_type;
	if (han->handle == 0 || SPLAY_INSERT(drm_mode_tree,
		&dev->mode_config.mode_tree, han))
		goto again;
	rw_exit_write(&dev->mode_config.idr_rwl);
	return 0;
d339 3
a341 7
	struct drm_mode_handle han;
	han.obj = object;
	han.handle = object->id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
a356 1
	struct drm_mode_handle *han, search;
d358 7
a364 10
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}
	
	obj = han->obj;
	if (obj->type != type) {
d366 1
a366 2
	}
	rw_exit_write(&dev->mode_config.idr_rwl);
a427 1
	struct drm_mode_handle *han, search;
d430 2
a431 9
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}

	obj = han->obj;
d436 1
a436 1
	rw_exit_write(&dev->mode_config.idr_rwl);
d504 3
a506 7
	struct drm_mode_handle han;
	han.obj = &fb->base;
	han.handle = fb->base.id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
d4061 1
a4061 1
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
d4071 1
a4071 1
	SPLAY_INIT(&dev->mode_config.mode_tree);
a4155 1
#ifdef __linux__
a4156 3
#else
	/* XXX destroy idr/SPLAY tree */
#endif
a4158 8

int      
drm_mode_handle_cmp(struct drm_mode_handle *a, struct drm_mode_handle *b)
{
	return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);
@


1.18
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.17 2015/05/05 02:01:10 jsg Exp $	*/
a36 1
#include "refcount.h"
d415 1
a415 1
	refcount_init(&fb->refcount, 1);
d436 1
a436 1
static void drm_framebuffer_free(struct drm_framebuffer *fb)
d438 2
d501 1
a501 2
	if (refcount_release(&fb->refcount))
		drm_framebuffer_free(fb);
d512 1
a512 1
	refcount_acquire(&fb->refcount);
d516 1
a516 1
static void drm_framebuffer_free_bug(struct drm_framebuffer *fb)
d524 1
a524 2
	if (refcount_release(&fb->refcount))
		drm_framebuffer_free_bug(fb);
d628 1
a628 1
	if (atomic_read(&fb->refcount) > 1) {
@


1.17
log
@fix a return path that lacked a rw_exit_write() call
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.16 2015/04/06 09:23:19 jsg Exp $	*/
d39 52
d93 1
a93 3
	char *fnname(int);					\
								\
	char *fnname(int val)					\
a102 2
char	*drm_get_connector_status_name(enum drm_connector_status);
int	 drm_mode_group_init(struct drm_device *, struct drm_mode_group *);
d110 1
a110 1
static struct drm_prop_enum_list drm_dpms_enum_list[] =
d122 1
a122 1
static struct drm_prop_enum_list drm_scaling_mode_enum_list[] =
a129 7
static struct drm_prop_enum_list drm_dithering_mode_enum_list[] =
{
	{ DRM_MODE_DITHERING_OFF, "Off" },
	{ DRM_MODE_DITHERING_ON, "On" },
	{ DRM_MODE_DITHERING_AUTO, "Automatic" },
};

d133 1
a133 1
static struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =
d142 1
a142 1
static struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =
d152 1
a152 1
static struct drm_prop_enum_list drm_tv_select_enum_list[] =
d163 1
a163 1
static struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =
d175 1
a175 1
static struct drm_prop_enum_list drm_dirty_info_enum_list[] = {
a180 3
DRM_ENUM_NAME_FN(drm_get_dirty_info_name,
		 drm_dirty_info_enum_list)

d183 4
a186 1
	char *name;
d188 1
d195 17
a211 16
{	{ DRM_MODE_CONNECTOR_Unknown, "Unknown", 0 },
	{ DRM_MODE_CONNECTOR_VGA, "VGA", 0 },
	{ DRM_MODE_CONNECTOR_DVII, "DVI-I", 0 },
	{ DRM_MODE_CONNECTOR_DVID, "DVI-D", 0 },
	{ DRM_MODE_CONNECTOR_DVIA, "DVI-A", 0 },
	{ DRM_MODE_CONNECTOR_Composite, "Composite", 0 },
	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO", 0 },
	{ DRM_MODE_CONNECTOR_LVDS, "LVDS", 0 },
	{ DRM_MODE_CONNECTOR_Component, "Component", 0 },
	{ DRM_MODE_CONNECTOR_9PinDIN, "DIN", 0 },
	{ DRM_MODE_CONNECTOR_DisplayPort, "DP", 0 },
	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI-A", 0 },
	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI-B", 0 },
	{ DRM_MODE_CONNECTOR_TV, "TV", 0 },
	{ DRM_MODE_CONNECTOR_eDP, "eDP", 0 },
	{ DRM_MODE_CONNECTOR_VIRTUAL, "Virtual", 0},
d214 1
a214 1
static struct drm_prop_enum_list drm_encoder_enum_list[] =
d221 1
d224 23
a246 1
char *drm_get_encoder_name(struct drm_encoder *encoder)
d257 1
a257 1
char *drm_get_connector_name(struct drm_connector *connector)
d268 1
a268 1
char *drm_get_connector_status_name(enum drm_connector_status status)
d277 23
d302 1
a302 1
 * drm_mode_object_get - allocate a new identifier
d304 2
a305 4
 * @@ptr: object pointer, used to generate unique ID
 * @@type: object type
 *
 * LOCKING:
d341 1
a341 1
 * drm_mode_object_put - free an identifer
d343 1
a343 4
 * @@id: ID to free
 *
 * LOCKING:
 * Caller must hold DRM mode_config lock.
d359 9
d395 2
a396 3
 *
 * LOCKING:
 * Caller must hold mode config lock.
d401 6
d415 1
d417 3
d423 4
a426 1
		return ret;
a427 2
	fb->dev = dev;
	fb->funcs = funcs;
d430 2
d442 49
d493 1
d495 1
a495 2
 * LOCKING:
 * Caller must hold mode config lock.
a498 1
	struct drm_device *dev = fb->dev;
a499 1
	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
d507 1
d516 49
d569 2
a570 2
 * LOCKING:
 * Caller must hold mode config lock.
d572 8
a579 2
 * Scans all the CRTCs in @@dev's mode_config.  If they're using @@fb, removes
 * it, setting it to NULL.
d584 2
a585 8
	/*
	 * This could be moved to drm_framebuffer_remove(), but for
	 * debugging is nice to keep around the list of fb's that are
	 * no longer associated w/ a drm_file but are not unreferenced
	 * yet.  (i915 and omapdrm have debugfs files which will show
	 * this.)
	 */
	drm_mode_object_put(dev, &fb->base);
d588 1
d596 3
a598 2
 * LOCKING:
 * Caller must hold mode config lock.
d600 3
a602 2
 * Scans all the CRTCs and planes in @@dev's mode_config.  If they're
 * using @@fb, removes it, setting it to NULL.
d612 30
a641 10
	/* remove from any CRTC */
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		if (crtc->fb == fb) {
			/* should turn off the crtc */
			memset(&set, 0, sizeof(struct drm_mode_set));
			set.crtc = crtc;
			set.fb = NULL;
			ret = crtc->funcs->set_config(&set);
			if (ret)
				DRM_ERROR("failed to reset crtc %p when fb was deleted\n", crtc);
a642 1
	}
d644 3
a646 9
	list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
		if (plane->fb == fb) {
			/* should turn off the crtc */
			ret = plane->funcs->disable_plane(plane);
			if (ret)
				DRM_ERROR("failed to disable plane with busy fb\n");
			/* disconnect the plane from the fb and crtc: */
			plane->fb = NULL;
			plane->crtc = NULL;
d648 1
a650 2
	list_del(&fb->filp_head);

d661 1
a661 4
 * LOCKING:
 * Takes mode_config lock.
 *
 * Inits a new object created as base part of an driver crtc object.
d675 3
a677 1
	mutex_lock(&dev->mode_config.mutex);
d689 1
a689 1
	mutex_unlock(&dev->mode_config.mutex);
d696 1
a696 1
 * drm_crtc_cleanup - Cleans up the core crtc usage.
d699 3
a701 5
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Cleanup @@crtc. Removes from drm modesetting space
 * does NOT free object, caller does that.
d717 23
a743 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d749 1
a749 1
	list_add(&mode->head, &connector->probed_modes);
d753 1
a753 1
/**
a757 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d760 2
a761 2
void drm_mode_remove(struct drm_connector *connector,
		     struct drm_display_mode *mode)
a765 1
EXPORT_SYMBOL(drm_mode_remove);
d772 1
a772 4
 * @@name: user visible name of the connector
 *
 * LOCKING:
 * Takes mode config lock.
d786 4
d791 1
a791 1
	mutex_lock(&dev->mode_config.mutex);
d801 4
d806 7
a812 2
		++drm_connector_enum_list[connector_type].count; /* TODO */
	INIT_LIST_HEAD(&connector->user_modes);
d830 1
a830 1
	mutex_unlock(&dev->mode_config.mutex);
a839 3
 * LOCKING:
 * Takes mode config lock.
 *
d853 4
a856 2
	list_for_each_entry_safe(mode, t, &connector->user_modes, head)
		drm_mode_remove(connector, mode);
a857 1
	mutex_lock(&dev->mode_config.mutex);
a860 1
	mutex_unlock(&dev->mode_config.mutex);
d874 35
d916 1
a916 1
	mutex_lock(&dev->mode_config.mutex);
d930 1
a930 1
	mutex_unlock(&dev->mode_config.mutex);
d939 1
a939 1
	mutex_lock(&dev->mode_config.mutex);
d943 1
a943 1
	mutex_unlock(&dev->mode_config.mutex);
d947 15
d970 1
a970 1
	mutex_lock(&dev->mode_config.mutex);
d1004 1
a1004 1
	mutex_unlock(&dev->mode_config.mutex);
d1010 8
d1022 1
a1022 1
	mutex_lock(&dev->mode_config.mutex);
d1030 1
a1030 1
	mutex_unlock(&dev->mode_config.mutex);
d1035 26
a1063 3
 * LOCKING:
 * Caller must hold DRM mode_config lock.
 *
a1090 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
a1262 24
 * drm_mode_create_dithering_property - create dithering property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_dithering_property(struct drm_device *dev)
{
	struct drm_property *dithering_mode;

	if (dev->mode_config.dithering_mode_property)
		return 0;

	dithering_mode =
		drm_property_create_enum(dev, 0, "dithering",
				drm_dithering_mode_enum_list,
				    ARRAY_SIZE(drm_dithering_mode_enum_list));
	dev->mode_config.dithering_mode_property = dithering_mode;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dithering_property);

/**
d1287 1
a1287 11
/**
 * drm_mode_config_init - initialize DRM mode_configuration structure
 * @@dev: DRM device
 *
 * LOCKING:
 * None, should happen single threaded at init time.
 *
 * Initialize @@dev's mode_config structure, used for tracking the graphics
 * configuration of @@dev.
 */
void drm_mode_config_init(struct drm_device *dev)
d1289 1
a1289 26
	rw_init(&dev->mode_config.mutex, "mcrwl");
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
	INIT_LIST_HEAD(&dev->mode_config.fb_list);
	INIT_LIST_HEAD(&dev->mode_config.crtc_list);
	INIT_LIST_HEAD(&dev->mode_config.connector_list);
	INIT_LIST_HEAD(&dev->mode_config.encoder_list);
	INIT_LIST_HEAD(&dev->mode_config.property_list);
	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
	INIT_LIST_HEAD(&dev->mode_config.plane_list);
	SPLAY_INIT(&dev->mode_config.mode_tree);

	mutex_lock(&dev->mode_config.mutex);
	drm_mode_create_standard_connector_properties(dev);
	mutex_unlock(&dev->mode_config.mutex);

	/* Just to be sure */
	dev->mode_config.num_fb = 0;
	dev->mode_config.num_connector = 0;
	dev->mode_config.num_crtc = 0;
	dev->mode_config.num_encoder = 0;
}
EXPORT_SYMBOL(drm_mode_config_init);

int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
{
	uint32_t total_objects = 0;
d1294 1
d1303 1
d1313 1
d1330 5
a1339 53
 * drm_mode_config_cleanup - free up DRM mode_config info
 * @@dev: DRM device
 *
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Free up all the connectors and CRTCs associated with this DRM device, then
 * free up the framebuffers and associated buffer objects.
 *
 * FIXME: cleanup any dangling user buffer objects too
 */
void drm_mode_config_cleanup(struct drm_device *dev)
{
	struct drm_connector *connector, *ot;
	struct drm_crtc *crtc, *ct;
	struct drm_encoder *encoder, *enct;
	struct drm_framebuffer *fb, *fbt;
	struct drm_property *property, *pt;
	struct drm_plane *plane, *plt;

	list_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,
				 head) {
		encoder->funcs->destroy(encoder);
	}

	list_for_each_entry_safe(connector, ot,
				 &dev->mode_config.connector_list, head) {
		connector->funcs->destroy(connector);
	}

	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
				 head) {
		drm_property_destroy(dev, property);
	}

	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
		drm_framebuffer_remove(fb);
	}

	list_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,
				 head) {
		plane->funcs->destroy(plane);
	}

	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
		crtc->funcs->destroy(crtc);
	}

	// XXX destroy idr/SPLAY tree
}
EXPORT_SYMBOL(drm_mode_config_cleanup);

/**
a1343 3
 * LOCKING:
 * None.
 *
d1376 1
a1376 1
 * drm_crtc_convert_to_umode - convert a modeinfo into a drm_display_mode
a1379 3
 * LOCKING:
 * None.
 *
d1392 3
d1417 3
a1419 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1443 3
a1446 2
#if 0
	int i;
d1452 1
a1452 1
#if 0
a1458 1
	mutex_lock(&dev->mode_config.mutex);
d1460 1
d1468 18
a1485 1
#if 0
d1498 1
a1498 1
#if 0
a1511 15
	/* handle this in 4 parts */
	/* FBs */
	if (card_res->count_fbs >= fb_count) {
		copied = 0;
		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
			if (put_user(fb->base.id, fb_id + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	card_res->count_fbs = fb_count;

d1516 1
a1516 1
#if 0
d1528 1
a1528 1
#if 0
d1547 1
a1547 1
#if 0
d1562 1
a1562 1
#if 0
d1582 1
a1582 1
#if 0
d1598 1
a1598 1
#if 0
d1619 1
a1619 1
	mutex_unlock(&dev->mode_config.mutex);
d1625 3
a1627 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1647 1
a1647 1
	mutex_lock(&dev->mode_config.mutex);
d1652 1
a1652 1
		ret = -EINVAL;
d1675 1
a1675 1
	mutex_unlock(&dev->mode_config.mutex);
d1679 13
d1694 3
a1696 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1736 1
a1736 1
		ret = -EINVAL;
d1757 2
a1758 1
		mode_count++;
d1780 3
d1833 1
d1848 1
a1848 1
	mutex_lock(&dev->mode_config.mutex);
d1852 1
a1852 1
		ret = -EINVAL;
d1867 1
a1867 1
	mutex_unlock(&dev->mode_config.mutex);
a1876 3
 * LOCKING:
 * Takes mode config lock.
 *
d1891 1
a1891 1
	mutex_lock(&dev->mode_config.mutex);
d1913 1
a1913 1
	mutex_unlock(&dev->mode_config.mutex);
a1922 3
 * LOCKING:
 * Takes mode config lock.
 *
d1938 1
a1938 1
	mutex_lock(&dev->mode_config.mutex);
d1959 1
a1959 1
	plane_resp->gamma_size = plane->gamma_size;
d1978 1
a1978 1
	mutex_unlock(&dev->mode_config.mutex);
d1986 1
a1986 4
 * @@file_prive: DRM file info
 *
 * LOCKING:
 * Takes mode config lock.
d1998 1
a1998 1
	struct drm_framebuffer *fb;
a2005 2
	mutex_lock(&dev->mode_config.mutex);

d2015 1
a2015 2
		ret = -ENOENT;
		goto out;
d2021 2
d2026 1
d2040 2
a2041 3
	obj = drm_mode_object_find(dev, plane_req->fb_id,
				   DRM_MODE_OBJECT_FB);
	if (!obj) {
a2046 1
	fb = obj_to_fb(obj);
d2053 2
a2054 1
		DRM_DEBUG_KMS("Invalid pixel format 0x%08x\n", fb->pixel_format);
d2093 1
d2100 1
d2103 1
d2105 1
d2108 44
a2151 1
	mutex_unlock(&dev->mode_config.mutex);
d2155 43
d2201 3
a2203 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d2230 5
a2234 2
	/* For some reason crtc x/y offsets are signed internally. */
	if (crtc_req->x > INT_MAX || crtc_req->y > INT_MAX)
d2237 1
a2237 1
	mutex_lock(&dev->mode_config.mutex);
d2242 1
a2242 1
		ret = -EINVAL;
a2248 1
		int hdisplay, vdisplay;
d2258 2
d2261 2
a2262 3
			obj = drm_mode_object_find(dev, crtc_req->fb_id,
						   DRM_MODE_OBJECT_FB);
			if (!obj) {
d2265 1
a2265 1
				ret = -EINVAL;
a2267 1
			fb = obj_to_fb(obj);
d2284 4
a2287 2
		hdisplay = mode->hdisplay;
		vdisplay = mode->vdisplay;
a2288 17
		if (crtc->invert_dimensions) {
			int tmp = hdisplay;
			hdisplay = vdisplay;
			vdisplay = tmp;
		}

		if (hdisplay > fb->width ||
		    vdisplay > fb->height ||
		    crtc_req->x > fb->width - hdisplay ||
		    crtc_req->y > fb->height - vdisplay) {
			DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
				      fb->width, fb->height,
				      hdisplay, vdisplay, crtc_req->x, crtc_req->y,
				      crtc->invert_dimensions ? " (inverted)" : "");
			ret = -ENOSPC;
			goto out;
		}
d2333 1
a2333 1
				ret = -EINVAL;
d2352 1
a2352 1
	ret = crtc->funcs->set_config(&set);
d2355 3
d2360 1
a2360 1
	mutex_unlock(&dev->mode_config.mutex);
d2364 3
a2366 2
int drm_mode_cursor_ioctl(struct drm_device *dev,
			void *data, struct drm_file *file_priv)
a2367 1
	struct drm_mode_cursor *req = data;
a2377 1
	mutex_lock(&dev->mode_config.mutex);
d2381 1
a2381 2
		ret = -EINVAL;
		goto out;
d2385 1
d2387 1
a2387 1
		if (!crtc->funcs->cursor_set) {
d2392 6
a2397 2
		ret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,
					      req->width, req->height);
d2409 2
a2410 1
	mutex_unlock(&dev->mode_config.mutex);
d2412 19
d2471 3
a2473 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2507 5
	mutex_lock(&dev->mode_config.mutex);

	/* TODO check buffer is sufficiently large */
	/* TODO setup destructor callback */

d2511 1
a2511 2
		ret = PTR_ERR(fb);
		goto out;
d2514 1
d2518 1
a2519 2
out:
	mutex_unlock(&dev->mode_config.mutex);
d2590 2
d2602 2
a2603 1
		DRM_DEBUG_KMS("bad framebuffer format 0x%08x\n", r->pixel_format);
d2648 3
a2650 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2689 2
	mutex_lock(&dev->mode_config.mutex);

d2693 1
a2693 2
		ret = PTR_ERR(fb);
		goto out;
d2696 1
d2700 2
a2702 2
out:
	mutex_unlock(&dev->mode_config.mutex);
d2708 3
a2710 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2721 1
	struct drm_mode_object *obj;
a2724 1
	int ret = 0;
d2730 5
a2734 8
	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, *id, DRM_MODE_OBJECT_FB);
	/* TODO check that we really get a framebuffer back. */
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	fb = obj_to_fb(obj);
d2739 5
d2745 3
a2747 4
	if (!found) {
		ret = -EINVAL;
		goto out;
	}
d2751 7
a2757 3
out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
d2762 3
a2764 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2776 34
	struct drm_mode_object *obj;
	struct drm_framebuffer *fb;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	fb = obj_to_fb(obj);

	r->height = fb->height;
	r->width = fb->width;
	r->depth = fb->depth;
	r->bpp = fb->bits_per_pixel;
	r->pitch = fb->pitches[0];
	fb->funcs->create_handle(fb, file_priv, &r->handle);

out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}

int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_clip_rect __user *clips_ptr;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = data;
	struct drm_mode_object *obj;
a2777 2
	unsigned flags;
	int num_clips;
d2783 3
a2785 144
	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj) {
		ret = -EINVAL;
		goto out_err1;
	}
	fb = obj_to_fb(obj);

	num_clips = r->num_clips;
	clips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;

	if (!num_clips != !clips_ptr) {
		ret = -EINVAL;
		goto out_err1;
	}

	flags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;

	/* If userspace annotates copy, clips must come in pairs */
	if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {
		ret = -EINVAL;
		goto out_err1;
	}

	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
		if (!clips) {
			ret = -ENOMEM;
			goto out_err1;
		}

		ret = copy_from_user(clips, clips_ptr,
				     num_clips * sizeof(*clips));
		if (ret) {
			ret = -EFAULT;
			goto out_err2;
		}
	}

	if (fb->funcs->dirty) {
		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
				       clips, num_clips);
	} else {
		ret = -ENOSYS;
		goto out_err2;
	}

out_err2:
	kfree(clips);
out_err1:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}


/**
 * drm_fb_release - remove and free the FBs on this file
 * @@filp: file * from the ioctl
 *
 * LOCKING:
 * Takes mode config lock.
 *
 * Destroy all the FBs associated with @@filp.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
void drm_fb_release(struct drm_device *dev, struct drm_file *priv)
{
	struct drm_framebuffer *fb, *tfb;

	mutex_lock(&dev->mode_config.mutex);
	list_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {
		drm_framebuffer_remove(fb);
	}
	mutex_unlock(&dev->mode_config.mutex);
}

/**
 * drm_mode_attachmode - add a mode to the user mode list
 * @@dev: DRM device
 * @@connector: connector to add the mode to
 * @@mode: mode to add
 *
 * Add @@mode to @@connector's user mode list.
 */
static void drm_mode_attachmode(struct drm_device *dev,
				struct drm_connector *connector,
				struct drm_display_mode *mode)
{
	list_add_tail(&mode->head, &connector->user_modes);
}

int drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
			     const struct drm_display_mode *mode)
{
	struct drm_connector *connector;
	int ret = 0;
	struct drm_display_mode *dup_mode, *next;
	DRM_LIST_HEAD(list);

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder)
			continue;
		if (connector->encoder->crtc == crtc) {
			dup_mode = drm_mode_duplicate(dev, mode);
			if (!dup_mode) {
				ret = -ENOMEM;
				goto out;
			}
			list_add_tail(&dup_mode->head, &list);
		}
	}

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder)
			continue;
		if (connector->encoder->crtc == crtc)
			list_move_tail(list.next, &connector->user_modes);
	}

//	WARN_ON(!list_empty(&list));

 out:
	list_for_each_entry_safe(dup_mode, next, &list, head)
		drm_mode_destroy(dev, dup_mode);

	return ret;
}
EXPORT_SYMBOL(drm_mode_attachmode_crtc);

static int drm_mode_detachmode(struct drm_device *dev,
			       struct drm_connector *connector,
			       struct drm_display_mode *mode)
{
	int found = 0;
	int ret = 0;
	struct drm_display_mode *match_mode, *t;
d2787 17
a2803 6
	list_for_each_entry_safe(match_mode, t, &connector->user_modes, head) {
		if (drm_mode_equal(match_mode, mode)) {
			list_del(&match_mode->head);
			drm_mode_destroy(dev, match_mode);
			found = 1;
			break;
d2805 2
d2809 1
a2809 2
	if (!found)
		ret = -EINVAL;
d2814 2
a2815 1
int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
d2817 6
a2822 30
	struct drm_connector *connector;

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		drm_mode_detachmode(dev, connector, mode);
	}
	return 0;
}
EXPORT_SYMBOL(drm_mode_detachmode_crtc);

/**
 * drm_fb_attachmode - Attach a user mode to an connector
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * This attaches a user specified mode to an connector.
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_attachmode_ioctl(struct drm_device *dev,
			      void *data, struct drm_file *file_priv)
{
	struct drm_mode_mode_cmd *mode_cmd = data;
	struct drm_connector *connector;
	struct drm_display_mode *mode;
	struct drm_mode_object *obj;
	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
d2828 13
a2840 1
	mutex_lock(&dev->mode_config.mutex);
d2842 2
a2843 2
	obj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
d2845 1
a2845 1
		goto out;
a2846 1
	connector = obj_to_connector(obj);
d2848 17
a2864 4
	mode = drm_mode_create(dev);
	if (!mode) {
		ret = -ENOMEM;
		goto out;
d2867 5
a2871 5
	ret = drm_crtc_convert_umode(mode, umode);
	if (ret) {
		DRM_DEBUG_KMS("Invalid mode\n");
		drm_mode_destroy(dev, mode);
		goto out;
d2874 5
a2878 3
	drm_mode_attachmode(dev, connector, mode);
out:
	mutex_unlock(&dev->mode_config.mutex);
d2884 4
a2887 5
 * drm_fb_detachmode - Detach a user specified mode from an connector
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
d2894 1
a2894 2
int drm_mode_detachmode_ioctl(struct drm_device *dev,
			      void *data, struct drm_file *file_priv)
d2896 1
a2896 6
	struct drm_mode_object *obj;
	struct drm_mode_mode_cmd *mode_cmd = data;
	struct drm_connector *connector;
	struct drm_display_mode mode;
	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
	int ret;
d2898 2
a2899 2
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;
d2901 4
a2904 1
	mutex_lock(&dev->mode_config.mutex);
d2906 1
a2906 6
	obj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	connector = obj_to_connector(obj);
d2908 2
a2909 4
	ret = drm_crtc_convert_umode(&mode, umode);
	if (ret) {
		DRM_DEBUG_KMS("Invalid mode\n");
		goto out;
d2911 1
a2911 5

	ret = drm_mode_detachmode(dev, connector, &mode);
out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
d3156 1
a3156 1
	mutex_lock(&dev->mode_config.mutex);
d3159 1
a3159 1
		ret = -EINVAL;
d3234 1
a3234 1
	mutex_unlock(&dev->mode_config.mutex);
d3285 1
a3285 1
	mutex_lock(&dev->mode_config.mutex);
d3288 1
a3288 1
		ret = -EINVAL;
d3303 1
a3303 1
	mutex_unlock(&dev->mode_config.mutex);
d3445 1
a3445 1
	mutex_lock(&dev->mode_config.mutex);
d3449 1
a3449 1
		ret = -EINVAL;
d3482 1
a3482 1
	mutex_unlock(&dev->mode_config.mutex);
d3499 1
a3499 1
	mutex_lock(&dev->mode_config.mutex);
d3502 2
a3503 1
	if (!arg_obj)
d3505 1
d3518 2
a3519 1
	if (!prop_obj)
d3521 1
d3541 1
a3541 1
	mutex_unlock(&dev->mode_config.mutex);
d3603 1
a3603 1
	mutex_lock(&dev->mode_config.mutex);
d3606 1
a3606 1
		ret = -EINVAL;
d3644 1
a3644 1
	mutex_unlock(&dev->mode_config.mutex);
d3662 1
a3662 1
	mutex_lock(&dev->mode_config.mutex);
d3665 1
a3665 1
		ret = -EINVAL;
d3695 1
a3695 1
	mutex_unlock(&dev->mode_config.mutex);
d3705 1
a3705 1
	struct drm_framebuffer *fb;
a3707 1
	int hdisplay, vdisplay;
d3714 1
a3714 2
	/* XXX always reject async until we have a newer drm version */
	if (page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC)
a3716 1
	mutex_lock(&dev->mode_config.mutex);
d3719 1
a3719 1
		goto out;
d3722 1
d3735 3
a3737 2
	obj = drm_mode_object_find(dev, page_flip->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj)
d3739 1
a3739 1
	fb = obj_to_fb(obj);
d3741 3
a3743 2
	hdisplay = crtc->mode.hdisplay;
	vdisplay = crtc->mode.vdisplay;
d3745 3
a3747 14
	if (crtc->invert_dimensions) {
		int tmp = hdisplay;
		hdisplay = vdisplay;
		vdisplay = tmp;
	}

	if (hdisplay > fb->width ||
	    vdisplay > fb->height ||
	    crtc->x > fb->width - hdisplay ||
	    crtc->y > fb->height - vdisplay) {
		DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
			      fb->width, fb->height, hdisplay, vdisplay, crtc->x, crtc->y,
			      crtc->invert_dimensions ? " (inverted)" : "");
		ret = -ENOSPC;
d3778 2
a3779 1
	ret = crtc->funcs->page_flip(crtc, fb, e);
d3787 12
d3802 6
a3807 1
	mutex_unlock(&dev->mode_config.mutex);
d3928 2
a3929 1
		DRM_DEBUG_KMS("unsupported pixel format\n");
d4077 118
@


1.16
log
@Add an empty drm_sysfs_hotplug_event() function and use it
and the existing drm_sysfs* functions to remove some ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.15 2015/04/06 08:14:00 kettenis Exp $	*/
d291 1
a291 1
		return NULL;
@


1.15
log
@Add get_user() and put_user() compatibility interfaces and use them.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.14 2015/04/05 13:04:41 kettenis Exp $	*/
a628 1
#ifdef __linux__
a633 1
#endif
@


1.14
log
@Consistently use #if 0/#endif to handle our lack of DRM_MINOR_CONTROL.
Change an #ifdef notyet into #ifdef __linux__ as we'll never have sysfs.
Remove #ifdef notyet around WARN macro since we have it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.13 2015/04/05 11:53:53 kettenis Exp $	*/
d1298 1
a1298 2
			if (copyout(&fb->base.id, fb_id + copied,
			    sizeof(fb->base.id)) != 0) {
d1317 1
a1317 2
				if (copyout(&crtc->base.id, crtc_id + copied,
				    sizeof(crtc->base.id)) != 0) {
d1326 2
a1327 3
				if (copyout(&mode_group->id_list[i],
				    crtc_id + copied,
				    sizeof(mode_group->id_list[i])) != 0) {
d1350 2
a1351 2
				if (copyout(&encoder->base.id, encoder_id +
				    copied, sizeof(encoder->base.id)) != 0) {
d1360 2
a1361 3
				if (copyout(&mode_group->id_list[i],
				    encoder_id + copied,
				    sizeof(mode_group->id_list[i])) != 0) {
d1386 2
a1387 3
				if (copyout(&connector->base.id,
				    connector_id + copied,
				    sizeof(connector->base.id)) != 0) {
d1398 2
a1399 3
				if (copyout(&mode_group->id_list[i],
				    connector_id + copied,
				    sizeof(mode_grou->id_list[i])) != 0) {
d1585 2
a1586 3
			if (copyout(&connector->properties.ids[i],
			    prop_ptr + copied,
			    sizeof(connector->properties.ids[i])) != 0) {
d1591 2
a1592 3
			if (copyout(&connector->properties.values[i],
			    prop_values + copied,
			    sizeof(connector->properties.values[i])) != 0) {
d1606 2
a1607 3
				if (copyout(&connector->encoder_ids[i],
				    encoder_ptr + copied,
				    sizeof(connector->encoder_ids[i])) != 0) {
d1691 1
a1691 2
			if (copyout(&plane->base.id, plane_ptr + copied,
			    sizeof(plane->base.id))) {
d2045 1
a2045 2
			if (copyin(&set_connectors_ptr[i], &out_id,
			    sizeof(out_id)) != 0) {
d3109 1
a3109 3
				if (copyout(&prop_blob->base.id,
				    blob_id_ptr + copied,
				    sizeof(prop_blob->base.id)) != 0) {
d3114 1
a3114 3
				if (copyout(&prop_blob->length,
				    blob_length_ptr + copied,
				    sizeof(prop_blob->length)) != 0) {
d3358 2
a3359 3
			if (copyout(&obj->properties->ids[i],
			    props_ptr + copied,
			    sizeof(obj->properties->ids[i])) != 0) {
d3363 2
a3364 3
			if (copyout(&obj->properties->values[i],
			    prop_values_ptr + copied,
			    sizeof(obj->properties->values[i])) != 0) {
@


1.13
log
@Another round of reducing diffs with Linux.  This one moves the various
copy_to_user and copy_from_user functions into drm_linux.h and uses them
instead of copyin/copyout and DRM_COPY_*.  Also move the timespec functions,
and put i915_gem_object_is_purgable() where it belongs.

Uncovered a bug where the arguments to copyout() were in the wrong order.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.12 2015/02/12 02:12:02 kettenis Exp $	*/
d629 1
a629 1
#ifdef notyet
a695 1

a1143 1
#ifdef notyet
a1149 1
#endif
d1312 3
a1314 1
		/* if (file_priv->master->minor->type == DRM_MINOR_CONTROL) { */
d1325 2
a1326 1
		/* } else {
d1336 2
a1337 1
		} */
@


1.12
log
@Add mutex_is_locked and use it wherever linux uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.11 2015/02/11 07:01:36 jsg Exp $	*/
d1575 2
a1576 2
			if (copyout(&u_mode, mode_ptr + copied,
			    sizeof(u_mode)) != 0) {
d1768 3
a1770 3
		if (copyout(format_ptr,
		    plane->format_types,
		    sizeof(uint32_t) * plane->format_count)) {
d2578 2
a2579 3
		ret = copyin(clips_ptr, clips,
		    num_clips * sizeof(*clips));

d3082 1
a3082 1
			if (copyout(&property->values[i], values_ptr + i, sizeof(uint64_t)) != 0) {
d3096 1
a3096 3
				if (copyout(&prop_enum->value,
				    &enum_ptr[copied].value,
				    sizeof(uint64_t)) != 0) {
d3101 2
a3102 3
				if (copyout(&prop_enum->name,
				    &enum_ptr[copied].name,
				    DRM_PROP_NAME_LEN) != 0) {
d3200 1
a3200 1
		if (copyout(blob->data, blob_ptr, blob->length) != 0) {
d3527 1
a3527 2
	if (copyin((void __user *)(unsigned long)crtc_lut->red,
	    r_base, size) != 0) {
d3533 1
a3533 2
	if (copyin((void __user *)(unsigned long)crtc_lut->green,
	    g_base, size) != 0) {
d3539 1
a3539 2
	if (copyin((void __user *)(unsigned long)crtc_lut->blue,
	    b_base, size) != 0) {
d3581 1
a3581 2
	if (copyout(r_base,
	    (void __user *)(unsigned long)crtc_lut->red, size) != 0) {
d3587 1
a3587 2
	if (copyout(g_base,
	    (void __user *)(unsigned long)crtc_lut->green, size) != 0) {
d3593 1
a3593 2
	if (copyout(b_base,
	    (void __user *)(unsigned long)crtc_lut->blue, size) != 0) {
@


1.11
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.10 2015/02/10 10:50:49 jsg Exp $	*/
d345 1
a345 1
//	struct drm_device *dev = fb->dev;
a346 1
#ifdef notyet
a347 1
#endif
@


1.10
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.9 2015/02/10 03:39:41 jsg Exp $	*/
d2994 1
a2994 1
		printf("Failed to attach object property (type: 0x%x). Please "
@


1.9
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.8 2014/03/09 11:07:18 jsg Exp $	*/
d3622 1
d3679 1
a3679 1
		mtx_enter(&dev->event_lock);
d3681 1
a3681 1
			mtx_leave(&dev->event_lock);
d3685 1
a3685 1
		mtx_leave(&dev->event_lock);
d3689 1
a3689 1
			mtx_enter(&dev->event_lock);
d3691 1
a3691 1
			mtx_leave(&dev->event_lock);
d3707 1
a3707 1
			mtx_enter(&dev->event_lock);
d3709 1
a3709 1
			mtx_leave(&dev->event_lock);
@


1.8
log
@use linux style memory allocations in shared drm code
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.7 2014/02/13 12:33:08 kettenis Exp $	*/
d463 1
a463 1
	rw_enter_write(&dev->mode_config.rwl);
d475 1
a475 1
	rw_exit_write(&dev->mode_config.rwl);
d562 1
a562 1
	rw_enter_write(&dev->mode_config.rwl);
d592 1
a592 1
	rw_exit_write(&dev->mode_config.rwl);
d621 1
a621 1
	rw_enter_write(&dev->mode_config.rwl);
d625 1
a625 1
	rw_exit_write(&dev->mode_config.rwl);
d648 1
a648 1
	rw_enter_write(&dev->mode_config.rwl);
d662 1
a662 1
	rw_exit_write(&dev->mode_config.rwl);
d671 1
a671 1
	rw_enter_write(&dev->mode_config.rwl);
d675 1
a675 1
	rw_exit_write(&dev->mode_config.rwl);
d687 1
a687 1
	rw_enter_write(&dev->mode_config.rwl);
d722 1
a722 1
	rw_exit_write(&dev->mode_config.rwl);
d732 1
a732 1
	rw_enter_write(&dev->mode_config.rwl);
d740 1
a740 1
	rw_exit_write(&dev->mode_config.rwl);
d1013 1
a1013 1
	rw_init(&dev->mode_config.rwl, "mcrwl");
d1024 1
a1024 1
	rw_enter_write(&dev->mode_config.rwl);
d1026 1
a1026 1
	rw_exit_write(&dev->mode_config.rwl);
d1261 1
a1261 1
	rw_enter_write(&dev->mode_config.rwl);
d1421 1
a1421 1
	rw_exit_write(&dev->mode_config.rwl);
d1453 1
a1453 1
	rw_enter_write(&dev->mode_config.rwl);
d1481 1
a1481 1
	rw_exit_write(&dev->mode_config.rwl);
d1528 1
a1528 1
	rw_enter_write(&dev->mode_config.rwl);
d1628 1
a1628 1
	rw_exit_write(&dev->mode_config.rwl);
d1643 1
a1643 1
	rw_enter_write(&dev->mode_config.rwl);
d1662 1
a1662 1
	rw_exit_write(&dev->mode_config.rwl);
d1689 1
a1689 1
	rw_enter_write(&dev->mode_config.rwl);
d1712 1
a1712 1
	rw_exit_write(&dev->mode_config.rwl);
d1740 1
a1740 1
	rw_enter_write(&dev->mode_config.rwl);
d1780 1
a1780 1
	rw_exit_write(&dev->mode_config.rwl);
d1811 1
a1811 1
	rw_enter_write(&dev->mode_config.rwl);
d1910 1
a1910 1
	rw_exit_write(&dev->mode_config.rwl);
d1954 1
a1954 1
	rw_enter_write(&dev->mode_config.rwl);
d2091 1
a2091 1
	rw_exit_write(&dev->mode_config.rwl);
d2109 1
a2109 1
	rw_enter_write(&dev->mode_config.rwl);
d2137 1
a2137 1
	rw_exit_write(&dev->mode_config.rwl);
d2220 1
a2220 1
	rw_enter_write(&dev->mode_config.rwl);
d2237 1
a2237 1
	rw_exit_write(&dev->mode_config.rwl);
d2409 1
a2409 1
	rw_enter_write(&dev->mode_config.rwl);
d2423 1
a2423 1
	rw_exit_write(&dev->mode_config.rwl);
d2457 1
a2457 1
	rw_enter_write(&dev->mode_config.rwl);
d2478 1
a2478 1
	rw_exit_write(&dev->mode_config.rwl);
d2510 1
a2510 1
	rw_enter_write(&dev->mode_config.rwl);
d2526 1
a2526 1
	rw_exit_write(&dev->mode_config.rwl);
d2545 1
a2545 1
	rw_enter_write(&dev->mode_config.rwl);
d2600 1
a2600 1
	rw_exit_write(&dev->mode_config.rwl);
d2623 1
a2623 1
	rw_enter_write(&dev->mode_config.rwl);
d2627 1
a2627 1
	rw_exit_write(&dev->mode_config.rwl);
d2743 1
a2743 1
	rw_enter_write(&dev->mode_config.rwl);
d2767 1
a2767 1
	rw_exit_write(&dev->mode_config.rwl);
d2797 1
a2797 1
	rw_enter_write(&dev->mode_config.rwl);
d2814 1
a2814 1
	rw_exit_write(&dev->mode_config.rwl);
d3060 1
a3060 1
	rw_enter_write(&dev->mode_config.rwl);
d3145 1
a3145 1
	rw_exit_write(&dev->mode_config.rwl);
d3196 1
a3196 1
	rw_enter_write(&dev->mode_config.rwl);
d3214 1
a3214 1
	rw_exit_write(&dev->mode_config.rwl);
d3356 1
a3356 1
	rw_enter_write(&dev->mode_config.rwl);
d3395 1
a3395 1
	rw_exit_write(&dev->mode_config.rwl);
d3412 1
a3412 1
	rw_enter_write(&dev->mode_config.rwl);
d3450 1
a3450 1
	rw_exit_write(&dev->mode_config.rwl);
d3512 1
a3512 1
	rw_enter_write(&dev->mode_config.rwl);
d3556 1
a3556 1
	rw_exit_write(&dev->mode_config.rwl);
d3574 1
a3574 1
	rw_enter_write(&dev->mode_config.rwl);
d3610 1
a3610 1
	rw_exit_write(&dev->mode_config.rwl);
d3633 1
a3633 1
	rw_enter_write(&dev->mode_config.rwl);
d3714 1
a3714 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.7
log
@Make sure we copy out the right amount of data in the various copyout() calls
that replace the put_user() calls in the Linux code by using sizeof on the
appropriate variables instead of explicit uint32_t/uint64_t types.  Fixes a
case where we accidentally copied out only 32 bits of a 64-bit value,
uncovered by xf86-video-intel 2.99.909.

ok jsg@@, matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.6 2014/01/18 08:25:06 jsg Exp $	*/
d495 2
a496 4
	if (crtc->gamma_store) {
		free(crtc->gamma_store, M_DRM);
		crtc->gamma_store = NULL;
	}
d696 2
a697 2
	plane->format_types = malloc(sizeof(uint32_t) * format_count,
	    M_DRM, M_WAITOK);
d733 1
a733 1
	free(plane->format_types, M_DRM);
d760 1
a760 1
	nmode = malloc(sizeof(struct drm_display_mode), M_DRM, M_WAITOK|M_ZERO);
d765 1
a765 1
		free(nmode, M_DRM);
d790 1
a790 1
	free(mode, M_DRM);
d1044 1
a1044 2
	group->id_list = malloc(total_objects * sizeof(uint32_t),
	    M_DRM, M_WAITOK|M_ZERO);
d2046 1
a2046 1
		connector_set = malloc(crtc_req->count_connectors *
d2048 1
a2048 1
		    M_DRM, M_WAITOK);
d2089 1
a2089 2
	if (connector_set != NULL)
		free(connector_set, M_DRM);
d2574 1
a2574 2
		clips = malloc(num_clips * sizeof(*clips), M_DRM,
		    M_WAITOK|M_ZERO);
d2598 1
a2598 1
	free(clips, M_DRM);
d2824 1
a2824 1
	property = malloc(sizeof(struct drm_property), M_DRM, M_WAITOK|M_ZERO);
d2829 1
a2829 2
		property->values = malloc(sizeof(uint64_t)*num_values,
		    M_DRM, M_WAITOK|M_ZERO);
d2850 2
a2851 2
	free(property->values, M_DRM);
	free(property, M_DRM);
d2956 1
a2956 2
	prop_enum = malloc(sizeof(struct drm_property_enum), M_DRM,
	    M_WAITOK | M_ZERO);
d2976 1
a2976 1
		free(prop_enum, M_DRM);
d2980 1
a2980 1
		free(property->values, M_DRM);
d2983 1
a2983 1
	free(property, M_DRM);
d3158 1
a3158 2
	blob = malloc(sizeof(struct drm_property_blob)+length,
	    M_DRM, M_WAITOK|M_ZERO);
d3164 1
a3164 1
		free(blob, M_DRM);
d3181 1
a3181 1
	free(blob, M_DRM);
d3489 1
a3489 2
	crtc->gamma_store = malloc(gamma_size * sizeof(uint16_t) * 3,
	    M_DRM, M_WAITOK|M_ZERO);
d3686 1
a3686 1
		e = malloc(sizeof *e, M_DRM, M_WAITOK|M_ZERO);
d3700 1
a3700 1
			(void (*) (struct drm_pending_event *)) drm_free;
d3709 1
a3709 1
			free(e, M_DRM);
@


1.6
log
@Update the drm headers based on libdrm 2.4.51
but make sure we still reject DRM_MODE_PAGE_FLIP_ASYNC.

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.5 2013/12/16 19:57:08 kettenis Exp $	*/
d1367 3
a1369 2
				if (copyout(&mode_group->id_list[i]
				    encoder_id + copied, sizeof(uint32_t)) != 0) {
d1409 1
a1409 1
				    sizeof(uint32_t)) != 0) {
d1597 1
a1597 1
			    sizeof(uint32_t)) != 0) {
d1604 1
a1604 1
			    sizeof(uint32_t)) != 0) {
d1705 1
a1705 1
			    sizeof(uint32_t))) {
@


1.5
log
@Switch generic drm modesetting code over to Linux-style negative errno
return values.  Fixes at least one bug where userland would see a negative
errno value and hopefully doesn't introduce any new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.4 2013/12/15 22:09:37 kettenis Exp $	*/
d3635 4
@


1.4
log
@Fix error handling of ->fb_create() call.  Prevents kernel panic if an
unsupported frame buffer configuration is requested.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.3 2013/09/02 10:18:26 jsg Exp $	*/
d234 1
a234 1
		return ENOMEM;
d704 1
a704 1
		ret = ENOMEM;
d1049 1
a1049 1
		return ENOMEM;
d1195 1
a1195 1
		return ERANGE;
d1262 1
a1262 1
		return EINVAL;
d1308 1
a1308 1
				ret = EFAULT;
d1326 1
a1326 1
					ret = EFAULT;
d1336 1
a1336 1
					ret = EFAULT;
d1359 1
a1359 1
					ret = EFAULT;
d1369 1
a1369 1
					ret = EFAULT;
d1396 1
a1396 1
					ret = EFAULT;
d1409 1
a1409 1
					ret = EFAULT;
d1453 1
a1453 1
		return EINVAL;
d1460 1
a1460 1
		ret = EINVAL;
d1524 1
a1524 1
		return EINVAL;
d1535 1
a1535 1
		ret = EINVAL;
d1581 1
a1581 1
				ret = EFAULT;
d1597 1
a1597 1
				ret = EFAULT;
d1604 1
a1604 1
				ret = EFAULT;
d1620 1
a1620 1
					ret = EFAULT;
d1643 1
a1643 1
		return EINVAL;
d1649 1
a1649 1
		ret = EINVAL;
d1689 1
a1689 1
		return EINVAL;
d1705 1
a1705 1
				ret = EFAULT;
d1740 1
a1740 1
		return EINVAL;
d1746 1
a1746 1
		ret = ENOENT;
d1775 1
a1775 1
			ret = EFAULT;
d1811 1
a1811 1
		return EINVAL;
d1824 1
a1824 1
		ret = ENOENT;
d1842 1
a1842 1
		ret = ENOENT;
d1852 1
a1852 1
		ret = ENOENT;
d1863 1
a1863 1
		ret = EINVAL;
d1885 1
a1885 1
		ret = ENOSPC;
d1897 1
a1897 1
		ret = ERANGE;
d1950 1
a1950 1
		return EINVAL;
d1954 1
a1954 1
		return ERANGE;
d1961 1
a1961 1
		ret = EINVAL;
d1974 1
a1974 1
				ret = EINVAL;
d1984 1
a1984 1
				ret = EINVAL;
d1992 1
a1992 1
			ret = ENOMEM;
d2021 1
a2021 1
			ret = ENOSPC;
d2028 1
a2028 1
		ret = EINVAL;
d2035 1
a2035 1
		ret = EINVAL;
d2044 1
a2044 1
			ret = EINVAL;
d2052 1
a2052 1
			ret = ENOMEM;
d2060 1
a2060 1
				ret = EFAULT;
d2069 1
a2069 1
				ret = EINVAL;
d2107 1
a2107 1
		return EINVAL;
d2110 1
a2110 1
		return EINVAL;
d2116 1
a2116 1
		ret = EINVAL;
d2123 1
a2123 1
			ret = ENXIO;
d2135 1
a2135 1
			ret = EFAULT;
d2215 1
a2215 1
		return EINVAL;
d2218 1
a2218 1
		return EINVAL;
d2221 1
a2221 1
		return EINVAL;
d2231 1
a2231 1
		ret = -PTR_ERR(fb);
d2311 1
a2311 1
		return EINVAL;
d2331 1
a2331 1
		return EINVAL;
d2336 1
a2336 1
		return EINVAL;
d2346 1
a2346 1
			return EINVAL;
d2350 1
a2350 1
			return ERANGE;
d2353 1
a2353 1
			return ERANGE;
d2357 1
a2357 1
			return EINVAL;
d2390 1
a2390 1
		return EINVAL;
d2394 1
a2394 1
		return EINVAL;
d2400 1
a2400 1
		return EINVAL;
d2405 1
a2405 1
		return EINVAL;
d2417 1
a2417 1
		ret = -PTR_ERR(fb);
d2458 1
a2458 1
		return EINVAL;
d2464 1
a2464 1
		ret = EINVAL;
d2474 1
a2474 1
		ret = EINVAL;
d2511 1
a2511 1
		return EINVAL;
d2516 1
a2516 1
		ret = EINVAL;
d2546 1
a2546 1
		return EINVAL;
d2551 1
a2551 1
		ret = EINVAL;
d2560 1
a2560 1
		ret = EINVAL;
d2568 1
a2568 1
		ret = EINVAL;
d2574 1
a2574 1
			ret = EINVAL;
d2580 1
a2580 1
			ret = ENOMEM;
d2588 1
a2588 1
			ret = EFAULT;
d2597 1
a2597 1
		ret = ENOSYS;
d2663 1
a2663 1
				ret = ENOMEM;
d2705 1
a2705 1
		ret = EINVAL;
d2745 1
a2745 1
		return EINVAL;
d2751 1
a2751 1
		ret = EINVAL;
d2758 1
a2758 1
		ret = ENOMEM;
d2799 1
a2799 1
		return EINVAL;
d2805 1
a2805 1
		ret = EINVAL;
d2942 1
a2942 1
		return EINVAL;
d2949 1
a2949 1
		return EINVAL;
d2964 1
a2964 1
		return ENOMEM;
d3025 1
a3025 1
	return EINVAL;
d3041 1
a3041 1
	return EINVAL;
d3064 1
a3064 1
		return EINVAL;
d3069 1
a3069 1
		ret = EINVAL;
d3092 1
a3092 1
				ret = EFAULT;
d3108 1
a3108 1
					ret = EFAULT;
d3115 1
a3115 1
					ret = EFAULT;
d3134 1
a3134 1
					ret = EFAULT;
d3141 1
a3141 1
					ret = EFAULT;
d3201 1
a3201 1
		return EINVAL;
d3206 1
a3206 1
		ret = EINVAL;
d3214 1
a3214 1
			ret = EFAULT;
d3245 1
a3245 1
		return EINVAL;
d3301 1
a3301 1
	int ret = EINVAL;
d3322 1
a3322 1
	int ret = EINVAL;
d3337 1
a3337 1
	int ret = EINVAL;
d3361 1
a3361 1
		return EINVAL;
d3367 1
a3367 1
		ret = EINVAL;
d3371 1
a3371 1
		ret = EINVAL;
d3388 1
a3388 1
				ret = EFAULT;
d3394 1
a3394 1
				ret = EFAULT;
d3413 1
a3413 1
	int ret = EINVAL;
d3417 1
a3417 1
		return EINVAL;
d3472 1
a3472 1
	return ENOMEM;
d3500 1
a3500 1
		return ENOMEM;
d3518 1
a3518 1
		return EINVAL;
d3523 1
a3523 1
		ret = EINVAL;
d3529 1
a3529 1
		ret = ENOSYS;
d3535 1
a3535 1
		ret = EINVAL;
d3543 1
a3543 1
		ret = EFAULT;
d3550 1
a3550 1
		ret = EFAULT;
d3557 1
a3557 1
		ret = EFAULT;
d3580 1
a3580 1
		return EINVAL;
d3585 1
a3585 1
		ret = EINVAL;
d3592 1
a3592 1
		ret = EINVAL;
d3600 1
a3600 1
		ret = EFAULT;
d3607 1
a3607 1
		ret = EFAULT;
d3614 1
a3614 1
		ret = EFAULT;
d3631 1
a3631 1
	int ret = EINVAL;
d3635 1
a3635 1
		return EINVAL;
d3648 1
a3648 1
		ret = EBUSY;
d3676 1
a3676 1
		ret = ENOSPC;
d3681 1
a3681 1
		ret = ENOMEM;
d3751 1
a3751 1
		return ENOSYS;
d3762 1
a3762 1
		return ENOSYS;
d3773 1
a3773 1
		return ENOSYS;
@


1.3
log
@fb refcount must be initialised to 1 not 0 to match the behaviour
of the linux kref functions.

Switch to using the FreeBSD refcount api for the fb refcount while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.2 2013/09/02 06:25:27 jsg Exp $	*/
d2229 1
a2229 1
	if (fb == NULL) {
d2231 1
d2415 1
a2415 1
	if (fb == NULL) {
d2417 1
@


1.2
log
@add static back to functions that originally had it
reduces the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
d37 1
d317 1
a317 1
	fb->refcount = 0;
d350 1
a350 1
	if (--fb->refcount == 0)
d361 1
a361 1
	fb->refcount++;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 28
void	 drm_crtc_convert_to_umode(struct drm_mode_modeinfo *,
	     const struct drm_display_mode *);
int	 drm_mode_handle_cmp(struct drm_mode_handle *,
	     struct drm_mode_handle *);
int	 drm_crtc_convert_umode(struct drm_display_mode *,
	     const struct drm_mode_modeinfo *);
int	 drm_mode_object_get(struct drm_device *, struct drm_mode_object *,
	     uint32_t);
void	 drm_mode_object_put(struct drm_device *, struct drm_mode_object *);
int	 drm_mode_create_standard_connector_properties(struct drm_device *);
void	 drm_mode_attachmode(struct drm_device *, struct drm_connector *,
	     struct drm_display_mode *);
int	 drm_mode_detachmode(struct drm_device *, struct drm_connector *,
	     struct drm_display_mode *);
struct drm_property_blob	*drm_property_create_blob(struct drm_device *,
				     int, void *);
void	 drm_property_destroy_blob(struct drm_device *,
	     struct drm_property_blob *);
int	 format_check(const struct drm_mode_fb_cmd2 *);
int	 framebuffer_check(const struct drm_mode_fb_cmd2 *);
bool	 drm_property_change_is_valid(struct drm_property *, uint64_t);
int	 drm_mode_connector_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
int	 drm_mode_crtc_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
int	 drm_mode_plane_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
void	 drm_framebuffer_free(struct drm_framebuffer *);
d226 1
a226 2
int
drm_mode_object_get(struct drm_device *dev,
d262 1
a262 2
void
drm_mode_object_put(struct drm_device *dev,
d274 1
a274 2
struct drm_mode_object *
drm_mode_object_find(struct drm_device *dev,
d311 1
a311 2
int
drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,
d331 1
a331 2
void
drm_framebuffer_free(struct drm_framebuffer *fb)
d342 1
a342 2
void
drm_framebuffer_unreference(struct drm_framebuffer *fb)
d357 1
a357 2
void
drm_framebuffer_reference(struct drm_framebuffer *fb)
d374 1
a374 2
void
drm_framebuffer_cleanup(struct drm_framebuffer *fb)
d400 1
a400 2
void
drm_framebuffer_remove(struct drm_framebuffer *fb)
d453 1
a453 2
int
drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
d490 1
a490 2
void
drm_crtc_cleanup(struct drm_crtc *crtc)
d515 1
a515 2
void
drm_mode_probed_add(struct drm_connector *connector,
d532 1
a532 2
void
drm_mode_remove(struct drm_connector *connector,
d556 1
a556 2
int
drm_connector_init(struct drm_device *dev,
d608 1
a608 2
void
drm_connector_cleanup(struct drm_connector *connector)
d630 1
a630 2
void
drm_connector_unplug_all(struct drm_device *dev)
d642 1
a642 2
int
drm_encoder_init(struct drm_device *dev,
d669 1
a669 2
void
drm_encoder_cleanup(struct drm_encoder *encoder)
d680 1
a680 2
int
drm_plane_init(struct drm_device *dev, struct drm_plane *plane,
d729 1
a729 2
void
drm_plane_cleanup(struct drm_plane *plane)
d757 1
a757 2
struct drm_display_mode *
drm_mode_create(struct drm_device *dev)
d784 1
a784 2
void
drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
d795 1
a795 2
int
drm_mode_create_standard_connector_properties(struct drm_device *dev)
d822 1
a822 2
int
drm_mode_create_dvi_i_properties(struct drm_device *dev)
d858 1
a858 2
int
drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,
d935 1
a935 2
int
drm_mode_create_scaling_mode_property(struct drm_device *dev)
d960 1
a960 2
int
drm_mode_create_dithering_property(struct drm_device *dev)
d984 1
a984 2
int
drm_mode_create_dirty_info_property(struct drm_device *dev)
d1012 1
a1012 2
void
drm_mode_config_init(struct drm_device *dev)
d1037 1
a1037 2
int
drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
d1056 1
a1056 2
int
drm_mode_group_init_legacy_group(struct drm_device *dev,
d1094 1
a1094 2
void
drm_mode_config_cleanup(struct drm_device *dev)
d1146 1
a1146 2
void
drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,
d1190 1
a1190 2
int
drm_crtc_convert_umode(struct drm_display_mode *out,
d1234 1
a1234 2
int
drm_mode_getresources(struct drm_device *dev, void *data,
d1443 1
a1443 2
int
drm_mode_getcrtc(struct drm_device *dev,
d1503 1
a1503 2
int
drm_mode_getconnector(struct drm_device *dev, void *data,
d1633 1
a1633 2
int
drm_mode_getencoder(struct drm_device *dev, void *data,
d1678 1
a1678 2
int
drm_mode_getplane_res(struct drm_device *dev, void *data,
d1729 1
a1729 2
int
drm_mode_getplane(struct drm_device *dev, void *data,
d1797 1
a1797 2
int
drm_mode_setplane(struct drm_device *dev, void *data,
d1933 1
a1933 2
int
drm_mode_setcrtc(struct drm_device *dev, void *data,
d2097 1
a2097 2
int
drm_mode_cursor_ioctl(struct drm_device *dev,
d2144 1
a2144 2
uint32_t
drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth)
d2196 1
a2196 2
int
drm_mode_addfb(struct drm_device *dev,
d2242 1
a2242 2
int
format_check(const struct drm_mode_fb_cmd2 *r)
d2313 1
a2313 2
int
framebuffer_check(const struct drm_mode_fb_cmd2 *r)
d2379 1
a2379 2
int
drm_mode_addfb2(struct drm_device *dev,
d2444 1
a2444 2
int
drm_mode_rmfb(struct drm_device *dev,
d2499 1
a2499 2
int
drm_mode_getfb(struct drm_device *dev,
d2530 1
a2530 2
int
drm_mode_dirtyfb_ioctl(struct drm_device *dev,
d2620 1
a2620 2
void
drm_fb_release(struct drm_device *dev, struct drm_file *priv)
d2639 1
a2639 2
void
drm_mode_attachmode(struct drm_device *dev,
d2646 1
a2646 2
int
drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
d2684 1
a2684 2
int
drm_mode_detachmode(struct drm_device *dev,
d2707 1
a2707 2
int
drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
d2731 1
a2731 2
int
drm_mode_attachmode_ioctl(struct drm_device *dev,
d2785 1
a2785 2
int
drm_mode_detachmode_ioctl(struct drm_device *dev,
d2819 1
a2819 2
struct drm_property *
drm_property_create(struct drm_device *dev, int flags,
d2858 1
a2858 2
struct drm_property *
drm_property_create_enum(struct drm_device *dev, int flags,
d2886 1
a2886 2
struct drm_property *
drm_property_create_bitmask(struct drm_device *dev,
d2914 1
a2914 2
struct drm_property *
drm_property_create_range(struct drm_device *dev, int flags,
d2933 1
a2933 2
int
drm_property_add_enum(struct drm_property *property, int index,
d2973 1
a2973 2
void
drm_property_destroy(struct drm_device *dev, struct drm_property *property)
d2990 1
a2990 2
void
drm_object_attach_property(struct drm_mode_object *obj,
d3010 1
a3010 2
int
drm_object_property_set_value(struct drm_mode_object *obj,
d3026 1
a3026 2
int
drm_object_property_get_value(struct drm_mode_object *obj,
d3042 1
a3042 2
int
drm_mode_getproperty_ioctl(struct drm_device *dev,
d3152 1
a3152 2
struct drm_property_blob *
drm_property_create_blob(struct drm_device *dev, int length,
d3180 1
a3180 2
void
drm_property_destroy_blob(struct drm_device *dev,
d3188 1
a3188 2
int
drm_mode_getblob_ioctl(struct drm_device *dev,
d3222 1
a3222 2
int
drm_mode_connector_update_edid_property(struct drm_connector *connector,
d3252 1
a3252 2
bool
drm_property_change_is_valid(struct drm_property *property,
d3279 1
a3279 2
int
drm_mode_connector_property_set_ioctl(struct drm_device *dev,
d3294 1
a3294 2
int
drm_mode_connector_set_obj_prop(struct drm_mode_object *obj,
d3315 1
a3315 2
int
drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,
d3330 1
a3330 2
int
drm_mode_plane_set_obj_prop(struct drm_mode_object *obj,
d3345 1
a3345 2
int
drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
d3403 1
a3403 2
int
drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
d3458 1
a3458 2
int
drm_mode_connector_attach_encoder(struct drm_connector *connector,
d3473 1
a3473 2
void
drm_mode_connector_detach_encoder(struct drm_connector *connector,
d3488 1
a3488 2
int
drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
d3504 1
a3504 2
int
drm_mode_gamma_set_ioctl(struct drm_device *dev,
d3566 1
a3566 2
int
drm_mode_gamma_get_ioctl(struct drm_device *dev,
d3619 1
a3619 2
int
drm_mode_page_flip_ioctl(struct drm_device *dev,
d3719 1
a3719 2
void
drm_mode_config_reset(struct drm_device *dev)
d3742 1
a3742 2
int
drm_mode_create_dumb_ioctl(struct drm_device *dev,
d3752 1
a3752 2
int
drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
d3764 1
a3764 2
int
drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
d3779 1
a3779 2
void
drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
d3851 1
a3851 2
int
drm_format_num_planes(uint32_t format)
d3886 1
a3886 2
int
drm_format_plane_cpp(uint32_t format, int plane)
d3933 1
a3933 2
int 
drm_format_horz_chroma_subsampling(uint32_t format)
d3968 1
a3968 2
int
drm_format_vert_chroma_subsampling(uint32_t format)
@

