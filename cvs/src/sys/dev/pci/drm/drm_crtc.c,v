head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.4
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.23.0.6
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.26
date	2017.07.12.20.12.19;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	63xYTpLuz3Z38Pwu;

1.25
date	2017.07.01.16.00.25;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	aN6GlSqZJXG1gx72;

1.24
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.23;
commitid	GnoPKa34InShCqYl;

1.23
date	2016.04.08.08.27.53;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	mS4ttEBzpAfn3sVx;

1.22
date	2016.04.07.20.33.24;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	b7TUPgWhn5cou224;

1.21
date	2016.04.06.21.12.40;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	QO3FDEetxShNl6Ad;

1.20
date	2016.04.06.14.39.19;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	3RYGzl8Nwjgc2QjX;

1.19
date	2015.09.27.11.09.26;	author jsg;	state Exp;
branches;
next	1.18;
commitid	OkoKp05dU7tP7DK3;

1.18
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.17;
commitid	lQlppvmETCN49oZe;

1.17
date	2015.05.05.02.01.10;	author jsg;	state Exp;
branches;
next	1.16;
commitid	IzDhD51qtTqJ1S80;

1.16
date	2015.04.06.09.23.19;	author jsg;	state Exp;
branches;
next	1.15;
commitid	99nej6bpjNHMCLwr;

1.15
date	2015.04.06.08.14.00;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	3FenpHSGCnS2uSz0;

1.14
date	2015.04.05.13.04.41;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	QduPwqvNJHSeaWl5;

1.13
date	2015.04.05.11.53.53;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	3YXcRggXXMDC9Cpg;

1.12
date	2015.02.12.02.12.02;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	cYXtgYH6nnLqDRGU;

1.11
date	2015.02.11.07.01.36;	author jsg;	state Exp;
branches;
next	1.10;
commitid	dLgISW35NAmGN8Xl;

1.10
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.9;
commitid	aHLMSW1RfE1rmMw9;

1.9
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.8;
commitid	C5l5rZ5v9mpRR1eS;

1.8
date	2014.03.09.11.07.18;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.02.13.12.33.08;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.18.08.25.06;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.12.16.19.57.08;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.12.15.22.09.37;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.02.10.18.26;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.09.02.06.25.27;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Add a "Backlight" property to connectors with an associated backlight
controller for the inteldrm(4) driver.  If wscons(4) provides backlight
control, prefer ir over raw hardware control and attach it to LVDS, eDP
and DSI connectors which are the connector types typically connected to
laptop screens.
@
text
@/*
 * Copyright (c) 2006-2008 Intel Corporation
 * Copyright (c) 2007 Dave Airlie <airlied@@linux.ie>
 * Copyright (c) 2008 Red Hat Inc.
 *
 * DRM core CRTC related functions
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Authors:
 *      Keith Packard
 *	Eric Anholt <eric@@anholt.net>
 *      Dave Airlie <airlied@@linux.ie>
 *      Jesse Barnes <jesse.barnes@@intel.com>
 */
#ifdef __linux__
#include <linux/ctype.h>
#include <linux/list.h>
#include <linux/slab.h>
#include <linux/export.h>
#endif
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_edid.h>
#include <dev/pci/drm/drm_fourcc.h>
#include <dev/pci/drm/drm_modeset_lock.h>
#include <dev/pci/drm/drm_atomic.h>

#include "drm_crtc_internal.h"
#include "drm_internal.h"

static struct drm_framebuffer *
internal_framebuffer_create(struct drm_device *dev,
			    struct drm_mode_fb_cmd2 *r,
			    struct drm_file *file_priv);

/* Avoid boilerplate.  I'm tired of typing. */
#define DRM_ENUM_NAME_FN(fnname, list)				\
	const char *fnname(int val)				\
	{							\
		int i;						\
		for (i = 0; i < ARRAY_SIZE(list); i++) {	\
			if (list[i].type == val)		\
				return list[i].name;		\
		}						\
		return "(unknown)";				\
	}

/*
 * Global properties
 */
static const struct drm_prop_enum_list drm_dpms_enum_list[] = {
	{ DRM_MODE_DPMS_ON, "On" },
	{ DRM_MODE_DPMS_STANDBY, "Standby" },
	{ DRM_MODE_DPMS_SUSPEND, "Suspend" },
	{ DRM_MODE_DPMS_OFF, "Off" }
};

DRM_ENUM_NAME_FN(drm_get_dpms_name, drm_dpms_enum_list)

static const struct drm_prop_enum_list drm_plane_type_enum_list[] = {
	{ DRM_PLANE_TYPE_OVERLAY, "Overlay" },
	{ DRM_PLANE_TYPE_PRIMARY, "Primary" },
	{ DRM_PLANE_TYPE_CURSOR, "Cursor" },
};

/*
 * Optional properties
 */
static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] = {
	{ DRM_MODE_SCALE_NONE, "None" },
	{ DRM_MODE_SCALE_FULLSCREEN, "Full" },
	{ DRM_MODE_SCALE_CENTER, "Center" },
	{ DRM_MODE_SCALE_ASPECT, "Full aspect" },
};

static const struct drm_prop_enum_list drm_aspect_ratio_enum_list[] = {
	{ DRM_MODE_PICTURE_ASPECT_NONE, "Automatic" },
	{ DRM_MODE_PICTURE_ASPECT_4_3, "4:3" },
	{ DRM_MODE_PICTURE_ASPECT_16_9, "16:9" },
};

/*
 * Non-global properties, but "required" for certain connectors.
 */
static const struct drm_prop_enum_list drm_dvi_i_select_enum_list[] = {
	{ DRM_MODE_SUBCONNECTOR_Automatic, "Automatic" }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_DVID,      "DVI-D"     }, /* DVI-I  */
	{ DRM_MODE_SUBCONNECTOR_DVIA,      "DVI-A"     }, /* DVI-I  */
};

DRM_ENUM_NAME_FN(drm_get_dvi_i_select_name, drm_dvi_i_select_enum_list)

static const struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] = {
	{ DRM_MODE_SUBCONNECTOR_Unknown,   "Unknown"   }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_DVID,      "DVI-D"     }, /* DVI-I  */
	{ DRM_MODE_SUBCONNECTOR_DVIA,      "DVI-A"     }, /* DVI-I  */
};

DRM_ENUM_NAME_FN(drm_get_dvi_i_subconnector_name,
		 drm_dvi_i_subconnector_enum_list)

static const struct drm_prop_enum_list drm_tv_select_enum_list[] = {
	{ DRM_MODE_SUBCONNECTOR_Automatic, "Automatic" }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_Composite, "Composite" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SVIDEO,    "SVIDEO"    }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_Component, "Component" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SCART,     "SCART"     }, /* TV-out */
};

DRM_ENUM_NAME_FN(drm_get_tv_select_name, drm_tv_select_enum_list)

static const struct drm_prop_enum_list drm_tv_subconnector_enum_list[] = {
	{ DRM_MODE_SUBCONNECTOR_Unknown,   "Unknown"   }, /* DVI-I and TV-out */
	{ DRM_MODE_SUBCONNECTOR_Composite, "Composite" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SVIDEO,    "SVIDEO"    }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_Component, "Component" }, /* TV-out */
	{ DRM_MODE_SUBCONNECTOR_SCART,     "SCART"     }, /* TV-out */
};

DRM_ENUM_NAME_FN(drm_get_tv_subconnector_name,
		 drm_tv_subconnector_enum_list)

static const struct drm_prop_enum_list drm_dirty_info_enum_list[] = {
	{ DRM_MODE_DIRTY_OFF,      "Off"      },
	{ DRM_MODE_DIRTY_ON,       "On"       },
	{ DRM_MODE_DIRTY_ANNOTATE, "Annotate" },
};

struct drm_conn_prop_enum_list {
	int type;
	const char *name;
	struct ida ida;
};

/*
 * Connector and encoder types.
 */
static struct drm_conn_prop_enum_list drm_connector_enum_list[] = {
	{ DRM_MODE_CONNECTOR_Unknown, "Unknown" },
	{ DRM_MODE_CONNECTOR_VGA, "VGA" },
	{ DRM_MODE_CONNECTOR_DVII, "DVI-I" },
	{ DRM_MODE_CONNECTOR_DVID, "DVI-D" },
	{ DRM_MODE_CONNECTOR_DVIA, "DVI-A" },
	{ DRM_MODE_CONNECTOR_Composite, "Composite" },
	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO" },
	{ DRM_MODE_CONNECTOR_LVDS, "LVDS" },
	{ DRM_MODE_CONNECTOR_Component, "Component" },
	{ DRM_MODE_CONNECTOR_9PinDIN, "DIN" },
	{ DRM_MODE_CONNECTOR_DisplayPort, "DP" },
	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI-A" },
	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI-B" },
	{ DRM_MODE_CONNECTOR_TV, "TV" },
	{ DRM_MODE_CONNECTOR_eDP, "eDP" },
	{ DRM_MODE_CONNECTOR_VIRTUAL, "Virtual" },
	{ DRM_MODE_CONNECTOR_DSI, "DSI" },
};

static const struct drm_prop_enum_list drm_encoder_enum_list[] = {
	{ DRM_MODE_ENCODER_NONE, "None" },
	{ DRM_MODE_ENCODER_DAC, "DAC" },
	{ DRM_MODE_ENCODER_TMDS, "TMDS" },
	{ DRM_MODE_ENCODER_LVDS, "LVDS" },
	{ DRM_MODE_ENCODER_TVDAC, "TV" },
	{ DRM_MODE_ENCODER_VIRTUAL, "Virtual" },
	{ DRM_MODE_ENCODER_DSI, "DSI" },
	{ DRM_MODE_ENCODER_DPMST, "DP MST" },
};

static const struct drm_prop_enum_list drm_subpixel_enum_list[] = {
	{ SubPixelUnknown, "Unknown" },
	{ SubPixelHorizontalRGB, "Horizontal RGB" },
	{ SubPixelHorizontalBGR, "Horizontal BGR" },
	{ SubPixelVerticalRGB, "Vertical RGB" },
	{ SubPixelVerticalBGR, "Vertical BGR" },
	{ SubPixelNone, "None" },
};

void drm_connector_ida_init(void)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)
		ida_init(&drm_connector_enum_list[i].ida);
}

void drm_connector_ida_destroy(void)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(drm_connector_enum_list); i++)
		ida_destroy(&drm_connector_enum_list[i].ida);
}

/**
 * drm_get_connector_status_name - return a string for connector status
 * @@status: connector status to compute name of
 *
 * In contrast to the other drm_get_*_name functions this one here returns a
 * const pointer and hence is threadsafe.
 */
const char *drm_get_connector_status_name(enum drm_connector_status status)
{
	if (status == connector_status_connected)
		return "connected";
	else if (status == connector_status_disconnected)
		return "disconnected";
	else
		return "unknown";
}
EXPORT_SYMBOL(drm_get_connector_status_name);

/**
 * drm_get_subpixel_order_name - return a string for a given subpixel enum
 * @@order: enum of subpixel_order
 *
 * Note you could abuse this and return something out of bounds, but that
 * would be a caller error.  No unscrubbed user data should make it here.
 */
const char *drm_get_subpixel_order_name(enum subpixel_order order)
{
	return drm_subpixel_enum_list[order].name;
}
EXPORT_SYMBOL(drm_get_subpixel_order_name);

static char printable_char(int c)
{
	return isascii(c) && isprint(c) ? c : '?';
}

/**
 * drm_get_format_name - return a string for drm fourcc format
 * @@format: format to compute name of
 *
 * Note that the buffer used by this function is globally shared and owned by
 * the function itself.
 *
 * FIXME: This isn't really multithreading safe.
 */
const char *drm_get_format_name(uint32_t format)
{
	static char buf[32];

	snprintf(buf, sizeof(buf),
		 "%c%c%c%c %s-endian (0x%08x)",
		 printable_char(format & 0xff),
		 printable_char((format >> 8) & 0xff),
		 printable_char((format >> 16) & 0xff),
		 printable_char((format >> 24) & 0x7f),
		 format & DRM_FORMAT_BIG_ENDIAN ? "big" : "little",
		 format);

	return buf;
}
EXPORT_SYMBOL(drm_get_format_name);

/*
 * Internal function to assign a slot in the object idr and optionally
 * register the object into the idr.
 */
static int drm_mode_object_get_reg(struct drm_device *dev,
				   struct drm_mode_object *obj,
				   uint32_t obj_type,
				   bool register_obj)
{
	int ret;

	mutex_lock(&dev->mode_config.idr_mutex);
	ret = idr_alloc(&dev->mode_config.crtc_idr, register_obj ? obj : NULL, 1, 0, GFP_KERNEL);
	if (ret >= 0) {
		/*
		 * Set up the object linking under the protection of the idr
		 * lock so that other users can't see inconsistent state.
		 */
		obj->id = ret;
		obj->type = obj_type;
	}
	mutex_unlock(&dev->mode_config.idr_mutex);

	return ret < 0 ? ret : 0;
}

/**
 * drm_mode_object_get - allocate a new modeset identifier
 * @@dev: DRM device
 * @@obj: object pointer, used to generate unique ID
 * @@obj_type: object type
 *
 * Create a unique identifier based on @@ptr in @@dev's identifier space.  Used
 * for tracking modes, CRTCs and connectors. Note that despite the _get postfix
 * modeset identifiers are _not_ reference counted. Hence don't use this for
 * reference counted modeset objects like framebuffers.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_mode_object_get(struct drm_device *dev,
			struct drm_mode_object *obj, uint32_t obj_type)
{
	return drm_mode_object_get_reg(dev, obj, obj_type, true);
}

static void drm_mode_object_register(struct drm_device *dev,
				     struct drm_mode_object *obj)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_replace(&dev->mode_config.crtc_idr, obj, obj->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
}

/**
 * drm_mode_object_put - free a modeset identifer
 * @@dev: DRM device
 * @@object: object to free
 *
 * Free @@id from @@dev's unique identifier pool. Note that despite the _get
 * postfix modeset identifiers are _not_ reference counted. Hence don't use this
 * for reference counted modeset objects like framebuffers.
 */
void drm_mode_object_put(struct drm_device *dev,
			 struct drm_mode_object *object)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, object->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
}

static struct drm_mode_object *_object_find(struct drm_device *dev,
		uint32_t id, uint32_t type)
{
	struct drm_mode_object *obj = NULL;

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (obj && type != DRM_MODE_OBJECT_ANY && obj->type != type)
		obj = NULL;
	if (obj && obj->id != id)
		obj = NULL;
	/* don't leak out unref'd fb's */
	if (obj &&
	    (obj->type == DRM_MODE_OBJECT_FB ||
	     obj->type == DRM_MODE_OBJECT_BLOB))
		obj = NULL;
	mutex_unlock(&dev->mode_config.idr_mutex);

	return obj;
}

/**
 * drm_mode_object_find - look up a drm object with static lifetime
 * @@dev: drm device
 * @@id: id of the mode object
 * @@type: type of the mode object
 *
 * Note that framebuffers cannot be looked up with this functions - since those
 * are reference counted, they need special treatment.  Even with
 * DRM_MODE_OBJECT_ANY (although that will simply return NULL
 * rather than WARN_ON()).
 */
struct drm_mode_object *drm_mode_object_find(struct drm_device *dev,
		uint32_t id, uint32_t type)
{
	struct drm_mode_object *obj = NULL;

	/* Framebuffers are reference counted and need their own lookup
	 * function.*/
	WARN_ON(type == DRM_MODE_OBJECT_FB || type == DRM_MODE_OBJECT_BLOB);
	obj = _object_find(dev, id, type);
	return obj;
}
EXPORT_SYMBOL(drm_mode_object_find);

/**
 * drm_framebuffer_init - initialize a framebuffer
 * @@dev: DRM device
 * @@fb: framebuffer to be initialized
 * @@funcs: ... with these functions
 *
 * Allocates an ID for the framebuffer's parent mode object, sets its mode
 * functions & device file and adds it to the master fd list.
 *
 * IMPORTANT:
 * This functions publishes the fb and makes it available for concurrent access
 * by other users. Which means by this point the fb _must_ be fully set up -
 * since all the fb attributes are invariant over its lifetime, no further
 * locking but only correct reference counting is required.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,
			 const struct drm_framebuffer_funcs *funcs)
{
	int ret;

	mutex_lock(&dev->mode_config.fb_lock);
	kref_init(&fb->refcount);
	INIT_LIST_HEAD(&fb->filp_head);
	fb->dev = dev;
	fb->funcs = funcs;

	ret = drm_mode_object_get(dev, &fb->base, DRM_MODE_OBJECT_FB);
	if (ret)
		goto out;

	dev->mode_config.num_fb++;
	list_add(&fb->head, &dev->mode_config.fb_list);
out:
	mutex_unlock(&dev->mode_config.fb_lock);

	return ret;
}
EXPORT_SYMBOL(drm_framebuffer_init);

/* dev->mode_config.fb_lock must be held! */
static void __drm_framebuffer_unregister(struct drm_device *dev,
					 struct drm_framebuffer *fb)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, fb->base.id);
	mutex_unlock(&dev->mode_config.idr_mutex);

	fb->base.id = 0;
}

static void drm_framebuffer_free(struct kref *kref)
{
	struct drm_framebuffer *fb =
			container_of(kref, struct drm_framebuffer, refcount);
	struct drm_device *dev = fb->dev;

	/*
	 * The lookup idr holds a weak reference, which has not necessarily been
	 * removed at this point. Check for that.
	 */
	mutex_lock(&dev->mode_config.fb_lock);
	if (fb->base.id) {
		/* Mark fb as reaped and drop idr ref. */
		__drm_framebuffer_unregister(dev, fb);
	}
	mutex_unlock(&dev->mode_config.fb_lock);

	fb->funcs->destroy(fb);
}

static struct drm_framebuffer *__drm_framebuffer_lookup(struct drm_device *dev,
							uint32_t id)
{
	struct drm_mode_object *obj = NULL;
	struct drm_framebuffer *fb;

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != DRM_MODE_OBJECT_FB) || (obj->id != id))
		fb = NULL;
	else
		fb = obj_to_fb(obj);
	mutex_unlock(&dev->mode_config.idr_mutex);

	return fb;
}

/**
 * drm_framebuffer_lookup - look up a drm framebuffer and grab a reference
 * @@dev: drm device
 * @@id: id of the fb object
 *
 * If successful, this grabs an additional reference to the framebuffer -
 * callers need to make sure to eventually unreference the returned framebuffer
 * again, using @@drm_framebuffer_unreference.
 */
struct drm_framebuffer *drm_framebuffer_lookup(struct drm_device *dev,
					       uint32_t id)
{
	struct drm_framebuffer *fb;

	mutex_lock(&dev->mode_config.fb_lock);
	fb = __drm_framebuffer_lookup(dev, id);
	if (fb) {
		if (!kref_get_unless_zero(&fb->refcount))
			fb = NULL;
	}
	mutex_unlock(&dev->mode_config.fb_lock);

	return fb;
}
EXPORT_SYMBOL(drm_framebuffer_lookup);

/**
 * drm_framebuffer_unreference - unref a framebuffer
 * @@fb: framebuffer to unref
 *
 * This functions decrements the fb's refcount and frees it if it drops to zero.
 */
void drm_framebuffer_unreference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("%p: FB ID: %d (%d)\n", fb, fb->base.id, atomic_read(&fb->refcount.refcount));
	kref_put(&fb->refcount, drm_framebuffer_free);
}
EXPORT_SYMBOL(drm_framebuffer_unreference);

/**
 * drm_framebuffer_reference - incr the fb refcnt
 * @@fb: framebuffer
 *
 * This functions increments the fb's refcount.
 */
void drm_framebuffer_reference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("%p: FB ID: %d (%d)\n", fb, fb->base.id, atomic_read(&fb->refcount.refcount));
	kref_get(&fb->refcount);
}
EXPORT_SYMBOL(drm_framebuffer_reference);

/**
 * drm_framebuffer_unregister_private - unregister a private fb from the lookup idr
 * @@fb: fb to unregister
 *
 * Drivers need to call this when cleaning up driver-private framebuffers, e.g.
 * those used for fbdev. Note that the caller must hold a reference of it's own,
 * i.e. the object may not be destroyed through this call (since it'll lead to a
 * locking inversion).
 */
void drm_framebuffer_unregister_private(struct drm_framebuffer *fb)
{
	struct drm_device *dev;

	if (!fb)
		return;

	dev = fb->dev;

	mutex_lock(&dev->mode_config.fb_lock);
	/* Mark fb as reaped and drop idr ref. */
	__drm_framebuffer_unregister(dev, fb);
	mutex_unlock(&dev->mode_config.fb_lock);
}
EXPORT_SYMBOL(drm_framebuffer_unregister_private);

/**
 * drm_framebuffer_cleanup - remove a framebuffer object
 * @@fb: framebuffer to remove
 *
 * Cleanup framebuffer. This function is intended to be used from the drivers
 * ->destroy callback. It can also be used to clean up driver private
 *  framebuffers embedded into a larger structure.
 *
 * Note that this function does not remove the fb from active usuage - if it is
 * still used anywhere, hilarity can ensue since userspace could call getfb on
 * the id and get back -EINVAL. Obviously no concern at driver unload time.
 *
 * Also, the framebuffer will not be removed from the lookup idr - for
 * user-created framebuffers this will happen in in the rmfb ioctl. For
 * driver-private objects (e.g. for fbdev) drivers need to explicitly call
 * drm_framebuffer_unregister_private.
 */
void drm_framebuffer_cleanup(struct drm_framebuffer *fb)
{
	struct drm_device *dev = fb->dev;

	mutex_lock(&dev->mode_config.fb_lock);
	list_del(&fb->head);
	dev->mode_config.num_fb--;
	mutex_unlock(&dev->mode_config.fb_lock);
}
EXPORT_SYMBOL(drm_framebuffer_cleanup);

/**
 * drm_framebuffer_remove - remove and unreference a framebuffer object
 * @@fb: framebuffer to remove
 *
 * Scans all the CRTCs and planes in @@dev's mode_config.  If they're
 * using @@fb, removes it, setting it to NULL. Then drops the reference to the
 * passed-in framebuffer. Might take the modeset locks.
 *
 * Note that this function optimizes the cleanup away if the caller holds the
 * last reference to the framebuffer. It is also guaranteed to not take the
 * modeset locks in this case.
 */
void drm_framebuffer_remove(struct drm_framebuffer *fb)
{
	struct drm_device *dev;
	struct drm_crtc *crtc;
	struct drm_plane *plane;
	struct drm_mode_set set;
	int ret;

	if (!fb)
		return;

	dev = fb->dev;

	WARN_ON(!list_empty(&fb->filp_head));

	/*
	 * drm ABI mandates that we remove any deleted framebuffers from active
	 * useage. But since most sane clients only remove framebuffers they no
	 * longer need, try to optimize this away.
	 *
	 * Since we're holding a reference ourselves, observing a refcount of 1
	 * means that we're the last holder and can skip it. Also, the refcount
	 * can never increase from 1 again, so we don't need any barriers or
	 * locks.
	 *
	 * Note that userspace could try to race with use and instate a new
	 * usage _after_ we've cleared all current ones. End result will be an
	 * in-use fb with fb-id == 0. Userspace is allowed to shoot its own foot
	 * in this manner.
	 */
	if (atomic_read(&fb->refcount.refcount) > 1) {
		drm_modeset_lock_all(dev);
		/* remove from any CRTC */
		drm_for_each_crtc(crtc, dev) {
			if (crtc->primary->fb == fb) {
				/* should turn off the crtc */
				memset(&set, 0, sizeof(struct drm_mode_set));
				set.crtc = crtc;
				set.fb = NULL;
				ret = drm_mode_set_config_internal(&set);
				if (ret)
					DRM_ERROR("failed to reset crtc %p when fb was deleted\n", crtc);
			}
		}

		drm_for_each_plane(plane, dev) {
			if (plane->fb == fb)
				drm_plane_force_disable(plane);
		}
		drm_modeset_unlock_all(dev);
	}

	drm_framebuffer_unreference(fb);
}
EXPORT_SYMBOL(drm_framebuffer_remove);

DEFINE_WW_CLASS(crtc_ww_class);

/**
 * drm_crtc_init_with_planes - Initialise a new CRTC object with
 *    specified primary and cursor planes.
 * @@dev: DRM device
 * @@crtc: CRTC object to init
 * @@primary: Primary plane for CRTC
 * @@cursor: Cursor plane for CRTC
 * @@funcs: callbacks for the new CRTC
 *
 * Inits a new object created as base part of a driver crtc object.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_crtc_init_with_planes(struct drm_device *dev, struct drm_crtc *crtc,
			      struct drm_plane *primary,
			      struct drm_plane *cursor,
			      const struct drm_crtc_funcs *funcs)
{
	struct drm_mode_config *config = &dev->mode_config;
	int ret;

	WARN_ON(primary && primary->type != DRM_PLANE_TYPE_PRIMARY);
	WARN_ON(cursor && cursor->type != DRM_PLANE_TYPE_CURSOR);

	crtc->dev = dev;
	crtc->funcs = funcs;

	drm_modeset_lock_init(&crtc->mutex);
	ret = drm_mode_object_get(dev, &crtc->base, DRM_MODE_OBJECT_CRTC);
	if (ret)
		return ret;

	crtc->base.properties = &crtc->properties;

	list_add_tail(&crtc->head, &config->crtc_list);
	config->num_crtc++;

	crtc->primary = primary;
	crtc->cursor = cursor;
	if (primary)
		primary->possible_crtcs = 1 << drm_crtc_index(crtc);
	if (cursor)
		cursor->possible_crtcs = 1 << drm_crtc_index(crtc);

	if (drm_core_check_feature(dev, DRIVER_ATOMIC)) {
		drm_object_attach_property(&crtc->base, config->prop_active, 0);
		drm_object_attach_property(&crtc->base, config->prop_mode_id, 0);
	}

	return 0;
}
EXPORT_SYMBOL(drm_crtc_init_with_planes);

/**
 * drm_crtc_cleanup - Clean up the core crtc usage
 * @@crtc: CRTC to cleanup
 *
 * This function cleans up @@crtc and removes it from the DRM mode setting
 * core. Note that the function does *not* free the crtc structure itself,
 * this is the responsibility of the caller.
 */
void drm_crtc_cleanup(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;

	kfree(crtc->gamma_store);
	crtc->gamma_store = NULL;

	drm_modeset_lock_fini(&crtc->mutex);

	drm_mode_object_put(dev, &crtc->base);
	list_del(&crtc->head);
	dev->mode_config.num_crtc--;

	WARN_ON(crtc->state && !crtc->funcs->atomic_destroy_state);
	if (crtc->state && crtc->funcs->atomic_destroy_state)
		crtc->funcs->atomic_destroy_state(crtc, crtc->state);

	memset(crtc, 0, sizeof(*crtc));
}
EXPORT_SYMBOL(drm_crtc_cleanup);

/**
 * drm_crtc_index - find the index of a registered CRTC
 * @@crtc: CRTC to find index for
 *
 * Given a registered CRTC, return the index of that CRTC within a DRM
 * device's list of CRTCs.
 */
unsigned int drm_crtc_index(struct drm_crtc *crtc)
{
	unsigned int index = 0;
	struct drm_crtc *tmp;

	drm_for_each_crtc(tmp, crtc->dev) {
		if (tmp == crtc)
			return index;

		index++;
	}

	BUG();
}
EXPORT_SYMBOL(drm_crtc_index);

/*
 * drm_mode_remove - remove and free a mode
 * @@connector: connector list to modify
 * @@mode: mode to remove
 *
 * Remove @@mode from @@connector's mode list, then free it.
 */
static void drm_mode_remove(struct drm_connector *connector,
			    struct drm_display_mode *mode)
{
	list_del(&mode->head);
	drm_mode_destroy(connector->dev, mode);
}

/**
 * drm_display_info_set_bus_formats - set the supported bus formats
 * @@info: display info to store bus formats in
 * @@formats: array containing the supported bus formats
 * @@num_formats: the number of entries in the fmts array
 *
 * Store the supported bus formats in display info structure.
 * See MEDIA_BUS_FMT_* definitions in include/uapi/linux/media-bus-format.h for
 * a full list of available formats.
 */
int drm_display_info_set_bus_formats(struct drm_display_info *info,
				     const u32 *formats,
				     unsigned int num_formats)
{
	u32 *fmts = NULL;

	if (!formats && num_formats)
		return -EINVAL;

	if (formats && num_formats) {
		fmts = kmemdup(formats, sizeof(*formats) * num_formats,
			       GFP_KERNEL);
		if (!fmts)
			return -ENOMEM;
	}

	kfree(info->bus_formats);
	info->bus_formats = fmts;
	info->num_bus_formats = num_formats;

	return 0;
}
EXPORT_SYMBOL(drm_display_info_set_bus_formats);

/**
 * drm_connector_get_cmdline_mode - reads the user's cmdline mode
 * @@connector: connector to quwery
 *
 * The kernel supports per-connector configration of its consoles through
 * use of the video= parameter. This function parses that option and
 * extracts the user's specified mode (or enable/disable status) for a
 * particular connector. This is typically only used during the early fbdev
 * setup.
 */
static void drm_connector_get_cmdline_mode(struct drm_connector *connector)
{
	struct drm_cmdline_mode *mode = &connector->cmdline_mode;
	char *option = NULL;

#ifdef __linux__
	if (fb_get_options(connector->name, &option))
		return;
#endif

	if (!drm_mode_parse_command_line_for_connector(option,
						       connector,
						       mode))
		return;

	if (mode->force) {
		const char *s;

		switch (mode->force) {
		case DRM_FORCE_OFF:
			s = "OFF";
			break;
		case DRM_FORCE_ON_DIGITAL:
			s = "ON - dig";
			break;
		default:
		case DRM_FORCE_ON:
			s = "ON";
			break;
		}

		DRM_INFO("forcing %s connector %s\n", connector->name, s);
		connector->force = mode->force;
	}

	DRM_DEBUG_KMS("cmdline mode for connector %s %dx%d@@%dHz%s%s%s\n",
		      connector->name,
		      mode->xres, mode->yres,
		      mode->refresh_specified ? mode->refresh : 60,
		      mode->rb ? " reduced blanking" : "",
		      mode->margins ? " with margins" : "",
		      mode->interlace ?  " interlaced" : "");
}

/**
 * drm_connector_init - Init a preallocated connector
 * @@dev: DRM device
 * @@connector: the connector to init
 * @@funcs: callbacks for this connector
 * @@connector_type: user visible type of the connector
 *
 * Initialises a preallocated connector. Connectors should be
 * subclassed as part of driver connector objects.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_connector_init(struct drm_device *dev,
		       struct drm_connector *connector,
		       const struct drm_connector_funcs *funcs,
		       int connector_type)
{
	struct drm_mode_config *config = &dev->mode_config;
	int ret;
	struct ida *connector_ida =
		&drm_connector_enum_list[connector_type].ida;

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get_reg(dev, &connector->base, DRM_MODE_OBJECT_CONNECTOR, false);
	if (ret)
		goto out_unlock;

	connector->base.properties = &connector->properties;
	connector->dev = dev;
	connector->funcs = funcs;
	connector->connector_type = connector_type;
	connector->connector_type_id =
		ida_simple_get(connector_ida, 1, 0, GFP_KERNEL);
	if (connector->connector_type_id < 0) {
		ret = connector->connector_type_id;
		goto out_put;
	}
	connector->name =
		kasprintf(GFP_KERNEL, "%s-%d",
			  drm_connector_enum_list[connector_type].name,
			  connector->connector_type_id);
	if (!connector->name) {
		ret = -ENOMEM;
		goto out_put;
	}

	INIT_LIST_HEAD(&connector->probed_modes);
	INIT_LIST_HEAD(&connector->modes);
	connector->edid_blob_ptr = NULL;
	connector->status = connector_status_unknown;

	drm_connector_get_cmdline_mode(connector);

	/* We should add connectors at the end to avoid upsetting the connector
	 * index too much. */
	list_add_tail(&connector->head, &config->connector_list);
	config->num_connector++;

	if (connector_type != DRM_MODE_CONNECTOR_VIRTUAL)
		drm_object_attach_property(&connector->base,
					      config->edid_property,
					      0);

	drm_object_attach_property(&connector->base,
				      config->dpms_property, 0);

	if (drm_core_check_feature(dev, DRIVER_ATOMIC)) {
		drm_object_attach_property(&connector->base, config->prop_crtc_id, 0);
	}

	connector->debugfs_entry = NULL;

out_put:
	if (ret)
		drm_mode_object_put(dev, &connector->base);

out_unlock:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_connector_init);

/**
 * drm_connector_cleanup - cleans up an initialised connector
 * @@connector: connector to cleanup
 *
 * Cleans up the connector but doesn't free the object.
 */
void drm_connector_cleanup(struct drm_connector *connector)
{
	struct drm_device *dev = connector->dev;
	struct drm_display_mode *mode, *t;

	if (connector->tile_group) {
		drm_mode_put_tile_group(dev, connector->tile_group);
		connector->tile_group = NULL;
	}

	list_for_each_entry_safe(mode, t, &connector->probed_modes, head)
		drm_mode_remove(connector, mode);

	list_for_each_entry_safe(mode, t, &connector->modes, head)
		drm_mode_remove(connector, mode);

	ida_remove(&drm_connector_enum_list[connector->connector_type].ida,
		   connector->connector_type_id);

	kfree(connector->display_info.bus_formats);
	drm_mode_object_put(dev, &connector->base);
	kfree(connector->name);
	connector->name = NULL;
	list_del(&connector->head);
	dev->mode_config.num_connector--;

	WARN_ON(connector->state && !connector->funcs->atomic_destroy_state);
	if (connector->state && connector->funcs->atomic_destroy_state)
		connector->funcs->atomic_destroy_state(connector,
						       connector->state);

	memset(connector, 0, sizeof(*connector));
}
EXPORT_SYMBOL(drm_connector_cleanup);

/**
 * drm_connector_index - find the index of a registered connector
 * @@connector: connector to find index for
 *
 * Given a registered connector, return the index of that connector within a DRM
 * device's list of connectors.
 */
unsigned int drm_connector_index(struct drm_connector *connector)
{
	unsigned int index = 0;
	struct drm_connector *tmp;
	struct drm_mode_config *config = &connector->dev->mode_config;

	WARN_ON(!drm_modeset_is_locked(&config->connection_mutex));

	drm_for_each_connector(tmp, connector->dev) {
		if (tmp == connector)
			return index;

		index++;
	}

	BUG();
}
EXPORT_SYMBOL(drm_connector_index);

/**
 * drm_connector_register - register a connector
 * @@connector: the connector to register
 *
 * Register userspace interfaces for a connector
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_connector_register(struct drm_connector *connector)
{
	int ret;

	drm_mode_object_register(connector->dev, &connector->base);

	ret = drm_sysfs_connector_add(connector);
	if (ret)
		return ret;

	ret = drm_debugfs_connector_add(connector);
	if (ret) {
		drm_sysfs_connector_remove(connector);
		return ret;
	}

	return 0;
}
EXPORT_SYMBOL(drm_connector_register);

/**
 * drm_connector_unregister - unregister a connector
 * @@connector: the connector to unregister
 *
 * Unregister userspace interfaces for a connector
 */
void drm_connector_unregister(struct drm_connector *connector)
{
	drm_sysfs_connector_remove(connector);
	drm_debugfs_connector_remove(connector);
}
EXPORT_SYMBOL(drm_connector_unregister);


/**
 * drm_connector_unplug_all - unregister connector userspace interfaces
 * @@dev: drm device
 *
 * This function unregisters all connector userspace interfaces in sysfs. Should
 * be call when the device is disconnected, e.g. from an usb driver's
 * ->disconnect callback.
 */
void drm_connector_unplug_all(struct drm_device *dev)
{
	struct drm_connector *connector;

	/* FIXME: taking the mode config mutex ends up in a clash with sysfs */
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
		drm_connector_unregister(connector);

}
EXPORT_SYMBOL(drm_connector_unplug_all);

/**
 * drm_encoder_init - Init a preallocated encoder
 * @@dev: drm device
 * @@encoder: the encoder to init
 * @@funcs: callbacks for this encoder
 * @@encoder_type: user visible type of the encoder
 *
 * Initialises a preallocated encoder. Encoder should be
 * subclassed as part of driver encoder objects.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_encoder_init(struct drm_device *dev,
		      struct drm_encoder *encoder,
		      const struct drm_encoder_funcs *funcs,
		      int encoder_type)
{
	int ret;

	drm_modeset_lock_all(dev);

	ret = drm_mode_object_get(dev, &encoder->base, DRM_MODE_OBJECT_ENCODER);
	if (ret)
		goto out_unlock;

	encoder->dev = dev;
	encoder->encoder_type = encoder_type;
	encoder->funcs = funcs;
	encoder->name = kasprintf(GFP_KERNEL, "%s-%d",
				  drm_encoder_enum_list[encoder_type].name,
				  encoder->base.id);
	if (!encoder->name) {
		ret = -ENOMEM;
		goto out_put;
	}

	list_add_tail(&encoder->head, &dev->mode_config.encoder_list);
	dev->mode_config.num_encoder++;

out_put:
	if (ret)
		drm_mode_object_put(dev, &encoder->base);

out_unlock:
	drm_modeset_unlock_all(dev);

	return ret;
}
EXPORT_SYMBOL(drm_encoder_init);

/**
 * drm_encoder_cleanup - cleans up an initialised encoder
 * @@encoder: encoder to cleanup
 *
 * Cleans up the encoder but doesn't free the object.
 */
void drm_encoder_cleanup(struct drm_encoder *encoder)
{
	struct drm_device *dev = encoder->dev;

	drm_modeset_lock_all(dev);
	drm_mode_object_put(dev, &encoder->base);
	kfree(encoder->name);
	list_del(&encoder->head);
	dev->mode_config.num_encoder--;
	drm_modeset_unlock_all(dev);

	memset(encoder, 0, sizeof(*encoder));
}
EXPORT_SYMBOL(drm_encoder_cleanup);

/**
 * drm_universal_plane_init - Initialize a new universal plane object
 * @@dev: DRM device
 * @@plane: plane object to init
 * @@possible_crtcs: bitmask of possible CRTCs
 * @@funcs: callbacks for the new plane
 * @@formats: array of supported formats (%DRM_FORMAT_*)
 * @@format_count: number of elements in @@formats
 * @@type: type of plane (overlay, primary, cursor)
 *
 * Initializes a plane object of type @@type.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_universal_plane_init(struct drm_device *dev, struct drm_plane *plane,
			     unsigned long possible_crtcs,
			     const struct drm_plane_funcs *funcs,
			     const uint32_t *formats, unsigned int format_count,
			     enum drm_plane_type type)
{
	struct drm_mode_config *config = &dev->mode_config;
	int ret;

	ret = drm_mode_object_get(dev, &plane->base, DRM_MODE_OBJECT_PLANE);
	if (ret)
		return ret;

	drm_modeset_lock_init(&plane->mutex);

	plane->base.properties = &plane->properties;
	plane->dev = dev;
	plane->funcs = funcs;
	plane->format_types = kmalloc_array(format_count, sizeof(uint32_t),
					    GFP_KERNEL);
	if (!plane->format_types) {
		DRM_DEBUG_KMS("out of memory when allocating plane\n");
		drm_mode_object_put(dev, &plane->base);
		return -ENOMEM;
	}

	memcpy(plane->format_types, formats, format_count * sizeof(uint32_t));
	plane->format_count = format_count;
	plane->possible_crtcs = possible_crtcs;
	plane->type = type;

	list_add_tail(&plane->head, &config->plane_list);
	config->num_total_plane++;
	if (plane->type == DRM_PLANE_TYPE_OVERLAY)
		config->num_overlay_plane++;

	drm_object_attach_property(&plane->base,
				   config->plane_type_property,
				   plane->type);

	if (drm_core_check_feature(dev, DRIVER_ATOMIC)) {
		drm_object_attach_property(&plane->base, config->prop_fb_id, 0);
		drm_object_attach_property(&plane->base, config->prop_crtc_id, 0);
		drm_object_attach_property(&plane->base, config->prop_crtc_x, 0);
		drm_object_attach_property(&plane->base, config->prop_crtc_y, 0);
		drm_object_attach_property(&plane->base, config->prop_crtc_w, 0);
		drm_object_attach_property(&plane->base, config->prop_crtc_h, 0);
		drm_object_attach_property(&plane->base, config->prop_src_x, 0);
		drm_object_attach_property(&plane->base, config->prop_src_y, 0);
		drm_object_attach_property(&plane->base, config->prop_src_w, 0);
		drm_object_attach_property(&plane->base, config->prop_src_h, 0);
	}

	return 0;
}
EXPORT_SYMBOL(drm_universal_plane_init);

/**
 * drm_plane_init - Initialize a legacy plane
 * @@dev: DRM device
 * @@plane: plane object to init
 * @@possible_crtcs: bitmask of possible CRTCs
 * @@funcs: callbacks for the new plane
 * @@formats: array of supported formats (%DRM_FORMAT_*)
 * @@format_count: number of elements in @@formats
 * @@is_primary: plane type (primary vs overlay)
 *
 * Legacy API to initialize a DRM plane.
 *
 * New drivers should call drm_universal_plane_init() instead.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_plane_init(struct drm_device *dev, struct drm_plane *plane,
		   unsigned long possible_crtcs,
		   const struct drm_plane_funcs *funcs,
		   const uint32_t *formats, unsigned int format_count,
		   bool is_primary)
{
	enum drm_plane_type type;

	type = is_primary ? DRM_PLANE_TYPE_PRIMARY : DRM_PLANE_TYPE_OVERLAY;
	return drm_universal_plane_init(dev, plane, possible_crtcs, funcs,
					formats, format_count, type);
}
EXPORT_SYMBOL(drm_plane_init);

/**
 * drm_plane_cleanup - Clean up the core plane usage
 * @@plane: plane to cleanup
 *
 * This function cleans up @@plane and removes it from the DRM mode setting
 * core. Note that the function does *not* free the plane structure itself,
 * this is the responsibility of the caller.
 */
void drm_plane_cleanup(struct drm_plane *plane)
{
	struct drm_device *dev = plane->dev;

	drm_modeset_lock_all(dev);
	kfree(plane->format_types);
	drm_mode_object_put(dev, &plane->base);

	BUG_ON(list_empty(&plane->head));

	list_del(&plane->head);
	dev->mode_config.num_total_plane--;
	if (plane->type == DRM_PLANE_TYPE_OVERLAY)
		dev->mode_config.num_overlay_plane--;
	drm_modeset_unlock_all(dev);

	WARN_ON(plane->state && !plane->funcs->atomic_destroy_state);
	if (plane->state && plane->funcs->atomic_destroy_state)
		plane->funcs->atomic_destroy_state(plane, plane->state);

	memset(plane, 0, sizeof(*plane));
}
EXPORT_SYMBOL(drm_plane_cleanup);

/**
 * drm_plane_index - find the index of a registered plane
 * @@plane: plane to find index for
 *
 * Given a registered plane, return the index of that CRTC within a DRM
 * device's list of planes.
 */
unsigned int drm_plane_index(struct drm_plane *plane)
{
	unsigned int index = 0;
	struct drm_plane *tmp;

	drm_for_each_plane(tmp, plane->dev) {
		if (tmp == plane)
			return index;

		index++;
	}

	BUG();
}
EXPORT_SYMBOL(drm_plane_index);

/**
 * drm_plane_from_index - find the registered plane at an index
 * @@dev: DRM device
 * @@idx: index of registered plane to find for
 *
 * Given a plane index, return the registered plane from DRM device's
 * list of planes with matching index.
 */
struct drm_plane *
drm_plane_from_index(struct drm_device *dev, int idx)
{
	struct drm_plane *plane;
	unsigned int i = 0;

	drm_for_each_plane(plane, dev) {
		if (i == idx)
			return plane;
		i++;
	}
	return NULL;
}
EXPORT_SYMBOL(drm_plane_from_index);

/**
 * drm_plane_force_disable - Forcibly disable a plane
 * @@plane: plane to disable
 *
 * Forces the plane to be disabled.
 *
 * Used when the plane's current framebuffer is destroyed,
 * and when restoring fbdev mode.
 */
void drm_plane_force_disable(struct drm_plane *plane)
{
	int ret;

	if (!plane->fb)
		return;

	plane->old_fb = plane->fb;
	ret = plane->funcs->disable_plane(plane);
	if (ret) {
		DRM_ERROR("failed to disable plane with busy fb\n");
		plane->old_fb = NULL;
		return;
	}
	/* disconnect the plane from the fb and crtc: */
	drm_framebuffer_unreference(plane->old_fb);
	plane->old_fb = NULL;
	plane->fb = NULL;
	plane->crtc = NULL;
}
EXPORT_SYMBOL(drm_plane_force_disable);

static int drm_mode_create_standard_properties(struct drm_device *dev)
{
	struct drm_property *prop;

	/*
	 * Standard properties (apply to all connectors)
	 */
	prop = drm_property_create(dev, DRM_MODE_PROP_BLOB |
				   DRM_MODE_PROP_IMMUTABLE,
				   "EDID", 0);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.edid_property = prop;

	prop = drm_property_create_enum(dev, 0,
				   "DPMS", drm_dpms_enum_list,
				   ARRAY_SIZE(drm_dpms_enum_list));
	if (!prop)
		return -ENOMEM;
	dev->mode_config.dpms_property = prop;

	prop = drm_property_create(dev,
				   DRM_MODE_PROP_BLOB |
				   DRM_MODE_PROP_IMMUTABLE,
				   "PATH", 0);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.path_property = prop;

	prop = drm_property_create(dev,
				   DRM_MODE_PROP_BLOB |
				   DRM_MODE_PROP_IMMUTABLE,
				   "TILE", 0);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.tile_property = prop;

	prop = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
					"type", drm_plane_type_enum_list,
					ARRAY_SIZE(drm_plane_type_enum_list));
	if (!prop)
		return -ENOMEM;
	dev->mode_config.plane_type_property = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"SRC_X", 0, UINT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_src_x = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"SRC_Y", 0, UINT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_src_y = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"SRC_W", 0, UINT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_src_w = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"SRC_H", 0, UINT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_src_h = prop;

	prop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,
			"CRTC_X", INT_MIN, INT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_crtc_x = prop;

	prop = drm_property_create_signed_range(dev, DRM_MODE_PROP_ATOMIC,
			"CRTC_Y", INT_MIN, INT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_crtc_y = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"CRTC_W", 0, INT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_crtc_w = prop;

	prop = drm_property_create_range(dev, DRM_MODE_PROP_ATOMIC,
			"CRTC_H", 0, INT_MAX);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_crtc_h = prop;

	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
			"FB_ID", DRM_MODE_OBJECT_FB);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_fb_id = prop;

	prop = drm_property_create_object(dev, DRM_MODE_PROP_ATOMIC,
			"CRTC_ID", DRM_MODE_OBJECT_CRTC);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_crtc_id = prop;

	prop = drm_property_create_bool(dev, DRM_MODE_PROP_ATOMIC,
			"ACTIVE");
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_active = prop;

	prop = drm_property_create(dev,
			DRM_MODE_PROP_ATOMIC | DRM_MODE_PROP_BLOB,
			"MODE_ID", 0);
	if (!prop)
		return -ENOMEM;
	dev->mode_config.prop_mode_id = prop;

	return 0;
}

/**
 * drm_mode_create_dvi_i_properties - create DVI-I specific connector properties
 * @@dev: DRM device
 *
 * Called by a driver the first time a DVI-I connector is made.
 */
int drm_mode_create_dvi_i_properties(struct drm_device *dev)
{
	struct drm_property *dvi_i_selector;
	struct drm_property *dvi_i_subconnector;

	if (dev->mode_config.dvi_i_select_subconnector_property)
		return 0;

	dvi_i_selector =
		drm_property_create_enum(dev, 0,
				    "select subconnector",
				    drm_dvi_i_select_enum_list,
				    ARRAY_SIZE(drm_dvi_i_select_enum_list));
	dev->mode_config.dvi_i_select_subconnector_property = dvi_i_selector;

	dvi_i_subconnector = drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "subconnector",
				    drm_dvi_i_subconnector_enum_list,
				    ARRAY_SIZE(drm_dvi_i_subconnector_enum_list));
	dev->mode_config.dvi_i_subconnector_property = dvi_i_subconnector;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dvi_i_properties);

/**
 * drm_create_tv_properties - create TV specific connector properties
 * @@dev: DRM device
 * @@num_modes: number of different TV formats (modes) supported
 * @@modes: array of pointers to strings containing name of each format
 *
 * Called by a driver's TV initialization routine, this function creates
 * the TV specific connector properties for a given device.  Caller is
 * responsible for allocating a list of format names and passing them to
 * this routine.
 */
int drm_mode_create_tv_properties(struct drm_device *dev,
				  unsigned int num_modes,
				  const char * const modes[])
{
	struct drm_property *tv_selector;
	struct drm_property *tv_subconnector;
	unsigned int i;

	if (dev->mode_config.tv_select_subconnector_property)
		return 0;

	/*
	 * Basic connector properties
	 */
	tv_selector = drm_property_create_enum(dev, 0,
					  "select subconnector",
					  drm_tv_select_enum_list,
					  ARRAY_SIZE(drm_tv_select_enum_list));
	if (!tv_selector)
		goto nomem;

	dev->mode_config.tv_select_subconnector_property = tv_selector;

	tv_subconnector =
		drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "subconnector",
				    drm_tv_subconnector_enum_list,
				    ARRAY_SIZE(drm_tv_subconnector_enum_list));
	if (!tv_subconnector)
		goto nomem;
	dev->mode_config.tv_subconnector_property = tv_subconnector;

	/*
	 * Other, TV specific properties: margins & TV modes.
	 */
	dev->mode_config.tv_left_margin_property =
		drm_property_create_range(dev, 0, "left margin", 0, 100);
	if (!dev->mode_config.tv_left_margin_property)
		goto nomem;

	dev->mode_config.tv_right_margin_property =
		drm_property_create_range(dev, 0, "right margin", 0, 100);
	if (!dev->mode_config.tv_right_margin_property)
		goto nomem;

	dev->mode_config.tv_top_margin_property =
		drm_property_create_range(dev, 0, "top margin", 0, 100);
	if (!dev->mode_config.tv_top_margin_property)
		goto nomem;

	dev->mode_config.tv_bottom_margin_property =
		drm_property_create_range(dev, 0, "bottom margin", 0, 100);
	if (!dev->mode_config.tv_bottom_margin_property)
		goto nomem;

	dev->mode_config.tv_mode_property =
		drm_property_create(dev, DRM_MODE_PROP_ENUM,
				    "mode", num_modes);
	if (!dev->mode_config.tv_mode_property)
		goto nomem;

	for (i = 0; i < num_modes; i++)
		drm_property_add_enum(dev->mode_config.tv_mode_property, i,
				      i, modes[i]);

	dev->mode_config.tv_brightness_property =
		drm_property_create_range(dev, 0, "brightness", 0, 100);
	if (!dev->mode_config.tv_brightness_property)
		goto nomem;

	dev->mode_config.tv_contrast_property =
		drm_property_create_range(dev, 0, "contrast", 0, 100);
	if (!dev->mode_config.tv_contrast_property)
		goto nomem;

	dev->mode_config.tv_flicker_reduction_property =
		drm_property_create_range(dev, 0, "flicker reduction", 0, 100);
	if (!dev->mode_config.tv_flicker_reduction_property)
		goto nomem;

	dev->mode_config.tv_overscan_property =
		drm_property_create_range(dev, 0, "overscan", 0, 100);
	if (!dev->mode_config.tv_overscan_property)
		goto nomem;

	dev->mode_config.tv_saturation_property =
		drm_property_create_range(dev, 0, "saturation", 0, 100);
	if (!dev->mode_config.tv_saturation_property)
		goto nomem;

	dev->mode_config.tv_hue_property =
		drm_property_create_range(dev, 0, "hue", 0, 100);
	if (!dev->mode_config.tv_hue_property)
		goto nomem;

	return 0;
nomem:
	return -ENOMEM;
}
EXPORT_SYMBOL(drm_mode_create_tv_properties);

/**
 * drm_mode_create_scaling_mode_property - create scaling mode property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_scaling_mode_property(struct drm_device *dev)
{
	struct drm_property *scaling_mode;

	if (dev->mode_config.scaling_mode_property)
		return 0;

	scaling_mode =
		drm_property_create_enum(dev, 0, "scaling mode",
				drm_scaling_mode_enum_list,
				    ARRAY_SIZE(drm_scaling_mode_enum_list));

	dev->mode_config.scaling_mode_property = scaling_mode;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_scaling_mode_property);

/**
 * drm_mode_create_aspect_ratio_property - create aspect ratio property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_create_aspect_ratio_property(struct drm_device *dev)
{
	if (dev->mode_config.aspect_ratio_property)
		return 0;

	dev->mode_config.aspect_ratio_property =
		drm_property_create_enum(dev, 0, "aspect ratio",
				drm_aspect_ratio_enum_list,
				ARRAY_SIZE(drm_aspect_ratio_enum_list));

	if (dev->mode_config.aspect_ratio_property == NULL)
		return -ENOMEM;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_aspect_ratio_property);

/**
 * drm_mode_create_dirty_property - create dirty property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_dirty_info_property(struct drm_device *dev)
{
	struct drm_property *dirty_info;

	if (dev->mode_config.dirty_info_property)
		return 0;

	dirty_info =
		drm_property_create_enum(dev, DRM_MODE_PROP_IMMUTABLE,
				    "dirty",
				    drm_dirty_info_enum_list,
				    ARRAY_SIZE(drm_dirty_info_enum_list));
	dev->mode_config.dirty_info_property = dirty_info;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dirty_info_property);

/**
 * drm_mode_create_suggested_offset_properties - create suggests offset properties
 * @@dev: DRM device
 *
 * Create the the suggested x/y offset property for connectors.
 */
int drm_mode_create_suggested_offset_properties(struct drm_device *dev)
{
	if (dev->mode_config.suggested_x_property && dev->mode_config.suggested_y_property)
		return 0;

	dev->mode_config.suggested_x_property =
		drm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, "suggested X", 0, 0xffffffff);

	dev->mode_config.suggested_y_property =
		drm_property_create_range(dev, DRM_MODE_PROP_IMMUTABLE, "suggested Y", 0, 0xffffffff);

	if (dev->mode_config.suggested_x_property == NULL ||
	    dev->mode_config.suggested_y_property == NULL)
		return -ENOMEM;
	return 0;
}
EXPORT_SYMBOL(drm_mode_create_suggested_offset_properties);

/**
 * drm_mode_getresources - get graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a set of configuration description structures and return
 * them to the user, including CRTC, connector and framebuffer configuration.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getresources(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	struct drm_mode_card_res *card_res = data;
	struct list_head *lh;
	struct drm_framebuffer *fb;
	struct drm_connector *connector;
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	int ret = 0;
	int connector_count = 0;
	int crtc_count = 0;
	int fb_count = 0;
	int encoder_count = 0;
	int copied = 0;
	uint32_t __user *fb_id;
	uint32_t __user *crtc_id;
	uint32_t __user *connector_id;
	uint32_t __user *encoder_id;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;


	mutex_lock(&file_priv->fbs_lock);
	/*
	 * For the non-control nodes we need to limit the list of resources
	 * by IDs in the group list for this node
	 */
	list_for_each(lh, &file_priv->fbs)
		fb_count++;

	/* handle this in 4 parts */
	/* FBs */
	if (card_res->count_fbs >= fb_count) {
		copied = 0;
		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
			if (put_user(fb->base.id, fb_id + copied)) {
				mutex_unlock(&file_priv->fbs_lock);
				return -EFAULT;
			}
			copied++;
		}
	}
	card_res->count_fbs = fb_count;
	mutex_unlock(&file_priv->fbs_lock);

	/* mode_config.mutex protects the connector list against e.g. DP MST
	 * connector hot-adding. CRTC/Plane lists are invariant. */
	mutex_lock(&dev->mode_config.mutex);
	drm_for_each_crtc(crtc, dev)
		crtc_count++;

	drm_for_each_connector(connector, dev)
		connector_count++;

	drm_for_each_encoder(encoder, dev)
		encoder_count++;

	card_res->max_height = dev->mode_config.max_height;
	card_res->min_height = dev->mode_config.min_height;
	card_res->max_width = dev->mode_config.max_width;
	card_res->min_width = dev->mode_config.min_width;

	/* CRTCs */
	if (card_res->count_crtcs >= crtc_count) {
		copied = 0;
		crtc_id = (uint32_t __user *)(unsigned long)card_res->crtc_id_ptr;
		drm_for_each_crtc(crtc, dev) {
			DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);
			if (put_user(crtc->base.id, crtc_id + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	card_res->count_crtcs = crtc_count;

	/* Encoders */
	if (card_res->count_encoders >= encoder_count) {
		copied = 0;
		encoder_id = (uint32_t __user *)(unsigned long)card_res->encoder_id_ptr;
		drm_for_each_encoder(encoder, dev) {
			DRM_DEBUG_KMS("[ENCODER:%d:%s]\n", encoder->base.id,
					encoder->name);
			if (put_user(encoder->base.id, encoder_id +
				     copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	card_res->count_encoders = encoder_count;

	/* Connectors */
	if (card_res->count_connectors >= connector_count) {
		copied = 0;
		connector_id = (uint32_t __user *)(unsigned long)card_res->connector_id_ptr;
		drm_for_each_connector(connector, dev) {
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
				connector->base.id,
				connector->name);
			if (put_user(connector->base.id,
				     connector_id + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	card_res->count_connectors = connector_count;

	DRM_DEBUG_KMS("CRTC[%d] CONNECTORS[%d] ENCODERS[%d]\n", card_res->count_crtcs,
		  card_res->count_connectors, card_res->count_encoders);

out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}

/**
 * drm_mode_getcrtc - get CRTC configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a CRTC configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getcrtc(struct drm_device *dev,
		     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc *crtc_resp = data;
	struct drm_crtc *crtc;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	crtc = drm_crtc_find(dev, crtc_resp->crtc_id);
	if (!crtc)
		return -ENOENT;

	drm_modeset_lock_crtc(crtc, crtc->primary);
	crtc_resp->gamma_size = crtc->gamma_size;
	if (crtc->primary->fb)
		crtc_resp->fb_id = crtc->primary->fb->base.id;
	else
		crtc_resp->fb_id = 0;

	if (crtc->state) {
		crtc_resp->x = crtc->primary->state->src_x >> 16;
		crtc_resp->y = crtc->primary->state->src_y >> 16;
		if (crtc->state->enable) {
			drm_mode_convert_to_umode(&crtc_resp->mode, &crtc->state->mode);
			crtc_resp->mode_valid = 1;

		} else {
			crtc_resp->mode_valid = 0;
		}
	} else {
		crtc_resp->x = crtc->x;
		crtc_resp->y = crtc->y;
		if (crtc->enabled) {
			drm_mode_convert_to_umode(&crtc_resp->mode, &crtc->mode);
			crtc_resp->mode_valid = 1;

		} else {
			crtc_resp->mode_valid = 0;
		}
	}
	drm_modeset_unlock_crtc(crtc);

	return 0;
}

static bool drm_mode_expose_to_userspace(const struct drm_display_mode *mode,
					 const struct drm_file *file_priv)
{
	/*
	 * If user-space hasn't configured the driver to expose the stereo 3D
	 * modes, don't expose them.
	 */
	if (!file_priv->stereo_allowed && drm_mode_is_stereo(mode))
		return false;

	return true;
}

static struct drm_encoder *drm_connector_get_encoder(struct drm_connector *connector)
{
	/* For atomic drivers only state objects are synchronously updated and
	 * protected by modeset locks, so check those first. */
	if (connector->state)
		return connector->state->best_encoder;
	return connector->encoder;
}

/* helper for getconnector and getproperties ioctls */
static int get_properties(struct drm_mode_object *obj, bool atomic,
		uint32_t __user *prop_ptr, uint64_t __user *prop_values,
		uint32_t *arg_count_props)
{
	int props_count;
	int i, ret, copied;

	props_count = obj->properties->count;
	if (!atomic)
		props_count -= obj->properties->atomic_count;

	if ((*arg_count_props >= props_count) && props_count) {
		for (i = 0, copied = 0; copied < props_count; i++) {
			struct drm_property *prop = obj->properties->properties[i];
			uint64_t val;

			if ((prop->flags & DRM_MODE_PROP_ATOMIC) && !atomic)
				continue;

			ret = drm_object_property_get_value(obj, prop, &val);
			if (ret)
				return ret;

			if (put_user(prop->base.id, prop_ptr + copied))
				return -EFAULT;

			if (put_user(val, prop_values + copied))
				return -EFAULT;

			copied++;
		}
	}
	*arg_count_props = props_count;

	return 0;
}

/**
 * drm_mode_getconnector - get connector configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a connector configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getconnector(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	struct drm_mode_get_connector *out_resp = data;
	struct drm_connector *connector;
	struct drm_encoder *encoder;
	struct drm_display_mode *mode;
	int mode_count = 0;
	int encoders_count = 0;
	int ret = 0;
	int copied = 0;
	int i;
	struct drm_mode_modeinfo u_mode;
	struct drm_mode_modeinfo __user *mode_ptr;
	uint32_t __user *encoder_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	memset(&u_mode, 0, sizeof(struct drm_mode_modeinfo));

	DRM_DEBUG_KMS("[CONNECTOR:%d:?]\n", out_resp->connector_id);

	mutex_lock(&dev->mode_config.mutex);

	connector = drm_connector_find(dev, out_resp->connector_id);
	if (!connector) {
		ret = -ENOENT;
		goto out_unlock;
	}

	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++)
		if (connector->encoder_ids[i] != 0)
			encoders_count++;

	if (out_resp->count_modes == 0) {
		connector->funcs->fill_modes(connector,
					     dev->mode_config.max_width,
					     dev->mode_config.max_height);
	}

	/* delayed so we get modes regardless of pre-fill_modes state */
	list_for_each_entry(mode, &connector->modes, head)
		if (drm_mode_expose_to_userspace(mode, file_priv))
			mode_count++;

	out_resp->connector_id = connector->base.id;
	out_resp->connector_type = connector->connector_type;
	out_resp->connector_type_id = connector->connector_type_id;
	out_resp->mm_width = connector->display_info.width_mm;
	out_resp->mm_height = connector->display_info.height_mm;
	out_resp->subpixel = connector->display_info.subpixel_order;
	out_resp->connection = connector->status;

	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
	encoder = drm_connector_get_encoder(connector);
	if (encoder)
		out_resp->encoder_id = encoder->base.id;
	else
		out_resp->encoder_id = 0;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if ((out_resp->count_modes >= mode_count) && mode_count) {
		copied = 0;
		mode_ptr = (struct drm_mode_modeinfo __user *)(unsigned long)out_resp->modes_ptr;
		list_for_each_entry(mode, &connector->modes, head) {
			if (!drm_mode_expose_to_userspace(mode, file_priv))
				continue;

			drm_mode_convert_to_umode(&u_mode, mode);
			if (copy_to_user(mode_ptr + copied,
					 &u_mode, sizeof(u_mode))) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	out_resp->count_modes = mode_count;

	ret = get_properties(&connector->base, file_priv->atomic,
			(uint32_t __user *)(unsigned long)(out_resp->props_ptr),
			(uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr),
			&out_resp->count_props);
	if (ret)
		goto out;

	if ((out_resp->count_encoders >= encoders_count) && encoders_count) {
		copied = 0;
		encoder_ptr = (uint32_t __user *)(unsigned long)(out_resp->encoders_ptr);
		for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
			if (connector->encoder_ids[i] != 0) {
				if (put_user(connector->encoder_ids[i],
					     encoder_ptr + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
		}
	}
	out_resp->count_encoders = encoders_count;

out:
	drm_modeset_unlock(&dev->mode_config.connection_mutex);

out_unlock:
	mutex_unlock(&dev->mode_config.mutex);

	return ret;
}

static struct drm_crtc *drm_encoder_get_crtc(struct drm_encoder *encoder)
{
	struct drm_connector *connector;
	struct drm_device *dev = encoder->dev;
	bool uses_atomic = false;

	/* For atomic drivers only state objects are synchronously updated and
	 * protected by modeset locks, so check those first. */
	drm_for_each_connector(connector, dev) {
		if (!connector->state)
			continue;

		uses_atomic = true;

		if (connector->state->best_encoder != encoder)
			continue;

		return connector->state->crtc;
	}

	/* Don't return stale data (e.g. pending async disable). */
	if (uses_atomic)
		return NULL;

	return encoder->crtc;
}

/**
 * drm_mode_getencoder - get encoder configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Construct a encoder configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getencoder(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	struct drm_mode_get_encoder *enc_resp = data;
	struct drm_encoder *encoder;
	struct drm_crtc *crtc;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	encoder = drm_encoder_find(dev, enc_resp->encoder_id);
	if (!encoder)
		return -ENOENT;

	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
	crtc = drm_encoder_get_crtc(encoder);
	if (crtc)
		enc_resp->crtc_id = crtc->base.id;
	else
		enc_resp->crtc_id = 0;
	drm_modeset_unlock(&dev->mode_config.connection_mutex);

	enc_resp->encoder_type = encoder->encoder_type;
	enc_resp->encoder_id = encoder->base.id;
	enc_resp->possible_crtcs = encoder->possible_crtcs;
	enc_resp->possible_clones = encoder->possible_clones;

	return 0;
}

/**
 * drm_mode_getplane_res - enumerate all plane resources
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Construct a list of plane ids to return to the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getplane_res(struct drm_device *dev, void *data,
			  struct drm_file *file_priv)
{
	struct drm_mode_get_plane_res *plane_resp = data;
	struct drm_mode_config *config;
	struct drm_plane *plane;
	uint32_t __user *plane_ptr;
	int copied = 0;
	unsigned num_planes;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	config = &dev->mode_config;

	if (file_priv->universal_planes)
		num_planes = config->num_total_plane;
	else
		num_planes = config->num_overlay_plane;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if (num_planes &&
	    (plane_resp->count_planes >= num_planes)) {
		plane_ptr = (uint32_t __user *)(unsigned long)plane_resp->plane_id_ptr;

		/* Plane lists are invariant, no locking needed. */
		drm_for_each_plane(plane, dev) {
			/*
			 * Unless userspace set the 'universal planes'
			 * capability bit, only advertise overlays.
			 */
			if (plane->type != DRM_PLANE_TYPE_OVERLAY &&
			    !file_priv->universal_planes)
				continue;

			if (put_user(plane->base.id, plane_ptr + copied))
				return -EFAULT;
			copied++;
		}
	}
	plane_resp->count_planes = num_planes;

	return 0;
}

/**
 * drm_mode_getplane - get plane configuration
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Construct a plane configuration structure to return to the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getplane(struct drm_device *dev, void *data,
		      struct drm_file *file_priv)
{
	struct drm_mode_get_plane *plane_resp = data;
	struct drm_plane *plane;
	uint32_t __user *format_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	plane = drm_plane_find(dev, plane_resp->plane_id);
	if (!plane)
		return -ENOENT;

	drm_modeset_lock(&plane->mutex, NULL);
	if (plane->crtc)
		plane_resp->crtc_id = plane->crtc->base.id;
	else
		plane_resp->crtc_id = 0;

	if (plane->fb)
		plane_resp->fb_id = plane->fb->base.id;
	else
		plane_resp->fb_id = 0;
	drm_modeset_unlock(&plane->mutex);

	plane_resp->plane_id = plane->base.id;
	plane_resp->possible_crtcs = plane->possible_crtcs;
	plane_resp->gamma_size = 0;

	/*
	 * This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it.
	 */
	if (plane->format_count &&
	    (plane_resp->count_format_types >= plane->format_count)) {
		format_ptr = (uint32_t __user *)(unsigned long)plane_resp->format_type_ptr;
		if (copy_to_user(format_ptr,
				 plane->format_types,
				 sizeof(uint32_t) * plane->format_count)) {
			return -EFAULT;
		}
	}
	plane_resp->count_format_types = plane->format_count;

	return 0;
}

/**
 * drm_plane_check_pixel_format - Check if the plane supports the pixel format
 * @@plane: plane to check for format support
 * @@format: the pixel format
 *
 * Returns:
 * Zero of @@plane has @@format in its list of supported pixel formats, -EINVAL
 * otherwise.
 */
int drm_plane_check_pixel_format(const struct drm_plane *plane, u32 format)
{
	unsigned int i;

	for (i = 0; i < plane->format_count; i++) {
		if (format == plane->format_types[i])
			return 0;
	}

	return -EINVAL;
}

static int check_src_coords(uint32_t src_x, uint32_t src_y,
			    uint32_t src_w, uint32_t src_h,
			    const struct drm_framebuffer *fb)
{
	unsigned int fb_width, fb_height;

	fb_width = fb->width << 16;
	fb_height = fb->height << 16;

	/* Make sure source coordinates are inside the fb. */
	if (src_w > fb_width ||
	    src_x > fb_width - src_w ||
	    src_h > fb_height ||
	    src_y > fb_height - src_h) {
		DRM_DEBUG_KMS("Invalid source coordinates "
			      "%u.%06ux%u.%06u+%u.%06u+%u.%06u\n",
			      src_w >> 16, ((src_w & 0xffff) * 15625) >> 10,
			      src_h >> 16, ((src_h & 0xffff) * 15625) >> 10,
			      src_x >> 16, ((src_x & 0xffff) * 15625) >> 10,
			      src_y >> 16, ((src_y & 0xffff) * 15625) >> 10);
		return -ENOSPC;
	}

	return 0;
}

/*
 * setplane_internal - setplane handler for internal callers
 *
 * Note that we assume an extra reference has already been taken on fb.  If the
 * update fails, this reference will be dropped before return; if it succeeds,
 * the previous framebuffer (if any) will be unreferenced instead.
 *
 * src_{x,y,w,h} are provided in 16.16 fixed point format
 */
static int __setplane_internal(struct drm_plane *plane,
			       struct drm_crtc *crtc,
			       struct drm_framebuffer *fb,
			       int32_t crtc_x, int32_t crtc_y,
			       uint32_t crtc_w, uint32_t crtc_h,
			       /* src_{x,y,w,h} values are 16.16 fixed point */
			       uint32_t src_x, uint32_t src_y,
			       uint32_t src_w, uint32_t src_h)
{
	int ret = 0;

	/* No fb means shut it down */
	if (!fb) {
		plane->old_fb = plane->fb;
		ret = plane->funcs->disable_plane(plane);
		if (!ret) {
			plane->crtc = NULL;
			plane->fb = NULL;
		} else {
			plane->old_fb = NULL;
		}
		goto out;
	}

	/* Check whether this plane is usable on this CRTC */
	if (!(plane->possible_crtcs & drm_crtc_mask(crtc))) {
		DRM_DEBUG_KMS("Invalid crtc for plane\n");
		ret = -EINVAL;
		goto out;
	}

	/* Check whether this plane supports the fb pixel format. */
	ret = drm_plane_check_pixel_format(plane, fb->pixel_format);
	if (ret) {
		DRM_DEBUG_KMS("Invalid pixel format %s\n",
			      drm_get_format_name(fb->pixel_format));
		goto out;
	}

	/* Give drivers some help against integer overflows */
	if (crtc_w > INT_MAX ||
	    crtc_x > INT_MAX - (int32_t) crtc_w ||
	    crtc_h > INT_MAX ||
	    crtc_y > INT_MAX - (int32_t) crtc_h) {
		DRM_DEBUG_KMS("Invalid CRTC coordinates %ux%u+%d+%d\n",
			      crtc_w, crtc_h, crtc_x, crtc_y);
		ret = -ERANGE;
		goto out;
	}

	ret = check_src_coords(src_x, src_y, src_w, src_h, fb);
	if (ret)
		goto out;

	plane->old_fb = plane->fb;
	ret = plane->funcs->update_plane(plane, crtc, fb,
					 crtc_x, crtc_y, crtc_w, crtc_h,
					 src_x, src_y, src_w, src_h);
	if (!ret) {
		plane->crtc = crtc;
		plane->fb = fb;
		fb = NULL;
	} else {
		plane->old_fb = NULL;
	}

out:
	if (fb)
		drm_framebuffer_unreference(fb);
	if (plane->old_fb)
		drm_framebuffer_unreference(plane->old_fb);
	plane->old_fb = NULL;

	return ret;
}

static int setplane_internal(struct drm_plane *plane,
			     struct drm_crtc *crtc,
			     struct drm_framebuffer *fb,
			     int32_t crtc_x, int32_t crtc_y,
			     uint32_t crtc_w, uint32_t crtc_h,
			     /* src_{x,y,w,h} values are 16.16 fixed point */
			     uint32_t src_x, uint32_t src_y,
			     uint32_t src_w, uint32_t src_h)
{
	int ret;

	drm_modeset_lock_all(plane->dev);
	ret = __setplane_internal(plane, crtc, fb,
				  crtc_x, crtc_y, crtc_w, crtc_h,
				  src_x, src_y, src_w, src_h);
	drm_modeset_unlock_all(plane->dev);

	return ret;
}

/**
 * drm_mode_setplane - configure a plane's configuration
 * @@dev: DRM device
 * @@data: ioctl data*
 * @@file_priv: DRM file info
 *
 * Set plane configuration, including placement, fb, scaling, and other factors.
 * Or pass a NULL fb to disable (planes may be disabled without providing a
 * valid crtc).
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_setplane(struct drm_device *dev, void *data,
		      struct drm_file *file_priv)
{
	struct drm_mode_set_plane *plane_req = data;
	struct drm_plane *plane;
	struct drm_crtc *crtc = NULL;
	struct drm_framebuffer *fb = NULL;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	/*
	 * First, find the plane, crtc, and fb objects.  If not available,
	 * we don't bother to call the driver.
	 */
	plane = drm_plane_find(dev, plane_req->plane_id);
	if (!plane) {
		DRM_DEBUG_KMS("Unknown plane ID %d\n",
			      plane_req->plane_id);
		return -ENOENT;
	}

	if (plane_req->fb_id) {
		fb = drm_framebuffer_lookup(dev, plane_req->fb_id);
		if (!fb) {
			DRM_DEBUG_KMS("Unknown framebuffer ID %d\n",
				      plane_req->fb_id);
			return -ENOENT;
		}

		crtc = drm_crtc_find(dev, plane_req->crtc_id);
		if (!crtc) {
			DRM_DEBUG_KMS("Unknown crtc ID %d\n",
				      plane_req->crtc_id);
			return -ENOENT;
		}
	}

	/*
	 * setplane_internal will take care of deref'ing either the old or new
	 * framebuffer depending on success.
	 */
	return setplane_internal(plane, crtc, fb,
				 plane_req->crtc_x, plane_req->crtc_y,
				 plane_req->crtc_w, plane_req->crtc_h,
				 plane_req->src_x, plane_req->src_y,
				 plane_req->src_w, plane_req->src_h);
}

/**
 * drm_mode_set_config_internal - helper to call ->set_config
 * @@set: modeset config to set
 *
 * This is a little helper to wrap internal calls to the ->set_config driver
 * interface. The only thing it adds is correct refcounting dance.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_set_config_internal(struct drm_mode_set *set)
{
	struct drm_crtc *crtc = set->crtc;
	struct drm_framebuffer *fb;
	struct drm_crtc *tmp;
	int ret;

	/*
	 * NOTE: ->set_config can also disable other crtcs (if we steal all
	 * connectors from it), hence we need to refcount the fbs across all
	 * crtcs. Atomic modeset will have saner semantics ...
	 */
	drm_for_each_crtc(tmp, crtc->dev)
		tmp->primary->old_fb = tmp->primary->fb;

	fb = set->fb;

	ret = crtc->funcs->set_config(set);
	if (ret == 0) {
		crtc->primary->crtc = crtc;
		crtc->primary->fb = fb;
	}

	drm_for_each_crtc(tmp, crtc->dev) {
		if (tmp->primary->fb)
			drm_framebuffer_reference(tmp->primary->fb);
		if (tmp->primary->old_fb)
			drm_framebuffer_unreference(tmp->primary->old_fb);
		tmp->primary->old_fb = NULL;
	}

	return ret;
}
EXPORT_SYMBOL(drm_mode_set_config_internal);

/**
 * drm_crtc_get_hv_timing - Fetches hdisplay/vdisplay for given mode
 * @@mode: mode to query
 * @@hdisplay: hdisplay value to fill in
 * @@vdisplay: vdisplay value to fill in
 *
 * The vdisplay value will be doubled if the specified mode is a stereo mode of
 * the appropriate layout.
 */
void drm_crtc_get_hv_timing(const struct drm_display_mode *mode,
			    int *hdisplay, int *vdisplay)
{
	struct drm_display_mode adjusted;

	drm_mode_copy(&adjusted, mode);
	drm_mode_set_crtcinfo(&adjusted, CRTC_STEREO_DOUBLE_ONLY);
	*hdisplay = adjusted.crtc_hdisplay;
	*vdisplay = adjusted.crtc_vdisplay;
}
EXPORT_SYMBOL(drm_crtc_get_hv_timing);

/**
 * drm_crtc_check_viewport - Checks that a framebuffer is big enough for the
 *     CRTC viewport
 * @@crtc: CRTC that framebuffer will be displayed on
 * @@x: x panning
 * @@y: y panning
 * @@mode: mode that framebuffer will be displayed under
 * @@fb: framebuffer to check size of
 */
int drm_crtc_check_viewport(const struct drm_crtc *crtc,
			    int x, int y,
			    const struct drm_display_mode *mode,
			    const struct drm_framebuffer *fb)

{
	int hdisplay, vdisplay;

	drm_crtc_get_hv_timing(mode, &hdisplay, &vdisplay);

	if (crtc->state &&
	    crtc->primary->state->rotation & (BIT(DRM_ROTATE_90) |
					      BIT(DRM_ROTATE_270)))
		swap(hdisplay, vdisplay);

	return check_src_coords(x << 16, y << 16,
				hdisplay << 16, vdisplay << 16, fb);
}
EXPORT_SYMBOL(drm_crtc_check_viewport);

/**
 * drm_mode_setcrtc - set CRTC configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Build a new CRTC configuration based on user request.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_setcrtc(struct drm_device *dev, void *data,
		     struct drm_file *file_priv)
{
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_mode_crtc *crtc_req = data;
	struct drm_crtc *crtc;
	struct drm_connector **connector_set = NULL, *connector;
	struct drm_framebuffer *fb = NULL;
	struct drm_display_mode *mode = NULL;
	struct drm_mode_set set;
	uint32_t __user *set_connectors_ptr;
	int ret;
	int i;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	/*
	 * Universal plane src offsets are only 16.16, prevent havoc for
	 * drivers using universal plane code internally.
	 */
	if (crtc_req->x & 0xffff0000 || crtc_req->y & 0xffff0000)
		return -ERANGE;

	drm_modeset_lock_all(dev);
	crtc = drm_crtc_find(dev, crtc_req->crtc_id);
	if (!crtc) {
		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", crtc_req->crtc_id);
		ret = -ENOENT;
		goto out;
	}
	DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);

	if (crtc_req->mode_valid) {
		/* If we have a mode we need a framebuffer. */
		/* If we pass -1, set the mode with the currently bound fb */
		if (crtc_req->fb_id == -1) {
			if (!crtc->primary->fb) {
				DRM_DEBUG_KMS("CRTC doesn't have current FB\n");
				ret = -EINVAL;
				goto out;
			}
			fb = crtc->primary->fb;
			/* Make refcounting symmetric with the lookup path. */
			drm_framebuffer_reference(fb);
		} else {
			fb = drm_framebuffer_lookup(dev, crtc_req->fb_id);
			if (!fb) {
				DRM_DEBUG_KMS("Unknown FB ID%d\n",
						crtc_req->fb_id);
				ret = -ENOENT;
				goto out;
			}
		}

		mode = drm_mode_create(dev);
		if (!mode) {
			ret = -ENOMEM;
			goto out;
		}

		ret = drm_mode_convert_umode(mode, &crtc_req->mode);
		if (ret) {
			DRM_DEBUG_KMS("Invalid mode\n");
			goto out;
		}

		/*
		 * Check whether the primary plane supports the fb pixel format.
		 * Drivers not implementing the universal planes API use a
		 * default formats list provided by the DRM core which doesn't
		 * match real hardware capabilities. Skip the check in that
		 * case.
		 */
		if (!crtc->primary->format_default) {
			ret = drm_plane_check_pixel_format(crtc->primary,
							   fb->pixel_format);
			if (ret) {
				DRM_DEBUG_KMS("Invalid pixel format %s\n",
					drm_get_format_name(fb->pixel_format));
				goto out;
			}
		}

		ret = drm_crtc_check_viewport(crtc, crtc_req->x, crtc_req->y,
					      mode, fb);
		if (ret)
			goto out;

	}

	if (crtc_req->count_connectors == 0 && mode) {
		DRM_DEBUG_KMS("Count connectors is 0 but mode set\n");
		ret = -EINVAL;
		goto out;
	}

	if (crtc_req->count_connectors > 0 && (!mode || !fb)) {
		DRM_DEBUG_KMS("Count connectors is %d but no mode or fb set\n",
			  crtc_req->count_connectors);
		ret = -EINVAL;
		goto out;
	}

	if (crtc_req->count_connectors > 0) {
		u32 out_id;

		/* Avoid unbounded kernel memory allocation */
		if (crtc_req->count_connectors > config->num_connector) {
			ret = -EINVAL;
			goto out;
		}

		connector_set = kmalloc_array(crtc_req->count_connectors,
					      sizeof(struct drm_connector *),
					      GFP_KERNEL);
		if (!connector_set) {
			ret = -ENOMEM;
			goto out;
		}

		for (i = 0; i < crtc_req->count_connectors; i++) {
			set_connectors_ptr = (uint32_t __user *)(unsigned long)crtc_req->set_connectors_ptr;
			if (get_user(out_id, &set_connectors_ptr[i])) {
				ret = -EFAULT;
				goto out;
			}

			connector = drm_connector_find(dev, out_id);
			if (!connector) {
				DRM_DEBUG_KMS("Connector id %d unknown\n",
						out_id);
				ret = -ENOENT;
				goto out;
			}
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
					connector->base.id,
					connector->name);

			connector_set[i] = connector;
		}
	}

	set.crtc = crtc;
	set.x = crtc_req->x;
	set.y = crtc_req->y;
	set.mode = mode;
	set.connectors = connector_set;
	set.num_connectors = crtc_req->count_connectors;
	set.fb = fb;
	ret = drm_mode_set_config_internal(&set);

out:
	if (fb)
		drm_framebuffer_unreference(fb);

	kfree(connector_set);
	drm_mode_destroy(dev, mode);
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_cursor_universal - translate legacy cursor ioctl call into a
 *     universal plane handler call
 * @@crtc: crtc to update cursor for
 * @@req: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Legacy cursor ioctl's work directly with driver buffer handles.  To
 * translate legacy ioctl calls into universal plane handler calls, we need to
 * wrap the native buffer handle in a drm_framebuffer.
 *
 * Note that we assume any handle passed to the legacy ioctls was a 32-bit ARGB
 * buffer with a pitch of 4*width; the universal plane interface should be used
 * directly in cases where the hardware can support other buffer settings and
 * userspace wants to make use of these capabilities.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
static int drm_mode_cursor_universal(struct drm_crtc *crtc,
				     struct drm_mode_cursor2 *req,
				     struct drm_file *file_priv)
{
	struct drm_device *dev = crtc->dev;
	struct drm_framebuffer *fb = NULL;
	struct drm_mode_fb_cmd2 fbreq = {
		.width = req->width,
		.height = req->height,
		.pixel_format = DRM_FORMAT_ARGB8888,
		.pitches = { req->width * 4 },
		.handles = { req->handle },
	};
	int32_t crtc_x, crtc_y;
	uint32_t crtc_w = 0, crtc_h = 0;
	uint32_t src_w = 0, src_h = 0;
	int ret = 0;

	BUG_ON(!crtc->cursor);
	WARN_ON(crtc->cursor->crtc != crtc && crtc->cursor->crtc != NULL);

	/*
	 * Obtain fb we'll be using (either new or existing) and take an extra
	 * reference to it if fb != null.  setplane will take care of dropping
	 * the reference if the plane update fails.
	 */
	if (req->flags & DRM_MODE_CURSOR_BO) {
		if (req->handle) {
			fb = internal_framebuffer_create(dev, &fbreq, file_priv);
			if (IS_ERR(fb)) {
				DRM_DEBUG_KMS("failed to wrap cursor buffer in drm framebuffer\n");
				return PTR_ERR(fb);
			}
		} else {
			fb = NULL;
		}
	} else {
		fb = crtc->cursor->fb;
		if (fb)
			drm_framebuffer_reference(fb);
	}

	if (req->flags & DRM_MODE_CURSOR_MOVE) {
		crtc_x = req->x;
		crtc_y = req->y;
	} else {
		crtc_x = crtc->cursor_x;
		crtc_y = crtc->cursor_y;
	}

	if (fb) {
		crtc_w = fb->width;
		crtc_h = fb->height;
		src_w = fb->width << 16;
		src_h = fb->height << 16;
	}

	/*
	 * setplane_internal will take care of deref'ing either the old or new
	 * framebuffer depending on success.
	 */
	ret = __setplane_internal(crtc->cursor, crtc, fb,
				crtc_x, crtc_y, crtc_w, crtc_h,
				0, 0, src_w, src_h);

	/* Update successful; save new cursor position, if necessary */
	if (ret == 0 && req->flags & DRM_MODE_CURSOR_MOVE) {
		crtc->cursor_x = req->x;
		crtc->cursor_y = req->y;
	}

	return ret;
}

static int drm_mode_cursor_common(struct drm_device *dev,
				  struct drm_mode_cursor2 *req,
				  struct drm_file *file_priv)
{
	struct drm_crtc *crtc;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if (!req->flags || (~DRM_MODE_CURSOR_FLAGS & req->flags))
		return -EINVAL;

	crtc = drm_crtc_find(dev, req->crtc_id);
	if (!crtc) {
		DRM_DEBUG_KMS("Unknown CRTC ID %d\n", req->crtc_id);
		return -ENOENT;
	}

	/*
	 * If this crtc has a universal cursor plane, call that plane's update
	 * handler rather than using legacy cursor handlers.
	 */
	drm_modeset_lock_crtc(crtc, crtc->cursor);
	if (crtc->cursor) {
		ret = drm_mode_cursor_universal(crtc, req, file_priv);
		goto out;
	}

	if (req->flags & DRM_MODE_CURSOR_BO) {
		if (!crtc->funcs->cursor_set && !crtc->funcs->cursor_set2) {
			ret = -ENXIO;
			goto out;
		}
		/* Turns off the cursor if handle is 0 */
		if (crtc->funcs->cursor_set2)
			ret = crtc->funcs->cursor_set2(crtc, file_priv, req->handle,
						      req->width, req->height, req->hot_x, req->hot_y);
		else
			ret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,
						      req->width, req->height);
	}

	if (req->flags & DRM_MODE_CURSOR_MOVE) {
		if (crtc->funcs->cursor_move) {
			ret = crtc->funcs->cursor_move(crtc, req->x, req->y);
		} else {
			ret = -EFAULT;
			goto out;
		}
	}
out:
	drm_modeset_unlock_crtc(crtc);

	return ret;

}


/**
 * drm_mode_cursor_ioctl - set CRTC's cursor configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Set the cursor configuration based on user request.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_cursor_ioctl(struct drm_device *dev,
			  void *data, struct drm_file *file_priv)
{
	struct drm_mode_cursor *req = data;
	struct drm_mode_cursor2 new_req;

	memcpy(&new_req, req, sizeof(struct drm_mode_cursor));
	new_req.hot_x = new_req.hot_y = 0;

	return drm_mode_cursor_common(dev, &new_req, file_priv);
}

/**
 * drm_mode_cursor2_ioctl - set CRTC's cursor configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Set the cursor configuration based on user request. This implements the 2nd
 * version of the cursor ioctl, which allows userspace to additionally specify
 * the hotspot of the pointer.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_cursor2_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_mode_cursor2 *req = data;

	return drm_mode_cursor_common(dev, req, file_priv);
}

/**
 * drm_mode_legacy_fb_format - compute drm fourcc code from legacy description
 * @@bpp: bits per pixels
 * @@depth: bit depth per pixel
 *
 * Computes a drm fourcc pixel format code for the given @@bpp/@@depth values.
 * Useful in fbdev emulation code, since that deals in those values.
 */
uint32_t drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth)
{
	uint32_t fmt;

	switch (bpp) {
	case 8:
		fmt = DRM_FORMAT_C8;
		break;
	case 16:
		if (depth == 15)
			fmt = DRM_FORMAT_XRGB1555;
		else
			fmt = DRM_FORMAT_RGB565;
		break;
	case 24:
		fmt = DRM_FORMAT_RGB888;
		break;
	case 32:
		if (depth == 24)
			fmt = DRM_FORMAT_XRGB8888;
		else if (depth == 30)
			fmt = DRM_FORMAT_XRGB2101010;
		else
			fmt = DRM_FORMAT_ARGB8888;
		break;
	default:
		DRM_ERROR("bad bpp, assuming x8r8g8b8 pixel format\n");
		fmt = DRM_FORMAT_XRGB8888;
		break;
	}

	return fmt;
}
EXPORT_SYMBOL(drm_mode_legacy_fb_format);

/**
 * drm_mode_addfb - add an FB to the graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Add a new FB to the specified CRTC, given a user request. This is the
 * original addfb ioctl which only supported RGB formats.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_addfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd *or = data;
	struct drm_mode_fb_cmd2 r = {};
	int ret;

	/* convert to new format and call new ioctl */
	r.fb_id = or->fb_id;
	r.width = or->width;
	r.height = or->height;
	r.pitches[0] = or->pitch;
	r.pixel_format = drm_mode_legacy_fb_format(or->bpp, or->depth);
	r.handles[0] = or->handle;

	ret = drm_mode_addfb2(dev, &r, file_priv);
	if (ret)
		return ret;

	or->fb_id = r.fb_id;

	return 0;
}

static int format_check(const struct drm_mode_fb_cmd2 *r)
{
	uint32_t format = r->pixel_format & ~DRM_FORMAT_BIG_ENDIAN;

	switch (format) {
	case DRM_FORMAT_C8:
	case DRM_FORMAT_RGB332:
	case DRM_FORMAT_BGR233:
	case DRM_FORMAT_XRGB4444:
	case DRM_FORMAT_XBGR4444:
	case DRM_FORMAT_RGBX4444:
	case DRM_FORMAT_BGRX4444:
	case DRM_FORMAT_ARGB4444:
	case DRM_FORMAT_ABGR4444:
	case DRM_FORMAT_RGBA4444:
	case DRM_FORMAT_BGRA4444:
	case DRM_FORMAT_XRGB1555:
	case DRM_FORMAT_XBGR1555:
	case DRM_FORMAT_RGBX5551:
	case DRM_FORMAT_BGRX5551:
	case DRM_FORMAT_ARGB1555:
	case DRM_FORMAT_ABGR1555:
	case DRM_FORMAT_RGBA5551:
	case DRM_FORMAT_BGRA5551:
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_BGR565:
	case DRM_FORMAT_RGB888:
	case DRM_FORMAT_BGR888:
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_RGBX8888:
	case DRM_FORMAT_BGRX8888:
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_RGBA8888:
	case DRM_FORMAT_BGRA8888:
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_RGBX1010102:
	case DRM_FORMAT_BGRX1010102:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_ABGR2101010:
	case DRM_FORMAT_RGBA1010102:
	case DRM_FORMAT_BGRA1010102:
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_AYUV:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 0;
	default:
		DRM_DEBUG_KMS("invalid pixel format %s\n",
			      drm_get_format_name(r->pixel_format));
		return -EINVAL;
	}
}

static int framebuffer_check(const struct drm_mode_fb_cmd2 *r)
{
	int ret, hsub, vsub, num_planes, i;

	ret = format_check(r);
	if (ret) {
		DRM_DEBUG_KMS("bad framebuffer format %s\n",
			      drm_get_format_name(r->pixel_format));
		return ret;
	}

	hsub = drm_format_horz_chroma_subsampling(r->pixel_format);
	vsub = drm_format_vert_chroma_subsampling(r->pixel_format);
	num_planes = drm_format_num_planes(r->pixel_format);

	if (r->width == 0 || r->width % hsub) {
		DRM_DEBUG_KMS("bad framebuffer width %u\n", r->width);
		return -EINVAL;
	}

	if (r->height == 0 || r->height % vsub) {
		DRM_DEBUG_KMS("bad framebuffer height %u\n", r->height);
		return -EINVAL;
	}

	for (i = 0; i < num_planes; i++) {
		unsigned int width = r->width / (i != 0 ? hsub : 1);
		unsigned int height = r->height / (i != 0 ? vsub : 1);
		unsigned int cpp = drm_format_plane_cpp(r->pixel_format, i);

		if (!r->handles[i]) {
			DRM_DEBUG_KMS("no buffer object handle for plane %d\n", i);
			return -EINVAL;
		}

		if ((uint64_t) width * cpp > UINT_MAX)
			return -ERANGE;

		if ((uint64_t) height * r->pitches[i] + r->offsets[i] > UINT_MAX)
			return -ERANGE;

		if (r->pitches[i] < width * cpp) {
			DRM_DEBUG_KMS("bad pitch %u for plane %d\n", r->pitches[i], i);
			return -EINVAL;
		}

		if (r->modifier[i] && !(r->flags & DRM_MODE_FB_MODIFIERS)) {
			DRM_DEBUG_KMS("bad fb modifier %llu for plane %d\n",
				      r->modifier[i], i);
			return -EINVAL;
		}

		/* modifier specific checks: */
		switch (r->modifier[i]) {
		case DRM_FORMAT_MOD_SAMSUNG_64_32_TILE:
			/* NOTE: the pitch restriction may be lifted later if it turns
			 * out that no hw has this restriction:
			 */
			if (r->pixel_format != DRM_FORMAT_NV12 ||
					width % 128 || height % 32 ||
					r->pitches[i] % 128) {
				DRM_DEBUG_KMS("bad modifier data for plane %d\n", i);
				return -EINVAL;
			}
			break;

		default:
			break;
		}
	}

	for (i = num_planes; i < 4; i++) {
		if (r->modifier[i]) {
			DRM_DEBUG_KMS("non-zero modifier for unused plane %d\n", i);
			return -EINVAL;
		}

		/* Pre-FB_MODIFIERS userspace didn't clear the structs properly. */
		if (!(r->flags & DRM_MODE_FB_MODIFIERS))
			continue;

		if (r->handles[i]) {
			DRM_DEBUG_KMS("buffer object handle for unused plane %d\n", i);
			return -EINVAL;
		}

		if (r->pitches[i]) {
			DRM_DEBUG_KMS("non-zero pitch for unused plane %d\n", i);
			return -EINVAL;
		}

		if (r->offsets[i]) {
			DRM_DEBUG_KMS("non-zero offset for unused plane %d\n", i);
			return -EINVAL;
		}
	}

	return 0;
}

static struct drm_framebuffer *
internal_framebuffer_create(struct drm_device *dev,
			    struct drm_mode_fb_cmd2 *r,
			    struct drm_file *file_priv)
{
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_framebuffer *fb;
	int ret;

	if (r->flags & ~(DRM_MODE_FB_INTERLACED | DRM_MODE_FB_MODIFIERS)) {
		DRM_DEBUG_KMS("bad framebuffer flags 0x%08x\n", r->flags);
		return ERR_PTR(-EINVAL);
	}

	if ((config->min_width > r->width) || (r->width > config->max_width)) {
		DRM_DEBUG_KMS("bad framebuffer width %d, should be >= %d && <= %d\n",
			  r->width, config->min_width, config->max_width);
		return ERR_PTR(-EINVAL);
	}
	if ((config->min_height > r->height) || (r->height > config->max_height)) {
		DRM_DEBUG_KMS("bad framebuffer height %d, should be >= %d && <= %d\n",
			  r->height, config->min_height, config->max_height);
		return ERR_PTR(-EINVAL);
	}

	if (r->flags & DRM_MODE_FB_MODIFIERS &&
	    !dev->mode_config.allow_fb_modifiers) {
		DRM_DEBUG_KMS("driver does not support fb modifiers\n");
		return ERR_PTR(-EINVAL);
	}

	ret = framebuffer_check(r);
	if (ret)
		return ERR_PTR(ret);

	fb = dev->mode_config.funcs->fb_create(dev, file_priv, r);
	if (IS_ERR(fb)) {
		DRM_DEBUG_KMS("could not create framebuffer\n");
		return fb;
	}

	return fb;
}

/**
 * drm_mode_addfb2 - add an FB to the graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Add a new FB to the specified CRTC, given a user request with format. This is
 * the 2nd version of the addfb ioctl, which supports multi-planar framebuffers
 * and uses fourcc codes as pixel format specifiers.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_addfb2(struct drm_device *dev,
		    void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd2 *r = data;
	struct drm_framebuffer *fb;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	fb = internal_framebuffer_create(dev, r, file_priv);
	if (IS_ERR(fb))
		return PTR_ERR(fb);

	/* Transfer ownership to the filp for reaping on close */

	DRM_DEBUG_KMS("[FB:%d]\n", fb->base.id);
	mutex_lock(&file_priv->fbs_lock);
	r->fb_id = fb->base.id;
	list_add(&fb->filp_head, &file_priv->fbs);
	mutex_unlock(&file_priv->fbs_lock);

	return 0;
}

struct drm_mode_rmfb_work {
	struct work_struct work;
	struct list_head fbs;
};

static void drm_mode_rmfb_work_fn(struct work_struct *w)
{
	struct drm_mode_rmfb_work *arg = container_of(w, typeof(*arg), work);

	while (!list_empty(&arg->fbs)) {
		struct drm_framebuffer *fb =
			list_first_entry(&arg->fbs, typeof(*fb), filp_head);

		list_del_init(&fb->filp_head);
		drm_framebuffer_remove(fb);
	}
}

/**
 * drm_mode_rmfb - remove an FB from the configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Remove the FB specified by the user.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_rmfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_framebuffer *fb = NULL;
	struct drm_framebuffer *fbl = NULL;
	uint32_t *id = data;
	int found = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&file_priv->fbs_lock);
	mutex_lock(&dev->mode_config.fb_lock);
	fb = __drm_framebuffer_lookup(dev, *id);
	if (!fb)
		goto fail_lookup;

	list_for_each_entry(fbl, &file_priv->fbs, filp_head)
		if (fb == fbl)
			found = 1;
	if (!found)
		goto fail_lookup;

	list_del_init(&fb->filp_head);
	mutex_unlock(&dev->mode_config.fb_lock);
	mutex_unlock(&file_priv->fbs_lock);

	/*
	 * we now own the reference that was stored in the fbs list
	 *
	 * drm_framebuffer_remove may fail with -EINTR on pending signals,
	 * so run this in a separate stack as there's no way to correctly
	 * handle this after the fb is already removed from the lookup table.
	 */
	if (atomic_read(&fb->refcount.refcount) > 1) {
		struct drm_mode_rmfb_work arg;

		INIT_WORK_ONSTACK(&arg.work, drm_mode_rmfb_work_fn);
		INIT_LIST_HEAD(&arg.fbs);
		list_add_tail(&fb->filp_head, &arg.fbs);

		schedule_work(&arg.work);
		flush_work(&arg.work);
		destroy_work_on_stack(&arg.work);
	} else
		drm_framebuffer_unreference(fb);

	return 0;

fail_lookup:
	mutex_unlock(&dev->mode_config.fb_lock);
	mutex_unlock(&file_priv->fbs_lock);

	return -ENOENT;
}

/**
 * drm_mode_getfb - get FB info
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Lookup the FB given its ID and return info about it.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getfb(struct drm_device *dev,
		   void *data, struct drm_file *file_priv)
{
	struct drm_mode_fb_cmd *r = data;
	struct drm_framebuffer *fb;
	int ret;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	fb = drm_framebuffer_lookup(dev, r->fb_id);
	if (!fb)
		return -ENOENT;

	r->height = fb->height;
	r->width = fb->width;
	r->depth = fb->depth;
	r->bpp = fb->bits_per_pixel;
	r->pitch = fb->pitches[0];
	if (fb->funcs->create_handle) {
		if (file_priv->is_master || capable(CAP_SYS_ADMIN) ||
		    drm_is_control_client(file_priv)) {
			ret = fb->funcs->create_handle(fb, file_priv,
						       &r->handle);
		} else {
			/* GET_FB() is an unprivileged ioctl so we must not
			 * return a buffer-handle to non-master processes! For
			 * backwards-compatibility reasons, we cannot make
			 * GET_FB() privileged, so just return an invalid handle
			 * for non-masters. */
			r->handle = 0;
			ret = 0;
		}
	} else {
		ret = -ENODEV;
	}

	drm_framebuffer_unreference(fb);

	return ret;
}

/**
 * drm_mode_dirtyfb_ioctl - flush frontbuffer rendering on an FB
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Lookup the FB and flush out the damaged area supplied by userspace as a clip
 * rectangle list. Generic userspace which does frontbuffer rendering must call
 * this ioctl to flush out the changes on manual-update display outputs, e.g.
 * usb display-link, mipi manual update panels or edp panel self refresh modes.
 *
 * Modesetting drivers which always update the frontbuffer do not need to
 * implement the corresponding ->dirty framebuffer callback.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_clip_rect __user *clips_ptr;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = data;
	struct drm_framebuffer *fb;
	unsigned flags;
	int num_clips;
	int ret;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	fb = drm_framebuffer_lookup(dev, r->fb_id);
	if (!fb)
		return -ENOENT;

	num_clips = r->num_clips;
	clips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;

	if (!num_clips != !clips_ptr) {
		ret = -EINVAL;
		goto out_err1;
	}

	flags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;

	/* If userspace annotates copy, clips must come in pairs */
	if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {
		ret = -EINVAL;
		goto out_err1;
	}

	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
		clips = kcalloc(num_clips, sizeof(*clips), GFP_KERNEL);
		if (!clips) {
			ret = -ENOMEM;
			goto out_err1;
		}

		ret = copy_from_user(clips, clips_ptr,
				     num_clips * sizeof(*clips));
		if (ret) {
			ret = -EFAULT;
			goto out_err2;
		}
	}

	if (fb->funcs->dirty) {
		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
				       clips, num_clips);
	} else {
		ret = -ENOSYS;
	}

out_err2:
	kfree(clips);
out_err1:
	drm_framebuffer_unreference(fb);

	return ret;
}

/**
 * drm_fb_release - remove and free the FBs on this file
 * @@priv: drm file for the ioctl
 *
 * Destroy all the FBs associated with @@filp.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
void drm_fb_release(struct drm_file *priv)
{
	struct drm_framebuffer *fb, *tfb;
	struct drm_mode_rmfb_work arg;

	INIT_LIST_HEAD(&arg.fbs);

	/*
	 * When the file gets released that means no one else can access the fb
	 * list any more, so no need to grab fpriv->fbs_lock. And we need to
	 * avoid upsetting lockdep since the universal cursor code adds a
	 * framebuffer while holding mutex locks.
	 *
	 * Note that a real deadlock between fpriv->fbs_lock and the modeset
	 * locks is impossible here since no one else but this function can get
	 * at it any more.
	 */
	list_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {
		if (atomic_read(&fb->refcount.refcount) > 1) {
			list_move_tail(&fb->filp_head, &arg.fbs);
		} else {
			list_del_init(&fb->filp_head);

			/* This drops the fpriv->fbs reference. */
			drm_framebuffer_unreference(fb);
		}
	}

	if (!list_empty(&arg.fbs)) {
		INIT_WORK_ONSTACK(&arg.work, drm_mode_rmfb_work_fn);

		schedule_work(&arg.work);
		flush_work(&arg.work);
		destroy_work_on_stack(&arg.work);
	}
}

/**
 * drm_property_create - create a new property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@num_values: number of pre-defined values
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Note that the DRM core keeps a per-device list of properties and that, if
 * drm_mode_config_cleanup() is called, it will destroy all properties created
 * by the driver.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create(struct drm_device *dev, int flags,
					 const char *name, int num_values)
{
	struct drm_property *property = NULL;
	int ret;

	property = kzalloc(sizeof(struct drm_property), GFP_KERNEL);
	if (!property)
		return NULL;

	property->dev = dev;

	if (num_values) {
		property->values = kcalloc(num_values, sizeof(uint64_t),
					   GFP_KERNEL);
		if (!property->values)
			goto fail;
	}

	ret = drm_mode_object_get(dev, &property->base, DRM_MODE_OBJECT_PROPERTY);
	if (ret)
		goto fail;

	property->flags = flags;
	property->num_values = num_values;
	INIT_LIST_HEAD(&property->enum_list);

	if (name) {
		strncpy(property->name, name, DRM_PROP_NAME_LEN);
		property->name[DRM_PROP_NAME_LEN-1] = '\0';
	}

	list_add_tail(&property->head, &dev->mode_config.property_list);

	WARN_ON(!drm_property_type_valid(property));

	return property;
fail:
	kfree(property->values);
	kfree(property);
	return NULL;
}
EXPORT_SYMBOL(drm_property_create);

/**
 * drm_property_create_enum - create a new enumeration property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@props: enumeration lists with property values
 * @@num_values: number of pre-defined values
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Userspace is only allowed to set one of the predefined values for enumeration
 * properties.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_enum(struct drm_device *dev, int flags,
					 const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_values)
{
	struct drm_property *property;
	int i, ret;

	flags |= DRM_MODE_PROP_ENUM;

	property = drm_property_create(dev, flags, name, num_values);
	if (!property)
		return NULL;

	for (i = 0; i < num_values; i++) {
		ret = drm_property_add_enum(property, i,
				      props[i].type,
				      props[i].name);
		if (ret) {
			drm_property_destroy(dev, property);
			return NULL;
		}
	}

	return property;
}
EXPORT_SYMBOL(drm_property_create_enum);

/**
 * drm_property_create_bitmask - create a new bitmask property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@props: enumeration lists with property bitflags
 * @@num_props: size of the @@props array
 * @@supported_bits: bitmask of all supported enumeration values
 *
 * This creates a new bitmask drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Compared to plain enumeration properties userspace is allowed to set any
 * or'ed together combination of the predefined property bitflag values
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_bitmask(struct drm_device *dev,
					 int flags, const char *name,
					 const struct drm_prop_enum_list *props,
					 int num_props,
					 uint64_t supported_bits)
{
	struct drm_property *property;
	int i, ret, index = 0;
	int num_values = hweight64(supported_bits);

	flags |= DRM_MODE_PROP_BITMASK;

	property = drm_property_create(dev, flags, name, num_values);
	if (!property)
		return NULL;
	for (i = 0; i < num_props; i++) {
		if (!(supported_bits & (1ULL << props[i].type)))
			continue;

		if (WARN_ON(index >= num_values)) {
			drm_property_destroy(dev, property);
			return NULL;
		}

		ret = drm_property_add_enum(property, index++,
				      props[i].type,
				      props[i].name);
		if (ret) {
			drm_property_destroy(dev, property);
			return NULL;
		}
	}

	return property;
}
EXPORT_SYMBOL(drm_property_create_bitmask);

static struct drm_property *property_create_range(struct drm_device *dev,
					 int flags, const char *name,
					 uint64_t min, uint64_t max)
{
	struct drm_property *property;

	property = drm_property_create(dev, flags, name, 2);
	if (!property)
		return NULL;

	property->values[0] = min;
	property->values[1] = max;

	return property;
}

/**
 * drm_property_create_range - create a new unsigned ranged property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@min: minimum value of the property
 * @@max: maximum value of the property
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Userspace is allowed to set any unsigned integer value in the (min, max)
 * range inclusive.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
					 const char *name,
					 uint64_t min, uint64_t max)
{
	return property_create_range(dev, DRM_MODE_PROP_RANGE | flags,
			name, min, max);
}
EXPORT_SYMBOL(drm_property_create_range);

/**
 * drm_property_create_signed_range - create a new signed ranged property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@min: minimum value of the property
 * @@max: maximum value of the property
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Userspace is allowed to set any signed integer value in the (min, max)
 * range inclusive.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_signed_range(struct drm_device *dev,
					 int flags, const char *name,
					 int64_t min, int64_t max)
{
	return property_create_range(dev, DRM_MODE_PROP_SIGNED_RANGE | flags,
			name, I642U64(min), I642U64(max));
}
EXPORT_SYMBOL(drm_property_create_signed_range);

/**
 * drm_property_create_object - create a new object property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 * @@type: object type from DRM_MODE_OBJECT_* defines
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * Userspace is only allowed to set this to any property value of the given
 * @@type. Only useful for atomic properties, which is enforced.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_object(struct drm_device *dev,
					 int flags, const char *name, uint32_t type)
{
	struct drm_property *property;

	flags |= DRM_MODE_PROP_OBJECT;

	if (WARN_ON(!(flags & DRM_MODE_PROP_ATOMIC)))
		return NULL;

	property = drm_property_create(dev, flags, name, 1);
	if (!property)
		return NULL;

	property->values[0] = type;

	return property;
}
EXPORT_SYMBOL(drm_property_create_object);

/**
 * drm_property_create_bool - create a new boolean property type
 * @@dev: drm device
 * @@flags: flags specifying the property type
 * @@name: name of the property
 *
 * This creates a new generic drm property which can then be attached to a drm
 * object with drm_object_attach_property. The returned property object must be
 * freed with drm_property_destroy.
 *
 * This is implemented as a ranged property with only {0, 1} as valid values.
 *
 * Returns:
 * A pointer to the newly created property on success, NULL on failure.
 */
struct drm_property *drm_property_create_bool(struct drm_device *dev, int flags,
					 const char *name)
{
	return drm_property_create_range(dev, flags, name, 0, 1);
}
EXPORT_SYMBOL(drm_property_create_bool);

/**
 * drm_property_add_enum - add a possible value to an enumeration property
 * @@property: enumeration property to change
 * @@index: index of the new enumeration
 * @@value: value of the new enumeration
 * @@name: symbolic name of the new enumeration
 *
 * This functions adds enumerations to a property.
 *
 * It's use is deprecated, drivers should use one of the more specific helpers
 * to directly create the property with all enumerations already attached.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_property_add_enum(struct drm_property *property, int index,
			  uint64_t value, const char *name)
{
	struct drm_property_enum *prop_enum;

	if (!(drm_property_type_is(property, DRM_MODE_PROP_ENUM) ||
			drm_property_type_is(property, DRM_MODE_PROP_BITMASK)))
		return -EINVAL;

	/*
	 * Bitmask enum properties have the additional constraint of values
	 * from 0 to 63
	 */
	if (drm_property_type_is(property, DRM_MODE_PROP_BITMASK) &&
			(value > 63))
		return -EINVAL;

	if (!list_empty(&property->enum_list)) {
		list_for_each_entry(prop_enum, &property->enum_list, head) {
			if (prop_enum->value == value) {
				strncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);
				prop_enum->name[DRM_PROP_NAME_LEN-1] = '\0';
				return 0;
			}
		}
	}

	prop_enum = kzalloc(sizeof(struct drm_property_enum), GFP_KERNEL);
	if (!prop_enum)
		return -ENOMEM;

	strncpy(prop_enum->name, name, DRM_PROP_NAME_LEN);
	prop_enum->name[DRM_PROP_NAME_LEN-1] = '\0';
	prop_enum->value = value;

	property->values[index] = value;
	list_add_tail(&prop_enum->head, &property->enum_list);
	return 0;
}
EXPORT_SYMBOL(drm_property_add_enum);

/**
 * drm_property_destroy - destroy a drm property
 * @@dev: drm device
 * @@property: property to destry
 *
 * This function frees a property including any attached resources like
 * enumeration values.
 */
void drm_property_destroy(struct drm_device *dev, struct drm_property *property)
{
	struct drm_property_enum *prop_enum, *pt;

	list_for_each_entry_safe(prop_enum, pt, &property->enum_list, head) {
		list_del(&prop_enum->head);
		kfree(prop_enum);
	}

	if (property->num_values)
		kfree(property->values);
	drm_mode_object_put(dev, &property->base);
	list_del(&property->head);
	kfree(property);
}
EXPORT_SYMBOL(drm_property_destroy);

/**
 * drm_object_attach_property - attach a property to a modeset object
 * @@obj: drm modeset object
 * @@property: property to attach
 * @@init_val: initial value of the property
 *
 * This attaches the given property to the modeset object with the given initial
 * value. Currently this function cannot fail since the properties are stored in
 * a statically sized array.
 */
void drm_object_attach_property(struct drm_mode_object *obj,
				struct drm_property *property,
				uint64_t init_val)
{
	int count = obj->properties->count;

	if (count == DRM_OBJECT_MAX_PROPERTY) {
		WARN(1, "Failed to attach object property (type: 0x%x). Please "
			"increase DRM_OBJECT_MAX_PROPERTY by 1 for each time "
			"you see this message on the same object type.\n",
			obj->type);
		return;
	}

	obj->properties->properties[count] = property;
	obj->properties->values[count] = init_val;
	obj->properties->count++;
	if (property->flags & DRM_MODE_PROP_ATOMIC)
		obj->properties->atomic_count++;
}
EXPORT_SYMBOL(drm_object_attach_property);

/**
 * drm_object_property_set_value - set the value of a property
 * @@obj: drm mode object to set property value for
 * @@property: property to set
 * @@val: value the property should be set to
 *
 * This functions sets a given property on a given object. This function only
 * changes the software state of the property, it does not call into the
 * driver's ->set_property callback.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_object_property_set_value(struct drm_mode_object *obj,
				  struct drm_property *property, uint64_t val)
{
	int i;

	for (i = 0; i < obj->properties->count; i++) {
		if (obj->properties->properties[i] == property) {
			obj->properties->values[i] = val;
			return 0;
		}
	}

	return -EINVAL;
}
EXPORT_SYMBOL(drm_object_property_set_value);

/**
 * drm_object_property_get_value - retrieve the value of a property
 * @@obj: drm mode object to get property value from
 * @@property: property to retrieve
 * @@val: storage for the property value
 *
 * This function retrieves the softare state of the given property for the given
 * property. Since there is no driver callback to retrieve the current property
 * value this might be out of sync with the hardware, depending upon the driver
 * and property.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_object_property_get_value(struct drm_mode_object *obj,
				  struct drm_property *property, uint64_t *val)
{
	int i;

#ifdef __OpenBSD__
	if (obj->type == DRM_MODE_OBJECT_CONNECTOR) {
		struct drm_connector *connector = obj_to_connector(obj);

		if (property == connector->backlight_property) {
			struct backlight_device *bd =
				connector->backlight_device;

			if (bd->props.type == BACKLIGHT_FIRMWARE)
				*val = bd->ops->get_brightness(bd);
			else
				*val = bd->props.brightness;
			return 0;
		}
	}
#endif

	/* read-only properties bypass atomic mechanism and still store
	 * their value in obj->properties->values[].. mostly to avoid
	 * having to deal w/ EDID and similar props in atomic paths:
	 */
	if (drm_core_check_feature(property->dev, DRIVER_ATOMIC) &&
			!(property->flags & DRM_MODE_PROP_IMMUTABLE))
		return drm_atomic_get_property(obj, property, val);

	for (i = 0; i < obj->properties->count; i++) {
		if (obj->properties->properties[i] == property) {
			*val = obj->properties->values[i];
			return 0;
		}
	}

	return -EINVAL;
}
EXPORT_SYMBOL(drm_object_property_get_value);

/**
 * drm_mode_getproperty_ioctl - get the property metadata
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function retrieves the metadata for a given property, like the different
 * possible values for an enum property or the limits for a range property.
 *
 * Blob properties are special
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getproperty_ioctl(struct drm_device *dev,
			       void *data, struct drm_file *file_priv)
{
	struct drm_mode_get_property *out_resp = data;
	struct drm_property *property;
	int enum_count = 0;
	int value_count = 0;
	int ret = 0, i;
	int copied;
	struct drm_property_enum *prop_enum;
	struct drm_mode_property_enum __user *enum_ptr;
	uint64_t __user *values_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	property = drm_property_find(dev, out_resp->prop_id);
	if (!property) {
		ret = -ENOENT;
		goto done;
	}

	if (drm_property_type_is(property, DRM_MODE_PROP_ENUM) ||
			drm_property_type_is(property, DRM_MODE_PROP_BITMASK)) {
		list_for_each_entry(prop_enum, &property->enum_list, head)
			enum_count++;
	}

	value_count = property->num_values;

	strncpy(out_resp->name, property->name, DRM_PROP_NAME_LEN);
	out_resp->name[DRM_PROP_NAME_LEN-1] = 0;
	out_resp->flags = property->flags;

	if ((out_resp->count_values >= value_count) && value_count) {
		values_ptr = (uint64_t __user *)(unsigned long)out_resp->values_ptr;
		for (i = 0; i < value_count; i++) {
			if (copy_to_user(values_ptr + i, &property->values[i], sizeof(uint64_t))) {
				ret = -EFAULT;
				goto done;
			}
		}
	}
	out_resp->count_values = value_count;

	if (drm_property_type_is(property, DRM_MODE_PROP_ENUM) ||
			drm_property_type_is(property, DRM_MODE_PROP_BITMASK)) {
		if ((out_resp->count_enum_blobs >= enum_count) && enum_count) {
			copied = 0;
			enum_ptr = (struct drm_mode_property_enum __user *)(unsigned long)out_resp->enum_blob_ptr;
			list_for_each_entry(prop_enum, &property->enum_list, head) {

				if (copy_to_user(&enum_ptr[copied].value, &prop_enum->value, sizeof(uint64_t))) {
					ret = -EFAULT;
					goto done;
				}

				if (copy_to_user(&enum_ptr[copied].name,
						 &prop_enum->name, DRM_PROP_NAME_LEN)) {
					ret = -EFAULT;
					goto done;
				}
				copied++;
			}
		}
		out_resp->count_enum_blobs = enum_count;
	}

	/*
	 * NOTE: The idea seems to have been to use this to read all the blob
	 * property values. But nothing ever added them to the corresponding
	 * list, userspace always used the special-purpose get_blob ioctl to
	 * read the value for a blob property. It also doesn't make a lot of
	 * sense to return values here when everything else is just metadata for
	 * the property itself.
	 */
	if (drm_property_type_is(property, DRM_MODE_PROP_BLOB))
		out_resp->count_enum_blobs = 0;
done:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_property_create_blob - Create new blob property
 *
 * Creates a new blob property for a specified DRM device, optionally
 * copying data.
 *
 * @@dev: DRM device to create property for
 * @@length: Length to allocate for blob data
 * @@data: If specified, copies data into blob
 *
 * Returns:
 * New blob property with a single reference on success, or an ERR_PTR
 * value on failure.
 */
struct drm_property_blob *
drm_property_create_blob(struct drm_device *dev, size_t length,
			 const void *data)
{
	struct drm_property_blob *blob;
	int ret;

	if (!length || length > ULONG_MAX - sizeof(struct drm_property_blob))
		return ERR_PTR(-EINVAL);

	blob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);
	if (!blob)
		return ERR_PTR(-ENOMEM);

	/* This must be explicitly initialised, so we can safely call list_del
	 * on it in the removal handler, even if it isn't in a file list. */
	INIT_LIST_HEAD(&blob->head_file);
	blob->length = length;
	blob->dev = dev;

	if (data)
		memcpy(blob->data, data, length);

	mutex_lock(&dev->mode_config.blob_lock);

	ret = drm_mode_object_get(dev, &blob->base, DRM_MODE_OBJECT_BLOB);
	if (ret) {
		kfree(blob);
		mutex_unlock(&dev->mode_config.blob_lock);
		return ERR_PTR(-EINVAL);
	}

	kref_init(&blob->refcount);

	list_add_tail(&blob->head_global,
	              &dev->mode_config.property_blob_list);

	mutex_unlock(&dev->mode_config.blob_lock);

	return blob;
}
EXPORT_SYMBOL(drm_property_create_blob);

/**
 * drm_property_free_blob - Blob property destructor
 *
 * Internal free function for blob properties; must not be used directly.
 *
 * @@kref: Reference
 */
static void drm_property_free_blob(struct kref *kref)
{
	struct drm_property_blob *blob =
		container_of(kref, struct drm_property_blob, refcount);

	WARN_ON(!mutex_is_locked(&blob->dev->mode_config.blob_lock));

	list_del(&blob->head_global);
	list_del(&blob->head_file);
	drm_mode_object_put(blob->dev, &blob->base);

	kfree(blob);
}

/**
 * drm_property_unreference_blob - Unreference a blob property
 *
 * Drop a reference on a blob property. May free the object.
 *
 * @@blob: Pointer to blob property
 */
void drm_property_unreference_blob(struct drm_property_blob *blob)
{
	struct drm_device *dev;

	if (!blob)
		return;

	dev = blob->dev;

	DRM_DEBUG("%p: blob ID: %d (%d)\n", blob, blob->base.id, atomic_read(&blob->refcount.refcount));

	if (kref_put_mutex(&blob->refcount, drm_property_free_blob,
			   &dev->mode_config.blob_lock))
		mutex_unlock(&dev->mode_config.blob_lock);
	else
		might_lock(&dev->mode_config.blob_lock);
}
EXPORT_SYMBOL(drm_property_unreference_blob);

/**
 * drm_property_unreference_blob_locked - Unreference a blob property with blob_lock held
 *
 * Drop a reference on a blob property. May free the object. This must be
 * called with blob_lock held.
 *
 * @@blob: Pointer to blob property
 */
static void drm_property_unreference_blob_locked(struct drm_property_blob *blob)
{
	if (!blob)
		return;

	DRM_DEBUG("%p: blob ID: %d (%d)\n", blob, blob->base.id, atomic_read(&blob->refcount.refcount));

	kref_put(&blob->refcount, drm_property_free_blob);
}

/**
 * drm_property_destroy_user_blobs - destroy all blobs created by this client
 * @@dev:       DRM device
 * @@file_priv: destroy all blobs owned by this file handle
 */
void drm_property_destroy_user_blobs(struct drm_device *dev,
				     struct drm_file *file_priv)
{
	struct drm_property_blob *blob, *bt;

	mutex_lock(&dev->mode_config.blob_lock);

	list_for_each_entry_safe(blob, bt, &file_priv->blobs, head_file) {
		list_del_init(&blob->head_file);
		drm_property_unreference_blob_locked(blob);
	}

	mutex_unlock(&dev->mode_config.blob_lock);
}

/**
 * drm_property_reference_blob - Take a reference on an existing property
 *
 * Take a new reference on an existing blob property.
 *
 * @@blob: Pointer to blob property
 */
struct drm_property_blob *drm_property_reference_blob(struct drm_property_blob *blob)
{
	DRM_DEBUG("%p: blob ID: %d (%d)\n", blob, blob->base.id, atomic_read(&blob->refcount.refcount));
	kref_get(&blob->refcount);
	return blob;
}
EXPORT_SYMBOL(drm_property_reference_blob);

/*
 * Like drm_property_lookup_blob, but does not return an additional reference.
 * Must be called with blob_lock held.
 */
static struct drm_property_blob *__drm_property_lookup_blob(struct drm_device *dev,
							    uint32_t id)
{
	struct drm_mode_object *obj = NULL;
	struct drm_property_blob *blob;

	WARN_ON(!mutex_is_locked(&dev->mode_config.blob_lock));

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != DRM_MODE_OBJECT_BLOB) || (obj->id != id))
		blob = NULL;
	else
		blob = obj_to_blob(obj);
	mutex_unlock(&dev->mode_config.idr_mutex);

	return blob;
}

/**
 * drm_property_lookup_blob - look up a blob property and take a reference
 * @@dev: drm device
 * @@id: id of the blob property
 *
 * If successful, this takes an additional reference to the blob property.
 * callers need to make sure to eventually unreference the returned property
 * again, using @@drm_property_unreference_blob.
 */
struct drm_property_blob *drm_property_lookup_blob(struct drm_device *dev,
					           uint32_t id)
{
	struct drm_property_blob *blob;

	mutex_lock(&dev->mode_config.blob_lock);
	blob = __drm_property_lookup_blob(dev, id);
	if (blob) {
		if (!kref_get_unless_zero(&blob->refcount))
			blob = NULL;
	}
	mutex_unlock(&dev->mode_config.blob_lock);

	return blob;
}
EXPORT_SYMBOL(drm_property_lookup_blob);

/**
 * drm_property_replace_global_blob - atomically replace existing blob property
 * @@dev: drm device
 * @@replace: location of blob property pointer to be replaced
 * @@length: length of data for new blob, or 0 for no data
 * @@data: content for new blob, or NULL for no data
 * @@obj_holds_id: optional object for property holding blob ID
 * @@prop_holds_id: optional property holding blob ID
 * @@return 0 on success or error on failure
 *
 * This function will atomically replace a global property in the blob list,
 * optionally updating a property which holds the ID of that property. It is
 * guaranteed to be atomic: no caller will be allowed to see intermediate
 * results, and either the entire operation will succeed and clean up the
 * previous property, or it will fail and the state will be unchanged.
 *
 * If length is 0 or data is NULL, no new blob will be created, and the holding
 * property, if specified, will be set to 0.
 *
 * Access to the replace pointer is assumed to be protected by the caller, e.g.
 * by holding the relevant modesetting object lock for its parent.
 *
 * For example, a drm_connector has a 'PATH' property, which contains the ID
 * of a blob property with the value of the MST path information. Calling this
 * function with replace pointing to the connector's path_blob_ptr, length and
 * data set for the new path information, obj_holds_id set to the connector's
 * base object, and prop_holds_id set to the path property name, will perform
 * a completely atomic update. The access to path_blob_ptr is protected by the
 * caller holding a lock on the connector.
 */
static int drm_property_replace_global_blob(struct drm_device *dev,
                                            struct drm_property_blob **replace,
                                            size_t length,
                                            const void *data,
                                            struct drm_mode_object *obj_holds_id,
                                            struct drm_property *prop_holds_id)
{
	struct drm_property_blob *new_blob = NULL;
	struct drm_property_blob *old_blob = NULL;
	int ret;

	WARN_ON(replace == NULL);

	old_blob = *replace;

	if (length && data) {
		new_blob = drm_property_create_blob(dev, length, data);
		if (IS_ERR(new_blob))
			return PTR_ERR(new_blob);
	}

	/* This does not need to be synchronised with blob_lock, as the
	 * get_properties ioctl locks all modesetting objects, and
	 * obj_holds_id must be locked before calling here, so we cannot
	 * have its value out of sync with the list membership modified
	 * below under blob_lock. */
	if (obj_holds_id) {
		ret = drm_object_property_set_value(obj_holds_id,
						    prop_holds_id,
						    new_blob ?
						        new_blob->base.id : 0);
		if (ret != 0)
			goto err_created;
	}

	drm_property_unreference_blob(old_blob);
	*replace = new_blob;

	return 0;

err_created:
	drm_property_unreference_blob(new_blob);
	return ret;
}

/**
 * drm_mode_getblob_ioctl - get the contents of a blob property value
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function retrieves the contents of a blob property. The value stored in
 * an object's blob property is just a normal modeset object id.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_getblob_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_mode_get_blob *out_resp = data;
	struct drm_property_blob *blob;
	int ret = 0;
	void __user *blob_ptr;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	mutex_lock(&dev->mode_config.blob_lock);
	blob = __drm_property_lookup_blob(dev, out_resp->blob_id);
	if (!blob) {
		ret = -ENOENT;
		goto done;
	}

	if (out_resp->length == blob->length) {
		blob_ptr = (void __user *)(unsigned long)out_resp->data;
		if (copy_to_user(blob_ptr, blob->data, blob->length)) {
			ret = -EFAULT;
			goto done;
		}
	}
	out_resp->length = blob->length;

done:
	mutex_unlock(&dev->mode_config.blob_lock);
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_createblob_ioctl - create a new blob property
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function creates a new blob property with user-defined values. In order
 * to give us sensible validation and checking when creating, rather than at
 * every potential use, we also require a type to be provided upfront.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_createblob_ioctl(struct drm_device *dev,
			      void *data, struct drm_file *file_priv)
{
	struct drm_mode_create_blob *out_resp = data;
	struct drm_property_blob *blob;
	void __user *blob_ptr;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	blob = drm_property_create_blob(dev, out_resp->length, NULL);
	if (IS_ERR(blob))
		return PTR_ERR(blob);

	blob_ptr = (void __user *)(unsigned long)out_resp->data;
	if (copy_from_user(blob->data, blob_ptr, out_resp->length)) {
		ret = -EFAULT;
		goto out_blob;
	}

	/* Dropping the lock between create_blob and our access here is safe
	 * as only the same file_priv can remove the blob; at this point, it is
	 * not associated with any file_priv. */
	mutex_lock(&dev->mode_config.blob_lock);
	out_resp->blob_id = blob->base.id;
	list_add_tail(&blob->head_file, &file_priv->blobs);
	mutex_unlock(&dev->mode_config.blob_lock);

	return 0;

out_blob:
	drm_property_unreference_blob(blob);
	return ret;
}

/**
 * drm_mode_destroyblob_ioctl - destroy a user blob property
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Destroy an existing user-defined blob property.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_destroyblob_ioctl(struct drm_device *dev,
			       void *data, struct drm_file *file_priv)
{
	struct drm_mode_destroy_blob *out_resp = data;
	struct drm_property_blob *blob = NULL, *bt;
	bool found = false;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&dev->mode_config.blob_lock);
	blob = __drm_property_lookup_blob(dev, out_resp->blob_id);
	if (!blob) {
		ret = -ENOENT;
		goto err;
	}

	/* Ensure the property was actually created by this user. */
	list_for_each_entry(bt, &file_priv->blobs, head_file) {
		if (bt == blob) {
			found = true;
			break;
		}
	}

	if (!found) {
		ret = -EPERM;
		goto err;
	}

	/* We must drop head_file here, because we may not be the last
	 * reference on the blob. */
	list_del_init(&blob->head_file);
	drm_property_unreference_blob_locked(blob);
	mutex_unlock(&dev->mode_config.blob_lock);

	return 0;

err:
	mutex_unlock(&dev->mode_config.blob_lock);
	return ret;
}

/**
 * drm_mode_connector_set_path_property - set tile property on connector
 * @@connector: connector to set property on.
 * @@path: path to use for property; must not be NULL.
 *
 * This creates a property to expose to userspace to specify a
 * connector path. This is mainly used for DisplayPort MST where
 * connectors have a topology and we want to allow userspace to give
 * them more meaningful names.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_connector_set_path_property(struct drm_connector *connector,
					 const char *path)
{
	struct drm_device *dev = connector->dev;
	int ret;

	ret = drm_property_replace_global_blob(dev,
	                                       &connector->path_blob_ptr,
	                                       strlen(path) + 1,
	                                       path,
	                                       &connector->base,
	                                       dev->mode_config.path_property);
	return ret;
}
EXPORT_SYMBOL(drm_mode_connector_set_path_property);

/**
 * drm_mode_connector_set_tile_property - set tile property on connector
 * @@connector: connector to set property on.
 *
 * This looks up the tile information for a connector, and creates a
 * property for userspace to parse if it exists. The property is of
 * the form of 8 integers using ':' as a separator.
 *
 * Returns:
 * Zero on success, errno on failure.
 */
int drm_mode_connector_set_tile_property(struct drm_connector *connector)
{
	struct drm_device *dev = connector->dev;
	char tile[256];
	int ret;

	if (!connector->has_tile) {
		ret  = drm_property_replace_global_blob(dev,
		                                        &connector->tile_blob_ptr,
		                                        0,
		                                        NULL,
		                                        &connector->base,
		                                        dev->mode_config.tile_property);
		return ret;
	}

	snprintf(tile, 256, "%d:%d:%d:%d:%d:%d:%d:%d",
		 connector->tile_group->id, connector->tile_is_single_monitor,
		 connector->num_h_tile, connector->num_v_tile,
		 connector->tile_h_loc, connector->tile_v_loc,
		 connector->tile_h_size, connector->tile_v_size);

	ret = drm_property_replace_global_blob(dev,
	                                       &connector->tile_blob_ptr,
	                                       strlen(tile) + 1,
	                                       tile,
	                                       &connector->base,
	                                       dev->mode_config.tile_property);
	return ret;
}
EXPORT_SYMBOL(drm_mode_connector_set_tile_property);

/**
 * drm_mode_connector_update_edid_property - update the edid property of a connector
 * @@connector: drm connector
 * @@edid: new value of the edid property
 *
 * This function creates a new blob modeset object and assigns its id to the
 * connector's edid property.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_connector_update_edid_property(struct drm_connector *connector,
					    const struct edid *edid)
{
	struct drm_device *dev = connector->dev;
	size_t size = 0;
	int ret;

	/* ignore requests to set edid when overridden */
	if (connector->override_edid)
		return 0;

	if (edid)
		size = EDID_LENGTH * (1 + edid->extensions);

	ret = drm_property_replace_global_blob(dev,
					       &connector->edid_blob_ptr,
	                                       size,
	                                       edid,
	                                       &connector->base,
	                                       dev->mode_config.edid_property);
	return ret;
}
EXPORT_SYMBOL(drm_mode_connector_update_edid_property);

/* Some properties could refer to dynamic refcnt'd objects, or things that
 * need special locking to handle lifetime issues (ie. to ensure the prop
 * value doesn't become invalid part way through the property update due to
 * race).  The value returned by reference via 'obj' should be passed back
 * to drm_property_change_valid_put() after the property is set (and the
 * object to which the property is attached has a chance to take it's own
 * reference).
 */
bool drm_property_change_valid_get(struct drm_property *property,
					 uint64_t value, struct drm_mode_object **ref)
{
	int i;

	if (property->flags & DRM_MODE_PROP_IMMUTABLE)
		return false;

	*ref = NULL;

	if (drm_property_type_is(property, DRM_MODE_PROP_RANGE)) {
		if (value < property->values[0] || value > property->values[1])
			return false;
		return true;
	} else if (drm_property_type_is(property, DRM_MODE_PROP_SIGNED_RANGE)) {
		int64_t svalue = U642I64(value);

		if (svalue < U642I64(property->values[0]) ||
				svalue > U642I64(property->values[1]))
			return false;
		return true;
	} else if (drm_property_type_is(property, DRM_MODE_PROP_BITMASK)) {
		uint64_t valid_mask = 0;

		for (i = 0; i < property->num_values; i++)
			valid_mask |= (1ULL << property->values[i]);
		return !(value & ~valid_mask);
	} else if (drm_property_type_is(property, DRM_MODE_PROP_BLOB)) {
		struct drm_property_blob *blob;

		if (value == 0)
			return true;

		blob = drm_property_lookup_blob(property->dev, value);
		if (blob) {
			*ref = &blob->base;
			return true;
		} else {
			return false;
		}
	} else if (drm_property_type_is(property, DRM_MODE_PROP_OBJECT)) {
		/* a zero value for an object property translates to null: */
		if (value == 0)
			return true;

		/* handle refcnt'd objects specially: */
		if (property->values[0] == DRM_MODE_OBJECT_FB) {
			struct drm_framebuffer *fb;
			fb = drm_framebuffer_lookup(property->dev, value);
			if (fb) {
				*ref = &fb->base;
				return true;
			} else {
				return false;
			}
		} else {
			return _object_find(property->dev, value, property->values[0]) != NULL;
		}
	}

	for (i = 0; i < property->num_values; i++)
		if (property->values[i] == value)
			return true;
	return false;
}

void drm_property_change_valid_put(struct drm_property *property,
		struct drm_mode_object *ref)
{
	if (!ref)
		return;

	if (drm_property_type_is(property, DRM_MODE_PROP_OBJECT)) {
		if (property->values[0] == DRM_MODE_OBJECT_FB)
			drm_framebuffer_unreference(obj_to_fb(ref));
	} else if (drm_property_type_is(property, DRM_MODE_PROP_BLOB))
		drm_property_unreference_blob(obj_to_blob(ref));
}

/**
 * drm_mode_connector_property_set_ioctl - set the current value of a connector property
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function sets the current value for a connectors's property. It also
 * calls into a driver's ->set_property callback to update the hardware state
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_connector_property_set_ioctl(struct drm_device *dev,
				       void *data, struct drm_file *file_priv)
{
	struct drm_mode_connector_set_property *conn_set_prop = data;
	struct drm_mode_obj_set_property obj_set_prop = {
		.value = conn_set_prop->value,
		.prop_id = conn_set_prop->prop_id,
		.obj_id = conn_set_prop->connector_id,
		.obj_type = DRM_MODE_OBJECT_CONNECTOR
	};

	/* It does all the locking and checking we need */
	return drm_mode_obj_set_property_ioctl(dev, &obj_set_prop, file_priv);
}

static int drm_mode_connector_set_obj_prop(struct drm_mode_object *obj,
					   struct drm_property *property,
					   uint64_t value)
{
	int ret = -EINVAL;
	struct drm_connector *connector = obj_to_connector(obj);

	/* Do DPMS ourselves */
	if (property == connector->dev->mode_config.dpms_property) {
		ret = 0;
		if (connector->funcs->dpms)
			ret = (*connector->funcs->dpms)(connector, (int)value);
#ifdef __OpenBSD__
	} else if (property == connector->backlight_property) {
		ret = 0;
		connector->backlight_device->props.brightness = value;
		backlight_schedule_update_status(connector->backlight_device);
#endif
	} else if (connector->funcs->set_property)
		ret = connector->funcs->set_property(connector, property, value);

	/* store the property value if successful */
	if (!ret)
		drm_object_property_set_value(&connector->base, property, value);
	return ret;
}

static int drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,
				      struct drm_property *property,
				      uint64_t value)
{
	int ret = -EINVAL;
	struct drm_crtc *crtc = obj_to_crtc(obj);

	if (crtc->funcs->set_property)
		ret = crtc->funcs->set_property(crtc, property, value);
	if (!ret)
		drm_object_property_set_value(obj, property, value);

	return ret;
}

/**
 * drm_mode_plane_set_obj_prop - set the value of a property
 * @@plane: drm plane object to set property value for
 * @@property: property to set
 * @@value: value the property should be set to
 *
 * This functions sets a given property on a given plane object. This function
 * calls the driver's ->set_property callback and changes the software state of
 * the property if the callback succeeds.
 *
 * Returns:
 * Zero on success, error code on failure.
 */
int drm_mode_plane_set_obj_prop(struct drm_plane *plane,
				struct drm_property *property,
				uint64_t value)
{
	int ret = -EINVAL;
	struct drm_mode_object *obj = &plane->base;

	if (plane->funcs->set_property)
		ret = plane->funcs->set_property(plane, property, value);
	if (!ret)
		drm_object_property_set_value(obj, property, value);

	return ret;
}
EXPORT_SYMBOL(drm_mode_plane_set_obj_prop);

/**
 * drm_mode_obj_get_properties_ioctl - get the current value of a object's property
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function retrieves the current value for an object's property. Compared
 * to the connector specific ioctl this one is extended to also work on crtc and
 * plane objects.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
				      struct drm_file *file_priv)
{
	struct drm_mode_obj_get_properties *arg = data;
	struct drm_mode_object *obj;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);

	obj = drm_mode_object_find(dev, arg->obj_id, arg->obj_type);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	if (!obj->properties) {
		ret = -EINVAL;
		goto out;
	}

	ret = get_properties(obj, file_priv->atomic,
			(uint32_t __user *)(unsigned long)(arg->props_ptr),
			(uint64_t __user *)(unsigned long)(arg->prop_values_ptr),
			&arg->count_props);

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_obj_set_property_ioctl - set the current value of an object's property
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This function sets the current value for an object's property. It also calls
 * into a driver's ->set_property callback to update the hardware state.
 * Compared to the connector specific ioctl this one is extended to also work on
 * crtc and plane objects.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
				    struct drm_file *file_priv)
{
	struct drm_mode_obj_set_property *arg = data;
	struct drm_mode_object *arg_obj;
	struct drm_mode_object *prop_obj;
	struct drm_property *property;
	int i, ret = -EINVAL;
	struct drm_mode_object *ref;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);

	arg_obj = drm_mode_object_find(dev, arg->obj_id, arg->obj_type);
	if (!arg_obj) {
		ret = -ENOENT;
		goto out;
	}
	if (!arg_obj->properties)
		goto out;

	for (i = 0; i < arg_obj->properties->count; i++)
		if (arg_obj->properties->properties[i]->base.id == arg->prop_id)
			break;

	if (i == arg_obj->properties->count)
		goto out;

	prop_obj = drm_mode_object_find(dev, arg->prop_id,
					DRM_MODE_OBJECT_PROPERTY);
	if (!prop_obj) {
		ret = -ENOENT;
		goto out;
	}
	property = obj_to_property(prop_obj);

	if (!drm_property_change_valid_get(property, arg->value, &ref))
		goto out;

	switch (arg_obj->type) {
	case DRM_MODE_OBJECT_CONNECTOR:
		ret = drm_mode_connector_set_obj_prop(arg_obj, property,
						      arg->value);
		break;
	case DRM_MODE_OBJECT_CRTC:
		ret = drm_mode_crtc_set_obj_prop(arg_obj, property, arg->value);
		break;
	case DRM_MODE_OBJECT_PLANE:
		ret = drm_mode_plane_set_obj_prop(obj_to_plane(arg_obj),
						  property, arg->value);
		break;
	}

	drm_property_change_valid_put(property, ref);

out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_connector_attach_encoder - attach a connector to an encoder
 * @@connector: connector to attach
 * @@encoder: encoder to attach @@connector to
 *
 * This function links up a connector to an encoder. Note that the routing
 * restrictions between encoders and crtcs are exposed to userspace through the
 * possible_clones and possible_crtcs bitmasks.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_connector_attach_encoder(struct drm_connector *connector,
				      struct drm_encoder *encoder)
{
	int i;

	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] == 0) {
			connector->encoder_ids[i] = encoder->base.id;
			return 0;
		}
	}
	return -ENOMEM;
}
EXPORT_SYMBOL(drm_mode_connector_attach_encoder);

/**
 * drm_mode_crtc_set_gamma_size - set the gamma table size
 * @@crtc: CRTC to set the gamma table size for
 * @@gamma_size: size of the gamma table
 *
 * Drivers which support gamma tables should set this to the supported gamma
 * table size when initializing the CRTC. Currently the drm core only supports a
 * fixed gamma table size.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
				 int gamma_size)
{
	crtc->gamma_size = gamma_size;

	crtc->gamma_store = kcalloc(gamma_size, sizeof(uint16_t) * 3,
				    GFP_KERNEL);
	if (!crtc->gamma_store) {
		crtc->gamma_size = 0;
		return -ENOMEM;
	}

	return 0;
}
EXPORT_SYMBOL(drm_mode_crtc_set_gamma_size);

/**
 * drm_mode_gamma_set_ioctl - set the gamma table
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Set the gamma table of a CRTC to the one passed in by the user. Userspace can
 * inquire the required gamma table size through drm_mode_gamma_get_ioctl.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_gamma_set_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_lut *crtc_lut = data;
	struct drm_crtc *crtc;
	void *r_base, *g_base, *b_base;
	int size;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	crtc = drm_crtc_find(dev, crtc_lut->crtc_id);
	if (!crtc) {
		ret = -ENOENT;
		goto out;
	}

	if (crtc->funcs->gamma_set == NULL) {
		ret = -ENOSYS;
		goto out;
	}

	/* memcpy into gamma store */
	if (crtc_lut->gamma_size != crtc->gamma_size) {
		ret = -EINVAL;
		goto out;
	}

	size = crtc_lut->gamma_size * (sizeof(uint16_t));
	r_base = crtc->gamma_store;
	if (copy_from_user(r_base, (void __user *)(unsigned long)crtc_lut->red, size)) {
		ret = -EFAULT;
		goto out;
	}

	g_base = r_base + size;
	if (copy_from_user(g_base, (void __user *)(unsigned long)crtc_lut->green, size)) {
		ret = -EFAULT;
		goto out;
	}

	b_base = g_base + size;
	if (copy_from_user(b_base, (void __user *)(unsigned long)crtc_lut->blue, size)) {
		ret = -EFAULT;
		goto out;
	}

	crtc->funcs->gamma_set(crtc, r_base, g_base, b_base, 0, crtc->gamma_size);

out:
	drm_modeset_unlock_all(dev);
	return ret;

}

/**
 * drm_mode_gamma_get_ioctl - get the gamma table
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Copy the current gamma table into the storage provided. This also provides
 * the gamma table size the driver expects, which can be used to size the
 * allocated storage.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_gamma_get_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_lut *crtc_lut = data;
	struct drm_crtc *crtc;
	void *r_base, *g_base, *b_base;
	int size;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	drm_modeset_lock_all(dev);
	crtc = drm_crtc_find(dev, crtc_lut->crtc_id);
	if (!crtc) {
		ret = -ENOENT;
		goto out;
	}

	/* memcpy into gamma store */
	if (crtc_lut->gamma_size != crtc->gamma_size) {
		ret = -EINVAL;
		goto out;
	}

	size = crtc_lut->gamma_size * (sizeof(uint16_t));
	r_base = crtc->gamma_store;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->red, r_base, size)) {
		ret = -EFAULT;
		goto out;
	}

	g_base = r_base + size;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->green, g_base, size)) {
		ret = -EFAULT;
		goto out;
	}

	b_base = g_base + size;
	if (copy_to_user((void __user *)(unsigned long)crtc_lut->blue, b_base, size)) {
		ret = -EFAULT;
		goto out;
	}
out:
	drm_modeset_unlock_all(dev);
	return ret;
}

/**
 * drm_mode_page_flip_ioctl - schedule an asynchronous fb update
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This schedules an asynchronous update on a given CRTC, called page flip.
 * Optionally a drm event is generated to signal the completion of the event.
 * Generic drivers cannot assume that a pageflip with changed framebuffer
 * properties (including driver specific metadata like tiling layout) will work,
 * but some drivers support e.g. pixel format changes through the pageflip
 * ioctl.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_page_flip_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_crtc_page_flip *page_flip = data;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb = NULL;
	struct drm_pending_vblank_event *e = NULL;
	unsigned long flags;
	int ret = -EINVAL;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if (page_flip->flags & ~DRM_MODE_PAGE_FLIP_FLAGS ||
	    page_flip->reserved != 0)
		return -EINVAL;

	if ((page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC) && !dev->mode_config.async_page_flip)
		return -EINVAL;

	crtc = drm_crtc_find(dev, page_flip->crtc_id);
	if (!crtc)
		return -ENOENT;

	drm_modeset_lock_crtc(crtc, crtc->primary);
	if (crtc->primary->fb == NULL) {
		/* The framebuffer is currently unbound, presumably
		 * due to a hotplug event, that userspace has not
		 * yet discovered.
		 */
		ret = -EBUSY;
		goto out;
	}

	if (crtc->funcs->page_flip == NULL)
		goto out;

	fb = drm_framebuffer_lookup(dev, page_flip->fb_id);
	if (!fb) {
		ret = -ENOENT;
		goto out;
	}

	if (crtc->state) {
		const struct drm_plane_state *state = crtc->primary->state;

		ret = check_src_coords(state->src_x, state->src_y,
				       state->src_w, state->src_h, fb);
	} else {
		ret = drm_crtc_check_viewport(crtc, crtc->x, crtc->y, &crtc->mode, fb);
	}
	if (ret)
		goto out;

	if (crtc->primary->fb->pixel_format != fb->pixel_format) {
		DRM_DEBUG_KMS("Page flip is not allowed to change frame buffer format.\n");
		ret = -EINVAL;
		goto out;
	}

	if (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {
		ret = -ENOMEM;
		spin_lock_irqsave(&dev->event_lock, flags);
		if (file_priv->event_space < sizeof(e->event)) {
			spin_unlock_irqrestore(&dev->event_lock, flags);
			goto out;
		}
		file_priv->event_space -= sizeof(e->event);
		spin_unlock_irqrestore(&dev->event_lock, flags);

		e = kzalloc(sizeof(*e), GFP_KERNEL);
		if (e == NULL) {
			spin_lock_irqsave(&dev->event_lock, flags);
			file_priv->event_space += sizeof(e->event);
			spin_unlock_irqrestore(&dev->event_lock, flags);
			goto out;
		}

		e->event.base.type = DRM_EVENT_FLIP_COMPLETE;
		e->event.base.length = sizeof(e->event);
		e->event.user_data = page_flip->user_data;
		e->base.event = &e->event.base;
		e->base.file_priv = file_priv;
		e->base.destroy =
			(void (*) (struct drm_pending_event *)) kfree;
	}

	crtc->primary->old_fb = crtc->primary->fb;
	ret = crtc->funcs->page_flip(crtc, fb, e, page_flip->flags);
	if (ret) {
		if (page_flip->flags & DRM_MODE_PAGE_FLIP_EVENT) {
			spin_lock_irqsave(&dev->event_lock, flags);
			file_priv->event_space += sizeof(e->event);
			spin_unlock_irqrestore(&dev->event_lock, flags);
			kfree(e);
		}
		/* Keep the old fb, don't unref it. */
		crtc->primary->old_fb = NULL;
	} else {
		crtc->primary->fb = fb;
		/* Unref only the old framebuffer. */
		fb = NULL;
	}

out:
	if (fb)
		drm_framebuffer_unreference(fb);
	if (crtc->primary->old_fb)
		drm_framebuffer_unreference(crtc->primary->old_fb);
	crtc->primary->old_fb = NULL;
	drm_modeset_unlock_crtc(crtc);

	return ret;
}

/**
 * drm_mode_config_reset - call ->reset callbacks
 * @@dev: drm device
 *
 * This functions calls all the crtc's, encoder's and connector's ->reset
 * callback. Drivers can use this in e.g. their driver load or resume code to
 * reset hardware and software state.
 */
void drm_mode_config_reset(struct drm_device *dev)
{
	struct drm_crtc *crtc;
	struct drm_plane *plane;
	struct drm_encoder *encoder;
	struct drm_connector *connector;

	drm_for_each_plane(plane, dev)
		if (plane->funcs->reset)
			plane->funcs->reset(plane);

	drm_for_each_crtc(crtc, dev)
		if (crtc->funcs->reset)
			crtc->funcs->reset(crtc);

	drm_for_each_encoder(encoder, dev)
		if (encoder->funcs->reset)
			encoder->funcs->reset(encoder);

	mutex_lock(&dev->mode_config.mutex);
	drm_for_each_connector(connector, dev)
		if (connector->funcs->reset)
			connector->funcs->reset(connector);
	mutex_unlock(&dev->mode_config.mutex);
}
EXPORT_SYMBOL(drm_mode_config_reset);

/**
 * drm_mode_create_dumb_ioctl - create a dumb backing storage buffer
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This creates a new dumb buffer in the driver's backing storage manager (GEM,
 * TTM or something else entirely) and returns the resulting buffer handle. This
 * handle can then be wrapped up into a framebuffer modeset object.
 *
 * Note that userspace is not allowed to use such objects for render
 * acceleration - drivers must create their own private ioctls for such a use
 * case.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_create_dumb_ioctl(struct drm_device *dev,
			       void *data, struct drm_file *file_priv)
{
	struct drm_mode_create_dumb *args = data;
	u32 cpp, stride, size;

	if (!dev->driver->dumb_create)
		return -ENOSYS;
	if (!args->width || !args->height || !args->bpp)
		return -EINVAL;

	/* overflow checks for 32bit size calculations */
	/* NOTE: DIV_ROUND_UP() can overflow */
	cpp = DIV_ROUND_UP(args->bpp, 8);
	if (!cpp || cpp > 0xffffffffU / args->width)
		return -EINVAL;
	stride = cpp * args->width;
	if (args->height > 0xffffffffU / stride)
		return -EINVAL;

	/* test for wrap-around */
	size = args->height * stride;
	if (PAGE_ALIGN(size) == 0)
		return -EINVAL;

	/*
	 * handle, pitch and size are output parameters. Zero them out to
	 * prevent drivers from accidentally using uninitialized data. Since
	 * not all existing userspace is clearing these fields properly we
	 * cannot reject IOCTL with garbage in them.
	 */
	args->handle = 0;
	args->pitch = 0;
	args->size = 0;

	return dev->driver->dumb_create(file_priv, dev, args);
}

/**
 * drm_mode_mmap_dumb_ioctl - create an mmap offset for a dumb backing storage buffer
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * Allocate an offset in the drm device node's address space to be able to
 * memory map a dumb buffer.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
			     void *data, struct drm_file *file_priv)
{
	struct drm_mode_map_dumb *args = data;

	/* call driver ioctl to get mmap offset */
	if (!dev->driver->dumb_map_offset)
		return -ENOSYS;

	return dev->driver->dumb_map_offset(file_priv, dev, args->handle, &args->offset);
}

/**
 * drm_mode_destroy_dumb_ioctl - destroy a dumb backing strage buffer
 * @@dev: DRM device
 * @@data: ioctl data
 * @@file_priv: DRM file info
 *
 * This destroys the userspace handle for the given dumb backing storage buffer.
 * Since buffer objects must be reference counted in the kernel a buffer object
 * won't be immediately freed if a framebuffer modeset object still uses it.
 *
 * Called by the user via ioctl.
 *
 * Returns:
 * Zero on success, negative errno on failure.
 */
int drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
				void *data, struct drm_file *file_priv)
{
	struct drm_mode_destroy_dumb *args = data;

	if (!dev->driver->dumb_destroy)
		return -ENOSYS;

	return dev->driver->dumb_destroy(file_priv, dev, args->handle);
}

/**
 * drm_fb_get_bpp_depth - get the bpp/depth values for format
 * @@format: pixel format (DRM_FORMAT_*)
 * @@depth: storage for the depth value
 * @@bpp: storage for the bpp value
 *
 * This only supports RGB formats here for compat with code that doesn't use
 * pixel formats directly yet.
 */
void drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
			  int *bpp)
{
	switch (format) {
	case DRM_FORMAT_C8:
	case DRM_FORMAT_RGB332:
	case DRM_FORMAT_BGR233:
		*depth = 8;
		*bpp = 8;
		break;
	case DRM_FORMAT_XRGB1555:
	case DRM_FORMAT_XBGR1555:
	case DRM_FORMAT_RGBX5551:
	case DRM_FORMAT_BGRX5551:
	case DRM_FORMAT_ARGB1555:
	case DRM_FORMAT_ABGR1555:
	case DRM_FORMAT_RGBA5551:
	case DRM_FORMAT_BGRA5551:
		*depth = 15;
		*bpp = 16;
		break;
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_BGR565:
		*depth = 16;
		*bpp = 16;
		break;
	case DRM_FORMAT_RGB888:
	case DRM_FORMAT_BGR888:
		*depth = 24;
		*bpp = 24;
		break;
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_RGBX8888:
	case DRM_FORMAT_BGRX8888:
		*depth = 24;
		*bpp = 32;
		break;
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_RGBX1010102:
	case DRM_FORMAT_BGRX1010102:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_ABGR2101010:
	case DRM_FORMAT_RGBA1010102:
	case DRM_FORMAT_BGRA1010102:
		*depth = 30;
		*bpp = 32;
		break;
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_RGBA8888:
	case DRM_FORMAT_BGRA8888:
		*depth = 32;
		*bpp = 32;
		break;
	default:
		DRM_DEBUG_KMS("unsupported pixel format %s\n",
			      drm_get_format_name(format));
		*depth = 0;
		*bpp = 0;
		break;
	}
}
EXPORT_SYMBOL(drm_fb_get_bpp_depth);

/**
 * drm_format_num_planes - get the number of planes for format
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * Returns:
 * The number of planes used by the specified pixel format.
 */
int drm_format_num_planes(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 3;
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_num_planes);

/**
 * drm_format_plane_cpp - determine the bytes per pixel value
 * @@format: pixel format (DRM_FORMAT_*)
 * @@plane: plane index
 *
 * Returns:
 * The bytes per pixel value for the specified plane.
 */
int drm_format_plane_cpp(uint32_t format, int plane)
{
	unsigned int depth;
	int bpp;

	if (plane >= drm_format_num_planes(format))
		return 0;

	switch (format) {
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
		return 2;
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_NV24:
	case DRM_FORMAT_NV42:
		return plane ? 2 : 1;
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV444:
	case DRM_FORMAT_YVU444:
		return 1;
	default:
		drm_fb_get_bpp_depth(format, &depth, &bpp);
		return bpp >> 3;
	}
}
EXPORT_SYMBOL(drm_format_plane_cpp);

/**
 * drm_format_horz_chroma_subsampling - get the horizontal chroma subsampling factor
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * Returns:
 * The horizontal chroma subsampling factor for the
 * specified pixel format.
 */
int drm_format_horz_chroma_subsampling(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV411:
	case DRM_FORMAT_YVU411:
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
		return 4;
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
	case DRM_FORMAT_NV16:
	case DRM_FORMAT_NV61:
	case DRM_FORMAT_YUV422:
	case DRM_FORMAT_YVU422:
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_horz_chroma_subsampling);

/**
 * drm_format_vert_chroma_subsampling - get the vertical chroma subsampling factor
 * @@format: pixel format (DRM_FORMAT_*)
 *
 * Returns:
 * The vertical chroma subsampling factor for the
 * specified pixel format.
 */
int drm_format_vert_chroma_subsampling(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUV410:
	case DRM_FORMAT_YVU410:
		return 4;
	case DRM_FORMAT_YUV420:
	case DRM_FORMAT_YVU420:
	case DRM_FORMAT_NV12:
	case DRM_FORMAT_NV21:
		return 2;
	default:
		return 1;
	}
}
EXPORT_SYMBOL(drm_format_vert_chroma_subsampling);

/**
 * drm_rotation_simplify() - Try to simplify the rotation
 * @@rotation: Rotation to be simplified
 * @@supported_rotations: Supported rotations
 *
 * Attempt to simplify the rotation to a form that is supported.
 * Eg. if the hardware supports everything except DRM_REFLECT_X
 * one could call this function like this:
 *
 * drm_rotation_simplify(rotation, BIT(DRM_ROTATE_0) |
 *                       BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_180) |
 *                       BIT(DRM_ROTATE_270) | BIT(DRM_REFLECT_Y));
 *
 * to eliminate the DRM_ROTATE_X flag. Depending on what kind of
 * transforms the hardware supports, this function may not
 * be able to produce a supported transform, so the caller should
 * check the result afterwards.
 */
unsigned int drm_rotation_simplify(unsigned int rotation,
				   unsigned int supported_rotations)
{
	if (rotation & ~supported_rotations) {
		rotation ^= BIT(DRM_REFLECT_X) | BIT(DRM_REFLECT_Y);
		rotation = (rotation & DRM_REFLECT_MASK) |
		           BIT((ffs(rotation & DRM_ROTATE_MASK) + 1) % 4);
	}

	return rotation;
}
EXPORT_SYMBOL(drm_rotation_simplify);

/**
 * drm_mode_config_init - initialize DRM mode_configuration structure
 * @@dev: DRM device
 *
 * Initialize @@dev's mode_config structure, used for tracking the graphics
 * configuration of @@dev.
 *
 * Since this initializes the modeset locks, no locking is possible. Which is no
 * problem, since this should happen single threaded at init time. It is the
 * driver's problem to ensure this guarantee.
 *
 */
void drm_mode_config_init(struct drm_device *dev)
{
	rw_init(&dev->mode_config.mutex, "mcrwl");
	drm_modeset_lock_init(&dev->mode_config.connection_mutex);
	rw_init(&dev->mode_config.idr_mutex, "idrlk");
	rw_init(&dev->mode_config.fb_lock, "fblk");
	rw_init(&dev->mode_config.blob_lock, "mcblk");
	INIT_LIST_HEAD(&dev->mode_config.fb_list);
	INIT_LIST_HEAD(&dev->mode_config.crtc_list);
	INIT_LIST_HEAD(&dev->mode_config.connector_list);
	INIT_LIST_HEAD(&dev->mode_config.encoder_list);
	INIT_LIST_HEAD(&dev->mode_config.property_list);
	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
	INIT_LIST_HEAD(&dev->mode_config.plane_list);
	idr_init(&dev->mode_config.crtc_idr);
	idr_init(&dev->mode_config.tile_idr);

	drm_modeset_lock_all(dev);
	drm_mode_create_standard_properties(dev);
	drm_modeset_unlock_all(dev);

	/* Just to be sure */
	dev->mode_config.num_fb = 0;
	dev->mode_config.num_connector = 0;
	dev->mode_config.num_crtc = 0;
	dev->mode_config.num_encoder = 0;
	dev->mode_config.num_overlay_plane = 0;
	dev->mode_config.num_total_plane = 0;
}
EXPORT_SYMBOL(drm_mode_config_init);

/**
 * drm_mode_config_cleanup - free up DRM mode_config info
 * @@dev: DRM device
 *
 * Free up all the connectors and CRTCs associated with this DRM device, then
 * free up the framebuffers and associated buffer objects.
 *
 * Note that since this /should/ happen single-threaded at driver/device
 * teardown time, no locking is required. It's the driver's job to ensure that
 * this guarantee actually holds true.
 *
 * FIXME: cleanup any dangling user buffer objects too
 */
void drm_mode_config_cleanup(struct drm_device *dev)
{
	struct drm_connector *connector, *ot;
	struct drm_crtc *crtc, *ct;
	struct drm_encoder *encoder, *enct;
	struct drm_framebuffer *fb, *fbt;
	struct drm_property *property, *pt;
	struct drm_property_blob *blob, *bt;
	struct drm_plane *plane, *plt;

	list_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,
				 head) {
		encoder->funcs->destroy(encoder);
	}

	list_for_each_entry_safe(connector, ot,
				 &dev->mode_config.connector_list, head) {
		connector->funcs->destroy(connector);
	}

	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
				 head) {
		drm_property_destroy(dev, property);
	}

	list_for_each_entry_safe(blob, bt, &dev->mode_config.property_blob_list,
				 head_global) {
		drm_property_unreference_blob(blob);
	}

	/*
	 * Single-threaded teardown context, so it's not required to grab the
	 * fb_lock to protect against concurrent fb_list access. Contrary, it
	 * would actually deadlock with the drm_framebuffer_cleanup function.
	 *
	 * Also, if there are any framebuffers left, that's a driver leak now,
	 * so politely WARN about this.
	 */
	WARN_ON(!list_empty(&dev->mode_config.fb_list));
	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
		drm_framebuffer_free(&fb->refcount);
	}

	list_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,
				 head) {
		plane->funcs->destroy(plane);
	}

	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
		crtc->funcs->destroy(crtc);
	}

	idr_destroy(&dev->mode_config.tile_idr);
	idr_destroy(&dev->mode_config.crtc_idr);
	drm_modeset_lock_fini(&dev->mode_config.connection_mutex);
}
EXPORT_SYMBOL(drm_mode_config_cleanup);

struct drm_property *drm_mode_create_rotation_property(struct drm_device *dev,
						       unsigned int supported_rotations)
{
	static const struct drm_prop_enum_list props[] = {
		{ DRM_ROTATE_0,   "rotate-0" },
		{ DRM_ROTATE_90,  "rotate-90" },
		{ DRM_ROTATE_180, "rotate-180" },
		{ DRM_ROTATE_270, "rotate-270" },
		{ DRM_REFLECT_X,  "reflect-x" },
		{ DRM_REFLECT_Y,  "reflect-y" },
	};

	return drm_property_create_bitmask(dev, 0, "rotation",
					   props, ARRAY_SIZE(props),
					   supported_rotations);
}
EXPORT_SYMBOL(drm_mode_create_rotation_property);

/**
 * DOC: Tile group
 *
 * Tile groups are used to represent tiled monitors with a unique
 * integer identifier. Tiled monitors using DisplayID v1.3 have
 * a unique 8-byte handle, we store this in a tile group, so we
 * have a common identifier for all tiles in a monitor group.
 */
static void drm_tile_group_free(struct kref *kref)
{
	struct drm_tile_group *tg = container_of(kref, struct drm_tile_group, refcount);
	struct drm_device *dev = tg->dev;
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.tile_idr, tg->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
	kfree(tg);
}

/**
 * drm_mode_put_tile_group - drop a reference to a tile group.
 * @@dev: DRM device
 * @@tg: tile group to drop reference to.
 *
 * drop reference to tile group and free if 0.
 */
void drm_mode_put_tile_group(struct drm_device *dev,
			     struct drm_tile_group *tg)
{
	kref_put(&tg->refcount, drm_tile_group_free);
}

/**
 * drm_mode_get_tile_group - get a reference to an existing tile group
 * @@dev: DRM device
 * @@topology: 8-bytes unique per monitor.
 *
 * Use the unique bytes to get a reference to an existing tile group.
 *
 * RETURNS:
 * tile group or NULL if not found.
 */
struct drm_tile_group *drm_mode_get_tile_group(struct drm_device *dev,
					       char topology[8])
{
	struct drm_tile_group *tg;
	int id;
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_for_each_entry(&dev->mode_config.tile_idr, tg, id) {
		if (!memcmp(tg->group_data, topology, 8)) {
			if (!kref_get_unless_zero(&tg->refcount))
				tg = NULL;
			mutex_unlock(&dev->mode_config.idr_mutex);
			return tg;
		}
	}
	mutex_unlock(&dev->mode_config.idr_mutex);
	return NULL;
}
EXPORT_SYMBOL(drm_mode_get_tile_group);

/**
 * drm_mode_create_tile_group - create a tile group from a displayid description
 * @@dev: DRM device
 * @@topology: 8-bytes unique per monitor.
 *
 * Create a tile group for the unique monitor, and get a unique
 * identifier for the tile group.
 *
 * RETURNS:
 * new tile group or error.
 */
struct drm_tile_group *drm_mode_create_tile_group(struct drm_device *dev,
						  char topology[8])
{
	struct drm_tile_group *tg;
	int ret;

	tg = kzalloc(sizeof(*tg), GFP_KERNEL);
	if (!tg)
		return ERR_PTR(-ENOMEM);

	kref_init(&tg->refcount);
	memcpy(tg->group_data, topology, 8);
	tg->dev = dev;

	mutex_lock(&dev->mode_config.idr_mutex);
	ret = idr_alloc(&dev->mode_config.tile_idr, tg, 1, 0, GFP_KERNEL);
	if (ret >= 0) {
		tg->id = ret;
	} else {
		kfree(tg);
		tg = ERR_PTR(ret);
	}

	mutex_unlock(&dev->mode_config.idr_mutex);
	return tg;
}
EXPORT_SYMBOL(drm_mode_create_tile_group);
@


1.25
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d4052 17
d4860 6
@


1.24
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@a0 1
/*	$OpenBSD: drm_crtc.c,v 1.23 2016/04/08 08:27:53 kettenis Exp $	*/
d32 20
a51 56
#include "drmP.h"
#include "drm_crtc.h"
#include "drm_edid.h"
#include "drm_fourcc.h"

/**
 * drm_modeset_lock_all - take all modeset locks
 * @@dev: drm device
 *
 * This function takes all modeset locks, suitable where a more fine-grained
 * scheme isn't (yet) implemented.
 */
void drm_modeset_lock_all(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	mutex_lock(&dev->mode_config.mutex);

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		mutex_lock_nest_lock(&crtc->mutex, &dev->mode_config.mutex);
}
EXPORT_SYMBOL(drm_modeset_lock_all);

/**
 * drm_modeset_unlock_all - drop all modeset locks
 * @@dev: device
 */
void drm_modeset_unlock_all(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		mutex_unlock(&crtc->mutex);

	mutex_unlock(&dev->mode_config.mutex);
}
EXPORT_SYMBOL(drm_modeset_unlock_all);

/**
 * drm_warn_on_modeset_not_all_locked - check that all modeset locks are locked
 * @@dev: device
 */
void drm_warn_on_modeset_not_all_locked(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	/* Locking is currently fubar in the panic handler. */
	if (oops_in_progress)
		return;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		WARN_ON(!mutex_is_locked(&crtc->mutex));

	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
}
EXPORT_SYMBOL(drm_warn_on_modeset_not_all_locked);
d68 2
a69 2
static const struct drm_prop_enum_list drm_dpms_enum_list[] =
{	{ DRM_MODE_DPMS_ON, "On" },
d77 6
d86 1
a86 2
static const struct drm_prop_enum_list drm_scaling_mode_enum_list[] =
{
d93 6
d102 1
a102 2
static const struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =
{
d110 1
a110 2
static const struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =
{
d119 1
a119 2
static const struct drm_prop_enum_list drm_tv_select_enum_list[] =
{
d129 1
a129 2
static const struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =
{
a148 1
#ifdef notyet
a149 3
#else
	int count;
#endif
d155 2
a156 2
static struct drm_conn_prop_enum_list drm_connector_enum_list[] =
{	{ DRM_MODE_CONNECTOR_Unknown, "Unknown" },
d175 2
a176 2
static const struct drm_prop_enum_list drm_encoder_enum_list[] =
{	{ DRM_MODE_ENCODER_NONE, "None" },
d183 10
a196 2
	printf("%s stub\n", __func__);
#ifdef notyet
a200 1
#endif
a204 2
	printf("%s stub\n", __func__);
#ifdef notyet
a208 1
#endif
d211 7
a217 22
const char *drm_get_encoder_name(const struct drm_encoder *encoder)
{
	static char buf[32];

	snprintf(buf, 32, "%s-%d",
		 drm_encoder_enum_list[encoder->encoder_type].name,
		 encoder->base.id);
	return buf;
}
EXPORT_SYMBOL(drm_get_encoder_name);

const char *drm_get_connector_name(const struct drm_connector *connector)
{
	static char buf[32];

	snprintf(buf, 32, "%s-%d",
		 drm_connector_enum_list[connector->connector_type].name,
		 connector->connector_type_id);
	return buf;
}
EXPORT_SYMBOL(drm_get_connector_name);

d229 13
d247 9
d273 3
a275 12
/**
 * drm_mode_object_get - allocate a new modeset identifier
 * @@dev: DRM device
 * @@obj: object pointer, used to generate unique ID
 * @@obj_type: object type
 *
 * Create a unique identifier based on @@ptr in @@dev's identifier space.  Used
 * for tracking modes, CRTCs and connectors.
 *
 * RETURNS:
 * New unique (relative to other objects in @@dev) integer identifier for the
 * object.
d277 4
a280 2
static int drm_mode_object_get(struct drm_device *dev,
			       struct drm_mode_object *obj, uint32_t obj_type)
d285 1
a285 2
	/* XXX The xf86-video-intel driver truncates to 8 bits. */
	ret = idr_alloc(&dev->mode_config.crtc_idr, obj, 1, 256, GFP_KERNEL);
d300 28
d332 3
a334 1
 * Free @@id from @@dev's unique identifier pool.
d336 2
a337 2
static void drm_mode_object_put(struct drm_device *dev,
				struct drm_mode_object *object)
d344 21
d372 3
a374 1
 * are reference counted, they need special treatment.
d383 2
a384 8
	WARN_ON(type == DRM_MODE_OBJECT_FB);

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != type) || (obj->id != id))
		obj = NULL;
	mutex_unlock(&dev->mode_config.idr_mutex);

d404 1
a404 1
 * RETURNS:
a421 3
	/* Grab the idr reference. */
	drm_framebuffer_reference(fb);

d427 1
a427 1
	return 0;
d431 11
d446 13
d486 1
a486 1
 * again.
d495 4
a498 2
	if (fb)
		drm_framebuffer_reference(fb);
d513 1
a513 1
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
d521 2
d526 1
a526 1
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
a530 24
static void drm_framebuffer_free_bug(struct kref *kref)
{
	BUG();
}

static void __drm_framebuffer_unreference(struct drm_framebuffer *fb)
{
	DRM_DEBUG("FB ID: %d\n", fb->base.id);
	kref_put(&fb->refcount, drm_framebuffer_free_bug);
}

/* dev->mode_config.fb_lock must be held! */
static void __drm_framebuffer_unregister(struct drm_device *dev,
					 struct drm_framebuffer *fb)
{
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, fb->base.id);
	mutex_unlock(&dev->mode_config.idr_mutex);

	fb->base.id = 0;

	__drm_framebuffer_unreference(fb);
}

d542 6
a547 1
	struct drm_device *dev = fb->dev;
d560 3
a562 2
 * Cleanup references to a user-created framebuffer. This function is intended
 * to be used from the drivers ->destroy callback.
d598 1
a598 1
	struct drm_device *dev = fb->dev;
d604 5
d629 2
a630 2
		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
			if (crtc->fb == fb) {
d641 1
a641 1
		list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
d652 2
d655 2
a656 1
 * drm_crtc_init - Initialise a new CRTC object
d659 2
d665 1
a665 1
 * RETURNS:
d668 4
a671 2
int drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
		   const struct drm_crtc_funcs *funcs)
d673 1
d676 3
a680 5
	crtc->invert_dimensions = false;

	drm_modeset_lock_all(dev);
	rw_init_flags(&crtc->mutex, "crtcl", RWL_DUPOK);
	mutex_lock_nest_lock(&crtc->mutex, &dev->mode_config.mutex);
d682 1
d685 1
a685 1
		goto out;
d689 2
a690 2
	list_add_tail(&crtc->head, &dev->mode_config.crtc_list);
	dev->mode_config.num_crtc++;
d692 11
a702 2
 out:
	drm_modeset_unlock_all(dev);
d704 1
a704 1
	return ret;
d706 1
a706 1
EXPORT_SYMBOL(drm_crtc_init);
d723 2
d728 6
d749 1
a749 1
	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head) {
a759 14
/**
 * drm_mode_probed_add - add a mode to a connector's probed mode list
 * @@connector: connector the new mode
 * @@mode: mode data
 *
 * Add @@mode to @@connector's mode list for later use.
 */
void drm_mode_probed_add(struct drm_connector *connector,
			 struct drm_display_mode *mode)
{
	list_add_tail(&mode->head, &connector->probed_modes);
}
EXPORT_SYMBOL(drm_mode_probed_add);

d775 88
d872 1
a872 1
 * RETURNS:
d880 1
a881 1
#ifdef notyet
a883 1
#endif
d887 1
a887 1
	ret = drm_mode_object_get(dev, &connector->base, DRM_MODE_OBJECT_CONNECTOR);
d889 1
a889 1
		goto out;
a894 1
#ifdef notyet
a896 4
#else
	connector->connector_type_id =
		++drm_connector_enum_list[connector_type].count;
#endif
d899 9
a907 2
		drm_mode_object_put(dev, &connector->base);
		goto out;
d909 1
d915 6
a920 2
	list_add_tail(&connector->head, &dev->mode_config.connector_list);
	dev->mode_config.num_connector++;
d924 1
a924 1
					      dev->mode_config.edid_property,
d928 5
a932 1
				      dev->mode_config.dpms_property, 0);
d934 7
a940 1
 out:
d958 5
a968 1
#ifdef notyet
a970 1
#endif
d972 1
d974 2
d978 7
d988 8
a995 1
void drm_connector_unplug_all(struct drm_device *dev)
d997 5
a1001 1
	struct drm_connector *connector;
d1003 8
a1010 3
	/* taking the mode config mutex ends up in a clash with sysfs */
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
		drm_sysfs_connector_remove(connector);
d1012 1
a1012 1
EXPORT_SYMBOL(drm_connector_unplug_all);
d1014 10
a1023 2
int drm_bridge_init(struct drm_device *dev, struct drm_bridge *bridge,
		const struct drm_bridge_funcs *funcs)
d1027 1
a1027 1
	drm_modeset_lock_all(dev);
d1029 1
a1029 1
	ret = drm_mode_object_get(dev, &bridge->base, DRM_MODE_OBJECT_BRIDGE);
d1031 1
a1031 1
		goto out;
d1033 5
a1037 2
	bridge->dev = dev;
	bridge->funcs = funcs;
d1039 3
a1041 2
	list_add_tail(&bridge->head, &dev->mode_config.bridge_list);
	dev->mode_config.num_bridge++;
d1043 10
a1052 3
 out:
	drm_modeset_unlock_all(dev);
	return ret;
d1054 2
a1055 1
EXPORT_SYMBOL(drm_bridge_init);
d1057 9
a1065 1
void drm_bridge_cleanup(struct drm_bridge *bridge)
d1067 5
a1071 1
	struct drm_device *dev = bridge->dev;
a1072 5
	drm_modeset_lock_all(dev);
	drm_mode_object_put(dev, &bridge->base);
	list_del(&bridge->head);
	dev->mode_config.num_bridge--;
	drm_modeset_unlock_all(dev);
d1074 1
a1074 1
EXPORT_SYMBOL(drm_bridge_cleanup);
d1076 13
d1100 1
a1100 1
		goto out;
d1105 7
d1116 5
a1120 1
 out:
d1127 6
d1136 1
d1139 1
d1143 2
d1149 1
a1149 1
 * drm_plane_init - Initialise a new plane object
d1156 1
a1156 1
 * @@priv: plane is private (hidden from userspace)?
d1158 1
a1158 1
 * Inits a new object created as base part of a driver plane object.
d1160 1
a1160 1
 * RETURNS:
d1163 5
a1167 5
int drm_plane_init(struct drm_device *dev, struct drm_plane *plane,
		   unsigned long possible_crtcs,
		   const struct drm_plane_funcs *funcs,
		   const uint32_t *formats, uint32_t format_count,
		   bool priv)
d1169 1
a1171 2
	drm_modeset_lock_all(dev);

d1174 3
a1176 1
		goto out;
d1181 2
a1182 2
	plane->format_types = kmalloc(sizeof(uint32_t) * format_count,
				      GFP_KERNEL);
d1186 1
a1186 2
		ret = -ENOMEM;
		goto out;
d1192 1
d1194 20
a1213 9
	/* private planes are not exposed to userspace, but depending on
	 * display hardware, might be convenient to allow sharing programming
	 * for the scanout engine with the crtc implementation.
	 */
	if (!priv) {
		list_add_tail(&plane->head, &dev->mode_config.plane_list);
		dev->mode_config.num_plane++;
	} else {
		INIT_LIST_HEAD(&plane->head);
d1216 28
a1243 2
 out:
	drm_modeset_unlock_all(dev);
d1245 3
a1247 1
	return ret;
d1266 7
a1272 5
	/* if not added to a list, it must be a private plane */
	if (!list_empty(&plane->head)) {
		list_del(&plane->head);
		dev->mode_config.num_plane--;
	}
d1274 6
d1284 2
a1285 2
 * drm_plane_force_disable - Forcibly disable a plane
 * @@plane: plane to disable
d1287 2
a1288 4
 * Forces the plane to be disabled.
 *
 * Used when the plane's current framebuffer is destroyed,
 * and when restoring fbdev mode.
d1290 1
a1290 1
void drm_plane_force_disable(struct drm_plane *plane)
d1292 6
a1297 1
	int ret;
d1299 2
a1300 2
	if (!plane->fb)
		return;
d1302 1
a1302 7
	ret = plane->funcs->disable_plane(plane);
	if (ret)
		DRM_ERROR("failed to disable plane with busy fb\n");
	/* disconnect the plane from the fb and crtc: */
	__drm_framebuffer_unreference(plane->fb);
	plane->fb = NULL;
	plane->crtc = NULL;
d1304 1
a1304 1
EXPORT_SYMBOL(drm_plane_force_disable);
d1307 1
a1307 1
 * drm_mode_create - create a new display mode
d1309 1
d1311 2
a1312 4
 * Create a new drm_display_mode, give it an ID, and return it.
 *
 * RETURNS:
 * Pointer to new mode on success, NULL on error.
d1314 2
a1315 1
struct drm_display_mode *drm_mode_create(struct drm_device *dev)
d1317 2
a1318 1
	struct drm_display_mode *nmode;
d1320 4
a1323 7
	nmode = kzalloc(sizeof(struct drm_display_mode), GFP_KERNEL);
	if (!nmode)
		return NULL;

	if (drm_mode_object_get(dev, &nmode->base, DRM_MODE_OBJECT_MODE)) {
		kfree(nmode);
		return NULL;
d1325 1
a1325 2

	return nmode;
d1327 1
a1327 1
EXPORT_SYMBOL(drm_mode_create);
d1330 4
a1333 3
 * drm_mode_destroy - remove a mode
 * @@dev: DRM device
 * @@mode: mode to remove
d1335 2
a1336 1
 * Free @@mode's unique identifier, then free it.
d1338 1
a1338 1
void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
d1340 3
a1342 1
	if (!mode)
d1345 12
a1356 3
	drm_mode_object_put(dev, &mode->base);

	kfree(mode);
d1358 1
a1358 1
EXPORT_SYMBOL(drm_mode_destroy);
d1360 1
a1360 1
static int drm_mode_create_standard_connector_properties(struct drm_device *dev)
d1362 1
a1362 2
	struct drm_property *edid;
	struct drm_property *dpms;
d1367 1
a1367 1
	edid = drm_property_create(dev, DRM_MODE_PROP_BLOB |
d1370 3
a1372 1
	dev->mode_config.edid_property = edid;
d1374 1
a1374 1
	dpms = drm_property_create_enum(dev, 0,
d1377 99
a1475 1
	dev->mode_config.dpms_property = dpms;
d1522 3
a1524 2
int drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,
				  char *modes[])
d1528 1
a1528 1
	int i;
d1540 3
d1550 2
d1559 2
d1564 2
d1569 2
d1574 2
d1580 3
d1589 2
d1594 2
d1599 2
d1604 2
d1609 2
d1614 2
d1618 2
d1649 27
a1699 52
static int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
{
	uint32_t total_objects = 0;

	total_objects += dev->mode_config.num_crtc;
	total_objects += dev->mode_config.num_connector;
	total_objects += dev->mode_config.num_encoder;
	total_objects += dev->mode_config.num_bridge;

	group->id_list = kzalloc(total_objects * sizeof(uint32_t), GFP_KERNEL);
	if (!group->id_list)
		return -ENOMEM;

	group->num_crtcs = 0;
	group->num_connectors = 0;
	group->num_encoders = 0;
	group->num_bridges = 0;
	return 0;
}

int drm_mode_group_init_legacy_group(struct drm_device *dev,
				     struct drm_mode_group *group)
{
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	struct drm_connector *connector;
	struct drm_bridge *bridge;
	int ret;

	if ((ret = drm_mode_group_init(dev, group)))
		return ret;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
		group->id_list[group->num_crtcs++] = crtc->base.id;

	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
		group->id_list[group->num_crtcs + group->num_encoders++] =
		encoder->base.id;

	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
		group->id_list[group->num_crtcs + group->num_encoders +
			       group->num_connectors++] = connector->base.id;

	list_for_each_entry(bridge, &dev->mode_config.bridge_list, head)
		group->id_list[group->num_crtcs + group->num_encoders +
			       group->num_connectors + group->num_bridges++] =
					bridge->base.id;

	return 0;
}
EXPORT_SYMBOL(drm_mode_group_init_legacy_group);

d1701 2
a1702 42
 * drm_crtc_convert_to_umode - convert a drm_display_mode into a modeinfo
 * @@out: drm_mode_modeinfo struct to return to the user
 * @@in: drm_display_mode to use
 *
 * Convert a drm_display_mode into a drm_mode_modeinfo structure to return to
 * the user.
 */
static void drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,
				      const struct drm_display_mode *in)
{
	WARN(in->hdisplay > USHRT_MAX || in->hsync_start > USHRT_MAX ||
	     in->hsync_end > USHRT_MAX || in->htotal > USHRT_MAX ||
	     in->hskew > USHRT_MAX || in->vdisplay > USHRT_MAX ||
	     in->vsync_start > USHRT_MAX || in->vsync_end > USHRT_MAX ||
	     in->vtotal > USHRT_MAX || in->vscan > USHRT_MAX,
	     "timing values too large for mode info\n");

	out->clock = in->clock;
	out->hdisplay = in->hdisplay;
	out->hsync_start = in->hsync_start;
	out->hsync_end = in->hsync_end;
	out->htotal = in->htotal;
	out->hskew = in->hskew;
	out->vdisplay = in->vdisplay;
	out->vsync_start = in->vsync_start;
	out->vsync_end = in->vsync_end;
	out->vtotal = in->vtotal;
	out->vscan = in->vscan;
	out->vrefresh = in->vrefresh;
	out->flags = in->flags;
	out->type = in->type;
	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;
}

/**
 * drm_crtc_convert_umode - convert a modeinfo into a drm_display_mode
 * @@out: drm_display_mode to return to the user
 * @@in: drm_mode_modeinfo to use
 *
 * Convert a drm_mode_modeinfo into a drm_display_mode structure to return to
 * the caller.
d1704 1
a1704 2
 * RETURNS:
 * Zero on success, errno on failure.
d1706 1
a1706 2
static int drm_crtc_convert_umode(struct drm_display_mode *out,
				  const struct drm_mode_modeinfo *in)
d1708 2
a1709 2
	if (in->clock > INT_MAX || in->vrefresh > INT_MAX)
		return -ERANGE;
d1711 2
a1712 2
	if ((in->flags & DRM_MODE_FLAG_3D_MASK) > DRM_MODE_FLAG_3D_MAX)
		return -EINVAL;
d1714 2
a1715 16
	out->clock = in->clock;
	out->hdisplay = in->hdisplay;
	out->hsync_start = in->hsync_start;
	out->hsync_end = in->hsync_end;
	out->htotal = in->htotal;
	out->hskew = in->hskew;
	out->vdisplay = in->vdisplay;
	out->vsync_start = in->vsync_start;
	out->vsync_end = in->vsync_end;
	out->vtotal = in->vtotal;
	out->vscan = in->vscan;
	out->vrefresh = in->vrefresh;
	out->flags = in->flags;
	out->type = in->type;
	strncpy(out->name, in->name, DRM_DISPLAY_MODE_LEN);
	out->name[DRM_DISPLAY_MODE_LEN-1] = 0;
d1717 3
d1722 1
d1735 2
a1736 2
 * RETURNS:
 * Zero on success, errno on failure.
a1751 3
#ifdef notyet
	int copied = 0, i;
#else
a1752 1
#endif
a1756 3
#ifdef notyet
	struct drm_mode_group *mode_group;
#endif
d1786 5
a1790 8
	drm_modeset_lock_all(dev);
#ifdef notyet
	mode_group = &file_priv->master->minor->mode_group;
	if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif

		list_for_each(lh, &dev->mode_config.crtc_list)
			crtc_count++;
d1792 2
a1793 2
		list_for_each(lh, &dev->mode_config.connector_list)
			connector_count++;
d1795 2
a1796 10
		list_for_each(lh, &dev->mode_config.encoder_list)
			encoder_count++;
#ifdef notyet
	} else {

		crtc_count = mode_group->num_crtcs;
		connector_count = mode_group->num_connectors;
		encoder_count = mode_group->num_encoders;
	}
#endif
d1807 7
a1813 22
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(crtc, &dev->mode_config.crtc_list,
					    head) {
				DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);
				if (put_user(crtc->base.id, crtc_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
#ifdef notyet
		} else {
			for (i = 0; i < mode_group->num_crtcs; i++) {
				if (put_user(mode_group->id_list[i],
					     crtc_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
a1814 1
#endif
d1822 7
a1828 14
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(encoder,
					    &dev->mode_config.encoder_list,
					    head) {
				DRM_DEBUG_KMS("[ENCODER:%d:%s]\n", encoder->base.id,
						drm_get_encoder_name(encoder));
				if (put_user(encoder->base.id, encoder_id +
					     copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
d1830 1
a1830 11
#ifdef notyet
		} else {
			for (i = mode_group->num_crtcs; i < mode_group->num_crtcs + mode_group->num_encoders; i++) {
				if (put_user(mode_group->id_list[i],
					     encoder_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}

a1831 1
#endif
d1839 8
a1846 27
#ifdef notyet
		if (file_priv->master->minor->type == DRM_MINOR_CONTROL) {
#endif
			list_for_each_entry(connector,
					    &dev->mode_config.connector_list,
					    head) {
				DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
					connector->base.id,
					drm_get_connector_name(connector));
				if (put_user(connector->base.id,
					     connector_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
			}
#ifdef notyet
		} else {
			int start = mode_group->num_crtcs +
				mode_group->num_encoders;
			for (i = start; i < start + mode_group->num_connectors; i++) {
				if (put_user(mode_group->id_list[i],
					     connector_id + copied)) {
					ret = -EFAULT;
					goto out;
				}
				copied++;
d1848 1
a1849 1
#endif
d1857 1
a1857 1
	drm_modeset_unlock_all(dev);
d1871 2
a1872 2
 * RETURNS:
 * Zero on success, errno on failure.
a1878 2
	struct drm_mode_object *obj;
	int ret = 0;
d1883 3
a1885 9
	drm_modeset_lock_all(dev);

	obj = drm_mode_object_find(dev, crtc_resp->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);
d1887 1
a1887 2
	crtc_resp->x = crtc->x;
	crtc_resp->y = crtc->y;
d1889 2
a1890 2
	if (crtc->fb)
		crtc_resp->fb_id = crtc->fb->base.id;
d1894 6
a1899 1
	if (crtc->enabled) {
d1901 9
a1909 2
		drm_crtc_convert_to_umode(&crtc_resp->mode, &crtc->mode);
		crtc_resp->mode_valid = 1;
d1911 3
a1913 2
	} else {
		crtc_resp->mode_valid = 0;
d1915 1
d1917 1
a1917 3
out:
	drm_modeset_unlock_all(dev);
	return ret;
d1933 47
d1990 2
a1991 2
 * RETURNS:
 * Zero on success, errno on failure.
a1996 1
	struct drm_mode_object *obj;
d1998 1
a2000 1
	int props_count = 0;
a2006 2
	uint32_t __user *prop_ptr;
	uint64_t __user *prop_values;
d2018 2
a2019 3
	obj = drm_mode_object_find(dev, out_resp->connector_id,
				   DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
d2021 1
a2021 1
		goto out;
a2022 3
	connector = obj_to_connector(obj);

	props_count = connector->properties.count;
d2024 2
a2025 2
	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] != 0) {
a2026 2
		}
	}
d2046 5
a2050 2
	if (connector->encoder)
		out_resp->encoder_id = connector->encoder->base.id;
d2065 1
a2065 1
			drm_crtc_convert_to_umode(&u_mode, mode);
d2076 6
a2081 20
	if ((out_resp->count_props >= props_count) && props_count) {
		copied = 0;
		prop_ptr = (uint32_t __user *)(unsigned long)(out_resp->props_ptr);
		prop_values = (uint64_t __user *)(unsigned long)(out_resp->prop_values_ptr);
		for (i = 0; i < connector->properties.count; i++) {
			if (put_user(connector->properties.ids[i],
				     prop_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}

			if (put_user(connector->properties.values[i],
				     prop_values + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	out_resp->count_props = props_count;
d2100 3
d2108 40
a2151 1
	struct drm_mode_object *obj;
d2153 1
a2153 1
	int ret = 0;
d2158 3
a2160 8
	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, enc_resp->encoder_id,
				   DRM_MODE_OBJECT_ENCODER);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	encoder = obj_to_encoder(obj);
d2162 4
a2165 2
	if (encoder->crtc)
		enc_resp->crtc_id = encoder->crtc->base.id;
d2168 2
d2175 1
a2175 3
out:
	drm_modeset_unlock_all(dev);
	return ret;
d2179 1
a2179 1
 * drm_mode_getplane_res - get plane info
d2184 6
a2189 1
 * Return an plane count and set of IDs.
d2192 1
a2192 1
			    struct drm_file *file_priv)
d2198 2
a2199 1
	int copied = 0, ret = 0;
a2203 1
	drm_modeset_lock_all(dev);
d2206 5
d2215 2
a2216 2
	if (config->num_plane &&
	    (plane_resp->count_planes >= config->num_plane)) {
d2219 12
a2230 5
		list_for_each_entry(plane, &config->plane_list, head) {
			if (put_user(plane->base.id, plane_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
d2234 1
a2234 1
	plane_resp->count_planes = config->num_plane;
d2236 1
a2236 3
out:
	drm_modeset_unlock_all(dev);
	return ret;
d2240 1
a2240 1
 * drm_mode_getplane - get plane info
d2245 6
a2250 2
 * Return plane info, including formats supported, gamma size, any
 * current fb, etc.
d2253 1
a2253 1
			struct drm_file *file_priv)
a2255 1
	struct drm_mode_object *obj;
a2257 1
	int ret = 0;
d2262 3
a2264 8
	drm_modeset_lock_all(dev);
	obj = drm_mode_object_find(dev, plane_resp->plane_id,
				   DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		ret = -ENOENT;
		goto out;
	}
	plane = obj_to_plane(obj);
d2266 1
d2276 1
d2292 1
a2292 2
			ret = -EFAULT;
			goto out;
d2297 1
a2297 3
out:
	drm_modeset_unlock_all(dev);
	return ret;
d2301 3
a2303 4
 * drm_mode_setplane - set up or tear down an plane
 * @@dev: DRM device
 * @@data: ioctl data*
 * @@file_priv: DRM file info
d2305 3
a2307 2
 * Set plane info, including placement, fb, scaling, and other factors.
 * Or pass a NULL fb to disable.
d2309 15
a2323 2
int drm_mode_setplane(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
a2324 6
	struct drm_mode_set_plane *plane_req = data;
	struct drm_mode_object *obj;
	struct drm_plane *plane;
	struct drm_crtc *crtc;
	struct drm_framebuffer *fb = NULL, *old_fb = NULL;
	int ret = 0;
a2325 1
	int i;
d2327 2
a2328 2
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;
d2330 12
a2341 10
	/*
	 * First, find the plane, crtc, and fb objects.  If not available,
	 * we don't bother to call the driver.
	 */
	obj = drm_mode_object_find(dev, plane_req->plane_id,
				   DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown plane ID %d\n",
			      plane_req->plane_id);
		return -ENOENT;
d2343 23
a2365 1
	plane = obj_to_plane(obj);
d2368 9
a2376 7
	if (!plane_req->fb_id) {
		drm_modeset_lock_all(dev);
		old_fb = plane->fb;
		plane->funcs->disable_plane(plane);
		plane->crtc = NULL;
		plane->fb = NULL;
		drm_modeset_unlock_all(dev);
d2380 4
a2383 15
	obj = drm_mode_object_find(dev, plane_req->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
		DRM_DEBUG_KMS("Unknown crtc ID %d\n",
			      plane_req->crtc_id);
		ret = -ENOENT;
		goto out;
	}
	crtc = obj_to_crtc(obj);

	fb = drm_framebuffer_lookup(dev, plane_req->fb_id);
	if (!fb) {
		DRM_DEBUG_KMS("Unknown framebuffer ID %d\n",
			      plane_req->fb_id);
		ret = -ENOENT;
d2388 2
a2389 4
	for (i = 0; i < plane->format_count; i++)
		if (fb->pixel_format == plane->format_types[i])
			break;
	if (i == plane->format_count) {
a2391 23
		ret = -EINVAL;
		goto out;
	}

	fb_width = fb->width << 16;
	fb_height = fb->height << 16;

	/* Make sure source coordinates are inside the fb. */
	if (plane_req->src_w > fb_width ||
	    plane_req->src_x > fb_width - plane_req->src_w ||
	    plane_req->src_h > fb_height ||
	    plane_req->src_y > fb_height - plane_req->src_h) {
		DRM_DEBUG_KMS("Invalid source coordinates "
			      "%u.%06ux%u.%06u+%u.%06u+%u.%06u\n",
			      plane_req->src_w >> 16,
			      ((plane_req->src_w & 0xffff) * 15625) >> 10,
			      plane_req->src_h >> 16,
			      ((plane_req->src_h & 0xffff) * 15625) >> 10,
			      plane_req->src_x >> 16,
			      ((plane_req->src_x & 0xffff) * 15625) >> 10,
			      plane_req->src_y >> 16,
			      ((plane_req->src_y & 0xffff) * 15625) >> 10);
		ret = -ENOSPC;
d2396 4
a2399 4
	if (plane_req->crtc_w > INT_MAX ||
	    plane_req->crtc_x > INT_MAX - (int32_t) plane_req->crtc_w ||
	    plane_req->crtc_h > INT_MAX ||
	    plane_req->crtc_y > INT_MAX - (int32_t) plane_req->crtc_h) {
d2401 1
a2401 2
			      plane_req->crtc_w, plane_req->crtc_h,
			      plane_req->crtc_x, plane_req->crtc_y);
d2406 5
a2410 1
	drm_modeset_lock_all(dev);
d2412 2
a2413 4
					 plane_req->crtc_x, plane_req->crtc_y,
					 plane_req->crtc_w, plane_req->crtc_h,
					 plane_req->src_x, plane_req->src_y,
					 plane_req->src_w, plane_req->src_h);
a2414 1
		old_fb = plane->fb;
d2418 2
a2420 1
	drm_modeset_unlock_all(dev);
d2425 23
a2447 2
	if (old_fb)
		drm_framebuffer_unreference(old_fb);
d2453 62
d2520 3
d2536 2
a2537 2
	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head)
		tmp->old_fb = tmp->fb;
d2543 2
a2544 2
		/* crtc->fb must be updated by ->set_config, enforces this. */
		WARN_ON(fb != crtc->fb);
d2547 6
a2552 5
	list_for_each_entry(tmp, &crtc->dev->mode_config.crtc_list, head) {
		if (tmp->fb)
			drm_framebuffer_reference(tmp->fb);
		if (tmp->old_fb)
			drm_framebuffer_unreference(tmp->old_fb);
d2559 34
a2592 8
/*
 * Checks that the framebuffer is big enough for the CRTC viewport
 * (x, y, hdisplay, vdisplay)
 */
static int drm_crtc_check_viewport(const struct drm_crtc *crtc,
				   int x, int y,
				   const struct drm_display_mode *mode,
				   const struct drm_framebuffer *fb)
d2597 1
a2597 2
	hdisplay = mode->hdisplay;
	vdisplay = mode->vdisplay;
d2599 4
a2602 23
	if (drm_mode_is_stereo(mode)) {
		struct drm_display_mode adjusted = *mode;

		drm_mode_set_crtcinfo(&adjusted, CRTC_STEREO_DOUBLE);
		hdisplay = adjusted.crtc_hdisplay;
		vdisplay = adjusted.crtc_vdisplay;
	}

	if (crtc->invert_dimensions) {
		int tmp = hdisplay;
		hdisplay = vdisplay;
		vdisplay = tmp;
	}

	if (hdisplay > fb->width ||
	    vdisplay > fb->height ||
	    x > fb->width - hdisplay ||
	    y > fb->height - vdisplay) {
		DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
			      fb->width, fb->height, hdisplay, vdisplay, x, y,
			      crtc->invert_dimensions ? " (inverted)" : "");
		return -ENOSPC;
	}
d2604 2
a2605 1
	return 0;
d2607 1
d2619 2
a2620 2
 * RETURNS:
 * Zero on success, errno on failure.
a2626 1
	struct drm_mode_object *obj;
d2647 2
a2648 3
	obj = drm_mode_object_find(dev, crtc_req->crtc_id,
				   DRM_MODE_OBJECT_CRTC);
	if (!obj) {
a2652 1
	crtc = obj_to_crtc(obj);
d2659 1
a2659 1
			if (!crtc->fb) {
d2664 1
a2664 1
			fb = crtc->fb;
d2683 1
a2683 1
		ret = drm_crtc_convert_umode(mode, &crtc_req->mode);
d2689 16
a2704 1
		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
d2735 3
a2737 3
		connector_set = kmalloc(crtc_req->count_connectors *
					sizeof(struct drm_connector *),
					GFP_KERNEL);
d2750 2
a2751 3
			obj = drm_mode_object_find(dev, out_id,
						   DRM_MODE_OBJECT_CONNECTOR);
			if (!obj) {
a2756 1
			connector = obj_to_connector(obj);
d2759 1
a2759 1
					drm_get_connector_name(connector));
d2784 93
a2880 1
	struct drm_mode_object *obj;
d2890 2
a2891 2
	obj = drm_mode_object_find(dev, req->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
a2894 1
	crtc = obj_to_crtc(obj);
d2896 10
a2905 1
	mutex_lock(&crtc->mutex);
d2929 1
a2929 1
	mutex_unlock(&crtc->mutex);
d2934 15
d2950 1
a2950 1
			void *data, struct drm_file *file_priv)
d2961 15
d2980 1
d2984 8
a2991 1
/* Original addfb only supported RGB formats, so figure out which one */
d3033 2
a3034 1
 * Add a new FB to the specified CRTC, given a user request.
d3038 2
a3039 2
 * RETURNS:
 * Zero on success, errno on failure.
d3046 1
a3046 3
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_framebuffer *fb;
	int ret = 0;
d3048 1
a3048 1
	/* Use new struct with format internally */
d3056 3
a3058 2
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;
d3060 1
a3060 2
	if ((config->min_width > r.width) || (r.width > config->max_width))
		return -EINVAL;
d3062 1
a3062 16
	if ((config->min_height > r.height) || (r.height > config->max_height))
		return -EINVAL;

	fb = dev->mode_config.funcs->fb_create(dev, file_priv, &r);
	if (IS_ERR(fb)) {
		DRM_DEBUG_KMS("could not create framebuffer\n");
		return PTR_ERR(fb);
	}

	mutex_lock(&file_priv->fbs_lock);
	or->fb_id = fb->base.id;
	list_add(&fb->filp_head, &file_priv->fbs);
	DRM_DEBUG_KMS("[FB:%d]\n", fb->base.id);
	mutex_unlock(&file_priv->fbs_lock);

	return ret;
d3154 1
a3154 1
		DRM_DEBUG_KMS("bad framebuffer width %u\n", r->height);
d3183 50
d3238 4
a3241 15
/**
 * drm_mode_addfb2 - add an FB to the graphics configuration
 * @@dev: drm device for the ioctl
 * @@data: data pointer for the ioctl
 * @@file_priv: drm file for the ioctl call
 *
 * Add a new FB to the specified CRTC, given a user request with format.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_addfb2(struct drm_device *dev,
		    void *data, struct drm_file *file_priv)
a3242 1
	struct drm_mode_fb_cmd2 *r = data;
d3247 1
a3247 4
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	if (r->flags & ~DRM_MODE_FB_INTERLACED) {
d3249 1
a3249 1
		return -EINVAL;
d3255 1
a3255 1
		return -EINVAL;
d3260 7
a3266 1
		return -EINVAL;
d3271 1
a3271 1
		return ret;
d3276 32
a3308 1
	}
d3310 3
a3315 1
	DRM_DEBUG_KMS("[FB:%d]\n", fb->base.id);
d3318 15
d3334 3
a3336 1
	return ret;
d3349 2
a3350 2
 * RETURNS:
 * Zero on success, errno on failure.
a3374 3
	/* Mark fb as reaped, we still have a ref from fpriv->fbs. */
	__drm_framebuffer_unregister(dev, fb);

d3379 19
a3397 1
	drm_framebuffer_remove(fb);
d3418 2
a3419 2
 * RETURNS:
 * Zero on success, errno on failure.
d3441 2
a3442 1
		if (file_priv->is_master || capable(CAP_SYS_ADMIN)) {
d3463 19
d3521 1
a3521 1
		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
a3549 1

d3558 2
a3559 2
 * RETURNS:
 * Zero on success, errno on failure.
d3561 1
a3561 1
void drm_fb_release(struct drm_device *dev, struct drm_file *priv)
d3564 3
d3568 10
a3577 1
	mutex_lock(&priv->fbs_lock);
d3579 4
d3584 4
a3587 4
		mutex_lock(&dev->mode_config.fb_lock);
		/* Mark fb as reaped, we still have a ref from fpriv->fbs. */
		__drm_framebuffer_unregister(dev, fb);
		mutex_unlock(&dev->mode_config.fb_lock);
d3589 2
a3590 1
		list_del_init(&fb->filp_head);
d3592 3
a3594 2
		/* This will also drop the fpriv->fbs reference. */
		drm_framebuffer_remove(fb);
a3595 1
	mutex_unlock(&priv->fbs_lock);
d3598 18
d3626 2
d3629 2
a3630 1
		property->values = kzalloc(sizeof(uint64_t)*num_values, GFP_KERNEL);
d3641 1
a3641 1
	INIT_LIST_HEAD(&property->enum_blob_list);
d3649 3
d3660 18
d3706 19
d3728 2
a3729 1
					 int num_values)
d3732 2
a3733 1
	int i, ret;
d3740 3
d3744 6
a3749 2
	for (i = 0; i < num_values; i++) {
		ret = drm_property_add_enum(property, i,
d3762 2
a3763 2
struct drm_property *drm_property_create_range(struct drm_device *dev, int flags,
					 const char *name,
a3767 2
	flags |= DRM_MODE_PROP_RANGE;

d3777 26
d3805 101
d3911 2
a3912 1
	if (!(property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)))
d3919 2
a3920 1
	if ((property->flags & DRM_MODE_PROP_BITMASK) && (value > 63))
d3923 2
a3924 2
	if (!list_empty(&property->enum_blob_list)) {
		list_for_each_entry(prop_enum, &property->enum_blob_list, head) {
d3942 1
a3942 1
	list_add_tail(&prop_enum->head, &property->enum_blob_list);
d3947 8
d3959 1
a3959 1
	list_for_each_entry_safe(prop_enum, pt, &property->enum_blob_list, head) {
d3972 10
d3996 1
a3996 1
	obj->properties->ids[count] = property->base.id;
d3999 2
d4004 13
d4023 1
a4023 1
		if (obj->properties->ids[i] == property->base.id) {
d4033 14
d4052 8
d4061 1
a4061 1
		if (obj->properties->ids[i] == property->base.id) {
d4071 16
a4089 1
	struct drm_mode_object *obj;
a4092 1
	int blob_count = 0;
a4097 2
	struct drm_property_blob *prop_blob;
	uint32_t __user *blob_id_ptr;
a4098 1
	uint32_t __user *blob_length_ptr;
d4104 2
a4105 2
	obj = drm_mode_object_find(dev, out_resp->prop_id, DRM_MODE_OBJECT_PROPERTY);
	if (!obj) {
a4108 1
	property = obj_to_property(obj);
d4110 3
a4112 2
	if (property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)) {
		list_for_each_entry(prop_enum, &property->enum_blob_list, head)
a4113 3
	} else if (property->flags & DRM_MODE_PROP_BLOB) {
		list_for_each_entry(prop_blob, &property->enum_blob_list, head)
			blob_count++;
d4133 2
a4134 1
	if (property->flags & (DRM_MODE_PROP_ENUM | DRM_MODE_PROP_BITMASK)) {
d4138 1
a4138 1
			list_for_each_entry(prop_enum, &property->enum_blob_list, head) {
d4156 10
a4165 22
	if (property->flags & DRM_MODE_PROP_BLOB) {
		if ((out_resp->count_enum_blobs >= blob_count) && blob_count) {
			copied = 0;
			blob_id_ptr = (uint32_t __user *)(unsigned long)out_resp->enum_blob_ptr;
			blob_length_ptr = (uint32_t __user *)(unsigned long)out_resp->values_ptr;

			list_for_each_entry(prop_blob, &property->enum_blob_list, head) {
				if (put_user(prop_blob->base.id, blob_id_ptr + copied)) {
					ret = -EFAULT;
					goto done;
				}

				if (put_user(prop_blob->length, blob_length_ptr + copied)) {
					ret = -EFAULT;
					goto done;
				}

				copied++;
			}
		}
		out_resp->count_enum_blobs = blob_count;
	}
d4171 17
a4187 2
static struct drm_property_blob *drm_property_create_blob(struct drm_device *dev, int length,
							  void *data)
d4192 2
a4193 2
	if (!length || !data)
		return NULL;
d4197 12
a4208 1
		return NULL;
d4213 2
a4214 1
		return NULL;
d4217 4
a4220 1
	blob->length = length;
d4222 1
a4222 1
	memcpy(blob->data, data, length);
a4223 1
	list_add_tail(&blob->head, &dev->mode_config.property_blob_list);
d4226 1
d4228 8
a4235 2
static void drm_property_destroy_blob(struct drm_device *dev,
			       struct drm_property_blob *blob)
d4237 9
a4245 2
	drm_mode_object_put(dev, &blob->base);
	list_del(&blob->head);
d4249 217
a4468 1
	struct drm_mode_object *obj;
d4478 3
a4480 2
	obj = drm_mode_object_find(dev, out_resp->blob_id, DRM_MODE_OBJECT_BLOB);
	if (!obj) {
a4483 1
	blob = obj_to_blob(obj);
d4487 1
a4487 1
		if (copy_to_user(blob_ptr, blob->data, blob->length)){
d4495 1
d4500 123
a4622 2
int drm_mode_connector_update_edid_property(struct drm_connector *connector,
					    struct edid *edid)
d4625 1
a4625 1
	int ret, size;
d4627 9
a4635 2
	if (connector->edid_blob_ptr)
		drm_property_destroy_blob(dev, connector->edid_blob_ptr);
d4637 24
a4660 4
	/* Delete edid, when there is none. */
	if (!edid) {
		connector->edid_blob_ptr = NULL;
		ret = drm_object_property_set_value(&connector->base, dev->mode_config.edid_property, 0);
d4664 37
a4700 5
	size = EDID_LENGTH * (1 + edid->extensions);
	connector->edid_blob_ptr = drm_property_create_blob(connector->dev,
							    size, edid);
	if (!connector->edid_blob_ptr)
		return -EINVAL;
d4702 2
a4703 3
	ret = drm_object_property_set_value(&connector->base,
					       dev->mode_config.edid_property,
					       connector->edid_blob_ptr->base.id);
d4705 6
d4715 10
a4724 2
static bool drm_property_change_is_valid(struct drm_property *property,
					 uint64_t value)
d4726 2
d4730 4
a4733 1
	if (property->flags & DRM_MODE_PROP_RANGE) {
d4737 8
a4744 2
	} else if (property->flags & DRM_MODE_PROP_BITMASK) {
		int i;
d4746 1
d4750 24
a4773 7
	} else if (property->flags & DRM_MODE_PROP_BLOB) {
		/* Only the driver knows */
		return true;
	} else {
		int i;
		for (i = 0; i < property->num_values; i++)
			if (property->values[i] == value)
d4775 6
a4780 1
		return false;
d4782 18
d4802 14
d4840 1
d4842 1
a4842 2
			(*connector->funcs->dpms)(connector, (int)value);
		ret = 0;
d4867 16
a4882 3
static int drm_mode_plane_set_obj_prop(struct drm_mode_object *obj,
				      struct drm_property *property,
				      uint64_t value)
d4885 1
a4885 1
	struct drm_plane *plane = obj_to_plane(obj);
d4894 1
d4896 15
a4916 5
	int i;
	int copied = 0;
	int props_count = 0;
	uint32_t __user *props_ptr;
	uint64_t __user *prop_values_ptr;
d4933 4
a4936 1
	props_count = obj->properties->count;
a4937 22
	/* This ioctl is called twice, once to determine how much space is
	 * needed, and the 2nd time to fill it. */
	if ((arg->count_props >= props_count) && props_count) {
		copied = 0;
		props_ptr = (uint32_t __user *)(unsigned long)(arg->props_ptr);
		prop_values_ptr = (uint64_t __user *)(unsigned long)
				  (arg->prop_values_ptr);
		for (i = 0; i < props_count; i++) {
			if (put_user(obj->properties->ids[i],
				     props_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
			if (put_user(obj->properties->values[i],
				     prop_values_ptr + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	arg->count_props = props_count;
d4943 16
d4966 2
a4967 2
	int ret = -EINVAL;
	int i;
d4983 1
a4983 1
		if (arg_obj->properties->ids[i] == arg->prop_id)
d4997 1
a4997 1
	if (!drm_property_change_is_valid(property, arg->value))
d5009 2
a5010 1
		ret = drm_mode_plane_set_obj_prop(arg_obj, property, arg->value);
d5014 2
d5021 12
d5048 12
a5059 15
void drm_mode_connector_detach_encoder(struct drm_connector *connector,
				    struct drm_encoder *encoder)
{
	int i;
	for (i = 0; i < DRM_CONNECTOR_MAX_ENCODER; i++) {
		if (connector->encoder_ids[i] == encoder->base.id) {
			connector->encoder_ids[i] = 0;
			if (connector->encoder == encoder)
				connector->encoder = NULL;
			break;
		}
	}
}
EXPORT_SYMBOL(drm_mode_connector_detach_encoder);

d5061 1
a5061 1
				  int gamma_size)
d5065 2
a5066 1
	crtc->gamma_store = kzalloc(gamma_size * sizeof(uint16_t) * 3, GFP_KERNEL);
d5076 14
a5093 1
	struct drm_mode_object *obj;
d5103 2
a5104 2
	obj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
a5107 1
	crtc = obj_to_crtc(obj);
d5147 15
a5165 1
	struct drm_mode_object *obj;
d5175 2
a5176 2
	obj = drm_mode_object_find(dev, crtc_lut->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj) {
a5179 1
	crtc = obj_to_crtc(obj);
d5210 18
a5231 1
	struct drm_mode_object *obj;
d5233 1
a5233 1
	struct drm_framebuffer *fb = NULL, *old_fb = NULL;
d5238 3
d5248 2
a5249 2
	obj = drm_mode_object_find(dev, page_flip->crtc_id, DRM_MODE_OBJECT_CRTC);
	if (!obj)
a5250 1
	crtc = obj_to_crtc(obj);
d5252 2
a5253 2
	mutex_lock(&crtc->mutex);
	if (crtc->fb == NULL) {
d5271 8
a5278 1
	ret = drm_crtc_check_viewport(crtc, crtc->x, crtc->y, &crtc->mode, fb);
d5282 1
a5282 1
	if (crtc->fb->pixel_format != fb->pixel_format) {
d5291 1
a5291 1
		if (file_priv->event_space < sizeof e->event) {
d5295 1
a5295 1
		file_priv->event_space -= sizeof e->event;
d5298 1
a5298 1
		e = kzalloc(sizeof *e, GFP_KERNEL);
d5301 1
a5301 1
			file_priv->event_space += sizeof e->event;
d5307 1
a5307 1
		e->event.base.length = sizeof e->event;
d5315 1
a5315 1
	old_fb = crtc->fb;
d5320 1
a5320 1
			file_priv->event_space += sizeof e->event;
d5325 1
a5325 1
		old_fb = NULL;
d5327 1
a5327 7
		/*
		 * Warn if the driver hasn't properly updated the crtc->fb
		 * field to reflect that the new framebuffer is now used.
		 * Failing to do so will screw with the reference counting
		 * on framebuffers.
		 */
		WARN_ON(crtc->fb != fb);
d5335 4
a5338 3
	if (old_fb)
		drm_framebuffer_unreference(old_fb);
	mutex_unlock(&crtc->mutex);
d5343 8
d5354 1
d5358 5
a5362 1
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
d5366 1
a5366 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
d5370 2
a5371 3
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		connector->status = connector_status_unknown;

d5374 1
a5374 1
	}
d5378 19
d5401 1
d5405 27
d5435 14
d5461 15
d5487 8
a5494 3
/*
 * Just need to support RGB formats here for compat with code that doesn't
 * use pixel formats directly yet.
d5566 1
a5566 1
 * RETURNS:
d5601 1
a5601 1
 * RETURNS:
d5647 1
a5647 1
 * RETURNS:
d5682 1
a5682 1
 * RETURNS:
d5704 31
d5749 2
a5750 1
	rw_init(&dev->mode_config.idr_mutex, "idrwl");
d5752 1
a5755 1
	INIT_LIST_HEAD(&dev->mode_config.bridge_list);
d5761 1
d5764 1
a5764 1
	drm_mode_create_standard_connector_properties(dev);
d5772 2
a5794 1
	struct drm_bridge *bridge, *brt;
a5804 5
	list_for_each_entry_safe(bridge, brt,
				 &dev->mode_config.bridge_list, head) {
		bridge->funcs->destroy(bridge);
	}

d5816 2
a5817 2
				 head) {
		drm_property_destroy_blob(dev, blob);
d5830 1
a5830 1
		drm_framebuffer_remove(fb);
d5842 1
d5844 1
d5847 117
@


1.23
log
@Get rid of some infrastrcuture that is now obsolete and synchronize some of
the data structures in drmP.h with Linux 3.14.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.22 2016/04/07 20:33:24 kettenis Exp $	*/
d645 1
a645 1
	rw_init(&crtc->mutex, "crtcl");
@


1.22
log
@Retry the drm_crtc.c "idr"conversion.  Turns out the xf86-video-intel driver
is buggy and trucates the ids to 8 bits.  So specifymaximum in the idr_alloc()
call until that gets fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.21 2016/04/06 21:12:40 kettenis Exp $	*/
d2762 1
a2762 1
		if (file_priv->master || capable(CAP_SYS_ADMIN)) {
@


1.21
log
@Revert the drm_crt.c "idr" conversion as it breaks X on (at least) the T430s.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.20 2016/04/06 14:39:19 kettenis Exp $	*/
a101 4
int	 drm_mode_handle_cmp(struct drm_mode_handle *, struct drm_mode_handle *);

SPLAY_PROTOTYPE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);

d312 14
a325 2
	struct drm_mode_handle *han;
	int new_id = 0;
d327 1
a327 18
	if ((han = drm_calloc(1, sizeof(*han))) == NULL)
		return -ENOMEM;
	han->obj = obj;
	rw_enter_write(&dev->mode_config.idr_rwl);
	
again:
	new_id = han->handle = ++dev->mode_config.mode_obj_id;
	/*
	 * Make sure we have no duplicates. this'll hurt once we wrap, 0 is
	 * reserved.
	 */
	obj->id = new_id;
	obj->type = obj_type;
	if (han->handle == 0 || SPLAY_INSERT(drm_mode_tree,
		&dev->mode_config.mode_tree, han))
		goto again;
	rw_exit_write(&dev->mode_config.idr_rwl);
	return 0;
d340 3
a342 7
	struct drm_mode_handle han;
	han.obj = object;
	han.handle = object->id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
a357 1
	struct drm_mode_handle *han, search;
d359 7
a365 10
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}
	
	obj = han->obj;
	if (obj->type != type) {
d367 1
a367 2
	}
	rw_exit_write(&dev->mode_config.idr_rwl);
a428 1
	struct drm_mode_handle *han, search;
d431 2
a432 9
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}

	obj = han->obj;
d437 1
a437 1
	rw_exit_write(&dev->mode_config.idr_rwl);
d505 3
a507 7
	struct drm_mode_handle han;
	han.obj = &fb->base;
	han.handle = fb->base.id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
d4062 1
a4062 1
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
d4072 1
a4072 1
	SPLAY_INIT(&dev->mode_config.mode_tree);
a4156 1
#ifdef __linux__
a4157 3
#else
	/* XXX destroy idr/SPLAY tree */
#endif
a4159 8

int      
drm_mode_handle_cmp(struct drm_mode_handle *a, struct drm_mode_handle *b)
{
	return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);
@


1.20
log
@Another "idr" conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.19 2015/09/27 11:09:26 jsg Exp $	*/
d102 4
d316 2
a317 1
	int ret;
d319 18
a336 13
	mutex_lock(&dev->mode_config.idr_mutex);
	ret = idr_alloc(&dev->mode_config.crtc_idr, obj, 1, 0, GFP_KERNEL);
	if (ret >= 0) {
		/*
		 * Set up the object linking under the protection of the idr
		 * lock so that other users can't see inconsistent state.
		 */
		obj->id = ret;
		obj->type = obj_type;
	}
	mutex_unlock(&dev->mode_config.idr_mutex);

	return ret < 0 ? ret : 0;
d349 7
a355 3
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, object->id);
	mutex_unlock(&dev->mode_config.idr_mutex);
d371 1
d373 10
a382 7
	/* Framebuffers are reference counted and need their own lookup
	 * function.*/
	WARN_ON(type == DRM_MODE_OBJECT_FB);

	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
	if (!obj || (obj->type != type) || (obj->id != id))
d384 2
a385 1
	mutex_unlock(&dev->mode_config.idr_mutex);
d447 1
d450 9
a458 2
	mutex_lock(&dev->mode_config.idr_mutex);
	obj = idr_find(&dev->mode_config.crtc_idr, id);
d463 1
a463 1
	mutex_unlock(&dev->mode_config.idr_mutex);
d531 7
a537 3
	mutex_lock(&dev->mode_config.idr_mutex);
	idr_remove(&dev->mode_config.crtc_idr, fb->base.id);
	mutex_unlock(&dev->mode_config.idr_mutex);
d4092 1
a4092 1
	rw_init(&dev->mode_config.idr_mutex, "idrwl");
d4102 1
a4102 1
	idr_init(&dev->mode_config.crtc_idr);
d4187 1
d4189 3
d4194 8
@


1.19
log
@Switch remaining users of the FreeBSD refcount apis back to the original
linux kref/kobject use.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.18 2015/09/23 23:12:11 kettenis Exp $	*/
a101 4
int	 drm_mode_handle_cmp(struct drm_mode_handle *, struct drm_mode_handle *);

SPLAY_PROTOTYPE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);

d312 13
a324 2
	struct drm_mode_handle *han;
	int new_id = 0;
d326 1
a326 18
	if ((han = drm_calloc(1, sizeof(*han))) == NULL)
		return -ENOMEM;
	han->obj = obj;
	rw_enter_write(&dev->mode_config.idr_rwl);
	
again:
	new_id = han->handle = ++dev->mode_config.mode_obj_id;
	/*
	 * Make sure we have no duplicates. this'll hurt once we wrap, 0 is
	 * reserved.
	 */
	obj->id = new_id;
	obj->type = obj_type;
	if (han->handle == 0 || SPLAY_INSERT(drm_mode_tree,
		&dev->mode_config.mode_tree, han))
		goto again;
	rw_exit_write(&dev->mode_config.idr_rwl);
	return 0;
d339 3
a341 7
	struct drm_mode_handle han;
	han.obj = object;
	han.handle = object->id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
a356 1
	struct drm_mode_handle *han, search;
d358 7
a364 10
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}
	
	obj = han->obj;
	if (obj->type != type) {
d366 1
a366 2
	}
	rw_exit_write(&dev->mode_config.idr_rwl);
a427 1
	struct drm_mode_handle *han, search;
d430 2
a431 9
	rw_enter_write(&dev->mode_config.idr_rwl);
	search.handle = id;
	han = SPLAY_FIND(drm_mode_tree, &dev->mode_config.mode_tree, &search);
	if (han == NULL) {
		rw_exit_write(&dev->mode_config.idr_rwl);
		return NULL;
	}

	obj = han->obj;
d436 1
a436 1
	rw_exit_write(&dev->mode_config.idr_rwl);
d504 3
a506 7
	struct drm_mode_handle han;
	han.obj = &fb->base;
	han.handle = fb->base.id;

	rw_enter_write(&dev->mode_config.idr_rwl);
	SPLAY_REMOVE(drm_mode_tree, &dev->mode_config.mode_tree, &han);
	rw_exit_write(&dev->mode_config.idr_rwl);
d4061 1
a4061 1
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
d4071 1
a4071 1
	SPLAY_INIT(&dev->mode_config.mode_tree);
a4155 1
#ifdef __linux__
a4156 3
#else
	/* XXX destroy idr/SPLAY tree */
#endif
a4158 8

int      
drm_mode_handle_cmp(struct drm_mode_handle *a, struct drm_mode_handle *b)
{
	return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(drm_mode_tree, drm_mode_handle, entry, drm_mode_handle_cmp);
@


1.18
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.17 2015/05/05 02:01:10 jsg Exp $	*/
a36 1
#include "refcount.h"
d415 1
a415 1
	refcount_init(&fb->refcount, 1);
d436 1
a436 1
static void drm_framebuffer_free(struct drm_framebuffer *fb)
d438 2
d501 1
a501 2
	if (refcount_release(&fb->refcount))
		drm_framebuffer_free(fb);
d512 1
a512 1
	refcount_acquire(&fb->refcount);
d516 1
a516 1
static void drm_framebuffer_free_bug(struct drm_framebuffer *fb)
d524 1
a524 2
	if (refcount_release(&fb->refcount))
		drm_framebuffer_free_bug(fb);
d628 1
a628 1
	if (atomic_read(&fb->refcount) > 1) {
@


1.17
log
@fix a return path that lacked a rw_exit_write() call
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.16 2015/04/06 09:23:19 jsg Exp $	*/
d39 52
d93 1
a93 3
	char *fnname(int);					\
								\
	char *fnname(int val)					\
a102 2
char	*drm_get_connector_status_name(enum drm_connector_status);
int	 drm_mode_group_init(struct drm_device *, struct drm_mode_group *);
d110 1
a110 1
static struct drm_prop_enum_list drm_dpms_enum_list[] =
d122 1
a122 1
static struct drm_prop_enum_list drm_scaling_mode_enum_list[] =
a129 7
static struct drm_prop_enum_list drm_dithering_mode_enum_list[] =
{
	{ DRM_MODE_DITHERING_OFF, "Off" },
	{ DRM_MODE_DITHERING_ON, "On" },
	{ DRM_MODE_DITHERING_AUTO, "Automatic" },
};

d133 1
a133 1
static struct drm_prop_enum_list drm_dvi_i_select_enum_list[] =
d142 1
a142 1
static struct drm_prop_enum_list drm_dvi_i_subconnector_enum_list[] =
d152 1
a152 1
static struct drm_prop_enum_list drm_tv_select_enum_list[] =
d163 1
a163 1
static struct drm_prop_enum_list drm_tv_subconnector_enum_list[] =
d175 1
a175 1
static struct drm_prop_enum_list drm_dirty_info_enum_list[] = {
a180 3
DRM_ENUM_NAME_FN(drm_get_dirty_info_name,
		 drm_dirty_info_enum_list)

d183 4
a186 1
	char *name;
d188 1
d195 17
a211 16
{	{ DRM_MODE_CONNECTOR_Unknown, "Unknown", 0 },
	{ DRM_MODE_CONNECTOR_VGA, "VGA", 0 },
	{ DRM_MODE_CONNECTOR_DVII, "DVI-I", 0 },
	{ DRM_MODE_CONNECTOR_DVID, "DVI-D", 0 },
	{ DRM_MODE_CONNECTOR_DVIA, "DVI-A", 0 },
	{ DRM_MODE_CONNECTOR_Composite, "Composite", 0 },
	{ DRM_MODE_CONNECTOR_SVIDEO, "SVIDEO", 0 },
	{ DRM_MODE_CONNECTOR_LVDS, "LVDS", 0 },
	{ DRM_MODE_CONNECTOR_Component, "Component", 0 },
	{ DRM_MODE_CONNECTOR_9PinDIN, "DIN", 0 },
	{ DRM_MODE_CONNECTOR_DisplayPort, "DP", 0 },
	{ DRM_MODE_CONNECTOR_HDMIA, "HDMI-A", 0 },
	{ DRM_MODE_CONNECTOR_HDMIB, "HDMI-B", 0 },
	{ DRM_MODE_CONNECTOR_TV, "TV", 0 },
	{ DRM_MODE_CONNECTOR_eDP, "eDP", 0 },
	{ DRM_MODE_CONNECTOR_VIRTUAL, "Virtual", 0},
d214 1
a214 1
static struct drm_prop_enum_list drm_encoder_enum_list[] =
d221 1
d224 23
a246 1
char *drm_get_encoder_name(struct drm_encoder *encoder)
d257 1
a257 1
char *drm_get_connector_name(struct drm_connector *connector)
d268 1
a268 1
char *drm_get_connector_status_name(enum drm_connector_status status)
d277 23
d302 1
a302 1
 * drm_mode_object_get - allocate a new identifier
d304 2
a305 4
 * @@ptr: object pointer, used to generate unique ID
 * @@type: object type
 *
 * LOCKING:
d341 1
a341 1
 * drm_mode_object_put - free an identifer
d343 1
a343 4
 * @@id: ID to free
 *
 * LOCKING:
 * Caller must hold DRM mode_config lock.
d359 9
d395 2
a396 3
 *
 * LOCKING:
 * Caller must hold mode config lock.
d401 6
d415 1
d417 3
d423 4
a426 1
		return ret;
a427 2
	fb->dev = dev;
	fb->funcs = funcs;
d430 2
d442 49
d493 1
d495 1
a495 2
 * LOCKING:
 * Caller must hold mode config lock.
a498 1
	struct drm_device *dev = fb->dev;
a499 1
	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
d507 1
d516 49
d569 2
a570 2
 * LOCKING:
 * Caller must hold mode config lock.
d572 8
a579 2
 * Scans all the CRTCs in @@dev's mode_config.  If they're using @@fb, removes
 * it, setting it to NULL.
d584 2
a585 8
	/*
	 * This could be moved to drm_framebuffer_remove(), but for
	 * debugging is nice to keep around the list of fb's that are
	 * no longer associated w/ a drm_file but are not unreferenced
	 * yet.  (i915 and omapdrm have debugfs files which will show
	 * this.)
	 */
	drm_mode_object_put(dev, &fb->base);
d588 1
d596 3
a598 2
 * LOCKING:
 * Caller must hold mode config lock.
d600 3
a602 2
 * Scans all the CRTCs and planes in @@dev's mode_config.  If they're
 * using @@fb, removes it, setting it to NULL.
d612 30
a641 10
	/* remove from any CRTC */
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		if (crtc->fb == fb) {
			/* should turn off the crtc */
			memset(&set, 0, sizeof(struct drm_mode_set));
			set.crtc = crtc;
			set.fb = NULL;
			ret = crtc->funcs->set_config(&set);
			if (ret)
				DRM_ERROR("failed to reset crtc %p when fb was deleted\n", crtc);
a642 1
	}
d644 3
a646 9
	list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
		if (plane->fb == fb) {
			/* should turn off the crtc */
			ret = plane->funcs->disable_plane(plane);
			if (ret)
				DRM_ERROR("failed to disable plane with busy fb\n");
			/* disconnect the plane from the fb and crtc: */
			plane->fb = NULL;
			plane->crtc = NULL;
d648 1
a650 2
	list_del(&fb->filp_head);

d661 1
a661 4
 * LOCKING:
 * Takes mode_config lock.
 *
 * Inits a new object created as base part of an driver crtc object.
d675 3
a677 1
	mutex_lock(&dev->mode_config.mutex);
d689 1
a689 1
	mutex_unlock(&dev->mode_config.mutex);
d696 1
a696 1
 * drm_crtc_cleanup - Cleans up the core crtc usage.
d699 3
a701 5
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Cleanup @@crtc. Removes from drm modesetting space
 * does NOT free object, caller does that.
d717 23
a743 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d749 1
a749 1
	list_add(&mode->head, &connector->probed_modes);
d753 1
a753 1
/**
a757 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d760 2
a761 2
void drm_mode_remove(struct drm_connector *connector,
		     struct drm_display_mode *mode)
a765 1
EXPORT_SYMBOL(drm_mode_remove);
d772 1
a772 4
 * @@name: user visible name of the connector
 *
 * LOCKING:
 * Takes mode config lock.
d786 4
d791 1
a791 1
	mutex_lock(&dev->mode_config.mutex);
d801 4
d806 7
a812 2
		++drm_connector_enum_list[connector_type].count; /* TODO */
	INIT_LIST_HEAD(&connector->user_modes);
d830 1
a830 1
	mutex_unlock(&dev->mode_config.mutex);
a839 3
 * LOCKING:
 * Takes mode config lock.
 *
d853 4
a856 2
	list_for_each_entry_safe(mode, t, &connector->user_modes, head)
		drm_mode_remove(connector, mode);
a857 1
	mutex_lock(&dev->mode_config.mutex);
a860 1
	mutex_unlock(&dev->mode_config.mutex);
d874 35
d916 1
a916 1
	mutex_lock(&dev->mode_config.mutex);
d930 1
a930 1
	mutex_unlock(&dev->mode_config.mutex);
d939 1
a939 1
	mutex_lock(&dev->mode_config.mutex);
d943 1
a943 1
	mutex_unlock(&dev->mode_config.mutex);
d947 15
d970 1
a970 1
	mutex_lock(&dev->mode_config.mutex);
d1004 1
a1004 1
	mutex_unlock(&dev->mode_config.mutex);
d1010 8
d1022 1
a1022 1
	mutex_lock(&dev->mode_config.mutex);
d1030 1
a1030 1
	mutex_unlock(&dev->mode_config.mutex);
d1035 26
a1063 3
 * LOCKING:
 * Caller must hold DRM mode_config lock.
 *
a1090 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
a1262 24
 * drm_mode_create_dithering_property - create dithering property
 * @@dev: DRM device
 *
 * Called by a driver the first time it's needed, must be attached to desired
 * connectors.
 */
int drm_mode_create_dithering_property(struct drm_device *dev)
{
	struct drm_property *dithering_mode;

	if (dev->mode_config.dithering_mode_property)
		return 0;

	dithering_mode =
		drm_property_create_enum(dev, 0, "dithering",
				drm_dithering_mode_enum_list,
				    ARRAY_SIZE(drm_dithering_mode_enum_list));
	dev->mode_config.dithering_mode_property = dithering_mode;

	return 0;
}
EXPORT_SYMBOL(drm_mode_create_dithering_property);

/**
d1287 1
a1287 11
/**
 * drm_mode_config_init - initialize DRM mode_configuration structure
 * @@dev: DRM device
 *
 * LOCKING:
 * None, should happen single threaded at init time.
 *
 * Initialize @@dev's mode_config structure, used for tracking the graphics
 * configuration of @@dev.
 */
void drm_mode_config_init(struct drm_device *dev)
d1289 1
a1289 26
	rw_init(&dev->mode_config.mutex, "mcrwl");
	rw_init(&dev->mode_config.idr_rwl, "idrwl");
	INIT_LIST_HEAD(&dev->mode_config.fb_list);
	INIT_LIST_HEAD(&dev->mode_config.crtc_list);
	INIT_LIST_HEAD(&dev->mode_config.connector_list);
	INIT_LIST_HEAD(&dev->mode_config.encoder_list);
	INIT_LIST_HEAD(&dev->mode_config.property_list);
	INIT_LIST_HEAD(&dev->mode_config.property_blob_list);
	INIT_LIST_HEAD(&dev->mode_config.plane_list);
	SPLAY_INIT(&dev->mode_config.mode_tree);

	mutex_lock(&dev->mode_config.mutex);
	drm_mode_create_standard_connector_properties(dev);
	mutex_unlock(&dev->mode_config.mutex);

	/* Just to be sure */
	dev->mode_config.num_fb = 0;
	dev->mode_config.num_connector = 0;
	dev->mode_config.num_crtc = 0;
	dev->mode_config.num_encoder = 0;
}
EXPORT_SYMBOL(drm_mode_config_init);

int drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
{
	uint32_t total_objects = 0;
d1294 1
d1303 1
d1313 1
d1330 5
a1339 53
 * drm_mode_config_cleanup - free up DRM mode_config info
 * @@dev: DRM device
 *
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Free up all the connectors and CRTCs associated with this DRM device, then
 * free up the framebuffers and associated buffer objects.
 *
 * FIXME: cleanup any dangling user buffer objects too
 */
void drm_mode_config_cleanup(struct drm_device *dev)
{
	struct drm_connector *connector, *ot;
	struct drm_crtc *crtc, *ct;
	struct drm_encoder *encoder, *enct;
	struct drm_framebuffer *fb, *fbt;
	struct drm_property *property, *pt;
	struct drm_plane *plane, *plt;

	list_for_each_entry_safe(encoder, enct, &dev->mode_config.encoder_list,
				 head) {
		encoder->funcs->destroy(encoder);
	}

	list_for_each_entry_safe(connector, ot,
				 &dev->mode_config.connector_list, head) {
		connector->funcs->destroy(connector);
	}

	list_for_each_entry_safe(property, pt, &dev->mode_config.property_list,
				 head) {
		drm_property_destroy(dev, property);
	}

	list_for_each_entry_safe(fb, fbt, &dev->mode_config.fb_list, head) {
		drm_framebuffer_remove(fb);
	}

	list_for_each_entry_safe(plane, plt, &dev->mode_config.plane_list,
				 head) {
		plane->funcs->destroy(plane);
	}

	list_for_each_entry_safe(crtc, ct, &dev->mode_config.crtc_list, head) {
		crtc->funcs->destroy(crtc);
	}

	// XXX destroy idr/SPLAY tree
}
EXPORT_SYMBOL(drm_mode_config_cleanup);

/**
a1343 3
 * LOCKING:
 * None.
 *
d1376 1
a1376 1
 * drm_crtc_convert_to_umode - convert a modeinfo into a drm_display_mode
a1379 3
 * LOCKING:
 * None.
 *
d1392 3
d1417 3
a1419 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1443 3
a1446 2
#if 0
	int i;
d1452 1
a1452 1
#if 0
a1458 1
	mutex_lock(&dev->mode_config.mutex);
d1460 1
d1468 18
a1485 1
#if 0
d1498 1
a1498 1
#if 0
a1511 15
	/* handle this in 4 parts */
	/* FBs */
	if (card_res->count_fbs >= fb_count) {
		copied = 0;
		fb_id = (uint32_t __user *)(unsigned long)card_res->fb_id_ptr;
		list_for_each_entry(fb, &file_priv->fbs, filp_head) {
			if (put_user(fb->base.id, fb_id + copied)) {
				ret = -EFAULT;
				goto out;
			}
			copied++;
		}
	}
	card_res->count_fbs = fb_count;

d1516 1
a1516 1
#if 0
d1528 1
a1528 1
#if 0
d1547 1
a1547 1
#if 0
d1562 1
a1562 1
#if 0
d1582 1
a1582 1
#if 0
d1598 1
a1598 1
#if 0
d1619 1
a1619 1
	mutex_unlock(&dev->mode_config.mutex);
d1625 3
a1627 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1647 1
a1647 1
	mutex_lock(&dev->mode_config.mutex);
d1652 1
a1652 1
		ret = -EINVAL;
d1675 1
a1675 1
	mutex_unlock(&dev->mode_config.mutex);
d1679 13
d1694 3
a1696 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d1736 1
a1736 1
		ret = -EINVAL;
d1757 2
a1758 1
		mode_count++;
d1780 3
d1833 1
d1848 1
a1848 1
	mutex_lock(&dev->mode_config.mutex);
d1852 1
a1852 1
		ret = -EINVAL;
d1867 1
a1867 1
	mutex_unlock(&dev->mode_config.mutex);
a1876 3
 * LOCKING:
 * Takes mode config lock.
 *
d1891 1
a1891 1
	mutex_lock(&dev->mode_config.mutex);
d1913 1
a1913 1
	mutex_unlock(&dev->mode_config.mutex);
a1922 3
 * LOCKING:
 * Takes mode config lock.
 *
d1938 1
a1938 1
	mutex_lock(&dev->mode_config.mutex);
d1959 1
a1959 1
	plane_resp->gamma_size = plane->gamma_size;
d1978 1
a1978 1
	mutex_unlock(&dev->mode_config.mutex);
d1986 1
a1986 4
 * @@file_prive: DRM file info
 *
 * LOCKING:
 * Takes mode config lock.
d1998 1
a1998 1
	struct drm_framebuffer *fb;
a2005 2
	mutex_lock(&dev->mode_config.mutex);

d2015 1
a2015 2
		ret = -ENOENT;
		goto out;
d2021 2
d2026 1
d2040 2
a2041 3
	obj = drm_mode_object_find(dev, plane_req->fb_id,
				   DRM_MODE_OBJECT_FB);
	if (!obj) {
a2046 1
	fb = obj_to_fb(obj);
d2053 2
a2054 1
		DRM_DEBUG_KMS("Invalid pixel format 0x%08x\n", fb->pixel_format);
d2093 1
d2100 1
d2103 1
d2105 1
d2108 44
a2151 1
	mutex_unlock(&dev->mode_config.mutex);
d2155 43
d2201 3
a2203 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
d2230 5
a2234 2
	/* For some reason crtc x/y offsets are signed internally. */
	if (crtc_req->x > INT_MAX || crtc_req->y > INT_MAX)
d2237 1
a2237 1
	mutex_lock(&dev->mode_config.mutex);
d2242 1
a2242 1
		ret = -EINVAL;
a2248 1
		int hdisplay, vdisplay;
d2258 2
d2261 2
a2262 3
			obj = drm_mode_object_find(dev, crtc_req->fb_id,
						   DRM_MODE_OBJECT_FB);
			if (!obj) {
d2265 1
a2265 1
				ret = -EINVAL;
a2267 1
			fb = obj_to_fb(obj);
d2284 4
a2287 2
		hdisplay = mode->hdisplay;
		vdisplay = mode->vdisplay;
a2288 17
		if (crtc->invert_dimensions) {
			int tmp = hdisplay;
			hdisplay = vdisplay;
			vdisplay = tmp;
		}

		if (hdisplay > fb->width ||
		    vdisplay > fb->height ||
		    crtc_req->x > fb->width - hdisplay ||
		    crtc_req->y > fb->height - vdisplay) {
			DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
				      fb->width, fb->height,
				      hdisplay, vdisplay, crtc_req->x, crtc_req->y,
				      crtc->invert_dimensions ? " (inverted)" : "");
			ret = -ENOSPC;
			goto out;
		}
d2333 1
a2333 1
				ret = -EINVAL;
d2352 1
a2352 1
	ret = crtc->funcs->set_config(&set);
d2355 3
d2360 1
a2360 1
	mutex_unlock(&dev->mode_config.mutex);
d2364 3
a2366 2
int drm_mode_cursor_ioctl(struct drm_device *dev,
			void *data, struct drm_file *file_priv)
a2367 1
	struct drm_mode_cursor *req = data;
a2377 1
	mutex_lock(&dev->mode_config.mutex);
d2381 1
a2381 2
		ret = -EINVAL;
		goto out;
d2385 1
d2387 1
a2387 1
		if (!crtc->funcs->cursor_set) {
d2392 6
a2397 2
		ret = crtc->funcs->cursor_set(crtc, file_priv, req->handle,
					      req->width, req->height);
d2409 2
a2410 1
	mutex_unlock(&dev->mode_config.mutex);
d2412 19
d2471 3
a2473 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2507 5
	mutex_lock(&dev->mode_config.mutex);

	/* TODO check buffer is sufficiently large */
	/* TODO setup destructor callback */

d2511 1
a2511 2
		ret = PTR_ERR(fb);
		goto out;
d2514 1
d2518 1
a2519 2
out:
	mutex_unlock(&dev->mode_config.mutex);
d2590 2
d2602 2
a2603 1
		DRM_DEBUG_KMS("bad framebuffer format 0x%08x\n", r->pixel_format);
d2648 3
a2650 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2689 2
	mutex_lock(&dev->mode_config.mutex);

d2693 1
a2693 2
		ret = PTR_ERR(fb);
		goto out;
d2696 1
d2700 2
a2702 2
out:
	mutex_unlock(&dev->mode_config.mutex);
d2708 3
a2710 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2721 1
	struct drm_mode_object *obj;
a2724 1
	int ret = 0;
d2730 5
a2734 8
	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, *id, DRM_MODE_OBJECT_FB);
	/* TODO check that we really get a framebuffer back. */
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	fb = obj_to_fb(obj);
d2739 5
d2745 3
a2747 4
	if (!found) {
		ret = -EINVAL;
		goto out;
	}
d2751 7
a2757 3
out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
d2762 3
a2764 7
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * LOCKING:
 * Takes mode config lock.
a2776 34
	struct drm_mode_object *obj;
	struct drm_framebuffer *fb;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;

	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	fb = obj_to_fb(obj);

	r->height = fb->height;
	r->width = fb->width;
	r->depth = fb->depth;
	r->bpp = fb->bits_per_pixel;
	r->pitch = fb->pitches[0];
	fb->funcs->create_handle(fb, file_priv, &r->handle);

out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}

int drm_mode_dirtyfb_ioctl(struct drm_device *dev,
			   void *data, struct drm_file *file_priv)
{
	struct drm_clip_rect __user *clips_ptr;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = data;
	struct drm_mode_object *obj;
a2777 2
	unsigned flags;
	int num_clips;
d2783 3
a2785 144
	mutex_lock(&dev->mode_config.mutex);
	obj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj) {
		ret = -EINVAL;
		goto out_err1;
	}
	fb = obj_to_fb(obj);

	num_clips = r->num_clips;
	clips_ptr = (struct drm_clip_rect __user *)(unsigned long)r->clips_ptr;

	if (!num_clips != !clips_ptr) {
		ret = -EINVAL;
		goto out_err1;
	}

	flags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;

	/* If userspace annotates copy, clips must come in pairs */
	if (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {
		ret = -EINVAL;
		goto out_err1;
	}

	if (num_clips && clips_ptr) {
		if (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {
			ret = -EINVAL;
			goto out_err1;
		}
		clips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);
		if (!clips) {
			ret = -ENOMEM;
			goto out_err1;
		}

		ret = copy_from_user(clips, clips_ptr,
				     num_clips * sizeof(*clips));
		if (ret) {
			ret = -EFAULT;
			goto out_err2;
		}
	}

	if (fb->funcs->dirty) {
		ret = fb->funcs->dirty(fb, file_priv, flags, r->color,
				       clips, num_clips);
	} else {
		ret = -ENOSYS;
		goto out_err2;
	}

out_err2:
	kfree(clips);
out_err1:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
}


/**
 * drm_fb_release - remove and free the FBs on this file
 * @@filp: file * from the ioctl
 *
 * LOCKING:
 * Takes mode config lock.
 *
 * Destroy all the FBs associated with @@filp.
 *
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
void drm_fb_release(struct drm_device *dev, struct drm_file *priv)
{
	struct drm_framebuffer *fb, *tfb;

	mutex_lock(&dev->mode_config.mutex);
	list_for_each_entry_safe(fb, tfb, &priv->fbs, filp_head) {
		drm_framebuffer_remove(fb);
	}
	mutex_unlock(&dev->mode_config.mutex);
}

/**
 * drm_mode_attachmode - add a mode to the user mode list
 * @@dev: DRM device
 * @@connector: connector to add the mode to
 * @@mode: mode to add
 *
 * Add @@mode to @@connector's user mode list.
 */
static void drm_mode_attachmode(struct drm_device *dev,
				struct drm_connector *connector,
				struct drm_display_mode *mode)
{
	list_add_tail(&mode->head, &connector->user_modes);
}

int drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
			     const struct drm_display_mode *mode)
{
	struct drm_connector *connector;
	int ret = 0;
	struct drm_display_mode *dup_mode, *next;
	DRM_LIST_HEAD(list);

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder)
			continue;
		if (connector->encoder->crtc == crtc) {
			dup_mode = drm_mode_duplicate(dev, mode);
			if (!dup_mode) {
				ret = -ENOMEM;
				goto out;
			}
			list_add_tail(&dup_mode->head, &list);
		}
	}

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder)
			continue;
		if (connector->encoder->crtc == crtc)
			list_move_tail(list.next, &connector->user_modes);
	}

//	WARN_ON(!list_empty(&list));

 out:
	list_for_each_entry_safe(dup_mode, next, &list, head)
		drm_mode_destroy(dev, dup_mode);

	return ret;
}
EXPORT_SYMBOL(drm_mode_attachmode_crtc);

static int drm_mode_detachmode(struct drm_device *dev,
			       struct drm_connector *connector,
			       struct drm_display_mode *mode)
{
	int found = 0;
	int ret = 0;
	struct drm_display_mode *match_mode, *t;
d2787 17
a2803 6
	list_for_each_entry_safe(match_mode, t, &connector->user_modes, head) {
		if (drm_mode_equal(match_mode, mode)) {
			list_del(&match_mode->head);
			drm_mode_destroy(dev, match_mode);
			found = 1;
			break;
d2805 2
d2809 1
a2809 2
	if (!found)
		ret = -EINVAL;
d2814 2
a2815 1
int drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
d2817 6
a2822 30
	struct drm_connector *connector;

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		drm_mode_detachmode(dev, connector, mode);
	}
	return 0;
}
EXPORT_SYMBOL(drm_mode_detachmode_crtc);

/**
 * drm_fb_attachmode - Attach a user mode to an connector
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
 *
 * This attaches a user specified mode to an connector.
 * Called by the user via ioctl.
 *
 * RETURNS:
 * Zero on success, errno on failure.
 */
int drm_mode_attachmode_ioctl(struct drm_device *dev,
			      void *data, struct drm_file *file_priv)
{
	struct drm_mode_mode_cmd *mode_cmd = data;
	struct drm_connector *connector;
	struct drm_display_mode *mode;
	struct drm_mode_object *obj;
	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
d2828 13
a2840 1
	mutex_lock(&dev->mode_config.mutex);
d2842 2
a2843 2
	obj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
d2845 1
a2845 1
		goto out;
a2846 1
	connector = obj_to_connector(obj);
d2848 17
a2864 4
	mode = drm_mode_create(dev);
	if (!mode) {
		ret = -ENOMEM;
		goto out;
d2867 5
a2871 5
	ret = drm_crtc_convert_umode(mode, umode);
	if (ret) {
		DRM_DEBUG_KMS("Invalid mode\n");
		drm_mode_destroy(dev, mode);
		goto out;
d2874 5
a2878 3
	drm_mode_attachmode(dev, connector, mode);
out:
	mutex_unlock(&dev->mode_config.mutex);
d2884 4
a2887 5
 * drm_fb_detachmode - Detach a user specified mode from an connector
 * @@inode: inode from the ioctl
 * @@filp: file * from the ioctl
 * @@cmd: cmd from ioctl
 * @@arg: arg from ioctl
d2894 1
a2894 2
int drm_mode_detachmode_ioctl(struct drm_device *dev,
			      void *data, struct drm_file *file_priv)
d2896 1
a2896 6
	struct drm_mode_object *obj;
	struct drm_mode_mode_cmd *mode_cmd = data;
	struct drm_connector *connector;
	struct drm_display_mode mode;
	struct drm_mode_modeinfo *umode = &mode_cmd->mode;
	int ret;
d2898 2
a2899 2
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -EINVAL;
d2901 4
a2904 1
	mutex_lock(&dev->mode_config.mutex);
d2906 1
a2906 6
	obj = drm_mode_object_find(dev, mode_cmd->connector_id, DRM_MODE_OBJECT_CONNECTOR);
	if (!obj) {
		ret = -EINVAL;
		goto out;
	}
	connector = obj_to_connector(obj);
d2908 2
a2909 4
	ret = drm_crtc_convert_umode(&mode, umode);
	if (ret) {
		DRM_DEBUG_KMS("Invalid mode\n");
		goto out;
d2911 1
a2911 5

	ret = drm_mode_detachmode(dev, connector, &mode);
out:
	mutex_unlock(&dev->mode_config.mutex);
	return ret;
d3156 1
a3156 1
	mutex_lock(&dev->mode_config.mutex);
d3159 1
a3159 1
		ret = -EINVAL;
d3234 1
a3234 1
	mutex_unlock(&dev->mode_config.mutex);
d3285 1
a3285 1
	mutex_lock(&dev->mode_config.mutex);
d3288 1
a3288 1
		ret = -EINVAL;
d3303 1
a3303 1
	mutex_unlock(&dev->mode_config.mutex);
d3445 1
a3445 1
	mutex_lock(&dev->mode_config.mutex);
d3449 1
a3449 1
		ret = -EINVAL;
d3482 1
a3482 1
	mutex_unlock(&dev->mode_config.mutex);
d3499 1
a3499 1
	mutex_lock(&dev->mode_config.mutex);
d3502 2
a3503 1
	if (!arg_obj)
d3505 1
d3518 2
a3519 1
	if (!prop_obj)
d3521 1
d3541 1
a3541 1
	mutex_unlock(&dev->mode_config.mutex);
d3603 1
a3603 1
	mutex_lock(&dev->mode_config.mutex);
d3606 1
a3606 1
		ret = -EINVAL;
d3644 1
a3644 1
	mutex_unlock(&dev->mode_config.mutex);
d3662 1
a3662 1
	mutex_lock(&dev->mode_config.mutex);
d3665 1
a3665 1
		ret = -EINVAL;
d3695 1
a3695 1
	mutex_unlock(&dev->mode_config.mutex);
d3705 1
a3705 1
	struct drm_framebuffer *fb;
a3707 1
	int hdisplay, vdisplay;
d3714 1
a3714 2
	/* XXX always reject async until we have a newer drm version */
	if (page_flip->flags & DRM_MODE_PAGE_FLIP_ASYNC)
a3716 1
	mutex_lock(&dev->mode_config.mutex);
d3719 1
a3719 1
		goto out;
d3722 1
d3735 3
a3737 2
	obj = drm_mode_object_find(dev, page_flip->fb_id, DRM_MODE_OBJECT_FB);
	if (!obj)
d3739 1
a3739 1
	fb = obj_to_fb(obj);
d3741 3
a3743 2
	hdisplay = crtc->mode.hdisplay;
	vdisplay = crtc->mode.vdisplay;
d3745 3
a3747 14
	if (crtc->invert_dimensions) {
		int tmp = hdisplay;
		hdisplay = vdisplay;
		vdisplay = tmp;
	}

	if (hdisplay > fb->width ||
	    vdisplay > fb->height ||
	    crtc->x > fb->width - hdisplay ||
	    crtc->y > fb->height - vdisplay) {
		DRM_DEBUG_KMS("Invalid fb size %ux%u for CRTC viewport %ux%u+%d+%d%s.\n",
			      fb->width, fb->height, hdisplay, vdisplay, crtc->x, crtc->y,
			      crtc->invert_dimensions ? " (inverted)" : "");
		ret = -ENOSPC;
d3778 2
a3779 1
	ret = crtc->funcs->page_flip(crtc, fb, e);
d3787 12
d3802 6
a3807 1
	mutex_unlock(&dev->mode_config.mutex);
d3928 2
a3929 1
		DRM_DEBUG_KMS("unsupported pixel format\n");
d4077 118
@


1.16
log
@Add an empty drm_sysfs_hotplug_event() function and use it
and the existing drm_sysfs* functions to remove some ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.15 2015/04/06 08:14:00 kettenis Exp $	*/
d291 1
a291 1
		return NULL;
@


1.15
log
@Add get_user() and put_user() compatibility interfaces and use them.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.14 2015/04/05 13:04:41 kettenis Exp $	*/
a628 1
#ifdef __linux__
a633 1
#endif
@


1.14
log
@Consistently use #if 0/#endif to handle our lack of DRM_MINOR_CONTROL.
Change an #ifdef notyet into #ifdef __linux__ as we'll never have sysfs.
Remove #ifdef notyet around WARN macro since we have it now.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.13 2015/04/05 11:53:53 kettenis Exp $	*/
d1298 1
a1298 2
			if (copyout(&fb->base.id, fb_id + copied,
			    sizeof(fb->base.id)) != 0) {
d1317 1
a1317 2
				if (copyout(&crtc->base.id, crtc_id + copied,
				    sizeof(crtc->base.id)) != 0) {
d1326 2
a1327 3
				if (copyout(&mode_group->id_list[i],
				    crtc_id + copied,
				    sizeof(mode_group->id_list[i])) != 0) {
d1350 2
a1351 2
				if (copyout(&encoder->base.id, encoder_id +
				    copied, sizeof(encoder->base.id)) != 0) {
d1360 2
a1361 3
				if (copyout(&mode_group->id_list[i],
				    encoder_id + copied,
				    sizeof(mode_group->id_list[i])) != 0) {
d1386 2
a1387 3
				if (copyout(&connector->base.id,
				    connector_id + copied,
				    sizeof(connector->base.id)) != 0) {
d1398 2
a1399 3
				if (copyout(&mode_group->id_list[i],
				    connector_id + copied,
				    sizeof(mode_grou->id_list[i])) != 0) {
d1585 2
a1586 3
			if (copyout(&connector->properties.ids[i],
			    prop_ptr + copied,
			    sizeof(connector->properties.ids[i])) != 0) {
d1591 2
a1592 3
			if (copyout(&connector->properties.values[i],
			    prop_values + copied,
			    sizeof(connector->properties.values[i])) != 0) {
d1606 2
a1607 3
				if (copyout(&connector->encoder_ids[i],
				    encoder_ptr + copied,
				    sizeof(connector->encoder_ids[i])) != 0) {
d1691 1
a1691 2
			if (copyout(&plane->base.id, plane_ptr + copied,
			    sizeof(plane->base.id))) {
d2045 1
a2045 2
			if (copyin(&set_connectors_ptr[i], &out_id,
			    sizeof(out_id)) != 0) {
d3109 1
a3109 3
				if (copyout(&prop_blob->base.id,
				    blob_id_ptr + copied,
				    sizeof(prop_blob->base.id)) != 0) {
d3114 1
a3114 3
				if (copyout(&prop_blob->length,
				    blob_length_ptr + copied,
				    sizeof(prop_blob->length)) != 0) {
d3358 2
a3359 3
			if (copyout(&obj->properties->ids[i],
			    props_ptr + copied,
			    sizeof(obj->properties->ids[i])) != 0) {
d3363 2
a3364 3
			if (copyout(&obj->properties->values[i],
			    prop_values_ptr + copied,
			    sizeof(obj->properties->values[i])) != 0) {
@


1.13
log
@Another round of reducing diffs with Linux.  This one moves the various
copy_to_user and copy_from_user functions into drm_linux.h and uses them
instead of copyin/copyout and DRM_COPY_*.  Also move the timespec functions,
and put i915_gem_object_is_purgable() where it belongs.

Uncovered a bug where the arguments to copyout() were in the wrong order.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.12 2015/02/12 02:12:02 kettenis Exp $	*/
d629 1
a629 1
#ifdef notyet
a695 1

a1143 1
#ifdef notyet
a1149 1
#endif
d1312 3
a1314 1
		/* if (file_priv->master->minor->type == DRM_MINOR_CONTROL) { */
d1325 2
a1326 1
		/* } else {
d1336 2
a1337 1
		} */
@


1.12
log
@Add mutex_is_locked and use it wherever linux uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.11 2015/02/11 07:01:36 jsg Exp $	*/
d1575 2
a1576 2
			if (copyout(&u_mode, mode_ptr + copied,
			    sizeof(u_mode)) != 0) {
d1768 3
a1770 3
		if (copyout(format_ptr,
		    plane->format_types,
		    sizeof(uint32_t) * plane->format_count)) {
d2578 2
a2579 3
		ret = copyin(clips_ptr, clips,
		    num_clips * sizeof(*clips));

d3082 1
a3082 1
			if (copyout(&property->values[i], values_ptr + i, sizeof(uint64_t)) != 0) {
d3096 1
a3096 3
				if (copyout(&prop_enum->value,
				    &enum_ptr[copied].value,
				    sizeof(uint64_t)) != 0) {
d3101 2
a3102 3
				if (copyout(&prop_enum->name,
				    &enum_ptr[copied].name,
				    DRM_PROP_NAME_LEN) != 0) {
d3200 1
a3200 1
		if (copyout(blob->data, blob_ptr, blob->length) != 0) {
d3527 1
a3527 2
	if (copyin((void __user *)(unsigned long)crtc_lut->red,
	    r_base, size) != 0) {
d3533 1
a3533 2
	if (copyin((void __user *)(unsigned long)crtc_lut->green,
	    g_base, size) != 0) {
d3539 1
a3539 2
	if (copyin((void __user *)(unsigned long)crtc_lut->blue,
	    b_base, size) != 0) {
d3581 1
a3581 2
	if (copyout(r_base,
	    (void __user *)(unsigned long)crtc_lut->red, size) != 0) {
d3587 1
a3587 2
	if (copyout(g_base,
	    (void __user *)(unsigned long)crtc_lut->green, size) != 0) {
d3593 1
a3593 2
	if (copyout(b_base,
	    (void __user *)(unsigned long)crtc_lut->blue, size) != 0) {
@


1.11
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.10 2015/02/10 10:50:49 jsg Exp $	*/
d345 1
a345 1
//	struct drm_device *dev = fb->dev;
a346 1
#ifdef notyet
a347 1
#endif
@


1.10
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.9 2015/02/10 03:39:41 jsg Exp $	*/
d2994 1
a2994 1
		printf("Failed to attach object property (type: 0x%x). Please "
@


1.9
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.8 2014/03/09 11:07:18 jsg Exp $	*/
d3622 1
d3679 1
a3679 1
		mtx_enter(&dev->event_lock);
d3681 1
a3681 1
			mtx_leave(&dev->event_lock);
d3685 1
a3685 1
		mtx_leave(&dev->event_lock);
d3689 1
a3689 1
			mtx_enter(&dev->event_lock);
d3691 1
a3691 1
			mtx_leave(&dev->event_lock);
d3707 1
a3707 1
			mtx_enter(&dev->event_lock);
d3709 1
a3709 1
			mtx_leave(&dev->event_lock);
@


1.8
log
@use linux style memory allocations in shared drm code
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.7 2014/02/13 12:33:08 kettenis Exp $	*/
d463 1
a463 1
	rw_enter_write(&dev->mode_config.rwl);
d475 1
a475 1
	rw_exit_write(&dev->mode_config.rwl);
d562 1
a562 1
	rw_enter_write(&dev->mode_config.rwl);
d592 1
a592 1
	rw_exit_write(&dev->mode_config.rwl);
d621 1
a621 1
	rw_enter_write(&dev->mode_config.rwl);
d625 1
a625 1
	rw_exit_write(&dev->mode_config.rwl);
d648 1
a648 1
	rw_enter_write(&dev->mode_config.rwl);
d662 1
a662 1
	rw_exit_write(&dev->mode_config.rwl);
d671 1
a671 1
	rw_enter_write(&dev->mode_config.rwl);
d675 1
a675 1
	rw_exit_write(&dev->mode_config.rwl);
d687 1
a687 1
	rw_enter_write(&dev->mode_config.rwl);
d722 1
a722 1
	rw_exit_write(&dev->mode_config.rwl);
d732 1
a732 1
	rw_enter_write(&dev->mode_config.rwl);
d740 1
a740 1
	rw_exit_write(&dev->mode_config.rwl);
d1013 1
a1013 1
	rw_init(&dev->mode_config.rwl, "mcrwl");
d1024 1
a1024 1
	rw_enter_write(&dev->mode_config.rwl);
d1026 1
a1026 1
	rw_exit_write(&dev->mode_config.rwl);
d1261 1
a1261 1
	rw_enter_write(&dev->mode_config.rwl);
d1421 1
a1421 1
	rw_exit_write(&dev->mode_config.rwl);
d1453 1
a1453 1
	rw_enter_write(&dev->mode_config.rwl);
d1481 1
a1481 1
	rw_exit_write(&dev->mode_config.rwl);
d1528 1
a1528 1
	rw_enter_write(&dev->mode_config.rwl);
d1628 1
a1628 1
	rw_exit_write(&dev->mode_config.rwl);
d1643 1
a1643 1
	rw_enter_write(&dev->mode_config.rwl);
d1662 1
a1662 1
	rw_exit_write(&dev->mode_config.rwl);
d1689 1
a1689 1
	rw_enter_write(&dev->mode_config.rwl);
d1712 1
a1712 1
	rw_exit_write(&dev->mode_config.rwl);
d1740 1
a1740 1
	rw_enter_write(&dev->mode_config.rwl);
d1780 1
a1780 1
	rw_exit_write(&dev->mode_config.rwl);
d1811 1
a1811 1
	rw_enter_write(&dev->mode_config.rwl);
d1910 1
a1910 1
	rw_exit_write(&dev->mode_config.rwl);
d1954 1
a1954 1
	rw_enter_write(&dev->mode_config.rwl);
d2091 1
a2091 1
	rw_exit_write(&dev->mode_config.rwl);
d2109 1
a2109 1
	rw_enter_write(&dev->mode_config.rwl);
d2137 1
a2137 1
	rw_exit_write(&dev->mode_config.rwl);
d2220 1
a2220 1
	rw_enter_write(&dev->mode_config.rwl);
d2237 1
a2237 1
	rw_exit_write(&dev->mode_config.rwl);
d2409 1
a2409 1
	rw_enter_write(&dev->mode_config.rwl);
d2423 1
a2423 1
	rw_exit_write(&dev->mode_config.rwl);
d2457 1
a2457 1
	rw_enter_write(&dev->mode_config.rwl);
d2478 1
a2478 1
	rw_exit_write(&dev->mode_config.rwl);
d2510 1
a2510 1
	rw_enter_write(&dev->mode_config.rwl);
d2526 1
a2526 1
	rw_exit_write(&dev->mode_config.rwl);
d2545 1
a2545 1
	rw_enter_write(&dev->mode_config.rwl);
d2600 1
a2600 1
	rw_exit_write(&dev->mode_config.rwl);
d2623 1
a2623 1
	rw_enter_write(&dev->mode_config.rwl);
d2627 1
a2627 1
	rw_exit_write(&dev->mode_config.rwl);
d2743 1
a2743 1
	rw_enter_write(&dev->mode_config.rwl);
d2767 1
a2767 1
	rw_exit_write(&dev->mode_config.rwl);
d2797 1
a2797 1
	rw_enter_write(&dev->mode_config.rwl);
d2814 1
a2814 1
	rw_exit_write(&dev->mode_config.rwl);
d3060 1
a3060 1
	rw_enter_write(&dev->mode_config.rwl);
d3145 1
a3145 1
	rw_exit_write(&dev->mode_config.rwl);
d3196 1
a3196 1
	rw_enter_write(&dev->mode_config.rwl);
d3214 1
a3214 1
	rw_exit_write(&dev->mode_config.rwl);
d3356 1
a3356 1
	rw_enter_write(&dev->mode_config.rwl);
d3395 1
a3395 1
	rw_exit_write(&dev->mode_config.rwl);
d3412 1
a3412 1
	rw_enter_write(&dev->mode_config.rwl);
d3450 1
a3450 1
	rw_exit_write(&dev->mode_config.rwl);
d3512 1
a3512 1
	rw_enter_write(&dev->mode_config.rwl);
d3556 1
a3556 1
	rw_exit_write(&dev->mode_config.rwl);
d3574 1
a3574 1
	rw_enter_write(&dev->mode_config.rwl);
d3610 1
a3610 1
	rw_exit_write(&dev->mode_config.rwl);
d3633 1
a3633 1
	rw_enter_write(&dev->mode_config.rwl);
d3714 1
a3714 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.7
log
@Make sure we copy out the right amount of data in the various copyout() calls
that replace the put_user() calls in the Linux code by using sizeof on the
appropriate variables instead of explicit uint32_t/uint64_t types.  Fixes a
case where we accidentally copied out only 32 bits of a 64-bit value,
uncovered by xf86-video-intel 2.99.909.

ok jsg@@, matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.6 2014/01/18 08:25:06 jsg Exp $	*/
d495 2
a496 4
	if (crtc->gamma_store) {
		free(crtc->gamma_store, M_DRM);
		crtc->gamma_store = NULL;
	}
d696 2
a697 2
	plane->format_types = malloc(sizeof(uint32_t) * format_count,
	    M_DRM, M_WAITOK);
d733 1
a733 1
	free(plane->format_types, M_DRM);
d760 1
a760 1
	nmode = malloc(sizeof(struct drm_display_mode), M_DRM, M_WAITOK|M_ZERO);
d765 1
a765 1
		free(nmode, M_DRM);
d790 1
a790 1
	free(mode, M_DRM);
d1044 1
a1044 2
	group->id_list = malloc(total_objects * sizeof(uint32_t),
	    M_DRM, M_WAITOK|M_ZERO);
d2046 1
a2046 1
		connector_set = malloc(crtc_req->count_connectors *
d2048 1
a2048 1
		    M_DRM, M_WAITOK);
d2089 1
a2089 2
	if (connector_set != NULL)
		free(connector_set, M_DRM);
d2574 1
a2574 2
		clips = malloc(num_clips * sizeof(*clips), M_DRM,
		    M_WAITOK|M_ZERO);
d2598 1
a2598 1
	free(clips, M_DRM);
d2824 1
a2824 1
	property = malloc(sizeof(struct drm_property), M_DRM, M_WAITOK|M_ZERO);
d2829 1
a2829 2
		property->values = malloc(sizeof(uint64_t)*num_values,
		    M_DRM, M_WAITOK|M_ZERO);
d2850 2
a2851 2
	free(property->values, M_DRM);
	free(property, M_DRM);
d2956 1
a2956 2
	prop_enum = malloc(sizeof(struct drm_property_enum), M_DRM,
	    M_WAITOK | M_ZERO);
d2976 1
a2976 1
		free(prop_enum, M_DRM);
d2980 1
a2980 1
		free(property->values, M_DRM);
d2983 1
a2983 1
	free(property, M_DRM);
d3158 1
a3158 2
	blob = malloc(sizeof(struct drm_property_blob)+length,
	    M_DRM, M_WAITOK|M_ZERO);
d3164 1
a3164 1
		free(blob, M_DRM);
d3181 1
a3181 1
	free(blob, M_DRM);
d3489 1
a3489 2
	crtc->gamma_store = malloc(gamma_size * sizeof(uint16_t) * 3,
	    M_DRM, M_WAITOK|M_ZERO);
d3686 1
a3686 1
		e = malloc(sizeof *e, M_DRM, M_WAITOK|M_ZERO);
d3700 1
a3700 1
			(void (*) (struct drm_pending_event *)) drm_free;
d3709 1
a3709 1
			free(e, M_DRM);
@


1.6
log
@Update the drm headers based on libdrm 2.4.51
but make sure we still reject DRM_MODE_PAGE_FLIP_ASYNC.

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.5 2013/12/16 19:57:08 kettenis Exp $	*/
d1367 3
a1369 2
				if (copyout(&mode_group->id_list[i]
				    encoder_id + copied, sizeof(uint32_t)) != 0) {
d1409 1
a1409 1
				    sizeof(uint32_t)) != 0) {
d1597 1
a1597 1
			    sizeof(uint32_t)) != 0) {
d1604 1
a1604 1
			    sizeof(uint32_t)) != 0) {
d1705 1
a1705 1
			    sizeof(uint32_t))) {
@


1.5
log
@Switch generic drm modesetting code over to Linux-style negative errno
return values.  Fixes at least one bug where userland would see a negative
errno value and hopefully doesn't introduce any new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.4 2013/12/15 22:09:37 kettenis Exp $	*/
d3635 4
@


1.4
log
@Fix error handling of ->fb_create() call.  Prevents kernel panic if an
unsupported frame buffer configuration is requested.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.3 2013/09/02 10:18:26 jsg Exp $	*/
d234 1
a234 1
		return ENOMEM;
d704 1
a704 1
		ret = ENOMEM;
d1049 1
a1049 1
		return ENOMEM;
d1195 1
a1195 1
		return ERANGE;
d1262 1
a1262 1
		return EINVAL;
d1308 1
a1308 1
				ret = EFAULT;
d1326 1
a1326 1
					ret = EFAULT;
d1336 1
a1336 1
					ret = EFAULT;
d1359 1
a1359 1
					ret = EFAULT;
d1369 1
a1369 1
					ret = EFAULT;
d1396 1
a1396 1
					ret = EFAULT;
d1409 1
a1409 1
					ret = EFAULT;
d1453 1
a1453 1
		return EINVAL;
d1460 1
a1460 1
		ret = EINVAL;
d1524 1
a1524 1
		return EINVAL;
d1535 1
a1535 1
		ret = EINVAL;
d1581 1
a1581 1
				ret = EFAULT;
d1597 1
a1597 1
				ret = EFAULT;
d1604 1
a1604 1
				ret = EFAULT;
d1620 1
a1620 1
					ret = EFAULT;
d1643 1
a1643 1
		return EINVAL;
d1649 1
a1649 1
		ret = EINVAL;
d1689 1
a1689 1
		return EINVAL;
d1705 1
a1705 1
				ret = EFAULT;
d1740 1
a1740 1
		return EINVAL;
d1746 1
a1746 1
		ret = ENOENT;
d1775 1
a1775 1
			ret = EFAULT;
d1811 1
a1811 1
		return EINVAL;
d1824 1
a1824 1
		ret = ENOENT;
d1842 1
a1842 1
		ret = ENOENT;
d1852 1
a1852 1
		ret = ENOENT;
d1863 1
a1863 1
		ret = EINVAL;
d1885 1
a1885 1
		ret = ENOSPC;
d1897 1
a1897 1
		ret = ERANGE;
d1950 1
a1950 1
		return EINVAL;
d1954 1
a1954 1
		return ERANGE;
d1961 1
a1961 1
		ret = EINVAL;
d1974 1
a1974 1
				ret = EINVAL;
d1984 1
a1984 1
				ret = EINVAL;
d1992 1
a1992 1
			ret = ENOMEM;
d2021 1
a2021 1
			ret = ENOSPC;
d2028 1
a2028 1
		ret = EINVAL;
d2035 1
a2035 1
		ret = EINVAL;
d2044 1
a2044 1
			ret = EINVAL;
d2052 1
a2052 1
			ret = ENOMEM;
d2060 1
a2060 1
				ret = EFAULT;
d2069 1
a2069 1
				ret = EINVAL;
d2107 1
a2107 1
		return EINVAL;
d2110 1
a2110 1
		return EINVAL;
d2116 1
a2116 1
		ret = EINVAL;
d2123 1
a2123 1
			ret = ENXIO;
d2135 1
a2135 1
			ret = EFAULT;
d2215 1
a2215 1
		return EINVAL;
d2218 1
a2218 1
		return EINVAL;
d2221 1
a2221 1
		return EINVAL;
d2231 1
a2231 1
		ret = -PTR_ERR(fb);
d2311 1
a2311 1
		return EINVAL;
d2331 1
a2331 1
		return EINVAL;
d2336 1
a2336 1
		return EINVAL;
d2346 1
a2346 1
			return EINVAL;
d2350 1
a2350 1
			return ERANGE;
d2353 1
a2353 1
			return ERANGE;
d2357 1
a2357 1
			return EINVAL;
d2390 1
a2390 1
		return EINVAL;
d2394 1
a2394 1
		return EINVAL;
d2400 1
a2400 1
		return EINVAL;
d2405 1
a2405 1
		return EINVAL;
d2417 1
a2417 1
		ret = -PTR_ERR(fb);
d2458 1
a2458 1
		return EINVAL;
d2464 1
a2464 1
		ret = EINVAL;
d2474 1
a2474 1
		ret = EINVAL;
d2511 1
a2511 1
		return EINVAL;
d2516 1
a2516 1
		ret = EINVAL;
d2546 1
a2546 1
		return EINVAL;
d2551 1
a2551 1
		ret = EINVAL;
d2560 1
a2560 1
		ret = EINVAL;
d2568 1
a2568 1
		ret = EINVAL;
d2574 1
a2574 1
			ret = EINVAL;
d2580 1
a2580 1
			ret = ENOMEM;
d2588 1
a2588 1
			ret = EFAULT;
d2597 1
a2597 1
		ret = ENOSYS;
d2663 1
a2663 1
				ret = ENOMEM;
d2705 1
a2705 1
		ret = EINVAL;
d2745 1
a2745 1
		return EINVAL;
d2751 1
a2751 1
		ret = EINVAL;
d2758 1
a2758 1
		ret = ENOMEM;
d2799 1
a2799 1
		return EINVAL;
d2805 1
a2805 1
		ret = EINVAL;
d2942 1
a2942 1
		return EINVAL;
d2949 1
a2949 1
		return EINVAL;
d2964 1
a2964 1
		return ENOMEM;
d3025 1
a3025 1
	return EINVAL;
d3041 1
a3041 1
	return EINVAL;
d3064 1
a3064 1
		return EINVAL;
d3069 1
a3069 1
		ret = EINVAL;
d3092 1
a3092 1
				ret = EFAULT;
d3108 1
a3108 1
					ret = EFAULT;
d3115 1
a3115 1
					ret = EFAULT;
d3134 1
a3134 1
					ret = EFAULT;
d3141 1
a3141 1
					ret = EFAULT;
d3201 1
a3201 1
		return EINVAL;
d3206 1
a3206 1
		ret = EINVAL;
d3214 1
a3214 1
			ret = EFAULT;
d3245 1
a3245 1
		return EINVAL;
d3301 1
a3301 1
	int ret = EINVAL;
d3322 1
a3322 1
	int ret = EINVAL;
d3337 1
a3337 1
	int ret = EINVAL;
d3361 1
a3361 1
		return EINVAL;
d3367 1
a3367 1
		ret = EINVAL;
d3371 1
a3371 1
		ret = EINVAL;
d3388 1
a3388 1
				ret = EFAULT;
d3394 1
a3394 1
				ret = EFAULT;
d3413 1
a3413 1
	int ret = EINVAL;
d3417 1
a3417 1
		return EINVAL;
d3472 1
a3472 1
	return ENOMEM;
d3500 1
a3500 1
		return ENOMEM;
d3518 1
a3518 1
		return EINVAL;
d3523 1
a3523 1
		ret = EINVAL;
d3529 1
a3529 1
		ret = ENOSYS;
d3535 1
a3535 1
		ret = EINVAL;
d3543 1
a3543 1
		ret = EFAULT;
d3550 1
a3550 1
		ret = EFAULT;
d3557 1
a3557 1
		ret = EFAULT;
d3580 1
a3580 1
		return EINVAL;
d3585 1
a3585 1
		ret = EINVAL;
d3592 1
a3592 1
		ret = EINVAL;
d3600 1
a3600 1
		ret = EFAULT;
d3607 1
a3607 1
		ret = EFAULT;
d3614 1
a3614 1
		ret = EFAULT;
d3631 1
a3631 1
	int ret = EINVAL;
d3635 1
a3635 1
		return EINVAL;
d3648 1
a3648 1
		ret = EBUSY;
d3676 1
a3676 1
		ret = ENOSPC;
d3681 1
a3681 1
		ret = ENOMEM;
d3751 1
a3751 1
		return ENOSYS;
d3762 1
a3762 1
		return ENOSYS;
d3773 1
a3773 1
		return ENOSYS;
@


1.3
log
@fb refcount must be initialised to 1 not 0 to match the behaviour
of the linux kref functions.

Switch to using the FreeBSD refcount api for the fb refcount while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.2 2013/09/02 06:25:27 jsg Exp $	*/
d2229 1
a2229 1
	if (fb == NULL) {
d2231 1
d2415 1
a2415 1
	if (fb == NULL) {
d2417 1
@


1.2
log
@add static back to functions that originally had it
reduces the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc.c,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
d37 1
d317 1
a317 1
	fb->refcount = 0;
d350 1
a350 1
	if (--fb->refcount == 0)
d361 1
a361 1
	fb->refcount++;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 28
void	 drm_crtc_convert_to_umode(struct drm_mode_modeinfo *,
	     const struct drm_display_mode *);
int	 drm_mode_handle_cmp(struct drm_mode_handle *,
	     struct drm_mode_handle *);
int	 drm_crtc_convert_umode(struct drm_display_mode *,
	     const struct drm_mode_modeinfo *);
int	 drm_mode_object_get(struct drm_device *, struct drm_mode_object *,
	     uint32_t);
void	 drm_mode_object_put(struct drm_device *, struct drm_mode_object *);
int	 drm_mode_create_standard_connector_properties(struct drm_device *);
void	 drm_mode_attachmode(struct drm_device *, struct drm_connector *,
	     struct drm_display_mode *);
int	 drm_mode_detachmode(struct drm_device *, struct drm_connector *,
	     struct drm_display_mode *);
struct drm_property_blob	*drm_property_create_blob(struct drm_device *,
				     int, void *);
void	 drm_property_destroy_blob(struct drm_device *,
	     struct drm_property_blob *);
int	 format_check(const struct drm_mode_fb_cmd2 *);
int	 framebuffer_check(const struct drm_mode_fb_cmd2 *);
bool	 drm_property_change_is_valid(struct drm_property *, uint64_t);
int	 drm_mode_connector_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
int	 drm_mode_crtc_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
int	 drm_mode_plane_set_obj_prop(struct drm_mode_object *,
	     struct drm_property *, uint64_t);
void	 drm_framebuffer_free(struct drm_framebuffer *);
d226 1
a226 2
int
drm_mode_object_get(struct drm_device *dev,
d262 1
a262 2
void
drm_mode_object_put(struct drm_device *dev,
d274 1
a274 2
struct drm_mode_object *
drm_mode_object_find(struct drm_device *dev,
d311 1
a311 2
int
drm_framebuffer_init(struct drm_device *dev, struct drm_framebuffer *fb,
d331 1
a331 2
void
drm_framebuffer_free(struct drm_framebuffer *fb)
d342 1
a342 2
void
drm_framebuffer_unreference(struct drm_framebuffer *fb)
d357 1
a357 2
void
drm_framebuffer_reference(struct drm_framebuffer *fb)
d374 1
a374 2
void
drm_framebuffer_cleanup(struct drm_framebuffer *fb)
d400 1
a400 2
void
drm_framebuffer_remove(struct drm_framebuffer *fb)
d453 1
a453 2
int
drm_crtc_init(struct drm_device *dev, struct drm_crtc *crtc,
d490 1
a490 2
void
drm_crtc_cleanup(struct drm_crtc *crtc)
d515 1
a515 2
void
drm_mode_probed_add(struct drm_connector *connector,
d532 1
a532 2
void
drm_mode_remove(struct drm_connector *connector,
d556 1
a556 2
int
drm_connector_init(struct drm_device *dev,
d608 1
a608 2
void
drm_connector_cleanup(struct drm_connector *connector)
d630 1
a630 2
void
drm_connector_unplug_all(struct drm_device *dev)
d642 1
a642 2
int
drm_encoder_init(struct drm_device *dev,
d669 1
a669 2
void
drm_encoder_cleanup(struct drm_encoder *encoder)
d680 1
a680 2
int
drm_plane_init(struct drm_device *dev, struct drm_plane *plane,
d729 1
a729 2
void
drm_plane_cleanup(struct drm_plane *plane)
d757 1
a757 2
struct drm_display_mode *
drm_mode_create(struct drm_device *dev)
d784 1
a784 2
void
drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode)
d795 1
a795 2
int
drm_mode_create_standard_connector_properties(struct drm_device *dev)
d822 1
a822 2
int
drm_mode_create_dvi_i_properties(struct drm_device *dev)
d858 1
a858 2
int
drm_mode_create_tv_properties(struct drm_device *dev, int num_modes,
d935 1
a935 2
int
drm_mode_create_scaling_mode_property(struct drm_device *dev)
d960 1
a960 2
int
drm_mode_create_dithering_property(struct drm_device *dev)
d984 1
a984 2
int
drm_mode_create_dirty_info_property(struct drm_device *dev)
d1012 1
a1012 2
void
drm_mode_config_init(struct drm_device *dev)
d1037 1
a1037 2
int
drm_mode_group_init(struct drm_device *dev, struct drm_mode_group *group)
d1056 1
a1056 2
int
drm_mode_group_init_legacy_group(struct drm_device *dev,
d1094 1
a1094 2
void
drm_mode_config_cleanup(struct drm_device *dev)
d1146 1
a1146 2
void
drm_crtc_convert_to_umode(struct drm_mode_modeinfo *out,
d1190 1
a1190 2
int
drm_crtc_convert_umode(struct drm_display_mode *out,
d1234 1
a1234 2
int
drm_mode_getresources(struct drm_device *dev, void *data,
d1443 1
a1443 2
int
drm_mode_getcrtc(struct drm_device *dev,
d1503 1
a1503 2
int
drm_mode_getconnector(struct drm_device *dev, void *data,
d1633 1
a1633 2
int
drm_mode_getencoder(struct drm_device *dev, void *data,
d1678 1
a1678 2
int
drm_mode_getplane_res(struct drm_device *dev, void *data,
d1729 1
a1729 2
int
drm_mode_getplane(struct drm_device *dev, void *data,
d1797 1
a1797 2
int
drm_mode_setplane(struct drm_device *dev, void *data,
d1933 1
a1933 2
int
drm_mode_setcrtc(struct drm_device *dev, void *data,
d2097 1
a2097 2
int
drm_mode_cursor_ioctl(struct drm_device *dev,
d2144 1
a2144 2
uint32_t
drm_mode_legacy_fb_format(uint32_t bpp, uint32_t depth)
d2196 1
a2196 2
int
drm_mode_addfb(struct drm_device *dev,
d2242 1
a2242 2
int
format_check(const struct drm_mode_fb_cmd2 *r)
d2313 1
a2313 2
int
framebuffer_check(const struct drm_mode_fb_cmd2 *r)
d2379 1
a2379 2
int
drm_mode_addfb2(struct drm_device *dev,
d2444 1
a2444 2
int
drm_mode_rmfb(struct drm_device *dev,
d2499 1
a2499 2
int
drm_mode_getfb(struct drm_device *dev,
d2530 1
a2530 2
int
drm_mode_dirtyfb_ioctl(struct drm_device *dev,
d2620 1
a2620 2
void
drm_fb_release(struct drm_device *dev, struct drm_file *priv)
d2639 1
a2639 2
void
drm_mode_attachmode(struct drm_device *dev,
d2646 1
a2646 2
int
drm_mode_attachmode_crtc(struct drm_device *dev, struct drm_crtc *crtc,
d2684 1
a2684 2
int
drm_mode_detachmode(struct drm_device *dev,
d2707 1
a2707 2
int
drm_mode_detachmode_crtc(struct drm_device *dev, struct drm_display_mode *mode)
d2731 1
a2731 2
int
drm_mode_attachmode_ioctl(struct drm_device *dev,
d2785 1
a2785 2
int
drm_mode_detachmode_ioctl(struct drm_device *dev,
d2819 1
a2819 2
struct drm_property *
drm_property_create(struct drm_device *dev, int flags,
d2858 1
a2858 2
struct drm_property *
drm_property_create_enum(struct drm_device *dev, int flags,
d2886 1
a2886 2
struct drm_property *
drm_property_create_bitmask(struct drm_device *dev,
d2914 1
a2914 2
struct drm_property *
drm_property_create_range(struct drm_device *dev, int flags,
d2933 1
a2933 2
int
drm_property_add_enum(struct drm_property *property, int index,
d2973 1
a2973 2
void
drm_property_destroy(struct drm_device *dev, struct drm_property *property)
d2990 1
a2990 2
void
drm_object_attach_property(struct drm_mode_object *obj,
d3010 1
a3010 2
int
drm_object_property_set_value(struct drm_mode_object *obj,
d3026 1
a3026 2
int
drm_object_property_get_value(struct drm_mode_object *obj,
d3042 1
a3042 2
int
drm_mode_getproperty_ioctl(struct drm_device *dev,
d3152 1
a3152 2
struct drm_property_blob *
drm_property_create_blob(struct drm_device *dev, int length,
d3180 1
a3180 2
void
drm_property_destroy_blob(struct drm_device *dev,
d3188 1
a3188 2
int
drm_mode_getblob_ioctl(struct drm_device *dev,
d3222 1
a3222 2
int
drm_mode_connector_update_edid_property(struct drm_connector *connector,
d3252 1
a3252 2
bool
drm_property_change_is_valid(struct drm_property *property,
d3279 1
a3279 2
int
drm_mode_connector_property_set_ioctl(struct drm_device *dev,
d3294 1
a3294 2
int
drm_mode_connector_set_obj_prop(struct drm_mode_object *obj,
d3315 1
a3315 2
int
drm_mode_crtc_set_obj_prop(struct drm_mode_object *obj,
d3330 1
a3330 2
int
drm_mode_plane_set_obj_prop(struct drm_mode_object *obj,
d3345 1
a3345 2
int
drm_mode_obj_get_properties_ioctl(struct drm_device *dev, void *data,
d3403 1
a3403 2
int
drm_mode_obj_set_property_ioctl(struct drm_device *dev, void *data,
d3458 1
a3458 2
int
drm_mode_connector_attach_encoder(struct drm_connector *connector,
d3473 1
a3473 2
void
drm_mode_connector_detach_encoder(struct drm_connector *connector,
d3488 1
a3488 2
int
drm_mode_crtc_set_gamma_size(struct drm_crtc *crtc,
d3504 1
a3504 2
int
drm_mode_gamma_set_ioctl(struct drm_device *dev,
d3566 1
a3566 2
int
drm_mode_gamma_get_ioctl(struct drm_device *dev,
d3619 1
a3619 2
int
drm_mode_page_flip_ioctl(struct drm_device *dev,
d3719 1
a3719 2
void
drm_mode_config_reset(struct drm_device *dev)
d3742 1
a3742 2
int
drm_mode_create_dumb_ioctl(struct drm_device *dev,
d3752 1
a3752 2
int
drm_mode_mmap_dumb_ioctl(struct drm_device *dev,
d3764 1
a3764 2
int
drm_mode_destroy_dumb_ioctl(struct drm_device *dev,
d3779 1
a3779 2
void
drm_fb_get_bpp_depth(uint32_t format, unsigned int *depth,
d3851 1
a3851 2
int
drm_format_num_planes(uint32_t format)
d3886 1
a3886 2
int
drm_format_plane_cpp(uint32_t format, int plane)
d3933 1
a3933 2
int 
drm_format_horz_chroma_subsampling(uint32_t format)
d3968 1
a3968 2
int
drm_format_vert_chroma_subsampling(uint32_t format)
@

