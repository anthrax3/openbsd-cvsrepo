head	1.69;
access;
symbols
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.67.0.4
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.66.0.6
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.59.0.4
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.2
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.69
date	2017.08.12.19.46.02;	author mpi;	state Exp;
branches;
next	1.68;
commitid	NMOcAVcmXWSmAOO4;

1.68
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.67;
commitid	KnwRPOZok9A30HI4;

1.67
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.66;
commitid	W7ztnDZwvjCaeQTS;

1.66
date	2015.09.26.19.52.16;	author kettenis;	state Exp;
branches;
next	1.65;
commitid	PpEJMvqmELqAFnQv;

1.65
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.64;
commitid	lQlppvmETCN49oZe;

1.64
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.63;
commitid	c1fUeeFWMNg4COgR;

1.63
date	2015.04.15.09.48.19;	author kettenis;	state Exp;
branches;
next	1.62;
commitid	ZmPBAa9xEK5IPEd0;

1.62
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.61;
commitid	uVTyY1h8Sggc8pFj;

1.61
date	2015.04.06.12.25.10;	author jsg;	state Exp;
branches;
next	1.60;
commitid	CN1fAwudhSb2ckyl;

1.60
date	2015.04.05.12.53.41;	author kettenis;	state Exp;
branches;
next	1.59;
commitid	ZNWAu454opxqrbc5;

1.59
date	2015.02.12.08.48.32;	author jsg;	state Exp;
branches;
next	1.58;
commitid	b7XA83Agvw5SEHRi;

1.58
date	2015.02.11.07.01.36;	author jsg;	state Exp;
branches;
next	1.57;
commitid	dLgISW35NAmGN8Xl;

1.57
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.56;
commitid	aHLMSW1RfE1rmMw9;

1.56
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.55;
commitid	a8Vt7gSt34kmziIS;

1.55
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.54;
commitid	jdBY2kKXhfcoQitp;

1.54
date	2014.03.09.11.07.18;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2014.01.24.04.43.56;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2013.09.24.21.18.58;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2013.09.24.21.16.24;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2013.09.02.07.14.22;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2013.09.02.06.25.28;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2013.07.01.06.29.10;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.22.15.10.55;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.42;

1.42
date	2011.02.22.14.16.38;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.18.21.01.06;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.15.19.17.48;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.12.19.47.54;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2009.05.12.19.42.42;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.05.12.19.28.40;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.05.04.15.37;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.04.19.39.07;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.03.13.47.03;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.03.11.31.36;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.30.00.17.12;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.26.07.25.06;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.25.17.43.40;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.25.17.06.03;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.24.04.21.31;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.23.21.35.00;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.23.20.46.47;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.17.00.30.41;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.06.16.06.25;	author dhill;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.06.14.25.21;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.18.15.10.57;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.06.01.32.08;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.02.01.12.04;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.21.21.43.57;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.21.18.23.17;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.13.20.27.58;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.13.19.30.12;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.29.22.23.50;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.29.19.44.13;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.07.16.29.57;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.26.16.42.48;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.19.01.43.25;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.19.00.51.27;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.05.27.19.39.52;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.05.19.34.01;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Provide a stub implementation for request_irq() and free_irq().

Fix Coverity CID 1453484 and reduce diff with Linux.

ok kettenis@@
@
text
@/*
 * drm_irq.c IRQ and vblank support
 *
 * \author Rickard E. (Rik) Faith <faith@@valinux.com>
 * \author Gareth Hughes <gareth@@valinux.com>
 */

/*
 * Created: Fri Mar 19 14:30:16 1999 by faith@@valinux.com
 *
 * Copyright 1999, 2000 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include <dev/pci/drm/drmP.h>
#include "drm_trace.h"
#include "drm_internal.h"

#ifdef __linux__
#include <linux/interrupt.h>	/* For task queue support */
#include <linux/slab.h>

#include <linux/vgaarb.h>
#include <linux/export.h>
#endif

/* Access macro for slots in vblank timestamp ringbuffer. */
#define vblanktimestamp(dev, pipe, count) \
	((dev)->vblank[pipe].time[(count) % DRM_VBLANKTIME_RBSIZE])

/* Retry timestamp calculation up to 3 times to satisfy
 * drm_timestamp_precision before giving up.
 */
#define DRM_TIMESTAMP_MAXRETRIES 3

/* Threshold in nanoseconds for detection of redundant
 * vblank irq in drm_handle_vblank(). 1 msec should be ok.
 */
#define DRM_REDUNDANT_VBLIRQ_THRESH_NS 1000000

static bool
drm_get_last_vbltimestamp(struct drm_device *dev, unsigned int pipe,
			  struct timeval *tvblank, unsigned flags);

static unsigned int drm_timestamp_precision = 20;  /* Default to 20 usecs. */

/*
 * Default to use monotonic timestamps for wait-for-vblank and page-flip
 * complete events.
 */
unsigned int drm_timestamp_monotonic = 1;

static int drm_vblank_offdelay = 5000;    /* Default to 5000 msecs. */

module_param_named(vblankoffdelay, drm_vblank_offdelay, int, 0600);
module_param_named(timestamp_precision_usec, drm_timestamp_precision, int, 0600);
module_param_named(timestamp_monotonic, drm_timestamp_monotonic, int, 0600);

static void store_vblank(struct drm_device *dev, unsigned int pipe,
			 u32 vblank_count_inc,
			 struct timeval *t_vblank, u32 last)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	u32 tslot;

	assert_spin_locked(&dev->vblank_time_lock);

	vblank->last = last;

	/* All writers hold the spinlock, but readers are serialized by
	 * the latching of vblank->count below.
	 */
	tslot = vblank->count + vblank_count_inc;
	vblanktimestamp(dev, pipe, tslot) = *t_vblank;

	/*
	 * vblank timestamp updates are protected on the write side with
	 * vblank_time_lock, but on the read side done locklessly using a
	 * sequence-lock on the vblank counter. Ensure correct ordering using
	 * memory barrriers. We need the barrier both before and also after the
	 * counter update to synchronize with the next timestamp write.
	 * The read-side barriers for this are in drm_vblank_count_and_time.
	 */
	smp_wmb();
	vblank->count += vblank_count_inc;
	smp_wmb();
}

/**
 * drm_reset_vblank_timestamp - reset the last timestamp to the last vblank
 * @@dev: DRM device
 * @@pipe: index of CRTC for which to reset the timestamp
 *
 * Reset the stored timestamp for the current vblank count to correspond
 * to the last vblank occurred.
 *
 * Only to be called from drm_vblank_on().
 *
 * Note: caller must hold dev->vbl_lock since this reads & writes
 * device vblank fields.
 */
static void drm_reset_vblank_timestamp(struct drm_device *dev, unsigned int pipe)
{
	u32 cur_vblank;
	bool rc;
	struct timeval t_vblank;
	int count = DRM_TIMESTAMP_MAXRETRIES;

	spin_lock(&dev->vblank_time_lock);

	/*
	 * sample the current counter to avoid random jumps
	 * when drm_vblank_enable() applies the diff
	 */
	do {
		cur_vblank = dev->driver->get_vblank_counter(dev, pipe);
		rc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, 0);
	} while (cur_vblank != dev->driver->get_vblank_counter(dev, pipe) && --count > 0);

	/*
	 * Only reinitialize corresponding vblank timestamp if high-precision query
	 * available and didn't fail. Otherwise reinitialize delayed at next vblank
	 * interrupt and assign 0 for now, to mark the vblanktimestamp as invalid.
	 */
	if (!rc)
		t_vblank = (struct timeval) {0, 0};

	/*
	 * +1 to make sure user will never see the same
	 * vblank counter value before and after a modeset
	 */
	store_vblank(dev, pipe, 1, &t_vblank, cur_vblank);

	spin_unlock(&dev->vblank_time_lock);
}

/**
 * drm_update_vblank_count - update the master vblank counter
 * @@dev: DRM device
 * @@pipe: counter to update
 *
 * Call back into the driver to update the appropriate vblank counter
 * (specified by @@pipe).  Deal with wraparound, if it occurred, and
 * update the last read value so we can deal with wraparound on the next
 * call if necessary.
 *
 * Only necessary when going from off->on, to account for frames we
 * didn't get an interrupt for.
 *
 * Note: caller must hold dev->vbl_lock since this reads & writes
 * device vblank fields.
 */
static void drm_update_vblank_count(struct drm_device *dev, unsigned int pipe,
				    unsigned long flags)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	u32 cur_vblank, diff;
	bool rc;
	struct timeval t_vblank;
	int count = DRM_TIMESTAMP_MAXRETRIES;
	int framedur_ns = vblank->framedur_ns;

	/*
	 * Interrupts were disabled prior to this call, so deal with counter
	 * wrap if needed.
	 * NOTE!  It's possible we lost a full dev->max_vblank_count + 1 events
	 * here if the register is small or we had vblank interrupts off for
	 * a long time.
	 *
	 * We repeat the hardware vblank counter & timestamp query until
	 * we get consistent results. This to prevent races between gpu
	 * updating its hardware counter while we are retrieving the
	 * corresponding vblank timestamp.
	 */
	do {
		cur_vblank = dev->driver->get_vblank_counter(dev, pipe);
		rc = drm_get_last_vbltimestamp(dev, pipe, &t_vblank, flags);
	} while (cur_vblank != dev->driver->get_vblank_counter(dev, pipe) && --count > 0);

	if (dev->max_vblank_count != 0) {
		/* trust the hw counter when it's around */
		diff = (cur_vblank - vblank->last) & dev->max_vblank_count;
	} else if (rc && framedur_ns) {
		const struct timeval *t_old;
		u64 diff_ns;

		t_old = &vblanktimestamp(dev, pipe, vblank->count);
		diff_ns = timeval_to_ns(&t_vblank) - timeval_to_ns(t_old);

		/*
		 * Figure out how many vblanks we've missed based
		 * on the difference in the timestamps and the
		 * frame/field duration.
		 */
		diff = DIV_ROUND_CLOSEST_ULL(diff_ns, framedur_ns);

		if (diff == 0 && flags & DRM_CALLED_FROM_VBLIRQ)
			DRM_DEBUG_VBL("crtc %u: Redundant vblirq ignored."
				      " diff_ns = %lld, framedur_ns = %d)\n",
				      pipe, (long long) diff_ns, framedur_ns);
	} else {
		/* some kind of default for drivers w/o accurate vbl timestamping */
		diff = (flags & DRM_CALLED_FROM_VBLIRQ) != 0;
	}

	/*
	 * Within a drm_vblank_pre_modeset - drm_vblank_post_modeset
	 * interval? If so then vblank irqs keep running and it will likely
	 * happen that the hardware vblank counter is not trustworthy as it
	 * might reset at some point in that interval and vblank timestamps
	 * are not trustworthy either in that interval. Iow. this can result
	 * in a bogus diff >> 1 which must be avoided as it would cause
	 * random large forward jumps of the software vblank counter.
	 */
	if (diff > 1 && (vblank->inmodeset & 0x2)) {
		DRM_DEBUG_VBL("clamping vblank bump to 1 on crtc %u: diffr=%u"
			      " due to pre-modeset.\n", pipe, diff);
		diff = 1;
	}

	/*
	 * FIMXE: Need to replace this hack with proper seqlocks.
	 *
	 * Restrict the bump of the software vblank counter to a safe maximum
	 * value of +1 whenever there is the possibility that concurrent readers
	 * of vblank timestamps could be active at the moment, as the current
	 * implementation of the timestamp caching and updating is not safe
	 * against concurrent readers for calls to store_vblank() with a bump
	 * of anything but +1. A bump != 1 would very likely return corrupted
	 * timestamps to userspace, because the same slot in the cache could
	 * be concurrently written by store_vblank() and read by one of those
	 * readers without the read-retry logic detecting the collision.
	 *
	 * Concurrent readers can exist when we are called from the
	 * drm_vblank_off() or drm_vblank_on() functions and other non-vblank-
	 * irq callers. However, all those calls to us are happening with the
	 * vbl_lock locked to prevent drm_vblank_get(), so the vblank refcount
	 * can't increase while we are executing. Therefore a zero refcount at
	 * this point is safe for arbitrary counter bumps if we are called
	 * outside vblank irq, a non-zero count is not 100% safe. Unfortunately
	 * we must also accept a refcount of 1, as whenever we are called from
	 * drm_vblank_get() -> drm_vblank_enable() the refcount will be 1 and
	 * we must let that one pass through in order to not lose vblank counts
	 * during vblank irq off - which would completely defeat the whole
	 * point of this routine.
	 *
	 * Whenever we are called from vblank irq, we have to assume concurrent
	 * readers exist or can show up any time during our execution, even if
	 * the refcount is currently zero, as vblank irqs are usually only
	 * enabled due to the presence of readers, and because when we are called
	 * from vblank irq we can't hold the vbl_lock to protect us from sudden
	 * bumps in vblank refcount. Therefore also restrict bumps to +1 when
	 * called from vblank irq.
	 */
	if ((diff > 1) && (atomic_read(&vblank->refcount) > 1 ||
	    (flags & DRM_CALLED_FROM_VBLIRQ))) {
		DRM_DEBUG_VBL("clamping vblank bump to 1 on crtc %u: diffr=%u "
			      "refcount %u, vblirq %u\n", pipe, diff,
			      atomic_read(&vblank->refcount),
			      (flags & DRM_CALLED_FROM_VBLIRQ) != 0);
		diff = 1;
	}

	DRM_DEBUG_VBL("updating vblank count on crtc %u:"
		      " current=%u, diff=%u, hw=%u hw_last=%u\n",
		      pipe, vblank->count, diff, cur_vblank, vblank->last);

	if (diff == 0) {
		WARN_ON_ONCE(cur_vblank != vblank->last);
		return;
	}

	/*
	 * Only reinitialize corresponding vblank timestamp if high-precision query
	 * available and didn't fail, or we were called from the vblank interrupt.
	 * Otherwise reinitialize delayed at next vblank interrupt and assign 0
	 * for now, to mark the vblanktimestamp as invalid.
	 */
	if (!rc && (flags & DRM_CALLED_FROM_VBLIRQ) == 0)
		t_vblank = (struct timeval) {0, 0};

	store_vblank(dev, pipe, diff, &t_vblank, cur_vblank);
}

/*
 * Disable vblank irq's on crtc, make sure that last vblank count
 * of hardware and corresponding consistent software vblank counter
 * are preserved, even if there are any spurious vblank irq's after
 * disable.
 */
static void vblank_disable_and_save(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	unsigned long irqflags;

	/* Prevent vblank irq processing while disabling vblank irqs,
	 * so no updates of timestamps or count can happen after we've
	 * disabled. Needed to prevent races in case of delayed irq's.
	 */
	spin_lock_irqsave(&dev->vblank_time_lock, irqflags);

	/*
	 * Only disable vblank interrupts if they're enabled. This avoids
	 * calling the ->disable_vblank() operation in atomic context with the
	 * hardware potentially runtime suspended.
	 */
	if (vblank->enabled) {
		dev->driver->disable_vblank(dev, pipe);
		vblank->enabled = false;
	}

	/*
	 * Always update the count and timestamp to maintain the
	 * appearance that the counter has been ticking all along until
	 * this time. This makes the count account for the entire time
	 * between drm_vblank_on() and drm_vblank_off().
	 */
	drm_update_vblank_count(dev, pipe, 0);

	spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);
}

static void vblank_disable_fn(unsigned long arg)
{
	struct drm_vblank_crtc *vblank = (void *)arg;
	struct drm_device *dev = vblank->dev;
	unsigned int pipe = vblank->pipe;
	unsigned long irqflags;

	if (!dev->vblank_disable_allowed)
		return;

	spin_lock_irqsave(&dev->vbl_lock, irqflags);
	if (atomic_read(&vblank->refcount) == 0 && vblank->enabled) {
		DRM_DEBUG("disabling vblank on crtc %u\n", pipe);
		vblank_disable_and_save(dev, pipe);
	}
	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
}

/**
 * drm_vblank_cleanup - cleanup vblank support
 * @@dev: DRM device
 *
 * This function cleans up any resources allocated in drm_vblank_init.
 */
void drm_vblank_cleanup(struct drm_device *dev)
{
	unsigned int pipe;

	/* Bail if the driver didn't call drm_vblank_init() */
	if (dev->num_crtcs == 0)
		return;

	for (pipe = 0; pipe < dev->num_crtcs; pipe++) {
		struct drm_vblank_crtc *vblank = &dev->vblank[pipe];

		WARN_ON(vblank->enabled &&
			drm_core_check_feature(dev, DRIVER_MODESET));

		del_timer_sync(&vblank->disable_timer);
	}

	kfree(dev->vblank);

	dev->num_crtcs = 0;
}
EXPORT_SYMBOL(drm_vblank_cleanup);

/**
 * drm_vblank_init - initialize vblank support
 * @@dev: DRM device
 * @@num_crtcs: number of CRTCs supported by @@dev
 *
 * This function initializes vblank support for @@num_crtcs display pipelines.
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
int drm_vblank_init(struct drm_device *dev, unsigned int num_crtcs)
{
	int ret = -ENOMEM;
	unsigned int i;

	mtx_init(&dev->vbl_lock, IPL_TTY);
	mtx_init(&dev->vblank_time_lock, IPL_TTY);

	dev->num_crtcs = num_crtcs;

	dev->vblank = kcalloc(num_crtcs, sizeof(*dev->vblank), GFP_KERNEL);
	if (!dev->vblank)
		goto err;

	for (i = 0; i < num_crtcs; i++) {
		struct drm_vblank_crtc *vblank = &dev->vblank[i];

		vblank->dev = dev;
		vblank->pipe = i;
		init_waitqueue_head(&vblank->queue);
		setup_timer(&vblank->disable_timer, vblank_disable_fn,
			    (unsigned long)vblank);
	}

	DRM_INFO("Supports vblank timestamp caching Rev 2 (21.10.2013).\n");

	/* Driver specific high-precision vblank timestamping supported? */
	if (dev->driver->get_vblank_timestamp)
		DRM_INFO("Driver supports precise vblank timestamp query.\n");
	else
		DRM_INFO("No driver support for vblank timestamp query.\n");

	/* Must have precise timestamping for reliable vblank instant disable */
	if (dev->vblank_disable_immediate && !dev->driver->get_vblank_timestamp) {
		dev->vblank_disable_immediate = false;
		DRM_INFO("Setting vblank_disable_immediate to false because "
			 "get_vblank_timestamp == NULL\n");
	}

	dev->vblank_disable_allowed = false;

	return 0;

err:
	dev->num_crtcs = 0;
	return ret;
}
EXPORT_SYMBOL(drm_vblank_init);

static void drm_irq_vgaarb_nokms(void *cookie, bool state)
{
	struct drm_device *dev = cookie;

#ifdef __linux__
	if (dev->driver->vgaarb_irq) {
		dev->driver->vgaarb_irq(dev, state);
		return;
	}
#endif

	if (!dev->irq_enabled)
		return;

	if (state) {
		if (dev->driver->irq_uninstall)
			dev->driver->irq_uninstall(dev);
	} else {
		if (dev->driver->irq_preinstall)
			dev->driver->irq_preinstall(dev);
		if (dev->driver->irq_postinstall)
			dev->driver->irq_postinstall(dev);
	}
}

/**
 * drm_irq_install - install IRQ handler
 * @@dev: DRM device
 * @@irq: IRQ number to install the handler for
 *
 * Initializes the IRQ related data. Installs the handler, calling the driver
 * irq_preinstall() and irq_postinstall() functions before and after the
 * installation.
 *
 * This is the simplified helper interface provided for drivers with no special
 * needs. Drivers which need to install interrupt handlers for multiple
 * interrupts must instead set drm_device->irq_enabled to signal the DRM core
 * that vblank interrupts are available.
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
int drm_irq_install(struct drm_device *dev, int irq)
{
	int ret;
	unsigned long sh_flags = 0;

	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
		return -EINVAL;

	if (irq == 0)
		return -EINVAL;

	/* Driver must have been initialized */
	if (!dev->dev_private)
		return -EINVAL;

	if (dev->irq_enabled)
		return -EBUSY;
	dev->irq_enabled = true;

	DRM_DEBUG("irq=%d\n", irq);

	/* Before installing handler */
	if (dev->driver->irq_preinstall)
		dev->driver->irq_preinstall(dev);

	/* Install handler */
	if (drm_core_check_feature(dev, DRIVER_IRQ_SHARED))
		sh_flags = IRQF_SHARED;

	ret = request_irq(irq, dev->driver->irq_handler,
			  sh_flags, dev->driver->name, dev);

	if (ret < 0) {
		dev->irq_enabled = false;
		return ret;
	}

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		vga_client_register(dev->pdev, (void *)dev, drm_irq_vgaarb_nokms, NULL);

	/* After installing handler */
	if (dev->driver->irq_postinstall)
		ret = dev->driver->irq_postinstall(dev);

	if (ret < 0) {
		dev->irq_enabled = false;
		if (!drm_core_check_feature(dev, DRIVER_MODESET))
			vga_client_register(dev->pdev, NULL, NULL, NULL);
		free_irq(irq, dev);
	} else {
		dev->irq = irq;
	}

	return ret;
}
EXPORT_SYMBOL(drm_irq_install);

/**
 * drm_irq_uninstall - uninstall the IRQ handler
 * @@dev: DRM device
 *
 * Calls the driver's irq_uninstall() function and unregisters the IRQ handler.
 * This should only be called by drivers which used drm_irq_install() to set up
 * their interrupt handler. Other drivers must only reset
 * drm_device->irq_enabled to false.
 *
 * Note that for kernel modesetting drivers it is a bug if this function fails.
 * The sanity checks are only to catch buggy user modesetting drivers which call
 * the same function through an ioctl.
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
int drm_irq_uninstall(struct drm_device *dev)
{
	unsigned long irqflags;
	bool irq_enabled;
	int i;

	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
		return -EINVAL;

	irq_enabled = dev->irq_enabled;
	dev->irq_enabled = false;

	/*
	 * Wake up any waiters so they don't hang. This is just to paper over
	 * isssues for UMS drivers which aren't in full control of their
	 * vblank/irq handling. KMS drivers must ensure that vblanks are all
	 * disabled when uninstalling the irq handler.
	 */
	if (dev->num_crtcs) {
		spin_lock_irqsave(&dev->vbl_lock, irqflags);
		for (i = 0; i < dev->num_crtcs; i++) {
			struct drm_vblank_crtc *vblank = &dev->vblank[i];

			if (!vblank->enabled)
				continue;

			WARN_ON(drm_core_check_feature(dev, DRIVER_MODESET));

			vblank_disable_and_save(dev, i);
			wake_up(&vblank->queue);
		}
		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
	}

	if (!irq_enabled)
		return -EINVAL;

	DRM_DEBUG("irq=%d\n", dev->irq);

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		vga_client_register(dev->pdev, NULL, NULL, NULL);

	if (dev->driver->irq_uninstall)
		dev->driver->irq_uninstall(dev);

	free_irq(dev->irq, dev);

	return 0;
}
EXPORT_SYMBOL(drm_irq_uninstall);

/*
 * IRQ control ioctl.
 *
 * \param inode device inode.
 * \param file_priv DRM file private.
 * \param cmd command.
 * \param arg user argument, pointing to a drm_control structure.
 * \return zero on success or a negative number on failure.
 *
 * Calls irq_install() or irq_uninstall() according to \p arg.
 */
int drm_control(struct drm_device *dev, void *data,
		struct drm_file *file_priv)
{
	struct drm_control *ctl = data;
	int ret = 0, irq;

	/* if we haven't irq we fallback for compatibility reasons -
	 * this used to be a separate function in drm_dma.h
	 */

	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
		return 0;
	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return 0;
	/* UMS was only ever support on pci devices. */
	if (WARN_ON(!dev->pdev))
		return -EINVAL;

	switch (ctl->func) {
	case DRM_INST_HANDLER:
		irq = dev->pdev->irq;

		if (dev->if_version < DRM_IF_VERSION(1, 2) &&
		    ctl->irq != irq)
			return -EINVAL;
		mutex_lock(&dev->struct_mutex);
		ret = drm_irq_install(dev, irq);
		mutex_unlock(&dev->struct_mutex);

		return ret;
	case DRM_UNINST_HANDLER:
		mutex_lock(&dev->struct_mutex);
		ret = drm_irq_uninstall(dev);
		mutex_unlock(&dev->struct_mutex);

		return ret;
	default:
		return -EINVAL;
	}
}

/**
 * drm_calc_timestamping_constants - calculate vblank timestamp constants
 * @@crtc: drm_crtc whose timestamp constants should be updated.
 * @@mode: display mode containing the scanout timings
 *
 * Calculate and store various constants which are later
 * needed by vblank and swap-completion timestamping, e.g,
 * by drm_calc_vbltimestamp_from_scanoutpos(). They are
 * derived from CRTC's true scanout timing, so they take
 * things like panel scaling or other adjustments into account.
 */
void drm_calc_timestamping_constants(struct drm_crtc *crtc,
				     const struct drm_display_mode *mode)
{
	struct drm_device *dev = crtc->dev;
	unsigned int pipe = drm_crtc_index(crtc);
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	int linedur_ns = 0, framedur_ns = 0;
	int dotclock = mode->crtc_clock;

	if (!dev->num_crtcs)
		return;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	/* Valid dotclock? */
	if (dotclock > 0) {
		int frame_size = mode->crtc_htotal * mode->crtc_vtotal;

		/*
		 * Convert scanline length in pixels and video
		 * dot clock to line duration and frame duration
		 * in nanoseconds:
		 */
		linedur_ns  = div_u64((u64) mode->crtc_htotal * 1000000, dotclock);
		framedur_ns = div_u64((u64) frame_size * 1000000, dotclock);

		/*
		 * Fields of interlaced scanout modes are only half a frame duration.
		 */
		if (mode->flags & DRM_MODE_FLAG_INTERLACE)
			framedur_ns /= 2;
	} else
		DRM_ERROR("crtc %u: Can't calculate constants, dotclock = 0!\n",
			  crtc->base.id);

	vblank->linedur_ns  = linedur_ns;
	vblank->framedur_ns = framedur_ns;

	DRM_DEBUG("crtc %u: hwmode: htotal %d, vtotal %d, vdisplay %d\n",
		  crtc->base.id, mode->crtc_htotal,
		  mode->crtc_vtotal, mode->crtc_vdisplay);
	DRM_DEBUG("crtc %u: clock %d kHz framedur %d linedur %d\n",
		  crtc->base.id, dotclock, framedur_ns, linedur_ns);
}
EXPORT_SYMBOL(drm_calc_timestamping_constants);

/**
 * drm_calc_vbltimestamp_from_scanoutpos - precise vblank timestamp helper
 * @@dev: DRM device
 * @@pipe: index of CRTC whose vblank timestamp to retrieve
 * @@max_error: Desired maximum allowable error in timestamps (nanosecs)
 *             On return contains true maximum error of timestamp
 * @@vblank_time: Pointer to struct timeval which should receive the timestamp
 * @@flags: Flags to pass to driver:
 *         0 = Default,
 *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl IRQ handler
 * @@mode: mode which defines the scanout timings
 *
 * Implements calculation of exact vblank timestamps from given drm_display_mode
 * timings and current video scanout position of a CRTC. This can be called from
 * within get_vblank_timestamp() implementation of a kms driver to implement the
 * actual timestamping.
 *
 * Should return timestamps conforming to the OML_sync_control OpenML
 * extension specification. The timestamp corresponds to the end of
 * the vblank interval, aka start of scanout of topmost-leftmost display
 * pixel in the following video frame.
 *
 * Requires support for optional dev->driver->get_scanout_position()
 * in kms driver, plus a bit of setup code to provide a drm_display_mode
 * that corresponds to the true scanout timing.
 *
 * The current implementation only handles standard video modes. It
 * returns as no operation if a doublescan or interlaced video mode is
 * active. Higher level code is expected to handle this.
 *
 * Returns:
 * Negative value on error, failure or if not supported in current
 * video mode:
 *
 * -EINVAL   - Invalid CRTC.
 * -EAGAIN   - Temporary unavailable, e.g., called before initial modeset.
 * -ENOTSUPP - Function not supported in current display mode.
 * -EIO      - Failed, e.g., due to failed scanout position query.
 *
 * Returns or'ed positive status flags on success:
 *
 * DRM_VBLANKTIME_SCANOUTPOS_METHOD - Signal this method used for timestamping.
 * DRM_VBLANKTIME_INVBL - Timestamp taken while scanout was in vblank interval.
 *
 */
int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev,
					  unsigned int pipe,
					  int *max_error,
					  struct timeval *vblank_time,
					  unsigned flags,
					  const struct drm_display_mode *mode)
{
	struct timeval tv_etime;
	ktime_t stime, etime;
	unsigned int vbl_status;
	int ret = DRM_VBLANKTIME_SCANOUTPOS_METHOD;
	int vpos, hpos, i;
	int delta_ns, duration_ns;

	if (pipe >= dev->num_crtcs) {
		DRM_ERROR("Invalid crtc %u\n", pipe);
		return -EINVAL;
	}

	/* Scanout position query not supported? Should not happen. */
	if (!dev->driver->get_scanout_position) {
		DRM_ERROR("Called from driver w/o get_scanout_position()!?\n");
		return -EIO;
	}

	/* If mode timing undefined, just return as no-op:
	 * Happens during initial modesetting of a crtc.
	 */
	if (mode->crtc_clock == 0) {
		DRM_DEBUG("crtc %u: Noop due to uninitialized mode.\n", pipe);
		return -EAGAIN;
	}

	/* Get current scanout position with system timestamp.
	 * Repeat query up to DRM_TIMESTAMP_MAXRETRIES times
	 * if single query takes longer than max_error nanoseconds.
	 *
	 * This guarantees a tight bound on maximum error if
	 * code gets preempted or delayed for some reason.
	 */
	for (i = 0; i < DRM_TIMESTAMP_MAXRETRIES; i++) {
		/*
		 * Get vertical and horizontal scanout position vpos, hpos,
		 * and bounding timestamps stime, etime, pre/post query.
		 */
		vbl_status = dev->driver->get_scanout_position(dev, pipe, flags,
							       &vpos, &hpos,
							       &stime, &etime,
							       mode);

		/* Return as no-op if scanout query unsupported or failed. */
		if (!(vbl_status & DRM_SCANOUTPOS_VALID)) {
			DRM_DEBUG("crtc %u : scanoutpos query failed [0x%x].\n",
				  pipe, vbl_status);
			return -EIO;
		}

		/* Compute uncertainty in timestamp of scanout position query. */
		duration_ns = ktime_to_ns(etime) - ktime_to_ns(stime);

		/* Accept result with <  max_error nsecs timing uncertainty. */
		if (duration_ns <= *max_error)
			break;
	}

	/* Noisy system timing? */
	if (i == DRM_TIMESTAMP_MAXRETRIES) {
		DRM_DEBUG("crtc %u: Noisy timestamp %d us > %d us [%d reps].\n",
			  pipe, duration_ns/1000, *max_error/1000, i);
	}

	/* Return upper bound of timestamp precision error. */
	*max_error = duration_ns;

	/* Check if in vblank area:
	 * vpos is >=0 in video scanout area, but negative
	 * within vblank area, counting down the number of lines until
	 * start of scanout.
	 */
	if (vbl_status & DRM_SCANOUTPOS_IN_VBLANK)
		ret |= DRM_VBLANKTIME_IN_VBLANK;

	/* Convert scanout position into elapsed time at raw_time query
	 * since start of scanout at first display scanline. delta_ns
	 * can be negative if start of scanout hasn't happened yet.
	 */
	delta_ns = div_s64(1000000LL * (vpos * mode->crtc_htotal + hpos),
			   mode->crtc_clock);

	if (!drm_timestamp_monotonic)
		etime = ktime_mono_to_real(etime);

	/* save this only for debugging purposes */
	tv_etime = ktime_to_timeval(etime);
	/* Subtract time delta from raw timestamp to get final
	 * vblank_time timestamp for end of vblank.
	 */
	if (delta_ns < 0)
		etime = ktime_add_ns(etime, -delta_ns);
	else
		etime = ktime_sub_ns(etime, delta_ns);
	*vblank_time = ktime_to_timeval(etime);

	DRM_DEBUG_VBL("crtc %u : v 0x%x p(%d,%d)@@ %ld.%ld -> %ld.%ld [e %d us, %d rep]\n",
		      pipe, vbl_status, hpos, vpos,
		      (long)tv_etime.tv_sec, (long)tv_etime.tv_usec,
		      (long)vblank_time->tv_sec, (long)vblank_time->tv_usec,
		      duration_ns/1000, i);

	return ret;
}
EXPORT_SYMBOL(drm_calc_vbltimestamp_from_scanoutpos);

static struct timeval get_drm_timestamp(void)
{
	ktime_t now;

	now = drm_timestamp_monotonic ? ktime_get() : ktime_get_real();
	return ktime_to_timeval(now);
}

/**
 * drm_get_last_vbltimestamp - retrieve raw timestamp for the most recent
 *                             vblank interval
 * @@dev: DRM device
 * @@pipe: index of CRTC whose vblank timestamp to retrieve
 * @@tvblank: Pointer to target struct timeval which should receive the timestamp
 * @@flags: Flags to pass to driver:
 *         0 = Default,
 *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl IRQ handler
 *
 * Fetches the system timestamp corresponding to the time of the most recent
 * vblank interval on specified CRTC. May call into kms-driver to
 * compute the timestamp with a high-precision GPU specific method.
 *
 * Returns zero if timestamp originates from uncorrected do_gettimeofday()
 * call, i.e., it isn't very precisely locked to the true vblank.
 *
 * Returns:
 * True if timestamp is considered to be very precise, false otherwise.
 */
static bool
drm_get_last_vbltimestamp(struct drm_device *dev, unsigned int pipe,
			  struct timeval *tvblank, unsigned flags)
{
	int ret;

	/* Define requested maximum error on timestamps (nanoseconds). */
	int max_error = (int) drm_timestamp_precision * 1000;

	/* Query driver if possible and precision timestamping enabled. */
	if (dev->driver->get_vblank_timestamp && (max_error > 0)) {
		ret = dev->driver->get_vblank_timestamp(dev, pipe, &max_error,
							tvblank, flags);
		if (ret > 0)
			return true;
	}

	/* GPU high precision timestamp query unsupported or failed.
	 * Return current monotonic/gettimeofday timestamp as best estimate.
	 */
	*tvblank = get_drm_timestamp();

	return false;
}

/**
 * drm_vblank_count - retrieve "cooked" vblank counter value
 * @@dev: DRM device
 * @@pipe: index of CRTC for which to retrieve the counter
 *
 * Fetches the "cooked" vblank count value that represents the number of
 * vblank events since the system was booted, including lost events due to
 * modesetting activity.
 *
 * This is the legacy version of drm_crtc_vblank_count().
 *
 * Returns:
 * The software vblank counter.
 */
u32 drm_vblank_count(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];

	if (WARN_ON(pipe >= dev->num_crtcs))
		return 0;

	return vblank->count;
}
EXPORT_SYMBOL(drm_vblank_count);

/**
 * drm_crtc_vblank_count - retrieve "cooked" vblank counter value
 * @@crtc: which counter to retrieve
 *
 * Fetches the "cooked" vblank count value that represents the number of
 * vblank events since the system was booted, including lost events due to
 * modesetting activity.
 *
 * This is the native KMS version of drm_vblank_count().
 *
 * Returns:
 * The software vblank counter.
 */
u32 drm_crtc_vblank_count(struct drm_crtc *crtc)
{
	return drm_vblank_count(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_vblank_count);

/**
 * drm_vblank_count_and_time - retrieve "cooked" vblank counter value and the
 *     system timestamp corresponding to that vblank counter value.
 * @@dev: DRM device
 * @@pipe: index of CRTC whose counter to retrieve
 * @@vblanktime: Pointer to struct timeval to receive the vblank timestamp.
 *
 * Fetches the "cooked" vblank count value that represents the number of
 * vblank events since the system was booted, including lost events due to
 * modesetting activity. Returns corresponding system timestamp of the time
 * of the vblank interval that corresponds to the current vblank counter value.
 *
 * This is the legacy version of drm_crtc_vblank_count_and_time().
 */
u32 drm_vblank_count_and_time(struct drm_device *dev, unsigned int pipe,
			      struct timeval *vblanktime)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	int count = DRM_TIMESTAMP_MAXRETRIES;
	u32 cur_vblank;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return 0;

	/*
	 * Vblank timestamps are read lockless. To ensure consistency the vblank
	 * counter is rechecked and ordering is ensured using memory barriers.
	 * This works like a seqlock. The write-side barriers are in store_vblank.
	 */
	do {
		cur_vblank = vblank->count;
		smp_rmb();
		*vblanktime = vblanktimestamp(dev, pipe, cur_vblank);
		smp_rmb();
	} while (cur_vblank != vblank->count && --count > 0);

	return cur_vblank;
}
EXPORT_SYMBOL(drm_vblank_count_and_time);

/**
 * drm_crtc_vblank_count_and_time - retrieve "cooked" vblank counter value
 *     and the system timestamp corresponding to that vblank counter value
 * @@crtc: which counter to retrieve
 * @@vblanktime: Pointer to struct timeval to receive the vblank timestamp.
 *
 * Fetches the "cooked" vblank count value that represents the number of
 * vblank events since the system was booted, including lost events due to
 * modesetting activity. Returns corresponding system timestamp of the time
 * of the vblank interval that corresponds to the current vblank counter value.
 *
 * This is the native KMS version of drm_vblank_count_and_time().
 */
u32 drm_crtc_vblank_count_and_time(struct drm_crtc *crtc,
				   struct timeval *vblanktime)
{
	return drm_vblank_count_and_time(crtc->dev, drm_crtc_index(crtc),
					 vblanktime);
}
EXPORT_SYMBOL(drm_crtc_vblank_count_and_time);

static void send_vblank_event(struct drm_device *dev,
		struct drm_pending_vblank_event *e,
		unsigned long seq, struct timeval *now)
{
	assert_spin_locked(&dev->event_lock);

	e->event.sequence = seq;
	e->event.tv_sec = now->tv_sec;
	e->event.tv_usec = now->tv_usec;

	list_add_tail(&e->base.link,
		      &e->base.file_priv->event_list);
	wake_up_interruptible(&e->base.file_priv->event_wait);
#ifdef __OpenBSD__
	selwakeup(&e->base.file_priv->rsel);
#endif
	trace_drm_vblank_event_delivered(e->base.pid, e->pipe,
					 e->event.sequence);
}

/**
 * drm_arm_vblank_event - arm vblank event after pageflip
 * @@dev: DRM device
 * @@pipe: CRTC index
 * @@e: the event to prepare to send
 *
 * A lot of drivers need to generate vblank events for the very next vblank
 * interrupt. For example when the page flip interrupt happens when the page
 * flip gets armed, but not when it actually executes within the next vblank
 * period. This helper function implements exactly the required vblank arming
 * behaviour.
 *
 * Caller must hold event lock. Caller must also hold a vblank reference for
 * the event @@e, which will be dropped when the next vblank arrives.
 *
 * This is the legacy version of drm_crtc_arm_vblank_event().
 */
void drm_arm_vblank_event(struct drm_device *dev, unsigned int pipe,
			  struct drm_pending_vblank_event *e)
{
	assert_spin_locked(&dev->event_lock);

	e->pipe = pipe;
	e->event.sequence = drm_vblank_count(dev, pipe);
	list_add_tail(&e->base.link, &dev->vblank_event_list);
}
EXPORT_SYMBOL(drm_arm_vblank_event);

/**
 * drm_crtc_arm_vblank_event - arm vblank event after pageflip
 * @@crtc: the source CRTC of the vblank event
 * @@e: the event to send
 *
 * A lot of drivers need to generate vblank events for the very next vblank
 * interrupt. For example when the page flip interrupt happens when the page
 * flip gets armed, but not when it actually executes within the next vblank
 * period. This helper function implements exactly the required vblank arming
 * behaviour.
 *
 * Caller must hold event lock. Caller must also hold a vblank reference for
 * the event @@e, which will be dropped when the next vblank arrives.
 *
 * This is the native KMS version of drm_arm_vblank_event().
 */
void drm_crtc_arm_vblank_event(struct drm_crtc *crtc,
			       struct drm_pending_vblank_event *e)
{
	drm_arm_vblank_event(crtc->dev, drm_crtc_index(crtc), e);
}
EXPORT_SYMBOL(drm_crtc_arm_vblank_event);

/**
 * drm_send_vblank_event - helper to send vblank event after pageflip
 * @@dev: DRM device
 * @@pipe: CRTC index
 * @@e: the event to send
 *
 * Updates sequence # and timestamp on event, and sends it to userspace.
 * Caller must hold event lock.
 *
 * This is the legacy version of drm_crtc_send_vblank_event().
 */
void drm_send_vblank_event(struct drm_device *dev, unsigned int pipe,
			   struct drm_pending_vblank_event *e)
{
	struct timeval now;
	unsigned int seq;

	if (dev->num_crtcs > 0) {
		seq = drm_vblank_count_and_time(dev, pipe, &now);
	} else {
		seq = 0;

		now = get_drm_timestamp();
	}
	e->pipe = pipe;
	send_vblank_event(dev, e, seq, &now);
}
EXPORT_SYMBOL(drm_send_vblank_event);

/**
 * drm_crtc_send_vblank_event - helper to send vblank event after pageflip
 * @@crtc: the source CRTC of the vblank event
 * @@e: the event to send
 *
 * Updates sequence # and timestamp on event, and sends it to userspace.
 * Caller must hold event lock.
 *
 * This is the native KMS version of drm_send_vblank_event().
 */
void drm_crtc_send_vblank_event(struct drm_crtc *crtc,
				struct drm_pending_vblank_event *e)
{
	drm_send_vblank_event(crtc->dev, drm_crtc_index(crtc), e);
}
EXPORT_SYMBOL(drm_crtc_send_vblank_event);

/**
 * drm_vblank_enable - enable the vblank interrupt on a CRTC
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
static int drm_vblank_enable(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	int ret = 0;

	assert_spin_locked(&dev->vbl_lock);

	spin_lock(&dev->vblank_time_lock);

	if (!vblank->enabled) {
		/*
		 * Enable vblank irqs under vblank_time_lock protection.
		 * All vblank count & timestamp updates are held off
		 * until we are done reinitializing master counter and
		 * timestamps. Filtercode in drm_handle_vblank() will
		 * prevent double-accounting of same vblank interval.
		 */
		ret = dev->driver->enable_vblank(dev, pipe);
		DRM_DEBUG("enabling vblank on crtc %u, ret: %d\n", pipe, ret);
		if (ret)
			atomic_dec(&vblank->refcount);
		else {
			vblank->enabled = true;
			drm_update_vblank_count(dev, pipe, 0);
		}
	}

	spin_unlock(&dev->vblank_time_lock);

	return ret;
}

/**
 * drm_vblank_get - get a reference count on vblank events
 * @@dev: DRM device
 * @@pipe: index of CRTC to own
 *
 * Acquire a reference count on vblank events to avoid having them disabled
 * while in use.
 *
 * This is the legacy version of drm_crtc_vblank_get().
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
int drm_vblank_get(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	unsigned long irqflags;
	int ret = 0;

	if (!dev->num_crtcs)
		return -EINVAL;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return -EINVAL;

	spin_lock_irqsave(&dev->vbl_lock, irqflags);
	/* Going from 0->1 means we have to enable interrupts again */
	if (atomic_add_return(1, &vblank->refcount) == 1) {
		ret = drm_vblank_enable(dev, pipe);
	} else {
		if (!vblank->enabled) {
			atomic_dec(&vblank->refcount);
			ret = -EINVAL;
		}
	}
	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);

	return ret;
}
EXPORT_SYMBOL(drm_vblank_get);

/**
 * drm_crtc_vblank_get - get a reference count on vblank events
 * @@crtc: which CRTC to own
 *
 * Acquire a reference count on vblank events to avoid having them disabled
 * while in use.
 *
 * This is the native kms version of drm_vblank_get().
 *
 * Returns:
 * Zero on success or a negative error code on failure.
 */
int drm_crtc_vblank_get(struct drm_crtc *crtc)
{
	return drm_vblank_get(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_vblank_get);

/**
 * drm_vblank_put - release ownership of vblank events
 * @@dev: DRM device
 * @@pipe: index of CRTC to release
 *
 * Release ownership of a given vblank counter, turning off interrupts
 * if possible. Disable interrupts after drm_vblank_offdelay milliseconds.
 *
 * This is the legacy version of drm_crtc_vblank_put().
 */
void drm_vblank_put(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	if (WARN_ON(atomic_read(&vblank->refcount) == 0))
		return;

	/* Last user schedules interrupt disable */
	if (atomic_dec_and_test(&vblank->refcount)) {
		if (drm_vblank_offdelay == 0)
			return;
		else if (dev->vblank_disable_immediate || drm_vblank_offdelay < 0)
			vblank_disable_fn((unsigned long)vblank);
		else
			mod_timer(&vblank->disable_timer,
				  jiffies + ((drm_vblank_offdelay * HZ)/1000));
	}
}
EXPORT_SYMBOL(drm_vblank_put);

/**
 * drm_crtc_vblank_put - give up ownership of vblank events
 * @@crtc: which counter to give up
 *
 * Release ownership of a given vblank counter, turning off interrupts
 * if possible. Disable interrupts after drm_vblank_offdelay milliseconds.
 *
 * This is the native kms version of drm_vblank_put().
 */
void drm_crtc_vblank_put(struct drm_crtc *crtc)
{
	drm_vblank_put(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_vblank_put);

/**
 * drm_wait_one_vblank - wait for one vblank
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * This waits for one vblank to pass on @@pipe, using the irq driver interfaces.
 * It is a failure to call this when the vblank irq for @@pipe is disabled, e.g.
 * due to lack of driver support or because the crtc is off.
 */
void drm_wait_one_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	int ret;
	u32 last;

	if (WARN_ON(pipe >= dev->num_crtcs) || cold)
		return;

	ret = drm_vblank_get(dev, pipe);
	if (WARN(ret, "vblank not available on crtc %i, ret=%i\n", pipe, ret))
		return;

	last = drm_vblank_count(dev, pipe);

	ret = wait_event_timeout(vblank->queue,
				 last != drm_vblank_count(dev, pipe),
				 msecs_to_jiffies(100));

	WARN(ret == 0, "vblank wait timed out on crtc %i\n", pipe);

	drm_vblank_put(dev, pipe);
}
EXPORT_SYMBOL(drm_wait_one_vblank);

/**
 * drm_crtc_wait_one_vblank - wait for one vblank
 * @@crtc: DRM crtc
 *
 * This waits for one vblank to pass on @@crtc, using the irq driver interfaces.
 * It is a failure to call this when the vblank irq for @@crtc is disabled, e.g.
 * due to lack of driver support or because the crtc is off.
 */
void drm_crtc_wait_one_vblank(struct drm_crtc *crtc)
{
	drm_wait_one_vblank(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_wait_one_vblank);

/**
 * drm_vblank_off - disable vblank events on a CRTC
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * Drivers can use this function to shut down the vblank interrupt handling when
 * disabling a crtc. This function ensures that the latest vblank frame count is
 * stored so that drm_vblank_on() can restore it again.
 *
 * Drivers must use this function when the hardware vblank counter can get
 * reset, e.g. when suspending.
 *
 * This is the legacy version of drm_crtc_vblank_off().
 */
void drm_vblank_off(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	struct drm_pending_vblank_event *e, *t;
	struct timeval now;
	unsigned long irqflags;
	unsigned int seq;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	spin_lock_irqsave(&dev->event_lock, irqflags);

	spin_lock(&dev->vbl_lock);
	DRM_DEBUG_VBL("crtc %d, vblank enabled %d, inmodeset %d\n",
		      pipe, vblank->enabled, vblank->inmodeset);

	/* Avoid redundant vblank disables without previous drm_vblank_on(). */
	if (drm_core_check_feature(dev, DRIVER_ATOMIC) || !vblank->inmodeset)
		vblank_disable_and_save(dev, pipe);

	wake_up(&vblank->queue);

	/*
	 * Prevent subsequent drm_vblank_get() from re-enabling
	 * the vblank interrupt by bumping the refcount.
	 */
	if (!vblank->inmodeset) {
		atomic_inc(&vblank->refcount);
		vblank->inmodeset = 1;
	}
	spin_unlock(&dev->vbl_lock);

	/* Send any queued vblank events, lest the natives grow disquiet */
	seq = drm_vblank_count_and_time(dev, pipe, &now);

	list_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {
		if (e->pipe != pipe)
			continue;
		DRM_DEBUG("Sending premature vblank event on disable: "
			  "wanted %d, current %d\n",
			  e->event.sequence, seq);
		list_del(&e->base.link);
		drm_vblank_put(dev, pipe);
		send_vblank_event(dev, e, seq, &now);
	}
	spin_unlock_irqrestore(&dev->event_lock, irqflags);
}
EXPORT_SYMBOL(drm_vblank_off);

/**
 * drm_crtc_vblank_off - disable vblank events on a CRTC
 * @@crtc: CRTC in question
 *
 * Drivers can use this function to shut down the vblank interrupt handling when
 * disabling a crtc. This function ensures that the latest vblank frame count is
 * stored so that drm_vblank_on can restore it again.
 *
 * Drivers must use this function when the hardware vblank counter can get
 * reset, e.g. when suspending.
 *
 * This is the native kms version of drm_vblank_off().
 */
void drm_crtc_vblank_off(struct drm_crtc *crtc)
{
	drm_vblank_off(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_vblank_off);

/**
 * drm_crtc_vblank_reset - reset vblank state to off on a CRTC
 * @@crtc: CRTC in question
 *
 * Drivers can use this function to reset the vblank state to off at load time.
 * Drivers should use this together with the drm_crtc_vblank_off() and
 * drm_crtc_vblank_on() functions. The difference compared to
 * drm_crtc_vblank_off() is that this function doesn't save the vblank counter
 * and hence doesn't need to call any driver hooks.
 */
void drm_crtc_vblank_reset(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	unsigned long irqflags;
	unsigned int pipe = drm_crtc_index(crtc);
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];

	spin_lock_irqsave(&dev->vbl_lock, irqflags);
	/*
	 * Prevent subsequent drm_vblank_get() from enabling the vblank
	 * interrupt by bumping the refcount.
	 */
	if (!vblank->inmodeset) {
		atomic_inc(&vblank->refcount);
		vblank->inmodeset = 1;
	}
	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);

	WARN_ON(!list_empty(&dev->vblank_event_list));
}
EXPORT_SYMBOL(drm_crtc_vblank_reset);

/**
 * drm_vblank_on - enable vblank events on a CRTC
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * This functions restores the vblank interrupt state captured with
 * drm_vblank_off() again. Note that calls to drm_vblank_on() and
 * drm_vblank_off() can be unbalanced and so can also be unconditionally called
 * in driver load code to reflect the current hardware state of the crtc.
 *
 * This is the legacy version of drm_crtc_vblank_on().
 */
void drm_vblank_on(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	unsigned long irqflags;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	spin_lock_irqsave(&dev->vbl_lock, irqflags);
	DRM_DEBUG_VBL("crtc %d, vblank enabled %d, inmodeset %d\n",
		      pipe, vblank->enabled, vblank->inmodeset);

	/* Drop our private "prevent drm_vblank_get" refcount */
	if (vblank->inmodeset) {
		atomic_dec(&vblank->refcount);
		vblank->inmodeset = 0;
	}

	drm_reset_vblank_timestamp(dev, pipe);

	/*
	 * re-enable interrupts if there are users left, or the
	 * user wishes vblank interrupts to be enabled all the time.
	 */
	if (atomic_read(&vblank->refcount) != 0 || drm_vblank_offdelay == 0)
		WARN_ON(drm_vblank_enable(dev, pipe));
	spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
}
EXPORT_SYMBOL(drm_vblank_on);

/**
 * drm_crtc_vblank_on - enable vblank events on a CRTC
 * @@crtc: CRTC in question
 *
 * This functions restores the vblank interrupt state captured with
 * drm_vblank_off() again. Note that calls to drm_vblank_on() and
 * drm_vblank_off() can be unbalanced and so can also be unconditionally called
 * in driver load code to reflect the current hardware state of the crtc.
 *
 * This is the native kms version of drm_vblank_on().
 */
void drm_crtc_vblank_on(struct drm_crtc *crtc)
{
	drm_vblank_on(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_vblank_on);

/**
 * drm_vblank_pre_modeset - account for vblanks across mode sets
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * Account for vblank events across mode setting events, which will likely
 * reset the hardware frame counter.
 *
 * This is done by grabbing a temporary vblank reference to ensure that the
 * vblank interrupt keeps running across the modeset sequence. With this the
 * software-side vblank frame counting will ensure that there are no jumps or
 * discontinuities.
 *
 * Unfortunately this approach is racy and also doesn't work when the vblank
 * interrupt stops running, e.g. across system suspend resume. It is therefore
 * highly recommended that drivers use the newer drm_vblank_off() and
 * drm_vblank_on() instead. drm_vblank_pre_modeset() only works correctly when
 * using "cooked" software vblank frame counters and not relying on any hardware
 * counters.
 *
 * Drivers must call drm_vblank_post_modeset() when re-enabling the same crtc
 * again.
 */
void drm_vblank_pre_modeset(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];

	/* vblank is not initialized (IRQ not installed ?), or has been freed */
	if (!dev->num_crtcs)
		return;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	/*
	 * To avoid all the problems that might happen if interrupts
	 * were enabled/disabled around or between these calls, we just
	 * have the kernel take a reference on the CRTC (just once though
	 * to avoid corrupting the count if multiple, mismatch calls occur),
	 * so that interrupts remain enabled in the interim.
	 */
	if (!vblank->inmodeset) {
		vblank->inmodeset = 0x1;
		if (drm_vblank_get(dev, pipe) == 0)
			vblank->inmodeset |= 0x2;
	}
}
EXPORT_SYMBOL(drm_vblank_pre_modeset);

/**
 * drm_vblank_post_modeset - undo drm_vblank_pre_modeset changes
 * @@dev: DRM device
 * @@pipe: CRTC index
 *
 * This function again drops the temporary vblank reference acquired in
 * drm_vblank_pre_modeset.
 */
void drm_vblank_post_modeset(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	unsigned long irqflags;

	/* vblank is not initialized (IRQ not installed ?), or has been freed */
	if (!dev->num_crtcs)
		return;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return;

	if (vblank->inmodeset) {
		spin_lock_irqsave(&dev->vbl_lock, irqflags);
		dev->vblank_disable_allowed = true;
		drm_reset_vblank_timestamp(dev, pipe);
		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);

		if (vblank->inmodeset & 0x2)
			drm_vblank_put(dev, pipe);

		vblank->inmodeset = 0;
	}
}
EXPORT_SYMBOL(drm_vblank_post_modeset);

/*
 * drm_modeset_ctl - handle vblank event counter changes across mode switch
 * @@DRM_IOCTL_ARGS: standard ioctl arguments
 *
 * Applications should call the %_DRM_PRE_MODESET and %_DRM_POST_MODESET
 * ioctls around modesetting so that any lost vblank events are accounted for.
 *
 * Generally the counter will reset across mode sets.  If interrupts are
 * enabled around this call, we don't have to do anything since the counter
 * will have already been incremented.
 */
int drm_modeset_ctl(struct drm_device *dev, void *data,
		    struct drm_file *file_priv)
{
	struct drm_modeset_ctl *modeset = data;
	unsigned int pipe;

	/* If drm_vblank_init() hasn't been called yet, just no-op */
	if (!dev->num_crtcs)
		return 0;

	/* KMS drivers handle this internally */
	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return 0;

	pipe = modeset->crtc;
	if (pipe >= dev->num_crtcs)
		return -EINVAL;

	switch (modeset->cmd) {
	case _DRM_PRE_MODESET:
		drm_vblank_pre_modeset(dev, pipe);
		break;
	case _DRM_POST_MODESET:
		drm_vblank_post_modeset(dev, pipe);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int drm_queue_vblank_event(struct drm_device *dev, unsigned int pipe,
				  union drm_wait_vblank *vblwait,
				  struct drm_file *file_priv)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	struct drm_pending_vblank_event *e;
	struct timeval now;
	unsigned long flags;
	unsigned int seq;
	int ret;

	e = kzalloc(sizeof(*e), GFP_KERNEL);
	if (e == NULL) {
		ret = -ENOMEM;
		goto err_put;
	}

	e->pipe = pipe;
#ifdef __linux__
	e->base.pid = current->pid;
#else
	e->base.pid = curproc->p_p->ps_pid;
#endif
	e->event.base.type = DRM_EVENT_VBLANK;
	e->event.base.length = sizeof(e->event);
	e->event.user_data = vblwait->request.signal;
	e->base.event = &e->event.base;
	e->base.file_priv = file_priv;
	e->base.destroy = (void (*) (struct drm_pending_event *)) kfree;

	spin_lock_irqsave(&dev->event_lock, flags);

	/*
	 * drm_vblank_off() might have been called after we called
	 * drm_vblank_get(). drm_vblank_off() holds event_lock
	 * around the vblank disable, so no need for further locking.
	 * The reference from drm_vblank_get() protects against
	 * vblank disable from another source.
	 */
	if (!vblank->enabled) {
		ret = -EINVAL;
		goto err_unlock;
	}

	if (file_priv->event_space < sizeof(e->event)) {
		ret = -EBUSY;
		goto err_unlock;
	}

	file_priv->event_space -= sizeof(e->event);
	seq = drm_vblank_count_and_time(dev, pipe, &now);

	if ((vblwait->request.type & _DRM_VBLANK_NEXTONMISS) &&
	    (seq - vblwait->request.sequence) <= (1 << 23)) {
		vblwait->request.sequence = seq + 1;
		vblwait->reply.sequence = vblwait->request.sequence;
	}

	DRM_DEBUG("event on vblank count %d, current %d, crtc %u\n",
		  vblwait->request.sequence, seq, pipe);

#ifdef __linux__
	trace_drm_vblank_event_queued(current->pid, pipe,
				      vblwait->request.sequence);
#else
	trace_drm_vblank_event_queued(curproc->p_p->ps_pid, pipe,
				      vblwait->request.sequence);
#endif

	e->event.sequence = vblwait->request.sequence;
	if ((seq - vblwait->request.sequence) <= (1 << 23)) {
		drm_vblank_put(dev, pipe);
		send_vblank_event(dev, e, seq, &now);
		vblwait->reply.sequence = seq;
	} else {
		/* drm_handle_vblank_events will call drm_vblank_put */
		list_add_tail(&e->base.link, &dev->vblank_event_list);
		vblwait->reply.sequence = vblwait->request.sequence;
	}

	spin_unlock_irqrestore(&dev->event_lock, flags);

	return 0;

err_unlock:
	spin_unlock_irqrestore(&dev->event_lock, flags);
	kfree(e);
err_put:
	drm_vblank_put(dev, pipe);
	return ret;
}

/*
 * Wait for VBLANK.
 *
 * \param inode device inode.
 * \param file_priv DRM file private.
 * \param cmd command.
 * \param data user argument, pointing to a drm_wait_vblank structure.
 * \return zero on success or a negative number on failure.
 *
 * This function enables the vblank interrupt on the pipe requested, then
 * sleeps waiting for the requested sequence number to occur, and drops
 * the vblank interrupt refcount afterwards. (vblank IRQ disable follows that
 * after a timeout with no further vblank waits scheduled).
 */
int drm_wait_vblank(struct drm_device *dev, void *data,
		    struct drm_file *file_priv)
{
	struct drm_vblank_crtc *vblank;
	union drm_wait_vblank *vblwait = data;
	int ret;
	unsigned int flags, seq, pipe, high_pipe;

	if (!dev->irq_enabled)
		return -EINVAL;

	if (vblwait->request.type & _DRM_VBLANK_SIGNAL)
		return -EINVAL;

	if (vblwait->request.type &
	    ~(_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |
	      _DRM_VBLANK_HIGH_CRTC_MASK)) {
		DRM_ERROR("Unsupported type value 0x%x, supported mask 0x%x\n",
			  vblwait->request.type,
			  (_DRM_VBLANK_TYPES_MASK | _DRM_VBLANK_FLAGS_MASK |
			   _DRM_VBLANK_HIGH_CRTC_MASK));
		return -EINVAL;
	}

	flags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;
	high_pipe = (vblwait->request.type & _DRM_VBLANK_HIGH_CRTC_MASK);
	if (high_pipe)
		pipe = high_pipe >> _DRM_VBLANK_HIGH_CRTC_SHIFT;
	else
		pipe = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;
	if (pipe >= dev->num_crtcs)
		return -EINVAL;

	vblank = &dev->vblank[pipe];

	ret = drm_vblank_get(dev, pipe);
	if (ret) {
		DRM_DEBUG("failed to acquire vblank counter, %d\n", ret);
		return ret;
	}
	seq = drm_vblank_count(dev, pipe);

	switch (vblwait->request.type & _DRM_VBLANK_TYPES_MASK) {
	case _DRM_VBLANK_RELATIVE:
		vblwait->request.sequence += seq;
		vblwait->request.type &= ~_DRM_VBLANK_RELATIVE;
	case _DRM_VBLANK_ABSOLUTE:
		break;
	default:
		ret = -EINVAL;
		goto done;
	}

	if (flags & _DRM_VBLANK_EVENT) {
		/* must hold on to the vblank ref until the event fires
		 * drm_vblank_put will be called asynchronously
		 */
		return drm_queue_vblank_event(dev, pipe, vblwait, file_priv);
	}

	if ((flags & _DRM_VBLANK_NEXTONMISS) &&
	    (seq - vblwait->request.sequence) <= (1<<23)) {
		vblwait->request.sequence = seq + 1;
	}

	DRM_DEBUG("waiting on vblank count %d, crtc %u\n",
		  vblwait->request.sequence, pipe);
	vblank->last_wait = vblwait->request.sequence;
	DRM_WAIT_ON(ret, vblank->queue, 3 * HZ,
		    (((drm_vblank_count(dev, pipe) -
		       vblwait->request.sequence) <= (1 << 23)) ||
		     !vblank->enabled ||
		     !dev->irq_enabled));

	if (ret != -EINTR) {
		struct timeval now;

		vblwait->reply.sequence = drm_vblank_count_and_time(dev, pipe, &now);
		vblwait->reply.tval_sec = now.tv_sec;
		vblwait->reply.tval_usec = now.tv_usec;

		DRM_DEBUG("returning %d to client\n",
			  vblwait->reply.sequence);
	} else {
		DRM_DEBUG("vblank wait interrupted by signal\n");
	}

done:
	drm_vblank_put(dev, pipe);
	return ret;
}

static void drm_handle_vblank_events(struct drm_device *dev, unsigned int pipe)
{
	struct drm_pending_vblank_event *e, *t;
	struct timeval now;
	unsigned int seq;

	assert_spin_locked(&dev->event_lock);

	seq = drm_vblank_count_and_time(dev, pipe, &now);

	list_for_each_entry_safe(e, t, &dev->vblank_event_list, base.link) {
		if (e->pipe != pipe)
			continue;
		if ((seq - e->event.sequence) > (1<<23))
			continue;

		DRM_DEBUG("vblank event on %d, current %d\n",
			  e->event.sequence, seq);

		list_del(&e->base.link);
		drm_vblank_put(dev, pipe);
		send_vblank_event(dev, e, seq, &now);
	}

	trace_drm_vblank_event(pipe, seq);
}

/**
 * drm_handle_vblank - handle a vblank event
 * @@dev: DRM device
 * @@pipe: index of CRTC where this event occurred
 *
 * Drivers should call this routine in their vblank interrupt handlers to
 * update the vblank counter and send any signals that may be pending.
 *
 * This is the legacy version of drm_crtc_handle_vblank().
 */
bool drm_handle_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_vblank_crtc *vblank = &dev->vblank[pipe];
	unsigned long irqflags;

	if (WARN_ON_ONCE(!dev->num_crtcs))
		return false;

	if (WARN_ON(pipe >= dev->num_crtcs))
		return false;

	spin_lock_irqsave(&dev->event_lock, irqflags);

	/* Need timestamp lock to prevent concurrent execution with
	 * vblank enable/disable, as this would cause inconsistent
	 * or corrupted timestamps and vblank counts.
	 */
	spin_lock(&dev->vblank_time_lock);

	/* Vblank irq handling disabled. Nothing to do. */
	if (!vblank->enabled) {
		spin_unlock(&dev->vblank_time_lock);
		spin_unlock_irqrestore(&dev->event_lock, irqflags);
		return false;
	}

	drm_update_vblank_count(dev, pipe, DRM_CALLED_FROM_VBLIRQ);

	spin_unlock(&dev->vblank_time_lock);

	wake_up(&vblank->queue);
	drm_handle_vblank_events(dev, pipe);

	spin_unlock_irqrestore(&dev->event_lock, irqflags);

	return true;
}
EXPORT_SYMBOL(drm_handle_vblank);

/**
 * drm_crtc_handle_vblank - handle a vblank event
 * @@crtc: where this event occurred
 *
 * Drivers should call this routine in their vblank interrupt handlers to
 * update the vblank counter and send any signals that may be pending.
 *
 * This is the native KMS version of drm_handle_vblank().
 *
 * Returns:
 * True if the event was successfully handled, false on failure.
 */
bool drm_crtc_handle_vblank(struct drm_crtc *crtc)
{
	return drm_handle_vblank(crtc->dev, drm_crtc_index(crtc));
}
EXPORT_SYMBOL(drm_crtc_handle_vblank);

/**
 * drm_vblank_no_hw_counter - "No hw counter" implementation of .get_vblank_counter()
 * @@dev: DRM device
 * @@pipe: CRTC for which to read the counter
 *
 * Drivers can plug this into the .get_vblank_counter() function if
 * there is no useable hardware frame counter available.
 *
 * Returns:
 * 0
 */
u32 drm_vblank_no_hw_counter(struct drm_device *dev, unsigned int pipe)
{
	return 0;
}
EXPORT_SYMBOL(drm_vblank_no_hw_counter);
@


1.68
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@a448 1
#ifdef __linux__
d453 1
d458 1
a472 1
#endif
a493 1
#ifdef __linux__
a494 1
#endif
a515 1
#ifdef __linux__
a529 1
#endif
a536 1
#ifdef __linux__
a539 1
#endif
a602 1
#ifdef __linux__
a604 1
#endif
a608 1
#ifdef __linux__
a609 1
#endif
@


1.67
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 2
a2 3
/**
 * \file drm_irq.c
 * IRQ support
d35 1
a35 1
#include "drmP.h"
d37 5
d43 2
a44 4
#ifdef DRM_VBLANK_DEBUG
#define VBL_DEBUG(x...)	do { printf(x); } while(/* CONSTCOND */ 0)
#else
#define VBL_DEBUG(x...)	do { } while(/* CONSTCOND */ 0)
d48 2
a49 2
#define vblanktimestamp(dev, crtc, count) \
	((dev)->vblank[crtc].time[(count) % DRM_VBLANKTIME_RBSIZE])
d61 6
a66 2
unsigned int drm_timestamp_precision = 20;  /* Default to 20 usecs. */
unsigned int drm_vblank_offdelay = 5000;    /* Default to 5000 msecs. */
d73 36
a108 1
#ifdef __linux__
d110 6
a115 1
 * Get interrupt from bus id.
d117 1
a117 5
 * \param inode device inode.
 * \param file_priv DRM file private.
 * \param cmd command.
 * \param arg user argument, pointing to a drm_irq_busid structure.
 * \return zero on success or a negative number on failure.
d119 2
a120 3
 * Finds the PCI device with the specified bus id and gets its IRQ number.
 * This IOCTL is deprecated, and will now return EINVAL for any busid not equal
 * to that of the device that this DRM instance attached to.
d122 1
a122 2
int drm_irq_by_busid(struct drm_device *dev, void *data,
		     struct drm_file *file_priv)
d124 4
a127 1
	struct drm_irq_busid *p = data;
d129 18
a146 2
	if (!dev->driver->bus->irq_by_busid)
		return -EINVAL;
d148 5
a152 2
	if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
		return -EINVAL;
d154 1
a154 1
	return dev->driver->bus->irq_by_busid(dev, p);
a155 1
#endif
d157 15
a171 2
/*
 * Clear vblank timestamp buffer for a crtc.
d173 2
a174 1
static void clear_vblank_timestamps(struct drm_device *dev, int crtc)
d176 127
a302 1
	memset(dev->vblank[crtc].time, 0, sizeof(dev->vblank[crtc].time));
d311 1
a311 1
static void vblank_disable_and_save(struct drm_device *dev, int crtc)
d313 1
a314 5
	u32 vblcount;
	s64 diff_ns;
	int vblrc;
	struct timeval tvblank;
	int count = DRM_TIMESTAMP_MAXRETRIES;
d322 4
a325 41
	dev->driver->disable_vblank(dev, crtc);
	dev->vblank[crtc].enabled = false;

	/* No further vblank irq's will be processed after
	 * this point. Get current hardware vblank count and
	 * vblank timestamp, repeat until they are consistent.
	 *
	 * FIXME: There is still a race condition here and in
	 * drm_update_vblank_count() which can cause off-by-one
	 * reinitialization of software vblank counter. If gpu
	 * vblank counter doesn't increment exactly at the leading
	 * edge of a vblank interval, then we can lose 1 count if
	 * we happen to execute between start of vblank and the
	 * delayed gpu counter increment.
	 */
	do {
		dev->vblank[crtc].last = dev->driver->get_vblank_counter(dev, crtc);
		vblrc = drm_get_last_vbltimestamp(dev, crtc, &tvblank, 0);
	} while (dev->vblank[crtc].last != dev->driver->get_vblank_counter(dev, crtc) && (--count) && vblrc);

	if (!count)
		vblrc = 0;

	/* Compute time difference to stored timestamp of last vblank
	 * as updated by last invocation of drm_handle_vblank() in vblank irq.
	 */
	vblcount = atomic_read(&dev->vblank[crtc].count);
	diff_ns = timeval_to_ns(&tvblank) -
		  timeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));

	/* If there is at least 1 msec difference between the last stored
	 * timestamp and tvblank, then we are currently executing our
	 * disable inside a new vblank interval, the tvblank timestamp
	 * corresponds to this new vblank interval and the irq handler
	 * for this vblank didn't run yet and won't run due to our disable.
	 * Therefore we need to do the job of drm_handle_vblank() and
	 * increment the vblank counter by one to account for this vblank.
	 *
	 * Skip this step if there isn't any high precision timestamp
	 * available. In that case we can't account for this and just
	 * hope for the best.
d327 3
a329 3
	if ((vblrc > 0) && (abs64(diff_ns) > 1000000)) {
		atomic_inc(&dev->vblank[crtc].count);
		smp_mb__after_atomic_inc();
d332 7
a338 2
	/* Invalidate all timestamps while vblank irq's are off. */
	clear_vblank_timestamps(dev, crtc);
d345 3
a347 1
	struct drm_device *dev = (struct drm_device *)arg;
a348 1
	int i;
d353 4
a356 8
	for (i = 0; i < dev->num_crtcs; i++) {
		spin_lock_irqsave(&dev->vbl_lock, irqflags);
		if (atomic_read(&dev->vblank[i].refcount) == 0 &&
		    dev->vblank[i].enabled) {
			DRM_DEBUG("disabling vblank on crtc %d\n", i);
			vblank_disable_and_save(dev, i);
		}
		spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
d358 1
d361 6
d369 2
d375 2
a376 1
	del_timer_sync(&dev->vblank_disable_timer);
d378 5
a382 1
	vblank_disable_fn((unsigned long)dev);
d390 11
a400 1
int drm_vblank_init(struct drm_device *dev, int num_crtcs)
d402 2
a403 1
	int i, ret = -ENOMEM;
a404 2
	setup_timer(&dev->vblank_disable_timer, vblank_disable_fn,
		    (unsigned long)dev);
d414 9
a422 2
	for (i = 0; i < num_crtcs; i++)
		init_waitqueue_head(&dev->vblank[i].queue);
d432 7
d444 1
a444 1
	drm_vblank_cleanup(dev);
d475 7
a481 1
 * Install IRQ handler.
d483 4
a486 1
 * \param dev DRM device.
d488 2
a489 3
 * Initializes the IRQ related data. Installs the handler, calling the driver
 * \c irq_preinstall() and \c irq_postinstall() functions
 * before and after the installation.
d491 1
a491 1
int drm_irq_install(struct drm_device *dev)
a495 1
	char *irqname;
d501 1
a501 1
	if (drm_dev_to_irq(dev) == 0)
a503 2
	mutex_lock(&dev->struct_mutex);

d505 1
a505 2
	if (!dev->dev_private) {
		mutex_unlock(&dev->struct_mutex);
a506 1
	}
d508 1
a508 2
	if (dev->irq_enabled) {
		mutex_unlock(&dev->struct_mutex);
a509 1
	}
a510 1
	mutex_unlock(&dev->struct_mutex);
d512 1
a512 1
	DRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));
d523 2
a524 7
	if (dev->devname)
		irqname = dev->devname;
	else
		irqname = dev->driver->name;

	ret = request_irq(drm_dev_to_irq(dev), dev->driver->irq_handler,
			  sh_flags, irqname, dev);
a526 1
		mutex_lock(&dev->struct_mutex);
a527 1
		mutex_unlock(&dev->struct_mutex);
a539 1
		mutex_lock(&dev->struct_mutex);
a540 1
		mutex_unlock(&dev->struct_mutex);
d544 1
a544 1
		free_irq(drm_dev_to_irq(dev), dev);
d546 2
d555 2
a556 1
 * Uninstall the IRQ handler.
d558 8
a565 1
 * \param dev DRM device.
d567 2
a568 1
 * Calls the driver's \c irq_uninstall() function, and stops the irq.
a578 1
	mutex_lock(&dev->struct_mutex);
a580 1
	mutex_unlock(&dev->struct_mutex);
d583 4
a586 1
	 * Wake up any waiters so they don't hang.
d591 9
a599 4
			wake_up(&dev->vblank[i].queue);
			dev->vblank[i].enabled = false;
			dev->vblank[i].last =
				dev->driver->get_vblank_counter(dev, i);
d607 1
a607 1
	DRM_DEBUG("irq=%d\n", drm_dev_to_irq(dev));
d618 1
a618 1
	free_irq(drm_dev_to_irq(dev), dev);
d625 1
a625 2
#ifdef __linux__
/**
d640 1
d646 7
d656 2
a657 4
		if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
			return 0;
		if (drm_core_check_feature(dev, DRIVER_MODESET))
			return 0;
d659 1
a659 1
		    ctl->irq != drm_dev_to_irq(dev))
d661 5
a665 1
		return drm_irq_install(dev);
d667 5
a671 5
		if (!drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
			return 0;
		if (drm_core_check_feature(dev, DRIVER_MODESET))
			return 0;
		return drm_irq_uninstall(dev);
a675 1
#endif
d678 3
a680 4
 * drm_calc_timestamping_constants - Calculate vblank timestamp constants
 *
 * @@crtc drm_crtc whose timestamp constants should be updated.
 * @@mode display mode containing the scanout timings
d685 1
a685 1
 * derived from crtc's true scanout timing, so they take
d691 4
a694 1
	int linedur_ns = 0, pixeldur_ns = 0, framedur_ns = 0;
d697 6
d709 2
a710 2
		 * dot clock to line duration, frame duration
		 * and pixel duration in nanoseconds:
a711 1
		pixeldur_ns = 1000000 / dotclock;
d721 1
a721 1
		DRM_ERROR("crtc %d: Can't calculate constants, dotclock = 0!\n",
d724 2
a725 3
	crtc->pixeldur_ns = pixeldur_ns;
	crtc->linedur_ns  = linedur_ns;
	crtc->framedur_ns = framedur_ns;
d727 1
a727 1
	DRM_DEBUG("crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d\n",
d730 2
a731 3
	DRM_DEBUG("crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d\n",
		  crtc->base.id, dotclock, framedur_ns,
		  linedur_ns, pixeldur_ns);
d736 15
a750 5
 * drm_calc_vbltimestamp_from_scanoutpos - helper routine for kms
 * drivers. Implements calculation of exact vblank timestamps from
 * given drm_display_mode timings and current video scanout position
 * of a crtc. This can be called from within get_vblank_timestamp()
 * implementation of a kms driver to implement the actual timestamping.
d765 2
a766 12
 * @@dev: DRM device.
 * @@crtc: Which crtc's vblank timestamp to retrieve.
 * @@max_error: Desired maximum allowable error in timestamps (nanosecs).
 *             On return contains true maximum error of timestamp.
 * @@vblank_time: Pointer to struct timeval which should receive the timestamp.
 * @@flags: Flags to pass to driver:
 *         0 = Default.
 *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.
 * @@refcrtc: drm_crtc* of crtc which defines scanout timing.
 * @@mode: mode which defines the scanout timings
 *
 * Returns negative value on error, failure or if not supported in current
d769 1
a769 1
 * -EINVAL   - Invalid crtc.
d780 2
a781 1
int drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev, int crtc,
a784 1
					  const struct drm_crtc *refcrtc,
a786 1
	ktime_t stime, etime, mono_time_offset;
d788 3
a790 1
	int vbl_status;
d792 1
a792 2
	int framedur_ns, linedur_ns, pixeldur_ns, delta_ns, duration_ns;
	bool invbl;
d794 2
a795 2
	if (crtc < 0 || crtc >= dev->num_crtcs) {
		DRM_ERROR("Invalid crtc %d\n", crtc);
a804 5
	/* Durations of frames, lines, pixels in nanoseconds. */
	framedur_ns = refcrtc->framedur_ns;
	linedur_ns  = refcrtc->linedur_ns;
	pixeldur_ns = refcrtc->pixeldur_ns;

d808 2
a809 2
	if (framedur_ns == 0) {
		DRM_DEBUG("crtc %d: Noop due to uninitialized mode.\n", crtc);
d825 4
a828 9
		vbl_status = dev->driver->get_scanout_position(dev, crtc, flags, &vpos,
							       &hpos, &stime, &etime);

		/*
		 * Get correction for CLOCK_MONOTONIC -> CLOCK_REALTIME if
		 * CLOCK_REALTIME is requested.
		 */
		if (!drm_timestamp_monotonic)
			mono_time_offset = ktime_get_monotonic_offset();
d832 2
a833 2
			DRM_DEBUG("crtc %d : scanoutpos query failed [%d].\n",
				  crtc, vbl_status);
d847 2
a848 2
		DRM_DEBUG("crtc %d: Noisy timestamp %d us > %d us [%d reps].\n",
			  crtc, duration_ns/1000, *max_error/1000, i);
d859 2
a860 1
	invbl = vbl_status & DRM_SCANOUTPOS_INVBL;
d866 2
a867 1
	delta_ns = vpos * linedur_ns + hpos * pixeldur_ns;
d870 1
a870 1
		etime = ktime_sub(etime, mono_time_offset);
d883 5
a887 9
	VBL_DEBUG("crtc %d : v %d p(%d,%d)@@ %ld.%ld -> %ld.%ld [e %d us, %d rep]\n",
		  crtc, (int)vbl_status, hpos, vpos,
		  (long)tv_etime.tv_sec, (long)tv_etime.tv_usec,
		  (long)vblank_time->tv_sec, (long)vblank_time->tv_usec,
		  duration_ns/1000, i);

	vbl_status = DRM_VBLANKTIME_SCANOUTPOS_METHOD;
	if (invbl)
		vbl_status |= DRM_VBLANKTIME_INVBL;
d889 1
a889 1
	return vbl_status;
d897 1
a897 4
	now = ktime_get();
	if (!drm_timestamp_monotonic)
		now = ktime_sub(now, ktime_get_monotonic_offset());

d903 1
a903 2
 * vblank interval.
 *
d905 1
a905 1
 * @@crtc: which crtc's vblank timestamp to retrieve
d908 2
a909 2
 *         0 = Default.
 *         DRM_CALLED_FROM_VBLIRQ = If function is called from vbl irq handler.
d912 1
a912 1
 * vblank interval on specified crtc. May call into kms-driver to
d918 2
a919 1
 * Returns non-zero if timestamp is considered to be very precise.
d921 3
a923 2
u32 drm_get_last_vbltimestamp(struct drm_device *dev, int crtc,
			      struct timeval *tvblank, unsigned flags)
d932 1
a932 1
		ret = dev->driver->get_vblank_timestamp(dev, crtc, &max_error,
d935 1
a935 1
			return (u32) ret;
d943 1
a943 1
	return 0;
a944 1
EXPORT_SYMBOL(drm_get_last_vbltimestamp);
d949 1
a949 1
 * @@crtc: which counter to retrieve
d954 5
d960 1
a960 1
u32 drm_vblank_count(struct drm_device *dev, int crtc)
d962 6
a967 1
	return atomic_read(&dev->vblank[crtc].count);
d972 2
a973 2
 * drm_vblank_count_and_time - retrieve "cooked" vblank counter value
 * and the system timestamp corresponding to that vblank counter value.
d975 18
d994 1
a994 1
 * @@crtc: which counter to retrieve
d1000 3
a1002 2
 * of the vblank interval that corresponds to the current value vblank counter
 * value.
d1004 1
a1004 1
u32 drm_vblank_count_and_time(struct drm_device *dev, int crtc,
d1007 2
d1011 7
a1017 4
	/* Read timestamp from slot of _vblank_time ringbuffer
	 * that corresponds to current vblank count. Retry if
	 * count has incremented during readout. This works like
	 * a seqlock.
d1020 3
a1022 2
		cur_vblank = atomic_read(&dev->vblank[crtc].count);
		*vblanktime = vblanktimestamp(dev, crtc, cur_vblank);
d1024 1
a1024 1
	} while (cur_vblank != atomic_read(&dev->vblank[crtc].count));
d1030 21
d1055 2
a1056 1
	MUTEX_ASSERT_LOCKED(&dev->event_lock);
d1064 1
d1066 1
d1072 51
d1125 1
a1125 1
 * @@crtc: CRTC in question
d1130 2
d1133 2
a1134 2
void drm_send_vblank_event(struct drm_device *dev, int crtc,
		struct drm_pending_vblank_event *e)
d1138 3
a1140 2
	if (crtc >= 0) {
		seq = drm_vblank_count_and_time(dev, crtc, &now);
d1146 1
a1146 1
	e->pipe = crtc;
d1152 3
a1154 3
 * drm_update_vblank_count - update the master vblank counter
 * @@dev: DRM device
 * @@crtc: counter to update
d1156 2
a1157 4
 * Call back into the driver to update the appropriate vblank counter
 * (specified by @@crtc).  Deal with wraparound, if it occurred, and
 * update the last read value so we can deal with wraparound on the next
 * call if necessary.
d1159 13
a1171 2
 * Only necessary when going from off->on, to account for frames we
 * didn't get an interrupt for.
d1173 2
a1174 2
 * Note: caller must hold dev->vbl_lock since this reads & writes
 * device vblank fields.
d1176 1
a1176 1
static void drm_update_vblank_count(struct drm_device *dev, int crtc)
d1178 2
a1179 2
	u32 cur_vblank, diff, tslot, rc;
	struct timeval t_vblank;
d1181 1
a1181 16
	/*
	 * Interrupts were disabled prior to this call, so deal with counter
	 * wrap if needed.
	 * NOTE!  It's possible we lost a full dev->max_vblank_count events
	 * here if the register is small or we had vblank interrupts off for
	 * a long time.
	 *
	 * We repeat the hardware vblank counter & timestamp query until
	 * we get consistent results. This to prevent races between gpu
	 * updating its hardware counter while we are retrieving the
	 * corresponding vblank timestamp.
	 */
	do {
		cur_vblank = dev->driver->get_vblank_counter(dev, crtc);
		rc = drm_get_last_vbltimestamp(dev, crtc, &t_vblank, 0);
	} while (cur_vblank != dev->driver->get_vblank_counter(dev, crtc));
d1183 1
a1183 4
	/* Deal with counter wrap */
	diff = cur_vblank - dev->vblank[crtc].last;
	if (cur_vblank < dev->vblank[crtc].last) {
		diff += dev->max_vblank_count;
d1185 16
a1200 2
		DRM_DEBUG("last_vblank[%d]=0x%x, cur_vblank=0x%x => diff=0x%x\n",
			  crtc, dev->vblank[crtc].last, cur_vblank, diff);
d1203 1
a1203 2
	VBL_DEBUG("enabling vblank interrupts on crtc %d, missed %d\n",
		  crtc, diff);
d1205 1
a1205 12
	/* Reinitialize corresponding vblank timestamp if high-precision query
	 * available. Skip this step if query unsupported or failed. Will
	 * reinitialize delayed at next vblank interrupt in that case.
	 */
	if (rc) {
		tslot = atomic_read(&dev->vblank[crtc].count) + diff;
		vblanktimestamp(dev, crtc, tslot) = t_vblank;
	}

	smp_mb__before_atomic_inc();
	atomic_add(diff, &dev->vblank[crtc].count);
	smp_mb__after_atomic_inc();
d1211 1
a1211 1
 * @@crtc: which CRTC to own
d1216 4
a1219 2
 * RETURNS
 * Zero on success, nonzero on failure.
d1221 1
a1221 1
int drm_vblank_get(struct drm_device *dev, int crtc)
d1223 2
a1224 1
	unsigned long irqflags, irqflags2;
d1227 6
d1235 2
a1236 20
	if (atomic_add_return(1, &dev->vblank[crtc].refcount) == 1) {
		spin_lock_irqsave(&dev->vblank_time_lock, irqflags2);
		if (!dev->vblank[crtc].enabled) {
			/* Enable vblank irqs under vblank_time_lock protection.
			 * All vblank count & timestamp updates are held off
			 * until we are done reinitializing master counter and
			 * timestamps. Filtercode in drm_handle_vblank() will
			 * prevent double-accounting of same vblank interval.
			 */
			ret = dev->driver->enable_vblank(dev, crtc);
			VBL_DEBUG("enabling vblank on crtc %d, ret: %d\n",
				  crtc, ret);
			if (ret)
				atomic_dec(&dev->vblank[crtc].refcount);
			else {
				dev->vblank[crtc].enabled = true;
				drm_update_vblank_count(dev, crtc);
			}
		}
		spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags2);
d1238 2
a1239 2
		if (!dev->vblank[crtc].enabled) {
			atomic_dec(&dev->vblank[crtc].refcount);
d1250 19
a1268 1
 * drm_vblank_put - give up ownership of vblank events
d1270 1
a1270 1
 * @@crtc: which counter to give up
d1274 2
d1277 1
a1277 1
void drm_vblank_put(struct drm_device *dev, int crtc)
d1279 7
a1285 1
	BUG_ON(atomic_read(&dev->vblank[crtc].refcount) == 0);
d1288 9
a1296 4
	if (atomic_dec_and_test(&dev->vblank[crtc].refcount) &&
	    (drm_vblank_offdelay > 0))
		mod_timer(&dev->vblank_disable_timer,
			  jiffies + ((drm_vblank_offdelay * HZ)/1000));
d1301 63
d1366 8
a1373 1
 * @@crtc: CRTC in question
d1375 1
a1375 1
 * Caller must hold event lock.
d1377 1
a1377 1
void drm_vblank_off(struct drm_device *dev, int crtc)
d1379 1
d1385 24
a1408 3
	spin_lock_irqsave(&dev->vbl_lock, irqflags);
	vblank_disable_and_save(dev, crtc);
	wake_up(&dev->vblank[crtc].queue);
d1411 1
a1411 1
	seq = drm_vblank_count_and_time(dev, crtc, &now);
a1412 1
	spin_lock(&dev->event_lock);
d1414 1
a1414 1
		if (e->pipe != crtc)
d1416 2
a1417 2
		DRM_DEBUG("Sending premature vblank event on disable: \
			  wanted %d, current %d\n",
d1420 1
a1420 1
		drm_vblank_put(dev, e->pipe);
d1423 3
a1425 1
	spin_unlock(&dev->event_lock);
d1427 89
d1518 18
a1535 1
EXPORT_SYMBOL(drm_vblank_off);
d1540 1
a1540 1
 * @@crtc: CRTC in question
d1544 15
d1560 1
a1560 1
void drm_vblank_pre_modeset(struct drm_device *dev, int crtc)
d1562 2
d1567 4
d1578 4
a1581 4
	if (!dev->vblank[crtc].inmodeset) {
		dev->vblank[crtc].inmodeset = 0x1;
		if (drm_vblank_get(dev, crtc) == 0)
			dev->vblank[crtc].inmodeset |= 0x2;
d1586 9
a1594 1
void drm_vblank_post_modeset(struct drm_device *dev, int crtc)
d1596 1
d1603 4
a1606 1
	if (dev->vblank[crtc].inmodeset) {
d1609 1
d1612 2
a1613 2
		if (dev->vblank[crtc].inmodeset & 0x2)
			drm_vblank_put(dev, crtc);
d1615 1
a1615 1
		dev->vblank[crtc].inmodeset = 0;
d1620 1
a1620 1
/**
d1635 1
a1635 1
	unsigned int crtc;
d1645 2
a1646 2
	crtc = modeset->crtc;
	if (crtc >= dev->num_crtcs)
d1651 1
a1651 1
		drm_vblank_pre_modeset(dev, crtc);
d1654 1
a1654 1
		drm_vblank_post_modeset(dev, crtc);
d1663 1
a1663 1
static int drm_queue_vblank_event(struct drm_device *dev, int pipe,
d1667 1
d1674 1
a1674 1
	e = kzalloc(sizeof *e, GFP_KERNEL);
d1681 5
a1685 1
	e->base.pid = curproc->p_tid;	/* XXX */
d1687 1
a1687 1
	e->event.base.length = sizeof e->event;
d1695 13
a1707 1
	if (file_priv->event_space < sizeof e->event) {
d1712 1
a1712 1
	file_priv->event_space -= sizeof e->event;
d1721 1
a1721 1
	DRM_DEBUG("event on vblank count %d, current %d, crtc %d\n",
d1724 5
a1728 1
	trace_drm_vblank_event_queued(curproc->p_tid, pipe,
d1730 1
d1755 1
a1755 1
/**
d1766 1
a1766 1
 * the vblank interrupt refcount afterwards. (vblank irq disable follows that
d1772 1
d1775 1
a1775 1
	unsigned int flags, seq, crtc, high_crtc;
d1777 2
a1778 3
	if (drm_core_check_feature(dev, DRIVER_HAVE_IRQ))
		if ((!drm_dev_to_irq(dev)) || (!dev->irq_enabled))
			return -EINVAL;
d1794 3
a1796 3
	high_crtc = (vblwait->request.type & _DRM_VBLANK_HIGH_CRTC_MASK);
	if (high_crtc)
		crtc = high_crtc >> _DRM_VBLANK_HIGH_CRTC_SHIFT;
d1798 2
a1799 2
		crtc = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;
	if (crtc >= dev->num_crtcs)
d1802 3
a1804 1
	ret = drm_vblank_get(dev, crtc);
d1809 1
a1809 1
	seq = drm_vblank_count(dev, crtc);
d1826 1
a1826 1
		return drm_queue_vblank_event(dev, crtc, vblwait, file_priv);
d1834 5
a1838 5
	DRM_DEBUG("waiting on vblank count %d, crtc %d\n",
		  vblwait->request.sequence, crtc);
	dev->vblank[crtc].last_wait = vblwait->request.sequence;
	DRM_WAIT_ON(ret, dev->vblank[crtc].queue, 3 * HZ,
		    (((drm_vblank_count(dev, crtc) -
d1840 1
d1846 1
a1846 1
		vblwait->reply.sequence = drm_vblank_count_and_time(dev, crtc, &now);
d1857 1
a1857 1
	drm_vblank_put(dev, crtc);
d1861 1
a1861 1
static void drm_handle_vblank_events(struct drm_device *dev, int crtc)
a1864 1
	unsigned long flags;
d1867 1
a1867 1
	seq = drm_vblank_count_and_time(dev, crtc, &now);
d1869 1
a1869 1
	spin_lock_irqsave(&dev->event_lock, flags);
d1872 1
a1872 1
		if (e->pipe != crtc)
d1877 1
a1877 1
		VBL_DEBUG("vblank event on %d, current %d\n",
d1881 1
a1881 1
		drm_vblank_put(dev, e->pipe);
d1885 1
a1885 3
	spin_unlock_irqrestore(&dev->event_lock, flags);

	trace_drm_vblank_event(crtc, seq);
d1891 1
a1891 1
 * @@crtc: where this event occurred
d1895 2
d1898 1
a1898 1
bool drm_handle_vblank(struct drm_device *dev, int crtc)
d1900 1
a1900 3
	u32 vblcount;
	s64 diff_ns;
	struct timeval tvblank;
d1903 4
a1906 1
	if (!dev->num_crtcs)
d1909 2
d1915 1
a1915 1
	spin_lock_irqsave(&dev->vblank_time_lock, irqflags);
d1918 3
a1920 2
	if (!dev->vblank[crtc].enabled) {
		spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);
d1924 1
a1924 3
	/* Fetch corresponding timestamp for this vblank interval from
	 * driver and store it in proper slot of timestamp ringbuffer.
	 */
d1926 1
a1926 20
	/* Get current timestamp and count. */
	vblcount = atomic_read(&dev->vblank[crtc].count);
	drm_get_last_vbltimestamp(dev, crtc, &tvblank, DRM_CALLED_FROM_VBLIRQ);

	/* Compute time difference to timestamp of last vblank */
	diff_ns = timeval_to_ns(&tvblank) -
		  timeval_to_ns(&vblanktimestamp(dev, crtc, vblcount));

	/* Update vblank timestamp and count if at least
	 * DRM_REDUNDANT_VBLIRQ_THRESH_NS nanoseconds
	 * difference between last stored timestamp and current
	 * timestamp. A smaller difference means basically
	 * identical timestamps. Happens if this vblank has
	 * been already processed and this is a redundant call,
	 * e.g., due to spurious vblank interrupts. We need to
	 * ignore those for accounting.
	 */
	if (abs64(diff_ns) > DRM_REDUNDANT_VBLIRQ_THRESH_NS) {
		/* Store new timestamp in ringbuffer. */
		vblanktimestamp(dev, crtc, vblcount + 1) = tvblank;
d1928 2
a1929 10
		/* Increment cooked vblank count. This also atomically commits
		 * the timestamp computed above.
		 */
		smp_mb__before_atomic_inc();
		atomic_inc(&dev->vblank[crtc].count);
		smp_mb__after_atomic_inc();
	} else {
		DRM_DEBUG("crtc %d: Redundant vblirq ignored. diff_ns = %d\n",
			  crtc, (int) diff_ns);
	}
d1931 1
a1931 2
	wake_up(&dev->vblank[crtc].queue);
	drm_handle_vblank_events(dev, crtc);
a1932 1
	spin_unlock_irqrestore(&dev->vblank_time_lock, irqflags);
d1936 35
@


1.66
log
@Update drm_irq.c to the version from Linux 3.14.52.
Disable the DRM_IOCTL_IRQ_BUSID and DRM_IOCTL_CONTROL ioctls.
These are legacy ioctls for DRI1 support, which we no longer support on
OpenBSD.
@
text
@d1114 1
a1114 1
	e->base.pid = curproc->p_pid;
d1141 1
a1141 1
	trace_drm_vblank_event_queued(curproc->p_pid, pipe,
@


1.65
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@a0 1
/*	$OpenBSD: drm_irq.c,v 1.64 2015/04/18 14:47:34 jsg Exp $	*/
d36 2
a37 1
#include <sys/task.h>
d39 5
a43 2
#include "drmP.h"
#include "drm.h"
d46 2
a47 3
#define vblanktimestamp(dev, crtc, count) ( \
	(dev)->_vblank_time[(crtc) * DRM_VBLANKTIME_RBSIZE + \
	((count) % DRM_VBLANKTIME_RBSIZE)])
a58 6
#ifdef DRM_VBLANK_DEBUG
#define DPRINTF(x...)	do { printf(x); } while(/* CONSTCOND */ 0)
#else
#define DPRINTF(x...)	do { } while(/* CONSTCOND */ 0)
#endif

d67 1
d84 1
a84 1
	struct drm_irq_busid	*irq = data;
d86 2
a87 6
	/*
	 * This is only ever called by root as part of a stupid interface.
	 * just hand over the irq without checking the busid. If all clients
	 * can be forced to use interface 1.2 then this can die.
	 */
	irq->irq = dev->irq;
d89 2
a90 2
	DRM_DEBUG("%d:%d:%d => IRQ %d\n", irq->busnum, irq->devnum,
	    irq->funcnum, irq->irq);
d92 1
a92 1
	return 0;
d94 1
d101 1
a101 2
	memset(&dev->_vblank_time[crtc * DRM_VBLANKTIME_RBSIZE], 0,
		DRM_VBLANKTIME_RBSIZE * sizeof(struct timeval));
d126 1
a126 1
	dev->vblank_enabled[crtc] = 0;
d141 1
a141 1
		dev->last_vblank[crtc] = dev->driver->get_vblank_counter(dev, crtc);
d143 1
a143 1
	} while (dev->last_vblank[crtc] != dev->driver->get_vblank_counter(dev, crtc) && (--count) && vblrc);
d151 1
a151 1
	vblcount = atomic_read(&dev->_vblank_count[crtc]);
d168 1
a168 1
		atomic_inc(&dev->_vblank_count[crtc]);
d178 1
a178 1
static void vblank_disable_fn(void *arg)
d189 2
a190 2
		if (atomic_read(&dev->vblank_refcount[i]) == 0 &&
		    dev->vblank_enabled[i]) {
d204 1
a204 1
	timeout_del(&dev->vblank_disable_timer);
d206 1
a206 1
	vblank_disable_fn(dev);
d208 1
a208 8
	kfree(dev->vbl_queue);
	kfree(dev->_vblank_count);
	kfree(dev->vblank_refcount);
	kfree(dev->vblank_enabled);
	kfree(dev->last_vblank);
	kfree(dev->last_vblank_wait);
	kfree(dev->vblank_inmodeset);
	kfree(dev->_vblank_time);
d218 2
a219 2
	timeout_set(&dev->vblank_disable_timer, vblank_disable_fn,
	    dev);
d225 2
a226 7
	dev->vbl_queue = kmalloc(sizeof(wait_queue_head_t) * num_crtcs,
				 GFP_KERNEL);
	if (!dev->vbl_queue)
		goto err;

	dev->_vblank_count = kmalloc(sizeof(atomic_t) * num_crtcs, GFP_KERNEL);
	if (!dev->_vblank_count)
d229 2
a230 4
	dev->vblank_refcount = kmalloc(sizeof(atomic_t) * num_crtcs,
				       GFP_KERNEL);
	if (!dev->vblank_refcount)
		goto err;
d232 1
a232 22
	dev->vblank_enabled = kcalloc(num_crtcs, sizeof(int), GFP_KERNEL);
	if (!dev->vblank_enabled)
		goto err;

	dev->last_vblank = kcalloc(num_crtcs, sizeof(u32), GFP_KERNEL);
	if (!dev->last_vblank)
		goto err;

	dev->last_vblank_wait = kcalloc(num_crtcs, sizeof(u32), GFP_KERNEL);
	if (!dev->last_vblank_wait)
		goto err;

	dev->vblank_inmodeset = kcalloc(num_crtcs, sizeof(int), GFP_KERNEL);
	if (!dev->vblank_inmodeset)
		goto err;

	dev->_vblank_time = kcalloc(num_crtcs * DRM_VBLANKTIME_RBSIZE,
				    sizeof(struct timeval), GFP_KERNEL);
	if (!dev->_vblank_time)
		goto err;

	DRM_INFO("Supports vblank timestamp caching Rev 1 (10.10.2010).\n");
d240 1
a240 6
	/* Zero per-crtc vblank stuff */
	for (i = 0; i < num_crtcs; i++) {
		init_waitqueue_head(&dev->vbl_queue[i]);
		atomic_set(&dev->_vblank_count[i], 0);
		atomic_set(&dev->vblank_refcount[i], 0);
	}
a241 1
	dev->vblank_disable_allowed = 0;
d250 1
a250 1
#ifdef notyet
a254 1
#ifdef notyet
a258 1
#endif
d286 5
a290 1
	int	ret;
d292 1
a292 1
	if (dev->irq == 0 || dev->dev_private == NULL)
d295 2
a296 1
	DRM_DEBUG("irq=%d\n", dev->irq);
d299 7
d310 1
a310 1
	dev->irq_enabled = 1;
d313 43
a355 8
	if (dev->driver->irq_install) {
		if ((ret = dev->driver->irq_install(dev)) != 0)
			goto err;
	} else {
		if (dev->driver->irq_preinstall)
			dev->driver->irq_preinstall(dev);
		if (dev->driver->irq_postinstall)
			dev->driver->irq_postinstall(dev);
a357 5
	return 0;
err:
	mutex_lock(&dev->struct_mutex);
	dev->irq_enabled = 0;
	mutex_unlock(&dev->struct_mutex);
d372 1
d375 1
a375 3
	mutex_lock(&dev->struct_mutex);
	if (!dev->irq_enabled) {
		mutex_unlock(&dev->struct_mutex);
a376 1
	}
d378 3
a380 1
	dev->irq_enabled = 0;
d384 1
a384 3
	 * Ick. we're about to turn of vblanks, so make sure anyone waiting
	 * on them gets woken up. Also make sure we update state correctly
	 * so that we can continue refcounting correctly.
d389 3
a391 3
			DRM_WAKEUP(&dev->vbl_queue[i]);
			dev->vblank_enabled[i] = 0;
			dev->last_vblank[i] =
d397 4
a400 1
	DRM_DEBUG("irq=%d\n", dev->irq);
d402 11
a412 1
	dev->driver->irq_uninstall(dev);
d418 1
d435 4
a438 3
	/* Handle drivers who used to require IRQ setup no longer does. */
	if (!(dev->driver->flags & DRIVER_IRQ))
		return 0;
d442 2
d447 1
a447 1
		    ctl->irq != dev->irq)
d451 2
d460 1
d544 1
d567 3
a569 5
	struct timeval stime, etime;
#ifdef notyet
	struct timeval mono_time_offset;
#endif
	int vbl_status, vtotal, vdisplay;
d571 1
a571 1
	s64 framedur_ns, linedur_ns, pixeldur_ns, delta_ns, duration_ns;
a584 4
	mode = &refcrtc->hwmode;
	vtotal = mode->crtc_vtotal;
	vdisplay = mode->crtc_vdisplay;

d593 1
a593 1
	if (vtotal <= 0 || vdisplay <= 0 || framedur_ns == 0) {
d606 3
a608 2
		/* Disable preemption to make it very likely to
		 * succeed in the first iteration even on PREEMPT_RT kernel.
a609 8
#ifdef notyet
		preempt_disable();
#endif

		/* Get system timestamp before query. */
		getmicrouptime(&stime);

		/* Get vertical and horizontal scanout pos. vpos, hpos. */
d613 4
a616 3
		/* Get system timestamp after query. */
		getmicrouptime(&etime);
#ifdef notyet
a619 3
		preempt_enable();
#endif

d627 2
a628 1
		duration_ns = timeval_to_ns(&etime) - timeval_to_ns(&stime);
d631 1
a631 1
		if (duration_ns <= (s64) *max_error)
d638 1
a638 1
			  crtc, (int) duration_ns/1000, *max_error/1000, i);
d642 1
a642 1
	*max_error = (int) duration_ns;
d655 1
a655 1
	delta_ns = (s64) vpos * linedur_ns + (s64) hpos * pixeldur_ns;
a656 19
	/* Is vpos outside nominal vblank area, but less than
	 * 1/100 of a frame height away from start of vblank?
	 * If so, assume this isn't a massively delayed vblank
	 * interrupt, but a vblank interrupt that fired a few
	 * microseconds before true start of vblank. Compensate
	 * by adding a full frame duration to the final timestamp.
	 * Happens, e.g., on ATI R500, R600.
	 *
	 * We only do this if DRM_CALLED_FROM_VBLIRQ.
	 */
	if ((flags & DRM_CALLED_FROM_VBLIRQ) && !invbl &&
	    ((vdisplay - vpos) < vtotal / 100)) {
		delta_ns = delta_ns - framedur_ns;

		/* Signal this correction as "applied". */
		vbl_status |= 0x8;
	}

#ifdef notyet
a658 1
#endif
d660 2
d665 5
a669 1
	*vblank_time = ns_to_timeval(timeval_to_ns(&etime) - delta_ns);
d671 1
a671 1
	DPRINTF("crtc %d : v %d p(%d,%d)@@ %lld.%ld -> %lld.%ld [e %d us, %d rep]\n",
d673 3
a675 3
		  (long long)etime.tv_sec, (long)etime.tv_usec,
		  (long long)vblank_time->tv_sec, (long)vblank_time->tv_usec,
		  (int)duration_ns/1000, i);
d687 1
a687 1
	struct timeval now;
d689 1
a689 2
	getmicrouptime(&now);
#ifdef notyet
a691 1
#endif
d693 1
a693 1
	return (now);
d752 1
a752 1
	return atomic_read(&dev->_vblank_count[crtc]);
d781 1
a781 1
		cur_vblank = atomic_read(&dev->_vblank_count[crtc]);
d784 1
a784 1
	} while (cur_vblank != atomic_read(&dev->_vblank_count[crtc]));
a793 1
	struct drm_file *file_priv = e->base.file_priv;
d799 4
a802 4
	TAILQ_INSERT_TAIL(&file_priv->evlist, &e->base, link);
	wakeup(&file_priv->evlist);
	selwakeup(&file_priv->rsel);
#if 0
a804 1
#endif
d828 1
d872 2
a873 2
	diff = cur_vblank - dev->last_vblank[crtc];
	if (cur_vblank < dev->last_vblank[crtc]) {
d877 1
a877 1
			  crtc, dev->last_vblank[crtc], cur_vblank, diff);
d880 1
a880 1
	DPRINTF("enabling vblank interrupts on crtc %d, missed %d\n",
d888 1
a888 1
		tslot = atomic_read(&dev->_vblank_count[crtc]) + diff;
d893 1
a893 1
	atomic_add(diff, &dev->_vblank_count[crtc]);
d915 1
a915 1
	if (atomic_add_return(1, &dev->vblank_refcount[crtc]) == 1) {
d917 1
a917 1
		if (!dev->vblank_enabled[crtc]) {
d925 1
a925 1
			DPRINTF("enabling vblank on crtc %d, ret: %d\n",
d928 1
a928 1
				atomic_dec(&dev->vblank_refcount[crtc]);
d930 1
a930 1
				dev->vblank_enabled[crtc] = 1;
d936 2
a937 2
		if (!dev->vblank_enabled[crtc]) {
			atomic_dec(&dev->vblank_refcount[crtc]);
d957 1
a957 1
	BUG_ON(atomic_read(&dev->vblank_refcount[crtc]) == 0);
d960 1
a960 1
	if (atomic_dec_and_test(&dev->vblank_refcount[crtc]) &&
d962 2
a963 1
		timeout_add_msec(&dev->vblank_disable_timer, drm_vblank_offdelay);
d976 1
a976 3
	struct drmevlist *list;
	struct drm_pending_event *ev, *tmp;
	struct drm_pending_vblank_event *vev;
d983 1
a983 1
	DRM_WAKEUP(&dev->vbl_queue[crtc]);
a984 1
	list = &dev->vbl_events;
d989 2
a990 6
	for (ev = TAILQ_FIRST(list); ev != NULL; ev = tmp) {
		tmp = TAILQ_NEXT(ev, link);

		vev = (struct drm_pending_vblank_event *)ev;

		if (vev->pipe != crtc)
d994 4
a997 4
			  vev->event.sequence, seq);
		TAILQ_REMOVE(list, ev, link);
		drm_vblank_put(dev, vev->pipe);
		send_vblank_event(dev, vev, seq, &now);
d1025 2
a1026 2
	if (!dev->vblank_inmodeset[crtc]) {
		dev->vblank_inmodeset[crtc] = 0x1;
d1028 1
a1028 1
			dev->vblank_inmodeset[crtc] |= 0x2;
d1041 1
a1041 1
	if (dev->vblank_inmodeset[crtc]) {
d1043 1
a1043 1
		dev->vblank_disable_allowed = 1;
d1046 1
a1046 1
		if (dev->vblank_inmodeset[crtc] & 0x2)
d1049 1
a1049 1
		dev->vblank_inmodeset[crtc] = 0;
d1114 1
a1114 1
	e->base.pid = DRM_CURRENTPID;
d1141 1
a1141 2
#if 0
	trace_drm_vblank_event_queued(current->pid, pipe,
a1142 1
#endif
d1151 1
a1151 1
		TAILQ_INSERT_TAIL(&dev->vbl_events, &e->base, link);
d1188 3
a1190 2
	if (!dev->irq_enabled)
		return -EINVAL;
d1246 3
a1248 3
	dev->last_vblank_wait[crtc] = vblwait->request.sequence;
	DRM_WAIT_ON(ret, &dev->vbl_queue[crtc], &dev->vbl_lock, 3 * hz,
		    "drmvblq", (((drm_vblank_count(dev, crtc) -
d1272 1
a1272 3
	struct drmevlist *list;
	struct drm_pending_event *ev, *tmp;
	struct drm_pending_vblank_event *vev;
a1276 1
	list = &dev->vbl_events;
d1281 2
a1282 6
	for (ev = TAILQ_FIRST(list); ev != NULL; ev = tmp) {
		tmp = TAILQ_NEXT(ev, link);

		vev = (struct drm_pending_vblank_event *)ev;

		if (vev->pipe != crtc)
d1284 1
a1284 1
		if ((seq - vev->event.sequence) > (1<<23))
d1287 2
a1288 2
		DPRINTF("vblank event on %d, current %d\n",
			  vev->event.sequence, seq);
d1290 3
a1292 3
		TAILQ_REMOVE(list, ev, link);
		drm_vblank_put(dev, vev->pipe);
		send_vblank_event(dev, vev, seq, &now);
d1297 1
a1297 1
//	trace_drm_vblank_event(crtc, seq);
d1325 1
a1325 1
	if (!dev->vblank_enabled[crtc]) {
d1335 1
a1335 1
	vblcount = atomic_read(&dev->_vblank_count[crtc]);
d1359 1
a1359 1
		atomic_inc(&dev->_vblank_count[crtc]);
d1366 1
a1366 1
	DRM_WAKEUP(&dev->vbl_queue[crtc]);
@


1.64
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.63 2015/04/15 09:48:19 kettenis Exp $	*/
d453 1
a453 7
 * drm_calc_timestamping_constants - Calculate and
 * store various constants which are later needed by
 * vblank and swap-completion timestamping, e.g, by
 * drm_calc_vbltimestamp_from_scanoutpos().
 * They are derived from crtc's true scanout timing,
 * so they take things like panel scaling or other
 * adjustments into account.
d456 1
d458 5
d464 2
a465 1
void drm_calc_timestamping_constants(struct drm_crtc *crtc)
d467 2
a468 2
	s64 linedur_ns = 0, pixeldur_ns = 0, framedur_ns = 0;
	u64 dotclock;
d470 3
a472 2
	/* Dot clock in Hz: */
	dotclock = (u64) crtc->hwmode.clock * 1000;
d474 8
a481 5
	/* Fields of interlaced scanout modes are only halve a frame duration.
	 * Double the dotclock to get halve the frame-/line-/pixelduration.
	 */
	if (crtc->hwmode.flags & DRM_MODE_FLAG_INTERLACE)
		dotclock *= 2;
d483 2
a484 5
	/* Valid dotclock? */
	if (dotclock > 0) {
		/* Convert scanline length in pixels and video dot clock to
		 * line duration, frame duration and pixel duration in
		 * nanoseconds:
d486 2
a487 4
		pixeldur_ns = (s64) div64_u64(1000000000, dotclock);
		linedur_ns  = (s64) div64_u64(((u64) crtc->hwmode.crtc_htotal *
					      1000000000), dotclock);
		framedur_ns = (s64) crtc->hwmode.crtc_vtotal * linedur_ns;
d496 6
a501 6
	DPRINTF("crtc %d: hwmode: htotal %d, vtotal %d, vdisplay %d\n",
		  crtc->base.id, crtc->hwmode.crtc_htotal,
		  crtc->hwmode.crtc_vtotal, crtc->hwmode.crtc_vdisplay);
	DPRINTF("crtc %d: clock %d kHz framedur %d linedur %d, pixeldur %d\n",
		  crtc->base.id, (int) dotclock/1000, (int) framedur_ns,
		  (int) linedur_ns, (int) pixeldur_ns);
d553 2
a554 1
					  struct drm_crtc *refcrtc)
a559 1
	struct drm_display_mode *mode;
d612 2
a613 1
		vbl_status = dev->driver->get_scanout_position(dev, crtc, &vpos, &hpos);
@


1.63
log
@Convert remaining drm ioctl implementation functions to return Linux-style
negative errno values.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.62 2015/04/12 03:54:10 jsg Exp $	*/
d399 1
a399 1
			wakeup(&dev->vbl_queue[i]);
d402 1
a402 1
			    dev->driver->get_vblank_counter(dev, i);
d484 3
a486 3
		pixeldur_ns = (s64) 1000000000 / dotclock;
		linedur_ns  = (s64) ((u64) crtc->hwmode.crtc_htotal *
					      1000000000) / dotclock;
d983 1
d1003 1
a1003 1
	wakeup(&dev->vbl_queue[crtc]);
d1028 1
d1399 1
a1399 1
	wakeup(&dev->vbl_queue[crtc]);
@


1.62
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.61 2015/04/06 12:25:10 jsg Exp $	*/
d339 1
a339 1
		return (EINVAL);
d346 1
a346 1
		return (EBUSY);
d361 1
a361 1
	return (0);
d366 1
a366 1
	return (ret);
d385 1
a385 1
		return (EINVAL);
d411 1
a411 1
	return (0);
d433 1
a433 1
		return (0);
d441 2
a442 2
			return (EINVAL);
		return (drm_irq_install(dev));
d446 1
a446 1
		return (drm_irq_uninstall(dev));
d448 1
a448 1
		return (EINVAL);
@


1.61
log
@move some inline linux compat into the dedicated files
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.60 2015/04/05 12:53:41 kettenis Exp $	*/
d239 1
a239 1
	dev->vbl_queue = kmalloc(sizeof(int) * num_crtcs,
d284 1
@


1.60
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.59 2015/02/12 08:48:32 jsg Exp $	*/
a56 3
int64_t	 timeval_to_ns(const struct timeval *);
struct timeval ns_to_timeval(const int64_t);

a108 38
}

#define NSEC_PER_USEC	1000L
#define NSEC_PER_SEC	1000000000L

int64_t
timeval_to_ns(const struct timeval *tv)
{
	return ((int64_t)tv->tv_sec * NSEC_PER_SEC) +
		tv->tv_usec * NSEC_PER_USEC;
}

struct timeval
ns_to_timeval(const int64_t nsec)
{
	struct timeval tv;
	int32_t rem;

	if (nsec == 0) {
		tv.tv_sec = 0;
		tv.tv_usec = 0;
		return (tv);
	}

	tv.tv_sec = nsec / NSEC_PER_SEC;
	rem = nsec % NSEC_PER_SEC;
	if (rem < 0) {
		tv.tv_sec--;
		rem += NSEC_PER_SEC;
	}
	tv.tv_usec = rem / 1000;
	return (tv);
}

static inline int64_t
abs64(int64_t x)
{
	return (x < 0 ? -x : x);
@


1.59
log
@Add and use macros for linux memory barriers.  Fix the call in
i915_gem_object_flush_fence() to be mb() not wmb() while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.58 2015/02/11 07:01:36 jsg Exp $	*/
d469 1
a469 1
	struct drm_control	*ctl = data;
@


1.58
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.57 2015/02/10 10:50:49 jsg Exp $	*/
d841 1
a841 1
		DRM_READMEMORYBARRIER();
@


1.57
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.56 2015/02/10 01:39:32 jsg Exp $	*/
d239 1
a239 1
			DPRINTF("disabling vblank on crtc %d\n", i);
d315 1
a315 1
	DRM_DEBUG("Supports vblank timestamp caching Rev 1 (10.10.2010).\n");
d319 1
a319 1
		DRM_DEBUG("Driver supports precise vblank timestamp query.\n");
d321 1
a321 1
		DRM_DEBUG("No driver support for vblank timestamp query.\n");
d1201 1
a1201 1
	DPRINTF("event on vblank count %d, current %d, crtc %d\n",
d1308 1
a1308 1
	DPRINTF("waiting on vblank count %d, crtc %d\n",
d1323 1
a1323 1
		DPRINTF("returning %d to client\n",
d1326 1
a1326 1
		DPRINTF("vblank wait interrupted by signal\n");
@


1.56
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.55 2014/09/13 16:06:37 doug Exp $	*/
d160 1
d171 1
a171 1
	mtx_enter(&dev->vblank_time_lock);
d223 1
a223 1
	mtx_leave(&dev->vblank_time_lock);
d229 1
d236 1
a236 1
		mtx_enter(&dev->vbl_lock);
d242 1
a242 1
		mtx_leave(&dev->vbl_lock);
d419 1
d437 1
a437 1
		mtx_enter(&dev->vbl_lock);
d444 1
a444 1
		mtx_leave(&dev->vbl_lock);
d969 1
d972 1
a972 1
	mtx_enter(&dev->vbl_lock);
d975 1
a975 1
		mtx_enter(&dev->vblank_time_lock);
d993 1
a993 1
		mtx_leave(&dev->vblank_time_lock);
d1000 1
a1000 1
	mtx_leave(&dev->vbl_lock);
d1037 1
d1040 1
a1040 1
	mtx_enter(&dev->vbl_lock);
d1048 1
a1048 1
	mtx_enter(&dev->event_lock);
d1063 1
a1063 1
	mtx_leave(&dev->event_lock);
d1065 1
a1065 1
	mtx_leave(&dev->vbl_lock);
d1098 2
d1105 1
a1105 1
		mtx_enter(&dev->vbl_lock);
d1107 1
a1107 1
		mtx_leave(&dev->vbl_lock);
d1166 1
d1185 1
a1185 1
	mtx_enter(&dev->event_lock);
d1220 1
a1220 1
	mtx_leave(&dev->event_lock);
d1225 1
a1225 1
	mtx_leave(&dev->event_lock);
d1340 1
d1346 1
a1346 1
	mtx_enter(&dev->event_lock);
d1366 1
a1366 1
	mtx_leave(&dev->event_lock);
d1384 1
d1393 1
a1393 1
	mtx_enter(&dev->vblank_time_lock);
d1397 1
a1397 1
		mtx_leave(&dev->vblank_time_lock);
d1440 1
a1440 1
	mtx_leave(&dev->vblank_time_lock);
@


1.55
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.54 2014/03/09 11:07:18 jsg Exp $	*/
d381 1
a381 1
	DRM_LOCK();
d383 1
a383 1
		DRM_UNLOCK();
d387 1
a387 1
	DRM_UNLOCK();
d401 1
a401 1
	DRM_LOCK();
d403 1
a403 1
	DRM_UNLOCK();
d419 1
a419 1
	DRM_LOCK();
d421 1
a421 1
		DRM_UNLOCK();
d426 1
a426 1
	DRM_UNLOCK();
@


1.54
log
@use linux style memory allocations in shared drm code
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.53 2014/01/24 04:43:56 jsg Exp $	*/
d1044 1
a1044 1
	for (ev = TAILQ_FIRST(list); ev != TAILQ_END(list); ev = tmp) {
d1339 1
a1339 1
	for (ev = TAILQ_FIRST(list); ev != TAILQ_END(list); ev = tmp) {
@


1.53
log
@drm: fix a use-after-free when GPU acceleration disabled

From Huacai Chen
efe4df2ae6302d6fdbb7b460d8747fe50e2aa4d0 in ubuntu 3.8
b7ea85a4fed37835eec78a7be3039c8dc22b8178 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.52 2013/10/29 06:30:57 jsg Exp $	*/
d254 8
a261 8
	free(dev->vbl_queue, M_DRM);
	free(dev->_vblank_count, M_DRM);
	free(dev->vblank_refcount, M_DRM);
	free(dev->vblank_enabled, M_DRM);
	free(dev->last_vblank, M_DRM);
	free(dev->last_vblank_wait, M_DRM);
	free(dev->vblank_inmodeset, M_DRM);
	free(dev->_vblank_time, M_DRM);
d278 2
a279 2
	dev->vbl_queue = malloc(sizeof(int) * num_crtcs,
	    M_DRM, M_WAITOK);
d283 1
a283 2
	dev->_vblank_count = malloc(sizeof(atomic_t) * num_crtcs,
	    M_DRM, M_WAITOK);
d287 2
a288 2
	dev->vblank_refcount = malloc(sizeof(atomic_t) * num_crtcs,
	    M_DRM, M_WAITOK);
d292 1
a292 2
	dev->vblank_enabled = malloc(num_crtcs * sizeof(int),
	    M_DRM, M_ZERO | M_WAITOK);
d296 1
a296 2
	dev->last_vblank = malloc(num_crtcs * sizeof(u32),
	    M_DRM, M_ZERO | M_WAITOK);
d300 1
a300 2
	dev->last_vblank_wait = malloc(num_crtcs * sizeof(u32),
	    M_DRM, M_ZERO | M_WAITOK);
d304 1
a304 2
	dev->vblank_inmodeset = malloc(num_crtcs * sizeof(int),
	    M_DRM, M_ZERO | M_WAITOK);
d308 2
a309 2
	dev->_vblank_time = malloc(num_crtcs * DRM_VBLANKTIME_RBSIZE *
	    sizeof(struct timeval), M_DRM, M_ZERO | M_WAITOK);
d1162 1
a1162 1
	e = malloc(sizeof *e, M_DRM, M_ZERO | M_WAITOK);
d1175 1
a1175 1
	e->base.destroy = (void (*) (struct drm_pending_event *)) drm_free;
d1218 1
a1218 1
	free(e, M_DRM);
@


1.52
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.51 2013/09/24 21:18:58 kettenis Exp $	*/
d1078 1
a1078 1
	/* vblank is not initialized (IRQ not installed ?) */
d1098 4
@


1.51
log
@Make (almost all) atomic operations really atomic.
Potentially fixes a race/panic reported by claudio@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.50 2013/09/24 21:16:24 kettenis Exp $	*/
d37 1
a37 1
#include <sys/workq.h>
@


1.50
log
@Make sure vblank_time_lock blocks interrupts to match Linux.
Potentially fixes a race/panic reported by claudio@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.49 2013/09/02 07:14:22 jsg Exp $	*/
d1020 1
a1020 1
	if ((--dev->vblank_refcount[crtc] == 0) &&
@


1.49
log
@use DRM_MEMORYBARRIER() for smp_mb__*
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.48 2013/09/02 06:25:28 jsg Exp $	*/
d274 1
a274 1
	mtx_init(&dev->vblank_time_lock, IPL_NONE);
@


1.48
log
@add static back to functions that originally had it
reduces the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.47 2013/08/12 04:11:52 jsg Exp $	*/
d216 1
a216 2
//		smp_mb__after_atomic_inc();
		DRM_WRITEMEMORYBARRIER();
d953 1
a953 1
//	smp_mb__before_atomic_inc();
d955 1
a955 1
//	smp_mb__after_atomic_inc();
d1420 1
a1420 1
//		smp_mb__before_atomic_inc();
d1422 1
a1422 1
//		smp_mb__after_atomic_inc();
@


1.47
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.46 2013/07/01 06:29:10 brad Exp $	*/
a56 5
void	 clear_vblank_timestamps(struct drm_device *, int);
void	 vblank_disable_and_save(struct drm_device *, int);
u32	 drm_get_last_vbltimestamp(struct drm_device *, int, struct timeval *,
	     unsigned);
void	 vblank_disable_fn(void *);
a58 9
void	 drm_irq_vgaarb_nokms(void *, bool);
struct timeval get_drm_timestamp(void);
void	 send_vblank_event(struct drm_device *,
	     struct drm_pending_vblank_event *, unsigned long,
	     struct timeval *);
void	 drm_update_vblank_count(struct drm_device *, int);
int	 drm_queue_vblank_event(struct drm_device *, int,
	     union drm_wait_vblank *, struct drm_file *);
void	 drm_handle_vblank_events(struct drm_device *, int);
d87 2
a88 2
int
drm_irq_by_busid(struct drm_device *dev, void *data, struct drm_file *file_priv)
d108 1
a108 2
void
clear_vblank_timestamps(struct drm_device *dev, int crtc)
d158 1
a158 2
void
vblank_disable_and_save(struct drm_device *dev, int crtc)
d226 1
a226 2
void
vblank_disable_fn(void *arg)
d245 1
a245 2
void
drm_vblank_cleanup(struct drm_device *dev)
d266 1
d268 1
a268 2
int
drm_vblank_init(struct drm_device *dev, int num_crtcs)
d340 1
d342 2
a343 2
void
drm_irq_vgaarb_nokms(void *cookie, bool state)
d367 1
d378 1
a378 2
int
drm_irq_install(struct drm_device *dev)
d412 1
d421 1
a421 2
int
drm_irq_uninstall(struct drm_device *dev)
d456 1
d469 2
a470 2
int
drm_control(struct drm_device *dev, void *data, struct drm_file *file_priv)
d507 1
a507 2
void
drm_calc_timestamping_constants(struct drm_crtc *crtc)
d546 1
d592 1
a592 2
int
drm_calc_vbltimestamp_from_scanoutpos(struct drm_device *dev, int crtc,
d742 1
d744 1
a744 2
struct timeval
get_drm_timestamp(void)
d777 1
a777 2
u32
drm_get_last_vbltimestamp(struct drm_device *dev, int crtc,
d800 1
d811 1
a811 2
u32
drm_vblank_count(struct drm_device *dev, int crtc)
d815 1
d831 1
a831 2
u32
drm_vblank_count_and_time(struct drm_device *dev, int crtc,
d849 1
d851 1
a851 2
void
send_vblank_event(struct drm_device *dev,
d879 1
a879 2
void
drm_send_vblank_event(struct drm_device *dev, int crtc,
d893 1
d911 1
a911 2
void
drm_update_vblank_count(struct drm_device *dev, int crtc)
d970 1
a970 2
int
drm_vblank_get(struct drm_device *dev, int crtc)
d1006 1
d1016 1
a1016 2
void
drm_vblank_put(struct drm_device *dev, int crtc)
d1033 1
a1033 2
void
drm_vblank_off(struct drm_device *dev, int crtc)
d1077 1
a1077 2
void
drm_vblank_pre_modeset(struct drm_device *dev, int crtc)
d1095 1
d1097 1
a1097 2
void
drm_vblank_post_modeset(struct drm_device *dev, int crtc)
d1110 1
d1123 1
a1123 2
int
drm_modeset_ctl(struct drm_device *dev, void *data,
d1155 1
a1155 2
int
drm_queue_vblank_event(struct drm_device *dev, int pipe,
d1240 1
a1240 2
int
drm_wait_vblank(struct drm_device *dev, void *data,
d1328 1
a1328 2
void
drm_handle_vblank_events(struct drm_device *dev, int crtc)
d1372 1
a1372 2
bool
drm_handle_vblank(struct drm_device *dev, int crtc)
d1435 1
@


1.46
log
@Within ns_to_timeval() change the rem field type from unsigned to signed.

Pointed out by LLVM.

drm_irq.c:154:10: error: comparison of unsigned expression < 0 is always false

kettenis@@ says it should be signed and this is what the equivalent Linux code does.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.45 2013/04/22 15:10:55 deraadt Exp $	*/
a65 1
u32	 drm_vblank_count_and_time(struct drm_device *, int, struct timeval *);
@


1.45
log
@handle long long time_t in debug code
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_irq.c,v 1.44 2013/03/18 12:36:51 jsg Exp $	*/
d144 1
a144 1
	uint32_t rem;
@


1.44
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d748 1
a748 1
	DPRINTF("crtc %d : v %d p(%d,%d)@@ %ld.%ld -> %ld.%ld [e %d us, %d rep]\n",
d750 2
a751 2
		  (long)etime.tv_sec, (long)etime.tv_usec,
		  (long)vblank_time->tv_sec, (long)vblank_time->tv_usec,
@


1.43
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 14
a14 3
/* $OpenBSD$ */
/*-
 * Copyright 2003 Eric Anholt
d31 4
a34 12
 * ERIC ANHOLT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <anholt@@FreeBSD.org>
 *
 */

/** @@file drm_irq.c
 * Support code for handling setup/teardown of interrupt handlers and
 * handing interrupt handlers off to the drivers.
d42 32
a73 5
void		drm_update_vblank_count(struct drm_device *, int);
void		vblank_disable(void *);
int		drm_queue_vblank_event(struct drm_device *, int,
		    union drm_wait_vblank *, struct drm_file *);
void		drm_handle_vblank_events(struct drm_device *, int);
d81 21
d120 275
d413 9
a421 2
	if ((ret = dev->driver->irq_install(dev)) != 0)
		goto err;
d431 7
d457 6
a462 6
	if (dev->vblank != NULL) {
		mtx_enter(&dev->vblank->vb_lock);
		for (i = 0; i < dev->vblank->vb_num; i++) {
			wakeup(&dev->vblank->vb_crtcs[i]);
			dev->vblank->vb_crtcs[i].vbl_enabled = 0;
			dev->vblank->vb_crtcs[i].vbl_last =
d465 1
a465 1
		mtx_leave(&dev->vblank->vb_lock);
d475 11
d497 2
d504 2
d512 12
d525 90
a614 1
vblank_disable(void *arg)
d616 73
a688 15
	struct drm_device	*dev = (struct drm_device*)arg;
	struct drm_vblank_info	*vbl = dev->vblank;
	struct drm_vblank	*crtc;
	int			 i;

	mtx_enter(&vbl->vb_lock);
	for (i = 0; i < vbl->vb_num; i++) {
		crtc = &vbl->vb_crtcs[i];

		if (crtc->vbl_refs == 0 && crtc->vbl_enabled) {
			DPRINTF("%s: disabling crtc %d\n", __func__, i);
			crtc->vbl_last =
			    dev->driver->get_vblank_counter(dev, i);
			dev->driver->disable_vblank(dev, i);
			crtc->vbl_enabled = 0;
d690 46
d737 36
a772 1
	mtx_leave(&vbl->vb_lock);
d775 23
a797 2
void
drm_vblank_cleanup(struct drm_device *dev)
d799 1
a799 2
	if (dev->vblank == NULL)
		return; /* not initialised */
d801 2
a802 1
	timeout_del(&dev->vblank->vb_disable_timer);
d804 12
a815 1
	vblank_disable(dev);
d817 1
a817 2
	drm_free(dev->vblank);
	dev->vblank = NULL;
d820 32
a851 2
int
drm_vblank_init(struct drm_device *dev, int num_crtcs)
d853 1
a853 1
	int	i;
d855 10
a864 10
	dev->vblank = malloc(sizeof(*dev->vblank) + (num_crtcs *
	    sizeof(struct drm_vblank)), M_DRM,  M_WAITOK | M_CANFAIL | M_ZERO);
	if (dev->vblank == NULL)
		return (ENOMEM);

	dev->vblank->vb_num = num_crtcs;
	mtx_init(&dev->vblank->vb_lock, IPL_TTY);
	timeout_set(&dev->vblank->vb_disable_timer, vblank_disable, dev);
	for (i = 0; i < num_crtcs; i++)
		TAILQ_INIT(&dev->vblank->vb_crtcs[i].vbl_events);
d866 1
a866 1
	return (0);
d869 4
a872 2
u_int32_t
drm_vblank_count(struct drm_device *dev, int crtc)
d874 13
a886 1
	return (dev->vblank->vb_crtcs[crtc].vbl_count);
d889 41
d933 2
a934 1
	u_int32_t	cur_vblank, diff;
d937 27
a963 8
	 * Interrupt was disabled prior to this call, so deal with counter wrap
	 * note that we may have lost a full vb_max events if
	 * the register is small or the interrupts were off for a long time.
	 */
	cur_vblank = dev->driver->get_vblank_counter(dev, crtc);
	diff = cur_vblank - dev->vblank->vb_crtcs[crtc].vbl_last;
	if (cur_vblank < dev->vblank->vb_crtcs[crtc].vbl_last)
		diff += dev->vblank->vb_max;
d965 12
a976 1
	dev->vblank->vb_crtcs[crtc].vbl_count += diff;
d979 11
d993 1
a993 2
	struct drm_vblank_info	*vbl = dev->vblank;
	int			 ret = 0;
d995 26
a1020 14
	if (dev->irq_enabled == 0)
		return (EINVAL);

	mtx_enter(&vbl->vb_lock);
	DPRINTF("%s: %d refs = %d\n", __func__, crtc,
	    vbl->vb_crtcs[crtc].vbl_refs);
	vbl->vb_crtcs[crtc].vbl_refs++;
	if (vbl->vb_crtcs[crtc].vbl_refs == 1 &&
	    vbl->vb_crtcs[crtc].vbl_enabled == 0) {
		if ((ret = dev->driver->enable_vblank(dev, crtc)) == 0) {
			vbl->vb_crtcs[crtc].vbl_enabled = 1;
			drm_update_vblank_count(dev, crtc);
		} else {
			vbl->vb_crtcs[crtc].vbl_refs--;
a1021 1

d1023 1
a1023 1
	mtx_leave(&vbl->vb_lock);
d1025 1
a1025 1
	return (ret);
d1028 8
d1039 6
a1044 8
	mtx_enter(&dev->vblank->vb_lock);
	/* Last user schedules disable */
	DPRINTF("%s: %d  refs = %d\n", __func__, crtc,
	    dev->vblank->vb_crtcs[crtc].vbl_refs);
	KASSERT(dev->vblank->vb_crtcs[crtc].vbl_refs > 0);
	if (--dev->vblank->vb_crtcs[crtc].vbl_refs == 0)
		timeout_add_sec(&dev->vblank->vb_disable_timer, 5);
	mtx_leave(&dev->vblank->vb_lock);
d1047 9
a1055 2
int
drm_modeset_ctl(struct drm_device *dev, void *data, struct drm_file *file_priv)
d1057 17
a1073 3
	struct drm_modeset_ctl	*modeset = data;
	struct drm_vblank	*vbl;
	int			 crtc, ret = 0;
d1075 1
a1075 3
	/* not initialised yet, just noop */
	if (dev->vblank == NULL)
		return (0);
d1077 10
a1086 3
	crtc = modeset->crtc;
	if (crtc >= dev->vblank->vb_num || crtc < 0)
		return (EINVAL);
d1088 2
a1089 1
	vbl = &dev->vblank->vb_crtcs[crtc];
d1091 14
d1106 5
a1110 3
	 * If interrupts are enabled/disabled between calls to this ioctl then
	 * it can get nasty. So just grab a reference so that the interrupts
	 * keep going through the modeset
d1112 52
d1166 1
a1166 8
		DPRINTF("%s: pre modeset on %d\n", __func__, crtc);
		if (vbl->vbl_inmodeset == 0) {
			mtx_enter(&dev->vblank->vb_lock);
			vbl->vbl_inmodeset = 0x1;
			mtx_leave(&dev->vblank->vb_lock);
			if (drm_vblank_get(dev, crtc) == 0)
				vbl->vbl_inmodeset |= 0x2;
		}
d1169 1
a1169 6
		DPRINTF("%s: post modeset on %d\n", __func__, crtc);
		if (vbl->vbl_inmodeset) {
			if (vbl->vbl_inmodeset & 0x2)
				drm_vblank_put(dev, crtc);
			vbl->vbl_inmodeset = 0;
		}
d1172 1
a1172 2
		ret = EINVAL;
		break;
d1175 1
a1175 1
	return (ret);
d1179 3
a1181 1
drm_wait_vblank(struct drm_device *dev, void *data, struct drm_file *file_priv)
d1183 10
a1192 3
	struct timeval		 now;
	union drm_wait_vblank	*vblwait = data;
	int			 ret, flags, crtc, seq;
d1194 8
a1201 3
	if (!dev->irq_enabled || dev->vblank == NULL ||
	    vblwait->request.type & _DRM_VBLANK_SIGNAL)
		return (EINVAL);
d1203 1
a1203 2
	flags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;
	crtc = flags & _DRM_VBLANK_SECONDARY ? 1 : 0;
d1205 4
a1208 2
	if (crtc >= dev->vblank->vb_num)
		return (EINVAL);
d1210 2
a1211 3
	if ((ret = drm_vblank_get(dev, crtc)) != 0)
		return (ret);
	seq = drm_vblank_count(dev, crtc);
d1213 4
a1216 3
	if (vblwait->request.type & _DRM_VBLANK_RELATIVE) {
		vblwait->request.sequence += seq;
		vblwait->request.type &= ~_DRM_VBLANK_RELATIVE;
d1219 17
a1235 4
	flags = vblwait->request.type & _DRM_VBLANK_FLAGS_MASK;
	if ((flags & _DRM_VBLANK_NEXTONMISS) &&
	    (seq - vblwait->request.sequence) <= (1<<23)) {
		vblwait->request.sequence = seq + 1;
d1238 1
a1238 2
	if (flags & _DRM_VBLANK_EVENT)
		return (drm_queue_vblank_event(dev, crtc, vblwait, file_priv));
d1240 1
a1240 12
	DPRINTF("%s: %d waiting on %d, current %d\n", __func__, crtc,
	     vblwait->request.sequence, drm_vblank_count(dev, crtc));
	DRM_WAIT_ON(ret, &dev->vblank->vb_crtcs[crtc], &dev->vblank->vb_lock,
	    3 * hz, "drmvblq", ((drm_vblank_count(dev, crtc) -
	    vblwait->request.sequence) <= (1 << 23)) || dev->irq_enabled == 0);

	microtime(&now);
	vblwait->reply.tval_sec = now.tv_sec;
	vblwait->reply.tval_usec = now.tv_usec;
	vblwait->reply.sequence = drm_vblank_count(dev, crtc);
	DPRINTF("%s: %d done waiting, seq = %d\n", __func__, crtc,
	    vblwait->reply.sequence);
d1242 6
a1247 2
	drm_vblank_put(dev, crtc);
	return (ret);
d1250 14
d1265 2
a1266 2
drm_queue_vblank_event(struct drm_device *dev, int crtc,
    union drm_wait_vblank *vblwait, struct drm_file *file_priv)
d1268 19
a1286 15
	struct drm_pending_vblank_event	*vev;
	struct timeval			 now;
	u_int				 seq;


	vev = drm_calloc(1, sizeof(*vev));
	if (vev == NULL)
		return (ENOMEM);

	vev->event.base.type = DRM_EVENT_VBLANK;
	vev->event.base.length = sizeof(vev->event);
	vev->event.user_data = vblwait->request.signal;
	vev->base.event = &vev->event.base;
	vev->base.file_priv = file_priv;
	vev->base.destroy = (void (*) (struct drm_pending_event *))drm_free;
d1288 15
a1302 1
	microtime(&now);
d1304 9
a1312 5
	mtx_enter(&dev->event_lock);
	if (file_priv->event_space < sizeof(vev->event)) {
		mtx_leave(&dev->event_lock);
		drm_free(vev);
		return (ENOMEM);
d1315 6
d1322 2
a1323 7
	seq = drm_vblank_count(dev, crtc);
	file_priv->event_space -= sizeof(vev->event);

	DPRINTF("%s: queueing event %d on crtc %d\n", __func__, seq, crtc);

	if ((vblwait->request.type & _DRM_VBLANK_NEXTONMISS) &&
	    (seq - vblwait->request.sequence) <= (1 << 23)) {
a1324 1
		vblwait->reply.sequence = vblwait->request.sequence;
d1327 17
a1343 10
	vev->event.sequence = vblwait->request.sequence;
	if ((seq - vblwait->request.sequence) <= (1 << 23)) {
		vev->event.tv_sec = now.tv_sec;
		vev->event.tv_usec = now.tv_usec;
		DPRINTF("%s: already passed, dequeuing: crtc %d, value %d\n",
		    __func__, crtc, seq);
		drm_vblank_put(dev, crtc);
		TAILQ_INSERT_TAIL(&file_priv->evlist, &vev->base, link);
		wakeup(&file_priv->evlist);
		selwakeup(&file_priv->rsel);
d1345 1
a1345 2
		TAILQ_INSERT_TAIL(&dev->vblank->vb_crtcs[crtc].vbl_events,
		    &vev->base, link);
a1346 1
	mtx_leave(&dev->event_lock);
d1348 3
a1350 1
	return (0);
d1356 5
a1360 5
	struct drmevlist		*list;
	struct drm_pending_event	*ev, *tmp;
	struct drm_pending_vblank_event	*vev;
	struct timeval			 now;
	u_int				 seq;
d1362 2
a1363 3
	list = &dev->vblank->vb_crtcs[crtc].vbl_events;
	microtime(&now);
	seq = drm_vblank_count(dev, crtc);
d1366 1
d1372 1
a1372 1
		if ((seq - vev->event.sequence) > (1 << 23))
d1374 6
a1379 7
		DPRINTF("%s: got vblank event on crtc %d, value %d\n",
		    __func__, crtc, seq);
		
		vev->event.sequence = seq;
		vev->event.tv_sec = now.tv_sec;
		vev->event.tv_usec = now.tv_usec;
		drm_vblank_put(dev, crtc);
d1381 2
a1382 3
		TAILQ_INSERT_TAIL(&ev->file_priv->evlist, ev, link);
		wakeup(&ev->file_priv->evlist);
		selwakeup(&ev->file_priv->rsel);
d1384 1
d1386 2
d1390 9
a1398 1
void
d1401 39
a1439 3
	/*
	 * XXX if we had proper atomic operations this mutex wouldn't
	 * XXX need to be held.
d1441 16
a1456 4
	mtx_enter(&dev->vblank->vb_lock);
	dev->vblank->vb_crtcs[crtc].vbl_count++;
	wakeup(&dev->vblank->vb_crtcs[crtc]);
	mtx_leave(&dev->vblank->vb_lock);
d1458 3
@


1.42
log
@In drm_modeset_ctl make sure to check the (now signed) value is > 0 as
well as < the array length.

ok kettenis@@, mikeb@@ (who suggested the same fix) and marco@@.

"get that fixed" deraadt@@.
@
text
@d1 1
@


1.41
log
@Support from vblank events in drm.

Previously, if userland wanted to wait on a certain vertical blank, it
had to call an ioctl which slept. Now, they can ask for an even on the
drm fd, which is then read off, and can be poll(4)ed on. For dri2 this
fits better into the workflow since the fd gets added to the xserver
main loop, and replies to the dri2 clients happen upon recieving the
events.

This functionality is only used with xserver 1.8 (and for the intel
driver in our tree, this support is currently #if 0ed out due to bugs
with vblanks on 945 that are still being chased)

matthieu@@ ok.
@
text
@d289 1
a289 1
	if (crtc >= dev->vblank->vb_num)
@


1.40
log
@Use IPL_TTY instead of IPB_BIO as suggested by oga.

Tested by me and mlarkin on amd64 and i386
ok oga
@
text
@d40 3
d196 2
d206 2
d345 1
a345 1
	seq = drm_vblank_count(dev,crtc);
d358 3
d378 96
d485 1
@


1.39
log
@hold the mutex in drm_handle_vblank().

Ideally we could avoid this and still be mpsafe using atomic
increment/decrement operators, but for now best be correct.
@
text
@d199 1
a199 1
	mtx_init(&dev->vblank->vb_lock, IPL_BIO);
@


1.38
log
@Remove the vblank_disable_allowed crud.

it's a linux compat hack for older X drivers that don't use the right
calls. All the drivers capable of turning vblanks off already use the
calls correctly, and this way we avoid problems with not being able to
turn off vblanks until we switch mode (so until then we're stuck at
$REFRESH_RATE interrupts a second from the graphics card, no thanks).
@
text
@d371 5
d378 1
@


1.37
log
@add a bunch of #ifdef DRM_VBLANK_DEBUG debugging to the vblank code.

I'm sick of writing debugging for the refcounting every damned time this
fragile as hell code breaks.
@
text
@a161 3
	if (!vbl->vb_disable_allowed)
		goto out;

a172 1
out:
a305 3
			mtx_enter(&dev->vblank->vb_lock);
			dev->vblank->vb_disable_allowed = 1;
			mtx_leave(&dev->vblank->vb_lock);
@


1.36
log
@Rework the vblank subsystem so that instead of having various bits in
the drm softc, we only have one pointer, with the rest in that struct. This is
so that vblank-less drivers (yes, they exist) don't need to waste space on
useless crud.

While i'm reworking most of this code anyway, accept that on openbsd all
of the #defined atomic functions are not atomic other than set and clear
bit. Also, realise that the vb_lock is held whenever we manipulate these
counts anyway.  With those two facts in mind just remove the
atomic_blah() and just use ++ and --.
@
text
@d41 6
d169 1
d243 2
d266 3
d278 1
a279 1
	struct drm_vblank	*vbl;
d283 1
a283 1
		goto out;
d286 2
a287 4
	if (crtc >= dev->vblank->vb_num) {
		ret = EINVAL;
		goto out;
	}
d298 1
d308 1
a322 1
out:
d358 2
d368 2
@


1.35
log
@A couple of  fixes (based mostly on stuff from upstream) to stop
breaking vblanks over suspend.

Firstly, when we turn off the irq, wait up anyone waiting on vblanks,
and prepare for the fact that interrupts are going off.

Secondly, only reduce the refcount for vblanks over modeset if they were
actually turned on.

Fixes gl apps running while you suspend an x40 (as in they still work
when it comes back).
@
text
@d107 9
a115 6
	mtx_enter(&dev->vbl_lock);
	for (i = 0; i < dev->num_crtcs; i++) {
		wakeup(&dev->vblank[i]);
		dev->vblank[i].vbl_enabled = 0;
		dev->vblank[i].last_vblank =
		    dev->driver->get_vblank_counter(dev, i);
a116 1
	mtx_leave(&dev->vbl_lock);
d150 4
a153 2
	struct drm_device *dev = (struct drm_device*)arg;
	int i;
d155 2
a156 2
	mtx_enter(&dev->vbl_lock);
	if (!dev->vblank_disable_allowed)
d159 5
a163 4
	for (i=0; i < dev->num_crtcs; i++){
		if (atomic_read(&dev->vblank[i].vbl_refcount) == 0 &&
		    dev->vblank[i].vbl_enabled) {
			dev->vblank[i].last_vblank =
d166 1
a166 1
			dev->vblank[i].vbl_enabled = 0;
d170 1
a170 1
	mtx_leave(&dev->vbl_lock);
d176 1
a176 1
	if (dev->num_crtcs == 0)
d179 1
a179 1
	timeout_del(&dev->vblank_disable_timer);
a183 1

a184 1
	dev->num_crtcs = 0;
d190 2
a191 5
	timeout_set(&dev->vblank_disable_timer, vblank_disable, dev);
	mtx_init(&dev->vbl_lock, IPL_BIO);
	dev->num_crtcs = num_crtcs;

	dev->vblank = drm_calloc(num_crtcs, sizeof(*dev->vblank));
d193 1
a193 1
		goto err;
d195 3
a197 1
	dev->vblank_disable_allowed = 0;
a199 4

err:
	drm_vblank_cleanup(dev);
	return ENOMEM;
d205 1
a205 1
	return atomic_read(&dev->vblank[crtc].vbl_count);
d211 1
a211 1
	u_int32_t cur_vblank, diff;
d215 1
a215 1
	 * note that we may have lost a full dev->max_vblank_count events if
d219 3
a221 3
	diff = cur_vblank - dev->vblank[crtc].last_vblank;
	if (cur_vblank < dev->vblank[crtc].last_vblank)
		diff += dev->max_vblank_count;
d223 1
a223 1
	atomic_add(diff, &dev->vblank[crtc].vbl_count);
d229 2
a230 1
	int ret = 0;
d235 4
a238 4
	mtx_enter(&dev->vbl_lock);
	atomic_add(1, &dev->vblank[crtc].vbl_refcount);
	if (dev->vblank[crtc].vbl_refcount == 1 &&
	    dev->vblank[crtc].vbl_enabled == 0) {
d240 1
a240 1
			dev->vblank[crtc].vbl_enabled = 1;
d243 1
a243 1
			atomic_dec(&dev->vblank[crtc].vbl_refcount);
d247 1
a247 1
	mtx_leave(&dev->vbl_lock);
d255 5
a259 6
	mtx_enter(&dev->vbl_lock);
	/* Last user schedules interrupt disable */
	atomic_dec(&dev->vblank[crtc].vbl_refcount);
	if (dev->vblank[crtc].vbl_refcount == 0) 
		timeout_add_sec(&dev->vblank_disable_timer, 5);
	mtx_leave(&dev->vbl_lock);
d265 3
a267 2
	struct drm_modeset_ctl *modeset = data;
	int crtc, ret = 0;
d270 1
a270 1
	if (dev->num_crtcs == 0)
d274 1
a274 1
	if (crtc >= dev->num_crtcs) {
d279 2
d288 4
a291 4
		if (dev->vblank[crtc].vbl_inmodeset == 0) {
			mtx_enter(&dev->vbl_lock);
			dev->vblank[crtc].vbl_inmodeset = 0x1;
			mtx_leave(&dev->vbl_lock);
d293 1
a293 1
				dev->vblank[crtc].vbl_inmodeset |= 0x2;
d297 5
a301 5
		if (dev->vblank[crtc].vbl_inmodeset) {
			mtx_enter(&dev->vbl_lock);
			dev->vblank_disable_allowed = 1;
			mtx_leave(&dev->vbl_lock);
			if (dev->vblank[crtc].vbl_inmodeset & 0x2)
d303 1
a303 1
			dev->vblank[crtc].vbl_inmodeset = 0;
d318 1
d322 3
a324 2
	if (!dev->irq_enabled)
		return EINVAL;
d329 2
a330 2
	if (crtc >= dev->num_crtcs)
		return EINVAL;
d332 1
a332 2
	ret = drm_vblank_get(dev, crtc);
	if (ret)
d347 8
a354 17
	if (flags & _DRM_VBLANK_SIGNAL) {
		ret = EINVAL;
	} else {
		DRM_WAIT_ON(ret, &dev->vblank[crtc], &dev->vbl_lock, 3 * hz,
		    "drmvblq", ((drm_vblank_count(dev, crtc) -
		    vblwait->request.sequence) <= (1 << 23)) ||
		    dev->irq_enabled == 0);

		if (ret != EINTR) {
			struct timeval now;

			microtime(&now);
			vblwait->reply.tval_sec = now.tv_sec;
			vblwait->reply.tval_usec = now.tv_usec;
			vblwait->reply.sequence = drm_vblank_count(dev, crtc);
		}
	}
d363 2
a364 2
	atomic_inc(&dev->vblank[crtc].vbl_count);
	wakeup(&dev->vblank[crtc]);
@


1.34
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d91 1
d102 14
a255 3
	if (dev->irq_enabled == 0)
		return;

d289 1
a289 1
			dev->vblank[crtc].vbl_inmodeset = 1;
d291 2
a292 1
			drm_vblank_get(dev, crtc);
d299 3
a302 2
			mtx_leave(&dev->vbl_lock);
			drm_vblank_put(dev, crtc);
d349 3
a351 2
		    "drmvblq", (drm_vblank_count(dev, crtc) -
		    vblwait->request.sequence) <= (1 << 23));
@


1.33
log
@Convert DRM_WAIT_ON to take additional parameters, the wmsg for msleep,
and the lock to manipulate.

first step of removing drm_irq_handler_wrap which just grabs the
irq_lock, and eventually irq_lock. drivers should manage their own.
@
text
@a58 13
irqreturn_t
drm_irq_handler_wrap(DRM_IRQ_ARGS)
{
	irqreturn_t ret;
	struct drm_device *dev = (struct drm_device *)arg;

	mtx_enter(&dev->irq_lock);
	ret = dev->driver->irq_handler(arg);
	mtx_leave(&dev->irq_lock);

	return ret;
}

a75 2

	mtx_init(&dev->irq_lock, IPL_BIO);
@


1.32
log
@Remove the DRM_SPIN lock macros, just expand them to mutex operations.
@
text
@d349 3
a351 10
		mtx_enter(&dev->vbl_lock);
		while (ret == 0) {
			if ((drm_vblank_count(dev, crtc)
			    - vblwait->request.sequence) <= (1 << 23))
				break;
			ret = msleep(&dev->vblank[crtc],
			    &dev->vbl_lock, PZERO | PCATCH,
			    "drmvblq", 3 * DRM_HZ);
		}
		mtx_leave(&dev->vbl_lock);
@


1.31
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@d65 1
a65 1
	DRM_SPINLOCK(&dev->irq_lock);
d67 1
a67 1
	DRM_SPINUNLOCK(&dev->irq_lock);
d151 1
a151 1
	DRM_SPINLOCK(&dev->vbl_lock);
d165 1
a165 1
	DRM_SPINUNLOCK(&dev->vbl_lock);
d236 1
a236 1
	DRM_SPINLOCK(&dev->vbl_lock);
d248 1
a248 1
	DRM_SPINUNLOCK(&dev->vbl_lock);
d259 1
a259 1
	DRM_SPINLOCK(&dev->vbl_lock);
d264 1
a264 1
	DRM_SPINUNLOCK(&dev->vbl_lock);
d291 1
a291 1
			DRM_SPINLOCK(&dev->vbl_lock);
d293 1
a293 1
			DRM_SPINUNLOCK(&dev->vbl_lock);
d299 1
a299 1
			DRM_SPINLOCK(&dev->vbl_lock);
d302 1
a302 1
			DRM_SPINUNLOCK(&dev->vbl_lock);
d349 1
a349 1
		DRM_SPINLOCK(&dev->vbl_lock);
d358 1
a358 1
		DRM_SPINUNLOCK(&dev->vbl_lock);
@


1.30
log
@The drm_* allocation functions have been #defined to not use most of
their arguments for a while. Actually go through the code and remove the
extraneous arguments. Makes things easier to read.
@
text
@a98 1
	DRM_SPINUNINIT(&dev->irq_lock);
d120 1
a120 3
	DRM_SPINUNINIT(&dev->irq_lock);

	return 0;
a181 1
	DRM_SPINUNINIT(&dev->vbl_lock);
@


1.29
log
@Unbreak the tree
*sigh*
@
text
@d181 1
a181 2
	drm_free(dev->vblank, sizeof(*dev->vblank) *
	    dev->num_crtcs, M_DRM);
d195 1
a195 1
	dev->vblank = drm_calloc(num_crtcs, sizeof(*dev->vblank), M_DRM);
@


1.28
log
@Don't try and enable the vblank handler if irqs are disabled.

This is the source of the radeon issues with seizing at X startup. I
didn't see this since my test box in coimbra is a pcie amd64 machine
running MP. i.e. it has a slightly less shitty interrupt controller.
@
text
@d238 1
a238 1
	if (dev_priv->irq_enabled == 0)
@


1.27
log
@change drm_attach_mi to drm_attach_pci. we take the pci_attach_args, and
setup the drm_attach_args with the needed information.

require interface version 1.1 libdrm has been requesting it for ages),
which means that we can set the busid string at attach time. (generated in
drm_attach_pci), also pass in the interrupt line and bst.

Now we don't need dev->pa at all, so remove it, finally.
@
text
@d238 3
a241 1

d245 1
a245 4
		ret = dev->driver->enable_vblank(dev, crtc);
		if (ret) {
			atomic_dec(&dev->vblank[crtc].vbl_refcount);
		} else {
d248 2
d251 1
d261 3
@


1.26
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d46 5
a50 6
	if ((irq->busnum >> 8) != dev->pci_domain ||
	    (irq->busnum & 0xff) != dev->pci_bus ||
	    irq->devnum != dev->pci_slot ||
	    irq->funcnum != dev->pci_func)
		return EINVAL;

@


1.25
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@a37 1
irqreturn_t	drm_irq_handler_wrap(DRM_IRQ_ARGS);
d76 1
a76 3
	int retcode;
	pci_intr_handle_t ih;
	const char *istr;
d93 1
a93 13
	/* Before installing handler */
	dev->driver->irq_preinstall(dev);

	/* Install handler */
	if (pci_intr_map(&dev->pa, &ih) != 0) {
		retcode = ENOENT;
		goto err;
	}
	istr = pci_intr_string(dev->pa.pa_pc, ih);
	dev->irqh = pci_intr_establish(dev->pa.pa_pc, ih, IPL_BIO,
	    drm_irq_handler_wrap, dev, dev->device.dv_xname);
	if (!dev->irqh) {
		retcode = ENOENT;
a94 2
	}
	DRM_DEBUG("%s: interrupting at %s\n", dev->device.dv_xname, istr);
d96 1
a96 5
	/* After installing handler */
	if (dev->driver->irq_postinstall != NULL)
		dev->driver->irq_postinstall(dev);

	return 0;
d102 1
a102 1
	return retcode;
a120 2

	pci_intr_disestablish(dev->pa.pa_pc, dev->irqh);
@


1.24
log
@Instead of using a width-1 bitfield for storing the driver capabilities
in the callback structure, just use a bunch of ORed together bits. This
has been annoying me for ages.
@
text
@d114 2
a115 1
	dev->driver->irq_postinstall(dev);
a144 1
	drm_vblank_cleanup(dev);
@


1.23
log
@Make sure we do not unlock twice.

nice catch, oga@@
@
text
@d156 1
a156 1
	if (!dev->driver->use_irq)
@


1.22
log
@Remove the drm_locked_tasklet interface. The only consumer that used it
was the i915 vblank swap ioctl, which just went kaput.
@
text
@d376 1
a376 2
			    - vblwait->request.sequence) <= (1 << 23)) {
				DRM_SPINUNLOCK(&dev->vbl_lock);
a377 1
			}
@


1.21
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@a38 1
void		drm_locked_task(void *, void *);
a404 43
}

void
drm_locked_task(void *context, void *pending)
{
	struct drm_device *dev = context;
	void		  (*func)(struct drm_device *);

	DRM_SPINLOCK(&dev->tsk_lock);
	mtx_enter(&dev->lock.spinlock);
	func = dev->locked_task_call;
	if (func == NULL ||
	    drm_lock_take(&dev->lock, DRM_KERNEL_CONTEXT) == 0) {
		mtx_leave(&dev->lock.spinlock);
		DRM_SPINUNLOCK(&dev->tsk_lock);
		return;
	}

	dev->lock.file_priv = NULL; /* kernel owned */
	dev->lock.lock_time = jiffies;
	mtx_leave(&dev->lock.spinlock);
	dev->locked_task_call = NULL;
	DRM_SPINUNLOCK(&dev->tsk_lock);

	(*func)(dev);

	drm_lock_free(&dev->lock, DRM_KERNEL_CONTEXT);
}

void
drm_locked_tasklet(struct drm_device *dev, void (*tasklet)(struct drm_device *))
{
	DRM_SPINLOCK(&dev->tsk_lock);
	if (dev->locked_task_call != NULL) {
		DRM_SPINUNLOCK(&dev->tsk_lock);
		return;
	}

	dev->locked_task_call = tasklet;
	DRM_SPINUNLOCK(&dev->tsk_lock);

	if (workq_add_task(NULL, 0, drm_locked_task, dev, NULL) == ENOMEM)
		DRM_ERROR("error adding task to workq\n");
@


1.20
log
@Rework the drm locking to be at least halfway sane. The freebsd code
held a lock over all driver ioctls in order to be ``mpsafe''. Stop lying
to ourselves for a start. This code is not fully mpsafe, and should not
pretend to be so.  Put the locking around where it should, and rely on
biglock for the rest. This will need to be fixed, but avoids some of the
horrible that we have right now.

Tested by many over a long time and several iterations.
@
text
@d69 1
a69 1
	ret = dev->driver.irq_handler(arg);
d98 1
a98 1
	dev->driver.irq_preinstall(dev);
d115 1
a115 1
	dev->driver.irq_postinstall(dev);
d141 1
a141 1
	dev->driver.irq_uninstall(dev);
d157 1
a157 1
	if (!dev->driver.use_irq)
d187 2
a188 2
			    dev->driver.get_vblank_counter(dev, i);
			dev->driver.disable_vblank(dev, i);
d250 1
a250 1
	cur_vblank = dev->driver.get_vblank_counter(dev, crtc);
d268 1
a268 1
		ret = dev->driver.enable_vblank(dev, crtc);
@


1.19
log
@Kill the stats data structures and noop some other parts. Nothing in
userland asks for these stats, and we stopped recording anything
interesting a while back.
@
text
@d83 1
a83 1
		return EINVAL;
d90 1
a90 1
		return EBUSY;
d93 1
a98 1
	DRM_UNLOCK();
a114 1
	DRM_LOCK();
a115 1
	DRM_UNLOCK();
d130 5
a134 2
	if (!dev->irq_enabled)
		return EINVAL;
d137 1
d155 4
a158 1
	int			 err;
a161 5
		/* Handle drivers whose DRM used to require IRQ setup but the
		 * no longer does.
		 */
		if (!dev->driver.use_irq)
			return 0;
d164 2
a165 2
			return EINVAL;
		return drm_irq_install(dev);
d167 1
a167 6
		if (!dev->driver.use_irq)
			return 0;
		DRM_LOCK();
		err = drm_irq_uninstall(dev);
		DRM_UNLOCK();
		return err;
d169 1
a169 1
		return EINVAL;
d179 1
d181 1
a181 1
		return;
a183 1
		DRM_SPINLOCK(&dev->vbl_lock);
a190 1
		DRM_SPINUNLOCK(&dev->vbl_lock);
d192 2
d374 1
a375 1
			DRM_SPINLOCK(&dev->vbl_lock);
d381 1
a381 1
			ret = msleep(&dev->vblank[crtc].vbl_queue,
a383 1
			DRM_SPINUNLOCK(&dev->vbl_lock);
d385 1
d405 1
a405 1
	DRM_WAKEUP(&dev->vblank[crtc].vbl_queue);
d412 1
d415 3
a417 3

	DRM_LOCK(); /* XXX drm_lock_take() should do its own locking */
	if (dev->locked_task_call == NULL ||
d419 1
a419 1
		DRM_UNLOCK();
d426 3
d430 1
a430 3
	DRM_UNLOCK();

	dev->locked_task_call(dev);
a432 4

	dev->locked_task_call = NULL;

	DRM_SPINUNLOCK(&dev->tsk_lock);
@


1.18
log
@detypedef some more. No functional change.
@
text
@a428 1
	atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
@


1.17
log
@Rip out the remnants of the vblank signal stuff. Nothing uses it, and
it's stupid anyway. Most of this was ifdefed out.
@
text
@d46 1
a46 1
	drm_irq_busid_t *irq = data;
d152 2
a153 2
	drm_control_t *ctl = data;
	int err;
d347 2
a348 2
	drm_wait_vblank_t *vblwait = data;
	int ret, flags, crtc, seq;
@


1.16
log
@Instead of having a number of malloced arrays for vblank handling, just
put them in a structure and malloc free an array of those, it is nicer
that way and They're all needed at the same time, anyway.

Idea taken from a suggestion on the dri-devel mailing list.
@
text
@a222 1
	atomic_set(&dev->vbl_signal_pending, 0);
a375 18
#if 0 /* disabled */
		drm_vbl_sig_t *vbl_sig = drm_calloc(1, sizeof(drm_vbl_sig_t),
		    DRM_MEM_DRIVER);
		if (vbl_sig == NULL)
			return ENOMEM;

		vbl_sig->sequence = vblwait->request.sequence;
		vbl_sig->signo = vblwait->request.signal;
		vbl_sig->pid = DRM_CURRENTPID;

		vblwait->reply.sequence = atomic_read(&dev->vbl_received);

		
		DRM_SPINLOCK(&dev->vbl_lock);
		TAILQ_INSERT_HEAD(&dev->vbl_sig_list, vbl_sig, link);
		DRM_SPINUNLOCK(&dev->vbl_lock);
		ret = 0;
#endif
a405 30
drm_vbl_send_signals(struct drm_device *dev, int crtc)
{
}

#if 0 /* disabled */
void
drm_vbl_send_signals(struct drm_device *dev, int crtc)
{
	drm_vbl_sig_t *vbl_sig;
	unsigned int vbl_seq = atomic_read(&dev->vbl_received);
	struct proc *p;

	vbl_sig = TAILQ_FIRST(&dev->vbl_sig_list);
	while (vbl_sig != NULL) {
		drm_vbl_sig_t *next = TAILQ_NEXT(vbl_sig, link);

		if ((vbl_seq - vbl_sig->sequence) <= (1<<23)) {
			p = pfind(vbl_sig->pid);
			if (p != NULL)
				psignal(p, vbl_sig->signo);

			TAILQ_REMOVE(&dev->vbl_sig_list, vbl_sig, link);
			drm_free(vbl_sig, sizeof(*vbl_sig), DRM_MEM_DRIVER);
		}
		vbl_sig = next;
	}
}
#endif

void
a409 1
	drm_vbl_send_signals(dev, crtc);
@


1.15
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@d189 3
a191 3
		if (atomic_read(&dev->vblank_refcount[i]) == 0 &&
		    dev->vblank_enabled[i]) {
			dev->last_vblank[i] =
d194 1
a194 1
			dev->vblank_enabled[i] = 0;
d210 1
a210 14
	drm_free(dev->vbl_queue, sizeof(*dev->vbl_queue) *
	    dev->num_crtcs, M_DRM);
#if 0 /* disabled for now */
	drm_free(dev->vbl_sigs, sizeof(*dev->vbl_sigs) * dev->num_crtcs, M_DRM);
#endif
	drm_free(dev->_vblank_count, sizeof(*dev->_vblank_count) *
	    dev->num_crtcs, M_DRM);
	drm_free(dev->vblank_refcount, sizeof(*dev->vblank_refcount) *
	    dev->num_crtcs, M_DRM);
	drm_free(dev->vblank_enabled, sizeof(*dev->vblank_enabled) *
	    dev->num_crtcs, M_DRM);
	drm_free(dev->last_vblank, sizeof(*dev->last_vblank) *
	    dev->num_crtcs, M_DRM);
	drm_free(dev->vblank_inmodeset, sizeof(*dev->vblank_inmodeset) *
d213 1
a220 2
	int i;

d226 2
a227 6
	if ((dev->vbl_queue = drm_calloc(num_crtcs, sizeof(*dev->vbl_queue),
	    M_DRM)) == NULL)
		goto err;

	if ((dev->_vblank_count = drm_calloc(num_crtcs,
	    sizeof(*dev->_vblank_count), M_DRM)) == NULL)
a229 19
	if ((dev->vblank_refcount = drm_calloc(num_crtcs,
	    sizeof(*dev->vblank_refcount), M_DRM)) == NULL)
		goto err;
	if ((dev->vblank_enabled = drm_calloc(num_crtcs,
	    sizeof(*dev->vblank_enabled), M_DRM)) == NULL)
		goto err;
	if ((dev->last_vblank = drm_calloc(num_crtcs,
	    sizeof(*dev->last_vblank), M_DRM)) == NULL)
		goto err;
	if ((dev->vblank_inmodeset = drm_calloc(num_crtcs,
	    sizeof(*dev->vblank_inmodeset), M_DRM)) == NULL)
		goto err;

	/* Zero everything */
	for (i = 0; i < num_crtcs; i++) {
		atomic_set(&dev->_vblank_count[i], 0);
		atomic_set(&dev->vblank_refcount[i], 0);
	}

d242 1
a242 1
	return atomic_read(&dev->_vblank_count[crtc]);
d256 2
a257 2
	diff = cur_vblank - dev->last_vblank[crtc];
	if (cur_vblank < dev->last_vblank[crtc])
d260 1
a260 1
	atomic_add(diff, &dev->_vblank_count[crtc]);
d270 3
a272 3
	atomic_add(1, &dev->vblank_refcount[crtc]);
	if (dev->vblank_refcount[crtc] == 1 &&
	    dev->vblank_enabled[crtc] == 0) {
d275 1
a275 1
			atomic_dec(&dev->vblank_refcount[crtc]);
d277 1
a277 1
			dev->vblank_enabled[crtc] = 1;
d291 2
a292 2
	atomic_dec(&dev->vblank_refcount[crtc]);
	if (dev->vblank_refcount[crtc] == 0) 
d320 4
a323 2
		if (dev->vblank_inmodeset[crtc] == 0) {
			dev->vblank_inmodeset[crtc] = 1;
d328 1
a328 1
		if (dev->vblank_inmodeset[crtc]) {
d331 1
a331 1
			dev->vblank_inmodeset[crtc] = 0;
d404 1
a404 1
			ret = msleep(&dev->vbl_queue[crtc],
d457 2
a458 2
	atomic_inc(&dev->_vblank_count[crtc]);
	DRM_WAKEUP(&dev->vbl_queue[crtc]);
@


1.14
log
@Change the drm_lock*() api to take a pointer to the struct as a
parameter, this makes things a little cleaner and removes the need to
pass in the softc for some functions.
@
text
@d39 2
a41 2
void		drm_update_vblank_count(struct drm_device *, int);
void		drm_locked_task(void *context, void *pending);
d56 2
a57 2
	DRM_DEBUG("%d:%d:%d => IRQ %d\n",
		  irq->busnum, irq->devnum, irq->funcnum, irq->irq);
d85 1
a85 1
	DRM_DEBUG( "%s: irq=%d\n", __FUNCTION__, dev->irq );
d96 1
a96 1
				/* Before installing handler */
d100 1
a100 1
				/* Install handler */
d107 1
a107 2
	    drm_irq_handler_wrap, dev,
	    dev->device.dv_xname);
d114 1
a114 1
				/* After installing handler */
d137 1
a137 1
	DRM_DEBUG( "%s: irq=%d\n", __FUNCTION__, dev->irq );
d155 1
a155 1
	switch ( ctl->func ) {
d350 2
a351 1
	/* If interrupts are enabled/disabled between calls to this ioctl then
d469 1
a469 1
	unsigned int vbl_seq = atomic_read( &dev->vbl_received );
d476 1
a476 1
		if ( ( vbl_seq - vbl_sig->sequence ) <= (1<<23) ) {
@


1.13
log
@Kill a bunch of the drm context code that nothing uses anymore, the
xserver only actually uses a small part of it nowadays.

Kill a few other dead bits from the drmP.h while i'm here.
@
text
@d506 1
a506 1
	    drm_lock_take(&dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT) == 0) {
d520 1
a520 1
	drm_lock_free(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
@


1.12
log
@Update to DRM git.

Some stability fixes for radeon. The most part of this diff is related
to fixing up the VBLANK (vertical blank interrupt) handling. Now, if the
X driver supports the DRM_IOCTL_MODESET_CTL ioctl, (to be used when
changing the video modes), then allow the vblank to be disabled once
that ioctl has been called. Otherwise, keep the interrupt enabled at all
time, since disabling it otherwise will lead to problems.

Tested by a few. "no problem" on API/ABI deraadt@@.
@
text
@a93 2
	dev->context_flag = 0;

@


1.11
log
@Switch all instances of malloc/free in the DRM to drm_alloc, drm_free
and drm_calloc.

With the recent change to check overflow in drm_calloc, this means that
all allocations that require multiplication are now checked. Also use
drm_calloc() when zeroing is needed and drop the bzero/memset
afterwards.  Finally, make drm_free() check for NULL, so we don't need
to do so every time.

ok miod@@, deraadt@@
@
text
@d40 1
d187 3
d194 2
d213 2
a214 3
	if (dev->vbl_queue)
		drm_free(dev->vbl_queue, sizeof(*dev->vbl_queue) *
		    dev->num_crtcs, M_DRM);
d216 1
a216 3
	if (dev-vbl_sigs)
		drm_free(dev->vbl_sigs, sizeof(*dev->vbl_sigs) * dev->num_crtcs,
		    M_DRM);
d218 10
a227 18
	if (dev->_vblank_count)
		drm_free(dev->_vblank_count, sizeof(*dev->_vblank_count) *
		    dev->num_crtcs, M_DRM);
	if (dev->vblank_refcount)
		drm_free(dev->vblank_refcount, sizeof(*dev->vblank_refcount) *
		    dev->num_crtcs, M_DRM);
	if (dev->vblank_enabled)
		drm_free(dev->vblank_enabled, sizeof(*dev->vblank_enabled) *
		    dev->num_crtcs, M_DRM);
	if (dev->last_vblank)
		drm_free(dev->last_vblank, sizeof(*dev->last_vblank) *
		    dev->num_crtcs, M_DRM);
	if (dev->vblank_premodeset)
		drm_free(dev->vblank_premodeset,
		    sizeof(*dev->vblank_premodeset) * dev->num_crtcs, M_DRM);
	if (dev->vblank_suspend)
		drm_free(dev->vblank_suspend,
		    sizeof(*dev->vblank_suspend) * dev->num_crtcs, M_DRM);
d257 2
a258 5
	if ((dev->last_vblank = drm_calloc(num_crtcs, sizeof(*dev->last_vblank),
	    M_DRM)) == NULL)
		goto err;
	if ((dev->vblank_premodeset = drm_calloc(num_crtcs,
	    sizeof(*dev->vblank_premodeset), M_DRM)) == NULL)
d260 2
a261 2
	if ((dev->vblank_suspend = drm_calloc(num_crtcs,
	    sizeof(*dev->vblank_suspend), M_DRM)) == NULL)
a263 1

d270 2
a289 3
	if (dev->vblank_suspend[crtc])
		return;

d291 3
a293 2
	 * Deal with the possibility of lost vblanks due to disabled interrupts
	 * counter overflow may have happened. 
d296 3
a298 13
	DRM_SPINLOCK(&dev->vbl_lock);
	if (cur_vblank < dev->last_vblank[crtc]) {
		if (cur_vblank == dev->last_vblank[crtc] -1)
			diff = 0;
		else {
			diff = dev->max_vblank_count - dev->last_vblank[crtc];
			diff += cur_vblank;
		}
	} else {
		diff = cur_vblank - dev->last_vblank[crtc];
	}
	dev->last_vblank[crtc] = cur_vblank;
	DRM_SPINUNLOCK(&dev->vbl_lock);
d318 1
d323 1
a323 1
	return ret;
d333 1
a333 1
		timeout_add(&dev->vblank_disable_timer, 5*DRM_HZ);
d343 4
d353 4
d359 4
a362 3
		dev->vblank_premodeset[crtc] =
			dev->driver.get_vblank_counter(dev, crtc);
		dev->vblank_suspend[crtc] = 1;
d365 6
a370 8
		if (dev->vblank_suspend[crtc]) {
			uint32_t new =
			    dev->driver.get_vblank_counter(dev, crtc);
			/* Compensate for spurious wraparound */
			if (new < dev->vblank_premodeset[crtc])
				atomic_sub(dev->max_vblank_count + new -
				    dev->vblank_premodeset[crtc],
				    &dev->_vblank_count[crtc]);
a371 1
		dev->vblank_suspend[crtc] = 0;
d375 1
d379 1
a379 1
	return ret;
d397 3
a399 1
	drm_update_vblank_count(dev, crtc);
d434 4
a437 16
		if (!dev->vblank_suspend[crtc]) {
			unsigned long cur_vblank;

			ret = drm_vblank_get(dev, crtc);
			if (ret)
				return ret;
			while (ret == 0) {
				DRM_SPINLOCK(&dev->vbl_lock);
				if (((cur_vblank = drm_vblank_count(dev, crtc))
				    - vblwait->request.sequence) <= (1 << 23)) {
					DRM_SPINUNLOCK(&dev->vbl_lock);
					break;
				}
				ret = msleep(&dev->vbl_queue[crtc],
				    &dev->vbl_lock, PZERO | PCATCH,
				    "drmvblq", 3 * DRM_HZ);
d439 1
d441 4
a444 1
			drm_vblank_put(dev, crtc);
d449 1
d457 1
d494 1
a494 1
	drm_update_vblank_count(dev, crtc);
@


1.10
log
@The current drm_locked_task*() code sometimes tries to sleep in an
interrupt handler.

This is bad and wrong. So change it so that if we can't immediately grab
the hardware lock, to just leave the task flagged so that we can run it
when we release the lock. The linux implementation uses a similar
scheme.

Tested by guenther@@, landry@@ and bernd@@. Also tested by many a while
ago as part of a larger diff.
@
text
@d424 2
a425 5
		if (dev->vblank_suspend[crtc])
			return (EBUSY);

		drm_vbl_sig_t *vbl_sig = malloc(sizeof(drm_vbl_sig_t), M_DRM,
		    M_NOWAIT | M_ZERO);
d499 1
a499 1
			DRM_FREE(vbl_sig,sizeof(*vbl_sig));
@


1.9
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d522 8
a529 20
	DRM_LOCK();
	for (;;) {
		int ret;

		if (drm_lock_take(&dev->lock.hw_lock->lock,
		    DRM_KERNEL_CONTEXT))
		{
			dev->lock.file_priv = NULL; /* kernel owned */
			dev->lock.lock_time = jiffies;
			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
			break;  /* Got lock */
		}

		/* Contention */
		ret = DRM_SLEEPLOCK((void *)&dev->lock.lock_queue, &dev->dev_lock,
		    PZERO | PCATCH, "drmlk2", 0);
		if (ret != 0) {
			DRM_UNLOCK();
			return;
		}
d531 5
d541 4
d550 6
d557 2
@


1.8
log
@Kill the rest of the ifdef maze in drm_*.c

I was going to do this per file, but decided all it would achieve was
artificially increasing my commit count.

>Kill the ifdef maze. I've been considering doing this for months, it
>doesn't make getting changes to and  from upstream much easier, and just
>makes the code hard to read.
@
text
@d43 1
a43 1
drm_irq_by_busid(drm_device_t *dev, void *data, struct drm_file *file_priv)
d65 1
a65 1
	drm_device_t *dev = (drm_device_t *)arg;
d75 1
a75 1
drm_irq_install(drm_device_t *dev)
d131 1
a131 1
drm_irq_uninstall(drm_device_t *dev)
d152 1
a152 1
drm_control(drm_device_t *dev, void *data, struct drm_file *file_priv)
d394 1
a394 1
drm_wait_vblank(drm_device_t *dev, void *data, struct drm_file *file_priv)
d480 1
a480 1
drm_vbl_send_signals(drm_device_t *dev, int crtc)
d486 1
a486 1
drm_vbl_send_signals(drm_device_t *dev, int crtc)
d520 1
a520 1
	drm_device_t *dev = context;
d551 1
a551 1
drm_locked_tasklet(drm_device_t *dev, void (*tasklet)(drm_device_t *dev))
@


1.7
log
@Don't play with the vblank refcount if we didn't increase it first.
@
text
@a39 2

#ifdef __OpenBSD__
a40 3
#else
void		drm_locked_task(void *context, int pending __unused);
#endif
a60 30
#if defined(__FreeBSD__) && __FreeBSD_version >= 500000
static irqreturn_t
drm_irq_handler_wrap(DRM_IRQ_ARGS)
{
	drm_device_t *dev = (drm_device_t *)arg;

	DRM_SPINLOCK(&dev->irq_lock);
	dev->driver.irq_handler(arg);
	DRM_SPINUNLOCK(&dev->irq_lock);
}
#endif

#ifdef __NetBSD__
static irqreturn_t
drm_irq_handler_wrap(DRM_IRQ_ARGS)
{
	int s;
	irqreturn_t ret;
	drm_device_t *dev = (drm_device_t *)arg;

	s = spldrm();
	DRM_SPINLOCK(&dev->irq_lock);
	ret = dev->driver.irq_handler(arg);
	DRM_SPINUNLOCK(&dev->irq_lock);
	splx(s);
	return ret;
}
#endif

#ifdef __OpenBSD__
a72 1
#endif
a77 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a79 1
#endif
a94 1
#ifdef __OpenBSD__
a95 3
#else
	DRM_SPININIT(&dev->irq_lock, "DRM IRQ lock");
#endif
a101 20
#ifdef __FreeBSD__
	dev->irqrid = 0;
	dev->irqr = bus_alloc_resource_any(dev->device, SYS_RES_IRQ, 
				      &dev->irqrid, RF_SHAREABLE);
	if (!dev->irqr) {
		retcode = ENOENT;
		goto err;
	}
#if __FreeBSD_version >= 700031
	retcode = bus_setup_intr(dev->device, dev->irqr,
				 INTR_TYPE_TTY | INTR_MPSAFE,
				 NULL, drm_irq_handler_wrap, dev, &dev->irqh);
#else
	retcode = bus_setup_intr(dev->device, dev->irqr,
				 INTR_TYPE_TTY | INTR_MPSAFE,
				 drm_irq_handler_wrap, dev, &dev->irqh);
#endif
	if (retcode != 0)
		goto err;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a106 1
#if defined(__OpenBSD__)
a109 4
#else
	dev->irqh = pci_intr_establish(dev->pa.pa_pc, ih, IPL_BIO,
	    drm_irq_handler_wrap, dev);
#endif
a114 1
#endif
a120 3
#ifdef __FreeBSD__
	TASK_INIT(&dev->locked_task, 0, drm_locked_task, dev);
#endif
a124 7
#ifdef ___FreeBSD__
	if (dev->irqrid != 0) {
		bus_release_resource(dev->device, SYS_RES_IRQ, dev->irqrid,
		    dev->irqr);
		dev->irqrid = 0;
	}
#endif
a132 3
#ifdef __FreeBSD__
	int irqrid;
#endif
a137 4
#ifdef __FreeBSD__
	irqrid = dev->irqrid;
	dev->irqrid = 0;
#endif
a142 6
#ifdef __FreeBSD__
	DRM_UNLOCK();
	bus_teardown_intr(dev->device, dev->irqr, dev->irqh);
	bus_release_resource(dev->device, SYS_RES_IRQ, irqrid, dev->irqr);
	DRM_LOCK();
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d144 1
a144 1
#endif
a517 1
#ifdef __OpenBSD__
a518 3
#else
drm_locked_task(void *context, int pending __unused)
#endif
a553 3
#ifdef __FreeBSD__
	taskqueue_enqueue(taskqueue_swi, &dev->locked_task);
#else
a555 1
#endif
@


1.6
log
@Check the right refcount so that the vblank irq has a hope of being
disabled when wished.
@
text
@d555 1
a556 1
		drm_vblank_put(dev, crtc);
@


1.5
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d424 1
a424 1
		if (ret)
d426 1
a426 1
		else
d428 1
d441 1
a441 1
	if (&dev->vblank_refcount[crtc] == 0)
@


1.4
log
@When i first ported the drm, i completely misunderstood the FreeBSD taskqueue
api. So drm_locked_tasklet() is wrong.

Fix this up to be at least mostly correct.
@
text
@d39 1
d42 1
a42 1
void	drm_locked_task(void *context, void *pending);
d44 1
a44 1
void	drm_locked_task(void *context, int pending __unused);
d133 1
a133 1
#ifdef __OpenBSD__ 
d174 1
a174 1
	dev->irqh = pci_intr_establish(dev->pa.pa_pc, ih, IPL_TTY,
d236 1
d271 212
d487 1
a487 2
	struct timeval now;
	int ret, flags;
d492 9
d502 1
a502 1
		vblwait->request.sequence += atomic_read(&dev->vbl_received);
d507 5
d514 3
d527 1
d529 1
a529 1
		DRM_SPINLOCK(&dev->irq_lock);
d531 1
a531 1
		DRM_SPINUNLOCK(&dev->irq_lock);
d536 20
a555 5
		DRM_LOCK();
		/* shared code returns -errno */
		ret = -dev->driver.vblank_wait(dev,
		    &vblwait->request.sequence);
		DRM_UNLOCK();
d557 7
a563 3
		microtime(&now);
		vblwait->reply.tval_sec = now.tv_sec;
		vblwait->reply.tval_usec = now.tv_usec;
d566 1
a566 1
	return ret;
d570 1
a570 1
drm_vbl_send_signals(drm_device_t *dev)
d576 1
a576 1
drm_vbl_send_signals( drm_device_t *dev )
d598 8
@


1.3
log
@drm_pci_alloc allocates memory using bus_dma, but then doesn't use dmamaps.
This is unportable to some architectures, fix it. While i'm here, kill
he defines for netbsd aprint_ and just use the DRM_* macros.

ok miod@@
@
text
@d40 5
a44 3
#if 0
void drm_locked_task(void *context, int pending __unused);
#endif /* 0 */
a348 1
#if 0 /* disabled while it's unused anywhere */
d350 3
d354 1
a380 1
#ifdef __FreeBSD__
a381 3
#elif defined (__OpenBSD__)
	dev->locked_task_call(dev,NULL);
#endif
a385 2
#endif /* disabled due to lack of use */

a386 1
#ifdef __FreeBSD__
a387 3
#else
drm_locked_tasklet(drm_device_t *dev, void (*tasklet)(void* dev, void*))
#endif
d393 2
a394 2
	workq_add_task(NULL, WQ_WAITOK, dev->locked_task_call,
	    dev, NULL);
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d178 1
a178 1
	aprint_normal("%s: interrupting at %s\n", dev->device.dv_xname, istr);
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d38 2
d41 1
a41 5
#ifdef __Freebsd__
static void drm_locked_task(void *context, int pending __unused);
#else
static void drm_locked_task(void *context, int  pending);
#endif
d44 2
a45 1
int drm_irq_by_busid(drm_device_t *dev, void *data, struct drm_file *file_priv)
d93 1
a93 1
static irqreturn_t
d107 2
a108 1
int drm_irq_install(drm_device_t *dev)
a160 3
#if defined(__OpenBSD__)
#define aprint_normal printf
#endif
d205 2
a206 1
int drm_irq_uninstall(drm_device_t *dev)
d238 2
a239 1
int drm_control(drm_device_t *dev, void *data, struct drm_file *file_priv)
d267 2
a268 1
int drm_wait_vblank(drm_device_t *dev, void *data, struct drm_file *file_priv)
d317 2
a318 1
void drm_vbl_send_signals(drm_device_t *dev)
d323 2
a324 1
void drm_vbl_send_signals( drm_device_t *dev )
d348 2
a349 5
#ifdef __FreeBSD__
static void drm_locked_task(void *context, int pending __unused)
#else
static void drm_locked_task(void *context, int pending)
#endif
d399 1
a399 1
		     dev, NULL);
@

