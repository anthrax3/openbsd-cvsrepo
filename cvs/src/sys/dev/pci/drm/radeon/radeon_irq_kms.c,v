head	1.9;
access;
symbols
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.8
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.7.0.4
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.4.0.4
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2015.04.18.14.47.35;	author jsg;	state Exp;
branches;
next	1.8;
commitid	c1fUeeFWMNg4COgR;

1.8
date	2015.04.06.07.38.49;	author jsg;	state Exp;
branches;
next	1.7;
commitid	A7VgsFjPNML2ZK3Q;

1.7
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.6;
commitid	dLgISW35NAmGN8Xl;

1.6
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.5;
commitid	aHLMSW1RfE1rmMw9;

1.5
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.4;
commitid	MyKPm9Q3dQu92BiX;

1.4
date	2014.04.07.06.43.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2014.01.23.03.15.09;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.12.04.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@another round of reducing the diff to linux
@
text
@/*	$OpenBSD: radeon_irq_kms.c,v 1.8 2015/04/06 07:38:49 jsg Exp $	*/
/*
 * Copyright 2008 Advanced Micro Devices, Inc.
 * Copyright 2008 Red Hat Inc.
 * Copyright 2009 Jerome Glisse.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Dave Airlie
 *          Alex Deucher
 *          Jerome Glisse
 */
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_crtc_helper.h>
#include <dev/pci/drm/radeon_drm.h>
#include "radeon_reg.h"
#include "radeon.h"
#include "atom.h"

#define RADEON_WAIT_IDLE_TIMEOUT 200

/**
 * radeon_driver_irq_handler_kms - irq handler for KMS
 *
 * @@DRM_IRQ_ARGS: args
 *
 * This is the irq handler for the radeon KMS driver (all asics).
 * radeon_irq_process is a macro that points to the per-asic
 * irq handler callback.
 */
irqreturn_t radeon_driver_irq_handler_kms(void *arg)
{
	struct drm_device *dev = arg;
	struct radeon_device *rdev = dev->dev_private;

	if (!rdev->irq.installed)
		return (0);

	return radeon_irq_process(rdev);
}

/*
 * Handle hotplug events outside the interrupt handler proper.
 */
/**
 * radeon_hotplug_work_func - display hotplug work handler
 *
 * @@work: work struct
 *
 * This is the hot plug event work handler (all asics).
 * The work gets scheduled from the irq handler if there
 * was a hot plug interrupt.  It walks the connector table
 * and calls the hotplug handler for each one, then sends
 * a drm hotplug event to alert userspace.
 */
static void radeon_hotplug_work_func(void *arg1)
{
	struct radeon_device *rdev = arg1;
	struct drm_device *dev = rdev->ddev;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct drm_connector *connector;

	if (mode_config->num_connector) {
		list_for_each_entry(connector, &mode_config->connector_list, head)
			radeon_connector_hotplug(connector);
	}
	/* Just fire off a uevent and let userspace tell us what to do */
	drm_helper_hpd_irq_event(dev);
}

/**
 * radeon_driver_irq_preinstall_kms - drm irq preinstall callback
 *
 * @@dev: drm dev pointer
 *
 * Gets the hw ready to enable irqs (all asics).
 * This function disables all interrupt sources on the GPU.
 */
void radeon_driver_irq_preinstall_kms(struct drm_device *dev)
{
	struct radeon_device *rdev = dev->dev_private;
	unsigned long irqflags;
	unsigned i;

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	/* Disable *all* interrupts */
	for (i = 0; i < RADEON_NUM_RINGS; i++)
		atomic_set(&rdev->irq.ring_int[i], 0);
	for (i = 0; i < RADEON_MAX_HPD_PINS; i++)
		rdev->irq.hpd[i] = false;
	for (i = 0; i < RADEON_MAX_CRTCS; i++) {
		rdev->irq.crtc_vblank_int[i] = false;
		atomic_set(&rdev->irq.pflip[i], 0);
		rdev->irq.afmt[i] = false;
	}
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	/* Clear bits */
	radeon_irq_process(rdev);
}

/**
 * radeon_driver_irq_postinstall_kms - drm irq preinstall callback
 *
 * @@dev: drm dev pointer
 *
 * Handles stuff to be done after enabling irqs (all asics).
 * Returns 0 on success.
 */
int radeon_driver_irq_postinstall_kms(struct drm_device *dev)
{
	dev->max_vblank_count = 0x001fffff;
	return 0;
}

/**
 * radeon_driver_irq_uninstall_kms - drm irq uninstall callback
 *
 * @@dev: drm dev pointer
 *
 * This function disables all interrupt sources on the GPU (all asics).
 */
void radeon_driver_irq_uninstall_kms(struct drm_device *dev)
{
	struct radeon_device *rdev = dev->dev_private;
	unsigned long irqflags;
	unsigned i;

	if (rdev == NULL) {
		return;
	}
	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	/* Disable *all* interrupts */
	for (i = 0; i < RADEON_NUM_RINGS; i++)
		atomic_set(&rdev->irq.ring_int[i], 0);
	for (i = 0; i < RADEON_MAX_HPD_PINS; i++)
		rdev->irq.hpd[i] = false;
	for (i = 0; i < RADEON_MAX_CRTCS; i++) {
		rdev->irq.crtc_vblank_int[i] = false;
		atomic_set(&rdev->irq.pflip[i], 0);
		rdev->irq.afmt[i] = false;
	}
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
}

/**
 * radeon_msi_ok - asic specific msi checks
 *
 * @@rdev: radeon device pointer
 *
 * Handles asic specific MSI checks to determine if
 * MSIs should be enabled on a particular chip (all asics).
 * Returns true if MSIs should be enabled, false if MSIs
 * should not be enabled.
 */
bool radeon_msi_ok(struct radeon_device *rdev)
{
	/* RV370/RV380 was first asic with MSI support */
	if (rdev->family < CHIP_RV380)
		return false;

	/* MSIs don't work on AGP */
	if (rdev->flags & RADEON_IS_AGP)
		return false;

	/* force MSI on */
	if (radeon_msi == 1)
		return true;
	else if (radeon_msi == 0)
		return false;

	/* Quirks */
	/* HP RS690 only seems to work with MSIs. */
	if ((rdev->pdev->device == 0x791f) &&
	    (rdev->pdev->subsystem_vendor == 0x103c) &&
	    (rdev->pdev->subsystem_device == 0x30c2))
		return true;

	/* Dell RS690 only seems to work with MSIs. */
	if ((rdev->pdev->device == 0x791f) &&
	    (rdev->pdev->subsystem_vendor == 0x1028) &&
	    (rdev->pdev->subsystem_device == 0x01fc))
		return true;

	/* Dell RS690 only seems to work with MSIs. */
	if ((rdev->pdev->device == 0x791f) &&
	    (rdev->pdev->subsystem_vendor == 0x1028) &&
	    (rdev->pdev->subsystem_device == 0x01fd))
		return true;

	/* Gateway RS690 only seems to work with MSIs. */
	if ((rdev->pdev->device == 0x791f) &&
	    (rdev->pdev->subsystem_vendor == 0x107b) &&
	    (rdev->pdev->subsystem_device == 0x0185))
		return true;

	/* try and enable MSIs by default on all RS690s */
	if (rdev->family == CHIP_RS690)
		return true;

	/* RV515 seems to have MSI issues where it loses
	 * MSI rearms occasionally. This leads to lockups and freezes.
	 * disable it by default.
	 */
	if (rdev->family == CHIP_RV515)
		return false;
	if (rdev->flags & RADEON_IS_IGP) {
		/* APUs work fine with MSIs */
		if (rdev->family >= CHIP_PALM)
			return true;
		/* lots of IGPs have problems with MSIs */
		return false;
	}

	return true;
}

/**
 * radeon_irq_kms_init - init driver interrupt info
 *
 * @@rdev: radeon device pointer
 *
 * Sets up the work irq handlers, vblank init, MSIs, etc. (all asics).
 * Returns 0 for success, error for failure.
 */
int radeon_irq_kms_init(struct radeon_device *rdev)
{
	int r = 0;

	task_set(&rdev->hotplug_task, radeon_hotplug_work_func, rdev);
	task_set(&rdev->audio_task, r600_audio_update_hdmi, rdev);

	mtx_init(&rdev->irq.lock, IPL_TTY);
	r = drm_vblank_init(rdev->ddev, rdev->num_crtc);
	if (r) {
		return r;
	}
#ifdef notyet
	/* enable msi */
	rdev->msi_enabled = 0;

	if (radeon_msi_ok(rdev)) {
		int ret = pci_enable_msi(rdev->pdev);
		if (!ret) {
			rdev->msi_enabled = 1;
			dev_info(rdev->dev, "radeon: using MSI.\n");
		}
	}
#endif
	rdev->irq.installed = true;
	r = drm_irq_install(rdev->ddev);
	if (r) {
		rdev->irq.installed = false;
		return r;
	}
	DRM_INFO("radeon: irq initialized.\n");
	return 0;
}

/**
 * radeon_irq_kms_fini - tear down driver interrrupt info
 *
 * @@rdev: radeon device pointer
 *
 * Tears down the work irq handlers, vblank handlers, MSIs, etc. (all asics).
 */
void radeon_irq_kms_fini(struct radeon_device *rdev)
{
	drm_vblank_cleanup(rdev->ddev);
	if (rdev->irq.installed) {
		drm_irq_uninstall(rdev->ddev);
		rdev->irq.installed = false;
#ifdef notyet
		if (rdev->msi_enabled)
			pci_disable_msi(rdev->pdev);
#endif
	}
#ifdef notyet
	flush_work(&rdev->hotplug_work);
#endif
}

/**
 * radeon_irq_kms_sw_irq_get - enable software interrupt
 *
 * @@rdev: radeon device pointer
 * @@ring: ring whose interrupt you want to enable
 *
 * Enables the software interrupt for a specific ring (all asics).
 * The software interrupt is generally used to signal a fence on
 * a particular ring.
 */
void radeon_irq_kms_sw_irq_get(struct radeon_device *rdev, int ring)
{
	unsigned long irqflags;

	if (!rdev->ddev->irq_enabled)
		return;

	if (atomic_inc_return(&rdev->irq.ring_int[ring]) == 1) {
		spin_lock_irqsave(&rdev->irq.lock, irqflags);
		radeon_irq_set(rdev);
		spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	}
}

/**
 * radeon_irq_kms_sw_irq_put - disable software interrupt
 *
 * @@rdev: radeon device pointer
 * @@ring: ring whose interrupt you want to disable
 *
 * Disables the software interrupt for a specific ring (all asics).
 * The software interrupt is generally used to signal a fence on
 * a particular ring.
 */
void radeon_irq_kms_sw_irq_put(struct radeon_device *rdev, int ring)
{
	unsigned long irqflags;

	if (!rdev->ddev->irq_enabled)
		return;

	if (atomic_dec_and_test(&rdev->irq.ring_int[ring])) {
		spin_lock_irqsave(&rdev->irq.lock, irqflags);
		radeon_irq_set(rdev);
		spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	}
}

/**
 * radeon_irq_kms_pflip_irq_get - enable pageflip interrupt
 *
 * @@rdev: radeon device pointer
 * @@crtc: crtc whose interrupt you want to enable
 *
 * Enables the pageflip interrupt for a specific crtc (all asics).
 * For pageflips we use the vblank interrupt source.
 */
void radeon_irq_kms_pflip_irq_get(struct radeon_device *rdev, int crtc)
{
	unsigned long irqflags;

	if (crtc < 0 || crtc >= rdev->num_crtc)
		return;

	if (!rdev->ddev->irq_enabled)
		return;

	if (atomic_inc_return(&rdev->irq.pflip[crtc]) == 1) {
		spin_lock_irqsave(&rdev->irq.lock, irqflags);
		radeon_irq_set(rdev);
		spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	}
}

/**
 * radeon_irq_kms_pflip_irq_put - disable pageflip interrupt
 *
 * @@rdev: radeon device pointer
 * @@crtc: crtc whose interrupt you want to disable
 *
 * Disables the pageflip interrupt for a specific crtc (all asics).
 * For pageflips we use the vblank interrupt source.
 */
void radeon_irq_kms_pflip_irq_put(struct radeon_device *rdev, int crtc)
{
	unsigned long irqflags;

	if (crtc < 0 || crtc >= rdev->num_crtc)
		return;

	if (!rdev->ddev->irq_enabled)
		return;

	if (atomic_dec_and_test(&rdev->irq.pflip[crtc])) {
		spin_lock_irqsave(&rdev->irq.lock, irqflags);
		radeon_irq_set(rdev);
		spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	}
}

/**
 * radeon_irq_kms_enable_afmt - enable audio format change interrupt
 *
 * @@rdev: radeon device pointer
 * @@block: afmt block whose interrupt you want to enable
 *
 * Enables the afmt change interrupt for a specific afmt block (all asics).
 */
void radeon_irq_kms_enable_afmt(struct radeon_device *rdev, int block)
{
	unsigned long irqflags;

	if (!rdev->ddev->irq_enabled)
		return;

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	rdev->irq.afmt[block] = true;
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);

}

/**
 * radeon_irq_kms_disable_afmt - disable audio format change interrupt
 *
 * @@rdev: radeon device pointer
 * @@block: afmt block whose interrupt you want to disable
 *
 * Disables the afmt change interrupt for a specific afmt block (all asics).
 */
void radeon_irq_kms_disable_afmt(struct radeon_device *rdev, int block)
{
	unsigned long irqflags;

	if (!rdev->ddev->irq_enabled)
		return;

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	rdev->irq.afmt[block] = false;
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
}

/**
 * radeon_irq_kms_enable_hpd - enable hotplug detect interrupt
 *
 * @@rdev: radeon device pointer
 * @@hpd_mask: mask of hpd pins you want to enable.
 *
 * Enables the hotplug detect interrupt for a specific hpd pin (all asics).
 */
void radeon_irq_kms_enable_hpd(struct radeon_device *rdev, unsigned hpd_mask)
{
	unsigned long irqflags;
	int i;

	if (!rdev->ddev->irq_enabled)
		return;

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	for (i = 0; i < RADEON_MAX_HPD_PINS; ++i)
		rdev->irq.hpd[i] |= !!(hpd_mask & (1 << i));
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
}

/**
 * radeon_irq_kms_disable_hpd - disable hotplug detect interrupt
 *
 * @@rdev: radeon device pointer
 * @@hpd_mask: mask of hpd pins you want to disable.
 *
 * Disables the hotplug detect interrupt for a specific hpd pin (all asics).
 */
void radeon_irq_kms_disable_hpd(struct radeon_device *rdev, unsigned hpd_mask)
{
	unsigned long irqflags;
	int i;

	if (!rdev->ddev->irq_enabled)
		return;

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	for (i = 0; i < RADEON_MAX_HPD_PINS; ++i)
		rdev->irq.hpd[i] &= !(hpd_mask & (1 << i));
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
}

@


1.8
log
@add back some more static use to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.7 2015/02/11 07:01:37 jsg Exp $	*/
d47 1
a47 2
int
radeon_driver_irq_handler_kms(void *arg)
@


1.7
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.6 2015/02/10 10:50:49 jsg Exp $	*/
a37 5
int	 radeon_driver_irq_handler_kms(void *);
void	 radeon_driver_irq_preinstall_kms(struct drm_device *);
int	 radeon_driver_irq_postinstall_kms(struct drm_device *);
void	 radeon_driver_irq_uninstall_kms(struct drm_device *);

d73 1
a73 2
void
radeon_hotplug_work_func(void *arg1)
d174 1
a174 2
bool
radeon_msi_ok(struct radeon_device *rdev)
@


1.6
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.5 2015/01/27 03:17:36 dlg Exp $	*/
d271 1
a271 1
			dev_info(rdev->ddev, "radeon: using MSI.\n");
d281 1
a281 1
	DRM_DEBUG("radeon: irq initialized.\n");
@


1.5
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.4 2014/04/07 06:43:11 jsg Exp $	*/
d105 1
d108 1
a108 1
	mtx_enter(&rdev->irq.lock);
d120 1
a120 1
	mtx_leave(&rdev->irq.lock);
d149 1
d155 1
a155 1
	mtx_enter(&rdev->irq.lock);
d167 1
a167 1
	mtx_leave(&rdev->irq.lock);
d320 2
d326 1
a326 1
		mtx_enter(&rdev->irq.lock);
d328 1
a328 1
		mtx_leave(&rdev->irq.lock);
d344 2
d350 1
a350 1
		mtx_enter(&rdev->irq.lock);
d352 1
a352 1
		mtx_leave(&rdev->irq.lock);
d367 2
d376 1
a376 1
		mtx_enter(&rdev->irq.lock);
d378 1
a378 1
		mtx_leave(&rdev->irq.lock);
d393 2
d402 1
a402 1
		mtx_enter(&rdev->irq.lock);
d404 1
a404 1
		mtx_leave(&rdev->irq.lock);
d418 2
d423 1
a423 1
	mtx_enter(&rdev->irq.lock);
d426 1
a426 1
	mtx_leave(&rdev->irq.lock);
d440 2
d445 1
a445 1
	mtx_enter(&rdev->irq.lock);
d448 1
a448 1
	mtx_leave(&rdev->irq.lock);
d461 1
d467 1
a467 1
	mtx_enter(&rdev->irq.lock);
d471 1
a471 1
	mtx_leave(&rdev->irq.lock);
d484 1
d490 1
a490 1
	mtx_enter(&rdev->irq.lock);
d494 1
a494 1
	mtx_leave(&rdev->irq.lock);
@


1.4
log
@reduce the diff to linux for drm pci vid/pid tests
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.3 2014/01/23 03:15:09 kettenis Exp $	*/
d79 1
a79 1
radeon_hotplug_work_func(void *arg1, void *arg2)
d253 2
a254 2
	task_set(&rdev->hotplug_task, radeon_hotplug_work_func, rdev, NULL);
	task_set(&rdev->audio_task, r600_audio_update_hdmi, rdev, NULL);
@


1.3
log
@Switch radeondrm(4) to MSI on the cards that support it.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.2 2013/10/29 06:30:57 jsg Exp $	*/
d197 3
a199 3
	if ((rdev->ddev->pci_device == 0x791f) &&
	    (rdev->ddev->pci_subvendor == 0x103c) &&
	    (rdev->ddev->pci_subdevice == 0x30c2))
d203 3
a205 3
	if ((rdev->ddev->pci_device == 0x791f) &&
	    (rdev->ddev->pci_subvendor == 0x1028) &&
	    (rdev->ddev->pci_subdevice == 0x01fc))
d209 3
a211 3
	if ((rdev->ddev->pci_device == 0x791f) &&
	    (rdev->ddev->pci_subvendor == 0x1028) &&
	    (rdev->ddev->pci_subdevice == 0x01fd))
d215 3
a217 3
	if ((rdev->ddev->pci_device == 0x791f) &&
	    (rdev->ddev->pci_subvendor == 0x107b) &&
	    (rdev->ddev->pci_subdevice == 0x0185))
@


1.2
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_irq_kms.c,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/
a41 1
bool	 radeon_msi_ok(struct radeon_device *);
d261 1
a264 1
#ifdef notyet
@


1.1
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d253 3
@

