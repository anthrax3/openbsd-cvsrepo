head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.2
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.35.0.4
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24;
locks; strict;
comment	@ * @;


1.52
date	2017.07.19.22.02.39;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	5mJz6p98gUiNGKkn;

1.51
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.50;
commitid	KnwRPOZok9A30HI4;

1.50
date	2017.06.19.11.03.30;	author fcambus;	state Exp;
branches;
next	1.49;
commitid	SamzBAZ2ZeR9zGPu;

1.49
date	2017.01.08.12.11.54;	author fcambus;	state Exp;
branches;
next	1.48;
commitid	gSiPorOnVEG1sSRV;

1.48
date	2016.04.08.08.27.53;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	mS4ttEBzpAfn3sVx;

1.47
date	2016.02.03.07.42.14;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	LLpkFBTlP5MxlxUt;

1.46
date	2016.01.06.19.56.08;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	ZJogda9tW3QaOXRL;

1.45
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.44;
commitid	fbhqfhfdKxBcsetK;

1.44
date	2015.11.22.15.35.49;	author kettenis;	state Exp;
branches;
next	1.43;
commitid	sDPS7MogSiSWMILu;

1.43
date	2015.11.16.11.24.58;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	RXiv8q3au4yiZuF1;

1.42
date	2015.09.27.16.13.23;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	SoxmrsbG1IHComht;

1.41
date	2015.09.26.19.52.16;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	PpEJMvqmELqAFnQv;

1.40
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	lQlppvmETCN49oZe;

1.39
date	2015.04.18.11.05.32;	author jsg;	state Exp;
branches;
next	1.38;
commitid	N5rmYm7ybHimJmMa;

1.38
date	2015.04.17.00.54.42;	author jsg;	state Exp;
branches;
next	1.37;
commitid	LqdQe79hlknpVtvI;

1.37
date	2015.04.06.12.25.10;	author jsg;	state Exp;
branches;
next	1.36;
commitid	CN1fAwudhSb2ckyl;

1.36
date	2015.04.06.07.38.49;	author jsg;	state Exp;
branches;
next	1.35;
commitid	A7VgsFjPNML2ZK3Q;

1.35
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.34;
commitid	dLgISW35NAmGN8Xl;

1.34
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.33;
commitid	aHLMSW1RfE1rmMw9;

1.33
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.32;
commitid	a8Vt7gSt34kmziIS;

1.32
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.31;
commitid	MyKPm9Q3dQu92BiX;

1.31
date	2014.12.20.16.34.27;	author krw;	state Exp;
branches;
next	1.30;
commitid	HzEf4vz6A0HRFIhU;

1.30
date	2014.10.25.14.20.09;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	SiWaMEyZSHR4LF76;

1.29
date	2014.07.06.08.24.54;	author jsg;	state Exp;
branches;
next	1.28;
commitid	nKU5FNUQGApjMHnX;

1.28
date	2014.06.21.04.37.42;	author jsg;	state Exp;
branches;
next	1.27;
commitid	VGrSKhz1kZ4Ho5rh;

1.27
date	2014.04.07.06.43.11;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.30.02.12.23;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.13.12.45.04;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2014.02.25.00.03.38;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2014.02.23.09.36.52;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2014.02.10.01.59.48;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2014.02.10.00.47.19;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2014.02.09.11.03.31;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.23.03.15.09;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.20.09.36.46;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2013.12.22.21.03.45;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.22.19.49.23;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2013.12.05.13.29.56;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2013.11.30.12.58.39;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.28.21.45.36;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.27.20.41.19;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.17.13.41.26;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.21.10.36.24;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.20.20.07.29;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.20.10.43.48;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.18.14.35.20;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2013.10.18.12.34.52;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2013.09.08.11.59.45;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.27.07.44.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.08.16.19.53.53;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.08.16.19.36.50;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.12.04.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Implement the enter_ddb() "accessop" here as well.
@
text
@/*	$OpenBSD: radeon_kms.c,v 1.51 2017/07/01 16:14:10 kettenis Exp $	*/
/*
 * Copyright 2008 Advanced Micro Devices, Inc.
 * Copyright 2008 Red Hat Inc.
 * Copyright 2009 Jerome Glisse.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors: Dave Airlie
 *          Alex Deucher
 *          Jerome Glisse
 */
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_fb_helper.h>
#include "radeon.h"
#include <dev/pci/drm/radeon_drm.h>
#include "radeon_asic.h"
#include <dev/pci/drm/drm_pciids.h>

/* can't include radeon_drv.h due to duplicated defines in radeon_reg.h */

#include "vga.h"

#if NVGA > 0
extern int vga_console_attached;
#endif

#ifdef __amd64__
#include "efifb.h"
#endif

#if NEFIFB > 0
#include <machine/efifbvar.h>
#endif

#define DRIVER_NAME		"radeon"
#define DRIVER_DESC		"ATI Radeon"
#define DRIVER_DATE		"20080613"

#define KMS_DRIVER_MAJOR	2
#define KMS_DRIVER_MINOR	29
#define KMS_DRIVER_PATCHLEVEL	0

int	radeon_driver_irq_handler_kms(void *);
void	radeon_driver_irq_preinstall_kms(struct drm_device *);
int	radeon_driver_irq_postinstall_kms(struct drm_device *);
void	radeon_driver_irq_uninstall_kms(struct drm_device *d);

void	radeon_gem_object_free(struct drm_gem_object *);
int	radeon_gem_object_open(struct drm_gem_object *, struct drm_file *);
void	radeon_gem_object_close(struct drm_gem_object *, struct drm_file *);

int	radeon_driver_unload_kms(struct drm_device *);
int	radeon_driver_load_kms(struct drm_device *, unsigned long);
int	radeon_info_ioctl(struct drm_device *, void *, struct drm_file *);
int	radeon_driver_firstopen_kms(struct drm_device *);
void	radeon_driver_lastclose_kms(struct drm_device *);
int	radeon_driver_open_kms(struct drm_device *, struct drm_file *);
void	radeon_driver_postclose_kms(struct drm_device *, struct drm_file *);
void	radeon_driver_preclose_kms(struct drm_device *, struct drm_file *);
u32	radeon_get_vblank_counter_kms(struct drm_device *, unsigned int);
int	radeon_enable_vblank_kms(struct drm_device *, unsigned int);
void	radeon_disable_vblank_kms(struct drm_device *, unsigned int);
int	radeon_get_vblank_timestamp_kms(struct drm_device *, unsigned int,
	    int *, struct timeval *, unsigned);

int	radeon_dma_ioctl_kms(struct drm_device *, struct drm_dma *, struct drm_file *);

int	radeon_cp_init_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_start_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_stop_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_reset_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_idle_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_resume_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_engine_reset_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_fullscreen_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_swap_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_clear_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_vertex_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_indices_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_texture_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_stipple_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_indirect_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_vertex2_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_cmdbuf_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_getparam_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_flip_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_mem_alloc_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_mem_free_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_mem_init_heap_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_irq_emit_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_irq_wait_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_cp_setparam_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_surface_alloc_kms(struct drm_device *, void *, struct drm_file *);
int	radeon_surface_free_kms(struct drm_device *, void *, struct drm_file *);

int	radeondrm_probe(struct device *, void *, void *);
void	radeondrm_attach_kms(struct device *, struct device *, void *);
int	radeondrm_detach_kms(struct device *, int);
int	radeondrm_activate_kms(struct device *, int);
void	radeondrm_attachhook(struct device *);
int	radeondrm_forcedetach(struct radeon_device *);

extern struct drm_ioctl_desc radeon_ioctls_kms[];
extern int radeon_max_kms_ioctl;

struct cfattach radeondrm_ca = {
        sizeof (struct radeon_device), radeondrm_probe, radeondrm_attach_kms,
        radeondrm_detach_kms, radeondrm_activate_kms
};

struct cfdriver radeondrm_cd = { 
	NULL, "radeondrm", DV_DULL
};

int radeon_no_wb;
int radeon_modeset = 1;
int radeon_dynclks = -1;
int radeon_r4xx_atom = 0;
int radeon_agpmode = 0;
int radeon_vram_limit = 0;
int radeon_gart_size = 512; /* default gart size */
int radeon_benchmarking = 0;
int radeon_testing = 0;
int radeon_connector_table = 0;
int radeon_tv = 1;
int radeon_audio = 0;
int radeon_disp_priority = 0;
int radeon_hw_i2c = 0;
int radeon_pcie_gen2 = -1;
int radeon_msi = -1;
int radeon_lockup_timeout = 10000;
int radeon_auxch = -1;

MODULE_PARM_DESC(no_wb, "Disable AGP writeback for scratch registers");
module_param_named(no_wb, radeon_no_wb, int, 0444);

MODULE_PARM_DESC(modeset, "Disable/Enable modesetting");
module_param_named(modeset, radeon_modeset, int, 0400);

MODULE_PARM_DESC(dynclks, "Disable/Enable dynamic clocks");
module_param_named(dynclks, radeon_dynclks, int, 0444);

MODULE_PARM_DESC(r4xx_atom, "Enable ATOMBIOS modesetting for R4xx");
module_param_named(r4xx_atom, radeon_r4xx_atom, int, 0444);

MODULE_PARM_DESC(vramlimit, "Restrict VRAM for testing");
module_param_named(vramlimit, radeon_vram_limit, int, 0600);

MODULE_PARM_DESC(agpmode, "AGP Mode (-1 == PCI)");
module_param_named(agpmode, radeon_agpmode, int, 0444);

MODULE_PARM_DESC(gartsize, "Size of PCIE/IGP gart to setup in megabytes (32, 64, etc)");
module_param_named(gartsize, radeon_gart_size, int, 0600);

MODULE_PARM_DESC(benchmark, "Run benchmark");
module_param_named(benchmark, radeon_benchmarking, int, 0444);

MODULE_PARM_DESC(test, "Run tests");
module_param_named(test, radeon_testing, int, 0444);

MODULE_PARM_DESC(connector_table, "Force connector table");
module_param_named(connector_table, radeon_connector_table, int, 0444);

MODULE_PARM_DESC(tv, "TV enable (0 = disable)");
module_param_named(tv, radeon_tv, int, 0444);

MODULE_PARM_DESC(audio, "Audio enable (1 = enable)");
module_param_named(audio, radeon_audio, int, 0444);

MODULE_PARM_DESC(disp_priority, "Display Priority (0 = auto, 1 = normal, 2 = high)");
module_param_named(disp_priority, radeon_disp_priority, int, 0444);

MODULE_PARM_DESC(hw_i2c, "hw i2c engine enable (0 = disable)");
module_param_named(hw_i2c, radeon_hw_i2c, int, 0444);

MODULE_PARM_DESC(pcie_gen2, "PCIE Gen2 mode (-1 = auto, 0 = disable, 1 = enable)");
module_param_named(pcie_gen2, radeon_pcie_gen2, int, 0444);

MODULE_PARM_DESC(msi, "MSI support (1 = enable, 0 = disable, -1 = auto)");
module_param_named(msi, radeon_msi, int, 0444);

MODULE_PARM_DESC(lockup_timeout, "GPU lockup timeout in ms (defaul 10000 = 10 seconds, 0 = disable)");
module_param_named(lockup_timeout, radeon_lockup_timeout, int, 0444);

/*
 * set if the mountroot hook has a fatal error
 * such as not being able to find the firmware on newer cards
 */
int radeon_fatal_error = 0;

const struct drm_pcidev radeondrm_pciidlist[] = {
	radeon_PCI_IDS
};

static struct drm_driver kms_driver = {
	.driver_features =
	    DRIVER_USE_AGP |
	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM |
	    DRIVER_MODESET,
	.buf_priv_size = 0,
	.firstopen = radeon_driver_firstopen_kms,
	.open = radeon_driver_open_kms,
	.mmap = radeon_mmap,
#ifdef notyet
	.preclose = radeon_driver_preclose_kms,
	.postclose = radeon_driver_postclose_kms,
#endif
	.lastclose = radeon_driver_lastclose_kms,
#ifdef notyet
	.suspend = radeon_suspend_kms,
	.resume = radeon_resume_kms,
#endif
	.get_vblank_counter = radeon_get_vblank_counter_kms,
	.enable_vblank = radeon_enable_vblank_kms,
	.disable_vblank = radeon_disable_vblank_kms,
	.get_vblank_timestamp = radeon_get_vblank_timestamp_kms,
	.get_scanout_position = radeon_get_crtc_scanoutpos,
#if defined(CONFIG_DEBUG_FS)
	.debugfs_init = radeon_debugfs_init,
	.debugfs_cleanup = radeon_debugfs_cleanup,
#endif
	.irq_preinstall = radeon_driver_irq_preinstall_kms,
	.irq_postinstall = radeon_driver_irq_postinstall_kms,
	.irq_uninstall = radeon_driver_irq_uninstall_kms,
	.ioctls = radeon_ioctls_kms,
	.gem_free_object = radeon_gem_object_free,
	.gem_open_object = radeon_gem_object_open,
	.gem_close_object = radeon_gem_object_close,
	.gem_size = sizeof(struct radeon_bo),
	.dma_ioctl = radeon_dma_ioctl_kms,
	.dumb_create = radeon_mode_dumb_create,
	.dumb_map_offset = radeon_mode_dumb_mmap,
	.dumb_destroy = radeon_mode_dumb_destroy,
#ifdef notyet
	.fops = &radeon_driver_kms_fops,

	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
	.gem_prime_export = radeon_gem_prime_export,
	.gem_prime_import = radeon_gem_prime_import,
#endif

	.name = DRIVER_NAME,
	.desc = DRIVER_DESC,
	.date = DRIVER_DATE,
	.major = KMS_DRIVER_MAJOR,
	.minor = KMS_DRIVER_MINOR,
	.patchlevel = KMS_DRIVER_PATCHLEVEL,
};

int
radeondrm_probe(struct device *parent, void *match, void *aux)
{
	if (radeon_fatal_error)
		return 0;
	if (drm_pciprobe(aux, radeondrm_pciidlist))
		return 20;
	return 0;
}

/**
 * radeon_driver_unload_kms - Main unload function for KMS.
 *
 * @@dev: drm dev pointer
 *
 * This is the main unload function for KMS (all asics).
 * It calls radeon_modeset_fini() to tear down the
 * displays, and radeon_device_fini() to tear down
 * the rest of the device (CP, writeback, etc.).
 * Returns 0 on success.
 */
int
radeondrm_detach_kms(struct device *self, int flags)
{
	struct radeon_device *rdev = (struct radeon_device *)self;

	if (rdev == NULL)
		return 0;

	radeon_acpi_fini(rdev);
	radeon_modeset_fini(rdev);
	radeon_device_fini(rdev);

	if (rdev->ddev != NULL) {
		config_detach((struct device *)rdev->ddev, flags);
		rdev->ddev = NULL;
	}

	pci_intr_disestablish(rdev->pc, rdev->irqh);

	if (rdev->rmmio_size > 0)
		bus_space_unmap(rdev->memt, rdev->rmmio, rdev->rmmio_size);

	return 0;
}

int radeondrm_wsioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t radeondrm_wsmmap(void *, off_t, int);
int radeondrm_alloc_screen(void *, const struct wsscreen_descr *,
    void **, int *, int *, long *);
void radeondrm_free_screen(void *, void *);
int radeondrm_show_screen(void *, void *, int,
    void (*)(void *, int, int), void *);
void radeondrm_doswitch(void *);
void radeondrm_enter_ddb(void *, void *);
#ifdef __sparc64__
void radeondrm_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);
#endif

struct wsscreen_descr radeondrm_stdscreen = {
	"std",
	0, 0,
	0,
	0, 0,
	WSSCREEN_UNDERLINE | WSSCREEN_HILIT |
	WSSCREEN_REVERSE | WSSCREEN_WSCOLORS
};

const struct wsscreen_descr *radeondrm_scrlist[] = {
	&radeondrm_stdscreen,
};

struct wsscreen_list radeondrm_screenlist = {
	nitems(radeondrm_scrlist), radeondrm_scrlist
};

struct wsdisplay_accessops radeondrm_accessops = {
	.ioctl = radeondrm_wsioctl,
	.mmap = radeondrm_wsmmap,
	.alloc_screen = radeondrm_alloc_screen,
	.free_screen = radeondrm_free_screen,
	.show_screen = radeondrm_show_screen,
	.enter_ddb = radeondrm_enter_ddb,
	.getchar = rasops_getchar,
	.load_font = rasops_load_font,
	.list_font = rasops_list_font,
	.burn_screen = radeondrm_burner
};

int
radeondrm_wsioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct rasops_info *ri = v;
	struct wsdisplay_fbinfo *wdf;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(int *)data = WSDISPLAY_TYPE_RADEONDRM;
		return 0;
	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->width = ri->ri_width;
		wdf->height = ri->ri_height;
		wdf->depth = ri->ri_depth;
		wdf->cmsize = 0;
		return 0;
	default:
		return -1;
	}
}

paddr_t
radeondrm_wsmmap(void *v, off_t off, int prot)
{
	return (-1);
}

int
radeondrm_alloc_screen(void *v, const struct wsscreen_descr *type,
    void **cookiep, int *curxp, int *curyp, long *attrp)
{
	return rasops_alloc_screen(v, cookiep, curxp, curyp, attrp);
}

void
radeondrm_free_screen(void *v, void *cookie)
{
	return rasops_free_screen(v, cookie);
}

int
radeondrm_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct rasops_info *ri = v;
	struct radeon_device *rdev = ri->ri_hw;

	if (cookie == ri->ri_active)
		return (0);

	rdev->switchcb = cb;
	rdev->switchcbarg = cbarg;
	rdev->switchcookie = cookie;
	if (cb) {
		task_add(systq, &rdev->switchtask);
		return (EAGAIN);
	}

	radeondrm_doswitch(v);

	return (0);
}

void
radeondrm_doswitch(void *v)
{
	struct rasops_info *ri = v;
	struct radeon_device *rdev = ri->ri_hw;
	struct radeon_crtc *radeon_crtc;
	int i, crtc;

	rasops_show_screen(ri, rdev->switchcookie, 0, NULL, NULL);
	for (crtc = 0; crtc < rdev->num_crtc; crtc++) {
		for (i = 0; i < 256; i++) {
			radeon_crtc = rdev->mode_info.crtcs[crtc];
			radeon_crtc->lut_r[i] = rasops_cmap[3 * i] << 2;
			radeon_crtc->lut_g[i] = rasops_cmap[(3 * i) + 1] << 2;
			radeon_crtc->lut_b[i] = rasops_cmap[(3 * i) + 2] << 2;
		}
	}
#ifdef __sparc64__
	fbwscons_setcolormap(&rdev->sf, radeondrm_setcolor);
#endif
	drm_fb_helper_restore_fbdev_mode_unlocked((void *)rdev->mode_info.rfbdev);

	if (rdev->switchcb)
		(rdev->switchcb)(rdev->switchcbarg, 0, 0);
}

void
radeondrm_enter_ddb(void *v, void *cookie)
{
	struct rasops_info *ri = v;
	struct radeon_device *rdev = ri->ri_hw;
	struct drm_fb_helper *fb_helper = (void *)rdev->mode_info.rfbdev;

	if (cookie == ri->ri_active)
		return;

	rasops_show_screen(ri, cookie, 0, NULL, NULL);
	drm_fb_helper_debug_enter(fb_helper->fbdev);
}

#ifdef __sparc64__
void
radeondrm_setcolor(void *v, u_int index, u_int8_t r, u_int8_t g, u_int8_t b)
{
	struct sunfb *sf = v;
	struct radeon_device *rdev = sf->sf_ro.ri_hw;
	struct drm_fb_helper *fb_helper = (void *)rdev->mode_info.rfbdev;
	u_int16_t red, green, blue;
	struct drm_crtc *crtc;
	int i;

	for (i = 0; i < fb_helper->crtc_count; i++) {
		crtc = fb_helper->crtc_info[i].mode_set.crtc;

		red = (r << 8) | r;
		green = (g << 8) | g;
		blue = (b << 8) | b;
		fb_helper->funcs->gamma_set(crtc, red, green, blue, index);
	}
}
#endif

/**
 * radeon_driver_load_kms - Main load function for KMS.
 *
 * @@dev: drm dev pointer
 * @@flags: device flags
 *
 * This is the main load function for KMS (all asics).
 * It calls radeon_device_init() to set up the non-display
 * parts of the chip (asic init, CP, writeback, etc.), and
 * radeon_modeset_init() to set up the display parts
 * (crtcs, encoders, hotplug detect, etc.).
 * Returns 0 on success, error on failure.
 */
void
radeondrm_attach_kms(struct device *parent, struct device *self, void *aux)
{
	struct radeon_device	*rdev = (struct radeon_device *)self;
	struct drm_device	*dev;
	struct pci_attach_args	*pa = aux;
	const struct drm_pcidev *id_entry;
	int			 is_agp;
	pcireg_t		 type;
	uint8_t			 iobar;
#if !defined(__sparc64__)
	pcireg_t		 addr, mask;
	int			 s;
#endif

#if defined(__sparc64__) || defined(__macppc__)
	extern int fbnode;
#endif

	id_entry = drm_find_description(PCI_VENDOR(pa->pa_id),
	    PCI_PRODUCT(pa->pa_id), radeondrm_pciidlist);
	rdev->flags = id_entry->driver_data;
	rdev->pc = pa->pa_pc;
	rdev->pa_tag = pa->pa_tag;
	rdev->iot = pa->pa_iot;
	rdev->memt = pa->pa_memt;
	rdev->dmat = pa->pa_dmat;

#if defined(__sparc64__) || defined(__macppc__)
	if (fbnode == PCITAG_NODE(rdev->pa_tag))
		rdev->console = 1;
#else
	if (PCI_CLASS(pa->pa_class) == PCI_CLASS_DISPLAY &&
	    PCI_SUBCLASS(pa->pa_class) == PCI_SUBCLASS_DISPLAY_VGA &&
	    (pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG)
	    & (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE))
	    == (PCI_COMMAND_IO_ENABLE | PCI_COMMAND_MEM_ENABLE)) {
		rdev->console = 1;
#if NVGA > 0
		vga_console_attached = 1;
#endif
	}
#if NEFIFB > 0
	if (efifb_is_console(pa)) {
		rdev->console = 1;
		efifb_cndetach();
	}
#endif
#endif

#define RADEON_PCI_MEM		0x10
#define RADEON_PCI_IO		0x14
#define RADEON_PCI_MMIO		0x18
#define RADEON_PCI_IO2		0x20

	type = pci_mapreg_type(pa->pa_pc, pa->pa_tag, RADEON_PCI_MEM);
	if (PCI_MAPREG_TYPE(type) != PCI_MAPREG_TYPE_MEM ||
	    pci_mapreg_info(pa->pa_pc, pa->pa_tag, RADEON_PCI_MEM,
	    type, &rdev->fb_aper_offset, &rdev->fb_aper_size, NULL)) {
		printf(": can't get frambuffer info\n");
		return;
	}

	if (PCI_MAPREG_MEM_TYPE(type) != PCI_MAPREG_MEM_TYPE_64BIT)
		iobar = RADEON_PCI_IO;
	else
		iobar = RADEON_PCI_IO2;
	
	if (pci_mapreg_map(pa, iobar, PCI_MAPREG_TYPE_IO, 0,
	    NULL, &rdev->rio_mem, NULL, &rdev->rio_mem_size, 0)) {
		printf(": can't map IO space\n");
		return;
	}

	type = pci_mapreg_type(pa->pa_pc, pa->pa_tag, RADEON_PCI_MMIO);
	if (PCI_MAPREG_TYPE(type) != PCI_MAPREG_TYPE_MEM ||
	    pci_mapreg_map(pa, RADEON_PCI_MMIO, type, 0, NULL,
	    &rdev->rmmio, &rdev->rmmio_base, &rdev->rmmio_size, 0)) {
		printf(": can't map mmio space\n");
		return;
	}

#if !defined(__sparc64__)
	/*
	 * Make sure we have a base address for the ROM such that we
	 * can map it later.
	 */
	s = splhigh();
	addr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, ~PCI_ROM_ENABLE);
	mask = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_ROM_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, addr);
	splx(s);

	if (addr == 0 && PCI_ROM_SIZE(mask) != 0 && pa->pa_memex) {
		bus_size_t size, start, end;
		bus_addr_t base;

		size = PCI_ROM_SIZE(mask);
		start = max(PCI_MEM_START, pa->pa_memex->ex_start);
		end = min(PCI_MEM_END, pa->pa_memex->ex_end);
		if (extent_alloc_subregion(pa->pa_memex, start, end, size,
		    size, 0, 0, 0, &base) == 0)
			pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_ROM_REG, base);
	}
#endif

#ifdef notyet
	mtx_init(&rdev->swi_lock, IPL_TTY);
#endif

	/* update BUS flag */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP, NULL, NULL)) {
		rdev->flags |= RADEON_IS_AGP;
	} else if (pci_get_capability(pa->pa_pc, pa->pa_tag,
	    PCI_CAP_PCIEXPRESS, NULL, NULL)) {
		rdev->flags |= RADEON_IS_PCIE;
	} else {
		rdev->flags |= RADEON_IS_PCI;
	}

	DRM_DEBUG("%s card detected\n",
		 ((rdev->flags & RADEON_IS_AGP) ? "AGP" :
		 (((rdev->flags & RADEON_IS_PCIE) ? "PCIE" : "PCI"))));

	is_agp = pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
	    NULL, NULL);

	printf("\n");

	kms_driver.num_ioctls = radeon_max_kms_ioctl;

	dev = (struct drm_device *)drm_attach_pci(&kms_driver, pa, is_agp,
	    rdev->console, self);
	rdev->ddev = dev;
	rdev->pdev = dev->pdev;

	rdev->family = rdev->flags & RADEON_FAMILY_MASK;
	if (!radeon_msi_ok(rdev))
		pa->pa_flags &= ~PCI_FLAGS_MSI_ENABLED;

	rdev->msi_enabled = 0;
	if (pci_intr_map_msi(pa, &rdev->intrh) == 0)
		rdev->msi_enabled = 1;
	else if (pci_intr_map(pa, &rdev->intrh) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
	printf("%s: %s\n", rdev->dev.dv_xname,
	    pci_intr_string(pa->pa_pc, rdev->intrh));

	rdev->irqh = pci_intr_establish(pa->pa_pc, rdev->intrh, IPL_TTY,
	    radeon_driver_irq_handler_kms, rdev->ddev, rdev->dev.dv_xname);
	if (rdev->irqh == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    rdev->dev.dv_xname);
		return;
	}
	rdev->pdev->irq = -1;

#ifdef __sparc64__
{
	struct rasops_info *ri;
	int node, console;

	node = PCITAG_NODE(pa->pa_tag);
	console = (fbnode == node);

	fb_setsize(&rdev->sf, 8, 1152, 900, node, 0);

	/*
	 * The firmware sets up the framebuffer such that at starts at
	 * an offset from the start of video memory.
	 */
	rdev->fb_offset =
	    bus_space_read_4(rdev->memt, rdev->rmmio, RADEON_CRTC_OFFSET);
	if (bus_space_map(rdev->memt, rdev->fb_aper_offset + rdev->fb_offset,
	    rdev->sf.sf_fbsize, BUS_SPACE_MAP_LINEAR, &rdev->memh)) {
		printf("%s: can't map video memory\n", rdev->dev.dv_xname);
		return;
	}

	ri = &rdev->sf.sf_ro;
	ri->ri_bits = bus_space_vaddr(rdev->memt, rdev->memh);
	ri->ri_hw = rdev;
	ri->ri_updatecursor = NULL;

	fbwscons_init(&rdev->sf, RI_VCONS | RI_WRONLY | RI_BSWAP, console);
	if (console)
		fbwscons_console_init(&rdev->sf, -1);
}
#endif

	rdev->shutdown = true;
	config_mountroot(self, radeondrm_attachhook);
}

int
radeondrm_forcedetach(struct radeon_device *rdev)
{
	struct pci_softc	*sc = (struct pci_softc *)rdev->dev.dv_parent;
	pcitag_t		 tag = rdev->pa_tag;

#if NVGA > 0
	if (rdev->console)
		vga_console_attached = 0;
#endif

	config_detach(&rdev->dev, 0);
	return pci_probe_device(sc, tag, NULL, NULL);
}

void
radeondrm_attachhook(struct device *self)
{
	struct radeon_device	*rdev = (struct radeon_device *)self;
	int			 r, acpi_status;

	/* radeon_device_init should report only fatal error
	 * like memory allocation failure or iomapping failure,
	 * or memory manager initialization failure, it must
	 * properly initialize the GPU MC controller and permit
	 * VRAM allocation
	 */
	r = radeon_device_init(rdev, rdev->ddev);
	if (r) {
		dev_err(&dev->pdev->dev, "Fatal error during GPU init\n");
		radeon_fatal_error = 1;
		radeondrm_forcedetach(rdev);
		return;
	}

	/* Again modeset_init should fail only on fatal error
	 * otherwise it should provide enough functionalities
	 * for shadowfb to run
	 */
	r = radeon_modeset_init(rdev);
	if (r)
		dev_err(&dev->pdev->dev, "Fatal error during modeset init\n");

	/* Call ACPI methods: require modeset init
	 * but failure is not fatal
	 */
	if (!r) {
		acpi_status = radeon_acpi_init(rdev);
		if (acpi_status)
			DRM_DEBUG("Error during ACPI methods call\n");
	}

{
	struct drm_fb_helper *fb_helper = (void *)rdev->mode_info.rfbdev;
	struct wsemuldisplaydev_attach_args aa;
	struct rasops_info *ri = &rdev->ro;

	task_set(&rdev->switchtask, radeondrm_doswitch, ri);

	if (ri->ri_bits == NULL)
		return;

#ifdef __sparc64__
	fbwscons_setcolormap(&rdev->sf, radeondrm_setcolor);
#endif
	drm_fb_helper_restore_fbdev_mode_unlocked(fb_helper);

#ifndef __sparc64__
	ri->ri_flg = RI_CENTER | RI_VCONS | RI_WRONLY;
	rasops_init(ri, 160, 160);

	ri->ri_hw = rdev;
#else
	ri = &rdev->sf.sf_ro;
#endif

	radeondrm_stdscreen.capabilities = ri->ri_caps;
	radeondrm_stdscreen.nrows = ri->ri_rows;
	radeondrm_stdscreen.ncols = ri->ri_cols;
	radeondrm_stdscreen.textops = &ri->ri_ops;
	radeondrm_stdscreen.fontwidth = ri->ri_font->fontwidth;
	radeondrm_stdscreen.fontheight = ri->ri_font->fontheight;

	aa.console = rdev->console;
	aa.scrdata = &radeondrm_screenlist;
	aa.accessops = &radeondrm_accessops;
	aa.accesscookie = ri;
	aa.defaultscreens = 0;

	if (rdev->console) {
		long defattr;

		ri->ri_ops.alloc_attr(ri->ri_active, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&radeondrm_stdscreen, ri->ri_active,
		    ri->ri_ccol, ri->ri_crow, defattr);
	}

	/*
	 * Now that we've taken over the console, disable decoding of
	 * VGA legacy addresses, and opt out of arbitration.
	 */
	radeon_vga_set_state(rdev, false);
	pci_disable_legacy_vga(&rdev->dev);

	printf("%s: %dx%d, %dbpp\n", rdev->dev.dv_xname,
	    ri->ri_width, ri->ri_height, ri->ri_depth);

	config_found_sm(&rdev->dev, &aa, wsemuldisplaydevprint,
	    wsemuldisplaydevsubmatch);
}
}

int
radeondrm_activate_kms(struct device *self, int act)
{
	struct radeon_device *rdev = (struct radeon_device *)self;
	int rv = 0;

	if (rdev->ddev == NULL)
		return (0);

	switch (act) {
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		radeon_suspend_kms(rdev->ddev);
		break;
	case DVACT_SUSPEND:
		break;
	case DVACT_RESUME:
		break;
	case DVACT_WAKEUP:
		radeon_resume_kms(rdev->ddev);
		rv = config_activate_children(self, act);
		break;
	}

	return (rv);
}

/**
 * radeon_set_filp_rights - Set filp right.
 *
 * @@dev: drm dev pointer
 * @@owner: drm file
 * @@applier: drm file
 * @@value: value
 *
 * Sets the filp rights for the device (all asics).
 */
static void radeon_set_filp_rights(struct drm_device *dev,
				   struct drm_file **owner,
				   struct drm_file *applier,
				   uint32_t *value)
{
	mutex_lock(&dev->struct_mutex);
	if (*value == 1) {
		/* wants rights */
		if (!*owner)
			*owner = applier;
	} else if (*value == 0) {
		/* revokes rights */
		if (*owner == applier)
			*owner = NULL;
	}
	*value = *owner == applier ? 1 : 0;
	mutex_unlock(&dev->struct_mutex);
}

/*
 * Userspace get information ioctl
 */
/**
 * radeon_info_ioctl - answer a device specific request.
 *
 * @@rdev: radeon device pointer
 * @@data: request object
 * @@filp: drm filp
 *
 * This function is used to pass device specific parameters to the userspace
 * drivers.  Examples include: pci device id, pipeline parms, tiling params,
 * etc. (all asics).
 * Returns 0 on success, -EINVAL on failure.
 */
int radeon_info_ioctl(struct drm_device *dev, void *data, struct drm_file *filp)
{
	struct radeon_device *rdev = dev->dev_private;
	struct drm_radeon_info *info = data;
	struct radeon_mode_info *minfo = &rdev->mode_info;
	uint32_t value, *value_ptr;
	uint64_t value64, *value_ptr64;
	struct drm_crtc *crtc;
	int i, found;

	/* TIMESTAMP is a 64-bit value, needs special handling. */
	if (info->request == RADEON_INFO_TIMESTAMP) {
		if (rdev->family >= CHIP_R600) {
			value_ptr64 = (uint64_t*)((unsigned long)info->value);
			if (rdev->family >= CHIP_TAHITI) {
				value64 = si_get_gpu_clock(rdev);
			} else {
				value64 = r600_get_gpu_clock(rdev);
			}

			if (DRM_COPY_TO_USER(value_ptr64, &value64, sizeof(value64))) {
				DRM_ERROR("copy_to_user %s:%u\n", __func__, __LINE__);
				return -EFAULT;
			}
			return 0;
		} else {
			DRM_DEBUG_KMS("timestamp is r6xx+ only!\n");
			return -EINVAL;
		}
	}

	value_ptr = (uint32_t *)((unsigned long)info->value);
	if (DRM_COPY_FROM_USER(&value, value_ptr, sizeof(value))) {
		DRM_ERROR("copy_from_user %s:%u\n", __func__, __LINE__);
		return -EFAULT;
	}

	switch (info->request) {
	case RADEON_INFO_DEVICE_ID:
		value = dev->pci_device;
		break;
	case RADEON_INFO_NUM_GB_PIPES:
		value = rdev->num_gb_pipes;
		break;
	case RADEON_INFO_NUM_Z_PIPES:
		value = rdev->num_z_pipes;
		break;
	case RADEON_INFO_ACCEL_WORKING:
		/* xf86-video-ati 6.13.0 relies on this being false for evergreen */
		if ((rdev->family >= CHIP_CEDAR) && (rdev->family <= CHIP_HEMLOCK))
			value = false;
		else
			value = rdev->accel_working;
		break;
	case RADEON_INFO_CRTC_FROM_ID:
		for (i = 0, found = 0; i < rdev->num_crtc; i++) {
			crtc = (struct drm_crtc *)minfo->crtcs[i];
			if (crtc && crtc->base.id == value) {
				struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
				value = radeon_crtc->crtc_id;
				found = 1;
				break;
			}
		}
		if (!found) {
			DRM_DEBUG_KMS("unknown crtc id %d\n", value);
			return -EINVAL;
		}
		break;
	case RADEON_INFO_ACCEL_WORKING2:
		value = rdev->accel_working;
		break;
	case RADEON_INFO_TILING_CONFIG:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.tile_config;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.tile_config;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.tile_config;
		else if (rdev->family >= CHIP_RV770)
			value = rdev->config.rv770.tile_config;
		else if (rdev->family >= CHIP_R600)
			value = rdev->config.r600.tile_config;
		else {
			DRM_DEBUG_KMS("tiling config is r6xx+ only!\n");
			return -EINVAL;
		}
		break;
	case RADEON_INFO_WANT_HYPERZ:
		/* The "value" here is both an input and output parameter.
		 * If the input value is 1, filp requests hyper-z access.
		 * If the input value is 0, filp revokes its hyper-z access.
		 *
		 * When returning, the value is 1 if filp owns hyper-z access,
		 * 0 otherwise. */
		if (value >= 2) {
			DRM_DEBUG_KMS("WANT_HYPERZ: invalid value %d\n", value);
			return -EINVAL;
		}
		radeon_set_filp_rights(dev, &rdev->hyperz_filp, filp, &value);
		break;
	case RADEON_INFO_WANT_CMASK:
		/* The same logic as Hyper-Z. */
		if (value >= 2) {
			DRM_DEBUG_KMS("WANT_CMASK: invalid value %d\n", value);
			return -EINVAL;
		}
		radeon_set_filp_rights(dev, &rdev->cmask_filp, filp, &value);
		break;
	case RADEON_INFO_CLOCK_CRYSTAL_FREQ:
		/* return clock value in KHz */
		value = rdev->clock.spll.reference_freq * 10;
		break;
	case RADEON_INFO_NUM_BACKENDS:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.max_backends_per_se *
				rdev->config.si.max_shader_engines;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.max_backends_per_se *
				rdev->config.cayman.max_shader_engines;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.max_backends;
		else if (rdev->family >= CHIP_RV770)
			value = rdev->config.rv770.max_backends;
		else if (rdev->family >= CHIP_R600)
			value = rdev->config.r600.max_backends;
		else {
			return -EINVAL;
		}
		break;
	case RADEON_INFO_NUM_TILE_PIPES:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.max_tile_pipes;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.max_tile_pipes;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.max_tile_pipes;
		else if (rdev->family >= CHIP_RV770)
			value = rdev->config.rv770.max_tile_pipes;
		else if (rdev->family >= CHIP_R600)
			value = rdev->config.r600.max_tile_pipes;
		else {
			return -EINVAL;
		}
		break;
	case RADEON_INFO_FUSION_GART_WORKING:
		value = 1;
		break;
	case RADEON_INFO_BACKEND_MAP:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.backend_map;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.backend_map;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.backend_map;
		else if (rdev->family >= CHIP_RV770)
			value = rdev->config.rv770.backend_map;
		else if (rdev->family >= CHIP_R600)
			value = rdev->config.r600.backend_map;
		else {
			return -EINVAL;
		}
		break;
	case RADEON_INFO_VA_START:
		/* this is where we report if vm is supported or not */
		if (rdev->family < CHIP_CAYMAN)
			return -EINVAL;
		value = RADEON_VA_RESERVED_SIZE;
		break;
	case RADEON_INFO_IB_VM_MAX_SIZE:
		/* this is where we report if vm is supported or not */
		if (rdev->family < CHIP_CAYMAN)
			return -EINVAL;
		value = RADEON_IB_VM_MAX_SIZE;
		break;
	case RADEON_INFO_MAX_PIPES:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.max_cu_per_sh;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.max_pipes_per_simd;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.max_pipes;
		else if (rdev->family >= CHIP_RV770)
			value = rdev->config.rv770.max_pipes;
		else if (rdev->family >= CHIP_R600)
			value = rdev->config.r600.max_pipes;
		else {
			return -EINVAL;
		}
		break;
	case RADEON_INFO_MAX_SE:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.max_shader_engines;
		else if (rdev->family >= CHIP_CAYMAN)
			value = rdev->config.cayman.max_shader_engines;
		else if (rdev->family >= CHIP_CEDAR)
			value = rdev->config.evergreen.num_ses;
		else
			value = 1;
		break;
	case RADEON_INFO_MAX_SH_PER_SE:
		if (rdev->family >= CHIP_TAHITI)
			value = rdev->config.si.max_sh_per_se;
		else
			return -EINVAL;
		break;
	case RADEON_INFO_SI_CP_DMA_COMPUTE:
		value = 1;
		break;
	case RADEON_INFO_SI_BACKEND_ENABLED_MASK:
		if (rdev->family >= CHIP_TAHITI) {
			value = rdev->config.si.backend_enable_mask;
		} else {
			DRM_DEBUG_KMS("BACKEND_ENABLED_MASK is si+ only!\n");
		}
		break;
	default:
		DRM_DEBUG_KMS("Invalid request %d\n", info->request);
		return -EINVAL;
	}
	if (DRM_COPY_TO_USER(value_ptr, &value, sizeof(uint32_t))) {
		DRM_ERROR("copy_to_user %s:%u\n", __func__, __LINE__);
		return -EFAULT;
	}
	return 0;
}


/*
 * Outdated mess for old drm with Xorg being in charge (void function now).
 */
/**
 * radeon_driver_firstopen_kms - drm callback for first open
 *
 * @@dev: drm dev pointer
 *
 * Nothing to be done for KMS (all asics).
 * Returns 0 on success.
 */
int radeon_driver_firstopen_kms(struct drm_device *dev)
{
	return 0;
}

/**
 * radeon_driver_firstopen_kms - drm callback for last close
 *
 * @@dev: drm dev pointer
 *
 * Switch vga switcheroo state after last close (all asics).
 */
void radeon_driver_lastclose_kms(struct drm_device *dev)
{
	struct radeon_device *rdev = dev->dev_private;
	struct drm_fb_helper *fb_helper = (void *)rdev->mode_info.rfbdev;

#ifdef __sparc64__
	fbwscons_setcolormap(&rdev->sf, radeondrm_setcolor);
#endif
	if (rdev->mode_info.mode_config_initialized)
		drm_fb_helper_restore_fbdev_mode_unlocked(fb_helper);
#ifdef notyet
	vga_switcheroo_process_delayed_switch();
#endif
}

/**
 * radeon_driver_open_kms - drm callback for open
 *
 * @@dev: drm dev pointer
 * @@file_priv: drm file
 *
 * On device open, init vm on cayman+ (all asics).
 * Returns 0 on success, error on failure.
 */
int radeon_driver_open_kms(struct drm_device *dev, struct drm_file *file_priv)
{
	struct radeon_device *rdev = dev->dev_private;

	file_priv->driver_priv = NULL;

	/* new gpu have virtual address space support */
	if (rdev->family >= CHIP_CAYMAN) {
		struct radeon_fpriv *fpriv;
		struct radeon_bo_va *bo_va;
		int r;

		fpriv = kzalloc(sizeof(*fpriv), GFP_KERNEL);
		if (unlikely(!fpriv)) {
			return -ENOMEM;
		}

		radeon_vm_init(rdev, &fpriv->vm);

		if (rdev->accel_working) {
			r = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);
			if (r) {
				radeon_vm_fini(rdev, &fpriv->vm);
				kfree(fpriv);
				return r;
			}

			/* map the ib pool buffer read only into
			 * virtual address space */
			bo_va = radeon_vm_bo_add(rdev, &fpriv->vm,
						 rdev->ring_tmp_bo.bo);
			r = radeon_vm_bo_set_addr(rdev, bo_va, RADEON_VA_IB_OFFSET,
						  RADEON_VM_PAGE_READABLE |
						  RADEON_VM_PAGE_SNOOPED);

			radeon_bo_unreserve(rdev->ring_tmp_bo.bo);
			if (r) {
				radeon_vm_fini(rdev, &fpriv->vm);
				kfree(fpriv);
				return r;
			}
		}
		file_priv->driver_priv = fpriv;
	}
	return 0;
}

/**
 * radeon_driver_postclose_kms - drm callback for post close
 *
 * @@dev: drm dev pointer
 * @@file_priv: drm file
 *
 * On device post close, tear down vm on cayman+ (all asics).
 */
void radeon_driver_postclose_kms(struct drm_device *dev,
				 struct drm_file *file_priv)
{
	struct radeon_device *rdev = dev->dev_private;

	/* new gpu have virtual address space support */
	if (rdev->family >= CHIP_CAYMAN && file_priv->driver_priv) {
		struct radeon_fpriv *fpriv = file_priv->driver_priv;
		struct radeon_bo_va *bo_va;
		int r;

		if (rdev->accel_working) {
			r = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);
			if (!r) {
				bo_va = radeon_vm_bo_find(&fpriv->vm,
							  rdev->ring_tmp_bo.bo);
				if (bo_va)
					radeon_vm_bo_rmv(rdev, bo_va);
				radeon_bo_unreserve(rdev->ring_tmp_bo.bo);
			}
		}

		radeon_vm_fini(rdev, &fpriv->vm);
		kfree(fpriv);
		file_priv->driver_priv = NULL;
	}
}

/**
 * radeon_driver_preclose_kms - drm callback for pre close
 *
 * @@dev: drm dev pointer
 * @@file_priv: drm file
 *
 * On device pre close, tear down hyperz and cmask filps on r1xx-r5xx
 * (all asics).
 */
void radeon_driver_preclose_kms(struct drm_device *dev,
				struct drm_file *file_priv)
{
	struct radeon_device *rdev = dev->dev_private;
	if (rdev->hyperz_filp == file_priv)
		rdev->hyperz_filp = NULL;
	if (rdev->cmask_filp == file_priv)
		rdev->cmask_filp = NULL;
}

/*
 * VBlank related functions.
 */
/**
 * radeon_get_vblank_counter_kms - get frame count
 *
 * @@dev: drm dev pointer
 * @@crtc: crtc to get the frame count from
 *
 * Gets the frame count on the requested crtc (all asics).
 * Returns frame count on success, -EINVAL on failure.
 */
u32 radeon_get_vblank_counter_kms(struct drm_device *dev, unsigned int crtc)
{
	struct radeon_device *rdev = dev->dev_private;

	if (crtc < 0 || crtc >= rdev->num_crtc) {
		DRM_ERROR("Invalid crtc %d\n", crtc);
		return -EINVAL;
	}

	return radeon_get_vblank_counter(rdev, crtc);
}

/**
 * radeon_enable_vblank_kms - enable vblank interrupt
 *
 * @@dev: drm dev pointer
 * @@crtc: crtc to enable vblank interrupt for
 *
 * Enable the interrupt on the requested crtc (all asics).
 * Returns 0 on success, -EINVAL on failure.
 */
int radeon_enable_vblank_kms(struct drm_device *dev, unsigned int crtc)
{
	struct radeon_device *rdev = dev->dev_private;
	unsigned long irqflags;
	int r;

	if (crtc < 0 || crtc >= rdev->num_crtc) {
		DRM_ERROR("Invalid crtc %d\n", crtc);
		return -EINVAL;
	}

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	rdev->irq.crtc_vblank_int[crtc] = true;
	r = radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
	return r;
}

/**
 * radeon_disable_vblank_kms - disable vblank interrupt
 *
 * @@dev: drm dev pointer
 * @@crtc: crtc to disable vblank interrupt for
 *
 * Disable the interrupt on the requested crtc (all asics).
 */
void radeon_disable_vblank_kms(struct drm_device *dev, unsigned int crtc)
{
	struct radeon_device *rdev = dev->dev_private;
	unsigned long irqflags;

	if (crtc < 0 || crtc >= rdev->num_crtc) {
		DRM_ERROR("Invalid crtc %d\n", crtc);
		return;
	}

	spin_lock_irqsave(&rdev->irq.lock, irqflags);
	rdev->irq.crtc_vblank_int[crtc] = false;
	radeon_irq_set(rdev);
	spin_unlock_irqrestore(&rdev->irq.lock, irqflags);
}

/**
 * radeon_get_vblank_timestamp_kms - get vblank timestamp
 *
 * @@dev: drm dev pointer
 * @@crtc: crtc to get the timestamp for
 * @@max_error: max error
 * @@vblank_time: time value
 * @@flags: flags passed to the driver
 *
 * Gets the timestamp on the requested crtc based on the
 * scanout position.  (all asics).
 * Returns postive status flags on success, negative error on failure.
 */
int radeon_get_vblank_timestamp_kms(struct drm_device *dev, unsigned int crtc,
				    int *max_error,
				    struct timeval *vblank_time,
				    unsigned flags)
{
	struct drm_crtc *drmcrtc;
	struct radeon_device *rdev = dev->dev_private;

	if (crtc < 0 || crtc >= dev->num_crtcs) {
		DRM_ERROR("Invalid crtc %d\n", crtc);
		return -EINVAL;
	}

	/* Get associated drm_crtc: */
	drmcrtc = &rdev->mode_info.crtcs[crtc]->base;
	if (!drmcrtc)
		return -EINVAL;

	/* Helper routine in DRM core does all the work: */
	return drm_calc_vbltimestamp_from_scanoutpos(dev, crtc, max_error,
						     vblank_time, flags,
						     &drmcrtc->hwmode);
}

/*
 * IOCTL.
 */
int radeon_dma_ioctl_kms(struct drm_device *dev, struct drm_dma *d,
			 struct drm_file *file_priv)
{
	/* Not valid in KMS. */
	return -EINVAL;
}

#define KMS_INVALID_IOCTL(name)						\
int name(struct drm_device *dev, void *data, struct drm_file *file_priv)\
{									\
	DRM_ERROR("invalid ioctl with kms %s\n", __func__);		\
	return -EINVAL;							\
}

/*
 * All these ioctls are invalid in kms world.
 */
KMS_INVALID_IOCTL(radeon_cp_init_kms)
KMS_INVALID_IOCTL(radeon_cp_start_kms)
KMS_INVALID_IOCTL(radeon_cp_stop_kms)
KMS_INVALID_IOCTL(radeon_cp_reset_kms)
KMS_INVALID_IOCTL(radeon_cp_idle_kms)
KMS_INVALID_IOCTL(radeon_cp_resume_kms)
KMS_INVALID_IOCTL(radeon_engine_reset_kms)
KMS_INVALID_IOCTL(radeon_fullscreen_kms)
KMS_INVALID_IOCTL(radeon_cp_swap_kms)
KMS_INVALID_IOCTL(radeon_cp_clear_kms)
KMS_INVALID_IOCTL(radeon_cp_vertex_kms)
KMS_INVALID_IOCTL(radeon_cp_indices_kms)
KMS_INVALID_IOCTL(radeon_cp_texture_kms)
KMS_INVALID_IOCTL(radeon_cp_stipple_kms)
KMS_INVALID_IOCTL(radeon_cp_indirect_kms)
KMS_INVALID_IOCTL(radeon_cp_vertex2_kms)
KMS_INVALID_IOCTL(radeon_cp_cmdbuf_kms)
KMS_INVALID_IOCTL(radeon_cp_getparam_kms)
KMS_INVALID_IOCTL(radeon_cp_flip_kms)
KMS_INVALID_IOCTL(radeon_mem_alloc_kms)
KMS_INVALID_IOCTL(radeon_mem_free_kms)
KMS_INVALID_IOCTL(radeon_mem_init_heap_kms)
KMS_INVALID_IOCTL(radeon_irq_emit_kms)
KMS_INVALID_IOCTL(radeon_irq_wait_kms)
KMS_INVALID_IOCTL(radeon_cp_setparam_kms)
KMS_INVALID_IOCTL(radeon_surface_alloc_kms)
KMS_INVALID_IOCTL(radeon_surface_free_kms)


struct drm_ioctl_desc radeon_ioctls_kms[] = {
	DRM_IOCTL_DEF_DRV(RADEON_CP_INIT, radeon_cp_init_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_CP_START, radeon_cp_start_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_CP_STOP, radeon_cp_stop_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_CP_RESET, radeon_cp_reset_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_CP_IDLE, radeon_cp_idle_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_CP_RESUME, radeon_cp_resume_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_RESET, radeon_engine_reset_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_FULLSCREEN, radeon_fullscreen_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_SWAP, radeon_cp_swap_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_CLEAR, radeon_cp_clear_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_VERTEX, radeon_cp_vertex_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_INDICES, radeon_cp_indices_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_TEXTURE, radeon_cp_texture_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_STIPPLE, radeon_cp_stipple_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_INDIRECT, radeon_cp_indirect_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_VERTEX2, radeon_cp_vertex2_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_CMDBUF, radeon_cp_cmdbuf_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_GETPARAM, radeon_cp_getparam_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_FLIP, radeon_cp_flip_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_ALLOC, radeon_mem_alloc_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_FREE, radeon_mem_free_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_INIT_HEAP, radeon_mem_init_heap_kms, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF_DRV(RADEON_IRQ_EMIT, radeon_irq_emit_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_IRQ_WAIT, radeon_irq_wait_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_SETPARAM, radeon_cp_setparam_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_SURF_ALLOC, radeon_surface_alloc_kms, DRM_AUTH),
	DRM_IOCTL_DEF_DRV(RADEON_SURF_FREE, radeon_surface_free_kms, DRM_AUTH),
	/* KMS */
	DRM_IOCTL_DEF_DRV(RADEON_GEM_INFO, radeon_gem_info_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_CREATE, radeon_gem_create_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_MMAP, radeon_gem_mmap_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_SET_DOMAIN, radeon_gem_set_domain_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_PREAD, radeon_gem_pread_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_PWRITE, radeon_gem_pwrite_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_WAIT_IDLE, radeon_gem_wait_idle_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_CS, radeon_cs_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_INFO, radeon_info_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_SET_TILING, radeon_gem_set_tiling_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_GET_TILING, radeon_gem_get_tiling_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_BUSY, radeon_gem_busy_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_VA, radeon_gem_va_ioctl, DRM_AUTH|DRM_UNLOCKED|DRM_RENDER_ALLOW),
};
int radeon_max_kms_ioctl = DRM_ARRAY_SIZE(radeon_ioctls_kms);
@


1.51
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.50 2017/06/19 11:03:30 fcambus Exp $	*/
d322 1
d350 1
d445 14
@


1.50
log
@Add a handler for the WSDISPLAYIO_GINFO ioctl in radeondrm, allowing
to retrieve basic information about a framebuffer display.

OK visa@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.49 2017/01/08 12:11:54 fcambus Exp $	*/
d77 5
a81 5
u32	radeon_get_vblank_counter_kms(struct drm_device *, int);
int	radeon_enable_vblank_kms(struct drm_device *, int);
void	radeon_disable_vblank_kms(struct drm_device *, int);
int	radeon_get_vblank_timestamp_kms(struct drm_device *, int, int *,
	    struct timeval *, unsigned);
d149 1
d212 1
a212 1
static struct drm_driver_info kms_driver = {
d439 1
a439 3
	drm_modeset_lock_all(rdev->ddev);
	drm_fb_helper_restore_fbdev_mode((void *)rdev->mode_info.rfbdev);
	drm_modeset_unlock_all(rdev->ddev);
d638 1
d730 1
d742 1
a742 3
	drm_modeset_lock_all(rdev->ddev);
	drm_fb_helper_restore_fbdev_mode((void *)rdev->mode_info.rfbdev);
	drm_modeset_unlock_all(rdev->ddev);
d1119 2
a1120 5
	if (rdev->mode_info.mode_config_initialized) {
		drm_modeset_lock_all(dev);
		drm_fb_helper_restore_fbdev_mode(fb_helper);
		drm_modeset_unlock_all(dev);
	}
d1249 1
a1249 1
u32 radeon_get_vblank_counter_kms(struct drm_device *dev, int crtc)
d1270 1
a1270 1
int radeon_enable_vblank_kms(struct drm_device *dev, int crtc)
d1296 1
a1296 1
void radeon_disable_vblank_kms(struct drm_device *dev, int crtc)
d1325 1
a1325 1
int radeon_get_vblank_timestamp_kms(struct drm_device *dev, int crtc,
d1340 2
d1346 1
a1346 1
						     drmcrtc, &drmcrtc->hwmode);
@


1.49
log
@Display color depth alongside resolution when attaching inteldrm and
radeondrm, using the same scheme as efifb(4).

OK mpi@@, visa@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.48 2016/04/08 08:27:53 kettenis Exp $	*/
d357 3
d363 7
@


1.48
log
@Get rid of some infrastrcuture that is now obsolete and synchronize some of
the data structures in drmP.h with Linux 3.14.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.47 2016/02/03 07:42:14 kettenis Exp $	*/
d772 2
a773 1
	printf("%s: %dx%d\n", rdev->dev.dv_xname, ri->ri_width, ri->ri_height);
@


1.47
log
@Prevent efifb(4) from attaching if we're the console.

Unfortunately, making this decision in radeondrm_attachhook() is too late
because at that point efifb(4) would have already been attached.  This means
that if we decide to bail in radeondrm_attachhook() we may end up without
a glass console.  That may happen for example if the firmware package
has not been installed.  I'm still looking for a solution for that problem.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.46 2016/01/06 19:56:08 kettenis Exp $	*/
d212 4
a215 3
	.flags =
	    DRIVER_AGP | DRIVER_PCI_DMA | DRIVER_SG |
	    DRIVER_HAVE_IRQ | DRIVER_HAVE_DMA | DRIVER_GEM | DRIVER_MODESET,
@


1.46
log
@Add DRM_RENDER_ALLOW flag to the appropriate ioctls such that pledge "drm"
allows them.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.45 2015/12/11 16:07:02 mpi Exp $	*/
d44 8
d512 6
@


1.45
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.44 2015/11/22 15:35:49 kettenis Exp $	*/
d1403 4
a1406 4
	DRM_IOCTL_DEF_DRV(RADEON_GEM_INFO, radeon_gem_info_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_CREATE, radeon_gem_create_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_MMAP, radeon_gem_mmap_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_SET_DOMAIN, radeon_gem_set_domain_ioctl, DRM_AUTH|DRM_UNLOCKED),
d1409 7
a1415 7
	DRM_IOCTL_DEF_DRV(RADEON_GEM_WAIT_IDLE, radeon_gem_wait_idle_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_CS, radeon_cs_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_INFO, radeon_info_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_SET_TILING, radeon_gem_set_tiling_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_GET_TILING, radeon_gem_get_tiling_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_BUSY, radeon_gem_busy_ioctl, DRM_AUTH|DRM_UNLOCKED),
	DRM_IOCTL_DEF_DRV(RADEON_GEM_VA, radeon_gem_va_ioctl, DRM_AUTH|DRM_UNLOCKED),
@


1.44
log
@Remove drm_gem_object_alloc() and associated infrastructure.  It's unused and
has been removed upstream as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.43 2015/11/16 11:24:58 kettenis Exp $	*/
d109 1
a109 1
void	radeondrm_attachhook(void *);
d649 1
a649 4
	if (rootvp == NULL)
		mountroothook_establish(radeondrm_attachhook, rdev);
	else
		radeondrm_attachhook(rdev);
d668 1
a668 1
radeondrm_attachhook(void *xsc)
d670 1
a670 1
	struct radeon_device	*rdev = xsc;
@


1.43
log
@Don't attempt to restore the framebuffer mode in radeon_driver_lastclose_kms()
if the mode config stuff has not been initialized yet.  Fixes a panic that
happens when radeondrm(4) detaches because the hardware couldn't be initialized
properly.

Tested by Lubos Boucek.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.42 2015/09/27 16:13:23 kettenis Exp $	*/
a56 1
int	radeon_gem_object_init(struct drm_gem_object *);
a232 1
	.gem_init_object = radeon_gem_object_init,
@


1.42
log
@Use drm_fb_helper_restore_fbdev_mode() to restore the wscons framebuffer
whenever we need to.  Apologies for the ugly cast.

Should fix the locking warnings reported by tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.41 2015/09/26 19:52:16 kettenis Exp $	*/
d1094 1
d1099 5
a1103 3
	drm_modeset_lock_all(dev);
	drm_fb_helper_restore_fbdev_mode((void *)rdev->mode_info.rfbdev);
	drm_modeset_unlock_all(dev);
@


1.41
log
@Update drm_irq.c to the version from Linux 3.14.52.
Disable the DRM_IOCTL_IRQ_BUSID and DRM_IOCTL_CONTROL ioctls.
These are legacy ioctls for DRI1 support, which we no longer support on
OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.40 2015/09/23 23:12:12 kettenis Exp $	*/
d422 1
a422 1
	drm_fb_helper_restore();
d722 1
a722 1
	drm_fb_helper_restore();
a1092 1
#ifdef __sparc64__
d1095 1
d1099 1
a1099 1
	drm_fb_helper_restore();
@


1.40
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.39 2015/04/18 11:05:32 jsg Exp $	*/
d206 2
a207 2
	    DRIVER_AGP | DRIVER_MTRR | DRIVER_PCI_DMA | DRIVER_SG |
	    DRIVER_IRQ | DRIVER_DMA | DRIVER_GEM | DRIVER_MODESET,
@


1.39
log
@add and use module param macros
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.38 2015/04/17 00:54:42 jsg Exp $	*/
a232 1
	.irq_handler = radeon_driver_irq_handler_kms,
d421 1
d423 1
d721 1
d723 1
d1098 1
d1100 1
d1324 1
a1324 1
						     drmcrtc);
@


1.38
log
@Make drm ioctls table driven.  Further reduces the diff to linux.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.37 2015/04/06 12:25:10 jsg Exp $	*/
a124 1
/* Disable AGP writeback for scratch registers */
d126 19
d146 2
a147 2
/* Disable/Enable modesetting */
int radeon_modeset = 1;
d149 2
a150 2
/* Disable/Enable dynamic clocks */
int radeon_dynclks = -1;
d152 2
a153 2
/* Enable ATOMBIOS modesetting for R4xx */
int radeon_r4xx_atom = 0;
d155 2
a156 2
/* AGP Mode (-1 == PCI) */
int radeon_agpmode = 0;
d158 2
a159 2
/* Restrict VRAM for testing */
int radeon_vram_limit = 0;
d161 2
a162 2
/* Size of PCIE/IGP gart to setup in megabytes (32, 64, etc) */
int radeon_gart_size = 512; /* default gart size */
d164 2
a165 2
/* Run benchmark */
int radeon_benchmarking = 0;
d167 2
a168 2
/* Run tests */
int radeon_testing = 0;
d170 2
a171 2
/* Force connector table */
int radeon_connector_table = 0;
d173 2
a174 2
/* TV enable (0 = disable) */
int radeon_tv = 1;
d176 2
a177 2
/* Audio enable (1 = enable) */
int radeon_audio = 0;
d179 2
a180 2
/* Display Priority (0 = auto, 1 = normal, 2 = high) */
int radeon_disp_priority = 0;
d182 2
a183 2
/* hw i2c engine enable (0 = disable) */
int radeon_hw_i2c = 0;
d185 2
a186 2
/* PCIE Gen2 mode (-1 = auto, 0 = disable, 1 = enable) */
int radeon_pcie_gen2 = -1;
d188 2
a189 2
/* MSI support (1 = enable, 0 = disable, -1 = auto) */
int radeon_msi = -1;
d191 2
a192 2
/* GPU lockup timeout in ms (defaul 10000 = 10 seconds, 0 = disable) */
int radeon_lockup_timeout = 10000;
@


1.37
log
@move some inline linux compat into the dedicated files
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.36 2015/04/06 07:38:49 jsg Exp $	*/
a75 2
int	radeondrm_ioctl_kms(struct drm_device *, u_long, caddr_t, struct drm_file *);
int	radeon_ioctl_kms(struct drm_device *, u_long, caddr_t, struct drm_file *);
d113 3
a190 1
	.ioctl = radeondrm_ioctl_kms,
d216 1
d569 2
a1351 6
int
radeondrm_ioctl_kms(struct drm_device *dev, u_long cmd, caddr_t data,
    struct drm_file *file_priv)
{
	return -(radeon_ioctl_kms(dev, cmd, data, file_priv));
}
d1353 44
a1396 96
int
radeon_ioctl_kms(struct drm_device *dev, u_long cmd, caddr_t data,
    struct drm_file *file_priv)
{
	if (file_priv->authenticated == 1) {
		switch (cmd) {
		case DRM_IOCTL_RADEON_CP_IDLE:
			return (radeon_cp_idle_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CP_RESUME:
			return (radeon_cp_resume_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_RESET:
			return (radeon_engine_reset_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_FULLSCREEN:
			return (radeon_fullscreen_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_SWAP:
			return (radeon_cp_swap_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CLEAR:
			return (radeon_cp_clear_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_VERTEX:
			return (radeon_cp_vertex_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_INDICES:
			return (radeon_cp_indices_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_TEXTURE:
			return (radeon_cp_texture_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_STIPPLE:
			return (radeon_cp_stipple_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_VERTEX2:
			return (radeon_cp_vertex2_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CMDBUF:
			return (radeon_cp_cmdbuf_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GETPARAM:
			return (radeon_cp_getparam_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_FLIP:
			return (radeon_cp_flip_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_ALLOC:
			return (radeon_mem_alloc_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_FREE:
			return (radeon_mem_free_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_IRQ_EMIT:
			return (radeon_irq_emit_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_IRQ_WAIT:
			return (radeon_irq_wait_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_SETPARAM:
			return (radeon_cp_setparam_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_SURF_ALLOC:
			return (radeon_surface_alloc_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_SURF_FREE:
			return (radeon_surface_free_kms(dev, data, file_priv));
		/* KMS */
		case DRM_IOCTL_RADEON_GEM_INFO:
			return (radeon_gem_info_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_CREATE:
			return (radeon_gem_create_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_MMAP:
			return (radeon_gem_mmap_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_SET_DOMAIN:
			return (radeon_gem_set_domain_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_PREAD:
			return (radeon_gem_pread_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_PWRITE:
			return (radeon_gem_pwrite_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_WAIT_IDLE:
			return (radeon_gem_wait_idle_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CS:
			return (radeon_cs_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_INFO:
			return (radeon_info_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_SET_TILING:
			return (radeon_gem_set_tiling_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_GET_TILING:
			return (radeon_gem_get_tiling_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_BUSY:
			return (radeon_gem_busy_ioctl(dev, data, file_priv));
		case DRM_IOCTL_RADEON_GEM_VA:
			return (radeon_gem_va_ioctl(dev, data, file_priv));
		}
	}

	if (file_priv->master == 1) {
		switch (cmd) {
		case DRM_IOCTL_RADEON_CP_INIT:
			return (radeon_cp_init_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CP_START:
			return (radeon_cp_start_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CP_STOP:
			return (radeon_cp_stop_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_CP_RESET:
			return (radeon_cp_reset_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_INDIRECT:
			return (radeon_cp_indirect_kms(dev, data, file_priv));
		case DRM_IOCTL_RADEON_INIT_HEAP:
			return (radeon_mem_init_heap_kms(dev, data, file_priv));
		}
	}
	return -EINVAL;
}
@


1.36
log
@add back some more static use to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.35 2015/02/11 07:01:37 jsg Exp $	*/
a34 8

#ifndef PCI_MEM_START
#define PCI_MEM_START	0
#endif

#ifndef PCI_MEM_END
#define PCI_MEM_END	0xffffffff
#endif
@


1.35
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.34 2015/02/10 10:50:49 jsg Exp $	*/
a82 2
void	radeon_set_filp_rights(struct drm_device *, struct drm_file **,
	    struct drm_file *, uint32_t *);
d790 1
a790 2
void
radeon_set_filp_rights(struct drm_device *dev,
@


1.34
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.33 2015/02/10 01:39:32 jsg Exp $	*/
d674 1
a674 1
		printf(": Fatal error during GPU init\n");
d686 1
a686 1
		printf("Fatal error during modeset init\n");
@


1.33
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.32 2015/01/27 03:17:36 dlg Exp $	*/
d1238 1
d1246 1
a1246 1
	mtx_enter(&rdev->irq.lock);
d1249 1
a1249 1
	mtx_leave(&rdev->irq.lock);
d1264 1
d1271 1
a1271 1
	mtx_enter(&rdev->irq.lock);
d1274 1
a1274 1
	mtx_leave(&rdev->irq.lock);
@


1.32
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.31 2014/12/20 16:34:27 krw Exp $	*/
d798 1
a798 1
	DRM_LOCK();
d809 1
a809 1
	DRM_UNLOCK();
@


1.31
log
@Replace switch workq with taskq.

Diff from blambert@@, double ok@@ kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.30 2014/10/25 14:20:09 kettenis Exp $	*/
d305 1
a305 1
void radeondrm_doswitch(void *, void *);
d388 1
a388 1
	radeondrm_doswitch(v, cookie);
d394 1
a394 1
radeondrm_doswitch(void *v, void *dummy)
d701 1
a701 1
	task_set(&rdev->switchtask, radeondrm_doswitch, ri, NULL);
@


1.30
log
@Don't attempt to suspend/resume a partially attached drm(4) driver.
Fixes a crash upon resume with an ATI FireMV 2400 card.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.29 2014/07/06 08:24:54 jsg Exp $	*/
d382 1
d384 1
a384 2
		workq_queue_task(NULL, &rdev->switchwqt, 0,
		    radeondrm_doswitch, v, cookie);
d394 1
a394 1
radeondrm_doswitch(void *v, void *cookie)
d401 1
a401 1
	rasops_show_screen(ri, cookie, 0, NULL, NULL);
d700 2
@


1.29
log
@drm/radeon: avoid segfault on device open when accel is not working.

From Jerome Glisse
16d30071c6cd4b72a950d265b0d7d08fb4220b92 in ubuntu 3.8
24f47acc78b0ab5e2201f859fe1f693ae90c7c83 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.28 2014/06/21 04:37:42 jsg Exp $	*/
d758 3
@


1.28
log
@drm/radeon: memory leak on bo reservation failure. v2

From Quentin Casasnovas
2b9149f17e7135c31c9df1c80ab6d912c4265126 in ubuntu 3.8
74073c9dd29905645feb6dee03c144657a9844cd in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.27 2014/04/07 06:43:11 jsg Exp $	*/
d1114 15
a1128 6
		r = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);
		if (r) {
			radeon_vm_fini(rdev, &fpriv->vm);
			kfree(fpriv);
			return r;
		}
d1130 6
a1135 13
		/* map the ib pool buffer read only into
		 * virtual address space */
		bo_va = radeon_vm_bo_add(rdev, &fpriv->vm,
					 rdev->ring_tmp_bo.bo);
		r = radeon_vm_bo_set_addr(rdev, bo_va, RADEON_VA_IB_OFFSET,
					  RADEON_VM_PAGE_READABLE |
					  RADEON_VM_PAGE_SNOOPED);

		radeon_bo_unreserve(rdev->ring_tmp_bo.bo);
		if (r) {
			radeon_vm_fini(rdev, &fpriv->vm);
			kfree(fpriv);
			return r;
a1136 1

d1161 9
a1169 7
		r = radeon_bo_reserve(rdev->ring_tmp_bo.bo, false);
		if (!r) {
			bo_va = radeon_vm_bo_find(&fpriv->vm,
						  rdev->ring_tmp_bo.bo);
			if (bo_va)
				radeon_vm_bo_rmv(rdev, bo_va);
			radeon_bo_unreserve(rdev->ring_tmp_bo.bo);
@


1.27
log
@reduce the diff to linux for drm pci vid/pid tests
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.26 2014/03/30 02:12:23 jsg Exp $	*/
d1115 3
a1117 1
		if (r)
d1119 1
@


1.26
log
@drm/radeon: fix missing bo reservation

From Christian Koenig
ea0e5ee12a70badcdfee846bfaf5d4338dc285ca in ubuntu 3.8
5e386b574cf7e1593e1296e5b0feea4108ed6ad8 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.25 2014/03/13 12:45:04 kettenis Exp $	*/
d581 1
@


1.25
log
@Block userland from entering drm code (and make sure it is no longer in there)
before we truly start quiescing the device and don't unblock until we've
finished waking the device up.  Fixes issues with suspend/resume on inteldrm(4)
and perhaps radeondrm(4) as well.

i"it is the right place to stall" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.24 2014/02/25 00:03:38 kettenis Exp $	*/
d1113 4
d1124 2
@


1.24
log
@Some broken BIOSen don't assign an address to the ROM BAR.  Fix this up, as we
typically need to be able to map the ROM to get connector information and/or
to POST the card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.23 2014/02/23 09:36:52 kettenis Exp $	*/
d753 1
a753 1
radeondrm_activate_kms(struct device *arg, int act)
d755 2
a756 1
	struct radeon_device *rdev = (struct radeon_device *)arg;
d760 1
d769 1
d773 1
a773 1
	return (0);
@


1.23
log
@Give drm(4) a console locator just like wsdisplay(4) such that we can make
sure /dev/drm0 always matches the primary display.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.22 2014/02/10 01:59:48 jsg Exp $	*/
d36 8
d464 4
d529 25
@


1.22
log
@drm/radeon: expose render backend mask to the userspace

From Marek Olsak
413f46c51b173d8a46135d33fa3adef05f2b1a7e in ubuntu 3.8
439a1cfffe2c1a06e5a6394ccd5d18a8e89b15d3 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.21 2014/02/10 00:47:19 jsg Exp $	*/
d541 2
a542 1
	dev = (struct drm_device *)drm_attach_pci(&kms_driver, pa, is_agp, self);
@


1.21
log
@drm/radeon/si: Add support for CP DMA to CS checker for compute v2

From Tom Stellard
0f5c67667c1914c3f133bc2d43199b6d01bfde28 in ubuntu 3.8
e5b9e7503eb1f4884efa3b321d3cc47806779202 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.20 2014/02/09 11:03:31 jsg Exp $	*/
d988 7
@


1.20
log
@use linux style memory allocations in radeon
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.19 2014/01/23 03:15:09 kettenis Exp $	*/
d985 3
@


1.19
log
@Switch radeondrm(4) to MSI on the cards that support it.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.18 2014/01/20 09:36:46 kettenis Exp $	*/
d1055 1
a1055 1
		fpriv = malloc(sizeof(*fpriv), M_DRM, M_WAITOK | M_ZERO);
d1071 1
a1071 1
			free(fpriv, M_DRM);
d1109 1
a1109 1
		free(fpriv, M_DRM);
@


1.18
log
@Do the resume work from DVACT_WAKEUP.  There is far too much code, and it
is almost certainly doing tsleeps.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.17 2013/12/22 21:03:45 kettenis Exp $	*/
a517 5
	if (pci_intr_map(pa, &rdev->intrh) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, rdev->intrh));
d539 2
d543 14
@


1.17
log
@Try to keep the framebuffer console layout that was set up by the firmware
on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.16 2013/12/22 19:49:23 kettenis Exp $	*/
d715 2
@


1.16
log
@Use the rasops_info struct as the accesscookie for wsdisplay.  Simplifies the
code as it allows us to use some of the rasops_xxx functions directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.15 2013/12/05 13:29:56 kettenis Exp $	*/
d298 3
d402 3
a411 2
void	radeondrm_setcolor(void *, u_int, u_int8_t, u_int8_t, u_int8_t);

d570 1
a570 1
	    bus_space_read_4(rdev->memt,  rdev->rmmio, RADEON_CRTC_OFFSET);
d580 1
d659 1
a660 3
#ifdef __sparc64__
	ri->ri_flg |= RI_BSWAP;
#endif
d664 3
d1010 5
@


1.15
log
@Rename 'struct drm_obj' to 'struct drm_gem_object' to reduce the diffs with
Linux.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.14 2013/11/30 12:58:39 kettenis Exp $	*/
a297 3
int radeondrm_load_font(void *, void *, struct wsdisplay_font *);
int radeondrm_list_font(void *, struct wsdisplay_font *);
int radeondrm_getchar(void *, int, int, struct wsdisplay_charcell *);
d322 3
a324 3
	.getchar = radeondrm_getchar,
	.load_font = radeondrm_load_font,
	.list_font = radeondrm_list_font,
d350 1
a350 4
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;

	return rasops_alloc_screen(ri, cookiep, curxp, curyp, attrp);
d356 1
a356 4
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;

	return rasops_free_screen(ri, cookie);
d363 2
a364 2
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;
d385 2
a386 2
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;
a404 27
int
radeondrm_load_font(void *v, void *cookie, struct wsdisplay_font *font)
{
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;

	return rasops_load_font(ri, cookie, font);
}

int
radeondrm_list_font(void *v, struct wsdisplay_font *font)
{
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;

	return rasops_list_font(ri, font);
}

int
radeondrm_getchar(void *v, int row, int col, struct wsdisplay_charcell *cell)
{
	struct radeon_device *rdev = v;
	struct rasops_info *ri = &rdev->ro;

	return rasops_getchar(ri, row, col, cell);
}

d672 1
a672 1
	aa.accesscookie = rdev;
@


1.14
log
@Restore frame buffer upon last close; makes sure we we have a usable console
after exiting X.

tested by tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.13 2013/11/28 21:45:36 kettenis Exp $	*/
d57 4
a60 4
int	radeon_gem_object_init(struct drm_obj *);
void	radeon_gem_object_free(struct drm_obj *);
int	radeon_gem_object_open(struct drm_obj *, struct drm_file *);
void	radeon_gem_object_close(struct drm_obj *, struct drm_file *);
@


1.13
log
@Re-enable RADEON_INFO_VA_START and RADEON_INFO_IB_VM_MAX_SIZE.

suggested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.12 2013/11/27 20:41:19 kettenis Exp $	*/
d1040 1
@


1.12
log
@Hook up gem_open/close_object methods.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.11 2013/11/17 13:41:26 kettenis Exp $	*/
a961 2
		return -EINVAL;
#ifdef notyet
a965 1
#endif
a967 2
		return -EINVAL;
#ifdef notyet
a971 1
#endif
@


1.11
log
@Distinguish between inteldrm and radeondrm.

ok jsg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.10 2013/10/21 10:36:24 miod Exp $	*/
a219 1
#ifdef notyet
a221 1
#endif
@


1.10
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.9 2013/10/20 20:07:29 miod Exp $	*/
d338 1
a338 1
		*(int *)data = WSDISPLAY_TYPE_KMS;
@


1.9
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.8 2013/10/20 10:43:48 miod Exp $	*/
d300 2
d328 2
d414 18
@


1.8
log
@WSDISPLAYIO_GTYPE ioctl support for KMS drivers. ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.7 2013/10/18 14:35:20 deraadt Exp $	*/
d320 7
a326 9
	radeondrm_wsioctl,
	radeondrm_wsmmap,
	radeondrm_alloc_screen,
	radeondrm_free_screen,
	radeondrm_show_screen,
	NULL,
	NULL,
	radeondrm_getchar,
	radeondrm_burner
@


1.7
log
@the radeon suspend routine looks hairy, and feels like it should run
under DVACT_QUIESCE.  And yes, it works, so let's go with that.
ok mlarkin jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.6 2013/10/18 12:34:52 deraadt Exp $	*/
d334 7
a340 1
	return (-1);
@


1.6
log
@At device attach, mark the device "shutdown", until the mountroot hook
gets to run.  In the suspend case, do nothing if we are shutdown.  This
allows hibernate to run the suspend code before mountroot.  tested by mlarkin
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.5 2013/09/08 11:59:45 jsg Exp $	*/
d715 3
a718 1
		radeon_suspend_kms(rdev->ddev);
@


1.5
log
@switch to using linux style pci match tables
fixes some omissions and flag errors for radeon
and removes the duplicate table for i915
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.4 2013/08/27 07:44:52 jsg Exp $	*/
d595 1
@


1.4
log
@Give RS400/RS480/RS690 another chance.  These were previously disabled
with the old radeondrm code but should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.3 2013/08/16 19:53:53 kettenis Exp $	*/
d34 1
d184 1
a184 1112
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M241P,
	    CHIP_RV380|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X300M24,
	    CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M24GL,
	    CHIP_RV380|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X600_RV380,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V3200,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP320,
	    CHIP_RS100|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP340,
	    CHIP_RS200|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9500PRO, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AE9700PRO, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AF9600TX, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_AGZ1, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AH_9800SE, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AI_9800, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AJ_9800, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_AKX2, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9600PRO, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9600LE, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9600XT, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9550, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_ATT2, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9650, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_AVT2, CHIP_RV350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP_RS250,
	    CHIP_RS200|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R200_BB, CHIP_R200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R200_BC, CHIP_R200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP320M,
	    CHIP_RS100|RADEON_IS_IGP|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_M6,
	    CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_MIGP_RS250,
	    CHIP_RS200|RADEON_IS_IGP|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV250, CHIP_RV250},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IG9000, CHIP_RV250},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_JHX800,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800PRO,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800SE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XT,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_X3256,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_M18,
	    CHIP_R420|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_JOX800SE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XTPE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AIW_X800VE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850XT,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850SE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850PRO,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850XTPE,
	    CHIP_R420|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M7LW,
	    CHIP_RV200|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M7,
	    CHIP_RV200|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M6LY,
	    CHIP_RV100|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M6LZ,
	    CHIP_RV100|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M9LD,
	    CHIP_RV250|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M9Lf,
	    CHIP_RV250},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M9Lg,
	    CHIP_RV250|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R300, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON9500_PRO, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON9600TX, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_X1, CHIP_R300},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R350, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON9800, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9800XT, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_X2, CHIP_R350},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV350,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV350NQ,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV350NR,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV350NS,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV350_WS,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_9550,
	    CHIP_RV350|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_AIW,
	    CHIP_R100|RADEON_SINGLE_CRTC},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QE,
	    CHIP_R100|RADEON_SINGLE_CRTC},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QF,
	    CHIP_R100|RADEON_SINGLE_CRTC},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QG,
	    CHIP_R100|RADEON_SINGLE_CRTC},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QH, CHIP_R200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R200_QL, CHIP_R200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_R200_QM, CHIP_R200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV200_QW, CHIP_RV200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV200_QX, CHIP_RV200},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QY, CHIP_RV100},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_QZ, CHIP_RV100},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_ES1000_1, CHIP_RV100},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M300_M22,
	    CHIP_RV380|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X600_M24C,
	    CHIP_RV380|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M44,
	    CHIP_RV380|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800PRORV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XT_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800SE_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XTPRV430,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XL_RV430,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800SE_RV430,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800_RV430,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V7100_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5100_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_UR_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_UT_RV423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5000_M26,
	    CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5000_M26b,
	    CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700XL_M26,
	    CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700_M26_1,
	    CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700_M26_2,
	    CHIP_RV410|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X550XTX,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP9100_IGP,
	    CHIP_RS300|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_IGP9100,
	    CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS480,
	    CHIP_RS480|RADEON_IS_IGP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS480_B,
	    CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS482,
	    CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS482_B,
	    CHIP_RS480|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RV280_PRO, CHIP_RV280},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RV280, CHIP_RV280},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RV280_B, CHIP_RV280},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RV280_SE_S, CHIP_RV280},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2200, CHIP_RV280},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_ES1000, CHIP_RV100},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS400,
	    CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS400_B,
	    CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RC410,
	    CHIP_RS400|RADEON_IS_IGP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RC410_B,
	    CHIP_RS400|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X300,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X600_RV370,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X550,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_RV370,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2200_5B65,
	    CHIP_RV380|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RV280_M,
	    CHIP_RV280|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_M9PLUS,
	    CHIP_RV280|RADEON_IS_MOBILITY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XT_M28,
	    CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5100_M28,
	    CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X800_M28,
	    CHIP_R423|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850_R480,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850XTPER480,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850SE_R480,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800_GTO,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_R480,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X850XT_R480,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X800XT_R423,
	    CHIP_R423|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5000_R410,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700XT_R410,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700PRO_R410,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700SE_R410,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700_PCIE,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X700SE_PCIE,
	    CHIP_RV410|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800A,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800XT,
	    CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1800,
	    CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M_V7200,
	    CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M_V7200,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5300,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_M_V7100,
	    CHIP_R520|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800B,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800C,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800D,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800E,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1800F,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V7300,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V7350,
	    CHIP_R520|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV505_1,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_X1550,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_M54_GL,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1400,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550_X1300,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550_64,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_M52,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1300_4A,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1300_4B,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1300_4C,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_4D,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_4E,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV505_2,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV505_3,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V3300,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V3350,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_5E,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550_64_2,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300X1550,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_81,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300PRO,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1450,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X2300,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X2300_2,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1350,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1350_2,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1450,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_8F,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550_2,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1350_3,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2250,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1550_64_3,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_C0,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1650,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_PRO,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_C3,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5200,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_M,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1650_PRO,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1650_PRO2,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1600_CD,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1300_XT,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V3400,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV530_M56,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1700,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1700XT,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5200_1,
	    CHIP_RV530|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1700,
	    CHIP_RV530|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X2300HD,
	    CHIP_RV515|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X2300HD,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X2300HD_1,
	    CHIP_RV515|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1950_40,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_43,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1950_44,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_45,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_46,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_47,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_48,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_49,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_4A,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_4B,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_4C,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_4D,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_STREAM_PROCESSOR,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1900_4F,
	    CHIP_R580|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1950_PRO,
	    CHIP_RV570|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV560,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV560_1,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_X1900,
	    CHIP_R580|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV560_2,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1950GT,
	    CHIP_RV570|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV570,
	    CHIP_RV570|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV570_2,
	    CHIP_RV570|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V7400,
	    CHIP_RV570|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV560_3,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RX1650_XT,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1650_1,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RV560_4,
	    CHIP_RV560|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_9000IGP,
	    CHIP_RS300|RADEON_IS_IGP|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_RS350IGP,
	    CHIP_RS300|RADEON_IS_IGP|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1250_1,
	    CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1250_2,
	    CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_X1250IGP,
	    CHIP_RS690|RADEON_IS_IGP|RADEON_NEW_MEMMAP|RADEON_IS_IGPGART},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V4000,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2260,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_E2400,
	    CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2350,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400_PRO,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400PROAGP,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400_XT,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400_M72,
	    CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400_XT_M,
	    CHIP_RV610|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2400PROPCI,
	    CHIP_RV610|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2450,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2260_1,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREMV_2260_2,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V3700,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3400_M82,
	    CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3430,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3430_M,
	    CHIP_RV620|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3450,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3450_AGP,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3450_PCI,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3470,
	    CHIP_RV620|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5600,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V3600,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600_PRO,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600_XT,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600_M76,
	    CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600_XT_M,
	    CHIP_RV630|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600XTAGP,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD2600PROAGP,
	    CHIP_RV630|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5700_M,
	    CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V5725_M,
	    CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3600,
	    CHIP_RV635|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3650_AGP,
	    CHIP_RV635|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3650_M,
	    CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3650,
	    CHIP_RV635|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3670_M,
	    CHIP_RV635|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREGL_V7700,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIRESTREAM_9170,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3690,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3850,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3850_AGP,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3850_M,
	    CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3850_X2_M,
	    CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3870,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3870_X2,
	    CHIP_RV670|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3870_M,
	    CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3870_X2_M,
	    CHIP_RV670|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3000,
	    CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3200_1,
	    CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3200_2,
	    CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD3300,
	    CHIP_RS780|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_RG220,
	    CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4350,
	    CHIP_RV710|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4300_M,
	    CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4330_M,
	    CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4500_M,
	    CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4500_M_2,
	    CHIP_RV710|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4550,
	    CHIP_RV710|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_E4600,
	    CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V3750,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V5700,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V7750,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4600,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4650,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4650_M,
	    CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4670,
	    CHIP_RV730|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4670_M,
	    CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4670_M_2,
	    CHIP_RV730|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_M5750,
	    CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4700,
	    CHIP_RV740|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4770,
	    CHIP_RV740|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4830_M,
	    CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4850_M_2,
	    CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_M7740,
	    CHIP_RV740|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_M7750,
	    CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_RV770,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V7760,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V8700,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V8750,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIRESTREAM_9250,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIRESTREAM_9270,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4800,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4800_2,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4850,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4850_M,
	    CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4850_X2_M,
	    CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4850_X2,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4870,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4870_X2,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4870_M,
	    CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4870_M98,
	    CHIP_RV770|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4890,
	    CHIP_RV770|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4100,
	    CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4200,
	    CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4250,
	    CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4100_M,
	    CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4200_M,
	    CHIP_RS880|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD4290,
	    CHIP_RS880|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5470,
	    CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5430,
	    CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6370M,
	    CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6330M,
	    CHIP_CEDAR|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CEDAR,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_CEDAR,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_2460,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_2270,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7300,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5450,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7350,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CEDAR_LE,
	    CHIP_CEDAR|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5730,
	    CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5650,
	    CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5570,
	    CHIP_REDWOOD|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V4800,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V3800,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5670,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5570,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5550,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_REDWOOD,
	    CHIP_REDWOOD|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5870,
	    CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5850,
	    CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6850M,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V5800,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD5800,
	    CHIP_JUNIPER|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5770,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5670_640SP,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6770,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5750,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6750,
	    CHIP_JUNIPER|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CYPRESS,
	    CHIP_CYPRESS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V8800,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V7800,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V9800,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIRESTREAM_9370,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIRESTREAM_9350,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5870,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5850,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6800,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5830,
	    CHIP_CYPRESS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5970,
	    CHIP_HEMLOCK|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD5900,
	    CHIP_HEMLOCK|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6310_1,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6310_2,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6250_1,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6250_2,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6320,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6290,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7340,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7310,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7290,
	    CHIP_PALM|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6550D,
	    CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6620G,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6520G,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6480G_1,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6480G_2,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6530D,
	    CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SUMO_1,
	    CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SUMO_2,
	    CHIP_SUMO|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SUMO_3,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_SUMO_4,
	    CHIP_SUMO|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6370D,
	    CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6380G,
	    CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6410D_1,
	    CHIP_SUMO2|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6410D_2,
	    CHIP_SUMO2|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6970M,
	    CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD6000_1,
	    CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_1,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_2,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_HD6000_2,
	    CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6900M,
	    CHIP_BARTS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_3,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_4,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_5,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_BARTS_6,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6870,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6850,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6790,
	    CHIP_BARTS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6730M,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6600M,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6610M,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_E6760,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_1,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_2,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_3,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_4,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_5,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V4900,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V3900,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6650A,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7670A,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6670,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6570,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_6,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7570,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6510,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7670M_1,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7550M,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7000M,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7670M_2,
	    CHIP_TURKS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7400,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_7,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_8,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TURKS_9,
	    CHIP_TURKS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6400M,
	    CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6430M,
	    CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAICOS_1,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_E6460,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6400M_1,
	    CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6400M_2,
	    CHIP_CAICOS|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAICOS_2,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAICOS_3,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAICOS_4,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6450A,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8490,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7450A,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7470,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6450,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7450,
	    CHIP_CAICOS|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_1,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_2,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_3,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_4,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V7900,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_5,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_6,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V5900,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_7,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_CAYMAN_8,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6970,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6950,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6990_1,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6990_2,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD6930,
	    CHIP_CAYMAN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_ARUBA_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7660D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7640G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7560D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_A300_1,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_A300_2,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7620G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7600G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7500G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7500G_2,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8650G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8670D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8550G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8570D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8610G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7660G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7640G_2,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7620G_2,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7600G_2,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7500G,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7520G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7540D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7420G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7480D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7400G_1,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8450G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8470D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8350G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8370D,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8510G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8410G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8310G,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_ARUBA_2,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_ARUBA_3,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7520G_2,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7420G_2,
	    CHIP_ARUBA|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7400G_2,
	    CHIP_ARUBA|RADEON_NEW_MEMMAP|RADEON_IS_IGP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_W9000,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V_1,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_V_2,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TAHITI_1,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TAHITI_2,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TAHITI_3,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TAHITI_4,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7970,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7900,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7950,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7990,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7870XT,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_TAHITI_5,
	    CHIP_TAHITI|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7970M,
	    CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8970M,
	    CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_1,
	    CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_2,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_W7000,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_W5000,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_3,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_4,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_5,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_6,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7870,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7850,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_PITCAIRN_7,
	    CHIP_PITCAIRN|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8800M_1,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8800M_2,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_4,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8800M_3,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7700M_1,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7870M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7700M_2,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7850M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_W600,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_1,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_5,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8800M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_FIREPRO_M4000,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7730M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7800M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7700M,
	    CHIP_VERDE|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_6,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7730,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_2,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_VERDE_3,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7700,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7770,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD7750,
	    CHIP_VERDE|RADEON_NEW_MEMMAP},
#if 0
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8670A,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8730M,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_1,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_2,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8790M,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8530M,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8600,
	    CHIP_OLAND|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8570,
	    CHIP_OLAND|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8500,
	    CHIP_OLAND|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_3,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_4,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_5,
	    CHIP_OLAND|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_OLAND_6,
	    CHIP_OLAND|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8670M,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8500M_1,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_HAINAN_1,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_HAINAN_2,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_HAINAN_3,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RADEON_HD8500M_2,
	    CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP},
#endif
        {0, 0, 0}
d471 1
a471 1
	rdev->flags = id_entry->driver_private;
@


1.3
log
@Hook up the framebuffer colormap helper code on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.2 2013/08/16 19:36:50 kettenis Exp $	*/
a347 1
#if 0
a355 1
#endif
a361 1
#if 0
a369 1
#endif
a609 1
#if 0
a615 1
#endif
@


1.2
log
@Pass cursor position in wsdisplay_cnattach() call.  Preparation for seamless
console transation on sparc64 (and eventually macppc).
@
text
@d1 1
a1 1
/*	$OpenBSD: radeon_kms.c,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/
d1533 24
d1776 3
@


1.1
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1780 1
a1780 1
		    0, 0, defattr);
@

