head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.18
date	2014.03.09.07.42.29;	author jsg;	state dead;
branches;
next	1.17;

1.17
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.16;

1.16
date	2010.05.24.01.19.19;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.29.03.27.02;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.17.00.30.41;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.06.14.25.21;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.04.16.19.54;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.18.15.10.57;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.07.00.44.06;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.06.01.32.08;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.02.01.12.04;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.13.20.27.58;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.07.16.29.57;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.18
log
@remove dri1 interfaces
discussed with kettenis some time last year
@
text
@/* $OpenBSD: drm_lock.c,v 1.17 2011/06/02 18:22:00 weerd Exp $ */
/*-
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *
 */

/** @@file drm_lock.c
 * Implementation of the ioctls and other support code for dealing with the
 * hardware lock.
 *
 * The DRM hardware lock is a shared structure between the kernel and userland.
 *
 * On uncontended access where the new context was the last context, the
 * client may take the lock without dropping down into the kernel, using atomic
 * compare-and-set.
 *
 * If the client finds during compare-and-set that it was not the last owner
 * of the lock, it calls the DRM lock ioctl, which may sleep waiting for the
 * lock, and may have side-effects of kernel-managed context switching.
 *
 * When the client releases the lock, if the lock is marked as being contended
 * by another client, then the DRM unlock ioctl is called so that the
 * contending client may be woken up.
 */

#include "drmP.h"

int
drm_lock_take(struct drm_lock_data *lock_data, unsigned int context)
{
	volatile unsigned int	*lock = &lock_data->hw_lock->lock;
	unsigned int		 old, new;

	do {
		old = *lock;
		if (old & _DRM_LOCK_HELD)
			new = old | _DRM_LOCK_CONT;
		else
			new = context | _DRM_LOCK_HELD;
	} while (!atomic_cmpset_int(lock, old, new));

	if (_DRM_LOCKING_CONTEXT(old) == context && _DRM_LOCK_IS_HELD(old)) {
		if (context != DRM_KERNEL_CONTEXT)
			DRM_ERROR("%d holds heavyweight lock\n", context);
		return (0);
	}
	/* If the lock wasn't held before, it's ours */
	return (!_DRM_LOCK_IS_HELD(old));
}

int
drm_lock_free(struct drm_lock_data *lock_data, unsigned int context)
{
	volatile unsigned int	*lock = &lock_data->hw_lock->lock;
	unsigned int		 old, new;

	mtx_enter(&lock_data->spinlock);
	lock_data->file_priv = NULL;
	do {
		old  = *lock;
		new  = 0;
	} while (!atomic_cmpset_int(lock, old, new));
	mtx_leave(&lock_data->spinlock);

	if (_DRM_LOCK_IS_HELD(old) && _DRM_LOCKING_CONTEXT(old) != context) {
		DRM_ERROR("%d freed heavyweight lock held by %d\n",
			  context, _DRM_LOCKING_CONTEXT(old));
		return 1;
	}
	wakeup(lock_data);
	return 0;
}

int
drm_lock(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
        struct drm_lock	*lock = data;
        int		 ret = 0;

        if (lock->context == DRM_KERNEL_CONTEXT) {
                DRM_ERROR("Process %d using kernel context %d\n",
		    DRM_CURRENTPID, lock->context);
                return EINVAL;
        }

        DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
	    lock->context, DRM_CURRENTPID, dev->lock.hw_lock->lock,
	    lock->flags);

	mtx_enter(&dev->lock.spinlock);
	for (;;) {
		if (drm_lock_take(&dev->lock, lock->context)) {
			dev->lock.file_priv = file_priv;
			break;  /* Got lock */
		}

		/* Contention */
		ret = msleep(&dev->lock, &dev->lock.spinlock,
		    PZERO | PCATCH, "drmlkq", 0);
		if (ret != 0)
			break;
	}
	mtx_leave(&dev->lock.spinlock);
	DRM_DEBUG("%d %s\n", lock->context, ret ? "interrupted" : "has lock");

	if (ret != 0)
		return ret;

	/* XXX: Add signal blocking here */

	return 0;
}

int
drm_unlock(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	struct drm_lock	*lock = data;

	if (lock->context == DRM_KERNEL_CONTEXT) {
		DRM_ERROR("Process %d using kernel context %d\n",
		    DRM_CURRENTPID, lock->context);
		return EINVAL;
	}
	/* Check that the context unlock being requested actually matches
	 * who currently holds the lock.
	 */
	if (!_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) ||
	    _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock) != lock->context)
		return EINVAL;

	if (drm_lock_free(&dev->lock, lock->context)) {
		DRM_ERROR("\n");
	}

	return 0;
}
@


1.17
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.16
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@d1 1
@


1.15
log
@Remove the lock_time member from the hardware lock. It's not that
useful, and driver shouldn't need to know about ``ticks''.
@
text
@a134 4
	if (dev->driver->dma_quiescent != NULL &&
	    (lock->flags & _DRM_LOCK_QUIESCENT))
		dev->driver->dma_quiescent(dev);

@


1.14
log
@Instead of using a width-1 bitfield for storing the driver capabilities
in the callback structure, just use a bunch of ORed together bits. This
has been annoying me for ages.
@
text
@d66 4
a69 8
	if (_DRM_LOCKING_CONTEXT(old) == context) {
		if (old & _DRM_LOCK_HELD) {
			if (context != DRM_KERNEL_CONTEXT) {
				DRM_ERROR("%d holds heavyweight lock\n",
				    context);
			}
			return 0;
		}
d71 2
a72 5
	if (new == (context | _DRM_LOCK_HELD)) {
		/* Have lock */
		return 1;
	}
	return 0;
a117 1
			dev->lock.lock_time = jiffies;
@


1.13
log
@Remove the drm_locked_tasklet interface. The only consumer that used it
was the i915 vblank swap ioctl, which just went kaput.
@
text
@a120 3
        if (dev->driver->use_dma_queue && lock->context < 0)
                return EINVAL;

@


1.12
log
@If we need to call the tasklet function on unlock, we don't need to hold
tsk_lock (which blocks irqs) for the whole call of the function, just
when we manipulate the function pointer.
@
text
@a156 1
	void		(*func)(struct drm_device *);
a168 7

	mtx_enter(&dev->tsk_lock);
	func = dev->locked_task_call;
	dev->locked_task_call = NULL;
	mtx_leave(&dev->tsk_lock);
	if (func != NULL)
		(*func)(dev);
@


1.11
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@d157 1
d171 6
a176 6
	DRM_SPINLOCK(&dev->tsk_lock);
	if (dev->locked_task_call != NULL) {
		dev->locked_task_call(dev);
		dev->locked_task_call = NULL;
	}
	DRM_SPINUNLOCK(&dev->tsk_lock);
@


1.10
log
@Rework the drm locking to be at least halfway sane. The freebsd code
held a lock over all driver ioctls in order to be ``mpsafe''. Stop lying
to ourselves for a start. This code is not fully mpsafe, and should not
pretend to be so.  Put the locking around where it should, and rely on
biglock for the rest. This will need to be fixed, but avoids some of the
horrible that we have right now.

Tested by many over a long time and several iterations.
@
text
@d121 1
a121 1
        if (dev->driver.use_dma_queue && lock->context < 0)
d146 1
a146 1
	if (dev->driver.dma_quiescent != NULL &&
d148 1
a148 1
		dev->driver.dma_quiescent(dev);
@


1.9
log
@Kill some unneeded defines and struct members.
@
text
@a81 17
/* This takes a lock forcibly and hands it to context.	Should ONLY be used
   inside *_unlock to give lock to kernel before calling *_dma_schedule. */
int
drm_lock_transfer(struct drm_lock_data *lock_data, unsigned int context)
{
	volatile unsigned int	*lock = &lock_data->hw_lock->lock;
	unsigned int		 old, new;

	lock_data->file_priv = NULL;
	do {
		old  = *lock;
		new  = context | _DRM_LOCK_HELD;
	} while (!atomic_cmpset_int(lock, old, new));

	return 1;
}

d88 1
d94 1
d101 1
a101 1
	DRM_WAKEUP_INT((void *)&lock_data->lock_queue);
d124 1
a124 1
	DRM_LOCK();
d133 2
a134 2
		ret = msleep((void *)&dev->lock.lock_queue,
		    &dev->dev_lock, PZERO | PCATCH, "drmlkq", 0);
d138 1
a138 1
	DRM_UNLOCK();
d177 1
a177 4
	DRM_LOCK();
	drm_lock_transfer(&dev->lock, DRM_KERNEL_CONTEXT);

	if (drm_lock_free(&dev->lock, DRM_KERNEL_CONTEXT)) {
a179 1
	DRM_UNLOCK();
@


1.8
log
@Kill the stats data structures and noop some other parts. Nothing in
userland asks for these stats, and we stopped recording anything
interesting a while back.
@
text
@d148 1
a148 1
		ret = DRM_SLEEPLOCK((void *)&dev->lock.lock_queue,
@


1.7
log
@detypedef some more. No functional change.
@
text
@a143 1
			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
a190 2

	atomic_inc(&dev->counts[_DRM_STAT_UNLOCKS]);
@


1.6
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@d123 1
a123 1
        drm_lock_t	*lock = data;
d172 1
a172 1
	drm_lock_t	*lock = data;
@


1.5
log
@Change the drm_lock*() api to take a pointer to the struct as a
parameter, this makes things a little cleaner and removes the need to
pass in the softc for some functions.
@
text
@d60 4
a63 2
		if (old & _DRM_LOCK_HELD) new = old | _DRM_LOCK_CONT;
		else new = context | _DRM_LOCK_HELD;
d85 1
a85 2
drm_lock_transfer(struct drm_lock_data *lock_data,
    unsigned int context)
d100 1
a100 2
drm_lock_free(struct drm_lock_data *lock_data,
    unsigned int context)
@


1.4
log
@The current drm_locked_task*() code sometimes tries to sleep in an
interrupt handler.

This is bad and wrong. So change it so that if we can't immediately grab
the hardware lock, to just leave the task flagged so that we can run it
when we release the lock. The linux implementation uses a similar
scheme.

Tested by guenther@@, landry@@ and bernd@@. Also tested by many a while
ago as part of a larger diff.
@
text
@d53 1
a53 1
drm_lock_take(__volatile__ unsigned int *lock, unsigned int context)
d55 2
a56 1
	unsigned int old, new;
d83 1
a83 1
drm_lock_transfer(struct drm_device *dev, __volatile__ unsigned int *lock,
d86 2
a87 1
	unsigned int old, new;
d89 1
a89 1
	dev->lock.file_priv = NULL;
d99 1
a99 1
drm_lock_free(struct drm_device *dev, __volatile__ unsigned int *lock,
d102 2
a103 1
	unsigned int old, new;
d105 1
a105 1
	dev->lock.file_priv = NULL;
d116 1
a116 1
	DRM_WAKEUP_INT((void *)&dev->lock.lock_queue);
d123 2
a124 2
        drm_lock_t *lock = data;
        int ret = 0;
d141 1
a141 1
		if (drm_lock_take(&dev->lock.hw_lock->lock, lock->context)) {
d149 2
a150 2
		ret = DRM_SLEEPLOCK((void *)&dev->lock.lock_queue, &dev->dev_lock,
		    PZERO | PCATCH, "drmlk2", 0);
d172 1
a172 1
	drm_lock_t *lock = data;
d196 1
a196 1
	drm_lock_transfer(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT);
d198 1
a198 1
	if (drm_lock_free(dev, &dev->lock.hw_lock->lock, DRM_KERNEL_CONTEXT)) {
@


1.3
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d183 7
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d82 1
a82 1
drm_lock_transfer(drm_device_t *dev, __volatile__ unsigned int *lock,
d97 1
a97 1
drm_lock_free(drm_device_t *dev, __volatile__ unsigned int *lock,
d118 1
a118 1
drm_lock(drm_device_t *dev, void *data, struct drm_file *file_priv)
d167 1
a167 1
drm_unlock(drm_device_t *dev, void *data, struct drm_file *file_priv)
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d52 2
a53 1
int drm_lock_take(__volatile__ unsigned int *lock, unsigned int context)
d60 1
a60 1
		else			  new = context | _DRM_LOCK_HELD;
d67 1
a67 1
					  context);
d73 1
a73 1
				/* Have lock */
d81 3
a83 2
int drm_lock_transfer(drm_device_t *dev,
		       __volatile__ unsigned int *lock, unsigned int context)
d96 3
a98 2
int drm_lock_free(drm_device_t *dev,
		   __volatile__ unsigned int *lock, unsigned int context)
d117 2
a118 1
int drm_lock(drm_device_t *dev, void *data, struct drm_file *file_priv)
d166 2
a167 1
int drm_unlock(drm_device_t *dev, void *data, struct drm_file *file_priv)
@

