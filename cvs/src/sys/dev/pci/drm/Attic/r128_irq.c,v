head	1.11;
access;
symbols
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2010.05.24.01.19.19;	author oga;	state dead;
branches;
next	1.10;

1.10
date	2010.04.15.19.17.48;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.03.14.01.40;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.03.13.56.23;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.03.13.51.45;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.03.13.47.04;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.03.12.54.24;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.23.21.35.01;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.23.20.46.48;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@/* r128_irq.c -- IRQ handling for radeon -*- linux-c -*- */
/*
 * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
 *
 * The Weather Channel (TM) funded Tungsten Graphics to develop the
 * initial release of the Radeon 8500 driver under the XFree86 license.
 * This notice must be preserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keith@@tungstengraphics.com>
 *    Eric Anholt <anholt@@FreeBSD.org>
 */

#include "drmP.h"
#include "drm.h"
#include "r128_drm.h"
#include "r128_drv.h"

int	ragedrm_intr(void *);

u_int32_t
r128_get_vblank_counter(struct drm_device *dev, int crtc)
{
	const drm_r128_private_t	*dev_priv = dev->dev_private;

	if (crtc != 0)
		return 0;

	return (atomic_read(&dev_priv->vbl_received));
}

int
ragedrm_intr(void *arg)
{
	struct drm_device	*dev = (struct drm_device *) arg;
	drm_r128_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 status;
	int			 handled = 0;

	status = R128_READ(R128_GEN_INT_STATUS);

	/* VBLANK interrupt */
	if (status & R128_CRTC_VBLANK_INT) {
		R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);
		atomic_inc(&dev_priv->vbl_received);
		drm_handle_vblank(dev, 0);
		handled = 1;
	}
	return (handled);
}

int
r128_enable_vblank(struct drm_device *dev, int crtc)
{
	drm_r128_private_t	*dev_priv = dev->dev_private;

	if (crtc != 0) {
		DRM_ERROR("%s:  bad crtc %d\n", __FUNCTION__, crtc);
		return (EINVAL);
	}

	R128_WRITE(R128_GEN_INT_CNTL, R128_CRTC_VBLANK_INT_EN);
	return (0);
}

void
r128_disable_vblank(struct drm_device *dev, int crtc)
{
	if (crtc != 0)
		DRM_ERROR("%s:  bad crtc %d\n", __FUNCTION__, crtc);

	/*
	 * FIXME: implement proper interrupt disable by using the vblank
	 * counter register (if available)
	 *
	 * R128_WRITE(R128_GEN_INT_CNTL,
	 *            R128_READ(R128_GEN_INT_CNTL) & ~R128_CRTC_VBLANK_INT_EN);
	 */
}

int
r128_driver_irq_install(struct drm_device * dev)
{
	drm_r128_private_t *dev_priv = dev->dev_private;

	/* Disable *all* interrupts */
	R128_WRITE(R128_GEN_INT_CNTL, 0);
	/* Clear vblank bit if it's already high */
	R128_WRITE(R128_GEN_INT_STATUS, R128_CRTC_VBLANK_INT_AK);

	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_TTY,
	    ragedrm_intr, dev, dev_priv->dev.dv_xname);
	if (dev_priv->irqh == NULL)
		return (ENOENT);
	return (0);
}

void
r128_driver_irq_uninstall(struct drm_device * dev)
{
	drm_r128_private_t *dev_priv = dev->dev_private;

	/* Disable *all* interrupts */
	R128_WRITE(R128_GEN_INT_CNTL, 0);

	pci_intr_disestablish(dev_priv->pc, dev_priv->irqh);
}
@


1.10
log
@Use IPL_TTY instead of IPB_BIO as suggested by oga.

Tested by me and mlarkin on amd64 and i386
ok oga
@
text
@@


1.9
log
@${XORGNAME}_driver_irq_handler() is a stupid name for an interrupt
handler anyway. replace it with ${OpenBSD_driver_name}_intr like most of
the rest of the tree. No functional change.
@
text
@d110 1
a110 1
	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_BIO,
@


1.8
log
@More compat crud bites the dust: Remove the IRQ_NONE and IRQ_HANDLED
defines. 0 and 1 are fine for returning from irq handlers so why bother
with the indirection?
@
text
@d38 1
a38 1
int	r128_driver_irq_handler(void *);
d52 1
a52 1
r128_driver_irq_handler(void *arg)
d111 1
a111 1
	    r128_driver_irq_handler, dev, dev_priv->dev.dv_xname);
@


1.7
log
@kill the stupid DRM_IRQ_ARGS macros and irqreturn_t typedef, switch to
the unmacroed/typedefed version.
@
text
@d56 2
a57 1
	int			 status;
d66 1
a66 1
		return (IRQ_HANDLED);
d68 1
a68 1
	return (IRQ_NONE);
@


1.6
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d38 1
a38 1
irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS);
d51 2
a52 2
irqreturn_t
r128_driver_irq_handler(DRM_IRQ_ARGS)
@


1.5
log
@Same as just done for machdrm, just convert us over to using our irq
handler directly, no fences to worry about right now.
@
text
@d38 2
@


1.4
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d38 2
a39 1
u32 r128_get_vblank_counter(struct drm_device *dev, int crtc)
d41 1
a41 1
	const drm_r128_private_t *dev_priv = dev->dev_private;
d46 1
a46 1
	return atomic_read(&dev_priv->vbl_received);
d49 2
a50 1
irqreturn_t r128_driver_irq_handler(DRM_IRQ_ARGS)
d52 3
a54 3
	struct drm_device *dev = (struct drm_device *) arg;
	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
	int status;
d63 1
a63 1
		return IRQ_HANDLED;
d65 1
a65 1
	return IRQ_NONE;
d68 2
a69 1
int r128_enable_vblank(struct drm_device *dev, int crtc)
d71 1
a71 1
	drm_r128_private_t *dev_priv = dev->dev_private;
d75 1
a75 1
		return -EINVAL;
d79 1
a79 1
	return 0;
d82 2
a83 1
void r128_disable_vblank(struct drm_device *dev, int crtc)
d100 1
a100 1
	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
d108 1
a108 1
	    drm_irq_handler_wrap, dev, dev_priv->dev.dv_xname);
d117 1
a117 1
	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;
@


1.3
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d93 2
a94 1
void r128_driver_irq_preinstall(struct drm_device * dev)
d102 6
d110 2
a111 1
void r128_driver_irq_uninstall(struct drm_device * dev)
a113 2
	if (!dev_priv)
		return;
d117 2
@


1.2
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@a102 5
int r128_driver_irq_postinstall(struct drm_device * dev)
{
	return drm_vblank_init(dev, 1);
}

@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d38 10
d59 2
a60 3
		atomic_inc(&dev->vbl_received);
		DRM_WAKEUP(&dev->vbl_queue);
		drm_vbl_send_signals(dev);
d66 1
a66 1
int r128_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
d68 6
a73 2
	unsigned int cur_vblank;
	int ret = 0;
d75 3
a77 7
	/* Assume that the user has missed the current sequence number
	 * by about a day rather than she wants to wait for years
	 * using vertical blanks...
	 */
	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
		    (((cur_vblank = atomic_read(&dev->vbl_received))
		      - *sequence) <= (1 << 23)));
d79 4
a82 1
	*sequence = cur_vblank;
d84 7
a90 1
	return ret;
d103 1
a103 1
void r128_driver_irq_postinstall(struct drm_device * dev)
d105 1
a105 4
	drm_r128_private_t *dev_priv = (drm_r128_private_t *) dev->dev_private;

	/* Turn on VBL interrupt */
	R128_WRITE(R128_GEN_INT_CNTL, R128_CRTC_VBLANK_INT_EN);
@

