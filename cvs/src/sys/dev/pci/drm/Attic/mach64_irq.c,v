head	1.13;
access;
symbols
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2010.05.24.01.19.19;	author oga;	state dead;
branches;
next	1.12;

1.12
date	2010.04.15.19.17.48;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.03.14.01.40;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.03.13.56.23;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.03.13.51.45;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.03.13.47.04;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.03.12.50.27;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.27.00.29.44;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.23.21.35.01;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.23.20.46.47;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.10.07.22.25.12;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@/* mach64_irq.c -- IRQ handling for ATI Mach64 -*- linux-c -*-
 * Created: Tue Feb 25, 2003 by Leif Delgass, based on radeon_irq.c/r128_irq.c
 */
/*-
 * Copyright (C) The Weather Channel, Inc.  2002.
 * Copyright 2003 Leif Delgass
 * All Rights Reserved.
 *
 * The Weather Channel (TM) funded Tungsten Graphics to develop the
 * initial release of the Radeon 8500 driver under the XFree86 license.
 * This notice must be preserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keith@@tungstengraphics.com>
 *    Eric Anholt <anholt@@FreeBSD.org>
 *    Leif Delgass <ldelgass@@retinalburn.net>
 */

#include "drmP.h"
#include "drm.h"
#include "mach64_drm.h"
#include "mach64_drv.h"

int	machdrm_intr(void *);

int
machdrm_intr(void *arg)
{
	struct drm_device	*dev = arg;
	drm_mach64_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 status;
	int			 handled = 0;

	status = MACH64_READ(MACH64_CRTC_INT_CNTL);

	/* VBLANK interrupt */
	if (status & MACH64_CRTC_VBLANK_INT) {
		/*
		 * Mask off all interrupt ack bits before setting the ack bit,
		 * since there may be other handlers outside the DRM.
		 *
		 * NOTE: On mach64, you need to keep the enable bits set when
		 * doing the ack, despite what the docs say about not acking
		 * and enabling in a single write.
		 */
		MACH64_WRITE(MACH64_CRTC_INT_CNTL,
		    (status & ~MACH64_CRTC_INT_ACKS) | MACH64_CRTC_VBLANK_INT);

		atomic_inc(&dev_priv->vbl_received);
		drm_handle_vblank(dev, 0);
		handled = 1;
	}
	return (handled);
}

u_int32_t
mach64_get_vblank_counter(struct drm_device * dev, int crtc)
{
	const drm_mach64_private_t *const	dev_priv = dev->dev_private;

	if (crtc != 0)
		return 0;

	return (atomic_read(&dev_priv->vbl_received));
}

int
mach64_enable_vblank(struct drm_device * dev, int crtc)
{
	drm_mach64_private_t	*dev_priv = dev->dev_private;

	if (crtc != 0) {
		DRM_ERROR("tried to enable vblank on non-existent crtc %d\n",
			  crtc);
		return (EINVAL);
	}

	DRM_DEBUG("before enable vblank CRTC_INT_CTNL: 0x%08x\n",
	    MACH64_READ(MACH64_CRTC_INT_CNTL));

	/* Turn on VBLANK interrupt */
	MACH64_WRITE(MACH64_CRTC_INT_CNTL, MACH64_READ(MACH64_CRTC_INT_CNTL) |
	    MACH64_CRTC_VBLANK_INT_EN);

	return (0);
}

void
mach64_disable_vblank(struct drm_device * dev, int crtc)
{
	if (crtc != 0) {
		DRM_ERROR("tried to disable vblank on non-existent crtc %d\n",
			  crtc);
		return;
	}

	/*
	 * FIXME: implement proper interrupt disable by using the vblank
	 * counter register (if available).
	 */
}

static void
mach64_disable_vblank_local(struct drm_device * dev, int crtc)
{
	drm_mach64_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 status;

	status = MACH64_READ(MACH64_CRTC_INT_CNTL);

	if (crtc != 0) {
		DRM_ERROR("tried to disable vblank on non-existent crtc %d\n",
			  crtc);
		return;
	}

	DRM_DEBUG("before disable vblank CRTC_INT_CTNL: 0x%08x\n", status);

	/* Disable and clear VBLANK interrupt */
	MACH64_WRITE(MACH64_CRTC_INT_CNTL, (status & ~MACH64_CRTC_VBLANK_INT_EN)
	    | MACH64_CRTC_VBLANK_INT);
}

int
mach64_driver_irq_install(struct drm_device * dev)
{
	drm_mach64_private_t	*dev_priv = dev->dev_private;


	DRM_DEBUG("before install CRTC_INT_CTNL: 0x%08x\n",
	    MACH64_READ(MACH64_CRTC_INT_CNTL));

	mach64_disable_vblank_local(dev, 0);

	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_TTY,
	    machdrm_intr, dev, dev_priv->dev.dv_xname);
	if (dev_priv->irqh == NULL)
		return (ENOENT);
	return (0);
}

void
mach64_driver_irq_uninstall(struct drm_device * dev)
{
	drm_mach64_private_t	*dev_priv = dev->dev_private;

	mach64_disable_vblank_local(dev, 0);

	DRM_DEBUG("after uninstall CRTC_INT_CTNL: 0x%08x\n",
		  MACH64_READ(MACH64_CRTC_INT_CNTL));
	pci_intr_disestablish(dev_priv->pc, dev_priv->irqh);
}
@


1.12
log
@Use IPL_TTY instead of IPB_BIO as suggested by oga.

Tested by me and mlarkin on amd64 and i386
ok oga
@
text
@@


1.11
log
@${XORGNAME}_driver_irq_handler() is a stupid name for an interrupt
handler anyway. replace it with ${OpenBSD_driver_name}_intr like most of
the rest of the tree. No functional change.
@
text
@d154 1
a154 1
	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_BIO,
@


1.10
log
@More compat crud bites the dust: Remove the IRQ_NONE and IRQ_HANDLED
defines. 0 and 1 are fine for returning from irq handlers so why bother
with the indirection?
@
text
@d43 1
a43 1
int	mach64_driver_irq_handler(void *);
d46 1
a46 1
mach64_driver_irq_handler(void *arg)
d155 1
a155 1
	    mach64_driver_irq_handler, dev, dev_priv->dev.dv_xname);
@


1.9
log
@kill the stupid DRM_IRQ_ARGS macros and irqreturn_t typedef, switch to
the unmacroed/typedefed version.
@
text
@d50 2
a51 1
	int			 status;
d70 1
a70 1
		return (IRQ_HANDLED);
d72 1
a72 1
	return (IRQ_NONE);
@


1.8
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d43 1
a43 1
irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS);
d45 2
a46 2
irqreturn_t
mach64_driver_irq_handler(DRM_IRQ_ARGS)
@


1.7
log
@Convert machdrm to not have to user drm_irq_handler. Since the only
interrupt we provide is vblank, it's just switching the handler. knf
while here.
@
text
@d43 2
@


1.6
log
@While printing is turned off by default, the debug code was still
compiled into drm. I'd forgotten about that. if DRMDEBUG is defined,
build in the printfs, else no-op them. Shaves a bunch of string from the
kernel

Fix two cases in mach64_irq.c where this would lead to unused variable
warnings.

Reminded by an entirely different comment by djm@@.
@
text
@d43 2
a44 1
irqreturn_t mach64_driver_irq_handler(DRM_IRQ_ARGS)
d46 3
a48 3
	struct drm_device *dev = arg;
	drm_mach64_private_t *dev_priv = dev->dev_private;
	int status;
d54 3
a56 2
		/* Mask off all interrupt ack bits before setting the ack bit, since
		 * there may be other handlers outside the DRM.
d58 3
a60 3
		 * NOTE: On mach64, you need to keep the enable bits set when doing
		 * the ack, despite what the docs say about not acking and enabling
		 * in a single write.
d63 1
a63 2
			     (status & ~MACH64_CRTC_INT_ACKS)
			     | MACH64_CRTC_VBLANK_INT);
d67 1
a67 1
		return IRQ_HANDLED;
d69 1
a69 1
	return IRQ_NONE;
d72 2
a73 1
u32 mach64_get_vblank_counter(struct drm_device * dev, int crtc)
d75 1
a75 1
	const drm_mach64_private_t *const dev_priv = dev->dev_private;
d80 1
a80 1
	return atomic_read(&dev_priv->vbl_received);
d83 2
a84 1
int mach64_enable_vblank(struct drm_device * dev, int crtc)
d86 1
a86 1
	drm_mach64_private_t *dev_priv = dev->dev_private;
d91 1
a91 1
		return EINVAL;
d98 2
a99 2
	MACH64_WRITE(MACH64_CRTC_INT_CNTL, MACH64_READ(MACH64_CRTC_INT_CNTL)
		     | MACH64_CRTC_VBLANK_INT_EN);
d101 1
a101 1
	return 0;
d104 2
a105 1
void mach64_disable_vblank(struct drm_device * dev, int crtc)
d119 2
a120 1
static void mach64_disable_vblank_local(struct drm_device * dev, int crtc)
d122 4
a125 2
	drm_mach64_private_t *dev_priv = dev->dev_private;
	u32 status = MACH64_READ(MACH64_CRTC_INT_CNTL);
d137 1
a137 1
		     | MACH64_CRTC_VBLANK_INT);
d143 1
a143 1
	drm_mach64_private_t *dev_priv = dev->dev_private;
d152 1
a152 1
	    drm_irq_handler_wrap, dev, dev_priv->dev.dv_xname);
d158 2
a159 1
void mach64_driver_irq_uninstall(struct drm_device * dev)
d161 1
a161 1
	drm_mach64_private_t *dev_priv = dev->dev_private;
@


1.5
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@a83 1
	u32 status = MACH64_READ(MACH64_CRTC_INT_CNTL);
d91 2
a92 1
	DRM_DEBUG("before enable vblank CRTC_INT_CTNL: 0x%08x\n", status);
a137 1
	u32 status = MACH64_READ(MACH64_CRTC_INT_CNTL);
d139 2
a140 1
	DRM_DEBUG("before install CRTC_INT_CTNL: 0x%08x\n", status);
@


1.4
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d133 2
a134 1
void mach64_driver_irq_preinstall(struct drm_device * dev)
d143 6
a153 2
	if (!dev_priv)
		return;
d159 1
@


1.3
log
@Kill the linux-ready negative return codes in ``shared'' code. We handle
them wrong in several cases that i've noticed and Merging when needed is
still fairly simple, anyway. This shaves another 500 bytes from an amd64
kernel due to not having to flip the sign on some things. It also stops
my eyes bleeding.

Tested by a few along with the last diff that went in.
@
text
@a143 5
int mach64_driver_irq_postinstall(struct drm_device * dev)
{
	return drm_vblank_init(dev, 1);
}

@


1.2
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d89 1
a89 1
		return -EINVAL;
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d45 2
a46 3
	struct drm_device *dev = (struct drm_device *) arg;
	drm_mach64_private_t *dev_priv =
	    (drm_mach64_private_t *) dev->dev_private;
d64 2
a65 3
		atomic_inc(&dev->vbl_received);
		DRM_WAKEUP(&dev->vbl_queue);
		drm_vbl_send_signals(dev);
d71 1
a71 1
int mach64_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
d73 1
a73 2
	unsigned int cur_vblank;
	int ret = 0;
d75 16
a90 7
	/* Assume that the user has missed the current sequence number
	 * by about a day rather than she wants to wait for years
	 * using vertical blanks...
	 */
	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
		    (((cur_vblank = atomic_read(&dev->vbl_received))
		      - *sequence) <= (1 << 23)));
d92 1
a92 1
	*sequence = cur_vblank;
d94 5
a98 1
	return ret;
d101 1
a101 3
/* drm_dma.h hooks
*/
void mach64_driver_irq_preinstall(struct drm_device * dev)
d103 11
a113 2
	drm_mach64_private_t *dev_priv =
	    (drm_mach64_private_t *) dev->dev_private;
d115 3
d120 7
a126 1
	DRM_DEBUG("before install CRTC_INT_CTNL: 0x%08x\n", status);
d133 1
a133 1
void mach64_driver_irq_postinstall(struct drm_device * dev)
d135 3
a137 2
	drm_mach64_private_t *dev_priv =
	    (drm_mach64_private_t *) dev->dev_private;
d139 1
a139 3
	/* Turn on VBLANK interrupt */
	MACH64_WRITE(MACH64_CRTC_INT_CNTL, MACH64_READ(MACH64_CRTC_INT_CNTL)
		     | MACH64_CRTC_VBLANK_INT_EN);
d141 2
a142 2
	DRM_DEBUG("after install CRTC_INT_CTNL: 0x%08x\n",
		  MACH64_READ(MACH64_CRTC_INT_CNTL));
d144 3
d151 1
a151 2
	drm_mach64_private_t *dev_priv =
	    (drm_mach64_private_t *) dev->dev_private;
d155 1
a155 5
	/* Disable and clear VBLANK interrupt */
	MACH64_WRITE(MACH64_CRTC_INT_CNTL,
		     (MACH64_READ(MACH64_CRTC_INT_CNTL) &
		      ~MACH64_CRTC_VBLANK_INT_EN)
		     | MACH64_CRTC_VBLANK_INT);
@

