head	1.27;
access;
symbols
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2010.05.24.01.19.19;	author oga;	state dead;
branches;
next	1.26;

1.26
date	2009.04.07.00.10.31;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.03.14.30.57;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.03.14.16.23;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.03.13.47.04;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.08.19.06.34;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.24.07.06.27;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.24.04.21.31;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.24.03.49.19;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.24.03.16.27;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.23.22.56.02;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.23.21.35.01;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.23.20.46.48;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.22.22.43.53;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.22.21.26.48;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.22.20.49.36;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.22.04.45.21;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.22.04.30.41;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.17.00.30.41;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.17.00.26.02;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.10.07.22.35.30;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.26.19.33.20;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@/* r128_drv.c -- ATI Rage 128 driver -*- linux-c -*-
 * Created: Mon Dec 13 09:47:27 1999 by faith@@precisioninsight.com
 */
/*-
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *
 */

#include "drmP.h"
#include "drm.h"
#include "r128_drm.h"
#include "r128_drv.h"

int	ragedrm_probe(struct device *, void *, void *);
void	ragedrm_attach(struct device *, struct device *, void *);
int	ragedrm_detach(struct device *, int);
int	ragedrm_ioctl(struct drm_device *, u_long, caddr_t, struct drm_file *);

const static struct drm_pcidev ragedrm_pciidlist[] = {
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_LE},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_M3},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_MF},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_ML},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PA},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PB},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PC},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PD},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PE},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE_FURY},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PG},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PH},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PI},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PJ},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PK},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PL},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PM},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PN},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PO},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PP},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PQ},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PR},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PS},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PT},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PU},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PV},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PW},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PX},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_GL},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE_MAGNUM},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_RG},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_RK},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_VR},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_SM},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TF},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TL},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TR},
	{0, 0, 0}
};

static const struct drm_driver_info ragedrm_driver = {
	.buf_priv_size		= sizeof(struct ragedrm_buf_priv),
	.ioctl			= ragedrm_ioctl,
	.close			= r128_driver_close,
	.lastclose		= r128_driver_lastclose,
	.vblank_pipes		= 1,
	.get_vblank_counter	= r128_get_vblank_counter,
	.enable_vblank 		= r128_enable_vblank,
	.disable_vblank		= r128_disable_vblank,
	.irq_install		= r128_driver_irq_install,
	.irq_uninstall		= r128_driver_irq_uninstall,
	.dma_ioctl		= r128_cce_buffers,

	.name			= DRIVER_NAME,
	.desc			= DRIVER_DESC,
	.date			= DRIVER_DATE,
	.major			= DRIVER_MAJOR,
	.minor			= DRIVER_MINOR,
	.patchlevel		= DRIVER_PATCHLEVEL,

	.flags			= DRIVER_AGP | DRIVER_MTRR | DRIVER_SG |
				    DRIVER_DMA | DRIVER_IRQ,
};

int
ragedrm_probe(struct device *parent, void *match, void *aux)
{
	return drm_pciprobe((struct pci_attach_args *)aux, ragedrm_pciidlist);
}

void
ragedrm_attach(struct device *parent, struct device *self, void *aux)
{
	drm_r128_private_t	*dev_priv = (drm_r128_private_t *)self;
	struct pci_attach_args	*pa = aux;
	struct vga_pci_bar	*bar;
	int			 is_agp;

	dev_priv->pc = pa->pa_pc;

	bar = vga_pci_bar_info((struct vga_pci_softc *)parent, 2);
	if (bar == NULL) {
		printf(": can't get BAR info\n");
		return;
	}

	dev_priv->regs = vga_pci_bar_map((struct vga_pci_softc *)parent, 
	    bar->addr, 0, 0);
	if (dev_priv->regs == NULL) {
		printf(": can't map mmio space\n");
		return;
	}

	if (pci_intr_map(pa, &dev_priv->ih) != 0) {
		printf(": couldn't map interrupt\n");
		return;
	}
	printf(": %s\n", pci_intr_string(pa->pa_pc, dev_priv->ih));

	is_agp = pci_get_capability(pa->pa_pc, pa->pa_tag, PCI_CAP_AGP,
	    NULL, NULL);

	dev_priv->drmdev = drm_attach_pci(&ragedrm_driver, pa, is_agp, self);
}

int
ragedrm_detach(struct device *self, int flags)
{
	drm_r128_private_t	*dev_priv = (drm_r128_private_t *)self;

	if (dev_priv->drmdev != NULL) {
		config_detach(dev_priv->drmdev, flags);
		dev_priv->drmdev = NULL;
	}

	if (dev_priv->regs != NULL)
		vga_pci_bar_unmap(dev_priv->regs);

	return (0);
}

struct cfattach ragedrm_ca = {
	sizeof(drm_r128_private_t), ragedrm_probe, ragedrm_attach,
	ragedrm_detach
};

struct cfdriver ragedrm_cd = {
	0, "ragedrm", DV_DULL
};

int
ragedrm_ioctl(struct drm_device *dev, u_long cmd, caddr_t data,
    struct drm_file *file_priv)
{
	if (file_priv->authenticated == 1) {
		switch (cmd) {
		case DRM_IOCTL_R128_CCE_IDLE:
			return (r128_cce_idle(dev, data, file_priv));
		case DRM_IOCTL_R128_RESET:
			return (r128_engine_reset(dev, data, file_priv));
		case DRM_IOCTL_R128_FULLSCREEN:
			return (r128_fullscreen(dev, data, file_priv));
		case DRM_IOCTL_R128_SWAP:
			return (r128_cce_swap(dev, data, file_priv));
		case DRM_IOCTL_R128_FLIP:
			return (r128_cce_flip(dev, data, file_priv));
		case DRM_IOCTL_R128_CLEAR:
			return (r128_cce_clear(dev, data, file_priv));
		case DRM_IOCTL_R128_VERTEX:
			return (r128_cce_vertex(dev, data, file_priv));
		case DRM_IOCTL_R128_INDICES:
			return (r128_cce_indices(dev, data, file_priv));
		case DRM_IOCTL_R128_BLIT:
			return (r128_cce_blit(dev, data, file_priv));
		case DRM_IOCTL_R128_DEPTH:
			return (r128_cce_depth(dev, data, file_priv));
		case DRM_IOCTL_R128_STIPPLE:
			return (r128_cce_stipple(dev, data, file_priv));
		case DRM_IOCTL_R128_GETPARAM:
			return (r128_getparam(dev, data, file_priv));
		}
	}

	if (file_priv->master == 1) {
		switch (cmd) {
		case DRM_IOCTL_R128_INIT:
			return (r128_cce_init(dev, data, file_priv));
		case DRM_IOCTL_R128_CCE_START:
			return (r128_cce_start(dev, data, file_priv));
		case DRM_IOCTL_R128_CCE_STOP:
			return (r128_cce_stop(dev, data, file_priv));
		case DRM_IOCTL_R128_CCE_RESET:
			return (r128_cce_reset(dev, data, file_priv));
		case DRM_IOCTL_R128_INDIRECT:
			return (r128_cce_indirect(dev, data, file_priv));
		}
	}
	return (EINVAL);
}
@


1.26
log
@Remove some dead and if 0ed out code in the ragedrm freelist, while i'm here
detypedef the buf_priv structure and do a little cleanup.
@
text
@@


1.25
log
@detypedef drm_pci_id_list_t.
@
text
@d86 1
a86 1
	.buf_priv_size		= sizeof(drm_r128_buf_priv_t),
@


1.24
log
@Sprinkle some const correctness for the pciid lists. From mickey ages
ago.
@
text
@d44 1
a44 1
const static drm_pci_id_list_t ragedrm_pciidlist[] = {
@


1.23
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d44 1
a44 1
static drm_pci_id_list_t ragedrm_pciidlist[] = {
@


1.22
log
@Make the various drm drivers print the interrupt they're using.

ok oga@@
@
text
@a95 1
	.irq_handler		= r128_driver_irq_handler,
@


1.21
log
@do the same for struct drm_file (file_priv) as previously done for
dma_bufs; allow the driver to provide the size and not have the private
data pointer.  only radeon only needs this so far, but intel with GEM
also needs it.

Postclose was only used for freeing said private data, so this allows me
to remove the postclose callback and rename preclose to close.
@
text
@d143 1
@


1.20
log
@change drm_attach_mi to drm_attach_pci. we take the pci_attach_args, and
setup the drm_attach_args with the needed information.

require interface version 1.1 libdrm has been requesting it for ages),
which means that we can set the busid string at attach time. (generated in
drm_attach_pci), also pass in the interrupt line and bst.

Now we don't need dev->pa at all, so remove it, finally.
@
text
@d88 1
a88 1
	.preclose		= r128_driver_preclose,
@


1.19
log
@make device works out if it's agp and tells the drm driver, not the
other way round. More dev->pa reduction
@
text
@d147 1
a147 2
	dev_priv->drmdev = drm_attach_mi(&ragedrm_driver, pa->pa_dmat, pa,
	    is_agp, self);
@


1.18
log
@oops. Use the correct struct member to map so that radeon doesn't panic
on X startup.

found by ckuethe@@
@
text
@d122 1
d144 5
a148 1
	dev_priv->drmdev = drm_attach_mi(&ragedrm_driver, pa->pa_dmat, pa, self);
@


1.17
log
@pass in the dmat when we attach the drm driver. reduces pci dependancy.
@
text
@d132 1
a132 1
	    bar->addr, bar->size, 0);
@


1.16
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d143 1
a143 1
	dev_priv->drmdev = drm_attach_mi(&ragedrm_driver, pa, self);
@


1.15
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d94 1
a94 1
	.irq_preinstall		= r128_driver_irq_preinstall,
d123 2
d135 5
@


1.14
log
@Make all drm drivers map their mmio register space on attach instead of
using the drm_maps interface (this was done for inteldrm a few days
ago).  All drivers now ignore the mmio_offset argument that the init
ioctl takes.

This clears up the code and makes sure that drm_ioremap_core() doesn't
need the vga_pci_map inteface anymore, so we don't have to pass in the
vga softc anymore. We also get to kill the drm_resource_{start,length}
linux-alike functions since we just calculate all the requisite offsets
at startup and cache those we need. This now means that technically the
only driver that needs the vga_pci_map api is inteldrm (due to sharing
with intagp issues), though this diff doesn't convert them over.
@
text
@d90 1
a94 1
	.irq_postinstall	= r128_driver_irq_postinstall,
@


1.13
log
@Move the drm drivers over from:

vga1 at pci0
inteldrm0 at vga1

to

vga1 at pci0
inteldrm0 at vga1
drm0 at inteldrm0

i.e. a similar scheme to audio(4) where the interface attaches on top of
the wildly different drivers. This helps to clean up the code a lot
(more is coming) and help me start to move drm to being essentially bus
independent, which will help in the future.
@
text
@d121 1
d123 14
a136 1
	dev_priv->drmdev = drm_attach_mi(&ragedrm_driver, pa, parent, self);
d148 3
@


1.12
log
@Remove the driver->load callback and just do all the initialization in
the attach function. First step towards splitting drm off as it's own
(bus independant) device, as it should be.
@
text
@d113 1
a113 1
	return drm_probe((struct pci_attach_args *)aux, ragedrm_pciidlist);
d119 2
a120 8
	struct pci_attach_args *pa = aux;
	struct drm_device *dev = (struct drm_device *)self;
	drm_r128_private_t *dev_priv;

	dev_priv = drm_calloc(1, sizeof(*dev_priv), DRM_MEM_DRIVER);
	if (dev_priv == NULL)
		return;
	dev->dev_private = (void *)dev_priv;
d122 1
a122 2
	dev->driver = &ragedrm_driver;
	return drm_attach(parent, self, pa);
d128 1
a128 2
	struct drm_device *dev = (struct drm_device *)self;
	drm_r128_private_t *dev_priv = dev->dev_private;
d130 4
a133 3
	drm_free(dev_priv, sizeof(*dev_priv),
		 DRM_MEM_DRIVER);
	dev->dev_private = NULL;
d135 1
a135 1
	return (drm_detach(self, flags));
d139 2
a140 2
	sizeof(struct drm_device), ragedrm_probe, ragedrm_attach,
	ragedrm_detach, drm_activate
@


1.11
log
@Remove the strings from the pcidevs arrays. they are no longer needed and are
just wasting space.
@
text
@d39 3
a41 2
int	r128drm_probe(struct device *, void *, void *);
void	r128drm_attach(struct device *, struct device *, void *);
d44 1
a44 1
static drm_pci_id_list_t r128_pciidlist[] = {
d85 1
a85 1
static const struct drm_driver_info r128_driver = {
d111 1
a111 1
r128drm_probe(struct device *parent, void *match, void *aux)
d113 1
a113 1
	return drm_probe((struct pci_attach_args *)aux, r128_pciidlist);
d117 1
a117 1
r128drm_attach(struct device *parent, struct device *self, void *aux)
d121 1
d123 20
a142 2
	dev->driver = &r128_driver;
	return drm_attach(parent, self, pa, r128_pciidlist);
d146 2
a147 2
	sizeof(struct drm_device), r128drm_probe, r128drm_attach,
	drm_detach, drm_activate
@


1.10
log
@switch all of the drm drivers over to using the defines from pcidevs.

Furthermore, move the list of pcidevs from drm_pciids.h (in macros!), to
the array in the driver file. The strings are left in the array for now, but
will go in the next commit
@
text
@d44 38
a81 38
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_LE, 0, "ATI Rage 128 Mobility LE (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_MOBILITY_M3, 0, "ATI Rage 128 Mobility LF (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_MF, 0, "ATI Rage 128 Mobility MF (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_ML, 0, "ATI Rage 128 Mobility ML (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PA, 0, "ATI Rage 128 Pro PA (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PB, 0, "ATI Rage 128 Pro PB (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PC, 0, "ATI Rage 128 Pro PC (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PD, 0, "ATI Rage 128 Pro PD (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PE, 0, "ATI Rage 128 Pro PE (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE_FURY, 0, "ATI Rage 128 Pro PF (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PG, 0, "ATI Rage 128 Pro PG (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PH, 0, "ATI Rage 128 Pro PH (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PI, 0, "ATI Rage 128 Pro PI (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PJ, 0, "ATI Rage 128 Pro PJ (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PK, 0, "ATI Rage 128 Pro PK (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PL, 0, "ATI Rage 128 Pro PL (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PM, 0, "ATI Rage 128 Pro PM (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PN, 0, "ATI Rage 128 Pro PN (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PO, 0, "ATI Rage 128 Pro PO (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PP, 0, "ATI Rage 128 Pro PP (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PQ, 0, "ATI Rage 128 Pro PQ (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PR, 0, "ATI Rage 128 Pro PR (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PS, 0, "ATI Rage 128 Pro PS (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PT, 0, "ATI Rage 128 Pro PT (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PU, 0, "ATI Rage 128 Pro PU (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PV, 0, "ATI Rage 128 Pro PV (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PW, 0, "ATI Rage 128 Pro PW (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_PX, 0, "ATI Rage 128 Pro PX (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_GL, 0, "ATI Rage 128 RE (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE_MAGNUM, 0, "ATI Rage 128 RF (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_RG, 0, "ATI Rage 128 RG (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_RK, 0, "ATI Rage 128 RK (PCI)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_VR, 0, "ATI Rage 128 RL (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_SM, 0, "ATI Rage 128 SM (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TF, 0, "ATI Rage 128 Pro Ultra TF (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TL, 0, "ATI Rage 128 Pro Ultra TL (AGP)"},
	{PCI_VENDOR_ATI, PCI_PRODUCT_ATI_RAGE128_TR, 0, "ATI Rage 128 Pro Ultra TR (AGP)"},
	{0, 0, 0, NULL}
@


1.9
log
@Instead of using a width-1 bitfield for storing the driver capabilities
in the callback structure, just use a bunch of ORed together bits. This
has been annoying me for ages.
@
text
@a37 1
#include "drm_pciids.h"
a42 1
/* drv_PCI_IDs comes from drm_pciids.h, generated from drm_pciids.txt. */
d44 38
a81 1
	r128_PCI_IDS
@


1.8
log
@rework how we handle ioctls.

Before it was based on a static array with flags. Instead, let the
driver provide an ioctl callback, which deals with things appropriately.
Makes the code a bit easier to read, and also drops just over 5k on an
amd64 kernel build with all drm drivers enabled.

Tested by a few.
@
text
@d70 2
a71 7
	.use_agp		= 1,
	.use_mtrr		= 1,
	.use_pci_dma		= 1,
	.use_sg			= 1,
	.use_dma		= 1,
	.use_irq		= 1,
	.use_vbl_irq		= 1,
@


1.7
log
@Kill a bunch of #ifdef freebsd/netbsd code in *_drv.c. No binary change.
@
text
@d40 4
a48 20
struct drm_ioctl_desc r128_ioctls[] = {
	DRM_IOCTL_DEF(DRM_R128_INIT, r128_cce_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_R128_CCE_START, r128_cce_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_R128_CCE_STOP, r128_cce_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_R128_CCE_RESET, r128_cce_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_R128_CCE_IDLE, r128_cce_idle, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_RESET, r128_engine_reset, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_FULLSCREEN, r128_fullscreen, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_SWAP, r128_cce_swap, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_FLIP, r128_cce_flip, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_CLEAR, r128_cce_clear, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_VERTEX, r128_cce_vertex, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_INDICES, r128_cce_indices, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_BLIT, r128_cce_blit, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_DEPTH, r128_cce_depth, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_STIPPLE, r128_cce_stipple, DRM_AUTH),
	DRM_IOCTL_DEF(DRM_R128_INDIRECT, r128_cce_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
	DRM_IOCTL_DEF(DRM_R128_GETPARAM, r128_getparam, DRM_AUTH),
};

d51 1
a62 3
	.ioctls			= r128_ioctls,
	.max_ioctl		= DRM_ARRAY_SIZE(r128_ioctls),

a78 3
int	r128drm_probe(struct device *, void *, void *);
void	r128drm_attach(struct device *, struct device *, void *);

d103 50
@


1.6
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@a96 42
#ifdef __FreeBSD__
static int
r128_probe(device_t dev)
{
	return drm_probe(dev, r128_pciidlist);
}

static int
r128_attach(device_t nbdev)
{
	struct drm_device *dev = device_get_softc(nbdev);

	bzero(dev, sizeof(struct drm_device));
	r128_configure(dev);
	return drm_attach(nbdev, r128_pciidlist);
}

static device_method_t r128_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		r128_probe),
	DEVMETHOD(device_attach,	r128_attach),
	DEVMETHOD(device_detach,	drm_detach),

	{ 0, 0 }
};

static driver_t r128_driver = {
	"drm",
	r128_methods,
	sizeof(struct drm_device)
};

extern devclass_t drm_devclass;
#if __FreeBSD_version >= 700010
DRIVER_MODULE(r128, vgapci, r128_driver, drm_devclass, 0, 0);
#else
DRIVER_MODULE(r128, pci, r128_driver, drm_devclass, 0, 0);
#endif
MODULE_DEPEND(r128, drm, 1, 1, 1);

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a100 1
#if defined(__OpenBSD__)
a101 3
#else
r128drm_probe(struct device *parent, struct cfdata *match, void *aux)
#endif
a115 1
#if defined(__OpenBSD__)
a123 10
#else
#ifdef _LKM
CFDRIVER_DECL(r128drm, DV_TTY, NULL);
#else
CFATTACH_DECL(r128drm, sizeof(struct drm_device), r128drm_probe, r128drm_attach,
	drm_detach, drm_activate);
#endif
#endif

#endif
@


1.5
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@a39 2
void r128_configure(struct drm_device *);

d45 51
a95 33
void
r128_configure(struct drm_device *dev)
{
	dev->driver.buf_priv_size	= sizeof(drm_r128_buf_priv_t);
	dev->driver.preclose		= r128_driver_preclose;
	dev->driver.lastclose		= r128_driver_lastclose;
	dev->driver.get_vblank_counter	= r128_get_vblank_counter;
	dev->driver.enable_vblank 	= r128_enable_vblank;
	dev->driver.disable_vblank	= r128_disable_vblank;
	dev->driver.irq_preinstall	= r128_driver_irq_preinstall;
	dev->driver.irq_postinstall	= r128_driver_irq_postinstall;
	dev->driver.irq_uninstall	= r128_driver_irq_uninstall;
	dev->driver.irq_handler		= r128_driver_irq_handler;
	dev->driver.dma_ioctl		= r128_cce_buffers;

	dev->driver.ioctls		= r128_ioctls;
	dev->driver.max_ioctl		= r128_max_ioctl;

	dev->driver.name		= DRIVER_NAME;
	dev->driver.desc		= DRIVER_DESC;
	dev->driver.date		= DRIVER_DATE;
	dev->driver.major		= DRIVER_MAJOR;
	dev->driver.minor		= DRIVER_MINOR;
	dev->driver.patchlevel		= DRIVER_PATCHLEVEL;

	dev->driver.use_agp		= 1;
	dev->driver.use_mtrr		= 1;
	dev->driver.use_pci_dma		= 1;
	dev->driver.use_sg		= 1;
	dev->driver.use_dma		= 1;
	dev->driver.use_irq		= 1;
	dev->driver.use_vbl_irq		= 1;
}
d158 1
a158 1
	r128_configure(dev);
@


1.4
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d40 1
a40 1
void r128_configure(drm_device_t *);
d48 1
a48 1
r128_configure(drm_device_t *dev)
d91 1
a91 1
	drm_device_t *dev = device_get_softc(nbdev);
d93 1
a93 1
	bzero(dev, sizeof(drm_device_t));
d110 1
a110 1
	sizeof(drm_device_t)
d140 1
a140 1
	drm_device_t *dev = (drm_device_t *)self;
d148 1
a148 1
	sizeof(drm_device_t), r128drm_probe, r128drm_attach,
d159 1
a159 1
CFATTACH_DECL(r128drm, sizeof(drm_device_t), r128drm_probe, r128drm_attach,
@


1.3
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@d53 3
a55 1
	dev->driver.vblank_wait		= r128_driver_vblank_wait;
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d141 1
a141 1
	return drm_attach(self, pa, r128_pciidlist);
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d40 2
d47 2
a48 1
static void r128_configure(drm_device_t *dev)
d121 4
a124 1
static int
d134 1
a134 1
static void
@

