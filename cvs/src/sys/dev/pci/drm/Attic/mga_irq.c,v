head	1.15;
access;
symbols
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2010.05.24.01.19.19;	author oga;	state dead;
branches;
next	1.14;

1.14
date	2010.04.15.19.17.48;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.03.14.01.40;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.03.13.56.23;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.03.13.51.45;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.03.13.47.04;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.04.03.12.41.20;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.03.11.31.36;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.24.12.22.55;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.23.21.35.01;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.23.20.46.48;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.22.22.54.48;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove the drm drivers that are not enabled (and have never been so).

For now they are unmaintained, and work on kernel modesetting has very
large inferface changes needing to be made. Also, when the radeon driver
has been converted over, we will no longer support X with the DRI1
protocol, only DRI2.

When the upheaval has finished, these drivers may be brought back after
work to switch them to DRI2 style memory management and kernel
modesetting has been done, but until then they are unsupported and
probably broken (i know at least two of them have been reported broken
before now). ragedrm will likely come back as a component of radeon
(their interfaces are still fairly similar). The other drivers require
rewriting.

I have been threatening to do this for over a year. Discussed with
deraadt@@ and matthieu@@ at various points since then.
@
text
@/* mga_irq.c -- IRQ handling for radeon -*- linux-c -*-
 */
/*
 * Copyright (C) The Weather Channel, Inc.  2002.  All Rights Reserved.
 *
 * The Weather Channel (TM) funded Tungsten Graphics to develop the
 * initial release of the Radeon 8500 driver under the XFree86 license.
 * This notice must be preserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Whitwell <keith@@tungstengraphics.com>
 *    Eric Anholt <anholt@@FreeBSD.org>
 */

#include "drmP.h"
#include "drm.h"
#include "mga_drm.h"
#include "mga_drv.h"

int	mgadrm_intr(void *);

u_int32_t
mga_get_vblank_counter(struct drm_device *dev, int crtc)
{
	const drm_mga_private_t *const	dev_priv = dev->dev_private;

	if (crtc != 0) {
		return (0);
	}

	return (atomic_read(&dev_priv->vbl_received));
}


int
mgadrm_intr(void *arg)
{
	struct drm_device	*dev =  arg;
	drm_mga_private_t	*dev_priv = dev->dev_private;
	int			 status, handled = 0;

	status = MGA_READ(MGA_STATUS);

	/* VBLANK interrupt */
	if (status & MGA_VLINEPEN) {
		MGA_WRITE(MGA_ICLEAR, MGA_VLINEICLR);
		atomic_inc(&dev_priv->vbl_received);
		drm_handle_vblank(dev, 0);
		handled = 1;
	}

	/* SOFTRAP interrupt */
	if (status & MGA_SOFTRAPEN) {
		const u_int32_t prim_start = MGA_READ(MGA_PRIMADDRESS);
		const u_int32_t prim_end = MGA_READ(MGA_PRIMEND);


		MGA_WRITE(MGA_ICLEAR, MGA_SOFTRAPICLR);

		/* In addition to clearing the interrupt-pending bit, we
		 * have to write to MGA_PRIMEND to re-start the DMA operation.
		 */
		if ((prim_start & ~0x03) != (prim_end & ~0x03)) {
			MGA_WRITE(MGA_PRIMEND, prim_end);
		}

		mtx_enter(&dev_priv->fence_lock);
		dev_priv->last_fence_retired++;
		wakeup(dev_priv);
		mtx_leave(&dev_priv->fence_lock);
		handled = 1;
	}

	return (handled);
}

int
mga_enable_vblank(struct drm_device *dev, int crtc)
{
	drm_mga_private_t *dev_priv = dev->dev_private;

	if (crtc != 0) {
		DRM_ERROR("tried to enable vblank on non-existent crtc %d\n",
			  crtc);
		return (0);
	}

	MGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN);
	return (0);
}


void
mga_disable_vblank(struct drm_device *dev, int crtc)
{
	if (crtc != 0) {
		DRM_ERROR("tried to disable vblank on non-existent crtc %d\n",
			  crtc);
	}

	/* Do *NOT* disable the vertical refresh interrupt.  MGA doesn't have
	 * a nice hardware counter that tracks the number of refreshes when
	 * the interrupt is disabled, and the kernel doesn't know the refresh
	 * rate to calculate an estimate.
	 */
	/* MGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN); */
}

int
mga_driver_fence_wait(struct drm_device * dev, u_int32_t *sequence)
{
	drm_mga_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 cur_fence;
	int			 ret = 0;

	/* Assume that the user has missed the current sequence number
	 * by about a day rather than she wants to wait for years
	 * using fences.
	 */
	DRM_WAIT_ON(ret, dev_priv, &dev_priv->fence_lock, 3 * hz, "mgawt",
	    (((cur_fence = dev_priv->last_fence_retired) -
	    *sequence) <= (1 << 23)));

	*sequence = cur_fence;

	return (ret);
}

int
mga_driver_irq_install(struct drm_device * dev)
{
	drm_mga_private_t	*dev_priv = dev->dev_private;

	/* Disable *all* interrupts */
	MGA_WRITE(MGA_IEN, 0);
	/* Clear bits if they're already high */
	MGA_WRITE(MGA_ICLEAR, ~0);

	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_TTY,
	    mgadrm_intr, dev, dev_priv->dev.dv_xname);
	if (dev_priv->irqh == NULL)
		return (ENOENT);

	/* Turn on soft trap interrupt.  Vertical blank interrupts are enabled
	 * in mga_enable_vblank.
	 */
	MGA_WRITE(MGA_IEN, MGA_SOFTRAPEN);
	return 0;
}

void
mga_driver_irq_uninstall(struct drm_device * dev)
{
	drm_mga_private_t *dev_priv = dev->dev_private;

	/* Disable *all* interrupts */
	MGA_WRITE(MGA_IEN, 0);

	pci_intr_disestablish(dev_priv->pc, dev_priv->irqh);
}
@


1.14
log
@Use IPL_TTY instead of IPB_BIO as suggested by oga.

Tested by me and mlarkin on amd64 and i386
ok oga
@
text
@@


1.13
log
@${XORGNAME}_driver_irq_handler() is a stupid name for an interrupt
handler anyway. replace it with ${OpenBSD_driver_name}_intr like most of
the rest of the tree. No functional change.
@
text
@d158 1
a158 1
	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_BIO,
@


1.12
log
@More compat crud bites the dust: Remove the IRQ_NONE and IRQ_HANDLED
defines. 0 and 1 are fine for returning from irq handlers so why bother
with the indirection?
@
text
@d39 1
a39 1
int	mga_driver_irq_handler(void *);
d55 1
a55 1
mga_driver_irq_handler(void *arg)
d159 1
a159 1
	    mga_driver_irq_handler, dev, dev_priv->dev.dv_xname);
@


1.11
log
@kill the stupid DRM_IRQ_ARGS macros and irqreturn_t typedef, switch to
the unmacroed/typedefed version.
@
text
@d93 1
a93 3
	if (handled)
		return (IRQ_HANDLED);
	return (IRQ_NONE);
@


1.10
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d39 1
a39 1
irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS);
d54 2
a55 2
irqreturn_t
mga_driver_irq_handler(DRM_IRQ_ARGS)
@


1.9
log
@Same as just done for radeon. Add and use a lock for procecting against
races when waiting on fences, and use that in preference to irq_lock.
Don't use drm_irq_handler_wrap() anymore for irq handler, just the
mgadrm main irq handler. knf while here.
@
text
@d39 2
@


1.8
log
@Convert DRM_WAIT_ON to take additional parameters, the wmsg for msleep,
and the lock to manipulate.

first step of removing drm_irq_handler_wrap which just grabs the
irq_lock, and eventually irq_lock. drivers should manage their own.
@
text
@a47 1

d71 2
a72 2
		const u32 prim_start = MGA_READ(MGA_PRIMADDRESS);
		const u32 prim_end = MGA_READ(MGA_PRIMEND);
d84 2
a85 1
		atomic_inc(&dev_priv->last_fence_retired);
d87 1
d96 2
a97 1
int mga_enable_vblank(struct drm_device *dev, int crtc)
d99 1
a99 1
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
d104 1
a104 1
		return 0;
d108 1
a108 1
	return 0;
d112 2
a113 1
void mga_disable_vblank(struct drm_device *dev, int crtc)
d128 2
a129 1
int mga_driver_fence_wait(struct drm_device * dev, unsigned int *sequence)
d131 3
a133 3
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
	unsigned int cur_fence;
	int ret = 0;
d139 2
a140 2
	DRM_WAIT_ON(ret, dev_priv, &dev->irq_lock, 3 * hz, "mgawt",
	    (((cur_fence = atomic_read(&dev_priv->last_fence_retired)) -
d145 1
a145 1
	return ret;
d151 1
a151 1
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
d159 1
a159 1
	    drm_irq_handler_wrap, dev, dev_priv->dev.dv_xname);
d173 1
a173 1
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
@


1.7
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@d39 2
a40 1
u32 mga_get_vblank_counter(struct drm_device *dev, int crtc)
d42 1
a42 2
	const drm_mga_private_t *const dev_priv = 
		(drm_mga_private_t *) dev->dev_private;
d45 1
a45 1
		return 0;
d49 1
a49 1
	return atomic_read(&dev_priv->vbl_received);
d53 2
a54 1
irqreturn_t mga_driver_irq_handler(DRM_IRQ_ARGS)
d56 3
a58 4
	struct drm_device *dev = (struct drm_device *) arg;
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
	int status;
	int handled = 0;
d91 2
a92 2
		return IRQ_HANDLED;
	return IRQ_NONE;
d135 3
a137 3
	DRM_WAIT_ON(ret, dev_priv, 3 * DRM_HZ,
		    (((cur_fence = atomic_read(&dev_priv->last_fence_retired))
		      - *sequence) <= (1 << 23)));
@


1.6
log
@Fixup wakeup pointers. interrupts work properly again.
@
text
@d86 1
a86 1
		DRM_WAKEUP(dev_priv);
@


1.5
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d86 1
a86 1
		DRM_WAKEUP(&dev_priv);
@


1.4
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d144 2
a145 1
void mga_driver_irq_preinstall(struct drm_device * dev)
a152 1
}
d154 4
a157 3
int mga_driver_irq_postinstall(struct drm_device * dev)
{
	drm_mga_private_t *dev_priv = (drm_mga_private_t *) dev->dev_private;
d166 2
a167 1
void mga_driver_irq_uninstall(struct drm_device * dev)
a169 2
	if (!dev_priv)
		return;
d174 1
a174 1
	dev->irq_enabled = 0;
@


1.3
log
@using ``wait queues' for sleep is a linuxism. Kill them and just sleep
on the softc.
@
text
@a156 5
	int ret;

	ret = drm_vblank_init(dev, 1);
	if (ret)
		return ret;
@


1.2
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d86 1
a86 1
		DRM_WAKEUP(&dev_priv->fence_queue);
d135 1
a135 1
	DRM_WAIT_ON(ret, dev_priv->fence_queue, 3 * DRM_HZ,
a161 2

	DRM_INIT_WAITQUEUE(&dev_priv->fence_queue);
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d39 14
d65 2
a66 3
		atomic_inc(&dev->vbl_received);
		DRM_WAKEUP(&dev->vbl_queue);
		drm_vbl_send_signals(dev);
d73 1
a73 1
		const u32 prim_end   = MGA_READ(MGA_PRIMEND);
d81 1
a81 1
		if ( (prim_start & ~0x03) != (prim_end & ~0x03) ) {
d90 1
a90 1
	if ( handled ) {
a91 1
	}
d95 1
a95 1
int mga_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
d97 11
a107 2
	unsigned int cur_vblank;
	int ret = 0;
a108 7
	/* Assume that the user has missed the current sequence number
	 * by about a day rather than she wants to wait for years
	 * using vertical blanks...
	 */
	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
		    (((cur_vblank = atomic_read(&dev->vbl_received))
		      - *sequence) <= (1 << 23)));
d110 6
a115 1
	*sequence = cur_vblank;
d117 6
a122 1
	return ret;
d154 1
a154 1
void mga_driver_irq_postinstall(struct drm_device * dev)
d157 1
d159 3
a161 1
	DRM_INIT_WAITQUEUE( &dev_priv->fence_queue );
d163 7
a169 2
	/* Turn on vertical blank interrupt and soft trap interrupt. */
	MGA_WRITE(MGA_IEN, MGA_VLINEIEN | MGA_SOFTRAPEN);
@

