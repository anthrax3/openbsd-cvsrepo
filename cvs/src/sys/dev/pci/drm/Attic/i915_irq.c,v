head	1.55;
access;
symbols
	OPENBSD_5_3:1.54.0.2
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.53.0.2
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.1.0.2
	OPENBSD_4_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.55
date	2013.03.18.12.36.51;	author jsg;	state dead;
branches;
next	1.54;

1.54
date	2012.09.25.10.19.46;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2012.05.19.18.02.53;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2011.09.14.10.26.16;	author oga;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.24.14.34.41;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.12.15.13.44;	author marco;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.30.09.22.07;	author oga;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.25.17.27.13;	author oga;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.25.17.15.49;	author oga;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.10.22.28.17;	author oga;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.08.11.45.54;	author oga;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.23.18.51.12;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.23.18.49.05;	author oga;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.23.18.25.28;	author oga;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.08.23.29.40;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.12.20.42.09;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.19.19.15.48;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.14.21.10.54;	author jj;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.06.10.52.36;	author oga;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.05.04.15.37;	author oga;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.03.14.01.40;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.03.13.56.23;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.03.13.51.45;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.04.03.13.47.03;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.04.03.13.38.53;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2009.04.03.11.34.49;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2009.04.03.11.31.36;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.05.23.13.19;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.09.10.54.16;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.09.06.09.41;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.24.12.22.55;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.23.21.35.01;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.23.20.46.47;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.22.22.54.48;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.22.05.03.26;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.17.00.58.30;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.17.00.51.45;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.17.00.43.13;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.06.14.08.03;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.04.00.38.14;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.04.00.22.12;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.04.00.00.23;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.31.19.48.57;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.30.21.33.00;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.10.07.22.25.12;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.05.20.17.11;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.01.17.37.05;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.28.01.34.18;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.07.29.22.23.50;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.03.18.27.51;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.11.09.33.01;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2008.05.27.19.39.52;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@/* $OpenBSD: i915_irq.c,v 1.54 2012/09/25 10:19:46 jsg Exp $ */
/* i915_irq.c -- IRQ support for the I915 -*- linux-c -*-
 */
/*
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "drmP.h"
#include "drm.h"
#include "i915_drm.h"
#include "i915_drv.h"

void	i915_enable_irq(struct inteldrm_softc *, u_int32_t);
void	i915_disable_irq(struct inteldrm_softc *, u_int32_t);
void	ironlake_enable_graphics_irq(struct inteldrm_softc *, u_int32_t);
void	ironlake_disable_graphics_irq(struct inteldrm_softc *, u_int32_t);
void	ironlake_enable_display_irq(struct inteldrm_softc *, u_int32_t);
void	ironlake_disable_display_irq(struct inteldrm_softc *, u_int32_t);
void	i915_enable_pipestat(struct inteldrm_softc *, int, u_int32_t);
void	i915_disable_pipestat(struct inteldrm_softc *, int, u_int32_t);
int	ironlake_irq_install(struct inteldrm_softc *);

void
i915_enable_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->irq_mask_reg & mask) != 0) {
		dev_priv->irq_mask_reg &= ~mask;
		I915_WRITE(IMR, dev_priv->irq_mask_reg);
		(void)I915_READ(IMR);
	}
}

void
i915_disable_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->irq_mask_reg & mask) != mask) {
		dev_priv->irq_mask_reg |= mask;
		I915_WRITE(IMR, dev_priv->irq_mask_reg);
		(void)I915_READ(IMR);
	}
}

inline void
ironlake_enable_graphics_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->gt_irq_mask_reg & mask) != 0) {
		/* XXX imr bullshit */
		dev_priv->gt_irq_mask_reg &= ~mask;
		if (IS_GEN6(dev_priv) || IS_GEN7(dev_priv)) {
			I915_WRITE(0x20a8, dev_priv->gt_irq_mask_reg);
			(void)I915_READ(0x20a8);
		} else {
			I915_WRITE(GTIMR, dev_priv->gt_irq_mask_reg);
			(void)I915_READ(GTIMR);
		}
	}
}

inline void
ironlake_disable_graphics_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->gt_irq_mask_reg & mask) != mask) {
		dev_priv->gt_irq_mask_reg |= mask;
		if (IS_GEN6(dev_priv) || IS_GEN7(dev_priv)) {
			I915_WRITE(0x20a8, dev_priv->gt_irq_mask_reg);
			(void)I915_READ(0x20a8);
		} else {
			I915_WRITE(GTIMR, dev_priv->gt_irq_mask_reg);
			(void)I915_READ(GTIMR);
		}
	}
}

/* display hotplug and vblank irqs */
inline void
ironlake_enable_display_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->irq_mask_reg & mask) != 0) {
		dev_priv->irq_mask_reg &= ~mask;
		I915_WRITE(DEIMR, dev_priv->irq_mask_reg);
		(void)I915_READ(DEIMR);
	}
}

inline void
ironlake_disable_display_irq(struct inteldrm_softc *dev_priv, u_int32_t mask)
{
	if ((dev_priv->irq_mask_reg & mask) != mask) {
		dev_priv->irq_mask_reg |= mask;
		I915_WRITE(DEIMR, dev_priv->irq_mask_reg);
		(void)I915_READ(DEIMR);
	}
}

void
i915_enable_pipestat(struct inteldrm_softc *dev_priv, int pipe, u_int32_t mask)
{
	if ((dev_priv->pipestat[pipe] & mask) != mask) {
		bus_size_t reg = pipe == 0 ? _PIPEASTAT : _PIPEBSTAT;

		dev_priv->pipestat[pipe] |= mask;
		/* Enable the interrupt, clear and pending status */
		I915_WRITE(reg, dev_priv->pipestat[pipe] | (mask >> 16));
		(void)I915_READ(reg);
	}
}

void
i915_disable_pipestat(struct inteldrm_softc *dev_priv, int pipe, u_int32_t mask)
{
	if ((dev_priv->pipestat[pipe] & mask) != 0) {
		bus_size_t reg = pipe == 0 ? _PIPEASTAT : _PIPEBSTAT;

		dev_priv->pipestat[pipe] &= ~mask;
		I915_WRITE(reg, dev_priv->pipestat[pipe]);
		(void)I915_READ(reg);
	}
}

/**
 * inteldrm_pipe_enabled - check if a pipe is enabled
 * @@dev: DRM device
 * @@pipe: pipe to check
 *
 * Reading certain registers when the pipe is disabled can hang the chip.
 * Use this routine to make sure the PLL is running and the pipe is active
 * before reading such registers if unsure.
 */
int
inteldrm_pipe_enabled(struct inteldrm_softc *dev_priv, int pipe)
{
	return I915_READ(PIPECONF(pipe)) & PIPECONF_ENABLE;
}

u_int32_t
i915_get_vblank_counter(struct drm_device *dev, int pipe)
{
	struct inteldrm_softc	*dev_priv = dev->dev_private;
	bus_size_t		 high_frame, low_frame;
	u_int32_t		 high1, high2, low;

	if (inteldrm_pipe_enabled(dev_priv, pipe) == 0) {
		DRM_DEBUG("trying to get vblank count for disabled pipe %d\n",
		    pipe);
		return (0);
	}

	high_frame = PIPEFRAME(pipe);
	low_frame = PIPEFRAMEPIXEL(pipe);

	/* GM45 just had to be different... */
	if (IS_GM45(dev_priv) || IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv) ||
	    IS_GEN6(dev_priv) || IS_GEN7(dev_priv)) {
		return (I915_READ(PIPE_FRMCOUNT_GM45(pipe)));
	}

	/*
	 * High & low register fields aren't synchronized, so make sure
	 * we get a low value that's stable across two reads of the high
	 * register.
	 */
	do {
		high1 = ((I915_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>
			 PIPE_FRAME_HIGH_SHIFT);
		low =  ((I915_READ(low_frame) & PIPE_FRAME_LOW_MASK) >>
			PIPE_FRAME_LOW_SHIFT);
		high2 = ((I915_READ(high_frame) & PIPE_FRAME_HIGH_MASK) >>
			 PIPE_FRAME_HIGH_SHIFT);
	} while (high1 != high2);

	return ((high1 << 8) | low);
}

void
i915_user_irq_get(struct inteldrm_softc *dev_priv)
{
	if (++dev_priv->user_irq_refcount == 1) {
		if (HAS_PCH_SPLIT(dev_priv))
			ironlake_enable_graphics_irq(dev_priv,
			    GT_USER_INTERRUPT);
		else
			i915_enable_irq(dev_priv, I915_USER_INTERRUPT);
	}
}

void
i915_user_irq_put(struct inteldrm_softc *dev_priv)
{
	if (--dev_priv->user_irq_refcount == 0) {
		if (HAS_PCH_SPLIT(dev_priv))
			ironlake_disable_graphics_irq(dev_priv,
			    GT_USER_INTERRUPT);
		else
			i915_disable_irq(dev_priv, I915_USER_INTERRUPT);
	}
}

int
i915_enable_vblank(struct drm_device *dev, int pipe)
{
	struct inteldrm_softc	*dev_priv = dev->dev_private;

	if (inteldrm_pipe_enabled(dev_priv, pipe) == 0)
		return (EINVAL);

	mtx_enter(&dev_priv->user_irq_lock);
	if (IS_GEN7(dev_priv))
		ironlake_enable_display_irq(dev_priv,
		    DE_PIPEA_VBLANK_IVB << (5 * pipe));
	else if (HAS_PCH_SPLIT(dev_priv))
		ironlake_enable_display_irq(dev_priv, (pipe == 0) ?
		    DE_PIPEA_VBLANK : DE_PIPEB_VBLANK);
	else
		i915_enable_pipestat(dev_priv, pipe, (IS_I965G(dev_priv) ?
		    PIPE_START_VBLANK_INTERRUPT_ENABLE :
		    PIPE_VBLANK_INTERRUPT_ENABLE));
	mtx_leave(&dev_priv->user_irq_lock);

	return (0);
}

void
i915_disable_vblank(struct drm_device *dev, int pipe)
{
	struct inteldrm_softc	*dev_priv = dev->dev_private;

	mtx_enter(&dev_priv->user_irq_lock);
	if (IS_GEN7(dev_priv))
		ironlake_disable_display_irq(dev_priv,
		    DE_PIPEA_VBLANK_IVB << (pipe * 5));
	else if (HAS_PCH_SPLIT(dev_priv))
		ironlake_disable_display_irq(dev_priv, (pipe == 0) ?
		    DE_PIPEA_VBLANK : DE_PIPEB_VBLANK);
	else
		i915_disable_pipestat(dev_priv, pipe,
		    PIPE_START_VBLANK_INTERRUPT_ENABLE |
		    PIPE_VBLANK_INTERRUPT_ENABLE);
	mtx_leave(&dev_priv->user_irq_lock);
}

/* drm_dma.h hooks
*/
int
i915_driver_irq_install(struct drm_device *dev)
{
	struct inteldrm_softc	*dev_priv = dev->dev_private;

	dev->vblank->vb_max = 0xffffff; /* only 24 bits of frame count */
	if (IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv) || IS_GEN6(dev_priv) ||
	    IS_GEN7(dev_priv))
		dev->vblank->vb_max = 0xffffffff;

	I915_WRITE(HWSTAM, 0xeffe);

	if (HAS_PCH_SPLIT(dev_priv))
		return (ironlake_irq_install(dev_priv));

	I915_WRITE(_PIPEASTAT, 0);
	I915_WRITE(_PIPEBSTAT, 0);
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);
	(void)I915_READ(IER);


	/*
	 * Enable some error detection, note the instruction error mask
	 * bit is reserved, so we leave it masked.
	 */
	I915_WRITE(EMR, IS_G4X(dev_priv) ?
	    ~(GM45_ERROR_PAGE_TABLE | GM45_ERROR_MEM_PRIV |
	    GM45_ERROR_CP_PRIV | I915_ERROR_MEMORY_REFRESH) :
	    ~(I915_ERROR_PAGE_TABLE | I915_ERROR_MEMORY_REFRESH));

	/*
	 * Disable pipe interrupt enables, clear pending pipe status
	 * add back in the enabled interrupts from previous iterations
	 * (say in the reset case where we want vblank interrupts etc to be
	 * switched back on if they were running
	 */
	I915_WRITE(_PIPEASTAT, (I915_READ(_PIPEASTAT) & 0x8000ffff) |
	    dev_priv->pipestat[0]);
	I915_WRITE(_PIPEBSTAT, (I915_READ(_PIPEBSTAT) & 0x8000ffff) |
	    dev_priv->pipestat[1]);
	/* Clear pending interrupt status */
	I915_WRITE(IIR, I915_READ(IIR));

	I915_WRITE(IER, I915_INTERRUPT_ENABLE_MASK);
	I915_WRITE(IMR, dev_priv->irq_mask_reg);
	(void)I915_READ(IER);

	return (0);
}

int
ironlake_irq_install(struct inteldrm_softc *dev_priv)
{
	/* mask and ack everything before we turn anything on. */
	/*
	 * XXX this is a legacy of the only preinstall/postinstall split.
	 * I wonder if we could avoid this now...
	 */
	I915_WRITE(DEIMR, 0xffffffff);
	I915_WRITE(DEIER, 0x0);
	(void)I915_READ(DEIER);

	/* GT */
	I915_WRITE(GTIMR, 0xfffffff);
	I915_WRITE(GTIER, 0x0);
	(void)I915_READ(GTIER);

	/*
	 * Everything is turned off now and everything acked.
	 * now we can set everything up
	 */

	I915_WRITE(DEIIR, I915_READ(DEIIR));
	I915_WRITE(DEIMR, dev_priv->irq_mask_reg);
	I915_WRITE(DEIER, PCH_SPLIT_DISPLAY_ENABLE_MASK);

	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask_reg);
	I915_WRITE(GTIER, PCH_SPLIT_RENDER_ENABLE_MASK);

	/* south display irq -- hotplug off for now */
	I915_WRITE(SDEIIR, I915_READ(SDEIIR));
	I915_WRITE(SDEIMR, dev_priv->pch_irq_mask_reg);
	I915_WRITE(SDEIER, PCH_SPLIT_HOTPLUG_ENABLE_MASK);
	(void)I915_READ(SDEIER);

	return (0);
}

void
i915_driver_irq_uninstall(struct drm_device *dev)
{
	struct inteldrm_softc	*dev_priv = dev->dev_private;

	I915_WRITE(HWSTAM, 0xffffffff);

	if (HAS_PCH_SPLIT(dev_priv)) {
		I915_WRITE(DEIMR, 0xffffffff);
		I915_WRITE(DEIER, 0x0);
		I915_WRITE(DEIIR, I915_READ(DEIIR));

		I915_WRITE(GTIMR, 0xfffffff);
		I915_WRITE(GTIER, 0x0);
		I915_WRITE(GTIIR, I915_READ(GTIIR));
	} else {
		I915_WRITE(_PIPEASTAT, 0);
		I915_WRITE(_PIPEBSTAT, 0);
		I915_WRITE(IMR, 0xffffffff);
		I915_WRITE(IER, 0x0);

		I915_WRITE(_PIPEASTAT, I915_READ(_PIPEASTAT) & 0x8000ffff);
		I915_WRITE(_PIPEBSTAT, I915_READ(_PIPEBSTAT) & 0x8000ffff);
		I915_WRITE(IIR, I915_READ(IIR));
	}
}
@


1.54
log
@Add minimal support for gen7/ivy bridge in inteldrm.
Like gen6/sandy bridge this is enough to manage memory but
does not attempt to setup the rings.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: i915_irq.c,v 1.53 2012/05/19 18:02:53 kettenis Exp $ */
@


1.53
log
@Split out the suspend/resume code into its own file to make it possible to
diff it against the Linux kernel sources.  Fix a few bugs revealed by doing
such a diff.  Tested by myself and a few others on 915, 945, 965 and
6-series.
@
text
@d1 1
a1 1
/* $OpenBSD: i915_irq.c,v 1.52 2011/09/14 10:26:16 oga Exp $ */
d71 1
a71 1
		if (IS_GEN6(dev_priv)) {
d86 1
a86 1
		if (IS_GEN6(dev_priv)) {
d175 1
a175 1
	IS_GEN6(dev_priv)) {
d229 4
a232 1
	if (HAS_PCH_SPLIT(dev_priv))
d250 4
a253 1
	if (HAS_PCH_SPLIT(dev_priv))
d271 2
a272 1
	if (IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv) || IS_GEN6(dev_priv))
@


1.52
log
@Initial kernel support for sandybridge intel chipsets in intagp and inteldrm.

Far from perfect. Extra (almost essential) features like the extra
ringbuffers are not yet supported (I have half a diff), but this and the
appropriate ddx patches allow modesetting and basic shadow acceleration.

Initial work by jcs@@, a few cleanups and bugfixes by me.

Tested by many on all appropriate chipsets. ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: i915_irq.c,v 1.51 2011/06/02 18:22:00 weerd Exp $ */
d121 1
a121 1
		bus_size_t reg = pipe == 0 ? PIPEASTAT : PIPEBSTAT;
d134 1
a134 1
		bus_size_t reg = pipe == 0 ? PIPEASTAT : PIPEBSTAT;
d142 15
a163 3
	high_frame = pipe ? PIPEBFRAMEHIGH : PIPEAFRAMEHIGH;
	low_frame = pipe ? PIPEBFRAMEPIXEL : PIPEAFRAMEPIXEL;

d170 3
d176 1
a176 2
		return (I915_READ(pipe ? PIPEB_FRMCOUNT_GM45 :
		    PIPEA_FRMCOUNT_GM45));
d273 2
a274 2
	I915_WRITE(PIPEASTAT, 0);
	I915_WRITE(PIPEBSTAT, 0);
d295 1
a295 1
	I915_WRITE(PIPEASTAT, (I915_READ(PIPEASTAT) & 0x8000ffff) |
d297 1
a297 1
	I915_WRITE(PIPEBSTAT, (I915_READ(PIPEBSTAT) & 0x8000ffff) |
d364 2
a365 2
		I915_WRITE(PIPEASTAT, 0);
		I915_WRITE(PIPEBSTAT, 0);
d369 2
a370 2
		I915_WRITE(PIPEASTAT, I915_READ(PIPEASTAT) & 0x8000ffff);
		I915_WRITE(PIPEBSTAT, I915_READ(PIPEBSTAT) & 0x8000ffff);
@


1.51
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d69 1
d71 7
a77 2
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask_reg);
		(void)I915_READ(GTIMR);
d86 7
a92 2
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask_reg);
		(void)I915_READ(GTIMR);
d159 2
a160 1
	if (IS_GM45(dev_priv) || IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv)) {
d251 1
a251 1
	if (IS_G4X(dev_priv) || IS_IRONLAKE(dev_priv))
@


1.50
log
@do not need that proto
@
text
@d1 1
@


1.49
log
@Fix a ton of space and tab violations.  No binary change.

ok oga
@
text
@a33 1
int	inteldrm_intr(void *);
@


1.48
log
@Add mostly working support for ironlake (integrated graphics on core i5 and i3
cpus) to inteldrm.

This mostly works, but the suspend/resume handler doesn't put the
registers back 100% (this is being worked on) and with the X driver code
that is in snapshots (and soon to be on tech) we don't do vt switch in a
100% sane way. Similarly there are some vblank issues that aren't solved
yet, but for most usage this works with the correct Xorg DDX.


tested on two x201's, a t510 and a t410 all work given the correct
userland.  Suspend works once (due to crazy crap done in the ddx) but
doesn't come back the second time and text vts are screwed post suspend.
this will be fixed shortly when a non-sucky solution has been found. for now,
this allows non-vesa X on ironlake graphics and makes us the only accelerated
but non-kms OS that works on ironlake.
@
text
@d206 2
a207 2
	else 
		i915_enable_pipestat(dev_priv, pipe, (IS_I965G(dev_priv) ? 
d225 1
a225 1
		i915_disable_pipestat(dev_priv, pipe, 
d258 1
a258 1
	I915_WRITE(EMR, IS_G4X(dev_priv) ? 
d304 1
a304 1
	
@


1.47
log
@rename struct drm_i915_private to struct inteldrm_softc, to be more in
line with everything in the tree. No functional change.

I have wanted to do this for ages! More cleanup will be forthcoming.
@
text
@d37 4
d43 1
d65 41
d148 1
a148 1
	if (IS_GM45(dev_priv) || IS_G4X(dev_priv)) {
d173 7
a179 2
	if (++dev_priv->user_irq_refcount == 1)
		i915_enable_irq(dev_priv, I915_USER_INTERRUPT);
d185 7
a191 2
	if (--dev_priv->user_irq_refcount == 0)
		i915_disable_irq(dev_priv, I915_USER_INTERRUPT);
d203 7
a209 2
	i915_enable_pipestat(dev_priv, pipe, (IS_I965G(dev_priv) ? 
	    PIPE_START_VBLANK_INTERRUPT_ENABLE : PIPE_VBLANK_INTERRUPT_ENABLE));
d221 7
a227 2
	i915_disable_pipestat(dev_priv, pipe, 
	    PIPE_START_VBLANK_INTERRUPT_ENABLE | PIPE_VBLANK_INTERRUPT_ENABLE);
d238 4
d243 4
a252 3
	dev->vblank->vb_max = 0xffffff; /* only 24 bits of frame count */
	if (IS_G4X(dev_priv))
		dev->vblank->vb_max = 0xffffffff;
d283 39
a327 4
	I915_WRITE(PIPEASTAT, 0);
	I915_WRITE(PIPEBSTAT, 0);
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);
d329 18
a346 3
	I915_WRITE(PIPEASTAT, I915_READ(PIPEASTAT) & 0x8000ffff);
	I915_WRITE(PIPEBSTAT, I915_READ(PIPEBSTAT) & 0x8000ffff);
	I915_WRITE(IIR, I915_READ(IIR));
@


1.46
log
@Remove the DRI1 code paths from inteldrm as promised two weeks ago.

We no longer support these paths, only memory managed mode is now allowed.
@
text
@d35 4
a38 4
void	i915_enable_irq(drm_i915_private_t *, u_int32_t);
void	i915_disable_irq(drm_i915_private_t *, u_int32_t);
void	i915_enable_pipestat(drm_i915_private_t *, int, u_int32_t);
void	i915_disable_pipestat(drm_i915_private_t *, int, u_int32_t);
d40 2
a41 2
inline void
i915_enable_irq(drm_i915_private_t *dev_priv, u_int32_t mask)
d50 2
a51 2
inline void
i915_disable_irq(drm_i915_private_t *dev_priv, u_int32_t mask)
d61 1
a61 1
i915_enable_pipestat(drm_i915_private_t *dev_priv, int pipe, u_int32_t mask)
d74 1
a74 1
i915_disable_pipestat(drm_i915_private_t *dev_priv, int pipe, u_int32_t mask)
d88 1
a88 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
d125 1
a125 1
i915_user_irq_get(struct drm_i915_private *dev_priv)
d132 1
a132 1
i915_user_irq_put(struct drm_i915_private *dev_priv)
d141 1
a141 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
d157 1
a157 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
d170 1
a170 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
d215 1
a215 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
@


1.45
log
@unifdef INTELDRM_GEM.

This enabled GEM for the intel driver unconditionally. The legacy
codepaths will be removed in approximately one week since they are now
completely unused.

After discussion with matthieu@@, drahn@@, kettenis@@ and marco@@ (well,
mostly nagging from marco ;).
@
text
@a38 1
int	i915_wait_irq(struct drm_device *, int);
a123 19
int
i915_emit_irq(struct drm_device *dev)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;

	inteldrm_update_ring(dev_priv);

	DRM_DEBUG("\n");

	i915_emit_breadcrumb(dev);

	BEGIN_LP_RING(2);
	OUT_RING(0);
	OUT_RING(MI_USER_INTERRUPT);
	ADVANCE_LP_RING();

	return (dev_priv->counter);
}

a137 65

int
i915_wait_irq(struct drm_device *dev, int irq_nr)
{
	drm_i915_private_t	*dev_priv =  dev->dev_private;
	int			 ret = 0;

	DRM_DEBUG("irq_nr=%d breadcrumb=%d\n", irq_nr,
		  READ_BREADCRUMB(dev_priv));

	mtx_enter(&dev_priv->user_irq_lock);
	i915_user_irq_get(dev_priv);
	while (ret == 0) {
		if (READ_BREADCRUMB(dev_priv) >= irq_nr)
			break;
		ret = msleep(dev_priv, &dev_priv->user_irq_lock,
		    PZERO | PCATCH, "i915wt", 3 * hz);
	}
	i915_user_irq_put(dev_priv);
	mtx_leave(&dev_priv->user_irq_lock);

	if (dev_priv->sarea_priv != NULL)
		dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
	return (ret);
}

/* Needs the lock as it touches the ring.
 */
int
i915_irq_emit(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;
	drm_i915_irq_emit_t	*emit = data;
	int			 result;

	RING_LOCK_TEST_WITH_RETURN(dev, file_priv);

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return EINVAL;
	}

	DRM_LOCK();
	result = i915_emit_irq(dev);
	DRM_UNLOCK();

	return (copyout(&result, emit->irq_seq, sizeof(result)));
}

/* Doesn't need the hardware lock.
 */
int
i915_irq_wait(struct drm_device *dev, void *data, struct drm_file *file_priv)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;
	drm_i915_irq_wait_t	*irqwait = data;

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return (EINVAL);
	}

	return (i915_wait_irq(dev, irqwait->irq_seq));
}

a162 17
}

int
i915_vblank_pipe_get(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;
	drm_i915_vblank_pipe_t	*pipe = data;

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return (EINVAL);
	}

	pipe->pipe = DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B;

	return (0);
@


1.44
log
@DRM memory management for inteldrm(4) using the Graphics Execution
Manager api.

This is currently disabled by default under ifdef INTELDRM_GEM (option
INTELDRM_GEM in a kernel config or a patch to i915_drv.h needed to
enable), mostly because the intel X driver currently in tree does not
always play well with GEM and needs to be switched to UXA accelmethod
(which is the only option on later drivers).

While based on the intel drm code in the linux kernel this has come cleanups and
some obvious behaviour changes:

1) mmap through the GTT is entirely coherent with the gpu cache, removing
mappings whenever the cache dirties so you can not race with userland to write
to memory at the same time as the gpu.

2) pread/pwrite access is tiling-correct, so userland does not need to tile
manually (mesa has already been fixed for this a while ago). The straw that
broke the camels back here was the bit17 swizzling stuff on some mobile gpus
meansing that while userland did the swizzle itself, the kernel had to do
*extra* swizzling, this was frankly retarded so the option was dropped.

3) there is no option to map via the cpu from userland, again due to
coherency issues.

4) additional integer overflow checking in some areas.

5) we only support the newer EXECBUFFER2 command submission ioctl. the
old one is not supported at all (libdrm was fixed WRT over a week ago).


now the TODOs:

1) the locking is funky and is only correct due to biglock. it does
however work due to that. This will be fixed in tree, the design in
formulating in my head as I type.

2) there are currently no memory limits on drm memory, this needs to be
changed.

3) we really need PAT support for the machines where MTRRs are useless, else drm
uses quite a lot of cpu (this is a bug that continues from the older code
though, nothing new).

4) gpu resetting support on other than 965 is not written yet.

5) currently a lot of the code is in inteldrm, when memory management
comes to other chipset common code will be factored out into the drm
midlayer.

Tested on: 855 (x40), GM965 and 915 by me. 945 by armani@@ and jkmeuser@@,
gm45 by armani@@ and marco@@. More testing is needed before I enable this
by default though.  Others also provided testing by what they tested
escapes me right now.

In order to test this enable INTELDRM_GEM in a kernel and add the following line
to the driver section in xorg.conf (I am working on a patch to autodetect the X
stuff):

Option "AccelMethod" "UXA"
@
text
@a284 1
#ifdef INTELDRM_GEM
a292 1
#endif /* INTELDRM_GEM */
@


1.43
log
@G4X chipsets actually have a slightly larger vblank counter  register,
so tell the vblank layer this.

from upstream, ages ago.
@
text
@a40 19
/*
 * Interrupts that are always left unmasked.
 *
 * Since pipe events are edge-triggered from the PIPESTAT register to IIRC,
 * we leave them always unmasked in IMR and then control enabling them through
 * PIPESTAT alone.
 */
#define I915_INTERRUPT_ENABLE_FIX		\
	(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |	\
    	I915_DISPLAY_PIPE_B_EVENT_INTERRUPT)	

/* Interrupts that we mask and unmask at runtime */
#define I915_INTERRUPT_ENABLE_VAR	(I915_USER_INTERRUPT)

/* These are all of the interrupts used by the driver */
#define I915_INTERRUPT_ENABLE_MASK	\
	(I915_INTERRUPT_ENABLE_FIX |	\
	I915_INTERRUPT_ENABLE_VAR)

a125 49
inteldrm_intr(void *arg)
{
	struct drm_device	*dev = arg;
	drm_i915_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 iir, pipea_stats = 0, pipeb_stats = 0;

	/*
	 * lock is to protect from writes to PIPESTAT and IMR from other cores.
	 */
	mtx_enter(&dev_priv->user_irq_lock);
	iir = I915_READ(IIR);
	if (iir == 0) {
		mtx_leave(&dev_priv->user_irq_lock);
		return (0);
	}

	/*
	 * Clear the PIPE(A|B)STAT regs before the IIR
	 */
	if (iir & I915_DISPLAY_PIPE_A_EVENT_INTERRUPT) {
		pipea_stats = I915_READ(PIPEASTAT);
		I915_WRITE(PIPEASTAT, pipea_stats);
	}
	if (iir & I915_DISPLAY_PIPE_B_EVENT_INTERRUPT) {
		pipeb_stats = I915_READ(PIPEBSTAT);
		I915_WRITE(PIPEBSTAT, pipeb_stats);
	}

	I915_WRITE(IIR, iir);
	(void)I915_READ(IIR); /* Flush posted writes */

	if (dev_priv->sarea_priv != NULL)
		dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);

	if (iir & I915_USER_INTERRUPT)
		wakeup(dev_priv);

	mtx_leave(&dev_priv->user_irq_lock);

	if (pipea_stats & I915_VBLANK_INTERRUPT_STATUS)
		drm_handle_vblank(dev, 0);

	if (pipeb_stats & I915_VBLANK_INTERRUPT_STATUS)
		drm_handle_vblank(dev, 1);

	return (1);
}

int
d147 1
a147 3
	struct drm_device	*dev = (struct drm_device *)dev_priv->drmdev;

	if (dev->irq_enabled && (++dev_priv->user_irq_refcount == 1))
d154 1
a154 3
	struct drm_device	*dev = (struct drm_device *)dev_priv->drmdev;

	if (dev->irq_enabled && (--dev_priv->user_irq_refcount == 0))
d193 1
a193 1
	LOCK_TEST_WITH_RETURN(dev, file_priv);
a280 5
	dev_priv->irqh = pci_intr_establish(dev_priv->pc, dev_priv->ih, IPL_BIO,
	    inteldrm_intr, dev, dev_priv->dev.dv_xname);
	if (dev_priv->irqh == NULL)
		return (ENOENT);

d285 10
a294 2
	/* Unmask the interrupts that we always want on. */
	dev_priv->irq_mask_reg = ~I915_INTERRUPT_ENABLE_FIX;
d296 10
a305 5
	dev_priv->pipestat[0] = dev_priv->pipestat[1] = 0;

	/* Disable pipe interrupt enables, clear pending pipe status */
	I915_WRITE(PIPEASTAT, I915_READ(PIPEASTAT) & 0x8000ffff);
	I915_WRITE(PIPEBSTAT, I915_READ(PIPEBSTAT) & 0x8000ffff);
a320 3
	if (!dev_priv)
		return;

a329 2

	pci_intr_disestablish(dev_priv->pc, dev_priv->irqh);
@


1.42
log
@Make it so that instead of grabbing and ungrabbing the spinlock one line apart,
we just grab it once and drop it when we're done.

will reduce spl/splx wrangling. While here, clean it up a little bit.
@
text
@d359 2
@


1.41
log
@Suspend/resume goop for inteldrm, essentially a big pile of save/restore
registers (man these things have a lot of state!).

ok pirofti@@ (who did the activate function and tested).
@
text
@d179 1
a179 1
	if (iir & I915_USER_INTERRUPT) {
d181 1
a181 1
	}
d213 1
a213 1
i915_user_irq_get(struct drm_device *dev)
d215 1
a215 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
a216 1
	mtx_enter(&dev_priv->user_irq_lock);
a218 1
	mtx_leave(&dev_priv->user_irq_lock);
d222 1
a222 1
i915_user_irq_put(struct drm_device *dev)
d224 1
a224 1
	drm_i915_private_t	*dev_priv = dev->dev_private;
a225 1
	mtx_enter(&dev_priv->user_irq_lock);
a227 1
	mtx_leave(&dev_priv->user_irq_lock);
d240 10
a249 4
	i915_user_irq_get(dev);
	DRM_WAIT_ON(ret, dev_priv, &dev_priv->user_irq_lock, 3 * hz, "i915wt",
	    READ_BREADCRUMB(dev_priv) >= irq_nr);
	i915_user_irq_put(dev);
@


1.40
log
@Something i should have commited months ago.

Instead of planes, use pipes for the vblank code (this matters with the
newer drivers we're now using). originally from upstream (kinda, i
adapted it a little). Much cleaner now, too.

Helps with some vblank issues sthen@@ has been seeing. Also seems to fix
any issues i've seen with the x40, with suspend-on-lid disabled shutting
hte lid no longer borks X on my x40, this issue pointed out (and
reminded regularly until I found time :) by deraadt@@
@
text
@a34 1
int	i915_pipe_enabled(struct drm_device *, int);
a104 18
/**
 * i915_pipe_enabled - check if a pipe is enabled
 * @@dev: DRM device
 * @@pipe: pipe to check
 *
 * Reading certain registers when the pipe is disabled can hang the chip.
 * Use this routine to make sure the PLL is running and the pipe is active
 * before reading such registers if unsure.
 */
int
i915_pipe_enabled(struct drm_device *dev, int pipe)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;
	bus_size_t		 pipeconf = pipe ? PIPEBCONF : PIPEACONF;

	return ((I915_READ(pipeconf) & PIPEACONF_ENABLE) == PIPEACONF_ENABLE);
}

d115 1
a115 1
	if (i915_pipe_enabled(dev, pipe) == 0) {
d298 1
a298 1
	if (i915_pipe_enabled(dev, pipe) == 0)
@


1.39
log
@Cleanup: knf, typos.
@
text
@a106 37
 * i915_get_pipe - return the pipe associated with a given plane
 * @@dev: DRM device
 * @@plane: plane to look for
 *
 * The Intel Mesa & 2D drivers call the vblank routines with a plane number
 * rather than a pipe number, since they may not always be equal.  This routine
 * maps the given @@plane back to a pipe number.
 */
static int
i915_get_pipe(struct drm_device *dev, int plane)
{
	drm_i915_private_t	*dev_priv = dev->dev_private;
	u_int32_t		 dspcntr;

	dspcntr = plane ? I915_READ(DSPBCNTR) : I915_READ(DSPACNTR);

	return dspcntr & DISPPLANE_SEL_PIPE_MASK ? 1 : 0;
}

/**
 * i915_get_plane - return the the plane associated with a given pipe
 * @@dev: DRM device
 * @@pipe: pipe to look for
 *
 * The Intel Mesa & 2D drivers call the vblank routines with a plane number
 * rather than a plane number, since they may not always be equal.  This routine
 * maps the given @@pipe back to a plane number.
 */
static int
i915_get_plane(struct drm_device *dev, int pipe)
{
	if (i915_get_pipe(dev, 0) == pipe)
		return 0;
	return 1;
}

/**
d125 1
a125 1
i915_get_vblank_counter(struct drm_device *dev, int plane)
a129 1
	int			 pipe;
a130 1
	pipe = i915_get_pipe(dev, plane);
d204 1
a204 1
		drm_handle_vblank(dev, i915_get_plane(dev, 0));
d207 1
a207 1
		drm_handle_vblank(dev, i915_get_plane(dev, 1));
d313 1
a313 1
i915_enable_vblank(struct drm_device *dev, int plane)
a315 1
	int			 pipe = i915_get_pipe(dev, plane);
d329 1
a329 1
i915_disable_vblank(struct drm_device *dev, int plane)
a331 1
	int			 pipe = i915_get_pipe(dev, plane);
@


1.38
log
@The G4X and GM45 just /had/ to have a different counter register.

Been meaning to pull this in from upstream for ages.
@
text
@d35 1
d88 1
a88 1
		/* Enabble the interrupt, clear and pending status */
d118 2
a119 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	u32 dspcntr;
d152 1
a152 1
static int
d155 2
a156 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	unsigned long pipeconf = pipe ? PIPEBCONF : PIPEACONF;
d158 1
a158 4
	if (I915_READ(pipeconf) & PIPEACONF_ENABLE)
		return 1;

	return 0;
d205 3
a207 3
	struct drm_device *dev = (struct drm_device *)arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *)dev->dev_private;
	u_int32_t iir, pipea_stats = 0, pipeb_stats = 0;
d251 2
a252 1
int i915_emit_irq(struct drm_device *dev)
d254 1
a254 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d267 1
a267 1
	return dev_priv->counter;
d270 2
a271 1
void i915_user_irq_get(struct drm_device *dev)
d273 1
a273 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *)dev->dev_private;
d281 2
a282 1
void i915_user_irq_put(struct drm_device *dev)
d284 1
a284 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *)dev->dev_private;
d314 2
a315 2
int i915_irq_emit(struct drm_device *dev, void *data,
			 struct drm_file *file_priv)
d317 3
a319 3
	drm_i915_private_t *dev_priv = dev->dev_private;
	drm_i915_irq_emit_t *emit = data;
	int result;
d332 1
a332 6
	if (DRM_COPY_TO_USER(emit->irq_seq, &result, sizeof(int))) {
		DRM_ERROR("copy_to_user\n");
		return EFAULT;
	}

	return 0;
d337 2
a338 2
int i915_irq_wait(struct drm_device *dev, void *data,
		  struct drm_file *file_priv)
d340 2
a341 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	drm_i915_irq_wait_t *irqwait = data;
d345 1
a345 1
		return EINVAL;
d348 1
a348 1
	return i915_wait_irq(dev, irqwait->irq_seq);
d351 2
a352 1
int i915_enable_vblank(struct drm_device *dev, int plane)
d354 2
a355 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int pipe = i915_get_pipe(dev, plane);
d365 1
a365 1
	return 0;
d368 2
a369 1
void i915_disable_vblank(struct drm_device *dev, int plane)
d371 2
a372 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int pipe = i915_get_pipe(dev, plane);
d380 3
a382 2
int i915_vblank_pipe_get(struct drm_device *dev, void *data,
			 struct drm_file *file_priv)
d384 2
a385 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	drm_i915_vblank_pipe_t *pipe = data;
d389 1
a389 1
		return EINVAL;
d394 1
a394 1
	return 0;
d402 1
a402 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d433 1
a433 1
	return 0;
d436 2
a437 1
void i915_driver_irq_uninstall(struct drm_device * dev)
d439 1
a439 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
@


1.37
log
@Fixed a few the-the misspellings in comments. Skipped a bunch in binutils,gcc and so on. ok jmc@@
@
text
@d181 6
@


1.36
log
@Don't bother to keep a count of irqs recieved, the os does that for us.
@
text
@d106 1
a106 1
 * i915_get_pipe - return the the pipe associated with a given plane
@


1.35
log
@Rework the vblank subsystem so that instead of having various bits in
the drm softc, we only have one pointer, with the rest in that struct. This is
so that vblank-less drivers (yes, they exist) don't need to waste space on
useless crud.

While i'm reworking most of this code anyway, accept that on openbsd all
of the #defined atomic functions are not atomic other than set and clear
bit. Also, realise that the vb_lock is held whenever we manipulate these
counts anyway.  With those two facts in mind just remove the
atomic_blah() and just use ++ and --.
@
text
@a208 1
	atomic_inc(&dev_priv->irq_received);
@


1.34
log
@${XORGNAME}_driver_irq_handler() is a stupid name for an interrupt
handler anyway. replace it with ${OpenBSD_driver_name}_intr like most of
the rest of the tree. No functional change.
@
text
@d412 1
a412 1
	dev->max_vblank_count = 0xffffff; /* only 24 bits of frame count */
@


1.33
log
@More compat crud bites the dust: Remove the IRQ_NONE and IRQ_HANDLED
defines. 0 and 1 are fine for returning from irq handlers so why bother
with the indirection?
@
text
@d34 1
a34 1
int	i915_driver_irq_handler(void *);
d199 1
a199 1
i915_driver_irq_handler(void *arg)
d408 1
a408 1
	    i915_driver_irq_handler, dev, dev_priv->dev.dv_xname);
@


1.32
log
@kill the stupid DRM_IRQ_ARGS macros and irqreturn_t typedef, switch to
the unmacroed/typedefed version.
@
text
@d213 1
a213 1
		return (IRQ_NONE);
d245 1
a245 1
	return (IRQ_HANDLED);
@


1.31
log
@Remove dev->irq_lock, the drm_irq_handler_wrap irq handler, and remove
the dev->driver irq_handler member since we now don't need to know.
Shaves a few bytes, and makes me happy.
@
text
@d34 1
a34 1
irqreturn_t i915_driver_irq_handler(DRM_IRQ_ARGS);
d198 2
a199 2
irqreturn_t
i915_driver_irq_handler(DRM_IRQ_ARGS)
@


1.30
log
@Final irq_lock piece. Switch inteldrm over like radeomdrm and the rest.

We already have a lock protecting the irq registers, so extend it
trivially so it protects user interrupts too. Switch irq handler to
purely local handler.  Finally remove an extra test in i915_wait_irq()
since we won't sleep even without that if the test will pass.

irq_lock and handler_wrap may now die. Coming soon.
@
text
@d34 1
@


1.29
log
@use i915_pipe_enabled() to test to see if the pipe is lit up, instead of
expanding the function in line here.
@
text
@d204 3
a228 1
	mtx_leave(&dev_priv->user_irq_lock);
d236 1
a294 8
	if (READ_BREADCRUMB(dev_priv) >= irq_nr) {
		if (dev_priv->sarea_priv != NULL) {
			dev_priv->sarea_priv->last_dispatch =
			    READ_BREADCRUMB(dev_priv);
		}
		return (0);
	}

d296 1
a296 1
	DRM_WAIT_ON(ret, dev_priv, &dev->irq_lock, 3 * hz, "i915wt",
a299 5
	if (ret == EBUSY) {
		DRM_ERROR("EBUSY -- rec: %d emitted: %d\n",
			  READ_BREADCRUMB(dev_priv), (int)dev_priv->counter);
	}

d407 1
a407 1
	    drm_irq_handler_wrap, dev, dev_priv->dev.dv_xname);
@


1.28
log
@Convert DRM_WAIT_ON to take additional parameters, the wmsg for msleep,
and the lock to manipulate.

first step of removing drm_irq_handler_wrap which just grabs the
irq_lock, and eventually irq_lock. drivers should manage their own.
@
text
@d174 1
a174 1
	if (!i915_pipe_enabled(dev, pipe)) {
d363 2
a364 3
	int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
 
	if ((I915_READ(pipeconf_reg) & PIPEACONF_ENABLE) == 0)
@


1.27
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@d162 2
a163 1
u32 i915_get_vblank_counter(struct drm_device *dev, int plane)
d165 4
a168 5
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	unsigned long high_frame;
	unsigned long low_frame;
	u32 high1, high2, low, count;
	int pipe;
d177 1
a177 1
		return 0;
d194 1
a194 3
	count = (high1 << 8) | low;

	return count;
d197 2
a198 1
irqreturn_t i915_driver_irq_handler(DRM_IRQ_ARGS)
d283 2
a284 1
int i915_wait_irq(struct drm_device * dev, int irq_nr)
d286 2
a287 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int ret = 0;
d297 1
a297 1
		return 0;
d301 2
a302 2
	DRM_WAIT_ON(ret, dev_priv, 3 * DRM_HZ,
		    READ_BREADCRUMB(dev_priv) >= irq_nr);
d312 1
a312 1
	return ret;
@


1.26
log
@Demacro the inteldrm ring macros too, making them use bus_space_write
instead of assuming BUS_SPACE_LINEAR + bus_space_vaddr  while i'm at
it.

Cleans things up nicely, and shaves a little bit of space, too.
@
text
@d233 1
a233 1
		DRM_WAKEUP(dev_priv);
@


1.25
log
@Remove an unused define.
@
text
@a247 1
	RING_LOCALS;
d249 1
a249 1
	i915_kernel_lost_context(dev);
@


1.24
log
@Don't enable vblank if the pipe is disabled.

Based on a patch from the intel driver maintainers (Jesse Barnes,
specifically)

Tested by several people on various hardware.
@
text
@a33 1
#define MAX_NOPID ((u32)~0)
@


1.23
log
@Fixup wakeup pointers. interrupts work properly again.
@
text
@d365 4
@


1.22
log
@Map device interrupts in the attach routine. and remove more need for
dev->pa by doing the pci_intr_establish/disestablish dance in the driver
function, not in drm. This removes the need for
interrupt_{pre,post}install callbacks, instead just provide a
interrupt_install() callback.
@
text
@d234 1
a234 1
		DRM_WAKEUP(&dev_priv);
@


1.21
log
@Move vblank data allocation to happening at attach, not at irq enable.
just put a vblank_pipes argument to the driver structure which tells us
how many to set up

this means that intel doesn't lose all vblank count on vtswitch (it
disables the interrupt there), i've heard of a few uvm_faults where this
happens as well as things just going wrong.

This was suggested by Keith Packard who provided a different diff for
drm.git.
@
text
@d403 2
a404 1
void i915_driver_irq_preinstall(struct drm_device * dev)
a413 1
}
d415 4
a418 3
int i915_driver_irq_postinstall(struct drm_device * dev)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d456 2
@


1.20
log
@using ``wait queues' for sleep is a linuxism. Kill them and just sleep
on the softc.
@
text
@a417 5
	int ret, num_pipes = 2;

	ret = drm_vblank_init(dev, num_pipes);
	if (ret)
		return ret;
@


1.19
log
@Slightly fix up previous
@
text
@d234 1
a234 1
		DRM_WAKEUP(&dev_priv->irq_queue);
d303 1
a303 1
	DRM_WAIT_ON(ret, dev_priv->irq_queue, 3 * DRM_HZ,
a439 2

	DRM_INIT_WAITQUEUE(&dev_priv->irq_queue);
@


1.18
log
@garbage collect i915_vblank_swap.
@
text
@d367 1
a367 1
	i915_enable_pipestat(dev_priv, pipe, (IS_I965G(dev) ? 
@


1.17
log
@Manage vblank interrupts using the PIPESTAT register.

The pipestat register needs tweaking when enabling vblanks, and doing this and
playing with the IMR seems to lead to problems, so just leave them always
unmasked and just tweak PIPESTAT.

From Keith Packard at Intel.
@
text
@a400 23
/*
 * Schedule buffer swap at given vertical blank.
 */
int i915_vblank_swap(struct drm_device *dev, void *data,
		     struct drm_file *file_priv)
{
	/* The delayed swap mechanism was fundamentally racy, and has been
	 * removed.  The model was that the client requested a delayed flip/swap
	 * from the kernel, then waited for vblank before continuing to perform
	 * rendering.  The problem was that the kernel might wake the client
	 * up before it dispatched the vblank swap (since the lock has to be
	 * held while touching the ringbuffer), in which case the client would
	 * clear and start the next frame before the swap occurred, and   
	 * flicker would occur in addition to likely missing the vblank.
	 *
	 * In the absence of this ioctl, userland falls back to a correct path
	 * of waiting for a vblank, then dispatching the swap on its own.
	 * Context switching to userland and back is plenty fast enough for
	 * meeting the requirements of vblank swapping.
	 */
	return (EINVAL);
}

@


1.16
log
@Conditionalise the use of the SAREA in inteldrm. In DRI2 setups (which we don't
support yet, but will) it won't exist, prepare for this by only writing to it if
it's there.

Bits of this came from Eric Anholt at intel.
@
text
@d37 2
d41 18
a58 4
/** These are the interrupts used by the driver */
#define I915_INTERRUPT_ENABLE_MASK	(I915_USER_INTERRUPT |		\
					I915_DISPLAY_PIPE_A_EVENT_INTERRUPT | \
					I915_DISPLAY_PIPE_B_EVENT_INTERRUPT)
d80 25
d202 3
a204 5
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	u32 iir;
	u32 pipea_stats, pipeb_stats;
	int vblank = 0;
d206 1
d209 4
a212 2
	if (iir == 0)
		return IRQ_NONE;
d215 1
a215 2
	 * Clear the PIPE(A|B)STAT regs before the IIR otherwise
	 * we may get extra interrupts.
a218 6
		if (pipea_stats & (PIPE_START_VBLANK_INTERRUPT_STATUS|
		    PIPE_VBLANK_INTERRUPT_STATUS)) {
			vblank++;
			drm_handle_vblank(dev, i915_get_plane(dev, 0));
		}

a222 9
		/* Ack the event */
		I915_WRITE(PIPEBSTAT, pipeb_stats);

		if (pipeb_stats & (PIPE_START_VBLANK_INTERRUPT_STATUS|
		    PIPE_VBLANK_INTERRUPT_STATUS)) {
			vblank++;
			drm_handle_vblank(dev, i915_get_plane(dev, 1));
		}

d227 2
a228 1
	(void) I915_READ(IIR); /* Flush posted writes */
d237 7
a243 1
	return IRQ_HANDLED;
a364 18
	u32	pipestat_reg = 0;
	u32	pipestat;
	u32	interrupt = 0;

	switch (pipe) {
	case 0:
		pipestat_reg = PIPEASTAT;
		interrupt = I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
		break;
	case 1:
		pipestat_reg = PIPEBSTAT;
		interrupt = I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
		break;
	default:
		DRM_ERROR("tried to enable vblank on non-existent pipe %d\n",
			  pipe);
		return (0);
	}
d367 2
a368 20
	/*
	 * Enabling vblank events in IMR comes before PIPESTAT write, or
	 * there's a race where the PIPESTAT vblank bit gets set to 1, so
	 * the OR of enabled PIPESTAT bits goes to 1, so the PIPExEVENT in
	 * ISR flashes to 1, but the IIR bit doesn't get set to 1 because
	 * IMR masks it.  It doesn't ever get set after we clear the masking
	 * in IMR because the ISR bit is edge, not level-triggered, on the
	 * OR of PIPESTAT bits.
	 */
	i915_enable_irq(dev_priv, interrupt);
	pipestat = I915_READ(pipestat_reg);
	if (IS_I965G(dev))
		pipestat |= PIPE_START_VBLANK_INTERRUPT_ENABLE;
	else
		pipestat |= PIPE_VBLANK_INTERRUPT_ENABLE;
	/* Clear any stale interrupt status */
	pipestat |= (PIPE_START_VBLANK_INTERRUPT_STATUS |
	    PIPE_VBLANK_INTERRUPT_STATUS);
	I915_WRITE(pipestat_reg, pipestat);
	(void)I915_READ(pipestat_reg); /* Posting read */
a377 18
	u32	pipestat_reg = 0;
	u32	pipestat;
	u32	interrupt = 0;

	switch (pipe) {
	case 0:
		pipestat_reg = PIPEASTAT;
		interrupt = I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
		break;
	case 1:
		pipestat_reg = PIPEBSTAT;
		interrupt = I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
		break;
	default:
		DRM_ERROR("tried to disable vblank on non-existent pipe %d\n",
			  pipe);
		return;
	}
d380 2
a381 9
	i915_disable_irq(dev_priv, interrupt);
	pipestat = I915_READ(pipestat_reg);
	pipestat &= ~(PIPE_START_VBLANK_INTERRUPT_ENABLE |
	    PIPE_VBLANK_INTERRUPT_ENABLE);
	/* Clear any stale interrupt status */
	pipestat |= (PIPE_START_VBLANK_INTERRUPT_STATUS |
	    PIPE_VBLANK_INTERRUPT_STATUS);
	I915_WRITE(pipestat_reg, pipestat);
	(void)I915_READ(pipestat_reg);
d431 2
d435 1
a442 2
	dev_priv->irq_mask_reg = ~0;

d449 12
a461 1
	I915_WRITE(IER, I915_INTERRUPT_ENABLE_MASK);
a471 1
	u32 temp;
d477 2
d482 3
a484 6
	temp = I915_READ(PIPEASTAT);
	I915_WRITE(PIPEASTAT, temp);
	temp = I915_READ(PIPEBSTAT);
	I915_WRITE(PIPEBSTAT, temp);
	temp = I915_READ(IIR);
	I915_WRITE(IIR, temp);
@


1.15
log
@The i915 vblank swap ioctl is fundamentally racy.

using it allowed rendering to continue while waiting for a vblank swap,
and often this lead to flickering and rendering a new scene before the
swap. this broke a lot of things.

With the removal of this swap, userland falls back to the old way of
waiting for the vblank then doing the swap itself, this is smooth
enough.

I decided independantly to kill this, but the intel guys recently
concurred.  Comment change comes from Eric Anholt at intel.
@
text
@d203 1
a203 1
	if (dev_priv->sarea_priv)
d262 1
a262 1
		if (dev_priv->sarea_priv) {
d279 2
a280 3
	if (dev_priv->sarea_priv)
		dev_priv->sarea_priv->last_dispatch =
			READ_BREADCRUMB(dev_priv);
@


1.14
log
@Enable IMR passthrough of vblank events before enabling it in the
pipestat register. Fixes a nasty race where the bit would get set
without being reflected in the interrupt register, so we'd never get
another vblank interrupt.

Also, use the user_irq_lock to also protect vblank register writes, since it
covers the same register.

From Eric Anholt and  Keith Packard at Intel.
@
text
@a121 200
/**
 * Emit blits for scheduled buffer swaps.
 *
 * This function will be called with the HW lock held.
 */
static void i915_vblank_tasklet(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	struct list_head *list, *tmp, hits, *hit;
	int nhits, nrects, slice[2], upper[2], lower[2], i;
	unsigned counter[2];
	struct drm_drawable_info *drw;
	drm_i915_sarea_t *sarea_priv = dev_priv->sarea_priv;
	u32 cpp = dev_priv->cpp;
	u32 cmd = (cpp == 4) ? (XY_SRC_COPY_BLT_CMD |
				XY_SRC_COPY_BLT_WRITE_ALPHA |
				XY_SRC_COPY_BLT_WRITE_RGB)
			     : XY_SRC_COPY_BLT_CMD;
	u32 src_pitch = sarea_priv->pitch * cpp;
	u32 dst_pitch = sarea_priv->pitch * cpp;
	u32 ropcpp = (0xcc << 16) | ((cpp - 1) << 24);
	RING_LOCALS;

	DRM_LOCK();

	if (IS_I965G(dev) && sarea_priv->front_tiled) {
		cmd |= XY_SRC_COPY_BLT_DST_TILED;
		dst_pitch >>= 2;
	}
	if (IS_I965G(dev) && sarea_priv->back_tiled) {
		cmd |= XY_SRC_COPY_BLT_SRC_TILED;
		src_pitch >>= 2;
	}

	counter[0] = drm_vblank_count(dev, i915_get_plane(dev, 0));
	counter[1] = drm_vblank_count(dev, i915_get_plane(dev, 1));

	DRM_DEBUG("\n");

	INIT_LIST_HEAD(&hits);

	nhits = nrects = 0;

	mtx_enter(&dev_priv->swaps_lock);

	/* Find buffer swaps scheduled for this vertical blank */
	list_for_each_safe(list, tmp, &dev_priv->vbl_swaps.head) {
		drm_i915_vbl_swap_t *vbl_swap =
			list_entry(list, drm_i915_vbl_swap_t, head);
		int pipe = vbl_swap->pipe;

		if ((counter[pipe] - vbl_swap->sequence) > (1<<23))
			continue;

		list_del(list);
		dev_priv->swaps_pending--;
		drm_vblank_put(dev, pipe);

		mtx_leave(&dev_priv->swaps_lock);
		mtx_enter(&dev->drw_lock);

		drw = drm_get_drawable_info(dev, vbl_swap->drw_id);

		list_for_each(hit, &hits) {
			drm_i915_vbl_swap_t *swap_cmp =
				list_entry(hit, drm_i915_vbl_swap_t, head);
			struct drm_drawable_info *drw_cmp =
				drm_get_drawable_info(dev, swap_cmp->drw_id);

			/*
			 * Make sure both drawables are still around and have
			 * cliprects before we poke around in them
			 */
			if (drw_cmp && drw_cmp->num_rects > 0 &&
			    drw != NULL && drw->num_rects > 0 &&
			    drw_cmp->rects[0].y1 > drw->rects[0].y1) {
				list_add_tail(list, hit);
				break;
			}
		}

		mtx_leave(&dev->drw_lock);

		/* List of hits was empty, or we reached the end of it */
		if (hit == &hits)
			list_add_tail(list, hits.prev);

		nhits++;

		mtx_enter(&dev_priv->swaps_lock);
	}

	mtx_leave(&dev_priv->swaps_lock);

	if (nhits == 0) {
		DRM_UNLOCK();
		return;
	}

	i915_kernel_lost_context(dev);

	if (IS_I965G(dev)) {
		BEGIN_LP_RING(4);

		OUT_RING(GFX_OP_DRAWRECT_INFO_I965);
		OUT_RING(0);
		OUT_RING(((sarea_priv->width - 1) & 0xffff) | ((sarea_priv->height - 1) << 16));
		OUT_RING(0);
		ADVANCE_LP_RING();
	} else {
		BEGIN_LP_RING(6);

		OUT_RING(GFX_OP_DRAWRECT_INFO);
		OUT_RING(0);
		OUT_RING(0);
		OUT_RING(sarea_priv->width | sarea_priv->height << 16);
		OUT_RING(sarea_priv->width | sarea_priv->height << 16);
		OUT_RING(0);

		ADVANCE_LP_RING();
	}

	sarea_priv->ctxOwner = DRM_KERNEL_CONTEXT;

	upper[0] = upper[1] = 0;
	slice[0] = max(sarea_priv->planeA_h / nhits, 1);
	slice[1] = max(sarea_priv->planeB_h / nhits, 1);
	lower[0] = sarea_priv->planeA_y + slice[0];
	lower[1] = sarea_priv->planeB_y + slice[0];

	mtx_enter(&dev->drw_lock);

	/* Emit blits for buffer swaps, partitioning both outputs into as many
	 * slices as there are buffer swaps scheduled in order to avoid tearing
	 * (based on the assumption that a single buffer swap would always
	 * complete before scanout starts).
	 */
	for (i = 0; i++ < nhits;
	     upper[0] = lower[0], lower[0] += slice[0],
	     upper[1] = lower[1], lower[1] += slice[1]) {
		if (i == nhits)
			lower[0] = lower[1] = sarea_priv->height;

		list_for_each(hit, &hits) {
			drm_i915_vbl_swap_t *swap_hit =
				list_entry(hit, drm_i915_vbl_swap_t, head);
			struct drm_clip_rect *rect;
			int num_rects, pipe;
			unsigned short top, bottom;

			drw = drm_get_drawable_info(dev, swap_hit->drw_id);

			/*
			 * Drawable may have disappeared since this swap was
			 * queued
			 */
			if (!drw)
				continue;

			rect = drw->rects;
			pipe = swap_hit->pipe;
			top = upper[pipe];
			bottom = lower[pipe];

			for (num_rects = drw->num_rects; num_rects--; rect++) {
				int y1 = max(rect->y1, top);
				int y2 = min(rect->y2, bottom);

				if (y1 >= y2)
					continue;

				BEGIN_LP_RING(8);

				OUT_RING(cmd);
				OUT_RING(ropcpp | dst_pitch);
				OUT_RING((y1 << 16) | rect->x1);
				OUT_RING((y2 << 16) | rect->x2);
				OUT_RING(sarea_priv->front_offset);
				OUT_RING((y1 << 16) | rect->x1);
				OUT_RING(src_pitch);
				OUT_RING(sarea_priv->back_offset);

				ADVANCE_LP_RING();
			}
		}
	}

	mtx_leave(&dev->drw_lock);
	DRM_UNLOCK();

	list_for_each_safe(hit, tmp, &hits) {
		drm_i915_vbl_swap_t *swap_hit =
			list_entry(hit, drm_i915_vbl_swap_t, head);

		list_del(hit);

		drm_free(swap_hit, sizeof(*swap_hit), DRM_MEM_DRIVER);
	}
}

a209 5
	if (vblank) {
		if (dev_priv->swaps_pending > 0)
			drm_locked_tasklet(dev, i915_vblank_tasklet);
	}

d430 1
a430 1
/**
d436 13
a448 46
	drm_i915_private_t *dev_priv = dev->dev_private;
	drm_i915_vblank_swap_t *swap = data;
	drm_i915_vbl_swap_t *vbl_swap, *vbl_old;
	unsigned int pipe, seqtype, curseq, plane;
	struct list_head *list;
	int ret;

	if (!dev_priv || !dev_priv->sarea_priv) {
		DRM_ERROR("%s called with no initialization\n", __func__);
		return EINVAL;
	}

	if (dev_priv->sarea_priv->rotation) {
		DRM_DEBUG("Rotation not supported\n");
		return EINVAL;
	}

	if (swap->seqtype & ~(_DRM_VBLANK_RELATIVE | _DRM_VBLANK_ABSOLUTE |
			     _DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS)) {
		DRM_ERROR("Invalid sequence type 0x%x\n", swap->seqtype);
		return EINVAL;
	}

	plane = (swap->seqtype & _DRM_VBLANK_SECONDARY) ? 1 : 0;
	pipe = i915_get_pipe(dev, plane);

	seqtype = swap->seqtype & (_DRM_VBLANK_RELATIVE | _DRM_VBLANK_ABSOLUTE);

	if ((1 << pipe && DRM_I915_VBLANK_PIPE_A|DRM_I915_VBLANK_PIPE_B) == 0) {
		DRM_ERROR("Invalid pipe %d\n", pipe);
		return EINVAL;
	}

	mtx_enter(&dev->drw_lock);

	if (!drm_get_drawable_info(dev, swap->drawable)) {
		mtx_leave(&dev->drw_lock);
		DRM_DEBUG("Invalid drawable ID %d\n", swap->drawable);
		return EINVAL;
	}

	mtx_leave(&dev->drw_lock);

	/*
	 * We take the ref here and put it when the swap actually completes
	 * in the tasklet.
d450 1
a450 59
	ret = drm_vblank_get(dev, pipe);
	if (ret)
		return ret;
	curseq = drm_vblank_count(dev, pipe);

	if (seqtype == _DRM_VBLANK_RELATIVE)
		swap->sequence += curseq;

	if ((curseq - swap->sequence) <= (1<<23)) {
		if (swap->seqtype & _DRM_VBLANK_NEXTONMISS) {
			swap->sequence = curseq + 1;
		} else {
			DRM_DEBUG("Missed target sequence\n");
			drm_vblank_put(dev, pipe);
			return EINVAL;
		}
	}

	vbl_swap = drm_calloc(1, sizeof(*vbl_swap), DRM_MEM_DRIVER);
	if (vbl_swap == NULL) {
		DRM_ERROR("Failed to allocate memory to queue swap\n");
		drm_vblank_put(dev, pipe);
		return (ENOMEM);
	}

	vbl_swap->drw_id = swap->drawable;
	vbl_swap->pipe = pipe;
	vbl_swap->sequence = swap->sequence;

	mtx_enter(&dev_priv->swaps_lock);

	list_for_each(list, &dev_priv->vbl_swaps.head) {
		vbl_old = list_entry(list, drm_i915_vbl_swap_t, head);

		if (vbl_old->drw_id == swap->drawable &&
		    vbl_old->pipe == pipe &&
		    vbl_old->sequence == swap->sequence) {
			mtx_leave(&dev_priv->swaps_lock);
			drm_vblank_put(dev, pipe);
			drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
			DRM_DEBUG("Already scheduled\n");
			return 0;
		}
	}

	if (dev_priv->swaps_pending >= 10) {
		DRM_DEBUG("Too many swaps queued\n");
		mtx_leave(&dev_priv->swaps_lock);
		drm_vblank_put(dev, pipe);
		drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
		return EBUSY;
	}

	list_add_tail(&vbl_swap->head, &dev_priv->vbl_swaps.head);
	dev_priv->swaps_pending++;

	mtx_leave(&dev_priv->swaps_lock);

	return 0;
a467 3

	INIT_LIST_HEAD(&dev_priv->vbl_swaps.head);
	dev_priv->swaps_pending = 0;
@


1.13
log
@Hold the drm lock around all things that touch the ringbuffer.

Not strictly needed in the non-gem case, but it will be needed then, and
doesn't hurt now.

From Eric Anholt at intel.
@
text
@d441 1
a441 1
	DRM_SPINLOCK(&dev_priv->user_irq_lock);
d444 1
a444 2
	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);

d451 1
a451 1
	DRM_SPINLOCK(&dev_priv->user_irq_lock);
d454 1
a454 1
	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);
d557 1
a557 1
	pipestat = I915_READ (pipestat_reg);
d559 7
a565 2
	 * Older chips didn't have the start vblank interrupt,
	 * but 
d567 3
a569 1
	if (IS_I965G (dev))
d573 1
a573 3
	/*
	 * Clear any pending status
	 */
d575 1
a575 1
		     PIPE_VBLANK_INTERRUPT_STATUS);
d577 2
a578 4

	DRM_SPINLOCK(&dev_priv->user_irq_lock);
	i915_enable_irq(dev_priv, interrupt);
	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);
d606 1
a606 1
	DRM_SPINLOCK(&dev_priv->user_irq_lock);
d608 1
a608 3
	DRM_SPINUNLOCK(&dev_priv->user_irq_lock);

	pipestat = I915_READ (pipestat_reg);
d610 2
a611 4
		      PIPE_VBLANK_INTERRUPT_ENABLE);
	/*
	 * Clear any pending status
	 */
d613 1
a613 1
		     PIPE_VBLANK_INTERRUPT_STATUS);
d616 1
a675 5
	/* It makes no sense to schedule a swap for a drawable that doesn't have
	 * valid information at this point. E.g. this could mean that the X
	 * server is too old to push drawable information to the DRM, in which
	 * case all such swaps would become ineffective.
	 */
a781 5
	/*
	 * Initialize the hardware status page IRQ location.
	 */

	I915_WRITE(INSTPM, (1 << 5) | (1 << 21));
@


1.12
log
@revert the pageflipping and vblank sync code to the older style that
doesn't handle triple buffering (which has been marked ``don't use this,
it's unstable'' for ever anyway)

While the code just removed is in drm git. it's not planned to go any
further, due to being a horribly ugly hack. Instead a proper fix which
will depend on memory management is planned. So revert this stuff here,
since it's now dead.

Testing shows no regressions.
@
text
@d507 1
d509 1
@


1.11
log
@Remove the vblank_pipe member of the softc and noop the ioctl that sets
it.

Since the vblank handling got reworked this is very much unneeded.
@
text
@a122 47
 * Emit a synchronous flip.
 *
 * This function must be called with the drawable spinlock held.
 */
static void
i915_dispatch_vsync_flip(struct drm_device *dev, struct drm_drawable_info *drw,
			 int plane)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	drm_i915_sarea_t *sarea_priv = dev_priv->sarea_priv;
	u16 x1, y1, x2, y2;
	int pf_planes = 1 << plane;

	DRM_SPINLOCK_ASSERT(&dev->drw_lock);

	/* If the window is visible on the other plane, we have to flip on that
	 * plane as well.
	 */
	if (plane == 1) {
		x1 = sarea_priv->planeA_x;
		y1 = sarea_priv->planeA_y;
		x2 = x1 + sarea_priv->planeA_w;
		y2 = y1 + sarea_priv->planeA_h;
	} else {
		x1 = sarea_priv->planeB_x;
		y1 = sarea_priv->planeB_y;
		x2 = x1 + sarea_priv->planeB_w;
		y2 = y1 + sarea_priv->planeB_h;
	}

	if (x2 > 0 && y2 > 0) {
		int i, num_rects = drw->num_rects;
		struct drm_clip_rect *rect = drw->rects;

		for (i = 0; i < num_rects; i++)
			if (!(rect[i].x1 >= x2 || rect[i].y1 >= y2 ||
			      rect[i].x2 <= x1 || rect[i].y2 <= y1)) {
				pf_planes = 0x3;

				break;
			}
	}

	i915_dispatch_flip(dev, pf_planes, 1);
}

/**
d131 1
a131 1
	int nhits, nrects, slice[2], upper[2], lower[2], i, num_pages;
d135 1
a135 1
	u32 cpp = dev_priv->cpp,  offsets[3];
a141 1
	/* COPY rop (0xcc), map cpp to magic color depth constants */
d144 3
a146 1
	
d155 3
a157 3
	
	counter[0] = drm_vblank_count(dev, 0);
	counter[1] = drm_vblank_count(dev, 1);
d165 1
a165 6
	/* No irqsave/restore necessary.  This tasklet may be run in an
	 * interrupt context or normal context, but we don't have to worry
	 * about getting interrupted by something acquiring the lock, because
	 * we are the interrupt context thing that acquires the lock.
	 */
	DRM_SPINLOCK(&dev_priv->swaps_lock);
d171 1
a171 1
		int pipe = i915_get_pipe(dev, vbl_swap->plane);
d180 2
a181 2
		DRM_SPINUNLOCK(&dev_priv->swaps_lock);
		DRM_SPINLOCK(&dev->drw_lock);
a184 7
		if (!drw) {
			DRM_SPINUNLOCK(&dev->drw_lock);
			drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
			DRM_SPINLOCK(&dev_priv->swaps_lock);
			continue;
		}

d191 6
a196 1
			if (drw_cmp &&
d203 1
a203 1
		DRM_SPINUNLOCK(&dev->drw_lock);
d211 1
a211 1
		DRM_SPINLOCK(&dev_priv->swaps_lock);
d214 1
a214 1
	DRM_SPINUNLOCK(&dev_priv->swaps_lock);
d217 1
d223 23
d252 1
a252 6
	offsets[0] = sarea_priv->front_offset;
	offsets[1] = sarea_priv->back_offset;
	offsets[2] = sarea_priv->third_offset;
	num_pages = sarea_priv->third_handle ? 3 : 2;

	DRM_SPINLOCK(&dev->drw_lock);
a261 2
		int init_drawrect = 1;

d269 1
a269 1
			int num_rects, plane, front, back;
d274 4
a280 37
			plane = swap_hit->plane;

			if (swap_hit->flip) {
				i915_dispatch_vsync_flip(dev, drw, plane);
				continue;
			}

			if (init_drawrect) {
				int width  = sarea_priv->width;
				int height = sarea_priv->height;
				if (IS_I965G(dev)) {
					BEGIN_LP_RING(4);

					OUT_RING(GFX_OP_DRAWRECT_INFO_I965);
					OUT_RING(0);
					OUT_RING(((width - 1) & 0xffff) | ((height - 1) << 16));
					OUT_RING(0);
					
					ADVANCE_LP_RING();
				} else {
					BEGIN_LP_RING(6);
	
					OUT_RING(GFX_OP_DRAWRECT_INFO);
					OUT_RING(0);
					OUT_RING(0);
					OUT_RING(((width - 1) & 0xffff) | ((height - 1) << 16));
					OUT_RING(0);
					OUT_RING(0);
					
					ADVANCE_LP_RING();
				}

				sarea_priv->ctxOwner = DRM_KERNEL_CONTEXT;

				init_drawrect = 0;
			}

d282 3
a284 6
			top = upper[plane];
			bottom = lower[plane];

			front = (dev_priv->sarea_priv->pf_current_page >>
				 (2 * plane)) & 0x3;
			back = (front + 1) % num_pages;
d299 1
a299 1
				OUT_RING(offsets[front]);
d302 1
a302 1
				OUT_RING(offsets[back]);
d309 2
a310 1
	DRM_SPINUNLOCK(&dev->drw_lock);
d642 1
a642 1
	drm_i915_vbl_swap_t *vbl_swap;
a643 1
	unsigned long irqflags;
d647 1
a647 1
	if (!dev_priv) {
d652 1
a652 1
	if (!dev_priv->sarea_priv || dev_priv->sarea_priv->rotation) {
d658 1
a658 2
			     _DRM_VBLANK_SECONDARY | _DRM_VBLANK_NEXTONMISS |
			     _DRM_VBLANK_FLIP)) {
d673 1
a673 1
	DRM_SPINLOCK_IRQSAVE(&dev->drw_lock, irqflags);
d681 1
a681 1
		DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock, irqflags);
d686 1
a686 1
	DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock, irqflags);
d710 6
a715 2
	if (swap->seqtype & _DRM_VBLANK_FLIP) {
		swap->sequence--;
d717 3
a719 2
		if ((curseq - swap->sequence) <= (1<<23)) {
			struct drm_drawable_info *drw;
d721 1
a721 1
			LOCK_TEST_WITH_RETURN(dev, file_priv);
d723 2
a724 16
			DRM_SPINLOCK_IRQSAVE(&dev->drw_lock, irqflags);

			drw = drm_get_drawable_info(dev, swap->drawable);

			if (!drw) {
				DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock,
				    irqflags);
				DRM_DEBUG("Invalid drawable ID %d\n",
					  swap->drawable);
				drm_vblank_put(dev, pipe);
				return EINVAL;
			}

			i915_dispatch_vsync_flip(dev, drw, plane);

			DRM_SPINUNLOCK_IRQRESTORE(&dev->drw_lock, irqflags);
d726 4
d731 1
a731 14
			return 0;
		}
	}

	DRM_SPINLOCK_IRQSAVE(&dev_priv->swaps_lock, irqflags);

	list_for_each(list, &dev_priv->vbl_swaps.head) {
		vbl_swap = list_entry(list, drm_i915_vbl_swap_t, head);

		if (vbl_swap->drw_id == swap->drawable &&
		    vbl_swap->plane == plane &&
		    vbl_swap->sequence == swap->sequence) {
			vbl_swap->flip = (swap->seqtype & _DRM_VBLANK_FLIP);
			DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);
d737 1
a737 3
	DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);

	if (dev_priv->swaps_pending >= 100) {
d739 1
d741 1
a744 20
	vbl_swap = drm_calloc(1, sizeof(*vbl_swap), DRM_MEM_DRIVER);

	if (!vbl_swap) {
		DRM_ERROR("Failed to allocate memory to queue swap\n");
		drm_vblank_put(dev, pipe);
		return ENOMEM;
	}

	DRM_DEBUG("\n");

	vbl_swap->drw_id = swap->drawable;
	vbl_swap->plane = plane;
	vbl_swap->sequence = swap->sequence;
	vbl_swap->flip = (swap->seqtype & _DRM_VBLANK_FLIP);

	if (vbl_swap->flip)
		swap->sequence++;

	DRM_SPINLOCK_IRQSAVE(&dev_priv->swaps_lock, irqflags);

d748 1
a748 1
	DRM_SPINUNLOCK_IRQRESTORE(&dev_priv->swaps_lock, irqflags);
@


1.10
log
@Bunch of cleanup. Kill some dead variables and some stupid code.

Some ideas taken from upstream.
@
text
@a688 15
/* Set the vblank monitor pipe
 */
int i915_vblank_pipe_set(struct drm_device *dev, void *data,
			 struct drm_file *file_priv)
{
	drm_i915_private_t *dev_priv = dev->dev_private;

	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return EINVAL;
	}

	return 0;
}

d741 1
a741 1
	if (!(dev_priv->vblank_pipe & (1 << pipe))) {
a888 1
	dev_priv->vblank_pipe = DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B;
a911 2

	dev_priv->vblank_pipe = 0;
@


1.9
log
@Kill the linux-ready negative return codes in ``shared'' code. We handle
them wrong in several cases that i've noticed and Merging when needed is
still fairly simple, anyway. This shaves another 500 bytes from an amd64
kernel due to not having to flip the sign on some things. It also stops
my eyes bleeding.

Tested by a few along with the last diff that went in.
@
text
@d406 3
a408 2
	    DRM_DEBUG("trying to get vblank count for disabled pipe %d\n", pipe);
	    return 0;
d435 1
a435 1
	u32 pipea_stats = 0, pipeb_stats = 0;
d438 1
a439 1
	atomic_inc(&dev_priv->irq_received);
d450 1
a450 2
				   PIPE_VBLANK_INTERRUPT_STATUS))
		{
a461 5
		/* The vblank interrupt gets enabled even if we didn't ask for
		   it, so make sure it's shut down again */
		if (!(dev_priv->vblank_pipe & DRM_I915_VBLANK_PIPE_B))
			pipeb_stats &= ~(I915_VBLANK_INTERRUPT_ENABLE);

d463 1
a463 2
				   PIPE_VBLANK_INTERRUPT_STATUS))
		{
a467 4
#ifdef __linux__
		if (pipeb_stats & I915_LEGACY_BLC_EVENT_ENABLE)
			opregion_asle_intr(dev);
#endif
d471 2
a472 4
#ifdef __linux__
	if (iir & I915_ASLE_INTERRUPT)
		opregion_asle_intr(dev);
#endif
d475 1
a475 4
	    dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);

	I915_WRITE(IIR, iir);
	(void) I915_READ(IIR); /* Flush posted writes */
d508 1
a508 1
void i915_user_irq_on(drm_i915_private_t *dev_priv)
d510 2
d513 1
a513 1
	if (dev_priv->irq_enabled && (++dev_priv->user_irq_refcount == 1))
d519 1
a519 1
void i915_user_irq_off(drm_i915_private_t *dev_priv)
d521 2
d524 1
a524 1
	if (dev_priv->irq_enabled && (--dev_priv->user_irq_refcount == 0))
a534 5
	if (!dev_priv) {
		DRM_ERROR("called with no initialization\n");
		return EINVAL;
	}

d539 1
a539 1
		if (dev_priv->sarea_priv)
d542 1
d546 1
a546 1
	i915_user_irq_on(dev_priv);
d549 1
a549 1
	i915_user_irq_off(dev_priv);
a608 1
	u32	mask_reg = 0;
d610 1
d615 1
a615 1
		mask_reg |= I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
d619 1
a619 1
		mask_reg |= I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
d624 1
a624 1
		break;
d627 16
a642 18
	if (pipestat_reg)
	{
		pipestat = I915_READ (pipestat_reg);
		/*
		 * Older chips didn't have the start vblank interrupt,
		 * but 
		 */
		if (IS_I965G (dev))
			pipestat |= PIPE_START_VBLANK_INTERRUPT_ENABLE;
		else
			pipestat |= PIPE_VBLANK_INTERRUPT_ENABLE;
		/*
		 * Clear any pending status
		 */
		pipestat |= (PIPE_START_VBLANK_INTERRUPT_STATUS |
			     PIPE_VBLANK_INTERRUPT_STATUS);
		I915_WRITE(pipestat_reg, pipestat);
	}
d644 1
a644 1
	i915_enable_irq(dev_priv, mask_reg);
a654 1
	u32	mask_reg = 0;
d656 1
d661 1
a661 1
		mask_reg |= I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
d665 1
a665 1
		mask_reg |= I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
d670 1
a670 1
		break;
d674 1
a674 1
	i915_disable_irq(dev_priv, mask_reg);
d677 10
a686 29
	if (pipestat_reg)
	{
		pipestat = I915_READ (pipestat_reg);
		pipestat &= ~(PIPE_START_VBLANK_INTERRUPT_ENABLE |
			      PIPE_VBLANK_INTERRUPT_ENABLE);
		/*
		 * Clear any pending status
		 */
		pipestat |= (PIPE_START_VBLANK_INTERRUPT_STATUS |
			     PIPE_VBLANK_INTERRUPT_STATUS);
		I915_WRITE(pipestat_reg, pipestat);
		(void)I915_READ(pipestat_reg);
	}
}

void i915_enable_interrupt (struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;

	dev_priv->irq_mask_reg = ~0;
	I915_WRITE(IMR, dev_priv->irq_mask_reg);
	I915_WRITE(IER, I915_INTERRUPT_ENABLE_MASK);
	(void)I915_READ(IER);

#ifdef __linux__
	opregion_enable_asle(dev);
#endif

	dev_priv->irq_enabled = 1;
d886 1
a886 1
	I915_WRITE(IMR, 0x0);
a897 1
	dev_priv->user_irq_refcount = 0;
d907 4
a910 1
	i915_enable_interrupt(dev);
a930 1
	dev_priv->irq_enabled = 0;
@


1.8
log
@fix vblank interrupt mask. Unbreaks sync-to-vblank and anything that
needs the actual interrupts. Oops!
@
text
@d548 1
a548 1
		return -EINVAL;
d566 1
a566 1
	if (ret == -EBUSY) {
d590 1
a590 1
		return -EINVAL;
d597 1
a597 1
		return -EFAULT;
d613 1
a613 1
		return -EINVAL;
d734 1
a734 1
		return -EINVAL;
d748 1
a748 1
		return -EINVAL;
d772 1
a772 1
		return -EINVAL;
d777 1
a777 1
		return -EINVAL;
d784 1
a784 1
		return -EINVAL;
d794 1
a794 1
		return -EINVAL;
d807 1
a807 1
		return -EINVAL;
d830 1
a830 1
			return -EINVAL;
d852 1
a852 1
				return -EINVAL;
d884 1
a884 1
		return -EBUSY;
d892 1
a892 1
		return -ENOMEM;
@


1.7
log
@Add Interrupt mitigation for the i9XX user_irq, should save a bit of power;
from drm git.
@
text
@d41 2
a42 2
					I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT | \
					I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT)
@


1.6
log
@Kill the ifdefed out ttm interface stuff. The intel driver has
definitively gone for GEM so this will not be needed.

No binary change.
@
text
@d35 28
d406 1
a406 1
	    DRM_ERROR("trying to get vblank count for disabled pipe %d\n", pipe);
d434 1
a434 1
	u32 pipea_stats, pipeb_stats;
d438 1
d490 1
a490 1
	(void) I915_READ(IIR);
d526 2
a527 4
	if (dev_priv->irq_enabled && (++dev_priv->user_irq_refcount == 1)){
		dev_priv->irq_enable_reg |= I915_USER_INTERRUPT;
		I915_WRITE(IER, dev_priv->irq_enable_reg);
	}
d535 2
a536 4
	if (dev_priv->irq_enabled && (--dev_priv->user_irq_refcount == 0)) {
		//		dev_priv->irq_enable_reg &= ~I915_USER_INTERRUPT;
		//		I915_WRITE(IER, dev_priv->irq_enable_reg);
	}
d541 1
a541 1
static int i915_wait_irq(struct drm_device * dev, int irq_nr)
d546 5
d554 4
a557 1
	if (READ_BREADCRUMB(dev_priv) >= irq_nr)
d559 1
d624 1
d630 1
a630 1
		dev_priv->irq_enable_reg |= I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
d634 1
a634 1
		dev_priv->irq_enable_reg |= I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
d660 3
a662 1
	I915_WRITE(IER, dev_priv->irq_enable_reg);
d672 1
d678 1
a678 1
		dev_priv->irq_enable_reg &= ~I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
d682 1
a682 1
		dev_priv->irq_enable_reg &= ~I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
d690 3
a692 1
	I915_WRITE(IER, dev_priv->irq_enable_reg);
d705 1
d712 5
a716 2
	
	dev_priv->irq_enable_reg |= I915_USER_INTERRUPT;
a721 1
	I915_WRITE(IER, dev_priv->irq_enable_reg);
d921 3
a923 3
	I915_WRITE16(HWSTAM, 0xeffe);
	I915_WRITE16(IMR, 0x0);
	I915_WRITE16(IER, 0x0);
a930 1
	DRM_SPININIT(&dev_priv->swaps_lock, "swap");
a933 1
	DRM_SPININIT(&dev_priv->user_irq_lock, "userirq");
d935 1
a935 1
	dev_priv->irq_enable_reg = 0;
d962 2
@


1.5
log
@Update to DRM git.

Some stability fixes for radeon. The most part of this diff is related
to fixing up the VBLANK (vertical blank interrupt) handling. Now, if the
X driver supports the DRM_IOCTL_MODESET_CTL ioctl, (to be used when
changing the video modes), then allow the vblank to be disabled once
that ioctl has been called. Otherwise, keep the interrupt enabled at all
time, since disabling it otherwise will lead to problems.

Tested by a few. "no problem" on API/ABI deraadt@@.
@
text
@a464 3
#ifdef I915_HAVE_FENCE
		i915_fence_handler(dev);
#endif
@


1.4
log
@Update the inteldrm driver to drm git.

changes:
- Support for intel 4 series chipsets (i'll do any relavent agp bits for
these as soon as i grab the datasheet and find a testcase)
- fix scheduled buffer swaps on non 965 chipsets
- major reorder, dedup and general cleanup of register definition and
the header file

Tested by a few, no regressions
@
text
@a363 15
#if 0
static int i915_in_vblank(struct drm_device *dev, int pipe)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	unsigned long pipedsl, vblank, vtotal;
	unsigned long vbl_start, vbl_end, cur_line;

	pipedsl = pipe ? PIPEBDSL : PIPEADSL;
	vblank = pipe ? VBLANK_B : VBLANK_A;
	vtotal = pipe ? VTOTAL_B : VTOTAL_A;

	vbl_start = I915_READ(vblank) & VBLANK_START_MASK;
	vbl_end = (I915_READ(vblank) >> VBLANK_END_SHIFT) & VBLANK_END_MASK;

	cur_line = I915_READ(pipedsl);
a364 6
	if (cur_line >= vbl_start)
		return 1;

	return 0;
}
#endif
a397 16
	/*
	 * If we're in the middle of the vblank period, the
	 * above regs won't have been updated yet, so return
	 * an incremented count to stay accurate
	 */
#if 0
	if (i915_in_vblank(dev, pipe))
		count++;
#endif
	/* count may be reset by other driver(e.g. 2D driver), 
	   we have no way to know if it is wrapped or resetted 
	   when count is zero. do a rough guess.
	*/
	if (count == 0 && dev->last_vblank[pipe] < dev->max_vblank_count/2)
		dev->last_vblank[pipe] = 0; 
	
d410 1
a410 10
#if 0
	DRM_DEBUG("flag=%08x\n", iir);
#endif
	if (iir == 0) {
		DRM_DEBUG ("iir 0x%08x im 0x%08x ie 0x%08x pipea 0x%08x pipeb 0x%08x\n",
			   iir,
			   I915_READ(IMR),
			   I915_READ(IER),
			   I915_READ(PIPEASTAT),
			   I915_READ(PIPEBSTAT));
a411 1
	}
d430 8
d444 5
d452 5
d671 1
a671 1
static void i915_enable_interrupt (struct drm_device *dev)
d677 4
a690 1
	drm_i915_vblank_pipe_t *pipe = data;
a696 7
	if (pipe->pipe & ~(DRM_I915_VBLANK_PIPE_A|DRM_I915_VBLANK_PIPE_B)) {
		DRM_ERROR("called with invalid pipe 0x%x\n", pipe->pipe);
		return -EINVAL;
	}

	dev_priv->vblank_pipe = pipe->pipe;

a704 1
	u16 flag;
d711 1
a711 7
	flag = I915_READ(IER);

	pipe->pipe = 0;
	if (flag & I915_DISPLAY_PIPE_A_EVENT_INTERRUPT)
		pipe->pipe |= DRM_I915_VBLANK_PIPE_A;
	if (flag & I915_DISPLAY_PIPE_B_EVENT_INTERRUPT)
		pipe->pipe |= DRM_I915_VBLANK_PIPE_B;
d772 7
a778 1
	drm_update_vblank_count(dev, pipe);
d789 1
d811 1
d819 1
d843 1
d851 1
a856 6
	ret = drm_vblank_get(dev, pipe);
	if (ret) {
		drm_free(vbl_swap, sizeof(*vbl_swap), DRM_MEM_DRIVER);
		return ret;
	}

d903 1
@


1.3
log
@Update to DRM git as of a few days ago. This mostly affects the
card-specific files with a few minor changes elsewhere.

The main change to the OpenBSD specific stuff is the change to the irq
api due to the vblank rework.

4 more large bugs known, I have a fix for one.

Tested by many.  prompted by deraadt@@.
@
text
@d165 1
a165 1
	if (sarea_priv->front_tiled) {
d169 1
a169 1
	if (sarea_priv->back_tiled) {
d446 1
a446 1
	iir = I915_READ(I915REG_INT_IDENTITY_R);
d453 4
a456 4
			   I915_READ(I915REG_INT_MASK_R),
			   I915_READ(I915REG_INT_ENABLE_R),
			   I915_READ(I915REG_PIPEASTAT),
			   I915_READ(I915REG_PIPEBSTAT));
d465 3
a467 3
		pipea_stats = I915_READ(I915REG_PIPEASTAT);
		if (pipea_stats & (I915_START_VBLANK_INTERRUPT_STATUS|
				   I915_VBLANK_INTERRUPT_STATUS))
d472 2
a473 1
		I915_WRITE(I915REG_PIPEASTAT, pipea_stats);
d476 3
a478 3
		pipeb_stats = I915_READ(I915REG_PIPEBSTAT);
		if (pipeb_stats & (I915_START_VBLANK_INTERRUPT_STATUS|
				   I915_VBLANK_INTERRUPT_STATUS))
d483 1
a483 1
		I915_WRITE(I915REG_PIPEBSTAT, pipeb_stats);
d489 2
a490 2
	I915_WRITE(I915REG_INT_IDENTITY_R, iir);
	(void) I915_READ(I915REG_INT_IDENTITY_R); /* Flush posted write */
d520 1
a520 1
	OUT_RING(GFX_OP_USER_INTERRUPT);
d531 1
a531 1
		I915_WRITE(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d541 2
a542 2
		//		dev_priv->irq_enable_reg &= ~USER_INT_FLAG;
		//		I915_WRITE(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d626 1
a626 1
		pipestat_reg = I915REG_PIPEASTAT;
d630 1
a630 1
		pipestat_reg = I915REG_PIPEBSTAT;
d647 1
a647 1
			pipestat |= I915_START_VBLANK_INTERRUPT_ENABLE;
d649 1
a649 1
			pipestat |= I915_VBLANK_INTERRUPT_ENABLE;
d653 2
a654 2
		pipestat |= (I915_START_VBLANK_INTERRUPT_STATUS |
			     I915_VBLANK_INTERRUPT_STATUS);
d657 1
a657 1
	I915_WRITE(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d671 1
a671 1
		pipestat_reg = I915REG_PIPEASTAT;
d675 1
a675 1
		pipestat_reg = I915REG_PIPEBSTAT;
d684 2
a685 1
	I915_WRITE(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d689 2
a690 2
		pipestat &= ~(I915_START_VBLANK_INTERRUPT_ENABLE |
			      I915_VBLANK_INTERRUPT_ENABLE);
d694 2
a695 2
		pipestat |= (I915_START_VBLANK_INTERRUPT_STATUS |
			     I915_VBLANK_INTERRUPT_STATUS);
d706 1
a706 1
	I915_WRITE(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d745 2
a746 1
	flag = I915_READ(I915REG_INT_ENABLE_R);
d916 3
a918 3
	I915_WRITE16(I915REG_HWSTAM, 0xeffe);
	I915_WRITE16(I915REG_INT_MASK_R, 0x0);
	I915_WRITE16(I915REG_INT_ENABLE_R, 0x0);
a929 3
#ifdef __OpenBSD__
	mtx_init(&dev_priv->user_irq_lock, IPL_NONE);
#else
a930 1
#endif
d947 1
a947 1
	I915_WRITE(I915REG_INSTPM, (1 << 5) | (1 << 21));
d960 10
a969 10
	I915_WRITE(I915REG_HWSTAM, 0xffffffff);
	I915_WRITE(I915REG_INT_MASK_R, 0xffffffff);
	I915_WRITE(I915REG_INT_ENABLE_R, 0x0);

	temp = I915_READ(I915REG_PIPEASTAT);
	I915_WRITE(I915REG_PIPEASTAT, temp);
	temp = I915_READ(I915REG_PIPEBSTAT);
	I915_WRITE(I915REG_PIPEBSTAT, temp);
	temp = I915_READ(I915REG_INT_IDENTITY_R);
	I915_WRITE(I915REG_INT_IDENTITY_R, temp);
@


1.2
log
@When i first ported the drm, i completely misunderstood the FreeBSD taskqueue
api. So drm_locked_tasklet() is wrong.

Fix this up to be at least mostly correct.
@
text
@a33 4
#define USER_INT_FLAG (1<<1)
#define VSYNC_PIPEB_FLAG (1<<5)
#define VSYNC_PIPEA_FLAG (1<<7)

d41 3
a43 3
 * We need to get the pipe associated with a given plane to correctly perform
 * vblank driven swapping, and they may not always be equal.  So look up the
 * pipe associated with @@plane here.
d57 38
d151 1
a151 2
	unsigned counter[2] = { atomic_read(&dev->vbl_received),
				atomic_read(&dev->vbl_received2) };
d159 4
a162 2
	u32 pitchropcpp = (sarea_priv->pitch * cpp) | (0xcc << 16) |
			  (cpp << 23) | (1 << 24);
d164 12
d201 1
d293 23
a315 10
				BEGIN_LP_RING(6);

				OUT_RING(GFX_OP_DRAWRECT_INFO);
				OUT_RING(0);
				OUT_RING(0);
				OUT_RING(sarea_priv->width | sarea_priv->height << 16);
				OUT_RING(sarea_priv->width | sarea_priv->height << 16);
				OUT_RING(0);

				ADVANCE_LP_RING();
d340 1
a340 1
				OUT_RING(pitchropcpp);
d345 1
a345 1
				OUT_RING(pitchropcpp & 0xffff);
d364 73
d442 1
a442 1
	u16 temp;
d444 1
d446 1
a446 6
	pipea_stats = I915_READ(I915REG_PIPEASTAT);
	pipeb_stats = I915_READ(I915REG_PIPEBSTAT);

	temp = I915_READ16(I915REG_INT_IDENTITY_R);
	temp &= (dev_priv->irq_enable_reg | USER_INT_FLAG);

d448 1
a448 1
	DRM_DEBUG("%s flag=%08x\n", __FUNCTION__, temp);
d450 7
a456 1
	if (temp == 0)
d458 26
d485 2
a486 3
	I915_WRITE16(I915REG_INT_IDENTITY_R, temp);
	(void) I915_READ16(I915REG_INT_IDENTITY_R);
	DRM_READMEMORYBARRIER();
d488 2
a489 1
	dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
d491 1
a491 1
	if (temp & USER_INT_FLAG) {
d498 1
a498 19
	if (temp & (VSYNC_PIPEA_FLAG | VSYNC_PIPEB_FLAG)) {
		int vblank_pipe = dev_priv->vblank_pipe;

		if ((vblank_pipe &
		     (DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B))
		    == (DRM_I915_VBLANK_PIPE_A | DRM_I915_VBLANK_PIPE_B)) {
			if (temp & VSYNC_PIPEA_FLAG)
				atomic_inc(&dev->vbl_received);
			if (temp & VSYNC_PIPEB_FLAG)
				atomic_inc(&dev->vbl_received2);
		} else if (((temp & VSYNC_PIPEA_FLAG) &&
			    (vblank_pipe & DRM_I915_VBLANK_PIPE_A)) ||
			   ((temp & VSYNC_PIPEB_FLAG) &&
			    (vblank_pipe & DRM_I915_VBLANK_PIPE_B)))
			atomic_inc(&dev->vbl_received);

		DRM_WAKEUP(&dev->vbl_queue);
		drm_vbl_send_signals(dev);

a500 6
		I915_WRITE(I915REG_PIPEASTAT,
			pipea_stats|I915_VBLANK_INTERRUPT_ENABLE|
			I915_VBLANK_CLEAR);
		I915_WRITE(I915REG_PIPEBSTAT,
			pipeb_stats|I915_VBLANK_INTERRUPT_ENABLE|
			I915_VBLANK_CLEAR);
d513 1
a513 1
	DRM_DEBUG("%s\n", __FUNCTION__);
d529 2
a530 2
		dev_priv->irq_enable_reg |= USER_INT_FLAG;
		I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d541 1
a541 1
		//		I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d552 1
a552 1
	DRM_DEBUG("%s irq_nr=%d breadcrumb=%d\n", __FUNCTION__, irq_nr,
a557 2
	dev_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;

d564 1
a564 2
		DRM_ERROR("%s: EBUSY -- rec: %d emitted: %d\n",
			  __FUNCTION__,
d568 3
a570 1
	dev_priv->sarea_priv->last_dispatch = READ_BREADCRUMB(dev_priv);
a573 32
static int i915_driver_vblank_do_wait(struct drm_device *dev,
				      unsigned int *sequence,
				      atomic_t *counter)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned int cur_vblank;
	int ret = 0;

	if (!dev_priv) {
		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
		return -EINVAL;
	}

	DRM_WAIT_ON(ret, dev->vbl_queue, 3 * DRM_HZ,
		    (((cur_vblank = atomic_read(counter))
			- *sequence) <= (1<<23)));

	*sequence = cur_vblank;

	return ret;
}

int i915_driver_vblank_wait(struct drm_device *dev, unsigned int *sequence)
{
	return i915_driver_vblank_do_wait(dev, sequence, &dev->vbl_received);
}

int i915_driver_vblank_wait2(struct drm_device *dev, unsigned int *sequence)
{
	return i915_driver_vblank_do_wait(dev, sequence, &dev->vbl_received2);
}

d586 1
a586 1
		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
d609 1
a609 1
		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
d616 82
d701 2
d704 1
a704 7
	dev_priv->irq_enable_reg = USER_INT_FLAG;
	if (dev_priv->vblank_pipe & DRM_I915_VBLANK_PIPE_A)
		dev_priv->irq_enable_reg |= VSYNC_PIPEA_FLAG;
	if (dev_priv->vblank_pipe & DRM_I915_VBLANK_PIPE_B)
		dev_priv->irq_enable_reg |= VSYNC_PIPEB_FLAG;

	I915_WRITE16(I915REG_INT_ENABLE_R, dev_priv->irq_enable_reg);
d717 1
a717 1
		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
d722 1
a722 2
		DRM_ERROR("%s called with invalid pipe 0x%x\n",
			  __FUNCTION__, pipe->pipe);
a727 2
	i915_enable_interrupt (dev);

d739 1
a739 1
		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
d745 1
a745 1
	if (flag & VSYNC_PIPEA_FLAG)
d747 1
a747 1
	if (flag & VSYNC_PIPEB_FLAG)
d765 1
d772 1
a772 1
	if (dev_priv->sarea_priv->rotation) {
d809 2
a810 1
	curseq = atomic_read(pipe ? &dev->vbl_received2 : &dev->vbl_received);
d883 6
d899 1
a899 1
	list_add_tail((struct list_head *)vbl_swap, &dev_priv->vbl_swaps.head);
d918 1
a918 1
void i915_driver_irq_postinstall(struct drm_device * dev)
d921 1
d927 3
d931 1
d933 7
d949 1
d955 1
a955 1
	u16 temp;
d961 10
a970 6
	I915_WRITE16(I915REG_HWSTAM, 0xffff);
	I915_WRITE16(I915REG_INT_MASK_R, 0xffff);
	I915_WRITE16(I915REG_INT_ENABLE_R, 0x0);

	temp = I915_READ16(I915REG_INT_IDENTITY_R);
	I915_WRITE16(I915REG_INT_IDENTITY_R, temp);
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@a111 5
#ifdef __OpenBSD__
static void i915_vblank_tasklet(void * kdev, void * unused)
{
	struct drm_device *dev = (struct drm_device *)kdev;
#else
a113 1
#endif
@

