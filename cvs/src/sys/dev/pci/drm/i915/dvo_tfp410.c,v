head	1.7;
access;
symbols
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.6.0.8
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.6
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.4.0.10
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.8
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	KnwRPOZok9A30HI4;

1.6
date	2016.02.24.21.06.13;	author jsg;	state Exp;
branches;
next	1.5;
commitid	JgXu6nceb5ev8ENq;

1.5
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.4;
commitid	lQlppvmETCN49oZe;

1.4
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.08.13.10.23.49;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.30.12.36.50;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright Â© 2007 Dave Mueller
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Dave Mueller <dave.mueller@@gmx.ch>
 *
 */

#include "dvo.h"

/* register definitions according to the TFP410 data sheet */
#define TFP410_VID		0x014C
#define TFP410_DID		0x0410

#define TFP410_VID_LO		0x00
#define TFP410_VID_HI		0x01
#define TFP410_DID_LO		0x02
#define TFP410_DID_HI		0x03
#define TFP410_REV		0x04

#define TFP410_CTL_1		0x08
#define TFP410_CTL_1_TDIS	(1<<6)
#define TFP410_CTL_1_VEN	(1<<5)
#define TFP410_CTL_1_HEN	(1<<4)
#define TFP410_CTL_1_DSEL	(1<<3)
#define TFP410_CTL_1_BSEL	(1<<2)
#define TFP410_CTL_1_EDGE	(1<<1)
#define TFP410_CTL_1_PD		(1<<0)

#define TFP410_CTL_2		0x09
#define TFP410_CTL_2_VLOW	(1<<7)
#define TFP410_CTL_2_MSEL_MASK	(0x7<<4)
#define TFP410_CTL_2_MSEL	(1<<4)
#define TFP410_CTL_2_TSEL	(1<<3)
#define TFP410_CTL_2_RSEN	(1<<2)
#define TFP410_CTL_2_HTPLG	(1<<1)
#define TFP410_CTL_2_MDI	(1<<0)

#define TFP410_CTL_3		0x0A
#define TFP410_CTL_3_DK_MASK	(0x7<<5)
#define TFP410_CTL_3_DK		(1<<5)
#define TFP410_CTL_3_DKEN	(1<<4)
#define TFP410_CTL_3_CTL_MASK	(0x7<<1)
#define TFP410_CTL_3_CTL	(1<<1)

#define TFP410_USERCFG		0x0B

#define TFP410_DE_DLY		0x32

#define TFP410_DE_CTL		0x33
#define TFP410_DE_CTL_DEGEN	(1<<6)
#define TFP410_DE_CTL_VSPOL	(1<<5)
#define TFP410_DE_CTL_HSPOL	(1<<4)
#define TFP410_DE_CTL_DEDLY8	(1<<0)

#define TFP410_DE_TOP		0x34

#define TFP410_DE_CNT_LO	0x36
#define TFP410_DE_CNT_HI	0x37

#define TFP410_DE_LIN_LO	0x38
#define TFP410_DE_LIN_HI	0x39

#define TFP410_H_RES_LO		0x3A
#define TFP410_H_RES_HI		0x3B

#define TFP410_V_RES_LO		0x3C
#define TFP410_V_RES_HI		0x3D

struct tfp410_priv {
	bool quiet;
};

static bool tfp410_readb(struct intel_dvo_device *dvo, int addr, uint8_t *ch)
{
	struct tfp410_priv *tfp = dvo->dev_priv;
	struct i2c_adapter *adapter = dvo->i2c_bus;
	u8 out_buf[2];
	u8 in_buf[2];

	struct i2c_msg msgs[] = {
		{
			.addr = dvo->slave_addr,
			.flags = 0,
			.len = 1,
			.buf = out_buf,
		},
		{
			.addr = dvo->slave_addr,
			.flags = I2C_M_RD,
			.len = 1,
			.buf = in_buf,
		}
	};

	out_buf[0] = addr;
	out_buf[1] = 0;

	if (i2c_transfer(adapter, msgs, 2) == 2) {
		*ch = in_buf[0];
		return true;
	}

	if (!tfp->quiet) {
		DRM_DEBUG_KMS("Unable to read register 0x%02x from %s:%02x.\n",
			  addr, adapter->name, dvo->slave_addr);
	}
	return false;
}

static bool tfp410_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)
{
	struct tfp410_priv *tfp = dvo->dev_priv;
	struct i2c_adapter *adapter = dvo->i2c_bus;
	uint8_t out_buf[2];
	struct i2c_msg msg = {
		.addr = dvo->slave_addr,
		.flags = 0,
		.len = 2,
		.buf = out_buf,
	};

	out_buf[0] = addr;
	out_buf[1] = ch;

	if (i2c_transfer(adapter, &msg, 1) == 1)
		return true;

	if (!tfp->quiet) {
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d.\n",
			  addr, adapter->name, dvo->slave_addr);
	}

	return false;
}

static int tfp410_getid(struct intel_dvo_device *dvo, int addr)
{
	uint8_t ch1, ch2;

	if (tfp410_readb(dvo, addr+0, &ch1) &&
	    tfp410_readb(dvo, addr+1, &ch2))
		return ((ch2 << 8) & 0xFF00) | (ch1 & 0x00FF);

	return -1;
}

/* Ti TFP410 driver for chip on i2c bus */
static bool tfp410_init(struct intel_dvo_device *dvo,
			struct i2c_adapter *adapter)
{
	/* this will detect the tfp410 chip on the specified i2c bus */
	struct tfp410_priv *tfp;
	int id;

	tfp = kzalloc(sizeof(struct tfp410_priv), GFP_KERNEL);
	if (tfp == NULL)
		return false;

	dvo->i2c_bus = adapter;
	dvo->dev_priv = tfp;
	tfp->quiet = true;

	if ((id = tfp410_getid(dvo, TFP410_VID_LO)) != TFP410_VID) {
		DRM_DEBUG_KMS("tfp410 not detected got VID %X: from %s "
				"Slave %d.\n",
			  id, adapter->name, dvo->slave_addr);
		goto out;
	}

	if ((id = tfp410_getid(dvo, TFP410_DID_LO)) != TFP410_DID) {
		DRM_DEBUG_KMS("tfp410 not detected got DID %X: from %s "
				"Slave %d.\n",
			  id, adapter->name, dvo->slave_addr);
		goto out;
	}
	tfp->quiet = false;
	return true;
out:
	kfree(tfp);
	return false;
}

static enum drm_connector_status tfp410_detect(struct intel_dvo_device *dvo)
{
	enum drm_connector_status ret = connector_status_disconnected;
	uint8_t ctl2;

	if (tfp410_readb(dvo, TFP410_CTL_2, &ctl2)) {
		if (ctl2 & TFP410_CTL_2_RSEN)
			ret = connector_status_connected;
		else
			ret = connector_status_disconnected;
	}

	return ret;
}

static enum drm_mode_status tfp410_mode_valid(struct intel_dvo_device *dvo,
					      struct drm_display_mode *mode)
{
	return MODE_OK;
}

static void tfp410_mode_set(struct intel_dvo_device *dvo,
			    const struct drm_display_mode *mode,
			    const struct drm_display_mode *adjusted_mode)
{
	/* As long as the basics are set up, since we don't have clock dependencies
	* in the mode setup, we can just leave the registers alone and everything
	* will work fine.
	*/
	/* don't do much */
	return;
}

/* set the tfp410 power state */
static void tfp410_dpms(struct intel_dvo_device *dvo, bool enable)
{
	uint8_t ctl1;

	if (!tfp410_readb(dvo, TFP410_CTL_1, &ctl1))
		return;

	if (enable)
		ctl1 |= TFP410_CTL_1_PD;
	else
		ctl1 &= ~TFP410_CTL_1_PD;

	tfp410_writeb(dvo, TFP410_CTL_1, ctl1);
}

static bool tfp410_get_hw_state(struct intel_dvo_device *dvo)
{
	uint8_t ctl1;

	if (!tfp410_readb(dvo, TFP410_CTL_1, &ctl1))
		return false;

	if (ctl1 & TFP410_CTL_1_PD)
		return true;
	else
		return false;
}

static void tfp410_dump_regs(struct intel_dvo_device *dvo)
{
	uint8_t val, val2;

	tfp410_readb(dvo, TFP410_REV, &val);
	DRM_DEBUG_KMS("TFP410_REV: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_CTL_1, &val);
	DRM_DEBUG_KMS("TFP410_CTL1: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_CTL_2, &val);
	DRM_DEBUG_KMS("TFP410_CTL2: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_CTL_3, &val);
	DRM_DEBUG_KMS("TFP410_CTL3: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_USERCFG, &val);
	DRM_DEBUG_KMS("TFP410_USERCFG: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_DE_DLY, &val);
	DRM_DEBUG_KMS("TFP410_DE_DLY: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_DE_CTL, &val);
	DRM_DEBUG_KMS("TFP410_DE_CTL: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_DE_TOP, &val);
	DRM_DEBUG_KMS("TFP410_DE_TOP: 0x%02X\n", val);
	tfp410_readb(dvo, TFP410_DE_CNT_LO, &val);
	tfp410_readb(dvo, TFP410_DE_CNT_HI, &val2);
	DRM_DEBUG_KMS("TFP410_DE_CNT: 0x%02X%02X\n", val2, val);
	tfp410_readb(dvo, TFP410_DE_LIN_LO, &val);
	tfp410_readb(dvo, TFP410_DE_LIN_HI, &val2);
	DRM_DEBUG_KMS("TFP410_DE_LIN: 0x%02X%02X\n", val2, val);
	tfp410_readb(dvo, TFP410_H_RES_LO, &val);
	tfp410_readb(dvo, TFP410_H_RES_HI, &val2);
	DRM_DEBUG_KMS("TFP410_H_RES: 0x%02X%02X\n", val2, val);
	tfp410_readb(dvo, TFP410_V_RES_LO, &val);
	tfp410_readb(dvo, TFP410_V_RES_HI, &val2);
	DRM_DEBUG_KMS("TFP410_V_RES: 0x%02X%02X\n", val2, val);
}

static void tfp410_destroy(struct intel_dvo_device *dvo)
{
	struct tfp410_priv *tfp = dvo->dev_priv;

	if (tfp) {
		kfree(tfp);
		dvo->dev_priv = NULL;
	}
}

struct intel_dvo_dev_ops tfp410_ops = {
	.init = tfp410_init,
	.detect = tfp410_detect,
	.mode_valid = tfp410_mode_valid,
	.mode_set = tfp410_mode_set,
	.dpms = tfp410_dpms,
	.get_hw_state = tfp410_get_hw_state,
	.dump_regs = tfp410_dump_regs,
	.destroy = tfp410_destroy,
};
@


1.6
log
@Fix the build with DRMDEBUG.  Committing now instead of after unlock to
make it easier for people running release to diagnose drm problems.
ok deraadt@@
@
text
@a0 1
/*	$OpenBSD: dvo_tfp410.c,v 1.5 2015/09/23 23:12:11 kettenis Exp $	*/
d96 1
a96 1
	struct i2c_controller *adapter = dvo->i2c_bus;
d99 15
a113 1
	int ret;
d118 4
a121 9
	iic_acquire_bus(adapter, 0);
	ret = iic_exec(adapter, I2C_OP_READ_WITH_STOP, dvo->slave_addr,
	    out_buf, 1, in_buf, 1, 0);
	if (ret)
		goto read_err;
	iic_release_bus(adapter, 0);

	*ch = in_buf[0];
	return true;
a122 2
read_err:
	iic_release_bus(adapter, 0);
d124 2
a125 2
		DRM_DEBUG_KMS("Unable to read register 0x%02x from %02x.\n",
			  addr, dvo->slave_addr);
d133 1
a133 1
	struct i2c_controller *adapter = dvo->i2c_bus;
d135 6
a140 1
	int ret;
d145 2
a146 8
	iic_acquire_bus(adapter, 0);
	ret = iic_exec(adapter, I2C_OP_WRITE_WITH_STOP, dvo->slave_addr,
	    NULL, 0, out_buf, 2, 0);
	iic_release_bus(adapter, 0);
	if (ret)
		goto write_err;

	return true;
a147 1
write_err:
d149 2
a150 2
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %d.\n",
			  addr, dvo->slave_addr);
d169 1
a169 1
			struct i2c_controller *adapter)
d184 1
a184 1
		DRM_DEBUG_KMS("tfp410 not detected got VID %X: from "
d186 1
a186 1
			  id, dvo->slave_addr);
d191 1
a191 1
		DRM_DEBUG_KMS("tfp410 not detected got DID %X: from "
d193 1
a193 1
			  id, dvo->slave_addr);
d225 2
a226 2
			    struct drm_display_mode *mode,
			    struct drm_display_mode *adjusted_mode)
d270 1
a270 1
	DRM_LOG_KMS("TFP410_REV: 0x%02X\n", val);
d272 1
a272 1
	DRM_LOG_KMS("TFP410_CTL1: 0x%02X\n", val);
d274 1
a274 1
	DRM_LOG_KMS("TFP410_CTL2: 0x%02X\n", val);
d276 1
a276 1
	DRM_LOG_KMS("TFP410_CTL3: 0x%02X\n", val);
d278 1
a278 1
	DRM_LOG_KMS("TFP410_USERCFG: 0x%02X\n", val);
d280 1
a280 1
	DRM_LOG_KMS("TFP410_DE_DLY: 0x%02X\n", val);
d282 1
a282 1
	DRM_LOG_KMS("TFP410_DE_CTL: 0x%02X\n", val);
d284 1
a284 1
	DRM_LOG_KMS("TFP410_DE_TOP: 0x%02X\n", val);
d287 1
a287 1
	DRM_LOG_KMS("TFP410_DE_CNT: 0x%02X%02X\n", val2, val);
d290 1
a290 1
	DRM_LOG_KMS("TFP410_DE_LIN: 0x%02X%02X\n", val2, val);
d293 1
a293 1
	DRM_LOG_KMS("TFP410_H_RES: 0x%02X%02X\n", val2, val);
d296 1
a296 1
	DRM_LOG_KMS("TFP410_V_RES: 0x%02X%02X\n", val2, val);
@


1.5
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_tfp410.c,v 1.4 2014/01/21 08:57:22 kettenis Exp $	*/
d118 2
a119 2
		DRM_DEBUG_KMS("Unable to read register 0x%02x from %s:%02x.\n",
			  addr, adapter->name, dvo->slave_addr);
d145 2
a146 2
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d.\n",
			  addr, adapter->name, dvo->slave_addr);
d180 1
a180 1
		DRM_DEBUG_KMS("tfp410 not detected got VID %X: from %s "
d182 1
a182 1
			  id, adapter->name, dvo->slave_addr);
d187 1
a187 1
		DRM_DEBUG_KMS("tfp410 not detected got DID %X: from %s "
d189 1
a189 1
			  id, adapter->name, dvo->slave_addr);
@


1.4
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_tfp410.c,v 1.3 2013/08/13 10:23:49 jsg Exp $	*/
d118 2
a119 2
		DRM_DEBUG_KMS("Unable to read register 0x%02x from %02x.\n",
			  addr, dvo->slave_addr);
d145 2
a146 2
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %d.\n",
			  addr, dvo->slave_addr);
d180 1
a180 1
		DRM_DEBUG_KMS("tfp410 not detected got VID %X: from "
d182 1
a182 1
			  id, dvo->slave_addr);
d187 1
a187 1
		DRM_DEBUG_KMS("tfp410 not detected got DID %X: from "
d189 1
a189 1
			  id, dvo->slave_addr);
@


1.3
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_tfp410.c,v 1.2 2013/03/30 12:36:50 kettenis Exp $	*/
d171 1
a171 1
	tfp = malloc(sizeof(struct tfp410_priv), M_DRM, M_WAITOK | M_ZERO);
d195 1
a195 1
	free(tfp, M_DRM);
d300 1
a300 1
		free(tfp, M_DRM);
@


1.2
log
@Fix intel gmbus i2c code.  Not all transactions were handled correctly, and
on top of that, various iic_exec(9) calls were incorrect.  Doesn't seem to
handle SDVO yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_tfp410.c,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
d94 1
a94 16
bool tfp410_readb(struct intel_dvo_device *, int, uint8_t *);
bool tfp410_writeb(struct intel_dvo_device *, int, uint8_t);
int tfp410_getid(struct intel_dvo_device *, int);
bool tfp410_init(struct intel_dvo_device *, struct i2c_controller *);
enum drm_connector_status tfp410_detect(struct intel_dvo_device *);
enum drm_mode_status tfp410_mode_valid(struct intel_dvo_device *,
    struct drm_display_mode *);
void tfp410_mode_set(struct intel_dvo_device *, struct drm_display_mode *,
    struct drm_display_mode *);
void tfp410_dpms(struct intel_dvo_device *, bool);
bool tfp410_get_hw_state(struct intel_dvo_device *);
void tfp410_dump_regs(struct intel_dvo_device *);
void tfp410_destroy(struct intel_dvo_device *);

bool
tfp410_readb(struct intel_dvo_device *dvo, int addr, uint8_t *ch)
d124 1
a124 2
bool
tfp410_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)
d152 1
a152 2
int
tfp410_getid(struct intel_dvo_device *dvo, int addr)
d164 1
a164 2
bool
tfp410_init(struct intel_dvo_device *dvo,
d199 1
a199 2
enum drm_connector_status
tfp410_detect(struct intel_dvo_device *dvo)
d214 1
a214 2
enum drm_mode_status
tfp410_mode_valid(struct intel_dvo_device *dvo,
d220 1
a220 2
void
tfp410_mode_set(struct intel_dvo_device *dvo,
d233 1
a233 2
void
tfp410_dpms(struct intel_dvo_device *dvo, bool enable)
d248 1
a248 2
bool
tfp410_get_hw_state(struct intel_dvo_device *dvo)
d261 1
a261 2
void
tfp410_dump_regs(struct intel_dvo_device *dvo)
d295 1
a295 2
void
tfp410_destroy(struct intel_dvo_device *dvo)
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a115 1
	uint8_t cmd = 0;
a120 4
	ret = iic_exec(adapter, I2C_OP_WRITE_WITH_STOP, dvo->slave_addr,
	    &cmd, 1, out_buf, 1, 0);
	if (ret)
		goto read_err;
d122 1
a122 1
	    &cmd, 1, in_buf, 1, 0);
a145 1
	uint8_t cmd = 0;
d152 1
a152 1
	    &cmd, 1, out_buf, 2, 0);
@

