head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.8
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.2.0.6
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.2.0.2
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.1.0.12
	OPENBSD_5_8_BASE:1.1
	OPENBSD_5_7:1.1.0.10
	OPENBSD_5_7_BASE:1.1
	OPENBSD_5_6:1.1.0.8
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.6
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.2
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.1;
commitid	lQlppvmETCN49oZe;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@/*	$OpenBSD: dvo.h,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
/*
 * Copyright Â© 2006 Eric Anholt
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 */

#ifndef _INTEL_DVO_H
#define _INTEL_DVO_H

#include <sys/types.h>
#include <sys/device.h>
#include <dev/i2c/i2cvar.h>
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_crtc.h>
#include "intel_drv.h"

struct intel_dvo_device {
	const char *name;
	int type;
	/* DVOA/B/C output register */
	u32 dvo_reg;
	/* GPIO register used for i2c bus to control this device */
	u32 gpio;
	int slave_addr;

	const struct intel_dvo_dev_ops *dev_ops;
	void *dev_priv;
	struct i2c_controller *i2c_bus;
};

struct intel_dvo_dev_ops {
	/*
	 * Initialize the device at startup time.
	 * Returns NULL if the device does not exist.
	 */
	bool (*init)(struct intel_dvo_device *dvo,
		     struct i2c_controller *i2cbus);

	/*
	 * Called to allow the output a chance to create properties after the
	 * RandR objects have been created.
	 */
	void (*create_resources)(struct intel_dvo_device *dvo);

	/*
	 * Turn on/off output.
	 *
	 * Because none of our dvo drivers support an intermediate power levels,
	 * we don't expose this in the interfac.
	 */
	void (*dpms)(struct intel_dvo_device *dvo, bool enable);

	/*
	 * Callback for testing a video mode for a given output.
	 *
	 * This function should only check for cases where a mode can't
	 * be supported on the output specifically, and not represent
	 * generic CRTC limitations.
	 *
	 * \return MODE_OK if the mode is valid, or another MODE_* otherwise.
	 */
	int (*mode_valid)(struct intel_dvo_device *dvo,
			  struct drm_display_mode *mode);

	/*
	 * Callback for preparing mode changes on an output
	 */
	void (*prepare)(struct intel_dvo_device *dvo);

	/*
	 * Callback for committing mode changes on an output
	 */
	void (*commit)(struct intel_dvo_device *dvo);

	/*
	 * Callback for setting up a video mode after fixups have been made.
	 *
	 * This is only called while the output is disabled.  The dpms callback
	 * must be all that's necessary for the output, to turn the output on
	 * after this function is called.
	 */
	void (*mode_set)(struct intel_dvo_device *dvo,
			 struct drm_display_mode *mode,
			 struct drm_display_mode *adjusted_mode);

	/*
	 * Probe for a connected output, and return detect_status.
	 */
	enum drm_connector_status (*detect)(struct intel_dvo_device *dvo);

	/*
	 * Probe the current hw status, returning true if the connected output
	 * is active.
	 */
	bool (*get_hw_state)(struct intel_dvo_device *dev);

	/**
	 * Query the device for the modes it provides.
	 *
	 * This function may also update MonInfo, mm_width, and mm_height.
	 *
	 * \return singly-linked list of modes or NULL if no modes found.
	 */
	struct drm_display_mode *(*get_modes)(struct intel_dvo_device *dvo);

	/**
	 * Clean up driver-specific bits of the output
	 */
	void (*destroy) (struct intel_dvo_device *dvo);

	/**
	 * Debugging hook to dump device registers to log file
	 */
	void (*dump_regs)(struct intel_dvo_device *dvo);
};

extern struct intel_dvo_dev_ops sil164_ops;
extern struct intel_dvo_dev_ops ch7xxx_ops;
extern struct intel_dvo_dev_ops ivch_ops;
extern struct intel_dvo_dev_ops tfp410_ops;
extern struct intel_dvo_dev_ops ch7017_ops;
extern struct intel_dvo_dev_ops ns2501_ops;

#endif /* _INTEL_DVO_H */
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a80 11

	/*
	 * Callback to adjust the mode to be set in the CRTC.
	 *
	 * This allows an output to adjust the clock or even the entire set of
	 * timings, which is used for panels with fixed timings or for
	 * buses with clock limitations.
	 */
	bool (*mode_fixup)(struct intel_dvo_device *dvo,
			   const struct drm_display_mode *mode,
			   struct drm_display_mode *adjusted_mode);
@

