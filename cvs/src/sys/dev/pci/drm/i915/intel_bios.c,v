head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.4
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2017.07.02.20.58.55;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	3X20l6oWqChtP7LU;

1.12
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	KnwRPOZok9A30HI4;

1.11
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	lQlppvmETCN49oZe;

1.10
date	2015.04.06.12.25.10;	author jsg;	state Exp;
branches;
next	1.9;
commitid	CN1fAwudhSb2ckyl;

1.9
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	adfbJ0ccUTdhFGhI;

1.8
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.21.04.47.38;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.13.10.23.50;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.07.04.09.52.29;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.18.13.06.37;	author mpi;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Enable MIPI/DSI support for inteldrm(4).  Makes the display on my ASUS
Transformer Book T100HA work (with some ugly error/warning messages).
@
text
@/*
 * Copyright Â© 2006 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */
#ifdef __linux__
#include <linux/dmi.h>
#include <drm/drm_dp_helper.h>
#include <drm/drmP.h>
#include <drm/i915_drm.h>
#else
#include <dev/pci/drm/drm_dp_helper.h>
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/i915_drm.h>
#endif
#include "i915_drv.h"
#include "intel_bios.h"

#define	SLAVE_ADDR1	0x70
#define	SLAVE_ADDR2	0x72

static int panel_type;

static const void *
find_section(const void *_bdb, int section_id)
{
	const struct bdb_header *bdb = _bdb;
	const u8 *base = _bdb;
	int index = 0;
	u32 total, current_size;
	u8 current_id;

	/* skip to first section */
	index += bdb->header_size;
	total = bdb->bdb_size;

	/* walk the sections looking for section_id */
	while (index + 3 < total) {
		current_id = *(base + index);
		index++;

		current_size = *((const u16 *)(base + index));
		index += 2;

		/* The MIPI Sequence Block v3+ has a separate size field. */
		if (current_id == BDB_MIPI_SEQUENCE && *(base + index) >= 3)
			current_size = *((const u32 *)(base + index + 1));

		if (index + current_size > total)
			return NULL;

		if (current_id == section_id)
			return base + index;

		index += current_size;
	}

	return NULL;
}

static u16
get_blocksize(const void *p)
{
	u16 *block_ptr, block_size;

	block_ptr = (u16 *)((char *)p - 2);
	block_size = *block_ptr;
	return block_size;
}

static void
fill_detail_timing_data(struct drm_display_mode *panel_fixed_mode,
			const struct lvds_dvo_timing *dvo_timing)
{
	panel_fixed_mode->hdisplay = (dvo_timing->hactive_hi << 8) |
		dvo_timing->hactive_lo;
	panel_fixed_mode->hsync_start = panel_fixed_mode->hdisplay +
		((dvo_timing->hsync_off_hi << 8) | dvo_timing->hsync_off_lo);
	panel_fixed_mode->hsync_end = panel_fixed_mode->hsync_start +
		dvo_timing->hsync_pulse_width;
	panel_fixed_mode->htotal = panel_fixed_mode->hdisplay +
		((dvo_timing->hblank_hi << 8) | dvo_timing->hblank_lo);

	panel_fixed_mode->vdisplay = (dvo_timing->vactive_hi << 8) |
		dvo_timing->vactive_lo;
	panel_fixed_mode->vsync_start = panel_fixed_mode->vdisplay +
		dvo_timing->vsync_off;
	panel_fixed_mode->vsync_end = panel_fixed_mode->vsync_start +
		dvo_timing->vsync_pulse_width;
	panel_fixed_mode->vtotal = panel_fixed_mode->vdisplay +
		((dvo_timing->vblank_hi << 8) | dvo_timing->vblank_lo);
	panel_fixed_mode->clock = dvo_timing->clock * 10;
	panel_fixed_mode->type = DRM_MODE_TYPE_PREFERRED;

	if (dvo_timing->hsync_positive)
		panel_fixed_mode->flags |= DRM_MODE_FLAG_PHSYNC;
	else
		panel_fixed_mode->flags |= DRM_MODE_FLAG_NHSYNC;

	if (dvo_timing->vsync_positive)
		panel_fixed_mode->flags |= DRM_MODE_FLAG_PVSYNC;
	else
		panel_fixed_mode->flags |= DRM_MODE_FLAG_NVSYNC;

	/* Some VBTs have bogus h/vtotal values */
	if (panel_fixed_mode->hsync_end > panel_fixed_mode->htotal)
		panel_fixed_mode->htotal = panel_fixed_mode->hsync_end + 1;
	if (panel_fixed_mode->vsync_end > panel_fixed_mode->vtotal)
		panel_fixed_mode->vtotal = panel_fixed_mode->vsync_end + 1;

	drm_mode_set_name(panel_fixed_mode);
}

static const struct lvds_dvo_timing *
get_lvds_dvo_timing(const struct bdb_lvds_lfp_data *lvds_lfp_data,
		    const struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs,
		    int index)
{
	/*
	 * the size of fp_timing varies on the different platform.
	 * So calculate the DVO timing relative offset in LVDS data
	 * entry to get the DVO timing entry
	 */

	int lfp_data_size =
		lvds_lfp_data_ptrs->ptr[1].dvo_timing_offset -
		lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset;
	int dvo_timing_offset =
		lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset -
		lvds_lfp_data_ptrs->ptr[0].fp_timing_offset;
	char *entry = (char *)lvds_lfp_data->data + lfp_data_size * index;

	return (struct lvds_dvo_timing *)(entry + dvo_timing_offset);
}

/* get lvds_fp_timing entry
 * this function may return NULL if the corresponding entry is invalid
 */
static const struct lvds_fp_timing *
get_lvds_fp_timing(const struct bdb_header *bdb,
		   const struct bdb_lvds_lfp_data *data,
		   const struct bdb_lvds_lfp_data_ptrs *ptrs,
		   int index)
{
	size_t data_ofs = (const u8 *)data - (const u8 *)bdb;
	u16 data_size = ((const u16 *)data)[-1]; /* stored in header */
	size_t ofs;

	if (index >= ARRAY_SIZE(ptrs->ptr))
		return NULL;
	ofs = ptrs->ptr[index].fp_timing_offset;
	if (ofs < data_ofs ||
	    ofs + sizeof(struct lvds_fp_timing) > data_ofs + data_size)
		return NULL;
	return (const struct lvds_fp_timing *)((const u8 *)bdb + ofs);
}

/* Try to find integrated panel data */
static void
parse_lfp_panel_data(struct drm_i915_private *dev_priv,
		     const struct bdb_header *bdb)
{
	const struct bdb_lvds_options *lvds_options;
	const struct bdb_lvds_lfp_data *lvds_lfp_data;
	const struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs;
	const struct lvds_dvo_timing *panel_dvo_timing;
	const struct lvds_fp_timing *fp_timing;
	struct drm_display_mode *panel_fixed_mode;
	int drrs_mode;

	lvds_options = find_section(bdb, BDB_LVDS_OPTIONS);
	if (!lvds_options)
		return;

	dev_priv->vbt.lvds_dither = lvds_options->pixel_dither;
	if (lvds_options->panel_type == 0xff)
		return;

	panel_type = lvds_options->panel_type;

	drrs_mode = (lvds_options->dps_panel_type_bits
				>> (panel_type * 2)) & MODE_MASK;
	/*
	 * VBT has static DRRS = 0 and seamless DRRS = 2.
	 * The below piece of code is required to adjust vbt.drrs_type
	 * to match the enum drrs_support_type.
	 */
	switch (drrs_mode) {
	case 0:
		dev_priv->vbt.drrs_type = STATIC_DRRS_SUPPORT;
		DRM_DEBUG_KMS("DRRS supported mode is static\n");
		break;
	case 2:
		dev_priv->vbt.drrs_type = SEAMLESS_DRRS_SUPPORT;
		DRM_DEBUG_KMS("DRRS supported mode is seamless\n");
		break;
	default:
		dev_priv->vbt.drrs_type = DRRS_NOT_SUPPORTED;
		DRM_DEBUG_KMS("DRRS not supported (VBT input)\n");
		break;
	}

	lvds_lfp_data = find_section(bdb, BDB_LVDS_LFP_DATA);
	if (!lvds_lfp_data)
		return;

	lvds_lfp_data_ptrs = find_section(bdb, BDB_LVDS_LFP_DATA_PTRS);
	if (!lvds_lfp_data_ptrs)
		return;

	dev_priv->vbt.lvds_vbt = 1;

	panel_dvo_timing = get_lvds_dvo_timing(lvds_lfp_data,
					       lvds_lfp_data_ptrs,
					       lvds_options->panel_type);

	panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);
	if (!panel_fixed_mode)
		return;

	fill_detail_timing_data(panel_fixed_mode, panel_dvo_timing);

	dev_priv->vbt.lfp_lvds_vbt_mode = panel_fixed_mode;

	DRM_DEBUG_KMS("Found panel mode in BIOS VBT tables:\n");
	drm_mode_debug_printmodeline(panel_fixed_mode);

	fp_timing = get_lvds_fp_timing(bdb, lvds_lfp_data,
				       lvds_lfp_data_ptrs,
				       lvds_options->panel_type);
	if (fp_timing) {
		/* check the resolution, just to be sure */
		if (fp_timing->x_res == panel_fixed_mode->hdisplay &&
		    fp_timing->y_res == panel_fixed_mode->vdisplay) {
			dev_priv->vbt.bios_lvds_val = fp_timing->lvds_reg_val;
			DRM_DEBUG_KMS("VBT initial LVDS value %x\n",
				      dev_priv->vbt.bios_lvds_val);
		}
	}
}

static void
parse_lfp_backlight(struct drm_i915_private *dev_priv,
		    const struct bdb_header *bdb)
{
	const struct bdb_lfp_backlight_data *backlight_data;
	const struct bdb_lfp_backlight_data_entry *entry;

	backlight_data = find_section(bdb, BDB_LVDS_BACKLIGHT);
	if (!backlight_data)
		return;

	if (backlight_data->entry_size != sizeof(backlight_data->data[0])) {
		DRM_DEBUG_KMS("Unsupported backlight data entry size %u\n",
			      backlight_data->entry_size);
		return;
	}

	entry = &backlight_data->data[panel_type];

	dev_priv->vbt.backlight.present = entry->type == BDB_BACKLIGHT_TYPE_PWM;
	if (!dev_priv->vbt.backlight.present) {
		DRM_DEBUG_KMS("PWM backlight not present in VBT (type %u)\n",
			      entry->type);
		return;
	}

	dev_priv->vbt.backlight.pwm_freq_hz = entry->pwm_freq_hz;
	dev_priv->vbt.backlight.active_low_pwm = entry->active_low_pwm;
	dev_priv->vbt.backlight.min_brightness = entry->min_brightness;
	DRM_DEBUG_KMS("VBT backlight PWM modulation frequency %u Hz, "
		      "active %s, min brightness %u, level %u\n",
		      dev_priv->vbt.backlight.pwm_freq_hz,
		      dev_priv->vbt.backlight.active_low_pwm ? "low" : "high",
		      dev_priv->vbt.backlight.min_brightness,
		      backlight_data->level[panel_type]);
}

/* Try to find sdvo panel data */
static void
parse_sdvo_panel_data(struct drm_i915_private *dev_priv,
		      const struct bdb_header *bdb)
{
	const struct lvds_dvo_timing *dvo_timing;
	struct drm_display_mode *panel_fixed_mode;
	int index;

	index = i915.vbt_sdvo_panel_type;
	if (index == -2) {
		DRM_DEBUG_KMS("Ignore SDVO panel mode from BIOS VBT tables.\n");
		return;
	}

	if (index == -1) {
		const struct bdb_sdvo_lvds_options *sdvo_lvds_options;

		sdvo_lvds_options = find_section(bdb, BDB_SDVO_LVDS_OPTIONS);
		if (!sdvo_lvds_options)
			return;

		index = sdvo_lvds_options->panel_type;
	}

	dvo_timing = find_section(bdb, BDB_SDVO_PANEL_DTDS);
	if (!dvo_timing)
		return;

	panel_fixed_mode = kzalloc(sizeof(*panel_fixed_mode), GFP_KERNEL);
	if (!panel_fixed_mode)
		return;

	fill_detail_timing_data(panel_fixed_mode, dvo_timing + index);

	dev_priv->vbt.sdvo_lvds_vbt_mode = panel_fixed_mode;

	DRM_DEBUG_KMS("Found SDVO panel mode in BIOS VBT tables:\n");
	drm_mode_debug_printmodeline(panel_fixed_mode);
}

static int intel_bios_ssc_frequency(struct drm_device *dev,
				    bool alternate)
{
	switch (INTEL_INFO(dev)->gen) {
	case 2:
		return alternate ? 66667 : 48000;
	case 3:
	case 4:
		return alternate ? 100000 : 96000;
	default:
		return alternate ? 100000 : 120000;
	}
}

static void
parse_general_features(struct drm_i915_private *dev_priv,
		       const struct bdb_header *bdb)
{
	struct drm_device *dev = dev_priv->dev;
	const struct bdb_general_features *general;

	general = find_section(bdb, BDB_GENERAL_FEATURES);
	if (general) {
		dev_priv->vbt.int_tv_support = general->int_tv_support;
		dev_priv->vbt.int_crt_support = general->int_crt_support;
		dev_priv->vbt.lvds_use_ssc = general->enable_ssc;
		dev_priv->vbt.lvds_ssc_freq =
			intel_bios_ssc_frequency(dev, general->ssc_freq);
		dev_priv->vbt.display_clock_mode = general->display_clock_mode;
		dev_priv->vbt.fdi_rx_polarity_inverted = general->fdi_rx_polarity_inverted;
		DRM_DEBUG_KMS("BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d fdi_rx_polarity_inverted %d\n",
			      dev_priv->vbt.int_tv_support,
			      dev_priv->vbt.int_crt_support,
			      dev_priv->vbt.lvds_use_ssc,
			      dev_priv->vbt.lvds_ssc_freq,
			      dev_priv->vbt.display_clock_mode,
			      dev_priv->vbt.fdi_rx_polarity_inverted);
	}
}

static void
parse_general_definitions(struct drm_i915_private *dev_priv,
			  const struct bdb_header *bdb)
{
	const struct bdb_general_definitions *general;

	general = find_section(bdb, BDB_GENERAL_DEFINITIONS);
	if (general) {
		u16 block_size = get_blocksize(general);
		if (block_size >= sizeof(*general)) {
			int bus_pin = general->crt_ddc_gmbus_pin;
			DRM_DEBUG_KMS("crt_ddc_bus_pin: %d\n", bus_pin);
			if (intel_gmbus_is_valid_pin(dev_priv, bus_pin))
				dev_priv->vbt.crt_ddc_pin = bus_pin;
		} else {
			DRM_DEBUG_KMS("BDB_GD too small (%d). Invalid.\n",
				      block_size);
		}
	}
}

static const union child_device_config *
child_device_ptr(const struct bdb_general_definitions *p_defs, int i)
{
	return (const void *) &p_defs->devices[i * p_defs->child_dev_size];
}

static void
parse_sdvo_device_mapping(struct drm_i915_private *dev_priv,
			  const struct bdb_header *bdb)
{
	struct sdvo_device_mapping *p_mapping;
	const struct bdb_general_definitions *p_defs;
	const struct old_child_dev_config *child; /* legacy */
	int i, child_device_num, count;
	u16	block_size;

	p_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);
	if (!p_defs) {
		DRM_DEBUG_KMS("No general definition block is found, unable to construct sdvo mapping.\n");
		return;
	}

	/*
	 * Only parse SDVO mappings when the general definitions block child
	 * device size matches that of the *legacy* child device config
	 * struct. Thus, SDVO mapping will be skipped for newer VBT.
	 */
	if (p_defs->child_dev_size != sizeof(*child)) {
		DRM_DEBUG_KMS("Unsupported child device size for SDVO mapping.\n");
		return;
	}
	/* get the block size of general definitions */
	block_size = get_blocksize(p_defs);
	/* get the number of child device */
	child_device_num = (block_size - sizeof(*p_defs)) /
		p_defs->child_dev_size;
	count = 0;
	for (i = 0; i < child_device_num; i++) {
		child = &child_device_ptr(p_defs, i)->old;
		if (!child->device_type) {
			/* skip the device block if device type is invalid */
			continue;
		}
		if (child->slave_addr != SLAVE_ADDR1 &&
		    child->slave_addr != SLAVE_ADDR2) {
			/*
			 * If the slave address is neither 0x70 nor 0x72,
			 * it is not a SDVO device. Skip it.
			 */
			continue;
		}
		if (child->dvo_port != DEVICE_PORT_DVOB &&
		    child->dvo_port != DEVICE_PORT_DVOC) {
			/* skip the incorrect SDVO port */
			DRM_DEBUG_KMS("Incorrect SDVO port. Skip it\n");
			continue;
		}
		DRM_DEBUG_KMS("the SDVO device with slave addr %2x is found on"
			      " %s port\n",
			      child->slave_addr,
			      (child->dvo_port == DEVICE_PORT_DVOB) ?
			      "SDVOB" : "SDVOC");
		p_mapping = &(dev_priv->sdvo_mappings[child->dvo_port - 1]);
		if (!p_mapping->initialized) {
			p_mapping->dvo_port = child->dvo_port;
			p_mapping->slave_addr = child->slave_addr;
			p_mapping->dvo_wiring = child->dvo_wiring;
			p_mapping->ddc_pin = child->ddc_pin;
			p_mapping->i2c_pin = child->i2c_pin;
			p_mapping->initialized = 1;
			DRM_DEBUG_KMS("SDVO device: dvo=%x, addr=%x, wiring=%d, ddc_pin=%d, i2c_pin=%d\n",
				      p_mapping->dvo_port,
				      p_mapping->slave_addr,
				      p_mapping->dvo_wiring,
				      p_mapping->ddc_pin,
				      p_mapping->i2c_pin);
		} else {
			DRM_DEBUG_KMS("Maybe one SDVO port is shared by "
					 "two SDVO device.\n");
		}
		if (child->slave2_addr) {
			/* Maybe this is a SDVO device with multiple inputs */
			/* And the mapping info is not added */
			DRM_DEBUG_KMS("there exists the slave2_addr. Maybe this"
				" is a SDVO device with multiple inputs.\n");
		}
		count++;
	}

	if (!count) {
		/* No SDVO device info is found */
		DRM_DEBUG_KMS("No SDVO device info is found in VBT\n");
	}
	return;
}

static void
parse_driver_features(struct drm_i915_private *dev_priv,
		      const struct bdb_header *bdb)
{
	const struct bdb_driver_features *driver;

	driver = find_section(bdb, BDB_DRIVER_FEATURES);
	if (!driver)
		return;

	if (driver->lvds_config == BDB_DRIVER_FEATURE_EDP)
		dev_priv->vbt.edp_support = 1;

	if (driver->dual_frequency)
		dev_priv->render_reclock_avail = true;

	DRM_DEBUG_KMS("DRRS State Enabled:%d\n", driver->drrs_enabled);
	/*
	 * If DRRS is not supported, drrs_type has to be set to 0.
	 * This is because, VBT is configured in such a way that
	 * static DRRS is 0 and DRRS not supported is represented by
	 * driver->drrs_enabled=false
	 */
	if (!driver->drrs_enabled)
		dev_priv->vbt.drrs_type = DRRS_NOT_SUPPORTED;
}

static void
parse_edp(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
{
	const struct bdb_edp *edp;
	const struct edp_power_seq *edp_pps;
	const struct edp_link_params *edp_link_params;

	edp = find_section(bdb, BDB_EDP);
	if (!edp) {
		if (dev_priv->vbt.edp_support)
			DRM_DEBUG_KMS("No eDP BDB found but eDP panel supported.\n");
		return;
	}

	switch ((edp->color_depth >> (panel_type * 2)) & 3) {
	case EDP_18BPP:
		dev_priv->vbt.edp_bpp = 18;
		break;
	case EDP_24BPP:
		dev_priv->vbt.edp_bpp = 24;
		break;
	case EDP_30BPP:
		dev_priv->vbt.edp_bpp = 30;
		break;
	}

	/* Get the eDP sequencing and link info */
	edp_pps = &edp->power_seqs[panel_type];
	edp_link_params = &edp->link_params[panel_type];

	dev_priv->vbt.edp_pps = *edp_pps;

	switch (edp_link_params->rate) {
	case EDP_RATE_1_62:
		dev_priv->vbt.edp_rate = DP_LINK_BW_1_62;
		break;
	case EDP_RATE_2_7:
		dev_priv->vbt.edp_rate = DP_LINK_BW_2_7;
		break;
	default:
		DRM_DEBUG_KMS("VBT has unknown eDP link rate value %u\n",
			      edp_link_params->rate);
		break;
	}

	switch (edp_link_params->lanes) {
	case EDP_LANE_1:
		dev_priv->vbt.edp_lanes = 1;
		break;
	case EDP_LANE_2:
		dev_priv->vbt.edp_lanes = 2;
		break;
	case EDP_LANE_4:
		dev_priv->vbt.edp_lanes = 4;
		break;
	default:
		DRM_DEBUG_KMS("VBT has unknown eDP lane count value %u\n",
			      edp_link_params->lanes);
		break;
	}

	switch (edp_link_params->preemphasis) {
	case EDP_PREEMPHASIS_NONE:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_0;
		break;
	case EDP_PREEMPHASIS_3_5dB:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_1;
		break;
	case EDP_PREEMPHASIS_6dB:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_2;
		break;
	case EDP_PREEMPHASIS_9_5dB:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPH_LEVEL_3;
		break;
	default:
		DRM_DEBUG_KMS("VBT has unknown eDP pre-emphasis value %u\n",
			      edp_link_params->preemphasis);
		break;
	}

	switch (edp_link_params->vswing) {
	case EDP_VSWING_0_4V:
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_0;
		break;
	case EDP_VSWING_0_6V:
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_1;
		break;
	case EDP_VSWING_0_8V:
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
		break;
	case EDP_VSWING_1_2V:
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
		break;
	default:
		DRM_DEBUG_KMS("VBT has unknown eDP voltage swing value %u\n",
			      edp_link_params->vswing);
		break;
	}

	if (bdb->version >= 173) {
		uint8_t vswing;

		/* Don't read from VBT if module parameter has valid value*/
		if (i915.edp_vswing) {
			dev_priv->edp_low_vswing = i915.edp_vswing == 1;
		} else {
			vswing = (edp->edp_vswing_preemph >> (panel_type * 4)) & 0xF;
			dev_priv->edp_low_vswing = vswing == 0;
		}
	}
}

static void
parse_psr(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
{
	const struct bdb_psr *psr;
	const struct psr_table *psr_table;

	psr = find_section(bdb, BDB_PSR);
	if (!psr) {
		DRM_DEBUG_KMS("No PSR BDB found.\n");
		return;
	}

	psr_table = &psr->psr_table[panel_type];

	dev_priv->vbt.psr.full_link = psr_table->full_link;
	dev_priv->vbt.psr.require_aux_wakeup = psr_table->require_aux_to_wakeup;

	/* Allowed VBT values goes from 0 to 15 */
	dev_priv->vbt.psr.idle_frames = psr_table->idle_frames < 0 ? 0 :
		psr_table->idle_frames > 15 ? 15 : psr_table->idle_frames;

	switch (psr_table->lines_to_wait) {
	case 0:
		dev_priv->vbt.psr.lines_to_wait = PSR_0_LINES_TO_WAIT;
		break;
	case 1:
		dev_priv->vbt.psr.lines_to_wait = PSR_1_LINE_TO_WAIT;
		break;
	case 2:
		dev_priv->vbt.psr.lines_to_wait = PSR_4_LINES_TO_WAIT;
		break;
	case 3:
		dev_priv->vbt.psr.lines_to_wait = PSR_8_LINES_TO_WAIT;
		break;
	default:
		DRM_DEBUG_KMS("VBT has unknown PSR lines to wait %u\n",
			      psr_table->lines_to_wait);
		break;
	}

	dev_priv->vbt.psr.tp1_wakeup_time = psr_table->tp1_wakeup_time;
	dev_priv->vbt.psr.tp2_tp3_wakeup_time = psr_table->tp2_tp3_wakeup_time;
}

static u8 *goto_next_sequence(u8 *data, int *size)
{
	u16 len;
	int tmp = *size;

	if (--tmp < 0)
		return NULL;

	/* goto first element */
	data++;
	while (1) {
		switch (*data) {
		case MIPI_SEQ_ELEM_SEND_PKT:
			/*
			 * skip by this element payload size
			 * skip elem id, command flag and data type
			 */
			tmp -= 5;
			if (tmp < 0)
				return NULL;

			data += 3;
			len = *((u16 *)data);

			tmp -= len;
			if (tmp < 0)
				return NULL;

			/* skip by len */
			data = data + 2 + len;
			break;
		case MIPI_SEQ_ELEM_DELAY:
			/* skip by elem id, and delay is 4 bytes */
			tmp -= 5;
			if (tmp < 0)
				return NULL;

			data += 5;
			break;
		case MIPI_SEQ_ELEM_GPIO:
			tmp -= 3;
			if (tmp < 0)
				return NULL;

			data += 3;
			break;
		default:
			DRM_ERROR("Unknown element\n");
			return NULL;
		}

		/* end of sequence ? */
		if (*data == 0)
			break;
	}

	/* goto next sequence or end of block byte */
	if (--tmp < 0)
		return NULL;

	data++;

	/* update amount of data left for the sequence block to be parsed */
	*size = tmp;
	return data;
}

static void
parse_mipi(struct drm_i915_private *dev_priv, const struct bdb_header *bdb)
{
	const struct bdb_mipi_config *start;
	const struct bdb_mipi_sequence *sequence;
	const struct mipi_config *config;
	const struct mipi_pps_data *pps;
	u8 *data;
	const u8 *seq_data;
	int i, panel_id, seq_size;
	u16 block_size;

	/* parse MIPI blocks only if LFP type is MIPI */
	if (!dev_priv->vbt.has_mipi)
		return;

	/* Initialize this to undefined indicating no generic MIPI support */
	dev_priv->vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;

	/* Block #40 is already parsed and panel_fixed_mode is
	 * stored in dev_priv->lfp_lvds_vbt_mode
	 * resuse this when needed
	 */

	/* Parse #52 for panel index used from panel_type already
	 * parsed
	 */
	start = find_section(bdb, BDB_MIPI_CONFIG);
	if (!start) {
		DRM_DEBUG_KMS("No MIPI config BDB found");
		return;
	}

	DRM_DEBUG_DRIVER("Found MIPI Config block, panel index = %d\n",
								panel_type);

	/*
	 * get hold of the correct configuration block and pps data as per
	 * the panel_type as index
	 */
	config = &start->config[panel_type];
	pps = &start->pps[panel_type];

	/* store as of now full data. Trim when we realise all is not needed */
	dev_priv->vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);
	if (!dev_priv->vbt.dsi.config)
		return;

	dev_priv->vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);
	if (!dev_priv->vbt.dsi.pps) {
		kfree(dev_priv->vbt.dsi.config);
		return;
	}

	/* We have mandatory mipi config blocks. Initialize as generic panel */
	dev_priv->vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;

	/* Check if we have sequence block as well */
	sequence = find_section(bdb, BDB_MIPI_SEQUENCE);
	if (!sequence) {
		DRM_DEBUG_KMS("No MIPI Sequence found, parsing complete\n");
		return;
	}

	/* Fail gracefully for forward incompatible sequence block. */
	if (sequence->version >= 3) {
		DRM_ERROR("Unable to parse MIPI Sequence Block v3+\n");
		return;
	}

	DRM_DEBUG_DRIVER("Found MIPI sequence block\n");

	block_size = get_blocksize(sequence);

	/*
	 * parse the sequence block for individual sequences
	 */
	dev_priv->vbt.dsi.seq_version = sequence->version;

	seq_data = &sequence->data[0];

	/*
	 * sequence block is variable length and hence we need to parse and
	 * get the sequence data for specific panel id
	 */
	for (i = 0; i < MAX_MIPI_CONFIGURATIONS; i++) {
		panel_id = *seq_data;
		seq_size = *((u16 *) (seq_data + 1));
		if (panel_id == panel_type)
			break;

		/* skip the sequence including seq header of 3 bytes */
		seq_data = seq_data + 3 + seq_size;
		if ((seq_data - &sequence->data[0]) > block_size) {
			DRM_ERROR("Sequence start is beyond sequence block size, corrupted sequence block\n");
			return;
		}
	}

	if (i == MAX_MIPI_CONFIGURATIONS) {
		DRM_ERROR("Sequence block detected but no valid configuration\n");
		return;
	}

	/* check if found sequence is completely within the sequence block
	 * just being paranoid */
	if (seq_size > block_size) {
		DRM_ERROR("Corrupted sequence/size, bailing out\n");
		return;
	}

	/* skip the panel id(1 byte) and seq size(2 bytes) */
	dev_priv->vbt.dsi.data = kmemdup(seq_data + 3, seq_size, GFP_KERNEL);
	if (!dev_priv->vbt.dsi.data)
		return;

	/*
	 * loop into the sequence data and split into multiple sequneces
	 * There are only 5 types of sequences as of now
	 */
	data = dev_priv->vbt.dsi.data;
	dev_priv->vbt.dsi.size = seq_size;

	/* two consecutive 0x00 indicate end of all sequences */
	while (1) {
		int seq_id = *data;
		if (MIPI_SEQ_MAX > seq_id && seq_id > MIPI_SEQ_UNDEFINED) {
			dev_priv->vbt.dsi.sequence[seq_id] = data;
			DRM_DEBUG_DRIVER("Found mipi sequence - %d\n", seq_id);
		} else {
			DRM_ERROR("undefined sequence\n");
			goto err;
		}

		/* partial parsing to skip elements */
		data = goto_next_sequence(data, &seq_size);

		if (data == NULL) {
			DRM_ERROR("Sequence elements going beyond block itself. Sequence block parsing failed\n");
			goto err;
		}

		if (*data == 0)
			break; /* end of sequence reached */
	}

	DRM_DEBUG_DRIVER("MIPI related vbt parsing complete\n");
	return;
err:
	kfree(dev_priv->vbt.dsi.data);
	dev_priv->vbt.dsi.data = NULL;

	/* error during parsing so set all pointers to null
	 * because of partial parsing */
	memset(dev_priv->vbt.dsi.sequence, 0, sizeof(dev_priv->vbt.dsi.sequence));
}

static u8 translate_iboost(u8 val)
{
	static const u8 mapping[] = { 1, 3, 7 }; /* See VBT spec */

	if (val >= ARRAY_SIZE(mapping)) {
		DRM_DEBUG_KMS("Unsupported I_boost value found in VBT (%d), display may not work properly\n", val);
		return 0;
	}
	return mapping[val];
}

static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,
			   const struct bdb_header *bdb)
{
	union child_device_config *it, *child = NULL;
	struct ddi_vbt_port_info *info = &dev_priv->vbt.ddi_port_info[port];
	uint8_t hdmi_level_shift;
	int i, j;
	bool is_dvi, is_hdmi, is_dp, is_edp, is_crt;
	uint8_t aux_channel, ddc_pin;
	/* Each DDI port can have more than one value on the "DVO Port" field,
	 * so look for all the possible values for each port and abort if more
	 * than one is found. */
	int dvo_ports[][3] = {
		{DVO_PORT_HDMIA, DVO_PORT_DPA, -1},
		{DVO_PORT_HDMIB, DVO_PORT_DPB, -1},
		{DVO_PORT_HDMIC, DVO_PORT_DPC, -1},
		{DVO_PORT_HDMID, DVO_PORT_DPD, -1},
		{DVO_PORT_CRT, DVO_PORT_HDMIE, DVO_PORT_DPE},
	};

	/* Find the child device to use, abort if more than one found. */
	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
		it = dev_priv->vbt.child_dev + i;

		for (j = 0; j < 3; j++) {
			if (dvo_ports[port][j] == -1)
				break;

			if (it->common.dvo_port == dvo_ports[port][j]) {
				if (child) {
					DRM_DEBUG_KMS("More than one child device for port %c in VBT.\n",
						      port_name(port));
					return;
				}
				child = it;
			}
		}
	}
	if (!child)
		return;

	aux_channel = child->raw[25];
	ddc_pin = child->common.ddc_pin;

	is_dvi = child->common.device_type & DEVICE_TYPE_TMDS_DVI_SIGNALING;
	is_dp = child->common.device_type & DEVICE_TYPE_DISPLAYPORT_OUTPUT;
	is_crt = child->common.device_type & DEVICE_TYPE_ANALOG_OUTPUT;
	is_hdmi = is_dvi && (child->common.device_type & DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;
	is_edp = is_dp && (child->common.device_type & DEVICE_TYPE_INTERNAL_CONNECTOR);

	info->supports_dvi = is_dvi;
	info->supports_hdmi = is_hdmi;
	info->supports_dp = is_dp;

	DRM_DEBUG_KMS("Port %c VBT info: DP:%d HDMI:%d DVI:%d EDP:%d CRT:%d\n",
		      port_name(port), is_dp, is_hdmi, is_dvi, is_edp, is_crt);

	if (is_edp && is_dvi)
		DRM_DEBUG_KMS("Internal DP port %c is TMDS compatible\n",
			      port_name(port));
	if (is_crt && port != PORT_E)
		DRM_DEBUG_KMS("Port %c is analog\n", port_name(port));
	if (is_crt && (is_dvi || is_dp))
		DRM_DEBUG_KMS("Analog port %c is also DP or TMDS compatible\n",
			      port_name(port));
	if (is_dvi && (port == PORT_A || port == PORT_E))
		DRM_DEBUG_KMS("Port %c is TMDS compatible\n", port_name(port));
	if (!is_dvi && !is_dp && !is_crt)
		DRM_DEBUG_KMS("Port %c is not DP/TMDS/CRT compatible\n",
			      port_name(port));
	if (is_edp && (port == PORT_B || port == PORT_C || port == PORT_E))
		DRM_DEBUG_KMS("Port %c is internal DP\n", port_name(port));

	if (is_dvi) {
		if (port == PORT_E) {
			info->alternate_ddc_pin = ddc_pin;
			/* if DDIE share ddc pin with other port, then
			 * dvi/hdmi couldn't exist on the shared port.
			 * Otherwise they share the same ddc bin and system
			 * couldn't communicate with them seperately. */
			if (ddc_pin == DDC_PIN_B) {
				dev_priv->vbt.ddi_port_info[PORT_B].supports_dvi = 0;
				dev_priv->vbt.ddi_port_info[PORT_B].supports_hdmi = 0;
			} else if (ddc_pin == DDC_PIN_C) {
				dev_priv->vbt.ddi_port_info[PORT_C].supports_dvi = 0;
				dev_priv->vbt.ddi_port_info[PORT_C].supports_hdmi = 0;
			} else if (ddc_pin == DDC_PIN_D) {
				dev_priv->vbt.ddi_port_info[PORT_D].supports_dvi = 0;
				dev_priv->vbt.ddi_port_info[PORT_D].supports_hdmi = 0;
			}
		} else if (ddc_pin == DDC_PIN_B && port != PORT_B)
			DRM_DEBUG_KMS("Unexpected DDC pin for port B\n");
		else if (ddc_pin == DDC_PIN_C && port != PORT_C)
			DRM_DEBUG_KMS("Unexpected DDC pin for port C\n");
		else if (ddc_pin == DDC_PIN_D && port != PORT_D)
			DRM_DEBUG_KMS("Unexpected DDC pin for port D\n");
	}

	if (is_dp) {
		if (port == PORT_E) {
			info->alternate_aux_channel = aux_channel;
			/* if DDIE share aux channel with other port, then
			 * DP couldn't exist on the shared port. Otherwise
			 * they share the same aux channel and system
			 * couldn't communicate with them seperately. */
			if (aux_channel == DP_AUX_A)
				dev_priv->vbt.ddi_port_info[PORT_A].supports_dp = 0;
			else if (aux_channel == DP_AUX_B)
				dev_priv->vbt.ddi_port_info[PORT_B].supports_dp = 0;
			else if (aux_channel == DP_AUX_C)
				dev_priv->vbt.ddi_port_info[PORT_C].supports_dp = 0;
			else if (aux_channel == DP_AUX_D)
				dev_priv->vbt.ddi_port_info[PORT_D].supports_dp = 0;
		}
		else if (aux_channel == DP_AUX_A && port != PORT_A)
			DRM_DEBUG_KMS("Unexpected AUX channel for port A\n");
		else if (aux_channel == DP_AUX_B && port != PORT_B)
			DRM_DEBUG_KMS("Unexpected AUX channel for port B\n");
		else if (aux_channel == DP_AUX_C && port != PORT_C)
			DRM_DEBUG_KMS("Unexpected AUX channel for port C\n");
		else if (aux_channel == DP_AUX_D && port != PORT_D)
			DRM_DEBUG_KMS("Unexpected AUX channel for port D\n");
	}

	if (bdb->version >= 158) {
		/* The VBT HDMI level shift values match the table we have. */
		hdmi_level_shift = child->raw[7] & 0xF;
		DRM_DEBUG_KMS("VBT HDMI level shift for port %c: %d\n",
			      port_name(port),
			      hdmi_level_shift);
		info->hdmi_level_shift = hdmi_level_shift;
	}

	/* Parse the I_boost config for SKL and above */
	if (bdb->version >= 196 && (child->common.flags_1 & IBOOST_ENABLE)) {
		info->dp_boost_level = translate_iboost(child->common.iboost_level & 0xF);
		DRM_DEBUG_KMS("VBT (e)DP boost level for port %c: %d\n",
			      port_name(port), info->dp_boost_level);
		info->hdmi_boost_level = translate_iboost(child->common.iboost_level >> 4);
		DRM_DEBUG_KMS("VBT HDMI boost level for port %c: %d\n",
			      port_name(port), info->hdmi_boost_level);
	}
}

static void parse_ddi_ports(struct drm_i915_private *dev_priv,
			    const struct bdb_header *bdb)
{
	struct drm_device *dev = dev_priv->dev;
	enum port port;

	if (!HAS_DDI(dev))
		return;

	if (!dev_priv->vbt.child_dev_num)
		return;

	if (bdb->version < 155)
		return;

	for (port = PORT_A; port < I915_MAX_PORTS; port++)
		parse_ddi_port(dev_priv, port, bdb);
}

static void
parse_device_mapping(struct drm_i915_private *dev_priv,
		     const struct bdb_header *bdb)
{
	const struct bdb_general_definitions *p_defs;
	const union child_device_config *p_child;
	union child_device_config *child_dev_ptr;
	int i, child_device_num, count;
	u8 expected_size;
	u16 block_size;

	p_defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);
	if (!p_defs) {
		DRM_DEBUG_KMS("No general definition block is found, no devices defined.\n");
		return;
	}
	if (bdb->version < 195) {
		expected_size = sizeof(struct old_child_dev_config);
	} else if (bdb->version == 195) {
		expected_size = 37;
	} else if (bdb->version <= 197) {
		expected_size = 38;
	} else {
		expected_size = 38;
		BUILD_BUG_ON(sizeof(*p_child) < 38);
		DRM_DEBUG_DRIVER("Expected child device config size for VBT version %u not known; assuming %u\n",
				 bdb->version, expected_size);
	}

	/* The legacy sized child device config is the minimum we need. */
	if (p_defs->child_dev_size < sizeof(struct old_child_dev_config)) {
		DRM_ERROR("Child device config size %u is too small.\n",
			  p_defs->child_dev_size);
		return;
	}

	/* Flag an error for unexpected size, but continue anyway. */
	if (p_defs->child_dev_size != expected_size)
		DRM_ERROR("Unexpected child device config size %u (expected %u for VBT version %u)\n",
			  p_defs->child_dev_size, expected_size, bdb->version);

	/* get the block size of general definitions */
	block_size = get_blocksize(p_defs);
	/* get the number of child device */
	child_device_num = (block_size - sizeof(*p_defs)) /
				p_defs->child_dev_size;
	count = 0;
	/* get the number of child device that is present */
	for (i = 0; i < child_device_num; i++) {
		p_child = child_device_ptr(p_defs, i);
		if (!p_child->common.device_type) {
			/* skip the device block if device type is invalid */
			continue;
		}
		count++;
	}
	if (!count) {
		DRM_DEBUG_KMS("no child dev is parsed from VBT\n");
		return;
	}
	dev_priv->vbt.child_dev = kcalloc(count, sizeof(*p_child), GFP_KERNEL);
	if (!dev_priv->vbt.child_dev) {
		DRM_DEBUG_KMS("No memory space for child device\n");
		return;
	}

	dev_priv->vbt.child_dev_num = count;
	count = 0;
	for (i = 0; i < child_device_num; i++) {
		p_child = child_device_ptr(p_defs, i);
		if (!p_child->common.device_type) {
			/* skip the device block if device type is invalid */
			continue;
		}

		if (p_child->common.dvo_port >= DVO_PORT_MIPIA
		    && p_child->common.dvo_port <= DVO_PORT_MIPID
		    &&p_child->common.device_type & DEVICE_TYPE_MIPI_OUTPUT) {
			DRM_DEBUG_KMS("Found MIPI as LFP\n");
			dev_priv->vbt.has_mipi = 1;
			dev_priv->vbt.dsi.port = p_child->common.dvo_port;
		}

		child_dev_ptr = dev_priv->vbt.child_dev + count;
		count++;

		/*
		 * Copy as much as we know (sizeof) and is available
		 * (child_dev_size) of the child device. Accessing the data must
		 * depend on VBT version.
		 */
		memcpy(child_dev_ptr, p_child,
		       min_t(size_t, p_defs->child_dev_size, sizeof(*p_child)));
	}
	return;
}

static void
init_vbt_defaults(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	enum port port;

	dev_priv->vbt.crt_ddc_pin = GMBUS_PIN_VGADDC;

	/* Default to having backlight */
	dev_priv->vbt.backlight.present = true;

	/* LFP panel data */
	dev_priv->vbt.lvds_dither = 1;
	dev_priv->vbt.lvds_vbt = 0;

	/* SDVO panel data */
	dev_priv->vbt.sdvo_lvds_vbt_mode = NULL;

	/* general features */
	dev_priv->vbt.int_tv_support = 1;
	dev_priv->vbt.int_crt_support = 1;

	/* Default to using SSC */
	dev_priv->vbt.lvds_use_ssc = 1;
	/*
	 * Core/SandyBridge/IvyBridge use alternative (120MHz) reference
	 * clock for LVDS.
	 */
	dev_priv->vbt.lvds_ssc_freq = intel_bios_ssc_frequency(dev,
			!HAS_PCH_SPLIT(dev));
	DRM_DEBUG_KMS("Set default to SSC at %d kHz\n", dev_priv->vbt.lvds_ssc_freq);

	for (port = PORT_A; port < I915_MAX_PORTS; port++) {
		struct ddi_vbt_port_info *info =
			&dev_priv->vbt.ddi_port_info[port];

		info->hdmi_level_shift = HDMI_LEVEL_SHIFT_UNKNOWN;

		info->supports_dvi = (port != PORT_A && port != PORT_E);
		info->supports_hdmi = info->supports_dvi;
		info->supports_dp = (port != PORT_E);
	}
}

static int intel_no_opregion_vbt_callback(const struct dmi_system_id *id)
{
	DRM_DEBUG_KMS("Falling back to manually reading VBT from "
		      "VBIOS ROM for %s\n",
		      id->ident);
	return 1;
}

static const struct dmi_system_id intel_no_opregion_vbt[] = {
	{
		.callback = intel_no_opregion_vbt_callback,
		.ident = "ThinkCentre A57",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
			DMI_MATCH(DMI_PRODUCT_NAME, "97027RG"),
		},
	},
	{ }
};

static const struct bdb_header *validate_vbt(const void *base,
					     size_t size,
					     const void *_vbt,
					     const char *source)
{
	size_t offset = _vbt - base;
	const struct vbt_header *vbt = _vbt;
	const struct bdb_header *bdb;

	if (offset + sizeof(struct vbt_header) > size) {
		DRM_DEBUG_DRIVER("VBT header incomplete\n");
		return NULL;
	}

	if (memcmp(vbt->signature, "$VBT", 4)) {
		DRM_DEBUG_DRIVER("VBT invalid signature\n");
		return NULL;
	}

	offset += vbt->bdb_offset;
	if (offset + sizeof(struct bdb_header) > size) {
		DRM_DEBUG_DRIVER("BDB header incomplete\n");
		return NULL;
	}

	bdb = base + offset;
	if (offset + bdb->bdb_size > size) {
		DRM_DEBUG_DRIVER("BDB incomplete\n");
		return NULL;
	}

	DRM_DEBUG_KMS("Using VBT from %s: %20s\n",
		      source, vbt->signature);
	return bdb;
}

static const struct bdb_header *find_vbt(void __iomem *bios, size_t size)
{
	const struct bdb_header *bdb = NULL;
	size_t i;

	/* Scour memory looking for the VBT signature. */
	for (i = 0; i + 4 < size; i++) {
		if (ioread32(bios + i) == *((const u32 *) "$VBT")) {
			/*
			 * This is the one place where we explicitly discard the
			 * address space (__iomem) of the BIOS/VBT. From now on
			 * everything is based on 'base', and treated as regular
			 * memory.
			 */
			void *_bios = (void __force *) bios;

			bdb = validate_vbt(_bios, size, _bios + i, "PCI ROM");
			break;
		}
	}

	return bdb;
}

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#define VGA_BIOS_ADDR	0xc0000
#define VGA_BIOS_LEN	0x10000

/**
 * intel_parse_bios - find VBT and initialize settings from the BIOS
 * @@dev: DRM device
 *
 * Loads the Video BIOS and checks that the VBT exists.  Sets scratch registers
 * to appropriate values.
 *
 * Returns 0 on success, nonzero on failure.
 */
int
intel_parse_bios(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
#ifdef __linux__
	struct pci_dev *pdev = dev->pdev;
#endif
	const struct bdb_header *bdb = NULL;
	u8 __iomem *bios = NULL;

	if (HAS_PCH_NOP(dev))
		return -ENODEV;

	init_vbt_defaults(dev_priv);

	/* XXX Should this validation be moved to intel_opregion.c? */
	if (!dmi_check_system(intel_no_opregion_vbt) && dev_priv->opregion.vbt)
		bdb = validate_vbt(dev_priv->opregion.header, OPREGION_SIZE,
				   dev_priv->opregion.vbt, "OpRegion");

	if (bdb == NULL) {
		size_t size;

#ifdef __linux__
		bios = pci_map_rom(pdev, &size);
		if (!bios)
			return -1;
#else
		bios = (u8 *)ISA_HOLE_VADDR(VGA_BIOS_ADDR);
		size = VGA_BIOS_LEN;
#endif

		bdb = find_vbt(bios, size);
		if (!bdb) {
#ifdef __linux__
			pci_unmap_rom(pdev, bios);
#endif
			return -1;
		}
	}

	/* Grab useful general definitions */
	parse_general_features(dev_priv, bdb);
	parse_general_definitions(dev_priv, bdb);
	parse_lfp_panel_data(dev_priv, bdb);
	parse_lfp_backlight(dev_priv, bdb);
	parse_sdvo_panel_data(dev_priv, bdb);
	parse_sdvo_device_mapping(dev_priv, bdb);
	parse_device_mapping(dev_priv, bdb);
	parse_driver_features(dev_priv, bdb);
	parse_edp(dev_priv, bdb);
	parse_psr(dev_priv, bdb);
	parse_mipi(dev_priv, bdb);
	parse_ddi_ports(dev_priv, bdb);

#ifdef __linux__
	if (bios)
		pci_unmap_rom(pdev, bios);
#endif

	return 0;
}

/**
 * intel_bios_is_port_present - is the specified digital port present
 * @@dev_priv:	i915 device instance
 * @@port:	port to check
 *
 * Return true if the device in %port is present.
 */
bool intel_bios_is_port_present(struct drm_i915_private *dev_priv, enum port port)
{
	static const struct {
		u16 dp, hdmi;
	} port_mapping[] = {
		[PORT_B] = { DVO_PORT_DPB, DVO_PORT_HDMIB, },
		[PORT_C] = { DVO_PORT_DPC, DVO_PORT_HDMIC, },
		[PORT_D] = { DVO_PORT_DPD, DVO_PORT_HDMID, },
		[PORT_E] = { DVO_PORT_DPE, DVO_PORT_HDMIE, },
	};
	int i;

	/* FIXME maybe deal with port A as well? */
	if (WARN_ON(port == PORT_A) || port >= ARRAY_SIZE(port_mapping))
		return false;

	if (!dev_priv->vbt.child_dev_num)
		return false;

	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
		const union child_device_config *p_child =
			&dev_priv->vbt.child_dev[i];
		if ((p_child->common.dvo_port == port_mapping[port].dp ||
		     p_child->common.dvo_port == port_mapping[port].hdmi) &&
		    (p_child->common.device_type & (DEVICE_TYPE_TMDS_DVI_SIGNALING |
						    DEVICE_TYPE_DISPLAYPORT_OUTPUT)))
			return true;
	}

	return false;
}
@


1.12
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@a680 2
#ifdef notyet

a904 2
#endif

a1153 1
#ifdef notyet
a1160 1
#endif
a1366 1
#ifdef notyet
a1367 1
#endif
@


1.11
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@a0 1
/*	$OpenBSD: intel_bios.c,v 1.10 2015/04/06 12:25:10 jsg Exp $	*/
d27 7
a34 1
#include <dev/pci/drm/drm_dp_helper.h>
d36 1
a38 2
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
d45 2
a46 2
static void *
find_section(struct bdb_header *bdb, int section_id)
d48 2
a49 1
	u8 *base = (u8 *)bdb;
d51 1
a51 1
	u16 total, current_size;
d59 1
a59 1
	while (index < total) {
d62 2
a63 1
		current_size = *((u16 *)(base + index));
d65 8
d75 1
d83 1
a83 1
get_blocksize(void *p)
a134 36
static bool
lvds_dvo_timing_equal_size(const struct lvds_dvo_timing *a,
			   const struct lvds_dvo_timing *b)
{
	if (a->hactive_hi != b->hactive_hi ||
	    a->hactive_lo != b->hactive_lo)
		return false;

	if (a->hsync_off_hi != b->hsync_off_hi ||
	    a->hsync_off_lo != b->hsync_off_lo)
		return false;

	if (a->hsync_pulse_width != b->hsync_pulse_width)
		return false;

	if (a->hblank_hi != b->hblank_hi ||
	    a->hblank_lo != b->hblank_lo)
		return false;

	if (a->vactive_hi != b->vactive_hi ||
	    a->vactive_lo != b->vactive_lo)
		return false;

	if (a->vsync_off != b->vsync_off)
		return false;

	if (a->vsync_pulse_width != b->vsync_pulse_width)
		return false;

	if (a->vblank_hi != b->vblank_hi ||
	    a->vblank_lo != b->vblank_lo)
		return false;

	return true;
}

d182 1
a182 1
			    struct bdb_header *bdb)
d190 1
a190 1
	int i, downclock;
d202 22
a248 24
	/*
	 * Iterate over the LVDS panel timing info to find the lowest clock
	 * for the native resolution.
	 */
	downclock = panel_dvo_timing->clock;
	for (i = 0; i < 16; i++) {
		const struct lvds_dvo_timing *dvo_timing;

		dvo_timing = get_lvds_dvo_timing(lvds_lfp_data,
						 lvds_lfp_data_ptrs,
						 i);
		if (lvds_dvo_timing_equal_size(dvo_timing, panel_dvo_timing) &&
		    dvo_timing->clock < downclock)
			downclock = dvo_timing->clock;
	}

	if (downclock < panel_dvo_timing->clock && i915_lvds_downclock) {
		dev_priv->lvds_downclock_avail = 1;
		dev_priv->lvds_downclock = downclock * 10;
		DRM_DEBUG_KMS("LVDS downclock is found in VBT. "
			      "Normal Clock %dKHz, downclock %dKHz\n",
			      panel_fixed_mode->clock, 10*downclock);
	}

d264 2
a265 1
parse_lfp_backlight(struct drm_i915_private *dev_priv, struct bdb_header *bdb)
d282 7
d291 1
d296 1
a296 1
		      entry->min_brightness,
d303 1
a303 1
		      struct bdb_header *bdb)
d305 1
a305 1
	struct lvds_dvo_timing *dvo_timing;
d309 1
a309 1
	index = i915_vbt_sdvo_panel_type;
d316 1
a316 1
		struct bdb_sdvo_lvds_options *sdvo_lvds_options;
d357 1
a357 1
		       struct bdb_header *bdb)
d360 1
a360 1
	struct bdb_general_features *general;
d383 1
a383 1
			  struct bdb_header *bdb)
d385 1
a385 1
	struct bdb_general_definitions *general;
d393 1
a393 1
			if (intel_gmbus_is_port_valid(bus_pin))
d402 6
d410 1
a410 1
			  struct bdb_header *bdb)
d413 2
a414 2
	struct bdb_general_definitions *p_defs;
	union child_device_config *p_child;
d423 8
a430 8
	/* judge whether the size of child device meets the requirements.
	 * If the child device size obtained from general definition block
	 * is different with sizeof(struct child_device_config), skip the
	 * parsing of sdvo device info
	 */
	if (p_defs->child_dev_size != sizeof(*p_child)) {
		/* different child dev size . Ignore it */
		DRM_DEBUG_KMS("different child size is found. Invalid.\n");
d437 1
a437 1
				sizeof(*p_child);
d440 2
a441 2
		p_child = &(p_defs->devices[i]);
		if (!p_child->old.device_type) {
d445 2
a446 2
		if (p_child->old.slave_addr != SLAVE_ADDR1 &&
			p_child->old.slave_addr != SLAVE_ADDR2) {
d453 2
a454 2
		if (p_child->old.dvo_port != DEVICE_PORT_DVOB &&
			p_child->old.dvo_port != DEVICE_PORT_DVOC) {
d460 5
a464 5
				" %s port\n",
				p_child->old.slave_addr,
				(p_child->old.dvo_port == DEVICE_PORT_DVOB) ?
					"SDVOB" : "SDVOC");
		p_mapping = &(dev_priv->sdvo_mappings[p_child->old.dvo_port - 1]);
d466 5
a470 5
			p_mapping->dvo_port = p_child->old.dvo_port;
			p_mapping->slave_addr = p_child->old.slave_addr;
			p_mapping->dvo_wiring = p_child->old.dvo_wiring;
			p_mapping->ddc_pin = p_child->old.ddc_pin;
			p_mapping->i2c_pin = p_child->old.i2c_pin;
d482 1
a482 1
		if (p_child->old.slave2_addr) {
d500 1
a500 1
		       struct bdb_header *bdb)
d502 1
a502 1
	struct bdb_driver_features *driver;
d513 10
d526 1
a526 1
parse_edp(struct drm_i915_private *dev_priv, struct bdb_header *bdb)
d528 3
a530 3
	struct bdb_edp *edp;
	struct edp_power_seq *edp_pps;
	struct edp_link_params *edp_link_params;
d557 13
a569 2
	dev_priv->vbt.edp_rate = edp_link_params->rate ? DP_LINK_BW_2_7 :
		DP_LINK_BW_1_62;
d571 1
a571 1
	case 0:
d574 1
a574 1
	case 1:
d577 3
a579 1
	case 3:
d581 2
a582 1
		dev_priv->vbt.edp_lanes = 4;
d585 1
d587 5
a591 2
	case 0:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPHASIS_0;
d593 2
a594 2
	case 1:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPHASIS_3_5;
d596 2
a597 2
	case 2:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPHASIS_6;
d599 3
a601 2
	case 3:
		dev_priv->vbt.edp_preemphasis = DP_TRAIN_PRE_EMPHASIS_9_5;
d604 1
d606 53
d660 1
a660 1
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_400;
d663 1
a663 1
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_600;
d666 1
a666 1
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_800;
d669 5
a673 1
		dev_priv->vbt.edp_vswing = DP_TRAIN_VOLTAGE_SWING_1200;
d676 72
d751 1
a751 1
parse_mipi(struct drm_i915_private *dev_priv, struct bdb_header *bdb)
d753 95
a847 1
	struct bdb_mipi *mipi;
d849 2
a850 3
	mipi = find_section(bdb, BDB_MIPI);
	if (!mipi) {
		DRM_DEBUG_KMS("No MIPI BDB found");
d854 64
a917 2
	/* XXX: add more info */
	dev_priv->vbt.dsi.panel_id = mipi->panel_id;
d921 1
a921 1
			   struct bdb_header *bdb)
d928 1
a928 1
	uint8_t aux_channel;
d932 6
a937 6
	int dvo_ports[][2] = {
		{DVO_PORT_HDMIA, DVO_PORT_DPA},
		{DVO_PORT_HDMIB, DVO_PORT_DPB},
		{DVO_PORT_HDMIC, DVO_PORT_DPC},
		{DVO_PORT_HDMID, DVO_PORT_DPD},
		{DVO_PORT_CRT, -1 /* Port E can only be DVO_PORT_CRT */ },
d944 1
a944 1
		for (j = 0; j < 2; j++) {
d962 1
d986 1
a986 1
		DRM_DEBUG_KMS("Port %c is TMDS compabile\n", port_name(port));
d994 17
a1010 1
		if (child->common.ddc_pin == 0x05 && port != PORT_B)
d1012 1
a1012 1
		if (child->common.ddc_pin == 0x04 && port != PORT_C)
d1014 1
a1014 1
		if (child->common.ddc_pin == 0x06 && port != PORT_D)
d1019 16
a1034 1
		if (aux_channel == 0x40 && port != PORT_A)
d1036 1
a1036 1
		if (aux_channel == 0x10 && port != PORT_B)
d1038 1
a1038 1
		if (aux_channel == 0x20 && port != PORT_C)
d1040 1
a1040 1
		if (aux_channel == 0x30 && port != PORT_D)
d1047 14
a1060 6
		if (hdmi_level_shift < 0xC) {
			DRM_DEBUG_KMS("VBT HDMI level shift for port %c: %d\n",
				      port_name(port),
				      hdmi_level_shift);
			info->hdmi_level_shift = hdmi_level_shift;
		}
d1065 1
a1065 1
			    struct bdb_header *bdb)
d1085 1
a1085 1
		       struct bdb_header *bdb)
d1087 3
a1089 2
	struct bdb_general_definitions *p_defs;
	union child_device_config *p_child, *child_dev_ptr;
d1091 2
a1092 1
	u16	block_size;
d1099 17
a1115 8
	/* judge whether the size of child device meets the requirements.
	 * If the child device size obtained from general definition block
	 * is different with sizeof(struct child_device_config), skip the
	 * parsing of sdvo device info
	 */
	if (p_defs->child_dev_size != sizeof(*p_child)) {
		/* different child dev size . Ignore it */
		DRM_DEBUG_KMS("different child size is found. Invalid.\n");
d1118 6
d1128 1
a1128 1
				sizeof(*p_child);
d1132 1
a1132 1
		p_child = &(p_defs->devices[i]);
d1152 1
a1152 1
		p_child = &(p_defs->devices[i]);
d1157 11
d1170 8
a1177 2
		memcpy((void *)child_dev_ptr, (void *)p_child,
					sizeof(*p_child));
d1188 4
a1191 1
	dev_priv->vbt.crt_ddc_pin = GMBUS_PORT_VGADDC;
d1218 1
a1218 2
		/* Recommended BSpec default: 800mV 0dB. */
		info->hdmi_level_shift = 6;
d1246 63
d1325 4
a1328 1
	struct bdb_header *bdb = NULL;
d1337 3
a1339 9
	if (!dmi_check_system(intel_no_opregion_vbt) && dev_priv->opregion.vbt) {
		struct vbt_header *vbt = dev_priv->opregion.vbt;
		if (memcmp(vbt->signature, "$VBT", 4) == 0) {
			DRM_DEBUG_KMS("Using VBT from OpRegion: %20s\n",
					 vbt->signature);
			bdb = (struct bdb_header *)((char *)vbt + vbt->bdb_offset);
		} else
			dev_priv->opregion.vbt = NULL;
	}
a1340 1
#if defined(__amd64__) || defined(__i386__)
a1341 1
		struct vbt_header *vbt = NULL;
a1342 1
		int i;
d1344 5
d1351 1
d1353 5
a1357 10
		/* Scour memory looking for the VBT signature */
		for (i = 0; i + 4 < size; i++) {
			if (!memcmp(bios + i, "$VBT", 4)) {
				vbt = (struct vbt_header *)(bios + i);
				break;
			}
		}

		if (!vbt) {
			DRM_DEBUG_DRIVER("VBT signature missing\n");
a1359 2

		bdb = (struct bdb_header *)(bios + i + vbt->bdb_offset);
a1360 1
#endif /* defined(__amd64__) || defined(__i386__) */
d1372 2
d1375 1
d1378 5
d1386 6
a1391 2
/* Ensure that vital registers have been initialised, even if the BIOS
 * is absent or just failing to do its job.
d1393 1
a1393 1
void intel_setup_bios(struct drm_device *dev)
d1395 9
a1403 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d1405 3
a1407 5
	 /* Set the Panel Power On/Off timings if uninitialized. */
	if (!HAS_PCH_SPLIT(dev) &&
	    I915_READ(PP_ON_DELAYS) == 0 && I915_READ(PP_OFF_DELAYS) == 0) {
		/* Set T2 to 40ms and T5 to 200ms */
		I915_WRITE(PP_ON_DELAYS, 0x019007d0);
d1409 11
a1419 2
		/* Set T3 to 35ms and Tx to 200ms */
		I915_WRITE(PP_OFF_DELAYS, 0x015e07d0);
d1421 2
@


1.10
log
@move some inline linux compat into the dedicated files
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.9 2015/02/12 04:56:03 kettenis Exp $	*/
d217 1
a217 1
	dev_priv->lvds_dither = lvds_options->pixel_dither;
d231 1
a231 1
	dev_priv->lvds_vbt = 1;
d243 1
a243 1
	dev_priv->lfp_lvds_vbt_mode = panel_fixed_mode;
d279 1
a279 1
			dev_priv->bios_lvds_val = fp_timing->lvds_reg_val;
d281 1
a281 1
				      dev_priv->bios_lvds_val);
d286 28
d349 1
a349 1
	dev_priv->sdvo_lvds_vbt_mode = panel_fixed_mode;
d360 1
a360 1
		return alternate ? 66 : 48;
d363 1
a363 1
		return alternate ? 100 : 96;
d365 1
a365 1
		return alternate ? 100 : 120;
d378 4
a381 4
		dev_priv->int_tv_support = general->int_tv_support;
		dev_priv->int_crt_support = general->int_crt_support;
		dev_priv->lvds_use_ssc = general->enable_ssc;
		dev_priv->lvds_ssc_freq =
d383 2
a384 2
		dev_priv->display_clock_mode = general->display_clock_mode;
		dev_priv->fdi_rx_polarity_inverted = general->fdi_rx_polarity_inverted;
d386 6
a391 6
			      dev_priv->int_tv_support,
			      dev_priv->int_crt_support,
			      dev_priv->lvds_use_ssc,
			      dev_priv->lvds_ssc_freq,
			      dev_priv->display_clock_mode,
			      dev_priv->fdi_rx_polarity_inverted);
d408 1
a408 1
				dev_priv->crt_ddc_pin = bus_pin;
d422 1
a422 1
	struct child_device_config *p_child;
d449 1
a449 1
		if (!p_child->device_type) {
d453 2
a454 2
		if (p_child->slave_addr != SLAVE_ADDR1 &&
			p_child->slave_addr != SLAVE_ADDR2) {
d461 2
a462 2
		if (p_child->dvo_port != DEVICE_PORT_DVOB &&
			p_child->dvo_port != DEVICE_PORT_DVOC) {
d469 2
a470 2
				p_child->slave_addr,
				(p_child->dvo_port == DEVICE_PORT_DVOB) ?
d472 1
a472 1
		p_mapping = &(dev_priv->sdvo_mappings[p_child->dvo_port - 1]);
d474 5
a478 5
			p_mapping->dvo_port = p_child->dvo_port;
			p_mapping->slave_addr = p_child->slave_addr;
			p_mapping->dvo_wiring = p_child->dvo_wiring;
			p_mapping->ddc_pin = p_child->ddc_pin;
			p_mapping->i2c_pin = p_child->i2c_pin;
d490 1
a490 1
		if (p_child->slave2_addr) {
a509 1
	struct drm_device *dev = dev_priv->dev;
d516 2
a517 3
	if (SUPPORTS_EDP(dev) &&
	    driver->lvds_config == BDB_DRIVER_FEATURE_EDP)
		dev_priv->edp.support = 1;
d532 1
a532 1
		if (SUPPORTS_EDP(dev_priv->dev) && dev_priv->edp.support)
d539 1
a539 1
		dev_priv->edp.bpp = 18;
d542 1
a542 1
		dev_priv->edp.bpp = 24;
d545 1
a545 1
		dev_priv->edp.bpp = 30;
d553 1
a553 1
	dev_priv->edp.pps = *edp_pps;
d555 1
a555 1
	dev_priv->edp.rate = edp_link_params->rate ? DP_LINK_BW_2_7 :
d559 1
a559 1
		dev_priv->edp.lanes = 1;
d562 1
a562 1
		dev_priv->edp.lanes = 2;
d566 1
a566 1
		dev_priv->edp.lanes = 4;
d571 1
a571 1
		dev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_0;
d574 1
a574 1
		dev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_3_5;
d577 1
a577 1
		dev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_6;
d580 1
a580 1
		dev_priv->edp.preemphasis = DP_TRAIN_PRE_EMPHASIS_9_5;
d585 1
a585 1
		dev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_400;
d588 1
a588 1
		dev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_600;
d591 1
a591 1
		dev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_800;
d594 1
a594 1
		dev_priv->edp.vswing = DP_TRAIN_VOLTAGE_SWING_1200;
d600 138
d742 1
a742 1
	struct child_device_config *p_child, *child_dev_ptr;
d770 1
a770 1
		if (!p_child->device_type) {
d780 2
a781 2
	dev_priv->child_dev = kcalloc(count, sizeof(*p_child), GFP_KERNEL);
	if (!dev_priv->child_dev) {
d786 1
a786 1
	dev_priv->child_dev_num = count;
d790 1
a790 1
		if (!p_child->device_type) {
d794 1
a794 1
		child_dev_ptr = dev_priv->child_dev + count;
d806 1
d808 1
a808 1
	dev_priv->crt_ddc_pin = GMBUS_PORT_VGADDC;
d811 2
a812 2
	dev_priv->lvds_dither = 1;
	dev_priv->lvds_vbt = 0;
d815 1
a815 1
	dev_priv->sdvo_lvds_vbt_mode = NULL;
d818 2
a819 2
	dev_priv->int_tv_support = 1;
	dev_priv->int_crt_support = 1;
d822 20
a841 3
	dev_priv->lvds_use_ssc = 1;
	dev_priv->lvds_ssc_freq = intel_bios_ssc_frequency(dev, 1);
	DRM_DEBUG_KMS("Set default to SSC at %dMHz\n", dev_priv->lvds_ssc_freq);
d844 1
a844 1
static int __init intel_no_opregion_vbt_callback(const struct dmi_system_id *id)
d883 3
d929 1
d935 2
@


1.9
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.8 2014/03/24 17:06:49 kettenis Exp $	*/
a680 50

extern char *hw_vendor, *hw_prod;

static bool
dmi_found(const struct dmi_system_id *dsi)
{
	int i, slot;

	for (i = 0; i < nitems(dsi->matches); i++) {
		slot = dsi->matches[i].slot;
		switch (slot) {
		case DMI_NONE:
			break;
		case DMI_SYS_VENDOR:
		case DMI_BOARD_VENDOR:
			if (hw_vendor != NULL &&
			    !strcmp(hw_vendor, dsi->matches[i].substr))
				break;
			else
				return false;
		case DMI_PRODUCT_NAME:
		case DMI_BOARD_NAME:
			if (hw_prod != NULL &&
			    !strcmp(hw_prod, dsi->matches[i].substr))
				break;
			else
				return false;
		default:
			return false;
		}
	}

	return true;
}

int
dmi_check_system(const struct dmi_system_id *sysid)
{
	const struct dmi_system_id *dsi;
	int num = 0;

	for (dsi = sysid; dsi->matches[0].slot != 0 ; dsi++) {
		if (dmi_found(dsi)) {
			num++;
			if (dsi->callback && dsi->callback(dsi))
				break;
		}
	}
	return (num);
}
@


1.8
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.7 2014/01/21 08:57:22 kettenis Exp $	*/
d345 1
a345 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d482 1
a482 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
a499 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d506 1
a506 1
		if (SUPPORTS_EDP(dev) && dev_priv->edp.support)
d641 1
a641 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
@


1.7
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.6 2014/01/21 04:47:38 kettenis Exp $	*/
d750 1
a750 1
	u8 *bios = NULL;
@


1.6
log
@Use ARRAY_SIZE() instead of nitems() to reduce diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.5 2013/08/13 10:23:50 jsg Exp $	*/
d237 1
a237 2
	panel_fixed_mode = malloc(sizeof(*panel_fixed_mode), M_DRM,
	    M_WAITOK | M_ZERO);
d315 1
a315 2
	panel_fixed_mode = malloc(sizeof(*panel_fixed_mode), M_DRM,
	    M_WAITOK | M_ZERO);
d617 1
a617 2
	dev_priv->child_dev = malloc(sizeof(*p_child) * count, M_DRM,
	    M_WAITOK | M_ZERO);
@


1.5
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.4 2013/07/05 07:20:27 jsg Exp $	*/
d191 1
a191 1
	if (index >= nitems(ptrs->ptr))
@


1.4
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.3 2013/07/04 09:52:29 jsg Exp $	*/
a38 28
void	*find_section(struct bdb_header *, int);
u16	 get_blocksize(void *);
void	 fill_detail_timing_data(struct drm_display_mode *,
	     const struct lvds_dvo_timing *);
bool	 lvds_dvo_timing_equal_size(const struct lvds_dvo_timing *,
	     const struct lvds_dvo_timing *);
const struct lvds_dvo_timing *
	 get_lvds_dvo_timing(const struct bdb_lvds_lfp_data *,
	     const struct bdb_lvds_lfp_data_ptrs *, int);
void	 parse_lfp_panel_data(struct drm_i915_private *, struct bdb_header *);
void	 parse_sdvo_panel_data(struct drm_i915_private *, struct bdb_header *);
int	 intel_bios_ssc_frequency(struct drm_device *, bool);
void	 parse_general_features(struct drm_i915_private *, struct bdb_header *);
void	 parse_general_definitions(struct drm_i915_private *,
	     struct bdb_header *);
void	 parse_sdvo_device_mapping(struct drm_i915_private *,
	     struct bdb_header *);
void	 parse_driver_features(struct drm_i915_private *, struct bdb_header *);
void	 parse_edp(struct drm_i915_private *, struct bdb_header *);
void	 parse_device_mapping(struct drm_i915_private *, struct bdb_header *);
void	 init_vbt_defaults(struct drm_i915_private *);
int	 intel_no_opregion_vbt_callback(const struct dmi_system_id *);
const struct lvds_fp_timing *
	 get_lvds_fp_timing(const struct bdb_header *,
	     const struct bdb_lvds_lfp_data *,
	     const struct bdb_lvds_lfp_data_ptrs *, int);
bool	 dmi_found(const struct dmi_system_id *);

d41 1
a41 1
void *
d67 1
a67 1
u16
d77 1
a77 1
void
d120 1
a120 1
bool
d156 1
a156 1
const struct lvds_dvo_timing *
d181 1
a181 1
const struct lvds_fp_timing *
d201 1
a201 1
void
d288 1
a288 1
void
d329 1
a329 2
int
intel_bios_ssc_frequency(struct drm_device *dev,
d343 1
a343 1
void
d369 1
a369 1
void
d390 1
a390 1
void
d480 1
a480 1
void
d499 1
a499 1
void
d576 1
a576 1
void
d642 1
a642 1
void
d666 1
a666 2
int
intel_no_opregion_vbt_callback(const struct dmi_system_id *id)
d688 1
a688 1
bool
d810 1
a810 2
void
intel_setup_bios(struct drm_device *dev)
@


1.3
log
@set CPT FDI RX polarity bits based on VBT
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.2 2013/03/18 13:06:37 mpi Exp $	*/
d48 2
a49 2
void	 parse_lfp_panel_data(struct inteldrm_softc *, struct bdb_header *);
void	 parse_sdvo_panel_data(struct inteldrm_softc *, struct bdb_header *);
d51 2
a52 2
void	 parse_general_features(struct inteldrm_softc *, struct bdb_header *);
void	 parse_general_definitions(struct inteldrm_softc *,
d54 1
a54 1
void	 parse_sdvo_device_mapping(struct inteldrm_softc *,
d56 4
a59 4
void	 parse_driver_features(struct inteldrm_softc *, struct bdb_header *);
void	 parse_edp(struct inteldrm_softc *, struct bdb_header *);
void	 parse_device_mapping(struct inteldrm_softc *, struct bdb_header *);
void	 init_vbt_defaults(struct inteldrm_softc *);
d230 1
a230 1
parse_lfp_panel_data(struct inteldrm_softc *dev_priv,
d317 1
a317 1
parse_sdvo_panel_data(struct inteldrm_softc *dev_priv,
d373 1
a373 1
parse_general_features(struct inteldrm_softc *dev_priv,
d399 1
a399 1
parse_general_definitions(struct inteldrm_softc *dev_priv,
d420 1
a420 1
parse_sdvo_device_mapping(struct inteldrm_softc *dev_priv,
d510 1
a510 1
parse_driver_features(struct inteldrm_softc *dev_priv,
d529 1
a529 1
parse_edp(struct inteldrm_softc *dev_priv, struct bdb_header *bdb)
d606 1
a606 1
parse_device_mapping(struct inteldrm_softc *dev_priv,
d672 1
a672 1
init_vbt_defaults(struct inteldrm_softc *dev_priv)
d781 1
a781 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d843 1
a843 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.2
log
@Correct a typo in a #ifdef condition, ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_bios.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d387 2
a388 1
		DRM_DEBUG_KMS("BDB_GENERAL_FEATURES int_tv_support %d int_crt_support %d lvds_use_ssc %d lvds_ssc_freq %d display_clock_mode %d\n",
d393 2
a394 1
			      dev_priv->display_clock_mode);
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d796 1
a796 1
#if defined(__amd64__) || defined(__i386)
@

