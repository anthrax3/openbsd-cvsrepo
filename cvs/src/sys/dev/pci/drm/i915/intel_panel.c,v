head	1.15;
access;
symbols
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.6
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2017.09.30.07.36.56;	author robert;	state Exp;
branches;
next	1.14;
commitid	XkWOvf4INOmfke72;

1.14
date	2017.07.05.20.30.13;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	wA527vsQhGJhZItC;

1.13
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	KnwRPOZok9A30HI4;

1.12
date	2017.03.07.02.48.15;	author jcs;	state Exp;
branches;
next	1.11;
commitid	ubWBTO5ZGyDiRxAe;

1.11
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	lQlppvmETCN49oZe;

1.10
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.9;
commitid	c1fUeeFWMNg4COgR;

1.9
date	2015.04.18.11.05.32;	author jsg;	state Exp;
branches;
next	1.8;
commitid	N5rmYm7ybHimJmMa;

1.8
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	adfbJ0ccUTdhFGhI;

1.7
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.24.04.05.06;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2014.01.24.03.21.17;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.13.10.23.52;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.04.09.55.01;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Add preliminary kabylake support to inteldrm(4) by backporting the relevant
commits from linux-4.8.x.
The changes are quiet minimal due to the fact that kabylake and skylake share
most of the code because they are both gen9 graphics.
This was tested by many and was also in snapshots for a while.

ok kettenis@@
@
text
@/*
 * Copyright Â© 2006-2010 Intel Corporation
 * Copyright (c) 2006 Dave Airlie <airlied@@linux.ie>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *	Eric Anholt <eric@@anholt.net>
 *      Dave Airlie <airlied@@linux.ie>
 *      Jesse Barnes <jesse.barnes@@intel.com>
 *      Chris Wilson <chris@@chris-wilson.co.uk>
 */

#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#ifdef __linux__
#include <linux/kernel.h>
#include <linux/moduleparam.h>
#include <linux/pwm.h>
#endif
#include "intel_drv.h"

#define CRC_PMIC_PWM_PERIOD_NS	21333

void
intel_fixed_panel_mode(const struct drm_display_mode *fixed_mode,
		       struct drm_display_mode *adjusted_mode)
{
	drm_mode_copy(adjusted_mode, fixed_mode);

	drm_mode_set_crtcinfo(adjusted_mode, 0);
}

/**
 * intel_find_panel_downclock - find the reduced downclock for LVDS in EDID
 * @@dev: drm device
 * @@fixed_mode : panel native mode
 * @@connector: LVDS/eDP connector
 *
 * Return downclock_avail
 * Find the reduced downclock for LVDS/eDP in EDID.
 */
struct drm_display_mode *
intel_find_panel_downclock(struct drm_device *dev,
			struct drm_display_mode *fixed_mode,
			struct drm_connector *connector)
{
	struct drm_display_mode *scan, *tmp_mode;
	int temp_downclock;

	temp_downclock = fixed_mode->clock;
	tmp_mode = NULL;

	list_for_each_entry(scan, &connector->probed_modes, head) {
		/*
		 * If one mode has the same resolution with the fixed_panel
		 * mode while they have the different refresh rate, it means
		 * that the reduced downclock is found. In such
		 * case we can set the different FPx0/1 to dynamically select
		 * between low and high frequency.
		 */
		if (scan->hdisplay == fixed_mode->hdisplay &&
		    scan->hsync_start == fixed_mode->hsync_start &&
		    scan->hsync_end == fixed_mode->hsync_end &&
		    scan->htotal == fixed_mode->htotal &&
		    scan->vdisplay == fixed_mode->vdisplay &&
		    scan->vsync_start == fixed_mode->vsync_start &&
		    scan->vsync_end == fixed_mode->vsync_end &&
		    scan->vtotal == fixed_mode->vtotal) {
			if (scan->clock < temp_downclock) {
				/*
				 * The downclock is already found. But we
				 * expect to find the lower downclock.
				 */
				temp_downclock = scan->clock;
				tmp_mode = scan;
			}
		}
	}

	if (temp_downclock < fixed_mode->clock)
		return drm_mode_duplicate(dev, tmp_mode);
	else
		return NULL;
}

/* adjusted_mode has been preset to be the panel's fixed mode */
void
intel_pch_panel_fitting(struct intel_crtc *intel_crtc,
			struct intel_crtc_state *pipe_config,
			int fitting_mode)
{
	const struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	int x = 0, y = 0, width = 0, height = 0;

	/* Native modes don't need fitting */
	if (adjusted_mode->crtc_hdisplay == pipe_config->pipe_src_w &&
	    adjusted_mode->crtc_vdisplay == pipe_config->pipe_src_h)
		goto done;

	switch (fitting_mode) {
	case DRM_MODE_SCALE_CENTER:
		width = pipe_config->pipe_src_w;
		height = pipe_config->pipe_src_h;
		x = (adjusted_mode->crtc_hdisplay - width + 1)/2;
		y = (adjusted_mode->crtc_vdisplay - height + 1)/2;
		break;

	case DRM_MODE_SCALE_ASPECT:
		/* Scale but preserve the aspect ratio */
		{
			u32 scaled_width = adjusted_mode->crtc_hdisplay
				* pipe_config->pipe_src_h;
			u32 scaled_height = pipe_config->pipe_src_w
				* adjusted_mode->crtc_vdisplay;
			if (scaled_width > scaled_height) { /* pillar */
				width = scaled_height / pipe_config->pipe_src_h;
				if (width & 1)
					width++;
				x = (adjusted_mode->crtc_hdisplay - width + 1) / 2;
				y = 0;
				height = adjusted_mode->crtc_vdisplay;
			} else if (scaled_width < scaled_height) { /* letter */
				height = scaled_width / pipe_config->pipe_src_w;
				if (height & 1)
				    height++;
				y = (adjusted_mode->crtc_vdisplay - height + 1) / 2;
				x = 0;
				width = adjusted_mode->crtc_hdisplay;
			} else {
				x = y = 0;
				width = adjusted_mode->crtc_hdisplay;
				height = adjusted_mode->crtc_vdisplay;
			}
		}
		break;

	case DRM_MODE_SCALE_FULLSCREEN:
		x = y = 0;
		width = adjusted_mode->crtc_hdisplay;
		height = adjusted_mode->crtc_vdisplay;
		break;

	default:
		WARN(1, "bad panel fit mode: %d\n", fitting_mode);
		return;
	}

done:
	pipe_config->pch_pfit.pos = (x << 16) | y;
	pipe_config->pch_pfit.size = (width << 16) | height;
	pipe_config->pch_pfit.enabled = pipe_config->pch_pfit.size != 0;
}

static void
centre_horizontally(struct drm_display_mode *adjusted_mode,
		    int width)
{
	u32 border, sync_pos, blank_width, sync_width;

	/* keep the hsync and hblank widths constant */
	sync_width = adjusted_mode->crtc_hsync_end - adjusted_mode->crtc_hsync_start;
	blank_width = adjusted_mode->crtc_hblank_end - adjusted_mode->crtc_hblank_start;
	sync_pos = (blank_width - sync_width + 1) / 2;

	border = (adjusted_mode->crtc_hdisplay - width + 1) / 2;
	border += border & 1; /* make the border even */

	adjusted_mode->crtc_hdisplay = width;
	adjusted_mode->crtc_hblank_start = width + border;
	adjusted_mode->crtc_hblank_end = adjusted_mode->crtc_hblank_start + blank_width;

	adjusted_mode->crtc_hsync_start = adjusted_mode->crtc_hblank_start + sync_pos;
	adjusted_mode->crtc_hsync_end = adjusted_mode->crtc_hsync_start + sync_width;
}

static void
centre_vertically(struct drm_display_mode *adjusted_mode,
		  int height)
{
	u32 border, sync_pos, blank_width, sync_width;

	/* keep the vsync and vblank widths constant */
	sync_width = adjusted_mode->crtc_vsync_end - adjusted_mode->crtc_vsync_start;
	blank_width = adjusted_mode->crtc_vblank_end - adjusted_mode->crtc_vblank_start;
	sync_pos = (blank_width - sync_width + 1) / 2;

	border = (adjusted_mode->crtc_vdisplay - height + 1) / 2;

	adjusted_mode->crtc_vdisplay = height;
	adjusted_mode->crtc_vblank_start = height + border;
	adjusted_mode->crtc_vblank_end = adjusted_mode->crtc_vblank_start + blank_width;

	adjusted_mode->crtc_vsync_start = adjusted_mode->crtc_vblank_start + sync_pos;
	adjusted_mode->crtc_vsync_end = adjusted_mode->crtc_vsync_start + sync_width;
}

static inline u32 panel_fitter_scaling(u32 source, u32 target)
{
	/*
	 * Floating point operation is not supported. So the FACTOR
	 * is defined, which can avoid the floating point computation
	 * when calculating the panel ratio.
	 */
#define ACCURACY 12
#define FACTOR (1 << ACCURACY)
	u32 ratio = source * FACTOR / target;
	return (FACTOR * ratio + FACTOR/2) / FACTOR;
}

static void i965_scale_aspect(struct intel_crtc_state *pipe_config,
			      u32 *pfit_control)
{
	const struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	u32 scaled_width = adjusted_mode->crtc_hdisplay *
		pipe_config->pipe_src_h;
	u32 scaled_height = pipe_config->pipe_src_w *
		adjusted_mode->crtc_vdisplay;

	/* 965+ is easy, it does everything in hw */
	if (scaled_width > scaled_height)
		*pfit_control |= PFIT_ENABLE |
			PFIT_SCALING_PILLAR;
	else if (scaled_width < scaled_height)
		*pfit_control |= PFIT_ENABLE |
			PFIT_SCALING_LETTER;
	else if (adjusted_mode->crtc_hdisplay != pipe_config->pipe_src_w)
		*pfit_control |= PFIT_ENABLE | PFIT_SCALING_AUTO;
}

static void i9xx_scale_aspect(struct intel_crtc_state *pipe_config,
			      u32 *pfit_control, u32 *pfit_pgm_ratios,
			      u32 *border)
{
	struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	u32 scaled_width = adjusted_mode->crtc_hdisplay *
		pipe_config->pipe_src_h;
	u32 scaled_height = pipe_config->pipe_src_w *
		adjusted_mode->crtc_vdisplay;
	u32 bits;

	/*
	 * For earlier chips we have to calculate the scaling
	 * ratio by hand and program it into the
	 * PFIT_PGM_RATIO register
	 */
	if (scaled_width > scaled_height) { /* pillar */
		centre_horizontally(adjusted_mode,
				    scaled_height /
				    pipe_config->pipe_src_h);

		*border = LVDS_BORDER_ENABLE;
		if (pipe_config->pipe_src_h != adjusted_mode->crtc_vdisplay) {
			bits = panel_fitter_scaling(pipe_config->pipe_src_h,
						    adjusted_mode->crtc_vdisplay);

			*pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |
					     bits << PFIT_VERT_SCALE_SHIFT);
			*pfit_control |= (PFIT_ENABLE |
					  VERT_INTERP_BILINEAR |
					  HORIZ_INTERP_BILINEAR);
		}
	} else if (scaled_width < scaled_height) { /* letter */
		centre_vertically(adjusted_mode,
				  scaled_width /
				  pipe_config->pipe_src_w);

		*border = LVDS_BORDER_ENABLE;
		if (pipe_config->pipe_src_w != adjusted_mode->crtc_hdisplay) {
			bits = panel_fitter_scaling(pipe_config->pipe_src_w,
						    adjusted_mode->crtc_hdisplay);

			*pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |
					     bits << PFIT_VERT_SCALE_SHIFT);
			*pfit_control |= (PFIT_ENABLE |
					  VERT_INTERP_BILINEAR |
					  HORIZ_INTERP_BILINEAR);
		}
	} else {
		/* Aspects match, Let hw scale both directions */
		*pfit_control |= (PFIT_ENABLE |
				  VERT_AUTO_SCALE | HORIZ_AUTO_SCALE |
				  VERT_INTERP_BILINEAR |
				  HORIZ_INTERP_BILINEAR);
	}
}

void intel_gmch_panel_fitting(struct intel_crtc *intel_crtc,
			      struct intel_crtc_state *pipe_config,
			      int fitting_mode)
{
	struct drm_device *dev = intel_crtc->base.dev;
	u32 pfit_control = 0, pfit_pgm_ratios = 0, border = 0;
	struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;

	/* Native modes don't need fitting */
	if (adjusted_mode->crtc_hdisplay == pipe_config->pipe_src_w &&
	    adjusted_mode->crtc_vdisplay == pipe_config->pipe_src_h)
		goto out;

	switch (fitting_mode) {
	case DRM_MODE_SCALE_CENTER:
		/*
		 * For centered modes, we have to calculate border widths &
		 * heights and modify the values programmed into the CRTC.
		 */
		centre_horizontally(adjusted_mode, pipe_config->pipe_src_w);
		centre_vertically(adjusted_mode, pipe_config->pipe_src_h);
		border = LVDS_BORDER_ENABLE;
		break;
	case DRM_MODE_SCALE_ASPECT:
		/* Scale but preserve the aspect ratio */
		if (INTEL_INFO(dev)->gen >= 4)
			i965_scale_aspect(pipe_config, &pfit_control);
		else
			i9xx_scale_aspect(pipe_config, &pfit_control,
					  &pfit_pgm_ratios, &border);
		break;
	case DRM_MODE_SCALE_FULLSCREEN:
		/*
		 * Full scaling, even if it changes the aspect ratio.
		 * Fortunately this is all done for us in hw.
		 */
		if (pipe_config->pipe_src_h != adjusted_mode->crtc_vdisplay ||
		    pipe_config->pipe_src_w != adjusted_mode->crtc_hdisplay) {
			pfit_control |= PFIT_ENABLE;
			if (INTEL_INFO(dev)->gen >= 4)
				pfit_control |= PFIT_SCALING_AUTO;
			else
				pfit_control |= (VERT_AUTO_SCALE |
						 VERT_INTERP_BILINEAR |
						 HORIZ_AUTO_SCALE |
						 HORIZ_INTERP_BILINEAR);
		}
		break;
	default:
		WARN(1, "bad panel fit mode: %d\n", fitting_mode);
		return;
	}

	/* 965+ wants fuzzy fitting */
	/* FIXME: handle multiple panels by failing gracefully */
	if (INTEL_INFO(dev)->gen >= 4)
		pfit_control |= ((intel_crtc->pipe << PFIT_PIPE_SHIFT) |
				 PFIT_FILTER_FUZZY);

out:
	if ((pfit_control & PFIT_ENABLE) == 0) {
		pfit_control = 0;
		pfit_pgm_ratios = 0;
	}

	/* Make sure pre-965 set dither correctly for 18bpp panels. */
	if (INTEL_INFO(dev)->gen < 4 && pipe_config->pipe_bpp == 18)
		pfit_control |= PANEL_8TO6_DITHER_ENABLE;

	pipe_config->gmch_pfit.control = pfit_control;
	pipe_config->gmch_pfit.pgm_ratios = pfit_pgm_ratios;
	pipe_config->gmch_pfit.lvds_border_bits = border;
}

enum drm_connector_status
intel_panel_detect(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* Assume that the BIOS does not lie through the OpRegion... */
	if (!i915.panel_ignore_lid && dev_priv->opregion.lid_state) {
		return *dev_priv->opregion.lid_state & 0x1 ?
			connector_status_connected :
			connector_status_disconnected;
	}

	switch (i915.panel_ignore_lid) {
	case -2:
		return connector_status_connected;
	case -1:
		return connector_status_disconnected;
	default:
		return connector_status_unknown;
	}
}

/**
 * scale - scale values from one range to another
 *
 * @@source_val: value in range [@@source_min..@@source_max]
 *
 * Return @@source_val in range [@@source_min..@@source_max] scaled to range
 * [@@target_min..@@target_max].
 */
static uint32_t scale(uint32_t source_val,
		      uint32_t source_min, uint32_t source_max,
		      uint32_t target_min, uint32_t target_max)
{
	uint64_t target_val;

	WARN_ON(source_min > source_max);
	WARN_ON(target_min > target_max);

	/* defensive */
	source_val = clamp(source_val, source_min, source_max);

	/* avoid overflows */
	target_val = DIV_ROUND_CLOSEST_ULL((uint64_t)(source_val - source_min) *
			(target_max - target_min), source_max - source_min);
	target_val += target_min;

	return target_val;
}

/* Scale user_level in range [0..user_max] to [hw_min..hw_max]. */
static inline u32 scale_user_to_hw(struct intel_connector *connector,
				   u32 user_level, u32 user_max)
{
	struct intel_panel *panel = &connector->panel;

	return scale(user_level, 0, user_max,
		     panel->backlight.min, panel->backlight.max);
}

/* Scale user_level in range [0..user_max] to [0..hw_max], clamping the result
 * to [hw_min..hw_max]. */
static inline u32 clamp_user_to_hw(struct intel_connector *connector,
				   u32 user_level, u32 user_max)
{
	struct intel_panel *panel = &connector->panel;
	u32 hw_level;

	hw_level = scale(user_level, 0, user_max, 0, panel->backlight.max);
	hw_level = clamp(hw_level, panel->backlight.min, panel->backlight.max);

	return hw_level;
}

/* Scale hw_level in range [hw_min..hw_max] to [0..user_max]. */
static inline u32 scale_hw_to_user(struct intel_connector *connector,
				   u32 hw_level, u32 user_max)
{
	struct intel_panel *panel = &connector->panel;

	return scale(hw_level, panel->backlight.min, panel->backlight.max,
		     0, user_max);
}

static u32 intel_panel_compute_brightness(struct intel_connector *connector,
					  u32 val)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;

	WARN_ON(panel->backlight.max == 0);

	if (i915.invert_brightness < 0)
		return val;

	if (i915.invert_brightness > 0 ||
	    dev_priv->quirks & QUIRK_INVERT_BRIGHTNESS) {
		return panel->backlight.max - val;
	}

	return val;
}

static u32 lpt_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	return I915_READ(BLC_PWM_PCH_CTL2) & BACKLIGHT_DUTY_CYCLE_MASK;
}

static u32 pch_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	return I915_READ(BLC_PWM_CPU_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;
}

static u32 i9xx_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 val;

	val = I915_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;
	if (INTEL_INFO(dev)->gen < 4)
		val >>= 1;

	if (panel->backlight.combination_mode) {
		u8 lbpc;

		pci_read_config_byte(dev->pdev, PCI_LBPC, &lbpc);
		val *= lbpc;
	}

	return val;
}

static u32 _vlv_get_backlight(struct drm_device *dev, enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return 0;

	return I915_READ(VLV_BLC_PWM_CTL(pipe)) & BACKLIGHT_DUTY_CYCLE_MASK;
}

static u32 vlv_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	enum pipe pipe = intel_get_pipe_from_connector(connector);

	return _vlv_get_backlight(dev, pipe);
}

static u32 bxt_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct intel_panel *panel = &connector->panel;
	struct drm_i915_private *dev_priv = dev->dev_private;

	return I915_READ(BXT_BLC_PWM_DUTY(panel->backlight.controller));
}

static u32 pwm_get_backlight(struct intel_connector *connector)
{
	struct intel_panel *panel = &connector->panel;
	int duty_ns;

	duty_ns = pwm_get_duty_cycle(panel->backlight.pwm);
	return DIV_ROUND_UP(duty_ns * 100, CRC_PMIC_PWM_PERIOD_NS);
}

static u32 intel_panel_get_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 val = 0;

	mutex_lock(&dev_priv->backlight_lock);

	if (panel->backlight.enabled) {
		val = panel->backlight.get(connector);
		val = intel_panel_compute_brightness(connector, val);
	}

	mutex_unlock(&dev_priv->backlight_lock);

	DRM_DEBUG_DRIVER("get backlight PWM = %d\n", val);
	return val;
}

static void lpt_set_backlight(struct intel_connector *connector, u32 level)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val = I915_READ(BLC_PWM_PCH_CTL2) & ~BACKLIGHT_DUTY_CYCLE_MASK;
	I915_WRITE(BLC_PWM_PCH_CTL2, val | level);
}

static void pch_set_backlight(struct intel_connector *connector, u32 level)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp;

	tmp = I915_READ(BLC_PWM_CPU_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;
	I915_WRITE(BLC_PWM_CPU_CTL, tmp | level);
}

static void i9xx_set_backlight(struct intel_connector *connector, u32 level)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 tmp, mask;

	WARN_ON(panel->backlight.max == 0);

	if (panel->backlight.combination_mode) {
		u8 lbpc;

		lbpc = level * 0xfe / panel->backlight.max + 1;
		level /= lbpc;
		pci_write_config_byte(dev->pdev, PCI_LBPC, lbpc);
	}

	if (IS_GEN4(dev)) {
		mask = BACKLIGHT_DUTY_CYCLE_MASK;
	} else {
		level <<= 1;
		mask = BACKLIGHT_DUTY_CYCLE_MASK_PNV;
	}

	tmp = I915_READ(BLC_PWM_CTL) & ~mask;
	I915_WRITE(BLC_PWM_CTL, tmp | level);
}

static void vlv_set_backlight(struct intel_connector *connector, u32 level)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 tmp;

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return;

	tmp = I915_READ(VLV_BLC_PWM_CTL(pipe)) & ~BACKLIGHT_DUTY_CYCLE_MASK;
	I915_WRITE(VLV_BLC_PWM_CTL(pipe), tmp | level);
}

static void bxt_set_backlight(struct intel_connector *connector, u32 level)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;

	I915_WRITE(BXT_BLC_PWM_DUTY(panel->backlight.controller), level);
}

static void pwm_set_backlight(struct intel_connector *connector, u32 level)
{
	struct intel_panel *panel = &connector->panel;
	int duty_ns = DIV_ROUND_UP(level * CRC_PMIC_PWM_PERIOD_NS, 100);

	pwm_config(panel->backlight.pwm, duty_ns, CRC_PMIC_PWM_PERIOD_NS);
}

static void
intel_panel_actually_set_backlight(struct intel_connector *connector, u32 level)
{
	struct intel_panel *panel = &connector->panel;

	DRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);

	level = intel_panel_compute_brightness(connector, level);
	panel->backlight.set(connector, level);
}

/* set backlight brightness to level in range [0..max], scaling wrt hw min */
static void intel_panel_set_backlight(struct intel_connector *connector,
				      u32 user_level, u32 user_max)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 hw_level;

	if (!panel->backlight.present)
		return;

	mutex_lock(&dev_priv->backlight_lock);

	WARN_ON(panel->backlight.max == 0);

	hw_level = scale_user_to_hw(connector, user_level, user_max);
	panel->backlight.level = hw_level;

	if (panel->backlight.enabled)
		intel_panel_actually_set_backlight(connector, hw_level);

	mutex_unlock(&dev_priv->backlight_lock);
}

/* set backlight brightness to level in range [0..max], assuming hw min is
 * respected.
 */
void intel_panel_set_backlight_acpi(struct intel_connector *connector,
				    u32 user_level, u32 user_max)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 hw_level;

	/*
	 * INVALID_PIPE may occur during driver init because
	 * connection_mutex isn't held across the entire backlight
	 * setup + modeset readout, and the BIOS can issue the
	 * requests at any time.
	 */
	if (!panel->backlight.present || pipe == INVALID_PIPE)
		return;

	mutex_lock(&dev_priv->backlight_lock);

	WARN_ON(panel->backlight.max == 0);

	hw_level = clamp_user_to_hw(connector, user_level, user_max);
	panel->backlight.level = hw_level;

	if (panel->backlight.device)
		panel->backlight.device->props.brightness =
			scale_hw_to_user(connector,
					 panel->backlight.level,
					 panel->backlight.device->props.max_brightness);

	if (panel->backlight.enabled)
		intel_panel_actually_set_backlight(connector, hw_level);

	mutex_unlock(&dev_priv->backlight_lock);
}

static void lpt_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp;

	intel_panel_actually_set_backlight(connector, 0);

	/*
	 * Although we don't support or enable CPU PWM with LPT/SPT based
	 * systems, it may have been enabled prior to loading the
	 * driver. Disable to avoid warnings on LCPLL disable.
	 *
	 * This needs rework if we need to add support for CPU PWM on PCH split
	 * platforms.
	 */
	tmp = I915_READ(BLC_PWM_CPU_CTL2);
	if (tmp & BLM_PWM_ENABLE) {
		DRM_DEBUG_KMS("cpu backlight was enabled, disabling\n");
		I915_WRITE(BLC_PWM_CPU_CTL2, tmp & ~BLM_PWM_ENABLE);
	}

	tmp = I915_READ(BLC_PWM_PCH_CTL1);
	I915_WRITE(BLC_PWM_PCH_CTL1, tmp & ~BLM_PCH_PWM_ENABLE);
}

static void pch_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp;

	intel_panel_actually_set_backlight(connector, 0);

	tmp = I915_READ(BLC_PWM_CPU_CTL2);
	I915_WRITE(BLC_PWM_CPU_CTL2, tmp & ~BLM_PWM_ENABLE);

	tmp = I915_READ(BLC_PWM_PCH_CTL1);
	I915_WRITE(BLC_PWM_PCH_CTL1, tmp & ~BLM_PCH_PWM_ENABLE);
}

static void i9xx_disable_backlight(struct intel_connector *connector)
{
	intel_panel_actually_set_backlight(connector, 0);
}

static void i965_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp;

	intel_panel_actually_set_backlight(connector, 0);

	tmp = I915_READ(BLC_PWM_CTL2);
	I915_WRITE(BLC_PWM_CTL2, tmp & ~BLM_PWM_ENABLE);
}

static void vlv_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 tmp;

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return;

	intel_panel_actually_set_backlight(connector, 0);

	tmp = I915_READ(VLV_BLC_PWM_CTL2(pipe));
	I915_WRITE(VLV_BLC_PWM_CTL2(pipe), tmp & ~BLM_PWM_ENABLE);
}

static void bxt_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 tmp, val;

	intel_panel_actually_set_backlight(connector, 0);

	tmp = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));
	I915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),
			tmp & ~BXT_BLC_PWM_ENABLE);

	if (panel->backlight.controller == 1) {
		val = I915_READ(UTIL_PIN_CTL);
		val &= ~UTIL_PIN_ENABLE;
		I915_WRITE(UTIL_PIN_CTL, val);
	}
}

static void pwm_disable_backlight(struct intel_connector *connector)
{
	struct intel_panel *panel = &connector->panel;

	/* Disable the backlight */
	pwm_config(panel->backlight.pwm, 0, CRC_PMIC_PWM_PERIOD_NS);
	usleep_range(2000, 3000);
	pwm_disable(panel->backlight.pwm);
}

void intel_panel_disable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;

	if (!panel->backlight.present)
		return;

#ifdef __linux__
	/*
	 * Do not disable backlight on the vga_switcheroo path. When switching
	 * away from i915, the other client may depend on i915 to handle the
	 * backlight. This will leave the backlight on unnecessarily when
	 * another client is not activated.
	 */
	if (dev->switch_power_state == DRM_SWITCH_POWER_CHANGING) {
		DRM_DEBUG_DRIVER("Skipping backlight disable on vga switch\n");
		return;
	}
#endif

	mutex_lock(&dev_priv->backlight_lock);

	if (panel->backlight.device)
		panel->backlight.device->props.power = FB_BLANK_POWERDOWN;
	panel->backlight.enabled = false;
	panel->backlight.disable(connector);

	mutex_unlock(&dev_priv->backlight_lock);
}

static void lpt_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 pch_ctl1, pch_ctl2, schicken;

	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
	if (pch_ctl1 & BLM_PCH_PWM_ENABLE) {
		DRM_DEBUG_KMS("pch backlight already enabled\n");
		pch_ctl1 &= ~BLM_PCH_PWM_ENABLE;
		I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);
	}

	if (HAS_PCH_LPT(dev)) {
		schicken = I915_READ(SOUTH_CHICKEN2);
		if (panel->backlight.alternate_pwm_increment)
			schicken |= LPT_PWM_GRANULARITY;
		else
			schicken &= ~LPT_PWM_GRANULARITY;
		I915_WRITE(SOUTH_CHICKEN2, schicken);
	} else {
		schicken = I915_READ(SOUTH_CHICKEN1);
		if (panel->backlight.alternate_pwm_increment)
			schicken |= SPT_PWM_GRANULARITY;
		else
			schicken &= ~SPT_PWM_GRANULARITY;
		I915_WRITE(SOUTH_CHICKEN1, schicken);
	}

	pch_ctl2 = panel->backlight.max << 16;
	I915_WRITE(BLC_PWM_PCH_CTL2, pch_ctl2);

	pch_ctl1 = 0;
	if (panel->backlight.active_low_pwm)
		pch_ctl1 |= BLM_PCH_POLARITY;

	/* After LPT, override is the default. */
	if (HAS_PCH_LPT(dev_priv))
		pch_ctl1 |= BLM_PCH_OVERRIDE_ENABLE;

	I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);
	POSTING_READ(BLC_PWM_PCH_CTL1);
	I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);

	/* This won't stick until the above enable. */
	intel_panel_actually_set_backlight(connector, panel->backlight.level);
}

static void pch_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	enum transcoder cpu_transcoder =
		intel_pipe_to_cpu_transcoder(dev_priv, pipe);
	u32 cpu_ctl2, pch_ctl1, pch_ctl2;

	cpu_ctl2 = I915_READ(BLC_PWM_CPU_CTL2);
	if (cpu_ctl2 & BLM_PWM_ENABLE) {
		DRM_DEBUG_KMS("cpu backlight already enabled\n");
		cpu_ctl2 &= ~BLM_PWM_ENABLE;
		I915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2);
	}

	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
	if (pch_ctl1 & BLM_PCH_PWM_ENABLE) {
		DRM_DEBUG_KMS("pch backlight already enabled\n");
		pch_ctl1 &= ~BLM_PCH_PWM_ENABLE;
		I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);
	}

	if (cpu_transcoder == TRANSCODER_EDP)
		cpu_ctl2 = BLM_TRANSCODER_EDP;
	else
		cpu_ctl2 = BLM_PIPE(cpu_transcoder);
	I915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2);
	POSTING_READ(BLC_PWM_CPU_CTL2);
	I915_WRITE(BLC_PWM_CPU_CTL2, cpu_ctl2 | BLM_PWM_ENABLE);

	/* This won't stick until the above enable. */
	intel_panel_actually_set_backlight(connector, panel->backlight.level);

	pch_ctl2 = panel->backlight.max << 16;
	I915_WRITE(BLC_PWM_PCH_CTL2, pch_ctl2);

	pch_ctl1 = 0;
	if (panel->backlight.active_low_pwm)
		pch_ctl1 |= BLM_PCH_POLARITY;

	I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);
	POSTING_READ(BLC_PWM_PCH_CTL1);
	I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1 | BLM_PCH_PWM_ENABLE);
}

static void i9xx_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 ctl, freq;

	ctl = I915_READ(BLC_PWM_CTL);
	if (ctl & BACKLIGHT_DUTY_CYCLE_MASK_PNV) {
		DRM_DEBUG_KMS("backlight already enabled\n");
		I915_WRITE(BLC_PWM_CTL, 0);
	}

	freq = panel->backlight.max;
	if (panel->backlight.combination_mode)
		freq /= 0xff;

	ctl = freq << 17;
	if (panel->backlight.combination_mode)
		ctl |= BLM_LEGACY_MODE;
	if (IS_PINEVIEW(dev) && panel->backlight.active_low_pwm)
		ctl |= BLM_POLARITY_PNV;

	I915_WRITE(BLC_PWM_CTL, ctl);
	POSTING_READ(BLC_PWM_CTL);

	/* XXX: combine this into above write? */
	intel_panel_actually_set_backlight(connector, panel->backlight.level);

	/*
	 * Needed to enable backlight on some 855gm models. BLC_HIST_CTL is
	 * 855gm only, but checking for gen2 is safe, as 855gm is the only gen2
	 * that has backlight.
	 */
	if (IS_GEN2(dev))
		I915_WRITE(BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);
}

static void i965_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 ctl, ctl2, freq;

	ctl2 = I915_READ(BLC_PWM_CTL2);
	if (ctl2 & BLM_PWM_ENABLE) {
		DRM_DEBUG_KMS("backlight already enabled\n");
		ctl2 &= ~BLM_PWM_ENABLE;
		I915_WRITE(BLC_PWM_CTL2, ctl2);
	}

	freq = panel->backlight.max;
	if (panel->backlight.combination_mode)
		freq /= 0xff;

	ctl = freq << 16;
	I915_WRITE(BLC_PWM_CTL, ctl);

	ctl2 = BLM_PIPE(pipe);
	if (panel->backlight.combination_mode)
		ctl2 |= BLM_COMBINATION_MODE;
	if (panel->backlight.active_low_pwm)
		ctl2 |= BLM_POLARITY_I965;
	I915_WRITE(BLC_PWM_CTL2, ctl2);
	POSTING_READ(BLC_PWM_CTL2);
	I915_WRITE(BLC_PWM_CTL2, ctl2 | BLM_PWM_ENABLE);

	intel_panel_actually_set_backlight(connector, panel->backlight.level);
}

static void vlv_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 ctl, ctl2;

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return;

	ctl2 = I915_READ(VLV_BLC_PWM_CTL2(pipe));
	if (ctl2 & BLM_PWM_ENABLE) {
		DRM_DEBUG_KMS("backlight already enabled\n");
		ctl2 &= ~BLM_PWM_ENABLE;
		I915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2);
	}

	ctl = panel->backlight.max << 16;
	I915_WRITE(VLV_BLC_PWM_CTL(pipe), ctl);

	/* XXX: combine this into above write? */
	intel_panel_actually_set_backlight(connector, panel->backlight.level);

	ctl2 = 0;
	if (panel->backlight.active_low_pwm)
		ctl2 |= BLM_POLARITY_I965;
	I915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2);
	POSTING_READ(VLV_BLC_PWM_CTL2(pipe));
	I915_WRITE(VLV_BLC_PWM_CTL2(pipe), ctl2 | BLM_PWM_ENABLE);
}

static void bxt_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	u32 pwm_ctl, val;

	/* To use 2nd set of backlight registers, utility pin has to be
	 * enabled with PWM mode.
	 * The field should only be changed when the utility pin is disabled
	 */
	if (panel->backlight.controller == 1) {
		val = I915_READ(UTIL_PIN_CTL);
		if (val & UTIL_PIN_ENABLE) {
			DRM_DEBUG_KMS("util pin already enabled\n");
			val &= ~UTIL_PIN_ENABLE;
			I915_WRITE(UTIL_PIN_CTL, val);
		}

		val = 0;
		if (panel->backlight.util_pin_active_low)
			val |= UTIL_PIN_POLARITY;
		I915_WRITE(UTIL_PIN_CTL, val | UTIL_PIN_PIPE(pipe) |
				UTIL_PIN_MODE_PWM | UTIL_PIN_ENABLE);
	}

	pwm_ctl = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));
	if (pwm_ctl & BXT_BLC_PWM_ENABLE) {
		DRM_DEBUG_KMS("backlight already enabled\n");
		pwm_ctl &= ~BXT_BLC_PWM_ENABLE;
		I915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),
				pwm_ctl);
	}

	I915_WRITE(BXT_BLC_PWM_FREQ(panel->backlight.controller),
			panel->backlight.max);

	intel_panel_actually_set_backlight(connector, panel->backlight.level);

	pwm_ctl = 0;
	if (panel->backlight.active_low_pwm)
		pwm_ctl |= BXT_BLC_PWM_POLARITY;

	I915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller), pwm_ctl);
	POSTING_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));
	I915_WRITE(BXT_BLC_PWM_CTL(panel->backlight.controller),
			pwm_ctl | BXT_BLC_PWM_ENABLE);
}

static void pwm_enable_backlight(struct intel_connector *connector)
{
	struct intel_panel *panel = &connector->panel;

	pwm_enable(panel->backlight.pwm);
	intel_panel_actually_set_backlight(connector, panel->backlight.level);
}

void intel_panel_enable_backlight(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
#ifdef DRMDEBUG
	enum pipe pipe = intel_get_pipe_from_connector(connector);
#endif

	if (!panel->backlight.present)
		return;

	DRM_DEBUG_KMS("pipe %c\n", pipe_name(pipe));

	mutex_lock(&dev_priv->backlight_lock);

	WARN_ON(panel->backlight.max == 0);

	if (panel->backlight.level <= panel->backlight.min) {
		panel->backlight.level = panel->backlight.max;
		if (panel->backlight.device)
			panel->backlight.device->props.brightness =
				scale_hw_to_user(connector,
						 panel->backlight.level,
						 panel->backlight.device->props.max_brightness);
	}

	panel->backlight.enable(connector);
	panel->backlight.enabled = true;
	if (panel->backlight.device)
		panel->backlight.device->props.power = FB_BLANK_UNBLANK;

	mutex_unlock(&dev_priv->backlight_lock);
}

#if IS_ENABLED(CONFIG_BACKLIGHT_CLASS_DEVICE)
static int intel_backlight_device_update_status(struct backlight_device *bd)
{
	struct intel_connector *connector = bl_get_data(bd);
	struct intel_panel *panel = &connector->panel;
	struct drm_device *dev = connector->base.dev;

	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
	DRM_DEBUG_KMS("updating intel_backlight, brightness=%d/%d\n",
		      bd->props.brightness, bd->props.max_brightness);
	intel_panel_set_backlight(connector, bd->props.brightness,
				  bd->props.max_brightness);

	/*
	 * Allow flipping bl_power as a sub-state of enabled. Sadly the
	 * backlight class device does not make it easy to to differentiate
	 * between callbacks for brightness and bl_power, so our backlight_power
	 * callback needs to take this into account.
	 */
	if (panel->backlight.enabled) {
		if (panel->backlight.power) {
			bool enable = bd->props.power == FB_BLANK_UNBLANK &&
				bd->props.brightness != 0;
			panel->backlight.power(connector, enable);
		}
	} else {
		bd->props.power = FB_BLANK_POWERDOWN;
	}

	drm_modeset_unlock(&dev->mode_config.connection_mutex);
	return 0;
}

static int intel_backlight_device_get_brightness(struct backlight_device *bd)
{
	struct intel_connector *connector = bl_get_data(bd);
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hw_level;
	int ret;

	intel_runtime_pm_get(dev_priv);
	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);

	hw_level = intel_panel_get_backlight(connector);
	ret = scale_hw_to_user(connector, hw_level, bd->props.max_brightness);

	drm_modeset_unlock(&dev->mode_config.connection_mutex);
	intel_runtime_pm_put(dev_priv);

	return ret;
}

static const struct backlight_ops intel_backlight_device_ops = {
	.update_status = intel_backlight_device_update_status,
	.get_brightness = intel_backlight_device_get_brightness,
};

static int intel_backlight_device_register(struct intel_connector *connector)
{
	struct intel_panel *panel = &connector->panel;
	struct backlight_properties props;

	if (WARN_ON(panel->backlight.device))
		return -ENODEV;

	if (!panel->backlight.present)
		return 0;

	WARN_ON(panel->backlight.max == 0);

	memset(&props, 0, sizeof(props));
	props.type = BACKLIGHT_RAW;

	/*
	 * Note: Everything should work even if the backlight device max
	 * presented to the userspace is arbitrarily chosen.
	 */
	props.max_brightness = panel->backlight.max;
	props.brightness = scale_hw_to_user(connector,
					    panel->backlight.level,
					    props.max_brightness);

	if (panel->backlight.enabled)
		props.power = FB_BLANK_UNBLANK;
	else
		props.power = FB_BLANK_POWERDOWN;

	/*
	 * Note: using the same name independent of the connector prevents
	 * registration of multiple backlight devices in the driver.
	 */
	panel->backlight.device =
		backlight_device_register("intel_backlight",
					  connector->base.kdev,
					  connector,
					  &intel_backlight_device_ops, &props);

	if (IS_ERR(panel->backlight.device)) {
		DRM_ERROR("Failed to register backlight: %ld\n",
			  PTR_ERR(panel->backlight.device));
		panel->backlight.device = NULL;
		return -ENODEV;
	}

	DRM_DEBUG_KMS("Connector %s backlight sysfs interface registered\n",
		      connector->base.name);

	return 0;
}

static void intel_backlight_device_unregister(struct intel_connector *connector)
{
	struct intel_panel *panel = &connector->panel;

	if (panel->backlight.device) {
		backlight_device_unregister(panel->backlight.device);
		panel->backlight.device = NULL;
	}
}
#else /* CONFIG_BACKLIGHT_CLASS_DEVICE */
static int intel_backlight_device_register(struct intel_connector *connector)
{
	return 0;
}
static void intel_backlight_device_unregister(struct intel_connector *connector)
{
}
#endif /* CONFIG_BACKLIGHT_CLASS_DEVICE */

/*
 * SPT: This value represents the period of the PWM stream in clock periods
 * multiplied by 16 (default increment) or 128 (alternate increment selected in
 * SCHICKEN_1 bit 0). PWM clock is 24 MHz.
 */
static u32 spt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 mul, clock;

	if (I915_READ(SOUTH_CHICKEN1) & SPT_PWM_GRANULARITY)
		mul = 128;
	else
		mul = 16;

	clock = MHz(24);

	return clock / (pwm_freq_hz * mul);
}

/*
 * LPT: This value represents the period of the PWM stream in clock periods
 * multiplied by 128 (default increment) or 16 (alternate increment, selected in
 * LPT SOUTH_CHICKEN2 register bit 5).
 */
static u32 lpt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 mul, clock;

	if (I915_READ(SOUTH_CHICKEN2) & LPT_PWM_GRANULARITY)
		mul = 16;
	else
		mul = 128;

	if (dev_priv->pch_id == INTEL_PCH_LPT_DEVICE_ID_TYPE)
		clock = MHz(135); /* LPT:H */
	else
		clock = MHz(24); /* LPT:LP */

	return clock / (pwm_freq_hz * mul);
}

/*
 * ILK/SNB/IVB: This value represents the period of the PWM stream in PCH
 * display raw clocks multiplied by 128.
 */
static u32 pch_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	int clock = MHz(intel_pch_rawclk(dev));

	return clock / (pwm_freq_hz * 128);
}

/*
 * Gen2: This field determines the number of time base events (display core
 * clock frequency/32) in total for a complete cycle of modulated backlight
 * control.
 *
 * Gen3: A time base event equals the display core clock ([DevPNV] HRAW clock)
 * divided by 32.
 */
static u32 i9xx_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int clock;

	if (IS_PINEVIEW(dev))
		clock = intel_hrawclk(dev);
	else
		clock = 1000 * dev_priv->display.get_display_clock_speed(dev);

	return clock / (pwm_freq_hz * 32);
}

/*
 * Gen4: This value represents the period of the PWM stream in display core
 * clocks multiplied by 128.
 */
static u32 i965_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int clock = 1000 * dev_priv->display.get_display_clock_speed(dev);

	return clock / (pwm_freq_hz * 128);
}

/*
 * VLV: This value represents the period of the PWM stream in display core
 * clocks ([DevCTG] 200MHz HRAW clocks) multiplied by 128 or 25MHz S0IX clocks
 * multiplied by 16. CHV uses a 19.2MHz S0IX clock.
 */
static u32 vlv_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int clock;

	if ((I915_READ(CBR1_VLV) & CBR_PWM_CLOCK_MUX_SELECT) == 0) {
		if (IS_CHERRYVIEW(dev))
			return KHz(19200) / (pwm_freq_hz * 16);
		else
			return MHz(25) / (pwm_freq_hz * 16);
	} else {
		clock = intel_hrawclk(dev);
		return MHz(clock) / (pwm_freq_hz * 128);
	}
}

static u32 get_backlight_max_vbt(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u16 pwm_freq_hz = dev_priv->vbt.backlight.pwm_freq_hz;
	u32 pwm;

	if (!pwm_freq_hz) {
		DRM_DEBUG_KMS("backlight frequency not specified in VBT\n");
		return 0;
	}

	if (!panel->backlight.hz_to_pwm) {
		DRM_DEBUG_KMS("backlight frequency setting from VBT currently not supported on this platform\n");
		return 0;
	}

	pwm = panel->backlight.hz_to_pwm(connector, pwm_freq_hz);
	if (!pwm) {
		DRM_DEBUG_KMS("backlight frequency conversion failed\n");
		return 0;
	}

	DRM_DEBUG_KMS("backlight frequency %u Hz from VBT\n", pwm_freq_hz);

	return pwm;
}

/*
 * Note: The setup hooks can't assume pipe is set!
 */
static u32 get_backlight_min_vbt(struct intel_connector *connector)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	int min;

	WARN_ON(panel->backlight.max == 0);

	/*
	 * XXX: If the vbt value is 255, it makes min equal to max, which leads
	 * to problems. There are such machines out there. Either our
	 * interpretation is wrong or the vbt has bogus data. Or both. Safeguard
	 * against this by letting the minimum be at most (arbitrarily chosen)
	 * 25% of the max.
	 */
	min = clamp_t(int, dev_priv->vbt.backlight.min_brightness, 0, 64);
	if (min != dev_priv->vbt.backlight.min_brightness) {
		DRM_DEBUG_KMS("clamping VBT min backlight %d/255 to %d/255\n",
			      dev_priv->vbt.backlight.min_brightness, min);
	}

	/* vbt value is a coefficient in range [0..255] */
	return scale(min, 0, 255, 0, panel->backlight.max);
}

static int lpt_setup_backlight(struct intel_connector *connector, enum pipe unused)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 pch_ctl1, pch_ctl2, val;
	bool alt;

	if (HAS_PCH_LPT(dev))
		alt = I915_READ(SOUTH_CHICKEN2) & LPT_PWM_GRANULARITY;
	else
		alt = I915_READ(SOUTH_CHICKEN1) & SPT_PWM_GRANULARITY;
	panel->backlight.alternate_pwm_increment = alt;

	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
	panel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;

	pch_ctl2 = I915_READ(BLC_PWM_PCH_CTL2);
	panel->backlight.max = pch_ctl2 >> 16;

	if (!panel->backlight.max)
		panel->backlight.max = get_backlight_max_vbt(connector);

	if (!panel->backlight.max)
		return -ENODEV;

	panel->backlight.min = get_backlight_min_vbt(connector);

	val = lpt_get_backlight(connector);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	panel->backlight.enabled = (pch_ctl1 & BLM_PCH_PWM_ENABLE) &&
		panel->backlight.level != 0;

	return 0;
}

static int pch_setup_backlight(struct intel_connector *connector, enum pipe unused)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 cpu_ctl2, pch_ctl1, pch_ctl2, val;

	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
	panel->backlight.active_low_pwm = pch_ctl1 & BLM_PCH_POLARITY;

	pch_ctl2 = I915_READ(BLC_PWM_PCH_CTL2);
	panel->backlight.max = pch_ctl2 >> 16;

	if (!panel->backlight.max)
		panel->backlight.max = get_backlight_max_vbt(connector);

	if (!panel->backlight.max)
		return -ENODEV;

	panel->backlight.min = get_backlight_min_vbt(connector);

	val = pch_get_backlight(connector);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	cpu_ctl2 = I915_READ(BLC_PWM_CPU_CTL2);
	panel->backlight.enabled = (cpu_ctl2 & BLM_PWM_ENABLE) &&
		(pch_ctl1 & BLM_PCH_PWM_ENABLE) && panel->backlight.level != 0;

	return 0;
}

static int i9xx_setup_backlight(struct intel_connector *connector, enum pipe unused)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 ctl, val;

	ctl = I915_READ(BLC_PWM_CTL);

	if (IS_GEN2(dev) || IS_I915GM(dev) || IS_I945GM(dev))
		panel->backlight.combination_mode = ctl & BLM_LEGACY_MODE;

	if (IS_PINEVIEW(dev))
		panel->backlight.active_low_pwm = ctl & BLM_POLARITY_PNV;

	panel->backlight.max = ctl >> 17;

	if (!panel->backlight.max) {
		panel->backlight.max = get_backlight_max_vbt(connector);
		panel->backlight.max >>= 1;
	}

	if (!panel->backlight.max)
		return -ENODEV;

	if (panel->backlight.combination_mode)
		panel->backlight.max *= 0xff;

	panel->backlight.min = get_backlight_min_vbt(connector);

	val = i9xx_get_backlight(connector);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	panel->backlight.enabled = panel->backlight.level != 0;

	return 0;
}

static int i965_setup_backlight(struct intel_connector *connector, enum pipe unused)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 ctl, ctl2, val;

	ctl2 = I915_READ(BLC_PWM_CTL2);
	panel->backlight.combination_mode = ctl2 & BLM_COMBINATION_MODE;
	panel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;

	ctl = I915_READ(BLC_PWM_CTL);
	panel->backlight.max = ctl >> 16;

	if (!panel->backlight.max)
		panel->backlight.max = get_backlight_max_vbt(connector);

	if (!panel->backlight.max)
		return -ENODEV;

	if (panel->backlight.combination_mode)
		panel->backlight.max *= 0xff;

	panel->backlight.min = get_backlight_min_vbt(connector);

	val = i9xx_get_backlight(connector);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	panel->backlight.enabled = (ctl2 & BLM_PWM_ENABLE) &&
		panel->backlight.level != 0;

	return 0;
}

static int vlv_setup_backlight(struct intel_connector *connector, enum pipe pipe)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 ctl, ctl2, val;

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return -ENODEV;

	ctl2 = I915_READ(VLV_BLC_PWM_CTL2(pipe));
	panel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;

	ctl = I915_READ(VLV_BLC_PWM_CTL(pipe));
	panel->backlight.max = ctl >> 16;

	if (!panel->backlight.max)
		panel->backlight.max = get_backlight_max_vbt(connector);

	if (!panel->backlight.max)
		return -ENODEV;

	panel->backlight.min = get_backlight_min_vbt(connector);

	val = _vlv_get_backlight(dev, pipe);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	panel->backlight.enabled = (ctl2 & BLM_PWM_ENABLE) &&
		panel->backlight.level != 0;

	return 0;
}

static int
bxt_setup_backlight(struct intel_connector *connector, enum pipe unused)
{
	struct drm_device *dev = connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_panel *panel = &connector->panel;
	u32 pwm_ctl, val;

	/*
	 * For BXT hard coding the Backlight controller to 0.
	 * TODO : Read the controller value from VBT and generalize
	 */
	panel->backlight.controller = 0;

	pwm_ctl = I915_READ(BXT_BLC_PWM_CTL(panel->backlight.controller));

	/* Keeping the check if controller 1 is to be programmed.
	 * This will come into affect once the VBT parsing
	 * is fixed for controller selection, and controller 1 is used
	 * for a prticular display configuration.
	 */
	if (panel->backlight.controller == 1) {
		val = I915_READ(UTIL_PIN_CTL);
		panel->backlight.util_pin_active_low =
					val & UTIL_PIN_POLARITY;
	}

	panel->backlight.active_low_pwm = pwm_ctl & BXT_BLC_PWM_POLARITY;
	panel->backlight.max =
		I915_READ(BXT_BLC_PWM_FREQ(panel->backlight.controller));

	if (!panel->backlight.max)
		panel->backlight.max = get_backlight_max_vbt(connector);

	if (!panel->backlight.max)
		return -ENODEV;

	val = bxt_get_backlight(connector);
	panel->backlight.level = intel_panel_compute_brightness(connector, val);

	panel->backlight.enabled = (pwm_ctl & BXT_BLC_PWM_ENABLE) &&
		panel->backlight.level != 0;

	return 0;
}

static int pwm_setup_backlight(struct intel_connector *connector,
			       enum pipe pipe)
{
	struct drm_device *dev = connector->base.dev;
	struct intel_panel *panel = &connector->panel;
	int retval;

	/* Get the PWM chip for backlight control */
	panel->backlight.pwm = pwm_get(dev->dev, "pwm_backlight");
	if (IS_ERR(panel->backlight.pwm)) {
		DRM_ERROR("Failed to own the pwm chip\n");
		panel->backlight.pwm = NULL;
		return -ENODEV;
	}

	retval = pwm_config(panel->backlight.pwm, CRC_PMIC_PWM_PERIOD_NS,
			    CRC_PMIC_PWM_PERIOD_NS);
	if (retval < 0) {
		DRM_ERROR("Failed to configure the pwm chip\n");
		pwm_put(panel->backlight.pwm);
		panel->backlight.pwm = NULL;
		return retval;
	}

	panel->backlight.min = 0; /* 0% */
	panel->backlight.max = 100; /* 100% */
	panel->backlight.level = DIV_ROUND_UP(
				 pwm_get_duty_cycle(panel->backlight.pwm) * 100,
				 CRC_PMIC_PWM_PERIOD_NS);
	panel->backlight.enabled = panel->backlight.level != 0;

	return 0;
}

int intel_panel_setup_backlight(struct drm_connector *connector, enum pipe pipe)
{
	struct drm_device *dev = connector->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct intel_panel *panel = &intel_connector->panel;
	int ret;

	if (!dev_priv->vbt.backlight.present) {
		if (dev_priv->quirks & QUIRK_BACKLIGHT_PRESENT) {
			DRM_DEBUG_KMS("no backlight present per VBT, but present per quirk\n");
		} else {
			DRM_DEBUG_KMS("no backlight present per VBT\n");
			return 0;
		}
	}

	/* ensure intel_panel has been initialized first */
	if (WARN_ON(!panel->backlight.setup))
		return -ENODEV;

	/* set level and max in panel struct */
	mutex_lock(&dev_priv->backlight_lock);
	ret = panel->backlight.setup(intel_connector, pipe);
	mutex_unlock(&dev_priv->backlight_lock);

	if (ret) {
		DRM_DEBUG_KMS("failed to setup backlight for connector %s\n",
			      connector->name);
		return ret;
	}

	panel->backlight.present = true;

	DRM_DEBUG_KMS("Connector %s backlight initialized, %s, brightness %u/%u\n",
		      connector->name,
		      panel->backlight.enabled ? "enabled" : "disabled",
		      panel->backlight.level, panel->backlight.max);

	return 0;
}

void intel_panel_destroy_backlight(struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct intel_panel *panel = &intel_connector->panel;

	/* dispose of the pwm */
	if (panel->backlight.pwm)
		pwm_put(panel->backlight.pwm);

	panel->backlight.present = false;
}

/* Set up chip specific backlight functions */
static void
intel_panel_init_backlight_funcs(struct intel_panel *panel)
{
	struct intel_connector *intel_connector =
		container_of(panel, struct intel_connector, panel);
	struct drm_device *dev = intel_connector->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (IS_BROXTON(dev)) {
		panel->backlight.setup = bxt_setup_backlight;
		panel->backlight.enable = bxt_enable_backlight;
		panel->backlight.disable = bxt_disable_backlight;
		panel->backlight.set = bxt_set_backlight;
		panel->backlight.get = bxt_get_backlight;
	} else if (HAS_PCH_LPT(dev_priv) || HAS_PCH_SPT(dev_priv) ||
		   HAS_PCH_KBP(dev_priv)) {
		panel->backlight.setup = lpt_setup_backlight;
		panel->backlight.enable = lpt_enable_backlight;
		panel->backlight.disable = lpt_disable_backlight;
		panel->backlight.set = lpt_set_backlight;
		panel->backlight.get = lpt_get_backlight;
		if (HAS_PCH_LPT(dev))
			panel->backlight.hz_to_pwm = lpt_hz_to_pwm;
		else
			panel->backlight.hz_to_pwm = spt_hz_to_pwm;
	} else if (HAS_PCH_SPLIT(dev)) {
		panel->backlight.setup = pch_setup_backlight;
		panel->backlight.enable = pch_enable_backlight;
		panel->backlight.disable = pch_disable_backlight;
		panel->backlight.set = pch_set_backlight;
		panel->backlight.get = pch_get_backlight;
		panel->backlight.hz_to_pwm = pch_hz_to_pwm;
	} else if (IS_VALLEYVIEW(dev)) {
		if (dev_priv->vbt.has_mipi) {
			panel->backlight.setup = pwm_setup_backlight;
			panel->backlight.enable = pwm_enable_backlight;
			panel->backlight.disable = pwm_disable_backlight;
			panel->backlight.set = pwm_set_backlight;
			panel->backlight.get = pwm_get_backlight;
		} else {
			panel->backlight.setup = vlv_setup_backlight;
			panel->backlight.enable = vlv_enable_backlight;
			panel->backlight.disable = vlv_disable_backlight;
			panel->backlight.set = vlv_set_backlight;
			panel->backlight.get = vlv_get_backlight;
			panel->backlight.hz_to_pwm = vlv_hz_to_pwm;
		}
	} else if (IS_GEN4(dev)) {
		panel->backlight.setup = i965_setup_backlight;
		panel->backlight.enable = i965_enable_backlight;
		panel->backlight.disable = i965_disable_backlight;
		panel->backlight.set = i9xx_set_backlight;
		panel->backlight.get = i9xx_get_backlight;
		panel->backlight.hz_to_pwm = i965_hz_to_pwm;
	} else {
		panel->backlight.setup = i9xx_setup_backlight;
		panel->backlight.enable = i9xx_enable_backlight;
		panel->backlight.disable = i9xx_disable_backlight;
		panel->backlight.set = i9xx_set_backlight;
		panel->backlight.get = i9xx_get_backlight;
		panel->backlight.hz_to_pwm = i9xx_hz_to_pwm;
	}
}

int intel_panel_init(struct intel_panel *panel,
		     struct drm_display_mode *fixed_mode,
		     struct drm_display_mode *downclock_mode)
{
	intel_panel_init_backlight_funcs(panel);

	panel->fixed_mode = fixed_mode;
	panel->downclock_mode = downclock_mode;

	return 0;
}

void intel_panel_fini(struct intel_panel *panel)
{
	struct intel_connector *intel_connector =
		container_of(panel, struct intel_connector, panel);

	if (panel->fixed_mode)
		drm_mode_destroy(intel_connector->base.dev, panel->fixed_mode);

	if (panel->downclock_mode)
		drm_mode_destroy(intel_connector->base.dev,
				panel->downclock_mode);
}

void intel_backlight_register(struct drm_device *dev)
{
	struct intel_connector *connector;

	list_for_each_entry(connector, &dev->mode_config.connector_list, base.head)
		intel_backlight_device_register(connector);
}

void intel_backlight_unregister(struct drm_device *dev)
{
	struct intel_connector *connector;

	list_for_each_entry(connector, &dev->mode_config.connector_list, base.head)
		intel_backlight_device_unregister(connector);
}
@


1.14
log
@Fix native/raw backlight support in inteldrm(4).
@
text
@d1782 2
a1783 1
	} else if (HAS_PCH_LPT(dev) || HAS_PCH_SPT(dev)) {
@


1.13
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@a555 1
#ifdef __linux__
a574 1
#endif
a663 2
#ifdef __linux__

a687 2

#endif
@


1.12
log
@Setup backlight pwm alternate increment on backlight enable

On at least the MacBookAir7,1 (Broadwell), upon S3 resume, the
backlight value was treated as 0 or 100 despite reporting
intermediate values, so if the backlight value was anything other
than 100 at suspend time, the screen would stay off upon resume.

This is backported from Linux commits
32b421e79e6b546da1d469f1229403ac9142d695 and
e29aff05f239f8dd24e9ee7816fd96726e20105a which were noted in
freedesktop.org bug 67454.

ok jsg
@
text
@a0 1
/*	$OpenBSD: intel_panel.c,v 1.11 2015/09/23 23:12:12 kettenis Exp $	*/
d33 5
a37 1
#include <dev/pci/drm/drmP.h>
d40 1
a40 1
#define PCI_LBPC 0xf4 /* legacy/combination backlight modes */
d51 53
d107 1
a107 1
			struct intel_crtc_config *pipe_config,
d110 2
a111 6
	struct drm_display_mode *adjusted_mode;
	int x, y, width, height;

	adjusted_mode = &pipe_config->adjusted_mode;

	x = y = width = height = 0;
d114 2
a115 2
	if (adjusted_mode->hdisplay == pipe_config->pipe_src_w &&
	    adjusted_mode->vdisplay == pipe_config->pipe_src_h)
d122 2
a123 2
		x = (adjusted_mode->hdisplay - width + 1)/2;
		y = (adjusted_mode->vdisplay - height + 1)/2;
d129 1
a129 1
			u32 scaled_width = adjusted_mode->hdisplay
d132 1
a132 1
				* adjusted_mode->vdisplay;
d137 1
a137 1
				x = (adjusted_mode->hdisplay - width + 1) / 2;
d139 1
a139 1
				height = adjusted_mode->vdisplay;
d144 1
a144 1
				y = (adjusted_mode->vdisplay - height + 1) / 2;
d146 1
a146 1
				width = adjusted_mode->hdisplay;
d149 2
a150 2
				width = adjusted_mode->hdisplay;
				height = adjusted_mode->vdisplay;
d157 2
a158 2
		width = adjusted_mode->hdisplay;
		height = adjusted_mode->vdisplay;
d173 1
a173 1
centre_horizontally(struct drm_display_mode *mode,
d179 2
a180 2
	sync_width = mode->crtc_hsync_end - mode->crtc_hsync_start;
	blank_width = mode->crtc_hblank_end - mode->crtc_hblank_start;
d183 1
a183 1
	border = (mode->hdisplay - width + 1) / 2;
d186 3
a188 3
	mode->crtc_hdisplay = width;
	mode->crtc_hblank_start = width + border;
	mode->crtc_hblank_end = mode->crtc_hblank_start + blank_width;
d190 2
a191 2
	mode->crtc_hsync_start = mode->crtc_hblank_start + sync_pos;
	mode->crtc_hsync_end = mode->crtc_hsync_start + sync_width;
d195 1
a195 1
centre_vertically(struct drm_display_mode *mode,
d201 2
a202 2
	sync_width = mode->crtc_vsync_end - mode->crtc_vsync_start;
	blank_width = mode->crtc_vblank_end - mode->crtc_vblank_start;
d205 1
a205 1
	border = (mode->vdisplay - height + 1) / 2;
d207 3
a209 3
	mode->crtc_vdisplay = height;
	mode->crtc_vblank_start = height + border;
	mode->crtc_vblank_end = mode->crtc_vblank_start + blank_width;
d211 2
a212 2
	mode->crtc_vsync_start = mode->crtc_vblank_start + sync_pos;
	mode->crtc_vsync_end = mode->crtc_vsync_start + sync_width;
d228 1
a228 1
static void i965_scale_aspect(struct intel_crtc_config *pipe_config,
d231 2
a232 2
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
	u32 scaled_width = adjusted_mode->hdisplay *
d235 1
a235 1
		adjusted_mode->vdisplay;
d244 1
a244 1
	else if (adjusted_mode->hdisplay != pipe_config->pipe_src_w)
d248 1
a248 1
static void i9xx_scale_aspect(struct intel_crtc_config *pipe_config,
d252 2
a253 2
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
	u32 scaled_width = adjusted_mode->hdisplay *
d256 1
a256 1
		adjusted_mode->vdisplay;
d270 1
a270 1
		if (pipe_config->pipe_src_h != adjusted_mode->vdisplay) {
d272 1
a272 1
						    adjusted_mode->vdisplay);
d286 1
a286 1
		if (pipe_config->pipe_src_w != adjusted_mode->hdisplay) {
d288 1
a288 1
						    adjusted_mode->hdisplay);
d306 1
a306 1
			      struct intel_crtc_config *pipe_config,
d311 1
a311 3
	struct drm_display_mode *adjusted_mode;

	adjusted_mode = &pipe_config->adjusted_mode;
d314 2
a315 2
	if (adjusted_mode->hdisplay == pipe_config->pipe_src_w &&
	    adjusted_mode->vdisplay == pipe_config->pipe_src_h)
d341 2
a342 2
		if (pipe_config->pipe_src_h != adjusted_mode->vdisplay ||
		    pipe_config->pipe_src_w != adjusted_mode->hdisplay) {
d379 84
a462 7
static int i915_panel_invert_brightness;
MODULE_PARM_DESC(invert_brightness, "Invert backlight brightness "
	"(-1 force normal, 0 machine defaults, 1 force inversion), please "
	"report PCI device ID, subsystem vendor and subsystem device ID "
	"to dri-devel@@lists.freedesktop.org, if your machine needs it. "
	"It will then be included in an upcoming module version.");
module_param_named(invert_brightness, i915_panel_invert_brightness, int, 0600);
d472 1
a472 1
	if (i915_panel_invert_brightness < 0)
d475 1
a475 1
	if (i915_panel_invert_brightness > 0 ||
d483 1
a483 1
static u32 bdw_get_backlight(struct intel_connector *connector)
d524 3
d538 18
d561 2
a562 2
	u32 val;
	unsigned long flags;
d564 1
a564 1
	spin_lock_irqsave(&dev_priv->backlight_lock, flags);
d566 4
a569 2
	val = dev_priv->display.get_backlight(connector);
	val = intel_panel_compute_brightness(connector, val);
d571 1
a571 1
	spin_unlock_irqrestore(&dev_priv->backlight_lock, flags);
d578 1
a578 1
static void bdw_set_backlight(struct intel_connector *connector, u32 level)
d631 3
d638 17
d658 14
d674 12
d687 2
a688 1
	DRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);
d690 1
a690 2
	level = intel_panel_compute_brightness(connector, level);
	dev_priv->display.set_backlight(connector, level);
d693 7
a699 3
/* set backlight brightness to level in range [0..max] */
void intel_panel_set_backlight(struct intel_connector *connector, u32 level,
			       u32 max)
d705 1
a705 3
	u32 freq;
	unsigned long flags;
	u64 n;
d707 6
d716 1
a716 1
	spin_lock_irqsave(&dev_priv->backlight_lock, flags);
d720 2
a721 5
	/* scale to hardware max, but be careful to not overflow */
	freq = panel->backlight.max;
	n = (u64)level * freq;
	do_div(n, max);
	level = n;
a722 1
	panel->backlight.level = level;
d724 4
a727 1
		panel->backlight.device->props.brightness = level;
d730 10
a739 1
		intel_panel_actually_set_backlight(connector, level);
d741 18
a758 1
	spin_unlock_irqrestore(&dev_priv->backlight_lock, flags);
d800 3
d809 30
a843 2
	enum pipe pipe = intel_get_pipe_from_connector(connector);
	unsigned long flags;
d845 1
a845 1
	if (!panel->backlight.present || pipe == INVALID_PIPE)
d850 1
a850 1
	 * Do not disable backlight on the vgaswitcheroo path. When switching
d861 1
a861 1
	spin_lock_irqsave(&dev_priv->backlight_lock, flags);
d863 2
d866 1
a866 1
	dev_priv->display.disable_backlight(connector);
d868 1
a868 1
	spin_unlock_irqrestore(&dev_priv->backlight_lock, flags);
d871 1
a871 1
static void bdw_enable_backlight(struct intel_connector *connector)
d908 3
a910 2
	/* BDW always uses the pch pwm controls. */
	pch_ctl1 |= BLM_PCH_OVERRIDE_ENABLE;
a957 4
	/* XXX: transitional */
	if (dev_priv->quirks & QUIRK_NO_PCH_PWM_ENABLE)
		return;

d995 8
d1047 3
d1071 58
d1134 1
d1136 1
a1136 1
	unsigned long flags;
d1138 1
a1138 1
	if (!panel->backlight.present || pipe == INVALID_PIPE)
d1143 1
a1143 1
	spin_lock_irqsave(&dev_priv->backlight_lock, flags);
d1147 1
a1147 1
	if (panel->backlight.level == 0) {
d1151 3
a1153 1
				panel->backlight.level;
d1156 1
a1156 1
	dev_priv->display.enable_backlight(connector);
d1158 2
d1161 1
a1161 23
	spin_unlock_irqrestore(&dev_priv->backlight_lock, flags);
}

enum drm_connector_status
intel_panel_detect(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* Assume that the BIOS does not lie through the OpRegion... */
	if (!i915_panel_ignore_lid && dev_priv->opregion.lid_state) {
		return ioread32(dev_priv->opregion.lid_state) & 0x1 ?
			connector_status_connected :
			connector_status_disconnected;
	}

	switch (i915_panel_ignore_lid) {
	case -2:
		return connector_status_connected;
	case -1:
		return connector_status_disconnected;
	default:
		return connector_status_unknown;
	}
d1168 1
d1171 1
a1171 1
	mutex_lock(&dev->mode_config.mutex);
d1176 18
a1193 1
	mutex_unlock(&dev->mode_config.mutex);
d1202 1
d1206 6
a1211 3
	mutex_lock(&dev->mode_config.mutex);
	ret = intel_panel_get_backlight(connector);
	mutex_unlock(&dev->mode_config.mutex);
d1230 4
a1233 1
	BUG_ON(panel->backlight.max == 0);
d1237 5
a1241 1
	props.brightness = panel->backlight.level;
d1243 8
d1268 4
d1287 74
d1363 33
a1395 1
	struct intel_panel *panel = &connector->panel;
d1397 8
a1404 5
	if (dev_priv->backlight.connector == NULL) {
		dev_priv->backlight.connector = connector;
		dev_priv->backlight.props.brightness = panel->backlight.level;
		dev_priv->backlight.props.max_brightness = panel->backlight.max;
		panel->backlight.device = &dev_priv->backlight;
d1406 1
d1408 1
a1408 3
	return 0;
}
static void intel_backlight_device_unregister(struct intel_connector *connector)
d1413 7
d1421 9
a1429 5
	if (dev_priv->backlight.connector == connector) {
		dev_priv->backlight.connector = NULL;
		dev_priv->backlight.props.brightness = 0;
		dev_priv->backlight.props.max_brightness = 0;
		panel->backlight.device = NULL;
d1431 4
a1435 1
#endif /* CONFIG_BACKLIGHT_CLASS_DEVICE */
a1438 3
 *
 * XXX: Query mode clock or hardware clock and program PWM modulation frequency
 * appropriately when it's 0. Use VBT and/or sane defaults.
d1440 27
a1466 1
static int bdw_setup_backlight(struct intel_connector *connector)
d1485 4
d1492 3
a1494 1
	val = bdw_get_backlight(connector);
d1503 1
a1503 1
static int pch_setup_backlight(struct intel_connector *connector)
d1515 4
d1522 2
d1534 1
a1534 1
static int i9xx_setup_backlight(struct intel_connector *connector)
d1550 9
d1562 1
a1562 2
	if (!panel->backlight.max)
		return -ENODEV;
d1572 1
a1572 1
static int i965_setup_backlight(struct intel_connector *connector)
d1585 7
d1595 30
d1628 3
a1630 1
	val = i9xx_get_backlight(connector);
d1639 2
a1640 1
static int vlv_setup_backlight(struct intel_connector *connector)
d1645 1
a1645 2
	enum pipe pipe;
	u32 ctl, ctl2, val;
d1647 5
a1651 2
	for_each_pipe(pipe) {
		u32 cur_val = I915_READ(VLV_BLC_PWM_CTL(pipe));
d1653 1
a1653 3
		/* Skip if the modulation freq is already set */
		if (cur_val & ~BACKLIGHT_DUTY_CYCLE_MASK)
			continue;
d1655 9
a1663 3
		cur_val &= BACKLIGHT_DUTY_CYCLE_MASK;
		I915_WRITE(VLV_BLC_PWM_CTL(pipe), (0xf42 << 16) |
			   cur_val);
d1666 6
a1671 2
	ctl2 = I915_READ(VLV_BLC_PWM_CTL2(PIPE_A));
	panel->backlight.active_low_pwm = ctl2 & BLM_POLARITY_I965;
a1672 2
	ctl = I915_READ(VLV_BLC_PWM_CTL(PIPE_A));
	panel->backlight.max = ctl >> 16;
d1676 1
a1676 1
	val = _vlv_get_backlight(dev, PIPE_A);
d1679 1
a1679 1
	panel->backlight.enabled = (ctl2 & BLM_PWM_ENABLE) &&
d1685 35
a1719 1
int intel_panel_setup_backlight(struct drm_connector *connector)
a1724 1
	unsigned long flags;
d1727 13
d1741 3
a1743 3
	spin_lock_irqsave(&dev_priv->backlight_lock, flags);
	ret = dev_priv->display.setup_backlight(intel_connector);
	spin_unlock_irqrestore(&dev_priv->backlight_lock, flags);
d1747 1
a1747 1
			      drm_get_connector_name(connector));
a1750 2
	intel_backlight_device_register(intel_connector);

d1753 2
a1754 2
	DRM_DEBUG_KMS("backlight initialized, %s, brightness %u/%u, "
		      "sysfs interface %sregistered\n",
d1756 1
a1756 2
		      panel->backlight.level, panel->backlight.max,
		      panel->backlight.device ? "" : "not ");
d1766 4
a1770 54
	intel_backlight_device_unregister(intel_connector);
}

/**
 * intel_find_panel_downclock - find the reduced downclock for LVDS in EDID
 * @@dev: drm device
 * @@fixed_mode : panel native mode
 * @@connector: LVDS/eDP connector
 *
 * Return downclock_avail
 * Find the reduced downclock for LVDS/eDP in EDID.
 */
struct drm_display_mode *
intel_find_panel_downclock(struct drm_device *dev,
			struct drm_display_mode *fixed_mode,
			struct drm_connector *connector)
{
	struct drm_display_mode *scan, *tmp_mode;
	int temp_downclock;

	temp_downclock = fixed_mode->clock;
	tmp_mode = NULL;

	list_for_each_entry(scan, &connector->probed_modes, head) {
		/*
		 * If one mode has the same resolution with the fixed_panel
		 * mode while they have the different refresh rate, it means
		 * that the reduced downclock is found. In such
		 * case we can set the different FPx0/1 to dynamically select
		 * between low and high frequency.
		 */
		if (scan->hdisplay == fixed_mode->hdisplay &&
		    scan->hsync_start == fixed_mode->hsync_start &&
		    scan->hsync_end == fixed_mode->hsync_end &&
		    scan->htotal == fixed_mode->htotal &&
		    scan->vdisplay == fixed_mode->vdisplay &&
		    scan->vsync_start == fixed_mode->vsync_start &&
		    scan->vsync_end == fixed_mode->vsync_end &&
		    scan->vtotal == fixed_mode->vtotal) {
			if (scan->clock < temp_downclock) {
				/*
				 * The downclock is already found. But we
				 * expect to find the lower downclock.
				 */
				temp_downclock = scan->clock;
				tmp_mode = scan;
			}
		}
	}

	if (temp_downclock < fixed_mode->clock)
		return drm_mode_duplicate(dev, tmp_mode);
	else
		return NULL;
d1774 2
a1775 1
void intel_panel_init_backlight_funcs(struct drm_device *dev)
d1777 3
d1782 16
a1797 6
	if (IS_BROADWELL(dev)) {
		dev_priv->display.setup_backlight = bdw_setup_backlight;
		dev_priv->display.enable_backlight = bdw_enable_backlight;
		dev_priv->display.disable_backlight = pch_disable_backlight;
		dev_priv->display.set_backlight = bdw_set_backlight;
		dev_priv->display.get_backlight = bdw_get_backlight;
d1799 6
a1804 5
		dev_priv->display.setup_backlight = pch_setup_backlight;
		dev_priv->display.enable_backlight = pch_enable_backlight;
		dev_priv->display.disable_backlight = pch_disable_backlight;
		dev_priv->display.set_backlight = pch_set_backlight;
		dev_priv->display.get_backlight = pch_get_backlight;
d1806 14
a1819 5
		dev_priv->display.setup_backlight = vlv_setup_backlight;
		dev_priv->display.enable_backlight = vlv_enable_backlight;
		dev_priv->display.disable_backlight = vlv_disable_backlight;
		dev_priv->display.set_backlight = vlv_set_backlight;
		dev_priv->display.get_backlight = vlv_get_backlight;
d1821 6
a1826 5
		dev_priv->display.setup_backlight = i965_setup_backlight;
		dev_priv->display.enable_backlight = i965_enable_backlight;
		dev_priv->display.disable_backlight = i965_disable_backlight;
		dev_priv->display.set_backlight = i9xx_set_backlight;
		dev_priv->display.get_backlight = i9xx_get_backlight;
d1828 6
a1833 5
		dev_priv->display.setup_backlight = i9xx_setup_backlight;
		dev_priv->display.enable_backlight = i9xx_enable_backlight;
		dev_priv->display.disable_backlight = i9xx_disable_backlight;
		dev_priv->display.set_backlight = i9xx_set_backlight;
		dev_priv->display.get_backlight = i9xx_get_backlight;
d1838 2
a1839 1
		     struct drm_display_mode *fixed_mode)
d1841 2
d1844 1
d1860 16
@


1.11
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d614 1
a614 1
	u32 pch_ctl1, pch_ctl2;
d623 16
d975 7
@


1.10
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.9 2015/04/18 11:05:32 jsg Exp $	*/
a38 2
u32 _intel_panel_get_max_backlight(struct drm_device *dev);

d40 1
a40 1
intel_fixed_panel_mode(struct drm_display_mode *fixed_mode,
d43 1
a43 9
	adjusted_mode->hdisplay = fixed_mode->hdisplay;
	adjusted_mode->hsync_start = fixed_mode->hsync_start;
	adjusted_mode->hsync_end = fixed_mode->hsync_end;
	adjusted_mode->htotal = fixed_mode->htotal;

	adjusted_mode->vdisplay = fixed_mode->vdisplay;
	adjusted_mode->vsync_start = fixed_mode->vsync_start;
	adjusted_mode->vsync_end = fixed_mode->vsync_end;
	adjusted_mode->vtotal = fixed_mode->vtotal;
d45 1
a45 1
	adjusted_mode->clock = fixed_mode->clock;
d50 3
a52 4
intel_pch_panel_fitting(struct drm_device *dev,
			int fitting_mode,
			const struct drm_display_mode *mode,
			struct drm_display_mode *adjusted_mode)
d54 1
a54 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d57 2
d62 2
a63 2
	if (adjusted_mode->hdisplay == mode->hdisplay &&
	    adjusted_mode->vdisplay == mode->vdisplay)
d68 2
a69 2
		width = mode->hdisplay;
		height = mode->vdisplay;
d77 4
a80 2
			u32 scaled_width = adjusted_mode->hdisplay * mode->vdisplay;
			u32 scaled_height = mode->hdisplay * adjusted_mode->vdisplay;
d82 1
a82 1
				width = scaled_height / mode->vdisplay;
d89 1
a89 1
				height = scaled_width / mode->hdisplay;
a102 1
	default:
d108 4
d115 3
a117 2
	dev_priv->pch_pf_pos = (x << 16) | y;
	dev_priv->pch_pf_size = (width << 16) | height;
d120 3
a122 1
static int is_backlight_combination_mode(struct drm_device *dev)
d124 6
a129 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d131 2
a132 2
	if (INTEL_INFO(dev)->gen >= 4)
		return I915_READ(BLC_PWM_CTL2) & BLM_COMBINATION_MODE;
d134 3
a136 2
	if (IS_GEN2(dev))
		return I915_READ(BLC_PWM_CTL) & BLM_LEGACY_MODE;
d138 2
a139 1
	return 0;
d142 3
a144 1
static u32 i915_read_blc_pwm_ctl(struct drm_device *dev)
d146 8
a153 2
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val;
d155 3
a157 1
	/* Restore the CTL value if it lost, e.g. GPU reset */
d159 84
a242 7
	if (HAS_PCH_SPLIT(dev_priv->dev)) {
		val = I915_READ(BLC_PWM_PCH_CTL2);
		if (dev_priv->regfile.saveBLC_PWM_CTL2 == 0) {
			dev_priv->regfile.saveBLC_PWM_CTL2 = val;
		} else if (val == 0) {
			val = dev_priv->regfile.saveBLC_PWM_CTL2;
			I915_WRITE(BLC_PWM_PCH_CTL2, val);
d245 5
a249 13
		val = I915_READ(BLC_PWM_CTL);
		if (dev_priv->regfile.saveBLC_PWM_CTL == 0) {
			dev_priv->regfile.saveBLC_PWM_CTL = val;
			if (INTEL_INFO(dev)->gen >= 4)
				dev_priv->regfile.saveBLC_PWM_CTL2 =
					I915_READ(BLC_PWM_CTL2);
		} else if (val == 0) {
			val = dev_priv->regfile.saveBLC_PWM_CTL;
			I915_WRITE(BLC_PWM_CTL, val);
			if (INTEL_INFO(dev)->gen >= 4)
				I915_WRITE(BLC_PWM_CTL2,
					   dev_priv->regfile.saveBLC_PWM_CTL2);
		}
d251 1
d253 7
a259 2
	return val;
}
d261 1
a261 3
u32 _intel_panel_get_max_backlight(struct drm_device *dev)
{
	u32 max;
d263 4
a266 1
	max = i915_read_blc_pwm_ctl(dev);
d268 14
a281 5
	if (HAS_PCH_SPLIT(dev)) {
		max >>= 16;
	} else {
		if (INTEL_INFO(dev)->gen < 4)
			max >>= 17;
d283 23
a305 4
			max >>= 16;

		if (is_backlight_combination_mode(dev))
			max *= 0xff;
d308 5
a312 2
	return max;
}
d314 4
a317 11
u32 intel_panel_get_max_backlight(struct drm_device *dev)
{
	u32 max;

	max = _intel_panel_get_max_backlight(dev);
	if (max == 0) {
		/* XXX add code here to query mode clock or hardware clock
		 * and program max PWM appropriately.
		 */
		pr_warn_once("fixme: max PWM is zero\n");
		return 1;
d320 7
a326 2
	DRM_DEBUG_DRIVER("max backlight PWM = %d\n", max);
	return max;
d336 2
a337 1
static u32 intel_panel_compute_brightness(struct drm_device *dev, u32 val)
d339 1
d341 3
d349 3
a351 2
	    dev_priv->quirks & QUIRK_INVERT_BRIGHTNESS)
		return intel_panel_get_max_backlight(dev) - val;
d356 17
a372 1
static u32 intel_panel_get_backlight(struct drm_device *dev)
d374 1
d376 1
d379 9
a387 14
	if (HAS_PCH_SPLIT(dev)) {
		val = I915_READ(BLC_PWM_CPU_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;
	} else {
		val = I915_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;
		if (INTEL_INFO(dev)->gen < 4)
			val >>= 1;

		if (is_backlight_combination_mode(dev)) {
			u8 lbpc;

			lbpc = pci_conf_read(dev_priv->pc, dev_priv->tag,
			    PCI_LBPC) & 0xff;
			val *= lbpc;
		}
d390 33
a422 1
	val = intel_panel_compute_brightness(dev, val);
d426 1
d428 1
a428 1
static void intel_pch_panel_set_backlight(struct drm_device *dev, u32 level)
d430 1
d432 2
a433 2
	u32 val = I915_READ(BLC_PWM_CPU_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;
	I915_WRITE(BLC_PWM_CPU_CTL, val | level);
d436 1
a436 1
static void intel_panel_actually_set_backlight(struct drm_device *dev, u32 level)
d438 1
d442 10
a451 2
	DRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);
	level = intel_panel_compute_brightness(dev, level);
d453 1
a453 2
	if (HAS_PCH_SPLIT(dev))
		return intel_pch_panel_set_backlight(dev, level);
d455 1
a455 2
	if (is_backlight_combination_mode(dev)) {
		u32 max = intel_panel_get_max_backlight(dev);
d458 1
a458 1
		lbpc = level * 0xfe / max + 1;
d460 1
a460 1
		pci_conf_write(dev_priv->pc, dev_priv->tag, PCI_LBPC, lbpc);
d463 3
a465 2
	tmp = I915_READ(BLC_PWM_CTL);
	if (INTEL_INFO(dev)->gen < 4)
d467 4
a470 1
	tmp &= ~BACKLIGHT_DUTY_CYCLE_MASK;
d474 1
a474 1
void intel_panel_set_backlight(struct drm_device *dev, u32 level)
d476 1
d478 50
d529 1
a529 3
	dev_priv->backlight_level = level;
	if (dev_priv->backlight_enabled)
		intel_panel_actually_set_backlight(dev, level);
d532 1
a532 1
void intel_panel_disable_backlight(struct drm_device *dev)
d534 1
d536 86
d623 2
a624 2
	dev_priv->backlight_enabled = false;
	intel_panel_actually_set_backlight(dev, 0);
d626 3
a628 2
	if (INTEL_INFO(dev)->gen >= 4) {
		uint32_t reg, tmp;
d630 2
a631 1
		reg = HAS_PCH_SPLIT(dev) ? BLC_PWM_CPU_CTL2 : BLC_PWM_CTL2;
d633 3
a635 1
		I915_WRITE(reg, I915_READ(reg) & ~BLM_PWM_ENABLE);
d637 26
a662 5
		if (HAS_PCH_SPLIT(dev)) {
			tmp = I915_READ(BLC_PWM_PCH_CTL1);
			tmp &= ~BLM_PCH_PWM_ENABLE;
			I915_WRITE(BLC_PWM_PCH_CTL1, tmp);
		}
d664 26
d692 1
a692 2
void intel_panel_enable_backlight(struct drm_device *dev,
				  enum pipe pipe)
d694 1
d696 8
d705 3
a707 2
	if (dev_priv->backlight_level == 0)
		dev_priv->backlight_level = intel_panel_get_max_backlight(dev);
d709 5
a713 2
	if (INTEL_INFO(dev)->gen >= 4) {
		uint32_t reg, tmp;
d715 2
a716 1
		reg = HAS_PCH_SPLIT(dev) ? BLC_PWM_CPU_CTL2 : BLC_PWM_CTL2;
d718 18
d737 3
a739 1
		tmp = I915_READ(reg);
d741 2
a742 5
		/* Note that this can also get called through dpms changes. And
		 * we don't track the backlight dpms state, hence check whether
		 * we have to do anything first. */
		if (tmp & BLM_PWM_ENABLE)
			goto set_level;
d744 8
a751 4
		if (INTEL_INFO(dev)->num_pipes == 3)
			tmp &= ~BLM_PIPE_SELECT_IVB;
		else
			tmp &= ~BLM_PIPE_SELECT;
d753 2
a754 2
		tmp |= BLM_PIPE(pipe);
		tmp &= ~BLM_PWM_ENABLE;
d756 13
a768 11
		I915_WRITE(reg, tmp);
		POSTING_READ(reg);
		I915_WRITE(reg, tmp | BLM_PWM_ENABLE);

		if (HAS_PCH_SPLIT(dev) &&
		    !(dev_priv->quirks & QUIRK_NO_PCH_PWM_ENABLE)) {
			tmp = I915_READ(BLC_PWM_PCH_CTL1);
			tmp |= BLM_PCH_PWM_ENABLE;
			tmp &= ~BLM_PCH_OVERRIDE_ENABLE;
			I915_WRITE(BLC_PWM_PCH_CTL1, tmp);
		}
d771 12
a782 7
set_level:
	/* Call below after setting BLC_PWM_CPU_CTL2 and BLC_PWM_PCH_CTL1.
	 * BLC_PWM_CPU_CTL may be cleared to zero automatically when these
	 * registers are set.
	 */
	dev_priv->backlight_enabled = true;
	intel_panel_actually_set_backlight(dev, dev_priv->backlight_level);
d785 1
a785 1
static void intel_panel_init_backlight(struct drm_device *dev)
d787 1
d789 6
d796 17
a812 2
	dev_priv->backlight_level = intel_panel_get_backlight(dev);
	dev_priv->backlight_enabled = dev_priv->backlight_level != 0;
d818 1
a818 1
//	struct drm_i915_private *dev_priv = dev->dev_private;
a819 1
#if 0
a825 1
#endif
d837 2
a838 2
#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
static int intel_panel_update_status(struct backlight_device *bd)
d840 9
a848 2
	struct drm_device *dev = bl_get_data(bd);
	intel_panel_set_backlight(dev, bd->props.brightness);
d852 1
a852 1
static int intel_panel_get_brightness(struct backlight_device *bd)
d854 2
a855 1
	struct drm_device *dev = bl_get_data(bd);
d857 9
a865 1
	return dev_priv->backlight_level;
d868 3
a870 3
static const struct backlight_ops intel_panel_bl_ops = {
	.update_status = intel_panel_update_status,
	.get_brightness = intel_panel_get_brightness,
d873 1
a873 1
int intel_panel_setup_backlight(struct drm_connector *connector)
d875 1
a875 2
	struct drm_device *dev = connector->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
d878 2
a879 1
	intel_panel_init_backlight(dev);
d881 1
a881 2
	if (WARN_ON(dev_priv->backlight))
		return -ENODEV;
d885 8
a892 6
	props.max_brightness = _intel_panel_get_max_backlight(dev);
	if (props.max_brightness == 0) {
		DRM_DEBUG_DRIVER("Failed to get maximum backlight value\n");
		return -ENODEV;
	}
	dev_priv->backlight =
d894 3
a896 2
					  &connector->kdev, dev,
					  &intel_panel_bl_ops, &props);
d898 1
a898 1
	if (IS_ERR(dev_priv->backlight)) {
d900 2
a901 2
			  PTR_ERR(dev_priv->backlight));
		dev_priv->backlight = NULL;
a903 1
	dev_priv->backlight->props.brightness = intel_panel_get_backlight(dev);
d907 126
a1032 1
void intel_panel_destroy_backlight(struct drm_device *dev)
d1034 1
d1036 42
a1077 3
	if (dev_priv->backlight) {
		backlight_device_unregister(dev_priv->backlight);
		dev_priv->backlight = NULL;
d1079 16
d1096 1
a1096 1
#else
d1099 28
a1126 1
	intel_panel_init_backlight(connector->dev);
d1130 1
a1130 1
void intel_panel_destroy_backlight(struct drm_device *dev)
d1132 96
a1227 1
	return;
a1228 1
#endif
d1245 4
@


1.9
log
@add and use module param macros
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.8 2015/02/12 04:56:03 kettenis Exp $	*/
a199 1
#ifdef notyet
a200 1
#endif
@


1.8
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.7 2014/03/24 17:06:49 kettenis Exp $	*/
d211 1
a211 1
/* 
d216 1
a216 1
*/
@


1.7
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.6 2014/01/24 04:05:06 jsg Exp $	*/
d143 1
a143 1
	if (HAS_PCH_SPLIT(dev)) {
@


1.6
log
@drm/i915: Move num_pipes to intel info

From Ben Widawsky
7ed1faada973243b6e11fa209ada91c9cc1dab53 in ubuntu 3.8
7eb552aeae058a88eece91b902dd51fde45b1f41 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.5 2014/01/24 03:21:17 jsg Exp $	*/
d212 2
a213 2
 	"(-1 force normal, 0 machine defaults, 1 force inversion), please "
 	"report PCI device ID, subsystem vendor and subsystem device ID "
@


1.5
log
@drm/i915: quirk no PCH_PWM_ENABLE for Dell XPS13 backlight

From Kamal Mostafa
9f5b330036e6f771438b22770f6c49e2c2eaf0e1 in ubuntu 3.8
e85843bec6c2ea7c10ec61238396891cc2b753a9 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.4 2013/08/13 10:23:52 jsg Exp $	*/
d344 1
a344 1
		if (dev_priv->num_pipe == 3)
@


1.4
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.3 2013/07/05 07:20:27 jsg Exp $	*/
d356 2
a357 1
		if (HAS_PCH_SPLIT(dev)) {
@


1.3
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.2 2013/07/04 09:55:01 jsg Exp $	*/
d39 1
a39 8
int	 is_backlight_combination_mode(struct drm_device *);
u32	 i915_read_blc_pwm_ctl(struct drm_device *);
void	 intel_pch_panel_set_backlight(struct drm_device *, u32);
void	 intel_panel_actually_set_backlight(struct drm_device *, u32);
void	 intel_panel_init_backlight(struct drm_device *);
u32	 _intel_panel_get_max_backlight(struct drm_device *);
u32	 intel_panel_compute_brightness(struct drm_device *, u32);
u32	 intel_panel_get_backlight(struct drm_device *);
d123 1
a123 2
int
is_backlight_combination_mode(struct drm_device *dev)
d136 1
a136 2
u32
i915_read_blc_pwm_ctl(struct drm_device *dev)
d170 1
a170 2
u32
_intel_panel_get_max_backlight(struct drm_device *dev)
d191 1
a191 2
u32
intel_panel_get_max_backlight(struct drm_device *dev)
d217 1
a217 2
u32
intel_panel_compute_brightness(struct drm_device *dev, u32 val)
d231 1
a231 2
u32
intel_panel_get_backlight(struct drm_device *dev)
d257 1
a257 2
void
intel_pch_panel_set_backlight(struct drm_device *dev, u32 level)
d264 1
a264 2
void
intel_panel_actually_set_backlight(struct drm_device *dev, u32 level)
d291 1
a291 2
void
intel_panel_set_backlight(struct drm_device *dev, u32 level)
d300 1
a300 2
void
intel_panel_disable_backlight(struct drm_device *dev)
d322 1
a322 2
void
intel_panel_enable_backlight(struct drm_device *dev,
d373 1
a373 2
void
intel_panel_init_backlight(struct drm_device *dev)
d406 1
a406 2
int
intel_panel_update_status(struct backlight_device *bd)
d413 1
a413 2
int
intel_panel_get_brightness(struct backlight_device *bd)
d425 1
a425 2
int
intel_panel_setup_backlight(struct drm_connector *connector)
d458 1
a458 2
void
intel_panel_destroy_backlight(struct drm_device *dev)
d467 1
a467 2
int
intel_panel_setup_backlight(struct drm_connector *connector)
d473 1
a473 2
void
intel_panel_destroy_backlight(struct drm_device *dev)
d479 1
a479 2
int
intel_panel_init(struct intel_panel *panel,
d487 1
a487 2
void
intel_panel_fini(struct intel_panel *panel)
@


1.2
log
@ensure single initialization and cleanup of backlight device
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_panel.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d72 1
a72 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d133 1
a133 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d147 1
a147 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d231 1
a231 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d246 1
a246 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d273 1
a273 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d281 1
a281 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d309 1
a309 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d319 1
a319 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d343 1
a343 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d394 1
a394 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d403 1
a403 1
//	struct inteldrm_softc *dev_priv = dev->dev_private;
d437 1
a437 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d450 1
a450 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d483 1
a483 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d455 3
d484 1
a484 1
	if (dev_priv->backlight)
d486 2
@

