head	1.32;
access;
symbols
	OPENBSD_6_1:1.30.0.8
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6;
locks; strict;
comment	@ * @;


1.32
date	2017.09.30.07.36.56;	author robert;	state Exp;
branches;
next	1.31;
commitid	XkWOvf4INOmfke72;

1.31
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	KnwRPOZok9A30HI4;

1.30
date	2015.12.01.20.41.32;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	iWcbMf4XzgmqqQhD;

1.29
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	lQlppvmETCN49oZe;

1.28
date	2015.07.16.18.48.51;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	L0a8i9q8D7R6QA4N;

1.27
date	2015.06.26.15.22.23;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	zE715ZsjyYsYQNQ0;

1.26
date	2015.06.24.08.32.39;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	hfEqCdm8ecmxIgUE;

1.25
date	2015.04.12.17.10.07;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	7RIU3AxWXbuzxDet;

1.24
date	2015.04.11.14.39.37;	author jsg;	state Exp;
branches;
next	1.23;
commitid	MAOlCKi3JlwvLeJa;

1.23
date	2015.04.11.05.10.13;	author jsg;	state Exp;
branches;
next	1.22;
commitid	pjaRMzmEKTQk8EZt;

1.22
date	2015.04.06.05.35.29;	author jsg;	state Exp;
branches;
next	1.21;
commitid	oeVBooRupIYToF2n;

1.21
date	2015.02.12.11.11.45;	author jsg;	state Exp;
branches;
next	1.20;
commitid	SzbWuibzaFWN7p7E;

1.20
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.19;
commitid	adfbJ0ccUTdhFGhI;

1.19
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.18;
commitid	dLgISW35NAmGN8Xl;

1.18
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.17;
commitid	aHLMSW1RfE1rmMw9;

1.17
date	2015.02.10.06.19.36;	author jsg;	state Exp;
branches;
next	1.16;
commitid	0OQNG9STPII6jEb4;

1.16
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.15;
commitid	C5l5rZ5v9mpRR1eS;

1.15
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.14;
commitid	a8Vt7gSt34kmziIS;

1.14
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.13;
commitid	MyKPm9Q3dQu92BiX;

1.13
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.12;
commitid	OBNa5kfxQ2UXoiIw;

1.12
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2014.02.05.10.58.48;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.24.04.05.06;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.30.02.11.32;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.13.10.23.50;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.17.20.04.04;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.28.20.37.50;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.21.08.27.32;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.20.12.37.41;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Add preliminary kabylake support to inteldrm(4) by backporting the relevant
commits from linux-4.8.x.
The changes are quiet minimal due to the fact that kabylake and skylake share
most of the code because they are both gen9 graphics.
This was tested by many and was also in snapshots for a while.

ok kettenis@@
@
text
@/* i915_irq.c -- IRQ support for the I915 -*- linux-c -*-
 */
/*
 * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt

#ifdef __linux__
#include <linux/sysrq.h>
#include <linux/slab.h>
#include <linux/circ_buf.h>
#endif
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#include "i915_trace.h"
#include "intel_drv.h"

/**
 * DOC: interrupt handling
 *
 * These functions provide the basic support for enabling and disabling the
 * interrupt handling support. There's a lot more functionality in i915_irq.c
 * and related files, but that will be described in separate chapters.
 */

static const u32 hpd_ilk[HPD_NUM_PINS] = {
	[HPD_PORT_A] = DE_DP_A_HOTPLUG,
};

static const u32 hpd_ivb[HPD_NUM_PINS] = {
	[HPD_PORT_A] = DE_DP_A_HOTPLUG_IVB,
};

static const u32 hpd_bdw[HPD_NUM_PINS] = {
	[HPD_PORT_A] = GEN8_PORT_DP_A_HOTPLUG,
};

static const u32 hpd_ibx[HPD_NUM_PINS] = {
	[HPD_CRT] = SDE_CRT_HOTPLUG,
	[HPD_SDVO_B] = SDE_SDVOB_HOTPLUG,
	[HPD_PORT_B] = SDE_PORTB_HOTPLUG,
	[HPD_PORT_C] = SDE_PORTC_HOTPLUG,
	[HPD_PORT_D] = SDE_PORTD_HOTPLUG
};

static const u32 hpd_cpt[HPD_NUM_PINS] = {
	[HPD_CRT] = SDE_CRT_HOTPLUG_CPT,
	[HPD_SDVO_B] = SDE_SDVOB_HOTPLUG_CPT,
	[HPD_PORT_B] = SDE_PORTB_HOTPLUG_CPT,
	[HPD_PORT_C] = SDE_PORTC_HOTPLUG_CPT,
	[HPD_PORT_D] = SDE_PORTD_HOTPLUG_CPT
};

static const u32 hpd_spt[HPD_NUM_PINS] = {
	[HPD_PORT_A] = SDE_PORTA_HOTPLUG_SPT,
	[HPD_PORT_B] = SDE_PORTB_HOTPLUG_CPT,
	[HPD_PORT_C] = SDE_PORTC_HOTPLUG_CPT,
	[HPD_PORT_D] = SDE_PORTD_HOTPLUG_CPT,
	[HPD_PORT_E] = SDE_PORTE_HOTPLUG_SPT
};

static const u32 hpd_mask_i915[HPD_NUM_PINS] = {
	[HPD_CRT] = CRT_HOTPLUG_INT_EN,
	[HPD_SDVO_B] = SDVOB_HOTPLUG_INT_EN,
	[HPD_SDVO_C] = SDVOC_HOTPLUG_INT_EN,
	[HPD_PORT_B] = PORTB_HOTPLUG_INT_EN,
	[HPD_PORT_C] = PORTC_HOTPLUG_INT_EN,
	[HPD_PORT_D] = PORTD_HOTPLUG_INT_EN
};

static const u32 hpd_status_g4x[HPD_NUM_PINS] = {
	[HPD_CRT] = CRT_HOTPLUG_INT_STATUS,
	[HPD_SDVO_B] = SDVOB_HOTPLUG_INT_STATUS_G4X,
	[HPD_SDVO_C] = SDVOC_HOTPLUG_INT_STATUS_G4X,
	[HPD_PORT_B] = PORTB_HOTPLUG_INT_STATUS,
	[HPD_PORT_C] = PORTC_HOTPLUG_INT_STATUS,
	[HPD_PORT_D] = PORTD_HOTPLUG_INT_STATUS
};

static const u32 hpd_status_i915[HPD_NUM_PINS] = {
	[HPD_CRT] = CRT_HOTPLUG_INT_STATUS,
	[HPD_SDVO_B] = SDVOB_HOTPLUG_INT_STATUS_I915,
	[HPD_SDVO_C] = SDVOC_HOTPLUG_INT_STATUS_I915,
	[HPD_PORT_B] = PORTB_HOTPLUG_INT_STATUS,
	[HPD_PORT_C] = PORTC_HOTPLUG_INT_STATUS,
	[HPD_PORT_D] = PORTD_HOTPLUG_INT_STATUS
};

/* BXT hpd list */
static const u32 hpd_bxt[HPD_NUM_PINS] = {
	[HPD_PORT_A] = BXT_DE_PORT_HP_DDIA,
	[HPD_PORT_B] = BXT_DE_PORT_HP_DDIB,
	[HPD_PORT_C] = BXT_DE_PORT_HP_DDIC
};

/* IIR can theoretically queue up two events. Be paranoid. */
#define GEN8_IRQ_RESET_NDX(type, which) do { \
	I915_WRITE(GEN8_##type##_IMR(which), 0xffffffff); \
	POSTING_READ(GEN8_##type##_IMR(which)); \
	I915_WRITE(GEN8_##type##_IER(which), 0); \
	I915_WRITE(GEN8_##type##_IIR(which), 0xffffffff); \
	POSTING_READ(GEN8_##type##_IIR(which)); \
	I915_WRITE(GEN8_##type##_IIR(which), 0xffffffff); \
	POSTING_READ(GEN8_##type##_IIR(which)); \
} while (0)

#define GEN5_IRQ_RESET(type) do { \
	I915_WRITE(type##IMR, 0xffffffff); \
	POSTING_READ(type##IMR); \
	I915_WRITE(type##IER, 0); \
	I915_WRITE(type##IIR, 0xffffffff); \
	POSTING_READ(type##IIR); \
	I915_WRITE(type##IIR, 0xffffffff); \
	POSTING_READ(type##IIR); \
} while (0)

/*
 * We should clear IMR at preinstall/uninstall, and just check at postinstall.
 */
static void gen5_assert_iir_is_zero(struct drm_i915_private *dev_priv, u32 reg)
{
	u32 val = I915_READ(reg);

	if (val == 0)
		return;

	WARN(1, "Interrupt register 0x%x is not zero: 0x%08x\n",
	     reg, val);
	I915_WRITE(reg, 0xffffffff);
	POSTING_READ(reg);
	I915_WRITE(reg, 0xffffffff);
	POSTING_READ(reg);
}

#define GEN8_IRQ_INIT_NDX(type, which, imr_val, ier_val) do { \
	gen5_assert_iir_is_zero(dev_priv, GEN8_##type##_IIR(which)); \
	I915_WRITE(GEN8_##type##_IER(which), (ier_val)); \
	I915_WRITE(GEN8_##type##_IMR(which), (imr_val)); \
	POSTING_READ(GEN8_##type##_IMR(which)); \
} while (0)

#define GEN5_IRQ_INIT(type, imr_val, ier_val) do { \
	gen5_assert_iir_is_zero(dev_priv, type##IIR); \
	I915_WRITE(type##IER, (ier_val)); \
	I915_WRITE(type##IMR, (imr_val)); \
	POSTING_READ(type##IMR); \
} while (0)

static void gen6_rps_irq_handler(struct drm_i915_private *dev_priv, u32 pm_iir);

/* For display hotplug interrupt */
static inline void
i915_hotplug_interrupt_update_locked(struct drm_i915_private *dev_priv,
				     uint32_t mask,
				     uint32_t bits)
{
	uint32_t val;

	assert_spin_locked(&dev_priv->irq_lock);
	WARN_ON(bits & ~mask);

	val = I915_READ(PORT_HOTPLUG_EN);
	val &= ~mask;
	val |= bits;
	I915_WRITE(PORT_HOTPLUG_EN, val);
}

/**
 * i915_hotplug_interrupt_update - update hotplug interrupt enable
 * @@dev_priv: driver private
 * @@mask: bits to update
 * @@bits: bits to enable
 * NOTE: the HPD enable bits are modified both inside and outside
 * of an interrupt context. To avoid that read-modify-write cycles
 * interfer, these bits are protected by a spinlock. Since this
 * function is usually not called from a context where the lock is
 * held already, this function acquires the lock itself. A non-locking
 * version is also available.
 */
void i915_hotplug_interrupt_update(struct drm_i915_private *dev_priv,
				   uint32_t mask,
				   uint32_t bits)
{
	spin_lock_irq(&dev_priv->irq_lock);
	i915_hotplug_interrupt_update_locked(dev_priv, mask, bits);
	spin_unlock_irq(&dev_priv->irq_lock);
}

/**
 * ilk_update_display_irq - update DEIMR
 * @@dev_priv: driver private
 * @@interrupt_mask: mask of interrupt bits to update
 * @@enabled_irq_mask: mask of interrupt bits to enable
 */
static void ilk_update_display_irq(struct drm_i915_private *dev_priv,
				   uint32_t interrupt_mask,
				   uint32_t enabled_irq_mask)
{
	uint32_t new_val;

	assert_spin_locked(&dev_priv->irq_lock);

	WARN_ON(enabled_irq_mask & ~interrupt_mask);

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	new_val = dev_priv->irq_mask;
	new_val &= ~interrupt_mask;
	new_val |= (~enabled_irq_mask & interrupt_mask);

	if (new_val != dev_priv->irq_mask) {
		dev_priv->irq_mask = new_val;
		I915_WRITE(DEIMR, dev_priv->irq_mask);
		POSTING_READ(DEIMR);
	}
}

void
ironlake_enable_display_irq(struct drm_i915_private *dev_priv, u32 mask)
{
	ilk_update_display_irq(dev_priv, mask, mask);
}

void
ironlake_disable_display_irq(struct drm_i915_private *dev_priv, u32 mask)
{
	ilk_update_display_irq(dev_priv, mask, 0);
}

/**
 * ilk_update_gt_irq - update GTIMR
 * @@dev_priv: driver private
 * @@interrupt_mask: mask of interrupt bits to update
 * @@enabled_irq_mask: mask of interrupt bits to enable
 */
static void ilk_update_gt_irq(struct drm_i915_private *dev_priv,
			      uint32_t interrupt_mask,
			      uint32_t enabled_irq_mask)
{
	assert_spin_locked(&dev_priv->irq_lock);

	WARN_ON(enabled_irq_mask & ~interrupt_mask);

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	dev_priv->gt_irq_mask &= ~interrupt_mask;
	dev_priv->gt_irq_mask |= (~enabled_irq_mask & interrupt_mask);
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
	POSTING_READ(GTIMR);
}

void gen5_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask)
{
	ilk_update_gt_irq(dev_priv, mask, mask);
}

void gen5_disable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask)
{
	ilk_update_gt_irq(dev_priv, mask, 0);
}

static u32 gen6_pm_iir(struct drm_i915_private *dev_priv)
{
	return INTEL_INFO(dev_priv)->gen >= 8 ? GEN8_GT_IIR(2) : GEN6_PMIIR;
}

static u32 gen6_pm_imr(struct drm_i915_private *dev_priv)
{
	return INTEL_INFO(dev_priv)->gen >= 8 ? GEN8_GT_IMR(2) : GEN6_PMIMR;
}

static u32 gen6_pm_ier(struct drm_i915_private *dev_priv)
{
	return INTEL_INFO(dev_priv)->gen >= 8 ? GEN8_GT_IER(2) : GEN6_PMIER;
}

/**
  * snb_update_pm_irq - update GEN6_PMIMR
  * @@dev_priv: driver private
  * @@interrupt_mask: mask of interrupt bits to update
  * @@enabled_irq_mask: mask of interrupt bits to enable
  */
static void snb_update_pm_irq(struct drm_i915_private *dev_priv,
			      uint32_t interrupt_mask,
			      uint32_t enabled_irq_mask)
{
	uint32_t new_val;

	WARN_ON(enabled_irq_mask & ~interrupt_mask);

	assert_spin_locked(&dev_priv->irq_lock);

	new_val = dev_priv->pm_irq_mask;
	new_val &= ~interrupt_mask;
	new_val |= (~enabled_irq_mask & interrupt_mask);

	if (new_val != dev_priv->pm_irq_mask) {
		dev_priv->pm_irq_mask = new_val;
		I915_WRITE(gen6_pm_imr(dev_priv), dev_priv->pm_irq_mask);
		POSTING_READ(gen6_pm_imr(dev_priv));
	}
}

void gen6_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask)
{
	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	snb_update_pm_irq(dev_priv, mask, mask);
}

static void __gen6_disable_pm_irq(struct drm_i915_private *dev_priv,
				  uint32_t mask)
{
	snb_update_pm_irq(dev_priv, mask, 0);
}

void gen6_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask)
{
	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	__gen6_disable_pm_irq(dev_priv, mask);
}

void gen6_reset_rps_interrupts(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t reg = gen6_pm_iir(dev_priv);

	spin_lock_irq(&dev_priv->irq_lock);
	I915_WRITE(reg, dev_priv->pm_rps_events);
	I915_WRITE(reg, dev_priv->pm_rps_events);
	POSTING_READ(reg);
	dev_priv->rps.pm_iir = 0;
	spin_unlock_irq(&dev_priv->irq_lock);
}

void gen6_enable_rps_interrupts(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	spin_lock_irq(&dev_priv->irq_lock);

	WARN_ON(dev_priv->rps.pm_iir);
	WARN_ON(I915_READ(gen6_pm_iir(dev_priv)) & dev_priv->pm_rps_events);
	dev_priv->rps.interrupts_enabled = true;
	I915_WRITE(gen6_pm_ier(dev_priv), I915_READ(gen6_pm_ier(dev_priv)) |
				dev_priv->pm_rps_events);
	gen6_enable_pm_irq(dev_priv, dev_priv->pm_rps_events);

	spin_unlock_irq(&dev_priv->irq_lock);
}

u32 gen6_sanitize_rps_pm_mask(struct drm_i915_private *dev_priv, u32 mask)
{
	/*
	 * SNB,IVB can while VLV,CHV may hard hang on looping batchbuffer
	 * if GEN6_PM_UP_EI_EXPIRED is masked.
	 *
	 * TODO: verify if this can be reproduced on VLV,CHV.
	 */
	if (INTEL_INFO(dev_priv)->gen <= 7 && !IS_HASWELL(dev_priv))
		mask &= ~GEN6_PM_RP_UP_EI_EXPIRED;

	if (INTEL_INFO(dev_priv)->gen >= 8)
		mask &= ~GEN8_PMINTR_REDIRECT_TO_NON_DISP;

	return mask;
}

void gen6_disable_rps_interrupts(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	spin_lock_irq(&dev_priv->irq_lock);
	dev_priv->rps.interrupts_enabled = false;
	spin_unlock_irq(&dev_priv->irq_lock);

	cancel_work_sync(&dev_priv->rps.work);

	spin_lock_irq(&dev_priv->irq_lock);

	I915_WRITE(GEN6_PMINTRMSK, gen6_sanitize_rps_pm_mask(dev_priv, ~0));

	__gen6_disable_pm_irq(dev_priv, dev_priv->pm_rps_events);
	I915_WRITE(gen6_pm_ier(dev_priv), I915_READ(gen6_pm_ier(dev_priv)) &
				~dev_priv->pm_rps_events);

	spin_unlock_irq(&dev_priv->irq_lock);

	synchronize_irq(dev->irq);
}

/**
  * bdw_update_port_irq - update DE port interrupt
  * @@dev_priv: driver private
  * @@interrupt_mask: mask of interrupt bits to update
  * @@enabled_irq_mask: mask of interrupt bits to enable
  */
static void bdw_update_port_irq(struct drm_i915_private *dev_priv,
				uint32_t interrupt_mask,
				uint32_t enabled_irq_mask)
{
	uint32_t new_val;
	uint32_t old_val;

	assert_spin_locked(&dev_priv->irq_lock);

	WARN_ON(enabled_irq_mask & ~interrupt_mask);

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	old_val = I915_READ(GEN8_DE_PORT_IMR);

	new_val = old_val;
	new_val &= ~interrupt_mask;
	new_val |= (~enabled_irq_mask & interrupt_mask);

	if (new_val != old_val) {
		I915_WRITE(GEN8_DE_PORT_IMR, new_val);
		POSTING_READ(GEN8_DE_PORT_IMR);
	}
}

/**
 * ibx_display_interrupt_update - update SDEIMR
 * @@dev_priv: driver private
 * @@interrupt_mask: mask of interrupt bits to update
 * @@enabled_irq_mask: mask of interrupt bits to enable
 */
void ibx_display_interrupt_update(struct drm_i915_private *dev_priv,
				  uint32_t interrupt_mask,
				  uint32_t enabled_irq_mask)
{
	uint32_t sdeimr = I915_READ(SDEIMR);
	sdeimr &= ~interrupt_mask;
	sdeimr |= (~enabled_irq_mask & interrupt_mask);

	WARN_ON(enabled_irq_mask & ~interrupt_mask);

	assert_spin_locked(&dev_priv->irq_lock);

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return;

	I915_WRITE(SDEIMR, sdeimr);
	POSTING_READ(SDEIMR);
}

static void
__i915_enable_pipestat(struct drm_i915_private *dev_priv, enum pipe pipe,
		       u32 enable_mask, u32 status_mask)
{
	u32 reg = PIPESTAT(pipe);
	u32 pipestat = I915_READ(reg) & PIPESTAT_INT_ENABLE_MASK;

	assert_spin_locked(&dev_priv->irq_lock);
	WARN_ON(!intel_irqs_enabled(dev_priv));

	if (WARN_ONCE(enable_mask & ~PIPESTAT_INT_ENABLE_MASK ||
		      status_mask & ~PIPESTAT_INT_STATUS_MASK,
		      "pipe %c: enable_mask=0x%x, status_mask=0x%x\n",
		      pipe_name(pipe), enable_mask, status_mask))
		return;

	if ((pipestat & enable_mask) == enable_mask)
		return;

	dev_priv->pipestat_irq_mask[pipe] |= status_mask;

	/* Enable the interrupt, clear any pending status */
	pipestat |= enable_mask | status_mask;
	I915_WRITE(reg, pipestat);
	POSTING_READ(reg);
}

static void
__i915_disable_pipestat(struct drm_i915_private *dev_priv, enum pipe pipe,
		        u32 enable_mask, u32 status_mask)
{
	u32 reg = PIPESTAT(pipe);
	u32 pipestat = I915_READ(reg) & PIPESTAT_INT_ENABLE_MASK;

	assert_spin_locked(&dev_priv->irq_lock);
	WARN_ON(!intel_irqs_enabled(dev_priv));

	if (WARN_ONCE(enable_mask & ~PIPESTAT_INT_ENABLE_MASK ||
		      status_mask & ~PIPESTAT_INT_STATUS_MASK,
		      "pipe %c: enable_mask=0x%x, status_mask=0x%x\n",
		      pipe_name(pipe), enable_mask, status_mask))
		return;

	if ((pipestat & enable_mask) == 0)
		return;

	dev_priv->pipestat_irq_mask[pipe] &= ~status_mask;

	pipestat &= ~enable_mask;
	I915_WRITE(reg, pipestat);
	POSTING_READ(reg);
}

static u32 vlv_get_pipestat_enable_mask(struct drm_device *dev, u32 status_mask)
{
	u32 enable_mask = status_mask << 16;

	/*
	 * On pipe A we don't support the PSR interrupt yet,
	 * on pipe B and C the same bit MBZ.
	 */
	if (WARN_ON_ONCE(status_mask & PIPE_A_PSR_STATUS_VLV))
		return 0;
	/*
	 * On pipe B and C we don't support the PSR interrupt yet, on pipe
	 * A the same bit is for perf counters which we don't use either.
	 */
	if (WARN_ON_ONCE(status_mask & PIPE_B_PSR_STATUS_VLV))
		return 0;

	enable_mask &= ~(PIPE_FIFO_UNDERRUN_STATUS |
			 SPRITE0_FLIP_DONE_INT_EN_VLV |
			 SPRITE1_FLIP_DONE_INT_EN_VLV);
	if (status_mask & SPRITE0_FLIP_DONE_INT_STATUS_VLV)
		enable_mask |= SPRITE0_FLIP_DONE_INT_EN_VLV;
	if (status_mask & SPRITE1_FLIP_DONE_INT_STATUS_VLV)
		enable_mask |= SPRITE1_FLIP_DONE_INT_EN_VLV;

	return enable_mask;
}

void
i915_enable_pipestat(struct drm_i915_private *dev_priv, enum pipe pipe,
		     u32 status_mask)
{
	u32 enable_mask;

	if (IS_VALLEYVIEW(dev_priv->dev))
		enable_mask = vlv_get_pipestat_enable_mask(dev_priv->dev,
							   status_mask);
	else
		enable_mask = status_mask << 16;
	__i915_enable_pipestat(dev_priv, pipe, enable_mask, status_mask);
}

void
i915_disable_pipestat(struct drm_i915_private *dev_priv, enum pipe pipe,
		      u32 status_mask)
{
	u32 enable_mask;

	if (IS_VALLEYVIEW(dev_priv->dev))
		enable_mask = vlv_get_pipestat_enable_mask(dev_priv->dev,
							   status_mask);
	else
		enable_mask = status_mask << 16;
	__i915_disable_pipestat(dev_priv, pipe, enable_mask, status_mask);
}

/**
 * i915_enable_asle_pipestat - enable ASLE pipestat for OpRegion
 * @@dev: drm device
 */
static void i915_enable_asle_pipestat(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv->opregion.asle || !IS_MOBILE(dev))
		return;

	spin_lock_irq(&dev_priv->irq_lock);

	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_LEGACY_BLC_EVENT_STATUS);
	if (INTEL_INFO(dev)->gen >= 4)
		i915_enable_pipestat(dev_priv, PIPE_A,
				     PIPE_LEGACY_BLC_EVENT_STATUS);

	spin_unlock_irq(&dev_priv->irq_lock);
}

/*
 * This timing diagram depicts the video signal in and
 * around the vertical blanking period.
 *
 * Assumptions about the fictitious mode used in this example:
 *  vblank_start >= 3
 *  vsync_start = vblank_start + 1
 *  vsync_end = vblank_start + 2
 *  vtotal = vblank_start + 3
 *
 *           start of vblank:
 *           latch double buffered registers
 *           increment frame counter (ctg+)
 *           generate start of vblank interrupt (gen4+)
 *           |
 *           |          frame start:
 *           |          generate frame start interrupt (aka. vblank interrupt) (gmch)
 *           |          may be shifted forward 1-3 extra lines via PIPECONF
 *           |          |
 *           |          |  start of vsync:
 *           |          |  generate vsync interrupt
 *           |          |  |
 * ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx___    ___xxxx
 *       .   \hs/   .      \hs/          \hs/          \hs/   .      \hs/
 * ----va---> <-----------------vb--------------------> <--------va-------------
 *       |          |       <----vs----->                     |
 * -vbs-----> <---vbs+1---> <---vbs+2---> <-----0-----> <-----1-----> <-----2--- (scanline counter gen2)
 * -vbs-2---> <---vbs-1---> <---vbs-----> <---vbs+1---> <---vbs+2---> <-----0--- (scanline counter gen3+)
 * -vbs-2---> <---vbs-2---> <---vbs-1---> <---vbs-----> <---vbs+1---> <---vbs+2- (scanline counter hsw+ hdmi)
 *       |          |                                         |
 *       last visible pixel                                   first visible pixel
 *                  |                                         increment frame counter (gen3/4)
 *                  pixel counter = vblank_start * htotal     pixel counter = 0 (gen3/4)
 *
 * x  = horizontal active
 * _  = horizontal blanking
 * hs = horizontal sync
 * va = vertical active
 * vb = vertical blanking
 * vs = vertical sync
 * vbs = vblank_start (number)
 *
 * Summary:
 * - most events happen at the start of horizontal sync
 * - frame start happens at the start of horizontal blank, 1-4 lines
 *   (depending on PIPECONF settings) after the start of vblank
 * - gen3/4 pixel and frame counter are synchronized with the start
 *   of horizontal active on the first line of vertical active
 */

static u32 i8xx_get_vblank_counter(struct drm_device *dev, unsigned int pipe)
{
	/* Gen2 doesn't have a hardware frame counter */
	return 0;
}

/* Called from drm generic code, passed a 'crtc', which
 * we use as a pipe index
 */
static u32 i915_get_vblank_counter(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long high_frame;
	unsigned long low_frame;
	u32 high1, high2, low, pixel, vbl_start, hsync_start, htotal;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
	const struct drm_display_mode *mode = &intel_crtc->base.hwmode;

	htotal = mode->crtc_htotal;
	hsync_start = mode->crtc_hsync_start;
	vbl_start = mode->crtc_vblank_start;
	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
		vbl_start = DIV_ROUND_UP(vbl_start, 2);

	/* Convert to pixel count */
	vbl_start *= htotal;

	/* Start of vblank event occurs at start of hsync */
	vbl_start -= htotal - hsync_start;

	high_frame = PIPEFRAME(pipe);
	low_frame = PIPEFRAMEPIXEL(pipe);

	/*
	 * High & low register fields aren't synchronized, so make sure
	 * we get a low value that's stable across two reads of the high
	 * register.
	 */
	do {
		high1 = I915_READ(high_frame) & PIPE_FRAME_HIGH_MASK;
		low   = I915_READ(low_frame);
		high2 = I915_READ(high_frame) & PIPE_FRAME_HIGH_MASK;
	} while (high1 != high2);

	high1 >>= PIPE_FRAME_HIGH_SHIFT;
	pixel = low & PIPE_PIXEL_MASK;
	low >>= PIPE_FRAME_LOW_SHIFT;

	/*
	 * The frame counter increments at beginning of active.
	 * Cook up a vblank counter by also checking the pixel
	 * counter against vblank start.
	 */
	return (((high1 << 8) | low) + (pixel >= vbl_start)) & 0xffffff;
}

static u32 g4x_get_vblank_counter(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	return I915_READ(PIPE_FRMCOUNT_G4X(pipe));
}

/* raw reads, only for fast reads of display block, no need for forcewake etc. */
#ifdef __linux__
#define __raw_i915_read32(dev_priv__, reg__) readl((dev_priv__)->regs + (reg__))
#else
#define __raw_i915_read32(dev_priv__, reg__) bus_space_read_4((dev_priv__)->regs->bst, (dev_priv__)->regs->bsh, (reg__))
#endif

static int __intel_get_crtc_scanline(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	const struct drm_display_mode *mode = &crtc->base.hwmode;
	enum pipe pipe = crtc->pipe;
	int position, vtotal;

	vtotal = mode->crtc_vtotal;
	if (mode->flags & DRM_MODE_FLAG_INTERLACE)
		vtotal /= 2;

	if (IS_GEN2(dev))
		position = __raw_i915_read32(dev_priv, PIPEDSL(pipe)) & DSL_LINEMASK_GEN2;
	else
		position = __raw_i915_read32(dev_priv, PIPEDSL(pipe)) & DSL_LINEMASK_GEN3;

	/*
	 * On HSW, the DSL reg (0x70000) appears to return 0 if we
	 * read it just before the start of vblank.  So try it again
	 * so we don't accidentally end up spanning a vblank frame
	 * increment, causing the pipe_update_end() code to squak at us.
	 *
	 * The nature of this problem means we can't simply check the ISR
	 * bit and return the vblank start value; nor can we use the scanline
	 * debug register in the transcoder as it appears to have the same
	 * problem.  We may need to extend this to include other platforms,
	 * but so far testing only shows the problem on HSW.
	 */
	if (HAS_DDI(dev) && !position) {
		int i, temp;

		for (i = 0; i < 100; i++) {
			udelay(1);
			temp = __raw_i915_read32(dev_priv, PIPEDSL(pipe)) &
				DSL_LINEMASK_GEN3;
			if (temp != position) {
				position = temp;
				break;
			}
		}
	}

	/*
	 * See update_scanline_offset() for the details on the
	 * scanline_offset adjustment.
	 */
	return (position + crtc->scanline_offset) % vtotal;
}

static int i915_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,
				    unsigned int flags, int *vpos, int *hpos,
				    ktime_t *stime, ktime_t *etime,
				    const struct drm_display_mode *mode)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int position;
	int vbl_start, vbl_end, hsync_start, htotal, vtotal;
	bool in_vbl = true;
	int ret = 0;
	unsigned long irqflags;

	if (WARN_ON(!mode->crtc_clock)) {
		DRM_DEBUG_DRIVER("trying to get scanoutpos for disabled "
				 "pipe %c\n", pipe_name(pipe));
		return 0;
	}

	htotal = mode->crtc_htotal;
	hsync_start = mode->crtc_hsync_start;
	vtotal = mode->crtc_vtotal;
	vbl_start = mode->crtc_vblank_start;
	vbl_end = mode->crtc_vblank_end;

	if (mode->flags & DRM_MODE_FLAG_INTERLACE) {
		vbl_start = DIV_ROUND_UP(vbl_start, 2);
		vbl_end /= 2;
		vtotal /= 2;
	}

	ret |= DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE;

	/*
	 * Lock uncore.lock, as we will do multiple timing critical raw
	 * register reads, potentially with preemption disabled, so the
	 * following code must not block on uncore.lock.
	 */
	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);

	/* preempt_disable_rt() should go right here in PREEMPT_RT patchset. */

	/* Get optional system timestamp before query. */
	if (stime)
		*stime = ktime_get();

	if (IS_GEN2(dev) || IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5) {
		/* No obvious pixelcount register. Only query vertical
		 * scanout position from Display scan line register.
		 */
		position = __intel_get_crtc_scanline(intel_crtc);
	} else {
		/* Have access to pixelcount since start of frame.
		 * We can split this into vertical and horizontal
		 * scanout position.
		 */
		position = (__raw_i915_read32(dev_priv, PIPEFRAMEPIXEL(pipe)) & PIPE_PIXEL_MASK) >> PIPE_PIXEL_SHIFT;

		/* convert to pixel counts */
		vbl_start *= htotal;
		vbl_end *= htotal;
		vtotal *= htotal;

		/*
		 * In interlaced modes, the pixel counter counts all pixels,
		 * so one field will have htotal more pixels. In order to avoid
		 * the reported position from jumping backwards when the pixel
		 * counter is beyond the length of the shorter field, just
		 * clamp the position the length of the shorter field. This
		 * matches how the scanline counter based position works since
		 * the scanline counter doesn't count the two half lines.
		 */
		if (position >= vtotal)
			position = vtotal - 1;

		/*
		 * Start of vblank interrupt is triggered at start of hsync,
		 * just prior to the first active line of vblank. However we
		 * consider lines to start at the leading edge of horizontal
		 * active. So, should we get here before we've crossed into
		 * the horizontal active of the first line in vblank, we would
		 * not set the DRM_SCANOUTPOS_INVBL flag. In order to fix that,
		 * always add htotal-hsync_start to the current pixel position.
		 */
		position = (position + htotal - hsync_start) % vtotal;
	}

	/* Get optional system timestamp after query. */
	if (etime)
		*etime = ktime_get();

	/* preempt_enable_rt() should go right here in PREEMPT_RT patchset. */

	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);

	in_vbl = position >= vbl_start && position < vbl_end;

	/*
	 * While in vblank, position will be negative
	 * counting up towards 0 at vbl_end. And outside
	 * vblank, position will be positive counting
	 * up since vbl_end.
	 */
	if (position >= vbl_start)
		position -= vbl_end;
	else
		position += vtotal - vbl_end;

	if (IS_GEN2(dev) || IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5) {
		*vpos = position;
		*hpos = 0;
	} else {
		*vpos = position / htotal;
		*hpos = position - (*vpos * htotal);
	}

	/* In vblank? */
	if (in_vbl)
		ret |= DRM_SCANOUTPOS_IN_VBLANK;

	return ret;
}

int intel_get_crtc_scanline(struct intel_crtc *crtc)
{
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
	unsigned long irqflags;
	int position;

	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
	position = __intel_get_crtc_scanline(crtc);
	spin_unlock_irqrestore(&dev_priv->uncore.lock, irqflags);

	return position;
}

static int i915_get_vblank_timestamp(struct drm_device *dev, unsigned int pipe,
			      int *max_error,
			      struct timeval *vblank_time,
			      unsigned flags)
{
	struct drm_crtc *crtc;

	if (pipe >= INTEL_INFO(dev)->num_pipes) {
		DRM_ERROR("Invalid crtc %u\n", pipe);
		return -EINVAL;
	}

	/* Get drm_crtc to timestamp: */
	crtc = intel_get_crtc_for_pipe(dev, pipe);
	if (crtc == NULL) {
		DRM_ERROR("Invalid crtc %u\n", pipe);
		return -EINVAL;
	}

	if (!crtc->hwmode.crtc_clock) {
		DRM_DEBUG_KMS("crtc %u is disabled\n", pipe);
		return -EBUSY;
	}

	/* Helper routine in DRM core does all the work: */
	return drm_calc_vbltimestamp_from_scanoutpos(dev, pipe, max_error,
						     vblank_time, flags,
						     &crtc->hwmode);
}

static void ironlake_rps_change_irq_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 busy_up, busy_down, max_avg, min_avg;
	u8 new_delay;

	spin_lock(&mchdev_lock);

	I915_WRITE16(MEMINTRSTS, I915_READ(MEMINTRSTS));

	new_delay = dev_priv->ips.cur_delay;

	I915_WRITE16(MEMINTRSTS, MEMINT_EVAL_CHG);
	busy_up = I915_READ(RCPREVBSYTUPAVG);
	busy_down = I915_READ(RCPREVBSYTDNAVG);
	max_avg = I915_READ(RCBMAXAVG);
	min_avg = I915_READ(RCBMINAVG);

	/* Handle RCS change request from hw */
	if (busy_up > max_avg) {
		if (dev_priv->ips.cur_delay != dev_priv->ips.max_delay)
			new_delay = dev_priv->ips.cur_delay - 1;
		if (new_delay < dev_priv->ips.max_delay)
			new_delay = dev_priv->ips.max_delay;
	} else if (busy_down < min_avg) {
		if (dev_priv->ips.cur_delay != dev_priv->ips.min_delay)
			new_delay = dev_priv->ips.cur_delay + 1;
		if (new_delay > dev_priv->ips.min_delay)
			new_delay = dev_priv->ips.min_delay;
	}

	if (ironlake_set_drps(dev, new_delay))
		dev_priv->ips.cur_delay = new_delay;

	spin_unlock(&mchdev_lock);

	return;
}

static void notify_ring(struct intel_engine_cs *ring)
{
	if (!intel_ring_initialized(ring))
		return;

	trace_i915_gem_request_notify(ring);

	wake_up_all(&ring->irq_queue);
}

static void vlv_c0_read(struct drm_i915_private *dev_priv,
			struct intel_rps_ei *ei)
{
	ei->cz_clock = vlv_punit_read(dev_priv, PUNIT_REG_CZ_TIMESTAMP);
	ei->render_c0 = I915_READ(VLV_RENDER_C0_COUNT);
	ei->media_c0 = I915_READ(VLV_MEDIA_C0_COUNT);
}

void gen6_rps_reset_ei(struct drm_i915_private *dev_priv)
{
	memset(&dev_priv->rps.ei, 0, sizeof(dev_priv->rps.ei));
}

static u32 vlv_wa_c0_ei(struct drm_i915_private *dev_priv, u32 pm_iir)
{
	const struct intel_rps_ei *prev = &dev_priv->rps.ei;
	struct intel_rps_ei now;
	u32 events = 0;

	if ((pm_iir & GEN6_PM_RP_UP_EI_EXPIRED) == 0)
		return 0;

	vlv_c0_read(dev_priv, &now);
	if (now.cz_clock == 0)
		return 0;

	if (prev->cz_clock) {
		u64 time, c0;
		unsigned int mul;

		mul = VLV_CZ_CLOCK_TO_MILLI_SEC * 100; /* scale to threshold% */
		if (I915_READ(VLV_COUNTER_CONTROL) & VLV_COUNT_RANGE_HIGH)
			mul <<= 8;

		time = now.cz_clock - prev->cz_clock;
		time *= dev_priv->czclk_freq;

		/* Workload can be split between render + media,
		 * e.g. SwapBuffers being blitted in X after being rendered in
		 * mesa. To account for this we need to combine both engines
		 * into our activity counter.
		 */
		c0 = now.render_c0 - prev->render_c0;
		c0 += now.media_c0 - prev->media_c0;
		c0 *= mul;

		if (c0 > time * dev_priv->rps.up_threshold)
			events = GEN6_PM_RP_UP_THRESHOLD;
		else if (c0 < time * dev_priv->rps.down_threshold)
			events = GEN6_PM_RP_DOWN_THRESHOLD;
	}

	dev_priv->rps.ei = now;
	return events;
}

static bool any_waiters(struct drm_i915_private *dev_priv)
{
	struct intel_engine_cs *ring;
	int i;

	for_each_ring(ring, dev_priv, i)
		if (ring->irq_refcount)
			return true;

	return false;
}

static void gen6_pm_rps_work(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, struct drm_i915_private, rps.work);
	bool client_boost;
	int new_delay, adj, min, max;
	u32 pm_iir;

	spin_lock_irq(&dev_priv->irq_lock);
	/* Speed up work cancelation during disabling rps interrupts. */
	if (!dev_priv->rps.interrupts_enabled) {
		spin_unlock_irq(&dev_priv->irq_lock);
		return;
	}
	pm_iir = dev_priv->rps.pm_iir;
	dev_priv->rps.pm_iir = 0;
	/* Make sure not to corrupt PMIMR state used by ringbuffer on GEN6 */
	gen6_enable_pm_irq(dev_priv, dev_priv->pm_rps_events);
	client_boost = dev_priv->rps.client_boost;
	dev_priv->rps.client_boost = false;
	spin_unlock_irq(&dev_priv->irq_lock);

	/* Make sure we didn't queue anything we're not going to process. */
	WARN_ON(pm_iir & ~dev_priv->pm_rps_events);

	if ((pm_iir & dev_priv->pm_rps_events) == 0 && !client_boost)
		return;

	mutex_lock(&dev_priv->rps.hw_lock);

	pm_iir |= vlv_wa_c0_ei(dev_priv, pm_iir);

	adj = dev_priv->rps.last_adj;
	new_delay = dev_priv->rps.cur_freq;
	min = dev_priv->rps.min_freq_softlimit;
	max = dev_priv->rps.max_freq_softlimit;

	if (client_boost) {
		new_delay = dev_priv->rps.max_freq_softlimit;
		adj = 0;
	} else if (pm_iir & GEN6_PM_RP_UP_THRESHOLD) {
		if (adj > 0)
			adj *= 2;
		else /* CHV needs even encode values */
			adj = IS_CHERRYVIEW(dev_priv) ? 2 : 1;
		/*
		 * For better performance, jump directly
		 * to RPe if we're below it.
		 */
		if (new_delay < dev_priv->rps.efficient_freq - adj) {
			new_delay = dev_priv->rps.efficient_freq;
			adj = 0;
		}
	} else if (any_waiters(dev_priv)) {
		adj = 0;
	} else if (pm_iir & GEN6_PM_RP_DOWN_TIMEOUT) {
		if (dev_priv->rps.cur_freq > dev_priv->rps.efficient_freq)
			new_delay = dev_priv->rps.efficient_freq;
		else
			new_delay = dev_priv->rps.min_freq_softlimit;
		adj = 0;
	} else if (pm_iir & GEN6_PM_RP_DOWN_THRESHOLD) {
		if (adj < 0)
			adj *= 2;
		else /* CHV needs even encode values */
			adj = IS_CHERRYVIEW(dev_priv) ? -2 : -1;
	} else { /* unknown event */
		adj = 0;
	}

	dev_priv->rps.last_adj = adj;

	/* sysfs frequency interfaces may have snuck in while servicing the
	 * interrupt
	 */
	new_delay += adj;
	new_delay = clamp_t(int, new_delay, min, max);

	intel_set_rps(dev_priv->dev, new_delay);

	mutex_unlock(&dev_priv->rps.hw_lock);
}


/**
 * ivybridge_parity_work - Workqueue called when a parity error interrupt
 * occurred.
 * @@work: workqueue struct
 *
 * Doesn't actually do anything except notify userspace. As a consequence of
 * this event, userspace should try to remap the bad rows since statistically
 * it is likely the same row is more likely to go bad again.
 */
static void ivybridge_parity_work(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, struct drm_i915_private, l3_parity.error_work);
	u32 error_status, row, bank, subbank;
#ifdef __linux__
	char *parity_event[6];
#endif
	uint32_t misccpctl;
	uint8_t slice = 0;

	/* We must turn off DOP level clock gating to access the L3 registers.
	 * In order to prevent a get/put style interface, acquire struct mutex
	 * any time we access those registers.
	 */
	mutex_lock(&dev_priv->dev->struct_mutex);

	/* If we've screwed up tracking, just let the interrupt fire again */
	if (WARN_ON(!dev_priv->l3_parity.which_slice))
		goto out;

	misccpctl = I915_READ(GEN7_MISCCPCTL);
	I915_WRITE(GEN7_MISCCPCTL, misccpctl & ~GEN7_DOP_CLOCK_GATE_ENABLE);
	POSTING_READ(GEN7_MISCCPCTL);

	while ((slice = ffs(dev_priv->l3_parity.which_slice)) != 0) {
		u32 reg;

		slice--;
		if (WARN_ON_ONCE(slice >= NUM_L3_SLICES(dev_priv->dev)))
			break;

		dev_priv->l3_parity.which_slice &= ~(1<<slice);

		reg = GEN7_L3CDERRST1 + (slice * 0x200);

		error_status = I915_READ(reg);
		row = GEN7_PARITY_ERROR_ROW(error_status);
		bank = GEN7_PARITY_ERROR_BANK(error_status);
		subbank = GEN7_PARITY_ERROR_SUBBANK(error_status);

		I915_WRITE(reg, GEN7_PARITY_ERROR_VALID | GEN7_L3CDERRST1_ENABLE);
		POSTING_READ(reg);

#ifdef __linux__
		parity_event[0] = I915_L3_PARITY_UEVENT "=1";
		parity_event[1] = kasprintf(GFP_KERNEL, "ROW=%d", row);
		parity_event[2] = kasprintf(GFP_KERNEL, "BANK=%d", bank);
		parity_event[3] = kasprintf(GFP_KERNEL, "SUBBANK=%d", subbank);
		parity_event[4] = kasprintf(GFP_KERNEL, "SLICE=%d", slice);
		parity_event[5] = NULL;

		kobject_uevent_env(&dev_priv->dev->primary->kdev->kobj,
				   KOBJ_CHANGE, parity_event);
#endif

		DRM_DEBUG("Parity error: Slice = %d, Row = %d, Bank = %d, Sub bank = %d.\n",
			  slice, row, bank, subbank);

#ifdef __linux__
		kfree(parity_event[4]);
		kfree(parity_event[3]);
		kfree(parity_event[2]);
		kfree(parity_event[1]);
#endif
	}

	I915_WRITE(GEN7_MISCCPCTL, misccpctl);

out:
	WARN_ON(dev_priv->l3_parity.which_slice);
	spin_lock_irq(&dev_priv->irq_lock);
	gen5_enable_gt_irq(dev_priv, GT_PARITY_ERROR(dev_priv->dev));
	spin_unlock_irq(&dev_priv->irq_lock);

	mutex_unlock(&dev_priv->dev->struct_mutex);
}

static void ivybridge_parity_error_irq_handler(struct drm_device *dev, u32 iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!HAS_L3_DPF(dev))
		return;

	spin_lock(&dev_priv->irq_lock);
	gen5_disable_gt_irq(dev_priv, GT_PARITY_ERROR(dev));
	spin_unlock(&dev_priv->irq_lock);

	iir &= GT_PARITY_ERROR(dev);
	if (iir & GT_RENDER_L3_PARITY_ERROR_INTERRUPT_S1)
		dev_priv->l3_parity.which_slice |= 1 << 1;

	if (iir & GT_RENDER_L3_PARITY_ERROR_INTERRUPT)
		dev_priv->l3_parity.which_slice |= 1 << 0;

	queue_work(dev_priv->wq, &dev_priv->l3_parity.error_work);
}

static void ilk_gt_irq_handler(struct drm_device *dev,
			       struct drm_i915_private *dev_priv,
			       u32 gt_iir)
{
	if (gt_iir &
	    (GT_RENDER_USER_INTERRUPT | GT_RENDER_PIPECTL_NOTIFY_INTERRUPT))
		notify_ring(&dev_priv->ring[RCS]);
	if (gt_iir & ILK_BSD_USER_INTERRUPT)
		notify_ring(&dev_priv->ring[VCS]);
}

static void snb_gt_irq_handler(struct drm_device *dev,
			       struct drm_i915_private *dev_priv,
			       u32 gt_iir)
{

	if (gt_iir &
	    (GT_RENDER_USER_INTERRUPT | GT_RENDER_PIPECTL_NOTIFY_INTERRUPT))
		notify_ring(&dev_priv->ring[RCS]);
	if (gt_iir & GT_BSD_USER_INTERRUPT)
		notify_ring(&dev_priv->ring[VCS]);
	if (gt_iir & GT_BLT_USER_INTERRUPT)
		notify_ring(&dev_priv->ring[BCS]);

	if (gt_iir & (GT_BLT_CS_ERROR_INTERRUPT |
		      GT_BSD_CS_ERROR_INTERRUPT |
		      GT_RENDER_CS_MASTER_ERROR_INTERRUPT))
		DRM_DEBUG("Command parser error, gt_iir 0x%08x\n", gt_iir);

	if (gt_iir & GT_PARITY_ERROR(dev))
		ivybridge_parity_error_irq_handler(dev, gt_iir);
}

static irqreturn_t gen8_gt_irq_handler(struct drm_i915_private *dev_priv,
				       u32 master_ctl)
{
	irqreturn_t ret = IRQ_NONE;

	if (master_ctl & (GEN8_GT_RCS_IRQ | GEN8_GT_BCS_IRQ)) {
		u32 tmp = I915_READ_FW(GEN8_GT_IIR(0));
		if (tmp) {
			I915_WRITE_FW(GEN8_GT_IIR(0), tmp);
			ret = IRQ_HANDLED;

			if (tmp & (GT_CONTEXT_SWITCH_INTERRUPT << GEN8_RCS_IRQ_SHIFT))
				intel_lrc_irq_handler(&dev_priv->ring[RCS]);
			if (tmp & (GT_RENDER_USER_INTERRUPT << GEN8_RCS_IRQ_SHIFT))
				notify_ring(&dev_priv->ring[RCS]);

			if (tmp & (GT_CONTEXT_SWITCH_INTERRUPT << GEN8_BCS_IRQ_SHIFT))
				intel_lrc_irq_handler(&dev_priv->ring[BCS]);
			if (tmp & (GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT))
				notify_ring(&dev_priv->ring[BCS]);
		} else
			DRM_ERROR("The master control interrupt lied (GT0)!\n");
	}

	if (master_ctl & (GEN8_GT_VCS1_IRQ | GEN8_GT_VCS2_IRQ)) {
		u32 tmp = I915_READ_FW(GEN8_GT_IIR(1));
		if (tmp) {
			I915_WRITE_FW(GEN8_GT_IIR(1), tmp);
			ret = IRQ_HANDLED;

			if (tmp & (GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VCS1_IRQ_SHIFT))
				intel_lrc_irq_handler(&dev_priv->ring[VCS]);
			if (tmp & (GT_RENDER_USER_INTERRUPT << GEN8_VCS1_IRQ_SHIFT))
				notify_ring(&dev_priv->ring[VCS]);

			if (tmp & (GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VCS2_IRQ_SHIFT))
				intel_lrc_irq_handler(&dev_priv->ring[VCS2]);
			if (tmp & (GT_RENDER_USER_INTERRUPT << GEN8_VCS2_IRQ_SHIFT))
				notify_ring(&dev_priv->ring[VCS2]);
		} else
			DRM_ERROR("The master control interrupt lied (GT1)!\n");
	}

	if (master_ctl & GEN8_GT_VECS_IRQ) {
		u32 tmp = I915_READ_FW(GEN8_GT_IIR(3));
		if (tmp) {
			I915_WRITE_FW(GEN8_GT_IIR(3), tmp);
			ret = IRQ_HANDLED;

			if (tmp & (GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VECS_IRQ_SHIFT))
				intel_lrc_irq_handler(&dev_priv->ring[VECS]);
			if (tmp & (GT_RENDER_USER_INTERRUPT << GEN8_VECS_IRQ_SHIFT))
				notify_ring(&dev_priv->ring[VECS]);
		} else
			DRM_ERROR("The master control interrupt lied (GT3)!\n");
	}

	if (master_ctl & GEN8_GT_PM_IRQ) {
		u32 tmp = I915_READ_FW(GEN8_GT_IIR(2));
		if (tmp & dev_priv->pm_rps_events) {
			I915_WRITE_FW(GEN8_GT_IIR(2),
				      tmp & dev_priv->pm_rps_events);
			ret = IRQ_HANDLED;
			gen6_rps_irq_handler(dev_priv, tmp);
		} else
			DRM_ERROR("The master control interrupt lied (PM)!\n");
	}

	return ret;
}

static bool bxt_port_hotplug_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_A:
		return val & PORTA_HOTPLUG_LONG_DETECT;
	case PORT_B:
		return val & PORTB_HOTPLUG_LONG_DETECT;
	case PORT_C:
		return val & PORTC_HOTPLUG_LONG_DETECT;
	default:
		return false;
	}
}

static bool spt_port_hotplug2_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_E:
		return val & PORTE_HOTPLUG_LONG_DETECT;
	default:
		return false;
	}
}

static bool spt_port_hotplug_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_A:
		return val & PORTA_HOTPLUG_LONG_DETECT;
	case PORT_B:
		return val & PORTB_HOTPLUG_LONG_DETECT;
	case PORT_C:
		return val & PORTC_HOTPLUG_LONG_DETECT;
	case PORT_D:
		return val & PORTD_HOTPLUG_LONG_DETECT;
	default:
		return false;
	}
}

static bool ilk_port_hotplug_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_A:
		return val & DIGITAL_PORTA_HOTPLUG_LONG_DETECT;
	default:
		return false;
	}
}

static bool pch_port_hotplug_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_B:
		return val & PORTB_HOTPLUG_LONG_DETECT;
	case PORT_C:
		return val & PORTC_HOTPLUG_LONG_DETECT;
	case PORT_D:
		return val & PORTD_HOTPLUG_LONG_DETECT;
	default:
		return false;
	}
}

static bool i9xx_port_hotplug_long_detect(enum port port, u32 val)
{
	switch (port) {
	case PORT_B:
		return val & PORTB_HOTPLUG_INT_LONG_PULSE;
	case PORT_C:
		return val & PORTC_HOTPLUG_INT_LONG_PULSE;
	case PORT_D:
		return val & PORTD_HOTPLUG_INT_LONG_PULSE;
	default:
		return false;
	}
}

/*
 * Get a bit mask of pins that have triggered, and which ones may be long.
 * This can be called multiple times with the same masks to accumulate
 * hotplug detection results from several registers.
 *
 * Note that the caller is expected to zero out the masks initially.
 */
static void intel_get_hpd_pins(u32 *pin_mask, u32 *long_mask,
			     u32 hotplug_trigger, u32 dig_hotplug_reg,
			     const u32 hpd[HPD_NUM_PINS],
			     bool long_pulse_detect(enum port port, u32 val))
{
	enum port port;
	int i;

	for_each_hpd_pin(i) {
		if ((hpd[i] & hotplug_trigger) == 0)
			continue;

		*pin_mask |= BIT(i);

		if (!intel_hpd_pin_to_port(i, &port))
			continue;

		if (long_pulse_detect(port, dig_hotplug_reg))
			*long_mask |= BIT(i);
	}

	DRM_DEBUG_DRIVER("hotplug event received, stat 0x%08x, dig 0x%08x, pins 0x%08x\n",
			 hotplug_trigger, dig_hotplug_reg, *pin_mask);

}

static void gmbus_irq_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	wake_up_all(&dev_priv->gmbus_wait_queue);
}

static void dp_aux_irq_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	wake_up_all(&dev_priv->gmbus_wait_queue);
}

#if defined(CONFIG_DEBUG_FS)
static void display_pipe_crc_irq_handler(struct drm_device *dev, enum pipe pipe,
					 uint32_t crc0, uint32_t crc1,
					 uint32_t crc2, uint32_t crc3,
					 uint32_t crc4)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[pipe];
	struct intel_pipe_crc_entry *entry;
	int head, tail;

	spin_lock(&pipe_crc->lock);

	if (!pipe_crc->entries) {
		spin_unlock(&pipe_crc->lock);
		DRM_DEBUG_KMS("spurious interrupt\n");
		return;
	}

	head = pipe_crc->head;
	tail = pipe_crc->tail;

	if (CIRC_SPACE(head, tail, INTEL_PIPE_CRC_ENTRIES_NR) < 1) {
		spin_unlock(&pipe_crc->lock);
		DRM_ERROR("CRC buffer overflowing\n");
		return;
	}

	entry = &pipe_crc->entries[head];

	entry->frame = dev->driver->get_vblank_counter(dev, pipe);
	entry->crc[0] = crc0;
	entry->crc[1] = crc1;
	entry->crc[2] = crc2;
	entry->crc[3] = crc3;
	entry->crc[4] = crc4;

	head = (head + 1) & (INTEL_PIPE_CRC_ENTRIES_NR - 1);
	pipe_crc->head = head;

	spin_unlock(&pipe_crc->lock);

	wake_up_interruptible(&pipe_crc->wq);
}
#else
static inline void
display_pipe_crc_irq_handler(struct drm_device *dev, enum pipe pipe,
			     uint32_t crc0, uint32_t crc1,
			     uint32_t crc2, uint32_t crc3,
			     uint32_t crc4) {}
#endif


static void hsw_pipe_crc_irq_handler(struct drm_device *dev, enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	display_pipe_crc_irq_handler(dev, pipe,
				     I915_READ(PIPE_CRC_RES_1_IVB(pipe)),
				     0, 0, 0, 0);
}

static void ivb_pipe_crc_irq_handler(struct drm_device *dev, enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	display_pipe_crc_irq_handler(dev, pipe,
				     I915_READ(PIPE_CRC_RES_1_IVB(pipe)),
				     I915_READ(PIPE_CRC_RES_2_IVB(pipe)),
				     I915_READ(PIPE_CRC_RES_3_IVB(pipe)),
				     I915_READ(PIPE_CRC_RES_4_IVB(pipe)),
				     I915_READ(PIPE_CRC_RES_5_IVB(pipe)));
}

static void i9xx_pipe_crc_irq_handler(struct drm_device *dev, enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t res1, res2;

	if (INTEL_INFO(dev)->gen >= 3)
		res1 = I915_READ(PIPE_CRC_RES_RES1_I915(pipe));
	else
		res1 = 0;

	if (INTEL_INFO(dev)->gen >= 5 || IS_G4X(dev))
		res2 = I915_READ(PIPE_CRC_RES_RES2_G4X(pipe));
	else
		res2 = 0;

	display_pipe_crc_irq_handler(dev, pipe,
				     I915_READ(PIPE_CRC_RES_RED(pipe)),
				     I915_READ(PIPE_CRC_RES_GREEN(pipe)),
				     I915_READ(PIPE_CRC_RES_BLUE(pipe)),
				     res1, res2);
}

/* The RPS events need forcewake, so we add them to a work queue and mask their
 * IMR bits until the work is done. Other interrupts can be processed without
 * the work queue. */
static void gen6_rps_irq_handler(struct drm_i915_private *dev_priv, u32 pm_iir)
{
	if (pm_iir & dev_priv->pm_rps_events) {
		spin_lock(&dev_priv->irq_lock);
		gen6_disable_pm_irq(dev_priv, pm_iir & dev_priv->pm_rps_events);
		if (dev_priv->rps.interrupts_enabled) {
			dev_priv->rps.pm_iir |= pm_iir & dev_priv->pm_rps_events;
			queue_work(dev_priv->wq, &dev_priv->rps.work);
		}
		spin_unlock(&dev_priv->irq_lock);
	}

	if (INTEL_INFO(dev_priv)->gen >= 8)
		return;

	if (HAS_VEBOX(dev_priv->dev)) {
		if (pm_iir & PM_VEBOX_USER_INTERRUPT)
			notify_ring(&dev_priv->ring[VECS]);

		if (pm_iir & PM_VEBOX_CS_ERROR_INTERRUPT)
			DRM_DEBUG("Command parser error, pm_iir 0x%08x\n", pm_iir);
	}
}

static bool intel_pipe_handle_vblank(struct drm_device *dev, enum pipe pipe)
{
	if (!drm_handle_vblank(dev, pipe))
		return false;

	return true;
}

static void valleyview_pipestat_irq_handler(struct drm_device *dev, u32 iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pipe_stats[I915_MAX_PIPES] = { };
	int pipe;

	spin_lock(&dev_priv->irq_lock);
	for_each_pipe(dev_priv, pipe) {
		int reg;
		u32 mask, iir_bit = 0;

		/*
		 * PIPESTAT bits get signalled even when the interrupt is
		 * disabled with the mask bits, and some of the status bits do
		 * not generate interrupts at all (like the underrun bit). Hence
		 * we need to be careful that we only handle what we want to
		 * handle.
		 */

		/* fifo underruns are filterered in the underrun handler. */
		mask = PIPE_FIFO_UNDERRUN_STATUS;

		switch (pipe) {
		case PIPE_A:
			iir_bit = I915_DISPLAY_PIPE_A_EVENT_INTERRUPT;
			break;
		case PIPE_B:
			iir_bit = I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
			break;
		case PIPE_C:
			iir_bit = I915_DISPLAY_PIPE_C_EVENT_INTERRUPT;
			break;
		}
		if (iir & iir_bit)
			mask |= dev_priv->pipestat_irq_mask[pipe];

		if (!mask)
			continue;

		reg = PIPESTAT(pipe);
		mask |= PIPESTAT_INT_ENABLE_MASK;
		pipe_stats[pipe] = I915_READ(reg) & mask;

		/*
		 * Clear the PIPE*STAT regs before the IIR
		 */
		if (pipe_stats[pipe] & (PIPE_FIFO_UNDERRUN_STATUS |
					PIPESTAT_INT_STATUS_MASK))
			I915_WRITE(reg, pipe_stats[pipe]);
	}
	spin_unlock(&dev_priv->irq_lock);

	for_each_pipe(dev_priv, pipe) {
		if (pipe_stats[pipe] & PIPE_START_VBLANK_INTERRUPT_STATUS &&
		    intel_pipe_handle_vblank(dev, pipe))
			intel_check_page_flip(dev, pipe);

		if (pipe_stats[pipe] & PLANE_FLIP_DONE_INT_STATUS_VLV) {
			intel_prepare_page_flip(dev, pipe);
			intel_finish_page_flip(dev, pipe);
		}

		if (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)
			i9xx_pipe_crc_irq_handler(dev, pipe);

		if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
			intel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);
	}

	if (pipe_stats[0] & PIPE_GMBUS_INTERRUPT_STATUS)
		gmbus_irq_handler(dev);
}

static void i9xx_hpd_irq_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_status = I915_READ(PORT_HOTPLUG_STAT);
	u32 pin_mask = 0, long_mask = 0;

	if (!hotplug_status)
		return;

	I915_WRITE(PORT_HOTPLUG_STAT, hotplug_status);
	/*
	 * Make sure hotplug status is cleared before we clear IIR, or else we
	 * may miss hotplug events.
	 */
	POSTING_READ(PORT_HOTPLUG_STAT);

	if (IS_G4X(dev) || IS_VALLEYVIEW(dev)) {
		u32 hotplug_trigger = hotplug_status & HOTPLUG_INT_STATUS_G4X;

		if (hotplug_trigger) {
			intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
					   hotplug_trigger, hpd_status_g4x,
					   i9xx_port_hotplug_long_detect);

			intel_hpd_irq_handler(dev, pin_mask, long_mask);
		}

		if (hotplug_status & DP_AUX_CHANNEL_MASK_INT_STATUS_G4X)
			dp_aux_irq_handler(dev);
	} else {
		u32 hotplug_trigger = hotplug_status & HOTPLUG_INT_STATUS_I915;

		if (hotplug_trigger) {
			intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
					   hotplug_trigger, hpd_status_i915,
					   i9xx_port_hotplug_long_detect);
			intel_hpd_irq_handler(dev, pin_mask, long_mask);
		}
	}
}

static irqreturn_t valleyview_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 iir, gt_iir, pm_iir;
	irqreturn_t ret = IRQ_NONE;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	while (true) {
		/* Find, clear, then process each source of interrupt */

		gt_iir = I915_READ(GTIIR);
		if (gt_iir)
			I915_WRITE(GTIIR, gt_iir);

		pm_iir = I915_READ(GEN6_PMIIR);
		if (pm_iir)
			I915_WRITE(GEN6_PMIIR, pm_iir);

		iir = I915_READ(VLV_IIR);
		if (iir) {
			/* Consume port before clearing IIR or we'll miss events */
			if (iir & I915_DISPLAY_PORT_INTERRUPT)
				i9xx_hpd_irq_handler(dev);
			I915_WRITE(VLV_IIR, iir);
		}

		if (gt_iir == 0 && pm_iir == 0 && iir == 0)
			goto out;

		ret = IRQ_HANDLED;

		if (gt_iir)
			snb_gt_irq_handler(dev, dev_priv, gt_iir);
		if (pm_iir)
			gen6_rps_irq_handler(dev_priv, pm_iir);
		/* Call regardless, as some status bits might not be
		 * signalled in iir */
		valleyview_pipestat_irq_handler(dev, iir);
	}

out:
	return ret;
}

static irqreturn_t cherryview_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 master_ctl, iir;
	irqreturn_t ret = IRQ_NONE;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	for (;;) {
		master_ctl = I915_READ(GEN8_MASTER_IRQ) & ~GEN8_MASTER_IRQ_CONTROL;
		iir = I915_READ(VLV_IIR);

		if (master_ctl == 0 && iir == 0)
			break;

		ret = IRQ_HANDLED;

		I915_WRITE(GEN8_MASTER_IRQ, 0);

		/* Find, clear, then process each source of interrupt */

		if (iir) {
			/* Consume port before clearing IIR or we'll miss events */
			if (iir & I915_DISPLAY_PORT_INTERRUPT)
				i9xx_hpd_irq_handler(dev);
			I915_WRITE(VLV_IIR, iir);
		}

		gen8_gt_irq_handler(dev_priv, master_ctl);

		/* Call regardless, as some status bits might not be
		 * signalled in iir */
		valleyview_pipestat_irq_handler(dev, iir);

		I915_WRITE(GEN8_MASTER_IRQ, DE_MASTER_IRQ_CONTROL);
		POSTING_READ(GEN8_MASTER_IRQ);
	}

	return ret;
}

static void ibx_hpd_irq_handler(struct drm_device *dev, u32 hotplug_trigger,
				const u32 hpd[HPD_NUM_PINS])
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	u32 dig_hotplug_reg, pin_mask = 0, long_mask = 0;

	dig_hotplug_reg = I915_READ(PCH_PORT_HOTPLUG);
	I915_WRITE(PCH_PORT_HOTPLUG, dig_hotplug_reg);

	intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
			   dig_hotplug_reg, hpd,
			   pch_port_hotplug_long_detect);

	intel_hpd_irq_handler(dev, pin_mask, long_mask);
}

static void ibx_irq_handler(struct drm_device *dev, u32 pch_iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;
	u32 hotplug_trigger = pch_iir & SDE_HOTPLUG_MASK;

	if (hotplug_trigger)
		ibx_hpd_irq_handler(dev, hotplug_trigger, hpd_ibx);

#ifdef __linux__
	if (pch_iir & SDE_AUDIO_POWER_MASK) {
		int port = ffs((pch_iir & SDE_AUDIO_POWER_MASK) >>
			       SDE_AUDIO_POWER_SHIFT);
		DRM_DEBUG_DRIVER("PCH audio power change on port %d\n",
				 port_name(port));
	}
#endif

	if (pch_iir & SDE_AUX_MASK)
		dp_aux_irq_handler(dev);

	if (pch_iir & SDE_GMBUS)
		gmbus_irq_handler(dev);

	if (pch_iir & SDE_AUDIO_HDCP_MASK)
		DRM_DEBUG_DRIVER("PCH HDCP audio interrupt\n");

	if (pch_iir & SDE_AUDIO_TRANS_MASK)
		DRM_DEBUG_DRIVER("PCH transcoder audio interrupt\n");

	if (pch_iir & SDE_POISON)
		DRM_ERROR("PCH poison interrupt\n");

	if (pch_iir & SDE_FDI_MASK)
		for_each_pipe(dev_priv, pipe)
			DRM_DEBUG_DRIVER("  pipe %c FDI IIR: 0x%08x\n",
					 pipe_name(pipe),
					 I915_READ(FDI_RX_IIR(pipe)));

	if (pch_iir & (SDE_TRANSB_CRC_DONE | SDE_TRANSA_CRC_DONE))
		DRM_DEBUG_DRIVER("PCH transcoder CRC done interrupt\n");

	if (pch_iir & (SDE_TRANSB_CRC_ERR | SDE_TRANSA_CRC_ERR))
		DRM_DEBUG_DRIVER("PCH transcoder CRC error interrupt\n");

	if (pch_iir & SDE_TRANSA_FIFO_UNDER)
		intel_pch_fifo_underrun_irq_handler(dev_priv, TRANSCODER_A);

	if (pch_iir & SDE_TRANSB_FIFO_UNDER)
		intel_pch_fifo_underrun_irq_handler(dev_priv, TRANSCODER_B);
}

static void ivb_err_int_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 err_int = I915_READ(GEN7_ERR_INT);
	enum pipe pipe;

	if (err_int & ERR_INT_POISON)
		DRM_ERROR("Poison interrupt\n");

	for_each_pipe(dev_priv, pipe) {
		if (err_int & ERR_INT_FIFO_UNDERRUN(pipe))
			intel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);

		if (err_int & ERR_INT_PIPE_CRC_DONE(pipe)) {
			if (IS_IVYBRIDGE(dev))
				ivb_pipe_crc_irq_handler(dev, pipe);
			else
				hsw_pipe_crc_irq_handler(dev, pipe);
		}
	}

	I915_WRITE(GEN7_ERR_INT, err_int);
}

static void cpt_serr_int_handler(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 serr_int = I915_READ(SERR_INT);

	if (serr_int & SERR_INT_POISON)
		DRM_ERROR("PCH poison interrupt\n");

	if (serr_int & SERR_INT_TRANS_A_FIFO_UNDERRUN)
		intel_pch_fifo_underrun_irq_handler(dev_priv, TRANSCODER_A);

	if (serr_int & SERR_INT_TRANS_B_FIFO_UNDERRUN)
		intel_pch_fifo_underrun_irq_handler(dev_priv, TRANSCODER_B);

	if (serr_int & SERR_INT_TRANS_C_FIFO_UNDERRUN)
		intel_pch_fifo_underrun_irq_handler(dev_priv, TRANSCODER_C);

	I915_WRITE(SERR_INT, serr_int);
}

static void cpt_irq_handler(struct drm_device *dev, u32 pch_iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;
	u32 hotplug_trigger = pch_iir & SDE_HOTPLUG_MASK_CPT;

	if (hotplug_trigger)
		ibx_hpd_irq_handler(dev, hotplug_trigger, hpd_cpt);

#ifdef __linux__
	if (pch_iir & SDE_AUDIO_POWER_MASK_CPT) {
		int port = ffs((pch_iir & SDE_AUDIO_POWER_MASK_CPT) >>
			       SDE_AUDIO_POWER_SHIFT_CPT);
		DRM_DEBUG_DRIVER("PCH audio power change on port %c\n",
				 port_name(port));
	}
#endif

	if (pch_iir & SDE_AUX_MASK_CPT)
		dp_aux_irq_handler(dev);

	if (pch_iir & SDE_GMBUS_CPT)
		gmbus_irq_handler(dev);

	if (pch_iir & SDE_AUDIO_CP_REQ_CPT)
		DRM_DEBUG_DRIVER("Audio CP request interrupt\n");

	if (pch_iir & SDE_AUDIO_CP_CHG_CPT)
		DRM_DEBUG_DRIVER("Audio CP change interrupt\n");

	if (pch_iir & SDE_FDI_MASK_CPT)
		for_each_pipe(dev_priv, pipe)
			DRM_DEBUG_DRIVER("  pipe %c FDI IIR: 0x%08x\n",
					 pipe_name(pipe),
					 I915_READ(FDI_RX_IIR(pipe)));

	if (pch_iir & SDE_ERROR_CPT)
		cpt_serr_int_handler(dev);
}

static void spt_irq_handler(struct drm_device *dev, u32 pch_iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_trigger = pch_iir & SDE_HOTPLUG_MASK_SPT &
		~SDE_PORTE_HOTPLUG_SPT;
	u32 hotplug2_trigger = pch_iir & SDE_PORTE_HOTPLUG_SPT;
	u32 pin_mask = 0, long_mask = 0;

	if (hotplug_trigger) {
		u32 dig_hotplug_reg;

		dig_hotplug_reg = I915_READ(PCH_PORT_HOTPLUG);
		I915_WRITE(PCH_PORT_HOTPLUG, dig_hotplug_reg);

		intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
				   dig_hotplug_reg, hpd_spt,
				   spt_port_hotplug_long_detect);
	}

	if (hotplug2_trigger) {
		u32 dig_hotplug_reg;

		dig_hotplug_reg = I915_READ(PCH_PORT_HOTPLUG2);
		I915_WRITE(PCH_PORT_HOTPLUG2, dig_hotplug_reg);

		intel_get_hpd_pins(&pin_mask, &long_mask, hotplug2_trigger,
				   dig_hotplug_reg, hpd_spt,
				   spt_port_hotplug2_long_detect);
	}

	if (pin_mask)
		intel_hpd_irq_handler(dev, pin_mask, long_mask);

	if (pch_iir & SDE_GMBUS_CPT)
		gmbus_irq_handler(dev);
}

static void ilk_hpd_irq_handler(struct drm_device *dev, u32 hotplug_trigger,
				const u32 hpd[HPD_NUM_PINS])
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	u32 dig_hotplug_reg, pin_mask = 0, long_mask = 0;

	dig_hotplug_reg = I915_READ(DIGITAL_PORT_HOTPLUG_CNTRL);
	I915_WRITE(DIGITAL_PORT_HOTPLUG_CNTRL, dig_hotplug_reg);

	intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
			   dig_hotplug_reg, hpd,
			   ilk_port_hotplug_long_detect);

	intel_hpd_irq_handler(dev, pin_mask, long_mask);
}

static void ilk_display_irq_handler(struct drm_device *dev, u32 de_iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe;
	u32 hotplug_trigger = de_iir & DE_DP_A_HOTPLUG;

	if (hotplug_trigger)
		ilk_hpd_irq_handler(dev, hotplug_trigger, hpd_ilk);

	if (de_iir & DE_AUX_CHANNEL_A)
		dp_aux_irq_handler(dev);

	if (de_iir & DE_GSE)
		intel_opregion_asle_intr(dev);

	if (de_iir & DE_POISON)
		DRM_ERROR("Poison interrupt\n");

	for_each_pipe(dev_priv, pipe) {
		if (de_iir & DE_PIPE_VBLANK(pipe) &&
		    intel_pipe_handle_vblank(dev, pipe))
			intel_check_page_flip(dev, pipe);

		if (de_iir & DE_PIPE_FIFO_UNDERRUN(pipe))
			intel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);

		if (de_iir & DE_PIPE_CRC_DONE(pipe))
			i9xx_pipe_crc_irq_handler(dev, pipe);

		/* plane/pipes map 1:1 on ilk+ */
		if (de_iir & DE_PLANE_FLIP_DONE(pipe)) {
			intel_prepare_page_flip(dev, pipe);
			intel_finish_page_flip_plane(dev, pipe);
		}
	}

	/* check event from PCH */
	if (de_iir & DE_PCH_EVENT) {
		u32 pch_iir = I915_READ(SDEIIR);

		if (HAS_PCH_CPT(dev))
			cpt_irq_handler(dev, pch_iir);
		else
			ibx_irq_handler(dev, pch_iir);

		/* should clear PCH hotplug event before clear CPU irq */
		I915_WRITE(SDEIIR, pch_iir);
	}

	if (IS_GEN5(dev) && de_iir & DE_PCU_EVENT)
		ironlake_rps_change_irq_handler(dev);
}

static void ivb_display_irq_handler(struct drm_device *dev, u32 de_iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe;
	u32 hotplug_trigger = de_iir & DE_DP_A_HOTPLUG_IVB;

	if (hotplug_trigger)
		ilk_hpd_irq_handler(dev, hotplug_trigger, hpd_ivb);

	if (de_iir & DE_ERR_INT_IVB)
		ivb_err_int_handler(dev);

	if (de_iir & DE_AUX_CHANNEL_A_IVB)
		dp_aux_irq_handler(dev);

	if (de_iir & DE_GSE_IVB)
		intel_opregion_asle_intr(dev);

	for_each_pipe(dev_priv, pipe) {
		if (de_iir & (DE_PIPE_VBLANK_IVB(pipe)) &&
		    intel_pipe_handle_vblank(dev, pipe))
			intel_check_page_flip(dev, pipe);

		/* plane/pipes map 1:1 on ilk+ */
		if (de_iir & DE_PLANE_FLIP_DONE_IVB(pipe)) {
			intel_prepare_page_flip(dev, pipe);
			intel_finish_page_flip_plane(dev, pipe);
		}
	}

	/* check event from PCH */
	if (!HAS_PCH_NOP(dev) && (de_iir & DE_PCH_EVENT_IVB)) {
		u32 pch_iir = I915_READ(SDEIIR);

		cpt_irq_handler(dev, pch_iir);

		/* clear PCH hotplug event before clear CPU irq */
		I915_WRITE(SDEIIR, pch_iir);
	}
}

/*
 * To handle irqs with the minimum potential races with fresh interrupts, we:
 * 1 - Disable Master Interrupt Control.
 * 2 - Find the source(s) of the interrupt.
 * 3 - Clear the Interrupt Identity bits (IIR).
 * 4 - Process the interrupt(s) that had bits set in the IIRs.
 * 5 - Re-enable Master Interrupt Control.
 */
static irqreturn_t ironlake_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 de_iir, gt_iir, de_ier, sde_ier = 0;
	irqreturn_t ret = IRQ_NONE;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	/* We get interrupts on unclaimed registers, so check for this before we
	 * do any I915_{READ,WRITE}. */
	intel_uncore_check_errors(dev);

	/* disable master interrupt before clearing iir  */
	de_ier = I915_READ(DEIER);
	I915_WRITE(DEIER, de_ier & ~DE_MASTER_IRQ_CONTROL);
	POSTING_READ(DEIER);

	/* Disable south interrupts. We'll only write to SDEIIR once, so further
	 * interrupts will will be stored on its back queue, and then we'll be
	 * able to process them after we restore SDEIER (as soon as we restore
	 * it, we'll get an interrupt if SDEIIR still has something to process
	 * due to its back queue). */
	if (!HAS_PCH_NOP(dev)) {
		sde_ier = I915_READ(SDEIER);
		I915_WRITE(SDEIER, 0);
		POSTING_READ(SDEIER);
	}

	/* Find, clear, then process each source of interrupt */

	gt_iir = I915_READ(GTIIR);
	if (gt_iir) {
		I915_WRITE(GTIIR, gt_iir);
		ret = IRQ_HANDLED;
		if (INTEL_INFO(dev)->gen >= 6)
			snb_gt_irq_handler(dev, dev_priv, gt_iir);
		else
			ilk_gt_irq_handler(dev, dev_priv, gt_iir);
	}

	de_iir = I915_READ(DEIIR);
	if (de_iir) {
		I915_WRITE(DEIIR, de_iir);
		ret = IRQ_HANDLED;
		if (INTEL_INFO(dev)->gen >= 7)
			ivb_display_irq_handler(dev, de_iir);
		else
			ilk_display_irq_handler(dev, de_iir);
	}

	if (INTEL_INFO(dev)->gen >= 6) {
		u32 pm_iir = I915_READ(GEN6_PMIIR);
		if (pm_iir) {
			I915_WRITE(GEN6_PMIIR, pm_iir);
			ret = IRQ_HANDLED;
			gen6_rps_irq_handler(dev_priv, pm_iir);
		}
	}

	I915_WRITE(DEIER, de_ier);
	POSTING_READ(DEIER);
	if (!HAS_PCH_NOP(dev)) {
		I915_WRITE(SDEIER, sde_ier);
		POSTING_READ(SDEIER);
	}

	return ret;
}

static void bxt_hpd_irq_handler(struct drm_device *dev, u32 hotplug_trigger,
				const u32 hpd[HPD_NUM_PINS])
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	u32 dig_hotplug_reg, pin_mask = 0, long_mask = 0;

	dig_hotplug_reg = I915_READ(PCH_PORT_HOTPLUG);
	I915_WRITE(PCH_PORT_HOTPLUG, dig_hotplug_reg);

	intel_get_hpd_pins(&pin_mask, &long_mask, hotplug_trigger,
			   dig_hotplug_reg, hpd,
			   bxt_port_hotplug_long_detect);

	intel_hpd_irq_handler(dev, pin_mask, long_mask);
}

static irqreturn_t gen8_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 master_ctl;
	irqreturn_t ret = IRQ_NONE;
	uint32_t tmp = 0;
	enum pipe pipe;
	u32 aux_mask = GEN8_AUX_CHANNEL_A;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	if (INTEL_INFO(dev_priv)->gen >= 9)
		aux_mask |=  GEN9_AUX_CHANNEL_B | GEN9_AUX_CHANNEL_C |
			GEN9_AUX_CHANNEL_D;

	master_ctl = I915_READ_FW(GEN8_MASTER_IRQ);
	master_ctl &= ~GEN8_MASTER_IRQ_CONTROL;
	if (!master_ctl)
		return IRQ_NONE;

	I915_WRITE_FW(GEN8_MASTER_IRQ, 0);

	/* Find, clear, then process each source of interrupt */

	ret = gen8_gt_irq_handler(dev_priv, master_ctl);

	if (master_ctl & GEN8_DE_MISC_IRQ) {
		tmp = I915_READ(GEN8_DE_MISC_IIR);
		if (tmp) {
			I915_WRITE(GEN8_DE_MISC_IIR, tmp);
			ret = IRQ_HANDLED;
			if (tmp & GEN8_DE_MISC_GSE)
				intel_opregion_asle_intr(dev);
			else
				DRM_ERROR("Unexpected DE Misc interrupt\n");
		}
		else
			DRM_ERROR("The master control interrupt lied (DE MISC)!\n");
	}

	if (master_ctl & GEN8_DE_PORT_IRQ) {
		tmp = I915_READ(GEN8_DE_PORT_IIR);
		if (tmp) {
			bool found = false;
			u32 hotplug_trigger = 0;

			if (IS_BROXTON(dev_priv))
				hotplug_trigger = tmp & BXT_DE_PORT_HOTPLUG_MASK;
			else if (IS_BROADWELL(dev_priv))
				hotplug_trigger = tmp & GEN8_PORT_DP_A_HOTPLUG;

			I915_WRITE(GEN8_DE_PORT_IIR, tmp);
			ret = IRQ_HANDLED;

			if (tmp & aux_mask) {
				dp_aux_irq_handler(dev);
				found = true;
			}

			if (hotplug_trigger) {
				if (IS_BROXTON(dev))
					bxt_hpd_irq_handler(dev, hotplug_trigger, hpd_bxt);
				else
					ilk_hpd_irq_handler(dev, hotplug_trigger, hpd_bdw);
				found = true;
			}

			if (IS_BROXTON(dev) && (tmp & BXT_DE_PORT_GMBUS)) {
				gmbus_irq_handler(dev);
				found = true;
			}

			if (!found)
				DRM_ERROR("Unexpected DE Port interrupt\n");
		}
		else
			DRM_ERROR("The master control interrupt lied (DE PORT)!\n");
	}

	for_each_pipe(dev_priv, pipe) {
		uint32_t pipe_iir, flip_done = 0, fault_errors = 0;

		if (!(master_ctl & GEN8_DE_PIPE_IRQ(pipe)))
			continue;

		pipe_iir = I915_READ(GEN8_DE_PIPE_IIR(pipe));
		if (pipe_iir) {
			ret = IRQ_HANDLED;
			I915_WRITE(GEN8_DE_PIPE_IIR(pipe), pipe_iir);

			if (pipe_iir & GEN8_PIPE_VBLANK &&
			    intel_pipe_handle_vblank(dev, pipe))
				intel_check_page_flip(dev, pipe);

			if (INTEL_INFO(dev_priv)->gen >= 9)
				flip_done = pipe_iir & GEN9_PIPE_PLANE1_FLIP_DONE;
			else
				flip_done = pipe_iir & GEN8_PIPE_PRIMARY_FLIP_DONE;

			if (flip_done) {
				intel_prepare_page_flip(dev, pipe);
				intel_finish_page_flip_plane(dev, pipe);
			}

			if (pipe_iir & GEN8_PIPE_CDCLK_CRC_DONE)
				hsw_pipe_crc_irq_handler(dev, pipe);

			if (pipe_iir & GEN8_PIPE_FIFO_UNDERRUN)
				intel_cpu_fifo_underrun_irq_handler(dev_priv,
								    pipe);


			if (INTEL_INFO(dev_priv)->gen >= 9)
				fault_errors = pipe_iir & GEN9_DE_PIPE_IRQ_FAULT_ERRORS;
			else
				fault_errors = pipe_iir & GEN8_DE_PIPE_IRQ_FAULT_ERRORS;

			if (fault_errors)
				DRM_ERROR("Fault errors on pipe %c\n: 0x%08x",
					  pipe_name(pipe),
					  pipe_iir & GEN8_DE_PIPE_IRQ_FAULT_ERRORS);
		} else
			DRM_ERROR("The master control interrupt lied (DE PIPE)!\n");
	}

	if (HAS_PCH_SPLIT(dev) && !HAS_PCH_NOP(dev) &&
	    master_ctl & GEN8_DE_PCH_IRQ) {
		/*
		 * FIXME(BDW): Assume for now that the new interrupt handling
		 * scheme also closed the SDE interrupt handling race we've seen
		 * on older pch-split platforms. But this needs testing.
		 */
		u32 pch_iir = I915_READ(SDEIIR);
		if (pch_iir) {
			I915_WRITE(SDEIIR, pch_iir);
			ret = IRQ_HANDLED;

			if (HAS_PCH_SPT(dev_priv) || HAS_PCH_KBP(dev_priv))
				spt_irq_handler(dev, pch_iir);
			else
				cpt_irq_handler(dev, pch_iir);
		} else {
			/*
			 * Like on previous PCH there seems to be something
			 * fishy going on with forwarding PCH interrupts.
			 */
			DRM_DEBUG_DRIVER("The master control interrupt lied (SDE)!\n");
		}
	}

	I915_WRITE_FW(GEN8_MASTER_IRQ, GEN8_MASTER_IRQ_CONTROL);
	POSTING_READ_FW(GEN8_MASTER_IRQ);

	return ret;
}

static void i915_error_wake_up(struct drm_i915_private *dev_priv,
			       bool reset_completed)
{
	struct intel_engine_cs *ring;
	int i;

	/*
	 * Notify all waiters for GPU completion events that reset state has
	 * been changed, and that they need to restart their wait after
	 * checking for potential errors (and bail out to drop locks if there is
	 * a gpu reset pending so that i915_error_work_func can acquire them).
	 */

	/* Wake up __wait_seqno, potentially holding dev->struct_mutex. */
	for_each_ring(ring, dev_priv, i)
		wake_up_all(&ring->irq_queue);

	/* Wake up intel_crtc_wait_for_pending_flips, holding crtc->mutex. */
	wake_up_all(&dev_priv->pending_flip_queue);

	/*
	 * Signal tasks blocked in i915_gem_wait_for_error that the pending
	 * reset state is cleared.
	 */
	if (reset_completed)
		wake_up_all(&dev_priv->gpu_error.reset_queue);
}

/**
 * i915_reset_and_wakeup - do process context error handling work
 * @@dev: drm device
 *
 * Fire an error uevent so userspace can see that a hang or error
 * was detected.
 */
static void i915_reset_and_wakeup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct i915_gpu_error *error = &dev_priv->gpu_error;
#ifdef __linux__
	char *error_event[] = { I915_ERROR_UEVENT "=1", NULL };
	char *reset_event[] = { I915_RESET_UEVENT "=1", NULL };
	char *reset_done_event[] = { I915_ERROR_UEVENT "=0", NULL };
#endif
	int ret;

#ifdef __linux__
	kobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE, error_event);
#endif

	/*
	 * Note that there's only one work item which does gpu resets, so we
	 * need not worry about concurrent gpu resets potentially incrementing
	 * error->reset_counter twice. We only need to take care of another
	 * racing irq/hangcheck declaring the gpu dead for a second time. A
	 * quick check for that is good enough: schedule_work ensures the
	 * correct ordering between hang detection and this work item, and since
	 * the reset in-progress bit is only ever set by code outside of this
	 * work we don't need to worry about any other races.
	 */
	if (i915_reset_in_progress(error) && !i915_terminally_wedged(error)) {
		DRM_DEBUG_DRIVER("resetting chip\n");
#ifdef __linux__
		kobject_uevent_env(&dev->primary->kdev->kobj, KOBJ_CHANGE,
				   reset_event);
#endif

		/*
		 * In most cases it's guaranteed that we get here with an RPM
		 * reference held, for example because there is a pending GPU
		 * request that won't finish until the reset is done. This
		 * isn't the case at least when we get here by doing a
		 * simulated reset via debugs, so get an RPM reference.
		 */
		intel_runtime_pm_get(dev_priv);

		intel_prepare_reset(dev);

		/*
		 * All state reset _must_ be completed before we update the
		 * reset counter, for otherwise waiters might miss the reset
		 * pending state and not properly drop locks, resulting in
		 * deadlocks with the reset work.
		 */
		ret = i915_reset(dev);

		intel_finish_reset(dev);

		intel_runtime_pm_put(dev_priv);

		if (ret == 0) {
			/*
			 * After all the gem state is reset, increment the reset
			 * counter and wake up everyone waiting for the reset to
			 * complete.
			 *
			 * Since unlock operations are a one-sided barrier only,
			 * we need to insert a barrier here to order any seqno
			 * updates before
			 * the counter increment.
			 */
			smp_mb__before_atomic();
			atomic_inc(&dev_priv->gpu_error.reset_counter);

#ifdef __linux__
			kobject_uevent_env(&dev->primary->kdev->kobj,
					   KOBJ_CHANGE, reset_done_event);
#endif
		} else {
			atomic_or(I915_WEDGED, &error->reset_counter);
		}

		/*
		 * Note: The wake_up also serves as a memory barrier so that
		 * waiters see the update value of the reset counter atomic_t.
		 */
		i915_error_wake_up(dev_priv, true);
	}
}

static void i915_report_and_clear_eir(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t instdone[I915_NUM_INSTDONE_REG];
	u32 eir = I915_READ(EIR);
	int pipe, i;

	if (!eir)
		return;

	pr_err("render error detected, EIR: 0x%08x\n", eir);

	i915_get_extra_instdone(dev, instdone);

	if (IS_G4X(dev)) {
		if (eir & (GM45_ERROR_MEM_PRIV | GM45_ERROR_CP_PRIV)) {
			u32 ipeir = I915_READ(IPEIR_I965);

			pr_err("  IPEIR: 0x%08x\n", I915_READ(IPEIR_I965));
			pr_err("  IPEHR: 0x%08x\n", I915_READ(IPEHR_I965));
			for (i = 0; i < ARRAY_SIZE(instdone); i++)
				pr_err("  INSTDONE_%d: 0x%08x\n", i, instdone[i]);
			pr_err("  INSTPS: 0x%08x\n", I915_READ(INSTPS));
			pr_err("  ACTHD: 0x%08x\n", I915_READ(ACTHD_I965));
			I915_WRITE(IPEIR_I965, ipeir);
			POSTING_READ(IPEIR_I965);
		}
		if (eir & GM45_ERROR_PAGE_TABLE) {
			u32 pgtbl_err = I915_READ(PGTBL_ER);
			pr_err("page table error\n");
			pr_err("  PGTBL_ER: 0x%08x\n", pgtbl_err);
			I915_WRITE(PGTBL_ER, pgtbl_err);
			POSTING_READ(PGTBL_ER);
		}
	}

	if (!IS_GEN2(dev)) {
		if (eir & I915_ERROR_PAGE_TABLE) {
			u32 pgtbl_err = I915_READ(PGTBL_ER);
			pr_err("page table error\n");
			pr_err("  PGTBL_ER: 0x%08x\n", pgtbl_err);
			I915_WRITE(PGTBL_ER, pgtbl_err);
			POSTING_READ(PGTBL_ER);
		}
	}

	if (eir & I915_ERROR_MEMORY_REFRESH) {
		pr_err("memory refresh error:\n");
		for_each_pipe(dev_priv, pipe)
			pr_err("pipe %c stat: 0x%08x\n",
			       pipe_name(pipe), I915_READ(PIPESTAT(pipe)));
		/* pipestat has already been acked */
	}
	if (eir & I915_ERROR_INSTRUCTION) {
		pr_err("instruction error\n");
		pr_err("  INSTPM: 0x%08x\n", I915_READ(INSTPM));
		for (i = 0; i < ARRAY_SIZE(instdone); i++)
			pr_err("  INSTDONE_%d: 0x%08x\n", i, instdone[i]);
		if (INTEL_INFO(dev)->gen < 4) {
			u32 ipeir = I915_READ(IPEIR);

			pr_err("  IPEIR: 0x%08x\n", I915_READ(IPEIR));
			pr_err("  IPEHR: 0x%08x\n", I915_READ(IPEHR));
			pr_err("  ACTHD: 0x%08x\n", I915_READ(ACTHD));
			I915_WRITE(IPEIR, ipeir);
			POSTING_READ(IPEIR);
		} else {
			u32 ipeir = I915_READ(IPEIR_I965);

			pr_err("  IPEIR: 0x%08x\n", I915_READ(IPEIR_I965));
			pr_err("  IPEHR: 0x%08x\n", I915_READ(IPEHR_I965));
			pr_err("  INSTPS: 0x%08x\n", I915_READ(INSTPS));
			pr_err("  ACTHD: 0x%08x\n", I915_READ(ACTHD_I965));
			I915_WRITE(IPEIR_I965, ipeir);
			POSTING_READ(IPEIR_I965);
		}
	}

	I915_WRITE(EIR, eir);
	POSTING_READ(EIR);
	eir = I915_READ(EIR);
	if (eir) {
		/*
		 * some errors might have become stuck,
		 * mask them.
		 */
		DRM_ERROR("EIR stuck: 0x%08x, masking\n", eir);
		I915_WRITE(EMR, I915_READ(EMR) | eir);
		I915_WRITE(IIR, I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);
	}
}

/**
 * i915_handle_error - handle a gpu error
 * @@dev: drm device
 *
 * Do some basic checking of register state at error time and
 * dump it to the syslog.  Also call i915_capture_error_state() to make
 * sure we get a record and make it available in debugfs.  Fire a uevent
 * so userspace knows something bad happened (should trigger collection
 * of a ring dump etc.).
 */
void i915_handle_error(struct drm_device *dev, bool wedged,
		       const char *fmt, ...)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	va_list args;
	char error_msg[80];

	va_start(args, fmt);
	vsnprintf(error_msg, sizeof(error_msg), fmt, args);
	va_end(args);

	i915_capture_error_state(dev, wedged, error_msg);
	i915_report_and_clear_eir(dev);

	if (wedged) {
		atomic_or(I915_RESET_IN_PROGRESS_FLAG,
				&dev_priv->gpu_error.reset_counter);

		/*
		 * Wakeup waiting processes so that the reset function
		 * i915_reset_and_wakeup doesn't deadlock trying to grab
		 * various locks. By bumping the reset counter first, the woken
		 * processes will see a reset in progress and back off,
		 * releasing their locks and then wait for the reset completion.
		 * We must do this for _all_ gpu waiters that might hold locks
		 * that the reset work needs to acquire.
		 *
		 * Note: The wake_up serves as the required memory barrier to
		 * ensure that the waiters see the updated value of the reset
		 * counter atomic_t.
		 */
		i915_error_wake_up(dev_priv, false);
	}

	i915_reset_and_wakeup(dev);
}

/* Called from drm generic code, passed 'crtc' which
 * we use as a pipe index
 */
static int i915_enable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	if (INTEL_INFO(dev)->gen >= 4)
		i915_enable_pipestat(dev_priv, pipe,
				     PIPE_START_VBLANK_INTERRUPT_STATUS);
	else
		i915_enable_pipestat(dev_priv, pipe,
				     PIPE_VBLANK_INTERRUPT_STATUS);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);

	return 0;
}

static int ironlake_enable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;
	uint32_t bit = (INTEL_INFO(dev)->gen >= 7) ? DE_PIPE_VBLANK_IVB(pipe) :
						     DE_PIPE_VBLANK(pipe);

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	ironlake_enable_display_irq(dev_priv, bit);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);

	return 0;
}

static int valleyview_enable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_enable_pipestat(dev_priv, pipe,
			     PIPE_START_VBLANK_INTERRUPT_STATUS);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);

	return 0;
}

static int gen8_enable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	dev_priv->de_irq_mask[pipe] &= ~GEN8_PIPE_VBLANK;
	I915_WRITE(GEN8_DE_PIPE_IMR(pipe), dev_priv->de_irq_mask[pipe]);
	POSTING_READ(GEN8_DE_PIPE_IMR(pipe));
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
	return 0;
}

/* Called from drm generic code, passed 'crtc' which
 * we use as a pipe index
 */
static void i915_disable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_disable_pipestat(dev_priv, pipe,
			      PIPE_VBLANK_INTERRUPT_STATUS |
			      PIPE_START_VBLANK_INTERRUPT_STATUS);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}

static void ironlake_disable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;
	uint32_t bit = (INTEL_INFO(dev)->gen >= 7) ? DE_PIPE_VBLANK_IVB(pipe) :
						     DE_PIPE_VBLANK(pipe);

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	ironlake_disable_display_irq(dev_priv, bit);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}

static void valleyview_disable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_disable_pipestat(dev_priv, pipe,
			      PIPE_START_VBLANK_INTERRUPT_STATUS);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}

static void gen8_disable_vblank(struct drm_device *dev, unsigned int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	dev_priv->de_irq_mask[pipe] |= GEN8_PIPE_VBLANK;
	I915_WRITE(GEN8_DE_PIPE_IMR(pipe), dev_priv->de_irq_mask[pipe]);
	POSTING_READ(GEN8_DE_PIPE_IMR(pipe));
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}

static bool
ring_idle(struct intel_engine_cs *ring, u32 seqno)
{
	return (list_empty(&ring->request_list) ||
		i915_seqno_passed(seqno, ring->last_submitted_seqno));
}

static bool
ipehr_is_semaphore_wait(struct drm_device *dev, u32 ipehr)
{
	if (INTEL_INFO(dev)->gen >= 8) {
		return (ipehr >> 23) == 0x1c;
	} else {
		ipehr &= ~MI_SEMAPHORE_SYNC_MASK;
		return ipehr == (MI_SEMAPHORE_MBOX | MI_SEMAPHORE_COMPARE |
				 MI_SEMAPHORE_REGISTER);
	}
}

static struct intel_engine_cs *
semaphore_wait_to_signaller_ring(struct intel_engine_cs *ring, u32 ipehr, u64 offset)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	struct intel_engine_cs *signaller;
	int i;

	if (INTEL_INFO(dev_priv->dev)->gen >= 8) {
		for_each_ring(signaller, dev_priv, i) {
			if (ring == signaller)
				continue;

			if (offset == signaller->semaphore.signal_ggtt[ring->id])
				return signaller;
		}
	} else {
		u32 sync_bits = ipehr & MI_SEMAPHORE_SYNC_MASK;

		for_each_ring(signaller, dev_priv, i) {
			if(ring == signaller)
				continue;

			if (sync_bits == signaller->semaphore.mbox.wait[ring->id])
				return signaller;
		}
	}

	DRM_ERROR("No signaller ring found for ring %i, ipehr 0x%08x, offset 0x%016llx\n",
		  ring->id, ipehr, offset);

	return NULL;
}

static struct intel_engine_cs *
semaphore_waits_for(struct intel_engine_cs *ring, u32 *seqno)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	u32 cmd, ipehr, head;
	u64 offset = 0;
	int i, backwards;

	/*
	 * This function does not support execlist mode - any attempt to
	 * proceed further into this function will result in a kernel panic
	 * when dereferencing ring->buffer, which is not set up in execlist
	 * mode.
	 *
	 * The correct way of doing it would be to derive the currently
	 * executing ring buffer from the current context, which is derived
	 * from the currently running request. Unfortunately, to get the
	 * current request we would have to grab the struct_mutex before doing
	 * anything else, which would be ill-advised since some other thread
	 * might have grabbed it already and managed to hang itself, causing
	 * the hang checker to deadlock.
	 *
	 * Therefore, this function does not support execlist mode in its
	 * current form. Just return NULL and move on.
	 */
	if (ring->buffer == NULL)
		return NULL;

	ipehr = I915_READ(RING_IPEHR(ring->mmio_base));
	if (!ipehr_is_semaphore_wait(ring->dev, ipehr))
		return NULL;

	/*
	 * HEAD is likely pointing to the dword after the actual command,
	 * so scan backwards until we find the MBOX. But limit it to just 3
	 * or 4 dwords depending on the semaphore wait command size.
	 * Note that we don't care about ACTHD here since that might
	 * point at at batch, and semaphores are always emitted into the
	 * ringbuffer itself.
	 */
	head = I915_READ_HEAD(ring) & HEAD_ADDR;
	backwards = (INTEL_INFO(ring->dev)->gen >= 8) ? 5 : 4;

	for (i = backwards; i; --i) {
		/*
		 * Be paranoid and presume the hw has gone off into the wild -
		 * our ring is smaller than what the hardware (and hence
		 * HEAD_ADDR) allows. Also handles wrap-around.
		 */
		head &= ring->buffer->size - 1;

		/* This here seems to blow up */
		cmd = ioread32(ring->buffer->virtual_start + head);
		if (cmd == ipehr)
			break;

		head -= 4;
	}

	if (!i)
		return NULL;

	*seqno = ioread32(ring->buffer->virtual_start + head + 4) + 1;
	if (INTEL_INFO(ring->dev)->gen >= 8) {
		offset = ioread32(ring->buffer->virtual_start + head + 12);
		offset <<= 32;
		offset = ioread32(ring->buffer->virtual_start + head + 8);
	}
	return semaphore_wait_to_signaller_ring(ring, ipehr, offset);
}

static int semaphore_passed(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	struct intel_engine_cs *signaller;
	u32 seqno;

	ring->hangcheck.deadlock++;

	signaller = semaphore_waits_for(ring, &seqno);
	if (signaller == NULL)
		return -1;

	/* Prevent pathological recursion due to driver bugs */
	if (signaller->hangcheck.deadlock >= I915_NUM_RINGS)
		return -1;

	if (i915_seqno_passed(signaller->get_seqno(signaller, false), seqno))
		return 1;

	/* cursory check for an unkickable deadlock */
	if (I915_READ_CTL(signaller) & RING_WAIT_SEMAPHORE &&
	    semaphore_passed(signaller) < 0)
		return -1;

	return 0;
}

static void semaphore_clear_deadlocks(struct drm_i915_private *dev_priv)
{
	struct intel_engine_cs *ring;
	int i;

	for_each_ring(ring, dev_priv, i)
		ring->hangcheck.deadlock = 0;
}

static enum intel_ring_hangcheck_action
ring_stuck(struct intel_engine_cs *ring, u64 acthd)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp;

	if (acthd != ring->hangcheck.acthd) {
		if (acthd > ring->hangcheck.max_acthd) {
			ring->hangcheck.max_acthd = acthd;
			return HANGCHECK_ACTIVE;
		}

		return HANGCHECK_ACTIVE_LOOP;
	}

	if (IS_GEN2(dev))
		return HANGCHECK_HUNG;

	/* Is the chip hanging on a WAIT_FOR_EVENT?
	 * If so we can simply poke the RB_WAIT bit
	 * and break the hang. This should work on
	 * all but the second generation chipsets.
	 */
	tmp = I915_READ_CTL(ring);
	if (tmp & RING_WAIT) {
		i915_handle_error(dev, false,
				  "Kicking stuck wait on %s",
				  ring->name);
		I915_WRITE_CTL(ring, tmp);
		return HANGCHECK_KICK;
	}

	if (INTEL_INFO(dev)->gen >= 6 && tmp & RING_WAIT_SEMAPHORE) {
		switch (semaphore_passed(ring)) {
		default:
			return HANGCHECK_HUNG;
		case 1:
			i915_handle_error(dev, false,
					  "Kicking stuck semaphore on %s",
					  ring->name);
			I915_WRITE_CTL(ring, tmp);
			return HANGCHECK_KICK;
		case 0:
			return HANGCHECK_WAIT;
		}
	}

	return HANGCHECK_HUNG;
}

/*
 * This is called when the chip hasn't reported back with completed
 * batchbuffers in a long time. We keep track per ring seqno progress and
 * if there are no progress, hangcheck score for that ring is increased.
 * Further, acthd is inspected to see if the ring is stuck. On stuck case
 * we kick the ring. If we see no progress on three subsequent calls
 * we assume chip is wedged and try to fix it by resetting the chip.
 */
static void i915_hangcheck_elapsed(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, typeof(*dev_priv),
			     gpu_error.hangcheck_work.work);
	struct drm_device *dev = dev_priv->dev;
	struct intel_engine_cs *ring;
	int i;
	int busy_count = 0, rings_hung = 0;
	bool stuck[I915_NUM_RINGS] = { 0 };
#define BUSY 1
#define KICK 5
#define HUNG 20

	if (!i915.enable_hangcheck)
		return;

	for_each_ring(ring, dev_priv, i) {
		u64 acthd;
		u32 seqno;
		bool busy = true;

		semaphore_clear_deadlocks(dev_priv);

		seqno = ring->get_seqno(ring, false);
		acthd = intel_ring_get_active_head(ring);

		if (ring->hangcheck.seqno == seqno) {
			if (ring_idle(ring, seqno)) {
				ring->hangcheck.action = HANGCHECK_IDLE;

				if (waitqueue_active(&ring->irq_queue)) {
					/* Issue a wake-up to catch stuck h/w. */
					if (!test_and_set_bit(ring->id, &dev_priv->gpu_error.missed_irq_rings)) {
						if (!(dev_priv->gpu_error.test_irq_rings & intel_ring_flag(ring)))
							DRM_ERROR("Hangcheck timer elapsed... %s idle\n",
								  ring->name);
						else
							DRM_INFO("Fake missed irq on %s\n",
								 ring->name);
						wake_up_all(&ring->irq_queue);
					}
					/* Safeguard against driver failure */
					ring->hangcheck.score += BUSY;
				} else
					busy = false;
			} else {
				/* We always increment the hangcheck score
				 * if the ring is busy and still processing
				 * the same request, so that no single request
				 * can run indefinitely (such as a chain of
				 * batches). The only time we do not increment
				 * the hangcheck score on this ring, if this
				 * ring is in a legitimate wait for another
				 * ring. In that case the waiting ring is a
				 * victim and we want to be sure we catch the
				 * right culprit. Then every time we do kick
				 * the ring, add a small increment to the
				 * score so that we can catch a batch that is
				 * being repeatedly kicked and so responsible
				 * for stalling the machine.
				 */
				ring->hangcheck.action = ring_stuck(ring,
								    acthd);

				switch (ring->hangcheck.action) {
				case HANGCHECK_IDLE:
				case HANGCHECK_WAIT:
				case HANGCHECK_ACTIVE:
					break;
				case HANGCHECK_ACTIVE_LOOP:
					ring->hangcheck.score += BUSY;
					break;
				case HANGCHECK_KICK:
					ring->hangcheck.score += KICK;
					break;
				case HANGCHECK_HUNG:
					ring->hangcheck.score += HUNG;
					stuck[i] = true;
					break;
				}
			}
		} else {
			ring->hangcheck.action = HANGCHECK_ACTIVE;

			/* Gradually reduce the count so that we catch DoS
			 * attempts across multiple batches.
			 */
			if (ring->hangcheck.score > 0)
				ring->hangcheck.score--;

			ring->hangcheck.acthd = ring->hangcheck.max_acthd = 0;
		}

		ring->hangcheck.seqno = seqno;
		ring->hangcheck.acthd = acthd;
		busy_count += busy;
	}

	for_each_ring(ring, dev_priv, i) {
		if (ring->hangcheck.score >= HANGCHECK_SCORE_RING_HUNG) {
			DRM_INFO("%s on %s\n",
				 stuck[i] ? "stuck" : "no progress",
				 ring->name);
			rings_hung++;
		}
	}

	if (rings_hung)
		return i915_handle_error(dev, true, "Ring hung");

	if (busy_count)
		/* Reset timer case chip hangs without another request
		 * being added */
		i915_queue_hangcheck(dev);
}

void i915_queue_hangcheck(struct drm_device *dev)
{
	struct i915_gpu_error *e = &to_i915(dev)->gpu_error;

	if (!i915.enable_hangcheck)
		return;

	/* Don't continually defer the hangcheck so that it is always run at
	 * least once after work has been scheduled on any ring. Otherwise,
	 * we will ignore a hung ring if a second ring is kept busy.
	 */

	queue_delayed_work(e->hangcheck_wq, &e->hangcheck_work,
			   round_jiffies_up_relative(DRM_I915_HANGCHECK_JIFFIES));
}

static void ibx_irq_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (HAS_PCH_NOP(dev))
		return;

	GEN5_IRQ_RESET(SDE);

	if (HAS_PCH_CPT(dev) || HAS_PCH_LPT(dev))
		I915_WRITE(SERR_INT, 0xffffffff);
}

/*
 * SDEIER is also touched by the interrupt handler to work around missed PCH
 * interrupts. Hence we can't update it after the interrupt handler is enabled -
 * instead we unconditionally enable all PCH interrupt sources here, but then
 * only unmask them as needed with SDEIMR.
 *
 * This function needs to be called before interrupts are enabled.
 */
static void ibx_irq_pre_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (HAS_PCH_NOP(dev))
		return;

	WARN_ON(I915_READ(SDEIER) != 0);
	I915_WRITE(SDEIER, 0xffffffff);
	POSTING_READ(SDEIER);
}

static void gen5_gt_irq_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	GEN5_IRQ_RESET(GT);
	if (INTEL_INFO(dev)->gen >= 6)
		GEN5_IRQ_RESET(GEN6_PM);
}

/* drm_dma.h hooks
*/
static void ironlake_irq_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE(HWSTAM, 0xffffffff);

	GEN5_IRQ_RESET(DE);
	if (IS_GEN7(dev))
		I915_WRITE(GEN7_ERR_INT, 0xffffffff);

	gen5_gt_irq_reset(dev);

	ibx_irq_reset(dev);
}

static void vlv_display_irq_reset(struct drm_i915_private *dev_priv)
{
	enum pipe pipe;

	i915_hotplug_interrupt_update(dev_priv, 0xFFFFFFFF, 0);
	I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));

	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), 0xffff);

	GEN5_IRQ_RESET(VLV_);
}

static void valleyview_irq_preinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* VLV magic */
	I915_WRITE(VLV_IMR, 0);
	I915_WRITE(RING_IMR(RENDER_RING_BASE), 0);
	I915_WRITE(RING_IMR(GEN6_BSD_RING_BASE), 0);
	I915_WRITE(RING_IMR(BLT_RING_BASE), 0);

	gen5_gt_irq_reset(dev);

	I915_WRITE(DPINVGTT, DPINVGTT_STATUS_MASK);

	vlv_display_irq_reset(dev_priv);
}

static void gen8_gt_irq_reset(struct drm_i915_private *dev_priv)
{
	GEN8_IRQ_RESET_NDX(GT, 0);
	GEN8_IRQ_RESET_NDX(GT, 1);
	GEN8_IRQ_RESET_NDX(GT, 2);
	GEN8_IRQ_RESET_NDX(GT, 3);
}

static void gen8_irq_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	I915_WRITE(GEN8_MASTER_IRQ, 0);
	POSTING_READ(GEN8_MASTER_IRQ);

	gen8_gt_irq_reset(dev_priv);

	for_each_pipe(dev_priv, pipe)
		if (intel_display_power_is_enabled(dev_priv,
						   POWER_DOMAIN_PIPE(pipe)))
			GEN8_IRQ_RESET_NDX(DE_PIPE, pipe);

	GEN5_IRQ_RESET(GEN8_DE_PORT_);
	GEN5_IRQ_RESET(GEN8_DE_MISC_);
	GEN5_IRQ_RESET(GEN8_PCU_);

	if (HAS_PCH_SPLIT(dev))
		ibx_irq_reset(dev);
}

void gen8_irq_power_well_post_enable(struct drm_i915_private *dev_priv,
				     unsigned int pipe_mask)
{
	uint32_t extra_ier = GEN8_PIPE_VBLANK | GEN8_PIPE_FIFO_UNDERRUN;

	spin_lock_irq(&dev_priv->irq_lock);
	if (pipe_mask & 1 << PIPE_A)
		GEN8_IRQ_INIT_NDX(DE_PIPE, PIPE_A,
				  dev_priv->de_irq_mask[PIPE_A],
				  ~dev_priv->de_irq_mask[PIPE_A] | extra_ier);
	if (pipe_mask & 1 << PIPE_B)
		GEN8_IRQ_INIT_NDX(DE_PIPE, PIPE_B,
				  dev_priv->de_irq_mask[PIPE_B],
				  ~dev_priv->de_irq_mask[PIPE_B] | extra_ier);
	if (pipe_mask & 1 << PIPE_C)
		GEN8_IRQ_INIT_NDX(DE_PIPE, PIPE_C,
				  dev_priv->de_irq_mask[PIPE_C],
				  ~dev_priv->de_irq_mask[PIPE_C] | extra_ier);
	spin_unlock_irq(&dev_priv->irq_lock);
}

static void cherryview_irq_preinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE(GEN8_MASTER_IRQ, 0);
	POSTING_READ(GEN8_MASTER_IRQ);

	gen8_gt_irq_reset(dev_priv);

	GEN5_IRQ_RESET(GEN8_PCU_);

	I915_WRITE(DPINVGTT, DPINVGTT_STATUS_MASK_CHV);

	vlv_display_irq_reset(dev_priv);
}

static u32 intel_hpd_enabled_irqs(struct drm_device *dev,
				  const u32 hpd[HPD_NUM_PINS])
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct intel_encoder *encoder;
	u32 enabled_irqs = 0;

	for_each_intel_encoder(dev, encoder)
		if (dev_priv->hotplug.stats[encoder->hpd_pin].state == HPD_ENABLED)
			enabled_irqs |= hpd[encoder->hpd_pin];

	return enabled_irqs;
}

static void ibx_hpd_irq_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_irqs, hotplug, enabled_irqs;

	if (HAS_PCH_IBX(dev)) {
		hotplug_irqs = SDE_HOTPLUG_MASK;
		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_ibx);
	} else {
		hotplug_irqs = SDE_HOTPLUG_MASK_CPT;
		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_cpt);
	}

	ibx_display_interrupt_update(dev_priv, hotplug_irqs, enabled_irqs);

	/*
	 * Enable digital hotplug on the PCH, and configure the DP short pulse
	 * duration to 2ms (which is the minimum in the Display Port spec).
	 * The pulse duration bits are reserved on LPT+.
	 */
	hotplug = I915_READ(PCH_PORT_HOTPLUG);
	hotplug &= ~(PORTD_PULSE_DURATION_MASK|PORTC_PULSE_DURATION_MASK|PORTB_PULSE_DURATION_MASK);
	hotplug |= PORTD_HOTPLUG_ENABLE | PORTD_PULSE_DURATION_2ms;
	hotplug |= PORTC_HOTPLUG_ENABLE | PORTC_PULSE_DURATION_2ms;
	hotplug |= PORTB_HOTPLUG_ENABLE | PORTB_PULSE_DURATION_2ms;
	/*
	 * When CPU and PCH are on the same package, port A
	 * HPD must be enabled in both north and south.
	 */
	if (HAS_PCH_LPT_LP(dev))
		hotplug |= PORTA_HOTPLUG_ENABLE;
	I915_WRITE(PCH_PORT_HOTPLUG, hotplug);
}

static void spt_hpd_irq_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_irqs, hotplug, enabled_irqs;

	hotplug_irqs = SDE_HOTPLUG_MASK_SPT;
	enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_spt);

	ibx_display_interrupt_update(dev_priv, hotplug_irqs, enabled_irqs);

	/* Enable digital hotplug on the PCH */
	hotplug = I915_READ(PCH_PORT_HOTPLUG);
	hotplug |= PORTD_HOTPLUG_ENABLE | PORTC_HOTPLUG_ENABLE |
		PORTB_HOTPLUG_ENABLE | PORTA_HOTPLUG_ENABLE;
	I915_WRITE(PCH_PORT_HOTPLUG, hotplug);

	hotplug = I915_READ(PCH_PORT_HOTPLUG2);
	hotplug |= PORTE_HOTPLUG_ENABLE;
	I915_WRITE(PCH_PORT_HOTPLUG2, hotplug);
}

static void ilk_hpd_irq_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_irqs, hotplug, enabled_irqs;

	if (INTEL_INFO(dev)->gen >= 8) {
		hotplug_irqs = GEN8_PORT_DP_A_HOTPLUG;
		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_bdw);

		bdw_update_port_irq(dev_priv, hotplug_irqs, enabled_irqs);
	} else if (INTEL_INFO(dev)->gen >= 7) {
		hotplug_irqs = DE_DP_A_HOTPLUG_IVB;
		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_ivb);

		ilk_update_display_irq(dev_priv, hotplug_irqs, enabled_irqs);
	} else {
		hotplug_irqs = DE_DP_A_HOTPLUG;
		enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_ilk);

		ilk_update_display_irq(dev_priv, hotplug_irqs, enabled_irqs);
	}

	/*
	 * Enable digital hotplug on the CPU, and configure the DP short pulse
	 * duration to 2ms (which is the minimum in the Display Port spec)
	 * The pulse duration bits are reserved on HSW+.
	 */
	hotplug = I915_READ(DIGITAL_PORT_HOTPLUG_CNTRL);
	hotplug &= ~DIGITAL_PORTA_PULSE_DURATION_MASK;
	hotplug |= DIGITAL_PORTA_HOTPLUG_ENABLE | DIGITAL_PORTA_PULSE_DURATION_2ms;
	I915_WRITE(DIGITAL_PORT_HOTPLUG_CNTRL, hotplug);

	ibx_hpd_irq_setup(dev);
}

static void bxt_hpd_irq_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_irqs, hotplug, enabled_irqs;

	enabled_irqs = intel_hpd_enabled_irqs(dev, hpd_bxt);
	hotplug_irqs = BXT_DE_PORT_HOTPLUG_MASK;

	bdw_update_port_irq(dev_priv, hotplug_irqs, enabled_irqs);

	hotplug = I915_READ(PCH_PORT_HOTPLUG);
	hotplug |= PORTC_HOTPLUG_ENABLE | PORTB_HOTPLUG_ENABLE |
		PORTA_HOTPLUG_ENABLE;
	I915_WRITE(PCH_PORT_HOTPLUG, hotplug);
}

static void ibx_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 mask;

	if (HAS_PCH_NOP(dev))
		return;

	if (HAS_PCH_IBX(dev))
		mask = SDE_GMBUS | SDE_AUX_MASK | SDE_POISON;
	else
		mask = SDE_GMBUS_CPT | SDE_AUX_MASK_CPT;

	gen5_assert_iir_is_zero(dev_priv, SDEIIR);
	I915_WRITE(SDEIMR, ~mask);
}

static void gen5_gt_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pm_irqs, gt_irqs;

	pm_irqs = gt_irqs = 0;

	dev_priv->gt_irq_mask = ~0;
	if (HAS_L3_DPF(dev)) {
		/* L3 parity interrupt is always unmasked. */
		dev_priv->gt_irq_mask = ~GT_PARITY_ERROR(dev);
		gt_irqs |= GT_PARITY_ERROR(dev);
	}

	gt_irqs |= GT_RENDER_USER_INTERRUPT;
	if (IS_GEN5(dev)) {
		gt_irqs |= GT_RENDER_PIPECTL_NOTIFY_INTERRUPT |
			   ILK_BSD_USER_INTERRUPT;
	} else {
		gt_irqs |= GT_BLT_USER_INTERRUPT | GT_BSD_USER_INTERRUPT;
	}

	GEN5_IRQ_INIT(GT, dev_priv->gt_irq_mask, gt_irqs);

	if (INTEL_INFO(dev)->gen >= 6) {
		/*
		 * RPS interrupts will get enabled/disabled on demand when RPS
		 * itself is enabled/disabled.
		 */
		if (HAS_VEBOX(dev))
			pm_irqs |= PM_VEBOX_USER_INTERRUPT;

		dev_priv->pm_irq_mask = 0xffffffff;
		GEN5_IRQ_INIT(GEN6_PM, dev_priv->pm_irq_mask, pm_irqs);
	}
}

static int ironlake_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 display_mask, extra_mask;

	if (INTEL_INFO(dev)->gen >= 7) {
		display_mask = (DE_MASTER_IRQ_CONTROL | DE_GSE_IVB |
				DE_PCH_EVENT_IVB | DE_PLANEC_FLIP_DONE_IVB |
				DE_PLANEB_FLIP_DONE_IVB |
				DE_PLANEA_FLIP_DONE_IVB | DE_AUX_CHANNEL_A_IVB);
		extra_mask = (DE_PIPEC_VBLANK_IVB | DE_PIPEB_VBLANK_IVB |
			      DE_PIPEA_VBLANK_IVB | DE_ERR_INT_IVB |
			      DE_DP_A_HOTPLUG_IVB);
	} else {
		display_mask = (DE_MASTER_IRQ_CONTROL | DE_GSE | DE_PCH_EVENT |
				DE_PLANEA_FLIP_DONE | DE_PLANEB_FLIP_DONE |
				DE_AUX_CHANNEL_A |
				DE_PIPEB_CRC_DONE | DE_PIPEA_CRC_DONE |
				DE_POISON);
		extra_mask = (DE_PIPEA_VBLANK | DE_PIPEB_VBLANK | DE_PCU_EVENT |
			      DE_PIPEB_FIFO_UNDERRUN | DE_PIPEA_FIFO_UNDERRUN |
			      DE_DP_A_HOTPLUG);
	}

	dev_priv->irq_mask = ~display_mask;

	I915_WRITE(HWSTAM, 0xeffe);

	ibx_irq_pre_postinstall(dev);

	GEN5_IRQ_INIT(DE, dev_priv->irq_mask, display_mask | extra_mask);

	gen5_gt_irq_postinstall(dev);

	ibx_irq_postinstall(dev);

	if (IS_IRONLAKE_M(dev)) {
		/* Enable PCU event interrupts
		 *
		 * spinlocking not required here for correctness since interrupt
		 * setup is guaranteed to run in single-threaded context. But we
		 * need it to make the assert_spin_locked happy. */
		spin_lock_irq(&dev_priv->irq_lock);
		ironlake_enable_display_irq(dev_priv, DE_PCU_EVENT);
		spin_unlock_irq(&dev_priv->irq_lock);
	}

	return 0;
}

static void valleyview_display_irqs_install(struct drm_i915_private *dev_priv)
{
	u32 pipestat_mask;
	u32 iir_mask;
	enum pipe pipe;

	pipestat_mask = PIPESTAT_INT_STATUS_MASK |
			PIPE_FIFO_UNDERRUN_STATUS;

	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), pipestat_mask);
	POSTING_READ(PIPESTAT(PIPE_A));

	pipestat_mask = PLANE_FLIP_DONE_INT_STATUS_VLV |
			PIPE_CRC_DONE_INTERRUPT_STATUS;

	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_INTERRUPT_STATUS);
	for_each_pipe(dev_priv, pipe)
		      i915_enable_pipestat(dev_priv, pipe, pipestat_mask);

	iir_mask = I915_DISPLAY_PORT_INTERRUPT |
		   I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		   I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
	if (IS_CHERRYVIEW(dev_priv))
		iir_mask |= I915_DISPLAY_PIPE_C_EVENT_INTERRUPT;
	dev_priv->irq_mask &= ~iir_mask;

	I915_WRITE(VLV_IIR, iir_mask);
	I915_WRITE(VLV_IIR, iir_mask);
	I915_WRITE(VLV_IER, ~dev_priv->irq_mask);
	I915_WRITE(VLV_IMR, dev_priv->irq_mask);
	POSTING_READ(VLV_IMR);
}

static void valleyview_display_irqs_uninstall(struct drm_i915_private *dev_priv)
{
	u32 pipestat_mask;
	u32 iir_mask;
	enum pipe pipe;

	iir_mask = I915_DISPLAY_PORT_INTERRUPT |
		   I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		   I915_DISPLAY_PIPE_B_EVENT_INTERRUPT;
	if (IS_CHERRYVIEW(dev_priv))
		iir_mask |= I915_DISPLAY_PIPE_C_EVENT_INTERRUPT;

	dev_priv->irq_mask |= iir_mask;
	I915_WRITE(VLV_IMR, dev_priv->irq_mask);
	I915_WRITE(VLV_IER, ~dev_priv->irq_mask);
	I915_WRITE(VLV_IIR, iir_mask);
	I915_WRITE(VLV_IIR, iir_mask);
	POSTING_READ(VLV_IIR);

	pipestat_mask = PLANE_FLIP_DONE_INT_STATUS_VLV |
			PIPE_CRC_DONE_INTERRUPT_STATUS;

	i915_disable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_INTERRUPT_STATUS);
	for_each_pipe(dev_priv, pipe)
		i915_disable_pipestat(dev_priv, pipe, pipestat_mask);

	pipestat_mask = PIPESTAT_INT_STATUS_MASK |
			PIPE_FIFO_UNDERRUN_STATUS;

	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), pipestat_mask);
	POSTING_READ(PIPESTAT(PIPE_A));
}

void valleyview_enable_display_irqs(struct drm_i915_private *dev_priv)
{
	assert_spin_locked(&dev_priv->irq_lock);

	if (dev_priv->display_irqs_enabled)
		return;

	dev_priv->display_irqs_enabled = true;

	if (intel_irqs_enabled(dev_priv))
		valleyview_display_irqs_install(dev_priv);
}

void valleyview_disable_display_irqs(struct drm_i915_private *dev_priv)
{
	assert_spin_locked(&dev_priv->irq_lock);

	if (!dev_priv->display_irqs_enabled)
		return;

	dev_priv->display_irqs_enabled = false;

	if (intel_irqs_enabled(dev_priv))
		valleyview_display_irqs_uninstall(dev_priv);
}

static void vlv_display_irq_postinstall(struct drm_i915_private *dev_priv)
{
	dev_priv->irq_mask = ~0;

	i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
	POSTING_READ(PORT_HOTPLUG_EN);

	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(VLV_IER, ~dev_priv->irq_mask);
	I915_WRITE(VLV_IMR, dev_priv->irq_mask);
	POSTING_READ(VLV_IMR);

	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked check happy. */
	spin_lock_irq(&dev_priv->irq_lock);
	if (dev_priv->display_irqs_enabled)
		valleyview_display_irqs_install(dev_priv);
	spin_unlock_irq(&dev_priv->irq_lock);
}

static int valleyview_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	vlv_display_irq_postinstall(dev_priv);

	gen5_gt_irq_postinstall(dev);

	/* ack & enable invalid PTE error interrupts */
#if 0 /* FIXME: add support to irq handler for checking these bits */
	I915_WRITE(DPINVGTT, DPINVGTT_STATUS_MASK);
	I915_WRITE(DPINVGTT, DPINVGTT_EN_MASK);
#endif

	I915_WRITE(VLV_MASTER_IER, MASTER_INTERRUPT_ENABLE);

	return 0;
}

static void gen8_gt_irq_postinstall(struct drm_i915_private *dev_priv)
{
	/* These are interrupts we'll toggle with the ring mask register */
	uint32_t gt_interrupts[] = {
		GT_RENDER_USER_INTERRUPT << GEN8_RCS_IRQ_SHIFT |
			GT_CONTEXT_SWITCH_INTERRUPT << GEN8_RCS_IRQ_SHIFT |
			GT_RENDER_L3_PARITY_ERROR_INTERRUPT |
			GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT |
			GT_CONTEXT_SWITCH_INTERRUPT << GEN8_BCS_IRQ_SHIFT,
		GT_RENDER_USER_INTERRUPT << GEN8_VCS1_IRQ_SHIFT |
			GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VCS1_IRQ_SHIFT |
			GT_RENDER_USER_INTERRUPT << GEN8_VCS2_IRQ_SHIFT |
			GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VCS2_IRQ_SHIFT,
		0,
		GT_RENDER_USER_INTERRUPT << GEN8_VECS_IRQ_SHIFT |
			GT_CONTEXT_SWITCH_INTERRUPT << GEN8_VECS_IRQ_SHIFT
		};

	dev_priv->pm_irq_mask = 0xffffffff;
	GEN8_IRQ_INIT_NDX(GT, 0, ~gt_interrupts[0], gt_interrupts[0]);
	GEN8_IRQ_INIT_NDX(GT, 1, ~gt_interrupts[1], gt_interrupts[1]);
	/*
	 * RPS interrupts will get enabled/disabled on demand when RPS itself
	 * is enabled/disabled.
	 */
	GEN8_IRQ_INIT_NDX(GT, 2, dev_priv->pm_irq_mask, 0);
	GEN8_IRQ_INIT_NDX(GT, 3, ~gt_interrupts[3], gt_interrupts[3]);
}

static void gen8_de_irq_postinstall(struct drm_i915_private *dev_priv)
{
	uint32_t de_pipe_masked = GEN8_PIPE_CDCLK_CRC_DONE;
	uint32_t de_pipe_enables;
	u32 de_port_masked = GEN8_AUX_CHANNEL_A;
	u32 de_port_enables;
	enum pipe pipe;

	if (INTEL_INFO(dev_priv)->gen >= 9) {
		de_pipe_masked |= GEN9_PIPE_PLANE1_FLIP_DONE |
				  GEN9_DE_PIPE_IRQ_FAULT_ERRORS;
		de_port_masked |= GEN9_AUX_CHANNEL_B | GEN9_AUX_CHANNEL_C |
				  GEN9_AUX_CHANNEL_D;
		if (IS_BROXTON(dev_priv))
			de_port_masked |= BXT_DE_PORT_GMBUS;
	} else {
		de_pipe_masked |= GEN8_PIPE_PRIMARY_FLIP_DONE |
				  GEN8_DE_PIPE_IRQ_FAULT_ERRORS;
	}

	de_pipe_enables = de_pipe_masked | GEN8_PIPE_VBLANK |
					   GEN8_PIPE_FIFO_UNDERRUN;

	de_port_enables = de_port_masked;
	if (IS_BROXTON(dev_priv))
		de_port_enables |= BXT_DE_PORT_HOTPLUG_MASK;
	else if (IS_BROADWELL(dev_priv))
		de_port_enables |= GEN8_PORT_DP_A_HOTPLUG;

	dev_priv->de_irq_mask[PIPE_A] = ~de_pipe_masked;
	dev_priv->de_irq_mask[PIPE_B] = ~de_pipe_masked;
	dev_priv->de_irq_mask[PIPE_C] = ~de_pipe_masked;

	for_each_pipe(dev_priv, pipe)
		if (intel_display_power_is_enabled(dev_priv,
				POWER_DOMAIN_PIPE(pipe)))
			GEN8_IRQ_INIT_NDX(DE_PIPE, pipe,
					  dev_priv->de_irq_mask[pipe],
					  de_pipe_enables);

	GEN5_IRQ_INIT(GEN8_DE_PORT_, ~de_port_masked, de_port_enables);

	GEN5_IRQ_INIT(GEN8_DE_MISC_, ~GEN8_DE_MISC_GSE, GEN8_DE_MISC_GSE);
}

static int gen8_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (HAS_PCH_SPLIT(dev))
		ibx_irq_pre_postinstall(dev);

	gen8_gt_irq_postinstall(dev_priv);
	gen8_de_irq_postinstall(dev_priv);

	if (HAS_PCH_SPLIT(dev))
		ibx_irq_postinstall(dev);

	I915_WRITE(GEN8_MASTER_IRQ, DE_MASTER_IRQ_CONTROL);
	POSTING_READ(GEN8_MASTER_IRQ);

	return 0;
}

static int cherryview_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	vlv_display_irq_postinstall(dev_priv);

	gen8_gt_irq_postinstall(dev_priv);

	I915_WRITE(GEN8_MASTER_IRQ, MASTER_INTERRUPT_ENABLE);
	POSTING_READ(GEN8_MASTER_IRQ);

	return 0;
}

static void gen8_irq_uninstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv)
		return;

	gen8_irq_reset(dev);
}

static void vlv_display_irq_uninstall(struct drm_i915_private *dev_priv)
{
	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked check happy. */
	spin_lock_irq(&dev_priv->irq_lock);
	if (dev_priv->display_irqs_enabled)
		valleyview_display_irqs_uninstall(dev_priv);
	spin_unlock_irq(&dev_priv->irq_lock);

	vlv_display_irq_reset(dev_priv);

	dev_priv->irq_mask = ~0;
}

static void valleyview_irq_uninstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv)
		return;

	I915_WRITE(VLV_MASTER_IER, 0);

	gen5_gt_irq_reset(dev);

	I915_WRITE(HWSTAM, 0xffffffff);

	vlv_display_irq_uninstall(dev_priv);
}

static void cherryview_irq_uninstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv)
		return;

	I915_WRITE(GEN8_MASTER_IRQ, 0);
	POSTING_READ(GEN8_MASTER_IRQ);

	gen8_gt_irq_reset(dev_priv);

	GEN5_IRQ_RESET(GEN8_PCU_);

	vlv_display_irq_uninstall(dev_priv);
}

static void ironlake_irq_uninstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv)
		return;

	ironlake_irq_reset(dev);
}

static void i8xx_irq_preinstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), 0);
	I915_WRITE16(IMR, 0xffff);
	I915_WRITE16(IER, 0x0);
	POSTING_READ16(IER);
}

static int i8xx_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE16(EMR,
		     ~(I915_ERROR_PAGE_TABLE | I915_ERROR_MEMORY_REFRESH));

	/* Unmask the interrupts that we always want on. */
	dev_priv->irq_mask =
		~(I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);
	I915_WRITE16(IMR, dev_priv->irq_mask);

	I915_WRITE16(IER,
		     I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		     I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
		     I915_USER_INTERRUPT);
	POSTING_READ16(IER);

	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked check happy. */
	spin_lock_irq(&dev_priv->irq_lock);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);
	spin_unlock_irq(&dev_priv->irq_lock);

	return 0;
}

/*
 * Returns true when a page flip has completed.
 */
static bool i8xx_handle_vblank(struct drm_device *dev,
			       int plane, int pipe, u32 iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u16 flip_pending = DISPLAY_PLANE_FLIP_PENDING(plane);

	if (!intel_pipe_handle_vblank(dev, pipe))
		return false;

	if ((iir & flip_pending) == 0)
		goto check_page_flip;

	/* We detect FlipDone by looking for the change in PendingFlip from '1'
	 * to '0' on the following vblank, i.e. IIR has the Pendingflip
	 * asserted following the MI_DISPLAY_FLIP, but ISR is deasserted, hence
	 * the flip is completed (no longer pending). Since this doesn't raise
	 * an interrupt per se, we watch for the change at vblank.
	 */
	if (I915_READ16(ISR) & flip_pending)
		goto check_page_flip;

	intel_prepare_page_flip(dev, plane);
	intel_finish_page_flip(dev, pipe);
	return true;

check_page_flip:
	intel_check_page_flip(dev, pipe);
	return false;
}

static irqreturn_t i8xx_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u16 iir, new_iir;
	u32 pipe_stats[2];
	int pipe;
	u16 flip_mask =
		I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
		I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	iir = I915_READ16(IIR);
	if (iir == 0)
		return IRQ_NONE;

	while (iir & ~flip_mask) {
		/* Can't rely on pipestat interrupt bit in iir as it might
		 * have been cleared after the pipestat interrupt was received.
		 * It doesn't set the bit in iir again, but it still produces
		 * interrupts (for non-MSI).
		 */
		spin_lock(&dev_priv->irq_lock);
		if (iir & I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT)
			DRM_DEBUG("Command parser error, iir 0x%08x\n", iir);

		for_each_pipe(dev_priv, pipe) {
			int reg = PIPESTAT(pipe);
			pipe_stats[pipe] = I915_READ(reg);

			/*
			 * Clear the PIPE*STAT regs before the IIR
			 */
			if (pipe_stats[pipe] & 0x8000ffff)
				I915_WRITE(reg, pipe_stats[pipe]);
		}
		spin_unlock(&dev_priv->irq_lock);

		I915_WRITE16(IIR, iir & ~flip_mask);
		new_iir = I915_READ16(IIR); /* Flush posted writes */

		if (iir & I915_USER_INTERRUPT)
			notify_ring(&dev_priv->ring[RCS]);

		for_each_pipe(dev_priv, pipe) {
			int plane = pipe;
			if (HAS_FBC(dev))
				plane = !plane;

			if (pipe_stats[pipe] & PIPE_VBLANK_INTERRUPT_STATUS &&
			    i8xx_handle_vblank(dev, plane, pipe, iir))
				flip_mask &= ~DISPLAY_PLANE_FLIP_PENDING(plane);

			if (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)
				i9xx_pipe_crc_irq_handler(dev, pipe);

			if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
				intel_cpu_fifo_underrun_irq_handler(dev_priv,
								    pipe);
		}

		iir = new_iir;
	}

	return IRQ_HANDLED;
}

static void i8xx_irq_uninstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	for_each_pipe(dev_priv, pipe) {
		/* Clear enable bits; then clear status bits */
		I915_WRITE(PIPESTAT(pipe), 0);
		I915_WRITE(PIPESTAT(pipe), I915_READ(PIPESTAT(pipe)));
	}
	I915_WRITE16(IMR, 0xffff);
	I915_WRITE16(IER, 0x0);
	I915_WRITE16(IIR, I915_READ16(IIR));
}

static void i915_irq_preinstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	if (I915_HAS_HOTPLUG(dev)) {
		i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
		I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));
	}

	I915_WRITE16(HWSTAM, 0xeffe);
	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), 0);
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);
	POSTING_READ(IER);
}

static int i915_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 enable_mask;

	I915_WRITE(EMR, ~(I915_ERROR_PAGE_TABLE | I915_ERROR_MEMORY_REFRESH));

	/* Unmask the interrupts that we always want on. */
	dev_priv->irq_mask =
		~(I915_ASLE_INTERRUPT |
		  I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		  I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
		  I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);

	enable_mask =
		I915_ASLE_INTERRUPT |
		I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
		I915_USER_INTERRUPT;

	if (I915_HAS_HOTPLUG(dev)) {
		i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
		POSTING_READ(PORT_HOTPLUG_EN);

		/* Enable in IER... */
		enable_mask |= I915_DISPLAY_PORT_INTERRUPT;
		/* and unmask in IMR */
		dev_priv->irq_mask &= ~I915_DISPLAY_PORT_INTERRUPT;
	}

	I915_WRITE(IMR, dev_priv->irq_mask);
	I915_WRITE(IER, enable_mask);
	POSTING_READ(IER);

	i915_enable_asle_pipestat(dev);

	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked check happy. */
	spin_lock_irq(&dev_priv->irq_lock);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);
	spin_unlock_irq(&dev_priv->irq_lock);

	return 0;
}

/*
 * Returns true when a page flip has completed.
 */
static bool i915_handle_vblank(struct drm_device *dev,
			       int plane, int pipe, u32 iir)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 flip_pending = DISPLAY_PLANE_FLIP_PENDING(plane);

	if (!intel_pipe_handle_vblank(dev, pipe))
		return false;

	if ((iir & flip_pending) == 0)
		goto check_page_flip;

	/* We detect FlipDone by looking for the change in PendingFlip from '1'
	 * to '0' on the following vblank, i.e. IIR has the Pendingflip
	 * asserted following the MI_DISPLAY_FLIP, but ISR is deasserted, hence
	 * the flip is completed (no longer pending). Since this doesn't raise
	 * an interrupt per se, we watch for the change at vblank.
	 */
	if (I915_READ(ISR) & flip_pending)
		goto check_page_flip;

	intel_prepare_page_flip(dev, plane);
	intel_finish_page_flip(dev, pipe);
	return true;

check_page_flip:
	intel_check_page_flip(dev, pipe);
	return false;
}

static irqreturn_t i915_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 iir, new_iir, pipe_stats[I915_MAX_PIPES];
	u32 flip_mask =
		I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
		I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT;
	int pipe, ret = IRQ_NONE;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	iir = I915_READ(IIR);
	do {
		bool irq_received = (iir & ~flip_mask) != 0;
		bool blc_event = false;

		/* Can't rely on pipestat interrupt bit in iir as it might
		 * have been cleared after the pipestat interrupt was received.
		 * It doesn't set the bit in iir again, but it still produces
		 * interrupts (for non-MSI).
		 */
		spin_lock(&dev_priv->irq_lock);
		if (iir & I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT)
			DRM_DEBUG("Command parser error, iir 0x%08x\n", iir);

		for_each_pipe(dev_priv, pipe) {
			int reg = PIPESTAT(pipe);
			pipe_stats[pipe] = I915_READ(reg);

			/* Clear the PIPE*STAT regs before the IIR */
			if (pipe_stats[pipe] & 0x8000ffff) {
				I915_WRITE(reg, pipe_stats[pipe]);
				irq_received = true;
			}
		}
		spin_unlock(&dev_priv->irq_lock);

		if (!irq_received)
			break;

		/* Consume port.  Then clear IIR or we'll miss events */
		if (I915_HAS_HOTPLUG(dev) &&
		    iir & I915_DISPLAY_PORT_INTERRUPT)
			i9xx_hpd_irq_handler(dev);

		I915_WRITE(IIR, iir & ~flip_mask);
		new_iir = I915_READ(IIR); /* Flush posted writes */

		if (iir & I915_USER_INTERRUPT)
			notify_ring(&dev_priv->ring[RCS]);

		for_each_pipe(dev_priv, pipe) {
			int plane = pipe;
			if (HAS_FBC(dev))
				plane = !plane;

			if (pipe_stats[pipe] & PIPE_VBLANK_INTERRUPT_STATUS &&
			    i915_handle_vblank(dev, plane, pipe, iir))
				flip_mask &= ~DISPLAY_PLANE_FLIP_PENDING(plane);

			if (pipe_stats[pipe] & PIPE_LEGACY_BLC_EVENT_STATUS)
				blc_event = true;

			if (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)
				i9xx_pipe_crc_irq_handler(dev, pipe);

			if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
				intel_cpu_fifo_underrun_irq_handler(dev_priv,
								    pipe);
		}

		if (blc_event || (iir & I915_ASLE_INTERRUPT))
			intel_opregion_asle_intr(dev);

		/* With MSI, interrupts are only generated when iir
		 * transitions from zero to nonzero.  If another bit got
		 * set while we were handling the existing iir bits, then
		 * we would never get another interrupt.
		 *
		 * This is fine on non-MSI as well, as if we hit this path
		 * we avoid exiting the interrupt handler only to generate
		 * another one.
		 *
		 * Note that for MSI this could cause a stray interrupt report
		 * if an interrupt landed in the time between writing IIR and
		 * the posting read.  This should be rare enough to never
		 * trigger the 99% of 100,000 interrupts test for disabling
		 * stray interrupts.
		 */
		ret = IRQ_HANDLED;
		iir = new_iir;
	} while (iir & ~flip_mask);

	return ret;
}

static void i915_irq_uninstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	if (I915_HAS_HOTPLUG(dev)) {
		i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
		I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));
	}

	I915_WRITE16(HWSTAM, 0xffff);
	for_each_pipe(dev_priv, pipe) {
		/* Clear enable bits; then clear status bits */
		I915_WRITE(PIPESTAT(pipe), 0);
		I915_WRITE(PIPESTAT(pipe), I915_READ(PIPESTAT(pipe)));
	}
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);

	I915_WRITE(IIR, I915_READ(IIR));
}

static void i965_irq_preinstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
	I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));

	I915_WRITE(HWSTAM, 0xeffe);
	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), 0);
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);
	POSTING_READ(IER);
}

static int i965_irq_postinstall(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 enable_mask;
	u32 error_mask;

	/* Unmask the interrupts that we always want on. */
	dev_priv->irq_mask = ~(I915_ASLE_INTERRUPT |
			       I915_DISPLAY_PORT_INTERRUPT |
			       I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
			       I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
			       I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
			       I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |
			       I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);

	enable_mask = ~dev_priv->irq_mask;
	enable_mask &= ~(I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
			 I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT);
	enable_mask |= I915_USER_INTERRUPT;

	if (IS_G4X(dev))
		enable_mask |= I915_BSD_USER_INTERRUPT;

	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked check happy. */
	spin_lock_irq(&dev_priv->irq_lock);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_INTERRUPT_STATUS);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_INTERRUPT_STATUS);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_INTERRUPT_STATUS);
	spin_unlock_irq(&dev_priv->irq_lock);

	/*
	 * Enable some error detection, note the instruction error mask
	 * bit is reserved, so we leave it masked.
	 */
	if (IS_G4X(dev)) {
		error_mask = ~(GM45_ERROR_PAGE_TABLE |
			       GM45_ERROR_MEM_PRIV |
			       GM45_ERROR_CP_PRIV |
			       I915_ERROR_MEMORY_REFRESH);
	} else {
		error_mask = ~(I915_ERROR_PAGE_TABLE |
			       I915_ERROR_MEMORY_REFRESH);
	}
	I915_WRITE(EMR, error_mask);

	I915_WRITE(IMR, dev_priv->irq_mask);
	I915_WRITE(IER, enable_mask);
	POSTING_READ(IER);

	i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
	POSTING_READ(PORT_HOTPLUG_EN);

	i915_enable_asle_pipestat(dev);

	return 0;
}

static void i915_hpd_irq_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 hotplug_en;

	assert_spin_locked(&dev_priv->irq_lock);

	/* Note HDMI and DP share hotplug bits */
	/* enable bits are the same for all generations */
	hotplug_en = intel_hpd_enabled_irqs(dev, hpd_mask_i915);
	/* Programming the CRT detection parameters tends
	   to generate a spurious hotplug event about three
	   seconds later.  So just do it once.
	*/
	if (IS_G4X(dev))
		hotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;
	hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;

	/* Ignore TV since it's buggy */
	i915_hotplug_interrupt_update_locked(dev_priv,
					     HOTPLUG_INT_EN_MASK |
					     CRT_HOTPLUG_VOLTAGE_COMPARE_MASK |
					     CRT_HOTPLUG_ACTIVATION_PERIOD_64,
					     hotplug_en);
}

static irqreturn_t i965_irq_handler(int irq, void *arg)
{
	struct drm_device *dev = arg;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 iir, new_iir;
	u32 pipe_stats[I915_MAX_PIPES];
	int ret = IRQ_NONE, pipe;
	u32 flip_mask =
		I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT |
		I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT;

	if (!intel_irqs_enabled(dev_priv))
		return IRQ_NONE;

	iir = I915_READ(IIR);

	for (;;) {
		bool irq_received = (iir & ~flip_mask) != 0;
		bool blc_event = false;

		/* Can't rely on pipestat interrupt bit in iir as it might
		 * have been cleared after the pipestat interrupt was received.
		 * It doesn't set the bit in iir again, but it still produces
		 * interrupts (for non-MSI).
		 */
		spin_lock(&dev_priv->irq_lock);
		if (iir & I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT)
			DRM_DEBUG("Command parser error, iir 0x%08x\n", iir);

		for_each_pipe(dev_priv, pipe) {
			int reg = PIPESTAT(pipe);
			pipe_stats[pipe] = I915_READ(reg);

			/*
			 * Clear the PIPE*STAT regs before the IIR
			 */
			if (pipe_stats[pipe] & 0x8000ffff) {
				I915_WRITE(reg, pipe_stats[pipe]);
				irq_received = true;
			}
		}
		spin_unlock(&dev_priv->irq_lock);

		if (!irq_received)
			break;

		ret = IRQ_HANDLED;

		/* Consume port.  Then clear IIR or we'll miss events */
		if (iir & I915_DISPLAY_PORT_INTERRUPT)
			i9xx_hpd_irq_handler(dev);

		I915_WRITE(IIR, iir & ~flip_mask);
		new_iir = I915_READ(IIR); /* Flush posted writes */

		if (iir & I915_USER_INTERRUPT)
			notify_ring(&dev_priv->ring[RCS]);
		if (iir & I915_BSD_USER_INTERRUPT)
			notify_ring(&dev_priv->ring[VCS]);

		for_each_pipe(dev_priv, pipe) {
			if (pipe_stats[pipe] & PIPE_START_VBLANK_INTERRUPT_STATUS &&
			    i915_handle_vblank(dev, pipe, pipe, iir))
				flip_mask &= ~DISPLAY_PLANE_FLIP_PENDING(pipe);

			if (pipe_stats[pipe] & PIPE_LEGACY_BLC_EVENT_STATUS)
				blc_event = true;

			if (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)
				i9xx_pipe_crc_irq_handler(dev, pipe);

			if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
				intel_cpu_fifo_underrun_irq_handler(dev_priv, pipe);
		}

		if (blc_event || (iir & I915_ASLE_INTERRUPT))
			intel_opregion_asle_intr(dev);

		if (pipe_stats[0] & PIPE_GMBUS_INTERRUPT_STATUS)
			gmbus_irq_handler(dev);

		/* With MSI, interrupts are only generated when iir
		 * transitions from zero to nonzero.  If another bit got
		 * set while we were handling the existing iir bits, then
		 * we would never get another interrupt.
		 *
		 * This is fine on non-MSI as well, as if we hit this path
		 * we avoid exiting the interrupt handler only to generate
		 * another one.
		 *
		 * Note that for MSI this could cause a stray interrupt report
		 * if an interrupt landed in the time between writing IIR and
		 * the posting read.  This should be rare enough to never
		 * trigger the 99% of 100,000 interrupts test for disabling
		 * stray interrupts.
		 */
		iir = new_iir;
	}

	return ret;
}

static void i965_irq_uninstall(struct drm_device * dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe;

	if (!dev_priv)
		return;

	i915_hotplug_interrupt_update(dev_priv, 0xffffffff, 0);
	I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));

	I915_WRITE(HWSTAM, 0xffffffff);
	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe), 0);
	I915_WRITE(IMR, 0xffffffff);
	I915_WRITE(IER, 0x0);

	for_each_pipe(dev_priv, pipe)
		I915_WRITE(PIPESTAT(pipe),
			   I915_READ(PIPESTAT(pipe)) & 0x8000ffff);
	I915_WRITE(IIR, I915_READ(IIR));
}

/**
 * intel_irq_init - initializes irq support
 * @@dev_priv: i915 device instance
 *
 * This function initializes all the irq support including work items, timers
 * and all the vtables. It does not setup the interrupt itself though.
 */
void intel_irq_init(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;

	intel_hpd_init_work(dev_priv);

	INIT_WORK(&dev_priv->rps.work, gen6_pm_rps_work);
	INIT_WORK(&dev_priv->l3_parity.error_work, ivybridge_parity_work);

	/* Let's track the enabled rps events */
	if (IS_VALLEYVIEW(dev_priv) && !IS_CHERRYVIEW(dev_priv))
		/* WaGsvRC0ResidencyMethod:vlv */
		dev_priv->pm_rps_events = GEN6_PM_RP_UP_EI_EXPIRED;
	else
		dev_priv->pm_rps_events = GEN6_PM_RPS_EVENTS;

	INIT_DELAYED_WORK(&dev_priv->gpu_error.hangcheck_work,
			  i915_hangcheck_elapsed);

#ifdef __linux__
	pm_qos_add_request(&dev_priv->pm_qos, PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
#endif

	if (IS_GEN2(dev_priv)) {
		dev->max_vblank_count = 0;
		dev->driver->get_vblank_counter = i8xx_get_vblank_counter;
	} else if (IS_G4X(dev_priv) || INTEL_INFO(dev_priv)->gen >= 5) {
		dev->max_vblank_count = 0xffffffff; /* full 32 bit counter */
		dev->driver->get_vblank_counter = g4x_get_vblank_counter;
	} else {
		dev->driver->get_vblank_counter = i915_get_vblank_counter;
		dev->max_vblank_count = 0xffffff; /* only 24 bits of frame count */
	}

	/*
	 * Opt out of the vblank disable timer on everything except gen2.
	 * Gen2 doesn't have a hardware frame counter and so depends on
	 * vblank interrupts to produce sane vblank seuquence numbers.
	 */
	if (!IS_GEN2(dev_priv))
		dev->vblank_disable_immediate = true;

	dev->driver->get_vblank_timestamp = i915_get_vblank_timestamp;
	dev->driver->get_scanout_position = i915_get_crtc_scanoutpos;

	if (IS_CHERRYVIEW(dev_priv)) {
		dev->driver->irq_handler = cherryview_irq_handler;
		dev->driver->irq_preinstall = cherryview_irq_preinstall;
		dev->driver->irq_postinstall = cherryview_irq_postinstall;
		dev->driver->irq_uninstall = cherryview_irq_uninstall;
		dev->driver->enable_vblank = valleyview_enable_vblank;
		dev->driver->disable_vblank = valleyview_disable_vblank;
		dev_priv->display.hpd_irq_setup = i915_hpd_irq_setup;
	} else if (IS_VALLEYVIEW(dev_priv)) {
		dev->driver->irq_handler = valleyview_irq_handler;
		dev->driver->irq_preinstall = valleyview_irq_preinstall;
		dev->driver->irq_postinstall = valleyview_irq_postinstall;
		dev->driver->irq_uninstall = valleyview_irq_uninstall;
		dev->driver->enable_vblank = valleyview_enable_vblank;
		dev->driver->disable_vblank = valleyview_disable_vblank;
		dev_priv->display.hpd_irq_setup = i915_hpd_irq_setup;
	} else if (INTEL_INFO(dev_priv)->gen >= 8) {
		dev->driver->irq_handler = gen8_irq_handler;
		dev->driver->irq_preinstall = gen8_irq_reset;
		dev->driver->irq_postinstall = gen8_irq_postinstall;
		dev->driver->irq_uninstall = gen8_irq_uninstall;
		dev->driver->enable_vblank = gen8_enable_vblank;
		dev->driver->disable_vblank = gen8_disable_vblank;
		if (IS_BROXTON(dev))
			dev_priv->display.hpd_irq_setup = bxt_hpd_irq_setup;
		else if (HAS_PCH_SPT(dev) || HAS_PCH_KBP(dev))
			dev_priv->display.hpd_irq_setup = spt_hpd_irq_setup;
		else
			dev_priv->display.hpd_irq_setup = ilk_hpd_irq_setup;
	} else if (HAS_PCH_SPLIT(dev)) {
		dev->driver->irq_handler = ironlake_irq_handler;
		dev->driver->irq_preinstall = ironlake_irq_reset;
		dev->driver->irq_postinstall = ironlake_irq_postinstall;
		dev->driver->irq_uninstall = ironlake_irq_uninstall;
		dev->driver->enable_vblank = ironlake_enable_vblank;
		dev->driver->disable_vblank = ironlake_disable_vblank;
		dev_priv->display.hpd_irq_setup = ilk_hpd_irq_setup;
	} else {
		if (INTEL_INFO(dev_priv)->gen == 2) {
			dev->driver->irq_preinstall = i8xx_irq_preinstall;
			dev->driver->irq_postinstall = i8xx_irq_postinstall;
			dev->driver->irq_handler = i8xx_irq_handler;
			dev->driver->irq_uninstall = i8xx_irq_uninstall;
		} else if (INTEL_INFO(dev_priv)->gen == 3) {
			dev->driver->irq_preinstall = i915_irq_preinstall;
			dev->driver->irq_postinstall = i915_irq_postinstall;
			dev->driver->irq_uninstall = i915_irq_uninstall;
			dev->driver->irq_handler = i915_irq_handler;
		} else {
			dev->driver->irq_preinstall = i965_irq_preinstall;
			dev->driver->irq_postinstall = i965_irq_postinstall;
			dev->driver->irq_uninstall = i965_irq_uninstall;
			dev->driver->irq_handler = i965_irq_handler;
		}
		if (I915_HAS_HOTPLUG(dev_priv))
			dev_priv->display.hpd_irq_setup = i915_hpd_irq_setup;
		dev->driver->enable_vblank = i915_enable_vblank;
		dev->driver->disable_vblank = i915_disable_vblank;
	}
}

/**
 * intel_irq_install - enables the hardware interrupt
 * @@dev_priv: i915 device instance
 *
 * This function enables the hardware interrupt handling, but leaves the hotplug
 * handling still disabled. It is called after intel_irq_init().
 *
 * In the driver load and resume code we need working interrupts in a few places
 * but don't want to deal with the hassle of concurrent probe and hotplug
 * workers. Hence the split into this two-stage approach.
 */
int intel_irq_install(struct drm_i915_private *dev_priv)
{
	/*
	 * We enable some interrupt sources in our postinstall hooks, so mark
	 * interrupts as enabled _before_ actually enabling them to avoid
	 * special cases in our ordering checks.
	 */
	dev_priv->pm.irqs_enabled = true;

	return drm_irq_install(dev_priv->dev, dev_priv->dev->pdev->irq);
}

/**
 * intel_irq_uninstall - finilizes all irq handling
 * @@dev_priv: i915 device instance
 *
 * This stops interrupt and hotplug handling and unregisters and frees all
 * resources acquired in the init functions.
 */
void intel_irq_uninstall(struct drm_i915_private *dev_priv)
{
	drm_irq_uninstall(dev_priv->dev);
	intel_hpd_cancel_work(dev_priv);
	dev_priv->pm.irqs_enabled = false;
}

/**
 * intel_runtime_pm_disable_interrupts - runtime interrupt disabling
 * @@dev_priv: i915 device instance
 *
 * This function is used to disable interrupts at runtime, both in the runtime
 * pm and the system suspend/resume code.
 */
void intel_runtime_pm_disable_interrupts(struct drm_i915_private *dev_priv)
{
	dev_priv->dev->driver->irq_uninstall(dev_priv->dev);
	dev_priv->pm.irqs_enabled = false;
	synchronize_irq(dev_priv->dev->irq);
}

/**
 * intel_runtime_pm_enable_interrupts - runtime interrupt enabling
 * @@dev_priv: i915 device instance
 *
 * This function is used to enable interrupts at runtime, both in the runtime
 * pm and the system suspend/resume code.
 */
void intel_runtime_pm_enable_interrupts(struct drm_i915_private *dev_priv)
{
	dev_priv->pm.irqs_enabled = true;
	dev_priv->dev->driver->irq_preinstall(dev_priv->dev);
	dev_priv->dev->driver->irq_postinstall(dev_priv->dev);
}
@


1.31
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d2352 1
a2352 1
			if (HAS_PCH_SPT(dev_priv))
d4460 1
a4460 1
		else if (HAS_PCH_SPT(dev))
@


1.30
log
@Enable the GSE interrupt on Broadwell.  Fixes acpi brightness control on
the MacBookPro12,1, 3rd gen Lenovo X1 Carbon (when hacked to use the standard
acpi mechanism for this purpose) and probably many others.  Seems this
hasn't been figured out over in Linux land yet.
@
text
@a0 1
/*	$OpenBSD: i915_irq.c,v 1.29 2015/09/23 23:12:12 kettenis Exp $	*/
d31 5
d42 21
a62 1
static const u32 hpd_ibx[] = {
d70 1
a70 1
static const u32 hpd_cpt[] = {
d78 9
a86 1
static const u32 hpd_mask_i915[] = {
d95 1
a95 1
static const u32 hpd_status_g4x[] = {
d104 1
a104 1
static const u32 hpd_status_i915[] = { /* i915 and valleyview are the same */
d113 62
d176 4
a179 2
static void
ironlake_enable_display_irq(drm_i915_private_t *dev_priv, u32 mask)
d181 2
d184 1
d186 5
a190 5
	if (dev_priv->pc8.irqs_disabled) {
		WARN(1, "IRQs disabled\n");
		dev_priv->pc8.regsave.deimr &= ~mask;
		return;
	}
d192 19
a210 5
	if ((dev_priv->irq_mask & mask) != 0) {
		dev_priv->irq_mask &= ~mask;
		I915_WRITE(DEIMR, dev_priv->irq_mask);
		POSTING_READ(DEIMR);
	}
d213 9
a221 2
static void
ironlake_disable_display_irq(drm_i915_private_t *dev_priv, u32 mask)
d223 2
d227 3
a229 3
	if (dev_priv->pc8.irqs_disabled) {
		WARN(1, "IRQs disabled\n");
		dev_priv->pc8.regsave.deimr |= mask;
a230 1
	}
d232 6
a237 2
	if ((dev_priv->irq_mask & mask) != mask) {
		dev_priv->irq_mask |= mask;
d243 12
d267 3
a269 5
	if (dev_priv->pc8.irqs_disabled) {
		WARN(1, "IRQs disabled\n");
		dev_priv->pc8.regsave.gtimr &= ~interrupt_mask;
		dev_priv->pc8.regsave.gtimr |= (~enabled_irq_mask &
						interrupt_mask);
a270 1
	}
d278 1
a278 1
void ilk_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask)
d283 1
a283 1
void ilk_disable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask)
d288 15
d315 2
a318 8
	if (dev_priv->pc8.irqs_disabled) {
		WARN(1, "IRQs disabled\n");
		dev_priv->pc8.regsave.gen6_pmimr &= ~interrupt_mask;
		dev_priv->pc8.regsave.gen6_pmimr |= (~enabled_irq_mask &
						     interrupt_mask);
		return;
	}

d325 2
a326 2
		I915_WRITE(GEN6_PMIMR, dev_priv->pm_irq_mask);
		POSTING_READ(GEN6_PMIMR);
d330 1
a330 1
void snb_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask)
d332 3
d338 2
a339 1
void snb_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask)
d344 1
a344 1
static bool ivb_can_enable_err_int(struct drm_device *dev)
d346 2
a347 3
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc;
	enum pipe pipe;
d349 2
a350 1
	assert_spin_locked(&dev_priv->irq_lock);
d352 4
a355 2
	for_each_pipe(pipe) {
		crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
d357 6
a362 5
		if (crtc->cpu_fifo_underrun_disabled)
			return false;
	}

	return true;
d365 1
a365 1
static bool cpt_can_enable_serr_int(struct drm_device *dev)
a367 2
	enum pipe pipe;
	struct intel_crtc *crtc;
d369 1
a369 1
	assert_spin_locked(&dev_priv->irq_lock);
d371 6
a376 2
	for_each_pipe(pipe) {
		crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
d378 1
a378 5
		if (crtc->pch_fifo_underrun_disabled)
			return false;
	}

	return true;
d381 1
a381 2
static void ironlake_set_fifo_underrun_reporting(struct drm_device *dev,
						 enum pipe pipe, bool enable)
d383 11
a393 3
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t bit = (pipe == PIPE_A) ? DE_PIPEA_FIFO_UNDERRUN :
					  DE_PIPEB_FIFO_UNDERRUN;
d395 1
a395 4
	if (enable)
		ironlake_enable_display_irq(dev_priv, bit);
	else
		ironlake_disable_display_irq(dev_priv, bit);
d398 1
a398 2
static void ivybridge_set_fifo_underrun_reporting(struct drm_device *dev,
						  enum pipe pipe, bool enable)
a400 2
	if (enable) {
		I915_WRITE(GEN7_ERR_INT, ERR_INT_FIFO_UNDERRUN(pipe));
d402 7
a408 2
		if (!ivb_can_enable_err_int(dev))
			return;
d410 5
a414 3
		ironlake_enable_display_irq(dev_priv, DE_ERR_INT_IVB);
	} else {
		bool was_enabled = !(I915_READ(DEIMR) & DE_ERR_INT_IVB);
d416 1
a416 2
		/* Change the state _after_ we've read out the current one. */
		ironlake_disable_display_irq(dev_priv, DE_ERR_INT_IVB);
d418 1
a418 6
		if (!was_enabled &&
		    (I915_READ(GEN7_ERR_INT) & ERR_INT_FIFO_UNDERRUN(pipe))) {
			DRM_DEBUG_KMS("uncleared fifo underrun on pipe %c\n",
				      pipe_name(pipe));
		}
	}
d421 9
a429 2
static void broadwell_set_fifo_underrun_reporting(struct drm_device *dev,
						  enum pipe pipe, bool enable)
d431 2
a432 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d436 15
a450 6
	if (enable)
		dev_priv->de_irq_mask[pipe] &= ~GEN8_PIPE_FIFO_UNDERRUN;
	else
		dev_priv->de_irq_mask[pipe] |= GEN8_PIPE_FIFO_UNDERRUN;
	I915_WRITE(GEN8_DE_PIPE_IMR(pipe), dev_priv->de_irq_mask[pipe]);
	POSTING_READ(GEN8_DE_PIPE_IMR(pipe));
d459 3
a461 3
static void ibx_display_interrupt_update(struct drm_i915_private *dev_priv,
					 uint32_t interrupt_mask,
					 uint32_t enabled_irq_mask)
d467 2
d471 1
a471 6
	if (dev_priv->pc8.irqs_disabled &&
	    (interrupt_mask & SDE_HOTPLUG_MASK_CPT)) {
		WARN(1, "IRQs disabled\n");
		dev_priv->pc8.regsave.sdeimr &= ~interrupt_mask;
		dev_priv->pc8.regsave.sdeimr |= (~enabled_irq_mask &
						 interrupt_mask);
a472 1
	}
a476 4
#define ibx_enable_display_interrupt(dev_priv, bits) \
	ibx_display_interrupt_update((dev_priv), (bits), (bits))
#define ibx_disable_display_interrupt(dev_priv, bits) \
	ibx_display_interrupt_update((dev_priv), (bits), 0)
d478 3
a480 3
static void ibx_set_fifo_underrun_reporting(struct drm_device *dev,
					    enum transcoder pch_transcoder,
					    bool enable)
d482 2
a483 3
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t bit = (pch_transcoder == TRANSCODER_A) ?
		       SDE_TRANSA_FIFO_UNDER : SDE_TRANSB_FIFO_UNDER;
d485 2
a486 5
	if (enable)
		ibx_enable_display_interrupt(dev_priv, bit);
	else
		ibx_disable_display_interrupt(dev_priv, bit);
}
d488 5
a492 5
static void cpt_set_fifo_underrun_reporting(struct drm_device *dev,
					    enum transcoder pch_transcoder,
					    bool enable)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
d494 2
a495 3
	if (enable) {
		I915_WRITE(SERR_INT,
			   SERR_INT_TRANS_FIFO_UNDERRUN(pch_transcoder));
d497 1
a497 2
		if (!cpt_can_enable_serr_int(dev))
			return;
d499 4
a502 14
		ibx_enable_display_interrupt(dev_priv, SDE_ERROR_CPT);
	} else {
		uint32_t tmp = I915_READ(SERR_INT);
		bool was_enabled = !(I915_READ(SDEIMR) & SDE_ERROR_CPT);

		/* Change the state _after_ we've read out the current one. */
		ibx_disable_display_interrupt(dev_priv, SDE_ERROR_CPT);

		if (!was_enabled &&
		    (tmp & SERR_INT_TRANS_FIFO_UNDERRUN(pch_transcoder))) {
			DRM_DEBUG_KMS("uncleared pch fifo underrun on pch transcoder %c\n",
				      transcoder_name(pch_transcoder));
		}
	}
d505 3
a507 16
/**
 * intel_set_cpu_fifo_underrun_reporting - enable/disable FIFO underrun messages
 * @@dev: drm device
 * @@pipe: pipe
 * @@enable: true if we want to report FIFO underrun errors, false otherwise
 *
 * This function makes us disable or enable CPU fifo underruns for a specific
 * pipe. Notice that on some Gens (e.g. IVB, HSW), disabling FIFO underrun
 * reporting for one pipe may also disable all the other CPU error interruts for
 * the other pipes, due to the fact that there's just one interrupt mask/enable
 * bit for all the pipes.
 *
 * Returns the previous state of underrun reporting.
 */
bool intel_set_cpu_fifo_underrun_reporting(struct drm_device *dev,
					   enum pipe pipe, bool enable)
d509 2
a510 5
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	unsigned long flags;
	bool ret;
d512 2
a513 1
	spin_lock_irqsave(&dev_priv->irq_lock, flags);
d515 5
a519 1
	ret = !intel_crtc->cpu_fifo_underrun_disabled;
d521 2
a522 2
	if (enable == ret)
		goto done;
d524 1
a524 1
	intel_crtc->cpu_fifo_underrun_disabled = !enable;
d526 3
a528 10
	if (IS_GEN5(dev) || IS_GEN6(dev))
		ironlake_set_fifo_underrun_reporting(dev, pipe, enable);
	else if (IS_GEN7(dev))
		ivybridge_set_fifo_underrun_reporting(dev, pipe, enable);
	else if (IS_GEN8(dev))
		broadwell_set_fifo_underrun_reporting(dev, pipe, enable);

done:
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
	return ret;
d531 1
a531 17
/**
 * intel_set_pch_fifo_underrun_reporting - enable/disable FIFO underrun messages
 * @@dev: drm device
 * @@pch_transcoder: the PCH transcoder (same as pipe on IVB and older)
 * @@enable: true if we want to report FIFO underrun errors, false otherwise
 *
 * This function makes us disable or enable PCH fifo underruns for a specific
 * PCH transcoder. Notice that on some PCHs (e.g. CPT/PPT), disabling FIFO
 * underrun reporting for one transcoder may also disable all the other PCH
 * error interruts for the other transcoders, due to the fact that there's just
 * one interrupt mask/enable bit for all the transcoders.
 *
 * Returns the previous state of underrun reporting.
 */
bool intel_set_pch_fifo_underrun_reporting(struct drm_device *dev,
					   enum transcoder pch_transcoder,
					   bool enable)
d533 1
a533 5
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pch_transcoder];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	unsigned long flags;
	bool ret;
d536 8
a543 6
	 * NOTE: Pre-LPT has a fixed cpu pipe -> pch transcoder mapping, but LPT
	 * has only one pch transcoder A that all pipes can use. To avoid racy
	 * pch transcoder -> pipe lookups from interrupt code simply store the
	 * underrun statistics in crtc A. Since we never expose this anywhere
	 * nor use it outside of the fifo underrun code here using the "wrong"
	 * crtc on LPT won't cause issues.
d545 2
d548 7
a554 3
	spin_lock_irqsave(&dev_priv->irq_lock, flags);

	ret = !intel_crtc->pch_fifo_underrun_disabled;
d556 1
a556 13
	if (enable == ret)
		goto done;

	intel_crtc->pch_fifo_underrun_disabled = !enable;

	if (HAS_PCH_IBX(dev))
		ibx_set_fifo_underrun_reporting(dev, pch_transcoder, enable);
	else
		cpt_set_fifo_underrun_reporting(dev, pch_transcoder, enable);

done:
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
	return ret;
a558 1

d560 2
a561 1
i915_enable_pipestat(drm_i915_private_t *dev_priv, enum pipe pipe, u32 mask)
d563 1
a563 2
	u32 reg = PIPESTAT(pipe);
	u32 pipestat = I915_READ(reg) & 0x7fff0000;
d565 6
a570 9
	assert_spin_locked(&dev_priv->irq_lock);

	if ((pipestat & mask) == mask)
		return;

	/* Enable the interrupt, clear any pending status */
	pipestat |= mask | (mask >> 16);
	I915_WRITE(reg, pipestat);
	POSTING_READ(reg);
d574 2
a575 1
i915_disable_pipestat(drm_i915_private_t *dev_priv, enum pipe pipe, u32 mask)
d577 1
a577 2
	u32 reg = PIPESTAT(pipe);
	u32 pipestat = I915_READ(reg) & 0x7fff0000;
d579 6
a584 8
	assert_spin_locked(&dev_priv->irq_lock);

	if ((pipestat & mask) == 0)
		return;

	pipestat &= ~mask;
	I915_WRITE(reg, pipestat);
	POSTING_READ(reg);
d589 1
d593 1
a593 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long irqflags;
d598 1
a598 1
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
d600 1
a600 1
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_LEGACY_BLC_EVENT_ENABLE);
d603 1
a603 1
				     PIPE_LEGACY_BLC_EVENT_ENABLE);
d605 1
a605 1
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d608 41
a648 4
/**
 * i915_pipe_enabled - check if a pipe is enabled
 * @@dev: DRM device
 * @@pipe: pipe to check
d650 6
a655 3
 * Reading certain registers when the pipe is disabled can hang the chip.
 * Use this routine to make sure the PLL is running and the pipe is active
 * before reading such registers if unsure.
a656 9
static int
i915_pipe_enabled(struct drm_device *dev, int pipe)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;

	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
		/* Locking is horribly broken here, but whatever. */
		struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
d658 1
a658 7
		return intel_crtc->active;
	} else {
		return I915_READ(PIPECONF(pipe)) & PIPECONF_ENABLE;
	}
}

static u32 i8xx_get_vblank_counter(struct drm_device *dev, int pipe)
d667 1
a667 1
static u32 i915_get_vblank_counter(struct drm_device *dev, int pipe)
d669 1
a669 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d672 4
a675 1
	u32 high1, high2, low, pixel, vbl_start;
d677 5
a681 5
	if (!i915_pipe_enabled(dev, pipe)) {
		DRM_DEBUG_DRIVER("trying to get vblank count for disabled "
				"pipe %c\n", pipe_name(pipe));
		return 0;
	}
d683 2
a684 5
	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
		struct intel_crtc *intel_crtc =
			to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
		const struct drm_display_mode *mode =
			&intel_crtc->config.adjusted_mode;
d686 2
a687 10
		vbl_start = mode->crtc_vblank_start * mode->crtc_htotal;
	} else {
		enum transcoder cpu_transcoder = (enum transcoder) pipe;
		u32 htotal;

		htotal = ((I915_READ(HTOTAL(cpu_transcoder)) >> 16) & 0x1fff) + 1;
		vbl_start = (I915_READ(VBLANK(cpu_transcoder)) & 0x1fff) + 1;

		vbl_start *= htotal;
	}
d715 1
a715 1
static u32 gm45_get_vblank_counter(struct drm_device *dev, int pipe)
d717 1
a717 8
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int reg = PIPE_FRMCOUNT_GM45(pipe);

	if (!i915_pipe_enabled(dev, pipe)) {
		DRM_DEBUG_DRIVER("trying to get vblank count for disabled "
				 "pipe %c\n", pipe_name(pipe));
		return 0;
	}
d719 1
a719 1
	return I915_READ(reg);
d723 3
d727 1
d729 1
a729 1
static bool ilk_pipe_in_vblank_locked(struct drm_device *dev, enum pipe pipe)
d731 1
d733 27
a759 2
	uint32_t status;
	int reg;
d761 9
a769 9
	if (INTEL_INFO(dev)->gen >= 8) {
		status = GEN8_PIPE_VBLANK;
		reg = GEN8_DE_PIPE_ISR(pipe);
	} else if (INTEL_INFO(dev)->gen >= 7) {
		status = DE_PIPE_VBLANK_IVB(pipe);
		reg = DEISR;
	} else {
		status = DE_PIPE_VBLANK(pipe);
		reg = DEISR;
d772 5
a776 1
	return __raw_i915_read32(dev_priv, reg) & status;
d779 1
a779 1
static int i915_get_crtc_scanoutpos(struct drm_device *dev, int pipe,
d781 2
a782 1
				    ktime_t *stime, ktime_t *etime)
a786 1
	const struct drm_display_mode *mode = &intel_crtc->config.adjusted_mode;
d788 1
a788 1
	int vbl_start, vbl_end, htotal, vtotal;
d793 1
a793 1
	if (!intel_crtc->active) {
d800 1
d819 1
a819 1
	
d830 1
a830 62
		if (IS_GEN2(dev))
			position = __raw_i915_read32(dev_priv, PIPEDSL(pipe)) & DSL_LINEMASK_GEN2;
		else
			position = __raw_i915_read32(dev_priv, PIPEDSL(pipe)) & DSL_LINEMASK_GEN3;

		if (HAS_DDI(dev)) {
			/*
			 * On HSW HDMI outputs there seems to be a 2 line
			 * difference, whereas eDP has the normal 1 line
			 * difference that earlier platforms have. External
			 * DP is unknown. For now just check for the 2 line
			 * difference case on all output types on HSW+.
			 *
			 * This might misinterpret the scanline counter being
			 * one line too far along on eDP, but that's less
			 * dangerous than the alternative since that would lead
			 * the vblank timestamp code astray when it sees a
			 * scanline count before vblank_start during a vblank
			 * interrupt.
			 */
			in_vbl = ilk_pipe_in_vblank_locked(dev, pipe);
			if ((in_vbl && (position == vbl_start - 2 ||
					position == vbl_start - 1)) ||
			    (!in_vbl && (position == vbl_end - 2 ||
					 position == vbl_end - 1)))
				position = (position + 2) % vtotal;
		} else if (HAS_PCH_SPLIT(dev)) {
			/*
			 * The scanline counter increments at the leading edge
			 * of hsync, ie. it completely misses the active portion
			 * of the line. Fix up the counter at both edges of vblank
			 * to get a more accurate picture whether we're in vblank
			 * or not.
			 */
			in_vbl = ilk_pipe_in_vblank_locked(dev, pipe);
			if ((in_vbl && position == vbl_start - 1) ||
			    (!in_vbl && position == vbl_end - 1))
				position = (position + 1) % vtotal;
		} else {
			/*
			 * ISR vblank status bits don't work the way we'd want
			 * them to work on non-PCH platforms (for
			 * ilk_pipe_in_vblank_locked()), and there doesn't
			 * appear any other way to determine if we're currently
			 * in vblank.
			 *
			 * Instead let's assume that we're already in vblank if
			 * we got called from the vblank interrupt and the
			 * scanline counter value indicates that we're on the
			 * line just prior to vblank start. This should result
			 * in the correct answer, unless the vblank interrupt
			 * delivery really got delayed for almost exactly one
			 * full frame/field.
			 */
			if (flags & DRM_CALLED_FROM_VBLIRQ &&
			    position == vbl_start - 1) {
				position = (position + 1) % vtotal;

				/* Signal this correction as "applied". */
				ret |= 0x8;
			}
		}
d842 23
d898 1
a898 1
		ret |= DRM_SCANOUTPOS_INVBL;
d903 14
a916 1
static int i915_get_vblank_timestamp(struct drm_device *dev, int pipe,
d923 2
a924 2
	if (pipe < 0 || pipe >= INTEL_INFO(dev)->num_pipes) {
		DRM_ERROR("Invalid crtc %d\n", pipe);
d931 1
a931 1
		DRM_ERROR("Invalid crtc %d\n", pipe);
d935 2
a936 2
	if (!crtc->enabled) {
		DRM_DEBUG_KMS("crtc %d is disabled\n", pipe);
d943 1
a943 99
						     crtc,
						     &to_intel_crtc(crtc)->config.adjusted_mode);
}

static bool intel_hpd_irq_event(struct drm_device *dev,
				struct drm_connector *connector)
{
	enum drm_connector_status old_status;

	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
	old_status = connector->status;

	connector->status = connector->funcs->detect(connector, false);
	if (old_status == connector->status)
		return false;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
		      connector->base.id,
		      drm_get_connector_name(connector),
		      drm_get_connector_status_name(old_status),
		      drm_get_connector_status_name(connector->status));

	return true;
}

/*
 * Handle hotplug events outside the interrupt handler proper.
 */
#define I915_REENABLE_HOTPLUG_DELAY (2*60*1000)

static void i915_hotplug_work_func(struct work_struct *work)
{
	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
						    hotplug_work);
	struct drm_device *dev = dev_priv->dev;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct intel_connector *intel_connector;
	struct intel_encoder *intel_encoder;
	struct drm_connector *connector;
	unsigned long irqflags;
	bool hpd_disabled = false;
	bool changed = false;
	u32 hpd_event_bits;

	/* HPD irq before everything is fully set up. */
	if (!dev_priv->enable_hotplug_processing)
		return;

	mutex_lock(&mode_config->mutex);
	DRM_DEBUG_KMS("running encoder hotplug functions\n");

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);

	hpd_event_bits = dev_priv->hpd_event_bits;
	dev_priv->hpd_event_bits = 0;
	list_for_each_entry(connector, &mode_config->connector_list, head) {
		intel_connector = to_intel_connector(connector);
		intel_encoder = intel_connector->encoder;
		if (intel_encoder->hpd_pin > HPD_NONE &&
		    dev_priv->hpd_stats[intel_encoder->hpd_pin].hpd_mark == HPD_MARK_DISABLED &&
		    connector->polled == DRM_CONNECTOR_POLL_HPD) {
			DRM_INFO("HPD interrupt storm detected on connector %s: "
				 "switching from hotplug detection to polling\n",
				drm_get_connector_name(connector));
			dev_priv->hpd_stats[intel_encoder->hpd_pin].hpd_mark = HPD_DISABLED;
			connector->polled = DRM_CONNECTOR_POLL_CONNECT
				| DRM_CONNECTOR_POLL_DISCONNECT;
			hpd_disabled = true;
		}
		if (hpd_event_bits & (1 << intel_encoder->hpd_pin)) {
			DRM_DEBUG_KMS("Connector %s (pin %i) received hotplug event.\n",
				      drm_get_connector_name(connector), intel_encoder->hpd_pin);
		}
	}
	 /* if there were no outputs to poll, poll was disabled,
	  * therefore make sure it's enabled when disabling HPD on
	  * some connectors */
	if (hpd_disabled) {
		drm_kms_helper_poll_enable(dev);
		mod_timer(&dev_priv->hotplug_reenable_timer,
			  jiffies + msecs_to_jiffies(I915_REENABLE_HOTPLUG_DELAY));
	}

	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);

	list_for_each_entry(connector, &mode_config->connector_list, head) {
		intel_connector = to_intel_connector(connector);
		intel_encoder = intel_connector->encoder;
		if (hpd_event_bits & (1 << intel_encoder->hpd_pin)) {
			if (intel_encoder->hot_plug)
				intel_encoder->hot_plug(intel_encoder);
			if (intel_hpd_irq_event(dev, connector))
				changed = true;
		}
	}
	mutex_unlock(&mode_config->mutex);

	if (changed)
		drm_kms_helper_hotplug_event(dev);
d948 1
a948 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d985 1
a985 2
static void notify_ring(struct drm_device *dev,
			struct intel_ring_buffer *ring)
d987 1
a987 1
	if (ring->obj == NULL)
d990 1
a990 1
	trace_i915_gem_request_complete(ring);
d993 68
a1060 1
	i915_queue_hangcheck(dev);
d1065 4
a1068 2
	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
						    rps.work);
a1069 1
	int new_delay, adj;
d1072 5
d1079 4
a1082 2
	/* Make sure not to corrupt PMIMR state used by ringbuffer code */
	snb_enable_pm_irq(dev_priv, GEN6_PM_RPS_EVENTS);
d1086 1
a1086 1
	WARN_ON(pm_iir & ~GEN6_PM_RPS_EVENTS);
d1088 1
a1088 1
	if ((pm_iir & GEN6_PM_RPS_EVENTS) == 0)
d1093 2
d1096 8
a1103 1
	if (pm_iir & GEN6_PM_RP_UP_THRESHOLD) {
d1106 2
a1107 4
		else
			adj = 1;
		new_delay = dev_priv->rps.cur_delay + adj;

d1112 6
a1117 2
		if (new_delay < dev_priv->rps.rpe_delay)
			new_delay = dev_priv->rps.rpe_delay;
d1119 2
a1120 2
		if (dev_priv->rps.cur_delay > dev_priv->rps.rpe_delay)
			new_delay = dev_priv->rps.rpe_delay;
d1122 1
a1122 1
			new_delay = dev_priv->rps.min_delay;
d1127 2
a1128 3
		else
			adj = -1;
		new_delay = dev_priv->rps.cur_delay + adj;
d1130 1
a1130 1
		new_delay = dev_priv->rps.cur_delay;
d1133 2
d1138 2
a1139 3
	new_delay = clamp_t(int, new_delay,
			    dev_priv->rps.min_delay, dev_priv->rps.max_delay);
	dev_priv->rps.last_adj = new_delay - dev_priv->rps.cur_delay;
d1141 1
a1141 4
	if (IS_VALLEYVIEW(dev_priv->dev))
		valleyview_set_rps(dev_priv->dev, new_delay);
	else
		gen6_set_rps(dev_priv->dev, new_delay);
d1158 2
a1159 3
#ifdef notyet
	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
						    l3_parity.error_work);
d1161 1
d1163 1
a1164 1
	unsigned long flags;
d1200 1
d1210 1
d1215 1
d1220 1
d1227 3
a1229 3
	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	ilk_enable_gt_irq(dev_priv, GT_PARITY_ERROR(dev_priv->dev));
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
a1231 1
#endif
d1236 1
a1236 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d1242 1
a1242 1
	ilk_disable_gt_irq(dev_priv, GT_PARITY_ERROR(dev));
d1261 1
a1261 1
		notify_ring(dev, &dev_priv->ring[RCS]);
d1263 1
a1263 1
		notify_ring(dev, &dev_priv->ring[VCS]);
d1273 1
a1273 1
		notify_ring(dev, &dev_priv->ring[RCS]);
d1275 1
a1275 1
		notify_ring(dev, &dev_priv->ring[VCS]);
d1277 1
a1277 1
		notify_ring(dev, &dev_priv->ring[BCS]);
d1281 2
a1282 4
		      GT_RENDER_CS_MASTER_ERROR_INTERRUPT)) {
		DRM_ERROR("GT error interrupt 0x%08x\n", gt_iir);
		i915_handle_error(dev, false);
	}
d1288 1
a1288 2
static irqreturn_t gen8_gt_irq_handler(struct drm_device *dev,
				       struct drm_i915_private *dev_priv,
a1290 2
	u32 rcs, bcs, vcs;
	uint32_t tmp = 0;
d1294 1
a1294 1
		tmp = I915_READ(GEN8_GT_IIR(0));
d1296 1
d1298 10
a1307 7
			rcs = tmp >> GEN8_RCS_IRQ_SHIFT;
			bcs = tmp >> GEN8_BCS_IRQ_SHIFT;
			if (rcs & GT_RENDER_USER_INTERRUPT)
				notify_ring(dev, &dev_priv->ring[RCS]);
			if (bcs & GT_RENDER_USER_INTERRUPT)
				notify_ring(dev, &dev_priv->ring[BCS]);
			I915_WRITE(GEN8_GT_IIR(0), tmp);
d1312 2
a1313 2
	if (master_ctl & GEN8_GT_VCS1_IRQ) {
		tmp = I915_READ(GEN8_GT_IIR(1));
d1315 1
d1317 10
a1326 4
			vcs = tmp >> GEN8_VCS1_IRQ_SHIFT;
			if (vcs & GT_RENDER_USER_INTERRUPT)
				notify_ring(dev, &dev_priv->ring[VCS]);
			I915_WRITE(GEN8_GT_IIR(1), tmp);
d1332 1
a1332 1
		tmp = I915_READ(GEN8_GT_IIR(3));
d1334 1
d1336 5
a1340 4
			vcs = tmp >> GEN8_VECS_IRQ_SHIFT;
			if (vcs & GT_RENDER_USER_INTERRUPT)
				notify_ring(dev, &dev_priv->ring[VECS]);
			I915_WRITE(GEN8_GT_IIR(3), tmp);
d1345 90
a1434 1
	return ret;
d1437 11
a1447 6
#define HPD_STORM_DETECT_PERIOD 1000
#define HPD_STORM_THRESHOLD 5

static inline void intel_hpd_irq_handler(struct drm_device *dev,
					 u32 hotplug_trigger,
					 const u32 *hpd)
d1449 1
a1449 1
	drm_i915_private_t *dev_priv = dev->dev_private;
a1450 1
	bool storm_detected = false;
d1452 3
a1454 17
	if (!hotplug_trigger)
		return;

	spin_lock(&dev_priv->irq_lock);
	for (i = 1; i < HPD_NUM_PINS; i++) {

		if (hpd[i] & hotplug_trigger &&
		    dev_priv->hpd_stats[i].hpd_mark == HPD_DISABLED) {
			/*
			 * On GMCH platforms the interrupt mask bits only
			 * prevent irq generation, not the setting of the
			 * hotplug bits itself. So only WARN about unexpected
			 * interrupts on saner platforms.
			 */
			WARN_ONCE(INTEL_INFO(dev)->gen >= 5 && !IS_VALLEYVIEW(dev),
				  "Received HPD interrupt (0x%08x) on pin %d (0x%08x) although disabled\n",
				  hotplug_trigger, i, hpd[i]);
d1456 1
a1456 2
			continue;
		}
d1458 1
a1458 2
		if (!(hpd[i] & hotplug_trigger) ||
		    dev_priv->hpd_stats[i].hpd_mark != HPD_ENABLED)
d1461 2
a1462 17
		dev_priv->hpd_event_bits |= (1 << i);
		if (!time_in_range(jiffies, dev_priv->hpd_stats[i].hpd_last_jiffies,
				   dev_priv->hpd_stats[i].hpd_last_jiffies
				   + msecs_to_jiffies(HPD_STORM_DETECT_PERIOD))) {
			dev_priv->hpd_stats[i].hpd_last_jiffies = jiffies;
			dev_priv->hpd_stats[i].hpd_cnt = 0;
			DRM_DEBUG_KMS("Received HPD interrupt on PIN %d - cnt: 0\n", i);
		} else if (dev_priv->hpd_stats[i].hpd_cnt > HPD_STORM_THRESHOLD) {
			dev_priv->hpd_stats[i].hpd_mark = HPD_MARK_DISABLED;
			dev_priv->hpd_event_bits &= ~(1 << i);
			DRM_DEBUG_KMS("HPD interrupt storm detected on PIN %d\n", i);
			storm_detected = true;
		} else {
			dev_priv->hpd_stats[i].hpd_cnt++;
			DRM_DEBUG_KMS("Received HPD interrupt on PIN %d - cnt: %d\n", i,
				      dev_priv->hpd_stats[i].hpd_cnt);
		}
d1465 2
a1466 3
	if (storm_detected)
		dev_priv->display.hpd_irq_setup(dev);
	spin_unlock(&dev_priv->irq_lock);
a1467 7
	/*
	 * Our hotplug handler can grab modeset locks (by calling down into the
	 * fb helpers). Hence it must not be run on our own dev-priv->wq work
	 * queue for otherwise the flush_work in the pageflip code will
	 * deadlock.
	 */
	schedule_work(&dev_priv->hotplug_work);
d1472 1
a1472 1
	struct drm_i915_private *dev_priv = (drm_i915_private_t *) dev->dev_private;
d1479 1
a1479 1
	struct drm_i915_private *dev_priv = (drm_i915_private_t *) dev->dev_private;
d1499 1
a1499 1
		DRM_ERROR("spurious interrupt\n");
d1585 1
a1585 1
	if (pm_iir & GEN6_PM_RPS_EVENTS) {
d1587 5
a1591 2
		dev_priv->rps.pm_iir |= pm_iir & GEN6_PM_RPS_EVENTS;
		snb_disable_pm_irq(dev_priv, pm_iir & GEN6_PM_RPS_EVENTS);
d1593 1
d1595 2
a1596 2
		queue_work(dev_priv->wq, &dev_priv->rps.work);
	}
d1600 79
a1678 1
			notify_ring(dev_priv->dev, &dev_priv->ring[VECS]);
d1680 45
a1724 3
		if (pm_iir & PM_VEBOX_CS_ERROR_INTERRUPT) {
			DRM_ERROR("VEBOX CS error interrupt 0x%08x\n", pm_iir);
			i915_handle_error(dev_priv->dev, false);
d1731 2
a1732 2
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a1734 3
	unsigned long irqflags;
	int pipe;
	u32 pipe_stats[I915_MAX_PIPES];
d1736 2
a1737 1
	atomic_inc(&dev_priv->irq_received);
d1740 2
a1741 1
		iir = I915_READ(VLV_IIR);
d1743 3
d1747 10
d1763 8
a1770 1
		snb_gt_irq_handler(dev, dev_priv, gt_iir);
d1772 3
a1774 4
		spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
		for_each_pipe(pipe) {
			int reg = PIPESTAT(pipe);
			pipe_stats[pipe] = I915_READ(reg);
d1776 6
a1781 11
			/*
			 * Clear the PIPE*STAT regs before the IIR
			 */
			if (pipe_stats[pipe] & 0x8000ffff) {
				if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
					DRM_DEBUG_DRIVER("pipe %c underrun\n",
							 pipe_name(pipe));
				I915_WRITE(reg, pipe_stats[pipe]);
			}
		}
		spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d1783 2
a1784 3
		for_each_pipe(pipe) {
			if (pipe_stats[pipe] & PIPE_START_VBLANK_INTERRUPT_STATUS)
				drm_handle_vblank(dev, pipe);
d1786 3
a1788 4
			if (pipe_stats[pipe] & PLANE_FLIPDONE_INT_STATUS_VLV) {
				intel_prepare_page_flip(dev, pipe);
				intel_finish_page_flip(dev, pipe);
			}
d1790 2
a1791 3
			if (pipe_stats[pipe] & PIPE_CRC_DONE_INTERRUPT_STATUS)
				i9xx_pipe_crc_irq_handler(dev, pipe);
		}
d1793 1
a1793 7
		/* Consume port.  Then clear IIR or we'll miss events */
		if (iir & I915_DISPLAY_PORT_INTERRUPT) {
			u32 hotplug_status = I915_READ(PORT_HOTPLUG_STAT);
			u32 hotplug_trigger = hotplug_status & HOTPLUG_INT_STATUS_I915;

			DRM_DEBUG_DRIVER("hotplug event received, stat 0x%08x\n",
					 hotplug_status);
d1795 1
a1795 1
			intel_hpd_irq_handler(dev, hotplug_trigger, hpd_status_i915);
d1797 1
a1797 2
			if (hotplug_status & DP_AUX_CHANNEL_MASK_INT_STATUS_G4X)
				dp_aux_irq_handler(dev);
d1799 5
a1803 2
			I915_WRITE(PORT_HOTPLUG_STAT, hotplug_status);
			I915_READ(PORT_HOTPLUG_STAT);
d1806 1
a1806 2
		if (pipe_stats[0] & PIPE_GMBUS_INTERRUPT_STATUS)
			gmbus_irq_handler(dev);
d1808 3
a1810 2
		if (pm_iir)
			gen6_rps_irq_handler(dev_priv, pm_iir);
d1812 2
a1813 3
		I915_WRITE(GTIIR, gt_iir);
		I915_WRITE(GEN6_PMIIR, pm_iir);
		I915_WRITE(VLV_IIR, iir);
a1815 1
out:
d1819 16
d1837 1
a1837 3
#ifdef DRMDEBUG
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
#endif
d1841 2
a1842 1
	intel_hpd_irq_handler(dev, hotplug_trigger, hpd_ibx);
d1844 1
a1844 1
#ifdef notyet
d1869 1
a1869 1
		for_each_pipe(pipe)
d1881 1
a1881 3
		if (intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_A,
							  false))
			DRM_DEBUG_DRIVER("PCH transcoder A FIFO underrun\n");
d1884 1
a1884 3
		if (intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_B,
							  false))
			DRM_DEBUG_DRIVER("PCH transcoder B FIFO underrun\n");
d1896 3
a1898 7
	for_each_pipe(pipe) {
		if (err_int & ERR_INT_FIFO_UNDERRUN(pipe)) {
			if (intel_set_cpu_fifo_underrun_reporting(dev, pipe,
								  false))
				DRM_DEBUG_DRIVER("Pipe %c FIFO underrun\n",
						 pipe_name(pipe));
		}
d1920 1
a1920 3
		if (intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_A,
							  false))
			DRM_DEBUG_DRIVER("PCH transcoder A FIFO underrun\n");
d1923 1
a1923 3
		if (intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_B,
							  false))
			DRM_DEBUG_DRIVER("PCH transcoder B FIFO underrun\n");
d1926 1
a1926 3
		if (intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_C,
							  false))
			DRM_DEBUG_DRIVER("PCH transcoder C FIFO underrun\n");
d1933 1
a1933 3
#ifdef DRMDEBUG
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
#endif
d1937 2
a1938 1
	intel_hpd_irq_handler(dev, hotplug_trigger, hpd_cpt);
d1940 1
a1940 1
#ifdef notyet
d1962 1
a1962 1
		for_each_pipe(pipe)
d1971 53
d2028 4
d2042 4
a2045 3
	for_each_pipe(pipe) {
		if (de_iir & DE_PIPE_VBLANK(pipe))
			drm_handle_vblank(dev, pipe);
d2048 1
a2048 3
			if (intel_set_cpu_fifo_underrun_reporting(dev, pipe, false))
				DRM_DEBUG_DRIVER("Pipe %c FIFO underrun\n",
						 pipe_name(pipe));
d2080 5
a2084 1
	enum pipe i;
d2095 4
a2098 3
	for_each_pipe(i) {
		if (de_iir & (DE_PIPE_VBLANK_IVB(i)))
			drm_handle_vblank(dev, i);
d2101 3
a2103 3
		if (de_iir & DE_PLANE_FLIP_DONE_IVB(i)) {
			intel_prepare_page_flip(dev, i);
			intel_finish_page_flip_plane(dev, i);
d2118 8
d2128 2
a2129 2
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d2133 2
a2134 1
	atomic_inc(&dev_priv->irq_received);
d2156 2
d2160 2
a2165 2
		I915_WRITE(GTIIR, gt_iir);
		ret = IRQ_HANDLED;
d2170 2
a2175 2
		I915_WRITE(DEIIR, de_iir);
		ret = IRQ_HANDLED;
a2180 1
			gen6_rps_irq_handler(dev_priv, pm_iir);
d2183 1
d2197 16
d2221 4
d2226 3
a2228 1
	atomic_inc(&dev_priv->irq_received);
d2230 1
a2230 1
	master_ctl = I915_READ(GEN8_MASTER_IRQ);
d2235 3
a2237 2
	I915_WRITE(GEN8_MASTER_IRQ, 0);
	POSTING_READ(GEN8_MASTER_IRQ);
d2239 1
a2239 1
	ret = gen8_gt_irq_handler(dev, dev_priv, master_ctl);
a2242 7
		if (tmp & GEN8_DE_MISC_GSE)
			intel_opregion_asle_intr(dev);
		else if (tmp)
			DRM_ERROR("Unexpected DE Misc interrupt\n");
		else
			DRM_ERROR("The master control interrupt lied (DE MISC)!\n");

d2246 4
d2251 2
d2257 8
a2264 6
		if (tmp & GEN8_AUX_CHANNEL_A)
			dp_aux_irq_handler(dev);
		else if (tmp)
			DRM_ERROR("Unexpected DE Port interrupt\n");
		else
			DRM_ERROR("The master control interrupt lied (DE PORT)!\n");
a2265 1
		if (tmp) {
d2268 21
d2290 2
d2294 2
a2295 2
	for_each_pipe(pipe) {
		uint32_t pipe_iir;
d2301 17
a2317 2
		if (pipe_iir & GEN8_PIPE_VBLANK)
			drm_handle_vblank(dev, pipe);
d2319 2
a2320 4
		if (pipe_iir & GEN8_PIPE_FLIP_DONE) {
			intel_prepare_page_flip(dev, pipe);
			intel_finish_page_flip_plane(dev, pipe);
		}
d2322 3
a2324 2
		if (pipe_iir & GEN8_PIPE_CDCLK_CRC_DONE)
			hsw_pipe_crc_irq_handler(dev, pipe);
a2325 6
		if (pipe_iir & GEN8_PIPE_FIFO_UNDERRUN) {
			if (intel_set_cpu_fifo_underrun_reporting(dev, pipe,
								  false))
				DRM_DEBUG_DRIVER("Pipe %c FIFO underrun\n",
						 pipe_name(pipe));
		}
d2327 4
a2330 5
		if (pipe_iir & GEN8_DE_PIPE_IRQ_FAULT_ERRORS) {
			DRM_ERROR("Fault errors on pipe %c\n: 0x%08x",
				  pipe_name(pipe),
				  pipe_iir & GEN8_DE_PIPE_IRQ_FAULT_ERRORS);
		}
d2332 4
a2335 3
		if (pipe_iir) {
			ret = IRQ_HANDLED;
			I915_WRITE(GEN8_DE_PIPE_IIR(pipe), pipe_iir);
d2340 2
a2341 1
	if (!HAS_PCH_NOP(dev) && master_ctl & GEN8_DE_PCH_IRQ) {
d2348 3
d2352 10
a2361 5
		cpt_irq_handler(dev, pch_iir);

		if (pch_iir) {
			I915_WRITE(SDEIIR, pch_iir);
			ret = IRQ_HANDLED;
d2365 2
a2366 2
	I915_WRITE(GEN8_MASTER_IRQ, GEN8_MASTER_IRQ_CONTROL);
	POSTING_READ(GEN8_MASTER_IRQ);
d2374 1
a2374 1
	struct intel_ring_buffer *ring;
d2400 2
a2401 2
 * i915_error_work_func - do process context error handling work
 * @@work: work struct
d2406 1
a2406 1
static void i915_error_work_func(struct work_struct *work)
d2408 3
a2410 6
	struct i915_gpu_error *error = container_of(work, struct i915_gpu_error,
						    work);
	drm_i915_private_t *dev_priv = container_of(error, drm_i915_private_t,
						    gpu_error);
	struct drm_device *dev = dev_priv->dev;
#ifdef notyet
d2439 11
d2457 3
a2459 1
		intel_display_handle_reset(dev);
d2472 1
a2472 1
			smp_mb__before_atomic_inc();
d2480 1
a2480 1
			atomic_set_mask(I915_WEDGED, &error->reset_counter);
d2539 1
a2539 1
		for_each_pipe(pipe)
d2584 1
a2584 1
 * i915_handle_error - handle an error interrupt
d2587 1
a2587 1
 * Do some basic checking of regsiter state at error interrupt time and
d2593 2
a2594 1
void i915_handle_error(struct drm_device *dev, bool wedged)
d2597 6
d2604 1
a2604 1
	i915_capture_error_state(dev);
d2608 1
a2608 1
		atomic_set_mask(I915_RESET_IN_PROGRESS_FLAG,
d2612 3
a2614 3
		 * Wakeup waiting processes so that the reset work function
		 * i915_error_work_func doesn't deadlock trying to grab various
		 * locks. By bumping the reset counter first, the woken
d2627 1
a2627 53
	/*
	 * Our reset work can grab modeset locks (since it needs to reset the
	 * state of outstanding pagelips). Hence it must not be run on our own
	 * dev-priv->wq work queue for otherwise the flush_work in the pageflip
	 * code will deadlock.
	 */
	schedule_work(&dev_priv->gpu_error.work);
}

static void __always_unused i915_pageflip_stall_check(struct drm_device *dev, int pipe)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_i915_gem_object *obj;
	struct intel_unpin_work *work;
	unsigned long flags;
	bool stall_detected;

	/* Ignore early vblank irqs */
	if (intel_crtc == NULL)
		return;

	spin_lock_irqsave(&dev->event_lock, flags);
	work = intel_crtc->unpin_work;

	if (work == NULL ||
	    atomic_read(&work->pending) >= INTEL_FLIP_COMPLETE ||
	    !work->enable_stall_check) {
		/* Either the pending flip IRQ arrived, or we're too early. Don't check */
		spin_unlock_irqrestore(&dev->event_lock, flags);
		return;
	}

	/* Potential stall - if we see that the flip has happened, assume a missed interrupt */
	obj = work->pending_flip_obj;
	if (INTEL_INFO(dev)->gen >= 4) {
		int dspsurf = DSPSURF(intel_crtc->plane);
		stall_detected = I915_HI_DISPBASE(I915_READ(dspsurf)) ==
					i915_gem_obj_ggtt_offset(obj);
	} else {
		int dspaddr = DSPADDR(intel_crtc->plane);
		stall_detected = I915_READ(dspaddr) == (i915_gem_obj_ggtt_offset(obj) +
							crtc->y * crtc->fb->pitches[0] +
							crtc->x * crtc->fb->bits_per_pixel/8);
	}

	spin_unlock_irqrestore(&dev->event_lock, flags);

	if (stall_detected) {
		DRM_DEBUG_DRIVER("Pageflip stall detected\n");
		intel_prepare_page_flip(dev, intel_crtc->plane);
	}
d2633 1
a2633 1
static int i915_enable_vblank(struct drm_device *dev, int pipe)
d2635 1
a2635 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2637 3
	if (!i915_pipe_enabled(dev, pipe))
		return -EINVAL;

d2641 1
a2641 1
				     PIPE_START_VBLANK_INTERRUPT_ENABLE);
d2644 1
a2644 5
				     PIPE_VBLANK_INTERRUPT_ENABLE);

	/* maintain vblank delivery even in deep C-states */
	if (dev_priv->info->gen == 3)
		I915_WRITE(INSTPM, _MASKED_BIT_DISABLE(INSTPM_AGPBUSY_DIS));
d2650 1
a2650 1
static int ironlake_enable_vblank(struct drm_device *dev, int pipe)
d2652 1
a2652 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2656 3
	if (!i915_pipe_enabled(dev, pipe))
		return -EINVAL;

d2664 1
a2664 1
static int valleyview_enable_vblank(struct drm_device *dev, int pipe)
d2666 1
a2666 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2667 4
	u32 imr;

	if (!i915_pipe_enabled(dev, pipe))
		return -EINVAL;
a2669 6
	imr = I915_READ(VLV_IMR);
	if (pipe == PIPE_A)
		imr &= ~I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT;
	else
		imr &= ~I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
	I915_WRITE(VLV_IMR, imr);
d2671 1
a2671 1
			     PIPE_START_VBLANK_INTERRUPT_ENABLE);
d2677 1
a2677 1
static int gen8_enable_vblank(struct drm_device *dev, int pipe)
a2681 3
	if (!i915_pipe_enabled(dev, pipe))
		return -EINVAL;

d2693 1
a2693 1
static void i915_disable_vblank(struct drm_device *dev, int pipe)
d2695 1
a2695 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2698 3
	if (dev_priv->info->gen == 3)
		I915_WRITE(INSTPM, _MASKED_BIT_ENABLE(INSTPM_AGPBUSY_DIS));

d2700 2
a2701 2
			      PIPE_VBLANK_INTERRUPT_ENABLE |
			      PIPE_START_VBLANK_INTERRUPT_ENABLE);
d2705 1
a2705 1
static void ironlake_disable_vblank(struct drm_device *dev, int pipe)
d2707 1
a2707 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d2717 1
a2717 1
static void valleyview_disable_vblank(struct drm_device *dev, int pipe)
d2719 1
a2719 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2720 1
	u32 imr;
d2724 1
a2724 7
			      PIPE_START_VBLANK_INTERRUPT_ENABLE);
	imr = I915_READ(VLV_IMR);
	if (pipe == PIPE_A)
		imr |= I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT;
	else
		imr |= I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
	I915_WRITE(VLV_IMR, imr);
d2728 1
a2728 1
static void gen8_disable_vblank(struct drm_device *dev, int pipe)
a2732 3
	if (!i915_pipe_enabled(dev, pipe))
		return;

d2740 2
a2741 2
static u32
ring_last_seqno(struct intel_ring_buffer *ring)
d2743 2
a2744 2
	return list_entry(ring->request_list.prev,
			  struct drm_i915_gem_request, list)->seqno;
d2748 13
a2760 1
ring_idle(struct intel_ring_buffer *ring, u32 seqno)
d2762 28
a2789 2
	return (list_empty(&ring->request_list) ||
		i915_seqno_passed(seqno, ring_last_seqno(ring)));
d2792 2
a2793 2
static struct intel_ring_buffer *
semaphore_waits_for(struct intel_ring_buffer *ring, u32 *seqno)
d2796 23
a2818 1
	u32 cmd, ipehr, acthd, acthd_min;
d2821 1
a2821 2
	if ((ipehr & ~(0x3 << 16)) !=
	    (MI_SEMAPHORE_MBOX | MI_SEMAPHORE_COMPARE | MI_SEMAPHORE_REGISTER))
d2824 7
a2830 2
	/* ACTHD is likely pointing to the dword after the actual command,
	 * so scan backwards until we find the MBOX.
d2832 13
a2844 4
	acthd = intel_ring_get_active_head(ring) & HEAD_ADDR;
	acthd_min = max((int)acthd - 3 * 4, 0);
	do {
		cmd = ioread32(ring->virtual_start + acthd);
d2848 5
a2852 4
		acthd -= 4;
		if (acthd < acthd_min)
			return NULL;
	} while (1);
d2854 7
a2860 2
	*seqno = ioread32(ring->virtual_start+acthd+4)+1;
	return &dev_priv->ring[(ring->id + (((ipehr >> 17) & 1) + 1)) % 3];
d2863 1
a2863 1
static int semaphore_passed(struct intel_ring_buffer *ring)
d2866 2
a2867 2
	struct intel_ring_buffer *signaller;
	u32 seqno, ctl;
d2869 1
a2869 1
	ring->hangcheck.deadlock = true;
d2872 1
a2872 1
	if (signaller == NULL || signaller->hangcheck.deadlock)
d2875 7
d2883 2
a2884 2
	ctl = I915_READ_CTL(signaller);
	if (ctl & RING_WAIT_SEMAPHORE && semaphore_passed(signaller) < 0)
d2887 1
a2887 1
	return i915_seqno_passed(signaller->get_seqno(signaller, false), seqno);
d2892 1
a2892 1
	struct intel_ring_buffer *ring;
d2896 1
a2896 1
		ring->hangcheck.deadlock = false;
d2900 1
a2900 1
ring_stuck(struct intel_ring_buffer *ring, u32 acthd)
d2906 8
a2913 2
	if (ring->hangcheck.acthd != acthd)
		return HANGCHECK_ACTIVE;
d2925 3
a2927 3
		DRM_ERROR("Kicking stuck wait on %s\n",
			  ring->name);
		i915_handle_error(dev, false);
d2937 3
a2939 3
			DRM_ERROR("Kicking stuck semaphore on %s\n",
				  ring->name);
			i915_handle_error(dev, false);
d2950 1
a2950 1
/**
d2958 1
a2958 1
static void i915_hangcheck_elapsed(unsigned long data)
d2960 5
a2964 3
	struct drm_device *dev = (struct drm_device *)data;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
a2970 1
#define FIRE 30
d2972 1
a2972 1
	if (!i915_enable_hangcheck)
d2976 2
a2977 1
		u32 seqno, acthd;
d3026 1
d3028 1
a3028 1
				case HANGCHECK_ACTIVE:
d3048 2
d3058 1
a3058 1
		if (ring->hangcheck.score > FIRE) {
d3067 1
a3067 1
		return i915_handle_error(dev, true);
d3077 16
d3094 2
a3095 1
	if (!i915_enable_hangcheck)
d3098 4
a3101 2
	mod_timer(&dev_priv->gpu_error.hangcheck_timer,
		  round_jiffies_up(jiffies + DRM_I915_HANGCHECK_JIFFIES));
d3104 9
a3112 1
static void ibx_irq_preinstall(struct drm_device *dev)
d3119 1
a3119 8
	/* south display irq */
	I915_WRITE(SDEIMR, 0xffffffff);
	/*
	 * SDEIER is also touched by the interrupt handler to work around missed
	 * PCH interrupts. Hence we can't update it after the interrupt handler
	 * is enabled - instead we unconditionally enable all PCH interrupt
	 * sources here, but then only unmask them as needed with SDEIMR.
	 */
d3124 1
a3124 1
static void gen5_gt_irq_preinstall(struct drm_device *dev)
d3128 3
a3130 11
	/* and GT */
	I915_WRITE(GTIMR, 0xffffffff);
	I915_WRITE(GTIER, 0x0);
	POSTING_READ(GTIER);

	if (INTEL_INFO(dev)->gen >= 6) {
		/* and PM */
		I915_WRITE(GEN6_PMIMR, 0xffffffff);
		I915_WRITE(GEN6_PMIER, 0x0);
		POSTING_READ(GEN6_PMIER);
	}
d3135 1
a3135 1
static void ironlake_irq_preinstall(struct drm_device *dev)
d3137 7
a3143 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3145 1
a3145 1
	atomic_set(&dev_priv->irq_received, 0);
d3147 6
a3152 1
	I915_WRITE(HWSTAM, 0xeffe);
d3154 2
a3155 3
	I915_WRITE(DEIMR, 0xffffffff);
	I915_WRITE(DEIER, 0x0);
	POSTING_READ(DEIER);
d3157 2
a3158 1
	gen5_gt_irq_preinstall(dev);
d3160 1
a3160 1
	ibx_irq_preinstall(dev);
d3165 1
a3165 4
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int pipe;

	atomic_set(&dev_priv->irq_received, 0);
d3173 1
a3173 3
	/* and GT */
	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIIR, I915_READ(GTIIR));
d3175 1
a3175 1
	gen5_gt_irq_preinstall(dev);
d3177 2
a3178 1
	I915_WRITE(DPINVGTT, 0xff);
d3180 6
a3185 8
	I915_WRITE(PORT_HOTPLUG_EN, 0);
	I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));
	for_each_pipe(pipe)
		I915_WRITE(PIPESTAT(pipe), 0xffff);
	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(VLV_IMR, 0xffffffff);
	I915_WRITE(VLV_IER, 0x0);
	POSTING_READ(VLV_IER);
d3188 1
a3188 1
static void gen8_irq_preinstall(struct drm_device *dev)
d3193 42
a3234 1
	atomic_set(&dev_priv->irq_received, 0);
d3239 15
a3253 33
	/* IIR can theoretically queue up two events. Be paranoid */
#define GEN8_IRQ_INIT_NDX(type, which) do { \
		I915_WRITE(GEN8_##type##_IMR(which), 0xffffffff); \
		POSTING_READ(GEN8_##type##_IMR(which)); \
		I915_WRITE(GEN8_##type##_IER(which), 0); \
		I915_WRITE(GEN8_##type##_IIR(which), 0xffffffff); \
		POSTING_READ(GEN8_##type##_IIR(which)); \
		I915_WRITE(GEN8_##type##_IIR(which), 0xffffffff); \
	} while (0)

#define GEN8_IRQ_INIT(type) do { \
		I915_WRITE(GEN8_##type##_IMR, 0xffffffff); \
		POSTING_READ(GEN8_##type##_IMR); \
		I915_WRITE(GEN8_##type##_IER, 0); \
		I915_WRITE(GEN8_##type##_IIR, 0xffffffff); \
		POSTING_READ(GEN8_##type##_IIR); \
		I915_WRITE(GEN8_##type##_IIR, 0xffffffff); \
	} while (0)

	GEN8_IRQ_INIT_NDX(GT, 0);
	GEN8_IRQ_INIT_NDX(GT, 1);
	GEN8_IRQ_INIT_NDX(GT, 2);
	GEN8_IRQ_INIT_NDX(GT, 3);

	for_each_pipe(pipe) {
		GEN8_IRQ_INIT_NDX(DE_PIPE, pipe);
	}

	GEN8_IRQ_INIT(DE_PORT);
	GEN8_IRQ_INIT(DE_MISC);
	GEN8_IRQ_INIT(PCU);
#undef GEN8_IRQ_INIT
#undef GEN8_IRQ_INIT_NDX
d3255 3
a3257 1
	POSTING_READ(GEN8_PCU_IIR);
d3259 1
a3259 1
	ibx_irq_preinstall(dev);
d3264 2
a3265 4
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct intel_encoder *intel_encoder;
	u32 hotplug_irqs, hotplug, enabled_irqs = 0;
d3269 1
a3269 3
		list_for_each_entry(intel_encoder, &mode_config->encoder_list, base.head)
			if (dev_priv->hpd_stats[intel_encoder->hpd_pin].hpd_mark == HPD_ENABLED)
				enabled_irqs |= hpd_ibx[intel_encoder->hpd_pin];
d3272 1
a3272 3
		list_for_each_entry(intel_encoder, &mode_config->encoder_list, base.head)
			if (dev_priv->hpd_stats[intel_encoder->hpd_pin].hpd_mark == HPD_ENABLED)
				enabled_irqs |= hpd_cpt[intel_encoder->hpd_pin];
d3279 2
a3280 3
	 * duration to 2ms (which is the minimum in the Display Port spec)
	 *
	 * This register is the same on all known PCH chips.
d3287 78
d3370 1
a3370 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3376 1
a3376 1
	if (HAS_PCH_IBX(dev)) {
d3378 1
a3378 1
	} else {
d3381 1
a3381 4
		I915_WRITE(SERR_INT, I915_READ(SERR_INT));
	}

	I915_WRITE(SDEIIR, I915_READ(SDEIIR));
d3407 1
a3407 4
	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
	I915_WRITE(GTIER, gt_irqs);
	POSTING_READ(GTIER);
d3410 4
a3413 2
		pm_irqs |= GEN6_PM_RPS_EVENTS;

d3418 1
a3418 4
		I915_WRITE(GEN6_PMIIR, I915_READ(GEN6_PMIIR));
		I915_WRITE(GEN6_PMIMR, dev_priv->pm_irq_mask);
		I915_WRITE(GEN6_PMIER, pm_irqs);
		POSTING_READ(GEN6_PMIER);
d3424 1
a3424 2
	unsigned long irqflags;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3433 2
a3434 3
			      DE_PIPEA_VBLANK_IVB | DE_ERR_INT_IVB);

		I915_WRITE(GEN7_ERR_INT, I915_READ(GEN7_ERR_INT));
d3441 3
a3443 2
		extra_mask = DE_PIPEA_VBLANK | DE_PIPEB_VBLANK | DE_PCU_EVENT |
				DE_PIPEB_FIFO_UNDERRUN | DE_PIPEA_FIFO_UNDERRUN;
d3448 5
a3452 5
	/* should always can generate irq */
	I915_WRITE(DEIIR, I915_READ(DEIIR));
	I915_WRITE(DEIMR, dev_priv->irq_mask);
	I915_WRITE(DEIER, display_mask | extra_mask);
	POSTING_READ(DEIER);
d3464 84
a3547 4
		spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
		ironlake_enable_display_irq(dev_priv, DE_PCU_EVENT);
		spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
	}
d3549 2
a3550 1
	return 0;
d3553 1
a3553 1
static int valleyview_irq_postinstall(struct drm_device *dev)
d3555 6
a3560 5
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	u32 enable_mask;
	u32 pipestat_enable = PLANE_FLIP_DONE_INT_EN_VLV |
		PIPE_CRC_DONE_ENABLE;
	unsigned long irqflags;
d3562 3
a3564 5
	enable_mask = I915_DISPLAY_PORT_INTERRUPT;
	enable_mask |= I915_DISPLAY_PIPE_A_EVENT_INTERRUPT |
		I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT |
		I915_DISPLAY_PIPE_B_EVENT_INTERRUPT |
		I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
d3566 3
a3568 7
	/*
	 *Leave vblank interrupts masked initially.  enable/disable will
	 * toggle them based on usage.
	 */
	dev_priv->irq_mask = (~enable_mask) |
		I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT |
		I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
d3570 1
a3570 1
	I915_WRITE(PORT_HOTPLUG_EN, 0);
d3573 3
d3577 1
a3577 5
	I915_WRITE(VLV_IER, enable_mask);
	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(PIPESTAT(0), 0xffff);
	I915_WRITE(PIPESTAT(1), 0xffff);
	POSTING_READ(VLV_IER);
d3581 9
a3589 5
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_enable_pipestat(dev_priv, PIPE_A, pipestat_enable);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_EVENT_ENABLE);
	i915_enable_pipestat(dev_priv, PIPE_B, pipestat_enable);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d3591 1
a3591 2
	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(VLV_IIR, 0xffffffff);
a3607 2
	int i;

d3611 1
d3613 2
a3614 1
			GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT,
d3616 3
a3618 1
			GT_RENDER_USER_INTERRUPT << GEN8_VCS2_IRQ_SHIFT,
d3620 2
a3621 1
		GT_RENDER_USER_INTERRUPT << GEN8_VECS_IRQ_SHIFT
d3624 9
a3632 9
	for (i = 0; i < ARRAY_SIZE(gt_interrupts); i++) {
		u32 tmp = I915_READ(GEN8_GT_IIR(i));
		if (tmp)
			DRM_ERROR("Interrupt (%d) should have been masked in pre-install 0x%08x\n",
				  i, tmp);
		I915_WRITE(GEN8_GT_IMR(i), ~gt_interrupts[i]);
		I915_WRITE(GEN8_GT_IER(i), gt_interrupts[i]);
	}
	POSTING_READ(GEN8_GT_IER(0));
d3637 27
a3663 7
	struct drm_device *dev = dev_priv->dev;
	uint32_t de_pipe_masked = GEN8_PIPE_FLIP_DONE |
		GEN8_PIPE_CDCLK_CRC_DONE |
		GEN8_DE_PIPE_IRQ_FAULT_ERRORS;
	uint32_t de_pipe_enables = de_pipe_masked | GEN8_PIPE_VBLANK |
		GEN8_PIPE_FIFO_UNDERRUN;
	int pipe;
d3668 10
a3677 17
	for_each_pipe(pipe) {
		u32 tmp = I915_READ(GEN8_DE_PIPE_IIR(pipe));
		if (tmp)
			DRM_ERROR("Interrupt (%d) should have been masked in pre-install 0x%08x\n",
				  pipe, tmp);
		I915_WRITE(GEN8_DE_PIPE_IMR(pipe), dev_priv->de_irq_mask[pipe]);
		I915_WRITE(GEN8_DE_PIPE_IER(pipe), de_pipe_enables);
	}
	POSTING_READ(GEN8_DE_PIPE_ISR(0));

	I915_WRITE(GEN8_DE_PORT_IMR, ~GEN8_AUX_CHANNEL_A);
	I915_WRITE(GEN8_DE_PORT_IER, GEN8_AUX_CHANNEL_A);
	POSTING_READ(GEN8_DE_PORT_IER);

	I915_WRITE(GEN8_DE_MISC_IMR, ~GEN8_DE_MISC_GSE);
	I915_WRITE(GEN8_DE_MISC_IER, GEN8_DE_MISC_GSE);
	POSTING_READ(GEN8_DE_MISC_IER);
d3684 3
d3690 2
a3691 1
	ibx_irq_postinstall(dev);
d3699 14
a3715 1
	int pipe;
d3720 2
a3721 1
	atomic_set(&dev_priv->irq_received, 0);
d3723 8
a3730 1
	I915_WRITE(GEN8_MASTER_IRQ, 0);
d3732 1
a3732 26
#define GEN8_IRQ_FINI_NDX(type, which) do { \
		I915_WRITE(GEN8_##type##_IMR(which), 0xffffffff); \
		I915_WRITE(GEN8_##type##_IER(which), 0); \
		I915_WRITE(GEN8_##type##_IIR(which), 0xffffffff); \
	} while (0)

#define GEN8_IRQ_FINI(type) do { \
		I915_WRITE(GEN8_##type##_IMR, 0xffffffff); \
		I915_WRITE(GEN8_##type##_IER, 0); \
		I915_WRITE(GEN8_##type##_IIR, 0xffffffff); \
	} while (0)

	GEN8_IRQ_FINI_NDX(GT, 0);
	GEN8_IRQ_FINI_NDX(GT, 1);
	GEN8_IRQ_FINI_NDX(GT, 2);
	GEN8_IRQ_FINI_NDX(GT, 3);

	for_each_pipe(pipe) {
		GEN8_IRQ_FINI_NDX(DE_PIPE, pipe);
	}

	GEN8_IRQ_FINI(DE_PORT);
	GEN8_IRQ_FINI(DE_MISC);
	GEN8_IRQ_FINI(PCU);
#undef GEN8_IRQ_FINI
#undef GEN8_IRQ_FINI_NDX
d3734 1
a3734 1
	POSTING_READ(GEN8_PCU_IIR);
d3739 1
a3739 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	int pipe;
d3744 1
a3744 1
	del_timer_sync(&dev_priv->hotplug_reenable_timer);
d3746 1
a3746 2
	for_each_pipe(pipe)
		I915_WRITE(PIPESTAT(pipe), 0xffff);
d3749 2
a3750 8
	I915_WRITE(PORT_HOTPLUG_EN, 0);
	I915_WRITE(PORT_HOTPLUG_STAT, I915_READ(PORT_HOTPLUG_STAT));
	for_each_pipe(pipe)
		I915_WRITE(PIPESTAT(pipe), 0xffff);
	I915_WRITE(VLV_IIR, 0xffffffff);
	I915_WRITE(VLV_IMR, 0xffffffff);
	I915_WRITE(VLV_IER, 0x0);
	POSTING_READ(VLV_IER);
d3753 1
a3753 1
static void ironlake_irq_uninstall(struct drm_device *dev)
d3755 1
a3755 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3760 4
a3763 1
	del_timer_sync(&dev_priv->hotplug_reenable_timer);
d3765 1
a3765 1
	I915_WRITE(HWSTAM, 0xffffffff);
d3767 2
a3768 5
	I915_WRITE(DEIMR, 0xffffffff);
	I915_WRITE(DEIER, 0x0);
	I915_WRITE(DEIIR, I915_READ(DEIIR));
	if (IS_GEN7(dev))
		I915_WRITE(GEN7_ERR_INT, I915_READ(GEN7_ERR_INT));
d3770 3
a3772 3
	I915_WRITE(GTIMR, 0xffffffff);
	I915_WRITE(GTIER, 0x0);
	I915_WRITE(GTIIR, I915_READ(GTIIR));
d3774 1
a3774 1
	if (HAS_PCH_NOP(dev))
d3777 1
a3777 5
	I915_WRITE(SDEIMR, 0xffffffff);
	I915_WRITE(SDEIER, 0x0);
	I915_WRITE(SDEIIR, I915_READ(SDEIIR));
	if (HAS_PCH_CPT(dev) || HAS_PCH_LPT(dev))
		I915_WRITE(SERR_INT, I915_READ(SERR_INT));
d3782 1
a3782 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3785 1
a3785 3
	atomic_set(&dev_priv->irq_received, 0);

	for_each_pipe(pipe)
d3794 1
a3794 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	unsigned long irqflags;
d3804 1
a3804 2
		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |
		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);
a3809 1
		     I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |
d3815 4
a3818 4
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_ENABLE);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_ENABLE);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d3829 1
a3829 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d3832 1
a3832 1
	if (!drm_handle_vblank(dev, pipe))
d3836 1
a3836 3
		return false;

	intel_prepare_page_flip(dev, plane);
d3845 1
a3845 1
		return false;
d3847 1
d3849 1
d3851 3
a3853 1
	return true;
d3858 2
a3859 2
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a3861 1
	unsigned long irqflags;
d3867 2
a3868 1
	atomic_inc(&dev_priv->irq_received);
d3880 1
a3880 1
		spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
d3882 1
a3882 1
			i915_handle_error(dev, false);
d3884 1
a3884 1
		for_each_pipe(pipe) {
d3891 1
a3891 4
			if (pipe_stats[pipe] & 0x8000ffff) {
				if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
					DRM_DEBUG_DRIVER("pipe %c underrun\n",
							 pipe_name(pipe));
a3892 1
			}
d3894 1
a3894 1
		spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
a3898 2
		i915_update_dri1_breadcrumb(dev);

d3900 1
a3900 1
			notify_ring(dev, &dev_priv->ring[RCS]);
d3902 1
a3902 1
		for_each_pipe(pipe) {
d3913 4
d3927 1
a3927 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d3930 1
a3930 1
	for_each_pipe(pipe) {
d3942 1
a3942 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a3944 2
	atomic_set(&dev_priv->irq_received, 0);

d3946 1
a3946 1
		I915_WRITE(PORT_HOTPLUG_EN, 0);
d3951 1
a3951 1
	for_each_pipe(pipe)
d3960 1
a3960 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a3961 1
	unsigned long irqflags;
d3971 1
a3971 2
		  I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT |
		  I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT);
a3976 1
		I915_RENDER_COMMAND_PARSER_ERROR_INTERRUPT |
d3980 1
a3980 1
		I915_WRITE(PORT_HOTPLUG_EN, 0);
d3997 4
a4000 4
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_ENABLE);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_ENABLE);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4011 1
a4011 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d4014 1
a4014 1
	if (!drm_handle_vblank(dev, pipe))
d4018 1
a4018 3
		return false;

	intel_prepare_page_flip(dev, plane);
d4027 1
a4027 1
		return false;
d4029 1
d4031 1
d4033 3
a4035 1
	return true;
d4040 2
a4041 2
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a4042 1
	unsigned long irqflags;
d4048 2
a4049 1
	atomic_inc(&dev_priv->irq_received);
d4061 1
a4061 1
		spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
d4063 1
a4063 1
			i915_handle_error(dev, false);
d4065 1
a4065 1
		for_each_pipe(pipe) {
a4070 3
				if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
					DRM_DEBUG_DRIVER("pipe %c underrun\n",
							 pipe_name(pipe));
d4075 1
a4075 1
		spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4081 3
a4083 13
		if ((I915_HAS_HOTPLUG(dev)) &&
		    (iir & I915_DISPLAY_PORT_INTERRUPT)) {
			u32 hotplug_status = I915_READ(PORT_HOTPLUG_STAT);
			u32 hotplug_trigger = hotplug_status & HOTPLUG_INT_STATUS_I915;

			DRM_DEBUG_DRIVER("hotplug event received, stat 0x%08x\n",
				  hotplug_status);

			intel_hpd_irq_handler(dev, hotplug_trigger, hpd_status_i915);

			I915_WRITE(PORT_HOTPLUG_STAT, hotplug_status);
			POSTING_READ(PORT_HOTPLUG_STAT);
		}
d4089 1
a4089 1
			notify_ring(dev, &dev_priv->ring[RCS]);
d4091 1
a4091 1
		for_each_pipe(pipe) {
d4105 4
a4132 2
	i915_update_dri1_breadcrumb(dev);

d4138 1
a4138 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a4140 2
	del_timer_sync(&dev_priv->hotplug_reenable_timer);

d4142 1
a4142 1
		I915_WRITE(PORT_HOTPLUG_EN, 0);
d4147 1
a4147 1
	for_each_pipe(pipe) {
d4160 1
a4160 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d4163 1
a4163 3
	atomic_set(&dev_priv->irq_received, 0);

	I915_WRITE(PORT_HOTPLUG_EN, 0);
d4167 1
a4167 1
	for_each_pipe(pipe)
d4176 1
a4176 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a4178 1
	unsigned long irqflags;
d4199 5
a4203 5
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_GMBUS_EVENT_ENABLE);
	i915_enable_pipestat(dev_priv, PIPE_A, PIPE_CRC_DONE_ENABLE);
	i915_enable_pipestat(dev_priv, PIPE_B, PIPE_CRC_DONE_ENABLE);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4224 1
a4224 1
	I915_WRITE(PORT_HOTPLUG_EN, 0);
d4234 1
a4234 3
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct intel_encoder *intel_encoder;
d4239 10
a4248 16
	if (I915_HAS_HOTPLUG(dev)) {
		hotplug_en = I915_READ(PORT_HOTPLUG_EN);
		hotplug_en &= ~HOTPLUG_INT_EN_MASK;
		/* Note HDMI and DP share hotplug bits */
		/* enable bits are the same for all generations */
		list_for_each_entry(intel_encoder, &mode_config->encoder_list, base.head)
			if (dev_priv->hpd_stats[intel_encoder->hpd_pin].hpd_mark == HPD_ENABLED)
				hotplug_en |= hpd_mask_i915[intel_encoder->hpd_pin];
		/* Programming the CRT detection parameters tends
		   to generate a spurious hotplug event about three
		   seconds later.  So just do it once.
		*/
		if (IS_G4X(dev))
			hotplug_en |= CRT_HOTPLUG_ACTIVATION_PERIOD_64;
		hotplug_en &= ~CRT_HOTPLUG_VOLTAGE_COMPARE_MASK;
		hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;
d4250 6
a4255 3
		/* Ignore TV since it's buggy */
		I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
	}
d4260 2
a4261 2
	struct drm_device *dev = (struct drm_device *) arg;
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a4263 2
	unsigned long irqflags;
	int irq_received;
d4269 2
a4270 1
	atomic_inc(&dev_priv->irq_received);
d4275 1
a4277 2
		irq_received = (iir & ~flip_mask) != 0;

d4283 1
a4283 1
		spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
d4285 1
a4285 1
			i915_handle_error(dev, false);
d4287 1
a4287 1
		for_each_pipe(pipe) {
a4294 3
				if (pipe_stats[pipe] & PIPE_FIFO_UNDERRUN_STATUS)
					DRM_DEBUG_DRIVER("pipe %c underrun\n",
							 pipe_name(pipe));
d4296 1
a4296 1
				irq_received = 1;
d4299 1
a4299 1
		spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4307 2
a4308 19
		if (iir & I915_DISPLAY_PORT_INTERRUPT) {
			u32 hotplug_status = I915_READ(PORT_HOTPLUG_STAT);
			u32 hotplug_trigger = hotplug_status & (IS_G4X(dev) ?
								  HOTPLUG_INT_STATUS_G4X :
								  HOTPLUG_INT_STATUS_I915);

			DRM_DEBUG_DRIVER("hotplug event received, stat 0x%08x\n",
				  hotplug_status);

			intel_hpd_irq_handler(dev, hotplug_trigger,
					      IS_G4X(dev) ? hpd_status_g4x : hpd_status_i915);

			if (IS_G4X(dev) &&
			    (hotplug_status & DP_AUX_CHANNEL_MASK_INT_STATUS_G4X))
				dp_aux_irq_handler(dev);

			I915_WRITE(PORT_HOTPLUG_STAT, hotplug_status);
			I915_READ(PORT_HOTPLUG_STAT);
		}
d4314 1
a4314 1
			notify_ring(dev, &dev_priv->ring[RCS]);
d4316 1
a4316 1
			notify_ring(dev, &dev_priv->ring[VCS]);
d4318 1
a4318 1
		for_each_pipe(pipe) {
d4328 3
a4332 1

a4356 2
	i915_update_dri1_breadcrumb(dev);

d4362 1
a4362 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
d4368 1
a4368 3
	del_timer_sync(&dev_priv->hotplug_reenable_timer);

	I915_WRITE(PORT_HOTPLUG_EN, 0);
d4372 1
a4372 1
	for_each_pipe(pipe)
d4377 1
a4377 1
	for_each_pipe(pipe)
d4383 8
a4390 1
static void i915_reenable_hotplug_timer_func(unsigned long data)
a4391 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *)data;
a4392 30
	struct drm_mode_config *mode_config = &dev->mode_config;
	unsigned long irqflags;
	int i;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	for (i = (HPD_NONE + 1); i < HPD_NUM_PINS; i++) {
		struct drm_connector *connector;

		if (dev_priv->hpd_stats[i].hpd_mark != HPD_DISABLED)
			continue;

		dev_priv->hpd_stats[i].hpd_mark = HPD_ENABLED;

		list_for_each_entry(connector, &mode_config->connector_list, head) {
			struct intel_connector *intel_connector = to_intel_connector(connector);

			if (intel_connector->encoder->hpd_pin == i) {
				if (connector->polled != intel_connector->polled)
					DRM_DEBUG_DRIVER("Reenabling HPD on connector %s\n",
							 drm_get_connector_name(connector));
				connector->polled = intel_connector->polled;
				if (!connector->polled)
					connector->polled = DRM_CONNECTOR_POLL_HPD;
			}
		}
	}
	if (dev_priv->display.hpd_irq_setup)
		dev_priv->display.hpd_irq_setup(dev);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}
d4394 1
a4394 3
void intel_irq_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
a4395 2
	INIT_WORK(&dev_priv->hotplug_work, i915_hotplug_work_func);
	INIT_WORK(&dev_priv->gpu_error.work, i915_error_work_func);
d4399 9
a4407 5
	setup_timer(&dev_priv->gpu_error.hangcheck_timer,
		    i915_hangcheck_elapsed,
		    (unsigned long) dev);
	setup_timer(&dev_priv->hotplug_reenable_timer, i915_reenable_hotplug_timer_func,
		    (unsigned long) dev_priv);
d4409 1
a4409 1
#ifdef notyet
d4413 1
a4413 1
	if (IS_GEN2(dev)) {
d4416 1
a4416 1
	} else if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5) {
d4418 1
a4418 1
		dev->driver->get_vblank_counter = gm45_get_vblank_counter;
d4424 10
a4433 4
	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
		dev->driver->get_vblank_timestamp = i915_get_vblank_timestamp;
		dev->driver->get_scanout_position = i915_get_crtc_scanoutpos;
	}
d4435 9
a4443 1
	if (IS_VALLEYVIEW(dev)) {
d4451 1
a4451 1
	} else if (IS_GEN8(dev)) {
d4453 1
a4453 1
		dev->driver->irq_preinstall = gen8_irq_preinstall;
d4458 6
a4463 1
		dev_priv->display.hpd_irq_setup = ibx_hpd_irq_setup;
d4466 1
a4466 1
		dev->driver->irq_preinstall = ironlake_irq_preinstall;
d4471 1
a4471 1
		dev_priv->display.hpd_irq_setup = ibx_hpd_irq_setup;
d4473 1
a4473 1
		if (INTEL_INFO(dev)->gen == 2) {
d4478 1
a4478 1
		} else if (INTEL_INFO(dev)->gen == 3) {
a4482 1
			dev_priv->display.hpd_irq_setup = i915_hpd_irq_setup;
d4488 2
a4490 1
		}
d4496 12
a4507 1
void intel_hpd_init(struct drm_device *dev)
d4509 6
a4514 5
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct drm_connector *connector;
	unsigned long irqflags;
	int i;
d4516 2
a4517 10
	for (i = 1; i < HPD_NUM_PINS; i++) {
		dev_priv->hpd_stats[i].hpd_cnt = 0;
		dev_priv->hpd_stats[i].hpd_mark = HPD_ENABLED;
	}
	list_for_each_entry(connector, &mode_config->connector_list, head) {
		struct intel_connector *intel_connector = to_intel_connector(connector);
		connector->polled = intel_connector->polled;
		if (!connector->polled && I915_HAS_HOTPLUG(dev) && intel_connector->encoder->hpd_pin > HPD_NONE)
			connector->polled = DRM_CONNECTOR_POLL_HPD;
	}
d4519 12
a4530 6
	/* Interrupt setup is already guaranteed to be single-threaded, this is
	 * just to make the assert_spin_locked checks happy. */
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	if (dev_priv->display.hpd_irq_setup)
		dev_priv->display.hpd_irq_setup(dev);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4533 8
a4540 2
/* Disable interrupts so we can allow Package C8+. */
void hsw_pc8_disable_interrupts(struct drm_device *dev)
d4542 3
a4544 19
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);

	dev_priv->pc8.regsave.deimr = I915_READ(DEIMR);
	dev_priv->pc8.regsave.sdeimr = I915_READ(SDEIMR);
	dev_priv->pc8.regsave.gtimr = I915_READ(GTIMR);
	dev_priv->pc8.regsave.gtier = I915_READ(GTIER);
	dev_priv->pc8.regsave.gen6_pmimr = I915_READ(GEN6_PMIMR);

	ironlake_disable_display_irq(dev_priv, 0xffffffff);
	ibx_disable_display_interrupt(dev_priv, 0xffffffff);
	ilk_disable_gt_irq(dev_priv, 0xffffffff);
	snb_disable_pm_irq(dev_priv, 0xffffffff);

	dev_priv->pc8.irqs_disabled = true;

	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d4547 8
a4554 2
/* Restore interrupts so we can recover from Package C8+. */
void hsw_pc8_restore_interrupts(struct drm_device *dev)
d4556 3
a4558 27
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long irqflags;
	uint32_t val;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);

	val = I915_READ(DEIMR);
	WARN(val != 0xffffffff, "DEIMR is 0x%08x\n", val);

	val = I915_READ(SDEIMR);
	WARN(val != 0xffffffff, "SDEIMR is 0x%08x\n", val);

	val = I915_READ(GTIMR);
	WARN(val != 0xffffffff, "GTIMR is 0x%08x\n", val);

	val = I915_READ(GEN6_PMIMR);
	WARN(val != 0xffffffff, "GEN6_PMIMR is 0x%08x\n", val);

	dev_priv->pc8.irqs_disabled = false;

	ironlake_enable_display_irq(dev_priv, ~dev_priv->pc8.regsave.deimr);
	ibx_enable_display_interrupt(dev_priv, ~dev_priv->pc8.regsave.sdeimr);
	ilk_enable_gt_irq(dev_priv, ~dev_priv->pc8.regsave.gtimr);
	snb_enable_pm_irq(dev_priv, ~dev_priv->pc8.regsave.gen6_pmimr);
	I915_WRITE(GTIER, dev_priv->pc8.regsave.gtier);

	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
@


1.29
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.28 2015/07/16 18:48:51 kettenis Exp $	*/
d3022 4
@


1.28
log
@Introduce a Linux compatible wait_event API and use it in the inteldrm code.

ok jsg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.27 2015/06/26 15:22:23 kettenis Exp $	*/
d38 43
d85 8
d100 1
a100 1
static inline void
d103 8
d118 341
d460 1
a460 1
i915_enable_pipestat(drm_i915_private_t *dev_priv, int pipe, u32 mask)
d462 4
a465 2
	if ((dev_priv->pipestat[pipe] & mask) != mask) {
		u32 reg = PIPESTAT(pipe);
d467 7
a473 5
		dev_priv->pipestat[pipe] |= mask;
		/* Enable the interrupt, clear any pending status */
		I915_WRITE(reg, dev_priv->pipestat[pipe] | (mask >> 16));
		POSTING_READ(reg);
	}
d477 1
a477 1
i915_disable_pipestat(drm_i915_private_t *dev_priv, int pipe, u32 mask)
d479 2
a480 2
	if ((dev_priv->pipestat[pipe] & mask) != 0) {
		u32 reg = PIPESTAT(pipe);
d482 8
a489 4
		dev_priv->pipestat[pipe] &= ~mask;
		I915_WRITE(reg, dev_priv->pipestat[pipe]);
		POSTING_READ(reg);
	}
d493 1
a493 1
 * intel_enable_asle - enable ASLE interrupt for OpRegion
d495 1
a495 1
void intel_enable_asle(struct drm_device *dev)
d500 1
a500 2
	/* FIXME: opregion/asle for VLV */
	if (IS_VALLEYVIEW(dev))
d505 3
a507 4
	if (HAS_PCH_SPLIT(dev))
		ironlake_enable_display_irq(dev_priv, DE_GSE);
	else {
		i915_enable_pipestat(dev_priv, 1,
a508 4
		if (INTEL_INFO(dev)->gen >= 4)
			i915_enable_pipestat(dev_priv, 0,
					     PIPE_LEGACY_BLC_EVENT_ENABLE);
	}
a525 2
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
d527 15
a541 1
	return I915_READ(PIPECONF(cpu_transcoder)) & PIPECONF_ENABLE;
d552 1
a552 1
	u32 high1, high2, low;
d560 17
d587 1
a587 1
		low   = I915_READ(low_frame)  & PIPE_FRAME_LOW_MASK;
d592 1
d594 7
a600 1
	return (high1 << 8) | low;
d617 23
d641 2
a642 1
			     int *vpos, int *hpos)
d644 5
a648 2
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	u32 vbl = 0, position = 0;
d652 1
a652 2
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
d654 1
a654 1
	if (!i915_pipe_enabled(dev, pipe)) {
d660 12
a671 2
	/* Get vtotal. */
	vtotal = 1 + ((I915_READ(VTOTAL(cpu_transcoder)) >> 16) & 0x1fff);
d673 14
a686 1
	if (INTEL_INFO(dev)->gen >= 4) {
d690 57
a746 1
		position = I915_READ(PIPEDSL(pipe));
d748 4
a751 5
		/* Decode into vertical scanout position. Don't have
		 * horizontal scanout position.
		 */
		*vpos = position & 0x1fff;
		*hpos = 0;
d757 11
a767 1
		position = (I915_READ(PIPEFRAMEPIXEL(pipe)) & PIPE_PIXEL_MASK) >> PIPE_PIXEL_SHIFT;
d769 21
a789 1
		htotal = 1 + ((I915_READ(HTOTAL(cpu_transcoder)) >> 16) & 0x1fff);
a793 18
	/* Query vblank area. */
	vbl = I915_READ(VBLANK(cpu_transcoder));

	/* Test position against vblank region. */
	vbl_start = vbl & 0x1fff;
	vbl_end = (vbl >> 16) & 0x1fff;

	if ((*vpos < vbl_start) || (*vpos > vbl_end))
		in_vbl = false;

	/* Inside "upper part" of vblank area? Apply corrective offset: */
	if (in_vbl && (*vpos >= vbl_start))
		*vpos = *vpos - vtotal;

	/* Readouts valid? */
	if (vbl > 0)
		ret |= DRM_SCANOUTPOS_VALID | DRM_SCANOUTPOS_ACCURATE;

d828 23
a850 1
						     crtc);
d856 2
d864 11
a874 1
	struct intel_encoder *encoder;
d879 33
a911 3
	list_for_each_entry(encoder, &mode_config->encoder_list, base.head)
		if (encoder->hot_plug)
			encoder->hot_plug(encoder);
d913 10
d925 2
a926 2
	/* Just fire off a uevent and let userspace tell us what to do */
	drm_helper_hpd_irq_event(dev);
d929 1
a929 4
/* defined intel_pm.c */
extern spinlock_t mchdev_lock;

static void ironlake_handle_rps_change(struct drm_device *dev)
a933 1
	unsigned long flags;
d935 1
a935 1
	spin_lock_irqsave(&mchdev_lock, flags);
d963 1
a963 1
	spin_unlock_irqrestore(&mchdev_lock, flags);
d971 1
a971 3
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (ring->obj == NULL)
d974 1
a974 1
	trace_i915_gem_request_complete(ring, ring->get_seqno(ring, false));
d977 1
a977 5
	if (i915_enable_hangcheck) {
		dev_priv->hangcheck_count = 0;
		timeout_add_msec(&dev_priv->hangcheck_timer,
				 DRM_I915_HANGCHECK_PERIOD);
	}
d984 2
a985 2
	u32 pm_iir, pm_imr;
	u8 new_delay;
d987 1
a987 1
	spin_lock_irq(&dev_priv->rps.lock);
d990 6
a995 3
	pm_imr = I915_READ(GEN6_PMIMR);
	I915_WRITE(GEN6_PMIMR, 0);
	spin_unlock_irq(&dev_priv->rps.lock);
d997 1
a997 1
	if ((pm_iir & GEN6_PM_DEFERRED_EVENTS) == 0)
d1002 29
a1030 4
	if (pm_iir & GEN6_PM_RP_UP_THRESHOLD)
		new_delay = dev_priv->rps.cur_delay + 1;
	else
		new_delay = dev_priv->rps.cur_delay - 1;
d1035 7
a1041 2
	if (!(new_delay > dev_priv->rps.max_delay ||
	      new_delay < dev_priv->rps.min_delay)) {
a1042 1
	}
d1059 1
d1063 1
a1063 1
//	char *parity_event[5];
d1066 1
d1074 4
d1082 37
a1118 8
	error_status = I915_READ(GEN7_L3CDERRST1);
	row = GEN7_PARITY_ERROR_ROW(error_status);
	bank = GEN7_PARITY_ERROR_BANK(error_status);
	subbank = GEN7_PARITY_ERROR_SUBBANK(error_status);

	I915_WRITE(GEN7_L3CDERRST1, GEN7_PARITY_ERROR_VALID |
				    GEN7_L3CDERRST1_ENABLE);
	POSTING_READ(GEN7_L3CDERRST1);
d1122 2
d1125 1
a1125 2
	dev_priv->gt_irq_mask &= ~GT_GEN7_L3_PARITY_ERROR_INTERRUPT;
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
a1128 19

#if 0
	parity_event[0] = "L3_PARITY_ERROR=1";
	parity_event[1] = kasprintf(GFP_KERNEL, "ROW=%d", row);
	parity_event[2] = kasprintf(GFP_KERNEL, "BANK=%d", bank);
	parity_event[3] = kasprintf(GFP_KERNEL, "SUBBANK=%d", subbank);
	parity_event[4] = NULL;

	kobject_uevent_env(&dev_priv->dev->primary->kdev.kobj,
			   KOBJ_CHANGE, parity_event);
#endif

	DRM_DEBUG("Parity error: Row = %d, Bank = %d, Sub bank = %d.\n",
		  row, bank, subbank);

#if 0
	kfree(parity_event[3]);
	kfree(parity_event[2]);
	kfree(parity_event[1]);
d1132 1
a1132 1
static void ivybridge_handle_parity_error(struct drm_device *dev)
a1134 1
	unsigned long flags;
d1136 1
a1136 1
	if (!HAS_L3_GPU_CACHE(dev))
d1139 10
a1148 4
	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	dev_priv->gt_irq_mask |= GT_GEN7_L3_PARITY_ERROR_INTERRUPT;
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
d1153 11
d1169 2
a1170 2
	if (gt_iir & (GEN6_RENDER_USER_INTERRUPT |
		      GEN6_RENDER_PIPE_CONTROL_NOTIFY_INTERRUPT))
d1172 1
a1172 1
	if (gt_iir & GEN6_BSD_USER_INTERRUPT)
d1174 1
a1174 1
	if (gt_iir & GEN6_BLITTER_USER_INTERRUPT)
d1177 3
a1179 3
	if (gt_iir & (GT_GEN6_BLT_CS_ERROR_INTERRUPT |
		      GT_GEN6_BSD_CS_ERROR_INTERRUPT |
		      GT_RENDER_CS_ERROR_INTERRUPT)) {
d1184 52
a1235 2
	if (gt_iir & GT_GEN7_L3_PARITY_ERROR_INTERRUPT)
		ivybridge_handle_parity_error(dev);
d1238 6
a1243 2
static void gen6_queue_rps_work(struct drm_i915_private *dev_priv,
				u32 pm_iir)
d1245 51
a1295 1
	unsigned long flags;
d1298 4
a1301 7
	 * IIR bits should never already be set because IMR should
	 * prevent an interrupt from being shown in IIR. The warning
	 * displays a case where we've unsafely cleared
	 * dev_priv->rps.pm_iir. Although missing an interrupt of the same
	 * type is not a problem, it displays a problem in the logic.
	 *
	 * The mask bit in IMR is cleared by dev_priv->rps.work.
d1303 95
d1399 30
a1428 5
	spin_lock_irqsave(&dev_priv->rps.lock, flags);
	dev_priv->rps.pm_iir |= pm_iir;
	I915_WRITE(GEN6_PMIMR, dev_priv->rps.pm_iir);
	POSTING_READ(GEN6_PMIMR);
	spin_unlock_irqrestore(&dev_priv->rps.lock, flags);
d1430 9
a1438 1
	queue_work(dev_priv->wq, &dev_priv->rps.work);
d1441 1
a1441 1
static irqreturn_t valleyview_irq_handler(void *arg)
d1443 2
a1444 2
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
a1449 1
	bool blc_event;
d1451 1
a1451 1
//	atomic_inc(&dev_priv->irq_received);
d1483 1
a1483 1
			if (pipe_stats[pipe] & PIPE_VBLANK_INTERRUPT_STATUS)
d1490 3
d1498 1
d1502 5
a1506 3
			if (hotplug_status & dev_priv->hotplug_supported_mask)
				queue_work(dev_priv->wq,
					   &dev_priv->hotplug_work);
d1512 2
a1513 2
		if (pipe_stats[pipe] & PIPE_LEGACY_BLC_EVENT_STATUS)
			blc_event = true;
d1515 2
a1516 2
		if (pm_iir & GEN6_PM_DEFERRED_EVENTS)
			gen6_queue_rps_work(dev_priv, pm_iir);
d1529 1
d1531 1
d1533 1
d1535 1
a1535 2
	if (pch_iir & SDE_HOTPLUG_MASK)
		queue_work(dev_priv->wq, &dev_priv->hotplug_work);
d1537 4
a1540 1
	if (pch_iir & SDE_AUDIO_POWER_MASK)
d1542 6
a1547 2
				 (pch_iir & SDE_AUDIO_POWER_MASK) >>
				 SDE_AUDIO_POWER_SHIFT);
d1550 1
a1550 1
		DRM_DEBUG_DRIVER("PCH GMBUS interrupt\n");
d1573 5
d1579 57
a1635 3
		DRM_DEBUG_DRIVER("PCH transcoder B underrun interrupt\n");
	if (pch_iir & SDE_TRANSA_FIFO_UNDER)
		DRM_DEBUG_DRIVER("PCH transcoder A underrun interrupt\n");
d1640 1
d1642 1
d1644 1
d1646 1
a1646 2
	if (pch_iir & SDE_HOTPLUG_MASK_CPT)
		queue_work(dev_priv->wq, &dev_priv->hotplug_work);
d1648 8
a1655 4
	if (pch_iir & SDE_AUDIO_POWER_MASK_CPT)
		DRM_DEBUG_DRIVER("PCH audio power change on port %d\n",
				 (pch_iir & SDE_AUDIO_POWER_MASK_CPT) >>
				 SDE_AUDIO_POWER_SHIFT_CPT);
d1658 1
a1658 1
		DRM_DEBUG_DRIVER("AUX channel interrupt\n");
d1661 1
a1661 1
		DRM_DEBUG_DRIVER("PCH GMBUS interrupt\n");
a1673 27
}

static irqreturn_t ivybridge_irq_handler(void *arg)
{
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
	u32 de_iir, gt_iir, de_ier, pm_iir;
	irqreturn_t ret = IRQ_NONE;
	int i;

//	atomic_inc(&dev_priv->irq_received);

	/* disable master interrupt before clearing iir  */
	de_ier = I915_READ(DEIER);
	I915_WRITE(DEIER, de_ier & ~DE_MASTER_IRQ_CONTROL);

	gt_iir = I915_READ(GTIIR);
	if (gt_iir) {
		snb_gt_irq_handler(dev, dev_priv, gt_iir);
		I915_WRITE(GTIIR, gt_iir);
		ret = IRQ_HANDLED;
	}

	de_iir = I915_READ(DEIIR);
	if (de_iir) {
		if (de_iir & DE_GSE_IVB)
			intel_opregion_gse_intr(dev);
d1675 2
a1676 45
		for (i = 0; i < 3; i++) {
			if (de_iir & (DE_PIPEA_VBLANK_IVB << (5 * i)))
				drm_handle_vblank(dev, i);
			if (de_iir & (DE_PLANEA_FLIP_DONE_IVB << (5 * i))) {
				intel_prepare_page_flip(dev, i);
				intel_finish_page_flip_plane(dev, i);
			}
		}

		/* check event from PCH */
		if (de_iir & DE_PCH_EVENT_IVB) {
			u32 pch_iir = I915_READ(SDEIIR);

			cpt_irq_handler(dev, pch_iir);

			/* clear PCH hotplug event before clear CPU irq */
			I915_WRITE(SDEIIR, pch_iir);
		}

		I915_WRITE(DEIIR, de_iir);
		ret = IRQ_HANDLED;
	}

	pm_iir = I915_READ(GEN6_PMIIR);
	if (pm_iir) {
		if (pm_iir & GEN6_PM_DEFERRED_EVENTS)
			gen6_queue_rps_work(dev_priv, pm_iir);
		I915_WRITE(GEN6_PMIIR, pm_iir);
		ret = IRQ_HANDLED;
	}

	I915_WRITE(DEIER, de_ier);
	POSTING_READ(DEIER);

	return ret;
}

static void ilk_gt_irq_handler(struct drm_device *dev,
			       struct drm_i915_private *dev_priv,
			       u32 gt_iir)
{
	if (gt_iir & (GT_USER_INTERRUPT | GT_PIPE_NOTIFY))
		notify_ring(dev, &dev_priv->ring[RCS]);
	if (gt_iir & GT_BSD_USER_INTERRUPT)
		notify_ring(dev, &dev_priv->ring[VCS]);
d1679 1
a1679 1
static irqreturn_t ironlake_irq_handler(void *arg)
d1681 2
a1682 22
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
	int ret = IRQ_NONE;
	u32 de_iir, gt_iir, de_ier, pch_iir, pm_iir;

//	atomic_inc(&dev_priv->irq_received);

	/* disable master interrupt before clearing iir  */
	de_ier = I915_READ(DEIER);
	I915_WRITE(DEIER, de_ier & ~DE_MASTER_IRQ_CONTROL);
	POSTING_READ(DEIER);

	de_iir = I915_READ(DEIIR);
	gt_iir = I915_READ(GTIIR);
	pch_iir = I915_READ(SDEIIR);
	pm_iir = I915_READ(GEN6_PMIIR);

	if (de_iir == 0 && gt_iir == 0 && pch_iir == 0 &&
	    (!IS_GEN6(dev) || pm_iir == 0))
		goto done;

	ret = IRQ_HANDLED;
d1684 2
a1685 4
	if (IS_GEN5(dev))
		ilk_gt_irq_handler(dev, dev_priv, gt_iir);
	else
		snb_gt_irq_handler(dev, dev_priv, gt_iir);
d1688 1
a1688 1
		intel_opregion_gse_intr(dev);
d1690 2
a1691 2
	if (de_iir & DE_PIPEA_VBLANK)
		drm_handle_vblank(dev, 0);
d1693 3
a1695 2
	if (de_iir & DE_PIPEB_VBLANK)
		drm_handle_vblank(dev, 1);
d1697 13
a1709 8
	if (de_iir & DE_PLANEA_FLIP_DONE) {
		intel_prepare_page_flip(dev, 0);
		intel_finish_page_flip_plane(dev, 0);
	}

	if (de_iir & DE_PLANEB_FLIP_DONE) {
		intel_prepare_page_flip(dev, 1);
		intel_finish_page_flip_plane(dev, 1);
d1714 2
d1720 3
d1725 2
a1726 17
	if (IS_GEN5(dev) &&  de_iir & DE_PCU_EVENT)
		ironlake_handle_rps_change(dev);

	if (IS_GEN6(dev) && pm_iir & GEN6_PM_DEFERRED_EVENTS)
		gen6_queue_rps_work(dev_priv, pm_iir);

	/* should clear PCH hotplug event before clear CPU irq */
	I915_WRITE(SDEIIR, pch_iir);
	I915_WRITE(GTIIR, gt_iir);
	I915_WRITE(DEIIR, de_iir);
	I915_WRITE(GEN6_PMIIR, pm_iir);

done:
	I915_WRITE(DEIER, de_ier);
	POSTING_READ(DEIER);

	return ret;
d1729 1
a1729 8
/**
 * i915_error_work_func - do process context error handling work
 * @@work: work struct
 *
 * Fire an error uevent so userspace can see that a hang or error
 * was detected.
 */
static void i915_error_work_func(struct work_struct *work)
d1731 2
a1732 7
	drm_i915_private_t *dev_priv = container_of(work, drm_i915_private_t,
						    error_work);
	struct drm_device *dev = dev_priv->dev;
#if 0
	char *error_event[] = { "ERROR=1", NULL };
	char *reset_event[] = { "RESET=1", NULL };
	char *reset_done_event[] = { "ERROR=0", NULL };
d1734 2
a1735 2
	kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, error_event);
#endif
d1737 2
a1738 10
	if (atomic_read(&dev_priv->mm.wedged)) {
		DRM_DEBUG_DRIVER("resetting chip\n");
//		kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, reset_event);
		if (!i915_reset(dev)) {
			atomic_set(&dev_priv->mm.wedged, 0);
//			kobject_uevent_env(&dev->primary->kdev.kobj, KOBJ_CHANGE, reset_done_event);
		}
		complete_all(&dev_priv->error_completion);
	}
}
d1740 2
a1741 28
/* NB: please notice the memset */
static void i915_get_extra_instdone(struct drm_device *dev,
				    uint32_t *instdone)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	memset(instdone, 0, sizeof(*instdone) * I915_NUM_INSTDONE_REG);

	switch(INTEL_INFO(dev)->gen) {
	case 2:
	case 3:
		instdone[0] = I915_READ(INSTDONE);
		break;
	case 4:
	case 5:
	case 6:
		instdone[0] = I915_READ(INSTDONE_I965);
		instdone[1] = I915_READ(INSTDONE1);
		break;
	default:
		WARN_ONCE(1, "Unsupported platform\n");
	case 7:
		instdone[0] = I915_READ(GEN7_INSTDONE_1);
		instdone[1] = I915_READ(GEN7_SC_INSTDONE);
		instdone[2] = I915_READ(GEN7_SAMPLER_INSTDONE);
		instdone[3] = I915_READ(GEN7_ROW_INSTDONE);
		break;
	}
}
d1743 3
a1745 8
#ifdef CONFIG_DEBUG_FS
static struct drm_i915_error_object *
i915_error_object_create(struct drm_i915_private *dev_priv,
			 struct drm_i915_gem_object *src)
{
	struct drm_i915_error_object *dst;
	int i, count;
	u32 reloc_offset;
d1747 6
a1752 2
	if (src == NULL || src->pages == NULL)
		return NULL;
d1754 3
a1756 1
	count = src->base.size / PAGE_SIZE;
d1758 1
a1758 22
	dst = kmalloc(sizeof(*dst) + count * sizeof(u32 *), GFP_ATOMIC);
	if (dst == NULL)
		return NULL;

	reloc_offset = src->gtt_offset;
	for (i = 0; i < count; i++) {
		unsigned long flags;
		void *d;

		d = kmalloc(PAGE_SIZE, GFP_ATOMIC);
		if (d == NULL)
			goto unwind;

		local_irq_save(flags);
		if (reloc_offset < dev_priv->mm.gtt_mappable_end &&
		    src->has_global_gtt_mapping) {
			void __iomem *s;

			/* Simply ignore tiling or any overlapping fence.
			 * It's part of the error state, and this hopefully
			 * captures what the GPU read.
			 */
d1760 2
a1761 23
			s = io_mapping_map_atomic_wc(dev_priv->mm.gtt_mapping,
						     reloc_offset);
			memcpy_fromio(d, s, PAGE_SIZE);
			io_mapping_unmap_atomic(s);
		} else {
			struct page *page;
			void *s;

			page = i915_gem_object_get_page(src, i);

			drm_clflush_pages(&page, 1);

			s = kmap_atomic(page);
			memcpy(d, s, PAGE_SIZE);
			kunmap_atomic(s);

			drm_clflush_pages(&page, 1);
		}
		local_irq_restore(flags);

		dst->pages[i] = d;

		reloc_offset += PAGE_SIZE;
a1762 10
	dst->page_count = count;
	dst->gtt_offset = src->gtt_offset;

	return dst;

unwind:
	while (i--)
		kfree(dst->pages[i]);
	kfree(dst);
	return NULL;
d1765 1
a1765 2
static void
i915_error_object_free(struct drm_i915_error_object *obj)
d1767 4
a1770 1
	int page;
d1772 1
a1772 2
	if (obj == NULL)
		return;
d1774 3
a1776 2
	for (page = 0; page < obj->page_count; page++)
		kfree(obj->pages[page]);
d1778 4
a1781 9
	kfree(obj);
}

void
i915_error_state_free(struct kref *error_ref)
{
	struct drm_i915_error_state *error = container_of(error_ref,
							  typeof(*error), ref);
	int i;
d1783 9
a1791 43
	for (i = 0; i < ARRAY_SIZE(error->ring); i++) {
		i915_error_object_free(error->ring[i].batchbuffer);
		i915_error_object_free(error->ring[i].ringbuffer);
		kfree(error->ring[i].requests);
	}

	kfree(error->active_bo);
	kfree(error->overlay);
	kfree(error);
}
static void capture_bo(struct drm_i915_error_buffer *err,
		       struct drm_i915_gem_object *obj)
{
	err->size = obj->base.size;
	err->name = obj->base.name;
	err->rseqno = obj->last_read_seqno;
	err->wseqno = obj->last_write_seqno;
	err->gtt_offset = obj->gtt_offset;
	err->read_domains = obj->base.read_domains;
	err->write_domain = obj->base.write_domain;
	err->fence_reg = obj->fence_reg;
	err->pinned = 0;
	if (obj->pin_count > 0)
		err->pinned = 1;
	if (obj->user_pin_count > 0)
		err->pinned = -1;
	err->tiling = obj->tiling_mode;
	err->dirty = obj->dirty;
	err->purgeable = obj->madv != I915_MADV_WILLNEED;
	err->ring = obj->ring ? obj->ring->id : -1;
	err->cache_level = obj->cache_level;
}

static u32 capture_active_bo(struct drm_i915_error_buffer *err,
			     int count, struct list_head *head)
{
	struct drm_i915_gem_object *obj;
	int i = 0;

	list_for_each_entry(obj, head, mm_list) {
		capture_bo(err++, obj);
		if (++i == count)
			break;
d1794 8
a1801 16
	return i;
}

static u32 capture_pinned_bo(struct drm_i915_error_buffer *err,
			     int count, struct list_head *head)
{
	struct drm_i915_gem_object *obj;
	int i = 0;

	list_for_each_entry(obj, head, gtt_list) {
		if (obj->pin_count == 0)
			continue;

		capture_bo(err++, obj);
		if (++i == count)
			break;
d1804 8
a1811 30
	return i;
}

static void i915_gem_record_fences(struct drm_device *dev,
				   struct drm_i915_error_state *error)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	/* Fences */
	switch (INTEL_INFO(dev)->gen) {
	case 7:
	case 6:
		for (i = 0; i < 16; i++)
			error->fence[i] = I915_READ64(FENCE_REG_SANDYBRIDGE_0 + (i * 8));
		break;
	case 5:
	case 4:
		for (i = 0; i < 16; i++)
			error->fence[i] = I915_READ64(FENCE_REG_965_0 + (i * 8));
		break;
	case 3:
		if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev))
			for (i = 0; i < 8; i++)
				error->fence[i+8] = I915_READ(FENCE_REG_945_8 + (i * 4));
	case 2:
		for (i = 0; i < 8; i++)
			error->fence[i] = I915_READ(FENCE_REG_830_0 + (i * 4));
		break;

a1812 1
}
d1814 7
a1820 20
static struct drm_i915_error_object *
i915_error_first_batchbuffer(struct drm_i915_private *dev_priv,
			     struct intel_ring_buffer *ring)
{
	struct drm_i915_gem_object *obj;
	u32 seqno;

	if (!ring->get_seqno)
		return NULL;

	if (HAS_BROKEN_CS_TLB(dev_priv->dev)) {
		u32 acthd = I915_READ(ACTHD);

		if (WARN_ON(ring->id != RCS))
			return NULL;

		obj = ring->private;
		if (acthd >= obj->gtt_offset &&
		    acthd < obj->gtt_offset + obj->base.size)
			return i915_error_object_create(dev_priv, obj);
d1823 5
a1827 15
	seqno = ring->get_seqno(ring, false);
	list_for_each_entry(obj, &dev_priv->mm.active_list, mm_list) {
		if (obj->ring != ring)
			continue;

		if (i915_seqno_passed(seqno, obj->last_read_seqno))
			continue;

		if ((obj->base.read_domains & I915_GEM_DOMAIN_COMMAND) == 0)
			continue;

		/* We need to copy these to an anonymous buffer as the simplest
		 * method to avoid being overwritten by userspace.
		 */
		return i915_error_object_create(dev_priv, obj);
d1830 1
a1830 1
	return NULL;
d1833 1
a1833 3
static void i915_record_ring_state(struct drm_device *dev,
				   struct drm_i915_error_state *error,
				   struct intel_ring_buffer *ring)
d1835 1
d1837 4
d1842 1
a1842 10
	if (INTEL_INFO(dev)->gen >= 6) {
		error->rc_psmi[ring->id] = I915_READ(ring->mmio_base + 0x50);
		error->fault_reg[ring->id] = I915_READ(RING_FAULT_REG(ring));
		error->semaphore_mboxes[ring->id][0]
			= I915_READ(RING_SYNC_0(ring->mmio_base));
		error->semaphore_mboxes[ring->id][1]
			= I915_READ(RING_SYNC_1(ring->mmio_base));
		error->semaphore_seqno[ring->id][0] = ring->sync_seqno[0];
		error->semaphore_seqno[ring->id][1] = ring->sync_seqno[1];
	}
d1844 4
a1847 22
	if (INTEL_INFO(dev)->gen >= 4) {
		error->faddr[ring->id] = I915_READ(RING_DMA_FADD(ring->mmio_base));
		error->ipeir[ring->id] = I915_READ(RING_IPEIR(ring->mmio_base));
		error->ipehr[ring->id] = I915_READ(RING_IPEHR(ring->mmio_base));
		error->instdone[ring->id] = I915_READ(RING_INSTDONE(ring->mmio_base));
		error->instps[ring->id] = I915_READ(RING_INSTPS(ring->mmio_base));
		if (ring->id == RCS)
			error->bbaddr = I915_READ64(BB_ADDR);
	} else {
		error->faddr[ring->id] = I915_READ(DMA_FADD_I8XX);
		error->ipeir[ring->id] = I915_READ(IPEIR);
		error->ipehr[ring->id] = I915_READ(IPEHR);
		error->instdone[ring->id] = I915_READ(INSTDONE);
	}

	error->waiting[ring->id] = waitqueue_active(&ring->irq_queue);
	error->instpm[ring->id] = I915_READ(RING_INSTPM(ring->mmio_base));
	error->seqno[ring->id] = ring->get_seqno(ring, false);
	error->acthd[ring->id] = intel_ring_get_active_head(ring);
	error->head[ring->id] = I915_READ_HEAD(ring);
	error->tail[ring->id] = I915_READ_TAIL(ring);
	error->ctl[ring->id] = I915_READ_CTL(ring);
d1849 2
a1850 3
	error->cpu_ring_head[ring->id] = ring->head;
	error->cpu_ring_tail[ring->id] = ring->tail;
}
d1852 1
a1852 7
static void i915_gem_record_rings(struct drm_device *dev,
				  struct drm_i915_error_state *error)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	struct drm_i915_gem_request *request;
	int i, count;
d1854 8
a1861 2
	for_each_ring(ring, dev_priv, i) {
		i915_record_ring_state(dev, error, ring);
d1863 5
a1867 2
		error->ring[i].batchbuffer =
			i915_error_first_batchbuffer(dev_priv, ring);
d1869 8
a1876 2
		error->ring[i].ringbuffer =
			i915_error_object_create(dev_priv, ring->obj);
d1878 3
a1880 11
		count = 0;
		list_for_each_entry(request, &ring->request_list, list)
			count++;

		error->ring[i].num_requests = count;
		error->ring[i].requests =
			kmalloc(count*sizeof(struct drm_i915_error_request),
				GFP_ATOMIC);
		if (error->ring[i].requests == NULL) {
			error->ring[i].num_requests = 0;
			continue;
d1882 1
d1884 2
a1885 11
		count = 0;
		list_for_each_entry(request, &ring->request_list, list) {
			struct drm_i915_error_request *erq;

			erq = &error->ring[i].requests[count++];
			erq->seqno = request->seqno;
			erq->jiffies = request->emitted_jiffies;
			erq->tail = request->tail;
		}
	}
}
d1887 2
a1888 16
/**
 * i915_capture_error_state - capture an error record for later analysis
 * @@dev: drm device
 *
 * Should be called when an error is detected (either a hang or an error
 * interrupt) to capture error state from the time of the error.  Fills
 * out a structure which becomes available in debugfs for user level tools
 * to pick up.
 */
static void i915_capture_error_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj;
	struct drm_i915_error_state *error;
	unsigned long flags;
	int i, pipe;
d1890 3
a1892 5
	spin_lock_irqsave(&dev_priv->error_lock, flags);
	error = dev_priv->first_error;
	spin_unlock_irqrestore(&dev_priv->error_lock, flags);
	if (error)
		return;
d1894 4
a1897 6
	/* Account for pipe specific data like PIPE*STAT */
	error = kzalloc(sizeof(*error), GFP_ATOMIC);
	if (!error) {
		DRM_DEBUG_DRIVER("out of memory, not capturing error state\n");
		return;
	}
d1899 2
a1900 2
	DRM_INFO("capturing error event; look for more information in /debug/dri/%d/i915_error_state\n",
		 dev->primary->index);
d1902 6
a1907 4
	kref_init(&error->ref);
	error->eir = I915_READ(EIR);
	error->pgtbl_er = I915_READ(PGTBL_ER);
	error->ccid = I915_READ(CCID);
d1909 5
a1913 8
	if (HAS_PCH_SPLIT(dev))
		error->ier = I915_READ(DEIER) | I915_READ(GTIER);
	else if (IS_VALLEYVIEW(dev))
		error->ier = I915_READ(GTIER) | I915_READ(VLV_IER);
	else if (IS_GEN2(dev))
		error->ier = I915_READ16(IER);
	else
		error->ier = I915_READ(IER);
d1915 6
a1920 2
	if (INTEL_INFO(dev)->gen >= 6)
		error->derrmr = I915_READ(DERRMR);
d1922 7
a1928 6
	if (IS_VALLEYVIEW(dev))
		error->forcewake = I915_READ(FORCEWAKE_VLV);
	else if (INTEL_INFO(dev)->gen >= 7)
		error->forcewake = I915_READ(FORCEWAKE_MT);
	else if (INTEL_INFO(dev)->gen == 6)
		error->forcewake = I915_READ(FORCEWAKE);
d1930 1
a1930 2
	for_each_pipe(pipe)
		error->pipestat[pipe] = I915_READ(PIPESTAT(pipe));
d1932 4
a1935 3
	if (INTEL_INFO(dev)->gen >= 6) {
		error->error = I915_READ(ERROR_GEN6);
		error->done_reg = I915_READ(DONE_REG);
d1938 2
a1939 2
	if (INTEL_INFO(dev)->gen == 7)
		error->err_int = I915_READ(GEN7_ERR_INT);
d1941 2
a1942 1
	i915_get_extra_instdone(dev, error->extra_instdone);
d1944 5
a1948 2
	i915_gem_record_fences(dev, error);
	i915_gem_record_rings(dev, error);
d1950 6
a1955 3
	/* Record buffers on the active and pinned lists. */
	error->active_bo = NULL;
	error->pinned_bo = NULL;
d1957 3
a1959 8
	i = 0;
	list_for_each_entry(obj, &dev_priv->mm.active_list, mm_list)
		i++;
	error->active_bo_count = i;
	list_for_each_entry(obj, &dev_priv->mm.bound_list, gtt_list)
		if (obj->pin_count)
			i++;
	error->pinned_bo_count = i - error->active_bo_count;
d1961 2
a1962 9
	error->active_bo = NULL;
	error->pinned_bo = NULL;
	if (i) {
		error->active_bo = kmalloc(sizeof(*error->active_bo)*i,
					   GFP_ATOMIC);
		if (error->active_bo)
			error->pinned_bo =
				error->active_bo + error->active_bo_count;
	}
d1964 7
a1970 5
	if (error->active_bo)
		error->active_bo_count =
			capture_active_bo(error->active_bo,
					  error->active_bo_count,
					  &dev_priv->mm.active_list);
d1972 20
a1991 5
	if (error->pinned_bo)
		error->pinned_bo_count =
			capture_pinned_bo(error->pinned_bo,
					  error->pinned_bo_count,
					  &dev_priv->mm.bound_list);
d1993 3
a1995 1
	do_gettimeofday(&error->time);
d1997 16
a2012 2
	error->overlay = intel_overlay_capture_error_state(dev);
	error->display = intel_display_capture_error_state(dev);
d2014 7
a2020 6
	spin_lock_irqsave(&dev_priv->error_lock, flags);
	if (dev_priv->first_error == NULL) {
		dev_priv->first_error = error;
		error = NULL;
	}
	spin_unlock_irqrestore(&dev_priv->error_lock, flags);
d2022 1
a2022 3
	if (error)
		i915_error_state_free(&error->ref);
}
d2024 13
a2036 5
void i915_destroy_error_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_error_state *error;
	unsigned long flags;
d2038 7
a2044 4
	spin_lock_irqsave(&dev_priv->error_lock, flags);
	error = dev_priv->first_error;
	dev_priv->first_error = NULL;
	spin_unlock_irqrestore(&dev_priv->error_lock, flags);
d2046 6
a2051 2
	if (error)
		kref_put(&error->ref, i915_error_state_free);
a2052 3
#else
#define i915_capture_error_state(x)
#endif
a2158 2
	struct intel_ring_buffer *ring;
	int i;
d2164 2
a2165 2
		INIT_COMPLETION(dev_priv->error_completion);
		atomic_set(&dev_priv->mm.wedged, 1);
d2168 11
a2178 1
		 * Wakeup waiting processes so they don't hang
d2180 1
a2180 2
		for_each_ring(ring, dev_priv, i)
			wake_up_all(&ring->irq_queue);
d2183 7
a2189 1
	queue_work(dev_priv->wq, &dev_priv->error_work);
d2192 1
a2192 1
static void i915_pageflip_stall_check(struct drm_device *dev, int pipe)
d2222 1
a2222 1
					obj->gtt_offset;
d2225 1
a2225 1
		stall_detected = I915_READ(dspaddr) == (obj->gtt_offset +
d2269 2
d2276 1
a2276 2
	ironlake_enable_display_irq(dev_priv, (pipe == 0) ?
				    DE_PIPEA_VBLANK : DE_PIPEB_VBLANK);
d2282 1
a2282 1
static int ivybridge_enable_vblank(struct drm_device *dev, int pipe)
d2286 1
d2292 8
a2299 2
	ironlake_enable_display_irq(dev_priv,
				    DE_PIPEA_VBLANK_IVB << (5 * pipe));
d2305 1
a2305 1
static int valleyview_enable_vblank(struct drm_device *dev, int pipe)
d2307 1
a2307 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
a2308 1
	u32 imr;
d2314 3
a2316 8
	imr = I915_READ(VLV_IMR);
	if (pipe == 0)
		imr &= ~I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT;
	else
		imr &= ~I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
	I915_WRITE(VLV_IMR, imr);
	i915_enable_pipestat(dev_priv, pipe,
			     PIPE_START_VBLANK_INTERRUPT_ENABLE);
a2317 1

d2343 2
d2347 1
a2347 13
	ironlake_disable_display_irq(dev_priv, (pipe == 0) ?
				     DE_PIPEA_VBLANK : DE_PIPEB_VBLANK);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
}

static void ivybridge_disable_vblank(struct drm_device *dev, int pipe)
{
	drm_i915_private_t *dev_priv = (drm_i915_private_t *) dev->dev_private;
	unsigned long irqflags;

	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	ironlake_disable_display_irq(dev_priv,
				     DE_PIPEA_VBLANK_IVB << (pipe * 5));
d2361 1
a2361 1
	if (pipe == 0)
d2369 15
d2391 58
a2448 1
static bool i915_hangcheck_ring_idle(struct intel_ring_buffer *ring, bool *err)
d2450 5
a2454 16
	if (list_empty(&ring->request_list) ||
	    i915_seqno_passed(ring->get_seqno(ring, false),
			      ring_last_seqno(ring))) {
		/* Issue a wake-up to catch stuck h/w. */
#ifdef notyet
		if (wakeup(&ring->irq_queue) > 0) {
			DRM_ERROR("Hangcheck timer elapsed... %s idle\n",
				  ring->name);
			*err = true;
		}
#else
		wake_up_all(&ring->irq_queue);
#endif
		return true;
	}
	return false;
d2457 2
a2458 1
static bool kick_ring(struct intel_ring_buffer *ring)
d2462 14
a2475 1
	u32 tmp = I915_READ_CTL(ring);
d2479 1
d2481 1
a2481 1
		return true;
a2482 2
	return false;
}
d2484 12
a2495 21
static bool i915_hangcheck_hung(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;

	if (dev_priv->hangcheck_count++ > 1) {
		bool hung = true;

		DRM_ERROR("Hangcheck timer elapsed... GPU hung\n");
		i915_handle_error(dev, true);

		if (!IS_GEN2(dev)) {
			struct intel_ring_buffer *ring;
			int i;

			/* Is the chip hanging on a WAIT_FOR_EVENT?
			 * If so we can simply poke the RB_WAIT bit
			 * and break the hang. This should work on
			 * all but the second generation chipsets.
			 */
			for_each_ring(ring, dev_priv, i)
				hung &= !kick_ring(ring);
a2496 2

		return hung;
d2499 1
a2499 1
	return false;
d2504 5
a2508 3
 * batchbuffers in a long time. The first time this is called we simply record
 * ACTHD. If ACTHD hasn't changed by the time the hangcheck timer elapses
 * again, we assume the chip is wedged and try to fix it.
d2510 1
a2510 1
void i915_hangcheck_elapsed(void *arg)
d2512 2
a2513 3
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
	uint32_t acthd[I915_NUM_RINGS], instdone[I915_NUM_INSTDONE_REG];
a2514 1
	bool err = false, idle;
d2516 6
a2525 2
	memset(acthd, 0, sizeof(acthd));
	idle = true;
d2527 84
a2610 2
	    idle &= i915_hangcheck_ring_idle(ring, &err);
	    acthd[i] = intel_ring_get_active_head(ring);
d2613 18
a2630 5
	/* If all work is done then ACTHD clearly hasn't advanced. */
	if (idle) {
		if (err) {
			if (i915_hangcheck_hung(dev))
				return;
d2632 3
a2634 2
			goto repeat;
		}
d2636 1
a2636 1
		dev_priv->hangcheck_count = 0;
a2637 1
	}
d2639 20
a2658 7
	i915_get_extra_instdone(dev, instdone);
	if (memcmp(dev_priv->last_acthd, acthd, sizeof(acthd)) == 0 &&
	    memcmp(dev_priv->prev_instdone, instdone, sizeof(instdone)) == 0) {
		if (i915_hangcheck_hung(dev))
			return;
	} else {
		dev_priv->hangcheck_count = 0;
d2660 5
a2664 2
		memcpy(dev_priv->last_acthd, acthd, sizeof(acthd));
		memcpy(dev_priv->prev_instdone, instdone, sizeof(instdone));
a2665 4

repeat:
	/* Reset timer case chip hangs without another request being added */
	timeout_add_msec(&dev_priv->hangcheck_timer, DRM_I915_HANGCHECK_PERIOD);
d2674 1
a2674 1
//	atomic_set(&dev_priv->irq_received, 0);
a2677 2
	/* XXX hotplug from PCH */

d2682 1
a2682 4
	/* and GT */
	I915_WRITE(GTIMR, 0xffffffff);
	I915_WRITE(GTIER, 0x0);
	POSTING_READ(GTIER);
d2684 1
a2684 4
	/* south display irq */
	I915_WRITE(SDEIMR, 0xffffffff);
	I915_WRITE(SDEIER, 0x0);
	POSTING_READ(SDEIER);
d2692 1
a2692 1
//	atomic_set(&dev_priv->irq_received, 0);
d2703 2
a2704 3
	I915_WRITE(GTIMR, 0xffffffff);
	I915_WRITE(GTIER, 0x0);
	POSTING_READ(GTIER);
d2718 48
a2765 6
/*
 * Enable digital hotplug on the PCH, and configure the DP short pulse
 * duration to 2ms (which is the minimum in the Display Port spec)
 *
 * This register is the same on all known PCH chips.
 */
d2767 1
a2767 1
static void ironlake_enable_pch_hotplug(struct drm_device *dev)
d2770 15
a2784 1
	u32	hotplug;
d2786 8
d2802 1
a2802 1
static int ironlake_irq_postinstall(struct drm_device *dev)
d2805 9
a2813 5
	/* enable kind of interrupts always enabled */
	u32 display_mask = DE_MASTER_IRQ_CONTROL | DE_GSE | DE_PCH_EVENT |
			   DE_PLANEA_FLIP_DONE | DE_PLANEB_FLIP_DONE;
	u32 render_irqs;
	u32 hotplug_mask;
d2815 2
a2816 1
	dev_priv->irq_mask = ~display_mask;
d2818 3
a2820 5
	/* should always can generate irq */
	I915_WRITE(DEIIR, I915_READ(DEIIR));
	I915_WRITE(DEIMR, dev_priv->irq_mask);
	I915_WRITE(DEIER, display_mask | DE_PIPEA_VBLANK | DE_PIPEB_VBLANK);
	POSTING_READ(DEIER);
d2822 4
a2825 1
	dev_priv->gt_irq_mask = ~0;
d2827 1
a2827 2
	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
d2829 6
a2834 12
	if (IS_GEN6(dev))
		render_irqs =
			GT_USER_INTERRUPT |
			GEN6_BSD_USER_INTERRUPT |
			GEN6_BLITTER_USER_INTERRUPT;
	else
		render_irqs =
			GT_USER_INTERRUPT |
			GT_PIPE_NOTIFY |
			GT_BSD_USER_INTERRUPT;
	I915_WRITE(GTIER, render_irqs);
	POSTING_READ(GTIER);
d2836 4
a2839 5
	if (HAS_PCH_CPT(dev)) {
		hotplug_mask = (SDE_CRT_HOTPLUG_CPT |
				SDE_PORTB_HOTPLUG_CPT |
				SDE_PORTC_HOTPLUG_CPT |
				SDE_PORTD_HOTPLUG_CPT);
d2841 1
a2841 5
		hotplug_mask = (SDE_CRT_HOTPLUG |
				SDE_PORTB_HOTPLUG |
				SDE_PORTC_HOTPLUG |
				SDE_PORTD_HOTPLUG |
				SDE_AUX_MASK);
d2844 4
a2847 1
	dev_priv->pch_irq_mask = ~hotplug_mask;
d2849 2
a2850 4
	I915_WRITE(SDEIIR, I915_READ(SDEIIR));
	I915_WRITE(SDEIMR, dev_priv->pch_irq_mask);
	I915_WRITE(SDEIER, hotplug_mask);
	POSTING_READ(SDEIER);
d2852 2
a2853 1
	ironlake_enable_pch_hotplug(dev);
d2855 5
a2859 5
	if (IS_IRONLAKE_M(dev)) {
		/* Clear & enable PCU event interrupts */
		I915_WRITE(DEIIR, DE_PCU_EVENT);
		I915_WRITE(DEIER, I915_READ(DEIER) | DE_PCU_EVENT);
		ironlake_enable_display_irq(dev_priv, DE_PCU_EVENT);
a2860 2

	return 0;
d2863 1
a2863 1
static int ivybridge_irq_postinstall(struct drm_device *dev)
d2865 1
d2867 20
a2886 8
	/* enable kind of interrupts always enabled */
	u32 display_mask =
		DE_MASTER_IRQ_CONTROL | DE_GSE_IVB | DE_PCH_EVENT_IVB |
		DE_PLANEC_FLIP_DONE_IVB |
		DE_PLANEB_FLIP_DONE_IVB |
		DE_PLANEA_FLIP_DONE_IVB;
	u32 render_irqs;
	u32 hotplug_mask;
d2893 1
a2893 5
	I915_WRITE(DEIER,
		   display_mask |
		   DE_PIPEC_VBLANK_IVB |
		   DE_PIPEB_VBLANK_IVB |
		   DE_PIPEA_VBLANK_IVB);
d2896 1
a2896 1
	dev_priv->gt_irq_mask = ~GT_GEN7_L3_PARITY_ERROR_INTERRUPT;
d2898 1
a2898 2
	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
d2900 10
a2909 17
	render_irqs = GT_USER_INTERRUPT | GEN6_BSD_USER_INTERRUPT |
		GEN6_BLITTER_USER_INTERRUPT | GT_GEN7_L3_PARITY_ERROR_INTERRUPT;
	I915_WRITE(GTIER, render_irqs);
	POSTING_READ(GTIER);

	hotplug_mask = (SDE_CRT_HOTPLUG_CPT |
			SDE_PORTB_HOTPLUG_CPT |
			SDE_PORTC_HOTPLUG_CPT |
			SDE_PORTD_HOTPLUG_CPT);
	dev_priv->pch_irq_mask = ~hotplug_mask;

	I915_WRITE(SDEIIR, I915_READ(SDEIIR));
	I915_WRITE(SDEIMR, dev_priv->pch_irq_mask);
	I915_WRITE(SDEIER, hotplug_mask);
	POSTING_READ(SDEIER);

	ironlake_enable_pch_hotplug(dev);
d2918 3
a2920 4
	u32 hotplug_en = I915_READ(PORT_HOTPLUG_EN);
	u32 pipestat_enable = PLANE_FLIP_DONE_INT_EN_VLV;
	u32 render_irqs;
	u16 msid;
d2936 2
a2937 9
	dev_priv->pipestat[0] = 0;
	dev_priv->pipestat[1] = 0;

	/* Hack for broken MSIs on VLV */
	pci_conf_write(dev_priv->pc, dev_priv->tag, 0x94, 0xfee00000);
	msid = pci_conf_read(dev_priv->pc, dev_priv->tag, 0x98);
	msid &= 0xff; /* mask out delivery bits */
	msid |= (1<<14);
	pci_conf_write(dev_priv->pc, dev_priv->tag, 0x98, msid);
d2946 7
a2952 2
	i915_enable_pipestat(dev_priv, 0, pipestat_enable);
	i915_enable_pipestat(dev_priv, 1, pipestat_enable);
d2957 1
a2957 7
	I915_WRITE(GTIIR, I915_READ(GTIIR));
	I915_WRITE(GTIMR, dev_priv->gt_irq_mask);

	render_irqs = GT_USER_INTERRUPT | GEN6_BSD_USER_INTERRUPT |
		GEN6_BLITTER_USER_INTERRUPT;
	I915_WRITE(GTIER, render_irqs);
	POSTING_READ(GTIER);
d2966 50
a3015 14
	/* Note HDMI and DP share bits */
	if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMIB_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMIC_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMID_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS_I915)
		hotplug_en |= SDVOC_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS_I915)
		hotplug_en |= SDVOB_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS) {
		hotplug_en |= CRT_HOTPLUG_INT_EN;
		hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;
d3017 10
d3028 7
a3034 1
	I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
d3039 42
d3089 2
d3112 2
d3119 2
d3126 3
d3132 2
d3141 1
a3141 1
//	atomic_set(&dev_priv->irq_received, 0);
d3153 1
a3153 3

	dev_priv->pipestat[0] = 0;
	dev_priv->pipestat[1] = 0;
d3174 7
d3184 32
a3215 1
static irqreturn_t i8xx_irq_handler(void *arg)
d3217 2
a3218 2
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
a3221 1
	int irq_received;
d3227 1
a3227 1
//	atomic_inc(&dev_priv->irq_received);
a3254 1
				irq_received = 1;
d3262 1
a3262 1
//		i915_update_dri1_breadcrumb(dev);
d3267 8
a3274 8
		if (pipe_stats[0] & PIPE_VBLANK_INTERRUPT_STATUS &&
		    drm_handle_vblank(dev, 0)) {
			if (iir & I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT) {
				intel_prepare_page_flip(dev, 0);
				intel_finish_page_flip(dev, 0);
				flip_mask &= ~I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT;
			}
		}
d3276 2
a3277 7
		if (pipe_stats[1] & PIPE_VBLANK_INTERRUPT_STATUS &&
		    drm_handle_vblank(dev, 1)) {
			if (iir & I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT) {
				intel_prepare_page_flip(dev, 1);
				intel_finish_page_flip(dev, 1);
				flip_mask &= ~I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT;
			}
d3306 1
a3306 1
//	atomic_set(&dev_priv->irq_received, 0);
d3325 1
a3325 3

	dev_priv->pipestat[0] = 0;
	dev_priv->pipestat[1] = 0;
d3346 3
d3359 23
a3381 2
	if (I915_HAS_HOTPLUG(dev)) {
		u32 hotplug_en = I915_READ(PORT_HOTPLUG_EN);
d3383 2
a3384 14
		if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
			hotplug_en |= HDMIB_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
			hotplug_en |= HDMIC_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
			hotplug_en |= HDMID_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS_I915)
			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS_I915)
			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS) {
			hotplug_en |= CRT_HOTPLUG_INT_EN;
			hotplug_en |= CRT_HOTPLUG_VOLTAGE_COMPARE_50;
		}
d3386 1
a3386 1
		/* Ignore TV since it's buggy */
d3388 8
a3395 2
		I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);
	}
d3397 1
a3397 1
	intel_opregion_enable_asle(dev);
d3399 1
a3399 1
	return 0;
d3402 1
a3402 1
static irqreturn_t i915_irq_handler(void *arg)
d3404 2
a3405 2
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
a3410 4
	u32 flip[2] = {
		I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT,
		I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT
	};
d3413 1
a3413 1
//	atomic_inc(&dev_priv->irq_received);
d3451 1
d3455 2
a3456 3
			if (hotplug_status & dev_priv->hotplug_supported_mask)
				queue_work(dev_priv->wq,
					   &dev_priv->hotplug_work);
d3470 1
a3470 1
			if (IS_MOBILE(dev))
d3472 1
d3474 2
a3475 7
			    drm_handle_vblank(dev, pipe)) {
				if (iir & flip[plane]) {
					intel_prepare_page_flip(dev, plane);
					intel_finish_page_flip(dev, pipe);
					flip_mask &= ~flip[plane];
				}
			}
d3479 3
d3506 1
a3506 1
//	i915_update_dri1_breadcrumb(dev);
d3516 2
d3540 1
a3540 1
//	atomic_set(&dev_priv->irq_received, 0);
a3555 1
	u32 hotplug_en;
d3558 1
d3570 2
d3577 7
a3583 2
	dev_priv->pipestat[0] = 0;
	dev_priv->pipestat[1] = 0;
d3604 16
a3619 21
	/* Note HDMI and DP share hotplug bits */
	hotplug_en = 0;
	if (dev_priv->hotplug_supported_mask & HDMIB_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMIB_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & HDMIC_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMIC_HOTPLUG_INT_EN;
	if (dev_priv->hotplug_supported_mask & HDMID_HOTPLUG_INT_STATUS)
		hotplug_en |= HDMID_HOTPLUG_INT_EN;
	if (IS_G4X(dev)) {
		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS_G4X)
			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS_G4X)
			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
	} else {
		if (dev_priv->hotplug_supported_mask & SDVOC_HOTPLUG_INT_STATUS_I965)
			hotplug_en |= SDVOC_HOTPLUG_INT_EN;
		if (dev_priv->hotplug_supported_mask & SDVOB_HOTPLUG_INT_STATUS_I965)
			hotplug_en |= SDVOB_HOTPLUG_INT_EN;
	}
	if (dev_priv->hotplug_supported_mask & CRT_HOTPLUG_INT_STATUS) {
		hotplug_en |= CRT_HOTPLUG_INT_EN;
d3621 8
d3632 1
a3632 1
		   */
d3635 1
d3637 3
a3640 8

	/* Ignore TV since it's buggy */

	I915_WRITE(PORT_HOTPLUG_EN, hotplug_en);

	intel_opregion_enable_asle(dev);

	return 0;
d3643 1
a3643 1
static irqreturn_t i965_irq_handler(void *arg)
d3645 2
a3646 2
	drm_i915_private_t *dev_priv = arg;
	struct drm_device *dev = dev_priv->dev;
d3652 3
d3656 1
a3656 1
//	atomic_inc(&dev_priv->irq_received);
d3663 1
a3663 1
		irq_received = iir != 0;
d3699 3
d3705 7
a3711 3
			if (hotplug_status & dev_priv->hotplug_supported_mask)
				queue_work(dev_priv->wq,
					   &dev_priv->hotplug_work);
d3717 1
a3717 1
		I915_WRITE(IIR, iir);
a3724 6
		if (iir & I915_DISPLAY_PLANE_A_FLIP_PENDING_INTERRUPT)
			intel_prepare_page_flip(dev, 0);

		if (iir & I915_DISPLAY_PLANE_B_FLIP_PENDING_INTERRUPT)
			intel_prepare_page_flip(dev, 1);

d3727 2
a3728 4
			    drm_handle_vblank(dev, pipe)) {
				i915_pageflip_stall_check(dev, pipe);
				intel_finish_page_flip(dev, pipe);
			}
d3732 3
d3741 3
d3762 1
a3762 1
//	i915_update_dri1_breadcrumb(dev);
d3775 2
d3792 35
d3832 1
a3832 1
	INIT_WORK(&dev_priv->error_work, i915_error_work_func);
d3836 14
a3849 3
	dev->driver->get_vblank_counter = i915_get_vblank_counter;
	dev->max_vblank_count = 0xffffff; /* only 24 bits of frame count */
	if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5) {
d3852 3
d3857 1
a3857 1
	if (drm_core_check_feature(dev, DRIVER_MODESET))
d3859 2
a3860 3
	else
		dev->driver->get_vblank_timestamp = NULL;
	dev->driver->get_scanout_position = i915_get_crtc_scanoutpos;
d3869 9
a3877 16
	} else if (IS_IVYBRIDGE(dev)) {
		/* Share pre & uninstall handlers with ILK/SNB */
		dev->driver->irq_handler = ivybridge_irq_handler;
		dev->driver->irq_preinstall = ironlake_irq_preinstall;
		dev->driver->irq_postinstall = ivybridge_irq_postinstall;
		dev->driver->irq_uninstall = ironlake_irq_uninstall;
		dev->driver->enable_vblank = ivybridge_enable_vblank;
		dev->driver->disable_vblank = ivybridge_disable_vblank;
	} else if (IS_HASWELL(dev)) {
		/* Share interrupts handling with IVB */
		dev->driver->irq_handler = ivybridge_irq_handler;
		dev->driver->irq_preinstall = ironlake_irq_preinstall;
		dev->driver->irq_postinstall = ivybridge_irq_postinstall;
		dev->driver->irq_uninstall = ironlake_irq_uninstall;
		dev->driver->enable_vblank = ivybridge_enable_vblank;
		dev->driver->disable_vblank = ivybridge_disable_vblank;
d3885 1
d3897 1
d3903 1
d3908 83
@


1.27
log
@Add Linux completion API and use it.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.26 2015/06/24 08:32:39 kettenis Exp $	*/
d354 1
a354 1
	wake_up_all(ring);
d1473 1
a1473 1
			wake_up_all(ring);
d1679 1
a1679 1
		if (wakeup(ring) > 0) {
d1685 1
a1685 1
		wake_up_all(ring);
@


1.26
log
@Introduce Linux work queue APIs and use them.  As a side-effect, this will
move some of the work from the system task queue to the driver-specific
task queue.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.25 2015/04/12 17:10:07 kettenis Exp $	*/
d861 1
a861 4
		mtx_enter(&dev_priv->error_completion_lock);
		dev_priv->error_completion++;
		wakeup(&dev_priv->error_completion);
		mtx_leave(&dev_priv->error_completion_lock);
d1466 1
a1466 1
//		INIT_COMPLETION(dev_priv->error_completion);
@


1.25
log
@Add a few missing trace functions, and "use" them.  Add back the WATCH_GTT
code (that isn't actually compiled in).  Use dev_priv->dev in one more place
now that we have it, and add set_normalized_timespec() and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.24 2015/04/11 14:39:37 jsg Exp $	*/
d280 1
a280 1
static void i915_hotplug_work_func(void *arg1)
d282 2
a283 1
	drm_i915_private_t *dev_priv = (drm_i915_private_t *)arg1;
d362 1
a362 1
static void gen6_pm_rps_work(void *arg1)
d364 2
a365 1
	drm_i915_private_t *dev_priv = arg1;
d407 1
a407 1
static void ivybridge_parity_work(void *arg1)
d409 2
a410 1
	drm_i915_private_t *dev_priv = arg1;
d478 1
a478 1
	task_add(systq, &dev_priv->l3_parity.error_task);
d526 1
a526 1
	task_add(systq, &dev_priv->rps.task);
d588 2
a589 1
				task_add(systq, &dev_priv->hotplug_task);
d616 1
a616 1
		task_add(systq, &dev_priv->hotplug_task);
d659 1
a659 1
		task_add(systq, &dev_priv->hotplug_task);
d841 1
a841 1
static void i915_error_work_func(void *arg1)
d843 2
a844 1
	drm_i915_private_t *dev_priv = arg1;
d1479 1
a1479 1
	task_add(systq, &dev_priv->error_task);
d2393 2
a2394 1
				task_add(systq, &dev_priv->hotplug_task);
d2631 2
a2632 1
				task_add(systq, &dev_priv->hotplug_task);
d2717 4
a2720 5
	task_set(&dev_priv->hotplug_task, i915_hotplug_work_func, dev_priv);
	task_set(&dev_priv->error_task, i915_error_work_func, dev_priv);
	task_set(&dev_priv->rps.task, gen6_pm_rps_work, dev_priv);
	task_set(&dev_priv->l3_parity.error_task, ivybridge_parity_work,
	    dev_priv);
@


1.24
log
@rename i915 interrupt handlers from *_intr back to *_irq_handler
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.23 2015/04/11 05:10:13 jsg Exp $	*/
d35 1
d351 1
a351 1
//	trace_i915_gem_request_complete(ring, ring->get_seqno(ring, false));
@


1.23
log
@change back to spinlock_t/DEFINE_SPINLOCK
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.22 2015/04/06 05:35:29 jsg Exp $	*/
d525 1
a525 1
static int valleyview_intr(void *arg)
d530 1
a530 1
	int ret = IRQ_NONE;
d680 1
a680 1
static int ivybridge_intr(void *arg)
d685 1
a685 1
	int ret = IRQ_NONE;
d753 1
a753 1
static int ironlake_intr(void *arg)
d2152 1
a2152 1
static int i8xx_intr(void *arg)
d2330 1
a2330 1
static int i915_intr(void *arg)
d2567 1
a2567 1
static int i965_intr(void *arg)
d2729 1
a2729 1
		dev->driver->irq_handler = valleyview_intr;
d2737 1
a2737 1
		dev->driver->irq_handler = ivybridge_intr;
d2745 1
a2745 1
		dev->driver->irq_handler = ivybridge_intr;
d2752 1
a2752 1
		dev->driver->irq_handler = ironlake_intr;
d2762 1
a2762 1
			dev->driver->irq_handler = i8xx_intr;
d2768 1
a2768 1
			dev->driver->irq_handler = i915_intr;
d2773 1
a2773 1
			dev->driver->irq_handler = i965_intr;
@


1.22
log
@add and use macros for wake_up/wake_up_all/wake_up_all_locked
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.21 2015/02/12 11:11:45 jsg Exp $	*/
d300 1
a300 1
extern struct mutex mchdev_lock;
@


1.21
log
@switch back to IRQ_NONE/IRQ_HANDLED
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.20 2015/02/12 04:56:03 kettenis Exp $	*/
d352 1
a352 1
	wakeup(ring);
d1470 1
a1470 1
			wakeup(ring);
d1682 1
a1682 1
		wakeup(ring);
@


1.20
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.19 2015/02/11 07:01:37 jsg Exp $	*/
a35 3

#define IRQ_NONE	0
#define IRQ_HANDLED	1
@


1.19
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.18 2015/02/10 10:50:49 jsg Exp $	*/
d285 1
a285 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
a365 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d391 1
a391 1
		gen6_set_rps(dev, new_delay);
d397 1
a409 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d419 1
a419 1
	mutex_lock(&dev->struct_mutex);
d441 1
a441 1
	mutex_unlock(&dev->struct_mutex);
a448 1
#endif
a449 1
#ifdef notyet
d458 3
a460 3
	free(parity_event[3], M_DRM, 0);
	free(parity_event[2], M_DRM, 0);
	free(parity_event[1], M_DRM, 0);
d531 1
a531 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d686 1
a686 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d759 1
a759 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d842 1
a842 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1744 1
a1744 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d2158 1
a2158 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d2336 1
a2336 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d2573 1
a2573 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
@


1.18
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.17 2015/02/10 06:19:36 jsg Exp $	*/
d1367 1
a1367 1
	printf("render error detected, EIR: 0x%08x\n", eir);
d1375 2
a1376 2
			printf("  IPEIR: 0x%08x\n", I915_READ(IPEIR_I965));
			printf("  IPEHR: 0x%08x\n", I915_READ(IPEHR_I965));
d1378 3
a1380 3
				printf("  INSTDONE_%d: 0x%08x\n", i, instdone[i]);
			printf("  INSTPS: 0x%08x\n", I915_READ(INSTPS));
			printf("  ACTHD: 0x%08x\n", I915_READ(ACTHD_I965));
d1386 2
a1387 2
			printf("page table error\n");
			printf("  PGTBL_ER: 0x%08x\n", pgtbl_err);
d1396 2
a1397 2
			printf("page table error\n");
			printf("  PGTBL_ER: 0x%08x\n", pgtbl_err);
d1404 1
a1404 1
		printf("memory refresh error:\n");
d1406 1
a1406 1
			printf("pipe %c stat: 0x%08x\n",
d1411 2
a1412 2
		printf("instruction error\n");
		printf("  INSTPM: 0x%08x\n", I915_READ(INSTPM));
d1414 1
a1414 1
			printf("  INSTDONE_%d: 0x%08x\n", i, instdone[i]);
d1418 3
a1420 3
			printf("  IPEIR: 0x%08x\n", I915_READ(IPEIR));
			printf("  IPEHR: 0x%08x\n", I915_READ(IPEHR));
			printf("  ACTHD: 0x%08x\n", I915_READ(ACTHD));
d1426 4
a1429 4
			printf("  IPEIR: 0x%08x\n", I915_READ(IPEIR_I965));
			printf("  IPEHR: 0x%08x\n", I915_READ(IPEHR_I965));
			printf("  INSTPS: 0x%08x\n", I915_READ(INSTPS));
			printf("  ACTHD: 0x%08x\n", I915_READ(ACTHD_I965));
@


1.17
log
@switch most rwlock calls back to their linux equivalents
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.16 2015/02/10 03:39:41 jsg Exp $	*/
d92 1
d98 1
a98 1
	mtx_enter(&dev_priv->irq_lock);
d110 1
a110 1
	mtx_leave(&dev_priv->irq_lock);
d310 1
d312 1
a312 1
	mtx_enter(&mchdev_lock);
d340 1
a340 1
	mtx_leave(&mchdev_lock);
d370 1
a370 1
	mtx_enter(&dev_priv->rps.lock);
d375 1
a375 1
	mtx_leave(&dev_priv->rps.lock);
d414 1
d437 1
a437 1
	mtx_enter(&dev_priv->irq_lock);
d440 1
a440 1
	mtx_leave(&dev_priv->irq_lock);
d470 1
d475 1
a475 1
	mtx_enter(&dev_priv->irq_lock);
d478 1
a478 1
	mtx_leave(&dev_priv->irq_lock);
d510 2
d522 1
a522 1
	mtx_enter(&dev_priv->rps.lock);
d526 1
a526 1
	mtx_leave(&dev_priv->rps.lock);
d537 1
d556 1
a556 1
		mtx_enter(&dev_priv->irq_lock);
d571 1
a571 1
		mtx_leave(&dev_priv->irq_lock);
d1489 1
d1496 1
a1496 1
	mtx_enter(&dev->event_lock);
d1503 1
a1503 1
		mtx_leave(&dev->event_lock);
d1520 1
a1520 1
	mtx_leave(&dev->event_lock);
d1534 1
d1539 1
a1539 1
	mtx_enter(&dev_priv->irq_lock);
d1550 1
a1550 1
	mtx_leave(&dev_priv->irq_lock);
d1558 1
d1563 1
a1563 1
	mtx_enter(&dev_priv->irq_lock);
d1566 1
a1566 1
	mtx_leave(&dev_priv->irq_lock);
d1574 1
d1579 1
a1579 1
	mtx_enter(&dev_priv->irq_lock);
d1582 1
a1582 1
	mtx_leave(&dev_priv->irq_lock);
d1590 1
d1596 1
a1596 1
	mtx_enter(&dev_priv->irq_lock);
d1605 1
a1605 1
	mtx_leave(&dev_priv->irq_lock);
d1616 1
d1618 1
a1618 1
	mtx_enter(&dev_priv->irq_lock);
d1625 1
a1625 1
	mtx_leave(&dev_priv->irq_lock);
d1631 1
d1633 1
a1633 1
	mtx_enter(&dev_priv->irq_lock);
d1636 1
a1636 1
	mtx_leave(&dev_priv->irq_lock);
d1642 1
d1644 1
a1644 1
	mtx_enter(&dev_priv->irq_lock);
d1647 1
a1647 1
	mtx_leave(&dev_priv->irq_lock);
d1653 1
d1656 1
a1656 1
	mtx_enter(&dev_priv->irq_lock);
d1665 1
a1665 1
	mtx_leave(&dev_priv->irq_lock);
d2164 1
d2183 1
a2183 1
		mtx_enter(&dev_priv->irq_lock);
d2202 1
a2202 1
		mtx_leave(&dev_priv->irq_lock);
d2341 1
d2363 1
a2363 1
		mtx_enter(&dev_priv->irq_lock);
d2380 1
a2380 1
		mtx_leave(&dev_priv->irq_lock);
d2579 1
d2597 1
a2597 1
		mtx_enter(&dev_priv->irq_lock);
d2616 1
a2616 1
		mtx_leave(&dev_priv->irq_lock);
@


1.16
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.15 2015/02/10 01:39:32 jsg Exp $	*/
d378 1
a378 1
	rw_enter_write(&dev_priv->rps.hw_lock);
d393 1
a393 1
	rw_exit_write(&dev_priv->rps.hw_lock);
@


1.15
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.14 2015/01/27 03:17:36 dlg Exp $	*/
d288 1
a288 1
	rw_enter_write(&mode_config->rwl);
d295 1
a295 1
	rw_exit_write(&mode_config->rwl);
@


1.14
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.13 2014/07/12 18:48:52 tedu Exp $	*/
d417 1
a417 1
	DRM_LOCK();
d439 1
a439 1
	DRM_UNLOCK();
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.12 2014/03/24 17:06:49 kettenis Exp $	*/
d281 1
a281 1
static void i915_hotplug_work_func(void *arg1, void *arg2)
d361 1
a361 1
static void gen6_pm_rps_work(void *arg1, void *arg2)
d405 1
a405 1
static void ivybridge_parity_work(void *arg1, void *arg2)
d835 1
a835 1
static void i915_error_work_func(void *arg1, void *arg2)
d2696 3
a2698 6
	task_set(&dev_priv->hotplug_task, i915_hotplug_work_func,
	    dev_priv, NULL);
	task_set(&dev_priv->error_task, i915_error_work_func,
	    dev_priv, NULL);
	task_set(&dev_priv->rps.task, gen6_pm_rps_work,
	    dev_priv, NULL);
d2700 1
a2700 1
	    dev_priv, NULL);
@


1.12
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.11 2014/02/05 10:58:48 kettenis Exp $	*/
d458 3
a460 3
	free(parity_event[3], M_DRM);
	free(parity_event[2], M_DRM);
	free(parity_event[1], M_DRM);
@


1.11
log
@We have WARN_ONCE now.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.10 2014/01/24 04:05:06 jsg Exp $	*/
d37 3
d530 1
a530 1
	int ret = 0;
d545 1
a545 1
		ret = 1;
d684 1
a684 1
	int ret = 0;
d697 1
a697 1
		ret = 1;
d725 1
a725 1
		ret = 1;
d733 1
a733 1
		ret = 1;
d756 1
a756 1
	int ret = 0;
d775 1
a775 1
	ret = 1;
d2158 1
a2158 1
		return 0;
d2216 1
a2216 1
	return 1;
d2331 1
a2331 1
	int pipe, ret = 0;
d2422 1
a2422 1
		ret = 1;
d2562 1
a2562 1
	int ret = 0, pipe;
d2602 1
a2602 1
		ret = 1;
@


1.10
log
@drm/i915: Move num_pipes to intel info

From Ben Widawsky
7ed1faada973243b6e11fa209ada91c9cc1dab53 in ubuntu 3.8
7eb552aeae058a88eece91b902dd51fde45b1f41 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.9 2013/10/30 02:11:32 dlg Exp $	*/
d877 1
a877 1
//		WARN_ONCE(1, "Unsupported platform\n");
@


1.9
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.8 2013/10/29 06:30:57 jsg Exp $	*/
a249 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d252 1
a252 1
	if (pipe < 0 || pipe >= dev_priv->num_pipe) {
@


1.8
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.7 2013/08/13 10:23:50 jsg Exp $	*/
d474 1
a474 1
	task_add(taskq_systq(), &dev_priv->l3_parity.error_task);
d520 1
a520 1
	task_add(taskq_systq(), &dev_priv->rps.task);
d581 1
a581 1
				task_add(taskq_systq(), &dev_priv->hotplug_task);
d608 1
a608 1
		task_add(taskq_systq(), &dev_priv->hotplug_task);
d651 1
a651 1
		task_add(taskq_systq(), &dev_priv->hotplug_task);
d1470 1
a1470 1
	task_add(taskq_systq(), &dev_priv->error_task);
d2373 1
a2373 1
				task_add(taskq_systq(), &dev_priv->hotplug_task);
d2609 1
a2609 1
				task_add(taskq_systq(), &dev_priv->hotplug_task);
@


1.7
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.6 2013/07/05 07:20:27 jsg Exp $	*/
d474 1
a474 3
	workq_queue_task(NULL, &dev_priv->l3_parity.error_task, 0,
	    ivybridge_parity_work, dev_priv, NULL);
	
d520 1
a520 2
	workq_queue_task(NULL, &dev_priv->rps.task, 0, gen6_pm_rps_work,
	    dev_priv, NULL);
d581 1
a581 2
				workq_queue_task(NULL, &dev_priv->hotplug_task,
				    0, i915_hotplug_work_func, dev_priv, NULL);
d608 1
a608 2
		workq_queue_task(NULL, &dev_priv->hotplug_task, 0,
		    i915_hotplug_work_func, dev_priv, NULL);
d651 1
a651 2
		workq_queue_task(NULL, &dev_priv->hotplug_task, 0,
		    i915_hotplug_work_func, dev_priv, NULL);
d1470 1
a1470 2
	workq_queue_task(NULL, &dev_priv->error_task, 0,
	    i915_error_work_func, dev_priv, NULL);
d2373 1
a2373 2
				workq_queue_task(NULL, &dev_priv->hotplug_task,
				    0, i915_hotplug_work_func, dev_priv, NULL);
d2609 1
a2609 2
				workq_queue_task(NULL, &dev_priv->hotplug_task,
				    0, i915_hotplug_work_func, dev_priv, NULL);
d2692 10
@


1.6
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.5 2013/04/17 20:04:04 kettenis Exp $	*/
a36 59
void	 ironlake_enable_display_irq(drm_i915_private_t *, u32);
void	 intel_enable_asle(struct drm_device *);
int	 i915_pipeconf_enabled(struct drm_device *, int);
u32	 gm45_get_vblank_counter(struct drm_device *, int);
int	 i915_get_crtc_scanoutpos(struct drm_device *, int, int *, int *);
int	 i915_get_vblank_timestamp(struct drm_device *, int, int *,
	     struct timeval *, unsigned);
void	 ironlake_handle_rps_change(struct drm_device *);
void	 notify_ring(struct drm_device *, struct intel_ring_buffer *);
void	 ivybridge_handle_parity_error(struct drm_device *);
void	 snb_gt_irq_handler(struct drm_device *, struct drm_i915_private *, u32);
void	 snb_gt_irq_handler(struct drm_device *, struct drm_i915_private *, u32);
void	 gen6_queue_rps_work(struct drm_i915_private *, u32);
int	 valleyview_intr(void *);
void	 ibx_irq_handler(struct drm_device *, u32);
void	 cpt_irq_handler(struct drm_device *, u32);
int	 ivybridge_intr(void *);
void	 ilk_gt_irq_handler(struct drm_device *, struct drm_i915_private *, u32);
int	 ironlake_intr(void *);
void	 i915_get_extra_instdone(struct drm_device *, uint32_t *);
void	 i915_report_and_clear_eir(struct drm_device *);
void	 i915_handle_error(struct drm_device *, bool);
void	 i915_pageflip_stall_check(struct drm_device *, int);
int	 ironlake_enable_vblank(struct drm_device *, int);
int	 ivybridge_enable_vblank(struct drm_device *, int);
int	 valleyview_enable_vblank(struct drm_device *, int);
void	 ironlake_disable_vblank(struct drm_device *, int);
void	 ivybridge_disable_vblank(struct drm_device *, int);
void	 valleyview_disable_vblank(struct drm_device *, int);
u32	 ring_last_seqno(struct intel_ring_buffer *);
bool	 i915_hangcheck_ring_idle(struct intel_ring_buffer *, bool *);
bool	 kick_ring(struct intel_ring_buffer *);
bool	 i915_hangcheck_hung(struct drm_device *);
void	 ironlake_irq_preinstall(struct drm_device *);
void	 valleyview_irq_preinstall(struct drm_device *);
void	 ironlake_enable_pch_hotplug(struct drm_device *);
int	 ironlake_irq_postinstall(struct drm_device *);
int	 ivybridge_irq_postinstall(struct drm_device *);
int	 valleyview_irq_postinstall(struct drm_device *);
void	 valleyview_irq_uninstall(struct drm_device *);
void	 ironlake_irq_uninstall(struct drm_device *);
void	 i8xx_irq_preinstall(struct drm_device *);
int	 i8xx_irq_postinstall(struct drm_device *);
int	 i8xx_intr(void *);
void	 i8xx_irq_uninstall(struct drm_device *);
void	 i915_irq_preinstall(struct drm_device *);
int	 i915_irq_postinstall(struct drm_device *);
int	 i915_intr(void *);
void	 i915_irq_uninstall(struct drm_device *);
void	 i965_irq_preinstall(struct drm_device *);
int	 i965_irq_postinstall(struct drm_device *);
int	 i965_intr(void *);
void	 i965_irq_uninstall(struct drm_device *);
void	 intel_irq_init(struct drm_device *);
void	 i915_hotplug_work_func(void *, void *);
void	 i915_error_work_func(void *, void *);
void	 ivybridge_parity_work(void *, void *);
void	 gen6_pm_rps_work(void *, void *);

d38 1
a38 1
void
d86 1
a86 2
void
intel_enable_asle(struct drm_device *dev)
d110 1
a110 1
 * i915_pipeconf_enabled - check if a pipe is enabled
d118 2
a119 2
int
i915_pipeconf_enabled(struct drm_device *dev, int pipe)
d131 1
a131 2
u32
i915_get_vblank_counter(struct drm_device *dev, int pipe)
d138 1
a138 1
	if (!i915_pipeconf_enabled(dev, pipe)) {
d163 1
a163 2
u32
gm45_get_vblank_counter(struct drm_device *dev, int pipe)
d168 1
a168 1
	if (!i915_pipeconf_enabled(dev, pipe)) {
d177 1
a177 2
int
i915_get_crtc_scanoutpos(struct drm_device *dev, int pipe,
d188 1
a188 1
	if (!i915_pipeconf_enabled(dev, pipe)) {
d245 1
a245 2
int
i915_get_vblank_timestamp(struct drm_device *dev, int pipe,
d279 1
a279 2
void
i915_hotplug_work_func(void *arg1, void *arg2)
d302 1
a302 2
void
ironlake_handle_rps_change(struct drm_device *dev)
d341 1
a341 2
void
notify_ring(struct drm_device *dev,
d359 1
a359 2
void
gen6_pm_rps_work(void *arg1, void *arg2)
d403 1
a403 2
void
ivybridge_parity_work(void *arg1, void *arg2)
d462 1
a462 2
void
ivybridge_handle_parity_error(struct drm_device *dev)
d479 1
a479 2
void
snb_gt_irq_handler(struct drm_device *dev,
d503 1
a503 2
void
gen6_queue_rps_work(struct drm_i915_private *dev_priv,
d526 1
a526 2
int
valleyview_intr(void *arg)
d606 1
a606 2
void
ibx_irq_handler(struct drm_device *dev, u32 pch_iir)
d650 1
a650 2
void
cpt_irq_handler(struct drm_device *dev, u32 pch_iir)
d683 1
a683 2
int
ivybridge_intr(void *arg)
d746 1
a746 2
void
ilk_gt_irq_handler(struct drm_device *dev,
d756 1
a756 2
int
ironlake_intr(void *arg)
d839 1
a839 2
void
i915_error_work_func(void *arg1, void *arg2)
d866 1
a866 2
void
i915_get_extra_instdone(struct drm_device *dev,
d895 1
a895 1
struct drm_i915_error_object *
d967 1
a967 1
void
d998 1
a998 3

void
capture_bo(struct drm_i915_error_buffer *err,
d1021 1
a1021 2
u32
capture_active_bo(struct drm_i915_error_buffer *err,
d1036 1
a1036 2
u32
capture_pinned_bo(struct drm_i915_error_buffer *err,
d1054 1
a1054 2
void
i915_gem_record_fences(struct drm_device *dev,
d1084 1
a1084 1
struct drm_i915_error_object *
d1126 1
a1126 2
void
i915_record_ring_state(struct drm_device *dev,
d1170 1
a1170 2
void
i915_gem_record_rings(struct drm_device *dev,
d1221 1
a1221 2
void
i915_capture_error_state(struct drm_device *dev)
d1336 1
a1336 2
void
i915_destroy_error_state(struct drm_device *dev)
d1354 1
a1354 2
void
i915_report_and_clear_eir(struct drm_device *dev)
d1456 1
a1456 2
void
i915_handle_error(struct drm_device *dev, bool wedged)
d1480 1
a1480 2
void
i915_pageflip_stall_check(struct drm_device *dev, int pipe)
d1528 1
a1528 2
int
i915_enable_vblank(struct drm_device *dev, int pipe)
d1532 1
a1532 1
	if (!i915_pipeconf_enabled(dev, pipe))
d1551 1
a1551 2
int
ironlake_enable_vblank(struct drm_device *dev, int pipe)
d1555 1
a1555 1
	if (!i915_pipeconf_enabled(dev, pipe))
d1566 1
a1566 2
int
ivybridge_enable_vblank(struct drm_device *dev, int pipe)
d1570 1
a1570 1
	if (!i915_pipeconf_enabled(dev, pipe))
d1581 1
a1581 2
int
valleyview_enable_vblank(struct drm_device *dev, int pipe)
d1586 1
a1586 1
	if (!i915_pipeconf_enabled(dev, pipe))
d1606 1
a1606 2
void
i915_disable_vblank(struct drm_device *dev, int pipe)
d1620 1
a1620 2
void
ironlake_disable_vblank(struct drm_device *dev, int pipe)
d1630 1
a1630 2
void
ivybridge_disable_vblank(struct drm_device *dev, int pipe)
d1640 1
a1640 2
void
valleyview_disable_vblank(struct drm_device *dev, int pipe)
d1657 1
a1657 1
u32
d1664 1
a1664 2
bool
i915_hangcheck_ring_idle(struct intel_ring_buffer *ring, bool *err)
d1684 1
a1684 2
bool
kick_ring(struct intel_ring_buffer *ring)
d1698 1
a1698 2
bool
i915_hangcheck_hung(struct drm_device *dev)
d1733 1
a1733 2
void
i915_hangcheck_elapsed(void *arg)
d1784 1
a1784 2
void
ironlake_irq_preinstall(struct drm_device *dev)
d1809 1
a1809 2
void
valleyview_irq_preinstall(struct drm_device *dev)
d1848 1
a1848 2
void
ironlake_enable_pch_hotplug(struct drm_device *dev)
d1861 1
a1861 2
int
ironlake_irq_postinstall(struct drm_device *dev)
d1928 1
a1928 2
int
ivybridge_irq_postinstall(struct drm_device *dev)
d1978 1
a1978 2
int
valleyview_irq_postinstall(struct drm_device *dev)
d2060 1
a2060 2
void
valleyview_irq_uninstall(struct drm_device *dev)
d2082 1
a2082 2
void
ironlake_irq_uninstall(struct drm_device *dev)
d2104 1
a2104 2
void
i8xx_irq_preinstall(struct drm_device * dev)
d2118 1
a2118 2
int
i8xx_irq_postinstall(struct drm_device *dev)
d2147 1
a2147 2
int
i8xx_intr(void *arg)
d2224 1
a2224 2
void
i8xx_irq_uninstall(struct drm_device * dev)
d2239 1
a2239 2
void
i915_irq_preinstall(struct drm_device * dev)
d2259 1
a2259 2
int
i915_irq_postinstall(struct drm_device *dev)
d2324 1
a2324 2
int
i915_intr(void *arg)
d2437 1
a2437 2
void
i915_irq_uninstall(struct drm_device * dev)
d2459 1
a2459 2
void
i965_irq_preinstall(struct drm_device * dev)
d2477 1
a2477 2
int
i965_irq_postinstall(struct drm_device *dev)
d2561 1
a2561 2
int
i965_intr(void *arg)
d2676 1
a2676 2
void
i965_irq_uninstall(struct drm_device * dev)
d2699 1
a2699 2
void
intel_irq_init(struct drm_device *dev)
@


1.5
log
@Another round of reducing diffs with Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.4 2013/03/28 20:37:50 kettenis Exp $	*/
d47 3
a49 3
void	 snb_gt_irq_handler(struct drm_device *, struct inteldrm_softc *, u32);
void	 snb_gt_irq_handler(struct drm_device *, struct inteldrm_softc *, u32);
void	 gen6_queue_rps_work(struct inteldrm_softc *, u32);
d54 1
a54 1
void	 ilk_gt_irq_handler(struct drm_device *, struct inteldrm_softc *, u32);
d314 1
a314 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d411 1
a411 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d551 1
a551 1
			       struct inteldrm_softc *dev_priv,
d575 1
a575 1
gen6_queue_rps_work(struct inteldrm_softc *dev_priv,
d824 1
a824 1
			       struct inteldrm_softc *dev_priv,
d949 1
a949 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d976 1
a976 1
i915_error_object_create(struct inteldrm_softc *dev_priv,
d1142 1
a1142 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1170 1
a1170 1
i915_error_first_batchbuffer(struct inteldrm_softc *dev_priv,
d1216 1
a1216 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1260 1
a1260 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1311 1
a1311 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1427 1
a1427 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1446 1
a1446 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1549 1
a1549 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1789 1
a1789 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1839 1
a1839 1
	struct inteldrm_softc *dev_priv = arg;
a2825 1
//	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.4
log
@Reduce diffs with Linux now that we have i915_enable_hangcheck.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.3 2013/03/21 08:27:32 jsg Exp $	*/
d557 1
a557 1
		notify_ring(dev, &dev_priv->rings[RCS]);
d559 1
a559 1
		notify_ring(dev, &dev_priv->rings[VCS]);
d561 1
a561 1
		notify_ring(dev, &dev_priv->rings[BCS]);
d828 1
a828 1
		notify_ring(dev, &dev_priv->rings[RCS]);
d830 1
a830 1
		notify_ring(dev, &dev_priv->rings[VCS]);
d2313 1
a2313 1
			notify_ring(dev, &dev_priv->rings[RCS]);
d2510 1
a2510 1
			notify_ring(dev, &dev_priv->rings[RCS]);
d2751 1
a2751 1
			notify_ring(dev, &dev_priv->rings[RCS]);
d2753 1
a2753 1
			notify_ring(dev, &dev_priv->rings[VCS]);
@


1.3
log
@Enable the opregion code but keep the parts that try to talk to acpi
disabled for now.  Makes the brightness keys on my x230 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.2 2013/03/20 12:37:41 jsg Exp $	*/
a418 5
	dev_priv->hangcheck_count = 0;
	timeout_add_msec(&dev_priv->hangcheck_timer, DRM_I915_HANGCHECK_PERIOD);

#ifdef notyet
	wakeup(&ring->irq_queue);
d421 2
a422 2
		mod_timer(&dev_priv->hangcheck_timer,
			  round_jiffies_up(jiffies + DRM_I915_HANGCHECK_JIFFIES));
a423 1
#endif
a1845 1
#ifdef notyet
a1847 1
#endif
@


1.2
log
@Backout some changes introduced in linux 3.8.3 which are known
to cause problems and have been reverted in linux 3.8.4-rc1:

"drm/i915: reorder setup sequence to have irqs for output setup"
"drm/i915: enable irqs earlier when resuming"

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_irq.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
a787 1
#ifdef notyet
a789 1
#endif
a869 1
#ifdef notyet
a871 1
#endif
a2396 1
#ifdef notyet
a2397 3
#else
		~(
#endif
a2404 1
#ifdef notyet
a2405 1
#endif
d2445 1
a2445 1
//	intel_opregion_enable_asle(dev);
a2536 1
#ifdef notyet
a2538 1
#endif
a2614 1
#ifdef notyet
a2615 3
#else
	dev_priv->irq_mask = ~(
#endif
a2685 1
#ifdef notyet
a2686 1
#endif
a2780 1
#ifdef notyet
a2782 1
#endif
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a349 4

	/* HPD irq before everything is fully set up. */
	if (!dev_priv->enable_hotplug_processing)
		return;
@

