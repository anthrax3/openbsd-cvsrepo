head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.8
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.6
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.2
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.6.0.10
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.8
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.6
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.8
date	2016.02.24.21.06.13;	author jsg;	state Exp;
branches;
next	1.7;
commitid	JgXu6nceb5ev8ENq;

1.7
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	lQlppvmETCN49oZe;

1.6
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.13.10.23.49;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.31.11.43.23;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.30.12.36.50;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Fix the build with DRMDEBUG.  Committing now instead of after unlock to
make it easier for people running release to diagnose drm problems.
ok deraadt@@
@
text
@/*	$OpenBSD: dvo_ns2501.c,v 1.7 2015/09/23 23:12:11 kettenis Exp $	*/
/*
 *
 * Copyright (c) 2012 Gilles Dartiguelongue, Thomas Richter
 *
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

#include "dvo.h"
#include "i915_reg.h"
#include "i915_drv.h"

#define NS2501_VID 0x1305
#define NS2501_DID 0x6726

#define NS2501_VID_LO 0x00
#define NS2501_VID_HI 0x01
#define NS2501_DID_LO 0x02
#define NS2501_DID_HI 0x03
#define NS2501_REV 0x04
#define NS2501_RSVD 0x05
#define NS2501_FREQ_LO 0x06
#define NS2501_FREQ_HI 0x07

#define NS2501_REG8 0x08
#define NS2501_8_VEN (1<<5)
#define NS2501_8_HEN (1<<4)
#define NS2501_8_DSEL (1<<3)
#define NS2501_8_BPAS (1<<2)
#define NS2501_8_RSVD (1<<1)
#define NS2501_8_PD (1<<0)

#define NS2501_REG9 0x09
#define NS2501_9_VLOW (1<<7)
#define NS2501_9_MSEL_MASK (0x7<<4)
#define NS2501_9_TSEL (1<<3)
#define NS2501_9_RSEN (1<<2)
#define NS2501_9_RSVD (1<<1)
#define NS2501_9_MDI (1<<0)

#define NS2501_REGC 0x0c

struct ns2501_priv {
	//I2CDevRec d;
	bool quiet;
	int reg_8_shadow;
	int reg_8_set;
	// Shadow registers for i915
	int dvoc;
	int pll_a;
	int srcdim;
	int fw_blc;
};

#define NSPTR(d) ((NS2501Ptr)(d->DriverPrivate.ptr))

/*
 * For reasons unclear to me, the ns2501 at least on the Fujitsu/Siemens
 * laptops does not react on the i2c bus unless
 * both the PLL is running and the display is configured in its native
 * resolution.
 * This function forces the DVO on, and stores the registers it touches.
 * Afterwards, registers are restored to regular values.
 *
 * This is pretty much a hack, though it works.
 * Without that, ns2501_readb and ns2501_writeb fail
 * when switching the resolution.
 */

/*
** Read a register from the ns2501.
** Returns true if successful, false otherwise.
** If it returns false, it might be wise to enable the
** DVO with the above function.
*/
static bool ns2501_readb(struct intel_dvo_device *dvo, int addr, uint8_t * ch)
{
	struct ns2501_priv *ns = dvo->dev_priv;
	struct i2c_controller *adapter = dvo->i2c_bus;
	u8 out_buf[2];
	u8 in_buf[2];
	int ret;

	out_buf[0] = addr;
	out_buf[1] = 0;

	iic_acquire_bus(adapter, 0);
	ret = iic_exec(adapter, I2C_OP_READ_WITH_STOP, dvo->slave_addr,
	    &out_buf, 1, in_buf, 1, 0);
	if (ret)
		goto read_err;
	iic_release_bus(adapter, 0);

	*ch = in_buf[0];
	return true;

read_err:
	iic_release_bus(adapter, 0);
	if (!ns->quiet) {
		DRM_DEBUG_KMS
		    ("Unable to read register 0x%02x from 0x%02x.\n", addr,
		     dvo->slave_addr);
	}

	return false;
}

/*
** Write a register to the ns2501.
** Returns true if successful, false otherwise.
** If it returns false, it might be wise to enable the
** DVO with the above function.
*/
static bool ns2501_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)
{
	struct ns2501_priv *ns = dvo->dev_priv;
	struct i2c_controller *adapter = dvo->i2c_bus;
	uint8_t out_buf[2];
	int ret;

	out_buf[0] = addr;
	out_buf[1] = ch;

	iic_acquire_bus(adapter, 0);
	ret = iic_exec(adapter, I2C_OP_WRITE_WITH_STOP, dvo->slave_addr,
	    NULL, 0, out_buf, 2, 0);
	iic_release_bus(adapter, 0);
	if (ret)
		goto write_err;

	return true;

write_err:
	if (!ns->quiet) {
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %d\n",
			      addr, dvo->slave_addr);
	}

	return false;
}

/* National Semiconductor 2501 driver for chip on i2c bus
 * scan for the chip on the bus.
 * Hope the VBIOS initialized the PLL correctly so we can
 * talk to it. If not, it will not be seen and not detected.
 * Bummer!
 */
static bool ns2501_init(struct intel_dvo_device *dvo,
			struct i2c_controller *adapter)
{
	/* this will detect the NS2501 chip on the specified i2c bus */
	struct ns2501_priv *ns;
	unsigned char ch;

	ns = kzalloc(sizeof(struct ns2501_priv), GFP_KERNEL);
	if (ns == NULL)
		return false;

	dvo->i2c_bus = adapter;
	dvo->dev_priv = ns;
	ns->quiet = true;

	if (!ns2501_readb(dvo, NS2501_VID_LO, &ch))
		goto out;

	if (ch != (NS2501_VID & 0xff)) {
		DRM_DEBUG_KMS("ns2501 not detected got %d: from Slave %d.\n",
			      ch, dvo->slave_addr);
		goto out;
	}

	if (!ns2501_readb(dvo, NS2501_DID_LO, &ch))
		goto out;

	if (ch != (NS2501_DID & 0xff)) {
		DRM_DEBUG_KMS("ns2501 not detected got %d: from Slave %d.\n",
			      ch, dvo->slave_addr);
		goto out;
	}
	ns->quiet = false;
	ns->reg_8_set = 0;
	ns->reg_8_shadow =
	    NS2501_8_PD | NS2501_8_BPAS | NS2501_8_VEN | NS2501_8_HEN;

	DRM_DEBUG_KMS("init ns2501 dvo controller successfully!\n");
	return true;

out:
	kfree(ns);
	return false;
}

static enum drm_connector_status ns2501_detect(struct intel_dvo_device *dvo)
{
	/*
	 * This is a Laptop display, it doesn't have hotplugging.
	 * Even if not, the detection bit of the 2501 is unreliable as
	 * it only works for some display types.
	 * It is even more unreliable as the PLL must be active for
	 * allowing reading from the chiop.
	 */
	return connector_status_connected;
}

static enum drm_mode_status ns2501_mode_valid(struct intel_dvo_device *dvo,
					      struct drm_display_mode *mode)
{
	DRM_DEBUG_KMS
	    ("%s: is mode valid (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d)\n",
	     __FUNCTION__, mode->hdisplay, mode->htotal, mode->vdisplay,
	     mode->vtotal);

	/*
	 * Currently, these are all the modes I have data from.
	 * More might exist. Unclear how to find the native resolution
	 * of the panel in here so we could always accept it
	 * by disabling the scaler.
	 */
	if ((mode->hdisplay == 800 && mode->vdisplay == 600) ||
	    (mode->hdisplay == 640 && mode->vdisplay == 480) ||
	    (mode->hdisplay == 1024 && mode->vdisplay == 768)) {
		return MODE_OK;
	} else {
		return MODE_ONE_SIZE;	/* Is this a reasonable error? */
	}
}

static void ns2501_mode_set(struct intel_dvo_device *dvo,
			    struct drm_display_mode *mode,
			    struct drm_display_mode *adjusted_mode)
{
	bool ok;
	int retries = 10;
	struct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);

	DRM_DEBUG_KMS
	    ("%s: set mode (hdisplay=%d,htotal=%d,vdisplay=%d,vtotal=%d).\n",
	     __FUNCTION__, mode->hdisplay, mode->htotal, mode->vdisplay,
	     mode->vtotal);

	/*
	 * Where do I find the native resolution for which scaling is not required???
	 *
	 * First trigger the DVO on as otherwise the chip does not appear on the i2c
	 * bus.
	 */
	do {
		ok = true;

		if (mode->hdisplay == 800 && mode->vdisplay == 600) {
			/* mode 277 */
			ns->reg_8_shadow &= ~NS2501_8_BPAS;
			DRM_DEBUG_KMS("%s: switching to 800x600\n",
				      __FUNCTION__);

			/*
			 * No, I do not know where this data comes from.
			 * It is just what the video bios left in the DVO, so
			 * I'm just copying it here over.
			 * This also means that I cannot support any other modes
			 * except the ones supported by the bios.
			 */
			ok &= ns2501_writeb(dvo, 0x11, 0xc8);	// 0xc7 also works.
			ok &= ns2501_writeb(dvo, 0x1b, 0x19);
			ok &= ns2501_writeb(dvo, 0x1c, 0x62);	// VBIOS left 0x64 here, but 0x62 works nicer
			ok &= ns2501_writeb(dvo, 0x1d, 0x02);

			ok &= ns2501_writeb(dvo, 0x34, 0x03);
			ok &= ns2501_writeb(dvo, 0x35, 0xff);

			ok &= ns2501_writeb(dvo, 0x80, 0x27);
			ok &= ns2501_writeb(dvo, 0x81, 0x03);
			ok &= ns2501_writeb(dvo, 0x82, 0x41);
			ok &= ns2501_writeb(dvo, 0x83, 0x05);

			ok &= ns2501_writeb(dvo, 0x8d, 0x02);
			ok &= ns2501_writeb(dvo, 0x8e, 0x04);
			ok &= ns2501_writeb(dvo, 0x8f, 0x00);

			ok &= ns2501_writeb(dvo, 0x90, 0xfe);	/* vertical. VBIOS left 0xff here, but 0xfe works better */
			ok &= ns2501_writeb(dvo, 0x91, 0x07);
			ok &= ns2501_writeb(dvo, 0x94, 0x00);
			ok &= ns2501_writeb(dvo, 0x95, 0x00);

			ok &= ns2501_writeb(dvo, 0x96, 0x00);

			ok &= ns2501_writeb(dvo, 0x99, 0x00);
			ok &= ns2501_writeb(dvo, 0x9a, 0x88);

			ok &= ns2501_writeb(dvo, 0x9c, 0x23);	/* Looks like first and last line of the image. */
			ok &= ns2501_writeb(dvo, 0x9d, 0x00);
			ok &= ns2501_writeb(dvo, 0x9e, 0x25);
			ok &= ns2501_writeb(dvo, 0x9f, 0x03);

			ok &= ns2501_writeb(dvo, 0xa4, 0x80);

			ok &= ns2501_writeb(dvo, 0xb6, 0x00);

			ok &= ns2501_writeb(dvo, 0xb9, 0xc8);	/* horizontal? */
			ok &= ns2501_writeb(dvo, 0xba, 0x00);	/* horizontal? */

			ok &= ns2501_writeb(dvo, 0xc0, 0x05);	/* horizontal? */
			ok &= ns2501_writeb(dvo, 0xc1, 0xd7);

			ok &= ns2501_writeb(dvo, 0xc2, 0x00);
			ok &= ns2501_writeb(dvo, 0xc3, 0xf8);

			ok &= ns2501_writeb(dvo, 0xc4, 0x03);
			ok &= ns2501_writeb(dvo, 0xc5, 0x1a);

			ok &= ns2501_writeb(dvo, 0xc6, 0x00);
			ok &= ns2501_writeb(dvo, 0xc7, 0x73);
			ok &= ns2501_writeb(dvo, 0xc8, 0x02);

		} else if (mode->hdisplay == 640 && mode->vdisplay == 480) {
			/* mode 274 */
			DRM_DEBUG_KMS("%s: switching to 640x480\n",
				      __FUNCTION__);
			/*
			 * No, I do not know where this data comes from.
			 * It is just what the video bios left in the DVO, so
			 * I'm just copying it here over.
			 * This also means that I cannot support any other modes
			 * except the ones supported by the bios.
			 */
			ns->reg_8_shadow &= ~NS2501_8_BPAS;

			ok &= ns2501_writeb(dvo, 0x11, 0xa0);
			ok &= ns2501_writeb(dvo, 0x1b, 0x11);
			ok &= ns2501_writeb(dvo, 0x1c, 0x54);
			ok &= ns2501_writeb(dvo, 0x1d, 0x03);

			ok &= ns2501_writeb(dvo, 0x34, 0x03);
			ok &= ns2501_writeb(dvo, 0x35, 0xff);

			ok &= ns2501_writeb(dvo, 0x80, 0xff);
			ok &= ns2501_writeb(dvo, 0x81, 0x07);
			ok &= ns2501_writeb(dvo, 0x82, 0x3d);
			ok &= ns2501_writeb(dvo, 0x83, 0x05);

			ok &= ns2501_writeb(dvo, 0x8d, 0x02);
			ok &= ns2501_writeb(dvo, 0x8e, 0x10);
			ok &= ns2501_writeb(dvo, 0x8f, 0x00);

			ok &= ns2501_writeb(dvo, 0x90, 0xff);	/* vertical */
			ok &= ns2501_writeb(dvo, 0x91, 0x07);
			ok &= ns2501_writeb(dvo, 0x94, 0x00);
			ok &= ns2501_writeb(dvo, 0x95, 0x00);

			ok &= ns2501_writeb(dvo, 0x96, 0x05);

			ok &= ns2501_writeb(dvo, 0x99, 0x00);
			ok &= ns2501_writeb(dvo, 0x9a, 0x88);

			ok &= ns2501_writeb(dvo, 0x9c, 0x24);
			ok &= ns2501_writeb(dvo, 0x9d, 0x00);
			ok &= ns2501_writeb(dvo, 0x9e, 0x25);
			ok &= ns2501_writeb(dvo, 0x9f, 0x03);

			ok &= ns2501_writeb(dvo, 0xa4, 0x84);

			ok &= ns2501_writeb(dvo, 0xb6, 0x09);

			ok &= ns2501_writeb(dvo, 0xb9, 0xa0);	/* horizontal? */
			ok &= ns2501_writeb(dvo, 0xba, 0x00);	/* horizontal? */

			ok &= ns2501_writeb(dvo, 0xc0, 0x05);	/* horizontal? */
			ok &= ns2501_writeb(dvo, 0xc1, 0x90);

			ok &= ns2501_writeb(dvo, 0xc2, 0x00);
			ok &= ns2501_writeb(dvo, 0xc3, 0x0f);

			ok &= ns2501_writeb(dvo, 0xc4, 0x03);
			ok &= ns2501_writeb(dvo, 0xc5, 0x16);

			ok &= ns2501_writeb(dvo, 0xc6, 0x00);
			ok &= ns2501_writeb(dvo, 0xc7, 0x02);
			ok &= ns2501_writeb(dvo, 0xc8, 0x02);

		} else if (mode->hdisplay == 1024 && mode->vdisplay == 768) {
			/* mode 280 */
			DRM_DEBUG_KMS("%s: switching to 1024x768\n",
				      __FUNCTION__);
			/*
			 * This might or might not work, actually. I'm silently
			 * assuming here that the native panel resolution is
			 * 1024x768. If not, then this leaves the scaler disabled
			 * generating a picture that is likely not the expected.
			 *
			 * Problem is that I do not know where to take the panel
			 * dimensions from.
			 *
			 * Enable the bypass, scaling not required.
			 *
			 * The scaler registers are irrelevant here....
			 *
			 */
			ns->reg_8_shadow |= NS2501_8_BPAS;
			ok &= ns2501_writeb(dvo, 0x37, 0x44);
		} else {
			/*
			 * Data not known. Bummer!
			 * Hopefully, the code should not go here
			 * as mode_OK delivered no other modes.
			 */
			ns->reg_8_shadow |= NS2501_8_BPAS;
		}
		ok &= ns2501_writeb(dvo, NS2501_REG8, ns->reg_8_shadow);
	} while (!ok && retries--);
}

/* set the NS2501 power state */
static bool ns2501_get_hw_state(struct intel_dvo_device *dvo)
{
	unsigned char ch;

	if (!ns2501_readb(dvo, NS2501_REG8, &ch))
		return false;

	if (ch & NS2501_8_PD)
		return true;
	else
		return false;
}

/* set the NS2501 power state */
static void ns2501_dpms(struct intel_dvo_device *dvo, bool enable)
{
	bool ok;
	int retries = 10;
	struct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);
	unsigned char ch;

	DRM_DEBUG_KMS("%s: Trying set the dpms of the DVO to %i\n",
		      __FUNCTION__, enable);

	ch = ns->reg_8_shadow;

	if (enable)
		ch |= NS2501_8_PD;
	else
		ch &= ~NS2501_8_PD;

	if (ns->reg_8_set == 0 || ns->reg_8_shadow != ch) {
		ns->reg_8_set = 1;
		ns->reg_8_shadow = ch;

		do {
			ok = true;
			ok &= ns2501_writeb(dvo, NS2501_REG8, ch);
			ok &=
			    ns2501_writeb(dvo, 0x34,
					  enable ? 0x03 : 0x00);
			ok &=
			    ns2501_writeb(dvo, 0x35,
					  enable ? 0xff : 0x00);
		} while (!ok && retries--);
	}
}

static void ns2501_dump_regs(struct intel_dvo_device *dvo)
{
	uint8_t val;

	ns2501_readb(dvo, NS2501_FREQ_LO, &val);
	DRM_LOG_KMS("NS2501_FREQ_LO: 0x%02x\n", val);
	ns2501_readb(dvo, NS2501_FREQ_HI, &val);
	DRM_LOG_KMS("NS2501_FREQ_HI: 0x%02x\n", val);
	ns2501_readb(dvo, NS2501_REG8, &val);
	DRM_LOG_KMS("NS2501_REG8: 0x%02x\n", val);
	ns2501_readb(dvo, NS2501_REG9, &val);
	DRM_LOG_KMS("NS2501_REG9: 0x%02x\n", val);
	ns2501_readb(dvo, NS2501_REGC, &val);
	DRM_LOG_KMS("NS2501_REGC: 0x%02x\n", val);
}

static void ns2501_destroy(struct intel_dvo_device *dvo)
{
	struct ns2501_priv *ns = dvo->dev_priv;

	if (ns) {
		kfree(ns);
		dvo->dev_priv = NULL;
	}
}

struct intel_dvo_dev_ops ns2501_ops = {
	.init = ns2501_init,
	.detect = ns2501_detect,
	.mode_valid = ns2501_mode_valid,
	.mode_set = ns2501_mode_set,
	.dpms = ns2501_dpms,
	.get_hw_state = ns2501_get_hw_state,
	.dump_regs = ns2501_dump_regs,
	.destroy = ns2501_destroy,
};
@


1.7
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.6 2014/01/21 08:57:22 kettenis Exp $	*/
d122 2
a123 2
		    ("Unable to read register 0x%02x from %s:0x%02x.\n", addr,
		     adapter->name, dvo->slave_addr);
d156 2
a157 2
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %s:%d\n",
			      addr, adapter->name, dvo->slave_addr);
d188 2
a189 2
		DRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",
			      ch, adapter->name, dvo->slave_addr);
d197 2
a198 2
		DRM_DEBUG_KMS("ns2501 not detected got %d: from %s Slave %d.\n",
			      ch, adapter->name, dvo->slave_addr);
@


1.6
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.5 2013/08/13 10:23:49 jsg Exp $	*/
a90 43
static void enable_dvo(struct intel_dvo_device *dvo)
{
	struct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);
	struct i2c_controller *adapter = dvo->i2c_bus;
	struct intel_gmbus *bus = container_of(adapter,
					       struct intel_gmbus,
					       controller);
	struct drm_i915_private *dev_priv = bus->dev_priv;

	DRM_DEBUG_KMS("%s: Trying to re-enable the DVO\n", __FUNCTION__);

	ns->dvoc = I915_READ(DVO_C);
	ns->pll_a = I915_READ(_DPLL_A);
	ns->srcdim = I915_READ(DVOC_SRCDIM);
	ns->fw_blc = I915_READ(FW_BLC);

	I915_WRITE(DVOC, 0x10004084);
	I915_WRITE(_DPLL_A, 0xd0820000);
	I915_WRITE(DVOC_SRCDIM, 0x400300);	// 1024x768
	I915_WRITE(FW_BLC, 0x1080304);

	I915_WRITE(DVOC, 0x90004084);
}

/*
 * Restore the I915 registers modified by the above
 * trigger function.
 */
static void restore_dvo(struct intel_dvo_device *dvo)
{
	struct i2c_controller *adapter = dvo->i2c_bus;
	struct intel_gmbus *bus = container_of(adapter,
					       struct intel_gmbus,
					       controller);
	struct drm_i915_private *dev_priv = bus->dev_priv;
	struct ns2501_priv *ns = (struct ns2501_priv *)(dvo->dev_priv);

	I915_WRITE(DVOC, ns->dvoc);
	I915_WRITE(_DPLL_A, ns->pll_a);
	I915_WRITE(DVOC_SRCDIM, ns->srcdim);
	I915_WRITE(FW_BLC, ns->fw_blc);
}

d122 2
a123 2
		    ("Unable to read register 0x%02x from 0x%02x.\n", addr,
		     dvo->slave_addr);
d156 2
a157 2
		DRM_DEBUG_KMS("Unable to write register 0x%02x to %d\n",
			      addr, dvo->slave_addr);
d188 2
a189 2
		DRM_DEBUG_KMS("ns2501 not detected got %d: from Slave %d.\n",
			      ch, dvo->slave_addr);
d197 2
a198 2
		DRM_DEBUG_KMS("ns2501 not detected got %d: from Slave %d.\n",
			      ch, dvo->slave_addr);
d254 1
a254 1
	bool restore = false;
d430 1
a430 14

		if (!ok) {
			if (restore)
				restore_dvo(dvo);
			enable_dvo(dvo);
			restore = true;
		}
	} while (!ok);
	/*
	 * Restore the old i915 registers before
	 * forcing the ns2501 on.
	 */
	if (restore)
		restore_dvo(dvo);
d451 1
a451 1
	bool restore = false;
d478 1
a478 10
			if (!ok) {
				if (restore)
					restore_dvo(dvo);
				enable_dvo(dvo);
				restore = true;
			}
		} while (!ok);

		if (restore)
			restore_dvo(dvo);
@


1.5
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.4 2013/07/05 07:20:27 jsg Exp $	*/
d219 1
a219 1
	ns = malloc(sizeof(struct ns2501_priv), M_DRM, M_WAITOK | M_ZERO);
d253 1
a253 1
	free(ns, M_DRM);
d568 1
a568 1
		free(ns, M_DRM);
@


1.4
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.3 2013/03/31 11:43:23 kettenis Exp $	*/
a77 15
void enable_dvo(struct intel_dvo_device *);
void restore_dvo(struct intel_dvo_device *);
bool ns2501_readb(struct intel_dvo_device *, int, uint8_t *);
bool ns2501_writeb(struct intel_dvo_device *, int, uint8_t);
enum drm_connector_status ns2501_detect(struct intel_dvo_device *);
bool ns2501_init(struct intel_dvo_device *, struct i2c_controller *);
enum drm_mode_status ns2501_mode_valid(struct intel_dvo_device *,
    struct drm_display_mode *);
void ns2501_mode_set(struct intel_dvo_device *, struct drm_display_mode *,
    struct drm_display_mode *);
bool ns2501_get_hw_state(struct intel_dvo_device *);
void ns2501_dpms(struct intel_dvo_device *, bool);
void ns2501_dump_regs(struct intel_dvo_device *);
void ns2501_destroy(struct intel_dvo_device *);

d91 1
a91 2
void
enable_dvo(struct intel_dvo_device *dvo)
d119 1
a119 2
void
restore_dvo(struct intel_dvo_device *dvo)
d140 1
a140 2
bool
ns2501_readb(struct intel_dvo_device *dvo, int addr, uint8_t * ch)
d178 1
a178 2
bool
ns2501_writeb(struct intel_dvo_device *dvo, int addr, uint8_t ch)
d212 1
a212 2
bool
ns2501_init(struct intel_dvo_device *dvo,
d257 1
a257 2
enum drm_connector_status
ns2501_detect(struct intel_dvo_device *dvo)
d269 1
a269 2
enum drm_mode_status
ns2501_mode_valid(struct intel_dvo_device *dvo,
d292 1
a292 2
void
ns2501_mode_set(struct intel_dvo_device *dvo,
d490 1
a490 2
bool
ns2501_get_hw_state(struct intel_dvo_device *dvo)
d504 1
a504 2
void
ns2501_dpms(struct intel_dvo_device *dvo, bool enable)
d547 1
a547 2
void
ns2501_dump_regs(struct intel_dvo_device *dvo)
d563 1
a563 2
void
ns2501_destroy(struct intel_dvo_device *dvo)
@


1.3
log
@Add bit banging support.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.2 2013/03/30 12:36:50 kettenis Exp $	*/
d114 1
a114 1
	drm_i915_private_t *dev_priv = bus->dev_priv;
d142 1
a142 1
	drm_i915_private_t *dev_priv = bus->dev_priv;
@


1.2
log
@Fix intel gmbus i2c code.  Not all transactions were handled correctly, and
on top of that, various iic_exec(9) calls were incorrect.  Doesn't seem to
handle SDVO yet though.
@
text
@d1 1
a1 1
/*	$OpenBSD: dvo_ns2501.c,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
d114 1
a114 1
	drm_i915_private_t *dev_priv = bus->gp.dev_priv;
d142 1
a142 1
	drm_i915_private_t *dev_priv = bus->gp.dev_priv;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a164 1
	uint8_t cmd = 0;
a169 4
	ret = iic_exec(adapter, I2C_OP_WRITE_WITH_STOP, dvo->slave_addr,
	    &cmd, 1, out_buf, 1, 0);
	if (ret)
		goto read_err;
d171 1
a171 1
	    &cmd, 1, in_buf, 1, 0);
a202 1
	uint8_t cmd = 0;
d209 1
a209 1
	    &cmd, 1, out_buf, 2, 0);
@

