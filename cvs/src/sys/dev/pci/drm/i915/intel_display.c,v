head	1.60;
access;
symbols
	OPENBSD_6_1:1.57.0.8
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.6
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.43.0.4
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9;
locks; strict;
comment	@ * @;


1.60
date	2017.07.15.13.55.05;	author kettenis;	state Exp;
branches;
next	1.59;
commitid	iYGJR8DbR0YWGHKv;

1.59
date	2017.07.02.20.58.55;	author kettenis;	state Exp;
branches;
next	1.58;
commitid	3X20l6oWqChtP7LU;

1.58
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.57;
commitid	KnwRPOZok9A30HI4;

1.57
date	2015.12.31.13.01.00;	author kettenis;	state Exp;
branches;
next	1.56;
commitid	PRTGqV1xSkCKPIeR;

1.56
date	2015.09.25.09.42.14;	author kettenis;	state Exp;
branches;
next	1.55;
commitid	ii5fPNM9KiLIg8uD;

1.55
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	lQlppvmETCN49oZe;

1.54
date	2015.07.16.18.48.51;	author kettenis;	state Exp;
branches;
next	1.53;
commitid	L0a8i9q8D7R6QA4N;

1.53
date	2015.06.28.15.00.41;	author kettenis;	state Exp;
branches;
next	1.52;
commitid	tojQx6jphPWJ25Qg;

1.52
date	2015.06.24.17.59.42;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	3wz7SV1D1yJbfWE9;

1.51
date	2015.06.24.08.32.39;	author kettenis;	state Exp;
branches;
next	1.50;
commitid	hfEqCdm8ecmxIgUE;

1.50
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.49;
commitid	c1fUeeFWMNg4COgR;

1.49
date	2015.04.12.17.10.07;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	7RIU3AxWXbuzxDet;

1.48
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.47;
commitid	syZU9J25izIJ2cm1;

1.47
date	2015.04.08.04.24.40;	author jsg;	state Exp;
branches;
next	1.46;
commitid	qsPUrHZnfUhUkthX;

1.46
date	2015.04.08.03.21.13;	author jsg;	state Exp;
branches;
next	1.45;
commitid	7EKNazExjqqL6OEi;

1.45
date	2015.04.06.10.03.34;	author jsg;	state Exp;
branches;
next	1.44;
commitid	oJYtUavwJsvpe91h;

1.44
date	2015.04.06.05.35.29;	author jsg;	state Exp;
branches;
next	1.43;
commitid	oeVBooRupIYToF2n;

1.43
date	2015.02.12.08.48.32;	author jsg;	state Exp;
branches;
next	1.42;
commitid	b7XA83Agvw5SEHRi;

1.42
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	adfbJ0ccUTdhFGhI;

1.41
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.40;
commitid	dLgISW35NAmGN8Xl;

1.40
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.39;
commitid	aHLMSW1RfE1rmMw9;

1.39
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.38;
commitid	a8Vt7gSt34kmziIS;

1.38
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.37;
commitid	MyKPm9Q3dQu92BiX;

1.37
date	2014.10.08.05.25.41;	author jsg;	state Exp;
branches;
next	1.36;
commitid	AGLvWgZoe3h6y1D0;

1.36
date	2014.06.21.05.38.28;	author jsg;	state Exp;
branches;
next	1.35;
commitid	SSvPNoflPngsrN2i;

1.35
date	2014.05.03.05.11.30;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.07.06.43.11;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2014.03.30.01.03.05;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.16.03.34.32;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2014.02.15.09.56.08;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2014.02.15.09.47.15;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.05.10.58.48;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2014.02.02.13.55.31;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2014.02.02.04.02.04;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2014.01.24.06.11.02;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2014.01.24.04.05.06;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2014.01.24.03.21.17;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.24.01.07.00;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.23.11.18.34;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.23.10.42.57;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2013.12.01.14.20.02;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2013.11.11.02.53.26;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.11.02.48.04;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.02.22.58.10;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.30.02.11.32;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2013.09.08.11.59.45;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.13.10.23.50;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.09.07.55.42;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2013.07.08.09.47.45;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.04.09.57.23;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.04.09.55.01;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.17.20.04.04;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.14.04.49.22;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.04.08.05.43.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.19.03.58.10;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.60
log
@Disable the has_audio pipe config check.  We don't manage the HDMI/DP audio
capabilities yet so discrepancies are not entirely unexpected.
@
text
@/*
 * Copyright Â© 2006-2007 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *	Eric Anholt <eric@@anholt.net>
 */

#ifdef __linux__
#include <linux/dmi.h>
#include <linux/module.h>
#include <linux/input.h>
#include <linux/i2c.h>
#include <linux/kernel.h>
#include <linux/slab.h>
#include <linux/vgaarb.h>
#endif
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_edid.h>
#include "intel_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#include "i915_trace.h"
#include <dev/pci/drm/drm_atomic.h>
#include <dev/pci/drm/drm_atomic_helper.h>
#include <dev/pci/drm/drm_dp_helper.h>
#include <dev/pci/drm/drm_crtc_helper.h>
#include <dev/pci/drm/drm_plane_helper.h>
#include <dev/pci/drm/drm_rect.h>
#ifdef __linux__
#include <linux/dma_remapping.h>
#endif

/* Primary plane formats for gen <= 3 */
static const uint32_t i8xx_primary_formats[] = {
	DRM_FORMAT_C8,
	DRM_FORMAT_RGB565,
	DRM_FORMAT_XRGB1555,
	DRM_FORMAT_XRGB8888,
};

/* Primary plane formats for gen >= 4 */
static const uint32_t i965_primary_formats[] = {
	DRM_FORMAT_C8,
	DRM_FORMAT_RGB565,
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_XBGR8888,
	DRM_FORMAT_XRGB2101010,
	DRM_FORMAT_XBGR2101010,
};

static const uint32_t skl_primary_formats[] = {
	DRM_FORMAT_C8,
	DRM_FORMAT_RGB565,
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_XBGR8888,
	DRM_FORMAT_ARGB8888,
	DRM_FORMAT_ABGR8888,
	DRM_FORMAT_XRGB2101010,
	DRM_FORMAT_XBGR2101010,
	DRM_FORMAT_YUYV,
	DRM_FORMAT_YVYU,
	DRM_FORMAT_UYVY,
	DRM_FORMAT_VYUY,
};

/* Cursor formats */
static const uint32_t intel_cursor_formats[] = {
	DRM_FORMAT_ARGB8888,
};

static void intel_crtc_update_cursor(struct drm_crtc *crtc, bool on);

static void i9xx_crtc_clock_get(struct intel_crtc *crtc,
				struct intel_crtc_state *pipe_config);
static void ironlake_pch_clock_get(struct intel_crtc *crtc,
				   struct intel_crtc_state *pipe_config);

static int intel_framebuffer_init(struct drm_device *dev,
				  struct intel_framebuffer *ifb,
				  struct drm_mode_fb_cmd2 *mode_cmd,
				  struct drm_i915_gem_object *obj);
static void i9xx_set_pipeconf(struct intel_crtc *intel_crtc);
static void intel_set_pipe_timings(struct intel_crtc *intel_crtc);
static void intel_cpu_transcoder_set_m_n(struct intel_crtc *crtc,
					 struct intel_link_m_n *m_n,
					 struct intel_link_m_n *m2_n2);
static void ironlake_set_pipeconf(struct drm_crtc *crtc);
static void haswell_set_pipeconf(struct drm_crtc *crtc);
static void intel_set_pipe_csc(struct drm_crtc *crtc);
static void vlv_prepare_pll(struct intel_crtc *crtc,
			    const struct intel_crtc_state *pipe_config);
static void chv_prepare_pll(struct intel_crtc *crtc,
			    const struct intel_crtc_state *pipe_config);
static void intel_begin_crtc_commit(struct drm_crtc *, struct drm_crtc_state *);
static void intel_finish_crtc_commit(struct drm_crtc *, struct drm_crtc_state *);
static void skl_init_scalers(struct drm_device *dev, struct intel_crtc *intel_crtc,
	struct intel_crtc_state *crtc_state);
static int i9xx_get_refclk(const struct intel_crtc_state *crtc_state,
			   int num_connectors);
static void skylake_pfit_enable(struct intel_crtc *crtc);
static void ironlake_pfit_disable(struct intel_crtc *crtc, bool force);
static void ironlake_pfit_enable(struct intel_crtc *crtc);
static void intel_modeset_setup_hw_state(struct drm_device *dev);
static void intel_pre_disable_primary(struct drm_crtc *crtc);

typedef struct {
	int	min, max;
} intel_range_t;

typedef struct {
	int	dot_limit;
	int	p2_slow, p2_fast;
} intel_p2_t;

typedef struct intel_limit intel_limit_t;
struct intel_limit {
	intel_range_t   dot, vco, n, m, m1, m2, p, p1;
	intel_p2_t	    p2;
};

/* returns HPLL frequency in kHz */
static int valleyview_get_vco(struct drm_i915_private *dev_priv)
{
	int hpll_freq, vco_freq[] = { 800, 1600, 2000, 2400 };

	/* Obtain SKU information */
	mutex_lock(&dev_priv->sb_lock);
	hpll_freq = vlv_cck_read(dev_priv, CCK_FUSE_REG) &
		CCK_FUSE_HPLL_FREQ_MASK;
	mutex_unlock(&dev_priv->sb_lock);

	return vco_freq[hpll_freq] * 1000;
}

static int vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,
				  const char *name, u32 reg)
{
	u32 val;
	int divider;

	if (dev_priv->hpll_freq == 0)
		dev_priv->hpll_freq = valleyview_get_vco(dev_priv);

	mutex_lock(&dev_priv->sb_lock);
	val = vlv_cck_read(dev_priv, reg);
	mutex_unlock(&dev_priv->sb_lock);

	divider = val & CCK_FREQUENCY_VALUES;

	WARN((val & CCK_FREQUENCY_STATUS) !=
	     (divider << CCK_FREQUENCY_STATUS_SHIFT),
	     "%s change in progress\n", name);

	return DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1, divider + 1);
}

int
intel_pch_rawclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	WARN_ON(!HAS_PCH_SPLIT(dev));

	return I915_READ(PCH_RAWCLK_FREQ) & RAWCLK_FREQ_MASK;
}

/* hrawclock is 1/4 the FSB frequency */
int intel_hrawclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t clkcfg;

	/* There is no CLKCFG reg in Valleyview. VLV hrawclk is 200 MHz */
	if (IS_VALLEYVIEW(dev))
		return 200;

	clkcfg = I915_READ(CLKCFG);
	switch (clkcfg & CLKCFG_FSB_MASK) {
	case CLKCFG_FSB_400:
		return 100;
	case CLKCFG_FSB_533:
		return 133;
	case CLKCFG_FSB_667:
		return 166;
	case CLKCFG_FSB_800:
		return 200;
	case CLKCFG_FSB_1067:
		return 266;
	case CLKCFG_FSB_1333:
		return 333;
	/* these two are just a guess; one of them might be right */
	case CLKCFG_FSB_1600:
	case CLKCFG_FSB_1600_ALT:
		return 400;
	default:
		return 133;
	}
}

static void intel_update_czclk(struct drm_i915_private *dev_priv)
{
	if (!IS_VALLEYVIEW(dev_priv))
		return;

	dev_priv->czclk_freq = vlv_get_cck_clock_hpll(dev_priv, "czclk",
						      CCK_CZ_CLOCK_CONTROL);

	DRM_DEBUG_DRIVER("CZ clock rate: %d kHz\n", dev_priv->czclk_freq);
}

static inline u32 /* units of 100MHz */
intel_fdi_link_freq(struct drm_device *dev)
{
	if (IS_GEN5(dev)) {
		struct drm_i915_private *dev_priv = dev->dev_private;
		return (I915_READ(FDI_PLL_BIOS_0) & FDI_PLL_FB_CLOCK_MASK) + 2;
	} else
		return 27;
}

static const intel_limit_t intel_limits_i8xx_dac = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 908000, .max = 1512000 },
	.n = { .min = 2, .max = 16 },
	.m = { .min = 96, .max = 140 },
	.m1 = { .min = 18, .max = 26 },
	.m2 = { .min = 6, .max = 16 },
	.p = { .min = 4, .max = 128 },
	.p1 = { .min = 2, .max = 33 },
	.p2 = { .dot_limit = 165000,
		.p2_slow = 4, .p2_fast = 2 },
};

static const intel_limit_t intel_limits_i8xx_dvo = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 908000, .max = 1512000 },
	.n = { .min = 2, .max = 16 },
	.m = { .min = 96, .max = 140 },
	.m1 = { .min = 18, .max = 26 },
	.m2 = { .min = 6, .max = 16 },
	.p = { .min = 4, .max = 128 },
	.p1 = { .min = 2, .max = 33 },
	.p2 = { .dot_limit = 165000,
		.p2_slow = 4, .p2_fast = 4 },
};

static const intel_limit_t intel_limits_i8xx_lvds = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 908000, .max = 1512000 },
	.n = { .min = 2, .max = 16 },
	.m = { .min = 96, .max = 140 },
	.m1 = { .min = 18, .max = 26 },
	.m2 = { .min = 6, .max = 16 },
	.p = { .min = 4, .max = 128 },
	.p1 = { .min = 1, .max = 6 },
	.p2 = { .dot_limit = 165000,
		.p2_slow = 14, .p2_fast = 7 },
};

static const intel_limit_t intel_limits_i9xx_sdvo = {
	.dot = { .min = 20000, .max = 400000 },
	.vco = { .min = 1400000, .max = 2800000 },
	.n = { .min = 1, .max = 6 },
	.m = { .min = 70, .max = 120 },
	.m1 = { .min = 8, .max = 18 },
	.m2 = { .min = 3, .max = 7 },
	.p = { .min = 5, .max = 80 },
	.p1 = { .min = 1, .max = 8 },
	.p2 = { .dot_limit = 200000,
		.p2_slow = 10, .p2_fast = 5 },
};

static const intel_limit_t intel_limits_i9xx_lvds = {
	.dot = { .min = 20000, .max = 400000 },
	.vco = { .min = 1400000, .max = 2800000 },
	.n = { .min = 1, .max = 6 },
	.m = { .min = 70, .max = 120 },
	.m1 = { .min = 8, .max = 18 },
	.m2 = { .min = 3, .max = 7 },
	.p = { .min = 7, .max = 98 },
	.p1 = { .min = 1, .max = 8 },
	.p2 = { .dot_limit = 112000,
		.p2_slow = 14, .p2_fast = 7 },
};


static const intel_limit_t intel_limits_g4x_sdvo = {
	.dot = { .min = 25000, .max = 270000 },
	.vco = { .min = 1750000, .max = 3500000},
	.n = { .min = 1, .max = 4 },
	.m = { .min = 104, .max = 138 },
	.m1 = { .min = 17, .max = 23 },
	.m2 = { .min = 5, .max = 11 },
	.p = { .min = 10, .max = 30 },
	.p1 = { .min = 1, .max = 3},
	.p2 = { .dot_limit = 270000,
		.p2_slow = 10,
		.p2_fast = 10
	},
};

static const intel_limit_t intel_limits_g4x_hdmi = {
	.dot = { .min = 22000, .max = 400000 },
	.vco = { .min = 1750000, .max = 3500000},
	.n = { .min = 1, .max = 4 },
	.m = { .min = 104, .max = 138 },
	.m1 = { .min = 16, .max = 23 },
	.m2 = { .min = 5, .max = 11 },
	.p = { .min = 5, .max = 80 },
	.p1 = { .min = 1, .max = 8},
	.p2 = { .dot_limit = 165000,
		.p2_slow = 10, .p2_fast = 5 },
};

static const intel_limit_t intel_limits_g4x_single_channel_lvds = {
	.dot = { .min = 20000, .max = 115000 },
	.vco = { .min = 1750000, .max = 3500000 },
	.n = { .min = 1, .max = 3 },
	.m = { .min = 104, .max = 138 },
	.m1 = { .min = 17, .max = 23 },
	.m2 = { .min = 5, .max = 11 },
	.p = { .min = 28, .max = 112 },
	.p1 = { .min = 2, .max = 8 },
	.p2 = { .dot_limit = 0,
		.p2_slow = 14, .p2_fast = 14
	},
};

static const intel_limit_t intel_limits_g4x_dual_channel_lvds = {
	.dot = { .min = 80000, .max = 224000 },
	.vco = { .min = 1750000, .max = 3500000 },
	.n = { .min = 1, .max = 3 },
	.m = { .min = 104, .max = 138 },
	.m1 = { .min = 17, .max = 23 },
	.m2 = { .min = 5, .max = 11 },
	.p = { .min = 14, .max = 42 },
	.p1 = { .min = 2, .max = 6 },
	.p2 = { .dot_limit = 0,
		.p2_slow = 7, .p2_fast = 7
	},
};

static const intel_limit_t intel_limits_pineview_sdvo = {
	.dot = { .min = 20000, .max = 400000},
	.vco = { .min = 1700000, .max = 3500000 },
	/* Pineview's Ncounter is a ring counter */
	.n = { .min = 3, .max = 6 },
	.m = { .min = 2, .max = 256 },
	/* Pineview only has one combined m divider, which we treat as m2. */
	.m1 = { .min = 0, .max = 0 },
	.m2 = { .min = 0, .max = 254 },
	.p = { .min = 5, .max = 80 },
	.p1 = { .min = 1, .max = 8 },
	.p2 = { .dot_limit = 200000,
		.p2_slow = 10, .p2_fast = 5 },
};

static const intel_limit_t intel_limits_pineview_lvds = {
	.dot = { .min = 20000, .max = 400000 },
	.vco = { .min = 1700000, .max = 3500000 },
	.n = { .min = 3, .max = 6 },
	.m = { .min = 2, .max = 256 },
	.m1 = { .min = 0, .max = 0 },
	.m2 = { .min = 0, .max = 254 },
	.p = { .min = 7, .max = 112 },
	.p1 = { .min = 1, .max = 8 },
	.p2 = { .dot_limit = 112000,
		.p2_slow = 14, .p2_fast = 14 },
};

/* Ironlake / Sandybridge
 *
 * We calculate clock using (register_value + 2) for N/M1/M2, so here
 * the range value for them is (actual_value - 2).
 */
static const intel_limit_t intel_limits_ironlake_dac = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000 },
	.n = { .min = 1, .max = 5 },
	.m = { .min = 79, .max = 127 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 5, .max = 80 },
	.p1 = { .min = 1, .max = 8 },
	.p2 = { .dot_limit = 225000,
		.p2_slow = 10, .p2_fast = 5 },
};

static const intel_limit_t intel_limits_ironlake_single_lvds = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000 },
	.n = { .min = 1, .max = 3 },
	.m = { .min = 79, .max = 118 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 28, .max = 112 },
	.p1 = { .min = 2, .max = 8 },
	.p2 = { .dot_limit = 225000,
		.p2_slow = 14, .p2_fast = 14 },
};

static const intel_limit_t intel_limits_ironlake_dual_lvds = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000 },
	.n = { .min = 1, .max = 3 },
	.m = { .min = 79, .max = 127 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 14, .max = 56 },
	.p1 = { .min = 2, .max = 8 },
	.p2 = { .dot_limit = 225000,
		.p2_slow = 7, .p2_fast = 7 },
};

/* LVDS 100mhz refclk limits. */
static const intel_limit_t intel_limits_ironlake_single_lvds_100m = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000 },
	.n = { .min = 1, .max = 2 },
	.m = { .min = 79, .max = 126 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 28, .max = 112 },
	.p1 = { .min = 2, .max = 8 },
	.p2 = { .dot_limit = 225000,
		.p2_slow = 14, .p2_fast = 14 },
};

static const intel_limit_t intel_limits_ironlake_dual_lvds_100m = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000 },
	.n = { .min = 1, .max = 3 },
	.m = { .min = 79, .max = 126 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 14, .max = 42 },
	.p1 = { .min = 2, .max = 6 },
	.p2 = { .dot_limit = 225000,
		.p2_slow = 7, .p2_fast = 7 },
};

static const intel_limit_t intel_limits_vlv = {
	 /*
	  * These are the data rate limits (measured in fast clocks)
	  * since those are the strictest limits we have. The fast
	  * clock and actual rate limits are more relaxed, so checking
	  * them would make no difference.
	  */
	.dot = { .min = 25000 * 5, .max = 270000 * 5 },
	.vco = { .min = 4000000, .max = 6000000 },
	.n = { .min = 1, .max = 7 },
	.m1 = { .min = 2, .max = 3 },
	.m2 = { .min = 11, .max = 156 },
	.p1 = { .min = 2, .max = 3 },
	.p2 = { .p2_slow = 2, .p2_fast = 20 }, /* slow=min, fast=max */
};

static const intel_limit_t intel_limits_chv = {
	/*
	 * These are the data rate limits (measured in fast clocks)
	 * since those are the strictest limits we have.  The fast
	 * clock and actual rate limits are more relaxed, so checking
	 * them would make no difference.
	 */
	.dot = { .min = 25000 * 5, .max = 540000 * 5},
	.vco = { .min = 4800000, .max = 6480000 },
	.n = { .min = 1, .max = 1 },
	.m1 = { .min = 2, .max = 2 },
	.m2 = { .min = 24 << 22, .max = 175 << 22 },
	.p1 = { .min = 2, .max = 4 },
	.p2 = {	.p2_slow = 1, .p2_fast = 14 },
};

static const intel_limit_t intel_limits_bxt = {
	/* FIXME: find real dot limits */
	.dot = { .min = 0, .max = INT_MAX },
	.vco = { .min = 4800000, .max = 6700000 },
	.n = { .min = 1, .max = 1 },
	.m1 = { .min = 2, .max = 2 },
	/* FIXME: find real m2 limits */
	.m2 = { .min = 2 << 22, .max = 255 << 22 },
	.p1 = { .min = 2, .max = 4 },
	.p2 = { .p2_slow = 1, .p2_fast = 20 },
};

static bool
needs_modeset(struct drm_crtc_state *state)
{
	return drm_atomic_crtc_needs_modeset(state);
}

/**
 * Returns whether any output on the specified pipe is of the specified type
 */
bool intel_pipe_has_type(struct intel_crtc *crtc, enum intel_output_type type)
{
	struct drm_device *dev = crtc->base.dev;
	struct intel_encoder *encoder;

	for_each_encoder_on_crtc(dev, &crtc->base, encoder)
		if (encoder->type == type)
			return true;

	return false;
}

/**
 * Returns whether any output on the specified pipe will have the specified
 * type after a staged modeset is complete, i.e., the same as
 * intel_pipe_has_type() but looking at encoder->new_crtc instead of
 * encoder->crtc.
 */
static bool intel_pipe_will_have_type(const struct intel_crtc_state *crtc_state,
				      int type)
{
	struct drm_atomic_state *state = crtc_state->base.state;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	struct intel_encoder *encoder;
	int i, num_connectors = 0;

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != crtc_state->base.crtc)
			continue;

		num_connectors++;

		encoder = to_intel_encoder(connector_state->best_encoder);
		if (encoder->type == type)
			return true;
	}

	WARN_ON(num_connectors == 0);

	return false;
}

static const intel_limit_t *
intel_ironlake_limit(struct intel_crtc_state *crtc_state, int refclk)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	const intel_limit_t *limit;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS)) {
		if (intel_is_dual_link_lvds(dev)) {
			if (refclk == 100000)
				limit = &intel_limits_ironlake_dual_lvds_100m;
			else
				limit = &intel_limits_ironlake_dual_lvds;
		} else {
			if (refclk == 100000)
				limit = &intel_limits_ironlake_single_lvds_100m;
			else
				limit = &intel_limits_ironlake_single_lvds;
		}
	} else
		limit = &intel_limits_ironlake_dac;

	return limit;
}

static const intel_limit_t *
intel_g4x_limit(struct intel_crtc_state *crtc_state)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	const intel_limit_t *limit;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS)) {
		if (intel_is_dual_link_lvds(dev))
			limit = &intel_limits_g4x_dual_channel_lvds;
		else
			limit = &intel_limits_g4x_single_channel_lvds;
	} else if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_HDMI) ||
		   intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_ANALOG)) {
		limit = &intel_limits_g4x_hdmi;
	} else if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_SDVO)) {
		limit = &intel_limits_g4x_sdvo;
	} else /* The option is for other outputs */
		limit = &intel_limits_i9xx_sdvo;

	return limit;
}

static const intel_limit_t *
intel_limit(struct intel_crtc_state *crtc_state, int refclk)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	const intel_limit_t *limit;

	if (IS_BROXTON(dev))
		limit = &intel_limits_bxt;
	else if (HAS_PCH_SPLIT(dev))
		limit = intel_ironlake_limit(crtc_state, refclk);
	else if (IS_G4X(dev)) {
		limit = intel_g4x_limit(crtc_state);
	} else if (IS_PINEVIEW(dev)) {
		if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS))
			limit = &intel_limits_pineview_lvds;
		else
			limit = &intel_limits_pineview_sdvo;
	} else if (IS_CHERRYVIEW(dev)) {
		limit = &intel_limits_chv;
	} else if (IS_VALLEYVIEW(dev)) {
		limit = &intel_limits_vlv;
	} else if (!IS_GEN2(dev)) {
		if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS))
			limit = &intel_limits_i9xx_lvds;
		else
			limit = &intel_limits_i9xx_sdvo;
	} else {
		if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS))
			limit = &intel_limits_i8xx_lvds;
		else if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_DVO))
			limit = &intel_limits_i8xx_dvo;
		else
			limit = &intel_limits_i8xx_dac;
	}
	return limit;
}

/*
 * Platform specific helpers to calculate the port PLL loopback- (clock.m),
 * and post-divider (clock.p) values, pre- (clock.vco) and post-divided fast
 * (clock.dot) clock rates. This fast dot clock is fed to the port's IO logic.
 * The helpers' return value is the rate of the clock that is fed to the
 * display engine's pipe which can be the above fast dot clock rate or a
 * divided-down version of it.
 */
/* m1 is reserved as 0 in Pineview, n is a ring counter */
static int pnv_calc_dpll_params(int refclk, intel_clock_t *clock)
{
	clock->m = clock->m2 + 2;
	clock->p = clock->p1 * clock->p2;
	if (WARN_ON(clock->n == 0 || clock->p == 0))
		return 0;
	clock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);
	clock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);

	return clock->dot;
}

static uint32_t i9xx_dpll_compute_m(struct dpll *dpll)
{
	return 5 * (dpll->m1 + 2) + (dpll->m2 + 2);
}

static int i9xx_calc_dpll_params(int refclk, intel_clock_t *clock)
{
	clock->m = i9xx_dpll_compute_m(clock);
	clock->p = clock->p1 * clock->p2;
	if (WARN_ON(clock->n + 2 == 0 || clock->p == 0))
		return 0;
	clock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n + 2);
	clock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);

	return clock->dot;
}

static int vlv_calc_dpll_params(int refclk, intel_clock_t *clock)
{
	clock->m = clock->m1 * clock->m2;
	clock->p = clock->p1 * clock->p2;
	if (WARN_ON(clock->n == 0 || clock->p == 0))
		return 0;
	clock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);
	clock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);

	return clock->dot / 5;
}

int chv_calc_dpll_params(int refclk, intel_clock_t *clock)
{
	clock->m = clock->m1 * clock->m2;
	clock->p = clock->p1 * clock->p2;
	if (WARN_ON(clock->n == 0 || clock->p == 0))
		return 0;
	clock->vco = DIV_ROUND_CLOSEST_ULL((uint64_t)refclk * clock->m,
			clock->n << 22);
	clock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);

	return clock->dot / 5;
}

#define INTELPllInvalid(s)   do { /* DRM_DEBUG(s); */ return false; } while (0)
/**
 * Returns whether the given set of divisors are valid for a given refclk with
 * the given connectors.
 */

static bool intel_PLL_is_valid(struct drm_device *dev,
			       const intel_limit_t *limit,
			       const intel_clock_t *clock)
{
	if (clock->n   < limit->n.min   || limit->n.max   < clock->n)
		INTELPllInvalid("n out of range\n");
	if (clock->p1  < limit->p1.min  || limit->p1.max  < clock->p1)
		INTELPllInvalid("p1 out of range\n");
	if (clock->m2  < limit->m2.min  || limit->m2.max  < clock->m2)
		INTELPllInvalid("m2 out of range\n");
	if (clock->m1  < limit->m1.min  || limit->m1.max  < clock->m1)
		INTELPllInvalid("m1 out of range\n");

	if (!IS_PINEVIEW(dev) && !IS_VALLEYVIEW(dev) && !IS_BROXTON(dev))
		if (clock->m1 <= clock->m2)
			INTELPllInvalid("m1 <= m2\n");

	if (!IS_VALLEYVIEW(dev) && !IS_BROXTON(dev)) {
		if (clock->p < limit->p.min || limit->p.max < clock->p)
			INTELPllInvalid("p out of range\n");
		if (clock->m < limit->m.min || limit->m.max < clock->m)
			INTELPllInvalid("m out of range\n");
	}

	if (clock->vco < limit->vco.min || limit->vco.max < clock->vco)
		INTELPllInvalid("vco out of range\n");
	/* XXX: We may need to be checking "Dot clock" depending on the multiplier,
	 * connector, etc., rather than just a single range.
	 */
	if (clock->dot < limit->dot.min || limit->dot.max < clock->dot)
		INTELPllInvalid("dot out of range\n");

	return true;
}

static int
i9xx_select_p2_div(const intel_limit_t *limit,
		   const struct intel_crtc_state *crtc_state,
		   int target)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS)) {
		/*
		 * For LVDS just rely on its current settings for dual-channel.
		 * We haven't figured out how to reliably set up different
		 * single/dual channel state, if we even can.
		 */
		if (intel_is_dual_link_lvds(dev))
			return limit->p2.p2_fast;
		else
			return limit->p2.p2_slow;
	} else {
		if (target < limit->p2.dot_limit)
			return limit->p2.p2_slow;
		else
			return limit->p2.p2_fast;
	}
}

static bool
i9xx_find_best_dpll(const intel_limit_t *limit,
		    struct intel_crtc_state *crtc_state,
		    int target, int refclk, intel_clock_t *match_clock,
		    intel_clock_t *best_clock)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	intel_clock_t clock;
	int err = target;

	memset(best_clock, 0, sizeof(*best_clock));

	clock.p2 = i9xx_select_p2_div(limit, crtc_state, target);

	for (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;
	     clock.m1++) {
		for (clock.m2 = limit->m2.min;
		     clock.m2 <= limit->m2.max; clock.m2++) {
			if (clock.m2 >= clock.m1)
				break;
			for (clock.n = limit->n.min;
			     clock.n <= limit->n.max; clock.n++) {
				for (clock.p1 = limit->p1.min;
					clock.p1 <= limit->p1.max; clock.p1++) {
					int this_err;

					i9xx_calc_dpll_params(refclk, &clock);
					if (!intel_PLL_is_valid(dev, limit,
								&clock))
						continue;
					if (match_clock &&
					    clock.p != match_clock->p)
						continue;

					this_err = abs(clock.dot - target);
					if (this_err < err) {
						*best_clock = clock;
						err = this_err;
					}
				}
			}
		}
	}

	return (err != target);
}

static bool
pnv_find_best_dpll(const intel_limit_t *limit,
		   struct intel_crtc_state *crtc_state,
		   int target, int refclk, intel_clock_t *match_clock,
		   intel_clock_t *best_clock)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	intel_clock_t clock;
	int err = target;

	memset(best_clock, 0, sizeof(*best_clock));

	clock.p2 = i9xx_select_p2_div(limit, crtc_state, target);

	for (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max;
	     clock.m1++) {
		for (clock.m2 = limit->m2.min;
		     clock.m2 <= limit->m2.max; clock.m2++) {
			for (clock.n = limit->n.min;
			     clock.n <= limit->n.max; clock.n++) {
				for (clock.p1 = limit->p1.min;
					clock.p1 <= limit->p1.max; clock.p1++) {
					int this_err;

					pnv_calc_dpll_params(refclk, &clock);
					if (!intel_PLL_is_valid(dev, limit,
								&clock))
						continue;
					if (match_clock &&
					    clock.p != match_clock->p)
						continue;

					this_err = abs(clock.dot - target);
					if (this_err < err) {
						*best_clock = clock;
						err = this_err;
					}
				}
			}
		}
	}

	return (err != target);
}

static bool
g4x_find_best_dpll(const intel_limit_t *limit,
		   struct intel_crtc_state *crtc_state,
		   int target, int refclk, intel_clock_t *match_clock,
		   intel_clock_t *best_clock)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	intel_clock_t clock;
	int max_n;
	bool found = false;
	/* approximately equals target * 0.00585 */
	int err_most = (target >> 8) + (target >> 9);

	memset(best_clock, 0, sizeof(*best_clock));

	clock.p2 = i9xx_select_p2_div(limit, crtc_state, target);

	max_n = limit->n.max;
	/* based on hardware requirement, prefer smaller n to precision */
	for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {
		/* based on hardware requirement, prefere larger m1,m2 */
		for (clock.m1 = limit->m1.max;
		     clock.m1 >= limit->m1.min; clock.m1--) {
			for (clock.m2 = limit->m2.max;
			     clock.m2 >= limit->m2.min; clock.m2--) {
				for (clock.p1 = limit->p1.max;
				     clock.p1 >= limit->p1.min; clock.p1--) {
					int this_err;

					i9xx_calc_dpll_params(refclk, &clock);
					if (!intel_PLL_is_valid(dev, limit,
								&clock))
						continue;

					this_err = abs(clock.dot - target);
					if (this_err < err_most) {
						*best_clock = clock;
						err_most = this_err;
						max_n = clock.n;
						found = true;
					}
				}
			}
		}
	}
	return found;
}

/*
 * Check if the calculated PLL configuration is more optimal compared to the
 * best configuration and error found so far. Return the calculated error.
 */
static bool vlv_PLL_is_optimal(struct drm_device *dev, int target_freq,
			       const intel_clock_t *calculated_clock,
			       const intel_clock_t *best_clock,
			       unsigned int best_error_ppm,
			       unsigned int *error_ppm)
{
	/*
	 * For CHV ignore the error and consider only the P value.
	 * Prefer a bigger P value based on HW requirements.
	 */
	if (IS_CHERRYVIEW(dev)) {
		*error_ppm = 0;

		return calculated_clock->p > best_clock->p;
	}

	if (WARN_ON_ONCE(!target_freq))
		return false;

	*error_ppm = div_u64(1000000ULL *
				abs(target_freq - calculated_clock->dot),
			     target_freq);
	/*
	 * Prefer a better P value over a better (smaller) error if the error
	 * is small. Ensure this preference for future configurations too by
	 * setting the error to 0.
	 */
	if (*error_ppm < 100 && calculated_clock->p > best_clock->p) {
		*error_ppm = 0;

		return true;
	}

	return *error_ppm + 10 < best_error_ppm;
}

static bool
vlv_find_best_dpll(const intel_limit_t *limit,
		   struct intel_crtc_state *crtc_state,
		   int target, int refclk, intel_clock_t *match_clock,
		   intel_clock_t *best_clock)
{
	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
	struct drm_device *dev = crtc->base.dev;
	intel_clock_t clock;
	unsigned int bestppm = 1000000;
	/* min update 19.2 MHz */
	int max_n = min(limit->n.max, refclk / 19200);
	bool found = false;

	target *= 5; /* fast clock */

	memset(best_clock, 0, sizeof(*best_clock));

	/* based on hardware requirement, prefer smaller n to precision */
	for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {
		for (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {
			for (clock.p2 = limit->p2.p2_fast; clock.p2 >= limit->p2.p2_slow;
			     clock.p2 -= clock.p2 > 10 ? 2 : 1) {
				clock.p = clock.p1 * clock.p2;
				/* based on hardware requirement, prefer bigger m1,m2 values */
				for (clock.m1 = limit->m1.min; clock.m1 <= limit->m1.max; clock.m1++) {
					unsigned int ppm;

					clock.m2 = DIV_ROUND_CLOSEST(target * clock.p * clock.n,
								     refclk * clock.m1);

					vlv_calc_dpll_params(refclk, &clock);

					if (!intel_PLL_is_valid(dev, limit,
								&clock))
						continue;

					if (!vlv_PLL_is_optimal(dev, target,
								&clock,
								best_clock,
								bestppm, &ppm))
						continue;

					*best_clock = clock;
					bestppm = ppm;
					found = true;
				}
			}
		}
	}

	return found;
}

static bool
chv_find_best_dpll(const intel_limit_t *limit,
		   struct intel_crtc_state *crtc_state,
		   int target, int refclk, intel_clock_t *match_clock,
		   intel_clock_t *best_clock)
{
	struct intel_crtc *crtc = to_intel_crtc(crtc_state->base.crtc);
	struct drm_device *dev = crtc->base.dev;
	unsigned int best_error_ppm;
	intel_clock_t clock;
	uint64_t m2;
	int found = false;

	memset(best_clock, 0, sizeof(*best_clock));
	best_error_ppm = 1000000;

	/*
	 * Based on hardware doc, the n always set to 1, and m1 always
	 * set to 2.  If requires to support 200Mhz refclk, we need to
	 * revisit this because n may not 1 anymore.
	 */
	clock.n = 1, clock.m1 = 2;
	target *= 5;	/* fast clock */

	for (clock.p1 = limit->p1.max; clock.p1 >= limit->p1.min; clock.p1--) {
		for (clock.p2 = limit->p2.p2_fast;
				clock.p2 >= limit->p2.p2_slow;
				clock.p2 -= clock.p2 > 10 ? 2 : 1) {
			unsigned int error_ppm;

			clock.p = clock.p1 * clock.p2;

			m2 = DIV_ROUND_CLOSEST_ULL(((uint64_t)target * clock.p *
					clock.n) << 22, refclk * clock.m1);

			if (m2 > INT_MAX/clock.m1)
				continue;

			clock.m2 = m2;

			chv_calc_dpll_params(refclk, &clock);

			if (!intel_PLL_is_valid(dev, limit, &clock))
				continue;

			if (!vlv_PLL_is_optimal(dev, target, &clock, best_clock,
						best_error_ppm, &error_ppm))
				continue;

			*best_clock = clock;
			best_error_ppm = error_ppm;
			found = true;
		}
	}

	return found;
}

bool bxt_find_best_dpll(struct intel_crtc_state *crtc_state, int target_clock,
			intel_clock_t *best_clock)
{
	int refclk = i9xx_get_refclk(crtc_state, 0);

	return chv_find_best_dpll(intel_limit(crtc_state, refclk), crtc_state,
				  target_clock, refclk, NULL, best_clock);
}

bool intel_crtc_active(struct drm_crtc *crtc)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	/* Be paranoid as we can arrive here with only partial
	 * state retrieved from the hardware during setup.
	 *
	 * We can ditch the adjusted_mode.crtc_clock check as soon
	 * as Haswell has gained clock readout/fastboot support.
	 *
	 * We can ditch the crtc->primary->fb check as soon as we can
	 * properly reconstruct framebuffers.
	 *
	 * FIXME: The intel_crtc->active here should be switched to
	 * crtc->state->active once we have proper CRTC states wired up
	 * for atomic.
	 */
	return intel_crtc->active && crtc->primary->state->fb &&
		intel_crtc->config->base.adjusted_mode.crtc_clock;
}

enum transcoder intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
					     enum pipe pipe)
{
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	return intel_crtc->config->cpu_transcoder;
}

static bool pipe_dsl_stopped(struct drm_device *dev, enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 reg = PIPEDSL(pipe);
	u32 line1, line2;
	u32 line_mask;

	if (IS_GEN2(dev))
		line_mask = DSL_LINEMASK_GEN2;
	else
		line_mask = DSL_LINEMASK_GEN3;

	line1 = I915_READ(reg) & line_mask;
	drm_msleep(5);
	line2 = I915_READ(reg) & line_mask;

	return line1 == line2;
}

/*
 * intel_wait_for_pipe_off - wait for pipe to turn off
 * @@crtc: crtc whose pipe to wait for
 *
 * After disabling a pipe, we can't wait for vblank in the usual way,
 * spinning on the vblank interrupt status bit, since we won't actually
 * see an interrupt when the pipe is disabled.
 *
 * On Gen4 and above:
 *   wait for the pipe register state bit to turn off
 *
 * Otherwise:
 *   wait for the display line value to settle (it usually
 *   ends up stopping at the start of the next frame).
 *
 */
static void intel_wait_for_pipe_off(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum transcoder cpu_transcoder = crtc->config->cpu_transcoder;
	enum pipe pipe = crtc->pipe;

	if (INTEL_INFO(dev)->gen >= 4) {
		int reg = PIPECONF(cpu_transcoder);

		/* Wait for the Pipe State to go off */
		if (wait_for((I915_READ(reg) & I965_PIPECONF_ACTIVE) == 0,
			     100))
			WARN(1, "pipe_off wait timed out\n");
	} else {
		/* Wait for the display line to settle */
		if (wait_for(pipe_dsl_stopped(dev, pipe), 100))
			WARN(1, "pipe_off wait timed out\n");
	}
}

static const char *state_string(bool enabled)
{
	return enabled ? "on" : "off";
}

/* Only for pre-ILK configs */
void assert_pll(struct drm_i915_private *dev_priv,
		enum pipe pipe, bool state)
{
	u32 val;
	bool cur_state;

	val = I915_READ(DPLL(pipe));
	cur_state = !!(val & DPLL_VCO_ENABLE);
	I915_STATE_WARN(cur_state != state,
	     "PLL state assertion failure (expected %s, current %s)\n",
	     state_string(state), state_string(cur_state));
}

/* XXX: the dsi pll is shared between MIPI DSI ports */
static void assert_dsi_pll(struct drm_i915_private *dev_priv, bool state)
{
	u32 val;
	bool cur_state;

	mutex_lock(&dev_priv->sb_lock);
	val = vlv_cck_read(dev_priv, CCK_REG_DSI_PLL_CONTROL);
	mutex_unlock(&dev_priv->sb_lock);

	cur_state = val & DSI_PLL_VCO_EN;
	I915_STATE_WARN(cur_state != state,
	     "DSI PLL state assertion failure (expected %s, current %s)\n",
	     state_string(state), state_string(cur_state));
}
#define assert_dsi_pll_enabled(d) assert_dsi_pll(d, true)
#define assert_dsi_pll_disabled(d) assert_dsi_pll(d, false)

struct intel_shared_dpll *
intel_crtc_to_shared_dpll(struct intel_crtc *crtc)
{
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;

	if (crtc->config->shared_dpll < 0)
		return NULL;

	return &dev_priv->shared_dplls[crtc->config->shared_dpll];
}

/* For ILK+ */
void assert_shared_dpll(struct drm_i915_private *dev_priv,
			struct intel_shared_dpll *pll,
			bool state)
{
	bool cur_state;
	struct intel_dpll_hw_state hw_state;

	if (WARN (!pll,
		  "asserting DPLL %s with no DPLL\n", state_string(state)))
		return;

	cur_state = pll->get_hw_state(dev_priv, pll, &hw_state);
	I915_STATE_WARN(cur_state != state,
	     "%s assertion failure (expected %s, current %s)\n",
	     pll->name, state_string(state), state_string(cur_state));
}

static void assert_fdi_tx(struct drm_i915_private *dev_priv,
			  enum pipe pipe, bool state)
{
	bool cur_state;
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);

	if (HAS_DDI(dev_priv->dev)) {
		/* DDI does not have a specific FDI_TX register */
		u32 val = I915_READ(TRANS_DDI_FUNC_CTL(cpu_transcoder));
		cur_state = !!(val & TRANS_DDI_FUNC_ENABLE);
	} else {
		u32 val = I915_READ(FDI_TX_CTL(pipe));
		cur_state = !!(val & FDI_TX_ENABLE);
	}
	I915_STATE_WARN(cur_state != state,
	     "FDI TX state assertion failure (expected %s, current %s)\n",
	     state_string(state), state_string(cur_state));
}
#define assert_fdi_tx_enabled(d, p) assert_fdi_tx(d, p, true)
#define assert_fdi_tx_disabled(d, p) assert_fdi_tx(d, p, false)

static void assert_fdi_rx(struct drm_i915_private *dev_priv,
			  enum pipe pipe, bool state)
{
	u32 val;
	bool cur_state;

	val = I915_READ(FDI_RX_CTL(pipe));
	cur_state = !!(val & FDI_RX_ENABLE);
	I915_STATE_WARN(cur_state != state,
	     "FDI RX state assertion failure (expected %s, current %s)\n",
	     state_string(state), state_string(cur_state));
}
#define assert_fdi_rx_enabled(d, p) assert_fdi_rx(d, p, true)
#define assert_fdi_rx_disabled(d, p) assert_fdi_rx(d, p, false)

static void assert_fdi_tx_pll_enabled(struct drm_i915_private *dev_priv,
				      enum pipe pipe)
{
	u32 val;

	/* ILK FDI PLL is always enabled */
	if (INTEL_INFO(dev_priv->dev)->gen == 5)
		return;

	/* On Haswell, DDI ports are responsible for the FDI PLL setup */
	if (HAS_DDI(dev_priv->dev))
		return;

	val = I915_READ(FDI_TX_CTL(pipe));
	I915_STATE_WARN(!(val & FDI_TX_PLL_ENABLE), "FDI TX PLL assertion failure, should be active but is disabled\n");
}

void assert_fdi_rx_pll(struct drm_i915_private *dev_priv,
		       enum pipe pipe, bool state)
{
	u32 val;
	bool cur_state;

	val = I915_READ(FDI_RX_CTL(pipe));
	cur_state = !!(val & FDI_RX_PLL_ENABLE);
	I915_STATE_WARN(cur_state != state,
	     "FDI RX PLL assertion failure (expected %s, current %s)\n",
	     state_string(state), state_string(cur_state));
}

void assert_panel_unlocked(struct drm_i915_private *dev_priv,
			   enum pipe pipe)
{
	struct drm_device *dev = dev_priv->dev;
	int pp_reg;
	u32 val;
	enum pipe panel_pipe = PIPE_A;
	bool locked = true;

	if (WARN_ON(HAS_DDI(dev)))
		return;

	if (HAS_PCH_SPLIT(dev)) {
		u32 port_sel;

		pp_reg = PCH_PP_CONTROL;
		port_sel = I915_READ(PCH_PP_ON_DELAYS) & PANEL_PORT_SELECT_MASK;

		if (port_sel == PANEL_PORT_SELECT_LVDS &&
		    I915_READ(PCH_LVDS) & LVDS_PIPEB_SELECT)
			panel_pipe = PIPE_B;
		/* XXX: else fix for eDP */
	} else if (IS_VALLEYVIEW(dev)) {
		/* presumably write lock depends on pipe, not port select */
		pp_reg = VLV_PIPE_PP_CONTROL(pipe);
		panel_pipe = pipe;
	} else {
		pp_reg = PP_CONTROL;
		if (I915_READ(LVDS) & LVDS_PIPEB_SELECT)
			panel_pipe = PIPE_B;
	}

	val = I915_READ(pp_reg);
	if (!(val & PANEL_POWER_ON) ||
	    ((val & PANEL_UNLOCK_MASK) == PANEL_UNLOCK_REGS))
		locked = false;

	I915_STATE_WARN(panel_pipe == pipe && locked,
	     "panel assertion failure, pipe %c regs locked\n",
	     pipe_name(pipe));
}

static void assert_cursor(struct drm_i915_private *dev_priv,
			  enum pipe pipe, bool state)
{
	struct drm_device *dev = dev_priv->dev;
	bool cur_state;

	if (IS_845G(dev) || IS_I865G(dev))
		cur_state = I915_READ(CURCNTR(PIPE_A)) & CURSOR_ENABLE;
	else
		cur_state = I915_READ(CURCNTR(pipe)) & CURSOR_MODE;

	I915_STATE_WARN(cur_state != state,
	     "cursor on pipe %c assertion failure (expected %s, current %s)\n",
	     pipe_name(pipe), state_string(state), state_string(cur_state));
}
#define assert_cursor_enabled(d, p) assert_cursor(d, p, true)
#define assert_cursor_disabled(d, p) assert_cursor(d, p, false)

void assert_pipe(struct drm_i915_private *dev_priv,
		 enum pipe pipe, bool state)
{
	bool cur_state;
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);

	/* if we need the pipe quirk it must be always on */
	if ((pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) ||
	    (pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE))
		state = true;

	if (!intel_display_power_is_enabled(dev_priv,
				POWER_DOMAIN_TRANSCODER(cpu_transcoder))) {
		cur_state = false;
	} else {
		u32 val = I915_READ(PIPECONF(cpu_transcoder));
		cur_state = !!(val & PIPECONF_ENABLE);
	}

	I915_STATE_WARN(cur_state != state,
	     "pipe %c assertion failure (expected %s, current %s)\n",
	     pipe_name(pipe), state_string(state), state_string(cur_state));
}

static void assert_plane(struct drm_i915_private *dev_priv,
			 enum plane plane, bool state)
{
	u32 val;
	bool cur_state;

	val = I915_READ(DSPCNTR(plane));
	cur_state = !!(val & DISPLAY_PLANE_ENABLE);
	I915_STATE_WARN(cur_state != state,
	     "plane %c assertion failure (expected %s, current %s)\n",
	     plane_name(plane), state_string(state), state_string(cur_state));
}

#define assert_plane_enabled(d, p) assert_plane(d, p, true)
#define assert_plane_disabled(d, p) assert_plane(d, p, false)

static void assert_planes_disabled(struct drm_i915_private *dev_priv,
				   enum pipe pipe)
{
	struct drm_device *dev = dev_priv->dev;
	int i;

	/* Primary planes are fixed to pipes on gen4+ */
	if (INTEL_INFO(dev)->gen >= 4) {
		u32 val = I915_READ(DSPCNTR(pipe));
		I915_STATE_WARN(val & DISPLAY_PLANE_ENABLE,
		     "plane %c assertion failure, should be disabled but not\n",
		     plane_name(pipe));
		return;
	}

	/* Need to check both planes against the pipe */
	for_each_pipe(dev_priv, i) {
		u32 val = I915_READ(DSPCNTR(i));
		enum pipe cur_pipe = (val & DISPPLANE_SEL_PIPE_MASK) >>
			DISPPLANE_SEL_PIPE_SHIFT;
		I915_STATE_WARN((val & DISPLAY_PLANE_ENABLE) && pipe == cur_pipe,
		     "plane %c assertion failure, should be off on pipe %c but is still active\n",
		     plane_name(i), pipe_name(pipe));
	}
}

static void assert_sprites_disabled(struct drm_i915_private *dev_priv,
				    enum pipe pipe)
{
	struct drm_device *dev = dev_priv->dev;
	int sprite;

	if (INTEL_INFO(dev)->gen >= 9) {
		for_each_sprite(dev_priv, pipe, sprite) {
			u32 val = I915_READ(PLANE_CTL(pipe, sprite));
			I915_STATE_WARN(val & PLANE_CTL_ENABLE,
			     "plane %d assertion failure, should be off on pipe %c but is still active\n",
			     sprite, pipe_name(pipe));
		}
	} else if (IS_VALLEYVIEW(dev)) {
		for_each_sprite(dev_priv, pipe, sprite) {
			u32 val = I915_READ(SPCNTR(pipe, sprite));
			I915_STATE_WARN(val & SP_ENABLE,
			     "sprite %c assertion failure, should be off on pipe %c but is still active\n",
			     sprite_name(pipe, sprite), pipe_name(pipe));
		}
	} else if (INTEL_INFO(dev)->gen >= 7) {
		u32 val = I915_READ(SPRCTL(pipe));
		I915_STATE_WARN(val & SPRITE_ENABLE,
		     "sprite %c assertion failure, should be off on pipe %c but is still active\n",
		     plane_name(pipe), pipe_name(pipe));
	} else if (INTEL_INFO(dev)->gen >= 5) {
		u32 val = I915_READ(DVSCNTR(pipe));
		I915_STATE_WARN(val & DVS_ENABLE,
		     "sprite %c assertion failure, should be off on pipe %c but is still active\n",
		     plane_name(pipe), pipe_name(pipe));
	}
}

static void assert_vblank_disabled(struct drm_crtc *crtc)
{
	if (I915_STATE_WARN_ON(drm_crtc_vblank_get(crtc) == 0))
		drm_crtc_vblank_put(crtc);
}

static void ibx_assert_pch_refclk_enabled(struct drm_i915_private *dev_priv)
{
	u32 val;
	bool enabled;

	I915_STATE_WARN_ON(!(HAS_PCH_IBX(dev_priv->dev) || HAS_PCH_CPT(dev_priv->dev)));

	val = I915_READ(PCH_DREF_CONTROL);
	enabled = !!(val & (DREF_SSC_SOURCE_MASK | DREF_NONSPREAD_SOURCE_MASK |
			    DREF_SUPERSPREAD_SOURCE_MASK));
	I915_STATE_WARN(!enabled, "PCH refclk assertion failure, should be active but is disabled\n");
}

static void assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,
					   enum pipe pipe)
{
	u32 val;
	bool enabled;

	val = I915_READ(PCH_TRANSCONF(pipe));
	enabled = !!(val & TRANS_ENABLE);
	I915_STATE_WARN(enabled,
	     "transcoder assertion failed, should be off on pipe %c but is still active\n",
	     pipe_name(pipe));
}

static bool dp_pipe_enabled(struct drm_i915_private *dev_priv,
			    enum pipe pipe, u32 port_sel, u32 val)
{
	if ((val & DP_PORT_EN) == 0)
		return false;

	if (HAS_PCH_CPT(dev_priv->dev)) {
		u32	trans_dp_ctl_reg = TRANS_DP_CTL(pipe);
		u32	trans_dp_ctl = I915_READ(trans_dp_ctl_reg);
		if ((trans_dp_ctl & TRANS_DP_PORT_SEL_MASK) != port_sel)
			return false;
	} else if (IS_CHERRYVIEW(dev_priv->dev)) {
		if ((val & DP_PIPE_MASK_CHV) != DP_PIPE_SELECT_CHV(pipe))
			return false;
	} else {
		if ((val & DP_PIPE_MASK) != (pipe << 30))
			return false;
	}
	return true;
}

static bool hdmi_pipe_enabled(struct drm_i915_private *dev_priv,
			      enum pipe pipe, u32 val)
{
	if ((val & SDVO_ENABLE) == 0)
		return false;

	if (HAS_PCH_CPT(dev_priv->dev)) {
		if ((val & SDVO_PIPE_SEL_MASK_CPT) != SDVO_PIPE_SEL_CPT(pipe))
			return false;
	} else if (IS_CHERRYVIEW(dev_priv->dev)) {
		if ((val & SDVO_PIPE_SEL_MASK_CHV) != SDVO_PIPE_SEL_CHV(pipe))
			return false;
	} else {
		if ((val & SDVO_PIPE_SEL_MASK) != SDVO_PIPE_SEL(pipe))
			return false;
	}
	return true;
}

static bool lvds_pipe_enabled(struct drm_i915_private *dev_priv,
			      enum pipe pipe, u32 val)
{
	if ((val & LVDS_PORT_EN) == 0)
		return false;

	if (HAS_PCH_CPT(dev_priv->dev)) {
		if ((val & PORT_TRANS_SEL_MASK) != PORT_TRANS_SEL_CPT(pipe))
			return false;
	} else {
		if ((val & LVDS_PIPE_MASK) != LVDS_PIPE(pipe))
			return false;
	}
	return true;
}

static bool adpa_pipe_enabled(struct drm_i915_private *dev_priv,
			      enum pipe pipe, u32 val)
{
	if ((val & ADPA_DAC_ENABLE) == 0)
		return false;
	if (HAS_PCH_CPT(dev_priv->dev)) {
		if ((val & PORT_TRANS_SEL_MASK) != PORT_TRANS_SEL_CPT(pipe))
			return false;
	} else {
		if ((val & ADPA_PIPE_SELECT_MASK) != ADPA_PIPE_SELECT(pipe))
			return false;
	}
	return true;
}

static void assert_pch_dp_disabled(struct drm_i915_private *dev_priv,
				   enum pipe pipe, int reg, u32 port_sel)
{
	u32 val = I915_READ(reg);
	I915_STATE_WARN(dp_pipe_enabled(dev_priv, pipe, port_sel, val),
	     "PCH DP (0x%08x) enabled on transcoder %c, should be disabled\n",
	     reg, pipe_name(pipe));

	I915_STATE_WARN(HAS_PCH_IBX(dev_priv->dev) && (val & DP_PORT_EN) == 0
	     && (val & DP_PIPEB_SELECT),
	     "IBX PCH dp port still using transcoder B\n");
}

static void assert_pch_hdmi_disabled(struct drm_i915_private *dev_priv,
				     enum pipe pipe, int reg)
{
	u32 val = I915_READ(reg);
	I915_STATE_WARN(hdmi_pipe_enabled(dev_priv, pipe, val),
	     "PCH HDMI (0x%08x) enabled on transcoder %c, should be disabled\n",
	     reg, pipe_name(pipe));

	I915_STATE_WARN(HAS_PCH_IBX(dev_priv->dev) && (val & SDVO_ENABLE) == 0
	     && (val & SDVO_PIPE_B_SELECT),
	     "IBX PCH hdmi port still using transcoder B\n");
}

static void assert_pch_ports_disabled(struct drm_i915_private *dev_priv,
				      enum pipe pipe)
{
	u32 val;

	assert_pch_dp_disabled(dev_priv, pipe, PCH_DP_B, TRANS_DP_PORT_SEL_B);
	assert_pch_dp_disabled(dev_priv, pipe, PCH_DP_C, TRANS_DP_PORT_SEL_C);
	assert_pch_dp_disabled(dev_priv, pipe, PCH_DP_D, TRANS_DP_PORT_SEL_D);

	val = I915_READ(PCH_ADPA);
	I915_STATE_WARN(adpa_pipe_enabled(dev_priv, pipe, val),
	     "PCH VGA enabled on transcoder %c, should be disabled\n",
	     pipe_name(pipe));

	val = I915_READ(PCH_LVDS);
	I915_STATE_WARN(lvds_pipe_enabled(dev_priv, pipe, val),
	     "PCH LVDS enabled on transcoder %c, should be disabled\n",
	     pipe_name(pipe));

	assert_pch_hdmi_disabled(dev_priv, pipe, PCH_HDMIB);
	assert_pch_hdmi_disabled(dev_priv, pipe, PCH_HDMIC);
	assert_pch_hdmi_disabled(dev_priv, pipe, PCH_HDMID);
}

static void vlv_enable_pll(struct intel_crtc *crtc,
			   const struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int reg = DPLL(crtc->pipe);
	u32 dpll = pipe_config->dpll_hw_state.dpll;

	assert_pipe_disabled(dev_priv, crtc->pipe);

	/* No really, not for ILK+ */
	BUG_ON(!IS_VALLEYVIEW(dev_priv->dev));

	/* PLL is protected by panel, make sure we can write it */
	if (IS_MOBILE(dev_priv->dev))
		assert_panel_unlocked(dev_priv, crtc->pipe);

	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150);

	if (wait_for(((I915_READ(reg) & DPLL_LOCK_VLV) == DPLL_LOCK_VLV), 1))
		DRM_ERROR("DPLL %d failed to lock\n", crtc->pipe);

	I915_WRITE(DPLL_MD(crtc->pipe), pipe_config->dpll_hw_state.dpll_md);
	POSTING_READ(DPLL_MD(crtc->pipe));

	/* We do this three times for luck */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
}

static void chv_enable_pll(struct intel_crtc *crtc,
			   const struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
	enum dpio_channel port = vlv_pipe_to_channel(pipe);
	u32 tmp;

	assert_pipe_disabled(dev_priv, crtc->pipe);

	BUG_ON(!IS_CHERRYVIEW(dev_priv->dev));

	mutex_lock(&dev_priv->sb_lock);

	/* Enable back the 10bit clock to display controller */
	tmp = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
	tmp |= DPIO_DCLKP_EN;
	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), tmp);

	mutex_unlock(&dev_priv->sb_lock);

	/*
	 * Need to wait > 100ns between dclkp clock enable bit and PLL enable.
	 */
	udelay(1);

	/* Enable PLL */
	I915_WRITE(DPLL(pipe), pipe_config->dpll_hw_state.dpll);

	/* Check PLL is locked */
	if (wait_for(((I915_READ(DPLL(pipe)) & DPLL_LOCK_VLV) == DPLL_LOCK_VLV), 1))
		DRM_ERROR("PLL %d failed to lock\n", pipe);

	/* not sure when this should be written */
	I915_WRITE(DPLL_MD(pipe), pipe_config->dpll_hw_state.dpll_md);
	POSTING_READ(DPLL_MD(pipe));
}

static int intel_num_dvo_pipes(struct drm_device *dev)
{
	struct intel_crtc *crtc;
	int count = 0;

	for_each_intel_crtc(dev, crtc)
		count += crtc->base.state->active &&
			intel_pipe_has_type(crtc, INTEL_OUTPUT_DVO);

	return count;
}

static void i9xx_enable_pll(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int reg = DPLL(crtc->pipe);
	u32 dpll = crtc->config->dpll_hw_state.dpll;

	assert_pipe_disabled(dev_priv, crtc->pipe);

	/* No really, not for ILK+ */
	BUG_ON(INTEL_INFO(dev)->gen >= 5);

	/* PLL is protected by panel, make sure we can write it */
	if (IS_MOBILE(dev) && !IS_I830(dev))
		assert_panel_unlocked(dev_priv, crtc->pipe);

	/* Enable DVO 2x clock on both PLLs if necessary */
	if (IS_I830(dev) && intel_num_dvo_pipes(dev) > 0) {
		/*
		 * It appears to be important that we don't enable this
		 * for the current pipe before otherwise configuring the
		 * PLL. No idea how this should be handled if multiple
		 * DVO outputs are enabled simultaneosly.
		 */
		dpll |= DPLL_DVO_2X_MODE;
		I915_WRITE(DPLL(!crtc->pipe),
			   I915_READ(DPLL(!crtc->pipe)) | DPLL_DVO_2X_MODE);
	}

	/*
	 * Apparently we need to have VGA mode enabled prior to changing
	 * the P1/P2 dividers. Otherwise the DPLL will keep using the old
	 * dividers, even though the register value does change.
	 */
	I915_WRITE(reg, 0);

	I915_WRITE(reg, dpll);

	/* Wait for the clocks to stabilize. */
	POSTING_READ(reg);
	udelay(150);

	if (INTEL_INFO(dev)->gen >= 4) {
		I915_WRITE(DPLL_MD(crtc->pipe),
			   crtc->config->dpll_hw_state.dpll_md);
	} else {
		/* The pixel multiplier can only be updated once the
		 * DPLL is enabled and the clocks are stable.
		 *
		 * So write it again.
		 */
		I915_WRITE(reg, dpll);
	}

	/* We do this three times for luck */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
	I915_WRITE(reg, dpll);
	POSTING_READ(reg);
	udelay(150); /* wait for warmup */
}

/**
 * i9xx_disable_pll - disable a PLL
 * @@dev_priv: i915 private structure
 * @@pipe: pipe PLL to disable
 *
 * Disable the PLL for @@pipe, making sure the pipe is off first.
 *
 * Note!  This is for pre-ILK only.
 */
static void i9xx_disable_pll(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = crtc->pipe;

	/* Disable DVO 2x clock on both PLLs if necessary */
	if (IS_I830(dev) &&
	    intel_pipe_has_type(crtc, INTEL_OUTPUT_DVO) &&
	    !intel_num_dvo_pipes(dev)) {
		I915_WRITE(DPLL(PIPE_B),
			   I915_READ(DPLL(PIPE_B)) & ~DPLL_DVO_2X_MODE);
		I915_WRITE(DPLL(PIPE_A),
			   I915_READ(DPLL(PIPE_A)) & ~DPLL_DVO_2X_MODE);
	}

	/* Don't disable pipe or pipe PLLs if needed */
	if ((pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) ||
	    (pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE))
		return;

	/* Make sure the pipe isn't still relying on us */
	assert_pipe_disabled(dev_priv, pipe);

	I915_WRITE(DPLL(pipe), DPLL_VGA_MODE_DIS);
	POSTING_READ(DPLL(pipe));
}

static void vlv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
{
	u32 val;

	/* Make sure the pipe isn't still relying on us */
	assert_pipe_disabled(dev_priv, pipe);

	/*
	 * Leave integrated clock source and reference clock enabled for pipe B.
	 * The latter is needed for VGA hotplug / manual detection.
	 */
	val = DPLL_VGA_MODE_DIS;
	if (pipe == PIPE_B)
		val = DPLL_INTEGRATED_CRI_CLK_VLV | DPLL_REF_CLK_ENABLE_VLV;
	I915_WRITE(DPLL(pipe), val);
	POSTING_READ(DPLL(pipe));

}

static void chv_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
{
	enum dpio_channel port = vlv_pipe_to_channel(pipe);
	u32 val;

	/* Make sure the pipe isn't still relying on us */
	assert_pipe_disabled(dev_priv, pipe);

	/* Set PLL en = 0 */
	val = DPLL_SSC_REF_CLK_CHV |
		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS;
	if (pipe != PIPE_A)
		val |= DPLL_INTEGRATED_CRI_CLK_VLV;
	I915_WRITE(DPLL(pipe), val);
	POSTING_READ(DPLL(pipe));

	mutex_lock(&dev_priv->sb_lock);

	/* Disable 10bit clock to display controller */
	val = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port));
	val &= ~DPIO_DCLKP_EN;
	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port), val);

	mutex_unlock(&dev_priv->sb_lock);
}

void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
			 struct intel_digital_port *dport,
			 unsigned int expected_mask)
{
	u32 port_mask;
	int dpll_reg;

	switch (dport->port) {
	case PORT_B:
		port_mask = DPLL_PORTB_READY_MASK;
		dpll_reg = DPLL(0);
		break;
	case PORT_C:
		port_mask = DPLL_PORTC_READY_MASK;
		dpll_reg = DPLL(0);
		expected_mask <<= 4;
		break;
	case PORT_D:
		port_mask = DPLL_PORTD_READY_MASK;
		dpll_reg = DPIO_PHY_STATUS;
		break;
	default:
		BUG();
	}

	if (wait_for((I915_READ(dpll_reg) & port_mask) == expected_mask, 1000))
		WARN(1, "timed out waiting for port %c ready: got 0x%x, expected 0x%x\n",
		     port_name(dport->port), I915_READ(dpll_reg) & port_mask, expected_mask);
}

static void intel_prepare_shared_dpll(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_shared_dpll *pll = intel_crtc_to_shared_dpll(crtc);

	if (WARN_ON(pll == NULL))
		return;

	WARN_ON(!pll->config.crtc_mask);
	if (pll->active == 0) {
		DRM_DEBUG_DRIVER("setting up %s\n", pll->name);
		WARN_ON(pll->on);
		assert_shared_dpll_disabled(dev_priv, pll);

		pll->mode_set(dev_priv, pll);
	}
}

/**
 * intel_enable_shared_dpll - enable PCH PLL
 * @@dev_priv: i915 private structure
 * @@pipe: pipe PLL to enable
 *
 * The PCH PLL needs to be enabled before the PCH transcoder, since it
 * drives the transcoder clock.
 */
static void intel_enable_shared_dpll(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_shared_dpll *pll = intel_crtc_to_shared_dpll(crtc);

	if (WARN_ON(pll == NULL))
		return;

	if (WARN_ON(pll->config.crtc_mask == 0))
		return;

	DRM_DEBUG_KMS("enable %s (active %d, on? %d) for crtc %d\n",
		      pll->name, pll->active, pll->on,
		      crtc->base.base.id);

	if (pll->active++) {
		WARN_ON(!pll->on);
		assert_shared_dpll_enabled(dev_priv, pll);
		return;
	}
	WARN_ON(pll->on);

	intel_display_power_get(dev_priv, POWER_DOMAIN_PLLS);

	DRM_DEBUG_KMS("enabling %s\n", pll->name);
	pll->enable(dev_priv, pll);
	pll->on = true;
}

static void intel_disable_shared_dpll(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_shared_dpll *pll = intel_crtc_to_shared_dpll(crtc);

	/* PCH only available on ILK+ */
	if (INTEL_INFO(dev)->gen < 5)
		return;

	if (pll == NULL)
		return;

	if (WARN_ON(!(pll->config.crtc_mask & (1 << drm_crtc_index(&crtc->base)))))
		return;

	DRM_DEBUG_KMS("disable %s (active %d, on? %d) for crtc %d\n",
		      pll->name, pll->active, pll->on,
		      crtc->base.base.id);

	if (WARN_ON(pll->active == 0)) {
		assert_shared_dpll_disabled(dev_priv, pll);
		return;
	}

	assert_shared_dpll_enabled(dev_priv, pll);
	WARN_ON(!pll->on);
	if (--pll->active)
		return;

	DRM_DEBUG_KMS("disabling %s\n", pll->name);
	pll->disable(dev_priv, pll);
	pll->on = false;

	intel_display_power_put(dev_priv, POWER_DOMAIN_PLLS);
}

static void ironlake_enable_pch_transcoder(struct drm_i915_private *dev_priv,
					   enum pipe pipe)
{
	struct drm_device *dev = dev_priv->dev;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t reg, val, pipeconf_val;

	/* PCH only available on ILK+ */
	BUG_ON(!HAS_PCH_SPLIT(dev));

	/* Make sure PCH DPLL is enabled */
	assert_shared_dpll_enabled(dev_priv,
				   intel_crtc_to_shared_dpll(intel_crtc));

	/* FDI must be feeding us bits for PCH ports */
	assert_fdi_tx_enabled(dev_priv, pipe);
	assert_fdi_rx_enabled(dev_priv, pipe);

	if (HAS_PCH_CPT(dev)) {
		/* Workaround: Set the timing override bit before enabling the
		 * pch transcoder. */
		reg = TRANS_CHICKEN2(pipe);
		val = I915_READ(reg);
		val |= TRANS_CHICKEN2_TIMING_OVERRIDE;
		I915_WRITE(reg, val);
	}

	reg = PCH_TRANSCONF(pipe);
	val = I915_READ(reg);
	pipeconf_val = I915_READ(PIPECONF(pipe));

	if (HAS_PCH_IBX(dev_priv->dev)) {
		/*
		 * Make the BPC in transcoder be consistent with
		 * that in pipeconf reg. For HDMI we must use 8bpc
		 * here for both 8bpc and 12bpc.
		 */
		val &= ~PIPECONF_BPC_MASK;
		if (intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_HDMI))
			val |= PIPECONF_8BPC;
		else
			val |= pipeconf_val & PIPECONF_BPC_MASK;
	}

	val &= ~TRANS_INTERLACE_MASK;
	if ((pipeconf_val & PIPECONF_INTERLACE_MASK) == PIPECONF_INTERLACED_ILK)
		if (HAS_PCH_IBX(dev_priv->dev) &&
		    intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_SDVO))
			val |= TRANS_LEGACY_INTERLACED_ILK;
		else
			val |= TRANS_INTERLACED;
	else
		val |= TRANS_PROGRESSIVE;

	I915_WRITE(reg, val | TRANS_ENABLE);
	if (wait_for(I915_READ(reg) & TRANS_STATE_ENABLE, 100))
		DRM_ERROR("failed to enable transcoder %c\n", pipe_name(pipe));
}

static void lpt_enable_pch_transcoder(struct drm_i915_private *dev_priv,
				      enum transcoder cpu_transcoder)
{
	u32 val, pipeconf_val;

	/* PCH only available on ILK+ */
	BUG_ON(!HAS_PCH_SPLIT(dev_priv->dev));

	/* FDI must be feeding us bits for PCH ports */
	assert_fdi_tx_enabled(dev_priv, (enum pipe) cpu_transcoder);
	assert_fdi_rx_enabled(dev_priv, TRANSCODER_A);

	/* Workaround: set timing override bit. */
	val = I915_READ(TRANS_CHICKEN2(PIPE_A));
	val |= TRANS_CHICKEN2_TIMING_OVERRIDE;
	I915_WRITE(TRANS_CHICKEN2(PIPE_A), val);

	val = TRANS_ENABLE;
	pipeconf_val = I915_READ(PIPECONF(cpu_transcoder));

	if ((pipeconf_val & PIPECONF_INTERLACE_MASK_HSW) ==
	    PIPECONF_INTERLACED_ILK)
		val |= TRANS_INTERLACED;
	else
		val |= TRANS_PROGRESSIVE;

	I915_WRITE(LPT_TRANSCONF, val);
	if (wait_for(I915_READ(LPT_TRANSCONF) & TRANS_STATE_ENABLE, 100))
		DRM_ERROR("Failed to enable PCH transcoder\n");
}

static void ironlake_disable_pch_transcoder(struct drm_i915_private *dev_priv,
					    enum pipe pipe)
{
	struct drm_device *dev = dev_priv->dev;
	uint32_t reg, val;

	/* FDI relies on the transcoder */
	assert_fdi_tx_disabled(dev_priv, pipe);
	assert_fdi_rx_disabled(dev_priv, pipe);

	/* Ports must be off as well */
	assert_pch_ports_disabled(dev_priv, pipe);

	reg = PCH_TRANSCONF(pipe);
	val = I915_READ(reg);
	val &= ~TRANS_ENABLE;
	I915_WRITE(reg, val);
	/* wait for PCH transcoder off, transcoder state */
	if (wait_for((I915_READ(reg) & TRANS_STATE_ENABLE) == 0, 50))
		DRM_ERROR("failed to disable transcoder %c\n", pipe_name(pipe));

	if (!HAS_PCH_IBX(dev)) {
		/* Workaround: Clear the timing override chicken bit again. */
		reg = TRANS_CHICKEN2(pipe);
		val = I915_READ(reg);
		val &= ~TRANS_CHICKEN2_TIMING_OVERRIDE;
		I915_WRITE(reg, val);
	}
}

static void lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv)
{
	u32 val;

	val = I915_READ(LPT_TRANSCONF);
	val &= ~TRANS_ENABLE;
	I915_WRITE(LPT_TRANSCONF, val);
	/* wait for PCH transcoder off, transcoder state */
	if (wait_for((I915_READ(LPT_TRANSCONF) & TRANS_STATE_ENABLE) == 0, 50))
		DRM_ERROR("Failed to disable PCH transcoder\n");

	/* Workaround: clear timing override bit. */
	val = I915_READ(TRANS_CHICKEN2(PIPE_A));
	val &= ~TRANS_CHICKEN2_TIMING_OVERRIDE;
	I915_WRITE(TRANS_CHICKEN2(PIPE_A), val);
}

/**
 * intel_enable_pipe - enable a pipe, asserting requirements
 * @@crtc: crtc responsible for the pipe
 *
 * Enable @@crtc's pipe, making sure that various hardware specific requirements
 * are met, if applicable, e.g. PLL enabled, LVDS pairs enabled, etc.
 */
static void intel_enable_pipe(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = crtc->pipe;
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
	enum pipe pch_transcoder;
	int reg;
	u32 val;

	DRM_DEBUG_KMS("enabling pipe %c\n", pipe_name(pipe));

	assert_planes_disabled(dev_priv, pipe);
	assert_cursor_disabled(dev_priv, pipe);
	assert_sprites_disabled(dev_priv, pipe);

	if (HAS_PCH_LPT(dev_priv->dev))
		pch_transcoder = TRANSCODER_A;
	else
		pch_transcoder = pipe;

	/*
	 * A pipe without a PLL won't actually be able to drive bits from
	 * a plane.  On ILK+ the pipe PLLs are integrated, so we don't
	 * need the check.
	 */
	if (HAS_GMCH_DISPLAY(dev_priv->dev))
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DSI))
			assert_dsi_pll_enabled(dev_priv);
		else
			assert_pll_enabled(dev_priv, pipe);
	else {
		if (crtc->config->has_pch_encoder) {
			/* if driving the PCH, we need FDI enabled */
			assert_fdi_rx_pll_enabled(dev_priv, pch_transcoder);
			assert_fdi_tx_pll_enabled(dev_priv,
						  (enum pipe) cpu_transcoder);
		}
		/* FIXME: assert CPU port conditions for SNB+ */
	}

	reg = PIPECONF(cpu_transcoder);
	val = I915_READ(reg);
	if (val & PIPECONF_ENABLE) {
		WARN_ON(!((pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) ||
			  (pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE)));
		return;
	}

	I915_WRITE(reg, val | PIPECONF_ENABLE);
	POSTING_READ(reg);
}

/**
 * intel_disable_pipe - disable a pipe, asserting requirements
 * @@crtc: crtc whose pipes is to be disabled
 *
 * Disable the pipe of @@crtc, making sure that various hardware
 * specific requirements are met, if applicable, e.g. plane
 * disabled, panel fitter off, etc.
 *
 * Will wait until the pipe has shut down before returning.
 */
static void intel_disable_pipe(struct intel_crtc *crtc)
{
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
	enum transcoder cpu_transcoder = crtc->config->cpu_transcoder;
	enum pipe pipe = crtc->pipe;
	int reg;
	u32 val;

	DRM_DEBUG_KMS("disabling pipe %c\n", pipe_name(pipe));

	/*
	 * Make sure planes won't keep trying to pump pixels to us,
	 * or we might hang the display.
	 */
	assert_planes_disabled(dev_priv, pipe);
	assert_cursor_disabled(dev_priv, pipe);
	assert_sprites_disabled(dev_priv, pipe);

	reg = PIPECONF(cpu_transcoder);
	val = I915_READ(reg);
	if ((val & PIPECONF_ENABLE) == 0)
		return;

	/*
	 * Double wide has implications for planes
	 * so best keep it disabled when not needed.
	 */
	if (crtc->config->double_wide)
		val &= ~PIPECONF_DOUBLE_WIDE;

	/* Don't disable pipe or pipe PLLs if needed */
	if (!(pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) &&
	    !(pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE))
		val &= ~PIPECONF_ENABLE;

	I915_WRITE(reg, val);
	if ((val & PIPECONF_ENABLE) == 0)
		intel_wait_for_pipe_off(crtc);
}

static bool need_vtd_wa(struct drm_device *dev)
{
#ifdef CONFIG_INTEL_IOMMU
	if (INTEL_INFO(dev)->gen >= 6 && intel_iommu_gfx_mapped)
		return true;
#endif
	return false;
}

unsigned int
intel_tile_height(struct drm_device *dev, uint32_t pixel_format,
		  uint64_t fb_format_modifier, unsigned int plane)
{
	unsigned int tile_height;
	uint32_t pixel_bytes;

	switch (fb_format_modifier) {
	case DRM_FORMAT_MOD_NONE:
		tile_height = 1;
		break;
	case I915_FORMAT_MOD_X_TILED:
		tile_height = IS_GEN2(dev) ? 16 : 8;
		break;
	case I915_FORMAT_MOD_Y_TILED:
		tile_height = 32;
		break;
	case I915_FORMAT_MOD_Yf_TILED:
		pixel_bytes = drm_format_plane_cpp(pixel_format, plane);
		switch (pixel_bytes) {
		default:
		case 1:
			tile_height = 64;
			break;
		case 2:
		case 4:
			tile_height = 32;
			break;
		case 8:
			tile_height = 16;
			break;
		case 16:
			WARN_ONCE(1,
				  "128-bit pixels are not supported for display!");
			tile_height = 16;
			break;
		}
		break;
	default:
		MISSING_CASE(fb_format_modifier);
		tile_height = 1;
		break;
	}

	return tile_height;
}

unsigned int
intel_fb_align_height(struct drm_device *dev, unsigned int height,
		      uint32_t pixel_format, uint64_t fb_format_modifier)
{
	return roundup2(height, intel_tile_height(dev, pixel_format,
					       fb_format_modifier, 0));
}

static int
intel_fill_fb_ggtt_view(struct i915_ggtt_view *view, struct drm_framebuffer *fb,
			const struct drm_plane_state *plane_state)
{
	struct intel_rotation_info *info = &view->rotation_info;
	unsigned int tile_height, tile_pitch;

	*view = i915_ggtt_view_normal;

	if (!plane_state)
		return 0;

	if (!intel_rotation_90_or_270(plane_state->rotation))
		return 0;

	*view = i915_ggtt_view_rotated;

	info->height = fb->height;
	info->pixel_format = fb->pixel_format;
	info->pitch = fb->pitches[0];
	info->uv_offset = fb->offsets[1];
	info->fb_modifier = fb->modifier[0];

	tile_height = intel_tile_height(fb->dev, fb->pixel_format,
					fb->modifier[0], 0);
	tile_pitch = PAGE_SIZE / tile_height;
	info->width_pages = DIV_ROUND_UP(fb->pitches[0], tile_pitch);
	info->height_pages = DIV_ROUND_UP(fb->height, tile_height);
	info->size = info->width_pages * info->height_pages * PAGE_SIZE;

	if (info->pixel_format == DRM_FORMAT_NV12) {
		tile_height = intel_tile_height(fb->dev, fb->pixel_format,
						fb->modifier[0], 1);
		tile_pitch = PAGE_SIZE / tile_height;
		info->width_pages_uv = DIV_ROUND_UP(fb->pitches[0], tile_pitch);
		info->height_pages_uv = DIV_ROUND_UP(fb->height / 2,
						     tile_height);
		info->size_uv = info->width_pages_uv * info->height_pages_uv *
				PAGE_SIZE;
	}

	return 0;
}

static unsigned int intel_linear_alignment(struct drm_i915_private *dev_priv)
{
	if (INTEL_INFO(dev_priv)->gen >= 9)
		return 256 * 1024;
	else if (IS_BROADWATER(dev_priv) || IS_CRESTLINE(dev_priv) ||
		 IS_VALLEYVIEW(dev_priv))
		return 128 * 1024;
	else if (INTEL_INFO(dev_priv)->gen >= 4)
		return 4 * 1024;
	else
		return 0;
}

int
intel_pin_and_fence_fb_obj(struct drm_plane *plane,
			   struct drm_framebuffer *fb,
			   const struct drm_plane_state *plane_state,
			   struct intel_engine_cs *pipelined,
			   struct drm_i915_gem_request **pipelined_request)
{
	struct drm_device *dev = fb->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	struct i915_ggtt_view view;
	u32 alignment;
	int ret;

	WARN_ON(!mutex_is_locked(&dev->struct_mutex));

	switch (fb->modifier[0]) {
	case DRM_FORMAT_MOD_NONE:
		alignment = intel_linear_alignment(dev_priv);
		break;
	case I915_FORMAT_MOD_X_TILED:
		if (INTEL_INFO(dev)->gen >= 9)
			alignment = 256 * 1024;
		else {
			/* pin() will align the object as required by fence */
			alignment = 0;
		}
		break;
	case I915_FORMAT_MOD_Y_TILED:
	case I915_FORMAT_MOD_Yf_TILED:
		if (WARN_ONCE(INTEL_INFO(dev)->gen < 9,
			  "Y tiling bo slipped through, driver bug!\n"))
			return -EINVAL;
		alignment = 1 * 1024 * 1024;
		break;
	default:
		MISSING_CASE(fb->modifier[0]);
		return -EINVAL;
	}

	ret = intel_fill_fb_ggtt_view(&view, fb, plane_state);
	if (ret)
		return ret;

	/* Note that the w/a also requires 64 PTE of padding following the
	 * bo. We currently fill all unused PTE with the shadow page and so
	 * we should always have valid PTE following the scanout preventing
	 * the VT-d warning.
	 */
	if (need_vtd_wa(dev) && alignment < 256 * 1024)
		alignment = 256 * 1024;

	/*
	 * Global gtt pte registers are special registers which actually forward
	 * writes to a chunk of system memory. Which means that there is no risk
	 * that the register values disappear as soon as we call
	 * intel_runtime_pm_put(), so it is correct to wrap only the
	 * pin/unpin/fence and not more.
	 */
	intel_runtime_pm_get(dev_priv);

	dev_priv->mm.interruptible = false;
	ret = i915_gem_object_pin_to_display_plane(obj, alignment, pipelined,
						   pipelined_request, &view);
	if (ret)
		goto err_interruptible;

	/* Install a fence for tiled scan-out. Pre-i965 always needs a
	 * fence, whereas 965+ only requires a fence if using
	 * framebuffer compression.  For simplicity, we always install
	 * a fence as the cost is not that onerous.
	 */
	if (view.type == I915_GGTT_VIEW_NORMAL) {
		ret = i915_gem_object_get_fence(obj);
		if (ret == -EDEADLK) {
			/*
			 * -EDEADLK means there are no free fences
			 * no pending flips.
			 *
			 * This is propagated to atomic, but it uses
			 * -EDEADLK to force a locking recovery, so
			 * change the returned error to -EBUSY.
			 */
			ret = -EBUSY;
			goto err_unpin;
		} else if (ret)
			goto err_unpin;

		i915_gem_object_pin_fence(obj);
	}

	dev_priv->mm.interruptible = true;
	intel_runtime_pm_put(dev_priv);
	return 0;

err_unpin:
	i915_gem_object_unpin_from_display_plane(obj, &view);
err_interruptible:
	dev_priv->mm.interruptible = true;
	intel_runtime_pm_put(dev_priv);
	return ret;
}

static void intel_unpin_fb_obj(struct drm_framebuffer *fb,
			       const struct drm_plane_state *plane_state)
{
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	struct i915_ggtt_view view;
	int ret;

	WARN_ON(!mutex_is_locked(&obj->base.dev->struct_mutex));

	ret = intel_fill_fb_ggtt_view(&view, fb, plane_state);
	WARN_ONCE(ret, "Couldn't get view from plane state!");

	if (view.type == I915_GGTT_VIEW_NORMAL)
		i915_gem_object_unpin_fence(obj);

	i915_gem_object_unpin_from_display_plane(obj, &view);
}

/* Computes the linear offset to the base tile and adjusts x, y. bytes per pixel
 * is assumed to be a power-of-two. */
unsigned long intel_gen4_compute_page_offset(struct drm_i915_private *dev_priv,
					     int *x, int *y,
					     unsigned int tiling_mode,
					     unsigned int cpp,
					     unsigned int pitch)
{
	if (tiling_mode != I915_TILING_NONE) {
		unsigned int tile_rows, tiles;

		tile_rows = *y / 8;
		*y %= 8;

		tiles = *x / (512/cpp);
		*x %= 512/cpp;

		return tile_rows * pitch * 8 + tiles * 4096;
	} else {
		unsigned int alignment = intel_linear_alignment(dev_priv) - 1;
		unsigned int offset;

		offset = *y * pitch + *x * cpp;
		*y = (offset & alignment) / pitch;
		*x = ((offset & alignment) - *y * pitch) / cpp;
		return offset & ~alignment;
	}
}

static int i9xx_format_to_fourcc(int format)
{
	switch (format) {
	case DISPPLANE_8BPP:
		return DRM_FORMAT_C8;
	case DISPPLANE_BGRX555:
		return DRM_FORMAT_XRGB1555;
	case DISPPLANE_BGRX565:
		return DRM_FORMAT_RGB565;
	default:
	case DISPPLANE_BGRX888:
		return DRM_FORMAT_XRGB8888;
	case DISPPLANE_RGBX888:
		return DRM_FORMAT_XBGR8888;
	case DISPPLANE_BGRX101010:
		return DRM_FORMAT_XRGB2101010;
	case DISPPLANE_RGBX101010:
		return DRM_FORMAT_XBGR2101010;
	}
}

static int skl_format_to_fourcc(int format, bool rgb_order, bool alpha)
{
	switch (format) {
	case PLANE_CTL_FORMAT_RGB_565:
		return DRM_FORMAT_RGB565;
	default:
	case PLANE_CTL_FORMAT_XRGB_8888:
		if (rgb_order) {
			if (alpha)
				return DRM_FORMAT_ABGR8888;
			else
				return DRM_FORMAT_XBGR8888;
		} else {
			if (alpha)
				return DRM_FORMAT_ARGB8888;
			else
				return DRM_FORMAT_XRGB8888;
		}
	case PLANE_CTL_FORMAT_XRGB_2101010:
		if (rgb_order)
			return DRM_FORMAT_XBGR2101010;
		else
			return DRM_FORMAT_XRGB2101010;
	}
}

static bool
intel_alloc_initial_plane_obj(struct intel_crtc *crtc,
			      struct intel_initial_plane_config *plane_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct drm_i915_gem_object *obj = NULL;
	struct drm_mode_fb_cmd2 mode_cmd = { 0 };
	struct drm_framebuffer *fb = &plane_config->fb->base;
	u32 base_aligned = round_down(plane_config->base, PAGE_SIZE);
	u32 size_aligned = round_up(plane_config->base + plane_config->size,
				    PAGE_SIZE);

	size_aligned -= base_aligned;

	if (plane_config->size == 0)
		return false;

	/* If the FB is too big, just don't use it since fbdev is not very
	 * important and we should probably use that space with FBC or other
	 * features. */
	if (size_aligned * 2 > dev_priv->gtt.stolen_usable_size)
		return false;

	obj = i915_gem_object_create_stolen_for_preallocated(dev,
							     base_aligned,
							     base_aligned,
							     size_aligned);
	if (!obj)
		return false;

	obj->tiling_mode = plane_config->tiling;
	if (obj->tiling_mode == I915_TILING_X)
		obj->stride = fb->pitches[0];

	mode_cmd.pixel_format = fb->pixel_format;
	mode_cmd.width = fb->width;
	mode_cmd.height = fb->height;
	mode_cmd.pitches[0] = fb->pitches[0];
	mode_cmd.modifier[0] = fb->modifier[0];
	mode_cmd.flags = DRM_MODE_FB_MODIFIERS;

	mutex_lock(&dev->struct_mutex);
	if (intel_framebuffer_init(dev, to_intel_framebuffer(fb),
				   &mode_cmd, obj)) {
		DRM_DEBUG_KMS("intel fb init failed\n");
		goto out_unref_obj;
	}
	mutex_unlock(&dev->struct_mutex);

	DRM_DEBUG_KMS("initial plane fb obj %p\n", obj);
	return true;

out_unref_obj:
	drm_gem_object_unreference(&obj->base);
	mutex_unlock(&dev->struct_mutex);
	return false;
}

/* Update plane->state->fb to match plane->fb after driver-internal updates */
static void
update_state_fb(struct drm_plane *plane)
{
	if (plane->fb == plane->state->fb)
		return;

	if (plane->state->fb)
		drm_framebuffer_unreference(plane->state->fb);
	plane->state->fb = plane->fb;
	if (plane->state->fb)
		drm_framebuffer_reference(plane->state->fb);
}

static void
intel_find_initial_plane_obj(struct intel_crtc *intel_crtc,
			     struct intel_initial_plane_config *plane_config)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *c;
	struct intel_crtc *i;
	struct drm_i915_gem_object *obj;
	struct drm_plane *primary = intel_crtc->base.primary;
	struct drm_plane_state *plane_state = primary->state;
	struct drm_crtc_state *crtc_state = intel_crtc->base.state;
	struct intel_plane *intel_plane = to_intel_plane(primary);
	struct drm_framebuffer *fb;

	if (!plane_config->fb)
		return;

	if (intel_alloc_initial_plane_obj(intel_crtc, plane_config)) {
		fb = &plane_config->fb->base;
		goto valid_fb;
	}

	kfree(plane_config->fb);

	/*
	 * Failed to alloc the obj, check to see if we should share
	 * an fb with another CRTC instead
	 */
	for_each_crtc(dev, c) {
		i = to_intel_crtc(c);

		if (c == &intel_crtc->base)
			continue;

		if (!i->active)
			continue;

		fb = c->primary->fb;
		if (!fb)
			continue;

		obj = intel_fb_obj(fb);
		if (i915_gem_obj_ggtt_offset(obj) == plane_config->base) {
			drm_framebuffer_reference(fb);
			goto valid_fb;
		}
	}

	/*
	 * We've failed to reconstruct the BIOS FB.  Current display state
	 * indicates that the primary plane is visible, but has a NULL FB,
	 * which will lead to problems later if we don't fix it up.  The
	 * simplest solution is to just disable the primary plane now and
	 * pretend the BIOS never had it enabled.
	 */
	to_intel_plane_state(plane_state)->visible = false;
	crtc_state->plane_mask &= ~(1 << drm_plane_index(primary));
	intel_pre_disable_primary(&intel_crtc->base);
	intel_plane->disable_plane(primary, &intel_crtc->base);

	return;

valid_fb:
	plane_state->src_x = 0;
	plane_state->src_y = 0;
	plane_state->src_w = fb->width << 16;
	plane_state->src_h = fb->height << 16;

	plane_state->crtc_x = 0;
	plane_state->crtc_y = 0;
	plane_state->crtc_w = fb->width;
	plane_state->crtc_h = fb->height;

	obj = intel_fb_obj(fb);
	if (obj->tiling_mode != I915_TILING_NONE)
		dev_priv->preserve_bios_swizzle = true;

	drm_framebuffer_reference(fb);
	primary->fb = primary->state->fb = fb;
	primary->crtc = primary->state->crtc = &intel_crtc->base;
	intel_crtc->base.state->plane_mask |= (1 << drm_plane_index(primary));
	obj->frontbuffer_bits |= to_intel_plane(primary)->frontbuffer_bit;
}

static void i9xx_update_primary_plane(struct drm_crtc *crtc,
				      struct drm_framebuffer *fb,
				      int x, int y)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *primary = crtc->primary;
	bool visible = to_intel_plane_state(primary->state)->visible;
	struct drm_i915_gem_object *obj;
	int plane = intel_crtc->plane;
	unsigned long linear_offset;
	u32 dspcntr;
	u32 reg = DSPCNTR(plane);
	int pixel_size;

	if (!visible || !fb) {
		I915_WRITE(reg, 0);
		if (INTEL_INFO(dev)->gen >= 4)
			I915_WRITE(DSPSURF(plane), 0);
		else
			I915_WRITE(DSPADDR(plane), 0);
		POSTING_READ(reg);
		return;
	}

	obj = intel_fb_obj(fb);
	if (WARN_ON(obj == NULL))
		return;

	pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);

	dspcntr = DISPPLANE_GAMMA_ENABLE;

	dspcntr |= DISPLAY_PLANE_ENABLE;

	if (INTEL_INFO(dev)->gen < 4) {
		if (intel_crtc->pipe == PIPE_B)
			dspcntr |= DISPPLANE_SEL_PIPE_B;

		/* pipesrc and dspsize control the size that is scaled from,
		 * which should always be the user's requested size.
		 */
		I915_WRITE(DSPSIZE(plane),
			   ((intel_crtc->config->pipe_src_h - 1) << 16) |
			   (intel_crtc->config->pipe_src_w - 1));
		I915_WRITE(DSPPOS(plane), 0);
	} else if (IS_CHERRYVIEW(dev) && plane == PLANE_B) {
		I915_WRITE(PRIMSIZE(plane),
			   ((intel_crtc->config->pipe_src_h - 1) << 16) |
			   (intel_crtc->config->pipe_src_w - 1));
		I915_WRITE(PRIMPOS(plane), 0);
		I915_WRITE(PRIMCNSTALPHA(plane), 0);
	}

	switch (fb->pixel_format) {
	case DRM_FORMAT_C8:
		dspcntr |= DISPPLANE_8BPP;
		break;
	case DRM_FORMAT_XRGB1555:
		dspcntr |= DISPPLANE_BGRX555;
		break;
	case DRM_FORMAT_RGB565:
		dspcntr |= DISPPLANE_BGRX565;
		break;
	case DRM_FORMAT_XRGB8888:
		dspcntr |= DISPPLANE_BGRX888;
		break;
	case DRM_FORMAT_XBGR8888:
		dspcntr |= DISPPLANE_RGBX888;
		break;
	case DRM_FORMAT_XRGB2101010:
		dspcntr |= DISPPLANE_BGRX101010;
		break;
	case DRM_FORMAT_XBGR2101010:
		dspcntr |= DISPPLANE_RGBX101010;
		break;
	default:
		BUG();
	}

	if (INTEL_INFO(dev)->gen >= 4 &&
	    obj->tiling_mode != I915_TILING_NONE)
		dspcntr |= DISPPLANE_TILED;

	if (IS_G4X(dev))
		dspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;

	linear_offset = y * fb->pitches[0] + x * pixel_size;

	if (INTEL_INFO(dev)->gen >= 4) {
		intel_crtc->dspaddr_offset =
			intel_gen4_compute_page_offset(dev_priv,
						       &x, &y, obj->tiling_mode,
						       pixel_size,
						       fb->pitches[0]);
		linear_offset -= intel_crtc->dspaddr_offset;
	} else {
		intel_crtc->dspaddr_offset = linear_offset;
	}

	if (crtc->primary->state->rotation == BIT(DRM_ROTATE_180)) {
		dspcntr |= DISPPLANE_ROTATE_180;

		x += (intel_crtc->config->pipe_src_w - 1);
		y += (intel_crtc->config->pipe_src_h - 1);

		/* Finding the last pixel of the last line of the display
		data and adding to linear_offset*/
		linear_offset +=
			(intel_crtc->config->pipe_src_h - 1) * fb->pitches[0] +
			(intel_crtc->config->pipe_src_w - 1) * pixel_size;
	}

	intel_crtc->adjusted_x = x;
	intel_crtc->adjusted_y = y;

	I915_WRITE(reg, dspcntr);

	I915_WRITE(DSPSTRIDE(plane), fb->pitches[0]);
	if (INTEL_INFO(dev)->gen >= 4) {
		I915_WRITE(DSPSURF(plane),
			   i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
		I915_WRITE(DSPTILEOFF(plane), (y << 16) | x);
		I915_WRITE(DSPLINOFF(plane), linear_offset);
	} else
		I915_WRITE(DSPADDR(plane), i915_gem_obj_ggtt_offset(obj) + linear_offset);
	POSTING_READ(reg);
}

static void ironlake_update_primary_plane(struct drm_crtc *crtc,
					  struct drm_framebuffer *fb,
					  int x, int y)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *primary = crtc->primary;
	bool visible = to_intel_plane_state(primary->state)->visible;
	struct drm_i915_gem_object *obj;
	int plane = intel_crtc->plane;
	unsigned long linear_offset;
	u32 dspcntr;
	u32 reg = DSPCNTR(plane);
	int pixel_size;

	if (!visible || !fb) {
		I915_WRITE(reg, 0);
		I915_WRITE(DSPSURF(plane), 0);
		POSTING_READ(reg);
		return;
	}

	obj = intel_fb_obj(fb);
	if (WARN_ON(obj == NULL))
		return;

	pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);

	dspcntr = DISPPLANE_GAMMA_ENABLE;

	dspcntr |= DISPLAY_PLANE_ENABLE;

	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		dspcntr |= DISPPLANE_PIPE_CSC_ENABLE;

	switch (fb->pixel_format) {
	case DRM_FORMAT_C8:
		dspcntr |= DISPPLANE_8BPP;
		break;
	case DRM_FORMAT_RGB565:
		dspcntr |= DISPPLANE_BGRX565;
		break;
	case DRM_FORMAT_XRGB8888:
		dspcntr |= DISPPLANE_BGRX888;
		break;
	case DRM_FORMAT_XBGR8888:
		dspcntr |= DISPPLANE_RGBX888;
		break;
	case DRM_FORMAT_XRGB2101010:
		dspcntr |= DISPPLANE_BGRX101010;
		break;
	case DRM_FORMAT_XBGR2101010:
		dspcntr |= DISPPLANE_RGBX101010;
		break;
	default:
		BUG();
	}

	if (obj->tiling_mode != I915_TILING_NONE)
		dspcntr |= DISPPLANE_TILED;

	if (!IS_HASWELL(dev) && !IS_BROADWELL(dev))
		dspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;

	linear_offset = y * fb->pitches[0] + x * pixel_size;
	intel_crtc->dspaddr_offset =
		intel_gen4_compute_page_offset(dev_priv,
					       &x, &y, obj->tiling_mode,
					       pixel_size,
					       fb->pitches[0]);
	linear_offset -= intel_crtc->dspaddr_offset;
	if (crtc->primary->state->rotation == BIT(DRM_ROTATE_180)) {
		dspcntr |= DISPPLANE_ROTATE_180;

		if (!IS_HASWELL(dev) && !IS_BROADWELL(dev)) {
			x += (intel_crtc->config->pipe_src_w - 1);
			y += (intel_crtc->config->pipe_src_h - 1);

			/* Finding the last pixel of the last line of the display
			data and adding to linear_offset*/
			linear_offset +=
				(intel_crtc->config->pipe_src_h - 1) * fb->pitches[0] +
				(intel_crtc->config->pipe_src_w - 1) * pixel_size;
		}
	}

	intel_crtc->adjusted_x = x;
	intel_crtc->adjusted_y = y;

	I915_WRITE(reg, dspcntr);

	I915_WRITE(DSPSTRIDE(plane), fb->pitches[0]);
	I915_WRITE(DSPSURF(plane),
		   i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
	if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		I915_WRITE(DSPOFFSET(plane), (y << 16) | x);
	} else {
		I915_WRITE(DSPTILEOFF(plane), (y << 16) | x);
		I915_WRITE(DSPLINOFF(plane), linear_offset);
	}
	POSTING_READ(reg);
}

u32 intel_fb_stride_alignment(struct drm_device *dev, uint64_t fb_modifier,
			      uint32_t pixel_format)
{
	u32 bits_per_pixel = drm_format_plane_cpp(pixel_format, 0) * 8;

	/*
	 * The stride is either expressed as a multiple of 64 bytes
	 * chunks for linear buffers or in number of tiles for tiled
	 * buffers.
	 */
	switch (fb_modifier) {
	case DRM_FORMAT_MOD_NONE:
		return 64;
	case I915_FORMAT_MOD_X_TILED:
		if (INTEL_INFO(dev)->gen == 2)
			return 128;
		return 512;
	case I915_FORMAT_MOD_Y_TILED:
		/* No need to check for old gens and Y tiling since this is
		 * about the display engine and those will be blocked before
		 * we get here.
		 */
		return 128;
	case I915_FORMAT_MOD_Yf_TILED:
		if (bits_per_pixel == 8)
			return 64;
		else
			return 128;
	default:
		MISSING_CASE(fb_modifier);
		return 64;
	}
}

u32 intel_plane_obj_offset(struct intel_plane *intel_plane,
			   struct drm_i915_gem_object *obj,
			   unsigned int plane)
{
	const struct i915_ggtt_view *view = &i915_ggtt_view_normal;
	struct i915_vma *vma;
	u64 offset;

	if (intel_rotation_90_or_270(intel_plane->base.state->rotation))
		view = &i915_ggtt_view_rotated;

	vma = i915_gem_obj_to_ggtt_view(obj, view);
	if (WARN(!vma, "ggtt vma for display object not found! (view=%u)\n",
		view->type))
		return -1;

	offset = vma->node.start;

	if (plane == 1) {
		offset += vma->ggtt_view.rotation_info.uv_start_page *
			  PAGE_SIZE;
	}

	WARN_ON(upper_32_bits(offset));

	return lower_32_bits(offset);
}

static void skl_detach_scaler(struct intel_crtc *intel_crtc, int id)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE(SKL_PS_CTRL(intel_crtc->pipe, id), 0);
	I915_WRITE(SKL_PS_WIN_POS(intel_crtc->pipe, id), 0);
	I915_WRITE(SKL_PS_WIN_SZ(intel_crtc->pipe, id), 0);
}

/*
 * This function detaches (aka. unbinds) unused scalers in hardware
 */
static void skl_detach_scalers(struct intel_crtc *intel_crtc)
{
	struct intel_crtc_scaler_state *scaler_state;
	int i;

	scaler_state = &intel_crtc->config->scaler_state;

	/* loop through and disable scalers that aren't in use */
	for (i = 0; i < intel_crtc->num_scalers; i++) {
		if (!scaler_state->scalers[i].in_use)
			skl_detach_scaler(intel_crtc, i);
	}
}

u32 skl_plane_ctl_format(uint32_t pixel_format)
{
	switch (pixel_format) {
	case DRM_FORMAT_C8:
		return PLANE_CTL_FORMAT_INDEXED;
	case DRM_FORMAT_RGB565:
		return PLANE_CTL_FORMAT_RGB_565;
	case DRM_FORMAT_XBGR8888:
		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX;
	case DRM_FORMAT_XRGB8888:
		return PLANE_CTL_FORMAT_XRGB_8888;
	/*
	 * XXX: For ARBG/ABGR formats we default to expecting scanout buffers
	 * to be already pre-multiplied. We need to add a knob (or a different
	 * DRM_FORMAT) for user-space to configure that.
	 */
	case DRM_FORMAT_ABGR8888:
		return PLANE_CTL_FORMAT_XRGB_8888 | PLANE_CTL_ORDER_RGBX |
			PLANE_CTL_ALPHA_SW_PREMULTIPLY;
	case DRM_FORMAT_ARGB8888:
		return PLANE_CTL_FORMAT_XRGB_8888 |
			PLANE_CTL_ALPHA_SW_PREMULTIPLY;
	case DRM_FORMAT_XRGB2101010:
		return PLANE_CTL_FORMAT_XRGB_2101010;
	case DRM_FORMAT_XBGR2101010:
		return PLANE_CTL_ORDER_RGBX | PLANE_CTL_FORMAT_XRGB_2101010;
	case DRM_FORMAT_YUYV:
		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YUYV;
	case DRM_FORMAT_YVYU:
		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_YVYU;
	case DRM_FORMAT_UYVY:
		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_UYVY;
	case DRM_FORMAT_VYUY:
		return PLANE_CTL_FORMAT_YUV422 | PLANE_CTL_YUV422_VYUY;
	default:
		MISSING_CASE(pixel_format);
	}

	return 0;
}

u32 skl_plane_ctl_tiling(uint64_t fb_modifier)
{
	switch (fb_modifier) {
	case DRM_FORMAT_MOD_NONE:
		break;
	case I915_FORMAT_MOD_X_TILED:
		return PLANE_CTL_TILED_X;
	case I915_FORMAT_MOD_Y_TILED:
		return PLANE_CTL_TILED_Y;
	case I915_FORMAT_MOD_Yf_TILED:
		return PLANE_CTL_TILED_YF;
	default:
		MISSING_CASE(fb_modifier);
	}

	return 0;
}

u32 skl_plane_ctl_rotation(unsigned int rotation)
{
	switch (rotation) {
	case BIT(DRM_ROTATE_0):
		break;
	/*
	 * DRM_ROTATE_ is counter clockwise to stay compatible with Xrandr
	 * while i915 HW rotation is clockwise, thats why this swapping.
	 */
	case BIT(DRM_ROTATE_90):
		return PLANE_CTL_ROTATE_270;
	case BIT(DRM_ROTATE_180):
		return PLANE_CTL_ROTATE_180;
	case BIT(DRM_ROTATE_270):
		return PLANE_CTL_ROTATE_90;
	default:
		MISSING_CASE(rotation);
	}

	return 0;
}

static void skylake_update_primary_plane(struct drm_crtc *crtc,
					 struct drm_framebuffer *fb,
					 int x, int y)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *plane = crtc->primary;
	bool visible = to_intel_plane_state(plane->state)->visible;
	struct drm_i915_gem_object *obj;
	int pipe = intel_crtc->pipe;
	u32 plane_ctl, stride_div, stride;
	u32 tile_height, plane_offset, plane_size;
	unsigned int rotation;
	int x_offset, y_offset;
	u32 surf_addr;
	struct intel_crtc_state *crtc_state = intel_crtc->config;
	struct intel_plane_state *plane_state;
	int src_x = 0, src_y = 0, src_w = 0, src_h = 0;
	int dst_x = 0, dst_y = 0, dst_w = 0, dst_h = 0;
	int scaler_id = -1;

	plane_state = to_intel_plane_state(plane->state);

	if (!visible || !fb) {
		I915_WRITE(PLANE_CTL(pipe, 0), 0);
		I915_WRITE(PLANE_SURF(pipe, 0), 0);
		POSTING_READ(PLANE_CTL(pipe, 0));
		return;
	}

	plane_ctl = PLANE_CTL_ENABLE |
		    PLANE_CTL_PIPE_GAMMA_ENABLE |
		    PLANE_CTL_PIPE_CSC_ENABLE;

	plane_ctl |= skl_plane_ctl_format(fb->pixel_format);
	plane_ctl |= skl_plane_ctl_tiling(fb->modifier[0]);
	plane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;

	rotation = plane->state->rotation;
	plane_ctl |= skl_plane_ctl_rotation(rotation);

	obj = intel_fb_obj(fb);
	stride_div = intel_fb_stride_alignment(dev, fb->modifier[0],
					       fb->pixel_format);
	surf_addr = intel_plane_obj_offset(to_intel_plane(plane), obj, 0);

	WARN_ON(drm_rect_width(&plane_state->src) == 0);

	scaler_id = plane_state->scaler_id;
	src_x = plane_state->src.x1 >> 16;
	src_y = plane_state->src.y1 >> 16;
	src_w = drm_rect_width(&plane_state->src) >> 16;
	src_h = drm_rect_height(&plane_state->src) >> 16;
	dst_x = plane_state->dst.x1;
	dst_y = plane_state->dst.y1;
	dst_w = drm_rect_width(&plane_state->dst);
	dst_h = drm_rect_height(&plane_state->dst);

	WARN_ON(x != src_x || y != src_y);

	if (intel_rotation_90_or_270(rotation)) {
		/* stride = Surface height in tiles */
		tile_height = intel_tile_height(dev, fb->pixel_format,
						fb->modifier[0], 0);
		stride = DIV_ROUND_UP(fb->height, tile_height);
		x_offset = stride * tile_height - y - src_h;
		y_offset = x;
		plane_size = (src_w - 1) << 16 | (src_h - 1);
	} else {
		stride = fb->pitches[0] / stride_div;
		x_offset = x;
		y_offset = y;
		plane_size = (src_h - 1) << 16 | (src_w - 1);
	}
	plane_offset = y_offset << 16 | x_offset;

	intel_crtc->adjusted_x = x_offset;
	intel_crtc->adjusted_y = y_offset;

	I915_WRITE(PLANE_CTL(pipe, 0), plane_ctl);
	I915_WRITE(PLANE_OFFSET(pipe, 0), plane_offset);
	I915_WRITE(PLANE_SIZE(pipe, 0), plane_size);
	I915_WRITE(PLANE_STRIDE(pipe, 0), stride);

	if (scaler_id >= 0) {
		uint32_t ps_ctrl = 0;

		WARN_ON(!dst_w || !dst_h);
		ps_ctrl = PS_SCALER_EN | PS_PLANE_SEL(0) |
			crtc_state->scaler_state.scalers[scaler_id].mode;
		I915_WRITE(SKL_PS_CTRL(pipe, scaler_id), ps_ctrl);
		I915_WRITE(SKL_PS_PWR_GATE(pipe, scaler_id), 0);
		I915_WRITE(SKL_PS_WIN_POS(pipe, scaler_id), (dst_x << 16) | dst_y);
		I915_WRITE(SKL_PS_WIN_SZ(pipe, scaler_id), (dst_w << 16) | dst_h);
		I915_WRITE(PLANE_POS(pipe, 0), 0);
	} else {
		I915_WRITE(PLANE_POS(pipe, 0), (dst_y << 16) | dst_x);
	}

	I915_WRITE(PLANE_SURF(pipe, 0), surf_addr);

	POSTING_READ(PLANE_SURF(pipe, 0));
}

/* Assume fb object is pinned & idle & fenced and just update base pointers */
static int
intel_pipe_set_base_atomic(struct drm_crtc *crtc, struct drm_framebuffer *fb,
			   int x, int y, enum mode_set_atomic state)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev_priv->fbc.disable_fbc)
		dev_priv->fbc.disable_fbc(dev_priv);

	dev_priv->display.update_primary_plane(crtc, fb, x, y);

	return 0;
}

static void intel_complete_page_flips(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	for_each_crtc(dev, crtc) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
		enum plane plane = intel_crtc->plane;

		intel_prepare_page_flip(dev, plane);
		intel_finish_page_flip_plane(dev, plane);
	}
}

static void intel_update_primary_planes(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	for_each_crtc(dev, crtc) {
		struct intel_plane *plane = to_intel_plane(crtc->primary);
		struct intel_plane_state *plane_state;

		drm_modeset_lock_crtc(crtc, &plane->base);

		plane_state = to_intel_plane_state(plane->base.state);

		if (plane_state->base.fb)
			plane->commit_plane(&plane->base, plane_state);

		drm_modeset_unlock_crtc(crtc);
	}
}

void intel_prepare_reset(struct drm_device *dev)
{
	/* no reset support for gen2 */
	if (IS_GEN2(dev))
		return;

	/* reset doesn't touch the display */
	if (INTEL_INFO(dev)->gen >= 5 || IS_G4X(dev))
		return;

	drm_modeset_lock_all(dev);
	/*
	 * Disabling the crtcs gracefully seems nicer. Also the
	 * g33 docs say we should at least disable all the planes.
	 */
	intel_display_suspend(dev);
}

void intel_finish_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = to_i915(dev);

	/*
	 * Flips in the rings will be nuked by the reset,
	 * so complete all pending flips so that user space
	 * will get its events and not get stuck.
	 */
	intel_complete_page_flips(dev);

	/* no reset support for gen2 */
	if (IS_GEN2(dev))
		return;

	/* reset doesn't touch the display */
	if (INTEL_INFO(dev)->gen >= 5 || IS_G4X(dev)) {
		/*
		 * Flips in the rings have been nuked by the reset,
		 * so update the base address of all primary
		 * planes to the the last fb to make sure we're
		 * showing the correct fb after a reset.
		 *
		 * FIXME: Atomic will make this obsolete since we won't schedule
		 * CS-based flips (which might get lost in gpu resets) any more.
		 */
		intel_update_primary_planes(dev);
		return;
	}

	/*
	 * The display has been reset as well,
	 * so need a full re-initialization.
	 */
	intel_runtime_pm_disable_interrupts(dev_priv);
	intel_runtime_pm_enable_interrupts(dev_priv);

	intel_modeset_init_hw(dev);

	spin_lock_irq(&dev_priv->irq_lock);
	if (dev_priv->display.hpd_irq_setup)
		dev_priv->display.hpd_irq_setup(dev);
	spin_unlock_irq(&dev_priv->irq_lock);

	intel_display_resume(dev);

	intel_hpd_init(dev_priv);

	drm_modeset_unlock_all(dev);
}

static void
intel_finish_fb(struct drm_framebuffer *old_fb)
{
	struct drm_i915_gem_object *obj = intel_fb_obj(old_fb);
	struct drm_i915_private *dev_priv = to_i915(obj->base.dev);
	bool was_interruptible = dev_priv->mm.interruptible;
	int ret;

	/* Big Hammer, we also need to ensure that any pending
	 * MI_WAIT_FOR_EVENT inside a user batch buffer on the
	 * current scanout is retired before unpinning the old
	 * framebuffer. Note that we rely on userspace rendering
	 * into the buffer attached to the pipe they are waiting
	 * on. If not, userspace generates a GPU hang with IPEHR
	 * point to the MI_WAIT_FOR_EVENT.
	 *
	 * This should only fail upon a hung GPU, in which case we
	 * can safely continue.
	 */
	dev_priv->mm.interruptible = false;
	ret = i915_gem_object_wait_rendering(obj, true);
	dev_priv->mm.interruptible = was_interruptible;

	WARN_ON(ret);
}

static bool intel_crtc_has_pending_flip(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	bool pending;

	if (i915_reset_in_progress(&dev_priv->gpu_error) ||
	    intel_crtc->reset_counter != atomic_read(&dev_priv->gpu_error.reset_counter))
		return false;

	spin_lock_irq(&dev->event_lock);
	pending = to_intel_crtc(crtc)->unpin_work != NULL;
	spin_unlock_irq(&dev->event_lock);

	return pending;
}

static void intel_update_pipe_config(struct intel_crtc *crtc,
				     struct intel_crtc_state *old_crtc_state)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc_state *pipe_config =
		to_intel_crtc_state(crtc->base.state);

	/* drm_atomic_helper_update_legacy_modeset_state might not be called. */
	crtc->base.mode = crtc->base.state->mode;

	DRM_DEBUG_KMS("Updating pipe size %ix%i -> %ix%i\n",
		      old_crtc_state->pipe_src_w, old_crtc_state->pipe_src_h,
		      pipe_config->pipe_src_w, pipe_config->pipe_src_h);

	if (HAS_DDI(dev))
		intel_set_pipe_csc(&crtc->base);

	/*
	 * Update pipe size and adjust fitter if needed: the reason for this is
	 * that in compute_mode_changes we check the native mode (not the pfit
	 * mode) to see if we can flip rather than do a full mode set. In the
	 * fastboot case, we'll flip, but if we don't update the pipesrc and
	 * pfit state, we'll end up with a big fb scanned out into the wrong
	 * sized surface.
	 */

	I915_WRITE(PIPESRC(crtc->pipe),
		   ((pipe_config->pipe_src_w - 1) << 16) |
		   (pipe_config->pipe_src_h - 1));

	/* on skylake this is done by detaching scalers */
	if (INTEL_INFO(dev)->gen >= 9) {
		skl_detach_scalers(crtc);

		if (pipe_config->pch_pfit.enabled)
			skylake_pfit_enable(crtc);
	} else if (HAS_PCH_SPLIT(dev)) {
		if (pipe_config->pch_pfit.enabled)
			ironlake_pfit_enable(crtc);
		else if (old_crtc_state->pch_pfit.enabled)
			ironlake_pfit_disable(crtc, true);
	}
}

static void intel_fdi_normal_train(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp;

	/* enable normal train */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	if (IS_IVYBRIDGE(dev)) {
		temp &= ~FDI_LINK_TRAIN_NONE_IVB;
		temp |= FDI_LINK_TRAIN_NONE_IVB | FDI_TX_ENHANCE_FRAME_ENABLE;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_NONE | FDI_TX_ENHANCE_FRAME_ENABLE;
	}
	I915_WRITE(reg, temp);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	if (HAS_PCH_CPT(dev)) {
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_NORMAL_CPT;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_NONE;
	}
	I915_WRITE(reg, temp | FDI_RX_ENHANCE_FRAME_ENABLE);

	/* wait one idle pattern time */
	POSTING_READ(reg);
	udelay(1000);

	/* IVB wants error correction enabled */
	if (IS_IVYBRIDGE(dev))
		I915_WRITE(reg, I915_READ(reg) | FDI_FS_ERRC_ENABLE |
			   FDI_FE_ERRC_ENABLE);
}

/* The FDI link training functions for ILK/Ibexpeak. */
static void ironlake_fdi_link_train(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp, tries;

	/* FDI needs bits from pipe first */
	assert_pipe_enabled(dev_priv, pipe);

	/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
	   for train result */
	reg = FDI_RX_IMR(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_RX_SYMBOL_LOCK;
	temp &= ~FDI_RX_BIT_LOCK;
	I915_WRITE(reg, temp);
	I915_READ(reg);
	udelay(150);

	/* enable CPU FDI TX and PCH FDI RX */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_DP_PORT_WIDTH_MASK;
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config->fdi_lanes);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	I915_WRITE(reg, temp | FDI_TX_ENABLE);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	I915_WRITE(reg, temp | FDI_RX_ENABLE);

	POSTING_READ(reg);
	udelay(150);

	/* Ironlake workaround, enable clock pointer after FDI enable*/
	I915_WRITE(FDI_RX_CHICKEN(pipe), FDI_RX_PHASE_SYNC_POINTER_OVR);
	I915_WRITE(FDI_RX_CHICKEN(pipe), FDI_RX_PHASE_SYNC_POINTER_OVR |
		   FDI_RX_PHASE_SYNC_POINTER_EN);

	reg = FDI_RX_IIR(pipe);
	for (tries = 0; tries < 5; tries++) {
		temp = I915_READ(reg);
		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);

		if ((temp & FDI_RX_BIT_LOCK)) {
			DRM_DEBUG_KMS("FDI train 1 done.\n");
			I915_WRITE(reg, temp | FDI_RX_BIT_LOCK);
			break;
		}
	}
	if (tries == 5)
		DRM_ERROR("FDI train 1 fail!\n");

	/* Train 2 */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_2;
	I915_WRITE(reg, temp);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_2;
	I915_WRITE(reg, temp);

	POSTING_READ(reg);
	udelay(150);

	reg = FDI_RX_IIR(pipe);
	for (tries = 0; tries < 5; tries++) {
		temp = I915_READ(reg);
		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);

		if (temp & FDI_RX_SYMBOL_LOCK) {
			I915_WRITE(reg, temp | FDI_RX_SYMBOL_LOCK);
			DRM_DEBUG_KMS("FDI train 2 done.\n");
			break;
		}
	}
	if (tries == 5)
		DRM_ERROR("FDI train 2 fail!\n");

	DRM_DEBUG_KMS("FDI train done\n");

}

static const int snb_b_fdi_train_param[] = {
	FDI_LINK_TRAIN_400MV_0DB_SNB_B,
	FDI_LINK_TRAIN_400MV_6DB_SNB_B,
	FDI_LINK_TRAIN_600MV_3_5DB_SNB_B,
	FDI_LINK_TRAIN_800MV_0DB_SNB_B,
};

/* The FDI link training functions for SNB/Cougarpoint. */
static void gen6_fdi_link_train(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp, i, retry;

	/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
	   for train result */
	reg = FDI_RX_IMR(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_RX_SYMBOL_LOCK;
	temp &= ~FDI_RX_BIT_LOCK;
	I915_WRITE(reg, temp);

	POSTING_READ(reg);
	udelay(150);

	/* enable CPU FDI TX and PCH FDI RX */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_DP_PORT_WIDTH_MASK;
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config->fdi_lanes);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	/* SNB-B */
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	I915_WRITE(reg, temp | FDI_TX_ENABLE);

	I915_WRITE(FDI_RX_MISC(pipe),
		   FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	if (HAS_PCH_CPT(dev)) {
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_PATTERN_1;
	}
	I915_WRITE(reg, temp | FDI_RX_ENABLE);

	POSTING_READ(reg);
	udelay(150);

	for (i = 0; i < 4; i++) {
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[i];
		I915_WRITE(reg, temp);

		POSTING_READ(reg);
		udelay(500);

		for (retry = 0; retry < 5; retry++) {
			reg = FDI_RX_IIR(pipe);
			temp = I915_READ(reg);
			DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
			if (temp & FDI_RX_BIT_LOCK) {
				I915_WRITE(reg, temp | FDI_RX_BIT_LOCK);
				DRM_DEBUG_KMS("FDI train 1 done.\n");
				break;
			}
			udelay(50);
		}
		if (retry < 5)
			break;
	}
	if (i == 4)
		DRM_ERROR("FDI train 1 fail!\n");

	/* Train 2 */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_2;
	if (IS_GEN6(dev)) {
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		/* SNB-B */
		temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	}
	I915_WRITE(reg, temp);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	if (HAS_PCH_CPT(dev)) {
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_PATTERN_2_CPT;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_PATTERN_2;
	}
	I915_WRITE(reg, temp);

	POSTING_READ(reg);
	udelay(150);

	for (i = 0; i < 4; i++) {
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[i];
		I915_WRITE(reg, temp);

		POSTING_READ(reg);
		udelay(500);

		for (retry = 0; retry < 5; retry++) {
			reg = FDI_RX_IIR(pipe);
			temp = I915_READ(reg);
			DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
			if (temp & FDI_RX_SYMBOL_LOCK) {
				I915_WRITE(reg, temp | FDI_RX_SYMBOL_LOCK);
				DRM_DEBUG_KMS("FDI train 2 done.\n");
				break;
			}
			udelay(50);
		}
		if (retry < 5)
			break;
	}
	if (i == 4)
		DRM_ERROR("FDI train 2 fail!\n");

	DRM_DEBUG_KMS("FDI train done.\n");
}

/* Manual link training for Ivy Bridge A0 parts */
static void ivb_manual_fdi_link_train(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp, i, j;

	/* Train 1: umask FDI RX Interrupt symbol_lock and bit_lock bit
	   for train result */
	reg = FDI_RX_IMR(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_RX_SYMBOL_LOCK;
	temp &= ~FDI_RX_BIT_LOCK;
	I915_WRITE(reg, temp);

	POSTING_READ(reg);
	udelay(150);

	DRM_DEBUG_KMS("FDI_RX_IIR before link train 0x%x\n",
		      I915_READ(FDI_RX_IIR(pipe)));

	/* Try each vswing and preemphasis setting twice before moving on */
	for (j = 0; j < ARRAY_SIZE(snb_b_fdi_train_param) * 2; j++) {
		/* disable first in case we need to retry */
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~(FDI_LINK_TRAIN_AUTO | FDI_LINK_TRAIN_NONE_IVB);
		temp &= ~FDI_TX_ENABLE;
		I915_WRITE(reg, temp);

		reg = FDI_RX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_LINK_TRAIN_AUTO;
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp &= ~FDI_RX_ENABLE;
		I915_WRITE(reg, temp);

		/* enable CPU FDI TX and PCH FDI RX */
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_DP_PORT_WIDTH_MASK;
		temp |= FDI_DP_PORT_WIDTH(intel_crtc->config->fdi_lanes);
		temp |= FDI_LINK_TRAIN_PATTERN_1_IVB;
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[j/2];
		temp |= FDI_COMPOSITE_SYNC;
		I915_WRITE(reg, temp | FDI_TX_ENABLE);

		I915_WRITE(FDI_RX_MISC(pipe),
			   FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);

		reg = FDI_RX_CTL(pipe);
		temp = I915_READ(reg);
		temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
		temp |= FDI_COMPOSITE_SYNC;
		I915_WRITE(reg, temp | FDI_RX_ENABLE);

		POSTING_READ(reg);
		udelay(1); /* should be 0.5us */

		for (i = 0; i < 4; i++) {
			reg = FDI_RX_IIR(pipe);
			temp = I915_READ(reg);
			DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);

			if (temp & FDI_RX_BIT_LOCK ||
			    (I915_READ(reg) & FDI_RX_BIT_LOCK)) {
				I915_WRITE(reg, temp | FDI_RX_BIT_LOCK);
				DRM_DEBUG_KMS("FDI train 1 done, level %i.\n",
					      i);
				break;
			}
			udelay(1); /* should be 0.5us */
		}
		if (i == 4) {
			DRM_DEBUG_KMS("FDI train 1 fail on vswing %d\n", j / 2);
			continue;
		}

		/* Train 2 */
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_LINK_TRAIN_NONE_IVB;
		temp |= FDI_LINK_TRAIN_PATTERN_2_IVB;
		I915_WRITE(reg, temp);

		reg = FDI_RX_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_PATTERN_2_CPT;
		I915_WRITE(reg, temp);

		POSTING_READ(reg);
		udelay(2); /* should be 1.5us */

		for (i = 0; i < 4; i++) {
			reg = FDI_RX_IIR(pipe);
			temp = I915_READ(reg);
			DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);

			if (temp & FDI_RX_SYMBOL_LOCK ||
			    (I915_READ(reg) & FDI_RX_SYMBOL_LOCK)) {
				I915_WRITE(reg, temp | FDI_RX_SYMBOL_LOCK);
				DRM_DEBUG_KMS("FDI train 2 done, level %i.\n",
					      i);
				goto train_done;
			}
			udelay(2); /* should be 1.5us */
		}
		if (i == 4)
			DRM_DEBUG_KMS("FDI train 2 fail on vswing %d\n", j / 2);
	}

train_done:
	DRM_DEBUG_KMS("FDI train done.\n");
}

static void ironlake_fdi_pll_enable(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = intel_crtc->pipe;
	u32 reg, temp;


	/* enable PCH FDI RX PLL, wait warmup plus DMI latency */
	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~(FDI_DP_PORT_WIDTH_MASK | (0x7 << 16));
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config->fdi_lanes);
	temp |= (I915_READ(PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;
	I915_WRITE(reg, temp | FDI_RX_PLL_ENABLE);

	POSTING_READ(reg);
	udelay(200);

	/* Switch from Rawclk to PCDclk */
	temp = I915_READ(reg);
	I915_WRITE(reg, temp | FDI_PCDCLK);

	POSTING_READ(reg);
	udelay(200);

	/* Enable CPU FDI TX PLL, always on for Ironlake */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	if ((temp & FDI_TX_PLL_ENABLE) == 0) {
		I915_WRITE(reg, temp | FDI_TX_PLL_ENABLE);

		POSTING_READ(reg);
		udelay(100);
	}
}

static void ironlake_fdi_pll_disable(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = intel_crtc->pipe;
	u32 reg, temp;

	/* Switch from PCDclk to Rawclk */
	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	I915_WRITE(reg, temp & ~FDI_PCDCLK);

	/* Disable CPU FDI TX PLL */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	I915_WRITE(reg, temp & ~FDI_TX_PLL_ENABLE);

	POSTING_READ(reg);
	udelay(100);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	I915_WRITE(reg, temp & ~FDI_RX_PLL_ENABLE);

	/* Wait for the clocks to turn off. */
	POSTING_READ(reg);
	udelay(100);
}

static void ironlake_fdi_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp;

	/* disable CPU FDI tx and PCH FDI rx */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	I915_WRITE(reg, temp & ~FDI_TX_ENABLE);
	POSTING_READ(reg);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~(0x7 << 16);
	temp |= (I915_READ(PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;
	I915_WRITE(reg, temp & ~FDI_RX_ENABLE);

	POSTING_READ(reg);
	udelay(100);

	/* Ironlake workaround, disable clock pointer after downing FDI */
	if (HAS_PCH_IBX(dev))
		I915_WRITE(FDI_RX_CHICKEN(pipe), FDI_RX_PHASE_SYNC_POINTER_OVR);

	/* still set train pattern 1 */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE;
	temp |= FDI_LINK_TRAIN_PATTERN_1;
	I915_WRITE(reg, temp);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	if (HAS_PCH_CPT(dev)) {
		temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
		temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
	} else {
		temp &= ~FDI_LINK_TRAIN_NONE;
		temp |= FDI_LINK_TRAIN_PATTERN_1;
	}
	/* BPC in FDI rx is consistent with that in PIPECONF */
	temp &= ~(0x07 << 16);
	temp |= (I915_READ(PIPECONF(pipe)) & PIPECONF_BPC_MASK) << 11;
	I915_WRITE(reg, temp);

	POSTING_READ(reg);
	udelay(100);
}

bool intel_has_pending_fb_unpin(struct drm_device *dev)
{
	struct intel_crtc *crtc;

	/* Note that we don't need to be called with mode_config.lock here
	 * as our list of CRTC objects is static for the lifetime of the
	 * device and so cannot disappear as we iterate. Similarly, we can
	 * happily treat the predicates as racy, atomic checks as userspace
	 * cannot claim and pin a new fb without at least acquring the
	 * struct_mutex and so serialising with us.
	 */
	for_each_intel_crtc(dev, crtc) {
		if (atomic_read(&crtc->unpin_work_count) == 0)
			continue;

		if (crtc->unpin_work)
			intel_wait_for_vblank(dev, crtc->pipe);

		return true;
	}

	return false;
}

static void page_flip_completed(struct intel_crtc *intel_crtc)
{
	struct drm_i915_private *dev_priv = to_i915(intel_crtc->base.dev);
	struct intel_unpin_work *work = intel_crtc->unpin_work;

	/* ensure that the unpin work is consistent wrt ->pending. */
	smp_rmb();
	intel_crtc->unpin_work = NULL;

	if (work->event)
		drm_send_vblank_event(intel_crtc->base.dev,
				      intel_crtc->pipe,
				      work->event);

	drm_crtc_vblank_put(&intel_crtc->base);

	wake_up_all(&dev_priv->pending_flip_queue);
	trace_i915_flip_complete(intel_crtc->plane,
				 work->pending_flip_obj);

	queue_work(dev_priv->wq, &work->work);
}

void intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	WARN_ON(waitqueue_active(&dev_priv->pending_flip_queue));
	if (WARN_ON(wait_event_timeout(dev_priv->pending_flip_queue,
				       !intel_crtc_has_pending_flip(crtc),
				       60*HZ) == 0)) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

		spin_lock_irq(&dev->event_lock);
		if (intel_crtc->unpin_work) {
			WARN_ONCE(1, "Removing stuck page flip\n");
			page_flip_completed(intel_crtc);
		}
		spin_unlock_irq(&dev->event_lock);
	}

	if (crtc->primary->fb) {
		mutex_lock(&dev->struct_mutex);
		intel_finish_fb(crtc->primary->fb);
		mutex_unlock(&dev->struct_mutex);
	}
}

/* Program iCLKIP clock to the desired frequency */
static void lpt_program_iclkip(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int clock = to_intel_crtc(crtc)->config->base.adjusted_mode.crtc_clock;
	u32 divsel, phaseinc, auxdiv, phasedir = 0;
	u32 temp;

	mutex_lock(&dev_priv->sb_lock);

	/* It is necessary to ungate the pixclk gate prior to programming
	 * the divisors, and gate it back when it is done.
	 */
	I915_WRITE(PIXCLK_GATE, PIXCLK_GATE_GATE);

	/* Disable SSCCTL */
	intel_sbi_write(dev_priv, SBI_SSCCTL6,
			intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK) |
				SBI_SSCCTL_DISABLE,
			SBI_ICLK);

	/* 20MHz is a corner case which is out of range for the 7-bit divisor */
	if (clock == 20000) {
		auxdiv = 1;
		divsel = 0x41;
		phaseinc = 0x20;
	} else {
		/* The iCLK virtual clock root frequency is in MHz,
		 * but the adjusted_mode->crtc_clock in in KHz. To get the
		 * divisors, it is necessary to divide one by another, so we
		 * convert the virtual clock precision to KHz here for higher
		 * precision.
		 */
		u32 iclk_virtual_root_freq = 172800 * 1000;
		u32 iclk_pi_range = 64;
		u32 desired_divisor, msb_divisor_value, pi_value;

		desired_divisor = (iclk_virtual_root_freq / clock);
		msb_divisor_value = desired_divisor / iclk_pi_range;
		pi_value = desired_divisor % iclk_pi_range;

		auxdiv = 0;
		divsel = msb_divisor_value - 2;
		phaseinc = pi_value;
	}

	/* This should not happen with any sane values */
	WARN_ON(SBI_SSCDIVINTPHASE_DIVSEL(divsel) &
		~SBI_SSCDIVINTPHASE_DIVSEL_MASK);
	WARN_ON(SBI_SSCDIVINTPHASE_DIR(phasedir) &
		~SBI_SSCDIVINTPHASE_INCVAL_MASK);

	DRM_DEBUG_KMS("iCLKIP clock: found settings for %dKHz refresh rate: auxdiv=%x, divsel=%x, phasedir=%x, phaseinc=%x\n",
			clock,
			auxdiv,
			divsel,
			phasedir,
			phaseinc);

	/* Program SSCDIVINTPHASE6 */
	temp = intel_sbi_read(dev_priv, SBI_SSCDIVINTPHASE6, SBI_ICLK);
	temp &= ~SBI_SSCDIVINTPHASE_DIVSEL_MASK;
	temp |= SBI_SSCDIVINTPHASE_DIVSEL(divsel);
	temp &= ~SBI_SSCDIVINTPHASE_INCVAL_MASK;
	temp |= SBI_SSCDIVINTPHASE_INCVAL(phaseinc);
	temp |= SBI_SSCDIVINTPHASE_DIR(phasedir);
	temp |= SBI_SSCDIVINTPHASE_PROPAGATE;
	intel_sbi_write(dev_priv, SBI_SSCDIVINTPHASE6, temp, SBI_ICLK);

	/* Program SSCAUXDIV */
	temp = intel_sbi_read(dev_priv, SBI_SSCAUXDIV6, SBI_ICLK);
	temp &= ~SBI_SSCAUXDIV_FINALDIV2SEL(1);
	temp |= SBI_SSCAUXDIV_FINALDIV2SEL(auxdiv);
	intel_sbi_write(dev_priv, SBI_SSCAUXDIV6, temp, SBI_ICLK);

	/* Enable modulator and associated divider */
	temp = intel_sbi_read(dev_priv, SBI_SSCCTL6, SBI_ICLK);
	temp &= ~SBI_SSCCTL_DISABLE;
	intel_sbi_write(dev_priv, SBI_SSCCTL6, temp, SBI_ICLK);

	/* Wait for initialization time */
	udelay(24);

	I915_WRITE(PIXCLK_GATE, PIXCLK_GATE_UNGATE);

	mutex_unlock(&dev_priv->sb_lock);
}

static void ironlake_pch_transcoder_set_timings(struct intel_crtc *crtc,
						enum pipe pch_transcoder)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum transcoder cpu_transcoder = crtc->config->cpu_transcoder;

	I915_WRITE(PCH_TRANS_HTOTAL(pch_transcoder),
		   I915_READ(HTOTAL(cpu_transcoder)));
	I915_WRITE(PCH_TRANS_HBLANK(pch_transcoder),
		   I915_READ(HBLANK(cpu_transcoder)));
	I915_WRITE(PCH_TRANS_HSYNC(pch_transcoder),
		   I915_READ(HSYNC(cpu_transcoder)));

	I915_WRITE(PCH_TRANS_VTOTAL(pch_transcoder),
		   I915_READ(VTOTAL(cpu_transcoder)));
	I915_WRITE(PCH_TRANS_VBLANK(pch_transcoder),
		   I915_READ(VBLANK(cpu_transcoder)));
	I915_WRITE(PCH_TRANS_VSYNC(pch_transcoder),
		   I915_READ(VSYNC(cpu_transcoder)));
	I915_WRITE(PCH_TRANS_VSYNCSHIFT(pch_transcoder),
		   I915_READ(VSYNCSHIFT(cpu_transcoder)));
}

static void cpt_set_fdi_bc_bifurcation(struct drm_device *dev, bool enable)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t temp;

	temp = I915_READ(SOUTH_CHICKEN1);
	if (!!(temp & FDI_BC_BIFURCATION_SELECT) == enable)
		return;

	WARN_ON(I915_READ(FDI_RX_CTL(PIPE_B)) & FDI_RX_ENABLE);
	WARN_ON(I915_READ(FDI_RX_CTL(PIPE_C)) & FDI_RX_ENABLE);

	temp &= ~FDI_BC_BIFURCATION_SELECT;
	if (enable)
		temp |= FDI_BC_BIFURCATION_SELECT;

	DRM_DEBUG_KMS("%sabling fdi C rx\n", enable ? "en" : "dis");
	I915_WRITE(SOUTH_CHICKEN1, temp);
	POSTING_READ(SOUTH_CHICKEN1);
}

static void ivybridge_update_fdi_bc_bifurcation(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;

	switch (intel_crtc->pipe) {
	case PIPE_A:
		break;
	case PIPE_B:
		if (intel_crtc->config->fdi_lanes > 2)
			cpt_set_fdi_bc_bifurcation(dev, false);
		else
			cpt_set_fdi_bc_bifurcation(dev, true);

		break;
	case PIPE_C:
		cpt_set_fdi_bc_bifurcation(dev, true);

		break;
	default:
		BUG();
	}
}

/*
 * Enable PCH resources required for PCH ports:
 *   - PCH PLLs
 *   - FDI training & RX/TX
 *   - update transcoder timings
 *   - DP transcoding bits
 *   - transcoder
 */
static void ironlake_pch_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 reg, temp;

	assert_pch_transcoder_disabled(dev_priv, pipe);

	if (IS_IVYBRIDGE(dev))
		ivybridge_update_fdi_bc_bifurcation(intel_crtc);

	/* Write the TU size bits before fdi link training, so that error
	 * detection works. */
	I915_WRITE(FDI_RX_TUSIZE1(pipe),
		   I915_READ(PIPE_DATA_M1(pipe)) & TU_SIZE_MASK);

	/* For PCH output, training FDI link */
	dev_priv->display.fdi_link_train(crtc);

	/* We need to program the right clock selection before writing the pixel
	 * mutliplier into the DPLL. */
	if (HAS_PCH_CPT(dev)) {
		u32 sel;

		temp = I915_READ(PCH_DPLL_SEL);
		temp |= TRANS_DPLL_ENABLE(pipe);
		sel = TRANS_DPLLB_SEL(pipe);
		if (intel_crtc->config->shared_dpll == DPLL_ID_PCH_PLL_B)
			temp |= sel;
		else
			temp &= ~sel;
		I915_WRITE(PCH_DPLL_SEL, temp);
	}

	/* XXX: pch pll's can be enabled any time before we enable the PCH
	 * transcoder, and we actually should do this to not upset any PCH
	 * transcoder that already use the clock when we share it.
	 *
	 * Note that enable_shared_dpll tries to do the right thing, but
	 * get_shared_dpll unconditionally resets the pll - we need that to have
	 * the right LVDS enable sequence. */
	intel_enable_shared_dpll(intel_crtc);

	/* set transcoder timing, panel must allow it */
	assert_panel_unlocked(dev_priv, pipe);
	ironlake_pch_transcoder_set_timings(intel_crtc, pipe);

	intel_fdi_normal_train(crtc);

	/* For PCH DP, enable TRANS_DP_CTL */
	if (HAS_PCH_CPT(dev) && intel_crtc->config->has_dp_encoder) {
		u32 bpc = (I915_READ(PIPECONF(pipe)) & PIPECONF_BPC_MASK) >> 5;
		reg = TRANS_DP_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~(TRANS_DP_PORT_SEL_MASK |
			  TRANS_DP_SYNC_MASK |
			  TRANS_DP_BPC_MASK);
		temp |= TRANS_DP_OUTPUT_ENABLE;
		temp |= bpc << 9; /* same format but at 11:9 */

		if (crtc->mode.flags & DRM_MODE_FLAG_PHSYNC)
			temp |= TRANS_DP_HSYNC_ACTIVE_HIGH;
		if (crtc->mode.flags & DRM_MODE_FLAG_PVSYNC)
			temp |= TRANS_DP_VSYNC_ACTIVE_HIGH;

		switch (intel_trans_dp_port_sel(crtc)) {
		case PCH_DP_B:
			temp |= TRANS_DP_PORT_SEL_B;
			break;
		case PCH_DP_C:
			temp |= TRANS_DP_PORT_SEL_C;
			break;
		case PCH_DP_D:
			temp |= TRANS_DP_PORT_SEL_D;
			break;
		default:
			BUG();
		}

		I915_WRITE(reg, temp);
	}

	ironlake_enable_pch_transcoder(dev_priv, pipe);
}

static void lpt_pch_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;

	assert_pch_transcoder_disabled(dev_priv, TRANSCODER_A);

	lpt_program_iclkip(crtc);

	/* Set transcoder timing. */
	ironlake_pch_transcoder_set_timings(intel_crtc, PIPE_A);

	lpt_enable_pch_transcoder(dev_priv, cpu_transcoder);
}

struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc,
						struct intel_crtc_state *crtc_state)
{
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
	struct intel_shared_dpll *pll;
	struct intel_shared_dpll_config *shared_dpll;
	enum intel_dpll_id i;
	int max = dev_priv->num_shared_dpll;

	shared_dpll = intel_atomic_get_shared_dpll_state(crtc_state->base.state);

	if (HAS_PCH_IBX(dev_priv->dev)) {
		/* Ironlake PCH has a fixed PLL->PCH pipe mapping. */
		i = (enum intel_dpll_id) crtc->pipe;
		pll = &dev_priv->shared_dplls[i];

		DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
			      crtc->base.base.id, pll->name);

		WARN_ON(shared_dpll[i].crtc_mask);

		goto found;
	}

	if (IS_BROXTON(dev_priv->dev)) {
		/* PLL is attached to port in bxt */
		struct intel_encoder *encoder;
		struct intel_digital_port *intel_dig_port;

		encoder = intel_ddi_get_crtc_new_encoder(crtc_state);
		if (WARN_ON(!encoder))
			return NULL;

		intel_dig_port = enc_to_dig_port(&encoder->base);
		/* 1:1 mapping between ports and PLLs */
		i = (enum intel_dpll_id)intel_dig_port->port;
		pll = &dev_priv->shared_dplls[i];
		DRM_DEBUG_KMS("CRTC:%d using pre-allocated %s\n",
			crtc->base.base.id, pll->name);
		WARN_ON(shared_dpll[i].crtc_mask);

		goto found;
	} else if (INTEL_INFO(dev_priv)->gen < 9 && HAS_DDI(dev_priv))
		/* Do not consider SPLL */
		max = 2;

	for (i = 0; i < max; i++) {
		pll = &dev_priv->shared_dplls[i];

		/* Only want to check enabled timings first */
		if (shared_dpll[i].crtc_mask == 0)
			continue;

		if (memcmp(&crtc_state->dpll_hw_state,
			   &shared_dpll[i].hw_state,
			   sizeof(crtc_state->dpll_hw_state)) == 0) {
			DRM_DEBUG_KMS("CRTC:%d sharing existing %s (crtc mask 0x%08x, ative %d)\n",
				      crtc->base.base.id, pll->name,
				      shared_dpll[i].crtc_mask,
				      pll->active);
			goto found;
		}
	}

	/* Ok no matching timings, maybe there's a free one? */
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		pll = &dev_priv->shared_dplls[i];
		if (shared_dpll[i].crtc_mask == 0) {
			DRM_DEBUG_KMS("CRTC:%d allocated %s\n",
				      crtc->base.base.id, pll->name);
			goto found;
		}
	}

	return NULL;

found:
	if (shared_dpll[i].crtc_mask == 0)
		shared_dpll[i].hw_state =
			crtc_state->dpll_hw_state;

	crtc_state->shared_dpll = i;
	DRM_DEBUG_DRIVER("using %s for pipe %c\n", pll->name,
			 pipe_name(crtc->pipe));

	shared_dpll[i].crtc_mask |= 1 << crtc->pipe;

	return pll;
}

static void intel_shared_dpll_commit(struct drm_atomic_state *state)
{
	struct drm_i915_private *dev_priv = to_i915(state->dev);
	struct intel_shared_dpll_config *shared_dpll;
	struct intel_shared_dpll *pll;
	enum intel_dpll_id i;

	if (!to_intel_atomic_state(state)->dpll_set)
		return;

	shared_dpll = to_intel_atomic_state(state)->shared_dpll;
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		pll = &dev_priv->shared_dplls[i];
		pll->config = shared_dpll[i];
	}
}

static void cpt_verify_modeset(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int dslreg = PIPEDSL(pipe);
	u32 temp;

	temp = I915_READ(dslreg);
	udelay(500);
	if (wait_for(I915_READ(dslreg) != temp, 5)) {
		if (wait_for(I915_READ(dslreg) != temp, 5))
			DRM_ERROR("mode set failed: pipe %c stuck\n", pipe_name(pipe));
	}
}

static int
skl_update_scaler(struct intel_crtc_state *crtc_state, bool force_detach,
		  unsigned scaler_user, int *scaler_id, unsigned int rotation,
		  int src_w, int src_h, int dst_w, int dst_h)
{
	struct intel_crtc_scaler_state *scaler_state =
		&crtc_state->scaler_state;
#ifdef DRMDEBUG
	struct intel_crtc *intel_crtc =
		to_intel_crtc(crtc_state->base.crtc);
#endif
	int need_scaling;

	need_scaling = intel_rotation_90_or_270(rotation) ?
		(src_h != dst_w || src_w != dst_h):
		(src_w != dst_w || src_h != dst_h);

	/*
	 * if plane is being disabled or scaler is no more required or force detach
	 *  - free scaler binded to this plane/crtc
	 *  - in order to do this, update crtc->scaler_usage
	 *
	 * Here scaler state in crtc_state is set free so that
	 * scaler can be assigned to other user. Actual register
	 * update to free the scaler is done in plane/panel-fit programming.
	 * For this purpose crtc/plane_state->scaler_id isn't reset here.
	 */
	if (force_detach || !need_scaling) {
		if (*scaler_id >= 0) {
			scaler_state->scaler_users &= ~(1 << scaler_user);
			scaler_state->scalers[*scaler_id].in_use = 0;

			DRM_DEBUG_KMS("scaler_user index %u.%u: "
				"Staged freeing scaler id %d scaler_users = 0x%x\n",
				intel_crtc->pipe, scaler_user, *scaler_id,
				scaler_state->scaler_users);
			*scaler_id = -1;
		}
		return 0;
	}

	/* range checks */
	if (src_w < SKL_MIN_SRC_W || src_h < SKL_MIN_SRC_H ||
		dst_w < SKL_MIN_DST_W || dst_h < SKL_MIN_DST_H ||

		src_w > SKL_MAX_SRC_W || src_h > SKL_MAX_SRC_H ||
		dst_w > SKL_MAX_DST_W || dst_h > SKL_MAX_DST_H) {
		DRM_DEBUG_KMS("scaler_user index %u.%u: src %ux%u dst %ux%u "
			"size is out of scaler range\n",
			intel_crtc->pipe, scaler_user, src_w, src_h, dst_w, dst_h);
		return -EINVAL;
	}

	/* mark this plane as a scaler user in crtc_state */
	scaler_state->scaler_users |= (1 << scaler_user);
	DRM_DEBUG_KMS("scaler_user index %u.%u: "
		"staged scaling request for %ux%u->%ux%u scaler_users = 0x%x\n",
		intel_crtc->pipe, scaler_user, src_w, src_h, dst_w, dst_h,
		scaler_state->scaler_users);

	return 0;
}

/**
 * skl_update_scaler_crtc - Stages update to scaler state for a given crtc.
 *
 * @@state: crtc's scaler state
 *
 * Return
 *     0 - scaler_usage updated successfully
 *    error - requested scaling cannot be supported or other error condition
 */
int skl_update_scaler_crtc(struct intel_crtc_state *state)
{
#ifdef DRMDEBUG
	struct intel_crtc *intel_crtc = to_intel_crtc(state->base.crtc);
#endif
	const struct drm_display_mode *adjusted_mode = &state->base.adjusted_mode;

	DRM_DEBUG_KMS("Updating scaler for [CRTC:%i] scaler_user index %u.%u\n",
		      intel_crtc->base.base.id, intel_crtc->pipe, SKL_CRTC_INDEX);

	return skl_update_scaler(state, !state->base.active, SKL_CRTC_INDEX,
		&state->scaler_state.scaler_id, BIT(DRM_ROTATE_0),
		state->pipe_src_w, state->pipe_src_h,
		adjusted_mode->crtc_hdisplay, adjusted_mode->crtc_vdisplay);
}

/**
 * skl_update_scaler_plane - Stages update to scaler state for a given plane.
 *
 * @@state: crtc's scaler state
 * @@plane_state: atomic plane state to update
 *
 * Return
 *     0 - scaler_usage updated successfully
 *    error - requested scaling cannot be supported or other error condition
 */
static int skl_update_scaler_plane(struct intel_crtc_state *crtc_state,
				   struct intel_plane_state *plane_state)
{
#ifdef DRMDEBUG
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state->base.crtc);
#endif
	struct intel_plane *intel_plane =
		to_intel_plane(plane_state->base.plane);
	struct drm_framebuffer *fb = plane_state->base.fb;
	int ret;

	bool force_detach = !fb || !plane_state->visible;

	DRM_DEBUG_KMS("Updating scaler for [PLANE:%d] scaler_user index %u.%u\n",
		      intel_plane->base.base.id, intel_crtc->pipe,
		      drm_plane_index(&intel_plane->base));

	ret = skl_update_scaler(crtc_state, force_detach,
				drm_plane_index(&intel_plane->base),
				&plane_state->scaler_id,
				plane_state->base.rotation,
				drm_rect_width(&plane_state->src) >> 16,
				drm_rect_height(&plane_state->src) >> 16,
				drm_rect_width(&plane_state->dst),
				drm_rect_height(&plane_state->dst));

	if (ret || plane_state->scaler_id < 0)
		return ret;

	/* check colorkey */
	if (plane_state->ckey.flags != I915_SET_COLORKEY_NONE) {
		DRM_DEBUG_KMS("[PLANE:%d] scaling with color key not allowed",
			      intel_plane->base.base.id);
		return -EINVAL;
	}

	/* Check src format */
	switch (fb->pixel_format) {
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_ARGB8888:
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
		break;
	default:
		DRM_DEBUG_KMS("[PLANE:%d] FB:%d unsupported scaling format 0x%x\n",
			intel_plane->base.base.id, fb->base.id, fb->pixel_format);
		return -EINVAL;
	}

	return 0;
}

static void skylake_scaler_disable(struct intel_crtc *crtc)
{
	int i;

	for (i = 0; i < crtc->num_scalers; i++)
		skl_detach_scaler(crtc, i);
}

static void skylake_pfit_enable(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
	struct intel_crtc_scaler_state *scaler_state =
		&crtc->config->scaler_state;

	DRM_DEBUG_KMS("for crtc_state = %p\n", crtc->config);

	if (crtc->config->pch_pfit.enabled) {
		int id;

		if (WARN_ON(crtc->config->scaler_state.scaler_id < 0)) {
			DRM_ERROR("Requesting pfit without getting a scaler first\n");
			return;
		}

		id = scaler_state->scaler_id;
		I915_WRITE(SKL_PS_CTRL(pipe, id), PS_SCALER_EN |
			PS_FILTER_MEDIUM | scaler_state->scalers[id].mode);
		I915_WRITE(SKL_PS_WIN_POS(pipe, id), crtc->config->pch_pfit.pos);
		I915_WRITE(SKL_PS_WIN_SZ(pipe, id), crtc->config->pch_pfit.size);

		DRM_DEBUG_KMS("for crtc_state = %p scaler_id = %d\n", crtc->config, id);
	}
}

static void ironlake_pfit_enable(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;

	if (crtc->config->pch_pfit.enabled) {
		/* Force use of hard-coded filter coefficients
		 * as some pre-programmed values are broken,
		 * e.g. x201.
		 */
		if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev))
			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3 |
						 PF_PIPE_SEL_IVB(pipe));
		else
			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3);
		I915_WRITE(PF_WIN_POS(pipe), crtc->config->pch_pfit.pos);
		I915_WRITE(PF_WIN_SZ(pipe), crtc->config->pch_pfit.size);
	}
}

void hsw_enable_ips(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!crtc->config->ips_enabled)
		return;

	/* We can only enable IPS after we enable a plane and wait for a vblank */
	intel_wait_for_vblank(dev, crtc->pipe);

	assert_plane_enabled(dev_priv, crtc->plane);
	if (IS_BROADWELL(dev)) {
		mutex_lock(&dev_priv->rps.hw_lock);
		WARN_ON(sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL, 0xc0000000));
		mutex_unlock(&dev_priv->rps.hw_lock);
		/* Quoting Art Runyan: "its not safe to expect any particular
		 * value in IPS_CTL bit 31 after enabling IPS through the
		 * mailbox." Moreover, the mailbox may return a bogus state,
		 * so we need to just enable it and continue on.
		 */
	} else {
		I915_WRITE(IPS_CTL, IPS_ENABLE);
		/* The bit only becomes 1 in the next vblank, so this wait here
		 * is essentially intel_wait_for_vblank. If we don't have this
		 * and don't wait for vblanks until the end of crtc_enable, then
		 * the HW state readout code will complain that the expected
		 * IPS_CTL value is not the one we read. */
		if (wait_for(I915_READ_NOTRACE(IPS_CTL) & IPS_ENABLE, 50))
			DRM_ERROR("Timed out waiting for IPS enable\n");
	}
}

void hsw_disable_ips(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!crtc->config->ips_enabled)
		return;

	assert_plane_enabled(dev_priv, crtc->plane);
	if (IS_BROADWELL(dev)) {
		mutex_lock(&dev_priv->rps.hw_lock);
		WARN_ON(sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL, 0));
		mutex_unlock(&dev_priv->rps.hw_lock);
		/* wait for pcode to finish disabling IPS, which may take up to 42ms */
		if (wait_for((I915_READ(IPS_CTL) & IPS_ENABLE) == 0, 42))
			DRM_ERROR("Timed out waiting for IPS disable\n");
	} else {
		I915_WRITE(IPS_CTL, 0);
		POSTING_READ(IPS_CTL);
	}

	/* We need to wait for a vblank before we can disable the plane. */
	intel_wait_for_vblank(dev, crtc->pipe);
}

/** Loads the palette/gamma unit for the CRTC with the prepared values */
static void intel_crtc_load_lut(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum pipe pipe = intel_crtc->pipe;
	int i;
	bool reenable_ips = false;

	/* The clocks have to be on to load the palette. */
	if (!crtc->state->active)
		return;

	if (HAS_GMCH_DISPLAY(dev_priv->dev)) {
		if (intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_DSI))
			assert_dsi_pll_enabled(dev_priv);
		else
			assert_pll_enabled(dev_priv, pipe);
	}

	/* Workaround : Do not read or write the pipe palette/gamma data while
	 * GAMMA_MODE is configured for split gamma and IPS_CTL has IPS enabled.
	 */
	if (IS_HASWELL(dev) && intel_crtc->config->ips_enabled &&
	    ((I915_READ(GAMMA_MODE(pipe)) & GAMMA_MODE_MODE_MASK) ==
	     GAMMA_MODE_MODE_SPLIT)) {
		hsw_disable_ips(intel_crtc);
		reenable_ips = true;
	}

	for (i = 0; i < 256; i++) {
		u32 palreg;

		if (HAS_GMCH_DISPLAY(dev))
			palreg = PALETTE(pipe, i);
		else
			palreg = LGC_PALETTE(pipe, i);

		I915_WRITE(palreg,
			   (intel_crtc->lut_r[i] << 16) |
			   (intel_crtc->lut_g[i] << 8) |
			   intel_crtc->lut_b[i]);
	}

	if (reenable_ips)
		hsw_enable_ips(intel_crtc);
}

static void intel_crtc_dpms_overlay_disable(struct intel_crtc *intel_crtc)
{
	if (intel_crtc->overlay) {
		struct drm_device *dev = intel_crtc->base.dev;
		struct drm_i915_private *dev_priv = dev->dev_private;

		mutex_lock(&dev->struct_mutex);
		dev_priv->mm.interruptible = false;
		(void) intel_overlay_switch_off(intel_crtc->overlay);
		dev_priv->mm.interruptible = true;
		mutex_unlock(&dev->struct_mutex);
	}

	/* Let userspace switch the overlay on again. In most cases userspace
	 * has to recompute where to put it anyway.
	 */
}

/**
 * intel_post_enable_primary - Perform operations after enabling primary plane
 * @@crtc: the CRTC whose primary plane was just enabled
 *
 * Performs potentially sleeping operations that must be done after the primary
 * plane is enabled, such as updating FBC and IPS.  Note that this may be
 * called due to an explicit primary plane update, or due to an implicit
 * re-enable that is caused when a sprite plane is updated to no longer
 * completely hide the primary plane.
 */
static void
intel_post_enable_primary(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;

	/*
	 * BDW signals flip done immediately if the plane
	 * is disabled, even if the plane enable is already
	 * armed to occur at the next vblank :(
	 */
	if (IS_BROADWELL(dev))
		intel_wait_for_vblank(dev, pipe);

	/*
	 * FIXME IPS should be fine as long as one plane is
	 * enabled, but in practice it seems to have problems
	 * when going from primary only to sprite only and vice
	 * versa.
	 */
	hsw_enable_ips(intel_crtc);

	/*
	 * Gen2 reports pipe underruns whenever all planes are disabled.
	 * So don't enable underrun reporting before at least some planes
	 * are enabled.
	 * FIXME: Need to fix the logic to work when we turn off all planes
	 * but leave the pipe running.
	 */
	if (IS_GEN2(dev))
		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);

	/* Underruns don't raise interrupts, so check manually. */
	if (HAS_GMCH_DISPLAY(dev))
		i9xx_check_fifo_underruns(dev_priv);
}

/**
 * intel_pre_disable_primary - Perform operations before disabling primary plane
 * @@crtc: the CRTC whose primary plane is to be disabled
 *
 * Performs potentially sleeping operations that must be done before the
 * primary plane is disabled, such as updating FBC and IPS.  Note that this may
 * be called due to an explicit primary plane update, or due to an implicit
 * disable that is caused when a sprite plane completely hides the primary
 * plane.
 */
static void
intel_pre_disable_primary(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;

	/*
	 * Gen2 reports pipe underruns whenever all planes are disabled.
	 * So diasble underrun reporting before all the planes get disabled.
	 * FIXME: Need to fix the logic to work when we turn off all planes
	 * but leave the pipe running.
	 */
	if (IS_GEN2(dev))
		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);

	/*
	 * Vblank time updates from the shadow to live plane control register
	 * are blocked if the memory self-refresh mode is active at that
	 * moment. So to make sure the plane gets truly disabled, disable
	 * first the self-refresh mode. The self-refresh enable bit in turn
	 * will be checked/applied by the HW only at the next frame start
	 * event which is after the vblank start event, so we need to have a
	 * wait-for-vblank between disabling the plane and the pipe.
	 */
	if (HAS_GMCH_DISPLAY(dev)) {
		intel_set_memory_cxsr(dev_priv, false);
		dev_priv->wm.vlv.cxsr = false;
		intel_wait_for_vblank(dev, pipe);
	}

	/*
	 * FIXME IPS should be fine as long as one plane is
	 * enabled, but in practice it seems to have problems
	 * when going from primary only to sprite only and vice
	 * versa.
	 */
	hsw_disable_ips(intel_crtc);
}

static void intel_post_plane_update(struct intel_crtc *crtc)
{
	struct intel_crtc_atomic_commit *atomic = &crtc->atomic;
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_plane *plane;

	if (atomic->wait_vblank)
		intel_wait_for_vblank(dev, crtc->pipe);

	intel_frontbuffer_flip(dev, atomic->fb_bits);

	if (atomic->disable_cxsr)
		crtc->wm.cxsr_allowed = true;

	if (crtc->atomic.update_wm_post)
		intel_update_watermarks(&crtc->base);

	if (atomic->update_fbc)
		intel_fbc_update(dev_priv);

	if (atomic->post_enable_primary)
		intel_post_enable_primary(&crtc->base);

	drm_for_each_plane_mask(plane, dev, atomic->update_sprite_watermarks)
		intel_update_sprite_watermarks(plane, &crtc->base,
					       0, 0, 0, false, false);

	memset(atomic, 0, sizeof(*atomic));
}

static void intel_pre_plane_update(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc_atomic_commit *atomic = &crtc->atomic;
	struct drm_plane *p;

	/* Track fb's for any planes being disabled */
	drm_for_each_plane_mask(p, dev, atomic->disabled_planes) {
		struct intel_plane *plane = to_intel_plane(p);

		mutex_lock(&dev->struct_mutex);
		i915_gem_track_fb(intel_fb_obj(plane->base.fb), NULL,
				  plane->frontbuffer_bit);
		mutex_unlock(&dev->struct_mutex);
	}

	if (atomic->wait_for_flips)
		intel_crtc_wait_for_pending_flips(&crtc->base);

	if (atomic->disable_fbc)
		intel_fbc_disable_crtc(crtc);

	if (crtc->atomic.disable_ips)
		hsw_disable_ips(crtc);

	if (atomic->pre_disable_primary)
		intel_pre_disable_primary(&crtc->base);

	if (atomic->disable_cxsr) {
		crtc->wm.cxsr_allowed = false;
		intel_set_memory_cxsr(dev_priv, false);
	}
}

static void intel_crtc_disable_planes(struct drm_crtc *crtc, unsigned plane_mask)
{
	struct drm_device *dev = crtc->dev;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *p;
	int pipe = intel_crtc->pipe;

	intel_crtc_dpms_overlay_disable(intel_crtc);

	drm_for_each_plane_mask(p, dev, plane_mask)
		to_intel_plane(p)->disable_plane(p, crtc);

	/*
	 * FIXME: Once we grow proper nuclear flip support out of this we need
	 * to compute the mask of flip planes precisely. For the time being
	 * consider this a flip to a NULL plane.
	 */
	intel_frontbuffer_flip(dev, INTEL_FRONTBUFFER_ALL_MASK(pipe));
}

static void ironlake_crtc_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;

	if (WARN_ON(intel_crtc->active))
		return;

	if (intel_crtc->config->has_pch_encoder)
		intel_prepare_shared_dpll(intel_crtc);

	if (intel_crtc->config->has_dp_encoder)
		intel_dp_set_m_n(intel_crtc, M1_N1);

	intel_set_pipe_timings(intel_crtc);

	if (intel_crtc->config->has_pch_encoder) {
		intel_cpu_transcoder_set_m_n(intel_crtc,
				     &intel_crtc->config->fdi_m_n, NULL);
	}

	ironlake_set_pipeconf(crtc);

	intel_crtc->active = true;

	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
	intel_set_pch_fifo_underrun_reporting(dev_priv, pipe, true);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);

	if (intel_crtc->config->has_pch_encoder) {
		/* Note: FDI PLL enabling _must_ be done before we enable the
		 * cpu pipes, hence this is separate from all the other fdi/pch
		 * enabling. */
		ironlake_fdi_pll_enable(intel_crtc);
	} else {
		assert_fdi_tx_disabled(dev_priv, pipe);
		assert_fdi_rx_disabled(dev_priv, pipe);
	}

	ironlake_pfit_enable(intel_crtc);

	/*
	 * On ILK+ LUT must be loaded before the pipe is running but with
	 * clocks enabled
	 */
	intel_crtc_load_lut(crtc);

	intel_update_watermarks(crtc);
	intel_enable_pipe(intel_crtc);

	if (intel_crtc->config->has_pch_encoder)
		ironlake_pch_enable(crtc);

	assert_vblank_disabled(crtc);
	drm_crtc_vblank_on(crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);

	if (HAS_PCH_CPT(dev))
		cpt_verify_modeset(dev, intel_crtc->pipe);
}

/* IPS only exists on ULT machines and is tied to pipe A. */
static bool hsw_crtc_supports_ips(struct intel_crtc *crtc)
{
	return HAS_IPS(crtc->base.dev) && crtc->pipe == PIPE_A;
}

static void haswell_crtc_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe, hsw_workaround_pipe;
	struct intel_crtc_state *pipe_config =
		to_intel_crtc_state(crtc->state);
	bool is_dsi = intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_DSI);

	if (WARN_ON(intel_crtc->active))
		return;

	if (intel_crtc_to_shared_dpll(intel_crtc))
		intel_enable_shared_dpll(intel_crtc);

	if (intel_crtc->config->has_dp_encoder)
		intel_dp_set_m_n(intel_crtc, M1_N1);

	intel_set_pipe_timings(intel_crtc);

	if (intel_crtc->config->cpu_transcoder != TRANSCODER_EDP) {
		I915_WRITE(PIPE_MULT(intel_crtc->config->cpu_transcoder),
			   intel_crtc->config->pixel_multiplier - 1);
	}

	if (intel_crtc->config->has_pch_encoder) {
		intel_cpu_transcoder_set_m_n(intel_crtc,
				     &intel_crtc->config->fdi_m_n, NULL);
	}

	haswell_set_pipeconf(crtc);

	intel_set_pipe_csc(crtc);

	intel_crtc->active = true;

	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);
	for_each_encoder_on_crtc(dev, crtc, encoder) {
		if (encoder->pre_pll_enable)
			encoder->pre_pll_enable(encoder);
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);
	}

	if (intel_crtc->config->has_pch_encoder) {
		intel_set_pch_fifo_underrun_reporting(dev_priv, TRANSCODER_A,
						      true);
		dev_priv->display.fdi_link_train(crtc);
	}

	if (!is_dsi)
		intel_ddi_enable_pipe_clock(intel_crtc);

	if (INTEL_INFO(dev)->gen >= 9)
		skylake_pfit_enable(intel_crtc);
	else
		ironlake_pfit_enable(intel_crtc);

	/*
	 * On ILK+ LUT must be loaded before the pipe is running but with
	 * clocks enabled
	 */
	intel_crtc_load_lut(crtc);

	intel_ddi_set_pipe_settings(crtc);
	if (!is_dsi)
		intel_ddi_enable_transcoder_func(crtc);

	intel_update_watermarks(crtc);
	intel_enable_pipe(intel_crtc);

	if (intel_crtc->config->has_pch_encoder)
		lpt_pch_enable(crtc);

	if (intel_crtc->config->dp_encoder_is_mst && !is_dsi)
		intel_ddi_set_vc_payload_alloc(crtc, true);

	assert_vblank_disabled(crtc);
	drm_crtc_vblank_on(crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder) {
		encoder->enable(encoder);
		intel_opregion_notify_encoder(encoder, true);
	}

	/* If we change the relative order between pipe/planes enabling, we need
	 * to change the workaround. */
	hsw_workaround_pipe = pipe_config->hsw_workaround_pipe;
	if (IS_HASWELL(dev) && hsw_workaround_pipe != INVALID_PIPE) {
		intel_wait_for_vblank(dev, hsw_workaround_pipe);
		intel_wait_for_vblank(dev, hsw_workaround_pipe);
	}
}

static void ironlake_pfit_disable(struct intel_crtc *crtc, bool force)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;

	/* To avoid upsetting the power well on haswell only disable the pfit if
	 * it's in use. The hw state code will make sure we get this right. */
	if (force || crtc->config->pch_pfit.enabled) {
		I915_WRITE(PF_CTL(pipe), 0);
		I915_WRITE(PF_WIN_POS(pipe), 0);
		I915_WRITE(PF_WIN_SZ(pipe), 0);
	}
}

static void ironlake_crtc_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	u32 reg, temp;

	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->disable(encoder);

	drm_crtc_vblank_off(crtc);
	assert_vblank_disabled(crtc);

	if (intel_crtc->config->has_pch_encoder)
		intel_set_pch_fifo_underrun_reporting(dev_priv, pipe, false);

	intel_disable_pipe(intel_crtc);

	ironlake_pfit_disable(intel_crtc, false);

	if (intel_crtc->config->has_pch_encoder)
		ironlake_fdi_disable(crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_disable)
			encoder->post_disable(encoder);

	if (intel_crtc->config->has_pch_encoder) {
		ironlake_disable_pch_transcoder(dev_priv, pipe);

		if (HAS_PCH_CPT(dev)) {
			/* disable TRANS_DP_CTL */
			reg = TRANS_DP_CTL(pipe);
			temp = I915_READ(reg);
			temp &= ~(TRANS_DP_OUTPUT_ENABLE |
				  TRANS_DP_PORT_SEL_MASK);
			temp |= TRANS_DP_PORT_SEL_NONE;
			I915_WRITE(reg, temp);

			/* disable DPLL_SEL */
			temp = I915_READ(PCH_DPLL_SEL);
			temp &= ~(TRANS_DPLL_ENABLE(pipe) | TRANS_DPLLB_SEL(pipe));
			I915_WRITE(PCH_DPLL_SEL, temp);
		}

		ironlake_fdi_pll_disable(intel_crtc);
	}
}

static void haswell_crtc_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;
	bool is_dsi = intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_DSI);

	for_each_encoder_on_crtc(dev, crtc, encoder) {
		intel_opregion_notify_encoder(encoder, false);
		encoder->disable(encoder);
	}

	drm_crtc_vblank_off(crtc);
	assert_vblank_disabled(crtc);

	if (intel_crtc->config->has_pch_encoder)
		intel_set_pch_fifo_underrun_reporting(dev_priv, TRANSCODER_A,
						      false);
	intel_disable_pipe(intel_crtc);

	if (intel_crtc->config->dp_encoder_is_mst)
		intel_ddi_set_vc_payload_alloc(crtc, false);

	if (!is_dsi)
		intel_ddi_disable_transcoder_func(dev_priv, cpu_transcoder);

	if (INTEL_INFO(dev)->gen >= 9)
		skylake_scaler_disable(intel_crtc);
	else
		ironlake_pfit_disable(intel_crtc, false);

	if (!is_dsi)
		intel_ddi_disable_pipe_clock(intel_crtc);

	if (intel_crtc->config->has_pch_encoder) {
		lpt_disable_pch_transcoder(dev_priv);
		intel_ddi_fdi_disable(crtc);
	}

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_disable)
			encoder->post_disable(encoder);
}

static void i9xx_pfit_enable(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc_state *pipe_config = crtc->config;

	if (!pipe_config->gmch_pfit.control)
		return;

	/*
	 * The panel fitter should only be adjusted whilst the pipe is disabled,
	 * according to register description and PRM.
	 */
	WARN_ON(I915_READ(PFIT_CONTROL) & PFIT_ENABLE);
	assert_pipe_disabled(dev_priv, crtc->pipe);

	I915_WRITE(PFIT_PGM_RATIOS, pipe_config->gmch_pfit.pgm_ratios);
	I915_WRITE(PFIT_CONTROL, pipe_config->gmch_pfit.control);

	/* Border color in case we don't scale up to the full screen. Black by
	 * default, change to something else for debugging. */
	I915_WRITE(BCLRPAT(crtc->pipe), 0);
}

static enum intel_display_power_domain port_to_power_domain(enum port port)
{
	switch (port) {
	case PORT_A:
		return POWER_DOMAIN_PORT_DDI_A_4_LANES;
	case PORT_B:
		return POWER_DOMAIN_PORT_DDI_B_4_LANES;
	case PORT_C:
		return POWER_DOMAIN_PORT_DDI_C_4_LANES;
	case PORT_D:
		return POWER_DOMAIN_PORT_DDI_D_4_LANES;
	case PORT_E:
		return POWER_DOMAIN_PORT_DDI_E_2_LANES;
	default:
		MISSING_CASE(port);
		return POWER_DOMAIN_PORT_OTHER;
	}
}

static enum intel_display_power_domain port_to_aux_power_domain(enum port port)
{
	switch (port) {
	case PORT_A:
		return POWER_DOMAIN_AUX_A;
	case PORT_B:
		return POWER_DOMAIN_AUX_B;
	case PORT_C:
		return POWER_DOMAIN_AUX_C;
	case PORT_D:
		return POWER_DOMAIN_AUX_D;
	case PORT_E:
		/* FIXME: Check VBT for actual wiring of PORT E */
		return POWER_DOMAIN_AUX_D;
	default:
		MISSING_CASE(port);
		return POWER_DOMAIN_AUX_A;
	}
}

#define for_each_power_domain(domain, mask)				\
	for ((domain) = 0; (domain) < POWER_DOMAIN_NUM; (domain)++)	\
		if ((1 << (domain)) & (mask))

enum intel_display_power_domain
intel_display_port_power_domain(struct intel_encoder *intel_encoder)
{
	struct drm_device *dev = intel_encoder->base.dev;
	struct intel_digital_port *intel_dig_port;

	switch (intel_encoder->type) {
	case INTEL_OUTPUT_UNKNOWN:
		/* Only DDI platforms should ever use this output type */
		WARN_ON_ONCE(!HAS_DDI(dev));
	case INTEL_OUTPUT_DISPLAYPORT:
	case INTEL_OUTPUT_HDMI:
	case INTEL_OUTPUT_EDP:
		intel_dig_port = enc_to_dig_port(&intel_encoder->base);
		return port_to_power_domain(intel_dig_port->port);
	case INTEL_OUTPUT_DP_MST:
		intel_dig_port = enc_to_mst(&intel_encoder->base)->primary;
		return port_to_power_domain(intel_dig_port->port);
	case INTEL_OUTPUT_ANALOG:
		return POWER_DOMAIN_PORT_CRT;
	case INTEL_OUTPUT_DSI:
		return POWER_DOMAIN_PORT_DSI;
	default:
		return POWER_DOMAIN_PORT_OTHER;
	}
}

enum intel_display_power_domain
intel_display_port_aux_power_domain(struct intel_encoder *intel_encoder)
{
	struct drm_device *dev = intel_encoder->base.dev;
	struct intel_digital_port *intel_dig_port;

	switch (intel_encoder->type) {
	case INTEL_OUTPUT_UNKNOWN:
	case INTEL_OUTPUT_HDMI:
		/*
		 * Only DDI platforms should ever use these output types.
		 * We can get here after the HDMI detect code has already set
		 * the type of the shared encoder. Since we can't be sure
		 * what's the status of the given connectors, play safe and
		 * run the DP detection too.
		 */
		WARN_ON_ONCE(!HAS_DDI(dev));
	case INTEL_OUTPUT_DISPLAYPORT:
	case INTEL_OUTPUT_EDP:
		intel_dig_port = enc_to_dig_port(&intel_encoder->base);
		return port_to_aux_power_domain(intel_dig_port->port);
	case INTEL_OUTPUT_DP_MST:
		intel_dig_port = enc_to_mst(&intel_encoder->base)->primary;
		return port_to_aux_power_domain(intel_dig_port->port);
	default:
		MISSING_CASE(intel_encoder->type);
		return POWER_DOMAIN_AUX_A;
	}
}

static unsigned long get_crtc_power_domains(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum pipe pipe = intel_crtc->pipe;
	unsigned long mask;
	enum transcoder transcoder;

	if (!crtc->state->active)
		return 0;

	transcoder = intel_pipe_to_cpu_transcoder(dev->dev_private, pipe);

	mask = BIT(POWER_DOMAIN_PIPE(pipe));
	mask |= BIT(POWER_DOMAIN_TRANSCODER(transcoder));
	if (intel_crtc->config->pch_pfit.enabled ||
	    intel_crtc->config->pch_pfit.force_thru)
		mask |= BIT(POWER_DOMAIN_PIPE_PANEL_FITTER(pipe));

	for_each_encoder_on_crtc(dev, crtc, intel_encoder)
		mask |= BIT(intel_display_port_power_domain(intel_encoder));

	return mask;
}

static unsigned long modeset_get_crtc_power_domains(struct drm_crtc *crtc)
{
	struct drm_i915_private *dev_priv = crtc->dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum intel_display_power_domain domain;
	unsigned long domains, new_domains, old_domains;

	old_domains = intel_crtc->enabled_power_domains;
	intel_crtc->enabled_power_domains = new_domains = get_crtc_power_domains(crtc);

	domains = new_domains & ~old_domains;

	for_each_power_domain(domain, domains)
		intel_display_power_get(dev_priv, domain);

	return old_domains & ~new_domains;
}

static void modeset_put_power_domains(struct drm_i915_private *dev_priv,
				      unsigned long domains)
{
	enum intel_display_power_domain domain;

	for_each_power_domain(domain, domains)
		intel_display_power_put(dev_priv, domain);
}

static void modeset_update_crtc_power_domains(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long put_domains[I915_MAX_PIPES] = {};
	struct drm_crtc_state *crtc_state;
	struct drm_crtc *crtc;
	int i;

	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		if (needs_modeset(crtc->state))
			put_domains[to_intel_crtc(crtc)->pipe] =
				modeset_get_crtc_power_domains(crtc);
	}

	if (dev_priv->display.modeset_commit_cdclk) {
		unsigned int cdclk = to_intel_atomic_state(state)->cdclk;

		if (cdclk != dev_priv->cdclk_freq &&
		    !WARN_ON(!state->allow_modeset))
			dev_priv->display.modeset_commit_cdclk(state);
	}

	for (i = 0; i < I915_MAX_PIPES; i++)
		if (put_domains[i])
			modeset_put_power_domains(dev_priv, put_domains[i]);
}

static int intel_compute_max_dotclk(struct drm_i915_private *dev_priv)
{
	int max_cdclk_freq = dev_priv->max_cdclk_freq;

	if (INTEL_INFO(dev_priv)->gen >= 9 ||
	    IS_HASWELL(dev_priv) || IS_BROADWELL(dev_priv))
		return max_cdclk_freq;
	else if (IS_CHERRYVIEW(dev_priv))
		return max_cdclk_freq*95/100;
	else if (INTEL_INFO(dev_priv)->gen < 4)
		return 2*max_cdclk_freq*90/100;
	else
		return max_cdclk_freq*90/100;
}

static void intel_update_max_cdclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (IS_SKYLAKE(dev)) {
		u32 limit = I915_READ(SKL_DFSM) & SKL_DFSM_CDCLK_LIMIT_MASK;

		if (limit == SKL_DFSM_CDCLK_LIMIT_675)
			dev_priv->max_cdclk_freq = 675000;
		else if (limit == SKL_DFSM_CDCLK_LIMIT_540)
			dev_priv->max_cdclk_freq = 540000;
		else if (limit == SKL_DFSM_CDCLK_LIMIT_450)
			dev_priv->max_cdclk_freq = 450000;
		else
			dev_priv->max_cdclk_freq = 337500;
	} else if (IS_BROADWELL(dev))  {
		/*
		 * FIXME with extra cooling we can allow
		 * 540 MHz for ULX and 675 Mhz for ULT.
		 * How can we know if extra cooling is
		 * available? PCI ID, VTB, something else?
		 */
		if (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)
			dev_priv->max_cdclk_freq = 450000;
		else if (IS_BDW_ULX(dev))
			dev_priv->max_cdclk_freq = 450000;
		else if (IS_BDW_ULT(dev))
			dev_priv->max_cdclk_freq = 540000;
		else
			dev_priv->max_cdclk_freq = 675000;
	} else if (IS_CHERRYVIEW(dev)) {
		dev_priv->max_cdclk_freq = 320000;
	} else if (IS_VALLEYVIEW(dev)) {
		dev_priv->max_cdclk_freq = 400000;
	} else {
		/* otherwise assume cdclk is fixed */
		dev_priv->max_cdclk_freq = dev_priv->cdclk_freq;
	}

	dev_priv->max_dotclk_freq = intel_compute_max_dotclk(dev_priv);

	DRM_DEBUG_DRIVER("Max CD clock rate: %d kHz\n",
			 dev_priv->max_cdclk_freq);

	DRM_DEBUG_DRIVER("Max dotclock rate: %d kHz\n",
			 dev_priv->max_dotclk_freq);
}

static void intel_update_cdclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	dev_priv->cdclk_freq = dev_priv->display.get_display_clock_speed(dev);
	DRM_DEBUG_DRIVER("Current CD clock rate: %d kHz\n",
			 dev_priv->cdclk_freq);

	/*
	 * Program the gmbus_freq based on the cdclk frequency.
	 * BSpec erroneously claims we should aim for 4MHz, but
	 * in fact 1MHz is the correct frequency.
	 */
	if (IS_VALLEYVIEW(dev)) {
		/*
		 * Program the gmbus_freq based on the cdclk frequency.
		 * BSpec erroneously claims we should aim for 4MHz, but
		 * in fact 1MHz is the correct frequency.
		 */
		I915_WRITE(GMBUSFREQ_VLV, DIV_ROUND_UP(dev_priv->cdclk_freq, 1000));
	}

	if (dev_priv->max_cdclk_freq == 0)
		intel_update_max_cdclk(dev);
}

static void broxton_set_cdclk(struct drm_device *dev, int frequency)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t divider;
	uint32_t ratio;
	uint32_t current_freq;
	int ret;

	/* frequency = 19.2MHz * ratio / 2 / div{1,1.5,2,4} */
	switch (frequency) {
	case 144000:
		divider = BXT_CDCLK_CD2X_DIV_SEL_4;
		ratio = BXT_DE_PLL_RATIO(60);
		break;
	case 288000:
		divider = BXT_CDCLK_CD2X_DIV_SEL_2;
		ratio = BXT_DE_PLL_RATIO(60);
		break;
	case 384000:
		divider = BXT_CDCLK_CD2X_DIV_SEL_1_5;
		ratio = BXT_DE_PLL_RATIO(60);
		break;
	case 576000:
		divider = BXT_CDCLK_CD2X_DIV_SEL_1;
		ratio = BXT_DE_PLL_RATIO(60);
		break;
	case 624000:
		divider = BXT_CDCLK_CD2X_DIV_SEL_1;
		ratio = BXT_DE_PLL_RATIO(65);
		break;
	case 19200:
		/*
		 * Bypass frequency with DE PLL disabled. Init ratio, divider
		 * to suppress GCC warning.
		 */
		ratio = 0;
		divider = 0;
		break;
	default:
		DRM_ERROR("unsupported CDCLK freq %d", frequency);

		return;
	}

	mutex_lock(&dev_priv->rps.hw_lock);
	/* Inform power controller of upcoming frequency change */
	ret = sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ,
				      0x80000000);
	mutex_unlock(&dev_priv->rps.hw_lock);

	if (ret) {
		DRM_ERROR("PCode CDCLK freq change notify failed (err %d, freq %d)\n",
			  ret, frequency);
		return;
	}

	current_freq = I915_READ(CDCLK_CTL) & CDCLK_FREQ_DECIMAL_MASK;
	/* convert from .1 fixpoint MHz with -1MHz offset to kHz */
	current_freq = current_freq * 500 + 1000;

	/*
	 * DE PLL has to be disabled when
	 * - setting to 19.2MHz (bypass, PLL isn't used)
	 * - before setting to 624MHz (PLL needs toggling)
	 * - before setting to any frequency from 624MHz (PLL needs toggling)
	 */
	if (frequency == 19200 || frequency == 624000 ||
	    current_freq == 624000) {
		I915_WRITE(BXT_DE_PLL_ENABLE, ~BXT_DE_PLL_PLL_ENABLE);
		/* Timeout 200us */
		if (wait_for(!(I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK),
			     1))
			DRM_ERROR("timout waiting for DE PLL unlock\n");
	}

	if (frequency != 19200) {
		uint32_t val;

		val = I915_READ(BXT_DE_PLL_CTL);
		val &= ~BXT_DE_PLL_RATIO_MASK;
		val |= ratio;
		I915_WRITE(BXT_DE_PLL_CTL, val);

		I915_WRITE(BXT_DE_PLL_ENABLE, BXT_DE_PLL_PLL_ENABLE);
		/* Timeout 200us */
		if (wait_for(I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_LOCK, 1))
			DRM_ERROR("timeout waiting for DE PLL lock\n");

		val = I915_READ(CDCLK_CTL);
		val &= ~BXT_CDCLK_CD2X_DIV_SEL_MASK;
		val |= divider;
		/*
		 * Disable SSA Precharge when CD clock frequency < 500 MHz,
		 * enable otherwise.
		 */
		val &= ~BXT_CDCLK_SSA_PRECHARGE_ENABLE;
		if (frequency >= 500000)
			val |= BXT_CDCLK_SSA_PRECHARGE_ENABLE;

		val &= ~CDCLK_FREQ_DECIMAL_MASK;
		/* convert from kHz to .1 fixpoint MHz with -1MHz offset */
		val |= (frequency - 1000) / 500;
		I915_WRITE(CDCLK_CTL, val);
	}

	mutex_lock(&dev_priv->rps.hw_lock);
	ret = sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ,
				      DIV_ROUND_UP(frequency, 25000));
	mutex_unlock(&dev_priv->rps.hw_lock);

	if (ret) {
		DRM_ERROR("PCode CDCLK freq set failed, (err %d, freq %d)\n",
			  ret, frequency);
		return;
	}

	intel_update_cdclk(dev);
}

void broxton_init_cdclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t val;

	/*
	 * NDE_RSTWRN_OPT RST PCH Handshake En must always be 0b on BXT
	 * or else the reset will hang because there is no PCH to respond.
	 * Move the handshake programming to initialization sequence.
	 * Previously was left up to BIOS.
	 */
	val = I915_READ(HSW_NDE_RSTWRN_OPT);
	val &= ~RESET_PCH_HANDSHAKE_ENABLE;
	I915_WRITE(HSW_NDE_RSTWRN_OPT, val);

	/* Enable PG1 for cdclk */
	intel_display_power_get(dev_priv, POWER_DOMAIN_PLLS);

	/* check if cd clock is enabled */
	if (I915_READ(BXT_DE_PLL_ENABLE) & BXT_DE_PLL_PLL_ENABLE) {
		DRM_DEBUG_KMS("Display already initialized\n");
		return;
	}

	/*
	 * FIXME:
	 * - The initial CDCLK needs to be read from VBT.
	 *   Need to make this change after VBT has changes for BXT.
	 * - check if setting the max (or any) cdclk freq is really necessary
	 *   here, it belongs to modeset time
	 */
	broxton_set_cdclk(dev, 624000);

	I915_WRITE(DBUF_CTL, I915_READ(DBUF_CTL) | DBUF_POWER_REQUEST);
	POSTING_READ(DBUF_CTL);

	udelay(10);

	if (!(I915_READ(DBUF_CTL) & DBUF_POWER_STATE))
		DRM_ERROR("DBuf power enable timeout!\n");
}

void broxton_uninit_cdclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE(DBUF_CTL, I915_READ(DBUF_CTL) & ~DBUF_POWER_REQUEST);
	POSTING_READ(DBUF_CTL);

	udelay(10);

	if (I915_READ(DBUF_CTL) & DBUF_POWER_STATE)
		DRM_ERROR("DBuf power disable timeout!\n");

	/* Set minimum (bypass) frequency, in effect turning off the DE PLL */
	broxton_set_cdclk(dev, 19200);

	intel_display_power_put(dev_priv, POWER_DOMAIN_PLLS);
}

static const struct skl_cdclk_entry {
	unsigned int freq;
	unsigned int vco;
} skl_cdclk_frequencies[] = {
	{ .freq = 308570, .vco = 8640 },
	{ .freq = 337500, .vco = 8100 },
	{ .freq = 432000, .vco = 8640 },
	{ .freq = 450000, .vco = 8100 },
	{ .freq = 540000, .vco = 8100 },
	{ .freq = 617140, .vco = 8640 },
	{ .freq = 675000, .vco = 8100 },
};

static unsigned int skl_cdclk_decimal(unsigned int freq)
{
	return (freq - 1000) / 500;
}

static unsigned int skl_cdclk_get_vco(unsigned int freq)
{
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(skl_cdclk_frequencies); i++) {
		const struct skl_cdclk_entry *e = &skl_cdclk_frequencies[i];

		if (e->freq == freq)
			return e->vco;
	}

	return 8100;
}

static void
skl_dpll0_enable(struct drm_i915_private *dev_priv, unsigned int required_vco)
{
	unsigned int min_freq;
	u32 val;

	/* select the minimum CDCLK before enabling DPLL 0 */
	val = I915_READ(CDCLK_CTL);
	val &= ~CDCLK_FREQ_SEL_MASK | ~CDCLK_FREQ_DECIMAL_MASK;
	val |= CDCLK_FREQ_337_308;

	if (required_vco == 8640)
		min_freq = 308570;
	else
		min_freq = 337500;

	val = CDCLK_FREQ_337_308 | skl_cdclk_decimal(min_freq);

	I915_WRITE(CDCLK_CTL, val);
	POSTING_READ(CDCLK_CTL);

	/*
	 * We always enable DPLL0 with the lowest link rate possible, but still
	 * taking into account the VCO required to operate the eDP panel at the
	 * desired frequency. The usual DP link rates operate with a VCO of
	 * 8100 while the eDP 1.4 alternate link rates need a VCO of 8640.
	 * The modeset code is responsible for the selection of the exact link
	 * rate later on, with the constraint of choosing a frequency that
	 * works with required_vco.
	 */
	val = I915_READ(DPLL_CTRL1);

	val &= ~(DPLL_CTRL1_HDMI_MODE(SKL_DPLL0) | DPLL_CTRL1_SSC(SKL_DPLL0) |
		 DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0));
	val |= DPLL_CTRL1_OVERRIDE(SKL_DPLL0);
	if (required_vco == 8640)
		val |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080,
					    SKL_DPLL0);
	else
		val |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810,
					    SKL_DPLL0);

	I915_WRITE(DPLL_CTRL1, val);
	POSTING_READ(DPLL_CTRL1);

	I915_WRITE(LCPLL1_CTL, I915_READ(LCPLL1_CTL) | LCPLL_PLL_ENABLE);

	if (wait_for(I915_READ(LCPLL1_CTL) & LCPLL_PLL_LOCK, 5))
		DRM_ERROR("DPLL0 not locked\n");
}

static bool skl_cdclk_pcu_ready(struct drm_i915_private *dev_priv)
{
	int ret;
	u32 val;

	/* inform PCU we want to change CDCLK */
	val = SKL_CDCLK_PREPARE_FOR_CHANGE;
	mutex_lock(&dev_priv->rps.hw_lock);
	ret = sandybridge_pcode_read(dev_priv, SKL_PCODE_CDCLK_CONTROL, &val);
	mutex_unlock(&dev_priv->rps.hw_lock);

	return ret == 0 && (val & SKL_CDCLK_READY_FOR_CHANGE);
}

static bool skl_cdclk_wait_for_pcu_ready(struct drm_i915_private *dev_priv)
{
	unsigned int i;

	for (i = 0; i < 15; i++) {
		if (skl_cdclk_pcu_ready(dev_priv))
			return true;
		udelay(10);
	}

	return false;
}

static void skl_set_cdclk(struct drm_i915_private *dev_priv, unsigned int freq)
{
	struct drm_device *dev = dev_priv->dev;
	u32 freq_select, pcu_ack;

	DRM_DEBUG_DRIVER("Changing CDCLK to %dKHz\n", freq);

	if (!skl_cdclk_wait_for_pcu_ready(dev_priv)) {
		DRM_ERROR("failed to inform PCU about cdclk change\n");
		return;
	}

	/* set CDCLK_CTL */
	switch(freq) {
	case 450000:
	case 432000:
		freq_select = CDCLK_FREQ_450_432;
		pcu_ack = 1;
		break;
	case 540000:
		freq_select = CDCLK_FREQ_540;
		pcu_ack = 2;
		break;
	case 308570:
	case 337500:
	default:
		freq_select = CDCLK_FREQ_337_308;
		pcu_ack = 0;
		break;
	case 617140:
	case 675000:
		freq_select = CDCLK_FREQ_675_617;
		pcu_ack = 3;
		break;
	}

	I915_WRITE(CDCLK_CTL, freq_select | skl_cdclk_decimal(freq));
	POSTING_READ(CDCLK_CTL);

	/* inform PCU of the change */
	mutex_lock(&dev_priv->rps.hw_lock);
	sandybridge_pcode_write(dev_priv, SKL_PCODE_CDCLK_CONTROL, pcu_ack);
	mutex_unlock(&dev_priv->rps.hw_lock);

	intel_update_cdclk(dev);
}

void skl_uninit_cdclk(struct drm_i915_private *dev_priv)
{
	/* disable DBUF power */
	I915_WRITE(DBUF_CTL, I915_READ(DBUF_CTL) & ~DBUF_POWER_REQUEST);
	POSTING_READ(DBUF_CTL);

	udelay(10);

	if (I915_READ(DBUF_CTL) & DBUF_POWER_STATE)
		DRM_ERROR("DBuf power disable timeout\n");

	/*
	 * DMC assumes ownership of LCPLL and will get confused if we touch it.
	 */
	if (dev_priv->csr.dmc_payload) {
		/* disable DPLL0 */
		I915_WRITE(LCPLL1_CTL, I915_READ(LCPLL1_CTL) &
					~LCPLL_PLL_ENABLE);
		if (wait_for(!(I915_READ(LCPLL1_CTL) & LCPLL_PLL_LOCK), 1))
			DRM_ERROR("Couldn't disable DPLL0\n");
	}

	intel_display_power_put(dev_priv, POWER_DOMAIN_PLLS);
}

void skl_init_cdclk(struct drm_i915_private *dev_priv)
{
	u32 val;
	unsigned int required_vco;

	/* enable PCH reset handshake */
	val = I915_READ(HSW_NDE_RSTWRN_OPT);
	I915_WRITE(HSW_NDE_RSTWRN_OPT, val | RESET_PCH_HANDSHAKE_ENABLE);

	/* enable PG1 and Misc I/O */
	intel_display_power_get(dev_priv, POWER_DOMAIN_PLLS);

	/* DPLL0 not enabled (happens on early BIOS versions) */
	if (!(I915_READ(LCPLL1_CTL) & LCPLL_PLL_ENABLE)) {
		/* enable DPLL0 */
		required_vco = skl_cdclk_get_vco(dev_priv->skl_boot_cdclk);
		skl_dpll0_enable(dev_priv, required_vco);
	}

	/* set CDCLK to the frequency the BIOS chose */
	skl_set_cdclk(dev_priv, dev_priv->skl_boot_cdclk);

	/* enable DBUF power */
	I915_WRITE(DBUF_CTL, I915_READ(DBUF_CTL) | DBUF_POWER_REQUEST);
	POSTING_READ(DBUF_CTL);

	udelay(10);

	if (!(I915_READ(DBUF_CTL) & DBUF_POWER_STATE))
		DRM_ERROR("DBuf power enable timeout\n");
}

/* Adjust CDclk dividers to allow high res or save power if possible */
static void valleyview_set_cdclk(struct drm_device *dev, int cdclk)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, cmd;

	WARN_ON(dev_priv->display.get_display_clock_speed(dev)
					!= dev_priv->cdclk_freq);

	if (cdclk >= 320000) /* jump to highest voltage for 400MHz too */
		cmd = 2;
	else if (cdclk == 266667)
		cmd = 1;
	else
		cmd = 0;

	mutex_lock(&dev_priv->rps.hw_lock);
	val = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);
	val &= ~DSPFREQGUAR_MASK;
	val |= (cmd << DSPFREQGUAR_SHIFT);
	vlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);
	if (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &
		      DSPFREQSTAT_MASK) == (cmd << DSPFREQSTAT_SHIFT),
		     50)) {
		DRM_ERROR("timed out waiting for CDclk change\n");
	}
	mutex_unlock(&dev_priv->rps.hw_lock);

	mutex_lock(&dev_priv->sb_lock);

	if (cdclk == 400000) {
		u32 divider;

		divider = DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1, cdclk) - 1;

		/* adjust cdclk divider */
		val = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);
		val &= ~CCK_FREQUENCY_VALUES;
		val |= divider;
		vlv_cck_write(dev_priv, CCK_DISPLAY_CLOCK_CONTROL, val);

		if (wait_for((vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL) &
			      CCK_FREQUENCY_STATUS) == (divider << CCK_FREQUENCY_STATUS_SHIFT),
			     50))
			DRM_ERROR("timed out waiting for CDclk change\n");
	}

	/* adjust self-refresh exit latency value */
	val = vlv_bunit_read(dev_priv, BUNIT_REG_BISOC);
	val &= ~0x7f;

	/*
	 * For high bandwidth configs, we set a higher latency in the bunit
	 * so that the core display fetch happens in time to avoid underruns.
	 */
	if (cdclk == 400000)
		val |= 4500 / 250; /* 4.5 usec */
	else
		val |= 3000 / 250; /* 3.0 usec */
	vlv_bunit_write(dev_priv, BUNIT_REG_BISOC, val);

	mutex_unlock(&dev_priv->sb_lock);

	intel_update_cdclk(dev);
}

static void cherryview_set_cdclk(struct drm_device *dev, int cdclk)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, cmd;

	WARN_ON(dev_priv->display.get_display_clock_speed(dev)
						!= dev_priv->cdclk_freq);

	switch (cdclk) {
	case 333333:
	case 320000:
	case 266667:
	case 200000:
		break;
	default:
		MISSING_CASE(cdclk);
		return;
	}

	/*
	 * Specs are full of misinformation, but testing on actual
	 * hardware has shown that we just need to write the desired
	 * CCK divider into the Punit register.
	 */
	cmd = DIV_ROUND_CLOSEST(dev_priv->hpll_freq << 1, cdclk) - 1;

	mutex_lock(&dev_priv->rps.hw_lock);
	val = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);
	val &= ~DSPFREQGUAR_MASK_CHV;
	val |= (cmd << DSPFREQGUAR_SHIFT_CHV);
	vlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);
	if (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &
		      DSPFREQSTAT_MASK_CHV) == (cmd << DSPFREQSTAT_SHIFT_CHV),
		     50)) {
		DRM_ERROR("timed out waiting for CDclk change\n");
	}
	mutex_unlock(&dev_priv->rps.hw_lock);

	intel_update_cdclk(dev);
}

static int valleyview_calc_cdclk(struct drm_i915_private *dev_priv,
				 int max_pixclk)
{
	int freq_320 = (dev_priv->hpll_freq <<  1) % 320000 != 0 ? 333333 : 320000;
	int limit = IS_CHERRYVIEW(dev_priv) ? 95 : 90;

	/*
	 * Really only a few cases to deal with, as only 4 CDclks are supported:
	 *   200MHz
	 *   267MHz
	 *   320/333MHz (depends on HPLL freq)
	 *   400MHz (VLV only)
	 * So we check to see whether we're above 90% (VLV) or 95% (CHV)
	 * of the lower bin and adjust if needed.
	 *
	 * We seem to get an unstable or solid color picture at 200MHz.
	 * Not sure what's wrong. For now use 200MHz only when all pipes
	 * are off.
	 */
	if (!IS_CHERRYVIEW(dev_priv) &&
	    max_pixclk > freq_320*limit/100)
		return 400000;
	else if (max_pixclk > 266667*limit/100)
		return freq_320;
	else if (max_pixclk > 0)
		return 266667;
	else
		return 200000;
}

static int broxton_calc_cdclk(struct drm_i915_private *dev_priv,
			      int max_pixclk)
{
	/*
	 * FIXME:
	 * - remove the guardband, it's not needed on BXT
	 * - set 19.2MHz bypass frequency if there are no active pipes
	 */
	if (max_pixclk > 576000*9/10)
		return 624000;
	else if (max_pixclk > 384000*9/10)
		return 576000;
	else if (max_pixclk > 288000*9/10)
		return 384000;
	else if (max_pixclk > 144000*9/10)
		return 288000;
	else
		return 144000;
}

/* Compute the max pixel clock for new configuration. Uses atomic state if
 * that's non-NULL, look at current state otherwise. */
static int intel_mode_max_pixclk(struct drm_device *dev,
				 struct drm_atomic_state *state)
{
	struct intel_crtc *intel_crtc;
	struct intel_crtc_state *crtc_state;
	int max_pixclk = 0;

	for_each_intel_crtc(dev, intel_crtc) {
		crtc_state = intel_atomic_get_crtc_state(state, intel_crtc);
		if (IS_ERR(crtc_state))
			return PTR_ERR(crtc_state);

		if (!crtc_state->base.enable)
			continue;

		max_pixclk = max(max_pixclk,
				 crtc_state->base.adjusted_mode.crtc_clock);
	}

	return max_pixclk;
}

static int valleyview_modeset_calc_cdclk(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int max_pixclk = intel_mode_max_pixclk(dev, state);

	if (max_pixclk < 0)
		return max_pixclk;

	to_intel_atomic_state(state)->cdclk =
		valleyview_calc_cdclk(dev_priv, max_pixclk);

	return 0;
}

static int broxton_modeset_calc_cdclk(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int max_pixclk = intel_mode_max_pixclk(dev, state);

	if (max_pixclk < 0)
		return max_pixclk;

	to_intel_atomic_state(state)->cdclk =
		broxton_calc_cdclk(dev_priv, max_pixclk);

	return 0;
}

static void vlv_program_pfi_credits(struct drm_i915_private *dev_priv)
{
	unsigned int credits, default_credits;

	if (IS_CHERRYVIEW(dev_priv))
		default_credits = PFI_CREDIT(12);
	else
		default_credits = PFI_CREDIT(8);

	if (dev_priv->cdclk_freq >= dev_priv->czclk_freq) {
		/* CHV suggested value is 31 or 63 */
		if (IS_CHERRYVIEW(dev_priv))
			credits = PFI_CREDIT_63;
		else
			credits = PFI_CREDIT(15);
	} else {
		credits = default_credits;
	}

	/*
	 * WA - write default credits before re-programming
	 * FIXME: should we also set the resend bit here?
	 */
	I915_WRITE(GCI_CONTROL, VGA_FAST_MODE_DISABLE |
		   default_credits);

	I915_WRITE(GCI_CONTROL, VGA_FAST_MODE_DISABLE |
		   credits | PFI_CREDIT_RESEND);

	/*
	 * FIXME is this guaranteed to clear
	 * immediately or should we poll for it?
	 */
	WARN_ON(I915_READ(GCI_CONTROL) & PFI_CREDIT_RESEND);
}

static void valleyview_modeset_commit_cdclk(struct drm_atomic_state *old_state)
{
	struct drm_device *dev = old_state->dev;
	unsigned int req_cdclk = to_intel_atomic_state(old_state)->cdclk;
	struct drm_i915_private *dev_priv = dev->dev_private;

	/*
	 * FIXME: We can end up here with all power domains off, yet
	 * with a CDCLK frequency other than the minimum. To account
	 * for this take the PIPE-A power domain, which covers the HW
	 * blocks needed for the following programming. This can be
	 * removed once it's guaranteed that we get here either with
	 * the minimum CDCLK set, or the required power domains
	 * enabled.
	 */
	intel_display_power_get(dev_priv, POWER_DOMAIN_PIPE_A);

	if (IS_CHERRYVIEW(dev))
		cherryview_set_cdclk(dev, req_cdclk);
	else
		valleyview_set_cdclk(dev, req_cdclk);

	vlv_program_pfi_credits(dev_priv);

	intel_display_power_put(dev_priv, POWER_DOMAIN_PIPE_A);
}

static void valleyview_crtc_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	bool is_dsi;

	if (WARN_ON(intel_crtc->active))
		return;

	is_dsi = intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_DSI);

	if (intel_crtc->config->has_dp_encoder)
		intel_dp_set_m_n(intel_crtc, M1_N1);

	intel_set_pipe_timings(intel_crtc);

	if (IS_CHERRYVIEW(dev) && pipe == PIPE_B) {
		struct drm_i915_private *dev_priv = dev->dev_private;

		I915_WRITE(CHV_BLEND(pipe), CHV_BLEND_LEGACY);
		I915_WRITE(CHV_CANVAS(pipe), 0);
	}

	i9xx_set_pipeconf(intel_crtc);

	intel_crtc->active = true;

	intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_pll_enable)
			encoder->pre_pll_enable(encoder);

	if (!is_dsi) {
		if (IS_CHERRYVIEW(dev)) {
			chv_prepare_pll(intel_crtc, intel_crtc->config);
			chv_enable_pll(intel_crtc, intel_crtc->config);
		} else {
			vlv_prepare_pll(intel_crtc, intel_crtc->config);
			vlv_enable_pll(intel_crtc, intel_crtc->config);
		}
	}

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);

	i9xx_pfit_enable(intel_crtc);

	intel_crtc_load_lut(crtc);

	intel_enable_pipe(intel_crtc);

	assert_vblank_disabled(crtc);
	drm_crtc_vblank_on(crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
}

static void i9xx_set_pll_dividers(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	I915_WRITE(FP0(crtc->pipe), crtc->config->dpll_hw_state.fp0);
	I915_WRITE(FP1(crtc->pipe), crtc->config->dpll_hw_state.fp1);
}

static void i9xx_crtc_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;

	if (WARN_ON(intel_crtc->active))
		return;

	i9xx_set_pll_dividers(intel_crtc);

	if (intel_crtc->config->has_dp_encoder)
		intel_dp_set_m_n(intel_crtc, M1_N1);

	intel_set_pipe_timings(intel_crtc);

	i9xx_set_pipeconf(intel_crtc);

	intel_crtc->active = true;

	if (!IS_GEN2(dev))
		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, true);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);

	i9xx_enable_pll(intel_crtc);

	i9xx_pfit_enable(intel_crtc);

	intel_crtc_load_lut(crtc);

	intel_update_watermarks(crtc);
	intel_enable_pipe(intel_crtc);

	assert_vblank_disabled(crtc);
	drm_crtc_vblank_on(crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
}

static void i9xx_pfit_disable(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!crtc->config->gmch_pfit.control)
		return;

	assert_pipe_disabled(dev_priv, crtc->pipe);

	DRM_DEBUG_DRIVER("disabling pfit, current: 0x%08x\n",
			 I915_READ(PFIT_CONTROL));
	I915_WRITE(PFIT_CONTROL, 0);
}

static void i9xx_crtc_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;

	/*
	 * On gen2 planes are double buffered but the pipe isn't, so we must
	 * wait for planes to fully turn off before disabling the pipe.
	 * We also need to wait on all gmch platforms because of the
	 * self-refresh mode constraint explained above.
	 */
	intel_wait_for_vblank(dev, pipe);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->disable(encoder);

	drm_crtc_vblank_off(crtc);
	assert_vblank_disabled(crtc);

	intel_disable_pipe(intel_crtc);

	i9xx_pfit_disable(intel_crtc);

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_disable)
			encoder->post_disable(encoder);

	if (!intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_DSI)) {
		if (IS_CHERRYVIEW(dev))
			chv_disable_pll(dev_priv, pipe);
		else if (IS_VALLEYVIEW(dev))
			vlv_disable_pll(dev_priv, pipe);
		else
			i9xx_disable_pll(intel_crtc);
	}

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_pll_disable)
			encoder->post_pll_disable(encoder);

	if (!IS_GEN2(dev))
		intel_set_cpu_fifo_underrun_reporting(dev_priv, pipe, false);
}

static void intel_crtc_disable_noatomic(struct drm_crtc *crtc)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
	enum intel_display_power_domain domain;
	unsigned long domains;

	if (!intel_crtc->active)
		return;

	if (to_intel_plane_state(crtc->primary->state)->visible) {
		intel_crtc_wait_for_pending_flips(crtc);
		intel_pre_disable_primary(crtc);

		intel_crtc_disable_planes(crtc, 1 << drm_plane_index(crtc->primary));
		to_intel_plane_state(crtc->primary->state)->visible = false;
	}

	dev_priv->display.crtc_disable(crtc);
	intel_crtc->active = false;
	intel_update_watermarks(crtc);
	intel_disable_shared_dpll(intel_crtc);

	domains = intel_crtc->enabled_power_domains;
	for_each_power_domain(domain, domains)
		intel_display_power_put(dev_priv, domain);
	intel_crtc->enabled_power_domains = 0;
}

/*
 * turn all crtc's off, but do not adjust state
 * This has to be paired with a call to intel_modeset_setup_hw_state.
 */
int intel_display_suspend(struct drm_device *dev)
{
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_modeset_acquire_ctx *ctx = config->acquire_ctx;
	struct drm_atomic_state *state;
	struct drm_crtc *crtc;
	unsigned crtc_mask = 0;
	int ret = 0;

	if (WARN_ON(!ctx))
		return 0;

	lockdep_assert_held(&ctx->ww_ctx);
	state = drm_atomic_state_alloc(dev);
	if (WARN_ON(!state))
		return -ENOMEM;

	state->acquire_ctx = ctx;
	state->allow_modeset = true;

	for_each_crtc(dev, crtc) {
		struct drm_crtc_state *crtc_state =
			drm_atomic_get_crtc_state(state, crtc);

		ret = PTR_ERR_OR_ZERO(crtc_state);
		if (ret)
			goto free;

		if (!crtc_state->active)
			continue;

		crtc_state->active = false;
		crtc_mask |= 1 << drm_crtc_index(crtc);
	}

	if (crtc_mask) {
		ret = drm_atomic_commit(state);

		if (!ret) {
			for_each_crtc(dev, crtc)
				if (crtc_mask & (1 << drm_crtc_index(crtc)))
					crtc->state->active = true;

			return ret;
		}
	}

free:
	if (ret)
		DRM_ERROR("Suspending crtc's failed with %i\n", ret);
	drm_atomic_state_free(state);
	return ret;
}

void intel_encoder_destroy(struct drm_encoder *encoder)
{
	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);

	drm_encoder_cleanup(encoder);
	kfree(intel_encoder);
}

/* Cross check the actual hw state with our own modeset state tracking (and it's
 * internal consistency). */
static void intel_connector_check_state(struct intel_connector *connector)
{
	struct drm_crtc *crtc = connector->base.state->crtc;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.base.id,
		      connector->base.name);

	if (connector->get_hw_state(connector)) {
		struct intel_encoder *encoder = connector->encoder;
		struct drm_connector_state *conn_state = connector->base.state;

		I915_STATE_WARN(!crtc,
			 "connector enabled without attached crtc\n");

		if (!crtc)
			return;

		I915_STATE_WARN(!crtc->state->active,
		      "connector is active, but attached crtc isn't\n");

		if (!encoder || encoder->type == INTEL_OUTPUT_DP_MST)
			return;

		I915_STATE_WARN(conn_state->best_encoder != &encoder->base,
			"atomic encoder doesn't match attached encoder\n");

		I915_STATE_WARN(conn_state->crtc != encoder->base.crtc,
			"attached encoder crtc differs from connector crtc\n");
	} else {
		I915_STATE_WARN(crtc && crtc->state->active,
			"attached crtc is active, but connector isn't\n");
		I915_STATE_WARN(!crtc && connector->base.state->best_encoder,
			"best encoder set without crtc!\n");
	}
}

int intel_connector_init(struct intel_connector *connector)
{
	struct drm_connector_state *connector_state;

	connector_state = kzalloc(sizeof *connector_state, GFP_KERNEL);
	if (!connector_state)
		return -ENOMEM;

	connector->base.state = connector_state;
	return 0;
}

struct intel_connector *intel_connector_alloc(void)
{
	struct intel_connector *connector;

	connector = kzalloc(sizeof *connector, GFP_KERNEL);
	if (!connector)
		return NULL;

	if (intel_connector_init(connector) < 0) {
		kfree(connector);
		return NULL;
	}

	return connector;
}

/* Simple connector->get_hw_state implementation for encoders that support only
 * one connector and no cloning and hence the encoder state determines the state
 * of the connector. */
bool intel_connector_get_hw_state(struct intel_connector *connector)
{
	enum pipe pipe = 0;
	struct intel_encoder *encoder = connector->encoder;

	return encoder->get_hw_state(encoder, &pipe);
}

static int pipe_required_fdi_lanes(struct intel_crtc_state *crtc_state)
{
	if (crtc_state->base.enable && crtc_state->has_pch_encoder)
		return crtc_state->fdi_lanes;

	return 0;
}

static int ironlake_check_fdi_lanes(struct drm_device *dev, enum pipe pipe,
				     struct intel_crtc_state *pipe_config)
{
	struct drm_atomic_state *state = pipe_config->base.state;
	struct intel_crtc *other_crtc;
	struct intel_crtc_state *other_crtc_state;

	DRM_DEBUG_KMS("checking fdi config on pipe %c, lanes %i\n",
		      pipe_name(pipe), pipe_config->fdi_lanes);
	if (pipe_config->fdi_lanes > 4) {
		DRM_DEBUG_KMS("invalid fdi lane config on pipe %c: %i lanes\n",
			      pipe_name(pipe), pipe_config->fdi_lanes);
		return -EINVAL;
	}

	if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		if (pipe_config->fdi_lanes > 2) {
			DRM_DEBUG_KMS("only 2 lanes on haswell, required: %i lanes\n",
				      pipe_config->fdi_lanes);
			return -EINVAL;
		} else {
			return 0;
		}
	}

	if (INTEL_INFO(dev)->num_pipes == 2)
		return 0;

	/* Ivybridge 3 pipe is really complicated */
	switch (pipe) {
	case PIPE_A:
		return 0;
	case PIPE_B:
		if (pipe_config->fdi_lanes <= 2)
			return 0;

		other_crtc = to_intel_crtc(intel_get_crtc_for_pipe(dev, PIPE_C));
		other_crtc_state =
			intel_atomic_get_crtc_state(state, other_crtc);
		if (IS_ERR(other_crtc_state))
			return PTR_ERR(other_crtc_state);

		if (pipe_required_fdi_lanes(other_crtc_state) > 0) {
			DRM_DEBUG_KMS("invalid shared fdi lane config on pipe %c: %i lanes\n",
				      pipe_name(pipe), pipe_config->fdi_lanes);
			return -EINVAL;
		}
		return 0;
	case PIPE_C:
		if (pipe_config->fdi_lanes > 2) {
			DRM_DEBUG_KMS("only 2 lanes on pipe %c: required %i lanes\n",
				      pipe_name(pipe), pipe_config->fdi_lanes);
			return -EINVAL;
		}

		other_crtc = to_intel_crtc(intel_get_crtc_for_pipe(dev, PIPE_B));
		other_crtc_state =
			intel_atomic_get_crtc_state(state, other_crtc);
		if (IS_ERR(other_crtc_state))
			return PTR_ERR(other_crtc_state);

		if (pipe_required_fdi_lanes(other_crtc_state) > 2) {
			DRM_DEBUG_KMS("fdi link B uses too many lanes to enable link C\n");
			return -EINVAL;
		}
		return 0;
	default:
		BUG();
	}
}

#define RETRY 1
static int ironlake_fdi_compute_config(struct intel_crtc *intel_crtc,
				       struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = intel_crtc->base.dev;
	const struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	int lane, link_bw, fdi_dotclock, ret;
	bool needs_recompute = false;

retry:
	/* FDI is a binary signal running at ~2.7GHz, encoding
	 * each output octet as 10 bits. The actual frequency
	 * is stored as a divider into a 100MHz clock, and the
	 * mode pixel clock is stored in units of 1KHz.
	 * Hence the bw of each lane in terms of the mode signal
	 * is:
	 */
	link_bw = intel_fdi_link_freq(dev) * MHz(100)/KHz(1)/10;

	fdi_dotclock = adjusted_mode->crtc_clock;

	lane = ironlake_get_lanes_required(fdi_dotclock, link_bw,
					   pipe_config->pipe_bpp);

	pipe_config->fdi_lanes = lane;

	intel_link_compute_m_n(pipe_config->pipe_bpp, lane, fdi_dotclock,
			       link_bw, &pipe_config->fdi_m_n);

	ret = ironlake_check_fdi_lanes(intel_crtc->base.dev,
				       intel_crtc->pipe, pipe_config);
	if (ret == -EINVAL && pipe_config->pipe_bpp > 6*3) {
		pipe_config->pipe_bpp -= 2*3;
		DRM_DEBUG_KMS("fdi link bw constraint, reducing pipe bpp to %i\n",
			      pipe_config->pipe_bpp);
		needs_recompute = true;
		pipe_config->bw_constrained = true;

		goto retry;
	}

	if (needs_recompute)
		return RETRY;

	return ret;
}

static bool pipe_config_supports_ips(struct drm_i915_private *dev_priv,
				     struct intel_crtc_state *pipe_config)
{
	if (pipe_config->pipe_bpp > 24)
		return false;

	/* HSW can handle pixel rate up to cdclk? */
	if (IS_HASWELL(dev_priv->dev))
		return true;

	/*
	 * We compare against max which means we must take
	 * the increased cdclk requirement into account when
	 * calculating the new cdclk.
	 *
	 * Should measure whether using a lower cdclk w/o IPS
	 */
	return ilk_pipe_pixel_rate(pipe_config) <=
		dev_priv->max_cdclk_freq * 95 / 100;
}

static void hsw_compute_ips_config(struct intel_crtc *crtc,
				   struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	pipe_config->ips_enabled = i915.enable_ips &&
		hsw_crtc_supports_ips(crtc) &&
		pipe_config_supports_ips(dev_priv, pipe_config);
}

static int intel_crtc_compute_config(struct intel_crtc *crtc,
				     struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	const struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;

	/* FIXME should check pixel clock limits on all platforms */
	if (INTEL_INFO(dev)->gen < 4) {
		int clock_limit = dev_priv->max_cdclk_freq;

		/*
		 * Enable pixel doubling when the dot clock
		 * is > 90% of the (display) core speed.
		 *
		 * GDG double wide on either pipe,
		 * otherwise pipe A only.
		 */
		if ((crtc->pipe == PIPE_A || IS_I915G(dev)) &&
		    adjusted_mode->crtc_clock > clock_limit * 9 / 10) {
			clock_limit *= 2;
			pipe_config->double_wide = true;
		}

		if (adjusted_mode->crtc_clock > clock_limit * 9 / 10)
			return -EINVAL;
	}

	/*
	 * Pipe horizontal size must be even in:
	 * - DVO ganged mode
	 * - LVDS dual channel mode
	 * - Double wide pipe
	 */
	if ((intel_pipe_will_have_type(pipe_config, INTEL_OUTPUT_LVDS) &&
	     intel_is_dual_link_lvds(dev)) || pipe_config->double_wide)
		pipe_config->pipe_src_w &= ~1;

	/* Cantiga+ cannot handle modes with a hsync front porch of 0.
	 * WaPruneModeWithIncorrectHsyncOffset:ctg,elk,ilk,snb,ivb,vlv,hsw.
	 */
	if ((INTEL_INFO(dev)->gen > 4 || IS_G4X(dev)) &&
		adjusted_mode->crtc_hsync_start == adjusted_mode->crtc_hdisplay)
		return -EINVAL;

	if (HAS_IPS(dev))
		hsw_compute_ips_config(crtc, pipe_config);

	if (pipe_config->has_pch_encoder)
		return ironlake_fdi_compute_config(crtc, pipe_config);

	return 0;
}

static int skylake_get_display_clock_speed(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	uint32_t lcpll1 = I915_READ(LCPLL1_CTL);
	uint32_t cdctl = I915_READ(CDCLK_CTL);
	uint32_t linkrate;

	if (!(lcpll1 & LCPLL_PLL_ENABLE))
		return 24000; /* 24MHz is the cd freq with NSSC ref */

	if ((cdctl & CDCLK_FREQ_SEL_MASK) == CDCLK_FREQ_540)
		return 540000;

	linkrate = (I915_READ(DPLL_CTRL1) &
		    DPLL_CTRL1_LINK_RATE_MASK(SKL_DPLL0)) >> 1;

	if (linkrate == DPLL_CTRL1_LINK_RATE_2160 ||
	    linkrate == DPLL_CTRL1_LINK_RATE_1080) {
		/* vco 8640 */
		switch (cdctl & CDCLK_FREQ_SEL_MASK) {
		case CDCLK_FREQ_450_432:
			return 432000;
		case CDCLK_FREQ_337_308:
			return 308570;
		case CDCLK_FREQ_675_617:
			return 617140;
		default:
			WARN(1, "Unknown cd freq selection\n");
		}
	} else {
		/* vco 8100 */
		switch (cdctl & CDCLK_FREQ_SEL_MASK) {
		case CDCLK_FREQ_450_432:
			return 450000;
		case CDCLK_FREQ_337_308:
			return 337500;
		case CDCLK_FREQ_675_617:
			return 675000;
		default:
			WARN(1, "Unknown cd freq selection\n");
		}
	}

	/* error case, do as if DPLL0 isn't enabled */
	return 24000;
}

static int broxton_get_display_clock_speed(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	uint32_t cdctl = I915_READ(CDCLK_CTL);
	uint32_t pll_ratio = I915_READ(BXT_DE_PLL_CTL) & BXT_DE_PLL_RATIO_MASK;
	uint32_t pll_enab = I915_READ(BXT_DE_PLL_ENABLE);
	int cdclk;

	if (!(pll_enab & BXT_DE_PLL_PLL_ENABLE))
		return 19200;

	cdclk = 19200 * pll_ratio / 2;

	switch (cdctl & BXT_CDCLK_CD2X_DIV_SEL_MASK) {
	case BXT_CDCLK_CD2X_DIV_SEL_1:
		return cdclk;  /* 576MHz or 624MHz */
	case BXT_CDCLK_CD2X_DIV_SEL_1_5:
		return cdclk * 2 / 3; /* 384MHz */
	case BXT_CDCLK_CD2X_DIV_SEL_2:
		return cdclk / 2; /* 288MHz */
	case BXT_CDCLK_CD2X_DIV_SEL_4:
		return cdclk / 4; /* 144MHz */
	}

	/* error case, do as if DE PLL isn't enabled */
	return 19200;
}

static int broadwell_get_display_clock_speed(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t lcpll = I915_READ(LCPLL_CTL);
	uint32_t freq = lcpll & LCPLL_CLK_FREQ_MASK;

	if (lcpll & LCPLL_CD_SOURCE_FCLK)
		return 800000;
	else if (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)
		return 450000;
	else if (freq == LCPLL_CLK_FREQ_450)
		return 450000;
	else if (freq == LCPLL_CLK_FREQ_54O_BDW)
		return 540000;
	else if (freq == LCPLL_CLK_FREQ_337_5_BDW)
		return 337500;
	else
		return 675000;
}

static int haswell_get_display_clock_speed(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t lcpll = I915_READ(LCPLL_CTL);
	uint32_t freq = lcpll & LCPLL_CLK_FREQ_MASK;

	if (lcpll & LCPLL_CD_SOURCE_FCLK)
		return 800000;
	else if (I915_READ(FUSE_STRAP) & HSW_CDCLK_LIMIT)
		return 450000;
	else if (freq == LCPLL_CLK_FREQ_450)
		return 450000;
	else if (IS_HSW_ULT(dev))
		return 337500;
	else
		return 540000;
}

static int valleyview_get_display_clock_speed(struct drm_device *dev)
{
	return vlv_get_cck_clock_hpll(to_i915(dev), "cdclk",
				      CCK_DISPLAY_CLOCK_CONTROL);
}

static int ilk_get_display_clock_speed(struct drm_device *dev)
{
	return 450000;
}

static int i945_get_display_clock_speed(struct drm_device *dev)
{
	return 400000;
}

static int i915_get_display_clock_speed(struct drm_device *dev)
{
	return 333333;
}

static int i9xx_misc_get_display_clock_speed(struct drm_device *dev)
{
	return 200000;
}

static int pnv_get_display_clock_speed(struct drm_device *dev)
{
	u16 gcfgc = 0;

	pci_read_config_word(dev->pdev, GCFGC, &gcfgc);

	switch (gcfgc & GC_DISPLAY_CLOCK_MASK) {
	case GC_DISPLAY_CLOCK_267_MHZ_PNV:
		return 266667;
	case GC_DISPLAY_CLOCK_333_MHZ_PNV:
		return 333333;
	case GC_DISPLAY_CLOCK_444_MHZ_PNV:
		return 444444;
	case GC_DISPLAY_CLOCK_200_MHZ_PNV:
		return 200000;
	default:
		DRM_ERROR("Unknown pnv display core clock 0x%04x\n", gcfgc);
	case GC_DISPLAY_CLOCK_133_MHZ_PNV:
		return 133333;
	case GC_DISPLAY_CLOCK_167_MHZ_PNV:
		return 166667;
	}
}

static int i915gm_get_display_clock_speed(struct drm_device *dev)
{
	u16 gcfgc = 0;

	pci_read_config_word(dev->pdev, GCFGC, &gcfgc);

	if (gcfgc & GC_LOW_FREQUENCY_ENABLE)
		return 133333;
	else {
		switch (gcfgc & GC_DISPLAY_CLOCK_MASK) {
		case GC_DISPLAY_CLOCK_333_MHZ:
			return 333333;
		default:
		case GC_DISPLAY_CLOCK_190_200_MHZ:
			return 190000;
		}
	}
}

static int i865_get_display_clock_speed(struct drm_device *dev)
{
	return 266667;
}

static int i85x_get_display_clock_speed(struct drm_device *dev)
{
	u16 hpllcc = 0;

	/*
	 * 852GM/852GMV only supports 133 MHz and the HPLLCC
	 * encoding is different :(
	 * FIXME is this the right way to detect 852GM/852GMV?
	 */
	if (dev->pdev->revision == 0x1)
		return 133333;

	pci_bus_read_config_word(dev->pdev->bus,
				 PCI_DEVFN(0, 3), HPLLCC, &hpllcc);

	/* Assume that the hardware is in the high speed state.  This
	 * should be the default.
	 */
	switch (hpllcc & GC_CLOCK_CONTROL_MASK) {
	case GC_CLOCK_133_200:
	case GC_CLOCK_133_200_2:
	case GC_CLOCK_100_200:
		return 200000;
	case GC_CLOCK_166_250:
		return 250000;
	case GC_CLOCK_100_133:
		return 133333;
	case GC_CLOCK_133_266:
	case GC_CLOCK_133_266_2:
	case GC_CLOCK_166_266:
		return 266667;
	}

	/* Shouldn't happen */
	return 0;
}

static int i830_get_display_clock_speed(struct drm_device *dev)
{
	return 133333;
}

static unsigned int intel_hpll_vco(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	static const unsigned int blb_vco[8] = {
		[0] = 3200000,
		[1] = 4000000,
		[2] = 5333333,
		[3] = 4800000,
		[4] = 6400000,
	};
	static const unsigned int pnv_vco[8] = {
		[0] = 3200000,
		[1] = 4000000,
		[2] = 5333333,
		[3] = 4800000,
		[4] = 2666667,
	};
	static const unsigned int cl_vco[8] = {
		[0] = 3200000,
		[1] = 4000000,
		[2] = 5333333,
		[3] = 6400000,
		[4] = 3333333,
		[5] = 3566667,
		[6] = 4266667,
	};
	static const unsigned int elk_vco[8] = {
		[0] = 3200000,
		[1] = 4000000,
		[2] = 5333333,
		[3] = 4800000,
	};
	static const unsigned int ctg_vco[8] = {
		[0] = 3200000,
		[1] = 4000000,
		[2] = 5333333,
		[3] = 6400000,
		[4] = 2666667,
		[5] = 4266667,
	};
	const unsigned int *vco_table;
	unsigned int vco;
	uint8_t tmp = 0;

	/* FIXME other chipsets? */
	if (IS_GM45(dev))
		vco_table = ctg_vco;
	else if (IS_G4X(dev))
		vco_table = elk_vco;
	else if (IS_CRESTLINE(dev))
		vco_table = cl_vco;
	else if (IS_PINEVIEW(dev))
		vco_table = pnv_vco;
	else if (IS_G33(dev))
		vco_table = blb_vco;
	else
		return 0;

	tmp = I915_READ(IS_MOBILE(dev) ? HPLLVCO_MOBILE : HPLLVCO);

	vco = vco_table[tmp & 0x7];
	if (vco == 0)
		DRM_ERROR("Bad HPLL VCO (HPLLVCO=0x%02x)\n", tmp);
	else
		DRM_DEBUG_KMS("HPLL VCO %u kHz\n", vco);

	return vco;
}

static int gm45_get_display_clock_speed(struct drm_device *dev)
{
	unsigned int cdclk_sel, vco = intel_hpll_vco(dev);
	uint16_t tmp = 0;

	pci_read_config_word(dev->pdev, GCFGC, &tmp);

	cdclk_sel = (tmp >> 12) & 0x1;

	switch (vco) {
	case 2666667:
	case 4000000:
	case 5333333:
		return cdclk_sel ? 333333 : 222222;
	case 3200000:
		return cdclk_sel ? 320000 : 228571;
	default:
		DRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u, CFGC=0x%04x\n", vco, tmp);
		return 222222;
	}
}

static int i965gm_get_display_clock_speed(struct drm_device *dev)
{
	static const uint8_t div_3200[] = { 16, 10,  8 };
	static const uint8_t div_4000[] = { 20, 12, 10 };
	static const uint8_t div_5333[] = { 24, 16, 14 };
	const uint8_t *div_table;
	unsigned int cdclk_sel, vco = intel_hpll_vco(dev);
	uint16_t tmp = 0;

	pci_read_config_word(dev->pdev, GCFGC, &tmp);

	cdclk_sel = ((tmp >> 8) & 0x1f) - 1;

	if (cdclk_sel >= ARRAY_SIZE(div_3200))
		goto fail;

	switch (vco) {
	case 3200000:
		div_table = div_3200;
		break;
	case 4000000:
		div_table = div_4000;
		break;
	case 5333333:
		div_table = div_5333;
		break;
	default:
		goto fail;
	}

	return DIV_ROUND_CLOSEST(vco, div_table[cdclk_sel]);

fail:
	DRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%04x\n", vco, tmp);
	return 200000;
}

static int g33_get_display_clock_speed(struct drm_device *dev)
{
	static const uint8_t div_3200[] = { 12, 10,  8,  7, 5, 16 };
	static const uint8_t div_4000[] = { 14, 12, 10,  8, 6, 20 };
	static const uint8_t div_4800[] = { 20, 14, 12, 10, 8, 24 };
	static const uint8_t div_5333[] = { 20, 16, 12, 12, 8, 28 };
	const uint8_t *div_table;
	unsigned int cdclk_sel, vco = intel_hpll_vco(dev);
	uint16_t tmp = 0;

	pci_read_config_word(dev->pdev, GCFGC, &tmp);

	cdclk_sel = (tmp >> 4) & 0x7;

	if (cdclk_sel >= ARRAY_SIZE(div_3200))
		goto fail;

	switch (vco) {
	case 3200000:
		div_table = div_3200;
		break;
	case 4000000:
		div_table = div_4000;
		break;
	case 4800000:
		div_table = div_4800;
		break;
	case 5333333:
		div_table = div_5333;
		break;
	default:
		goto fail;
	}

	return DIV_ROUND_CLOSEST(vco, div_table[cdclk_sel]);

fail:
	DRM_ERROR("Unable to determine CDCLK. HPLL VCO=%u kHz, CFGC=0x%08x\n", vco, tmp);
	return 190476;
}

static void
intel_reduce_m_n_ratio(uint32_t *num, uint32_t *den)
{
	while (*num > DATA_LINK_M_N_MASK ||
	       *den > DATA_LINK_M_N_MASK) {
		*num >>= 1;
		*den >>= 1;
	}
}

static void compute_m_n(unsigned int m, unsigned int n,
			uint32_t *ret_m, uint32_t *ret_n)
{
	*ret_n = min_t(unsigned int, roundup_pow_of_two(n), DATA_LINK_N_MAX);
	*ret_m = div_u64((uint64_t) m * *ret_n, n);
	intel_reduce_m_n_ratio(ret_m, ret_n);
}

void
intel_link_compute_m_n(int bits_per_pixel, int nlanes,
		       int pixel_clock, int link_clock,
		       struct intel_link_m_n *m_n)
{
	m_n->tu = 64;

	compute_m_n(bits_per_pixel * pixel_clock,
		    link_clock * nlanes * 8,
		    &m_n->gmch_m, &m_n->gmch_n);

	compute_m_n(pixel_clock, link_clock,
		    &m_n->link_m, &m_n->link_n);
}

static inline bool intel_panel_use_ssc(struct drm_i915_private *dev_priv)
{
	if (i915.panel_use_ssc >= 0)
		return i915.panel_use_ssc != 0;
	return dev_priv->vbt.lvds_use_ssc
		&& !(dev_priv->quirks & QUIRK_LVDS_SSC_DISABLE);
}

static int i9xx_get_refclk(const struct intel_crtc_state *crtc_state,
			   int num_connectors)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int refclk;

	WARN_ON(!crtc_state->base.state);

	if (IS_VALLEYVIEW(dev) || IS_BROXTON(dev)) {
		refclk = 100000;
	} else if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS) &&
	    intel_panel_use_ssc(dev_priv) && num_connectors < 2) {
		refclk = dev_priv->vbt.lvds_ssc_freq;
		DRM_DEBUG_KMS("using SSC reference clock of %d kHz\n", refclk);
	} else if (!IS_GEN2(dev)) {
		refclk = 96000;
	} else {
		refclk = 48000;
	}

	return refclk;
}

static uint32_t pnv_dpll_compute_fp(struct dpll *dpll)
{
	return (1 << dpll->n) << 16 | dpll->m2;
}

static uint32_t i9xx_dpll_compute_fp(struct dpll *dpll)
{
	return dpll->n << 16 | dpll->m1 << 8 | dpll->m2;
}

static void i9xx_update_pll_dividers(struct intel_crtc *crtc,
				     struct intel_crtc_state *crtc_state,
				     intel_clock_t *reduced_clock)
{
	struct drm_device *dev = crtc->base.dev;
	u32 fp, fp2 = 0;

	if (IS_PINEVIEW(dev)) {
		fp = pnv_dpll_compute_fp(&crtc_state->dpll);
		if (reduced_clock)
			fp2 = pnv_dpll_compute_fp(reduced_clock);
	} else {
		fp = i9xx_dpll_compute_fp(&crtc_state->dpll);
		if (reduced_clock)
			fp2 = i9xx_dpll_compute_fp(reduced_clock);
	}

	crtc_state->dpll_hw_state.fp0 = fp;

	crtc->lowfreq_avail = false;
	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS) &&
	    reduced_clock) {
		crtc_state->dpll_hw_state.fp1 = fp2;
		crtc->lowfreq_avail = true;
	} else {
		crtc_state->dpll_hw_state.fp1 = fp;
	}
}

static void vlv_pllb_recal_opamp(struct drm_i915_private *dev_priv, enum pipe
		pipe)
{
	u32 reg_val;

	/*
	 * PLLB opamp always calibrates to max value of 0x3f, force enable it
	 * and set it to a reasonable value instead.
	 */
	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
	reg_val &= 0xffffff00;
	reg_val |= 0x00000030;
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);

	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
	reg_val &= 0x8cffffff;
	reg_val = 0x8c000000;
	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);

	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW9(1));
	reg_val &= 0xffffff00;
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9(1), reg_val);

	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_REF_DW13);
	reg_val &= 0x00ffffff;
	reg_val |= 0xb0000000;
	vlv_dpio_write(dev_priv, pipe, VLV_REF_DW13, reg_val);
}

static void intel_pch_transcoder_set_m_n(struct intel_crtc *crtc,
					 struct intel_link_m_n *m_n)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;

	I915_WRITE(PCH_TRANS_DATA_M1(pipe), TU_SIZE(m_n->tu) | m_n->gmch_m);
	I915_WRITE(PCH_TRANS_DATA_N1(pipe), m_n->gmch_n);
	I915_WRITE(PCH_TRANS_LINK_M1(pipe), m_n->link_m);
	I915_WRITE(PCH_TRANS_LINK_N1(pipe), m_n->link_n);
}

static void intel_cpu_transcoder_set_m_n(struct intel_crtc *crtc,
					 struct intel_link_m_n *m_n,
					 struct intel_link_m_n *m2_n2)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
	enum transcoder transcoder = crtc->config->cpu_transcoder;

	if (INTEL_INFO(dev)->gen >= 5) {
		I915_WRITE(PIPE_DATA_M1(transcoder), TU_SIZE(m_n->tu) | m_n->gmch_m);
		I915_WRITE(PIPE_DATA_N1(transcoder), m_n->gmch_n);
		I915_WRITE(PIPE_LINK_M1(transcoder), m_n->link_m);
		I915_WRITE(PIPE_LINK_N1(transcoder), m_n->link_n);
		/* M2_N2 registers to be set only for gen < 8 (M2_N2 available
		 * for gen < 8) and if DRRS is supported (to make sure the
		 * registers are not unnecessarily accessed).
		 */
		if (m2_n2 && (IS_CHERRYVIEW(dev) || INTEL_INFO(dev)->gen < 8) &&
			crtc->config->has_drrs) {
			I915_WRITE(PIPE_DATA_M2(transcoder),
					TU_SIZE(m2_n2->tu) | m2_n2->gmch_m);
			I915_WRITE(PIPE_DATA_N2(transcoder), m2_n2->gmch_n);
			I915_WRITE(PIPE_LINK_M2(transcoder), m2_n2->link_m);
			I915_WRITE(PIPE_LINK_N2(transcoder), m2_n2->link_n);
		}
	} else {
		I915_WRITE(PIPE_DATA_M_G4X(pipe), TU_SIZE(m_n->tu) | m_n->gmch_m);
		I915_WRITE(PIPE_DATA_N_G4X(pipe), m_n->gmch_n);
		I915_WRITE(PIPE_LINK_M_G4X(pipe), m_n->link_m);
		I915_WRITE(PIPE_LINK_N_G4X(pipe), m_n->link_n);
	}
}

void intel_dp_set_m_n(struct intel_crtc *crtc, enum link_m_n_set m_n)
{
	struct intel_link_m_n *dp_m_n, *dp_m2_n2 = NULL;

	if (m_n == M1_N1) {
		dp_m_n = &crtc->config->dp_m_n;
		dp_m2_n2 = &crtc->config->dp_m2_n2;
	} else if (m_n == M2_N2) {

		/*
		 * M2_N2 registers are not supported. Hence m2_n2 divider value
		 * needs to be programmed into M1_N1.
		 */
		dp_m_n = &crtc->config->dp_m2_n2;
	} else {
		DRM_ERROR("Unsupported divider value\n");
		return;
	}

	if (crtc->config->has_pch_encoder)
		intel_pch_transcoder_set_m_n(crtc, &crtc->config->dp_m_n);
	else
		intel_cpu_transcoder_set_m_n(crtc, dp_m_n, dp_m2_n2);
}

static void vlv_compute_dpll(struct intel_crtc *crtc,
			     struct intel_crtc_state *pipe_config)
{
	u32 dpll, dpll_md;

	/*
	 * Enable DPIO clock input. We should never disable the reference
	 * clock for pipe B, since VGA hotplug / manual detection depends
	 * on it.
	 */
	dpll = DPLL_EXT_BUFFER_ENABLE_VLV | DPLL_REF_CLK_ENABLE_VLV |
		DPLL_VGA_MODE_DIS | DPLL_INTEGRATED_REF_CLK_VLV;
	/* We should never disable this, set it here for state tracking */
	if (crtc->pipe == PIPE_B)
		dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;
	dpll |= DPLL_VCO_ENABLE;
	pipe_config->dpll_hw_state.dpll = dpll;

	dpll_md = (pipe_config->pixel_multiplier - 1)
		<< DPLL_MD_UDI_MULTIPLIER_SHIFT;
	pipe_config->dpll_hw_state.dpll_md = dpll_md;
}

static void vlv_prepare_pll(struct intel_crtc *crtc,
			    const struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
	u32 mdiv;
	u32 bestn, bestm1, bestm2, bestp1, bestp2;
	u32 coreclk, reg_val;

	mutex_lock(&dev_priv->sb_lock);

	bestn = pipe_config->dpll.n;
	bestm1 = pipe_config->dpll.m1;
	bestm2 = pipe_config->dpll.m2;
	bestp1 = pipe_config->dpll.p1;
	bestp2 = pipe_config->dpll.p2;

	/* See eDP HDMI DPIO driver vbios notes doc */

	/* PLL B needs special handling */
	if (pipe == PIPE_B)
		vlv_pllb_recal_opamp(dev_priv, pipe);

	/* Set up Tx target for periodic Rcomp update */
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW9_BCAST, 0x0100000f);

	/* Disable target IRef on PLL */
	reg_val = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW8(pipe));
	reg_val &= 0x00ffffff;
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW8(pipe), reg_val);

	/* Disable fast lock */
	vlv_dpio_write(dev_priv, pipe, VLV_CMN_DW0, 0x610);

	/* Set idtafcrecal before PLL is enabled */
	mdiv = ((bestm1 << DPIO_M1DIV_SHIFT) | (bestm2 & DPIO_M2DIV_MASK));
	mdiv |= ((bestp1 << DPIO_P1_SHIFT) | (bestp2 << DPIO_P2_SHIFT));
	mdiv |= ((bestn << DPIO_N_SHIFT));
	mdiv |= (1 << DPIO_K_SHIFT);

	/*
	 * Post divider depends on pixel clock rate, DAC vs digital (and LVDS,
	 * but we don't support that).
	 * Note: don't use the DAC post divider as it seems unstable.
	 */
	mdiv |= (DPIO_POST_DIV_HDMIDP << DPIO_POST_DIV_SHIFT);
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);

	mdiv |= DPIO_ENABLE_CALIBRATION;
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW3(pipe), mdiv);

	/* Set HBR and RBR LPF coefficients */
	if (pipe_config->port_clock == 162000 ||
	    intel_pipe_has_type(crtc, INTEL_OUTPUT_ANALOG) ||
	    intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI))
		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
				 0x009f0003);
	else
		vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW10(pipe),
				 0x00d0000f);

	if (pipe_config->has_dp_encoder) {
		/* Use SSC source */
		if (pipe == PIPE_A)
			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
					 0x0df40000);
		else
			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
					 0x0df70000);
	} else { /* HDMI or VGA */
		/* Use bend source */
		if (pipe == PIPE_A)
			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
					 0x0df70000);
		else
			vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW5(pipe),
					 0x0df40000);
	}

	coreclk = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW7(pipe));
	coreclk = (coreclk & 0x0000ff00) | 0x01c00000;
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT) ||
	    intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))
		coreclk |= 0x01000000;
	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW7(pipe), coreclk);

	vlv_dpio_write(dev_priv, pipe, VLV_PLL_DW11(pipe), 0x87871000);
	mutex_unlock(&dev_priv->sb_lock);
}

static void chv_compute_dpll(struct intel_crtc *crtc,
			     struct intel_crtc_state *pipe_config)
{
	pipe_config->dpll_hw_state.dpll = DPLL_SSC_REF_CLK_CHV |
		DPLL_REF_CLK_ENABLE_VLV | DPLL_VGA_MODE_DIS |
		DPLL_VCO_ENABLE;
	if (crtc->pipe != PIPE_A)
		pipe_config->dpll_hw_state.dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;

	pipe_config->dpll_hw_state.dpll_md =
		(pipe_config->pixel_multiplier - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;
}

static void chv_prepare_pll(struct intel_crtc *crtc,
			    const struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
	int dpll_reg = DPLL(crtc->pipe);
	enum dpio_channel port = vlv_pipe_to_channel(pipe);
	u32 loopfilter, tribuf_calcntr;
	u32 bestn, bestm1, bestm2, bestp1, bestp2, bestm2_frac;
	u32 dpio_val;
	int vco;

	bestn = pipe_config->dpll.n;
	bestm2_frac = pipe_config->dpll.m2 & 0x3fffff;
	bestm1 = pipe_config->dpll.m1;
	bestm2 = pipe_config->dpll.m2 >> 22;
	bestp1 = pipe_config->dpll.p1;
	bestp2 = pipe_config->dpll.p2;
	vco = pipe_config->dpll.vco;
	dpio_val = 0;
	loopfilter = 0;

	/*
	 * Enable Refclk and SSC
	 */
	I915_WRITE(dpll_reg,
		   pipe_config->dpll_hw_state.dpll & ~DPLL_VCO_ENABLE);

	mutex_lock(&dev_priv->sb_lock);

	/* p1 and p2 divider */
	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW13(port),
			5 << DPIO_CHV_S1_DIV_SHIFT |
			bestp1 << DPIO_CHV_P1_DIV_SHIFT |
			bestp2 << DPIO_CHV_P2_DIV_SHIFT |
			1 << DPIO_CHV_K_DIV_SHIFT);

	/* Feedback post-divider - m2 */
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW0(port), bestm2);

	/* Feedback refclk divider - n and m1 */
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW1(port),
			DPIO_CHV_M1_DIV_BY_2 |
			1 << DPIO_CHV_N_DIV_SHIFT);

	/* M2 fraction division */
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW2(port), bestm2_frac);

	/* M2 fraction division enable */
	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));
	dpio_val &= ~(DPIO_CHV_FEEDFWD_GAIN_MASK | DPIO_CHV_FRAC_DIV_EN);
	dpio_val |= (2 << DPIO_CHV_FEEDFWD_GAIN_SHIFT);
	if (bestm2_frac)
		dpio_val |= DPIO_CHV_FRAC_DIV_EN;
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW3(port), dpio_val);

	/* Program digital lock detect threshold */
	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW9(port));
	dpio_val &= ~(DPIO_CHV_INT_LOCK_THRESHOLD_MASK |
					DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE);
	dpio_val |= (0x5 << DPIO_CHV_INT_LOCK_THRESHOLD_SHIFT);
	if (!bestm2_frac)
		dpio_val |= DPIO_CHV_INT_LOCK_THRESHOLD_SEL_COARSE;
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW9(port), dpio_val);

	/* Loop filter */
	if (vco == 5400000) {
		loopfilter |= (0x3 << DPIO_CHV_PROP_COEFF_SHIFT);
		loopfilter |= (0x8 << DPIO_CHV_INT_COEFF_SHIFT);
		loopfilter |= (0x1 << DPIO_CHV_GAIN_CTRL_SHIFT);
		tribuf_calcntr = 0x9;
	} else if (vco <= 6200000) {
		loopfilter |= (0x5 << DPIO_CHV_PROP_COEFF_SHIFT);
		loopfilter |= (0xB << DPIO_CHV_INT_COEFF_SHIFT);
		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
		tribuf_calcntr = 0x9;
	} else if (vco <= 6480000) {
		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
		tribuf_calcntr = 0x8;
	} else {
		/* Not supported. Apply the same limits as in the max case */
		loopfilter |= (0x4 << DPIO_CHV_PROP_COEFF_SHIFT);
		loopfilter |= (0x9 << DPIO_CHV_INT_COEFF_SHIFT);
		loopfilter |= (0x3 << DPIO_CHV_GAIN_CTRL_SHIFT);
		tribuf_calcntr = 0;
	}
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW6(port), loopfilter);

	dpio_val = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW8(port));
	dpio_val &= ~DPIO_CHV_TDC_TARGET_CNT_MASK;
	dpio_val |= (tribuf_calcntr << DPIO_CHV_TDC_TARGET_CNT_SHIFT);
	vlv_dpio_write(dev_priv, pipe, CHV_PLL_DW8(port), dpio_val);

	/* AFC Recal */
	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW14(port),
			vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW14(port)) |
			DPIO_AFC_RECAL);

	mutex_unlock(&dev_priv->sb_lock);
}

/**
 * vlv_force_pll_on - forcibly enable just the PLL
 * @@dev_priv: i915 private structure
 * @@pipe: pipe PLL to enable
 * @@dpll: PLL configuration
 *
 * Enable the PLL for @@pipe using the supplied @@dpll config. To be used
 * in cases where we need the PLL enabled even when @@pipe is not going to
 * be enabled.
 */
void vlv_force_pll_on(struct drm_device *dev, enum pipe pipe,
		      const struct dpll *dpll)
{
	struct intel_crtc *crtc =
		to_intel_crtc(intel_get_crtc_for_pipe(dev, pipe));
	struct intel_crtc_state pipe_config = {
		.base.crtc = &crtc->base,
		.pixel_multiplier = 1,
		.dpll = *dpll,
	};

	if (IS_CHERRYVIEW(dev)) {
		chv_compute_dpll(crtc, &pipe_config);
		chv_prepare_pll(crtc, &pipe_config);
		chv_enable_pll(crtc, &pipe_config);
	} else {
		vlv_compute_dpll(crtc, &pipe_config);
		vlv_prepare_pll(crtc, &pipe_config);
		vlv_enable_pll(crtc, &pipe_config);
	}
}

/**
 * vlv_force_pll_off - forcibly disable just the PLL
 * @@dev_priv: i915 private structure
 * @@pipe: pipe PLL to disable
 *
 * Disable the PLL for @@pipe. To be used in cases where we need
 * the PLL enabled even when @@pipe is not going to be enabled.
 */
void vlv_force_pll_off(struct drm_device *dev, enum pipe pipe)
{
	if (IS_CHERRYVIEW(dev))
		chv_disable_pll(to_i915(dev), pipe);
	else
		vlv_disable_pll(to_i915(dev), pipe);
}

static void i9xx_compute_dpll(struct intel_crtc *crtc,
			      struct intel_crtc_state *crtc_state,
			      intel_clock_t *reduced_clock,
			      int num_connectors)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpll;
	bool is_sdvo;
	struct dpll *clock = &crtc_state->dpll;

	i9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);

	is_sdvo = intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_SDVO) ||
		intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_HDMI);

	dpll = DPLL_VGA_MODE_DIS;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS))
		dpll |= DPLLB_MODE_LVDS;
	else
		dpll |= DPLLB_MODE_DAC_SERIAL;

	if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev)) {
		dpll |= (crtc_state->pixel_multiplier - 1)
			<< SDVO_MULTIPLIER_SHIFT_HIRES;
	}

	if (is_sdvo)
		dpll |= DPLL_SDVO_HIGH_SPEED;

	if (crtc_state->has_dp_encoder)
		dpll |= DPLL_SDVO_HIGH_SPEED;

	/* compute bitmask from p1 value */
	if (IS_PINEVIEW(dev))
		dpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW;
	else {
		dpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
		if (IS_G4X(dev) && reduced_clock)
			dpll |= (1 << (reduced_clock->p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;
	}
	switch (clock->p2) {
	case 5:
		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;
		break;
	case 7:
		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;
		break;
	case 10:
		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;
		break;
	case 14:
		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;
		break;
	}
	if (INTEL_INFO(dev)->gen >= 4)
		dpll |= (6 << PLL_LOAD_PULSE_PHASE_SHIFT);

	if (crtc_state->sdvo_tv_clock)
		dpll |= PLL_REF_INPUT_TVCLKINBC;
	else if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS) &&
		 intel_panel_use_ssc(dev_priv) && num_connectors < 2)
		dpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;
	else
		dpll |= PLL_REF_INPUT_DREFCLK;

	dpll |= DPLL_VCO_ENABLE;
	crtc_state->dpll_hw_state.dpll = dpll;

	if (INTEL_INFO(dev)->gen >= 4) {
		u32 dpll_md = (crtc_state->pixel_multiplier - 1)
			<< DPLL_MD_UDI_MULTIPLIER_SHIFT;
		crtc_state->dpll_hw_state.dpll_md = dpll_md;
	}
}

static void i8xx_compute_dpll(struct intel_crtc *crtc,
			      struct intel_crtc_state *crtc_state,
			      intel_clock_t *reduced_clock,
			      int num_connectors)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpll;
	struct dpll *clock = &crtc_state->dpll;

	i9xx_update_pll_dividers(crtc, crtc_state, reduced_clock);

	dpll = DPLL_VGA_MODE_DIS;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS)) {
		dpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
	} else {
		if (clock->p1 == 2)
			dpll |= PLL_P1_DIVIDE_BY_TWO;
		else
			dpll |= (clock->p1 - 2) << DPLL_FPA01_P1_POST_DIV_SHIFT;
		if (clock->p2 == 4)
			dpll |= PLL_P2_DIVIDE_BY_4;
	}

	if (!IS_I830(dev) && intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_DVO))
		dpll |= DPLL_DVO_2X_MODE;

	if (intel_pipe_will_have_type(crtc_state, INTEL_OUTPUT_LVDS) &&
		 intel_panel_use_ssc(dev_priv) && num_connectors < 2)
		dpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;
	else
		dpll |= PLL_REF_INPUT_DREFCLK;

	dpll |= DPLL_VCO_ENABLE;
	crtc_state->dpll_hw_state.dpll = dpll;
}

static void intel_set_pipe_timings(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = intel_crtc->pipe;
	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;
	const struct drm_display_mode *adjusted_mode = &intel_crtc->config->base.adjusted_mode;
	uint32_t crtc_vtotal, crtc_vblank_end;
	int vsyncshift = 0;

	/* We need to be careful not to changed the adjusted mode, for otherwise
	 * the hw state checker will get angry at the mismatch. */
	crtc_vtotal = adjusted_mode->crtc_vtotal;
	crtc_vblank_end = adjusted_mode->crtc_vblank_end;

	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {
		/* the chip adds 2 halflines automatically */
		crtc_vtotal -= 1;
		crtc_vblank_end -= 1;

		if (intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_SDVO))
			vsyncshift = (adjusted_mode->crtc_htotal - 1) / 2;
		else
			vsyncshift = adjusted_mode->crtc_hsync_start -
				adjusted_mode->crtc_htotal / 2;
		if (vsyncshift < 0)
			vsyncshift += adjusted_mode->crtc_htotal;
	}

	if (INTEL_INFO(dev)->gen > 3)
		I915_WRITE(VSYNCSHIFT(cpu_transcoder), vsyncshift);

	I915_WRITE(HTOTAL(cpu_transcoder),
		   (adjusted_mode->crtc_hdisplay - 1) |
		   ((adjusted_mode->crtc_htotal - 1) << 16));
	I915_WRITE(HBLANK(cpu_transcoder),
		   (adjusted_mode->crtc_hblank_start - 1) |
		   ((adjusted_mode->crtc_hblank_end - 1) << 16));
	I915_WRITE(HSYNC(cpu_transcoder),
		   (adjusted_mode->crtc_hsync_start - 1) |
		   ((adjusted_mode->crtc_hsync_end - 1) << 16));

	I915_WRITE(VTOTAL(cpu_transcoder),
		   (adjusted_mode->crtc_vdisplay - 1) |
		   ((crtc_vtotal - 1) << 16));
	I915_WRITE(VBLANK(cpu_transcoder),
		   (adjusted_mode->crtc_vblank_start - 1) |
		   ((crtc_vblank_end - 1) << 16));
	I915_WRITE(VSYNC(cpu_transcoder),
		   (adjusted_mode->crtc_vsync_start - 1) |
		   ((adjusted_mode->crtc_vsync_end - 1) << 16));

	/* Workaround: when the EDP input selection is B, the VTOTAL_B must be
	 * programmed with the VTOTAL_EDP value. Same for VTOTAL_C. This is
	 * documented on the DDI_FUNC_CTL register description, EDP Input Select
	 * bits. */
	if (IS_HASWELL(dev) && cpu_transcoder == TRANSCODER_EDP &&
	    (pipe == PIPE_B || pipe == PIPE_C))
		I915_WRITE(VTOTAL(pipe), I915_READ(VTOTAL(cpu_transcoder)));

	/* pipesrc controls the size that is scaled from, which should
	 * always be the user's requested size.
	 */
	I915_WRITE(PIPESRC(pipe),
		   ((intel_crtc->config->pipe_src_w - 1) << 16) |
		   (intel_crtc->config->pipe_src_h - 1));
}

static void intel_get_pipe_timings(struct intel_crtc *crtc,
				   struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum transcoder cpu_transcoder = pipe_config->cpu_transcoder;
	uint32_t tmp;

	tmp = I915_READ(HTOTAL(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_hdisplay = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_htotal = ((tmp >> 16) & 0xffff) + 1;
	tmp = I915_READ(HBLANK(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_hblank_start = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_hblank_end = ((tmp >> 16) & 0xffff) + 1;
	tmp = I915_READ(HSYNC(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_hsync_start = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_hsync_end = ((tmp >> 16) & 0xffff) + 1;

	tmp = I915_READ(VTOTAL(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_vdisplay = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_vtotal = ((tmp >> 16) & 0xffff) + 1;
	tmp = I915_READ(VBLANK(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_vblank_start = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_vblank_end = ((tmp >> 16) & 0xffff) + 1;
	tmp = I915_READ(VSYNC(cpu_transcoder));
	pipe_config->base.adjusted_mode.crtc_vsync_start = (tmp & 0xffff) + 1;
	pipe_config->base.adjusted_mode.crtc_vsync_end = ((tmp >> 16) & 0xffff) + 1;

	if (I915_READ(PIPECONF(cpu_transcoder)) & PIPECONF_INTERLACE_MASK) {
		pipe_config->base.adjusted_mode.flags |= DRM_MODE_FLAG_INTERLACE;
		pipe_config->base.adjusted_mode.crtc_vtotal += 1;
		pipe_config->base.adjusted_mode.crtc_vblank_end += 1;
	}

	tmp = I915_READ(PIPESRC(crtc->pipe));
	pipe_config->pipe_src_h = (tmp & 0xffff) + 1;
	pipe_config->pipe_src_w = ((tmp >> 16) & 0xffff) + 1;

	pipe_config->base.mode.vdisplay = pipe_config->pipe_src_h;
	pipe_config->base.mode.hdisplay = pipe_config->pipe_src_w;
}

void intel_mode_from_pipe_config(struct drm_display_mode *mode,
				 struct intel_crtc_state *pipe_config)
{
	mode->hdisplay = pipe_config->base.adjusted_mode.crtc_hdisplay;
	mode->htotal = pipe_config->base.adjusted_mode.crtc_htotal;
	mode->hsync_start = pipe_config->base.adjusted_mode.crtc_hsync_start;
	mode->hsync_end = pipe_config->base.adjusted_mode.crtc_hsync_end;

	mode->vdisplay = pipe_config->base.adjusted_mode.crtc_vdisplay;
	mode->vtotal = pipe_config->base.adjusted_mode.crtc_vtotal;
	mode->vsync_start = pipe_config->base.adjusted_mode.crtc_vsync_start;
	mode->vsync_end = pipe_config->base.adjusted_mode.crtc_vsync_end;

	mode->flags = pipe_config->base.adjusted_mode.flags;
	mode->type = DRM_MODE_TYPE_DRIVER;

	mode->clock = pipe_config->base.adjusted_mode.crtc_clock;
	mode->flags |= pipe_config->base.adjusted_mode.flags;

	mode->hsync = drm_mode_hsync(mode);
	mode->vrefresh = drm_mode_vrefresh(mode);
	drm_mode_set_name(mode);
}

static void i9xx_set_pipeconf(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t pipeconf;

	pipeconf = 0;

	if ((intel_crtc->pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) ||
	    (intel_crtc->pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE))
		pipeconf |= I915_READ(PIPECONF(intel_crtc->pipe)) & PIPECONF_ENABLE;

	if (intel_crtc->config->double_wide)
		pipeconf |= PIPECONF_DOUBLE_WIDE;

	/* only g4x and later have fancy bpc/dither controls */
	if (IS_G4X(dev) || IS_VALLEYVIEW(dev)) {
		/* Bspec claims that we can't use dithering for 30bpp pipes. */
		if (intel_crtc->config->dither && intel_crtc->config->pipe_bpp != 30)
			pipeconf |= PIPECONF_DITHER_EN |
				    PIPECONF_DITHER_TYPE_SP;

		switch (intel_crtc->config->pipe_bpp) {
		case 18:
			pipeconf |= PIPECONF_6BPC;
			break;
		case 24:
			pipeconf |= PIPECONF_8BPC;
			break;
		case 30:
			pipeconf |= PIPECONF_10BPC;
			break;
		default:
			/* Case prevented by intel_choose_pipe_bpp_dither. */
			BUG();
		}
	}

	if (HAS_PIPE_CXSR(dev)) {
		if (intel_crtc->lowfreq_avail) {
			DRM_DEBUG_KMS("enabling CxSR downclocking\n");
			pipeconf |= PIPECONF_CXSR_DOWNCLOCK;
		} else {
			DRM_DEBUG_KMS("disabling CxSR downclocking\n");
		}
	}

	if (intel_crtc->config->base.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {
		if (INTEL_INFO(dev)->gen < 4 ||
		    intel_pipe_has_type(intel_crtc, INTEL_OUTPUT_SDVO))
			pipeconf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;
		else
			pipeconf |= PIPECONF_INTERLACE_W_SYNC_SHIFT;
	} else
		pipeconf |= PIPECONF_PROGRESSIVE;

	if (IS_VALLEYVIEW(dev) && intel_crtc->config->limited_color_range)
		pipeconf |= PIPECONF_COLOR_RANGE_SELECT;

	I915_WRITE(PIPECONF(intel_crtc->pipe), pipeconf);
	POSTING_READ(PIPECONF(intel_crtc->pipe));
}

static int i9xx_crtc_compute_clock(struct intel_crtc *crtc,
				   struct intel_crtc_state *crtc_state)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int refclk, num_connectors = 0;
	intel_clock_t clock;
	bool ok;
	bool is_dsi = false;
	struct intel_encoder *encoder;
	const intel_limit_t *limit;
	struct drm_atomic_state *state = crtc_state->base.state;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	int i;

	memset(&crtc_state->dpll_hw_state, 0,
	       sizeof(crtc_state->dpll_hw_state));

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != &crtc->base)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);

		switch (encoder->type) {
		case INTEL_OUTPUT_DSI:
			is_dsi = true;
			break;
		default:
			break;
		}

		num_connectors++;
	}

	if (is_dsi)
		return 0;

	if (!crtc_state->clock_set) {
		refclk = i9xx_get_refclk(crtc_state, num_connectors);

		/*
		 * Returns a set of divisors for the desired target clock with
		 * the given refclk, or FALSE.  The returned values represent
		 * the clock equation: reflck * (5 * (m1 + 2) + (m2 + 2)) / (n +
		 * 2) / p1 / p2.
		 */
		limit = intel_limit(crtc_state, refclk);
		ok = dev_priv->display.find_dpll(limit, crtc_state,
						 crtc_state->port_clock,
						 refclk, NULL, &clock);
		if (!ok) {
			DRM_ERROR("Couldn't find PLL settings for mode!\n");
			return -EINVAL;
		}

		/* Compat-code for transition, will disappear. */
		crtc_state->dpll.n = clock.n;
		crtc_state->dpll.m1 = clock.m1;
		crtc_state->dpll.m2 = clock.m2;
		crtc_state->dpll.p1 = clock.p1;
		crtc_state->dpll.p2 = clock.p2;
	}

	if (IS_GEN2(dev)) {
		i8xx_compute_dpll(crtc, crtc_state, NULL,
				  num_connectors);
	} else if (IS_CHERRYVIEW(dev)) {
		chv_compute_dpll(crtc, crtc_state);
	} else if (IS_VALLEYVIEW(dev)) {
		vlv_compute_dpll(crtc, crtc_state);
	} else {
		i9xx_compute_dpll(crtc, crtc_state, NULL,
				  num_connectors);
	}

	return 0;
}

static void i9xx_get_pfit_config(struct intel_crtc *crtc,
				 struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t tmp;

	if (INTEL_INFO(dev)->gen <= 3 && (IS_I830(dev) || !IS_MOBILE(dev)))
		return;

	tmp = I915_READ(PFIT_CONTROL);
	if (!(tmp & PFIT_ENABLE))
		return;

	/* Check whether the pfit is attached to our pipe. */
	if (INTEL_INFO(dev)->gen < 4) {
		if (crtc->pipe != PIPE_B)
			return;
	} else {
		if ((tmp & PFIT_PIPE_MASK) != (crtc->pipe << PFIT_PIPE_SHIFT))
			return;
	}

	pipe_config->gmch_pfit.control = tmp;
	pipe_config->gmch_pfit.pgm_ratios = I915_READ(PFIT_PGM_RATIOS);
	if (INTEL_INFO(dev)->gen < 5)
		pipe_config->gmch_pfit.lvds_border_bits =
			I915_READ(LVDS) & LVDS_BORDER_ENABLE;
}

static void vlv_crtc_clock_get(struct intel_crtc *crtc,
			       struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = pipe_config->cpu_transcoder;
	intel_clock_t clock;
	u32 mdiv;
	int refclk = 100000;

	/* In case of MIPI DPLL will not even be used */
	if (!(pipe_config->dpll_hw_state.dpll & DPLL_VCO_ENABLE))
		return;

	mutex_lock(&dev_priv->sb_lock);
	mdiv = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW3(pipe));
	mutex_unlock(&dev_priv->sb_lock);

	clock.m1 = (mdiv >> DPIO_M1DIV_SHIFT) & 7;
	clock.m2 = mdiv & DPIO_M2DIV_MASK;
	clock.n = (mdiv >> DPIO_N_SHIFT) & 0xf;
	clock.p1 = (mdiv >> DPIO_P1_SHIFT) & 7;
	clock.p2 = (mdiv >> DPIO_P2_SHIFT) & 0x1f;

	pipe_config->port_clock = vlv_calc_dpll_params(refclk, &clock);
}

static void
i9xx_get_initial_plane_config(struct intel_crtc *crtc,
			      struct intel_initial_plane_config *plane_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, base, offset;
	int pipe = crtc->pipe, plane = crtc->plane;
	int fourcc, pixel_format;
	unsigned int aligned_height;
	struct drm_framebuffer *fb;
	struct intel_framebuffer *intel_fb;

	val = I915_READ(DSPCNTR(plane));
	if (!(val & DISPLAY_PLANE_ENABLE))
		return;

	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
	if (!intel_fb) {
		DRM_DEBUG_KMS("failed to alloc fb\n");
		return;
	}

	fb = &intel_fb->base;

	if (INTEL_INFO(dev)->gen >= 4) {
		if (val & DISPPLANE_TILED) {
			plane_config->tiling = I915_TILING_X;
			fb->modifier[0] = I915_FORMAT_MOD_X_TILED;
		}
	}

	pixel_format = val & DISPPLANE_PIXFORMAT_MASK;
	fourcc = i9xx_format_to_fourcc(pixel_format);
	fb->pixel_format = fourcc;
	fb->bits_per_pixel = drm_format_plane_cpp(fourcc, 0) * 8;

	if (INTEL_INFO(dev)->gen >= 4) {
		if (plane_config->tiling)
			offset = I915_READ(DSPTILEOFF(plane));
		else
			offset = I915_READ(DSPLINOFF(plane));
		base = I915_READ(DSPSURF(plane)) & 0xfffff000;
	} else {
		base = I915_READ(DSPADDR(plane));
	}
	plane_config->base = base;

	val = I915_READ(PIPESRC(pipe));
	fb->width = ((val >> 16) & 0xfff) + 1;
	fb->height = ((val >> 0) & 0xfff) + 1;

	val = I915_READ(DSPSTRIDE(pipe));
	fb->pitches[0] = val & 0xffffffc0;

	aligned_height = intel_fb_align_height(dev, fb->height,
					       fb->pixel_format,
					       fb->modifier[0]);

	plane_config->size = fb->pitches[0] * aligned_height;

	DRM_DEBUG_KMS("pipe/plane %c/%d with fb: size=%dx%d@@%d, offset=%x, pitch %d, size 0x%x\n",
		      pipe_name(pipe), plane, fb->width, fb->height,
		      fb->bits_per_pixel, base, fb->pitches[0],
		      plane_config->size);

	plane_config->fb = intel_fb;
}

static void chv_crtc_clock_get(struct intel_crtc *crtc,
			       struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = pipe_config->cpu_transcoder;
	enum dpio_channel port = vlv_pipe_to_channel(pipe);
	intel_clock_t clock;
	u32 cmn_dw13, pll_dw0, pll_dw1, pll_dw2, pll_dw3;
	int refclk = 100000;

	mutex_lock(&dev_priv->sb_lock);
	cmn_dw13 = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW13(port));
	pll_dw0 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW0(port));
	pll_dw1 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW1(port));
	pll_dw2 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW2(port));
	pll_dw3 = vlv_dpio_read(dev_priv, pipe, CHV_PLL_DW3(port));
	mutex_unlock(&dev_priv->sb_lock);

	clock.m1 = (pll_dw1 & 0x7) == DPIO_CHV_M1_DIV_BY_2 ? 2 : 0;
	clock.m2 = (pll_dw0 & 0xff) << 22;
	if (pll_dw3 & DPIO_CHV_FRAC_DIV_EN)
		clock.m2 |= pll_dw2 & 0x3fffff;
	clock.n = (pll_dw1 >> DPIO_CHV_N_DIV_SHIFT) & 0xf;
	clock.p1 = (cmn_dw13 >> DPIO_CHV_P1_DIV_SHIFT) & 0x7;
	clock.p2 = (cmn_dw13 >> DPIO_CHV_P2_DIV_SHIFT) & 0x1f;

	pipe_config->port_clock = chv_calc_dpll_params(refclk, &clock);
}

static bool i9xx_get_pipe_config(struct intel_crtc *crtc,
				 struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t tmp;

	if (!intel_display_power_is_enabled(dev_priv,
					    POWER_DOMAIN_PIPE(crtc->pipe)))
		return false;

	pipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;
	pipe_config->shared_dpll = DPLL_ID_PRIVATE;

	tmp = I915_READ(PIPECONF(crtc->pipe));
	if (!(tmp & PIPECONF_ENABLE))
		return false;

	if (IS_G4X(dev) || IS_VALLEYVIEW(dev)) {
		switch (tmp & PIPECONF_BPC_MASK) {
		case PIPECONF_6BPC:
			pipe_config->pipe_bpp = 18;
			break;
		case PIPECONF_8BPC:
			pipe_config->pipe_bpp = 24;
			break;
		case PIPECONF_10BPC:
			pipe_config->pipe_bpp = 30;
			break;
		default:
			break;
		}
	}

	if (IS_VALLEYVIEW(dev) && (tmp & PIPECONF_COLOR_RANGE_SELECT))
		pipe_config->limited_color_range = true;

	if (INTEL_INFO(dev)->gen < 4)
		pipe_config->double_wide = tmp & PIPECONF_DOUBLE_WIDE;

	intel_get_pipe_timings(crtc, pipe_config);

	i9xx_get_pfit_config(crtc, pipe_config);

	if (INTEL_INFO(dev)->gen >= 4) {
		tmp = I915_READ(DPLL_MD(crtc->pipe));
		pipe_config->pixel_multiplier =
			((tmp & DPLL_MD_UDI_MULTIPLIER_MASK)
			 >> DPLL_MD_UDI_MULTIPLIER_SHIFT) + 1;
		pipe_config->dpll_hw_state.dpll_md = tmp;
	} else if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev)) {
		tmp = I915_READ(DPLL(crtc->pipe));
		pipe_config->pixel_multiplier =
			((tmp & SDVO_MULTIPLIER_MASK)
			 >> SDVO_MULTIPLIER_SHIFT_HIRES) + 1;
	} else {
		/* Note that on i915G/GM the pixel multiplier is in the sdvo
		 * port and will be fixed up in the encoder->get_config
		 * function. */
		pipe_config->pixel_multiplier = 1;
	}
	pipe_config->dpll_hw_state.dpll = I915_READ(DPLL(crtc->pipe));
	if (!IS_VALLEYVIEW(dev)) {
		/*
		 * DPLL_DVO_2X_MODE must be enabled for both DPLLs
		 * on 830. Filter it out here so that we don't
		 * report errors due to that.
		 */
		if (IS_I830(dev))
			pipe_config->dpll_hw_state.dpll &= ~DPLL_DVO_2X_MODE;

		pipe_config->dpll_hw_state.fp0 = I915_READ(FP0(crtc->pipe));
		pipe_config->dpll_hw_state.fp1 = I915_READ(FP1(crtc->pipe));
	} else {
		/* Mask out read-only status bits. */
		pipe_config->dpll_hw_state.dpll &= ~(DPLL_LOCK_VLV |
						     DPLL_PORTC_READY_MASK |
						     DPLL_PORTB_READY_MASK);
	}

	if (IS_CHERRYVIEW(dev))
		chv_crtc_clock_get(crtc, pipe_config);
	else if (IS_VALLEYVIEW(dev))
		vlv_crtc_clock_get(crtc, pipe_config);
	else
		i9xx_crtc_clock_get(crtc, pipe_config);

	/*
	 * Normally the dotclock is filled in by the encoder .get_config()
	 * but in case the pipe is enabled w/o any ports we need a sane
	 * default.
	 */
	pipe_config->base.adjusted_mode.crtc_clock =
		pipe_config->port_clock / pipe_config->pixel_multiplier;

	return true;
}

static void ironlake_init_pch_refclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;
	int i;
	u32 val, final;
	bool has_lvds = false;
	bool has_cpu_edp = false;
	bool has_panel = false;
	bool has_ck505 = false;
	bool can_ssc = false;
	bool using_ssc_source = false;

	/* We need to take the global config into account */
	for_each_intel_encoder(dev, encoder) {
		switch (encoder->type) {
		case INTEL_OUTPUT_LVDS:
			has_panel = true;
			has_lvds = true;
			break;
		case INTEL_OUTPUT_EDP:
			has_panel = true;
			if (enc_to_dig_port(&encoder->base)->port == PORT_A)
				has_cpu_edp = true;
			break;
		default:
			break;
		}
	}

	if (HAS_PCH_IBX(dev)) {
		has_ck505 = dev_priv->vbt.display_clock_mode;
		can_ssc = has_ck505;
	} else {
		has_ck505 = false;
		can_ssc = true;
	}

	/* Check if any DPLLs are using the SSC source */
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		u32 temp = I915_READ(PCH_DPLL(i));

		if (!(temp & DPLL_VCO_ENABLE))
			continue;

		if ((temp & PLL_REF_INPUT_MASK) ==
		    PLLB_REF_INPUT_SPREADSPECTRUMIN) {
			using_ssc_source = true;
			break;
		}
	}

	DRM_DEBUG_KMS("has_panel %d has_lvds %d has_ck505 %d using_ssc_source %d\n",
		      has_panel, has_lvds, has_ck505, using_ssc_source);

	/* Ironlake: try to setup display ref clock before DPLL
	 * enabling. This is only under driver's control after
	 * PCH B stepping, previous chipset stepping should be
	 * ignoring this setting.
	 */
	val = I915_READ(PCH_DREF_CONTROL);

	/* As we must carefully and slowly disable/enable each source in turn,
	 * compute the final state we want first and check if we need to
	 * make any changes at all.
	 */
	final = val;
	final &= ~DREF_NONSPREAD_SOURCE_MASK;
	if (has_ck505)
		final |= DREF_NONSPREAD_CK505_ENABLE;
	else
		final |= DREF_NONSPREAD_SOURCE_ENABLE;

	final &= ~DREF_SSC_SOURCE_MASK;
	final &= ~DREF_CPU_SOURCE_OUTPUT_MASK;
	final &= ~DREF_SSC1_ENABLE;

	if (has_panel) {
		final |= DREF_SSC_SOURCE_ENABLE;

		if (intel_panel_use_ssc(dev_priv) && can_ssc)
			final |= DREF_SSC1_ENABLE;

		if (has_cpu_edp) {
			if (intel_panel_use_ssc(dev_priv) && can_ssc)
				final |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;
			else
				final |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;
		} else
			final |= DREF_CPU_SOURCE_OUTPUT_DISABLE;
	} else if (using_ssc_source) {
		final |= DREF_SSC_SOURCE_ENABLE;
		final |= DREF_SSC1_ENABLE;
	}

	if (final == val)
		return;

	/* Always enable nonspread source */
	val &= ~DREF_NONSPREAD_SOURCE_MASK;

	if (has_ck505)
		val |= DREF_NONSPREAD_CK505_ENABLE;
	else
		val |= DREF_NONSPREAD_SOURCE_ENABLE;

	if (has_panel) {
		val &= ~DREF_SSC_SOURCE_MASK;
		val |= DREF_SSC_SOURCE_ENABLE;

		/* SSC must be turned on before enabling the CPU output  */
		if (intel_panel_use_ssc(dev_priv) && can_ssc) {
			DRM_DEBUG_KMS("Using SSC on panel\n");
			val |= DREF_SSC1_ENABLE;
		} else
			val &= ~DREF_SSC1_ENABLE;

		/* Get SSC going before enabling the outputs */
		I915_WRITE(PCH_DREF_CONTROL, val);
		POSTING_READ(PCH_DREF_CONTROL);
		udelay(200);

		val &= ~DREF_CPU_SOURCE_OUTPUT_MASK;

		/* Enable CPU source on CPU attached eDP */
		if (has_cpu_edp) {
			if (intel_panel_use_ssc(dev_priv) && can_ssc) {
				DRM_DEBUG_KMS("Using SSC on eDP\n");
				val |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;
			} else
				val |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;
		} else
			val |= DREF_CPU_SOURCE_OUTPUT_DISABLE;

		I915_WRITE(PCH_DREF_CONTROL, val);
		POSTING_READ(PCH_DREF_CONTROL);
		udelay(200);
	} else {
		DRM_DEBUG_KMS("Disabling CPU source output\n");

		val &= ~DREF_CPU_SOURCE_OUTPUT_MASK;

		/* Turn off CPU output */
		val |= DREF_CPU_SOURCE_OUTPUT_DISABLE;

		I915_WRITE(PCH_DREF_CONTROL, val);
		POSTING_READ(PCH_DREF_CONTROL);
		udelay(200);

		if (!using_ssc_source) {
			DRM_DEBUG_KMS("Disabling SSC source\n");

			/* Turn off the SSC source */
			val &= ~DREF_SSC_SOURCE_MASK;
			val |= DREF_SSC_SOURCE_DISABLE;

			/* Turn off SSC1 */
			val &= ~DREF_SSC1_ENABLE;

			I915_WRITE(PCH_DREF_CONTROL, val);
			POSTING_READ(PCH_DREF_CONTROL);
			udelay(200);
		}
	}

	BUG_ON(val != final);
}

static void lpt_reset_fdi_mphy(struct drm_i915_private *dev_priv)
{
	uint32_t tmp;

	tmp = I915_READ(SOUTH_CHICKEN2);
	tmp |= FDI_MPHY_IOSFSB_RESET_CTL;
	I915_WRITE(SOUTH_CHICKEN2, tmp);

	if (wait_for_atomic_us(I915_READ(SOUTH_CHICKEN2) &
			       FDI_MPHY_IOSFSB_RESET_STATUS, 100))
		DRM_ERROR("FDI mPHY reset assert timeout\n");

	tmp = I915_READ(SOUTH_CHICKEN2);
	tmp &= ~FDI_MPHY_IOSFSB_RESET_CTL;
	I915_WRITE(SOUTH_CHICKEN2, tmp);

	if (wait_for_atomic_us((I915_READ(SOUTH_CHICKEN2) &
				FDI_MPHY_IOSFSB_RESET_STATUS) == 0, 100))
		DRM_ERROR("FDI mPHY reset de-assert timeout\n");
}

/* WaMPhyProgramming:hsw */
static void lpt_program_fdi_mphy(struct drm_i915_private *dev_priv)
{
	uint32_t tmp;

	tmp = intel_sbi_read(dev_priv, 0x8008, SBI_MPHY);
	tmp &= ~(0xFF << 24);
	tmp |= (0x12 << 24);
	intel_sbi_write(dev_priv, 0x8008, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2008, SBI_MPHY);
	tmp |= (1 << 11);
	intel_sbi_write(dev_priv, 0x2008, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2108, SBI_MPHY);
	tmp |= (1 << 11);
	intel_sbi_write(dev_priv, 0x2108, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x206C, SBI_MPHY);
	tmp |= (1 << 24) | (1 << 21) | (1 << 18);
	intel_sbi_write(dev_priv, 0x206C, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x216C, SBI_MPHY);
	tmp |= (1 << 24) | (1 << 21) | (1 << 18);
	intel_sbi_write(dev_priv, 0x216C, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2080, SBI_MPHY);
	tmp &= ~(7 << 13);
	tmp |= (5 << 13);
	intel_sbi_write(dev_priv, 0x2080, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2180, SBI_MPHY);
	tmp &= ~(7 << 13);
	tmp |= (5 << 13);
	intel_sbi_write(dev_priv, 0x2180, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x208C, SBI_MPHY);
	tmp &= ~0xFF;
	tmp |= 0x1C;
	intel_sbi_write(dev_priv, 0x208C, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x218C, SBI_MPHY);
	tmp &= ~0xFF;
	tmp |= 0x1C;
	intel_sbi_write(dev_priv, 0x218C, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2098, SBI_MPHY);
	tmp &= ~(0xFF << 16);
	tmp |= (0x1C << 16);
	intel_sbi_write(dev_priv, 0x2098, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x2198, SBI_MPHY);
	tmp &= ~(0xFF << 16);
	tmp |= (0x1C << 16);
	intel_sbi_write(dev_priv, 0x2198, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x20C4, SBI_MPHY);
	tmp |= (1 << 27);
	intel_sbi_write(dev_priv, 0x20C4, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x21C4, SBI_MPHY);
	tmp |= (1 << 27);
	intel_sbi_write(dev_priv, 0x21C4, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x20EC, SBI_MPHY);
	tmp &= ~(0xF << 28);
	tmp |= (4 << 28);
	intel_sbi_write(dev_priv, 0x20EC, tmp, SBI_MPHY);

	tmp = intel_sbi_read(dev_priv, 0x21EC, SBI_MPHY);
	tmp &= ~(0xF << 28);
	tmp |= (4 << 28);
	intel_sbi_write(dev_priv, 0x21EC, tmp, SBI_MPHY);
}

/* Implements 3 different sequences from BSpec chapter "Display iCLK
 * Programming" based on the parameters passed:
 * - Sequence to enable CLKOUT_DP
 * - Sequence to enable CLKOUT_DP without spread
 * - Sequence to enable CLKOUT_DP for FDI usage and configure PCH FDI I/O
 */
static void lpt_enable_clkout_dp(struct drm_device *dev, bool with_spread,
				 bool with_fdi)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t reg, tmp;

	if (WARN(with_fdi && !with_spread, "FDI requires downspread\n"))
		with_spread = true;
	if (WARN(HAS_PCH_LPT_LP(dev) && with_fdi, "LP PCH doesn't have FDI\n"))
		with_fdi = false;

	mutex_lock(&dev_priv->sb_lock);

	tmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);
	tmp &= ~SBI_SSCCTL_DISABLE;
	tmp |= SBI_SSCCTL_PATHALT;
	intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);

	udelay(24);

	if (with_spread) {
		tmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);
		tmp &= ~SBI_SSCCTL_PATHALT;
		intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);

		if (with_fdi) {
			lpt_reset_fdi_mphy(dev_priv);
			lpt_program_fdi_mphy(dev_priv);
		}
	}

	reg = HAS_PCH_LPT_LP(dev) ? SBI_GEN0 : SBI_DBUFF0;
	tmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);
	tmp |= SBI_GEN0_CFG_BUFFENABLE_DISABLE;
	intel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);

	mutex_unlock(&dev_priv->sb_lock);
}

/* Sequence to disable CLKOUT_DP */
static void lpt_disable_clkout_dp(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t reg, tmp;

	mutex_lock(&dev_priv->sb_lock);

	reg = HAS_PCH_LPT_LP(dev) ? SBI_GEN0 : SBI_DBUFF0;
	tmp = intel_sbi_read(dev_priv, reg, SBI_ICLK);
	tmp &= ~SBI_GEN0_CFG_BUFFENABLE_DISABLE;
	intel_sbi_write(dev_priv, reg, tmp, SBI_ICLK);

	tmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);
	if (!(tmp & SBI_SSCCTL_DISABLE)) {
		if (!(tmp & SBI_SSCCTL_PATHALT)) {
			tmp |= SBI_SSCCTL_PATHALT;
			intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);
			udelay(32);
		}
		tmp |= SBI_SSCCTL_DISABLE;
		intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);
	}

	mutex_unlock(&dev_priv->sb_lock);
}

static void lpt_init_pch_refclk(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	bool has_vga = false;

	for_each_intel_encoder(dev, encoder) {
		switch (encoder->type) {
		case INTEL_OUTPUT_ANALOG:
			has_vga = true;
			break;
		default:
			break;
		}
	}

	if (has_vga)
		lpt_enable_clkout_dp(dev, true, true);
	else
		lpt_disable_clkout_dp(dev);
}

/*
 * Initialize reference clocks when the driver loads
 */
void intel_init_pch_refclk(struct drm_device *dev)
{
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		ironlake_init_pch_refclk(dev);
	else if (HAS_PCH_LPT(dev))
		lpt_init_pch_refclk(dev);
}

static int ironlake_get_refclk(struct intel_crtc_state *crtc_state)
{
	struct drm_device *dev = crtc_state->base.crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_atomic_state *state = crtc_state->base.state;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	struct intel_encoder *encoder;
	int num_connectors = 0, i;
	bool is_lvds = false;

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != crtc_state->base.crtc)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);

		switch (encoder->type) {
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
		default:
			break;
		}
		num_connectors++;
	}

	if (is_lvds && intel_panel_use_ssc(dev_priv) && num_connectors < 2) {
		DRM_DEBUG_KMS("using SSC reference clock of %d kHz\n",
			      dev_priv->vbt.lvds_ssc_freq);
		return dev_priv->vbt.lvds_ssc_freq;
	}

	return 120000;
}

static void ironlake_set_pipeconf(struct drm_crtc *crtc)
{
	struct drm_i915_private *dev_priv = crtc->dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	uint32_t val;

	val = 0;

	switch (intel_crtc->config->pipe_bpp) {
	case 18:
		val |= PIPECONF_6BPC;
		break;
	case 24:
		val |= PIPECONF_8BPC;
		break;
	case 30:
		val |= PIPECONF_10BPC;
		break;
	case 36:
		val |= PIPECONF_12BPC;
		break;
	default:
		/* Case prevented by intel_choose_pipe_bpp_dither. */
		BUG();
	}

	if (intel_crtc->config->dither)
		val |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);

	if (intel_crtc->config->base.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
		val |= PIPECONF_INTERLACED_ILK;
	else
		val |= PIPECONF_PROGRESSIVE;

	if (intel_crtc->config->limited_color_range)
		val |= PIPECONF_COLOR_RANGE_SELECT;

	I915_WRITE(PIPECONF(pipe), val);
	POSTING_READ(PIPECONF(pipe));
}

/*
 * Set up the pipe CSC unit.
 *
 * Currently only full range RGB to limited range RGB conversion
 * is supported, but eventually this should handle various
 * RGB<->YCbCr scenarios as well.
 */
static void intel_set_pipe_csc(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	uint16_t coeff = 0x7800; /* 1.0 */

	/*
	 * TODO: Check what kind of values actually come out of the pipe
	 * with these coeff/postoff values and adjust to get the best
	 * accuracy. Perhaps we even need to take the bpc value into
	 * consideration.
	 */

	if (intel_crtc->config->limited_color_range)
		coeff = ((235 - 16) * (1 << 12) / 255) & 0xff8; /* 0.xxx... */

	/*
	 * GY/GU and RY/RU should be the other way around according
	 * to BSpec, but reality doesn't agree. Just set them up in
	 * a way that results in the correct picture.
	 */
	I915_WRITE(PIPE_CSC_COEFF_RY_GY(pipe), coeff << 16);
	I915_WRITE(PIPE_CSC_COEFF_BY(pipe), 0);

	I915_WRITE(PIPE_CSC_COEFF_RU_GU(pipe), coeff);
	I915_WRITE(PIPE_CSC_COEFF_BU(pipe), 0);

	I915_WRITE(PIPE_CSC_COEFF_RV_GV(pipe), 0);
	I915_WRITE(PIPE_CSC_COEFF_BV(pipe), coeff << 16);

	I915_WRITE(PIPE_CSC_PREOFF_HI(pipe), 0);
	I915_WRITE(PIPE_CSC_PREOFF_ME(pipe), 0);
	I915_WRITE(PIPE_CSC_PREOFF_LO(pipe), 0);

	if (INTEL_INFO(dev)->gen > 6) {
		uint16_t postoff = 0;

		if (intel_crtc->config->limited_color_range)
			postoff = (16 * (1 << 12) / 255) & 0x1fff;

		I915_WRITE(PIPE_CSC_POSTOFF_HI(pipe), postoff);
		I915_WRITE(PIPE_CSC_POSTOFF_ME(pipe), postoff);
		I915_WRITE(PIPE_CSC_POSTOFF_LO(pipe), postoff);

		I915_WRITE(PIPE_CSC_MODE(pipe), 0);
	} else {
		uint32_t mode = CSC_MODE_YUV_TO_RGB;

		if (intel_crtc->config->limited_color_range)
			mode |= CSC_BLACK_SCREEN_OFFSET;

		I915_WRITE(PIPE_CSC_MODE(pipe), mode);
	}
}

static void haswell_set_pipeconf(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum pipe pipe = intel_crtc->pipe;
	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;
	uint32_t val;

	val = 0;

	if (IS_HASWELL(dev) && intel_crtc->config->dither)
		val |= (PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_SP);

	if (intel_crtc->config->base.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
		val |= PIPECONF_INTERLACED_ILK;
	else
		val |= PIPECONF_PROGRESSIVE;

	I915_WRITE(PIPECONF(cpu_transcoder), val);
	POSTING_READ(PIPECONF(cpu_transcoder));

	I915_WRITE(GAMMA_MODE(intel_crtc->pipe), GAMMA_MODE_MODE_8BIT);
	POSTING_READ(GAMMA_MODE(intel_crtc->pipe));

	if (IS_BROADWELL(dev) || INTEL_INFO(dev)->gen >= 9) {
		val = 0;

		switch (intel_crtc->config->pipe_bpp) {
		case 18:
			val |= PIPEMISC_DITHER_6_BPC;
			break;
		case 24:
			val |= PIPEMISC_DITHER_8_BPC;
			break;
		case 30:
			val |= PIPEMISC_DITHER_10_BPC;
			break;
		case 36:
			val |= PIPEMISC_DITHER_12_BPC;
			break;
		default:
			/* Case prevented by pipe_config_set_bpp. */
			BUG();
		}

		if (intel_crtc->config->dither)
			val |= PIPEMISC_DITHER_ENABLE | PIPEMISC_DITHER_TYPE_SP;

		I915_WRITE(PIPEMISC(pipe), val);
	}
}

static bool ironlake_compute_clocks(struct drm_crtc *crtc,
				    struct intel_crtc_state *crtc_state,
				    intel_clock_t *clock,
				    bool *has_reduced_clock,
				    intel_clock_t *reduced_clock)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int refclk;
	const intel_limit_t *limit;
	bool ret;

	refclk = ironlake_get_refclk(crtc_state);

	/*
	 * Returns a set of divisors for the desired target clock with the given
	 * refclk, or FALSE.  The returned values represent the clock equation:
	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.
	 */
	limit = intel_limit(crtc_state, refclk);
	ret = dev_priv->display.find_dpll(limit, crtc_state,
					  crtc_state->port_clock,
					  refclk, NULL, clock);
	if (!ret)
		return false;

	return true;
}

int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp)
{
	/*
	 * Account for spread spectrum to avoid
	 * oversubscribing the link. Max center spread
	 * is 2.5%; use 5% for safety's sake.
	 */
	u32 bps = target_clock * bpp * 21 / 20;
	return DIV_ROUND_UP(bps, link_bw * 8);
}

static bool ironlake_needs_fb_cb_tune(struct dpll *dpll, int factor)
{
	return i9xx_dpll_compute_m(dpll) < factor * dpll->n;
}

static uint32_t ironlake_compute_dpll(struct intel_crtc *intel_crtc,
				      struct intel_crtc_state *crtc_state,
				      u32 *fp,
				      intel_clock_t *reduced_clock, u32 *fp2)
{
	struct drm_crtc *crtc = &intel_crtc->base;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_atomic_state *state = crtc_state->base.state;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	struct intel_encoder *encoder;
	uint32_t dpll;
	int factor, num_connectors = 0, i;
	bool is_lvds = false, is_sdvo = false;

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != crtc_state->base.crtc)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);

		switch (encoder->type) {
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
		case INTEL_OUTPUT_SDVO:
		case INTEL_OUTPUT_HDMI:
			is_sdvo = true;
			break;
		default:
			break;
		}

		num_connectors++;
	}

	/* Enable autotuning of the PLL clock (if permissible) */
	factor = 21;
	if (is_lvds) {
		if ((intel_panel_use_ssc(dev_priv) &&
		     dev_priv->vbt.lvds_ssc_freq == 100000) ||
		    (HAS_PCH_IBX(dev) && intel_is_dual_link_lvds(dev)))
			factor = 25;
	} else if (crtc_state->sdvo_tv_clock)
		factor = 20;

	if (ironlake_needs_fb_cb_tune(&crtc_state->dpll, factor))
		*fp |= FP_CB_TUNE;

	if (fp2 && (reduced_clock->m < factor * reduced_clock->n))
		*fp2 |= FP_CB_TUNE;

	dpll = 0;

	if (is_lvds)
		dpll |= DPLLB_MODE_LVDS;
	else
		dpll |= DPLLB_MODE_DAC_SERIAL;

	dpll |= (crtc_state->pixel_multiplier - 1)
		<< PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;

	if (is_sdvo)
		dpll |= DPLL_SDVO_HIGH_SPEED;
	if (crtc_state->has_dp_encoder)
		dpll |= DPLL_SDVO_HIGH_SPEED;

	/* compute bitmask from p1 value */
	dpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
	/* also FPA1 */
	dpll |= (1 << (crtc_state->dpll.p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;

	switch (crtc_state->dpll.p2) {
	case 5:
		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_5;
		break;
	case 7:
		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_7;
		break;
	case 10:
		dpll |= DPLL_DAC_SERIAL_P2_CLOCK_DIV_10;
		break;
	case 14:
		dpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;
		break;
	}

	if (is_lvds && intel_panel_use_ssc(dev_priv) && num_connectors < 2)
		dpll |= PLLB_REF_INPUT_SPREADSPECTRUMIN;
	else
		dpll |= PLL_REF_INPUT_DREFCLK;

	return dpll | DPLL_VCO_ENABLE;
}

static int ironlake_crtc_compute_clock(struct intel_crtc *crtc,
				       struct intel_crtc_state *crtc_state)
{
	struct drm_device *dev = crtc->base.dev;
	intel_clock_t clock, reduced_clock;
	u32 dpll = 0, fp = 0, fp2 = 0;
	bool ok, has_reduced_clock = false;
	bool is_lvds = false;
	struct intel_shared_dpll *pll;

	memset(&crtc_state->dpll_hw_state, 0,
	       sizeof(crtc_state->dpll_hw_state));

	is_lvds = intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS);

	WARN(!(HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)),
	     "Unexpected PCH type %d\n", INTEL_PCH_TYPE(dev));

	ok = ironlake_compute_clocks(&crtc->base, crtc_state, &clock,
				     &has_reduced_clock, &reduced_clock);
	if (!ok && !crtc_state->clock_set) {
		DRM_ERROR("Couldn't find PLL settings for mode!\n");
		return -EINVAL;
	}
	/* Compat-code for transition, will disappear. */
	if (!crtc_state->clock_set) {
		crtc_state->dpll.n = clock.n;
		crtc_state->dpll.m1 = clock.m1;
		crtc_state->dpll.m2 = clock.m2;
		crtc_state->dpll.p1 = clock.p1;
		crtc_state->dpll.p2 = clock.p2;
	}

	/* CPU eDP is the only output that doesn't need a PCH PLL of its own. */
	if (crtc_state->has_pch_encoder) {
		fp = i9xx_dpll_compute_fp(&crtc_state->dpll);
		if (has_reduced_clock)
			fp2 = i9xx_dpll_compute_fp(&reduced_clock);

		dpll = ironlake_compute_dpll(crtc, crtc_state,
					     &fp, &reduced_clock,
					     has_reduced_clock ? &fp2 : NULL);

		crtc_state->dpll_hw_state.dpll = dpll;
		crtc_state->dpll_hw_state.fp0 = fp;
		if (has_reduced_clock)
			crtc_state->dpll_hw_state.fp1 = fp2;
		else
			crtc_state->dpll_hw_state.fp1 = fp;

		pll = intel_get_shared_dpll(crtc, crtc_state);
		if (pll == NULL) {
			DRM_DEBUG_DRIVER("failed to find PLL for pipe %c\n",
					 pipe_name(crtc->pipe));
			return -EINVAL;
		}
	}

	if (is_lvds && has_reduced_clock)
		crtc->lowfreq_avail = true;
	else
		crtc->lowfreq_avail = false;

	return 0;
}

static void intel_pch_transcoder_get_m_n(struct intel_crtc *crtc,
					 struct intel_link_m_n *m_n)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = crtc->pipe;

	m_n->link_m = I915_READ(PCH_TRANS_LINK_M1(pipe));
	m_n->link_n = I915_READ(PCH_TRANS_LINK_N1(pipe));
	m_n->gmch_m = I915_READ(PCH_TRANS_DATA_M1(pipe))
		& ~TU_SIZE_MASK;
	m_n->gmch_n = I915_READ(PCH_TRANS_DATA_N1(pipe));
	m_n->tu = ((I915_READ(PCH_TRANS_DATA_M1(pipe))
		    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
}

static void intel_cpu_transcoder_get_m_n(struct intel_crtc *crtc,
					 enum transcoder transcoder,
					 struct intel_link_m_n *m_n,
					 struct intel_link_m_n *m2_n2)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = crtc->pipe;

	if (INTEL_INFO(dev)->gen >= 5) {
		m_n->link_m = I915_READ(PIPE_LINK_M1(transcoder));
		m_n->link_n = I915_READ(PIPE_LINK_N1(transcoder));
		m_n->gmch_m = I915_READ(PIPE_DATA_M1(transcoder))
			& ~TU_SIZE_MASK;
		m_n->gmch_n = I915_READ(PIPE_DATA_N1(transcoder));
		m_n->tu = ((I915_READ(PIPE_DATA_M1(transcoder))
			    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
		/* Read M2_N2 registers only for gen < 8 (M2_N2 available for
		 * gen < 8) and if DRRS is supported (to make sure the
		 * registers are not unnecessarily read).
		 */
		if (m2_n2 && INTEL_INFO(dev)->gen < 8 &&
			crtc->config->has_drrs) {
			m2_n2->link_m = I915_READ(PIPE_LINK_M2(transcoder));
			m2_n2->link_n =	I915_READ(PIPE_LINK_N2(transcoder));
			m2_n2->gmch_m =	I915_READ(PIPE_DATA_M2(transcoder))
					& ~TU_SIZE_MASK;
			m2_n2->gmch_n =	I915_READ(PIPE_DATA_N2(transcoder));
			m2_n2->tu = ((I915_READ(PIPE_DATA_M2(transcoder))
					& TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
		}
	} else {
		m_n->link_m = I915_READ(PIPE_LINK_M_G4X(pipe));
		m_n->link_n = I915_READ(PIPE_LINK_N_G4X(pipe));
		m_n->gmch_m = I915_READ(PIPE_DATA_M_G4X(pipe))
			& ~TU_SIZE_MASK;
		m_n->gmch_n = I915_READ(PIPE_DATA_N_G4X(pipe));
		m_n->tu = ((I915_READ(PIPE_DATA_M_G4X(pipe))
			    & TU_SIZE_MASK) >> TU_SIZE_SHIFT) + 1;
	}
}

void intel_dp_get_m_n(struct intel_crtc *crtc,
		      struct intel_crtc_state *pipe_config)
{
	if (pipe_config->has_pch_encoder)
		intel_pch_transcoder_get_m_n(crtc, &pipe_config->dp_m_n);
	else
		intel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,
					     &pipe_config->dp_m_n,
					     &pipe_config->dp_m2_n2);
}

static void ironlake_get_fdi_m_n_config(struct intel_crtc *crtc,
					struct intel_crtc_state *pipe_config)
{
	intel_cpu_transcoder_get_m_n(crtc, pipe_config->cpu_transcoder,
				     &pipe_config->fdi_m_n, NULL);
}

static void skylake_get_pfit_config(struct intel_crtc *crtc,
				    struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc_scaler_state *scaler_state = &pipe_config->scaler_state;
	uint32_t ps_ctrl = 0;
	int id = -1;
	int i;

	/* find scaler attached to this pipe */
	for (i = 0; i < crtc->num_scalers; i++) {
		ps_ctrl = I915_READ(SKL_PS_CTRL(crtc->pipe, i));
		if (ps_ctrl & PS_SCALER_EN && !(ps_ctrl & PS_PLANE_SEL_MASK)) {
			id = i;
			pipe_config->pch_pfit.enabled = true;
			pipe_config->pch_pfit.pos = I915_READ(SKL_PS_WIN_POS(crtc->pipe, i));
			pipe_config->pch_pfit.size = I915_READ(SKL_PS_WIN_SZ(crtc->pipe, i));
			break;
		}
	}

	scaler_state->scaler_id = id;
	if (id >= 0) {
		scaler_state->scaler_users |= (1 << SKL_CRTC_INDEX);
	} else {
		scaler_state->scaler_users &= ~(1 << SKL_CRTC_INDEX);
	}
}

static void
skylake_get_initial_plane_config(struct intel_crtc *crtc,
				 struct intel_initial_plane_config *plane_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, base, offset, stride_mult, tiling;
	int pipe = crtc->pipe;
	int fourcc, pixel_format;
	unsigned int aligned_height;
	struct drm_framebuffer *fb;
	struct intel_framebuffer *intel_fb;

	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
	if (!intel_fb) {
		DRM_DEBUG_KMS("failed to alloc fb\n");
		return;
	}

	fb = &intel_fb->base;

	val = I915_READ(PLANE_CTL(pipe, 0));
	if (!(val & PLANE_CTL_ENABLE))
		goto error;

	pixel_format = val & PLANE_CTL_FORMAT_MASK;
	fourcc = skl_format_to_fourcc(pixel_format,
				      val & PLANE_CTL_ORDER_RGBX,
				      val & PLANE_CTL_ALPHA_MASK);
	fb->pixel_format = fourcc;
	fb->bits_per_pixel = drm_format_plane_cpp(fourcc, 0) * 8;

	tiling = val & PLANE_CTL_TILED_MASK;
	switch (tiling) {
	case PLANE_CTL_TILED_LINEAR:
		fb->modifier[0] = DRM_FORMAT_MOD_NONE;
		break;
	case PLANE_CTL_TILED_X:
		plane_config->tiling = I915_TILING_X;
		fb->modifier[0] = I915_FORMAT_MOD_X_TILED;
		break;
	case PLANE_CTL_TILED_Y:
		fb->modifier[0] = I915_FORMAT_MOD_Y_TILED;
		break;
	case PLANE_CTL_TILED_YF:
		fb->modifier[0] = I915_FORMAT_MOD_Yf_TILED;
		break;
	default:
		MISSING_CASE(tiling);
		goto error;
	}

	base = I915_READ(PLANE_SURF(pipe, 0)) & 0xfffff000;
	plane_config->base = base;

	offset = I915_READ(PLANE_OFFSET(pipe, 0));

	val = I915_READ(PLANE_SIZE(pipe, 0));
	fb->height = ((val >> 16) & 0xfff) + 1;
	fb->width = ((val >> 0) & 0x1fff) + 1;

	val = I915_READ(PLANE_STRIDE(pipe, 0));
	stride_mult = intel_fb_stride_alignment(dev, fb->modifier[0],
						fb->pixel_format);
	fb->pitches[0] = (val & 0x3ff) * stride_mult;

	aligned_height = intel_fb_align_height(dev, fb->height,
					       fb->pixel_format,
					       fb->modifier[0]);

	plane_config->size = fb->pitches[0] * aligned_height;

	DRM_DEBUG_KMS("pipe %c with fb: size=%dx%d@@%d, offset=%x, pitch %d, size 0x%x\n",
		      pipe_name(pipe), fb->width, fb->height,
		      fb->bits_per_pixel, base, fb->pitches[0],
		      plane_config->size);

	plane_config->fb = intel_fb;
	return;

error:
	kfree(fb);
}

static void ironlake_get_pfit_config(struct intel_crtc *crtc,
				     struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t tmp;

	tmp = I915_READ(PF_CTL(crtc->pipe));

	if (tmp & PF_ENABLE) {
		pipe_config->pch_pfit.enabled = true;
		pipe_config->pch_pfit.pos = I915_READ(PF_WIN_POS(crtc->pipe));
		pipe_config->pch_pfit.size = I915_READ(PF_WIN_SZ(crtc->pipe));

		/* We currently do not free assignements of panel fitters on
		 * ivb/hsw (since we don't use the higher upscaling modes which
		 * differentiates them) so just WARN about this case for now. */
		if (IS_GEN7(dev)) {
			WARN_ON((tmp & PF_PIPE_SEL_MASK_IVB) !=
				PF_PIPE_SEL_IVB(crtc->pipe));
		}
	}
}

static void
ironlake_get_initial_plane_config(struct intel_crtc *crtc,
				  struct intel_initial_plane_config *plane_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, base, offset;
	int pipe = crtc->pipe;
	int fourcc, pixel_format;
	unsigned int aligned_height;
	struct drm_framebuffer *fb;
	struct intel_framebuffer *intel_fb;

	val = I915_READ(DSPCNTR(pipe));
	if (!(val & DISPLAY_PLANE_ENABLE))
		return;

	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
	if (!intel_fb) {
		DRM_DEBUG_KMS("failed to alloc fb\n");
		return;
	}

	fb = &intel_fb->base;

	if (INTEL_INFO(dev)->gen >= 4) {
		if (val & DISPPLANE_TILED) {
			plane_config->tiling = I915_TILING_X;
			fb->modifier[0] = I915_FORMAT_MOD_X_TILED;
		}
	}

	pixel_format = val & DISPPLANE_PIXFORMAT_MASK;
	fourcc = i9xx_format_to_fourcc(pixel_format);
	fb->pixel_format = fourcc;
	fb->bits_per_pixel = drm_format_plane_cpp(fourcc, 0) * 8;

	base = I915_READ(DSPSURF(pipe)) & 0xfffff000;
	if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		offset = I915_READ(DSPOFFSET(pipe));
	} else {
		if (plane_config->tiling)
			offset = I915_READ(DSPTILEOFF(pipe));
		else
			offset = I915_READ(DSPLINOFF(pipe));
	}
	plane_config->base = base;

	val = I915_READ(PIPESRC(pipe));
	fb->width = ((val >> 16) & 0xfff) + 1;
	fb->height = ((val >> 0) & 0xfff) + 1;

	val = I915_READ(DSPSTRIDE(pipe));
	fb->pitches[0] = val & 0xffffffc0;

	aligned_height = intel_fb_align_height(dev, fb->height,
					       fb->pixel_format,
					       fb->modifier[0]);

	plane_config->size = fb->pitches[0] * aligned_height;

	DRM_DEBUG_KMS("pipe %c with fb: size=%dx%d@@%d, offset=%x, pitch %d, size 0x%x\n",
		      pipe_name(pipe), fb->width, fb->height,
		      fb->bits_per_pixel, base, fb->pitches[0],
		      plane_config->size);

	plane_config->fb = intel_fb;
}

static bool ironlake_get_pipe_config(struct intel_crtc *crtc,
				     struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t tmp;

	if (!intel_display_power_is_enabled(dev_priv,
					    POWER_DOMAIN_PIPE(crtc->pipe)))
		return false;

	pipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;
	pipe_config->shared_dpll = DPLL_ID_PRIVATE;

	tmp = I915_READ(PIPECONF(crtc->pipe));
	if (!(tmp & PIPECONF_ENABLE))
		return false;

	switch (tmp & PIPECONF_BPC_MASK) {
	case PIPECONF_6BPC:
		pipe_config->pipe_bpp = 18;
		break;
	case PIPECONF_8BPC:
		pipe_config->pipe_bpp = 24;
		break;
	case PIPECONF_10BPC:
		pipe_config->pipe_bpp = 30;
		break;
	case PIPECONF_12BPC:
		pipe_config->pipe_bpp = 36;
		break;
	default:
		break;
	}

	if (tmp & PIPECONF_COLOR_RANGE_SELECT)
		pipe_config->limited_color_range = true;

	if (I915_READ(PCH_TRANSCONF(crtc->pipe)) & TRANS_ENABLE) {
		struct intel_shared_dpll *pll;

		pipe_config->has_pch_encoder = true;

		tmp = I915_READ(FDI_RX_CTL(crtc->pipe));
		pipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>
					  FDI_DP_PORT_WIDTH_SHIFT) + 1;

		ironlake_get_fdi_m_n_config(crtc, pipe_config);

		if (HAS_PCH_IBX(dev_priv->dev)) {
			pipe_config->shared_dpll =
				(enum intel_dpll_id) crtc->pipe;
		} else {
			tmp = I915_READ(PCH_DPLL_SEL);
			if (tmp & TRANS_DPLLB_SEL(crtc->pipe))
				pipe_config->shared_dpll = DPLL_ID_PCH_PLL_B;
			else
				pipe_config->shared_dpll = DPLL_ID_PCH_PLL_A;
		}

		pll = &dev_priv->shared_dplls[pipe_config->shared_dpll];

		WARN_ON(!pll->get_hw_state(dev_priv, pll,
					   &pipe_config->dpll_hw_state));

		tmp = pipe_config->dpll_hw_state.dpll;
		pipe_config->pixel_multiplier =
			((tmp & PLL_REF_SDVO_HDMI_MULTIPLIER_MASK)
			 >> PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT) + 1;

		ironlake_pch_clock_get(crtc, pipe_config);
	} else {
		pipe_config->pixel_multiplier = 1;
	}

	intel_get_pipe_timings(crtc, pipe_config);

	ironlake_get_pfit_config(crtc, pipe_config);

	return true;
}

static void assert_can_disable_lcpll(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	struct intel_crtc *crtc;

	for_each_intel_crtc(dev, crtc)
		I915_STATE_WARN(crtc->active, "CRTC for pipe %c enabled\n",
		     pipe_name(crtc->pipe));

	I915_STATE_WARN(I915_READ(HSW_PWR_WELL_DRIVER), "Power well on\n");
	I915_STATE_WARN(I915_READ(SPLL_CTL) & SPLL_PLL_ENABLE, "SPLL enabled\n");
	I915_STATE_WARN(I915_READ(WRPLL_CTL1) & WRPLL_PLL_ENABLE, "WRPLL1 enabled\n");
	I915_STATE_WARN(I915_READ(WRPLL_CTL2) & WRPLL_PLL_ENABLE, "WRPLL2 enabled\n");
	I915_STATE_WARN(I915_READ(PCH_PP_STATUS) & PP_ON, "Panel power on\n");
	I915_STATE_WARN(I915_READ(BLC_PWM_CPU_CTL2) & BLM_PWM_ENABLE,
	     "CPU PWM1 enabled\n");
	if (IS_HASWELL(dev))
		I915_STATE_WARN(I915_READ(HSW_BLC_PWM2_CTL) & BLM_PWM_ENABLE,
		     "CPU PWM2 enabled\n");
	I915_STATE_WARN(I915_READ(BLC_PWM_PCH_CTL1) & BLM_PCH_PWM_ENABLE,
	     "PCH PWM1 enabled\n");
	I915_STATE_WARN(I915_READ(UTIL_PIN_CTL) & UTIL_PIN_ENABLE,
	     "Utility pin enabled\n");
	I915_STATE_WARN(I915_READ(PCH_GTC_CTL) & PCH_GTC_ENABLE, "PCH GTC enabled\n");

	/*
	 * In theory we can still leave IRQs enabled, as long as only the HPD
	 * interrupts remain enabled. We used to check for that, but since it's
	 * gen-specific and since we only disable LCPLL after we fully disable
	 * the interrupts, the check below should be enough.
	 */
	I915_STATE_WARN(intel_irqs_enabled(dev_priv), "IRQs enabled\n");
}

static uint32_t hsw_read_dcomp(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;

	if (IS_HASWELL(dev))
		return I915_READ(D_COMP_HSW);
	else
		return I915_READ(D_COMP_BDW);
}

static void hsw_write_dcomp(struct drm_i915_private *dev_priv, uint32_t val)
{
	struct drm_device *dev = dev_priv->dev;

	if (IS_HASWELL(dev)) {
		mutex_lock(&dev_priv->rps.hw_lock);
		if (sandybridge_pcode_write(dev_priv, GEN6_PCODE_WRITE_D_COMP,
					    val))
			DRM_ERROR("Failed to write to D_COMP\n");
		mutex_unlock(&dev_priv->rps.hw_lock);
	} else {
		I915_WRITE(D_COMP_BDW, val);
		POSTING_READ(D_COMP_BDW);
	}
}

/*
 * This function implements pieces of two sequences from BSpec:
 * - Sequence for display software to disable LCPLL
 * - Sequence for display software to allow package C8+
 * The steps implemented here are just the steps that actually touch the LCPLL
 * register. Callers should take care of disabling all the display engine
 * functions, doing the mode unset, fixing interrupts, etc.
 */
static void hsw_disable_lcpll(struct drm_i915_private *dev_priv,
			      bool switch_to_fclk, bool allow_power_down)
{
	uint32_t val;

	assert_can_disable_lcpll(dev_priv);

	val = I915_READ(LCPLL_CTL);

	if (switch_to_fclk) {
		val |= LCPLL_CD_SOURCE_FCLK;
		I915_WRITE(LCPLL_CTL, val);

		if (wait_for_atomic_us(I915_READ(LCPLL_CTL) &
				       LCPLL_CD_SOURCE_FCLK_DONE, 1))
			DRM_ERROR("Switching to FCLK failed\n");

		val = I915_READ(LCPLL_CTL);
	}

	val |= LCPLL_PLL_DISABLE;
	I915_WRITE(LCPLL_CTL, val);
	POSTING_READ(LCPLL_CTL);

	if (wait_for((I915_READ(LCPLL_CTL) & LCPLL_PLL_LOCK) == 0, 1))
		DRM_ERROR("LCPLL still locked\n");

	val = hsw_read_dcomp(dev_priv);
	val |= D_COMP_COMP_DISABLE;
	hsw_write_dcomp(dev_priv, val);
	ndelay(100);

	if (wait_for((hsw_read_dcomp(dev_priv) & D_COMP_RCOMP_IN_PROGRESS) == 0,
		     1))
		DRM_ERROR("D_COMP RCOMP still in progress\n");

	if (allow_power_down) {
		val = I915_READ(LCPLL_CTL);
		val |= LCPLL_POWER_DOWN_ALLOW;
		I915_WRITE(LCPLL_CTL, val);
		POSTING_READ(LCPLL_CTL);
	}
}

/*
 * Fully restores LCPLL, disallowing power down and switching back to LCPLL
 * source.
 */
static void hsw_restore_lcpll(struct drm_i915_private *dev_priv)
{
	uint32_t val;

	val = I915_READ(LCPLL_CTL);

	if ((val & (LCPLL_PLL_LOCK | LCPLL_PLL_DISABLE | LCPLL_CD_SOURCE_FCLK |
		    LCPLL_POWER_DOWN_ALLOW)) == LCPLL_PLL_LOCK)
		return;

	/*
	 * Make sure we're not on PC8 state before disabling PC8, otherwise
	 * we'll hang the machine. To prevent PC8 state, just enable force_wake.
	 */
	intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);

	if (val & LCPLL_POWER_DOWN_ALLOW) {
		val &= ~LCPLL_POWER_DOWN_ALLOW;
		I915_WRITE(LCPLL_CTL, val);
		POSTING_READ(LCPLL_CTL);
	}

	val = hsw_read_dcomp(dev_priv);
	val |= D_COMP_COMP_FORCE;
	val &= ~D_COMP_COMP_DISABLE;
	hsw_write_dcomp(dev_priv, val);

	val = I915_READ(LCPLL_CTL);
	val &= ~LCPLL_PLL_DISABLE;
	I915_WRITE(LCPLL_CTL, val);

	if (wait_for(I915_READ(LCPLL_CTL) & LCPLL_PLL_LOCK, 5))
		DRM_ERROR("LCPLL not locked yet\n");

	if (val & LCPLL_CD_SOURCE_FCLK) {
		val = I915_READ(LCPLL_CTL);
		val &= ~LCPLL_CD_SOURCE_FCLK;
		I915_WRITE(LCPLL_CTL, val);

		if (wait_for_atomic_us((I915_READ(LCPLL_CTL) &
					LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))
			DRM_ERROR("Switching back to LCPLL failed\n");
	}

	intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);
	intel_update_cdclk(dev_priv->dev);
}

/*
 * Package states C8 and deeper are really deep PC states that can only be
 * reached when all the devices on the system allow it, so even if the graphics
 * device allows PC8+, it doesn't mean the system will actually get to these
 * states. Our driver only allows PC8+ when going into runtime PM.
 *
 * The requirements for PC8+ are that all the outputs are disabled, the power
 * well is disabled and most interrupts are disabled, and these are also
 * requirements for runtime PM. When these conditions are met, we manually do
 * the other conditions: disable the interrupts, clocks and switch LCPLL refclk
 * to Fclk. If we're in PC8+ and we get an non-hotplug interrupt, we can hard
 * hang the machine.
 *
 * When we really reach PC8 or deeper states (not just when we allow it) we lose
 * the state of some registers, so when we come back from PC8+ we need to
 * restore this state. We don't get into PC8+ if we're not in RC6, so we don't
 * need to take care of the registers kept by RC6. Notice that this happens even
 * if we don't put the device in PCI D3 state (which is what currently happens
 * because of the runtime PM support).
 *
 * For more, read "Display Sequences for Package C8" on the hardware
 * documentation.
 */
void hsw_enable_pc8(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	uint32_t val;

	DRM_DEBUG_KMS("Enabling package C8+\n");

	if (HAS_PCH_LPT_LP(dev)) {
		val = I915_READ(SOUTH_DSPCLK_GATE_D);
		val &= ~PCH_LP_PARTITION_LEVEL_DISABLE;
		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
	}

	lpt_disable_clkout_dp(dev);
	hsw_disable_lcpll(dev_priv, true, true);
}

void hsw_disable_pc8(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	uint32_t val;

	DRM_DEBUG_KMS("Disabling package C8+\n");

	hsw_restore_lcpll(dev_priv);
	lpt_init_pch_refclk(dev);

	if (HAS_PCH_LPT_LP(dev)) {
		val = I915_READ(SOUTH_DSPCLK_GATE_D);
		val |= PCH_LP_PARTITION_LEVEL_DISABLE;
		I915_WRITE(SOUTH_DSPCLK_GATE_D, val);
	}

	intel_prepare_ddi(dev);
}

static void broxton_modeset_commit_cdclk(struct drm_atomic_state *old_state)
{
	struct drm_device *dev = old_state->dev;
	unsigned int req_cdclk = to_intel_atomic_state(old_state)->cdclk;

	broxton_set_cdclk(dev, req_cdclk);
}

/* compute the max rate for new configuration */
static int ilk_max_pixel_rate(struct drm_atomic_state *state)
{
	struct intel_crtc *intel_crtc;
	struct intel_crtc_state *crtc_state;
	int max_pixel_rate = 0;

	for_each_intel_crtc(state->dev, intel_crtc) {
		int pixel_rate;

		crtc_state = intel_atomic_get_crtc_state(state, intel_crtc);
		if (IS_ERR(crtc_state))
			return PTR_ERR(crtc_state);

		if (!crtc_state->base.enable)
			continue;

		pixel_rate = ilk_pipe_pixel_rate(crtc_state);

		/* pixel rate mustn't exceed 95% of cdclk with IPS on BDW */
		if (IS_BROADWELL(state->dev) && crtc_state->ips_enabled)
			pixel_rate = DIV_ROUND_UP(pixel_rate * 100, 95);

		max_pixel_rate = max(max_pixel_rate, pixel_rate);
	}

	return max_pixel_rate;
}

static void broadwell_set_cdclk(struct drm_device *dev, int cdclk)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t val, data;
	int ret;

	if (WARN((I915_READ(LCPLL_CTL) &
		  (LCPLL_PLL_DISABLE | LCPLL_PLL_LOCK |
		   LCPLL_CD_CLOCK_DISABLE | LCPLL_ROOT_CD_CLOCK_DISABLE |
		   LCPLL_CD2X_CLOCK_DISABLE | LCPLL_POWER_DOWN_ALLOW |
		   LCPLL_CD_SOURCE_FCLK)) != LCPLL_PLL_LOCK,
		 "trying to change cdclk frequency with cdclk not enabled\n"))
		return;

	mutex_lock(&dev_priv->rps.hw_lock);
	ret = sandybridge_pcode_write(dev_priv,
				      BDW_PCODE_DISPLAY_FREQ_CHANGE_REQ, 0x0);
	mutex_unlock(&dev_priv->rps.hw_lock);
	if (ret) {
		DRM_ERROR("failed to inform pcode about cdclk change\n");
		return;
	}

	val = I915_READ(LCPLL_CTL);
	val |= LCPLL_CD_SOURCE_FCLK;
	I915_WRITE(LCPLL_CTL, val);

	if (wait_for_atomic_us(I915_READ(LCPLL_CTL) &
			       LCPLL_CD_SOURCE_FCLK_DONE, 1))
		DRM_ERROR("Switching to FCLK failed\n");

	val = I915_READ(LCPLL_CTL);
	val &= ~LCPLL_CLK_FREQ_MASK;

	switch (cdclk) {
	case 450000:
		val |= LCPLL_CLK_FREQ_450;
		data = 0;
		break;
	case 540000:
		val |= LCPLL_CLK_FREQ_54O_BDW;
		data = 1;
		break;
	case 337500:
		val |= LCPLL_CLK_FREQ_337_5_BDW;
		data = 2;
		break;
	case 675000:
		val |= LCPLL_CLK_FREQ_675_BDW;
		data = 3;
		break;
	default:
		WARN(1, "invalid cdclk frequency\n");
		return;
	}

	I915_WRITE(LCPLL_CTL, val);

	val = I915_READ(LCPLL_CTL);
	val &= ~LCPLL_CD_SOURCE_FCLK;
	I915_WRITE(LCPLL_CTL, val);

	if (wait_for_atomic_us((I915_READ(LCPLL_CTL) &
				LCPLL_CD_SOURCE_FCLK_DONE) == 0, 1))
		DRM_ERROR("Switching back to LCPLL failed\n");

	mutex_lock(&dev_priv->rps.hw_lock);
	sandybridge_pcode_write(dev_priv, HSW_PCODE_DE_WRITE_FREQ_REQ, data);
	mutex_unlock(&dev_priv->rps.hw_lock);

	I915_WRITE(CDCLK_FREQ, DIV_ROUND_CLOSEST(cdclk, 1000) - 1);

	intel_update_cdclk(dev);

	WARN(cdclk != dev_priv->cdclk_freq,
	     "cdclk requested %d kHz but got %d kHz\n",
	     cdclk, dev_priv->cdclk_freq);
}

static int broadwell_modeset_calc_cdclk(struct drm_atomic_state *state)
{
	struct drm_i915_private *dev_priv = to_i915(state->dev);
	int max_pixclk = ilk_max_pixel_rate(state);
	int cdclk;

	/*
	 * FIXME should also account for plane ratio
	 * once 64bpp pixel formats are supported.
	 */
	if (max_pixclk > 540000)
		cdclk = 675000;
	else if (max_pixclk > 450000)
		cdclk = 540000;
	else if (max_pixclk > 337500)
		cdclk = 450000;
	else
		cdclk = 337500;

	/*
	 * FIXME move the cdclk caclulation to
	 * compute_config() so we can fail gracegully.
	 */
	if (cdclk > dev_priv->max_cdclk_freq) {
		DRM_ERROR("requested cdclk (%d kHz) exceeds max (%d kHz)\n",
			  cdclk, dev_priv->max_cdclk_freq);
		cdclk = dev_priv->max_cdclk_freq;
	}

	to_intel_atomic_state(state)->cdclk = cdclk;

	return 0;
}

static void broadwell_modeset_commit_cdclk(struct drm_atomic_state *old_state)
{
	struct drm_device *dev = old_state->dev;
	unsigned int req_cdclk = to_intel_atomic_state(old_state)->cdclk;

	broadwell_set_cdclk(dev, req_cdclk);
}

static int haswell_crtc_compute_clock(struct intel_crtc *crtc,
				      struct intel_crtc_state *crtc_state)
{
	if (!intel_ddi_pll_select(crtc, crtc_state))
		return -EINVAL;

	crtc->lowfreq_avail = false;

	return 0;
}

static void bxt_get_ddi_pll(struct drm_i915_private *dev_priv,
				enum port port,
				struct intel_crtc_state *pipe_config)
{
	switch (port) {
	case PORT_A:
		pipe_config->ddi_pll_sel = SKL_DPLL0;
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL1;
		break;
	case PORT_B:
		pipe_config->ddi_pll_sel = SKL_DPLL1;
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL2;
		break;
	case PORT_C:
		pipe_config->ddi_pll_sel = SKL_DPLL2;
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL3;
		break;
	default:
		DRM_ERROR("Incorrect port type\n");
	}
}

static void skylake_get_ddi_pll(struct drm_i915_private *dev_priv,
				enum port port,
				struct intel_crtc_state *pipe_config)
{
	u32 temp, dpll_ctl1;

	temp = I915_READ(DPLL_CTRL2) & DPLL_CTRL2_DDI_CLK_SEL_MASK(port);
	pipe_config->ddi_pll_sel = temp >> (port * 3 + 1);

	switch (pipe_config->ddi_pll_sel) {
	case SKL_DPLL0:
		/*
		 * On SKL the eDP DPLL (DPLL0 as we don't use SSC) is not part
		 * of the shared DPLL framework and thus needs to be read out
		 * separately
		 */
		dpll_ctl1 = I915_READ(DPLL_CTRL1);
		pipe_config->dpll_hw_state.ctrl1 = dpll_ctl1 & 0x3f;
		break;
	case SKL_DPLL1:
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL1;
		break;
	case SKL_DPLL2:
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL2;
		break;
	case SKL_DPLL3:
		pipe_config->shared_dpll = DPLL_ID_SKL_DPLL3;
		break;
	}
}

static void haswell_get_ddi_pll(struct drm_i915_private *dev_priv,
				enum port port,
				struct intel_crtc_state *pipe_config)
{
	pipe_config->ddi_pll_sel = I915_READ(PORT_CLK_SEL(port));

	switch (pipe_config->ddi_pll_sel) {
	case PORT_CLK_SEL_WRPLL1:
		pipe_config->shared_dpll = DPLL_ID_WRPLL1;
		break;
	case PORT_CLK_SEL_WRPLL2:
		pipe_config->shared_dpll = DPLL_ID_WRPLL2;
		break;
	case PORT_CLK_SEL_SPLL:
		pipe_config->shared_dpll = DPLL_ID_SPLL;
	}
}

static void haswell_get_ddi_port_state(struct intel_crtc *crtc,
				       struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_shared_dpll *pll;
	enum port port;
	uint32_t tmp;

	tmp = I915_READ(TRANS_DDI_FUNC_CTL(pipe_config->cpu_transcoder));

	port = (tmp & TRANS_DDI_PORT_MASK) >> TRANS_DDI_PORT_SHIFT;

	if (IS_SKYLAKE(dev))
		skylake_get_ddi_pll(dev_priv, port, pipe_config);
	else if (IS_BROXTON(dev))
		bxt_get_ddi_pll(dev_priv, port, pipe_config);
	else
		haswell_get_ddi_pll(dev_priv, port, pipe_config);

	if (pipe_config->shared_dpll >= 0) {
		pll = &dev_priv->shared_dplls[pipe_config->shared_dpll];

		WARN_ON(!pll->get_hw_state(dev_priv, pll,
					   &pipe_config->dpll_hw_state));
	}

	/*
	 * Haswell has only FDI/PCH transcoder A. It is which is connected to
	 * DDI E. So just check whether this pipe is wired to DDI E and whether
	 * the PCH transcoder is on.
	 */
	if (INTEL_INFO(dev)->gen < 9 &&
	    (port == PORT_E) && I915_READ(LPT_TRANSCONF) & TRANS_ENABLE) {
		pipe_config->has_pch_encoder = true;

		tmp = I915_READ(FDI_RX_CTL(PIPE_A));
		pipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>
					  FDI_DP_PORT_WIDTH_SHIFT) + 1;

		ironlake_get_fdi_m_n_config(crtc, pipe_config);
	}
}

static bool haswell_get_pipe_config(struct intel_crtc *crtc,
				    struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain pfit_domain;
	uint32_t tmp;

	if (!intel_display_power_is_enabled(dev_priv,
					 POWER_DOMAIN_PIPE(crtc->pipe)))
		return false;

	pipe_config->cpu_transcoder = (enum transcoder) crtc->pipe;
	pipe_config->shared_dpll = DPLL_ID_PRIVATE;

	tmp = I915_READ(TRANS_DDI_FUNC_CTL(TRANSCODER_EDP));
	if (tmp & TRANS_DDI_FUNC_ENABLE) {
		enum pipe trans_edp_pipe;
		switch (tmp & TRANS_DDI_EDP_INPUT_MASK) {
		default:
			WARN(1, "unknown pipe linked to edp transcoder\n");
		case TRANS_DDI_EDP_INPUT_A_ONOFF:
		case TRANS_DDI_EDP_INPUT_A_ON:
			trans_edp_pipe = PIPE_A;
			break;
		case TRANS_DDI_EDP_INPUT_B_ONOFF:
			trans_edp_pipe = PIPE_B;
			break;
		case TRANS_DDI_EDP_INPUT_C_ONOFF:
			trans_edp_pipe = PIPE_C;
			break;
		}

		if (trans_edp_pipe == crtc->pipe)
			pipe_config->cpu_transcoder = TRANSCODER_EDP;
	}

	if (!intel_display_power_is_enabled(dev_priv,
			POWER_DOMAIN_TRANSCODER(pipe_config->cpu_transcoder)))
		return false;

	tmp = I915_READ(PIPECONF(pipe_config->cpu_transcoder));
	if (!(tmp & PIPECONF_ENABLE))
		return false;

	haswell_get_ddi_port_state(crtc, pipe_config);

	intel_get_pipe_timings(crtc, pipe_config);

	if (INTEL_INFO(dev)->gen >= 9) {
		skl_init_scalers(dev, crtc, pipe_config);
	}

	pfit_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe);

	if (INTEL_INFO(dev)->gen >= 9) {
		pipe_config->scaler_state.scaler_id = -1;
		pipe_config->scaler_state.scaler_users &= ~(1 << SKL_CRTC_INDEX);
	}

	if (intel_display_power_is_enabled(dev_priv, pfit_domain)) {
		if (INTEL_INFO(dev)->gen >= 9)
			skylake_get_pfit_config(crtc, pipe_config);
		else
			ironlake_get_pfit_config(crtc, pipe_config);
	}

	if (IS_HASWELL(dev))
		pipe_config->ips_enabled = hsw_crtc_supports_ips(crtc) &&
			(I915_READ(IPS_CTL) & IPS_ENABLE);

	if (pipe_config->cpu_transcoder != TRANSCODER_EDP) {
		pipe_config->pixel_multiplier =
			I915_READ(PIPE_MULT(pipe_config->cpu_transcoder)) + 1;
	} else {
		pipe_config->pixel_multiplier = 1;
	}

	return true;
}

static void i845_update_cursor(struct drm_crtc *crtc, u32 base, bool on)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t cntl = 0, size = 0;

	if (on) {
		unsigned int width = intel_crtc->base.cursor->state->crtc_w;
		unsigned int height = intel_crtc->base.cursor->state->crtc_h;
		unsigned int stride = roundup_pow_of_two(width) * 4;

		switch (stride) {
		default:
			WARN_ONCE(1, "Invalid cursor width/stride, width=%u, stride=%u\n",
				  width, stride);
			stride = 256;
			/* fallthrough */
		case 256:
		case 512:
		case 1024:
		case 2048:
			break;
		}

		cntl |= CURSOR_ENABLE |
			CURSOR_GAMMA_ENABLE |
			CURSOR_FORMAT_ARGB |
			CURSOR_STRIDE(stride);

		size = (height << 12) | width;
	}

	if (intel_crtc->cursor_cntl != 0 &&
	    (intel_crtc->cursor_base != base ||
	     intel_crtc->cursor_size != size ||
	     intel_crtc->cursor_cntl != cntl)) {
		/* On these chipsets we can only modify the base/size/stride
		 * whilst the cursor is disabled.
		 */
		I915_WRITE(CURCNTR(PIPE_A), 0);
		POSTING_READ(CURCNTR(PIPE_A));
		intel_crtc->cursor_cntl = 0;
	}

	if (intel_crtc->cursor_base != base) {
		I915_WRITE(CURBASE(PIPE_A), base);
		intel_crtc->cursor_base = base;
	}

	if (intel_crtc->cursor_size != size) {
		I915_WRITE(CURSIZE, size);
		intel_crtc->cursor_size = size;
	}

	if (intel_crtc->cursor_cntl != cntl) {
		I915_WRITE(CURCNTR(PIPE_A), cntl);
		POSTING_READ(CURCNTR(PIPE_A));
		intel_crtc->cursor_cntl = cntl;
	}
}

static void i9xx_update_cursor(struct drm_crtc *crtc, u32 base, bool on)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	uint32_t cntl = 0;

	if (on) {
		cntl = MCURSOR_GAMMA_ENABLE;
		switch (intel_crtc->base.cursor->state->crtc_w) {
			case 64:
				cntl |= CURSOR_MODE_64_ARGB_AX;
				break;
			case 128:
				cntl |= CURSOR_MODE_128_ARGB_AX;
				break;
			case 256:
				cntl |= CURSOR_MODE_256_ARGB_AX;
				break;
			default:
				MISSING_CASE(intel_crtc->base.cursor->state->crtc_w);
				return;
		}
		cntl |= pipe << 28; /* Connect to correct pipe */

		if (HAS_DDI(dev))
			cntl |= CURSOR_PIPE_CSC_ENABLE;
	}

	if (crtc->cursor->state->rotation == BIT(DRM_ROTATE_180))
		cntl |= CURSOR_ROTATE_180;

	if (intel_crtc->cursor_cntl != cntl) {
		I915_WRITE(CURCNTR(pipe), cntl);
		POSTING_READ(CURCNTR(pipe));
		intel_crtc->cursor_cntl = cntl;
	}

	/* and commit changes on next vblank */
	I915_WRITE(CURBASE(pipe), base);
	POSTING_READ(CURBASE(pipe));

	intel_crtc->cursor_base = base;
}

/* If no-part of the cursor is visible on the framebuffer, then the GPU may hang... */
static void intel_crtc_update_cursor(struct drm_crtc *crtc,
				     bool on)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	struct drm_plane_state *cursor_state = crtc->cursor->state;
	int x = cursor_state->crtc_x;
	int y = cursor_state->crtc_y;
	u32 base = 0, pos = 0;

	base = intel_crtc->cursor_addr;

	if (x >= intel_crtc->config->pipe_src_w)
		on = false;

	if (y >= intel_crtc->config->pipe_src_h)
		on = false;

	if (x < 0) {
		if (x + cursor_state->crtc_w <= 0)
			on = false;

		pos |= CURSOR_POS_SIGN << CURSOR_X_SHIFT;
		x = -x;
	}
	pos |= x << CURSOR_X_SHIFT;

	if (y < 0) {
		if (y + cursor_state->crtc_h <= 0)
			on = false;

		pos |= CURSOR_POS_SIGN << CURSOR_Y_SHIFT;
		y = -y;
	}
	pos |= y << CURSOR_Y_SHIFT;

	I915_WRITE(CURPOS(pipe), pos);

	/* ILK+ do this automagically */
	if (HAS_GMCH_DISPLAY(dev) &&
	    crtc->cursor->state->rotation == BIT(DRM_ROTATE_180)) {
		base += (cursor_state->crtc_h *
			 cursor_state->crtc_w - 1) * 4;
	}

	if (IS_845G(dev) || IS_I865G(dev))
		i845_update_cursor(crtc, base, on);
	else
		i9xx_update_cursor(crtc, base, on);
}

static bool cursor_size_ok(struct drm_device *dev,
			   uint32_t width, uint32_t height)
{
	if (width == 0 || height == 0)
		return false;

	/*
	 * 845g/865g are special in that they are only limited by
	 * the width of their cursors, the height is arbitrary up to
	 * the precision of the register. Everything else requires
	 * square cursors, limited to a few power-of-two sizes.
	 */
	if (IS_845G(dev) || IS_I865G(dev)) {
		if ((width & 63) != 0)
			return false;

		if (width > (IS_845G(dev) ? 64 : 512))
			return false;

		if (height > 1023)
			return false;
	} else {
		switch (width | height) {
		case 256:
		case 128:
			if (IS_GEN2(dev))
				return false;
		case 64:
			break;
		default:
			return false;
		}
	}

	return true;
}

static void intel_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,
				 u16 *blue, uint32_t start, uint32_t size)
{
	int end = (start + size > 256) ? 256 : start + size, i;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	for (i = start; i < end; i++) {
		intel_crtc->lut_r[i] = red[i] >> 8;
		intel_crtc->lut_g[i] = green[i] >> 8;
		intel_crtc->lut_b[i] = blue[i] >> 8;
	}

	intel_crtc_load_lut(crtc);
}

/* VESA 640x480x72Hz mode to set on the pipe */
static struct drm_display_mode load_detect_mode = {
	DRM_MODE("640x480", DRM_MODE_TYPE_DEFAULT, 31500, 640, 664,
		 704, 832, 0, 480, 489, 491, 520, 0, DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
};

struct drm_framebuffer *
__intel_framebuffer_create(struct drm_device *dev,
			   struct drm_mode_fb_cmd2 *mode_cmd,
			   struct drm_i915_gem_object *obj)
{
	struct intel_framebuffer *intel_fb;
	int ret;

	intel_fb = kzalloc(sizeof(*intel_fb), GFP_KERNEL);
	if (!intel_fb) {
		drm_gem_object_unreference(&obj->base);
		return ERR_PTR(-ENOMEM);
	}

	ret = intel_framebuffer_init(dev, intel_fb, mode_cmd, obj);
	if (ret)
		goto err;

	return &intel_fb->base;
err:
	drm_gem_object_unreference(&obj->base);
	kfree(intel_fb);

	return ERR_PTR(ret);
}

static struct drm_framebuffer *
intel_framebuffer_create(struct drm_device *dev,
			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct drm_i915_gem_object *obj)
{
	struct drm_framebuffer *fb;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ERR_PTR(ret);
	fb = __intel_framebuffer_create(dev, mode_cmd, obj);
	mutex_unlock(&dev->struct_mutex);

	return fb;
}

static u32
intel_framebuffer_pitch_for_width(int width, int bpp)
{
	u32 pitch = DIV_ROUND_UP(width * bpp, 8);
	return roundup2(pitch, 64);
}

static u32
intel_framebuffer_size_for_mode(struct drm_display_mode *mode, int bpp)
{
	u32 pitch = intel_framebuffer_pitch_for_width(mode->hdisplay, bpp);
	return PAGE_ALIGN(pitch * mode->vdisplay);
}

static struct drm_framebuffer *
intel_framebuffer_create_for_mode(struct drm_device *dev,
				  struct drm_display_mode *mode,
				  int depth, int bpp)
{
	struct drm_i915_gem_object *obj;
	struct drm_mode_fb_cmd2 mode_cmd = { 0 };

	obj = i915_gem_alloc_object(dev,
				    intel_framebuffer_size_for_mode(mode, bpp));
	if (obj == NULL)
		return ERR_PTR(-ENOMEM);

	mode_cmd.width = mode->hdisplay;
	mode_cmd.height = mode->vdisplay;
	mode_cmd.pitches[0] = intel_framebuffer_pitch_for_width(mode_cmd.width,
								bpp);
	mode_cmd.pixel_format = drm_mode_legacy_fb_format(bpp, depth);

	return intel_framebuffer_create(dev, &mode_cmd, obj);
}

static struct drm_framebuffer *
mode_fits_in_fbdev(struct drm_device *dev,
		   struct drm_display_mode *mode)
{
#ifdef CONFIG_DRM_FBDEV_EMULATION
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj;
	struct drm_framebuffer *fb;

	if (!dev_priv->fbdev)
		return NULL;

	if (!dev_priv->fbdev->fb)
		return NULL;

	obj = dev_priv->fbdev->fb->obj;
	BUG_ON(!obj);

	fb = &dev_priv->fbdev->fb->base;
	if (fb->pitches[0] < intel_framebuffer_pitch_for_width(mode->hdisplay,
							       fb->bits_per_pixel))
		return NULL;

	if (obj->base.size < mode->vdisplay * fb->pitches[0])
		return NULL;

	return fb;
#else
	return NULL;
#endif
}

static int intel_modeset_setup_plane_state(struct drm_atomic_state *state,
					   struct drm_crtc *crtc,
					   struct drm_display_mode *mode,
					   struct drm_framebuffer *fb,
					   int x, int y)
{
	struct drm_plane_state *plane_state;
	int hdisplay, vdisplay;
	int ret;

	plane_state = drm_atomic_get_plane_state(state, crtc->primary);
	if (IS_ERR(plane_state))
		return PTR_ERR(plane_state);

	if (mode)
		drm_crtc_get_hv_timing(mode, &hdisplay, &vdisplay);
	else
		hdisplay = vdisplay = 0;

	ret = drm_atomic_set_crtc_for_plane(plane_state, fb ? crtc : NULL);
	if (ret)
		return ret;
	drm_atomic_set_fb_for_plane(plane_state, fb);
	plane_state->crtc_x = 0;
	plane_state->crtc_y = 0;
	plane_state->crtc_w = hdisplay;
	plane_state->crtc_h = vdisplay;
	plane_state->src_x = x << 16;
	plane_state->src_y = y << 16;
	plane_state->src_w = hdisplay << 16;
	plane_state->src_h = vdisplay << 16;

	return 0;
}

bool intel_get_load_detect_pipe(struct drm_connector *connector,
				struct drm_display_mode *mode,
				struct intel_load_detect_pipe *old,
				struct drm_modeset_acquire_ctx *ctx)
{
	struct intel_crtc *intel_crtc;
	struct intel_encoder *intel_encoder =
		intel_attached_encoder(connector);
	struct drm_crtc *possible_crtc;
	struct drm_encoder *encoder = &intel_encoder->base;
	struct drm_crtc *crtc = NULL;
	struct drm_device *dev = encoder->dev;
	struct drm_framebuffer *fb;
	struct drm_mode_config *config = &dev->mode_config;
	struct drm_atomic_state *state = NULL;
	struct drm_connector_state *connector_state;
	struct intel_crtc_state *crtc_state;
	int ret, i = -1;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n",
		      connector->base.id, connector->name,
		      encoder->base.id, encoder->name);

retry:
	ret = drm_modeset_lock(&config->connection_mutex, ctx);
	if (ret)
		goto fail;

	/*
	 * Algorithm gets a little messy:
	 *
	 *   - if the connector already has an assigned crtc, use it (but make
	 *     sure it's on first)
	 *
	 *   - try to find the first unused crtc that can drive this connector,
	 *     and use that if we find one
	 */

	/* See if we already have a CRTC for this connector */
	if (encoder->crtc) {
		crtc = encoder->crtc;

		ret = drm_modeset_lock(&crtc->mutex, ctx);
		if (ret)
			goto fail;
		ret = drm_modeset_lock(&crtc->primary->mutex, ctx);
		if (ret)
			goto fail;

		old->dpms_mode = connector->dpms;
		old->load_detect_temp = false;

		/* Make sure the crtc and connector are running */
		if (connector->dpms != DRM_MODE_DPMS_ON)
			connector->funcs->dpms(connector, DRM_MODE_DPMS_ON);

		return true;
	}

	/* Find an unused one (if possible) */
	for_each_crtc(dev, possible_crtc) {
		i++;
		if (!(encoder->possible_crtcs & (1 << i)))
			continue;
		if (possible_crtc->state->enable)
			continue;

		crtc = possible_crtc;
		break;
	}

	/*
	 * If we didn't find an unused CRTC, don't use any.
	 */
	if (!crtc) {
		DRM_DEBUG_KMS("no pipe available for load-detect\n");
		goto fail;
	}

	ret = drm_modeset_lock(&crtc->mutex, ctx);
	if (ret)
		goto fail;
	ret = drm_modeset_lock(&crtc->primary->mutex, ctx);
	if (ret)
		goto fail;

	intel_crtc = to_intel_crtc(crtc);
	old->dpms_mode = connector->dpms;
	old->load_detect_temp = true;
	old->release_fb = NULL;

	state = drm_atomic_state_alloc(dev);
	if (!state)
		return false;

	state->acquire_ctx = ctx;

	connector_state = drm_atomic_get_connector_state(state, connector);
	if (IS_ERR(connector_state)) {
		ret = PTR_ERR(connector_state);
		goto fail;
	}

	connector_state->crtc = crtc;
	connector_state->best_encoder = &intel_encoder->base;

	crtc_state = intel_atomic_get_crtc_state(state, intel_crtc);
	if (IS_ERR(crtc_state)) {
		ret = PTR_ERR(crtc_state);
		goto fail;
	}

	crtc_state->base.active = crtc_state->base.enable = true;

	if (!mode)
		mode = &load_detect_mode;

	/* We need a framebuffer large enough to accommodate all accesses
	 * that the plane may generate whilst we perform load detection.
	 * We can not rely on the fbcon either being present (we get called
	 * during its initialisation to detect all boot displays, or it may
	 * not even exist) or that it is large enough to satisfy the
	 * requested mode.
	 */
	fb = mode_fits_in_fbdev(dev, mode);
	if (fb == NULL) {
		DRM_DEBUG_KMS("creating tmp fb for load-detection\n");
		fb = intel_framebuffer_create_for_mode(dev, mode, 24, 32);
		old->release_fb = fb;
	} else
		DRM_DEBUG_KMS("reusing fbdev for load-detection framebuffer\n");
	if (IS_ERR(fb)) {
		DRM_DEBUG_KMS("failed to allocate framebuffer for load-detection\n");
		goto fail;
	}

	ret = intel_modeset_setup_plane_state(state, crtc, mode, fb, 0, 0);
	if (ret)
		goto fail;

	drm_mode_copy(&crtc_state->base.mode, mode);

	if (drm_atomic_commit(state)) {
		DRM_DEBUG_KMS("failed to set mode on load-detect pipe\n");
		if (old->release_fb)
			old->release_fb->funcs->destroy(old->release_fb);
		goto fail;
	}
	crtc->primary->crtc = crtc;

	/* let the connector get through one full cycle before testing */
	intel_wait_for_vblank(dev, intel_crtc->pipe);
	return true;

fail:
	drm_atomic_state_free(state);
	state = NULL;

	if (ret == -EDEADLK) {
		drm_modeset_backoff(ctx);
		goto retry;
	}

	return false;
}

void intel_release_load_detect_pipe(struct drm_connector *connector,
				    struct intel_load_detect_pipe *old,
				    struct drm_modeset_acquire_ctx *ctx)
{
	struct drm_device *dev = connector->dev;
	struct intel_encoder *intel_encoder =
		intel_attached_encoder(connector);
	struct drm_encoder *encoder = &intel_encoder->base;
	struct drm_crtc *crtc = encoder->crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_atomic_state *state;
	struct drm_connector_state *connector_state;
	struct intel_crtc_state *crtc_state;
	int ret;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s], [ENCODER:%d:%s]\n",
		      connector->base.id, connector->name,
		      encoder->base.id, encoder->name);

	if (old->load_detect_temp) {
		state = drm_atomic_state_alloc(dev);
		if (!state)
			goto fail;

		state->acquire_ctx = ctx;

		connector_state = drm_atomic_get_connector_state(state, connector);
		if (IS_ERR(connector_state))
			goto fail;

		crtc_state = intel_atomic_get_crtc_state(state, intel_crtc);
		if (IS_ERR(crtc_state))
			goto fail;

		connector_state->best_encoder = NULL;
		connector_state->crtc = NULL;

		crtc_state->base.enable = crtc_state->base.active = false;

		ret = intel_modeset_setup_plane_state(state, crtc, NULL, NULL,
						      0, 0);
		if (ret)
			goto fail;

		ret = drm_atomic_commit(state);
		if (ret)
			goto fail;

		if (old->release_fb) {
			drm_framebuffer_unregister_private(old->release_fb);
			drm_framebuffer_unreference(old->release_fb);
		}

		return;
	}

	/* Switch crtc and encoder back off if necessary */
	if (old->dpms_mode != DRM_MODE_DPMS_ON)
		connector->funcs->dpms(connector, old->dpms_mode);

	return;
fail:
	DRM_DEBUG_KMS("Couldn't release load detect pipe.\n");
	drm_atomic_state_free(state);
}

static int i9xx_pll_refclk(struct drm_device *dev,
			   const struct intel_crtc_state *pipe_config)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpll = pipe_config->dpll_hw_state.dpll;

	if ((dpll & PLL_REF_INPUT_MASK) == PLLB_REF_INPUT_SPREADSPECTRUMIN)
		return dev_priv->vbt.lvds_ssc_freq;
	else if (HAS_PCH_SPLIT(dev))
		return 120000;
	else if (!IS_GEN2(dev))
		return 96000;
	else
		return 48000;
}

/* Returns the clock of the currently programmed mode of the given pipe. */
static void i9xx_crtc_clock_get(struct intel_crtc *crtc,
				struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = pipe_config->cpu_transcoder;
	u32 dpll = pipe_config->dpll_hw_state.dpll;
	u32 fp;
	intel_clock_t clock;
	int port_clock;
	int refclk = i9xx_pll_refclk(dev, pipe_config);

	if ((dpll & DISPLAY_RATE_SELECT_FPA1) == 0)
		fp = pipe_config->dpll_hw_state.fp0;
	else
		fp = pipe_config->dpll_hw_state.fp1;

	clock.m1 = (fp & FP_M1_DIV_MASK) >> FP_M1_DIV_SHIFT;
	if (IS_PINEVIEW(dev)) {
		clock.n = ffs((fp & FP_N_PINEVIEW_DIV_MASK) >> FP_N_DIV_SHIFT) - 1;
		clock.m2 = (fp & FP_M2_PINEVIEW_DIV_MASK) >> FP_M2_DIV_SHIFT;
	} else {
		clock.n = (fp & FP_N_DIV_MASK) >> FP_N_DIV_SHIFT;
		clock.m2 = (fp & FP_M2_DIV_MASK) >> FP_M2_DIV_SHIFT;
	}

	if (!IS_GEN2(dev)) {
		if (IS_PINEVIEW(dev))
			clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_PINEVIEW) >>
				DPLL_FPA01_P1_POST_DIV_SHIFT_PINEVIEW);
		else
			clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK) >>
			       DPLL_FPA01_P1_POST_DIV_SHIFT);

		switch (dpll & DPLL_MODE_MASK) {
		case DPLLB_MODE_DAC_SERIAL:
			clock.p2 = dpll & DPLL_DAC_SERIAL_P2_CLOCK_DIV_5 ?
				5 : 10;
			break;
		case DPLLB_MODE_LVDS:
			clock.p2 = dpll & DPLLB_LVDS_P2_CLOCK_DIV_7 ?
				7 : 14;
			break;
		default:
			DRM_DEBUG_KMS("Unknown DPLL mode %08x in programmed "
				  "mode\n", (int)(dpll & DPLL_MODE_MASK));
			return;
		}

		if (IS_PINEVIEW(dev))
			port_clock = pnv_calc_dpll_params(refclk, &clock);
		else
			port_clock = i9xx_calc_dpll_params(refclk, &clock);
	} else {
		u32 lvds = IS_I830(dev) ? 0 : I915_READ(LVDS);
		bool is_lvds = (pipe == 1) && (lvds & LVDS_PORT_EN);

		if (is_lvds) {
			clock.p1 = ffs((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830_LVDS) >>
				       DPLL_FPA01_P1_POST_DIV_SHIFT);

			if (lvds & LVDS_CLKB_POWER_UP)
				clock.p2 = 7;
			else
				clock.p2 = 14;
		} else {
			if (dpll & PLL_P1_DIVIDE_BY_TWO)
				clock.p1 = 2;
			else {
				clock.p1 = ((dpll & DPLL_FPA01_P1_POST_DIV_MASK_I830) >>
					    DPLL_FPA01_P1_POST_DIV_SHIFT) + 2;
			}
			if (dpll & PLL_P2_DIVIDE_BY_4)
				clock.p2 = 4;
			else
				clock.p2 = 2;
		}

		port_clock = i9xx_calc_dpll_params(refclk, &clock);
	}

	/*
	 * This value includes pixel_multiplier. We will use
	 * port_clock to compute adjusted_mode.crtc_clock in the
	 * encoder's get_config() function.
	 */
	pipe_config->port_clock = port_clock;
}

int intel_dotclock_calculate(int link_freq,
			     const struct intel_link_m_n *m_n)
{
	/*
	 * The calculation for the data clock is:
	 * pixel_clock = ((m/n)*(link_clock * nr_lanes))/bpp
	 * But we want to avoid losing precison if possible, so:
	 * pixel_clock = ((m * link_clock * nr_lanes)/(n*bpp))
	 *
	 * and the link clock is simpler:
	 * link_clock = (m * link_clock) / n
	 */

	if (!m_n->link_n)
		return 0;

	return div_u64((u64)m_n->link_m * link_freq, m_n->link_n);
}

static void ironlake_pch_clock_get(struct intel_crtc *crtc,
				   struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;

	/* read out port_clock from the DPLL */
	i9xx_crtc_clock_get(crtc, pipe_config);

	/*
	 * This value does not include pixel_multiplier.
	 * We will check that port_clock and adjusted_mode.crtc_clock
	 * agree once we know their relationship in the encoder's
	 * get_config() function.
	 */
	pipe_config->base.adjusted_mode.crtc_clock =
		intel_dotclock_calculate(intel_fdi_link_freq(dev) * 10000,
					 &pipe_config->fdi_m_n);
}

/** Returns the currently programmed mode of the given pipe. */
struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
					     struct drm_crtc *crtc)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum transcoder cpu_transcoder = intel_crtc->config->cpu_transcoder;
	struct drm_display_mode *mode;
	struct intel_crtc_state pipe_config;
	int htot = I915_READ(HTOTAL(cpu_transcoder));
	int hsync = I915_READ(HSYNC(cpu_transcoder));
	int vtot = I915_READ(VTOTAL(cpu_transcoder));
	int vsync = I915_READ(VSYNC(cpu_transcoder));
	enum pipe pipe = intel_crtc->pipe;

	mode = kzalloc(sizeof(*mode), GFP_KERNEL);
	if (!mode)
		return NULL;

	/*
	 * Construct a pipe_config sufficient for getting the clock info
	 * back out of crtc_clock_get.
	 *
	 * Note, if LVDS ever uses a non-1 pixel multiplier, we'll need
	 * to use a real value here instead.
	 */
	pipe_config.cpu_transcoder = (enum transcoder) pipe;
	pipe_config.pixel_multiplier = 1;
	pipe_config.dpll_hw_state.dpll = I915_READ(DPLL(pipe));
	pipe_config.dpll_hw_state.fp0 = I915_READ(FP0(pipe));
	pipe_config.dpll_hw_state.fp1 = I915_READ(FP1(pipe));
	i9xx_crtc_clock_get(intel_crtc, &pipe_config);

	mode->clock = pipe_config.port_clock / pipe_config.pixel_multiplier;
	mode->hdisplay = (htot & 0xffff) + 1;
	mode->htotal = ((htot & 0xffff0000) >> 16) + 1;
	mode->hsync_start = (hsync & 0xffff) + 1;
	mode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;
	mode->vdisplay = (vtot & 0xffff) + 1;
	mode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;
	mode->vsync_start = (vsync & 0xffff) + 1;
	mode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;

	drm_mode_set_name(mode);

	return mode;
}

void intel_mark_busy(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev_priv->mm.busy)
		return;

	intel_runtime_pm_get(dev_priv);
	i915_update_gfx_val(dev_priv);
	if (INTEL_INFO(dev)->gen >= 6)
		gen6_rps_busy(dev_priv);
	dev_priv->mm.busy = true;
}

void intel_mark_idle(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!dev_priv->mm.busy)
		return;

	dev_priv->mm.busy = false;

	if (INTEL_INFO(dev)->gen >= 6)
		gen6_rps_idle(dev->dev_private);

	intel_runtime_pm_put(dev_priv);
}

static void intel_crtc_destroy(struct drm_crtc *crtc)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_device *dev = crtc->dev;
	struct intel_unpin_work *work;

	spin_lock_irq(&dev->event_lock);
	work = intel_crtc->unpin_work;
	intel_crtc->unpin_work = NULL;
	spin_unlock_irq(&dev->event_lock);

	if (work) {
		cancel_work_sync(&work->work);
		kfree(work);
	}

	drm_crtc_cleanup(crtc);

	kfree(intel_crtc);
}

static void intel_unpin_work_fn(struct work_struct *__work)
{
	struct intel_unpin_work *work =
		container_of(__work, struct intel_unpin_work, work);
	struct intel_crtc *crtc = to_intel_crtc(work->crtc);
	struct drm_device *dev = crtc->base.dev;
	struct drm_plane *primary = crtc->base.primary;

	mutex_lock(&dev->struct_mutex);
	intel_unpin_fb_obj(work->old_fb, primary->state);
	drm_gem_object_unreference(&work->pending_flip_obj->base);

	if (work->flip_queued_req)
		i915_gem_request_assign(&work->flip_queued_req, NULL);
	mutex_unlock(&dev->struct_mutex);

	intel_frontbuffer_flip_complete(dev, to_intel_plane(primary)->frontbuffer_bit);
	drm_framebuffer_unreference(work->old_fb);

	BUG_ON(atomic_read(&crtc->unpin_work_count) == 0);
	atomic_dec(&crtc->unpin_work_count);

	kfree(work);
}

static void do_intel_finish_page_flip(struct drm_device *dev,
				      struct drm_crtc *crtc)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_unpin_work *work;
	unsigned long flags;

	/* Ignore early vblank irqs */
	if (intel_crtc == NULL)
		return;

	/*
	 * This is called both by irq handlers and the reset code (to complete
	 * lost pageflips) so needs the full irqsave spinlocks.
	 */
	spin_lock_irqsave(&dev->event_lock, flags);
	work = intel_crtc->unpin_work;

	/* Ensure we don't miss a work->pending update ... */
	smp_rmb();

	if (work == NULL || atomic_read(&work->pending) < INTEL_FLIP_COMPLETE) {
		spin_unlock_irqrestore(&dev->event_lock, flags);
		return;
	}

	page_flip_completed(intel_crtc);

	spin_unlock_irqrestore(&dev->event_lock, flags);
}

void intel_finish_page_flip(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];

	do_intel_finish_page_flip(dev, crtc);
}

void intel_finish_page_flip_plane(struct drm_device *dev, int plane)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->plane_to_crtc_mapping[plane];

	do_intel_finish_page_flip(dev, crtc);
}

/* Is 'a' after or equal to 'b'? */
static bool g4x_flip_count_after_eq(u32 a, u32 b)
{
	return !((a - b) & 0x80000000);
}

static bool page_flip_finished(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (i915_reset_in_progress(&dev_priv->gpu_error) ||
	    crtc->reset_counter != atomic_read(&dev_priv->gpu_error.reset_counter))
		return true;

	/*
	 * The relevant registers doen't exist on pre-ctg.
	 * As the flip done interrupt doesn't trigger for mmio
	 * flips on gmch platforms, a flip count check isn't
	 * really needed there. But since ctg has the registers,
	 * include it in the check anyway.
	 */
	if (INTEL_INFO(dev)->gen < 5 && !IS_G4X(dev))
		return true;

	/*
	 * A DSPSURFLIVE check isn't enough in case the mmio and CS flips
	 * used the same base address. In that case the mmio flip might
	 * have completed, but the CS hasn't even executed the flip yet.
	 *
	 * A flip count check isn't enough as the CS might have updated
	 * the base address just after start of vblank, but before we
	 * managed to process the interrupt. This means we'd complete the
	 * CS flip too soon.
	 *
	 * Combining both checks should get us a good enough result. It may
	 * still happen that the CS flip has been executed, but has not
	 * yet actually completed. But in case the base address is the same
	 * anyway, we don't really care.
	 */
	return (I915_READ(DSPSURFLIVE(crtc->plane)) & ~0xfff) ==
		crtc->unpin_work->gtt_offset &&
		g4x_flip_count_after_eq(I915_READ(PIPE_FLIPCOUNT_G4X(crtc->pipe)),
				    crtc->unpin_work->flip_count);
}

void intel_prepare_page_flip(struct drm_device *dev, int plane)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dev_priv->plane_to_crtc_mapping[plane]);
	unsigned long flags;


	/*
	 * This is called both by irq handlers and the reset code (to complete
	 * lost pageflips) so needs the full irqsave spinlocks.
	 *
	 * NB: An MMIO update of the plane base pointer will also
	 * generate a page-flip completion irq, i.e. every modeset
	 * is also accompanied by a spurious intel_prepare_page_flip().
	 */
	spin_lock_irqsave(&dev->event_lock, flags);
	if (intel_crtc->unpin_work && page_flip_finished(intel_crtc))
		atomic_inc_not_zero(&intel_crtc->unpin_work->pending);
	spin_unlock_irqrestore(&dev->event_lock, flags);
}

static inline void intel_mark_page_flip_active(struct intel_unpin_work *work)
{
	/* Ensure that the work item is consistent when activating it ... */
	smp_wmb();
	atomic_set(&work->pending, INTEL_FLIP_PENDING);
	/* and that it is marked active as soon as the irq could fire. */
	smp_wmb();
}

static int intel_gen2_queue_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct drm_i915_gem_request *req,
				 uint32_t flags)
{
	struct intel_engine_cs *ring = req->ring;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	u32 flip_mask;
	int ret;

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	/* Can't queue multiple flips, so wait for the previous
	 * one to finish before executing the next.
	 */
	if (intel_crtc->plane)
		flip_mask = MI_WAIT_FOR_PLANE_B_FLIP;
	else
		flip_mask = MI_WAIT_FOR_PLANE_A_FLIP;
	intel_ring_emit(ring, MI_WAIT_FOR_EVENT | flip_mask);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_emit(ring, MI_DISPLAY_FLIP |
			MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
	intel_ring_emit(ring, fb->pitches[0]);
	intel_ring_emit(ring, intel_crtc->unpin_work->gtt_offset);
	intel_ring_emit(ring, 0); /* aux display base address, unused */

	intel_mark_page_flip_active(intel_crtc->unpin_work);
	return 0;
}

static int intel_gen3_queue_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct drm_i915_gem_request *req,
				 uint32_t flags)
{
	struct intel_engine_cs *ring = req->ring;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	u32 flip_mask;
	int ret;

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	if (intel_crtc->plane)
		flip_mask = MI_WAIT_FOR_PLANE_B_FLIP;
	else
		flip_mask = MI_WAIT_FOR_PLANE_A_FLIP;
	intel_ring_emit(ring, MI_WAIT_FOR_EVENT | flip_mask);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_emit(ring, MI_DISPLAY_FLIP_I915 |
			MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
	intel_ring_emit(ring, fb->pitches[0]);
	intel_ring_emit(ring, intel_crtc->unpin_work->gtt_offset);
	intel_ring_emit(ring, MI_NOOP);

	intel_mark_page_flip_active(intel_crtc->unpin_work);
	return 0;
}

static int intel_gen4_queue_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct drm_i915_gem_request *req,
				 uint32_t flags)
{
	struct intel_engine_cs *ring = req->ring;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t pf, pipesrc;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	/* i965+ uses the linear or tiled offsets from the
	 * Display Registers (which do not change across a page-flip)
	 * so we need only reprogram the base address.
	 */
	intel_ring_emit(ring, MI_DISPLAY_FLIP |
			MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
	intel_ring_emit(ring, fb->pitches[0]);
	intel_ring_emit(ring, intel_crtc->unpin_work->gtt_offset |
			obj->tiling_mode);

	/* XXX Enabling the panel-fitter across page-flip is so far
	 * untested on non-native modes, so ignore it for now.
	 * pf = I915_READ(pipe == 0 ? PFA_CTL_1 : PFB_CTL_1) & PF_ENABLE;
	 */
	pf = 0;
	pipesrc = I915_READ(PIPESRC(intel_crtc->pipe)) & 0x0fff0fff;
	intel_ring_emit(ring, pf | pipesrc);

	intel_mark_page_flip_active(intel_crtc->unpin_work);
	return 0;
}

static int intel_gen6_queue_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct drm_i915_gem_request *req,
				 uint32_t flags)
{
	struct intel_engine_cs *ring = req->ring;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t pf, pipesrc;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_DISPLAY_FLIP |
			MI_DISPLAY_FLIP_PLANE(intel_crtc->plane));
	intel_ring_emit(ring, fb->pitches[0] | obj->tiling_mode);
	intel_ring_emit(ring, intel_crtc->unpin_work->gtt_offset);

	/* Contrary to the suggestions in the documentation,
	 * "Enable Panel Fitter" does not seem to be required when page
	 * flipping with a non-native mode, and worse causes a normal
	 * modeset to fail.
	 * pf = I915_READ(PF_CTL(intel_crtc->pipe)) & PF_ENABLE;
	 */
	pf = 0;
	pipesrc = I915_READ(PIPESRC(intel_crtc->pipe)) & 0x0fff0fff;
	intel_ring_emit(ring, pf | pipesrc);

	intel_mark_page_flip_active(intel_crtc->unpin_work);
	return 0;
}

static int intel_gen7_queue_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct drm_i915_gem_request *req,
				 uint32_t flags)
{
	struct intel_engine_cs *ring = req->ring;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t plane_bit = 0;
	int len, ret;

	switch (intel_crtc->plane) {
	case PLANE_A:
		plane_bit = MI_DISPLAY_FLIP_IVB_PLANE_A;
		break;
	case PLANE_B:
		plane_bit = MI_DISPLAY_FLIP_IVB_PLANE_B;
		break;
	case PLANE_C:
		plane_bit = MI_DISPLAY_FLIP_IVB_PLANE_C;
		break;
	default:
		WARN_ONCE(1, "unknown plane in flip command\n");
		return -ENODEV;
	}

	len = 4;
	if (ring->id == RCS) {
		len += 6;
		/*
		 * On Gen 8, SRM is now taking an extra dword to accommodate
		 * 48bits addresses, and we need a NOOP for the batch size to
		 * stay even.
		 */
		if (IS_GEN8(dev))
			len += 2;
	}

	/*
	 * BSpec MI_DISPLAY_FLIP for IVB:
	 * "The full packet must be contained within the same cache line."
	 *
	 * Currently the LRI+SRM+MI_DISPLAY_FLIP all fit within the same
	 * cacheline, if we ever start emitting more commands before
	 * the MI_DISPLAY_FLIP we may need to first emit everything else,
	 * then do the cacheline alignment, and finally emit the
	 * MI_DISPLAY_FLIP.
	 */
	ret = intel_ring_cacheline_align(req);
	if (ret)
		return ret;

	ret = intel_ring_begin(req, len);
	if (ret)
		return ret;

	/* Unmask the flip-done completion message. Note that the bspec says that
	 * we should do this for both the BCS and RCS, and that we must not unmask
	 * more than one flip event at any time (or ensure that one flip message
	 * can be sent by waiting for flip-done prior to queueing new flips).
	 * Experimentation says that BCS works despite DERRMR masking all
	 * flip-done completion events and that unmasking all planes at once
	 * for the RCS also doesn't appear to drop events. Setting the DERRMR
	 * to zero does lead to lockups within MI_DISPLAY_FLIP.
	 */
	if (ring->id == RCS) {
		intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
		intel_ring_emit(ring, DERRMR);
		intel_ring_emit(ring, ~(DERRMR_PIPEA_PRI_FLIP_DONE |
					DERRMR_PIPEB_PRI_FLIP_DONE |
					DERRMR_PIPEC_PRI_FLIP_DONE));
		if (IS_GEN8(dev))
			intel_ring_emit(ring, MI_STORE_REGISTER_MEM_GEN8 |
					      MI_SRM_LRM_GLOBAL_GTT);
		else
			intel_ring_emit(ring, MI_STORE_REGISTER_MEM |
					      MI_SRM_LRM_GLOBAL_GTT);
		intel_ring_emit(ring, DERRMR);
		intel_ring_emit(ring, ring->scratch.gtt_offset + 256);
		if (IS_GEN8(dev)) {
			intel_ring_emit(ring, 0);
			intel_ring_emit(ring, MI_NOOP);
		}
	}

	intel_ring_emit(ring, MI_DISPLAY_FLIP_I915 | plane_bit);
	intel_ring_emit(ring, (fb->pitches[0] | obj->tiling_mode));
	intel_ring_emit(ring, intel_crtc->unpin_work->gtt_offset);
	intel_ring_emit(ring, (MI_NOOP));

	intel_mark_page_flip_active(intel_crtc->unpin_work);
	return 0;
}

static bool use_mmio_flip(struct intel_engine_cs *ring,
			  struct drm_i915_gem_object *obj)
{
	/*
	 * This is not being used for older platforms, because
	 * non-availability of flip done interrupt forces us to use
	 * CS flips. Older platforms derive flip done using some clever
	 * tricks involving the flip_pending status bits and vblank irqs.
	 * So using MMIO flips there would disrupt this mechanism.
	 */

	if (ring == NULL)
		return true;

	if (INTEL_INFO(ring->dev)->gen < 5)
		return false;

	if (i915.use_mmio_flip < 0)
		return false;
	else if (i915.use_mmio_flip > 0)
		return true;
	else if (i915.enable_execlists)
		return true;
	else
		return ring != i915_gem_request_get_ring(obj->last_write_req);
}

static void skl_do_mmio_flip(struct intel_crtc *intel_crtc,
			     struct intel_unpin_work *work)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_framebuffer *fb = intel_crtc->base.primary->fb;
	const enum pipe pipe = intel_crtc->pipe;
	u32 ctl, stride;

	ctl = I915_READ(PLANE_CTL(pipe, 0));
	ctl &= ~PLANE_CTL_TILED_MASK;
	switch (fb->modifier[0]) {
	case DRM_FORMAT_MOD_NONE:
		break;
	case I915_FORMAT_MOD_X_TILED:
		ctl |= PLANE_CTL_TILED_X;
		break;
	case I915_FORMAT_MOD_Y_TILED:
		ctl |= PLANE_CTL_TILED_Y;
		break;
	case I915_FORMAT_MOD_Yf_TILED:
		ctl |= PLANE_CTL_TILED_YF;
		break;
	default:
		MISSING_CASE(fb->modifier[0]);
	}

	/*
	 * The stride is either expressed as a multiple of 64 bytes chunks for
	 * linear buffers or in number of tiles for tiled buffers.
	 */
	stride = fb->pitches[0] /
		 intel_fb_stride_alignment(dev, fb->modifier[0],
					   fb->pixel_format);

	/*
	 * Both PLANE_CTL and PLANE_STRIDE are not updated on vblank but on
	 * PLANE_SURF updates, the update is then guaranteed to be atomic.
	 */
	I915_WRITE(PLANE_CTL(pipe, 0), ctl);
	I915_WRITE(PLANE_STRIDE(pipe, 0), stride);

	I915_WRITE(PLANE_SURF(pipe, 0), work->gtt_offset);
	POSTING_READ(PLANE_SURF(pipe, 0));
}

static void ilk_do_mmio_flip(struct intel_crtc *intel_crtc,
			     struct intel_unpin_work *work)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_framebuffer *intel_fb =
		to_intel_framebuffer(intel_crtc->base.primary->fb);
	struct drm_i915_gem_object *obj = intel_fb->obj;
	u32 dspcntr;
	u32 reg;

	reg = DSPCNTR(intel_crtc->plane);
	dspcntr = I915_READ(reg);

	if (obj->tiling_mode != I915_TILING_NONE)
		dspcntr |= DISPPLANE_TILED;
	else
		dspcntr &= ~DISPPLANE_TILED;

	I915_WRITE(reg, dspcntr);

	I915_WRITE(DSPSURF(intel_crtc->plane), work->gtt_offset);
	POSTING_READ(DSPSURF(intel_crtc->plane));
}

/*
 * XXX: This is the temporary way to update the plane registers until we get
 * around to using the usual plane update functions for MMIO flips
 */
static void intel_do_mmio_flip(struct intel_mmio_flip *mmio_flip)
{
	struct intel_crtc *crtc = mmio_flip->crtc;
	struct intel_unpin_work *work;

	spin_lock_irq(&crtc->base.dev->event_lock);
	work = crtc->unpin_work;
	spin_unlock_irq(&crtc->base.dev->event_lock);
	if (work == NULL)
		return;

	intel_mark_page_flip_active(work);

	intel_pipe_update_start(crtc);

	if (INTEL_INFO(mmio_flip->i915)->gen >= 9)
		skl_do_mmio_flip(crtc, work);
	else
		/* use_mmio_flip() retricts MMIO flips to ilk+ */
		ilk_do_mmio_flip(crtc, work);

	intel_pipe_update_end(crtc);
}

static void intel_mmio_flip_work_func(struct work_struct *work)
{
	struct intel_mmio_flip *mmio_flip =
		container_of(work, struct intel_mmio_flip, work);

	if (mmio_flip->req) {
		WARN_ON(__i915_wait_request(mmio_flip->req,
					    mmio_flip->crtc->reset_counter,
					    false, NULL,
					    &mmio_flip->i915->rps.mmioflips));
		i915_gem_request_unreference__unlocked(mmio_flip->req);
	}

	intel_do_mmio_flip(mmio_flip);
	kfree(mmio_flip);
}

static int intel_queue_mmio_flip(struct drm_device *dev,
				 struct drm_crtc *crtc,
				 struct drm_framebuffer *fb,
				 struct drm_i915_gem_object *obj,
				 struct intel_engine_cs *ring,
				 uint32_t flags)
{
	struct intel_mmio_flip *mmio_flip;

	mmio_flip = kmalloc(sizeof(*mmio_flip), GFP_KERNEL);
	if (mmio_flip == NULL)
		return -ENOMEM;

	mmio_flip->i915 = to_i915(dev);
	mmio_flip->req = i915_gem_request_reference(obj->last_write_req);
	mmio_flip->crtc = to_intel_crtc(crtc);

	INIT_WORK(&mmio_flip->work, intel_mmio_flip_work_func);
	schedule_work(&mmio_flip->work);

	return 0;
}

static int intel_default_queue_flip(struct drm_device *dev,
				    struct drm_crtc *crtc,
				    struct drm_framebuffer *fb,
				    struct drm_i915_gem_object *obj,
				    struct drm_i915_gem_request *req,
				    uint32_t flags)
{
	return -ENODEV;
}

static bool __intel_pageflip_stall_check(struct drm_device *dev,
					 struct drm_crtc *crtc)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_unpin_work *work = intel_crtc->unpin_work;
	u32 addr;

	if (atomic_read(&work->pending) >= INTEL_FLIP_COMPLETE)
		return true;

	if (atomic_read(&work->pending) < INTEL_FLIP_PENDING)
		return false;

	if (!work->enable_stall_check)
		return false;

	if (work->flip_ready_vblank == 0) {
		if (work->flip_queued_req &&
		    !i915_gem_request_completed(work->flip_queued_req, true))
			return false;

		work->flip_ready_vblank = drm_crtc_vblank_count(crtc);
	}

	if (drm_crtc_vblank_count(crtc) - work->flip_ready_vblank < 3)
		return false;

	/* Potential stall - if we see that the flip has happened,
	 * assume a missed interrupt. */
	if (INTEL_INFO(dev)->gen >= 4)
		addr = I915_HI_DISPBASE(I915_READ(DSPSURF(intel_crtc->plane)));
	else
		addr = I915_READ(DSPADDR(intel_crtc->plane));

	/* There is a potential issue here with a false positive after a flip
	 * to the same address. We could address this by checking for a
	 * non-incrementing frame counter.
	 */
	return addr == work->gtt_offset;
}

void intel_check_page_flip(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dev_priv->pipe_to_crtc_mapping[pipe];
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_unpin_work *work;

//	WARN_ON(!in_interrupt());

	if (crtc == NULL)
		return;

	spin_lock(&dev->event_lock);
	work = intel_crtc->unpin_work;
	if (work != NULL && __intel_pageflip_stall_check(dev, crtc)) {
		WARN_ONCE(1, "Kicking stuck page flip: queued at %d, now %d\n",
			 work->flip_queued_vblank, drm_vblank_count(dev, pipe));
		page_flip_completed(intel_crtc);
		work = NULL;
	}
	if (work != NULL &&
	    drm_vblank_count(dev, pipe) - work->flip_queued_vblank > 1)
		intel_queue_rps_boost_for_request(dev, work->flip_queued_req);
	spin_unlock(&dev->event_lock);
}

static int intel_crtc_page_flip(struct drm_crtc *crtc,
				struct drm_framebuffer *fb,
				struct drm_pending_vblank_event *event,
				uint32_t page_flip_flags)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_framebuffer *old_fb = crtc->primary->fb;
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *primary = crtc->primary;
	enum pipe pipe = intel_crtc->pipe;
	struct intel_unpin_work *work;
	struct intel_engine_cs *ring;
	bool mmio_flip;
	struct drm_i915_gem_request *request = NULL;
	int ret;

	/*
	 * drm_mode_page_flip_ioctl() should already catch this, but double
	 * check to be safe.  In the future we may enable pageflipping from
	 * a disabled primary plane.
	 */
	if (WARN_ON(intel_fb_obj(old_fb) == NULL))
		return -EBUSY;

	/* Can't change pixel format via MI display flips. */
	if (fb->pixel_format != crtc->primary->fb->pixel_format)
		return -EINVAL;

	/*
	 * TILEOFF/LINOFF registers can't be changed via MI display flips.
	 * Note that pitch changes could also affect these register.
	 */
	if (INTEL_INFO(dev)->gen > 3 &&
	    (fb->offsets[0] != crtc->primary->fb->offsets[0] ||
	     fb->pitches[0] != crtc->primary->fb->pitches[0]))
		return -EINVAL;

	if (i915_terminally_wedged(&dev_priv->gpu_error))
		goto out_hang;

	work = kzalloc(sizeof(*work), GFP_KERNEL);
	if (work == NULL)
		return -ENOMEM;

	work->event = event;
	work->crtc = crtc;
	work->old_fb = old_fb;
	INIT_WORK(&work->work, intel_unpin_work_fn);

	ret = drm_crtc_vblank_get(crtc);
	if (ret)
		goto free_work;

	/* We borrow the event spin lock for protecting unpin_work */
	spin_lock_irq(&dev->event_lock);
	if (intel_crtc->unpin_work) {
		/* Before declaring the flip queue wedged, check if
		 * the hardware completed the operation behind our backs.
		 */
		if (__intel_pageflip_stall_check(dev, crtc)) {
			DRM_DEBUG_DRIVER("flip queue: previous flip completed, continuing\n");
			page_flip_completed(intel_crtc);
		} else {
			DRM_DEBUG_DRIVER("flip queue: crtc already busy\n");
			spin_unlock_irq(&dev->event_lock);

			drm_crtc_vblank_put(crtc);
			kfree(work);
			return -EBUSY;
		}
	}
	intel_crtc->unpin_work = work;
	spin_unlock_irq(&dev->event_lock);

	if (atomic_read(&intel_crtc->unpin_work_count) >= 2)
		flush_workqueue(dev_priv->wq);

	/* Reference the objects for the scheduled work. */
	drm_framebuffer_reference(work->old_fb);
	drm_gem_object_reference(&obj->base);

	crtc->primary->fb = fb;
	update_state_fb(crtc->primary);

	work->pending_flip_obj = obj;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		goto cleanup;

	atomic_inc(&intel_crtc->unpin_work_count);
	intel_crtc->reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);

	if (INTEL_INFO(dev)->gen >= 5 || IS_G4X(dev))
		work->flip_count = I915_READ(PIPE_FLIPCOUNT_G4X(pipe)) + 1;

	if (IS_VALLEYVIEW(dev)) {
		ring = &dev_priv->ring[BCS];
		if (obj->tiling_mode != intel_fb_obj(work->old_fb)->tiling_mode)
			/* vlv: DISPLAY_FLIP fails to change tiling */
			ring = NULL;
	} else if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev)) {
		ring = &dev_priv->ring[BCS];
	} else if (INTEL_INFO(dev)->gen >= 7) {
		ring = i915_gem_request_get_ring(obj->last_write_req);
		if (ring == NULL || ring->id != RCS)
			ring = &dev_priv->ring[BCS];
	} else {
		ring = &dev_priv->ring[RCS];
	}

	mmio_flip = use_mmio_flip(ring, obj);

	/* When using CS flips, we want to emit semaphores between rings.
	 * However, when using mmio flips we will create a task to do the
	 * synchronisation, so all we want here is to pin the framebuffer
	 * into the display plane and skip any waits.
	 */
	ret = intel_pin_and_fence_fb_obj(crtc->primary, fb,
					 crtc->primary->state,
					 mmio_flip ? i915_gem_request_get_ring(obj->last_write_req) : ring, &request);
	if (ret)
		goto cleanup_pending;

	work->gtt_offset = intel_plane_obj_offset(to_intel_plane(primary),
						  obj, 0);
	work->gtt_offset += intel_crtc->dspaddr_offset;

	if (mmio_flip) {
		ret = intel_queue_mmio_flip(dev, crtc, fb, obj, ring,
					    page_flip_flags);
		if (ret)
			goto cleanup_unpin;

		i915_gem_request_assign(&work->flip_queued_req,
					obj->last_write_req);
	} else {
		if (!request) {
			ret = i915_gem_request_alloc(ring, ring->default_context, &request);
			if (ret)
				goto cleanup_unpin;
		}

		ret = dev_priv->display.queue_flip(dev, crtc, fb, obj, request,
						   page_flip_flags);
		if (ret)
			goto cleanup_unpin;

		i915_gem_request_assign(&work->flip_queued_req, request);
	}

	if (request)
		i915_add_request_no_flush(request);

	work->flip_queued_vblank = drm_crtc_vblank_count(crtc);
	work->enable_stall_check = true;

	i915_gem_track_fb(intel_fb_obj(work->old_fb), obj,
			  to_intel_plane(primary)->frontbuffer_bit);
	mutex_unlock(&dev->struct_mutex);

	intel_fbc_disable_crtc(intel_crtc);
	intel_frontbuffer_flip_prepare(dev,
				       to_intel_plane(primary)->frontbuffer_bit);

	trace_i915_flip_request(intel_crtc->plane, obj);

	return 0;

cleanup_unpin:
	intel_unpin_fb_obj(fb, crtc->primary->state);
cleanup_pending:
	if (request)
		i915_gem_request_cancel(request);
	atomic_dec(&intel_crtc->unpin_work_count);
	mutex_unlock(&dev->struct_mutex);
cleanup:
	crtc->primary->fb = old_fb;
	update_state_fb(crtc->primary);

	drm_gem_object_unreference_unlocked(&obj->base);
	drm_framebuffer_unreference(work->old_fb);

	spin_lock_irq(&dev->event_lock);
	intel_crtc->unpin_work = NULL;
	spin_unlock_irq(&dev->event_lock);

	drm_crtc_vblank_put(crtc);
free_work:
	kfree(work);

	if (ret == -EIO) {
		struct drm_atomic_state *state;
		struct drm_plane_state *plane_state;

out_hang:
		state = drm_atomic_state_alloc(dev);
		if (!state)
			return -ENOMEM;
		state->acquire_ctx = drm_modeset_legacy_acquire_ctx(crtc);

retry:
		plane_state = drm_atomic_get_plane_state(state, primary);
		ret = PTR_ERR_OR_ZERO(plane_state);
		if (!ret) {
			drm_atomic_set_fb_for_plane(plane_state, fb);

			ret = drm_atomic_set_crtc_for_plane(plane_state, crtc);
			if (!ret)
				ret = drm_atomic_commit(state);
		}

		if (ret == -EDEADLK) {
			drm_modeset_backoff(state->acquire_ctx);
			drm_atomic_state_clear(state);
			goto retry;
		}

		if (ret)
			drm_atomic_state_free(state);

		if (ret == 0 && event) {
			spin_lock_irq(&dev->event_lock);
			drm_send_vblank_event(dev, pipe, event);
			spin_unlock_irq(&dev->event_lock);
		}
	}
	return ret;
}


/**
 * intel_wm_need_update - Check whether watermarks need updating
 * @@plane: drm plane
 * @@state: new plane state
 *
 * Check current plane state versus the new one to determine whether
 * watermarks need to be recalculated.
 *
 * Returns true or false.
 */
static bool intel_wm_need_update(struct drm_plane *plane,
				 struct drm_plane_state *state)
{
	/* Update watermarks on tiling changes. */
	if (!plane->state->fb || !state->fb ||
	    plane->state->fb->modifier[0] != state->fb->modifier[0] ||
	    plane->state->rotation != state->rotation)
		return true;

	if (plane->state->crtc_w != state->crtc_w)
		return true;

	return false;
}

int intel_plane_atomic_calc_changes(struct drm_crtc_state *crtc_state,
				    struct drm_plane_state *plane_state)
{
	struct drm_crtc *crtc = crtc_state->crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_plane *plane = plane_state->plane;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane_state *old_plane_state =
		to_intel_plane_state(plane->state);
#ifdef DRMDEBUG
	int idx = intel_crtc->base.base.id, ret;
#else
	int ret;
#endif
	int i = drm_plane_index(plane);
	bool mode_changed = needs_modeset(crtc_state);
	bool was_crtc_enabled = crtc->state->active;
	bool is_crtc_enabled = crtc_state->active;

	bool turn_off, turn_on, visible, was_visible;
	struct drm_framebuffer *fb = plane_state->fb;

	if (crtc_state && INTEL_INFO(dev)->gen >= 9 &&
	    plane->type != DRM_PLANE_TYPE_CURSOR) {
		ret = skl_update_scaler_plane(
			to_intel_crtc_state(crtc_state),
			to_intel_plane_state(plane_state));
		if (ret)
			return ret;
	}

	/*
	 * Disabling a plane is always okay; we just need to update
	 * fb tracking in a special way since cleanup_fb() won't
	 * get called by the plane helpers.
	 */
	if (old_plane_state->base.fb && !fb)
		intel_crtc->atomic.disabled_planes |= 1 << i;

	was_visible = old_plane_state->visible;
	visible = to_intel_plane_state(plane_state)->visible;

	if (!was_crtc_enabled && WARN_ON(was_visible))
		was_visible = false;

	if (!is_crtc_enabled && WARN_ON(visible))
		visible = false;

	if (!was_visible && !visible)
		return 0;

	turn_off = was_visible && (!visible || mode_changed);
	turn_on = visible && (!was_visible || mode_changed);

	DRM_DEBUG_ATOMIC("[CRTC:%i] has [PLANE:%i] with fb %i\n", idx,
			 plane->base.id, fb ? fb->base.id : -1);

	DRM_DEBUG_ATOMIC("[PLANE:%i] visible %i -> %i, off %i, on %i, ms %i\n",
			 plane->base.id, was_visible, visible,
			 turn_off, turn_on, mode_changed);

	if (turn_on) {
		intel_crtc->atomic.update_wm_pre = true;
		/* must disable cxsr around plane enable/disable */
		if (plane->type != DRM_PLANE_TYPE_CURSOR) {
			intel_crtc->atomic.disable_cxsr = true;
			/* to potentially re-enable cxsr */
			intel_crtc->atomic.wait_vblank = true;
			intel_crtc->atomic.update_wm_post = true;
		}
	} else if (turn_off) {
		intel_crtc->atomic.update_wm_post = true;
		/* must disable cxsr around plane enable/disable */
		if (plane->type != DRM_PLANE_TYPE_CURSOR) {
			if (is_crtc_enabled)
				intel_crtc->atomic.wait_vblank = true;
			intel_crtc->atomic.disable_cxsr = true;
		}
	} else if (intel_wm_need_update(plane, plane_state)) {
		intel_crtc->atomic.update_wm_pre = true;
	}

	if (visible || was_visible)
		intel_crtc->atomic.fb_bits |=
			to_intel_plane(plane)->frontbuffer_bit;

	switch (plane->type) {
	case DRM_PLANE_TYPE_PRIMARY:
		intel_crtc->atomic.wait_for_flips = true;
		intel_crtc->atomic.pre_disable_primary = turn_off;
		intel_crtc->atomic.post_enable_primary = turn_on;

		if (turn_off) {
			/*
			 * FIXME: Actually if we will still have any other
			 * plane enabled on the pipe we could let IPS enabled
			 * still, but for now lets consider that when we make
			 * primary invisible by setting DSPCNTR to 0 on
			 * update_primary_plane function IPS needs to be
			 * disable.
			 */
			intel_crtc->atomic.disable_ips = true;

			intel_crtc->atomic.disable_fbc = true;
		}

		/*
		 * FBC does not work on some platforms for rotated
		 * planes, so disable it when rotation is not 0 and
		 * update it when rotation is set back to 0.
		 *
		 * FIXME: This is redundant with the fbc update done in
		 * the primary plane enable function except that that
		 * one is done too late. We eventually need to unify
		 * this.
		 */

		if (visible &&
		    INTEL_INFO(dev)->gen <= 4 && !IS_G4X(dev) &&
		    dev_priv->fbc.crtc == intel_crtc &&
		    plane_state->rotation != BIT(DRM_ROTATE_0))
			intel_crtc->atomic.disable_fbc = true;

		/*
		 * BDW signals flip done immediately if the plane
		 * is disabled, even if the plane enable is already
		 * armed to occur at the next vblank :(
		 */
		if (turn_on && IS_BROADWELL(dev))
			intel_crtc->atomic.wait_vblank = true;

		intel_crtc->atomic.update_fbc |= visible || mode_changed;
		break;
	case DRM_PLANE_TYPE_CURSOR:
		break;
	case DRM_PLANE_TYPE_OVERLAY:
		if (turn_off && !mode_changed) {
			intel_crtc->atomic.wait_vblank = true;
			intel_crtc->atomic.update_sprite_watermarks |=
				1 << i;
		}
	}
	return 0;
}

static bool encoders_cloneable(const struct intel_encoder *a,
			       const struct intel_encoder *b)
{
	/* masks could be asymmetric, so check both ways */
	return a == b || (a->cloneable & (1 << b->type) &&
			  b->cloneable & (1 << a->type));
}

static bool check_single_encoder_cloning(struct drm_atomic_state *state,
					 struct intel_crtc *crtc,
					 struct intel_encoder *encoder)
{
	struct intel_encoder *source_encoder;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	int i;

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != &crtc->base)
			continue;

		source_encoder =
			to_intel_encoder(connector_state->best_encoder);
		if (!encoders_cloneable(encoder, source_encoder))
			return false;
	}

	return true;
}

static bool check_encoder_cloning(struct drm_atomic_state *state,
				  struct intel_crtc *crtc)
{
	struct intel_encoder *encoder;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	int i;

	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != &crtc->base)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);
		if (!check_single_encoder_cloning(state, crtc, encoder))
			return false;
	}

	return true;
}

static int intel_crtc_atomic_check(struct drm_crtc *crtc,
				   struct drm_crtc_state *crtc_state)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_crtc_state *pipe_config =
		to_intel_crtc_state(crtc_state);
	struct drm_atomic_state *state = crtc_state->state;
	int ret;
	bool mode_changed = needs_modeset(crtc_state);

	if (mode_changed && !check_encoder_cloning(state, intel_crtc)) {
		DRM_DEBUG_KMS("rejecting invalid cloning configuration\n");
		return -EINVAL;
	}

	if (mode_changed && !crtc_state->active)
		intel_crtc->atomic.update_wm_post = true;

	if (mode_changed && crtc_state->enable &&
	    dev_priv->display.crtc_compute_clock &&
	    !WARN_ON(pipe_config->shared_dpll != DPLL_ID_PRIVATE)) {
		ret = dev_priv->display.crtc_compute_clock(intel_crtc,
							   pipe_config);
		if (ret)
			return ret;
	}

	ret = 0;
	if (INTEL_INFO(dev)->gen >= 9) {
		if (mode_changed)
			ret = skl_update_scaler_crtc(pipe_config);

		if (!ret)
			ret = intel_atomic_setup_scalers(dev, intel_crtc,
							 pipe_config);
	}

	return ret;
}

static const struct drm_crtc_helper_funcs intel_helper_funcs = {
	.mode_set_base_atomic = intel_pipe_set_base_atomic,
	.load_lut = intel_crtc_load_lut,
	.atomic_begin = intel_begin_crtc_commit,
	.atomic_flush = intel_finish_crtc_commit,
	.atomic_check = intel_crtc_atomic_check,
};

static void intel_modeset_update_connector_atomic_state(struct drm_device *dev)
{
	struct intel_connector *connector;

	for_each_intel_connector(dev, connector) {
		if (connector->base.encoder) {
			connector->base.state->best_encoder =
				connector->base.encoder;
			connector->base.state->crtc =
				connector->base.encoder->crtc;
		} else {
			connector->base.state->best_encoder = NULL;
			connector->base.state->crtc = NULL;
		}
	}
}

static void
connected_sink_compute_bpp(struct intel_connector *connector,
			   struct intel_crtc_state *pipe_config)
{
	int bpp = pipe_config->pipe_bpp;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] checking for sink bpp constrains\n",
		connector->base.base.id,
		connector->base.name);

	/* Don't use an invalid EDID bpc value */
	if (connector->base.display_info.bpc &&
	    connector->base.display_info.bpc * 3 < bpp) {
		DRM_DEBUG_KMS("clamping display bpp (was %d) to EDID reported max of %d\n",
			      bpp, connector->base.display_info.bpc*3);
		pipe_config->pipe_bpp = connector->base.display_info.bpc*3;
	}

	/* Clamp bpp to 8 on screens without EDID 1.4 */
	if (connector->base.display_info.bpc == 0 && bpp > 24) {
		DRM_DEBUG_KMS("clamping display bpp (was %d) to default limit of 24\n",
			      bpp);
		pipe_config->pipe_bpp = 24;
	}
}

static int
compute_baseline_pipe_bpp(struct intel_crtc *crtc,
			  struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_atomic_state *state;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	int bpp, i;

	if ((IS_G4X(dev) || IS_VALLEYVIEW(dev)))
		bpp = 10*3;
	else if (INTEL_INFO(dev)->gen >= 5)
		bpp = 12*3;
	else
		bpp = 8*3;


	pipe_config->pipe_bpp = bpp;

	state = pipe_config->base.state;

	/* Clamp display bpp to EDID value */
	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != &crtc->base)
			continue;

		connected_sink_compute_bpp(to_intel_connector(connector),
					   pipe_config);
	}

	return bpp;
}

static void intel_dump_crtc_timings(const struct drm_display_mode *mode)
{
	DRM_DEBUG_KMS("crtc timings: %d %d %d %d %d %d %d %d %d, "
			"type: 0x%x flags: 0x%x\n",
		mode->crtc_clock,
		mode->crtc_hdisplay, mode->crtc_hsync_start,
		mode->crtc_hsync_end, mode->crtc_htotal,
		mode->crtc_vdisplay, mode->crtc_vsync_start,
		mode->crtc_vsync_end, mode->crtc_vtotal, mode->type, mode->flags);
}

static void intel_dump_pipe_config(struct intel_crtc *crtc,
				   struct intel_crtc_state *pipe_config,
				   const char *context)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_plane *plane;
	struct intel_plane *intel_plane;
	struct intel_plane_state *state;
	struct drm_framebuffer *fb;

	DRM_DEBUG_KMS("[CRTC:%d]%s config %p for pipe %c\n", crtc->base.base.id,
		      context, pipe_config, pipe_name(crtc->pipe));

	DRM_DEBUG_KMS("cpu_transcoder: %c\n", transcoder_name(pipe_config->cpu_transcoder));
	DRM_DEBUG_KMS("pipe bpp: %i, dithering: %i\n",
		      pipe_config->pipe_bpp, pipe_config->dither);
	DRM_DEBUG_KMS("fdi/pch: %i, lanes: %i, gmch_m: %u, gmch_n: %u, link_m: %u, link_n: %u, tu: %u\n",
		      pipe_config->has_pch_encoder,
		      pipe_config->fdi_lanes,
		      pipe_config->fdi_m_n.gmch_m, pipe_config->fdi_m_n.gmch_n,
		      pipe_config->fdi_m_n.link_m, pipe_config->fdi_m_n.link_n,
		      pipe_config->fdi_m_n.tu);
	DRM_DEBUG_KMS("dp: %i, lanes: %i, gmch_m: %u, gmch_n: %u, link_m: %u, link_n: %u, tu: %u\n",
		      pipe_config->has_dp_encoder,
		      pipe_config->lane_count,
		      pipe_config->dp_m_n.gmch_m, pipe_config->dp_m_n.gmch_n,
		      pipe_config->dp_m_n.link_m, pipe_config->dp_m_n.link_n,
		      pipe_config->dp_m_n.tu);

	DRM_DEBUG_KMS("dp: %i, lanes: %i, gmch_m2: %u, gmch_n2: %u, link_m2: %u, link_n2: %u, tu2: %u\n",
		      pipe_config->has_dp_encoder,
		      pipe_config->lane_count,
		      pipe_config->dp_m2_n2.gmch_m,
		      pipe_config->dp_m2_n2.gmch_n,
		      pipe_config->dp_m2_n2.link_m,
		      pipe_config->dp_m2_n2.link_n,
		      pipe_config->dp_m2_n2.tu);

	DRM_DEBUG_KMS("audio: %i, infoframes: %i\n",
		      pipe_config->has_audio,
		      pipe_config->has_infoframe);

	DRM_DEBUG_KMS("requested mode:\n");
	drm_mode_debug_printmodeline(&pipe_config->base.mode);
	DRM_DEBUG_KMS("adjusted mode:\n");
	drm_mode_debug_printmodeline(&pipe_config->base.adjusted_mode);
	intel_dump_crtc_timings(&pipe_config->base.adjusted_mode);
	DRM_DEBUG_KMS("port clock: %d\n", pipe_config->port_clock);
	DRM_DEBUG_KMS("pipe src size: %dx%d\n",
		      pipe_config->pipe_src_w, pipe_config->pipe_src_h);
	DRM_DEBUG_KMS("num_scalers: %d, scaler_users: 0x%x, scaler_id: %d\n",
		      crtc->num_scalers,
		      pipe_config->scaler_state.scaler_users,
		      pipe_config->scaler_state.scaler_id);
	DRM_DEBUG_KMS("gmch pfit: control: 0x%08x, ratios: 0x%08x, lvds border: 0x%08x\n",
		      pipe_config->gmch_pfit.control,
		      pipe_config->gmch_pfit.pgm_ratios,
		      pipe_config->gmch_pfit.lvds_border_bits);
	DRM_DEBUG_KMS("pch pfit: pos: 0x%08x, size: 0x%08x, %s\n",
		      pipe_config->pch_pfit.pos,
		      pipe_config->pch_pfit.size,
		      pipe_config->pch_pfit.enabled ? "enabled" : "disabled");
	DRM_DEBUG_KMS("ips: %i\n", pipe_config->ips_enabled);
	DRM_DEBUG_KMS("double wide: %i\n", pipe_config->double_wide);

	if (IS_BROXTON(dev)) {
		DRM_DEBUG_KMS("ddi_pll_sel: %u; dpll_hw_state: ebb0: 0x%x, ebb4: 0x%x,"
			      "pll0: 0x%x, pll1: 0x%x, pll2: 0x%x, pll3: 0x%x, "
			      "pll6: 0x%x, pll8: 0x%x, pll9: 0x%x, pll10: 0x%x, pcsdw12: 0x%x\n",
			      pipe_config->ddi_pll_sel,
			      pipe_config->dpll_hw_state.ebb0,
			      pipe_config->dpll_hw_state.ebb4,
			      pipe_config->dpll_hw_state.pll0,
			      pipe_config->dpll_hw_state.pll1,
			      pipe_config->dpll_hw_state.pll2,
			      pipe_config->dpll_hw_state.pll3,
			      pipe_config->dpll_hw_state.pll6,
			      pipe_config->dpll_hw_state.pll8,
			      pipe_config->dpll_hw_state.pll9,
			      pipe_config->dpll_hw_state.pll10,
			      pipe_config->dpll_hw_state.pcsdw12);
	} else if (IS_SKYLAKE(dev)) {
		DRM_DEBUG_KMS("ddi_pll_sel: %u; dpll_hw_state: "
			      "ctrl1: 0x%x, cfgcr1: 0x%x, cfgcr2: 0x%x\n",
			      pipe_config->ddi_pll_sel,
			      pipe_config->dpll_hw_state.ctrl1,
			      pipe_config->dpll_hw_state.cfgcr1,
			      pipe_config->dpll_hw_state.cfgcr2);
	} else if (HAS_DDI(dev)) {
		DRM_DEBUG_KMS("ddi_pll_sel: %u; dpll_hw_state: wrpll: 0x%x spll: 0x%x\n",
			      pipe_config->ddi_pll_sel,
			      pipe_config->dpll_hw_state.wrpll,
			      pipe_config->dpll_hw_state.spll);
	} else {
		DRM_DEBUG_KMS("dpll_hw_state: dpll: 0x%x, dpll_md: 0x%x, "
			      "fp0: 0x%x, fp1: 0x%x\n",
			      pipe_config->dpll_hw_state.dpll,
			      pipe_config->dpll_hw_state.dpll_md,
			      pipe_config->dpll_hw_state.fp0,
			      pipe_config->dpll_hw_state.fp1);
	}

	DRM_DEBUG_KMS("planes on this crtc\n");
	list_for_each_entry(plane, &dev->mode_config.plane_list, head) {
		intel_plane = to_intel_plane(plane);
		if (intel_plane->pipe != crtc->pipe)
			continue;

		state = to_intel_plane_state(plane->state);
		fb = state->base.fb;
		if (!fb) {
			DRM_DEBUG_KMS("%s PLANE:%d plane: %u.%u idx: %d "
				"disabled, scaler_id = %d\n",
				plane->type == DRM_PLANE_TYPE_CURSOR ? "CURSOR" : "STANDARD",
				plane->base.id, intel_plane->pipe,
				(crtc->base.primary == plane) ? 0 : intel_plane->plane + 1,
				drm_plane_index(plane), state->scaler_id);
			continue;
		}

		DRM_DEBUG_KMS("%s PLANE:%d plane: %u.%u idx: %d enabled",
			plane->type == DRM_PLANE_TYPE_CURSOR ? "CURSOR" : "STANDARD",
			plane->base.id, intel_plane->pipe,
			crtc->base.primary == plane ? 0 : intel_plane->plane + 1,
			drm_plane_index(plane));
		DRM_DEBUG_KMS("\tFB:%d, fb = %ux%u format = 0x%x",
			fb->base.id, fb->width, fb->height, fb->pixel_format);
		DRM_DEBUG_KMS("\tscaler:%d src (%u, %u) %ux%u dst (%u, %u) %ux%u\n",
			state->scaler_id,
			state->src.x1 >> 16, state->src.y1 >> 16,
			drm_rect_width(&state->src) >> 16,
			drm_rect_height(&state->src) >> 16,
			state->dst.x1, state->dst.y1,
			drm_rect_width(&state->dst), drm_rect_height(&state->dst));
	}
}

static bool check_digital_port_conflicts(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_connector *connector;
	unsigned int used_ports = 0;

	/*
	 * Walk the connector list instead of the encoder
	 * list to detect the problem on ddi platforms
	 * where there's just one encoder per digital port.
	 */
	drm_for_each_connector(connector, dev) {
		struct drm_connector_state *connector_state;
		struct intel_encoder *encoder;

		connector_state = drm_atomic_get_existing_connector_state(state, connector);
		if (!connector_state)
			connector_state = connector->state;

		if (!connector_state->best_encoder)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);

		WARN_ON(!connector_state->crtc);

		switch (encoder->type) {
			unsigned int port_mask;
		case INTEL_OUTPUT_UNKNOWN:
			if (WARN_ON(!HAS_DDI(dev)))
				break;
		case INTEL_OUTPUT_DISPLAYPORT:
		case INTEL_OUTPUT_HDMI:
		case INTEL_OUTPUT_EDP:
			port_mask = 1 << enc_to_dig_port(&encoder->base)->port;

			/* the same port mustn't appear more than once */
			if (used_ports & port_mask)
				return false;

			used_ports |= port_mask;
		default:
			break;
		}
	}

	return true;
}

static void
clear_intel_crtc_state(struct intel_crtc_state *crtc_state)
{
	struct drm_crtc_state tmp_state;
	struct intel_crtc_scaler_state scaler_state;
	struct intel_dpll_hw_state dpll_hw_state;
	enum intel_dpll_id shared_dpll;
	uint32_t ddi_pll_sel;
	bool force_thru;

	/* FIXME: before the switch to atomic started, a new pipe_config was
	 * kzalloc'd. Code that depends on any field being zero should be
	 * fixed, so that the crtc_state can be safely duplicated. For now,
	 * only fields that are know to not cause problems are preserved. */

	tmp_state = crtc_state->base;
	scaler_state = crtc_state->scaler_state;
	shared_dpll = crtc_state->shared_dpll;
	dpll_hw_state = crtc_state->dpll_hw_state;
	ddi_pll_sel = crtc_state->ddi_pll_sel;
	force_thru = crtc_state->pch_pfit.force_thru;

	memset(crtc_state, 0, sizeof *crtc_state);

	crtc_state->base = tmp_state;
	crtc_state->scaler_state = scaler_state;
	crtc_state->shared_dpll = shared_dpll;
	crtc_state->dpll_hw_state = dpll_hw_state;
	crtc_state->ddi_pll_sel = ddi_pll_sel;
	crtc_state->pch_pfit.force_thru = force_thru;
}

static int
intel_modeset_pipe_config(struct drm_crtc *crtc,
			  struct intel_crtc_state *pipe_config)
{
	struct drm_atomic_state *state = pipe_config->base.state;
	struct intel_encoder *encoder;
	struct drm_connector *connector;
	struct drm_connector_state *connector_state;
	int base_bpp, ret = -EINVAL;
	int i;
	bool retry = true;

	clear_intel_crtc_state(pipe_config);

	pipe_config->cpu_transcoder =
		(enum transcoder) to_intel_crtc(crtc)->pipe;

	/*
	 * Sanitize sync polarity flags based on requested ones. If neither
	 * positive or negative polarity is requested, treat this as meaning
	 * negative polarity.
	 */
	if (!(pipe_config->base.adjusted_mode.flags &
	      (DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_NHSYNC)))
		pipe_config->base.adjusted_mode.flags |= DRM_MODE_FLAG_NHSYNC;

	if (!(pipe_config->base.adjusted_mode.flags &
	      (DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC)))
		pipe_config->base.adjusted_mode.flags |= DRM_MODE_FLAG_NVSYNC;

	base_bpp = compute_baseline_pipe_bpp(to_intel_crtc(crtc),
					     pipe_config);
	if (base_bpp < 0)
		goto fail;

	/*
	 * Determine the real pipe dimensions. Note that stereo modes can
	 * increase the actual pipe size due to the frame doubling and
	 * insertion of additional space for blanks between the frame. This
	 * is stored in the crtc timings. We use the requested mode to do this
	 * computation to clearly distinguish it from the adjusted mode, which
	 * can be changed by the connectors in the below retry loop.
	 */
	drm_crtc_get_hv_timing(&pipe_config->base.mode,
			       &pipe_config->pipe_src_w,
			       &pipe_config->pipe_src_h);

encoder_retry:
	/* Ensure the port clock defaults are reset when retrying. */
	pipe_config->port_clock = 0;
	pipe_config->pixel_multiplier = 1;

	/* Fill in default crtc timings, allow encoders to overwrite them. */
	drm_mode_set_crtcinfo(&pipe_config->base.adjusted_mode,
			      CRTC_STEREO_DOUBLE);

	/* Pass our mode to the connectors and the CRTC to give them a chance to
	 * adjust it according to limitations or connector properties, and also
	 * a chance to reject the mode entirely.
	 */
	for_each_connector_in_state(state, connector, connector_state, i) {
		if (connector_state->crtc != crtc)
			continue;

		encoder = to_intel_encoder(connector_state->best_encoder);

		if (!(encoder->compute_config(encoder, pipe_config))) {
			DRM_DEBUG_KMS("Encoder config failure\n");
			goto fail;
		}
	}

	/* Set default port clock if not overwritten by the encoder. Needs to be
	 * done afterwards in case the encoder adjusts the mode. */
	if (!pipe_config->port_clock)
		pipe_config->port_clock = pipe_config->base.adjusted_mode.crtc_clock
			* pipe_config->pixel_multiplier;

	ret = intel_crtc_compute_config(to_intel_crtc(crtc), pipe_config);
	if (ret < 0) {
		DRM_DEBUG_KMS("CRTC fixup failed\n");
		goto fail;
	}

	if (ret == RETRY) {
		if (WARN(!retry, "loop in pipe configuration computation\n")) {
			ret = -EINVAL;
			goto fail;
		}

		DRM_DEBUG_KMS("CRTC bw constrained, retrying\n");
		retry = false;
		goto encoder_retry;
	}

	/* Dithering seems to not pass-through bits correctly when it should, so
	 * only enable it on 6bpc panels. */
	pipe_config->dither = pipe_config->pipe_bpp == 6*3;
	DRM_DEBUG_KMS("hw max bpp: %i, pipe bpp: %i, dithering: %i\n",
		      base_bpp, pipe_config->pipe_bpp, pipe_config->dither);

fail:
	return ret;
}

static void
intel_modeset_update_crtc_state(struct drm_atomic_state *state)
{
	struct drm_crtc *crtc;
	struct drm_crtc_state *crtc_state;
	int i;

	/* Double check state. */
	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		to_intel_crtc(crtc)->config = to_intel_crtc_state(crtc->state);

		/* Update hwmode for vblank functions */
		if (crtc->state->active)
			crtc->hwmode = crtc->state->adjusted_mode;
		else
			crtc->hwmode.crtc_clock = 0;
	}
}

static bool intel_fuzzy_clock_check(int clock1, int clock2)
{
	int diff;

	if (clock1 == clock2)
		return true;

	if (!clock1 || !clock2)
		return false;

	diff = abs(clock1 - clock2);

	if (((((diff + clock1 + clock2) * 100)) / (clock1 + clock2)) < 105)
		return true;

	return false;
}

#define for_each_intel_crtc_masked(dev, mask, intel_crtc) \
	list_for_each_entry((intel_crtc), \
			    &(dev)->mode_config.crtc_list, \
			    base.head) \
		if (mask & (1 <<(intel_crtc)->pipe))

static bool
intel_compare_m_n(unsigned int m, unsigned int n,
		  unsigned int m2, unsigned int n2,
		  bool exact)
{
	if (m == m2 && n == n2)
		return true;

	if (exact || !m || !n || !m2 || !n2)
		return false;

	BUILD_BUG_ON(DATA_LINK_M_N_MASK > INT_MAX);

	if (m > m2) {
		while (m > m2) {
			m2 <<= 1;
			n2 <<= 1;
		}
	} else if (m < m2) {
		while (m < m2) {
			m <<= 1;
			n <<= 1;
		}
	}

	return m == m2 && n == n2;
}

static bool
intel_compare_link_m_n(const struct intel_link_m_n *m_n,
		       struct intel_link_m_n *m2_n2,
		       bool adjust)
{
	if (m_n->tu == m2_n2->tu &&
	    intel_compare_m_n(m_n->gmch_m, m_n->gmch_n,
			      m2_n2->gmch_m, m2_n2->gmch_n, !adjust) &&
	    intel_compare_m_n(m_n->link_m, m_n->link_n,
			      m2_n2->link_m, m2_n2->link_n, !adjust)) {
		if (adjust)
			*m2_n2 = *m_n;

		return true;
	}

	return false;
}

static bool
intel_pipe_config_compare(struct drm_device *dev,
			  struct intel_crtc_state *current_config,
			  struct intel_crtc_state *pipe_config,
			  bool adjust)
{
	bool ret = true;

#define INTEL_ERR_OR_DBG_KMS(fmt, ...) \
	do { \
		if (!adjust) \
			DRM_ERROR(fmt, ##__VA_ARGS__); \
		else \
			DRM_DEBUG_KMS(fmt, ##__VA_ARGS__); \
	} while (0)

#define PIPE_CONF_CHECK_X(name)	\
	if (current_config->name != pipe_config->name) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
			  "(expected 0x%08x, found 0x%08x)\n", \
			  current_config->name, \
			  pipe_config->name); \
		ret = false; \
	}

#define PIPE_CONF_CHECK_I(name)	\
	if (current_config->name != pipe_config->name) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
			  "(expected %i, found %i)\n", \
			  current_config->name, \
			  pipe_config->name); \
		ret = false; \
	}

#define PIPE_CONF_CHECK_M_N(name) \
	if (!intel_compare_link_m_n(&current_config->name, \
				    &pipe_config->name,\
				    adjust)) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
			  "(expected tu %i gmch %i/%i link %i/%i, " \
			  "found tu %i, gmch %i/%i link %i/%i)\n", \
			  current_config->name.tu, \
			  current_config->name.gmch_m, \
			  current_config->name.gmch_n, \
			  current_config->name.link_m, \
			  current_config->name.link_n, \
			  pipe_config->name.tu, \
			  pipe_config->name.gmch_m, \
			  pipe_config->name.gmch_n, \
			  pipe_config->name.link_m, \
			  pipe_config->name.link_n); \
		ret = false; \
	}

#define PIPE_CONF_CHECK_M_N_ALT(name, alt_name) \
	if (!intel_compare_link_m_n(&current_config->name, \
				    &pipe_config->name, adjust) && \
	    !intel_compare_link_m_n(&current_config->alt_name, \
				    &pipe_config->name, adjust)) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
			  "(expected tu %i gmch %i/%i link %i/%i, " \
			  "or tu %i gmch %i/%i link %i/%i, " \
			  "found tu %i, gmch %i/%i link %i/%i)\n", \
			  current_config->name.tu, \
			  current_config->name.gmch_m, \
			  current_config->name.gmch_n, \
			  current_config->name.link_m, \
			  current_config->name.link_n, \
			  current_config->alt_name.tu, \
			  current_config->alt_name.gmch_m, \
			  current_config->alt_name.gmch_n, \
			  current_config->alt_name.link_m, \
			  current_config->alt_name.link_n, \
			  pipe_config->name.tu, \
			  pipe_config->name.gmch_m, \
			  pipe_config->name.gmch_n, \
			  pipe_config->name.link_m, \
			  pipe_config->name.link_n); \
		ret = false; \
	}

/* This is required for BDW+ where there is only one set of registers for
 * switching between high and low RR.
 * This macro can be used whenever a comparison has to be made between one
 * hw state and multiple sw state variables.
 */
#define PIPE_CONF_CHECK_I_ALT(name, alt_name) \
	if ((current_config->name != pipe_config->name) && \
		(current_config->alt_name != pipe_config->name)) { \
			INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
				  "(expected %i or %i, found %i)\n", \
				  current_config->name, \
				  current_config->alt_name, \
				  pipe_config->name); \
			ret = false; \
	}

#define PIPE_CONF_CHECK_FLAGS(name, mask)	\
	if ((current_config->name ^ pipe_config->name) & (mask)) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name "(" #mask ") " \
			  "(expected %i, found %i)\n", \
			  current_config->name & (mask), \
			  pipe_config->name & (mask)); \
		ret = false; \
	}

#define PIPE_CONF_CHECK_CLOCK_FUZZY(name) \
	if (!intel_fuzzy_clock_check(current_config->name, pipe_config->name)) { \
		INTEL_ERR_OR_DBG_KMS("mismatch in " #name " " \
			  "(expected %i, found %i)\n", \
			  current_config->name, \
			  pipe_config->name); \
		ret = false; \
	}

#define PIPE_CONF_QUIRK(quirk)	\
	((current_config->quirks | pipe_config->quirks) & (quirk))

	PIPE_CONF_CHECK_I(cpu_transcoder);

	PIPE_CONF_CHECK_I(has_pch_encoder);
	PIPE_CONF_CHECK_I(fdi_lanes);
	PIPE_CONF_CHECK_M_N(fdi_m_n);

	PIPE_CONF_CHECK_I(has_dp_encoder);
	PIPE_CONF_CHECK_I(lane_count);

	if (INTEL_INFO(dev)->gen < 8) {
		PIPE_CONF_CHECK_M_N(dp_m_n);

		if (current_config->has_drrs)
			PIPE_CONF_CHECK_M_N(dp_m2_n2);
	} else
		PIPE_CONF_CHECK_M_N_ALT(dp_m_n, dp_m2_n2);

	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_hdisplay);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_htotal);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_hblank_start);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_hblank_end);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_hsync_start);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_hsync_end);

	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vdisplay);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vtotal);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vblank_start);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vblank_end);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vsync_start);
	PIPE_CONF_CHECK_I(base.adjusted_mode.crtc_vsync_end);

	PIPE_CONF_CHECK_I(pixel_multiplier);
	PIPE_CONF_CHECK_I(has_hdmi_sink);
	if ((INTEL_INFO(dev)->gen < 8 && !IS_HASWELL(dev)) ||
	    IS_VALLEYVIEW(dev))
		PIPE_CONF_CHECK_I(limited_color_range);
	PIPE_CONF_CHECK_I(has_infoframe);

#ifdef notyet
	PIPE_CONF_CHECK_I(has_audio);
#endif

	PIPE_CONF_CHECK_FLAGS(base.adjusted_mode.flags,
			      DRM_MODE_FLAG_INTERLACE);

	if (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS)) {
		PIPE_CONF_CHECK_FLAGS(base.adjusted_mode.flags,
				      DRM_MODE_FLAG_PHSYNC);
		PIPE_CONF_CHECK_FLAGS(base.adjusted_mode.flags,
				      DRM_MODE_FLAG_NHSYNC);
		PIPE_CONF_CHECK_FLAGS(base.adjusted_mode.flags,
				      DRM_MODE_FLAG_PVSYNC);
		PIPE_CONF_CHECK_FLAGS(base.adjusted_mode.flags,
				      DRM_MODE_FLAG_NVSYNC);
	}

	PIPE_CONF_CHECK_X(gmch_pfit.control);
	/* pfit ratios are autocomputed by the hw on gen4+ */
	if (INTEL_INFO(dev)->gen < 4)
		PIPE_CONF_CHECK_I(gmch_pfit.pgm_ratios);
	PIPE_CONF_CHECK_X(gmch_pfit.lvds_border_bits);

	if (!adjust) {
		PIPE_CONF_CHECK_I(pipe_src_w);
		PIPE_CONF_CHECK_I(pipe_src_h);

		PIPE_CONF_CHECK_I(pch_pfit.enabled);
		if (current_config->pch_pfit.enabled) {
			PIPE_CONF_CHECK_X(pch_pfit.pos);
			PIPE_CONF_CHECK_X(pch_pfit.size);
		}

		PIPE_CONF_CHECK_I(scaler_state.scaler_id);
	}

	/* BDW+ don't expose a synchronous way to read the state */
	if (IS_HASWELL(dev))
		PIPE_CONF_CHECK_I(ips_enabled);

	PIPE_CONF_CHECK_I(double_wide);

	PIPE_CONF_CHECK_X(ddi_pll_sel);

	PIPE_CONF_CHECK_I(shared_dpll);
	PIPE_CONF_CHECK_X(dpll_hw_state.dpll);
	PIPE_CONF_CHECK_X(dpll_hw_state.dpll_md);
	PIPE_CONF_CHECK_X(dpll_hw_state.fp0);
	PIPE_CONF_CHECK_X(dpll_hw_state.fp1);
	PIPE_CONF_CHECK_X(dpll_hw_state.wrpll);
	PIPE_CONF_CHECK_X(dpll_hw_state.spll);
	PIPE_CONF_CHECK_X(dpll_hw_state.ctrl1);
	PIPE_CONF_CHECK_X(dpll_hw_state.cfgcr1);
	PIPE_CONF_CHECK_X(dpll_hw_state.cfgcr2);

	if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5)
		PIPE_CONF_CHECK_I(pipe_bpp);

	PIPE_CONF_CHECK_CLOCK_FUZZY(base.adjusted_mode.crtc_clock);
	PIPE_CONF_CHECK_CLOCK_FUZZY(port_clock);

#undef PIPE_CONF_CHECK_X
#undef PIPE_CONF_CHECK_I
#undef PIPE_CONF_CHECK_I_ALT
#undef PIPE_CONF_CHECK_FLAGS
#undef PIPE_CONF_CHECK_CLOCK_FUZZY
#undef PIPE_CONF_QUIRK
#undef INTEL_ERR_OR_DBG_KMS

	return ret;
}

static void check_wm_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct skl_ddb_allocation hw_ddb, *sw_ddb;
	struct intel_crtc *intel_crtc;
	int plane;

	if (INTEL_INFO(dev)->gen < 9)
		return;

	skl_ddb_get_hw_state(dev_priv, &hw_ddb);
	sw_ddb = &dev_priv->wm.skl_hw.ddb;

	for_each_intel_crtc(dev, intel_crtc) {
		struct skl_ddb_entry *hw_entry, *sw_entry;
		const enum pipe pipe = intel_crtc->pipe;

		if (!intel_crtc->active)
			continue;

		/* planes */
		for_each_plane(dev_priv, pipe, plane) {
			hw_entry = &hw_ddb.plane[pipe][plane];
			sw_entry = &sw_ddb->plane[pipe][plane];

			if (skl_ddb_entry_equal(hw_entry, sw_entry))
				continue;

			DRM_ERROR("mismatch in DDB state pipe %c plane %d "
				  "(expected (%u,%u), found (%u,%u))\n",
				  pipe_name(pipe), plane + 1,
				  sw_entry->start, sw_entry->end,
				  hw_entry->start, hw_entry->end);
		}

		/* cursor */
		hw_entry = &hw_ddb.plane[pipe][PLANE_CURSOR];
		sw_entry = &sw_ddb->plane[pipe][PLANE_CURSOR];

		if (skl_ddb_entry_equal(hw_entry, sw_entry))
			continue;

		DRM_ERROR("mismatch in DDB state pipe %c cursor "
			  "(expected (%u,%u), found (%u,%u))\n",
			  pipe_name(pipe),
			  sw_entry->start, sw_entry->end,
			  hw_entry->start, hw_entry->end);
	}
}

static void
check_connector_state(struct drm_device *dev,
		      struct drm_atomic_state *old_state)
{
	struct drm_connector_state *old_conn_state;
	struct drm_connector *connector;
	int i;

	for_each_connector_in_state(old_state, connector, old_conn_state, i) {
		struct drm_encoder *encoder = connector->encoder;
		struct drm_connector_state *state = connector->state;

		/* This also checks the encoder/connector hw state with the
		 * ->get_hw_state callbacks. */
		intel_connector_check_state(to_intel_connector(connector));

		I915_STATE_WARN(state->best_encoder != encoder,
		     "connector's atomic encoder doesn't match legacy encoder\n");
	}
}

static void
check_encoder_state(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	struct intel_connector *connector;

	for_each_intel_encoder(dev, encoder) {
		bool enabled = false;
		enum pipe pipe;

		DRM_DEBUG_KMS("[ENCODER:%d:%s]\n",
			      encoder->base.base.id,
			      encoder->base.name);

		for_each_intel_connector(dev, connector) {
			if (connector->base.state->best_encoder != &encoder->base)
				continue;
			enabled = true;

			I915_STATE_WARN(connector->base.state->crtc !=
					encoder->base.crtc,
			     "connector's crtc doesn't match encoder crtc\n");
		}

		I915_STATE_WARN(!!encoder->base.crtc != enabled,
		     "encoder's enabled state mismatch "
		     "(expected %i, found %i)\n",
		     !!encoder->base.crtc, enabled);

		if (!encoder->base.crtc) {
			bool active;

			active = encoder->get_hw_state(encoder, &pipe);
			I915_STATE_WARN(active,
			     "encoder detached but still enabled on pipe %c.\n",
			     pipe_name(pipe));
		}
	}
}

static void
check_crtc_state(struct drm_device *dev, struct drm_atomic_state *old_state)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;
	struct drm_crtc_state *old_crtc_state;
	struct drm_crtc *crtc;
	int i;

	for_each_crtc_in_state(old_state, crtc, old_crtc_state, i) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
		struct intel_crtc_state *pipe_config, *sw_config;
		bool active;

		if (!needs_modeset(crtc->state) &&
		    !to_intel_crtc_state(crtc->state)->update_pipe)
			continue;

		__drm_atomic_helper_crtc_destroy_state(crtc, old_crtc_state);
		pipe_config = to_intel_crtc_state(old_crtc_state);
		memset(pipe_config, 0, sizeof(*pipe_config));
		pipe_config->base.crtc = crtc;
		pipe_config->base.state = old_state;

		DRM_DEBUG_KMS("[CRTC:%d]\n",
			      crtc->base.id);

		active = dev_priv->display.get_pipe_config(intel_crtc,
							   pipe_config);

		/* hw state is inconsistent with the pipe quirk */
		if ((intel_crtc->pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE) ||
		    (intel_crtc->pipe == PIPE_B && dev_priv->quirks & QUIRK_PIPEB_FORCE))
			active = crtc->state->active;

		I915_STATE_WARN(crtc->state->active != active,
		     "crtc active state doesn't match with hw state "
		     "(expected %i, found %i)\n", crtc->state->active, active);

		I915_STATE_WARN(intel_crtc->active != crtc->state->active,
		     "transitional active state does not match atomic hw state "
		     "(expected %i, found %i)\n", crtc->state->active, intel_crtc->active);

		for_each_encoder_on_crtc(dev, crtc, encoder) {
			enum pipe pipe;

			active = encoder->get_hw_state(encoder, &pipe);
			I915_STATE_WARN(active != crtc->state->active,
				"[ENCODER:%i] active %i with crtc active %i\n",
				encoder->base.base.id, active, crtc->state->active);

			I915_STATE_WARN(active && intel_crtc->pipe != pipe,
					"Encoder connected to wrong pipe %c\n",
					pipe_name(pipe));

			if (active)
				encoder->get_config(encoder, pipe_config);
		}

		if (!crtc->state->active)
			continue;

		sw_config = to_intel_crtc_state(crtc->state);
		if (!intel_pipe_config_compare(dev, sw_config,
					       pipe_config, false)) {
			I915_STATE_WARN(1, "pipe state doesn't match!\n");
			intel_dump_pipe_config(intel_crtc, pipe_config,
					       "[hw state]");
			intel_dump_pipe_config(intel_crtc, sw_config,
					       "[sw state]");
		}
	}
}

static void
check_shared_dpll_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc;
	struct intel_dpll_hw_state dpll_hw_state;
	int i;

	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		struct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];
		int enabled_crtcs = 0, active_crtcs = 0;
		bool active;

		memset(&dpll_hw_state, 0, sizeof(dpll_hw_state));

		DRM_DEBUG_KMS("%s\n", pll->name);

		active = pll->get_hw_state(dev_priv, pll, &dpll_hw_state);

		I915_STATE_WARN(pll->active > hweight32(pll->config.crtc_mask),
		     "more active pll users than references: %i vs %i\n",
		     pll->active, hweight32(pll->config.crtc_mask));
		I915_STATE_WARN(pll->active && !pll->on,
		     "pll in active use but not on in sw tracking\n");
		I915_STATE_WARN(pll->on && !pll->active,
		     "pll in on but not on in use in sw tracking\n");
		I915_STATE_WARN(pll->on != active,
		     "pll on state mismatch (expected %i, found %i)\n",
		     pll->on, active);

		for_each_intel_crtc(dev, crtc) {
			if (crtc->base.state->enable && intel_crtc_to_shared_dpll(crtc) == pll)
				enabled_crtcs++;
			if (crtc->active && intel_crtc_to_shared_dpll(crtc) == pll)
				active_crtcs++;
		}
		I915_STATE_WARN(pll->active != active_crtcs,
		     "pll active crtcs mismatch (expected %i, found %i)\n",
		     pll->active, active_crtcs);
		I915_STATE_WARN(hweight32(pll->config.crtc_mask) != enabled_crtcs,
		     "pll enabled crtcs mismatch (expected %i, found %i)\n",
		     hweight32(pll->config.crtc_mask), enabled_crtcs);

		I915_STATE_WARN(pll->on && memcmp(&pll->config.hw_state, &dpll_hw_state,
				       sizeof(dpll_hw_state)),
		     "pll hw state mismatch\n");
	}
}

static void
intel_modeset_check_state(struct drm_device *dev,
			  struct drm_atomic_state *old_state)
{
	check_wm_state(dev);
	check_connector_state(dev, old_state);
	check_encoder_state(dev);
	check_crtc_state(dev, old_state);
	check_shared_dpll_state(dev);
}

void ironlake_check_encoder_dotclock(const struct intel_crtc_state *pipe_config,
				     int dotclock)
{
	/*
	 * FDI already provided one idea for the dotclock.
	 * Yell if the encoder disagrees.
	 */
	WARN(!intel_fuzzy_clock_check(pipe_config->base.adjusted_mode.crtc_clock, dotclock),
	     "FDI dotclock and encoder dotclock mismatch, fdi: %i, encoder: %i\n",
	     pipe_config->base.adjusted_mode.crtc_clock, dotclock);
}

static void update_scanline_offset(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;

	/*
	 * The scanline counter increments at the leading edge of hsync.
	 *
	 * On most platforms it starts counting from vtotal-1 on the
	 * first active line. That means the scanline counter value is
	 * always one less than what we would expect. Ie. just after
	 * start of vblank, which also occurs at start of hsync (on the
	 * last active line), the scanline counter will read vblank_start-1.
	 *
	 * On gen2 the scanline counter starts counting from 1 instead
	 * of vtotal-1, so we have to subtract one (or rather add vtotal-1
	 * to keep the value positive), instead of adding one.
	 *
	 * On HSW+ the behaviour of the scanline counter depends on the output
	 * type. For DP ports it behaves like most other platforms, but on HDMI
	 * there's an extra 1 line difference. So we need to add two instead of
	 * one to the value.
	 */
	if (IS_GEN2(dev)) {
		const struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;
		int vtotal;

		vtotal = adjusted_mode->crtc_vtotal;
		if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
			vtotal /= 2;

		crtc->scanline_offset = vtotal - 1;
	} else if (HAS_DDI(dev) &&
		   intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI)) {
		crtc->scanline_offset = 2;
	} else
		crtc->scanline_offset = 1;
}

static void intel_modeset_clear_plls(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct intel_shared_dpll_config *shared_dpll = NULL;
	struct intel_crtc *intel_crtc;
	struct intel_crtc_state *intel_crtc_state;
	struct drm_crtc *crtc;
	struct drm_crtc_state *crtc_state;
	int i;

	if (!dev_priv->display.crtc_compute_clock)
		return;

	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		int dpll;

		intel_crtc = to_intel_crtc(crtc);
		intel_crtc_state = to_intel_crtc_state(crtc_state);
		dpll = intel_crtc_state->shared_dpll;

		if (!needs_modeset(crtc_state) || dpll == DPLL_ID_PRIVATE)
			continue;

		intel_crtc_state->shared_dpll = DPLL_ID_PRIVATE;

		if (!shared_dpll)
			shared_dpll = intel_atomic_get_shared_dpll_state(state);

		shared_dpll[dpll].crtc_mask &= ~(1 << intel_crtc->pipe);
	}
}

/*
 * This implements the workaround described in the "notes" section of the mode
 * set sequence documentation. When going from no pipes or single pipe to
 * multiple pipes, and planes are enabled after the pipe, we need to wait at
 * least 2 vblanks on the first pipe before enabling planes on the second pipe.
 */
static int haswell_mode_set_planes_workaround(struct drm_atomic_state *state)
{
	struct drm_crtc_state *crtc_state;
	struct intel_crtc *intel_crtc;
	struct drm_crtc *crtc;
	struct intel_crtc_state *first_crtc_state = NULL;
	struct intel_crtc_state *other_crtc_state = NULL;
	enum pipe first_pipe = INVALID_PIPE, enabled_pipe = INVALID_PIPE;
	int i;

	/* look at all crtc's that are going to be enabled in during modeset */
	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		intel_crtc = to_intel_crtc(crtc);

		if (!crtc_state->active || !needs_modeset(crtc_state))
			continue;

		if (first_crtc_state) {
			other_crtc_state = to_intel_crtc_state(crtc_state);
			break;
		} else {
			first_crtc_state = to_intel_crtc_state(crtc_state);
			first_pipe = intel_crtc->pipe;
		}
	}

	/* No workaround needed? */
	if (!first_crtc_state)
		return 0;

	/* w/a possibly needed, check how many crtc's are already enabled. */
	for_each_intel_crtc(state->dev, intel_crtc) {
		struct intel_crtc_state *pipe_config;

		pipe_config = intel_atomic_get_crtc_state(state, intel_crtc);
		if (IS_ERR(pipe_config))
			return PTR_ERR(pipe_config);

		pipe_config->hsw_workaround_pipe = INVALID_PIPE;

		if (!pipe_config->base.active ||
		    needs_modeset(&pipe_config->base))
			continue;

		/* 2 or more enabled crtcs means no need for w/a */
		if (enabled_pipe != INVALID_PIPE)
			return 0;

		enabled_pipe = intel_crtc->pipe;
	}

	if (enabled_pipe != INVALID_PIPE)
		first_crtc_state->hsw_workaround_pipe = enabled_pipe;
	else if (other_crtc_state)
		other_crtc_state->hsw_workaround_pipe = first_pipe;

	return 0;
}

static int intel_modeset_all_pipes(struct drm_atomic_state *state)
{
	struct drm_crtc *crtc;
	struct drm_crtc_state *crtc_state;
	int ret = 0;

	/* add all active pipes to the state */
	for_each_crtc(state->dev, crtc) {
		crtc_state = drm_atomic_get_crtc_state(state, crtc);
		if (IS_ERR(crtc_state))
			return PTR_ERR(crtc_state);

		if (!crtc_state->active || needs_modeset(crtc_state))
			continue;

		crtc_state->mode_changed = true;

		ret = drm_atomic_add_affected_connectors(state, crtc);
		if (ret)
			break;

		ret = drm_atomic_add_affected_planes(state, crtc);
		if (ret)
			break;
	}

	return ret;
}

static int intel_modeset_checks(struct drm_atomic_state *state)
{
	struct drm_device *dev = state->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	if (!check_digital_port_conflicts(state)) {
		DRM_DEBUG_KMS("rejecting conflicting digital port configuration\n");
		return -EINVAL;
	}

	/*
	 * See if the config requires any additional preparation, e.g.
	 * to adjust global state with pipes off.  We need to do this
	 * here so we can get the modeset_pipe updated config for the new
	 * mode set on this crtc.  For other crtcs we need to use the
	 * adjusted_mode bits in the crtc directly.
	 */
	if (dev_priv->display.modeset_calc_cdclk) {
		unsigned int cdclk;

		ret = dev_priv->display.modeset_calc_cdclk(state);

		cdclk = to_intel_atomic_state(state)->cdclk;
		if (!ret && cdclk != dev_priv->cdclk_freq)
			ret = intel_modeset_all_pipes(state);

		if (ret < 0)
			return ret;
	} else
		to_intel_atomic_state(state)->cdclk = dev_priv->cdclk_freq;

	intel_modeset_clear_plls(state);

	if (IS_HASWELL(dev))
		return haswell_mode_set_planes_workaround(state);

	return 0;
}

/**
 * intel_atomic_check - validate state object
 * @@dev: drm device
 * @@state: state to validate
 */
static int intel_atomic_check(struct drm_device *dev,
			      struct drm_atomic_state *state)
{
	struct drm_crtc *crtc;
	struct drm_crtc_state *crtc_state;
	int ret, i;
	bool any_ms = false;

	ret = drm_atomic_helper_check_modeset(dev, state);
	if (ret)
		return ret;

	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		struct intel_crtc_state *pipe_config =
			to_intel_crtc_state(crtc_state);

		memset(&to_intel_crtc(crtc)->atomic, 0,
		       sizeof(struct intel_crtc_atomic_commit));

		/* Catch I915_MODE_FLAG_INHERITED */
		if (crtc_state->mode.private_flags != crtc->state->mode.private_flags)
			crtc_state->mode_changed = true;

		if (!crtc_state->enable) {
			if (needs_modeset(crtc_state))
				any_ms = true;
			continue;
		}

		if (!needs_modeset(crtc_state))
			continue;

		/* FIXME: For only active_changed we shouldn't need to do any
		 * state recomputation at all. */

		ret = drm_atomic_add_affected_connectors(state, crtc);
		if (ret)
			return ret;

		ret = intel_modeset_pipe_config(crtc, pipe_config);
		if (ret)
			return ret;

		if (i915.fastboot &&
		    intel_pipe_config_compare(state->dev,
					to_intel_crtc_state(crtc->state),
					pipe_config, true)) {
			crtc_state->mode_changed = false;
			to_intel_crtc_state(crtc_state)->update_pipe = true;
		}

		if (needs_modeset(crtc_state)) {
			any_ms = true;

			ret = drm_atomic_add_affected_planes(state, crtc);
			if (ret)
				return ret;
		}

		intel_dump_pipe_config(to_intel_crtc(crtc), pipe_config,
				       needs_modeset(crtc_state) ?
				       "[modeset]" : "[fastset]");
	}

	if (any_ms) {
		ret = intel_modeset_checks(state);

		if (ret)
			return ret;
	} else
		to_intel_atomic_state(state)->cdclk =
			to_i915(state->dev)->cdclk_freq;

	return drm_atomic_helper_check_planes(state->dev, state);
}

/**
 * intel_atomic_commit - commit validated state object
 * @@dev: DRM device
 * @@state: the top-level driver state object
 * @@async: asynchronous commit
 *
 * This function commits a top-level state object that has been validated
 * with drm_atomic_helper_check().
 *
 * FIXME:  Atomic modeset support for i915 is not yet complete.  At the moment
 * we can only handle plane-related operations and do not yet support
 * asynchronous commit.
 *
 * RETURNS
 * Zero for success or -errno.
 */
static int intel_atomic_commit(struct drm_device *dev,
			       struct drm_atomic_state *state,
			       bool async)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc;
	struct drm_crtc_state *crtc_state;
	int ret = 0;
	int i;
	bool any_ms = false;

	if (async) {
		DRM_DEBUG_KMS("i915 does not yet support async commit\n");
		return -EINVAL;
	}

	ret = drm_atomic_helper_prepare_planes(dev, state);
	if (ret)
		return ret;

	drm_atomic_helper_swap_state(dev, state);

	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

		if (!needs_modeset(crtc->state))
			continue;

		any_ms = true;
		intel_pre_plane_update(intel_crtc);

		if (crtc_state->active) {
			intel_crtc_disable_planes(crtc, crtc_state->plane_mask);
			dev_priv->display.crtc_disable(crtc);
			intel_crtc->active = false;
			intel_disable_shared_dpll(intel_crtc);
		}
	}

	/* Only after disabling all output pipelines that will be changed can we
	 * update the the output configuration. */
	intel_modeset_update_crtc_state(state);

	if (any_ms) {
		intel_shared_dpll_commit(state);

		drm_atomic_helper_update_legacy_modeset_state(state->dev, state);
		modeset_update_crtc_power_domains(state);
	}

	/* Now enable the clocks, plane, pipe, and connectors that we set up. */
	for_each_crtc_in_state(state, crtc, crtc_state, i) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
		bool modeset = needs_modeset(crtc->state);
		bool update_pipe = !modeset &&
			to_intel_crtc_state(crtc->state)->update_pipe;
		unsigned long put_domains = 0;

		if (modeset && crtc->state->active) {
			update_scanline_offset(to_intel_crtc(crtc));
			dev_priv->display.crtc_enable(crtc);
		}

		if (update_pipe) {
			put_domains = modeset_get_crtc_power_domains(crtc);

			/* make sure intel_modeset_check_state runs */
			any_ms = true;
		}

		if (!modeset)
			intel_pre_plane_update(intel_crtc);

		drm_atomic_helper_commit_planes_on_crtc(crtc_state);

		if (put_domains)
			modeset_put_power_domains(dev_priv, put_domains);

		intel_post_plane_update(intel_crtc);
	}

	/* FIXME: add subpixel order */

	drm_atomic_helper_wait_for_vblanks(dev, state);
	drm_atomic_helper_cleanup_planes(dev, state);

	if (any_ms)
		intel_modeset_check_state(dev, state);

	drm_atomic_state_free(state);

	return 0;
}

void intel_crtc_restore_mode(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_atomic_state *state;
	struct drm_crtc_state *crtc_state;
	int ret;

	state = drm_atomic_state_alloc(dev);
	if (!state) {
		DRM_DEBUG_KMS("[CRTC:%d] crtc restore failed, out of memory",
			      crtc->base.id);
		return;
	}

	state->acquire_ctx = drm_modeset_legacy_acquire_ctx(crtc);

retry:
	crtc_state = drm_atomic_get_crtc_state(state, crtc);
	ret = PTR_ERR_OR_ZERO(crtc_state);
	if (!ret) {
		if (!crtc_state->active)
			goto out;

		crtc_state->mode_changed = true;
		ret = drm_atomic_commit(state);
	}

	if (ret == -EDEADLK) {
		drm_atomic_state_clear(state);
		drm_modeset_backoff(state->acquire_ctx);
		goto retry;
	}

	if (ret)
out:
		drm_atomic_state_free(state);
}

#undef for_each_intel_crtc_masked

static const struct drm_crtc_funcs intel_crtc_funcs = {
	.gamma_set = intel_crtc_gamma_set,
	.set_config = drm_atomic_helper_set_config,
	.destroy = intel_crtc_destroy,
	.page_flip = intel_crtc_page_flip,
	.atomic_duplicate_state = intel_crtc_duplicate_state,
	.atomic_destroy_state = intel_crtc_destroy_state,
};

static bool ibx_pch_dpll_get_hw_state(struct drm_i915_private *dev_priv,
				      struct intel_shared_dpll *pll,
				      struct intel_dpll_hw_state *hw_state)
{
	uint32_t val;

	if (!intel_display_power_is_enabled(dev_priv, POWER_DOMAIN_PLLS))
		return false;

	val = I915_READ(PCH_DPLL(pll->id));
	hw_state->dpll = val;
	hw_state->fp0 = I915_READ(PCH_FP0(pll->id));
	hw_state->fp1 = I915_READ(PCH_FP1(pll->id));

	return val & DPLL_VCO_ENABLE;
}

static void ibx_pch_dpll_mode_set(struct drm_i915_private *dev_priv,
				  struct intel_shared_dpll *pll)
{
	I915_WRITE(PCH_FP0(pll->id), pll->config.hw_state.fp0);
	I915_WRITE(PCH_FP1(pll->id), pll->config.hw_state.fp1);
}

static void ibx_pch_dpll_enable(struct drm_i915_private *dev_priv,
				struct intel_shared_dpll *pll)
{
	/* PCH refclock must be enabled first */
	ibx_assert_pch_refclk_enabled(dev_priv);

	I915_WRITE(PCH_DPLL(pll->id), pll->config.hw_state.dpll);

	/* Wait for the clocks to stabilize. */
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(150);

	/* The pixel multiplier can only be updated once the
	 * DPLL is enabled and the clocks are stable.
	 *
	 * So write it again.
	 */
	I915_WRITE(PCH_DPLL(pll->id), pll->config.hw_state.dpll);
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(200);
}

static void ibx_pch_dpll_disable(struct drm_i915_private *dev_priv,
				 struct intel_shared_dpll *pll)
{
	struct drm_device *dev = dev_priv->dev;
	struct intel_crtc *crtc;

	/* Make sure no transcoder isn't still depending on us. */
	for_each_intel_crtc(dev, crtc) {
		if (intel_crtc_to_shared_dpll(crtc) == pll)
			assert_pch_transcoder_disabled(dev_priv, crtc->pipe);
	}

	I915_WRITE(PCH_DPLL(pll->id), 0);
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(200);
}

static char *ibx_pch_dpll_names[] = {
	"PCH DPLL A",
	"PCH DPLL B",
};

static void ibx_pch_dpll_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	dev_priv->num_shared_dpll = 2;

	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		dev_priv->shared_dplls[i].id = i;
		dev_priv->shared_dplls[i].name = ibx_pch_dpll_names[i];
		dev_priv->shared_dplls[i].mode_set = ibx_pch_dpll_mode_set;
		dev_priv->shared_dplls[i].enable = ibx_pch_dpll_enable;
		dev_priv->shared_dplls[i].disable = ibx_pch_dpll_disable;
		dev_priv->shared_dplls[i].get_hw_state =
			ibx_pch_dpll_get_hw_state;
	}
}

static void intel_shared_dpll_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (HAS_DDI(dev))
		intel_ddi_pll_init(dev);
	else if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		ibx_pch_dpll_init(dev);
	else
		dev_priv->num_shared_dpll = 0;

	BUG_ON(dev_priv->num_shared_dpll > I915_NUM_PLLS);
}

/**
 * intel_prepare_plane_fb - Prepare fb for usage on plane
 * @@plane: drm plane to prepare for
 * @@fb: framebuffer to prepare for presentation
 *
 * Prepares a framebuffer for usage on a display plane.  Generally this
 * involves pinning the underlying object and updating the frontbuffer tracking
 * bits.  Some older platforms need special physical address handling for
 * cursor planes.
 *
 * Returns 0 on success, negative error code on failure.
 */
int
intel_prepare_plane_fb(struct drm_plane *plane,
		       const struct drm_plane_state *new_state)
{
	struct drm_device *dev = plane->dev;
	struct drm_framebuffer *fb = new_state->fb;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	struct drm_i915_gem_object *old_obj = intel_fb_obj(plane->fb);
	int ret = 0;

	if (!obj)
		return 0;

	mutex_lock(&dev->struct_mutex);

	if (plane->type == DRM_PLANE_TYPE_CURSOR &&
	    INTEL_INFO(dev)->cursor_needs_physical) {
		int align = IS_I830(dev) ? 16 * 1024 : 256;
		ret = i915_gem_object_attach_phys(obj, align);
		if (ret)
			DRM_DEBUG_KMS("failed to attach phys object\n");
	} else {
		ret = intel_pin_and_fence_fb_obj(plane, fb, new_state, NULL, NULL);
	}

	if (ret == 0)
		i915_gem_track_fb(old_obj, obj, intel_plane->frontbuffer_bit);

	mutex_unlock(&dev->struct_mutex);

	return ret;
}

/**
 * intel_cleanup_plane_fb - Cleans up an fb after plane use
 * @@plane: drm plane to clean up for
 * @@fb: old framebuffer that was on plane
 *
 * Cleans up a framebuffer that has just been removed from a plane.
 */
void
intel_cleanup_plane_fb(struct drm_plane *plane,
		       const struct drm_plane_state *old_state)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_gem_object *obj = intel_fb_obj(old_state->fb);

	if (!obj)
		return;

	if (plane->type != DRM_PLANE_TYPE_CURSOR ||
	    !INTEL_INFO(dev)->cursor_needs_physical) {
		mutex_lock(&dev->struct_mutex);
		intel_unpin_fb_obj(old_state->fb, old_state);
		mutex_unlock(&dev->struct_mutex);
	}
}

int
skl_max_scale(struct intel_crtc *intel_crtc, struct intel_crtc_state *crtc_state)
{
	int max_scale;
	struct drm_device *dev;
	struct drm_i915_private *dev_priv;
	int crtc_clock, cdclk;

	if (!intel_crtc || !crtc_state)
		return DRM_PLANE_HELPER_NO_SCALING;

	dev = intel_crtc->base.dev;
	dev_priv = dev->dev_private;
	crtc_clock = crtc_state->base.adjusted_mode.crtc_clock;
	cdclk = to_intel_atomic_state(crtc_state->base.state)->cdclk;

	if (!crtc_clock || !cdclk)
		return DRM_PLANE_HELPER_NO_SCALING;

	/*
	 * skl max scale is lower of:
	 *    close to 3 but not 3, -1 is for that purpose
	 *            or
	 *    cdclk/crtc_clock
	 */
	max_scale = min((1 << 16) * 3 - 1, (1 << 8) * ((cdclk << 8) / crtc_clock));

	return max_scale;
}

static int
intel_check_primary_plane(struct drm_plane *plane,
			  struct intel_crtc_state *crtc_state,
			  struct intel_plane_state *state)
{
	struct drm_crtc *crtc = state->base.crtc;
	struct drm_framebuffer *fb = state->base.fb;
	int min_scale = DRM_PLANE_HELPER_NO_SCALING;
	int max_scale = DRM_PLANE_HELPER_NO_SCALING;
	bool can_position = false;

	if (INTEL_INFO(plane->dev)->gen >= 9) {
		/* use scaler when colorkey is not required */
		if (state->ckey.flags == I915_SET_COLORKEY_NONE) {
			min_scale = 1;
			max_scale = skl_max_scale(to_intel_crtc(crtc), crtc_state);
		}
		can_position = true;
	}

	return drm_plane_helper_check_update(plane, crtc, fb, &state->src,
					     &state->dst, &state->clip,
					     min_scale, max_scale,
					     can_position, true,
					     &state->visible);
}

static void
intel_commit_primary_plane(struct drm_plane *plane,
			   struct intel_plane_state *state)
{
	struct drm_crtc *crtc = state->base.crtc;
	struct drm_framebuffer *fb = state->base.fb;
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc;
	struct drm_rect *src = &state->src;

	crtc = crtc ? crtc : plane->crtc;
	intel_crtc = to_intel_crtc(crtc);

	plane->fb = fb;
	crtc->x = src->x1 >> 16;
	crtc->y = src->y1 >> 16;

	if (!crtc->state->active)
		return;

	dev_priv->display.update_primary_plane(crtc, fb,
					       state->src.x1 >> 16,
					       state->src.y1 >> 16);
}

static void
intel_disable_primary_plane(struct drm_plane *plane,
			    struct drm_crtc *crtc)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	dev_priv->display.update_primary_plane(crtc, NULL, 0, 0);
}

static void intel_begin_crtc_commit(struct drm_crtc *crtc,
				    struct drm_crtc_state *old_crtc_state)
{
	struct drm_device *dev = crtc->dev;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_crtc_state *old_intel_state =
		to_intel_crtc_state(old_crtc_state);
	bool modeset = needs_modeset(crtc->state);

	if (intel_crtc->atomic.update_wm_pre)
		intel_update_watermarks(crtc);

	/* Perform vblank evasion around commit operation */
	if (crtc->state->active)
		intel_pipe_update_start(intel_crtc);

	if (modeset)
		return;

	if (to_intel_crtc_state(crtc->state)->update_pipe)
		intel_update_pipe_config(intel_crtc, old_intel_state);
	else if (INTEL_INFO(dev)->gen >= 9)
		skl_detach_scalers(intel_crtc);
}

static void intel_finish_crtc_commit(struct drm_crtc *crtc,
				     struct drm_crtc_state *old_crtc_state)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	if (crtc->state->active)
		intel_pipe_update_end(intel_crtc);
}

/**
 * intel_plane_destroy - destroy a plane
 * @@plane: plane to destroy
 *
 * Common destruction function for all types of planes (primary, cursor,
 * sprite).
 */
void intel_plane_destroy(struct drm_plane *plane)
{
	struct intel_plane *intel_plane = to_intel_plane(plane);
	drm_plane_cleanup(plane);
	kfree(intel_plane);
}

const struct drm_plane_funcs intel_plane_funcs = {
	.update_plane = drm_atomic_helper_update_plane,
	.disable_plane = drm_atomic_helper_disable_plane,
	.destroy = intel_plane_destroy,
	.set_property = drm_atomic_helper_plane_set_property,
	.atomic_get_property = intel_plane_atomic_get_property,
	.atomic_set_property = intel_plane_atomic_set_property,
	.atomic_duplicate_state = intel_plane_duplicate_state,
	.atomic_destroy_state = intel_plane_destroy_state,

};

static struct drm_plane *intel_primary_plane_create(struct drm_device *dev,
						    int pipe)
{
	struct intel_plane *primary;
	struct intel_plane_state *state;
	const uint32_t *intel_primary_formats;
	unsigned int num_formats;

	primary = kzalloc(sizeof(*primary), GFP_KERNEL);
	if (primary == NULL)
		return NULL;

	state = intel_create_plane_state(&primary->base);
	if (!state) {
		kfree(primary);
		return NULL;
	}
	primary->base.state = &state->base;

	primary->can_scale = false;
	primary->max_downscale = 1;
	if (INTEL_INFO(dev)->gen >= 9) {
		primary->can_scale = true;
		state->scaler_id = -1;
	}
	primary->pipe = pipe;
	primary->plane = pipe;
	primary->frontbuffer_bit = INTEL_FRONTBUFFER_PRIMARY(pipe);
	primary->check_plane = intel_check_primary_plane;
	primary->commit_plane = intel_commit_primary_plane;
	primary->disable_plane = intel_disable_primary_plane;
	if (HAS_FBC(dev) && INTEL_INFO(dev)->gen < 4)
		primary->plane = !pipe;

	if (INTEL_INFO(dev)->gen >= 9) {
		intel_primary_formats = skl_primary_formats;
		num_formats = ARRAY_SIZE(skl_primary_formats);
	} else if (INTEL_INFO(dev)->gen >= 4) {
		intel_primary_formats = i965_primary_formats;
		num_formats = ARRAY_SIZE(i965_primary_formats);
	} else {
		intel_primary_formats = i8xx_primary_formats;
		num_formats = ARRAY_SIZE(i8xx_primary_formats);
	}

	drm_universal_plane_init(dev, &primary->base, 0,
				 &intel_plane_funcs,
				 intel_primary_formats, num_formats,
				 DRM_PLANE_TYPE_PRIMARY);

	if (INTEL_INFO(dev)->gen >= 4)
		intel_create_rotation_property(dev, primary);

	drm_plane_helper_add(&primary->base, &intel_plane_helper_funcs);

	return &primary->base;
}

void intel_create_rotation_property(struct drm_device *dev, struct intel_plane *plane)
{
	if (!dev->mode_config.rotation_property) {
		unsigned long flags = BIT(DRM_ROTATE_0) |
			BIT(DRM_ROTATE_180);

		if (INTEL_INFO(dev)->gen >= 9)
			flags |= BIT(DRM_ROTATE_90) | BIT(DRM_ROTATE_270);

		dev->mode_config.rotation_property =
			drm_mode_create_rotation_property(dev, flags);
	}
	if (dev->mode_config.rotation_property)
		drm_object_attach_property(&plane->base.base,
				dev->mode_config.rotation_property,
				plane->base.state->rotation);
}

static int
intel_check_cursor_plane(struct drm_plane *plane,
			 struct intel_crtc_state *crtc_state,
			 struct intel_plane_state *state)
{
	struct drm_crtc *crtc = crtc_state->base.crtc;
	struct drm_framebuffer *fb = state->base.fb;
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	enum pipe pipe = to_intel_plane(plane)->pipe;
	unsigned stride;
	int ret;

	ret = drm_plane_helper_check_update(plane, crtc, fb, &state->src,
					    &state->dst, &state->clip,
					    DRM_PLANE_HELPER_NO_SCALING,
					    DRM_PLANE_HELPER_NO_SCALING,
					    true, true, &state->visible);
	if (ret)
		return ret;

	/* if we want to turn off the cursor ignore width and height */
	if (!obj)
		return 0;

	/* Check for which cursor types we support */
	if (!cursor_size_ok(plane->dev, state->base.crtc_w, state->base.crtc_h)) {
		DRM_DEBUG("Cursor dimension %dx%d not supported\n",
			  state->base.crtc_w, state->base.crtc_h);
		return -EINVAL;
	}

	stride = roundup_pow_of_two(state->base.crtc_w) * 4;
	if (obj->base.size < stride * state->base.crtc_h) {
		DRM_DEBUG_KMS("buffer is too small\n");
		return -ENOMEM;
	}

	if (fb->modifier[0] != DRM_FORMAT_MOD_NONE) {
		DRM_DEBUG_KMS("cursor cannot be tiled\n");
		return -EINVAL;
	}

	/*
	 * There's something wrong with the cursor on CHV pipe C.
	 * If it straddles the left edge of the screen then
	 * moving it away from the edge or disabling it often
	 * results in a pipe underrun, and often that can lead to
	 * dead pipe (constant underrun reported, and it scans
	 * out just a solid color). To recover from that, the
	 * display power well must be turned off and on again.
	 * Refuse the put the cursor into that compromised position.
	 */
	if (IS_CHERRYVIEW(plane->dev) && pipe == PIPE_C &&
	    state->visible && state->base.crtc_x < 0) {
		DRM_DEBUG_KMS("CHV cursor C not allowed to straddle the left screen edge\n");
		return -EINVAL;
	}

	return 0;
}

static void
intel_disable_cursor_plane(struct drm_plane *plane,
			   struct drm_crtc *crtc)
{
	intel_crtc_update_cursor(crtc, false);
}

static void
intel_commit_cursor_plane(struct drm_plane *plane,
			  struct intel_plane_state *state)
{
	struct drm_crtc *crtc = state->base.crtc;
	struct drm_device *dev = plane->dev;
	struct intel_crtc *intel_crtc;
	struct drm_i915_gem_object *obj = intel_fb_obj(state->base.fb);
	uint32_t addr;

	crtc = crtc ? crtc : plane->crtc;
	intel_crtc = to_intel_crtc(crtc);

	if (!obj)
		addr = 0;
	else if (!INTEL_INFO(dev)->cursor_needs_physical)
		addr = i915_gem_obj_ggtt_offset(obj);
	else
		addr = obj->phys_handle->segs[0].ds_addr;

	intel_crtc->cursor_addr = addr;

	if (crtc->state->active)
		intel_crtc_update_cursor(crtc, state->visible);
}

static struct drm_plane *intel_cursor_plane_create(struct drm_device *dev,
						   int pipe)
{
	struct intel_plane *cursor;
	struct intel_plane_state *state;

	cursor = kzalloc(sizeof(*cursor), GFP_KERNEL);
	if (cursor == NULL)
		return NULL;

	state = intel_create_plane_state(&cursor->base);
	if (!state) {
		kfree(cursor);
		return NULL;
	}
	cursor->base.state = &state->base;

	cursor->can_scale = false;
	cursor->max_downscale = 1;
	cursor->pipe = pipe;
	cursor->plane = pipe;
	cursor->frontbuffer_bit = INTEL_FRONTBUFFER_CURSOR(pipe);
	cursor->check_plane = intel_check_cursor_plane;
	cursor->commit_plane = intel_commit_cursor_plane;
	cursor->disable_plane = intel_disable_cursor_plane;

	drm_universal_plane_init(dev, &cursor->base, 0,
				 &intel_plane_funcs,
				 intel_cursor_formats,
				 ARRAY_SIZE(intel_cursor_formats),
				 DRM_PLANE_TYPE_CURSOR);

	if (INTEL_INFO(dev)->gen >= 4) {
		if (!dev->mode_config.rotation_property)
			dev->mode_config.rotation_property =
				drm_mode_create_rotation_property(dev,
							BIT(DRM_ROTATE_0) |
							BIT(DRM_ROTATE_180));
		if (dev->mode_config.rotation_property)
			drm_object_attach_property(&cursor->base.base,
				dev->mode_config.rotation_property,
				state->base.rotation);
	}

	if (INTEL_INFO(dev)->gen >=9)
		state->scaler_id = -1;

	drm_plane_helper_add(&cursor->base, &intel_plane_helper_funcs);

	return &cursor->base;
}

static void skl_init_scalers(struct drm_device *dev, struct intel_crtc *intel_crtc,
	struct intel_crtc_state *crtc_state)
{
	int i;
	struct intel_scaler *intel_scaler;
	struct intel_crtc_scaler_state *scaler_state = &crtc_state->scaler_state;

	for (i = 0; i < intel_crtc->num_scalers; i++) {
		intel_scaler = &scaler_state->scalers[i];
		intel_scaler->in_use = 0;
		intel_scaler->mode = PS_SCALER_MODE_DYN;
	}

	scaler_state->scaler_id = -1;
}

static void intel_crtc_init(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc;
	struct intel_crtc_state *crtc_state = NULL;
	struct drm_plane *primary = NULL;
	struct drm_plane *cursor = NULL;
	int i, ret;

	intel_crtc = kzalloc(sizeof(*intel_crtc), GFP_KERNEL);
	if (intel_crtc == NULL)
		return;

	crtc_state = kzalloc(sizeof(*crtc_state), GFP_KERNEL);
	if (!crtc_state)
		goto fail;
	intel_crtc->config = crtc_state;
	intel_crtc->base.state = &crtc_state->base;
	crtc_state->base.crtc = &intel_crtc->base;

	/* initialize shared scalers */
	if (INTEL_INFO(dev)->gen >= 9) {
		if (pipe == PIPE_C)
			intel_crtc->num_scalers = 1;
		else
			intel_crtc->num_scalers = SKL_NUM_SCALERS;

		skl_init_scalers(dev, intel_crtc, crtc_state);
	}

	primary = intel_primary_plane_create(dev, pipe);
	if (!primary)
		goto fail;

	cursor = intel_cursor_plane_create(dev, pipe);
	if (!cursor)
		goto fail;

	ret = drm_crtc_init_with_planes(dev, &intel_crtc->base, primary,
					cursor, &intel_crtc_funcs);
	if (ret)
		goto fail;

	drm_mode_crtc_set_gamma_size(&intel_crtc->base, 256);
	for (i = 0; i < 256; i++) {
		intel_crtc->lut_r[i] = i;
		intel_crtc->lut_g[i] = i;
		intel_crtc->lut_b[i] = i;
	}

	/*
	 * On gen2/3 only plane A can do fbc, but the panel fitter and lvds port
	 * is hooked to pipe B. Hence we want plane A feeding pipe B.
	 */
	intel_crtc->pipe = pipe;
	intel_crtc->plane = pipe;
	if (HAS_FBC(dev) && INTEL_INFO(dev)->gen < 4) {
		DRM_DEBUG_KMS("swapping pipes & planes for FBC\n");
		intel_crtc->plane = !pipe;
	}

	intel_crtc->cursor_base = ~0;
	intel_crtc->cursor_cntl = ~0;
	intel_crtc->cursor_size = ~0;

	intel_crtc->wm.cxsr_allowed = true;

	BUG_ON(pipe >= ARRAY_SIZE(dev_priv->plane_to_crtc_mapping) ||
	       dev_priv->plane_to_crtc_mapping[intel_crtc->plane] != NULL);
	dev_priv->plane_to_crtc_mapping[intel_crtc->plane] = &intel_crtc->base;
	dev_priv->pipe_to_crtc_mapping[intel_crtc->pipe] = &intel_crtc->base;

	drm_crtc_helper_add(&intel_crtc->base, &intel_helper_funcs);

	WARN_ON(drm_crtc_index(&intel_crtc->base) != intel_crtc->pipe);
	return;

fail:
	if (primary)
		drm_plane_cleanup(primary);
	if (cursor)
		drm_plane_cleanup(cursor);
	kfree(crtc_state);
	kfree(intel_crtc);
}

enum pipe intel_get_pipe_from_connector(struct intel_connector *connector)
{
	struct drm_encoder *encoder = connector->base.encoder;
	struct drm_device *dev = connector->base.dev;

	WARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));

	if (!encoder || WARN_ON(!encoder->crtc))
		return INVALID_PIPE;

	return to_intel_crtc(encoder->crtc)->pipe;
}

int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
				struct drm_file *file)
{
	struct drm_i915_get_pipe_from_crtc_id *pipe_from_crtc_id = data;
	struct drm_crtc *drmmode_crtc;
	struct intel_crtc *crtc;

	drmmode_crtc = drm_crtc_find(dev, pipe_from_crtc_id->crtc_id);

	if (!drmmode_crtc) {
		DRM_ERROR("no such CRTC id\n");
		return -ENOENT;
	}

	crtc = to_intel_crtc(drmmode_crtc);
	pipe_from_crtc_id->pipe = crtc->pipe;

	return 0;
}

static int intel_encoder_clones(struct intel_encoder *encoder)
{
	struct drm_device *dev = encoder->base.dev;
	struct intel_encoder *source_encoder;
	int index_mask = 0;
	int entry = 0;

	for_each_intel_encoder(dev, source_encoder) {
		if (encoders_cloneable(encoder, source_encoder))
			index_mask |= (1 << entry);

		entry++;
	}

	return index_mask;
}

static bool has_edp_a(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!IS_MOBILE(dev))
		return false;

	if ((I915_READ(DP_A) & DP_DETECTED) == 0)
		return false;

	if (IS_GEN5(dev) && (I915_READ(FUSE_STRAP) & ILK_eDP_A_DISABLE))
		return false;

	return true;
}

static bool intel_crt_present(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (INTEL_INFO(dev)->gen >= 9)
		return false;

	if (IS_HSW_ULT(dev) || IS_BDW_ULT(dev))
		return false;

	if (IS_CHERRYVIEW(dev))
		return false;

	if (IS_VALLEYVIEW(dev) && !dev_priv->vbt.int_crt_support)
		return false;

	return true;
}

static void intel_setup_outputs(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;
	bool dpd_is_edp = false;

	intel_lvds_init(dev);

	if (intel_crt_present(dev))
		intel_crt_init(dev);

	if (IS_BROXTON(dev)) {
		/*
		 * FIXME: Broxton doesn't support port detection via the
		 * DDI_BUF_CTL_A or SFUSE_STRAP registers, find another way to
		 * detect the ports.
		 */
		intel_ddi_init(dev, PORT_A);
		intel_ddi_init(dev, PORT_B);
		intel_ddi_init(dev, PORT_C);
	} else if (HAS_DDI(dev)) {
		int found;

		/*
		 * Haswell uses DDI functions to detect digital outputs.
		 * On SKL pre-D0 the strap isn't connected, so we assume
		 * it's there.
		 */
		found = I915_READ(DDI_BUF_CTL(PORT_A)) & DDI_INIT_DISPLAY_DETECTED;
		/* WaIgnoreDDIAStrap: skl */
		if (found || IS_SKYLAKE(dev))
			intel_ddi_init(dev, PORT_A);

		/* DDI B, C and D detection is indicated by the SFUSE_STRAP
		 * register */
		found = I915_READ(SFUSE_STRAP);

		if (found & SFUSE_STRAP_DDIB_DETECTED)
			intel_ddi_init(dev, PORT_B);
		if (found & SFUSE_STRAP_DDIC_DETECTED)
			intel_ddi_init(dev, PORT_C);
		if (found & SFUSE_STRAP_DDID_DETECTED)
			intel_ddi_init(dev, PORT_D);
		/*
		 * On SKL we don't have a way to detect DDI-E so we rely on VBT.
		 */
		if (IS_SKYLAKE(dev) &&
		    (dev_priv->vbt.ddi_port_info[PORT_E].supports_dp ||
		     dev_priv->vbt.ddi_port_info[PORT_E].supports_dvi ||
		     dev_priv->vbt.ddi_port_info[PORT_E].supports_hdmi))
			intel_ddi_init(dev, PORT_E);

	} else if (HAS_PCH_SPLIT(dev)) {
		int found;
		dpd_is_edp = intel_dp_is_edp(dev, PORT_D);

		if (has_edp_a(dev))
			intel_dp_init(dev, DP_A, PORT_A);

		if (I915_READ(PCH_HDMIB) & SDVO_DETECTED) {
			/* PCH SDVOB multiplex with HDMIB */
			found = intel_sdvo_init(dev, PCH_SDVOB, true);
			if (!found)
				intel_hdmi_init(dev, PCH_HDMIB, PORT_B);
			if (!found && (I915_READ(PCH_DP_B) & DP_DETECTED))
				intel_dp_init(dev, PCH_DP_B, PORT_B);
		}

		if (I915_READ(PCH_HDMIC) & SDVO_DETECTED)
			intel_hdmi_init(dev, PCH_HDMIC, PORT_C);

		if (!dpd_is_edp && I915_READ(PCH_HDMID) & SDVO_DETECTED)
			intel_hdmi_init(dev, PCH_HDMID, PORT_D);

		if (I915_READ(PCH_DP_C) & DP_DETECTED)
			intel_dp_init(dev, PCH_DP_C, PORT_C);

		if (I915_READ(PCH_DP_D) & DP_DETECTED)
			intel_dp_init(dev, PCH_DP_D, PORT_D);
	} else if (IS_VALLEYVIEW(dev)) {
		bool has_edp, has_port;

		/*
		 * The DP_DETECTED bit is the latched state of the DDC
		 * SDA pin at boot. However since eDP doesn't require DDC
		 * (no way to plug in a DP->HDMI dongle) the DDC pins for
		 * eDP ports may have been muxed to an alternate function.
		 * Thus we can't rely on the DP_DETECTED bit alone to detect
		 * eDP ports. Consult the VBT as well as DP_DETECTED to
		 * detect eDP ports.
		 *
		 * Sadly the straps seem to be missing sometimes even for HDMI
		 * ports (eg. on Voyo V3 - CHT x7-Z8700), so check both strap
		 * and VBT for the presence of the port. Additionally we can't
		 * trust the port type the VBT declares as we've seen at least
		 * HDMI ports that the VBT claim are DP or eDP.
		 */
		has_edp = intel_dp_is_edp(dev, PORT_B);
		has_port = intel_bios_is_port_present(dev_priv, PORT_B);
		if (I915_READ(VLV_DP_B) & DP_DETECTED || has_port)
			has_edp &= intel_dp_init(dev, VLV_DP_B, PORT_B);
		if ((I915_READ(VLV_HDMIB) & SDVO_DETECTED || has_port) && !has_edp)
			intel_hdmi_init(dev, VLV_HDMIB, PORT_B);

		has_edp = intel_dp_is_edp(dev, PORT_C);
		has_port = intel_bios_is_port_present(dev_priv, PORT_C);
		if (I915_READ(VLV_DP_C) & DP_DETECTED || has_port)
			has_edp &= intel_dp_init(dev, VLV_DP_C, PORT_C);
		if ((I915_READ(VLV_HDMIC) & SDVO_DETECTED || has_port) && !has_edp)
			intel_hdmi_init(dev, VLV_HDMIC, PORT_C);

		if (IS_CHERRYVIEW(dev)) {
			/*
			 * eDP not supported on port D,
			 * so no need to worry about it
			 */
			has_port = intel_bios_is_port_present(dev_priv, PORT_D);
			if (I915_READ(CHV_DP_D) & DP_DETECTED || has_port)
				intel_dp_init(dev, CHV_DP_D, PORT_D);
			if (I915_READ(CHV_HDMID) & SDVO_DETECTED || has_port)
				intel_hdmi_init(dev, CHV_HDMID, PORT_D);
		}

		intel_dsi_init(dev);
	} else if (!IS_GEN2(dev) && !IS_PINEVIEW(dev)) {
		bool found = false;

		if (I915_READ(GEN3_SDVOB) & SDVO_DETECTED) {
			DRM_DEBUG_KMS("probing SDVOB\n");
			found = intel_sdvo_init(dev, GEN3_SDVOB, true);
			if (!found && IS_G4X(dev)) {
				DRM_DEBUG_KMS("probing HDMI on SDVOB\n");
				intel_hdmi_init(dev, GEN4_HDMIB, PORT_B);
			}

			if (!found && IS_G4X(dev))
				intel_dp_init(dev, DP_B, PORT_B);
		}

		/* Before G4X SDVOC doesn't have its own detect register */

		if (I915_READ(GEN3_SDVOB) & SDVO_DETECTED) {
			DRM_DEBUG_KMS("probing SDVOC\n");
			found = intel_sdvo_init(dev, GEN3_SDVOC, false);
		}

		if (!found && (I915_READ(GEN3_SDVOC) & SDVO_DETECTED)) {

			if (IS_G4X(dev)) {
				DRM_DEBUG_KMS("probing HDMI on SDVOC\n");
				intel_hdmi_init(dev, GEN4_HDMIC, PORT_C);
			}
			if (IS_G4X(dev))
				intel_dp_init(dev, DP_C, PORT_C);
		}

		if (IS_G4X(dev) &&
		    (I915_READ(DP_D) & DP_DETECTED))
			intel_dp_init(dev, DP_D, PORT_D);
	} else if (IS_GEN2(dev))
		intel_dvo_init(dev);

	if (SUPPORTS_TV(dev))
		intel_tv_init(dev);

	intel_psr_init(dev);

	for_each_intel_encoder(dev, encoder) {
		encoder->base.possible_crtcs = encoder->crtc_mask;
		encoder->base.possible_clones =
			intel_encoder_clones(encoder);
	}

	intel_init_pch_refclk(dev);

	drm_helper_move_panel_connectors_to_head(dev);
}

static void intel_user_framebuffer_destroy(struct drm_framebuffer *fb)
{
	struct drm_device *dev = fb->dev;
	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);

	drm_framebuffer_cleanup(fb);
	mutex_lock(&dev->struct_mutex);
	WARN_ON(!intel_fb->obj->framebuffer_references--);
	drm_gem_object_unreference(&intel_fb->obj->base);
	mutex_unlock(&dev->struct_mutex);
	kfree(intel_fb);
}

static int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,
						struct drm_file *file,
						unsigned int *handle)
{
	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);
	struct drm_i915_gem_object *obj = intel_fb->obj;

	if (obj->userptr.mm) {
		DRM_DEBUG("attempting to use a userptr for a framebuffer, denied\n");
		return -EINVAL;
	}

	return drm_gem_handle_create(file, &obj->base, handle);
}

static int intel_user_framebuffer_dirty(struct drm_framebuffer *fb,
					struct drm_file *file,
					unsigned flags, unsigned color,
					struct drm_clip_rect *clips,
					unsigned num_clips)
{
	struct drm_device *dev = fb->dev;
	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);
	struct drm_i915_gem_object *obj = intel_fb->obj;

	mutex_lock(&dev->struct_mutex);
	intel_fb_obj_flush(obj, false, ORIGIN_DIRTYFB);
	mutex_unlock(&dev->struct_mutex);

	return 0;
}

static const struct drm_framebuffer_funcs intel_fb_funcs = {
	.destroy = intel_user_framebuffer_destroy,
	.create_handle = intel_user_framebuffer_create_handle,
	.dirty = intel_user_framebuffer_dirty,
};

static
u32 intel_fb_pitch_limit(struct drm_device *dev, uint64_t fb_modifier,
			 uint32_t pixel_format)
{
	u32 gen = INTEL_INFO(dev)->gen;

	if (gen >= 9) {
		/* "The stride in bytes must not exceed the of the size of 8K
		 *  pixels and 32K bytes."
		 */
		 return min(8192*drm_format_plane_cpp(pixel_format, 0), 32768);
	} else if (gen >= 5 && !IS_VALLEYVIEW(dev)) {
		return 32*1024;
	} else if (gen >= 4) {
		if (fb_modifier == I915_FORMAT_MOD_X_TILED)
			return 16*1024;
		else
			return 32*1024;
	} else if (gen >= 3) {
		if (fb_modifier == I915_FORMAT_MOD_X_TILED)
			return 8*1024;
		else
			return 16*1024;
	} else {
		/* XXX DSPC is limited to 4k tiled */
		return 8*1024;
	}
}

static int intel_framebuffer_init(struct drm_device *dev,
				  struct intel_framebuffer *intel_fb,
				  struct drm_mode_fb_cmd2 *mode_cmd,
				  struct drm_i915_gem_object *obj)
{
	unsigned int aligned_height;
	int ret;
	u32 pitch_limit, stride_alignment;

	WARN_ON(!mutex_is_locked(&dev->struct_mutex));

	if (mode_cmd->flags & DRM_MODE_FB_MODIFIERS) {
		/* Enforce that fb modifier and tiling mode match, but only for
		 * X-tiled. This is needed for FBC. */
		if (!!(obj->tiling_mode == I915_TILING_X) !=
		    !!(mode_cmd->modifier[0] == I915_FORMAT_MOD_X_TILED)) {
			DRM_DEBUG("tiling_mode doesn't match fb modifier\n");
			return -EINVAL;
		}
	} else {
		if (obj->tiling_mode == I915_TILING_X)
			mode_cmd->modifier[0] = I915_FORMAT_MOD_X_TILED;
		else if (obj->tiling_mode == I915_TILING_Y) {
			DRM_DEBUG("No Y tiling for legacy addfb\n");
			return -EINVAL;
		}
	}

	/* Passed in modifier sanity checking. */
	switch (mode_cmd->modifier[0]) {
	case I915_FORMAT_MOD_Y_TILED:
	case I915_FORMAT_MOD_Yf_TILED:
		if (INTEL_INFO(dev)->gen < 9) {
			DRM_DEBUG("Unsupported tiling 0x%llx!\n",
				  mode_cmd->modifier[0]);
			return -EINVAL;
		}
	case DRM_FORMAT_MOD_NONE:
	case I915_FORMAT_MOD_X_TILED:
		break;
	default:
		DRM_DEBUG("Unsupported fb modifier 0x%llx!\n",
			  mode_cmd->modifier[0]);
		return -EINVAL;
	}

	stride_alignment = intel_fb_stride_alignment(dev, mode_cmd->modifier[0],
						     mode_cmd->pixel_format);
	if (mode_cmd->pitches[0] & (stride_alignment - 1)) {
		DRM_DEBUG("pitch (%d) must be at least %u byte aligned\n",
			  mode_cmd->pitches[0], stride_alignment);
		return -EINVAL;
	}

	pitch_limit = intel_fb_pitch_limit(dev, mode_cmd->modifier[0],
					   mode_cmd->pixel_format);
	if (mode_cmd->pitches[0] > pitch_limit) {
		DRM_DEBUG("%s pitch (%u) must be at less than %d\n",
			  mode_cmd->modifier[0] != DRM_FORMAT_MOD_NONE ?
			  "tiled" : "linear",
			  mode_cmd->pitches[0], pitch_limit);
		return -EINVAL;
	}

	if (mode_cmd->modifier[0] == I915_FORMAT_MOD_X_TILED &&
	    mode_cmd->pitches[0] != obj->stride) {
		DRM_DEBUG("pitch (%d) must match tiling stride (%d)\n",
			  mode_cmd->pitches[0], obj->stride);
		return -EINVAL;
	}

	/* Reject formats not supported by any plane early. */
	switch (mode_cmd->pixel_format) {
	case DRM_FORMAT_C8:
	case DRM_FORMAT_RGB565:
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_ARGB8888:
		break;
	case DRM_FORMAT_XRGB1555:
		if (INTEL_INFO(dev)->gen > 3) {
			DRM_DEBUG("unsupported pixel format: %s\n",
				  drm_get_format_name(mode_cmd->pixel_format));
			return -EINVAL;
		}
		break;
	case DRM_FORMAT_ABGR8888:
		if (!IS_VALLEYVIEW(dev) && INTEL_INFO(dev)->gen < 9) {
			DRM_DEBUG("unsupported pixel format: %s\n",
				  drm_get_format_name(mode_cmd->pixel_format));
			return -EINVAL;
		}
		break;
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_XBGR2101010:
		if (INTEL_INFO(dev)->gen < 4) {
			DRM_DEBUG("unsupported pixel format: %s\n",
				  drm_get_format_name(mode_cmd->pixel_format));
			return -EINVAL;
		}
		break;
	case DRM_FORMAT_ABGR2101010:
		if (!IS_VALLEYVIEW(dev)) {
			DRM_DEBUG("unsupported pixel format: %s\n",
				  drm_get_format_name(mode_cmd->pixel_format));
			return -EINVAL;
		}
		break;
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_YVYU:
	case DRM_FORMAT_VYUY:
		if (INTEL_INFO(dev)->gen < 5) {
			DRM_DEBUG("unsupported pixel format: %s\n",
				  drm_get_format_name(mode_cmd->pixel_format));
			return -EINVAL;
		}
		break;
	default:
		DRM_DEBUG("unsupported pixel format: %s\n",
			  drm_get_format_name(mode_cmd->pixel_format));
		return -EINVAL;
	}

	/* FIXME need to adjust LINOFF/TILEOFF accordingly. */
	if (mode_cmd->offsets[0] != 0)
		return -EINVAL;

	aligned_height = intel_fb_align_height(dev, mode_cmd->height,
					       mode_cmd->pixel_format,
					       mode_cmd->modifier[0]);
	/* FIXME drm helper for size checks (especially planar formats)? */
	if (obj->base.size < aligned_height * mode_cmd->pitches[0])
		return -EINVAL;

	drm_helper_mode_fill_fb_struct(&intel_fb->base, mode_cmd);
	intel_fb->obj = obj;
	intel_fb->obj->framebuffer_references++;

	ret = drm_framebuffer_init(dev, &intel_fb->base, &intel_fb_funcs);
	if (ret) {
		DRM_ERROR("framebuffer init failed %d\n", ret);
		return ret;
	}

	return 0;
}

static struct drm_framebuffer *
intel_user_framebuffer_create(struct drm_device *dev,
			      struct drm_file *filp,
			      struct drm_mode_fb_cmd2 *user_mode_cmd)
{
	struct drm_i915_gem_object *obj;
	struct drm_mode_fb_cmd2 mode_cmd = *user_mode_cmd;

	obj = to_intel_bo(drm_gem_object_lookup(dev, filp,
						mode_cmd.handles[0]));
	if (&obj->base == NULL)
		return ERR_PTR(-ENOENT);

	return intel_framebuffer_create(dev, &mode_cmd, obj);
}

#ifndef CONFIG_DRM_FBDEV_EMULATION
static inline void intel_fbdev_output_poll_changed(struct drm_device *dev)
{
}
#endif

static const struct drm_mode_config_funcs intel_mode_funcs = {
	.fb_create = intel_user_framebuffer_create,
	.output_poll_changed = intel_fbdev_output_poll_changed,
	.atomic_check = intel_atomic_check,
	.atomic_commit = intel_atomic_commit,
	.atomic_state_alloc = intel_atomic_state_alloc,
	.atomic_state_clear = intel_atomic_state_clear,
};

/* Set up chip specific display functions */
static void intel_init_display(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (HAS_PCH_SPLIT(dev) || IS_G4X(dev))
		dev_priv->display.find_dpll = g4x_find_best_dpll;
	else if (IS_CHERRYVIEW(dev))
		dev_priv->display.find_dpll = chv_find_best_dpll;
	else if (IS_VALLEYVIEW(dev))
		dev_priv->display.find_dpll = vlv_find_best_dpll;
	else if (IS_PINEVIEW(dev))
		dev_priv->display.find_dpll = pnv_find_best_dpll;
	else
		dev_priv->display.find_dpll = i9xx_find_best_dpll;

	if (INTEL_INFO(dev)->gen >= 9) {
		dev_priv->display.get_pipe_config = haswell_get_pipe_config;
		dev_priv->display.get_initial_plane_config =
			skylake_get_initial_plane_config;
		dev_priv->display.crtc_compute_clock =
			haswell_crtc_compute_clock;
		dev_priv->display.crtc_enable = haswell_crtc_enable;
		dev_priv->display.crtc_disable = haswell_crtc_disable;
		dev_priv->display.update_primary_plane =
			skylake_update_primary_plane;
	} else if (HAS_DDI(dev)) {
		dev_priv->display.get_pipe_config = haswell_get_pipe_config;
		dev_priv->display.get_initial_plane_config =
			ironlake_get_initial_plane_config;
		dev_priv->display.crtc_compute_clock =
			haswell_crtc_compute_clock;
		dev_priv->display.crtc_enable = haswell_crtc_enable;
		dev_priv->display.crtc_disable = haswell_crtc_disable;
		dev_priv->display.update_primary_plane =
			ironlake_update_primary_plane;
	} else if (HAS_PCH_SPLIT(dev)) {
		dev_priv->display.get_pipe_config = ironlake_get_pipe_config;
		dev_priv->display.get_initial_plane_config =
			ironlake_get_initial_plane_config;
		dev_priv->display.crtc_compute_clock =
			ironlake_crtc_compute_clock;
		dev_priv->display.crtc_enable = ironlake_crtc_enable;
		dev_priv->display.crtc_disable = ironlake_crtc_disable;
		dev_priv->display.update_primary_plane =
			ironlake_update_primary_plane;
	} else if (IS_VALLEYVIEW(dev)) {
		dev_priv->display.get_pipe_config = i9xx_get_pipe_config;
		dev_priv->display.get_initial_plane_config =
			i9xx_get_initial_plane_config;
		dev_priv->display.crtc_compute_clock = i9xx_crtc_compute_clock;
		dev_priv->display.crtc_enable = valleyview_crtc_enable;
		dev_priv->display.crtc_disable = i9xx_crtc_disable;
		dev_priv->display.update_primary_plane =
			i9xx_update_primary_plane;
	} else {
		dev_priv->display.get_pipe_config = i9xx_get_pipe_config;
		dev_priv->display.get_initial_plane_config =
			i9xx_get_initial_plane_config;
		dev_priv->display.crtc_compute_clock = i9xx_crtc_compute_clock;
		dev_priv->display.crtc_enable = i9xx_crtc_enable;
		dev_priv->display.crtc_disable = i9xx_crtc_disable;
		dev_priv->display.update_primary_plane =
			i9xx_update_primary_plane;
	}

	/* Returns the core display clock speed */
	if (IS_SKYLAKE(dev))
		dev_priv->display.get_display_clock_speed =
			skylake_get_display_clock_speed;
	else if (IS_BROXTON(dev))
		dev_priv->display.get_display_clock_speed =
			broxton_get_display_clock_speed;
	else if (IS_BROADWELL(dev))
		dev_priv->display.get_display_clock_speed =
			broadwell_get_display_clock_speed;
	else if (IS_HASWELL(dev))
		dev_priv->display.get_display_clock_speed =
			haswell_get_display_clock_speed;
	else if (IS_VALLEYVIEW(dev))
		dev_priv->display.get_display_clock_speed =
			valleyview_get_display_clock_speed;
	else if (IS_GEN5(dev))
		dev_priv->display.get_display_clock_speed =
			ilk_get_display_clock_speed;
	else if (IS_I945G(dev) || IS_BROADWATER(dev) ||
		 IS_GEN6(dev) || IS_IVYBRIDGE(dev))
		dev_priv->display.get_display_clock_speed =
			i945_get_display_clock_speed;
	else if (IS_GM45(dev))
		dev_priv->display.get_display_clock_speed =
			gm45_get_display_clock_speed;
	else if (IS_CRESTLINE(dev))
		dev_priv->display.get_display_clock_speed =
			i965gm_get_display_clock_speed;
	else if (IS_PINEVIEW(dev))
		dev_priv->display.get_display_clock_speed =
			pnv_get_display_clock_speed;
	else if (IS_G33(dev) || IS_G4X(dev))
		dev_priv->display.get_display_clock_speed =
			g33_get_display_clock_speed;
	else if (IS_I915G(dev))
		dev_priv->display.get_display_clock_speed =
			i915_get_display_clock_speed;
	else if (IS_I945GM(dev) || IS_845G(dev))
		dev_priv->display.get_display_clock_speed =
			i9xx_misc_get_display_clock_speed;
	else if (IS_PINEVIEW(dev))
		dev_priv->display.get_display_clock_speed =
			pnv_get_display_clock_speed;
	else if (IS_I915GM(dev))
		dev_priv->display.get_display_clock_speed =
			i915gm_get_display_clock_speed;
	else if (IS_I865G(dev))
		dev_priv->display.get_display_clock_speed =
			i865_get_display_clock_speed;
	else if (IS_I85X(dev))
		dev_priv->display.get_display_clock_speed =
			i85x_get_display_clock_speed;
	else { /* 830 */
		WARN(!IS_I830(dev), "Unknown platform. Assuming 133 MHz CDCLK\n");
		dev_priv->display.get_display_clock_speed =
			i830_get_display_clock_speed;
	}

	if (IS_GEN5(dev)) {
		dev_priv->display.fdi_link_train = ironlake_fdi_link_train;
	} else if (IS_GEN6(dev)) {
		dev_priv->display.fdi_link_train = gen6_fdi_link_train;
	} else if (IS_IVYBRIDGE(dev)) {
		/* FIXME: detect B0+ stepping and use auto training */
		dev_priv->display.fdi_link_train = ivb_manual_fdi_link_train;
	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		dev_priv->display.fdi_link_train = hsw_fdi_link_train;
		if (IS_BROADWELL(dev)) {
			dev_priv->display.modeset_commit_cdclk =
				broadwell_modeset_commit_cdclk;
			dev_priv->display.modeset_calc_cdclk =
				broadwell_modeset_calc_cdclk;
		}
	} else if (IS_VALLEYVIEW(dev)) {
		dev_priv->display.modeset_commit_cdclk =
			valleyview_modeset_commit_cdclk;
		dev_priv->display.modeset_calc_cdclk =
			valleyview_modeset_calc_cdclk;
	} else if (IS_BROXTON(dev)) {
		dev_priv->display.modeset_commit_cdclk =
			broxton_modeset_commit_cdclk;
		dev_priv->display.modeset_calc_cdclk =
			broxton_modeset_calc_cdclk;
	}

	switch (INTEL_INFO(dev)->gen) {
	case 2:
		dev_priv->display.queue_flip = intel_gen2_queue_flip;
		break;

	case 3:
		dev_priv->display.queue_flip = intel_gen3_queue_flip;
		break;

	case 4:
	case 5:
		dev_priv->display.queue_flip = intel_gen4_queue_flip;
		break;

	case 6:
		dev_priv->display.queue_flip = intel_gen6_queue_flip;
		break;
	case 7:
	case 8: /* FIXME(BDW): Check that the gen8 RCS flip works. */
		dev_priv->display.queue_flip = intel_gen7_queue_flip;
		break;
	case 9:
		/* Drop through - unsupported since execlist only. */
	default:
		/* Default just returns -ENODEV to indicate unsupported */
		dev_priv->display.queue_flip = intel_default_queue_flip;
	}

	rw_init(&dev_priv->pps_mutex, "pps");
}

/*
 * Some BIOSes insist on assuming the GPU's pipe A is enabled at suspend,
 * resume, or other times.  This quirk makes sure that's the case for
 * affected systems.
 */
static void quirk_pipea_force(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	dev_priv->quirks |= QUIRK_PIPEA_FORCE;
	DRM_INFO("applying pipe a force quirk\n");
}

static void quirk_pipeb_force(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	dev_priv->quirks |= QUIRK_PIPEB_FORCE;
	DRM_INFO("applying pipe b force quirk\n");
}

/*
 * Some machines (Lenovo U160) do not work with SSC on LVDS for some reason
 */
static void quirk_ssc_force_disable(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	dev_priv->quirks |= QUIRK_LVDS_SSC_DISABLE;
	DRM_INFO("applying lvds SSC disable quirk\n");
}

/*
 * A machine (e.g. Acer Aspire 5734Z) may need to invert the panel backlight
 * brightness value
 */
static void quirk_invert_brightness(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	dev_priv->quirks |= QUIRK_INVERT_BRIGHTNESS;
	DRM_INFO("applying inverted panel brightness quirk\n");
}

/* Some VBT's incorrectly indicate no backlight is present */
static void quirk_backlight_present(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	dev_priv->quirks |= QUIRK_BACKLIGHT_PRESENT;
	DRM_INFO("applying backlight present quirk\n");
}

struct intel_quirk {
	int device;
	int subsystem_vendor;
	int subsystem_device;
	void (*hook)(struct drm_device *dev);
};

/* For systems that don't have a meaningful PCI subdevice/subvendor ID */
struct intel_dmi_quirk {
	void (*hook)(struct drm_device *dev);
	const struct dmi_system_id (*dmi_id_list)[];
};

#ifdef notyet
static int intel_dmi_reverse_brightness(const struct dmi_system_id *id)
{
	DRM_INFO("Backlight polarity reversed on %s\n", id->ident);
	return 1;
}

static const struct intel_dmi_quirk intel_dmi_quirks[] = {
	{
		.dmi_id_list = &(const struct dmi_system_id[]) {
			{
				.callback = intel_dmi_reverse_brightness,
				.ident = "NCR Corporation",
				.matches = {DMI_MATCH(DMI_SYS_VENDOR, "NCR Corporation"),
					    DMI_MATCH(DMI_PRODUCT_NAME, ""),
				},
			},
			{ }  /* terminating entry */
		},
		.hook = quirk_invert_brightness,
	},
};
#endif

static struct intel_quirk intel_quirks[] = {
	/* Toshiba Protege R-205, S-209 needs pipe A force quirk */
	{ 0x2592, 0x1179, 0x0001, quirk_pipea_force },

	/* ThinkPad T60 needs pipe A force quirk (bug #16494) */
	{ 0x2782, 0x17aa, 0x201a, quirk_pipea_force },

	/* 830 needs to leave pipe A & dpll A up */
	{ 0x3577, PCI_ANY_ID, PCI_ANY_ID, quirk_pipea_force },

	/* 830 needs to leave pipe B & dpll B up */
	{ 0x3577, PCI_ANY_ID, PCI_ANY_ID, quirk_pipeb_force },

	/* Lenovo U160 cannot use SSC on LVDS */
	{ 0x0046, 0x17aa, 0x3920, quirk_ssc_force_disable },

	/* Sony Vaio Y cannot use SSC on LVDS */
	{ 0x0046, 0x104d, 0x9076, quirk_ssc_force_disable },

	/* Acer Aspire 5734Z must invert backlight brightness */
	{ 0x2a42, 0x1025, 0x0459, quirk_invert_brightness },

	/* Acer/eMachines G725 */
	{ 0x2a42, 0x1025, 0x0210, quirk_invert_brightness },

	/* Acer/eMachines e725 */
	{ 0x2a42, 0x1025, 0x0212, quirk_invert_brightness },

	/* Acer/Packard Bell NCL20 */
	{ 0x2a42, 0x1025, 0x034b, quirk_invert_brightness },

	/* Acer Aspire 4736Z */
	{ 0x2a42, 0x1025, 0x0260, quirk_invert_brightness },

	/* Acer Aspire 5336 */
	{ 0x2a42, 0x1025, 0x048a, quirk_invert_brightness },

	/* Acer C720 and C720P Chromebooks (Celeron 2955U) have backlights */
	{ 0x0a06, 0x1025, 0x0a11, quirk_backlight_present },

	/* Acer C720 Chromebook (Core i3 4005U) */
	{ 0x0a16, 0x1025, 0x0a11, quirk_backlight_present },

	/* Apple Macbook 2,1 (Core 2 T7400) */
	{ 0x27a2, 0x8086, 0x7270, quirk_backlight_present },

	/* Apple Macbook 4,1 */
	{ 0x2a02, 0x106b, 0x00a1, quirk_backlight_present },

	/* Toshiba CB35 Chromebook (Celeron 2955U) */
	{ 0x0a06, 0x1179, 0x0a88, quirk_backlight_present },

	/* HP Chromebook 14 (Celeron 2955U) */
	{ 0x0a06, 0x103c, 0x21ed, quirk_backlight_present },

	/* Dell Chromebook 11 */
	{ 0x0a06, 0x1028, 0x0a35, quirk_backlight_present },

	/* Dell Chromebook 11 (2015 version) */
	{ 0x0a16, 0x1028, 0x0a35, quirk_backlight_present },
};

static void intel_init_quirks(struct drm_device *dev)
{
	struct pci_dev *d = dev->pdev;
	int i;

	for (i = 0; i < ARRAY_SIZE(intel_quirks); i++) {
		struct intel_quirk *q = &intel_quirks[i];

		if (d->device == q->device &&
		    (d->subsystem_vendor == q->subsystem_vendor ||
		     q->subsystem_vendor == PCI_ANY_ID) &&
		    (d->subsystem_device == q->subsystem_device ||
		     q->subsystem_device == PCI_ANY_ID))
			q->hook(dev);
	}
#ifdef notyet
	for (i = 0; i < ARRAY_SIZE(intel_dmi_quirks); i++) {
		if (dmi_check_system(*intel_dmi_quirks[i].dmi_id_list) != 0)
			intel_dmi_quirks[i].hook(dev);
	}
#endif
}

/* Disable the VGA plane that we never use */
static void i915_disable_vga(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u8 sr1;
	u32 vga_reg = i915_vgacntrl_reg(dev);

	/* WaEnableVGAAccessThroughIOPort:ctg,elk,ilk,snb,ivb,vlv,hsw */
	vga_get_uninterruptible(dev->pdev, VGA_RSRC_LEGACY_IO);
#ifdef __linux__
	outb(SR01, VGA_SR_INDEX);
	sr1 = inb(VGA_SR_DATA);
	outb(sr1 | 1<<5, VGA_SR_DATA);
#else
	outb(VGA_SR_INDEX, SR01);
	sr1 = inb(VGA_SR_DATA);
	outb(VGA_SR_DATA, sr1 | 1<<5);
#endif
	vga_put(dev->pdev, VGA_RSRC_LEGACY_IO);
	udelay(300);

	I915_WRITE(vga_reg, VGA_DISP_DISABLE);
	POSTING_READ(vga_reg);
}

void intel_modeset_init_hw(struct drm_device *dev)
{
	intel_update_cdclk(dev);
	intel_prepare_ddi(dev);
	intel_init_clock_gating(dev);
	intel_enable_gt_powersave(dev);
}

void intel_modeset_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int sprite, ret;
	enum pipe pipe;
	struct intel_crtc *crtc;

	drm_mode_config_init(dev);

	dev->mode_config.min_width = 0;
	dev->mode_config.min_height = 0;

	dev->mode_config.preferred_depth = 24;
	dev->mode_config.prefer_shadow = 1;

	dev->mode_config.allow_fb_modifiers = true;

	dev->mode_config.funcs = &intel_mode_funcs;

	intel_init_quirks(dev);

	intel_init_pm(dev);

	if (INTEL_INFO(dev)->num_pipes == 0)
		return;

	/*
	 * There may be no VBT; and if the BIOS enabled SSC we can
	 * just keep using it to avoid unnecessary flicker.  Whereas if the
	 * BIOS isn't using it, don't assume it will work even if the VBT
	 * indicates as much.
	 */
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		bool bios_lvds_use_ssc = !!(I915_READ(PCH_DREF_CONTROL) &
					    DREF_SSC1_ENABLE);

		if (dev_priv->vbt.lvds_use_ssc != bios_lvds_use_ssc) {
			DRM_DEBUG_KMS("SSC %sabled by BIOS, overriding VBT which says %sabled\n",
				     bios_lvds_use_ssc ? "en" : "dis",
				     dev_priv->vbt.lvds_use_ssc ? "en" : "dis");
			dev_priv->vbt.lvds_use_ssc = bios_lvds_use_ssc;
		}
	}

	intel_init_display(dev);
	intel_init_audio(dev);

	if (IS_GEN2(dev)) {
		dev->mode_config.max_width = 2048;
		dev->mode_config.max_height = 2048;
	} else if (IS_GEN3(dev)) {
		dev->mode_config.max_width = 4096;
		dev->mode_config.max_height = 4096;
	} else {
		dev->mode_config.max_width = 8192;
		dev->mode_config.max_height = 8192;
	}

	if (IS_845G(dev) || IS_I865G(dev)) {
		dev->mode_config.cursor_width = IS_845G(dev) ? 64 : 512;
		dev->mode_config.cursor_height = 1023;
	} else if (IS_GEN2(dev)) {
		dev->mode_config.cursor_width = GEN2_CURSOR_WIDTH;
		dev->mode_config.cursor_height = GEN2_CURSOR_HEIGHT;
	} else {
		dev->mode_config.cursor_width = MAX_CURSOR_WIDTH;
		dev->mode_config.cursor_height = MAX_CURSOR_HEIGHT;
	}

	dev->mode_config.fb_base = dev_priv->gtt.mappable_base;

	DRM_DEBUG_KMS("%d display pipe%s available.\n",
		      INTEL_INFO(dev)->num_pipes,
		      INTEL_INFO(dev)->num_pipes > 1 ? "s" : "");

	for_each_pipe(dev_priv, pipe) {
		intel_crtc_init(dev, pipe);
		for_each_sprite(dev_priv, pipe, sprite) {
			ret = intel_plane_init(dev, pipe, sprite);
			if (ret)
				DRM_DEBUG_KMS("pipe %c sprite %c init failed: %d\n",
					      pipe_name(pipe), sprite_name(pipe, sprite), ret);
		}
	}

	intel_update_czclk(dev_priv);
	intel_update_cdclk(dev);

	intel_shared_dpll_init(dev);

	/* Just disable it once at startup */
	i915_disable_vga(dev);
	intel_setup_outputs(dev);

	/* Just in case the BIOS is doing something questionable. */
	intel_fbc_disable(dev_priv);

	drm_modeset_lock_all(dev);
	intel_modeset_setup_hw_state(dev);
	drm_modeset_unlock_all(dev);

	for_each_intel_crtc(dev, crtc) {
		struct intel_initial_plane_config plane_config = {};

		if (!crtc->active)
			continue;

		/*
		 * Note that reserving the BIOS fb up front prevents us
		 * from stuffing other stolen allocations like the ring
		 * on top.  This prevents some ugliness at boot time, and
		 * can even allow for smooth boot transitions if the BIOS
		 * fb is large enough for the active pipe configuration.
		 */
		dev_priv->display.get_initial_plane_config(crtc,
							   &plane_config);

		/*
		 * If the fb is shared between multiple heads, we'll
		 * just get the first one.
		 */
		intel_find_initial_plane_obj(crtc, &plane_config);
	}
}

static void intel_enable_pipe_a(struct drm_device *dev)
{
	struct intel_connector *connector;
	struct drm_connector *crt = NULL;
	struct intel_load_detect_pipe load_detect_temp;
	struct drm_modeset_acquire_ctx *ctx = dev->mode_config.acquire_ctx;

	/* We can't just switch on the pipe A, we need to set things up with a
	 * proper mode and output configuration. As a gross hack, enable pipe A
	 * by enabling the load detect pipe once. */
	for_each_intel_connector(dev, connector) {
		if (connector->encoder->type == INTEL_OUTPUT_ANALOG) {
			crt = &connector->base;
			break;
		}
	}

	if (!crt)
		return;

	if (intel_get_load_detect_pipe(crt, NULL, &load_detect_temp, ctx))
		intel_release_load_detect_pipe(crt, &load_detect_temp, ctx);
}

static bool
intel_check_plane_mapping(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val;

	if (INTEL_INFO(dev)->num_pipes == 1)
		return true;

	val = I915_READ(DSPCNTR(!crtc->plane));

	if ((val & DISPLAY_PLANE_ENABLE) &&
	    (!!(val & DISPPLANE_SEL_PIPE_MASK) == crtc->pipe))
		return false;

	return true;
}

static bool intel_crtc_has_encoders(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct intel_encoder *encoder;

	for_each_encoder_on_crtc(dev, &crtc->base, encoder)
		return true;

	return false;
}

static void intel_sanitize_crtc(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 reg;

	/* Clear any frame start delays used for debugging left by the BIOS */
	reg = PIPECONF(crtc->config->cpu_transcoder);
	I915_WRITE(reg, I915_READ(reg) & ~PIPECONF_FRAME_START_DELAY_MASK);

	/* restore vblank interrupts to correct state */
	drm_crtc_vblank_reset(&crtc->base);
	if (crtc->active) {
		struct intel_plane *plane;

		drm_crtc_vblank_on(&crtc->base);

		/* Disable everything but the primary plane */
		for_each_intel_plane_on_crtc(dev, crtc, plane) {
			if (plane->base.type == DRM_PLANE_TYPE_PRIMARY)
				continue;

			plane->disable_plane(&plane->base, &crtc->base);
		}
	}

	/* We need to sanitize the plane -> pipe mapping first because this will
	 * disable the crtc (and hence change the state) if it is wrong. Note
	 * that gen4+ has a fixed plane -> pipe mapping.  */
	if (INTEL_INFO(dev)->gen < 4 && !intel_check_plane_mapping(crtc)) {
		bool plane;

		DRM_DEBUG_KMS("[CRTC:%d] wrong plane connection detected!\n",
			      crtc->base.base.id);

		/* Pipe has the wrong plane attached and the plane is active.
		 * Temporarily change the plane mapping and disable everything
		 * ...  */
		plane = crtc->plane;
		to_intel_plane_state(crtc->base.primary->state)->visible = true;
		crtc->plane = !plane;
		intel_crtc_disable_noatomic(&crtc->base);
		crtc->plane = plane;
	}

	if (dev_priv->quirks & QUIRK_PIPEA_FORCE &&
	    crtc->pipe == PIPE_A && !crtc->active) {
		/* BIOS forgot to enable pipe A, this mostly happens after
		 * resume. Force-enable the pipe to fix this, the update_dpms
		 * call below we restore the pipe to the right state, but leave
		 * the required bits on. */
		intel_enable_pipe_a(dev);
	}

	/* Adjust the state of the output pipe according to whether we
	 * have active connectors/encoders. */
	if (!intel_crtc_has_encoders(crtc))
		intel_crtc_disable_noatomic(&crtc->base);

	if (crtc->active != crtc->base.state->active) {
		struct intel_encoder *encoder;

		/* This can happen either due to bugs in the get_hw_state
		 * functions or because of calls to intel_crtc_disable_noatomic,
		 * or because the pipe is force-enabled due to the
		 * pipe A quirk. */
		DRM_DEBUG_KMS("[CRTC:%d] hw state adjusted, was %s, now %s\n",
			      crtc->base.base.id,
			      crtc->base.state->enable ? "enabled" : "disabled",
			      crtc->active ? "enabled" : "disabled");

		WARN_ON(drm_atomic_set_mode_for_crtc(crtc->base.state, NULL) < 0);
		crtc->base.state->active = crtc->active;
		crtc->base.enabled = crtc->active;

		/* Because we only establish the connector -> encoder ->
		 * crtc links if something is active, this means the
		 * crtc is now deactivated. Break the links. connector
		 * -> encoder links are only establish when things are
		 *  actually up, hence no need to break them. */
		WARN_ON(crtc->active);

		for_each_encoder_on_crtc(dev, &crtc->base, encoder)
			encoder->base.crtc = NULL;
	}

	if (crtc->active || HAS_GMCH_DISPLAY(dev)) {
		/*
		 * We start out with underrun reporting disabled to avoid races.
		 * For correct bookkeeping mark this on active crtcs.
		 *
		 * Also on gmch platforms we dont have any hardware bits to
		 * disable the underrun reporting. Which means we need to start
		 * out with underrun reporting disabled also on inactive pipes,
		 * since otherwise we'll complain about the garbage we read when
		 * e.g. coming up after runtime pm.
		 *
		 * No protection against concurrent access is required - at
		 * worst a fifo underrun happens which also sets this to false.
		 */
		crtc->cpu_fifo_underrun_disabled = true;
		crtc->pch_fifo_underrun_disabled = true;
	}
}

static void intel_sanitize_encoder(struct intel_encoder *encoder)
{
	struct intel_connector *connector;
	struct drm_device *dev = encoder->base.dev;
	bool active = false;

	/* We need to check both for a crtc link (meaning that the
	 * encoder is active and trying to read from a pipe) and the
	 * pipe itself being active. */
	bool has_active_crtc = encoder->base.crtc &&
		to_intel_crtc(encoder->base.crtc)->active;

	for_each_intel_connector(dev, connector) {
		if (connector->base.encoder != &encoder->base)
			continue;

		active = true;
		break;
	}

	if (active && !has_active_crtc) {
		DRM_DEBUG_KMS("[ENCODER:%d:%s] has active connectors but no active pipe!\n",
			      encoder->base.base.id,
			      encoder->base.name);

		/* Connector is active, but has no active pipe. This is
		 * fallout from our resume register restoring. Disable
		 * the encoder manually again. */
		if (encoder->base.crtc) {
			DRM_DEBUG_KMS("[ENCODER:%d:%s] manually disabled\n",
				      encoder->base.base.id,
				      encoder->base.name);
			encoder->disable(encoder);
			if (encoder->post_disable)
				encoder->post_disable(encoder);
		}
		encoder->base.crtc = NULL;

		/* Inconsistent output/port/pipe state happens presumably due to
		 * a bug in one of the get_hw_state functions. Or someplace else
		 * in our code, like the register restore mess on resume. Clamp
		 * things to off as a safer default. */
		for_each_intel_connector(dev, connector) {
			if (connector->encoder != encoder)
				continue;
			connector->base.dpms = DRM_MODE_DPMS_OFF;
			connector->base.encoder = NULL;
		}
	}
	/* Enabled encoders without active connectors will be fixed in
	 * the crtc fixup. */
}

void i915_redisable_vga_power_on(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 vga_reg = i915_vgacntrl_reg(dev);

	if (!(I915_READ(vga_reg) & VGA_DISP_DISABLE)) {
		DRM_DEBUG_KMS("Something enabled VGA plane, disabling it\n");
		i915_disable_vga(dev);
	}
}

void i915_redisable_vga(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* This function can be called both from intel_modeset_setup_hw_state or
	 * at a very early point in our resume sequence, where the power well
	 * structures are not yet restored. Since this function is at a very
	 * paranoid "someone might have enabled VGA while we were not looking"
	 * level, just check if the power well is enabled instead of trying to
	 * follow the "don't touch the power well if we don't need it" policy
	 * the rest of the driver uses. */
	if (!intel_display_power_is_enabled(dev_priv, POWER_DOMAIN_VGA))
		return;

	i915_redisable_vga_power_on(dev);
}

static bool primary_get_hw_state(struct intel_plane *plane)
{
	struct drm_i915_private *dev_priv = to_i915(plane->base.dev);

	return I915_READ(DSPCNTR(plane->plane)) & DISPLAY_PLANE_ENABLE;
}

/* FIXME read out full plane state for all planes */
static void readout_plane_state(struct intel_crtc *crtc)
{
	struct drm_plane *primary = crtc->base.primary;
	struct intel_plane_state *plane_state =
		to_intel_plane_state(primary->state);

	plane_state->visible =
		primary_get_hw_state(to_intel_plane(primary));

	if (plane_state->visible)
		crtc->base.state->plane_mask |= 1 << drm_plane_index(primary);
}

static void intel_modeset_readout_hw_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe;
	struct intel_crtc *crtc;
	struct intel_encoder *encoder;
	struct intel_connector *connector;
	int i;

	for_each_intel_crtc(dev, crtc) {
		__drm_atomic_helper_crtc_destroy_state(&crtc->base, crtc->base.state);
		memset(crtc->config, 0, sizeof(*crtc->config));
		crtc->config->base.crtc = &crtc->base;

		crtc->active = dev_priv->display.get_pipe_config(crtc,
								 crtc->config);

		crtc->base.state->active = crtc->active;
		crtc->base.enabled = crtc->active;

		readout_plane_state(crtc);

		DRM_DEBUG_KMS("[CRTC:%d] hw state readout: %s\n",
			      crtc->base.base.id,
			      crtc->active ? "enabled" : "disabled");
	}

	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		struct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];

		pll->on = pll->get_hw_state(dev_priv, pll,
					    &pll->config.hw_state);
		pll->active = 0;
		pll->config.crtc_mask = 0;
		for_each_intel_crtc(dev, crtc) {
			if (crtc->active && intel_crtc_to_shared_dpll(crtc) == pll) {
				pll->active++;
				pll->config.crtc_mask |= 1 << crtc->pipe;
			}
		}

		DRM_DEBUG_KMS("%s hw state readout: crtc_mask 0x%08x, on %i\n",
			      pll->name, pll->config.crtc_mask, pll->on);

		if (pll->config.crtc_mask)
			intel_display_power_get(dev_priv, POWER_DOMAIN_PLLS);
	}

	for_each_intel_encoder(dev, encoder) {
		pipe = 0;

		if (encoder->get_hw_state(encoder, &pipe)) {
			crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
			encoder->base.crtc = &crtc->base;
			encoder->get_config(encoder, crtc->config);
		} else {
			encoder->base.crtc = NULL;
		}

		DRM_DEBUG_KMS("[ENCODER:%d:%s] hw state readout: %s, pipe %c\n",
			      encoder->base.base.id,
			      encoder->base.name,
			      encoder->base.crtc ? "enabled" : "disabled",
			      pipe_name(pipe));
	}

	for_each_intel_connector(dev, connector) {
		if (connector->get_hw_state(connector)) {
			connector->base.dpms = DRM_MODE_DPMS_ON;
			connector->base.encoder = &connector->encoder->base;
		} else {
			connector->base.dpms = DRM_MODE_DPMS_OFF;
			connector->base.encoder = NULL;
		}
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] hw state readout: %s\n",
			      connector->base.base.id,
			      connector->base.name,
			      connector->base.encoder ? "enabled" : "disabled");
	}

	for_each_intel_crtc(dev, crtc) {
		crtc->base.hwmode = crtc->config->base.adjusted_mode;

		memset(&crtc->base.mode, 0, sizeof(crtc->base.mode));
		if (crtc->base.state->active) {
			intel_mode_from_pipe_config(&crtc->base.mode, crtc->config);
			intel_mode_from_pipe_config(&crtc->base.state->adjusted_mode, crtc->config);
			WARN_ON(drm_atomic_set_mode_for_crtc(crtc->base.state, &crtc->base.mode));

			/*
			 * The initial mode needs to be set in order to keep
			 * the atomic core happy. It wants a valid mode if the
			 * crtc's enabled, so we do the above call.
			 *
			 * At this point some state updated by the connectors
			 * in their ->detect() callback has not run yet, so
			 * no recalculation can be done yet.
			 *
			 * Even if we could do a recalculation and modeset
			 * right now it would cause a double modeset if
			 * fbdev or userspace chooses a different initial mode.
			 *
			 * If that happens, someone indicated they wanted a
			 * mode change, which means it's safe to do a full
			 * recalculation.
			 */
			crtc->base.state->mode.private_flags = I915_MODE_FLAG_INHERITED;

			drm_calc_timestamping_constants(&crtc->base, &crtc->base.hwmode);
			update_scanline_offset(crtc);
		}
	}
}

/* Scan out the current hw modeset state,
 * and sanitizes it to the current state
 */
static void
intel_modeset_setup_hw_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe;
	struct intel_crtc *crtc;
	struct intel_encoder *encoder;
	int i;

	intel_modeset_readout_hw_state(dev);

	/* HW state is read out, now we need to sanitize this mess. */
	for_each_intel_encoder(dev, encoder) {
		intel_sanitize_encoder(encoder);
	}

	for_each_pipe(dev_priv, pipe) {
		crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
		intel_sanitize_crtc(crtc);
		intel_dump_pipe_config(crtc, crtc->config,
				       "[setup_hw_state]");
	}

	intel_modeset_update_connector_atomic_state(dev);

	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		struct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];

		if (!pll->on || pll->active)
			continue;

		DRM_DEBUG_KMS("%s enabled but not in use, disabling\n", pll->name);

		pll->disable(dev_priv, pll);
		pll->on = false;
	}

	if (IS_VALLEYVIEW(dev))
		vlv_wm_get_hw_state(dev);
	else if (IS_GEN9(dev))
		skl_wm_get_hw_state(dev);
	else if (HAS_PCH_SPLIT(dev))
		ilk_wm_get_hw_state(dev);

	for_each_intel_crtc(dev, crtc) {
		unsigned long put_domains;

		put_domains = modeset_get_crtc_power_domains(&crtc->base);
		if (WARN_ON(put_domains))
			modeset_put_power_domains(dev_priv, put_domains);
	}
	intel_display_set_init_power(dev_priv, false);
}

void intel_display_resume(struct drm_device *dev)
{
	struct drm_atomic_state *state = drm_atomic_state_alloc(dev);
	struct intel_connector *conn;
	struct intel_plane *plane;
	struct drm_crtc *crtc;
	int ret;

	if (!state)
		return;

	state->acquire_ctx = dev->mode_config.acquire_ctx;

	/* preserve complete old state, including dpll */
	intel_atomic_get_shared_dpll_state(state);

	for_each_crtc(dev, crtc) {
		struct drm_crtc_state *crtc_state =
			drm_atomic_get_crtc_state(state, crtc);

		ret = PTR_ERR_OR_ZERO(crtc_state);
		if (ret)
			goto err;

		/* force a restore */
		crtc_state->mode_changed = true;
	}

	for_each_intel_plane(dev, plane) {
		ret = PTR_ERR_OR_ZERO(drm_atomic_get_plane_state(state, &plane->base));
		if (ret)
			goto err;
	}

	for_each_intel_connector(dev, conn) {
		ret = PTR_ERR_OR_ZERO(drm_atomic_get_connector_state(state, &conn->base));
		if (ret)
			goto err;
	}

	intel_modeset_setup_hw_state(dev);

	i915_redisable_vga(dev);
	ret = drm_atomic_commit(state);
	if (!ret)
		return;

err:
	DRM_ERROR("Restoring old state failed with %i\n", ret);
	drm_atomic_state_free(state);
}

void intel_modeset_gem_init(struct drm_device *dev)
{
	struct drm_crtc *c;
	struct drm_i915_gem_object *obj;
	int ret;

	mutex_lock(&dev->struct_mutex);
	intel_init_gt_powersave(dev);
	mutex_unlock(&dev->struct_mutex);

	intel_modeset_init_hw(dev);

	intel_setup_overlay(dev);

	/*
	 * Make sure any fbs we allocated at startup are properly
	 * pinned & fenced.  When we do the allocation it's too early
	 * for this.
	 */
	for_each_crtc(dev, c) {
		obj = intel_fb_obj(c->primary->fb);
		if (obj == NULL)
			continue;

		mutex_lock(&dev->struct_mutex);
		ret = intel_pin_and_fence_fb_obj(c->primary,
						 c->primary->fb,
						 c->primary->state,
						 NULL, NULL);
		mutex_unlock(&dev->struct_mutex);
		if (ret) {
			DRM_ERROR("failed to pin boot fb on pipe %d\n",
				  to_intel_crtc(c)->pipe);
			drm_framebuffer_unreference(c->primary->fb);
			c->primary->fb = NULL;
			c->primary->crtc = c->primary->state->crtc = NULL;
			update_state_fb(c->primary);
			c->state->plane_mask &= ~(1 << drm_plane_index(c->primary));
		}
	}

	intel_backlight_register(dev);
}

void intel_connector_unregister(struct intel_connector *intel_connector)
{
	struct drm_connector *connector = &intel_connector->base;

	intel_panel_destroy_backlight(connector);
	drm_connector_unregister(connector);
}

void intel_modeset_cleanup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_connector *connector;

	intel_disable_gt_powersave(dev);

	intel_backlight_unregister(dev);

	/*
	 * Interrupts and polling as the first thing to avoid creating havoc.
	 * Too much stuff here (turning of connectors, ...) would
	 * experience fancy races otherwise.
	 */
	intel_irq_uninstall(dev_priv);

	/*
	 * Due to the hpd irq storm handling the hotplug work can re-arm the
	 * poll handlers. Hence disable polling after hpd handling is shut down.
	 */
	drm_kms_helper_poll_fini(dev);

#ifdef notyet
	intel_unregister_dsm_handler();
#endif

	intel_fbc_disable(dev_priv);

	/* flush any delayed tasks or pending work */
	flush_scheduled_work();

	/* destroy the backlight and sysfs files before encoders/connectors */
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		struct intel_connector *intel_connector;

		intel_connector = to_intel_connector(connector);
		intel_connector->unregister(intel_connector);
	}

	drm_mode_config_cleanup(dev);

	intel_cleanup_overlay(dev);

	mutex_lock(&dev->struct_mutex);
	intel_cleanup_gt_powersave(dev);
	mutex_unlock(&dev->struct_mutex);

	intel_teardown_gmbus(dev);
}

/*
 * Return which encoder is currently attached for connector.
 */
struct drm_encoder *intel_best_encoder(struct drm_connector *connector)
{
	return &intel_attached_encoder(connector)->base;
}

void intel_connector_attach_encoder(struct intel_connector *connector,
				    struct intel_encoder *encoder)
{
	connector->encoder = encoder;
	drm_mode_connector_attach_encoder(&connector->base,
					  &encoder->base);
}

/*
 * set vga decode state - true == enable VGA decode
 */
int intel_modeset_vga_set_state(struct drm_device *dev, bool state)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned reg = INTEL_INFO(dev)->gen >= 6 ? SNB_GMCH_CTRL : INTEL_GMCH_CTRL;
	u16 gmch_ctrl;

	if (pci_read_config_word(dev_priv->bridge_dev, reg, &gmch_ctrl)) {
		DRM_ERROR("failed to read control word\n");
		return -EIO;
	}

	if (!!(gmch_ctrl & INTEL_GMCH_VGA_DISABLE) == !state)
		return 0;

	if (state)
		gmch_ctrl &= ~INTEL_GMCH_VGA_DISABLE;
	else
		gmch_ctrl |= INTEL_GMCH_VGA_DISABLE;

	if (pci_write_config_word(dev_priv->bridge_dev, reg, gmch_ctrl)) {
		DRM_ERROR("failed to write control word\n");
		return -EIO;
	}

	return 0;
}

struct intel_display_error_state {

	u32 power_well_driver;

	int num_transcoders;

	struct intel_cursor_error_state {
		u32 control;
		u32 position;
		u32 base;
		u32 size;
	} cursor[I915_MAX_PIPES];

	struct intel_pipe_error_state {
		bool power_domain_on;
		u32 source;
		u32 stat;
	} pipe[I915_MAX_PIPES];

	struct intel_plane_error_state {
		u32 control;
		u32 stride;
		u32 size;
		u32 pos;
		u32 addr;
		u32 surface;
		u32 tile_offset;
	} plane[I915_MAX_PIPES];

	struct intel_transcoder_error_state {
		bool power_domain_on;
		enum transcoder cpu_transcoder;

		u32 conf;

		u32 htotal;
		u32 hblank;
		u32 hsync;
		u32 vtotal;
		u32 vblank;
		u32 vsync;
	} transcoder[4];
};

struct intel_display_error_state *
intel_display_capture_error_state(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_display_error_state *error;
	int transcoders[] = {
		TRANSCODER_A,
		TRANSCODER_B,
		TRANSCODER_C,
		TRANSCODER_EDP,
	};
	int i;

	if (INTEL_INFO(dev)->num_pipes == 0)
		return NULL;

	error = kzalloc(sizeof(*error), GFP_ATOMIC);
	if (error == NULL)
		return NULL;

	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		error->power_well_driver = I915_READ(HSW_PWR_WELL_DRIVER);

	for_each_pipe(dev_priv, i) {
		error->pipe[i].power_domain_on =
			__intel_display_power_is_enabled(dev_priv,
							 POWER_DOMAIN_PIPE(i));
		if (!error->pipe[i].power_domain_on)
			continue;

		error->cursor[i].control = I915_READ(CURCNTR(i));
		error->cursor[i].position = I915_READ(CURPOS(i));
		error->cursor[i].base = I915_READ(CURBASE(i));

		error->plane[i].control = I915_READ(DSPCNTR(i));
		error->plane[i].stride = I915_READ(DSPSTRIDE(i));
		if (INTEL_INFO(dev)->gen <= 3) {
			error->plane[i].size = I915_READ(DSPSIZE(i));
			error->plane[i].pos = I915_READ(DSPPOS(i));
		}
		if (INTEL_INFO(dev)->gen <= 7 && !IS_HASWELL(dev))
			error->plane[i].addr = I915_READ(DSPADDR(i));
		if (INTEL_INFO(dev)->gen >= 4) {
			error->plane[i].surface = I915_READ(DSPSURF(i));
			error->plane[i].tile_offset = I915_READ(DSPTILEOFF(i));
		}

		error->pipe[i].source = I915_READ(PIPESRC(i));

		if (HAS_GMCH_DISPLAY(dev))
			error->pipe[i].stat = I915_READ(PIPESTAT(i));
	}

	error->num_transcoders = INTEL_INFO(dev)->num_pipes;
	if (HAS_DDI(dev_priv->dev))
		error->num_transcoders++; /* Account for eDP. */

	for (i = 0; i < error->num_transcoders; i++) {
		enum transcoder cpu_transcoder = transcoders[i];

		error->transcoder[i].power_domain_on =
			__intel_display_power_is_enabled(dev_priv,
				POWER_DOMAIN_TRANSCODER(cpu_transcoder));
		if (!error->transcoder[i].power_domain_on)
			continue;

		error->transcoder[i].cpu_transcoder = cpu_transcoder;

		error->transcoder[i].conf = I915_READ(PIPECONF(cpu_transcoder));
		error->transcoder[i].htotal = I915_READ(HTOTAL(cpu_transcoder));
		error->transcoder[i].hblank = I915_READ(HBLANK(cpu_transcoder));
		error->transcoder[i].hsync = I915_READ(HSYNC(cpu_transcoder));
		error->transcoder[i].vtotal = I915_READ(VTOTAL(cpu_transcoder));
		error->transcoder[i].vblank = I915_READ(VBLANK(cpu_transcoder));
		error->transcoder[i].vsync = I915_READ(VSYNC(cpu_transcoder));
	}

	return error;
}

#define err_printf(e, ...) i915_error_printf(e, __VA_ARGS__)

void
intel_display_print_error_state(struct drm_i915_error_state_buf *m,
				struct drm_device *dev,
				struct intel_display_error_state *error)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	if (!error)
		return;

	err_printf(m, "Num Pipes: %d\n", INTEL_INFO(dev)->num_pipes);
	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		err_printf(m, "PWR_WELL_CTL2: %08x\n",
			   error->power_well_driver);
	for_each_pipe(dev_priv, i) {
		err_printf(m, "Pipe [%d]:\n", i);
		err_printf(m, "  Power: %s\n",
			   error->pipe[i].power_domain_on ? "on" : "off");
		err_printf(m, "  SRC: %08x\n", error->pipe[i].source);
		err_printf(m, "  STAT: %08x\n", error->pipe[i].stat);

		err_printf(m, "Plane [%d]:\n", i);
		err_printf(m, "  CNTR: %08x\n", error->plane[i].control);
		err_printf(m, "  STRIDE: %08x\n", error->plane[i].stride);
		if (INTEL_INFO(dev)->gen <= 3) {
			err_printf(m, "  SIZE: %08x\n", error->plane[i].size);
			err_printf(m, "  POS: %08x\n", error->plane[i].pos);
		}
		if (INTEL_INFO(dev)->gen <= 7 && !IS_HASWELL(dev))
			err_printf(m, "  ADDR: %08x\n", error->plane[i].addr);
		if (INTEL_INFO(dev)->gen >= 4) {
			err_printf(m, "  SURF: %08x\n", error->plane[i].surface);
			err_printf(m, "  TILEOFF: %08x\n", error->plane[i].tile_offset);
		}

		err_printf(m, "Cursor [%d]:\n", i);
		err_printf(m, "  CNTR: %08x\n", error->cursor[i].control);
		err_printf(m, "  POS: %08x\n", error->cursor[i].position);
		err_printf(m, "  BASE: %08x\n", error->cursor[i].base);
	}

	for (i = 0; i < error->num_transcoders; i++) {
		err_printf(m, "CPU transcoder: %c\n",
			   transcoder_name(error->transcoder[i].cpu_transcoder));
		err_printf(m, "  Power: %s\n",
			   error->transcoder[i].power_domain_on ? "on" : "off");
		err_printf(m, "  CONF: %08x\n", error->transcoder[i].conf);
		err_printf(m, "  HTOTAL: %08x\n", error->transcoder[i].htotal);
		err_printf(m, "  HBLANK: %08x\n", error->transcoder[i].hblank);
		err_printf(m, "  HSYNC: %08x\n", error->transcoder[i].hsync);
		err_printf(m, "  VTOTAL: %08x\n", error->transcoder[i].vtotal);
		err_printf(m, "  VBLANK: %08x\n", error->transcoder[i].vblank);
		err_printf(m, "  VSYNC: %08x\n", error->transcoder[i].vsync);
	}
}

void intel_modeset_preclose(struct drm_device *dev, struct drm_file *file)
{
	struct intel_crtc *crtc;

	for_each_intel_crtc(dev, crtc) {
		struct intel_unpin_work *work;

		spin_lock_irq(&dev->event_lock);

		work = crtc->unpin_work;

		if (work && work->event &&
		    work->event->base.file_priv == file) {
			kfree(work->event);
			work->event = NULL;
		}

		spin_unlock_irq(&dev->event_lock);
	}
}
@


1.59
log
@Enable MIPI/DSI support for inteldrm(4).  Makes the display on my ASUS
Transformer Book T100HA work (with some ugly error/warning messages).
@
text
@d12592 1
d12594 1
@


1.58
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@a14220 1
#ifdef notyet
a14221 1
#endif
@


1.57
log
@Provide a minimal implementation of the Linux vga_get/vga_put API and use it
in inteldrm(4).

The Intel integrated graphics device has a major design flaw where it needs
legacy VGA io access to disable VGA mode completely.  This only works if
legacy VGA io routing is setup such that it actually reaches the IGD.  This
typically isn't the case if the primary VGA device is a discrete graphics
device.  To make sure we don't whack that device we have to temporarily
route legacy VGA io access to the IGD.

Fixes the "black screen" issue reported by Timo Myrra and others.
@
text
@a0 1
/*	$OpenBSD: intel_display.c,v 1.56 2015/09/25 09:42:14 kettenis Exp $	*/
d27 9
d42 2
d46 43
a89 1
static void intel_increase_pllclock(struct drm_crtc *crtc);
d93 1
a93 1
				struct intel_crtc_config *pipe_config);
d95 1
a95 4
				   struct intel_crtc_config *pipe_config);

static int intel_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
			  int x, int y, struct drm_framebuffer *old_fb);
d97 27
d140 36
d186 44
d477 30
a506 1
static void vlv_clock(int refclk, intel_clock_t *clock)
d508 1
a508 6
	clock->m = clock->m1 * clock->m2;
	clock->p = clock->p1 * clock->p2;
	if (WARN_ON(clock->n == 0 || clock->p == 0))
		return;
	clock->vco = DIV_ROUND_CLOSEST(refclk * clock->m, clock->n);
	clock->dot = DIV_ROUND_CLOSEST(clock->vco, clock->p);
d514 20
a533 1
static bool intel_pipe_has_type(struct drm_crtc *crtc, int type)
d535 3
a537 1
	struct drm_device *dev = crtc->dev;
d539 7
d547 1
a547 1
	for_each_encoder_on_crtc(dev, crtc, encoder)
d550 3
d557 2
a558 2
static const intel_limit_t *intel_ironlake_limit(struct drm_crtc *crtc,
						int refclk)
d560 1
a560 1
	struct drm_device *dev = crtc->dev;
d563 1
a563 1
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
d581 2
a582 1
static const intel_limit_t *intel_g4x_limit(struct drm_crtc *crtc)
d584 1
a584 1
	struct drm_device *dev = crtc->dev;
d587 1
a587 1
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
d592 2
a593 2
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI) ||
		   intel_pipe_has_type(crtc, INTEL_OUTPUT_ANALOG)) {
d595 1
a595 1
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_SDVO)) {
d603 2
a604 1
static const intel_limit_t *intel_limit(struct drm_crtc *crtc, int refclk)
d606 1
a606 1
	struct drm_device *dev = crtc->dev;
d609 4
a612 2
	if (HAS_PCH_SPLIT(dev))
		limit = intel_ironlake_limit(crtc, refclk);
d614 1
a614 1
		limit = intel_g4x_limit(crtc);
d616 1
a616 1
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
d620 2
d625 1
a625 1
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
d630 1
a630 1
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
d632 1
a632 1
		else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DVO))
d640 8
d649 1
a649 1
static void pineview_clock(int refclk, intel_clock_t *clock)
d654 1
a654 1
		return;
d657 2
d666 1
a666 1
static void i9xx_clock(int refclk, intel_clock_t *clock)
d671 1
a671 1
		return;
d674 27
d722 1
a722 1
	if (!IS_PINEVIEW(dev) && !IS_VALLEYVIEW(dev))
d726 1
a726 1
	if (!IS_VALLEYVIEW(dev)) {
d744 4
a747 4
static bool
i9xx_find_best_dpll(const intel_limit_t *limit, struct drm_crtc *crtc,
		    int target, int refclk, intel_clock_t *match_clock,
		    intel_clock_t *best_clock)
d749 1
a749 3
	struct drm_device *dev = crtc->dev;
	intel_clock_t clock;
	int err = target;
d751 1
a751 1
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
d758 1
a758 1
			clock.p2 = limit->p2.p2_fast;
d760 1
a760 1
			clock.p2 = limit->p2.p2_slow;
d763 1
a763 1
			clock.p2 = limit->p2.p2_slow;
d765 1
a765 1
			clock.p2 = limit->p2.p2_fast;
d767 11
d781 2
d795 1
a795 1
					i9xx_clock(refclk, &clock);
d817 2
a818 1
pnv_find_best_dpll(const intel_limit_t *limit, struct drm_crtc *crtc,
d822 1
a822 1
	struct drm_device *dev = crtc->dev;
d826 1
a826 16
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
		/*
		 * For LVDS just rely on its current settings for dual-channel.
		 * We haven't figured out how to reliably set up different
		 * single/dual channel state, if we even can.
		 */
		if (intel_is_dual_link_lvds(dev))
			clock.p2 = limit->p2.p2_fast;
		else
			clock.p2 = limit->p2.p2_slow;
	} else {
		if (target < limit->p2.dot_limit)
			clock.p2 = limit->p2.p2_slow;
		else
			clock.p2 = limit->p2.p2_fast;
	}
d828 1
a828 1
	memset(best_clock, 0, sizeof(*best_clock));
d840 1
a840 1
					pineview_clock(refclk, &clock);
d862 2
a863 1
g4x_find_best_dpll(const intel_limit_t *limit, struct drm_crtc *crtc,
d867 1
a867 1
	struct drm_device *dev = crtc->dev;
d870 1
a870 1
	bool found;
a872 1
	found = false;
d874 3
a876 11
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
		if (intel_is_dual_link_lvds(dev))
			clock.p2 = limit->p2.p2_fast;
		else
			clock.p2 = limit->p2.p2_slow;
	} else {
		if (target < limit->p2.dot_limit)
			clock.p2 = limit->p2.p2_slow;
		else
			clock.p2 = limit->p2.p2_fast;
	}
a877 1
	memset(best_clock, 0, sizeof(*best_clock));
d890 1
a890 1
					i9xx_clock(refclk, &clock);
d909 40
d950 2
a951 1
vlv_find_best_dpll(const intel_limit_t *limit, struct drm_crtc *crtc,
d955 2
a956 1
	struct drm_device *dev = crtc->dev;
d975 1
a975 1
					unsigned int ppm, diff;
d980 1
a980 1
					vlv_clock(refclk, &clock);
d986 5
a990 2
					diff = abs(clock.dot - target);
					ppm = div_u64(1000000ULL * diff, target);
d992 3
a994 11
					if (ppm < 100 && clock.p > best_clock->p) {
						bestppm = 0;
						*best_clock = clock;
						found = true;
					}

					if (bestppm >= 10 && ppm < bestppm - 10) {
						bestppm = ppm;
						*best_clock = clock;
						found = true;
					}
d1003 67
d1080 1
a1080 1
	 * We can ditch the crtc->fb check as soon as we can
d1082 4
d1087 2
a1088 2
	return intel_crtc->active && crtc->fb &&
		intel_crtc->config.adjusted_mode.crtc_clock;
d1097 1
a1097 53
	return intel_crtc->config.cpu_transcoder;
}

static void g4x_wait_for_vblank(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 frame, frame_reg = PIPE_FRMCOUNT_GM45(pipe);

	frame = I915_READ(frame_reg);

	if (wait_for(I915_READ_NOTRACE(frame_reg) != frame, 50))
		DRM_DEBUG_KMS("vblank wait timed out\n");
}

/**
 * intel_wait_for_vblank - wait for vblank on a given pipe
 * @@dev: drm device
 * @@pipe: pipe to wait for
 *
 * Wait for vblank to occur on a given pipe.  Needed for various bits of
 * mode setting code.
 */
void intel_wait_for_vblank(struct drm_device *dev, int pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipestat_reg = PIPESTAT(pipe);

	if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5) {
		g4x_wait_for_vblank(dev, pipe);
		return;
	}

	/* Clear existing vblank status. Note this will clear any other
	 * sticky status fields as well.
	 *
	 * This races with i915_driver_irq_handler() with the result
	 * that either function could miss a vblank event.  Here it is not
	 * fatal, as we will either wait upon the next vblank interrupt or
	 * timeout.  Generally speaking intel_wait_for_vblank() is only
	 * called during modeset at which time the GPU should be idle and
	 * should *not* be performing page flips and thus not waiting on
	 * vblanks...
	 * Currently, the result of us stealing a vblank from the irq
	 * handler is that a single frame will be skipped during swapbuffers.
	 */
	I915_WRITE(pipestat_reg,
		   I915_READ(pipestat_reg) | PIPE_VBLANK_INTERRUPT_STATUS);

	/* Wait for vblank interrupt bit to set */
	if (wait_for(I915_READ(pipestat_reg) &
		     PIPE_VBLANK_INTERRUPT_STATUS,
		     50))
		DRM_DEBUG_KMS("vblank wait timed out\n");
d1113 1
a1113 1
	mdelay(5);
d1121 1
a1121 2
 * @@dev: drm device
 * @@pipe: pipe to wait for
d1135 1
a1135 1
void intel_wait_for_pipe_off(struct drm_device *dev, int pipe)
d1137 1
d1139 2
a1140 2
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
d1156 8
a1163 9
/*
 * ibx_digital_port_connected - is the specified port connected?
 * @@dev_priv: i915 private structure
 * @@port: the port to test
 *
 * Returns true if @@port is connected, false otherwise.
 */
bool ibx_digital_port_connected(struct drm_i915_private *dev_priv,
				struct intel_digital_port *port)
d1165 2
a1166 1
	u32 bit;
d1168 3
a1170 50
	if (HAS_PCH_IBX(dev_priv->dev)) {
		switch(port->port) {
		case PORT_B:
			bit = SDE_PORTB_HOTPLUG;
			break;
		case PORT_C:
			bit = SDE_PORTC_HOTPLUG;
			break;
		case PORT_D:
			bit = SDE_PORTD_HOTPLUG;
			break;
		default:
			return true;
		}
	} else {
		switch(port->port) {
		case PORT_B:
			bit = SDE_PORTB_HOTPLUG_CPT;
			break;
		case PORT_C:
			bit = SDE_PORTC_HOTPLUG_CPT;
			break;
		case PORT_D:
			bit = SDE_PORTD_HOTPLUG_CPT;
			break;
		default:
			return true;
		}
	}

	return I915_READ(SDEISR) & bit;
}

static const char *state_string(bool enabled)
{
	return enabled ? "on" : "off";
}

/* Only for pre-ILK configs */
void assert_pll(struct drm_i915_private *dev_priv,
		enum pipe pipe, bool state)
{
	int reg;
	u32 val;
	bool cur_state;

	reg = DPLL(pipe);
	val = I915_READ(reg);
	cur_state = !!(val & DPLL_VCO_ENABLE);
	WARN(cur_state != state,
d1181 1
a1181 1
	mutex_lock(&dev_priv->dpio_lock);
d1183 1
a1183 1
	mutex_unlock(&dev_priv->dpio_lock);
d1186 1
a1186 1
	WARN(cur_state != state,
d1198 1
a1198 1
	if (crtc->config.shared_dpll < 0)
d1201 1
a1201 1
	return &dev_priv->shared_dplls[crtc->config.shared_dpll];
a1211 5
	if (HAS_PCH_LPT(dev_priv->dev)) {
		DRM_DEBUG_DRIVER("LPT detected: skipping PCH PLL test\n");
		return;
	}

d1217 1
a1217 1
	WARN(cur_state != state,
a1224 2
	int reg;
	u32 val;
d1231 1
a1231 2
		reg = TRANS_DDI_FUNC_CTL(cpu_transcoder);
		val = I915_READ(reg);
d1234 1
a1234 2
		reg = FDI_TX_CTL(pipe);
		val = I915_READ(reg);
d1237 1
a1237 1
	WARN(cur_state != state,
a1246 1
	int reg;
d1250 1
a1250 2
	reg = FDI_RX_CTL(pipe);
	val = I915_READ(reg);
d1252 1
a1252 1
	WARN(cur_state != state,
a1261 1
	int reg;
d1265 1
a1265 1
	if (dev_priv->info->gen == 5)
d1272 2
a1273 3
	reg = FDI_TX_CTL(pipe);
	val = I915_READ(reg);
	WARN(!(val & FDI_TX_PLL_ENABLE), "FDI TX PLL assertion failure, should be active but is disabled\n");
a1278 1
	int reg;
d1282 1
a1282 2
	reg = FDI_RX_CTL(pipe);
	val = I915_READ(reg);
d1284 1
a1284 1
	WARN(cur_state != state,
d1289 2
a1290 2
static void assert_panel_unlocked(struct drm_i915_private *dev_priv,
				  enum pipe pipe)
d1292 2
a1293 1
	int pp_reg, lvds_reg;
d1298 6
a1303 1
	if (HAS_PCH_SPLIT(dev_priv->dev)) {
d1305 10
a1314 1
		lvds_reg = PCH_LVDS;
d1317 2
a1318 1
		lvds_reg = LVDS;
d1323 1
a1323 1
	    ((val & PANEL_UNLOCK_REGS) == PANEL_UNLOCK_REGS))
d1326 1
a1326 4
	if (I915_READ(lvds_reg) & LVDS_PIPEB_SELECT)
		panel_pipe = PIPE_B;

	WARN(panel_pipe == pipe && locked,
d1338 2
a1339 2
		cur_state = I915_READ(_CURACNTR) & CURSOR_ENABLE;
	else if (INTEL_INFO(dev)->gen <= 6 || IS_VALLEYVIEW(dev))
a1340 2
	else
		cur_state = I915_READ(CURCNTR_IVB(pipe)) & CURSOR_MODE;
d1342 1
a1342 1
	WARN(cur_state != state,
a1351 2
	int reg;
	u32 val;
d1356 3
a1358 2
	/* if we need the pipe A quirk it must be always on */
	if (pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)
d1361 1
a1361 1
	if (!intel_display_power_enabled(dev_priv->dev,
d1365 1
a1365 2
		reg = PIPECONF(cpu_transcoder);
		val = I915_READ(reg);
d1369 1
a1369 1
	WARN(cur_state != state,
a1376 1
	int reg;
d1380 1
a1380 2
	reg = DSPCNTR(plane);
	val = I915_READ(reg);
d1382 1
a1382 1
	WARN(cur_state != state,
d1394 1
a1394 3
	int reg, i;
	u32 val;
	int cur_pipe;
d1398 2
a1399 3
		reg = DSPCNTR(pipe);
		val = I915_READ(reg);
		WARN((val & DISPLAY_PLANE_ENABLE),
d1406 3
a1408 4
	for_each_pipe(i) {
		reg = DSPCNTR(i);
		val = I915_READ(reg);
		cur_pipe = (val & DISPPLANE_SEL_PIPE_MASK) >>
d1410 1
a1410 1
		WARN((val & DISPLAY_PLANE_ENABLE) && pipe == cur_pipe,
d1420 1
a1420 2
	int reg, i;
	u32 val;
d1422 11
a1432 5
	if (IS_VALLEYVIEW(dev)) {
		for (i = 0; i < dev_priv->num_plane; i++) {
			reg = SPCNTR(pipe, i);
			val = I915_READ(reg);
			WARN((val & SP_ENABLE),
d1434 1
a1434 1
			     sprite_name(pipe, i), pipe_name(pipe));
d1437 2
a1438 3
		reg = SPRCTL(pipe);
		val = I915_READ(reg);
		WARN((val & SPRITE_ENABLE),
d1442 2
a1443 3
		reg = DVSCNTR(pipe);
		val = I915_READ(reg);
		WARN((val & DVS_ENABLE),
d1449 6
d1460 1
a1460 1
	WARN_ON(!(HAS_PCH_IBX(dev_priv->dev) || HAS_PCH_CPT(dev_priv->dev)));
d1465 1
a1465 1
	WARN(!enabled, "PCH refclk assertion failure, should be active but is disabled\n");
a1470 1
	int reg;
d1474 1
a1474 2
	reg = PCH_TRANSCONF(pipe);
	val = I915_READ(reg);
d1476 1
a1476 1
	WARN(enabled,
d1492 3
d1511 3
d1556 1
a1556 1
	WARN(dp_pipe_enabled(dev_priv, pipe, port_sel, val),
d1560 1
a1560 1
	WARN(HAS_PCH_IBX(dev_priv->dev) && (val & DP_PORT_EN) == 0
d1569 1
a1569 1
	WARN(hdmi_pipe_enabled(dev_priv, pipe, val),
d1573 1
a1573 1
	WARN(HAS_PCH_IBX(dev_priv->dev) && (val & SDVO_ENABLE) == 0
a1580 1
	int reg;
d1587 2
a1588 3
	reg = PCH_ADPA;
	val = I915_READ(reg);
	WARN(adpa_pipe_enabled(dev_priv, pipe, val),
d1592 2
a1593 3
	reg = PCH_LVDS;
	val = I915_READ(reg);
	WARN(lvds_pipe_enabled(dev_priv, pipe, val),
d1602 2
a1603 39
static void intel_init_dpio(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!IS_VALLEYVIEW(dev))
		return;

	DPIO_PHY_IOSF_PORT(DPIO_PHY0) = IOSF_PORT_DPIO;
}

static void intel_reset_dpio(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!IS_VALLEYVIEW(dev))
		return;

	/*
	 * Enable the CRI clock source so we can get at the display and the
	 * reference clock for VGA hotplug / manual detection.
	 */
	I915_WRITE(DPLL(PIPE_B), I915_READ(DPLL(PIPE_B)) |
		   DPLL_REFA_CLK_ENABLE_VLV |
		   DPLL_INTEGRATED_CRI_CLK_VLV);

	/*
	 * From VLV2A0_DP_eDP_DPIO_driver_vbios_notes_10.docx -
	 *  6.	De-assert cmn_reset/side_reset. Same as VLV X0.
	 *   a.	GUnit 0x2110 bit[0] set to 1 (def 0)
	 *   b.	The other bits such as sfr settings / modesel may all be set
	 *      to 0.
	 *
	 * This should only be done on init and resume from S3 with both
	 * PLLs disabled, or we risk losing DPIO and PLL synchronization.
	 */
	I915_WRITE(DPIO_CTL, I915_READ(DPIO_CTL) | DPIO_CMNRST);
}

static void vlv_enable_pll(struct intel_crtc *crtc)
d1608 1
a1608 1
	u32 dpll = crtc->config.dpll_hw_state.dpll;
d1616 1
a1616 1
	if (IS_MOBILE(dev_priv->dev) && !IS_I830(dev_priv->dev))
d1626 1
a1626 1
	I915_WRITE(DPLL_MD(crtc->pipe), crtc->config.dpll_hw_state.dpll_md);
d1641 51
d1697 1
a1697 1
	u32 dpll = crtc->config.dpll_hw_state.dpll;
d1702 1
a1702 1
	BUG_ON(dev_priv->info->gen >= 5);
d1708 20
d1736 1
a1736 1
			   crtc->config.dpll_hw_state.dpll_md);
d1767 1
a1767 1
static void i9xx_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
d1769 17
a1785 2
	/* Don't disable pipe A or pipe A PLLs if needed */
	if (pipe == PIPE_A && (dev_priv->quirks & QUIRK_PIPEA_FORCE))
d1791 1
a1791 1
	I915_WRITE(DPLL(pipe), 0);
d1797 1
a1797 1
	u32 val = 0;
d1806 1
d1808 19
a1826 1
		val = DPLL_INTEGRATED_CRI_CLK_VLV | DPLL_REFA_CLK_ENABLE_VLV;
d1829 9
d1841 2
a1842 1
		struct intel_digital_port *dport)
d1845 1
d1850 1
d1854 6
d1865 22
a1886 3
	if (wait_for((I915_READ(DPLL(0)) & port_mask) == 0, 1000))
		WARN(1, "timed out waiting for port %c ready: 0x%08x\n",
		     port_name(dport->port), I915_READ(DPLL(0)));
d1890 1
a1890 1
 * ironlake_enable_shared_dpll - enable PCH PLL
d1897 1
a1897 1
static void ironlake_enable_shared_dpll(struct intel_crtc *crtc)
d1899 2
a1900 1
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
a1902 2
	/* PCH PLLs only available on ILK, SNB and IVB */
	BUG_ON(dev_priv->info->gen < 5);
d1906 1
a1906 1
	if (WARN_ON(pll->refcount == 0))
d1909 1
a1909 1
	DRM_DEBUG_KMS("enable %s (active %d, on? %d)for crtc %d\n",
d1920 2
d1929 2
a1930 1
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
d1934 5
a1938 3
	BUG_ON(dev_priv->info->gen < 5);
	if (WARN_ON(pll == NULL))
	       return;
d1940 1
a1940 1
	if (WARN_ON(pll->refcount == 0))
d1960 2
d1973 1
a1973 1
	BUG_ON(dev_priv->info->gen < 5);
d1998 3
a2000 2
		 * make the BPC in transcoder be consistent with
		 * that in pipeconf reg.
d2003 4
a2006 1
		val |= pipeconf_val & PIPECONF_BPC_MASK;
d2012 1
a2012 1
		    intel_pipe_has_type(crtc, INTEL_OUTPUT_SDVO))
d2030 1
a2030 1
	BUG_ON(dev_priv->info->gen < 5);
d2037 1
a2037 1
	val = I915_READ(_TRANSA_CHICKEN2);
d2039 1
a2039 1
	I915_WRITE(_TRANSA_CHICKEN2, val);
d2097 1
a2097 1
	val = I915_READ(_TRANSA_CHICKEN2);
d2099 1
a2099 1
	I915_WRITE(_TRANSA_CHICKEN2, val);
d2104 1
a2104 3
 * @@dev_priv: i915 private structure
 * @@pipe: pipe to enable
 * @@pch_port: on ILK+, is this pipe driving a PCH port or not
d2106 1
a2106 1
 * Enable @@pipe, making sure that various hardware specific requirements
a2107 5
 *
 * @@pipe should be %PIPE_A or %PIPE_B.
 *
 * Will wait until the pipe is actually running (i.e. first vblank) before
 * returning.
d2109 1
a2109 2
static void intel_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe,
			      bool pch_port, bool dsi)
d2111 3
d2120 2
d2136 2
a2137 2
	if (!HAS_PCH_SPLIT(dev_priv->dev))
		if (dsi)
d2142 1
a2142 1
		if (pch_port) {
d2153 3
a2155 1
	if (val & PIPECONF_ENABLE)
d2157 1
d2160 1
a2160 1
	intel_wait_for_vblank(dev_priv->dev, pipe);
d2165 1
a2165 2
 * @@dev_priv: i915 private structure
 * @@pipe: pipe to disable
d2167 3
a2169 4
 * Disable @@pipe, making sure that various hardware specific requirements
 * are met, if applicable, e.g. plane disabled, panel fitter off, etc.
 *
 * @@pipe should be %PIPE_A or %PIPE_B.
d2173 1
a2173 2
static void intel_disable_pipe(struct drm_i915_private *dev_priv,
			       enum pipe pipe)
d2175 3
a2177 2
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
d2181 2
a2190 4
	/* Don't disable pipe A or pipe A PLLs if needed */
	if (pipe == PIPE_A && (dev_priv->quirks & QUIRK_PIPEA_FORCE))
		return;

d2196 15
a2210 2
	I915_WRITE(reg, val & ~PIPECONF_ENABLE);
	intel_wait_for_pipe_off(dev_priv->dev, pipe);
d2213 1
a2213 6
/*
 * Plane regs are double buffered, going from enabled->disabled needs a
 * trigger in order to latch.  The display address reg provides this.
 */
void intel_flush_primary_plane(struct drm_i915_private *dev_priv,
			       enum plane plane)
d2215 50
a2264 1
	u32 reg = dev_priv->info->gen >= 4 ? DSPSURF(plane) : DSPADDR(plane);
d2266 9
a2274 2
	I915_WRITE(reg, I915_READ(reg));
	POSTING_READ(reg);
d2277 3
a2279 10
/**
 * intel_enable_primary_plane - enable the primary plane on a given pipe
 * @@dev_priv: i915 private structure
 * @@plane: plane to enable
 * @@pipe: pipe being fed
 *
 * Enable @@plane on @@pipe, making sure that @@pipe is running first.
 */
static void intel_enable_primary_plane(struct drm_i915_private *dev_priv,
				       enum plane plane, enum pipe pipe)
d2281 4
a2284 4
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
	int reg;
	u32 val;
d2286 2
a2287 2
	/* If the pipe isn't enabled, we can't pump pixels and may hang */
	assert_pipe_enabled(dev_priv, pipe);
d2289 2
a2290 1
	WARN(intel_crtc->primary_enabled, "Primary plane already enabled\n");
d2292 1
a2292 1
	intel_crtc->primary_enabled = true;
d2294 23
a2316 4
	reg = DSPCNTR(plane);
	val = I915_READ(reg);
	if (val & DISPLAY_PLANE_ENABLE)
		return;
d2318 1
a2318 3
	I915_WRITE(reg, val | DISPLAY_PLANE_ENABLE);
	intel_flush_primary_plane(dev_priv, plane);
	intel_wait_for_vblank(dev_priv->dev, pipe);
d2321 1
a2321 10
/**
 * intel_disable_primary_plane - disable the primary plane
 * @@dev_priv: i915 private structure
 * @@plane: plane to disable
 * @@pipe: pipe consuming the data
 *
 * Disable @@plane; should be an independent operation.
 */
static void intel_disable_primary_plane(struct drm_i915_private *dev_priv,
					enum plane plane, enum pipe pipe)
d2323 9
a2331 26
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
	int reg;
	u32 val;

	WARN(!intel_crtc->primary_enabled, "Primary plane already disabled\n");

	intel_crtc->primary_enabled = false;

	reg = DSPCNTR(plane);
	val = I915_READ(reg);
	if ((val & DISPLAY_PLANE_ENABLE) == 0)
		return;

	I915_WRITE(reg, val & ~DISPLAY_PLANE_ENABLE);
	intel_flush_primary_plane(dev_priv, plane);
	intel_wait_for_vblank(dev_priv->dev, pipe);
}

static bool need_vtd_wa(struct drm_device *dev)
{
#ifdef CONFIG_INTEL_IOMMU
	if (INTEL_INFO(dev)->gen >= 6 && intel_iommu_gfx_mapped)
		return true;
#endif
	return false;
d2335 5
a2339 3
intel_pin_and_fence_fb_obj(struct drm_device *dev,
			   struct drm_i915_gem_object *obj,
			   struct intel_ring_buffer *pipelined)
d2341 1
d2343 2
d2348 20
a2367 8
	switch (obj->tiling_mode) {
	case I915_TILING_NONE:
		if (IS_BROADWATER(dev) || IS_CRESTLINE(dev))
			alignment = 128 * 1024;
		else if (INTEL_INFO(dev)->gen >= 4)
			alignment = 4 * 1024;
		else
			alignment = 64 * 1024;
d2369 2
a2370 6
	case I915_TILING_X:
		/* pin() will align the object as required by fence */
		alignment = 0;
		break;
	case I915_TILING_Y:
		WARN(1, "Y tiled bo slipped through, driver bug!\n");
a2371 2
	default:
		BUG();
d2374 4
d2386 9
d2396 2
a2397 1
	ret = i915_gem_object_pin_to_display_plane(obj, alignment, pipelined);
d2406 15
a2420 3
	ret = i915_gem_object_get_fence(obj);
	if (ret)
		goto err_unpin;
d2422 2
a2423 1
	i915_gem_object_pin_fence(obj);
d2426 1
d2430 1
a2430 1
	i915_gem_object_unpin_from_display_plane(obj);
d2433 1
d2437 2
a2438 1
void intel_unpin_fb_obj(struct drm_i915_gem_object *obj)
d2440 13
a2452 2
	i915_gem_object_unpin_fence(obj);
	i915_gem_object_unpin_from_display_plane(obj);
d2457 2
a2458 1
unsigned long intel_gen4_compute_page_offset(int *x, int *y,
d2474 1
d2478 173
a2650 3
		*y = 0;
		*x = (offset & 4095) / cpp;
		return offset & -4096;
d2652 35
d2689 3
a2691 2
static int i9xx_update_plane(struct drm_crtc *crtc, struct drm_framebuffer *fb,
			     int x, int y)
d2696 2
a2697 1
	struct intel_framebuffer *intel_fb;
d2702 2
a2703 1
	u32 reg;
d2705 8
a2712 7
	switch (plane) {
	case 0:
	case 1:
		break;
	default:
		DRM_ERROR("Can't update plane %c in SAREA\n", plane_name(plane));
		return -EINVAL;
d2715 28
a2742 2
	intel_fb = to_intel_framebuffer(fb);
	obj = intel_fb->obj;
a2743 4
	reg = DSPCNTR(plane);
	dspcntr = I915_READ(reg);
	/* Mask out pixel format bits in case we change it */
	dspcntr &= ~DISPPLANE_PIXFORMAT_MASK;
a2748 1
	case DRM_FORMAT_ARGB1555:
a2754 1
	case DRM_FORMAT_ARGB8888:
a2757 1
	case DRM_FORMAT_ABGR8888:
a2760 1
	case DRM_FORMAT_ARGB2101010:
a2763 1
	case DRM_FORMAT_ABGR2101010:
d2770 3
a2772 6
	if (INTEL_INFO(dev)->gen >= 4) {
		if (obj->tiling_mode != I915_TILING_NONE)
			dspcntr |= DISPPLANE_TILED;
		else
			dspcntr &= ~DISPPLANE_TILED;
	}
d2777 1
a2777 3
	I915_WRITE(reg, dspcntr);

	linear_offset = y * fb->pitches[0] + x * (fb->bits_per_pixel / 8);
d2781 3
a2783 2
			intel_gen4_compute_page_offset(&x, &y, obj->tiling_mode,
						       fb->bits_per_pixel / 8,
d2790 18
a2807 3
	DRM_DEBUG_KMS("Writing base %08lX %08lX %d %d %d\n",
		      i915_gem_obj_ggtt_offset(obj), linear_offset, x, y,
		      fb->pitches[0]);
a2816 2

	return 0;
d2819 3
a2821 2
static int ironlake_update_plane(struct drm_crtc *crtc,
				 struct drm_framebuffer *fb, int x, int y)
d2826 2
a2827 1
	struct intel_framebuffer *intel_fb;
d2832 2
a2833 1
	u32 reg;
d2835 5
a2839 8
	switch (plane) {
	case 0:
	case 1:
	case 2:
		break;
	default:
		DRM_ERROR("Can't update plane %c in SAREA\n", plane_name(plane));
		return -EINVAL;
d2842 12
a2853 2
	intel_fb = to_intel_framebuffer(fb);
	obj = intel_fb->obj;
a2854 4
	reg = DSPCNTR(plane);
	dspcntr = I915_READ(reg);
	/* Mask out pixel format bits in case we change it */
	dspcntr &= ~DISPPLANE_PIXFORMAT_MASK;
a2862 1
	case DRM_FORMAT_ARGB8888:
a2865 1
	case DRM_FORMAT_ABGR8888:
a2868 1
	case DRM_FORMAT_ARGB2101010:
a2871 1
	case DRM_FORMAT_ABGR2101010:
a2879 2
	else
		dspcntr &= ~DISPPLANE_TILED;
d2881 1
a2881 3
	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		dspcntr &= ~DISPPLANE_TRICKLE_FEED_DISABLE;
	else
d2884 1
a2884 3
	I915_WRITE(reg, dspcntr);

	linear_offset = y * fb->pitches[0] + x * (fb->bits_per_pixel / 8);
d2886 3
a2888 2
		intel_gen4_compute_page_offset(&x, &y, obj->tiling_mode,
					       fb->bits_per_pixel / 8,
d2891 19
a2910 3
	DRM_DEBUG_KMS("Writing base %08lX %08lX %d %d %d\n",
		      i915_gem_obj_ggtt_offset(obj), linear_offset, x, y,
		      fb->pitches[0]);
a2920 2

	return 0;
d2923 2
a2924 4
/* Assume fb object is pinned & idle & fenced and just update base pointers */
static int
intel_pipe_set_base_atomic(struct drm_crtc *crtc, struct drm_framebuffer *fb,
			   int x, int y, enum mode_set_atomic state)
d2926 1
a2926 2
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
d2928 27
a2954 5
	if (dev_priv->display.disable_fbc)
		dev_priv->display.disable_fbc(dev);
	intel_increase_pllclock(crtc);

	return dev_priv->display.update_plane(crtc, fb, x, y);
d2957 3
a2959 1
void intel_display_handle_reset(struct drm_device *dev)
d2961 6
a2966 2
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc;
d2968 4
a2971 13
	/*
	 * Flips in the rings have been nuked by the reset,
	 * so complete all pending flips so that user space
	 * will get its events and not get stuck.
	 *
	 * Also update the base address of all primary
	 * planes to the the last fb to make sure we're
	 * showing the correct fb after a reset.
	 *
	 * Need to make two loops over the crtcs so that we
	 * don't try to grab a crtc mutex before the
	 * pending_flip_queue really got woken up.
	 */
d2973 1
a2973 3
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
		enum plane plane = intel_crtc->plane;
d2975 3
a2977 2
		intel_prepare_page_flip(dev, plane);
		intel_finish_page_flip_plane(dev, plane);
d2980 1
a2980 2
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
d2982 1
a2982 11
		mutex_lock(&crtc->mutex);
		/*
		 * FIXME: Once we have proper support for primary planes (and
		 * disabling them without disabling the entire crtc) allow again
		 * a NULL crtc->fb.
		 */
		if (intel_crtc->active && crtc->fb)
			dev_priv->display.update_plane(crtc, crtc->fb,
						       crtc->x, crtc->y);
		mutex_unlock(&crtc->mutex);
	}
d2985 1
a2985 2
static int
intel_finish_fb(struct drm_framebuffer *old_fb)
d2987 2
a2988 16
	struct drm_i915_gem_object *obj = to_intel_framebuffer(old_fb)->obj;
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	bool was_interruptible = dev_priv->mm.interruptible;
	int ret;

	/* Big Hammer, we also need to ensure that any pending
	 * MI_WAIT_FOR_EVENT inside a user batch buffer on the
	 * current scanout is retired before unpinning the old
	 * framebuffer.
	 *
	 * This should only fail upon a hung GPU, in which case we
	 * can safely continue.
	 */
	dev_priv->mm.interruptible = false;
	ret = i915_gem_object_finish_gpu(obj);
	dev_priv->mm.interruptible = was_interruptible;
d2990 3
a2992 1
	return ret;
d2995 4
a2998 1
static void intel_crtc_update_sarea_pos(struct drm_crtc *crtc, int x, int y)
d3000 2
a3001 4
#if 0
	struct drm_device *dev = crtc->dev;
	struct drm_i915_master_private *master_priv;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
d3003 1
a3003 2
	if (!dev->primary->master)
		return;
d3005 47
a3051 3
	master_priv = dev->primary->master->driver_priv;
	if (!master_priv->sarea_priv)
		return;
d3053 4
a3056 8
	switch (intel_crtc->pipe) {
	case 0:
		master_priv->sarea_priv->pipeA_x = x;
		master_priv->sarea_priv->pipeA_y = y;
		break;
	case 1:
		master_priv->sarea_priv->pipeB_x = x;
		master_priv->sarea_priv->pipeB_y = y;
d3058 6
d3065 10
d3076 115
d3192 4
a3195 1
#endif
d3198 1
d3200 2
a3201 2
intel_pipe_set_base(struct drm_crtc *crtc, int x, int y,
		    struct drm_framebuffer *fb)
a3204 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_framebuffer *old_fb;
	int ret;
d3206 18
a3223 4
	/* no fb bound */
	if (!fb) {
		DRM_ERROR("No FB bound\n");
		return 0;
d3225 9
d3235 8
a3242 5
	if (intel_crtc->plane > INTEL_INFO(dev)->num_pipes) {
		DRM_ERROR("no plane for crtc: plane %c, num_pipes %d\n",
			  plane_name(intel_crtc->plane),
			  INTEL_INFO(dev)->num_pipes);
		return -EINVAL;
d3244 34
d3279 13
a3291 8
	mutex_lock(&dev->struct_mutex);
	ret = intel_pin_and_fence_fb_obj(dev,
					 to_intel_framebuffer(fb)->obj,
					 NULL);
	if (ret != 0) {
		mutex_unlock(&dev->struct_mutex);
		DRM_ERROR("pin & fence failed\n");
		return ret;
d3295 83
d3384 1
a3384 23
	 *
	 * To fix this properly, we need to hoist the checks up into
	 * compute_mode_changes (or above), check the actual pfit state and
	 * whether the platform allows pfit disable with pipe active, and only
	 * then update the pipesrc and pfit state, even on the flip path.
	 */
	if (i915_fastboot) {
		const struct drm_display_mode *adjusted_mode =
			&intel_crtc->config.adjusted_mode;

		I915_WRITE(PIPESRC(intel_crtc->pipe),
			   ((adjusted_mode->crtc_hdisplay - 1) << 16) |
			   (adjusted_mode->crtc_vdisplay - 1));
		if (!intel_crtc->config.pch_pfit.enabled &&
		    (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) ||
		     intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))) {
			I915_WRITE(PF_CTL(intel_crtc->pipe), 0);
			I915_WRITE(PF_WIN_POS(intel_crtc->pipe), 0);
			I915_WRITE(PF_WIN_SZ(intel_crtc->pipe), 0);
		}
		intel_crtc->config.pipe_src_w = adjusted_mode->crtc_hdisplay;
		intel_crtc->config.pipe_src_h = adjusted_mode->crtc_vdisplay;
	}
d3386 7
a3392 7
	ret = dev_priv->display.update_plane(crtc, fb, x, y);
	if (ret) {
		intel_unpin_fb_obj(to_intel_framebuffer(fb)->obj);
		mutex_unlock(&dev->struct_mutex);
		DRM_ERROR("failed to update base address\n");
		return ret;
	}
d3394 7
a3400 9
	old_fb = crtc->fb;
	crtc->fb = fb;
	crtc->x = x;
	crtc->y = y;

	if (old_fb) {
		if (intel_crtc->active && old_fb != fb)
			intel_wait_for_vblank(dev, intel_crtc->pipe);
		intel_unpin_fb_obj(to_intel_framebuffer(old_fb)->obj);
a3401 8

	intel_update_fbc(dev);
	intel_edp_psr_update(dev);
	mutex_unlock(&dev->struct_mutex);

	intel_crtc_update_sarea_pos(crtc, x, y);

	return 0;
a3444 32
static bool pipe_has_enabled_pch(struct intel_crtc *crtc)
{
	return crtc->base.enabled && crtc->active &&
		crtc->config.has_pch_encoder;
}

static void ivb_modeset_global_resources(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *pipe_B_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_B]);
	struct intel_crtc *pipe_C_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_C]);
	uint32_t temp;

	/*
	 * When everything is off disable fdi C so that we could enable fdi B
	 * with all lanes. Note that we don't care about enabled pipes without
	 * an enabled pch encoder.
	 */
	if (!pipe_has_enabled_pch(pipe_B_crtc) &&
	    !pipe_has_enabled_pch(pipe_C_crtc)) {
		WARN_ON(I915_READ(FDI_RX_CTL(PIPE_B)) & FDI_RX_ENABLE);
		WARN_ON(I915_READ(FDI_RX_CTL(PIPE_C)) & FDI_RX_ENABLE);

		temp = I915_READ(SOUTH_CHICKEN1);
		temp &= ~FDI_BC_BIFURCATION_SELECT;
		DRM_DEBUG_KMS("disabling fdi C rx\n");
		I915_WRITE(SOUTH_CHICKEN1, temp);
	}
}

a3451 1
	int plane = intel_crtc->plane;
d3454 1
a3454 1
	/* FDI needs bits from pipe & plane first */
a3455 1
	assert_plane_enabled(dev_priv, plane);
d3471 1
a3471 1
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config.fdi_lanes);
d3569 1
a3569 1
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config.fdi_lanes);
d3720 1
a3720 1
		temp |= FDI_DP_PORT_WIDTH(intel_crtc->config.fdi_lanes);
d3808 1
a3808 1
	temp |= FDI_DP_PORT_WIDTH(intel_crtc->config.fdi_lanes);
d3886 1
a3886 1
	if (HAS_PCH_IBX(dev)) {
a3887 1
	}
a3913 19
static bool intel_crtc_has_pending_flip(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	unsigned long flags;
	bool pending;

	if (i915_reset_in_progress(&dev_priv->gpu_error) ||
	    intel_crtc->reset_counter != atomic_read(&dev_priv->gpu_error.reset_counter))
		return false;

	spin_lock_irqsave(&dev->event_lock, flags);
	pending = to_intel_crtc(crtc)->unpin_work != NULL;
	spin_unlock_irqrestore(&dev->event_lock, flags);

	return pending;
}

d3925 1
a3925 1
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head) {
d3938 24
a3961 1
static void intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc)
a3965 3
	if (crtc->fb == NULL)
		return;

d3967 4
d3972 7
a3978 2
	wait_event(dev_priv->pending_flip_queue,
		   !intel_crtc_has_pending_flip(crtc));
d3980 5
a3984 3
	mutex_lock(&dev->struct_mutex);
	intel_finish_fb(crtc->fb);
	mutex_unlock(&dev->struct_mutex);
d3992 1
a3992 1
	int clock = to_intel_crtc(crtc)->config.adjusted_mode.crtc_clock;
d3996 1
a3996 1
	mutex_lock(&dev_priv->dpio_lock);
d4073 1
a4073 1
	mutex_unlock(&dev_priv->dpio_lock);
d4081 1
a4081 1
	enum transcoder cpu_transcoder = crtc->config.cpu_transcoder;
d4100 1
a4100 1
static void cpt_enable_fdi_bc_bifurcation(struct drm_device *dev)
d4106 1
a4106 1
	if (temp & FDI_BC_BIFURCATION_SELECT)
d4112 5
a4116 2
	temp |= FDI_BC_BIFURCATION_SELECT;
	DRM_DEBUG_KMS("enabling fdi C rx\n");
a4123 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d4129 2
a4130 2
		if (intel_crtc->config.fdi_lanes > 2)
			WARN_ON(I915_READ(SOUTH_CHICKEN1) & FDI_BC_BIFURCATION_SELECT);
d4132 1
a4132 1
			cpt_enable_fdi_bc_bifurcation(dev);
d4136 1
a4136 1
		cpt_enable_fdi_bc_bifurcation(dev);
d4181 1
a4181 1
		if (intel_crtc->config.shared_dpll == DPLL_ID_PCH_PLL_B)
d4195 1
a4195 1
	ironlake_enable_shared_dpll(intel_crtc);
d4204 1
a4204 3
	if (HAS_PCH_CPT(dev) &&
	    (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT) ||
	     intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))) {
d4211 1
a4211 2
		temp |= (TRANS_DP_OUTPUT_ENABLE |
			 TRANS_DP_ENH_FRAMING);
d4244 1
a4244 1
	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;
d4256 2
a4257 21
static void intel_put_shared_dpll(struct intel_crtc *crtc)
{
	struct intel_shared_dpll *pll = intel_crtc_to_shared_dpll(crtc);

	if (pll == NULL)
		return;

	if (pll->refcount == 0) {
		WARN(1, "bad %s refcount\n", pll->name);
		return;
	}

	if (--pll->refcount == 0) {
		WARN_ON(pll->on);
		WARN_ON(pll->active);
	}

	crtc->config.shared_dpll = DPLL_ID_PRIVATE;
}

static struct intel_shared_dpll *intel_get_shared_dpll(struct intel_crtc *crtc)
d4260 2
a4261 1
	struct intel_shared_dpll *pll = intel_crtc_to_shared_dpll(crtc);
d4263 1
d4265 1
a4265 5
	if (pll) {
		DRM_DEBUG_KMS("CRTC:%d dropping existing %s\n",
			      crtc->base.base.id, pll->name);
		intel_put_shared_dpll(crtc);
	}
d4275 2
d4280 23
a4302 1
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
d4306 1
a4306 1
		if (pll->refcount == 0)
d4309 7
a4315 6
		if (memcmp(&crtc->config.dpll_hw_state, &pll->hw_state,
			   sizeof(pll->hw_state)) == 0) {
			DRM_DEBUG_KMS("CRTC:%d sharing existing %s (refcount %d, ative %d)\n",
				      crtc->base.base.id,
				      pll->name, pll->refcount, pll->active);

d4323 1
a4323 1
		if (pll->refcount == 0) {
d4333 5
a4337 1
	crtc->config.shared_dpll = i;
d4341 11
a4351 3
	if (pll->active == 0) {
		memcpy(&pll->hw_state, &crtc->config.dpll_hw_state,
		       sizeof(pll->hw_state));
d4353 2
a4354 3
		DRM_DEBUG_DRIVER("setting up %s\n", pll->name);
		WARN_ON(pll->on);
		assert_shared_dpll_disabled(dev_priv, pll);
d4356 4
a4359 1
		pll->mode_set(dev_priv, pll);
a4360 3
	pll->refcount++;

	return pll;
d4377 193
d4576 1
a4576 1
	if (crtc->config.pch_pfit.enabled) {
d4586 2
a4587 2
		I915_WRITE(PF_WIN_POS(pipe), crtc->config.pch_pfit.pos);
		I915_WRITE(PF_WIN_SZ(pipe), crtc->config.pch_pfit.size);
a4590 22
static void intel_enable_planes(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	enum pipe pipe = to_intel_crtc(crtc)->pipe;
	struct intel_plane *intel_plane;

	list_for_each_entry(intel_plane, &dev->mode_config.plane_list, base.head)
		if (intel_plane->pipe == pipe)
			intel_plane_restore(&intel_plane->base);
}

static void intel_disable_planes(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	enum pipe pipe = to_intel_crtc(crtc)->pipe;
	struct intel_plane *intel_plane;

	list_for_each_entry(intel_plane, &dev->mode_config.plane_list, base.head)
		if (intel_plane->pipe == pipe)
			intel_plane_disable(&intel_plane->base);
}

d4593 2
a4594 1
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
d4596 1
a4596 1
	if (!crtc->config.ips_enabled)
d4599 3
a4601 4
	/* We can only enable IPS after we enable a plane and wait for a vblank.
	 * We guarantee that the plane is enabled by calling intel_enable_ips
	 * only after intel_enable_plane. And intel_enable_plane already waits
	 * for a vblank, so all we need to do here is to enable the IPS bit. */
d4603 1
a4603 1
	if (IS_BROADWELL(crtc->base.dev)) {
d4629 1
a4629 1
	if (!crtc->config.ips_enabled)
d4633 1
a4633 1
	if (IS_BROADWELL(crtc->base.dev)) {
d4637 3
a4655 1
	int palreg = PALETTE(pipe);
d4660 1
a4660 1
	if (!crtc->enabled || !intel_crtc->active)
d4663 2
a4664 2
	if (!HAS_PCH_SPLIT(dev_priv->dev)) {
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DSI))
a4669 4
	/* use legacy palette for Ironlake */
	if (HAS_PCH_SPLIT(dev))
		palreg = LGC_PALETTE(pipe);

d4673 1
a4673 1
	if (IS_HASWELL(dev) && intel_crtc->config.ips_enabled &&
d4681 8
a4688 1
		I915_WRITE(palreg + 4 * i,
d4698 204
a4908 1
	int plane = intel_crtc->plane;
d4910 15
a4924 1
	WARN_ON(!crtc->enabled);
d4926 1
a4926 2
	if (intel_crtc->active)
		return;
d4930 2
a4931 2
	intel_set_cpu_fifo_underrun_reporting(dev, pipe, true);
	intel_set_pch_fifo_underrun_reporting(dev, pipe, true);
d4937 1
a4937 1
	if (intel_crtc->config.has_pch_encoder) {
d4956 1
a4956 5
	intel_enable_pipe(dev_priv, pipe,
			  intel_crtc->config.has_pch_encoder, false);
	intel_enable_primary_plane(dev_priv, plane, pipe);
	intel_enable_planes(crtc);
	intel_crtc_update_cursor(crtc, true);
d4958 1
a4958 1
	if (intel_crtc->config.has_pch_encoder)
d4961 2
a4962 3
	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);
a4968 10

	/*
	 * There seems to be a race in PCH platform hw (at least on some
	 * outputs) where an enabled pipe still completes any pageflip right
	 * away (as if the pipe is off) instead of waiting for vblank. As soon
	 * as the first vblank happend, everything works as expected. Hence just
	 * wait for one vblank before returning to avoid strange things
	 * happening.
	 */
	intel_wait_for_vblank(dev, intel_crtc->pipe);
d4977 1
a4977 1
static void haswell_crtc_enable_planes(struct drm_crtc *crtc)
d4982 5
a4986 2
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d4988 2
a4989 3
	intel_enable_primary_plane(dev_priv, plane, pipe);
	intel_enable_planes(crtc);
	intel_crtc_update_cursor(crtc, true);
d4991 2
a4992 1
	hsw_enable_ips(intel_crtc);
d4994 2
a4995 4
	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);
}
d4997 1
a4997 7
static void haswell_crtc_disable_planes(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d4999 4
a5002 2
	intel_crtc_wait_for_pending_flips(crtc);
	drm_vblank_off(dev, pipe);
d5004 3
a5006 32
	/* FBC must be disabled before disabling the plane on HSW. */
	if (dev_priv->fbc.plane == plane)
		intel_disable_fbc(dev);

	hsw_disable_ips(intel_crtc);

	intel_crtc_update_cursor(crtc, false);
	intel_disable_planes(crtc);
	intel_disable_primary_plane(dev_priv, plane, pipe);
}

/*
 * This implements the workaround described in the "notes" section of the mode
 * set sequence documentation. When going from no pipes or single pipe to
 * multiple pipes, and planes are enabled after the pipe, we need to wait at
 * least 2 vblanks on the first pipe before enabling planes on the second pipe.
 */
static void haswell_mode_set_planes_workaround(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct intel_crtc *crtc_it, *other_active_crtc = NULL;

	/* We want to get the other_active_crtc only if there's only 1 other
	 * active crtc. */
	list_for_each_entry(crtc_it, &dev->mode_config.crtc_list, base.head) {
		if (!crtc_it->active || crtc_it == crtc)
			continue;

		if (other_active_crtc)
			return;

		other_active_crtc = crtc_it;
a5007 2
	if (!other_active_crtc)
		return;
d5009 1
a5009 3
	intel_wait_for_vblank(dev, other_active_crtc->pipe);
	intel_wait_for_vblank(dev, other_active_crtc->pipe);
}
d5011 1
a5011 12
static void haswell_crtc_enable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;

	WARN_ON(!crtc->enabled);

	if (intel_crtc->active)
		return;
d5015 7
a5021 3
	intel_set_cpu_fifo_underrun_reporting(dev, pipe, true);
	if (intel_crtc->config.has_pch_encoder)
		intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_A, true);
d5023 3
a5025 1
	if (intel_crtc->config.has_pch_encoder)
d5027 1
d5029 2
a5030 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);
d5032 4
a5035 3
	intel_ddi_enable_pipe_clock(intel_crtc);

	ironlake_pfit_enable(intel_crtc);
d5044 2
a5045 1
	intel_ddi_enable_transcoder_func(crtc);
d5048 1
a5048 2
	intel_enable_pipe(dev_priv, pipe,
			  intel_crtc->config.has_pch_encoder, false);
d5050 1
a5050 1
	if (intel_crtc->config.has_pch_encoder)
d5053 6
d5066 5
a5070 12
	haswell_mode_set_planes_workaround(intel_crtc);
	haswell_crtc_enable_planes(crtc);

	/*
	 * There seems to be a race in PCH platform hw (at least on some
	 * outputs) where an enabled pipe still completes any pageflip right
	 * away (as if the pipe is off) instead of waiting for vblank. As soon
	 * as the first vblank happend, everything works as expected. Hence just
	 * wait for one vblank before returning to avoid strange things
	 * happening.
	 */
	intel_wait_for_vblank(dev, intel_crtc->pipe);
d5073 1
a5073 1
static void ironlake_pfit_disable(struct intel_crtc *crtc)
d5081 1
a5081 1
	if (crtc->config.pch_pfit.enabled) {
a5094 1
	int plane = intel_crtc->plane;
a5096 4

	if (!intel_crtc->active)
		return;

d5100 2
a5101 2
	intel_crtc_wait_for_pending_flips(crtc);
	drm_vblank_off(dev, pipe);
d5103 2
a5104 2
	if (dev_priv->fbc.plane == plane)
		intel_disable_fbc(dev);
d5106 1
a5106 3
	intel_crtc_update_cursor(crtc, false);
	intel_disable_planes(crtc);
	intel_disable_primary_plane(dev_priv, plane, pipe);
d5108 1
a5108 2
	if (intel_crtc->config.has_pch_encoder)
		intel_set_pch_fifo_underrun_reporting(dev, pipe, false);
d5110 2
a5111 3
	intel_disable_pipe(dev_priv, pipe);

	ironlake_pfit_disable(intel_crtc);
d5117 1
a5117 3
	if (intel_crtc->config.has_pch_encoder) {
		ironlake_fdi_disable(crtc);

a5134 3
		/* disable PCH DPLL */
		intel_disable_shared_dpll(intel_crtc);

a5136 7

	intel_crtc->active = false;
	intel_update_watermarks(crtc);

	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);
d5145 2
a5146 7
	int pipe = intel_crtc->pipe;
	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;

	if (!intel_crtc->active)
		return;

	haswell_crtc_disable_planes(crtc);
d5153 7
a5159 3
	if (intel_crtc->config.has_pch_encoder)
		intel_set_pch_fifo_underrun_reporting(dev, TRANSCODER_A, false);
	intel_disable_pipe(dev_priv, pipe);
d5161 2
a5162 1
	intel_ddi_disable_transcoder_func(dev_priv, cpu_transcoder);
d5164 2
a5165 1
	ironlake_pfit_disable(intel_crtc);
d5167 4
a5170 1
	intel_ddi_disable_pipe_clock(intel_crtc);
d5172 2
a5173 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_disable)
			encoder->post_disable(encoder);
d5175 1
a5175 1
	if (intel_crtc->config.has_pch_encoder) {
d5180 3
a5182 59
	intel_crtc->active = false;
	intel_update_watermarks(crtc);

	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);
}

static void ironlake_crtc_off(struct drm_crtc *crtc)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	intel_put_shared_dpll(intel_crtc);
}

static void haswell_crtc_off(struct drm_crtc *crtc)
{
	intel_ddi_put_crtc_pll(crtc);
}

static void intel_crtc_dpms_overlay(struct intel_crtc *intel_crtc, bool enable)
{
	if (!enable && intel_crtc->overlay) {
		struct drm_device *dev = intel_crtc->base.dev;
		struct drm_i915_private *dev_priv = dev->dev_private;

		mutex_lock(&dev->struct_mutex);
		dev_priv->mm.interruptible = false;
		(void) intel_overlay_switch_off(intel_crtc->overlay);
		dev_priv->mm.interruptible = true;
		mutex_unlock(&dev->struct_mutex);
	}

	/* Let userspace switch the overlay on again. In most cases userspace
	 * has to recompute where to put it anyway.
	 */
}

/**
 * i9xx_fixup_plane - ugly workaround for G45 to fire up the hardware
 * cursor plane briefly if not already running after enabling the display
 * plane.
 * This workaround avoids occasional blank screens when self refresh is
 * enabled.
 */
static void
g4x_fixup_plane(struct drm_i915_private *dev_priv, enum pipe pipe)
{
	u32 cntl = I915_READ(CURCNTR(pipe));

	if ((cntl & CURSOR_MODE) == 0) {
		u32 fw_bcl_self = I915_READ(FW_BLC_SELF);

		I915_WRITE(FW_BLC_SELF, fw_bcl_self & ~FW_BLC_SELF_EN);
		I915_WRITE(CURCNTR(pipe), CURSOR_MODE_64_ARGB_AX);
		intel_wait_for_vblank(dev_priv->dev, pipe);
		I915_WRITE(CURCNTR(pipe), cntl);
		I915_WRITE(CURBASE(pipe), I915_READ(CURBASE(pipe)));
		I915_WRITE(FW_BLC_SELF, fw_bcl_self);
	}
d5189 1
a5189 1
	struct intel_crtc_config *pipe_config = &crtc->config;
d5191 1
a5191 1
	if (!crtc->config.gmch_pfit.control)
d5209 1
a5209 1
int valleyview_get_vco(struct drm_i915_private *dev_priv)
d5211 15
a5225 9
	int hpll_freq, vco_freq[] = { 800, 1600, 2000, 2400 };

	/* Obtain SKU information */
	mutex_lock(&dev_priv->dpio_lock);
	hpll_freq = vlv_cck_read(dev_priv, CCK_FUSE_REG) &
		CCK_FUSE_HPLL_FREQ_MASK;
	mutex_unlock(&dev_priv->dpio_lock);

	return vco_freq[hpll_freq];
d5228 1
a5228 2
/* Adjust CDclk dividers to allow high res or save power if possible */
static void valleyview_set_cdclk(struct drm_device *dev, int cdclk)
d5230 15
a5244 19
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 val, cmd;

	if (cdclk >= 320) /* jump to highest voltage for 400MHz too */
		cmd = 2;
	else if (cdclk == 266)
		cmd = 1;
	else
		cmd = 0;

	mutex_lock(&dev_priv->rps.hw_lock);
	val = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);
	val &= ~DSPFREQGUAR_MASK;
	val |= (cmd << DSPFREQGUAR_SHIFT);
	vlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);
	if (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &
		      DSPFREQSTAT_MASK) == (cmd << DSPFREQSTAT_SHIFT),
		     50)) {
		DRM_ERROR("timed out waiting for CDclk change\n");
d5246 1
a5246 1
	mutex_unlock(&dev_priv->rps.hw_lock);
d5248 3
a5250 2
	if (cdclk == 400) {
		u32 divider, vco;
d5252 5
a5256 2
		vco = valleyview_get_vco(dev_priv);
		divider = ((vco << 1) / cdclk) - 1;
d5258 18
a5275 7
		mutex_lock(&dev_priv->dpio_lock);
		/* adjust cdclk divider */
		val = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);
		val &= ~0xf;
		val |= divider;
		vlv_cck_write(dev_priv, CCK_DISPLAY_CLOCK_CONTROL, val);
		mutex_unlock(&dev_priv->dpio_lock);
d5277 1
d5279 5
a5283 4
	mutex_lock(&dev_priv->dpio_lock);
	/* adjust self-refresh exit latency value */
	val = vlv_bunit_read(dev_priv, BUNIT_REG_BISOC);
	val &= ~0x7f;
d5285 22
a5306 13
	/*
	 * For high bandwidth configs, we set a higher latency in the bunit
	 * so that the core display fetch happens in time to avoid underruns.
	 */
	if (cdclk == 400)
		val |= 4500 / 250; /* 4.5 usec */
	else
		val |= 3000 / 250; /* 3.0 usec */
	vlv_bunit_write(dev_priv, BUNIT_REG_BISOC, val);
	mutex_unlock(&dev_priv->dpio_lock);

	/* Since we changed the CDclk, we need to update the GMBUSFREQ too */
	intel_i2c_reset(dev);
d5309 1
a5309 1
static int valleyview_cur_cdclk(struct drm_i915_private *dev_priv)
d5311 6
a5316 2
	int cur_cdclk, vco;
	int divider;
d5318 2
a5319 1
	vco = valleyview_get_vco(dev_priv);
d5321 1
a5321 3
	mutex_lock(&dev_priv->dpio_lock);
	divider = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);
	mutex_unlock(&dev_priv->dpio_lock);
d5323 5
a5327 1
	divider &= 0xf;
d5329 2
a5330 1
	cur_cdclk = (vco << 1) / (divider + 1);
d5332 1
a5332 1
	return cur_cdclk;
d5335 1
a5335 2
static int valleyview_calc_cdclk(struct drm_i915_private *dev_priv,
				 int max_pixclk)
d5337 7
a5343 1
	int cur_cdclk;
d5345 1
a5345 1
	cur_cdclk = valleyview_cur_cdclk(dev_priv);
d5347 4
a5350 16
	/*
	 * Really only a few cases to deal with, as only 4 CDclks are supported:
	 *   200MHz
	 *   267MHz
	 *   320MHz
	 *   400MHz
	 * So we check to see whether we're above 90% of the lower bin and
	 * adjust if needed.
	 */
	if (max_pixclk > 288000) {
		return 400;
	} else if (max_pixclk > 240000) {
		return 320;
	} else
		return 266;
	/* Looks like the 200MHz CDclk freq doesn't work on some configs */
d5353 2
a5354 3
static int intel_mode_max_pixclk(struct drm_i915_private *dev_priv,
				 unsigned modeset_pipes,
				 struct intel_crtc_config *pipe_config)
d5356 1
a5356 13
	struct drm_device *dev = dev_priv->dev;
	struct intel_crtc *intel_crtc;
	int max_pixclk = 0;

	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list,
			    base.head) {
		if (modeset_pipes & (1 << intel_crtc->pipe))
			max_pixclk = max(max_pixclk,
					 pipe_config->adjusted_mode.crtc_clock);
		else if (intel_crtc->base.enabled)
			max_pixclk = max(max_pixclk,
					 intel_crtc->config.adjusted_mode.crtc_clock);
	}
d5358 2
a5359 1
	return max_pixclk;
d5362 1
a5362 4
static void valleyview_modeset_global_pipes(struct drm_device *dev,
					    unsigned *prepare_pipes,
					    unsigned modeset_pipes,
					    struct intel_crtc_config *pipe_config)
d5364 1
d5366 13
a5378 4
	struct intel_crtc *intel_crtc;
	int max_pixclk = intel_mode_max_pixclk(dev_priv, modeset_pipes,
					       pipe_config);
	int cur_cdclk = valleyview_cur_cdclk(dev_priv);
d5380 4
a5383 2
	if (valleyview_calc_cdclk(dev_priv, max_pixclk) == cur_cdclk)
		return;
d5385 3
a5387 4
	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list,
			    base.head)
		if (intel_crtc->base.enabled)
			*prepare_pipes |= (1 << intel_crtc->pipe);
d5390 1
a5390 1
static void valleyview_modeset_global_resources(struct drm_device *dev)
d5392 1
a5392 4
	struct drm_i915_private *dev_priv = dev->dev_private;
	int max_pixclk = intel_mode_max_pixclk(dev_priv, 0, NULL);
	int cur_cdclk = valleyview_cur_cdclk(dev_priv);
	int req_cdclk = valleyview_calc_cdclk(dev_priv, max_pixclk);
d5394 9
a5402 2
	if (req_cdclk != cur_cdclk)
		valleyview_set_cdclk(dev, req_cdclk);
d5405 1
a5405 1
static void valleyview_crtc_enable(struct drm_crtc *crtc)
a5406 1
	struct drm_device *dev = crtc->dev;
a5407 5
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
	bool is_dsi;
d5409 2
a5410 1
	WARN_ON(!crtc->enabled);
d5412 31
a5442 4
	if (intel_crtc->active)
		return;

	intel_crtc->active = true;
d5444 1
a5444 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_pll_enable)
			encoder->pre_pll_enable(encoder);
d5446 2
a5447 1
	is_dsi = intel_pipe_has_type(crtc, INTEL_OUTPUT_DSI);
d5449 3
a5451 2
	if (!is_dsi)
		vlv_enable_pll(intel_crtc);
d5453 3
a5455 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);
d5457 3
a5459 1
	i9xx_pfit_enable(intel_crtc);
d5461 13
a5473 9
	intel_crtc_load_lut(crtc);

	intel_update_watermarks(crtc);
	intel_enable_pipe(dev_priv, pipe, false, is_dsi);
	intel_enable_primary_plane(dev_priv, plane, pipe);
	intel_enable_planes(crtc);
	intel_crtc_update_cursor(crtc, true);

	intel_update_fbc(dev);
d5475 2
a5476 2
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
d5479 1
a5479 1
static void i9xx_crtc_enable(struct drm_crtc *crtc)
a5480 1
	struct drm_device *dev = crtc->dev;
d5482 4
a5485 4
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d5487 32
a5518 1
	WARN_ON(!crtc->enabled);
a5519 1
	if (intel_crtc->active)
d5521 1
d5523 5
a5527 1
	intel_crtc->active = true;
d5529 5
a5533 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);
d5535 3
a5537 1
	i9xx_enable_pll(intel_crtc);
d5539 14
a5552 1
	i9xx_pfit_enable(intel_crtc);
d5554 2
a5555 1
	intel_crtc_load_lut(crtc);
d5557 4
a5560 8
	intel_update_watermarks(crtc);
	intel_enable_pipe(dev_priv, pipe, false, false);
	intel_enable_primary_plane(dev_priv, plane, pipe);
	intel_enable_planes(crtc);
	/* The fixup needs to happen before cursor is enabled */
	if (IS_G4X(dev))
		g4x_fixup_plane(dev_priv, pipe);
	intel_crtc_update_cursor(crtc, true);
d5562 4
a5565 2
	/* Give the overlay scaler a chance to enable if it's on this pipe */
	intel_crtc_dpms_overlay(intel_crtc, true);
d5567 16
a5582 1
	intel_update_fbc(dev);
d5584 4
a5587 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
}
d5589 3
a5591 6
static void i9xx_pfit_disable(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!crtc->config.gmch_pfit.control)
d5593 1
d5595 1
a5595 5
	assert_pipe_disabled(dev_priv, crtc->pipe);

	DRM_DEBUG_DRIVER("disabling pfit, current: 0x%08x\n",
			 I915_READ(PFIT_CONTROL));
	I915_WRITE(PFIT_CONTROL, 0);
d5598 1
a5598 1
static void i9xx_crtc_disable(struct drm_crtc *crtc)
a5599 1
	struct drm_device *dev = crtc->dev;
d5601 14
a5614 4
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d5616 3
a5618 1
	if (!intel_crtc->active)
d5620 1
d5622 8
a5629 2
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->disable(encoder);
d5631 2
a5632 3
	/* Give the overlay scaler a chance to disable if it's on this pipe */
	intel_crtc_wait_for_pending_flips(crtc);
	drm_vblank_off(dev, pipe);
d5634 1
a5634 2
	if (dev_priv->fbc.plane == plane)
		intel_disable_fbc(dev);
d5636 3
a5638 4
	intel_crtc_dpms_overlay(intel_crtc, false);
	intel_crtc_update_cursor(crtc, false);
	intel_disable_planes(crtc);
	intel_disable_primary_plane(dev_priv, plane, pipe);
d5640 3
a5642 1
	intel_disable_pipe(dev_priv, pipe);
d5644 2
a5645 1
	i9xx_pfit_disable(intel_crtc);
d5647 1
a5647 3
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->post_disable)
			encoder->post_disable(encoder);
d5649 2
a5650 4
	if (IS_VALLEYVIEW(dev) && !intel_pipe_has_type(crtc, INTEL_OUTPUT_DSI))
		vlv_disable_pll(dev_priv, pipe);
	else if (!IS_VALLEYVIEW(dev))
		i9xx_disable_pll(dev_priv, pipe);
d5652 2
a5653 2
	intel_crtc->active = false;
	intel_update_watermarks(crtc);
d5655 1
a5655 1
	intel_update_fbc(dev);
d5658 14
a5671 1
static void i9xx_crtc_off(struct drm_crtc *crtc)
d5673 1
d5676 1
a5676 2
static void intel_crtc_update_sarea(struct drm_crtc *crtc,
				    bool enabled)
d5678 1
a5678 5
#if 0
	struct drm_device *dev = crtc->dev;
	struct drm_i915_master_private *master_priv;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
d5680 2
a5681 2
	if (!dev->primary->master)
		return;
d5683 3
a5685 3
	master_priv = dev->primary->master->driver_priv;
	if (!master_priv->sarea_priv)
		return;
d5687 1
a5687 14
	switch (pipe) {
	case 0:
		master_priv->sarea_priv->pipeA_w = enabled ? crtc->mode.hdisplay : 0;
		master_priv->sarea_priv->pipeA_h = enabled ? crtc->mode.vdisplay : 0;
		break;
	case 1:
		master_priv->sarea_priv->pipeB_w = enabled ? crtc->mode.hdisplay : 0;
		master_priv->sarea_priv->pipeB_h = enabled ? crtc->mode.vdisplay : 0;
		break;
	default:
		DRM_ERROR("Can't update pipe %c in SAREA\n", pipe_name(pipe));
		break;
	}
#endif
d5690 2
a5691 4
/**
 * Sets the power management mode of the pipe and plane.
 */
void intel_crtc_update_dpms(struct drm_crtc *crtc)
d5693 2
a5694 4
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *intel_encoder;
	bool enable = false;
d5696 4
a5699 2
	for_each_encoder_on_crtc(dev, crtc, intel_encoder)
		enable |= intel_encoder->connectors_active;
d5701 2
a5702 2
	if (enable)
		dev_priv->display.crtc_enable(crtc);
d5704 3
a5706 1
		dev_priv->display.crtc_disable(crtc);
d5708 2
a5709 2
	intel_crtc_update_sarea(crtc, enable);
}
d5711 20
a5730 6
static void intel_crtc_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_connector *connector;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
d5732 2
a5733 2
	/* crtc should still be enabled when we disable it. */
	WARN_ON(!crtc->enabled);
d5735 1
a5735 8
	dev_priv->display.crtc_disable(crtc);
	intel_crtc->eld_vld = false;
	intel_crtc_update_sarea(crtc, false);
	dev_priv->display.off(crtc);

	assert_plane_disabled(dev->dev_private, to_intel_crtc(crtc)->plane);
	assert_cursor_disabled(dev_priv, to_intel_crtc(crtc)->pipe);
	assert_pipe_disabled(dev->dev_private, to_intel_crtc(crtc)->pipe);
d5737 3
a5739 6
	if (crtc->fb) {
		mutex_lock(&dev->struct_mutex);
		intel_unpin_fb_obj(to_intel_framebuffer(crtc->fb)->obj);
		mutex_unlock(&dev->struct_mutex);
		crtc->fb = NULL;
	}
d5741 4
a5744 4
	/* Update computed state. */
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder || !connector->encoder->crtc)
			continue;
d5746 5
a5750 2
		if (connector->encoder->crtc != crtc)
			continue;
d5752 1
a5752 3
		connector->dpms = DRM_MODE_DPMS_OFF;
		to_intel_encoder(connector->encoder)->connectors_active = false;
	}
d5755 1
a5755 1
void intel_encoder_destroy(struct drm_encoder *encoder)
d5757 7
a5763 1
	struct intel_encoder *intel_encoder = to_intel_encoder(encoder);
d5765 1
a5765 2
	drm_encoder_cleanup(encoder);
	kfree(intel_encoder);
d5768 1
a5768 4
/* Simple dpms helper for encoders with just one connector, no cloning and only
 * one kind of off state. It clamps all !ON modes to fully OFF and changes the
 * state of the entire output pipe. */
static void intel_encoder_dpms(struct intel_encoder *encoder, int mode)
d5770 4
a5773 2
	if (mode == DRM_MODE_DPMS_ON) {
		encoder->connectors_active = true;
d5775 4
a5778 3
		intel_crtc_update_dpms(encoder->base.crtc);
	} else {
		encoder->connectors_active = false;
d5780 22
a5801 1
		intel_crtc_update_dpms(encoder->base.crtc);
d5803 10
d5815 1
a5815 3
/* Cross check the actual hw state with our own modeset state tracking (and it's
 * internal consistency). */
static void intel_connector_check_state(struct intel_connector *connector)
d5817 3
a5819 5
	if (connector->get_hw_state(connector)) {
		struct intel_encoder *encoder = connector->encoder;
		struct drm_crtc *crtc;
		bool encoder_enabled;
		enum pipe pipe;
d5821 1
a5821 3
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
			      connector->base.base.id,
			      drm_get_connector_name(&connector->base));
d5823 2
a5824 11
		WARN(connector->base.dpms == DRM_MODE_DPMS_OFF,
		     "wrong connector dpms state\n");
		WARN(connector->base.encoder != &encoder->base,
		     "active connector not linked to encoder\n");
		WARN(!encoder->connectors_active,
		     "encoder->connectors_active not set\n");

		encoder_enabled = encoder->get_hw_state(encoder, &pipe);
		WARN(!encoder_enabled, "encoder not enabled\n");
		if (WARN_ON(!encoder->base.crtc))
			return;
d5826 10
a5835 1
		crtc = encoder->base.crtc;
d5837 1
a5837 5
		WARN(!crtc->enabled, "crtc not enabled\n");
		WARN(!to_intel_crtc(crtc)->active, "crtc not active\n");
		WARN(pipe != to_intel_crtc(crtc)->pipe,
		     "encoder active on the wrong pipe\n");
	}
d5840 1
a5840 3
/* Even simpler default implementation, if there's really no special case to
 * consider. */
void intel_connector_dpms(struct drm_connector *connector, int mode)
d5842 2
a5843 3
	/* All the simple cases only support two dpms states. */
	if (mode != DRM_MODE_DPMS_ON)
		mode = DRM_MODE_DPMS_OFF;
d5845 6
a5850 2
	if (mode == connector->dpms)
		return;
d5852 6
a5857 1
	connector->dpms = mode;
d5859 2
a5860 3
	/* Only need to change hw state when actually enabled */
	if (connector->encoder)
		intel_encoder_dpms(to_intel_encoder(connector->encoder), mode);
d5862 3
a5864 2
	intel_modeset_check_state(connector->dev);
}
d5866 1
a5866 7
/* Simple connector->get_hw_state implementation for encoders that support only
 * one connector and no cloning and hence the encoder state determines the state
 * of the connector. */
bool intel_connector_get_hw_state(struct intel_connector *connector)
{
	enum pipe pipe = 0;
	struct intel_encoder *encoder = connector->encoder;
d5868 2
a5869 1
	return encoder->get_hw_state(encoder, &pipe);
d5872 2
a5873 2
static bool ironlake_check_fdi_lanes(struct drm_device *dev, enum pipe pipe,
				     struct intel_crtc_config *pipe_config)
d5876 4
a5879 2
	struct intel_crtc *pipe_B_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_B]);
d5881 16
a5896 6
	DRM_DEBUG_KMS("checking fdi config on pipe %c, lanes %i\n",
		      pipe_name(pipe), pipe_config->fdi_lanes);
	if (pipe_config->fdi_lanes > 4) {
		DRM_DEBUG_KMS("invalid fdi lane config on pipe %c: %i lanes\n",
			      pipe_name(pipe), pipe_config->fdi_lanes);
		return false;
d5898 8
d5907 10
a5916 8
	if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		if (pipe_config->fdi_lanes > 2) {
			DRM_DEBUG_KMS("only 2 lanes on haswell, required: %i lanes\n",
				      pipe_config->fdi_lanes);
			return false;
		} else {
			return true;
		}
d5919 614
a6532 2
	if (INTEL_INFO(dev)->num_pipes == 2)
		return true;
d6537 1
a6537 1
		return true;
d6539 10
a6548 2
		if (dev_priv->pipe_to_crtc_mapping[PIPE_C]->enabled &&
		    pipe_config->fdi_lanes > 2) {
d6551 1
a6551 1
			return false;
d6553 1
a6553 1
		return true;
d6555 13
a6567 8
		if (!pipe_has_enabled_pch(pipe_B_crtc) ||
		    pipe_B_crtc->config.fdi_lanes <= 2) {
			if (pipe_config->fdi_lanes > 2) {
				DRM_DEBUG_KMS("invalid shared fdi lane config on pipe %c: %i lanes\n",
					      pipe_name(pipe), pipe_config->fdi_lanes);
				return false;
			}
		} else {
d6569 1
a6569 1
			return false;
d6571 1
a6571 1
		return true;
d6579 1
a6579 1
				       struct intel_crtc_config *pipe_config)
d6582 3
a6584 3
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
	int lane, link_bw, fdi_dotclock;
	bool setup_ok, needs_recompute = false;
d6606 3
a6608 3
	setup_ok = ironlake_check_fdi_lanes(intel_crtc->base.dev,
					    intel_crtc->pipe, pipe_config);
	if (!setup_ok && pipe_config->pipe_bpp > 6*3) {
d6621 22
a6642 1
	return setup_ok ? 0 : -EINVAL;
d6646 1
a6646 1
				   struct intel_crtc_config *pipe_config)
d6648 6
a6653 3
	pipe_config->ips_enabled = i915_enable_ips &&
				   hsw_crtc_supports_ips(crtc) &&
				   pipe_config->pipe_bpp <= 24;
d6657 1
a6657 1
				     struct intel_crtc_config *pipe_config)
d6660 2
a6661 1
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
d6665 1
a6665 3
		struct drm_i915_private *dev_priv = dev->dev_private;
		int clock_limit =
			dev_priv->display.get_display_clock_speed(dev);
d6690 1
a6690 1
	if ((intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS) &&
d6698 1
a6698 1
		adjusted_mode->hsync_start == adjusted_mode->hdisplay)
d6701 78
a6778 6
	if ((IS_G4X(dev) || IS_VALLEYVIEW(dev)) && pipe_config->pipe_bpp > 10*3) {
		pipe_config->pipe_bpp = 10*3; /* 12bpc is gen5+ */
	} else if (INTEL_INFO(dev)->gen <= 4 && pipe_config->pipe_bpp > 8*3) {
		/* only a 8bpc pipe, with 6bpc dither through the panel fitter
		 * for lvds. */
		pipe_config->pipe_bpp = 8*3;
d6781 9
a6789 2
	if (HAS_IPS(dev))
		hsw_compute_ips_config(crtc, pipe_config);
d6791 13
a6803 4
	/* XXX: PCH clock sharing is done in ->mode_set, so make sure the old
	 * clock survives for now. */
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		pipe_config->shared_dpll = crtc->config.shared_dpll;
d6805 5
a6809 2
	if (pipe_config->has_pch_encoder)
		return ironlake_fdi_compute_config(crtc, pipe_config);
d6811 10
a6820 1
	return 0;
d6825 7
a6831 1
	return 400000; /* FIXME */
d6841 1
a6841 1
	return 333000;
d6857 1
a6857 1
		return 267000;
d6859 1
a6859 1
		return 333000;
d6861 1
a6861 1
		return 444000;
d6867 1
a6867 1
		return 133000;
d6869 1
a6869 1
		return 167000;
d6880 1
a6880 1
		return 133000;
d6884 1
a6884 1
			return 333000;
d6894 1
a6894 1
	return 266000;
d6897 1
a6897 1
static int i855_get_display_clock_speed(struct drm_device *dev)
d6900 12
d6917 1
d6923 5
a6927 1
		return 133000;
d6936 170
a7105 1
	return 133000;
d7143 2
a7144 2
	if (i915_panel_use_ssc >= 0)
		return i915_panel_use_ssc != 0;
d7149 2
a7150 1
static int i9xx_get_refclk(struct drm_crtc *crtc, int num_connectors)
d7152 1
a7152 1
	struct drm_device *dev = crtc->dev;
d7156 3
a7158 1
	if (IS_VALLEYVIEW(dev)) {
d7160 1
a7160 1
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&
d7184 1
a7187 2
	struct drm_i915_private *dev_priv = dev->dev_private;
	int pipe = crtc->pipe;
d7191 1
a7191 1
		fp = pnv_dpll_compute_fp(&crtc->config.dpll);
d7195 1
a7195 1
		fp = i9xx_dpll_compute_fp(&crtc->config.dpll);
d7200 1
a7200 2
	I915_WRITE(FP0(pipe), fp);
	crtc->config.dpll_hw_state.fp0 = fp;
d7203 3
a7205 4
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS) &&
	    reduced_clock && i915_powersave) {
		I915_WRITE(FP1(pipe), fp2);
		crtc->config.dpll_hw_state.fp1 = fp2;
d7208 1
a7208 2
		I915_WRITE(FP1(pipe), fp);
		crtc->config.dpll_hw_state.fp1 = fp;
d7255 2
a7256 1
					 struct intel_link_m_n *m_n)
d7261 1
a7261 1
	enum transcoder transcoder = crtc->config.cpu_transcoder;
d7268 12
d7288 1
a7288 1
static void intel_dp_set_m_n(struct intel_crtc *crtc)
d7290 19
a7308 2
	if (crtc->config.has_pch_encoder)
		intel_pch_transcoder_set_m_n(crtc, &crtc->config.dp_m_n);
d7310 24
a7333 1
		intel_cpu_transcoder_set_m_n(crtc, &crtc->config.dp_m_n);
d7336 2
a7337 1
static void vlv_update_pll(struct intel_crtc *crtc)
d7342 1
a7342 1
	u32 dpll, mdiv;
d7344 1
a7344 1
	u32 coreclk, reg_val, dpll_md;
d7346 1
a7346 1
	mutex_lock(&dev_priv->dpio_lock);
d7348 5
a7352 5
	bestn = crtc->config.dpll.n;
	bestm1 = crtc->config.dpll.m1;
	bestm2 = crtc->config.dpll.m2;
	bestp1 = crtc->config.dpll.p1;
	bestp2 = crtc->config.dpll.p2;
d7357 1
a7357 1
	if (pipe)
d7389 3
a7391 3
	if (crtc->config.port_clock == 162000 ||
	    intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_ANALOG) ||
	    intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_HDMI))
d7398 1
a7398 2
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_EDP) ||
	    intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_DISPLAYPORT)) {
d7400 1
a7400 1
		if (!pipe)
d7408 1
a7408 1
		if (!pipe)
d7418 2
a7419 2
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_DISPLAYPORT) ||
	    intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_EDP))
d7424 116
d7541 2
a7542 12
	/*
	 * Enable DPIO clock input. We should never disable the reference
	 * clock for pipe B, since VGA hotplug / manual detection depends
	 * on it.
	 */
	dpll = DPLL_EXT_BUFFER_ENABLE_VLV | DPLL_REFA_CLK_ENABLE_VLV |
		DPLL_VGA_MODE_DIS | DPLL_INTEGRATED_CLOCK_VLV;
	/* We should never disable this, set it here for state tracking */
	if (pipe == PIPE_B)
		dpll |= DPLL_INTEGRATED_CRI_CLK_VLV;
	dpll |= DPLL_VCO_ENABLE;
	crtc->config.dpll_hw_state.dpll = dpll;
d7544 20
a7563 3
	dpll_md = (crtc->config.pixel_multiplier - 1)
		<< DPLL_MD_UDI_MULTIPLIER_SHIFT;
	crtc->config.dpll_hw_state.dpll_md = dpll_md;
d7565 10
a7574 2
	if (crtc->config.has_dp_encoder)
		intel_dp_set_m_n(crtc);
d7576 14
a7589 1
	mutex_unlock(&dev_priv->dpio_lock);
d7592 4
a7595 3
static void i9xx_update_pll(struct intel_crtc *crtc,
			    intel_clock_t *reduced_clock,
			    int num_connectors)
d7601 1
a7601 1
	struct dpll *clock = &crtc->config.dpll;
d7603 1
a7603 1
	i9xx_update_pll_dividers(crtc, reduced_clock);
d7605 2
a7606 2
	is_sdvo = intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_SDVO) ||
		intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_HDMI);
d7610 1
a7610 1
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS))
d7616 1
a7616 1
		dpll |= (crtc->config.pixel_multiplier - 1)
d7623 1
a7623 1
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_DISPLAYPORT))
d7651 1
a7651 1
	if (crtc->config.sdvo_tv_clock)
d7653 1
a7653 1
	else if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS) &&
d7660 1
a7660 1
	crtc->config.dpll_hw_state.dpll = dpll;
d7663 1
a7663 1
		u32 dpll_md = (crtc->config.pixel_multiplier - 1)
d7665 1
a7665 1
		crtc->config.dpll_hw_state.dpll_md = dpll_md;
a7666 3

	if (crtc->config.has_dp_encoder)
		intel_dp_set_m_n(crtc);
d7669 4
a7672 3
static void i8xx_update_pll(struct intel_crtc *crtc,
			    intel_clock_t *reduced_clock,
			    int num_connectors)
d7677 1
a7677 1
	struct dpll *clock = &crtc->config.dpll;
d7679 1
a7679 1
	i9xx_update_pll_dividers(crtc, reduced_clock);
d7683 1
a7683 1
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS)) {
d7694 1
a7694 1
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_DVO))
d7697 1
a7697 1
	if (intel_pipe_has_type(&crtc->base, INTEL_OUTPUT_LVDS) &&
d7704 1
a7704 1
	crtc->config.dpll_hw_state.dpll = dpll;
d7712 4
a7715 4
	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;
	struct drm_display_mode *adjusted_mode =
		&intel_crtc->config.adjusted_mode;
	uint32_t vsyncshift, crtc_vtotal, crtc_vblank_end;
d7722 1
a7722 1
	if (!IS_GEN2(dev) && adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE) {
d7726 8
a7733 4
		vsyncshift = adjusted_mode->crtc_hsync_start
			     - adjusted_mode->crtc_htotal / 2;
	} else {
		vsyncshift = 0;
d7771 2
a7772 2
		   ((intel_crtc->config.pipe_src_w - 1) << 16) |
		   (intel_crtc->config.pipe_src_h - 1));
d7776 1
a7776 1
				   struct intel_crtc_config *pipe_config)
d7784 2
a7785 2
	pipe_config->adjusted_mode.crtc_hdisplay = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_htotal = ((tmp >> 16) & 0xffff) + 1;
d7787 2
a7788 2
	pipe_config->adjusted_mode.crtc_hblank_start = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_hblank_end = ((tmp >> 16) & 0xffff) + 1;
d7790 2
a7791 2
	pipe_config->adjusted_mode.crtc_hsync_start = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_hsync_end = ((tmp >> 16) & 0xffff) + 1;
d7794 2
a7795 2
	pipe_config->adjusted_mode.crtc_vdisplay = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_vtotal = ((tmp >> 16) & 0xffff) + 1;
d7797 2
a7798 2
	pipe_config->adjusted_mode.crtc_vblank_start = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_vblank_end = ((tmp >> 16) & 0xffff) + 1;
d7800 2
a7801 2
	pipe_config->adjusted_mode.crtc_vsync_start = (tmp & 0xffff) + 1;
	pipe_config->adjusted_mode.crtc_vsync_end = ((tmp >> 16) & 0xffff) + 1;
d7804 3
a7806 3
		pipe_config->adjusted_mode.flags |= DRM_MODE_FLAG_INTERLACE;
		pipe_config->adjusted_mode.crtc_vtotal += 1;
		pipe_config->adjusted_mode.crtc_vblank_end += 1;
d7813 2
a7814 2
	pipe_config->requested_mode.vdisplay = pipe_config->pipe_src_h;
	pipe_config->requested_mode.hdisplay = pipe_config->pipe_src_w;
d7817 2
a7818 2
static void intel_crtc_mode_from_pipe_config(struct intel_crtc *intel_crtc,
					     struct intel_crtc_config *pipe_config)
d7820 9
a7828 1
	struct drm_crtc *crtc = &intel_crtc->base;
d7830 2
a7831 9
	crtc->mode.hdisplay = pipe_config->adjusted_mode.crtc_hdisplay;
	crtc->mode.htotal = pipe_config->adjusted_mode.crtc_htotal;
	crtc->mode.hsync_start = pipe_config->adjusted_mode.crtc_hsync_start;
	crtc->mode.hsync_end = pipe_config->adjusted_mode.crtc_hsync_end;

	crtc->mode.vdisplay = pipe_config->adjusted_mode.crtc_vdisplay;
	crtc->mode.vtotal = pipe_config->adjusted_mode.crtc_vtotal;
	crtc->mode.vsync_start = pipe_config->adjusted_mode.crtc_vsync_start;
	crtc->mode.vsync_end = pipe_config->adjusted_mode.crtc_vsync_end;
d7833 2
a7834 1
	crtc->mode.flags = pipe_config->adjusted_mode.flags;
d7836 3
a7838 2
	crtc->mode.clock = pipe_config->adjusted_mode.crtc_clock;
	crtc->mode.flags |= pipe_config->adjusted_mode.flags;
d7849 3
a7851 3
	if (dev_priv->quirks & QUIRK_PIPEA_FORCE &&
	    I915_READ(PIPECONF(intel_crtc->pipe)) & PIPECONF_ENABLE)
		pipeconf |= PIPECONF_ENABLE;
d7853 1
a7853 1
	if (intel_crtc->config.double_wide)
d7859 1
a7859 1
		if (intel_crtc->config.dither && intel_crtc->config.pipe_bpp != 30)
d7863 1
a7863 1
		switch (intel_crtc->config.pipe_bpp) {
d7888 7
a7894 4
	if (!IS_GEN2(dev) &&
	    intel_crtc->config.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
		pipeconf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;
	else
d7897 1
a7897 1
	if (IS_VALLEYVIEW(dev) && intel_crtc->config.limited_color_range)
d7904 2
a7905 3
static int i9xx_crtc_mode_set(struct drm_crtc *crtc,
			      int x, int y,
			      struct drm_framebuffer *fb)
d7907 1
a7907 1
	struct drm_device *dev = crtc->dev;
a7908 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d7910 3
a7912 4
	intel_clock_t clock, reduced_clock;
	u32 dspcntr;
	bool ok, has_reduced_clock = false;
	bool is_lvds = false, is_dsi = false;
d7915 13
a7927 1
	int ret;
a7928 1
	for_each_encoder_on_crtc(dev, crtc, encoder) {
a7929 3
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
d7933 2
d7941 1
a7941 1
		goto skip_dpll;
d7943 2
a7944 2
	if (!intel_crtc->config.clock_set) {
		refclk = i9xx_get_refclk(crtc, num_connectors);
d7952 3
a7954 3
		limit = intel_limit(crtc, refclk);
		ok = dev_priv->display.find_dpll(limit, crtc,
						 intel_crtc->config.port_clock,
a7960 13
		if (is_lvds && dev_priv->lvds_downclock_avail) {
			/*
			 * Ensure we match the reduced clock's P to the target
			 * clock.  If the clocks don't match, we can't switch
			 * the display clock by using the FP0/FP1. In such case
			 * we will disable the LVDS downclock feature.
			 */
			has_reduced_clock =
				dev_priv->display.find_dpll(limit, crtc,
							    dev_priv->lvds_downclock,
							    refclk, &clock,
							    &reduced_clock);
		}
d7962 5
a7966 5
		intel_crtc->config.dpll.n = clock.n;
		intel_crtc->config.dpll.m1 = clock.m1;
		intel_crtc->config.dpll.m2 = clock.m2;
		intel_crtc->config.dpll.p1 = clock.p1;
		intel_crtc->config.dpll.p2 = clock.p2;
d7970 4
a7973 3
		i8xx_update_pll(intel_crtc,
				has_reduced_clock ? &reduced_clock : NULL,
				num_connectors);
d7975 1
a7975 1
		vlv_update_pll(intel_crtc);
d7977 2
a7978 3
		i9xx_update_pll(intel_crtc,
				has_reduced_clock ? &reduced_clock : NULL,
                                num_connectors);
d7981 1
a7981 29
skip_dpll:
	/* Set up the display plane register */
	dspcntr = DISPPLANE_GAMMA_ENABLE;

	if (!IS_VALLEYVIEW(dev)) {
		if (pipe == 0)
			dspcntr &= ~DISPPLANE_SEL_PIPE_MASK;
		else
			dspcntr |= DISPPLANE_SEL_PIPE_B;
	}

	intel_set_pipe_timings(intel_crtc);

	/* pipesrc and dspsize control the size that is scaled from,
	 * which should always be the user's requested size.
	 */
	I915_WRITE(DSPSIZE(plane),
		   ((intel_crtc->config.pipe_src_h - 1) << 16) |
		   (intel_crtc->config.pipe_src_w - 1));
	I915_WRITE(DSPPOS(plane), 0);

	i9xx_set_pipeconf(intel_crtc);

	I915_WRITE(DSPCNTR(plane), dspcntr);
	POSTING_READ(DSPCNTR(plane));

	ret = intel_pipe_set_base(crtc, x, y, fb);

	return ret;
d7985 1
a7985 1
				 struct intel_crtc_config *pipe_config)
d8005 101
a8105 1
	}
d8107 1
a8107 5
	pipe_config->gmch_pfit.control = tmp;
	pipe_config->gmch_pfit.pgm_ratios = I915_READ(PFIT_PGM_RATIOS);
	if (INTEL_INFO(dev)->gen < 5)
		pipe_config->gmch_pfit.lvds_border_bits =
			I915_READ(LVDS) & LVDS_BORDER_ENABLE;
d8110 2
a8111 2
static void vlv_crtc_clock_get(struct intel_crtc *crtc,
			       struct intel_crtc_config *pipe_config)
d8116 1
d8118 1
a8118 1
	u32 mdiv;
d8121 15
a8135 11
	mutex_lock(&dev_priv->dpio_lock);
	mdiv = vlv_dpio_read(dev_priv, pipe, VLV_PLL_DW3(pipe));
	mutex_unlock(&dev_priv->dpio_lock);

	clock.m1 = (mdiv >> DPIO_M1DIV_SHIFT) & 7;
	clock.m2 = mdiv & DPIO_M2DIV_MASK;
	clock.n = (mdiv >> DPIO_N_SHIFT) & 0xf;
	clock.p1 = (mdiv >> DPIO_P1_SHIFT) & 7;
	clock.p2 = (mdiv >> DPIO_P2_SHIFT) & 0x1f;

	vlv_clock(refclk, &clock);
d8137 1
a8137 2
	/* clock.dot is the fast clock */
	pipe_config->port_clock = clock.dot / 5;
d8141 1
a8141 1
				 struct intel_crtc_config *pipe_config)
d8147 4
d8174 3
d8203 8
d8220 3
a8222 1
	if (IS_VALLEYVIEW(dev))
d8227 8
a8240 1
	struct drm_mode_config *mode_config = &dev->mode_config;
d8242 1
d8249 1
d8252 1
a8252 2
	list_for_each_entry(encoder, &mode_config->encoder_list,
			    base.head) {
d8263 2
d8276 16
a8291 2
	DRM_DEBUG_KMS("has_panel %d has_lvds %d has_ck505 %d\n",
		      has_panel, has_lvds, has_ck505);
d8328 3
a8330 3
	} else {
		final |= DREF_SSC_SOURCE_DISABLE;
		final |= DREF_CPU_SOURCE_OUTPUT_DISABLE;
d8367 1
a8367 2
			}
			else
d8376 1
a8376 1
		DRM_DEBUG_KMS("Disabling SSC entirely\n");
d8387 6
a8392 3
		/* Turn off the SSC source */
		val &= ~DREF_SSC_SOURCE_MASK;
		val |= DREF_SSC_SOURCE_DISABLE;
d8394 2
a8395 2
		/* Turn off SSC1 */
		val &= ~DREF_SSC1_ENABLE;
d8397 4
a8400 3
		I915_WRITE(PCH_DREF_CONTROL, val);
		POSTING_READ(PCH_DREF_CONTROL);
		udelay(200);
d8516 1
a8516 2
	if (WARN(dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE &&
		 with_fdi, "LP PCH doesn't have FDI\n"))
d8519 1
a8519 1
	mutex_lock(&dev_priv->dpio_lock);
d8539 1
a8539 2
	reg = (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) ?
	       SBI_GEN0 : SBI_DBUFF0;
d8544 1
a8544 1
	mutex_unlock(&dev_priv->dpio_lock);
d8553 1
a8553 1
	mutex_lock(&dev_priv->dpio_lock);
d8555 1
a8555 2
	reg = (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) ?
	       SBI_GEN0 : SBI_DBUFF0;
d8571 1
a8571 1
	mutex_unlock(&dev_priv->dpio_lock);
a8575 1
	struct drm_mode_config *mode_config = &dev->mode_config;
d8579 1
a8579 1
	list_for_each_entry(encoder, &mode_config->encoder_list, base.head) {
d8584 2
d8606 1
a8606 1
static int ironlake_get_refclk(struct drm_crtc *crtc)
d8608 1
a8608 1
	struct drm_device *dev = crtc->dev;
d8610 3
d8614 1
a8614 1
	int num_connectors = 0;
d8617 6
a8622 1
	for_each_encoder_on_crtc(dev, crtc, encoder) {
d8627 2
d8651 1
a8651 1
	switch (intel_crtc->config.pipe_bpp) {
d8669 1
a8669 1
	if (intel_crtc->config.dither)
d8672 1
a8672 1
	if (intel_crtc->config.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
d8677 1
a8677 1
	if (intel_crtc->config.limited_color_range)
d8706 1
a8706 1
	if (intel_crtc->config.limited_color_range)
d8730 1
a8730 1
		if (intel_crtc->config.limited_color_range)
d8741 1
a8741 1
		if (intel_crtc->config.limited_color_range)
d8754 1
a8754 1
	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;
d8759 1
a8759 1
	if (IS_HASWELL(dev) && intel_crtc->config.dither)
d8762 1
a8762 1
	if (intel_crtc->config.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
d8773 1
a8773 1
	if (IS_BROADWELL(dev)) {
d8776 1
a8776 1
		switch (intel_crtc->config.pipe_bpp) {
d8794 1
a8794 1
		if (intel_crtc->config.dither)
d8802 1
a8808 1
	struct intel_encoder *intel_encoder;
d8811 1
a8811 9
	bool ret, is_lvds = false;

	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		switch (intel_encoder->type) {
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
		}
	}
d8813 1
a8813 1
	refclk = ironlake_get_refclk(crtc);
d8820 3
a8822 3
	limit = intel_limit(crtc, refclk);
	ret = dev_priv->display.find_dpll(limit, crtc,
					  to_intel_crtc(crtc)->config.port_clock,
a8826 14
	if (is_lvds && dev_priv->lvds_downclock_avail) {
		/*
		 * Ensure we match the reduced clock's P to the target clock.
		 * If the clocks don't match, we can't switch the display clock
		 * by using the FP0/FP1. In such case we will disable the LVDS
		 * downclock feature.
		*/
		*has_reduced_clock =
			dev_priv->display.find_dpll(limit, crtc,
						    dev_priv->lvds_downclock,
						    refclk, clock,
						    reduced_clock);
	}

d8838 1
a8838 1
	return bps / (link_bw * 8) + 1;
d8847 1
d8854 4
a8857 1
	struct intel_encoder *intel_encoder;
d8859 1
a8859 1
	int factor, num_connectors = 0;
d8862 7
a8868 2
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		switch (intel_encoder->type) {
d8876 2
d8890 1
a8890 1
	} else if (intel_crtc->config.sdvo_tv_clock)
d8893 1
a8893 1
	if (ironlake_needs_fb_cb_tune(&intel_crtc->config.dpll, factor))
d8906 1
a8906 1
	dpll |= (intel_crtc->config.pixel_multiplier - 1)
d8911 1
a8911 1
	if (intel_crtc->config.has_dp_encoder)
d8915 1
a8915 1
	dpll |= (1 << (intel_crtc->config.dpll.p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
d8917 1
a8917 1
	dpll |= (1 << (intel_crtc->config.dpll.p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;
d8919 1
a8919 1
	switch (intel_crtc->config.dpll.p2) {
d8942 2
a8943 3
static int ironlake_crtc_mode_set(struct drm_crtc *crtc,
				  int x, int y,
				  struct drm_framebuffer *fb)
d8945 1
a8945 8
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
#ifdef DRMDEBUG
	int pipe = intel_crtc->pipe;
#endif
	int plane = intel_crtc->plane;
	int num_connectors = 0;
a8949 1
	struct intel_encoder *encoder;
a8950 1
	int ret;
d8952 2
a8953 6
	for_each_encoder_on_crtc(dev, crtc, encoder) {
		switch (encoder->type) {
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
		}
d8955 1
a8955 2
		num_connectors++;
	}
d8960 1
a8960 1
	ok = ironlake_compute_clocks(crtc, &clock,
d8962 1
a8962 1
	if (!ok && !intel_crtc->config.clock_set) {
d8967 6
a8972 6
	if (!intel_crtc->config.clock_set) {
		intel_crtc->config.dpll.n = clock.n;
		intel_crtc->config.dpll.m1 = clock.m1;
		intel_crtc->config.dpll.m2 = clock.m2;
		intel_crtc->config.dpll.p1 = clock.p1;
		intel_crtc->config.dpll.p2 = clock.p2;
d8976 2
a8977 2
	if (intel_crtc->config.has_pch_encoder) {
		fp = i9xx_dpll_compute_fp(&intel_crtc->config.dpll);
d8981 1
a8981 1
		dpll = ironlake_compute_dpll(intel_crtc,
d8985 2
a8986 2
		intel_crtc->config.dpll_hw_state.dpll = dpll;
		intel_crtc->config.dpll_hw_state.fp0 = fp;
d8988 1
a8988 1
			intel_crtc->config.dpll_hw_state.fp1 = fp2;
d8990 1
a8990 1
			intel_crtc->config.dpll_hw_state.fp1 = fp;
d8992 1
a8992 1
		pll = intel_get_shared_dpll(intel_crtc);
d8995 1
a8995 1
					 pipe_name(pipe));
d8998 1
a8998 2
	} else
		intel_put_shared_dpll(intel_crtc);
d9000 2
a9001 5
	if (intel_crtc->config.has_dp_encoder)
		intel_dp_set_m_n(intel_crtc);

	if (is_lvds && has_reduced_clock && i915_powersave)
		intel_crtc->lowfreq_avail = true;
d9003 1
a9003 1
		intel_crtc->lowfreq_avail = false;
d9005 1
a9005 16
	intel_set_pipe_timings(intel_crtc);

	if (intel_crtc->config.has_pch_encoder) {
		intel_cpu_transcoder_set_m_n(intel_crtc,
					     &intel_crtc->config.fdi_m_n);
	}

	ironlake_set_pipeconf(crtc);

	/* Set up the display plane register */
	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
	POSTING_READ(DSPCNTR(plane));

	ret = intel_pipe_set_base(crtc, x, y, fb);

	return ret;
d9026 2
a9027 1
					 struct intel_link_m_n *m_n)
d9041 14
d9067 1
a9067 1
		      struct intel_crtc_config *pipe_config)
d9069 1
a9069 1
	if (crtc->config.has_pch_encoder)
d9073 2
a9074 1
					     &pipe_config->dp_m_n);
d9078 1
a9078 1
					struct intel_crtc_config *pipe_config)
d9081 115
a9195 1
				     &pipe_config->fdi_m_n);
d9199 1
a9199 1
				     struct intel_crtc_config *pipe_config)
d9222 69
d9292 1
a9292 1
				     struct intel_crtc_config *pipe_config)
d9298 4
d9326 3
a9375 1
	struct intel_ddi_plls *plls = &dev_priv->ddi_plls;
a9376 2
	unsigned long irqflags;
	uint32_t val;
d9378 2
a9379 2
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)
		WARN(crtc->active, "CRTC for pipe %c enabled\n",
d9382 6
a9387 6
	WARN(I915_READ(HSW_PWR_WELL_DRIVER), "Power well on\n");
	WARN(plls->spll_refcount, "SPLL enabled\n");
	WARN(plls->wrpll1_refcount, "WRPLL1 enabled\n");
	WARN(plls->wrpll2_refcount, "WRPLL2 enabled\n");
	WARN(I915_READ(PCH_PP_STATUS) & PP_ON, "Panel power on\n");
	WARN(I915_READ(BLC_PWM_CPU_CTL2) & BLM_PWM_ENABLE,
d9389 4
a9392 3
	WARN(I915_READ(HSW_BLC_PWM2_CTL) & BLM_PWM_ENABLE,
	     "CPU PWM2 enabled\n");
	WARN(I915_READ(BLC_PWM_PCH_CTL1) & BLM_PCH_PWM_ENABLE,
d9394 1
a9394 1
	WARN(I915_READ(UTIL_PIN_CTL) & UTIL_PIN_ENABLE,
d9396 24
a9419 1
	WARN(I915_READ(PCH_GTC_CTL) & PCH_GTC_ENABLE, "PCH GTC enabled\n");
d9421 10
a9430 8
	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
	val = I915_READ(DEIMR);
	WARN((val | DE_PCH_EVENT_IVB) != 0xffffffff,
	     "Unexpected DEIMR bits enabled: 0x%x\n", val);
	val = I915_READ(SDEIMR);
	WARN((val | SDE_HOTPLUG_MASK_CPT) != 0xffffffff,
	     "Unexpected SDEIMR bits enabled: 0x%x\n", val);
	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
d9468 1
a9468 1
	val = I915_READ(D_COMP);
d9470 1
a9470 5
	mutex_lock(&dev_priv->rps.hw_lock);
	if (sandybridge_pcode_write(dev_priv, GEN6_PCODE_WRITE_D_COMP, val))
		DRM_ERROR("Failed to disable D_COMP\n");
	mutex_unlock(&dev_priv->rps.hw_lock);
	POSTING_READ(D_COMP);
d9473 2
a9474 1
	if (wait_for((I915_READ(D_COMP) & D_COMP_RCOMP_IN_PROGRESS) == 0, 1))
d9499 5
a9503 3
	/* Make sure we're not on PC8 state before disabling PC8, otherwise
	 * we'll hang the machine! */
	gen6_gt_force_wake_get(dev_priv, FORCEWAKE_ALL);
d9511 1
a9511 1
	val = I915_READ(D_COMP);
d9514 1
a9514 5
	mutex_lock(&dev_priv->rps.hw_lock);
	if (sandybridge_pcode_write(dev_priv, GEN6_PCODE_WRITE_D_COMP, val))
		DRM_ERROR("Failed to enable D_COMP\n");
	mutex_unlock(&dev_priv->rps.hw_lock);
	POSTING_READ(D_COMP);
d9533 2
a9534 1
	gen6_gt_force_wake_put(dev_priv, FORCEWAKE_ALL);
d9537 24
a9560 1
void hsw_enable_pc8_work(struct work_struct *__work)
a9561 3
	struct drm_i915_private *dev_priv =
		container_of(to_delayed_work(__work), struct drm_i915_private,
			     pc8.enable_work);
a9564 5
	WARN_ON(!HAS_PC8(dev));

	if (dev_priv->pc8.enabled)
		return;

d9567 1
a9567 3
	dev_priv->pc8.enabled = true;

	if (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
a9573 1
	hsw_pc8_disable_interrupts(dev);
a9574 16

	intel_runtime_pm_put(dev_priv);
}

static void __hsw_enable_package_c8(struct drm_i915_private *dev_priv)
{
	WARN_ON(!mutex_is_locked(&dev_priv->pc8.lock));
	WARN(dev_priv->pc8.disable_count < 1,
	     "pc8.disable_count: %d\n", dev_priv->pc8.disable_count);

	dev_priv->pc8.disable_count--;
	if (dev_priv->pc8.disable_count != 0)
		return;

	schedule_delayed_work(&dev_priv->pc8.enable_work,
			      msecs_to_jiffies(i915_pc8_timeout));
d9577 1
a9577 1
static void __hsw_disable_package_c8(struct drm_i915_private *dev_priv)
a9581 14
	WARN_ON(!mutex_is_locked(&dev_priv->pc8.lock));
	WARN(dev_priv->pc8.disable_count < 0,
	     "pc8.disable_count: %d\n", dev_priv->pc8.disable_count);

	dev_priv->pc8.disable_count++;
	if (dev_priv->pc8.disable_count != 1)
		return;

	WARN_ON(!HAS_PC8(dev));

	cancel_delayed_work_sync(&dev_priv->pc8.enable_work);
	if (!dev_priv->pc8.enabled)
		return;

a9583 2
	intel_runtime_pm_get(dev_priv);

a9584 1
	hsw_pc8_restore_interrupts(dev);
d9587 1
a9587 1
	if (dev_priv->pch_id == INTEL_PCH_LPT_LP_DEVICE_ID_TYPE) {
a9593 5
	i915_gem_init_swizzling(dev);
	mutex_lock(&dev_priv->rps.hw_lock);
	gen6_update_ring_freq(dev);
	mutex_unlock(&dev_priv->rps.hw_lock);
	dev_priv->pc8.enabled = false;
d9596 1
a9596 1
void hsw_enable_package_c8(struct drm_i915_private *dev_priv)
d9598 2
a9599 2
	if (!HAS_PC8(dev_priv->dev))
		return;
d9601 1
a9601 3
	mutex_lock(&dev_priv->pc8.lock);
	__hsw_enable_package_c8(dev_priv);
	mutex_unlock(&dev_priv->pc8.lock);
d9604 13
a9616 4
void hsw_disable_package_c8(struct drm_i915_private *dev_priv)
{
	if (!HAS_PC8(dev_priv->dev))
		return;
d9618 2
a9619 4
	mutex_lock(&dev_priv->pc8.lock);
	__hsw_disable_package_c8(dev_priv);
	mutex_unlock(&dev_priv->pc8.lock);
}
d9621 1
a9621 5
static bool hsw_can_enable_package_c8(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	struct intel_crtc *crtc;
	uint32_t val;
d9623 3
a9625 3
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head)
		if (crtc->base.enabled)
			return false;
d9627 1
a9627 7
	/* This case is still possible since we have the i915.disable_power_well
	 * parameter and also the KVMr or something else might be requesting the
	 * power well. */
	val = I915_READ(HSW_PWR_WELL_DRIVER);
	if (val != 0) {
		DRM_DEBUG_KMS("Not enabling PC8: power well on\n");
		return false;
d9630 1
a9630 1
	return true;
d9633 1
a9633 6
/* Since we're called from modeset_global_resources there's no way to
 * symmetrically increase and decrease the refcount, so we use
 * dev_priv->pc8.requirements_met to track whether we already have the refcount
 * or not.
 */
static void hsw_update_package_c8(struct drm_device *dev)
d9636 2
a9637 1
	bool allow;
d9639 6
a9644 1
	if (!HAS_PC8(dev_priv->dev))
d9647 6
a9652 1
	if (!i915_enable_pc8)
d9654 5
d9660 3
a9662 1
	mutex_lock(&dev_priv->pc8.lock);
d9664 2
a9665 1
	allow = hsw_can_enable_package_c8(dev_priv);
d9667 21
a9687 2
	if (allow == dev_priv->pc8.requirements_met)
		goto done;
d9689 1
a9689 1
	dev_priv->pc8.requirements_met = allow;
d9691 3
a9693 4
	if (allow)
		__hsw_enable_package_c8(dev_priv);
	else
		__hsw_disable_package_c8(dev_priv);
d9695 3
a9697 3
done:
	mutex_unlock(&dev_priv->pc8.lock);
}
d9699 3
a9701 4
static void hsw_package_c8_gpu_idle(struct drm_i915_private *dev_priv)
{
	if (!HAS_PC8(dev_priv->dev))
		return;
d9703 1
a9703 7
	mutex_lock(&dev_priv->pc8.lock);
	if (!dev_priv->pc8.gpu_idle) {
		dev_priv->pc8.gpu_idle = true;
		__hsw_enable_package_c8(dev_priv);
	}
	mutex_unlock(&dev_priv->pc8.lock);
}
d9705 1
a9705 4
static void hsw_package_c8_gpu_busy(struct drm_i915_private *dev_priv)
{
	if (!HAS_PC8(dev_priv->dev))
		return;
d9707 3
a9709 6
	mutex_lock(&dev_priv->pc8.lock);
	if (dev_priv->pc8.gpu_idle) {
		dev_priv->pc8.gpu_idle = false;
		__hsw_disable_package_c8(dev_priv);
	}
	mutex_unlock(&dev_priv->pc8.lock);
d9712 5
a9716 3
#define for_each_power_domain(domain, mask)				\
	for ((domain) = 0; (domain) < POWER_DOMAIN_NUM; (domain)++)	\
		if ((1 << (domain)) & (mask))
d9718 12
a9729 5
static unsigned long get_pipe_power_domains(struct drm_device *dev,
					    enum pipe pipe, bool pfit_enabled)
{
	unsigned long mask;
	enum transcoder transcoder;
d9731 9
a9739 1
	transcoder = intel_pipe_to_cpu_transcoder(dev->dev_private, pipe);
d9741 1
a9741 4
	mask = BIT(POWER_DOMAIN_PIPE(pipe));
	mask |= BIT(POWER_DOMAIN_TRANSCODER(transcoder));
	if (pfit_enabled)
		mask |= BIT(POWER_DOMAIN_PIPE_PANEL_FITTER(pipe));
d9743 1
a9743 1
	return mask;
d9746 1
a9746 1
void intel_display_set_init_power(struct drm_device *dev, bool enable)
d9748 2
a9749 9
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev_priv->power_domains.init_power_on == enable)
		return;

	if (enable)
		intel_display_power_get(dev, POWER_DOMAIN_INIT);
	else
		intel_display_power_put(dev, POWER_DOMAIN_INIT);
d9751 1
a9751 1
	dev_priv->power_domains.init_power_on = enable;
d9754 2
a9755 1
static void modeset_update_power_wells(struct drm_device *dev)
d9757 2
a9758 2
	unsigned long pipe_domains[I915_MAX_PIPES] = { 0, };
	struct intel_crtc *crtc;
d9760 1
a9760 6
	/*
	 * First get all needed power domains, then put all unneeded, to avoid
	 * any unnecessary toggling of the power wells.
	 */
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head) {
		enum intel_display_power_domain domain;
d9762 2
a9763 2
		if (!crtc->base.enabled)
			continue;
d9765 19
a9783 6
		pipe_domains[crtc->pipe] = get_pipe_power_domains(dev,
						crtc->pipe,
						crtc->config.pch_pfit.enabled);

		for_each_power_domain(domain, pipe_domains[crtc->pipe])
			intel_display_power_get(dev, domain);
d9785 1
d9787 5
a9791 2
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head) {
		enum intel_display_power_domain domain;
d9793 2
a9794 2
		for_each_power_domain(domain, crtc->enabled_power_domains)
			intel_display_power_put(dev, domain);
d9796 19
a9814 1
		crtc->enabled_power_domains = pipe_domains[crtc->pipe];
a9815 2

	intel_display_set_init_power(dev, false);
d9818 3
a9820 1
static void haswell_modeset_global_resources(struct drm_device *dev)
d9822 12
a9833 2
	modeset_update_power_wells(dev);
	hsw_update_package_c8(dev);
d9836 2
a9837 3
static int haswell_crtc_mode_set(struct drm_crtc *crtc,
				 int x, int y,
				 struct drm_framebuffer *fb)
d9839 1
a9839 1
	struct drm_device *dev = crtc->dev;
d9841 3
a9843 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int plane = intel_crtc->plane;
	int ret;
d9845 1
a9845 3
	if (!intel_ddi_pll_select(intel_crtc))
		return -EINVAL;
	intel_ddi_pll_enable(intel_crtc);
d9847 1
a9847 2
	if (intel_crtc->config.has_dp_encoder)
		intel_dp_set_m_n(intel_crtc);
d9849 6
a9854 1
	intel_crtc->lowfreq_avail = false;
d9856 2
a9857 1
	intel_set_pipe_timings(intel_crtc);
d9859 2
a9860 3
	if (intel_crtc->config.has_pch_encoder) {
		intel_cpu_transcoder_set_m_n(intel_crtc,
					     &intel_crtc->config.fdi_m_n);
d9863 8
a9870 1
	haswell_set_pipeconf(crtc);
d9872 3
a9874 1
	intel_set_pipe_csc(crtc);
d9876 2
a9877 7
	/* Set up the display plane register */
	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE | DISPPLANE_PIPE_CSC_ENABLE);
	POSTING_READ(DSPCNTR(plane));

	ret = intel_pipe_set_base(crtc, x, y, fb);

	return ret;
d9881 1
a9881 1
				    struct intel_crtc_config *pipe_config)
d9888 4
d9917 1
a9917 1
	if (!intel_display_power_enabled(dev,
d9925 1
a9925 9
	/*
	 * Haswell has only FDI/PCH transcoder A. It is which is connected to
	 * DDI E. So just check whether this pipe is wired to DDI E and whether
	 * the PCH transcoder is on.
	 */
	tmp = I915_READ(TRANS_DDI_FUNC_CTL(pipe_config->cpu_transcoder));
	if ((tmp & TRANS_DDI_PORT_MASK) == TRANS_DDI_SELECT_PORT(PORT_E) &&
	    I915_READ(LPT_TRANSCONF) & TRANS_ENABLE) {
		pipe_config->has_pch_encoder = true;
d9927 1
a9927 3
		tmp = I915_READ(FDI_RX_CTL(PIPE_A));
		pipe_config->fdi_lanes = ((FDI_DP_PORT_WIDTH_MASK & tmp) >>
					  FDI_DP_PORT_WIDTH_SHIFT) + 1;
d9929 2
a9930 1
		ironlake_get_fdi_m_n_config(crtc, pipe_config);
d9933 6
a9938 1
	intel_get_pipe_timings(crtc, pipe_config);
d9940 6
a9945 3
	pfit_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc->pipe);
	if (intel_display_power_enabled(dev, pfit_domain))
		ironlake_get_pfit_config(crtc, pipe_config);
d9951 6
a9956 1
	pipe_config->pixel_multiplier = 1;
d9961 1
a9961 3
static int intel_crtc_mode_set(struct drm_crtc *crtc,
			       int x, int y,
			       struct drm_framebuffer *fb)
a9964 1
	struct intel_encoder *encoder;
d9966 1
a9966 5
#ifdef DRMDEBUG
	struct drm_display_mode *mode = &intel_crtc->config.requested_mode;
#endif
	int pipe = intel_crtc->pipe;
	int ret;
d9968 4
a9971 1
	drm_vblank_pre_modeset(dev, pipe);
d9973 10
a9982 41
	ret = dev_priv->display.crtc_mode_set(crtc, x, y, fb);

	drm_vblank_post_modeset(dev, pipe);

	if (ret != 0)
		return ret;

	for_each_encoder_on_crtc(dev, crtc, encoder) {
		DRM_DEBUG_KMS("[ENCODER:%d:%s] set [MODE:%d:%s]\n",
			encoder->base.base.id,
			drm_get_encoder_name(&encoder->base),
			mode->base.id, mode->name);
		encoder->mode_set(encoder);
	}

	return 0;
}

static struct {
	int clock;
	u32 config;
} hdmi_audio_clock[] = {
	{ DIV_ROUND_UP(25200 * 1000, 1001), AUD_CONFIG_PIXEL_CLOCK_HDMI_25175 },
	{ 25200, AUD_CONFIG_PIXEL_CLOCK_HDMI_25200 }, /* default per bspec */
	{ 27000, AUD_CONFIG_PIXEL_CLOCK_HDMI_27000 },
	{ 27000 * 1001 / 1000, AUD_CONFIG_PIXEL_CLOCK_HDMI_27027 },
	{ 54000, AUD_CONFIG_PIXEL_CLOCK_HDMI_54000 },
	{ 54000 * 1001 / 1000, AUD_CONFIG_PIXEL_CLOCK_HDMI_54054 },
	{ DIV_ROUND_UP(74250 * 1000, 1001), AUD_CONFIG_PIXEL_CLOCK_HDMI_74176 },
	{ 74250, AUD_CONFIG_PIXEL_CLOCK_HDMI_74250 },
	{ DIV_ROUND_UP(148500 * 1000, 1001), AUD_CONFIG_PIXEL_CLOCK_HDMI_148352 },
	{ 148500, AUD_CONFIG_PIXEL_CLOCK_HDMI_148500 },
};

/* get AUD_CONFIG_PIXEL_CLOCK_HDMI_* value for mode */
static u32 audio_config_hdmi_pixel_clock(struct drm_display_mode *mode)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(hdmi_audio_clock); i++) {
		if (mode->clock == hdmi_audio_clock[i].clock)
d9984 1
a9984 1
	}
d9986 4
a9989 50
	if (i == ARRAY_SIZE(hdmi_audio_clock)) {
		DRM_DEBUG_KMS("HDMI audio pixel clock setting for %d not found, falling back to defaults\n", mode->clock);
		i = 1;
	}

	DRM_DEBUG_KMS("Configuring HDMI audio for pixel clock %d (0x%08x)\n",
		      hdmi_audio_clock[i].clock,
		      hdmi_audio_clock[i].config);

	return hdmi_audio_clock[i].config;
}

static bool intel_eld_uptodate(struct drm_connector *connector,
			       int reg_eldv, uint32_t bits_eldv,
			       int reg_elda, uint32_t bits_elda,
			       int reg_edid)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	uint8_t *eld = connector->eld;
	uint32_t i;

	i = I915_READ(reg_eldv);
	i &= bits_eldv;

	if (!eld[0])
		return !i;

	if (!i)
		return false;

	i = I915_READ(reg_elda);
	i &= ~bits_elda;
	I915_WRITE(reg_elda, i);

	for (i = 0; i < eld[2]; i++)
		if (I915_READ(reg_edid) != *((uint32_t *)eld + i))
			return false;

	return true;
}

static void g4x_write_eld(struct drm_connector *connector,
			  struct drm_crtc *crtc,
			  struct drm_display_mode *mode)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	uint8_t *eld = connector->eld;
	uint32_t eldv;
	uint32_t len;
	uint32_t i;
d9991 1
a9991 150
	i = I915_READ(G4X_AUD_VID_DID);

	if (i == INTEL_AUDIO_DEVBLC || i == INTEL_AUDIO_DEVCL)
		eldv = G4X_ELDV_DEVCL_DEVBLC;
	else
		eldv = G4X_ELDV_DEVCTG;

	if (intel_eld_uptodate(connector,
			       G4X_AUD_CNTL_ST, eldv,
			       G4X_AUD_CNTL_ST, G4X_ELD_ADDR,
			       G4X_HDMIW_HDMIEDID))
		return;

	i = I915_READ(G4X_AUD_CNTL_ST);
	i &= ~(eldv | G4X_ELD_ADDR);
	len = (i >> 9) & 0x1f;		/* ELD buffer size */
	I915_WRITE(G4X_AUD_CNTL_ST, i);

	if (!eld[0])
		return;

	len = min_t(uint8_t, eld[2], len);
	DRM_DEBUG_DRIVER("ELD size %d\n", len);
	for (i = 0; i < len; i++)
		I915_WRITE(G4X_HDMIW_HDMIEDID, *((uint32_t *)eld + i));

	i = I915_READ(G4X_AUD_CNTL_ST);
	i |= eldv;
	I915_WRITE(G4X_AUD_CNTL_ST, i);
}

static void haswell_write_eld(struct drm_connector *connector,
			      struct drm_crtc *crtc,
			      struct drm_display_mode *mode)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	uint8_t *eld = connector->eld;
	struct drm_device *dev = crtc->dev;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	uint32_t eldv;
	uint32_t i;
	int len;
	int pipe = to_intel_crtc(crtc)->pipe;
	int tmp;

	int hdmiw_hdmiedid = HSW_AUD_EDID_DATA(pipe);
	int aud_cntl_st = HSW_AUD_DIP_ELD_CTRL(pipe);
	int aud_config = HSW_AUD_CFG(pipe);
	int aud_cntrl_st2 = HSW_AUD_PIN_ELD_CP_VLD;


	DRM_DEBUG_DRIVER("HDMI: Haswell Audio initialize....\n");

	/* Audio output enable */
	DRM_DEBUG_DRIVER("HDMI audio: enable codec\n");
	tmp = I915_READ(aud_cntrl_st2);
	tmp |= (AUDIO_OUTPUT_ENABLE_A << (pipe * 4));
	I915_WRITE(aud_cntrl_st2, tmp);

	/* Wait for 1 vertical blank */
	intel_wait_for_vblank(dev, pipe);

	/* Set ELD valid state */
	tmp = I915_READ(aud_cntrl_st2);
	DRM_DEBUG_DRIVER("HDMI audio: pin eld vld status=0x%08x\n", tmp);
	tmp |= (AUDIO_ELD_VALID_A << (pipe * 4));
	I915_WRITE(aud_cntrl_st2, tmp);
	tmp = I915_READ(aud_cntrl_st2);
	DRM_DEBUG_DRIVER("HDMI audio: eld vld status=0x%08x\n", tmp);

	/* Enable HDMI mode */
	tmp = I915_READ(aud_config);
	DRM_DEBUG_DRIVER("HDMI audio: audio conf: 0x%08x\n", tmp);
	/* clear N_programing_enable and N_value_index */
	tmp &= ~(AUD_CONFIG_N_VALUE_INDEX | AUD_CONFIG_N_PROG_ENABLE);
	I915_WRITE(aud_config, tmp);

	DRM_DEBUG_DRIVER("ELD on pipe %c\n", pipe_name(pipe));

	eldv = AUDIO_ELD_VALID_A << (pipe * 4);
	intel_crtc->eld_vld = true;

	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT)) {
		DRM_DEBUG_DRIVER("ELD: DisplayPort detected\n");
		eld[5] |= (1 << 2);	/* Conn_Type, 0x1 = DisplayPort */
		I915_WRITE(aud_config, AUD_CONFIG_N_VALUE_INDEX); /* 0x1 = DP */
	} else {
		I915_WRITE(aud_config, audio_config_hdmi_pixel_clock(mode));
	}

	if (intel_eld_uptodate(connector,
			       aud_cntrl_st2, eldv,
			       aud_cntl_st, IBX_ELD_ADDRESS,
			       hdmiw_hdmiedid))
		return;

	i = I915_READ(aud_cntrl_st2);
	i &= ~eldv;
	I915_WRITE(aud_cntrl_st2, i);

	if (!eld[0])
		return;

	i = I915_READ(aud_cntl_st);
	i &= ~IBX_ELD_ADDRESS;
	I915_WRITE(aud_cntl_st, i);
	i = (i >> 29) & DIP_PORT_SEL_MASK;		/* DIP_Port_Select, 0x1 = PortB */
	DRM_DEBUG_DRIVER("port num:%d\n", i);

	len = min_t(uint8_t, eld[2], 21);	/* 84 bytes of hw ELD buffer */
	DRM_DEBUG_DRIVER("ELD size %d\n", len);
	for (i = 0; i < len; i++)
		I915_WRITE(hdmiw_hdmiedid, *((uint32_t *)eld + i));

	i = I915_READ(aud_cntrl_st2);
	i |= eldv;
	I915_WRITE(aud_cntrl_st2, i);

}

static void ironlake_write_eld(struct drm_connector *connector,
			       struct drm_crtc *crtc,
			       struct drm_display_mode *mode)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	uint8_t *eld = connector->eld;
	uint32_t eldv;
	uint32_t i;
	int len;
	int hdmiw_hdmiedid;
	int aud_config;
	int aud_cntl_st;
	int aud_cntrl_st2;
	int pipe = to_intel_crtc(crtc)->pipe;

	if (HAS_PCH_IBX(connector->dev)) {
		hdmiw_hdmiedid = IBX_HDMIW_HDMIEDID(pipe);
		aud_config = IBX_AUD_CFG(pipe);
		aud_cntl_st = IBX_AUD_CNTL_ST(pipe);
		aud_cntrl_st2 = IBX_AUD_CNTL_ST2;
	} else if (IS_VALLEYVIEW(connector->dev)) {
		hdmiw_hdmiedid = VLV_HDMIW_HDMIEDID(pipe);
		aud_config = VLV_AUD_CFG(pipe);
		aud_cntl_st = VLV_AUD_CNTL_ST(pipe);
		aud_cntrl_st2 = VLV_AUD_CNTL_ST2;
	} else {
		hdmiw_hdmiedid = CPT_HDMIW_HDMIEDID(pipe);
		aud_config = CPT_AUD_CFG(pipe);
		aud_cntl_st = CPT_AUD_CNTL_ST(pipe);
		aud_cntrl_st2 = CPT_AUD_CNTRL_ST2;
d9994 10
a10003 32
	DRM_DEBUG_DRIVER("ELD on pipe %c\n", pipe_name(pipe));

	if (IS_VALLEYVIEW(connector->dev))  {
		struct intel_encoder *intel_encoder;
		struct intel_digital_port *intel_dig_port;

		intel_encoder = intel_attached_encoder(connector);
		intel_dig_port = enc_to_dig_port(&intel_encoder->base);
		i = intel_dig_port->port;
	} else {
		i = I915_READ(aud_cntl_st);
		i = (i >> 29) & DIP_PORT_SEL_MASK;
		/* DIP_Port_Select, 0x1 = PortB */
	}

	if (!i) {
		DRM_DEBUG_DRIVER("Audio directed to unknown port\n");
		/* operate blindly on all ports */
		eldv = IBX_ELD_VALIDB;
		eldv |= IBX_ELD_VALIDB << 4;
		eldv |= IBX_ELD_VALIDB << 8;
	} else {
		DRM_DEBUG_DRIVER("ELD on port %c\n", port_name(i));
		eldv = IBX_ELD_VALIDB << ((i - 1) * 4);
	}

	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT)) {
		DRM_DEBUG_DRIVER("ELD: DisplayPort detected\n");
		eld[5] |= (1 << 2);	/* Conn_Type, 0x1 = DisplayPort */
		I915_WRITE(aud_config, AUD_CONFIG_N_VALUE_INDEX); /* 0x1 = DP */
	} else {
		I915_WRITE(aud_config, audio_config_hdmi_pixel_clock(mode));
d10006 4
a10009 80
	if (intel_eld_uptodate(connector,
			       aud_cntrl_st2, eldv,
			       aud_cntl_st, IBX_ELD_ADDRESS,
			       hdmiw_hdmiedid))
		return;

	i = I915_READ(aud_cntrl_st2);
	i &= ~eldv;
	I915_WRITE(aud_cntrl_st2, i);

	if (!eld[0])
		return;

	i = I915_READ(aud_cntl_st);
	i &= ~IBX_ELD_ADDRESS;
	I915_WRITE(aud_cntl_st, i);

	len = min_t(uint8_t, eld[2], 21);	/* 84 bytes of hw ELD buffer */
	DRM_DEBUG_DRIVER("ELD size %d\n", len);
	for (i = 0; i < len; i++)
		I915_WRITE(hdmiw_hdmiedid, *((uint32_t *)eld + i));

	i = I915_READ(aud_cntrl_st2);
	i |= eldv;
	I915_WRITE(aud_cntrl_st2, i);
}

void intel_write_eld(struct drm_encoder *encoder,
		     struct drm_display_mode *mode)
{
	struct drm_crtc *crtc = encoder->crtc;
	struct drm_connector *connector;
	struct drm_device *dev = encoder->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	connector = drm_select_eld(encoder, mode);
	if (!connector)
		return;

	DRM_DEBUG_DRIVER("ELD on [CONNECTOR:%d:%s], [ENCODER:%d:%s]\n",
			 connector->base.id,
			 drm_get_connector_name(connector),
			 connector->encoder->base.id,
			 drm_get_encoder_name(connector->encoder));

	connector->eld[6] = drm_av_sync_delay(connector, mode) / 2;

	if (dev_priv->display.write_eld)
		dev_priv->display.write_eld(connector, crtc, mode);
}

static void i845_update_cursor(struct drm_crtc *crtc, u32 base)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	bool visible = base != 0;
	u32 cntl;

	if (intel_crtc->cursor_visible == visible)
		return;

	cntl = I915_READ(_CURACNTR);
	if (visible) {
		/* On these chipsets we can only modify the base whilst
		 * the cursor is disabled.
		 */
		I915_WRITE(_CURABASE, base);

		cntl &= ~(CURSOR_FORMAT_MASK);
		/* XXX width must be 64, stride 256 => 0x00 << 28 */
		cntl |= CURSOR_ENABLE |
			CURSOR_GAMMA_ENABLE |
			CURSOR_FORMAT_ARGB;
	} else
		cntl &= ~(CURSOR_ENABLE | CURSOR_GAMMA_ENABLE);
	I915_WRITE(_CURACNTR, cntl);

	intel_crtc->cursor_visible = visible;
}
d10011 4
a10014 7
static void i9xx_update_cursor(struct drm_crtc *crtc, u32 base)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	bool visible = base != 0;
d10016 4
a10019 13
	if (intel_crtc->cursor_visible != visible) {
		uint32_t cntl = I915_READ(CURCNTR(pipe));
		if (base) {
			cntl &= ~(CURSOR_MODE | MCURSOR_PIPE_SELECT);
			cntl |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;
			cntl |= pipe << 28; /* Connect to correct pipe */
		} else {
			cntl &= ~(CURSOR_MODE | MCURSOR_GAMMA_ENABLE);
			cntl |= CURSOR_MODE_DISABLE;
		}
		I915_WRITE(CURCNTR(pipe), cntl);

		intel_crtc->cursor_visible = visible;
a10020 4
	/* and commit changes on next vblank */
	POSTING_READ(CURCNTR(pipe));
	I915_WRITE(CURBASE(pipe), base);
	POSTING_READ(CURBASE(pipe));
d10023 1
a10023 1
static void ivb_update_cursor(struct drm_crtc *crtc, u32 base)
d10029 1
a10029 1
	bool visible = base != 0;
d10031 15
a10045 8
	if (intel_crtc->cursor_visible != visible) {
		uint32_t cntl = I915_READ(CURCNTR_IVB(pipe));
		if (base) {
			cntl &= ~CURSOR_MODE;
			cntl |= CURSOR_MODE_64_ARGB_AX | MCURSOR_GAMMA_ENABLE;
		} else {
			cntl &= ~(CURSOR_MODE | MCURSOR_GAMMA_ENABLE);
			cntl |= CURSOR_MODE_DISABLE;
d10047 3
a10049 1
		if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
d10051 4
a10054 3
			cntl &= ~CURSOR_TRICKLE_FEED_DISABLE;
		}
		I915_WRITE(CURCNTR_IVB(pipe), cntl);
d10056 4
a10059 1
		intel_crtc->cursor_visible = visible;
d10061 1
d10063 4
a10066 3
	POSTING_READ(CURCNTR_IVB(pipe));
	I915_WRITE(CURBASE_IVB(pipe), base);
	POSTING_READ(CURBASE_IVB(pipe));
d10077 3
a10079 2
	int x = intel_crtc->cursor_x;
	int y = intel_crtc->cursor_y;
a10080 1
	bool visible;
d10082 1
a10082 2
	if (on)
		base = intel_crtc->cursor_addr;
d10084 2
a10085 2
	if (x >= intel_crtc->config.pipe_src_w)
		base = 0;
d10087 2
a10088 2
	if (y >= intel_crtc->config.pipe_src_h)
		base = 0;
d10091 2
a10092 2
		if (x + intel_crtc->cursor_width <= 0)
			base = 0;
d10100 2
a10101 2
		if (y + intel_crtc->cursor_height <= 0)
			base = 0;
d10108 1
a10108 3
	visible = base != 0;
	if (!visible && !intel_crtc->cursor_visible)
		return;
d10110 5
a10114 9
	if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		I915_WRITE(CURPOS_IVB(pipe), pos);
		ivb_update_cursor(crtc, base);
	} else {
		I915_WRITE(CURPOS(pipe), pos);
		if (IS_845G(dev) || IS_I865G(dev))
			i845_update_cursor(crtc, base);
		else
			i9xx_update_cursor(crtc, base);
d10116 5
d10123 2
a10124 4
static int intel_crtc_cursor_set(struct drm_crtc *crtc,
				 struct drm_file *file,
				 uint32_t handle,
				 uint32_t width, uint32_t height)
d10126 2
a10127 6
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_i915_gem_object *obj;
	uint32_t addr;
	int ret;
d10129 9
a10137 8
	/* if we want to turn off the cursor ignore width and height */
	if (!handle) {
		DRM_DEBUG_KMS("cursor off\n");
		addr = 0;
		obj = NULL;
		mutex_lock(&dev->struct_mutex);
		goto finish;
	}
d10139 2
a10140 5
	/* Currently we only support 64x64 cursors */
	if (width != 64 || height != 64) {
		DRM_ERROR("we currently only support 64x64 cursors\n");
		return -EINVAL;
	}
d10142 2
a10143 43
	obj = to_intel_bo(drm_gem_object_lookup(dev, file, handle));
	if (&obj->base == NULL)
		return -ENOENT;

	if (obj->base.size < width * height * 4) {
		DRM_ERROR("buffer is to small\n");
		ret = -ENOMEM;
		goto fail;
	}

	/* we only need to pin inside GTT if cursor is non-phy */
	mutex_lock(&dev->struct_mutex);
	if (!dev_priv->info->cursor_needs_physical) {
		unsigned alignment;

		if (obj->tiling_mode) {
			DRM_ERROR("cursor cannot be tiled\n");
			ret = -EINVAL;
			goto fail_locked;
		}

		/* Note that the w/a also requires 2 PTE of padding following
		 * the bo. We currently fill all unused PTE with the shadow
		 * page and so we should always have valid PTE following the
		 * cursor preventing the VT-d warning.
		 */
		alignment = 0;
		if (need_vtd_wa(dev))
			alignment = 64*1024;

		ret = i915_gem_object_pin_to_display_plane(obj, alignment, NULL);
		if (ret) {
			DRM_ERROR("failed to move cursor bo into the GTT\n");
			goto fail_locked;
		}

		ret = i915_gem_object_put_fence(obj);
		if (ret) {
			DRM_ERROR("failed to release fence for cursor");
			goto fail_unpin;
		}

		addr = i915_gem_obj_ggtt_offset(obj);
d10145 9
a10153 7
		int align = IS_I830(dev) ? 16 * 1024 : 256;
		ret = i915_gem_attach_phys_object(dev, obj,
						  (intel_crtc->pipe == 0) ? I915_GEM_PHYS_CURSOR_0 : I915_GEM_PHYS_CURSOR_1,
						  align);
		if (ret) {
			DRM_ERROR("failed to attach phys object\n");
			goto fail_locked;
a10154 1
		addr = obj->phys_obj->handle->segs[0].ds_addr;
d10157 1
a10157 44
	if (IS_GEN2(dev))
		I915_WRITE(CURSIZE, (height << 12) | width);

 finish:
	if (intel_crtc->cursor_bo) {
		if (dev_priv->info->cursor_needs_physical) {
			if (intel_crtc->cursor_bo != obj)
				i915_gem_detach_phys_object(dev, intel_crtc->cursor_bo);
		} else
			i915_gem_object_unpin_from_display_plane(intel_crtc->cursor_bo);
		drm_gem_object_unreference(&intel_crtc->cursor_bo->base);
	}

	mutex_unlock(&dev->struct_mutex);

	intel_crtc->cursor_addr = addr;
	intel_crtc->cursor_bo = obj;
	intel_crtc->cursor_width = width;
	intel_crtc->cursor_height = height;

	if (intel_crtc->active)
		intel_crtc_update_cursor(crtc, intel_crtc->cursor_bo != NULL);

	return 0;
fail_unpin:
	i915_gem_object_unpin_from_display_plane(obj);
fail_locked:
	mutex_unlock(&dev->struct_mutex);
fail:
	drm_gem_object_unreference_unlocked(&obj->base);
	return ret;
}

static int intel_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	intel_crtc->cursor_x = clamp_t(int, x, SHRT_MIN, SHRT_MAX);
	intel_crtc->cursor_y = clamp_t(int, y, SHRT_MIN, SHRT_MAX);

	if (intel_crtc->active)
		intel_crtc_update_cursor(crtc, intel_crtc->cursor_bo != NULL);

	return 0;
d10181 4
a10184 4
static struct drm_framebuffer *
intel_framebuffer_create(struct drm_device *dev,
			 struct drm_mode_fb_cmd2 *mode_cmd,
			 struct drm_i915_gem_object *obj)
d10191 1
a10191 1
		drm_gem_object_unreference_unlocked(&obj->base);
a10194 4
	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		goto err;

a10195 1
	mutex_unlock(&dev->struct_mutex);
d10201 1
a10201 1
	drm_gem_object_unreference_unlocked(&obj->base);
d10207 17
d10235 1
a10235 1
	return roundup2(pitch * mode->vdisplay, PAGE_SIZE);
d10264 1
a10264 1
#ifdef CONFIG_DRM_I915_FBDEV
d10269 1
a10269 1
	if (dev_priv->fbdev == NULL)
d10272 1
a10272 2
	obj = dev_priv->fbdev->ifb.obj;
	if (obj == NULL)
d10275 4
a10278 1
	fb = &dev_priv->fbdev->ifb.base;
d10292 35
d10329 2
a10330 1
				struct intel_load_detect_pipe *old)
d10340 5
a10344 1
	int i = -1;
d10347 7
a10353 2
		      connector->base.id, drm_get_connector_name(connector),
		      encoder->base.id, drm_get_encoder_name(encoder));
d10369 6
a10374 1
		mutex_lock(&crtc->mutex);
d10387 1
a10387 1
	list_for_each_entry(possible_crtc, &dev->mode_config.crtc_list, head) {
d10391 5
a10395 4
		if (!possible_crtc->enabled) {
			crtc = possible_crtc;
			break;
		}
d10403 1
a10403 1
		return false;
d10406 6
a10411 3
	mutex_lock(&crtc->mutex);
	intel_encoder->new_crtc = to_intel_crtc(crtc);
	to_intel_connector(connector)->new_encoder = intel_encoder;
d10418 23
d10460 1
a10460 2
		mutex_unlock(&crtc->mutex);
		return false;
d10463 7
a10469 1
	if (intel_set_mode(crtc, mode, 0, 0, fb)) {
d10473 1
a10473 2
		mutex_unlock(&crtc->mutex);
		return false;
d10475 1
d10480 11
d10494 2
a10495 1
				    struct intel_load_detect_pipe *old)
d10497 1
d10502 5
d10509 2
a10510 2
		      connector->base.id, drm_get_connector_name(connector),
		      encoder->base.id, drm_get_encoder_name(encoder));
d10513 27
a10539 3
		to_intel_connector(connector)->new_encoder = NULL;
		intel_encoder->new_crtc = NULL;
		intel_set_mode(crtc, NULL, 0, 0, NULL);
a10545 1
		mutex_unlock(&crtc->mutex);
d10553 4
a10556 1
	mutex_unlock(&crtc->mutex);
d10560 1
a10560 1
			   const struct intel_crtc_config *pipe_config)
d10577 1
a10577 1
				struct intel_crtc_config *pipe_config)
d10585 1
d10626 1
a10626 1
			pineview_clock(refclk, &clock);
d10628 1
a10628 1
			i9xx_clock(refclk, &clock);
d10654 1
a10654 1
		i9xx_clock(refclk, &clock);
d10662 1
a10662 1
	pipe_config->port_clock = clock.dot;
d10685 1
a10685 1
				   struct intel_crtc_config *pipe_config)
d10698 1
a10698 1
	pipe_config->adjusted_mode.crtc_clock =
d10709 1
a10709 1
	enum transcoder cpu_transcoder = intel_crtc->config.cpu_transcoder;
d10711 1
a10711 1
	struct intel_crtc_config pipe_config;
d10723 5
a10727 74
	 * Construct a pipe_config sufficient for getting the clock info
	 * back out of crtc_clock_get.
	 *
	 * Note, if LVDS ever uses a non-1 pixel multiplier, we'll need
	 * to use a real value here instead.
	 */
	pipe_config.cpu_transcoder = (enum transcoder) pipe;
	pipe_config.pixel_multiplier = 1;
	pipe_config.dpll_hw_state.dpll = I915_READ(DPLL(pipe));
	pipe_config.dpll_hw_state.fp0 = I915_READ(FP0(pipe));
	pipe_config.dpll_hw_state.fp1 = I915_READ(FP1(pipe));
	i9xx_crtc_clock_get(intel_crtc, &pipe_config);

	mode->clock = pipe_config.port_clock / pipe_config.pixel_multiplier;
	mode->hdisplay = (htot & 0xffff) + 1;
	mode->htotal = ((htot & 0xffff0000) >> 16) + 1;
	mode->hsync_start = (hsync & 0xffff) + 1;
	mode->hsync_end = ((hsync & 0xffff0000) >> 16) + 1;
	mode->vdisplay = (vtot & 0xffff) + 1;
	mode->vtotal = ((vtot & 0xffff0000) >> 16) + 1;
	mode->vsync_start = (vsync & 0xffff) + 1;
	mode->vsync_end = ((vsync & 0xffff0000) >> 16) + 1;

	drm_mode_set_name(mode);

	return mode;
}

static void intel_increase_pllclock(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	int dpll_reg = DPLL(pipe);
	int dpll;

	if (HAS_PCH_SPLIT(dev))
		return;

	if (!dev_priv->lvds_downclock_avail)
		return;

	dpll = I915_READ(dpll_reg);
	if (!HAS_PIPE_CXSR(dev) && (dpll & DISPLAY_RATE_SELECT_FPA1)) {
		DRM_DEBUG_DRIVER("upclocking LVDS\n");

		assert_panel_unlocked(dev_priv, pipe);

		dpll &= ~DISPLAY_RATE_SELECT_FPA1;
		I915_WRITE(dpll_reg, dpll);
		intel_wait_for_vblank(dev, pipe);

		dpll = I915_READ(dpll_reg);
		if (dpll & DISPLAY_RATE_SELECT_FPA1)
			DRM_DEBUG_DRIVER("failed to upclock LVDS!\n");
	}
}

static void intel_decrease_pllclock(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	if (HAS_PCH_SPLIT(dev))
		return;

	if (!dev_priv->lvds_downclock_avail)
		return;

	/*
	 * Since this is called by a timer, we should never get here in
	 * the manual case.
d10729 6
a10734 4
	if (!HAS_PIPE_CXSR(dev) && intel_crtc->lowfreq_avail) {
		int pipe = intel_crtc->pipe;
		int dpll_reg = DPLL(pipe);
		int dpll;
d10736 9
a10744 1
		DRM_DEBUG_DRIVER("downclocking LVDS\n");
d10746 1
a10746 10
		assert_panel_unlocked(dev_priv, pipe);

		dpll = I915_READ(dpll_reg);
		dpll |= DISPLAY_RATE_SELECT_FPA1;
		I915_WRITE(dpll_reg, dpll);
		intel_wait_for_vblank(dev, pipe);
		dpll = I915_READ(dpll_reg);
		if (!(dpll & DISPLAY_RATE_SELECT_FPA1))
			DRM_DEBUG_DRIVER("failed to downclock LVDS!\n");
	}
d10748 1
d10755 4
a10758 1
	hsw_package_c8_gpu_busy(dev_priv);
d10760 3
a10767 3
	struct drm_crtc *crtc;

	hsw_package_c8_gpu_idle(dev_priv);
d10769 1
a10769 1
	if (!i915_powersave)
d10772 1
a10772 6
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		if (!crtc->fb)
			continue;

		intel_decrease_pllclock(crtc);
	}
d10774 1
a10774 1
	if (dev_priv->info->gen >= 6)
a10775 1
}
d10777 1
a10777 20
void intel_mark_fb_busy(struct drm_i915_gem_object *obj,
			struct intel_ring_buffer *ring)
{
	struct drm_device *dev = obj->base.dev;
	struct drm_crtc *crtc;

	if (!i915_powersave)
		return;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		if (!crtc->fb)
			continue;

		if (to_intel_framebuffer(crtc->fb)->obj != obj)
			continue;

		intel_increase_pllclock(crtc);
		if (ring && intel_fbc_enabled(dev))
			ring->fbc_dirty = true;
	}
a10784 1
	unsigned long flags;
d10786 1
a10786 1
	spin_lock_irqsave(&dev->event_lock, flags);
d10789 1
a10789 1
	spin_unlock_irqrestore(&dev->event_lock, flags);
a10795 2
	intel_crtc_cursor_set(crtc, NULL, 0, 0, 0);

d10805 3
a10807 1
	struct drm_device *dev = work->crtc->dev;
d10810 1
a10810 1
	intel_unpin_fb_obj(work->old_fb_obj);
a10811 1
	drm_gem_object_unreference(&work->old_fb_obj->base);
d10813 2
a10814 1
	intel_update_fbc(dev);
d10817 5
a10821 2
	BUG_ON(atomic_read(&to_intel_crtc(work->crtc)->unpin_work_count) == 0);
	atomic_dec(&to_intel_crtc(work->crtc)->unpin_work_count);
a10828 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d10837 4
d10852 1
a10852 9
	/* and that the unpin work is consistent wrt ->pending. */
	smp_rmb();

	intel_crtc->unpin_work = NULL;

	if (work->event)
		drm_send_vblank_event(dev, intel_crtc->pipe, work->event);

	drm_vblank_put(dev, intel_crtc->pipe);
a10854 6

	wake_up_all(&dev_priv->pending_flip_queue);

	queue_work(dev_priv->wq, &work->work);

	trace_i915_flip_complete(intel_crtc->plane, work->pending_flip_obj);
d10859 1
a10859 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d10867 1
a10867 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d10873 46
d10921 1
a10921 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d10926 6
a10931 1
	/* NB: An MMIO update of the plane base pointer will also
d10936 1
a10936 1
	if (intel_crtc->unpin_work)
d10941 1
a10941 1
inline static void intel_mark_page_flip_active(struct intel_crtc *intel_crtc)
d10945 1
a10945 1
	atomic_set(&intel_crtc->unpin_work->pending, INTEL_FLIP_PENDING);
d10954 1
d10957 1
a10957 1
	struct drm_i915_private *dev_priv = dev->dev_private;
a10959 1
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
d10962 1
a10962 1
	ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
d10964 1
a10964 5
		goto err;

	ret = intel_ring_begin(ring, 6);
	if (ret)
		goto err_unpin;
d10978 1
a10978 1
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
d10981 1
a10981 2
	intel_mark_page_flip_active(intel_crtc);
	__intel_ring_advance(ring);
a10982 5

err_unpin:
	intel_unpin_fb_obj(obj);
err:
	return ret;
d10989 1
d10992 1
a10992 1
	struct drm_i915_private *dev_priv = dev->dev_private;
a10994 1
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
d10997 1
a10997 1
	ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
d10999 1
a10999 5
		goto err;

	ret = intel_ring_begin(ring, 6);
	if (ret)
		goto err_unpin;
d11010 1
a11010 1
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
d11013 1
a11013 2
	intel_mark_page_flip_active(intel_crtc);
	__intel_ring_advance(ring);
a11014 5

err_unpin:
	intel_unpin_fb_obj(obj);
err:
	return ret;
d11021 1
d11024 1
a11027 1
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
d11030 1
a11030 1
	ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
d11032 1
a11032 5
		goto err;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		goto err_unpin;
d11041 1
a11041 2
	intel_ring_emit(ring,
			(i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset) |
d11052 1
a11052 2
	intel_mark_page_flip_active(intel_crtc);
	__intel_ring_advance(ring);
a11053 5

err_unpin:
	intel_unpin_fb_obj(obj);
err:
	return ret;
d11060 1
d11063 1
a11065 1
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
d11069 1
a11069 1
	ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
d11071 1
a11071 5
		goto err;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		goto err_unpin;
d11076 1
a11076 1
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
d11088 1
a11088 2
	intel_mark_page_flip_active(intel_crtc);
	__intel_ring_advance(ring);
a11089 5

err_unpin:
	intel_unpin_fb_obj(obj);
err:
	return ret;
d11096 1
d11099 1
a11099 1
	struct drm_i915_private *dev_priv = dev->dev_private;
a11100 1
	struct intel_ring_buffer *ring;
d11104 1
a11104 9
	ring = obj->ring;
	if (IS_VALLEYVIEW(dev) || ring == NULL || ring->id != RCS)
		ring = &dev_priv->ring[BCS];

	ret = intel_pin_and_fence_fb_obj(dev, obj, ring);
	if (ret)
		goto err;

	switch(intel_crtc->plane) {
d11116 1
a11116 2
		ret = -ENODEV;
		goto err_unpin;
d11120 1
a11120 1
	if (ring->id == RCS)
d11122 8
d11141 1
a11141 1
	ret = intel_ring_cacheline_align(ring);
d11143 1
a11143 1
		goto err_unpin;
d11145 1
a11145 1
	ret = intel_ring_begin(ring, len);
d11147 1
a11147 1
		goto err_unpin;
d11164 6
a11169 2
		intel_ring_emit(ring, MI_STORE_REGISTER_MEM(1) |
				MI_SRM_LRM_GLOBAL_GTT);
d11172 4
d11180 1
a11180 1
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(obj) + intel_crtc->dspaddr_offset);
d11183 220
a11402 8
	intel_mark_page_flip_active(intel_crtc);
	__intel_ring_advance(ring);
	return 0;

err_unpin:
	intel_unpin_fb_obj(obj);
err:
	return ret;
d11405 1
a11405 5
static int intel_default_queue_flip(struct drm_device *dev,
				    struct drm_crtc *crtc,
				    struct drm_framebuffer *fb,
				    struct drm_i915_gem_object *obj,
				    uint32_t flags)
d11407 22
a11428 1
	return -ENODEV;
d11438 2
a11439 2
	struct drm_framebuffer *old_fb = crtc->fb;
	struct drm_i915_gem_object *obj = to_intel_framebuffer(fb)->obj;
d11441 2
d11444 3
a11446 1
	unsigned long flags;
d11449 8
d11458 1
a11458 1
	if (fb->pixel_format != crtc->fb->pixel_format)
d11466 2
a11467 2
	    (fb->offsets[0] != crtc->fb->offsets[0] ||
	     fb->pitches[0] != crtc->fb->pitches[0]))
d11470 3
d11479 1
a11479 1
	work->old_fb_obj = to_intel_framebuffer(old_fb)->obj;
d11482 1
a11482 1
	ret = drm_vblank_get(dev, intel_crtc->pipe);
d11487 1
a11487 1
	spin_lock_irqsave(&dev->event_lock, flags);
d11489 9
a11497 3
		spin_unlock_irqrestore(&dev->event_lock, flags);
		kfree(work);
		drm_vblank_put(dev, intel_crtc->pipe);
d11499 4
a11502 2
		DRM_DEBUG_DRIVER("flip queue: crtc already busy\n");
		return -EBUSY;
d11505 1
a11505 1
	spin_unlock_irqrestore(&dev->event_lock, flags);
a11509 4
	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		goto cleanup;

d11511 1
a11511 1
	drm_gem_object_reference(&work->old_fb_obj->base);
d11514 2
a11515 1
	crtc->fb = fb;
d11519 3
a11521 1
	work->enable_stall_check = true;
d11526 28
a11553 1
	ret = dev_priv->display.queue_flip(dev, crtc, fb, obj, page_flip_flags);
d11557 35
a11591 2
	intel_disable_fbc(dev);
	intel_mark_fb_busy(obj, NULL);
d11594 4
d11602 2
d11605 2
a11607 3
	crtc->fb = old_fb;
	drm_gem_object_unreference(&work->old_fb_obj->base);
	drm_gem_object_unreference(&obj->base);
d11609 6
d11616 1
a11616 2
cleanup:
	spin_lock_irqsave(&dev->event_lock, flags);
d11618 1
a11618 1
	spin_unlock_irqrestore(&dev->event_lock, flags);
d11620 1
a11620 1
	drm_vblank_put(dev, intel_crtc->pipe);
d11624 36
a11662 4
static struct drm_crtc_helper_funcs intel_helper_funcs = {
	.mode_set_base_atomic = intel_pipe_set_base_atomic,
	.load_lut = intel_crtc_load_lut,
};
d11665 3
a11667 1
 * intel_modeset_update_staged_output_state
d11669 4
a11672 2
 * Updates the staged output configuration state, e.g. after we've read out the
 * current hw state.
d11674 17
a11690 1
static void intel_modeset_update_staged_output_state(struct drm_device *dev)
d11692 128
a11819 2
	struct intel_encoder *encoder;
	struct intel_connector *connector;
d11821 10
a11830 4
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		connector->new_encoder =
			to_intel_encoder(connector->base.encoder);
d11832 23
d11856 4
a11859 4
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		encoder->new_crtc =
			to_intel_crtc(encoder->base.crtc);
d11861 2
d11865 2
a11866 6
/**
 * intel_modeset_commit_output_state
 *
 * This function copies the stage display pipe configuration to the real one.
 */
static void intel_modeset_commit_output_state(struct drm_device *dev)
d11869 49
a11917 1
	struct intel_connector *connector;
d11919 3
a11921 3
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		connector->base.encoder = &connector->new_encoder->base;
d11924 25
a11948 3
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		encoder->base.crtc = &encoder->new_crtc->base;
d11953 2
a11954 2
connected_sink_compute_bpp(struct intel_connector * connector,
			   struct intel_crtc_config *pipe_config)
d11960 1
a11960 1
		drm_get_connector_name(&connector->base));
d11980 1
a11980 2
			  struct drm_framebuffer *fb,
			  struct intel_crtc_config *pipe_config)
d11983 4
a11986 2
	struct intel_connector *connector;
	int bpp;
d11988 5
a11992 19
	switch (fb->pixel_format) {
	case DRM_FORMAT_C8:
		bpp = 8*3; /* since we go through a colormap */
		break;
	case DRM_FORMAT_XRGB1555:
	case DRM_FORMAT_ARGB1555:
		/* checked in intel_framebuffer_init already */
		if (WARN_ON(INTEL_INFO(dev)->gen > 3))
			return -EINVAL;
	case DRM_FORMAT_RGB565:
		bpp = 6*3; /* min is 18bpp */
		break;
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_ABGR8888:
		/* checked in intel_framebuffer_init already */
		if (WARN_ON(INTEL_INFO(dev)->gen < 4))
			return -EINVAL;
	case DRM_FORMAT_XRGB8888:
	case DRM_FORMAT_ARGB8888:
d11994 1
a11994 15
		break;
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_XBGR2101010:
	case DRM_FORMAT_ABGR2101010:
		/* checked in intel_framebuffer_init already */
		if (WARN_ON(INTEL_INFO(dev)->gen < 4))
			return -EINVAL;
		bpp = 10*3;
		break;
	/* TODO: gen4+ supports 16 bpc floating point, too. */
	default:
		DRM_DEBUG_KMS("unsupported depth\n");
		return -EINVAL;
	}
d11998 2
d12001 2
a12002 4
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		if (!connector->new_encoder ||
		    connector->new_encoder->new_crtc != crtc)
d12005 2
a12006 1
		connected_sink_compute_bpp(connector, pipe_config);
d12024 1
a12024 1
				   struct intel_crtc_config *pipe_config,
d12027 8
a12034 2
	DRM_DEBUG_KMS("[CRTC:%d]%s config for pipe %c\n", crtc->base.base.id,
		      context, pipe_name(crtc->pipe));
d12045 1
a12045 1
	DRM_DEBUG_KMS("dp: %i, gmch_m: %u, gmch_n: %u, link_m: %u, link_n: %u, tu: %u\n",
d12047 1
d12051 14
d12066 1
a12066 1
	drm_mode_debug_printmodeline(&pipe_config->requested_mode);
d12068 2
a12069 2
	drm_mode_debug_printmodeline(&pipe_config->adjusted_mode);
	intel_dump_crtc_timings(&pipe_config->adjusted_mode);
d12073 4
d12087 71
d12160 1
a12160 1
static bool check_encoder_cloning(struct drm_crtc *crtc)
d12162 37
a12198 3
	int num_encoders = 0;
	bool uncloneable_encoders = false;
	struct intel_encoder *encoder;
d12200 5
a12204 4
	list_for_each_entry(encoder, &crtc->dev->mode_config.encoder_list,
			    base.head) {
		if (&encoder->new_crtc->base != crtc)
			continue;
d12206 2
a12207 4
		num_encoders++;
		if (!encoder->cloneable)
			uncloneable_encoders = true;
	}
d12209 30
a12238 1
	return !(num_encoders > 1 && uncloneable_encoders);
d12241 1
a12241 1
static struct intel_crtc_config *
d12243 1
a12243 2
			  struct drm_framebuffer *fb,
			  struct drm_display_mode *mode)
d12245 1
a12245 1
	struct drm_device *dev = crtc->dev;
d12247 4
a12250 2
	struct intel_crtc_config *pipe_config;
	int plane_bpp, ret = -EINVAL;
d12253 1
a12253 11
	if (!check_encoder_cloning(crtc)) {
		DRM_DEBUG_KMS("rejecting invalid cloning configuration\n");
		return ERR_PTR(-EINVAL);
	}

	pipe_config = kzalloc(sizeof(*pipe_config), GFP_KERNEL);
	if (!pipe_config)
		return ERR_PTR(-ENOMEM);

	drm_mode_copy(&pipe_config->adjusted_mode, mode);
	drm_mode_copy(&pipe_config->requested_mode, mode);
a12256 1
	pipe_config->shared_dpll = DPLL_ID_PRIVATE;
d12263 1
a12263 1
	if (!(pipe_config->adjusted_mode.flags &
d12265 1
a12265 1
		pipe_config->adjusted_mode.flags |= DRM_MODE_FLAG_NHSYNC;
d12267 1
a12267 1
	if (!(pipe_config->adjusted_mode.flags &
d12269 1
a12269 1
		pipe_config->adjusted_mode.flags |= DRM_MODE_FLAG_NVSYNC;
d12271 3
a12273 7
	/* Compute a starting value for pipe_config->pipe_bpp taking the source
	 * plane pixel format and any sink constraints into account. Returns the
	 * source plane bpp so that dithering can be selected on mismatches
	 * after encoders and crtc also have had their say. */
	plane_bpp = compute_baseline_pipe_bpp(to_intel_crtc(crtc),
					      fb, pipe_config);
	if (plane_bpp < 0)
d12284 3
a12286 3
	drm_mode_set_crtcinfo(&pipe_config->requested_mode, CRTC_STEREO_DOUBLE);
	pipe_config->pipe_src_w = pipe_config->requested_mode.crtc_hdisplay;
	pipe_config->pipe_src_h = pipe_config->requested_mode.crtc_vdisplay;
d12294 2
a12295 1
	drm_mode_set_crtcinfo(&pipe_config->adjusted_mode, CRTC_STEREO_DOUBLE);
d12301 3
a12303 2
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
d12305 1
a12305 2
		if (&encoder->new_crtc->base != crtc)
			continue;
d12316 1
a12316 1
		pipe_config->port_clock = pipe_config->adjusted_mode.crtc_clock
d12336 5
a12340 3
	pipe_config->dither = pipe_config->pipe_bpp != plane_bpp;
	DRM_DEBUG_KMS("plane bpp: %i, pipe bpp: %i, dithering: %i\n",
		      plane_bpp, pipe_config->pipe_bpp, pipe_config->dither);
a12341 1
	return pipe_config;
d12343 1
a12343 2
	kfree(pipe_config);
	return ERR_PTR(ret);
a12345 2
/* Computes which crtcs are affected and sets the relevant bits in the mask. For
 * simplicity we use the crtc's pipe number (because it's easier to obtain). */
d12347 317
a12663 2
intel_modeset_affected_pipes(struct drm_crtc *crtc, unsigned *modeset_pipes,
			     unsigned *prepare_pipes, unsigned *disable_pipes)
d12665 2
d12668 69
a12736 1
	struct drm_device *dev = crtc->dev;
a12738 1
	struct drm_crtc *tmp_crtc;
d12740 47
a12786 1
	*disable_pipes = *modeset_pipes = *prepare_pipes = 0;
d12788 2
a12789 7
	/* Check which crtcs have changed outputs connected to them, these need
	 * to be part of the prepare_pipes mask. We don't (yet) support global
	 * modeset across multiple crtcs, so modeset_pipes will only have one
	 * bit set at most. */
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		if (connector->base.encoder == &connector->new_encoder->base)
d12792 36
a12827 2
		if (connector->base.encoder) {
			tmp_crtc = connector->base.encoder->crtc;
d12829 2
a12830 1
			*prepare_pipes |= 1 << to_intel_crtc(tmp_crtc)->pipe;
d12833 12
a12844 3
		if (connector->new_encoder)
			*prepare_pipes |=
				1 << connector->new_encoder->new_crtc->pipe;
d12846 1
d12848 7
a12854 4
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		if (encoder->base.crtc == &encoder->new_crtc->base)
			continue;
d12856 4
a12859 2
		if (encoder->base.crtc) {
			tmp_crtc = encoder->base.crtc;
d12861 1
a12861 2
			*prepare_pipes |= 1 << to_intel_crtc(tmp_crtc)->pipe;
		}
d12863 1
a12863 3
		if (encoder->new_crtc)
			*prepare_pipes |= 1 << encoder->new_crtc->pipe;
	}
d12865 1
a12865 4
	/* Check for any pipes that will be fully disabled ... */
	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list,
			    base.head) {
		bool used = false;
d12867 10
a12876 3
		/* Don't try to disable disabled crtcs. */
		if (!intel_crtc->base.enabled)
			continue;
d12878 5
a12882 4
		list_for_each_entry(encoder, &dev->mode_config.encoder_list,
				    base.head) {
			if (encoder->new_crtc == intel_crtc)
				used = true;
d12884 6
d12891 3
a12893 2
		if (!used)
			*disable_pipes |= 1 << intel_crtc->pipe;
d12895 1
d12897 10
d12908 3
a12910 5
	/* set_mode is also used to update properties on life display pipes. */
	intel_crtc = to_intel_crtc(crtc);
	if (crtc->enabled)
		*prepare_pipes |= 1 << intel_crtc->pipe;

d12912 2
a12913 3
	 * For simplicity do a full modeset on any pipe where the output routing
	 * changed. We could be more clever, but that would require us to be
	 * more careful with calling the relevant encoder->mode_set functions.
d12915 4
a12918 2
	if (*prepare_pipes)
		*modeset_pipes = *prepare_pipes;
d12920 3
a12922 3
	/* ... and mask these out. */
	*modeset_pipes &= ~(*disable_pipes);
	*prepare_pipes &= ~(*disable_pipes);
d12925 16
a12940 3
	 * HACK: We don't (yet) fully support global modesets. intel_set_config
	 * obies this rule, but the modeset restore mode of
	 * intel_modeset_setup_hw_state does not.
d12942 3
a12944 2
	*modeset_pipes &= 1 << intel_crtc->pipe;
	*prepare_pipes &= 1 << intel_crtc->pipe;
d12946 10
a12955 2
	DRM_DEBUG_KMS("set mode pipe masks: modeset: %x, prepare: %x, disable: %x\n",
		      *modeset_pipes, *prepare_pipes, *disable_pipes);
d12958 1
a12958 1
static bool intel_crtc_in_use(struct drm_crtc *crtc)
d12960 23
a12982 2
	struct drm_encoder *encoder;
	struct drm_device *dev = crtc->dev;
d12984 2
a12985 3
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
		if (encoder->crtc == crtc)
			return true;
d12987 2
a12988 1
	return false;
d12991 7
a12997 2
static void
intel_modeset_update_state(struct drm_device *dev, unsigned prepare_pipes)
d12999 1
a12999 1
	struct intel_encoder *intel_encoder;
d13001 9
a13009 1
	struct drm_connector *connector;
d13011 1
a13011 3
	list_for_each_entry(intel_encoder, &dev->mode_config.encoder_list,
			    base.head) {
		if (!intel_encoder->base.crtc)
d13014 8
a13021 1
		intel_crtc = to_intel_crtc(intel_encoder->base.crtc);
d13023 3
a13025 3
		if (prepare_pipes & (1 << intel_crtc->pipe))
			intel_encoder->connectors_active = false;
	}
d13027 7
a13033 1
	intel_modeset_commit_output_state(dev);
d13035 1
a13035 5
	/* Update computed state. */
	list_for_each_entry(intel_crtc, &dev->mode_config.crtc_list,
			    base.head) {
		intel_crtc->base.enabled = intel_crtc_in_use(&intel_crtc->base);
	}
d13037 2
a13038 2
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder || !connector->encoder->crtc)
d13041 3
a13043 1
		intel_crtc = to_intel_crtc(connector->encoder->crtc);
d13045 2
a13046 8
		if (prepare_pipes & (1 << intel_crtc->pipe)) {
			struct drm_property *dpms_property =
				dev->mode_config.dpms_property;

			connector->dpms = DRM_MODE_DPMS_ON;
			drm_object_property_set_value(&connector->base,
							 dpms_property,
							 DRM_MODE_DPMS_ON);
d13048 4
a13051 4
			intel_encoder = to_intel_encoder(connector->encoder);
			intel_encoder->connectors_active = true;
		}
	}
d13053 1
d13056 1
a13056 1
static bool intel_fuzzy_clock_check(int clock1, int clock2)
d13058 9
a13066 1
	int diff;
d13068 2
a13069 2
	if (clock1 == clock2)
		return true;
d13071 1
a13071 2
	if (!clock1 || !clock2)
		return false;
d13073 3
a13075 1
	diff = abs(clock1 - clock2);
d13077 4
a13080 2
	if (((((diff + clock1 + clock2) * 100)) / (clock1 + clock2)) < 105)
		return true;
d13082 1
a13082 1
	return false;
d13085 5
a13089 5
#define for_each_intel_crtc_masked(dev, mask, intel_crtc) \
	list_for_each_entry((intel_crtc), \
			    &(dev)->mode_config.crtc_list, \
			    base.head) \
		if (mask & (1 <<(intel_crtc)->pipe))
d13091 3
a13093 12
static bool
intel_pipe_config_compare(struct drm_device *dev,
			  struct intel_crtc_config *current_config,
			  struct intel_crtc_config *pipe_config)
{
#define PIPE_CONF_CHECK_X(name)	\
	if (current_config->name != pipe_config->name) { \
		DRM_ERROR("mismatch in " #name " " \
			  "(expected 0x%08x, found 0x%08x)\n", \
			  current_config->name, \
			  pipe_config->name); \
		return false; \
d13096 9
a13104 8
#define PIPE_CONF_CHECK_I(name)	\
	if (current_config->name != pipe_config->name) { \
		DRM_ERROR("mismatch in " #name " " \
			  "(expected %i, found %i)\n", \
			  current_config->name, \
			  pipe_config->name); \
		return false; \
	}
d13106 1
a13106 8
#define PIPE_CONF_CHECK_FLAGS(name, mask)	\
	if ((current_config->name ^ pipe_config->name) & (mask)) { \
		DRM_ERROR("mismatch in " #name "(" #mask ") "	   \
			  "(expected %i, found %i)\n", \
			  current_config->name & (mask), \
			  pipe_config->name & (mask)); \
		return false; \
	}
d13108 3
a13110 8
#define PIPE_CONF_CHECK_CLOCK_FUZZY(name) \
	if (!intel_fuzzy_clock_check(current_config->name, pipe_config->name)) { \
		DRM_ERROR("mismatch in " #name " " \
			  "(expected %i, found %i)\n", \
			  current_config->name, \
			  pipe_config->name); \
		return false; \
	}
d13112 4
a13115 2
#define PIPE_CONF_QUIRK(quirk)	\
	((current_config->quirks | pipe_config->quirks) & (quirk))
d13117 1
a13117 1
	PIPE_CONF_CHECK_I(cpu_transcoder);
d13119 2
a13120 7
	PIPE_CONF_CHECK_I(has_pch_encoder);
	PIPE_CONF_CHECK_I(fdi_lanes);
	PIPE_CONF_CHECK_I(fdi_m_n.gmch_m);
	PIPE_CONF_CHECK_I(fdi_m_n.gmch_n);
	PIPE_CONF_CHECK_I(fdi_m_n.link_m);
	PIPE_CONF_CHECK_I(fdi_m_n.link_n);
	PIPE_CONF_CHECK_I(fdi_m_n.tu);
d13122 2
a13123 20
	PIPE_CONF_CHECK_I(has_dp_encoder);
	PIPE_CONF_CHECK_I(dp_m_n.gmch_m);
	PIPE_CONF_CHECK_I(dp_m_n.gmch_n);
	PIPE_CONF_CHECK_I(dp_m_n.link_m);
	PIPE_CONF_CHECK_I(dp_m_n.link_n);
	PIPE_CONF_CHECK_I(dp_m_n.tu);

	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hdisplay);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_htotal);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hblank_start);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hblank_end);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hsync_start);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_hsync_end);

	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vdisplay);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vtotal);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vblank_start);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vblank_end);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vsync_start);
	PIPE_CONF_CHECK_I(adjusted_mode.crtc_vsync_end);
d13125 12
a13136 1
	PIPE_CONF_CHECK_I(pixel_multiplier);
d13138 3
a13140 2
	PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
			      DRM_MODE_FLAG_INTERLACE);
d13142 16
a13157 10
	if (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_MODE_SYNC_FLAGS)) {
		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
				      DRM_MODE_FLAG_PHSYNC);
		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
				      DRM_MODE_FLAG_NHSYNC);
		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
				      DRM_MODE_FLAG_PVSYNC);
		PIPE_CONF_CHECK_FLAGS(adjusted_mode.flags,
				      DRM_MODE_FLAG_NVSYNC);
	}
d13159 2
a13160 2
	PIPE_CONF_CHECK_I(pipe_src_w);
	PIPE_CONF_CHECK_I(pipe_src_h);
d13162 2
a13163 15
	/*
	 * FIXME: BIOS likes to set up a cloned config with lvds+external
	 * screen. Since we don't yet re-compute the pipe config when moving
	 * just the lvds port away to another pipe the sw tracking won't match.
	 *
	 * Proper atomic modesets with recomputed global state will fix this.
	 * Until then just don't check gmch state for inherited modes.
	 */
	if (!PIPE_CONF_QUIRK(PIPE_CONFIG_QUIRK_INHERITED_MODE)) {
		PIPE_CONF_CHECK_I(gmch_pfit.control);
		/* pfit ratios are autocomputed by the hw on gen4+ */
		if (INTEL_INFO(dev)->gen < 4)
			PIPE_CONF_CHECK_I(gmch_pfit.pgm_ratios);
		PIPE_CONF_CHECK_I(gmch_pfit.lvds_border_bits);
	}
d13165 3
a13167 5
	PIPE_CONF_CHECK_I(pch_pfit.enabled);
	if (current_config->pch_pfit.enabled) {
		PIPE_CONF_CHECK_I(pch_pfit.pos);
		PIPE_CONF_CHECK_I(pch_pfit.size);
	}
d13169 3
a13171 3
	/* BDW+ don't expose a synchronous way to read the state */
	if (IS_HASWELL(dev))
		PIPE_CONF_CHECK_I(ips_enabled);
d13173 7
a13179 1
	PIPE_CONF_CHECK_I(double_wide);
d13181 2
a13182 5
	PIPE_CONF_CHECK_I(shared_dpll);
	PIPE_CONF_CHECK_X(dpll_hw_state.dpll);
	PIPE_CONF_CHECK_X(dpll_hw_state.dpll_md);
	PIPE_CONF_CHECK_X(dpll_hw_state.fp0);
	PIPE_CONF_CHECK_X(dpll_hw_state.fp1);
d13184 4
a13187 2
	if (IS_G4X(dev) || INTEL_INFO(dev)->gen >= 5)
		PIPE_CONF_CHECK_I(pipe_bpp);
d13189 3
a13191 3
	if (!HAS_DDI(dev)) {
		PIPE_CONF_CHECK_CLOCK_FUZZY(adjusted_mode.crtc_clock);
		PIPE_CONF_CHECK_CLOCK_FUZZY(port_clock);
d13194 8
a13201 5
#undef PIPE_CONF_CHECK_X
#undef PIPE_CONF_CHECK_I
#undef PIPE_CONF_CHECK_FLAGS
#undef PIPE_CONF_CHECK_CLOCK_FUZZY
#undef PIPE_CONF_QUIRK
d13203 1
a13203 1
	return true;
d13206 19
a13224 2
static void
check_connector_state(struct drm_device *dev)
d13226 6
a13231 1
	struct intel_connector *connector;
d13233 3
a13235 8
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		/* This also checks the encoder/connector hw state with the
		 * ->get_hw_state callbacks. */
		intel_connector_check_state(connector);

		WARN(&connector->new_encoder->base != connector->base.encoder,
		     "connector's staged encoder doesn't match current encoder\n");
a13236 1
}
d13238 3
a13240 5
static void
check_encoder_state(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	struct intel_connector *connector;
d13242 1
a13242 5
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		bool enabled = false;
		bool active = false;
		enum pipe pipe, tracked_pipe;
d13244 2
a13245 23
		DRM_DEBUG_KMS("[ENCODER:%d:%s]\n",
			      encoder->base.base.id,
			      drm_get_encoder_name(&encoder->base));

		WARN(&encoder->new_crtc->base != encoder->base.crtc,
		     "encoder's stage crtc doesn't match current crtc\n");
		WARN(encoder->connectors_active && !encoder->base.crtc,
		     "encoder's active_connectors set, but no crtc\n");

		list_for_each_entry(connector, &dev->mode_config.connector_list,
				    base.head) {
			if (connector->base.encoder != &encoder->base)
				continue;
			enabled = true;
			if (connector->base.dpms != DRM_MODE_DPMS_OFF)
				active = true;
		}
		WARN(!!encoder->base.crtc != enabled,
		     "encoder's enabled state mismatch "
		     "(expected %i, found %i)\n",
		     !!encoder->base.crtc, enabled);
		WARN(active && !encoder->base.crtc,
		     "active encoder with no crtc\n");
d13247 1
a13247 11
		WARN(encoder->connectors_active != active,
		     "encoder's computed active state doesn't match tracked active state "
		     "(expected %i, found %i)\n", active, encoder->connectors_active);

		active = encoder->get_hw_state(encoder, &pipe);
		WARN(active != encoder->connectors_active,
		     "encoder's hw state doesn't match sw tracking "
		     "(expected %i, found %i)\n",
		     encoder->connectors_active, active);

		if (!encoder->base.crtc)
d13250 2
a13251 5
		tracked_pipe = to_intel_crtc(encoder->base.crtc)->pipe;
		WARN(active && pipe != tracked_pipe,
		     "active encoder's pipe doesn't match"
		     "(expected %i, found %i)\n",
		     tracked_pipe, pipe);
d13253 6
a13259 1
}
d13261 3
a13263 17
static void
check_crtc_state(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_crtc *crtc;
	struct intel_encoder *encoder;
	struct intel_crtc_config pipe_config;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list,
			    base.head) {
		bool enabled = false;
		bool active = false;

		memset(&pipe_config, 0, sizeof(pipe_config));

		DRM_DEBUG_KMS("[CRTC:%d]\n",
			      crtc->base.base.id);
d13265 2
a13266 2
		WARN(crtc->active && !crtc->base.enabled,
		     "active crtc, but not enabled in sw tracking\n");
d13268 3
a13270 8
		list_for_each_entry(encoder, &dev->mode_config.encoder_list,
				    base.head) {
			if (encoder->base.crtc != &crtc->base)
				continue;
			enabled = true;
			if (encoder->connectors_active)
				active = true;
		}
d13272 7
a13278 13
		WARN(active != crtc->active,
		     "crtc's computed active state doesn't match tracked active state "
		     "(expected %i, found %i)\n", active, crtc->active);
		WARN(enabled != crtc->base.enabled,
		     "crtc's computed enabled state doesn't match tracked enabled state "
		     "(expected %i, found %i)\n", enabled, crtc->base.enabled);

		active = dev_priv->display.get_pipe_config(crtc,
							   &pipe_config);

		/* hw state is inconsistent with the pipe A quirk */
		if (crtc->pipe == PIPE_A && dev_priv->quirks & QUIRK_PIPEA_FORCE)
			active = crtc->active;
d13280 3
a13282 7
		list_for_each_entry(encoder, &dev->mode_config.encoder_list,
				    base.head) {
			enum pipe pipe;
			if (encoder->base.crtc != &crtc->base)
				continue;
			if (encoder->get_hw_state(encoder, &pipe))
				encoder->get_config(encoder, &pipe_config);
d13285 2
a13286 3
		WARN(crtc->active != active,
		     "crtc active state doesn't match with hw state "
		     "(expected %i, found %i)\n", crtc->active, active);
d13288 2
a13289 7
		if (active &&
		    !intel_pipe_config_compare(dev, &crtc->config, &pipe_config)) {
			WARN(1, "pipe state doesn't match!\n");
			intel_dump_pipe_config(crtc, &pipe_config,
					       "[hw state]");
			intel_dump_pipe_config(crtc, &crtc->config,
					       "[sw state]");
a13290 10
	}
}

static void
check_shared_dpll_state(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_crtc *crtc;
	struct intel_dpll_hw_state dpll_hw_state;
	int i;
d13292 2
a13293 4
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		struct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];
		int enabled_crtcs = 0, active_crtcs = 0;
		bool active;
d13295 1
a13295 1
		memset(&dpll_hw_state, 0, sizeof(dpll_hw_state));
d13297 2
a13298 1
		DRM_DEBUG_KMS("%s\n", pll->name);
d13300 2
a13301 1
		active = pll->get_hw_state(dev_priv, pll, &dpll_hw_state);
d13303 1
a13303 10
		WARN(pll->active > pll->refcount,
		     "more active pll users than references: %i vs %i\n",
		     pll->active, pll->refcount);
		WARN(pll->active && !pll->on,
		     "pll in active use but not on in sw tracking\n");
		WARN(pll->on && !pll->active,
		     "pll in on but not on in use in sw tracking\n");
		WARN(pll->on != active,
		     "pll on state mismatch (expected %i, found %i)\n",
		     pll->on, active);
d13305 2
a13306 13
		list_for_each_entry(crtc, &dev->mode_config.crtc_list,
				    base.head) {
			if (crtc->base.enabled && intel_crtc_to_shared_dpll(crtc) == pll)
				enabled_crtcs++;
			if (crtc->active && intel_crtc_to_shared_dpll(crtc) == pll)
				active_crtcs++;
		}
		WARN(pll->active != active_crtcs,
		     "pll active crtcs mismatch (expected %i, found %i)\n",
		     pll->active, active_crtcs);
		WARN(pll->refcount != enabled_crtcs,
		     "pll enabled crtcs mismatch (expected %i, found %i)\n",
		     pll->refcount, enabled_crtcs);
d13308 2
a13309 5
		WARN(pll->on && memcmp(&pll->hw_state, &dpll_hw_state,
				       sizeof(dpll_hw_state)),
		     "pll hw state mismatch\n");
	}
}
d13311 1
a13311 8
void
intel_modeset_check_state(struct drm_device *dev)
{
	check_connector_state(dev);
	check_encoder_state(dev);
	check_crtc_state(dev);
	check_shared_dpll_state(dev);
}
d13313 1
a13313 10
void ironlake_check_encoder_dotclock(const struct intel_crtc_config *pipe_config,
				     int dotclock)
{
	/*
	 * FDI already provided one idea for the dotclock.
	 * Yell if the encoder disagrees.
	 */
	WARN(!intel_fuzzy_clock_check(pipe_config->adjusted_mode.crtc_clock, dotclock),
	     "FDI dotclock and encoder dotclock mismatch, fdi: %i, encoder: %i\n",
	     pipe_config->adjusted_mode.crtc_clock, dotclock);
d13316 1
a13316 3
static int __intel_set_mode(struct drm_crtc *crtc,
			    struct drm_display_mode *mode,
			    int x, int y, struct drm_framebuffer *fb)
d13319 3
a13321 6
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_display_mode *saved_mode;
	struct intel_crtc_config *pipe_config = NULL;
	struct intel_crtc *intel_crtc;
	unsigned disable_pipes, prepare_pipes, modeset_pipes;
	int ret = 0;
d13323 6
a13328 3
	saved_mode = kmalloc(sizeof(*saved_mode), GFP_KERNEL);
	if (!saved_mode)
		return -ENOMEM;
d13330 1
a13330 2
	intel_modeset_affected_pipes(crtc, &modeset_pipes,
				     &prepare_pipes, &disable_pipes);
d13332 6
a13337 1
	*saved_mode = crtc->mode;
d13339 3
a13341 10
	/* Hack: Because we don't (yet) support global modeset on multiple
	 * crtcs, we don't keep track of the new mode for more than one crtc.
	 * Hence simply check whether any bit is set in modeset_pipes in all the
	 * pieces of code that are not yet converted to deal with mutliple crtcs
	 * changing their mode at the same time. */
	if (modeset_pipes) {
		pipe_config = intel_modeset_pipe_config(crtc, fb, mode);
		if (IS_ERR(pipe_config)) {
			ret = PTR_ERR(pipe_config);
			pipe_config = NULL;
d13343 4
a13346 4
			goto out;
		}
		intel_dump_pipe_config(to_intel_crtc(crtc), pipe_config,
				       "[modeset]");
d13349 4
a13352 10
	/*
	 * See if the config requires any additional preparation, e.g.
	 * to adjust global state with pipes off.  We need to do this
	 * here so we can get the modeset_pipe updated config for the new
	 * mode set on this crtc.  For other crtcs we need to use the
	 * adjusted_mode bits in the crtc directly.
	 */
	if (IS_VALLEYVIEW(dev)) {
		valleyview_modeset_global_pipes(dev, &prepare_pipes,
						modeset_pipes, pipe_config);
d13354 1
a13354 3
		/* may have added more to prepare_pipes than we should */
		prepare_pipes &= ~disable_pipes;
	}
d13356 8
a13363 2
	for_each_intel_crtc_masked(dev, disable_pipes, intel_crtc)
		intel_crtc_disable(&intel_crtc->base);
d13365 5
a13369 4
	for_each_intel_crtc_masked(dev, prepare_pipes, intel_crtc) {
		if (intel_crtc->base.enabled)
			dev_priv->display.crtc_disable(&intel_crtc->base);
	}
d13371 2
a13372 8
	/* crtc->mode is already used by the ->mode_set callbacks, hence we need
	 * to set it here already despite that we pass it down the callchain.
	 */
	if (modeset_pipes) {
		crtc->mode = *mode;
		/* mode_set/enable/disable functions rely on a correct pipe
		 * config. */
		to_intel_crtc(crtc)->config = *pipe_config;
d13374 4
a13377 8
		/*
		 * Calculate and store various constants which
		 * are later needed by vblank and swap-completion
		 * timestamping. They are derived from true hwmode.
		 */
		drm_calc_timestamping_constants(crtc,
						&pipe_config->adjusted_mode);
	}
d13379 2
a13380 3
	/* Only after disabling all output pipelines that will be changed can we
	 * update the the output configuration. */
	intel_modeset_update_state(dev, prepare_pipes);
d13382 6
a13387 2
	if (dev_priv->display.modeset_global_resources)
		dev_priv->display.modeset_global_resources(dev);
d13389 5
a13393 9
	/* Set up the DPLL and any encoders state that needs to adjust or depend
	 * on the DPLL.
	 */
	for_each_intel_crtc_masked(dev, modeset_pipes, intel_crtc) {
		ret = intel_crtc_mode_set(&intel_crtc->base,
					  x, y, fb);
		if (ret)
			goto done;
	}
d13395 1
a13395 3
	/* Now enable the clocks, plane, pipe, and connectors that we set up. */
	for_each_intel_crtc_masked(dev, prepare_pipes, intel_crtc)
		dev_priv->display.crtc_enable(&intel_crtc->base);
d13397 3
a13399 4
	/* FIXME: add subpixel order */
done:
	if (ret && crtc->enabled)
		crtc->mode = *saved_mode;
d13401 8
a13408 4
out:
	kfree(pipe_config);
	kfree(saved_mode);
	return ret;
d13411 2
a13412 3
static int intel_set_mode(struct drm_crtc *crtc,
			  struct drm_display_mode *mode,
			  int x, int y, struct drm_framebuffer *fb)
d13414 2
a13415 1
	int ret;
d13417 5
a13421 1
	ret = __intel_set_mode(crtc, mode, x, y, fb);
d13423 4
a13426 2
	if (ret == 0)
		intel_modeset_check_state(crtc->dev);
d13428 4
a13431 2
	return ret;
}
d13433 1
a13433 1
void intel_crtc_restore_mode(struct drm_crtc *crtc)
d13435 14
a13448 1
	intel_set_mode(crtc, &crtc->mode, crtc->x, crtc->y, crtc->fb);
d13451 3
a13453 1
#undef for_each_intel_crtc_masked
d13455 6
a13460 4
static void intel_set_config_free(struct intel_set_config *config)
{
	if (!config)
		return;
d13462 1
a13462 3
	kfree(config->save_connector_encoders);
	kfree(config->save_encoder_crtcs);
	kfree(config);
d13465 15
a13479 2
static int intel_set_config_save_state(struct drm_device *dev,
				       struct intel_set_config *config)
d13481 6
a13486 3
	struct drm_encoder *encoder;
	struct drm_connector *connector;
	int count;
d13488 2
a13489 5
	config->save_encoder_crtcs =
		kcalloc(dev->mode_config.num_encoder,
			sizeof(struct drm_crtc *), GFP_KERNEL);
	if (!config->save_encoder_crtcs)
		return -ENOMEM;
d13491 1
a13491 5
	config->save_connector_encoders =
		kcalloc(dev->mode_config.num_connector,
			sizeof(struct drm_encoder *), GFP_KERNEL);
	if (!config->save_connector_encoders)
		return -ENOMEM;
d13493 8
a13500 7
	/* Copy data. Note that driver private data is not affected.
	 * Should anything bad happen only the expected state is
	 * restored, not the drivers personal bookkeeping.
	 */
	count = 0;
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
		config->save_encoder_crtcs[count++] = encoder->crtc;
d13503 4
a13506 4
	count = 0;
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		config->save_connector_encoders[count++] = connector->encoder;
	}
d13508 1
a13508 1
	return 0;
d13511 10
a13520 2
static void intel_set_config_restore_state(struct drm_device *dev,
					   struct intel_set_config *config)
d13522 2
a13523 3
	struct intel_encoder *encoder;
	struct intel_connector *connector;
	int count;
d13525 2
a13526 5
	count = 0;
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, base.head) {
		encoder->new_crtc =
			to_intel_crtc(config->save_encoder_crtcs[count++]);
	}
d13528 5
a13532 4
	count = 0;
	list_for_each_entry(connector, &dev->mode_config.connector_list, base.head) {
		connector->new_encoder =
			to_intel_encoder(config->save_connector_encoders[count++]);
d13536 2
a13537 2
static bool
is_crtc_connector_off(struct drm_mode_set *set)
d13539 12
a13550 1
	int i;
d13552 2
a13553 2
	if (set->num_connectors == 0)
		return false;
d13555 7
a13561 2
	if (WARN_ON(set->connectors == NULL))
		return false;
d13563 2
a13564 5
	for (i = 0; i < set->num_connectors; i++)
		if (set->connectors[i]->encoder &&
		    set->connectors[i]->encoder->crtc == set->crtc &&
		    set->connectors[i]->dpms != DRM_MODE_DPMS_ON)
			return true;
d13566 25
a13590 1
	return false;
d13594 2
a13595 2
intel_set_config_compute_mode_changes(struct drm_mode_set *set,
				      struct intel_set_config *config)
d13597 6
d13604 2
a13605 26
	/* We should be able to check here if the fb has the same properties
	 * and then just flip_or_move it */
	if (is_crtc_connector_off(set)) {
		config->mode_changed = true;
	} else if (set->crtc->fb != set->fb) {
		/* If we have no fb then treat it as a full mode set */
		if (set->crtc->fb == NULL) {
			struct intel_crtc *intel_crtc =
				to_intel_crtc(set->crtc);

			if (intel_crtc->active && i915_fastboot) {
				DRM_DEBUG_KMS("crtc has no fb, will flip\n");
				config->fb_changed = true;
			} else {
				DRM_DEBUG_KMS("inactive crtc, full mode set\n");
				config->mode_changed = true;
			}
		} else if (set->fb == NULL) {
			config->mode_changed = true;
		} else if (set->fb->pixel_format !=
			   set->crtc->fb->pixel_format) {
			config->mode_changed = true;
		} else {
			config->fb_changed = true;
		}
	}
d13607 3
a13609 2
	if (set->fb && (set->x != set->crtc->x || set->y != set->crtc->y))
		config->fb_changed = true;
d13611 2
a13612 6
	if (set->mode && !drm_mode_equal(set->mode, &set->crtc->mode)) {
		DRM_DEBUG_KMS("modes are different, full mode set\n");
		drm_mode_debug_printmodeline(&set->crtc->mode);
		drm_mode_debug_printmodeline(set->mode);
		config->mode_changed = true;
	}
d13614 3
a13616 2
	DRM_DEBUG_KMS("computed changes for [CRTC:%d], mode_changed=%d, fb_changed=%d\n",
			set->crtc->base.id, config->mode_changed, config->fb_changed);
d13619 3
a13621 4
static int
intel_modeset_stage_output_state(struct drm_device *dev,
				 struct drm_mode_set *set,
				 struct intel_set_config *config)
d13623 2
a13624 4
	struct drm_crtc *new_crtc;
	struct intel_connector *connector;
	struct intel_encoder *encoder;
	int ro;
d13626 2
a13627 15
	/* The upper layers ensure that we either disable a crtc or have a list
	 * of connectors. For paranoia, double-check this. */
	WARN_ON(!set->fb && (set->num_connectors != 0));
	WARN_ON(set->fb && (set->num_connectors == 0));

	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		/* Otherwise traverse passed in connector list and get encoders
		 * for them. */
		for (ro = 0; ro < set->num_connectors; ro++) {
			if (set->connectors[ro] == &connector->base) {
				connector->new_encoder = connector->encoder;
				break;
			}
		}
d13629 8
a13636 20
		/* If we disable the crtc, disable all its connectors. Also, if
		 * the connector is on the changing crtc but not on the new
		 * connector list, disable it. */
		if ((!set->fb || ro == set->num_connectors) &&
		    connector->base.encoder &&
		    connector->base.encoder->crtc == set->crtc) {
			connector->new_encoder = NULL;

			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [NOCRTC]\n",
				connector->base.base.id,
				drm_get_connector_name(&connector->base));
		}


		if (&connector->new_encoder->base != connector->base.encoder) {
			DRM_DEBUG_KMS("encoder changed, full mode switch\n");
			config->mode_changed = true;
		}
	}
	/* connector->new_encoder is now updated for all connectors. */
d13638 2
a13639 5
	/* Update crtc of enabled connectors. */
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
		if (!connector->new_encoder)
			continue;
d13641 3
a13643 1
		new_crtc = connector->new_encoder->base.crtc;
d13645 2
a13646 4
		for (ro = 0; ro < set->num_connectors; ro++) {
			if (set->connectors[ro] == &connector->base)
				new_crtc = set->crtc;
		}
d13648 5
a13652 6
		/* Make sure the new CRTC will work with the encoder */
		if (!drm_encoder_crtc_ok(&connector->new_encoder->base,
					 new_crtc)) {
			return -EINVAL;
		}
		connector->encoder->new_crtc = to_intel_crtc(new_crtc);
d13654 4
a13657 18
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [CRTC:%d]\n",
			connector->base.base.id,
			drm_get_connector_name(&connector->base),
			new_crtc->base.id);
	}

	/* Check for any encoders that needs to be disabled. */
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		int num_connectors = 0;
		list_for_each_entry(connector,
				    &dev->mode_config.connector_list,
				    base.head) {
			if (connector->new_encoder == encoder) {
				WARN_ON(!connector->new_encoder->new_crtc);
				num_connectors++;
			}
		}
d13659 3
a13661 4
		if (num_connectors == 0)
			encoder->new_crtc = NULL;
		else if (num_connectors > 1)
			return -EINVAL;
d13663 23
a13685 8
		/* Only now check for crtc changes so we don't miss encoders
		 * that will be disabled. */
		if (&encoder->new_crtc->base != encoder->base.crtc) {
			DRM_DEBUG_KMS("crtc changed, full mode switch\n");
			config->mode_changed = true;
		}
	}
	/* Now we've also updated encoder->new_crtc for all encoders. */
d13687 1
a13687 2
	return 0;
}
d13689 2
a13690 1
static int intel_crtc_set_config(struct drm_mode_set *set)
d13692 4
a13695 4
	struct drm_device *dev;
	struct drm_mode_set save_set;
	struct intel_set_config *config;
	int ret;
d13697 3
a13699 3
	BUG_ON(!set);
	BUG_ON(!set->crtc);
	BUG_ON(!set->crtc->helper_private);
d13701 6
a13706 3
	/* Enforce sane interface api - has been abused by the fb helper. */
	BUG_ON(!set->mode && set->fb);
	BUG_ON(set->fb && set->num_connectors == 0);
d13708 21
a13728 4
	if (set->fb) {
		DRM_DEBUG_KMS("[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n",
				set->crtc->base.id, set->fb->base.id,
				(int)set->num_connectors, set->x, set->y);
d13730 2
a13731 1
		DRM_DEBUG_KMS("[CRTC:%d] [NOFB]\n", set->crtc->base.id);
d13734 4
a13737 1
	dev = set->crtc->dev;
d13739 2
a13740 4
	ret = -ENOMEM;
	config = kzalloc(sizeof(*config), GFP_KERNEL);
	if (!config)
		goto out_config;
d13742 1
a13742 3
	ret = intel_set_config_save_state(dev, config);
	if (ret)
		goto out_config;
d13744 2
a13745 11
	save_set.crtc = set->crtc;
	save_set.mode = &set->crtc->mode;
	save_set.x = set->crtc->x;
	save_set.y = set->crtc->y;
	save_set.fb = set->crtc->fb;

	/* Compute whether we need a full modeset, only an fb base update or no
	 * change at all. In the future we might also check whether only the
	 * mode changed, e.g. for LVDS where we only change the panel fitter in
	 * such cases. */
	intel_set_config_compute_mode_changes(set, config);
d13747 5
a13751 3
	ret = intel_modeset_stage_output_state(dev, set, config);
	if (ret)
		goto fail;
d13753 2
a13754 5
	if (config->mode_changed) {
		ret = intel_set_mode(set->crtc, set->mode,
				     set->x, set->y, set->fb);
	} else if (config->fb_changed) {
		intel_crtc_wait_for_pending_flips(set->crtc);
d13756 2
a13757 12
		ret = intel_pipe_set_base(set->crtc,
					  set->x, set->y, set->fb);
		/*
		 * In the fastboot case this may be our only check of the
		 * state after boot.  It would be better to only do it on
		 * the first update, but we don't have a nice way of doing that
		 * (and really, set_config isn't used much for high freq page
		 * flipping, so increasing its cost here shouldn't be a big
		 * deal).
		 */
		if (i915_fastboot && ret == 0)
			intel_modeset_check_state(set->crtc->dev);
d13759 5
d13765 11
a13775 5
	if (ret) {
		DRM_DEBUG_KMS("failed to set mode on [CRTC:%d], err = %d\n",
			      set->crtc->base.id, ret);
fail:
		intel_set_config_restore_state(dev, config);
d13777 7
a13783 6
		/* Try to restore the config */
		if (config->mode_changed &&
		    intel_set_mode(save_set.crtc, save_set.mode,
				   save_set.x, save_set.y, save_set.fb))
			DRM_ERROR("failed to restore config after modeset failure\n");
	}
d13785 3
a13787 4
out_config:
	intel_set_config_free(config);
	return ret;
}
d13789 6
a13794 8
static const struct drm_crtc_funcs intel_crtc_funcs = {
	.cursor_set = intel_crtc_cursor_set,
	.cursor_move = intel_crtc_cursor_move,
	.gamma_set = intel_crtc_gamma_set,
	.set_config = intel_crtc_set_config,
	.destroy = intel_crtc_destroy,
	.page_flip = intel_crtc_page_flip,
};
d13796 5
a13800 5
static void intel_cpu_pll_init(struct drm_device *dev)
{
	if (HAS_DDI(dev))
		intel_ddi_pll_init(dev);
}
d13802 4
a13805 5
static bool ibx_pch_dpll_get_hw_state(struct drm_i915_private *dev_priv,
				      struct intel_shared_dpll *pll,
				      struct intel_dpll_hw_state *hw_state)
{
	uint32_t val;
d13807 15
a13821 4
	val = I915_READ(PCH_DPLL(pll->id));
	hw_state->dpll = val;
	hw_state->fp0 = I915_READ(PCH_FP0(pll->id));
	hw_state->fp1 = I915_READ(PCH_FP1(pll->id));
d13823 1
a13823 1
	return val & DPLL_VCO_ENABLE;
d13826 3
a13828 2
static void ibx_pch_dpll_mode_set(struct drm_i915_private *dev_priv,
				  struct intel_shared_dpll *pll)
d13830 1
a13830 2
	I915_WRITE(PCH_FP0(pll->id), pll->hw_state.fp0);
	I915_WRITE(PCH_FP1(pll->id), pll->hw_state.fp1);
d13833 3
a13835 2
static void ibx_pch_dpll_enable(struct drm_i915_private *dev_priv,
				struct intel_shared_dpll *pll)
d13837 8
a13844 2
	/* PCH refclock must be enabled first */
	ibx_assert_pch_refclk_enabled(dev_priv);
d13846 6
a13851 1
	I915_WRITE(PCH_DPLL(pll->id), pll->hw_state.dpll);
d13853 1
a13853 3
	/* Wait for the clocks to stabilize. */
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(150);
d13855 2
a13856 8
	/* The pixel multiplier can only be updated once the
	 * DPLL is enabled and the clocks are stable.
	 *
	 * So write it again.
	 */
	I915_WRITE(PCH_DPLL(pll->id), pll->hw_state.dpll);
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(200);
d13859 2
a13860 2
static void ibx_pch_dpll_disable(struct drm_i915_private *dev_priv,
				 struct intel_shared_dpll *pll)
d13862 6
a13867 2
	struct drm_device *dev = dev_priv->dev;
	struct intel_crtc *crtc;
d13869 4
a13872 4
	/* Make sure no transcoder isn't still depending on us. */
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, base.head) {
		if (intel_crtc_to_shared_dpll(crtc) == pll)
			assert_pch_transcoder_disabled(dev_priv, crtc->pipe);
d13874 1
d13876 14
a13889 4
	I915_WRITE(PCH_DPLL(pll->id), 0);
	POSTING_READ(PCH_DPLL(pll->id));
	udelay(200);
}
d13891 11
a13901 4
static char *ibx_pch_dpll_names[] = {
	"PCH DPLL A",
	"PCH DPLL B",
};
d13903 2
a13904 4
static void ibx_pch_dpll_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;
d13906 1
a13906 1
	dev_priv->num_shared_dpll = 2;
d13908 1
a13908 9
	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
		dev_priv->shared_dplls[i].id = i;
		dev_priv->shared_dplls[i].name = ibx_pch_dpll_names[i];
		dev_priv->shared_dplls[i].mode_set = ibx_pch_dpll_mode_set;
		dev_priv->shared_dplls[i].enable = ibx_pch_dpll_enable;
		dev_priv->shared_dplls[i].disable = ibx_pch_dpll_disable;
		dev_priv->shared_dplls[i].get_hw_state =
			ibx_pch_dpll_get_hw_state;
	}
d13911 2
a13912 1
static void intel_shared_dpll_init(struct drm_device *dev)
d13914 3
a13916 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d13918 5
a13922 4
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		ibx_pch_dpll_init(dev);
	else
		dev_priv->num_shared_dpll = 0;
d13924 1
a13924 1
	BUG_ON(dev_priv->num_shared_dpll > I915_NUM_PLLS);
d13929 1
a13929 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d13931 4
a13934 1
	int i;
d13940 29
a13968 1
	drm_crtc_init(dev, &intel_crtc->base, &intel_crtc_funcs);
d13979 1
a13979 1
	 * is hooked to plane B. Hence we want plane A feeding pipe B.
d13988 6
d14000 11
d14016 1
d14018 1
a14018 1
	WARN_ON(!mutex_is_locked(&connector->base.dev->mode_config.mutex));
d14020 1
a14020 1
	if (!encoder)
d14030 1
a14030 1
	struct drm_mode_object *drmmode_obj;
d14033 1
a14033 5
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -ENODEV;

	drmmode_obj = drm_mode_object_find(dev, pipe_from_crtc_id->crtc_id,
			DRM_MODE_OBJECT_CRTC);
d14035 1
a14035 1
	if (!drmmode_obj) {
d14040 1
a14040 1
	crtc = to_intel_crtc(obj_to_crtc(drmmode_obj));
d14053 2
a14054 8
	list_for_each_entry(source_encoder,
			    &dev->mode_config.encoder_list, base.head) {

		if (encoder == source_encoder)
			index_mask |= (1 << entry);

		/* Intel hw has only one MUX where enocoders could be cloned. */
		if (encoder->cloneable && source_encoder->cloneable)
d14073 1
a14073 2
	if (IS_GEN5(dev) &&
	    (I915_READ(ILK_DISPLAY_CHICKEN_FUSES) & ILK_eDP_A_DISABLE))
d14079 1
a14079 1
const char *intel_output_name(int output)
d14081 10
a14090 13
	static const char *names[] = {
		[INTEL_OUTPUT_UNUSED] = "Unused",
		[INTEL_OUTPUT_ANALOG] = "Analog",
		[INTEL_OUTPUT_DVO] = "DVO",
		[INTEL_OUTPUT_SDVO] = "SDVO",
		[INTEL_OUTPUT_LVDS] = "LVDS",
		[INTEL_OUTPUT_TVOUT] = "TV",
		[INTEL_OUTPUT_HDMI] = "HDMI",
		[INTEL_OUTPUT_DISPLAYPORT] = "DisplayPort",
		[INTEL_OUTPUT_EDP] = "eDP",
		[INTEL_OUTPUT_DSI] = "DSI",
		[INTEL_OUTPUT_UNKNOWN] = "Unknown",
	};
d14092 2
a14093 2
	if (output < 0 || output >= ARRAY_SIZE(names) || !names[output])
		return "Invalid";
d14095 1
a14095 1
	return names[output];
d14106 1
a14106 1
	if (!IS_ULT(dev))
d14109 10
a14118 1
	if (HAS_DDI(dev)) {
d14121 8
a14128 4
		/* Haswell uses DDI functions to detect digital outputs */
		found = I915_READ(DDI_BUF_CTL_A) & DDI_INIT_DISPLAY_DETECTED;
		/* DDI A only supports eDP */
		if (found)
d14141 9
d14178 30
a14207 6
		if (I915_READ(VLV_DISPLAY_BASE + GEN4_HDMIB) & SDVO_DETECTED) {
			intel_hdmi_init(dev, VLV_DISPLAY_BASE + GEN4_HDMIB,
					PORT_B);
			if (I915_READ(VLV_DISPLAY_BASE + DP_B) & DP_DETECTED)
				intel_dp_init(dev, VLV_DISPLAY_BASE + DP_B, PORT_B);
		}
d14209 10
a14218 5
		if (I915_READ(VLV_DISPLAY_BASE + GEN4_HDMIC) & SDVO_DETECTED) {
			intel_hdmi_init(dev, VLV_DISPLAY_BASE + GEN4_HDMIC,
					PORT_C);
			if (I915_READ(VLV_DISPLAY_BASE + DP_C) & DP_DETECTED)
				intel_dp_init(dev, VLV_DISPLAY_BASE + DP_C, PORT_C);
d14224 1
a14224 1
	} else if (SUPPORTS_DIGITAL_OUTPUTS(dev)) {
d14230 1
a14230 1
			if (!found && SUPPORTS_INTEGRATED_HDMI(dev)) {
d14235 1
a14235 1
			if (!found && SUPPORTS_INTEGRATED_DP(dev))
d14248 1
a14248 1
			if (SUPPORTS_INTEGRATED_HDMI(dev)) {
d14252 1
a14252 1
			if (SUPPORTS_INTEGRATED_DP(dev))
d14256 1
a14256 1
		if (SUPPORTS_INTEGRATED_DP(dev) &&
d14265 3
a14267 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, base.head) {
a14277 7
void intel_framebuffer_fini(struct intel_framebuffer *fb)
{
	drm_framebuffer_cleanup(&fb->base);
	WARN_ON(!fb->obj->framebuffer_references--);
	drm_gem_object_unreference_unlocked(&fb->obj->base);
}

d14280 1
d14283 5
a14287 1
	intel_framebuffer_fini(intel_fb);
d14298 5
d14306 17
d14326 1
d14329 33
a14361 4
int intel_framebuffer_init(struct drm_device *dev,
			   struct intel_framebuffer *intel_fb,
			   struct drm_mode_fb_cmd2 *mode_cmd,
			   struct drm_i915_gem_object *obj)
d14363 1
a14363 2
	int aligned_height, tile_height;
	int pitch_limit;
d14365 1
d14369 32
a14400 2
	if (obj->tiling_mode == I915_TILING_Y) {
		DRM_DEBUG("hardware does not support tiling Y\n");
d14404 5
a14408 3
	if (mode_cmd->pitches[0] & 63) {
		DRM_DEBUG("pitch (%d) must be at least 64 byte aligned\n",
			  mode_cmd->pitches[0]);
d14412 2
a14413 16
	if (INTEL_INFO(dev)->gen >= 5 && !IS_VALLEYVIEW(dev)) {
		pitch_limit = 32*1024;
	} else if (INTEL_INFO(dev)->gen >= 4) {
		if (obj->tiling_mode)
			pitch_limit = 16*1024;
		else
			pitch_limit = 32*1024;
	} else if (INTEL_INFO(dev)->gen >= 3) {
		if (obj->tiling_mode)
			pitch_limit = 8*1024;
		else
			pitch_limit = 16*1024;
	} else
		/* XXX DSPC is limited to 4k tiled */
		pitch_limit = 8*1024;

d14415 3
a14417 2
		DRM_DEBUG("%s pitch (%d) must be at less than %d\n",
			  obj->tiling_mode ? "tiled" : "linear",
d14422 1
a14422 1
	if (obj->tiling_mode != I915_TILING_NONE &&
a14436 1
	case DRM_FORMAT_ARGB1555:
d14443 16
a14458 5
	case DRM_FORMAT_XBGR8888:
	case DRM_FORMAT_ABGR8888:
	case DRM_FORMAT_XRGB2101010:
	case DRM_FORMAT_ARGB2101010:
	case DRM_FORMAT_XBGR2101010:
d14460 1
a14460 1
		if (INTEL_INFO(dev)->gen < 4) {
d14486 3
a14488 3
	tile_height = IS_GEN2(dev) ? 16 : 8;
	aligned_height = roundup2(mode_cmd->height,
			       obj->tiling_mode ? tile_height : 1);
d14509 1
a14509 1
			      struct drm_mode_fb_cmd2 *mode_cmd)
d14512 1
d14515 1
a14515 1
						mode_cmd->handles[0]));
d14519 1
a14519 1
	return intel_framebuffer_create(dev, mode_cmd, obj);
d14522 1
a14522 1
#ifndef CONFIG_DRM_I915_FBDEV
d14531 4
d14544 2
d14553 11
a14563 1
	if (HAS_DDI(dev)) {
d14565 4
a14568 1
		dev_priv->display.crtc_mode_set = haswell_crtc_mode_set;
d14571 2
a14572 2
		dev_priv->display.off = haswell_crtc_off;
		dev_priv->display.update_plane = ironlake_update_plane;
d14575 4
a14578 1
		dev_priv->display.crtc_mode_set = ironlake_crtc_mode_set;
d14581 2
a14582 2
		dev_priv->display.off = ironlake_crtc_off;
		dev_priv->display.update_plane = ironlake_update_plane;
d14585 3
a14587 1
		dev_priv->display.crtc_mode_set = i9xx_crtc_mode_set;
d14590 2
a14591 2
		dev_priv->display.off = i9xx_crtc_off;
		dev_priv->display.update_plane = i9xx_update_plane;
d14594 3
a14596 1
		dev_priv->display.crtc_mode_set = i9xx_crtc_mode_set;
d14599 2
a14600 2
		dev_priv->display.off = i9xx_crtc_off;
		dev_priv->display.update_plane = i9xx_update_plane;
d14604 13
a14616 1
	if (IS_VALLEYVIEW(dev))
d14619 5
a14623 1
	else if (IS_I945G(dev) || (IS_G33(dev) && !IS_PINEVIEW_M(dev)))
d14626 12
d14655 3
a14657 2
			i855_get_display_clock_speed;
	else /* 852, 830 */
d14660 1
d14662 14
a14675 18
	if (HAS_PCH_SPLIT(dev)) {
		if (IS_GEN5(dev)) {
			dev_priv->display.fdi_link_train = ironlake_fdi_link_train;
			dev_priv->display.write_eld = ironlake_write_eld;
		} else if (IS_GEN6(dev)) {
			dev_priv->display.fdi_link_train = gen6_fdi_link_train;
			dev_priv->display.write_eld = ironlake_write_eld;
		} else if (IS_IVYBRIDGE(dev)) {
			/* FIXME: detect B0+ stepping and use auto training */
			dev_priv->display.fdi_link_train = ivb_manual_fdi_link_train;
			dev_priv->display.write_eld = ironlake_write_eld;
			dev_priv->display.modeset_global_resources =
				ivb_modeset_global_resources;
		} else if (IS_HASWELL(dev) || IS_GEN8(dev)) {
			dev_priv->display.fdi_link_train = hsw_fdi_link_train;
			dev_priv->display.write_eld = haswell_write_eld;
			dev_priv->display.modeset_global_resources =
				haswell_modeset_global_resources;
a14676 2
	} else if (IS_G4X(dev)) {
		dev_priv->display.write_eld = g4x_write_eld;
d14678 9
a14686 3
		dev_priv->display.modeset_global_resources =
			valleyview_modeset_global_resources;
		dev_priv->display.write_eld = ironlake_write_eld;
a14688 3
	/* Default just returns -ENODEV to indicate unsupported */
	dev_priv->display.queue_flip = intel_default_queue_flip;

d14710 5
d14717 1
a14717 1
	intel_panel_init_backlight_funcs(dev);
d14733 8
d14762 2
a14763 5
/*
 * Some machines (Dell XPS13) suffer broken backlight controls if
 * BLM_PCH_PWM_ENABLE is set.
 */
static void quirk_no_pcm_pwm_enable(struct drm_device *dev)
d14766 2
a14767 2
	dev_priv->quirks |= QUIRK_NO_PCH_PWM_ENABLE;
	DRM_INFO("applying no-PCH_PWM_ENABLE quirk\n");
a14776 1
#ifdef __linux__
d14783 1
a14807 3
	/* HP Mini needs pipe A force quirk (LP: #322104) */
	{ 0x27ae, 0x103c, 0x361a, quirk_pipea_force },

d14817 3
d14844 23
a14866 4
	/* Dell XPS13 HD Sandy Bridge */
	{ 0x0116, 0x1028, 0x052e, quirk_no_pcm_pwm_enable },
	/* Dell XPS13 HD and XPS13 FHD Ivy Bridge */
	{ 0x0166, 0x1028, 0x058b, quirk_no_pcm_pwm_enable },
d14884 1
a14884 1
#ifdef __linux__
d14899 1
d14903 2
a14906 1
#endif
a14907 3
#ifdef __linux__
	outb(sr1 | 1<<5, VGA_SR_DATA);
#else
d14919 1
a14920 1

a14921 4

	intel_reset_dpio(dev);

	mutex_lock(&dev->struct_mutex);
a14922 6
	mutex_unlock(&dev->struct_mutex);
}

void intel_modeset_suspend_hw(struct drm_device *dev)
{
	intel_suspend_hw(dev);
d14928 3
a14930 1
	int i, j, ret;
d14940 2
d14951 18
d14970 1
d14982 12
d15000 4
a15003 4
	for_each_pipe(i) {
		intel_crtc_init(dev, i);
		for (j = 0; j < dev_priv->num_plane; j++) {
			ret = intel_plane_init(dev, i, j);
d15006 1
a15006 1
					      pipe_name(i), sprite_name(i, j), ret);
d15010 2
a15011 2
	intel_init_dpio(dev);
	intel_reset_dpio(dev);
a15012 1
	intel_cpu_pll_init(dev);
d15020 28
a15047 1
	intel_disable_fbc(dev);
d15055 1
d15060 1
a15060 3
	list_for_each_entry(connector,
			    &dev->mode_config.connector_list,
			    base.head) {
d15070 2
a15071 4
	if (intel_get_load_detect_pipe(crt, NULL, &load_detect_temp))
		intel_release_load_detect_pipe(crt, &load_detect_temp);


d15079 1
a15079 1
	u32 reg, val;
d15084 1
a15084 2
	reg = DSPCNTR(!crtc->plane);
	val = I915_READ(reg);
d15093 11
d15111 1
a15111 1
	reg = PIPECONF(crtc->config.cpu_transcoder);
d15114 16
a15133 1
		struct intel_connector *connector;
d15143 1
d15145 1
a15145 1
		dev_priv->display.crtc_disable(&crtc->base);
a15146 21

		/* ... and break all links. */
		list_for_each_entry(connector, &dev->mode_config.connector_list,
				    base.head) {
			if (connector->encoder->base.crtc != &crtc->base)
				continue;

			connector->base.dpms = DRM_MODE_DPMS_OFF;
			connector->base.encoder = NULL;
		}
		/* multiple connectors may have the same encoder:
		 *  handle them and break crtc link separately */
		list_for_each_entry(connector, &dev->mode_config.connector_list,
				    base.head)
			if (connector->encoder->base.crtc == &crtc->base) {
				connector->encoder->base.crtc = NULL;
				connector->encoder->connectors_active = false;
			}

		WARN_ON(crtc->active);
		crtc->base.enabled = false;
d15160 2
a15161 1
	intel_crtc_update_dpms(&crtc->base);
d15163 1
a15163 1
	if (crtc->active != crtc->base.enabled) {
d15167 2
a15168 1
		 * functions or because the pipe is force-enabled due to the
d15172 1
a15172 1
			      crtc->base.enabled ? "enabled" : "disabled",
d15175 2
d15186 1
a15186 2
		for_each_encoder_on_crtc(dev, &crtc->base, encoder) {
			WARN_ON(encoder->connectors_active);
d15188 18
a15205 1
		}
d15213 1
d15221 9
a15229 1
	if (encoder->connectors_active && !has_active_crtc) {
d15232 1
a15232 1
			      drm_get_encoder_name(&encoder->base));
d15240 1
a15240 1
				      drm_get_encoder_name(&encoder->base));
d15242 2
a15245 1
		encoder->connectors_active = false;
d15251 1
a15251 3
		list_for_each_entry(connector,
				    &dev->mode_config.connector_list,
				    base.head) {
d15262 11
a15275 1
	u32 vga_reg = i915_vgacntrl_reg(dev);
d15284 1
a15284 2
	if ((IS_HASWELL(dev) || IS_BROADWELL(dev)) &&
	    (I915_READ(HSW_PWR_WELL_DRIVER) & HSW_PWR_WELL_STATE_ENABLED) == 0)
d15287 22
a15308 4
	if (!(I915_READ(vga_reg) & VGA_DISP_DISABLE)) {
		DRM_DEBUG_KMS("Something enabled VGA plane, disabling it\n");
		i915_disable_vga(dev);
	}
d15320 4
a15323 5
	list_for_each_entry(crtc, &dev->mode_config.crtc_list,
			    base.head) {
		memset(&crtc->config, 0, sizeof(crtc->config));

		crtc->config.quirks |= PIPE_CONFIG_QUIRK_INHERITED_MODE;
d15326 1
a15326 1
								 &crtc->config);
d15328 1
d15330 2
a15331 1
		crtc->primary_enabled = crtc->active;
a15337 4
	/* FIXME: Smash this into the new shared dpll infrastructure. */
	if (HAS_DDI(dev))
		intel_ddi_setup_hw_pll_state(dev);

d15341 2
a15342 1
		pll->on = pll->get_hw_state(dev_priv, pll, &pll->hw_state);
d15344 3
a15346 3
		list_for_each_entry(crtc, &dev->mode_config.crtc_list,
				    base.head) {
			if (crtc->active && intel_crtc_to_shared_dpll(crtc) == pll)
d15348 2
a15350 1
		pll->refcount = pll->active;
d15352 5
a15356 2
		DRM_DEBUG_KMS("%s hw state readout: refcount %i, on %i\n",
			      pll->name, pll->refcount, pll->on);
d15359 1
a15359 2
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
d15365 1
a15365 1
			encoder->get_config(encoder, &crtc->config);
a15369 1
		encoder->connectors_active = false;
d15372 1
a15372 1
			      drm_get_encoder_name(&encoder->base),
d15377 1
a15377 2
	list_for_each_entry(connector, &dev->mode_config.connector_list,
			    base.head) {
a15379 1
			connector->encoder->connectors_active = true;
d15387 1
a15387 1
			      drm_get_connector_name(&connector->base),
d15390 33
d15425 5
a15429 4
/* Scan out the current hw modeset state, sanitizes it and maps it into the drm
 * and i915 state tracking structures. */
void intel_modeset_setup_hw_state(struct drm_device *dev,
				  bool force_restore)
a15438 16
	/*
	 * Now that we have the config, copy it to each CRTC struct
	 * Note that this could go away if we move to using crtc_config
	 * checking everywhere.
	 */
	list_for_each_entry(crtc, &dev->mode_config.crtc_list,
			    base.head) {
		if (crtc->active && i915_fastboot) {
			intel_crtc_mode_from_pipe_config(crtc, &crtc->config);

			DRM_DEBUG_KMS("[CRTC:%d] found active mode: ",
				      crtc->base.base.id);
			drm_mode_debug_printmodeline(&crtc->base.mode);
		}
	}

d15440 1
a15440 2
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
d15444 1
a15444 1
	for_each_pipe(pipe) {
d15447 2
a15448 1
		intel_dump_pipe_config(crtc, &crtc->config, "[setup_hw_state]");
d15451 2
d15465 5
a15469 1
	if (HAS_PCH_SPLIT(dev))
d15472 37
a15508 2
	if (force_restore) {
		i915_redisable_vga(dev);
d15510 5
a15514 7
		/*
		 * We need to use raw interfaces for restoring state to avoid
		 * checking (bogus) intermediate states.
		 */
		for_each_pipe(pipe) {
			struct drm_crtc *crtc =
				dev_priv->pipe_to_crtc_mapping[pipe];
d15516 4
a15519 5
			__intel_set_mode(crtc, &crtc->mode, crtc->x, crtc->y,
					 crtc->fb);
		}
	} else {
		intel_modeset_update_staged_output_state(dev);
d15522 10
a15531 1
	intel_modeset_check_state(dev);
d15536 8
d15548 28
a15575 4
	mutex_lock(&dev->mode_config.mutex);
	drm_mode_config_reset(dev);
	intel_modeset_setup_hw_state(dev, false);
	mutex_unlock(&dev->mode_config.mutex);
d15583 1
a15583 1
	drm_sysfs_connector_remove(connector);
a15588 1
	struct drm_crtc *crtc;
d15591 4
d15597 1
a15597 1
	 * Too much stuff here (turning of rps, connectors, ...) would
d15600 2
a15601 2
	drm_irq_uninstall(dev);
	cancel_work_sync(&dev_priv->hotplug_work);
a15607 2
	mutex_lock(&dev->struct_mutex);

d15612 1
a15612 15
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		/* Skip inactive CRTCs */
		if (!crtc->fb)
			continue;

		intel_increase_pllclock(crtc);
	}

	intel_disable_fbc(dev);

	intel_disable_gt_powersave(dev);

	ironlake_teardown_rc6(dev);

	mutex_unlock(&dev->struct_mutex);
d15628 6
d15661 8
a15668 1
	pci_read_config_word(dev_priv->bridge_dev, reg, &gmch_ctrl);
d15673 6
a15678 1
	pci_write_config_word(dev_priv->bridge_dev, reg, gmch_ctrl);
d15698 1
d15729 1
a15729 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d15749 1
a15749 1
	for_each_pipe(i) {
d15751 2
a15752 1
			intel_display_power_enabled_sw(dev, POWER_DOMAIN_PIPE(i));
d15756 3
a15758 9
		if (INTEL_INFO(dev)->gen <= 6 || IS_VALLEYVIEW(dev)) {
			error->cursor[i].control = I915_READ(CURCNTR(i));
			error->cursor[i].position = I915_READ(CURPOS(i));
			error->cursor[i].base = I915_READ(CURBASE(i));
		} else {
			error->cursor[i].control = I915_READ(CURCNTR_IVB(i));
			error->cursor[i].position = I915_READ(CURPOS_IVB(i));
			error->cursor[i].base = I915_READ(CURBASE_IVB(i));
		}
d15774 3
d15787 1
a15787 1
			intel_display_power_enabled_sw(dev,
d15813 1
d15823 1
a15823 1
	for_each_pipe(i) {
d15828 1
d15862 21
@


1.56
log
@Now that waitqueue_active() actually works, enable the WARN_ON that uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.55 2015/09/23 23:12:12 kettenis Exp $	*/
d10907 1
a10908 1
	vga_get_uninterruptible(dev->pdev, VGA_RSRC_LEGACY_IO);
d10911 1
a10911 1
	outb(VGA_SR_INDEX,SR01);
a10915 1
	vga_put(dev->pdev, VGA_RSRC_LEGACY_IO);
d10919 1
@


1.55
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.54 2015/07/16 18:48:51 kettenis Exp $	*/
d3012 1
a3012 1
//	WARN_ON(waitqueue_active(&dev_priv->pending_flip_queue));
@


1.54
log
@Introduce a Linux compatible wait_event API and use it in the inteldrm code.

ok jsg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.53 2015/06/28 15:00:41 kettenis Exp $	*/
a36 1
bool intel_pipe_has_type(struct drm_crtc *crtc, int type);
d40 8
a47 11
typedef struct {
	/* given values */
	int n;
	int m1, m2;
	int p1, p2;
	/* derived values */
	int	dot;
	int	vco;
	int	m;
	int	p;
} intel_clock_t;
a57 1
#define INTEL_P2_NUM		      2
a61 2
	bool (* find_pll)(const intel_limit_t *, struct drm_crtc *,
			int, int, intel_clock_t *, intel_clock_t *);
a63 3
/* FDI */
#define IRONLAKE_FDI_FREQ		2700000 /* in kHz for mode->clock */

a73 23
static bool
intel_find_best_PLL(const intel_limit_t *limit, struct drm_crtc *crtc,
		    int target, int refclk, intel_clock_t *match_clock,
		    intel_clock_t *best_clock);
static bool
intel_g4x_find_best_PLL(const intel_limit_t *limit, struct drm_crtc *crtc,
			int target, int refclk, intel_clock_t *match_clock,
			intel_clock_t *best_clock);

static bool
intel_find_pll_g4x_dp(const intel_limit_t *, struct drm_crtc *crtc,
		      int target, int refclk, intel_clock_t *match_clock,
		      intel_clock_t *best_clock);
static bool
intel_find_pll_ironlake_dp(const intel_limit_t *, struct drm_crtc *crtc,
			   int target, int refclk, intel_clock_t *match_clock,
			   intel_clock_t *best_clock);

static bool
intel_vlv_find_best_pll(const intel_limit_t *limit, struct drm_crtc *crtc,
			int target, int refclk, intel_clock_t *match_clock,
			intel_clock_t *best_clock);

d84 13
d99 2
a100 2
	.vco = { .min = 930000, .max = 1400000 },
	.n = { .min = 3, .max = 16 },
d107 1
a107 2
		.p2_slow = 4, .p2_fast = 2 },
	.find_pll = intel_find_best_PLL,
d112 2
a113 2
	.vco = { .min = 930000, .max = 1400000 },
	.n = { .min = 3, .max = 16 },
a120 1
	.find_pll = intel_find_best_PLL,
a133 1
	.find_pll = intel_find_best_PLL,
d141 2
a142 2
	.m1 = { .min = 10, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
a146 1
	.find_pll = intel_find_best_PLL,
a162 1
	.find_pll = intel_g4x_find_best_PLL,
a175 1
	.find_pll = intel_g4x_find_best_PLL,
a189 1
	.find_pll = intel_g4x_find_best_PLL,
a203 15
	.find_pll = intel_g4x_find_best_PLL,
};

static const intel_limit_t intel_limits_g4x_display_port = {
	.dot = { .min = 161670, .max = 227000 },
	.vco = { .min = 1750000, .max = 3500000},
	.n = { .min = 1, .max = 2 },
	.m = { .min = 97, .max = 108 },
	.m1 = { .min = 0x10, .max = 0x12 },
	.m2 = { .min = 0x05, .max = 0x06 },
	.p = { .min = 10, .max = 20 },
	.p1 = { .min = 1, .max = 2},
	.p2 = { .dot_limit = 0,
		.p2_slow = 10, .p2_fast = 10 },
	.find_pll = intel_find_pll_g4x_dp,
a218 1
	.find_pll = intel_find_best_PLL,
a231 1
	.find_pll = intel_find_best_PLL,
a249 1
	.find_pll = intel_g4x_find_best_PLL,
a262 1
	.find_pll = intel_g4x_find_best_PLL,
a275 1
	.find_pll = intel_g4x_find_best_PLL,
a289 1
	.find_pll = intel_g4x_find_best_PLL,
a302 1
	.find_pll = intel_g4x_find_best_PLL,
d305 8
a312 44
static const intel_limit_t intel_limits_ironlake_display_port = {
	.dot = { .min = 25000, .max = 350000 },
	.vco = { .min = 1760000, .max = 3510000},
	.n = { .min = 1, .max = 2 },
	.m = { .min = 81, .max = 90 },
	.m1 = { .min = 12, .max = 22 },
	.m2 = { .min = 5, .max = 9 },
	.p = { .min = 10, .max = 20 },
	.p1 = { .min = 1, .max = 2},
	.p2 = { .dot_limit = 0,
		.p2_slow = 10, .p2_fast = 10 },
	.find_pll = intel_find_pll_ironlake_dp,
};

static const intel_limit_t intel_limits_vlv_dac = {
	.dot = { .min = 25000, .max = 270000 },
	.vco = { .min = 4000000, .max = 6000000 },
	.n = { .min = 1, .max = 7 },
	.m = { .min = 22, .max = 450 }, /* guess */
	.m1 = { .min = 2, .max = 3 },
	.m2 = { .min = 11, .max = 156 },
	.p = { .min = 10, .max = 30 },
	.p1 = { .min = 2, .max = 3 },
	.p2 = { .dot_limit = 270000,
		.p2_slow = 2, .p2_fast = 20 },
	.find_pll = intel_vlv_find_best_pll,
};

static const intel_limit_t intel_limits_vlv_hdmi = {
	.dot = { .min = 20000, .max = 165000 },
	.vco = { .min = 4000000, .max = 5994000},
	.n = { .min = 1, .max = 7 },
	.m = { .min = 60, .max = 300 }, /* guess */
	.m1 = { .min = 2, .max = 3 },
	.m2 = { .min = 11, .max = 156 },
	.p = { .min = 10, .max = 30 },
	.p1 = { .min = 2, .max = 3 },
	.p2 = { .dot_limit = 270000,
		.p2_slow = 2, .p2_fast = 20 },
	.find_pll = intel_vlv_find_best_pll,
};

static const intel_limit_t intel_limits_vlv_dp = {
	.dot = { .min = 25000, .max = 270000 },
a314 1
	.m = { .min = 22, .max = 450 },
a316 1
	.p = { .min = 10, .max = 30 },
d318 1
a318 3
	.p2 = { .dot_limit = 270000,
		.p2_slow = 2, .p2_fast = 20 },
	.find_pll = intel_vlv_find_best_pll,
d321 1
a321 1
u32 intel_dpio_read(struct drm_i915_private *dev_priv, int reg)
d323 6
a328 21
	unsigned long flags;
	u32 val = 0;

	spin_lock_irqsave(&dev_priv->dpio_lock, flags);
	if (wait_for_atomic_us((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0, 100)) {
		DRM_ERROR("DPIO idle wait timed out\n");
		goto out_unlock;
	}

	I915_WRITE(DPIO_REG, reg);
	I915_WRITE(DPIO_PKT, DPIO_RID | DPIO_OP_READ | DPIO_PORTID |
		   DPIO_BYTE);
	if (wait_for_atomic_us((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0, 100)) {
		DRM_ERROR("DPIO read wait timed out\n");
		goto out_unlock;
	}
	val = I915_READ(DPIO_DATA);

out_unlock:
	spin_unlock_irqrestore(&dev_priv->dpio_lock, flags);
	return val;
d331 4
a334 2
static void intel_dpio_write(struct drm_i915_private *dev_priv, int reg,
			     u32 val)
d336 2
a337 1
	unsigned long flags;
d339 3
a341 5
	spin_lock_irqsave(&dev_priv->dpio_lock, flags);
	if (wait_for_atomic_us((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0, 100)) {
		DRM_ERROR("DPIO idle wait timed out\n");
		goto out_unlock;
	}
d343 1
a343 66
	I915_WRITE(DPIO_DATA, val);
	I915_WRITE(DPIO_REG, reg);
	I915_WRITE(DPIO_PKT, DPIO_RID | DPIO_OP_WRITE | DPIO_PORTID |
		   DPIO_BYTE);
	if (wait_for_atomic_us((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0, 100))
		DRM_ERROR("DPIO write wait timed out\n");

out_unlock:
       spin_unlock_irqrestore(&dev_priv->dpio_lock, flags);
}

static void vlv_init_dpio(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* Reset the DPIO config */
	I915_WRITE(DPIO_CTL, 0);
	POSTING_READ(DPIO_CTL);
	I915_WRITE(DPIO_CTL, 1);
	POSTING_READ(DPIO_CTL);
}

static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)
{
	DRM_INFO("Forcing lvds to dual link mode on %s\n", id->ident);
	return 1;
}

static const struct dmi_system_id intel_dual_link_lvds[] = {
	{
		.callback = intel_dual_link_lvds_callback,
		.ident = "Apple MacBook Pro (Core i5/i7 Series)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro8,2"),
		},
	},
	{ }	/* terminating entry */
};

static bool is_dual_link_lvds(struct drm_i915_private *dev_priv,
			      unsigned int reg)
{
	unsigned int val;

	/* use the module option value if specified */
	if (i915_lvds_channel_mode > 0)
		return i915_lvds_channel_mode == 2;

	if (dmi_check_system(intel_dual_link_lvds))
		return true;

	if (dev_priv->lvds_val)
		val = dev_priv->lvds_val;
	else {
		/* BIOS should set the proper LVDS register value at boot, but
		 * in reality, it doesn't set the value when the lid is closed;
		 * we need to check "the value to be set" in VBT when LVDS
		 * register is uninitialized.
		 */
		val = I915_READ(reg);
		if (!(val & ~(LVDS_PIPE_MASK | LVDS_DETECTED)))
			val = dev_priv->bios_lvds_val;
		dev_priv->lvds_val = val;
	}
	return (val & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP;
a349 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d353 1
a353 2
		if (is_dual_link_lvds(dev_priv, PCH_LVDS)) {
			/* LVDS dual channel */
d364 1
a364 4
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT) ||
		   intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))
		limit = &intel_limits_ironlake_display_port;
	else
a372 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d376 1
a376 2
		if (is_dual_link_lvds(dev_priv, LVDS))
			/* LVDS with dual channel */
a378 1
			/* LVDS with dual channel */
a384 2
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT)) {
		limit = &intel_limits_g4x_display_port;
d406 1
a406 6
		if (intel_pipe_has_type(crtc, INTEL_OUTPUT_ANALOG))
			limit = &intel_limits_vlv_dac;
		else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI))
			limit = &intel_limits_vlv_hdmi;
		else
			limit = &intel_limits_vlv_dp;
d415 2
d418 1
a418 1
			limit = &intel_limits_i8xx_dvo;
d428 4
a431 2
	clock->vco = refclk * clock->m / clock->n;
	clock->dot = clock->vco / clock->p;
d434 1
a434 1
static void intel_clock(struct drm_device *dev, int refclk, intel_clock_t *clock)
d436 1
a436 8
	if (IS_PINEVIEW(dev)) {
		pineview_clock(refclk, clock);
		return;
	}
	clock->m = 5 * (clock->m1 + 2) + (clock->m2 + 2);
	clock->p = clock->p1 * clock->p2;
	clock->vco = refclk * clock->m / (clock->n + 2);
	clock->dot = clock->vco / clock->p;
d439 1
a439 4
/**
 * Returns whether any output on the specified pipe is of the specified type
 */
bool intel_pipe_has_type(struct drm_crtc *crtc, int type)
d441 6
a446 8
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *encoder;

	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->type == type)
			return true;

	return false;
d459 2
a462 2
	if (clock->p   < limit->p.min   || limit->p.max   < clock->p)
		INTELPllInvalid("p out of range\n");
d467 12
a478 6
	if (clock->m1 <= clock->m2 && !IS_PINEVIEW(dev))
		INTELPllInvalid("m1 <= m2\n");
	if (clock->m   < limit->m.min   || limit->m.max   < clock->m)
		INTELPllInvalid("m out of range\n");
	if (clock->n   < limit->n.min   || limit->n.max   < clock->n)
		INTELPllInvalid("n out of range\n");
d491 1
a491 1
intel_find_best_PLL(const intel_limit_t *limit, struct drm_crtc *crtc,
d494 56
d551 4
a556 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d560 1
a560 2
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&
	    (I915_READ(LVDS)) != 0) {
d562 3
a564 4
		 * For LVDS, if the panel is on, just rely on its current
		 * settings for dual-channel.  We haven't figured out how to
		 * reliably set up different single/dual channel state, if we
		 * even can.
d566 1
a566 1
		if (is_dual_link_lvds(dev_priv, LVDS))
a582 3
			/* m1 is always 0 in Pineview */
			if (clock.m2 >= clock.m1 && !IS_PINEVIEW(dev))
				break;
d589 1
a589 1
					intel_clock(dev, refclk, &clock);
d611 3
a613 3
intel_g4x_find_best_PLL(const intel_limit_t *limit, struct drm_crtc *crtc,
			int target, int refclk, intel_clock_t *match_clock,
			intel_clock_t *best_clock)
a615 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d624 1
a624 8
		int lvds_reg;

		if (HAS_PCH_SPLIT(dev))
			lvds_reg = PCH_LVDS;
		else
			lvds_reg = LVDS;
		if ((I915_READ(lvds_reg) & LVDS_CLKB_POWER_MASK) ==
		    LVDS_CLKB_POWER_UP)
d648 1
a648 1
					intel_clock(dev, refclk, &clock);
a651 3
					if (match_clock &&
					    clock.p != match_clock->p)
						continue;
d668 3
a670 3
intel_find_pll_ironlake_dp(const intel_limit_t *limit, struct drm_crtc *crtc,
			   int target, int refclk, intel_clock_t *match_clock,
			   intel_clock_t *best_clock)
d674 4
d679 1
a679 17
	if (target < 200000) {
		clock.n = 1;
		clock.p1 = 2;
		clock.p2 = 10;
		clock.m1 = 12;
		clock.m2 = 9;
	} else {
		clock.n = 2;
		clock.p1 = 1;
		clock.p2 = 10;
		clock.m1 = 14;
		clock.m2 = 8;
	}
	intel_clock(dev, refclk, &clock);
	memcpy(best_clock, &clock, sizeof(intel_clock_t));
	return true;
}
d681 1
a681 48
/* DisplayPort has only two frequencies, 162MHz and 270MHz */
static bool
intel_find_pll_g4x_dp(const intel_limit_t *limit, struct drm_crtc *crtc,
		      int target, int refclk, intel_clock_t *match_clock,
		      intel_clock_t *best_clock)
{
	intel_clock_t clock;
	if (target < 200000) {
		clock.p1 = 2;
		clock.p2 = 10;
		clock.n = 2;
		clock.m1 = 23;
		clock.m2 = 8;
	} else {
		clock.p1 = 1;
		clock.p2 = 10;
		clock.n = 1;
		clock.m1 = 14;
		clock.m2 = 2;
	}
	clock.m = 5 * (clock.m1 + 2) + (clock.m2 + 2);
	clock.p = (clock.p1 * clock.p2);
	clock.dot = 96000 * clock.m / (clock.n + 2) / clock.p;
	clock.vco = 0;
	memcpy(best_clock, &clock, sizeof(intel_clock_t));
	return true;
}
static bool
intel_vlv_find_best_pll(const intel_limit_t *limit, struct drm_crtc *crtc,
			int target, int refclk, intel_clock_t *match_clock,
			intel_clock_t *best_clock)
{
	u32 p1, p2, m1, m2, vco, bestn, bestm1, bestm2, bestp1, bestp2;
	u32 m, n, fastclk;
	u32 updrate, minupdate, fracbits, p;
	unsigned long bestppm, ppm, absppm;
	int dotclk, flag;

	flag = 0;
	dotclk = target * 1000;
	bestppm = 1000000;
	ppm = absppm = 0;
	fastclk = dotclk / (2*100);
	updrate = 0;
	minupdate = 19200;
	fracbits = 1;
	n = p = p1 = p2 = m = m1 = m2 = vco = bestn = 0;
	bestm1 = bestm2 = bestp1 = bestp2 = 0;
d684 5
a688 7
	for (n = limit->n.min; n <= ((refclk) / minupdate); n++) {
		updrate = refclk / n;
		for (p1 = limit->p1.max; p1 > limit->p1.min; p1--) {
			for (p2 = limit->p2.p2_fast+1; p2 > 0; p2--) {
				if (p2 > 10)
					p2 = p2 - 1;
				p = p1 * p2;
d690 25
a714 24
				for (m1 = limit->m1.min; m1 <= limit->m1.max; m1++) {
					m2 = (((2*(fastclk * p * n / m1 )) +
					       refclk) / (2*refclk));
					m = m1 * m2;
					vco = updrate * m;
					if (vco >= limit->vco.min && vco < limit->vco.max) {
						ppm = 1000000 * ((vco / p) - fastclk) / fastclk;
						absppm = (ppm > 0) ? ppm : (-ppm);
						if (absppm < 100 && ((p1 * p2) > (bestp1 * bestp2))) {
							bestppm = 0;
							flag = 1;
						}
						if (absppm < bestppm - 10) {
							bestppm = absppm;
							flag = 1;
						}
						if (flag) {
							bestn = n;
							bestm1 = m1;
							bestm2 = m2;
							bestp1 = p1;
							bestp2 = p2;
							flag = 0;
						}
a719 5
	best_clock->n = bestn;
	best_clock->m1 = bestm1;
	best_clock->m2 = bestm2;
	best_clock->p1 = bestp1;
	best_clock->p2 = bestp2;
d721 18
a738 1
	return true;
d747 1
a747 1
	return intel_crtc->cpu_transcoder;
d750 1
a750 1
static void ironlake_wait_for_vblank(struct drm_device *dev, int pipe)
d753 1
a753 1
	u32 frame, frame_reg = PIPEFRAME(pipe);
d774 2
a775 2
	if (INTEL_INFO(dev)->gen >= 5) {
		ironlake_wait_for_vblank(dev, pipe);
d802 19
a851 9
		u32 last_line, line_mask;
		int reg = PIPEDSL(pipe);
		unsigned long timeout = jiffies + msecs_to_jiffies(100);

		if (IS_GEN2(dev))
			line_mask = DSL_LINEMASK_GEN2;
		else
			line_mask = DSL_LINEMASK_GEN3;

d853 1
a853 6
		do {
			last_line = I915_READ(reg) & line_mask;
			mdelay(5);
		} while (((I915_READ(reg) & line_mask) != last_line) &&
			 time_after(timeout, jiffies));
		if (time_after(jiffies, timeout))
d858 9
a866 1
static const char *state_string(bool enabled)
d868 39
a906 2
	return enabled ? "on" : "off";
}
d909 2
a910 2
static void assert_pll(struct drm_i915_private *dev_priv,
		       enum pipe pipe, bool state)
d923 29
a951 2
#define assert_pll_enabled(d, p) assert_pll(d, p, true)
#define assert_pll_disabled(d, p) assert_pll(d, p, false)
d954 3
a956 4
static void assert_pch_pll(struct drm_i915_private *dev_priv,
			   struct intel_pch_pll *pll,
			   struct intel_crtc *crtc,
			   bool state)
a957 1
	u32 val;
d959 1
d967 1
a967 1
		  "asserting PCH PLL %s with no PLL\n", state_string(state)))
d970 1
a970 2
	val = I915_READ(pll->pll_reg);
	cur_state = !!(val & DPLL_VCO_ENABLE);
d972 2
a973 21
	     "PCH PLL state for reg %x assertion failure (expected %s, current %s), val=%08x\n",
	     pll->pll_reg, state_string(state), state_string(cur_state), val);

	/* Make sure the selected PLL is correctly attached to the transcoder */
	if (crtc && HAS_PCH_CPT(dev_priv->dev)) {
		u32 pch_dpll;

		pch_dpll = I915_READ(PCH_DPLL_SEL);
		cur_state = pll->pll_reg == _PCH_DPLL_B;
		if (!WARN(((pch_dpll >> (4 * crtc->pipe)) & 1) != cur_state,
			  "PLL[%d] not attached to this transcoder %d: %08x\n",
			  cur_state, crtc->pipe, pch_dpll)) {
			cur_state = !!(val >> (4*crtc->pipe + 3));
			WARN(cur_state != state,
			     "PLL[%d] not %s on this transcoder %d: %08x\n",
			     pll->pll_reg == _PCH_DPLL_B,
			     state_string(state),
			     crtc->pipe,
			     val);
		}
	}
a974 2
#define assert_pch_pll_enabled(d, p, c) assert_pch_pll(d, p, c, true)
#define assert_pch_pll_disabled(d, p, c) assert_pch_pll(d, p, c, false)
d1038 2
a1039 2
static void assert_fdi_rx_pll_enabled(struct drm_i915_private *dev_priv,
				      enum pipe pipe)
d1043 1
d1047 4
a1050 1
	WARN(!(val & FDI_RX_PLL_ENABLE), "FDI RX PLL assertion failure, should be active but is disabled\n");
d1082 20
d1115 9
a1123 3
	reg = PIPECONF(cpu_transcoder);
	val = I915_READ(reg);
	cur_state = !!(val & PIPECONF_ENABLE);
d1150 1
d1155 2
a1156 2
	/* Planes are fixed to pipes on ILK+ */
	if (HAS_PCH_SPLIT(dev_priv->dev)) {
d1166 1
a1166 1
	for (i = 0; i < 2; i++) {
d1177 31
a1207 1
static void assert_pch_refclk_enabled(struct drm_i915_private *dev_priv)
d1212 1
a1212 4
	if (HAS_PCH_LPT(dev_priv->dev)) {
		DRM_DEBUG_DRIVER("LPT does not has PCH refclk, skipping check\n");
		return;
	}
d1220 2
a1221 2
static void assert_transcoder_disabled(struct drm_i915_private *dev_priv,
				       enum pipe pipe)
d1227 1
a1227 1
	reg = TRANSCONF(pipe);
d1256 1
a1256 1
	if ((val & PORT_ENABLE) == 0)
d1260 1
a1260 1
		if ((val & PORT_TRANS_SEL_MASK) != PORT_TRANS_SEL_CPT(pipe))
d1263 1
a1263 1
		if ((val & TRANSCODER_MASK) != TRANSCODER(pipe))
d1321 1
a1321 1
	WARN(HAS_PCH_IBX(dev_priv->dev) && (val & PORT_ENABLE) == 0
d1348 41
a1388 3
	assert_pch_hdmi_disabled(dev_priv, pipe, HDMIB);
	assert_pch_hdmi_disabled(dev_priv, pipe, HDMIC);
	assert_pch_hdmi_disabled(dev_priv, pipe, HDMID);
d1391 1
a1391 14
/**
 * intel_enable_pll - enable a PLL
 * @@dev_priv: i915 private structure
 * @@pipe: pipe PLL to enable
 *
 * Enable @@pipe's PLL so we can start pumping pixels from a plane.  Check to
 * make sure the PLL reg is writable first though, since the panel write
 * protect mechanism may be enabled.
 *
 * Note!  This is for pre-ILK only.
 *
 * Unfortunately needed by dvo_ns2501 since the dvo depends on it running.
 */
static void intel_enable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
d1393 6
a1398 2
	int reg;
	u32 val;
d1401 1
a1401 1
	BUG_ON(!IS_VALLEYVIEW(dev_priv->dev) && dev_priv->info->gen >= 5);
d1405 45
a1449 1
		assert_panel_unlocked(dev_priv, pipe);
d1451 11
a1461 3
	reg = DPLL(pipe);
	val = I915_READ(reg);
	val |= DPLL_VCO_ENABLE;
d1464 1
a1464 1
	I915_WRITE(reg, val);
d1467 1
a1467 1
	I915_WRITE(reg, val);
d1470 1
a1470 1
	I915_WRITE(reg, val);
d1476 1
a1476 1
 * intel_disable_pll - disable a PLL
d1484 1
a1484 1
static void intel_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
a1485 3
	int reg;
	u32 val;

d1493 2
a1494 5
	reg = DPLL(pipe);
	val = I915_READ(reg);
	val &= ~DPLL_VCO_ENABLE;
	I915_WRITE(reg, val);
	POSTING_READ(reg);
d1497 1
a1497 4
/* SBI access */
static void
intel_sbi_write(struct drm_i915_private *dev_priv, u16 reg, u32 value,
		enum intel_sbi_destination destination)
d1499 1
a1499 2
	unsigned long flags;
	u32 tmp;
d1501 2
a1502 5
	spin_lock_irqsave(&dev_priv->dpio_lock, flags);
	if (wait_for((I915_READ(SBI_CTL_STAT) & SBI_BUSY) == 0, 100)) {
		DRM_ERROR("timeout waiting for SBI to become ready\n");
		goto out_unlock;
	}
d1504 8
a1511 17
	I915_WRITE(SBI_ADDR, (reg << 16));
	I915_WRITE(SBI_DATA, value);

	if (destination == SBI_ICLK)
		tmp = SBI_CTL_DEST_ICLK | SBI_CTL_OP_CRWR;
	else
		tmp = SBI_CTL_DEST_MPHY | SBI_CTL_OP_IOWR;
	I915_WRITE(SBI_CTL_STAT, SBI_BUSY | tmp);

	if (wait_for((I915_READ(SBI_CTL_STAT) & (SBI_BUSY | SBI_RESPONSE_FAIL)) == 0,
				100)) {
		DRM_ERROR("timeout waiting for SBI to complete write transaction\n");
		goto out_unlock;
	}

out_unlock:
	spin_unlock_irqrestore(&dev_priv->dpio_lock, flags);
d1514 2
a1515 3
static u32
intel_sbi_read(struct drm_i915_private *dev_priv, u16 reg,
	       enum intel_sbi_destination destination)
d1517 1
a1517 2
	unsigned long flags;
	u32 value = 0;
d1519 9
a1527 18
	spin_lock_irqsave(&dev_priv->dpio_lock, flags);
	if (wait_for((I915_READ(SBI_CTL_STAT) & SBI_BUSY) == 0, 100)) {
		DRM_ERROR("timeout waiting for SBI to become ready\n");
		goto out_unlock;
	}

	I915_WRITE(SBI_ADDR, (reg << 16));

	if (destination == SBI_ICLK)
		value = SBI_CTL_DEST_ICLK | SBI_CTL_OP_CRRD;
	else
		value = SBI_CTL_DEST_MPHY | SBI_CTL_OP_IORD;
	I915_WRITE(SBI_CTL_STAT, value | SBI_BUSY);

	if (wait_for((I915_READ(SBI_CTL_STAT) & (SBI_BUSY | SBI_RESPONSE_FAIL)) == 0,
				100)) {
		DRM_ERROR("timeout waiting for SBI to complete read transaction\n");
		goto out_unlock;
d1530 3
a1532 5
	value = I915_READ(SBI_DATA);

out_unlock:
	spin_unlock_irqrestore(&dev_priv->dpio_lock, flags);
	return value;
d1536 1
a1536 1
 * ironlake_enable_pch_pll - enable PCH PLL
d1543 1
a1543 1
static void ironlake_enable_pch_pll(struct intel_crtc *intel_crtc)
d1545 2
a1546 4
	struct drm_i915_private *dev_priv = intel_crtc->base.dev->dev_private;
	struct intel_pch_pll *pll;
	int reg;
	u32 val;
d1550 1
a1550 2
	pll = intel_crtc->pch_pll;
	if (pll == NULL)
d1556 3
a1558 3
	DRM_DEBUG_KMS("enable PCH PLL %x (active %d, on? %d)for crtc %d\n",
		      pll->pll_reg, pll->active, pll->on,
		      intel_crtc->base.base.id);
d1560 3
a1562 5
	/* PCH refclock must be enabled first */
	assert_pch_refclk_enabled(dev_priv);

	if (pll->active++ && pll->on) {
		assert_pch_pll_enabled(dev_priv, pll, NULL);
d1565 1
d1567 2
a1568 9
	DRM_DEBUG_KMS("enabling PCH PLL %x\n", pll->pll_reg);

	reg = pll->pll_reg;
	val = I915_READ(reg);
	val |= DPLL_VCO_ENABLE;
	I915_WRITE(reg, val);
	POSTING_READ(reg);
	udelay(200);

d1572 1
a1572 1
static void intel_disable_pch_pll(struct intel_crtc *intel_crtc)
d1574 2
a1575 4
	struct drm_i915_private *dev_priv = intel_crtc->base.dev->dev_private;
	struct intel_pch_pll *pll = intel_crtc->pch_pll;
	int reg;
	u32 val;
d1579 1
a1579 1
	if (pll == NULL)
d1585 3
a1587 3
	DRM_DEBUG_KMS("disable PCH PLL %x (active %d, on? %d) for crtc %d\n",
		      pll->pll_reg, pll->active, pll->on,
		      intel_crtc->base.base.id);
d1590 1
a1590 1
		assert_pch_pll_disabled(dev_priv, pll, NULL);
d1594 3
a1596 2
	if (--pll->active) {
		assert_pch_pll_enabled(dev_priv, pll, NULL);
a1597 13
	}

	DRM_DEBUG_KMS("disabling PCH PLL %x\n", pll->pll_reg);

	/* Make sure transcoder isn't still depending on us */
	assert_transcoder_disabled(dev_priv, intel_crtc->pipe);

	reg = pll->pll_reg;
	val = I915_READ(reg);
	val &= ~DPLL_VCO_ENABLE;
	I915_WRITE(reg, val);
	POSTING_READ(reg);
	udelay(200);
d1599 2
d1609 1
d1616 2
a1617 3
	assert_pch_pll_enabled(dev_priv,
			       to_intel_crtc(crtc)->pch_pll,
			       to_intel_crtc(crtc));
d1632 1
a1632 1
	reg = TRANSCONF(pipe);
d1641 2
a1642 2
		val &= ~PIPE_BPC_MASK;
		val |= pipeconf_val & PIPE_BPC_MASK;
d1657 1
a1657 1
		DRM_ERROR("failed to enable transcoder %d\n", pipe);
d1669 1
a1669 1
	assert_fdi_tx_enabled(dev_priv, cpu_transcoder);
d1686 2
a1687 2
	I915_WRITE(TRANSCONF(TRANSCODER_A), val);
	if (wait_for(I915_READ(_TRANSACONF) & TRANS_STATE_ENABLE, 100))
d1704 1
a1704 1
	reg = TRANSCONF(pipe);
d1710 1
a1710 1
		DRM_ERROR("failed to disable transcoder %d\n", pipe);
d1725 1
a1725 1
	val = I915_READ(_TRANSACONF);
d1727 1
a1727 1
	I915_WRITE(_TRANSACONF, val);
d1729 1
a1729 1
	if (wait_for((I915_READ(_TRANSACONF) & TRANS_STATE_ENABLE) == 0, 50))
d1753 1
a1753 1
			      bool pch_port)
d1757 1
a1757 1
	enum transcoder pch_transcoder;
d1761 5
a1765 1
	if (IS_HASWELL(dev_priv->dev))
d1776 4
a1779 1
		assert_pll_enabled(dev_priv, pipe);
d1784 2
a1785 1
			assert_fdi_tx_pll_enabled(dev_priv, cpu_transcoder);
d1824 2
d1844 2
a1845 2
void intel_flush_display_plane(struct drm_i915_private *dev_priv,
				      enum plane plane)
d1847 4
a1850 4
	if (dev_priv->info->gen >= 4)
		I915_WRITE(DSPSURF(plane), I915_READ(DSPSURF(plane)));
	else
		I915_WRITE(DSPADDR(plane), I915_READ(DSPADDR(plane)));
d1854 1
a1854 1
 * intel_enable_plane - enable a display plane on a given pipe
d1861 2
a1862 2
static void intel_enable_plane(struct drm_i915_private *dev_priv,
			       enum plane plane, enum pipe pipe)
d1864 2
d1872 4
d1882 1
a1882 1
	intel_flush_display_plane(dev_priv, plane);
d1887 1
a1887 1
 * intel_disable_plane - disable a display plane
d1894 2
a1895 2
static void intel_disable_plane(struct drm_i915_private *dev_priv,
				enum plane plane, enum pipe pipe)
d1897 2
d1902 4
d1912 1
a1912 1
	intel_flush_display_plane(dev_priv, plane);
d1916 9
d1948 1
a1948 2
		/* FIXME: Is this true? */
		DRM_ERROR("Y tiled not allowed for scan out buffers\n");
d1954 8
d1982 1
a1982 1
	i915_gem_object_unpin(obj);
d1991 1
a1991 1
	i915_gem_object_unpin(obj);
d2039 1
a2039 1
		DRM_ERROR("Can't update plane %d in SAREA\n", plane);
d2078 1
a2078 2
		DRM_ERROR("Unknown pixel format 0x%08x\n", fb->pixel_format);
		return -EINVAL;
d2088 3
d2105 3
a2107 2
	DRM_DEBUG_KMS("Writing base %08X %08lX %d %d %d\n",
		      obj->gtt_offset, linear_offset, x, y, fb->pitches[0]);
d2110 2
a2111 2
		I915_MODIFY_DISPBASE(DSPSURF(plane),
				     obj->gtt_offset + intel_crtc->dspaddr_offset);
d2115 1
a2115 1
		I915_WRITE(DSPADDR(plane), obj->gtt_offset + linear_offset);
d2140 1
a2140 1
		DRM_ERROR("Can't update plane %d in SAREA\n", plane);
d2175 1
a2175 2
		DRM_ERROR("Unknown pixel format 0x%08x\n", fb->pixel_format);
		return -EINVAL;
d2183 4
a2186 2
	/* must disable */
	dspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;
d2197 3
a2199 2
	DRM_DEBUG_KMS("Writing base %08X %08lX %d %d %d\n",
		      obj->gtt_offset, linear_offset, x, y, fb->pitches[0]);
d2201 3
a2203 3
	I915_MODIFY_DISPBASE(DSPSURF(plane),
			     obj->gtt_offset + intel_crtc->dspaddr_offset);
	if (IS_HASWELL(dev)) {
d2229 1
a2229 2
static int
intel_finish_fb(struct drm_framebuffer *old_fb)
d2231 2
a2232 4
	struct drm_i915_gem_object *obj = to_intel_framebuffer(old_fb)->obj;
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	bool was_interruptible = dev_priv->mm.interruptible;
	int ret;
d2234 45
a2278 3
	wait_event(dev_priv->pending_flip_queue,
		   atomic_read(&dev_priv->mm.wedged) ||
		   atomic_read(&obj->pending_flip) == 0);
d2341 3
a2343 3
		DRM_ERROR("no plane for crtc: plane %d, num_pipes %d\n",
				intel_crtc->plane,
				INTEL_INFO(dev)->num_pipes);
d2357 30
a2386 2
	if (crtc->fb)
		intel_finish_fb(crtc->fb);
d2402 2
a2403 1
		intel_wait_for_vblank(dev, intel_crtc->pipe);
d2408 1
a2415 37
static void ironlake_set_pll_edp(struct drm_crtc *crtc, int clock)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	DRM_DEBUG_KMS("eDP PLL enable for clock %d\n", clock);
	dpa_ctl = I915_READ(DP_A);
	dpa_ctl &= ~DP_PLL_FREQ_MASK;

	if (clock < 200000) {
		u32 temp;
		dpa_ctl |= DP_PLL_FREQ_160MHZ;
		/* workaround for 160Mhz:
		   1) program 0x4600c bits 15:0 = 0x8124
		   2) program 0x46010 bit 0 = 1
		   3) program 0x46034 bit 24 = 1
		   4) program 0x64000 bit 14 = 1
		   */
		temp = I915_READ(0x4600c);
		temp &= 0xffff0000;
		I915_WRITE(0x4600c, temp | 0x8124);

		temp = I915_READ(0x46010);
		I915_WRITE(0x46010, temp | 1);

		temp = I915_READ(0x46034);
		I915_WRITE(0x46034, temp | (1 << 24));
	} else {
		dpa_ctl |= DP_PLL_FREQ_270MHZ;
	}
	I915_WRITE(DP_A, dpa_ctl);

	POSTING_READ(DP_A);
	udelay(500);
}

d2457 6
d2472 7
a2478 4
	/* When everything is off disable fdi C so that we could enable fdi B
	 * with all lanes. XXX: This misses the case where a pipe is not using
	 * any pch resources and so doesn't need any fdi lanes. */
	if (!pipe_B_crtc->base.enabled && !pipe_C_crtc->base.enabled) {
d2516 2
a2517 2
	temp &= ~(7 << 19);
	temp |= (intel_crtc->fdi_lanes - 1) << 19;
d2614 2
a2615 2
	temp &= ~(7 << 19);
	temp |= (intel_crtc->fdi_lanes - 1) << 19;
d2730 1
a2730 1
	u32 reg, temp, i;
d2746 8
a2753 11
	/* enable CPU FDI TX and PCH FDI RX */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~(7 << 19);
	temp |= (intel_crtc->fdi_lanes - 1) << 19;
	temp &= ~(FDI_LINK_TRAIN_AUTO | FDI_LINK_TRAIN_NONE_IVB);
	temp |= FDI_LINK_TRAIN_PATTERN_1_IVB;
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	temp |= FDI_COMPOSITE_SYNC;
	I915_WRITE(reg, temp | FDI_TX_ENABLE);
d2755 6
a2760 13
	I915_WRITE(FDI_RX_MISC(pipe),
		   FDI_RX_TP1_TO_TP2_48 | FDI_RX_FDI_DELAY_90);

	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_AUTO;
	temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
	temp |= FDI_LINK_TRAIN_PATTERN_1_CPT;
	temp |= FDI_COMPOSITE_SYNC;
	I915_WRITE(reg, temp | FDI_RX_ENABLE);

	POSTING_READ(reg);
	udelay(150);
d2762 1
a2762 1
	for (i = 0; i < 4; i++) {
d2765 3
d2769 3
a2771 2
		temp |= snb_b_fdi_train_param[i];
		I915_WRITE(reg, temp);
d2773 2
a2774 2
		POSTING_READ(reg);
		udelay(500);
d2776 1
a2776 1
		reg = FDI_RX_IIR(pipe);
d2778 3
a2780 1
		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
d2782 2
a2783 9
		if (temp & FDI_RX_BIT_LOCK ||
		    (I915_READ(reg) & FDI_RX_BIT_LOCK)) {
			I915_WRITE(reg, temp | FDI_RX_BIT_LOCK);
			DRM_DEBUG_KMS("FDI train 1 done, level %i.\n", i);
			break;
		}
	}
	if (i == 4)
		DRM_ERROR("FDI train 1 fail!\n");
d2785 4
a2788 8
	/* Train 2 */
	reg = FDI_TX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_NONE_IVB;
	temp |= FDI_LINK_TRAIN_PATTERN_2_IVB;
	temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
	temp |= FDI_LINK_TRAIN_400MV_0DB_SNB_B;
	I915_WRITE(reg, temp);
d2790 13
a2802 5
	reg = FDI_RX_CTL(pipe);
	temp = I915_READ(reg);
	temp &= ~FDI_LINK_TRAIN_PATTERN_MASK_CPT;
	temp |= FDI_LINK_TRAIN_PATTERN_2_CPT;
	I915_WRITE(reg, temp);
d2804 6
a2809 2
	POSTING_READ(reg);
	udelay(150);
d2811 1
a2811 2
	for (i = 0; i < 4; i++) {
		reg = FDI_TX_CTL(pipe);
d2813 2
a2814 2
		temp &= ~FDI_LINK_TRAIN_VOL_EMP_MASK;
		temp |= snb_b_fdi_train_param[i];
d2818 1
a2818 1
		udelay(500);
d2820 4
a2823 3
		reg = FDI_RX_IIR(pipe);
		temp = I915_READ(reg);
		DRM_DEBUG_KMS("FDI_RX_IIR 0x%x\n", temp);
d2825 8
a2832 4
		if (temp & FDI_RX_SYMBOL_LOCK) {
			I915_WRITE(reg, temp | FDI_RX_SYMBOL_LOCK);
			DRM_DEBUG_KMS("FDI train 2 done, level %i.\n", i);
			break;
d2834 2
a2836 2
	if (i == 4)
		DRM_ERROR("FDI train 2 fail!\n");
d2838 1
d2853 3
a2855 3
	temp &= ~((0x7 << 19) | (0x7 << 16));
	temp |= (intel_crtc->fdi_lanes - 1) << 19;
	temp |= (I915_READ(PIPECONF(pipe)) & PIPE_BPC_MASK) << 11;
d2868 5
a2872 8
	/* On Haswell, the PLL configuration for ports and pipes is handled
	 * separately, as part of DDI setup */
	if (!IS_HASWELL(dev)) {
		/* Enable CPU FDI TX PLL, always on for Ironlake */
		reg = FDI_TX_CTL(pipe);
		temp = I915_READ(reg);
		if ((temp & FDI_TX_PLL_ENABLE) == 0) {
			I915_WRITE(reg, temp | FDI_TX_PLL_ENABLE);
d2874 2
a2875 3
			POSTING_READ(reg);
			udelay(100);
		}
d2925 1
a2925 1
	temp |= (I915_READ(PIPECONF(pipe)) & PIPE_BPC_MASK) << 11;
d2954 1
a2954 1
	temp |= (I915_READ(PIPECONF(pipe)) & PIPE_BPC_MASK) << 11;
d2965 1
d2969 2
a2970 1
	if (atomic_read(&dev_priv->mm.wedged))
d2980 24
d3012 2
a3021 26
static bool ironlake_crtc_driving_pch(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;

	/*
	 * If there's a non-PCH eDP on this crtc, it must be DP_A, and that
	 * must be driven by its own crtc; no sharing is possible.
	 */
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		switch (intel_encoder->type) {
		case INTEL_OUTPUT_EDP:
			if (!intel_encoder_is_pch_edp(&intel_encoder->base))
				return false;
			continue;
		}
	}

	return true;
}

static bool haswell_crtc_driving_pch(struct drm_crtc *crtc)
{
	return intel_pipe_has_type(crtc, INTEL_OUTPUT_ANALOG);
}

d3027 1
d3031 2
d3045 1
a3045 1
	if (crtc->mode.clock == 20000) {
d3051 2
a3052 2
		 * but the crtc->mode.clock in in KHz. To get the divisors,
		 * it is necessary to divide one by another, so we
d3060 1
a3060 1
		desired_divisor = (iclk_virtual_root_freq / crtc->mode.clock);
d3076 1
a3076 1
			crtc->mode.clock,
d3107 68
d3193 4
a3196 1
	assert_transcoder_disabled(dev_priv, pipe);
d3206 2
a3207 9
	/* XXX: pch pll's can be enabled any time before we enable the PCH
	 * transcoder, and we actually should do this to not upset any PCH
	 * transcoder that already use the clock when we share it.
	 *
	 * Note that enable_pch_pll tries to do the right thing, but get_pch_pll
	 * unconditionally resets the pll - we need that to have the right LVDS
	 * enable sequence. */
	ironlake_enable_pch_pll(intel_crtc);

d3212 3
a3214 16
		switch (pipe) {
		default:
		case 0:
			temp |= TRANSA_DPLL_ENABLE;
			sel = TRANSA_DPLLB_SEL;
			break;
		case 1:
			temp |= TRANSB_DPLL_ENABLE;
			sel = TRANSB_DPLLB_SEL;
			break;
		case 2:
			temp |= TRANSC_DPLL_ENABLE;
			sel = TRANSC_DPLLB_SEL;
			break;
		}
		if (intel_crtc->pch_pll->pll_reg == _PCH_DPLL_B)
d3221 9
d3232 1
a3232 8
	I915_WRITE(TRANS_HTOTAL(pipe), I915_READ(HTOTAL(pipe)));
	I915_WRITE(TRANS_HBLANK(pipe), I915_READ(HBLANK(pipe)));
	I915_WRITE(TRANS_HSYNC(pipe),  I915_READ(HSYNC(pipe)));

	I915_WRITE(TRANS_VTOTAL(pipe), I915_READ(VTOTAL(pipe)));
	I915_WRITE(TRANS_VBLANK(pipe), I915_READ(VBLANK(pipe)));
	I915_WRITE(TRANS_VSYNC(pipe),  I915_READ(VSYNC(pipe)));
	I915_WRITE(TRANS_VSYNCSHIFT(pipe),  I915_READ(VSYNCSHIFT(pipe)));
d3240 1
a3240 1
		u32 bpc = (I915_READ(PIPECONF(pipe)) & PIPE_BPC_MASK) >> 5;
d3280 1
a3280 1
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
d3282 1
a3282 1
	assert_transcoder_disabled(dev_priv, TRANSCODER_A);
d3287 1
a3287 8
	I915_WRITE(_TRANS_HTOTAL_A, I915_READ(HTOTAL(cpu_transcoder)));
	I915_WRITE(_TRANS_HBLANK_A, I915_READ(HBLANK(cpu_transcoder)));
	I915_WRITE(_TRANS_HSYNC_A,  I915_READ(HSYNC(cpu_transcoder)));

	I915_WRITE(_TRANS_VTOTAL_A, I915_READ(VTOTAL(cpu_transcoder)));
	I915_WRITE(_TRANS_VBLANK_A, I915_READ(VBLANK(cpu_transcoder)));
	I915_WRITE(_TRANS_VSYNC_A,  I915_READ(VSYNC(cpu_transcoder)));
	I915_WRITE(_TRANS_VSYNCSHIFT_A, I915_READ(VSYNCSHIFT(cpu_transcoder)));
d3292 1
a3292 1
static void intel_put_pch_pll(struct intel_crtc *intel_crtc)
d3294 1
a3294 1
	struct intel_pch_pll *pll = intel_crtc->pch_pll;
d3300 1
a3300 1
		WARN(1, "bad PCH PLL refcount\n");
d3304 6
a3309 2
	--pll->refcount;
	intel_crtc->pch_pll = NULL;
d3312 1
a3312 1
static struct intel_pch_pll *intel_get_pch_pll(struct intel_crtc *intel_crtc, u32 dpll, u32 fp)
d3314 3
a3316 3
	struct drm_i915_private *dev_priv = intel_crtc->base.dev->dev_private;
	struct intel_pch_pll *pll;
	int i;
a3317 1
	pll = intel_crtc->pch_pll;
d3319 3
a3321 3
		DRM_DEBUG_KMS("CRTC:%d reusing existing PCH PLL %x\n",
			      intel_crtc->base.base.id, pll->pll_reg);
		goto prepare;
d3326 2
a3327 2
		i = intel_crtc->pipe;
		pll = &dev_priv->pch_plls[i];
d3329 2
a3330 2
		DRM_DEBUG_KMS("CRTC:%d using pre-allocated PCH PLL %x\n",
			      intel_crtc->base.base.id, pll->pll_reg);
d3335 2
a3336 2
	for (i = 0; i < dev_priv->num_pch_pll; i++) {
		pll = &dev_priv->pch_plls[i];
d3342 5
a3346 5
		if (dpll == (I915_READ(pll->pll_reg) & 0x7fffffff) &&
		    fp == I915_READ(pll->fp0_reg)) {
			DRM_DEBUG_KMS("CRTC:%d sharing existing PCH PLL %x (refcount %d, ative %d)\n",
				      intel_crtc->base.base.id,
				      pll->pll_reg, pll->refcount, pll->active);
d3353 2
a3354 2
	for (i = 0; i < dev_priv->num_pch_pll; i++) {
		pll = &dev_priv->pch_plls[i];
d3356 2
a3357 2
			DRM_DEBUG_KMS("CRTC:%d allocated PCH PLL %x\n",
				      intel_crtc->base.base.id, pll->pll_reg);
d3365 14
a3378 1
	intel_crtc->pch_pll = pll;
a3379 8
	DRM_DEBUG_DRIVER("using pll %d for pipe %d\n", i, intel_crtc->pipe);
prepare: /* separate function? */
	DRM_DEBUG_DRIVER("switching PLL %x off\n", pll->pll_reg);

	/* Wait for the clocks to stabilize before rewriting the regs */
	I915_WRITE(pll->pll_reg, dpll & ~DPLL_VCO_ENABLE);
	POSTING_READ(pll->pll_reg);
	udelay(150);
a3380 3
	I915_WRITE(pll->fp0_reg, fp);
	I915_WRITE(pll->pll_reg, dpll & ~DPLL_VCO_ENABLE);
	pll->on = false;
d3384 1
a3384 1
void intel_cpt_verify_modeset(struct drm_device *dev, int pipe)
d3394 1
a3394 1
			DRM_ERROR("mode set failed: pipe %d stuck\n", pipe);
d3398 1
a3398 1
static void ironlake_crtc_enable(struct drm_crtc *crtc)
d3400 1
a3400 1
	struct drm_device *dev = crtc->dev;
d3402 1
a3402 6
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
	u32 temp;
	bool is_pch_port;
d3404 14
a3417 1
	WARN_ON(!crtc->enabled);
d3419 5
a3423 2
	if (intel_crtc->active)
		return;
d3425 4
a3428 2
	intel_crtc->active = true;
	intel_update_watermarks(dev);
d3430 107
a3536 4
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
		temp = I915_READ(PCH_LVDS);
		if ((temp & LVDS_PORT_EN) == 0)
			I915_WRITE(PCH_LVDS, temp | LVDS_PORT_EN);
d3539 26
a3564 1
	is_pch_port = ironlake_crtc_driving_pch(crtc);
d3566 1
a3566 1
	if (is_pch_port) {
d3576 1
a3576 20
	for_each_encoder_on_crtc(dev, crtc, encoder)
		if (encoder->pre_enable)
			encoder->pre_enable(encoder);

	/* Enable panel fitting for LVDS */
	if (dev_priv->pch_pf_size &&
	    (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) ||
	     intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP))) {
		/* Force use of hard-coded filter coefficients
		 * as some pre-programmed values are broken,
		 * e.g. x201.
		 */
		if (IS_IVYBRIDGE(dev))
			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3 |
						 PF_PIPE_SEL_IVB(pipe));
		else
			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3);
		I915_WRITE(PF_WIN_POS(pipe), dev_priv->pch_pf_pos);
		I915_WRITE(PF_WIN_SZ(pipe), dev_priv->pch_pf_size);
	}
d3584 6
a3589 2
	intel_enable_pipe(dev_priv, pipe, is_pch_port);
	intel_enable_plane(dev_priv, plane, pipe);
d3591 1
a3591 1
	if (is_pch_port)
a3597 2
	intel_crtc_update_cursor(crtc, true);

d3602 1
a3602 1
		intel_cpt_verify_modeset(dev, intel_crtc->pipe);
d3615 76
a3697 2
	int plane = intel_crtc->plane;
	bool is_pch_port;
a3704 1
	intel_update_watermarks(dev);
d3706 3
a3708 1
	is_pch_port = haswell_crtc_driving_pch(crtc);
d3710 1
a3710 1
	if (is_pch_port)
d3719 1
a3719 12
	/* Enable panel fitting for eDP */
	if (dev_priv->pch_pf_size &&
	    intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP)) {
		/* Force use of hard-coded filter coefficients
		 * as some pre-programmed values are broken,
		 * e.g. x201.
		 */
		I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3 |
					 PF_PIPE_SEL_IVB(pipe));
		I915_WRITE(PF_WIN_POS(pipe), dev_priv->pch_pf_pos);
		I915_WRITE(PF_WIN_SZ(pipe), dev_priv->pch_pf_size);
	}
d3728 1
a3728 1
	intel_ddi_enable_pipe_func(crtc);
d3730 3
a3732 2
	intel_enable_pipe(dev_priv, pipe, is_pch_port);
	intel_enable_plane(dev_priv, plane, pipe);
d3734 1
a3734 1
	if (is_pch_port)
d3737 4
a3740 5
	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);

	intel_crtc_update_cursor(crtc, true);
d3742 4
a3745 2
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
d3758 15
d3792 4
d3797 2
d3800 2
a3801 4
	intel_disable_plane(dev_priv, plane, pipe);

	if (dev_priv->cfb_plane == plane)
		intel_disable_fbc(dev);
d3805 1
a3805 3
	/* Disable PF */
	I915_WRITE(PF_CTL(pipe), 0);
	I915_WRITE(PF_WIN_SZ(pipe), 0);
d3811 2
a3812 1
	ironlake_fdi_disable(crtc);
d3814 1
a3814 1
	ironlake_disable_pch_transcoder(dev_priv, pipe);
d3816 8
a3823 7
	if (HAS_PCH_CPT(dev)) {
		/* disable TRANS_DP_CTL */
		reg = TRANS_DP_CTL(pipe);
		temp = I915_READ(reg);
		temp &= ~(TRANS_DP_OUTPUT_ENABLE | TRANS_DP_PORT_SEL_MASK);
		temp |= TRANS_DP_PORT_SEL_NONE;
		I915_WRITE(reg, temp);
d3825 4
a3828 15
		/* disable DPLL_SEL */
		temp = I915_READ(PCH_DPLL_SEL);
		switch (pipe) {
		case 0:
			temp &= ~(TRANSA_DPLL_ENABLE | TRANSA_DPLLB_SEL);
			break;
		case 1:
			temp &= ~(TRANSB_DPLL_ENABLE | TRANSB_DPLLB_SEL);
			break;
		case 2:
			/* C shares PLL A or B */
			temp &= ~(TRANSC_DPLL_ENABLE | TRANSC_DPLLB_SEL);
			break;
		default:
			BUG(); /* wtf */
a3829 2
		I915_WRITE(PCH_DPLL_SEL, temp);
	}
d3831 2
a3832 2
	/* disable PCH DPLL */
	intel_disable_pch_pll(intel_crtc);
d3834 2
a3835 1
	ironlake_fdi_pll_disable(intel_crtc);
d3838 1
a3838 1
	intel_update_watermarks(dev);
d3852 1
a3852 3
	int plane = intel_crtc->plane;
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
	bool is_pch_port;
d3857 1
a3857 1
	is_pch_port = haswell_crtc_driving_pch(crtc);
d3859 2
a3860 1
	for_each_encoder_on_crtc(dev, crtc, encoder)
d3862 1
d3864 2
a3865 9
	intel_crtc_wait_for_pending_flips(crtc);
	drm_vblank_off(dev, pipe);
	intel_crtc_update_cursor(crtc, false);

	intel_disable_plane(dev_priv, plane, pipe);

	if (dev_priv->cfb_plane == plane)
		intel_disable_fbc(dev);

d3870 1
a3870 3
	/* Disable PF */
	I915_WRITE(PF_CTL(pipe), 0);
	I915_WRITE(PF_WIN_SZ(pipe), 0);
d3878 1
a3878 1
	if (is_pch_port) {
d3884 1
a3884 1
	intel_update_watermarks(dev);
d3894 1
a3894 1
	intel_put_pch_pll(intel_crtc);
a3898 6
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	/* Stop saying we're using TRANSCODER_EDP because some other CRTC might
	 * start using it. */
	intel_crtc->cpu_transcoder = intel_crtc->pipe;

d3920 25
a3944 1
static void i9xx_crtc_enable(struct drm_crtc *crtc)
d3946 1
a3946 1
	struct drm_device *dev = crtc->dev;
d3948 1
a3948 4
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
d3950 2
a3951 1
	WARN_ON(!crtc->enabled);
d3953 6
a3958 2
	if (intel_crtc->active)
		return;
d3960 2
a3961 2
	intel_crtc->active = true;
	intel_update_watermarks(dev);
d3963 4
a3966 3
	intel_enable_pll(dev_priv, pipe);
	intel_enable_pipe(dev_priv, pipe, false);
	intel_enable_plane(dev_priv, plane, pipe);
d3968 3
a3970 2
	intel_crtc_load_lut(crtc);
	intel_update_fbc(dev);
d3972 5
a3976 3
	/* Give the overlay scaler a chance to enable if it's on this pipe */
	intel_crtc_dpms_overlay(intel_crtc, true);
	intel_crtc_update_cursor(crtc, true);
d3978 1
a3978 2
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->enable(encoder);
d3981 2
a3982 1
static void i9xx_crtc_disable(struct drm_crtc *crtc)
a3983 1
	struct drm_device *dev = crtc->dev;
d3985 8
a3992 5
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_encoder *encoder;
	int pipe = intel_crtc->pipe;
	int plane = intel_crtc->plane;
	u32 pctl;
d3994 31
d4026 10
a4035 2
	if (!intel_crtc->active)
		return;
d4037 3
a4039 2
	for_each_encoder_on_crtc(dev, crtc, encoder)
		encoder->disable(encoder);
d4041 4
a4044 5
	/* Give the overlay scaler a chance to disable if it's on this pipe */
	intel_crtc_wait_for_pending_flips(crtc);
	drm_vblank_off(dev, pipe);
	intel_crtc_dpms_overlay(intel_crtc, false);
	intel_crtc_update_cursor(crtc, false);
d4046 1
a4046 2
	if (dev_priv->cfb_plane == plane)
		intel_disable_fbc(dev);
d4048 3
a4050 2
	intel_disable_plane(dev_priv, plane, pipe);
	intel_disable_pipe(dev_priv, pipe);
d4052 1
a4052 5
	/* Disable pannel fitter if it is on this pipe. */
	pctl = I915_READ(PFIT_CONTROL);
	if ((pctl & PFIT_ENABLE) &&
	    ((pctl & PFIT_PIPE_MASK) >> PFIT_PIPE_SHIFT) == pipe)
		I915_WRITE(PFIT_CONTROL, 0);
d4054 1
a4054 1
	intel_disable_pll(dev_priv, pipe);
d4056 1
a4056 3
	intel_crtc->active = false;
	intel_update_fbc(dev);
	intel_update_watermarks(dev);
d4059 2
a4060 1
static void i9xx_crtc_off(struct drm_crtc *crtc)
d4062 228
a4289 1
}
a4343 4
static void intel_crtc_noop(struct drm_crtc *crtc)
{
}

d4349 1
d4355 1
d4360 1
a4382 14
void intel_modeset_disable(struct drm_device *dev)
{
	struct drm_crtc *crtc;

	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		if (crtc->enabled)
			intel_crtc_disable(crtc);
	}
}

void intel_encoder_noop(struct drm_encoder *encoder)
{
}

d4391 1
a4391 1
/* Simple dpms helper for encodres with just one connector, no cloning and only
d4394 1
a4394 1
void intel_encoder_dpms(struct intel_encoder *encoder, int mode)
d4473 2
a4474 3
static bool intel_crtc_mode_fixup(struct drm_crtc *crtc,
				  const struct drm_display_mode *mode,
				  struct drm_display_mode *adjusted_mode)
d4476 24
a4499 1
	struct drm_device *dev = crtc->dev;
d4501 22
a4522 3
	if (HAS_PCH_SPLIT(dev)) {
		/* FDI link clock is fixed at 2.7G */
		if (mode->clock * 3 > IRONLAKE_FDI_FREQ * 4)
d4524 89
d4615 9
a4623 5
	/* All interlaced capable intel hw wants timings in frames. Note though
	 * that intel_lvds_mode_fixup does some funny tricks with the crtc
	 * timings, so we need to be careful not to clobber these.*/
	if (!(adjusted_mode->private_flags & INTEL_MODE_CRTC_TIMINGS_SET))
		drm_mode_set_crtcinfo(adjusted_mode, 0);
d4625 2
a4626 2
	/* WaPruneModeWithIncorrectHsyncOffset: Cantiga+ cannot handle modes
	 * with a hsync front porch of 0.
d4630 20
a4649 1
		return false;
d4651 1
a4651 1
	return true;
d4674 24
a4699 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d4702 1
a4702 1
	gcfgc = pci_conf_read(dev_priv->pc, dev_priv->tag, GCFGC);
a4746 8
struct fdi_m_n {
	u32        tu;
	u32        gmch_m;
	u32        gmch_n;
	u32        link_m;
	u32        link_n;
};

d4748 1
a4748 1
fdi_reduce_ratio(u32 *num, u32 *den)
d4762 1
a4762 1
	fdi_reduce_ratio(ret_m, ret_n);
d4765 4
a4768 3
static void
ironlake_compute_m_n(int bits_per_pixel, int nlanes, int pixel_clock,
		     int link_clock, struct fdi_m_n *m_n)
d4770 1
a4770 1
	m_n->tu = 64; /* default size */
d4784 1
a4784 1
	return dev_priv->lvds_use_ssc
d4788 3
a4790 161
/**
 * intel_choose_pipe_bpp_dither - figure out what color depth the pipe should send
 * @@crtc: CRTC structure
 * @@mode: requested mode
 *
 * A pipe may be connected to one or more outputs.  Based on the depth of the
 * attached framebuffer, choose a good color depth to use on the pipe.
 *
 * If possible, match the pipe depth to the fb depth.  In some cases, this
 * isn't ideal, because the connected output supports a lesser or restricted
 * set of depths.  Resolve that here:
 *    LVDS typically supports only 6bpc, so clamp down in that case
 *    HDMI supports only 8bpc or 12bpc, so clamp to 8bpc with dither for 10bpc
 *    Displays may support a restricted set as well, check EDID and clamp as
 *      appropriate.
 *    DP may want to dither down to 6bpc to fit larger modes
 *
 * RETURNS:
 * Dithering requirement (i.e. false if display bpc and pipe bpc match,
 * true if they don't match).
 */
static bool intel_choose_pipe_bpp_dither(struct drm_crtc *crtc,
					 struct drm_framebuffer *fb,
					 unsigned int *pipe_bpp,
					 struct drm_display_mode *mode)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_connector *connector;
	struct intel_encoder *intel_encoder;
	unsigned int display_bpc = UINT_MAX, bpc;

	/* Walk the encoders & connectors on this crtc, get min bpc */
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {

		if (intel_encoder->type == INTEL_OUTPUT_LVDS) {
			unsigned int lvds_bpc;

			if ((I915_READ(PCH_LVDS) & LVDS_A3_POWER_MASK) ==
			    LVDS_A3_POWER_UP)
				lvds_bpc = 8;
			else
				lvds_bpc = 6;

			if (lvds_bpc < display_bpc) {
				DRM_DEBUG_KMS("clamping display bpc (was %d) to LVDS (%d)\n", display_bpc, lvds_bpc);
				display_bpc = lvds_bpc;
			}
			continue;
		}

		/* Not one of the known troublemakers, check the EDID */
		list_for_each_entry(connector, &dev->mode_config.connector_list,
				    head) {
			if (connector->encoder != &intel_encoder->base)
				continue;

			/* Don't use an invalid EDID bpc value */
			if (connector->display_info.bpc &&
			    connector->display_info.bpc < display_bpc) {
				DRM_DEBUG_KMS("clamping display bpc (was %d) to EDID reported max of %d\n", display_bpc, connector->display_info.bpc);
				display_bpc = connector->display_info.bpc;
			}
		}

		if (intel_encoder->type == INTEL_OUTPUT_EDP) {
			/* Use VBT settings if we have an eDP panel */
			unsigned int edp_bpc = dev_priv->edp.bpp / 3;

			if (edp_bpc && edp_bpc < display_bpc) {
				DRM_DEBUG_KMS("clamping display bpc (was %d) to eDP (%d)\n", display_bpc, edp_bpc);
				display_bpc = edp_bpc;
			}
			continue;
		}

		/*
		 * HDMI is either 12 or 8, so if the display lets 10bpc sneak
		 * through, clamp it down.  (Note: >12bpc will be caught below.)
		 */
		if (intel_encoder->type == INTEL_OUTPUT_HDMI) {
			if (display_bpc > 8 && display_bpc < 12) {
				DRM_DEBUG_KMS("forcing bpc to 12 for HDMI\n");
				display_bpc = 12;
			} else {
				DRM_DEBUG_KMS("forcing bpc to 8 for HDMI\n");
				display_bpc = 8;
			}
		}
	}

	if (mode->private_flags & INTEL_MODE_DP_FORCE_6BPC) {
		DRM_DEBUG_KMS("Dithering DP to 6bpc\n");
		display_bpc = 6;
	}

	/*
	 * We could just drive the pipe at the highest bpc all the time and
	 * enable dithering as needed, but that costs bandwidth.  So choose
	 * the minimum value that expresses the full color range of the fb but
	 * also stays within the max display bpc discovered above.
	 */

	switch (fb->depth) {
	case 8:
		bpc = 8; /* since we go through a colormap */
		break;
	case 15:
	case 16:
		bpc = 6; /* min is 18bpp */
		break;
	case 24:
		bpc = 8;
		break;
	case 30:
		bpc = 10;
		break;
	case 48:
		bpc = 12;
		break;
	default:
		DRM_DEBUG("unsupported depth, assuming 24 bits\n");
		bpc = min((unsigned int)8, display_bpc);
		break;
	}

	display_bpc = min(display_bpc, bpc);

	DRM_DEBUG_KMS("setting pipe bpc to %d (max display bpc %d)\n",
		      bpc, display_bpc);

	*pipe_bpp = display_bpc * 3;

	return display_bpc != bpc;
}

static int vlv_get_refclk(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int refclk = 27000; /* for DP & HDMI */

	return 100000; /* only one validated so far */

	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_ANALOG)) {
		refclk = 96000;
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
		if (intel_panel_use_ssc(dev_priv))
			refclk = 100000;
		else
			refclk = 96000;
	} else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP)) {
		refclk = 100000;
	}

	return refclk;
}

static int i9xx_get_refclk(struct drm_crtc *crtc, int num_connectors)
{
	struct drm_device *dev = crtc->dev;
d4795 1
a4795 1
		refclk = vlv_get_refclk(crtc);
d4798 2
a4799 3
		refclk = dev_priv->lvds_ssc_freq * 1000;
		DRM_DEBUG_KMS("using SSC reference clock of %d MHz\n",
			      refclk / 1000);
d4809 6
a4814 2
static void i9xx_adjust_sdvo_tv_clock(struct drm_display_mode *adjusted_mode,
				      intel_clock_t *clock)
d4816 1
a4816 17
	/* SDVO TV has fixed PLL values depend on its clock range,
	   this mirrors vbios setting. */
	if (adjusted_mode->clock >= 100000
	    && adjusted_mode->clock < 140500) {
		clock->p1 = 2;
		clock->p2 = 10;
		clock->n = 3;
		clock->m1 = 16;
		clock->m2 = 8;
	} else if (adjusted_mode->clock >= 140500
		   && adjusted_mode->clock <= 200000) {
		clock->p1 = 1;
		clock->p2 = 10;
		clock->n = 6;
		clock->m1 = 12;
		clock->m2 = 8;
	}
d4819 1
a4819 2
static void i9xx_update_pll_dividers(struct drm_crtc *crtc,
				     intel_clock_t *clock,
d4822 1
a4822 1
	struct drm_device *dev = crtc->dev;
d4824 1
a4824 2
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
d4828 1
a4828 1
		fp = (1 << clock->n) << 16 | clock->m1 << 8 | clock->m2;
d4830 1
a4830 2
			fp2 = (1 << reduced_clock->n) << 16 |
				reduced_clock->m1 << 8 | reduced_clock->m2;
d4832 1
a4832 1
		fp = clock->n << 16 | clock->m1 << 8 | clock->m2;
d4834 1
a4834 2
			fp2 = reduced_clock->n << 16 | reduced_clock->m1 << 8 |
				reduced_clock->m2;
d4838 1
d4840 2
a4841 2
	intel_crtc->lowfreq_avail = false;
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&
d4844 2
a4845 1
		intel_crtc->lowfreq_avail = true;
d4848 1
d4852 31
a4882 2
static void intel_update_lvds(struct drm_crtc *crtc, intel_clock_t *clock,
			      struct drm_display_mode *adjusted_mode)
d4884 1
a4884 1
	struct drm_device *dev = crtc->dev;
d4886 7
a4892 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 temp;
d4894 7
a4900 16
	temp = I915_READ(LVDS);
	temp |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;
	if (pipe == 1) {
		temp |= LVDS_PIPEB_SELECT;
	} else {
		temp &= ~LVDS_PIPEB_SELECT;
	}
	/* set the corresponsding LVDS_BORDER bit */
	temp |= dev_priv->lvds_border_bits;
	/* Set the B0-B3 data pairs corresponding to whether we're going to
	 * set the DPLLs for dual-channel mode or not.
	 */
	if (clock->p2 == 7)
		temp |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
	else
		temp &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);
d4902 10
a4911 10
	/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP)
	 * appropriately here, but we need to look more thoroughly into how
	 * panels behave in the two modes.
	 */
	/* set the dithering flag on LVDS as needed */
	if (INTEL_INFO(dev)->gen >= 4) {
		if (dev_priv->lvds_dither)
			temp |= LVDS_ENABLE_DITHER;
		else
			temp &= ~LVDS_ENABLE_DITHER;
a4912 6
	temp &= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);
	if (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)
		temp |= LVDS_HSYNC_POLARITY;
	if (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)
		temp |= LVDS_VSYNC_POLARITY;
	I915_WRITE(LVDS, temp);
d4915 9
a4923 5
static void vlv_update_pll(struct drm_crtc *crtc,
			   struct drm_display_mode *mode,
			   struct drm_display_mode *adjusted_mode,
			   intel_clock_t *clock, intel_clock_t *reduced_clock,
			   int num_connectors)
d4925 1
a4925 1
	struct drm_device *dev = crtc->dev;
d4927 2
a4928 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 dpll, mdiv, pdiv;
d4930 11
a4940 2
	bool is_sdvo;
	u32 temp;
d4942 3
a4944 2
	is_sdvo = intel_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ||
		intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI);
d4946 2
a4947 4
	dpll = DPLL_VGA_MODE_DIS;
	dpll |= DPLL_EXT_BUFFER_ENABLE_VLV;
	dpll |= DPLL_REFA_CLK_ENABLE_VLV;
	dpll |= DPLL_INTEGRATED_CLOCK_VLV;
d4949 4
a4952 2
	I915_WRITE(DPLL(pipe), dpll);
	POSTING_READ(DPLL(pipe));
d4954 2
a4955 5
	bestn = clock->n;
	bestm1 = clock->m1;
	bestm2 = clock->m2;
	bestp1 = clock->p1;
	bestp2 = clock->p2;
d4957 1
a4957 4
	/*
	 * In Valleyview PLL and program lane counter registers are exposed
	 * through DPIO interface
	 */
a4960 1
	mdiv |= (1 << DPIO_POST_DIV_SHIFT);
a4961 2
	mdiv |= DPIO_ENABLE_CALIBRATION;
	intel_dpio_write(dev_priv, DPIO_DIV(pipe), mdiv);
d4963 7
a4969 1
	intel_dpio_write(dev_priv, DPIO_CORE_CLK(pipe), 0x01000000);
d4971 2
a4972 5
	pdiv = (1 << DPIO_REFSEL_OVERRIDE) | (5 << DPIO_PLL_MODESEL_SHIFT) |
		(3 << DPIO_BIAS_CURRENT_CTL_SHIFT) | (1<<20) |
		(7 << DPIO_PLL_REFCLK_SEL_SHIFT) | (8 << DPIO_DRIVER_CTL_SHIFT) |
		(5 << DPIO_CLK_BIAS_CTL_SHIFT);
	intel_dpio_write(dev_priv, DPIO_REFSFR(pipe), pdiv);
d4974 9
a4982 1
	intel_dpio_write(dev_priv, DPIO_LFP_COEFF(pipe), 0x005f003b);
d4984 18
a5001 5
	dpll |= DPLL_VCO_ENABLE;
	I915_WRITE(DPLL(pipe), dpll);
	POSTING_READ(DPLL(pipe));
	if (wait_for(((I915_READ(DPLL(pipe)) & DPLL_LOCK_VLV) == DPLL_LOCK_VLV), 1))
		DRM_ERROR("DPLL %d failed to lock\n", pipe);
d5003 6
a5008 1
	intel_dpio_write(dev_priv, DPIO_FASTCLK_DISABLE, 0x620);
d5010 1
a5010 2
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT))
		intel_dp_set_m_n(crtc, mode, adjusted_mode);
d5012 12
a5023 1
	I915_WRITE(DPLL(pipe), dpll);
d5025 3
a5027 3
	/* Wait for the clocks to stabilize. */
	POSTING_READ(DPLL(pipe));
	udelay(150);
d5029 2
a5030 10
	temp = 0;
	if (is_sdvo) {
		temp = intel_mode_get_pixel_multiplier(adjusted_mode);
		if (temp > 1)
			temp = (temp - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;
		else
			temp = 0;
	}
	I915_WRITE(DPLL_MD(pipe), temp);
	POSTING_READ(DPLL_MD(pipe));
d5032 1
a5032 16
	/* Now program lane control registers */
	if(intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT)
			|| intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI))
	{
		temp = 0x1000C4;
		if(pipe == 1)
			temp |= (1 << 21);
		intel_dpio_write(dev_priv, DPIO_DATA_CHANNEL1, temp);
	}
	if(intel_pipe_has_type(crtc,INTEL_OUTPUT_EDP))
	{
		temp = 0x1000C4;
		if(pipe == 1)
			temp |= (1 << 21);
		intel_dpio_write(dev_priv, DPIO_DATA_CHANNEL2, temp);
	}
d5035 2
a5036 4
static void i9xx_update_pll(struct drm_crtc *crtc,
			    struct drm_display_mode *mode,
			    struct drm_display_mode *adjusted_mode,
			    intel_clock_t *clock, intel_clock_t *reduced_clock,
d5039 1
a5039 1
	struct drm_device *dev = crtc->dev;
a5040 2
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
d5043 1
d5045 1
a5045 1
	i9xx_update_pll_dividers(crtc, clock, reduced_clock);
d5047 2
a5048 2
	is_sdvo = intel_pipe_has_type(crtc, INTEL_OUTPUT_SDVO) ||
		intel_pipe_has_type(crtc, INTEL_OUTPUT_HDMI);
d5052 1
a5052 1
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
d5056 4
a5059 7
	if (is_sdvo) {
		int pixel_multiplier = intel_mode_get_pixel_multiplier(adjusted_mode);
		if (pixel_multiplier > 1) {
			if (IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev))
				dpll |= (pixel_multiplier - 1) << SDVO_MULTIPLIER_SHIFT_HIRES;
		}
		dpll |= DPLL_DVO_HIGH_SPEED;
d5061 6
a5066 2
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT))
		dpll |= DPLL_DVO_HIGH_SPEED;
d5093 1
a5093 1
	if (is_sdvo && intel_pipe_has_type(crtc, INTEL_OUTPUT_TVOUT))
d5095 1
a5095 5
	else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_TVOUT))
		/* XXX: just matching BIOS for now */
		/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
		dpll |= 3;
	else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&
d5102 1
a5102 19
	I915_WRITE(DPLL(pipe), dpll & ~DPLL_VCO_ENABLE);
	POSTING_READ(DPLL(pipe));
	udelay(150);

	/* The LVDS pin pair needs to be on before the DPLLs are enabled.
	 * This is an exception to the general rule that mode_set doesn't turn
	 * things on.
	 */
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
		intel_update_lvds(crtc, clock, adjusted_mode);

	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_DISPLAYPORT))
		intel_dp_set_m_n(crtc, mode, adjusted_mode);

	I915_WRITE(DPLL(pipe), dpll);

	/* Wait for the clocks to stabilize. */
	POSTING_READ(DPLL(pipe));
	udelay(150);
d5105 3
a5107 16
		u32 temp = 0;
		if (is_sdvo) {
			temp = intel_mode_get_pixel_multiplier(adjusted_mode);
			if (temp > 1)
				temp = (temp - 1) << DPLL_MD_UDI_MULTIPLIER_SHIFT;
			else
				temp = 0;
		}
		I915_WRITE(DPLL_MD(pipe), temp);
	} else {
		/* The pixel multiplier can only be updated once the
		 * DPLL is enabled and the clocks are stable.
		 *
		 * So write it again.
		 */
		I915_WRITE(DPLL(pipe), dpll);
d5109 3
d5114 2
a5115 3
static void i8xx_update_pll(struct drm_crtc *crtc,
			    struct drm_display_mode *adjusted_mode,
			    intel_clock_t *clock, intel_clock_t *reduced_clock,
d5118 1
a5118 1
	struct drm_device *dev = crtc->dev;
a5119 2
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
d5121 1
d5123 1
a5123 1
	i9xx_update_pll_dividers(crtc, clock, reduced_clock);
d5127 1
a5127 1
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS)) {
d5138 4
a5141 5
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_TVOUT))
		/* XXX: just matching BIOS for now */
		/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
		dpll |= 3;
	else if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS) &&
d5148 1
a5148 23
	I915_WRITE(DPLL(pipe), dpll & ~DPLL_VCO_ENABLE);
	POSTING_READ(DPLL(pipe));
	udelay(150);

	/* The LVDS pin pair needs to be on before the DPLLs are enabled.
	 * This is an exception to the general rule that mode_set doesn't turn
	 * things on.
	 */
	if (intel_pipe_has_type(crtc, INTEL_OUTPUT_LVDS))
		intel_update_lvds(crtc, clock, adjusted_mode);

	I915_WRITE(DPLL(pipe), dpll);

	/* Wait for the clocks to stabilize. */
	POSTING_READ(DPLL(pipe));
	udelay(150);

	/* The pixel multiplier can only be updated once the
	 * DPLL is enabled and the clocks are stable.
	 *
	 * So write it again.
	 */
	I915_WRITE(DPLL(pipe), dpll);
d5151 1
a5151 3
static void intel_set_pipe_timings(struct intel_crtc *intel_crtc,
				   struct drm_display_mode *mode,
				   struct drm_display_mode *adjusted_mode)
d5156 9
a5164 2
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
	uint32_t vsyncshift;
d5168 2
a5169 2
		adjusted_mode->crtc_vtotal -= 1;
		adjusted_mode->crtc_vblank_end -= 1;
d5191 1
a5191 1
		   ((adjusted_mode->crtc_vtotal - 1) << 16));
d5194 1
a5194 1
		   ((adjusted_mode->crtc_vblank_end - 1) << 16));
d5211 125
a5335 1
		   ((mode->hdisplay - 1) << 16) | (mode->vdisplay - 1));
a5338 2
			      struct drm_display_mode *mode,
			      struct drm_display_mode *adjusted_mode,
d5349 3
a5351 3
	u32 dspcntr, pipeconf;
	bool ok, has_reduced_clock = false, is_sdvo = false;
	bool is_lvds = false, is_tv = false, is_dp = false;
d5361 2
a5362 11
		case INTEL_OUTPUT_SDVO:
		case INTEL_OUTPUT_HDMI:
			is_sdvo = true;
			if (encoder->needs_tv_clock)
				is_tv = true;
			break;
		case INTEL_OUTPUT_TVOUT:
			is_tv = true;
			break;
		case INTEL_OUTPUT_DISPLAYPORT:
			is_dp = true;
d5369 2
a5370 1
	refclk = i9xx_get_refclk(crtc, num_connectors);
d5372 17
a5388 12
	/*
	 * Returns a set of divisors for the desired target clock with the given
	 * refclk, or FALSE.  The returned values represent the clock equation:
	 * reflck * (5 * (m1 + 2) + (m2 + 2)) / (n + 2) / p1 / p2.
	 */
	limit = intel_limit(crtc, refclk);
	ok = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk, NULL,
			     &clock);
	if (!ok) {
		DRM_ERROR("Couldn't find PLL settings for mode!\n");
		return -EINVAL;
	}
d5390 19
a5408 12
	if (is_lvds && dev_priv->lvds_downclock_avail) {
		/*
		 * Ensure we match the reduced clock's P to the target clock.
		 * If the clocks don't match, we can't switch the display clock
		 * by using the FP0/FP1. In such case we will disable the LVDS
		 * downclock feature.
		*/
		has_reduced_clock = limit->find_pll(limit, crtc,
						    dev_priv->lvds_downclock,
						    refclk,
						    &clock,
						    &reduced_clock);
d5411 2
a5412 5
	if (is_sdvo && is_tv)
		i9xx_adjust_sdvo_tv_clock(adjusted_mode, &clock);

	if (IS_GEN2(dev))
		i8xx_update_pll(crtc, adjusted_mode, &clock,
d5415 4
a5418 2
	else if (IS_VALLEYVIEW(dev))
		vlv_update_pll(crtc, mode, adjusted_mode, &clock,
d5420 2
a5421 8
				num_connectors);
	else
		i9xx_update_pll(crtc, mode, adjusted_mode, &clock,
				has_reduced_clock ? &reduced_clock : NULL,
				num_connectors);

	/* setup pipeconf */
	pipeconf = I915_READ(PIPECONF(pipe));
d5423 1
d5427 3
a5429 15
	if (pipe == 0)
		dspcntr &= ~DISPPLANE_SEL_PIPE_MASK;
	else
		dspcntr |= DISPPLANE_SEL_PIPE_B;

	if (pipe == 0 && INTEL_INFO(dev)->gen < 4) {
		/* Enable pixel doubling when the dot clock is > 90% of the (display)
		 * core speed.
		 *
		 * XXX: No double-wide on 915GM pipe B. Is that the only reason for the
		 * pipe == 0 check?
		 */
		if (mode->clock >
		    dev_priv->display.get_display_clock_speed(dev) * 9 / 10)
			pipeconf |= PIPECONF_DOUBLE_WIDE;
d5431 1
a5431 32
			pipeconf &= ~PIPECONF_DOUBLE_WIDE;
	}

	/* default to 8bpc */
	pipeconf &= ~(PIPECONF_BPP_MASK | PIPECONF_DITHER_EN);
	if (is_dp) {
		if (adjusted_mode->private_flags & INTEL_MODE_DP_FORCE_6BPC) {
			pipeconf |= PIPECONF_BPP_6 |
				    PIPECONF_DITHER_EN |
				    PIPECONF_DITHER_TYPE_SP;
		}
	}

	if (IS_VALLEYVIEW(dev) && intel_pipe_has_type(crtc, INTEL_OUTPUT_EDP)) {
		if (adjusted_mode->private_flags & INTEL_MODE_DP_FORCE_6BPC) {
			pipeconf |= PIPECONF_BPP_6 |
					PIPECONF_ENABLE |
					I965_PIPECONF_ACTIVE;
		}
	}

	DRM_DEBUG_KMS("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
	drm_mode_debug_printmodeline(mode);

	if (HAS_PIPE_CXSR(dev)) {
		if (intel_crtc->lowfreq_avail) {
			DRM_DEBUG_KMS("enabling CxSR downclocking\n");
			pipeconf |= PIPECONF_CXSR_DOWNCLOCK;
		} else {
			DRM_DEBUG_KMS("disabling CxSR downclocking\n");
			pipeconf &= ~PIPECONF_CXSR_DOWNCLOCK;
		}
d5434 1
a5434 8
	pipeconf &= ~PIPECONF_INTERLACE_MASK;
	if (!IS_GEN2(dev) &&
	    adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
		pipeconf |= PIPECONF_INTERLACE_W_FIELD_INDICATION;
	else
		pipeconf |= PIPECONF_PROGRESSIVE;

	intel_set_pipe_timings(intel_crtc, mode, adjusted_mode);
d5440 2
a5441 2
		   ((mode->vdisplay - 1) << 16) |
		   (mode->hdisplay - 1));
d5444 1
a5444 5
	I915_WRITE(PIPECONF(pipe), pipeconf);
	POSTING_READ(PIPECONF(pipe));
	intel_enable_pipe(dev_priv, pipe, false);

	intel_wait_for_vblank(dev, pipe);
d5451 128
a5578 1
	intel_update_watermarks(dev);
d5580 1
a5580 1
	return ret;
d5588 1
a5588 1
	u32 temp;
a5590 1
	bool has_pch_edp = false;
d5605 1
a5605 3
			if (intel_encoder_is_pch_edp(&encoder->base))
				has_pch_edp = true;
			else
d5612 1
a5612 1
		has_ck505 = dev_priv->display_clock_mode;
d5619 2
a5620 3
	DRM_DEBUG_KMS("has_panel %d has_lvds %d has_pch_edp %d has_cpu_edp %d has_ck505 %d\n",
		      has_panel, has_lvds, has_pch_edp, has_cpu_edp,
		      has_ck505);
d5627 38
a5664 1
	temp = I915_READ(PCH_DREF_CONTROL);
d5666 1
a5666 1
	temp &= ~DREF_NONSPREAD_SOURCE_MASK;
d5669 1
a5669 1
		temp |= DREF_NONSPREAD_CK505_ENABLE;
d5671 1
a5671 1
		temp |= DREF_NONSPREAD_SOURCE_ENABLE;
d5674 2
a5675 2
		temp &= ~DREF_SSC_SOURCE_MASK;
		temp |= DREF_SSC_SOURCE_ENABLE;
d5680 1
a5680 1
			temp |= DREF_SSC1_ENABLE;
d5682 1
a5682 1
			temp &= ~DREF_SSC1_ENABLE;
d5685 1
a5685 1
		I915_WRITE(PCH_DREF_CONTROL, temp);
d5689 1
a5689 1
		temp &= ~DREF_CPU_SOURCE_OUTPUT_MASK;
d5695 1
a5695 1
				temp |= DREF_CPU_SOURCE_OUTPUT_DOWNSPREAD;
d5698 1
a5698 1
				temp |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;
d5700 1
a5700 1
			temp |= DREF_CPU_SOURCE_OUTPUT_DISABLE;
d5702 1
a5702 1
		I915_WRITE(PCH_DREF_CONTROL, temp);
d5708 1
a5708 1
		temp &= ~DREF_CPU_SOURCE_OUTPUT_MASK;
d5711 1
a5711 1
		temp |= DREF_CPU_SOURCE_OUTPUT_DISABLE;
d5713 1
a5713 1
		I915_WRITE(PCH_DREF_CONTROL, temp);
d5718 2
a5719 2
		temp &= ~DREF_SSC_SOURCE_MASK;
		temp |= DREF_SSC_SOURCE_DISABLE;
d5722 1
a5722 1
		temp &= ~ DREF_SSC1_ENABLE;
d5724 1
a5724 1
		I915_WRITE(PCH_DREF_CONTROL, temp);
d5728 2
d5732 1
a5732 2
/* Sequence to enable CLKOUT_DP for FDI usage and configure PCH FDI I/O. */
static void lpt_init_pch_refclk(struct drm_device *dev)
d5734 1
a5734 17
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_mode_config *mode_config = &dev->mode_config;
	struct intel_encoder *encoder;
	bool has_vga = false;
	bool is_sdv = false;
	u32 tmp;

	list_for_each_entry(encoder, &mode_config->encoder_list, base.head) {
		switch (encoder->type) {
		case INTEL_OUTPUT_ANALOG:
			has_vga = true;
			break;
		}
	}

	if (!has_vga)
		return;
d5736 3
a5738 3
	/* XXX: Rip out SDV support once Haswell ships for real. */
	if (IS_HASWELL(dev) && (dev->pci_device & 0xFF00) == 0x0C00)
		is_sdv = true;
d5740 3
a5742 4
	tmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);
	tmp &= ~SBI_SSCCTL_DISABLE;
	tmp |= SBI_SSCCTL_PATHALT;
	intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);
d5744 3
a5746 1
	udelay(24);
d5748 4
a5751 3
	tmp = intel_sbi_read(dev_priv, SBI_SSCCTL, SBI_ICLK);
	tmp &= ~SBI_SSCCTL_PATHALT;
	intel_sbi_write(dev_priv, SBI_SSCCTL, tmp, SBI_ICLK);
d5753 4
a5756 18
	if (!is_sdv) {
		tmp = I915_READ(SOUTH_CHICKEN2);
		tmp |= FDI_MPHY_IOSFSB_RESET_CTL;
		I915_WRITE(SOUTH_CHICKEN2, tmp);

		if (wait_for_atomic_us(I915_READ(SOUTH_CHICKEN2) &
				       FDI_MPHY_IOSFSB_RESET_STATUS, 100))
			DRM_ERROR("FDI mPHY reset assert timeout\n");

		tmp = I915_READ(SOUTH_CHICKEN2);
		tmp &= ~FDI_MPHY_IOSFSB_RESET_CTL;
		I915_WRITE(SOUTH_CHICKEN2, tmp);

		if (wait_for_atomic_us((I915_READ(SOUTH_CHICKEN2) &
				        FDI_MPHY_IOSFSB_RESET_STATUS) == 0,
				       100))
			DRM_ERROR("FDI mPHY reset de-assert timeout\n");
	}
a5762 13
	if (!is_sdv) {
		tmp = intel_sbi_read(dev_priv, 0x808C, SBI_MPHY);
		tmp &= ~(0x3 << 6);
		tmp |= (1 << 6) | (1 << 0);
		intel_sbi_write(dev_priv, 0x808C, tmp, SBI_MPHY);
	}

	if (is_sdv) {
		tmp = intel_sbi_read(dev_priv, 0x800C, SBI_MPHY);
		tmp |= 0x7FFF;
		intel_sbi_write(dev_priv, 0x800C, tmp, SBI_MPHY);
	}

a5770 18
	if (is_sdv) {
		tmp = intel_sbi_read(dev_priv, 0x2038, SBI_MPHY);
		tmp |= (0x3F << 24) | (0xF << 20) | (0xF << 16);
		intel_sbi_write(dev_priv, 0x2038, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x2138, SBI_MPHY);
		tmp |= (0x3F << 24) | (0xF << 20) | (0xF << 16);
		intel_sbi_write(dev_priv, 0x2138, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x203C, SBI_MPHY);
		tmp |= (0x3F << 8);
		intel_sbi_write(dev_priv, 0x203C, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x213C, SBI_MPHY);
		tmp |= (0x3F << 8);
		intel_sbi_write(dev_priv, 0x213C, tmp, SBI_MPHY);
	}

d5779 9
a5787 11
	if (!is_sdv) {
		tmp = intel_sbi_read(dev_priv, 0x2080, SBI_MPHY);
		tmp &= ~(7 << 13);
		tmp |= (5 << 13);
		intel_sbi_write(dev_priv, 0x2080, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x2180, SBI_MPHY);
		tmp &= ~(7 << 13);
		tmp |= (5 << 13);
		intel_sbi_write(dev_priv, 0x2180, tmp, SBI_MPHY);
	}
d5809 112
a5920 24
	if (!is_sdv) {
		tmp = intel_sbi_read(dev_priv, 0x20C4, SBI_MPHY);
		tmp |= (1 << 27);
		intel_sbi_write(dev_priv, 0x20C4, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x21C4, SBI_MPHY);
		tmp |= (1 << 27);
		intel_sbi_write(dev_priv, 0x21C4, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x20EC, SBI_MPHY);
		tmp &= ~(0xF << 28);
		tmp |= (4 << 28);
		intel_sbi_write(dev_priv, 0x20EC, tmp, SBI_MPHY);

		tmp = intel_sbi_read(dev_priv, 0x21EC, SBI_MPHY);
		tmp &= ~(0xF << 28);
		tmp |= (4 << 28);
		intel_sbi_write(dev_priv, 0x21EC, tmp, SBI_MPHY);
	}

	/* ULT uses SBI_GEN0, but ULT doesn't have VGA, so we don't care. */
	tmp = intel_sbi_read(dev_priv, SBI_DBUFF0, SBI_ICLK);
	tmp |= SBI_DBUFF0_ENABLE;
	intel_sbi_write(dev_priv, SBI_DBUFF0, tmp, SBI_ICLK);
a5938 1
	struct intel_encoder *edp_encoder = NULL;
a5946 3
		case INTEL_OUTPUT_EDP:
			edp_encoder = encoder;
			break;
d5952 3
a5954 3
		DRM_DEBUG_KMS("using SSC reference clock of %d MHz\n",
			      dev_priv->lvds_ssc_freq);
		return dev_priv->lvds_ssc_freq * 1000;
d5960 1
a5960 3
static void ironlake_set_pipeconf(struct drm_crtc *crtc,
				  struct drm_display_mode *adjusted_mode,
				  bool dither)
d5967 1
a5967 1
	val = I915_READ(PIPECONF(pipe));
d5969 1
a5969 2
	val &= ~PIPE_BPC_MASK;
	switch (intel_crtc->bpp) {
d5971 1
a5971 1
		val |= PIPE_6BPC;
d5974 1
a5974 1
		val |= PIPE_8BPC;
d5977 1
a5977 1
		val |= PIPE_10BPC;
d5980 1
a5980 1
		val |= PIPE_12BPC;
d5987 1
a5987 2
	val &= ~(PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_MASK);
	if (dither)
d5990 1
a5990 2
	val &= ~PIPECONF_INTERLACE_MASK;
	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
d5995 3
d6002 65
a6066 3
static void haswell_set_pipeconf(struct drm_crtc *crtc,
				 struct drm_display_mode *adjusted_mode,
				 bool dither)
d6068 2
a6069 1
	struct drm_i915_private *dev_priv = crtc->dev->dev_private;
d6071 2
a6072 1
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
d6075 1
a6075 1
	val = I915_READ(PIPECONF(cpu_transcoder));
d6077 1
a6077 2
	val &= ~(PIPECONF_DITHER_EN | PIPECONF_DITHER_TYPE_MASK);
	if (dither)
d6080 1
a6080 2
	val &= ~PIPECONF_INTERLACE_MASK_HSW;
	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
d6087 31
a6117 1
}
a6119 1
				    struct drm_display_mode *adjusted_mode,
d6129 1
a6129 1
	bool ret, is_sdvo = false, is_tv = false, is_lvds = false;
a6135 9
		case INTEL_OUTPUT_SDVO:
		case INTEL_OUTPUT_HDMI:
			is_sdvo = true;
			if (intel_encoder->needs_tv_clock)
				is_tv = true;
			break;
		case INTEL_OUTPUT_TVOUT:
			is_tv = true;
			break;
d6147 3
a6149 2
	ret = limit->find_pll(limit, crtc, adjusted_mode->clock, refclk, NULL,
			      clock);
d6160 5
a6164 5
		*has_reduced_clock = limit->find_pll(limit, crtc,
						     dev_priv->lvds_downclock,
						     refclk,
						     clock,
						     reduced_clock);
a6166 3
	if (is_sdvo && is_tv)
		i9xx_adjust_sdvo_tv_clock(adjusted_mode, clock);

a6169 82
static void cpt_enable_fdi_bc_bifurcation(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t temp;

	temp = I915_READ(SOUTH_CHICKEN1);
	if (temp & FDI_BC_BIFURCATION_SELECT)
		return;

	WARN_ON(I915_READ(FDI_RX_CTL(PIPE_B)) & FDI_RX_ENABLE);
	WARN_ON(I915_READ(FDI_RX_CTL(PIPE_C)) & FDI_RX_ENABLE);

	temp |= FDI_BC_BIFURCATION_SELECT;
	DRM_DEBUG_KMS("enabling fdi C rx\n");
	I915_WRITE(SOUTH_CHICKEN1, temp);
	POSTING_READ(SOUTH_CHICKEN1);
}

static bool ironlake_check_fdi_lanes(struct intel_crtc *intel_crtc)
{
	struct drm_device *dev = intel_crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *pipe_B_crtc =
		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_B]);

	DRM_DEBUG_KMS("checking fdi config on pipe %i, lanes %i\n",
		      intel_crtc->pipe, intel_crtc->fdi_lanes);
	if (intel_crtc->fdi_lanes > 4) {
		DRM_DEBUG_KMS("invalid fdi lane config on pipe %i: %i lanes\n",
			      intel_crtc->pipe, intel_crtc->fdi_lanes);
		/* Clamp lanes to avoid programming the hw with bogus values. */
		intel_crtc->fdi_lanes = 4;

		return false;
	}

	if (INTEL_INFO(dev)->num_pipes == 2)
		return true;

	switch (intel_crtc->pipe) {
	case PIPE_A:
		return true;
	case PIPE_B:
		if (dev_priv->pipe_to_crtc_mapping[PIPE_C]->enabled &&
		    intel_crtc->fdi_lanes > 2) {
			DRM_DEBUG_KMS("invalid shared fdi lane config on pipe %i: %i lanes\n",
				      intel_crtc->pipe, intel_crtc->fdi_lanes);
			/* Clamp lanes to avoid programming the hw with bogus values. */
			intel_crtc->fdi_lanes = 2;

			return false;
		}

		if (intel_crtc->fdi_lanes > 2)
			WARN_ON(I915_READ(SOUTH_CHICKEN1) & FDI_BC_BIFURCATION_SELECT);
		else
			cpt_enable_fdi_bc_bifurcation(dev);

		return true;
	case PIPE_C:
		if (!pipe_B_crtc->base.enabled || pipe_B_crtc->fdi_lanes <= 2) {
			if (intel_crtc->fdi_lanes > 2) {
				DRM_DEBUG_KMS("invalid shared fdi lane config on pipe %i: %i lanes\n",
					      intel_crtc->pipe, intel_crtc->fdi_lanes);
				/* Clamp lanes to avoid programming the hw with bogus values. */
				intel_crtc->fdi_lanes = 2;

				return false;
			}
		} else {
			DRM_DEBUG_KMS("fdi link B uses too many lanes to enable link C\n");
			return false;
		}

		cpt_enable_fdi_bc_bifurcation(dev);

		return true;
	default:
		BUG();
	}
}

d6181 1
a6181 3
static void ironlake_set_m_n(struct drm_crtc *crtc,
			     struct drm_display_mode *mode,
			     struct drm_display_mode *adjusted_mode)
d6183 1
a6183 64
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
	struct intel_encoder *intel_encoder, *edp_encoder = NULL;
	struct fdi_m_n m_n = {0};
	int target_clock, pixel_multiplier, lane, link_bw;
	bool is_dp = false, is_cpu_edp = false;

	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		switch (intel_encoder->type) {
		case INTEL_OUTPUT_DISPLAYPORT:
			is_dp = true;
			break;
		case INTEL_OUTPUT_EDP:
			is_dp = true;
			if (!intel_encoder_is_pch_edp(&intel_encoder->base))
				is_cpu_edp = true;
			edp_encoder = intel_encoder;
			break;
		}
	}

	/* FDI link */
	pixel_multiplier = intel_mode_get_pixel_multiplier(adjusted_mode);
	lane = 0;
	/* CPU eDP doesn't require FDI link, so just set DP M/N
	   according to current link config */
	if (is_cpu_edp) {
		intel_edp_link_config(edp_encoder, &lane, &link_bw);
	} else {
		/* FDI is a binary signal running at ~2.7GHz, encoding
		 * each output octet as 10 bits. The actual frequency
		 * is stored as a divider into a 100MHz clock, and the
		 * mode pixel clock is stored in units of 1KHz.
		 * Hence the bw of each lane in terms of the mode signal
		 * is:
		 */
		link_bw = intel_fdi_link_freq(dev) * MHz(100)/KHz(1)/10;
	}

	/* [e]DP over FDI requires target mode clock instead of link clock. */
	if (edp_encoder)
		target_clock = intel_edp_target_clock(edp_encoder, mode);
	else if (is_dp)
		target_clock = mode->clock;
	else
		target_clock = adjusted_mode->clock;

	if (!lane)
		lane = ironlake_get_lanes_required(target_clock, link_bw,
						   intel_crtc->bpp);

	intel_crtc->fdi_lanes = lane;

	if (pixel_multiplier > 1)
		link_bw *= pixel_multiplier;
	ironlake_compute_m_n(intel_crtc->bpp, lane, target_clock, link_bw,
			     &m_n);

	I915_WRITE(PIPE_DATA_M1(cpu_transcoder), TU_SIZE(m_n.tu) | m_n.gmch_m);
	I915_WRITE(PIPE_DATA_N1(cpu_transcoder), m_n.gmch_n);
	I915_WRITE(PIPE_LINK_M1(cpu_transcoder), m_n.link_m);
	I915_WRITE(PIPE_LINK_N1(cpu_transcoder), m_n.link_n);
d6187 2
a6188 2
				      struct drm_display_mode *adjusted_mode,
				      intel_clock_t *clock, u32 fp)
d6195 2
a6196 3
	int factor, pixel_multiplier, num_connectors = 0;
	bool is_lvds = false, is_sdvo = false, is_tv = false;
	bool is_dp = false, is_cpu_edp = false;
a6205 13
			if (intel_encoder->needs_tv_clock)
				is_tv = true;
			break;
		case INTEL_OUTPUT_TVOUT:
			is_tv = true;
			break;
		case INTEL_OUTPUT_DISPLAYPORT:
			is_dp = true;
			break;
		case INTEL_OUTPUT_EDP:
			is_dp = true;
			if (!intel_encoder_is_pch_edp(&intel_encoder->base))
				is_cpu_edp = true;
d6216 2
a6217 2
		     dev_priv->lvds_ssc_freq == 100) ||
		    (I915_READ(PCH_LVDS) & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP)
d6219 1
a6219 1
	} else if (is_sdvo && is_tv)
d6222 5
a6226 2
	if (clock->m < factor * clock->n)
		fp |= FP_CB_TUNE;
d6234 8
a6241 9
	if (is_sdvo) {
		pixel_multiplier = intel_mode_get_pixel_multiplier(adjusted_mode);
		if (pixel_multiplier > 1) {
			dpll |= (pixel_multiplier - 1) << PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT;
		}
		dpll |= DPLL_DVO_HIGH_SPEED;
	}
	if (is_dp && !is_cpu_edp)
		dpll |= DPLL_DVO_HIGH_SPEED;
d6244 1
a6244 1
	dpll |= (1 << (clock->p1 - 1)) << DPLL_FPA01_P1_POST_DIV_SHIFT;
d6246 1
a6246 1
	dpll |= (1 << (clock->p1 - 1)) << DPLL_FPA1_P1_POST_DIV_SHIFT;
d6248 1
a6248 1
	switch (clock->p2) {
d6263 1
a6263 7
	if (is_sdvo && is_tv)
		dpll |= PLL_REF_INPUT_TVCLKINBC;
	else if (is_tv)
		/* XXX: just matching BIOS for now */
		/*	dpll |= PLL_REF_INPUT_TVCLKINBC; */
		dpll |= 3;
	else if (is_lvds && intel_panel_use_ssc(dev_priv) && num_connectors < 2)
d6268 1
a6268 1
	return dpll;
a6271 2
				  struct drm_display_mode *mode,
				  struct drm_display_mode *adjusted_mode,
d6278 1
d6280 1
d6284 1
a6284 1
	u32 dpll, fp = 0, fp2 = 0;
d6286 1
a6286 1
	bool is_lvds = false, is_dp = false, is_cpu_edp = false;
d6288 1
a6288 1
	u32 temp;
a6289 1
	bool dither, fdi_config_ok;
a6295 8
		case INTEL_OUTPUT_DISPLAYPORT:
			is_dp = true;
			break;
		case INTEL_OUTPUT_EDP:
			is_dp = true;
			if (!intel_encoder_is_pch_edp(&encoder->base))
				is_cpu_edp = true;
			break;
d6304 1
a6304 1
	ok = ironlake_compute_clocks(crtc, adjusted_mode, &clock,
d6306 1
a6306 1
	if (!ok) {
d6310 8
d6319 5
a6323 10
	/* determine panel color depth */
	dither = intel_choose_pipe_bpp_dither(crtc, fb, &intel_crtc->bpp,
					      adjusted_mode);
	if (is_lvds && dev_priv->lvds_dither)
		dither = true;

	fp = clock.n << 16 | clock.m1 << 8 | clock.m2;
	if (has_reduced_clock)
		fp2 = reduced_clock.n << 16 | reduced_clock.m1 << 8 |
			reduced_clock.m2;
d6325 3
a6327 1
	dpll = ironlake_compute_dpll(intel_crtc, adjusted_mode, &clock, fp);
d6329 6
a6334 2
	DRM_DEBUG_KMS("Mode for pipe %d:\n", pipe);
	drm_mode_debug_printmodeline(mode);
d6336 1
a6336 5
	/* CPU eDP is the only output that doesn't need a PCH PLL of its own. */
	if (!is_cpu_edp) {
		struct intel_pch_pll *pll;

		pll = intel_get_pch_pll(intel_crtc, dpll, fp);
d6338 2
a6339 2
			DRM_DEBUG_DRIVER("failed to find PLL for pipe %d\n",
					 pipe);
d6343 145
a6487 1
		intel_put_pch_pll(intel_crtc);
d6489 11
a6499 10
	/* The LVDS pin pair needs to be on before the DPLLs are enabled.
	 * This is an exception to the general rule that mode_set doesn't turn
	 * things on.
	 */
	if (is_lvds) {
		temp = I915_READ(PCH_LVDS);
		temp |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;
		if (HAS_PCH_CPT(dev)) {
			temp &= ~PORT_TRANS_SEL_MASK;
			temp |= PORT_TRANS_SEL_CPT(pipe);
d6501 3
a6503 2
			if (pipe == 1)
				temp |= LVDS_PIPEB_SELECT;
d6505 1
a6505 1
				temp &= ~LVDS_PIPEB_SELECT;
d6508 327
a6834 9
		/* set the corresponsding LVDS_BORDER bit */
		temp |= dev_priv->lvds_border_bits;
		/* Set the B0-B3 data pairs corresponding to whether we're going to
		 * set the DPLLs for dual-channel mode or not.
		 */
		if (clock.p2 == 7)
			temp |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
		else
			temp &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);
d6836 4
a6839 28
		/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP)
		 * appropriately here, but we need to look more thoroughly into how
		 * panels behave in the two modes.
		 */
		temp &= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);
		if (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)
			temp |= LVDS_HSYNC_POLARITY;
		if (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)
			temp |= LVDS_VSYNC_POLARITY;
		I915_WRITE(PCH_LVDS, temp);
	}

	if (is_dp && !is_cpu_edp) {
		intel_dp_set_m_n(crtc, mode, adjusted_mode);
	} else {
		/* For non-DP output, clear any trans DP clock recovery setting.*/
		I915_WRITE(TRANSDATA_M1(pipe), 0);
		I915_WRITE(TRANSDATA_N1(pipe), 0);
		I915_WRITE(TRANSDPLINK_M1(pipe), 0);
		I915_WRITE(TRANSDPLINK_N1(pipe), 0);
	}

	if (intel_crtc->pch_pll) {
		I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);

		/* Wait for the clocks to stabilize. */
		POSTING_READ(intel_crtc->pch_pll->pll_reg);
		udelay(150);
d6841 4
a6844 6
		/* The pixel multiplier can only be updated once the
		 * DPLL is enabled and the clocks are stable.
		 *
		 * So write it again.
		 */
		I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);
d6846 2
d6849 9
a6857 8
	intel_crtc->lowfreq_avail = false;
	if (intel_crtc->pch_pll) {
		if (is_lvds && has_reduced_clock && i915_powersave) {
			I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp2);
			intel_crtc->lowfreq_avail = true;
		} else {
			I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp);
		}
d6859 2
d6862 3
a6864 1
	intel_set_pipe_timings(intel_crtc, mode, adjusted_mode);
d6866 7
a6872 3
	/* Note, this also computes intel_crtc->fdi_lanes which is used below in
	 * ironlake_check_fdi_lanes. */
	ironlake_set_m_n(crtc, mode, adjusted_mode);
d6874 4
a6877 1
	fdi_config_ok = ironlake_check_fdi_lanes(intel_crtc);
d6879 2
a6880 2
	if (is_cpu_edp)
		ironlake_set_pll_edp(crtc, adjusted_mode->clock);
d6882 3
a6884 1
	ironlake_set_pipeconf(crtc, adjusted_mode, dither);
d6886 33
a6918 1
	intel_wait_for_vblank(dev, pipe);
d6920 2
a6921 3
	/* Set up the display plane register */
	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
	POSTING_READ(DSPCNTR(plane));
d6923 2
a6924 1
	ret = intel_pipe_set_base(crtc, x, y, fb);
d6926 2
a6927 1
	intel_update_watermarks(dev);
d6929 2
a6930 1
	intel_update_linetime_watermarks(dev, pipe, adjusted_mode);
d6932 4
a6935 1
	return fdi_config_ok ? ret : -EINVAL;
a6938 2
				 struct drm_display_mode *mode,
				 struct drm_display_mode *adjusted_mode,
a6944 1
	int pipe = intel_crtc->pipe;
a6945 7
	int num_connectors = 0;
	intel_clock_t clock, reduced_clock;
	u32 dpll = 0, fp = 0, fp2 = 0;
	bool ok, has_reduced_clock = false;
	bool is_lvds = false, is_dp = false, is_cpu_edp = false;
	struct intel_encoder *encoder;
	u32 temp;
a6946 1
	bool dither;
d6948 3
a6950 14
	for_each_encoder_on_crtc(dev, crtc, encoder) {
		switch (encoder->type) {
		case INTEL_OUTPUT_LVDS:
			is_lvds = true;
			break;
		case INTEL_OUTPUT_DISPLAYPORT:
			is_dp = true;
			break;
		case INTEL_OUTPUT_EDP:
			is_dp = true;
			if (!intel_encoder_is_pch_edp(&encoder->base))
				is_cpu_edp = true;
			break;
		}
d6952 2
a6953 2
		num_connectors++;
	}
d6955 1
a6955 4
	if (is_cpu_edp)
		intel_crtc->cpu_transcoder = TRANSCODER_EDP;
	else
		intel_crtc->cpu_transcoder = pipe;
d6957 1
a6957 3
	/* We are not sure yet this won't happen. */
	WARN(!HAS_PCH_LPT(dev), "Unexpected PCH type %d\n",
	     INTEL_PCH_TYPE(dev));
d6959 3
a6961 19
	WARN(num_connectors != 1, "%d connectors attached to pipe %c\n",
	     num_connectors, pipe_name(pipe));

	WARN_ON(I915_READ(PIPECONF(intel_crtc->cpu_transcoder)) &
		(PIPECONF_ENABLE | I965_PIPECONF_ACTIVE));

	WARN_ON(I915_READ(DSPCNTR(plane)) & DISPLAY_PLANE_ENABLE);

	if (!intel_ddi_pll_mode_set(crtc, adjusted_mode->clock))
		return -EINVAL;

	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		ok = ironlake_compute_clocks(crtc, adjusted_mode, &clock,
					     &has_reduced_clock,
					     &reduced_clock);
		if (!ok) {
			DRM_ERROR("Couldn't find PLL settings for mode!\n");
			return -EINVAL;
		}
d6964 1
a6964 5
	/* determine panel color depth */
	dither = intel_choose_pipe_bpp_dither(crtc, fb, &intel_crtc->bpp,
					      adjusted_mode);
	if (is_lvds && dev_priv->lvds_dither)
		dither = true;
d6966 1
a6966 2
	DRM_DEBUG_KMS("Mode for pipe %d:\n", pipe);
	drm_mode_debug_printmodeline(mode);
d6968 3
a6970 5
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		fp = clock.n << 16 | clock.m1 << 8 | clock.m2;
		if (has_reduced_clock)
			fp2 = reduced_clock.n << 16 | reduced_clock.m1 << 8 |
			      reduced_clock.m2;
d6972 1
a6972 2
		dpll = ironlake_compute_dpll(intel_crtc, adjusted_mode, &clock,
					     fp);
d6974 2
a6975 13
		/* CPU eDP is the only output that doesn't need a PCH PLL of its
		 * own on pre-Haswell/LPT generation */
		if (!is_cpu_edp) {
			struct intel_pch_pll *pll;

			pll = intel_get_pch_pll(intel_crtc, dpll, fp);
			if (pll == NULL) {
				DRM_DEBUG_DRIVER("failed to find PLL for pipe %d\n",
						 pipe);
				return -EINVAL;
			}
		} else
			intel_put_pch_pll(intel_crtc);
d6977 7
a6983 16
		/* The LVDS pin pair needs to be on before the DPLLs are
		 * enabled.  This is an exception to the general rule that
		 * mode_set doesn't turn things on.
		 */
		if (is_lvds) {
			temp = I915_READ(PCH_LVDS);
			temp |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;
			if (HAS_PCH_CPT(dev)) {
				temp &= ~PORT_TRANS_SEL_MASK;
				temp |= PORT_TRANS_SEL_CPT(pipe);
			} else {
				if (pipe == 1)
					temp |= LVDS_PIPEB_SELECT;
				else
					temp &= ~LVDS_PIPEB_SELECT;
			}
d6985 2
a6986 11
			/* set the corresponsding LVDS_BORDER bit */
			temp |= dev_priv->lvds_border_bits;
			/* Set the B0-B3 data pairs corresponding to whether
			 * we're going to set the DPLLs for dual-channel mode or
			 * not.
			 */
			if (clock.p2 == 7)
				temp |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
			else
				temp &= ~(LVDS_B0B3_POWER_UP |
					  LVDS_CLKB_POWER_UP);
d6988 16
a7003 11
			/* It would be nice to set 24 vs 18-bit mode
			 * (LVDS_A3_POWER_UP) appropriately here, but we need to
			 * look more thoroughly into how panels behave in the
			 * two modes.
			 */
			temp &= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);
			if (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)
				temp |= LVDS_HSYNC_POLARITY;
			if (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)
				temp |= LVDS_VSYNC_POLARITY;
			I915_WRITE(PCH_LVDS, temp);
a7004 1
	}
d7006 2
a7007 11
	if (is_dp && !is_cpu_edp) {
		intel_dp_set_m_n(crtc, mode, adjusted_mode);
	} else {
		if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
			/* For non-DP output, clear any trans DP clock recovery
			 * setting.*/
			I915_WRITE(TRANSDATA_M1(pipe), 0);
			I915_WRITE(TRANSDATA_N1(pipe), 0);
			I915_WRITE(TRANSDPLINK_M1(pipe), 0);
			I915_WRITE(TRANSDPLINK_N1(pipe), 0);
		}
d7010 3
a7012 16
	intel_crtc->lowfreq_avail = false;
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		if (intel_crtc->pch_pll) {
			I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);

			/* Wait for the clocks to stabilize. */
			POSTING_READ(intel_crtc->pch_pll->pll_reg);
			udelay(150);

			/* The pixel multiplier can only be updated once the
			 * DPLL is enabled and the clocks are stable.
			 *
			 * So write it again.
			 */
			I915_WRITE(intel_crtc->pch_pll->pll_reg, dpll);
		}
d7014 3
a7016 9
		if (intel_crtc->pch_pll) {
			if (is_lvds && has_reduced_clock && i915_powersave) {
				I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp2);
				intel_crtc->lowfreq_avail = true;
			} else {
				I915_WRITE(intel_crtc->pch_pll->fp1_reg, fp);
			}
		}
	}
d7018 9
a7026 1
	intel_set_pipe_timings(intel_crtc, mode, adjusted_mode);
d7028 3
a7030 2
	if (!is_dp || is_cpu_edp)
		ironlake_set_m_n(crtc, mode, adjusted_mode);
d7032 2
a7033 3
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		if (is_cpu_edp)
			ironlake_set_pll_edp(crtc, adjusted_mode->clock);
d7035 1
a7035 5
	haswell_set_pipeconf(crtc, adjusted_mode, dither);

	/* Set up the display plane register */
	I915_WRITE(DSPCNTR(plane), DISPPLANE_GAMMA_ENABLE);
	POSTING_READ(DSPCNTR(plane));
d7037 3
a7039 1
	ret = intel_pipe_set_base(crtc, x, y, fb);
d7041 3
a7043 1
	intel_update_watermarks(dev);
d7045 1
a7045 1
	intel_update_linetime_watermarks(dev, pipe, adjusted_mode);
d7047 1
a7047 1
	return ret;
a7050 2
			       struct drm_display_mode *mode,
			       struct drm_display_mode *adjusted_mode,
a7055 1
	struct drm_encoder_helper_funcs *encoder_funcs;
d7058 3
d7066 2
a7067 2
	ret = dev_priv->display.crtc_mode_set(crtc, mode, adjusted_mode,
					      x, y, fb);
d7078 1
a7078 2
		encoder_funcs = encoder->base.helper_private;
		encoder_funcs->mode_set(&encoder->base, mode, adjusted_mode);
d7084 38
d7152 2
a7153 1
			  struct drm_crtc *crtc)
d7193 2
a7194 1
				     struct drm_crtc *crtc)
d7199 1
d7225 1
a7225 1
	DRM_DEBUG_DRIVER("HDMI audio: pin eld vld status=0x%8x\n", tmp);
d7229 1
a7229 1
	DRM_DEBUG_DRIVER("HDMI audio: eld vld status=0x%8x\n", tmp);
d7233 1
a7233 1
	DRM_DEBUG_DRIVER("HDMI audio: audio conf: 0x%8x\n", tmp);
d7241 1
d7247 3
a7249 2
	} else
		I915_WRITE(aud_config, 0);
d7282 2
a7283 1
				     struct drm_crtc *crtc)
d7301 5
d7315 13
a7327 2
	i = I915_READ(aud_cntl_st);
	i = (i >> 29) & DIP_PORT_SEL_MASK;		/* DIP_Port_Select, 0x1 = PortB */
d7335 1
a7335 1
		DRM_DEBUG_DRIVER("ELD on port %c\n", 'A' + i);
d7343 3
a7345 2
	} else
		I915_WRITE(aud_config, 0);
d7395 1
a7395 26
		dev_priv->display.write_eld(connector, crtc);
}

/** Loads the palette/gamma unit for the CRTC with the prepared values */
void intel_crtc_load_lut(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int palreg = PALETTE(intel_crtc->pipe);
	int i;

	/* The clocks have to be on to load the palette. */
	if (!crtc->enabled || !intel_crtc->active)
		return;

	/* use legacy palette for Ironlake */
	if (HAS_PCH_SPLIT(dev))
		palreg = LGC_PALETTE(intel_crtc->pipe);

	for (i = 0; i < 256; i++) {
		I915_WRITE(palreg + 4 * i,
			   (intel_crtc->lut_r[i] << 16) |
			   (intel_crtc->lut_g[i] << 8) |
			   intel_crtc->lut_b[i]);
	}
d7473 4
d7497 1
a7497 1
	u32 base, pos;
d7500 2
a7501 1
	pos = 0;
d7503 2
a7504 4
	if (on && crtc->enabled && crtc->fb) {
		base = intel_crtc->cursor_addr;
		if (x > (int) crtc->fb->width)
			base = 0;
d7506 1
a7506 3
		if (y > (int) crtc->fb->height)
			base = 0;
	} else
d7510 1
a7510 1
		if (x + intel_crtc->cursor_width < 0)
d7519 1
a7519 1
		if (y + intel_crtc->cursor_height < 0)
d7531 1
a7531 1
	if (IS_IVYBRIDGE(dev) || IS_HASWELL(dev)) {
d7583 2
d7591 10
a7600 1
		ret = i915_gem_object_pin_to_display_plane(obj, 0, NULL);
d7612 1
a7612 1
		addr = obj->gtt_offset;
d7634 1
a7634 1
			i915_gem_object_unpin(intel_crtc->cursor_bo);
d7646 1
a7646 1
		intel_crtc_update_cursor(crtc, true);
d7650 1
a7650 1
	i915_gem_object_unpin(obj);
d7662 2
a7663 2
	intel_crtc->cursor_x = x;
	intel_crtc->cursor_y = y;
d7666 1
a7666 1
		intel_crtc_update_cursor(crtc, true);
a7670 21
/** Sets the color ramps on behalf of RandR */
void intel_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
				 u16 blue, int regno)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	intel_crtc->lut_r[regno] = red >> 8;
	intel_crtc->lut_g[regno] = green >> 8;
	intel_crtc->lut_b[regno] = blue >> 8;
}

void intel_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
			     u16 *blue, int regno)
{
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	*red = intel_crtc->lut_r[regno] << 8;
	*green = intel_crtc->lut_g[regno] << 8;
	*blue = intel_crtc->lut_b[regno] << 8;
}

a7685 14
/**
 * Get a pipe with a simple mode set on it for doing load-based monitor
 * detection.
 *
 * It will be up to the load-detect code to adjust the pipe as appropriate for
 * its requirements.  The pipe will be connected to no other encoders.
 *
 * Currently this code will only succeed if there is a pipe with no encoders
 * configured for it.  In the future, it could choose to temporarily disable
 * some outputs to free up a pipe for its use.
 *
 * \return crtc, or NULL if no pipes are available.
 */

d7706 4
d7711 3
a7713 5
	if (ret) {
		drm_gem_object_unreference_unlocked(&obj->base);
		kfree(intel_fb);
		return ERR_PTR(ret);
	}
d7716 5
d7763 1
d7784 3
d7821 2
d7852 1
d7880 1
d7884 1
a7884 1
	if (!intel_set_mode(crtc, mode, 0, 0, fb)) {
d7888 1
d7903 1
a7909 2
		struct drm_crtc *crtc = encoder->crtc;

d7914 4
a7917 2
		if (old->release_fb)
			old->release_fb->funcs->destroy(old->release_fb);
d7919 1
d7926 18
d7947 2
a7948 1
static int intel_crtc_clock_get(struct drm_device *dev, struct drm_crtc *crtc)
d7950 1
d7952 2
a7953 3
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int pipe = intel_crtc->pipe;
	u32 dpll = I915_READ(DPLL(pipe));
d7956 1
d7959 1
a7959 1
		fp = I915_READ(FP0(pipe));
d7961 1
a7961 1
		fp = I915_READ(FP1(pipe));
d7992 1
a7992 1
			return 0;
d7995 4
a7998 2
		/* XXX: Handle the 100Mhz refclk */
		intel_clock(dev, 96000, &clock);
d8000 2
a8001 1
		bool is_lvds = (pipe == 1) && (I915_READ(LVDS) & LVDS_PORT_EN);
a8005 1
			clock.p2 = 14;
d8007 4
a8010 6
			if ((dpll & PLL_REF_INPUT_MASK) ==
			    PLLB_REF_INPUT_SPREADSPECTRUMIN) {
				/* XXX: might not be 66MHz */
				intel_clock(dev, 66000, &clock);
			} else
				intel_clock(dev, 48000, &clock);
d8022 1
d8024 1
a8024 2
			intel_clock(dev, 48000, &clock);
		}
d8027 19
a8045 3
	/* XXX: It would be nice to validate the clocks, but we can't reuse
	 * i830PllIsValid() because it relies on the xf86_config connector
	 * configuration being accurate, which it isn't necessarily.
d8048 23
a8070 1
	return clock.dot;
d8079 1
a8079 1
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
d8081 1
d8086 1
d8092 15
a8106 1
	mode->clock = intel_crtc_clock_get(dev, crtc);
d8190 4
a8193 1
	i915_update_gfx_val(dev->dev_private);
d8198 1
d8201 2
d8212 3
d8217 2
a8218 1
void intel_mark_fb_busy(struct drm_i915_gem_object *obj)
d8230 6
a8235 2
		if (to_intel_framebuffer(crtc->fb)->obj == obj)
			intel_increase_pllclock(crtc);
d8256 2
a8288 1
	struct drm_i915_gem_object *obj;
d8318 1
a8318 5
	obj = work->old_fb_obj;

	atomic_clear_mask(1 << intel_crtc->plane,
			  &obj->pending_flip);
	wake_up(&dev_priv->pending_flip_queue);
d8358 1
a8358 1
static inline void intel_mark_page_flip_active(struct intel_crtc *intel_crtc)
d8370 2
a8371 1
				 struct drm_i915_gem_object *obj)
d8399 1
a8399 1
	intel_ring_emit(ring, obj->gtt_offset + intel_crtc->dspaddr_offset);
d8403 1
a8403 1
	intel_ring_advance(ring);
d8415 2
a8416 1
				 struct drm_i915_gem_object *obj)
d8441 1
a8441 1
	intel_ring_emit(ring, obj->gtt_offset + intel_crtc->dspaddr_offset);
d8445 1
a8445 1
	intel_ring_advance(ring);
d8457 2
a8458 1
				 struct drm_i915_gem_object *obj)
d8482 1
a8482 1
			(obj->gtt_offset + intel_crtc->dspaddr_offset) |
d8494 1
a8494 1
	intel_ring_advance(ring);
d8506 2
a8507 1
				 struct drm_i915_gem_object *obj)
d8526 1
a8526 1
	intel_ring_emit(ring, obj->gtt_offset + intel_crtc->dspaddr_offset);
d8539 1
a8539 1
	intel_ring_advance(ring);
a8547 6
/*
 * On gen7 we currently use the blit ring because (in early silicon at least)
 * the render ring doesn't give us interrpts for page flip completion, which
 * means clients will hang after the first flip is queued.  Fortunately the
 * blit ring generates interrupts properly, so use it instead.
 */
d8551 2
a8552 1
				 struct drm_i915_gem_object *obj)
d8556 1
a8556 1
	struct intel_ring_buffer *ring = &dev_priv->ring[BCS];
d8558 5
a8562 1
	int ret;
d8584 4
d8602 1
a8602 1
	ret = intel_ring_begin(ring, 4);
d8606 21
d8629 1
a8629 1
	intel_ring_emit(ring, obj->gtt_offset + intel_crtc->dspaddr_offset);
d8633 1
a8633 1
	intel_ring_advance(ring);
d8645 2
a8646 1
				    struct drm_i915_gem_object *obj)
d8653 2
a8654 1
				struct drm_pending_vblank_event *event)
d8678 1
a8678 1
	work = kzalloc(sizeof *work, GFP_KERNEL);
a8703 1
#ifdef notyet
a8705 1
#endif
a8720 4
	/* Block clients from rendering to the new back buffer until
	 * the flip occurs and the object is no longer visible.
	 */
	atomic_add(1 << intel_crtc->plane, &work->old_fb_obj->pending_flip);
d8722 1
d8724 1
a8724 1
	ret = dev_priv->display.queue_flip(dev, crtc, fb, obj);
d8729 1
a8729 1
	intel_mark_fb_busy(obj);
a8738 1
	atomic_sub(1 << intel_crtc->plane, &work->old_fb_obj->pending_flip);
a8757 1
	.disable = intel_crtc_noop,
a8759 44
bool intel_encoder_check_is_cloned(struct intel_encoder *encoder)
{
	struct intel_encoder *other_encoder;
	struct drm_crtc *crtc = &encoder->new_crtc->base;

	if (WARN_ON(!crtc))
		return false;

	list_for_each_entry(other_encoder,
			    &crtc->dev->mode_config.encoder_list,
			    base.head) {

		if (&other_encoder->new_crtc->base != crtc ||
		    encoder == other_encoder)
			continue;
		else
			return true;
	}

	return false;
}

static bool intel_encoder_crtc_ok(struct drm_encoder *encoder,
				  struct drm_crtc *crtc)
{
	struct drm_device *dev;
	struct drm_crtc *tmp;
	int crtc_mask = 1;

	WARN(!crtc, "checking null crtc?\n");

	dev = crtc->dev;

	list_for_each_entry(tmp, &dev->mode_config.crtc_list, head) {
		if (tmp == crtc)
			break;
		crtc_mask <<= 1;
	}

	if (encoder->possible_crtcs & crtc_mask)
		return true;
	return false;
}

d8805 161
a8965 3
static struct drm_display_mode *
intel_modeset_adjusted_mode(struct drm_crtc *crtc,
			    struct drm_display_mode *mode)
a8967 2
	struct drm_display_mode *adjusted_mode;
	struct drm_encoder_helper_funcs *encoder_funcs;
d8969 8
d8978 2
a8979 2
	adjusted_mode = drm_mode_duplicate(dev, mode);
	if (!adjusted_mode)
d8982 49
d9040 3
a9042 4
		encoder_funcs = encoder->base.helper_private;
		if (!(encoder_funcs->mode_fixup(&encoder->base, mode,
						adjusted_mode))) {
			DRM_DEBUG_KMS("Encoder fixup failed\n");
d9047 8
a9054 1
	if (!(intel_crtc_mode_fixup(crtc, mode, adjusted_mode))) {
a9057 1
	DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);
d9059 16
a9074 1
	return adjusted_mode;
d9076 2
a9077 2
	drm_mode_destroy(dev, adjusted_mode);
	return ERR_PTR(-EINVAL);
d9173 3
d9238 18
d9260 143
a9402 1
		if (mask & (1 <<(intel_crtc)->pipe)) \
d9404 5
a9408 2
void
intel_modeset_check_state(struct drm_device *dev)
a9409 2
	struct intel_crtc *crtc;
	struct intel_encoder *encoder;
d9421 7
d9479 9
d9494 2
d9510 1
d9518 78
a9595 1
		assert_pipe(dev->dev_private, crtc->pipe, crtc->active);
d9599 24
a9622 3
bool intel_set_mode(struct drm_crtc *crtc,
		    struct drm_display_mode *mode,
		    int x, int y, struct drm_framebuffer *fb)
d9626 2
a9627 1
	struct drm_display_mode *adjusted_mode, saved_mode, saved_hwmode;
d9630 5
a9634 1
	bool ret = true;
d9639 1
a9639 8
	DRM_DEBUG_KMS("set mode pipe masks: modeset: %x, prepare: %x, disable: %x\n",
		      modeset_pipes, prepare_pipes, disable_pipes);

	for_each_intel_crtc_masked(dev, disable_pipes, intel_crtc)
		intel_crtc_disable(&intel_crtc->base);

	saved_hwmode = crtc->hwmode;
	saved_mode = crtc->mode;
a9645 1
	adjusted_mode = NULL;
d9647 6
a9652 3
		adjusted_mode = intel_modeset_adjusted_mode(crtc, mode);
		if (IS_ERR(adjusted_mode)) {
			return false;
d9654 17
d9673 3
d9684 1
a9684 1
	if (modeset_pipes)
d9686 12
d9710 4
a9713 5
		ret = !intel_crtc_mode_set(&intel_crtc->base,
					   mode, adjusted_mode,
					   x, y, fb);
		if (!ret)
		    goto done;
d9720 16
a9735 3
	if (modeset_pipes) {
		/* Store real post-adjustment hardware mode. */
		crtc->hwmode = *adjusted_mode;
d9737 1
a9737 6
		/* Calculate and store various constants which
		 * are later needed by vblank and swap-completion
		 * timestamping. They are derived from true hwmode.
		 */
		drm_calc_timestamping_constants(crtc);
	}
d9739 2
a9740 9
	/* FIXME: add subpixel order */
done:
	drm_mode_destroy(dev, adjusted_mode);
	if (!ret && crtc->enabled) {
		crtc->hwmode = saved_hwmode;
		crtc->mode = saved_mode;
	} else {
		intel_modeset_check_state(dev);
	}
d9745 5
d9818 20
d9845 3
a9847 1
	if (set->crtc->fb != set->fb) {
d9850 10
a9859 2
			DRM_DEBUG_KMS("crtc has no fb, full mode set\n");
			config->mode_changed = true;
d9862 2
a9863 1
		} else if (set->fb->depth != set->crtc->fb->depth) {
d9865 1
a9865 4
		} else if (set->fb->bits_per_pixel !=
			   set->crtc->fb->bits_per_pixel) {
			config->mode_changed = true;
		} else
d9867 1
d9879 3
d9892 1
a9892 1
	int count, ro;
d9894 1
a9894 1
	/* The upper layers ensure that we either disabl a crtc or have a list
a9898 1
	count = 0;
a9931 1
	count = 0;
d9945 2
a9946 2
		if (!intel_encoder_crtc_ok(&connector->new_encoder->base,
					   new_crtc)) {
d9960 1
d9966 1
a9966 2

				goto next_encoder;
d9969 6
a9974 2
		encoder->new_crtc = NULL;
next_encoder:
d9998 3
a10000 8
	if (!set->mode)
		set->fb = NULL;

	/* The fb helper likes to play gross jokes with ->mode_set_config.
	 * Unfortunately the crtc helper doesn't do much at all for this case,
	 * so we have to cope with this madness until the fb helper is fixed up. */
	if (set->fb && set->num_connectors == 0)
		return 0;
d10038 4
a10041 5
		if (set->mode) {
			DRM_DEBUG_KMS("attempting to set mode from"
					" userspace\n");
			drm_mode_debug_printmodeline(set->mode);
		}
a10042 8
		if (!intel_set_mode(set->crtc, set->mode,
				    set->x, set->y, set->fb)) {
			DRM_ERROR("failed to set mode on [CRTC:%d]\n",
				  set->crtc->base.id);
			ret = -EINVAL;
			goto fail;
		}
	} else if (config->fb_changed) {
d10045 10
d10057 3
a10059 4
	intel_set_config_free(config);

	return 0;

d10061 1
a10061 1
	intel_set_config_restore_state(dev, config);
d10063 6
a10068 5
	/* Try to restore the config */
	if (config->mode_changed &&
	    !intel_set_mode(save_set.crtc, save_set.mode,
			    save_set.x, save_set.y, save_set.fb))
		DRM_ERROR("failed to restore config after modeset failure\n");
d10090 66
a10155 1
static void intel_pch_pll_init(struct drm_device *dev)
d10157 1
a10157 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d10160 10
a10169 3
	if (dev_priv->num_pch_pll == 0) {
		DRM_DEBUG_KMS("No PCH PLLs on this hardware, skipping initialisation\n");
		return;
d10171 5
d10177 6
a10182 5
	for (i = 0; i < dev_priv->num_pch_pll; i++) {
		dev_priv->pch_plls[i].pll_reg = _PCH_DPLL(i);
		dev_priv->pch_plls[i].fp0_reg = _PCH_FP0(i);
		dev_priv->pch_plls[i].fp1_reg = _PCH_FP1(i);
	}
d10191 1
a10191 1
	intel_crtc = kzalloc(sizeof(struct intel_crtc) + (INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)), GFP_KERNEL);
d10204 4
a10207 1
	/* Swap pipes & planes for FBC on pre-965 */
d10210 1
a10210 2
	intel_crtc->cpu_transcoder = pipe;
	if (IS_MOBILE(dev) && IS_GEN3(dev)) {
d10220 11
a10230 1
	intel_crtc->bpp = 24; /* default for pre-Ironlake */
d10232 1
a10232 1
	drm_crtc_helper_add(&intel_crtc->base, &intel_helper_funcs);
d10250 1
a10250 1
		return -EINVAL;
d10299 22
a10325 1
	bool has_lvds;
d10327 1
a10327 5
	has_lvds = intel_lvds_init(dev);
	if (!has_lvds && !HAS_PCH_SPLIT(dev)) {
		/* disable the panel fitter on everything but LVDS */
		I915_WRITE(PFIT_CONTROL, 0);
	}
d10353 1
a10353 1
		dpd_is_edp = intel_dpd_is_edp(dev);
d10358 1
a10358 1
		if (I915_READ(HDMIB) & PORT_DETECTED) {
d10362 1
a10362 1
				intel_hdmi_init(dev, HDMIB, PORT_B);
d10367 2
a10368 2
		if (I915_READ(HDMIC) & PORT_DETECTED)
			intel_hdmi_init(dev, HDMIC, PORT_C);
d10370 2
a10371 2
		if (!dpd_is_edp && I915_READ(HDMID) & PORT_DETECTED)
			intel_hdmi_init(dev, HDMID, PORT_D);
d10379 6
a10384 1
		int found;
d10386 5
a10390 11
		/* Check for built-in panel first. Shares lanes with HDMI on SDVOC */
		if (I915_READ(DP_C) & DP_DETECTED)
			intel_dp_init(dev, DP_C, PORT_C);

		if (I915_READ(SDVOB) & PORT_DETECTED) {
			/* SDVOB multiplex with HDMIB */
			found = intel_sdvo_init(dev, SDVOB, true);
			if (!found)
				intel_hdmi_init(dev, SDVOB, PORT_B);
			if (!found && (I915_READ(DP_B) & DP_DETECTED))
				intel_dp_init(dev, DP_B, PORT_B);
d10393 3
a10395 3
		if (I915_READ(SDVOC) & PORT_DETECTED)
			intel_hdmi_init(dev, SDVOC, PORT_C);

d10399 1
a10399 1
		if (I915_READ(SDVOB) & SDVO_DETECTED) {
d10401 1
a10401 1
			found = intel_sdvo_init(dev, SDVOB, true);
d10404 1
a10404 1
				intel_hdmi_init(dev, SDVOB, PORT_B);
d10407 1
a10407 2
			if (!found && SUPPORTS_INTEGRATED_DP(dev)) {
				DRM_DEBUG_KMS("probing DP_B\n");
a10408 1
			}
d10413 1
a10413 1
		if (I915_READ(SDVOB) & SDVO_DETECTED) {
d10415 1
a10415 1
			found = intel_sdvo_init(dev, SDVOC, false);
d10418 1
a10418 1
		if (!found && (I915_READ(SDVOC) & SDVO_DETECTED)) {
d10422 1
a10422 1
				intel_hdmi_init(dev, SDVOC, PORT_C);
d10424 1
a10424 2
			if (SUPPORTS_INTEGRATED_DP(dev)) {
				DRM_DEBUG_KMS("probing DP_C\n");
a10425 1
			}
d10429 1
a10429 2
		    (I915_READ(DP_D) & DP_DETECTED)) {
			DRM_DEBUG_KMS("probing DP_D\n");
a10430 1
		}
d10448 7
d10459 1
a10459 3
	drm_framebuffer_cleanup(fb);
	drm_gem_object_unreference_unlocked(&intel_fb->obj->base);

d10483 2
d10487 2
d10500 20
a10519 4
	/* FIXME <= Gen4 stride limits are bit unclear */
	if (mode_cmd->pitches[0] > 32768) {
		DRM_DEBUG("pitch (%d) must be at less than 32768\n",
			  mode_cmd->pitches[0]);
d10540 2
a10541 1
			DRM_DEBUG("invalid format: 0x%08x\n", mode_cmd->pixel_format);
d10552 2
a10553 1
			DRM_DEBUG("invalid format: 0x%08x\n", mode_cmd->pixel_format);
d10562 2
a10563 1
			DRM_DEBUG("invalid format: 0x%08x\n", mode_cmd->pixel_format);
d10568 2
a10569 1
		DRM_DEBUG("unsupported pixel format 0x%08x\n", mode_cmd->pixel_format);
d10577 11
a10593 2
	drm_helper_mode_fill_fb_struct(&intel_fb->base, mode_cmd);
	intel_fb->obj = obj;
d10612 6
d10620 1
a10620 1
	.output_poll_changed = intel_fb_output_poll_changed,
d10628 9
a10636 1
	/* We always want a DPMS function */
d10638 1
d10645 1
d10651 7
d10659 1
d10677 1
a10677 1
	else if (IS_I945GM(dev) || IS_845G(dev) || IS_PINEVIEW_M(dev))
d10680 3
d10709 1
a10709 1
		} else if (IS_HASWELL(dev)) {
d10712 3
a10714 2
		} else
			dev_priv->display.update_wm = NULL;
d10717 4
d10744 1
d10748 2
d10804 1
a10810 1
#ifdef notyet
d10816 16
d10844 3
a10855 3
	/* Acer Aspire 4736Z */
	{ 0x2a42, 0x1025, 0x0260, quirk_invert_brightness },

d10892 6
d10905 1
a10905 6
	u32 vga_reg;

	if (HAS_PCH_SPLIT(dev))
		vga_reg = CPU_VGACNTRL;
	else
		vga_reg = VGACNTRL;
d10907 1
a10907 1
#if 0
d10909 3
a10912 1
	outb(VGA_SR_INDEX, SR01);
d10914 4
a10918 2
#if 0
	vga_put(dev->pdev, VGA_RSRC_LEGACY_IO);
a10927 5
	/* We attempt to init the necessary power wells early in the initialization
	 * time, so the subsystems that expect power to be enabled can work.
	 */
	intel_init_power_wells(dev);

d10932 2
d10939 5
d10947 1
a10947 1
	int i, ret;
d10963 3
d10978 1
a10978 1
	dev->mode_config.fb_base = dev_priv->mm.gtt_base_addr;
d10984 1
a10984 1
	for (i = 0; i < INTEL_INFO(dev)->num_pipes; i++) {
d10986 6
a10991 3
		ret = intel_plane_init(dev, i);
		if (ret)
			DRM_DEBUG_KMS("plane %d init failed: %d\n", i, ret);
d10994 3
d10998 1
a10998 1
	intel_pch_pll_init(dev);
d11003 3
d11062 1
a11062 1
	reg = PIPECONF(crtc->cpu_transcoder);
d11190 1
a11190 1
static void i915_redisable_vga(struct drm_device *dev)
d11193 1
a11193 1
	u32 vga_reg;
d11195 10
a11204 4
	if (HAS_PCH_SPLIT(dev))
		vga_reg = CPU_VGACNTRL;
	else
		vga_reg = VGACNTRL;
d11206 1
a11206 1
	if (I915_READ(vga_reg) != VGA_DISP_DISABLE) {
d11208 1
a11208 2
		I915_WRITE(vga_reg, VGA_DISP_DISABLE);
		POSTING_READ(vga_reg);
d11212 1
a11212 4
/* Scan out the current hw modeset state, sanitizes it and maps it into the drm
 * and i915 state tracking structures. */
void intel_modeset_setup_hw_state(struct drm_device *dev,
				  bool force_restore)
a11215 1
	u32 tmp;
d11219 1
d11221 3
a11223 24
	if (HAS_DDI(dev)) {
		tmp = I915_READ(TRANS_DDI_FUNC_CTL(TRANSCODER_EDP));

		if (tmp & TRANS_DDI_FUNC_ENABLE) {
			switch (tmp & TRANS_DDI_EDP_INPUT_MASK) {
			case TRANS_DDI_EDP_INPUT_A_ON:
			case TRANS_DDI_EDP_INPUT_A_ONOFF:
				pipe = PIPE_A;
				break;
			case TRANS_DDI_EDP_INPUT_B_ONOFF:
				pipe = PIPE_B;
				break;
			case TRANS_DDI_EDP_INPUT_C_ONOFF:
				pipe = PIPE_C;
				break;
			}

			crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
			crtc->cpu_transcoder = TRANSCODER_EDP;

			DRM_DEBUG_KMS("Pipe %c using transcoder EDP\n",
				      pipe_name(pipe));
		}
	}
d11225 1
a11225 2
	for_each_pipe(pipe) {
		crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
d11227 2
a11228 5
		tmp = I915_READ(PIPECONF(crtc->cpu_transcoder));
		if (tmp & PIPECONF_ENABLE)
			crtc->active = true;
		else
			crtc->active = false;
d11231 1
d11238 1
d11242 16
d11263 3
a11265 2
			encoder->base.crtc =
				dev_priv->pipe_to_crtc_mapping[pipe];
d11271 1
a11271 1
		DRM_DEBUG_KMS("[ENCODER:%d:%s] hw state readout: %s, pipe=%i\n",
d11275 1
a11275 1
			      pipe);
d11293 30
d11333 13
d11348 3
d11352 6
d11359 5
a11363 3
			crtc = to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
			intel_set_mode(&crtc->base, &crtc->base.mode,
				       crtc->base.x, crtc->base.y, crtc->base.fb);
a11364 2

		i915_redisable_vga(dev);
d11378 1
d11381 9
d11396 1
a11396 1
	struct intel_crtc *intel_crtc;
d11398 11
d11410 1
a11416 1

a11421 1
		intel_crtc = to_intel_crtc(crtc);
a11430 3
	if (IS_VALLEYVIEW(dev))
		vlv_init_dpio(dev);

a11432 6
	/* Disable the irq before mode object teardown, for the irq might
	 * enqueue unpin/hotplug work. */
	drm_irq_uninstall(dev);
	cancel_work_sync(&dev_priv->hotplug_work);
	cancel_work_sync(&dev_priv->rps.work);

a11433 1
#ifdef notyet
a11434 1
#endif
d11436 7
a11442 2
	/* destroy backlight, if any, before the connectors */
	intel_panel_destroy_backlight(dev);
d11445 2
a11469 3
	printf("%s stub\n", __func__);
	return EINVAL;
#ifdef notyet
a11480 1
#endif
d11483 1
a11483 2
#ifdef CONFIG_DEBUG_FS
#include <linux/seq_file.h>
d11485 1
a11485 1
struct intel_display_error_state {
d11497 1
d11512 1
d11542 1
a11542 1
	error = kmalloc(sizeof(*error), GFP_ATOMIC);
d11546 3
d11550 14
a11563 3
		error->cursor[i].control = I915_READ(CURCNTR(i));
		error->cursor[i].position = I915_READ(CURPOS(i));
		error->cursor[i].base = I915_READ(CURBASE(i));
d11567 6
a11572 3
		error->plane[i].size = I915_READ(DSPSIZE(i));
		error->plane[i].pos = I915_READ(DSPPOS(i));
		error->plane[i].addr = I915_READ(DSPADDR(i));
d11588 6
d11608 2
d11611 1
a11611 1
intel_display_print_error_state(struct seq_file *m,
d11620 4
a11623 1
	seq_printf(m, "Num Pipes: %d\n", INTEL_INFO(dev)->num_pipes);
d11625 14
a11638 9
		seq_printf(m, "Pipe [%d]:\n", i);
		seq_printf(m, "  SRC: %08x\n", error->pipe[i].source);

		seq_printf(m, "Plane [%d]:\n", i);
		seq_printf(m, "  CNTR: %08x\n", error->plane[i].control);
		seq_printf(m, "  STRIDE: %08x\n", error->plane[i].stride);
		seq_printf(m, "  SIZE: %08x\n", error->plane[i].size);
		seq_printf(m, "  POS: %08x\n", error->plane[i].pos);
		seq_printf(m, "  ADDR: %08x\n", error->plane[i].addr);
d11640 2
a11641 2
			seq_printf(m, "  SURF: %08x\n", error->plane[i].surface);
			seq_printf(m, "  TILEOFF: %08x\n", error->plane[i].tile_offset);
d11644 4
a11647 4
		seq_printf(m, "Cursor [%d]:\n", i);
		seq_printf(m, "  CNTR: %08x\n", error->cursor[i].control);
		seq_printf(m, "  POS: %08x\n", error->cursor[i].position);
		seq_printf(m, "  BASE: %08x\n", error->cursor[i].base);
d11651 1
a11651 1
		seq_printf(m, "  CPU transcoder: %c\n",
d11653 9
a11661 7
		seq_printf(m, "  CONF: %08x\n", error->transcoder[i].conf);
		seq_printf(m, "  HTOTAL: %08x\n", error->transcoder[i].htotal);
		seq_printf(m, "  HBLANK: %08x\n", error->transcoder[i].hblank);
		seq_printf(m, "  HSYNC: %08x\n", error->transcoder[i].hsync);
		seq_printf(m, "  VTOTAL: %08x\n", error->transcoder[i].vtotal);
		seq_printf(m, "  VBLANK: %08x\n", error->transcoder[i].vblank);
		seq_printf(m, "  VSYNC: %08x\n", error->transcoder[i].vsync);
a11663 1
#endif
@


1.53
log
@Read the lower 16-bits of the GCFGC "double word".  Potentially fixes issues
with some modes on machines with the 915GM chipset.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.52 2015/06/24 17:59:42 kettenis Exp $	*/
d2249 3
a2251 4
	while(!atomic_read(&dev_priv->mm.wedged) &&
	    atomic_read(&obj->pending_flip) != 0) {
		tsleep(&dev_priv->pending_flip_queue, 0, "915flp", 0);
	}
d2959 2
a2960 2
	while (intel_crtc_has_pending_flip(crtc))
		tsleep(&dev_priv->pending_flip_queue, 0, "915wfl", 0);
@


1.52
log
@Linux jiffies and OpenBSD ticks are the same thing.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.51 2015/06/24 08:32:39 kettenis Exp $	*/
d3984 1
a3984 1
	gcfgc = pci_conf_read(dev_priv->pc, dev_priv->tag, GCFGC) >> 16;
@


1.51
log
@Introduce Linux work queue APIs and use them.  As a side-effect, this will
move some of the work from the system task queue to the driver-specific
task queue.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.50 2015/04/18 14:47:34 jsg Exp $	*/
d1025 1
a1025 1
		unsigned long timeout = ticks + msecs_to_jiffies(100);
d1037 2
a1038 2
			 time_after(timeout, ticks));
		if (time_after(ticks, timeout))
@


1.50
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.49 2015/04/12 17:10:07 kettenis Exp $	*/
d7057 1
a7057 1
		task_del(systq, &work->task);
d7066 1
a7066 1
static void intel_unpin_work_fn(void *arg1)
d7068 2
a7069 1
	struct intel_unpin_work *work = arg1;
d7128 1
a7128 1
	task_add(systq, &work->task);
d7463 1
a7463 1
	task_set(&work->task, intel_unpin_work_fn, work);
d9411 2
a9412 2
	task_del(systq, &dev_priv->hotplug_task);
	task_del(systq, &dev_priv->rps.task);
@


1.49
log
@Add a few missing trace functions, and "use" them.  Add back the WATCH_GTT
code (that isn't actually compiled in).  Use dev_priv->dev in one more place
now that we have it, and add set_normalized_timespec() and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.48 2015/04/12 11:26:54 jsg Exp $	*/
a1975 1
#ifdef notyet
a1976 4
#else
		DRM_ERROR("invalid tiling mode %d", obj->tiling_mode);
		return -EINVAL;
#endif
d7123 2
a7124 1
	atomic_clear_int(&obj->pending_flip, 1 << intel_crtc->plane);
@


1.48
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.47 2015/04/08 04:24:40 jsg Exp $	*/
d33 1
d7133 1
a7133 1
//	trace_i915_flip_complete(intel_crtc->plane, work->pending_flip_obj);
d7518 1
a7518 1
//	trace_i915_flip_request(intel_crtc->plane, obj);
@


1.47
log
@change back to udelay/mdelay
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.46 2015/04/08 03:21:13 jsg Exp $	*/
a412 1
	int retries;
d415 1
a415 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0)
			break;
		DELAY(100);
	}
	if (retries == 0) {
d423 1
a423 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0)
			break;
		DELAY(100);
	}
	if (retries == 0) {
a437 1
	int retries;
d440 1
a440 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0)
			break;
		DELAY(100);
	}
	if (retries == 0) {
d449 1
a449 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(DPIO_PKT) & DPIO_BUSY) == 0)
			break;
		DELAY(100);
	}
	if (retries == 0)
a942 1
	int retries;
d946 1
a946 6
	for (retries = 50; retries > 0; retries--) {
		if (I915_READ_NOTRACE(frame_reg) != frame)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a961 1
	int retries;
d985 3
a987 6
	for (retries = 50; retries > 0; retries--) {
		if (I915_READ(pipestat_reg) & PIPE_VBLANK_INTERRUPT_STATUS)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a1012 1
	int retries;
d1018 2
a1019 6
		for (retries = 100; retries > 0; retries--) {
			if ((I915_READ(reg) & I965_PIPECONF_ACTIVE) == 0)
				break;
			DELAY(1000);
		}
		if (retries == 0)
d1024 1
d1032 1
a1032 1
		for (retries = 100; retries > 0; retries--) {
d1035 3
a1037 4
			if ((I915_READ(reg) & line_mask) == last_line)
				break;
		}
		if (retries == 0)
a1505 1
	int retries;
d1508 1
a1508 6
	for (retries = 100; retries > 0; retries--) {
		if ((I915_READ(SBI_CTL_STAT) & SBI_BUSY) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
d1522 2
a1523 6
	for (retries = 100; retries > 0; retries--) {
		if ((I915_READ(SBI_CTL_STAT) & (SBI_BUSY | SBI_RESPONSE_FAIL)) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
a1537 1
	int retries;
d1540 1
a1540 6
	for (retries = 100; retries > 0; retries--) {
		if ((I915_READ(SBI_CTL_STAT) & SBI_BUSY) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
d1553 2
a1554 6
	for (retries = 100; retries > 0; retries--) {
		if ((I915_READ(SBI_CTL_STAT) & (SBI_BUSY | SBI_RESPONSE_FAIL)) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
a1663 1
	int retries;
d1710 1
a1710 6
	for (retries = 100; retries > 0; retries--) {
		if (I915_READ(reg) & TRANS_STATE_ENABLE)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a1717 1
	int retries;
d1741 1
a1741 6
	for (retries = 100; retries > 0; retries--) {
		if (I915_READ(_TRANSACONF) & TRANS_STATE_ENABLE)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a1749 1
	int retries;
d1763 1
a1763 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(reg) & TRANS_STATE_ENABLE) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a1777 1
	int retries;
d1783 1
a1783 6
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(_TRANSACONF) & TRANS_STATE_ENABLE) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a3310 1
	int retries;
d3314 3
a3316 7
	for (retries = 10; retries > 0; retries--) {
		if (I915_READ(dslreg) != temp)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
		DRM_ERROR("mode set failed: pipe %d stuck\n", pipe);
a4375 1
	int retries;
d4419 1
a4419 6
	for (retries = 1; retries > 0; retries--) {
		if ((I915_READ(DPLL(pipe)) & DPLL_LOCK_VLV) == DPLL_LOCK_VLV)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a4993 1
	int retries;
d5026 2
a5027 6
		for (retries = 100; retries > 0; retries--) {
			if (I915_READ(SOUTH_CHICKEN2) & FDI_MPHY_IOSFSB_RESET_STATUS)
				break;
			DELAY(100);
		}
		if (retries == 0)
d5034 3
a5036 6
		for (retries = 100; retries > 0; retries--) {
			if ((I915_READ(SOUTH_CHICKEN2) & FDI_MPHY_IOSFSB_RESET_STATUS) == 0)
				break;
			DELAY(100);
		}
		if (retries == 0)
@


1.46
log
@change back to using min_t
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.45 2015/04/06 10:03:34 jsg Exp $	*/
d1070 1
a1070 1
			DELAY(5000);
@


1.45
log
@Now we have dev_priv->mm.gtt_base_addr we can set fb_base and remove
an ifdef.  The code that uses fb_base itself remains #if 0'd out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.44 2015/04/06 05:35:29 jsg Exp $	*/
d6171 1
a6171 2
	if (eld[2] < (uint8_t)len)
		len = eld[2];
d6255 1
a6255 1
	len = eld[2] < 21 ? eld[2] : 21;	/* 84 bytes of hw ELD buffer */
d6331 1
a6331 1
	len = eld[2] < 21 ? eld[2] : 21;	/* 84 bytes of hw ELD buffer */
@


1.44
log
@add and use macros for wake_up/wake_up_all/wake_up_all_locked
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.43 2015/02/12 08:48:32 jsg Exp $	*/
d9101 1
a9129 1
#ifdef notyet
a9130 3
#else
	DRM_DEBUG_KMS("todo set fb base\n");
#endif
@


1.43
log
@Add and use macros for linux memory barriers.  Fix the call in
i915_gem_object_flush_fence() to be mb() not wmb() while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.42 2015/02/12 04:56:03 kettenis Exp $	*/
d7229 1
a7229 1
	wakeup(&dev_priv->pending_flip_queue);
@


1.42
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.41 2015/02/11 07:01:37 jsg Exp $	*/
d7207 1
a7207 1
	DRM_READMEMORYBARRIER();
d7215 1
a7215 1
	DRM_READMEMORYBARRIER();
d7272 1
a7272 1
	DRM_WRITEMEMORYBARRIER();
d7275 1
a7275 1
	DRM_WRITEMEMORYBARRIER();
@


1.41
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.40 2015/02/10 10:50:49 jsg Exp $	*/
a1107 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1111 1
a1111 1
	if (HAS_PCH_LPT(dev)) {
d1127 1
a1127 1
	if (crtc && HAS_PCH_CPT(dev)) {
a1150 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1157 1
a1157 1
	if (HAS_DDI(dev)) {
a1193 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1202 1
a1202 1
	if (HAS_DDI(dev))
a1223 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1229 1
a1229 1
	if (HAS_PCH_SPLIT(dev)) {
a1291 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1297 1
a1297 1
	if (HAS_PCH_SPLIT(dev)) {
a1319 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1323 1
a1323 1
	if (HAS_PCH_LPT(dev)) {
a1351 2
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;

d1355 1
a1355 1
	if (HAS_PCH_CPT(dev)) {
a1369 2
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;

d1373 1
a1373 1
	if (HAS_PCH_CPT(dev)) {
a1385 2
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;

d1389 1
a1389 1
	if (HAS_PCH_CPT(dev)) {
a1401 2
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;

d1404 1
a1404 1
	if (HAS_PCH_CPT(dev)) {
a1416 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1422 1
a1422 1
	WARN(HAS_PCH_IBX(dev) && (val & DP_PORT_EN) == 0
a1429 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1435 1
a1435 1
	WARN(HAS_PCH_IBX(dev) && (val & PORT_ENABLE) == 0
a1481 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1486 1
a1486 1
	BUG_ON(!IS_VALLEYVIEW(dev) && dev_priv->info->gen >= 5);
d1489 1
a1489 1
	if (IS_MOBILE(dev) && !IS_I830(dev))
d1718 1
a1718 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1748 1
a1748 1
	if (HAS_PCH_IBX(dev)) {
d1759 1
a1759 1
		if (HAS_PCH_IBX(dev) &&
d1817 1
a1817 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
a1889 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1896 1
a1896 1
	if (IS_HASWELL(dev))
d1906 1
a1906 1
	if (!HAS_PCH_SPLIT(dev))
d1923 1
a1923 1
	intel_wait_for_vblank(dev, pipe);
a1940 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d1962 1
a1962 1
	intel_wait_for_pipe_off(dev, pipe);
a1988 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d2002 1
a2002 1
	intel_wait_for_vblank(dev, pipe);
a2015 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d2026 1
a2026 1
	intel_wait_for_vblank(dev, pipe);
a3318 1
	struct drm_device *dev = intel_crtc->base.dev;
d3329 1
a3329 1
	if (HAS_PCH_IBX(dev)) {
@


1.40
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.39 2015/02/10 01:39:32 jsg Exp $	*/
d491 1
a491 1
	printf("Forcing lvds to dual link mode on %s\n", id->ident);
d9013 1
a9013 1
	printf("Backlight polarity reversed on %s\n", id->ident);
@


1.39
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.38 2015/01/27 03:17:36 dlg Exp $	*/
d411 1
d415 1
a415 1
	mtx_enter(&dev_priv->dpio_lock);
d441 1
a441 1
	mtx_leave(&dev_priv->dpio_lock);
d448 1
d451 1
a451 1
	mtx_enter(&dev_priv->dpio_lock);
d475 1
a475 1
       mtx_leave(&dev_priv->dpio_lock);
d1558 1
d1562 1
a1562 1
	mtx_enter(&dev_priv->dpio_lock);
d1593 1
a1593 1
	mtx_leave(&dev_priv->dpio_lock);
d1600 1
d1604 1
a1604 1
	mtx_enter(&dev_priv->dpio_lock);
d1636 1
a1636 1
	mtx_leave(&dev_priv->dpio_lock);
d3045 1
d3051 1
a3051 1
	mtx_enter(&dev->event_lock);
d3053 1
a3053 1
	mtx_leave(&dev->event_lock);
d7176 1
d7178 1
a7178 1
	mtx_enter(&dev->event_lock);
d7181 1
a7181 1
	mtx_leave(&dev->event_lock);
d7219 1
d7225 1
a7225 1
	mtx_enter(&dev->event_lock);
d7232 1
a7232 1
		mtx_leave(&dev->event_lock);
d7246 1
a7246 1
	mtx_leave(&dev->event_lock);
d7279 1
d7285 1
a7285 1
	mtx_enter(&dev->event_lock);
d7288 1
a7288 1
	mtx_leave(&dev->event_lock);
d7565 1
d7595 1
a7595 1
	mtx_enter(&dev->event_lock);
d7597 1
a7597 1
		mtx_leave(&dev->event_lock);
d7605 1
a7605 1
	mtx_leave(&dev->event_lock);
d7653 1
a7653 1
	mtx_enter(&dev->event_lock);
d7655 1
a7655 1
	mtx_leave(&dev->event_lock);
@


1.38
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.37 2014/10/08 05:25:41 jsg Exp $	*/
d2423 1
a2423 1
	DRM_LOCK();
d2428 1
a2428 1
		DRM_UNLOCK();
d2439 1
a2439 1
		DRM_UNLOCK();
d2455 1
a2455 1
	DRM_UNLOCK();
d3064 1
a3064 1
	DRM_LOCK();
d3066 1
a3066 1
	DRM_UNLOCK();
d3493 1
a3493 1
	DRM_LOCK();
d3495 1
a3495 1
	DRM_UNLOCK();
d3573 1
a3573 1
	DRM_LOCK();
d3575 1
a3575 1
	DRM_UNLOCK();
d3668 1
a3668 1
	DRM_LOCK();
d3670 1
a3670 1
	DRM_UNLOCK();
d3723 1
a3723 1
	DRM_LOCK();
d3725 1
a3725 1
	DRM_UNLOCK();
d3751 1
a3751 1
		DRM_LOCK();
d3755 1
a3755 1
		DRM_UNLOCK();
d3915 1
a3915 1
		DRM_LOCK();
d3917 1
a3917 1
		DRM_UNLOCK();
d6569 1
a6569 1
		DRM_LOCK();
d6590 1
a6590 1
	DRM_LOCK();
d6636 1
a6636 1
	DRM_UNLOCK();
d6650 1
a6650 1
	DRM_UNLOCK();
d7192 1
a7192 1
	DRM_LOCK();
d7198 1
a7198 1
	DRM_UNLOCK();
d7629 1
a7629 1
	DRM_UNLOCK();
d7641 1
a7641 1
	DRM_UNLOCK();
d9107 1
a9107 1
	DRM_LOCK();
d9109 1
a9109 1
	DRM_UNLOCK();
d9500 1
a9500 1
	DRM_LOCK();
d9525 1
a9525 1
	DRM_UNLOCK();
@


1.37
log
@Remove the i830/i845 pipe A force quirks, matching changes
in recent versions of the linux drm code.

drm/i915: Nuke pipe A quirk on i830M
From Daniel Vetter
0e8abc81bf4b54a01bb026ba4d883de7c415cc03 in mainline linux

drm/i915: Undo the PIPEA quirk for i845
From Chris Wilson
a4945f9522d27e1e6d64a02ad055e83768cb0896 in mainline linux

With this change a hardware lockup with i845g reported by "THEvoid"
via bugs@@ is avoided.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.36 2014/06/21 05:38:28 jsg Exp $	*/
d7187 1
a7187 1
static void intel_unpin_work_fn(void *arg1, void *arg2)
d7579 1
a7579 1
	task_set(&work->task, intel_unpin_work_fn, work, NULL);
@


1.36
log
@drm/i915: Break encoder->crtc link separately in intel_sanitize_crtc()

From Egbert Eich
9e68a1156da093385f057b9e4576652203f1248e in ubuntu 3.8
7f1950fbb989e8fc5463b307e062b4529d51c862 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.35 2014/05/03 05:11:30 jsg Exp $	*/
a9017 4

	/* 830/845 need to leave pipe A & dpll A up */
	{ 0x2562, PCI_ANY_ID, PCI_ANY_ID, quirk_pipea_force },
	{ 0x3577, PCI_ANY_ID, PCI_ANY_ID, quirk_pipea_force },
@


1.35
log
@drm/i915: quirk invert brightness for Acer Aspire 5336

From Jani Nikula
083bda2f1130f185eccdf7c5cbbdb53fa88429b1 in ubuntu 3.8
0f540c3a7cfb91c9d7a19eb0c95c24c5de1197d5 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.34 2014/04/07 06:43:11 jsg Exp $	*/
a9170 9
static void
intel_connector_break_all_links(struct intel_connector *connector)
{
	connector->base.dpms = DRM_MODE_DPMS_OFF;
	connector->base.encoder = NULL;
	connector->encoder->connectors_active = false;
	connector->encoder->base.crtc = NULL;
}

d9252 2
a9253 1
			intel_connector_break_all_links(connector);
d9255 8
d9333 2
d9345 2
a9346 2

			intel_connector_break_all_links(connector);
@


1.34
log
@reduce the diff to linux for drm pci vid/pid tests
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.33 2014/03/30 01:03:05 jsg Exp $	*/
d9046 3
@


1.33
log
@drm/i915: Prevent MI_DISPLAY_FLIP straddling two cachelines on IVB

From Ville Syrjala
0828f7607cee51cabf00b984dad3a8ef200beb41 in ubuntu 3.8
f66fab8e1cd6b3127ba4c5c0d11539fbe1de1e36 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.32 2014/03/16 03:34:32 jsg Exp $	*/
d9055 1
d9061 2
a9062 2
		if (dev->pci_device == q->device &&
		    (dev->pci_subvendor == q->subsystem_vendor ||
d9064 1
a9064 1
		    (dev->pci_subdevice == q->subsystem_device ||
@


1.32
log
@drm/i915: Do not clobber config status after a forced restore of hw state

From Chris Wilson
790dddadff219165a4666def708c16e8db2c5a7d in ubuntu 3.8
edd5b13313551d6b04acfb90d3db58ed3cf3c814 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.31 2014/02/15 09:56:08 jsg Exp $	*/
d7505 14
@


1.31
log
@drm/i915: Don't deref pipe->cpu_transcoder in the hangcheck code

From Chris Wilson
d280fd3cae523191525251159e3cf9e773fdcedb in ubuntu 3.8
63b66e5ba54b15a6592be00555d762db6db739ce in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.30 2014/02/15 09:47:15 jsg Exp $	*/
a9464 2

	drm_mode_config_reset(dev);
d9473 1
@


1.30
log
@drm/i915: Use the correct GMCH_CTRL register for Sandybridge+

From Chris Wilson
2259bb7720c52941c1d62e078bf019aa88d6f525 in ubuntu 3.8
a885b3ccc74d8e38074e1c43a47c354c5ea0b01e in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.29 2014/02/05 10:58:48 kettenis Exp $	*/
d9571 3
a9581 1
		u32 conf;
a9582 7

		u32 htotal;
		u32 hblank;
		u32 hsync;
		u32 vtotal;
		u32 vblank;
		u32 vsync;
d9594 13
d9614 6
a9619 1
	enum transcoder cpu_transcoder;
d9622 3
a9629 2
		cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv, i);

a9643 1
		error->pipe[i].conf = I915_READ(PIPECONF(cpu_transcoder));
d9645 18
a9662 6
		error->pipe[i].htotal = I915_READ(HTOTAL(cpu_transcoder));
		error->pipe[i].hblank = I915_READ(HBLANK(cpu_transcoder));
		error->pipe[i].hsync = I915_READ(HSYNC(cpu_transcoder));
		error->pipe[i].vtotal = I915_READ(VTOTAL(cpu_transcoder));
		error->pipe[i].vblank = I915_READ(VBLANK(cpu_transcoder));
		error->pipe[i].vsync = I915_READ(VSYNC(cpu_transcoder));
d9675 3
a9680 1
		seq_printf(m, "  CONF: %08x\n", error->pipe[i].conf);
a9681 6
		seq_printf(m, "  HTOTAL: %08x\n", error->pipe[i].htotal);
		seq_printf(m, "  HBLANK: %08x\n", error->pipe[i].hblank);
		seq_printf(m, "  HSYNC: %08x\n", error->pipe[i].hsync);
		seq_printf(m, "  VTOTAL: %08x\n", error->pipe[i].vtotal);
		seq_printf(m, "  VBLANK: %08x\n", error->pipe[i].vblank);
		seq_printf(m, "  VSYNC: %08x\n", error->pipe[i].vsync);
d9698 12
@


1.29
log
@We have WARN_ONCE now.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.28 2014/02/02 13:55:31 jsg Exp $	*/
d9554 1
d9557 1
a9557 1
	pci_read_config_word(dev_priv->bridge_dev, INTEL_GMCH_CTRL, &gmch_ctrl);
d9562 1
a9562 1
	pci_write_config_word(dev_priv->bridge_dev, INTEL_GMCH_CTRL, gmch_ctrl);
@


1.28
log
@drm/i915: flush cursors harder

From Daniel Vetter
ca5667eaca18b0267511728c97e3759d01a348cc in ubuntu 3.8
b2ea8ef559b4d94190009f3651b5b3ab7c05afd3 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.27 2014/02/02 04:02:04 jsg Exp $	*/
a7500 1
#ifdef notyet
a7501 1
#endif
@


1.27
log
@drm/i915: Make data/link N value power of two

From Ville Syrjala
16f091c6e04b5ac247d7b3b3764c2fbe8683e497 in ubuntu 3.8
a65851af59387146a28a928c3e7bb17dabc5db72 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.26 2014/01/24 06:11:02 jsg Exp $	*/
d6461 1
d6463 1
d6488 1
d6490 1
@


1.26
log
@drm/i915: Only apply DPMS to the encoder if enabled

From Chris Wilson
aee8722c71db885fd3a617a9866f63b7165d93e0 in ubuntu 3.8
c9976dcf55c8aaa7037427b239f15e5acfc01a3a in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.25 2014/01/24 04:05:06 jsg Exp $	*/
d4147 2
a4148 1
	while (*num > 0xffffff || *den > 0xffffff) {
d4154 8
d4168 6
a4173 8
	/* BUG_ON(pixel_clock > INT_MAX / 36); */
	m_n->gmch_m = bits_per_pixel * pixel_clock;
	m_n->gmch_n = link_clock * nlanes * 8;
	fdi_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);

	m_n->link_m = pixel_clock;
	m_n->link_n = link_clock;
	fdi_reduce_ratio(&m_n->link_m, &m_n->link_n);
@


1.25
log
@drm/i915: Move num_pipes to intel info

From Ben Widawsky
7ed1faada973243b6e11fa209ada91c9cc1dab53 in ubuntu 3.8
7eb552aeae058a88eece91b902dd51fde45b1f41 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.24 2014/01/24 03:21:17 jsg Exp $	*/
a4010 2
	struct intel_encoder *encoder = intel_attached_encoder(connector);

d4021 2
a4022 4
	if (encoder->base.crtc)
		intel_encoder_dpms(encoder, mode);
	else
		WARN_ON(encoder->connectors_active != false);
@


1.24
log
@drm/i915: quirk no PCH_PWM_ENABLE for Dell XPS13 backlight

From Kamal Mostafa
9f5b330036e6f771438b22770f6c49e2c2eaf0e1 in ubuntu 3.8
e85843bec6c2ea7c10ec61238396891cc2b753a9 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.23 2014/01/24 01:07:00 jsg Exp $	*/
d2416 1
a2416 1
	if(intel_crtc->plane > dev_priv->num_pipe) {
d2419 1
a2419 1
				dev_priv->num_pipe);
d5473 1
a5473 1
	if (dev_priv->num_pipe == 2)
a9094 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d9130 2
a9131 1
		      dev_priv->num_pipe, dev_priv->num_pipe > 1 ? "s" : "");
d9133 1
a9133 1
	for (i = 0; i < dev_priv->num_pipe; i++) {
d9187 2
a9188 1
	struct drm_i915_private *dev_priv = crtc->base.dev->dev_private;
d9191 1
a9191 1
	if (dev_priv->num_pipe == 1)
a9641 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d9644 1
a9644 1
	seq_printf(m, "Num Pipes: %d\n", dev_priv->num_pipe);
@


1.23
log
@add some HAS_DDI() conversions that were missed in the earlier commit
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.22 2014/01/23 11:18:34 jsg Exp $	*/
d8958 11
d9027 5
@


1.22
log
@drm/i915: don't intel_crt_init on any ULT machines

From Paulo Zanoni
1c1d6d5d6c89fa54403ee053141795ad71fd7ee0 in ubuntu 3.8
c40c0f5bd5b0f09e4386d2cf26c96c89c45ee539 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.21 2014/01/23 10:42:57 jsg Exp $	*/
d1157 2
a1158 2
	if (IS_HASWELL(dev)) {
		/* On Haswell, DDI is used instead of FDI_TX_CTL */
d1203 1
a1203 1
	if (IS_HASWELL(dev))
@


1.21
log
@drm/i915: add HAS_DDI check

From Paulo Zanoni
d99994528e9946a78a505ca752fa3b73aa8c5a76 in ubuntu 3.8
affa935440733a79c5a9eb0e5357e2564ca4b355 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.20 2014/01/22 04:04:53 kettenis Exp $	*/
d8567 1
a8567 1
	if (!(HAS_DDI(dev) && (I915_READ(DDI_BUF_CTL(PORT_A)) & DDI_A_4_LANES)))
@


1.20
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.19 2014/01/21 08:57:22 kettenis Exp $	*/
d8431 1
a8431 1
	if (IS_HASWELL(dev))
d8567 1
a8567 2
	if (!(IS_HASWELL(dev) &&
	      (I915_READ(DDI_BUF_CTL(PORT_A)) & DDI_A_4_LANES)))
d8570 1
a8570 1
	if (IS_HASWELL(dev)) {
d8830 1
a8830 1
	if (IS_HASWELL(dev)) {
d9340 1
a9340 1
	if (IS_HASWELL(dev)) {
d9381 1
a9381 1
	if (IS_HASWELL(dev))
@


1.19
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.18 2013/12/01 14:20:02 kettenis Exp $	*/
d6745 1
a6745 1
	u32 pitch = howmany(width * bpp, 8);
@


1.18
log
@drm/i915: inverted brightness quirk for Acer Aspire 4736Z

From Daniel Vetter
96f2e8dd3f2492d3bbf232fa0afc1e0e065e7d52 in ubuntu 3.8
ac4199e0f047546aa40172785e26c82b54bbe811 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.17 2013/11/11 02:53:26 jsg Exp $	*/
d3953 1
a3953 1
	free(intel_encoder, M_DRM);
d6726 1
a6726 1
	intel_fb = malloc(sizeof(*intel_fb), M_DRM, M_WAITOK | M_ZERO);
d6735 1
a6735 1
		free(intel_fb, M_DRM);
d7036 1
a7036 1
	mode = malloc(sizeof(*mode), M_DRM, M_WAITOK | M_ZERO);
d7172 1
a7172 1
		free(work, M_DRM);
d7177 1
a7177 1
	free(intel_crtc, M_DRM);
d7196 1
a7196 1
	free(work, M_DRM);
d7553 1
a7553 1
	work = malloc(sizeof *work, M_DRM, M_WAITOK | M_ZERO);
d7570 1
a7570 1
		free(work, M_DRM);
d7631 1
a7631 1
	free(work, M_DRM);
d8132 3
a8134 3
	free(config->save_connector_encoders, M_DRM);
	free(config->save_encoder_crtcs, M_DRM);
	free(config, M_DRM);
d8145 2
a8146 2
		malloc(dev->mode_config.num_encoder *
		    sizeof(struct drm_crtc *), M_DRM, M_WAITOK | M_ZERO);
d8151 2
a8152 2
		malloc(dev->mode_config.num_connector *
		    sizeof(struct drm_encoder *),M_DRM, M_WAITOK | M_ZERO);
d8359 1
a8359 1
	config = malloc(sizeof(*config), M_DRM, M_WAITOK | M_ZERO);
d8458 1
a8458 3
	intel_crtc = malloc(sizeof(struct intel_crtc) +
	    (INTELFB_CONN_LIMIT * sizeof(struct drm_connector *)),
	    M_DRM, M_WAITOK | M_ZERO);
d8701 1
a8701 1
	free(intel_fb, M_DRM);
@


1.17
log
@drm/i915: Don't enable the cursor on a disable pipe

On HSW enabling a plane on a disabled pipe may hang the entire system.
And there's no good reason for doing it ever, so just don't.

v2: Move the crtc active checks to intel_crtc_cursor_{set,move} to
avoid confusing people during modeset

From Ville Syrjala
f6c0873963a9b8ea1d94541e0e219e6ea090012b in ubuntu 3.8
f2f5f771c5fc0fa252cde3d0d0452dcc785cc17a in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.16 2013/11/11 02:48:04 jsg Exp $	*/
d9016 3
@


1.16
log
@drm/i915: do not update cursor in crtc mode set

The cursor is disabled before crtc mode set in crtc disable (and we
assert this is the case), and enabled afterwards in crtc enable. Do not
update it in crtc mode set.

On HSW enabling a plane on a disabled pipe may hang the entire system.
And there's no good reason for doing it ever, so just don't.

v2: Add note about HSW hangs - vsyrjala

From Jani Nikula
0be01fc195fd4ea1aec1f8be7c03ca8f920a9486 in ubuntu 3.8
cc173961a68034c1171a421f0dbed39edfb60880 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.15 2013/11/02 22:58:10 kettenis Exp $	*/
d6636 2
a6637 1
	intel_crtc_update_cursor(crtc, true);
d6656 2
a6657 1
	intel_crtc_update_cursor(crtc, true);
@


1.15
log
@Replace drm_handle_create/delete with drm_gem_handle_create/delete and make
the necessary adjustments to reference counting of GEM objects.  Matches what
Linux does these days.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.14 2013/10/30 02:11:32 dlg Exp $	*/
a4857 3
	/* Ensure that the cursor is valid for the new mode before changing... */
	intel_crtc_update_cursor(crtc, true);

a5751 3
	/* Ensure that the cursor is valid for the new mode before changing... */
	intel_crtc_update_cursor(crtc, true);

a5950 3

	/* Ensure that the cursor is valid for the new mode before changing... */
	intel_crtc_update_cursor(crtc, true);
@


1.14
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.13 2013/10/29 06:30:57 jsg Exp $	*/
d8720 1
a8720 2
	drm_gem_object_reference(&obj->base);
	return drm_handle_create(file, &obj->base, handle);
@


1.13
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.12 2013/09/08 11:59:45 jsg Exp $	*/
d7178 1
a7178 1
		task_del(taskq_systq(), &work->task);
d7246 1
a7246 1
	task_add(taskq_systq(), &work->task);
d9501 2
a9502 2
	task_del(taskq_systq(), &dev_priv->hotplug_task);
	task_del(taskq_systq(), &dev_priv->rps.task);
@


1.12
log
@switch to using linux style pci match tables
fixes some omissions and flag errors for radeon
and removes the duplicate table for i915
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.11 2013/08/13 10:23:50 jsg Exp $	*/
d7178 1
a7178 1
//		cancel_work_sync(&work->work);
d7246 1
a7246 1
	workq_queue_task(NULL, &work->task, 0, intel_unpin_work_fn, work, NULL);
d7567 1
d9466 1
a9466 1
//	struct drm_i915_private *dev_priv = dev->dev_private;
d9501 2
a9502 4
#ifdef notyet
	cancel_work_sync(&dev_priv->hotplug_work);
	cancel_work_sync(&dev_priv->rps.work);
#endif
@


1.11
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.10 2013/08/09 07:55:42 jsg Exp $	*/
a8987 2

#define PCI_ANY_ID	(u_int16_t) (~0U)
@


1.10
log
@add commented out versions of unused functions present in the original
files to reduce the diff to linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.9 2013/07/08 09:47:45 jsg Exp $	*/
d36 4
a70 8
struct fdi_m_n {
	u32        tu;
	u32        gmch_m;
	u32        gmch_n;
	u32        link_m;
	u32        link_n;
};

a72 322
bool	 intel_pipe_has_type(struct drm_crtc *crtc, int type);
void	 intel_increase_pllclock(struct drm_crtc *crtc);
void	 intel_crtc_update_cursor(struct drm_crtc *crtc, bool on);

const intel_limit_t	*intel_ironlake_limit(struct drm_crtc *, int);
const intel_limit_t	*intel_g4x_limit(struct drm_crtc *);
const intel_limit_t	*intel_limit(struct drm_crtc *, int);

void	 pineview_clock(int, intel_clock_t *);
void	 intel_clock(struct drm_device *, int, intel_clock_t *clock);
bool 	 intel_PLL_is_valid(struct drm_device *, const intel_limit_t *,
	     const intel_clock_t *);
void	 assert_pll(struct drm_i915_private *, enum pipe, bool);
void	 assert_pch_pll(struct drm_i915_private *, struct intel_pch_pll *,
	     struct intel_crtc *, bool);
void	 assert_fdi_tx(struct drm_i915_private *, enum pipe, bool);
void	 assert_fdi_rx(struct drm_i915_private *, enum pipe, bool);
void	 assert_fdi_tx_pll_enabled(struct drm_i915_private *, enum pipe);
void	 assert_fdi_rx_pll_enabled(struct drm_i915_private *, enum pipe);
void	 assert_panel_unlocked(struct drm_i915_private *, enum pipe);
void	 assert_plane(struct drm_i915_private *, enum plane, bool);
void	 assert_planes_disabled(struct drm_i915_private *, enum pipe); 
void	 assert_pch_refclk_enabled(struct drm_i915_private *);
void	 assert_transcoder_disabled(struct drm_i915_private *, enum pipe);
bool	 hdmi_pipe_enabled(struct drm_i915_private *, enum pipe, u32);
bool	 lvds_pipe_enabled(struct drm_i915_private *, enum pipe, u32);
bool	 adpa_pipe_enabled(struct drm_i915_private *, enum pipe, u32);
bool	 dp_pipe_enabled(struct drm_i915_private *, enum pipe, u32, u32);
void	 assert_pch_dp_disabled(struct drm_i915_private *, enum pipe, int, u32);
void	 assert_pch_hdmi_disabled(struct drm_i915_private *, enum pipe, int);
void	 assert_pch_ports_disabled(struct drm_i915_private *, enum pipe);
void	 intel_enable_pll(struct drm_i915_private *, enum pipe);
void	 intel_disable_pll(struct drm_i915_private *, enum pipe);
void	 intel_enable_pch_pll(struct drm_i915_private *, enum pipe);
void	 intel_disable_pch_pll(struct intel_crtc *);
void	 intel_enable_transcoder(struct drm_i915_private *, enum pipe);
void	 intel_disable_transcoder(struct drm_i915_private *, enum pipe);
void	 intel_enable_pipe(struct drm_i915_private *, enum pipe, bool);
void	 intel_disable_pipe(struct drm_i915_private *, enum pipe);
void	 intel_flush_display_plane(struct drm_i915_private *, enum plane);
void	 intel_enable_plane(struct drm_i915_private *, enum plane, enum pipe);
void	 intel_disable_plane(struct drm_i915_private *, enum plane, enum pipe);
void	 disable_pch_dp(struct drm_i915_private *, enum pipe, int, u32);
void	 disable_pch_hdmi(struct drm_i915_private *, enum pipe, int);
void	 intel_disable_pch_ports(struct drm_i915_private *, enum pipe);
void	 i8xx_disable_fbc(struct drm_device *);
void	 i8xx_enable_fbc(struct drm_crtc *, unsigned long);
bool	 i8xx_fbc_enabled(struct drm_device *);
void	 g4x_enable_fbc(struct drm_crtc *, unsigned long);
void	 g4x_disable_fbc(struct drm_device *);
bool	 g4x_fbc_enabled(struct drm_device *);
void	 sandybridge_blit_fbc_update(struct drm_device *);
void	 ironlake_enable_fbc(struct drm_crtc *, unsigned long);
void	 ironlake_disable_fbc(struct drm_device *);
bool	 ironlake_fbc_enabled(struct drm_device *);
void	 intel_fbc_work_fn(void *, int);
void	 intel_cancel_fbc_work(struct drm_i915_private *);
void	 intel_enable_fbc(struct drm_crtc *, unsigned long);
void	 intel_update_fbc(struct drm_device *);
int	 i9xx_update_plane(struct drm_crtc *, struct drm_framebuffer *, int,
	     int);
int	 ironlake_update_plane(struct drm_crtc *, struct drm_framebuffer *, int,
	     int);
int	 intel_pipe_set_base_atomic(struct drm_crtc *, struct drm_framebuffer *,
	     int, int, enum mode_set_atomic);
int	 intel_finish_fb(struct drm_framebuffer *);
int	 intel_pipe_set_base(struct drm_crtc *, int, int,
	     struct drm_framebuffer *);
void	 ironlake_set_pll_edp(struct drm_crtc *, int);
void	 intel_fdi_normal_train(struct drm_crtc *);
void	 cpt_phase_pointer_enable(struct drm_device *, int);
void	 ironlake_fdi_link_train(struct drm_crtc *);
void	 gen6_fdi_link_train(struct drm_crtc *);
void	 ivb_manual_fdi_link_train(struct drm_crtc *);
void	 ironlake_fdi_pll_enable(struct intel_crtc *);
void	 cpt_phase_pointer_disable(struct drm_device *, int);
void	 ironlake_fdi_disable(struct drm_crtc *);
void	 intel_clear_scanline_wait(struct drm_device *);
void	 intel_crtc_wait_for_pending_flips(struct drm_crtc *);
bool	 intel_crtc_driving_pch(struct drm_crtc *);
void	 ironlake_pch_enable(struct drm_crtc *);
void	 ironlake_crtc_enable(struct drm_crtc *);
void	 ironlake_crtc_disable(struct drm_crtc *);
void	 ironlake_crtc_dpms(struct drm_crtc *, int);
void	 intel_crtc_dpms_overlay(struct intel_crtc *, bool);
void	 i9xx_crtc_enable(struct drm_crtc *);
void	 i9xx_crtc_disable(struct drm_crtc *);
void	 i9xx_crtc_dpms(struct drm_crtc *, int);
void	 intel_crtc_dpms(struct drm_crtc *, int);
void	 intel_crtc_disable(struct drm_crtc *);
void	 i9xx_crtc_prepare(struct drm_crtc *);
void	 i9xx_crtc_commit(struct drm_crtc *);
void	 ironlake_crtc_prepare(struct drm_crtc *);
void	 ironlake_crtc_commit(struct drm_crtc *);
bool	 intel_crtc_mode_fixup(struct drm_crtc *, const struct drm_display_mode *,
	     struct drm_display_mode *);
int	 i945_get_display_clock_speed(struct drm_device *);
int	 i915_get_display_clock_speed(struct drm_device *);
int	 i9xx_misc_get_display_clock_speed(struct drm_device *);
int	 i915gm_get_display_clock_speed(struct drm_device *);
int	 i865_get_display_clock_speed(struct drm_device *);
int	 i855_get_display_clock_speed(struct drm_device *);
int	 i830_get_display_clock_speed(struct drm_device *);
void	 fdi_reduce_ratio(u32 *, u32 *);
void	 ironlake_compute_m_n(int, int, int, int, struct fdi_m_n *);
unsigned long	 intel_calculate_wm(unsigned long,
	     const struct intel_watermark_params *, int, int,
	     unsigned long);
const struct cxsr_latency	*intel_get_cxsr_latency(int, int, int, int);
void	 pineview_disable_cxsr(struct drm_device *);
int	 i9xx_get_fifo_size(struct drm_device *, int);
int	 i85x_get_fifo_size(struct drm_device *, int);
int	 i845_get_fifo_size(struct drm_device *, int);
int	 i830_get_fifo_size(struct drm_device *, int);
struct drm_crtc	*single_enabled_crtc(struct drm_device *);
void	 pineview_update_wm(struct drm_device *);
bool	 g4x_compute_wm0(struct drm_device *, int,
	     const struct intel_watermark_params *, int,
	     const struct intel_watermark_params *, int, int *, int *);
bool	 g4x_check_srwm(struct drm_device *, int, int,
	     const struct intel_watermark_params *,
	     const struct intel_watermark_params *);
bool	 g4x_compute_srwm(struct drm_device *, int, int,
	     const struct intel_watermark_params *,
	     const struct intel_watermark_params *, int *, int *);
void	 g4x_update_wm(struct drm_device *);
void	 i965_update_wm(struct drm_device *);
void	 i9xx_update_wm(struct drm_device *);
void	 i830_update_wm(struct drm_device *);
bool	 ironlake_check_srwm(struct drm_device *, int, int, int, int,
	     const struct intel_watermark_params *,
	     const struct intel_watermark_params *);
bool	 ironlake_compute_srwm(struct drm_device *, int, int, int,
	     const struct intel_watermark_params *,
	     const struct intel_watermark_params *, int *, int *, int *);
void	 ironlake_update_wm(struct drm_device *);
bool	 sandybridge_compute_sprite_wm(struct drm_device *, int, uint32_t, int,
	     const struct intel_watermark_params *, int, int *);
bool	 sandybridge_compute_sprite_srwm(struct drm_device *, int, uint32_t,
	     int, const struct intel_watermark_params *, int, int *);
void	 sandybridge_update_sprite_wm(struct drm_device *, int, uint32_t, int);
bool	 intel_choose_pipe_bpp_dither(struct drm_crtc *, struct drm_framebuffer *,
	     unsigned int *, struct drm_display_mode *);
int	 i9xx_get_refclk(struct drm_crtc *, int);
void	 i9xx_adjust_sdvo_tv_clock(struct drm_display_mode *, intel_clock_t *);
void	 i9xx_update_pll_dividers(struct drm_crtc *, intel_clock_t *,
	     intel_clock_t *);
int	 i9xx_crtc_mode_set(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, int, int, struct drm_framebuffer *);
int	 ironlake_get_refclk(struct drm_crtc *);
int	 ironlake_crtc_mode_set(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, int, int, struct drm_framebuffer *);
int	 intel_crtc_mode_set(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, int, int, struct drm_framebuffer *);
bool	 intel_eld_uptodate(struct drm_connector *, int, uint32_t, int,
	     uint32_t, int);
void	 g4x_write_eld(struct drm_connector *, struct drm_crtc *);
void	 ironlake_write_eld(struct drm_connector *, struct drm_crtc *);
void	 i845_update_cursor(struct drm_crtc *, u32);
void	 i9xx_update_cursor(struct drm_crtc *, u32);
void	 ivb_update_cursor(struct drm_crtc *, u32);
int	 intel_crtc_cursor_set(struct drm_crtc *, struct drm_file *, uint32_t,
	     uint32_t, uint32_t);
int	 intel_crtc_cursor_move(struct drm_crtc *, int, int);
void	 intel_crtc_gamma_set(struct drm_crtc *, u16 *, u16 *, u16 *, uint32_t,
	     uint32_t);
struct drm_framebuffer *
	 intel_framebuffer_create(struct drm_device *,
	     struct drm_mode_fb_cmd2 *, struct drm_i915_gem_object *);
u32	 intel_framebuffer_pitch_for_width(int, int);
u32	 intel_framebuffer_size_for_mode(struct drm_display_mode *, int);
struct drm_framebuffer *
	 intel_framebuffer_create_for_mode(struct drm_device *,
	     struct drm_display_mode *, int, int);
struct drm_framebuffer *
	 mode_fits_in_fbdev(struct drm_device *, struct drm_display_mode *);
int	 intel_crtc_clock_get(struct drm_device *, struct drm_crtc *);
void	 intel_crtc_destroy(struct drm_crtc *);
void	 do_intel_finish_page_flip(struct drm_device *, struct drm_crtc *);
int	 intel_crtc_page_flip(struct drm_crtc *, struct drm_framebuffer *,
	     struct drm_pending_vblank_event *);
void	 intel_sanitize_modesetting(struct drm_device *, int, int);
void	 intel_crtc_reset(struct drm_crtc *);
void	 intel_crtc_init(struct drm_device *, int);
int	 intel_encoder_clones(struct intel_encoder *);
bool	 has_edp_a(struct drm_device *);
void	 intel_setup_outputs(struct drm_device *);
void	 intel_user_framebuffer_destroy(struct drm_framebuffer *);
int	 intel_user_framebuffer_create_handle(struct drm_framebuffer *,
	     struct drm_file *, unsigned int *);
struct drm_framebuffer *
	 intel_user_framebuffer_create(struct drm_device *,
	 struct drm_file *, struct drm_mode_fb_cmd2 *);
unsigned long	 intel_pxfreq(u32);
void	 ironlake_init_clock_gating(struct drm_device *);
void	 gen6_init_clock_gating(struct drm_device *);
void	 ivybridge_init_clock_gating(struct drm_device *);
void	 g4x_init_clock_gating(struct drm_device *);
void	 crestline_init_clock_gating(struct drm_device *);
void	 broadwater_init_clock_gating(struct drm_device *);
void	 gen3_init_clock_gating(struct drm_device *);
void	 i85x_init_clock_gating(struct drm_device *);
void	 i830_init_clock_gating(struct drm_device *);
void	 ibx_init_clock_gating(struct drm_device *);
void	 cpt_init_clock_gating(struct drm_device *);
void	 ironlake_teardown_rc6(struct drm_device *);
void	 ironlake_disable_rc6(struct drm_device *);
int	 ironlake_setup_rc6(struct drm_device *);
void	 intel_init_display(struct drm_device *);
void	 quirk_pipea_force(struct drm_device *);
void	 quirk_ssc_force_disable(struct drm_device *);
void	 intel_init_quirks(struct drm_device *);
void	 i915_disable_vga(struct drm_device *);
void	 intel_crtc_idle_timer(void *);
void	 intel_gpu_idle_timer(void *);
void	 intel_idle_update(void *, int);
void	 intel_decrease_pllclock(struct drm_crtc *);
int	 intel_default_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
int	 intel_gen2_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
int	 intel_gen3_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
int	 intel_gen4_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
int	 intel_gen6_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
int	 intel_gen7_queue_flip(struct drm_device *, struct drm_crtc *,
	     struct drm_framebuffer *, struct drm_i915_gem_object *);
void	 intel_unpin_work_fn(void *, void *);
void	 intel_dpio_write(struct drm_i915_private *, int, u32);
void	 vlv_init_dpio(struct drm_device *);
int	 intel_dual_link_lvds_callback(const struct dmi_system_id *);
bool	 is_dual_link_lvds(struct drm_i915_private *, unsigned int);
void	 ironlake_wait_for_vblank(struct drm_device *, int);
const char *state_string(bool);
void	 intel_sbi_write(struct drm_i915_private *, u16, u32,
	     enum intel_sbi_destination);
u32	 intel_sbi_read(struct drm_i915_private *, u16,
	     enum intel_sbi_destination);
void	 ironlake_enable_pch_pll(struct intel_crtc *);
void	 ironlake_enable_pch_transcoder(struct drm_i915_private *, enum pipe);
void	 lpt_enable_pch_transcoder(struct drm_i915_private *, enum transcoder);
void	 ironlake_disable_pch_transcoder(struct drm_i915_private *, enum pipe);
void	 lpt_disable_pch_transcoder(struct drm_i915_private *);
void	 intel_crtc_update_sarea_pos(struct drm_crtc *, int, int);
void	 ivb_modeset_global_resources(struct drm_device *);
void	 ironlake_fdi_pll_disable(struct intel_crtc *);
bool	 intel_crtc_has_pending_flip(struct drm_crtc *);
bool	 ironlake_crtc_driving_pch(struct drm_crtc *);
bool	 haswell_crtc_driving_pch(struct drm_crtc *);
void	 lpt_program_iclkip(struct drm_crtc *);
void	 lpt_pch_enable(struct drm_crtc *);
void	 intel_put_pch_pll(struct intel_crtc *);
void	 haswell_crtc_enable(struct drm_crtc *);
void	 haswell_crtc_disable(struct drm_crtc *);
void	 ironlake_crtc_off(struct drm_crtc *);
void	 haswell_crtc_off(struct drm_crtc *);
void	 i9xx_crtc_off(struct drm_crtc *);
void	 intel_crtc_update_sarea(struct drm_crtc *, bool);
void	 intel_crtc_noop(struct drm_crtc *);
void	 intel_connector_check_state(struct intel_connector *);
int	 valleyview_get_display_clock_speed(struct drm_device *);
int	 vlv_get_refclk(struct drm_crtc *);
void	 intel_update_lvds(struct drm_crtc *, intel_clock_t *,
	     struct drm_display_mode *);
void	 vlv_update_pll(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, intel_clock_t *, intel_clock_t *, int);
void	 i9xx_update_pll(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, intel_clock_t *, intel_clock_t *, int);
void	 i8xx_update_pll(struct drm_crtc *, struct drm_display_mode *,
	     intel_clock_t *, intel_clock_t *, int);
void	 intel_set_pipe_timings(struct intel_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *);
void	 lpt_init_pch_refclk(struct drm_device *);
void	 ironlake_set_pipeconf(struct drm_crtc *, struct drm_display_mode *,
	     bool);
void	 haswell_set_pipeconf(struct drm_crtc *, struct drm_display_mode *,
	     bool);
bool	 ironlake_compute_clocks(struct drm_crtc *, struct drm_display_mode *,
	     intel_clock_t *, bool *, intel_clock_t *);
void	 cpt_enable_fdi_bc_bifurcation(struct drm_device *);
bool	 ironlake_check_fdi_lanes(struct intel_crtc *);
void	 ironlake_set_m_n(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *);
uint32_t ironlake_compute_dpll(struct intel_crtc *, struct drm_display_mode *,
	     intel_clock_t *, u32);
int	 haswell_crtc_mode_set(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *, int, int, struct drm_framebuffer *);
void	 haswell_write_eld(struct drm_connector *, struct drm_crtc *);
bool	 intel_encoder_crtc_ok(struct drm_encoder *, struct drm_crtc *);
void	 intel_modeset_update_staged_output_state(struct drm_device *);
void	 intel_modeset_commit_output_state(struct drm_device *);
struct drm_display_mode *
	 intel_modeset_adjusted_mode(struct drm_crtc *, struct drm_display_mode *);
void	 intel_modeset_affected_pipes(struct drm_crtc *, unsigned *,
	     unsigned *, unsigned *);
void	 intel_modeset_affected_pipes(struct drm_crtc *, unsigned *,
	     unsigned *, unsigned *);
bool	 intel_crtc_in_use(struct drm_crtc *);
void	 intel_modeset_update_state(struct drm_device *, unsigned);
void	 intel_set_config_free(struct intel_set_config *);
int	 intel_set_config_save_state(struct drm_device *,
	     struct intel_set_config *);
void	 intel_set_config_restore_state(struct drm_device *,
	     struct intel_set_config *);
void	 intel_set_config_compute_mode_changes(struct drm_mode_set *,
	     struct intel_set_config *);
int	 intel_modeset_stage_output_state(struct drm_device *,
	     struct drm_mode_set *, struct intel_set_config *);
int	 intel_crtc_set_config(struct drm_mode_set *);
void	 intel_cpu_pll_init(struct drm_device *);
void	 i915_redisable_vga(struct drm_device *);
void	 intel_pch_pll_init(struct drm_device *);
void	 quirk_invert_brightness(struct drm_device *);
int	 intel_dmi_reverse_brightness(const struct dmi_system_id *);
void	 intel_connector_break_all_links(struct intel_connector *);
void	 intel_enable_pipe_a(struct drm_device *);
bool	 intel_check_plane_mapping(struct intel_crtc *);
void	 intel_sanitize_crtc(struct intel_crtc *);
void	 intel_sanitize_encoder(struct intel_encoder *);

d409 1
a409 2
u32
intel_dpio_read(struct drm_i915_private *dev_priv, int reg)
d444 1
a444 2
void
intel_dpio_write(struct drm_i915_private *dev_priv, int reg,
d476 1
a476 2
void
vlv_init_dpio(struct drm_device *dev)
d487 1
a487 2
int
intel_dual_link_lvds_callback(const struct dmi_system_id *id)
d505 1
a505 2
bool
is_dual_link_lvds(struct drm_i915_private *dev_priv,
d533 1
a533 2
const intel_limit_t *
intel_ironlake_limit(struct drm_crtc *crtc,
d562 1
a562 2
const intel_limit_t *
intel_g4x_limit(struct drm_crtc *crtc)
d588 1
a588 2
const intel_limit_t *
intel_limit(struct drm_crtc *crtc, int refclk)
d624 1
a624 2
void
pineview_clock(int refclk, intel_clock_t *clock)
d632 1
a632 2
void
intel_clock(struct drm_device *dev, int refclk, intel_clock_t *clock)
d647 1
a647 2
bool
intel_pipe_has_type(struct drm_crtc *crtc, int type)
d665 1
a665 2
bool
intel_PLL_is_valid(struct drm_device *dev,
d694 1
a694 1
bool
d760 1
a760 1
bool
d828 1
a828 1
bool
d855 1
a855 1
bool
d881 1
a881 2

bool
d950 1
a950 2
enum transcoder
intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
d959 1
a959 2
void
ironlake_wait_for_vblank(struct drm_device *dev, int pipe)
d984 1
a984 2
void
intel_wait_for_vblank(struct drm_device *dev, int pipe)
d1038 1
a1038 2
void
intel_wait_for_pipe_off(struct drm_device *dev, int pipe)
d1077 1
a1077 2
const char *
state_string(bool enabled)
d1083 1
a1083 2
void
assert_pll(struct drm_i915_private *dev_priv,
d1101 1
a1101 2
void
assert_pch_pll(struct drm_i915_private *dev_priv,
d1147 1
a1147 2
void
assert_fdi_tx(struct drm_i915_private *dev_priv,
d1174 1
a1174 2
void
assert_fdi_rx(struct drm_i915_private *dev_priv,
d1191 1
a1191 2
void
assert_fdi_tx_pll_enabled(struct drm_i915_private *dev_priv,
d1211 1
a1211 2
void
assert_fdi_rx_pll_enabled(struct drm_i915_private *dev_priv,
d1222 1
a1222 2
void
assert_panel_unlocked(struct drm_i915_private *dev_priv,
d1252 1
a1252 2
void
assert_pipe(struct drm_i915_private *dev_priv,
d1273 1
a1273 2
void
assert_plane(struct drm_i915_private *dev_priv,
d1291 1
a1291 2
void
assert_planes_disabled(struct drm_i915_private *dev_priv,
d1321 1
a1321 2
void
assert_pch_refclk_enabled(struct drm_i915_private *dev_priv)
d1338 1
a1338 2
void
assert_transcoder_disabled(struct drm_i915_private *dev_priv,
d1353 1
a1353 2
bool
dp_pipe_enabled(struct drm_i915_private *dev_priv,
d1373 1
a1373 2
bool
hdmi_pipe_enabled(struct drm_i915_private *dev_priv,
d1391 1
a1391 2
bool
lvds_pipe_enabled(struct drm_i915_private *dev_priv,
d1409 1
a1409 2
bool
adpa_pipe_enabled(struct drm_i915_private *dev_priv,
d1426 1
a1426 2
void
assert_pch_dp_disabled(struct drm_i915_private *dev_priv,
d1440 1
a1440 2
void
assert_pch_hdmi_disabled(struct drm_i915_private *dev_priv,
d1454 1
a1454 2
void
assert_pch_ports_disabled(struct drm_i915_private *dev_priv,
d1494 1
a1494 2
void
intel_enable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
d1532 1
a1532 2
void
intel_disable_pll(struct drm_i915_private *dev_priv, enum pipe pipe)
d1552 1
a1552 1
void
d1593 1
a1593 1
u32
d1644 1
a1644 2
void
ironlake_enable_pch_pll(struct intel_crtc *intel_crtc)
d1684 1
a1684 2
void
intel_disable_pch_pll(struct intel_crtc *intel_crtc)
d1728 1
a1728 2
void
ironlake_enable_pch_transcoder(struct drm_i915_private *dev_priv,
d1790 1
a1790 2
void
lpt_enable_pch_transcoder(struct drm_i915_private *dev_priv,
d1827 1
a1827 2
void
ironlake_disable_pch_transcoder(struct drm_i915_private *dev_priv,
d1863 1
a1863 2
void
lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv)
d1900 1
a1900 2
void
intel_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe,
d1952 1
a1952 2
void
intel_disable_pipe(struct drm_i915_private *dev_priv,
d1984 1
a1984 2
void
intel_flush_display_plane(struct drm_i915_private *dev_priv,
d2001 1
a2001 2
void
intel_enable_plane(struct drm_i915_private *dev_priv,
d2029 1
a2029 2
void
intel_disable_plane(struct drm_i915_private *dev_priv,
d2107 1
a2107 2
void
intel_unpin_fb_obj(struct drm_i915_gem_object *obj)
d2115 1
a2115 2
unsigned long
intel_gen4_compute_page_offset(int *x, int *y,
d2140 1
a2140 2
int
i9xx_update_plane(struct drm_crtc *crtc, struct drm_framebuffer *fb,
d2237 1
a2237 2
int
ironlake_update_plane(struct drm_crtc *crtc,
d2329 1
a2329 1
int
d2343 1
a2343 1
int
d2371 1
a2371 2
void
intel_crtc_update_sarea_pos(struct drm_crtc *crtc, int x, int y)
d2400 1
a2400 1
int
d2462 1
a2462 2
void
ironlake_set_pll_edp(struct drm_crtc *crtc, int clock)
d2499 1
a2499 2
void
intel_fdi_normal_train(struct drm_crtc *crtc)
d2540 1
a2540 2
void
ivb_modeset_global_resources(struct drm_device *dev)
d2564 1
a2564 2
void
ironlake_fdi_link_train(struct drm_crtc *crtc)
d2666 1
a2666 2
void
gen6_fdi_link_train(struct drm_crtc *crtc)
d2798 1
a2798 2
void
ivb_manual_fdi_link_train(struct drm_crtc *crtc)
d2914 1
a2914 2
void
ironlake_fdi_pll_enable(struct intel_crtc *intel_crtc)
d2955 1
a2955 2
void
ironlake_fdi_pll_disable(struct intel_crtc *intel_crtc)
d2984 1
a2984 2
void
ironlake_fdi_disable(struct drm_crtc *crtc)
d3037 1
a3037 2
bool
intel_crtc_has_pending_flip(struct drm_crtc *crtc)
d3053 1
a3053 2
void
intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc)
d3069 1
a3069 2
bool
ironlake_crtc_driving_pch(struct drm_crtc *crtc)
d3090 1
a3090 2
bool
haswell_crtc_driving_pch(struct drm_crtc *crtc)
d3096 1
a3096 2
void
lpt_program_iclkip(struct drm_crtc *crtc)
d3187 1
a3187 2
void
ironlake_pch_enable(struct drm_crtc *crtc)
d3292 1
a3292 2
void
lpt_pch_enable(struct drm_crtc *crtc)
d3316 1
a3316 2
void
intel_put_pch_pll(struct intel_crtc *intel_crtc)
d3332 1
a3332 2
static struct intel_pch_pll *
intel_get_pch_pll(struct intel_crtc *intel_crtc, u32 dpll, u32 fp)
d3404 1
a3404 2
void
intel_cpt_verify_modeset(struct drm_device *dev, int pipe)
d3423 1
a3423 2
void
ironlake_crtc_enable(struct drm_crtc *crtc)
d3516 1
a3516 2
void
haswell_crtc_enable(struct drm_crtc *crtc)
d3593 1
a3593 2
void
ironlake_crtc_disable(struct drm_crtc *crtc)
d3673 1
a3673 2
void
haswell_crtc_disable(struct drm_crtc *crtc)
d3728 1
a3728 2
void
ironlake_crtc_off(struct drm_crtc *crtc)
d3734 1
a3734 2
void
haswell_crtc_off(struct drm_crtc *crtc)
d3745 1
a3745 2
void
intel_crtc_dpms_overlay(struct intel_crtc *intel_crtc, bool enable)
d3763 1
a3763 2
void
i9xx_crtc_enable(struct drm_crtc *crtc)
d3795 1
a3795 2
void
i9xx_crtc_disable(struct drm_crtc *crtc)
d3837 1
a3837 2
void
i9xx_crtc_off(struct drm_crtc *crtc)
d3841 1
a3841 2
void
intel_crtc_update_sarea(struct drm_crtc *crtc,
d3876 1
a3876 2
void
intel_crtc_update_dpms(struct drm_crtc *crtc)
d3894 1
a3894 2
void
intel_crtc_noop(struct drm_crtc *crtc)
d3898 1
a3898 2
void
intel_crtc_disable(struct drm_crtc *crtc)
d3934 1
a3934 2
void
intel_modeset_disable(struct drm_device *dev)
d3944 1
a3944 2
void
intel_encoder_noop(struct drm_encoder *encoder)
d3948 1
a3948 2
void
intel_encoder_destroy(struct drm_encoder *encoder)
d3959 1
a3959 2
void
intel_encoder_dpms(struct intel_encoder *encoder, int mode)
d3974 1
a3974 2
void
intel_connector_check_state(struct intel_connector *connector)
d4009 1
a4009 2
void
intel_connector_dpms(struct drm_connector *connector, int mode)
d4034 1
a4034 2
bool
intel_connector_get_hw_state(struct intel_connector *connector)
d4042 1
a4042 2
bool
intel_crtc_mode_fixup(struct drm_crtc *crtc,
d4070 1
a4070 2
int
valleyview_get_display_clock_speed(struct drm_device *dev)
d4075 1
a4075 2
int
i945_get_display_clock_speed(struct drm_device *dev)
d4080 1
a4080 2
int
i915_get_display_clock_speed(struct drm_device *dev)
d4085 1
a4085 2
int
i9xx_misc_get_display_clock_speed(struct drm_device *dev)
d4090 1
a4090 2
int
i915gm_get_display_clock_speed(struct drm_device *dev)
d4110 1
a4110 2
int
i865_get_display_clock_speed(struct drm_device *dev)
d4115 1
a4115 2
int
i855_get_display_clock_speed(struct drm_device *dev)
d4135 1
a4135 2
int
i830_get_display_clock_speed(struct drm_device *dev)
d4140 9
a4148 1
void
d4157 1
a4157 1
void
d4173 1
a4173 2
static inline bool
intel_panel_use_ssc(struct drm_i915_private *dev_priv)
d4202 1
a4202 2
bool
intel_choose_pipe_bpp_dither(struct drm_crtc *crtc,
d4317 1
a4317 2
int
vlv_get_refclk(struct drm_crtc *crtc)
d4339 1
a4339 2
int
i9xx_get_refclk(struct drm_crtc *crtc, int num_connectors)
d4361 1
a4361 2
void
i9xx_adjust_sdvo_tv_clock(struct drm_display_mode *adjusted_mode,
d4383 1
a4383 2
void
i9xx_update_pll_dividers(struct drm_crtc *crtc,
d4417 1
a4417 2
void
intel_update_lvds(struct drm_crtc *crtc, intel_clock_t *clock,
d4462 1
a4462 2
void
vlv_update_pll(struct drm_crtc *crtc,
d4568 1
a4568 2
void
i9xx_update_pll(struct drm_crtc *crtc,
d4681 1
a4681 2
void
i8xx_update_pll(struct drm_crtc *crtc,
d4743 1
a4743 2
void
intel_set_pipe_timings(struct intel_crtc *intel_crtc,
d4801 1
a4801 2
int
i9xx_crtc_mode_set(struct drm_crtc *crtc,
d4980 1
a4980 2
void
ironlake_init_pch_refclk(struct drm_device *dev)
d5095 1
a5095 2
void
lpt_init_pch_refclk(struct drm_device *dev)
d5270 1
a5270 2
void
intel_init_pch_refclk(struct drm_device *dev)
d5278 1
a5278 2
int
ironlake_get_refclk(struct drm_crtc *crtc)
d5308 1
a5308 2
void
ironlake_set_pipeconf(struct drm_crtc *crtc,
d5352 1
a5352 2
void
haswell_set_pipeconf(struct drm_crtc *crtc,
d5377 1
a5377 2
bool
ironlake_compute_clocks(struct drm_crtc *crtc,
d5440 1
a5440 2
void
cpt_enable_fdi_bc_bifurcation(struct drm_device *dev)
d5458 1
a5458 2
bool
ironlake_check_fdi_lanes(struct intel_crtc *intel_crtc)
d5522 1
a5522 2
int
ironlake_get_lanes_required(int target_clock, int link_bw, int bpp)
d5533 1
a5533 2
void
ironlake_set_m_n(struct drm_crtc *crtc,
d5603 1
a5603 2
uint32_t
ironlake_compute_dpll(struct intel_crtc *intel_crtc,
d5706 1
a5706 2
int
ironlake_crtc_mode_set(struct drm_crtc *crtc,
d5889 1
a5889 2
int
haswell_crtc_mode_set(struct drm_crtc *crtc,
d6100 1
a6100 2
int
intel_crtc_mode_set(struct drm_crtc *crtc,
d6135 1
a6135 2
bool
intel_eld_uptodate(struct drm_connector *connector,
d6164 1
a6164 2
void
g4x_write_eld(struct drm_connector *connector,
d6205 1
a6205 2
void
haswell_write_eld(struct drm_connector *connector,
d6290 1
a6290 2
void
ironlake_write_eld(struct drm_connector *connector,
d6365 1
a6365 2
void
intel_write_eld(struct drm_encoder *encoder,
d6390 1
a6390 2
void
intel_crtc_load_lut(struct drm_crtc *crtc)
d6414 1
a6414 2
void
i845_update_cursor(struct drm_crtc *crtc, u32 base)
d6444 1
a6444 2
void
i9xx_update_cursor(struct drm_crtc *crtc, u32 base)
d6470 1
a6470 2
void
ivb_update_cursor(struct drm_crtc *crtc, u32 base)
d6496 1
a6496 2
void
intel_crtc_update_cursor(struct drm_crtc *crtc,
d6554 1
a6554 2
int
intel_crtc_cursor_set(struct drm_crtc *crtc,
d6657 1
a6657 2
int
intel_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)
d6670 1
a6670 2
void
intel_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
d6680 1
a6680 2
void
intel_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
d6690 1
a6690 2
void
intel_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,
d6725 1
a6725 1
struct drm_framebuffer *
d6749 1
a6749 1
u32
d6756 1
a6756 1
u32
d6763 1
a6763 1
struct drm_framebuffer *
d6785 1
a6785 1
struct drm_framebuffer *
d6811 1
a6811 2
bool
intel_get_load_detect_pipe(struct drm_connector *connector,
d6914 1
a6914 2
void
intel_release_load_detect_pipe(struct drm_connector *connector,
d6944 1
a6944 2
int
intel_crtc_clock_get(struct drm_device *dev, struct drm_crtc *crtc)
d7031 1
a7031 2
struct drm_display_mode *
intel_crtc_mode_get(struct drm_device *dev,
d7062 1
a7062 2
void
intel_increase_pllclock(struct drm_crtc *crtc)
d7093 1
a7093 2
void
intel_decrease_pllclock(struct drm_crtc *crtc)
d7129 1
a7129 2
void
intel_mark_busy(struct drm_device *dev)
d7134 1
a7134 2
void
intel_mark_idle(struct drm_device *dev)
d7149 1
a7149 2
void
intel_mark_fb_busy(struct drm_i915_gem_object *obj)
d7166 1
a7166 2
void
intel_crtc_destroy(struct drm_crtc *crtc)
d7187 1
a7187 2
void
intel_unpin_work_fn(void *arg1, void *arg2)
d7206 1
a7206 2
void
do_intel_finish_page_flip(struct drm_device *dev,
d7251 1
a7251 2
void
intel_finish_page_flip(struct drm_device *dev, int pipe)
d7259 1
a7259 2
void
intel_finish_page_flip_plane(struct drm_device *dev, int plane)
d7267 1
a7267 2
void
intel_prepare_page_flip(struct drm_device *dev, int plane)
d7283 1
a7283 2
static inline void
intel_mark_page_flip_active(struct intel_crtc *intel_crtc)
d7292 1
a7292 2
int
intel_gen2_queue_flip(struct drm_device *dev,
d7336 1
a7336 2
int
intel_gen3_queue_flip(struct drm_device *dev,
d7377 1
a7377 2
int
intel_gen4_queue_flip(struct drm_device *dev,
d7425 1
a7425 2
int
intel_gen6_queue_flip(struct drm_device *dev,
d7475 1
a7475 2
int
intel_gen7_queue_flip(struct drm_device *dev,
d7527 1
a7527 2
int
intel_default_queue_flip(struct drm_device *dev,
d7535 1
a7535 2
int
intel_crtc_page_flip(struct drm_crtc *crtc,
d7648 1
a7648 2
bool
intel_encoder_check_is_cloned(struct intel_encoder *encoder)
d7670 1
a7670 2
bool
intel_encoder_crtc_ok(struct drm_encoder *encoder,
d7698 1
a7698 2
void
intel_modeset_update_staged_output_state(struct drm_device *dev)
d7721 1
a7721 2
void
intel_modeset_commit_output_state(struct drm_device *dev)
d7737 1
a7737 1
struct drm_display_mode *
d7781 1
a7781 1
void
d7874 1
a7874 2
bool
intel_crtc_in_use(struct drm_crtc *crtc)
d7886 1
a7886 1
void
d8038 1
a8038 2
bool
intel_set_mode(struct drm_crtc *crtc,
d8133 1
a8133 2
void
intel_set_config_free(struct intel_set_config *config)
d8143 1
a8143 2
int
intel_set_config_save_state(struct drm_device *dev,
d8179 1
a8179 2
void
intel_set_config_restore_state(struct drm_device *dev,
d8199 1
a8199 1
void
d8233 1
a8233 1
int
d8334 1
a8334 2
int
intel_crtc_set_config(struct drm_mode_set *set)
d8435 1
a8435 2
void
intel_cpu_pll_init(struct drm_device *dev)
d8441 1
a8441 2
void
intel_pch_pll_init(struct drm_device *dev)
d8458 1
a8458 2
void
intel_crtc_init(struct drm_device *dev, int pipe)
d8498 1
a8498 2
int
intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
d8522 1
a8522 2
int
intel_encoder_clones(struct intel_encoder *encoder)
d8545 1
a8545 2
bool
has_edp_a(struct drm_device *dev)
d8562 1
a8562 2
void
intel_setup_outputs(struct drm_device *dev)
d8702 1
a8702 2
void
intel_user_framebuffer_destroy(struct drm_framebuffer *fb)
d8712 1
a8712 2
int
intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,
d8728 1
a8728 2
int
intel_framebuffer_init(struct drm_device *dev,
d8814 1
a8814 1
struct drm_framebuffer *
d8835 1
a8835 2
void
intel_init_display(struct drm_device *dev)
d8939 1
a8939 2
void
quirk_pipea_force(struct drm_device *dev)
d8950 1
a8950 2
void
quirk_ssc_force_disable(struct drm_device *dev)
d8961 1
a8961 2
void
quirk_invert_brightness(struct drm_device *dev)
d8981 2
a8982 2
int
intel_dmi_reverse_brightness(const struct dmi_system_id *id)
d8987 1
d9027 1
a9027 2
void
intel_init_quirks(struct drm_device *dev)
d9044 1
a9044 2
void
i915_disable_vga(struct drm_device *dev)
d9070 1
a9070 2
void
intel_modeset_init_hw(struct drm_device *dev)
d9086 1
a9086 2
void
intel_modeset_init(struct drm_device *dev)
d9141 1
a9141 1
void
d9150 1
a9150 2
void
intel_enable_pipe_a(struct drm_device *dev)
d9177 1
a9177 1
bool
d9196 1
a9196 2
void
intel_sanitize_crtc(struct intel_crtc *crtc)
d9277 1
a9277 2
void
intel_sanitize_encoder(struct intel_encoder *encoder)
d9320 1
a9320 2
void
i915_redisable_vga(struct drm_device *dev)
d9339 1
a9339 2
void
intel_modeset_setup_hw_state(struct drm_device *dev,
d9456 1
a9456 2
void
intel_modeset_gem_init(struct drm_device *dev)
d9465 1
a9465 2
void
intel_modeset_cleanup(struct drm_device *dev)
d9521 1
a9521 2
struct drm_encoder *
intel_best_encoder(struct drm_connector *connector)
d9526 1
a9526 2
void
intel_connector_attach_encoder(struct intel_connector *connector,
d9537 1
a9537 2
int
intel_modeset_vga_set_state(struct drm_device *dev, bool state)
@


1.9
log
@make use of udelay to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.8 2013/07/05 07:20:27 jsg Exp $	*/
d10078 115
@


1.8
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.7 2013/07/04 09:57:23 jsg Exp $	*/
d1878 1
a1878 1
	DELAY(150); /* wait for warmup */
d1881 1
a1881 1
	DELAY(150); /* wait for warmup */
d1884 1
a1884 1
	DELAY(150); /* wait for warmup */
d2045 1
a2045 1
	DELAY(200);
d2090 1
a2090 1
	DELAY(200);
d2878 1
a2878 1
	DELAY(500);
d2915 1
a2915 1
	DELAY(1000);
d2970 1
a2970 1
	DELAY(150);
d2988 1
a2988 1
	DELAY(150);
d3023 1
a3023 1
	DELAY(150);
d3069 1
a3069 1
	DELAY(150);
d3098 1
a3098 1
	DELAY(150);
d3108 1
a3108 1
		DELAY(500);
d3119 1
a3119 1
			DELAY(50);
d3151 1
a3151 1
	DELAY(150);
d3161 1
a3161 1
		DELAY(500);
d3172 1
a3172 1
			DELAY(50);
d3202 1
a3202 1
	DELAY(150);
d3231 1
a3231 1
	DELAY(150);
d3241 1
a3241 1
		DELAY(500);
d3273 1
a3273 1
	DELAY(150);
d3283 1
a3283 1
		DELAY(500);
d3319 1
a3319 1
	DELAY(200);
d3326 1
a3326 1
	DELAY(200);
d3338 1
a3338 1
			DELAY(100);
d3362 1
a3362 1
	DELAY(100);
d3370 1
a3370 1
	DELAY(100);
d3395 1
a3395 1
	DELAY(100);
d3424 1
a3424 1
	DELAY(100);
d3569 1
a3569 1
	DELAY(24);
d3795 1
a3795 1
	DELAY(150);
d3812 1
a3812 1
	DELAY(500);
d4967 1
a4967 1
	DELAY(150);
d5074 1
a5074 1
	DELAY(150);
d5090 1
a5090 1
	DELAY(150);
d5152 1
a5152 1
	DELAY(150);
d5165 1
a5165 1
	DELAY(150);
d5486 1
a5486 1
		DELAY(200);
d5503 1
a5503 1
		DELAY(200);
d5514 1
a5514 1
		DELAY(200);
d5525 1
a5525 1
		DELAY(200);
d5561 1
a5561 1
	DELAY(24);
d6288 1
a6288 1
		DELAY(150);
d6504 1
a6504 1
			DELAY(150);
d9576 1
a9576 1
	DELAY(300);
@


1.7
log
@Fixup Oops in the pipe config computation
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.6 2013/07/04 09:55:01 jsg Exp $	*/
d89 2
a90 2
void	 assert_pll(struct inteldrm_softc *, enum pipe, bool);
void	 assert_pch_pll(struct inteldrm_softc *, struct intel_pch_pll *,
d92 19
a110 19
void	 assert_fdi_tx(struct inteldrm_softc *, enum pipe, bool);
void	 assert_fdi_rx(struct inteldrm_softc *, enum pipe, bool);
void	 assert_fdi_tx_pll_enabled(struct inteldrm_softc *, enum pipe);
void	 assert_fdi_rx_pll_enabled(struct inteldrm_softc *, enum pipe);
void	 assert_panel_unlocked(struct inteldrm_softc *, enum pipe);
void	 assert_plane(struct inteldrm_softc *, enum plane, bool);
void	 assert_planes_disabled(struct inteldrm_softc *, enum pipe); 
void	 assert_pch_refclk_enabled(struct inteldrm_softc *);
void	 assert_transcoder_disabled(struct inteldrm_softc *, enum pipe);
bool	 hdmi_pipe_enabled(struct inteldrm_softc *, enum pipe, u32);
bool	 lvds_pipe_enabled(struct inteldrm_softc *, enum pipe, u32);
bool	 adpa_pipe_enabled(struct inteldrm_softc *, enum pipe, u32);
bool	 dp_pipe_enabled(struct inteldrm_softc *, enum pipe, u32, u32);
void	 assert_pch_dp_disabled(struct inteldrm_softc *, enum pipe, int, u32);
void	 assert_pch_hdmi_disabled(struct inteldrm_softc *, enum pipe, int);
void	 assert_pch_ports_disabled(struct inteldrm_softc *, enum pipe);
void	 intel_enable_pll(struct inteldrm_softc *, enum pipe);
void	 intel_disable_pll(struct inteldrm_softc *, enum pipe);
void	 intel_enable_pch_pll(struct inteldrm_softc *, enum pipe);
d112 10
a121 10
void	 intel_enable_transcoder(struct inteldrm_softc *, enum pipe);
void	 intel_disable_transcoder(struct inteldrm_softc *, enum pipe);
void	 intel_enable_pipe(struct inteldrm_softc *, enum pipe, bool);
void	 intel_disable_pipe(struct inteldrm_softc *, enum pipe);
void	 intel_flush_display_plane(struct inteldrm_softc *, enum plane);
void	 intel_enable_plane(struct inteldrm_softc *, enum plane, enum pipe);
void	 intel_disable_plane(struct inteldrm_softc *, enum plane, enum pipe);
void	 disable_pch_dp(struct inteldrm_softc *, enum pipe, int, u32);
void	 disable_pch_hdmi(struct inteldrm_softc *, enum pipe, int);
void	 intel_disable_pch_ports(struct inteldrm_softc *, enum pipe);
d133 1
a133 1
void	 intel_cancel_fbc_work(struct inteldrm_softc *);
d307 1
a307 1
void	 intel_dpio_write(struct inteldrm_softc *, int, u32);
d310 1
a310 1
bool	 is_dual_link_lvds(struct inteldrm_softc *, unsigned int);
d313 1
a313 1
void	 intel_sbi_write(struct inteldrm_softc *, u16, u32,
d315 1
a315 1
u32	 intel_sbi_read(struct inteldrm_softc *, u16,
d318 4
a321 4
void	 ironlake_enable_pch_transcoder(struct inteldrm_softc *, enum pipe);
void	 lpt_enable_pch_transcoder(struct inteldrm_softc *, enum transcoder);
void	 ironlake_disable_pch_transcoder(struct inteldrm_softc *, enum pipe);
void	 lpt_disable_pch_transcoder(struct inteldrm_softc *);
d402 1
a402 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d436 1
a436 1
		struct inteldrm_softc *dev_priv = dev->dev_private;
d736 1
a736 1
intel_dpio_read(struct inteldrm_softc *dev_priv, int reg)
d772 1
a772 1
intel_dpio_write(struct inteldrm_softc *dev_priv, int reg,
d807 1
a807 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d836 1
a836 1
is_dual_link_lvds(struct inteldrm_softc *dev_priv,
d869 1
a869 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d898 1
a898 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1039 1
a1039 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1104 1
a1104 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1290 1
a1290 1
intel_pipe_to_cpu_transcoder(struct inteldrm_softc *dev_priv,
d1302 1
a1302 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1328 1
a1328 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1383 1
a1383 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1428 1
a1428 1
assert_pll(struct inteldrm_softc *dev_priv,
d1447 1
a1447 1
assert_pch_pll(struct inteldrm_softc *dev_priv,
d1494 1
a1494 1
assert_fdi_tx(struct inteldrm_softc *dev_priv,
d1522 1
a1522 1
assert_fdi_rx(struct inteldrm_softc *dev_priv,
d1540 1
a1540 1
assert_fdi_tx_pll_enabled(struct inteldrm_softc *dev_priv,
d1561 1
a1561 1
assert_fdi_rx_pll_enabled(struct inteldrm_softc *dev_priv,
d1573 1
a1573 1
assert_panel_unlocked(struct inteldrm_softc *dev_priv,
d1604 1
a1604 1
assert_pipe(struct inteldrm_softc *dev_priv,
d1626 1
a1626 1
assert_plane(struct inteldrm_softc *dev_priv,
d1645 1
a1645 1
assert_planes_disabled(struct inteldrm_softc *dev_priv,
d1676 1
a1676 1
assert_pch_refclk_enabled(struct inteldrm_softc *dev_priv)
d1694 1
a1694 1
assert_transcoder_disabled(struct inteldrm_softc *dev_priv,
d1710 1
a1710 1
dp_pipe_enabled(struct inteldrm_softc *dev_priv,
d1731 1
a1731 1
hdmi_pipe_enabled(struct inteldrm_softc *dev_priv,
d1750 1
a1750 1
lvds_pipe_enabled(struct inteldrm_softc *dev_priv,
d1769 1
a1769 1
adpa_pipe_enabled(struct inteldrm_softc *dev_priv,
d1787 1
a1787 1
assert_pch_dp_disabled(struct inteldrm_softc *dev_priv,
d1802 1
a1802 1
assert_pch_hdmi_disabled(struct inteldrm_softc *dev_priv,
d1817 1
a1817 1
assert_pch_ports_disabled(struct inteldrm_softc *dev_priv,
d1858 1
a1858 1
intel_enable_pll(struct inteldrm_softc *dev_priv, enum pipe pipe)
d1897 1
a1897 1
intel_disable_pll(struct inteldrm_softc *dev_priv, enum pipe pipe)
d1918 1
a1918 1
intel_sbi_write(struct inteldrm_softc *dev_priv, u16 reg, u32 value,
d1959 1
a1959 1
intel_sbi_read(struct inteldrm_softc *dev_priv, u16 reg,
d2012 1
a2012 1
	struct inteldrm_softc *dev_priv = intel_crtc->base.dev->dev_private;
d2053 1
a2053 1
	struct inteldrm_softc *dev_priv = intel_crtc->base.dev->dev_private;
d2096 1
a2096 1
ironlake_enable_pch_transcoder(struct inteldrm_softc *dev_priv,
d2159 1
a2159 1
lpt_enable_pch_transcoder(struct inteldrm_softc *dev_priv,
d2197 1
a2197 1
ironlake_disable_pch_transcoder(struct inteldrm_softc *dev_priv,
d2234 1
a2234 1
lpt_disable_pch_transcoder(struct inteldrm_softc *dev_priv)
d2272 1
a2272 1
intel_enable_pipe(struct inteldrm_softc *dev_priv, enum pipe pipe,
d2325 1
a2325 1
intel_disable_pipe(struct inteldrm_softc *dev_priv,
d2358 1
a2358 1
intel_flush_display_plane(struct inteldrm_softc *dev_priv,
d2376 1
a2376 1
intel_enable_plane(struct inteldrm_softc *dev_priv,
d2405 1
a2405 1
intel_disable_plane(struct inteldrm_softc *dev_priv,
d2427 1
a2427 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2523 1
a2523 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2621 1
a2621 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2714 1
a2714 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2727 1
a2727 1
	struct inteldrm_softc *dev_priv = obj->base.dev->dev_private;
d2786 1
a2786 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2847 1
a2847 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2885 1
a2885 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2926 1
a2926 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2952 1
a2952 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3055 1
a3055 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3188 1
a3188 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3305 1
a3305 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3347 1
a3347 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3377 1
a3377 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3431 1
a3431 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3448 1
a3448 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3494 1
a3494 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3586 1
a3586 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3692 1
a3692 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3733 1
a3733 1
	struct inteldrm_softc *dev_priv = intel_crtc->base.dev->dev_private;
d3806 1
a3806 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3827 1
a3827 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3921 1
a3921 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d3999 1
a3999 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4080 1
a4080 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4156 1
a4156 1
		struct inteldrm_softc *dev_priv = dev->dev_private;
d4174 1
a4174 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4207 1
a4207 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4291 1
a4291 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4316 1
a4316 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4519 1
a4519 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4596 1
a4596 1
intel_panel_use_ssc(struct inteldrm_softc *dev_priv)
d4632 1
a4632 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4745 1
a4745 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4768 1
a4768 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4816 1
a4816 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4850 1
a4850 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d4899 1
a4899 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5006 1
a5006 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5119 1
a5119 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5181 1
a5181 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5242 1
a5242 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5417 1
a5417 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5533 1
a5533 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5719 1
a5719 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5751 1
a5751 1
	struct inteldrm_softc *dev_priv = crtc->dev->dev_private;
d5796 1
a5796 1
	struct inteldrm_softc *dev_priv = crtc->dev->dev_private;
d5825 1
a5825 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5884 1
a5884 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5904 1
a5904 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d5983 1
a5983 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6055 1
a6055 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6160 1
a6160 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6344 1
a6344 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6556 1
a6556 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6590 1
a6590 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d6618 1
a6618 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d6660 1
a6660 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d6746 1
a6746 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d6825 1
a6825 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6848 1
a6848 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6873 1
a6873 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6904 1
a6904 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6931 1
a6931 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d6959 1
a6959 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7020 1
a7020 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7253 1
a7253 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7413 1
a7413 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7502 1
a7502 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7778 1
a7778 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7823 1
a7823 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7865 1
a7865 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7914 1
a7914 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d7965 1
a7965 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d8027 1
a8027 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9050 1
a9050 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9068 1
a9068 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9345 1
a9345 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9450 1
a9450 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9462 1
a9462 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9474 1
a9474 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9558 1
a9558 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9602 1
a9602 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9695 1
a9695 1
	struct inteldrm_softc *dev_priv = crtc->base.dev->dev_private;
d9715 1
a9715 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9840 1
a9840 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9861 1
a9861 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d9988 1
a9988 1
//	struct inteldrm_softc *dev_priv = dev->dev_private;
d10066 1
a10066 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.6
log
@ensure single initialization and cleanup of backlight device
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.5 2013/04/17 20:04:04 kettenis Exp $	*/
d8344 5
a8348 10
	/* We only support modeset on one single crtc, hence we need to do that
	 * only for the passed in crtc iff we change anything else than just
	 * disable crtcs.
	 *
	 * This is actually not true, to be fully compatible with the old crtc
	 * helper we automatically disable _any_ output (i.e. doesn't need to be
	 * connected to the crtc we're modesetting on) if it's disconnected.
	 * Which is a rather nutty api (since changed the output configuration
	 * without userspace's explicit request can lead to confusion), but
	 * alas. Hence we currently need to modeset on all pipes we prepare. */
d8355 8
@


1.5
log
@Another round of reducing diffs with Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.4 2013/04/14 04:49:22 jsg Exp $	*/
d10029 3
@


1.4
log
@add some acer quirks from linux 3.8.7
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.3 2013/04/08 05:43:33 jsg Exp $	*/
d7781 1
a7781 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d7826 1
a7826 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d7868 1
a7868 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d7916 1
a7916 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d7967 1
a7967 1
	struct intel_ring_buffer *ring = &dev_priv->rings[BCS];
@


1.3
log
@Don't clobber crtc->fb when queue_flip fails
from linux 3.8.6
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.2 2013/03/19 03:58:10 jsg Exp $	*/
d9523 9
@


1.2
log
@make a few printfs debug only to reduce dmesg spam
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_display.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d8028 2
a8029 2
	struct intel_framebuffer *intel_fb;
	struct drm_i915_gem_object *obj;
d8053 1
a8053 2
	intel_fb = to_intel_framebuffer(crtc->fb);
	work->old_fb_obj = intel_fb->obj;
a8071 3
	intel_fb = to_intel_framebuffer(fb);
	obj = intel_fb->obj;

d8111 1
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d9625 1
a9625 1
	printf("%s todo set fb base\n", __func__);
@

