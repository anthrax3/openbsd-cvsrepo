head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.15
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	KnwRPOZok9A30HI4;

1.14
date	2016.04.05.21.22.02;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	HESbnwM3z1fH4IBz;

1.13
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	lQlppvmETCN49oZe;

1.12
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	adfbJ0ccUTdhFGhI;

1.11
date	2015.02.12.02.12.02;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	cYXtgYH6nnLqDRGU;

1.10
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.9;
commitid	a8Vt7gSt34kmziIS;

1.9
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.8;
commitid	OBNa5kfxQ2UXoiIw;

1.8
date	2014.02.18.02.36.49;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.21.08.43.56;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.11.02.43.20;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.07.05.33.05;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.05.07.30.06;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.07.00.04.28;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright Â© 2011-2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Ben Widawsky <ben@@bwidawsk.net>
 *
 */

/*
 * This file implements HW context support. On gen5+ a HW context consists of an
 * opaque GPU object which is referenced at times of context saves and restores.
 * With RC6 enabled, the context is also referenced as the GPU enters and exists
 * from RC6 (GPU has it's own internal power context, except on gen5). Though
 * something like a context does exist for the media ring, the code only
 * supports contexts for the render ring.
 *
 * In software, there is a distinction between contexts created by the user,
 * and the default HW context. The default HW context is used by GPU clients
 * that do not request setup of their own hardware context. The default
 * context's state is never restored to help prevent programming errors. This
 * would happen if a client ran and piggy-backed off another clients GPU state.
 * The default context only exists to give the GPU some offset to load as the
 * current to invoke a save of the context we actually care about. In fact, the
 * code could likely be constructed, albeit in a more complicated fashion, to
 * never use the default context, though that limits the driver's ability to
 * swap out, and/or destroy other contexts.
 *
 * All other contexts are created as a request by the GPU client. These contexts
 * store GPU state, and thus allow GPU clients to not re-emit state (and
 * potentially query certain state) at any time. The kernel driver makes
 * certain that the appropriate commands are inserted.
 *
 * The context life cycle is semi-complicated in that context BOs may live
 * longer than the context itself because of the way the hardware, and object
 * tracking works. Below is a very crude representation of the state machine
 * describing the context life.
 *                                         refcount     pincount     active
 * S0: initial state                          0            0           0
 * S1: context created                        1            0           0
 * S2: context is currently running           2            1           X
 * S3: GPU referenced, but not current        2            0           1
 * S4: context is current, but destroyed      1            1           0
 * S5: like S3, but destroyed                 1            0           1
 *
 * The most common (but not all) transitions:
 * S0->S1: client creates a context
 * S1->S2: client submits execbuf with context
 * S2->S3: other clients submits execbuf with context
 * S3->S1: context object was retired
 * S3->S2: clients submits another execbuf
 * S2->S4: context destroy called with current context
 * S3->S5->S0: destroy path
 * S4->S5->S0: destroy path on current context
 *
 * There are two confusing terms used above:
 *  The "current context" means the context which is currently running on the
 *  GPU. The GPU has loaded its state already and has stored away the gtt
 *  offset of the BO. The GPU is not actively referencing the data at this
 *  offset, but it will on the next context switch. The only way to avoid this
 *  is to do a GPU reset.
 *
 *  An "active context' is one which was previously the "current context" and is
 *  on the active list waiting for the next context switch to occur. Until this
 *  happens, the object must remain at the same gtt offset. It is therefore
 *  possible to destroy a context, but it is still active.
 *
 */

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#include "i915_trace.h"

/* This is a HW constraint. The value below is the largest known requirement
 * I've seen in a spec to date, and that was a workaround for a non-shipping
 * part. It should be safe to decrease this, but it's more future proof as is.
 */
#define GEN6_CONTEXT_ALIGN (64<<10)
#define GEN7_CONTEXT_ALIGN 4096

static size_t get_context_alignment(struct drm_device *dev)
{
	if (IS_GEN6(dev))
		return GEN6_CONTEXT_ALIGN;

	return GEN7_CONTEXT_ALIGN;
}

static int get_context_size(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;
	u32 reg;

	switch (INTEL_INFO(dev)->gen) {
	case 6:
		reg = I915_READ(CXT_SIZE);
		ret = GEN6_CXT_TOTAL_SIZE(reg) * 64;
		break;
	case 7:
		reg = I915_READ(GEN7_CXT_SIZE);
		if (IS_HASWELL(dev))
			ret = HSW_CXT_TOTAL_SIZE;
		else
			ret = GEN7_CXT_TOTAL_SIZE(reg) * 64;
		break;
	case 8:
		ret = GEN8_CXT_TOTAL_SIZE;
		break;
	default:
		BUG();
	}

	return ret;
}

static void i915_gem_context_clean(struct intel_context *ctx)
{
	struct i915_hw_ppgtt *ppgtt = ctx->ppgtt;
	struct i915_vma *vma, *next;

	if (!ppgtt)
		return;

	list_for_each_entry_safe(vma, next, &ppgtt->base.inactive_list,
				 mm_list) {
		if (WARN_ON(__i915_vma_unbind_no_wait(vma)))
			break;
	}
}

void i915_gem_context_free(struct kref *ctx_ref)
{
	struct intel_context *ctx = container_of(ctx_ref, typeof(*ctx), ref);

	trace_i915_context_free(ctx);

	if (i915.enable_execlists)
		intel_lr_context_free(ctx);

	/*
	 * This context is going away and we need to remove all VMAs still
	 * around. This is to handle imported shared objects for which
	 * destructor did not run when their handles were closed.
	 */
	i915_gem_context_clean(ctx);

	i915_ppgtt_put(ctx->ppgtt);

	if (ctx->legacy_hw_ctx.rcs_state)
		drm_gem_object_unreference(&ctx->legacy_hw_ctx.rcs_state->base);
	list_del(&ctx->link);
	kfree(ctx);
}

struct drm_i915_gem_object *
i915_gem_alloc_context_obj(struct drm_device *dev, size_t size)
{
	struct drm_i915_gem_object *obj;
	int ret;

	obj = i915_gem_alloc_object(dev, size);
	if (obj == NULL)
		return ERR_PTR(-ENOMEM);

	/*
	 * Try to make the context utilize L3 as well as LLC.
	 *
	 * On VLV we don't have L3 controls in the PTEs so we
	 * shouldn't touch the cache level, especially as that
	 * would make the object snooped which might have a
	 * negative performance impact.
	 */
	if (INTEL_INFO(dev)->gen >= 7 && !IS_VALLEYVIEW(dev)) {
		ret = i915_gem_object_set_cache_level(obj, I915_CACHE_L3_LLC);
		/* Failure shouldn't ever happen this early */
		if (WARN_ON(ret)) {
			drm_gem_object_unreference(&obj->base);
			return ERR_PTR(ret);
		}
	}

	return obj;
}

static struct intel_context *
__create_hw_context(struct drm_device *dev,
		    struct drm_i915_file_private *file_priv)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_context *ctx;
	int ret;

	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
	if (ctx == NULL)
		return ERR_PTR(-ENOMEM);

	kref_init(&ctx->ref);
	list_add_tail(&ctx->link, &dev_priv->context_list);
	ctx->i915 = dev_priv;

	if (dev_priv->hw_context_size) {
		struct drm_i915_gem_object *obj =
				i915_gem_alloc_context_obj(dev, dev_priv->hw_context_size);
		if (IS_ERR(obj)) {
			ret = PTR_ERR(obj);
			goto err_out;
		}
		ctx->legacy_hw_ctx.rcs_state = obj;
	}

	/* Default context will never have a file_priv */
	if (file_priv != NULL) {
		ret = idr_alloc(&file_priv->context_idr, ctx,
				DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
		if (ret < 0)
			goto err_out;
	} else
		ret = DEFAULT_CONTEXT_HANDLE;

	ctx->file_priv = file_priv;
	ctx->user_handle = ret;
	/* NB: Mark all slices as needing a remap so that when the context first
	 * loads it will restore whatever remap state already exists. If there
	 * is no remap info, it will be a NOP. */
	ctx->remap_slice = (1 << NUM_L3_SLICES(dev)) - 1;

	ctx->hang_stats.ban_period_seconds = DRM_I915_CTX_BAN_PERIOD;

	return ctx;

err_out:
	i915_gem_context_unreference(ctx);
	return ERR_PTR(ret);
}

/**
 * The default context needs to exist per ring that uses contexts. It stores the
 * context state of the GPU for applications that don't utilize HW contexts, as
 * well as an idle case.
 */
static struct intel_context *
i915_gem_create_context(struct drm_device *dev,
			struct drm_i915_file_private *file_priv)
{
	const bool is_global_default_ctx = file_priv == NULL;
	struct intel_context *ctx;
	int ret = 0;

	BUG_ON(!mutex_is_locked(&dev->struct_mutex));

	ctx = __create_hw_context(dev, file_priv);
	if (IS_ERR(ctx))
		return ctx;

	if (is_global_default_ctx && ctx->legacy_hw_ctx.rcs_state) {
		/* We may need to do things with the shrinker which
		 * require us to immediately switch back to the default
		 * context. This can cause a problem as pinning the
		 * default context also requires GTT space which may not
		 * be available. To avoid this we always pin the default
		 * context.
		 */
		ret = i915_gem_obj_ggtt_pin(ctx->legacy_hw_ctx.rcs_state,
					    get_context_alignment(dev), 0);
		if (ret) {
			DRM_DEBUG_DRIVER("Couldn't pin %d\n", ret);
			goto err_destroy;
		}
	}

	if (USES_FULL_PPGTT(dev)) {
		struct i915_hw_ppgtt *ppgtt = i915_ppgtt_create(dev, file_priv);

		if (IS_ERR_OR_NULL(ppgtt)) {
			DRM_DEBUG_DRIVER("PPGTT setup failed (%ld)\n",
					 PTR_ERR(ppgtt));
			ret = PTR_ERR(ppgtt);
			goto err_unpin;
		}

		ctx->ppgtt = ppgtt;
	}

	trace_i915_context_create(ctx);

	return ctx;

err_unpin:
	if (is_global_default_ctx && ctx->legacy_hw_ctx.rcs_state)
		i915_gem_object_ggtt_unpin(ctx->legacy_hw_ctx.rcs_state);
err_destroy:
	idr_remove(&file_priv->context_idr, ctx->user_handle);
	i915_gem_context_unreference(ctx);
	return ERR_PTR(ret);
}

void i915_gem_context_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	if (i915.enable_execlists) {
		struct intel_context *ctx;

		list_for_each_entry(ctx, &dev_priv->context_list, link) {
			intel_lr_context_reset(dev, ctx);
		}

		return;
	}

	for (i = 0; i < I915_NUM_RINGS; i++) {
		struct intel_engine_cs *ring = &dev_priv->ring[i];
		struct intel_context *lctx = ring->last_context;

		if (lctx) {
			if (lctx->legacy_hw_ctx.rcs_state && i == RCS)
				i915_gem_object_ggtt_unpin(lctx->legacy_hw_ctx.rcs_state);

			i915_gem_context_unreference(lctx);
			ring->last_context = NULL;
		}

		/* Force the GPU state to be reinitialised on enabling */
		if (ring->default_context)
			ring->default_context->legacy_hw_ctx.initialized = false;
	}
}

int i915_gem_context_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_context *ctx;
	int i;

	/* Init should only be called once per module load. Eventually the
	 * restriction on the context_disabled check can be loosened. */
	if (WARN_ON(dev_priv->ring[RCS].default_context))
		return 0;

	if (intel_vgpu_active(dev) && HAS_LOGICAL_RING_CONTEXTS(dev)) {
		if (!i915.enable_execlists) {
			DRM_INFO("Only EXECLIST mode is supported in vgpu.\n");
			return -EINVAL;
		}
	}

	if (i915.enable_execlists) {
		/* NB: intentionally left blank. We will allocate our own
		 * backing objects as we need them, thank you very much */
		dev_priv->hw_context_size = 0;
	} else if (HAS_HW_CONTEXTS(dev)) {
		dev_priv->hw_context_size = round_up(get_context_size(dev), 4096);
		if (dev_priv->hw_context_size > (1<<20)) {
			DRM_DEBUG_DRIVER("Disabling HW Contexts; invalid size %d\n",
					 dev_priv->hw_context_size);
			dev_priv->hw_context_size = 0;
		}
	}

	ctx = i915_gem_create_context(dev, NULL);
	if (IS_ERR(ctx)) {
		DRM_ERROR("Failed to create default global context (error %ld)\n",
			  PTR_ERR(ctx));
		return PTR_ERR(ctx);
	}

	for (i = 0; i < I915_NUM_RINGS; i++) {
		struct intel_engine_cs *ring = &dev_priv->ring[i];

		/* NB: RCS will hold a ref for all rings */
		ring->default_context = ctx;
	}

	DRM_DEBUG_DRIVER("%s context support initialized\n",
			i915.enable_execlists ? "LR" :
			dev_priv->hw_context_size ? "HW" : "fake");
	return 0;
}

void i915_gem_context_fini(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_context *dctx = dev_priv->ring[RCS].default_context;
	int i;

	if (dctx->legacy_hw_ctx.rcs_state) {
		/* The only known way to stop the gpu from accessing the hw context is
		 * to reset it. Do this as the very last operation to avoid confusing
		 * other code, leading to spurious errors. */
		intel_gpu_reset(dev);

		/* When default context is created and switched to, base object refcount
		 * will be 2 (+1 from object creation and +1 from do_switch()).
		 * i915_gem_context_fini() will be called after gpu_idle() has switched
		 * to default context. So we need to unreference the base object once
		 * to offset the do_switch part, so that i915_gem_context_unreference()
		 * can then free the base object correctly. */
		WARN_ON(!dev_priv->ring[RCS].last_context);
		if (dev_priv->ring[RCS].last_context == dctx) {
			/* Fake switch to NULL context */
			WARN_ON(dctx->legacy_hw_ctx.rcs_state->active);
			i915_gem_object_ggtt_unpin(dctx->legacy_hw_ctx.rcs_state);
			i915_gem_context_unreference(dctx);
			dev_priv->ring[RCS].last_context = NULL;
		}

		i915_gem_object_ggtt_unpin(dctx->legacy_hw_ctx.rcs_state);
	}

	for (i = 0; i < I915_NUM_RINGS; i++) {
		struct intel_engine_cs *ring = &dev_priv->ring[i];

		if (ring->last_context)
			i915_gem_context_unreference(ring->last_context);

		ring->default_context = NULL;
		ring->last_context = NULL;
	}

	i915_gem_context_unreference(dctx);
}

int i915_gem_context_enable(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	if (i915.enable_execlists) {
		if (ring->init_context == NULL)
			return 0;

		ret = ring->init_context(req);
	} else
		ret = i915_switch_context(req);

	if (ret) {
		DRM_ERROR("ring init context: %d\n", ret);
		return ret;
	}

	return 0;
}

static int context_idr_cleanup(int id, void *p, void *data)
{
	struct intel_context *ctx = p;

	i915_gem_context_unreference(ctx);
	return 0;
}

int i915_gem_context_open(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct intel_context *ctx;

	idr_init(&file_priv->context_idr);

	mutex_lock(&dev->struct_mutex);
	ctx = i915_gem_create_context(dev, file_priv);
	mutex_unlock(&dev->struct_mutex);

	if (IS_ERR(ctx)) {
		idr_destroy(&file_priv->context_idr);
		return PTR_ERR(ctx);
	}

	return 0;
}

void i915_gem_context_close(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;

	idr_for_each(&file_priv->context_idr, context_idr_cleanup, NULL);
	idr_destroy(&file_priv->context_idr);
}

struct intel_context *
i915_gem_context_get(struct drm_i915_file_private *file_priv, u32 id)
{
	struct intel_context *ctx;

	ctx = (struct intel_context *)idr_find(&file_priv->context_idr, id);
	if (!ctx)
		return ERR_PTR(-ENOENT);

	return ctx;
}

static inline int
mi_set_context(struct drm_i915_gem_request *req, u32 hw_flags)
{
	struct intel_engine_cs *ring = req->ring;
	u32 flags = hw_flags | MI_MM_SPACE_GTT;
	const int num_rings =
		/* Use an extended w/a on ivb+ if signalling from other rings */
		i915_semaphore_is_enabled(ring->dev) ?
		hweight32(INTEL_INFO(ring->dev)->ring_mask) - 1 :
		0;
	int len, i, ret;

	/* w/a: If Flush TLB Invalidation Mode is enabled, driver must do a TLB
	 * invalidation prior to MI_SET_CONTEXT. On GEN6 we don't set the value
	 * explicitly, so we rely on the value at ring init, stored in
	 * itlb_before_ctx_switch.
	 */
	if (IS_GEN6(ring->dev)) {
		ret = ring->flush(req, I915_GEM_GPU_DOMAINS, 0);
		if (ret)
			return ret;
	}

	/* These flags are for resource streamer on HSW+ */
	if (IS_HASWELL(ring->dev) || INTEL_INFO(ring->dev)->gen >= 8)
		flags |= (HSW_MI_RS_SAVE_STATE_EN | HSW_MI_RS_RESTORE_STATE_EN);
	else if (INTEL_INFO(ring->dev)->gen < 8)
		flags |= (MI_SAVE_EXT_STATE_EN | MI_RESTORE_EXT_STATE_EN);


	len = 4;
	if (INTEL_INFO(ring->dev)->gen >= 7)
		len += 2 + (num_rings ? 4*num_rings + 2 : 0);

	ret = intel_ring_begin(req, len);
	if (ret)
		return ret;

	/* WaProgramMiArbOnOffAroundMiSetContext:ivb,vlv,hsw,bdw,chv */
	if (INTEL_INFO(ring->dev)->gen >= 7) {
		intel_ring_emit(ring, MI_ARB_ON_OFF | MI_ARB_DISABLE);
		if (num_rings) {
			struct intel_engine_cs *signaller;

			intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(num_rings));
			for_each_ring(signaller, to_i915(ring->dev), i) {
				if (signaller == ring)
					continue;

				intel_ring_emit(ring, RING_PSMI_CTL(signaller->mmio_base));
				intel_ring_emit(ring, _MASKED_BIT_ENABLE(GEN6_PSMI_SLEEP_MSG_DISABLE));
			}
		}
	}

	intel_ring_emit(ring, MI_NOOP);
	intel_ring_emit(ring, MI_SET_CONTEXT);
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(req->ctx->legacy_hw_ctx.rcs_state) |
			flags);
	/*
	 * w/a: MI_SET_CONTEXT must always be followed by MI_NOOP
	 * WaMiSetContext_Hang:snb,ivb,vlv
	 */
	intel_ring_emit(ring, MI_NOOP);

	if (INTEL_INFO(ring->dev)->gen >= 7) {
		if (num_rings) {
			struct intel_engine_cs *signaller;

			intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(num_rings));
			for_each_ring(signaller, to_i915(ring->dev), i) {
				if (signaller == ring)
					continue;

				intel_ring_emit(ring, RING_PSMI_CTL(signaller->mmio_base));
				intel_ring_emit(ring, _MASKED_BIT_DISABLE(GEN6_PSMI_SLEEP_MSG_DISABLE));
			}
		}
		intel_ring_emit(ring, MI_ARB_ON_OFF | MI_ARB_ENABLE);
	}

	intel_ring_advance(ring);

	return ret;
}

static inline bool should_skip_switch(struct intel_engine_cs *ring,
				      struct intel_context *from,
				      struct intel_context *to)
{
	if (to->remap_slice)
		return false;

	if (to->ppgtt && from == to &&
	    !(intel_ring_flag(ring) & to->ppgtt->pd_dirty_rings))
		return true;

	return false;
}

static bool
needs_pd_load_pre(struct intel_engine_cs *ring, struct intel_context *to)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	if (!to->ppgtt)
		return false;

	if (INTEL_INFO(ring->dev)->gen < 8)
		return true;

	if (ring != &dev_priv->ring[RCS])
		return true;

	return false;
}

static bool
needs_pd_load_post(struct intel_engine_cs *ring, struct intel_context *to,
		u32 hw_flags)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	if (!to->ppgtt)
		return false;

	if (!IS_GEN8(ring->dev))
		return false;

	if (ring != &dev_priv->ring[RCS])
		return false;

	if (hw_flags & MI_RESTORE_INHIBIT)
		return true;

	return false;
}

static int do_switch(struct drm_i915_gem_request *req)
{
	struct intel_context *to = req->ctx;
	struct intel_engine_cs *ring = req->ring;
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	struct intel_context *from = ring->last_context;
	u32 hw_flags = 0;
	bool uninitialized = false;
	int ret, i;

	if (from != NULL && ring == &dev_priv->ring[RCS]) {
		BUG_ON(from->legacy_hw_ctx.rcs_state == NULL);
		BUG_ON(!i915_gem_obj_is_pinned(from->legacy_hw_ctx.rcs_state));
	}

	if (should_skip_switch(ring, from, to))
		return 0;

	/* Trying to pin first makes error handling easier. */
	if (ring == &dev_priv->ring[RCS]) {
		ret = i915_gem_obj_ggtt_pin(to->legacy_hw_ctx.rcs_state,
					    get_context_alignment(ring->dev), 0);
		if (ret)
			return ret;
	}

	/*
	 * Pin can switch back to the default context if we end up calling into
	 * evict_everything - as a last ditch gtt defrag effort that also
	 * switches to the default context. Hence we need to reload from here.
	 */
	from = ring->last_context;

	if (needs_pd_load_pre(ring, to)) {
		/* Older GENs and non render rings still want the load first,
		 * "PP_DCLV followed by PP_DIR_BASE register through Load
		 * Register Immediate commands in Ring Buffer before submitting
		 * a context."*/
		trace_switch_mm(ring, to);
		ret = to->ppgtt->switch_mm(to->ppgtt, req);
		if (ret)
			goto unpin_out;

		/* Doing a PD load always reloads the page dirs */
		to->ppgtt->pd_dirty_rings &= ~intel_ring_flag(ring);
	}

	if (ring != &dev_priv->ring[RCS]) {
		if (from)
			i915_gem_context_unreference(from);
		goto done;
	}

	/*
	 * Clear this page out of any CPU caches for coherent swap-in/out. Note
	 * that thanks to write = false in this call and us not setting any gpu
	 * write domains when putting a context object onto the active list
	 * (when switching away from it), this won't block.
	 *
	 * XXX: We need a real interface to do this instead of trickery.
	 */
	ret = i915_gem_object_set_to_gtt_domain(to->legacy_hw_ctx.rcs_state, false);
	if (ret)
		goto unpin_out;

	if (!to->legacy_hw_ctx.initialized || i915_gem_context_is_default(to)) {
		hw_flags |= MI_RESTORE_INHIBIT;
		/* NB: If we inhibit the restore, the context is not allowed to
		 * die because future work may end up depending on valid address
		 * space. This means we must enforce that a page table load
		 * occur when this occurs. */
	} else if (to->ppgtt &&
		   (intel_ring_flag(ring) & to->ppgtt->pd_dirty_rings)) {
		hw_flags |= MI_FORCE_RESTORE;
		to->ppgtt->pd_dirty_rings &= ~intel_ring_flag(ring);
	}

	/* We should never emit switch_mm more than once */
	WARN_ON(needs_pd_load_pre(ring, to) &&
		needs_pd_load_post(ring, to, hw_flags));

	ret = mi_set_context(req, hw_flags);
	if (ret)
		goto unpin_out;

	/* GEN8 does *not* require an explicit reload if the PDPs have been
	 * setup, and we do not wish to move them.
	 */
	if (needs_pd_load_post(ring, to, hw_flags)) {
		trace_switch_mm(ring, to);
		ret = to->ppgtt->switch_mm(to->ppgtt, req);
		/* The hardware context switch is emitted, but we haven't
		 * actually changed the state - so it's probably safe to bail
		 * here. Still, let the user know something dangerous has
		 * happened.
		 */
		if (ret) {
			DRM_ERROR("Failed to change address space on context switch\n");
			goto unpin_out;
		}
	}

	for (i = 0; i < MAX_L3_SLICES; i++) {
		if (!(to->remap_slice & (1<<i)))
			continue;

		ret = i915_gem_l3_remap(req, i);
		/* If it failed, try again next round */
		if (ret)
			DRM_DEBUG_DRIVER("L3 remapping failed\n");
		else
			to->remap_slice &= ~(1<<i);
	}

	/* The backing object for the context is done after switching to the
	 * *next* context. Therefore we cannot retire the previous context until
	 * the next context has already started running. In fact, the below code
	 * is a bit suboptimal because the retiring can occur simply after the
	 * MI_SET_CONTEXT instead of when the next seqno has completed.
	 */
	if (from != NULL) {
		from->legacy_hw_ctx.rcs_state->base.read_domains = I915_GEM_DOMAIN_INSTRUCTION;
		i915_vma_move_to_active(i915_gem_obj_to_ggtt(from->legacy_hw_ctx.rcs_state), req);
		/* As long as MI_SET_CONTEXT is serializing, ie. it flushes the
		 * whole damn pipeline, we don't need to explicitly mark the
		 * object dirty. The only exception is that the context must be
		 * correct in case the object gets swapped out. Ideally we'd be
		 * able to defer doing this until we know the object would be
		 * swapped, but there is no way to do that yet.
		 */
		from->legacy_hw_ctx.rcs_state->dirty = 1;

		/* obj is kept alive until the next request by its active ref */
		i915_gem_object_ggtt_unpin(from->legacy_hw_ctx.rcs_state);
		i915_gem_context_unreference(from);
	}

	uninitialized = !to->legacy_hw_ctx.initialized;
	to->legacy_hw_ctx.initialized = true;

done:
	i915_gem_context_reference(to);
	ring->last_context = to;

	if (uninitialized) {
		if (ring->init_context) {
			ret = ring->init_context(req);
			if (ret)
				DRM_ERROR("ring init context: %d\n", ret);
		}
	}

	return 0;

unpin_out:
	if (ring->id == RCS)
		i915_gem_object_ggtt_unpin(to->legacy_hw_ctx.rcs_state);
	return ret;
}

/**
 * i915_switch_context() - perform a GPU context switch.
 * @@req: request for which we'll execute the context switch
 *
 * The context life cycle is simple. The context refcount is incremented and
 * decremented by 1 and create and destroy. If the context is in use by the GPU,
 * it will have a refcount > 1. This allows us to destroy the context abstract
 * object while letting the normal object tracking destroy the backing BO.
 *
 * This function should not be used in execlists mode.  Instead the context is
 * switched by writing to the ELSP and requests keep a reference to their
 * context.
 */
int i915_switch_context(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	WARN_ON(i915.enable_execlists);
	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));

	if (req->ctx->legacy_hw_ctx.rcs_state == NULL) { /* We have the fake context */
		if (req->ctx != ring->last_context) {
			i915_gem_context_reference(req->ctx);
			if (ring->last_context)
				i915_gem_context_unreference(ring->last_context);
			ring->last_context = req->ctx;
		}
		return 0;
	}

	return do_switch(req);
}

static bool contexts_enabled(struct drm_device *dev)
{
	return i915.enable_execlists || to_i915(dev)->hw_context_size;
}

int i915_gem_context_create_ioctl(struct drm_device *dev, void *data,
				  struct drm_file *file)
{
	struct drm_i915_gem_context_create *args = data;
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct intel_context *ctx;
	int ret;

	if (!contexts_enabled(dev))
		return -ENODEV;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = i915_gem_create_context(dev, file_priv);
	mutex_unlock(&dev->struct_mutex);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	args->ctx_id = ctx->user_handle;
	DRM_DEBUG_DRIVER("HW context %d created\n", args->ctx_id);

	return 0;
}

int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,
				   struct drm_file *file)
{
	struct drm_i915_gem_context_destroy *args = data;
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct intel_context *ctx;
	int ret;

	if (args->ctx_id == DEFAULT_CONTEXT_HANDLE)
		return -ENOENT;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = i915_gem_context_get(file_priv, args->ctx_id);
	if (IS_ERR(ctx)) {
		mutex_unlock(&dev->struct_mutex);
		return PTR_ERR(ctx);
	}

	idr_remove(&ctx->file_priv->context_idr, ctx->user_handle);
	i915_gem_context_unreference(ctx);
	mutex_unlock(&dev->struct_mutex);

	DRM_DEBUG_DRIVER("HW context %d destroyed\n", args->ctx_id);
	return 0;
}

int i915_gem_context_getparam_ioctl(struct drm_device *dev, void *data,
				    struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct drm_i915_gem_context_param *args = data;
	struct intel_context *ctx;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = i915_gem_context_get(file_priv, args->ctx_id);
	if (IS_ERR(ctx)) {
		mutex_unlock(&dev->struct_mutex);
		return PTR_ERR(ctx);
	}

	args->size = 0;
	switch (args->param) {
	case I915_CONTEXT_PARAM_BAN_PERIOD:
		args->value = ctx->hang_stats.ban_period_seconds;
		break;
	case I915_CONTEXT_PARAM_NO_ZEROMAP:
		args->value = ctx->flags & CONTEXT_NO_ZEROMAP;
		break;
	default:
		ret = -EINVAL;
		break;
	}
	mutex_unlock(&dev->struct_mutex);

	return ret;
}

int i915_gem_context_setparam_ioctl(struct drm_device *dev, void *data,
				    struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct drm_i915_gem_context_param *args = data;
	struct intel_context *ctx;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = i915_gem_context_get(file_priv, args->ctx_id);
	if (IS_ERR(ctx)) {
		mutex_unlock(&dev->struct_mutex);
		return PTR_ERR(ctx);
	}

	switch (args->param) {
	case I915_CONTEXT_PARAM_BAN_PERIOD:
		if (args->size)
			ret = -EINVAL;
		else if (args->value < ctx->hang_stats.ban_period_seconds &&
			 !capable(CAP_SYS_ADMIN))
			ret = -EPERM;
		else
			ctx->hang_stats.ban_period_seconds = args->value;
		break;
	case I915_CONTEXT_PARAM_NO_ZEROMAP:
		if (args->size) {
			ret = -EINVAL;
		} else {
			ctx->flags &= ~CONTEXT_NO_ZEROMAP;
			ctx->flags |= args->value ? CONTEXT_NO_ZEROMAP : 0;
		}
		break;
	default:
		ret = -EINVAL;
		break;
	}
	mutex_unlock(&dev->struct_mutex);

	return ret;
}
@


1.14
log
@Use the "idr" API here as well, reducing the diffs to Linux.
@
text
@a0 1
/*	$OpenBSD: i915_gem_context.c,v 1.13 2015/09/23 23:12:12 kettenis Exp $	*/
d91 1
d97 2
a98 1
#define CONTEXT_ALIGN (64<<10)
d100 7
a106 3
static struct i915_hw_context *
i915_gem_context_get(struct drm_i915_file_private *file_priv, u32 id);
static int do_switch(struct i915_hw_context *to);
d136 15
d153 13
a165 2
	struct i915_hw_context *ctx = container_of(ctx_ref,
						   typeof(*ctx), ref);
d167 4
a171 1
	drm_gem_object_unreference(&ctx->obj->base);
d175 33
a207 3
static struct i915_hw_context *
create_hw_context(struct drm_device *dev,
		  struct drm_i915_file_private *file_priv)
d210 1
a210 1
	struct i915_hw_context *ctx;
d218 2
a219 7
	ctx->obj = i915_gem_alloc_object(dev, dev_priv->hw_context_size);
	INIT_LIST_HEAD(&ctx->link);
	if (ctx->obj == NULL) {
		kfree(ctx);
		DRM_DEBUG_DRIVER("Context object allocated failed\n");
		return ERR_PTR(-ENOMEM);
	}
d221 5
a225 5
	if (INTEL_INFO(dev)->gen >= 7) {
		ret = i915_gem_object_set_cache_level(ctx->obj,
						      I915_CACHE_L3_LLC);
		/* Failure shouldn't ever happen this early */
		if (WARN_ON(ret))
d227 2
a230 7
	/* The ring associated with the context object is handled by the normal
	 * object tracking code. We give an initial ring value simple to pass an
	 * assertion in the context switch code.
	 */
	ctx->ring = &dev_priv->ring[RCS];
	list_add_tail(&ctx->link, &dev_priv->context_list);

d232 7
a238 7
	if (file_priv == NULL)
		return ctx;

	ret = idr_alloc(&file_priv->context_idr, ctx, DEFAULT_CONTEXT_ID + 1, 0,
			GFP_KERNEL);
	if (ret < 0)
		goto err_out;
d241 1
a241 1
	ctx->id = ret;
d247 2
a255 5
static inline bool is_default_context(struct i915_hw_context *ctx)
{
	return (ctx == ctx->ring->default_context);
}

d261 3
a263 1
static int create_default_context(struct drm_i915_private *dev_priv)
d265 3
a267 2
	struct i915_hw_context *ctx;
	int ret;
d269 1
a269 1
	BUG_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));
d271 1
a271 1
	ctx = create_hw_context(dev_priv->dev, NULL);
d273 1
a273 1
		return PTR_ERR(ctx);
d275 14
a288 10
	/* We may need to do things with the shrinker which require us to
	 * immediately switch back to the default context. This can cause a
	 * problem as pinning the default context also requires GTT space which
	 * may not be available. To avoid this we always pin the
	 * default context.
	 */
	ret = i915_gem_obj_ggtt_pin(ctx->obj, CONTEXT_ALIGN, false, false);
	if (ret) {
		DRM_DEBUG_DRIVER("Couldn't pin %d\n", ret);
		goto err_destroy;
d291 11
a301 4
	ret = do_switch(ctx);
	if (ret) {
		DRM_DEBUG_DRIVER("Switch failed %d\n", ret);
		goto err_unpin;
d304 1
a304 1
	dev_priv->ring[RCS].default_context = ctx;
d306 1
a306 2
	DRM_DEBUG_DRIVER("Default HW context loaded\n");
	return 0;
d309 2
a310 1
	i915_gem_object_unpin(ctx->obj);
d312 1
d314 34
a347 1
	return ret;
d353 2
a354 1
	int ret;
d356 3
a358 1
	if (!HAS_HW_CONTEXTS(dev))
d361 6
a366 3
	/* If called from reset, or thaw... we've been here already */
	if (dev_priv->ring[RCS].default_context)
		return 0;
d368 19
a386 1
	dev_priv->hw_context_size = round_up(get_context_size(dev), 4096);
d388 2
a389 4
	if (dev_priv->hw_context_size > (1<<20)) {
		DRM_DEBUG_DRIVER("Disabling HW Contexts; invalid size\n");
		return -E2BIG;
	}
d391 2
a392 5
	ret = create_default_context(dev_priv);
	if (ret) {
		DRM_DEBUG_DRIVER("Disabling HW Contexts; create failed %d\n",
				 ret);
		return ret;
d395 3
a397 1
	DRM_DEBUG_DRIVER("HW context support initialized\n");
d404 29
a432 1
	struct i915_hw_context *dctx = dev_priv->ring[RCS].default_context;
d434 2
a435 2
	if (!HAS_HW_CONTEXTS(dev))
		return;
d437 2
a438 17
	/* The only known way to stop the gpu from accessing the hw context is
	 * to reset it. Do this as the very last operation to avoid confusing
	 * other code, leading to spurious errors. */
	intel_gpu_reset(dev);

	/* When default context is created and switched to, base object refcount
	 * will be 2 (+1 from object creation and +1 from do_switch()).
	 * i915_gem_context_fini() will be called after gpu_idle() has switched
	 * to default context. So we need to unreference the base object once
	 * to offset the do_switch part, so that i915_gem_context_unreference()
	 * can then free the base object correctly. */
	WARN_ON(!dev_priv->ring[RCS].last_context);
	if (dev_priv->ring[RCS].last_context == dctx) {
		/* Fake switch to NULL context */
		WARN_ON(dctx->obj->active);
		i915_gem_object_unpin(dctx->obj);
		i915_gem_context_unreference(dctx);
a440 1
	i915_gem_object_unpin(dctx->obj);
d442 21
a462 2
	dev_priv->ring[RCS].default_context = NULL;
	dev_priv->ring[RCS].last_context = NULL;
d467 1
a467 3
	struct i915_hw_context *ctx = p;

	BUG_ON(id == DEFAULT_CONTEXT_ID);
d473 1
a473 4
struct i915_ctx_hang_stats *
i915_gem_context_get_hang_stats(struct drm_device *dev,
				struct drm_file *file,
				u32 id)
d476 1
a476 1
	struct i915_hw_context *ctx;
d478 1
a478 2
	if (id == DEFAULT_CONTEXT_ID)
		return &file_priv->hang_stats;
d480 3
a482 2
	if (!HAS_HW_CONTEXTS(dev))
		return ERR_PTR(-ENOENT);
d484 4
a487 3
	ctx = i915_gem_context_get(file->driver_priv, id);
	if (ctx == NULL)
		return ERR_PTR(-ENOENT);
d489 1
a489 1
	return &ctx->hang_stats;
d500 1
a500 1
static struct i915_hw_context *
d503 7
a509 1
	return (struct i915_hw_context *)idr_find(&file_priv->context_idr, id);
d513 1
a513 3
mi_set_context(struct intel_ring_buffer *ring,
	       struct i915_hw_context *new_context,
	       u32 hw_flags)
d515 8
a522 1
	int ret;
d529 2
a530 2
	if (IS_GEN6(ring->dev) && ring->itlb_before_ctx_switch) {
		ret = ring->flush(ring, I915_GEM_GPU_DOMAINS, 0);
d535 12
a546 1
	ret = intel_ring_begin(ring, 6);
d550 2
a551 2
	/* WaProgramMiArbOnOffAroundMiSetContext:ivb,vlv,hsw */
	if (IS_GEN7(ring->dev))
d553 13
a565 2
	else
		intel_ring_emit(ring, MI_NOOP);
d569 6
a574 6
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(new_context->obj) |
			MI_MM_SPACE_GTT |
			MI_SAVE_EXT_STATE_EN |
			MI_RESTORE_EXT_STATE_EN |
			hw_flags);
	/* w/a: MI_SET_CONTEXT must always be followed by MI_NOOP */
d577 13
a589 1
	if (IS_GEN7(ring->dev))
d591 1
a591 2
	else
		intel_ring_emit(ring, MI_NOOP);
d598 16
a613 1
static int do_switch(struct i915_hw_context *to)
d615 41
a655 2
	struct intel_ring_buffer *ring = to->ring;
	struct i915_hw_context *from = ring->last_context;
d657 1
d660 4
a663 1
	BUG_ON(from != NULL && from->obj != NULL && from->obj->pin_count == 0);
d665 1
a665 1
	if (from == to && !to->remap_slice)
d668 7
a674 3
	ret = i915_gem_obj_ggtt_pin(to->obj, CONTEXT_ALIGN, false, false);
	if (ret)
		return ret;
d683 20
d711 14
a724 4
	ret = i915_gem_object_set_to_gtt_domain(to->obj, false);
	if (ret) {
		i915_gem_object_unpin(to->obj);
		return ret;
d727 3
a729 2
	if (!to->obj->has_global_gtt_mapping)
		i915_gem_gtt_bind_object(to->obj, to->obj->cache_level);
d731 3
a733 2
	if (!to->is_initialized || is_default_context(to))
		hw_flags |= MI_RESTORE_INHIBIT;
d735 15
a749 4
	ret = mi_set_context(ring, to, hw_flags);
	if (ret) {
		i915_gem_object_unpin(to->obj);
		return ret;
d756 1
a756 1
		ret = i915_gem_l3_remap(ring, i);
d771 2
a772 2
		from->obj->base.read_domains = I915_GEM_DOMAIN_INSTRUCTION;
		i915_vma_move_to_active(i915_gem_obj_to_ggtt(from->obj), ring);
d780 1
a780 2
		from->obj->dirty = 1;
		BUG_ON(from->obj->ring != ring);
d783 1
a783 1
		i915_gem_object_unpin(from->obj);
d787 4
d793 8
a800 1
	to->is_initialized = true;
d803 5
d812 1
a812 3
 * @@ring: ring for which we'll execute the context switch
 * @@file_priv: file_priv associated with the context, may be NULL
 * @@id: context id number
d816 1
a816 1
 * it will have a refoucnt > 1. This allows us to destroy the context abstract
d818 4
d823 1
a823 3
int i915_switch_context(struct intel_ring_buffer *ring,
			struct drm_file *file,
			int to_id)
d825 1
a826 4
	struct i915_hw_context *to;

	if (!HAS_HW_CONTEXTS(ring->dev))
		return 0;
d828 1
d831 7
a837 1
	if (ring != &dev_priv->ring[RCS])
d839 1
d841 2
a842 5
	if (to_id == DEFAULT_CONTEXT_ID) {
		to = ring->default_context;
	} else {
		if (file == NULL)
			return -EINVAL;
d844 3
a846 6
		to = i915_gem_context_get(file->driver_priv, to_id);
		if (to == NULL)
			return -ENOENT;
	}

	return do_switch(to);
d854 1
a854 1
	struct i915_hw_context *ctx;
d857 1
a857 4
	if (!(dev->driver->driver_features & DRIVER_GEM))
		return -ENODEV;

	if (!HAS_HW_CONTEXTS(dev))
d864 1
a864 1
	ctx = create_hw_context(dev, file_priv);
d869 1
a869 1
	args->ctx_id = ctx->id;
d880 1
a880 1
	struct i915_hw_context *ctx;
d883 2
a884 2
	if (!(dev->driver->driver_features & DRIVER_GEM))
		return -ENODEV;
d891 1
a891 1
	if (!ctx) {
d893 1
a893 1
		return -ENOENT;
d896 1
a896 1
	idr_remove(&ctx->file_priv->context_idr, ctx->id);
d902 80
@


1.13
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.12 2015/02/12 04:56:03 kettenis Exp $	*/
a102 3
int i915_ctx_handle_cmp(struct i915_ctx_handle *, struct i915_ctx_handle *);
SPLAY_PROTOTYPE(i915_ctx_tree, i915_ctx_handle, entry, i915_ctx_handle_cmp);

a146 1
	struct i915_ctx_handle *han;
d181 3
a183 4
	han = malloc(sizeof(*han), M_DRM, M_WAITOK | M_CANFAIL | M_ZERO);
	if (han == NULL) {
		ret = -ENOMEM;
		DRM_DEBUG_DRIVER("idr allocation failed\n");
a184 7
	}
	han->ctx = ctx;
again:
	han->handle = ++file_priv->ctx_id;
	if (han->handle <= DEFAULT_CONTEXT_ID + 1 || SPLAY_INSERT(i915_ctx_tree,
	    &file_priv->ctx_tree, han))
		goto again;
d187 1
a187 1
	ctx->id = han->handle;
a347 1
	struct i915_ctx_handle *han, *nxt;
d349 2
a350 7
	for (han = SPLAY_MIN(i915_ctx_tree, &file_priv->ctx_tree); han != NULL;
	    han = nxt) {
		nxt = SPLAY_NEXT(i915_ctx_tree, &file_priv->ctx_tree, han);
		context_idr_cleanup(han->handle, han->ctx, NULL);
		SPLAY_REMOVE(i915_ctx_tree, &file_priv->ctx_tree, han);
		free(han, M_DRM, 0);
	}
d356 1
a356 8
	struct i915_ctx_handle *han, search;

	search.handle = id;
	han = SPLAY_FIND(i915_ctx_tree, &file_priv->ctx_tree, &search);
	if (han == NULL)
		return NULL;

	return (han->ctx);
d547 1
a547 1
	if (!drm_core_check_feature(dev, DRIVER_GEM))
a573 1
	struct i915_ctx_handle *han, find;
d576 1
a576 1
	if (!drm_core_check_feature(dev, DRIVER_GEM))
d589 1
a589 4
	find.handle = ctx->id;
	han = SPLAY_FIND(i915_ctx_tree, &ctx->file_priv->ctx_tree, &find);
	if (han != NULL)
		SPLAY_REMOVE(i915_ctx_tree, &ctx->file_priv->ctx_tree, han);
a595 8

int
i915_ctx_handle_cmp(struct i915_ctx_handle *a, struct i915_ctx_handle *b)
{
        return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(i915_ctx_tree, i915_ctx_handle, entry, i915_ctx_handle_cmp);
@


1.12
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.11 2015/02/12 02:12:02 kettenis Exp $	*/
d77 1
a77 1
 *  GPU. The GPU has loaded it's state already and has stored away the gtt
d124 3
d134 1
a134 1
static void do_destroy(struct i915_hw_context *ctx)
d136 2
a137 11
	struct drm_device *dev = ctx->obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (ctx->file_priv) {
		struct i915_ctx_handle *han, find;
		find.handle = ctx->id;
		han = SPLAY_FIND(i915_ctx_tree, &ctx->file_priv->ctx_tree, &find);
		if (han != NULL)
			SPLAY_REMOVE(i915_ctx_tree, &ctx->file_priv->ctx_tree, han);
	} else
		BUG_ON(ctx != dev_priv->ring[RCS].default_context);
d139 1
d157 1
d159 1
d168 3
a170 2
						      I915_CACHE_LLC_MLC);
		if (ret)
d179 1
a184 2
	ctx->file_priv = file_priv;

a191 1

a193 1

d198 1
d200 4
d208 1
a208 1
	do_destroy(ctx);
d239 3
a241 3
	dev_priv->ring[RCS].default_context = ctx;
	ret = i915_gem_object_pin(ctx->obj, CONTEXT_ALIGN, false, false);
	if (ret)
d243 1
d246 2
a247 1
	if (ret)
d249 3
d259 1
a259 1
	do_destroy(ctx);
d263 1
a263 1
void i915_gem_context_init(struct drm_device *dev)
d266 1
a266 1
	uint32_t ctx_size;
d268 2
a269 4
	if (!HAS_HW_CONTEXTS(dev)) {
		dev_priv->hw_contexts_disabled = true;
		return;
	}
d272 2
a273 3
	if (dev_priv->hw_contexts_disabled ||
	    dev_priv->ring[RCS].default_context)
		return;
d275 1
a275 3
	ctx_size = get_context_size(dev);
	dev_priv->hw_context_size = get_context_size(dev);
	dev_priv->hw_context_size = roundup2(dev_priv->hw_context_size, 4096);
d277 3
a279 3
	if (ctx_size <= 0 || ctx_size > (1<<20)) {
		dev_priv->hw_contexts_disabled = true;
		return;
d282 5
a286 3
	if (create_default_context(dev_priv)) {
		dev_priv->hw_contexts_disabled = true;
		return;
d290 1
d296 1
d298 1
a298 1
	if (dev_priv->hw_contexts_disabled)
d306 18
a323 3
	i915_gem_object_unpin(dev_priv->ring[RCS].default_context->obj);

	do_destroy(dev_priv->ring[RCS].default_context);
d332 17
a348 1
	do_destroy(ctx);
d350 5
a354 1
	return 0;
d375 1
d406 1
d414 1
a414 1
	intel_ring_emit(ring, new_context->obj->gtt_offset |
d435 1
a435 1
	struct drm_i915_gem_object *from_obj = ring->last_context_obj;
d437 1
a437 1
	int ret;
d439 1
a439 1
	BUG_ON(from_obj != NULL && from_obj->pin_count == 0);
d441 1
a441 1
	if (from_obj == to->obj)
d444 1
a444 1
	ret = i915_gem_object_pin(to->obj, CONTEXT_ALIGN, false, false);
d448 9
a456 1
	/* Clear this page out of any CPU caches for coherent swap-in/out. Note
d460 3
a462 1
	 * XXX: We need a real interface to do this instead of trickery. */
a473 2
	else if (WARN_ON_ONCE(from_obj == to->obj)) /* not yet expected */
		hw_flags |= MI_FORCE_RESTORE;
d481 12
d499 3
a501 3
	if (from_obj != NULL) {
		from_obj->base.read_domains = I915_GEM_DOMAIN_INSTRUCTION;
		i915_gem_object_move_to_active(from_obj, ring);
d509 2
a510 3
		from_obj->dirty = 1;
		BUG_ON(from_obj->ring != ring);
		i915_gem_object_unpin(from_obj);
d512 3
a514 1
		drm_gem_object_unreference(&from_obj->base);
d517 2
a518 2
	drm_gem_object_reference(&to->obj->base);
	ring->last_context_obj = to->obj;
a528 2
 * @@seqno: sequence number by which the new context will be switched to
 * @@flags:
d542 1
a542 1
	if (dev_priv->hw_contexts_disabled)
d545 2
a566 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d575 1
a575 1
	if (dev_priv->hw_contexts_disabled)
d599 1
d615 5
a619 2
	do_destroy(ctx);

@


1.11
log
@Add mutex_is_locked and use it wherever linux uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.10 2015/02/10 01:39:32 jsg Exp $	*/
a224 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d227 1
a227 1
	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
d229 1
a229 1
	ctx = create_hw_context(dev, NULL);
@


1.10
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.9 2014/07/12 18:48:52 tedu Exp $	*/
d228 1
a228 1
	rw_assert_wrlock(&dev->struct_mutex);
@


1.9
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.8 2014/02/18 02:36:49 jsg Exp $	*/
d228 1
a228 1
	rw_assert_wrlock(&dev->dev_lock);
d523 1
a523 1
	DRM_UNLOCK();
d550 1
a550 1
		DRM_UNLOCK();
d556 1
a556 1
	DRM_UNLOCK();
@


1.8
log
@drm/i915: Hold mutex across i915_gem_release

From Chris Wilson
e20ebbe3f08a1258fe54bcf6e6bcd75bb9b1ecc0 in ubuntu 3.8
0d1430a3f4b7cfd8779b78740a4182321f3ca7f3 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.7 2014/01/21 08:57:22 kettenis Exp $	*/
d329 1
a329 1
		free(han, M_DRM);
@


1.7
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.6 2014/01/21 08:43:56 kettenis Exp $	*/
a323 1
	DRM_LOCK();
a330 1
	DRM_UNLOCK();
@


1.6
log
@Use PTR_ERR where appropriate instead of a plain cast.
Reduces diffs to Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.5 2013/11/19 19:14:09 kettenis Exp $	*/
d146 1
a146 1
	free(ctx, M_DRM);
d158 1
a158 1
	ctx = malloc(sizeof(*ctx), M_DRM, M_WAITOK | M_ZERO);
d164 1
a164 1
		free(ctx, M_DRM);
d188 2
a189 1
	if ((han = drm_calloc(1, sizeof(*han))) == NULL) {
d330 1
a330 1
		drm_free(han);
@


1.5
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.4 2013/11/11 02:43:20 jsg Exp $	*/
d231 1
a231 1
		return (long)(ctx);
d526 1
a526 1
		return (long)(ctx);
@


1.4
log
@drm/i915: Fix context sizes on HSW

With updates to the spec, we can actually see the context layout, and
how many dwords are allocated. That table suggests we need 70720 bytes
per HW context. Rounded up, this is 18 pages. Looking at what lives
after the current 4 pages we use, I can't see too much important (mostly
it's d3d related), but there are a couple of things which look scary. I
am hopeful this can explain some of our odd HSW failures.

v2: Make the context only 17 pages. The power context space isn't used
ever, and execlists aren't used in our driver, making the actual total
66944 bytes.

v3: Add a comment to the code. (Jesse & Paulo)

From Ben Widawsky
6bab5ce3f3224d3c1fcc92ed9184392558ae3df4 in ubuntu 3.8
a0de80a0e07032a111230ec92eca563f9d93648d in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.3 2013/11/07 05:33:05 jsg Exp $	*/
d421 1
a421 1
		i915_gem_gtt_rebind_object(to->obj, to->obj->cache_level);
@


1.3
log
@add a simplistic version of WARN_ON_ONCE() that doesn't warn
reduces the diff to linux and avoids a clang warning brad mentioned
ok kettenis@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.2 2013/10/05 07:30:06 jsg Exp $	*/
d120 1
a120 1
			ret = HSW_CXT_TOTAL_SIZE(reg) * 64;
@


1.2
log
@add and use gtt mapping flags, further reduces the diff to linux
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.1 2013/08/07 00:04:28 jsg Exp $	*/
d425 1
a425 1
	else if (/*WARN_ON_ONCE*/(from_obj == to->obj)) /* not yet expected */
@


1.1
log
@add support for hardware contexts on recent intel hardware
based on the code in linux 3.8.13
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a419 1
#ifdef notyet
d421 1
a421 4
		i915_gem_gtt_bind_object(to->obj, to->obj->cache_level);
#else
	i915_gem_gtt_rebind_object(to->obj, to->obj->cache_level);
#endif
@

