head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8;
locks; strict;
comment	@ * @;


1.14
date	2016.04.05.21.22.02;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	HESbnwM3z1fH4IBz;

1.13
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.12;
commitid	lQlppvmETCN49oZe;

1.12
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.11;
commitid	adfbJ0ccUTdhFGhI;

1.11
date	2015.02.12.02.12.02;	author kettenis;	state Exp;
branches;
next	1.10;
commitid	cYXtgYH6nnLqDRGU;

1.10
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.9;
commitid	a8Vt7gSt34kmziIS;

1.9
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.8;
commitid	OBNa5kfxQ2UXoiIw;

1.8
date	2014.02.18.02.36.49;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2014.01.21.08.43.56;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.11.11.02.43.20;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.11.07.05.33.05;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.05.07.30.06;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.07.00.04.28;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Use the "idr" API here as well, reducing the diffs to Linux.
@
text
@/*	$OpenBSD: i915_gem_context.c,v 1.13 2015/09/23 23:12:12 kettenis Exp $	*/
/*
 * Copyright Â© 2011-2012 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Ben Widawsky <ben@@bwidawsk.net>
 *
 */

/*
 * This file implements HW context support. On gen5+ a HW context consists of an
 * opaque GPU object which is referenced at times of context saves and restores.
 * With RC6 enabled, the context is also referenced as the GPU enters and exists
 * from RC6 (GPU has it's own internal power context, except on gen5). Though
 * something like a context does exist for the media ring, the code only
 * supports contexts for the render ring.
 *
 * In software, there is a distinction between contexts created by the user,
 * and the default HW context. The default HW context is used by GPU clients
 * that do not request setup of their own hardware context. The default
 * context's state is never restored to help prevent programming errors. This
 * would happen if a client ran and piggy-backed off another clients GPU state.
 * The default context only exists to give the GPU some offset to load as the
 * current to invoke a save of the context we actually care about. In fact, the
 * code could likely be constructed, albeit in a more complicated fashion, to
 * never use the default context, though that limits the driver's ability to
 * swap out, and/or destroy other contexts.
 *
 * All other contexts are created as a request by the GPU client. These contexts
 * store GPU state, and thus allow GPU clients to not re-emit state (and
 * potentially query certain state) at any time. The kernel driver makes
 * certain that the appropriate commands are inserted.
 *
 * The context life cycle is semi-complicated in that context BOs may live
 * longer than the context itself because of the way the hardware, and object
 * tracking works. Below is a very crude representation of the state machine
 * describing the context life.
 *                                         refcount     pincount     active
 * S0: initial state                          0            0           0
 * S1: context created                        1            0           0
 * S2: context is currently running           2            1           X
 * S3: GPU referenced, but not current        2            0           1
 * S4: context is current, but destroyed      1            1           0
 * S5: like S3, but destroyed                 1            0           1
 *
 * The most common (but not all) transitions:
 * S0->S1: client creates a context
 * S1->S2: client submits execbuf with context
 * S2->S3: other clients submits execbuf with context
 * S3->S1: context object was retired
 * S3->S2: clients submits another execbuf
 * S2->S4: context destroy called with current context
 * S3->S5->S0: destroy path
 * S4->S5->S0: destroy path on current context
 *
 * There are two confusing terms used above:
 *  The "current context" means the context which is currently running on the
 *  GPU. The GPU has loaded its state already and has stored away the gtt
 *  offset of the BO. The GPU is not actively referencing the data at this
 *  offset, but it will on the next context switch. The only way to avoid this
 *  is to do a GPU reset.
 *
 *  An "active context' is one which was previously the "current context" and is
 *  on the active list waiting for the next context switch to occur. Until this
 *  happens, the object must remain at the same gtt offset. It is therefore
 *  possible to destroy a context, but it is still active.
 *
 */

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"

/* This is a HW constraint. The value below is the largest known requirement
 * I've seen in a spec to date, and that was a workaround for a non-shipping
 * part. It should be safe to decrease this, but it's more future proof as is.
 */
#define CONTEXT_ALIGN (64<<10)

static struct i915_hw_context *
i915_gem_context_get(struct drm_i915_file_private *file_priv, u32 id);
static int do_switch(struct i915_hw_context *to);

static int get_context_size(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;
	u32 reg;

	switch (INTEL_INFO(dev)->gen) {
	case 6:
		reg = I915_READ(CXT_SIZE);
		ret = GEN6_CXT_TOTAL_SIZE(reg) * 64;
		break;
	case 7:
		reg = I915_READ(GEN7_CXT_SIZE);
		if (IS_HASWELL(dev))
			ret = HSW_CXT_TOTAL_SIZE;
		else
			ret = GEN7_CXT_TOTAL_SIZE(reg) * 64;
		break;
	case 8:
		ret = GEN8_CXT_TOTAL_SIZE;
		break;
	default:
		BUG();
	}

	return ret;
}

void i915_gem_context_free(struct kref *ctx_ref)
{
	struct i915_hw_context *ctx = container_of(ctx_ref,
						   typeof(*ctx), ref);

	list_del(&ctx->link);
	drm_gem_object_unreference(&ctx->obj->base);
	kfree(ctx);
}

static struct i915_hw_context *
create_hw_context(struct drm_device *dev,
		  struct drm_i915_file_private *file_priv)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct i915_hw_context *ctx;
	int ret;

	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
	if (ctx == NULL)
		return ERR_PTR(-ENOMEM);

	kref_init(&ctx->ref);
	ctx->obj = i915_gem_alloc_object(dev, dev_priv->hw_context_size);
	INIT_LIST_HEAD(&ctx->link);
	if (ctx->obj == NULL) {
		kfree(ctx);
		DRM_DEBUG_DRIVER("Context object allocated failed\n");
		return ERR_PTR(-ENOMEM);
	}

	if (INTEL_INFO(dev)->gen >= 7) {
		ret = i915_gem_object_set_cache_level(ctx->obj,
						      I915_CACHE_L3_LLC);
		/* Failure shouldn't ever happen this early */
		if (WARN_ON(ret))
			goto err_out;
	}

	/* The ring associated with the context object is handled by the normal
	 * object tracking code. We give an initial ring value simple to pass an
	 * assertion in the context switch code.
	 */
	ctx->ring = &dev_priv->ring[RCS];
	list_add_tail(&ctx->link, &dev_priv->context_list);

	/* Default context will never have a file_priv */
	if (file_priv == NULL)
		return ctx;

	ret = idr_alloc(&file_priv->context_idr, ctx, DEFAULT_CONTEXT_ID + 1, 0,
			GFP_KERNEL);
	if (ret < 0)
		goto err_out;

	ctx->file_priv = file_priv;
	ctx->id = ret;
	/* NB: Mark all slices as needing a remap so that when the context first
	 * loads it will restore whatever remap state already exists. If there
	 * is no remap info, it will be a NOP. */
	ctx->remap_slice = (1 << NUM_L3_SLICES(dev)) - 1;

	return ctx;

err_out:
	i915_gem_context_unreference(ctx);
	return ERR_PTR(ret);
}

static inline bool is_default_context(struct i915_hw_context *ctx)
{
	return (ctx == ctx->ring->default_context);
}

/**
 * The default context needs to exist per ring that uses contexts. It stores the
 * context state of the GPU for applications that don't utilize HW contexts, as
 * well as an idle case.
 */
static int create_default_context(struct drm_i915_private *dev_priv)
{
	struct i915_hw_context *ctx;
	int ret;

	BUG_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));

	ctx = create_hw_context(dev_priv->dev, NULL);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	/* We may need to do things with the shrinker which require us to
	 * immediately switch back to the default context. This can cause a
	 * problem as pinning the default context also requires GTT space which
	 * may not be available. To avoid this we always pin the
	 * default context.
	 */
	ret = i915_gem_obj_ggtt_pin(ctx->obj, CONTEXT_ALIGN, false, false);
	if (ret) {
		DRM_DEBUG_DRIVER("Couldn't pin %d\n", ret);
		goto err_destroy;
	}

	ret = do_switch(ctx);
	if (ret) {
		DRM_DEBUG_DRIVER("Switch failed %d\n", ret);
		goto err_unpin;
	}

	dev_priv->ring[RCS].default_context = ctx;

	DRM_DEBUG_DRIVER("Default HW context loaded\n");
	return 0;

err_unpin:
	i915_gem_object_unpin(ctx->obj);
err_destroy:
	i915_gem_context_unreference(ctx);
	return ret;
}

int i915_gem_context_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	if (!HAS_HW_CONTEXTS(dev))
		return 0;

	/* If called from reset, or thaw... we've been here already */
	if (dev_priv->ring[RCS].default_context)
		return 0;

	dev_priv->hw_context_size = round_up(get_context_size(dev), 4096);

	if (dev_priv->hw_context_size > (1<<20)) {
		DRM_DEBUG_DRIVER("Disabling HW Contexts; invalid size\n");
		return -E2BIG;
	}

	ret = create_default_context(dev_priv);
	if (ret) {
		DRM_DEBUG_DRIVER("Disabling HW Contexts; create failed %d\n",
				 ret);
		return ret;
	}

	DRM_DEBUG_DRIVER("HW context support initialized\n");
	return 0;
}

void i915_gem_context_fini(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct i915_hw_context *dctx = dev_priv->ring[RCS].default_context;

	if (!HAS_HW_CONTEXTS(dev))
		return;

	/* The only known way to stop the gpu from accessing the hw context is
	 * to reset it. Do this as the very last operation to avoid confusing
	 * other code, leading to spurious errors. */
	intel_gpu_reset(dev);

	/* When default context is created and switched to, base object refcount
	 * will be 2 (+1 from object creation and +1 from do_switch()).
	 * i915_gem_context_fini() will be called after gpu_idle() has switched
	 * to default context. So we need to unreference the base object once
	 * to offset the do_switch part, so that i915_gem_context_unreference()
	 * can then free the base object correctly. */
	WARN_ON(!dev_priv->ring[RCS].last_context);
	if (dev_priv->ring[RCS].last_context == dctx) {
		/* Fake switch to NULL context */
		WARN_ON(dctx->obj->active);
		i915_gem_object_unpin(dctx->obj);
		i915_gem_context_unreference(dctx);
	}

	i915_gem_object_unpin(dctx->obj);
	i915_gem_context_unreference(dctx);
	dev_priv->ring[RCS].default_context = NULL;
	dev_priv->ring[RCS].last_context = NULL;
}

static int context_idr_cleanup(int id, void *p, void *data)
{
	struct i915_hw_context *ctx = p;

	BUG_ON(id == DEFAULT_CONTEXT_ID);

	i915_gem_context_unreference(ctx);
	return 0;
}

struct i915_ctx_hang_stats *
i915_gem_context_get_hang_stats(struct drm_device *dev,
				struct drm_file *file,
				u32 id)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct i915_hw_context *ctx;

	if (id == DEFAULT_CONTEXT_ID)
		return &file_priv->hang_stats;

	if (!HAS_HW_CONTEXTS(dev))
		return ERR_PTR(-ENOENT);

	ctx = i915_gem_context_get(file->driver_priv, id);
	if (ctx == NULL)
		return ERR_PTR(-ENOENT);

	return &ctx->hang_stats;
}

void i915_gem_context_close(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;

	idr_for_each(&file_priv->context_idr, context_idr_cleanup, NULL);
	idr_destroy(&file_priv->context_idr);
}

static struct i915_hw_context *
i915_gem_context_get(struct drm_i915_file_private *file_priv, u32 id)
{
	return (struct i915_hw_context *)idr_find(&file_priv->context_idr, id);
}

static inline int
mi_set_context(struct intel_ring_buffer *ring,
	       struct i915_hw_context *new_context,
	       u32 hw_flags)
{
	int ret;

	/* w/a: If Flush TLB Invalidation Mode is enabled, driver must do a TLB
	 * invalidation prior to MI_SET_CONTEXT. On GEN6 we don't set the value
	 * explicitly, so we rely on the value at ring init, stored in
	 * itlb_before_ctx_switch.
	 */
	if (IS_GEN6(ring->dev) && ring->itlb_before_ctx_switch) {
		ret = ring->flush(ring, I915_GEM_GPU_DOMAINS, 0);
		if (ret)
			return ret;
	}

	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;

	/* WaProgramMiArbOnOffAroundMiSetContext:ivb,vlv,hsw */
	if (IS_GEN7(ring->dev))
		intel_ring_emit(ring, MI_ARB_ON_OFF | MI_ARB_DISABLE);
	else
		intel_ring_emit(ring, MI_NOOP);

	intel_ring_emit(ring, MI_NOOP);
	intel_ring_emit(ring, MI_SET_CONTEXT);
	intel_ring_emit(ring, i915_gem_obj_ggtt_offset(new_context->obj) |
			MI_MM_SPACE_GTT |
			MI_SAVE_EXT_STATE_EN |
			MI_RESTORE_EXT_STATE_EN |
			hw_flags);
	/* w/a: MI_SET_CONTEXT must always be followed by MI_NOOP */
	intel_ring_emit(ring, MI_NOOP);

	if (IS_GEN7(ring->dev))
		intel_ring_emit(ring, MI_ARB_ON_OFF | MI_ARB_ENABLE);
	else
		intel_ring_emit(ring, MI_NOOP);

	intel_ring_advance(ring);

	return ret;
}

static int do_switch(struct i915_hw_context *to)
{
	struct intel_ring_buffer *ring = to->ring;
	struct i915_hw_context *from = ring->last_context;
	u32 hw_flags = 0;
	int ret, i;

	BUG_ON(from != NULL && from->obj != NULL && from->obj->pin_count == 0);

	if (from == to && !to->remap_slice)
		return 0;

	ret = i915_gem_obj_ggtt_pin(to->obj, CONTEXT_ALIGN, false, false);
	if (ret)
		return ret;

	/*
	 * Pin can switch back to the default context if we end up calling into
	 * evict_everything - as a last ditch gtt defrag effort that also
	 * switches to the default context. Hence we need to reload from here.
	 */
	from = ring->last_context;

	/*
	 * Clear this page out of any CPU caches for coherent swap-in/out. Note
	 * that thanks to write = false in this call and us not setting any gpu
	 * write domains when putting a context object onto the active list
	 * (when switching away from it), this won't block.
	 *
	 * XXX: We need a real interface to do this instead of trickery.
	 */
	ret = i915_gem_object_set_to_gtt_domain(to->obj, false);
	if (ret) {
		i915_gem_object_unpin(to->obj);
		return ret;
	}

	if (!to->obj->has_global_gtt_mapping)
		i915_gem_gtt_bind_object(to->obj, to->obj->cache_level);

	if (!to->is_initialized || is_default_context(to))
		hw_flags |= MI_RESTORE_INHIBIT;

	ret = mi_set_context(ring, to, hw_flags);
	if (ret) {
		i915_gem_object_unpin(to->obj);
		return ret;
	}

	for (i = 0; i < MAX_L3_SLICES; i++) {
		if (!(to->remap_slice & (1<<i)))
			continue;

		ret = i915_gem_l3_remap(ring, i);
		/* If it failed, try again next round */
		if (ret)
			DRM_DEBUG_DRIVER("L3 remapping failed\n");
		else
			to->remap_slice &= ~(1<<i);
	}

	/* The backing object for the context is done after switching to the
	 * *next* context. Therefore we cannot retire the previous context until
	 * the next context has already started running. In fact, the below code
	 * is a bit suboptimal because the retiring can occur simply after the
	 * MI_SET_CONTEXT instead of when the next seqno has completed.
	 */
	if (from != NULL) {
		from->obj->base.read_domains = I915_GEM_DOMAIN_INSTRUCTION;
		i915_vma_move_to_active(i915_gem_obj_to_ggtt(from->obj), ring);
		/* As long as MI_SET_CONTEXT is serializing, ie. it flushes the
		 * whole damn pipeline, we don't need to explicitly mark the
		 * object dirty. The only exception is that the context must be
		 * correct in case the object gets swapped out. Ideally we'd be
		 * able to defer doing this until we know the object would be
		 * swapped, but there is no way to do that yet.
		 */
		from->obj->dirty = 1;
		BUG_ON(from->obj->ring != ring);

		/* obj is kept alive until the next request by its active ref */
		i915_gem_object_unpin(from->obj);
		i915_gem_context_unreference(from);
	}

	i915_gem_context_reference(to);
	ring->last_context = to;
	to->is_initialized = true;

	return 0;
}

/**
 * i915_switch_context() - perform a GPU context switch.
 * @@ring: ring for which we'll execute the context switch
 * @@file_priv: file_priv associated with the context, may be NULL
 * @@id: context id number
 *
 * The context life cycle is simple. The context refcount is incremented and
 * decremented by 1 and create and destroy. If the context is in use by the GPU,
 * it will have a refoucnt > 1. This allows us to destroy the context abstract
 * object while letting the normal object tracking destroy the backing BO.
 */
int i915_switch_context(struct intel_ring_buffer *ring,
			struct drm_file *file,
			int to_id)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	struct i915_hw_context *to;

	if (!HAS_HW_CONTEXTS(ring->dev))
		return 0;

	WARN_ON(!mutex_is_locked(&dev_priv->dev->struct_mutex));

	if (ring != &dev_priv->ring[RCS])
		return 0;

	if (to_id == DEFAULT_CONTEXT_ID) {
		to = ring->default_context;
	} else {
		if (file == NULL)
			return -EINVAL;

		to = i915_gem_context_get(file->driver_priv, to_id);
		if (to == NULL)
			return -ENOENT;
	}

	return do_switch(to);
}

int i915_gem_context_create_ioctl(struct drm_device *dev, void *data,
				  struct drm_file *file)
{
	struct drm_i915_gem_context_create *args = data;
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct i915_hw_context *ctx;
	int ret;

	if (!(dev->driver->driver_features & DRIVER_GEM))
		return -ENODEV;

	if (!HAS_HW_CONTEXTS(dev))
		return -ENODEV;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = create_hw_context(dev, file_priv);
	mutex_unlock(&dev->struct_mutex);
	if (IS_ERR(ctx))
		return PTR_ERR(ctx);

	args->ctx_id = ctx->id;
	DRM_DEBUG_DRIVER("HW context %d created\n", args->ctx_id);

	return 0;
}

int i915_gem_context_destroy_ioctl(struct drm_device *dev, void *data,
				   struct drm_file *file)
{
	struct drm_i915_gem_context_destroy *args = data;
	struct drm_i915_file_private *file_priv = file->driver_priv;
	struct i915_hw_context *ctx;
	int ret;

	if (!(dev->driver->driver_features & DRIVER_GEM))
		return -ENODEV;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	ctx = i915_gem_context_get(file_priv, args->ctx_id);
	if (!ctx) {
		mutex_unlock(&dev->struct_mutex);
		return -ENOENT;
	}

	idr_remove(&ctx->file_priv->context_idr, ctx->id);
	i915_gem_context_unreference(ctx);
	mutex_unlock(&dev->struct_mutex);

	DRM_DEBUG_DRIVER("HW context %d destroyed\n", args->ctx_id);
	return 0;
}
@


1.13
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.12 2015/02/12 04:56:03 kettenis Exp $	*/
a102 3
int i915_ctx_handle_cmp(struct i915_ctx_handle *, struct i915_ctx_handle *);
SPLAY_PROTOTYPE(i915_ctx_tree, i915_ctx_handle, entry, i915_ctx_handle_cmp);

a146 1
	struct i915_ctx_handle *han;
d181 3
a183 4
	han = malloc(sizeof(*han), M_DRM, M_WAITOK | M_CANFAIL | M_ZERO);
	if (han == NULL) {
		ret = -ENOMEM;
		DRM_DEBUG_DRIVER("idr allocation failed\n");
a184 7
	}
	han->ctx = ctx;
again:
	han->handle = ++file_priv->ctx_id;
	if (han->handle <= DEFAULT_CONTEXT_ID + 1 || SPLAY_INSERT(i915_ctx_tree,
	    &file_priv->ctx_tree, han))
		goto again;
d187 1
a187 1
	ctx->id = han->handle;
a347 1
	struct i915_ctx_handle *han, *nxt;
d349 2
a350 7
	for (han = SPLAY_MIN(i915_ctx_tree, &file_priv->ctx_tree); han != NULL;
	    han = nxt) {
		nxt = SPLAY_NEXT(i915_ctx_tree, &file_priv->ctx_tree, han);
		context_idr_cleanup(han->handle, han->ctx, NULL);
		SPLAY_REMOVE(i915_ctx_tree, &file_priv->ctx_tree, han);
		free(han, M_DRM, 0);
	}
d356 1
a356 8
	struct i915_ctx_handle *han, search;

	search.handle = id;
	han = SPLAY_FIND(i915_ctx_tree, &file_priv->ctx_tree, &search);
	if (han == NULL)
		return NULL;

	return (han->ctx);
d547 1
a547 1
	if (!drm_core_check_feature(dev, DRIVER_GEM))
a573 1
	struct i915_ctx_handle *han, find;
d576 1
a576 1
	if (!drm_core_check_feature(dev, DRIVER_GEM))
d589 1
a589 4
	find.handle = ctx->id;
	han = SPLAY_FIND(i915_ctx_tree, &ctx->file_priv->ctx_tree, &find);
	if (han != NULL)
		SPLAY_REMOVE(i915_ctx_tree, &ctx->file_priv->ctx_tree, han);
a595 8

int
i915_ctx_handle_cmp(struct i915_ctx_handle *a, struct i915_ctx_handle *b)
{
        return a->handle < b->handle ? -1 : a->handle > b->handle;
}

SPLAY_GENERATE(i915_ctx_tree, i915_ctx_handle, entry, i915_ctx_handle_cmp);
@


1.12
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.11 2015/02/12 02:12:02 kettenis Exp $	*/
d77 1
a77 1
 *  GPU. The GPU has loaded it's state already and has stored away the gtt
d124 3
d134 1
a134 1
static void do_destroy(struct i915_hw_context *ctx)
d136 2
a137 11
	struct drm_device *dev = ctx->obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (ctx->file_priv) {
		struct i915_ctx_handle *han, find;
		find.handle = ctx->id;
		han = SPLAY_FIND(i915_ctx_tree, &ctx->file_priv->ctx_tree, &find);
		if (han != NULL)
			SPLAY_REMOVE(i915_ctx_tree, &ctx->file_priv->ctx_tree, han);
	} else
		BUG_ON(ctx != dev_priv->ring[RCS].default_context);
d139 1
d157 1
d159 1
d168 3
a170 2
						      I915_CACHE_LLC_MLC);
		if (ret)
d179 1
a184 2
	ctx->file_priv = file_priv;

a191 1

a193 1

d198 1
d200 4
d208 1
a208 1
	do_destroy(ctx);
d239 3
a241 3
	dev_priv->ring[RCS].default_context = ctx;
	ret = i915_gem_object_pin(ctx->obj, CONTEXT_ALIGN, false, false);
	if (ret)
d243 1
d246 2
a247 1
	if (ret)
d249 3
d259 1
a259 1
	do_destroy(ctx);
d263 1
a263 1
void i915_gem_context_init(struct drm_device *dev)
d266 1
a266 1
	uint32_t ctx_size;
d268 2
a269 4
	if (!HAS_HW_CONTEXTS(dev)) {
		dev_priv->hw_contexts_disabled = true;
		return;
	}
d272 2
a273 3
	if (dev_priv->hw_contexts_disabled ||
	    dev_priv->ring[RCS].default_context)
		return;
d275 1
a275 3
	ctx_size = get_context_size(dev);
	dev_priv->hw_context_size = get_context_size(dev);
	dev_priv->hw_context_size = roundup2(dev_priv->hw_context_size, 4096);
d277 3
a279 3
	if (ctx_size <= 0 || ctx_size > (1<<20)) {
		dev_priv->hw_contexts_disabled = true;
		return;
d282 5
a286 3
	if (create_default_context(dev_priv)) {
		dev_priv->hw_contexts_disabled = true;
		return;
d290 1
d296 1
d298 1
a298 1
	if (dev_priv->hw_contexts_disabled)
d306 18
a323 3
	i915_gem_object_unpin(dev_priv->ring[RCS].default_context->obj);

	do_destroy(dev_priv->ring[RCS].default_context);
d332 17
a348 1
	do_destroy(ctx);
d350 5
a354 1
	return 0;
d375 1
d406 1
d414 1
a414 1
	intel_ring_emit(ring, new_context->obj->gtt_offset |
d435 1
a435 1
	struct drm_i915_gem_object *from_obj = ring->last_context_obj;
d437 1
a437 1
	int ret;
d439 1
a439 1
	BUG_ON(from_obj != NULL && from_obj->pin_count == 0);
d441 1
a441 1
	if (from_obj == to->obj)
d444 1
a444 1
	ret = i915_gem_object_pin(to->obj, CONTEXT_ALIGN, false, false);
d448 9
a456 1
	/* Clear this page out of any CPU caches for coherent swap-in/out. Note
d460 3
a462 1
	 * XXX: We need a real interface to do this instead of trickery. */
a473 2
	else if (WARN_ON_ONCE(from_obj == to->obj)) /* not yet expected */
		hw_flags |= MI_FORCE_RESTORE;
d481 12
d499 3
a501 3
	if (from_obj != NULL) {
		from_obj->base.read_domains = I915_GEM_DOMAIN_INSTRUCTION;
		i915_gem_object_move_to_active(from_obj, ring);
d509 2
a510 3
		from_obj->dirty = 1;
		BUG_ON(from_obj->ring != ring);
		i915_gem_object_unpin(from_obj);
d512 3
a514 1
		drm_gem_object_unreference(&from_obj->base);
d517 2
a518 2
	drm_gem_object_reference(&to->obj->base);
	ring->last_context_obj = to->obj;
a528 2
 * @@seqno: sequence number by which the new context will be switched to
 * @@flags:
d542 1
a542 1
	if (dev_priv->hw_contexts_disabled)
d545 2
a566 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d575 1
a575 1
	if (dev_priv->hw_contexts_disabled)
d599 1
d615 5
a619 2
	do_destroy(ctx);

@


1.11
log
@Add mutex_is_locked and use it wherever linux uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.10 2015/02/10 01:39:32 jsg Exp $	*/
a224 1
	struct drm_device *dev = (struct drm_device *)dev_priv->drmdev;
d227 1
a227 1
	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
d229 1
a229 1
	ctx = create_hw_context(dev, NULL);
@


1.10
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.9 2014/07/12 18:48:52 tedu Exp $	*/
d228 1
a228 1
	rw_assert_wrlock(&dev->struct_mutex);
@


1.9
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.8 2014/02/18 02:36:49 jsg Exp $	*/
d228 1
a228 1
	rw_assert_wrlock(&dev->dev_lock);
d523 1
a523 1
	DRM_UNLOCK();
d550 1
a550 1
		DRM_UNLOCK();
d556 1
a556 1
	DRM_UNLOCK();
@


1.8
log
@drm/i915: Hold mutex across i915_gem_release

From Chris Wilson
e20ebbe3f08a1258fe54bcf6e6bcd75bb9b1ecc0 in ubuntu 3.8
0d1430a3f4b7cfd8779b78740a4182321f3ca7f3 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.7 2014/01/21 08:57:22 kettenis Exp $	*/
d329 1
a329 1
		free(han, M_DRM);
@


1.7
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.6 2014/01/21 08:43:56 kettenis Exp $	*/
a323 1
	DRM_LOCK();
a330 1
	DRM_UNLOCK();
@


1.6
log
@Use PTR_ERR where appropriate instead of a plain cast.
Reduces diffs to Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.5 2013/11/19 19:14:09 kettenis Exp $	*/
d146 1
a146 1
	free(ctx, M_DRM);
d158 1
a158 1
	ctx = malloc(sizeof(*ctx), M_DRM, M_WAITOK | M_ZERO);
d164 1
a164 1
		free(ctx, M_DRM);
d188 2
a189 1
	if ((han = drm_calloc(1, sizeof(*han))) == NULL) {
d330 1
a330 1
		drm_free(han);
@


1.5
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.4 2013/11/11 02:43:20 jsg Exp $	*/
d231 1
a231 1
		return (long)(ctx);
d526 1
a526 1
		return (long)(ctx);
@


1.4
log
@drm/i915: Fix context sizes on HSW

With updates to the spec, we can actually see the context layout, and
how many dwords are allocated. That table suggests we need 70720 bytes
per HW context. Rounded up, this is 18 pages. Looking at what lives
after the current 4 pages we use, I can't see too much important (mostly
it's d3d related), but there are a couple of things which look scary. I
am hopeful this can explain some of our odd HSW failures.

v2: Make the context only 17 pages. The power context space isn't used
ever, and execlists aren't used in our driver, making the actual total
66944 bytes.

v3: Add a comment to the code. (Jesse & Paulo)

From Ben Widawsky
6bab5ce3f3224d3c1fcc92ed9184392558ae3df4 in ubuntu 3.8
a0de80a0e07032a111230ec92eca563f9d93648d in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.3 2013/11/07 05:33:05 jsg Exp $	*/
d421 1
a421 1
		i915_gem_gtt_rebind_object(to->obj, to->obj->cache_level);
@


1.3
log
@add a simplistic version of WARN_ON_ONCE() that doesn't warn
reduces the diff to linux and avoids a clang warning brad mentioned
ok kettenis@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.2 2013/10/05 07:30:06 jsg Exp $	*/
d120 1
a120 1
			ret = HSW_CXT_TOTAL_SIZE(reg) * 64;
@


1.2
log
@add and use gtt mapping flags, further reduces the diff to linux
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem_context.c,v 1.1 2013/08/07 00:04:28 jsg Exp $	*/
d425 1
a425 1
	else if (/*WARN_ON_ONCE*/(from_obj == to->obj)) /* not yet expected */
@


1.1
log
@add support for hardware contexts on recent intel hardware
based on the code in linux 3.8.13
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a419 1
#ifdef notyet
d421 1
a421 4
		i915_gem_gtt_bind_object(to->obj, to->obj->cache_level);
#else
	i915_gem_gtt_rebind_object(to->obj, to->obj->cache_level);
#endif
@

