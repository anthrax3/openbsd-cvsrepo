head	1.29;
access;
symbols
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7;
locks; strict;
comment	@ * @;


1.29
date	2017.09.30.07.36.56;	author robert;	state Exp;
branches;
next	1.28;
commitid	XkWOvf4INOmfke72;

1.28
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	KnwRPOZok9A30HI4;

1.27
date	2015.12.09.05.17.44;	author jsg;	state Exp;
branches;
next	1.26;
commitid	s0XYUHVZL3Xim3bC;

1.26
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	lQlppvmETCN49oZe;

1.25
date	2015.06.24.08.32.39;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	hfEqCdm8ecmxIgUE;

1.24
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.23;
commitid	syZU9J25izIJ2cm1;

1.23
date	2015.04.06.10.56.37;	author jsg;	state Exp;
branches;
next	1.22;
commitid	YRwUkzqVtigPPQbt;

1.22
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.21;
commitid	C5l5rZ5v9mpRR1eS;

1.21
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.20;
commitid	MyKPm9Q3dQu92BiX;

1.20
date	2014.06.19.06.51.05;	author jsg;	state Exp;
branches;
next	1.19;
commitid	5s6b2JA43QOy2mup;

1.19
date	2014.06.19.06.44.00;	author jsg;	state Exp;
branches;
next	1.18;
commitid	fkRD3xvCprfQuBES;

1.18
date	2014.03.30.01.10.36;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.30.01.06.31;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.18.02.48.57;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.02.01.06.21;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.23.10.42.57;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.22.05.16.55;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.30.02.11.33;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.13.10.23.51;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.08.09.47.45;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.04.09.55.01;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.08.05.46.12;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.04.04.21.26.19;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.03.05.29.06;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Add preliminary kabylake support to inteldrm(4) by backporting the relevant
commits from linux-4.8.x.
The changes are quiet minimal due to the fact that kabylake and skylake share
most of the code because they are both gen9 graphics.
This was tested by many and was also in snapshots for a while.

ok kettenis@@
@
text
@/*
 * Copyright Â© 2008 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Packard <keithp@@keithp.com>
 *
 */

#ifdef __linux__
#include <linux/i2c.h>
#include <linux/slab.h>
#include <linux/export.h>
#include <linux/notifier.h>
#include <linux/reboot.h>
#endif
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_atomic_helper.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_crtc_helper.h>
#include <dev/pci/drm/drm_edid.h>
#include "intel_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"

#define DP_LINK_CHECK_TIMEOUT	(10 * 1000)

/* Compliance test status bits  */
#define INTEL_DP_RESOLUTION_SHIFT_MASK	0
#define INTEL_DP_RESOLUTION_PREFERRED	(1 << INTEL_DP_RESOLUTION_SHIFT_MASK)
#define INTEL_DP_RESOLUTION_STANDARD	(2 << INTEL_DP_RESOLUTION_SHIFT_MASK)
#define INTEL_DP_RESOLUTION_FAILSAFE	(3 << INTEL_DP_RESOLUTION_SHIFT_MASK)

struct dp_link_dpll {
	int clock;
	struct dpll dpll;
};

static const struct dp_link_dpll gen4_dpll[] = {
	{ 162000,
		{ .p1 = 2, .p2 = 10, .n = 2, .m1 = 23, .m2 = 8 } },
	{ 270000,
		{ .p1 = 1, .p2 = 10, .n = 1, .m1 = 14, .m2 = 2 } }
};

static const struct dp_link_dpll pch_dpll[] = {
	{ 162000,
		{ .p1 = 2, .p2 = 10, .n = 1, .m1 = 12, .m2 = 9 } },
	{ 270000,
		{ .p1 = 1, .p2 = 10, .n = 2, .m1 = 14, .m2 = 8 } }
};

static const struct dp_link_dpll vlv_dpll[] = {
	{ 162000,
		{ .p1 = 3, .p2 = 2, .n = 5, .m1 = 3, .m2 = 81 } },
	{ 270000,
		{ .p1 = 2, .p2 = 2, .n = 1, .m1 = 2, .m2 = 27 } }
};

/*
 * CHV supports eDP 1.4 that have  more link rates.
 * Below only provides the fixed rate but exclude variable rate.
 */
static const struct dp_link_dpll chv_dpll[] = {
	/*
	 * CHV requires to program fractional division for m2.
	 * m2 is stored in fixed point format using formula below
	 * (m2_int << 22) | m2_fraction
	 */
	{ 162000,	/* m2_int = 32, m2_fraction = 1677722 */
		{ .p1 = 4, .p2 = 2, .n = 1, .m1 = 2, .m2 = 0x819999a } },
	{ 270000,	/* m2_int = 27, m2_fraction = 0 */
		{ .p1 = 4, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000 } },
	{ 540000,	/* m2_int = 27, m2_fraction = 0 */
		{ .p1 = 2, .p2 = 1, .n = 1, .m1 = 2, .m2 = 0x6c00000 } }
};

static const int bxt_rates[] = { 162000, 216000, 243000, 270000,
				  324000, 432000, 540000 };
static const int skl_rates[] = { 162000, 216000, 270000,
				  324000, 432000, 540000 };
static const int default_rates[] = { 162000, 270000, 540000 };

/**
 * is_edp - is the given port attached to an eDP panel (either CPU or PCH)
 * @@intel_dp: DP struct
 *
 * If a CPU or PCH DP output is attached to an eDP panel, this function
 * will return true, and false otherwise.
 */
static bool is_edp(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	return intel_dig_port->base.type == INTEL_OUTPUT_EDP;
}

static struct drm_device *intel_dp_to_dev(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	return intel_dig_port->base.base.dev;
}

static struct intel_dp *intel_attached_dp(struct drm_connector *connector)
{
	return enc_to_intel_dp(&intel_attached_encoder(connector)->base);
}

static void intel_dp_link_down(struct intel_dp *intel_dp);
static bool edp_panel_vdd_on(struct intel_dp *intel_dp);
static void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync);
static void vlv_init_panel_power_sequencer(struct intel_dp *intel_dp);
static void vlv_steal_power_sequencer(struct drm_device *dev,
				      enum pipe pipe);

static unsigned int intel_dp_unused_lane_mask(int lane_count)
{
	return ~((1 << lane_count) - 1) & 0xf;
}

static int
intel_dp_max_link_bw(struct intel_dp  *intel_dp)
{
	int max_link_bw = intel_dp->dpcd[DP_MAX_LINK_RATE];

	switch (max_link_bw) {
	case DP_LINK_BW_1_62:
	case DP_LINK_BW_2_7:
	case DP_LINK_BW_5_4:
		break;
	default:
		WARN(1, "invalid max DP link bw val %x, using 1.62Gbps\n",
		     max_link_bw);
		max_link_bw = DP_LINK_BW_1_62;
		break;
	}
	return max_link_bw;
}

static u8 intel_dp_max_lane_count(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	u8 source_max, sink_max;

	source_max = 4;
	if (HAS_DDI(dev) && intel_dig_port->port == PORT_A &&
	    (intel_dig_port->saved_port_bits & DDI_A_4_LANES) == 0)
		source_max = 2;

	sink_max = drm_dp_max_lane_count(intel_dp->dpcd);

	return min(source_max, sink_max);
}

/*
 * The units on the numbers in the next two are... bizarre.  Examples will
 * make it clearer; this one parallels an example in the eDP spec.
 *
 * intel_dp_max_data_rate for one lane of 2.7GHz evaluates as:
 *
 *     270000 * 1 * 8 / 10 == 216000
 *
 * The actual data capacity of that configuration is 2.16Gbit/s, so the
 * units are decakilobits.  ->clock in a drm_display_mode is in kilohertz -
 * or equivalently, kilopixels per second - so for 1680x1050R it'd be
 * 119000.  At 18bpp that's 2142000 kilobits per second.
 *
 * Thus the strange-looking division by 10 in intel_dp_link_required, to
 * get the result in decakilobits instead of kilobits.
 */

static int
intel_dp_link_required(int pixel_clock, int bpp)
{
	return (pixel_clock * bpp + 9) / 10;
}

static int
intel_dp_max_data_rate(int max_link_clock, int max_lanes)
{
	return (max_link_clock * max_lanes * 8) / 10;
}

static enum drm_mode_status
intel_dp_mode_valid(struct drm_connector *connector,
		    struct drm_display_mode *mode)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct drm_display_mode *fixed_mode = intel_connector->panel.fixed_mode;
	int target_clock = mode->clock;
	int max_rate, mode_rate, max_lanes, max_link_clock;

	if (is_edp(intel_dp) && fixed_mode) {
		if (mode->hdisplay > fixed_mode->hdisplay)
			return MODE_PANEL;

		if (mode->vdisplay > fixed_mode->vdisplay)
			return MODE_PANEL;

		target_clock = fixed_mode->clock;
	}

	max_link_clock = intel_dp_max_link_rate(intel_dp);
	max_lanes = intel_dp_max_lane_count(intel_dp);

	max_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);
	mode_rate = intel_dp_link_required(target_clock, 18);

	if (mode_rate > max_rate)
		return MODE_CLOCK_HIGH;

	if (mode->clock < 10000)
		return MODE_CLOCK_LOW;

	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
		return MODE_H_ILLEGAL;

	return MODE_OK;
}

uint32_t intel_dp_pack_aux(const uint8_t *src, int src_bytes)
{
	int	i;
	uint32_t v = 0;

	if (src_bytes > 4)
		src_bytes = 4;
	for (i = 0; i < src_bytes; i++)
		v |= ((uint32_t) src[i]) << ((3-i) * 8);
	return v;
}

static void intel_dp_unpack_aux(uint32_t src, uint8_t *dst, int dst_bytes)
{
	int i;
	if (dst_bytes > 4)
		dst_bytes = 4;
	for (i = 0; i < dst_bytes; i++)
		dst[i] = src >> ((3-i) * 8);
}

static void
intel_dp_init_panel_power_sequencer(struct drm_device *dev,
				    struct intel_dp *intel_dp);
static void
intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
					      struct intel_dp *intel_dp);

static void pps_lock(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *encoder = &intel_dig_port->base;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;

	/*
	 * See vlv_power_sequencer_reset() why we need
	 * a power domain reference here.
	 */
	power_domain = intel_display_port_aux_power_domain(encoder);
	intel_display_power_get(dev_priv, power_domain);

	mutex_lock(&dev_priv->pps_mutex);
}

static void pps_unlock(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *encoder = &intel_dig_port->base;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;

	mutex_unlock(&dev_priv->pps_mutex);

	power_domain = intel_display_port_aux_power_domain(encoder);
	intel_display_power_put(dev_priv, power_domain);
}

static void
vlv_power_sequencer_kick(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum pipe pipe = intel_dp->pps_pipe;
	bool pll_enabled, release_cl_override = false;
	enum dpio_phy phy = DPIO_PHY(pipe);
	enum dpio_channel ch = vlv_pipe_to_channel(pipe);
	uint32_t DP;

	if (WARN(I915_READ(intel_dp->output_reg) & DP_PORT_EN,
		 "skipping pipe %c power seqeuncer kick due to port %c being active\n",
		 pipe_name(pipe), port_name(intel_dig_port->port)))
		return;

	DRM_DEBUG_KMS("kicking pipe %c power sequencer for port %c\n",
		      pipe_name(pipe), port_name(intel_dig_port->port));

	/* Preserve the BIOS-computed detected bit. This is
	 * supposed to be read-only.
	 */
	DP = I915_READ(intel_dp->output_reg) & DP_DETECTED;
	DP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;
	DP |= DP_PORT_WIDTH(1);
	DP |= DP_LINK_TRAIN_PAT_1;

	if (IS_CHERRYVIEW(dev))
		DP |= DP_PIPE_SELECT_CHV(pipe);
	else if (pipe == PIPE_B)
		DP |= DP_PIPEB_SELECT;

	pll_enabled = I915_READ(DPLL(pipe)) & DPLL_VCO_ENABLE;

	/*
	 * The DPLL for the pipe must be enabled for this to work.
	 * So enable temporarily it if it's not already enabled.
	 */
	if (!pll_enabled) {
		release_cl_override = IS_CHERRYVIEW(dev) &&
			!chv_phy_powergate_ch(dev_priv, phy, ch, true);

		vlv_force_pll_on(dev, pipe, IS_CHERRYVIEW(dev) ?
				 &chv_dpll[0].dpll : &vlv_dpll[0].dpll);
	}

	/*
	 * Similar magic as in intel_dp_enable_port().
	 * We _must_ do this port enable + disable trick
	 * to make this power seqeuencer lock onto the port.
	 * Otherwise even VDD force bit won't work.
	 */
	I915_WRITE(intel_dp->output_reg, DP);
	POSTING_READ(intel_dp->output_reg);

	I915_WRITE(intel_dp->output_reg, DP | DP_PORT_EN);
	POSTING_READ(intel_dp->output_reg);

	I915_WRITE(intel_dp->output_reg, DP & ~DP_PORT_EN);
	POSTING_READ(intel_dp->output_reg);

	if (!pll_enabled) {
		vlv_force_pll_off(dev, pipe);

		if (release_cl_override)
			chv_phy_powergate_ch(dev_priv, phy, ch, false);
	}
}

static enum pipe
vlv_power_sequencer_pipe(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;
	unsigned int pipes = (1 << PIPE_A) | (1 << PIPE_B);
	enum pipe pipe;

	lockdep_assert_held(&dev_priv->pps_mutex);

	/* We should never land here with regular DP ports */
	WARN_ON(!is_edp(intel_dp));

	if (intel_dp->pps_pipe != INVALID_PIPE)
		return intel_dp->pps_pipe;

	/*
	 * We don't have power sequencer currently.
	 * Pick one that's not used by other ports.
	 */
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		struct intel_dp *tmp;

		if (encoder->type != INTEL_OUTPUT_EDP)
			continue;

		tmp = enc_to_intel_dp(&encoder->base);

		if (tmp->pps_pipe != INVALID_PIPE)
			pipes &= ~(1 << tmp->pps_pipe);
	}

	/*
	 * Didn't find one. This should not happen since there
	 * are two power sequencers and up to two eDP ports.
	 */
	if (WARN_ON(pipes == 0))
		pipe = PIPE_A;
	else
		pipe = ffs(pipes) - 1;

	vlv_steal_power_sequencer(dev, pipe);
	intel_dp->pps_pipe = pipe;

	DRM_DEBUG_KMS("picked pipe %c power sequencer for port %c\n",
		      pipe_name(intel_dp->pps_pipe),
		      port_name(intel_dig_port->port));

	/* init power sequencer on this pipe and port */
	intel_dp_init_panel_power_sequencer(dev, intel_dp);
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);

	/*
	 * Even vdd force doesn't work until we've made
	 * the power sequencer lock in on the port.
	 */
	vlv_power_sequencer_kick(intel_dp);

	return intel_dp->pps_pipe;
}

typedef bool (*vlv_pipe_check)(struct drm_i915_private *dev_priv,
			       enum pipe pipe);

static bool vlv_pipe_has_pp_on(struct drm_i915_private *dev_priv,
			       enum pipe pipe)
{
	return I915_READ(VLV_PIPE_PP_STATUS(pipe)) & PP_ON;
}

static bool vlv_pipe_has_vdd_on(struct drm_i915_private *dev_priv,
				enum pipe pipe)
{
	return I915_READ(VLV_PIPE_PP_CONTROL(pipe)) & EDP_FORCE_VDD;
}

static bool vlv_pipe_any(struct drm_i915_private *dev_priv,
			 enum pipe pipe)
{
	return true;
}

static enum pipe
vlv_initial_pps_pipe(struct drm_i915_private *dev_priv,
		     enum port port,
		     vlv_pipe_check pipe_check)
{
	enum pipe pipe;

	for (pipe = PIPE_A; pipe <= PIPE_B; pipe++) {
		u32 port_sel = I915_READ(VLV_PIPE_PP_ON_DELAYS(pipe)) &
			PANEL_PORT_SELECT_MASK;

		if (port_sel != PANEL_PORT_SELECT_VLV(port))
			continue;

		if (!pipe_check(dev_priv, pipe))
			continue;

		return pipe;
	}

	return INVALID_PIPE;
}

static void
vlv_initial_power_sequencer_setup(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;

	lockdep_assert_held(&dev_priv->pps_mutex);

	/* try to find a pipe with this port selected */
	/* first pick one where the panel is on */
	intel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,
						  vlv_pipe_has_pp_on);
	/* didn't find one? pick one where vdd is on */
	if (intel_dp->pps_pipe == INVALID_PIPE)
		intel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,
							  vlv_pipe_has_vdd_on);
	/* didn't find one? pick one with just the correct port */
	if (intel_dp->pps_pipe == INVALID_PIPE)
		intel_dp->pps_pipe = vlv_initial_pps_pipe(dev_priv, port,
							  vlv_pipe_any);

	/* didn't find one? just let vlv_power_sequencer_pipe() pick one when needed */
	if (intel_dp->pps_pipe == INVALID_PIPE) {
		DRM_DEBUG_KMS("no initial power sequencer for port %c\n",
			      port_name(port));
		return;
	}

	DRM_DEBUG_KMS("initial power sequencer for port %c: pipe %c\n",
		      port_name(port), pipe_name(intel_dp->pps_pipe));

	intel_dp_init_panel_power_sequencer(dev, intel_dp);
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);
}

void vlv_power_sequencer_reset(struct drm_i915_private *dev_priv)
{
	struct drm_device *dev = dev_priv->dev;
	struct intel_encoder *encoder;

	if (WARN_ON(!IS_VALLEYVIEW(dev)))
		return;

	/*
	 * We can't grab pps_mutex here due to deadlock with power_domain
	 * mutex when power_domain functions are called while holding pps_mutex.
	 * That also means that in order to use pps_pipe the code needs to
	 * hold both a power domain reference and pps_mutex, and the power domain
	 * reference get/put must be done while _not_ holding pps_mutex.
	 * pps_{lock,unlock}() do these steps in the correct order, so one
	 * should use them always.
	 */

	list_for_each_entry(encoder, &dev->mode_config.encoder_list, base.head) {
		struct intel_dp *intel_dp;

		if (encoder->type != INTEL_OUTPUT_EDP)
			continue;

		intel_dp = enc_to_intel_dp(&encoder->base);
		intel_dp->pps_pipe = INVALID_PIPE;
	}
}

static u32 _pp_ctrl_reg(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (IS_BROXTON(dev))
		return BXT_PP_CONTROL(0);
	else if (HAS_PCH_SPLIT(dev))
		return PCH_PP_CONTROL;
	else
		return VLV_PIPE_PP_CONTROL(vlv_power_sequencer_pipe(intel_dp));
}

static u32 _pp_stat_reg(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (IS_BROXTON(dev))
		return BXT_PP_STATUS(0);
	else if (HAS_PCH_SPLIT(dev))
		return PCH_PP_STATUS;
	else
		return VLV_PIPE_PP_STATUS(vlv_power_sequencer_pipe(intel_dp));
}

/* Reboot notifier handler to shutdown panel power to guarantee T12 timing
   This function only applicable when panel PM state is not to be tracked */
static int edp_notify_handler(struct notifier_block *this, unsigned long code,
			      void *unused)
{
	struct intel_dp *intel_dp = container_of(this, typeof(* intel_dp),
						 edp_notifier);
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!is_edp(intel_dp) || code != SYS_RESTART)
		return 0;

	pps_lock(intel_dp);

	if (IS_VALLEYVIEW(dev)) {
		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);
		u32 pp_ctrl_reg, pp_div_reg;
		u32 pp_div;

		pp_ctrl_reg = VLV_PIPE_PP_CONTROL(pipe);
		pp_div_reg  = VLV_PIPE_PP_DIVISOR(pipe);
		pp_div = I915_READ(pp_div_reg);
		pp_div &= PP_REFERENCE_DIVIDER_MASK;

		/* 0x1F write to PP_DIV_REG sets max cycle delay */
		I915_WRITE(pp_div_reg, pp_div | 0x1F);
		I915_WRITE(pp_ctrl_reg, PANEL_UNLOCK_REGS | PANEL_POWER_OFF);
		drm_msleep(intel_dp->panel_power_cycle_delay);
	}

	pps_unlock(intel_dp);

	return 0;
}

static bool edp_have_panel_power(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (IS_VALLEYVIEW(dev) &&
	    intel_dp->pps_pipe == INVALID_PIPE)
		return false;

	return (I915_READ(_pp_stat_reg(intel_dp)) & PP_ON) != 0;
}

static bool edp_have_panel_vdd(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (IS_VALLEYVIEW(dev) &&
	    intel_dp->pps_pipe == INVALID_PIPE)
		return false;

	return I915_READ(_pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD;
}

static void
intel_dp_check_edp(struct intel_dp *intel_dp)
{
#ifdef DRMDEBUG
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
#endif

	if (!is_edp(intel_dp))
		return;

	if (!edp_have_panel_power(intel_dp) && !edp_have_panel_vdd(intel_dp)) {
		WARN(1, "eDP powered off while attempting aux channel communication.\n");
		DRM_DEBUG_KMS("Status 0x%08x Control 0x%08x\n",
			      I915_READ(_pp_stat_reg(intel_dp)),
			      I915_READ(_pp_ctrl_reg(intel_dp)));
	}
}

static uint32_t
intel_dp_aux_wait_done(struct intel_dp *intel_dp, bool has_aux_irq)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t ch_ctl = intel_dp->aux_ch_ctl_reg;
	uint32_t status;
	bool done;

#define C (((status = I915_READ_NOTRACE(ch_ctl)) & DP_AUX_CH_CTL_SEND_BUSY) == 0)
	if (has_aux_irq && !cold)
		done = wait_event_timeout(dev_priv->gmbus_wait_queue, C,
					  msecs_to_jiffies_timeout(10));
	else
		done = wait_for_atomic(C, 10) == 0;
	if (!done)
		DRM_ERROR("dp aux hw did not signal timeout (has irq: %i)!\n",
			  has_aux_irq);
#undef C

	return status;
}

static uint32_t i9xx_get_aux_clock_divider(struct intel_dp *intel_dp, int index)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;

	/*
	 * The clock divider is based off the hrawclk, and would like to run at
	 * 2MHz.  So, take the hrawclk value and divide by 2 and use that
	 */
	return index ? 0 : intel_hrawclk(dev) / 2;
}

static uint32_t ilk_get_aux_clock_divider(struct intel_dp *intel_dp, int index)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (index)
		return 0;

	if (intel_dig_port->port == PORT_A) {
		return DIV_ROUND_UP(dev_priv->cdclk_freq, 2000);

	} else {
		return DIV_ROUND_UP(intel_pch_rawclk(dev), 2);
	}
}

static uint32_t hsw_get_aux_clock_divider(struct intel_dp *intel_dp, int index)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (intel_dig_port->port == PORT_A) {
		if (index)
			return 0;
		return DIV_ROUND_CLOSEST(dev_priv->cdclk_freq, 2000);
	} else if (dev_priv->pch_id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
		/* Workaround for non-ULT HSW */
		switch (index) {
		case 0: return 63;
		case 1: return 72;
		default: return 0;
		}
	} else  {
		return index ? 0 : DIV_ROUND_UP(intel_pch_rawclk(dev), 2);
	}
}

static uint32_t vlv_get_aux_clock_divider(struct intel_dp *intel_dp, int index)
{
	return index ? 0 : 100;
}

static uint32_t skl_get_aux_clock_divider(struct intel_dp *intel_dp, int index)
{
	/*
	 * SKL doesn't need us to program the AUX clock divider (Hardware will
	 * derive the clock from CDCLK automatically). We still implement the
	 * get_aux_clock_divider vfunc to plug-in into the existing code.
	 */
	return index ? 0 : 1;
}

static uint32_t i9xx_get_aux_send_ctl(struct intel_dp *intel_dp,
				      bool has_aux_irq,
				      int send_bytes,
				      uint32_t aux_clock_divider)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	uint32_t precharge, timeout;

	if (IS_GEN6(dev))
		precharge = 3;
	else
		precharge = 5;

	if (IS_BROADWELL(dev) && intel_dp->aux_ch_ctl_reg == DPA_AUX_CH_CTL)
		timeout = DP_AUX_CH_CTL_TIME_OUT_600us;
	else
		timeout = DP_AUX_CH_CTL_TIME_OUT_400us;

	return DP_AUX_CH_CTL_SEND_BUSY |
	       DP_AUX_CH_CTL_DONE |
	       (has_aux_irq ? DP_AUX_CH_CTL_INTERRUPT : 0) |
	       DP_AUX_CH_CTL_TIME_OUT_ERROR |
	       timeout |
	       DP_AUX_CH_CTL_RECEIVE_ERROR |
	       (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
	       (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
	       (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT);
}

static uint32_t skl_get_aux_send_ctl(struct intel_dp *intel_dp,
				      bool has_aux_irq,
				      int send_bytes,
				      uint32_t unused)
{
	return DP_AUX_CH_CTL_SEND_BUSY |
	       DP_AUX_CH_CTL_DONE |
	       (has_aux_irq ? DP_AUX_CH_CTL_INTERRUPT : 0) |
	       DP_AUX_CH_CTL_TIME_OUT_ERROR |
	       DP_AUX_CH_CTL_TIME_OUT_1600us |
	       DP_AUX_CH_CTL_RECEIVE_ERROR |
	       (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
	       DP_AUX_CH_CTL_SYNC_PULSE_SKL(32);
}

static int
intel_dp_aux_ch(struct intel_dp *intel_dp,
		const uint8_t *send, int send_bytes,
		uint8_t *recv, int recv_size)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t ch_ctl = intel_dp->aux_ch_ctl_reg;
	uint32_t ch_data = ch_ctl + 4;
	uint32_t aux_clock_divider;
	int i, ret, recv_bytes;
	uint32_t status;
	int try, clock = 0;
	bool has_aux_irq = HAS_AUX_IRQ(dev);
	bool vdd;

	pps_lock(intel_dp);

	/*
	 * We will be called with VDD already enabled for dpcd/edid/oui reads.
	 * In such cases we want to leave VDD enabled and it's up to upper layers
	 * to turn it off. But for eg. i2c-dev access we need to turn it on/off
	 * ourselves.
	 */
	vdd = edp_panel_vdd_on(intel_dp);

	/* dp aux is extremely sensitive to irq latency, hence request the
	 * lowest possible wakeup latency and so prevent the cpu from going into
	 * deep sleep states.
	 */
	pm_qos_update_request(&dev_priv->pm_qos, 0);

	intel_dp_check_edp(intel_dp);

	/* Try to wait for any previous AUX channel activity */
	for (try = 0; try < 3; try++) {
		status = I915_READ_NOTRACE(ch_ctl);
		if ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)
			break;
		drm_msleep(1);
	}

	if (try == 3) {
		static u32 last_status = -1;
		const u32 status = I915_READ(ch_ctl);

		if (status != last_status) {
			WARN(1, "dp_aux_ch not started status 0x%08x\n",
			     status);
			last_status = status;
		}

		ret = -EBUSY;
		goto out;
	}

	/* Only 5 data registers! */
	if (WARN_ON(send_bytes > 20 || recv_size > 20)) {
		ret = -E2BIG;
		goto out;
	}

	while ((aux_clock_divider = intel_dp->get_aux_clock_divider(intel_dp, clock++))) {
		u32 send_ctl = intel_dp->get_aux_send_ctl(intel_dp,
							  has_aux_irq,
							  send_bytes,
							  aux_clock_divider);

		/* Must try at least 3 times according to DP spec */
		for (try = 0; try < 5; try++) {
			/* Load the send data into the aux channel data registers */
			for (i = 0; i < send_bytes; i += 4)
				I915_WRITE(ch_data + i,
					   intel_dp_pack_aux(send + i,
							     send_bytes - i));

			/* Send the command and wait for it to complete */
			I915_WRITE(ch_ctl, send_ctl);

			status = intel_dp_aux_wait_done(intel_dp, has_aux_irq);

			/* Clear done status and any errors */
			I915_WRITE(ch_ctl,
				   status |
				   DP_AUX_CH_CTL_DONE |
				   DP_AUX_CH_CTL_TIME_OUT_ERROR |
				   DP_AUX_CH_CTL_RECEIVE_ERROR);

			if (status & DP_AUX_CH_CTL_TIME_OUT_ERROR)
				continue;

			/* DP CTS 1.2 Core Rev 1.1, 4.2.1.1 & 4.2.1.2
			 *   400us delay required for errors and timeouts
			 *   Timeout errors from the HW already meet this
			 *   requirement so skip to next iteration
			 */
			if (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {
				usleep_range(400, 500);
				continue;
			}
			if (status & DP_AUX_CH_CTL_DONE)
				goto done;
		}
	}

	if ((status & DP_AUX_CH_CTL_DONE) == 0) {
		DRM_ERROR("dp_aux_ch not done status 0x%08x\n", status);
		ret = -EBUSY;
		goto out;
	}

done:
	/* Check for timeout or receive error.
	 * Timeouts occur when the sink is not connected
	 */
	if (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {
		DRM_ERROR("dp_aux_ch receive error status 0x%08x\n", status);
		ret = -EIO;
		goto out;
	}

	/* Timeouts occur when the device isn't connected, so they're
	 * "normal" -- don't fill the kernel log with these */
	if (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {
		DRM_DEBUG_KMS("dp_aux_ch timeout status 0x%08x\n", status);
		ret = -ETIMEDOUT;
		goto out;
	}

	/* Unload any bytes sent back from the other side */
	recv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>
		      DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);
	if (recv_bytes > recv_size)
		recv_bytes = recv_size;

	for (i = 0; i < recv_bytes; i += 4)
		intel_dp_unpack_aux(I915_READ(ch_data + i),
				    recv + i, recv_bytes - i);

	ret = recv_bytes;
out:
	pm_qos_update_request(&dev_priv->pm_qos, PM_QOS_DEFAULT_VALUE);

	if (vdd)
		edp_panel_vdd_off(intel_dp, false);

	pps_unlock(intel_dp);

	return ret;
}

#define BARE_ADDRESS_SIZE	3
#define HEADER_SIZE		(BARE_ADDRESS_SIZE + 1)
static ssize_t
intel_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)
{
	struct intel_dp *intel_dp = container_of(aux, struct intel_dp, aux);
	uint8_t txbuf[20], rxbuf[20];
	size_t txsize, rxsize;
	int ret;

	txbuf[0] = (msg->request << 4) |
		((msg->address >> 16) & 0xf);
	txbuf[1] = (msg->address >> 8) & 0xff;
	txbuf[2] = msg->address & 0xff;
	txbuf[3] = msg->size - 1;

	switch (msg->request & ~DP_AUX_I2C_MOT) {
	case DP_AUX_NATIVE_WRITE:
	case DP_AUX_I2C_WRITE:
	case DP_AUX_I2C_WRITE_STATUS_UPDATE:
		txsize = msg->size ? HEADER_SIZE + msg->size : BARE_ADDRESS_SIZE;
		rxsize = 2; /* 0 or 1 data bytes */

		if (WARN_ON(txsize > 20))
			return -E2BIG;

		memcpy(txbuf + HEADER_SIZE, msg->buffer, msg->size);

		ret = intel_dp_aux_ch(intel_dp, txbuf, txsize, rxbuf, rxsize);
		if (ret > 0) {
			msg->reply = rxbuf[0] >> 4;

			if (ret > 1) {
				/* Number of bytes written in a short write. */
				ret = clamp_t(int, rxbuf[1], 0, msg->size);
			} else {
				/* Return payload size. */
				ret = msg->size;
			}
		}
		break;

	case DP_AUX_NATIVE_READ:
	case DP_AUX_I2C_READ:
		txsize = msg->size ? HEADER_SIZE : BARE_ADDRESS_SIZE;
		rxsize = msg->size + 1;

		if (WARN_ON(rxsize > 20))
			return -E2BIG;

		ret = intel_dp_aux_ch(intel_dp, txbuf, txsize, rxbuf, rxsize);
		if (ret > 0) {
			msg->reply = rxbuf[0] >> 4;
			/*
			 * Assume happy day, and copy the data. The caller is
			 * expected to check msg->reply before touching it.
			 *
			 * Return payload size.
			 */
			ret--;
			memcpy(msg->buffer, rxbuf + 1, ret);
		}
		break;

	default:
		ret = -EINVAL;
		break;
	}

	return ret;
}

static void
intel_dp_aux_init(struct intel_dp *intel_dp, struct intel_connector *connector)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	enum port port = intel_dig_port->port;
	struct ddi_vbt_port_info *info = &dev_priv->vbt.ddi_port_info[port];
	const char *name = NULL;
	uint32_t porte_aux_ctl_reg = DPA_AUX_CH_CTL;
	int ret;

	/* On SKL we don't have Aux for port E so we rely on VBT to set
	 * a proper alternate aux channel.
	 */
	if ((IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) && port == PORT_E) {
		switch (info->alternate_aux_channel) {
		case DP_AUX_B:
			porte_aux_ctl_reg = DPB_AUX_CH_CTL;
			break;
		case DP_AUX_C:
			porte_aux_ctl_reg = DPC_AUX_CH_CTL;
			break;
		case DP_AUX_D:
			porte_aux_ctl_reg = DPD_AUX_CH_CTL;
			break;
		case DP_AUX_A:
		default:
			porte_aux_ctl_reg = DPA_AUX_CH_CTL;
		}
	}

	switch (port) {
	case PORT_A:
		intel_dp->aux_ch_ctl_reg = DPA_AUX_CH_CTL;
		name = "DPDDC-A";
		break;
	case PORT_B:
		intel_dp->aux_ch_ctl_reg = PCH_DPB_AUX_CH_CTL;
		name = "DPDDC-B";
		break;
	case PORT_C:
		intel_dp->aux_ch_ctl_reg = PCH_DPC_AUX_CH_CTL;
		name = "DPDDC-C";
		break;
	case PORT_D:
		intel_dp->aux_ch_ctl_reg = PCH_DPD_AUX_CH_CTL;
		name = "DPDDC-D";
		break;
	case PORT_E:
		intel_dp->aux_ch_ctl_reg = porte_aux_ctl_reg;
		name = "DPDDC-E";
		break;
	default:
		BUG();
	}

	/*
	 * The AUX_CTL register is usually DP_CTL + 0x10.
	 *
	 * On Haswell and Broadwell though:
	 *   - Both port A DDI_BUF_CTL and DDI_AUX_CTL are on the CPU
	 *   - Port B/C/D AUX channels are on the PCH, DDI_BUF_CTL on the CPU
	 *
	 * Skylake moves AUX_CTL back next to DDI_BUF_CTL, on the CPU.
	 */
	if (!IS_HASWELL(dev) && !IS_BROADWELL(dev) && port != PORT_E)
		intel_dp->aux_ch_ctl_reg = intel_dp->output_reg + 0x10;

	intel_dp->aux.name = name;
	intel_dp->aux.dev = dev->dev;
	intel_dp->aux.transfer = intel_dp_aux_transfer;

#ifdef __linux__
	DRM_DEBUG_KMS("registering %s bus for %s\n", name,
		      connector->base.kdev->kobj.name);
#endif

	ret = drm_dp_aux_register(&intel_dp->aux);
	if (ret < 0) {
		DRM_ERROR("drm_dp_aux_register() for %s failed (%d)\n",
			  name, ret);
		return;
	}

#ifdef __linux__
	ret = sysfs_create_link(&connector->base.kdev->kobj,
				&intel_dp->aux.ddc.dev.kobj,
				intel_dp->aux.ddc.dev.kobj.name);
	if (ret < 0) {
		DRM_ERROR("sysfs_create_link() for %s failed (%d)\n", name, ret);
		drm_dp_aux_unregister(&intel_dp->aux);
	}
#endif
}

static void
intel_dp_connector_unregister(struct intel_connector *intel_connector)
{
#ifdef __linux__
	struct intel_dp *intel_dp = intel_attached_dp(&intel_connector->base);

	if (!intel_connector->mst_port)
		sysfs_remove_link(&intel_connector->base.kdev->kobj,
				  intel_dp->aux.ddc.dev.kobj.name);
#endif
	intel_connector_unregister(intel_connector);
}

static void
skl_edp_set_pll_config(struct intel_crtc_state *pipe_config)
{
	u32 ctrl1;

	memset(&pipe_config->dpll_hw_state, 0,
	       sizeof(pipe_config->dpll_hw_state));

	pipe_config->ddi_pll_sel = SKL_DPLL0;
	pipe_config->dpll_hw_state.cfgcr1 = 0;
	pipe_config->dpll_hw_state.cfgcr2 = 0;

	ctrl1 = DPLL_CTRL1_OVERRIDE(SKL_DPLL0);
	switch (pipe_config->port_clock / 2) {
	case 81000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_810,
					      SKL_DPLL0);
		break;
	case 135000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1350,
					      SKL_DPLL0);
		break;
	case 270000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2700,
					      SKL_DPLL0);
		break;
	case 162000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1620,
					      SKL_DPLL0);
		break;
	/* TBD: For DP link rates 2.16 GHz and 4.32 GHz, VCO is 8640 which
	results in CDCLK change. Need to handle the change of CDCLK by
	disabling pipes and re-enabling them */
	case 108000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_1080,
					      SKL_DPLL0);
		break;
	case 216000:
		ctrl1 |= DPLL_CTRL1_LINK_RATE(DPLL_CTRL1_LINK_RATE_2160,
					      SKL_DPLL0);
		break;

	}
	pipe_config->dpll_hw_state.ctrl1 = ctrl1;
}

void
hsw_dp_set_ddi_pll_sel(struct intel_crtc_state *pipe_config)
{
	memset(&pipe_config->dpll_hw_state, 0,
	       sizeof(pipe_config->dpll_hw_state));

	switch (pipe_config->port_clock / 2) {
	case 81000:
		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_810;
		break;
	case 135000:
		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_1350;
		break;
	case 270000:
		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_2700;
		break;
	}
}

static int
intel_dp_sink_rates(struct intel_dp *intel_dp, const int **sink_rates)
{
	if (intel_dp->num_sink_rates) {
		*sink_rates = intel_dp->sink_rates;
		return intel_dp->num_sink_rates;
	}

	*sink_rates = default_rates;

	return (intel_dp_max_link_bw(intel_dp) >> 3) + 1;
}

static bool intel_dp_source_supports_hbr2(struct drm_device *dev)
{
	/* WaDisableHBR2:skl */
	if (IS_SKL_REVID(dev, 0, SKL_REVID_B0))
		return false;

	if ((IS_HASWELL(dev) && !IS_HSW_ULX(dev)) || IS_BROADWELL(dev) ||
	    (INTEL_INFO(dev)->gen >= 9))
		return true;
	else
		return false;
}

static int
intel_dp_source_rates(struct drm_device *dev, const int **source_rates)
{
	int size;

	if (IS_BROXTON(dev)) {
		*source_rates = bxt_rates;
		size = ARRAY_SIZE(bxt_rates);
	} else if (IS_SKYLAKE(dev) || IS_KABYLAKE(dev)) {
		*source_rates = skl_rates;
		size = ARRAY_SIZE(skl_rates);
	} else {
		*source_rates = default_rates;
		size = ARRAY_SIZE(default_rates);
	}

	/* This depends on the fact that 5.4 is last value in the array */
	if (!intel_dp_source_supports_hbr2(dev))
		size--;

	return size;
}

static void
intel_dp_set_clock(struct intel_encoder *encoder,
		   struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = encoder->base.dev;
	const struct dp_link_dpll *divisor = NULL;
	int i, count = 0;

	if (IS_G4X(dev)) {
		divisor = gen4_dpll;
		count = ARRAY_SIZE(gen4_dpll);
	} else if (HAS_PCH_SPLIT(dev)) {
		divisor = pch_dpll;
		count = ARRAY_SIZE(pch_dpll);
	} else if (IS_CHERRYVIEW(dev)) {
		divisor = chv_dpll;
		count = ARRAY_SIZE(chv_dpll);
	} else if (IS_VALLEYVIEW(dev)) {
		divisor = vlv_dpll;
		count = ARRAY_SIZE(vlv_dpll);
	}

	if (divisor && count) {
		for (i = 0; i < count; i++) {
			if (pipe_config->port_clock == divisor[i].clock) {
				pipe_config->dpll = divisor[i].dpll;
				pipe_config->clock_set = true;
				break;
			}
		}
	}
}

static int intersect_rates(const int *source_rates, int source_len,
			   const int *sink_rates, int sink_len,
			   int *common_rates)
{
	int i = 0, j = 0, k = 0;

	while (i < source_len && j < sink_len) {
		if (source_rates[i] == sink_rates[j]) {
			if (WARN_ON(k >= DP_MAX_SUPPORTED_RATES))
				return k;
			common_rates[k] = source_rates[i];
			++k;
			++i;
			++j;
		} else if (source_rates[i] < sink_rates[j]) {
			++i;
		} else {
			++j;
		}
	}
	return k;
}

static int intel_dp_common_rates(struct intel_dp *intel_dp,
				 int *common_rates)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	const int *source_rates, *sink_rates;
	int source_len, sink_len;

	sink_len = intel_dp_sink_rates(intel_dp, &sink_rates);
	source_len = intel_dp_source_rates(dev, &source_rates);

	return intersect_rates(source_rates, source_len,
			       sink_rates, sink_len,
			       common_rates);
}

static void snprintf_int_array(char *str, size_t len,
			       const int *array, int nelem)
{
	int i;

	str[0] = '\0';

	for (i = 0; i < nelem; i++) {
		int r = snprintf(str, len, "%s%d", i ? ", " : "", array[i]);
		if (r >= len)
			return;
		str += r;
		len -= r;
	}
}

static void intel_dp_print_rates(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	const int *source_rates, *sink_rates;
	int source_len, sink_len, common_len;
	int common_rates[DP_MAX_SUPPORTED_RATES];
	char str[128]; /* FIXME: too big for stack? */

	if ((drm_debug & DRM_UT_KMS) == 0)
		return;

	source_len = intel_dp_source_rates(dev, &source_rates);
	snprintf_int_array(str, sizeof(str), source_rates, source_len);
	DRM_DEBUG_KMS("source rates: %s\n", str);

	sink_len = intel_dp_sink_rates(intel_dp, &sink_rates);
	snprintf_int_array(str, sizeof(str), sink_rates, sink_len);
	DRM_DEBUG_KMS("sink rates: %s\n", str);

	common_len = intel_dp_common_rates(intel_dp, common_rates);
	snprintf_int_array(str, sizeof(str), common_rates, common_len);
	DRM_DEBUG_KMS("common rates: %s\n", str);
}

static int rate_to_index(int find, const int *rates)
{
	int i = 0;

	for (i = 0; i < DP_MAX_SUPPORTED_RATES; ++i)
		if (find == rates[i])
			break;

	return i;
}

int
intel_dp_max_link_rate(struct intel_dp *intel_dp)
{
	int rates[DP_MAX_SUPPORTED_RATES] = {};
	int len;

	len = intel_dp_common_rates(intel_dp, rates);
	if (WARN_ON(len <= 0))
		return 162000;

	return rates[rate_to_index(0, rates) - 1];
}

int intel_dp_rate_select(struct intel_dp *intel_dp, int rate)
{
	return rate_to_index(rate, intel_dp->sink_rates);
}

static void intel_dp_compute_rate(struct intel_dp *intel_dp, int port_clock,
				  uint8_t *link_bw, uint8_t *rate_select)
{
	if (intel_dp->num_sink_rates) {
		*link_bw = 0;
		*rate_select =
			intel_dp_rate_select(intel_dp, port_clock);
	} else {
		*link_bw = drm_dp_link_rate_to_bw_code(port_clock);
		*rate_select = 0;
	}
}

bool
intel_dp_compute_config(struct intel_encoder *encoder,
			struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *intel_crtc = to_intel_crtc(pipe_config->base.crtc);
	struct intel_connector *intel_connector = intel_dp->attached_connector;
	int lane_count, clock;
	int min_lane_count = 1;
	int max_lane_count = intel_dp_max_lane_count(intel_dp);
	/* Conveniently, the link BW constants become indices with a shift...*/
	int min_clock = 0;
	int max_clock;
	int bpp, mode_rate;
	int link_avail, link_clock;
	int common_rates[DP_MAX_SUPPORTED_RATES] = {};
	int common_len;
	uint8_t link_bw, rate_select;

	common_len = intel_dp_common_rates(intel_dp, common_rates);

	/* No common link rates between source and sink */
	WARN_ON(common_len <= 0);

	max_clock = common_len - 1;

	if (HAS_PCH_SPLIT(dev) && !HAS_DDI(dev) && port != PORT_A)
		pipe_config->has_pch_encoder = true;

	pipe_config->has_dp_encoder = true;
	pipe_config->has_drrs = false;
	pipe_config->has_audio = intel_dp->has_audio && port != PORT_A;

	if (is_edp(intel_dp) && intel_connector->panel.fixed_mode) {
		intel_fixed_panel_mode(intel_connector->panel.fixed_mode,
				       adjusted_mode);

		if (INTEL_INFO(dev)->gen >= 9) {
			int ret;
			ret = skl_update_scaler_crtc(pipe_config);
			if (ret)
				return ret;
		}

		if (!HAS_PCH_SPLIT(dev))
			intel_gmch_panel_fitting(intel_crtc, pipe_config,
						 intel_connector->panel.fitting_mode);
		else
			intel_pch_panel_fitting(intel_crtc, pipe_config,
						intel_connector->panel.fitting_mode);
	}

	if (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)
		return false;

	DRM_DEBUG_KMS("DP link computation with max lane count %i "
		      "max bw %d pixel clock %iKHz\n",
		      max_lane_count, common_rates[max_clock],
		      adjusted_mode->crtc_clock);

	/* Walk through all bpp values. Luckily they're all nicely spaced with 2
	 * bpc in between. */
	bpp = pipe_config->pipe_bpp;
	if (is_edp(intel_dp)) {

		/* Get bpp from vbt only for panels that dont have bpp in edid */
		if (intel_connector->base.display_info.bpc == 0 &&
			(dev_priv->vbt.edp_bpp && dev_priv->vbt.edp_bpp < bpp)) {
			DRM_DEBUG_KMS("clamping bpp for eDP panel to BIOS-provided %i\n",
				      dev_priv->vbt.edp_bpp);
			bpp = dev_priv->vbt.edp_bpp;
		}

		/*
		 * Use the maximum clock and number of lanes the eDP panel
		 * advertizes being capable of. The panels are generally
		 * designed to support only a single clock and lane
		 * configuration, and typically these values correspond to the
		 * native resolution of the panel.
		 */
		min_lane_count = max_lane_count;
		min_clock = max_clock;
	}

	for (; bpp >= 6*3; bpp -= 2*3) {
		mode_rate = intel_dp_link_required(adjusted_mode->crtc_clock,
						   bpp);

		for (clock = min_clock; clock <= max_clock; clock++) {
			for (lane_count = min_lane_count;
				lane_count <= max_lane_count;
				lane_count <<= 1) {

				link_clock = common_rates[clock];
				link_avail = intel_dp_max_data_rate(link_clock,
								    lane_count);

				if (mode_rate <= link_avail) {
					goto found;
				}
			}
		}
	}

	return false;

found:
	if (intel_dp->color_range_auto) {
		/*
		 * See:
		 * CEA-861-E - 5.1 Default Encoding Parameters
		 * VESA DisplayPort Ver.1.2a - 5.1.1.1 Video Colorimetry
		 */
		pipe_config->limited_color_range =
			bpp != 18 && drm_match_cea_mode(adjusted_mode) > 1;
	} else {
		pipe_config->limited_color_range =
			intel_dp->limited_color_range;
	}

	pipe_config->lane_count = lane_count;

	pipe_config->pipe_bpp = bpp;
	pipe_config->port_clock = common_rates[clock];

	intel_dp_compute_rate(intel_dp, pipe_config->port_clock,
			      &link_bw, &rate_select);

	DRM_DEBUG_KMS("DP link bw %02x rate select %02x lane count %d clock %d bpp %d\n",
		      link_bw, rate_select, pipe_config->lane_count,
		      pipe_config->port_clock, bpp);
	DRM_DEBUG_KMS("DP link bw required %i available %i\n",
		      mode_rate, link_avail);

	intel_link_compute_m_n(bpp, lane_count,
			       adjusted_mode->crtc_clock,
			       pipe_config->port_clock,
			       &pipe_config->dp_m_n);

	if (intel_connector->panel.downclock_mode != NULL &&
		dev_priv->drrs.type == SEAMLESS_DRRS_SUPPORT) {
			pipe_config->has_drrs = true;
			intel_link_compute_m_n(bpp, lane_count,
				intel_connector->panel.downclock_mode->clock,
				pipe_config->port_clock,
				&pipe_config->dp_m2_n2);
	}

	if ((IS_SKYLAKE(dev)  || IS_KABYLAKE(dev)) && is_edp(intel_dp))
		skl_edp_set_pll_config(pipe_config);
	else if (IS_BROXTON(dev))
		/* handled in ddi */;
	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		hsw_dp_set_ddi_pll_sel(pipe_config);
	else
		intel_dp_set_clock(encoder, pipe_config);

	return true;
}

static void ironlake_set_pll_cpu_edp(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	DRM_DEBUG_KMS("eDP PLL enable for clock %d\n",
		      crtc->config->port_clock);
	dpa_ctl = I915_READ(DP_A);
	dpa_ctl &= ~DP_PLL_FREQ_MASK;

	if (crtc->config->port_clock == 162000) {
		/* For a long time we've carried around a ILK-DevA w/a for the
		 * 160MHz clock. If we're really unlucky, it's still required.
		 */
		DRM_DEBUG_KMS("160MHz cpu eDP clock, might need ilk devA w/a\n");
		dpa_ctl |= DP_PLL_FREQ_160MHZ;
		intel_dp->DP |= DP_PLL_FREQ_160MHZ;
	} else {
		dpa_ctl |= DP_PLL_FREQ_270MHZ;
		intel_dp->DP |= DP_PLL_FREQ_270MHZ;
	}

	I915_WRITE(DP_A, dpa_ctl);

	POSTING_READ(DP_A);
	udelay(500);
}

void intel_dp_set_link_params(struct intel_dp *intel_dp,
			      const struct intel_crtc_state *pipe_config)
{
	intel_dp->link_rate = pipe_config->port_clock;
	intel_dp->lane_count = pipe_config->lane_count;
}

static void intel_dp_prepare(struct intel_encoder *encoder)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	const struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;

	intel_dp_set_link_params(intel_dp, crtc->config);

	/*
	 * There are four kinds of DP registers:
	 *
	 * 	IBX PCH
	 * 	SNB CPU
	 *	IVB CPU
	 * 	CPT PCH
	 *
	 * IBX PCH and CPU are the same for almost everything,
	 * except that the CPU DP PLL is configured in this
	 * register
	 *
	 * CPT PCH is quite different, having many bits moved
	 * to the TRANS_DP_CTL register instead. That
	 * configuration happens (oddly) in ironlake_pch_enable
	 */

	/* Preserve the BIOS-computed detected bit. This is
	 * supposed to be read-only.
	 */
	intel_dp->DP = I915_READ(intel_dp->output_reg) & DP_DETECTED;

	/* Handle DP bits in common between all three register formats */
	intel_dp->DP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;
	intel_dp->DP |= DP_PORT_WIDTH(crtc->config->lane_count);

	if (crtc->config->has_audio)
		intel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;

	/* Split out the IBX/CPU vs CPT settings */

	if (IS_GEN7(dev) && port == PORT_A) {
		if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
			intel_dp->DP |= DP_SYNC_HS_HIGH;
		if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
			intel_dp->DP |= DP_SYNC_VS_HIGH;
		intel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;

		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
			intel_dp->DP |= DP_ENHANCED_FRAMING;

		intel_dp->DP |= crtc->pipe << 29;
	} else if (HAS_PCH_CPT(dev) && port != PORT_A) {
		u32 trans_dp;

		intel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;

		trans_dp = I915_READ(TRANS_DP_CTL(crtc->pipe));
		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
			trans_dp |= TRANS_DP_ENH_FRAMING;
		else
			trans_dp &= ~TRANS_DP_ENH_FRAMING;
		I915_WRITE(TRANS_DP_CTL(crtc->pipe), trans_dp);
	} else {
		if (!HAS_PCH_SPLIT(dev) && !IS_VALLEYVIEW(dev) &&
		    crtc->config->limited_color_range)
			intel_dp->DP |= DP_COLOR_RANGE_16_235;

		if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
			intel_dp->DP |= DP_SYNC_HS_HIGH;
		if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
			intel_dp->DP |= DP_SYNC_VS_HIGH;
		intel_dp->DP |= DP_LINK_TRAIN_OFF;

		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
			intel_dp->DP |= DP_ENHANCED_FRAMING;

		if (IS_CHERRYVIEW(dev))
			intel_dp->DP |= DP_PIPE_SELECT_CHV(crtc->pipe);
		else if (crtc->pipe == PIPE_B)
			intel_dp->DP |= DP_PIPEB_SELECT;
	}
}

#define IDLE_ON_MASK		(PP_ON | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
#define IDLE_ON_VALUE   	(PP_ON | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)

#define IDLE_OFF_MASK		(PP_ON | PP_SEQUENCE_MASK | 0                     | 0)
#define IDLE_OFF_VALUE		(0     | PP_SEQUENCE_NONE | 0                     | 0)

#define IDLE_CYCLE_MASK		(PP_ON | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)
#define IDLE_CYCLE_VALUE	(0     | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)

static void wait_panel_status(struct intel_dp *intel_dp,
				       u32 mask,
				       u32 value)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp_stat_reg, pp_ctrl_reg;

	lockdep_assert_held(&dev_priv->pps_mutex);

	pp_stat_reg = _pp_stat_reg(intel_dp);
	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	DRM_DEBUG_KMS("mask %08x value %08x status %08x control %08x\n",
			mask, value,
			I915_READ(pp_stat_reg),
			I915_READ(pp_ctrl_reg));

	if (_wait_for((I915_READ(pp_stat_reg) & mask) == value, 5000, 10)) {
		DRM_ERROR("Panel status timeout: status %08x control %08x\n",
				I915_READ(pp_stat_reg),
				I915_READ(pp_ctrl_reg));
	}

	DRM_DEBUG_KMS("Wait complete\n");
}

static void wait_panel_on(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power on\n");
	wait_panel_status(intel_dp, IDLE_ON_MASK, IDLE_ON_VALUE);
}

static void wait_panel_off(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power off time\n");
	wait_panel_status(intel_dp, IDLE_OFF_MASK, IDLE_OFF_VALUE);
}

static void wait_panel_power_cycle(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power cycle\n");

	/* When we disable the VDD override bit last we have to do the manual
	 * wait. */
	wait_remaining_ms_from_jiffies(intel_dp->last_power_cycle,
				       intel_dp->panel_power_cycle_delay);

	wait_panel_status(intel_dp, IDLE_CYCLE_MASK, IDLE_CYCLE_VALUE);
}

static void wait_backlight_on(struct intel_dp *intel_dp)
{
	wait_remaining_ms_from_jiffies(intel_dp->last_power_on,
				       intel_dp->backlight_on_delay);
}

static void edp_wait_backlight_off(struct intel_dp *intel_dp)
{
	wait_remaining_ms_from_jiffies(intel_dp->last_backlight_off,
				       intel_dp->backlight_off_delay);
}

/* Read the current pp_control value, unlocking the register if it
 * is locked
 */

static  u32 ironlake_get_pp_control(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 control;

	lockdep_assert_held(&dev_priv->pps_mutex);

	control = I915_READ(_pp_ctrl_reg(intel_dp));
	if (!IS_BROXTON(dev)) {
		control &= ~PANEL_UNLOCK_MASK;
		control |= PANEL_UNLOCK_REGS;
	}
	return control;
}

/*
 * Must be paired with edp_panel_vdd_off().
 * Must hold pps_mutex around the whole on/off sequence.
 * Can be nested with intel_edp_panel_vdd_{on,off}() calls.
 */
static bool edp_panel_vdd_on(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;
	u32 pp;
	u32 pp_stat_reg, pp_ctrl_reg;
	bool need_to_disable = !intel_dp->want_panel_vdd;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!is_edp(intel_dp))
		return false;

	cancel_delayed_work(&intel_dp->panel_vdd_work);
	intel_dp->want_panel_vdd = true;

	if (edp_have_panel_vdd(intel_dp))
		return need_to_disable;

	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_get(dev_priv, power_domain);

	DRM_DEBUG_KMS("Turning eDP port %c VDD on\n",
		      port_name(intel_dig_port->port));

	if (!edp_have_panel_power(intel_dp))
		wait_panel_power_cycle(intel_dp);

	pp = ironlake_get_pp_control(intel_dp);
	pp |= EDP_FORCE_VDD;

	pp_stat_reg = _pp_stat_reg(intel_dp);
	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);
	DRM_DEBUG_KMS("PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\n",
			I915_READ(pp_stat_reg), I915_READ(pp_ctrl_reg));
	/*
	 * If the panel wasn't on, delay before accessing aux channel
	 */
	if (!edp_have_panel_power(intel_dp)) {
		DRM_DEBUG_KMS("eDP port %c panel power wasn't enabled\n",
			      port_name(intel_dig_port->port));
		drm_msleep(intel_dp->panel_power_up_delay);
	}

	return need_to_disable;
}

/*
 * Must be paired with intel_edp_panel_vdd_off() or
 * intel_edp_panel_off().
 * Nested calls to these functions are not allowed since
 * we drop the lock. Caller must use some higher level
 * locking to prevent nested calls from other threads.
 */
void intel_edp_panel_vdd_on(struct intel_dp *intel_dp)
{
	bool vdd;

	if (!is_edp(intel_dp))
		return;

	pps_lock(intel_dp);
	vdd = edp_panel_vdd_on(intel_dp);
	pps_unlock(intel_dp);

	I915_STATE_WARN(!vdd, "eDP port %c VDD already requested on\n",
	     port_name(dp_to_dig_port(intel_dp)->port));
}

static void edp_panel_vdd_off_sync(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port =
		dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	enum intel_display_power_domain power_domain;
	u32 pp;
	u32 pp_stat_reg, pp_ctrl_reg;

	lockdep_assert_held(&dev_priv->pps_mutex);

	WARN_ON(intel_dp->want_panel_vdd);

	if (!edp_have_panel_vdd(intel_dp))
		return;

	DRM_DEBUG_KMS("Turning eDP port %c VDD off\n",
		      port_name(intel_dig_port->port));

	pp = ironlake_get_pp_control(intel_dp);
	pp &= ~EDP_FORCE_VDD;

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
	pp_stat_reg = _pp_stat_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	/* Make sure sequencer is idle before allowing subsequent activity */
	DRM_DEBUG_KMS("PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\n",
	I915_READ(pp_stat_reg), I915_READ(pp_ctrl_reg));

	if ((pp & POWER_TARGET_ON) == 0)
		intel_dp->last_power_cycle = jiffies;

	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_put(dev_priv, power_domain);
}

static void edp_panel_vdd_work(struct work_struct *__work)
{
	struct intel_dp *intel_dp = container_of(to_delayed_work(__work),
						 struct intel_dp, panel_vdd_work);

	pps_lock(intel_dp);
	if (!intel_dp->want_panel_vdd)
		edp_panel_vdd_off_sync(intel_dp);
	pps_unlock(intel_dp);
}

static void edp_panel_vdd_schedule_off(struct intel_dp *intel_dp)
{
	unsigned long delay;

	/*
	 * Queue the timer to fire a long time from now (relative to the power
	 * down delay) to keep the panel power up across a sequence of
	 * operations.
	 */
	delay = msecs_to_jiffies(intel_dp->panel_power_cycle_delay * 5);
	schedule_delayed_work(&intel_dp->panel_vdd_work, delay);
}

/*
 * Must be paired with edp_panel_vdd_on().
 * Must hold pps_mutex around the whole on/off sequence.
 * Can be nested with intel_edp_panel_vdd_{on,off}() calls.
 */
static void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
{
	struct drm_i915_private *dev_priv =
		intel_dp_to_dev(intel_dp)->dev_private;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!is_edp(intel_dp))
		return;

	I915_STATE_WARN(!intel_dp->want_panel_vdd, "eDP port %c VDD not forced on",
	     port_name(dp_to_dig_port(intel_dp)->port));

	intel_dp->want_panel_vdd = false;

	if (sync)
		edp_panel_vdd_off_sync(intel_dp);
	else
		edp_panel_vdd_schedule_off(intel_dp);
}

static void edp_panel_on(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("Turn eDP port %c panel power on\n",
		      port_name(dp_to_dig_port(intel_dp)->port));

	if (WARN(edp_have_panel_power(intel_dp),
		 "eDP port %c panel power already on\n",
		 port_name(dp_to_dig_port(intel_dp)->port)))
		return;

	wait_panel_power_cycle(intel_dp);

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
	pp = ironlake_get_pp_control(intel_dp);
	if (IS_GEN5(dev)) {
		/* ILK workaround: disable reset around power sequence */
		pp &= ~PANEL_POWER_RESET;
		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);
	}

	pp |= POWER_TARGET_ON;
	if (!IS_GEN5(dev))
		pp |= PANEL_POWER_RESET;

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	wait_panel_on(intel_dp);
	intel_dp->last_power_on = jiffies;

	if (IS_GEN5(dev)) {
		pp |= PANEL_POWER_RESET; /* restore panel reset bit */
		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);
	}
}

void intel_edp_panel_on(struct intel_dp *intel_dp)
{
	if (!is_edp(intel_dp))
		return;

	pps_lock(intel_dp);
	edp_panel_on(intel_dp);
	pps_unlock(intel_dp);
}


static void edp_panel_off(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;
	u32 pp;
	u32 pp_ctrl_reg;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("Turn eDP port %c panel power off\n",
		      port_name(dp_to_dig_port(intel_dp)->port));

	WARN(!intel_dp->want_panel_vdd, "Need eDP port %c VDD to turn off panel\n",
	     port_name(dp_to_dig_port(intel_dp)->port));

	pp = ironlake_get_pp_control(intel_dp);
	/* We need to switch off panel power _and_ force vdd, for otherwise some
	 * panels get very unhappy and cease to work. */
	pp &= ~(POWER_TARGET_ON | PANEL_POWER_RESET | EDP_FORCE_VDD |
		EDP_BLC_ENABLE);

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	intel_dp->want_panel_vdd = false;

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	intel_dp->last_power_cycle = jiffies;
	wait_panel_off(intel_dp);

	/* We got a reference when we enabled the VDD. */
	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_put(dev_priv, power_domain);
}

void intel_edp_panel_off(struct intel_dp *intel_dp)
{
	if (!is_edp(intel_dp))
		return;

	pps_lock(intel_dp);
	edp_panel_off(intel_dp);
	pps_unlock(intel_dp);
}

/* Enable backlight in the panel power control. */
static void _intel_edp_backlight_on(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	/*
	 * If we enable the backlight right away following a panel power
	 * on, we may see slight flicker as the panel syncs with the eDP
	 * link.  So delay a bit to make sure the image is solid before
	 * allowing it to appear.
	 */
	wait_backlight_on(intel_dp);

	pps_lock(intel_dp);

	pp = ironlake_get_pp_control(intel_dp);
	pp |= EDP_BLC_ENABLE;

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	pps_unlock(intel_dp);
}

/* Enable backlight PWM and backlight PP control. */
void intel_edp_backlight_on(struct intel_dp *intel_dp)
{
	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("\n");

	intel_panel_enable_backlight(intel_dp->attached_connector);
	_intel_edp_backlight_on(intel_dp);
}

/* Disable backlight in the panel power control. */
static void _intel_edp_backlight_off(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	pps_lock(intel_dp);

	pp = ironlake_get_pp_control(intel_dp);
	pp &= ~EDP_BLC_ENABLE;

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	pps_unlock(intel_dp);

	intel_dp->last_backlight_off = jiffies;
	edp_wait_backlight_off(intel_dp);
}

/* Disable backlight PP control and backlight PWM. */
void intel_edp_backlight_off(struct intel_dp *intel_dp)
{
	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("\n");

	_intel_edp_backlight_off(intel_dp);
	intel_panel_disable_backlight(intel_dp->attached_connector);
}

/*
 * Hook for controlling the panel power control backlight through the bl_power
 * sysfs attribute. Take care to handle multiple calls.
 */
static void intel_edp_backlight_power(struct intel_connector *connector,
				      bool enable)
{
	struct intel_dp *intel_dp = intel_attached_dp(&connector->base);
	bool is_enabled;

	pps_lock(intel_dp);
	is_enabled = ironlake_get_pp_control(intel_dp) & EDP_BLC_ENABLE;
	pps_unlock(intel_dp);

	if (is_enabled == enable)
		return;

	DRM_DEBUG_KMS("panel power control backlight %s\n",
		      enable ? "enable" : "disable");

	if (enable)
		_intel_edp_backlight_on(intel_dp);
	else
		_intel_edp_backlight_off(intel_dp);
}

static void ironlake_edp_pll_on(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	assert_pipe_disabled(dev_priv,
			     to_intel_crtc(crtc)->pipe);

	DRM_DEBUG_KMS("\n");
	dpa_ctl = I915_READ(DP_A);
	WARN(dpa_ctl & DP_PLL_ENABLE, "dp pll on, should be off\n");
	WARN(dpa_ctl & DP_PORT_EN, "dp port still on, should be off\n");

	/* We don't adjust intel_dp->DP while tearing down the link, to
	 * facilitate link retraining (e.g. after hotplug). Hence clear all
	 * enable bits here to ensure that we don't enable too much. */
	intel_dp->DP &= ~(DP_PORT_EN | DP_AUDIO_OUTPUT_ENABLE);
	intel_dp->DP |= DP_PLL_ENABLE;
	I915_WRITE(DP_A, intel_dp->DP);
	POSTING_READ(DP_A);
	udelay(200);
}

static void ironlake_edp_pll_off(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	assert_pipe_disabled(dev_priv,
			     to_intel_crtc(crtc)->pipe);

	dpa_ctl = I915_READ(DP_A);
	WARN((dpa_ctl & DP_PLL_ENABLE) == 0,
	     "dp pll off, should be on\n");
	WARN(dpa_ctl & DP_PORT_EN, "dp port still on, should be off\n");

	/* We can't rely on the value tracked for the DP register in
	 * intel_dp->DP because link_down must not change that (otherwise link
	 * re-training will fail. */
	dpa_ctl &= ~DP_PLL_ENABLE;
	I915_WRITE(DP_A, dpa_ctl);
	POSTING_READ(DP_A);
	udelay(200);
}

/* If the sink supports it, try to set the power state appropriately */
void intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode)
{
	int ret, i;

	/* Should have a valid DPCD by this point */
	if (intel_dp->dpcd[DP_DPCD_REV] < 0x11)
		return;

	if (mode != DRM_MODE_DPMS_ON) {
		ret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER,
					 DP_SET_POWER_D3);
	} else {
		/*
		 * When turning on, we need to retry for 1ms to give the sink
		 * time to wake up.
		 */
		for (i = 0; i < 3; i++) {
			ret = drm_dp_dpcd_writeb(&intel_dp->aux, DP_SET_POWER,
						 DP_SET_POWER_D0);
			if (ret == 1)
				break;
			drm_msleep(1);
		}
	}

	if (ret != 1)
		DRM_DEBUG_KMS("failed to %s sink power state\n",
			      mode == DRM_MODE_DPMS_ON ? "enable" : "disable");
}

static bool intel_dp_get_hw_state(struct intel_encoder *encoder,
				  enum pipe *pipe)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;
	u32 tmp;

	power_domain = intel_display_port_power_domain(encoder);
	if (!intel_display_power_is_enabled(dev_priv, power_domain))
		return false;

	tmp = I915_READ(intel_dp->output_reg);

	if (!(tmp & DP_PORT_EN))
		return false;

	if (IS_GEN7(dev) && port == PORT_A) {
		*pipe = PORT_TO_PIPE_CPT(tmp);
	} else if (HAS_PCH_CPT(dev) && port != PORT_A) {
		enum pipe p;

		for_each_pipe(dev_priv, p) {
			u32 trans_dp = I915_READ(TRANS_DP_CTL(p));
			if (TRANS_DP_PIPE_TO_PORT(trans_dp) == port) {
				*pipe = p;
				return true;
			}
		}

		DRM_DEBUG_KMS("No pipe for dp port 0x%x found\n",
			      intel_dp->output_reg);
	} else if (IS_CHERRYVIEW(dev)) {
		*pipe = DP_PORT_TO_PIPE_CHV(tmp);
	} else {
		*pipe = PORT_TO_PIPE(tmp);
	}

	return true;
}

static void intel_dp_get_config(struct intel_encoder *encoder,
				struct intel_crtc_state *pipe_config)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	u32 tmp, flags = 0;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	int dotclock;

	tmp = I915_READ(intel_dp->output_reg);

	pipe_config->has_audio = tmp & DP_AUDIO_OUTPUT_ENABLE && port != PORT_A;

	if (HAS_PCH_CPT(dev) && port != PORT_A) {
		u32 trans_dp = I915_READ(TRANS_DP_CTL(crtc->pipe));

		if (trans_dp & TRANS_DP_HSYNC_ACTIVE_HIGH)
			flags |= DRM_MODE_FLAG_PHSYNC;
		else
			flags |= DRM_MODE_FLAG_NHSYNC;

		if (trans_dp & TRANS_DP_VSYNC_ACTIVE_HIGH)
			flags |= DRM_MODE_FLAG_PVSYNC;
		else
			flags |= DRM_MODE_FLAG_NVSYNC;
	} else {
		if (tmp & DP_SYNC_HS_HIGH)
			flags |= DRM_MODE_FLAG_PHSYNC;
		else
			flags |= DRM_MODE_FLAG_NHSYNC;

		if (tmp & DP_SYNC_VS_HIGH)
			flags |= DRM_MODE_FLAG_PVSYNC;
		else
			flags |= DRM_MODE_FLAG_NVSYNC;
	}

	pipe_config->base.adjusted_mode.flags |= flags;

	if (!HAS_PCH_SPLIT(dev) && !IS_VALLEYVIEW(dev) &&
	    tmp & DP_COLOR_RANGE_16_235)
		pipe_config->limited_color_range = true;

	pipe_config->has_dp_encoder = true;

	pipe_config->lane_count =
		((tmp & DP_PORT_WIDTH_MASK) >> DP_PORT_WIDTH_SHIFT) + 1;

	intel_dp_get_m_n(crtc, pipe_config);

	if (port == PORT_A) {
		if ((I915_READ(DP_A) & DP_PLL_FREQ_MASK) == DP_PLL_FREQ_160MHZ)
			pipe_config->port_clock = 162000;
		else
			pipe_config->port_clock = 270000;
	}

	dotclock = intel_dotclock_calculate(pipe_config->port_clock,
					    &pipe_config->dp_m_n);

	if (HAS_PCH_SPLIT(dev_priv->dev) && port != PORT_A)
		ironlake_check_encoder_dotclock(pipe_config, dotclock);

	pipe_config->base.adjusted_mode.crtc_clock = dotclock;

	if (is_edp(intel_dp) && dev_priv->vbt.edp_bpp &&
	    pipe_config->pipe_bpp > dev_priv->vbt.edp_bpp) {
		/*
		 * This is a big fat ugly hack.
		 *
		 * Some machines in UEFI boot mode provide us a VBT that has 18
		 * bpp and 1.62 GHz link bandwidth for eDP, which for reasons
		 * unknown we fail to light up. Yet the same BIOS boots up with
		 * 24 bpp and 2.7 GHz link. Use the same bpp as the BIOS uses as
		 * max, not what it tells us to use.
		 *
		 * Note: This will still be broken if the eDP panel is not lit
		 * up by the BIOS, and thus we can't get the mode at module
		 * load.
		 */
		DRM_DEBUG_KMS("pipe has %d bpp for eDP panel, overriding BIOS-provided max %d bpp\n",
			      pipe_config->pipe_bpp, dev_priv->vbt.edp_bpp);
		dev_priv->vbt.edp_bpp = pipe_config->pipe_bpp;
	}
}

static void intel_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);

	if (crtc->config->has_audio)
		intel_audio_codec_disable(encoder);

	if (HAS_PSR(dev) && !HAS_DDI(dev))
		intel_psr_disable(intel_dp);

	/* Make sure the panel is off before trying to change the mode. But also
	 * ensure that we have vdd while we switch off the panel. */
	intel_edp_panel_vdd_on(intel_dp);
	intel_edp_backlight_off(intel_dp);
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
	intel_edp_panel_off(intel_dp);

	/* disable the port before the pipe on g4x */
	if (INTEL_INFO(dev)->gen < 5)
		intel_dp_link_down(intel_dp);
}

static void ilk_post_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;

	intel_dp_link_down(intel_dp);
	if (port == PORT_A)
		ironlake_edp_pll_off(intel_dp);
}

static void vlv_post_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);

	intel_dp_link_down(intel_dp);
}

static void chv_data_lane_soft_reset(struct intel_encoder *encoder,
				     bool reset)
{
	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
	enum dpio_channel ch = vlv_dport_to_channel(enc_to_dig_port(&encoder->base));
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	enum pipe pipe = crtc->pipe;
	uint32_t val;

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW0(ch));
	if (reset)
		val &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);
	else
		val |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW0(ch), val);

	if (crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW0(ch));
		if (reset)
			val &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);
		else
			val |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW0(ch), val);
	}

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW1(ch));
	val |= CHV_PCS_REQ_SOFTRESET_EN;
	if (reset)
		val &= ~DPIO_PCS_CLK_SOFT_RESET;
	else
		val |= DPIO_PCS_CLK_SOFT_RESET;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW1(ch), val);

	if (crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW1(ch));
		val |= CHV_PCS_REQ_SOFTRESET_EN;
		if (reset)
			val &= ~DPIO_PCS_CLK_SOFT_RESET;
		else
			val |= DPIO_PCS_CLK_SOFT_RESET;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW1(ch), val);
	}
}

static void chv_post_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	intel_dp_link_down(intel_dp);

	mutex_lock(&dev_priv->sb_lock);

	/* Assert data lane reset */
	chv_data_lane_soft_reset(encoder, true);

	mutex_unlock(&dev_priv->sb_lock);
}

static void
_intel_dp_set_link_train(struct intel_dp *intel_dp,
			 uint32_t *DP,
			 uint8_t dp_train_pat)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;

	if (HAS_DDI(dev)) {
		uint32_t temp = I915_READ(DP_TP_CTL(port));

		if (dp_train_pat & DP_LINK_SCRAMBLING_DISABLE)
			temp |= DP_TP_CTL_SCRAMBLE_DISABLE;
		else
			temp &= ~DP_TP_CTL_SCRAMBLE_DISABLE;

		temp &= ~DP_TP_CTL_LINK_TRAIN_MASK;
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			temp |= DP_TP_CTL_LINK_TRAIN_NORMAL;

			break;
		case DP_TRAINING_PATTERN_1:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
			break;
		case DP_TRAINING_PATTERN_2:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT2;
			break;
		case DP_TRAINING_PATTERN_3:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT3;
			break;
		}
		I915_WRITE(DP_TP_CTL(port), temp);

	} else if ((IS_GEN7(dev) && port == PORT_A) ||
		   (HAS_PCH_CPT(dev) && port != PORT_A)) {
		*DP &= ~DP_LINK_TRAIN_MASK_CPT;

		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF_CPT;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1_CPT;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		}

	} else {
		if (IS_CHERRYVIEW(dev))
			*DP &= ~DP_LINK_TRAIN_MASK_CHV;
		else
			*DP &= ~DP_LINK_TRAIN_MASK;

		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2;
			break;
		case DP_TRAINING_PATTERN_3:
			if (IS_CHERRYVIEW(dev)) {
				*DP |= DP_LINK_TRAIN_PAT_3_CHV;
			} else {
				DRM_ERROR("DP training pattern 3 not supported\n");
				*DP |= DP_LINK_TRAIN_PAT_2;
			}
			break;
		}
	}
}

static void intel_dp_enable_port(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* enable with pattern 1 (as per spec) */
	_intel_dp_set_link_train(intel_dp, &intel_dp->DP,
				 DP_TRAINING_PATTERN_1);

	I915_WRITE(intel_dp->output_reg, intel_dp->DP);
	POSTING_READ(intel_dp->output_reg);

	/*
	 * Magic for VLV/CHV. We _must_ first set up the register
	 * without actually enabling the port, and then do another
	 * write to enable the port. Otherwise link training will
	 * fail when the power sequencer is freshly used for this port.
	 */
	intel_dp->DP |= DP_PORT_EN;

	I915_WRITE(intel_dp->output_reg, intel_dp->DP);
	POSTING_READ(intel_dp->output_reg);
}

static void intel_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	uint32_t dp_reg = I915_READ(intel_dp->output_reg);

	if (WARN_ON(dp_reg & DP_PORT_EN))
		return;

	pps_lock(intel_dp);

	if (IS_VALLEYVIEW(dev))
		vlv_init_panel_power_sequencer(intel_dp);

	intel_dp_enable_port(intel_dp);

	edp_panel_vdd_on(intel_dp);
	edp_panel_on(intel_dp);
	edp_panel_vdd_off(intel_dp, true);

	pps_unlock(intel_dp);

	if (IS_VALLEYVIEW(dev)) {
		unsigned int lane_mask = 0x0;

		if (IS_CHERRYVIEW(dev))
			lane_mask = intel_dp_unused_lane_mask(crtc->config->lane_count);

		vlv_wait_port_ready(dev_priv, dp_to_dig_port(intel_dp),
				    lane_mask);
	}

	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
	intel_dp_start_link_train(intel_dp);
	intel_dp_stop_link_train(intel_dp);

	if (crtc->config->has_audio) {
		DRM_DEBUG_DRIVER("Enabling DP audio on pipe %c\n",
				 pipe_name(crtc->pipe));
		intel_audio_codec_enable(encoder);
	}
}

static void g4x_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);

	intel_enable_dp(encoder);
	intel_edp_backlight_on(intel_dp);
}

static void vlv_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);

	intel_edp_backlight_on(intel_dp);
	intel_psr_enable(intel_dp);
}

static void g4x_pre_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);

	intel_dp_prepare(encoder);

	/* Only ilk+ has port A */
	if (dport->port == PORT_A) {
		ironlake_set_pll_cpu_edp(intel_dp);
		ironlake_edp_pll_on(intel_dp);
	}
}

static void vlv_detach_power_sequencer(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_i915_private *dev_priv = intel_dig_port->base.base.dev->dev_private;
	enum pipe pipe = intel_dp->pps_pipe;
	int pp_on_reg = VLV_PIPE_PP_ON_DELAYS(pipe);

	edp_panel_vdd_off_sync(intel_dp);

	/*
	 * VLV seems to get confused when multiple power seqeuencers
	 * have the same port selected (even if only one has power/vdd
	 * enabled). The failure manifests as vlv_wait_port_ready() failing
	 * CHV on the other hand doesn't seem to mind having the same port
	 * selected in multiple power seqeuencers, but let's clear the
	 * port select always when logically disconnecting a power sequencer
	 * from a port.
	 */
	DRM_DEBUG_KMS("detaching pipe %c power sequencer from port %c\n",
		      pipe_name(pipe), port_name(intel_dig_port->port));
	I915_WRITE(pp_on_reg, 0);
	POSTING_READ(pp_on_reg);

	intel_dp->pps_pipe = INVALID_PIPE;
}

static void vlv_steal_power_sequencer(struct drm_device *dev,
				      enum pipe pipe)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (WARN_ON(pipe != PIPE_A && pipe != PIPE_B))
		return;

	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
		struct intel_dp *intel_dp;
		enum port port;

		if (encoder->type != INTEL_OUTPUT_EDP)
			continue;

		intel_dp = enc_to_intel_dp(&encoder->base);
		port = dp_to_dig_port(intel_dp)->port;

		if (intel_dp->pps_pipe != pipe)
			continue;

		DRM_DEBUG_KMS("stealing pipe %c power sequencer from port %c\n",
			      pipe_name(pipe), port_name(port));

		WARN(encoder->base.crtc,
		     "stealing pipe %c power sequencer from active eDP port %c\n",
		     pipe_name(pipe), port_name(port));

		/* make sure vdd is off before we steal it */
		vlv_detach_power_sequencer(intel_dp);
	}
}

static void vlv_init_panel_power_sequencer(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *encoder = &intel_dig_port->base;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!is_edp(intel_dp))
		return;

	if (intel_dp->pps_pipe == crtc->pipe)
		return;

	/*
	 * If another power sequencer was being used on this
	 * port previously make sure to turn off vdd there while
	 * we still have control of it.
	 */
	if (intel_dp->pps_pipe != INVALID_PIPE)
		vlv_detach_power_sequencer(intel_dp);

	/*
	 * We may be stealing the power
	 * sequencer from another port.
	 */
	vlv_steal_power_sequencer(dev, crtc->pipe);

	/* now it's all ours */
	intel_dp->pps_pipe = crtc->pipe;

	DRM_DEBUG_KMS("initializing pipe %c power sequencer for port %c\n",
		      pipe_name(intel_dp->pps_pipe), port_name(intel_dig_port->port));

	/* init power sequencer on this pipe and port */
	intel_dp_init_panel_power_sequencer(dev, intel_dp);
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);
}

static void vlv_pre_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;
	u32 val;

	mutex_lock(&dev_priv->sb_lock);

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(port));
	val = 0;
	if (pipe)
		val |= (1<<21);
	else
		val &= ~(1<<21);
	val |= 0x001000c4;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW8(port), val);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW14(port), 0x00760018);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW23(port), 0x00400888);

	mutex_unlock(&dev_priv->sb_lock);

	intel_enable_dp(encoder);
}

static void vlv_dp_pre_pll_enable(struct intel_encoder *encoder)
{
	struct intel_digital_port *dport = enc_to_dig_port(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(encoder->base.crtc);
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;

	intel_dp_prepare(encoder);

	/* Program Tx lane resets to default */
	mutex_lock(&dev_priv->sb_lock);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port),
			 DPIO_PCS_TX_LANE2_RESET |
			 DPIO_PCS_TX_LANE1_RESET);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port),
			 DPIO_PCS_CLK_CRI_RXEB_EIOS_EN |
			 DPIO_PCS_CLK_CRI_RXDIGFILTSG_EN |
			 (1<<DPIO_PCS_CLK_DATAWIDTH_SHIFT) |
				 DPIO_PCS_CLK_SOFT_RESET);

	/* Fix up inter-pair skew failure */
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW12(port), 0x00750f00);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW11(port), 0x00001500);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW14(port), 0x40400000);
	mutex_unlock(&dev_priv->sb_lock);
}

static void chv_pre_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(encoder->base.crtc);
	enum dpio_channel ch = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;
	int data, i, stagger;
	u32 val;

	mutex_lock(&dev_priv->sb_lock);

	/* allow hardware to manage TX FIFO reset source */
	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));
	val &= ~DPIO_LANEDESKEW_STRAP_OVRD;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));
		val &= ~DPIO_LANEDESKEW_STRAP_OVRD;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);
	}

	/* Program Tx lane latency optimal setting*/
	for (i = 0; i < intel_crtc->config->lane_count; i++) {
		/* Set the upar bit */
		if (intel_crtc->config->lane_count == 1)
			data = 0x0;
		else
			data = (i == 1) ? 0x0 : 0x1;
		vlv_dpio_write(dev_priv, pipe, CHV_TX_DW14(ch, i),
				data << DPIO_UPAR_SHIFT);
	}

	/* Data lane stagger programming */
	if (intel_crtc->config->port_clock > 270000)
		stagger = 0x18;
	else if (intel_crtc->config->port_clock > 135000)
		stagger = 0xd;
	else if (intel_crtc->config->port_clock > 67500)
		stagger = 0x7;
	else if (intel_crtc->config->port_clock > 33750)
		stagger = 0x4;
	else
		stagger = 0x2;

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));
	val |= DPIO_TX2_STAGGER_MASK(0x1f);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));
		val |= DPIO_TX2_STAGGER_MASK(0x1f);
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);
	}

	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW12(ch),
		       DPIO_LANESTAGGER_STRAP(stagger) |
		       DPIO_LANESTAGGER_STRAP_OVRD |
		       DPIO_TX1_STAGGER_MASK(0x1f) |
		       DPIO_TX1_STAGGER_MULT(6) |
		       DPIO_TX2_STAGGER_MULT(0));

	if (intel_crtc->config->lane_count > 2) {
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW12(ch),
			       DPIO_LANESTAGGER_STRAP(stagger) |
			       DPIO_LANESTAGGER_STRAP_OVRD |
			       DPIO_TX1_STAGGER_MASK(0x1f) |
			       DPIO_TX1_STAGGER_MULT(7) |
			       DPIO_TX2_STAGGER_MULT(5));
	}

	/* Deassert data lane reset */
	chv_data_lane_soft_reset(encoder, false);

	mutex_unlock(&dev_priv->sb_lock);

	intel_enable_dp(encoder);

	/* Second common lane will stay alive on its own now */
	if (dport->release_cl2_override) {
		chv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, false);
		dport->release_cl2_override = false;
	}
}

static void chv_dp_pre_pll_enable(struct intel_encoder *encoder)
{
	struct intel_digital_port *dport = enc_to_dig_port(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(encoder->base.crtc);
	enum dpio_channel ch = vlv_dport_to_channel(dport);
	enum pipe pipe = intel_crtc->pipe;
	unsigned int lane_mask =
		intel_dp_unused_lane_mask(intel_crtc->config->lane_count);
	u32 val;

	intel_dp_prepare(encoder);

	/*
	 * Must trick the second common lane into life.
	 * Otherwise we can't even access the PLL.
	 */
	if (ch == DPIO_CH0 && pipe == PIPE_B)
		dport->release_cl2_override =
			!chv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, true);

	chv_phy_powergate_lanes(encoder, true, lane_mask);

	mutex_lock(&dev_priv->sb_lock);

	/* Assert data lane reset */
	chv_data_lane_soft_reset(encoder, true);

	/* program left/right clock distribution */
	if (pipe != PIPE_B) {
		val = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);
		val &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);
		if (ch == DPIO_CH0)
			val |= CHV_BUFLEFTENA1_FORCE;
		if (ch == DPIO_CH1)
			val |= CHV_BUFRIGHTENA1_FORCE;
		vlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);
	} else {
		val = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);
		val &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);
		if (ch == DPIO_CH0)
			val |= CHV_BUFLEFTENA2_FORCE;
		if (ch == DPIO_CH1)
			val |= CHV_BUFRIGHTENA2_FORCE;
		vlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);
	}

	/* program clock channel usage */
	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(ch));
	val |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;
	if (pipe != PIPE_B)
		val &= ~CHV_PCS_USEDCLKCHANNEL;
	else
		val |= CHV_PCS_USEDCLKCHANNEL;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW8(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW8(ch));
		val |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;
		if (pipe != PIPE_B)
			val &= ~CHV_PCS_USEDCLKCHANNEL;
		else
			val |= CHV_PCS_USEDCLKCHANNEL;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW8(ch), val);
	}

	/*
	 * This a a bit weird since generally CL
	 * matches the pipe, but here we need to
	 * pick the CL based on the port.
	 */
	val = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW19(ch));
	if (pipe != PIPE_B)
		val &= ~CHV_CMN_USEDCLKCHANNEL;
	else
		val |= CHV_CMN_USEDCLKCHANNEL;
	vlv_dpio_write(dev_priv, pipe, CHV_CMN_DW19(ch), val);

	mutex_unlock(&dev_priv->sb_lock);
}

static void chv_dp_post_pll_disable(struct intel_encoder *encoder)
{
	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
	enum pipe pipe = to_intel_crtc(encoder->base.crtc)->pipe;
	u32 val;

	mutex_lock(&dev_priv->sb_lock);

	/* disable left/right clock distribution */
	if (pipe != PIPE_B) {
		val = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);
		val &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);
		vlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);
	} else {
		val = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);
		val &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);
		vlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);
	}

	mutex_unlock(&dev_priv->sb_lock);

	/*
	 * Leave the power down bit cleared for at least one
	 * lane so that chv_powergate_phy_ch() will power
	 * on something when the channel is otherwise unused.
	 * When the port is off and the override is removed
	 * the lanes power down anyway, so otherwise it doesn't
	 * really matter what the state of power down bits is
	 * after this.
	 */
	chv_phy_powergate_lanes(encoder, false, 0x0);
}

/*
 * Native read with retry for link status and receiver capability reads for
 * cases where the sink may still be asleep.
 *
 * Sinks are *supposed* to come up within 1ms from an off state, but we're also
 * supposed to retry 3 times per the spec.
 */
static ssize_t
intel_dp_dpcd_read_wake(struct drm_dp_aux *aux, unsigned int offset,
			void *buffer, size_t size)
{
	ssize_t ret;
	int i;

	/*
	 * Sometime we just get the same incorrect byte repeated
	 * over the entire buffer. Doing just one throw away read
	 * initially seems to "solve" it.
	 */
	drm_dp_dpcd_read(aux, DP_DPCD_REV, buffer, 1);

	for (i = 0; i < 3; i++) {
		ret = drm_dp_dpcd_read(aux, offset, buffer, size);
		if (ret == size)
			return ret;
		drm_msleep(1);
	}

	return ret;
}

/*
 * Fetch AUX CH registers 0x202 - 0x207 which contain
 * link status information
 */
static bool
intel_dp_get_link_status(struct intel_dp *intel_dp, uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	return intel_dp_dpcd_read_wake(&intel_dp->aux,
				       DP_LANE0_1_STATUS,
				       link_status,
				       DP_LINK_STATUS_SIZE) == DP_LINK_STATUS_SIZE;
}

/* These are source-specific values. */
static uint8_t
intel_dp_voltage_max(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = dp_to_dig_port(intel_dp)->port;

	if (IS_BROXTON(dev))
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
	else if (INTEL_INFO(dev)->gen >= 9) {
		if (dev_priv->edp_low_vswing && port == PORT_A)
			return DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
	} else if (IS_VALLEYVIEW(dev))
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
	else if (IS_GEN7(dev) && port == PORT_A)
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
	else if (HAS_PCH_CPT(dev) && port != PORT_A)
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
	else
		return DP_TRAIN_VOLTAGE_SWING_LEVEL_2;
}

static uint8_t
intel_dp_pre_emphasis_max(struct intel_dp *intel_dp, uint8_t voltage_swing)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	enum port port = dp_to_dig_port(intel_dp)->port;

	if (INTEL_INFO(dev)->gen >= 9) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			return DP_TRAIN_PRE_EMPH_LEVEL_3;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			return DP_TRAIN_PRE_EMPH_LEVEL_1;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		default:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		}
	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			return DP_TRAIN_PRE_EMPH_LEVEL_3;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			return DP_TRAIN_PRE_EMPH_LEVEL_1;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
		default:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		}
	} else if (IS_VALLEYVIEW(dev)) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			return DP_TRAIN_PRE_EMPH_LEVEL_3;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			return DP_TRAIN_PRE_EMPH_LEVEL_1;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
		default:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		}
	} else if (IS_GEN7(dev) && port == PORT_A) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			return DP_TRAIN_PRE_EMPH_LEVEL_1;
		default:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		}
	} else {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			return DP_TRAIN_PRE_EMPH_LEVEL_2;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			return DP_TRAIN_PRE_EMPH_LEVEL_1;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
		default:
			return DP_TRAIN_PRE_EMPH_LEVEL_0;
		}
	}
}

static uint32_t vlv_signal_levels(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dport->base.base.crtc);
	unsigned long demph_reg_value, preemph_reg_value,
		uniqtranscale_reg_value;
	uint8_t train_set = intel_dp->train_set[0];
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;

	switch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {
	case DP_TRAIN_PRE_EMPH_LEVEL_0:
		preemph_reg_value = 0x0004000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			demph_reg_value = 0x2B405555;
			uniqtranscale_reg_value = 0x552AB83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x5548B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			demph_reg_value = 0x2B245555;
			uniqtranscale_reg_value = 0x5560B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
			demph_reg_value = 0x2B405555;
			uniqtranscale_reg_value = 0x5598DA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_1:
		preemph_reg_value = 0x0002000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x5552B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			demph_reg_value = 0x2B404848;
			uniqtranscale_reg_value = 0x5580B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_2:
		preemph_reg_value = 0x0000000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			demph_reg_value = 0x2B305555;
			uniqtranscale_reg_value = 0x5570B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			demph_reg_value = 0x2B2B4040;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_3:
		preemph_reg_value = 0x0006000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			demph_reg_value = 0x1B405555;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	default:
		return 0;
	}

	mutex_lock(&dev_priv->sb_lock);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x00000000);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW4(port), demph_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW2(port),
			 uniqtranscale_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW3(port), 0x0C782040);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW11(port), 0x00030000);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW9(port), preemph_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x80000000);
	mutex_unlock(&dev_priv->sb_lock);

	return 0;
}

static bool chv_need_uniq_trans_scale(uint8_t train_set)
{
	return (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) == DP_TRAIN_PRE_EMPH_LEVEL_0 &&
		(train_set & DP_TRAIN_VOLTAGE_SWING_MASK) == DP_TRAIN_VOLTAGE_SWING_LEVEL_3;
}

static uint32_t chv_signal_levels(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct intel_crtc *intel_crtc = to_intel_crtc(dport->base.base.crtc);
	u32 deemph_reg_value, margin_reg_value, val;
	uint8_t train_set = intel_dp->train_set[0];
	enum dpio_channel ch = vlv_dport_to_channel(dport);
	enum pipe pipe = intel_crtc->pipe;
	int i;

	switch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {
	case DP_TRAIN_PRE_EMPH_LEVEL_0:
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			deemph_reg_value = 128;
			margin_reg_value = 52;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			deemph_reg_value = 128;
			margin_reg_value = 77;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			deemph_reg_value = 128;
			margin_reg_value = 102;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
			deemph_reg_value = 128;
			margin_reg_value = 154;
			/* FIXME extra to set for 1200 */
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_1:
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			deemph_reg_value = 85;
			margin_reg_value = 78;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			deemph_reg_value = 85;
			margin_reg_value = 116;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
			deemph_reg_value = 85;
			margin_reg_value = 154;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_2:
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			deemph_reg_value = 64;
			margin_reg_value = 104;
			break;
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
			deemph_reg_value = 64;
			margin_reg_value = 154;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_3:
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
			deemph_reg_value = 43;
			margin_reg_value = 154;
			break;
		default:
			return 0;
		}
		break;
	default:
		return 0;
	}

	mutex_lock(&dev_priv->sb_lock);

	/* Clear calc init */
	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));
	val &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);
	val &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);
	val |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));
		val &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);
		val &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);
		val |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);
	}

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW9(ch));
	val &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);
	val |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW9(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW9(ch));
		val &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);
		val |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW9(ch), val);
	}

	/* Program swing deemph */
	for (i = 0; i < intel_crtc->config->lane_count; i++) {
		val = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW4(ch, i));
		val &= ~DPIO_SWING_DEEMPH9P5_MASK;
		val |= deemph_reg_value << DPIO_SWING_DEEMPH9P5_SHIFT;
		vlv_dpio_write(dev_priv, pipe, CHV_TX_DW4(ch, i), val);
	}

	/* Program swing margin */
	for (i = 0; i < intel_crtc->config->lane_count; i++) {
		val = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW2(ch, i));

		val &= ~DPIO_SWING_MARGIN000_MASK;
		val |= margin_reg_value << DPIO_SWING_MARGIN000_SHIFT;

		/*
		 * Supposedly this value shouldn't matter when unique transition
		 * scale is disabled, but in fact it does matter. Let's just
		 * always program the same value and hope it's OK.
		 */
		val &= ~(0xff << DPIO_UNIQ_TRANS_SCALE_SHIFT);
		val |= 0x9a << DPIO_UNIQ_TRANS_SCALE_SHIFT;

		vlv_dpio_write(dev_priv, pipe, CHV_TX_DW2(ch, i), val);
	}

	/*
	 * The document said it needs to set bit 27 for ch0 and bit 26
	 * for ch1. Might be a typo in the doc.
	 * For now, for this unique transition scale selection, set bit
	 * 27 for ch0 and ch1.
	 */
	for (i = 0; i < intel_crtc->config->lane_count; i++) {
		val = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW3(ch, i));
		if (chv_need_uniq_trans_scale(train_set))
			val |= DPIO_TX_UNIQ_TRANS_SCALE_EN;
		else
			val &= ~DPIO_TX_UNIQ_TRANS_SCALE_EN;
		vlv_dpio_write(dev_priv, pipe, CHV_TX_DW3(ch, i), val);
	}

	/* Start swing calculation */
	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));
	val |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);

	if (intel_crtc->config->lane_count > 2) {
		val = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));
		val |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;
		vlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);
	}

	mutex_unlock(&dev_priv->sb_lock);

	return 0;
}

static void
intel_get_adjust_train(struct intel_dp *intel_dp,
		       const uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	uint8_t v = 0;
	uint8_t p = 0;
	int lane;
	uint8_t voltage_max;
	uint8_t preemph_max;

	for (lane = 0; lane < intel_dp->lane_count; lane++) {
		uint8_t this_v = drm_dp_get_adjust_request_voltage(link_status, lane);
		uint8_t this_p = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);

		if (this_v > v)
			v = this_v;
		if (this_p > p)
			p = this_p;
	}

	voltage_max = intel_dp_voltage_max(intel_dp);
	if (v >= voltage_max)
		v = voltage_max | DP_TRAIN_MAX_SWING_REACHED;

	preemph_max = intel_dp_pre_emphasis_max(intel_dp, v);
	if (p >= preemph_max)
		p = preemph_max | DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;

	for (lane = 0; lane < 4; lane++)
		intel_dp->train_set[lane] = v | p;
}

static uint32_t
gen4_signal_levels(uint8_t train_set)
{
	uint32_t	signal_levels = 0;

	switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0:
	default:
		signal_levels |= DP_VOLTAGE_0_4;
		break;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1:
		signal_levels |= DP_VOLTAGE_0_6;
		break;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2:
		signal_levels |= DP_VOLTAGE_0_8;
		break;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_3:
		signal_levels |= DP_VOLTAGE_1_2;
		break;
	}
	switch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {
	case DP_TRAIN_PRE_EMPH_LEVEL_0:
	default:
		signal_levels |= DP_PRE_EMPHASIS_0;
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_1:
		signal_levels |= DP_PRE_EMPHASIS_3_5;
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_2:
		signal_levels |= DP_PRE_EMPHASIS_6;
		break;
	case DP_TRAIN_PRE_EMPH_LEVEL_3:
		signal_levels |= DP_PRE_EMPHASIS_9_5;
		break;
	}
	return signal_levels;
}

/* Gen6's DP voltage swing and pre-emphasis control */
static uint32_t
gen6_edp_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:
		return EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:
		return EDP_LINK_TRAIN_400MV_3_5DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_2:
		return EDP_LINK_TRAIN_400_600MV_6DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:
		return EDP_LINK_TRAIN_600_800MV_3_5DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_3 | DP_TRAIN_PRE_EMPH_LEVEL_0:
		return EDP_LINK_TRAIN_800_1200MV_0DB_SNB_B;
	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;
	}
}

/* Gen7's DP voltage swing and pre-emphasis control */
static uint32_t
gen7_edp_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_0:
		return EDP_LINK_TRAIN_400MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_1:
		return EDP_LINK_TRAIN_400MV_3_5DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_0 | DP_TRAIN_PRE_EMPH_LEVEL_2:
		return EDP_LINK_TRAIN_400MV_6DB_IVB;

	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_0:
		return EDP_LINK_TRAIN_600MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_1 | DP_TRAIN_PRE_EMPH_LEVEL_1:
		return EDP_LINK_TRAIN_600MV_3_5DB_IVB;

	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_0:
		return EDP_LINK_TRAIN_800MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_LEVEL_2 | DP_TRAIN_PRE_EMPH_LEVEL_1:
		return EDP_LINK_TRAIN_800MV_3_5DB_IVB;

	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return EDP_LINK_TRAIN_500MV_0DB_IVB;
	}
}

/* Properly updates "DP" with the correct signal levels. */
static void
intel_dp_set_signal_levels(struct intel_dp *intel_dp, uint32_t *DP)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	enum port port = intel_dig_port->port;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	uint32_t signal_levels, mask = 0;
	uint8_t train_set = intel_dp->train_set[0];

	if (HAS_DDI(dev)) {
		signal_levels = ddi_signal_levels(intel_dp);

		if (IS_BROXTON(dev))
			signal_levels = 0;
		else
			mask = DDI_BUF_EMP_MASK;
	} else if (IS_CHERRYVIEW(dev)) {
		signal_levels = chv_signal_levels(intel_dp);
	} else if (IS_VALLEYVIEW(dev)) {
		signal_levels = vlv_signal_levels(intel_dp);
	} else if (IS_GEN7(dev) && port == PORT_A) {
		signal_levels = gen7_edp_signal_levels(train_set);
		mask = EDP_LINK_TRAIN_VOL_EMP_MASK_IVB;
	} else if (IS_GEN6(dev) && port == PORT_A) {
		signal_levels = gen6_edp_signal_levels(train_set);
		mask = EDP_LINK_TRAIN_VOL_EMP_MASK_SNB;
	} else {
		signal_levels = gen4_signal_levels(train_set);
		mask = DP_VOLTAGE_MASK | DP_PRE_EMPHASIS_MASK;
	}

	if (mask)
		DRM_DEBUG_KMS("Using signal levels %08x\n", signal_levels);

	DRM_DEBUG_KMS("Using vswing level %d\n",
		train_set & DP_TRAIN_VOLTAGE_SWING_MASK);
	DRM_DEBUG_KMS("Using pre-emphasis level %d\n",
		(train_set & DP_TRAIN_PRE_EMPHASIS_MASK) >>
			DP_TRAIN_PRE_EMPHASIS_SHIFT);

	*DP = (*DP & ~mask) | signal_levels;
}

static bool
intel_dp_set_link_train(struct intel_dp *intel_dp,
			uint32_t *DP,
			uint8_t dp_train_pat)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_i915_private *dev_priv =
		to_i915(intel_dig_port->base.base.dev);
	uint8_t buf[sizeof(intel_dp->train_set) + 1];
	int ret, len;

	_intel_dp_set_link_train(intel_dp, DP, dp_train_pat);

	I915_WRITE(intel_dp->output_reg, *DP);
	POSTING_READ(intel_dp->output_reg);

	buf[0] = dp_train_pat;
	if ((dp_train_pat & DP_TRAINING_PATTERN_MASK) ==
	    DP_TRAINING_PATTERN_DISABLE) {
		/* don't write DP_TRAINING_LANEx_SET on disable */
		len = 1;
	} else {
		/* DP_TRAINING_LANEx_SET follow DP_TRAINING_PATTERN_SET */
		memcpy(buf + 1, intel_dp->train_set, intel_dp->lane_count);
		len = intel_dp->lane_count + 1;
	}

	ret = drm_dp_dpcd_write(&intel_dp->aux, DP_TRAINING_PATTERN_SET,
				buf, len);

	return ret == len;
}

static bool
intel_dp_reset_link_train(struct intel_dp *intel_dp, uint32_t *DP,
			uint8_t dp_train_pat)
{
	memset(intel_dp->train_set, 0, sizeof(intel_dp->train_set));
	intel_dp_set_signal_levels(intel_dp, DP);
	return intel_dp_set_link_train(intel_dp, DP, dp_train_pat);
}

static bool
intel_dp_update_link_train(struct intel_dp *intel_dp, uint32_t *DP,
			   const uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_i915_private *dev_priv =
		to_i915(intel_dig_port->base.base.dev);
	int ret;

	intel_get_adjust_train(intel_dp, link_status);
	intel_dp_set_signal_levels(intel_dp, DP);

	I915_WRITE(intel_dp->output_reg, *DP);
	POSTING_READ(intel_dp->output_reg);

	ret = drm_dp_dpcd_write(&intel_dp->aux, DP_TRAINING_LANE0_SET,
				intel_dp->train_set, intel_dp->lane_count);

	return ret == intel_dp->lane_count;
}

static void intel_dp_set_idle_link_train(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	uint32_t val;

	if (!HAS_DDI(dev))
		return;

	val = I915_READ(DP_TP_CTL(port));
	val &= ~DP_TP_CTL_LINK_TRAIN_MASK;
	val |= DP_TP_CTL_LINK_TRAIN_IDLE;
	I915_WRITE(DP_TP_CTL(port), val);

	/*
	 * On PORT_A we can have only eDP in SST mode. There the only reason
	 * we need to set idle transmission mode is to work around a HW issue
	 * where we enable the pipe while not in idle link-training mode.
	 * In this case there is requirement to wait for a minimum number of
	 * idle patterns to be sent.
	 */
	if (port == PORT_A)
		return;

	if (wait_for((I915_READ(DP_TP_STATUS(port)) & DP_TP_STATUS_IDLE_DONE),
		     1))
		DRM_ERROR("Timed out waiting for DP idle patterns\n");
}

/* Enable corresponding port and start training pattern 1 */
static void
intel_dp_link_training_clock_recovery(struct intel_dp *intel_dp)
{
	struct drm_encoder *encoder = &dp_to_dig_port(intel_dp)->base.base;
	struct drm_device *dev = encoder->dev;
	int i;
	uint8_t voltage;
	int voltage_tries, loop_tries;
	uint32_t DP = intel_dp->DP;
	uint8_t link_config[2];
	uint8_t link_bw, rate_select;

	if (HAS_DDI(dev))
		intel_ddi_prepare_link_retrain(encoder);

	intel_dp_compute_rate(intel_dp, intel_dp->link_rate,
			      &link_bw, &rate_select);

	/* Write the link configuration data */
	link_config[0] = link_bw;
	link_config[1] = intel_dp->lane_count;
	if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
		link_config[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
	drm_dp_dpcd_write(&intel_dp->aux, DP_LINK_BW_SET, link_config, 2);
	if (intel_dp->num_sink_rates)
		drm_dp_dpcd_write(&intel_dp->aux, DP_LINK_RATE_SET,
				  &rate_select, 1);

	link_config[0] = 0;
	link_config[1] = DP_SET_ANSI_8B10B;
	drm_dp_dpcd_write(&intel_dp->aux, DP_DOWNSPREAD_CTRL, link_config, 2);

	DP |= DP_PORT_EN;

	/* clock recovery */
	if (!intel_dp_reset_link_train(intel_dp, &DP,
				       DP_TRAINING_PATTERN_1 |
				       DP_LINK_SCRAMBLING_DISABLE)) {
		DRM_ERROR("failed to enable link training\n");
		return;
	}

	voltage = 0xff;
	voltage_tries = 0;
	loop_tries = 0;
	for (;;) {
		uint8_t link_status[DP_LINK_STATUS_SIZE];

		drm_dp_link_train_clock_recovery_delay(intel_dp->dpcd);
		if (!intel_dp_get_link_status(intel_dp, link_status)) {
			DRM_ERROR("failed to get link status\n");
			break;
		}

		if (drm_dp_clock_recovery_ok(link_status, intel_dp->lane_count)) {
			DRM_DEBUG_KMS("clock recovery OK\n");
			break;
		}


		/* Check to see if we've tried the max voltage */
		for (i = 0; i < intel_dp->lane_count; i++)
			if ((intel_dp->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)
				break;
		if (i == intel_dp->lane_count) {
			++loop_tries;
			if (loop_tries == 5) {
				DRM_ERROR("too many full retries, give up\n");
				break;
			}
			intel_dp_reset_link_train(intel_dp, &DP,
						  DP_TRAINING_PATTERN_1 |
						  DP_LINK_SCRAMBLING_DISABLE);
			voltage_tries = 0;
			continue;
		}

		/* Check to see if we've tried the same voltage 5 times */
		if ((intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {
			++voltage_tries;
			if (voltage_tries == 5) {
				DRM_ERROR("too many voltage retries, give up\n");
				break;
			}
		} else
			voltage_tries = 0;
		voltage = intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;

		/* Update training set as requested by target */
		if (!intel_dp_update_link_train(intel_dp, &DP, link_status)) {
			DRM_ERROR("failed to update link training\n");
			break;
		}
	}

	intel_dp->DP = DP;
}

static void
intel_dp_link_training_channel_equalization(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	bool channel_eq = false;
	int tries, cr_tries;
	uint32_t DP = intel_dp->DP;
	uint32_t training_pattern = DP_TRAINING_PATTERN_2;

	/*
	 * Training Pattern 3 for HBR2 or 1.2 devices that support it.
	 *
	 * Intel platforms that support HBR2 also support TPS3. TPS3 support is
	 * also mandatory for downstream devices that support HBR2.
	 *
	 * Due to WaDisableHBR2 SKL < B0 is the only exception where TPS3 is
	 * supported but still not enabled.
	 */
	if (intel_dp_source_supports_hbr2(dev) &&
	    drm_dp_tps3_supported(intel_dp->dpcd))
		training_pattern = DP_TRAINING_PATTERN_3;
	else if (intel_dp->link_rate == 540000)
		DRM_ERROR("5.4 Gbps link rate without HBR2/TPS3 support\n");

	/* channel equalization */
	if (!intel_dp_set_link_train(intel_dp, &DP,
				     training_pattern |
				     DP_LINK_SCRAMBLING_DISABLE)) {
		DRM_ERROR("failed to start channel equalization\n");
		return;
	}

	tries = 0;
	cr_tries = 0;
	channel_eq = false;
	for (;;) {
		uint8_t link_status[DP_LINK_STATUS_SIZE];

		if (cr_tries > 5) {
			DRM_ERROR("failed to train DP, aborting\n");
			break;
		}

		drm_dp_link_train_channel_eq_delay(intel_dp->dpcd);
		if (!intel_dp_get_link_status(intel_dp, link_status)) {
			DRM_ERROR("failed to get link status\n");
			break;
		}

		/* Make sure clock is still ok */
		if (!drm_dp_clock_recovery_ok(link_status,
					      intel_dp->lane_count)) {
			intel_dp_link_training_clock_recovery(intel_dp);
			intel_dp_set_link_train(intel_dp, &DP,
						training_pattern |
						DP_LINK_SCRAMBLING_DISABLE);
			cr_tries++;
			continue;
		}

		if (drm_dp_channel_eq_ok(link_status,
					 intel_dp->lane_count)) {
			channel_eq = true;
			break;
		}

		/* Try 5 times, then try clock recovery if that fails */
		if (tries > 5) {
			intel_dp_link_training_clock_recovery(intel_dp);
			intel_dp_set_link_train(intel_dp, &DP,
						training_pattern |
						DP_LINK_SCRAMBLING_DISABLE);
			tries = 0;
			cr_tries++;
			continue;
		}

		/* Update training set as requested by target */
		if (!intel_dp_update_link_train(intel_dp, &DP, link_status)) {
			DRM_ERROR("failed to update link training\n");
			break;
		}
		++tries;
	}

	intel_dp_set_idle_link_train(intel_dp);

	intel_dp->DP = DP;

	if (channel_eq)
		DRM_DEBUG_KMS("Channel EQ done. DP Training successful\n");
}

void intel_dp_stop_link_train(struct intel_dp *intel_dp)
{
	intel_dp_set_link_train(intel_dp, &intel_dp->DP,
				DP_TRAINING_PATTERN_DISABLE);
}

void
intel_dp_start_link_train(struct intel_dp *intel_dp)
{
	intel_dp_link_training_clock_recovery(intel_dp);
	intel_dp_link_training_channel_equalization(intel_dp);
}

static void
intel_dp_link_down(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_crtc *crtc = to_intel_crtc(intel_dig_port->base.base.crtc);
	enum port port = intel_dig_port->port;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t DP = intel_dp->DP;

	if (WARN_ON(HAS_DDI(dev)))
		return;

	if (WARN_ON((I915_READ(intel_dp->output_reg) & DP_PORT_EN) == 0))
		return;

	DRM_DEBUG_KMS("\n");

	if ((IS_GEN7(dev) && port == PORT_A) ||
	    (HAS_PCH_CPT(dev) && port != PORT_A)) {
		DP &= ~DP_LINK_TRAIN_MASK_CPT;
		DP |= DP_LINK_TRAIN_PAT_IDLE_CPT;
	} else {
		if (IS_CHERRYVIEW(dev))
			DP &= ~DP_LINK_TRAIN_MASK_CHV;
		else
			DP &= ~DP_LINK_TRAIN_MASK;
		DP |= DP_LINK_TRAIN_PAT_IDLE;
	}
	I915_WRITE(intel_dp->output_reg, DP);
	POSTING_READ(intel_dp->output_reg);

	DP &= ~(DP_PORT_EN | DP_AUDIO_OUTPUT_ENABLE);
	I915_WRITE(intel_dp->output_reg, DP);
	POSTING_READ(intel_dp->output_reg);

	/*
	 * HW workaround for IBX, we need to move the port
	 * to transcoder A after disabling it to allow the
	 * matching HDMI port to be enabled on transcoder A.
	 */
	if (HAS_PCH_IBX(dev) && crtc->pipe == PIPE_B && port != PORT_A) {
		/* always enable with pattern 1 (as per spec) */
		DP &= ~(DP_PIPEB_SELECT | DP_LINK_TRAIN_MASK);
		DP |= DP_PORT_EN | DP_LINK_TRAIN_PAT_1;
		I915_WRITE(intel_dp->output_reg, DP);
		POSTING_READ(intel_dp->output_reg);

		DP &= ~DP_PORT_EN;
		I915_WRITE(intel_dp->output_reg, DP);
		POSTING_READ(intel_dp->output_reg);
	}

	drm_msleep(intel_dp->panel_power_down_delay);
}

static bool
intel_dp_get_dpcd(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint8_t rev;

	if (intel_dp_dpcd_read_wake(&intel_dp->aux, 0x000, intel_dp->dpcd,
				    sizeof(intel_dp->dpcd)) < 0)
		return false; /* aux transfer failed */

	DRM_DEBUG_KMS("DPCD: %*ph\n", (int) sizeof(intel_dp->dpcd), intel_dp->dpcd);

	if (intel_dp->dpcd[DP_DPCD_REV] == 0)
		return false; /* DPCD not present */

	/* Check if the panel supports PSR */
	memset(intel_dp->psr_dpcd, 0, sizeof(intel_dp->psr_dpcd));
	if (is_edp(intel_dp)) {
		intel_dp_dpcd_read_wake(&intel_dp->aux, DP_PSR_SUPPORT,
					intel_dp->psr_dpcd,
					sizeof(intel_dp->psr_dpcd));
		if (intel_dp->psr_dpcd[0] & DP_PSR_IS_SUPPORTED) {
			dev_priv->psr.sink_support = true;
			DRM_DEBUG_KMS("Detected EDP PSR Panel.\n");
		}

		if (INTEL_INFO(dev)->gen >= 9 &&
			(intel_dp->psr_dpcd[0] & DP_PSR2_IS_SUPPORTED)) {
			uint8_t frame_sync_cap;

			dev_priv->psr.sink_support = true;
			intel_dp_dpcd_read_wake(&intel_dp->aux,
					DP_SINK_DEVICE_AUX_FRAME_SYNC_CAP,
					&frame_sync_cap, 1);
			dev_priv->psr.aux_frame_sync = frame_sync_cap ? true : false;
			/* PSR2 needs frame sync as well */
			dev_priv->psr.psr2_support = dev_priv->psr.aux_frame_sync;
			DRM_DEBUG_KMS("PSR2 %s on sink",
				dev_priv->psr.psr2_support ? "supported" : "not supported");
		}
	}

	DRM_DEBUG_KMS("Display Port TPS3 support: source %s, sink %s\n",
		      yesno(intel_dp_source_supports_hbr2(dev)),
		      yesno(drm_dp_tps3_supported(intel_dp->dpcd)));

	/* Intermediate frequency support */
	if (is_edp(intel_dp) &&
	    (intel_dp->dpcd[DP_EDP_CONFIGURATION_CAP] &	DP_DPCD_DISPLAY_CONTROL_CAPABLE) &&
	    (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_EDP_DPCD_REV, &rev, 1) == 1) &&
	    (rev >= 0x03)) { /* eDp v1.4 or higher */
		__le16 sink_rates[DP_MAX_SUPPORTED_RATES];
		int i;

		intel_dp_dpcd_read_wake(&intel_dp->aux,
				DP_SUPPORTED_LINK_RATES,
				sink_rates,
				sizeof(sink_rates));

		for (i = 0; i < ARRAY_SIZE(sink_rates); i++) {
			int val = le16_to_cpu(sink_rates[i]);

			if (val == 0)
				break;

			/* Value read is in kHz while drm clock is saved in deca-kHz */
			intel_dp->sink_rates[i] = (val * 200) / 10;
		}
		intel_dp->num_sink_rates = i;
	}

	intel_dp_print_rates(intel_dp);

	if (!(intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
	      DP_DWN_STRM_PORT_PRESENT))
		return true; /* native DP sink */

	if (intel_dp->dpcd[DP_DPCD_REV] == 0x10)
		return true; /* no per-port downstream info */

	if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_DOWNSTREAM_PORT_0,
				    intel_dp->downstream_ports,
				    DP_MAX_DOWNSTREAM_PORTS) < 0)
		return false; /* downstream port status fetch failed */

	return true;
}

static void
intel_dp_probe_oui(struct intel_dp *intel_dp)
{
	u8 buf[3];

	if (!(intel_dp->dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))
		return;

	if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_SINK_OUI, buf, 3) == 3)
		DRM_DEBUG_KMS("Sink OUI: %02hx%02hx%02hx\n",
			      buf[0], buf[1], buf[2]);

	if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_BRANCH_OUI, buf, 3) == 3)
		DRM_DEBUG_KMS("Branch OUI: %02hx%02hx%02hx\n",
			      buf[0], buf[1], buf[2]);
}

static bool
intel_dp_probe_mst(struct intel_dp *intel_dp)
{
	u8 buf[1];

	if (!intel_dp->can_mst)
		return false;

	if (intel_dp->dpcd[DP_DPCD_REV] < 0x12)
		return false;

	if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_MSTM_CAP, buf, 1)) {
		if (buf[0] & DP_MST_CAP) {
			DRM_DEBUG_KMS("Sink is MST capable\n");
			intel_dp->is_mst = true;
		} else {
			DRM_DEBUG_KMS("Sink is not MST capable\n");
			intel_dp->is_mst = false;
		}
	}

	drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
	return intel_dp->is_mst;
}

static int intel_dp_sink_crc_stop(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct intel_crtc *intel_crtc = to_intel_crtc(dig_port->base.base.crtc);
	u8 buf;
	int ret = 0;

	if (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK, &buf) < 0) {
		DRM_DEBUG_KMS("Sink CRC couldn't be stopped properly\n");
		ret = -EIO;
		goto out;
	}

	if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_SINK,
			       buf & ~DP_TEST_SINK_START) < 0) {
		DRM_DEBUG_KMS("Sink CRC couldn't be stopped properly\n");
		ret = -EIO;
		goto out;
	}

	intel_dp->sink_crc.started = false;
 out:
	hsw_enable_ips(intel_crtc);
	return ret;
}

static int intel_dp_sink_crc_start(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct intel_crtc *intel_crtc = to_intel_crtc(dig_port->base.base.crtc);
	u8 buf;
	int ret;

	if (intel_dp->sink_crc.started) {
		ret = intel_dp_sink_crc_stop(intel_dp);
		if (ret)
			return ret;
	}

	if (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK_MISC, &buf) < 0)
		return -EIO;

	if (!(buf & DP_TEST_CRC_SUPPORTED))
		return -ENOTTY;

	intel_dp->sink_crc.last_count = buf & DP_TEST_COUNT_MASK;

	if (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK, &buf) < 0)
		return -EIO;

	hsw_disable_ips(intel_crtc);

	if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_SINK,
			       buf | DP_TEST_SINK_START) < 0) {
		hsw_enable_ips(intel_crtc);
		return -EIO;
	}

	intel_dp->sink_crc.started = true;
	return 0;
}

int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct intel_crtc *intel_crtc = to_intel_crtc(dig_port->base.base.crtc);
	u8 buf;
	int count, ret;
	int attempts = 6;
	bool old_equal_new;

	ret = intel_dp_sink_crc_start(intel_dp);
	if (ret)
		return ret;

	do {
		intel_wait_for_vblank(dev, intel_crtc->pipe);

		if (drm_dp_dpcd_readb(&intel_dp->aux,
				      DP_TEST_SINK_MISC, &buf) < 0) {
			ret = -EIO;
			goto stop;
		}
		count = buf & DP_TEST_COUNT_MASK;

		/*
		 * Count might be reset during the loop. In this case
		 * last known count needs to be reset as well.
		 */
		if (count == 0)
			intel_dp->sink_crc.last_count = 0;

		if (drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_CRC_R_CR, crc, 6) < 0) {
			ret = -EIO;
			goto stop;
		}

		old_equal_new = (count == intel_dp->sink_crc.last_count &&
				 !memcmp(intel_dp->sink_crc.last_crc, crc,
					 6 * sizeof(u8)));

	} while (--attempts && (count == 0 || old_equal_new));

	intel_dp->sink_crc.last_count = buf & DP_TEST_COUNT_MASK;
	memcpy(intel_dp->sink_crc.last_crc, crc, 6 * sizeof(u8));

	if (attempts == 0) {
		if (old_equal_new) {
			DRM_DEBUG_KMS("Unreliable Sink CRC counter: Current returned CRC is identical to the previous one\n");
		} else {
			DRM_ERROR("Panel is unable to calculate any CRC after 6 vblanks\n");
			ret = -ETIMEDOUT;
			goto stop;
		}
	}

stop:
	intel_dp_sink_crc_stop(intel_dp);
	return ret;
}

static bool
intel_dp_get_sink_irq(struct intel_dp *intel_dp, u8 *sink_irq_vector)
{
	return intel_dp_dpcd_read_wake(&intel_dp->aux,
				       DP_DEVICE_SERVICE_IRQ_VECTOR,
				       sink_irq_vector, 1) == 1;
}

static bool
intel_dp_get_sink_irq_esi(struct intel_dp *intel_dp, u8 *sink_irq_vector)
{
	int ret;

	ret = intel_dp_dpcd_read_wake(&intel_dp->aux,
					     DP_SINK_COUNT_ESI,
					     sink_irq_vector, 14);
	if (ret != 14)
		return false;

	return true;
}

static uint8_t intel_dp_autotest_link_training(struct intel_dp *intel_dp)
{
	uint8_t test_result = DP_TEST_ACK;
	return test_result;
}

static uint8_t intel_dp_autotest_video_pattern(struct intel_dp *intel_dp)
{
	uint8_t test_result = DP_TEST_NAK;
	return test_result;
}

static uint8_t intel_dp_autotest_edid(struct intel_dp *intel_dp)
{
	uint8_t test_result = DP_TEST_NAK;
	struct intel_connector *intel_connector = intel_dp->attached_connector;
	struct drm_connector *connector = &intel_connector->base;

	if (intel_connector->detect_edid == NULL ||
	    connector->edid_corrupt ||
	    intel_dp->aux.i2c_defer_count > 6) {
		/* Check EDID read for NACKs, DEFERs and corruption
		 * (DP CTS 1.2 Core r1.1)
		 *    4.2.2.4 : Failed EDID read, I2C_NAK
		 *    4.2.2.5 : Failed EDID read, I2C_DEFER
		 *    4.2.2.6 : EDID corruption detected
		 * Use failsafe mode for all cases
		 */
		if (intel_dp->aux.i2c_nack_count > 0 ||
			intel_dp->aux.i2c_defer_count > 0)
			DRM_DEBUG_KMS("EDID read had %d NACKs, %d DEFERs\n",
				      intel_dp->aux.i2c_nack_count,
				      intel_dp->aux.i2c_defer_count);
		intel_dp->compliance_test_data = INTEL_DP_RESOLUTION_FAILSAFE;
	} else {
		struct edid *block = intel_connector->detect_edid;

		/* We have to write the checksum
		 * of the last block read
		 */
		block += intel_connector->detect_edid->extensions;

		if (!drm_dp_dpcd_write(&intel_dp->aux,
					DP_TEST_EDID_CHECKSUM,
					&block->checksum,
					1))
			DRM_DEBUG_KMS("Failed to write EDID checksum\n");

		test_result = DP_TEST_ACK | DP_TEST_EDID_CHECKSUM_WRITE;
		intel_dp->compliance_test_data = INTEL_DP_RESOLUTION_STANDARD;
	}

	/* Set test active flag here so userspace doesn't interrupt things */
	intel_dp->compliance_test_active = 1;

	return test_result;
}

static uint8_t intel_dp_autotest_phy_pattern(struct intel_dp *intel_dp)
{
	uint8_t test_result = DP_TEST_NAK;
	return test_result;
}

static void intel_dp_handle_test_request(struct intel_dp *intel_dp)
{
	uint8_t response = DP_TEST_NAK;
	uint8_t rxdata = 0;
	int status = 0;

	intel_dp->compliance_test_active = 0;
	intel_dp->compliance_test_type = 0;
	intel_dp->compliance_test_data = 0;

	intel_dp->aux.i2c_nack_count = 0;
	intel_dp->aux.i2c_defer_count = 0;

	status = drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_REQUEST, &rxdata, 1);
	if (status <= 0) {
		DRM_DEBUG_KMS("Could not read test request from sink\n");
		goto update_status;
	}

	switch (rxdata) {
	case DP_TEST_LINK_TRAINING:
		DRM_DEBUG_KMS("LINK_TRAINING test requested\n");
		intel_dp->compliance_test_type = DP_TEST_LINK_TRAINING;
		response = intel_dp_autotest_link_training(intel_dp);
		break;
	case DP_TEST_LINK_VIDEO_PATTERN:
		DRM_DEBUG_KMS("TEST_PATTERN test requested\n");
		intel_dp->compliance_test_type = DP_TEST_LINK_VIDEO_PATTERN;
		response = intel_dp_autotest_video_pattern(intel_dp);
		break;
	case DP_TEST_LINK_EDID_READ:
		DRM_DEBUG_KMS("EDID test requested\n");
		intel_dp->compliance_test_type = DP_TEST_LINK_EDID_READ;
		response = intel_dp_autotest_edid(intel_dp);
		break;
	case DP_TEST_LINK_PHY_TEST_PATTERN:
		DRM_DEBUG_KMS("PHY_PATTERN test requested\n");
		intel_dp->compliance_test_type = DP_TEST_LINK_PHY_TEST_PATTERN;
		response = intel_dp_autotest_phy_pattern(intel_dp);
		break;
	default:
		DRM_DEBUG_KMS("Invalid test request '%02x'\n", rxdata);
		break;
	}

update_status:
	status = drm_dp_dpcd_write(&intel_dp->aux,
				   DP_TEST_RESPONSE,
				   &response, 1);
	if (status <= 0)
		DRM_DEBUG_KMS("Could not write test response to sink\n");
}

static int
intel_dp_check_mst_status(struct intel_dp *intel_dp)
{
	bool bret;

	if (intel_dp->is_mst) {
		u8 esi[16] = { 0 };
		int ret = 0;
		int retry;
		bool handled;
		bret = intel_dp_get_sink_irq_esi(intel_dp, esi);
go_again:
		if (bret == true) {

			/* check link status - esi[10] = 0x200c */
			if (intel_dp->active_mst_links &&
			    !drm_dp_channel_eq_ok(&esi[10], intel_dp->lane_count)) {
				DRM_DEBUG_KMS("channel EQ not ok, retraining\n");
				intel_dp_start_link_train(intel_dp);
				intel_dp_stop_link_train(intel_dp);
			}

			DRM_DEBUG_KMS("got esi %3ph\n", esi);
			ret = drm_dp_mst_hpd_irq(&intel_dp->mst_mgr, esi, &handled);

			if (handled) {
				for (retry = 0; retry < 3; retry++) {
					int wret;
					wret = drm_dp_dpcd_write(&intel_dp->aux,
								 DP_SINK_COUNT_ESI+1,
								 &esi[1], 3);
					if (wret == 3) {
						break;
					}
				}

				bret = intel_dp_get_sink_irq_esi(intel_dp, esi);
				if (bret == true) {
					DRM_DEBUG_KMS("got esi2 %3ph\n", esi);
					goto go_again;
				}
			} else
				ret = 0;

			return ret;
		} else {
			struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
			DRM_DEBUG_KMS("failed to get ESI - device may have failed\n");
			intel_dp->is_mst = false;
			drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
			/* send a hotplug event */
			drm_kms_helper_hotplug_event(intel_dig_port->base.base.dev);
		}
	}
	return -EINVAL;
}

/*
 * According to DP spec
 * 5.1.2:
 *  1. Read DPCD
 *  2. Configure link according to Receiver Capabilities
 *  3. Use Link Training from 2.5.3.3 and 3.5.1.3
 *  4. Check link status on receipt of hot-plug interrupt
 */
static void
intel_dp_check_link_status(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;
	u8 sink_irq_vector;
	u8 link_status[DP_LINK_STATUS_SIZE];

	WARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));

	if (!intel_encoder->base.crtc)
		return;

	if (!to_intel_crtc(intel_encoder->base.crtc)->active)
		return;

	/* Try to read receiver status if the link appears to be up */
	if (!intel_dp_get_link_status(intel_dp, link_status)) {
		return;
	}

	/* Now read the DPCD to see if it's actually running */
	if (!intel_dp_get_dpcd(intel_dp)) {
		return;
	}

	/* Try to read the source of the interrupt */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    intel_dp_get_sink_irq(intel_dp, &sink_irq_vector)) {
		/* Clear interrupt source */
		drm_dp_dpcd_writeb(&intel_dp->aux,
				   DP_DEVICE_SERVICE_IRQ_VECTOR,
				   sink_irq_vector);

		if (sink_irq_vector & DP_AUTOMATED_TEST_REQUEST)
			DRM_DEBUG_DRIVER("Test request in short pulse not handled\n");
		if (sink_irq_vector & (DP_CP_IRQ | DP_SINK_SPECIFIC_IRQ))
			DRM_DEBUG_DRIVER("CP or sink specific irq unhandled\n");
	}

	if (!drm_dp_channel_eq_ok(link_status, intel_dp->lane_count)) {
		DRM_DEBUG_KMS("%s: channel EQ not ok, retraining\n",
			      intel_encoder->base.name);
		intel_dp_start_link_train(intel_dp);
		intel_dp_stop_link_train(intel_dp);
	}
}

/* XXX this is probably wrong for multiple downstream ports */
static enum drm_connector_status
intel_dp_detect_dpcd(struct intel_dp *intel_dp)
{
	uint8_t *dpcd = intel_dp->dpcd;
	uint8_t type;

	if (!intel_dp_get_dpcd(intel_dp))
		return connector_status_disconnected;

	/* if there's no downstream port, we're done */
	if (!(dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT))
		return connector_status_connected;

	/* If we're HPD-aware, SINK_COUNT changes dynamically */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {
		uint8_t reg;

		if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_SINK_COUNT,
					    &reg, 1) < 0)
			return connector_status_unknown;

		return DP_GET_SINK_COUNT(reg) ? connector_status_connected
					      : connector_status_disconnected;
	}

	/* If no HPD, poke DDC gently */
	if (drm_probe_ddc(&intel_dp->aux.ddc))
		return connector_status_connected;

	/* Well we tried, say unknown for unreliable port types */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {
		type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
		if (type == DP_DS_PORT_TYPE_VGA ||
		    type == DP_DS_PORT_TYPE_NON_EDID)
			return connector_status_unknown;
	} else {
		type = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
			DP_DWN_STRM_PORT_TYPE_MASK;
		if (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||
		    type == DP_DWN_STRM_PORT_TYPE_OTHER)
			return connector_status_unknown;
	}

	/* Anything else is out of spec, warn and ignore */
	DRM_DEBUG_KMS("Broken DP branch device, ignoring\n");
	return connector_status_disconnected;
}

static enum drm_connector_status
edp_detect(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	enum drm_connector_status status;

	status = intel_panel_detect(dev);
	if (status == connector_status_unknown)
		status = connector_status_connected;

	return status;
}

static bool ibx_digital_port_connected(struct drm_i915_private *dev_priv,
				       struct intel_digital_port *port)
{
	u32 bit;

	switch (port->port) {
	case PORT_A:
		return true;
	case PORT_B:
		bit = SDE_PORTB_HOTPLUG;
		break;
	case PORT_C:
		bit = SDE_PORTC_HOTPLUG;
		break;
	case PORT_D:
		bit = SDE_PORTD_HOTPLUG;
		break;
	default:
		MISSING_CASE(port->port);
		return false;
	}

	return I915_READ(SDEISR) & bit;
}

static bool cpt_digital_port_connected(struct drm_i915_private *dev_priv,
				       struct intel_digital_port *port)
{
	u32 bit;

	switch (port->port) {
	case PORT_A:
		return true;
	case PORT_B:
		bit = SDE_PORTB_HOTPLUG_CPT;
		break;
	case PORT_C:
		bit = SDE_PORTC_HOTPLUG_CPT;
		break;
	case PORT_D:
		bit = SDE_PORTD_HOTPLUG_CPT;
		break;
	case PORT_E:
		bit = SDE_PORTE_HOTPLUG_SPT;
		break;
	default:
		MISSING_CASE(port->port);
		return false;
	}

	return I915_READ(SDEISR) & bit;
}

static bool g4x_digital_port_connected(struct drm_i915_private *dev_priv,
				       struct intel_digital_port *port)
{
	u32 bit;

	switch (port->port) {
	case PORT_B:
		bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
		break;
	case PORT_C:
		bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
		break;
	case PORT_D:
		bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
		break;
	default:
		MISSING_CASE(port->port);
		return false;
	}

	return I915_READ(PORT_HOTPLUG_STAT) & bit;
}

static bool gm45_digital_port_connected(struct drm_i915_private *dev_priv,
					struct intel_digital_port *port)
{
	u32 bit;

	switch (port->port) {
	case PORT_B:
		bit = PORTB_HOTPLUG_LIVE_STATUS_GM45;
		break;
	case PORT_C:
		bit = PORTC_HOTPLUG_LIVE_STATUS_GM45;
		break;
	case PORT_D:
		bit = PORTD_HOTPLUG_LIVE_STATUS_GM45;
		break;
	default:
		MISSING_CASE(port->port);
		return false;
	}

	return I915_READ(PORT_HOTPLUG_STAT) & bit;
}

static bool bxt_digital_port_connected(struct drm_i915_private *dev_priv,
				       struct intel_digital_port *intel_dig_port)
{
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	enum port port;
	u32 bit;

	intel_hpd_pin_to_port(intel_encoder->hpd_pin, &port);
	switch (port) {
	case PORT_A:
		bit = BXT_DE_PORT_HP_DDIA;
		break;
	case PORT_B:
		bit = BXT_DE_PORT_HP_DDIB;
		break;
	case PORT_C:
		bit = BXT_DE_PORT_HP_DDIC;
		break;
	default:
		MISSING_CASE(port);
		return false;
	}

	return I915_READ(GEN8_DE_PORT_ISR) & bit;
}

/*
 * intel_digital_port_connected - is the specified port connected?
 * @@dev_priv: i915 private structure
 * @@port: the port to test
 *
 * Return %true if @@port is connected, %false otherwise.
 */
static bool intel_digital_port_connected(struct drm_i915_private *dev_priv,
					 struct intel_digital_port *port)
{
	if (HAS_PCH_IBX(dev_priv))
		return ibx_digital_port_connected(dev_priv, port);
	if (HAS_PCH_SPLIT(dev_priv))
		return cpt_digital_port_connected(dev_priv, port);
	else if (IS_BROXTON(dev_priv))
		return bxt_digital_port_connected(dev_priv, port);
	else if (IS_GM45(dev_priv))
		return gm45_digital_port_connected(dev_priv, port);
	else
		return g4x_digital_port_connected(dev_priv, port);
}

static enum drm_connector_status
ironlake_dp_detect(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	if (!intel_digital_port_connected(dev_priv, intel_dig_port))
		return connector_status_disconnected;

	return intel_dp_detect_dpcd(intel_dp);
}

static enum drm_connector_status
g4x_dp_detect(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	/* Can't disconnect eDP, but you can close the lid... */
	if (is_edp(intel_dp)) {
		enum drm_connector_status status;

		status = intel_panel_detect(dev);
		if (status == connector_status_unknown)
			status = connector_status_connected;
		return status;
	}

	if (!intel_digital_port_connected(dev->dev_private, intel_dig_port))
		return connector_status_disconnected;

	return intel_dp_detect_dpcd(intel_dp);
}

static struct edid *
intel_dp_get_edid(struct intel_dp *intel_dp)
{
	struct intel_connector *intel_connector = intel_dp->attached_connector;

	/* use cached edid if we have one */
	if (intel_connector->edid) {
		/* invalid edid */
		if (IS_ERR(intel_connector->edid))
			return NULL;

		return drm_edid_duplicate(intel_connector->edid);
	} else
		return drm_get_edid(&intel_connector->base,
				    &intel_dp->aux.ddc);
}

static void
intel_dp_set_edid(struct intel_dp *intel_dp)
{
	struct intel_connector *intel_connector = intel_dp->attached_connector;
	struct edid *edid;

	edid = intel_dp_get_edid(intel_dp);
	intel_connector->detect_edid = edid;

	if (intel_dp->force_audio != HDMI_AUDIO_AUTO)
		intel_dp->has_audio = intel_dp->force_audio == HDMI_AUDIO_ON;
	else
		intel_dp->has_audio = drm_detect_monitor_audio(edid);
}

static void
intel_dp_unset_edid(struct intel_dp *intel_dp)
{
	struct intel_connector *intel_connector = intel_dp->attached_connector;

	kfree(intel_connector->detect_edid);
	intel_connector->detect_edid = NULL;

	intel_dp->has_audio = false;
}

static enum drm_connector_status
intel_dp_detect(struct drm_connector *connector, bool force)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = connector->dev;
	enum drm_connector_status status;
	enum intel_display_power_domain power_domain;
	bool ret;
	u8 sink_irq_vector;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.id, connector->name);
	intel_dp_unset_edid(intel_dp);

	if (intel_dp->is_mst) {
		/* MST devices are disconnected from a monitor POV */
		if (intel_encoder->type != INTEL_OUTPUT_EDP)
			intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
		return connector_status_disconnected;
	}

	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_get(to_i915(dev), power_domain);

	/* Can't disconnect eDP, but you can close the lid... */
	if (is_edp(intel_dp))
		status = edp_detect(intel_dp);
	else if (HAS_PCH_SPLIT(dev))
		status = ironlake_dp_detect(intel_dp);
	else
		status = g4x_dp_detect(intel_dp);
	if (status != connector_status_connected)
		goto out;

	intel_dp_probe_oui(intel_dp);

	ret = intel_dp_probe_mst(intel_dp);
	if (ret) {
		/* if we are in MST mode then this connector
		   won't appear connected or have anything with EDID on it */
		if (intel_encoder->type != INTEL_OUTPUT_EDP)
			intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
		status = connector_status_disconnected;
		goto out;
	}

	intel_dp_set_edid(intel_dp);

	if (intel_encoder->type != INTEL_OUTPUT_EDP)
		intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
	status = connector_status_connected;

	/* Try to read the source of the interrupt */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    intel_dp_get_sink_irq(intel_dp, &sink_irq_vector)) {
		/* Clear interrupt source */
		drm_dp_dpcd_writeb(&intel_dp->aux,
				   DP_DEVICE_SERVICE_IRQ_VECTOR,
				   sink_irq_vector);

		if (sink_irq_vector & DP_AUTOMATED_TEST_REQUEST)
			intel_dp_handle_test_request(intel_dp);
		if (sink_irq_vector & (DP_CP_IRQ | DP_SINK_SPECIFIC_IRQ))
			DRM_DEBUG_DRIVER("CP or sink specific irq unhandled\n");
	}

out:
	intel_display_power_put(to_i915(dev), power_domain);
	return status;
}

static void
intel_dp_force(struct drm_connector *connector)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;
	struct drm_i915_private *dev_priv = to_i915(intel_encoder->base.dev);
	enum intel_display_power_domain power_domain;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.id, connector->name);
	intel_dp_unset_edid(intel_dp);

	if (connector->status != connector_status_connected)
		return;

	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_get(dev_priv, power_domain);

	intel_dp_set_edid(intel_dp);

	intel_display_power_put(dev_priv, power_domain);

	if (intel_encoder->type != INTEL_OUTPUT_EDP)
		intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
}

static int intel_dp_get_modes(struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct edid *edid;

	edid = intel_connector->detect_edid;
	if (edid) {
		int ret = intel_connector_update_modes(connector, edid);
		if (ret)
			return ret;
	}

	/* if eDP has no EDID, fall back to fixed mode */
	if (is_edp(intel_attached_dp(connector)) &&
	    intel_connector->panel.fixed_mode) {
		struct drm_display_mode *mode;

		mode = drm_mode_duplicate(connector->dev,
					  intel_connector->panel.fixed_mode);
		if (mode) {
			drm_mode_probed_add(connector, mode);
			return 1;
		}
	}

	return 0;
}

static bool
intel_dp_detect_audio(struct drm_connector *connector)
{
	bool has_audio = false;
	struct edid *edid;

	edid = to_intel_connector(connector)->detect_edid;
	if (edid)
		has_audio = drm_detect_monitor_audio(edid);

	return has_audio;
}

static int
intel_dp_set_property(struct drm_connector *connector,
		      struct drm_property *property,
		      uint64_t val)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct intel_encoder *intel_encoder = intel_attached_encoder(connector);
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
	int ret;

	ret = drm_object_property_set_value(&connector->base, property, val);
	if (ret)
		return ret;

	if (property == dev_priv->force_audio_property) {
		int i = val;
		bool has_audio;

		if (i == intel_dp->force_audio)
			return 0;

		intel_dp->force_audio = i;

		if (i == HDMI_AUDIO_AUTO)
			has_audio = intel_dp_detect_audio(connector);
		else
			has_audio = (i == HDMI_AUDIO_ON);

		if (has_audio == intel_dp->has_audio)
			return 0;

		intel_dp->has_audio = has_audio;
		goto done;
	}

	if (property == dev_priv->broadcast_rgb_property) {
		bool old_auto = intel_dp->color_range_auto;
		bool old_range = intel_dp->limited_color_range;

		switch (val) {
		case INTEL_BROADCAST_RGB_AUTO:
			intel_dp->color_range_auto = true;
			break;
		case INTEL_BROADCAST_RGB_FULL:
			intel_dp->color_range_auto = false;
			intel_dp->limited_color_range = false;
			break;
		case INTEL_BROADCAST_RGB_LIMITED:
			intel_dp->color_range_auto = false;
			intel_dp->limited_color_range = true;
			break;
		default:
			return -EINVAL;
		}

		if (old_auto == intel_dp->color_range_auto &&
		    old_range == intel_dp->limited_color_range)
			return 0;

		goto done;
	}

	if (is_edp(intel_dp) &&
	    property == connector->dev->mode_config.scaling_mode_property) {
		if (val == DRM_MODE_SCALE_NONE) {
			DRM_DEBUG_KMS("no scaling not supported\n");
			return -EINVAL;
		}

		if (intel_connector->panel.fitting_mode == val) {
			/* the eDP scaling property is not changed */
			return 0;
		}
		intel_connector->panel.fitting_mode = val;

		goto done;
	}

	return -EINVAL;

done:
	if (intel_encoder->base.crtc)
		intel_crtc_restore_mode(intel_encoder->base.crtc);

	return 0;
}

static void
intel_dp_connector_destroy(struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	kfree(intel_connector->detect_edid);

	if (!IS_ERR_OR_NULL(intel_connector->edid))
		kfree(intel_connector->edid);

	/* Can't call is_edp() since the encoder may have been destroyed
	 * already. */
	if (connector->connector_type == DRM_MODE_CONNECTOR_eDP)
		intel_panel_fini(&intel_connector->panel);

	drm_connector_cleanup(connector);
	kfree(connector);
}

void intel_dp_encoder_destroy(struct drm_encoder *encoder)
{
	struct intel_digital_port *intel_dig_port = enc_to_dig_port(encoder);
	struct intel_dp *intel_dp = &intel_dig_port->dp;

	drm_dp_aux_unregister(&intel_dp->aux);
	intel_dp_mst_encoder_cleanup(intel_dig_port);
	if (is_edp(intel_dp)) {
		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
		/*
		 * vdd might still be enabled do to the delayed vdd off.
		 * Make sure vdd is actually turned off here.
		 */
		pps_lock(intel_dp);
		edp_panel_vdd_off_sync(intel_dp);
		pps_unlock(intel_dp);

		if (intel_dp->edp_notifier.notifier_call) {
			unregister_reboot_notifier(&intel_dp->edp_notifier);
			intel_dp->edp_notifier.notifier_call = NULL;
		}
	}
	drm_encoder_cleanup(encoder);
	kfree(intel_dig_port);
}

void intel_dp_encoder_suspend(struct intel_encoder *intel_encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);

	if (!is_edp(intel_dp))
		return;

	/*
	 * vdd might still be enabled do to the delayed vdd off.
	 * Make sure vdd is actually turned off here.
	 */
	cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
	pps_lock(intel_dp);
	edp_panel_vdd_off_sync(intel_dp);
	pps_unlock(intel_dp);
}

static void intel_edp_panel_vdd_sanitize(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (!edp_have_panel_vdd(intel_dp))
		return;

	/*
	 * The VDD bit needs a power domain reference, so if the bit is
	 * already enabled when we boot or resume, grab this reference and
	 * schedule a vdd off, so we don't hold on to the reference
	 * indefinitely.
	 */
	DRM_DEBUG_KMS("VDD left on by BIOS, adjusting state tracking\n");
	power_domain = intel_display_port_aux_power_domain(&intel_dig_port->base);
	intel_display_power_get(dev_priv, power_domain);

	edp_panel_vdd_schedule_off(intel_dp);
}

void intel_dp_encoder_reset(struct drm_encoder *encoder)
{
	struct drm_i915_private *dev_priv = to_i915(encoder->dev);
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);

	if (!HAS_DDI(dev_priv))
		intel_dp->DP = I915_READ(intel_dp->output_reg);

	if (to_intel_encoder(encoder)->type != INTEL_OUTPUT_EDP)
		return;

	pps_lock(intel_dp);

	/*
	 * Read out the current power sequencer assignment,
	 * in case the BIOS did something with it.
	 */
	if (IS_VALLEYVIEW(encoder->dev))
		vlv_initial_power_sequencer_setup(intel_dp);

	intel_edp_panel_vdd_sanitize(intel_dp);

	pps_unlock(intel_dp);
}

static const struct drm_connector_funcs intel_dp_connector_funcs = {
	.dpms = drm_atomic_helper_connector_dpms,
	.detect = intel_dp_detect,
	.force = intel_dp_force,
	.fill_modes = drm_helper_probe_single_connector_modes,
	.set_property = intel_dp_set_property,
	.atomic_get_property = intel_connector_atomic_get_property,
	.destroy = intel_dp_connector_destroy,
	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
};

static const struct drm_connector_helper_funcs intel_dp_connector_helper_funcs = {
	.get_modes = intel_dp_get_modes,
	.mode_valid = intel_dp_mode_valid,
	.best_encoder = intel_best_encoder,
};

static const struct drm_encoder_funcs intel_dp_enc_funcs = {
	.reset = intel_dp_encoder_reset,
	.destroy = intel_dp_encoder_destroy,
};

enum irqreturn
intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
{
	struct intel_dp *intel_dp = &intel_dig_port->dp;
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum intel_display_power_domain power_domain;
	enum irqreturn ret = IRQ_NONE;

	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP &&
	    intel_dig_port->base.type != INTEL_OUTPUT_HDMI)
		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;

	if (long_hpd && intel_dig_port->base.type == INTEL_OUTPUT_EDP) {
		/*
		 * vdd off can generate a long pulse on eDP which
		 * would require vdd on to handle it, and thus we
		 * would end up in an endless cycle of
		 * "vdd off -> long hpd -> vdd on -> detect -> vdd off -> ..."
		 */
		DRM_DEBUG_KMS("ignoring long hpd on eDP port %c\n",
			      port_name(intel_dig_port->port));
		return IRQ_HANDLED;
	}

	DRM_DEBUG_KMS("got hpd irq on port %c - %s\n",
		      port_name(intel_dig_port->port),
		      long_hpd ? "long" : "short");

	power_domain = intel_display_port_aux_power_domain(intel_encoder);
	intel_display_power_get(dev_priv, power_domain);

	if (long_hpd) {
		if (!intel_digital_port_connected(dev_priv, intel_dig_port))
			goto mst_fail;

		if (!intel_dp_get_dpcd(intel_dp)) {
			goto mst_fail;
		}

		intel_dp_probe_oui(intel_dp);

		if (!intel_dp_probe_mst(intel_dp)) {
			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
			intel_dp_check_link_status(intel_dp);
			drm_modeset_unlock(&dev->mode_config.connection_mutex);
			goto mst_fail;
		}
	} else {
		if (intel_dp->is_mst) {
			if (intel_dp_check_mst_status(intel_dp) == -EINVAL)
				goto mst_fail;
		}

		if (!intel_dp->is_mst) {
			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
			intel_dp_check_link_status(intel_dp);
			drm_modeset_unlock(&dev->mode_config.connection_mutex);
		}
	}

	ret = IRQ_HANDLED;

	goto put_power;
mst_fail:
	/* if we were in MST mode, and device is not there get out of MST mode */
	if (intel_dp->is_mst) {
		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
		intel_dp->is_mst = false;
		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
	}
put_power:
	intel_display_power_put(dev_priv, power_domain);

	return ret;
}

/* Return which DP Port should be selected for Transcoder DP control */
int
intel_trans_dp_port_sel(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;
	struct intel_dp *intel_dp;

	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		intel_dp = enc_to_intel_dp(&intel_encoder->base);

		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
		    intel_encoder->type == INTEL_OUTPUT_EDP)
			return intel_dp->output_reg;
	}

	return -1;
}

/* check the VBT to see whether the eDP is on another port */
bool intel_dp_is_edp(struct drm_device *dev, enum port port)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	union child_device_config *p_child;
	int i;
	static const short port_mapping[] = {
		[PORT_B] = DVO_PORT_DPB,
		[PORT_C] = DVO_PORT_DPC,
		[PORT_D] = DVO_PORT_DPD,
		[PORT_E] = DVO_PORT_DPE,
	};

	/*
	 * eDP not supported on g4x. so bail out early just
	 * for a bit extra safety in case the VBT is bonkers.
	 */
	if (INTEL_INFO(dev)->gen < 5)
		return false;

	if (port == PORT_A)
		return true;

	if (!dev_priv->vbt.child_dev_num)
		return false;

	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
		p_child = dev_priv->vbt.child_dev + i;

		if (p_child->common.dvo_port == port_mapping[port] &&
		    (p_child->common.device_type & DEVICE_TYPE_eDP_BITS) ==
		    (DEVICE_TYPE_eDP & DEVICE_TYPE_eDP_BITS))
			return true;
	}
	return false;
}

void
intel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	intel_attach_force_audio_property(connector);
	intel_attach_broadcast_rgb_property(connector);
	intel_dp->color_range_auto = true;

	if (is_edp(intel_dp)) {
		drm_mode_create_scaling_mode_property(connector->dev);
		drm_object_attach_property(
			&connector->base,
			connector->dev->mode_config.scaling_mode_property,
			DRM_MODE_SCALE_ASPECT);
		intel_connector->panel.fitting_mode = DRM_MODE_SCALE_ASPECT;
	}
}

static void intel_dp_init_panel_power_timestamps(struct intel_dp *intel_dp)
{
	intel_dp->last_power_cycle = jiffies;
	intel_dp->last_power_on = jiffies;
	intel_dp->last_backlight_off = jiffies;
}

static void
intel_dp_init_panel_power_sequencer(struct drm_device *dev,
				    struct intel_dp *intel_dp)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct edp_power_seq cur, vbt, spec,
		*final = &intel_dp->pps_delays;
	u32 pp_on, pp_off, pp_div = 0, pp_ctl = 0;
	int pp_ctrl_reg, pp_on_reg, pp_off_reg, pp_div_reg = 0;

	lockdep_assert_held(&dev_priv->pps_mutex);

	/* already initialized? */
	if (final->t11_t12 != 0)
		return;

	if (IS_BROXTON(dev)) {
		/*
		 * TODO: BXT has 2 sets of PPS registers.
		 * Correct Register for Broxton need to be identified
		 * using VBT. hardcoding for now
		 */
		pp_ctrl_reg = BXT_PP_CONTROL(0);
		pp_on_reg = BXT_PP_ON_DELAYS(0);
		pp_off_reg = BXT_PP_OFF_DELAYS(0);
	} else if (HAS_PCH_SPLIT(dev)) {
		pp_ctrl_reg = PCH_PP_CONTROL;
		pp_on_reg = PCH_PP_ON_DELAYS;
		pp_off_reg = PCH_PP_OFF_DELAYS;
		pp_div_reg = PCH_PP_DIVISOR;
	} else {
		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);

		pp_ctrl_reg = VLV_PIPE_PP_CONTROL(pipe);
		pp_on_reg = VLV_PIPE_PP_ON_DELAYS(pipe);
		pp_off_reg = VLV_PIPE_PP_OFF_DELAYS(pipe);
		pp_div_reg = VLV_PIPE_PP_DIVISOR(pipe);
	}

	/* Workaround: Need to write PP_CONTROL with the unlock key as
	 * the very first thing. */
	pp_ctl = ironlake_get_pp_control(intel_dp);

	pp_on = I915_READ(pp_on_reg);
	pp_off = I915_READ(pp_off_reg);
	if (!IS_BROXTON(dev)) {
		I915_WRITE(pp_ctrl_reg, pp_ctl);
		pp_div = I915_READ(pp_div_reg);
	}

	/* Pull timing values out of registers */
	cur.t1_t3 = (pp_on & PANEL_POWER_UP_DELAY_MASK) >>
		PANEL_POWER_UP_DELAY_SHIFT;

	cur.t8 = (pp_on & PANEL_LIGHT_ON_DELAY_MASK) >>
		PANEL_LIGHT_ON_DELAY_SHIFT;

	cur.t9 = (pp_off & PANEL_LIGHT_OFF_DELAY_MASK) >>
		PANEL_LIGHT_OFF_DELAY_SHIFT;

	cur.t10 = (pp_off & PANEL_POWER_DOWN_DELAY_MASK) >>
		PANEL_POWER_DOWN_DELAY_SHIFT;

	if (IS_BROXTON(dev)) {
		u16 tmp = (pp_ctl & BXT_POWER_CYCLE_DELAY_MASK) >>
			BXT_POWER_CYCLE_DELAY_SHIFT;
		if (tmp > 0)
			cur.t11_t12 = (tmp - 1) * 1000;
		else
			cur.t11_t12 = 0;
	} else {
		cur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>
		       PANEL_POWER_CYCLE_DELAY_SHIFT) * 1000;
	}

	DRM_DEBUG_KMS("cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
		      cur.t1_t3, cur.t8, cur.t9, cur.t10, cur.t11_t12);

	vbt = dev_priv->vbt.edp_pps;

	/* Upper limits from eDP 1.3 spec. Note that we use the clunky units of
	 * our hw here, which are all in 100usec. */
	spec.t1_t3 = 210 * 10;
	spec.t8 = 50 * 10; /* no limit for t8, use t7 instead */
	spec.t9 = 50 * 10; /* no limit for t9, make it symmetric with t8 */
	spec.t10 = 500 * 10;
	/* This one is special and actually in units of 100ms, but zero
	 * based in the hw (so we need to add 100 ms). But the sw vbt
	 * table multiplies it with 1000 to make it in units of 100usec,
	 * too. */
	spec.t11_t12 = (510 + 100) * 10;

	DRM_DEBUG_KMS("vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
		      vbt.t1_t3, vbt.t8, vbt.t9, vbt.t10, vbt.t11_t12);

	/* Use the max of the register settings and vbt. If both are
	 * unset, fall back to the spec limits. */
#define assign_final(field)	final->field = (max(cur.field, vbt.field) == 0 ? \
				       spec.field : \
				       max(cur.field, vbt.field))
	assign_final(t1_t3);
	assign_final(t8);
	assign_final(t9);
	assign_final(t10);
	assign_final(t11_t12);
#undef assign_final

#define get_delay(field)	(DIV_ROUND_UP(final->field, 10))
	intel_dp->panel_power_up_delay = get_delay(t1_t3);
	intel_dp->backlight_on_delay = get_delay(t8);
	intel_dp->backlight_off_delay = get_delay(t9);
	intel_dp->panel_power_down_delay = get_delay(t10);
	intel_dp->panel_power_cycle_delay = get_delay(t11_t12);
#undef get_delay

	DRM_DEBUG_KMS("panel power up delay %d, power down delay %d, power cycle delay %d\n",
		      intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,
		      intel_dp->panel_power_cycle_delay);

	DRM_DEBUG_KMS("backlight on delay %d, off delay %d\n",
		      intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);
}

static void
intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
					      struct intel_dp *intel_dp)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp_on, pp_off, pp_div, port_sel = 0;
	int div = HAS_PCH_SPLIT(dev) ? intel_pch_rawclk(dev) : intel_hrawclk(dev);
	int pp_on_reg, pp_off_reg, pp_div_reg = 0, pp_ctrl_reg;
	enum port port = dp_to_dig_port(intel_dp)->port;
	const struct edp_power_seq *seq = &intel_dp->pps_delays;

	lockdep_assert_held(&dev_priv->pps_mutex);

	if (IS_BROXTON(dev)) {
		/*
		 * TODO: BXT has 2 sets of PPS registers.
		 * Correct Register for Broxton need to be identified
		 * using VBT. hardcoding for now
		 */
		pp_ctrl_reg = BXT_PP_CONTROL(0);
		pp_on_reg = BXT_PP_ON_DELAYS(0);
		pp_off_reg = BXT_PP_OFF_DELAYS(0);

	} else if (HAS_PCH_SPLIT(dev)) {
		pp_on_reg = PCH_PP_ON_DELAYS;
		pp_off_reg = PCH_PP_OFF_DELAYS;
		pp_div_reg = PCH_PP_DIVISOR;
	} else {
		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);

		pp_on_reg = VLV_PIPE_PP_ON_DELAYS(pipe);
		pp_off_reg = VLV_PIPE_PP_OFF_DELAYS(pipe);
		pp_div_reg = VLV_PIPE_PP_DIVISOR(pipe);
	}

	/*
	 * And finally store the new values in the power sequencer. The
	 * backlight delays are set to 1 because we do manual waits on them. For
	 * T8, even BSpec recommends doing it. For T9, if we don't do this,
	 * we'll end up waiting for the backlight off delay twice: once when we
	 * do the manual sleep, and once when we disable the panel and wait for
	 * the PP_STATUS bit to become zero.
	 */
	pp_on = (seq->t1_t3 << PANEL_POWER_UP_DELAY_SHIFT) |
		(1 << PANEL_LIGHT_ON_DELAY_SHIFT);
	pp_off = (1 << PANEL_LIGHT_OFF_DELAY_SHIFT) |
		 (seq->t10 << PANEL_POWER_DOWN_DELAY_SHIFT);
	/* Compute the divisor for the pp clock, simply match the Bspec
	 * formula. */
	if (IS_BROXTON(dev)) {
		pp_div = I915_READ(pp_ctrl_reg);
		pp_div &= ~BXT_POWER_CYCLE_DELAY_MASK;
		pp_div |= (DIV_ROUND_UP((seq->t11_t12 + 1), 1000)
				<< BXT_POWER_CYCLE_DELAY_SHIFT);
	} else {
		pp_div = ((100 * div)/2 - 1) << PP_REFERENCE_DIVIDER_SHIFT;
		pp_div |= (DIV_ROUND_UP(seq->t11_t12, 1000)
				<< PANEL_POWER_CYCLE_DELAY_SHIFT);
	}

	/* Haswell doesn't have any port selection bits for the panel
	 * power sequencer any more. */
	if (IS_VALLEYVIEW(dev)) {
		port_sel = PANEL_PORT_SELECT_VLV(port);
	} else if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		if (port == PORT_A)
			port_sel = PANEL_PORT_SELECT_DPA;
		else
			port_sel = PANEL_PORT_SELECT_DPD;
	}

	pp_on |= port_sel;

	I915_WRITE(pp_on_reg, pp_on);
	I915_WRITE(pp_off_reg, pp_off);
	if (IS_BROXTON(dev))
		I915_WRITE(pp_ctrl_reg, pp_div);
	else
		I915_WRITE(pp_div_reg, pp_div);

	DRM_DEBUG_KMS("panel power sequencer register settings: PP_ON %#x, PP_OFF %#x, PP_DIV %#x\n",
		      I915_READ(pp_on_reg),
		      I915_READ(pp_off_reg),
		      IS_BROXTON(dev) ?
		      (I915_READ(pp_ctrl_reg) & BXT_POWER_CYCLE_DELAY_MASK) :
		      I915_READ(pp_div_reg));
}

/**
 * intel_dp_set_drrs_state - program registers for RR switch to take effect
 * @@dev: DRM device
 * @@refresh_rate: RR to be programmed
 *
 * This function gets called when refresh rate (RR) has to be changed from
 * one frequency to another. Switches can be between high and low RR
 * supported by the panel or to any other RR based on media playback (in
 * this case, RR value needs to be passed from user space).
 *
 * The caller of this function needs to take a lock on dev_priv->drrs.
 */
static void intel_dp_set_drrs_state(struct drm_device *dev, int refresh_rate)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_encoder *encoder;
	struct intel_digital_port *dig_port = NULL;
	struct intel_dp *intel_dp = dev_priv->drrs.dp;
	struct intel_crtc_state *config = NULL;
	struct intel_crtc *intel_crtc = NULL;
	enum drrs_refresh_rate_type index = DRRS_HIGH_RR;

	if (refresh_rate <= 0) {
		DRM_DEBUG_KMS("Refresh rate should be positive non-zero.\n");
		return;
	}

	if (intel_dp == NULL) {
		DRM_DEBUG_KMS("DRRS not supported.\n");
		return;
	}

	/*
	 * FIXME: This needs proper synchronization with psr state for some
	 * platforms that cannot have PSR and DRRS enabled at the same time.
	 */

	dig_port = dp_to_dig_port(intel_dp);
	encoder = &dig_port->base;
	intel_crtc = to_intel_crtc(encoder->base.crtc);

	if (!intel_crtc) {
		DRM_DEBUG_KMS("DRRS: intel_crtc not initialized\n");
		return;
	}

	config = intel_crtc->config;

	if (dev_priv->drrs.type < SEAMLESS_DRRS_SUPPORT) {
		DRM_DEBUG_KMS("Only Seamless DRRS supported.\n");
		return;
	}

	if (intel_dp->attached_connector->panel.downclock_mode->vrefresh ==
			refresh_rate)
		index = DRRS_LOW_RR;

	if (index == dev_priv->drrs.refresh_rate_type) {
		DRM_DEBUG_KMS(
			"DRRS requested for previously set RR...ignoring\n");
		return;
	}

	if (!intel_crtc->active) {
		DRM_DEBUG_KMS("eDP encoder disabled. CRTC not Active\n");
		return;
	}

	if (INTEL_INFO(dev)->gen >= 8 && !IS_CHERRYVIEW(dev)) {
		switch (index) {
		case DRRS_HIGH_RR:
			intel_dp_set_m_n(intel_crtc, M1_N1);
			break;
		case DRRS_LOW_RR:
			intel_dp_set_m_n(intel_crtc, M2_N2);
			break;
		case DRRS_MAX_RR:
		default:
			DRM_ERROR("Unsupported refreshrate type\n");
		}
	} else if (INTEL_INFO(dev)->gen > 6) {
		u32 reg = PIPECONF(intel_crtc->config->cpu_transcoder);
		u32 val;

		val = I915_READ(reg);
		if (index > DRRS_HIGH_RR) {
			if (IS_VALLEYVIEW(dev))
				val |= PIPECONF_EDP_RR_MODE_SWITCH_VLV;
			else
				val |= PIPECONF_EDP_RR_MODE_SWITCH;
		} else {
			if (IS_VALLEYVIEW(dev))
				val &= ~PIPECONF_EDP_RR_MODE_SWITCH_VLV;
			else
				val &= ~PIPECONF_EDP_RR_MODE_SWITCH;
		}
		I915_WRITE(reg, val);
	}

	dev_priv->drrs.refresh_rate_type = index;

	DRM_DEBUG_KMS("eDP Refresh Rate set to : %dHz\n", refresh_rate);
}

/**
 * intel_edp_drrs_enable - init drrs struct if supported
 * @@intel_dp: DP struct
 *
 * Initializes frontbuffer_bits and drrs.dp
 */
void intel_edp_drrs_enable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = dig_port->base.base.crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	if (!intel_crtc->config->has_drrs) {
		DRM_DEBUG_KMS("Panel doesn't support DRRS\n");
		return;
	}

	mutex_lock(&dev_priv->drrs.mutex);
	if (WARN_ON(dev_priv->drrs.dp)) {
		DRM_ERROR("DRRS already enabled\n");
		goto unlock;
	}

	dev_priv->drrs.busy_frontbuffer_bits = 0;

	dev_priv->drrs.dp = intel_dp;

unlock:
	mutex_unlock(&dev_priv->drrs.mutex);
}

/**
 * intel_edp_drrs_disable - Disable DRRS
 * @@intel_dp: DP struct
 *
 */
void intel_edp_drrs_disable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = dig_port->base.base.crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	if (!intel_crtc->config->has_drrs)
		return;

	mutex_lock(&dev_priv->drrs.mutex);
	if (!dev_priv->drrs.dp) {
		mutex_unlock(&dev_priv->drrs.mutex);
		return;
	}

	if (dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR)
		intel_dp_set_drrs_state(dev_priv->dev,
			intel_dp->attached_connector->panel.
			fixed_mode->vrefresh);

	dev_priv->drrs.dp = NULL;
	mutex_unlock(&dev_priv->drrs.mutex);

	cancel_delayed_work_sync(&dev_priv->drrs.work);
}

static void intel_edp_drrs_downclock_work(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, typeof(*dev_priv), drrs.work.work);
	struct intel_dp *intel_dp;

	mutex_lock(&dev_priv->drrs.mutex);

	intel_dp = dev_priv->drrs.dp;

	if (!intel_dp)
		goto unlock;

	/*
	 * The delayed work can race with an invalidate hence we need to
	 * recheck.
	 */

	if (dev_priv->drrs.busy_frontbuffer_bits)
		goto unlock;

	if (dev_priv->drrs.refresh_rate_type != DRRS_LOW_RR)
		intel_dp_set_drrs_state(dev_priv->dev,
			intel_dp->attached_connector->panel.
			downclock_mode->vrefresh);

unlock:
	mutex_unlock(&dev_priv->drrs.mutex);
}

/**
 * intel_edp_drrs_invalidate - Disable Idleness DRRS
 * @@dev: DRM device
 * @@frontbuffer_bits: frontbuffer plane tracking bits
 *
 * This function gets called everytime rendering on the given planes start.
 * Hence DRRS needs to be Upclocked, i.e. (LOW_RR -> HIGH_RR).
 *
 * Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.
 */
void intel_edp_drrs_invalidate(struct drm_device *dev,
		unsigned frontbuffer_bits)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc;
	enum pipe pipe;

	if (dev_priv->drrs.type == DRRS_NOT_SUPPORTED)
		return;

	cancel_delayed_work(&dev_priv->drrs.work);

	mutex_lock(&dev_priv->drrs.mutex);
	if (!dev_priv->drrs.dp) {
		mutex_unlock(&dev_priv->drrs.mutex);
		return;
	}

	crtc = dp_to_dig_port(dev_priv->drrs.dp)->base.base.crtc;
	pipe = to_intel_crtc(crtc)->pipe;

	frontbuffer_bits &= INTEL_FRONTBUFFER_ALL_MASK(pipe);
	dev_priv->drrs.busy_frontbuffer_bits |= frontbuffer_bits;

	/* invalidate means busy screen hence upclock */
	if (frontbuffer_bits && dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR)
		intel_dp_set_drrs_state(dev_priv->dev,
				dev_priv->drrs.dp->attached_connector->panel.
				fixed_mode->vrefresh);

	mutex_unlock(&dev_priv->drrs.mutex);
}

/**
 * intel_edp_drrs_flush - Restart Idleness DRRS
 * @@dev: DRM device
 * @@frontbuffer_bits: frontbuffer plane tracking bits
 *
 * This function gets called every time rendering on the given planes has
 * completed or flip on a crtc is completed. So DRRS should be upclocked
 * (LOW_RR -> HIGH_RR). And also Idleness detection should be started again,
 * if no other planes are dirty.
 *
 * Dirty frontbuffers relevant to DRRS are tracked in busy_frontbuffer_bits.
 */
void intel_edp_drrs_flush(struct drm_device *dev,
		unsigned frontbuffer_bits)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc;
	enum pipe pipe;

	if (dev_priv->drrs.type == DRRS_NOT_SUPPORTED)
		return;

	cancel_delayed_work(&dev_priv->drrs.work);

	mutex_lock(&dev_priv->drrs.mutex);
	if (!dev_priv->drrs.dp) {
		mutex_unlock(&dev_priv->drrs.mutex);
		return;
	}

	crtc = dp_to_dig_port(dev_priv->drrs.dp)->base.base.crtc;
	pipe = to_intel_crtc(crtc)->pipe;

	frontbuffer_bits &= INTEL_FRONTBUFFER_ALL_MASK(pipe);
	dev_priv->drrs.busy_frontbuffer_bits &= ~frontbuffer_bits;

	/* flush means busy screen hence upclock */
	if (frontbuffer_bits && dev_priv->drrs.refresh_rate_type == DRRS_LOW_RR)
		intel_dp_set_drrs_state(dev_priv->dev,
				dev_priv->drrs.dp->attached_connector->panel.
				fixed_mode->vrefresh);

	/*
	 * flush also means no more activity hence schedule downclock, if all
	 * other fbs are quiescent too
	 */
	if (!dev_priv->drrs.busy_frontbuffer_bits)
		schedule_delayed_work(&dev_priv->drrs.work,
				msecs_to_jiffies(1000));
	mutex_unlock(&dev_priv->drrs.mutex);
}

/**
 * DOC: Display Refresh Rate Switching (DRRS)
 *
 * Display Refresh Rate Switching (DRRS) is a power conservation feature
 * which enables swtching between low and high refresh rates,
 * dynamically, based on the usage scenario. This feature is applicable
 * for internal panels.
 *
 * Indication that the panel supports DRRS is given by the panel EDID, which
 * would list multiple refresh rates for one resolution.
 *
 * DRRS is of 2 types - static and seamless.
 * Static DRRS involves changing refresh rate (RR) by doing a full modeset
 * (may appear as a blink on screen) and is used in dock-undock scenario.
 * Seamless DRRS involves changing RR without any visual effect to the user
 * and can be used during normal system usage. This is done by programming
 * certain registers.
 *
 * Support for static/seamless DRRS may be indicated in the VBT based on
 * inputs from the panel spec.
 *
 * DRRS saves power by switching to low RR based on usage scenarios.
 *
 * eDP DRRS:-
 *        The implementation is based on frontbuffer tracking implementation.
 * When there is a disturbance on the screen triggered by user activity or a
 * periodic system activity, DRRS is disabled (RR is changed to high RR).
 * When there is no movement on screen, after a timeout of 1 second, a switch
 * to low RR is made.
 *        For integration with frontbuffer tracking code,
 * intel_edp_drrs_invalidate() and intel_edp_drrs_flush() are called.
 *
 * DRRS can be further extended to support other internal panels and also
 * the scenario of video playback wherein RR is set based on the rate
 * requested by userspace.
 */

/**
 * intel_dp_drrs_init - Init basic DRRS work and mutex.
 * @@intel_connector: eDP connector
 * @@fixed_mode: preferred mode of panel
 *
 * This function is  called only once at driver load to initialize basic
 * DRRS stuff.
 *
 * Returns:
 * Downclock mode if panel supports it, else return NULL.
 * DRRS support is determined by the presence of downclock mode (apart
 * from VBT setting).
 */
static struct drm_display_mode *
intel_dp_drrs_init(struct intel_connector *intel_connector,
		struct drm_display_mode *fixed_mode)
{
	struct drm_connector *connector = &intel_connector->base;
	struct drm_device *dev = connector->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *downclock_mode = NULL;

	INIT_DELAYED_WORK(&dev_priv->drrs.work, intel_edp_drrs_downclock_work);
	rw_init(&dev_priv->drrs.mutex,"drrs");

	if (INTEL_INFO(dev)->gen <= 6) {
		DRM_DEBUG_KMS("DRRS supported for Gen7 and above\n");
		return NULL;
	}

	if (dev_priv->vbt.drrs_type != SEAMLESS_DRRS_SUPPORT) {
		DRM_DEBUG_KMS("VBT doesn't support DRRS\n");
		return NULL;
	}

	downclock_mode = intel_find_panel_downclock
					(dev, fixed_mode, connector);

	if (!downclock_mode) {
		DRM_DEBUG_KMS("Downclock mode is not found. DRRS not supported\n");
		return NULL;
	}

	dev_priv->drrs.type = dev_priv->vbt.drrs_type;

	dev_priv->drrs.refresh_rate_type = DRRS_HIGH_RR;
	DRM_DEBUG_KMS("seamless DRRS supported for eDP panel.\n");
	return downclock_mode;
}

static bool intel_edp_init_connector(struct intel_dp *intel_dp,
				     struct intel_connector *intel_connector)
{
	struct drm_connector *connector = &intel_connector->base;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = intel_encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *fixed_mode = NULL;
	struct drm_display_mode *downclock_mode = NULL;
	bool has_dpcd;
	struct drm_display_mode *scan;
	struct edid *edid;
	enum pipe pipe = INVALID_PIPE;

	if (!is_edp(intel_dp))
		return true;

	pps_lock(intel_dp);
	intel_edp_panel_vdd_sanitize(intel_dp);
	pps_unlock(intel_dp);

	/* Cache DPCD and EDID for edp. */
	has_dpcd = intel_dp_get_dpcd(intel_dp);

	if (has_dpcd) {
		if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11)
			dev_priv->no_aux_handshake =
				intel_dp->dpcd[DP_MAX_DOWNSPREAD] &
				DP_NO_AUX_HANDSHAKE_LINK_TRAINING;
	} else {
		/* if this fails, presume the device is a ghost */
		DRM_INFO("failed to retrieve link info, disabling eDP\n");
		return false;
	}

	/* We now know it's not a ghost, init power sequence regs. */
	pps_lock(intel_dp);
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp);
	pps_unlock(intel_dp);

	mutex_lock(&dev->mode_config.mutex);
	edid = drm_get_edid(connector, &intel_dp->aux.ddc);
	if (edid) {
		if (drm_add_edid_modes(connector, edid)) {
			drm_mode_connector_update_edid_property(connector,
								edid);
			drm_edid_to_eld(connector, edid);
		} else {
			kfree(edid);
			edid = ERR_PTR(-EINVAL);
		}
	} else {
		edid = ERR_PTR(-ENOENT);
	}
	intel_connector->edid = edid;

	/* prefer fixed mode from EDID if available */
	list_for_each_entry(scan, &connector->probed_modes, head) {
		if ((scan->type & DRM_MODE_TYPE_PREFERRED)) {
			fixed_mode = drm_mode_duplicate(dev, scan);
			downclock_mode = intel_dp_drrs_init(
						intel_connector, fixed_mode);
			break;
		}
	}

	/* fallback to VBT if available for eDP */
	if (!fixed_mode && dev_priv->vbt.lfp_lvds_vbt_mode) {
		fixed_mode = drm_mode_duplicate(dev,
					dev_priv->vbt.lfp_lvds_vbt_mode);
		if (fixed_mode)
			fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
	}
	mutex_unlock(&dev->mode_config.mutex);

	if (IS_VALLEYVIEW(dev)) {
		intel_dp->edp_notifier.notifier_call = edp_notify_handler;
		register_reboot_notifier(&intel_dp->edp_notifier);

		/*
		 * Figure out the current pipe for the initial backlight setup.
		 * If the current pipe isn't valid, try the PPS pipe, and if that
		 * fails just assume pipe A.
		 */
		if (IS_CHERRYVIEW(dev))
			pipe = DP_PORT_TO_PIPE_CHV(intel_dp->DP);
		else
			pipe = PORT_TO_PIPE(intel_dp->DP);

		if (pipe != PIPE_A && pipe != PIPE_B)
			pipe = intel_dp->pps_pipe;

		if (pipe != PIPE_A && pipe != PIPE_B)
			pipe = PIPE_A;

		DRM_DEBUG_KMS("using pipe %c for initial backlight setup\n",
			      pipe_name(pipe));
	}

	intel_panel_init(&intel_connector->panel, fixed_mode, downclock_mode);
	intel_connector->panel.backlight.power = intel_edp_backlight_power;
	intel_panel_setup_backlight(connector, pipe);

	return true;
}

bool
intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
			struct intel_connector *intel_connector)
{
	struct drm_connector *connector = &intel_connector->base;
	struct intel_dp *intel_dp = &intel_dig_port->dp;
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = intel_encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	int type;

	intel_dp->pps_pipe = INVALID_PIPE;

	/* intel_dp vfuncs */
	if (INTEL_INFO(dev)->gen >= 9)
		intel_dp->get_aux_clock_divider = skl_get_aux_clock_divider;
	else if (IS_VALLEYVIEW(dev))
		intel_dp->get_aux_clock_divider = vlv_get_aux_clock_divider;
	else if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		intel_dp->get_aux_clock_divider = hsw_get_aux_clock_divider;
	else if (HAS_PCH_SPLIT(dev))
		intel_dp->get_aux_clock_divider = ilk_get_aux_clock_divider;
	else
		intel_dp->get_aux_clock_divider = i9xx_get_aux_clock_divider;

	if (INTEL_INFO(dev)->gen >= 9)
		intel_dp->get_aux_send_ctl = skl_get_aux_send_ctl;
	else
		intel_dp->get_aux_send_ctl = i9xx_get_aux_send_ctl;

	/* Preserve the current hw state. */
	intel_dp->DP = I915_READ(intel_dp->output_reg);
	intel_dp->attached_connector = intel_connector;

	if (intel_dp_is_edp(dev, port))
		type = DRM_MODE_CONNECTOR_eDP;
	else
		type = DRM_MODE_CONNECTOR_DisplayPort;

	/*
	 * For eDP we always set the encoder type to INTEL_OUTPUT_EDP, but
	 * for DP the encoder type can be set by the caller to
	 * INTEL_OUTPUT_UNKNOWN for DDI, so don't rewrite it.
	 */
	if (type == DRM_MODE_CONNECTOR_eDP)
		intel_encoder->type = INTEL_OUTPUT_EDP;

	/* eDP only on port B and/or C on vlv/chv */
	if (WARN_ON(IS_VALLEYVIEW(dev) && is_edp(intel_dp) &&
		    port != PORT_B && port != PORT_C))
		return false;

	DRM_DEBUG_KMS("Adding %s connector on port %c\n",
			type == DRM_MODE_CONNECTOR_eDP ? "eDP" : "DP",
			port_name(port));

	drm_connector_init(dev, connector, &intel_dp_connector_funcs, type);
	drm_connector_helper_add(connector, &intel_dp_connector_helper_funcs);

	connector->interlace_allowed = true;
	connector->doublescan_allowed = 0;

	INIT_DELAYED_WORK(&intel_dp->panel_vdd_work,
			  edp_panel_vdd_work);

	intel_connector_attach_encoder(intel_connector, intel_encoder);
	drm_connector_register(connector);

	if (HAS_DDI(dev))
		intel_connector->get_hw_state = intel_ddi_connector_get_hw_state;
	else
		intel_connector->get_hw_state = intel_connector_get_hw_state;
	intel_connector->unregister = intel_dp_connector_unregister;

	/* Set up the hotplug pin. */
	switch (port) {
	case PORT_A:
		intel_encoder->hpd_pin = HPD_PORT_A;
		break;
	case PORT_B:
		intel_encoder->hpd_pin = HPD_PORT_B;
		if (IS_BXT_REVID(dev, 0, BXT_REVID_A1))
			intel_encoder->hpd_pin = HPD_PORT_A;
		break;
	case PORT_C:
		intel_encoder->hpd_pin = HPD_PORT_C;
		break;
	case PORT_D:
		intel_encoder->hpd_pin = HPD_PORT_D;
		break;
	case PORT_E:
		intel_encoder->hpd_pin = HPD_PORT_E;
		break;
	default:
		BUG();
	}

	if (is_edp(intel_dp)) {
		pps_lock(intel_dp);
		intel_dp_init_panel_power_timestamps(intel_dp);
		if (IS_VALLEYVIEW(dev))
			vlv_initial_power_sequencer_setup(intel_dp);
		else
			intel_dp_init_panel_power_sequencer(dev, intel_dp);
		pps_unlock(intel_dp);
	}

	intel_dp_aux_init(intel_dp, intel_connector);

	/* init MST on ports that can support it */
	if (HAS_DP_MST(dev) &&
	    (port == PORT_B || port == PORT_C || port == PORT_D))
		intel_dp_mst_encoder_init(intel_dig_port,
					  intel_connector->base.base.id);

	if (!intel_edp_init_connector(intel_dp, intel_connector)) {
		drm_dp_aux_unregister(&intel_dp->aux);
		if (is_edp(intel_dp)) {
			cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
			/*
			 * vdd might still be enabled do to the delayed vdd off.
			 * Make sure vdd is actually turned off here.
			 */
			pps_lock(intel_dp);
			edp_panel_vdd_off_sync(intel_dp);
			pps_unlock(intel_dp);
		}
		drm_connector_unregister(connector);
		drm_connector_cleanup(connector);
		return false;
	}

	intel_dp_add_properties(intel_dp, connector);

	/* For G4X desktop chip, PEG_BAND_GAP_DATA 3:0 must first be written
	 * 0xd.  Failure to do so will result in spurious interrupts being
	 * generated on the port when a cable is not attached.
	 */
	if (IS_G4X(dev) && !IS_GM45(dev)) {
		u32 temp = I915_READ(PEG_BAND_GAP_DATA);
		I915_WRITE(PEG_BAND_GAP_DATA, (temp & ~0xf) | 0xd);
	}

	i915_debugfs_connector_add(connector);

	return true;
}

bool intel_dp_init(struct drm_device *dev,
		   int output_reg,
		   enum port port)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port;
	struct intel_encoder *intel_encoder;
	struct drm_encoder *encoder;
	struct intel_connector *intel_connector;

	intel_dig_port = kzalloc(sizeof(*intel_dig_port), GFP_KERNEL);
	if (!intel_dig_port)
		return false;

	intel_connector = intel_connector_alloc();
	if (!intel_connector)
		goto err_connector_alloc;

	intel_encoder = &intel_dig_port->base;
	encoder = &intel_encoder->base;

	drm_encoder_init(dev, &intel_encoder->base, &intel_dp_enc_funcs,
			 DRM_MODE_ENCODER_TMDS);

	intel_encoder->compute_config = intel_dp_compute_config;
	intel_encoder->disable = intel_disable_dp;
	intel_encoder->get_hw_state = intel_dp_get_hw_state;
	intel_encoder->get_config = intel_dp_get_config;
	intel_encoder->suspend = intel_dp_encoder_suspend;
	if (IS_CHERRYVIEW(dev)) {
		intel_encoder->pre_pll_enable = chv_dp_pre_pll_enable;
		intel_encoder->pre_enable = chv_pre_enable_dp;
		intel_encoder->enable = vlv_enable_dp;
		intel_encoder->post_disable = chv_post_disable_dp;
		intel_encoder->post_pll_disable = chv_dp_post_pll_disable;
	} else if (IS_VALLEYVIEW(dev)) {
		intel_encoder->pre_pll_enable = vlv_dp_pre_pll_enable;
		intel_encoder->pre_enable = vlv_pre_enable_dp;
		intel_encoder->enable = vlv_enable_dp;
		intel_encoder->post_disable = vlv_post_disable_dp;
	} else {
		intel_encoder->pre_enable = g4x_pre_enable_dp;
		intel_encoder->enable = g4x_enable_dp;
		if (INTEL_INFO(dev)->gen >= 5)
			intel_encoder->post_disable = ilk_post_disable_dp;
	}

	intel_dig_port->port = port;
	intel_dig_port->dp.output_reg = output_reg;

	intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
	if (IS_CHERRYVIEW(dev)) {
		if (port == PORT_D)
			intel_encoder->crtc_mask = 1 << 2;
		else
			intel_encoder->crtc_mask = (1 << 0) | (1 << 1);
	} else {
		intel_encoder->crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);
	}
	intel_encoder->cloneable = 0;

	intel_dig_port->hpd_pulse = intel_dp_hpd_pulse;
	dev_priv->hotplug.irq_port[port] = intel_dig_port;

	if (!intel_dp_init_connector(intel_dig_port, intel_connector))
		goto err_init_connector;

	return true;

err_init_connector:
	drm_encoder_cleanup(encoder);
	kfree(intel_connector);
err_connector_alloc:
	kfree(intel_dig_port);
	return false;
}

void intel_dp_mst_suspend(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	/* disable MST */
	for (i = 0; i < I915_MAX_PORTS; i++) {
		struct intel_digital_port *intel_dig_port = dev_priv->hotplug.irq_port[i];
		if (!intel_dig_port)
			continue;

		if (intel_dig_port->base.type == INTEL_OUTPUT_DISPLAYPORT) {
			if (!intel_dig_port->dp.can_mst)
				continue;
			if (intel_dig_port->dp.is_mst)
				drm_dp_mst_topology_mgr_suspend(&intel_dig_port->dp.mst_mgr);
		}
	}
}

void intel_dp_mst_resume(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	for (i = 0; i < I915_MAX_PORTS; i++) {
		struct intel_digital_port *intel_dig_port = dev_priv->hotplug.irq_port[i];
		if (!intel_dig_port)
			continue;
		if (intel_dig_port->base.type == INTEL_OUTPUT_DISPLAYPORT) {
			int ret;

			if (!intel_dig_port->dp.can_mst)
				continue;

			ret = drm_dp_mst_topology_mgr_resume(&intel_dig_port->dp.mst_mgr);
			if (ret != 0) {
				intel_dp_check_mst_status(&intel_dig_port->dp);
			}
		}
	}
}
@


1.28
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d1027 1
a1027 1
	if (IS_SKYLAKE(dev) && port == PORT_E) {
d1202 1
a1202 1
	if (IS_SKYLAKE(dev) && INTEL_REVID(dev) <= SKL_REVID_B0)
d1220 1
a1220 1
	} else if (IS_SKYLAKE(dev)) {
d1540 1
a1540 1
	if (IS_SKYLAKE(dev) && is_edp(intel_dp))
d6059 1
a6059 1
		if (IS_BROXTON(dev_priv) && (INTEL_REVID(dev) < BXT_REVID_B0))
@


1.27
log
@Backport some commits from mainline linux to enable High Bit Rate 2
(HBR2) for Broadwell and non-ULX Haswell DisplayPort.  This enables
support for 3840x2160 60Hz SST.

Initial patch from and tested by Scot Doyle.

drm/i915: Enable 5.4Ghz (HBR2) link rate for Displayport 1.2-capable devices
from Todd Previte
06ea66b6bb445043dc25a9626254d5c130093199

drm/i915: don't try DP_LINK_BW_5_4 on HSW ULX
from Paulo Zanoni
9bbfd20abe5025adbb0ac75160bd2e41158a9e83

drm/i915/dp: add missing \n in the TPS3 debug message
from Jani Nikula
f8d8a672f9370278ae2c9752ad3021662dbc42fd

drm/i915/dp: only use training pattern 3 on platforms that support it
from Jani Nikula
7809a61176b385ebb3299ea43c58b1bb31ffb8c0
@
text
@a0 1
/*	$OpenBSD: intel_dp.c,v 1.26 2015/09/23 23:12:12 kettenis Exp $	*/
d28 7
d36 1
d46 6
d53 1
a53 1
	int link_bw;
d58 1
a58 1
	{ DP_LINK_BW_1_62,
d60 1
a60 1
	{ DP_LINK_BW_2_7,
d65 1
a65 1
	{ DP_LINK_BW_1_62,
d67 1
a67 1
	{ DP_LINK_BW_2_7,
d72 1
a72 1
	{ DP_LINK_BW_1_62,
d74 1
a74 1
	{ DP_LINK_BW_2_7,
d78 24
d129 10
d141 1
a141 1
intel_dp_max_link_bw(struct intel_dp *intel_dp)
a143 1
	struct drm_device *dev = intel_dp->attached_connector->base.dev;
d148 1
a148 8
		break;
	case DP_LINK_BW_5_4: /* 1.2 capable displays may advertise higher bw */
		if (((IS_HASWELL(dev) && !IS_HSW_ULX(dev)) ||
		     INTEL_INFO(dev)->gen >= 8) &&
		    intel_dp->dpcd[DP_DPCD_REV] >= 0x12)
			max_link_bw = DP_LINK_BW_5_4;
		else
			max_link_bw = DP_LINK_BW_2_7;
d159 16
d224 2
a225 2
	max_link_clock = drm_dp_bw_code_to_link_rate(intel_dp_max_link_bw(intel_dp));
	max_lanes = drm_dp_max_lane_count(intel_dp->dpcd);
d242 1
a242 2
static uint32_t
pack_aux(uint8_t *src, int src_bytes)
d254 1
a254 2
static void
unpack_aux(uint32_t src, uint8_t *dst, int dst_bytes)
d263 26
a288 3
/* hrawclock is 1/4 the FSB frequency */
static int
intel_hrawclk(struct drm_device *dev)
d290 3
d294 1
a294 1
	uint32_t clkcfg;
d296 1
a296 3
	/* There is no CLKCFG reg in Valleyview. VLV hrawclk is 200 MHz */
	if (IS_VALLEYVIEW(dev))
		return 200;
d298 2
a299 21
	clkcfg = I915_READ(CLKCFG);
	switch (clkcfg & CLKCFG_FSB_MASK) {
	case CLKCFG_FSB_400:
		return 100;
	case CLKCFG_FSB_533:
		return 133;
	case CLKCFG_FSB_667:
		return 166;
	case CLKCFG_FSB_800:
		return 200;
	case CLKCFG_FSB_1067:
		return 266;
	case CLKCFG_FSB_1333:
		return 333;
	/* these two are just a guess; one of them might be right */
	case CLKCFG_FSB_1600:
	case CLKCFG_FSB_1600_ALT:
		return 400;
	default:
		return 133;
	}
d303 68
a370 7
intel_dp_init_panel_power_sequencer(struct drm_device *dev,
				    struct intel_dp *intel_dp,
				    struct edp_power_seq *out);
static void
intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
					      struct intel_dp *intel_dp,
					      struct edp_power_seq *out);
a375 1
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
d378 2
a379 1
	enum port port = intel_dig_port->port;
d382 81
a462 3
	/* modeset should have pipe */
	if (crtc)
		return to_intel_crtc(crtc)->pipe;
a463 1
	/* init time, try to find a pipe with this port selected */
d467 41
a507 4
		if (port_sel == PANEL_PORT_SELECT_DPB_VLV && port == PORT_B)
			return pipe;
		if (port_sel == PANEL_PORT_SELECT_DPC_VLV && port == PORT_C)
			return pipe;
d510 34
a543 2
	/* shrug */
	return PIPE_A;
d550 3
a552 1
	if (HAS_PCH_SPLIT(dev))
d562 3
a564 1
	if (HAS_PCH_SPLIT(dev))
d570 37
a606 1
static bool ironlake_edp_have_panel_power(struct intel_dp *intel_dp)
d611 6
d620 1
a620 1
static bool ironlake_edp_have_panel_vdd(struct intel_dp *intel_dp)
d625 7
a631 1
	return (I915_READ(_pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD) != 0;
d645 1
a645 1
	if (!ironlake_edp_have_panel_power(intel_dp) && !ironlake_edp_have_panel_vdd(intel_dp)) {
a662 3
	if (cold)
		has_aux_irq = false;

d664 1
a664 1
	if (has_aux_irq)
d677 30
a706 2
static uint32_t get_aux_clock_divider(struct intel_dp *intel_dp,
				      int index)
d712 1
a712 10
	/* The clock divider is based off the hrawclk,
	 * and would like to run at 2MHz. So, take the
	 * hrawclk value and divide by 2 and use that
	 *
	 * Note that PCH attached eDP panels should use a 125MHz input
	 * clock divider.
	 */
	if (IS_VALLEYVIEW(dev)) {
		return index ? 0 : 100;
	} else if (intel_dig_port->port == PORT_A) {
d715 1
a715 6
		if (HAS_DDI(dev))
			return DIV_ROUND_CLOSEST(intel_ddi_get_cdclk_freq(dev_priv), 2000);
		else if (IS_GEN6(dev) || IS_GEN7(dev))
			return 200; /* SNB & IVB eDP input clock at 400Mhz */
		else
			return 225; /* eDP input clock at 450Mhz */
d723 1
a723 1
	} else if (HAS_PCH_SPLIT(dev)) {
a724 2
	} else {
		return index ? 0 :intel_hrawclk(dev) / 2;
d728 60
d790 1
a790 1
		uint8_t *send, int send_bytes,
d801 1
a801 1
	int try, precharge, clock = 0;
d803 11
a813 1
	uint32_t timeout;
a814 1
#ifdef notyet
a819 1
#endif
a822 12
	if (IS_GEN6(dev))
		precharge = 3;
	else
		precharge = 5;

	if (IS_BROADWELL(dev) && ch_ctl == DPA_AUX_CH_CTL)
		timeout = DP_AUX_CH_CTL_TIME_OUT_600us;
	else
		timeout = DP_AUX_CH_CTL_TIME_OUT_400us;

	intel_aux_display_runtime_get(dev_priv);

d832 9
a840 2
		WARN(1, "dp_aux_ch not started status 0x%08x\n",
		     I915_READ(ch_ctl));
d851 6
a856 1
	while ((aux_clock_divider = get_aux_clock_divider(intel_dp, clock++))) {
d862 2
a863 1
					   pack_aux(send + i, send_bytes - i));
d866 1
a866 10
			I915_WRITE(ch_ctl,
				   DP_AUX_CH_CTL_SEND_BUSY |
				   (has_aux_irq ? DP_AUX_CH_CTL_INTERRUPT : 0) |
				   timeout |
				   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
				   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
				   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |
				   DP_AUX_CH_CTL_DONE |
				   DP_AUX_CH_CTL_TIME_OUT_ERROR |
				   DP_AUX_CH_CTL_RECEIVE_ERROR);
d877 10
a886 2
			if (status & (DP_AUX_CH_CTL_TIME_OUT_ERROR |
				      DP_AUX_CH_CTL_RECEIVE_ERROR))
d888 1
d925 2
a926 2
		unpack_aux(I915_READ(ch_data + i),
			   recv + i, recv_bytes - i);
a929 1
#ifdef notyet
d931 5
a935 2
#endif
	intel_aux_display_runtime_put(dev_priv);
d940 8
a947 5
/* Write data to the aux channel in native mode */
static int
intel_dp_aux_native_write(struct intel_dp *intel_dp,
			  uint16_t address, uint8_t *send, int send_bytes)
{
a948 4
	uint8_t	msg[20];
	int msg_bytes;
	uint8_t	ack;
	int retry;
d950 53
a1002 2
	if (WARN_ON(send_bytes > 16))
		return -E2BIG;
d1004 3
a1006 18
	intel_dp_check_edp(intel_dp);
	msg[0] = DP_AUX_NATIVE_WRITE << 4;
	msg[1] = address >> 8;
	msg[2] = address & 0xff;
	msg[3] = send_bytes - 1;
	memcpy(&msg[4], send, send_bytes);
	msg_bytes = send_bytes + 4;
	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp, msg, msg_bytes, &ack, 1);
		if (ret < 0)
			return ret;
		ack >>= 4;
		if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK)
			return send_bytes;
		else if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)
			usleep_range(400, 500);
		else
			return -EIO;
d1009 1
a1009 2
	DRM_ERROR("too many retries, giving up\n");
	return -EIO;
d1012 2
a1013 4
/* Write a single byte to the aux channel in native mode */
static int
intel_dp_aux_native_write_1(struct intel_dp *intel_dp,
			    uint16_t address, uint8_t byte)
d1015 7
a1021 13
	return intel_dp_aux_native_write(intel_dp, address, &byte, 1);
}

/* read bytes from a native aux channel */
static int
intel_dp_aux_native_read(struct intel_dp *intel_dp,
			 uint16_t address, uint8_t *recv, int recv_bytes)
{
	uint8_t msg[4];
	int msg_bytes;
	uint8_t reply[20];
	int reply_bytes;
	uint8_t ack;
a1022 1
	int retry;
d1024 17
a1040 23
	if (WARN_ON(recv_bytes > 19))
		return -E2BIG;

	intel_dp_check_edp(intel_dp);
	msg[0] = DP_AUX_NATIVE_READ << 4;
	msg[1] = address >> 8;
	msg[2] = address & 0xff;
	msg[3] = recv_bytes - 1;

	msg_bytes = 4;
	reply_bytes = recv_bytes + 1;

	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp, msg, msg_bytes,
				      reply, reply_bytes);
		if (ret == 0)
			return -EPROTO;
		if (ret < 0)
			return ret;
		ack = reply[0] >> 4;
		if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK) {
			memcpy(recv, reply + 1, ret - 1);
			return ret - 1;
a1041 4
		else if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)
			usleep_range(400, 500);
		else
			return -EIO;
d1044 20
a1063 45
	DRM_ERROR("too many retries, giving up\n");
	return -EIO;
}

static int
intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,
		    uint8_t write_byte, uint8_t *read_byte)
{
	struct i2c_algo_dp_aux_data *algo_data = adapter->ic_cookie;
	struct intel_dp *intel_dp = container_of(adapter,
						struct intel_dp,
						adapter);
	uint16_t address = algo_data->address;
	uint8_t msg[5];
	uint8_t reply[2];
	unsigned retry;
	int msg_bytes;
	int reply_bytes;
	int ret;

	ironlake_edp_panel_vdd_on(intel_dp);
	intel_dp_check_edp(intel_dp);
	/* Set up the command byte */
	if (mode & MODE_I2C_READ)
		msg[0] = DP_AUX_I2C_READ << 4;
	else
		msg[0] = DP_AUX_I2C_WRITE << 4;

	if (!(mode & MODE_I2C_STOP))
		msg[0] |= DP_AUX_I2C_MOT << 4;

	msg[1] = address >> 8;
	msg[2] = address;

	switch (mode) {
	case MODE_I2C_WRITE:
		msg[3] = 0;
		msg[4] = write_byte;
		msg_bytes = 5;
		reply_bytes = 1;
		break;
	case MODE_I2C_READ:
		msg[3] = 0;
		msg_bytes = 4;
		reply_bytes = 2;
d1066 1
a1066 3
		msg_bytes = 3;
		reply_bytes = 1;
		break;
d1070 7
a1076 3
	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device is
	 * required to retry at least seven times upon receiving AUX_DEFER
	 * before giving up the AUX transaction.
d1078 6
a1083 8
	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp,
				      msg, msg_bytes,
				      reply, reply_bytes);
		if (ret < 0) {
			DRM_DEBUG_KMS("aux_ch failed %d\n", ret);
			goto out;
		}
d1085 4
a1088 30
		switch ((reply[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK) {
		case DP_AUX_NATIVE_REPLY_ACK:
			/* I2C-over-AUX Reply field is only valid
			 * when paired with AUX ACK.
			 */
			break;
		case DP_AUX_NATIVE_REPLY_NACK:
			DRM_DEBUG_KMS("aux_ch native nack\n");
			ret = -EREMOTEIO;
			goto out;
		case DP_AUX_NATIVE_REPLY_DEFER:
			/*
			 * For now, just give more slack to branch devices. We
			 * could check the DPCD for I2C bit rate capabilities,
			 * and if available, adjust the interval. We could also
			 * be more careful with DP-to-Legacy adapters where a
			 * long legacy cable may force very low I2C bit rates.
			 */
			if (intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
			    DP_DWN_STRM_PORT_PRESENT)
				usleep_range(500, 600);
			else
				usleep_range(300, 400);
			continue;
		default:
			DRM_ERROR("aux_ch invalid native reply 0x%02x\n",
				  reply[0]);
			ret = -EREMOTEIO;
			goto out;
		}
d1090 5
a1094 20
		switch ((reply[0] >> 4) & DP_AUX_I2C_REPLY_MASK) {
		case DP_AUX_I2C_REPLY_ACK:
			if (mode == MODE_I2C_READ) {
				*read_byte = reply[1];
			}
			ret = reply_bytes - 1;
			goto out;
		case DP_AUX_I2C_REPLY_NACK:
			DRM_DEBUG_KMS("aux_i2c nack\n");
			ret = -EREMOTEIO;
			goto out;
		case DP_AUX_I2C_REPLY_DEFER:
			DRM_DEBUG_KMS("aux_i2c defer\n");
			udelay(100);
			break;
		default:
			DRM_ERROR("aux_i2c invalid reply 0x%02x\n", reply[0]);
			ret = -EREMOTEIO;
			goto out;
		}
d1097 9
a1105 6
	DRM_ERROR("too many retries, giving up\n");
	ret = -EREMOTEIO;

out:
	ironlake_edp_panel_vdd_off(intel_dp, false);
	return ret;
d1114 3
a1116 2
	sysfs_remove_link(&intel_connector->base.kdev->kobj,
			  intel_dp->adapter.dev.kobj.name);
d1121 65
d1187 1
a1187 2
intel_dp_i2c_init(struct intel_dp *intel_dp,
		  struct intel_connector *intel_connector, const char *name)
d1189 9
a1197 1
	int	ret;
d1199 5
a1203 4
	DRM_DEBUG_KMS("i2c_init %s\n", name);
	intel_dp->algo.running = false;
	intel_dp->algo.address = 0;
	intel_dp->algo.aux_ch = intel_dp_i2c_aux_ch;
d1205 6
a1210 12
	memset(&intel_dp->adapter, '\0', sizeof(intel_dp->adapter));
#ifdef __linux__
	intel_dp->adapter.owner = THIS_MODULE;
	intel_dp->adapter.class = I2C_CLASS_DDC;
	strncpy(intel_dp->adapter.name, name, sizeof(intel_dp->adapter.name) - 1);
	intel_dp->adapter.name[sizeof(intel_dp->adapter.name) - 1] = '\0';
	intel_dp->adapter.algo_data = &intel_dp->algo;
	intel_dp->adapter.dev.parent = intel_connector->base.dev->dev;
#else
	intel_dp->algo.adapter = &intel_dp->adapter;
	intel_dp->adapter.ic_cookie = &intel_dp->algo;
#endif
d1212 4
a1215 3
	ret = i2c_dp_aux_add_bus(&intel_dp->adapter);
	if (ret < 0)
		return ret;
d1217 10
a1226 4
#ifdef __linux__
	ret = sysfs_create_link(&intel_connector->base.kdev->kobj,
				&intel_dp->adapter.dev.kobj,
				intel_dp->adapter.dev.kobj.name);
d1228 3
a1230 3
	if (ret < 0)
		i2c_del_adapter(&intel_dp->adapter);
#endif
d1232 1
a1232 1
	return ret;
d1237 1
a1237 1
		   struct intel_crtc_config *pipe_config, int link_bw)
a1245 2
	} else if (IS_HASWELL(dev)) {
		/* Haswell has special-purpose DP DDI clocks. */
d1249 3
d1259 1
a1259 1
			if (link_bw == divisor[i].link_bw) {
d1268 120
d1390 1
a1390 1
			struct intel_crtc_config *pipe_config)
d1394 1
a1394 1
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
d1397 1
a1397 1
	struct intel_crtc *intel_crtc = encoder->new_crtc;
d1400 2
a1401 1
	int max_lane_count = drm_dp_max_lane_count(intel_dp->dpcd);
d1403 2
a1404 1
	int max_clock = intel_dp_max_link_bw(intel_dp) >> 3;
a1405 1
	static int bws[] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7, DP_LINK_BW_5_4 };
d1407 10
d1422 2
d1428 8
d1448 2
a1449 2
		      "max bw %02x pixel clock %iKHz\n",
		      max_lane_count, bws[max_clock],
d1455 19
a1473 5
	if (is_edp(intel_dp) && dev_priv->vbt.edp_bpp &&
	    dev_priv->vbt.edp_bpp < bpp) {
		DRM_DEBUG_KMS("clamping bpp for eDP panel to BIOS-provided %i\n",
			      dev_priv->vbt.edp_bpp);
		bpp = dev_priv->vbt.edp_bpp;
d1480 6
a1485 3
		for (clock = 0; clock <= max_clock; clock++) {
			for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
				link_clock = drm_dp_bw_code_to_link_rate(bws[clock]);
d1505 5
a1509 4
		if (bpp != 18 && drm_match_cea_mode(adjusted_mode) > 1)
			intel_dp->color_range = DP_COLOR_RANGE_16_235;
		else
			intel_dp->color_range = 0;
d1512 1
a1512 2
	if (intel_dp->color_range)
		pipe_config->limited_color_range = true;
a1513 2
	intel_dp->link_bw = bws[clock];
	intel_dp->lane_count = lane_count;
d1515 1
a1515 1
	pipe_config->port_clock = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);
d1517 5
a1521 2
	DRM_DEBUG_KMS("DP link bw %02x lane count %d clock %d bpp %d\n",
		      intel_dp->link_bw, intel_dp->lane_count,
d1531 17
a1547 1
	intel_dp_set_clock(encoder, pipe_config, intel_dp->link_bw);
d1560 2
a1561 1
	DRM_DEBUG_KMS("eDP PLL enable for clock %d\n", crtc->config.port_clock);
d1565 1
a1565 1
	if (crtc->config.port_clock == 162000) {
d1583 8
a1590 1
static void intel_dp_mode_set(struct intel_encoder *encoder)
d1597 3
a1599 1
	struct drm_display_mode *adjusted_mode = &crtc->config.adjusted_mode;
d1625 1
a1625 1
	intel_dp->DP |= DP_PORT_WIDTH(intel_dp->lane_count);
d1627 1
a1627 3
	if (intel_dp->has_audio) {
		DRM_DEBUG_DRIVER("Enabling DP audio on pipe %c\n",
				 pipe_name(crtc->pipe));
a1628 2
		intel_write_eld(&encoder->base, adjusted_mode);
	}
d1632 1
a1632 1
	if (port == PORT_A && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
d1643 15
a1657 3
	} else if (!HAS_PCH_CPT(dev) || port == PORT_A) {
		if (!HAS_PCH_SPLIT(dev) && !IS_VALLEYVIEW(dev))
			intel_dp->DP |= intel_dp->color_range;
d1668 3
a1670 1
		if (crtc->pipe == 1)
a1671 2
	} else {
		intel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;
a1672 3

	if (port == PORT_A && !IS_VALLEYVIEW(dev))
		ironlake_set_pll_cpu_edp(intel_dp);
d1675 2
a1676 2
#define IDLE_ON_MASK		(PP_ON | 0 	  | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
#define IDLE_ON_VALUE   	(PP_ON | 0 	  | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)
d1678 2
a1679 2
#define IDLE_OFF_MASK		(PP_ON | 0        | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
#define IDLE_OFF_VALUE		(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)
d1681 2
a1682 2
#define IDLE_CYCLE_MASK		(PP_ON | 0        | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)
#define IDLE_CYCLE_VALUE	(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)
d1684 1
a1684 1
static void ironlake_wait_panel_status(struct intel_dp *intel_dp,
d1692 2
d1711 1
a1711 1
static void ironlake_wait_panel_on(struct intel_dp *intel_dp)
d1714 1
a1714 1
	ironlake_wait_panel_status(intel_dp, IDLE_ON_MASK, IDLE_ON_VALUE);
d1717 1
a1717 1
static void ironlake_wait_panel_off(struct intel_dp *intel_dp)
d1720 1
a1720 1
	ironlake_wait_panel_status(intel_dp, IDLE_OFF_MASK, IDLE_OFF_VALUE);
d1723 1
a1723 1
static void ironlake_wait_panel_power_cycle(struct intel_dp *intel_dp)
d1726 13
a1738 1
	ironlake_wait_panel_status(intel_dp, IDLE_CYCLE_MASK, IDLE_CYCLE_VALUE);
d1741 5
d1757 2
d1760 4
a1763 2
	control &= ~PANEL_UNLOCK_MASK;
	control |= PANEL_UNLOCK_REGS;
d1767 6
a1772 1
void ironlake_edp_panel_vdd_on(struct intel_dp *intel_dp)
d1775 2
d1778 1
d1781 3
d1786 1
a1786 4
		return;

	WARN(intel_dp->want_panel_vdd,
	     "eDP VDD already requested on\n");
d1788 1
d1791 2
a1792 2
	if (ironlake_edp_have_panel_vdd(intel_dp))
		return;
d1794 2
a1795 1
	intel_runtime_pm_get(dev_priv);
d1797 2
a1798 1
	DRM_DEBUG_KMS("Turning eDP VDD on\n");
d1800 2
a1801 2
	if (!ironlake_edp_have_panel_power(intel_dp))
		ironlake_wait_panel_power_cycle(intel_dp);
d1816 3
a1818 2
	if (!ironlake_edp_have_panel_power(intel_dp)) {
		DRM_DEBUG_KMS("eDP was not running\n");
d1821 24
d1847 1
a1847 1
static void ironlake_panel_vdd_off_sync(struct intel_dp *intel_dp)
d1851 4
d1858 6
a1863 1
	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
d1865 2
a1866 2
	if (!intel_dp->want_panel_vdd && ironlake_edp_have_panel_vdd(intel_dp)) {
		DRM_DEBUG_KMS("Turning eDP VDD off\n");
d1868 2
a1869 2
		pp = ironlake_get_pp_control(intel_dp);
		pp &= ~EDP_FORCE_VDD;
d1871 2
a1872 2
		pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
		pp_stat_reg = _pp_stat_reg(intel_dp);
d1874 2
a1875 2
		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);
d1877 3
a1879 3
		/* Make sure sequencer is idle before allowing subsequent activity */
		DRM_DEBUG_KMS("PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\n",
		I915_READ(pp_stat_reg), I915_READ(pp_ctrl_reg));
d1881 2
a1882 2
		if ((pp & POWER_TARGET_ON) == 0)
			drm_msleep(intel_dp->panel_power_cycle_delay);
d1884 2
a1885 2
		intel_runtime_pm_put(dev_priv);
	}
d1888 1
a1888 1
static void ironlake_panel_vdd_work(struct work_struct *__work)
a1891 1
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
d1893 4
a1896 3
	mutex_lock(&dev->mode_config.mutex);
	ironlake_panel_vdd_off_sync(intel_dp);
	mutex_unlock(&dev->mode_config.mutex);
d1899 1
a1899 1
void ironlake_edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
d1901 23
d1927 2
a1928 1
	WARN(!intel_dp->want_panel_vdd, "eDP VDD not forced on");
d1932 4
a1935 11
	if (sync) {
		ironlake_panel_vdd_off_sync(intel_dp);
	} else {
		/*
		 * Queue the timer to fire a long
		 * time from now (relative to the power down delay)
		 * to keep the panel power up across a sequence of operations
		 */
		schedule_delayed_work(&intel_dp->panel_vdd_work,
				      msecs_to_jiffies(intel_dp->panel_power_cycle_delay * 5));
	}
d1938 1
a1938 1
void ironlake_edp_panel_on(struct intel_dp *intel_dp)
d1945 2
d1950 2
a1951 1
	DRM_DEBUG_KMS("Turn eDP power on\n");
d1953 3
a1955 2
	if (ironlake_edp_have_panel_power(intel_dp)) {
		DRM_DEBUG_KMS("eDP power already on\n");
a1956 1
	}
d1958 1
a1958 1
	ironlake_wait_panel_power_cycle(intel_dp);
d1976 2
a1977 1
	ironlake_wait_panel_on(intel_dp);
d1986 12
a1997 1
void ironlake_edp_panel_off(struct intel_dp *intel_dp)
d1999 2
d2003 1
d2007 2
d2012 2
a2013 1
	DRM_DEBUG_KMS("Turn eDP power off\n");
d2015 2
a2016 1
	WARN(!intel_dp->want_panel_vdd, "Need VDD to turn off panel\n");
d2021 2
a2022 1
	pp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);
d2026 2
d2031 7
a2037 1
	intel_dp->want_panel_vdd = false;
d2039 4
a2042 1
	ironlake_wait_panel_off(intel_dp);
d2044 3
a2046 2
	/* We got a reference when we enabled the VDD. */
	intel_runtime_pm_put(dev_priv);
d2049 2
a2050 1
void ironlake_edp_backlight_on(struct intel_dp *intel_dp)
a2057 4
	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("\n");
d2064 4
a2067 1
	drm_msleep(intel_dp->backlight_on_delay);
d2076 11
d2088 1
d2091 2
a2092 1
void ironlake_edp_backlight_off(struct intel_dp *intel_dp)
d2102 1
a2102 1
	intel_panel_disable_backlight(intel_dp->attached_connector);
a2103 1
	DRM_DEBUG_KMS("\n");
d2111 43
a2153 1
	drm_msleep(intel_dp->backlight_off_delay);
d2217 2
a2218 4
		ret = intel_dp_aux_native_write_1(intel_dp, DP_SET_POWER,
						  DP_SET_POWER_D3);
		if (ret != 1)
			DRM_DEBUG_DRIVER("failed to write sink power state\n");
d2225 2
a2226 3
			ret = intel_dp_aux_native_write_1(intel_dp,
							  DP_SET_POWER,
							  DP_SET_POWER_D0);
d2232 4
d2245 8
a2252 1
	u32 tmp = I915_READ(intel_dp->output_reg);
d2257 1
a2257 1
	if (port == PORT_A && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
d2259 2
a2260 20
	} else if (!HAS_PCH_CPT(dev) || port == PORT_A) {
		*pipe = PORT_TO_PIPE(tmp);
	} else {
		u32 trans_sel;
		u32 trans_dp;
		int i;

		switch (intel_dp->output_reg) {
		case PCH_DP_B:
			trans_sel = TRANS_DP_PORT_SEL_B;
			break;
		case PCH_DP_C:
			trans_sel = TRANS_DP_PORT_SEL_C;
			break;
		case PCH_DP_D:
			trans_sel = TRANS_DP_PORT_SEL_D;
			break;
		default:
			return true;
		}
d2262 4
a2265 4
		for_each_pipe(i) {
			trans_dp = I915_READ(TRANS_DP_CTL(i));
			if ((trans_dp & TRANS_DP_PORT_SEL_MASK) == trans_sel) {
				*pipe = i;
d2272 4
d2282 1
a2282 1
				struct intel_crtc_config *pipe_config)
d2292 8
a2299 3
	if ((port == PORT_A) || !HAS_PCH_CPT(dev)) {
		tmp = I915_READ(intel_dp->output_reg);
		if (tmp & DP_SYNC_HS_HIGH)
d2304 1
a2304 1
		if (tmp & DP_SYNC_VS_HIGH)
d2309 1
a2309 2
		tmp = I915_READ(TRANS_DP_CTL(crtc->pipe));
		if (tmp & TRANS_DP_HSYNC_ACTIVE_HIGH)
d2314 1
a2314 1
		if (tmp & TRANS_DP_VSYNC_ACTIVE_HIGH)
d2320 5
a2324 1
	pipe_config->adjusted_mode.flags |= flags;
d2328 3
d2346 1
a2346 1
	pipe_config->adjusted_mode.crtc_clock = dotclock;
d2369 1
a2369 1
static bool is_edp_psr(struct drm_device *dev)
d2371 3
a2373 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d2375 2
a2376 2
	return dev_priv->psr.sink_support;
}
d2378 2
a2379 3
static bool intel_edp_is_psr_enabled(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
d2381 6
a2386 2
	if (!HAS_PSR(dev))
		return false;
d2388 3
a2390 1
	return I915_READ(EDP_PSR_CTL(dev)) & EDP_PSR_ENABLE;
d2393 1
a2393 2
static void intel_edp_psr_write_vsc(struct intel_dp *intel_dp,
				    struct edp_vsc_psr *vsc_psr)
d2395 2
a2396 8
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);
	u32 ctl_reg = HSW_TVIDEO_DIP_CTL(crtc->config.cpu_transcoder);
	u32 data_reg = HSW_TVIDEO_DIP_VSC_DATA(crtc->config.cpu_transcoder);
	uint32_t *data = (uint32_t *) vsc_psr;
	unsigned int i;
d2398 4
a2401 5
	/* As per BSPec (Pipe Video Data Island Packet), we need to disable
	   the video DIP being updated before program video DIP data buffer
	   registers for DIP being updated. */
	I915_WRITE(ctl_reg, 0);
	POSTING_READ(ctl_reg);
d2403 3
a2405 6
	for (i = 0; i < VIDEO_DIP_VSC_DATA_SIZE; i += 4) {
		if (i < sizeof(struct edp_vsc_psr))
			I915_WRITE(data_reg + i, *data++);
		else
			I915_WRITE(data_reg + i, 0);
	}
d2407 1
a2407 2
	I915_WRITE(ctl_reg, VIDEO_DIP_ENABLE_VSC_HSW);
	POSTING_READ(ctl_reg);
d2410 2
a2411 1
static void intel_edp_psr_setup(struct intel_dp *intel_dp)
d2413 5
a2417 3
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct edp_vsc_psr psr_vsc;
d2419 6
a2424 2
	if (intel_dp->psr_setup_done)
		return;
d2426 8
a2433 7
	/* Prepare VSC packet as per EDP 1.3 spec, Table 3.10 */
	memset(&psr_vsc, 0, sizeof(psr_vsc));
	psr_vsc.sdp_header.HB0 = 0;
	psr_vsc.sdp_header.HB1 = 0x7;
	psr_vsc.sdp_header.HB2 = 0x2;
	psr_vsc.sdp_header.HB3 = 0x8;
	intel_edp_psr_write_vsc(intel_dp, &psr_vsc);
d2435 7
a2441 3
	/* Avoid continuous PSR exit by masking memup and hpd */
	I915_WRITE(EDP_PSR_DEBUG_CTL(dev), EDP_PSR_DEBUG_MASK_MEMUP |
		   EDP_PSR_DEBUG_MASK_HPD | EDP_PSR_DEBUG_MASK_LPSP);
d2443 9
a2451 1
	intel_dp->psr_setup_done = true;
d2454 1
a2454 1
static void intel_edp_psr_enable_sink(struct intel_dp *intel_dp)
d2456 2
a2457 1
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
a2458 13
	uint32_t aux_clock_divider = get_aux_clock_divider(intel_dp, 0);
	int precharge = 0x3;
	int msg_size = 5;       /* Header(4) + Message(1) */

	/* Enable PSR in sink */
	if (intel_dp->psr_dpcd[1] & DP_PSR_NO_TRAIN_ON_EXIT)
		intel_dp_aux_native_write_1(intel_dp, DP_PSR_EN_CFG,
					    DP_PSR_ENABLE &
					    ~DP_PSR_MAIN_LINK_ACTIVE);
	else
		intel_dp_aux_native_write_1(intel_dp, DP_PSR_EN_CFG,
					    DP_PSR_ENABLE |
					    DP_PSR_MAIN_LINK_ACTIVE);
d2460 1
a2460 9
	/* Setup AUX registers */
	I915_WRITE(EDP_PSR_AUX_DATA1(dev), EDP_PSR_DPCD_COMMAND);
	I915_WRITE(EDP_PSR_AUX_DATA2(dev), EDP_PSR_DPCD_NORMAL_OPERATION);
	I915_WRITE(EDP_PSR_AUX_CTL(dev),
		   DP_AUX_CH_CTL_TIME_OUT_400us |
		   (msg_size << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
		   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
		   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT));
}
d2462 1
a2462 8
static void intel_edp_psr_enable_source(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t max_sleep_time = 0x1f;
	uint32_t idle_frames = 1;
	uint32_t val = 0x0;
	const uint32_t link_entry_time = EDP_PSR_MIN_LINK_ENTRY_TIME_8_LINES;
d2464 2
a2465 7
	if (intel_dp->psr_dpcd[1] & DP_PSR_NO_TRAIN_ON_EXIT) {
		val |= EDP_PSR_LINK_STANDBY;
		val |= EDP_PSR_TP2_TP3_TIME_0us;
		val |= EDP_PSR_TP1_TIME_0us;
		val |= EDP_PSR_SKIP_AUX_EXIT;
	} else
		val |= EDP_PSR_LINK_DISABLE;
d2467 1
a2467 5
	I915_WRITE(EDP_PSR_CTL(dev), val |
		   (IS_BROADWELL(dev) ? 0 : link_entry_time) |
		   max_sleep_time << EDP_PSR_MAX_SLEEP_TIME_SHIFT |
		   idle_frames << EDP_PSR_IDLE_FRAME_SHIFT |
		   EDP_PSR_ENABLE);
d2470 4
a2473 1
static bool intel_edp_psr_match_conditions(struct intel_dp *intel_dp)
d2475 2
a2476 2
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
d2478 1
a2478 4
	struct drm_crtc *crtc = dig_port->base.base.crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_i915_gem_object *obj = to_intel_framebuffer(crtc->fb)->obj;
	struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;
d2480 2
a2481 1
	dev_priv->psr.source_ok = false;
d2483 4
a2486 4
	if (!HAS_PSR(dev)) {
		DRM_DEBUG_KMS("PSR not supported on this platform\n");
		return false;
	}
d2488 4
a2491 5
	if ((intel_encoder->type != INTEL_OUTPUT_EDP) ||
	    (dig_port->port != PORT_A)) {
		DRM_DEBUG_KMS("HSW ties PSR to DDI A (eDP)\n");
		return false;
	}
d2493 12
a2504 4
	if (!i915_enable_psr) {
		DRM_DEBUG_KMS("PSR disable by flag\n");
		return false;
	}
d2506 3
a2508 5
	crtc = dig_port->base.base.crtc;
	if (crtc == NULL) {
		DRM_DEBUG_KMS("crtc not active for PSR\n");
		return false;
	}
d2510 15
a2524 5
	intel_crtc = to_intel_crtc(crtc);
	if (!intel_crtc_active(crtc)) {
		DRM_DEBUG_KMS("crtc not active for PSR\n");
		return false;
	}
d2526 5
a2530 6
	obj = to_intel_framebuffer(crtc->fb)->obj;
	if (obj->tiling_mode != I915_TILING_X ||
	    obj->fence_reg == I915_FENCE_REG_NONE) {
		DRM_DEBUG_KMS("PSR condition failed: fb not tiled or fenced\n");
		return false;
	}
d2532 19
a2550 3
	if (I915_READ(SPRCTL(intel_crtc->pipe)) & SPRITE_ENABLE) {
		DRM_DEBUG_KMS("PSR condition failed: Sprite is Enabled\n");
		return false;
a2551 14

	if (I915_READ(HSW_STEREO_3D_CTL(intel_crtc->config.cpu_transcoder)) &
	    S3D_ENABLE) {
		DRM_DEBUG_KMS("PSR condition failed: Stereo 3D is Enabled\n");
		return false;
	}

	if (intel_crtc->config.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {
		DRM_DEBUG_KMS("PSR condition failed: Interlaced is Enabled\n");
		return false;
	}

	dev_priv->psr.source_ok = true;
	return true;
d2554 1
a2554 1
static void intel_edp_psr_do_enable(struct intel_dp *intel_dp)
d2557 1
d2559 3
a2561 3
	if (!intel_edp_psr_match_conditions(intel_dp) ||
	    intel_edp_is_psr_enabled(dev))
		return;
d2563 2
a2564 2
	/* Setup PSR once */
	intel_edp_psr_setup(intel_dp);
d2566 7
a2572 2
	/* Enable PSR on the panel */
	intel_edp_psr_enable_sink(intel_dp);
d2574 2
a2575 2
	/* Enable PSR on the host */
	intel_edp_psr_enable_source(intel_dp);
d2578 1
a2578 1
void intel_edp_psr_enable(struct intel_dp *intel_dp)
d2580 2
a2581 10
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (intel_edp_psr_match_conditions(intel_dp) &&
	    !intel_edp_is_psr_enabled(dev))
		intel_edp_psr_do_enable(intel_dp);
}

void intel_edp_psr_disable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
d2583 2
d2586 1
a2586 1
	if (!intel_edp_is_psr_enabled(dev))
d2589 4
a2592 2
	I915_WRITE(EDP_PSR_CTL(dev),
		   I915_READ(EDP_PSR_CTL(dev)) & ~EDP_PSR_ENABLE);
d2594 1
a2594 5
	/* Wait till PSR is idle */
	if (_wait_for((I915_READ(EDP_PSR_STATUS_CTL(dev)) &
		       EDP_PSR_STATUS_STATE_MASK) == 0, 2000, 10))
		DRM_ERROR("Timed out waiting for PSR Idle State\n");
}
d2596 3
a2598 4
void intel_edp_psr_update(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	struct intel_dp *intel_dp = NULL;
d2600 1
a2600 3
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, base.head)
		if (encoder->type == INTEL_OUTPUT_EDP) {
			intel_dp = enc_to_intel_dp(&encoder->base);
d2602 2
a2603 2
			if (!is_edp_psr(dev))
				return;
d2605 16
a2620 6
			if (!intel_edp_psr_match_conditions(intel_dp))
				intel_edp_psr_disable(intel_dp);
			else
				if (!intel_edp_is_psr_enabled(dev))
					intel_edp_psr_do_enable(intel_dp);
		}
d2623 1
a2623 1
static void intel_disable_dp(struct intel_encoder *encoder)
a2625 2
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;
d2627 2
a2628 10
	/* Make sure the panel is off before trying to change the mode. But also
	 * ensure that we have vdd while we switch off the panel. */
	ironlake_edp_panel_vdd_on(intel_dp);
	ironlake_edp_backlight_off(intel_dp);
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
	ironlake_edp_panel_off(intel_dp);

	/* cpu edp my only be disable _after_ the cpu pipe/plane is disabled. */
	if (!(port == PORT_A || IS_VALLEYVIEW(dev)))
		intel_dp_link_down(intel_dp);
d2631 1
a2631 1
static void intel_post_disable_dp(struct intel_encoder *encoder)
a2633 2
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;
d2635 2
a2636 5
	if (port == PORT_A || IS_VALLEYVIEW(dev)) {
		intel_dp_link_down(intel_dp);
		if (!IS_VALLEYVIEW(dev))
			ironlake_edp_pll_off(intel_dp);
	}
d2639 1
a2639 1
static void intel_enable_dp(struct intel_encoder *encoder)
d2642 1
a2642 3
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t dp_reg = I915_READ(intel_dp->output_reg);
d2644 1
a2644 2
	if (WARN_ON(dp_reg & DP_PORT_EN))
		return;
d2646 5
a2650 7
	ironlake_edp_panel_vdd_on(intel_dp);
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
	intel_dp_start_link_train(intel_dp);
	ironlake_edp_panel_on(intel_dp);
	ironlake_edp_panel_vdd_off(intel_dp, true);
	intel_dp_complete_link_train(intel_dp);
	intel_dp_stop_link_train(intel_dp);
d2653 1
a2653 1
static void g4x_enable_dp(struct intel_encoder *encoder)
d2655 20
a2674 1
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
d2676 1
a2676 2
	intel_enable_dp(encoder);
	ironlake_edp_backlight_on(intel_dp);
d2679 2
a2680 1
static void vlv_enable_dp(struct intel_encoder *encoder)
d2682 28
a2709 1
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
d2711 3
a2713 1
	ironlake_edp_backlight_on(intel_dp);
d2716 1
a2716 1
static void g4x_pre_enable_dp(struct intel_encoder *encoder)
d2718 33
a2750 2
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
d2752 3
a2754 2
	if (dport->port == PORT_A)
		ironlake_edp_pll_on(intel_dp);
a2765 1
	struct edp_power_seq power_seq;
d2768 1
a2768 1
	mutex_lock(&dev_priv->dpio_lock);
d2781 1
a2781 8
	mutex_unlock(&dev_priv->dpio_lock);

	if (is_edp(intel_dp)) {
		/* init power sequencer on this pipe and port */
		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
							      &power_seq);
	}
a2783 2

	vlv_wait_port_ready(dev_priv, dport);
d2796 2
d2799 1
a2799 1
	mutex_lock(&dev_priv->dpio_lock);
d2813 206
a3018 1
	mutex_unlock(&dev_priv->dpio_lock);
d3024 3
d3028 3
a3030 3
static bool
intel_dp_aux_native_read_retry(struct intel_dp *intel_dp, uint16_t address,
			       uint8_t *recv, int recv_bytes)
d3032 2
a3033 1
	int ret, i;
d3036 3
a3038 2
	 * Sinks are *supposed* to come up within 1ms from an off state,
	 * but we're also supposed to retry 3 times per the spec.
d3040 2
d3043 3
a3045 4
		ret = intel_dp_aux_native_read(intel_dp, address, recv,
					       recv_bytes);
		if (ret == recv_bytes)
			return true;
d3049 1
a3049 1
	return false;
d3059 4
a3062 4
	return intel_dp_aux_native_read_retry(intel_dp,
					      DP_LANE0_1_STATUS,
					      link_status,
					      DP_LINK_STATUS_SIZE);
d3065 1
a3065 5
/*
 * These are source-specific values; current Intel hardware supports
 * a maximum voltage of 800mV and a maximum pre-emphasis of 6dB
 */

d3070 1
d3073 8
a3080 2
	if (IS_VALLEYVIEW(dev) || IS_BROADWELL(dev))
		return DP_TRAIN_VOLTAGE_SWING_1200;
d3082 1
a3082 1
		return DP_TRAIN_VOLTAGE_SWING_800;
d3084 1
a3084 1
		return DP_TRAIN_VOLTAGE_SWING_1200;
d3086 1
a3086 1
		return DP_TRAIN_VOLTAGE_SWING_800;
d3095 1
a3095 1
	if (IS_BROADWELL(dev)) {
d3097 8
a3104 6
		case DP_TRAIN_VOLTAGE_SWING_400:
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
d3106 1
a3106 1
			return DP_TRAIN_PRE_EMPHASIS_0;
d3108 1
a3108 1
	} else if (IS_HASWELL(dev)) {
d3110 7
a3116 7
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_9_5;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
d3118 1
a3118 1
			return DP_TRAIN_PRE_EMPHASIS_0;
d3122 7
a3128 7
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_9_5;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
d3130 1
a3130 1
			return DP_TRAIN_PRE_EMPHASIS_0;
d3134 5
a3138 5
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_600:
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
d3140 1
a3140 1
			return DP_TRAIN_PRE_EMPHASIS_0;
d3144 7
a3150 7
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
d3152 1
a3152 1
			return DP_TRAIN_PRE_EMPHASIS_0;
d3157 1
a3157 1
static uint32_t intel_vlv_signal_levels(struct intel_dp *intel_dp)
d3171 1
a3171 1
	case DP_TRAIN_PRE_EMPHASIS_0:
d3174 1
a3174 1
		case DP_TRAIN_VOLTAGE_SWING_400:
d3178 1
a3178 1
		case DP_TRAIN_VOLTAGE_SWING_600:
d3182 1
a3182 1
		case DP_TRAIN_VOLTAGE_SWING_800:
d3186 1
a3186 1
		case DP_TRAIN_VOLTAGE_SWING_1200:
d3194 1
a3194 1
	case DP_TRAIN_PRE_EMPHASIS_3_5:
d3197 1
a3197 1
		case DP_TRAIN_VOLTAGE_SWING_400:
d3201 1
a3201 1
		case DP_TRAIN_VOLTAGE_SWING_600:
d3205 1
a3205 1
		case DP_TRAIN_VOLTAGE_SWING_800:
d3213 1
a3213 1
	case DP_TRAIN_PRE_EMPHASIS_6:
d3216 1
a3216 1
		case DP_TRAIN_VOLTAGE_SWING_400:
d3220 1
a3220 1
		case DP_TRAIN_VOLTAGE_SWING_600:
d3228 1
a3228 1
	case DP_TRAIN_PRE_EMPHASIS_9_5:
d3231 1
a3231 1
		case DP_TRAIN_VOLTAGE_SWING_400:
d3243 1
a3243 1
	mutex_lock(&dev_priv->dpio_lock);
d3252 175
a3426 1
	mutex_unlock(&dev_priv->dpio_lock);
d3464 1
a3464 1
intel_gen4_signal_levels(uint8_t train_set)
d3469 1
a3469 1
	case DP_TRAIN_VOLTAGE_SWING_400:
d3473 1
a3473 1
	case DP_TRAIN_VOLTAGE_SWING_600:
d3476 1
a3476 1
	case DP_TRAIN_VOLTAGE_SWING_800:
d3479 1
a3479 1
	case DP_TRAIN_VOLTAGE_SWING_1200:
d3484 1
a3484 1
	case DP_TRAIN_PRE_EMPHASIS_0:
d3488 1
a3488 1
	case DP_TRAIN_PRE_EMPHASIS_3_5:
d3491 1
a3491 1
	case DP_TRAIN_PRE_EMPHASIS_6:
d3494 1
a3494 1
	case DP_TRAIN_PRE_EMPHASIS_9_5:
d3503 1
a3503 1
intel_gen6_edp_signal_levels(uint8_t train_set)
d3508 2
a3509 2
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
d3511 1
a3511 1
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
d3513 2
a3514 2
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
d3516 2
a3517 2
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
d3519 2
a3520 2
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
	case DP_TRAIN_VOLTAGE_SWING_1200 | DP_TRAIN_PRE_EMPHASIS_0:
d3531 1
a3531 1
intel_gen7_edp_signal_levels(uint8_t train_set)
d3536 1
a3536 1
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
d3538 1
a3538 1
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
d3540 1
a3540 1
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
d3543 1
a3543 1
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
d3545 1
a3545 1
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
d3548 1
a3548 1
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
d3550 1
a3550 1
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
a3559 69
/* Gen7.5's (HSW) DP voltage swing and pre-emphasis control */
static uint32_t
intel_hsw_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_400MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_400MV_3_5DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_400MV_6DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_9_5:
		return DDI_BUF_EMP_400MV_9_5DB_HSW;

	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_600MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_600MV_3_5DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_600MV_6DB_HSW;

	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_800MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_800MV_3_5DB_HSW;
	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return DDI_BUF_EMP_400MV_0DB_HSW;
	}
}

static uint32_t
intel_bdw_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_400MV_0DB_BDW;	/* Sel0 */
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_400MV_3_5DB_BDW;	/* Sel1 */
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_400MV_6DB_BDW;	/* Sel2 */

	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_600MV_0DB_BDW;	/* Sel3 */
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_600MV_3_5DB_BDW;	/* Sel4 */
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_600MV_6DB_BDW;	/* Sel5 */

	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_800MV_0DB_BDW;	/* Sel6 */
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_800MV_3_5DB_BDW;	/* Sel7 */

	case DP_TRAIN_VOLTAGE_SWING_1200 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_1200MV_0DB_BDW;	/* Sel8 */

	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return DDI_BUF_EMP_400MV_0DB_BDW;	/* Sel0 */
	}
}

d3567 1
a3567 1
	uint32_t signal_levels, mask;
d3570 9
a3578 6
	if (IS_BROADWELL(dev)) {
		signal_levels = intel_bdw_signal_levels(train_set);
		mask = DDI_BUF_EMP_MASK;
	} else if (IS_HASWELL(dev)) {
		signal_levels = intel_hsw_signal_levels(train_set);
		mask = DDI_BUF_EMP_MASK;
d3580 1
a3580 2
		signal_levels = intel_vlv_signal_levels(intel_dp);
		mask = 0;
d3582 1
a3582 1
		signal_levels = intel_gen7_edp_signal_levels(train_set);
d3585 1
a3585 1
		signal_levels = intel_gen6_edp_signal_levels(train_set);
d3588 1
a3588 1
		signal_levels = intel_gen4_signal_levels(train_set);
d3592 8
a3599 1
	DRM_DEBUG_KMS("Using signal levels %08x\n", signal_levels);
d3610 4
a3613 53
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	uint8_t buf[sizeof(intel_dp->train_set) + 1];
	int ret, len;

	if (HAS_DDI(dev)) {
		uint32_t temp = I915_READ(DP_TP_CTL(port));

		if (dp_train_pat & DP_LINK_SCRAMBLING_DISABLE)
			temp |= DP_TP_CTL_SCRAMBLE_DISABLE;
		else
			temp &= ~DP_TP_CTL_SCRAMBLE_DISABLE;

		temp &= ~DP_TP_CTL_LINK_TRAIN_MASK;
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			temp |= DP_TP_CTL_LINK_TRAIN_NORMAL;

			break;
		case DP_TRAINING_PATTERN_1:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
			break;
		case DP_TRAINING_PATTERN_2:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT2;
			break;
		case DP_TRAINING_PATTERN_3:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT3;
			break;
		}
		I915_WRITE(DP_TP_CTL(port), temp);

	} else if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || port != PORT_A)) {
		*DP &= ~DP_LINK_TRAIN_MASK_CPT;

		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF_CPT;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1_CPT;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		}

	} else {
		*DP &= ~DP_LINK_TRAIN_MASK;
d3615 1
a3615 16
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			*DP |= DP_LINK_TRAIN_PAT_2;
			break;
		}
	}
d3631 2
a3632 2
	ret = intel_dp_aux_native_write(intel_dp, DP_TRAINING_PATTERN_SET,
					buf, len);
d3651 2
a3652 2
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
d3661 2
a3662 3
	ret = intel_dp_aux_native_write(intel_dp, DP_TRAINING_LANE0_SET,
					intel_dp->train_set,
					intel_dp->lane_count);
d3699 2
a3700 2
void
intel_dp_start_link_train(struct intel_dp *intel_dp)
d3709 1
d3714 3
d3718 1
a3718 1
	link_config[0] = intel_dp->link_bw;
d3722 4
a3725 1
	intel_dp_aux_native_write(intel_dp, DP_LINK_BW_SET, link_config, 2);
d3729 1
a3729 1
	intel_dp_aux_native_write(intel_dp, DP_DOWNSPREAD_CTRL, link_config, 2);
d3758 1
d3797 2
a3798 2
void
intel_dp_complete_link_train(struct intel_dp *intel_dp)
d3800 2
d3807 11
a3817 2
	/* Training Pattern 3 for HBR2 ot 1.2 devices that support it*/
	if (intel_dp->link_bw == DP_LINK_BW_5_4 || intel_dp->use_tps3)
d3819 2
d3848 3
a3850 2
		if (!drm_dp_clock_recovery_ok(link_status, intel_dp->lane_count)) {
			intel_dp_start_link_train(intel_dp);
d3858 2
a3859 1
		if (drm_dp_channel_eq_ok(link_status, intel_dp->lane_count)) {
d3866 1
a3866 2
			intel_dp_link_down(intel_dp);
			intel_dp_start_link_train(intel_dp);
a3888 1

d3897 7
d3908 1
a3911 2
	struct intel_crtc *intel_crtc =
		to_intel_crtc(intel_dig_port->base.base.crtc);
d3914 1
a3914 16
	/*
	 * DDI code has a strict mode set sequence and we should try to respect
	 * it, otherwise we might hang the machine in many different ways. So we
	 * really should be disabling the port only on a complete crtc_disable
	 * sequence. This function is just called under two conditions on DDI
	 * code:
	 * - Link train failed while doing crtc_enable, and on this case we
	 *   really should respect the mode set sequence and wait for a
	 *   crtc_disable.
	 * - Someone turned the monitor off and intel_dp_check_link_status
	 *   called us. We don't need to disable the whole port on this case, so
	 *   when someone turns the monitor on again,
	 *   intel_ddi_prepare_link_retrain will take care of redoing the link
	 *   train.
	 */
	if (HAS_DDI(dev))
d3922 2
a3923 1
	if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || port != PORT_A)) {
d3925 1
a3925 1
		I915_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE_CPT);
d3927 5
a3931 2
		DP &= ~DP_LINK_TRAIN_MASK;
		I915_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE);
d3933 1
d3936 3
a3938 2
	/* We don't really know why we're doing this */
	intel_wait_for_vblank(dev, intel_crtc->pipe);
d3940 9
a3948 13
	if (HAS_PCH_IBX(dev) &&
	    I915_READ(intel_dp->output_reg) & DP_PIPEB_SELECT) {
		struct drm_crtc *crtc = intel_dig_port->base.base.crtc;

		/* Hardware workaround: leaving our transcoder select
		 * set to transcoder B while it's off will prevent the
		 * corresponding HDMI output on transcoder A.
		 *
		 * Combine this with another hardware workaround:
		 * transcoder select bit can only be cleared while the
		 * port is enabled.
		 */
		DP &= ~DP_PIPEB_SELECT;
d3950 1
d3952 3
a3954 11
		/* Changes to enable or select take place the vblank
		 * after being written.
		 */
		if (WARN_ON(crtc == NULL)) {
			/* We should never try to disable a port without a crtc
			 * attached. For paranoia keep the code around for a
			 * bit. */
			POSTING_READ(intel_dp->output_reg);
			drm_msleep(50);
		} else
			intel_wait_for_vblank(dev, intel_crtc->pipe);
a3956 3
	DP &= ~DP_AUDIO_OUTPUT_ENABLE;
	I915_WRITE(intel_dp->output_reg, DP & ~DP_PORT_EN);
	POSTING_READ(intel_dp->output_reg);
d3966 1
d3968 2
a3969 6
#ifdef notyet
	char dpcd_hex_dump[sizeof(intel_dp->dpcd) * 3];
#endif

	if (intel_dp_aux_native_read_retry(intel_dp, 0x000, intel_dp->dpcd,
					   sizeof(intel_dp->dpcd)) == 0)
d3972 1
a3972 5
#ifdef notyet
	hex_dump_to_buffer(intel_dp->dpcd, sizeof(intel_dp->dpcd),
			   32, 1, dpcd_hex_dump, sizeof(dpcd_hex_dump), false);
	DRM_DEBUG_KMS("DPCD: %s\n", dpcd_hex_dump);
#endif
d3980 3
a3982 3
		intel_dp_aux_native_read_retry(intel_dp, DP_PSR_SUPPORT,
					       intel_dp->psr_dpcd,
					       sizeof(intel_dp->psr_dpcd));
d3987 44
d4033 1
a4033 8
	/* Training Pattern 3 support, both source and sink */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x12 &&
	    intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_TPS3_SUPPORTED &&
	    (IS_HASWELL(dev) || INTEL_INFO(dev)->gen >= 8)) {
		intel_dp->use_tps3 = true;
		DRM_DEBUG_KMS("Displayport TPS3 supported\n");
	} else
		intel_dp->use_tps3 = false;
d4042 3
a4044 3
	if (intel_dp_aux_native_read_retry(intel_dp, DP_DOWNSTREAM_PORT_0,
					   intel_dp->downstream_ports,
					   DP_MAX_DOWNSTREAM_PORTS) == 0)
d4058 1
a4058 3
	ironlake_edp_panel_vdd_on(intel_dp);

	if (intel_dp_aux_native_read_retry(intel_dp, DP_SINK_OUI, buf, 3))
d4062 1
a4062 1
	if (intel_dp_aux_native_read_retry(intel_dp, DP_BRANCH_OUI, buf, 3))
d4065 71
d4137 75
a4211 1
	ironlake_edp_panel_vdd_off(intel_dp, false);
d4217 8
d4227 4
a4230 4
	ret = intel_dp_aux_native_read_retry(intel_dp,
					     DP_DEVICE_SERVICE_IRQ_VECTOR,
					     sink_irq_vector, 1);
	if (!ret)
d4236 119
a4354 2
static void
intel_dp_handle_test_request(struct intel_dp *intel_dp)
d4356 52
a4407 2
	/* NAK by default */
	intel_dp_aux_native_write_1(intel_dp, DP_TEST_RESPONSE, DP_TEST_NAK);
d4418 1
a4418 2

void
d4421 1
d4426 3
a4428 1
	if (!intel_encoder->connectors_active)
d4431 1
a4431 1
	if (WARN_ON(!intel_encoder->base.crtc))
d4448 3
a4450 3
		intel_dp_aux_native_write_1(intel_dp,
					    DP_DEVICE_SERVICE_IRQ_VECTOR,
					    sink_irq_vector);
d4453 1
a4453 1
			intel_dp_handle_test_request(intel_dp);
d4460 1
a4460 1
			      drm_get_encoder_name(&intel_encoder->base));
a4461 1
		intel_dp_complete_link_train(intel_dp);
d4484 3
a4486 2
		if (!intel_dp_aux_native_read_retry(intel_dp, DP_SINK_COUNT,
						    &reg, 1))
d4488 1
d4494 1
a4494 1
	if (drm_probe_ddc(&intel_dp->adapter))
d4517 160
a4681 1
	enum drm_connector_status status;
d4683 1
a4683 9
	/* Can't disconnect eDP, but you can close the lid... */
	if (is_edp(intel_dp)) {
		status = intel_panel_detect(dev);
		if (status == connector_status_unknown)
			status = connector_status_connected;
		return status;
	}

	if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
a4692 1
	struct drm_i915_private *dev_priv = dev->dev_private;
a4693 1
	uint32_t bit;
d4705 1
a4705 31
	if (IS_VALLEYVIEW(dev)) {
		switch (intel_dig_port->port) {
		case PORT_B:
			bit = PORTB_HOTPLUG_LIVE_STATUS_VLV;
			break;
		case PORT_C:
			bit = PORTC_HOTPLUG_LIVE_STATUS_VLV;
			break;
		case PORT_D:
			bit = PORTD_HOTPLUG_LIVE_STATUS_VLV;
			break;
		default:
			return connector_status_unknown;
		}
	} else {
		switch (intel_dig_port->port) {
		case PORT_B:
			bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
			break;
		case PORT_C:
			bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
			break;
		case PORT_D:
			bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
			break;
		default:
			return connector_status_unknown;
		}
	}

	if ((I915_READ(PORT_HOTPLUG_STAT) & bit) == 0)
d4712 1
a4712 1
intel_dp_get_edid(struct drm_connector *connector, struct i2c_adapter *adapter)
d4714 1
a4714 1
	struct intel_connector *intel_connector = to_intel_connector(connector);
d4723 13
a4735 1
	}
d4737 4
a4740 1
	return drm_get_edid(connector, adapter);
d4743 2
a4744 2
static int
intel_dp_get_edid_modes(struct drm_connector *connector, struct i2c_adapter *adapter)
d4746 1
a4746 1
	struct intel_connector *intel_connector = to_intel_connector(connector);
d4748 2
a4749 5
	/* use cached edid if we have one */
	if (intel_connector->edid) {
		/* invalid edid */
		if (IS_ERR(intel_connector->edid))
			return 0;
d4751 1
a4751 5
		return intel_connector_update_modes(connector,
						    intel_connector->edid);
	}

	return intel_ddc_get_modes(connector, adapter);
a4760 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d4762 3
a4764 1
	struct edid *edid = NULL;
d4766 3
a4768 1
	intel_runtime_pm_get(dev_priv);
d4770 6
a4775 2
	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.id, drm_get_connector_name(connector));
d4777 2
a4778 1
	intel_dp->has_audio = false;
d4780 4
a4783 1
	if (HAS_PCH_SPLIT(dev))
a4786 1

d4792 8
a4799 8
	if (intel_dp->force_audio != HDMI_AUDIO_AUTO) {
		intel_dp->has_audio = (intel_dp->force_audio == HDMI_AUDIO_ON);
	} else {
		edid = intel_dp_get_edid(connector, &intel_dp->adapter);
		if (edid) {
			intel_dp->has_audio = drm_detect_monitor_audio(edid);
			kfree(edid);
		}
d4802 2
d4808 14
d4823 1
a4823 1
	intel_runtime_pm_put(dev_priv);
d4827 26
a4854 1
	struct intel_dp *intel_dp = intel_attached_dp(connector);
d4856 1
a4856 2
	struct drm_device *dev = connector->dev;
	int ret;
d4858 6
a4863 6
	/* We should parse the EDID data and find out if it has an audio sink
	 */

	ret = intel_dp_get_edid_modes(connector, &intel_dp->adapter);
	if (ret)
		return ret;
d4866 2
a4867 1
	if (is_edp(intel_dp) && intel_connector->panel.fixed_mode) {
d4869 2
a4870 1
		mode = drm_mode_duplicate(dev,
d4877 1
d4884 1
a4884 1
	struct intel_dp *intel_dp = intel_attached_dp(connector);
a4885 1
	bool has_audio = false;
d4887 2
a4888 2
	edid = intel_dp_get_edid(connector, &intel_dp->adapter);
	if (edid) {
a4889 2
		kfree(edid);
	}
d4932 1
a4932 1
		uint32_t old_range = intel_dp->color_range;
d4940 1
a4940 1
			intel_dp->color_range = 0;
d4944 1
a4944 1
			intel_dp->color_range = DP_COLOR_RANGE_16_235;
d4951 1
a4951 1
		    old_range == intel_dp->color_range)
d4987 2
a5004 1
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
d5006 2
a5007 4
#ifdef notyet
	i2c_del_adapter(&intel_dp->adapter);
#endif
	drm_encoder_cleanup(encoder);
d5010 12
a5021 3
		mutex_lock(&dev->mode_config.mutex);
		ironlake_panel_vdd_off_sync(intel_dp);
		mutex_unlock(&dev->mode_config.mutex);
d5023 1
d5027 67
d5095 1
a5095 1
	.dpms = intel_connector_dpms,
d5097 1
d5100 1
d5102 2
d5113 1
d5117 2
a5118 2
static void
intel_dp_hot_plug(struct intel_encoder *intel_encoder)
d5120 6
a5125 1
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
d5127 67
a5193 2
	intel_dp_check_link_status(intel_dp);
}
d5214 1
a5214 1
/* check the VBT to see whether the eDP is on DP-D port */
d5221 4
a5224 3
		[PORT_B] = PORT_IDPB,
		[PORT_C] = PORT_IDPC,
		[PORT_D] = PORT_IDPD,
d5227 7
d5251 1
a5251 1
static void
d5270 7
d5279 1
a5279 2
				    struct intel_dp *intel_dp,
				    struct edp_power_seq *out)
d5282 6
a5287 3
	struct edp_power_seq cur, vbt, spec, final;
	u32 pp_on, pp_off, pp_div, pp;
	int pp_ctrl_reg, pp_on_reg, pp_off_reg, pp_div_reg;
d5289 14
a5302 1
	if (HAS_PCH_SPLIT(dev)) {
d5318 1
a5318 2
	pp = ironlake_get_pp_control(intel_dp);
	I915_WRITE(pp_ctrl_reg, pp);
d5322 4
a5325 1
	pp_div = I915_READ(pp_div_reg);
d5340 9
a5348 1
	cur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>
d5350 1
d5374 1
a5374 1
#define assign_final(field)	final.field = (max(cur.field, vbt.field) == 0 ? \
d5384 1
a5384 1
#define get_delay(field)	(DIV_ROUND_UP(final.field, 10))
a5397 3

	if (out)
		*out = final;
d5402 1
a5402 2
					      struct intel_dp *intel_dp,
					      struct edp_power_seq *seq)
d5407 15
a5421 1
	int pp_on_reg, pp_off_reg, pp_div_reg;
d5423 1
a5423 1
	if (HAS_PCH_SPLIT(dev)) {
d5435 8
a5442 1
	/* And finally store the new values in the power sequencer. */
d5444 2
a5445 2
		(seq->t8 << PANEL_LIGHT_ON_DELAY_SHIFT);
	pp_off = (seq->t9 << PANEL_LIGHT_OFF_DELAY_SHIFT) |
d5449 10
a5458 3
	pp_div = ((100 * div)/2 - 1) << PP_REFERENCE_DIVIDER_SHIFT;
	pp_div |= (DIV_ROUND_UP(seq->t11_t12, 1000)
			<< PANEL_POWER_CYCLE_DELAY_SHIFT);
d5463 1
a5463 4
		if (dp_to_dig_port(intel_dp)->port == PORT_B)
			port_sel = PANEL_PORT_SELECT_DPB_VLV;
		else
			port_sel = PANEL_PORT_SELECT_DPC_VLV;
d5465 1
a5465 1
		if (dp_to_dig_port(intel_dp)->port == PORT_A)
d5475 4
a5478 1
	I915_WRITE(pp_div_reg, pp_div);
d5483 2
d5488 382
d5875 2
a5876 1
	struct drm_device *dev = intel_dig_port->base.base.dev;
d5879 1
a5879 1
	struct edp_power_seq power_seq = { 0 };
d5883 1
d5888 3
a5890 1
	intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
a5892 1
	ironlake_edp_panel_vdd_on(intel_dp);
a5893 1
	ironlake_edp_panel_vdd_off(intel_dp, false);
d5907 3
a5909 2
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
						      &power_seq);
d5911 2
a5912 1
	edid = drm_get_edid(connector, &intel_dp->adapter);
d5931 2
d5944 25
d5970 3
a5972 2
	intel_panel_init(&intel_connector->panel, fixed_mode);
	intel_panel_setup_backlight(connector);
d5987 20
a6006 2
	const char *name = NULL;
	int type, error;
d6025 5
d6041 1
a6041 1
			  ironlake_panel_vdd_work);
d6044 1
a6044 1
	drm_sysfs_connector_add(connector);
d6052 1
a6052 21
	intel_dp->aux_ch_ctl_reg = intel_dp->output_reg + 0x10;
	if (HAS_DDI(dev)) {
		switch (intel_dig_port->port) {
		case PORT_A:
			intel_dp->aux_ch_ctl_reg = DPA_AUX_CH_CTL;
			break;
		case PORT_B:
			intel_dp->aux_ch_ctl_reg = PCH_DPB_AUX_CH_CTL;
			break;
		case PORT_C:
			intel_dp->aux_ch_ctl_reg = PCH_DPC_AUX_CH_CTL;
			break;
		case PORT_D:
			intel_dp->aux_ch_ctl_reg = PCH_DPD_AUX_CH_CTL;
			break;
		default:
			BUG();
		}
	}

	/* Set up the DDC bus. */
a6055 1
		name = "DPDDC-A";
d6059 2
a6060 1
		name = "DPDDC-B";
a6063 1
		name = "DPDDC-C";
d6067 3
a6069 1
		name = "DPDDC-D";
d6075 9
a6083 3
	error = intel_dp_i2c_init(intel_dp, intel_connector, name);
	WARN(error, "intel_dp_i2c_init failed with error %d for port %c\n",
	     error, port_name(port));
d6085 7
a6091 1
	intel_dp->psr_setup_done = false;
d6094 1
a6094 3
#ifdef notyet
		i2c_del_adapter(&intel_dp->adapter);
#endif
d6097 7
a6103 3
			mutex_lock(&dev->mode_config.mutex);
			ironlake_panel_vdd_off_sync(intel_dp);
			mutex_unlock(&dev->mode_config.mutex);
d6105 1
a6105 1
		drm_sysfs_connector_remove(connector);
d6121 2
d6126 3
a6128 2
void
intel_dp_init(struct drm_device *dev, int output_reg, enum port port)
d6130 1
d6138 1
a6138 1
		return;
d6140 3
a6142 5
	intel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);
	if (!intel_connector) {
		kfree(intel_dig_port);
		return;
	}
a6150 1
	intel_encoder->mode_set = intel_dp_mode_set;
a6151 1
	intel_encoder->post_disable = intel_post_disable_dp;
d6154 8
a6161 1
	if (IS_VALLEYVIEW(dev)) {
d6165 1
d6169 2
d6177 66
a6242 8
	intel_encoder->crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);
	intel_encoder->cloneable = false;
	intel_encoder->hot_plug = intel_dp_hot_plug;

	if (!intel_dp_init_connector(intel_dig_port, intel_connector)) {
		drm_encoder_cleanup(encoder);
		kfree(intel_dig_port);
		kfree(intel_connector);
@


1.26
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.25 2015/06/24 08:32:39 kettenis Exp $	*/
d97 1
d104 6
a109 1
		max_link_bw = DP_LINK_BW_2_7;
d856 2
a857 1
	int max_clock = intel_dp_max_link_bw(intel_dp) == DP_LINK_BW_2_7 ? 1 : 0;
d859 1
a859 1
	static int bws[2] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7 };
d2683 5
d2691 1
a2691 1
				     DP_TRAINING_PATTERN_2 |
d2718 1
a2718 1
						DP_TRAINING_PATTERN_2 |
d2734 1
a2734 1
						DP_TRAINING_PATTERN_2 |
d2879 9
@


1.25
log
@Introduce Linux work queue APIs and use them.  As a side-effect, this will
move some of the work from the system task queue to the driver-specific
task queue.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.24 2015/04/12 11:26:54 jsg Exp $	*/
d39 26
a78 24
/**
 * is_pch_edp - is the port on the PCH and attached to an eDP panel?
 * @@intel_dp: DP struct
 *
 * Returns true if the given DP struct corresponds to a PCH DP port attached
 * to an eDP panel, false otherwise.  Helpful for determining whether we
 * may need FDI resources for a given DP output or not.
 */
static bool is_pch_edp(struct intel_dp *intel_dp)
{
	return intel_dp->is_pch_edp;
}

/**
 * is_cpu_edp - is the port on the CPU and attached to an eDP panel?
 * @@intel_dp: DP struct
 *
 * Returns true if the given DP struct corresponds to a CPU eDP port.
 */
static bool is_cpu_edp(struct intel_dp *intel_dp)
{
	return is_edp(intel_dp) && !is_pch_edp(intel_dp);
}

a90 19
/**
 * intel_encoder_is_pch_edp - is the given encoder a PCH attached eDP?
 * @@encoder: DRM encoder
 *
 * Return true if @@encoder corresponds to a PCH attached eDP panel.  Needed
 * by intel_display.c.
 */
bool intel_encoder_is_pch_edp(struct drm_encoder *encoder)
{
	struct intel_dp *intel_dp;

	if (!encoder)
		return false;

	intel_dp = enc_to_intel_dp(encoder);

	return is_pch_edp(intel_dp);
}

a92 23
void
intel_edp_link_config(struct intel_encoder *intel_encoder,
		       int *lane_num, int *link_bw)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);

	*lane_num = intel_dp->lane_count;
	*link_bw = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);
}

int
intel_edp_target_clock(struct intel_encoder *intel_encoder,
		       struct drm_display_mode *mode)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
	struct intel_connector *intel_connector = intel_dp->attached_connector;

	if (intel_connector->panel.fixed_mode)
		return intel_connector->panel.fixed_mode->clock;
	else
		return mode->clock;
}

d143 1
a143 29
static bool
intel_dp_adjust_dithering(struct intel_dp *intel_dp,
			  struct drm_display_mode *mode,
			  bool adjust_mode)
{
	int max_link_clock =
		drm_dp_bw_code_to_link_rate(intel_dp_max_link_bw(intel_dp));
	int max_lanes = drm_dp_max_lane_count(intel_dp->dpcd);
	int max_rate, mode_rate;

	mode_rate = intel_dp_link_required(mode->clock, 24);
	max_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);

	if (mode_rate > max_rate) {
		mode_rate = intel_dp_link_required(mode->clock, 18);
		if (mode_rate > max_rate)
			return false;

		if (adjust_mode)
			mode->private_flags
				|= INTEL_MODE_DP_FORCE_6BPC;

		return true;
	}

	return true;
}

static int
d150 2
d159 2
d163 7
a169 1
	if (!intel_dp_adjust_dithering(intel_dp, mode, false))
d238 57
d300 1
a300 1
	return (I915_READ(PCH_PP_STATUS) & PP_ON) != 0;
d308 1
a308 1
	return (I915_READ(PCH_PP_CONTROL) & EDP_FORCE_VDD) != 0;
d321 1
d325 2
a326 2
			      I915_READ(PCH_PP_STATUS),
			      I915_READ(PCH_PP_CONTROL));
d330 2
a331 4
static int
intel_dp_aux_ch(struct intel_dp *intel_dp,
		uint8_t *send, int send_bytes,
		uint8_t *recv, int recv_size)
a332 1
	uint32_t output_reg = intel_dp->output_reg;
d336 1
a336 4
	uint32_t ch_ctl = output_reg + 0x10;
	uint32_t ch_data = ch_ctl + 4;
	int i;
	int recv_bytes;
d338 18
a355 2
	uint32_t aux_clock_divider;
	int try, precharge;
d357 6
a362 22
	if (IS_HASWELL(dev)) {
		switch (intel_dig_port->port) {
		case PORT_A:
			ch_ctl = DPA_AUX_CH_CTL;
			ch_data = DPA_AUX_CH_DATA1;
			break;
		case PORT_B:
			ch_ctl = PCH_DPB_AUX_CH_CTL;
			ch_data = PCH_DPB_AUX_CH_DATA1;
			break;
		case PORT_C:
			ch_ctl = PCH_DPC_AUX_CH_CTL;
			ch_data = PCH_DPC_AUX_CH_DATA1;
			break;
		case PORT_D:
			ch_ctl = PCH_DPD_AUX_CH_CTL;
			ch_data = PCH_DPD_AUX_CH_DATA1;
			break;
		default:
			BUG();
		}
	}
a363 1
	intel_dp_check_edp(intel_dp);
d371 5
a375 1
	if (is_cpu_edp(intel_dp)) {
d377 1
a377 3
			aux_clock_divider = intel_ddi_get_cdclk_freq(dev_priv) >> 1;
		else if (IS_VALLEYVIEW(dev))
			aux_clock_divider = 100;
d379 1
a379 1
			aux_clock_divider = 200; /* SNB & IVB eDP input clock at 400Mhz */
d381 41
a421 5
			aux_clock_divider = 225; /* eDP input clock at 450Mhz */
	} else if (HAS_PCH_SPLIT(dev))
		aux_clock_divider = DIV_ROUND_UP(intel_pch_rawclk(dev), 2);
	else
		aux_clock_divider = intel_hrawclk(dev) / 2;
d428 7
d437 1
a437 1
		status = I915_READ(ch_ctl);
d440 1
a440 1
		drm_msleep(1, "915ach");
d446 2
a447 1
		return -EBUSY;
d450 40
a489 22
	/* Must try at least 3 times according to DP spec */
	for (try = 0; try < 5; try++) {
		/* Load the send data into the aux channel data registers */
		for (i = 0; i < send_bytes; i += 4)
			I915_WRITE(ch_data + i,
				   pack_aux(send + i, send_bytes - i));

		/* Send the command and wait for it to complete */
		I915_WRITE(ch_ctl,
			   DP_AUX_CH_CTL_SEND_BUSY |
			   DP_AUX_CH_CTL_TIME_OUT_400us |
			   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
			   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
			   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |
			   DP_AUX_CH_CTL_DONE |
			   DP_AUX_CH_CTL_TIME_OUT_ERROR |
			   DP_AUX_CH_CTL_RECEIVE_ERROR);
		for (;;) {
			status = I915_READ(ch_ctl);
			if ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)
				break;
			udelay(100);
a490 13

		/* Clear done status and any errors */
		I915_WRITE(ch_ctl,
			   status |
			   DP_AUX_CH_CTL_DONE |
			   DP_AUX_CH_CTL_TIME_OUT_ERROR |
			   DP_AUX_CH_CTL_RECEIVE_ERROR);

		if (status & (DP_AUX_CH_CTL_TIME_OUT_ERROR |
			      DP_AUX_CH_CTL_RECEIVE_ERROR))
			continue;
		if (status & DP_AUX_CH_CTL_DONE)
			break;
d495 2
a496 1
		return -EBUSY;
d499 1
d505 2
a506 1
		return -EIO;
d513 2
a514 1
		return -ETIMEDOUT;
d527 8
a534 1
	return recv_bytes;
d548 3
d552 1
a552 3
	if (send_bytes > 16)
		return -1;
	msg[0] = AUX_NATIVE_WRITE << 4;
d562 2
a563 1
		if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK)
d565 1
a565 1
		else if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)
d596 3
d600 1
a600 1
	msg[0] = AUX_NATIVE_READ << 4;
d615 2
a616 2
		ack = reply[0];
		if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK) {
d620 1
a620 1
		else if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)
d631 1
a631 1
intel_dp_i2c_aux_ch(struct i2c_controller *adapter, int mode,
d646 1
d650 1
a650 1
		msg[0] = AUX_I2C_READ << 4;
d652 1
a652 1
		msg[0] = AUX_I2C_WRITE << 4;
d655 1
a655 1
		msg[0] |= AUX_I2C_MOT << 4;
d678 6
a683 1
	for (retry = 0; retry < 5; retry++) {
d689 1
a689 1
			return ret;
d692 2
a693 2
		switch (reply[0] & AUX_NATIVE_REPLY_MASK) {
		case AUX_NATIVE_REPLY_ACK:
d698 1
a698 1
		case AUX_NATIVE_REPLY_NACK:
d700 3
a702 2
			return -EREMOTEIO;
		case AUX_NATIVE_REPLY_DEFER:
d719 2
a720 1
			return -EREMOTEIO;
d723 2
a724 2
		switch (reply[0] & AUX_I2C_REPLY_MASK) {
		case AUX_I2C_REPLY_ACK:
d728 3
a730 2
			return reply_bytes - 1;
		case AUX_I2C_REPLY_NACK:
d732 3
a734 2
			return -EREMOTEIO;
		case AUX_I2C_REPLY_DEFER:
d740 2
a741 1
			return -EREMOTEIO;
d746 17
a762 1
	return -EREMOTEIO;
a774 1
	intel_dp->algo.adapter = &intel_dp->adapter;
d777 1
a777 1
#if 0
d782 4
a785 1
#endif
a786 2
#if 0
	intel_dp->adapter.dev.parent = &intel_connector->base.kdev;
a788 1
	ironlake_edp_panel_vdd_on(intel_dp);
d790 12
a801 1
	ironlake_edp_panel_vdd_off(intel_dp, false);
d805 32
d838 2
a839 3
intel_dp_mode_fixup(struct drm_encoder *encoder,
		    const struct drm_display_mode *mode,
		    struct drm_display_mode *adjusted_mode)
d841 6
a846 2
	struct drm_device *dev = encoder->dev;
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
d853 6
d863 6
a868 3
		intel_pch_panel_fitting(dev,
					intel_connector->panel.fitting_mode,
					mode, adjusted_mode);
d876 2
a877 7
		      max_lane_count, bws[max_clock], adjusted_mode->clock);

	if (!intel_dp_adjust_dithering(intel_dp, adjusted_mode, true))
		return false;

	bpp = adjusted_mode->private_flags & INTEL_MODE_DP_FORCE_6BPC ? 18 : 24;
	mode_rate = intel_dp_link_required(adjusted_mode->clock, bpp);
d879 23
a901 18
	for (clock = 0; clock <= max_clock; clock++) {
		for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
			int link_bw_clock =
				drm_dp_bw_code_to_link_rate(bws[clock]);
			int link_avail = intel_dp_max_data_rate(link_bw_clock,
								lane_count);

			if (mode_rate <= link_avail) {
				intel_dp->link_bw = bws[clock];
				intel_dp->lane_count = lane_count;
				adjusted_mode->clock = link_bw_clock;
				DRM_DEBUG_KMS("DP link bw %02x lane "
						"count %d clock %d bpp %d\n",
				       intel_dp->link_bw, intel_dp->lane_count,
				       adjusted_mode->clock, bpp);
				DRM_DEBUG_KMS("DP link bw required %i available %i\n",
					      mode_rate, link_avail);
				return true;
d907 36
d945 11
a955 7
struct intel_dp_m_n {
	uint32_t	tu;
	uint32_t	gmch_m;
	uint32_t	gmch_n;
	uint32_t	link_m;
	uint32_t	link_n;
};
d957 10
a966 6
static void
intel_reduce_ratio(uint32_t *num, uint32_t *den)
{
	while (*num > 0xffffff || *den > 0xffffff) {
		*num >>= 1;
		*den >>= 1;
a967 1
}
d969 4
a972 14
static void
intel_dp_compute_m_n(int bpp,
		     int nlanes,
		     int pixel_clock,
		     int link_clock,
		     struct intel_dp_m_n *m_n)
{
	m_n->tu = 64;
	m_n->gmch_m = (pixel_clock * bpp) >> 3;
	m_n->gmch_n = link_clock * nlanes;
	intel_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);
	m_n->link_m = pixel_clock;
	m_n->link_n = link_clock;
	intel_reduce_ratio(&m_n->link_m, &m_n->link_n);
d975 1
a975 3
void
intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,
		 struct drm_display_mode *adjusted_mode)
d977 1
a977 3
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;
	struct intel_dp *intel_dp;
d979 4
a982 6
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int lane_count = 4;
	struct intel_dp_m_n m_n;
	int pipe = intel_crtc->pipe;
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
	int target_clock;
d985 2
a986 83
	 * Find the lane count in the intel_encoder private
	 */
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		intel_dp = enc_to_intel_dp(&intel_encoder->base);

		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
		    intel_encoder->type == INTEL_OUTPUT_EDP)
		{
			lane_count = intel_dp->lane_count;
			break;
		}
	}

	target_clock = mode->clock;
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		if (intel_encoder->type == INTEL_OUTPUT_EDP) {
			target_clock = intel_edp_target_clock(intel_encoder,
							      mode);
			break;
		}
	}

	/*
	 * Compute the GMCH and Link ratios. The '3' here is
	 * the number of bytes_per_pixel post-LUT, which we always
	 * set up for 8-bits of R/G/B, or 3 bytes total.
	 */
	intel_dp_compute_m_n(intel_crtc->bpp, lane_count,
			     target_clock, adjusted_mode->clock, &m_n);

	if (IS_HASWELL(dev)) {
		I915_WRITE(PIPE_DATA_M1(cpu_transcoder),
			   TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_DATA_N1(cpu_transcoder), m_n.gmch_n);
		I915_WRITE(PIPE_LINK_M1(cpu_transcoder), m_n.link_m);
		I915_WRITE(PIPE_LINK_N1(cpu_transcoder), m_n.link_n);
	} else if (HAS_PCH_SPLIT(dev)) {
		I915_WRITE(TRANSDATA_M1(pipe), TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(TRANSDATA_N1(pipe), m_n.gmch_n);
		I915_WRITE(TRANSDPLINK_M1(pipe), m_n.link_m);
		I915_WRITE(TRANSDPLINK_N1(pipe), m_n.link_n);
	} else if (IS_VALLEYVIEW(dev)) {
		I915_WRITE(PIPE_DATA_M1(pipe), TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_DATA_N1(pipe), m_n.gmch_n);
		I915_WRITE(PIPE_LINK_M1(pipe), m_n.link_m);
		I915_WRITE(PIPE_LINK_N1(pipe), m_n.link_n);
	} else {
		I915_WRITE(PIPE_GMCH_DATA_M(pipe),
			   TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_GMCH_DATA_N(pipe), m_n.gmch_n);
		I915_WRITE(PIPE_DP_LINK_M(pipe), m_n.link_m);
		I915_WRITE(PIPE_DP_LINK_N(pipe), m_n.link_n);
	}
}

void intel_dp_init_link_config(struct intel_dp *intel_dp)
{
	memset(intel_dp->link_configuration, 0, DP_LINK_CONFIGURATION_SIZE);
	intel_dp->link_configuration[0] = intel_dp->link_bw;
	intel_dp->link_configuration[1] = intel_dp->lane_count;
	intel_dp->link_configuration[8] = DP_SET_ANSI_8B10B;
	/*
	 * Check for DPCD version > 1.1 and enhanced framing support
	 */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    (intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP)) {
		intel_dp->link_configuration[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
	}
}

static void
intel_dp_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,
		  struct drm_display_mode *adjusted_mode)
{
	struct drm_device *dev = encoder->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
	struct drm_crtc *crtc = encoder->crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	/*
	 * There are four kinds of DP registers:
	 *
d1008 1
a1009 11
	switch (intel_dp->lane_count) {
	case 1:
		intel_dp->DP |= DP_PORT_WIDTH_1;
		break;
	case 2:
		intel_dp->DP |= DP_PORT_WIDTH_2;
		break;
	case 4:
		intel_dp->DP |= DP_PORT_WIDTH_4;
		break;
	}
d1012 1
a1012 1
				 pipe_name(intel_crtc->pipe));
d1014 1
a1014 1
		intel_write_eld(encoder, adjusted_mode);
a1016 2
	intel_dp_init_link_config(intel_dp);

d1019 1
a1019 1
	if (is_cpu_edp(intel_dp) && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
d1026 1
a1026 1
		if (intel_dp->link_configuration[1] & DP_LANE_COUNT_ENHANCED_FRAME_EN)
d1029 4
a1032 9
		intel_dp->DP |= intel_crtc->pipe << 29;

		/* don't miss out required setting for eDP */
		if (adjusted_mode->clock < 200000)
			intel_dp->DP |= DP_PLL_FREQ_160MHZ;
		else
			intel_dp->DP |= DP_PLL_FREQ_270MHZ;
	} else if (!HAS_PCH_CPT(dev) || is_cpu_edp(intel_dp)) {
		intel_dp->DP |= intel_dp->color_range;
d1040 1
a1040 1
		if (intel_dp->link_configuration[1] & DP_LANE_COUNT_ENHANCED_FRAME_EN)
d1043 1
a1043 1
		if (intel_crtc->pipe == 1)
a1044 8

		if (is_cpu_edp(intel_dp)) {
			/* don't miss out required setting for eDP */
			if (adjusted_mode->clock < 200000)
				intel_dp->DP |= DP_PLL_FREQ_160MHZ;
			else
				intel_dp->DP |= DP_PLL_FREQ_270MHZ;
		}
d1048 3
d1068 4
d1074 3
a1076 3
		      mask, value,
		      I915_READ(PCH_PP_STATUS),
		      I915_READ(PCH_PP_CONTROL));
d1078 1
a1078 1
	if (_wait_for((I915_READ(PCH_PP_STATUS) & mask) == value, 5000, 10)) {
d1080 2
a1081 2
			  I915_READ(PCH_PP_STATUS),
			  I915_READ(PCH_PP_CONTROL));
d1083 2
d1110 1
a1110 1
static  u32 ironlake_get_pp_control(struct drm_i915_private *dev_priv)
d1112 3
a1114 1
	u32	control = I915_READ(PCH_PP_CONTROL);
d1116 1
d1127 1
a1130 1
	DRM_DEBUG_KMS("Turn eDP VDD on\n");
d1137 1
a1137 2
	if (ironlake_edp_have_panel_vdd(intel_dp)) {
		DRM_DEBUG_KMS("eDP VDD already on\n");
d1139 4
a1142 1
	}
d1147 1
a1147 1
	pp = ironlake_get_pp_control(dev_priv);
a1148 4
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
	DRM_DEBUG_KMS("PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n",
		      I915_READ(PCH_PP_STATUS), I915_READ(PCH_PP_CONTROL));
d1150 7
d1162 1
a1162 1
		drm_msleep(intel_dp->panel_power_up_delay, "915edpon");
d1171 3
d1176 3
a1178 1
		pp = ironlake_get_pp_control(dev_priv);
d1180 6
a1185 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1188 5
a1192 2
		DRM_DEBUG_KMS("PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n",
			      I915_READ(PCH_PP_STATUS), I915_READ(PCH_PP_CONTROL));
d1194 1
a1194 1
		drm_msleep(intel_dp->panel_power_down_delay, "915vddo");
a1213 1
	DRM_DEBUG_KMS("Turn eDP VDD off %d\n", intel_dp->want_panel_vdd);
d1236 1
d1250 2
a1251 1
	pp = ironlake_get_pp_control(dev_priv);
d1255 2
a1256 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1263 2
a1264 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1270 2
a1271 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1280 1
d1289 1
a1289 1
	pp = ironlake_get_pp_control(dev_priv);
d1293 5
a1297 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1302 3
a1311 1
	int pipe = to_intel_crtc(intel_dig_port->base.base.crtc)->pipe;
d1313 1
d1325 2
a1326 2
	drm_msleep(intel_dp->backlight_on_delay, "915ebo");
	pp = ironlake_get_pp_control(dev_priv);
a1327 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1329 6
a1334 1
	intel_panel_enable_backlight(dev, pipe);
d1342 1
d1347 1
a1347 1
	intel_panel_disable_backlight(dev);
d1350 1
a1350 1
	pp = ironlake_get_pp_control(dev_priv);
d1352 6
a1357 3
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
	drm_msleep(intel_dp->backlight_off_delay, "915bo1");
d1436 1
a1436 1
			drm_msleep(1, "915dps");
d1445 1
d1453 1
a1453 1
	if (is_cpu_edp(intel_dp) && IS_GEN7(dev)) {
d1455 1
a1455 1
	} else if (!HAS_PCH_CPT(dev) || is_cpu_edp(intel_dp)) {
d1491 330
d1824 2
d1831 1
a1831 1
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
d1835 1
a1835 1
	if (!is_cpu_edp(intel_dp))
d1842 2
d1845 1
a1845 1
	if (is_cpu_edp(intel_dp)) {
d1847 2
a1848 1
		ironlake_edp_pll_off(intel_dp);
d1868 15
d1886 1
a1886 1
static void intel_pre_enable_dp(struct intel_encoder *encoder)
d1889 1
d1891 1
a1891 1
	if (is_cpu_edp(intel_dp))
d1895 67
d1981 1
a1981 1
		drm_msleep(1, "915dpl");
a1999 12
#if 0
static char	*voltage_names[] = {
	"0.4V", "0.6V", "0.8V", "1.2V"
};
static char	*pre_emph_names[] = {
	"0dB", "3.5dB", "6dB", "9.5dB"
};
static char	*link_train_names[] = {
	"pattern 1", "pattern 2", "idle", "off"
};
#endif

d2009 1
d2011 3
a2013 1
	if (IS_GEN7(dev) && is_cpu_edp(intel_dp))
d2015 1
a2015 1
	else if (HAS_PCH_CPT(dev) && !is_cpu_edp(intel_dp))
d2025 1
d2027 24
a2050 1
	if (IS_HASWELL(dev)) {
d2062 1
a2062 1
	} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
d2087 100
d2188 2
a2189 1
intel_get_adjust_train(struct intel_dp *intel_dp, uint8_t link_status[DP_LINK_STATUS_SIZE])
d2220 1
a2220 1
intel_dp_signal_levels(uint8_t train_set)
d2318 1
a2318 1
intel_dp_signal_levels_hsw(uint8_t train_set)
d2350 70
d2422 1
a2422 1
			uint32_t dp_reg_value,
d2429 2
a2430 2
	int ret;
	uint32_t temp;
d2432 2
a2433 2
	if (IS_HASWELL(dev)) {
		temp = I915_READ(DP_TP_CTL(port));
a2442 8
			temp |= DP_TP_CTL_LINK_TRAIN_IDLE;
			I915_WRITE(DP_TP_CTL(port), temp);

			if (wait_for((I915_READ(DP_TP_STATUS(port)) &
				      DP_TP_STATUS_IDLE_DONE), 1))
				DRM_ERROR("Timed out waiting for DP idle patterns\n");

			temp &= ~DP_TP_CTL_LINK_TRAIN_MASK;
d2458 21
a2478 3
	} else if (HAS_PCH_CPT(dev) &&
		   (IS_GEN7(dev) || !is_cpu_edp(intel_dp))) {
		dp_reg_value &= ~DP_LINK_TRAIN_MASK_CPT;
d2482 1
a2482 1
			dp_reg_value |= DP_LINK_TRAIN_OFF_CPT;
d2485 1
a2485 1
			dp_reg_value |= DP_LINK_TRAIN_PAT_1_CPT;
d2487 57
a2543 8
		case DP_TRAINING_PATTERN_2:
			dp_reg_value |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			dp_reg_value |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		}
d2545 2
a2546 2
	} else {
		dp_reg_value &= ~DP_LINK_TRAIN_MASK;
d2548 7
a2554 16
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			dp_reg_value |= DP_LINK_TRAIN_OFF;
			break;
		case DP_TRAINING_PATTERN_1:
			dp_reg_value |= DP_LINK_TRAIN_PAT_1;
			break;
		case DP_TRAINING_PATTERN_2:
			dp_reg_value |= DP_LINK_TRAIN_PAT_2;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			dp_reg_value |= DP_LINK_TRAIN_PAT_2;
			break;
		}
	}
d2556 2
a2557 2
	I915_WRITE(intel_dp->output_reg, dp_reg_value);
	POSTING_READ(intel_dp->output_reg);
d2559 4
a2562 3
	intel_dp_aux_native_write_1(intel_dp,
				    DP_TRAINING_PATTERN_SET,
				    dp_train_pat);
d2564 9
a2572 9
	if ((dp_train_pat & DP_TRAINING_PATTERN_MASK) !=
	    DP_TRAINING_PATTERN_DISABLE) {
		ret = intel_dp_aux_native_write(intel_dp,
						DP_TRAINING_LANE0_SET,
						intel_dp->train_set,
						intel_dp->lane_count);
		if (ret != intel_dp->lane_count)
			return false;
	}
d2574 3
a2576 1
	return true;
a2586 1
	bool clock_recovery = false;
d2589 1
d2595 9
a2603 3
	intel_dp_aux_native_write(intel_dp, DP_LINK_BW_SET,
				  intel_dp->link_configuration,
				  DP_LINK_CONFIGURATION_SIZE);
d2607 8
a2614 1
	memset(intel_dp->train_set, 0, 4);
a2617 1
	clock_recovery = false;
d2619 1
a2619 26
		/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
		uint8_t	    link_status[DP_LINK_STATUS_SIZE];
		uint32_t    signal_levels;

		if (IS_HASWELL(dev)) {
			signal_levels = intel_dp_signal_levels_hsw(
							intel_dp->train_set[0]);
			DP = (DP & ~DDI_BUF_EMP_MASK) | signal_levels;
		} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
			signal_levels = intel_gen7_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB) | signal_levels;
		} else if (IS_GEN6(dev) && is_cpu_edp(intel_dp)) {
			signal_levels = intel_gen6_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB) | signal_levels;
		} else {
			signal_levels = intel_dp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~(DP_VOLTAGE_MASK|DP_PRE_EMPHASIS_MASK)) | signal_levels;
		}
		DRM_DEBUG_KMS("training pattern 1 signal levels %08x\n",
			      signal_levels);

		/* Set training pattern 1 */
		if (!intel_dp_set_link_train(intel_dp, DP,
					     DP_TRAINING_PATTERN_1 |
					     DP_LINK_SCRAMBLING_DISABLE))
			break;
a2628 1
			clock_recovery = true;
d2639 1
a2639 1
				DRM_DEBUG_KMS("too many full retries, give up\n");
d2642 3
a2644 1
			memset(intel_dp->train_set, 0, 4);
d2653 1
a2653 1
				DRM_DEBUG_KMS("too many voltage retries, give up\n");
d2660 5
a2664 2
		/* Compute new intel_dp->train_set as requested by target */
		intel_get_adjust_train(intel_dp, link_status);
a2672 1
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
d2678 7
d2689 1
a2689 3
		/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
		uint32_t    signal_levels;
		uint8_t	    link_status[DP_LINK_STATUS_SIZE];
a2692 1
			intel_dp_link_down(intel_dp);
a2695 20
		if (IS_HASWELL(dev)) {
			signal_levels = intel_dp_signal_levels_hsw(intel_dp->train_set[0]);
			DP = (DP & ~DDI_BUF_EMP_MASK) | signal_levels;
		} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
			signal_levels = intel_gen7_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB) | signal_levels;
		} else if (IS_GEN6(dev) && is_cpu_edp(intel_dp)) {
			signal_levels = intel_gen6_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB) | signal_levels;
		} else {
			signal_levels = intel_dp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~(DP_VOLTAGE_MASK|DP_PRE_EMPHASIS_MASK)) | signal_levels;
		}

		/* channel eq pattern */
		if (!intel_dp_set_link_train(intel_dp, DP,
					     DP_TRAINING_PATTERN_2 |
					     DP_LINK_SCRAMBLING_DISABLE))
			break;

d2697 2
a2698 1
		if (!intel_dp_get_link_status(intel_dp, link_status))
d2700 1
d2705 3
d2721 3
d2729 5
a2733 2
		/* Compute new intel_dp->train_set as requested by target */
		intel_get_adjust_train(intel_dp, link_status);
d2737 4
d2742 1
a2742 1
		DRM_DEBUG_KMS("Channel EQ done. DP Training successfull\n");
d2744 6
a2749 1
	intel_dp_set_link_train(intel_dp, DP, DP_TRAINING_PATTERN_DISABLE);
d2756 1
d2759 2
d2786 1
a2786 1
	if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || !is_cpu_edp(intel_dp))) {
d2795 2
a2796 1
	drm_msleep(17, "915dlo");
d2816 4
a2819 9
		if (crtc == NULL) {
			/* We can arrive here never having been attached
			 * to a CRTC, for instance, due to inheriting
			 * random state from the BIOS.
			 *
			 * If the pipe is not running, play safe and
			 * wait for the clocks to stabilise before
			 * continuing.
			 */
d2821 1
a2821 1
			drm_msleep(50, "915dla");
d2823 1
a2823 1
			intel_wait_for_vblank(dev, to_intel_crtc(crtc)->pipe);
d2829 1
a2829 1
	drm_msleep(intel_dp->panel_power_down_delay, "915ldo");
d2835 8
d2847 6
d2856 12
a2948 1
		intel_dp_link_down(intel_dp);
a2953 1
		intel_dp_link_down(intel_dp);
d2976 1
a2984 1
	bool hpd;
d2995 2
a2996 2
	hpd = !!(intel_dp->downstream_ports[0] & DP_DS_PORT_HPD);
	if (hpd) {
d3010 12
a3021 3
	type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
	if (type == DP_DS_PORT_TYPE_VGA || type == DP_DS_PORT_TYPE_NON_EDID)
		return connector_status_unknown;
d3032 2
d3044 3
d3055 1
d3058 10
d3069 3
a3071 3
		switch (intel_dp->output_reg) {
		case DP_B:
			bit = DPB_HOTPLUG_LIVE_STATUS_VLV;
d3073 2
a3074 2
		case DP_C:
			bit = DPC_HOTPLUG_LIVE_STATUS_VLV;
d3076 2
a3077 2
		case DP_D:
			bit = DPD_HOTPLUG_LIVE_STATUS_VLV;
d3083 3
a3085 3
		switch (intel_dp->output_reg) {
		case DP_B:
			bit = DPB_HOTPLUG_LIVE_STATUS_G4X;
d3087 2
a3088 2
		case DP_C:
			bit = DPC_HOTPLUG_LIVE_STATUS_G4X;
d3090 2
a3091 2
		case DP_D:
			bit = DPD_HOTPLUG_LIVE_STATUS_G4X;
d3105 1
a3105 1
intel_dp_get_edid(struct drm_connector *connector, struct i2c_controller *adapter)
a3110 3
		struct edid *edid;
		int size;

d3115 1
a3115 7
		size = (intel_connector->edid->extensions + 1) * EDID_LENGTH;
		edid = kmalloc(size, GFP_KERNEL);
		if (!edid)
			return NULL;

		memcpy(edid, intel_connector->edid, size);
		return edid;
d3122 1
a3122 1
intel_dp_get_edid_modes(struct drm_connector *connector, struct i2c_controller *adapter)
a3138 7

/**
 * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect DP connection.
 *
 * \return true if DP port is connected.
 * \return false if DP port is disconnected.
 */
d3146 1
d3149 5
a3153 3
#ifdef notyet
	char dpcd_hex_dump[sizeof(intel_dp->dpcd) * 3];
#endif
a3161 6
#ifdef notyet
	hex_dump_to_buffer(intel_dp->dpcd, sizeof(intel_dp->dpcd),
			   32, 1, dpcd_hex_dump, sizeof(dpcd_hex_dump), false);
	DRM_DEBUG_KMS("DPCD: %s\n", dpcd_hex_dump);
#endif

d3163 1
a3163 1
		return status;
d3179 5
a3183 1
	return connector_status_connected;
d3266 21
a3286 1
		if (val == !!intel_dp->color_range)
a3288 1
		intel_dp->color_range = val ? DP_COLOR_RANGE_16_235 : 0;
d3311 2
a3312 5
	if (intel_encoder->base.crtc) {
		struct drm_crtc *crtc = intel_encoder->base.crtc;
		intel_set_mode(crtc, &crtc->mode,
			       crtc->x, crtc->y, crtc->fb);
	}
d3318 1
a3318 1
intel_dp_destroy(struct drm_connector *connector)
a3319 1
	struct intel_dp *intel_dp = intel_attached_dp(connector);
d3325 3
a3327 1
	if (is_edp(intel_dp))
a3329 1
	drm_sysfs_connector_remove(connector);
d3338 1
d3346 1
d3348 1
a3352 6
static const struct drm_encoder_helper_funcs intel_dp_helper_funcs = {
	.mode_fixup = intel_dp_mode_fixup,
	.mode_set = intel_dp_mode_set,
	.disable = intel_encoder_noop,
};

d3358 1
a3358 1
	.destroy = intel_dp_destroy,
d3399 1
a3399 1
bool intel_dpd_is_edp(struct drm_device *dev)
d3402 1
a3402 1
	struct child_device_config *p_child;
d3404 5
d3410 4
a3413 1
	if (!dev_priv->child_dev_num)
d3416 2
a3417 2
	for (i = 0; i < dev_priv->child_dev_num; i++) {
		p_child = dev_priv->child_dev + i;
d3419 3
a3421 2
		if (p_child->dvo_port == PORT_IDPD &&
		    p_child->device_type == DEVICE_TYPE_eDP)
d3434 1
d3454 15
d3472 2
a3473 2
	pp = ironlake_get_pp_control(dev_priv);
	I915_WRITE(PCH_PP_CONTROL, pp);
d3475 3
a3477 3
	pp_on = I915_READ(PCH_PP_ON_DELAYS);
	pp_off = I915_READ(PCH_PP_OFF_DELAYS);
	pp_div = I915_READ(PCH_PP_DIVISOR);
d3498 1
a3498 1
	vbt = dev_priv->edp.pps;
d3552 15
a3566 1
	u32 pp_on, pp_off, pp_div;
d3575 1
a3575 2
	pp_div = ((100 * intel_pch_rawclk(dev))/2 - 1)
			<< PP_REFERENCE_DIVIDER_SHIFT;
d3581 3
a3583 3
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		if (is_cpu_edp(intel_dp))
			pp_on |= PANEL_POWER_PORT_DP_A;
d3585 6
a3590 1
			pp_on |= PANEL_POWER_PORT_DP_D;
d3593 5
a3597 3
	I915_WRITE(PCH_PP_ON_DELAYS, pp_on);
	I915_WRITE(PCH_PP_OFF_DELAYS, pp_off);
	I915_WRITE(PCH_PP_DIVISOR, pp_div);
d3600 78
a3677 3
		      I915_READ(PCH_PP_ON_DELAYS),
		      I915_READ(PCH_PP_OFF_DELAYS),
		      I915_READ(PCH_PP_DIVISOR));
d3680 1
a3680 1
void
a3688 2
	struct drm_display_mode *fixed_mode = NULL;
	struct edp_power_seq power_seq = { 0 };
d3691 1
a3691 1
	int type;
d3697 4
a3700 3
	if (HAS_PCH_SPLIT(dev) && port == PORT_D)
		if (intel_dpd_is_edp(dev))
			intel_dp->is_pch_edp = true;
d3703 3
a3705 2
	 * FIXME : We need to initialize built-in panels before external panels.
	 * For X0, DP_C is fixed as eDP. Revisit this as part of VLV eDP cleanup
d3707 1
a3707 2
	if (IS_VALLEYVIEW(dev) && port == PORT_C) {
		type = DRM_MODE_CONNECTOR_eDP;
d3709 4
a3712 10
	} else if (port == PORT_A || is_pch_edp(intel_dp)) {
		type = DRM_MODE_CONNECTOR_eDP;
		intel_encoder->type = INTEL_OUTPUT_EDP;
	} else {
		/* The intel_encoder->type value may be INTEL_OUTPUT_UNKNOWN for
		 * DDI or INTEL_OUTPUT_DISPLAYPORT for the older gens, so don't
		 * rewrite it.
		 */
		type = DRM_MODE_CONNECTOR_DisplayPort;
	}
a3716 1
	connector->polled = DRM_CONNECTOR_POLL_HPD;
d3730 1
d3732 19
d3755 1
d3759 1
a3759 1
		dev_priv->hotplug_supported_mask |= DPB_HOTPLUG_INT_STATUS;
d3763 1
a3763 1
		dev_priv->hotplug_supported_mask |= DPC_HOTPLUG_INT_STATUS;
d3767 1
a3767 1
		dev_priv->hotplug_supported_mask |= DPD_HOTPLUG_INT_STATUS;
d3771 1
a3771 2
		WARN(1, "Invalid port %c\n", port_name(port));
		break;
d3774 3
a3776 2
	if (is_edp(intel_dp))
		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
d3778 1
a3778 1
	intel_dp_i2c_init(intel_dp, intel_connector, name);
d3780 9
a3788 21
	/* Cache DPCD and EDID for edp. */
	if (is_edp(intel_dp)) {
		bool ret;
		struct drm_display_mode *scan;
		struct edid *edid;

		ironlake_edp_panel_vdd_on(intel_dp);
		ret = intel_dp_get_dpcd(intel_dp);
		ironlake_edp_panel_vdd_off(intel_dp, false);

		if (ret) {
			if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11)
				dev_priv->no_aux_handshake =
					intel_dp->dpcd[DP_MAX_DOWNSPREAD] &
					DP_NO_AUX_HANDSHAKE_LINK_TRAINING;
		} else {
			/* if this fails, presume the device is a ghost */
			DRM_INFO("failed to retrieve link info, disabling eDP\n");
			intel_dp_encoder_destroy(&intel_encoder->base);
			intel_dp_destroy(connector);
			return;
d3790 3
a3792 41

		/* We now know it's not a ghost, init power sequence regs. */
		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
							      &power_seq);

		ironlake_edp_panel_vdd_on(intel_dp);
		edid = drm_get_edid(connector, &intel_dp->adapter);
		if (edid) {
			if (drm_add_edid_modes(connector, edid)) {
				drm_mode_connector_update_edid_property(connector, edid);
				drm_edid_to_eld(connector, edid);
			} else {
				kfree(edid);
				edid = ERR_PTR(-EINVAL);
			}
		} else {
			edid = ERR_PTR(-ENOENT);
		}
		intel_connector->edid = edid;

		/* prefer fixed mode from EDID if available */
		list_for_each_entry(scan, &connector->probed_modes, head) {
			if ((scan->type & DRM_MODE_TYPE_PREFERRED)) {
				fixed_mode = drm_mode_duplicate(dev, scan);
				break;
			}
		}

		/* fallback to VBT if available for eDP */
		if (!fixed_mode && dev_priv->lfp_lvds_vbt_mode) {
			fixed_mode = drm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);
			if (fixed_mode)
				fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
		}

		ironlake_edp_panel_vdd_off(intel_dp, false);
	}

	if (is_edp(intel_dp)) {
		intel_panel_init(&intel_connector->panel, fixed_mode);
		intel_panel_setup_backlight(connector);
d3805 2
d3817 1
a3817 1
	intel_dig_port = kzalloc(sizeof(struct intel_digital_port), GFP_KERNEL);
d3821 1
a3821 1
	intel_connector = kzalloc(sizeof(struct intel_connector), GFP_KERNEL);
a3831 1
	drm_encoder_helper_add(&intel_encoder->base, &intel_dp_helper_funcs);
d3833 2
a3834 2
	intel_encoder->enable = intel_enable_dp;
	intel_encoder->pre_enable = intel_pre_enable_dp;
d3838 9
d3856 5
a3860 1
	intel_dp_init_connector(intel_dig_port, intel_connector);
@


1.24
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.23 2015/04/06 10:56:37 jsg Exp $	*/
d1107 1
a1107 1
static void ironlake_panel_vdd_work(void *arg1)
d1109 2
a1110 1
	struct intel_dp *intel_dp = arg1;
a1117 8
static void
ironlake_panel_vdd_tick(void *arg)
{
	struct intel_dp *intel_dp = arg;

	task_add(systq, &intel_dp->panel_vdd_task);
}

d1136 2
a1137 1
		timeout_add_msec(&intel_dp->panel_vdd_to, intel_dp->panel_power_cycle_delay * 5);
d2537 1
a2537 2
		timeout_del(&intel_dp->panel_vdd_to);
		task_del(systq, &intel_dp->panel_vdd_task);
d2804 2
a2805 2
	task_set(&intel_dp->panel_vdd_task, ironlake_panel_vdd_work, intel_dp);
	timeout_set(&intel_dp->panel_vdd_to, ironlake_panel_vdd_tick, intel_dp);
@


1.23
log
@add/use some more errno remapping
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.22 2015/02/10 03:39:41 jsg Exp $	*/
a1002 1
	int retries;
d1009 1
a1009 6
	for (retries = 5000; retries > 0; retries--) {
		if ((I915_READ(PCH_PP_STATUS) & mask) == value)
			break;
		DELAY(1000);
	}
	if (retries == 0)
d1013 1
a1725 1
	int retries;
d1741 2
a1742 7
			for (retries = 100; retries > 0; retries--) {
				if (I915_READ(DP_TP_STATUS(port)) &
				    DP_TP_STATUS_IDLE_DONE)
					break;
				DELAY(100);
			}
			if (retries == 0)
@


1.22
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.21 2015/01/27 03:17:36 dlg Exp $	*/
d552 1
a552 1
			return -EIO;
d634 1
a634 1
			return -EIO;
d652 1
a652 1
			return -EIO;
d663 1
a663 1
			return -EIO;
d670 1
a670 1
			return -EIO;
d675 1
a675 1
	return -EIO;
@


1.21
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.20 2014/06/19 06:51:05 jsg Exp $	*/
d1117 1
a1117 1
	rw_enter_write(&dev->mode_config.rwl);
d1119 1
a1119 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.20
log
@drm/i915: fix lane bandwidth capping for DP 1.2 sinks

DP 1.2 compatible displays may report a 5.4Gbps maximum bandwidth which
the driver will treat as an invalid value and use 1.62Gbps instead. Fix
this by capping to 2.7Gbps for sinks reporting a 5.4Gbps max bw.

Also add a warning for reserved values.

From Imre Deak
d4eead50eb206b875f54f66cc0f6ec7d54122c28 in mainline linux

One of two backported commits to prevent a black screen
on a Lenovo IdeaPad Yoga 2 Pro as reported/debugged by Steven Wilson.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.19 2014/06/19 06:44:00 jsg Exp $	*/
d1112 1
a1112 1
static void ironlake_panel_vdd_work(void *arg1, void *arg2)
d2822 1
a2822 2
	task_set(&intel_dp->panel_vdd_task, ironlake_panel_vdd_work, intel_dp,
	    NULL);
@


1.19
log
@drm/i915: kill intel_dp_link_clock()

Use drm_dp_bw_code_to_link_rate insead. It's the same thing, but
supports DP_LINK_BW_5_4 and is also used by the other drivers.

From Paulo Zanoni
9fa5f6522e6eecb5ab20192a264a29ba4f2f4e85 in mainline linux

One of two backported commits to prevent a black screen
on a Lenovo IdeaPad Yoga 2 Pro as reported/debugged by Steven Wilson.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.18 2014/03/30 01:10:36 jsg Exp $	*/
d142 3
d146 2
@


1.18
log
@drm/i915/dp: add native aux defer retry limit

From Jani Nikula
b4cdadf2591e12c61f895556cf93a8b61a36892c in ubuntu 3.8
f51a44b9a6c4982cc25bfb3727de9bb893621ebc in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.17 2014/03/30 01:06:31 jsg Exp $	*/
a148 9
static int
intel_dp_link_clock(uint8_t link_bw)
{
	if (link_bw == DP_LINK_BW_2_7)
		return 270000;
	else
		return 162000;
}

d183 2
a184 1
	int max_link_clock = intel_dp_link_clock(intel_dp_max_link_bw(intel_dp));
d740 4
a743 1
			int link_avail = intel_dp_max_data_rate(intel_dp_link_clock(bws[clock]), lane_count);
d748 1
a748 1
				adjusted_mode->clock = intel_dp_link_clock(intel_dp->link_bw);
@


1.17
log
@drm/i915/dp: increase native aux defer retry timeout

From Jani Nikula
6048560066737a87621b9169ef4bdab0e3cef620 in ubuntu 3.8
04eada25d1f72efdecd32d702706594f81de65d5 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.16 2014/02/18 02:48:57 jsg Exp $	*/
d494 1
d505 1
a505 1
	for (;;) {
d510 1
a510 1
			break;
d516 3
a518 1
	return send_bytes;
d540 1
d551 1
a551 1
	for (;;) {
d568 3
@


1.16
log
@drm/i915: VLV2 - Fix hotplug detect bits

From Todd Previte
080caf7f5b0d025c2e19f2f516da634d020ba70f in ubuntu 3.8
232a6ee9af8adb185640f67fcaaa9014a9aa0573 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.15 2014/02/02 01:06:21 jsg Exp $	*/
d511 1
a511 1
			udelay(100);
d560 1
a560 1
			udelay(100);
@


1.15
log
@drm/i915/dp: increase i2c-over-aux retry interval on AUX DEFER

From Jani Nikula
67c729e64ef03476312fc9fb815046d5e540428a in ubuntu 3.8
8d16f258217f2f583af1fd57c5144aa4bbe73e48 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.14 2014/01/23 10:42:57 jsg Exp $	*/
d2272 28
a2299 12
	switch (intel_dp->output_reg) {
	case DP_B:
		bit = DPB_HOTPLUG_LIVE_STATUS;
		break;
	case DP_C:
		bit = DPC_HOTPLUG_LIVE_STATUS;
		break;
	case DP_D:
		bit = DPD_HOTPLUG_LIVE_STATUS;
		break;
	default:
		return connector_status_unknown;
@


1.14
log
@drm/i915: add HAS_DDI check

From Paulo Zanoni
d99994528e9946a78a505ca752fa3b73aa8c5a76 in ubuntu 3.8
affa935440733a79c5a9eb0e5357e2564ca4b355 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.13 2014/01/22 05:16:55 kettenis Exp $	*/
d632 12
a643 1
			udelay(100);
@


1.13
log
@Provide inline dummy implementations of drm_sysfs_connector_add() and
drm_sysfs_connector_remove() and call those instead of #ifdef'ing them out.
Reduces the noise when diffing against Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.12 2014/01/22 04:04:53 kettenis Exp $	*/
d382 1
a382 1
		if (IS_HASWELL(dev))
d1826 1
a1826 1
	if (IS_HASWELL(dev))
d2016 1
a2016 1
	if (IS_HASWELL(dev))
d2795 1
a2795 1
	if (IS_HASWELL(dev))
@


1.12
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.11 2014/01/21 08:57:22 kettenis Exp $	*/
a2504 1
#ifdef notyet
a2505 1
#endif
a2792 1
#ifdef notyet
a2793 1
#endif
@


1.11
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.10 2013/10/30 02:11:33 dlg Exp $	*/
d391 1
a391 1
		aux_clock_divider = howmany(intel_pch_rawclk(dev), 2);
d2684 1
a2684 1
#define get_delay(field)	(howmany(final.field, 10))
d2720 1
a2720 1
	pp_div |= (howmany(seq->t11_t12, 1000)
@


1.10
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.9 2013/10/29 06:30:57 jsg Exp $	*/
d2296 1
a2296 1
		edid = malloc(size, M_DRM, M_WAITOK);
d2369 1
a2369 1
			free(edid, M_DRM);
d2415 1
a2415 1
		free(edid, M_DRM);
d2500 1
a2500 1
		free(intel_connector->edid, M_DRM);
d2509 1
a2509 1
	free(connector, M_DRM);
d2526 1
a2526 1
	free(intel_dig_port, M_DRM);
d2866 1
a2866 1
				free(edid, M_DRM);
d2917 1
a2917 2
	intel_dig_port = malloc(sizeof(struct intel_digital_port), M_DRM,
	    M_WAITOK | M_ZERO);
d2921 1
a2921 2
	intel_connector = malloc(sizeof(struct intel_connector), M_DRM,
	    M_WAITOK | M_ZERO);
d2923 1
a2923 1
		free(intel_dig_port, M_DRM);
@


1.9
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.8 2013/08/13 10:23:51 jsg Exp $	*/
d1109 1
a1109 1
	task_add(taskq_systq(), &intel_dp->panel_vdd_task);
d2523 1
a2523 1
		task_del(taskq_systq(), &intel_dp->panel_vdd_task);
@


1.8
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.7 2013/07/08 09:47:45 jsg Exp $	*/
d1109 1
a1109 2
	workq_queue_task(NULL, &intel_dp->panel_vdd_task, 0,
	    ironlake_panel_vdd_work, intel_dp, NULL);
d2523 1
d2790 2
@


1.7
log
@make use of udelay to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.6 2013/07/05 07:20:27 jsg Exp $	*/
a38 120
struct intel_dp_m_n {
	uint32_t	tu;
	uint32_t	gmch_m;
	uint32_t	gmch_n;
	uint32_t	link_m;
	uint32_t	link_n;
};

bool	 is_edp(struct intel_dp *);
bool	 is_pch_edp(struct intel_dp *);
bool	 is_cpu_edp(struct intel_dp *);
struct intel_dp	*enc_to_intel_dp(struct drm_encoder *);
struct intel_dp *intel_attached_dp(struct drm_connector *);
int	 intel_dp_max_lane_count(struct intel_dp *);
int	 intel_dp_max_link_bw(struct intel_dp *);
int	 intel_dp_link_clock(uint8_t);
int	 intel_dp_link_required(int, int);
int	 intel_dp_max_data_rate(int, int);
bool	 intel_dp_adjust_dithering(struct intel_dp *,
	     struct drm_display_mode *, bool);
int	 intel_dp_mode_valid(struct drm_connector *, struct drm_display_mode *);
uint32_t pack_aux(uint8_t *, int);
void	 unpack_aux(uint32_t, uint8_t *, int);
int	 intel_hrawclk(struct drm_device *);
bool	 ironlake_edp_have_panel_power(struct intel_dp *);
bool	 ironlake_edp_have_panel_vdd(struct intel_dp *);
void	 intel_dp_check_edp(struct intel_dp *);
int	 intel_dp_aux_ch(struct intel_dp *, uint8_t *, int, uint8_t *, int);
int	 intel_dp_aux_native_write(struct intel_dp *, uint16_t, uint8_t *,
	     int);
int	 intel_dp_aux_native_write_1(struct intel_dp *, uint16_t, uint8_t);
int	 intel_dp_aux_native_read(struct intel_dp *, uint16_t, uint8_t *, int);
int	 intel_dp_i2c_init(struct intel_dp *, struct intel_connector *,
	     const char *);
bool	 intel_dp_mode_fixup(struct drm_encoder *, const struct drm_display_mode *,
	     struct drm_display_mode *);
void	 intel_reduce_ratio(uint32_t *, uint32_t *);
void	 intel_dp_compute_m_n(int, int, int, int, struct intel_dp_m_n *);
void	 intel_dp_set_m_n(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *);
void	 intel_dp_mode_set(struct drm_encoder *, struct drm_display_mode *,
	     struct drm_display_mode *);
void	 ironlake_wait_panel_status(struct intel_dp *, u32, u32);
void	 ironlake_wait_panel_on(struct intel_dp *);
void	 ironlake_wait_panel_off(struct intel_dp *);
void	 ironlake_wait_panel_power_cycle(struct intel_dp *);
u32	 ironlake_get_pp_control(struct drm_i915_private *);
void	 ironlake_edp_panel_vdd_on(struct intel_dp *);
void	 ironlake_panel_vdd_off_sync(struct intel_dp *);
void	 ironlake_edp_panel_vdd_off(struct intel_dp *, bool);
void	 ironlake_edp_panel_on(struct intel_dp *);
void	 ironlake_edp_panel_off(struct intel_dp *);
void	 ironlake_edp_backlight_on(struct intel_dp *);
void	 ironlake_edp_backlight_off(struct intel_dp *);
void	 ironlake_edp_pll_on(struct intel_dp *);
void	 ironlake_edp_pll_off(struct intel_dp *);
void	 intel_dp_sink_dpms(struct intel_dp *, int);
void	 intel_dp_prepare(struct drm_encoder *);
void	 intel_dp_commit(struct drm_encoder *);
void	 intel_dp_start_link_train(struct intel_dp *);
void	 intel_dp_complete_link_train(struct intel_dp *);
void	 intel_dp_dpms(struct drm_encoder *, int);
bool	 intel_dp_aux_native_read_retry(struct intel_dp *, uint16_t, uint8_t *,
	     int);
bool	 intel_dp_get_link_status(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
uint8_t	 intel_dp_link_status(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
uint8_t	 intel_get_adjust_request_voltage(uint8_t adjust_request[2], int);
uint8_t	 intel_get_adjust_request_pre_emphasis(uint8_t adjust_request[2], int);
uint8_t	 intel_dp_voltage_max(struct intel_dp *);
uint8_t	 intel_dp_pre_emphasis_max(struct intel_dp *, uint8_t);
void	 intel_get_adjust_train(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
uint32_t intel_dp_signal_levels(uint8_t);
uint32_t intel_gen6_edp_signal_levels(uint8_t);
uint32_t intel_gen7_edp_signal_levels(uint8_t);
uint8_t	 intel_get_lane_status(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
bool	 intel_clock_recovery_ok(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
bool	 intel_channel_eq_ok(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
bool	 intel_dp_set_link_train(struct intel_dp *, uint32_t, uint8_t);
void	 intel_dp_start_link_train(struct intel_dp *);
void	 intel_dp_complete_link_train(struct intel_dp *);
void	 intel_dp_link_down(struct intel_dp *);
bool	 intel_dp_get_dpcd(struct intel_dp *);
bool	 intel_dp_get_sink_irq(struct intel_dp *, u8 *);
void	 intel_dp_handle_test_request(struct intel_dp *);
void	 intel_dp_check_link_status(struct intel_dp *);
enum drm_connector_status	 intel_dp_detect_dpcd(struct intel_dp *);
enum drm_connector_status	 ironlake_dp_detect(struct intel_dp *);
enum drm_connector_status	 g4x_dp_detect(struct intel_dp *);
struct edid	*intel_dp_get_edid(struct drm_connector *,
		     struct i2c_controller *);
int	 intel_dp_get_edid_modes(struct drm_connector *,
	     struct i2c_controller *);
enum drm_connector_status	 intel_dp_detect(struct drm_connector *, bool);
int	 intel_dp_get_modes(struct drm_connector *);
bool	 intel_dp_detect_audio(struct drm_connector *);
int	 intel_dp_set_property(struct drm_connector *, struct drm_property *,
	     uint64_t);
void	 intel_dp_destroy(struct drm_connector *);
void	 intel_dp_encoder_destroy(struct drm_encoder *);
void	 intel_dp_hot_plug(struct intel_encoder *);
void	 intel_dp_add_properties(struct intel_dp *, struct drm_connector *);
struct drm_device *intel_dp_to_dev(struct intel_dp *);
bool	 intel_dp_get_hw_state(struct intel_encoder *, enum pipe *);
void	 intel_disable_dp(struct intel_encoder *);
void	 intel_post_disable_dp(struct intel_encoder *);
void	 intel_enable_dp(struct intel_encoder *);
void	 intel_pre_enable_dp(struct intel_encoder *);
uint32_t intel_dp_signal_levels_hsw(uint8_t);
void	 intel_dp_probe_oui(struct intel_dp *);
void	 intel_dp_init_panel_power_sequencer(struct drm_device *,
	     struct intel_dp *, struct edp_power_seq *);
void	 intel_dp_init_panel_power_sequencer_registers(struct drm_device *,
	     struct intel_dp *, struct edp_power_seq *);
void	 ironlake_panel_vdd_tick(void *);
void	 ironlake_panel_vdd_work(void *, void *);
int	 intel_dp_i2c_aux_ch(struct i2c_controller *, int, uint8_t, uint8_t *);

d46 1
a46 2
bool
is_edp(struct intel_dp *intel_dp)
d61 1
a61 2
bool
is_pch_edp(struct intel_dp *intel_dp)
d72 1
a72 2
bool
is_cpu_edp(struct intel_dp *intel_dp)
d77 1
a77 2
struct drm_device *
intel_dp_to_dev(struct intel_dp *intel_dp)
d84 1
a84 2
struct intel_dp *
intel_attached_dp(struct drm_connector *connector)
d96 1
a96 2
bool
intel_encoder_is_pch_edp(struct drm_encoder *encoder)
d108 2
d133 1
a133 1
int
d149 1
a149 1
int
d175 1
a175 1
int
d181 1
a181 1
int
d187 1
a187 1
bool
d214 1
a214 1
int
d242 1
a242 1
uint32_t
d255 1
a255 1
void
d266 1
a266 1
int
d299 1
a299 2
bool
ironlake_edp_have_panel_power(struct intel_dp *intel_dp)
d307 1
a307 2
bool
ironlake_edp_have_panel_vdd(struct intel_dp *intel_dp)
d315 1
a315 1
void
d333 1
a333 1
int
d486 1
a486 1
int
d519 1
a519 1
int
d527 1
a527 1
int
d566 1
a566 1
int
d663 1
a663 1
int
d750 9
a758 1
void
d767 1
a767 1
void
d854 1
a854 2
void
intel_dp_init_link_config(struct intel_dp *intel_dp)
d869 1
a869 1
void
d979 1
a979 2
void
ironlake_wait_panel_status(struct intel_dp *intel_dp,
d1003 1
a1003 2
void
ironlake_wait_panel_on(struct intel_dp *intel_dp)
d1009 1
a1009 2
void
ironlake_wait_panel_off(struct intel_dp *intel_dp)
d1015 1
a1015 2
void
ironlake_wait_panel_power_cycle(struct intel_dp *intel_dp)
d1026 1
a1026 2
u32
ironlake_get_pp_control(struct drm_i915_private *dev_priv)
d1035 1
a1035 2
void
ironlake_edp_panel_vdd_on(struct intel_dp *intel_dp)
d1074 1
a1074 2
void
ironlake_panel_vdd_off_sync(struct intel_dp *intel_dp)
d1094 1
a1094 11
void
ironlake_panel_vdd_tick(void *arg)
{
	struct intel_dp *intel_dp = arg;

	workq_queue_task(NULL, &intel_dp->panel_vdd_task, 0,
	    ironlake_panel_vdd_work, intel_dp, NULL);
}

void
ironlake_panel_vdd_work(void *arg1, void *arg2)
d1104 10
a1113 2
void
ironlake_edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
d1135 1
a1135 2
void
ironlake_edp_panel_on(struct intel_dp *intel_dp)
d1177 1
a1177 2
void
ironlake_edp_panel_off(struct intel_dp *intel_dp)
d1202 1
a1202 2
void
ironlake_edp_backlight_on(struct intel_dp *intel_dp)
d1229 1
a1229 2
void
ironlake_edp_backlight_off(struct intel_dp *intel_dp)
d1248 1
a1248 2
void
ironlake_edp_pll_on(struct intel_dp *intel_dp)
d1274 1
a1274 2
void
ironlake_edp_pll_off(struct intel_dp *intel_dp)
d1300 1
a1300 2
void
intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode)
d1329 1
a1329 2
bool
intel_dp_get_hw_state(struct intel_encoder *encoder,
d1378 1
a1378 2
void
intel_disable_dp(struct intel_encoder *encoder)
d1394 1
a1394 2
void
intel_post_disable_dp(struct intel_encoder *encoder)
d1404 1
a1404 2
void
intel_enable_dp(struct intel_encoder *encoder)
d1423 1
a1423 2
void
intel_pre_enable_dp(struct intel_encoder *encoder)
d1435 1
a1435 1
bool
d1460 1
a1460 1
bool
d1486 1
a1486 1
uint8_t
d1499 1
a1499 1
uint8_t
d1541 1
a1541 1
void
d1572 1
a1572 1
uint32_t
d1611 1
a1611 1
uint32_t
d1639 1
a1639 1
uint32_t
d1670 1
a1670 1
uint32_t
d1703 1
a1703 1
bool
d1994 1
a1994 1
void
d2075 1
a2075 1
bool
d2100 1
a2100 1
void
d2121 1
a2121 1
bool
d2135 1
a2135 1
void
d2199 1
a2199 1
enum drm_connector_status
d2238 1
a2238 1
enum drm_connector_status
d2255 1
a2255 1
enum drm_connector_status
d2282 1
a2282 1
struct edid *
d2308 1
a2308 1
int
d2333 1
a2333 1
enum drm_connector_status
d2379 1
a2379 2
int
intel_dp_get_modes(struct drm_connector *connector)
d2406 1
a2406 1
bool
d2422 1
a2422 1
int
d2494 1
a2494 1
void
d2513 1
a2513 2
void
intel_dp_encoder_destroy(struct drm_encoder *encoder)
d2553 1
a2553 1
void
d2581 1
a2581 2
bool
intel_dpd_is_edp(struct drm_device *dev)
d2600 1
a2600 1
void
d2618 1
a2618 1
void
d2703 1
a2703 1
void
@


1.6
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.5 2013/07/04 09:55:01 jsg Exp $	*/
d561 1
a561 1
			DELAY(100);
d637 1
a637 1
			DELAY(100);
d686 1
a686 1
			DELAY(100);
d758 1
a758 1
			DELAY(100);
d777 1
a777 1
			DELAY(100);
d1404 1
a1404 1
	DELAY(200);
d1430 1
a1430 1
	DELAY(200);
@


1.5
log
@ensure single initialization and cleanup of backlight device
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.4 2013/04/08 05:46:12 jsg Exp $	*/
d85 1
a85 1
u32	 ironlake_get_pp_control(struct inteldrm_softc *);
d393 1
a393 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d427 1
a427 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d436 1
a436 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d446 1
a446 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d467 1
a467 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d908 1
a908 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d993 1
a993 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1104 1
a1104 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1150 1
a1150 1
ironlake_get_pp_control(struct inteldrm_softc *dev_priv)
d1163 1
a1163 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1203 1
a1203 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1267 1
a1267 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1310 1
a1310 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1337 1
a1337 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1364 1
a1364 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1386 1
a1386 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1413 1
a1413 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1470 1
a1470 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1547 1
a1547 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1850 1
a1850 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2139 1
a2139 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2399 1
a2399 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2568 1
a2568 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d2726 1
a2726 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2766 1
a2766 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2851 1
a2851 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2893 1
a2893 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.4
log
@Use the fixed pixel clock for eDP in intel_dp_set_m_n()
from linux 3.8.6
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.3 2013/04/04 21:26:19 kettenis Exp $	*/
a2637 1
	struct drm_device *dev = connector->dev;
d2644 1
a2644 2
	if (is_edp(intel_dp)) {
		intel_panel_destroy_backlight(dev);
a2645 1
	}
@


1.3
log
@The intel_dp_i2c_aux_ch() function has to return Linux-style negative errno
values.  Its callers assume a positive return value means the function was
successful.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.2 2013/04/03 05:29:06 jsg Exp $	*/
d914 1
d930 9
d945 1
a945 1
			     mode->clock, adjusted_mode->clock, &m_n);
@


1.2
log
@match linux 3.8.5 and backout the 'try to train DP even harder' commit
which introduced a bogus check that could lead to an infinite loop
in some eDP setups.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d756 1
a756 1
			return EIO;
d763 1
a763 1
			return EIO;
d774 1
a774 1
			return EIO;
d781 1
a781 1
			return EIO;
d786 1
a786 1
	return EIO;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2016 1
a2016 1
		if (i == intel_dp->lane_count && voltage_tries == 5) {
@

