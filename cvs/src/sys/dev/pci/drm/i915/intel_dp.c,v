head	1.27;
access;
symbols
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7;
locks; strict;
comment	@ * @;


1.27
date	2015.12.09.05.17.44;	author jsg;	state Exp;
branches;
next	1.26;
commitid	s0XYUHVZL3Xim3bC;

1.26
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	lQlppvmETCN49oZe;

1.25
date	2015.06.24.08.32.39;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	hfEqCdm8ecmxIgUE;

1.24
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.23;
commitid	syZU9J25izIJ2cm1;

1.23
date	2015.04.06.10.56.37;	author jsg;	state Exp;
branches;
next	1.22;
commitid	YRwUkzqVtigPPQbt;

1.22
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.21;
commitid	C5l5rZ5v9mpRR1eS;

1.21
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.20;
commitid	MyKPm9Q3dQu92BiX;

1.20
date	2014.06.19.06.51.05;	author jsg;	state Exp;
branches;
next	1.19;
commitid	5s6b2JA43QOy2mup;

1.19
date	2014.06.19.06.44.00;	author jsg;	state Exp;
branches;
next	1.18;
commitid	fkRD3xvCprfQuBES;

1.18
date	2014.03.30.01.10.36;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.30.01.06.31;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.18.02.48.57;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2014.02.02.01.06.21;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.23.10.42.57;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.22.05.16.55;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.30.02.11.33;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.13.10.23.51;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2013.07.08.09.47.45;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2013.07.04.09.55.01;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.08.05.46.12;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.04.04.21.26.19;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.03.05.29.06;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Backport some commits from mainline linux to enable High Bit Rate 2
(HBR2) for Broadwell and non-ULX Haswell DisplayPort.  This enables
support for 3840x2160 60Hz SST.

Initial patch from and tested by Scot Doyle.

drm/i915: Enable 5.4Ghz (HBR2) link rate for Displayport 1.2-capable devices
from Todd Previte
06ea66b6bb445043dc25a9626254d5c130093199

drm/i915: don't try DP_LINK_BW_5_4 on HSW ULX
from Paulo Zanoni
9bbfd20abe5025adbb0ac75160bd2e41158a9e83

drm/i915/dp: add missing \n in the TPS3 debug message
from Jani Nikula
f8d8a672f9370278ae2c9752ad3021662dbc42fd

drm/i915/dp: only use training pattern 3 on platforms that support it
from Jani Nikula
7809a61176b385ebb3299ea43c58b1bb31ffb8c0
@
text
@/*	$OpenBSD: intel_dp.c,v 1.26 2015/09/23 23:12:12 kettenis Exp $	*/
/*
 * Copyright Â© 2008 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Keith Packard <keithp@@keithp.com>
 *
 */

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_crtc_helper.h>
#include <dev/pci/drm/drm_edid.h>
#include "intel_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"

#define DP_LINK_CHECK_TIMEOUT	(10 * 1000)

struct dp_link_dpll {
	int link_bw;
	struct dpll dpll;
};

static const struct dp_link_dpll gen4_dpll[] = {
	{ DP_LINK_BW_1_62,
		{ .p1 = 2, .p2 = 10, .n = 2, .m1 = 23, .m2 = 8 } },
	{ DP_LINK_BW_2_7,
		{ .p1 = 1, .p2 = 10, .n = 1, .m1 = 14, .m2 = 2 } }
};

static const struct dp_link_dpll pch_dpll[] = {
	{ DP_LINK_BW_1_62,
		{ .p1 = 2, .p2 = 10, .n = 1, .m1 = 12, .m2 = 9 } },
	{ DP_LINK_BW_2_7,
		{ .p1 = 1, .p2 = 10, .n = 2, .m1 = 14, .m2 = 8 } }
};

static const struct dp_link_dpll vlv_dpll[] = {
	{ DP_LINK_BW_1_62,
		{ .p1 = 3, .p2 = 2, .n = 5, .m1 = 3, .m2 = 81 } },
	{ DP_LINK_BW_2_7,
		{ .p1 = 2, .p2 = 2, .n = 1, .m1 = 2, .m2 = 27 } }
};

/**
 * is_edp - is the given port attached to an eDP panel (either CPU or PCH)
 * @@intel_dp: DP struct
 *
 * If a CPU or PCH DP output is attached to an eDP panel, this function
 * will return true, and false otherwise.
 */
static bool is_edp(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	return intel_dig_port->base.type == INTEL_OUTPUT_EDP;
}

static struct drm_device *intel_dp_to_dev(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);

	return intel_dig_port->base.base.dev;
}

static struct intel_dp *intel_attached_dp(struct drm_connector *connector)
{
	return enc_to_intel_dp(&intel_attached_encoder(connector)->base);
}

static void intel_dp_link_down(struct intel_dp *intel_dp);

static int
intel_dp_max_link_bw(struct intel_dp *intel_dp)
{
	int max_link_bw = intel_dp->dpcd[DP_MAX_LINK_RATE];
	struct drm_device *dev = intel_dp->attached_connector->base.dev;

	switch (max_link_bw) {
	case DP_LINK_BW_1_62:
	case DP_LINK_BW_2_7:
		break;
	case DP_LINK_BW_5_4: /* 1.2 capable displays may advertise higher bw */
		if (((IS_HASWELL(dev) && !IS_HSW_ULX(dev)) ||
		     INTEL_INFO(dev)->gen >= 8) &&
		    intel_dp->dpcd[DP_DPCD_REV] >= 0x12)
			max_link_bw = DP_LINK_BW_5_4;
		else
			max_link_bw = DP_LINK_BW_2_7;
		break;
	default:
		WARN(1, "invalid max DP link bw val %x, using 1.62Gbps\n",
		     max_link_bw);
		max_link_bw = DP_LINK_BW_1_62;
		break;
	}
	return max_link_bw;
}

/*
 * The units on the numbers in the next two are... bizarre.  Examples will
 * make it clearer; this one parallels an example in the eDP spec.
 *
 * intel_dp_max_data_rate for one lane of 2.7GHz evaluates as:
 *
 *     270000 * 1 * 8 / 10 == 216000
 *
 * The actual data capacity of that configuration is 2.16Gbit/s, so the
 * units are decakilobits.  ->clock in a drm_display_mode is in kilohertz -
 * or equivalently, kilopixels per second - so for 1680x1050R it'd be
 * 119000.  At 18bpp that's 2142000 kilobits per second.
 *
 * Thus the strange-looking division by 10 in intel_dp_link_required, to
 * get the result in decakilobits instead of kilobits.
 */

static int
intel_dp_link_required(int pixel_clock, int bpp)
{
	return (pixel_clock * bpp + 9) / 10;
}

static int
intel_dp_max_data_rate(int max_link_clock, int max_lanes)
{
	return (max_link_clock * max_lanes * 8) / 10;
}

static enum drm_mode_status
intel_dp_mode_valid(struct drm_connector *connector,
		    struct drm_display_mode *mode)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct drm_display_mode *fixed_mode = intel_connector->panel.fixed_mode;
	int target_clock = mode->clock;
	int max_rate, mode_rate, max_lanes, max_link_clock;

	if (is_edp(intel_dp) && fixed_mode) {
		if (mode->hdisplay > fixed_mode->hdisplay)
			return MODE_PANEL;

		if (mode->vdisplay > fixed_mode->vdisplay)
			return MODE_PANEL;

		target_clock = fixed_mode->clock;
	}

	max_link_clock = drm_dp_bw_code_to_link_rate(intel_dp_max_link_bw(intel_dp));
	max_lanes = drm_dp_max_lane_count(intel_dp->dpcd);

	max_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);
	mode_rate = intel_dp_link_required(target_clock, 18);

	if (mode_rate > max_rate)
		return MODE_CLOCK_HIGH;

	if (mode->clock < 10000)
		return MODE_CLOCK_LOW;

	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
		return MODE_H_ILLEGAL;

	return MODE_OK;
}

static uint32_t
pack_aux(uint8_t *src, int src_bytes)
{
	int	i;
	uint32_t v = 0;

	if (src_bytes > 4)
		src_bytes = 4;
	for (i = 0; i < src_bytes; i++)
		v |= ((uint32_t) src[i]) << ((3-i) * 8);
	return v;
}

static void
unpack_aux(uint32_t src, uint8_t *dst, int dst_bytes)
{
	int i;
	if (dst_bytes > 4)
		dst_bytes = 4;
	for (i = 0; i < dst_bytes; i++)
		dst[i] = src >> ((3-i) * 8);
}

/* hrawclock is 1/4 the FSB frequency */
static int
intel_hrawclk(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t clkcfg;

	/* There is no CLKCFG reg in Valleyview. VLV hrawclk is 200 MHz */
	if (IS_VALLEYVIEW(dev))
		return 200;

	clkcfg = I915_READ(CLKCFG);
	switch (clkcfg & CLKCFG_FSB_MASK) {
	case CLKCFG_FSB_400:
		return 100;
	case CLKCFG_FSB_533:
		return 133;
	case CLKCFG_FSB_667:
		return 166;
	case CLKCFG_FSB_800:
		return 200;
	case CLKCFG_FSB_1067:
		return 266;
	case CLKCFG_FSB_1333:
		return 333;
	/* these two are just a guess; one of them might be right */
	case CLKCFG_FSB_1600:
	case CLKCFG_FSB_1600_ALT:
		return 400;
	default:
		return 133;
	}
}

static void
intel_dp_init_panel_power_sequencer(struct drm_device *dev,
				    struct intel_dp *intel_dp,
				    struct edp_power_seq *out);
static void
intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
					      struct intel_dp *intel_dp,
					      struct edp_power_seq *out);

static enum pipe
vlv_power_sequencer_pipe(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	enum pipe pipe;

	/* modeset should have pipe */
	if (crtc)
		return to_intel_crtc(crtc)->pipe;

	/* init time, try to find a pipe with this port selected */
	for (pipe = PIPE_A; pipe <= PIPE_B; pipe++) {
		u32 port_sel = I915_READ(VLV_PIPE_PP_ON_DELAYS(pipe)) &
			PANEL_PORT_SELECT_MASK;
		if (port_sel == PANEL_PORT_SELECT_DPB_VLV && port == PORT_B)
			return pipe;
		if (port_sel == PANEL_PORT_SELECT_DPC_VLV && port == PORT_C)
			return pipe;
	}

	/* shrug */
	return PIPE_A;
}

static u32 _pp_ctrl_reg(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (HAS_PCH_SPLIT(dev))
		return PCH_PP_CONTROL;
	else
		return VLV_PIPE_PP_CONTROL(vlv_power_sequencer_pipe(intel_dp));
}

static u32 _pp_stat_reg(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (HAS_PCH_SPLIT(dev))
		return PCH_PP_STATUS;
	else
		return VLV_PIPE_PP_STATUS(vlv_power_sequencer_pipe(intel_dp));
}

static bool ironlake_edp_have_panel_power(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	return (I915_READ(_pp_stat_reg(intel_dp)) & PP_ON) != 0;
}

static bool ironlake_edp_have_panel_vdd(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	return (I915_READ(_pp_ctrl_reg(intel_dp)) & EDP_FORCE_VDD) != 0;
}

static void
intel_dp_check_edp(struct intel_dp *intel_dp)
{
#ifdef DRMDEBUG
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
#endif

	if (!is_edp(intel_dp))
		return;

	if (!ironlake_edp_have_panel_power(intel_dp) && !ironlake_edp_have_panel_vdd(intel_dp)) {
		WARN(1, "eDP powered off while attempting aux channel communication.\n");
		DRM_DEBUG_KMS("Status 0x%08x Control 0x%08x\n",
			      I915_READ(_pp_stat_reg(intel_dp)),
			      I915_READ(_pp_ctrl_reg(intel_dp)));
	}
}

static uint32_t
intel_dp_aux_wait_done(struct intel_dp *intel_dp, bool has_aux_irq)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t ch_ctl = intel_dp->aux_ch_ctl_reg;
	uint32_t status;
	bool done;

	if (cold)
		has_aux_irq = false;

#define C (((status = I915_READ_NOTRACE(ch_ctl)) & DP_AUX_CH_CTL_SEND_BUSY) == 0)
	if (has_aux_irq)
		done = wait_event_timeout(dev_priv->gmbus_wait_queue, C,
					  msecs_to_jiffies_timeout(10));
	else
		done = wait_for_atomic(C, 10) == 0;
	if (!done)
		DRM_ERROR("dp aux hw did not signal timeout (has irq: %i)!\n",
			  has_aux_irq);
#undef C

	return status;
}

static uint32_t get_aux_clock_divider(struct intel_dp *intel_dp,
				      int index)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* The clock divider is based off the hrawclk,
	 * and would like to run at 2MHz. So, take the
	 * hrawclk value and divide by 2 and use that
	 *
	 * Note that PCH attached eDP panels should use a 125MHz input
	 * clock divider.
	 */
	if (IS_VALLEYVIEW(dev)) {
		return index ? 0 : 100;
	} else if (intel_dig_port->port == PORT_A) {
		if (index)
			return 0;
		if (HAS_DDI(dev))
			return DIV_ROUND_CLOSEST(intel_ddi_get_cdclk_freq(dev_priv), 2000);
		else if (IS_GEN6(dev) || IS_GEN7(dev))
			return 200; /* SNB & IVB eDP input clock at 400Mhz */
		else
			return 225; /* eDP input clock at 450Mhz */
	} else if (dev_priv->pch_id == INTEL_PCH_LPT_DEVICE_ID_TYPE) {
		/* Workaround for non-ULT HSW */
		switch (index) {
		case 0: return 63;
		case 1: return 72;
		default: return 0;
		}
	} else if (HAS_PCH_SPLIT(dev)) {
		return index ? 0 : DIV_ROUND_UP(intel_pch_rawclk(dev), 2);
	} else {
		return index ? 0 :intel_hrawclk(dev) / 2;
	}
}

static int
intel_dp_aux_ch(struct intel_dp *intel_dp,
		uint8_t *send, int send_bytes,
		uint8_t *recv, int recv_size)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t ch_ctl = intel_dp->aux_ch_ctl_reg;
	uint32_t ch_data = ch_ctl + 4;
	uint32_t aux_clock_divider;
	int i, ret, recv_bytes;
	uint32_t status;
	int try, precharge, clock = 0;
	bool has_aux_irq = HAS_AUX_IRQ(dev);
	uint32_t timeout;

#ifdef notyet
	/* dp aux is extremely sensitive to irq latency, hence request the
	 * lowest possible wakeup latency and so prevent the cpu from going into
	 * deep sleep states.
	 */
	pm_qos_update_request(&dev_priv->pm_qos, 0);
#endif

	intel_dp_check_edp(intel_dp);

	if (IS_GEN6(dev))
		precharge = 3;
	else
		precharge = 5;

	if (IS_BROADWELL(dev) && ch_ctl == DPA_AUX_CH_CTL)
		timeout = DP_AUX_CH_CTL_TIME_OUT_600us;
	else
		timeout = DP_AUX_CH_CTL_TIME_OUT_400us;

	intel_aux_display_runtime_get(dev_priv);

	/* Try to wait for any previous AUX channel activity */
	for (try = 0; try < 3; try++) {
		status = I915_READ_NOTRACE(ch_ctl);
		if ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)
			break;
		drm_msleep(1);
	}

	if (try == 3) {
		WARN(1, "dp_aux_ch not started status 0x%08x\n",
		     I915_READ(ch_ctl));
		ret = -EBUSY;
		goto out;
	}

	/* Only 5 data registers! */
	if (WARN_ON(send_bytes > 20 || recv_size > 20)) {
		ret = -E2BIG;
		goto out;
	}

	while ((aux_clock_divider = get_aux_clock_divider(intel_dp, clock++))) {
		/* Must try at least 3 times according to DP spec */
		for (try = 0; try < 5; try++) {
			/* Load the send data into the aux channel data registers */
			for (i = 0; i < send_bytes; i += 4)
				I915_WRITE(ch_data + i,
					   pack_aux(send + i, send_bytes - i));

			/* Send the command and wait for it to complete */
			I915_WRITE(ch_ctl,
				   DP_AUX_CH_CTL_SEND_BUSY |
				   (has_aux_irq ? DP_AUX_CH_CTL_INTERRUPT : 0) |
				   timeout |
				   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
				   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
				   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |
				   DP_AUX_CH_CTL_DONE |
				   DP_AUX_CH_CTL_TIME_OUT_ERROR |
				   DP_AUX_CH_CTL_RECEIVE_ERROR);

			status = intel_dp_aux_wait_done(intel_dp, has_aux_irq);

			/* Clear done status and any errors */
			I915_WRITE(ch_ctl,
				   status |
				   DP_AUX_CH_CTL_DONE |
				   DP_AUX_CH_CTL_TIME_OUT_ERROR |
				   DP_AUX_CH_CTL_RECEIVE_ERROR);

			if (status & (DP_AUX_CH_CTL_TIME_OUT_ERROR |
				      DP_AUX_CH_CTL_RECEIVE_ERROR))
				continue;
			if (status & DP_AUX_CH_CTL_DONE)
				goto done;
		}
	}

	if ((status & DP_AUX_CH_CTL_DONE) == 0) {
		DRM_ERROR("dp_aux_ch not done status 0x%08x\n", status);
		ret = -EBUSY;
		goto out;
	}

done:
	/* Check for timeout or receive error.
	 * Timeouts occur when the sink is not connected
	 */
	if (status & DP_AUX_CH_CTL_RECEIVE_ERROR) {
		DRM_ERROR("dp_aux_ch receive error status 0x%08x\n", status);
		ret = -EIO;
		goto out;
	}

	/* Timeouts occur when the device isn't connected, so they're
	 * "normal" -- don't fill the kernel log with these */
	if (status & DP_AUX_CH_CTL_TIME_OUT_ERROR) {
		DRM_DEBUG_KMS("dp_aux_ch timeout status 0x%08x\n", status);
		ret = -ETIMEDOUT;
		goto out;
	}

	/* Unload any bytes sent back from the other side */
	recv_bytes = ((status & DP_AUX_CH_CTL_MESSAGE_SIZE_MASK) >>
		      DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT);
	if (recv_bytes > recv_size)
		recv_bytes = recv_size;

	for (i = 0; i < recv_bytes; i += 4)
		unpack_aux(I915_READ(ch_data + i),
			   recv + i, recv_bytes - i);

	ret = recv_bytes;
out:
#ifdef notyet
	pm_qos_update_request(&dev_priv->pm_qos, PM_QOS_DEFAULT_VALUE);
#endif
	intel_aux_display_runtime_put(dev_priv);

	return ret;
}

/* Write data to the aux channel in native mode */
static int
intel_dp_aux_native_write(struct intel_dp *intel_dp,
			  uint16_t address, uint8_t *send, int send_bytes)
{
	int ret;
	uint8_t	msg[20];
	int msg_bytes;
	uint8_t	ack;
	int retry;

	if (WARN_ON(send_bytes > 16))
		return -E2BIG;

	intel_dp_check_edp(intel_dp);
	msg[0] = DP_AUX_NATIVE_WRITE << 4;
	msg[1] = address >> 8;
	msg[2] = address & 0xff;
	msg[3] = send_bytes - 1;
	memcpy(&msg[4], send, send_bytes);
	msg_bytes = send_bytes + 4;
	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp, msg, msg_bytes, &ack, 1);
		if (ret < 0)
			return ret;
		ack >>= 4;
		if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK)
			return send_bytes;
		else if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)
			usleep_range(400, 500);
		else
			return -EIO;
	}

	DRM_ERROR("too many retries, giving up\n");
	return -EIO;
}

/* Write a single byte to the aux channel in native mode */
static int
intel_dp_aux_native_write_1(struct intel_dp *intel_dp,
			    uint16_t address, uint8_t byte)
{
	return intel_dp_aux_native_write(intel_dp, address, &byte, 1);
}

/* read bytes from a native aux channel */
static int
intel_dp_aux_native_read(struct intel_dp *intel_dp,
			 uint16_t address, uint8_t *recv, int recv_bytes)
{
	uint8_t msg[4];
	int msg_bytes;
	uint8_t reply[20];
	int reply_bytes;
	uint8_t ack;
	int ret;
	int retry;

	if (WARN_ON(recv_bytes > 19))
		return -E2BIG;

	intel_dp_check_edp(intel_dp);
	msg[0] = DP_AUX_NATIVE_READ << 4;
	msg[1] = address >> 8;
	msg[2] = address & 0xff;
	msg[3] = recv_bytes - 1;

	msg_bytes = 4;
	reply_bytes = recv_bytes + 1;

	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp, msg, msg_bytes,
				      reply, reply_bytes);
		if (ret == 0)
			return -EPROTO;
		if (ret < 0)
			return ret;
		ack = reply[0] >> 4;
		if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_ACK) {
			memcpy(recv, reply + 1, ret - 1);
			return ret - 1;
		}
		else if ((ack & DP_AUX_NATIVE_REPLY_MASK) == DP_AUX_NATIVE_REPLY_DEFER)
			usleep_range(400, 500);
		else
			return -EIO;
	}

	DRM_ERROR("too many retries, giving up\n");
	return -EIO;
}

static int
intel_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,
		    uint8_t write_byte, uint8_t *read_byte)
{
	struct i2c_algo_dp_aux_data *algo_data = adapter->ic_cookie;
	struct intel_dp *intel_dp = container_of(adapter,
						struct intel_dp,
						adapter);
	uint16_t address = algo_data->address;
	uint8_t msg[5];
	uint8_t reply[2];
	unsigned retry;
	int msg_bytes;
	int reply_bytes;
	int ret;

	ironlake_edp_panel_vdd_on(intel_dp);
	intel_dp_check_edp(intel_dp);
	/* Set up the command byte */
	if (mode & MODE_I2C_READ)
		msg[0] = DP_AUX_I2C_READ << 4;
	else
		msg[0] = DP_AUX_I2C_WRITE << 4;

	if (!(mode & MODE_I2C_STOP))
		msg[0] |= DP_AUX_I2C_MOT << 4;

	msg[1] = address >> 8;
	msg[2] = address;

	switch (mode) {
	case MODE_I2C_WRITE:
		msg[3] = 0;
		msg[4] = write_byte;
		msg_bytes = 5;
		reply_bytes = 1;
		break;
	case MODE_I2C_READ:
		msg[3] = 0;
		msg_bytes = 4;
		reply_bytes = 2;
		break;
	default:
		msg_bytes = 3;
		reply_bytes = 1;
		break;
	}

	/*
	 * DP1.2 sections 2.7.7.1.5.6.1 and 2.7.7.1.6.6.1: A DP Source device is
	 * required to retry at least seven times upon receiving AUX_DEFER
	 * before giving up the AUX transaction.
	 */
	for (retry = 0; retry < 7; retry++) {
		ret = intel_dp_aux_ch(intel_dp,
				      msg, msg_bytes,
				      reply, reply_bytes);
		if (ret < 0) {
			DRM_DEBUG_KMS("aux_ch failed %d\n", ret);
			goto out;
		}

		switch ((reply[0] >> 4) & DP_AUX_NATIVE_REPLY_MASK) {
		case DP_AUX_NATIVE_REPLY_ACK:
			/* I2C-over-AUX Reply field is only valid
			 * when paired with AUX ACK.
			 */
			break;
		case DP_AUX_NATIVE_REPLY_NACK:
			DRM_DEBUG_KMS("aux_ch native nack\n");
			ret = -EREMOTEIO;
			goto out;
		case DP_AUX_NATIVE_REPLY_DEFER:
			/*
			 * For now, just give more slack to branch devices. We
			 * could check the DPCD for I2C bit rate capabilities,
			 * and if available, adjust the interval. We could also
			 * be more careful with DP-to-Legacy adapters where a
			 * long legacy cable may force very low I2C bit rates.
			 */
			if (intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
			    DP_DWN_STRM_PORT_PRESENT)
				usleep_range(500, 600);
			else
				usleep_range(300, 400);
			continue;
		default:
			DRM_ERROR("aux_ch invalid native reply 0x%02x\n",
				  reply[0]);
			ret = -EREMOTEIO;
			goto out;
		}

		switch ((reply[0] >> 4) & DP_AUX_I2C_REPLY_MASK) {
		case DP_AUX_I2C_REPLY_ACK:
			if (mode == MODE_I2C_READ) {
				*read_byte = reply[1];
			}
			ret = reply_bytes - 1;
			goto out;
		case DP_AUX_I2C_REPLY_NACK:
			DRM_DEBUG_KMS("aux_i2c nack\n");
			ret = -EREMOTEIO;
			goto out;
		case DP_AUX_I2C_REPLY_DEFER:
			DRM_DEBUG_KMS("aux_i2c defer\n");
			udelay(100);
			break;
		default:
			DRM_ERROR("aux_i2c invalid reply 0x%02x\n", reply[0]);
			ret = -EREMOTEIO;
			goto out;
		}
	}

	DRM_ERROR("too many retries, giving up\n");
	ret = -EREMOTEIO;

out:
	ironlake_edp_panel_vdd_off(intel_dp, false);
	return ret;
}

static void
intel_dp_connector_unregister(struct intel_connector *intel_connector)
{
#ifdef __linux__
	struct intel_dp *intel_dp = intel_attached_dp(&intel_connector->base);

	sysfs_remove_link(&intel_connector->base.kdev->kobj,
			  intel_dp->adapter.dev.kobj.name);
#endif
	intel_connector_unregister(intel_connector);
}

static int
intel_dp_i2c_init(struct intel_dp *intel_dp,
		  struct intel_connector *intel_connector, const char *name)
{
	int	ret;

	DRM_DEBUG_KMS("i2c_init %s\n", name);
	intel_dp->algo.running = false;
	intel_dp->algo.address = 0;
	intel_dp->algo.aux_ch = intel_dp_i2c_aux_ch;

	memset(&intel_dp->adapter, '\0', sizeof(intel_dp->adapter));
#ifdef __linux__
	intel_dp->adapter.owner = THIS_MODULE;
	intel_dp->adapter.class = I2C_CLASS_DDC;
	strncpy(intel_dp->adapter.name, name, sizeof(intel_dp->adapter.name) - 1);
	intel_dp->adapter.name[sizeof(intel_dp->adapter.name) - 1] = '\0';
	intel_dp->adapter.algo_data = &intel_dp->algo;
	intel_dp->adapter.dev.parent = intel_connector->base.dev->dev;
#else
	intel_dp->algo.adapter = &intel_dp->adapter;
	intel_dp->adapter.ic_cookie = &intel_dp->algo;
#endif

	ret = i2c_dp_aux_add_bus(&intel_dp->adapter);
	if (ret < 0)
		return ret;

#ifdef __linux__
	ret = sysfs_create_link(&intel_connector->base.kdev->kobj,
				&intel_dp->adapter.dev.kobj,
				intel_dp->adapter.dev.kobj.name);

	if (ret < 0)
		i2c_del_adapter(&intel_dp->adapter);
#endif

	return ret;
}

static void
intel_dp_set_clock(struct intel_encoder *encoder,
		   struct intel_crtc_config *pipe_config, int link_bw)
{
	struct drm_device *dev = encoder->base.dev;
	const struct dp_link_dpll *divisor = NULL;
	int i, count = 0;

	if (IS_G4X(dev)) {
		divisor = gen4_dpll;
		count = ARRAY_SIZE(gen4_dpll);
	} else if (IS_HASWELL(dev)) {
		/* Haswell has special-purpose DP DDI clocks. */
	} else if (HAS_PCH_SPLIT(dev)) {
		divisor = pch_dpll;
		count = ARRAY_SIZE(pch_dpll);
	} else if (IS_VALLEYVIEW(dev)) {
		divisor = vlv_dpll;
		count = ARRAY_SIZE(vlv_dpll);
	}

	if (divisor && count) {
		for (i = 0; i < count; i++) {
			if (link_bw == divisor[i].link_bw) {
				pipe_config->dpll = divisor[i].dpll;
				pipe_config->clock_set = true;
				break;
			}
		}
	}
}

bool
intel_dp_compute_config(struct intel_encoder *encoder,
			struct intel_crtc_config *pipe_config)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *intel_crtc = encoder->new_crtc;
	struct intel_connector *intel_connector = intel_dp->attached_connector;
	int lane_count, clock;
	int max_lane_count = drm_dp_max_lane_count(intel_dp->dpcd);
	/* Conveniently, the link BW constants become indices with a shift...*/
	int max_clock = intel_dp_max_link_bw(intel_dp) >> 3;
	int bpp, mode_rate;
	static int bws[] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7, DP_LINK_BW_5_4 };
	int link_avail, link_clock;

	if (HAS_PCH_SPLIT(dev) && !HAS_DDI(dev) && port != PORT_A)
		pipe_config->has_pch_encoder = true;

	pipe_config->has_dp_encoder = true;

	if (is_edp(intel_dp) && intel_connector->panel.fixed_mode) {
		intel_fixed_panel_mode(intel_connector->panel.fixed_mode,
				       adjusted_mode);
		if (!HAS_PCH_SPLIT(dev))
			intel_gmch_panel_fitting(intel_crtc, pipe_config,
						 intel_connector->panel.fitting_mode);
		else
			intel_pch_panel_fitting(intel_crtc, pipe_config,
						intel_connector->panel.fitting_mode);
	}

	if (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)
		return false;

	DRM_DEBUG_KMS("DP link computation with max lane count %i "
		      "max bw %02x pixel clock %iKHz\n",
		      max_lane_count, bws[max_clock],
		      adjusted_mode->crtc_clock);

	/* Walk through all bpp values. Luckily they're all nicely spaced with 2
	 * bpc in between. */
	bpp = pipe_config->pipe_bpp;
	if (is_edp(intel_dp) && dev_priv->vbt.edp_bpp &&
	    dev_priv->vbt.edp_bpp < bpp) {
		DRM_DEBUG_KMS("clamping bpp for eDP panel to BIOS-provided %i\n",
			      dev_priv->vbt.edp_bpp);
		bpp = dev_priv->vbt.edp_bpp;
	}

	for (; bpp >= 6*3; bpp -= 2*3) {
		mode_rate = intel_dp_link_required(adjusted_mode->crtc_clock,
						   bpp);

		for (clock = 0; clock <= max_clock; clock++) {
			for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
				link_clock = drm_dp_bw_code_to_link_rate(bws[clock]);
				link_avail = intel_dp_max_data_rate(link_clock,
								    lane_count);

				if (mode_rate <= link_avail) {
					goto found;
				}
			}
		}
	}

	return false;

found:
	if (intel_dp->color_range_auto) {
		/*
		 * See:
		 * CEA-861-E - 5.1 Default Encoding Parameters
		 * VESA DisplayPort Ver.1.2a - 5.1.1.1 Video Colorimetry
		 */
		if (bpp != 18 && drm_match_cea_mode(adjusted_mode) > 1)
			intel_dp->color_range = DP_COLOR_RANGE_16_235;
		else
			intel_dp->color_range = 0;
	}

	if (intel_dp->color_range)
		pipe_config->limited_color_range = true;

	intel_dp->link_bw = bws[clock];
	intel_dp->lane_count = lane_count;
	pipe_config->pipe_bpp = bpp;
	pipe_config->port_clock = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);

	DRM_DEBUG_KMS("DP link bw %02x lane count %d clock %d bpp %d\n",
		      intel_dp->link_bw, intel_dp->lane_count,
		      pipe_config->port_clock, bpp);
	DRM_DEBUG_KMS("DP link bw required %i available %i\n",
		      mode_rate, link_avail);

	intel_link_compute_m_n(bpp, lane_count,
			       adjusted_mode->crtc_clock,
			       pipe_config->port_clock,
			       &pipe_config->dp_m_n);

	intel_dp_set_clock(encoder, pipe_config, intel_dp->link_bw);

	return true;
}

static void ironlake_set_pll_cpu_edp(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);
	struct drm_device *dev = crtc->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	DRM_DEBUG_KMS("eDP PLL enable for clock %d\n", crtc->config.port_clock);
	dpa_ctl = I915_READ(DP_A);
	dpa_ctl &= ~DP_PLL_FREQ_MASK;

	if (crtc->config.port_clock == 162000) {
		/* For a long time we've carried around a ILK-DevA w/a for the
		 * 160MHz clock. If we're really unlucky, it's still required.
		 */
		DRM_DEBUG_KMS("160MHz cpu eDP clock, might need ilk devA w/a\n");
		dpa_ctl |= DP_PLL_FREQ_160MHZ;
		intel_dp->DP |= DP_PLL_FREQ_160MHZ;
	} else {
		dpa_ctl |= DP_PLL_FREQ_270MHZ;
		intel_dp->DP |= DP_PLL_FREQ_270MHZ;
	}

	I915_WRITE(DP_A, dpa_ctl);

	POSTING_READ(DP_A);
	udelay(500);
}

static void intel_dp_mode_set(struct intel_encoder *encoder)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	struct drm_display_mode *adjusted_mode = &crtc->config.adjusted_mode;

	/*
	 * There are four kinds of DP registers:
	 *
	 * 	IBX PCH
	 * 	SNB CPU
	 *	IVB CPU
	 * 	CPT PCH
	 *
	 * IBX PCH and CPU are the same for almost everything,
	 * except that the CPU DP PLL is configured in this
	 * register
	 *
	 * CPT PCH is quite different, having many bits moved
	 * to the TRANS_DP_CTL register instead. That
	 * configuration happens (oddly) in ironlake_pch_enable
	 */

	/* Preserve the BIOS-computed detected bit. This is
	 * supposed to be read-only.
	 */
	intel_dp->DP = I915_READ(intel_dp->output_reg) & DP_DETECTED;

	/* Handle DP bits in common between all three register formats */
	intel_dp->DP |= DP_VOLTAGE_0_4 | DP_PRE_EMPHASIS_0;
	intel_dp->DP |= DP_PORT_WIDTH(intel_dp->lane_count);

	if (intel_dp->has_audio) {
		DRM_DEBUG_DRIVER("Enabling DP audio on pipe %c\n",
				 pipe_name(crtc->pipe));
		intel_dp->DP |= DP_AUDIO_OUTPUT_ENABLE;
		intel_write_eld(&encoder->base, adjusted_mode);
	}

	/* Split out the IBX/CPU vs CPT settings */

	if (port == PORT_A && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
		if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
			intel_dp->DP |= DP_SYNC_HS_HIGH;
		if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
			intel_dp->DP |= DP_SYNC_VS_HIGH;
		intel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;

		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
			intel_dp->DP |= DP_ENHANCED_FRAMING;

		intel_dp->DP |= crtc->pipe << 29;
	} else if (!HAS_PCH_CPT(dev) || port == PORT_A) {
		if (!HAS_PCH_SPLIT(dev) && !IS_VALLEYVIEW(dev))
			intel_dp->DP |= intel_dp->color_range;

		if (adjusted_mode->flags & DRM_MODE_FLAG_PHSYNC)
			intel_dp->DP |= DP_SYNC_HS_HIGH;
		if (adjusted_mode->flags & DRM_MODE_FLAG_PVSYNC)
			intel_dp->DP |= DP_SYNC_VS_HIGH;
		intel_dp->DP |= DP_LINK_TRAIN_OFF;

		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
			intel_dp->DP |= DP_ENHANCED_FRAMING;

		if (crtc->pipe == 1)
			intel_dp->DP |= DP_PIPEB_SELECT;
	} else {
		intel_dp->DP |= DP_LINK_TRAIN_OFF_CPT;
	}

	if (port == PORT_A && !IS_VALLEYVIEW(dev))
		ironlake_set_pll_cpu_edp(intel_dp);
}

#define IDLE_ON_MASK		(PP_ON | 0 	  | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
#define IDLE_ON_VALUE   	(PP_ON | 0 	  | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_ON_IDLE)

#define IDLE_OFF_MASK		(PP_ON | 0        | PP_SEQUENCE_MASK | 0                     | PP_SEQUENCE_STATE_MASK)
#define IDLE_OFF_VALUE		(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)

#define IDLE_CYCLE_MASK		(PP_ON | 0        | PP_SEQUENCE_MASK | PP_CYCLE_DELAY_ACTIVE | PP_SEQUENCE_STATE_MASK)
#define IDLE_CYCLE_VALUE	(0     | 0        | PP_SEQUENCE_NONE | 0                     | PP_SEQUENCE_STATE_OFF_IDLE)

static void ironlake_wait_panel_status(struct intel_dp *intel_dp,
				       u32 mask,
				       u32 value)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp_stat_reg, pp_ctrl_reg;

	pp_stat_reg = _pp_stat_reg(intel_dp);
	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	DRM_DEBUG_KMS("mask %08x value %08x status %08x control %08x\n",
			mask, value,
			I915_READ(pp_stat_reg),
			I915_READ(pp_ctrl_reg));

	if (_wait_for((I915_READ(pp_stat_reg) & mask) == value, 5000, 10)) {
		DRM_ERROR("Panel status timeout: status %08x control %08x\n",
				I915_READ(pp_stat_reg),
				I915_READ(pp_ctrl_reg));
	}

	DRM_DEBUG_KMS("Wait complete\n");
}

static void ironlake_wait_panel_on(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power on\n");
	ironlake_wait_panel_status(intel_dp, IDLE_ON_MASK, IDLE_ON_VALUE);
}

static void ironlake_wait_panel_off(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power off time\n");
	ironlake_wait_panel_status(intel_dp, IDLE_OFF_MASK, IDLE_OFF_VALUE);
}

static void ironlake_wait_panel_power_cycle(struct intel_dp *intel_dp)
{
	DRM_DEBUG_KMS("Wait for panel power cycle\n");
	ironlake_wait_panel_status(intel_dp, IDLE_CYCLE_MASK, IDLE_CYCLE_VALUE);
}


/* Read the current pp_control value, unlocking the register if it
 * is locked
 */

static  u32 ironlake_get_pp_control(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 control;

	control = I915_READ(_pp_ctrl_reg(intel_dp));
	control &= ~PANEL_UNLOCK_MASK;
	control |= PANEL_UNLOCK_REGS;
	return control;
}

void ironlake_edp_panel_vdd_on(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_stat_reg, pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	WARN(intel_dp->want_panel_vdd,
	     "eDP VDD already requested on\n");

	intel_dp->want_panel_vdd = true;

	if (ironlake_edp_have_panel_vdd(intel_dp))
		return;

	intel_runtime_pm_get(dev_priv);

	DRM_DEBUG_KMS("Turning eDP VDD on\n");

	if (!ironlake_edp_have_panel_power(intel_dp))
		ironlake_wait_panel_power_cycle(intel_dp);

	pp = ironlake_get_pp_control(intel_dp);
	pp |= EDP_FORCE_VDD;

	pp_stat_reg = _pp_stat_reg(intel_dp);
	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);
	DRM_DEBUG_KMS("PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\n",
			I915_READ(pp_stat_reg), I915_READ(pp_ctrl_reg));
	/*
	 * If the panel wasn't on, delay before accessing aux channel
	 */
	if (!ironlake_edp_have_panel_power(intel_dp)) {
		DRM_DEBUG_KMS("eDP was not running\n");
		drm_msleep(intel_dp->panel_power_up_delay);
	}
}

static void ironlake_panel_vdd_off_sync(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_stat_reg, pp_ctrl_reg;

	WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));

	if (!intel_dp->want_panel_vdd && ironlake_edp_have_panel_vdd(intel_dp)) {
		DRM_DEBUG_KMS("Turning eDP VDD off\n");

		pp = ironlake_get_pp_control(intel_dp);
		pp &= ~EDP_FORCE_VDD;

		pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
		pp_stat_reg = _pp_stat_reg(intel_dp);

		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);

		/* Make sure sequencer is idle before allowing subsequent activity */
		DRM_DEBUG_KMS("PP_STATUS: 0x%08x PP_CONTROL: 0x%08x\n",
		I915_READ(pp_stat_reg), I915_READ(pp_ctrl_reg));

		if ((pp & POWER_TARGET_ON) == 0)
			drm_msleep(intel_dp->panel_power_cycle_delay);

		intel_runtime_pm_put(dev_priv);
	}
}

static void ironlake_panel_vdd_work(struct work_struct *__work)
{
	struct intel_dp *intel_dp = container_of(to_delayed_work(__work),
						 struct intel_dp, panel_vdd_work);
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	mutex_lock(&dev->mode_config.mutex);
	ironlake_panel_vdd_off_sync(intel_dp);
	mutex_unlock(&dev->mode_config.mutex);
}

void ironlake_edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
{
	if (!is_edp(intel_dp))
		return;

	WARN(!intel_dp->want_panel_vdd, "eDP VDD not forced on");

	intel_dp->want_panel_vdd = false;

	if (sync) {
		ironlake_panel_vdd_off_sync(intel_dp);
	} else {
		/*
		 * Queue the timer to fire a long
		 * time from now (relative to the power down delay)
		 * to keep the panel power up across a sequence of operations
		 */
		schedule_delayed_work(&intel_dp->panel_vdd_work,
				      msecs_to_jiffies(intel_dp->panel_power_cycle_delay * 5));
	}
}

void ironlake_edp_panel_on(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("Turn eDP power on\n");

	if (ironlake_edp_have_panel_power(intel_dp)) {
		DRM_DEBUG_KMS("eDP power already on\n");
		return;
	}

	ironlake_wait_panel_power_cycle(intel_dp);

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);
	pp = ironlake_get_pp_control(intel_dp);
	if (IS_GEN5(dev)) {
		/* ILK workaround: disable reset around power sequence */
		pp &= ~PANEL_POWER_RESET;
		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);
	}

	pp |= POWER_TARGET_ON;
	if (!IS_GEN5(dev))
		pp |= PANEL_POWER_RESET;

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	ironlake_wait_panel_on(intel_dp);

	if (IS_GEN5(dev)) {
		pp |= PANEL_POWER_RESET; /* restore panel reset bit */
		I915_WRITE(pp_ctrl_reg, pp);
		POSTING_READ(pp_ctrl_reg);
	}
}

void ironlake_edp_panel_off(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("Turn eDP power off\n");

	WARN(!intel_dp->want_panel_vdd, "Need VDD to turn off panel\n");

	pp = ironlake_get_pp_control(intel_dp);
	/* We need to switch off panel power _and_ force vdd, for otherwise some
	 * panels get very unhappy and cease to work. */
	pp &= ~(POWER_TARGET_ON | EDP_FORCE_VDD | PANEL_POWER_RESET | EDP_BLC_ENABLE);

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	intel_dp->want_panel_vdd = false;

	ironlake_wait_panel_off(intel_dp);

	/* We got a reference when we enabled the VDD. */
	intel_runtime_pm_put(dev_priv);
}

void ironlake_edp_backlight_on(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	DRM_DEBUG_KMS("\n");
	/*
	 * If we enable the backlight right away following a panel power
	 * on, we may see slight flicker as the panel syncs with the eDP
	 * link.  So delay a bit to make sure the image is solid before
	 * allowing it to appear.
	 */
	drm_msleep(intel_dp->backlight_on_delay);
	pp = ironlake_get_pp_control(intel_dp);
	pp |= EDP_BLC_ENABLE;

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);

	intel_panel_enable_backlight(intel_dp->attached_connector);
}

void ironlake_edp_backlight_off(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp;
	u32 pp_ctrl_reg;

	if (!is_edp(intel_dp))
		return;

	intel_panel_disable_backlight(intel_dp->attached_connector);

	DRM_DEBUG_KMS("\n");
	pp = ironlake_get_pp_control(intel_dp);
	pp &= ~EDP_BLC_ENABLE;

	pp_ctrl_reg = _pp_ctrl_reg(intel_dp);

	I915_WRITE(pp_ctrl_reg, pp);
	POSTING_READ(pp_ctrl_reg);
	drm_msleep(intel_dp->backlight_off_delay);
}

static void ironlake_edp_pll_on(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	assert_pipe_disabled(dev_priv,
			     to_intel_crtc(crtc)->pipe);

	DRM_DEBUG_KMS("\n");
	dpa_ctl = I915_READ(DP_A);
	WARN(dpa_ctl & DP_PLL_ENABLE, "dp pll on, should be off\n");
	WARN(dpa_ctl & DP_PORT_EN, "dp port still on, should be off\n");

	/* We don't adjust intel_dp->DP while tearing down the link, to
	 * facilitate link retraining (e.g. after hotplug). Hence clear all
	 * enable bits here to ensure that we don't enable too much. */
	intel_dp->DP &= ~(DP_PORT_EN | DP_AUDIO_OUTPUT_ENABLE);
	intel_dp->DP |= DP_PLL_ENABLE;
	I915_WRITE(DP_A, intel_dp->DP);
	POSTING_READ(DP_A);
	udelay(200);
}

static void ironlake_edp_pll_off(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_crtc *crtc = intel_dig_port->base.base.crtc;
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 dpa_ctl;

	assert_pipe_disabled(dev_priv,
			     to_intel_crtc(crtc)->pipe);

	dpa_ctl = I915_READ(DP_A);
	WARN((dpa_ctl & DP_PLL_ENABLE) == 0,
	     "dp pll off, should be on\n");
	WARN(dpa_ctl & DP_PORT_EN, "dp port still on, should be off\n");

	/* We can't rely on the value tracked for the DP register in
	 * intel_dp->DP because link_down must not change that (otherwise link
	 * re-training will fail. */
	dpa_ctl &= ~DP_PLL_ENABLE;
	I915_WRITE(DP_A, dpa_ctl);
	POSTING_READ(DP_A);
	udelay(200);
}

/* If the sink supports it, try to set the power state appropriately */
void intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode)
{
	int ret, i;

	/* Should have a valid DPCD by this point */
	if (intel_dp->dpcd[DP_DPCD_REV] < 0x11)
		return;

	if (mode != DRM_MODE_DPMS_ON) {
		ret = intel_dp_aux_native_write_1(intel_dp, DP_SET_POWER,
						  DP_SET_POWER_D3);
		if (ret != 1)
			DRM_DEBUG_DRIVER("failed to write sink power state\n");
	} else {
		/*
		 * When turning on, we need to retry for 1ms to give the sink
		 * time to wake up.
		 */
		for (i = 0; i < 3; i++) {
			ret = intel_dp_aux_native_write_1(intel_dp,
							  DP_SET_POWER,
							  DP_SET_POWER_D0);
			if (ret == 1)
				break;
			drm_msleep(1);
		}
	}
}

static bool intel_dp_get_hw_state(struct intel_encoder *encoder,
				  enum pipe *pipe)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 tmp = I915_READ(intel_dp->output_reg);

	if (!(tmp & DP_PORT_EN))
		return false;

	if (port == PORT_A && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
		*pipe = PORT_TO_PIPE_CPT(tmp);
	} else if (!HAS_PCH_CPT(dev) || port == PORT_A) {
		*pipe = PORT_TO_PIPE(tmp);
	} else {
		u32 trans_sel;
		u32 trans_dp;
		int i;

		switch (intel_dp->output_reg) {
		case PCH_DP_B:
			trans_sel = TRANS_DP_PORT_SEL_B;
			break;
		case PCH_DP_C:
			trans_sel = TRANS_DP_PORT_SEL_C;
			break;
		case PCH_DP_D:
			trans_sel = TRANS_DP_PORT_SEL_D;
			break;
		default:
			return true;
		}

		for_each_pipe(i) {
			trans_dp = I915_READ(TRANS_DP_CTL(i));
			if ((trans_dp & TRANS_DP_PORT_SEL_MASK) == trans_sel) {
				*pipe = i;
				return true;
			}
		}

		DRM_DEBUG_KMS("No pipe for dp port 0x%x found\n",
			      intel_dp->output_reg);
	}

	return true;
}

static void intel_dp_get_config(struct intel_encoder *encoder,
				struct intel_crtc_config *pipe_config)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	u32 tmp, flags = 0;
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	int dotclock;

	if ((port == PORT_A) || !HAS_PCH_CPT(dev)) {
		tmp = I915_READ(intel_dp->output_reg);
		if (tmp & DP_SYNC_HS_HIGH)
			flags |= DRM_MODE_FLAG_PHSYNC;
		else
			flags |= DRM_MODE_FLAG_NHSYNC;

		if (tmp & DP_SYNC_VS_HIGH)
			flags |= DRM_MODE_FLAG_PVSYNC;
		else
			flags |= DRM_MODE_FLAG_NVSYNC;
	} else {
		tmp = I915_READ(TRANS_DP_CTL(crtc->pipe));
		if (tmp & TRANS_DP_HSYNC_ACTIVE_HIGH)
			flags |= DRM_MODE_FLAG_PHSYNC;
		else
			flags |= DRM_MODE_FLAG_NHSYNC;

		if (tmp & TRANS_DP_VSYNC_ACTIVE_HIGH)
			flags |= DRM_MODE_FLAG_PVSYNC;
		else
			flags |= DRM_MODE_FLAG_NVSYNC;
	}

	pipe_config->adjusted_mode.flags |= flags;

	pipe_config->has_dp_encoder = true;

	intel_dp_get_m_n(crtc, pipe_config);

	if (port == PORT_A) {
		if ((I915_READ(DP_A) & DP_PLL_FREQ_MASK) == DP_PLL_FREQ_160MHZ)
			pipe_config->port_clock = 162000;
		else
			pipe_config->port_clock = 270000;
	}

	dotclock = intel_dotclock_calculate(pipe_config->port_clock,
					    &pipe_config->dp_m_n);

	if (HAS_PCH_SPLIT(dev_priv->dev) && port != PORT_A)
		ironlake_check_encoder_dotclock(pipe_config, dotclock);

	pipe_config->adjusted_mode.crtc_clock = dotclock;

	if (is_edp(intel_dp) && dev_priv->vbt.edp_bpp &&
	    pipe_config->pipe_bpp > dev_priv->vbt.edp_bpp) {
		/*
		 * This is a big fat ugly hack.
		 *
		 * Some machines in UEFI boot mode provide us a VBT that has 18
		 * bpp and 1.62 GHz link bandwidth for eDP, which for reasons
		 * unknown we fail to light up. Yet the same BIOS boots up with
		 * 24 bpp and 2.7 GHz link. Use the same bpp as the BIOS uses as
		 * max, not what it tells us to use.
		 *
		 * Note: This will still be broken if the eDP panel is not lit
		 * up by the BIOS, and thus we can't get the mode at module
		 * load.
		 */
		DRM_DEBUG_KMS("pipe has %d bpp for eDP panel, overriding BIOS-provided max %d bpp\n",
			      pipe_config->pipe_bpp, dev_priv->vbt.edp_bpp);
		dev_priv->vbt.edp_bpp = pipe_config->pipe_bpp;
	}
}

static bool is_edp_psr(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	return dev_priv->psr.sink_support;
}

static bool intel_edp_is_psr_enabled(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!HAS_PSR(dev))
		return false;

	return I915_READ(EDP_PSR_CTL(dev)) & EDP_PSR_ENABLE;
}

static void intel_edp_psr_write_vsc(struct intel_dp *intel_dp,
				    struct edp_vsc_psr *vsc_psr)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc = to_intel_crtc(dig_port->base.base.crtc);
	u32 ctl_reg = HSW_TVIDEO_DIP_CTL(crtc->config.cpu_transcoder);
	u32 data_reg = HSW_TVIDEO_DIP_VSC_DATA(crtc->config.cpu_transcoder);
	uint32_t *data = (uint32_t *) vsc_psr;
	unsigned int i;

	/* As per BSPec (Pipe Video Data Island Packet), we need to disable
	   the video DIP being updated before program video DIP data buffer
	   registers for DIP being updated. */
	I915_WRITE(ctl_reg, 0);
	POSTING_READ(ctl_reg);

	for (i = 0; i < VIDEO_DIP_VSC_DATA_SIZE; i += 4) {
		if (i < sizeof(struct edp_vsc_psr))
			I915_WRITE(data_reg + i, *data++);
		else
			I915_WRITE(data_reg + i, 0);
	}

	I915_WRITE(ctl_reg, VIDEO_DIP_ENABLE_VSC_HSW);
	POSTING_READ(ctl_reg);
}

static void intel_edp_psr_setup(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct edp_vsc_psr psr_vsc;

	if (intel_dp->psr_setup_done)
		return;

	/* Prepare VSC packet as per EDP 1.3 spec, Table 3.10 */
	memset(&psr_vsc, 0, sizeof(psr_vsc));
	psr_vsc.sdp_header.HB0 = 0;
	psr_vsc.sdp_header.HB1 = 0x7;
	psr_vsc.sdp_header.HB2 = 0x2;
	psr_vsc.sdp_header.HB3 = 0x8;
	intel_edp_psr_write_vsc(intel_dp, &psr_vsc);

	/* Avoid continuous PSR exit by masking memup and hpd */
	I915_WRITE(EDP_PSR_DEBUG_CTL(dev), EDP_PSR_DEBUG_MASK_MEMUP |
		   EDP_PSR_DEBUG_MASK_HPD | EDP_PSR_DEBUG_MASK_LPSP);

	intel_dp->psr_setup_done = true;
}

static void intel_edp_psr_enable_sink(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t aux_clock_divider = get_aux_clock_divider(intel_dp, 0);
	int precharge = 0x3;
	int msg_size = 5;       /* Header(4) + Message(1) */

	/* Enable PSR in sink */
	if (intel_dp->psr_dpcd[1] & DP_PSR_NO_TRAIN_ON_EXIT)
		intel_dp_aux_native_write_1(intel_dp, DP_PSR_EN_CFG,
					    DP_PSR_ENABLE &
					    ~DP_PSR_MAIN_LINK_ACTIVE);
	else
		intel_dp_aux_native_write_1(intel_dp, DP_PSR_EN_CFG,
					    DP_PSR_ENABLE |
					    DP_PSR_MAIN_LINK_ACTIVE);

	/* Setup AUX registers */
	I915_WRITE(EDP_PSR_AUX_DATA1(dev), EDP_PSR_DPCD_COMMAND);
	I915_WRITE(EDP_PSR_AUX_DATA2(dev), EDP_PSR_DPCD_NORMAL_OPERATION);
	I915_WRITE(EDP_PSR_AUX_CTL(dev),
		   DP_AUX_CH_CTL_TIME_OUT_400us |
		   (msg_size << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
		   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
		   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT));
}

static void intel_edp_psr_enable_source(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t max_sleep_time = 0x1f;
	uint32_t idle_frames = 1;
	uint32_t val = 0x0;
	const uint32_t link_entry_time = EDP_PSR_MIN_LINK_ENTRY_TIME_8_LINES;

	if (intel_dp->psr_dpcd[1] & DP_PSR_NO_TRAIN_ON_EXIT) {
		val |= EDP_PSR_LINK_STANDBY;
		val |= EDP_PSR_TP2_TP3_TIME_0us;
		val |= EDP_PSR_TP1_TIME_0us;
		val |= EDP_PSR_SKIP_AUX_EXIT;
	} else
		val |= EDP_PSR_LINK_DISABLE;

	I915_WRITE(EDP_PSR_CTL(dev), val |
		   (IS_BROADWELL(dev) ? 0 : link_entry_time) |
		   max_sleep_time << EDP_PSR_MAX_SLEEP_TIME_SHIFT |
		   idle_frames << EDP_PSR_IDLE_FRAME_SHIFT |
		   EDP_PSR_ENABLE);
}

static bool intel_edp_psr_match_conditions(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_crtc *crtc = dig_port->base.base.crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct drm_i915_gem_object *obj = to_intel_framebuffer(crtc->fb)->obj;
	struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;

	dev_priv->psr.source_ok = false;

	if (!HAS_PSR(dev)) {
		DRM_DEBUG_KMS("PSR not supported on this platform\n");
		return false;
	}

	if ((intel_encoder->type != INTEL_OUTPUT_EDP) ||
	    (dig_port->port != PORT_A)) {
		DRM_DEBUG_KMS("HSW ties PSR to DDI A (eDP)\n");
		return false;
	}

	if (!i915_enable_psr) {
		DRM_DEBUG_KMS("PSR disable by flag\n");
		return false;
	}

	crtc = dig_port->base.base.crtc;
	if (crtc == NULL) {
		DRM_DEBUG_KMS("crtc not active for PSR\n");
		return false;
	}

	intel_crtc = to_intel_crtc(crtc);
	if (!intel_crtc_active(crtc)) {
		DRM_DEBUG_KMS("crtc not active for PSR\n");
		return false;
	}

	obj = to_intel_framebuffer(crtc->fb)->obj;
	if (obj->tiling_mode != I915_TILING_X ||
	    obj->fence_reg == I915_FENCE_REG_NONE) {
		DRM_DEBUG_KMS("PSR condition failed: fb not tiled or fenced\n");
		return false;
	}

	if (I915_READ(SPRCTL(intel_crtc->pipe)) & SPRITE_ENABLE) {
		DRM_DEBUG_KMS("PSR condition failed: Sprite is Enabled\n");
		return false;
	}

	if (I915_READ(HSW_STEREO_3D_CTL(intel_crtc->config.cpu_transcoder)) &
	    S3D_ENABLE) {
		DRM_DEBUG_KMS("PSR condition failed: Stereo 3D is Enabled\n");
		return false;
	}

	if (intel_crtc->config.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE) {
		DRM_DEBUG_KMS("PSR condition failed: Interlaced is Enabled\n");
		return false;
	}

	dev_priv->psr.source_ok = true;
	return true;
}

static void intel_edp_psr_do_enable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (!intel_edp_psr_match_conditions(intel_dp) ||
	    intel_edp_is_psr_enabled(dev))
		return;

	/* Setup PSR once */
	intel_edp_psr_setup(intel_dp);

	/* Enable PSR on the panel */
	intel_edp_psr_enable_sink(intel_dp);

	/* Enable PSR on the host */
	intel_edp_psr_enable_source(intel_dp);
}

void intel_edp_psr_enable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

	if (intel_edp_psr_match_conditions(intel_dp) &&
	    !intel_edp_is_psr_enabled(dev))
		intel_edp_psr_do_enable(intel_dp);
}

void intel_edp_psr_disable(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (!intel_edp_is_psr_enabled(dev))
		return;

	I915_WRITE(EDP_PSR_CTL(dev),
		   I915_READ(EDP_PSR_CTL(dev)) & ~EDP_PSR_ENABLE);

	/* Wait till PSR is idle */
	if (_wait_for((I915_READ(EDP_PSR_STATUS_CTL(dev)) &
		       EDP_PSR_STATUS_STATE_MASK) == 0, 2000, 10))
		DRM_ERROR("Timed out waiting for PSR Idle State\n");
}

void intel_edp_psr_update(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	struct intel_dp *intel_dp = NULL;

	list_for_each_entry(encoder, &dev->mode_config.encoder_list, base.head)
		if (encoder->type == INTEL_OUTPUT_EDP) {
			intel_dp = enc_to_intel_dp(&encoder->base);

			if (!is_edp_psr(dev))
				return;

			if (!intel_edp_psr_match_conditions(intel_dp))
				intel_edp_psr_disable(intel_dp);
			else
				if (!intel_edp_is_psr_enabled(dev))
					intel_edp_psr_do_enable(intel_dp);
		}
}

static void intel_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;

	/* Make sure the panel is off before trying to change the mode. But also
	 * ensure that we have vdd while we switch off the panel. */
	ironlake_edp_panel_vdd_on(intel_dp);
	ironlake_edp_backlight_off(intel_dp);
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
	ironlake_edp_panel_off(intel_dp);

	/* cpu edp my only be disable _after_ the cpu pipe/plane is disabled. */
	if (!(port == PORT_A || IS_VALLEYVIEW(dev)))
		intel_dp_link_down(intel_dp);
}

static void intel_post_disable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	enum port port = dp_to_dig_port(intel_dp)->port;
	struct drm_device *dev = encoder->base.dev;

	if (port == PORT_A || IS_VALLEYVIEW(dev)) {
		intel_dp_link_down(intel_dp);
		if (!IS_VALLEYVIEW(dev))
			ironlake_edp_pll_off(intel_dp);
	}
}

static void intel_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t dp_reg = I915_READ(intel_dp->output_reg);

	if (WARN_ON(dp_reg & DP_PORT_EN))
		return;

	ironlake_edp_panel_vdd_on(intel_dp);
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
	intel_dp_start_link_train(intel_dp);
	ironlake_edp_panel_on(intel_dp);
	ironlake_edp_panel_vdd_off(intel_dp, true);
	intel_dp_complete_link_train(intel_dp);
	intel_dp_stop_link_train(intel_dp);
}

static void g4x_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);

	intel_enable_dp(encoder);
	ironlake_edp_backlight_on(intel_dp);
}

static void vlv_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);

	ironlake_edp_backlight_on(intel_dp);
}

static void g4x_pre_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);

	if (dport->port == PORT_A)
		ironlake_edp_pll_on(intel_dp);
}

static void vlv_pre_enable_dp(struct intel_encoder *encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;
	struct edp_power_seq power_seq;
	u32 val;

	mutex_lock(&dev_priv->dpio_lock);

	val = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(port));
	val = 0;
	if (pipe)
		val |= (1<<21);
	else
		val &= ~(1<<21);
	val |= 0x001000c4;
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW8(port), val);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW14(port), 0x00760018);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW23(port), 0x00400888);

	mutex_unlock(&dev_priv->dpio_lock);

	if (is_edp(intel_dp)) {
		/* init power sequencer on this pipe and port */
		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
							      &power_seq);
	}

	intel_enable_dp(encoder);

	vlv_wait_port_ready(dev_priv, dport);
}

static void vlv_dp_pre_pll_enable(struct intel_encoder *encoder)
{
	struct intel_digital_port *dport = enc_to_dig_port(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(encoder->base.crtc);
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;

	/* Program Tx lane resets to default */
	mutex_lock(&dev_priv->dpio_lock);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port),
			 DPIO_PCS_TX_LANE2_RESET |
			 DPIO_PCS_TX_LANE1_RESET);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port),
			 DPIO_PCS_CLK_CRI_RXEB_EIOS_EN |
			 DPIO_PCS_CLK_CRI_RXDIGFILTSG_EN |
			 (1<<DPIO_PCS_CLK_DATAWIDTH_SHIFT) |
				 DPIO_PCS_CLK_SOFT_RESET);

	/* Fix up inter-pair skew failure */
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW12(port), 0x00750f00);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW11(port), 0x00001500);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW14(port), 0x40400000);
	mutex_unlock(&dev_priv->dpio_lock);
}

/*
 * Native read with retry for link status and receiver capability reads for
 * cases where the sink may still be asleep.
 */
static bool
intel_dp_aux_native_read_retry(struct intel_dp *intel_dp, uint16_t address,
			       uint8_t *recv, int recv_bytes)
{
	int ret, i;

	/*
	 * Sinks are *supposed* to come up within 1ms from an off state,
	 * but we're also supposed to retry 3 times per the spec.
	 */
	for (i = 0; i < 3; i++) {
		ret = intel_dp_aux_native_read(intel_dp, address, recv,
					       recv_bytes);
		if (ret == recv_bytes)
			return true;
		drm_msleep(1);
	}

	return false;
}

/*
 * Fetch AUX CH registers 0x202 - 0x207 which contain
 * link status information
 */
static bool
intel_dp_get_link_status(struct intel_dp *intel_dp, uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	return intel_dp_aux_native_read_retry(intel_dp,
					      DP_LANE0_1_STATUS,
					      link_status,
					      DP_LINK_STATUS_SIZE);
}

/*
 * These are source-specific values; current Intel hardware supports
 * a maximum voltage of 800mV and a maximum pre-emphasis of 6dB
 */

static uint8_t
intel_dp_voltage_max(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	enum port port = dp_to_dig_port(intel_dp)->port;

	if (IS_VALLEYVIEW(dev) || IS_BROADWELL(dev))
		return DP_TRAIN_VOLTAGE_SWING_1200;
	else if (IS_GEN7(dev) && port == PORT_A)
		return DP_TRAIN_VOLTAGE_SWING_800;
	else if (HAS_PCH_CPT(dev) && port != PORT_A)
		return DP_TRAIN_VOLTAGE_SWING_1200;
	else
		return DP_TRAIN_VOLTAGE_SWING_800;
}

static uint8_t
intel_dp_pre_emphasis_max(struct intel_dp *intel_dp, uint8_t voltage_swing)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	enum port port = dp_to_dig_port(intel_dp)->port;

	if (IS_BROADWELL(dev)) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
		default:
			return DP_TRAIN_PRE_EMPHASIS_0;
		}
	} else if (IS_HASWELL(dev)) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_9_5;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
		default:
			return DP_TRAIN_PRE_EMPHASIS_0;
		}
	} else if (IS_VALLEYVIEW(dev)) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_9_5;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
		default:
			return DP_TRAIN_PRE_EMPHASIS_0;
		}
	} else if (IS_GEN7(dev) && port == PORT_A) {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_600:
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		default:
			return DP_TRAIN_PRE_EMPHASIS_0;
		}
	} else {
		switch (voltage_swing & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_600:
			return DP_TRAIN_PRE_EMPHASIS_6;
		case DP_TRAIN_VOLTAGE_SWING_800:
			return DP_TRAIN_PRE_EMPHASIS_3_5;
		case DP_TRAIN_VOLTAGE_SWING_1200:
		default:
			return DP_TRAIN_PRE_EMPHASIS_0;
		}
	}
}

static uint32_t intel_vlv_signal_levels(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *dport = dp_to_dig_port(intel_dp);
	struct intel_crtc *intel_crtc =
		to_intel_crtc(dport->base.base.crtc);
	unsigned long demph_reg_value, preemph_reg_value,
		uniqtranscale_reg_value;
	uint8_t train_set = intel_dp->train_set[0];
	enum dpio_channel port = vlv_dport_to_channel(dport);
	int pipe = intel_crtc->pipe;

	switch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {
	case DP_TRAIN_PRE_EMPHASIS_0:
		preemph_reg_value = 0x0004000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			demph_reg_value = 0x2B405555;
			uniqtranscale_reg_value = 0x552AB83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_600:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x5548B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_800:
			demph_reg_value = 0x2B245555;
			uniqtranscale_reg_value = 0x5560B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_1200:
			demph_reg_value = 0x2B405555;
			uniqtranscale_reg_value = 0x5598DA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPHASIS_3_5:
		preemph_reg_value = 0x0002000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x5552B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_600:
			demph_reg_value = 0x2B404848;
			uniqtranscale_reg_value = 0x5580B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_800:
			demph_reg_value = 0x2B404040;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPHASIS_6:
		preemph_reg_value = 0x0000000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			demph_reg_value = 0x2B305555;
			uniqtranscale_reg_value = 0x5570B83A;
			break;
		case DP_TRAIN_VOLTAGE_SWING_600:
			demph_reg_value = 0x2B2B4040;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	case DP_TRAIN_PRE_EMPHASIS_9_5:
		preemph_reg_value = 0x0006000;
		switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
		case DP_TRAIN_VOLTAGE_SWING_400:
			demph_reg_value = 0x1B405555;
			uniqtranscale_reg_value = 0x55ADDA3A;
			break;
		default:
			return 0;
		}
		break;
	default:
		return 0;
	}

	mutex_lock(&dev_priv->dpio_lock);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x00000000);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW4(port), demph_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW2(port),
			 uniqtranscale_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW3(port), 0x0C782040);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW11(port), 0x00030000);
	vlv_dpio_write(dev_priv, pipe, VLV_PCS_DW9(port), preemph_reg_value);
	vlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x80000000);
	mutex_unlock(&dev_priv->dpio_lock);

	return 0;
}

static void
intel_get_adjust_train(struct intel_dp *intel_dp,
		       const uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	uint8_t v = 0;
	uint8_t p = 0;
	int lane;
	uint8_t voltage_max;
	uint8_t preemph_max;

	for (lane = 0; lane < intel_dp->lane_count; lane++) {
		uint8_t this_v = drm_dp_get_adjust_request_voltage(link_status, lane);
		uint8_t this_p = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);

		if (this_v > v)
			v = this_v;
		if (this_p > p)
			p = this_p;
	}

	voltage_max = intel_dp_voltage_max(intel_dp);
	if (v >= voltage_max)
		v = voltage_max | DP_TRAIN_MAX_SWING_REACHED;

	preemph_max = intel_dp_pre_emphasis_max(intel_dp, v);
	if (p >= preemph_max)
		p = preemph_max | DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;

	for (lane = 0; lane < 4; lane++)
		intel_dp->train_set[lane] = v | p;
}

static uint32_t
intel_gen4_signal_levels(uint8_t train_set)
{
	uint32_t	signal_levels = 0;

	switch (train_set & DP_TRAIN_VOLTAGE_SWING_MASK) {
	case DP_TRAIN_VOLTAGE_SWING_400:
	default:
		signal_levels |= DP_VOLTAGE_0_4;
		break;
	case DP_TRAIN_VOLTAGE_SWING_600:
		signal_levels |= DP_VOLTAGE_0_6;
		break;
	case DP_TRAIN_VOLTAGE_SWING_800:
		signal_levels |= DP_VOLTAGE_0_8;
		break;
	case DP_TRAIN_VOLTAGE_SWING_1200:
		signal_levels |= DP_VOLTAGE_1_2;
		break;
	}
	switch (train_set & DP_TRAIN_PRE_EMPHASIS_MASK) {
	case DP_TRAIN_PRE_EMPHASIS_0:
	default:
		signal_levels |= DP_PRE_EMPHASIS_0;
		break;
	case DP_TRAIN_PRE_EMPHASIS_3_5:
		signal_levels |= DP_PRE_EMPHASIS_3_5;
		break;
	case DP_TRAIN_PRE_EMPHASIS_6:
		signal_levels |= DP_PRE_EMPHASIS_6;
		break;
	case DP_TRAIN_PRE_EMPHASIS_9_5:
		signal_levels |= DP_PRE_EMPHASIS_9_5;
		break;
	}
	return signal_levels;
}

/* Gen6's DP voltage swing and pre-emphasis control */
static uint32_t
intel_gen6_edp_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return EDP_LINK_TRAIN_400MV_3_5DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
		return EDP_LINK_TRAIN_400_600MV_6DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return EDP_LINK_TRAIN_600_800MV_3_5DB_SNB_B;
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
	case DP_TRAIN_VOLTAGE_SWING_1200 | DP_TRAIN_PRE_EMPHASIS_0:
		return EDP_LINK_TRAIN_800_1200MV_0DB_SNB_B;
	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return EDP_LINK_TRAIN_400_600MV_0DB_SNB_B;
	}
}

/* Gen7's DP voltage swing and pre-emphasis control */
static uint32_t
intel_gen7_edp_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
		return EDP_LINK_TRAIN_400MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return EDP_LINK_TRAIN_400MV_3_5DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
		return EDP_LINK_TRAIN_400MV_6DB_IVB;

	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return EDP_LINK_TRAIN_600MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return EDP_LINK_TRAIN_600MV_3_5DB_IVB;

	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
		return EDP_LINK_TRAIN_800MV_0DB_IVB;
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return EDP_LINK_TRAIN_800MV_3_5DB_IVB;

	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return EDP_LINK_TRAIN_500MV_0DB_IVB;
	}
}

/* Gen7.5's (HSW) DP voltage swing and pre-emphasis control */
static uint32_t
intel_hsw_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_400MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_400MV_3_5DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_400MV_6DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_9_5:
		return DDI_BUF_EMP_400MV_9_5DB_HSW;

	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_600MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_600MV_3_5DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_600MV_6DB_HSW;

	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_800MV_0DB_HSW;
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_800MV_3_5DB_HSW;
	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return DDI_BUF_EMP_400MV_0DB_HSW;
	}
}

static uint32_t
intel_bdw_signal_levels(uint8_t train_set)
{
	int signal_levels = train_set & (DP_TRAIN_VOLTAGE_SWING_MASK |
					 DP_TRAIN_PRE_EMPHASIS_MASK);
	switch (signal_levels) {
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_400MV_0DB_BDW;	/* Sel0 */
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_400MV_3_5DB_BDW;	/* Sel1 */
	case DP_TRAIN_VOLTAGE_SWING_400 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_400MV_6DB_BDW;	/* Sel2 */

	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_600MV_0DB_BDW;	/* Sel3 */
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_600MV_3_5DB_BDW;	/* Sel4 */
	case DP_TRAIN_VOLTAGE_SWING_600 | DP_TRAIN_PRE_EMPHASIS_6:
		return DDI_BUF_EMP_600MV_6DB_BDW;	/* Sel5 */

	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_800MV_0DB_BDW;	/* Sel6 */
	case DP_TRAIN_VOLTAGE_SWING_800 | DP_TRAIN_PRE_EMPHASIS_3_5:
		return DDI_BUF_EMP_800MV_3_5DB_BDW;	/* Sel7 */

	case DP_TRAIN_VOLTAGE_SWING_1200 | DP_TRAIN_PRE_EMPHASIS_0:
		return DDI_BUF_EMP_1200MV_0DB_BDW;	/* Sel8 */

	default:
		DRM_DEBUG_KMS("Unsupported voltage swing/pre-emphasis level:"
			      "0x%x\n", signal_levels);
		return DDI_BUF_EMP_400MV_0DB_BDW;	/* Sel0 */
	}
}

/* Properly updates "DP" with the correct signal levels. */
static void
intel_dp_set_signal_levels(struct intel_dp *intel_dp, uint32_t *DP)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	enum port port = intel_dig_port->port;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	uint32_t signal_levels, mask;
	uint8_t train_set = intel_dp->train_set[0];

	if (IS_BROADWELL(dev)) {
		signal_levels = intel_bdw_signal_levels(train_set);
		mask = DDI_BUF_EMP_MASK;
	} else if (IS_HASWELL(dev)) {
		signal_levels = intel_hsw_signal_levels(train_set);
		mask = DDI_BUF_EMP_MASK;
	} else if (IS_VALLEYVIEW(dev)) {
		signal_levels = intel_vlv_signal_levels(intel_dp);
		mask = 0;
	} else if (IS_GEN7(dev) && port == PORT_A) {
		signal_levels = intel_gen7_edp_signal_levels(train_set);
		mask = EDP_LINK_TRAIN_VOL_EMP_MASK_IVB;
	} else if (IS_GEN6(dev) && port == PORT_A) {
		signal_levels = intel_gen6_edp_signal_levels(train_set);
		mask = EDP_LINK_TRAIN_VOL_EMP_MASK_SNB;
	} else {
		signal_levels = intel_gen4_signal_levels(train_set);
		mask = DP_VOLTAGE_MASK | DP_PRE_EMPHASIS_MASK;
	}

	DRM_DEBUG_KMS("Using signal levels %08x\n", signal_levels);

	*DP = (*DP & ~mask) | signal_levels;
}

static bool
intel_dp_set_link_train(struct intel_dp *intel_dp,
			uint32_t *DP,
			uint8_t dp_train_pat)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	uint8_t buf[sizeof(intel_dp->train_set) + 1];
	int ret, len;

	if (HAS_DDI(dev)) {
		uint32_t temp = I915_READ(DP_TP_CTL(port));

		if (dp_train_pat & DP_LINK_SCRAMBLING_DISABLE)
			temp |= DP_TP_CTL_SCRAMBLE_DISABLE;
		else
			temp &= ~DP_TP_CTL_SCRAMBLE_DISABLE;

		temp &= ~DP_TP_CTL_LINK_TRAIN_MASK;
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			temp |= DP_TP_CTL_LINK_TRAIN_NORMAL;

			break;
		case DP_TRAINING_PATTERN_1:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT1;
			break;
		case DP_TRAINING_PATTERN_2:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT2;
			break;
		case DP_TRAINING_PATTERN_3:
			temp |= DP_TP_CTL_LINK_TRAIN_PAT3;
			break;
		}
		I915_WRITE(DP_TP_CTL(port), temp);

	} else if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || port != PORT_A)) {
		*DP &= ~DP_LINK_TRAIN_MASK_CPT;

		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF_CPT;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1_CPT;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			*DP |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		}

	} else {
		*DP &= ~DP_LINK_TRAIN_MASK;

		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			*DP |= DP_LINK_TRAIN_OFF;
			break;
		case DP_TRAINING_PATTERN_1:
			*DP |= DP_LINK_TRAIN_PAT_1;
			break;
		case DP_TRAINING_PATTERN_2:
			*DP |= DP_LINK_TRAIN_PAT_2;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			*DP |= DP_LINK_TRAIN_PAT_2;
			break;
		}
	}

	I915_WRITE(intel_dp->output_reg, *DP);
	POSTING_READ(intel_dp->output_reg);

	buf[0] = dp_train_pat;
	if ((dp_train_pat & DP_TRAINING_PATTERN_MASK) ==
	    DP_TRAINING_PATTERN_DISABLE) {
		/* don't write DP_TRAINING_LANEx_SET on disable */
		len = 1;
	} else {
		/* DP_TRAINING_LANEx_SET follow DP_TRAINING_PATTERN_SET */
		memcpy(buf + 1, intel_dp->train_set, intel_dp->lane_count);
		len = intel_dp->lane_count + 1;
	}

	ret = intel_dp_aux_native_write(intel_dp, DP_TRAINING_PATTERN_SET,
					buf, len);

	return ret == len;
}

static bool
intel_dp_reset_link_train(struct intel_dp *intel_dp, uint32_t *DP,
			uint8_t dp_train_pat)
{
	memset(intel_dp->train_set, 0, sizeof(intel_dp->train_set));
	intel_dp_set_signal_levels(intel_dp, DP);
	return intel_dp_set_link_train(intel_dp, DP, dp_train_pat);
}

static bool
intel_dp_update_link_train(struct intel_dp *intel_dp, uint32_t *DP,
			   const uint8_t link_status[DP_LINK_STATUS_SIZE])
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	intel_get_adjust_train(intel_dp, link_status);
	intel_dp_set_signal_levels(intel_dp, DP);

	I915_WRITE(intel_dp->output_reg, *DP);
	POSTING_READ(intel_dp->output_reg);

	ret = intel_dp_aux_native_write(intel_dp, DP_TRAINING_LANE0_SET,
					intel_dp->train_set,
					intel_dp->lane_count);

	return ret == intel_dp->lane_count;
}

static void intel_dp_set_idle_link_train(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	uint32_t val;

	if (!HAS_DDI(dev))
		return;

	val = I915_READ(DP_TP_CTL(port));
	val &= ~DP_TP_CTL_LINK_TRAIN_MASK;
	val |= DP_TP_CTL_LINK_TRAIN_IDLE;
	I915_WRITE(DP_TP_CTL(port), val);

	/*
	 * On PORT_A we can have only eDP in SST mode. There the only reason
	 * we need to set idle transmission mode is to work around a HW issue
	 * where we enable the pipe while not in idle link-training mode.
	 * In this case there is requirement to wait for a minimum number of
	 * idle patterns to be sent.
	 */
	if (port == PORT_A)
		return;

	if (wait_for((I915_READ(DP_TP_STATUS(port)) & DP_TP_STATUS_IDLE_DONE),
		     1))
		DRM_ERROR("Timed out waiting for DP idle patterns\n");
}

/* Enable corresponding port and start training pattern 1 */
void
intel_dp_start_link_train(struct intel_dp *intel_dp)
{
	struct drm_encoder *encoder = &dp_to_dig_port(intel_dp)->base.base;
	struct drm_device *dev = encoder->dev;
	int i;
	uint8_t voltage;
	int voltage_tries, loop_tries;
	uint32_t DP = intel_dp->DP;
	uint8_t link_config[2];

	if (HAS_DDI(dev))
		intel_ddi_prepare_link_retrain(encoder);

	/* Write the link configuration data */
	link_config[0] = intel_dp->link_bw;
	link_config[1] = intel_dp->lane_count;
	if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
		link_config[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
	intel_dp_aux_native_write(intel_dp, DP_LINK_BW_SET, link_config, 2);

	link_config[0] = 0;
	link_config[1] = DP_SET_ANSI_8B10B;
	intel_dp_aux_native_write(intel_dp, DP_DOWNSPREAD_CTRL, link_config, 2);

	DP |= DP_PORT_EN;

	/* clock recovery */
	if (!intel_dp_reset_link_train(intel_dp, &DP,
				       DP_TRAINING_PATTERN_1 |
				       DP_LINK_SCRAMBLING_DISABLE)) {
		DRM_ERROR("failed to enable link training\n");
		return;
	}

	voltage = 0xff;
	voltage_tries = 0;
	loop_tries = 0;
	for (;;) {
		uint8_t link_status[DP_LINK_STATUS_SIZE];

		drm_dp_link_train_clock_recovery_delay(intel_dp->dpcd);
		if (!intel_dp_get_link_status(intel_dp, link_status)) {
			DRM_ERROR("failed to get link status\n");
			break;
		}

		if (drm_dp_clock_recovery_ok(link_status, intel_dp->lane_count)) {
			DRM_DEBUG_KMS("clock recovery OK\n");
			break;
		}

		/* Check to see if we've tried the max voltage */
		for (i = 0; i < intel_dp->lane_count; i++)
			if ((intel_dp->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)
				break;
		if (i == intel_dp->lane_count) {
			++loop_tries;
			if (loop_tries == 5) {
				DRM_ERROR("too many full retries, give up\n");
				break;
			}
			intel_dp_reset_link_train(intel_dp, &DP,
						  DP_TRAINING_PATTERN_1 |
						  DP_LINK_SCRAMBLING_DISABLE);
			voltage_tries = 0;
			continue;
		}

		/* Check to see if we've tried the same voltage 5 times */
		if ((intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {
			++voltage_tries;
			if (voltage_tries == 5) {
				DRM_ERROR("too many voltage retries, give up\n");
				break;
			}
		} else
			voltage_tries = 0;
		voltage = intel_dp->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;

		/* Update training set as requested by target */
		if (!intel_dp_update_link_train(intel_dp, &DP, link_status)) {
			DRM_ERROR("failed to update link training\n");
			break;
		}
	}

	intel_dp->DP = DP;
}

void
intel_dp_complete_link_train(struct intel_dp *intel_dp)
{
	bool channel_eq = false;
	int tries, cr_tries;
	uint32_t DP = intel_dp->DP;
	uint32_t training_pattern = DP_TRAINING_PATTERN_2;

	/* Training Pattern 3 for HBR2 ot 1.2 devices that support it*/
	if (intel_dp->link_bw == DP_LINK_BW_5_4 || intel_dp->use_tps3)
		training_pattern = DP_TRAINING_PATTERN_3;

	/* channel equalization */
	if (!intel_dp_set_link_train(intel_dp, &DP,
				     training_pattern |
				     DP_LINK_SCRAMBLING_DISABLE)) {
		DRM_ERROR("failed to start channel equalization\n");
		return;
	}

	tries = 0;
	cr_tries = 0;
	channel_eq = false;
	for (;;) {
		uint8_t link_status[DP_LINK_STATUS_SIZE];

		if (cr_tries > 5) {
			DRM_ERROR("failed to train DP, aborting\n");
			break;
		}

		drm_dp_link_train_channel_eq_delay(intel_dp->dpcd);
		if (!intel_dp_get_link_status(intel_dp, link_status)) {
			DRM_ERROR("failed to get link status\n");
			break;
		}

		/* Make sure clock is still ok */
		if (!drm_dp_clock_recovery_ok(link_status, intel_dp->lane_count)) {
			intel_dp_start_link_train(intel_dp);
			intel_dp_set_link_train(intel_dp, &DP,
						training_pattern |
						DP_LINK_SCRAMBLING_DISABLE);
			cr_tries++;
			continue;
		}

		if (drm_dp_channel_eq_ok(link_status, intel_dp->lane_count)) {
			channel_eq = true;
			break;
		}

		/* Try 5 times, then try clock recovery if that fails */
		if (tries > 5) {
			intel_dp_link_down(intel_dp);
			intel_dp_start_link_train(intel_dp);
			intel_dp_set_link_train(intel_dp, &DP,
						training_pattern |
						DP_LINK_SCRAMBLING_DISABLE);
			tries = 0;
			cr_tries++;
			continue;
		}

		/* Update training set as requested by target */
		if (!intel_dp_update_link_train(intel_dp, &DP, link_status)) {
			DRM_ERROR("failed to update link training\n");
			break;
		}
		++tries;
	}

	intel_dp_set_idle_link_train(intel_dp);

	intel_dp->DP = DP;

	if (channel_eq)
		DRM_DEBUG_KMS("Channel EQ done. DP Training successful\n");

}

void intel_dp_stop_link_train(struct intel_dp *intel_dp)
{
	intel_dp_set_link_train(intel_dp, &intel_dp->DP,
				DP_TRAINING_PATTERN_DISABLE);
}

static void
intel_dp_link_down(struct intel_dp *intel_dp)
{
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	enum port port = intel_dig_port->port;
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc =
		to_intel_crtc(intel_dig_port->base.base.crtc);
	uint32_t DP = intel_dp->DP;

	/*
	 * DDI code has a strict mode set sequence and we should try to respect
	 * it, otherwise we might hang the machine in many different ways. So we
	 * really should be disabling the port only on a complete crtc_disable
	 * sequence. This function is just called under two conditions on DDI
	 * code:
	 * - Link train failed while doing crtc_enable, and on this case we
	 *   really should respect the mode set sequence and wait for a
	 *   crtc_disable.
	 * - Someone turned the monitor off and intel_dp_check_link_status
	 *   called us. We don't need to disable the whole port on this case, so
	 *   when someone turns the monitor on again,
	 *   intel_ddi_prepare_link_retrain will take care of redoing the link
	 *   train.
	 */
	if (HAS_DDI(dev))
		return;

	if (WARN_ON((I915_READ(intel_dp->output_reg) & DP_PORT_EN) == 0))
		return;

	DRM_DEBUG_KMS("\n");

	if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || port != PORT_A)) {
		DP &= ~DP_LINK_TRAIN_MASK_CPT;
		I915_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE_CPT);
	} else {
		DP &= ~DP_LINK_TRAIN_MASK;
		I915_WRITE(intel_dp->output_reg, DP | DP_LINK_TRAIN_PAT_IDLE);
	}
	POSTING_READ(intel_dp->output_reg);

	/* We don't really know why we're doing this */
	intel_wait_for_vblank(dev, intel_crtc->pipe);

	if (HAS_PCH_IBX(dev) &&
	    I915_READ(intel_dp->output_reg) & DP_PIPEB_SELECT) {
		struct drm_crtc *crtc = intel_dig_port->base.base.crtc;

		/* Hardware workaround: leaving our transcoder select
		 * set to transcoder B while it's off will prevent the
		 * corresponding HDMI output on transcoder A.
		 *
		 * Combine this with another hardware workaround:
		 * transcoder select bit can only be cleared while the
		 * port is enabled.
		 */
		DP &= ~DP_PIPEB_SELECT;
		I915_WRITE(intel_dp->output_reg, DP);

		/* Changes to enable or select take place the vblank
		 * after being written.
		 */
		if (WARN_ON(crtc == NULL)) {
			/* We should never try to disable a port without a crtc
			 * attached. For paranoia keep the code around for a
			 * bit. */
			POSTING_READ(intel_dp->output_reg);
			drm_msleep(50);
		} else
			intel_wait_for_vblank(dev, intel_crtc->pipe);
	}

	DP &= ~DP_AUDIO_OUTPUT_ENABLE;
	I915_WRITE(intel_dp->output_reg, DP & ~DP_PORT_EN);
	POSTING_READ(intel_dp->output_reg);
	drm_msleep(intel_dp->panel_power_down_delay);
}

static bool
intel_dp_get_dpcd(struct intel_dp *intel_dp)
{
	struct intel_digital_port *dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

#ifdef notyet
	char dpcd_hex_dump[sizeof(intel_dp->dpcd) * 3];
#endif

	if (intel_dp_aux_native_read_retry(intel_dp, 0x000, intel_dp->dpcd,
					   sizeof(intel_dp->dpcd)) == 0)
		return false; /* aux transfer failed */

#ifdef notyet
	hex_dump_to_buffer(intel_dp->dpcd, sizeof(intel_dp->dpcd),
			   32, 1, dpcd_hex_dump, sizeof(dpcd_hex_dump), false);
	DRM_DEBUG_KMS("DPCD: %s\n", dpcd_hex_dump);
#endif

	if (intel_dp->dpcd[DP_DPCD_REV] == 0)
		return false; /* DPCD not present */

	/* Check if the panel supports PSR */
	memset(intel_dp->psr_dpcd, 0, sizeof(intel_dp->psr_dpcd));
	if (is_edp(intel_dp)) {
		intel_dp_aux_native_read_retry(intel_dp, DP_PSR_SUPPORT,
					       intel_dp->psr_dpcd,
					       sizeof(intel_dp->psr_dpcd));
		if (intel_dp->psr_dpcd[0] & DP_PSR_IS_SUPPORTED) {
			dev_priv->psr.sink_support = true;
			DRM_DEBUG_KMS("Detected EDP PSR Panel.\n");
		}
	}

	/* Training Pattern 3 support, both source and sink */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x12 &&
	    intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_TPS3_SUPPORTED &&
	    (IS_HASWELL(dev) || INTEL_INFO(dev)->gen >= 8)) {
		intel_dp->use_tps3 = true;
		DRM_DEBUG_KMS("Displayport TPS3 supported\n");
	} else
		intel_dp->use_tps3 = false;

	if (!(intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
	      DP_DWN_STRM_PORT_PRESENT))
		return true; /* native DP sink */

	if (intel_dp->dpcd[DP_DPCD_REV] == 0x10)
		return true; /* no per-port downstream info */

	if (intel_dp_aux_native_read_retry(intel_dp, DP_DOWNSTREAM_PORT_0,
					   intel_dp->downstream_ports,
					   DP_MAX_DOWNSTREAM_PORTS) == 0)
		return false; /* downstream port status fetch failed */

	return true;
}

static void
intel_dp_probe_oui(struct intel_dp *intel_dp)
{
	u8 buf[3];

	if (!(intel_dp->dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))
		return;

	ironlake_edp_panel_vdd_on(intel_dp);

	if (intel_dp_aux_native_read_retry(intel_dp, DP_SINK_OUI, buf, 3))
		DRM_DEBUG_KMS("Sink OUI: %02hx%02hx%02hx\n",
			      buf[0], buf[1], buf[2]);

	if (intel_dp_aux_native_read_retry(intel_dp, DP_BRANCH_OUI, buf, 3))
		DRM_DEBUG_KMS("Branch OUI: %02hx%02hx%02hx\n",
			      buf[0], buf[1], buf[2]);

	ironlake_edp_panel_vdd_off(intel_dp, false);
}

static bool
intel_dp_get_sink_irq(struct intel_dp *intel_dp, u8 *sink_irq_vector)
{
	int ret;

	ret = intel_dp_aux_native_read_retry(intel_dp,
					     DP_DEVICE_SERVICE_IRQ_VECTOR,
					     sink_irq_vector, 1);
	if (!ret)
		return false;

	return true;
}

static void
intel_dp_handle_test_request(struct intel_dp *intel_dp)
{
	/* NAK by default */
	intel_dp_aux_native_write_1(intel_dp, DP_TEST_RESPONSE, DP_TEST_NAK);
}

/*
 * According to DP spec
 * 5.1.2:
 *  1. Read DPCD
 *  2. Configure link according to Receiver Capabilities
 *  3. Use Link Training from 2.5.3.3 and 3.5.1.3
 *  4. Check link status on receipt of hot-plug interrupt
 */

void
intel_dp_check_link_status(struct intel_dp *intel_dp)
{
	struct intel_encoder *intel_encoder = &dp_to_dig_port(intel_dp)->base;
	u8 sink_irq_vector;
	u8 link_status[DP_LINK_STATUS_SIZE];

	if (!intel_encoder->connectors_active)
		return;

	if (WARN_ON(!intel_encoder->base.crtc))
		return;

	/* Try to read receiver status if the link appears to be up */
	if (!intel_dp_get_link_status(intel_dp, link_status)) {
		return;
	}

	/* Now read the DPCD to see if it's actually running */
	if (!intel_dp_get_dpcd(intel_dp)) {
		return;
	}

	/* Try to read the source of the interrupt */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    intel_dp_get_sink_irq(intel_dp, &sink_irq_vector)) {
		/* Clear interrupt source */
		intel_dp_aux_native_write_1(intel_dp,
					    DP_DEVICE_SERVICE_IRQ_VECTOR,
					    sink_irq_vector);

		if (sink_irq_vector & DP_AUTOMATED_TEST_REQUEST)
			intel_dp_handle_test_request(intel_dp);
		if (sink_irq_vector & (DP_CP_IRQ | DP_SINK_SPECIFIC_IRQ))
			DRM_DEBUG_DRIVER("CP or sink specific irq unhandled\n");
	}

	if (!drm_dp_channel_eq_ok(link_status, intel_dp->lane_count)) {
		DRM_DEBUG_KMS("%s: channel EQ not ok, retraining\n",
			      drm_get_encoder_name(&intel_encoder->base));
		intel_dp_start_link_train(intel_dp);
		intel_dp_complete_link_train(intel_dp);
		intel_dp_stop_link_train(intel_dp);
	}
}

/* XXX this is probably wrong for multiple downstream ports */
static enum drm_connector_status
intel_dp_detect_dpcd(struct intel_dp *intel_dp)
{
	uint8_t *dpcd = intel_dp->dpcd;
	uint8_t type;

	if (!intel_dp_get_dpcd(intel_dp))
		return connector_status_disconnected;

	/* if there's no downstream port, we're done */
	if (!(dpcd[DP_DOWNSTREAMPORT_PRESENT] & DP_DWN_STRM_PORT_PRESENT))
		return connector_status_connected;

	/* If we're HPD-aware, SINK_COUNT changes dynamically */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    intel_dp->downstream_ports[0] & DP_DS_PORT_HPD) {
		uint8_t reg;
		if (!intel_dp_aux_native_read_retry(intel_dp, DP_SINK_COUNT,
						    &reg, 1))
			return connector_status_unknown;
		return DP_GET_SINK_COUNT(reg) ? connector_status_connected
					      : connector_status_disconnected;
	}

	/* If no HPD, poke DDC gently */
	if (drm_probe_ddc(&intel_dp->adapter))
		return connector_status_connected;

	/* Well we tried, say unknown for unreliable port types */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11) {
		type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
		if (type == DP_DS_PORT_TYPE_VGA ||
		    type == DP_DS_PORT_TYPE_NON_EDID)
			return connector_status_unknown;
	} else {
		type = intel_dp->dpcd[DP_DOWNSTREAMPORT_PRESENT] &
			DP_DWN_STRM_PORT_TYPE_MASK;
		if (type == DP_DWN_STRM_PORT_TYPE_ANALOG ||
		    type == DP_DWN_STRM_PORT_TYPE_OTHER)
			return connector_status_unknown;
	}

	/* Anything else is out of spec, warn and ignore */
	DRM_DEBUG_KMS("Broken DP branch device, ignoring\n");
	return connector_status_disconnected;
}

static enum drm_connector_status
ironlake_dp_detect(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	enum drm_connector_status status;

	/* Can't disconnect eDP, but you can close the lid... */
	if (is_edp(intel_dp)) {
		status = intel_panel_detect(dev);
		if (status == connector_status_unknown)
			status = connector_status_connected;
		return status;
	}

	if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
		return connector_status_disconnected;

	return intel_dp_detect_dpcd(intel_dp);
}

static enum drm_connector_status
g4x_dp_detect(struct intel_dp *intel_dp)
{
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	uint32_t bit;

	/* Can't disconnect eDP, but you can close the lid... */
	if (is_edp(intel_dp)) {
		enum drm_connector_status status;

		status = intel_panel_detect(dev);
		if (status == connector_status_unknown)
			status = connector_status_connected;
		return status;
	}

	if (IS_VALLEYVIEW(dev)) {
		switch (intel_dig_port->port) {
		case PORT_B:
			bit = PORTB_HOTPLUG_LIVE_STATUS_VLV;
			break;
		case PORT_C:
			bit = PORTC_HOTPLUG_LIVE_STATUS_VLV;
			break;
		case PORT_D:
			bit = PORTD_HOTPLUG_LIVE_STATUS_VLV;
			break;
		default:
			return connector_status_unknown;
		}
	} else {
		switch (intel_dig_port->port) {
		case PORT_B:
			bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
			break;
		case PORT_C:
			bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
			break;
		case PORT_D:
			bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
			break;
		default:
			return connector_status_unknown;
		}
	}

	if ((I915_READ(PORT_HOTPLUG_STAT) & bit) == 0)
		return connector_status_disconnected;

	return intel_dp_detect_dpcd(intel_dp);
}

static struct edid *
intel_dp_get_edid(struct drm_connector *connector, struct i2c_adapter *adapter)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	/* use cached edid if we have one */
	if (intel_connector->edid) {
		/* invalid edid */
		if (IS_ERR(intel_connector->edid))
			return NULL;

		return drm_edid_duplicate(intel_connector->edid);
	}

	return drm_get_edid(connector, adapter);
}

static int
intel_dp_get_edid_modes(struct drm_connector *connector, struct i2c_adapter *adapter)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	/* use cached edid if we have one */
	if (intel_connector->edid) {
		/* invalid edid */
		if (IS_ERR(intel_connector->edid))
			return 0;

		return intel_connector_update_modes(connector,
						    intel_connector->edid);
	}

	return intel_ddc_get_modes(connector, adapter);
}

static enum drm_connector_status
intel_dp_detect(struct drm_connector *connector, bool force)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = connector->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum drm_connector_status status;
	struct edid *edid = NULL;

	intel_runtime_pm_get(dev_priv);

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.id, drm_get_connector_name(connector));

	intel_dp->has_audio = false;

	if (HAS_PCH_SPLIT(dev))
		status = ironlake_dp_detect(intel_dp);
	else
		status = g4x_dp_detect(intel_dp);

	if (status != connector_status_connected)
		goto out;

	intel_dp_probe_oui(intel_dp);

	if (intel_dp->force_audio != HDMI_AUDIO_AUTO) {
		intel_dp->has_audio = (intel_dp->force_audio == HDMI_AUDIO_ON);
	} else {
		edid = intel_dp_get_edid(connector, &intel_dp->adapter);
		if (edid) {
			intel_dp->has_audio = drm_detect_monitor_audio(edid);
			kfree(edid);
		}
	}

	if (intel_encoder->type != INTEL_OUTPUT_EDP)
		intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
	status = connector_status_connected;

out:
	intel_runtime_pm_put(dev_priv);
	return status;
}

static int intel_dp_get_modes(struct drm_connector *connector)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct drm_device *dev = connector->dev;
	int ret;

	/* We should parse the EDID data and find out if it has an audio sink
	 */

	ret = intel_dp_get_edid_modes(connector, &intel_dp->adapter);
	if (ret)
		return ret;

	/* if eDP has no EDID, fall back to fixed mode */
	if (is_edp(intel_dp) && intel_connector->panel.fixed_mode) {
		struct drm_display_mode *mode;
		mode = drm_mode_duplicate(dev,
					  intel_connector->panel.fixed_mode);
		if (mode) {
			drm_mode_probed_add(connector, mode);
			return 1;
		}
	}
	return 0;
}

static bool
intel_dp_detect_audio(struct drm_connector *connector)
{
	struct intel_dp *intel_dp = intel_attached_dp(connector);
	struct edid *edid;
	bool has_audio = false;

	edid = intel_dp_get_edid(connector, &intel_dp->adapter);
	if (edid) {
		has_audio = drm_detect_monitor_audio(edid);
		kfree(edid);
	}

	return has_audio;
}

static int
intel_dp_set_property(struct drm_connector *connector,
		      struct drm_property *property,
		      uint64_t val)
{
	struct drm_i915_private *dev_priv = connector->dev->dev_private;
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct intel_encoder *intel_encoder = intel_attached_encoder(connector);
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
	int ret;

	ret = drm_object_property_set_value(&connector->base, property, val);
	if (ret)
		return ret;

	if (property == dev_priv->force_audio_property) {
		int i = val;
		bool has_audio;

		if (i == intel_dp->force_audio)
			return 0;

		intel_dp->force_audio = i;

		if (i == HDMI_AUDIO_AUTO)
			has_audio = intel_dp_detect_audio(connector);
		else
			has_audio = (i == HDMI_AUDIO_ON);

		if (has_audio == intel_dp->has_audio)
			return 0;

		intel_dp->has_audio = has_audio;
		goto done;
	}

	if (property == dev_priv->broadcast_rgb_property) {
		bool old_auto = intel_dp->color_range_auto;
		uint32_t old_range = intel_dp->color_range;

		switch (val) {
		case INTEL_BROADCAST_RGB_AUTO:
			intel_dp->color_range_auto = true;
			break;
		case INTEL_BROADCAST_RGB_FULL:
			intel_dp->color_range_auto = false;
			intel_dp->color_range = 0;
			break;
		case INTEL_BROADCAST_RGB_LIMITED:
			intel_dp->color_range_auto = false;
			intel_dp->color_range = DP_COLOR_RANGE_16_235;
			break;
		default:
			return -EINVAL;
		}

		if (old_auto == intel_dp->color_range_auto &&
		    old_range == intel_dp->color_range)
			return 0;

		goto done;
	}

	if (is_edp(intel_dp) &&
	    property == connector->dev->mode_config.scaling_mode_property) {
		if (val == DRM_MODE_SCALE_NONE) {
			DRM_DEBUG_KMS("no scaling not supported\n");
			return -EINVAL;
		}

		if (intel_connector->panel.fitting_mode == val) {
			/* the eDP scaling property is not changed */
			return 0;
		}
		intel_connector->panel.fitting_mode = val;

		goto done;
	}

	return -EINVAL;

done:
	if (intel_encoder->base.crtc)
		intel_crtc_restore_mode(intel_encoder->base.crtc);

	return 0;
}

static void
intel_dp_connector_destroy(struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	if (!IS_ERR_OR_NULL(intel_connector->edid))
		kfree(intel_connector->edid);

	/* Can't call is_edp() since the encoder may have been destroyed
	 * already. */
	if (connector->connector_type == DRM_MODE_CONNECTOR_eDP)
		intel_panel_fini(&intel_connector->panel);

	drm_connector_cleanup(connector);
	kfree(connector);
}

void intel_dp_encoder_destroy(struct drm_encoder *encoder)
{
	struct intel_digital_port *intel_dig_port = enc_to_dig_port(encoder);
	struct intel_dp *intel_dp = &intel_dig_port->dp;
	struct drm_device *dev = intel_dp_to_dev(intel_dp);

#ifdef notyet
	i2c_del_adapter(&intel_dp->adapter);
#endif
	drm_encoder_cleanup(encoder);
	if (is_edp(intel_dp)) {
		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
		mutex_lock(&dev->mode_config.mutex);
		ironlake_panel_vdd_off_sync(intel_dp);
		mutex_unlock(&dev->mode_config.mutex);
	}
	kfree(intel_dig_port);
}

static const struct drm_connector_funcs intel_dp_connector_funcs = {
	.dpms = intel_connector_dpms,
	.detect = intel_dp_detect,
	.fill_modes = drm_helper_probe_single_connector_modes,
	.set_property = intel_dp_set_property,
	.destroy = intel_dp_connector_destroy,
};

static const struct drm_connector_helper_funcs intel_dp_connector_helper_funcs = {
	.get_modes = intel_dp_get_modes,
	.mode_valid = intel_dp_mode_valid,
	.best_encoder = intel_best_encoder,
};

static const struct drm_encoder_funcs intel_dp_enc_funcs = {
	.destroy = intel_dp_encoder_destroy,
};

static void
intel_dp_hot_plug(struct intel_encoder *intel_encoder)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);

	intel_dp_check_link_status(intel_dp);
}

/* Return which DP Port should be selected for Transcoder DP control */
int
intel_trans_dp_port_sel(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;
	struct intel_dp *intel_dp;

	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		intel_dp = enc_to_intel_dp(&intel_encoder->base);

		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
		    intel_encoder->type == INTEL_OUTPUT_EDP)
			return intel_dp->output_reg;
	}

	return -1;
}

/* check the VBT to see whether the eDP is on DP-D port */
bool intel_dp_is_edp(struct drm_device *dev, enum port port)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	union child_device_config *p_child;
	int i;
	static const short port_mapping[] = {
		[PORT_B] = PORT_IDPB,
		[PORT_C] = PORT_IDPC,
		[PORT_D] = PORT_IDPD,
	};

	if (port == PORT_A)
		return true;

	if (!dev_priv->vbt.child_dev_num)
		return false;

	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
		p_child = dev_priv->vbt.child_dev + i;

		if (p_child->common.dvo_port == port_mapping[port] &&
		    (p_child->common.device_type & DEVICE_TYPE_eDP_BITS) ==
		    (DEVICE_TYPE_eDP & DEVICE_TYPE_eDP_BITS))
			return true;
	}
	return false;
}

static void
intel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);

	intel_attach_force_audio_property(connector);
	intel_attach_broadcast_rgb_property(connector);
	intel_dp->color_range_auto = true;

	if (is_edp(intel_dp)) {
		drm_mode_create_scaling_mode_property(connector->dev);
		drm_object_attach_property(
			&connector->base,
			connector->dev->mode_config.scaling_mode_property,
			DRM_MODE_SCALE_ASPECT);
		intel_connector->panel.fitting_mode = DRM_MODE_SCALE_ASPECT;
	}
}

static void
intel_dp_init_panel_power_sequencer(struct drm_device *dev,
				    struct intel_dp *intel_dp,
				    struct edp_power_seq *out)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct edp_power_seq cur, vbt, spec, final;
	u32 pp_on, pp_off, pp_div, pp;
	int pp_ctrl_reg, pp_on_reg, pp_off_reg, pp_div_reg;

	if (HAS_PCH_SPLIT(dev)) {
		pp_ctrl_reg = PCH_PP_CONTROL;
		pp_on_reg = PCH_PP_ON_DELAYS;
		pp_off_reg = PCH_PP_OFF_DELAYS;
		pp_div_reg = PCH_PP_DIVISOR;
	} else {
		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);

		pp_ctrl_reg = VLV_PIPE_PP_CONTROL(pipe);
		pp_on_reg = VLV_PIPE_PP_ON_DELAYS(pipe);
		pp_off_reg = VLV_PIPE_PP_OFF_DELAYS(pipe);
		pp_div_reg = VLV_PIPE_PP_DIVISOR(pipe);
	}

	/* Workaround: Need to write PP_CONTROL with the unlock key as
	 * the very first thing. */
	pp = ironlake_get_pp_control(intel_dp);
	I915_WRITE(pp_ctrl_reg, pp);

	pp_on = I915_READ(pp_on_reg);
	pp_off = I915_READ(pp_off_reg);
	pp_div = I915_READ(pp_div_reg);

	/* Pull timing values out of registers */
	cur.t1_t3 = (pp_on & PANEL_POWER_UP_DELAY_MASK) >>
		PANEL_POWER_UP_DELAY_SHIFT;

	cur.t8 = (pp_on & PANEL_LIGHT_ON_DELAY_MASK) >>
		PANEL_LIGHT_ON_DELAY_SHIFT;

	cur.t9 = (pp_off & PANEL_LIGHT_OFF_DELAY_MASK) >>
		PANEL_LIGHT_OFF_DELAY_SHIFT;

	cur.t10 = (pp_off & PANEL_POWER_DOWN_DELAY_MASK) >>
		PANEL_POWER_DOWN_DELAY_SHIFT;

	cur.t11_t12 = ((pp_div & PANEL_POWER_CYCLE_DELAY_MASK) >>
		       PANEL_POWER_CYCLE_DELAY_SHIFT) * 1000;

	DRM_DEBUG_KMS("cur t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
		      cur.t1_t3, cur.t8, cur.t9, cur.t10, cur.t11_t12);

	vbt = dev_priv->vbt.edp_pps;

	/* Upper limits from eDP 1.3 spec. Note that we use the clunky units of
	 * our hw here, which are all in 100usec. */
	spec.t1_t3 = 210 * 10;
	spec.t8 = 50 * 10; /* no limit for t8, use t7 instead */
	spec.t9 = 50 * 10; /* no limit for t9, make it symmetric with t8 */
	spec.t10 = 500 * 10;
	/* This one is special and actually in units of 100ms, but zero
	 * based in the hw (so we need to add 100 ms). But the sw vbt
	 * table multiplies it with 1000 to make it in units of 100usec,
	 * too. */
	spec.t11_t12 = (510 + 100) * 10;

	DRM_DEBUG_KMS("vbt t1_t3 %d t8 %d t9 %d t10 %d t11_t12 %d\n",
		      vbt.t1_t3, vbt.t8, vbt.t9, vbt.t10, vbt.t11_t12);

	/* Use the max of the register settings and vbt. If both are
	 * unset, fall back to the spec limits. */
#define assign_final(field)	final.field = (max(cur.field, vbt.field) == 0 ? \
				       spec.field : \
				       max(cur.field, vbt.field))
	assign_final(t1_t3);
	assign_final(t8);
	assign_final(t9);
	assign_final(t10);
	assign_final(t11_t12);
#undef assign_final

#define get_delay(field)	(DIV_ROUND_UP(final.field, 10))
	intel_dp->panel_power_up_delay = get_delay(t1_t3);
	intel_dp->backlight_on_delay = get_delay(t8);
	intel_dp->backlight_off_delay = get_delay(t9);
	intel_dp->panel_power_down_delay = get_delay(t10);
	intel_dp->panel_power_cycle_delay = get_delay(t11_t12);
#undef get_delay

	DRM_DEBUG_KMS("panel power up delay %d, power down delay %d, power cycle delay %d\n",
		      intel_dp->panel_power_up_delay, intel_dp->panel_power_down_delay,
		      intel_dp->panel_power_cycle_delay);

	DRM_DEBUG_KMS("backlight on delay %d, off delay %d\n",
		      intel_dp->backlight_on_delay, intel_dp->backlight_off_delay);

	if (out)
		*out = final;
}

static void
intel_dp_init_panel_power_sequencer_registers(struct drm_device *dev,
					      struct intel_dp *intel_dp,
					      struct edp_power_seq *seq)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 pp_on, pp_off, pp_div, port_sel = 0;
	int div = HAS_PCH_SPLIT(dev) ? intel_pch_rawclk(dev) : intel_hrawclk(dev);
	int pp_on_reg, pp_off_reg, pp_div_reg;

	if (HAS_PCH_SPLIT(dev)) {
		pp_on_reg = PCH_PP_ON_DELAYS;
		pp_off_reg = PCH_PP_OFF_DELAYS;
		pp_div_reg = PCH_PP_DIVISOR;
	} else {
		enum pipe pipe = vlv_power_sequencer_pipe(intel_dp);

		pp_on_reg = VLV_PIPE_PP_ON_DELAYS(pipe);
		pp_off_reg = VLV_PIPE_PP_OFF_DELAYS(pipe);
		pp_div_reg = VLV_PIPE_PP_DIVISOR(pipe);
	}

	/* And finally store the new values in the power sequencer. */
	pp_on = (seq->t1_t3 << PANEL_POWER_UP_DELAY_SHIFT) |
		(seq->t8 << PANEL_LIGHT_ON_DELAY_SHIFT);
	pp_off = (seq->t9 << PANEL_LIGHT_OFF_DELAY_SHIFT) |
		 (seq->t10 << PANEL_POWER_DOWN_DELAY_SHIFT);
	/* Compute the divisor for the pp clock, simply match the Bspec
	 * formula. */
	pp_div = ((100 * div)/2 - 1) << PP_REFERENCE_DIVIDER_SHIFT;
	pp_div |= (DIV_ROUND_UP(seq->t11_t12, 1000)
			<< PANEL_POWER_CYCLE_DELAY_SHIFT);

	/* Haswell doesn't have any port selection bits for the panel
	 * power sequencer any more. */
	if (IS_VALLEYVIEW(dev)) {
		if (dp_to_dig_port(intel_dp)->port == PORT_B)
			port_sel = PANEL_PORT_SELECT_DPB_VLV;
		else
			port_sel = PANEL_PORT_SELECT_DPC_VLV;
	} else if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		if (dp_to_dig_port(intel_dp)->port == PORT_A)
			port_sel = PANEL_PORT_SELECT_DPA;
		else
			port_sel = PANEL_PORT_SELECT_DPD;
	}

	pp_on |= port_sel;

	I915_WRITE(pp_on_reg, pp_on);
	I915_WRITE(pp_off_reg, pp_off);
	I915_WRITE(pp_div_reg, pp_div);

	DRM_DEBUG_KMS("panel power sequencer register settings: PP_ON %#x, PP_OFF %#x, PP_DIV %#x\n",
		      I915_READ(pp_on_reg),
		      I915_READ(pp_off_reg),
		      I915_READ(pp_div_reg));
}

static bool intel_edp_init_connector(struct intel_dp *intel_dp,
				     struct intel_connector *intel_connector)
{
	struct drm_connector *connector = &intel_connector->base;
	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
	struct drm_device *dev = intel_dig_port->base.base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *fixed_mode = NULL;
	struct edp_power_seq power_seq = { 0 };
	bool has_dpcd;
	struct drm_display_mode *scan;
	struct edid *edid;

	if (!is_edp(intel_dp))
		return true;

	intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);

	/* Cache DPCD and EDID for edp. */
	ironlake_edp_panel_vdd_on(intel_dp);
	has_dpcd = intel_dp_get_dpcd(intel_dp);
	ironlake_edp_panel_vdd_off(intel_dp, false);

	if (has_dpcd) {
		if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11)
			dev_priv->no_aux_handshake =
				intel_dp->dpcd[DP_MAX_DOWNSPREAD] &
				DP_NO_AUX_HANDSHAKE_LINK_TRAINING;
	} else {
		/* if this fails, presume the device is a ghost */
		DRM_INFO("failed to retrieve link info, disabling eDP\n");
		return false;
	}

	/* We now know it's not a ghost, init power sequence regs. */
	intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
						      &power_seq);

	edid = drm_get_edid(connector, &intel_dp->adapter);
	if (edid) {
		if (drm_add_edid_modes(connector, edid)) {
			drm_mode_connector_update_edid_property(connector,
								edid);
			drm_edid_to_eld(connector, edid);
		} else {
			kfree(edid);
			edid = ERR_PTR(-EINVAL);
		}
	} else {
		edid = ERR_PTR(-ENOENT);
	}
	intel_connector->edid = edid;

	/* prefer fixed mode from EDID if available */
	list_for_each_entry(scan, &connector->probed_modes, head) {
		if ((scan->type & DRM_MODE_TYPE_PREFERRED)) {
			fixed_mode = drm_mode_duplicate(dev, scan);
			break;
		}
	}

	/* fallback to VBT if available for eDP */
	if (!fixed_mode && dev_priv->vbt.lfp_lvds_vbt_mode) {
		fixed_mode = drm_mode_duplicate(dev,
					dev_priv->vbt.lfp_lvds_vbt_mode);
		if (fixed_mode)
			fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
	}

	intel_panel_init(&intel_connector->panel, fixed_mode);
	intel_panel_setup_backlight(connector);

	return true;
}

bool
intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
			struct intel_connector *intel_connector)
{
	struct drm_connector *connector = &intel_connector->base;
	struct intel_dp *intel_dp = &intel_dig_port->dp;
	struct intel_encoder *intel_encoder = &intel_dig_port->base;
	struct drm_device *dev = intel_encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	enum port port = intel_dig_port->port;
	const char *name = NULL;
	int type, error;

	/* Preserve the current hw state. */
	intel_dp->DP = I915_READ(intel_dp->output_reg);
	intel_dp->attached_connector = intel_connector;

	if (intel_dp_is_edp(dev, port))
		type = DRM_MODE_CONNECTOR_eDP;
	else
		type = DRM_MODE_CONNECTOR_DisplayPort;

	/*
	 * For eDP we always set the encoder type to INTEL_OUTPUT_EDP, but
	 * for DP the encoder type can be set by the caller to
	 * INTEL_OUTPUT_UNKNOWN for DDI, so don't rewrite it.
	 */
	if (type == DRM_MODE_CONNECTOR_eDP)
		intel_encoder->type = INTEL_OUTPUT_EDP;

	DRM_DEBUG_KMS("Adding %s connector on port %c\n",
			type == DRM_MODE_CONNECTOR_eDP ? "eDP" : "DP",
			port_name(port));

	drm_connector_init(dev, connector, &intel_dp_connector_funcs, type);
	drm_connector_helper_add(connector, &intel_dp_connector_helper_funcs);

	connector->interlace_allowed = true;
	connector->doublescan_allowed = 0;

	INIT_DELAYED_WORK(&intel_dp->panel_vdd_work,
			  ironlake_panel_vdd_work);

	intel_connector_attach_encoder(intel_connector, intel_encoder);
	drm_sysfs_connector_add(connector);

	if (HAS_DDI(dev))
		intel_connector->get_hw_state = intel_ddi_connector_get_hw_state;
	else
		intel_connector->get_hw_state = intel_connector_get_hw_state;
	intel_connector->unregister = intel_dp_connector_unregister;

	intel_dp->aux_ch_ctl_reg = intel_dp->output_reg + 0x10;
	if (HAS_DDI(dev)) {
		switch (intel_dig_port->port) {
		case PORT_A:
			intel_dp->aux_ch_ctl_reg = DPA_AUX_CH_CTL;
			break;
		case PORT_B:
			intel_dp->aux_ch_ctl_reg = PCH_DPB_AUX_CH_CTL;
			break;
		case PORT_C:
			intel_dp->aux_ch_ctl_reg = PCH_DPC_AUX_CH_CTL;
			break;
		case PORT_D:
			intel_dp->aux_ch_ctl_reg = PCH_DPD_AUX_CH_CTL;
			break;
		default:
			BUG();
		}
	}

	/* Set up the DDC bus. */
	switch (port) {
	case PORT_A:
		intel_encoder->hpd_pin = HPD_PORT_A;
		name = "DPDDC-A";
		break;
	case PORT_B:
		intel_encoder->hpd_pin = HPD_PORT_B;
		name = "DPDDC-B";
		break;
	case PORT_C:
		intel_encoder->hpd_pin = HPD_PORT_C;
		name = "DPDDC-C";
		break;
	case PORT_D:
		intel_encoder->hpd_pin = HPD_PORT_D;
		name = "DPDDC-D";
		break;
	default:
		BUG();
	}

	error = intel_dp_i2c_init(intel_dp, intel_connector, name);
	WARN(error, "intel_dp_i2c_init failed with error %d for port %c\n",
	     error, port_name(port));

	intel_dp->psr_setup_done = false;

	if (!intel_edp_init_connector(intel_dp, intel_connector)) {
#ifdef notyet
		i2c_del_adapter(&intel_dp->adapter);
#endif
		if (is_edp(intel_dp)) {
			cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
			mutex_lock(&dev->mode_config.mutex);
			ironlake_panel_vdd_off_sync(intel_dp);
			mutex_unlock(&dev->mode_config.mutex);
		}
		drm_sysfs_connector_remove(connector);
		drm_connector_cleanup(connector);
		return false;
	}

	intel_dp_add_properties(intel_dp, connector);

	/* For G4X desktop chip, PEG_BAND_GAP_DATA 3:0 must first be written
	 * 0xd.  Failure to do so will result in spurious interrupts being
	 * generated on the port when a cable is not attached.
	 */
	if (IS_G4X(dev) && !IS_GM45(dev)) {
		u32 temp = I915_READ(PEG_BAND_GAP_DATA);
		I915_WRITE(PEG_BAND_GAP_DATA, (temp & ~0xf) | 0xd);
	}

	return true;
}

void
intel_dp_init(struct drm_device *dev, int output_reg, enum port port)
{
	struct intel_digital_port *intel_dig_port;
	struct intel_encoder *intel_encoder;
	struct drm_encoder *encoder;
	struct intel_connector *intel_connector;

	intel_dig_port = kzalloc(sizeof(*intel_dig_port), GFP_KERNEL);
	if (!intel_dig_port)
		return;

	intel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);
	if (!intel_connector) {
		kfree(intel_dig_port);
		return;
	}

	intel_encoder = &intel_dig_port->base;
	encoder = &intel_encoder->base;

	drm_encoder_init(dev, &intel_encoder->base, &intel_dp_enc_funcs,
			 DRM_MODE_ENCODER_TMDS);

	intel_encoder->compute_config = intel_dp_compute_config;
	intel_encoder->mode_set = intel_dp_mode_set;
	intel_encoder->disable = intel_disable_dp;
	intel_encoder->post_disable = intel_post_disable_dp;
	intel_encoder->get_hw_state = intel_dp_get_hw_state;
	intel_encoder->get_config = intel_dp_get_config;
	if (IS_VALLEYVIEW(dev)) {
		intel_encoder->pre_pll_enable = vlv_dp_pre_pll_enable;
		intel_encoder->pre_enable = vlv_pre_enable_dp;
		intel_encoder->enable = vlv_enable_dp;
	} else {
		intel_encoder->pre_enable = g4x_pre_enable_dp;
		intel_encoder->enable = g4x_enable_dp;
	}

	intel_dig_port->port = port;
	intel_dig_port->dp.output_reg = output_reg;

	intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
	intel_encoder->crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);
	intel_encoder->cloneable = false;
	intel_encoder->hot_plug = intel_dp_hot_plug;

	if (!intel_dp_init_connector(intel_dig_port, intel_connector)) {
		drm_encoder_cleanup(encoder);
		kfree(intel_dig_port);
		kfree(intel_connector);
	}
}
@


1.26
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.25 2015/06/24 08:32:39 kettenis Exp $	*/
d97 1
d104 6
a109 1
		max_link_bw = DP_LINK_BW_2_7;
d856 2
a857 1
	int max_clock = intel_dp_max_link_bw(intel_dp) == DP_LINK_BW_2_7 ? 1 : 0;
d859 1
a859 1
	static int bws[2] = { DP_LINK_BW_1_62, DP_LINK_BW_2_7 };
d2683 5
d2691 1
a2691 1
				     DP_TRAINING_PATTERN_2 |
d2718 1
a2718 1
						DP_TRAINING_PATTERN_2 |
d2734 1
a2734 1
						DP_TRAINING_PATTERN_2 |
d2879 9
@


1.25
log
@Introduce Linux work queue APIs and use them.  As a side-effect, this will
move some of the work from the system task queue to the driver-specific
task queue.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.24 2015/04/12 11:26:54 jsg Exp $	*/
d39 26
a78 24
/**
 * is_pch_edp - is the port on the PCH and attached to an eDP panel?
 * @@intel_dp: DP struct
 *
 * Returns true if the given DP struct corresponds to a PCH DP port attached
 * to an eDP panel, false otherwise.  Helpful for determining whether we
 * may need FDI resources for a given DP output or not.
 */
static bool is_pch_edp(struct intel_dp *intel_dp)
{
	return intel_dp->is_pch_edp;
}

/**
 * is_cpu_edp - is the port on the CPU and attached to an eDP panel?
 * @@intel_dp: DP struct
 *
 * Returns true if the given DP struct corresponds to a CPU eDP port.
 */
static bool is_cpu_edp(struct intel_dp *intel_dp)
{
	return is_edp(intel_dp) && !is_pch_edp(intel_dp);
}

a90 19
/**
 * intel_encoder_is_pch_edp - is the given encoder a PCH attached eDP?
 * @@encoder: DRM encoder
 *
 * Return true if @@encoder corresponds to a PCH attached eDP panel.  Needed
 * by intel_display.c.
 */
bool intel_encoder_is_pch_edp(struct drm_encoder *encoder)
{
	struct intel_dp *intel_dp;

	if (!encoder)
		return false;

	intel_dp = enc_to_intel_dp(encoder);

	return is_pch_edp(intel_dp);
}

a92 23
void
intel_edp_link_config(struct intel_encoder *intel_encoder,
		       int *lane_num, int *link_bw)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);

	*lane_num = intel_dp->lane_count;
	*link_bw = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);
}

int
intel_edp_target_clock(struct intel_encoder *intel_encoder,
		       struct drm_display_mode *mode)
{
	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
	struct intel_connector *intel_connector = intel_dp->attached_connector;

	if (intel_connector->panel.fixed_mode)
		return intel_connector->panel.fixed_mode->clock;
	else
		return mode->clock;
}

d143 1
a143 29
static bool
intel_dp_adjust_dithering(struct intel_dp *intel_dp,
			  struct drm_display_mode *mode,
			  bool adjust_mode)
{
	int max_link_clock =
		drm_dp_bw_code_to_link_rate(intel_dp_max_link_bw(intel_dp));
	int max_lanes = drm_dp_max_lane_count(intel_dp->dpcd);
	int max_rate, mode_rate;

	mode_rate = intel_dp_link_required(mode->clock, 24);
	max_rate = intel_dp_max_data_rate(max_link_clock, max_lanes);

	if (mode_rate > max_rate) {
		mode_rate = intel_dp_link_required(mode->clock, 18);
		if (mode_rate > max_rate)
			return false;

		if (adjust_mode)
			mode->private_flags
				|= INTEL_MODE_DP_FORCE_6BPC;

		return true;
	}

	return true;
}

static int
d150 2
d159 2
d163 7
a169 1
	if (!intel_dp_adjust_dithering(intel_dp, mode, false))
d238 57
d300 1
a300 1
	return (I915_READ(PCH_PP_STATUS) & PP_ON) != 0;
d308 1
a308 1
	return (I915_READ(PCH_PP_CONTROL) & EDP_FORCE_VDD) != 0;
d321 1
d325 2
a326 2
			      I915_READ(PCH_PP_STATUS),
			      I915_READ(PCH_PP_CONTROL));
d330 2
a331 4
static int
intel_dp_aux_ch(struct intel_dp *intel_dp,
		uint8_t *send, int send_bytes,
		uint8_t *recv, int recv_size)
a332 1
	uint32_t output_reg = intel_dp->output_reg;
d336 1
a336 4
	uint32_t ch_ctl = output_reg + 0x10;
	uint32_t ch_data = ch_ctl + 4;
	int i;
	int recv_bytes;
d338 18
a355 2
	uint32_t aux_clock_divider;
	int try, precharge;
d357 6
a362 22
	if (IS_HASWELL(dev)) {
		switch (intel_dig_port->port) {
		case PORT_A:
			ch_ctl = DPA_AUX_CH_CTL;
			ch_data = DPA_AUX_CH_DATA1;
			break;
		case PORT_B:
			ch_ctl = PCH_DPB_AUX_CH_CTL;
			ch_data = PCH_DPB_AUX_CH_DATA1;
			break;
		case PORT_C:
			ch_ctl = PCH_DPC_AUX_CH_CTL;
			ch_data = PCH_DPC_AUX_CH_DATA1;
			break;
		case PORT_D:
			ch_ctl = PCH_DPD_AUX_CH_CTL;
			ch_data = PCH_DPD_AUX_CH_DATA1;
			break;
		default:
			BUG();
		}
	}
a363 1
	intel_dp_check_edp(intel_dp);
d371 5
a375 1
	if (is_cpu_edp(intel_dp)) {
d377 1
a377 3
			aux_clock_divider = intel_ddi_get_cdclk_freq(dev_priv) >> 1;
		else if (IS_VALLEYVIEW(dev))
			aux_clock_divider = 100;
d379 1
a379 1
			aux_clock_divider = 200; /* SNB & IVB eDP input clock at 400Mhz */
d381 41
a421 5
			aux_clock_divider = 225; /* eDP input clock at 450Mhz */
	} else if (HAS_PCH_SPLIT(dev))
		aux_clock_divider = DIV_ROUND_UP(intel_pch_rawclk(dev), 2);
	else
		aux_clock_divider = intel_hrawclk(dev) / 2;
d428 7
d437 1
a437 1
		status = I915_READ(ch_ctl);
d440 1
a440 1
		drm_msleep(1, "915ach");
d446 2
a447 1
		return -EBUSY;
d450 40
a489 22
	/* Must try at least 3 times according to DP spec */
	for (try = 0; try < 5; try++) {
		/* Load the send data into the aux channel data registers */
		for (i = 0; i < send_bytes; i += 4)
			I915_WRITE(ch_data + i,
				   pack_aux(send + i, send_bytes - i));

		/* Send the command and wait for it to complete */
		I915_WRITE(ch_ctl,
			   DP_AUX_CH_CTL_SEND_BUSY |
			   DP_AUX_CH_CTL_TIME_OUT_400us |
			   (send_bytes << DP_AUX_CH_CTL_MESSAGE_SIZE_SHIFT) |
			   (precharge << DP_AUX_CH_CTL_PRECHARGE_2US_SHIFT) |
			   (aux_clock_divider << DP_AUX_CH_CTL_BIT_CLOCK_2X_SHIFT) |
			   DP_AUX_CH_CTL_DONE |
			   DP_AUX_CH_CTL_TIME_OUT_ERROR |
			   DP_AUX_CH_CTL_RECEIVE_ERROR);
		for (;;) {
			status = I915_READ(ch_ctl);
			if ((status & DP_AUX_CH_CTL_SEND_BUSY) == 0)
				break;
			udelay(100);
a490 13

		/* Clear done status and any errors */
		I915_WRITE(ch_ctl,
			   status |
			   DP_AUX_CH_CTL_DONE |
			   DP_AUX_CH_CTL_TIME_OUT_ERROR |
			   DP_AUX_CH_CTL_RECEIVE_ERROR);

		if (status & (DP_AUX_CH_CTL_TIME_OUT_ERROR |
			      DP_AUX_CH_CTL_RECEIVE_ERROR))
			continue;
		if (status & DP_AUX_CH_CTL_DONE)
			break;
d495 2
a496 1
		return -EBUSY;
d499 1
d505 2
a506 1
		return -EIO;
d513 2
a514 1
		return -ETIMEDOUT;
d527 8
a534 1
	return recv_bytes;
d548 3
d552 1
a552 3
	if (send_bytes > 16)
		return -1;
	msg[0] = AUX_NATIVE_WRITE << 4;
d562 2
a563 1
		if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK)
d565 1
a565 1
		else if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)
d596 3
d600 1
a600 1
	msg[0] = AUX_NATIVE_READ << 4;
d615 2
a616 2
		ack = reply[0];
		if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK) {
d620 1
a620 1
		else if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)
d631 1
a631 1
intel_dp_i2c_aux_ch(struct i2c_controller *adapter, int mode,
d646 1
d650 1
a650 1
		msg[0] = AUX_I2C_READ << 4;
d652 1
a652 1
		msg[0] = AUX_I2C_WRITE << 4;
d655 1
a655 1
		msg[0] |= AUX_I2C_MOT << 4;
d678 6
a683 1
	for (retry = 0; retry < 5; retry++) {
d689 1
a689 1
			return ret;
d692 2
a693 2
		switch (reply[0] & AUX_NATIVE_REPLY_MASK) {
		case AUX_NATIVE_REPLY_ACK:
d698 1
a698 1
		case AUX_NATIVE_REPLY_NACK:
d700 3
a702 2
			return -EREMOTEIO;
		case AUX_NATIVE_REPLY_DEFER:
d719 2
a720 1
			return -EREMOTEIO;
d723 2
a724 2
		switch (reply[0] & AUX_I2C_REPLY_MASK) {
		case AUX_I2C_REPLY_ACK:
d728 3
a730 2
			return reply_bytes - 1;
		case AUX_I2C_REPLY_NACK:
d732 3
a734 2
			return -EREMOTEIO;
		case AUX_I2C_REPLY_DEFER:
d740 2
a741 1
			return -EREMOTEIO;
d746 17
a762 1
	return -EREMOTEIO;
a774 1
	intel_dp->algo.adapter = &intel_dp->adapter;
d777 1
a777 1
#if 0
d782 4
a785 1
#endif
a786 2
#if 0
	intel_dp->adapter.dev.parent = &intel_connector->base.kdev;
a788 1
	ironlake_edp_panel_vdd_on(intel_dp);
d790 12
a801 1
	ironlake_edp_panel_vdd_off(intel_dp, false);
d805 32
d838 2
a839 3
intel_dp_mode_fixup(struct drm_encoder *encoder,
		    const struct drm_display_mode *mode,
		    struct drm_display_mode *adjusted_mode)
d841 6
a846 2
	struct drm_device *dev = encoder->dev;
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
d853 6
d863 6
a868 3
		intel_pch_panel_fitting(dev,
					intel_connector->panel.fitting_mode,
					mode, adjusted_mode);
d876 2
a877 7
		      max_lane_count, bws[max_clock], adjusted_mode->clock);

	if (!intel_dp_adjust_dithering(intel_dp, adjusted_mode, true))
		return false;

	bpp = adjusted_mode->private_flags & INTEL_MODE_DP_FORCE_6BPC ? 18 : 24;
	mode_rate = intel_dp_link_required(adjusted_mode->clock, bpp);
d879 23
a901 18
	for (clock = 0; clock <= max_clock; clock++) {
		for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
			int link_bw_clock =
				drm_dp_bw_code_to_link_rate(bws[clock]);
			int link_avail = intel_dp_max_data_rate(link_bw_clock,
								lane_count);

			if (mode_rate <= link_avail) {
				intel_dp->link_bw = bws[clock];
				intel_dp->lane_count = lane_count;
				adjusted_mode->clock = link_bw_clock;
				DRM_DEBUG_KMS("DP link bw %02x lane "
						"count %d clock %d bpp %d\n",
				       intel_dp->link_bw, intel_dp->lane_count,
				       adjusted_mode->clock, bpp);
				DRM_DEBUG_KMS("DP link bw required %i available %i\n",
					      mode_rate, link_avail);
				return true;
d907 36
d945 11
a955 7
struct intel_dp_m_n {
	uint32_t	tu;
	uint32_t	gmch_m;
	uint32_t	gmch_n;
	uint32_t	link_m;
	uint32_t	link_n;
};
d957 10
a966 6
static void
intel_reduce_ratio(uint32_t *num, uint32_t *den)
{
	while (*num > 0xffffff || *den > 0xffffff) {
		*num >>= 1;
		*den >>= 1;
a967 1
}
d969 4
a972 14
static void
intel_dp_compute_m_n(int bpp,
		     int nlanes,
		     int pixel_clock,
		     int link_clock,
		     struct intel_dp_m_n *m_n)
{
	m_n->tu = 64;
	m_n->gmch_m = (pixel_clock * bpp) >> 3;
	m_n->gmch_n = link_clock * nlanes;
	intel_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);
	m_n->link_m = pixel_clock;
	m_n->link_n = link_clock;
	intel_reduce_ratio(&m_n->link_m, &m_n->link_n);
d975 1
a975 3
void
intel_dp_set_m_n(struct drm_crtc *crtc, struct drm_display_mode *mode,
		 struct drm_display_mode *adjusted_mode)
d977 1
a977 3
	struct drm_device *dev = crtc->dev;
	struct intel_encoder *intel_encoder;
	struct intel_dp *intel_dp;
d979 4
a982 6
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int lane_count = 4;
	struct intel_dp_m_n m_n;
	int pipe = intel_crtc->pipe;
	enum transcoder cpu_transcoder = intel_crtc->cpu_transcoder;
	int target_clock;
d985 2
a986 83
	 * Find the lane count in the intel_encoder private
	 */
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		intel_dp = enc_to_intel_dp(&intel_encoder->base);

		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
		    intel_encoder->type == INTEL_OUTPUT_EDP)
		{
			lane_count = intel_dp->lane_count;
			break;
		}
	}

	target_clock = mode->clock;
	for_each_encoder_on_crtc(dev, crtc, intel_encoder) {
		if (intel_encoder->type == INTEL_OUTPUT_EDP) {
			target_clock = intel_edp_target_clock(intel_encoder,
							      mode);
			break;
		}
	}

	/*
	 * Compute the GMCH and Link ratios. The '3' here is
	 * the number of bytes_per_pixel post-LUT, which we always
	 * set up for 8-bits of R/G/B, or 3 bytes total.
	 */
	intel_dp_compute_m_n(intel_crtc->bpp, lane_count,
			     target_clock, adjusted_mode->clock, &m_n);

	if (IS_HASWELL(dev)) {
		I915_WRITE(PIPE_DATA_M1(cpu_transcoder),
			   TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_DATA_N1(cpu_transcoder), m_n.gmch_n);
		I915_WRITE(PIPE_LINK_M1(cpu_transcoder), m_n.link_m);
		I915_WRITE(PIPE_LINK_N1(cpu_transcoder), m_n.link_n);
	} else if (HAS_PCH_SPLIT(dev)) {
		I915_WRITE(TRANSDATA_M1(pipe), TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(TRANSDATA_N1(pipe), m_n.gmch_n);
		I915_WRITE(TRANSDPLINK_M1(pipe), m_n.link_m);
		I915_WRITE(TRANSDPLINK_N1(pipe), m_n.link_n);
	} else if (IS_VALLEYVIEW(dev)) {
		I915_WRITE(PIPE_DATA_M1(pipe), TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_DATA_N1(pipe), m_n.gmch_n);
		I915_WRITE(PIPE_LINK_M1(pipe), m_n.link_m);
		I915_WRITE(PIPE_LINK_N1(pipe), m_n.link_n);
	} else {
		I915_WRITE(PIPE_GMCH_DATA_M(pipe),
			   TU_SIZE(m_n.tu) | m_n.gmch_m);
		I915_WRITE(PIPE_GMCH_DATA_N(pipe), m_n.gmch_n);
		I915_WRITE(PIPE_DP_LINK_M(pipe), m_n.link_m);
		I915_WRITE(PIPE_DP_LINK_N(pipe), m_n.link_n);
	}
}

void intel_dp_init_link_config(struct intel_dp *intel_dp)
{
	memset(intel_dp->link_configuration, 0, DP_LINK_CONFIGURATION_SIZE);
	intel_dp->link_configuration[0] = intel_dp->link_bw;
	intel_dp->link_configuration[1] = intel_dp->lane_count;
	intel_dp->link_configuration[8] = DP_SET_ANSI_8B10B;
	/*
	 * Check for DPCD version > 1.1 and enhanced framing support
	 */
	if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11 &&
	    (intel_dp->dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP)) {
		intel_dp->link_configuration[1] |= DP_LANE_COUNT_ENHANCED_FRAME_EN;
	}
}

static void
intel_dp_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,
		  struct drm_display_mode *adjusted_mode)
{
	struct drm_device *dev = encoder->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
	struct drm_crtc *crtc = encoder->crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);

	/*
	 * There are four kinds of DP registers:
	 *
d1008 1
a1009 11
	switch (intel_dp->lane_count) {
	case 1:
		intel_dp->DP |= DP_PORT_WIDTH_1;
		break;
	case 2:
		intel_dp->DP |= DP_PORT_WIDTH_2;
		break;
	case 4:
		intel_dp->DP |= DP_PORT_WIDTH_4;
		break;
	}
d1012 1
a1012 1
				 pipe_name(intel_crtc->pipe));
d1014 1
a1014 1
		intel_write_eld(encoder, adjusted_mode);
a1016 2
	intel_dp_init_link_config(intel_dp);

d1019 1
a1019 1
	if (is_cpu_edp(intel_dp) && IS_GEN7(dev) && !IS_VALLEYVIEW(dev)) {
d1026 1
a1026 1
		if (intel_dp->link_configuration[1] & DP_LANE_COUNT_ENHANCED_FRAME_EN)
d1029 4
a1032 9
		intel_dp->DP |= intel_crtc->pipe << 29;

		/* don't miss out required setting for eDP */
		if (adjusted_mode->clock < 200000)
			intel_dp->DP |= DP_PLL_FREQ_160MHZ;
		else
			intel_dp->DP |= DP_PLL_FREQ_270MHZ;
	} else if (!HAS_PCH_CPT(dev) || is_cpu_edp(intel_dp)) {
		intel_dp->DP |= intel_dp->color_range;
d1040 1
a1040 1
		if (intel_dp->link_configuration[1] & DP_LANE_COUNT_ENHANCED_FRAME_EN)
d1043 1
a1043 1
		if (intel_crtc->pipe == 1)
a1044 8

		if (is_cpu_edp(intel_dp)) {
			/* don't miss out required setting for eDP */
			if (adjusted_mode->clock < 200000)
				intel_dp->DP |= DP_PLL_FREQ_160MHZ;
			else
				intel_dp->DP |= DP_PLL_FREQ_270MHZ;
		}
d1048 3
d1068 4
d1074 3
a1076 3
		      mask, value,
		      I915_READ(PCH_PP_STATUS),
		      I915_READ(PCH_PP_CONTROL));
d1078 1
a1078 1
	if (_wait_for((I915_READ(PCH_PP_STATUS) & mask) == value, 5000, 10)) {
d1080 2
a1081 2
			  I915_READ(PCH_PP_STATUS),
			  I915_READ(PCH_PP_CONTROL));
d1083 2
d1110 1
a1110 1
static  u32 ironlake_get_pp_control(struct drm_i915_private *dev_priv)
d1112 3
a1114 1
	u32	control = I915_READ(PCH_PP_CONTROL);
d1116 1
d1127 1
a1130 1
	DRM_DEBUG_KMS("Turn eDP VDD on\n");
d1137 1
a1137 2
	if (ironlake_edp_have_panel_vdd(intel_dp)) {
		DRM_DEBUG_KMS("eDP VDD already on\n");
d1139 4
a1142 1
	}
d1147 1
a1147 1
	pp = ironlake_get_pp_control(dev_priv);
a1148 4
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
	DRM_DEBUG_KMS("PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n",
		      I915_READ(PCH_PP_STATUS), I915_READ(PCH_PP_CONTROL));
d1150 7
d1162 1
a1162 1
		drm_msleep(intel_dp->panel_power_up_delay, "915edpon");
d1171 3
d1176 3
a1178 1
		pp = ironlake_get_pp_control(dev_priv);
d1180 6
a1185 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1188 5
a1192 2
		DRM_DEBUG_KMS("PCH_PP_STATUS: 0x%08x PCH_PP_CONTROL: 0x%08x\n",
			      I915_READ(PCH_PP_STATUS), I915_READ(PCH_PP_CONTROL));
d1194 1
a1194 1
		drm_msleep(intel_dp->panel_power_down_delay, "915vddo");
a1213 1
	DRM_DEBUG_KMS("Turn eDP VDD off %d\n", intel_dp->want_panel_vdd);
d1236 1
d1250 2
a1251 1
	pp = ironlake_get_pp_control(dev_priv);
d1255 2
a1256 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1263 2
a1264 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1270 2
a1271 2
		I915_WRITE(PCH_PP_CONTROL, pp);
		POSTING_READ(PCH_PP_CONTROL);
d1280 1
d1289 1
a1289 1
	pp = ironlake_get_pp_control(dev_priv);
d1293 5
a1297 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1302 3
a1311 1
	int pipe = to_intel_crtc(intel_dig_port->base.base.crtc)->pipe;
d1313 1
d1325 2
a1326 2
	drm_msleep(intel_dp->backlight_on_delay, "915ebo");
	pp = ironlake_get_pp_control(dev_priv);
a1327 2
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
d1329 6
a1334 1
	intel_panel_enable_backlight(dev, pipe);
d1342 1
d1347 1
a1347 1
	intel_panel_disable_backlight(dev);
d1350 1
a1350 1
	pp = ironlake_get_pp_control(dev_priv);
d1352 6
a1357 3
	I915_WRITE(PCH_PP_CONTROL, pp);
	POSTING_READ(PCH_PP_CONTROL);
	drm_msleep(intel_dp->backlight_off_delay, "915bo1");
d1436 1
a1436 1
			drm_msleep(1, "915dps");
d1445 1
d1453 1
a1453 1
	if (is_cpu_edp(intel_dp) && IS_GEN7(dev)) {
d1455 1
a1455 1
	} else if (!HAS_PCH_CPT(dev) || is_cpu_edp(intel_dp)) {
d1491 330
d1824 2
d1831 1
a1831 1
	intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
d1835 1
a1835 1
	if (!is_cpu_edp(intel_dp))
d1842 2
d1845 1
a1845 1
	if (is_cpu_edp(intel_dp)) {
d1847 2
a1848 1
		ironlake_edp_pll_off(intel_dp);
d1868 15
d1886 1
a1886 1
static void intel_pre_enable_dp(struct intel_encoder *encoder)
d1889 1
d1891 1
a1891 1
	if (is_cpu_edp(intel_dp))
d1895 67
d1981 1
a1981 1
		drm_msleep(1, "915dpl");
a1999 12
#if 0
static char	*voltage_names[] = {
	"0.4V", "0.6V", "0.8V", "1.2V"
};
static char	*pre_emph_names[] = {
	"0dB", "3.5dB", "6dB", "9.5dB"
};
static char	*link_train_names[] = {
	"pattern 1", "pattern 2", "idle", "off"
};
#endif

d2009 1
d2011 3
a2013 1
	if (IS_GEN7(dev) && is_cpu_edp(intel_dp))
d2015 1
a2015 1
	else if (HAS_PCH_CPT(dev) && !is_cpu_edp(intel_dp))
d2025 1
d2027 24
a2050 1
	if (IS_HASWELL(dev)) {
d2062 1
a2062 1
	} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
d2087 100
d2188 2
a2189 1
intel_get_adjust_train(struct intel_dp *intel_dp, uint8_t link_status[DP_LINK_STATUS_SIZE])
d2220 1
a2220 1
intel_dp_signal_levels(uint8_t train_set)
d2318 1
a2318 1
intel_dp_signal_levels_hsw(uint8_t train_set)
d2350 70
d2422 1
a2422 1
			uint32_t dp_reg_value,
d2429 2
a2430 2
	int ret;
	uint32_t temp;
d2432 2
a2433 2
	if (IS_HASWELL(dev)) {
		temp = I915_READ(DP_TP_CTL(port));
a2442 8
			temp |= DP_TP_CTL_LINK_TRAIN_IDLE;
			I915_WRITE(DP_TP_CTL(port), temp);

			if (wait_for((I915_READ(DP_TP_STATUS(port)) &
				      DP_TP_STATUS_IDLE_DONE), 1))
				DRM_ERROR("Timed out waiting for DP idle patterns\n");

			temp &= ~DP_TP_CTL_LINK_TRAIN_MASK;
d2458 21
a2478 3
	} else if (HAS_PCH_CPT(dev) &&
		   (IS_GEN7(dev) || !is_cpu_edp(intel_dp))) {
		dp_reg_value &= ~DP_LINK_TRAIN_MASK_CPT;
d2482 1
a2482 1
			dp_reg_value |= DP_LINK_TRAIN_OFF_CPT;
d2485 1
a2485 1
			dp_reg_value |= DP_LINK_TRAIN_PAT_1_CPT;
d2487 57
a2543 8
		case DP_TRAINING_PATTERN_2:
			dp_reg_value |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			dp_reg_value |= DP_LINK_TRAIN_PAT_2_CPT;
			break;
		}
d2545 2
a2546 2
	} else {
		dp_reg_value &= ~DP_LINK_TRAIN_MASK;
d2548 7
a2554 16
		switch (dp_train_pat & DP_TRAINING_PATTERN_MASK) {
		case DP_TRAINING_PATTERN_DISABLE:
			dp_reg_value |= DP_LINK_TRAIN_OFF;
			break;
		case DP_TRAINING_PATTERN_1:
			dp_reg_value |= DP_LINK_TRAIN_PAT_1;
			break;
		case DP_TRAINING_PATTERN_2:
			dp_reg_value |= DP_LINK_TRAIN_PAT_2;
			break;
		case DP_TRAINING_PATTERN_3:
			DRM_ERROR("DP training pattern 3 not supported\n");
			dp_reg_value |= DP_LINK_TRAIN_PAT_2;
			break;
		}
	}
d2556 2
a2557 2
	I915_WRITE(intel_dp->output_reg, dp_reg_value);
	POSTING_READ(intel_dp->output_reg);
d2559 4
a2562 3
	intel_dp_aux_native_write_1(intel_dp,
				    DP_TRAINING_PATTERN_SET,
				    dp_train_pat);
d2564 9
a2572 9
	if ((dp_train_pat & DP_TRAINING_PATTERN_MASK) !=
	    DP_TRAINING_PATTERN_DISABLE) {
		ret = intel_dp_aux_native_write(intel_dp,
						DP_TRAINING_LANE0_SET,
						intel_dp->train_set,
						intel_dp->lane_count);
		if (ret != intel_dp->lane_count)
			return false;
	}
d2574 3
a2576 1
	return true;
a2586 1
	bool clock_recovery = false;
d2589 1
d2595 9
a2603 3
	intel_dp_aux_native_write(intel_dp, DP_LINK_BW_SET,
				  intel_dp->link_configuration,
				  DP_LINK_CONFIGURATION_SIZE);
d2607 8
a2614 1
	memset(intel_dp->train_set, 0, 4);
a2617 1
	clock_recovery = false;
d2619 1
a2619 26
		/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
		uint8_t	    link_status[DP_LINK_STATUS_SIZE];
		uint32_t    signal_levels;

		if (IS_HASWELL(dev)) {
			signal_levels = intel_dp_signal_levels_hsw(
							intel_dp->train_set[0]);
			DP = (DP & ~DDI_BUF_EMP_MASK) | signal_levels;
		} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
			signal_levels = intel_gen7_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB) | signal_levels;
		} else if (IS_GEN6(dev) && is_cpu_edp(intel_dp)) {
			signal_levels = intel_gen6_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB) | signal_levels;
		} else {
			signal_levels = intel_dp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~(DP_VOLTAGE_MASK|DP_PRE_EMPHASIS_MASK)) | signal_levels;
		}
		DRM_DEBUG_KMS("training pattern 1 signal levels %08x\n",
			      signal_levels);

		/* Set training pattern 1 */
		if (!intel_dp_set_link_train(intel_dp, DP,
					     DP_TRAINING_PATTERN_1 |
					     DP_LINK_SCRAMBLING_DISABLE))
			break;
a2628 1
			clock_recovery = true;
d2639 1
a2639 1
				DRM_DEBUG_KMS("too many full retries, give up\n");
d2642 3
a2644 1
			memset(intel_dp->train_set, 0, 4);
d2653 1
a2653 1
				DRM_DEBUG_KMS("too many voltage retries, give up\n");
d2660 5
a2664 2
		/* Compute new intel_dp->train_set as requested by target */
		intel_get_adjust_train(intel_dp, link_status);
a2672 1
	struct drm_device *dev = intel_dp_to_dev(intel_dp);
d2678 7
d2689 1
a2689 3
		/* Use intel_dp->train_set[0] to set the voltage and pre emphasis values */
		uint32_t    signal_levels;
		uint8_t	    link_status[DP_LINK_STATUS_SIZE];
a2692 1
			intel_dp_link_down(intel_dp);
a2695 20
		if (IS_HASWELL(dev)) {
			signal_levels = intel_dp_signal_levels_hsw(intel_dp->train_set[0]);
			DP = (DP & ~DDI_BUF_EMP_MASK) | signal_levels;
		} else if (IS_GEN7(dev) && is_cpu_edp(intel_dp) && !IS_VALLEYVIEW(dev)) {
			signal_levels = intel_gen7_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_IVB) | signal_levels;
		} else if (IS_GEN6(dev) && is_cpu_edp(intel_dp)) {
			signal_levels = intel_gen6_edp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~EDP_LINK_TRAIN_VOL_EMP_MASK_SNB) | signal_levels;
		} else {
			signal_levels = intel_dp_signal_levels(intel_dp->train_set[0]);
			DP = (DP & ~(DP_VOLTAGE_MASK|DP_PRE_EMPHASIS_MASK)) | signal_levels;
		}

		/* channel eq pattern */
		if (!intel_dp_set_link_train(intel_dp, DP,
					     DP_TRAINING_PATTERN_2 |
					     DP_LINK_SCRAMBLING_DISABLE))
			break;

d2697 2
a2698 1
		if (!intel_dp_get_link_status(intel_dp, link_status))
d2700 1
d2705 3
d2721 3
d2729 5
a2733 2
		/* Compute new intel_dp->train_set as requested by target */
		intel_get_adjust_train(intel_dp, link_status);
d2737 4
d2742 1
a2742 1
		DRM_DEBUG_KMS("Channel EQ done. DP Training successfull\n");
d2744 6
a2749 1
	intel_dp_set_link_train(intel_dp, DP, DP_TRAINING_PATTERN_DISABLE);
d2756 1
d2759 2
d2786 1
a2786 1
	if (HAS_PCH_CPT(dev) && (IS_GEN7(dev) || !is_cpu_edp(intel_dp))) {
d2795 2
a2796 1
	drm_msleep(17, "915dlo");
d2816 4
a2819 9
		if (crtc == NULL) {
			/* We can arrive here never having been attached
			 * to a CRTC, for instance, due to inheriting
			 * random state from the BIOS.
			 *
			 * If the pipe is not running, play safe and
			 * wait for the clocks to stabilise before
			 * continuing.
			 */
d2821 1
a2821 1
			drm_msleep(50, "915dla");
d2823 1
a2823 1
			intel_wait_for_vblank(dev, to_intel_crtc(crtc)->pipe);
d2829 1
a2829 1
	drm_msleep(intel_dp->panel_power_down_delay, "915ldo");
d2835 8
d2847 6
d2856 12
a2948 1
		intel_dp_link_down(intel_dp);
a2953 1
		intel_dp_link_down(intel_dp);
d2976 1
a2984 1
	bool hpd;
d2995 2
a2996 2
	hpd = !!(intel_dp->downstream_ports[0] & DP_DS_PORT_HPD);
	if (hpd) {
d3010 12
a3021 3
	type = intel_dp->downstream_ports[0] & DP_DS_PORT_TYPE_MASK;
	if (type == DP_DS_PORT_TYPE_VGA || type == DP_DS_PORT_TYPE_NON_EDID)
		return connector_status_unknown;
d3032 2
d3044 3
d3055 1
d3058 10
d3069 3
a3071 3
		switch (intel_dp->output_reg) {
		case DP_B:
			bit = DPB_HOTPLUG_LIVE_STATUS_VLV;
d3073 2
a3074 2
		case DP_C:
			bit = DPC_HOTPLUG_LIVE_STATUS_VLV;
d3076 2
a3077 2
		case DP_D:
			bit = DPD_HOTPLUG_LIVE_STATUS_VLV;
d3083 3
a3085 3
		switch (intel_dp->output_reg) {
		case DP_B:
			bit = DPB_HOTPLUG_LIVE_STATUS_G4X;
d3087 2
a3088 2
		case DP_C:
			bit = DPC_HOTPLUG_LIVE_STATUS_G4X;
d3090 2
a3091 2
		case DP_D:
			bit = DPD_HOTPLUG_LIVE_STATUS_G4X;
d3105 1
a3105 1
intel_dp_get_edid(struct drm_connector *connector, struct i2c_controller *adapter)
a3110 3
		struct edid *edid;
		int size;

d3115 1
a3115 7
		size = (intel_connector->edid->extensions + 1) * EDID_LENGTH;
		edid = kmalloc(size, GFP_KERNEL);
		if (!edid)
			return NULL;

		memcpy(edid, intel_connector->edid, size);
		return edid;
d3122 1
a3122 1
intel_dp_get_edid_modes(struct drm_connector *connector, struct i2c_controller *adapter)
a3138 7

/**
 * Uses CRT_HOTPLUG_EN and CRT_HOTPLUG_STAT to detect DP connection.
 *
 * \return true if DP port is connected.
 * \return false if DP port is disconnected.
 */
d3146 1
d3149 5
a3153 3
#ifdef notyet
	char dpcd_hex_dump[sizeof(intel_dp->dpcd) * 3];
#endif
a3161 6
#ifdef notyet
	hex_dump_to_buffer(intel_dp->dpcd, sizeof(intel_dp->dpcd),
			   32, 1, dpcd_hex_dump, sizeof(dpcd_hex_dump), false);
	DRM_DEBUG_KMS("DPCD: %s\n", dpcd_hex_dump);
#endif

d3163 1
a3163 1
		return status;
d3179 5
a3183 1
	return connector_status_connected;
d3266 21
a3286 1
		if (val == !!intel_dp->color_range)
a3288 1
		intel_dp->color_range = val ? DP_COLOR_RANGE_16_235 : 0;
d3311 2
a3312 5
	if (intel_encoder->base.crtc) {
		struct drm_crtc *crtc = intel_encoder->base.crtc;
		intel_set_mode(crtc, &crtc->mode,
			       crtc->x, crtc->y, crtc->fb);
	}
d3318 1
a3318 1
intel_dp_destroy(struct drm_connector *connector)
a3319 1
	struct intel_dp *intel_dp = intel_attached_dp(connector);
d3325 3
a3327 1
	if (is_edp(intel_dp))
a3329 1
	drm_sysfs_connector_remove(connector);
d3338 1
d3346 1
d3348 1
a3352 6
static const struct drm_encoder_helper_funcs intel_dp_helper_funcs = {
	.mode_fixup = intel_dp_mode_fixup,
	.mode_set = intel_dp_mode_set,
	.disable = intel_encoder_noop,
};

d3358 1
a3358 1
	.destroy = intel_dp_destroy,
d3399 1
a3399 1
bool intel_dpd_is_edp(struct drm_device *dev)
d3402 1
a3402 1
	struct child_device_config *p_child;
d3404 5
d3410 4
a3413 1
	if (!dev_priv->child_dev_num)
d3416 2
a3417 2
	for (i = 0; i < dev_priv->child_dev_num; i++) {
		p_child = dev_priv->child_dev + i;
d3419 3
a3421 2
		if (p_child->dvo_port == PORT_IDPD &&
		    p_child->device_type == DEVICE_TYPE_eDP)
d3434 1
d3454 15
d3472 2
a3473 2
	pp = ironlake_get_pp_control(dev_priv);
	I915_WRITE(PCH_PP_CONTROL, pp);
d3475 3
a3477 3
	pp_on = I915_READ(PCH_PP_ON_DELAYS);
	pp_off = I915_READ(PCH_PP_OFF_DELAYS);
	pp_div = I915_READ(PCH_PP_DIVISOR);
d3498 1
a3498 1
	vbt = dev_priv->edp.pps;
d3552 15
a3566 1
	u32 pp_on, pp_off, pp_div;
d3575 1
a3575 2
	pp_div = ((100 * intel_pch_rawclk(dev))/2 - 1)
			<< PP_REFERENCE_DIVIDER_SHIFT;
d3581 3
a3583 3
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev)) {
		if (is_cpu_edp(intel_dp))
			pp_on |= PANEL_POWER_PORT_DP_A;
d3585 6
a3590 1
			pp_on |= PANEL_POWER_PORT_DP_D;
d3593 5
a3597 3
	I915_WRITE(PCH_PP_ON_DELAYS, pp_on);
	I915_WRITE(PCH_PP_OFF_DELAYS, pp_off);
	I915_WRITE(PCH_PP_DIVISOR, pp_div);
d3600 78
a3677 3
		      I915_READ(PCH_PP_ON_DELAYS),
		      I915_READ(PCH_PP_OFF_DELAYS),
		      I915_READ(PCH_PP_DIVISOR));
d3680 1
a3680 1
void
a3688 2
	struct drm_display_mode *fixed_mode = NULL;
	struct edp_power_seq power_seq = { 0 };
d3691 1
a3691 1
	int type;
d3697 4
a3700 3
	if (HAS_PCH_SPLIT(dev) && port == PORT_D)
		if (intel_dpd_is_edp(dev))
			intel_dp->is_pch_edp = true;
d3703 3
a3705 2
	 * FIXME : We need to initialize built-in panels before external panels.
	 * For X0, DP_C is fixed as eDP. Revisit this as part of VLV eDP cleanup
d3707 1
a3707 2
	if (IS_VALLEYVIEW(dev) && port == PORT_C) {
		type = DRM_MODE_CONNECTOR_eDP;
d3709 4
a3712 10
	} else if (port == PORT_A || is_pch_edp(intel_dp)) {
		type = DRM_MODE_CONNECTOR_eDP;
		intel_encoder->type = INTEL_OUTPUT_EDP;
	} else {
		/* The intel_encoder->type value may be INTEL_OUTPUT_UNKNOWN for
		 * DDI or INTEL_OUTPUT_DISPLAYPORT for the older gens, so don't
		 * rewrite it.
		 */
		type = DRM_MODE_CONNECTOR_DisplayPort;
	}
a3716 1
	connector->polled = DRM_CONNECTOR_POLL_HPD;
d3730 1
d3732 19
d3755 1
d3759 1
a3759 1
		dev_priv->hotplug_supported_mask |= DPB_HOTPLUG_INT_STATUS;
d3763 1
a3763 1
		dev_priv->hotplug_supported_mask |= DPC_HOTPLUG_INT_STATUS;
d3767 1
a3767 1
		dev_priv->hotplug_supported_mask |= DPD_HOTPLUG_INT_STATUS;
d3771 1
a3771 2
		WARN(1, "Invalid port %c\n", port_name(port));
		break;
d3774 3
a3776 2
	if (is_edp(intel_dp))
		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
d3778 1
a3778 1
	intel_dp_i2c_init(intel_dp, intel_connector, name);
d3780 9
a3788 21
	/* Cache DPCD and EDID for edp. */
	if (is_edp(intel_dp)) {
		bool ret;
		struct drm_display_mode *scan;
		struct edid *edid;

		ironlake_edp_panel_vdd_on(intel_dp);
		ret = intel_dp_get_dpcd(intel_dp);
		ironlake_edp_panel_vdd_off(intel_dp, false);

		if (ret) {
			if (intel_dp->dpcd[DP_DPCD_REV] >= 0x11)
				dev_priv->no_aux_handshake =
					intel_dp->dpcd[DP_MAX_DOWNSPREAD] &
					DP_NO_AUX_HANDSHAKE_LINK_TRAINING;
		} else {
			/* if this fails, presume the device is a ghost */
			DRM_INFO("failed to retrieve link info, disabling eDP\n");
			intel_dp_encoder_destroy(&intel_encoder->base);
			intel_dp_destroy(connector);
			return;
d3790 3
a3792 41

		/* We now know it's not a ghost, init power sequence regs. */
		intel_dp_init_panel_power_sequencer_registers(dev, intel_dp,
							      &power_seq);

		ironlake_edp_panel_vdd_on(intel_dp);
		edid = drm_get_edid(connector, &intel_dp->adapter);
		if (edid) {
			if (drm_add_edid_modes(connector, edid)) {
				drm_mode_connector_update_edid_property(connector, edid);
				drm_edid_to_eld(connector, edid);
			} else {
				kfree(edid);
				edid = ERR_PTR(-EINVAL);
			}
		} else {
			edid = ERR_PTR(-ENOENT);
		}
		intel_connector->edid = edid;

		/* prefer fixed mode from EDID if available */
		list_for_each_entry(scan, &connector->probed_modes, head) {
			if ((scan->type & DRM_MODE_TYPE_PREFERRED)) {
				fixed_mode = drm_mode_duplicate(dev, scan);
				break;
			}
		}

		/* fallback to VBT if available for eDP */
		if (!fixed_mode && dev_priv->lfp_lvds_vbt_mode) {
			fixed_mode = drm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);
			if (fixed_mode)
				fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
		}

		ironlake_edp_panel_vdd_off(intel_dp, false);
	}

	if (is_edp(intel_dp)) {
		intel_panel_init(&intel_connector->panel, fixed_mode);
		intel_panel_setup_backlight(connector);
d3805 2
d3817 1
a3817 1
	intel_dig_port = kzalloc(sizeof(struct intel_digital_port), GFP_KERNEL);
d3821 1
a3821 1
	intel_connector = kzalloc(sizeof(struct intel_connector), GFP_KERNEL);
a3831 1
	drm_encoder_helper_add(&intel_encoder->base, &intel_dp_helper_funcs);
d3833 2
a3834 2
	intel_encoder->enable = intel_enable_dp;
	intel_encoder->pre_enable = intel_pre_enable_dp;
d3838 9
d3856 5
a3860 1
	intel_dp_init_connector(intel_dig_port, intel_connector);
@


1.24
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.23 2015/04/06 10:56:37 jsg Exp $	*/
d1107 1
a1107 1
static void ironlake_panel_vdd_work(void *arg1)
d1109 2
a1110 1
	struct intel_dp *intel_dp = arg1;
a1117 8
static void
ironlake_panel_vdd_tick(void *arg)
{
	struct intel_dp *intel_dp = arg;

	task_add(systq, &intel_dp->panel_vdd_task);
}

d1136 2
a1137 1
		timeout_add_msec(&intel_dp->panel_vdd_to, intel_dp->panel_power_cycle_delay * 5);
d2537 1
a2537 2
		timeout_del(&intel_dp->panel_vdd_to);
		task_del(systq, &intel_dp->panel_vdd_task);
d2804 2
a2805 2
	task_set(&intel_dp->panel_vdd_task, ironlake_panel_vdd_work, intel_dp);
	timeout_set(&intel_dp->panel_vdd_to, ironlake_panel_vdd_tick, intel_dp);
@


1.23
log
@add/use some more errno remapping
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.22 2015/02/10 03:39:41 jsg Exp $	*/
a1002 1
	int retries;
d1009 1
a1009 6
	for (retries = 5000; retries > 0; retries--) {
		if ((I915_READ(PCH_PP_STATUS) & mask) == value)
			break;
		DELAY(1000);
	}
	if (retries == 0)
d1013 1
a1725 1
	int retries;
d1741 2
a1742 7
			for (retries = 100; retries > 0; retries--) {
				if (I915_READ(DP_TP_STATUS(port)) &
				    DP_TP_STATUS_IDLE_DONE)
					break;
				DELAY(100);
			}
			if (retries == 0)
@


1.22
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.21 2015/01/27 03:17:36 dlg Exp $	*/
d552 1
a552 1
			return -EIO;
d634 1
a634 1
			return -EIO;
d652 1
a652 1
			return -EIO;
d663 1
a663 1
			return -EIO;
d670 1
a670 1
			return -EIO;
d675 1
a675 1
	return -EIO;
@


1.21
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.20 2014/06/19 06:51:05 jsg Exp $	*/
d1117 1
a1117 1
	rw_enter_write(&dev->mode_config.rwl);
d1119 1
a1119 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.20
log
@drm/i915: fix lane bandwidth capping for DP 1.2 sinks

DP 1.2 compatible displays may report a 5.4Gbps maximum bandwidth which
the driver will treat as an invalid value and use 1.62Gbps instead. Fix
this by capping to 2.7Gbps for sinks reporting a 5.4Gbps max bw.

Also add a warning for reserved values.

From Imre Deak
d4eead50eb206b875f54f66cc0f6ec7d54122c28 in mainline linux

One of two backported commits to prevent a black screen
on a Lenovo IdeaPad Yoga 2 Pro as reported/debugged by Steven Wilson.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.19 2014/06/19 06:44:00 jsg Exp $	*/
d1112 1
a1112 1
static void ironlake_panel_vdd_work(void *arg1, void *arg2)
d2822 1
a2822 2
	task_set(&intel_dp->panel_vdd_task, ironlake_panel_vdd_work, intel_dp,
	    NULL);
@


1.19
log
@drm/i915: kill intel_dp_link_clock()

Use drm_dp_bw_code_to_link_rate insead. It's the same thing, but
supports DP_LINK_BW_5_4 and is also used by the other drivers.

From Paulo Zanoni
9fa5f6522e6eecb5ab20192a264a29ba4f2f4e85 in mainline linux

One of two backported commits to prevent a black screen
on a Lenovo IdeaPad Yoga 2 Pro as reported/debugged by Steven Wilson.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.18 2014/03/30 01:10:36 jsg Exp $	*/
d142 3
d146 2
@


1.18
log
@drm/i915/dp: add native aux defer retry limit

From Jani Nikula
b4cdadf2591e12c61f895556cf93a8b61a36892c in ubuntu 3.8
f51a44b9a6c4982cc25bfb3727de9bb893621ebc in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.17 2014/03/30 01:06:31 jsg Exp $	*/
a148 9
static int
intel_dp_link_clock(uint8_t link_bw)
{
	if (link_bw == DP_LINK_BW_2_7)
		return 270000;
	else
		return 162000;
}

d183 2
a184 1
	int max_link_clock = intel_dp_link_clock(intel_dp_max_link_bw(intel_dp));
d740 4
a743 1
			int link_avail = intel_dp_max_data_rate(intel_dp_link_clock(bws[clock]), lane_count);
d748 1
a748 1
				adjusted_mode->clock = intel_dp_link_clock(intel_dp->link_bw);
@


1.17
log
@drm/i915/dp: increase native aux defer retry timeout

From Jani Nikula
6048560066737a87621b9169ef4bdab0e3cef620 in ubuntu 3.8
04eada25d1f72efdecd32d702706594f81de65d5 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.16 2014/02/18 02:48:57 jsg Exp $	*/
d494 1
d505 1
a505 1
	for (;;) {
d510 1
a510 1
			break;
d516 3
a518 1
	return send_bytes;
d540 1
d551 1
a551 1
	for (;;) {
d568 3
@


1.16
log
@drm/i915: VLV2 - Fix hotplug detect bits

From Todd Previte
080caf7f5b0d025c2e19f2f516da634d020ba70f in ubuntu 3.8
232a6ee9af8adb185640f67fcaaa9014a9aa0573 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.15 2014/02/02 01:06:21 jsg Exp $	*/
d511 1
a511 1
			udelay(100);
d560 1
a560 1
			udelay(100);
@


1.15
log
@drm/i915/dp: increase i2c-over-aux retry interval on AUX DEFER

From Jani Nikula
67c729e64ef03476312fc9fb815046d5e540428a in ubuntu 3.8
8d16f258217f2f583af1fd57c5144aa4bbe73e48 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.14 2014/01/23 10:42:57 jsg Exp $	*/
d2272 28
a2299 12
	switch (intel_dp->output_reg) {
	case DP_B:
		bit = DPB_HOTPLUG_LIVE_STATUS;
		break;
	case DP_C:
		bit = DPC_HOTPLUG_LIVE_STATUS;
		break;
	case DP_D:
		bit = DPD_HOTPLUG_LIVE_STATUS;
		break;
	default:
		return connector_status_unknown;
@


1.14
log
@drm/i915: add HAS_DDI check

From Paulo Zanoni
d99994528e9946a78a505ca752fa3b73aa8c5a76 in ubuntu 3.8
affa935440733a79c5a9eb0e5357e2564ca4b355 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.13 2014/01/22 05:16:55 kettenis Exp $	*/
d632 12
a643 1
			udelay(100);
@


1.13
log
@Provide inline dummy implementations of drm_sysfs_connector_add() and
drm_sysfs_connector_remove() and call those instead of #ifdef'ing them out.
Reduces the noise when diffing against Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.12 2014/01/22 04:04:53 kettenis Exp $	*/
d382 1
a382 1
		if (IS_HASWELL(dev))
d1826 1
a1826 1
	if (IS_HASWELL(dev))
d2016 1
a2016 1
	if (IS_HASWELL(dev))
d2795 1
a2795 1
	if (IS_HASWELL(dev))
@


1.12
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.11 2014/01/21 08:57:22 kettenis Exp $	*/
a2504 1
#ifdef notyet
a2505 1
#endif
a2792 1
#ifdef notyet
a2793 1
#endif
@


1.11
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.10 2013/10/30 02:11:33 dlg Exp $	*/
d391 1
a391 1
		aux_clock_divider = howmany(intel_pch_rawclk(dev), 2);
d2684 1
a2684 1
#define get_delay(field)	(howmany(final.field, 10))
d2720 1
a2720 1
	pp_div |= (howmany(seq->t11_t12, 1000)
@


1.10
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.9 2013/10/29 06:30:57 jsg Exp $	*/
d2296 1
a2296 1
		edid = malloc(size, M_DRM, M_WAITOK);
d2369 1
a2369 1
			free(edid, M_DRM);
d2415 1
a2415 1
		free(edid, M_DRM);
d2500 1
a2500 1
		free(intel_connector->edid, M_DRM);
d2509 1
a2509 1
	free(connector, M_DRM);
d2526 1
a2526 1
	free(intel_dig_port, M_DRM);
d2866 1
a2866 1
				free(edid, M_DRM);
d2917 1
a2917 2
	intel_dig_port = malloc(sizeof(struct intel_digital_port), M_DRM,
	    M_WAITOK | M_ZERO);
d2921 1
a2921 2
	intel_connector = malloc(sizeof(struct intel_connector), M_DRM,
	    M_WAITOK | M_ZERO);
d2923 1
a2923 1
		free(intel_dig_port, M_DRM);
@


1.9
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.8 2013/08/13 10:23:51 jsg Exp $	*/
d1109 1
a1109 1
	task_add(taskq_systq(), &intel_dp->panel_vdd_task);
d2523 1
a2523 1
		task_del(taskq_systq(), &intel_dp->panel_vdd_task);
@


1.8
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.7 2013/07/08 09:47:45 jsg Exp $	*/
d1109 1
a1109 2
	workq_queue_task(NULL, &intel_dp->panel_vdd_task, 0,
	    ironlake_panel_vdd_work, intel_dp, NULL);
d2523 1
d2790 2
@


1.7
log
@make use of udelay to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.6 2013/07/05 07:20:27 jsg Exp $	*/
a38 120
struct intel_dp_m_n {
	uint32_t	tu;
	uint32_t	gmch_m;
	uint32_t	gmch_n;
	uint32_t	link_m;
	uint32_t	link_n;
};

bool	 is_edp(struct intel_dp *);
bool	 is_pch_edp(struct intel_dp *);
bool	 is_cpu_edp(struct intel_dp *);
struct intel_dp	*enc_to_intel_dp(struct drm_encoder *);
struct intel_dp *intel_attached_dp(struct drm_connector *);
int	 intel_dp_max_lane_count(struct intel_dp *);
int	 intel_dp_max_link_bw(struct intel_dp *);
int	 intel_dp_link_clock(uint8_t);
int	 intel_dp_link_required(int, int);
int	 intel_dp_max_data_rate(int, int);
bool	 intel_dp_adjust_dithering(struct intel_dp *,
	     struct drm_display_mode *, bool);
int	 intel_dp_mode_valid(struct drm_connector *, struct drm_display_mode *);
uint32_t pack_aux(uint8_t *, int);
void	 unpack_aux(uint32_t, uint8_t *, int);
int	 intel_hrawclk(struct drm_device *);
bool	 ironlake_edp_have_panel_power(struct intel_dp *);
bool	 ironlake_edp_have_panel_vdd(struct intel_dp *);
void	 intel_dp_check_edp(struct intel_dp *);
int	 intel_dp_aux_ch(struct intel_dp *, uint8_t *, int, uint8_t *, int);
int	 intel_dp_aux_native_write(struct intel_dp *, uint16_t, uint8_t *,
	     int);
int	 intel_dp_aux_native_write_1(struct intel_dp *, uint16_t, uint8_t);
int	 intel_dp_aux_native_read(struct intel_dp *, uint16_t, uint8_t *, int);
int	 intel_dp_i2c_init(struct intel_dp *, struct intel_connector *,
	     const char *);
bool	 intel_dp_mode_fixup(struct drm_encoder *, const struct drm_display_mode *,
	     struct drm_display_mode *);
void	 intel_reduce_ratio(uint32_t *, uint32_t *);
void	 intel_dp_compute_m_n(int, int, int, int, struct intel_dp_m_n *);
void	 intel_dp_set_m_n(struct drm_crtc *, struct drm_display_mode *,
	     struct drm_display_mode *);
void	 intel_dp_mode_set(struct drm_encoder *, struct drm_display_mode *,
	     struct drm_display_mode *);
void	 ironlake_wait_panel_status(struct intel_dp *, u32, u32);
void	 ironlake_wait_panel_on(struct intel_dp *);
void	 ironlake_wait_panel_off(struct intel_dp *);
void	 ironlake_wait_panel_power_cycle(struct intel_dp *);
u32	 ironlake_get_pp_control(struct drm_i915_private *);
void	 ironlake_edp_panel_vdd_on(struct intel_dp *);
void	 ironlake_panel_vdd_off_sync(struct intel_dp *);
void	 ironlake_edp_panel_vdd_off(struct intel_dp *, bool);
void	 ironlake_edp_panel_on(struct intel_dp *);
void	 ironlake_edp_panel_off(struct intel_dp *);
void	 ironlake_edp_backlight_on(struct intel_dp *);
void	 ironlake_edp_backlight_off(struct intel_dp *);
void	 ironlake_edp_pll_on(struct intel_dp *);
void	 ironlake_edp_pll_off(struct intel_dp *);
void	 intel_dp_sink_dpms(struct intel_dp *, int);
void	 intel_dp_prepare(struct drm_encoder *);
void	 intel_dp_commit(struct drm_encoder *);
void	 intel_dp_start_link_train(struct intel_dp *);
void	 intel_dp_complete_link_train(struct intel_dp *);
void	 intel_dp_dpms(struct drm_encoder *, int);
bool	 intel_dp_aux_native_read_retry(struct intel_dp *, uint16_t, uint8_t *,
	     int);
bool	 intel_dp_get_link_status(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
uint8_t	 intel_dp_link_status(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
uint8_t	 intel_get_adjust_request_voltage(uint8_t adjust_request[2], int);
uint8_t	 intel_get_adjust_request_pre_emphasis(uint8_t adjust_request[2], int);
uint8_t	 intel_dp_voltage_max(struct intel_dp *);
uint8_t	 intel_dp_pre_emphasis_max(struct intel_dp *, uint8_t);
void	 intel_get_adjust_train(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
uint32_t intel_dp_signal_levels(uint8_t);
uint32_t intel_gen6_edp_signal_levels(uint8_t);
uint32_t intel_gen7_edp_signal_levels(uint8_t);
uint8_t	 intel_get_lane_status(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
bool	 intel_clock_recovery_ok(uint8_t link_status[DP_LINK_STATUS_SIZE], int);
bool	 intel_channel_eq_ok(struct intel_dp *,
	     uint8_t link_status[DP_LINK_STATUS_SIZE]);
bool	 intel_dp_set_link_train(struct intel_dp *, uint32_t, uint8_t);
void	 intel_dp_start_link_train(struct intel_dp *);
void	 intel_dp_complete_link_train(struct intel_dp *);
void	 intel_dp_link_down(struct intel_dp *);
bool	 intel_dp_get_dpcd(struct intel_dp *);
bool	 intel_dp_get_sink_irq(struct intel_dp *, u8 *);
void	 intel_dp_handle_test_request(struct intel_dp *);
void	 intel_dp_check_link_status(struct intel_dp *);
enum drm_connector_status	 intel_dp_detect_dpcd(struct intel_dp *);
enum drm_connector_status	 ironlake_dp_detect(struct intel_dp *);
enum drm_connector_status	 g4x_dp_detect(struct intel_dp *);
struct edid	*intel_dp_get_edid(struct drm_connector *,
		     struct i2c_controller *);
int	 intel_dp_get_edid_modes(struct drm_connector *,
	     struct i2c_controller *);
enum drm_connector_status	 intel_dp_detect(struct drm_connector *, bool);
int	 intel_dp_get_modes(struct drm_connector *);
bool	 intel_dp_detect_audio(struct drm_connector *);
int	 intel_dp_set_property(struct drm_connector *, struct drm_property *,
	     uint64_t);
void	 intel_dp_destroy(struct drm_connector *);
void	 intel_dp_encoder_destroy(struct drm_encoder *);
void	 intel_dp_hot_plug(struct intel_encoder *);
void	 intel_dp_add_properties(struct intel_dp *, struct drm_connector *);
struct drm_device *intel_dp_to_dev(struct intel_dp *);
bool	 intel_dp_get_hw_state(struct intel_encoder *, enum pipe *);
void	 intel_disable_dp(struct intel_encoder *);
void	 intel_post_disable_dp(struct intel_encoder *);
void	 intel_enable_dp(struct intel_encoder *);
void	 intel_pre_enable_dp(struct intel_encoder *);
uint32_t intel_dp_signal_levels_hsw(uint8_t);
void	 intel_dp_probe_oui(struct intel_dp *);
void	 intel_dp_init_panel_power_sequencer(struct drm_device *,
	     struct intel_dp *, struct edp_power_seq *);
void	 intel_dp_init_panel_power_sequencer_registers(struct drm_device *,
	     struct intel_dp *, struct edp_power_seq *);
void	 ironlake_panel_vdd_tick(void *);
void	 ironlake_panel_vdd_work(void *, void *);
int	 intel_dp_i2c_aux_ch(struct i2c_controller *, int, uint8_t, uint8_t *);

d46 1
a46 2
bool
is_edp(struct intel_dp *intel_dp)
d61 1
a61 2
bool
is_pch_edp(struct intel_dp *intel_dp)
d72 1
a72 2
bool
is_cpu_edp(struct intel_dp *intel_dp)
d77 1
a77 2
struct drm_device *
intel_dp_to_dev(struct intel_dp *intel_dp)
d84 1
a84 2
struct intel_dp *
intel_attached_dp(struct drm_connector *connector)
d96 1
a96 2
bool
intel_encoder_is_pch_edp(struct drm_encoder *encoder)
d108 2
d133 1
a133 1
int
d149 1
a149 1
int
d175 1
a175 1
int
d181 1
a181 1
int
d187 1
a187 1
bool
d214 1
a214 1
int
d242 1
a242 1
uint32_t
d255 1
a255 1
void
d266 1
a266 1
int
d299 1
a299 2
bool
ironlake_edp_have_panel_power(struct intel_dp *intel_dp)
d307 1
a307 2
bool
ironlake_edp_have_panel_vdd(struct intel_dp *intel_dp)
d315 1
a315 1
void
d333 1
a333 1
int
d486 1
a486 1
int
d519 1
a519 1
int
d527 1
a527 1
int
d566 1
a566 1
int
d663 1
a663 1
int
d750 9
a758 1
void
d767 1
a767 1
void
d854 1
a854 2
void
intel_dp_init_link_config(struct intel_dp *intel_dp)
d869 1
a869 1
void
d979 1
a979 2
void
ironlake_wait_panel_status(struct intel_dp *intel_dp,
d1003 1
a1003 2
void
ironlake_wait_panel_on(struct intel_dp *intel_dp)
d1009 1
a1009 2
void
ironlake_wait_panel_off(struct intel_dp *intel_dp)
d1015 1
a1015 2
void
ironlake_wait_panel_power_cycle(struct intel_dp *intel_dp)
d1026 1
a1026 2
u32
ironlake_get_pp_control(struct drm_i915_private *dev_priv)
d1035 1
a1035 2
void
ironlake_edp_panel_vdd_on(struct intel_dp *intel_dp)
d1074 1
a1074 2
void
ironlake_panel_vdd_off_sync(struct intel_dp *intel_dp)
d1094 1
a1094 11
void
ironlake_panel_vdd_tick(void *arg)
{
	struct intel_dp *intel_dp = arg;

	workq_queue_task(NULL, &intel_dp->panel_vdd_task, 0,
	    ironlake_panel_vdd_work, intel_dp, NULL);
}

void
ironlake_panel_vdd_work(void *arg1, void *arg2)
d1104 10
a1113 2
void
ironlake_edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync)
d1135 1
a1135 2
void
ironlake_edp_panel_on(struct intel_dp *intel_dp)
d1177 1
a1177 2
void
ironlake_edp_panel_off(struct intel_dp *intel_dp)
d1202 1
a1202 2
void
ironlake_edp_backlight_on(struct intel_dp *intel_dp)
d1229 1
a1229 2
void
ironlake_edp_backlight_off(struct intel_dp *intel_dp)
d1248 1
a1248 2
void
ironlake_edp_pll_on(struct intel_dp *intel_dp)
d1274 1
a1274 2
void
ironlake_edp_pll_off(struct intel_dp *intel_dp)
d1300 1
a1300 2
void
intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode)
d1329 1
a1329 2
bool
intel_dp_get_hw_state(struct intel_encoder *encoder,
d1378 1
a1378 2
void
intel_disable_dp(struct intel_encoder *encoder)
d1394 1
a1394 2
void
intel_post_disable_dp(struct intel_encoder *encoder)
d1404 1
a1404 2
void
intel_enable_dp(struct intel_encoder *encoder)
d1423 1
a1423 2
void
intel_pre_enable_dp(struct intel_encoder *encoder)
d1435 1
a1435 1
bool
d1460 1
a1460 1
bool
d1486 1
a1486 1
uint8_t
d1499 1
a1499 1
uint8_t
d1541 1
a1541 1
void
d1572 1
a1572 1
uint32_t
d1611 1
a1611 1
uint32_t
d1639 1
a1639 1
uint32_t
d1670 1
a1670 1
uint32_t
d1703 1
a1703 1
bool
d1994 1
a1994 1
void
d2075 1
a2075 1
bool
d2100 1
a2100 1
void
d2121 1
a2121 1
bool
d2135 1
a2135 1
void
d2199 1
a2199 1
enum drm_connector_status
d2238 1
a2238 1
enum drm_connector_status
d2255 1
a2255 1
enum drm_connector_status
d2282 1
a2282 1
struct edid *
d2308 1
a2308 1
int
d2333 1
a2333 1
enum drm_connector_status
d2379 1
a2379 2
int
intel_dp_get_modes(struct drm_connector *connector)
d2406 1
a2406 1
bool
d2422 1
a2422 1
int
d2494 1
a2494 1
void
d2513 1
a2513 2
void
intel_dp_encoder_destroy(struct drm_encoder *encoder)
d2553 1
a2553 1
void
d2581 1
a2581 2
bool
intel_dpd_is_edp(struct drm_device *dev)
d2600 1
a2600 1
void
d2618 1
a2618 1
void
d2703 1
a2703 1
void
@


1.6
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.5 2013/07/04 09:55:01 jsg Exp $	*/
d561 1
a561 1
			DELAY(100);
d637 1
a637 1
			DELAY(100);
d686 1
a686 1
			DELAY(100);
d758 1
a758 1
			DELAY(100);
d777 1
a777 1
			DELAY(100);
d1404 1
a1404 1
	DELAY(200);
d1430 1
a1430 1
	DELAY(200);
@


1.5
log
@ensure single initialization and cleanup of backlight device
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.4 2013/04/08 05:46:12 jsg Exp $	*/
d85 1
a85 1
u32	 ironlake_get_pp_control(struct inteldrm_softc *);
d393 1
a393 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d427 1
a427 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d436 1
a436 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d446 1
a446 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d467 1
a467 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d908 1
a908 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d993 1
a993 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1104 1
a1104 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1150 1
a1150 1
ironlake_get_pp_control(struct inteldrm_softc *dev_priv)
d1163 1
a1163 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1203 1
a1203 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1267 1
a1267 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1310 1
a1310 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1337 1
a1337 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1364 1
a1364 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1386 1
a1386 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1413 1
a1413 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1470 1
a1470 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1547 1
a1547 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d1850 1
a1850 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2139 1
a2139 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2399 1
a2399 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2568 1
a2568 1
	struct inteldrm_softc *dev_priv = connector->dev->dev_private;
d2726 1
a2726 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2766 1
a2766 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2851 1
a2851 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d2893 1
a2893 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.4
log
@Use the fixed pixel clock for eDP in intel_dp_set_m_n()
from linux 3.8.6
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.3 2013/04/04 21:26:19 kettenis Exp $	*/
a2637 1
	struct drm_device *dev = connector->dev;
d2644 1
a2644 2
	if (is_edp(intel_dp)) {
		intel_panel_destroy_backlight(dev);
a2645 1
	}
@


1.3
log
@The intel_dp_i2c_aux_ch() function has to return Linux-style negative errno
values.  Its callers assume a positive return value means the function was
successful.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.2 2013/04/03 05:29:06 jsg Exp $	*/
d914 1
d930 9
d945 1
a945 1
			     mode->clock, adjusted_mode->clock, &m_n);
@


1.2
log
@match linux 3.8.5 and backout the 'try to train DP even harder' commit
which introduced a bogus check that could lead to an infinite loop
in some eDP setups.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_dp.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d756 1
a756 1
			return EIO;
d763 1
a763 1
			return EIO;
d774 1
a774 1
			return EIO;
d781 1
a781 1
			return EIO;
d786 1
a786 1
	return EIO;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2016 1
a2016 1
		if (i == intel_dp->lane_count && voltage_tries == 5) {
@

