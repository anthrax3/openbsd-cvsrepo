head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.5.0.6
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.10
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.9;
commitid	KnwRPOZok9A30HI4;

1.9
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	lQlppvmETCN49oZe;

1.8
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.7;
commitid	c1fUeeFWMNg4COgR;

1.7
date	2015.04.12.05.31.23;	author jsg;	state Exp;
branches;
next	1.6;
commitid	09jvnnyFAQrVbK5f;

1.6
date	2015.04.06.10.56.37;	author jsg;	state Exp;
branches;
next	1.5;
commitid	YRwUkzqVtigPPQbt;

1.5
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2013.08.13.10.23.51;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.21.08.27.32;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright 2008 Intel Corporation <hong.liu@@intel.com>
 * Copyright 2008 Red Hat <mjg@@redhat.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NON-INFRINGEMENT.  IN NO EVENT SHALL INTEL AND/OR ITS SUPPLIERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#ifdef __linux__
#include <linux/acpi.h>
#include <acpi/video.h>
#endif

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#include "intel_drv.h"

#define PCI_ASLE		0xe4
#define PCI_ASLS		0xfc
#define PCI_SWSCI		0xe8
#define PCI_SWSCI_SCISEL	(1 << 15)
#define PCI_SWSCI_GSSCIE	(1 << 0)

#define OPREGION_HEADER_OFFSET 0
#define OPREGION_ACPI_OFFSET   0x100
#define   ACPI_CLID 0x01ac /* current lid state indicator */
#define   ACPI_CDCK 0x01b0 /* current docking state indicator */
#define OPREGION_SWSCI_OFFSET  0x200
#define OPREGION_ASLE_OFFSET   0x300
#define OPREGION_VBT_OFFSET    0x400

#define OPREGION_SIGNATURE "IntelGraphicsMem"
#define MBOX_ACPI      (1<<0)
#define MBOX_SWSCI     (1<<1)
#define MBOX_ASLE      (1<<2)
#define MBOX_ASLE_EXT  (1<<4)

struct opregion_header {
	u8 signature[16];
	u32 size;
	u32 opregion_ver;
	u8 bios_ver[32];
	u8 vbios_ver[16];
	u8 driver_ver[16];
	u32 mboxes;
	u32 driver_model;
	u32 pcon;
	u8 dver[32];
	u8 rsvd[124];
} __packed;

/* OpRegion mailbox #1: public ACPI methods */
struct opregion_acpi {
	u32 drdy;       /* driver readiness */
	u32 csts;       /* notification status */
	u32 cevt;       /* current event */
	u8 rsvd1[20];
	u32 didl[8];    /* supported display devices ID list */
	u32 cpdl[8];    /* currently presented display list */
	u32 cadl[8];    /* currently active display list */
	u32 nadl[8];    /* next active devices list */
	u32 aslp;       /* ASL sleep time-out */
	u32 tidx;       /* toggle table index */
	u32 chpd;       /* current hotplug enable indicator */
	u32 clid;       /* current lid state*/
	u32 cdck;       /* current docking state */
	u32 sxsw;       /* Sx state resume */
	u32 evts;       /* ASL supported events */
	u32 cnot;       /* current OS notification */
	u32 nrdy;       /* driver status */
	u32 did2[7];	/* extended supported display devices ID list */
	u32 cpd2[7];	/* extended attached display devices list */
	u8 rsvd2[4];
} __packed;

/* OpRegion mailbox #2: SWSCI */
struct opregion_swsci {
	u32 scic;       /* SWSCI command|status|data */
	u32 parm;       /* command parameters */
	u32 dslp;       /* driver sleep time-out */
	u8 rsvd[244];
} __packed;

/* OpRegion mailbox #3: ASLE */
struct opregion_asle {
	u32 ardy;       /* driver readiness */
	u32 aslc;       /* ASLE interrupt command */
	u32 tche;       /* technology enabled indicator */
	u32 alsi;       /* current ALS illuminance reading */
	u32 bclp;       /* backlight brightness to set */
	u32 pfit;       /* panel fitting state */
	u32 cblv;       /* current brightness level */
	u16 bclm[20];   /* backlight level duty cycle mapping table */
	u32 cpfm;       /* current panel fitting mode */
	u32 epfm;       /* enabled panel fitting modes */
	u8 plut[74];    /* panel LUT and identifier */
	u32 pfmb;       /* PWM freq and min brightness */
	u32 cddv;       /* color correction default values */
	u32 pcft;       /* power conservation features */
	u32 srot;       /* supported rotation angles */
	u32 iuer;       /* IUER events */
	u64 fdss;
	u32 fdsp;
	u32 stat;
	u8 rsvd[70];
} __packed;

/* Driver readiness indicator */
#define ASLE_ARDY_READY		(1 << 0)
#define ASLE_ARDY_NOT_READY	(0 << 0)

/* ASLE Interrupt Command (ASLC) bits */
#define ASLC_SET_ALS_ILLUM		(1 << 0)
#define ASLC_SET_BACKLIGHT		(1 << 1)
#define ASLC_SET_PFIT			(1 << 2)
#define ASLC_SET_PWM_FREQ		(1 << 3)
#define ASLC_SUPPORTED_ROTATION_ANGLES	(1 << 4)
#define ASLC_BUTTON_ARRAY		(1 << 5)
#define ASLC_CONVERTIBLE_INDICATOR	(1 << 6)
#define ASLC_DOCKING_INDICATOR		(1 << 7)
#define ASLC_ISCT_STATE_CHANGE		(1 << 8)
#define ASLC_REQ_MSK			0x1ff
/* response bits */
#define ASLC_ALS_ILLUM_FAILED		(1 << 10)
#define ASLC_BACKLIGHT_FAILED		(1 << 12)
#define ASLC_PFIT_FAILED		(1 << 14)
#define ASLC_PWM_FREQ_FAILED		(1 << 16)
#define ASLC_ROTATION_ANGLES_FAILED	(1 << 18)
#define ASLC_BUTTON_ARRAY_FAILED	(1 << 20)
#define ASLC_CONVERTIBLE_FAILED		(1 << 22)
#define ASLC_DOCKING_FAILED		(1 << 24)
#define ASLC_ISCT_STATE_FAILED		(1 << 26)

/* Technology enabled indicator */
#define ASLE_TCHE_ALS_EN	(1 << 0)
#define ASLE_TCHE_BLC_EN	(1 << 1)
#define ASLE_TCHE_PFIT_EN	(1 << 2)
#define ASLE_TCHE_PFMB_EN	(1 << 3)

/* ASLE backlight brightness to set */
#define ASLE_BCLP_VALID                (1<<31)
#define ASLE_BCLP_MSK          (~(1<<31))

/* ASLE panel fitting request */
#define ASLE_PFIT_VALID         (1<<31)
#define ASLE_PFIT_CENTER (1<<0)
#define ASLE_PFIT_STRETCH_TEXT (1<<1)
#define ASLE_PFIT_STRETCH_GFX (1<<2)

/* PWM frequency and minimum brightness */
#define ASLE_PFMB_BRIGHTNESS_MASK (0xff)
#define ASLE_PFMB_BRIGHTNESS_VALID (1<<8)
#define ASLE_PFMB_PWM_MASK (0x7ffffe00)
#define ASLE_PFMB_PWM_VALID (1<<31)

#define ASLE_CBLV_VALID         (1<<31)

/* IUER */
#define ASLE_IUER_DOCKING		(1 << 7)
#define ASLE_IUER_CONVERTIBLE		(1 << 6)
#define ASLE_IUER_ROTATION_LOCK_BTN	(1 << 4)
#define ASLE_IUER_VOLUME_DOWN_BTN	(1 << 3)
#define ASLE_IUER_VOLUME_UP_BTN		(1 << 2)
#define ASLE_IUER_WINDOWS_BTN		(1 << 1)
#define ASLE_IUER_POWER_BTN		(1 << 0)

/* Software System Control Interrupt (SWSCI) */
#define SWSCI_SCIC_INDICATOR		(1 << 0)
#define SWSCI_SCIC_MAIN_FUNCTION_SHIFT	1
#define SWSCI_SCIC_MAIN_FUNCTION_MASK	(0xf << 1)
#define SWSCI_SCIC_SUB_FUNCTION_SHIFT	8
#define SWSCI_SCIC_SUB_FUNCTION_MASK	(0xff << 8)
#define SWSCI_SCIC_EXIT_PARAMETER_SHIFT	8
#define SWSCI_SCIC_EXIT_PARAMETER_MASK	(0xff << 8)
#define SWSCI_SCIC_EXIT_STATUS_SHIFT	5
#define SWSCI_SCIC_EXIT_STATUS_MASK	(7 << 5)
#define SWSCI_SCIC_EXIT_STATUS_SUCCESS	1

#define SWSCI_FUNCTION_CODE(main, sub) \
	((main) << SWSCI_SCIC_MAIN_FUNCTION_SHIFT | \
	 (sub) << SWSCI_SCIC_SUB_FUNCTION_SHIFT)

/* SWSCI: Get BIOS Data (GBDA) */
#define SWSCI_GBDA			4
#define SWSCI_GBDA_SUPPORTED_CALLS	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 0)
#define SWSCI_GBDA_REQUESTED_CALLBACKS	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 1)
#define SWSCI_GBDA_BOOT_DISPLAY_PREF	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 4)
#define SWSCI_GBDA_PANEL_DETAILS	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 5)
#define SWSCI_GBDA_TV_STANDARD		SWSCI_FUNCTION_CODE(SWSCI_GBDA, 6)
#define SWSCI_GBDA_INTERNAL_GRAPHICS	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 7)
#define SWSCI_GBDA_SPREAD_SPECTRUM	SWSCI_FUNCTION_CODE(SWSCI_GBDA, 10)

/* SWSCI: System BIOS Callbacks (SBCB) */
#define SWSCI_SBCB			6
#define SWSCI_SBCB_SUPPORTED_CALLBACKS	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 0)
#define SWSCI_SBCB_INIT_COMPLETION	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 1)
#define SWSCI_SBCB_PRE_HIRES_SET_MODE	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 3)
#define SWSCI_SBCB_POST_HIRES_SET_MODE	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 4)
#define SWSCI_SBCB_DISPLAY_SWITCH	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 5)
#define SWSCI_SBCB_SET_TV_FORMAT	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 6)
#define SWSCI_SBCB_ADAPTER_POWER_STATE	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 7)
#define SWSCI_SBCB_DISPLAY_POWER_STATE	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 8)
#define SWSCI_SBCB_SET_BOOT_DISPLAY	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 9)
#define SWSCI_SBCB_SET_PANEL_DETAILS	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 10)
#define SWSCI_SBCB_SET_INTERNAL_GFX	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 11)
#define SWSCI_SBCB_POST_HIRES_TO_DOS_FS	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 16)
#define SWSCI_SBCB_SUSPEND_RESUME	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 17)
#define SWSCI_SBCB_SET_SPREAD_SPECTRUM	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 18)
#define SWSCI_SBCB_POST_VBE_PM		SWSCI_FUNCTION_CODE(SWSCI_SBCB, 19)
#define SWSCI_SBCB_ENABLE_DISABLE_AUDIO	SWSCI_FUNCTION_CODE(SWSCI_SBCB, 21)

#define ACPI_OTHER_OUTPUT (0<<8)
#define ACPI_VGA_OUTPUT (1<<8)
#define ACPI_TV_OUTPUT (2<<8)
#define ACPI_DIGITAL_OUTPUT (3<<8)
#define ACPI_LVDS_OUTPUT (4<<8)

#define MAX_DSLP	1500

#ifdef CONFIG_ACPI
static int swsci(struct drm_device *dev, u32 function, u32 parm, u32 *parm_out)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct opregion_swsci *swsci = dev_priv->opregion.swsci;
	u32 main_function, sub_function, scic;
	u16 pci_swsci;
	u32 dslp;

	if (!swsci)
		return -ENODEV;

	main_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>
		SWSCI_SCIC_MAIN_FUNCTION_SHIFT;
	sub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>
		SWSCI_SCIC_SUB_FUNCTION_SHIFT;

	/* Check if we can call the function. See swsci_setup for details. */
	if (main_function == SWSCI_SBCB) {
		if ((dev_priv->opregion.swsci_sbcb_sub_functions &
		     (1 << sub_function)) == 0)
			return -EINVAL;
	} else if (main_function == SWSCI_GBDA) {
		if ((dev_priv->opregion.swsci_gbda_sub_functions &
		     (1 << sub_function)) == 0)
			return -EINVAL;
	}

	/* Driver sleep timeout in ms. */
	dslp = swsci->dslp;
	if (!dslp) {
		/* The spec says 2ms should be the default, but it's too small
		 * for some machines. */
		dslp = 50;
	} else if (dslp > MAX_DSLP) {
		/* Hey bios, trust must be earned. */
		DRM_INFO_ONCE("ACPI BIOS requests an excessive sleep of %u ms, "
			      "using %u ms instead\n", dslp, MAX_DSLP);
		dslp = MAX_DSLP;
	}

	/* The spec tells us to do this, but we are the only user... */
	scic = swsci->scic;
	if (scic & SWSCI_SCIC_INDICATOR) {
		DRM_DEBUG_DRIVER("SWSCI request already in progress\n");
		return -EBUSY;
	}

	scic = function | SWSCI_SCIC_INDICATOR;

	swsci->parm = parm;
	swsci->scic = scic;

	/* Ensure SCI event is selected and event trigger is cleared. */
	pci_read_config_word(dev->pdev, PCI_SWSCI, &pci_swsci);
	if (!(pci_swsci & PCI_SWSCI_SCISEL) || (pci_swsci & PCI_SWSCI_GSSCIE)) {
		pci_swsci |= PCI_SWSCI_SCISEL;
		pci_swsci &= ~PCI_SWSCI_GSSCIE;
		pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);
	}

	/* Use event trigger to tell bios to check the mail. */
	pci_swsci |= PCI_SWSCI_GSSCIE;
	pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);

	/* Poll for the result. */
#define C (((scic = swsci->scic) & SWSCI_SCIC_INDICATOR) == 0)
	if (wait_for(C, dslp)) {
		DRM_DEBUG_DRIVER("SWSCI request timed out\n");
		return -ETIMEDOUT;
	}

	scic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>
		SWSCI_SCIC_EXIT_STATUS_SHIFT;

	/* Note: scic == 0 is an error! */
	if (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {
		DRM_DEBUG_DRIVER("SWSCI request error %u\n", scic);
		return -EIO;
	}

	if (parm_out)
		*parm_out = swsci->parm;

	return 0;

#undef C
}

#define DISPLAY_TYPE_CRT			0
#define DISPLAY_TYPE_TV				1
#define DISPLAY_TYPE_EXTERNAL_FLAT_PANEL	2
#define DISPLAY_TYPE_INTERNAL_FLAT_PANEL	3

int intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,
				  bool enable)
{
	struct drm_device *dev = intel_encoder->base.dev;
	u32 parm = 0;
	u32 type = 0;
	u32 port;

	/* don't care about old stuff for now */
	if (!HAS_DDI(dev))
		return 0;

	if (intel_encoder->type == INTEL_OUTPUT_DSI)
		port = 0;
	else
		port = intel_ddi_get_encoder_port(intel_encoder);

	if (port == PORT_E)  {
		port = 0;
	} else {
		parm |= 1 << port;
		port++;
	}

	if (!enable)
		parm |= 4 << 8;

	switch (intel_encoder->type) {
	case INTEL_OUTPUT_ANALOG:
		type = DISPLAY_TYPE_CRT;
		break;
	case INTEL_OUTPUT_UNKNOWN:
	case INTEL_OUTPUT_DISPLAYPORT:
	case INTEL_OUTPUT_HDMI:
	case INTEL_OUTPUT_DP_MST:
		type = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;
		break;
	case INTEL_OUTPUT_EDP:
	case INTEL_OUTPUT_DSI:
		type = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;
		break;
	default:
		WARN_ONCE(1, "unsupported intel_encoder type %d\n",
			  intel_encoder->type);
		return -EINVAL;
	}

	parm |= type << (16 + port * 3);

	return swsci(dev, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);
}

static const struct {
	pci_power_t pci_power_state;
	u32 parm;
} power_state_map[] = {
	{ PCI_D0,	0x00 },
	{ PCI_D1,	0x01 },
	{ PCI_D2,	0x02 },
	{ PCI_D3hot,	0x04 },
	{ PCI_D3cold,	0x04 },
};

int intel_opregion_notify_adapter(struct drm_device *dev, pci_power_t state)
{
	int i;

	if (!HAS_DDI(dev))
		return 0;

	for (i = 0; i < ARRAY_SIZE(power_state_map); i++) {
		if (state == power_state_map[i].pci_power_state)
			return swsci(dev, SWSCI_SBCB_ADAPTER_POWER_STATE,
				     power_state_map[i].parm, NULL);
	}

	return -EINVAL;
}

static u32 asle_set_backlight(struct drm_device *dev, u32 bclp)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_connector *intel_connector;
	struct opregion_asle *asle = dev_priv->opregion.asle;

	DRM_DEBUG_DRIVER("bclp = 0x%08x\n", bclp);

#ifdef __linux__
	if (acpi_video_get_backlight_type() == acpi_backlight_native) {
		DRM_DEBUG_KMS("opregion backlight request ignored\n");
		return 0;
	}
#endif

	if (!(bclp & ASLE_BCLP_VALID))
		return ASLC_BACKLIGHT_FAILED;

	bclp &= ASLE_BCLP_MSK;
	if (bclp > 255)
		return ASLC_BACKLIGHT_FAILED;

	drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);

	/*
	 * Update backlight on all connectors that support backlight (usually
	 * only one).
	 */
	DRM_DEBUG_KMS("updating opregion backlight %d/255\n", bclp);
	list_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head)
		intel_panel_set_backlight_acpi(intel_connector, bclp, 255);
	asle->cblv = DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID;

	drm_modeset_unlock(&dev->mode_config.connection_mutex);


	return 0;
}

static u32 asle_set_als_illum(struct drm_device *dev, u32 alsi)
{
	/* alsi is the current ALS reading in lux. 0 indicates below sensor
	   range, 0xffff indicates above sensor range. 1-0xfffe are valid */
	DRM_DEBUG_DRIVER("Illum is not supported\n");
	return ASLC_ALS_ILLUM_FAILED;
}

static u32 asle_set_pwm_freq(struct drm_device *dev, u32 pfmb)
{
	DRM_DEBUG_DRIVER("PWM freq is not supported\n");
	return ASLC_PWM_FREQ_FAILED;
}

static u32 asle_set_pfit(struct drm_device *dev, u32 pfit)
{
	/* Panel fitting is currently controlled by the X code, so this is a
	   noop until modesetting support works fully */
	DRM_DEBUG_DRIVER("Pfit is not supported\n");
	return ASLC_PFIT_FAILED;
}

static u32 asle_set_supported_rotation_angles(struct drm_device *dev, u32 srot)
{
	DRM_DEBUG_DRIVER("SROT is not supported\n");
	return ASLC_ROTATION_ANGLES_FAILED;
}

static u32 asle_set_button_array(struct drm_device *dev, u32 iuer)
{
	if (!iuer)
		DRM_DEBUG_DRIVER("Button array event is not supported (nothing)\n");
	if (iuer & ASLE_IUER_ROTATION_LOCK_BTN)
		DRM_DEBUG_DRIVER("Button array event is not supported (rotation lock)\n");
	if (iuer & ASLE_IUER_VOLUME_DOWN_BTN)
		DRM_DEBUG_DRIVER("Button array event is not supported (volume down)\n");
	if (iuer & ASLE_IUER_VOLUME_UP_BTN)
		DRM_DEBUG_DRIVER("Button array event is not supported (volume up)\n");
	if (iuer & ASLE_IUER_WINDOWS_BTN)
		DRM_DEBUG_DRIVER("Button array event is not supported (windows)\n");
	if (iuer & ASLE_IUER_POWER_BTN)
		DRM_DEBUG_DRIVER("Button array event is not supported (power)\n");

	return ASLC_BUTTON_ARRAY_FAILED;
}

static u32 asle_set_convertible(struct drm_device *dev, u32 iuer)
{
	if (iuer & ASLE_IUER_CONVERTIBLE)
		DRM_DEBUG_DRIVER("Convertible is not supported (clamshell)\n");
	else
		DRM_DEBUG_DRIVER("Convertible is not supported (slate)\n");

	return ASLC_CONVERTIBLE_FAILED;
}

static u32 asle_set_docking(struct drm_device *dev, u32 iuer)
{
	if (iuer & ASLE_IUER_DOCKING)
		DRM_DEBUG_DRIVER("Docking is not supported (docked)\n");
	else
		DRM_DEBUG_DRIVER("Docking is not supported (undocked)\n");

	return ASLC_DOCKING_FAILED;
}

static u32 asle_isct_state(struct drm_device *dev)
{
	DRM_DEBUG_DRIVER("ISCT is not supported\n");
	return ASLC_ISCT_STATE_FAILED;
}

static void asle_work(struct work_struct *work)
{
	struct intel_opregion *opregion =
		container_of(work, struct intel_opregion, asle_work);
	struct drm_i915_private *dev_priv =
		container_of(opregion, struct drm_i915_private, opregion);
	struct drm_device *dev = dev_priv->dev;
	struct opregion_asle *asle = dev_priv->opregion.asle;
	u32 aslc_stat = 0;
	u32 aslc_req;

	if (!asle)
		return;

	aslc_req = asle->aslc;

	if (!(aslc_req & ASLC_REQ_MSK)) {
		DRM_DEBUG_DRIVER("No request on ASLC interrupt 0x%08x\n",
				 aslc_req);
		return;
	}

	if (aslc_req & ASLC_SET_ALS_ILLUM)
		aslc_stat |= asle_set_als_illum(dev, asle->alsi);

	if (aslc_req & ASLC_SET_BACKLIGHT)
		aslc_stat |= asle_set_backlight(dev, asle->bclp);

	if (aslc_req & ASLC_SET_PFIT)
		aslc_stat |= asle_set_pfit(dev, asle->pfit);

	if (aslc_req & ASLC_SET_PWM_FREQ)
		aslc_stat |= asle_set_pwm_freq(dev, asle->pfmb);

	if (aslc_req & ASLC_SUPPORTED_ROTATION_ANGLES)
		aslc_stat |= asle_set_supported_rotation_angles(dev,
							asle->srot);

	if (aslc_req & ASLC_BUTTON_ARRAY)
		aslc_stat |= asle_set_button_array(dev, asle->iuer);

	if (aslc_req & ASLC_CONVERTIBLE_INDICATOR)
		aslc_stat |= asle_set_convertible(dev, asle->iuer);

	if (aslc_req & ASLC_DOCKING_INDICATOR)
		aslc_stat |= asle_set_docking(dev, asle->iuer);

	if (aslc_req & ASLC_ISCT_STATE_CHANGE)
		aslc_stat |= asle_isct_state(dev);

	asle->aslc = aslc_stat;
}

void intel_opregion_asle_intr(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev_priv->opregion.asle)
		schedule_work(&dev_priv->opregion.asle_work);
}

#define ACPI_EV_DISPLAY_SWITCH (1<<0)
#define ACPI_EV_LID            (1<<1)
#define ACPI_EV_DOCK           (1<<2)

static struct intel_opregion *system_opregion;

#ifdef notyet

static int intel_opregion_video_event(struct notifier_block *nb,
				      unsigned long val, void *data)
{
	/* The only video events relevant to opregion are 0x80. These indicate
	   either a docking event, lid switch or display switch request. In
	   Linux, these are handled by the dock, button and video drivers.
	*/

	struct acpi_bus_event *event = data;
	struct opregion_acpi *acpi;
	int ret = NOTIFY_OK;

	if (strcmp(event->device_class, ACPI_VIDEO_CLASS) != 0)
		return NOTIFY_DONE;

	if (!system_opregion)
		return NOTIFY_DONE;

	acpi = system_opregion->acpi;

	if (event->type == 0x80 && ((acpi->cevt & 1) == 0))
		ret = NOTIFY_BAD;

	acpi->csts = 0;

	return ret;
}

static struct notifier_block intel_opregion_notifier = {
	.notifier_call = intel_opregion_video_event,
};

/*
 * Initialise the DIDL field in opregion. This passes a list of devices to
 * the firmware. Values are defined by section B.4.2 of the ACPI specification
 * (version 3)
 */

static u32 get_did(struct intel_opregion *opregion, int i)
{
	u32 did;

	if (i < ARRAY_SIZE(opregion->acpi->didl)) {
		did = opregion->acpi->didl[i];
	} else {
		i -= ARRAY_SIZE(opregion->acpi->didl);

		if (WARN_ON(i >= ARRAY_SIZE(opregion->acpi->did2)))
			return 0;

		did = opregion->acpi->did2[i];
	}

	return did;
}

static void set_did(struct intel_opregion *opregion, int i, u32 val)
{
	if (i < ARRAY_SIZE(opregion->acpi->didl)) {
		opregion->acpi->didl[i] = val;
	} else {
		i -= ARRAY_SIZE(opregion->acpi->didl);

		if (WARN_ON(i >= ARRAY_SIZE(opregion->acpi->did2)))
			return;

		opregion->acpi->did2[i] = val;
	}
}

static void intel_didl_outputs(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;
	struct drm_connector *connector;
	acpi_handle handle;
	struct acpi_device *acpi_dev, *acpi_cdev, *acpi_video_bus = NULL;
	unsigned long long device_id;
	acpi_status status;
	u32 temp, max_outputs;
	int i = 0;

	handle = ACPI_HANDLE(&dev->pdev->dev);
	if (!handle || acpi_bus_get_device(handle, &acpi_dev))
		return;

	if (acpi_is_video_device(handle))
		acpi_video_bus = acpi_dev;
	else {
		list_for_each_entry(acpi_cdev, &acpi_dev->children, node) {
			if (acpi_is_video_device(acpi_cdev->handle)) {
				acpi_video_bus = acpi_cdev;
				break;
			}
		}
	}

	if (!acpi_video_bus) {
		DRM_DEBUG_KMS("No ACPI video bus found\n");
		return;
	}

	/*
	 * In theory, did2, the extended didl, gets added at opregion version
	 * 3.0. In practice, however, we're supposed to set it for earlier
	 * versions as well, since a BIOS that doesn't understand did2 should
	 * not look at it anyway. Use a variable so we can tweak this if a need
	 * arises later.
	 */
	max_outputs = ARRAY_SIZE(opregion->acpi->didl) +
		ARRAY_SIZE(opregion->acpi->did2);

	list_for_each_entry(acpi_cdev, &acpi_video_bus->children, node) {
		if (i >= max_outputs) {
			DRM_DEBUG_KMS("More than %u outputs detected via ACPI\n",
				      max_outputs);
			return;
		}
		status = acpi_evaluate_integer(acpi_cdev->handle, "_ADR",
					       NULL, &device_id);
		if (ACPI_SUCCESS(status)) {
			if (!device_id)
				goto blind_set;
			set_did(opregion, i++, (u32)(device_id & 0x0f0f));
		}
	}

end:
	DRM_DEBUG_KMS("%d outputs detected\n", i);

	/* If fewer than max outputs, the list must be null terminated */
	if (i < max_outputs)
		set_did(opregion, i, 0);
	return;

blind_set:
	i = 0;
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		int output_type = ACPI_OTHER_OUTPUT;
		if (i >= max_outputs) {
			DRM_DEBUG_KMS("More than %u outputs in connector list\n",
				      max_outputs);
			return;
		}
		switch (connector->connector_type) {
		case DRM_MODE_CONNECTOR_VGA:
		case DRM_MODE_CONNECTOR_DVIA:
			output_type = ACPI_VGA_OUTPUT;
			break;
		case DRM_MODE_CONNECTOR_Composite:
		case DRM_MODE_CONNECTOR_SVIDEO:
		case DRM_MODE_CONNECTOR_Component:
		case DRM_MODE_CONNECTOR_9PinDIN:
			output_type = ACPI_TV_OUTPUT;
			break;
		case DRM_MODE_CONNECTOR_DVII:
		case DRM_MODE_CONNECTOR_DVID:
		case DRM_MODE_CONNECTOR_DisplayPort:
		case DRM_MODE_CONNECTOR_HDMIA:
		case DRM_MODE_CONNECTOR_HDMIB:
			output_type = ACPI_DIGITAL_OUTPUT;
			break;
		case DRM_MODE_CONNECTOR_LVDS:
			output_type = ACPI_LVDS_OUTPUT;
			break;
		}
		temp = get_did(opregion, i);
		set_did(opregion, i, temp | (1 << 31) | output_type | i);
		i++;
	}
	goto end;
}

static void intel_setup_cadls(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;
	int i = 0;
	u32 disp_id;

	/* Initialize the CADL field by duplicating the DIDL values.
	 * Technically, this is not always correct as display outputs may exist,
	 * but not active. This initialization is necessary for some Clevo
	 * laptops that check this field before processing the brightness and
	 * display switching hotkeys. Just like DIDL, CADL is NULL-terminated if
	 * there are less than eight devices. */
	do {
		disp_id = get_did(opregion, i);
		opregion->acpi->cadl[i] = disp_id;
	} while (++i < 8 && disp_id != 0);
}

#endif

void intel_opregion_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;

	if (!opregion->header)
		return;

	if (opregion->acpi) {
#ifdef notyet
		intel_didl_outputs(dev);
		intel_setup_cadls(dev);
#endif

		/* Notify BIOS we are ready to handle ACPI video ext notifs.
		 * Right now, all the events are handled by the ACPI video module.
		 * We don't actually need to do anything with them. */
		opregion->acpi->csts = 0;
		opregion->acpi->drdy = 1;

		system_opregion = opregion;
#ifdef notyet
		register_acpi_notifier(&intel_opregion_notifier);
#endif
	}

	if (opregion->asle) {
		opregion->asle->tche = ASLE_TCHE_BLC_EN;
		opregion->asle->ardy = ASLE_ARDY_READY;
	}
}

void intel_opregion_fini(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;

	if (!opregion->header)
		return;

	if (opregion->asle)
		opregion->asle->ardy = ASLE_ARDY_NOT_READY;

	cancel_work_sync(&dev_priv->opregion.asle_work);

	if (opregion->acpi) {
		opregion->acpi->drdy = 0;

		system_opregion = NULL;
#ifdef notyet
		unregister_acpi_notifier(&intel_opregion_notifier);
#endif
	}

	/* just clear all opregion memory pointers now */
#ifdef __linux__
	memunmap(opregion->header);
#else
	bus_space_unmap(dev_priv->bst, dev_priv->opregion_ioh, OPREGION_SIZE);
#endif
	opregion->header = NULL;
	opregion->acpi = NULL;
	opregion->swsci = NULL;
	opregion->asle = NULL;
	opregion->vbt = NULL;
	opregion->lid_state = NULL;
}

static void swsci_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;
	bool requested_callbacks = false;
	u32 tmp;

	/* Sub-function code 0 is okay, let's allow them. */
	opregion->swsci_gbda_sub_functions = 1;
	opregion->swsci_sbcb_sub_functions = 1;

	/* We use GBDA to ask for supported GBDA calls. */
	if (swsci(dev, SWSCI_GBDA_SUPPORTED_CALLS, 0, &tmp) == 0) {
		/* make the bits match the sub-function codes */
		tmp <<= 1;
		opregion->swsci_gbda_sub_functions |= tmp;
	}

	/*
	 * We also use GBDA to ask for _requested_ SBCB callbacks. The driver
	 * must not call interfaces that are not specifically requested by the
	 * bios.
	 */
	if (swsci(dev, SWSCI_GBDA_REQUESTED_CALLBACKS, 0, &tmp) == 0) {
		/* here, the bits already match sub-function codes */
		opregion->swsci_sbcb_sub_functions |= tmp;
		requested_callbacks = true;
	}

	/*
	 * But we use SBCB to ask for _supported_ SBCB calls. This does not mean
	 * the callback is _requested_. But we still can't call interfaces that
	 * are not requested.
	 */
	if (swsci(dev, SWSCI_SBCB_SUPPORTED_CALLBACKS, 0, &tmp) == 0) {
		/* make the bits match the sub-function codes */
		u32 low = tmp & 0x7ff;
		u32 high = tmp & ~0xfff; /* bit 11 is reserved */
		tmp = (high << 4) | (low << 1) | 1;

		/* best guess what to do with supported wrt requested */
		if (requested_callbacks) {
			u32 req = opregion->swsci_sbcb_sub_functions;
			if ((req & tmp) != req)
				DRM_DEBUG_DRIVER("SWSCI BIOS requested (%08x) SBCB callbacks that are not supported (%08x)\n", req, tmp);
			/* XXX: for now, trust the requested callbacks */
			/* opregion->swsci_sbcb_sub_functions &= tmp; */
		} else {
			opregion->swsci_sbcb_sub_functions |= tmp;
		}
	}

	DRM_DEBUG_DRIVER("SWSCI GBDA callbacks %08x, SBCB callbacks %08x\n",
			 opregion->swsci_gbda_sub_functions,
			 opregion->swsci_sbcb_sub_functions);
}
#else /* CONFIG_ACPI */
static inline void swsci_setup(struct drm_device *dev) {}
#endif  /* CONFIG_ACPI */

int intel_opregion_setup(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_opregion *opregion = &dev_priv->opregion;
	u32 asls, mboxes;
	char buf[sizeof(OPREGION_SIGNATURE)];
	int err = 0;
	void *base;

	BUILD_BUG_ON(sizeof(struct opregion_header) != 0x100);
	BUILD_BUG_ON(sizeof(struct opregion_acpi) != 0x100);
	BUILD_BUG_ON(sizeof(struct opregion_swsci) != 0x100);
	BUILD_BUG_ON(sizeof(struct opregion_asle) != 0x100);

	pci_read_config_dword(dev->pdev, PCI_ASLS, &asls);
	DRM_DEBUG_DRIVER("graphic opregion physical addr: 0x%x\n", asls);
	if (asls == 0) {
		DRM_DEBUG_DRIVER("ACPI OpRegion not supported!\n");
		return -ENOTSUPP;
	}

#ifdef CONFIG_ACPI
	INIT_WORK(&opregion->asle_work, asle_work);
#endif

#ifdef __linux
	base = memremap(asls, OPREGION_SIZE, MEMREMAP_WB);
	if (!base)
		return -ENOMEM;
#else
	if (bus_space_map(dev_priv->bst, asls, OPREGION_SIZE,
	    BUS_SPACE_MAP_LINEAR, &dev_priv->opregion_ioh))
		return -ENOMEM;
	base = bus_space_vaddr(dev_priv->bst, dev_priv->opregion_ioh);
#endif

	memcpy(buf, base, sizeof(buf));

	if (memcmp(buf, OPREGION_SIGNATURE, 16)) {
		DRM_DEBUG_DRIVER("opregion signature mismatch\n");
		err = -EINVAL;
		goto err_out;
	}
	opregion->header = base;
	opregion->vbt = base + OPREGION_VBT_OFFSET;

	opregion->lid_state = base + ACPI_CLID;

	mboxes = opregion->header->mboxes;
	if (mboxes & MBOX_ACPI) {
		DRM_DEBUG_DRIVER("Public ACPI methods supported\n");
		opregion->acpi = base + OPREGION_ACPI_OFFSET;
	}

	if (mboxes & MBOX_SWSCI) {
		DRM_DEBUG_DRIVER("SWSCI supported\n");
		opregion->swsci = base + OPREGION_SWSCI_OFFSET;
		swsci_setup(dev);
	}
	if (mboxes & MBOX_ASLE) {
		DRM_DEBUG_DRIVER("ASLE supported\n");
		opregion->asle = base + OPREGION_ASLE_OFFSET;

		opregion->asle->ardy = ASLE_ARDY_NOT_READY;
	}

	return 0;

err_out:
#ifdef __linux__
	memunmap(base);
#else
	bus_space_unmap(dev_priv->bst, dev_priv->opregion_ioh, OPREGION_SIZE);
#endif
	return err;
}
@


1.9
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@a0 1
/*	$OpenBSD: intel_opregion.c,v 1.8 2015/04/18 14:47:34 jsg Exp $	*/
d28 5
a37 6
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include "acpi.h"
#include <dev/acpi/acpivar.h>

d56 1
d66 4
a69 1
	u8 reserved[164];
d91 3
a93 1
	u8 rsvd2[60];
d122 4
a125 1
	u8 rsvd[86];
d244 1
a244 1
	struct opregion_swsci __iomem *swsci = dev_priv->opregion.swsci;
d269 1
a269 1
	dslp = ioread32(&swsci->dslp);
d282 1
a282 1
	scic = ioread32(&swsci->scic);
d290 2
a291 2
	iowrite32(parm, &swsci->parm);
	iowrite32(scic, &swsci->scic);
d306 1
a306 1
#define C (((scic = ioread32(&swsci->scic)) & SWSCI_SCIC_INDICATOR) == 0)
d322 1
a322 1
		*parm_out = ioread32(&swsci->parm);
d346 6
a351 2
	port = intel_ddi_get_encoder_port(intel_encoder);
	if (port == PORT_E) {
d368 1
d372 1
a385 2
#ifdef notyet

a412 2
#endif

d417 1
a417 1
	struct opregion_asle __iomem *asle = dev_priv->opregion.asle;
d421 7
d435 1
a435 1
	mutex_lock(&dev->mode_config.mutex);
d443 2
a444 2
		intel_panel_set_backlight(intel_connector, bclp, 255);
	iowrite32(DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID, &asle->cblv);
d446 1
a446 1
	mutex_unlock(&dev->mode_config.mutex);
d531 1
a531 1
	struct opregion_asle __iomem *asle = dev_priv->opregion.asle;
d538 1
a538 1
	aslc_req = ioread32(&asle->aslc);
d547 1
a547 1
		aslc_stat |= asle_set_als_illum(dev, ioread32(&asle->alsi));
d550 1
a550 1
		aslc_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));
d553 1
a553 1
		aslc_stat |= asle_set_pfit(dev, ioread32(&asle->pfit));
d556 1
a556 1
		aslc_stat |= asle_set_pwm_freq(dev, ioread32(&asle->pfmb));
d560 1
a560 1
							ioread32(&asle->srot));
d563 1
a563 1
		aslc_stat |= asle_set_button_array(dev, ioread32(&asle->iuer));
d566 1
a566 1
		aslc_stat |= asle_set_convertible(dev, ioread32(&asle->iuer));
d569 1
a569 1
		aslc_stat |= asle_set_docking(dev, ioread32(&asle->iuer));
d574 1
a574 1
	iowrite32(aslc_stat, &asle->aslc);
d592 1
a600 1
	struct opregion_acpi __iomem *acpi;
d602 1
d613 1
a613 2
	if (event->type == 0x80 &&
	    (ioread32(&acpi->cevt) & 1) == 0)
d616 1
a616 1
	iowrite32(0, &acpi->csts);
a623 1
#endif
d631 32
a664 1
#ifdef notyet
d672 1
a672 1
	u32 temp;
d691 1
a691 1
		pr_warn("No ACPI video bus found\n");
d695 10
d706 3
a708 3
		if (i >= 8) {
			dev_dbg(&dev->pdev->dev,
				"More than 8 outputs detected via ACPI\n");
d711 2
a712 3
		status =
			acpi_evaluate_integer(acpi_cdev->handle, "_ADR",
						NULL, &device_id);
d716 1
a716 3
			iowrite32((u32)(device_id & 0x0f0f),
				  &opregion->acpi->didl[i]);
			i++;
d721 5
a725 3
	/* If fewer than 8 outputs, the list must be null terminated */
	if (i < 8)
		iowrite32(0, &opregion->acpi->didl[i]);
d732 3
a734 3
		if (i >= 8) {
			dev_dbg(&dev->pdev->dev,
				"More than 8 outputs in connector list\n");
d759 2
a760 3
		temp = ioread32(&opregion->acpi->didl[i]);
		iowrite32(temp | (1<<31) | output_type | i,
			  &opregion->acpi->didl[i]);
a763 1
#endif
a767 1
#ifdef notyet
d780 2
a781 2
		disp_id = ioread32(&opregion->acpi->didl[i]);
		iowrite32(disp_id, &opregion->acpi->cadl[i]);
d783 2
a785 1
}
d796 4
a799 4
		if (drm_core_check_feature(dev, DRIVER_MODESET)) {
			intel_didl_outputs(dev);
			intel_setup_cadls(dev);
		}
d804 2
a805 2
		iowrite32(0, &opregion->acpi->csts);
		iowrite32(1, &opregion->acpi->drdy);
d814 2
a815 2
		iowrite32(ASLE_TCHE_BLC_EN, &opregion->asle->tche);
		iowrite32(ASLE_ARDY_READY, &opregion->asle->ardy);
d828 1
a828 1
		iowrite32(ASLE_ARDY_NOT_READY, &opregion->asle->ardy);
d833 1
a833 1
		iowrite32(0, &opregion->acpi->drdy);
d842 3
d846 1
a918 1
	void __iomem *base;
d922 6
d940 5
d946 1
a946 2
	    BUS_SPACE_MAP_LINEAR, &dev_priv->opregion_ioh)) {
		DRM_DEBUG_DRIVER("could not map opregion!\n");
a947 1
	}
d949 1
a949 2
	if (!base)
		return -ENOMEM;
d951 1
a951 1
	memcpy_fromio(buf, base, sizeof(buf));
d963 1
a963 1
	mboxes = ioread32(&opregion->header->mboxes);
d978 1
a978 1
		iowrite32(ASLE_ARDY_NOT_READY, &opregion->asle->ardy);
d984 3
d988 1
@


1.8
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.7 2015/04/12 05:31:23 jsg Exp $	*/
d40 5
a44 2
#define PCI_ASLE 0xe4
#define PCI_ASLS 0xfc
d68 1
a68 1
} __attribute__((packed));
d90 1
a90 1
} __attribute__((packed));
d98 1
a98 1
} __attribute__((packed));
d114 38
a151 15
	u8 rsvd[102];
} __attribute__((packed));

/* ASLE irq request bits */
#define ASLE_SET_ALS_ILLUM     (1 << 0)
#define ASLE_SET_BACKLIGHT     (1 << 1)
#define ASLE_SET_PFIT          (1 << 2)
#define ASLE_SET_PWM_FREQ      (1 << 3)
#define ASLE_REQ_MSK           0xf

/* response bits of ASLE irq request */
#define ASLE_ALS_ILLUM_FAILED	(1<<10)
#define ASLE_BACKLIGHT_FAILED	(1<<12)
#define ASLE_PFIT_FAILED	(1<<14)
#define ASLE_PWM_FREQ_FAILED	(1<<16)
d171 54
d231 173
a403 1
#if NACPI > 0
d407 1
a408 1
	u32 max;
d413 1
a413 1
		return ASLE_BACKLIGHT_FAILED;
d417 1
a417 1
		return ASLE_BACKLIGHT_FAILED;
d419 9
a427 2
	max = intel_panel_get_max_backlight(dev);
	intel_panel_set_backlight(dev, bclp * max / 255);
d430 3
d440 2
a441 1
	return 0;
d446 2
a447 9
	struct drm_i915_private *dev_priv = dev->dev_private;
	if (pfmb & ASLE_PFMB_PWM_VALID) {
		u32 blc_pwm_ctl = I915_READ(BLC_PWM_CTL);
		u32 pwm = pfmb & ASLE_PFMB_PWM_MASK;
		blc_pwm_ctl &= BACKLIGHT_DUTY_CYCLE_MASK;
		pwm = pwm >> 9;
		/* FIXME - what do we do with the PWM? */
	}
	return 0;
d454 2
a455 3
	if (!(pfit & ASLE_PFIT_VALID))
		return ASLE_PFIT_FAILED;
	return 0;
d458 1
a458 1
void intel_opregion_asle_intr(struct drm_device *dev)
d460 3
a462 4
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct opregion_asle __iomem *asle = dev_priv->opregion.asle;
	u32 asle_stat = 0;
	u32 asle_req;
d464 14
a477 2
	if (!asle)
		return;
d479 2
a480 1
	asle_req = ioread32(&asle->aslc) & ASLE_REQ_MSK;
d482 6
a487 4
	if (!asle_req) {
		DRM_DEBUG_DRIVER("non asle set request??\n");
		return;
	}
d489 2
a490 2
	if (asle_req & ASLE_SET_ALS_ILLUM)
		asle_stat |= asle_set_als_illum(dev, ioread32(&asle->alsi));
d492 6
a497 2
	if (asle_req & ASLE_SET_BACKLIGHT)
		asle_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));
d499 2
a500 2
	if (asle_req & ASLE_SET_PFIT)
		asle_stat |= asle_set_pfit(dev, ioread32(&asle->pfit));
d502 4
a505 4
	if (asle_req & ASLE_SET_PWM_FREQ)
		asle_stat |= asle_set_pwm_freq(dev, ioread32(&asle->pfmb));

	iowrite32(asle_stat, &asle->aslc);
d508 1
a508 1
void intel_opregion_gse_intr(struct drm_device *dev)
d510 5
a514 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d516 2
a517 2
	u32 asle_stat = 0;
	u32 asle_req;
d522 1
a522 1
	asle_req = ioread32(&asle->aslc) & ASLE_REQ_MSK;
d524 3
a526 2
	if (!asle_req) {
		DRM_DEBUG_DRIVER("non asle set request??\n");
d530 18
a547 4
	if (asle_req & ASLE_SET_ALS_ILLUM) {
		DRM_DEBUG_DRIVER("Illum is not supported\n");
		asle_stat |= ASLE_ALS_ILLUM_FAILED;
	}
d549 2
a550 2
	if (asle_req & ASLE_SET_BACKLIGHT)
		asle_stat |= asle_set_backlight(dev, ioread32(&asle->bclp));
d552 2
a553 4
	if (asle_req & ASLE_SET_PFIT) {
		DRM_DEBUG_DRIVER("Pfit is not supported\n");
		asle_stat |= ASLE_PFIT_FAILED;
	}
d555 2
a556 4
	if (asle_req & ASLE_SET_PWM_FREQ) {
		DRM_DEBUG_DRIVER("PWM freq is not supported\n");
		asle_stat |= ASLE_PWM_FREQ_FAILED;
	}
d558 1
a558 1
	iowrite32(asle_stat, &asle->aslc);
a559 4
#define ASLE_ALS_EN    (1<<0)
#define ASLE_BLC_EN    (1<<1)
#define ASLE_PFIT_EN   (1<<2)
#define ASLE_PFMB_EN   (1<<3)
d561 1
a561 1
void intel_opregion_enable_asle(struct drm_device *dev)
a563 1
	struct opregion_asle __iomem *asle = dev_priv->opregion.asle;
d565 2
a566 9
	if (asle) {
		if (IS_MOBILE(dev))
			intel_enable_asle(dev);

		iowrite32(ASLE_ALS_EN | ASLE_BLC_EN | ASLE_PFIT_EN |
			  ASLE_PFMB_EN,
			  &asle->tche);
		iowrite32(1, &asle->ardy);
	}
d629 2
a630 2
	handle = DEVICE_ACPI_HANDLE(&dev->pdev->dev);
	if (!handle || ACPI_FAILURE(acpi_bus_get_device(handle, &acpi_dev)))
d633 1
a633 1
	if (acpi_is_video_device(acpi_dev))
d637 1
a637 1
			if (acpi_is_video_device(acpi_cdev)) {
d651 2
a652 2
			dev_printk(KERN_ERR, &dev->pdev->dev,
				    "More than 8 outputs detected\n");
d678 2
a679 2
			dev_printk(KERN_ERR, &dev->pdev->dev,
				    "More than 8 outputs detected\n");
d760 4
a763 2
	if (opregion->asle)
		intel_opregion_enable_asle(dev);
d774 5
d795 1
d797 60
a856 1
#endif
d864 1
d867 1
a867 1
	asls = pci_conf_read(dev_priv->pc, dev_priv->tag, PCI_ASLS);
d874 4
d887 3
a889 1
	if (memcmp(base, OPREGION_SIGNATURE, 16)) {
d908 1
d913 2
@


1.7
log
@Switch back to ioread32 and iowrite32 for cases where bus_space_vaddr is
used instead of bus_space_read/bus_space_write.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.6 2015/04/06 10:56:37 jsg Exp $	*/
d437 21
d467 1
a467 1
		if (drm_core_check_feature(dev, DRIVER_MODESET))
d469 2
@


1.6
log
@add/use some more errno remapping
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.5 2014/03/24 17:06:49 kettenis Exp $	*/
d169 1
a169 1
	asle->cblv = DIV_ROUND_UP(bclp * 100, 255) | ASLE_CBLV_VALID;
d213 1
a213 1
	asle_req = asle->aslc & ASLE_REQ_MSK;
d221 1
a221 1
		asle_stat |= asle_set_als_illum(dev, asle->alsi);
d224 1
a224 1
		asle_stat |= asle_set_backlight(dev, asle->bclp);
d227 1
a227 1
		asle_stat |= asle_set_pfit(dev, asle->pfit);
d230 1
a230 1
		asle_stat |= asle_set_pwm_freq(dev, asle->pfmb);
d232 1
a232 1
	asle->aslc = asle_stat;
d245 1
a245 1
	asle_req = asle->aslc & ASLE_REQ_MSK;
d258 1
a258 1
		asle_stat |= asle_set_backlight(dev, asle->bclp);
d270 1
a270 1
	asle->aslc = asle_stat;
d286 4
a289 3
		asle->tche = ASLE_ALS_EN | ASLE_BLC_EN | ASLE_PFIT_EN |
			ASLE_PFMB_EN;
		asle->ardy = 1;
d320 2
a321 1
	if (event->type == 0x80 && !(acpi->cevt & 0x1))
d324 1
a324 1
	acpi->csts = 0;
d350 1
d385 2
a386 1
			opregion->acpi->didl[i] = (u32)(device_id & 0x0f0f);
d394 1
a394 1
		opregion->acpi->didl[i] = 0;
d428 3
a430 1
		opregion->acpi->didl[i] |= (1<<31) | output_type | i;
d452 2
a453 2
		opregion->acpi->csts = 0;
		opregion->acpi->drdy = 1;
d474 1
a474 1
		opregion->acpi->drdy = 0;
d526 1
a526 1
	mboxes = opregion->header->mboxes;
@


1.5
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.4 2013/08/13 10:23:51 jsg Exp $	*/
d498 1
a498 1
		return -ENOTSUP;
@


1.4
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.3 2013/07/05 07:20:27 jsg Exp $	*/
d155 1
a155 1
	struct opregion_asle *asle = dev_priv->opregion.asle;
d158 2
d169 1
a169 1
	asle->cblv = (bclp*0x64)/0xff | ASLE_CBLV_VALID;
d206 1
a206 1
	struct opregion_asle *asle = dev_priv->opregion.asle;
d216 1
a216 1
		DRM_DEBUG("non asle set request??\n");
d238 1
a238 1
	struct opregion_asle *asle = dev_priv->opregion.asle;
d248 1
a248 1
		DRM_DEBUG("non asle set request??\n");
d253 1
a253 1
		DRM_DEBUG("Illum is not supported\n");
d261 1
a261 1
		DRM_DEBUG("Pfit is not supported\n");
d266 1
a266 1
		DRM_DEBUG("PWM freq is not supported\n");
a271 1

d280 1
a280 1
	struct opregion_asle *asle = dev_priv->opregion.asle;
d306 2
a307 1
	struct opregion_acpi *acpi;
d366 1
a366 1
		printk(KERN_WARNING "No ACPI video bus found\n");
d398 1
a398 1
			device_printf(dev->device,
d490 1
a490 1
	void *base;
d495 1
a495 1
	DRM_DEBUG("graphic opregion physical addr: 0x%x\n", asls);
d497 1
a497 1
		DRM_DEBUG("ACPI OpRegion not supported!\n");
d503 2
a504 2
		DRM_DEBUG("could not map opregion!\n");
		return ENOMEM;
d511 1
a511 1
		DRM_DEBUG("opregion signature mismatch\n");
d515 1
a515 1
	opregion->header = (struct opregion_header *)base;
d518 1
a518 1
	opregion->lid_state = (u32 *)(base + ACPI_CLID);
d522 2
a523 3
		DRM_DEBUG("Public ACPI methods supported\n");
		opregion->acpi = (struct opregion_acpi *)(base +
		    OPREGION_ACPI_OFFSET);
d527 2
a528 3
		DRM_DEBUG("SWSCI supported\n");
		opregion->swsci = (struct opregion_swsci *)(base +
		    OPREGION_SWSCI_OFFSET);
d531 2
a532 3
		DRM_DEBUG("ASLE supported\n");
		opregion->asle = (struct opregion_asle *)(base +
		    OPREGION_ASLE_OFFSET);
@


1.3
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.2 2013/03/21 08:27:32 jsg Exp $	*/
a150 8
u32	asle_set_backlight(struct drm_device *, u32);
u32	asle_set_als_illum(struct drm_device *, u32);
u32	asle_set_pwm_freq(struct drm_device *, u32);
u32	asle_set_pfit(struct drm_device *, u32);
void	intel_opregion_asle_intr(struct drm_device *);
void	intel_opregion_gse_intr(struct drm_device *);
void	intel_didl_outputs(struct drm_device *);

d152 1
a152 2
u32
asle_set_backlight(struct drm_device *dev, u32 bclp)
d172 1
a172 2
u32
asle_set_als_illum(struct drm_device *dev, u32 alsi)
d179 1
a179 2
u32
asle_set_pwm_freq(struct drm_device *dev, u32 pfmb)
d192 1
a192 2
u32
asle_set_pfit(struct drm_device *dev, u32 pfit)
d201 1
a201 2
void
intel_opregion_asle_intr(struct drm_device *dev)
d233 1
a233 2
void
intel_opregion_gse_intr(struct drm_device *dev)
d276 1
a276 2
void
intel_opregion_enable_asle(struct drm_device *dev)
d298 2
a299 3
int
intel_opregion_video_event(struct notifier_block *nb, unsigned long val,
    void *data)
d336 1
a336 2
void
intel_didl_outputs(struct drm_device *dev)
d429 1
a429 2
void
intel_opregion_init(struct drm_device *dev)
d457 1
a457 2
void
intel_opregion_fini(struct drm_device *dev)
d484 1
a484 2
int
intel_opregion_setup(struct drm_device *dev)
@


1.2
log
@Enable the opregion code but keep the parts that try to talk to acpi
disabled for now.  Makes the brightness keys on my x230 work.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_opregion.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d163 1
a163 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d192 1
a192 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d216 1
a216 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d249 1
a249 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d293 1
a293 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d356 1
a356 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d449 1
a449 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d478 1
a478 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d506 1
a506 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
d151 9
a159 1
#ifdef CONFIG_ACPI
d312 1
d344 1
d355 1
d443 1
d466 1
d468 1
d488 1
d490 1
a493 27
	iounmap(opregion->header);
	opregion->header = NULL;
	opregion->acpi = NULL;
	opregion->swsci = NULL;
	opregion->asle = NULL;
	opregion->vbt = NULL;
}
#else
int
intel_opregion_init(struct drm_device *dev)
{

	return (0);
}

void
intel_opregion_fini(struct drm_device *dev)
{
	struct inteldrm_softc *dev_priv;
	struct intel_opregion *opregion;

	dev_priv = dev->dev_private;
	opregion = &dev_priv->opregion;

	if (opregion->header == NULL)
		return;

@

