head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.2
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.4
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.6
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.11.0.6
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.17
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	KnwRPOZok9A30HI4;

1.16
date	2016.12.24.21.52.24;	author kettenis;	state Exp;
branches;
next	1.15;
commitid	02YPAqytAgja2TqS;

1.15
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	lQlppvmETCN49oZe;

1.14
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.13;
commitid	syZU9J25izIJ2cm1;

1.13
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.12;
commitid	dLgISW35NAmGN8Xl;

1.12
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.11;
commitid	C5l5rZ5v9mpRR1eS;

1.11
date	2014.01.22.22.33.24;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.22.22.28.31;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.22.22.21.52;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.22.05.16.55;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2013.12.01.14.28.40;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.13.10.23.51;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.07.04.09.55.01;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.04.09.42.46;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright Â© 2006-2007 Intel Corporation
 * Copyright (c) 2006 Dave Airlie <airlied@@linux.ie>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *	Eric Anholt <eric@@anholt.net>
 *      Dave Airlie <airlied@@linux.ie>
 *      Jesse Barnes <jesse.barnes@@intel.com>
 */

#ifdef __linux__
#include <linux/dmi.h>
#include <linux/i2c.h>
#include <linux/slab.h>
#endif
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_atomic_helper.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_edid.h>
#include "intel_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#ifdef __linux__
#include <linux/acpi.h>
#endif

/* Private structure for the integrated LVDS support */
struct intel_lvds_connector {
	struct intel_connector base;

	struct notifier_block lid_notifier;
};

struct intel_lvds_encoder {
	struct intel_encoder base;

	bool is_dual_link;
	u32 reg;
	u32 a3_power;

	struct intel_lvds_connector *attached_connector;
};

static struct intel_lvds_encoder *to_lvds_encoder(struct drm_encoder *encoder)
{
	return container_of(encoder, struct intel_lvds_encoder, base.base);
}

static struct intel_lvds_connector *to_lvds_connector(struct drm_connector *connector)
{
	return container_of(connector, struct intel_lvds_connector, base.base);
}

static bool intel_lvds_get_hw_state(struct intel_encoder *encoder,
				    enum pipe *pipe)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	enum intel_display_power_domain power_domain;
	u32 tmp;

	power_domain = intel_display_port_power_domain(encoder);
	if (!intel_display_power_is_enabled(dev_priv, power_domain))
		return false;

	tmp = I915_READ(lvds_encoder->reg);

	if (!(tmp & LVDS_PORT_EN))
		return false;

	if (HAS_PCH_CPT(dev))
		*pipe = PORT_TO_PIPE_CPT(tmp);
	else
		*pipe = PORT_TO_PIPE(tmp);

	return true;
}

static void intel_lvds_get_config(struct intel_encoder *encoder,
				  struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	u32 tmp, flags = 0;
	int dotclock;

	tmp = I915_READ(lvds_encoder->reg);
	if (tmp & LVDS_HSYNC_POLARITY)
		flags |= DRM_MODE_FLAG_NHSYNC;
	else
		flags |= DRM_MODE_FLAG_PHSYNC;
	if (tmp & LVDS_VSYNC_POLARITY)
		flags |= DRM_MODE_FLAG_NVSYNC;
	else
		flags |= DRM_MODE_FLAG_PVSYNC;

	pipe_config->base.adjusted_mode.flags |= flags;

	/* gen2/3 store dither state in pfit control, needs to match */
	if (INTEL_INFO(dev)->gen < 4) {
		tmp = I915_READ(PFIT_CONTROL);

		pipe_config->gmch_pfit.control |= tmp & PANEL_8TO6_DITHER_ENABLE;
	}

	dotclock = pipe_config->port_clock;

	if (HAS_PCH_SPLIT(dev_priv->dev))
		ironlake_check_encoder_dotclock(pipe_config, dotclock);

	pipe_config->base.adjusted_mode.crtc_clock = dotclock;
}

static void intel_pre_enable_lvds(struct intel_encoder *encoder)
{
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	struct drm_device *dev = encoder->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
	const struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;
	int pipe = crtc->pipe;
	u32 temp;

	if (HAS_PCH_SPLIT(dev)) {
		assert_fdi_rx_pll_disabled(dev_priv, pipe);
		assert_shared_dpll_disabled(dev_priv,
					    intel_crtc_to_shared_dpll(crtc));
	} else {
		assert_pll_disabled(dev_priv, pipe);
	}

	temp = I915_READ(lvds_encoder->reg);
	temp |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;

	if (HAS_PCH_CPT(dev)) {
		temp &= ~PORT_TRANS_SEL_MASK;
		temp |= PORT_TRANS_SEL_CPT(pipe);
	} else {
		if (pipe == 1) {
			temp |= LVDS_PIPEB_SELECT;
		} else {
			temp &= ~LVDS_PIPEB_SELECT;
		}
	}

	/* set the corresponsding LVDS_BORDER bit */
	temp &= ~LVDS_BORDER_ENABLE;
	temp |= crtc->config->gmch_pfit.lvds_border_bits;
	/* Set the B0-B3 data pairs corresponding to whether we're going to
	 * set the DPLLs for dual-channel mode or not.
	 */
	if (lvds_encoder->is_dual_link)
		temp |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
	else
		temp &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);

	/* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP)
	 * appropriately here, but we need to look more thoroughly into how
	 * panels behave in the two modes. For now, let's just maintain the
	 * value we got from the BIOS.
	 */
	 temp &= ~LVDS_A3_POWER_MASK;
	 temp |= lvds_encoder->a3_power;

	/* Set the dithering flag on LVDS as needed, note that there is no
	 * special lvds dither control bit on pch-split platforms, dithering is
	 * only controlled through the PIPECONF reg. */
	if (INTEL_INFO(dev)->gen == 4) {
		/* Bspec wording suggests that LVDS port dithering only exists
		 * for 18bpp panels. */
		if (crtc->config->dither && crtc->config->pipe_bpp == 18)
			temp |= LVDS_ENABLE_DITHER;
		else
			temp &= ~LVDS_ENABLE_DITHER;
	}
	temp &= ~(LVDS_HSYNC_POLARITY | LVDS_VSYNC_POLARITY);
	if (adjusted_mode->flags & DRM_MODE_FLAG_NHSYNC)
		temp |= LVDS_HSYNC_POLARITY;
	if (adjusted_mode->flags & DRM_MODE_FLAG_NVSYNC)
		temp |= LVDS_VSYNC_POLARITY;

	I915_WRITE(lvds_encoder->reg, temp);
}

/**
 * Sets the power state for the panel.
 */
static void intel_enable_lvds(struct intel_encoder *encoder)
{
	struct drm_device *dev = encoder->base.dev;
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	struct intel_connector *intel_connector =
		&lvds_encoder->attached_connector->base;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 ctl_reg, stat_reg;

	if (HAS_PCH_SPLIT(dev)) {
		ctl_reg = PCH_PP_CONTROL;
		stat_reg = PCH_PP_STATUS;
	} else {
		ctl_reg = PP_CONTROL;
		stat_reg = PP_STATUS;
	}

	I915_WRITE(lvds_encoder->reg, I915_READ(lvds_encoder->reg) | LVDS_PORT_EN);

	I915_WRITE(ctl_reg, I915_READ(ctl_reg) | POWER_TARGET_ON);
	POSTING_READ(lvds_encoder->reg);
	if (wait_for((I915_READ(stat_reg) & PP_ON) != 0, 1000))
		DRM_ERROR("timed out waiting for panel to power on\n");

	intel_panel_enable_backlight(intel_connector);
}

static void intel_disable_lvds(struct intel_encoder *encoder)
{
	struct drm_device *dev = encoder->base.dev;
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 ctl_reg, stat_reg;

	if (HAS_PCH_SPLIT(dev)) {
		ctl_reg = PCH_PP_CONTROL;
		stat_reg = PCH_PP_STATUS;
	} else {
		ctl_reg = PP_CONTROL;
		stat_reg = PP_STATUS;
	}

	I915_WRITE(ctl_reg, I915_READ(ctl_reg) & ~POWER_TARGET_ON);
	if (wait_for((I915_READ(stat_reg) & PP_ON) == 0, 1000))
		DRM_ERROR("timed out waiting for panel to power off\n");

	I915_WRITE(lvds_encoder->reg, I915_READ(lvds_encoder->reg) & ~LVDS_PORT_EN);
	POSTING_READ(lvds_encoder->reg);
}

static void gmch_disable_lvds(struct intel_encoder *encoder)
{
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	struct intel_connector *intel_connector =
		&lvds_encoder->attached_connector->base;

	intel_panel_disable_backlight(intel_connector);

	intel_disable_lvds(encoder);
}

static void pch_disable_lvds(struct intel_encoder *encoder)
{
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(&encoder->base);
	struct intel_connector *intel_connector =
		&lvds_encoder->attached_connector->base;

	intel_panel_disable_backlight(intel_connector);
}

static void pch_post_disable_lvds(struct intel_encoder *encoder)
{
	intel_disable_lvds(encoder);
}

static enum drm_mode_status
intel_lvds_mode_valid(struct drm_connector *connector,
		      struct drm_display_mode *mode)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct drm_display_mode *fixed_mode = intel_connector->panel.fixed_mode;
	int max_pixclk = to_i915(connector->dev)->max_dotclk_freq;

	if (mode->hdisplay > fixed_mode->hdisplay)
		return MODE_PANEL;
	if (mode->vdisplay > fixed_mode->vdisplay)
		return MODE_PANEL;
	if (fixed_mode->clock > max_pixclk)
		return MODE_CLOCK_HIGH;

	return MODE_OK;
}

static bool intel_lvds_compute_config(struct intel_encoder *intel_encoder,
				      struct intel_crtc_state *pipe_config)
{
	struct drm_device *dev = intel_encoder->base.dev;
	struct intel_lvds_encoder *lvds_encoder =
		to_lvds_encoder(&intel_encoder->base);
	struct intel_connector *intel_connector =
		&lvds_encoder->attached_connector->base;
	struct drm_display_mode *adjusted_mode = &pipe_config->base.adjusted_mode;
	struct intel_crtc *intel_crtc = to_intel_crtc(pipe_config->base.crtc);
	unsigned int lvds_bpp;

	/* Should never happen!! */
	if (INTEL_INFO(dev)->gen < 4 && intel_crtc->pipe == 0) {
		DRM_ERROR("Can't support LVDS on pipe A\n");
		return false;
	}

	if (lvds_encoder->a3_power == LVDS_A3_POWER_UP)
		lvds_bpp = 8*3;
	else
		lvds_bpp = 6*3;

	if (lvds_bpp != pipe_config->pipe_bpp && !pipe_config->bw_constrained) {
		DRM_DEBUG_KMS("forcing display bpp (was %d) to LVDS (%d)\n",
			      pipe_config->pipe_bpp, lvds_bpp);
		pipe_config->pipe_bpp = lvds_bpp;
	}

	/*
	 * We have timings from the BIOS for the panel, put them in
	 * to the adjusted mode.  The CRTC will be set up for this mode,
	 * with the panel scaling set up to source from the H/VDisplay
	 * of the original mode.
	 */
	intel_fixed_panel_mode(intel_connector->panel.fixed_mode,
			       adjusted_mode);

	if (HAS_PCH_SPLIT(dev)) {
		pipe_config->has_pch_encoder = true;

		intel_pch_panel_fitting(intel_crtc, pipe_config,
					intel_connector->panel.fitting_mode);
	} else {
		intel_gmch_panel_fitting(intel_crtc, pipe_config,
					 intel_connector->panel.fitting_mode);

	}

	/*
	 * XXX: It would be nice to support lower refresh rates on the
	 * panels to reduce power consumption, and perhaps match the
	 * user's requested refresh rate.
	 */

	return true;
}

/**
 * Detect the LVDS connection.
 *
 * Since LVDS doesn't have hotlug, we use the lid as a proxy.  Open means
 * connected and closed means disconnected.  We also send hotplug events as
 * needed, using lid status notification from the input layer.
 */
static enum drm_connector_status
intel_lvds_detect(struct drm_connector *connector, bool force)
{
	struct drm_device *dev = connector->dev;
	enum drm_connector_status status;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
		      connector->base.id, connector->name);

	status = intel_panel_detect(dev);
	if (status != connector_status_unknown)
		return status;

	return connector_status_connected;
}

/**
 * Return the list of DDC modes if available, or the BIOS fixed mode otherwise.
 */
static int intel_lvds_get_modes(struct drm_connector *connector)
{
	struct intel_lvds_connector *lvds_connector = to_lvds_connector(connector);
	struct drm_device *dev = connector->dev;
	struct drm_display_mode *mode;

	/* use cached edid if we have one */
	if (!IS_ERR_OR_NULL(lvds_connector->base.edid))
		return drm_add_edid_modes(connector, lvds_connector->base.edid);

	mode = drm_mode_duplicate(dev, lvds_connector->base.panel.fixed_mode);
	if (mode == NULL)
		return 0;

	drm_mode_probed_add(connector, mode);
	return 1;
}

#ifdef notyet
static int intel_no_modeset_on_lid_dmi_callback(const struct dmi_system_id *id)
{
	DRM_INFO("Skipping forced modeset for %s\n", id->ident);
	return 1;
}

/* The GPU hangs up on these systems if modeset is performed on LID open */
static const struct dmi_system_id intel_no_modeset_on_lid[] = {
	{
		.callback = intel_no_modeset_on_lid_dmi_callback,
		.ident = "Toshiba Tecra A11",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
			DMI_MATCH(DMI_PRODUCT_NAME, "TECRA A11"),
		},
	},

	{ }	/* terminating entry */
};

/*
 * Lid events. Note the use of 'modeset':
 *  - we set it to MODESET_ON_LID_OPEN on lid close,
 *    and set it to MODESET_DONE on open
 *  - we use it as a "only once" bit (ie we ignore
 *    duplicate events where it was already properly set)
 *  - the suspend/resume paths will set it to
 *    MODESET_SUSPENDED and ignore the lid open event,
 *    because they restore the mode ("lid open").
 */
static int intel_lid_notify(struct notifier_block *nb, unsigned long val,
			    void *unused)
{
	struct intel_lvds_connector *lvds_connector =
		container_of(nb, struct intel_lvds_connector, lid_notifier);
	struct drm_connector *connector = &lvds_connector->base.base;
	struct drm_device *dev = connector->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev->switch_power_state != DRM_SWITCH_POWER_ON)
		return NOTIFY_OK;

	mutex_lock(&dev_priv->modeset_restore_lock);
	if (dev_priv->modeset_restore == MODESET_SUSPENDED)
		goto exit;
	/*
	 * check and update the status of LVDS connector after receiving
	 * the LID nofication event.
	 */
	connector->status = connector->funcs->detect(connector, false);

	/* Don't force modeset on machines where it causes a GPU lockup */
	if (dmi_check_system(intel_no_modeset_on_lid))
		goto exit;
	if (!acpi_lid_open()) {
		/* do modeset on next lid open event */
		dev_priv->modeset_restore = MODESET_ON_LID_OPEN;
		goto exit;
	}

	if (dev_priv->modeset_restore == MODESET_DONE)
		goto exit;

	/*
	 * Some old platform's BIOS love to wreak havoc while the lid is closed.
	 * We try to detect this here and undo any damage. The split for PCH
	 * platforms is rather conservative and a bit arbitrary expect that on
	 * those platforms VGA disabling requires actual legacy VGA I/O access,
	 * and as part of the cleanup in the hw state restore we also redisable
	 * the vga plane.
	 */
	if (!HAS_PCH_SPLIT(dev)) {
		drm_modeset_lock_all(dev);
		intel_display_resume(dev);
		drm_modeset_unlock_all(dev);
	}

	dev_priv->modeset_restore = MODESET_DONE;

exit:
	mutex_unlock(&dev_priv->modeset_restore_lock);
	return NOTIFY_OK;
}
#endif

/**
 * intel_lvds_destroy - unregister and free LVDS structures
 * @@connector: connector to free
 *
 * Unregister the DDC bus for this connector then free the driver private
 * structure.
 */
static void intel_lvds_destroy(struct drm_connector *connector)
{
	struct intel_lvds_connector *lvds_connector =
		to_lvds_connector(connector);

#ifdef notyet
	if (lvds_connector->lid_notifier.notifier_call)
		acpi_lid_notifier_unregister(&lvds_connector->lid_notifier);
#endif

	if (!IS_ERR_OR_NULL(lvds_connector->base.edid))
		kfree(lvds_connector->base.edid);

	intel_panel_fini(&lvds_connector->base.panel);

	drm_connector_cleanup(connector);
	kfree(connector);
}

static int intel_lvds_set_property(struct drm_connector *connector,
				   struct drm_property *property,
				   uint64_t value)
{
	struct intel_connector *intel_connector = to_intel_connector(connector);
	struct drm_device *dev = connector->dev;

	if (property == dev->mode_config.scaling_mode_property) {
		struct drm_crtc *crtc;

		if (value == DRM_MODE_SCALE_NONE) {
			DRM_DEBUG_KMS("no scaling not supported\n");
			return -EINVAL;
		}

		if (intel_connector->panel.fitting_mode == value) {
			/* the LVDS scaling property is not changed */
			return 0;
		}
		intel_connector->panel.fitting_mode = value;

		crtc = intel_attached_encoder(connector)->base.crtc;
		if (crtc && crtc->state->enable) {
			/*
			 * If the CRTC is enabled, the display will be changed
			 * according to the new panel fitting mode.
			 */
			intel_crtc_restore_mode(crtc);
		}
	}

	return 0;
}

static const struct drm_connector_helper_funcs intel_lvds_connector_helper_funcs = {
	.get_modes = intel_lvds_get_modes,
	.mode_valid = intel_lvds_mode_valid,
	.best_encoder = intel_best_encoder,
};

static const struct drm_connector_funcs intel_lvds_connector_funcs = {
	.dpms = drm_atomic_helper_connector_dpms,
	.detect = intel_lvds_detect,
	.fill_modes = drm_helper_probe_single_connector_modes,
	.set_property = intel_lvds_set_property,
	.atomic_get_property = intel_connector_atomic_get_property,
	.destroy = intel_lvds_destroy,
	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
};

static const struct drm_encoder_funcs intel_lvds_enc_funcs = {
	.destroy = intel_encoder_destroy,
};

static int intel_no_lvds_dmi_callback(const struct dmi_system_id *id)
{
	DRM_INFO("Skipping LVDS initialization for %s\n", id->ident);
	return 1;
}

/* These systems claim to have LVDS, but really don't */
static const struct dmi_system_id intel_no_lvds[] = {
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Apple Mac Mini (Core series)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple"),
			DMI_MATCH(DMI_PRODUCT_NAME, "Macmini1,1"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Apple Mac Mini (Core 2 series)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple"),
			DMI_MATCH(DMI_PRODUCT_NAME, "Macmini2,1"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "MSI IM-945GSE-A",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "MSI"),
			DMI_MATCH(DMI_PRODUCT_NAME, "A9830IMS"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Dell Studio Hybrid",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "Studio Hybrid 140g"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Dell OptiPlex FX170",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "OptiPlex FX170"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "AOpen Mini PC",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "AOpen"),
			DMI_MATCH(DMI_PRODUCT_NAME, "i965GMx-IF"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "AOpen Mini PC MP915",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
			DMI_MATCH(DMI_BOARD_NAME, "i915GMx-F"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "AOpen i915GMm-HFS",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
			DMI_MATCH(DMI_BOARD_NAME, "i915GMm-HFS"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
                .ident = "AOpen i45GMx-I",
                .matches = {
                        DMI_MATCH(DMI_BOARD_VENDOR, "AOpen"),
                        DMI_MATCH(DMI_BOARD_NAME, "i45GMx-I"),
                },
        },
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Aopen i945GTt-VFA",
		.matches = {
			DMI_MATCH(DMI_PRODUCT_VERSION, "AO00001JW"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Clientron U800",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Clientron"),
			DMI_MATCH(DMI_PRODUCT_NAME, "U800"),
		},
	},
	{
                .callback = intel_no_lvds_dmi_callback,
                .ident = "Clientron E830",
                .matches = {
                        DMI_MATCH(DMI_SYS_VENDOR, "Clientron"),
                        DMI_MATCH(DMI_PRODUCT_NAME, "E830"),
                },
        },
        {
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Asus EeeBox PC EB1007",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "ASUSTeK Computer INC."),
			DMI_MATCH(DMI_PRODUCT_NAME, "EB1007"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Asus AT5NM10T-I",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
			DMI_MATCH(DMI_BOARD_NAME, "AT5NM10T-I"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Hewlett-Packard HP t5740",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
			DMI_MATCH(DMI_PRODUCT_NAME, " t5740"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Hewlett-Packard t5745",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
			DMI_MATCH(DMI_PRODUCT_NAME, "hp t5745"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Hewlett-Packard st5747",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
			DMI_MATCH(DMI_PRODUCT_NAME, "hp st5747"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "MSI Wind Box DC500",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "MICRO-STAR INTERNATIONAL CO., LTD"),
			DMI_MATCH(DMI_BOARD_NAME, "MS-7469"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Gigabyte GA-D525TUD",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co., Ltd."),
			DMI_MATCH(DMI_BOARD_NAME, "D525TUD"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Supermicro X7SPA-H",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Supermicro"),
			DMI_MATCH(DMI_PRODUCT_NAME, "X7SPA-H"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Fujitsu Esprimo Q900",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
			DMI_MATCH(DMI_PRODUCT_NAME, "ESPRIMO Q900"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Intel D410PT",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Intel"),
			DMI_MATCH(DMI_BOARD_NAME, "D410PT"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Intel D425KT",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Intel"),
			DMI_EXACT_MATCH(DMI_BOARD_NAME, "D425KT"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Intel D510MO",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Intel"),
			DMI_EXACT_MATCH(DMI_BOARD_NAME, "D510MO"),
		},
	},
	{
		.callback = intel_no_lvds_dmi_callback,
		.ident = "Intel D525MW",
		.matches = {
			DMI_MATCH(DMI_BOARD_VENDOR, "Intel"),
			DMI_EXACT_MATCH(DMI_BOARD_NAME, "D525MW"),
		},
	},

	{ }	/* terminating entry */
};

/*
 * Enumerate the child dev array parsed from VBT to check whether
 * the LVDS is present.
 * If it is present, return 1.
 * If it is not present, return false.
 * If no child dev is parsed from VBT, it assumes that the LVDS is present.
 */
static bool lvds_is_present_in_vbt(struct drm_device *dev,
				   u8 *i2c_pin)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	if (!dev_priv->vbt.child_dev_num)
		return true;

	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
		union child_device_config *uchild = dev_priv->vbt.child_dev + i;
		struct old_child_dev_config *child = &uchild->old;

		/* If the device type is not LFP, continue.
		 * We have to check both the new identifiers as well as the
		 * old for compatibility with some BIOSes.
		 */
		if (child->device_type != DEVICE_TYPE_INT_LFP &&
		    child->device_type != DEVICE_TYPE_LFP)
			continue;

		if (intel_gmbus_is_valid_pin(dev_priv, child->i2c_pin))
			*i2c_pin = child->i2c_pin;

		/* However, we cannot trust the BIOS writers to populate
		 * the VBT correctly.  Since LVDS requires additional
		 * information from AIM blocks, a non-zero addin offset is
		 * a good indicator that the LVDS is actually present.
		 */
		if (child->addin_offset)
			return true;

		/* But even then some BIOS writers perform some black magic
		 * and instantiate the device without reference to any
		 * additional data.  Trust that if the VBT was written into
		 * the OpRegion then they have validated the LVDS's existence.
		 */
		if (dev_priv->opregion.vbt)
			return true;
	}

	return false;
}

static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)
{
	DRM_INFO("Forcing lvds to dual link mode on %s\n", id->ident);
	return 1;
}

static const struct dmi_system_id intel_dual_link_lvds[] = {
	{
		.callback = intel_dual_link_lvds_callback,
		.ident = "Apple MacBook Pro 15\" (2010)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro6,2"),
		},
	},
	{
		.callback = intel_dual_link_lvds_callback,
		.ident = "Apple MacBook Pro 15\" (2011)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro8,2"),
		},
	},
	{
		.callback = intel_dual_link_lvds_callback,
		.ident = "Apple MacBook Pro 15\" (2012)",
		.matches = {
			DMI_MATCH(DMI_SYS_VENDOR, "Apple Inc."),
			DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro9,1"),
		},
	},
	{ }	/* terminating entry */
};

bool intel_is_dual_link_lvds(struct drm_device *dev)
{
	struct intel_encoder *encoder;
	struct intel_lvds_encoder *lvds_encoder;

	for_each_intel_encoder(dev, encoder) {
		if (encoder->type == INTEL_OUTPUT_LVDS) {
			lvds_encoder = to_lvds_encoder(&encoder->base);

			return lvds_encoder->is_dual_link;
		}
	}

	return false;
}

static bool compute_is_dual_link_lvds(struct intel_lvds_encoder *lvds_encoder)
{
	struct drm_device *dev = lvds_encoder->base.base.dev;
	unsigned int val;
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* use the module option value if specified */
	if (i915.lvds_channel_mode > 0)
		return i915.lvds_channel_mode == 2;

	/* single channel LVDS is limited to 112 MHz */
	if (lvds_encoder->attached_connector->base.panel.fixed_mode->clock
	    > 112999)
		return true;

	if (dmi_check_system(intel_dual_link_lvds))
		return true;

	/* BIOS should set the proper LVDS register value at boot, but
	 * in reality, it doesn't set the value when the lid is closed;
	 * we need to check "the value to be set" in VBT when LVDS
	 * register is uninitialized.
	 */
	val = I915_READ(lvds_encoder->reg);
	if (!(val & ~(LVDS_PIPE_MASK | LVDS_DETECTED)))
		val = dev_priv->vbt.bios_lvds_val;

	return (val & LVDS_CLKB_POWER_MASK) == LVDS_CLKB_POWER_UP;
}

static bool intel_lvds_supported(struct drm_device *dev)
{
	/* With the introduction of the PCH we gained a dedicated
	 * LVDS presence pin, use it. */
	if (HAS_PCH_IBX(dev) || HAS_PCH_CPT(dev))
		return true;

	/* Otherwise LVDS was only attached to mobile products,
	 * except for the inglorious 830gm */
	if (INTEL_INFO(dev)->gen <= 4 && IS_MOBILE(dev) && !IS_I830(dev))
		return true;

	return false;
}

/**
 * intel_lvds_init - setup LVDS connectors on this device
 * @@dev: drm device
 *
 * Create the connector, register the LVDS DDC bus, and try to figure out what
 * modes we can display on the LVDS panel (if present).
 */
void intel_lvds_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_lvds_encoder *lvds_encoder;
	struct intel_encoder *intel_encoder;
	struct intel_lvds_connector *lvds_connector;
	struct intel_connector *intel_connector;
	struct drm_connector *connector;
	struct drm_encoder *encoder;
	struct drm_display_mode *scan; /* *modes, *bios_mode; */
	struct drm_display_mode *fixed_mode = NULL;
	struct drm_display_mode *downclock_mode = NULL;
	struct edid *edid;
	struct drm_crtc *crtc;
	u32 lvds_reg;
	u32 lvds;
	int pipe;
	u8 pin;

	/*
	 * Unlock registers and just leave them unlocked. Do this before
	 * checking quirk lists to avoid bogus WARNINGs.
	 */
	if (HAS_PCH_SPLIT(dev)) {
		I915_WRITE(PCH_PP_CONTROL,
			   I915_READ(PCH_PP_CONTROL) | PANEL_UNLOCK_REGS);
	} else if (INTEL_INFO(dev_priv)->gen < 5) {
		I915_WRITE(PP_CONTROL,
			   I915_READ(PP_CONTROL) | PANEL_UNLOCK_REGS);
	}
	if (!intel_lvds_supported(dev))
		return;

	/* Skip init on machines we know falsely report LVDS */
	if (dmi_check_system(intel_no_lvds))
		return;

	if (HAS_PCH_SPLIT(dev))
		lvds_reg = PCH_LVDS;
	else
		lvds_reg = LVDS;

	lvds = I915_READ(lvds_reg);

	if (HAS_PCH_SPLIT(dev)) {
		if ((lvds & LVDS_DETECTED) == 0)
			return;
		if (dev_priv->vbt.edp_support) {
			DRM_DEBUG_KMS("disable LVDS for eDP support\n");
			return;
		}
	}

	pin = GMBUS_PIN_PANEL;
	if (!lvds_is_present_in_vbt(dev, &pin)) {
		if ((lvds & LVDS_PORT_EN) == 0) {
			DRM_DEBUG_KMS("LVDS is not present in VBT\n");
			return;
		}
		DRM_DEBUG_KMS("LVDS is not present in VBT, but enabled anyway\n");
	}

	 /* Set the Panel Power On/Off timings if uninitialized. */
	if (INTEL_INFO(dev_priv)->gen < 5 &&
	    I915_READ(PP_ON_DELAYS) == 0 && I915_READ(PP_OFF_DELAYS) == 0) {
		/* Set T2 to 40ms and T5 to 200ms */
		I915_WRITE(PP_ON_DELAYS, 0x019007d0);

		/* Set T3 to 35ms and Tx to 200ms */
		I915_WRITE(PP_OFF_DELAYS, 0x015e07d0);

		DRM_DEBUG_KMS("Panel power timings uninitialized, setting defaults\n");
	}

	lvds_encoder = kzalloc(sizeof(*lvds_encoder), GFP_KERNEL);
	if (!lvds_encoder)
		return;

	lvds_connector = kzalloc(sizeof(*lvds_connector), GFP_KERNEL);
	if (!lvds_connector) {
		kfree(lvds_encoder);
		return;
	}

	if (intel_connector_init(&lvds_connector->base) < 0) {
		kfree(lvds_connector);
		kfree(lvds_encoder);
		return;
	}

	lvds_encoder->attached_connector = lvds_connector;

	intel_encoder = &lvds_encoder->base;
	encoder = &intel_encoder->base;
	intel_connector = &lvds_connector->base;
	connector = &intel_connector->base;
	drm_connector_init(dev, &intel_connector->base, &intel_lvds_connector_funcs,
			   DRM_MODE_CONNECTOR_LVDS);

	drm_encoder_init(dev, &intel_encoder->base, &intel_lvds_enc_funcs,
			 DRM_MODE_ENCODER_LVDS);

	intel_encoder->enable = intel_enable_lvds;
	intel_encoder->pre_enable = intel_pre_enable_lvds;
	intel_encoder->compute_config = intel_lvds_compute_config;
	if (HAS_PCH_SPLIT(dev_priv)) {
		intel_encoder->disable = pch_disable_lvds;
		intel_encoder->post_disable = pch_post_disable_lvds;
	} else {
		intel_encoder->disable = gmch_disable_lvds;
	}
	intel_encoder->get_hw_state = intel_lvds_get_hw_state;
	intel_encoder->get_config = intel_lvds_get_config;
	intel_connector->get_hw_state = intel_connector_get_hw_state;
	intel_connector->unregister = intel_connector_unregister;

	intel_connector_attach_encoder(intel_connector, intel_encoder);
	intel_encoder->type = INTEL_OUTPUT_LVDS;

	intel_encoder->cloneable = 0;
	if (HAS_PCH_SPLIT(dev))
		intel_encoder->crtc_mask = (1 << 0) | (1 << 1) | (1 << 2);
	else if (IS_GEN4(dev))
		intel_encoder->crtc_mask = (1 << 0) | (1 << 1);
	else
		intel_encoder->crtc_mask = (1 << 1);

	drm_connector_helper_add(connector, &intel_lvds_connector_helper_funcs);
	connector->display_info.subpixel_order = SubPixelHorizontalRGB;
	connector->interlace_allowed = false;
	connector->doublescan_allowed = false;

	lvds_encoder->reg = lvds_reg;

	/* create the scaling mode property */
	drm_mode_create_scaling_mode_property(dev);
	drm_object_attach_property(&connector->base,
				      dev->mode_config.scaling_mode_property,
				      DRM_MODE_SCALE_ASPECT);
	intel_connector->panel.fitting_mode = DRM_MODE_SCALE_ASPECT;
	/*
	 * LVDS discovery:
	 * 1) check for EDID on DDC
	 * 2) check for VBT data
	 * 3) check to see if LVDS is already on
	 *    if none of the above, no panel
	 * 4) make sure lid is open
	 *    if closed, act like it's not there for now
	 */

	/*
	 * Attempt to get the fixed panel mode from DDC.  Assume that the
	 * preferred mode is the right one.
	 */
	mutex_lock(&dev->mode_config.mutex);
	edid = drm_get_edid(connector, intel_gmbus_get_adapter(dev_priv, pin));
	if (edid) {
		if (drm_add_edid_modes(connector, edid)) {
			drm_mode_connector_update_edid_property(connector,
								edid);
		} else {
			kfree(edid);
			edid = ERR_PTR(-EINVAL);
		}
	} else {
		edid = ERR_PTR(-ENOENT);
	}
	lvds_connector->base.edid = edid;

	if (IS_ERR_OR_NULL(edid)) {
		/* Didn't get an EDID, so
		 * Set wide sync ranges so we get all modes
		 * handed to valid_mode for checking
		 */
		connector->display_info.min_vfreq = 0;
		connector->display_info.max_vfreq = 200;
		connector->display_info.min_hfreq = 0;
		connector->display_info.max_hfreq = 200;
	}

	list_for_each_entry(scan, &connector->probed_modes, head) {
		if (scan->type & DRM_MODE_TYPE_PREFERRED) {
			DRM_DEBUG_KMS("using preferred mode from EDID: ");
			drm_mode_debug_printmodeline(scan);

			fixed_mode = drm_mode_duplicate(dev, scan);
			if (fixed_mode)
				goto out;
		}
	}

	/* Failed to get EDID, what about VBT? */
	if (dev_priv->vbt.lfp_lvds_vbt_mode) {
		DRM_DEBUG_KMS("using mode from VBT: ");
		drm_mode_debug_printmodeline(dev_priv->vbt.lfp_lvds_vbt_mode);

		fixed_mode = drm_mode_duplicate(dev, dev_priv->vbt.lfp_lvds_vbt_mode);
		if (fixed_mode) {
			fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
			goto out;
		}
	}

	/*
	 * If we didn't get EDID, try checking if the panel is already turned
	 * on.  If so, assume that whatever is currently programmed is the
	 * correct mode.
	 */

	/* Ironlake: FIXME if still fail, not try pipe mode now */
	if (HAS_PCH_SPLIT(dev))
		goto failed;

	pipe = (lvds & LVDS_PIPEB_SELECT) ? 1 : 0;
	crtc = intel_get_crtc_for_pipe(dev, pipe);

	if (crtc && (lvds & LVDS_PORT_EN)) {
		fixed_mode = intel_crtc_mode_get(dev, crtc);
		if (fixed_mode) {
			DRM_DEBUG_KMS("using current (BIOS) mode: ");
			drm_mode_debug_printmodeline(fixed_mode);
			fixed_mode->type |= DRM_MODE_TYPE_PREFERRED;
			goto out;
		}
	}

	/* If we still don't have a mode after all that, give up. */
	if (!fixed_mode)
		goto failed;

out:
	mutex_unlock(&dev->mode_config.mutex);

	intel_panel_init(&intel_connector->panel, fixed_mode, downclock_mode);

	lvds_encoder->is_dual_link = compute_is_dual_link_lvds(lvds_encoder);
	DRM_DEBUG_KMS("detected %s-link lvds configuration\n",
		      lvds_encoder->is_dual_link ? "dual" : "single");

	lvds_encoder->a3_power = I915_READ(lvds_encoder->reg) &
				 LVDS_A3_POWER_MASK;

#ifdef notyet
	lvds_connector->lid_notifier.notifier_call = intel_lid_notify;
	if (acpi_lid_notifier_register(&lvds_connector->lid_notifier)) {
		DRM_DEBUG_KMS("lid notifier registration failed\n");
		lvds_connector->lid_notifier.notifier_call = NULL;
	}
#endif
	drm_connector_register(connector);

	intel_panel_setup_backlight(connector, INVALID_PIPE);

	return;

failed:
	mutex_unlock(&dev->mode_config.mutex);

	DRM_DEBUG_KMS("No LVDS modes found, disabling.\n");
	drm_connector_cleanup(connector);
	drm_encoder_cleanup(encoder);
	kfree(lvds_encoder);
	kfree(lvds_connector);
	return;
}
@


1.16
log
@Put a bit more unused code under #ifdef notyet to prevent a clang warning.
@
text
@a0 1
/*	$OpenBSD: intel_lvds.c,v 1.15 2015/09/23 23:12:12 kettenis Exp $	*/
d30 5
d36 1
d42 3
a49 1
#ifdef notyet
a50 1
#endif
d58 1
d79 1
d82 4
d100 1
a100 1
				  struct intel_crtc_config *pipe_config)
d104 2
a105 1
	u32 lvds_reg, tmp, flags = 0;
d108 1
a108 6
	if (HAS_PCH_SPLIT(dev))
		lvds_reg = PCH_LVDS;
	else
		lvds_reg = LVDS;

	tmp = I915_READ(lvds_reg);
d118 1
a118 1
	pipe_config->adjusted_mode.flags |= flags;
d132 1
a132 1
	pipe_config->adjusted_mode.crtc_clock = dotclock;
a134 4
/* The LVDS pin pair needs to be on before the DPLLs are enabled.
 * This is an exception to the general rule that mode_set doesn't turn
 * things on.
 */
d141 1
a141 2
	const struct drm_display_mode *adjusted_mode =
		&crtc->config.adjusted_mode;
d169 1
a169 1
	temp |= crtc->config.gmch_pfit.lvds_border_bits;
d180 2
a181 1
	 * panels behave in the two modes.
d183 2
d192 1
a192 1
		if (crtc->config.dither && crtc->config.pipe_bpp == 18)
a239 2
	struct intel_connector *intel_connector =
		&lvds_encoder->attached_connector->base;
a250 2
	intel_panel_disable_backlight(intel_connector);

d259 25
d290 1
d296 2
d303 1
a303 1
				      struct intel_crtc_config *pipe_config)
a305 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d310 2
a311 2
	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
	struct intel_crtc *intel_crtc = lvds_encoder->base.new_crtc;
d320 1
a320 2
	if ((I915_READ(lvds_encoder->reg) & LVDS_A3_POWER_MASK) ==
	    LVDS_A3_POWER_UP)
a359 9
static void intel_lvds_mode_set(struct intel_encoder *encoder)
{
	/*
	 * We don't do anything here, the LVDS port is fully set up in the pre
	 * enable hook - the ordering constraints for enabling the lvds port vs.
	 * enabling the display pll are too strict.
	 */
}

d374 1
a374 1
		      connector->base.id, drm_get_connector_name(connector));
d478 1
a478 1
		intel_modeset_setup_hw_state(dev, true);
d538 1
a538 1
		if (crtc && crtc->enabled) {
d557 1
a557 1
	.dpms = intel_connector_dpms,
d561 1
d563 2
d810 1
a810 1
		if (intel_gmbus_is_port_valid(child->i2c_pin))
d872 1
a872 2
	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
			    base.head) {
d890 7
a896 2
	if (i915_lvds_channel_mode > 0)
		return i915_lvds_channel_mode == 2;
d946 1
d949 1
d961 1
a961 1
	} else {
d972 6
a977 5
	pin = GMBUS_PORT_PANEL;
	if (!lvds_is_present_in_vbt(dev, &pin)) {
		DRM_DEBUG_KMS("LVDS is not present in VBT\n");
		return;
	}
d980 1
a980 1
		if ((I915_READ(PCH_LVDS) & LVDS_DETECTED) == 0)
d988 21
d1019 6
d1040 6
a1045 2
	intel_encoder->mode_set = intel_lvds_mode_set;
	intel_encoder->disable = intel_disable_lvds;
d1054 1
a1054 1
	intel_encoder->cloneable = false;
d1067 1
a1067 5
	if (HAS_PCH_SPLIT(dev)) {
		lvds_encoder->reg = PCH_LVDS;
	} else {
		lvds_encoder->reg = LVDS;
	}
d1089 1
d1121 1
a1121 17
			if (fixed_mode) {
				intel_connector->panel.downclock_mode =
					intel_find_panel_downclock(dev,
					fixed_mode, connector);
				if (intel_connector->panel.downclock_mode !=
					NULL &&	i915_lvds_downclock) {
					/* We found the downclock for LVDS. */
					dev_priv->lvds_downclock_avail = true;
					dev_priv->lvds_downclock =
						intel_connector->panel.
						downclock_mode->clock;
					DRM_DEBUG_KMS("LVDS downclock is found"
					" in EDID. Normal clock %dKhz, "
					"downclock %dKhz\n",
					fixed_mode->clock,
					dev_priv->lvds_downclock);
				}
a1122 1
			}
a1147 1
	lvds = I915_READ(LVDS);
d1166 4
d1174 3
d1184 1
a1184 1
	drm_sysfs_connector_add(connector);
d1186 1
a1186 2
	intel_panel_init(&intel_connector->panel, fixed_mode);
	intel_panel_setup_backlight(connector);
d1191 2
a1195 2
	if (fixed_mode)
		drm_mode_destroy(dev, fixed_mode);
@


1.15
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.14 2015/04/12 11:26:54 jsg Exp $	*/
d385 1
a405 1
#ifdef notyet
@


1.14
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.13 2015/02/11 07:01:37 jsg Exp $	*/
d50 2
a51 3
	u32 pfit_control;
	u32 pfit_pgm_ratios;
	bool pfit_dirty;
d71 2
a72 7
	u32 lvds_reg, tmp;

	if (HAS_PCH_SPLIT(dev)) {
		lvds_reg = PCH_LVDS;
	} else {
		lvds_reg = LVDS;
	}
d74 1
a74 1
	tmp = I915_READ(lvds_reg);
d87 113
d207 2
a208 1
	struct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);
d210 1
a210 1
	u32 ctl_reg, lvds_reg, stat_reg;
a213 1
		lvds_reg = PCH_LVDS;
a216 1
		lvds_reg = LVDS;
d220 1
a220 17
	I915_WRITE(lvds_reg, I915_READ(lvds_reg) | LVDS_PORT_EN);

	if (lvds_encoder->pfit_dirty) {
		/*
		 * Enable automatic panel scaling so that non-native modes
		 * fill the screen.  The panel fitter should only be
		 * adjusted whilst the pipe is disabled, according to
		 * register description and PRM.
		 */
		DRM_DEBUG_KMS("applying panel-fitter: %x, %x\n",
			      lvds_encoder->pfit_control,
			      lvds_encoder->pfit_pgm_ratios);

		I915_WRITE(PFIT_PGM_RATIOS, lvds_encoder->pfit_pgm_ratios);
		I915_WRITE(PFIT_CONTROL, lvds_encoder->pfit_control);
		lvds_encoder->pfit_dirty = false;
	}
d223 1
a223 1
	POSTING_READ(lvds_reg);
d227 1
a227 1
	intel_panel_enable_backlight(dev, intel_crtc->pipe);
d234 2
d237 1
a237 1
	u32 ctl_reg, lvds_reg, stat_reg;
a240 1
		lvds_reg = PCH_LVDS;
a243 1
		lvds_reg = LVDS;
d247 1
a247 1
	intel_panel_disable_backlight(dev);
d253 2
a254 7
	if (lvds_encoder->pfit_control) {
		I915_WRITE(PFIT_CONTROL, 0);
		lvds_encoder->pfit_dirty = true;
	}

	I915_WRITE(lvds_reg, I915_READ(lvds_reg) & ~LVDS_PORT_EN);
	POSTING_READ(lvds_reg);
d257 3
a259 2
static int intel_lvds_mode_valid(struct drm_connector *connector,
				 struct drm_display_mode *mode)
d272 2
a273 48
static void
centre_horizontally(struct drm_display_mode *mode,
		    int width)
{
	u32 border, sync_pos, blank_width, sync_width;

	/* keep the hsync and hblank widths constant */
	sync_width = mode->crtc_hsync_end - mode->crtc_hsync_start;
	blank_width = mode->crtc_hblank_end - mode->crtc_hblank_start;
	sync_pos = (blank_width - sync_width + 1) / 2;

	border = (mode->hdisplay - width + 1) / 2;
	border += border & 1; /* make the border even */

	mode->crtc_hdisplay = width;
	mode->crtc_hblank_start = width + border;
	mode->crtc_hblank_end = mode->crtc_hblank_start + blank_width;

	mode->crtc_hsync_start = mode->crtc_hblank_start + sync_pos;
	mode->crtc_hsync_end = mode->crtc_hsync_start + sync_width;

	mode->private_flags |= INTEL_MODE_CRTC_TIMINGS_SET;
}

static void
centre_vertically(struct drm_display_mode *mode,
		  int height)
{
	u32 border, sync_pos, blank_width, sync_width;

	/* keep the vsync and vblank widths constant */
	sync_width = mode->crtc_vsync_end - mode->crtc_vsync_start;
	blank_width = mode->crtc_vblank_end - mode->crtc_vblank_start;
	sync_pos = (blank_width - sync_width + 1) / 2;

	border = (mode->vdisplay - height + 1) / 2;

	mode->crtc_vdisplay = height;
	mode->crtc_vblank_start = height + border;
	mode->crtc_vblank_end = mode->crtc_vblank_start + blank_width;

	mode->crtc_vsync_start = mode->crtc_vblank_start + sync_pos;
	mode->crtc_vsync_end = mode->crtc_vsync_start + sync_width;

	mode->private_flags |= INTEL_MODE_CRTC_TIMINGS_SET;
}

static inline u32 panel_fitter_scaling(u32 source, u32 target)
d275 1
a275 16
	/*
	 * Floating point operation is not supported. So the FACTOR
	 * is defined, which can avoid the floating point computation
	 * when calculating the panel ratio.
	 */
#define ACCURACY 12
#define FACTOR (1 << ACCURACY)
	u32 ratio = source * FACTOR / target;
	return (FACTOR * ratio + FACTOR/2) / FACTOR;
}

static bool intel_lvds_mode_fixup(struct drm_encoder *encoder,
				  const struct drm_display_mode *mode,
				  struct drm_display_mode *adjusted_mode)
{
	struct drm_device *dev = encoder->dev;
d277 2
a278 1
	struct intel_lvds_encoder *lvds_encoder = to_lvds_encoder(encoder);
d281 1
d283 1
a283 2
	u32 pfit_control = 0, pfit_pgm_ratios = 0, border = 0;
	int pipe;
d291 11
a301 2
	if (intel_encoder_check_is_cloned(&lvds_encoder->base))
		return false;
d313 1
a313 5
		intel_pch_panel_fitting(dev,
					intel_connector->panel.fitting_mode,
					mode, adjusted_mode);
		return true;
	}
d315 5
a319 85
	/* Native modes don't need fitting */
	if (adjusted_mode->hdisplay == mode->hdisplay &&
	    adjusted_mode->vdisplay == mode->vdisplay)
		goto out;

	/* 965+ wants fuzzy fitting */
	if (INTEL_INFO(dev)->gen >= 4)
		pfit_control |= ((intel_crtc->pipe << PFIT_PIPE_SHIFT) |
				 PFIT_FILTER_FUZZY);

	/*
	 * Enable automatic panel scaling for non-native modes so that they fill
	 * the screen.  Should be enabled before the pipe is enabled, according
	 * to register description and PRM.
	 * Change the value here to see the borders for debugging
	 */
	for_each_pipe(pipe)
		I915_WRITE(BCLRPAT(pipe), 0);

	drm_mode_set_crtcinfo(adjusted_mode, 0);

	switch (intel_connector->panel.fitting_mode) {
	case DRM_MODE_SCALE_CENTER:
		/*
		 * For centered modes, we have to calculate border widths &
		 * heights and modify the values programmed into the CRTC.
		 */
		centre_horizontally(adjusted_mode, mode->hdisplay);
		centre_vertically(adjusted_mode, mode->vdisplay);
		border = LVDS_BORDER_ENABLE;
		break;

	case DRM_MODE_SCALE_ASPECT:
		/* Scale but preserve the aspect ratio */
		if (INTEL_INFO(dev)->gen >= 4) {
			u32 scaled_width = adjusted_mode->hdisplay * mode->vdisplay;
			u32 scaled_height = mode->hdisplay * adjusted_mode->vdisplay;

			/* 965+ is easy, it does everything in hw */
			if (scaled_width > scaled_height)
				pfit_control |= PFIT_ENABLE | PFIT_SCALING_PILLAR;
			else if (scaled_width < scaled_height)
				pfit_control |= PFIT_ENABLE | PFIT_SCALING_LETTER;
			else if (adjusted_mode->hdisplay != mode->hdisplay)
				pfit_control |= PFIT_ENABLE | PFIT_SCALING_AUTO;
		} else {
			u32 scaled_width = adjusted_mode->hdisplay * mode->vdisplay;
			u32 scaled_height = mode->hdisplay * adjusted_mode->vdisplay;
			/*
			 * For earlier chips we have to calculate the scaling
			 * ratio by hand and program it into the
			 * PFIT_PGM_RATIO register
			 */
			if (scaled_width > scaled_height) { /* pillar */
				centre_horizontally(adjusted_mode, scaled_height / mode->vdisplay);

				border = LVDS_BORDER_ENABLE;
				if (mode->vdisplay != adjusted_mode->vdisplay) {
					u32 bits = panel_fitter_scaling(mode->vdisplay, adjusted_mode->vdisplay);
					pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |
							    bits << PFIT_VERT_SCALE_SHIFT);
					pfit_control |= (PFIT_ENABLE |
							 VERT_INTERP_BILINEAR |
							 HORIZ_INTERP_BILINEAR);
				}
			} else if (scaled_width < scaled_height) { /* letter */
				centre_vertically(adjusted_mode, scaled_width / mode->hdisplay);

				border = LVDS_BORDER_ENABLE;
				if (mode->hdisplay != adjusted_mode->hdisplay) {
					u32 bits = panel_fitter_scaling(mode->hdisplay, adjusted_mode->hdisplay);
					pfit_pgm_ratios |= (bits << PFIT_HORIZ_SCALE_SHIFT |
							    bits << PFIT_VERT_SCALE_SHIFT);
					pfit_control |= (PFIT_ENABLE |
							 VERT_INTERP_BILINEAR |
							 HORIZ_INTERP_BILINEAR);
				}
			} else
				/* Aspects match, Let hw scale both directions */
				pfit_control |= (PFIT_ENABLE |
						 VERT_AUTO_SCALE | HORIZ_AUTO_SCALE |
						 VERT_INTERP_BILINEAR |
						 HORIZ_INTERP_BILINEAR);
		}
		break;
a320 20
	case DRM_MODE_SCALE_FULLSCREEN:
		/*
		 * Full scaling, even if it changes the aspect ratio.
		 * Fortunately this is all done for us in hw.
		 */
		if (mode->vdisplay != adjusted_mode->vdisplay ||
		    mode->hdisplay != adjusted_mode->hdisplay) {
			pfit_control |= PFIT_ENABLE;
			if (INTEL_INFO(dev)->gen >= 4)
				pfit_control |= PFIT_SCALING_AUTO;
			else
				pfit_control |= (VERT_AUTO_SCALE |
						 VERT_INTERP_BILINEAR |
						 HORIZ_AUTO_SCALE |
						 HORIZ_INTERP_BILINEAR);
		}
		break;

	default:
		break;
a322 19
out:
	/* If not enabling scaling, be consistent and always use 0. */
	if ((pfit_control & PFIT_ENABLE) == 0) {
		pfit_control = 0;
		pfit_pgm_ratios = 0;
	}

	/* Make sure pre-965 set dither correctly */
	if (INTEL_INFO(dev)->gen < 4 && dev_priv->lvds_dither)
		pfit_control |= PANEL_8TO6_DITHER_ENABLE;

	if (pfit_control != lvds_encoder->pfit_control ||
	    pfit_pgm_ratios != lvds_encoder->pfit_pgm_ratios) {
		lvds_encoder->pfit_control = pfit_control;
		lvds_encoder->pfit_pgm_ratios = pfit_pgm_ratios;
		lvds_encoder->pfit_dirty = true;
	}
	dev_priv->lvds_border_bits = border;

d332 1
a332 3
static void intel_lvds_mode_set(struct drm_encoder *encoder,
				struct drm_display_mode *mode,
				struct drm_display_mode *adjusted_mode)
d335 3
a337 3
	 * The LVDS pin pair will already have been turned on in the
	 * intel_crtc_mode_set since it has a large impact on the DPLL
	 * settings.
d354 3
d407 3
a409 2
 * Lid events. Note the use of 'modeset_on_lid':
 *  - we set it on lid close, and reset it on open
d411 4
a414 4
 *    duplicate events where it was already properly
 *    set/reset)
 *  - the suspend/resume paths will also set it to
 *    zero, since they restore the mode ("lid open").
d428 3
d439 1
a439 1
		return NOTIFY_OK;
d441 3
a443 2
		dev_priv->modeset_on_lid = 1;
		return NOTIFY_OK;
d446 2
a447 2
	if (!dev_priv->modeset_on_lid)
		return NOTIFY_OK;
d449 13
a461 1
	dev_priv->modeset_on_lid = 0;
d463 1
a463 3
	mutex_lock(&dev->mode_config.mutex);
	intel_modeset_setup_hw_state(dev, true);
	mutex_unlock(&dev->mode_config.mutex);
d465 2
a492 1
	drm_sysfs_connector_remove(connector);
d524 1
a524 2
			intel_set_mode(crtc, &crtc->mode,
				       crtc->x, crtc->y, crtc->fb);
a530 6
static const struct drm_encoder_helper_funcs intel_lvds_helper_funcs = {
	.mode_fixup = intel_lvds_mode_fixup,
	.mode_set = intel_lvds_mode_set,
	.disable = intel_encoder_noop,
};

d549 1
a549 1
static int __init intel_no_lvds_dmi_callback(const struct dmi_system_id *id)
a759 51
/**
 * intel_find_lvds_downclock - find the reduced downclock for LVDS in EDID
 * @@dev: drm device
 * @@connector: LVDS connector
 *
 * Find the reduced downclock for LVDS in EDID.
 */
static void intel_find_lvds_downclock(struct drm_device *dev,
				      struct drm_display_mode *fixed_mode,
				      struct drm_connector *connector)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_display_mode *scan;
	int temp_downclock;

	temp_downclock = fixed_mode->clock;
	list_for_each_entry(scan, &connector->probed_modes, head) {
		/*
		 * If one mode has the same resolution with the fixed_panel
		 * mode while they have the different refresh rate, it means
		 * that the reduced downclock is found for the LVDS. In such
		 * case we can set the different FPx0/1 to dynamically select
		 * between low and high frequency.
		 */
		if (scan->hdisplay == fixed_mode->hdisplay &&
		    scan->hsync_start == fixed_mode->hsync_start &&
		    scan->hsync_end == fixed_mode->hsync_end &&
		    scan->htotal == fixed_mode->htotal &&
		    scan->vdisplay == fixed_mode->vdisplay &&
		    scan->vsync_start == fixed_mode->vsync_start &&
		    scan->vsync_end == fixed_mode->vsync_end &&
		    scan->vtotal == fixed_mode->vtotal) {
			if (scan->clock < temp_downclock) {
				/*
				 * The downclock is already found. But we
				 * expect to find the lower downclock.
				 */
				temp_downclock = scan->clock;
			}
		}
	}
	if (temp_downclock < fixed_mode->clock && i915_lvds_downclock) {
		/* We found the downclock for LVDS. */
		dev_priv->lvds_downclock_avail = 1;
		dev_priv->lvds_downclock = temp_downclock;
		DRM_DEBUG_KMS("LVDS downclock is found in EDID. "
			      "Normal clock %dKhz, downclock %dKhz\n",
			      fixed_mode->clock, temp_downclock);
	}
}

d773 1
a773 1
	if (!dev_priv->child_dev_num)
d776 3
a778 2
	for (i = 0; i < dev_priv->child_dev_num; i++) {
		struct child_device_config *child = dev_priv->child_dev + i;
d811 76
d891 1
a891 1
	if (HAS_PCH_SPLIT(dev))
d896 4
a899 1
	return IS_MOBILE(dev) && !IS_I830(dev);
d909 1
a909 1
bool intel_lvds_init(struct drm_device *dev)
d926 11
d938 1
a938 1
		return false;
d942 1
a942 1
		return false;
d947 1
a947 1
		return false;
d952 2
a953 2
			return false;
		if (dev_priv->edp.support) {
d955 1
a955 1
			return false;
d959 1
a959 1
	lvds_encoder = kzalloc(sizeof(struct intel_lvds_encoder), GFP_KERNEL);
d961 1
a961 1
		return false;
d963 1
a963 1
	lvds_connector = kzalloc(sizeof(struct intel_lvds_connector), GFP_KERNEL);
d966 1
a966 1
		return false;
a970 4
	if (!HAS_PCH_SPLIT(dev)) {
		lvds_encoder->pfit_control = I915_READ(PFIT_CONTROL);
	}

d982 3
d987 1
d989 1
a1001 1
	drm_encoder_helper_add(encoder, &intel_lvds_helper_funcs);
d1007 6
d1065 16
a1080 2
				intel_find_lvds_downclock(dev, fixed_mode,
							  connector);
d1087 1
a1087 1
	if (dev_priv->lfp_lvds_vbt_mode) {
d1089 1
a1089 1
		drm_mode_debug_printmodeline(dev_priv->lfp_lvds_vbt_mode);
d1091 1
a1091 1
		fixed_mode = drm_mode_duplicate(dev, dev_priv->lfp_lvds_vbt_mode);
d1127 4
a1130 11
	/*
	 * Unlock registers and just
	 * leave them unlocked
	 */
	if (HAS_PCH_SPLIT(dev)) {
		I915_WRITE(PCH_PP_CONTROL,
			   I915_READ(PCH_PP_CONTROL) | PANEL_UNLOCK_REGS);
	} else {
		I915_WRITE(PP_CONTROL,
			   I915_READ(PP_CONTROL) | PANEL_UNLOCK_REGS);
	}
d1143 1
a1143 1
	return true;
d1153 1
a1153 1
	return false;
@


1.13
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.12 2015/02/10 03:39:41 jsg Exp $	*/
a102 1
	int retries;
d134 1
a134 6
	for (retries = 1000; retries > 0; retries--) {
		if ((I915_READ(stat_reg) & PP_ON) != 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
a145 1
	int retries;
d160 1
a160 6
	for (retries = 1000; retries > 0; retries--) {
		if ((I915_READ(stat_reg) & PP_ON) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
@


1.12
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.11 2014/01/22 22:33:24 jsg Exp $	*/
d486 1
a486 1
	printf("Skipping forced modeset for %s\n", id->ident);
d641 1
a641 1
	printf("Skipping LVDS initialization for %s\n", id->ident);
@


1.11
log
@drm/i915: No LVDS hardware on Intel D410PT and D425KT

From Rob Pearce
4694d14ae2ffe12fa49f4b3e57d5c7a6b74c0856 in ubuntu 3.8
645378d85ee524e429aa4cf52806047b56cdc596 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.10 2014/01/22 22:28:31 jsg Exp $	*/
d545 1
a545 1
	rw_enter_write(&dev->mode_config.rwl);
d547 1
a547 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.10
log
@drm/i915: quirk away phantom LVDS on Intel's D525MW mainboard

From Jani Nikula
24498530d1a0246d7995baa386ee4fc0208911b2 in in ubuntu 3.8
dcf6d294830d46b0e6901477fb4bf455281d90c8 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.9 2014/01/22 22:21:52 jsg Exp $	*/
d812 16
@


1.9
log
@drm/i915: quirk away phantom LVDS on Intel's D510MO mainboard

From Chris Wilson
b818e76978dda65f9c749970ebef14490eb93387 in ubuntu 3.8
e5614f0c2d0f4d7f0b8ef745d34593baf2c5dbf8 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.8 2014/01/22 05:16:55 kettenis Exp $	*/
d820 8
@


1.8
log
@Provide inline dummy implementations of drm_sysfs_connector_add() and
drm_sysfs_connector_remove() and call those instead of #ifdef'ing them out.
Reduces the noise when diffing against Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.7 2014/01/21 08:57:22 kettenis Exp $	*/
d812 8
@


1.7
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.6 2013/12/01 14:28:40 kettenis Exp $	*/
a574 1
#if 0
a575 1
#endif
d1142 1
a1143 1
#endif
@


1.6
log
@drm/i915: no lvds quirk for hp t5740

From Ben Mesman
117b91f41d99e88338e1f9577ced365e777a9098 in ubuntu 3.8
45a211d75137b1ac869a8a758a6667f15827a115 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.5 2013/08/13 10:23:51 jsg Exp $	*/
d571 1
a571 1
		free(lvds_connector->base.edid, M_DRM);
d579 1
a579 1
	free(connector, M_DRM);
d979 1
a979 2
	lvds_encoder = malloc(sizeof(struct intel_lvds_encoder), M_DRM,
	    M_WAITOK | M_ZERO);
d983 1
a983 2
	lvds_connector = malloc(sizeof(struct intel_lvds_connector), M_DRM,
	    M_WAITOK | M_ZERO);
d985 1
a985 1
		free(lvds_encoder, M_DRM);
d1053 1
a1053 1
			free(edid, M_DRM);
d1158 2
a1159 2
	free(lvds_encoder, M_DRM);
	free(lvds_connector, M_DRM);
@


1.5
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.4 2013/07/05 07:20:27 jsg Exp $	*/
d762 1
a762 1
		.ident = "Hewlett-Packard HP t5740e Thin Client",
d765 1
a765 1
			DMI_MATCH(DMI_PRODUCT_NAME, "HP t5740e Thin Client"),
@


1.4
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.3 2013/07/04 09:55:01 jsg Exp $	*/
d57 1
a57 34
struct intel_lvds	*to_intel_lvds(struct drm_encoder *);
struct intel_lvds	*intel_attached_lvds(struct drm_connector *);
void	 intel_enable_lvds(struct intel_encoder *);
void	 intel_disable_lvds(struct intel_encoder *);
void	 intel_lvds_dpms(struct drm_encoder *, int);
int	 intel_lvds_mode_valid(struct drm_connector *,
	     struct drm_display_mode *);
void	 centre_horizontally(struct drm_display_mode *, int);
void	 centre_vertically(struct drm_display_mode *, int);
bool	 intel_lvds_mode_fixup(struct drm_encoder *,
	     const struct drm_display_mode *, struct drm_display_mode *);
void	 intel_lvds_prepare(struct drm_encoder *);
void	 intel_lvds_commit(struct drm_encoder *);
void	 intel_lvds_mode_set(struct drm_encoder *, struct drm_display_mode *,
	     struct drm_display_mode *);
enum drm_connector_status	 intel_lvds_detect(struct drm_connector *,
				     bool);
int	 intel_lvds_get_modes(struct drm_connector *);
int	 intel_no_modeset_on_lid_dmi_callback(const struct dmi_system_id *);
void	 intel_lvds_destroy(struct drm_connector *);
int	 intel_lvds_set_property(struct drm_connector *,
	     struct drm_property *, uint64_t);
int	 intel_no_lvds_dmi_callback(const struct dmi_system_id *);
void	 intel_find_lvds_downclock(struct drm_device *,
	     struct drm_display_mode *, struct drm_connector *);
bool	 lvds_is_present_in_vbt(struct drm_device *, u8 *);
bool	 intel_lvds_supported(struct drm_device *);
struct intel_lvds_encoder *to_lvds_encoder(struct drm_encoder *);
struct intel_lvds_connector *to_lvds_connector(struct drm_connector *);
bool	 intel_lvds_get_hw_state(struct intel_encoder *, enum pipe *);


struct intel_lvds_encoder *
to_lvds_encoder(struct drm_encoder *encoder)
d62 1
a62 2
struct intel_lvds_connector *
to_lvds_connector(struct drm_connector *connector)
d67 1
a67 2
bool
intel_lvds_get_hw_state(struct intel_encoder *encoder,
d96 1
a96 2
void
intel_enable_lvds(struct intel_encoder *encoder)
d146 1
a146 2
void
intel_disable_lvds(struct intel_encoder *encoder)
d184 1
a184 2
int
intel_lvds_mode_valid(struct drm_connector *connector,
d198 1
a198 1
void
d222 1
a222 1
void
d245 1
a245 2
static inline u32
panel_fitter_scaling(u32 source, u32 target)
d258 1
a258 2
bool
intel_lvds_mode_fixup(struct drm_encoder *encoder,
d432 1
a432 2
void
intel_lvds_mode_set(struct drm_encoder *encoder,
d450 1
a450 1
enum drm_connector_status
d466 1
a466 2
int
intel_lvds_get_modes(struct drm_connector *connector)
d484 1
a484 2
int
intel_no_modeset_on_lid_dmi_callback(const struct dmi_system_id *id)
d514 1
a514 2
int
intel_lid_notify(struct notifier_block *nb, unsigned long val,
d560 1
a560 2
void
intel_lvds_destroy(struct drm_connector *connector)
d582 1
a582 2
int
intel_lvds_set_property(struct drm_connector *connector,
d641 1
a641 2
int
intel_no_lvds_dmi_callback(const struct dmi_system_id *id)
d827 1
a827 2
void
intel_find_lvds_downclock(struct drm_device *dev,
d878 1
a878 2
bool
lvds_is_present_in_vbt(struct drm_device *dev,
d921 1
a921 2
bool
intel_lvds_supported(struct drm_device *dev)
d940 1
a940 2
bool
intel_lvds_init(struct drm_device *dev)
@


1.3
log
@ensure single initialization and cleanup of backlight device
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.2 2013/07/04 09:42:46 jsg Exp $	*/
d106 1
a106 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d137 1
a137 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d187 1
a187 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d303 1
a303 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d565 1
a565 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d879 1
a879 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d930 1
a930 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d993 1
a993 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@


1.2
log
@Add no-lvds quirk for Fujitsu Esprimo Q900
from linux 3.8.13
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_lvds.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
a617 1
	intel_panel_destroy_backlight(connector->dev);
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d854 8
@

