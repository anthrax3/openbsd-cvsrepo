head	1.8;
access;
symbols
	OPENBSD_6_2_BASE:1.8
	OPENBSD_6_1:1.7.0.8
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.6
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.4.0.6
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	KnwRPOZok9A30HI4;

1.7
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	lQlppvmETCN49oZe;

1.6
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.5;
commitid	C5l5rZ5v9mpRR1eS;

1.5
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.4;
commitid	a8Vt7gSt34kmziIS;

1.4
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.08.13.10.23.52;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright Â© 2011 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Authors:
 *   Jesse Barnes <jbarnes@@virtuousgeek.org>
 *
 * New plane/sprite handling.
 *
 * The older chips had a separate interface for programming plane related
 * registers; newer ones are much simpler and we can use the new DRM plane
 * support.
 */
#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_fourcc.h>
#include <dev/pci/drm/drm_rect.h>
#include <dev/pci/drm/drm_atomic.h>
#include <dev/pci/drm/drm_plane_helper.h>
#include "intel_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"

static bool
format_is_yuv(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_YVYU:
		return true;
	default:
		return false;
	}
}

static int usecs_to_scanlines(const struct drm_display_mode *adjusted_mode,
			      int usecs)
{
	/* paranoia */
	if (!adjusted_mode->crtc_htotal)
		return 1;

	return DIV_ROUND_UP(usecs * adjusted_mode->crtc_clock,
			    1000 * adjusted_mode->crtc_htotal);
}

/**
 * intel_pipe_update_start() - start update of a set of display registers
 * @@crtc: the crtc of which the registers are going to be updated
 * @@start_vbl_count: vblank counter return pointer used for error checking
 *
 * Mark the start of an update to pipe registers that should be updated
 * atomically regarding vblank. If the next vblank will happens within
 * the next 100 us, this function waits until the vblank passes.
 *
 * After a successful call to this function, interrupts will be disabled
 * until a subsequent call to intel_pipe_update_end(). That is done to
 * avoid random delays. The value written to @@start_vbl_count should be
 * supplied to intel_pipe_update_end() for error checking.
 */
void intel_pipe_update_start(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	const struct drm_display_mode *adjusted_mode = &crtc->config->base.adjusted_mode;
	enum pipe pipe = crtc->pipe;
	long timeout = msecs_to_jiffies_timeout(1);
	int scanline, min, max, vblank_start;
	wait_queue_head_t *wq = drm_crtc_vblank_waitqueue(&crtc->base);
	struct sleep_state sls;

	vblank_start = adjusted_mode->crtc_vblank_start;
	if (adjusted_mode->flags & DRM_MODE_FLAG_INTERLACE)
		vblank_start = DIV_ROUND_UP(vblank_start, 2);

	/* FIXME needs to be calibrated sensibly */
	min = vblank_start - usecs_to_scanlines(adjusted_mode, 100);
	max = vblank_start - 1;

	local_irq_disable();

	if (min <= 0 || max <= 0)
		return;

	if (WARN_ON(drm_crtc_vblank_get(&crtc->base)) || cold)
		return;

	crtc->debug.min_vbl = min;
	crtc->debug.max_vbl = max;
	trace_i915_pipe_update_start(crtc);

	KASSERT(!cold);
	for (;;) {
		/*
		 * prepare_to_wait() has a memory barrier, which guarantees
		 * other CPUs can see the task state update by the time we
		 * read the scanline.
		 */
		sleep_setup(&sls, wq, PZERO, "ipus");

		scanline = intel_get_crtc_scanline(crtc);
		if (scanline < min || scanline > max)
			break;

		if (timeout <= 0) {
			DRM_ERROR("Potential atomic update failure on pipe %c\n",
				  pipe_name(crtc->pipe));
			break;
		}

		local_irq_enable();

		sleep_setup_timeout(&sls, timeout);
		sleep_finish(&sls, 1);
		if (sleep_finish_timeout(&sls))
			timeout = -EWOULDBLOCK;

		local_irq_disable();
	}

	sleep_finish(&sls, 0);

	drm_crtc_vblank_put(&crtc->base);

	crtc->debug.scanline_start = scanline;
	crtc->debug.start_vbl_time = ktime_get();
	crtc->debug.start_vbl_count =
		dev->driver->get_vblank_counter(dev, pipe);

	trace_i915_pipe_update_vblank_evaded(crtc);
}

/**
 * intel_pipe_update_end() - end update of a set of display registers
 * @@crtc: the crtc of which the registers were updated
 * @@start_vbl_count: start vblank counter (used for error checking)
 *
 * Mark the end of an update started with intel_pipe_update_start(). This
 * re-enables interrupts and verifies the update was actually completed
 * before a vblank using the value of @@start_vbl_count.
 */
void intel_pipe_update_end(struct intel_crtc *crtc)
{
	struct drm_device *dev = crtc->base.dev;
	enum pipe pipe = crtc->pipe;
	int scanline_end = intel_get_crtc_scanline(crtc);
	u32 end_vbl_count = dev->driver->get_vblank_counter(dev, pipe);
	ktime_t end_vbl_time = ktime_get();

	trace_i915_pipe_update_end(crtc, end_vbl_count, scanline_end);

	local_irq_enable();

	if (crtc->debug.start_vbl_count &&
	    crtc->debug.start_vbl_count != end_vbl_count) {
		DRM_ERROR("Atomic update failure on pipe %c (start=%u end=%u) time %lld us, min %d, max %d, scanline start %d, end %d\n",
			  pipe_name(pipe), crtc->debug.start_vbl_count,
			  end_vbl_count,
			  ktime_us_delta(end_vbl_time, crtc->debug.start_vbl_time),
			  crtc->debug.min_vbl, crtc->debug.max_vbl,
			  crtc->debug.scanline_start, scanline_end);
	}
}

static void
skl_update_plane(struct drm_plane *drm_plane, struct drm_crtc *crtc,
		 struct drm_framebuffer *fb,
		 int crtc_x, int crtc_y,
		 unsigned int crtc_w, unsigned int crtc_h,
		 uint32_t x, uint32_t y,
		 uint32_t src_w, uint32_t src_h)
{
	struct drm_device *dev = drm_plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(drm_plane);
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	const int pipe = intel_plane->pipe;
	const int plane = intel_plane->plane + 1;
	u32 plane_ctl, stride_div, stride;
	int pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
	const struct drm_intel_sprite_colorkey *key =
		&to_intel_plane_state(drm_plane->state)->ckey;
	u32 surf_addr;
	u32 tile_height, plane_offset, plane_size;
	unsigned int rotation;
	int x_offset, y_offset;
	struct intel_crtc_state *crtc_state = to_intel_crtc(crtc)->config;
	int scaler_id;

	plane_ctl = PLANE_CTL_ENABLE |
		PLANE_CTL_PIPE_GAMMA_ENABLE |
		PLANE_CTL_PIPE_CSC_ENABLE;

	plane_ctl |= skl_plane_ctl_format(fb->pixel_format);
	plane_ctl |= skl_plane_ctl_tiling(fb->modifier[0]);

	rotation = drm_plane->state->rotation;
	plane_ctl |= skl_plane_ctl_rotation(rotation);

	intel_update_sprite_watermarks(drm_plane, crtc, src_w, src_h,
				       pixel_size, true,
				       src_w != crtc_w || src_h != crtc_h);

	stride_div = intel_fb_stride_alignment(dev, fb->modifier[0],
					       fb->pixel_format);

	scaler_id = to_intel_plane_state(drm_plane->state)->scaler_id;

	/* Sizes are 0 based */
	src_w--;
	src_h--;
	crtc_w--;
	crtc_h--;

	if (key->flags) {
		I915_WRITE(PLANE_KEYVAL(pipe, plane), key->min_value);
		I915_WRITE(PLANE_KEYMAX(pipe, plane), key->max_value);
		I915_WRITE(PLANE_KEYMSK(pipe, plane), key->channel_mask);
	}

	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		plane_ctl |= PLANE_CTL_KEY_ENABLE_DESTINATION;
	else if (key->flags & I915_SET_COLORKEY_SOURCE)
		plane_ctl |= PLANE_CTL_KEY_ENABLE_SOURCE;

	surf_addr = intel_plane_obj_offset(intel_plane, obj, 0);

	if (intel_rotation_90_or_270(rotation)) {
		/* stride: Surface height in tiles */
		tile_height = intel_tile_height(dev, fb->pixel_format,
						fb->modifier[0], 0);
		stride = DIV_ROUND_UP(fb->height, tile_height);
		plane_size = (src_w << 16) | src_h;
		x_offset = stride * tile_height - y - (src_h + 1);
		y_offset = x;
	} else {
		stride = fb->pitches[0] / stride_div;
		plane_size = (src_h << 16) | src_w;
		x_offset = x;
		y_offset = y;
	}
	plane_offset = y_offset << 16 | x_offset;

	I915_WRITE(PLANE_OFFSET(pipe, plane), plane_offset);
	I915_WRITE(PLANE_STRIDE(pipe, plane), stride);
	I915_WRITE(PLANE_SIZE(pipe, plane), plane_size);

	/* program plane scaler */
	if (scaler_id >= 0) {
		uint32_t ps_ctrl = 0;

		DRM_DEBUG_KMS("plane = %d PS_PLANE_SEL(plane) = 0x%x\n", plane,
			PS_PLANE_SEL(plane));
		ps_ctrl = PS_SCALER_EN | PS_PLANE_SEL(plane) |
			crtc_state->scaler_state.scalers[scaler_id].mode;
		I915_WRITE(SKL_PS_CTRL(pipe, scaler_id), ps_ctrl);
		I915_WRITE(SKL_PS_PWR_GATE(pipe, scaler_id), 0);
		I915_WRITE(SKL_PS_WIN_POS(pipe, scaler_id), (crtc_x << 16) | crtc_y);
		I915_WRITE(SKL_PS_WIN_SZ(pipe, scaler_id),
			((crtc_w + 1) << 16)|(crtc_h + 1));

		I915_WRITE(PLANE_POS(pipe, plane), 0);
	} else {
		I915_WRITE(PLANE_POS(pipe, plane), (crtc_y << 16) | crtc_x);
	}

	I915_WRITE(PLANE_CTL(pipe, plane), plane_ctl);
	I915_WRITE(PLANE_SURF(pipe, plane), surf_addr);
	POSTING_READ(PLANE_SURF(pipe, plane));
}

static void
skl_disable_plane(struct drm_plane *dplane, struct drm_crtc *crtc)
{
	struct drm_device *dev = dplane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(dplane);
	const int pipe = intel_plane->pipe;
	const int plane = intel_plane->plane + 1;

	I915_WRITE(PLANE_CTL(pipe, plane), 0);

	I915_WRITE(PLANE_SURF(pipe, plane), 0);
	POSTING_READ(PLANE_SURF(pipe, plane));

	intel_update_sprite_watermarks(dplane, crtc, 0, 0, 0, false, false);
}

static void
chv_update_csc(struct intel_plane *intel_plane, uint32_t format)
{
	struct drm_i915_private *dev_priv = intel_plane->base.dev->dev_private;
	int plane = intel_plane->plane;

	/* Seems RGB data bypasses the CSC always */
	if (!format_is_yuv(format))
		return;

	/*
	 * BT.601 limited range YCbCr -> full range RGB
	 *
	 * |r|   | 6537 4769     0|   |cr  |
	 * |g| = |-3330 4769 -1605| x |y-64|
	 * |b|   |    0 4769  8263|   |cb  |
	 *
	 * Cb and Cr apparently come in as signed already, so no
	 * need for any offset. For Y we need to remove the offset.
	 */
	I915_WRITE(SPCSCYGOFF(plane), SPCSC_OOFF(0) | SPCSC_IOFF(-64));
	I915_WRITE(SPCSCCBOFF(plane), SPCSC_OOFF(0) | SPCSC_IOFF(0));
	I915_WRITE(SPCSCCROFF(plane), SPCSC_OOFF(0) | SPCSC_IOFF(0));

	I915_WRITE(SPCSCC01(plane), SPCSC_C1(4769) | SPCSC_C0(6537));
	I915_WRITE(SPCSCC23(plane), SPCSC_C1(-3330) | SPCSC_C0(0));
	I915_WRITE(SPCSCC45(plane), SPCSC_C1(-1605) | SPCSC_C0(4769));
	I915_WRITE(SPCSCC67(plane), SPCSC_C1(4769) | SPCSC_C0(0));
	I915_WRITE(SPCSCC8(plane), SPCSC_C0(8263));

	I915_WRITE(SPCSCYGICLAMP(plane), SPCSC_IMAX(940) | SPCSC_IMIN(64));
	I915_WRITE(SPCSCCBICLAMP(plane), SPCSC_IMAX(448) | SPCSC_IMIN(-448));
	I915_WRITE(SPCSCCRICLAMP(plane), SPCSC_IMAX(448) | SPCSC_IMIN(-448));

	I915_WRITE(SPCSCYGOCLAMP(plane), SPCSC_OMAX(1023) | SPCSC_OMIN(0));
	I915_WRITE(SPCSCCBOCLAMP(plane), SPCSC_OMAX(1023) | SPCSC_OMIN(0));
	I915_WRITE(SPCSCCROCLAMP(plane), SPCSC_OMAX(1023) | SPCSC_OMIN(0));
}

static void
vlv_update_plane(struct drm_plane *dplane, struct drm_crtc *crtc,
		 struct drm_framebuffer *fb,
		 int crtc_x, int crtc_y,
		 unsigned int crtc_w, unsigned int crtc_h,
		 uint32_t x, uint32_t y,
		 uint32_t src_w, uint32_t src_h)
{
	struct drm_device *dev = dplane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(dplane);
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	int pipe = intel_plane->pipe;
	int plane = intel_plane->plane;
	u32 sprctl;
	unsigned long sprsurf_offset, linear_offset;
	int pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
	const struct drm_intel_sprite_colorkey *key =
		&to_intel_plane_state(dplane->state)->ckey;

	sprctl = SP_ENABLE;

	switch (fb->pixel_format) {
	case DRM_FORMAT_YUYV:
		sprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_YUYV;
		break;
	case DRM_FORMAT_YVYU:
		sprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_YVYU;
		break;
	case DRM_FORMAT_UYVY:
		sprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_UYVY;
		break;
	case DRM_FORMAT_VYUY:
		sprctl |= SP_FORMAT_YUV422 | SP_YUV_ORDER_VYUY;
		break;
	case DRM_FORMAT_RGB565:
		sprctl |= SP_FORMAT_BGR565;
		break;
	case DRM_FORMAT_XRGB8888:
		sprctl |= SP_FORMAT_BGRX8888;
		break;
	case DRM_FORMAT_ARGB8888:
		sprctl |= SP_FORMAT_BGRA8888;
		break;
	case DRM_FORMAT_XBGR2101010:
		sprctl |= SP_FORMAT_RGBX1010102;
		break;
	case DRM_FORMAT_ABGR2101010:
		sprctl |= SP_FORMAT_RGBA1010102;
		break;
	case DRM_FORMAT_XBGR8888:
		sprctl |= SP_FORMAT_RGBX8888;
		break;
	case DRM_FORMAT_ABGR8888:
		sprctl |= SP_FORMAT_RGBA8888;
		break;
	default:
		/*
		 * If we get here one of the upper layers failed to filter
		 * out the unsupported plane formats
		 */
		BUG();
		break;
	}

	/*
	 * Enable gamma to match primary/cursor plane behaviour.
	 * FIXME should be user controllable via propertiesa.
	 */
	sprctl |= SP_GAMMA_ENABLE;

	if (obj->tiling_mode != I915_TILING_NONE)
		sprctl |= SP_TILED;

	/* Sizes are 0 based */
	src_w--;
	src_h--;
	crtc_w--;
	crtc_h--;

	linear_offset = y * fb->pitches[0] + x * pixel_size;
	sprsurf_offset = intel_gen4_compute_page_offset(dev_priv,
							&x, &y,
							obj->tiling_mode,
							pixel_size,
							fb->pitches[0]);
	linear_offset -= sprsurf_offset;

	if (dplane->state->rotation == BIT(DRM_ROTATE_180)) {
		sprctl |= SP_ROTATE_180;

		x += src_w;
		y += src_h;
		linear_offset += src_h * fb->pitches[0] + src_w * pixel_size;
	}

	if (key->flags) {
		I915_WRITE(SPKEYMINVAL(pipe, plane), key->min_value);
		I915_WRITE(SPKEYMAXVAL(pipe, plane), key->max_value);
		I915_WRITE(SPKEYMSK(pipe, plane), key->channel_mask);
	}

	if (key->flags & I915_SET_COLORKEY_SOURCE)
		sprctl |= SP_SOURCE_KEY;

	if (IS_CHERRYVIEW(dev) && pipe == PIPE_B)
		chv_update_csc(intel_plane, fb->pixel_format);

	I915_WRITE(SPSTRIDE(pipe, plane), fb->pitches[0]);
	I915_WRITE(SPPOS(pipe, plane), (crtc_y << 16) | crtc_x);

	if (obj->tiling_mode != I915_TILING_NONE)
		I915_WRITE(SPTILEOFF(pipe, plane), (y << 16) | x);
	else
		I915_WRITE(SPLINOFF(pipe, plane), linear_offset);

	I915_WRITE(SPCONSTALPHA(pipe, plane), 0);

	I915_WRITE(SPSIZE(pipe, plane), (crtc_h << 16) | crtc_w);
	I915_WRITE(SPCNTR(pipe, plane), sprctl);
	I915_WRITE(SPSURF(pipe, plane), i915_gem_obj_ggtt_offset(obj) +
		   sprsurf_offset);
	POSTING_READ(SPSURF(pipe, plane));
}

static void
vlv_disable_plane(struct drm_plane *dplane, struct drm_crtc *crtc)
{
	struct drm_device *dev = dplane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(dplane);
	int pipe = intel_plane->pipe;
	int plane = intel_plane->plane;

	I915_WRITE(SPCNTR(pipe, plane), 0);

	I915_WRITE(SPSURF(pipe, plane), 0);
	POSTING_READ(SPSURF(pipe, plane));
}

static void
ivb_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
		 struct drm_framebuffer *fb,
		 int crtc_x, int crtc_y,
		 unsigned int crtc_w, unsigned int crtc_h,
		 uint32_t x, uint32_t y,
		 uint32_t src_w, uint32_t src_h)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	enum pipe pipe = intel_plane->pipe;
	u32 sprctl, sprscale = 0;
	unsigned long sprsurf_offset, linear_offset;
	int pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
	const struct drm_intel_sprite_colorkey *key =
		&to_intel_plane_state(plane->state)->ckey;

	sprctl = SPRITE_ENABLE;

	switch (fb->pixel_format) {
	case DRM_FORMAT_XBGR8888:
		sprctl |= SPRITE_FORMAT_RGBX888 | SPRITE_RGB_ORDER_RGBX;
		break;
	case DRM_FORMAT_XRGB8888:
		sprctl |= SPRITE_FORMAT_RGBX888;
		break;
	case DRM_FORMAT_YUYV:
		sprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_YUYV;
		break;
	case DRM_FORMAT_YVYU:
		sprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_YVYU;
		break;
	case DRM_FORMAT_UYVY:
		sprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_UYVY;
		break;
	case DRM_FORMAT_VYUY:
		sprctl |= SPRITE_FORMAT_YUV422 | SPRITE_YUV_ORDER_VYUY;
		break;
	default:
		BUG();
	}

	/*
	 * Enable gamma to match primary/cursor plane behaviour.
	 * FIXME should be user controllable via propertiesa.
	 */
	sprctl |= SPRITE_GAMMA_ENABLE;

	if (obj->tiling_mode != I915_TILING_NONE)
		sprctl |= SPRITE_TILED;

	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		sprctl &= ~SPRITE_TRICKLE_FEED_DISABLE;
	else
		sprctl |= SPRITE_TRICKLE_FEED_DISABLE;

	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		sprctl |= SPRITE_PIPE_CSC_ENABLE;

	intel_update_sprite_watermarks(plane, crtc, src_w, src_h, pixel_size,
				       true,
				       src_w != crtc_w || src_h != crtc_h);

	/* Sizes are 0 based */
	src_w--;
	src_h--;
	crtc_w--;
	crtc_h--;

	if (crtc_w != src_w || crtc_h != src_h)
		sprscale = SPRITE_SCALE_ENABLE | (src_w << 16) | src_h;

	linear_offset = y * fb->pitches[0] + x * pixel_size;
	sprsurf_offset =
		intel_gen4_compute_page_offset(dev_priv,
					       &x, &y, obj->tiling_mode,
					       pixel_size, fb->pitches[0]);
	linear_offset -= sprsurf_offset;

	if (plane->state->rotation == BIT(DRM_ROTATE_180)) {
		sprctl |= SPRITE_ROTATE_180;

		/* HSW and BDW does this automagically in hardware */
		if (!IS_HASWELL(dev) && !IS_BROADWELL(dev)) {
			x += src_w;
			y += src_h;
			linear_offset += src_h * fb->pitches[0] +
				src_w * pixel_size;
		}
	}

	if (key->flags) {
		I915_WRITE(SPRKEYVAL(pipe), key->min_value);
		I915_WRITE(SPRKEYMAX(pipe), key->max_value);
		I915_WRITE(SPRKEYMSK(pipe), key->channel_mask);
	}

	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		sprctl |= SPRITE_DEST_KEY;
	else if (key->flags & I915_SET_COLORKEY_SOURCE)
		sprctl |= SPRITE_SOURCE_KEY;

	I915_WRITE(SPRSTRIDE(pipe), fb->pitches[0]);
	I915_WRITE(SPRPOS(pipe), (crtc_y << 16) | crtc_x);

	/* HSW consolidates SPRTILEOFF and SPRLINOFF into a single SPROFFSET
	 * register */
	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
		I915_WRITE(SPROFFSET(pipe), (y << 16) | x);
	else if (obj->tiling_mode != I915_TILING_NONE)
		I915_WRITE(SPRTILEOFF(pipe), (y << 16) | x);
	else
		I915_WRITE(SPRLINOFF(pipe), linear_offset);

	I915_WRITE(SPRSIZE(pipe), (crtc_h << 16) | crtc_w);
	if (intel_plane->can_scale)
		I915_WRITE(SPRSCALE(pipe), sprscale);
	I915_WRITE(SPRCTL(pipe), sprctl);
	I915_WRITE(SPRSURF(pipe),
		   i915_gem_obj_ggtt_offset(obj) + sprsurf_offset);
	POSTING_READ(SPRSURF(pipe));
}

static void
ivb_disable_plane(struct drm_plane *plane, struct drm_crtc *crtc)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	int pipe = intel_plane->pipe;

	I915_WRITE(SPRCTL(pipe), 0);
	/* Can't leave the scaler enabled... */
	if (intel_plane->can_scale)
		I915_WRITE(SPRSCALE(pipe), 0);

	I915_WRITE(SPRSURF(pipe), 0);
	POSTING_READ(SPRSURF(pipe));
}

static void
ilk_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
		 struct drm_framebuffer *fb,
		 int crtc_x, int crtc_y,
		 unsigned int crtc_w, unsigned int crtc_h,
		 uint32_t x, uint32_t y,
		 uint32_t src_w, uint32_t src_h)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
	int pipe = intel_plane->pipe;
	unsigned long dvssurf_offset, linear_offset;
	u32 dvscntr, dvsscale;
	int pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
	const struct drm_intel_sprite_colorkey *key =
		&to_intel_plane_state(plane->state)->ckey;

	dvscntr = DVS_ENABLE;

	switch (fb->pixel_format) {
	case DRM_FORMAT_XBGR8888:
		dvscntr |= DVS_FORMAT_RGBX888 | DVS_RGB_ORDER_XBGR;
		break;
	case DRM_FORMAT_XRGB8888:
		dvscntr |= DVS_FORMAT_RGBX888;
		break;
	case DRM_FORMAT_YUYV:
		dvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_YUYV;
		break;
	case DRM_FORMAT_YVYU:
		dvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_YVYU;
		break;
	case DRM_FORMAT_UYVY:
		dvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_UYVY;
		break;
	case DRM_FORMAT_VYUY:
		dvscntr |= DVS_FORMAT_YUV422 | DVS_YUV_ORDER_VYUY;
		break;
	default:
		BUG();
	}

	/*
	 * Enable gamma to match primary/cursor plane behaviour.
	 * FIXME should be user controllable via propertiesa.
	 */
	dvscntr |= DVS_GAMMA_ENABLE;

	if (obj->tiling_mode != I915_TILING_NONE)
		dvscntr |= DVS_TILED;

	if (IS_GEN6(dev))
		dvscntr |= DVS_TRICKLE_FEED_DISABLE; /* must disable */

	intel_update_sprite_watermarks(plane, crtc, src_w, src_h,
				       pixel_size, true,
				       src_w != crtc_w || src_h != crtc_h);

	/* Sizes are 0 based */
	src_w--;
	src_h--;
	crtc_w--;
	crtc_h--;

	dvsscale = 0;
	if (crtc_w != src_w || crtc_h != src_h)
		dvsscale = DVS_SCALE_ENABLE | (src_w << 16) | src_h;

	linear_offset = y * fb->pitches[0] + x * pixel_size;
	dvssurf_offset =
		intel_gen4_compute_page_offset(dev_priv,
					       &x, &y, obj->tiling_mode,
					       pixel_size, fb->pitches[0]);
	linear_offset -= dvssurf_offset;

	if (plane->state->rotation == BIT(DRM_ROTATE_180)) {
		dvscntr |= DVS_ROTATE_180;

		x += src_w;
		y += src_h;
		linear_offset += src_h * fb->pitches[0] + src_w * pixel_size;
	}

	if (key->flags) {
		I915_WRITE(DVSKEYVAL(pipe), key->min_value);
		I915_WRITE(DVSKEYMAX(pipe), key->max_value);
		I915_WRITE(DVSKEYMSK(pipe), key->channel_mask);
	}

	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		dvscntr |= DVS_DEST_KEY;
	else if (key->flags & I915_SET_COLORKEY_SOURCE)
		dvscntr |= DVS_SOURCE_KEY;

	I915_WRITE(DVSSTRIDE(pipe), fb->pitches[0]);
	I915_WRITE(DVSPOS(pipe), (crtc_y << 16) | crtc_x);

	if (obj->tiling_mode != I915_TILING_NONE)
		I915_WRITE(DVSTILEOFF(pipe), (y << 16) | x);
	else
		I915_WRITE(DVSLINOFF(pipe), linear_offset);

	I915_WRITE(DVSSIZE(pipe), (crtc_h << 16) | crtc_w);
	I915_WRITE(DVSSCALE(pipe), dvsscale);
	I915_WRITE(DVSCNTR(pipe), dvscntr);
	I915_WRITE(DVSSURF(pipe),
		   i915_gem_obj_ggtt_offset(obj) + dvssurf_offset);
	POSTING_READ(DVSSURF(pipe));
}

static void
ilk_disable_plane(struct drm_plane *plane, struct drm_crtc *crtc)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	int pipe = intel_plane->pipe;

	I915_WRITE(DVSCNTR(pipe), 0);
	/* Disable the scaler */
	I915_WRITE(DVSSCALE(pipe), 0);

	I915_WRITE(DVSSURF(pipe), 0);
	POSTING_READ(DVSSURF(pipe));
}

static int
intel_check_sprite_plane(struct drm_plane *plane,
			 struct intel_crtc_state *crtc_state,
			 struct intel_plane_state *state)
{
	struct drm_device *dev = plane->dev;
	struct drm_crtc *crtc = state->base.crtc;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	struct intel_plane *intel_plane = to_intel_plane(plane);
	struct drm_framebuffer *fb = state->base.fb;
	int crtc_x, crtc_y;
	unsigned int crtc_w, crtc_h;
	uint32_t src_x, src_y, src_w, src_h;
	struct drm_rect *src = &state->src;
	struct drm_rect *dst = &state->dst;
	const struct drm_rect *clip = &state->clip;
	int hscale, vscale;
	int max_scale, min_scale;
	bool can_scale;
	int pixel_size;

	if (!fb) {
		state->visible = false;
		return 0;
	}

	/* Don't modify another pipe's plane */
	if (intel_plane->pipe != intel_crtc->pipe) {
		DRM_DEBUG_KMS("Wrong plane <-> crtc mapping\n");
		return -EINVAL;
	}

	/* FIXME check all gen limits */
	if (fb->width < 3 || fb->height < 3 || fb->pitches[0] > 16384) {
		DRM_DEBUG_KMS("Unsuitable framebuffer for plane\n");
		return -EINVAL;
	}

	/* setup can_scale, min_scale, max_scale */
	if (INTEL_INFO(dev)->gen >= 9) {
		/* use scaler when colorkey is not required */
		if (state->ckey.flags == I915_SET_COLORKEY_NONE) {
			can_scale = 1;
			min_scale = 1;
			max_scale = skl_max_scale(intel_crtc, crtc_state);
		} else {
			can_scale = 0;
			min_scale = DRM_PLANE_HELPER_NO_SCALING;
			max_scale = DRM_PLANE_HELPER_NO_SCALING;
		}
	} else {
		can_scale = intel_plane->can_scale;
		max_scale = intel_plane->max_downscale << 16;
		min_scale = intel_plane->can_scale ? 1 : (1 << 16);
	}

	/*
	 * FIXME the following code does a bunch of fuzzy adjustments to the
	 * coordinates and sizes. We probably need some way to decide whether
	 * more strict checking should be done instead.
	 */
	drm_rect_rotate(src, fb->width << 16, fb->height << 16,
			state->base.rotation);

	hscale = drm_rect_calc_hscale_relaxed(src, dst, min_scale, max_scale);
	BUG_ON(hscale < 0);

	vscale = drm_rect_calc_vscale_relaxed(src, dst, min_scale, max_scale);
	BUG_ON(vscale < 0);

	state->visible = drm_rect_clip_scaled(src, dst, clip, hscale, vscale);

	crtc_x = dst->x1;
	crtc_y = dst->y1;
	crtc_w = drm_rect_width(dst);
	crtc_h = drm_rect_height(dst);

	if (state->visible) {
		/* check again in case clipping clamped the results */
		hscale = drm_rect_calc_hscale(src, dst, min_scale, max_scale);
		if (hscale < 0) {
			DRM_DEBUG_KMS("Horizontal scaling factor out of limits\n");
			drm_rect_debug_print(src, true);
			drm_rect_debug_print(dst, false);

			return hscale;
		}

		vscale = drm_rect_calc_vscale(src, dst, min_scale, max_scale);
		if (vscale < 0) {
			DRM_DEBUG_KMS("Vertical scaling factor out of limits\n");
			drm_rect_debug_print(src, true);
			drm_rect_debug_print(dst, false);

			return vscale;
		}

		/* Make the source viewport size an exact multiple of the scaling factors. */
		drm_rect_adjust_size(src,
				     drm_rect_width(dst) * hscale - drm_rect_width(src),
				     drm_rect_height(dst) * vscale - drm_rect_height(src));

		drm_rect_rotate_inv(src, fb->width << 16, fb->height << 16,
				    state->base.rotation);

		/* sanity check to make sure the src viewport wasn't enlarged */
		WARN_ON(src->x1 < (int) state->base.src_x ||
			src->y1 < (int) state->base.src_y ||
			src->x2 > (int) state->base.src_x + state->base.src_w ||
			src->y2 > (int) state->base.src_y + state->base.src_h);

		/*
		 * Hardware doesn't handle subpixel coordinates.
		 * Adjust to (macro)pixel boundary, but be careful not to
		 * increase the source viewport size, because that could
		 * push the downscaling factor out of bounds.
		 */
		src_x = src->x1 >> 16;
		src_w = drm_rect_width(src) >> 16;
		src_y = src->y1 >> 16;
		src_h = drm_rect_height(src) >> 16;

		if (format_is_yuv(fb->pixel_format)) {
			src_x &= ~1;
			src_w &= ~1;

			/*
			 * Must keep src and dst the
			 * same if we can't scale.
			 */
			if (!can_scale)
				crtc_w &= ~1;

			if (crtc_w == 0)
				state->visible = false;
		}
	}

	/* Check size restrictions when scaling */
	if (state->visible && (src_w != crtc_w || src_h != crtc_h)) {
		unsigned int width_bytes;

		WARN_ON(!can_scale);

		/* FIXME interlacing min height is 6 */

		if (crtc_w < 3 || crtc_h < 3)
			state->visible = false;

		if (src_w < 3 || src_h < 3)
			state->visible = false;

		pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
		width_bytes = ((src_x * pixel_size) & 63) +
					src_w * pixel_size;

		if (INTEL_INFO(dev)->gen < 9 && (src_w > 2048 || src_h > 2048 ||
		    width_bytes > 4096 || fb->pitches[0] > 4096)) {
			DRM_DEBUG_KMS("Source dimensions exceed hardware limits\n");
			return -EINVAL;
		}
	}

	if (state->visible) {
		src->x1 = src_x << 16;
		src->x2 = (src_x + src_w) << 16;
		src->y1 = src_y << 16;
		src->y2 = (src_y + src_h) << 16;
	}

	dst->x1 = crtc_x;
	dst->x2 = crtc_x + crtc_w;
	dst->y1 = crtc_y;
	dst->y2 = crtc_y + crtc_h;

	return 0;
}

static void
intel_commit_sprite_plane(struct drm_plane *plane,
			  struct intel_plane_state *state)
{
	struct drm_crtc *crtc = state->base.crtc;
	struct intel_plane *intel_plane = to_intel_plane(plane);
	struct drm_framebuffer *fb = state->base.fb;

	crtc = crtc ? crtc : plane->crtc;

	if (!crtc->state->active)
		return;

	if (state->visible) {
		intel_plane->update_plane(plane, crtc, fb,
					  state->dst.x1, state->dst.y1,
					  drm_rect_width(&state->dst),
					  drm_rect_height(&state->dst),
					  state->src.x1 >> 16,
					  state->src.y1 >> 16,
					  drm_rect_width(&state->src) >> 16,
					  drm_rect_height(&state->src) >> 16);
	} else {
		intel_plane->disable_plane(plane, crtc);
	}
}

int intel_sprite_set_colorkey(struct drm_device *dev, void *data,
			      struct drm_file *file_priv)
{
	struct drm_intel_sprite_colorkey *set = data;
	struct drm_plane *plane;
	struct drm_plane_state *plane_state;
	struct drm_atomic_state *state;
	struct drm_modeset_acquire_ctx ctx;
	int ret = 0;

	/* Make sure we don't try to enable both src & dest simultaneously */
	if ((set->flags & (I915_SET_COLORKEY_DESTINATION | I915_SET_COLORKEY_SOURCE)) == (I915_SET_COLORKEY_DESTINATION | I915_SET_COLORKEY_SOURCE))
		return -EINVAL;

	if (IS_VALLEYVIEW(dev) &&
	    set->flags & I915_SET_COLORKEY_DESTINATION)
		return -EINVAL;

	plane = drm_plane_find(dev, set->plane_id);
	if (!plane || plane->type != DRM_PLANE_TYPE_OVERLAY)
		return -ENOENT;

	drm_modeset_acquire_init(&ctx, 0);

	state = drm_atomic_state_alloc(plane->dev);
	if (!state) {
		ret = -ENOMEM;
		goto out;
	}
	state->acquire_ctx = &ctx;

	while (1) {
		plane_state = drm_atomic_get_plane_state(state, plane);
		ret = PTR_ERR_OR_ZERO(plane_state);
		if (!ret) {
			to_intel_plane_state(plane_state)->ckey = *set;
			ret = drm_atomic_commit(state);
		}

		if (ret != -EDEADLK)
			break;

		drm_atomic_state_clear(state);
		drm_modeset_backoff(&ctx);
	}

	if (ret)
		drm_atomic_state_free(state);

out:
	drm_modeset_drop_locks(&ctx);
	drm_modeset_acquire_fini(&ctx);
	return ret;
}

static const uint32_t ilk_plane_formats[] = {
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_YUYV,
	DRM_FORMAT_YVYU,
	DRM_FORMAT_UYVY,
	DRM_FORMAT_VYUY,
};

static const uint32_t snb_plane_formats[] = {
	DRM_FORMAT_XBGR8888,
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_YUYV,
	DRM_FORMAT_YVYU,
	DRM_FORMAT_UYVY,
	DRM_FORMAT_VYUY,
};

static const uint32_t vlv_plane_formats[] = {
	DRM_FORMAT_RGB565,
	DRM_FORMAT_ABGR8888,
	DRM_FORMAT_ARGB8888,
	DRM_FORMAT_XBGR8888,
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_XBGR2101010,
	DRM_FORMAT_ABGR2101010,
	DRM_FORMAT_YUYV,
	DRM_FORMAT_YVYU,
	DRM_FORMAT_UYVY,
	DRM_FORMAT_VYUY,
};

static uint32_t skl_plane_formats[] = {
	DRM_FORMAT_RGB565,
	DRM_FORMAT_ABGR8888,
	DRM_FORMAT_ARGB8888,
	DRM_FORMAT_XBGR8888,
	DRM_FORMAT_XRGB8888,
	DRM_FORMAT_YUYV,
	DRM_FORMAT_YVYU,
	DRM_FORMAT_UYVY,
	DRM_FORMAT_VYUY,
};

int
intel_plane_init(struct drm_device *dev, enum pipe pipe, int plane)
{
	struct intel_plane *intel_plane;
	struct intel_plane_state *state;
	unsigned long possible_crtcs;
	const uint32_t *plane_formats;
	int num_plane_formats;
	int ret;

	if (INTEL_INFO(dev)->gen < 5)
		return -ENODEV;

	intel_plane = kzalloc(sizeof(*intel_plane), GFP_KERNEL);
	if (!intel_plane)
		return -ENOMEM;

	state = intel_create_plane_state(&intel_plane->base);
	if (!state) {
		kfree(intel_plane);
		return -ENOMEM;
	}
	intel_plane->base.state = &state->base;

	switch (INTEL_INFO(dev)->gen) {
	case 5:
	case 6:
		intel_plane->can_scale = true;
		intel_plane->max_downscale = 16;
		intel_plane->update_plane = ilk_update_plane;
		intel_plane->disable_plane = ilk_disable_plane;

		if (IS_GEN6(dev)) {
			plane_formats = snb_plane_formats;
			num_plane_formats = ARRAY_SIZE(snb_plane_formats);
		} else {
			plane_formats = ilk_plane_formats;
			num_plane_formats = ARRAY_SIZE(ilk_plane_formats);
		}
		break;

	case 7:
	case 8:
		if (IS_IVYBRIDGE(dev)) {
			intel_plane->can_scale = true;
			intel_plane->max_downscale = 2;
		} else {
			intel_plane->can_scale = false;
			intel_plane->max_downscale = 1;
		}

		if (IS_VALLEYVIEW(dev)) {
			intel_plane->update_plane = vlv_update_plane;
			intel_plane->disable_plane = vlv_disable_plane;

			plane_formats = vlv_plane_formats;
			num_plane_formats = ARRAY_SIZE(vlv_plane_formats);
		} else {
			intel_plane->update_plane = ivb_update_plane;
			intel_plane->disable_plane = ivb_disable_plane;

			plane_formats = snb_plane_formats;
			num_plane_formats = ARRAY_SIZE(snb_plane_formats);
		}
		break;
	case 9:
		intel_plane->can_scale = true;
		intel_plane->update_plane = skl_update_plane;
		intel_plane->disable_plane = skl_disable_plane;
		state->scaler_id = -1;

		plane_formats = skl_plane_formats;
		num_plane_formats = ARRAY_SIZE(skl_plane_formats);
		break;
	default:
		kfree(intel_plane);
		return -ENODEV;
	}

	intel_plane->pipe = pipe;
	intel_plane->plane = plane;
	intel_plane->frontbuffer_bit = INTEL_FRONTBUFFER_SPRITE(pipe, plane);
	intel_plane->check_plane = intel_check_sprite_plane;
	intel_plane->commit_plane = intel_commit_sprite_plane;
	possible_crtcs = (1 << pipe);
	ret = drm_universal_plane_init(dev, &intel_plane->base, possible_crtcs,
				       &intel_plane_funcs,
				       plane_formats, num_plane_formats,
				       DRM_PLANE_TYPE_OVERLAY);
	if (ret) {
		kfree(intel_plane);
		goto out;
	}

	intel_create_rotation_property(dev, intel_plane);

	drm_plane_helper_add(&intel_plane->base, &intel_plane_helper_funcs);

out:
	return ret;
}
@


1.7
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@a0 1
/*	$OpenBSD: intel_sprite.c,v 1.6 2015/02/10 03:39:41 jsg Exp $	*/
d36 2
d42 305
d350 1
a350 1
		 struct drm_i915_gem_object *obj, int crtc_x, int crtc_y,
d358 1
d364 2
d367 1
a367 6
	sprctl = I915_READ(SPCNTR(pipe, plane));

	/* Mask out pixel format bits in case we change it */
	sprctl &= ~SP_PIXFORMAT_MASK;
	sprctl &= ~SP_YUV_BYTE_ORDER_MASK;
	sprctl &= ~SP_TILED;
a420 5
	sprctl |= SP_ENABLE;

	intel_update_sprite_watermarks(dplane, crtc, src_w, pixel_size, true,
				       src_w != crtc_w || src_h != crtc_h);

a426 3
	I915_WRITE(SPSTRIDE(pipe, plane), fb->pitches[0]);
	I915_WRITE(SPPOS(pipe, plane), (crtc_y << 16) | crtc_x);

d428 2
a429 1
	sprsurf_offset = intel_gen4_compute_page_offset(&x, &y,
d435 23
d463 2
d481 2
a482 3
	I915_WRITE(SPCNTR(pipe, plane), I915_READ(SPCNTR(pipe, plane)) &
		   ~SP_ENABLE);
	/* Activate double buffered register update */
a484 53

	intel_update_sprite_watermarks(dplane, crtc, 0, 0, false, false);
}

static int
vlv_update_colorkey(struct drm_plane *dplane,
		    struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = dplane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(dplane);
	int pipe = intel_plane->pipe;
	int plane = intel_plane->plane;
	u32 sprctl;

	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		return -EINVAL;

	I915_WRITE(SPKEYMINVAL(pipe, plane), key->min_value);
	I915_WRITE(SPKEYMAXVAL(pipe, plane), key->max_value);
	I915_WRITE(SPKEYMSK(pipe, plane), key->channel_mask);

	sprctl = I915_READ(SPCNTR(pipe, plane));
	sprctl &= ~SP_SOURCE_KEY;
	if (key->flags & I915_SET_COLORKEY_SOURCE)
		sprctl |= SP_SOURCE_KEY;
	I915_WRITE(SPCNTR(pipe, plane), sprctl);

	POSTING_READ(SPKEYMSK(pipe, plane));

	return 0;
}

static void
vlv_get_colorkey(struct drm_plane *dplane,
		 struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = dplane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane = to_intel_plane(dplane);
	int pipe = intel_plane->pipe;
	int plane = intel_plane->plane;
	u32 sprctl;

	key->min_value = I915_READ(SPKEYMINVAL(pipe, plane));
	key->max_value = I915_READ(SPKEYMAXVAL(pipe, plane));
	key->channel_mask = I915_READ(SPKEYMSK(pipe, plane));

	sprctl = I915_READ(SPCNTR(pipe, plane));
	if (sprctl & SP_SOURCE_KEY)
		key->flags = I915_SET_COLORKEY_SOURCE;
	else
		key->flags = I915_SET_COLORKEY_NONE;
d490 1
a490 1
		 struct drm_i915_gem_object *obj, int crtc_x, int crtc_y,
d498 2
a499 1
	int pipe = intel_plane->pipe;
d503 2
d506 1
a506 7
	sprctl = I915_READ(SPRCTL(pipe));

	/* Mask out pixel format bits in case we change it */
	sprctl &= ~SPRITE_PIXFORMAT_MASK;
	sprctl &= ~SPRITE_RGB_ORDER_RGBX;
	sprctl &= ~SPRITE_YUV_BYTE_ORDER_MASK;
	sprctl &= ~SPRITE_TILED;
a544 2
	sprctl |= SPRITE_ENABLE;

d548 2
a549 1
	intel_update_sprite_watermarks(plane, crtc, src_w, pixel_size, true,
a560 3
	I915_WRITE(SPRSTRIDE(pipe), fb->pitches[0]);
	I915_WRITE(SPRPOS(pipe), (crtc_y << 16) | crtc_x);

d563 2
a564 1
		intel_gen4_compute_page_offset(&x, &y, obj->tiling_mode,
d568 26
d620 1
a620 1
	I915_WRITE(SPRCTL(pipe), I915_READ(SPRCTL(pipe)) & ~SPRITE_ENABLE);
d624 1
a624 1
	/* Activate double buffered register update */
a626 62

	/*
	 * Avoid underruns when disabling the sprite.
	 * FIXME remove once watermark updates are done properly.
	 */
	intel_wait_for_vblank(dev, pipe);

	intel_update_sprite_watermarks(plane, crtc, 0, 0, false, false);
}

static int
ivb_update_colorkey(struct drm_plane *plane,
		    struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane;
	u32 sprctl;
	int ret = 0;

	intel_plane = to_intel_plane(plane);

	I915_WRITE(SPRKEYVAL(intel_plane->pipe), key->min_value);
	I915_WRITE(SPRKEYMAX(intel_plane->pipe), key->max_value);
	I915_WRITE(SPRKEYMSK(intel_plane->pipe), key->channel_mask);

	sprctl = I915_READ(SPRCTL(intel_plane->pipe));
	sprctl &= ~(SPRITE_SOURCE_KEY | SPRITE_DEST_KEY);
	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		sprctl |= SPRITE_DEST_KEY;
	else if (key->flags & I915_SET_COLORKEY_SOURCE)
		sprctl |= SPRITE_SOURCE_KEY;
	I915_WRITE(SPRCTL(intel_plane->pipe), sprctl);

	POSTING_READ(SPRKEYMSK(intel_plane->pipe));

	return ret;
}

static void
ivb_get_colorkey(struct drm_plane *plane, struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane;
	u32 sprctl;

	intel_plane = to_intel_plane(plane);

	key->min_value = I915_READ(SPRKEYVAL(intel_plane->pipe));
	key->max_value = I915_READ(SPRKEYMAX(intel_plane->pipe));
	key->channel_mask = I915_READ(SPRKEYMSK(intel_plane->pipe));
	key->flags = 0;

	sprctl = I915_READ(SPRCTL(intel_plane->pipe));

	if (sprctl & SPRITE_DEST_KEY)
		key->flags = I915_SET_COLORKEY_DESTINATION;
	else if (sprctl & SPRITE_SOURCE_KEY)
		key->flags = I915_SET_COLORKEY_SOURCE;
	else
		key->flags = I915_SET_COLORKEY_NONE;
d632 1
a632 1
		 struct drm_i915_gem_object *obj, int crtc_x, int crtc_y,
d640 1
d645 2
d648 1
a648 7
	dvscntr = I915_READ(DVSCNTR(pipe));

	/* Mask out pixel format bits in case we change it */
	dvscntr &= ~DVS_PIXFORMAT_MASK;
	dvscntr &= ~DVS_RGB_ORDER_XBGR;
	dvscntr &= ~DVS_YUV_BYTE_ORDER_MASK;
	dvscntr &= ~DVS_TILED;
a683 1
	dvscntr |= DVS_ENABLE;
d685 2
a686 1
	intel_update_sprite_watermarks(plane, crtc, src_w, pixel_size, true,
a698 3
	I915_WRITE(DVSSTRIDE(pipe), fb->pitches[0]);
	I915_WRITE(DVSPOS(pipe), (crtc_y << 16) | crtc_x);

d701 2
a702 1
		intel_gen4_compute_page_offset(&x, &y, obj->tiling_mode,
d706 22
d749 1
a749 1
	I915_WRITE(DVSCNTR(pipe), I915_READ(DVSCNTR(pipe)) & ~DVS_ENABLE);
d752 1
a752 1
	/* Flush double buffered register updates */
a754 70

	/*
	 * Avoid underruns when disabling the sprite.
	 * FIXME remove once watermark updates are done properly.
	 */
	intel_wait_for_vblank(dev, pipe);

	intel_update_sprite_watermarks(plane, crtc, 0, 0, false, false);
}

static void
intel_enable_primary(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int reg = DSPCNTR(intel_crtc->plane);

	if (intel_crtc->primary_enabled)
		return;

	intel_crtc->primary_enabled = true;

	I915_WRITE(reg, I915_READ(reg) | DISPLAY_PLANE_ENABLE);
	intel_flush_primary_plane(dev_priv, intel_crtc->plane);

	/*
	 * FIXME IPS should be fine as long as one plane is
	 * enabled, but in practice it seems to have problems
	 * when going from primary only to sprite only and vice
	 * versa.
	 */
	if (intel_crtc->config.ips_enabled) {
		intel_wait_for_vblank(dev, intel_crtc->pipe);
		hsw_enable_ips(intel_crtc);
	}

	mutex_lock(&dev->struct_mutex);
	intel_update_fbc(dev);
	mutex_unlock(&dev->struct_mutex);
}

static void
intel_disable_primary(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
	int reg = DSPCNTR(intel_crtc->plane);

	if (!intel_crtc->primary_enabled)
		return;

	intel_crtc->primary_enabled = false;

	mutex_lock(&dev->struct_mutex);
	if (dev_priv->fbc.plane == intel_crtc->plane)
		intel_disable_fbc(dev);
	mutex_unlock(&dev->struct_mutex);

	/*
	 * FIXME IPS should be fine as long as one plane is
	 * enabled, but in practice it seems to have problems
	 * when going from primary only to sprite only and vice
	 * versa.
	 */
	hsw_disable_ips(intel_crtc);

	I915_WRITE(reg, I915_READ(reg) & ~DISPLAY_PLANE_ENABLE);
	intel_flush_primary_plane(dev_priv, intel_crtc->plane);
d758 3
a760 82
ilk_update_colorkey(struct drm_plane *plane,
		    struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane;
	u32 dvscntr;
	int ret = 0;

	intel_plane = to_intel_plane(plane);

	I915_WRITE(DVSKEYVAL(intel_plane->pipe), key->min_value);
	I915_WRITE(DVSKEYMAX(intel_plane->pipe), key->max_value);
	I915_WRITE(DVSKEYMSK(intel_plane->pipe), key->channel_mask);

	dvscntr = I915_READ(DVSCNTR(intel_plane->pipe));
	dvscntr &= ~(DVS_SOURCE_KEY | DVS_DEST_KEY);
	if (key->flags & I915_SET_COLORKEY_DESTINATION)
		dvscntr |= DVS_DEST_KEY;
	else if (key->flags & I915_SET_COLORKEY_SOURCE)
		dvscntr |= DVS_SOURCE_KEY;
	I915_WRITE(DVSCNTR(intel_plane->pipe), dvscntr);

	POSTING_READ(DVSKEYMSK(intel_plane->pipe));

	return ret;
}

static void
ilk_get_colorkey(struct drm_plane *plane, struct drm_intel_sprite_colorkey *key)
{
	struct drm_device *dev = plane->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_plane *intel_plane;
	u32 dvscntr;

	intel_plane = to_intel_plane(plane);

	key->min_value = I915_READ(DVSKEYVAL(intel_plane->pipe));
	key->max_value = I915_READ(DVSKEYMAX(intel_plane->pipe));
	key->channel_mask = I915_READ(DVSKEYMSK(intel_plane->pipe));
	key->flags = 0;

	dvscntr = I915_READ(DVSCNTR(intel_plane->pipe));

	if (dvscntr & DVS_DEST_KEY)
		key->flags = I915_SET_COLORKEY_DESTINATION;
	else if (dvscntr & DVS_SOURCE_KEY)
		key->flags = I915_SET_COLORKEY_SOURCE;
	else
		key->flags = I915_SET_COLORKEY_NONE;
}

static bool
format_is_yuv(uint32_t format)
{
	switch (format) {
	case DRM_FORMAT_YUYV:
	case DRM_FORMAT_UYVY:
	case DRM_FORMAT_VYUY:
	case DRM_FORMAT_YVYU:
		return true;
	default:
		return false;
	}
}

static bool colorkey_enabled(struct intel_plane *intel_plane)
{
	struct drm_intel_sprite_colorkey key;

	intel_plane->get_colorkey(&intel_plane->base, &key);

	return key.flags != I915_SET_COLORKEY_NONE;
}

static int
intel_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
		   struct drm_framebuffer *fb, int crtc_x, int crtc_y,
		   unsigned int crtc_w, unsigned int crtc_h,
		   uint32_t src_x, uint32_t src_y,
		   uint32_t src_w, uint32_t src_h)
d763 1
d766 7
a772 6
	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);
	struct drm_i915_gem_object *obj = intel_fb->obj;
	struct drm_i915_gem_object *old_obj = intel_plane->obj;
	int ret;
	bool disable_primary = false;
	bool visible;
d775 7
a781 33
	int pixel_size = drm_format_plane_cpp(fb->pixel_format, 0);
	struct drm_rect src = {
		/* sample coordinates in 16.16 fixed point */
		.x1 = src_x,
		.x2 = src_x + src_w,
		.y1 = src_y,
		.y2 = src_y + src_h,
	};
	struct drm_rect dst = {
		/* integer pixels */
		.x1 = crtc_x,
		.x2 = crtc_x + crtc_w,
		.y1 = crtc_y,
		.y2 = crtc_y + crtc_h,
	};
	const struct drm_rect clip = {
		.x2 = intel_crtc->active ? intel_crtc->config.pipe_src_w : 0,
		.y2 = intel_crtc->active ? intel_crtc->config.pipe_src_h : 0,
	};
	const struct {
		int crtc_x, crtc_y;
		unsigned int crtc_w, crtc_h;
		uint32_t src_x, src_y, src_w, src_h;
	} orig = {
		.crtc_x = crtc_x,
		.crtc_y = crtc_y,
		.crtc_w = crtc_w,
		.crtc_h = crtc_h,
		.src_x = src_x,
		.src_y = src_y,
		.src_w = src_w,
		.src_h = src_h,
	};
d795 16
a810 8
	/* Sprite planes can be linear or x-tiled surfaces */
	switch (obj->tiling_mode) {
		case I915_TILING_NONE:
		case I915_TILING_X:
			break;
		default:
			DRM_DEBUG_KMS("Unsupported tiling mode\n");
			return -EINVAL;
d818 2
a819 2
	max_scale = intel_plane->max_downscale << 16;
	min_scale = intel_plane->can_scale ? 1 : (1 << 16);
d821 1
a821 1
	hscale = drm_rect_calc_hscale_relaxed(&src, &dst, min_scale, max_scale);
d824 1
a824 1
	vscale = drm_rect_calc_vscale_relaxed(&src, &dst, min_scale, max_scale);
d827 1
a827 1
	visible = drm_rect_clip_scaled(&src, &dst, &clip, hscale, vscale);
d829 4
a832 4
	crtc_x = dst.x1;
	crtc_y = dst.y1;
	crtc_w = drm_rect_width(&dst);
	crtc_h = drm_rect_height(&dst);
d834 1
a834 1
	if (visible) {
d836 1
a836 1
		hscale = drm_rect_calc_hscale(&src, &dst, min_scale, max_scale);
d839 2
a840 2
			drm_rect_debug_print(&src, true);
			drm_rect_debug_print(&dst, false);
d845 1
a845 1
		vscale = drm_rect_calc_vscale(&src, &dst, min_scale, max_scale);
d848 2
a849 2
			drm_rect_debug_print(&src, true);
			drm_rect_debug_print(&dst, false);
d855 6
a860 3
		drm_rect_adjust_size(&src,
				     drm_rect_width(&dst) * hscale - drm_rect_width(&src),
				     drm_rect_height(&dst) * vscale - drm_rect_height(&src));
d863 4
a866 4
		WARN_ON(src.x1 < (int) src_x ||
			src.y1 < (int) src_y ||
			src.x2 > (int) (src_x + src_w) ||
			src.y2 > (int) (src_y + src_h));
d874 4
a877 4
		src_x = src.x1 >> 16;
		src_w = drm_rect_width(&src) >> 16;
		src_y = src.y1 >> 16;
		src_h = drm_rect_height(&src) >> 16;
d887 1
a887 1
			if (!intel_plane->can_scale)
d891 1
a891 1
				visible = false;
d896 1
a896 1
	if (visible && (src_w != crtc_w || src_h != crtc_h)) {
d899 1
a899 1
		WARN_ON(!intel_plane->can_scale);
d904 1
a904 1
			visible = false;
d907 1
a907 1
			visible = false;
d909 3
a911 1
		width_bytes = ((src_x * pixel_size) & 63) + src_w * pixel_size;
d913 2
a914 2
		if (src_w > 2048 || src_h > 2048 ||
		    width_bytes > 4096 || fb->pitches[0] > 4096) {
d920 5
a924 53
	dst.x1 = crtc_x;
	dst.x2 = crtc_x + crtc_w;
	dst.y1 = crtc_y;
	dst.y2 = crtc_y + crtc_h;

	/*
	 * If the sprite is completely covering the primary plane,
	 * we can disable the primary and save power.
	 */
	disable_primary = drm_rect_equals(&dst, &clip) && !colorkey_enabled(intel_plane);
	WARN_ON(disable_primary && !visible && intel_crtc->active);

	mutex_lock(&dev->struct_mutex);

	/* Note that this will apply the VT-d workaround for scanouts,
	 * which is more restrictive than required for sprites. (The
	 * primary plane requires 256KiB alignment with 64 PTE padding,
	 * the sprite planes only require 128KiB alignment and 32 PTE padding.
	 */
	ret = intel_pin_and_fence_fb_obj(dev, obj, NULL);

	mutex_unlock(&dev->struct_mutex);

	if (ret)
		return ret;

	intel_plane->crtc_x = orig.crtc_x;
	intel_plane->crtc_y = orig.crtc_y;
	intel_plane->crtc_w = orig.crtc_w;
	intel_plane->crtc_h = orig.crtc_h;
	intel_plane->src_x = orig.src_x;
	intel_plane->src_y = orig.src_y;
	intel_plane->src_w = orig.src_w;
	intel_plane->src_h = orig.src_h;
	intel_plane->obj = obj;

	if (intel_crtc->active) {
		/*
		 * Be sure to re-enable the primary before the sprite is no longer
		 * covering it fully.
		 */
		if (!disable_primary)
			intel_enable_primary(crtc);

		if (visible)
			intel_plane->update_plane(plane, crtc, fb, obj,
						  crtc_x, crtc_y, crtc_w, crtc_h,
						  src_x, src_y, src_w, src_h);
		else
			intel_plane->disable_plane(plane, crtc);

		if (disable_primary)
			intel_disable_primary(crtc);
d927 4
a930 15
	/* Unpin old obj after new one is active to avoid ugliness */
	if (old_obj) {
		/*
		 * It's fairly common to simply update the position of
		 * an existing object.  In that case, we don't need to
		 * wait for vblank to avoid ugliness, we only need to
		 * do the pin & ref bookkeeping.
		 */
		if (old_obj != obj && intel_crtc->active)
			intel_wait_for_vblank(dev, intel_crtc->pipe);

		mutex_lock(&dev->struct_mutex);
		intel_unpin_fb_obj(old_obj);
		mutex_unlock(&dev->struct_mutex);
	}
d935 3
a937 2
static int
intel_disable_plane(struct drm_plane *plane)
d939 1
a939 1
	struct drm_device *dev = plane->dev;
d941 1
a941 1
	struct intel_crtc *intel_crtc;
d943 1
a943 2
	if (!plane->fb)
		return 0;
d945 2
a946 2
	if (WARN_ON(!plane->crtc))
		return -EINVAL;
d948 11
a958 5
	intel_crtc = to_intel_crtc(plane->crtc);

	if (intel_crtc->active) {
		intel_enable_primary(plane->crtc);
		intel_plane->disable_plane(plane, plane->crtc);
a959 21

	if (intel_plane->obj) {
		if (intel_crtc->active)
			intel_wait_for_vblank(dev, intel_plane->pipe);

		mutex_lock(&dev->struct_mutex);
		intel_unpin_fb_obj(intel_plane->obj);
		mutex_unlock(&dev->struct_mutex);

		intel_plane->obj = NULL;
	}

	return 0;
}

static void intel_destroy_plane(struct drm_plane *plane)
{
	struct intel_plane *intel_plane = to_intel_plane(plane);
	intel_disable_plane(plane);
	drm_plane_cleanup(plane);
	kfree(intel_plane);
a965 1
	struct drm_mode_object *obj;
d967 3
a969 1
	struct intel_plane *intel_plane;
a971 3
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -ENODEV;

d976 3
a978 1
	drm_modeset_lock_all(dev);
d980 10
a989 4
	obj = drm_mode_object_find(dev, set->plane_id, DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		ret = -ENOENT;
		goto out_unlock;
d991 1
d993 7
a999 3
	plane = obj_to_plane(obj);
	intel_plane = to_intel_plane(plane);
	ret = intel_plane->update_colorkey(plane, set);
d1001 2
a1002 18
out_unlock:
	drm_modeset_unlock_all(dev);
	return ret;
}

int intel_sprite_get_colorkey(struct drm_device *dev, void *data,
			      struct drm_file *file_priv)
{
	struct drm_intel_sprite_colorkey *get = data;
	struct drm_mode_object *obj;
	struct drm_plane *plane;
	struct intel_plane *intel_plane;
	int ret = 0;

	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		return -ENODEV;

	drm_modeset_lock_all(dev);
d1004 2
a1005 4
	obj = drm_mode_object_find(dev, get->plane_id, DRM_MODE_OBJECT_PLANE);
	if (!obj) {
		ret = -ENOENT;
		goto out_unlock;
d1008 2
a1009 3
	plane = obj_to_plane(obj);
	intel_plane = to_intel_plane(plane);
	intel_plane->get_colorkey(plane, get);
d1011 3
a1013 2
out_unlock:
	drm_modeset_unlock_all(dev);
d1017 6
a1022 26
void intel_plane_restore(struct drm_plane *plane)
{
	struct intel_plane *intel_plane = to_intel_plane(plane);

	if (!plane->crtc || !plane->fb)
		return;

	intel_update_plane(plane, plane->crtc, plane->fb,
			   intel_plane->crtc_x, intel_plane->crtc_y,
			   intel_plane->crtc_w, intel_plane->crtc_h,
			   intel_plane->src_x, intel_plane->src_y,
			   intel_plane->src_w, intel_plane->src_h);
}

void intel_plane_disable(struct drm_plane *plane)
{
	if (!plane->crtc || !plane->fb)
		return;

	intel_disable_plane(plane);
}

static const struct drm_plane_funcs intel_plane_funcs = {
	.update_plane = intel_update_plane,
	.disable_plane = intel_disable_plane,
	.destroy = intel_destroy_plane,
d1025 2
a1026 1
static uint32_t ilk_plane_formats[] = {
d1034 4
a1037 1
static uint32_t snb_plane_formats[] = {
d1040 2
d1048 1
a1048 1
static uint32_t vlv_plane_formats[] = {
a1053 2
	DRM_FORMAT_XBGR2101010,
	DRM_FORMAT_ABGR2101010,
d1064 1
d1077 7
a1090 2
		intel_plane->update_colorkey = ilk_update_colorkey;
		intel_plane->get_colorkey = ilk_get_colorkey;
a1113 2
			intel_plane->update_colorkey = vlv_update_colorkey;
			intel_plane->get_colorkey = vlv_get_colorkey;
a1119 2
			intel_plane->update_colorkey = ivb_update_colorkey;
			intel_plane->get_colorkey = ivb_get_colorkey;
d1125 5
d1131 3
d1141 3
d1145 5
a1149 5
	ret = drm_plane_init(dev, &intel_plane->base, possible_crtcs,
			     &intel_plane_funcs,
			     plane_formats, num_plane_formats,
			     false);
	if (ret)
d1151 6
d1158 1
@


1.6
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_sprite.c,v 1.5 2015/02/10 01:39:32 jsg Exp $	*/
d36 1
d42 180
a221 1
ivb_update_plane(struct drm_plane *plane, struct drm_framebuffer *fb,
d266 6
d275 5
a279 2
	/* must disable */
	sprctl |= SPRITE_TRICKLE_FEED_DISABLE;
d282 6
d294 1
a294 13
	intel_update_sprite_watermarks(dev, pipe, crtc_w, pixel_size);

	/*
	 * IVB workaround: must disable low power watermarks for at least
	 * one frame before enabling scaling.  LP watermarks can be re-enabled
	 * when scaling is disabled.
	 */
	if (crtc_w != src_w || crtc_h != src_h) {
		if (!dev_priv->sprite_scaling_enabled) {
			dev_priv->sprite_scaling_enabled = true;
			intel_update_watermarks(dev);
			intel_wait_for_vblank(dev, pipe);
		}
a295 7
	} else {
		if (dev_priv->sprite_scaling_enabled) {
			dev_priv->sprite_scaling_enabled = false;
			/* potentially re-enable LP watermarks */
			intel_update_watermarks(dev);
		}
	}
d308 1
a308 1
	if (IS_HASWELL(dev))
d319 2
a320 1
	I915_MODIFY_DISPBASE(SPRSURF(pipe), obj->gtt_offset + sprsurf_offset);
d325 1
a325 1
ivb_disable_plane(struct drm_plane *plane)
d337 1
a337 1
	I915_MODIFY_DISPBASE(SPRSURF(pipe), 0);
d340 7
a346 2
	dev_priv->sprite_scaling_enabled = false;
	intel_update_watermarks(dev);
d404 2
a405 1
ilk_update_plane(struct drm_plane *plane, struct drm_framebuffer *fb,
d450 6
d463 3
a471 2
	intel_update_sprite_watermarks(dev, pipe, crtc_w, pixel_size);

d473 1
a473 1
	if (IS_GEN5(dev) || crtc_w != src_w || crtc_h != src_h)
d493 2
a494 1
	I915_MODIFY_DISPBASE(DVSSURF(pipe), obj->gtt_offset + dvssurf_offset);
d499 1
a499 1
ilk_disable_plane(struct drm_plane *plane)
d510 1
a510 1
	I915_MODIFY_DISPBASE(DVSSURF(pipe), 0);
d512 8
d530 1
a530 1
	if (!intel_crtc->primary_disabled)
d533 1
a533 2
	intel_crtc->primary_disabled = false;
	intel_update_fbc(dev);
d536 16
d562 1
a562 1
	if (intel_crtc->primary_disabled)
d565 15
d581 1
a581 3

	intel_crtc->primary_disabled = true;
	intel_update_fbc(dev);
d638 23
a668 1
	struct drm_i915_private *dev_priv = dev->dev_private;
d671 4
a674 8
	struct intel_framebuffer *intel_fb;
	struct drm_i915_gem_object *obj, *old_obj;
	int pipe = intel_plane->pipe;
	enum transcoder cpu_transcoder = intel_pipe_to_cpu_transcoder(dev_priv,
								      pipe);
	int ret = 0;
	int x = src_x >> 16, y = src_y >> 16;
	int primary_w = crtc->mode.hdisplay, primary_h = crtc->mode.vdisplay;
d676 36
d713 3
a715 10
	intel_fb = to_intel_framebuffer(fb);
	obj = intel_fb->obj;

	old_obj = intel_plane->obj;

	src_w = src_w >> 16;
	src_h = src_h >> 16;

	/* Pipe must be running... */
	if (!(I915_READ(PIPECONF(cpu_transcoder)) & PIPECONF_ENABLE))
d717 1
d719 3
a721 5
	if (crtc_x >= primary_w || crtc_y >= primary_h)
		return -EINVAL;

	/* Don't modify another pipe's plane */
	if (intel_plane->pipe != intel_crtc->pipe)
d723 1
d731 1
d736 3
a738 3
	 * Clamp the width & height into the visible area.  Note we don't
	 * try to scale the source if part of the visible region is offscreen.
	 * The caller must handle that by adjusting source offset and size.
d740 35
a774 17
	if ((crtc_x < 0) && ((crtc_x + crtc_w) > 0)) {
		crtc_w += crtc_x;
		crtc_x = 0;
	}
	if ((crtc_x + crtc_w) <= 0) /* Nothing to display */
		goto out;
	if ((crtc_x + crtc_w) > primary_w)
		crtc_w = primary_w - crtc_x;

	if ((crtc_y < 0) && ((crtc_y + crtc_h) > 0)) {
		crtc_h += crtc_y;
		crtc_y = 0;
	}
	if ((crtc_y + crtc_h) <= 0) /* Nothing to display */
		goto out;
	if (crtc_y + crtc_h > primary_h)
		crtc_h = primary_h - crtc_y;
d776 10
a785 2
	if (!crtc_w || !crtc_h) /* Again, nothing to display */
		goto out;
d787 49
a835 5
	/*
	 * We may not have a scaler, eg. HSW does not have it any more
	 */
	if (!intel_plane->can_scale && (crtc_w != src_w || crtc_h != src_h))
		return -EINVAL;
d837 4
a840 6
	/*
	 * We can take a larger source and scale it down, but
	 * only so much...  16x is the max on SNB.
	 */
	if (((src_w * src_h) / (crtc_w * crtc_h)) > intel_plane->max_downscale)
		return -EINVAL;
d846 2
a847 3
	if ((crtc_x == 0) && (crtc_y == 0) &&
	    (crtc_w == primary_w) && (crtc_h == primary_h))
		disable_primary = true;
d851 5
d857 3
d861 1
a861 1
		goto out_unlock;
d863 8
d873 7
a879 6
	/*
	 * Be sure to re-enable the primary before the sprite is no longer
	 * covering it fully.
	 */
	if (!disable_primary)
		intel_enable_primary(crtc);
d881 6
a886 2
	intel_plane->update_plane(plane, fb, obj, crtc_x, crtc_y,
				  crtc_w, crtc_h, x, y, src_w, src_h);
d888 3
a890 2
	if (disable_primary)
		intel_disable_primary(crtc);
d900 4
a903 5
		if (old_obj != obj) {
			mutex_unlock(&dev->struct_mutex);
			intel_wait_for_vblank(dev, to_intel_crtc(crtc)->pipe);
			mutex_lock(&dev->struct_mutex);
		}
d905 1
d908 1
a908 4
out_unlock:
	mutex_unlock(&dev->struct_mutex);
out:
	return ret;
d916 9
a924 1
	int ret = 0;
d926 1
a926 1
	if (plane->crtc)
d928 2
a929 1
	intel_plane->disable_plane(plane);
d931 7
a937 2
	if (!intel_plane->obj)
		goto out;
d939 2
a940 5
	mutex_lock(&dev->struct_mutex);
	intel_unpin_fb_obj(intel_plane->obj);
	intel_plane->obj = NULL;
	mutex_unlock(&dev->struct_mutex);
out:
d942 1
a942 1
	return ret;
d969 1
a969 1
	mutex_lock(&dev->mode_config.mutex);
d973 1
a973 1
		ret = -EINVAL;
d982 1
a982 1
	mutex_unlock(&dev->mode_config.mutex);
d998 1
a998 1
	mutex_lock(&dev->mode_config.mutex);
d1002 1
a1002 1
		ret = -EINVAL;
d1011 1
a1011 1
	mutex_unlock(&dev->mode_config.mutex);
d1015 22
d1060 14
d1075 1
a1075 1
intel_plane_init(struct drm_device *dev, enum pipe pipe)
d1086 1
a1086 1
	intel_plane = kzalloc(sizeof(struct intel_plane), GFP_KERNEL);
d1110 5
a1114 1
		if (IS_HASWELL(dev) || IS_VALLEYVIEW(dev))
d1116 16
a1131 7
		else
			intel_plane->can_scale = true;
		intel_plane->max_downscale = 2;
		intel_plane->update_plane = ivb_update_plane;
		intel_plane->disable_plane = ivb_disable_plane;
		intel_plane->update_colorkey = ivb_update_colorkey;
		intel_plane->get_colorkey = ivb_get_colorkey;
d1133 3
a1135 2
		plane_formats = snb_plane_formats;
		num_plane_formats = ARRAY_SIZE(snb_plane_formats);
d1144 1
@


1.5
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_sprite.c,v 1.4 2014/01/21 08:57:22 kettenis Exp $	*/
d597 1
a597 1
	rw_enter_write(&dev->mode_config.rwl);
d610 1
a610 1
	rw_exit_write(&dev->mode_config.rwl);
d626 1
a626 1
	rw_enter_write(&dev->mode_config.rwl);
d639 1
a639 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.4
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_sprite.c,v 1.3 2013/08/13 10:23:52 jsg Exp $	*/
d507 1
a507 1
	DRM_LOCK();
d537 1
a537 1
			DRM_UNLOCK();
d539 1
a539 1
			DRM_LOCK();
d545 1
a545 1
	DRM_UNLOCK();
d564 1
a564 1
	DRM_LOCK();
d567 1
a567 1
	DRM_UNLOCK();
@


1.3
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_sprite.c,v 1.2 2013/07/05 07:20:27 jsg Exp $	*/
d578 1
a578 1
	free(intel_plane, M_DRM);
d678 1
a678 2
	intel_plane = malloc(sizeof(struct intel_plane), M_DRM,
	    M_WAITOK | M_ZERO);
d717 1
a717 1
		free(intel_plane, M_DRM);
d728 1
a728 1
		free(intel_plane, M_DRM);
@


1.2
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_sprite.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d40 1
a40 33
void	 ivb_disable_plane(struct drm_plane *);
int	 ivb_update_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);
void	 ivb_get_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);
void	 snb_disable_plane(struct drm_plane *);
void	 intel_enable_primary(struct drm_crtc *);
int	 snb_update_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);
void	 snb_get_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);
int	 intel_update_plane(struct drm_plane *, struct drm_crtc *,
	     struct drm_framebuffer *, int, int, unsigned int, unsigned int,
	     uint32_t, uint32_t, uint32_t, uint32_t);
int	 intel_disable_drm_plane(struct drm_plane *);
void	 intel_destroy_plane(struct drm_plane *);
void	 ivb_update_plane(struct drm_plane *, struct drm_framebuffer *,
	     struct drm_i915_gem_object *, int, int, unsigned int,
	     unsigned int, uint32_t, uint32_t, uint32_t, uint32_t);
void	 snb_update_plane(struct drm_plane *, struct drm_framebuffer *,
	     struct drm_i915_gem_object *, int, int, unsigned int,
	     unsigned int, uint32_t, uint32_t, uint32_t, uint32_t);
void	 intel_disable_primary(struct drm_crtc *);
void	 ilk_update_plane(struct drm_plane *, struct drm_framebuffer *,
	     struct drm_i915_gem_object *, int, int, unsigned int, unsigned int,
	     uint32_t, uint32_t, uint32_t, uint32_t);
void	 ilk_disable_plane(struct drm_plane *);
int	 ilk_update_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);
void	 ilk_get_colorkey(struct drm_plane *,
	     struct drm_intel_sprite_colorkey *);

void
d147 1
a147 1
void
d167 1
a167 1
int
d196 1
a196 1
void
d221 1
a221 1
void
d307 1
a307 1
void
d323 1
a323 1
void
d340 1
a340 1
void
d357 1
a357 1
int
d386 1
a386 1
void
d411 1
a411 1
int
d550 2
a551 2
int
intel_disable_drm_plane(struct drm_plane *plane)
d573 1
a573 2
void
intel_destroy_plane(struct drm_plane *plane)
d576 1
a576 1
	intel_disable_drm_plane(plane);
d581 1
a581 2
int
intel_sprite_set_colorkey(struct drm_device *dev, void *data,
d614 1
a614 2
int
intel_sprite_get_colorkey(struct drm_device *dev, void *data,
d645 1
a645 1
	.disable_plane = intel_disable_drm_plane,
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d183 1
a183 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d204 1
a204 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d232 1
a232 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d261 1
a261 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d343 1
a343 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d359 1
a359 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d376 1
a376 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d394 1
a394 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d422 1
a422 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
d451 1
a451 1
	struct inteldrm_softc *dev_priv = dev->dev_private;
@

