head	1.106;
access;
symbols
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.106.0.4
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.99.0.4
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.85.0.4
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28;
locks; strict;
comment	@ * @;


1.106
date	2016.04.05.21.22.02;	author kettenis;	state Exp;
branches;
next	1.105;
commitid	HESbnwM3z1fH4IBz;

1.105
date	2016.04.05.08.22.50;	author kettenis;	state Exp;
branches;
next	1.104;
commitid	4zEfxNVjitzOF81p;

1.104
date	2015.10.19.19.54.35;	author kettenis;	state Exp;
branches;
next	1.103;
commitid	JXuDrDgg2dBFhF56;

1.103
date	2015.10.07.09.53.00;	author kettenis;	state Exp;
branches;
next	1.102;
commitid	k2SU4CwVoB6TQ00j;

1.102
date	2015.09.30.06.29.09;	author kettenis;	state Exp;
branches;
next	1.101;
commitid	fVxVZWGpbu83iMVo;

1.101
date	2015.09.24.20.52.28;	author kettenis;	state Exp;
branches;
next	1.100;
commitid	7aH5GgFn0EMAmSm3;

1.100
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.99;
commitid	lQlppvmETCN49oZe;

1.99
date	2015.07.16.18.48.51;	author kettenis;	state Exp;
branches;
next	1.98;
commitid	L0a8i9q8D7R6QA4N;

1.98
date	2015.06.26.15.22.23;	author kettenis;	state Exp;
branches;
next	1.97;
commitid	zE715ZsjyYsYQNQ0;

1.97
date	2015.06.24.17.59.42;	author kettenis;	state Exp;
branches;
next	1.96;
commitid	3wz7SV1D1yJbfWE9;

1.96
date	2015.06.24.08.32.39;	author kettenis;	state Exp;
branches;
next	1.95;
commitid	hfEqCdm8ecmxIgUE;

1.95
date	2015.06.22.15.20.43;	author kettenis;	state Exp;
branches;
next	1.94;
commitid	C4tEeNlcZM8TbJM2;

1.94
date	2015.04.18.14.47.34;	author jsg;	state Exp;
branches;
next	1.93;
commitid	c1fUeeFWMNg4COgR;

1.93
date	2015.04.18.11.41.28;	author jsg;	state Exp;
branches;
next	1.92;
commitid	c3CbYQJYD10xhd6O;

1.92
date	2015.04.17.00.54.42;	author jsg;	state Exp;
branches;
next	1.91;
commitid	LqdQe79hlknpVtvI;

1.91
date	2015.04.12.17.10.07;	author kettenis;	state Exp;
branches;
next	1.90;
commitid	7RIU3AxWXbuzxDet;

1.90
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.89;
commitid	uVTyY1h8Sggc8pFj;

1.89
date	2015.04.08.02.28.13;	author jsg;	state Exp;
branches;
next	1.88;
commitid	pBZw25gbMMahiUV2;

1.88
date	2015.04.06.12.25.10;	author jsg;	state Exp;
branches;
next	1.87;
commitid	CN1fAwudhSb2ckyl;

1.87
date	2015.04.06.10.56.37;	author jsg;	state Exp;
branches;
next	1.86;
commitid	YRwUkzqVtigPPQbt;

1.86
date	2015.04.05.11.53.53;	author kettenis;	state Exp;
branches;
next	1.85;
commitid	3YXcRggXXMDC9Cpg;

1.85
date	2015.02.12.08.48.32;	author jsg;	state Exp;
branches;
next	1.84;
commitid	b7XA83Agvw5SEHRi;

1.84
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.83;
commitid	adfbJ0ccUTdhFGhI;

1.83
date	2015.02.12.02.12.02;	author kettenis;	state Exp;
branches;
next	1.82;
commitid	cYXtgYH6nnLqDRGU;

1.82
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.81;
commitid	aHLMSW1RfE1rmMw9;

1.81
date	2015.02.10.06.19.36;	author jsg;	state Exp;
branches;
next	1.80;
commitid	0OQNG9STPII6jEb4;

1.80
date	2015.02.10.01.39.32;	author jsg;	state Exp;
branches;
next	1.79;
commitid	a8Vt7gSt34kmziIS;

1.79
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.78;
commitid	MyKPm9Q3dQu92BiX;

1.78
date	2014.12.17.06.58.10;	author guenther;	state Exp;
branches;
next	1.77;
commitid	DImukoCWyTxwdbuh;

1.77
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.76;
commitid	ZxaujiOM0aYQRjFY;

1.76
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	yv0ECmCdICvq576h;

1.75
date	2014.09.20.21.17.43;	author kettenis;	state Exp;
branches;
next	1.74;
commitid	EVxnMw291QGly5Fu;

1.74
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.73;
commitid	OBNa5kfxQ2UXoiIw;

1.73
date	2014.05.12.19.29.16;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2014.04.01.20.16.50;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.70;

1.70
date	2014.02.13.23.11.05;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2014.02.05.10.41.32;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2014.02.02.10.54.10;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.30.15.10.47;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.21.08.29.32;	author kettenis;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.21.08.25.33;	author kettenis;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.21.04.47.38;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2013.12.21.15.09.23;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2013.12.21.12.21.23;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2013.12.15.11.42.10;	author kettenis;	state Exp;
branches;
next	1.59;

1.59
date	2013.12.11.20.31.43;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.09.20.09.55;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2013.12.07.17.20.47;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2013.12.06.23.41.51;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2013.12.06.20.13.29;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2013.12.05.13.29.56;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2013.12.01.14.23.48;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2013.12.01.12.58.33;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2013.12.01.11.47.13;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2013.11.30.20.13.36;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2013.11.30.20.03.32;	author kettenis;	state Exp;
branches;
next	1.48;

1.48
date	2013.11.28.20.32.20;	author kettenis;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.27.20.13.30;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.20.02.03.52;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.19.15.08.04;	author jsg;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.17.18.47.13;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.17.14.29.45;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2013.11.02.22.58.10;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.02.14.37.19;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2013.10.26.20.31.48;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2013.10.05.07.30.06;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.03.18.12.18;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2013.09.13.13.00.00;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.10.03.40.39;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.13.10.23.49;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.09.07.55.42;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2013.08.07.19.49.06;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.07.00.04.28;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2013.07.29.18.32.15;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2013.07.10.02.21.09;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.04.09.49.00;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2013.06.12.14.28.40;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2013.06.11.19.39.09;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.07.20.46.15;	author kettenis;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.27.19.29.25;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.18.21.43.42;	author kettenis;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.11.19.03.41;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.11.15.57.24;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.09.16.06.40;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.09.15.00.41;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.08.23.01.36;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.05.13.55.36;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.05.13.19.00;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.05.13.02.46;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.21.14.41.26;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.17.20.04.04;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.08.21.32.19;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.03.19.57.17;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2013.03.30.11.08.07;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.03.28.22.41.48;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.28.19.38.53;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.03.28.05.13.07;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.22.22.51.00;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2013.03.22.06.19.56;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.21.21.49.07;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Use the "idr" API here as well, reducing the diffs to Linux.
@
text
@/*	$OpenBSD: i915_gem.c,v 1.105 2016/04/05 08:22:50 kettenis Exp $	*/
/*
 * Copyright (c) 2008-2009 Owain G. Ainsworth <oga@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright © 2008 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *
 */

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_vma_manager.h>
#include <dev/pci/drm/i915_drm.h>
#include "i915_drv.h"
#include "i915_trace.h"
#include "intel_drv.h"

#include <machine/pmap.h>

static void i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj);
static void i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj,
						   bool force);
static __must_check int
i915_gem_object_wait_rendering(struct drm_i915_gem_object *obj,
			       bool readonly);
static __must_check int
i915_gem_object_bind_to_vm(struct drm_i915_gem_object *obj,
			   struct i915_address_space *vm,
			   unsigned alignment,
			   bool map_and_fenceable,
			   bool nonblocking);
static int i915_gem_phys_pwrite(struct drm_device *dev,
				struct drm_i915_gem_object *obj,
				struct drm_i915_gem_pwrite *args,
				struct drm_file *file);

static void i915_gem_write_fence(struct drm_device *dev, int reg,
				 struct drm_i915_gem_object *obj);
static void i915_gem_object_update_fence(struct drm_i915_gem_object *obj,
					 struct drm_i915_fence_reg *fence,
					 bool enable);

#ifdef notyet
static unsigned long i915_gem_inactive_count(struct shrinker *shrinker,
					     struct shrink_control *sc);
static unsigned long i915_gem_inactive_scan(struct shrinker *shrinker,
					    struct shrink_control *sc);
static unsigned long i915_gem_purge(struct drm_i915_private *dev_priv, long target);
static unsigned long i915_gem_shrink_all(struct drm_i915_private *dev_priv);
#endif
static void i915_gem_object_truncate(struct drm_i915_gem_object *obj);

static bool cpu_cache_is_coherent(struct drm_device *dev,
				  enum i915_cache_level level)
{
	return HAS_LLC(dev) || level != I915_CACHE_NONE;
}

static bool cpu_write_needs_clflush(struct drm_i915_gem_object *obj)
{
	if (!cpu_cache_is_coherent(obj->base.dev, obj->cache_level))
		return true;

	return obj->pin_display;
}

static inline void i915_gem_object_fence_lost(struct drm_i915_gem_object *obj)
{
	if (obj->tiling_mode)
		i915_gem_release_mmap(obj);

	/* As we do not have an associated fence register, we will force
	 * a tiling change if we ever need to acquire one.
	 */
	obj->fence_dirty = false;
	obj->fence_reg = I915_FENCE_REG_NONE;
}

/* some bookkeeping */
static void i915_gem_info_add_obj(struct drm_i915_private *dev_priv,
				  size_t size)
{
	spin_lock(&dev_priv->mm.object_stat_lock);
	dev_priv->mm.object_count++;
	dev_priv->mm.object_memory += size;
	spin_unlock(&dev_priv->mm.object_stat_lock);
}

static void i915_gem_info_remove_obj(struct drm_i915_private *dev_priv,
				     size_t size)
{
	spin_lock(&dev_priv->mm.object_stat_lock);
	dev_priv->mm.object_count--;
	dev_priv->mm.object_memory -= size;
	spin_unlock(&dev_priv->mm.object_stat_lock);
}

static int
i915_gem_wait_for_error(struct i915_gpu_error *error)
{
	int ret;

#define EXIT_COND (!i915_reset_in_progress(error) || \
		   i915_terminally_wedged(error))
	if (EXIT_COND)
		return 0;

	/*
	 * Only wait 10 seconds for the gpu reset to complete to avoid hanging
	 * userspace. If it takes that long something really bad is going on and
	 * we should simply try to bail out and fail as gracefully as possible.
	 */
	ret = wait_event_interruptible_timeout(error->reset_queue,
					       EXIT_COND,
					       10*HZ);
	if (ret == 0) {
		DRM_ERROR("Timed out waiting for the gpu reset to complete\n");
		return -EIO;
	} else if (ret < 0) {
		return ret;
	}
#undef EXIT_COND

	return 0;
}

int i915_mutex_lock_interruptible(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	ret = i915_gem_wait_for_error(&dev_priv->gpu_error);
	if (ret)
		return ret;

	ret = mutex_lock_interruptible(&dev->struct_mutex);
	if (ret)
		return ret;

	WARN_ON(i915_verify_lists(dev));
	return 0;
}

static inline bool
i915_gem_object_is_inactive(struct drm_i915_gem_object *obj)
{
	return i915_gem_obj_bound_any(obj) && !obj->active;
}

int
i915_gem_init_ioctl(struct drm_device *dev, void *data,
		    struct drm_file *file)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_init *args = data;

	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return -ENODEV;

	if (args->gtt_start >= args->gtt_end ||
	    (args->gtt_end | args->gtt_start) & (PAGE_SIZE - 1))
		return -EINVAL;

	/* GEM with user mode setting was never supported on ilk and later. */
	if (INTEL_INFO(dev)->gen >= 5)
		return -ENODEV;

	mutex_lock(&dev->struct_mutex);
	i915_gem_setup_global_gtt(dev, args->gtt_start, args->gtt_end,
				  args->gtt_end);
	dev_priv->gtt.mappable_end = args->gtt_end;
	mutex_unlock(&dev->struct_mutex);

	return 0;
}

int
i915_gem_get_aperture_ioctl(struct drm_device *dev, void *data,
			    struct drm_file *file)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_get_aperture *args = data;
	struct drm_i915_gem_object *obj;
	size_t pinned;

	pinned = 0;
	mutex_lock(&dev->struct_mutex);
	list_for_each_entry(obj, &dev_priv->mm.bound_list, global_list)
		if (obj->pin_count)
			pinned += i915_gem_obj_ggtt_size(obj);
	mutex_unlock(&dev->struct_mutex);

	args->aper_size = dev_priv->gtt.base.total;
	args->aper_available_size = args->aper_size - pinned;

	return 0;
}

void *i915_gem_object_alloc(struct drm_device *dev)
{
	return pool_get(&dev->objpl, PR_WAITOK | PR_ZERO);
}

void i915_gem_object_free(struct drm_i915_gem_object *obj)
{
	pool_put(&obj->base.dev->objpl, obj);
}

static int
i915_gem_create(struct drm_file *file,
		struct drm_device *dev,
		uint64_t size,
		uint32_t *handle_p)
{
	struct drm_i915_gem_object *obj;
	int ret;
	u32 handle;

	size = roundup(size, PAGE_SIZE);
	if (size == 0)
		return -EINVAL;

	/* Allocate the new object */
	obj = i915_gem_alloc_object(dev, size);
	if (obj == NULL)
		return -ENOMEM;

	ret = drm_gem_handle_create(file, &obj->base, &handle);
	/* drop reference from allocate - handle holds it now */
	drm_gem_object_unreference_unlocked(&obj->base);
	if (ret)
		return ret;

	*handle_p = handle;
	return 0;
}

int
i915_gem_dumb_create(struct drm_file *file,
		     struct drm_device *dev,
		     struct drm_mode_create_dumb *args)
{
	/* have to work out size/pitch and return them */
	args->pitch = roundup2(args->width * DIV_ROUND_UP(args->bpp, 8), 64);
	args->size = args->pitch * args->height;
	return i915_gem_create(file, dev,
			       args->size, &args->handle);
}

/**
 * Creates a new mm object and returns a handle to it.
 */
int
i915_gem_create_ioctl(struct drm_device *dev, void *data,
		      struct drm_file *file)
{
	struct drm_i915_gem_create *args = data;

	return i915_gem_create(file, dev,
			       args->size, &args->handle);
}

static inline void
drm_clflush_virt_range(void *addr, size_t len)
{
	pmap_flush_cache((vaddr_t)addr, len);
}

static inline int
__copy_to_user_swizzled(char __user *cpu_vaddr,
			const char *gpu_vaddr, int gpu_offset,
			int length)
{
	int ret, cpu_offset = 0;

	while (length > 0) {
		int cacheline_end = roundup2(gpu_offset + 1, 64);
		int this_length = min(cacheline_end - gpu_offset, length);
		int swizzled_gpu_offset = gpu_offset ^ 64;

		ret = __copy_to_user(cpu_vaddr + cpu_offset,
				     gpu_vaddr + swizzled_gpu_offset,
				     this_length);
		if (ret)
			return ret + length;

		cpu_offset += this_length;
		gpu_offset += this_length;
		length -= this_length;
	}

	return 0;
}

static inline int
__copy_from_user_swizzled(char *gpu_vaddr, int gpu_offset,
			  const char __user *cpu_vaddr,
			  int length)
{
	int ret, cpu_offset = 0;

	while (length > 0) {
		int cacheline_end = roundup2(gpu_offset + 1, 64);
		int this_length = min(cacheline_end - gpu_offset, length);
		int swizzled_gpu_offset = gpu_offset ^ 64;

		ret = __copy_from_user(gpu_vaddr + swizzled_gpu_offset,
				       cpu_vaddr + cpu_offset,
				       this_length);
		if (ret)
			return ret + length;

		cpu_offset += this_length;
		gpu_offset += this_length;
		length -= this_length;
	}

	return 0;
}

/* Per-page copy function for the shmem pread fastpath.
 * Flushes invalid cachelines before reading the target if
 * needs_clflush is set. */
static int
shmem_pread_fast(struct vm_page *page, int shmem_page_offset, int page_length,
		 char __user *user_data,
		 bool page_do_bit17_swizzling, bool needs_clflush)
{
	char *vaddr;
	int ret;

	if (unlikely(page_do_bit17_swizzling))
		return -EINVAL;

	vaddr = kmap_atomic(page);
	if (needs_clflush)
		drm_clflush_virt_range(vaddr + shmem_page_offset,
				       page_length);
	ret = __copy_to_user_inatomic(user_data,
				      vaddr + shmem_page_offset,
				      page_length);
	kunmap_atomic(vaddr);

	return ret ? -EFAULT : 0;
}

static void
shmem_clflush_swizzled_range(char *addr, unsigned long length,
			     bool swizzled)
{
	if (unlikely(swizzled)) {
		unsigned long start = (unsigned long) addr;
		unsigned long end = (unsigned long) addr + length;

		/* For swizzling simply ensure that we always flush both
		 * channels. Lame, but simple and it works. Swizzled
		 * pwrite/pread is far from a hotpath - current userspace
		 * doesn't use it at all. */
		start = round_down(start, 128);
		end = round_up(end, 128);

		drm_clflush_virt_range((void *)start, end - start);
	} else {
		drm_clflush_virt_range(addr, length);
	}

}

/* Only difference to the fast-path function is that this can handle bit17
 * and uses non-atomic copy and kmap functions. */
static int
shmem_pread_slow(struct vm_page *page, int shmem_page_offset, int page_length,
		 char __user *user_data,
		 bool page_do_bit17_swizzling, bool needs_clflush)
{
	char *vaddr;
	int ret;

	vaddr = kmap(page);
	if (needs_clflush)
		shmem_clflush_swizzled_range(vaddr + shmem_page_offset,
					     page_length,
					     page_do_bit17_swizzling);

	if (page_do_bit17_swizzling)
		ret = __copy_to_user_swizzled(user_data,
					      vaddr, shmem_page_offset,
					      page_length);
	else
		ret = __copy_to_user(user_data,
				     vaddr + shmem_page_offset,
				     page_length);
	kunmap(vaddr);

	return ret ? - EFAULT : 0;
}

static int
i915_gem_shmem_pread(struct drm_device *dev,
		     struct drm_i915_gem_object *obj,
		     struct drm_i915_gem_pread *args,
		     struct drm_file *file)
{
	char __user *user_data;
	ssize_t remain;
	loff_t offset;
	int shmem_page_offset, page_length, ret = 0;
	int obj_do_bit17_swizzling, page_do_bit17_swizzling;
	int needs_clflush = 0;
	int i;

	user_data = to_user_ptr(args->data_ptr);
	remain = args->size;

	obj_do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);

	if (!(obj->base.read_domains & I915_GEM_DOMAIN_CPU)) {
		/* If we're not in the cpu read domain, set ourself into the gtt
		 * read domain and manually flush cachelines (if required). This
		 * optimizes for the case when the gpu will dirty the data
		 * anyway again before the next pread happens. */
		needs_clflush = !cpu_cache_is_coherent(dev, obj->cache_level);
		ret = i915_gem_object_wait_rendering(obj, true);
		if (ret)
			return ret;
	}

	ret = i915_gem_object_get_pages(obj);
	if (ret)
		return ret;

	i915_gem_object_pin_pages(obj);

	offset = args->offset;

	for (i = 0; i < (obj->base.size >> PAGE_SHIFT); i++) {
		struct vm_page *page;

		if (i < (offset >> PAGE_SHIFT))
			continue;

		if (remain <= 0)
			break;

		/* Operation in this page
		 *
		 * shmem_page_offset = offset within page in shmem file
		 * page_length = bytes to copy for this page
		 */
		shmem_page_offset = offset_in_page(offset);
		page_length = remain;
		if ((shmem_page_offset + page_length) > PAGE_SIZE)
			page_length = PAGE_SIZE - shmem_page_offset;

#ifdef __linux__
		page = sg_page(sg);
#else
		page = obj->pages[i];
#endif
		page_do_bit17_swizzling = obj_do_bit17_swizzling &&
			(page_to_phys(page) & (1 << 17)) != 0;

		ret = shmem_pread_fast(page, shmem_page_offset, page_length,
				       user_data, page_do_bit17_swizzling,
				       needs_clflush);
		if (ret == 0)
			goto next_page;

		mutex_unlock(&dev->struct_mutex);

#ifdef __linux__
		if (likely(!i915_prefault_disable) && !prefaulted) {
			ret = fault_in_multipages_writeable(user_data, remain);
			/* Userspace is tricking us, but we've already clobbered
			 * its pages with the prefault and promised to write the
			 * data up to the first fault. Hence ignore any errors
			 * and just continue. */
			(void)ret;
			prefaulted = 1;
		}
#endif

		ret = shmem_pread_slow(page, shmem_page_offset, page_length,
				       user_data, page_do_bit17_swizzling,
				       needs_clflush);

		mutex_lock(&dev->struct_mutex);

next_page:
#ifdef __linux__
		mark_page_accessed(page);
#endif

		if (ret)
			goto out;

		remain -= page_length;
		user_data += page_length;
		offset += page_length;
	}

out:
	i915_gem_object_unpin_pages(obj);

	return ret;
}

/**
 * Reads data from the object referenced by handle.
 *
 * On error, the contents of *data are undefined.
 */
int
i915_gem_pread_ioctl(struct drm_device *dev, void *data,
		     struct drm_file *file)
{
	struct drm_i915_gem_pread *args = data;
	struct drm_i915_gem_object *obj;
	int ret = 0;

	if (args->size == 0)
		return 0;

	if (!access_ok(VERIFY_WRITE,
		       to_user_ptr(args->data_ptr),
		       args->size))
		return -EFAULT;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	/* Bounds check source.  */
	if (args->offset > obj->base.size ||
	    args->size > obj->base.size - args->offset) {
		ret = -EINVAL;
		goto out;
	}

#ifdef notyet
	/* prime objects have no backing filp to GEM pread/pwrite
	 * pages from.
	 */
	if (!obj->base.filp) {
		ret = -EINVAL;
		goto out;
	}
#endif

	trace_i915_gem_object_pread(obj, args->offset, args->size);

	ret = i915_gem_shmem_pread(dev, obj, args, file);

out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

#ifdef __linux__
/* This is the fast write path which cannot handle
 * page faults in the source data
 */

static inline int
fast_user_write(struct io_mapping *mapping,
		loff_t page_base, int page_offset,
		char __user *user_data,
		int length)
{
	void __iomem *vaddr_atomic;
	void *vaddr;
	unsigned long unwritten;

	vaddr_atomic = io_mapping_map_atomic_wc(mapping, page_base);
	/* We can use the cpu mem copy function because this is X86. */
	vaddr = (void __force*)vaddr_atomic + page_offset;
	unwritten = __copy_from_user_inatomic_nocache(vaddr,
						      user_data, length);
	io_mapping_unmap_atomic(vaddr_atomic);
	return unwritten;
}
#else
/* This is the fast write path which cannot handle
 * page faults in the source data
 */

static inline int
fast_user_write(struct drm_i915_private *dev_priv,
		bus_size_t page_base, int page_offset,
		char __user *user_data,
		int length)
{
	bus_space_handle_t bsh;
	void __iomem *vaddr_atomic;
	void *vaddr;
	unsigned long unwritten;

	agp_map_atomic(dev_priv->agph, page_base, &bsh);
	vaddr_atomic = bus_space_vaddr(dev_priv->bst, bsh);
	/* We can use the cpu mem copy function because this is X86. */
	vaddr = (void __force*)vaddr_atomic + page_offset;
	unwritten = __copy_from_user_inatomic_nocache(vaddr,
						      user_data, length);
	agp_unmap_atomic(dev_priv->agph, bsh);
	return unwritten;
}
#endif

/**
 * This is the fast pwrite path, where we copy the data directly from the
 * user into the GTT, uncached.
 */
static int
i915_gem_gtt_pwrite_fast(struct drm_device *dev,
			 struct drm_i915_gem_object *obj,
			 struct drm_i915_gem_pwrite *args,
			 struct drm_file *file)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	ssize_t remain;
	bus_size_t offset, page_base;
	char __user *user_data;
	int page_offset, page_length, ret;

	ret = i915_gem_obj_ggtt_pin(obj, 0, true, true);
	if (ret)
		goto out;

	ret = i915_gem_object_set_to_gtt_domain(obj, true);
	if (ret)
		goto out_unpin;

	ret = i915_gem_object_put_fence(obj);
	if (ret)
		goto out_unpin;

	user_data = to_user_ptr(args->data_ptr);
	remain = args->size;

	offset = i915_gem_obj_ggtt_offset(obj) + args->offset;

	while (remain > 0) {
		/* Operation in this page
		 *
		 * page_base = page offset within aperture
		 * page_offset = offset within page
		 * page_length = bytes to copy for this page
		 */
		page_base = offset & ~PAGE_MASK;
		page_offset = offset_in_page(offset);
		page_length = remain;
		if ((page_offset + remain) > PAGE_SIZE)
			page_length = PAGE_SIZE - page_offset;

		/* If we get a fault while copying data, then (presumably) our
		 * source page isn't available.  Return the error and we'll
		 * retry in the slow path.
		 */
		if (fast_user_write(dev_priv, page_base,
				    page_offset, user_data, page_length)) {
			ret = -EFAULT;
			goto out_unpin;
		}

		remain -= page_length;
		user_data += page_length;
		offset += page_length;
	}

out_unpin:
	i915_gem_object_unpin(obj);
out:
	return ret;
}

/* Per-page copy function for the shmem pwrite fastpath.
 * Flushes invalid cachelines before writing to the target if
 * needs_clflush_before is set and flushes out any written cachelines after
 * writing if needs_clflush is set. */
static int
shmem_pwrite_fast(struct vm_page *page, int shmem_page_offset, int page_length,
		  char __user *user_data,
		  bool page_do_bit17_swizzling,
		  bool needs_clflush_before,
		  bool needs_clflush_after)
{
	char *vaddr;
	int ret;

	if (unlikely(page_do_bit17_swizzling))
		return -EINVAL;

	vaddr = kmap_atomic(page);
	if (needs_clflush_before)
		drm_clflush_virt_range(vaddr + shmem_page_offset,
				       page_length);
	ret = __copy_from_user_inatomic_nocache(vaddr + shmem_page_offset,
						user_data,
						page_length);
	if (needs_clflush_after)
		drm_clflush_virt_range(vaddr + shmem_page_offset,
				       page_length);
	kunmap_atomic(vaddr);

	return ret ? -EFAULT : 0;
}

/* Only difference to the fast-path function is that this can handle bit17
 * and uses non-atomic copy and kmap functions. */
static int
shmem_pwrite_slow(struct vm_page *page, int shmem_page_offset, int page_length,
		  char __user *user_data,
		  bool page_do_bit17_swizzling,
		  bool needs_clflush_before,
		  bool needs_clflush_after)
{
	char *vaddr;
	int ret;

	vaddr = kmap(page);
	if (unlikely(needs_clflush_before || page_do_bit17_swizzling))
		shmem_clflush_swizzled_range(vaddr + shmem_page_offset,
					     page_length,
					     page_do_bit17_swizzling);
	if (page_do_bit17_swizzling)
		ret = __copy_from_user_swizzled(vaddr, shmem_page_offset,
						user_data,
						page_length);
	else
		ret = __copy_from_user(vaddr + shmem_page_offset,
				       user_data,
				       page_length);
	if (needs_clflush_after)
		shmem_clflush_swizzled_range(vaddr + shmem_page_offset,
					     page_length,
					     page_do_bit17_swizzling);
	kunmap(vaddr);

	return ret ? -EFAULT : 0;
}

static int
i915_gem_shmem_pwrite(struct drm_device *dev,
		      struct drm_i915_gem_object *obj,
		      struct drm_i915_gem_pwrite *args,
		      struct drm_file *file)
{
	ssize_t remain;
	loff_t offset;
	char __user *user_data;
	int shmem_page_offset, page_length, ret = 0;
	int obj_do_bit17_swizzling, page_do_bit17_swizzling;
	int hit_slowpath = 0;
	int needs_clflush_after = 0;
	int needs_clflush_before = 0;
	int i;

	user_data = to_user_ptr(args->data_ptr);
	remain = args->size;

	obj_do_bit17_swizzling = i915_gem_object_needs_bit17_swizzle(obj);

	if (obj->base.write_domain != I915_GEM_DOMAIN_CPU) {
		/* If we're not in the cpu write domain, set ourself into the gtt
		 * write domain and manually flush cachelines (if required). This
		 * optimizes for the case when the gpu will use the data
		 * right away and we therefore have to clflush anyway. */
		needs_clflush_after = cpu_write_needs_clflush(obj);
		ret = i915_gem_object_wait_rendering(obj, false);
		if (ret)
			return ret;
	}
	/* Same trick applies to invalidate partially written cachelines read
	 * before writing. */
	if ((obj->base.read_domains & I915_GEM_DOMAIN_CPU) == 0)
		needs_clflush_before =
			!cpu_cache_is_coherent(dev, obj->cache_level);

	ret = i915_gem_object_get_pages(obj);
	if (ret)
		return ret;

	i915_gem_object_pin_pages(obj);

	offset = args->offset;
	obj->dirty = 1;

	for (i = 0; i < (obj->base.size >> PAGE_SHIFT); i++) {
		struct vm_page *page;
		int partial_cacheline_write;

		if (i < (offset >> PAGE_SHIFT))
			continue;

		if (remain <= 0)
			break;

		/* Operation in this page
		 *
		 * shmem_page_offset = offset within page in shmem file
		 * page_length = bytes to copy for this page
		 */
		shmem_page_offset = offset_in_page(offset);

		page_length = remain;
		if ((shmem_page_offset + page_length) > PAGE_SIZE)
			page_length = PAGE_SIZE - shmem_page_offset;

		/* If we don't overwrite a cacheline completely we need to be
		 * careful to have up-to-date data by first clflushing. Don't
		 * overcomplicate things and flush the entire patch. */
		partial_cacheline_write = needs_clflush_before &&
			((shmem_page_offset | page_length)
				& (curcpu()->ci_cflushsz - 1));

#ifdef __linux__
		page = sg_page(sg);
#else
		page = obj->pages[i];
#endif
		page_do_bit17_swizzling = obj_do_bit17_swizzling &&
			(page_to_phys(page) & (1 << 17)) != 0;

		ret = shmem_pwrite_fast(page, shmem_page_offset, page_length,
					user_data, page_do_bit17_swizzling,
					partial_cacheline_write,
					needs_clflush_after);
		if (ret == 0)
			goto next_page;

		hit_slowpath = 1;
		mutex_unlock(&dev->struct_mutex);
		ret = shmem_pwrite_slow(page, shmem_page_offset, page_length,
					user_data, page_do_bit17_swizzling,
					partial_cacheline_write,
					needs_clflush_after);

		mutex_lock(&dev->struct_mutex);

next_page:
		set_page_dirty(page);
#ifdef __linux__
		mark_page_accessed(page);
#endif

		if (ret)
			goto out;

		remain -= page_length;
		user_data += page_length;
		offset += page_length;
	}

out:
	i915_gem_object_unpin_pages(obj);

	if (hit_slowpath) {
		/*
		 * Fixup: Flush cpu caches in case we didn't flush the dirty
		 * cachelines in-line while writing and the object moved
		 * out of the cpu write domain while we've dropped the lock.
		 */
		if (!needs_clflush_after &&
		    obj->base.write_domain != I915_GEM_DOMAIN_CPU) {
			if (i915_gem_clflush_object(obj, obj->pin_display))
				i915_gem_chipset_flush(dev);
		}
	}

	if (needs_clflush_after)
		i915_gem_chipset_flush(dev);

	return ret;
}

/**
 * Writes data to the object referenced by handle.
 *
 * On error, the contents of the buffer that were to be modified are undefined.
 */
int
i915_gem_pwrite_ioctl(struct drm_device *dev, void *data,
		      struct drm_file *file)
{
	struct drm_i915_gem_pwrite *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	if (args->size == 0)
		return 0;

	if (!access_ok(VERIFY_READ,
		       to_user_ptr(args->data_ptr),
		       args->size))
		return -EFAULT;

#ifdef __linux__
	if (likely(!i915_prefault_disable)) {
		ret = fault_in_multipages_readable(to_user_ptr(args->data_ptr),
						   args->size);
		if (ret)
			return -EFAULT;
	}
#endif

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	/* Bounds check destination. */
	if (args->offset > obj->base.size ||
	    args->size > obj->base.size - args->offset) {
		ret = -EINVAL;
		goto out;
	}

#ifdef notyet
	/* prime objects have no backing filp to GEM pread/pwrite
	 * pages from.
	 */
	if (!obj->base.filp) {
		ret = -EINVAL;
		goto out;
	}
#endif

	trace_i915_gem_object_pwrite(obj, args->offset, args->size);

	ret = -EFAULT;
	/* We can only do the GTT pwrite on untiled buffers, as otherwise
	 * it would end up going through the fenced access, and we'll get
	 * different detiling behavior between reading and writing.
	 * pread/pwrite currently are reading and writing from the CPU
	 * perspective, requiring manual detiling by the client.
	 */
	if (obj->phys_obj) {
		ret = i915_gem_phys_pwrite(dev, obj, args, file);
		goto out;
	}

	if (obj->tiling_mode == I915_TILING_NONE &&
	    obj->base.write_domain != I915_GEM_DOMAIN_CPU &&
	    cpu_write_needs_clflush(obj)) {
		ret = i915_gem_gtt_pwrite_fast(dev, obj, args, file);
		/* Note that the gtt paths might fail with non-page-backed user
		 * pointers (e.g. gtt mappings when moving data between
		 * textures). Fallback to the shmem path in that case. */
	}

	if (ret == -EFAULT || ret == -ENOSPC)
		ret = i915_gem_shmem_pwrite(dev, obj, args, file);

out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int
i915_gem_check_wedge(struct i915_gpu_error *error,
		     bool interruptible)
{
	if (i915_reset_in_progress(error)) {
		/* Non-interruptible callers can't handle -EAGAIN, hence return
		 * -EIO unconditionally for these. */
		if (!interruptible)
			return -EIO;

		/* Recovery complete, but the reset failed ... */
		if (i915_terminally_wedged(error))
			return -EIO;

		return -EAGAIN;
	}

	return 0;
}

/*
 * Compare seqno against outstanding lazy request. Emit a request if they are
 * equal.
 */
static int
i915_gem_check_olr(struct intel_ring_buffer *ring, u32 seqno)
{
	int ret;

	BUG_ON(!mutex_is_locked(&ring->dev->struct_mutex));

	ret = 0;
	if (seqno == ring->outstanding_lazy_seqno)
		ret = i915_add_request(ring, NULL);

	return ret;
}

#ifdef notyet
static void fake_irq(unsigned long data)
{
	wake_up_process((struct task_struct *)data);
}
#endif

static bool missed_irq(struct drm_i915_private *dev_priv,
		       struct intel_ring_buffer *ring)
{
	return test_bit(ring->id, &dev_priv->gpu_error.missed_irq_rings);
}

static bool can_wait_boost(struct drm_i915_file_private *file_priv)
{
	if (file_priv == NULL)
		return true;

	return !atomic_xchg(&file_priv->rps_wait_boost, true);
}

/**
 * __wait_seqno - wait until execution of seqno has finished
 * @@ring: the ring expected to report seqno
 * @@seqno: duh!
 * @@reset_counter: reset sequence associated with the given seqno
 * @@interruptible: do an interruptible wait (normally yes)
 * @@timeout: in - how long to wait (NULL forever); out - how much time remaining
 *
 * Note: It is of utmost importance that the passed in seqno and reset_counter
 * values have been read by the caller in an smp safe manner. Where read-side
 * locks are involved, it is sufficient to read the reset_counter before
 * unlocking the lock that protects the seqno. For lockless tricks, the
 * reset_counter _must_ be read before, and an appropriate smp_rmb must be
 * inserted.
 *
 * Returns 0 if the seqno was found within the alloted time. Else returns the
 * errno with remaining time filled in timeout argument.
 */
#ifdef __linux__
static int __wait_seqno(struct intel_ring_buffer *ring, u32 seqno,
			unsigned reset_counter,
			bool interruptible,
			struct timespec *timeout,
			struct drm_i915_file_private *file_priv)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	const bool irq_test_in_progress =
		ACCESS_ONCE(dev_priv->gpu_error.test_irq_rings) & intel_ring_flag(ring);
	struct timespec before, now;
	DEFINE_WAIT(wait);
	unsigned long timeout_expire;
	int ret;

	WARN(dev_priv->pc8.irqs_disabled, "IRQs disabled\n");

	if (i915_seqno_passed(ring->get_seqno(ring, true), seqno))
		return 0;

	timeout_expire = timeout ? jiffies + timespec_to_jiffies_timeout(timeout) : 0;

	if (dev_priv->info->gen >= 6 && can_wait_boost(file_priv)) {
		gen6_rps_boost(dev_priv);
		if (file_priv)
			mod_delayed_work(dev_priv->wq,
					 &file_priv->mm.idle_work,
					 msecs_to_jiffies(100));
	}

	if (!irq_test_in_progress && WARN_ON(!ring->irq_get(ring)))
		return -ENODEV;

	/* Record current time in case interrupted by signal, or wedged */
	trace_i915_gem_request_wait_begin(ring, seqno);
	getrawmonotonic(&before);
	for (;;) {
		struct timer_list timer;

		prepare_to_wait(&ring->irq_queue, &wait,
				interruptible ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);

		/* We need to check whether any gpu reset happened in between
		 * the caller grabbing the seqno and now ... */
		if (reset_counter != atomic_read(&dev_priv->gpu_error.reset_counter)) {
			/* ... but upgrade the -EAGAIN to an -EIO if the gpu
			 * is truely gone. */
			ret = i915_gem_check_wedge(&dev_priv->gpu_error, interruptible);
			if (ret == 0)
				ret = -EAGAIN;
			break;
		}

		if (i915_seqno_passed(ring->get_seqno(ring, false), seqno)) {
			ret = 0;
			break;
		}

		if (interruptible && signal_pending(current)) {
			ret = -ERESTARTSYS;
			break;
		}

		if (timeout && time_after_eq(jiffies, timeout_expire)) {
			ret = -ETIME;
			break;
		}

		timer.function = NULL;
		if (timeout || missed_irq(dev_priv, ring)) {
			unsigned long expire;

			setup_timer_on_stack(&timer, fake_irq, (unsigned long)current);
			expire = missed_irq(dev_priv, ring) ? jiffies + 1 : timeout_expire;
			mod_timer(&timer, expire);
		}

		io_schedule();

		if (timer.function) {
			del_singleshot_timer_sync(&timer);
			destroy_timer_on_stack(&timer);
		}
	}
	getrawmonotonic(&now);
	trace_i915_gem_request_wait_end(ring, seqno);

	if (!irq_test_in_progress)
		ring->irq_put(ring);

	finish_wait(&ring->irq_queue, &wait);

	if (timeout) {
		struct timespec sleep_time = timespec_sub(now, before);
		*timeout = timespec_sub(*timeout, sleep_time);
		if (!timespec_valid(timeout)) /* i.e. negative time remains */
			set_normalized_timespec(timeout, 0, 0);
	}

	return ret;
}
#else
static int __wait_seqno(struct intel_ring_buffer *ring, u32 seqno,
			unsigned reset_counter,
			bool interruptible,
			struct timespec *timeout,
			struct drm_i915_file_private *file_priv)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	const bool irq_test_in_progress =
		ACCESS_ONCE(dev_priv->gpu_error.test_irq_rings) & intel_ring_flag(ring);
	struct timespec before, now;
	struct sleep_state sls;
	unsigned long timeout_expire;
	int ret = 0;

	WARN(dev_priv->pc8.irqs_disabled, "IRQs disabled\n");

	if (i915_seqno_passed(ring->get_seqno(ring, true), seqno))
		return 0;

	timeout_expire = timeout ? jiffies + timespec_to_jiffies_timeout(timeout) : 0;

	if (dev_priv->info->gen >= 6 && can_wait_boost(file_priv)) {
		gen6_rps_boost(dev_priv);
		if (file_priv)
			mod_delayed_work(dev_priv->wq,
					 &file_priv->mm.idle_work,
					 msecs_to_jiffies(100));
	}

	if (!irq_test_in_progress && WARN_ON(!ring->irq_get(ring)))
		return -ENODEV;

	/* Record current time in case interrupted by signal, or wedged */
	trace_i915_gem_request_wait_begin(ring, seqno);
	getrawmonotonic(&before);
	for (;;) {
		atomic_inc_int(&ring->irq_queue.count);
		sleep_setup(&sls, &ring->irq_queue, interruptible ? PCATCH : 0, "wseq");

		/* We need to check whether any gpu reset happened in between
		 * the caller grabbing the seqno and now ... */
		if (reset_counter != atomic_read(&dev_priv->gpu_error.reset_counter)) {
			/* ... but upgrade the -EAGAIN to an -EIO if the gpu
			 * is truely gone. */
			ret = i915_gem_check_wedge(&dev_priv->gpu_error, interruptible);
			if (ret == 0)
				ret = -EAGAIN;
			break;
		}

		if (i915_seqno_passed(ring->get_seqno(ring, false), seqno)) {
			ret = 0;
			break;
		}

		if (interruptible && ret) {
			ret = -ERESTARTSYS;
			break;
		}

		if (timeout && time_after_eq(jiffies, timeout_expire)) {
			ret = -ETIME;
			break;
		}

		if (timeout || missed_irq(dev_priv, ring)) {
			unsigned long expire;
			int timo;

			expire = missed_irq(dev_priv, ring) ? jiffies + 1 : timeout_expire;
			timo = expire - jiffies;
			if (timo < 1)
				timo = 1;
			sleep_setup_timeout(&sls, timo);
		}

		sleep_setup_signal(&sls, interruptible ? PCATCH : 0);

		sleep_finish(&sls, 1);
		sleep_finish_timeout(&sls);
		ret = sleep_finish_signal(&sls);
		atomic_dec_int(&ring->irq_queue.count);
	}
	getrawmonotonic(&now);
	trace_i915_gem_request_wait_end(ring, seqno);

	if (!irq_test_in_progress)
		ring->irq_put(ring);

	sleep_finish(&sls, 0);
	sleep_finish_timeout(&sls);
	sleep_finish_signal(&sls);
	atomic_dec_int(&ring->irq_queue.count);

	if (timeout) {
		struct timespec sleep_time = timespec_sub(now, before);
		*timeout = timespec_sub(*timeout, sleep_time);
		if (!timespec_valid(timeout)) /* i.e. negative time remains */
			set_normalized_timespec(timeout, 0, 0);
	}

	return ret;
}
#endif

/**
 * Waits for a sequence number to be signaled, and cleans up the
 * request and object lists appropriately for that event.
 */
int
i915_wait_seqno(struct intel_ring_buffer *ring, uint32_t seqno)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	bool interruptible = dev_priv->mm.interruptible;
	int ret;

	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
	BUG_ON(seqno == 0);

	ret = i915_gem_check_wedge(&dev_priv->gpu_error, interruptible);
	if (ret)
		return ret;

	ret = i915_gem_check_olr(ring, seqno);
	if (ret)
		return ret;

	return __wait_seqno(ring, seqno,
			    atomic_read(&dev_priv->gpu_error.reset_counter),
			    interruptible, NULL, NULL);
}

static int
i915_gem_object_wait_rendering__tail(struct drm_i915_gem_object *obj,
				     struct intel_ring_buffer *ring)
{
	i915_gem_retire_requests_ring(ring);

	/* Manually manage the write flush as we may have not yet
	 * retired the buffer.
	 *
	 * Note that the last_write_seqno is always the earlier of
	 * the two (read/write) seqno, so if we haved successfully waited,
	 * we know we have passed the last write.
	 */
	obj->last_write_seqno = 0;
	obj->base.write_domain &= ~I915_GEM_GPU_DOMAINS;

	return 0;
}

/**
 * Ensures that all rendering to the object has completed and the object is
 * safe to unbind from the GTT or access from the CPU.
 */
static __must_check int
i915_gem_object_wait_rendering(struct drm_i915_gem_object *obj,
			       bool readonly)
{
	struct intel_ring_buffer *ring = obj->ring;
	u32 seqno;
	int ret;

	seqno = readonly ? obj->last_write_seqno : obj->last_read_seqno;
	if (seqno == 0)
		return 0;

	ret = i915_wait_seqno(ring, seqno);
	if (ret)
		return ret;

	return i915_gem_object_wait_rendering__tail(obj, ring);
}

/* A nonblocking variant of the above wait. This is a highly dangerous routine
 * as the object state may change during this call.
 */
static __must_check int
i915_gem_object_wait_rendering__nonblocking(struct drm_i915_gem_object *obj,
					    struct drm_file *file,
					    bool readonly)
{
	struct drm_device *dev = obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = obj->ring;
	unsigned reset_counter;
	u32 seqno;
	int ret;

	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
	BUG_ON(!dev_priv->mm.interruptible);

	seqno = readonly ? obj->last_write_seqno : obj->last_read_seqno;
	if (seqno == 0)
		return 0;

	ret = i915_gem_check_wedge(&dev_priv->gpu_error, true);
	if (ret)
		return ret;

	ret = i915_gem_check_olr(ring, seqno);
	if (ret)
		return ret;

	reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
	mutex_unlock(&dev->struct_mutex);
	ret = __wait_seqno(ring, seqno, reset_counter, true, NULL, file->driver_priv);
	mutex_lock(&dev->struct_mutex);
	if (ret)
		return ret;

	return i915_gem_object_wait_rendering__tail(obj, ring);
}

/**
 * Called when user space prepares to use an object with the CPU, either
 * through the mmap ioctl's mapping or a GTT mapping.
 */
int
i915_gem_set_domain_ioctl(struct drm_device *dev, void *data,
			  struct drm_file *file)
{
	struct drm_i915_gem_set_domain *args = data;
	struct drm_i915_gem_object *obj;
	uint32_t read_domains = args->read_domains;
	uint32_t write_domain = args->write_domain;
	int ret;

	/* Only handle setting domains to types used by the CPU. */
	if (write_domain & I915_GEM_GPU_DOMAINS)
		return -EINVAL;

	if (read_domains & I915_GEM_GPU_DOMAINS)
		return -EINVAL;

	/* Having something in the write domain implies it's in the read
	 * domain, and only that read domain.  Enforce that in the request.
	 */
	if (write_domain != 0 && read_domains != write_domain)
		return -EINVAL;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	/* Try to flush the object off the GPU without holding the lock.
	 * We will repeat the flush holding the lock in the normal manner
	 * to catch cases where we are gazumped.
	 */
	ret = i915_gem_object_wait_rendering__nonblocking(obj, file, !write_domain);
	if (ret)
		goto unref;

	if (read_domains & I915_GEM_DOMAIN_GTT) {
		ret = i915_gem_object_set_to_gtt_domain(obj, write_domain != 0);

		/* Silently promote "you're not bound, there was nothing to do"
		 * to success, since the client was just asking us to
		 * make sure everything was done.
		 */
		if (ret == -EINVAL)
			ret = 0;
	} else {
		ret = i915_gem_object_set_to_cpu_domain(obj, write_domain != 0);
	}

unref:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

/**
 * Called when user space has done writes to this buffer
 */
int
i915_gem_sw_finish_ioctl(struct drm_device *dev, void *data,
			 struct drm_file *file)
{
	struct drm_i915_gem_sw_finish *args = data;
	struct drm_i915_gem_object *obj;
	int ret = 0;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	/* Pinned buffers may be scanout, so flush the cache */
	if (obj->pin_display)
		i915_gem_object_flush_cpu_write_domain(obj, true);

	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

/**
 * Maps the contents of an object, returning the address it is mapped
 * into.
 *
 * While the mapping holds a reference on the contents of the object, it doesn't
 * imply a ref on the object itself.
 */
int
i915_gem_mmap_ioctl(struct drm_device *dev, void *data,
		    struct drm_file *file)
{
	struct drm_i915_gem_mmap *args = data;
	struct drm_gem_object *obj;
	vaddr_t addr;
	vsize_t size;
	int ret;

	size = round_page(args->size);
	if (size == 0)
		return -EINVAL;

	if (args->offset + size < args->offset)
		return -EINVAL;
	if (args->offset & PAGE_MASK)
		return -EINVAL;

	obj = drm_gem_object_lookup(dev, file, args->handle);
	if (obj == NULL)
		return -ENOENT;

#ifdef notyet
	/* prime objects have no backing filp to GEM mmap
	 * pages from.
	 */
	if (!obj->filp) {
		drm_gem_object_unreference_unlocked(obj);
		return -EINVAL;
	}
#endif

	addr = 0;
	ret = -uvm_map(&curproc->p_vmspace->vm_map, &addr, size,
	    obj->uao, args->offset, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE,
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, MADV_RANDOM, 0));
	if (ret == 0)
		uao_reference(obj->uao);
	drm_gem_object_unreference_unlocked(obj);
	if (ret)
		return ret;

	args->addr_ptr = (uint64_t) addr;

	return 0;
}

int
i915_gem_fault(struct drm_gem_object *gem_obj, struct uvm_faultinfo *ufi,
    off_t offset, vaddr_t vaddr, vm_page_t *pps, int npages, int centeridx,
    vm_prot_t access_type, int flags)
{
	struct drm_i915_gem_object *obj = to_intel_bo(gem_obj);
	struct drm_device *dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	paddr_t paddr;
	int lcv, ret = 0;
	int write = !!(access_type & PROT_WRITE);
	vm_prot_t mapprot;
	boolean_t locked = TRUE;

	intel_runtime_pm_get(dev_priv);

	/*
	 * If we already own the lock, we must be doing a copyin or
	 * copyout in one of the fast paths.  Return failure such that
	 * we fall back on the slow path.
	 */
	if (!drm_vma_node_has_offset(&obj->base.vma_node) ||
	    RWLOCK_OWNER(&dev->struct_mutex) == curproc) {
		uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap,
		    &obj->base.uobj, NULL);
		ret = VM_PAGER_BAD;
		goto out;
	}

	offset -= drm_vma_node_offset_addr(&obj->base.vma_node);

	if (rw_enter(&dev->struct_mutex, RW_NOSLEEP | RW_WRITE) != 0) {
		uvmfault_unlockall(ufi, NULL, &obj->base.uobj, NULL);
		mutex_lock(&dev->struct_mutex);
		locked = uvmfault_relock(ufi);
	}
	if (!locked) {
		mutex_unlock(&dev->struct_mutex);
		ret = VM_PAGER_REFAULT;
		goto out;
	}

	/* Access to snoopable pages through the GTT is incoherent. */
	if (obj->cache_level != I915_CACHE_NONE && !HAS_LLC(dev)) {
		ret = -EINVAL;
		goto unlock;
	}

	/* Now bind it into the GTT if needed */
	ret = i915_gem_obj_ggtt_pin(obj,  0, true, false);
	if (ret)
		goto unlock;

	ret = i915_gem_object_set_to_gtt_domain(obj, write);
	if (ret)
		goto unpin;

	ret = i915_gem_object_get_fence(obj);
	if (ret)
		goto unpin;

	obj->fault_mappable = true;

	mapprot = ufi->entry->protection;
	/*
	 * if it's only a read fault, we only put ourselves into the gtt
	 * read domain, so make sure we fault again and set ourselves to write.
	 * this prevents us needing userland to do domain management and get
	 * it wrong, and makes us fully coherent with the gpu re mmap.
	 */
	if (write == 0)
		mapprot &= ~PROT_WRITE;
	/* XXX try and  be more efficient when we do this */
	for (lcv = 0 ; lcv < npages ; lcv++, offset += PAGE_SIZE,
	    vaddr += PAGE_SIZE) {
		if ((flags & PGO_ALLPAGES) == 0 && lcv != centeridx)
			continue;

		if (pps[lcv] == PGO_DONTCARE)
			continue;

		paddr = dev_priv->gtt.mappable_base +
		    i915_gem_obj_ggtt_offset(obj) + offset;

		if (pmap_enter(ufi->orig_map->pmap, vaddr, paddr,
		    mapprot, PMAP_CANFAIL | mapprot) != 0) {
			i915_gem_object_unpin(obj);
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap,
			    NULL, NULL);
			mutex_unlock(&dev->struct_mutex);
			pmap_update(ufi->orig_map->pmap);
			uvm_wait("intelflt");
			ret = VM_PAGER_REFAULT;
			goto out;
		}
	}
unpin:
	i915_gem_object_unpin(obj);
unlock:
	uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, NULL, NULL);
	mutex_unlock(&dev->struct_mutex);
	pmap_update(ufi->orig_map->pmap);

	switch (ret) {
	case -EIO:
		/*
		 * We eat errors when the gpu is terminally wedged to avoid
		 * userspace unduly crashing (gl has no provisions for mmaps to
		 * fail). But any other -EIO isn't ours (e.g. swap in failure)
		 * and so needs to be reported.
		 */
		if (!i915_terminally_wedged(&dev_priv->gpu_error)) {
			ret = VM_PAGER_ERROR;
			break;
		}
	case -EAGAIN:
		/*
		 * EAGAIN means the gpu is hung and we'll wait for the error
		 * handler to reset everything when re-faulting in
		 * i915_mutex_lock_interruptible.
		 */
	case 0:
	case -ERESTART:
	case -EINTR:
	case -EBUSY:
		/*
		 * EBUSY is ok: this just means that another thread
		 * already did the job.
		 */
		ret = VM_PAGER_OK;
		break;
	case -ENOMEM:
		ret = VM_PAGER_ERROR;
		break;
	case -ENOSPC:
		ret = VM_PAGER_ERROR;
		break;
	default:
		WARN_ONCE(ret, "unhandled error in i915_gem_fault: %i\n", ret);
		ret = VM_PAGER_ERROR;
		break;
	}

out:
	intel_runtime_pm_put(dev_priv);
	return ret;
}

void i915_gem_release_all_mmaps(struct drm_i915_private *dev_priv)
{
	struct i915_vma *vma;

	/*
	 * Only the global gtt is relevant for gtt memory mappings, so restrict
	 * list traversal to objects bound into the global address space. Note
	 * that the active list should be empty, but better safe than sorry.
	 */
	WARN_ON(!list_empty(&dev_priv->gtt.base.active_list));
	list_for_each_entry(vma, &dev_priv->gtt.base.active_list, mm_list)
		i915_gem_release_mmap(vma->obj);
	list_for_each_entry(vma, &dev_priv->gtt.base.inactive_list, mm_list)
		i915_gem_release_mmap(vma->obj);
}

/**
 * i915_gem_release_mmap - remove physical page mappings
 * @@obj: obj in question
 *
 * Preserve the reservation of the mmapping with the DRM core code, but
 * relinquish ownership of the pages back to the system.
 *
 * It is vital that we remove the page mapping if we have mapped a tiled
 * object through the GTT and then lose the fence register due to
 * resource pressure. Similarly if the object has been moved out of the
 * aperture, than pages mapped into userspace must be revoked. Removing the
 * mapping will then trigger a page fault on the next user access, allowing
 * fixup by i915_gem_fault().
 */
void
i915_gem_release_mmap(struct drm_i915_gem_object *obj)
{
	struct inteldrm_softc *dev_priv = obj->base.dev->dev_private;
	struct vm_page *pg;

	if (!obj->fault_mappable)
		return;

	for (pg = &dev_priv->pgs[atop(i915_gem_obj_ggtt_offset(obj))];
	     pg != &dev_priv->pgs[atop(i915_gem_obj_ggtt_offset(obj) + obj->base.size)];
	     pg++)
		pmap_page_protect(pg, PROT_NONE);

	drm_vma_node_unmap(&obj->base.vma_node, obj->base.dev->dev_mapping);
	obj->fault_mappable = false;
}

uint32_t
i915_gem_get_gtt_size(struct drm_device *dev, uint32_t size, int tiling_mode)
{
	uint32_t gtt_size;

	if (INTEL_INFO(dev)->gen >= 4 ||
	    tiling_mode == I915_TILING_NONE)
		return size;

	/* Previous chips need a power-of-two fence region when tiling */
	if (INTEL_INFO(dev)->gen == 3)
		gtt_size = 1024*1024;
	else
		gtt_size = 512*1024;

	while (gtt_size < size)
		gtt_size <<= 1;

	return gtt_size;
}

/**
 * i915_gem_get_gtt_alignment - return required GTT alignment for an object
 * @@obj: object to check
 *
 * Return the required GTT alignment for an object, taking into account
 * potential fence register mapping.
 */
uint32_t
i915_gem_get_gtt_alignment(struct drm_device *dev, uint32_t size,
			   int tiling_mode, bool fenced)
{
	/*
	 * Minimum alignment is 4k (GTT page size), but might be greater
	 * if a fence register is needed for the object.
	 */
	if (INTEL_INFO(dev)->gen >= 4 || (!fenced && IS_G33(dev)) ||
	    tiling_mode == I915_TILING_NONE)
		return 4096;

	/*
	 * Previous chips need to be aligned to the size of the smallest
	 * fence register that can contain the object.
	 */
	return i915_gem_get_gtt_size(dev, size, tiling_mode);
}

static int i915_gem_object_create_mmap_offset(struct drm_i915_gem_object *obj)
{
#if 0
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
#endif
	int ret;

	if (drm_vma_node_has_offset(&obj->base.vma_node))
		return 0;

#if 0
	dev_priv->mm.shrinker_no_lock_stealing = true;
#endif

	ret = drm_gem_create_mmap_offset(&obj->base);
#if 0
	if (ret != -ENOSPC)
		goto out;

	/* Badly fragmented mmap space? The only way we can recover
	 * space is by destroying unwanted objects. We can't randomly release
	 * mmap_offsets as userspace expects them to be persistent for the
	 * lifetime of the objects. The closest we can is to release the
	 * offsets on purgeable objects by truncating it and marking it purged,
	 * which prevents userspace from ever using that object again.
	 */
	i915_gem_purge(dev_priv, obj->base.size >> PAGE_SHIFT);
	ret = drm_gem_create_mmap_offset(&obj->base);
	if (ret != -ENOSPC)
		goto out;

	i915_gem_shrink_all(dev_priv);
	ret = drm_gem_create_mmap_offset(&obj->base);
out:
	dev_priv->mm.shrinker_no_lock_stealing = false;
#endif

	return ret;
}

static void i915_gem_object_free_mmap_offset(struct drm_i915_gem_object *obj)
{
	drm_gem_free_mmap_offset(&obj->base);
}

int
i915_gem_mmap_gtt(struct drm_file *file,
		  struct drm_device *dev,
		  uint32_t handle,
		  uint64_t *offset)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	if (obj->base.size > dev_priv->gtt.mappable_end) {
		ret = -E2BIG;
		goto out;
	}

	if (obj->madv != I915_MADV_WILLNEED) {
		DRM_ERROR("Attempting to mmap a purgeable buffer\n");
		ret = -EINVAL;
		goto out;
	}

	ret = i915_gem_object_create_mmap_offset(obj);
	if (ret)
		goto out;

	*offset = drm_vma_node_offset_addr(&obj->base.vma_node);

out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

/**
 * i915_gem_mmap_gtt_ioctl - prepare an object for GTT mmap'ing
 * @@dev: DRM device
 * @@data: GTT mapping ioctl data
 * @@file: GEM object info
 *
 * Simply returns the fake offset to userspace so it can mmap it.
 * The mmap call will end up in drm_gem_mmap(), which will set things
 * up so we can get faults in the handler above.
 *
 * The fault handler will take care of binding the object into the GTT
 * (since it may have been evicted to make room for something), allocating
 * a fence register, and mapping the appropriate aperture address into
 * userspace.
 */
int
i915_gem_mmap_gtt_ioctl(struct drm_device *dev, void *data,
			struct drm_file *file)
{
	struct drm_i915_gem_mmap_gtt *args = data;

	return i915_gem_mmap_gtt(file, dev, args->handle, &args->offset);
}

/* Immediately discard the backing storage */
static void
i915_gem_object_truncate(struct drm_i915_gem_object *obj)
{
	i915_gem_object_free_mmap_offset(obj);

	obj->base.uao->pgops->pgo_flush(obj->base.uao, 0, obj->base.size,
	    PGO_ALLPAGES | PGO_FREE);

	obj->madv = __I915_MADV_PURGED;
}

static inline int
i915_gem_object_is_purgeable(struct drm_i915_gem_object *obj)
{
	return obj->madv == I915_MADV_DONTNEED;
}

static void
i915_gem_object_put_pages_gtt(struct drm_i915_gem_object *obj)
{
#ifdef __linux__
	struct sg_page_iter sg_iter;
#else
	int i, page_count = obj->base.size / PAGE_SIZE;
#endif
	int ret;

	BUG_ON(obj->madv == __I915_MADV_PURGED);

	ret = i915_gem_object_set_to_cpu_domain(obj, true);
	if (ret) {
		/* In the event of a disaster, abandon all caches and
		 * hope for the best.
		 */
		WARN_ON(ret != -EIO);
		i915_gem_clflush_object(obj, true);
		obj->base.read_domains = obj->base.write_domain = I915_GEM_DOMAIN_CPU;
	}

	if (i915_gem_object_needs_bit17_swizzle(obj))
		i915_gem_object_save_bit_17_swizzle(obj);

	if (obj->madv == I915_MADV_DONTNEED)
		obj->dirty = 0;

#ifdef __linux__
	for_each_sg_page(obj->pages->sgl, &sg_iter, obj->pages->nents, 0) {
		struct page *page = sg_page_iter_page(&sg_iter);

		if (obj->dirty)
			set_page_dirty(page);

		if (obj->madv == I915_MADV_WILLNEED)
			mark_page_accessed(page);

		page_cache_release(page);
	}
#else
	for (i = 0; i < page_count; i++) {
		struct vm_page *page = obj->pages[i];

		if (obj->dirty)
			atomic_clearbits_int(&page->pg_flags, PG_CLEAN);
	}
	uvm_objunwire(obj->base.uao, 0, obj->base.size);
#endif
	obj->dirty = 0;

#ifdef __linux__
	sg_free_table(obj->pages);
#endif
	kfree(obj->pages);
}

int
i915_gem_object_put_pages(struct drm_i915_gem_object *obj)
{
	const struct drm_i915_gem_object_ops *ops = obj->ops;

	if (obj->pages == NULL)
		return 0;

	if (obj->pages_pin_count)
		return -EBUSY;

	BUG_ON(i915_gem_obj_bound_any(obj));

	/* ->put_pages might need to allocate memory for the bit17 swizzle
	 * array, hence protect them from being reaped by removing them from gtt
	 * lists early. */
	list_del(&obj->global_list);

	ops->put_pages(obj);
	obj->pages = NULL;

	if (i915_gem_object_is_purgeable(obj))
		i915_gem_object_truncate(obj);

	return 0;
}

#ifdef notyet
static unsigned long
__i915_gem_shrink(struct drm_i915_private *dev_priv, long target,
		  bool purgeable_only)
{
	struct list_head still_bound_list;
	struct drm_i915_gem_object *obj, *next;
	unsigned long count = 0;

	list_for_each_entry_safe(obj, next,
				 &dev_priv->mm.unbound_list,
				 global_list) {
		if ((i915_gem_object_is_purgeable(obj) || !purgeable_only) &&
		    i915_gem_object_put_pages(obj) == 0) {
			count += obj->base.size >> PAGE_SHIFT;
			if (count >= target)
				return count;
		}
	}

	/*
	 * As we may completely rewrite the bound list whilst unbinding
	 * (due to retiring requests) we have to strictly process only
	 * one element of the list at the time, and recheck the list
	 * on every iteration.
	 */
	INIT_LIST_HEAD(&still_bound_list);
	while (count < target && !list_empty(&dev_priv->mm.bound_list)) {
		struct i915_vma *vma, *v;

		obj = list_first_entry(&dev_priv->mm.bound_list,
				       typeof(*obj), global_list);
		list_move_tail(&obj->global_list, &still_bound_list);

		if (!i915_gem_object_is_purgeable(obj) && purgeable_only)
			continue;

		/*
		 * Hold a reference whilst we unbind this object, as we may
		 * end up waiting for and retiring requests. This might
		 * release the final reference (held by the active list)
		 * and result in the object being freed from under us.
		 * in this object being freed.
		 *
		 * Note 1: Shrinking the bound list is special since only active
		 * (and hence bound objects) can contain such limbo objects, so
		 * we don't need special tricks for shrinking the unbound list.
		 * The only other place where we have to be careful with active
		 * objects suddenly disappearing due to retiring requests is the
		 * eviction code.
		 *
		 * Note 2: Even though the bound list doesn't hold a reference
		 * to the object we can safely grab one here: The final object
		 * unreferencing and the bound_list are both protected by the
		 * dev->struct_mutex and so we won't ever be able to observe an
		 * object on the bound_list with a reference count equals 0.
		 */
		drm_gem_object_reference(&obj->base);

		list_for_each_entry_safe(vma, v, &obj->vma_list, vma_link)
			if (i915_vma_unbind(vma))
				break;

		if (i915_gem_object_put_pages(obj) == 0)
			count += obj->base.size >> PAGE_SHIFT;

		drm_gem_object_unreference(&obj->base);
	}
	list_splice(&still_bound_list, &dev_priv->mm.bound_list);

	return count;
}

static unsigned long
i915_gem_purge(struct drm_i915_private *dev_priv, long target)
{
	return __i915_gem_shrink(dev_priv, target, true);
}

static unsigned long
i915_gem_shrink_all(struct drm_i915_private *dev_priv)
{
	struct drm_i915_gem_object *obj, *next;
	long freed = 0;

	i915_gem_evict_everything(dev_priv->dev);

	list_for_each_entry_safe(obj, next, &dev_priv->mm.unbound_list,
				 global_list) {
		if (i915_gem_object_put_pages(obj) == 0)
			freed += obj->base.size >> PAGE_SHIFT;
	}
	return freed;
}
#endif /* notyet */

static int
i915_gem_object_get_pages_gtt(struct drm_i915_gem_object *obj)
{
#ifdef __linux__
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	int page_count, i;
	struct address_space *mapping;
	struct sg_table *st;
	struct scatterlist *sg;
	struct sg_page_iter sg_iter;
	struct page *page;
	unsigned long last_pfn = 0;	/* suppress gcc warning */
	gfp_t gfp;
#else
	int page_count, i;
	struct vm_page **st;
	struct pglist plist;
	struct vm_page *page;
#endif

	/* Assert that the object is not currently in any GPU domain. As it
	 * wasn't in the GTT, there shouldn't be any way it could have been in
	 * a GPU cache
	 */
	BUG_ON(obj->base.read_domains & I915_GEM_GPU_DOMAINS);
	BUG_ON(obj->base.write_domain & I915_GEM_GPU_DOMAINS);

#ifdef __linux__
	st = kmalloc(sizeof(*st), GFP_KERNEL);
	if (st == NULL)
		return -ENOMEM;

	page_count = obj->base.size / PAGE_SIZE;
	if (sg_alloc_table(st, page_count, GFP_KERNEL)) {
		kfree(st);
		return -ENOMEM;
	}

	/* Get the list of pages out of our struct file.  They'll be pinned
	 * at this point until we release them.
	 *
	 * Fail silently without starting the shrinker
	 */
	mapping = file_inode(obj->base.filp)->i_mapping;
	gfp = mapping_gfp_mask(mapping);
	gfp |= __GFP_NORETRY | __GFP_NOWARN | __GFP_NO_KSWAPD;
	gfp &= ~(__GFP_IO | __GFP_WAIT);
	sg = st->sgl;
	st->nents = 0;
	for (i = 0; i < page_count; i++) {
		page = shmem_read_mapping_page_gfp(mapping, i, gfp);
		if (IS_ERR(page)) {
			i915_gem_purge(dev_priv, page_count);
			page = shmem_read_mapping_page_gfp(mapping, i, gfp);
		}
		if (IS_ERR(page)) {
			/* We've tried hard to allocate the memory by reaping
			 * our own buffer, now let the real VM do its job and
			 * go down in flames if truly OOM.
			 */
			gfp &= ~(__GFP_NORETRY | __GFP_NOWARN | __GFP_NO_KSWAPD);
			gfp |= __GFP_IO | __GFP_WAIT;

			i915_gem_shrink_all(dev_priv);
			page = shmem_read_mapping_page_gfp(mapping, i, gfp);
			if (IS_ERR(page))
				goto err_pages;

			gfp |= __GFP_NORETRY | __GFP_NOWARN | __GFP_NO_KSWAPD;
			gfp &= ~(__GFP_IO | __GFP_WAIT);
		}
#ifdef CONFIG_SWIOTLB
		if (swiotlb_nr_tbl()) {
			st->nents++;
			sg_set_page(sg, page, PAGE_SIZE, 0);
			sg = sg_next(sg);
			continue;
		}
#endif
		if (!i || page_to_pfn(page) != last_pfn + 1) {
			if (i)
				sg = sg_next(sg);
			st->nents++;
			sg_set_page(sg, page, PAGE_SIZE, 0);
		} else {
			sg->length += PAGE_SIZE;
		}
		last_pfn = page_to_pfn(page);

		/* Check that the i965g/gm workaround works. */
		WARN_ON((gfp & __GFP_DMA32) && (last_pfn >= 0x00100000UL));
	}
#ifdef CONFIG_SWIOTLB
	if (!swiotlb_nr_tbl())
#endif
		sg_mark_end(sg);
	obj->pages = st;
#else
	page_count = obj->base.size / PAGE_SIZE;
	st = malloc(page_count * sizeof(struct vm_page *), M_DRM,
	    M_WAITOK | M_CANFAIL);
	if (st == NULL)
		return -ENOMEM;

	TAILQ_INIT(&plist);
	if (uvm_objwire(obj->base.uao, 0, obj->base.size, &plist))
		goto err_pages;

	i = 0;
	TAILQ_FOREACH(page, &plist, pageq) {
		st[i] = page;
		i++;
	}
	obj->pages = st;
#endif

	if (i915_gem_object_needs_bit17_swizzle(obj))
		i915_gem_object_do_bit_17_swizzle(obj);

	return 0;

#ifdef __linux__
err_pages:
	sg_mark_end(sg);
	for_each_sg_page(st->sgl, &sg_iter, st->nents, 0)
		page_cache_release(sg_page_iter_page(&sg_iter));
	sg_free_table(st);
	kfree(st);
	return PTR_ERR(page);
#else
err_pages:
	free(st, M_DRM, 0);
	return -ENOMEM;
#endif
}

/* Ensure that the associated pages are gathered from the backing storage
 * and pinned into our object. i915_gem_object_get_pages() may be called
 * multiple times before they are released by a single call to
 * i915_gem_object_put_pages() - once the pages are no longer referenced
 * either as a result of memory pressure (reaping pages under the shrinker)
 * or as the object is itself released.
 */
int
i915_gem_object_get_pages(struct drm_i915_gem_object *obj)
{
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	const struct drm_i915_gem_object_ops *ops = obj->ops;
	int ret;

	if (obj->pages)
		return 0;

	if (obj->madv != I915_MADV_WILLNEED) {
		DRM_ERROR("Attempting to obtain a purgeable object\n");
		return -EINVAL;
	}

	BUG_ON(obj->pages_pin_count);

	ret = ops->get_pages(obj);
	if (ret)
		return ret;

	list_add_tail(&obj->global_list, &dev_priv->mm.unbound_list);
	return 0;
}

static void
i915_gem_object_move_to_active(struct drm_i915_gem_object *obj,
			       struct intel_ring_buffer *ring)
{
	struct drm_device *dev = obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u32 seqno = intel_ring_get_seqno(ring);

	BUG_ON(ring == NULL);
	if (obj->ring != ring && obj->last_write_seqno) {
		/* Keep the seqno relative to the current ring */
		obj->last_write_seqno = seqno;
	}
	obj->ring = ring;

	/* Add a reference if we're newly entering the active list. */
	if (!obj->active) {
		drm_gem_object_reference(&obj->base);
		obj->active = 1;
	}

	list_move_tail(&obj->ring_list, &ring->active_list);

	obj->last_read_seqno = seqno;

	if (obj->fenced_gpu_access) {
		obj->last_fenced_seqno = seqno;

		/* Bump MRU to take account of the delayed flush */
		if (obj->fence_reg != I915_FENCE_REG_NONE) {
			struct drm_i915_fence_reg *reg;

			reg = &dev_priv->fence_regs[obj->fence_reg];
			list_move_tail(&reg->lru_list,
				       &dev_priv->mm.fence_list);
		}
	}
}

void i915_vma_move_to_active(struct i915_vma *vma,
			     struct intel_ring_buffer *ring)
{
	list_move_tail(&vma->mm_list, &vma->vm->active_list);
	return i915_gem_object_move_to_active(vma->obj, ring);
}

static void
i915_gem_object_move_to_inactive(struct drm_i915_gem_object *obj)
{
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	struct i915_address_space *ggtt_vm = &dev_priv->gtt.base;
	struct i915_vma *vma = i915_gem_obj_to_vma(obj, ggtt_vm);

	BUG_ON(obj->base.write_domain & ~I915_GEM_GPU_DOMAINS);
	BUG_ON(!obj->active);

	list_move_tail(&vma->mm_list, &ggtt_vm->inactive_list);

	list_del_init(&obj->ring_list);
	obj->ring = NULL;

	obj->last_read_seqno = 0;
	obj->last_write_seqno = 0;
	obj->base.write_domain = 0;

	obj->last_fenced_seqno = 0;
	obj->fenced_gpu_access = false;

	obj->active = 0;
	drm_gem_object_unreference(&obj->base);

	WARN_ON(i915_verify_lists(dev));
}

static int
i915_gem_init_seqno(struct drm_device *dev, u32 seqno)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	int ret, i, j;

	/* Carefully retire all requests without writing to the rings */
	for_each_ring(ring, dev_priv, i) {
		ret = intel_ring_idle(ring);
		if (ret)
			return ret;
	}
	i915_gem_retire_requests(dev);

	/* Finally reset hw state */
	for_each_ring(ring, dev_priv, i) {
		intel_ring_init_seqno(ring, seqno);

		for (j = 0; j < ARRAY_SIZE(ring->sync_seqno); j++)
			ring->sync_seqno[j] = 0;
	}

	return 0;
}

int i915_gem_set_seqno(struct drm_device *dev, u32 seqno)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	if (seqno == 0)
		return -EINVAL;

	/* HWS page needs to be set less than what we
	 * will inject to ring
	 */
	ret = i915_gem_init_seqno(dev, seqno - 1);
	if (ret)
		return ret;

	/* Carefully set the last_seqno value so that wrap
	 * detection still works
	 */
	dev_priv->next_seqno = seqno;
	dev_priv->last_seqno = seqno - 1;
	if (dev_priv->last_seqno == 0)
		dev_priv->last_seqno--;

	return 0;
}

int
i915_gem_get_seqno(struct drm_device *dev, u32 *seqno)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* reserve 0 for non-seqno */
	if (dev_priv->next_seqno == 0) {
		int ret = i915_gem_init_seqno(dev, 0);
		if (ret)
			return ret;

		dev_priv->next_seqno = 1;
	}

	*seqno = dev_priv->last_seqno = dev_priv->next_seqno++;
	return 0;
}

int __i915_add_request(struct intel_ring_buffer *ring,
		       struct drm_file *file,
		       struct drm_i915_gem_object *obj,
		       u32 *out_seqno)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	struct drm_i915_gem_request *request;
	u32 request_ring_position, request_start;
	int was_empty;
	int ret;

	request_start = intel_ring_get_tail(ring);
	/*
	 * Emit any outstanding flushes - execbuf can fail to emit the flush
	 * after having emitted the batchbuffer command. Hence we need to fix
	 * things up similar to emitting the lazy request. The difference here
	 * is that the flush _must_ happen before the next request, no matter
	 * what.
	 */
	ret = intel_ring_flush_all_caches(ring);
	if (ret)
		return ret;

	request = ring->preallocated_lazy_request;
	if (WARN_ON(request == NULL))
		return -ENOMEM;

	/* Record the position of the start of the request so that
	 * should we detect the updated seqno part-way through the
	 * GPU processing the request, we never over-estimate the
	 * position of the head.
	 */
	request_ring_position = intel_ring_get_tail(ring);

	ret = ring->add_request(ring);
	if (ret)
		return ret;

	request->seqno = intel_ring_get_seqno(ring);
	request->ring = ring;
	request->head = request_start;
	request->tail = request_ring_position;

	/* Whilst this request exists, batch_obj will be on the
	 * active_list, and so will hold the active reference. Only when this
	 * request is retired will the the batch_obj be moved onto the
	 * inactive_list and lose its active reference. Hence we do not need
	 * to explicitly hold another reference here.
	 */
	request->batch_obj = obj;

	/* Hold a reference to the current context so that we can inspect
	 * it later in case a hangcheck error event fires.
	 */
	request->ctx = ring->last_context;
	if (request->ctx)
		i915_gem_context_reference(request->ctx);

	request->emitted_jiffies = jiffies;
	was_empty = list_empty(&ring->request_list);
	list_add_tail(&request->list, &ring->request_list);
	request->file_priv = NULL;

	if (file) {
		struct drm_i915_file_private *file_priv = file->driver_priv;

		spin_lock(&file_priv->mm.lock);
		request->file_priv = file_priv;
		list_add_tail(&request->client_list,
			      &file_priv->mm.request_list);
		spin_unlock(&file_priv->mm.lock);
	}

	trace_i915_gem_request_add(ring, request->seqno);
	ring->outstanding_lazy_seqno = 0;
	ring->preallocated_lazy_request = NULL;

	if (!dev_priv->ums.mm_suspended) {
		i915_queue_hangcheck(ring->dev);

		if (was_empty) {
			cancel_delayed_work_sync(&dev_priv->mm.idle_work);
			queue_delayed_work(dev_priv->wq,
					   &dev_priv->mm.retire_work,
					   round_jiffies_up_relative(HZ));
			intel_mark_busy(dev_priv->dev);
		}
	}

	if (out_seqno)
		*out_seqno = request->seqno;
	return 0;
}

static inline void
i915_gem_request_remove_from_client(struct drm_i915_gem_request *request)
{
	struct drm_i915_file_private *file_priv = request->file_priv;

	if (!file_priv)
		return;

	spin_lock(&file_priv->mm.lock);
	list_del(&request->client_list);
	request->file_priv = NULL;
	spin_unlock(&file_priv->mm.lock);
}

static bool i915_head_inside_object(u32 acthd, struct drm_i915_gem_object *obj,
				    struct i915_address_space *vm)
{
	if (acthd >= i915_gem_obj_offset(obj, vm) &&
	    acthd < i915_gem_obj_offset(obj, vm) + obj->base.size)
		return true;

	return false;
}

static bool i915_head_inside_request(const u32 acthd_unmasked,
				     const u32 request_start,
				     const u32 request_end)
{
	const u32 acthd = acthd_unmasked & HEAD_ADDR;

	if (request_start < request_end) {
		if (acthd >= request_start && acthd < request_end)
			return true;
	} else if (request_start > request_end) {
		if (acthd >= request_start || acthd < request_end)
			return true;
	}

	return false;
}

static struct i915_address_space *
request_to_vm(struct drm_i915_gem_request *request)
{
	struct drm_i915_private *dev_priv = request->ring->dev->dev_private;
	struct i915_address_space *vm;

	vm = &dev_priv->gtt.base;

	return vm;
}

static bool i915_request_guilty(struct drm_i915_gem_request *request,
				const u32 acthd, bool *inside)
{
	/* There is a possibility that unmasked head address
	 * pointing inside the ring, matches the batch_obj address range.
	 * However this is extremely unlikely.
	 */
	if (request->batch_obj) {
		if (i915_head_inside_object(acthd, request->batch_obj,
					    request_to_vm(request))) {
			*inside = true;
			return true;
		}
	}

	if (i915_head_inside_request(acthd, request->head, request->tail)) {
		*inside = false;
		return true;
	}

	return false;
}

static bool i915_context_is_banned(const struct i915_ctx_hang_stats *hs)
{
	const unsigned long elapsed = get_seconds() - hs->guilty_ts;

	if (hs->banned)
		return true;

	if (elapsed <= DRM_I915_CTX_BAN_PERIOD) {
		DRM_ERROR("context hanging too fast, declaring banned!\n");
		return true;
	}

	return false;
}

static void i915_set_reset_status(struct intel_ring_buffer *ring,
				  struct drm_i915_gem_request *request,
				  u32 acthd)
{
	struct i915_ctx_hang_stats *hs = NULL;
	bool inside, guilty;
	unsigned long offset = 0;

	/* Innocent until proven guilty */
	guilty = false;

	if (request->batch_obj)
		offset = i915_gem_obj_offset(request->batch_obj,
					     request_to_vm(request));

	if (ring->hangcheck.action != HANGCHECK_WAIT &&
	    i915_request_guilty(request, acthd, &inside)) {
		DRM_DEBUG("%s hung %s bo (0x%lx ctx %d) at 0x%x\n",
			  ring->name,
			  inside ? "inside" : "flushing",
			  offset,
			  request->ctx ? request->ctx->id : 0,
			  acthd);

		guilty = true;
	}

	/* If contexts are disabled or this is the default context, use
	 * file_priv->reset_state
	 */
	if (request->ctx && request->ctx->id != DEFAULT_CONTEXT_ID)
		hs = &request->ctx->hang_stats;
	else if (request->file_priv)
		hs = &request->file_priv->hang_stats;

	if (hs) {
		if (guilty) {
			hs->banned = i915_context_is_banned(hs);
			hs->batch_active++;
			hs->guilty_ts = get_seconds();
		} else {
			hs->batch_pending++;
		}
	}
}

static void i915_gem_free_request(struct drm_i915_gem_request *request)
{
	list_del(&request->list);
	i915_gem_request_remove_from_client(request);

	if (request->ctx)
		i915_gem_context_unreference(request->ctx);

	kfree(request);
}

static void i915_gem_reset_ring_status(struct drm_i915_private *dev_priv,
				       struct intel_ring_buffer *ring)
{
	u32 completed_seqno = ring->get_seqno(ring, false);
	u32 acthd = intel_ring_get_active_head(ring);
	struct drm_i915_gem_request *request;

	list_for_each_entry(request, &ring->request_list, list) {
		if (i915_seqno_passed(completed_seqno, request->seqno))
			continue;

		i915_set_reset_status(ring, request, acthd);
	}
}

static void i915_gem_reset_ring_cleanup(struct drm_i915_private *dev_priv,
					struct intel_ring_buffer *ring)
{
	while (!list_empty(&ring->active_list)) {
		struct drm_i915_gem_object *obj;

		obj = list_first_entry(&ring->active_list,
				       struct drm_i915_gem_object,
				       ring_list);

		i915_gem_object_move_to_inactive(obj);
	}

	/*
	 * We must free the requests after all the corresponding objects have
	 * been moved off active lists. Which is the same order as the normal
	 * retire_requests function does. This is important if object hold
	 * implicit references on things like e.g. ppgtt address spaces through
	 * the request.
	 */
	while (!list_empty(&ring->request_list)) {
		struct drm_i915_gem_request *request;

		request = list_first_entry(&ring->request_list,
					   struct drm_i915_gem_request,
					   list);

		i915_gem_free_request(request);
	}
}

void i915_gem_restore_fences(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int i;

	for (i = 0; i < dev_priv->num_fence_regs; i++) {
		struct drm_i915_fence_reg *reg = &dev_priv->fence_regs[i];

		/*
		 * Commit delayed tiling changes if we have an object still
		 * attached to the fence, otherwise just clear the fence.
		 */
		if (reg->obj) {
			i915_gem_object_update_fence(reg->obj, reg,
						     reg->obj->tiling_mode);
		} else {
			i915_gem_write_fence(dev, i, NULL);
		}
	}
}

void i915_gem_reset(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	int i;

	/*
	 * Before we free the objects from the requests, we need to inspect
	 * them for finding the guilty party. As the requests only borrow
	 * their reference to the objects, the inspection must be done first.
	 */
	for_each_ring(ring, dev_priv, i)
		i915_gem_reset_ring_status(dev_priv, ring);

	for_each_ring(ring, dev_priv, i)
		i915_gem_reset_ring_cleanup(dev_priv, ring);

	i915_gem_cleanup_ringbuffer(dev);

	i915_gem_restore_fences(dev);
}

/**
 * This function clears the request list as sequence numbers are passed.
 */
void
i915_gem_retire_requests_ring(struct intel_ring_buffer *ring)
{
	uint32_t seqno;

	if (list_empty(&ring->request_list))
		return;

	WARN_ON(i915_verify_lists(ring->dev));

	seqno = ring->get_seqno(ring, true);

	while (!list_empty(&ring->request_list)) {
		struct drm_i915_gem_request *request;

		request = list_first_entry(&ring->request_list,
					   struct drm_i915_gem_request,
					   list);

		if (!i915_seqno_passed(seqno, request->seqno))
			break;

		trace_i915_gem_request_retire(ring, request->seqno);
		/* We know the GPU must have read the request to have
		 * sent us the seqno + interrupt, so use the position
		 * of tail of the request to update the last known position
		 * of the GPU head.
		 */
		ring->last_retired_head = request->tail;

		i915_gem_free_request(request);
	}

	/* Move any buffers on the active list that are no longer referenced
	 * by the ringbuffer to the flushing/inactive lists as appropriate.
	 */
	while (!list_empty(&ring->active_list)) {
		struct drm_i915_gem_object *obj;

		obj = list_first_entry(&ring->active_list,
				      struct drm_i915_gem_object,
				      ring_list);

		if (!i915_seqno_passed(seqno, obj->last_read_seqno))
			break;

		i915_gem_object_move_to_inactive(obj);
	}

	if (unlikely(ring->trace_irq_seqno &&
		     i915_seqno_passed(seqno, ring->trace_irq_seqno))) {
		ring->irq_put(ring);
		ring->trace_irq_seqno = 0;
	}

	WARN_ON(i915_verify_lists(ring->dev));
}

bool
i915_gem_retire_requests(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	bool idle = true;
	int i;

	for_each_ring(ring, dev_priv, i) {
		i915_gem_retire_requests_ring(ring);
		idle &= list_empty(&ring->request_list);
	}

	if (idle)
		mod_delayed_work(dev_priv->wq,
				   &dev_priv->mm.idle_work,
				   msecs_to_jiffies(100));

	return idle;
}

static void
i915_gem_retire_work_handler(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, typeof(*dev_priv), mm.retire_work.work);
	struct drm_device *dev = dev_priv->dev;
	bool idle;

	/* Come back later if the device is busy... */
	idle = false;
	if (mutex_trylock(&dev->struct_mutex)) {
		idle = i915_gem_retire_requests(dev);
		mutex_unlock(&dev->struct_mutex);
	}
	if (!idle)
		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work,
				   round_jiffies_up_relative(HZ));
}

static void
i915_gem_idle_work_handler(struct work_struct *work)
{
	struct drm_i915_private *dev_priv =
		container_of(work, typeof(*dev_priv), mm.idle_work.work);

	intel_mark_idle(dev_priv->dev);
}

/**
 * Ensures that an object will eventually get non-busy by flushing any required
 * write domains, emitting any outstanding lazy request and retiring and
 * completed requests.
 */
static int
i915_gem_object_flush_active(struct drm_i915_gem_object *obj)
{
	int ret;

	if (obj->active) {
		ret = i915_gem_check_olr(obj->ring, obj->last_read_seqno);
		if (ret)
			return ret;

		i915_gem_retire_requests_ring(obj->ring);
	}

	return 0;
}

/**
 * i915_gem_wait_ioctl - implements DRM_IOCTL_I915_GEM_WAIT
 * @@DRM_IOCTL_ARGS: standard ioctl arguments
 *
 * Returns 0 if successful, else an error is returned with the remaining time in
 * the timeout parameter.
 *  -ETIME: object is still busy after timeout
 *  -ERESTARTSYS: signal interrupted the wait
 *  -ENONENT: object doesn't exist
 * Also possible, but rare:
 *  -EAGAIN: GPU wedged
 *  -ENOMEM: damn
 *  -ENODEV: Internal IRQ fail
 *  -E?: The add request failed
 *
 * The wait ioctl with a timeout of 0 reimplements the busy ioctl. With any
 * non-zero timeout parameter the wait ioctl will wait for the given number of
 * nanoseconds on an object becoming unbusy. Since the wait itself does so
 * without holding struct_mutex the object may become re-busied before this
 * function completes. A similar but shorter * race condition exists in the busy
 * ioctl
 */
int
i915_gem_wait_ioctl(struct drm_device *dev, void *data, struct drm_file *file)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_i915_gem_wait *args = data;
	struct drm_i915_gem_object *obj;
	struct intel_ring_buffer *ring = NULL;
	struct timespec timeout_stack, *timeout = NULL;
	unsigned reset_counter;
	u32 seqno = 0;
	int ret = 0;

	if (args->timeout_ns >= 0) {
		timeout_stack = ns_to_timespec(args->timeout_ns);
		timeout = &timeout_stack;
	}

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->bo_handle));
	if (&obj->base == NULL) {
		mutex_unlock(&dev->struct_mutex);
		return -ENOENT;
	}

	/* Need to make sure the object gets inactive eventually. */
	ret = i915_gem_object_flush_active(obj);
	if (ret)
		goto out;

	if (obj->active) {
		seqno = obj->last_read_seqno;
		ring = obj->ring;
	}

	if (seqno == 0)
		 goto out;

	/* Do this after OLR check to make sure we make forward progress polling
	 * on this IOCTL with a 0 timeout (like busy ioctl)
	 */
	if (!args->timeout_ns) {
		ret = -ETIME;
		goto out;
	}

	drm_gem_object_unreference(&obj->base);
	reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
	mutex_unlock(&dev->struct_mutex);

	ret = __wait_seqno(ring, seqno, reset_counter, true, timeout, file->driver_priv);
	if (timeout)
		args->timeout_ns = timespec_to_ns(timeout);
	return ret;

out:
	drm_gem_object_unreference(&obj->base);
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

/**
 * i915_gem_object_sync - sync an object to a ring.
 *
 * @@obj: object which may be in use on another ring.
 * @@to: ring we wish to use the object on. May be NULL.
 *
 * This code is meant to abstract object synchronization with the GPU.
 * Calling with NULL implies synchronizing the object with the CPU
 * rather than a particular GPU ring.
 *
 * Returns 0 if successful, else propagates up the lower layer error.
 */
int
i915_gem_object_sync(struct drm_i915_gem_object *obj,
		     struct intel_ring_buffer *to)
{
	struct intel_ring_buffer *from = obj->ring;
	u32 seqno;
	int ret, idx;

	if (from == NULL || to == from)
		return 0;

	if (to == NULL || !i915_semaphore_is_enabled(obj->base.dev))
		return i915_gem_object_wait_rendering(obj, false);

	idx = intel_ring_sync_index(from, to);

	seqno = obj->last_read_seqno;
	if (seqno <= from->sync_seqno[idx])
		return 0;

	ret = i915_gem_check_olr(obj->ring, seqno);
	if (ret)
		return ret;

	trace_i915_gem_ring_sync_to(from, to, seqno);
	ret = to->sync_to(to, from, seqno);
	if (!ret)
		/* We use last_read_seqno because sync_to()
		 * might have just caused seqno wrap under
		 * the radar.
		 */
		from->sync_seqno[idx] = obj->last_read_seqno;

	return ret;
}

static void i915_gem_object_finish_gtt(struct drm_i915_gem_object *obj)
{
	u32 old_write_domain, old_read_domains;

	/* Force a pagefault for domain tracking on next user access */
	i915_gem_release_mmap(obj);

	if ((obj->base.read_domains & I915_GEM_DOMAIN_GTT) == 0)
		return;

	/* Wait for any direct GTT access to complete */
	mb();

	old_read_domains = obj->base.read_domains;
	old_write_domain = obj->base.write_domain;

	obj->base.read_domains &= ~I915_GEM_DOMAIN_GTT;
	obj->base.write_domain &= ~I915_GEM_DOMAIN_GTT;

	trace_i915_gem_object_change_domain(obj,
					    old_read_domains,
					    old_write_domain);
}

int i915_vma_unbind(struct i915_vma *vma)
{
	struct drm_i915_gem_object *obj = vma->obj;
	drm_i915_private_t *dev_priv = obj->base.dev->dev_private;
	int ret;

	/* For now we only ever use 1 vma per object */
	WARN_ON(!list_is_singular(&obj->vma_list));

	if (list_empty(&vma->vma_link))
		return 0;

	if (!drm_mm_node_allocated(&vma->node)) {
		i915_gem_vma_destroy(vma);

		return 0;
	}

	if (obj->pin_count)
		return -EBUSY;

	BUG_ON(obj->pages == NULL);

	ret = i915_gem_object_finish_gpu(obj);
	if (ret)
		return ret;
	/* Continue on if we fail due to EIO, the GPU is hung so we
	 * should be safe and we need to cleanup or else we might
	 * cause memory corruption through use-after-free.
	 */

	i915_gem_object_finish_gtt(obj);

	/* release the fence reg _after_ flushing */
	ret = i915_gem_object_put_fence(obj);
	if (ret)
		return ret;

	trace_i915_vma_unbind(vma);

	if (obj->has_global_gtt_mapping)
		i915_gem_gtt_unbind_object(obj);
	if (obj->has_aliasing_ppgtt_mapping) {
		i915_ppgtt_unbind_object(dev_priv->mm.aliasing_ppgtt, obj);
		obj->has_aliasing_ppgtt_mapping = 0;
	}
	i915_gem_gtt_finish_object(obj);

	list_del(&vma->mm_list);
	/* Avoid an unnecessary call to unbind on rebind. */
	if (i915_is_ggtt(vma->vm))
		obj->map_and_fenceable = true;

	drm_mm_remove_node(&vma->node);
	i915_gem_vma_destroy(vma);

	/* Since the unbound list is global, only move to that list if
	 * no more VMAs exist. */
	if (list_empty(&obj->vma_list))
		list_move_tail(&obj->global_list, &dev_priv->mm.unbound_list);

	/* And finally now the object is completely decoupled from this vma,
	 * we can drop its hold on the backing storage and allow it to be
	 * reaped by the shrinker.
	 */
	i915_gem_object_unpin_pages(obj);
	/* XXX Until we've hooked up the shrinking functions. */
	i915_gem_object_put_pages(obj);

	return 0;
}

/**
 * Unbinds an object from the global GTT aperture.
 */
int
i915_gem_object_ggtt_unbind(struct drm_i915_gem_object *obj)
{
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	struct i915_address_space *ggtt = &dev_priv->gtt.base;

	if (!i915_gem_obj_ggtt_bound(obj))
		return 0;

	if (obj->pin_count)
		return -EBUSY;

	BUG_ON(obj->pages == NULL);

	return i915_vma_unbind(i915_gem_obj_to_vma(obj, ggtt));
}

int i915_gpu_idle(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	int ret, i;

	/* Flush everything onto the inactive list. */
	for_each_ring(ring, dev_priv, i) {
		ret = i915_switch_context(ring, NULL, DEFAULT_CONTEXT_ID);
		if (ret)
			return ret;

		ret = intel_ring_idle(ring);
		if (ret)
			return ret;
	}

	return 0;
}

static void i965_write_fence_reg(struct drm_device *dev, int reg,
				 struct drm_i915_gem_object *obj)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	int fence_reg;
	int fence_pitch_shift;

	if (INTEL_INFO(dev)->gen >= 6) {
		fence_reg = FENCE_REG_SANDYBRIDGE_0;
		fence_pitch_shift = SANDYBRIDGE_FENCE_PITCH_SHIFT;
	} else {
		fence_reg = FENCE_REG_965_0;
		fence_pitch_shift = I965_FENCE_PITCH_SHIFT;
	}

	fence_reg += reg * 8;

	/* To w/a incoherency with non-atomic 64-bit register updates,
	 * we split the 64-bit update into two 32-bit writes. In order
	 * for a partial fence not to be evaluated between writes, we
	 * precede the update with write to turn off the fence register,
	 * and only enable the fence as the last step.
	 *
	 * For extra levels of paranoia, we make sure each step lands
	 * before applying the next step.
	 */
	I915_WRITE(fence_reg, 0);
	POSTING_READ(fence_reg);

	if (obj) {
		u32 size = i915_gem_obj_ggtt_size(obj);
		uint64_t val;

		/* Adjust fence size to match tiled area */
		if (obj->tiling_mode != I915_TILING_NONE) {
			uint32_t row_size = obj->stride *
				(obj->tiling_mode == I915_TILING_Y ? 32 : 8);
			size = (size / row_size) * row_size;
		}

		val = (uint64_t)((i915_gem_obj_ggtt_offset(obj) + size - 4096) &
				 0xfffff000) << 32;
		val |= i915_gem_obj_ggtt_offset(obj) & 0xfffff000;
		val |= (uint64_t)((obj->stride / 128) - 1) << fence_pitch_shift;
		if (obj->tiling_mode == I915_TILING_Y)
			val |= 1 << I965_FENCE_TILING_Y_SHIFT;
		val |= I965_FENCE_REG_VALID;

		I915_WRITE(fence_reg + 4, val >> 32);
		POSTING_READ(fence_reg + 4);

		I915_WRITE(fence_reg + 0, val);
		POSTING_READ(fence_reg);
	} else {
		I915_WRITE(fence_reg + 4, 0);
		POSTING_READ(fence_reg + 4);
	}
}

static void i915_write_fence_reg(struct drm_device *dev, int reg,
				 struct drm_i915_gem_object *obj)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	u32 val;

	if (obj) {
		u32 size = i915_gem_obj_ggtt_size(obj);
		int pitch_val;
		int tile_width;

		WARN((i915_gem_obj_ggtt_offset(obj) & ~I915_FENCE_START_MASK) ||
		     (size & -size) != size ||
		     (i915_gem_obj_ggtt_offset(obj) & (size - 1)),
		     "object 0x%08lx [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n",
		     i915_gem_obj_ggtt_offset(obj), obj->map_and_fenceable, size);

		if (obj->tiling_mode == I915_TILING_Y && HAS_128_BYTE_Y_TILING(dev))
			tile_width = 128;
		else
			tile_width = 512;

		/* Note: pitch better be a power of two tile widths */
		pitch_val = obj->stride / tile_width;
		pitch_val = ffs(pitch_val) - 1;

		val = i915_gem_obj_ggtt_offset(obj);
		if (obj->tiling_mode == I915_TILING_Y)
			val |= 1 << I830_FENCE_TILING_Y_SHIFT;
		val |= I915_FENCE_SIZE_BITS(size);
		val |= pitch_val << I830_FENCE_PITCH_SHIFT;
		val |= I830_FENCE_REG_VALID;
	} else
		val = 0;

	if (reg < 8)
		reg = FENCE_REG_830_0 + reg * 4;
	else
		reg = FENCE_REG_945_8 + (reg - 8) * 4;

	I915_WRITE(reg, val);
	POSTING_READ(reg);
}

static void i830_write_fence_reg(struct drm_device *dev, int reg,
				struct drm_i915_gem_object *obj)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	uint32_t val;

	if (obj) {
		u32 size = i915_gem_obj_ggtt_size(obj);
		uint32_t pitch_val;

		WARN((i915_gem_obj_ggtt_offset(obj) & ~I830_FENCE_START_MASK) ||
		     (size & -size) != size ||
		     (i915_gem_obj_ggtt_offset(obj) & (size - 1)),
		     "object 0x%08lx not 512K or pot-size 0x%08x aligned\n",
		     i915_gem_obj_ggtt_offset(obj), size);

		pitch_val = obj->stride / 128;
		pitch_val = ffs(pitch_val) - 1;

		val = i915_gem_obj_ggtt_offset(obj);
		if (obj->tiling_mode == I915_TILING_Y)
			val |= 1 << I830_FENCE_TILING_Y_SHIFT;
		val |= I830_FENCE_SIZE_BITS(size);
		val |= pitch_val << I830_FENCE_PITCH_SHIFT;
		val |= I830_FENCE_REG_VALID;
	} else
		val = 0;

	I915_WRITE(FENCE_REG_830_0 + reg * 4, val);
	POSTING_READ(FENCE_REG_830_0 + reg * 4);
}

inline static bool i915_gem_object_needs_mb(struct drm_i915_gem_object *obj)
{
	return obj && obj->base.read_domains & I915_GEM_DOMAIN_GTT;
}

static void i915_gem_write_fence(struct drm_device *dev, int reg,
				 struct drm_i915_gem_object *obj)
{
	struct drm_i915_private *dev_priv = dev->dev_private;

	/* Ensure that all CPU reads are completed before installing a fence
	 * and all writes before removing the fence.
	 */
	if (i915_gem_object_needs_mb(dev_priv->fence_regs[reg].obj))
		mb();

	WARN(obj && (!obj->stride || !obj->tiling_mode),
	     "bogus fence setup with stride: 0x%x, tiling mode: %i\n",
	     obj->stride, obj->tiling_mode);

	switch (INTEL_INFO(dev)->gen) {
	case 8:
	case 7:
	case 6:
	case 5:
	case 4: i965_write_fence_reg(dev, reg, obj); break;
	case 3: i915_write_fence_reg(dev, reg, obj); break;
	case 2: i830_write_fence_reg(dev, reg, obj); break;
	default: BUG();
	}

	/* And similarly be paranoid that no direct access to this region
	 * is reordered to before the fence is installed.
	 */
	if (i915_gem_object_needs_mb(obj))
		mb();
}

static inline int fence_number(struct drm_i915_private *dev_priv,
			       struct drm_i915_fence_reg *fence)
{
	return fence - dev_priv->fence_regs;
}

static void i915_gem_object_update_fence(struct drm_i915_gem_object *obj,
					 struct drm_i915_fence_reg *fence,
					 bool enable)
{
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	int reg = fence_number(dev_priv, fence);

	i915_gem_write_fence(obj->base.dev, reg, enable ? obj : NULL);

	if (enable) {
		obj->fence_reg = reg;
		fence->obj = obj;
		list_move_tail(&fence->lru_list, &dev_priv->mm.fence_list);
	} else {
		obj->fence_reg = I915_FENCE_REG_NONE;
		fence->obj = NULL;
		list_del_init(&fence->lru_list);
	}
	obj->fence_dirty = false;
}

static int
i915_gem_object_wait_fence(struct drm_i915_gem_object *obj)
{
	if (obj->last_fenced_seqno) {
		int ret = i915_wait_seqno(obj->ring, obj->last_fenced_seqno);
		if (ret)
			return ret;

		obj->last_fenced_seqno = 0;
	}

	obj->fenced_gpu_access = false;
	return 0;
}

int
i915_gem_object_put_fence(struct drm_i915_gem_object *obj)
{
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	struct drm_i915_fence_reg *fence;
	int ret;

	ret = i915_gem_object_wait_fence(obj);
	if (ret)
		return ret;

	if (obj->fence_reg == I915_FENCE_REG_NONE)
		return 0;

	fence = &dev_priv->fence_regs[obj->fence_reg];

	i915_gem_object_fence_lost(obj);
	i915_gem_object_update_fence(obj, fence, false);

	return 0;
}

static struct drm_i915_fence_reg *
i915_find_fence_reg(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_fence_reg *reg, *avail;
	int i;

	/* First try to find a free reg */
	avail = NULL;
	for (i = dev_priv->fence_reg_start; i < dev_priv->num_fence_regs; i++) {
		reg = &dev_priv->fence_regs[i];
		if (!reg->obj)
			return reg;

		if (!reg->pin_count)
			avail = reg;
	}

	if (avail == NULL)
		goto deadlock;

	/* None available, try to steal one or wait for a user to finish */
	list_for_each_entry(reg, &dev_priv->mm.fence_list, lru_list) {
		if (reg->pin_count)
			continue;

		return reg;
	}

deadlock:
	/* Wait for completion of pending flips which consume fences */
	if (intel_has_pending_fb_unpin(dev))
		return ERR_PTR(-EAGAIN);

	return ERR_PTR(-EDEADLK);
}

/**
 * i915_gem_object_get_fence - set up fencing for an object
 * @@obj: object to map through a fence reg
 *
 * When mapping objects through the GTT, userspace wants to be able to write
 * to them without having to worry about swizzling if the object is tiled.
 * This function walks the fence regs looking for a free one for @@obj,
 * stealing one if it can't find any.
 *
 * It then sets up the reg based on the object's properties: address, pitch
 * and tiling format.
 *
 * For an untiled surface, this removes any existing fence.
 */
int
i915_gem_object_get_fence(struct drm_i915_gem_object *obj)
{
	struct drm_device *dev = obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	bool enable = obj->tiling_mode != I915_TILING_NONE;
	struct drm_i915_fence_reg *reg;
	int ret;

	/* Have we updated the tiling parameters upon the object and so
	 * will need to serialise the write to the associated fence register?
	 */
	if (obj->fence_dirty) {
		ret = i915_gem_object_wait_fence(obj);
		if (ret)
			return ret;
	}

	/* Just update our place in the LRU if our fence is getting reused. */
	if (obj->fence_reg != I915_FENCE_REG_NONE) {
		reg = &dev_priv->fence_regs[obj->fence_reg];
		if (!obj->fence_dirty) {
			list_move_tail(&reg->lru_list,
				       &dev_priv->mm.fence_list);
			return 0;
		}
	} else if (enable) {
		reg = i915_find_fence_reg(dev);
		if (IS_ERR(reg))
			return PTR_ERR(reg);

		if (reg->obj) {
			struct drm_i915_gem_object *old = reg->obj;

			ret = i915_gem_object_wait_fence(old);
			if (ret)
				return ret;

			i915_gem_object_fence_lost(old);
		}
	} else
		return 0;

	i915_gem_object_update_fence(obj, reg, enable);

	return 0;
}

static bool i915_gem_valid_gtt_space(struct drm_device *dev,
				     struct drm_mm_node *gtt_space,
				     unsigned long cache_level)
{
	struct drm_mm_node *other;

	/* On non-LLC machines we have to be careful when putting differing
	 * types of snoopable memory together to avoid the prefetcher
	 * crossing memory domains and dying.
	 */
	if (HAS_LLC(dev))
		return true;

	if (!drm_mm_node_allocated(gtt_space))
		return true;

	if (list_empty(&gtt_space->node_list))
		return true;

	other = list_entry(gtt_space->node_list.prev, struct drm_mm_node, node_list);
	if (other->allocated && !other->hole_follows && other->color != cache_level)
		return false;

	other = list_entry(gtt_space->node_list.next, struct drm_mm_node, node_list);
	if (other->allocated && !gtt_space->hole_follows && other->color != cache_level)
		return false;

	return true;
}

static void i915_gem_verify_gtt(struct drm_device *dev)
{
#if WATCH_GTT
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj;
	int err = 0;

	list_for_each_entry(obj, &dev_priv->mm.gtt_list, global_list) {
		if (obj->gtt_space == NULL) {
			printk(KERN_ERR "object found on GTT list with no space reserved\n");
			err++;
			continue;
		}

		if (obj->cache_level != obj->gtt_space->color) {
			printk(KERN_ERR "object reserved space [%08lx, %08lx] with wrong color, cache_level=%x, color=%lx\n",
			       i915_gem_obj_ggtt_offset(obj),
			       i915_gem_obj_ggtt_offset(obj) + i915_gem_obj_ggtt_size(obj),
			       obj->cache_level,
			       obj->gtt_space->color);
			err++;
			continue;
		}

		if (!i915_gem_valid_gtt_space(dev,
					      obj->gtt_space,
					      obj->cache_level)) {
			printk(KERN_ERR "invalid GTT space found at [%08lx, %08lx] - color=%x\n",
			       i915_gem_obj_ggtt_offset(obj),
			       i915_gem_obj_ggtt_offset(obj) + i915_gem_obj_ggtt_size(obj),
			       obj->cache_level);
			err++;
			continue;
		}
	}

	WARN_ON(err);
#endif
}

/**
 * Finds free space in the GTT aperture and binds the object there.
 */
static int
i915_gem_object_bind_to_vm(struct drm_i915_gem_object *obj,
			   struct i915_address_space *vm,
			   unsigned alignment,
			   bool map_and_fenceable,
			   bool nonblocking)
{
	struct drm_device *dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	u32 size, fence_size, fence_alignment, unfenced_alignment;
	size_t gtt_max =
		map_and_fenceable ? dev_priv->gtt.mappable_end : vm->total;
	struct i915_vma *vma;
	int ret;

	fence_size = i915_gem_get_gtt_size(dev,
					   obj->base.size,
					   obj->tiling_mode);
	fence_alignment = i915_gem_get_gtt_alignment(dev,
						     obj->base.size,
						     obj->tiling_mode, true);
	unfenced_alignment =
		i915_gem_get_gtt_alignment(dev,
						    obj->base.size,
						    obj->tiling_mode, false);

	if (alignment == 0)
		alignment = map_and_fenceable ? fence_alignment :
						unfenced_alignment;
	if (map_and_fenceable && alignment & (fence_alignment - 1)) {
		DRM_ERROR("Invalid object alignment requested %u\n", alignment);
		return -EINVAL;
	}

	size = map_and_fenceable ? fence_size : obj->base.size;

	/* If the object is bigger than the entire aperture, reject it early
	 * before evicting everything in a vain attempt to find space.
	 */
	if (obj->base.size > gtt_max) {
		DRM_ERROR("Attempting to bind an object larger than the aperture: object=%zd > %s aperture=%zu\n",
			  obj->base.size,
			  map_and_fenceable ? "mappable" : "total",
			  gtt_max);
		return -E2BIG;
	}

	ret = i915_gem_object_get_pages(obj);
	if (ret)
		return ret;

	i915_gem_object_pin_pages(obj);

	BUG_ON(!i915_is_ggtt(vm));

	vma = i915_gem_obj_lookup_or_create_vma(obj, vm);
	if (IS_ERR(vma)) {
		ret = PTR_ERR(vma);
		goto err_unpin;
	}

	/* For now we only ever use 1 vma per object */
	WARN_ON(!list_is_singular(&obj->vma_list));

search_free:
	ret = drm_mm_insert_node_in_range_generic(&vm->mm, &vma->node,
						  size, alignment,
						  obj->cache_level, 0, gtt_max,
						  DRM_MM_SEARCH_DEFAULT);
	if (ret) {
		ret = i915_gem_evict_something(dev, vm, size, alignment,
					       obj->cache_level,
					       map_and_fenceable,
					       nonblocking);
		if (ret == 0)
			goto search_free;

		goto err_free_vma;
	}
	if (WARN_ON(!i915_gem_valid_gtt_space(dev, &vma->node,
					      obj->cache_level))) {
		ret = -EINVAL;
		goto err_remove_node;
	}

	ret = i915_gem_gtt_prepare_object(obj);
	if (ret)
		goto err_remove_node;

	list_move_tail(&obj->global_list, &dev_priv->mm.bound_list);
	list_add_tail(&vma->mm_list, &vm->inactive_list);

	if (i915_is_ggtt(vm)) {
		bool mappable, fenceable;

		fenceable = (vma->node.size == fence_size &&
			     (vma->node.start & (fence_alignment - 1)) == 0);

		mappable = (vma->node.start + obj->base.size <=
			    dev_priv->gtt.mappable_end);

		obj->map_and_fenceable = mappable && fenceable;
	}

	WARN_ON(map_and_fenceable && !obj->map_and_fenceable);

	trace_i915_vma_bind(vma, map_and_fenceable);
	i915_gem_verify_gtt(dev);
	return 0;

err_remove_node:
	drm_mm_remove_node(&vma->node);
err_free_vma:
	i915_gem_vma_destroy(vma);
err_unpin:
	i915_gem_object_unpin_pages(obj);
	/* XXX Until we've hooked up the shrinking functions. */
	i915_gem_object_put_pages(obj);
	return ret;
}

bool
i915_gem_clflush_object(struct drm_i915_gem_object *obj,
			bool force)
{
	/* If we don't have a page list set up, then we're not pinned
	 * to GPU, and we can ignore the cache flush because it'll happen
	 * again at bind time.
	 */
	if (obj->pages == NULL)
		return false;

	/*
	 * Stolen memory is always coherent with the GPU as it is explicitly
	 * marked as wc by the system, or the system is cache-coherent.
	 */
	if (obj->stolen)
		return false;

	/* If the GPU is snooping the contents of the CPU cache,
	 * we do not need to manually clear the CPU cache lines.  However,
	 * the caches are only snooped when the render cache is
	 * flushed/invalidated.  As we always have to emit invalidations
	 * and flushes when moving into and out of the RENDER domain, correct
	 * snooping behaviour occurs naturally as the result of our domain
	 * tracking.
	 */
	if (!force && cpu_cache_is_coherent(obj->base.dev, obj->cache_level))
		return false;

	trace_i915_gem_object_clflush(obj);
#if 0
	drm_clflush_sg(obj->pages);
#else
{
	int page_count = obj->base.size >> PAGE_SHIFT;
	int i;

	for (i = 0; i < page_count; i++)
		pmap_flush_page(VM_PAGE_TO_PHYS(obj->pages[i]));
}
#endif
	return true;
}

/** Flushes the GTT write domain for the object if it's dirty. */
static void
i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *obj)
{
	uint32_t old_write_domain;

	if (obj->base.write_domain != I915_GEM_DOMAIN_GTT)
		return;

	/* No actual flushing is required for the GTT write domain.  Writes
	 * to it immediately go to main memory as far as we know, so there's
	 * no chipset flush.  It also doesn't land in render cache.
	 *
	 * However, we do have to enforce the order so that all writes through
	 * the GTT land before any writes to the device, such as updates to
	 * the GATT itself.
	 */
	wmb();

	old_write_domain = obj->base.write_domain;
	obj->base.write_domain = 0;

	trace_i915_gem_object_change_domain(obj,
					    obj->base.read_domains,
					    old_write_domain);
}

/** Flushes the CPU write domain for the object if it's dirty. */
static void
i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj,
				       bool force)
{
	uint32_t old_write_domain;

	if (obj->base.write_domain != I915_GEM_DOMAIN_CPU)
		return;

	if (i915_gem_clflush_object(obj, force))
		i915_gem_chipset_flush(obj->base.dev);

	old_write_domain = obj->base.write_domain;
	obj->base.write_domain = 0;

	trace_i915_gem_object_change_domain(obj,
					    obj->base.read_domains,
					    old_write_domain);
}

/**
 * Moves a single object to the GTT read, and possibly write domain.
 *
 * This function returns when the move is complete, including waiting on
 * flushes to occur.
 */
int
i915_gem_object_set_to_gtt_domain(struct drm_i915_gem_object *obj, bool write)
{
	drm_i915_private_t *dev_priv = obj->base.dev->dev_private;
	uint32_t old_write_domain, old_read_domains;
	int ret;

	/* Not valid to be called on unbound objects. */
	if (!i915_gem_obj_bound_any(obj))
		return -EINVAL;

	if (obj->base.write_domain == I915_GEM_DOMAIN_GTT)
		return 0;

	ret = i915_gem_object_wait_rendering(obj, !write);
	if (ret)
		return ret;

	i915_gem_object_flush_cpu_write_domain(obj, false);

	/* Serialise direct access to this object with the barriers for
	 * coherent writes from the GPU, by effectively invalidating the
	 * GTT domain upon first access.
	 */
	if ((obj->base.read_domains & I915_GEM_DOMAIN_GTT) == 0)
		mb();

	old_write_domain = obj->base.write_domain;
	old_read_domains = obj->base.read_domains;

	/* It should now be out of any other write domains, and we can update
	 * the domain values for our changes.
	 */
	BUG_ON((obj->base.write_domain & ~I915_GEM_DOMAIN_GTT) != 0);
	obj->base.read_domains |= I915_GEM_DOMAIN_GTT;
	if (write) {
		obj->base.read_domains = I915_GEM_DOMAIN_GTT;
		obj->base.write_domain = I915_GEM_DOMAIN_GTT;
		obj->dirty = 1;
	}

	trace_i915_gem_object_change_domain(obj,
					    old_read_domains,
					    old_write_domain);

	/* And bump the LRU for this access */
	if (i915_gem_object_is_inactive(obj)) {
		struct i915_vma *vma = i915_gem_obj_to_ggtt(obj);
		if (vma)
			list_move_tail(&vma->mm_list,
				       &dev_priv->gtt.base.inactive_list);

	}

	return 0;
}

int i915_gem_object_set_cache_level(struct drm_i915_gem_object *obj,
				    enum i915_cache_level cache_level)
{
	struct drm_device *dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct i915_vma *vma, *next;
	int ret;

	if (obj->cache_level == cache_level)
		return 0;

	if (obj->pin_count) {
		DRM_DEBUG("can not change the cache level of pinned objects\n");
		return -EBUSY;
	}

	list_for_each_entry_safe(vma, next, &obj->vma_list, vma_link) {
		if (!i915_gem_valid_gtt_space(dev, &vma->node, cache_level)) {
			ret = i915_vma_unbind(vma);
			if (ret)
				return ret;

			break;
		}
	}

	if (i915_gem_obj_bound_any(obj)) {
		ret = i915_gem_object_finish_gpu(obj);
		if (ret)
			return ret;

		i915_gem_object_finish_gtt(obj);

		/* Before SandyBridge, you could not use tiling or fence
		 * registers with snooped memory, so relinquish any fences
		 * currently pointing to our region in the aperture.
		 */
		if (INTEL_INFO(dev)->gen < 6) {
			ret = i915_gem_object_put_fence(obj);
			if (ret)
				return ret;
		}

		if (obj->has_global_gtt_mapping)
			i915_gem_gtt_bind_object(obj, cache_level);
		if (obj->has_aliasing_ppgtt_mapping)
			i915_ppgtt_bind_object(dev_priv->mm.aliasing_ppgtt,
					       obj, cache_level);
	}

	list_for_each_entry(vma, &obj->vma_list, vma_link)
		vma->node.color = cache_level;
	obj->cache_level = cache_level;

	if (cpu_write_needs_clflush(obj)) {
		u32 old_read_domains, old_write_domain;

		/* If we're coming from LLC cached, then we haven't
		 * actually been tracking whether the data is in the
		 * CPU cache or not, since we only allow one bit set
		 * in obj->write_domain and have been skipping the clflushes.
		 * Just set it to the CPU cache for now.
		 */
		WARN_ON(obj->base.write_domain & ~I915_GEM_DOMAIN_CPU);

		old_read_domains = obj->base.read_domains;
		old_write_domain = obj->base.write_domain;

		obj->base.read_domains = I915_GEM_DOMAIN_CPU;
		obj->base.write_domain = I915_GEM_DOMAIN_CPU;

		trace_i915_gem_object_change_domain(obj,
						    old_read_domains,
						    old_write_domain);
	}

	i915_gem_verify_gtt(dev);
	return 0;
}

int i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,
			       struct drm_file *file)
{
	struct drm_i915_gem_caching *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	switch (obj->cache_level) {
	case I915_CACHE_LLC:
	case I915_CACHE_L3_LLC:
		args->caching = I915_CACHING_CACHED;
		break;

	case I915_CACHE_WT:
		args->caching = I915_CACHING_DISPLAY;
		break;

	default:
		args->caching = I915_CACHING_NONE;
		break;
	}

	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,
			       struct drm_file *file)
{
	struct drm_i915_gem_caching *args = data;
	struct drm_i915_gem_object *obj;
	enum i915_cache_level level;
	int ret;

	switch (args->caching) {
	case I915_CACHING_NONE:
		level = I915_CACHE_NONE;
		break;
	case I915_CACHING_CACHED:
		level = I915_CACHE_LLC;
		break;
	case I915_CACHING_DISPLAY:
		level = HAS_WT(dev) ? I915_CACHE_WT : I915_CACHE_NONE;
		break;
	default:
		return -EINVAL;
	}

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	ret = i915_gem_object_set_cache_level(obj, level);

	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

static bool is_pin_display(struct drm_i915_gem_object *obj)
{
	/* There are 3 sources that pin objects:
	 *   1. The display engine (scanouts, sprites, cursors);
	 *   2. Reservations for execbuffer;
	 *   3. The user.
	 *
	 * We can ignore reservations as we hold the struct_mutex and
	 * are only called outside of the reservation path.  The user
	 * can only increment pin_count once, and so if after
	 * subtracting the potential reference by the user, any pin_count
	 * remains, it must be due to another use by the display engine.
	 */
	return obj->pin_count - !!obj->user_pin_count;
}

/*
 * Prepare buffer for display plane (scanout, cursors, etc).
 * Can be called from an uninterruptible phase (modesetting) and allows
 * any flushes to be pipelined (for pageflips).
 */
int
i915_gem_object_pin_to_display_plane(struct drm_i915_gem_object *obj,
				     u32 alignment,
				     struct intel_ring_buffer *pipelined)
{
	u32 old_read_domains, old_write_domain;
	int ret;

	if (pipelined != obj->ring) {
		ret = i915_gem_object_sync(obj, pipelined);
		if (ret)
			return ret;
	}

	/* Mark the pin_display early so that we account for the
	 * display coherency whilst setting up the cache domains.
	 */
	obj->pin_display = true;

	/* The display engine is not coherent with the LLC cache on gen6.  As
	 * a result, we make sure that the pinning that is about to occur is
	 * done with uncached PTEs. This is lowest common denominator for all
	 * chipsets.
	 *
	 * However for gen6+, we could do better by using the GFDT bit instead
	 * of uncaching, which would allow us to flush all the LLC-cached data
	 * with that bit in the PTE to main memory with just one PIPE_CONTROL.
	 */
	ret = i915_gem_object_set_cache_level(obj,
					      HAS_WT(obj->base.dev) ? I915_CACHE_WT : I915_CACHE_NONE);
	if (ret)
		goto err_unpin_display;

	/* As the user may map the buffer once pinned in the display plane
	 * (e.g. libkms for the bootup splash), we have to ensure that we
	 * always use map_and_fenceable for all scanout buffers.
	 */
	ret = i915_gem_obj_ggtt_pin(obj, alignment, true, false);
	if (ret)
		goto err_unpin_display;

	i915_gem_object_flush_cpu_write_domain(obj, true);

	old_write_domain = obj->base.write_domain;
	old_read_domains = obj->base.read_domains;

	/* It should now be out of any other write domains, and we can update
	 * the domain values for our changes.
	 */
	obj->base.write_domain = 0;
	obj->base.read_domains |= I915_GEM_DOMAIN_GTT;

	trace_i915_gem_object_change_domain(obj,
					    old_read_domains,
					    old_write_domain);

	return 0;

err_unpin_display:
	obj->pin_display = is_pin_display(obj);
	return ret;
}

void
i915_gem_object_unpin_from_display_plane(struct drm_i915_gem_object *obj)
{
	i915_gem_object_unpin(obj);
	obj->pin_display = is_pin_display(obj);
}

int
i915_gem_object_finish_gpu(struct drm_i915_gem_object *obj)
{
	int ret;

	if ((obj->base.read_domains & I915_GEM_GPU_DOMAINS) == 0)
		return 0;

	ret = i915_gem_object_wait_rendering(obj, false);
	if (ret)
		return ret;

	/* Ensure that we invalidate the GPU's caches and TLBs. */
	obj->base.read_domains &= ~I915_GEM_GPU_DOMAINS;
	return 0;
}

/**
 * Moves a single object to the CPU read, and possibly write domain.
 *
 * This function returns when the move is complete, including waiting on
 * flushes to occur.
 */
int
i915_gem_object_set_to_cpu_domain(struct drm_i915_gem_object *obj, bool write)
{
	uint32_t old_write_domain, old_read_domains;
	int ret;

	if (obj->base.write_domain == I915_GEM_DOMAIN_CPU)
		return 0;

	ret = i915_gem_object_wait_rendering(obj, !write);
	if (ret)
		return ret;

	i915_gem_object_flush_gtt_write_domain(obj);

	old_write_domain = obj->base.write_domain;
	old_read_domains = obj->base.read_domains;

	/* Flush the CPU cache if it's still invalid. */
	if ((obj->base.read_domains & I915_GEM_DOMAIN_CPU) == 0) {
		i915_gem_clflush_object(obj, false);

		obj->base.read_domains |= I915_GEM_DOMAIN_CPU;
	}

	/* It should now be out of any other write domains, and we can update
	 * the domain values for our changes.
	 */
	BUG_ON((obj->base.write_domain & ~I915_GEM_DOMAIN_CPU) != 0);

	/* If we're writing through the CPU, then the GPU read domains will
	 * need to be invalidated at next use.
	 */
	if (write) {
		obj->base.read_domains = I915_GEM_DOMAIN_CPU;
		obj->base.write_domain = I915_GEM_DOMAIN_CPU;
	}

	trace_i915_gem_object_change_domain(obj,
					    old_read_domains,
					    old_write_domain);

	return 0;
}

/* Throttle our rendering by waiting until the ring has completed our requests
 * emitted over 20 msec ago.
 *
 * Note that if we were to use the current jiffies each time around the loop,
 * we wouldn't escape the function with any frames outstanding if the time to
 * render a frame was over 20ms.
 *
 * This should get us reasonable parallelism between CPU and GPU but also
 * relatively low latency when blocking on a particular request to finish.
 */
static int
i915_gem_ring_throttle(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct drm_i915_file_private *file_priv = file->driver_priv;
	unsigned long recent_enough = jiffies - msecs_to_jiffies(20);
	struct drm_i915_gem_request *request;
	struct intel_ring_buffer *ring = NULL;
	unsigned reset_counter;
	u32 seqno = 0;
	int ret;

	ret = i915_gem_wait_for_error(&dev_priv->gpu_error);
	if (ret)
		return ret;

	ret = i915_gem_check_wedge(&dev_priv->gpu_error, false);
	if (ret)
		return ret;

	spin_lock(&file_priv->mm.lock);
	list_for_each_entry(request, &file_priv->mm.request_list, client_list) {
		if (time_after_eq(request->emitted_jiffies, recent_enough))
			break;

		ring = request->ring;
		seqno = request->seqno;
	}
	reset_counter = atomic_read(&dev_priv->gpu_error.reset_counter);
	spin_unlock(&file_priv->mm.lock);

	if (seqno == 0)
		return 0;

	ret = __wait_seqno(ring, seqno, reset_counter, true, NULL, NULL);
	if (ret == 0)
		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work, 0);

	return ret;
}

int
i915_gem_object_pin(struct drm_i915_gem_object *obj,
		    struct i915_address_space *vm,
		    uint32_t alignment,
		    bool map_and_fenceable,
		    bool nonblocking)
{
	struct i915_vma *vma;
	int ret;

	if (WARN_ON(obj->pin_count == DRM_I915_GEM_OBJECT_MAX_PIN_COUNT))
		return -EBUSY;

	WARN_ON(map_and_fenceable && !i915_is_ggtt(vm));

	vma = i915_gem_obj_to_vma(obj, vm);

	if (vma) {
		if ((alignment &&
		     vma->node.start & (alignment - 1)) ||
		    (map_and_fenceable && !obj->map_and_fenceable)) {
			WARN(obj->pin_count,
			     "bo is already pinned with incorrect alignment:"
			     " offset=%lx, req.alignment=%x, req.map_and_fenceable=%d,"
			     " obj->map_and_fenceable=%d\n",
			     i915_gem_obj_offset(obj, vm), alignment,
			     map_and_fenceable,
			     obj->map_and_fenceable);
			ret = i915_vma_unbind(vma);
			if (ret)
				return ret;
		}
	}

	if (!i915_gem_obj_bound(obj, vm)) {
		struct drm_i915_private *dev_priv = obj->base.dev->dev_private;

		ret = i915_gem_object_bind_to_vm(obj, vm, alignment,
						 map_and_fenceable,
						 nonblocking);
		if (ret)
			return ret;

		if (!dev_priv->mm.aliasing_ppgtt)
			i915_gem_gtt_bind_object(obj, obj->cache_level);
	}

	if (!obj->has_global_gtt_mapping && map_and_fenceable)
		i915_gem_gtt_bind_object(obj, obj->cache_level);

	obj->pin_count++;
	obj->pin_mappable |= map_and_fenceable;

	return 0;
}

void
i915_gem_object_unpin(struct drm_i915_gem_object *obj)
{
	BUG_ON(obj->pin_count == 0);
	BUG_ON(!i915_gem_obj_bound_any(obj));

	if (--obj->pin_count == 0)
		obj->pin_mappable = false;
}

int
i915_gem_pin_ioctl(struct drm_device *dev, void *data,
		   struct drm_file *file)
{
	struct drm_i915_gem_pin *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	if (obj->madv != I915_MADV_WILLNEED) {
		DRM_ERROR("Attempting to pin a purgeable buffer\n");
		ret = -EINVAL;
		goto out;
	}

	if (obj->pin_filp != NULL && obj->pin_filp != file) {
		DRM_ERROR("Already pinned in i915_gem_pin_ioctl(): %d\n",
			  args->handle);
		ret = -EINVAL;
		goto out;
	}

	if (obj->user_pin_count == ULONG_MAX) {
		ret = -EBUSY;
		goto out;
	}

	if (obj->user_pin_count == 0) {
		ret = i915_gem_obj_ggtt_pin(obj, args->alignment, true, false);
		if (ret)
			goto out;
	}

	obj->user_pin_count++;
	obj->pin_filp = file;

	args->offset = i915_gem_obj_ggtt_offset(obj);
out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int
i915_gem_unpin_ioctl(struct drm_device *dev, void *data,
		     struct drm_file *file)
{
	struct drm_i915_gem_pin *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	if (obj->pin_filp != file) {
		DRM_ERROR("Not pinned by caller in i915_gem_pin_ioctl(): %d\n",
			  args->handle);
		ret = -EINVAL;
		goto out;
	}
	obj->user_pin_count--;
	if (obj->user_pin_count == 0) {
		obj->pin_filp = NULL;
		i915_gem_object_unpin(obj);
	}

out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int
i915_gem_busy_ioctl(struct drm_device *dev, void *data,
		    struct drm_file *file)
{
	struct drm_i915_gem_busy *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	/* Count all active objects as busy, even if they are currently not used
	 * by the gpu. Users of this interface expect objects to eventually
	 * become non-busy without any further actions, therefore emit any
	 * necessary flushes here.
	 */
	ret = i915_gem_object_flush_active(obj);

	args->busy = obj->active;
	if (obj->ring) {
		BUILD_BUG_ON(I915_NUM_RINGS > 16);
		args->busy |= intel_ring_flag(obj->ring) << 16;
	}

	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int
i915_gem_throttle_ioctl(struct drm_device *dev, void *data,
			struct drm_file *file_priv)
{
	return i915_gem_ring_throttle(dev, file_priv);
}

int
i915_gem_madvise_ioctl(struct drm_device *dev, void *data,
		       struct drm_file *file_priv)
{
	struct drm_i915_gem_madvise *args = data;
	struct drm_i915_gem_object *obj;
	int ret;

	switch (args->madv) {
	case I915_MADV_DONTNEED:
	case I915_MADV_WILLNEED:
	    break;
	default:
	    return -EINVAL;
	}

	ret = i915_mutex_lock_interruptible(dev);
	if (ret)
		return ret;

	obj = to_intel_bo(drm_gem_object_lookup(dev, file_priv, args->handle));
	if (&obj->base == NULL) {
		ret = -ENOENT;
		goto unlock;
	}

	if (obj->pin_count) {
		ret = -EINVAL;
		goto out;
	}

	if (obj->madv != __I915_MADV_PURGED)
		obj->madv = args->madv;

	/* if the object is no longer attached, discard its backing storage */
	if (i915_gem_object_is_purgeable(obj) && obj->pages == NULL)
		i915_gem_object_truncate(obj);

	args->retained = obj->madv != __I915_MADV_PURGED;

out:
	drm_gem_object_unreference(&obj->base);
unlock:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

void i915_gem_object_init(struct drm_i915_gem_object *obj,
			  const struct drm_i915_gem_object_ops *ops)
{
	INIT_LIST_HEAD(&obj->global_list);
	INIT_LIST_HEAD(&obj->ring_list);
	INIT_LIST_HEAD(&obj->obj_exec_link);
	INIT_LIST_HEAD(&obj->vma_list);

	obj->ops = ops;

	obj->fence_reg = I915_FENCE_REG_NONE;
	obj->madv = I915_MADV_WILLNEED;
	/* Avoid an unnecessary call to unbind on the first bind. */
	obj->map_and_fenceable = true;

	i915_gem_info_add_obj(obj->base.dev->dev_private, obj->base.size);
}

static const struct drm_i915_gem_object_ops i915_gem_object_ops = {
	.get_pages = i915_gem_object_get_pages_gtt,
	.put_pages = i915_gem_object_put_pages_gtt,
};

struct drm_i915_gem_object *i915_gem_alloc_object(struct drm_device *dev,
						  size_t size)
{
	struct drm_i915_gem_object *obj;
#ifdef __linux__
	struct address_space *mapping;
	gfp_t mask;
#endif

	obj = i915_gem_object_alloc(dev);
	if (obj == NULL)
		return NULL;

	if (drm_gem_object_init(dev, &obj->base, size) != 0) {
		i915_gem_object_free(obj);
		return NULL;
	}

#ifdef __linux__
	mask = GFP_HIGHUSER | __GFP_RECLAIMABLE;
	if (IS_CRESTLINE(dev) || IS_BROADWATER(dev)) {
		/* 965gm cannot relocate objects above 4GiB. */
		mask &= ~__GFP_HIGHMEM;
		mask |= __GFP_DMA32;
	}

	mapping = file_inode(obj->base.filp)->i_mapping;
	mapping_set_gfp_mask(mapping, mask);
#endif

	i915_gem_object_init(obj, &i915_gem_object_ops);

	obj->base.write_domain = I915_GEM_DOMAIN_CPU;
	obj->base.read_domains = I915_GEM_DOMAIN_CPU;

	if (HAS_LLC(dev)) {
		/* On some devices, we can have the GPU use the LLC (the CPU
		 * cache) for about a 10% performance improvement
		 * compared to uncached.  Graphics requests other than
		 * display scanout are coherent with the CPU in
		 * accessing this cache.  This means in this mode we
		 * don't need to clflush on the CPU side, and on the
		 * GPU side we only need to flush internal caches to
		 * get data visible to the CPU.
		 *
		 * However, we maintain the display planes as UC, and so
		 * need to rebind when first used as such.
		 */
		obj->cache_level = I915_CACHE_LLC;
	} else
		obj->cache_level = I915_CACHE_NONE;

	trace_i915_gem_object_create(obj);

	return obj;
}

void i915_gem_free_object(struct drm_gem_object *gem_obj)
{
	struct drm_i915_gem_object *obj = to_intel_bo(gem_obj);
	struct drm_device *dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct i915_vma *vma, *next;

	intel_runtime_pm_get(dev_priv);

	trace_i915_gem_object_destroy(obj);

	if (obj->phys_obj)
		i915_gem_detach_phys_object(dev, obj);

	obj->pin_count = 0;
	/* NB: 0 or 1 elements */
	WARN_ON(!list_empty(&obj->vma_list) &&
		!list_is_singular(&obj->vma_list));
	list_for_each_entry_safe(vma, next, &obj->vma_list, vma_link) {
		int ret = i915_vma_unbind(vma);
		if (WARN_ON(ret == -ERESTARTSYS)) {
			bool was_interruptible;

			was_interruptible = dev_priv->mm.interruptible;
			dev_priv->mm.interruptible = false;

			WARN_ON(i915_vma_unbind(vma));

			dev_priv->mm.interruptible = was_interruptible;
		}
	}

	/* Stolen objects don't hold a ref, but do hold pin count. Fix that up
	 * before progressing. */
	if (obj->stolen)
		i915_gem_object_unpin_pages(obj);

	if (WARN_ON(obj->pages_pin_count))
		obj->pages_pin_count = 0;
	i915_gem_object_put_pages(obj);
	i915_gem_object_free_mmap_offset(obj);
	i915_gem_object_release_stolen(obj);

	BUG_ON(obj->pages);

#ifdef notyet
	if (obj->base.import_attach)
		drm_prime_gem_destroy(&obj->base, NULL);
#endif

	drm_gem_object_release(&obj->base);
	i915_gem_info_remove_obj(dev_priv, obj->base.size);

	kfree(obj->bit_17);
	i915_gem_object_free(obj);

	intel_runtime_pm_put(dev_priv);
}

struct i915_vma *i915_gem_obj_to_vma(struct drm_i915_gem_object *obj,
				     struct i915_address_space *vm)
{
	struct i915_vma *vma;
	list_for_each_entry(vma, &obj->vma_list, vma_link)
		if (vma->vm == vm)
			return vma;

	return NULL;
}

static struct i915_vma *__i915_gem_vma_create(struct drm_i915_gem_object *obj,
					      struct i915_address_space *vm)
{
	struct i915_vma *vma = kzalloc(sizeof(*vma), GFP_KERNEL);
	if (vma == NULL)
		return ERR_PTR(-ENOMEM);

	INIT_LIST_HEAD(&vma->vma_link);
	INIT_LIST_HEAD(&vma->mm_list);
	INIT_LIST_HEAD(&vma->exec_list);
	vma->vm = vm;
	vma->obj = obj;

	/* Keep GGTT vmas first to make debug easier */
	if (i915_is_ggtt(vm))
		list_add(&vma->vma_link, &obj->vma_list);
	else
		list_add_tail(&vma->vma_link, &obj->vma_list);

	return vma;
}

struct i915_vma *
i915_gem_obj_lookup_or_create_vma(struct drm_i915_gem_object *obj,
				  struct i915_address_space *vm)
{
	struct i915_vma *vma;

	vma = i915_gem_obj_to_vma(obj, vm);
	if (!vma)
		vma = __i915_gem_vma_create(obj, vm);

	return vma;
}

void i915_gem_vma_destroy(struct i915_vma *vma)
{
	WARN_ON(vma->node.allocated);

	/* Keep the vma as a placeholder in the execbuffer reservation lists */
	if (!list_empty(&vma->exec_list))
		return;

	list_del(&vma->vma_link);

	kfree(vma);
}

int
i915_gem_suspend(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret = 0;

	mutex_lock(&dev->struct_mutex);
	if (dev_priv->ums.mm_suspended)
		goto err;

	ret = i915_gpu_idle(dev);
	if (ret)
		goto err;

	i915_gem_retire_requests(dev);

	/* Under UMS, be paranoid and evict. */
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		i915_gem_evict_everything(dev);

	i915_kernel_lost_context(dev);
	i915_gem_cleanup_ringbuffer(dev);

	/* Hack!  Don't let anybody do execbuf while we don't control the chip.
	 * We need to replace this with a semaphore, or something.
	 * And not confound ums.mm_suspended!
	 */
	dev_priv->ums.mm_suspended = !drm_core_check_feature(dev,
							     DRIVER_MODESET);
	mutex_unlock(&dev->struct_mutex);

	del_timer_sync(&dev_priv->gpu_error.hangcheck_timer);
	cancel_delayed_work_sync(&dev_priv->mm.retire_work);
	cancel_delayed_work_sync(&dev_priv->mm.idle_work);

	return 0;

err:
	mutex_unlock(&dev->struct_mutex);
	return ret;
}

int i915_gem_l3_remap(struct intel_ring_buffer *ring, int slice)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	u32 reg_base = GEN7_L3LOG_BASE + (slice * 0x200);
	u32 *remap_info = dev_priv->l3_parity.remap_info[slice];
	int i, ret;

	if (!HAS_L3_DPF(dev) || !remap_info)
		return 0;

	ret = intel_ring_begin(ring, GEN7_L3LOG_SIZE / 4 * 3);
	if (ret)
		return ret;

	/*
	 * Note: We do not worry about the concurrent register cacheline hang
	 * here because no other code should access these registers other than
	 * at initialization time.
	 */
	for (i = 0; i < GEN7_L3LOG_SIZE; i += 4) {
		intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
		intel_ring_emit(ring, reg_base + i);
		intel_ring_emit(ring, remap_info[i/4]);
	}

	intel_ring_advance(ring);

	return ret;
}

void i915_gem_init_swizzling(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;

	if (INTEL_INFO(dev)->gen < 5 ||
	    dev_priv->mm.bit_6_swizzle_x == I915_BIT_6_SWIZZLE_NONE)
		return;

	I915_WRITE(DISP_ARB_CTL, I915_READ(DISP_ARB_CTL) |
				 DISP_TILE_SURFACE_SWIZZLING);

	if (IS_GEN5(dev))
		return;

	I915_WRITE(TILECTL, I915_READ(TILECTL) | TILECTL_SWZCTL);
	if (IS_GEN6(dev))
		I915_WRITE(ARB_MODE, _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_SNB));
	else if (IS_GEN7(dev))
		I915_WRITE(ARB_MODE, _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_IVB));
	else if (IS_GEN8(dev))
		I915_WRITE(GAMTARBMODE, _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_BDW));
	else
		BUG();
}

static bool
intel_enable_blt(struct drm_device *dev)
{
	if (!HAS_BLT(dev))
		return false;

#ifdef notyet
	/* The blitter was dysfunctional on early prototypes */
	if (IS_GEN6(dev) && dev->pdev->revision < 8) {
		DRM_INFO("BLT not supported on this pre-production hardware;"
			 " graphics performance will be degraded.\n");
		return false;
	}
#endif

	return true;
}

static int i915_gem_init_rings(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	ret = intel_init_render_ring_buffer(dev);
	if (ret)
		return ret;

	if (HAS_BSD(dev)) {
		ret = intel_init_bsd_ring_buffer(dev);
		if (ret)
			goto cleanup_render_ring;
	}

	if (intel_enable_blt(dev)) {
		ret = intel_init_blt_ring_buffer(dev);
		if (ret)
			goto cleanup_bsd_ring;
	}

	if (HAS_VEBOX(dev)) {
		ret = intel_init_vebox_ring_buffer(dev);
		if (ret)
			goto cleanup_blt_ring;
	}


	ret = i915_gem_set_seqno(dev, ((u32)~0 - 0x1000));
	if (ret)
		goto cleanup_vebox_ring;

	return 0;

cleanup_vebox_ring:
	intel_cleanup_ring_buffer(&dev_priv->ring[VECS]);
cleanup_blt_ring:
	intel_cleanup_ring_buffer(&dev_priv->ring[BCS]);
cleanup_bsd_ring:
	intel_cleanup_ring_buffer(&dev_priv->ring[VCS]);
cleanup_render_ring:
	intel_cleanup_ring_buffer(&dev_priv->ring[RCS]);

	return ret;
}

int
i915_gem_init_hw(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret, i;

#ifdef notyet
	if (INTEL_INFO(dev)->gen < 6 && !intel_enable_gtt())
		return -EIO;
#endif

	if (dev_priv->ellc_size)
		I915_WRITE(HSW_IDICR, I915_READ(HSW_IDICR) | IDIHASHMSK(0xf));

	if (IS_HASWELL(dev))
		I915_WRITE(MI_PREDICATE_RESULT_2, IS_HSW_GT3(dev) ?
			   LOWER_SLICE_ENABLED : LOWER_SLICE_DISABLED);

	if (HAS_PCH_NOP(dev)) {
		u32 temp = I915_READ(GEN7_MSG_CTL);
		temp &= ~(WAIT_FOR_PCH_FLR_ACK | WAIT_FOR_PCH_RESET_ACK);
		I915_WRITE(GEN7_MSG_CTL, temp);
	}

	i915_gem_init_swizzling(dev);

	ret = i915_gem_init_rings(dev);
	if (ret)
		return ret;

	for (i = 0; i < NUM_L3_SLICES(dev); i++)
		i915_gem_l3_remap(&dev_priv->ring[RCS], i);

	/*
	 * XXX: There was some w/a described somewhere suggesting loading
	 * contexts before PPGTT.
	 */
	ret = i915_gem_context_init(dev);
	if (ret) {
		i915_gem_cleanup_ringbuffer(dev);
		DRM_ERROR("Context initialization failed %d\n", ret);
		return ret;
	}

	if (dev_priv->mm.aliasing_ppgtt) {
		ret = dev_priv->mm.aliasing_ppgtt->enable(dev);
		if (ret) {
			i915_gem_cleanup_aliasing_ppgtt(dev);
			DRM_INFO("PPGTT enable failed. This is not fatal, but unexpected\n");
		}
	}

	return 0;
}

int i915_gem_init(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	mutex_lock(&dev->struct_mutex);

	if (IS_VALLEYVIEW(dev)) {
		/* VLVA0 (potential hack), BIOS isn't actually waking us */
		I915_WRITE(VLV_GTLC_WAKE_CTRL, 1);
		if (wait_for((I915_READ(VLV_GTLC_PW_STATUS) & 1) == 1, 10))
			DRM_DEBUG_DRIVER("allow wake ack timed out\n");
	}

	i915_gem_init_global_gtt(dev);

	ret = i915_gem_init_hw(dev);
	mutex_unlock(&dev->struct_mutex);
	if (ret) {
		i915_gem_cleanup_aliasing_ppgtt(dev);
		return ret;
	}

#ifdef __linux__
	/* Allow hardware batchbuffers unless told otherwise, but not for KMS. */
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		dev_priv->dri1.allow_batchbuffer = 1;
#endif
	return 0;
}

void
i915_gem_cleanup_ringbuffer(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	int i;

	for_each_ring(ring, dev_priv, i)
		intel_cleanup_ring_buffer(ring);
}

int
i915_gem_entervt_ioctl(struct drm_device *dev, void *data,
		       struct drm_file *file_priv)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return 0;

	if (i915_reset_in_progress(&dev_priv->gpu_error)) {
		DRM_ERROR("Reenabling wedged hardware, good luck\n");
		atomic_set(&dev_priv->gpu_error.reset_counter, 0);
	}

	mutex_lock(&dev->struct_mutex);
	dev_priv->ums.mm_suspended = 0;

	ret = i915_gem_init_hw(dev);
	if (ret != 0) {
		mutex_unlock(&dev->struct_mutex);
		return ret;
	}

	BUG_ON(!list_empty(&dev_priv->gtt.base.active_list));
	mutex_unlock(&dev->struct_mutex);

	ret = drm_irq_install(dev);
	if (ret)
		goto cleanup_ringbuffer;

	return 0;

cleanup_ringbuffer:
	mutex_lock(&dev->struct_mutex);
	i915_gem_cleanup_ringbuffer(dev);
	dev_priv->ums.mm_suspended = 1;
	mutex_unlock(&dev->struct_mutex);

	return ret;
}

int
i915_gem_leavevt_ioctl(struct drm_device *dev, void *data,
		       struct drm_file *file_priv)
{
	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return 0;

	drm_irq_uninstall(dev);

	return i915_gem_suspend(dev);
}

void
i915_gem_lastclose(struct drm_device *dev)
{
	int ret;

	if (drm_core_check_feature(dev, DRIVER_MODESET))
		return;

	ret = i915_gem_suspend(dev);
	if (ret)
		DRM_ERROR("failed to idle hardware: %d\n", ret);
}

static void
init_ring_lists(struct intel_ring_buffer *ring)
{
	INIT_LIST_HEAD(&ring->active_list);
	INIT_LIST_HEAD(&ring->request_list);
}

static void i915_init_vm(struct drm_i915_private *dev_priv,
			 struct i915_address_space *vm)
{
	vm->dev = dev_priv->dev;
	INIT_LIST_HEAD(&vm->active_list);
	INIT_LIST_HEAD(&vm->inactive_list);
	INIT_LIST_HEAD(&vm->global_link);
	list_add(&vm->global_link, &dev_priv->vm_list);
}

void
i915_gem_load(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	int i;

#ifdef __linux__
	dev_priv->slab =
		kmem_cache_create("i915_gem_object",
				  sizeof(struct drm_i915_gem_object), 0,
				  SLAB_HWCACHE_ALIGN,
				  NULL);
#endif

	INIT_LIST_HEAD(&dev_priv->vm_list);
	i915_init_vm(dev_priv, &dev_priv->gtt.base);

	INIT_LIST_HEAD(&dev_priv->context_list);
	INIT_LIST_HEAD(&dev_priv->mm.unbound_list);
	INIT_LIST_HEAD(&dev_priv->mm.bound_list);
	INIT_LIST_HEAD(&dev_priv->mm.fence_list);
	for (i = 0; i < I915_NUM_RINGS; i++)
		init_ring_lists(&dev_priv->ring[i]);
	for (i = 0; i < I915_MAX_NUM_FENCES; i++)
		INIT_LIST_HEAD(&dev_priv->fence_regs[i].lru_list);
	INIT_DELAYED_WORK(&dev_priv->mm.retire_work,
			  i915_gem_retire_work_handler);
	INIT_DELAYED_WORK(&dev_priv->mm.idle_work,
			  i915_gem_idle_work_handler);
	init_waitqueue_head(&dev_priv->gpu_error.reset_queue);

	/* On GEN3 we really need to make sure the ARB C3 LP bit is set */
	if (IS_GEN3(dev)) {
		I915_WRITE(MI_ARB_STATE,
			   _MASKED_BIT_ENABLE(MI_ARB_C3_LP_WRITE_ENABLE));
	}

	dev_priv->relative_constants_mode = I915_EXEC_CONSTANTS_REL_GENERAL;

	/* Old X drivers will take 0-2 for front, back, depth buffers */
	if (!drm_core_check_feature(dev, DRIVER_MODESET))
		dev_priv->fence_reg_start = 3;

	if (INTEL_INFO(dev)->gen >= 7 && !IS_VALLEYVIEW(dev))
		dev_priv->num_fence_regs = 32;
	else if (INTEL_INFO(dev)->gen >= 4 || IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev))
		dev_priv->num_fence_regs = 16;
	else
		dev_priv->num_fence_regs = 8;

	/* Initialize fence registers to zero */
	INIT_LIST_HEAD(&dev_priv->mm.fence_list);
	i915_gem_restore_fences(dev);

	i915_gem_detect_bit_6_swizzle(dev);
	init_waitqueue_head(&dev_priv->pending_flip_queue);

	dev_priv->mm.interruptible = true;

#ifdef notyet
	dev_priv->mm.inactive_shrinker.scan_objects = i915_gem_inactive_scan;
	dev_priv->mm.inactive_shrinker.count_objects = i915_gem_inactive_count;
	dev_priv->mm.inactive_shrinker.seeks = DEFAULT_SEEKS;
	register_shrinker(&dev_priv->mm.inactive_shrinker);
#endif
}

/*
 * Create a physically contiguous memory object for this object
 * e.g. for cursor + overlay regs
 */
static int i915_gem_init_phys_object(struct drm_device *dev,
				     int id, int size, int align)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_i915_gem_phys_object *phys_obj;
	int ret;

	if (dev_priv->mm.phys_objs[id - 1] || !size)
		return 0;

	phys_obj = kzalloc(sizeof(*phys_obj), GFP_KERNEL);
	if (!phys_obj)
		return -ENOMEM;

	phys_obj->id = id;

	phys_obj->handle = drm_dmamem_alloc(dev->dmat, size, align, 1, size, BUS_DMA_NOCACHE, 0);
	if (!phys_obj->handle) {
		ret = -ENOMEM;
		goto kfree_obj;
	}

	dev_priv->mm.phys_objs[id - 1] = phys_obj;

	return 0;
kfree_obj:
	kfree(phys_obj);
	return ret;
}

#ifdef notyet
static void i915_gem_free_phys_object(struct drm_device *dev, int id)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_i915_gem_phys_object *phys_obj;

	if (!dev_priv->mm.phys_objs[id - 1])
		return;

	phys_obj = dev_priv->mm.phys_objs[id - 1];
	if (phys_obj->cur_obj) {
		i915_gem_detach_phys_object(dev, phys_obj->cur_obj);
	}

#ifdef CONFIG_X86
	set_memory_wb((unsigned long)phys_obj->handle->vaddr, phys_obj->handle->size / PAGE_SIZE);
#endif
	drm_pci_free(dev, phys_obj->handle);
	kfree(phys_obj);
	dev_priv->mm.phys_objs[id - 1] = NULL;
}

void i915_gem_free_all_phys_object(struct drm_device *dev)
{
	int i;

	for (i = I915_GEM_PHYS_CURSOR_0; i <= I915_MAX_PHYS_OBJECT; i++)
		i915_gem_free_phys_object(dev, i);
}
#endif /* notyet */

void i915_gem_detach_phys_object(struct drm_device *dev,
				 struct drm_i915_gem_object *obj)
{
	char *vaddr;
	int i;
	int page_count;

	if (!obj->phys_obj)
		return;
	vaddr = obj->phys_obj->handle->kva;

	page_count = obj->base.size / PAGE_SIZE;
	for (i = 0; i < page_count; i++) {
#ifdef notyet
		struct page *page = shmem_read_mapping_page(mapping, i);
		if (!IS_ERR(page)) {
			char *dst = kmap_atomic(page);
			memcpy(dst, vaddr + i*PAGE_SIZE, PAGE_SIZE);
			kunmap_atomic(dst);

			drm_clflush_pages(&page, 1);

			set_page_dirty(page);
			mark_page_accessed(page);
			page_cache_release(page);
		}
#endif
	}
	i915_gem_chipset_flush(dev);

	obj->phys_obj->cur_obj = NULL;
	obj->phys_obj = NULL;
}

int
i915_gem_attach_phys_object(struct drm_device *dev,
			    struct drm_i915_gem_object *obj,
			    int id,
			    int align)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret = 0;
	int page_count;
	int i;

	if (id > I915_MAX_PHYS_OBJECT)
		return -EINVAL;

	if (obj->phys_obj) {
		if (obj->phys_obj->id == id)
			return 0;
		i915_gem_detach_phys_object(dev, obj);
	}

	/* create a new object */
	if (!dev_priv->mm.phys_objs[id - 1]) {
		ret = i915_gem_init_phys_object(dev, id,
						obj->base.size, align);
		if (ret) {
			DRM_ERROR("failed to init phys object %d size: %zu\n",
				  id, obj->base.size);
			return ret;
		}
	}

	/* bind to the object */
	obj->phys_obj = dev_priv->mm.phys_objs[id - 1];
	obj->phys_obj->cur_obj = obj;

	page_count = obj->base.size / PAGE_SIZE;

	for (i = 0; i < page_count; i++) {
#ifdef notyet
		struct page *page;
		char *dst, *src;

		page = shmem_read_mapping_page(mapping, i);
		if (IS_ERR(page))
			return PTR_ERR(page);

		src = kmap_atomic(page);
		dst = obj->phys_obj->handle->kva + (i * PAGE_SIZE);
		memcpy(dst, src, PAGE_SIZE);
		kunmap_atomic(src);

		mark_page_accessed(page);
		page_cache_release(page);
#endif
	}

	return 0;
}

static int
i915_gem_phys_pwrite(struct drm_device *dev,
		     struct drm_i915_gem_object *obj,
		     struct drm_i915_gem_pwrite *args,
		     struct drm_file *file_priv)
{
	void *vaddr = obj->phys_obj->handle->kva + args->offset;
	char __user *user_data = to_user_ptr(args->data_ptr);

	if (__copy_from_user_inatomic_nocache(vaddr, user_data, args->size)) {
		unsigned long unwritten;

		/* The physical object once assigned is fixed for the lifetime
		 * of the obj, so we can safely drop the lock and continue
		 * to access vaddr.
		 */
		mutex_unlock(&dev->struct_mutex);
		unwritten = copy_from_user(vaddr, user_data, args->size);
		mutex_lock(&dev->struct_mutex);
		if (unwritten)
			return -EFAULT;
	}

	i915_gem_chipset_flush(dev);
	return 0;
}

void i915_gem_release(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_file_private *file_priv = file->driver_priv;

	cancel_delayed_work_sync(&file_priv->mm.idle_work);

	/* Clean up our request list when the client is going away, so that
	 * later retire_requests won't dereference our soon-to-be-gone
	 * file_priv.
	 */
	spin_lock(&file_priv->mm.lock);
	while (!list_empty(&file_priv->mm.request_list)) {
		struct drm_i915_gem_request *request;

		request = list_first_entry(&file_priv->mm.request_list,
					   struct drm_i915_gem_request,
					   client_list);
		list_del(&request->client_list);
		request->file_priv = NULL;
	}
	spin_unlock(&file_priv->mm.lock);
}

static void
i915_gem_file_idle_work_handler(struct work_struct *work)
{
	struct drm_i915_file_private *file_priv =
		container_of(work, typeof(*file_priv), mm.idle_work.work);

	atomic_set(&file_priv->rps_wait_boost, false);
}

int i915_gem_open(struct drm_device *dev, struct drm_file *file)
{
	struct drm_i915_file_private *file_priv;

	DRM_DEBUG_DRIVER("\n");

	file_priv = kzalloc(sizeof(*file_priv), GFP_KERNEL);
	if (!file_priv)
		return -ENOMEM;

	file->driver_priv = file_priv;
	file_priv->dev_priv = dev->dev_private;

	mtx_init(&file_priv->mm.lock, IPL_NONE);
	INIT_LIST_HEAD(&file_priv->mm.request_list);
	INIT_DELAYED_WORK(&file_priv->mm.idle_work,
			  i915_gem_file_idle_work_handler);

	idr_init(&file_priv->context_idr);

	return 0;
}

#ifdef notyet
static bool mutex_is_locked_by(struct mutex *mutex, struct task_struct *task)
{
	if (!mutex_is_locked(mutex))
		return false;

#if defined(CONFIG_SMP) && !defined(CONFIG_DEBUG_MUTEXES)
	return mutex->owner == task;
#else
	/* Since UP may be pre-empted, we cannot assume that we own the lock */
	return false;
#endif
}

static unsigned long
i915_gem_inactive_count(struct shrinker *shrinker, struct shrink_control *sc)
{
	struct drm_i915_private *dev_priv =
		container_of(shrinker,
			     struct drm_i915_private,
			     mm.inactive_shrinker);
	struct drm_device *dev = dev_priv->dev;
	struct drm_i915_gem_object *obj;
	bool unlock = true;
	unsigned long count;

	if (!mutex_trylock(&dev->struct_mutex)) {
		if (!mutex_is_locked_by(&dev->struct_mutex, current))
			return 0;

		if (dev_priv->mm.shrinker_no_lock_stealing)
			return 0;

		unlock = false;
	}

	count = 0;
	list_for_each_entry(obj, &dev_priv->mm.unbound_list, global_list)
		if (obj->pages_pin_count == 0)
			count += obj->base.size >> PAGE_SHIFT;

	list_for_each_entry(obj, &dev_priv->mm.bound_list, global_list) {
		if (obj->active)
			continue;

		if (obj->pin_count == 0 && obj->pages_pin_count == 0)
			count += obj->base.size >> PAGE_SHIFT;
	}

	if (unlock)
		mutex_unlock(&dev->struct_mutex);

	return count;
}
#endif

/* All the new VM stuff */
unsigned long i915_gem_obj_offset(struct drm_i915_gem_object *o,
				  struct i915_address_space *vm)
{
	struct drm_i915_private *dev_priv = o->base.dev->dev_private;
	struct i915_vma *vma;

	if (vm == &dev_priv->mm.aliasing_ppgtt->base)
		vm = &dev_priv->gtt.base;

	BUG_ON(list_empty(&o->vma_list));
	list_for_each_entry(vma, &o->vma_list, vma_link) {
		if (vma->vm == vm)
			return vma->node.start;

	}
	return -1;
}

bool i915_gem_obj_bound(struct drm_i915_gem_object *o,
			struct i915_address_space *vm)
{
	struct i915_vma *vma;

	list_for_each_entry(vma, &o->vma_list, vma_link)
		if (vma->vm == vm && drm_mm_node_allocated(&vma->node))
			return true;

	return false;
}

bool i915_gem_obj_bound_any(struct drm_i915_gem_object *o)
{
	struct i915_vma *vma;

	list_for_each_entry(vma, &o->vma_list, vma_link)
		if (drm_mm_node_allocated(&vma->node))
			return true;

	return false;
}

unsigned long i915_gem_obj_size(struct drm_i915_gem_object *o,
				struct i915_address_space *vm)
{
	struct drm_i915_private *dev_priv = o->base.dev->dev_private;
	struct i915_vma *vma;

	if (vm == &dev_priv->mm.aliasing_ppgtt->base)
		vm = &dev_priv->gtt.base;

	BUG_ON(list_empty(&o->vma_list));

	list_for_each_entry(vma, &o->vma_list, vma_link)
		if (vma->vm == vm)
			return vma->node.size;

	return 0;
}

#ifdef notyet
static unsigned long
i915_gem_inactive_scan(struct shrinker *shrinker, struct shrink_control *sc)
{
	struct drm_i915_private *dev_priv =
		container_of(shrinker,
			     struct drm_i915_private,
			     mm.inactive_shrinker);
	struct drm_device *dev = dev_priv->dev;
	unsigned long freed;
	bool unlock = true;

	if (!mutex_trylock(&dev->struct_mutex)) {
		if (!mutex_is_locked_by(&dev->struct_mutex, current))
			return SHRINK_STOP;

		if (dev_priv->mm.shrinker_no_lock_stealing)
			return SHRINK_STOP;

		unlock = false;
	}

	freed = i915_gem_purge(dev_priv, sc->nr_to_scan);
	if (freed < sc->nr_to_scan)
		freed += __i915_gem_shrink(dev_priv,
					   sc->nr_to_scan - freed,
					   false);
	if (freed < sc->nr_to_scan)
		freed += i915_gem_shrink_all(dev_priv);

	if (unlock)
		mutex_unlock(&dev->struct_mutex);

	return freed;
}
#endif /* notyet */

struct i915_vma *i915_gem_obj_to_ggtt(struct drm_i915_gem_object *obj)
{
	struct i915_vma *vma;

	if (WARN_ON(list_empty(&obj->vma_list)))
		return NULL;

	vma = list_first_entry(&obj->vma_list, typeof(*vma), vma_link);
	if (WARN_ON(vma->vm != obj_to_ggtt(obj)))
		return NULL;

	return vma;
}
@


1.105
log
@Split out the generic GEM code (like Linux did) and switch it over to
the vma offset manager.  This brings us a little bit more isolation between
applications as GEM buffers are now tied to a specific /dev/drmX clone.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.104 2015/10/19 19:54:35 kettenis Exp $	*/
a5290 1
#ifdef __linux__
a5291 3
#else
	SPLAY_INIT(&file_priv->ctx_tree);
#endif
@


1.104
log
@Enable some code that does power management magic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.103 2015/10/07 09:53:00 kettenis Exp $	*/
d45 1
a45 1
#include <dev/pci/drm/drm.h>
d262 3
a264 4
	if (ret) {
		drm_gem_object_release(&obj->base);
		i915_gem_info_remove_obj(dev->dev_private, obj->base.size);
		pool_put(&dev->objpl, obj);
a265 4
	}

	/* drop reference from allocate - handle holds it now */
	drm_gem_object_unreference(&obj->base);
d1573 2
a1574 1
	if (!obj->base.map || RWLOCK_OWNER(&dev->struct_mutex) == curproc) {
d1581 1
a1581 1
	offset -= obj->base.map->ext;
d1744 1
d1802 1
a1802 1
	if (obj->base.map)
a1836 3
	if (!obj->base.map)
		return;

d1875 1
a1875 1
	*offset = (u64)obj->base.map->ext;
@


1.103
log
@In i915_gem_fault(), move the "out" label after the switch state such that we
don't interpret one of the VM_PAGER_XXX return values as an unhandled errno
value and return the intended code instead of VM_PAGER_ERROR.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.102 2015/09/30 06:29:09 kettenis Exp $	*/
a1062 1
#ifdef notyet
a1069 1
#endif
a1211 1
#ifdef notyet
a1218 1
#endif
@


1.102
log
@I missed an #ifdef notyet when enabling the aliasing ppgtt code.
Hopefully this fixes the stability problems people have been seeing on
sandybridge and up after the ppgtt code got enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.101 2015/09/24 20:52:28 kettenis Exp $	*/
d1662 1
a1662 1
out:
d1703 1
@


1.101
log
@Properly implement waitqueue_active().  Gets rid of spurious

  *ERROR* Hangcheck timer elapsed... xxx ring idle

messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.100 2015/09/23 23:12:12 kettenis Exp $	*/
a3086 1
#ifdef notyet
a3090 1
#endif
@


1.100
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.99 2015/07/16 18:48:51 kettenis Exp $	*/
d1231 1
d1276 1
d1287 1
@


1.99
log
@Introduce a Linux compatible wait_event API and use it in the inteldrm code.

ok jsg@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.98 2015/06/26 15:22:23 kettenis Exp $	*/
a52 4
#include <sys/queue.h>
#include <sys/task.h>
#include <sys/time.h>

d54 11
a64 5
static void i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj);
static __must_check int i915_gem_object_bind_to_gtt(struct drm_i915_gem_object *obj,
						    unsigned alignment,
						    bool map_and_fenceable,
						    bool nonblocking);
d77 6
a82 4
static int i915_gem_inactive_shrink(struct shrinker *shrinker,
				    struct shrink_control *sc);
static long i915_gem_purge(struct drm_i915_private *dev_priv, long target);
static void i915_gem_shrink_all(struct drm_i915_private *dev_priv);
d86 14
d116 1
d119 1
d125 1
d128 1
d132 1
a132 1
i915_gem_wait_for_error(struct drm_device *dev)
a133 3
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct completion *x = &dev_priv->error_completion;
	unsigned long flags;
d136 3
a138 1
	if (!atomic_read(&dev_priv->mm.wedged))
d146 3
a148 1
	ret = wait_for_completion_interruptible_timeout(x, 10*HZ);
d155 1
a156 10
	if (atomic_read(&dev_priv->mm.wedged)) {
		/* GPU is hung, bump the completion count to account for
		 * the token we just consumed so that we never hit zero and
		 * end up waiting upon a subsequent completion event that
		 * will never happen.
		 */
		spin_lock_irqsave(&x->wait.lock, flags);
		x->done++;
		spin_unlock_irqrestore(&x->wait.lock, flags);
	}
d162 1
d165 1
a165 1
	ret = i915_gem_wait_for_error(dev);
d180 1
a180 1
	return obj->gtt_space && !obj->active;
d187 1
d202 3
a204 2
	i915_gem_init_global_gtt(dev, args->gtt_start,
				 args->gtt_end, args->gtt_end);
d221 1
a221 1
	list_for_each_entry(obj, &dev_priv->mm.bound_list, gtt_list)
d223 1
a223 1
			pinned += obj->gtt_space->size;
d226 1
a226 1
	args->aper_size = dev_priv->mm.gtt_total;
d232 10
a270 1
	trace_i915_gem_object_create(obj);
d282 1
a282 1
	args->pitch = roundup2(args->width * ((args->bpp + 7) / 8), 64);
a287 7
int i915_gem_dumb_destroy(struct drm_file *file,
			  struct drm_device *dev,
			  uint32_t handle)
{
	return drm_gem_handle_delete(file, handle);
}

a300 8
static int i915_gem_object_needs_bit17_swizzle(struct drm_i915_gem_object *obj)
{
	drm_i915_private_t *dev_priv = obj->base.dev->dev_private;

	return dev_priv->mm.bit_6_swizzle_x == I915_BIT_6_SWIZZLE_9_10_17 &&
		obj->tiling_mode != I915_TILING_NONE;
}

d444 1
a444 1
	off_t offset;
a446 1
	int hit_slowpath = 0;
d450 1
a450 1
	user_data = (char __user *) (uintptr_t) args->data_ptr;
d460 4
a463 7
		if (obj->cache_level == I915_CACHE_NONE)
			needs_clflush = 1;
		if (obj->gtt_space) {
			ret = i915_gem_object_set_to_gtt_domain(obj, false);
			if (ret)
				return ret;
		}
d477 1
a477 1
		if (i < offset >> PAGE_SHIFT)
a506 1
		hit_slowpath = 1;
d510 1
a510 1
		if (!prefaulted) {
a542 6
	if (hit_slowpath) {
		/* Fixup: Kill any reinstated backing storage pages */
		if (obj->madv == __I915_MADV_PURGED)
			i915_gem_object_truncate(obj);
	}

d562 5
d584 10
d671 1
a671 1
	ret = i915_gem_object_pin(obj, 0, true, true);
d683 1
a683 1
	user_data = (char __user *) (uintptr_t) args->data_ptr;
d686 1
a686 1
	offset = obj->gtt_offset + args->offset;
d795 1
a795 1
	off_t offset;
d804 1
a804 1
	user_data = (char __user *) (uintptr_t) args->data_ptr;
d814 4
a817 7
		if (obj->cache_level == I915_CACHE_NONE)
			needs_clflush_after = 1;
		if (obj->gtt_space) {
			ret = i915_gem_object_set_to_gtt_domain(obj, true);
			if (ret)
				return ret;
		}
d819 5
a823 5
	/* Same trick applies for invalidate partially written cachelines before
	 * writing.  */
	if (!(obj->base.read_domains & I915_GEM_DOMAIN_CPU)
	    && obj->cache_level == I915_CACHE_NONE)
		needs_clflush_before = 1;
d838 1
a838 1
		if (i < offset >> PAGE_SHIFT)
d904 9
a912 8
		/* Fixup: Kill any reinstated backing storage pages */
		if (obj->madv == __I915_MADV_PURGED)
			i915_gem_object_truncate(obj);
		/* and flush dirty cachelines in case the object isn't in the cpu write
		 * domain anymore. */
		if (obj->base.write_domain != I915_GEM_DOMAIN_CPU) {
			i915_gem_clflush_object(obj);
			i915_gem_chipset_flush(dev);
d938 14
d969 10
d993 3
a995 3
	if (obj->cache_level == I915_CACHE_NONE &&
	    obj->tiling_mode == I915_TILING_NONE &&
	    obj->base.write_domain != I915_GEM_DOMAIN_CPU) {
d1013 1
a1013 1
i915_gem_check_wedge(struct drm_i915_private *dev_priv,
d1016 1
a1016 10
	if (atomic_read(&dev_priv->mm.wedged)) {
		struct completion *x = &dev_priv->error_completion;
		bool recovery_complete;
		unsigned long flags;

		/* Give the error handler a chance to run. */
		spin_lock_irqsave(&x->wait.lock, flags);
		recovery_complete = x->done > 0;
		spin_unlock_irqrestore(&x->wait.lock, flags);

d1022 2
a1023 2
		/* Recovery complete, but still wedged means reset failure. */
		if (recovery_complete)
d1044 2
a1045 2
	if (seqno == ring->outstanding_lazy_request)
		ret = i915_add_request(ring, NULL, NULL);
d1050 23
d1077 1
d1081 7
d1091 1
d1093 4
a1096 1
			bool interruptible, struct timespec *timeout)
d1099 5
a1103 5
	struct timespec before, now, wait_time={1,0};
	struct timespec sleep_time;
	unsigned long timeout_jiffies;
	long end;
	bool wait_forever = true;
d1106 2
d1111 14
d1126 3
d1130 58
a1187 3
	if (timeout != NULL) {
		wait_time = *timeout;
		wait_forever = false;
d1190 33
a1222 1
	timeout_jiffies = timespec_to_jiffies(&wait_time);
d1224 1
a1224 1
	if (WARN_ON(!ring->irq_get(ring)))
d1227 2
a1228 1
	/* Record current time in case interrupted by signal, or wedged * */
d1230 28
d1259 10
a1268 11
#define EXIT_COND \
	(i915_seqno_passed(ring->get_seqno(ring, false), seqno) || \
	atomic_read(&dev_priv->mm.wedged))
	do {
		if (interruptible)
			end = wait_event_interruptible_timeout(ring->irq_queue,
							       EXIT_COND,
							       timeout_jiffies);
		else
			end = wait_event_timeout(ring->irq_queue, EXIT_COND,
						 timeout_jiffies);
d1270 1
a1270 4
		ret = i915_gem_check_wedge(dev_priv, interruptible);
		if (ret)
			end = ret;
	} while (end == 0 && wait_forever);
d1272 4
d1277 4
d1282 3
a1284 3
	ring->irq_put(ring);
	trace_i915_gem_request_wait_end(ring, seqno);
#undef EXIT_COND
d1287 4
a1290 2
		timespecsub(&now, &before, &sleep_time);
		timespecsub(timeout, &sleep_time, timeout);
d1293 1
a1293 13
	switch (end) {
	case -EIO:
	case -EAGAIN: /* Wedged */
	case -ERESTARTSYS: /* Signal */
		return (int)end;
	case 0: /* Timeout */
		if (timeout)
			set_normalized_timespec(timeout, 0, 0);
		return -ETIME;
	default: /* Completed */
		WARN_ON(end < 0); /* We're not aware of other errors */
		return 0;
	}
d1295 1
d1312 1
a1312 1
	ret = i915_gem_check_wedge(dev_priv, interruptible);
d1320 22
a1341 1
	return __wait_seqno(ring, seqno, interruptible, NULL);
d1364 1
a1364 12
	i915_gem_retire_requests_ring(ring);

	/* Manually manage the write flush as we may have not yet
	 * retired the buffer.
	 */
	if (obj->last_write_seqno &&
	    i915_seqno_passed(seqno, obj->last_write_seqno)) {
		obj->last_write_seqno = 0;
		obj->base.write_domain &= ~I915_GEM_GPU_DOMAINS;
	}

	return 0;
d1372 1
d1378 1
d1389 1
a1389 1
	ret = i915_gem_check_wedge(dev_priv, true);
d1397 1
d1399 1
a1399 1
	ret = __wait_seqno(ring, seqno, true, NULL);
d1401 2
d1404 1
a1404 13
	i915_gem_retire_requests_ring(ring);

	/* Manually manage the write flush as we may have not yet
	 * retired the buffer.
	 */
	if (ret == 0 &&
	    obj->last_write_seqno &&
	    i915_seqno_passed(seqno, obj->last_write_seqno)) {
		obj->last_write_seqno = 0;
		obj->base.write_domain &= ~I915_GEM_GPU_DOMAINS;
	}

	return ret;
d1448 1
a1448 1
	ret = i915_gem_object_wait_rendering__nonblocking(obj, !write_domain);
d1494 2
a1495 2
	if (obj->pin_count)
		i915_gem_object_flush_cpu_write_domain(obj);
d1533 10
d1567 1
a1567 1
	int lcv, ret;
d1572 1
a1572 1
	dev_priv->entries++;
d1582 2
a1583 2
		dev_priv->entries--;
		return (VM_PAGER_BAD);
d1595 8
a1602 2
		dev_priv->entries--;
		return (VM_PAGER_REFAULT);
d1606 1
a1606 1
	ret = i915_gem_object_pin(obj, 0, true, false);
d1638 2
a1639 1
		paddr = dev_priv->mm.gtt_base_addr + obj->gtt_offset + offset;
a1646 1
			dev_priv->entries--;
d1649 2
a1650 1
			return (VM_PAGER_REFAULT);
a1657 1
	dev_priv->entries--;
d1659 1
a1659 1

d1662 10
a1671 5
		/* If this -EIO is due to a gpu hang, give the reset code a
		 * chance to clean up the mess. Otherwise return the proper
		 * SIGBUS. */
		if (!atomic_read(&dev_priv->mm.wedged))
			return VM_PAGER_ERROR;
d1673 4
a1676 6
		/* Give the error handler a chance to run and move the
		 * objects off the GPU active list. Next time we service the
		 * fault, we should be able to transition the page into the
		 * GTT without touching the GPU (and so avoid further
		 * EIO/EGAIN). If the GPU is wedged, then there is no issue
		 * with coherency, just lost writes.
a1677 3
#if 0
		set_need_resched();
#endif
d1686 2
a1687 1
		return VM_PAGER_OK;
d1689 2
a1690 1
		return VM_PAGER_ERROR;
d1692 2
a1693 1
		return VM_PAGER_ERROR;
d1696 2
a1697 1
		return VM_PAGER_ERROR;
d1699 19
d1743 2
a1744 2
	for (pg = &dev_priv->pgs[atop(obj->gtt_offset)];
	     pg != &dev_priv->pgs[atop(obj->gtt_offset + obj->base.size)];
d1751 1
a1751 1
static uint32_t
d1779 3
a1781 4
static uint32_t
i915_gem_get_gtt_alignment(struct drm_device *dev,
			   uint32_t size,
			   int tiling_mode)
d1787 1
a1787 1
	if (INTEL_INFO(dev)->gen >= 4 ||
a1797 29
/**
 * i915_gem_get_unfenced_gtt_alignment - return required GTT alignment for an
 *					 unfenced object
 * @@dev: the device
 * @@size: size of the object
 * @@tiling_mode: tiling mode of the object
 *
 * Return the required GTT alignment for an object, only taking into account
 * unfenced tiled surface requirements.
 */
uint32_t
i915_gem_get_unfenced_gtt_alignment(struct drm_device *dev,
				    uint32_t size,
				    int tiling_mode)
{
	/*
	 * Minimum alignment is 4k (GTT page size) for sane hw.
	 */
	if (INTEL_INFO(dev)->gen >= 4 || IS_G33(dev) ||
	    tiling_mode == I915_TILING_NONE)
		return 4096;

	/* Previous hardware however needs to be aligned to a power-of-two
	 * tile height. The simplest method for determining this is to reuse
	 * the power-of-tile object size.
	 */
	return i915_gem_get_gtt_size(dev, size, tiling_mode);
}

d1866 1
a1866 1
	if (obj->base.size > dev_priv->mm.gtt_mappable_end) {
a1934 1
	int page_count = obj->base.size / PAGE_SIZE;
d1936 3
a1938 1
	struct scatterlist *sg;
d1940 1
a1940 1
	int ret, i;
d1950 1
a1950 1
		i915_gem_clflush_object(obj);
d1961 2
a1962 2
	for_each_sg(obj->pages->sgl, sg, page_count, i) {
		struct page *page = sg_page(sg);
d1989 1
a1989 1
static int
a1996 2
	BUG_ON(obj->gtt_space);

d2000 2
d2005 1
a2005 1
	list_del(&obj->gtt_list);
d2017 1
a2017 1
static long
d2021 1
d2023 1
a2023 1
	long count = 0;
d2027 1
a2027 1
				 gtt_list) {
d2036 44
a2079 6
	list_for_each_entry_safe(obj, next,
				 &dev_priv->mm.inactive_list,
				 mm_list) {
		if ((i915_gem_object_is_purgeable(obj) || !purgeable_only) &&
		    i915_gem_object_unbind(obj) == 0 &&
		    i915_gem_object_put_pages(obj) == 0) {
d2081 2
a2082 3
			if (count >= target)
				return count;
		}
d2084 1
d2089 1
a2089 1
static long
d2095 1
a2095 1
static void
d2099 1
d2103 6
a2108 2
	list_for_each_entry_safe(obj, next, &dev_priv->mm.unbound_list, gtt_list)
		i915_gem_object_put_pages(obj);
d2121 1
d2123 1
a2145 1
		sg_free_table(st);
d2155 1
a2155 1
	mapping = obj->base.filp->f_path.dentry->d_inode->i_mapping;
d2159 3
a2161 1
	for_each_sg(st->sgl, sg, page_count, i) {
d2183 17
d2201 2
a2202 1
		sg_set_page(sg, page, PAGE_SIZE, 0);
d2204 4
a2207 1

d2235 3
a2237 2
	for_each_sg(st->sgl, sg, i, page_count)
		page_cache_release(sg_page(sg));
d2265 5
d2276 1
a2276 1
	list_add_tail(&obj->gtt_list, &dev_priv->mm.unbound_list);
d2280 1
a2280 1
void
a2300 2
	/* Move from whatever list we were on to the tail of execution. */
	list_move_tail(&obj->mm_list, &dev_priv->mm.active_list);
d2319 7
d2329 3
a2331 2
	struct drm_device *dev = obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
d2336 1
a2336 1
	list_move_tail(&obj->mm_list, &dev_priv->mm.inactive_list);
d2355 1
a2355 1
i915_gem_handle_seqno_wrap(struct drm_device *dev)
d2361 9
a2369 5
	/* The hardware uses various monotonic 32-bit counters, if we
	 * detect that they will wraparound we need to idle the GPU
	 * and reset those counters.
	 */
	ret = 0;
d2371 2
d2374 1
a2374 1
			ret |= ring->sync_seqno[j] != 0;
a2375 2
	if (ret == 0)
		return ret;
d2377 15
a2391 1
	ret = i915_gpu_idle(dev);
d2395 7
a2401 5
	i915_gem_retire_requests(dev);
	for_each_ring(ring, dev_priv, i) {
		for (j = 0; j < ARRAY_SIZE(ring->sync_seqno); j++)
			ring->sync_seqno[j] = 0;
	}
d2413 1
a2413 1
		int ret = i915_gem_handle_seqno_wrap(dev);
d2420 1
a2420 1
	*seqno = dev_priv->next_seqno++;
d2424 4
a2427 4
int
i915_add_request(struct intel_ring_buffer *ring,
		 struct drm_file *file,
		 u32 *out_seqno)
d2431 1
a2431 1
	u32 request_ring_position;
d2435 1
d2447 2
a2448 2
	request = kmalloc(sizeof(*request), GFP_KERNEL);
	if (request == NULL)
a2450 1

d2459 1
a2459 2
	if (ret) {
		kfree(request);
a2460 1
	}
d2464 1
d2466 16
d2498 5
a2502 1
	ring->outstanding_lazy_request = 0;
a2503 5
	if (!dev_priv->mm.suspended) {
		if (i915_enable_hangcheck) {
			timeout_add_msec(&dev_priv->hangcheck_timer,
			    DRM_I915_HANGCHECK_PERIOD);
		}
d2505 1
d2527 124
a2650 3
	if (request->file_priv) {
		list_del(&request->client_list);
		request->file_priv = NULL;
a2651 1
	spin_unlock(&file_priv->mm.lock);
d2654 13
a2666 2
static void i915_gem_reset_ring_lists(struct drm_i915_private *dev_priv,
				      struct intel_ring_buffer *ring)
d2668 3
a2670 2
	while (!list_empty(&ring->request_list)) {
		struct drm_i915_gem_request *request;
d2672 3
a2674 3
		request = list_first_entry(&ring->request_list,
					   struct drm_i915_gem_request,
					   list);
d2676 1
a2676 3
		list_del(&request->list);
		i915_gem_request_remove_from_client(request);
		kfree(request);
d2678 1
d2680 3
d2692 17
d2711 1
a2711 1
static void i915_gem_reset_fences(struct drm_device *dev)
d2719 10
a2728 8
		i915_gem_write_fence(dev, i, NULL);

		if (reg->obj)
			i915_gem_object_fence_lost(reg->obj);

		reg->pin_count = 0;
		reg->obj = NULL;
		INIT_LIST_HEAD(&reg->lru_list);
a2729 2

	INIT_LIST_HEAD(&dev_priv->mm.fence_list);
a2734 1
	struct drm_i915_gem_object *obj;
d2738 8
d2747 1
a2747 1
		i915_gem_reset_ring_lists(dev_priv, ring);
d2749 1
a2749 9
	/* Move everything out of the GPU domains to ensure we do any
	 * necessary invalidation upon reuse.
	 */
	list_for_each_entry(obj,
			    &dev_priv->mm.inactive_list,
			    mm_list)
	{
		obj->base.read_domains &= ~I915_GEM_GPU_DOMAINS;
	}
d2751 1
a2751 2
	/* The fence registers are invalidated so clear them out */
	i915_gem_reset_fences(dev);
d2787 1
a2787 3
		list_del(&request->list);
		i915_gem_request_remove_from_client(request);
		kfree(request);
d2815 1
a2815 1
void
d2820 1
d2823 1
a2823 1
	for_each_ring(ring, dev_priv, i)
d2825 9
d2839 3
a2841 3
	drm_i915_private_t *dev_priv;
	struct drm_device *dev;
	struct intel_ring_buffer *ring;
a2842 5
	int i;

	dev_priv = container_of(work, drm_i915_private_t,
				mm.retire_work.work);
	dev = dev_priv->dev;
d2845 6
a2850 1
	if (rw_enter(&dev->struct_mutex, RW_NOSLEEP | RW_WRITE)) {
d2853 1
a2853 2
		return;
	}
d2855 5
a2859 18
	i915_gem_retire_requests(dev);

	/* Send a periodic flush down the ring so we don't hold onto GEM
	 * objects indefinitely.
	 */
	idle = true;
	for_each_ring(ring, dev_priv, i) {
		if (ring->gpu_caches_dirty)
			i915_add_request(ring, NULL, NULL);

		idle &= list_empty(&ring->request_list);
	}

	if (!dev_priv->mm.suspended && !idle)
		queue_delayed_work(dev_priv->wq, &dev_priv->mm.retire_work,
				   round_jiffies_up_relative(HZ));
	if (idle)
		intel_mark_idle(dev);
d2861 1
a2861 1
	mutex_unlock(&dev->struct_mutex);
d2910 1
d2915 1
d2956 1
d2959 2
a2960 3
	ret = __wait_seqno(ring, seqno, true, timeout);
	if (timeout) {
		WARN_ON(!timespec_valid(timeout));
a2961 1
	}
d3006 1
a3021 3
	/* Act a barrier for all accesses through the GTT */
	mb();

d3028 3
d3042 1
a3042 5
/**
 * Unbinds an object from the GTT aperture.
 */
int
i915_gem_object_unbind(struct drm_i915_gem_object *obj)
d3044 1
d3046 10
a3055 1
	int ret = 0;
a3056 1
	if (obj->gtt_space == NULL)
d3058 1
d3080 1
a3080 1
	trace_i915_gem_object_unbind(obj);
d3092 1
a3092 2
	list_del(&obj->mm_list);
	list_move_tail(&obj->gtt_list, &dev_priv->mm.unbound_list);
d3094 2
a3095 1
	obj->map_and_fenceable = true;
d3097 2
a3098 3
	drm_mm_put_block(obj->gtt_space);
	obj->gtt_space = NULL;
	obj->gtt_offset = 0;
d3100 10
d3116 20
d3186 1
a3186 1
		u32 size = obj->gtt_space->size;
d3189 8
a3196 1
		val = (uint64_t)((obj->gtt_offset + size - 4096) &
d3198 1
a3198 1
		val |= obj->gtt_offset & 0xfffff000;
d3222 1
a3222 1
		u32 size = obj->gtt_space->size;
d3226 1
a3226 1
		WARN((obj->gtt_offset & ~I915_FENCE_START_MASK) ||
d3228 3
a3230 3
		     (obj->gtt_offset & (size - 1)),
		     "object 0x%08x [fenceable? %d] not 1M or pot-size (0x%08x) aligned\n",
		     obj->gtt_offset, obj->map_and_fenceable, size);
d3241 1
a3241 1
		val = obj->gtt_offset;
d3266 1
a3266 1
		u32 size = obj->gtt_space->size;
d3269 1
a3269 1
		WARN((obj->gtt_offset & ~I830_FENCE_START_MASK) ||
d3271 3
a3273 3
		     (obj->gtt_offset & (size - 1)),
		     "object 0x%08x not 512K or pot-size 0x%08x aligned\n",
		     obj->gtt_offset, size);
d3278 1
a3278 1
		val = obj->gtt_offset;
d3291 5
d3299 12
d3312 1
d3319 1
a3319 1
	default: break;
d3321 6
d3353 1
d3357 1
a3357 1
i915_gem_object_flush_fence(struct drm_i915_gem_object *obj)
d3367 3
a3369 9
	/* Ensure that all CPU reads are completed before installing a fence
	 * and all writes before removing the fence.
	 */
	if (obj->base.read_domains & I915_GEM_DOMAIN_GTT)
		mb();

	obj->fenced_gpu_access = false;
	return 0;
}
d3375 1
d3378 1
a3378 1
	ret = i915_gem_object_flush_fence(obj);
d3385 2
a3386 3
	i915_gem_object_update_fence(obj,
				     &dev_priv->fence_regs[obj->fence_reg],
				     false);
d3388 1
d3412 1
a3412 1
		return NULL;
d3422 6
a3427 1
	return NULL;
d3457 1
a3457 1
		ret = i915_gem_object_flush_fence(obj);
d3472 2
a3473 2
		if (reg == NULL)
			return -EDEADLK;
d3478 1
a3478 1
			ret = i915_gem_object_flush_fence(old);
a3487 1
	obj->fence_dirty = false;
d3500 1
a3500 1
	 * crossing memory domains and dieing.
d3505 1
a3505 1
	if (gtt_space == NULL)
d3529 1
a3529 1
	list_for_each_entry(obj, &dev_priv->mm.gtt_list, gtt_list) {
d3538 2
a3539 2
			       obj->gtt_space->start,
			       obj->gtt_space->start + obj->gtt_space->size,
d3550 2
a3551 2
			       obj->gtt_space->start,
			       obj->gtt_space->start + obj->gtt_space->size,
d3566 5
a3570 4
i915_gem_object_bind_to_gtt(struct drm_i915_gem_object *obj,
			    unsigned alignment,
			    bool map_and_fenceable,
			    bool nonblocking)
a3573 1
	struct drm_mm_node *node;
d3575 3
a3577 1
	bool mappable, fenceable;
a3579 5
	if (obj->madv != I915_MADV_WILLNEED) {
		DRM_ERROR("Attempting to bind a purgeable object\n");
		return -EINVAL;
	}

d3585 1
a3585 1
						     obj->tiling_mode);
d3587 1
a3587 1
		i915_gem_get_unfenced_gtt_alignment(dev,
d3589 1
a3589 1
						    obj->tiling_mode);
d3604 5
a3608 3
	if (obj->base.size >
	    (map_and_fenceable ? dev_priv->mm.gtt_mappable_end : dev_priv->mm.gtt_total)) {
		DRM_ERROR("Attempting to bind an object larger than the aperture\n");
d3618 1
a3618 7
	node = kzalloc(sizeof(*node), GFP_KERNEL);
	if (node == NULL) {
		i915_gem_object_unpin_pages(obj);
		/* XXX Until we've hooked up the shrinking functions. */
		i915_gem_object_put_pages(obj);
		return -ENOMEM;
	}
d3620 14
a3633 8
 search_free:
	if (map_and_fenceable)
		ret = drm_mm_insert_node_in_range_generic(&dev_priv->mm.gtt_space, node,
							  size, alignment, obj->cache_level,
							  0, dev_priv->mm.gtt_mappable_end);
	else
		ret = drm_mm_insert_node_generic(&dev_priv->mm.gtt_space, node,
						 size, alignment, obj->cache_level);
d3635 1
a3635 1
		ret = i915_gem_evict_something(dev, size, alignment,
d3642 1
a3642 5
		i915_gem_object_unpin_pages(obj);
		/* XXX Until we've hooked up the shrinking functions. */
		i915_gem_object_put_pages(obj);
		kfree(node);
		return ret;
d3644 4
a3647 6
	if (WARN_ON(!i915_gem_valid_gtt_space(dev, node, obj->cache_level))) {
		i915_gem_object_unpin_pages(obj);
		/* XXX Until we've hooked up the shrinking functions. */
		i915_gem_object_put_pages(obj);
		drm_mm_put_block(node);
		return -EINVAL;
d3651 5
a3655 7
	if (ret) {
		i915_gem_object_unpin_pages(obj);
		/* XXX Until we've hooked up the shrinking functions. */
		i915_gem_object_put_pages(obj);
		drm_mm_put_block(node);
		return ret;
	}
d3657 2
a3658 2
	list_move_tail(&obj->gtt_list, &dev_priv->mm.bound_list);
	list_add_tail(&obj->mm_list, &dev_priv->mm.inactive_list);
d3660 2
a3661 2
	obj->gtt_space = node;
	obj->gtt_offset = node->start;
d3663 2
a3664 3
	fenceable =
		node->size == fence_size &&
		(node->start & (fence_alignment - 1)) == 0;
d3666 2
a3667 2
	mappable =
		obj->gtt_offset + obj->base.size <= dev_priv->mm.gtt_mappable_end;
d3669 1
a3669 1
	obj->map_and_fenceable = mappable && fenceable;
d3671 1
a3671 2
	i915_gem_object_unpin_pages(obj);
	trace_i915_gem_object_bind(obj, map_and_fenceable);
d3674 10
d3686 3
a3688 2
void
i915_gem_clflush_object(struct drm_i915_gem_object *obj)
d3695 8
a3702 1
		return;
d3712 2
a3713 2
	if (obj->cache_level != I915_CACHE_NONE)
		return;
a3715 1

d3727 1
d3759 2
a3760 1
i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *obj)
d3767 3
a3769 2
	i915_gem_clflush_object(obj);
	i915_gem_chipset_flush(obj->base.dev);
d3792 1
a3792 1
	if (obj->gtt_space == NULL)
d3802 8
a3809 1
	i915_gem_object_flush_cpu_write_domain(obj);
d3830 7
a3836 2
	if (i915_gem_object_is_inactive(obj))
		list_move_tail(&obj->mm_list, &dev_priv->mm.inactive_list);
a3844 1
#ifdef notyet
d3846 1
a3846 1
#endif
d3857 8
a3864 4
	if (!i915_gem_valid_gtt_space(dev, obj->gtt_space, cache_level)) {
		ret = i915_gem_object_unbind(obj);
		if (ret)
			return ret;
d3867 1
a3867 1
	if (obj->gtt_space) {
a3885 1
#ifdef notyet
d3889 1
a3889 1
#endif
d3891 3
a3893 2
		obj->gtt_space->color = cache_level;
	}
d3895 1
a3895 1
	if (cache_level == I915_CACHE_NONE) {
a3904 1
		WARN_ON(obj->base.read_domains & ~I915_GEM_DOMAIN_CPU);
a3916 1
	obj->cache_level = cache_level;
d3938 14
a3951 1
	args->caching = obj->cache_level != I915_CACHE_NONE;
d3974 3
d3999 16
d4034 5
d4048 2
a4049 1
	ret = i915_gem_object_set_cache_level(obj, I915_CACHE_NONE);
d4051 1
a4051 1
		return ret;
d4057 1
a4057 1
	ret = i915_gem_object_pin(obj, alignment, true, false);
d4059 1
a4059 1
		return ret;
d4061 1
a4061 1
	i915_gem_object_flush_cpu_write_domain(obj);
d4077 11
d4133 1
a4133 1
		i915_gem_clflush_object(obj);
d4168 1
a4168 1
int
d4176 1
d4180 7
a4186 2
	if (atomic_read(&dev_priv->mm.wedged))
		return -EIO;
d4196 1
d4202 1
a4202 1
	ret = __wait_seqno(ring, seqno, true, NULL);
d4211 1
d4216 1
d4222 7
a4228 2
	if (obj->gtt_space != NULL) {
		if ((alignment && obj->gtt_offset & (alignment - 1)) ||
d4232 1
a4232 1
			     " offset=%x, req.alignment=%x, req.map_and_fenceable=%d,"
d4234 1
a4234 1
			     obj->gtt_offset, alignment,
d4237 1
a4237 1
			ret = i915_gem_object_unbind(obj);
d4243 1
a4243 2
	if (obj->gtt_space == NULL) {
#ifdef notyet
a4244 1
#endif
d4246 3
a4248 3
		ret = i915_gem_object_bind_to_gtt(obj, alignment,
						  map_and_fenceable,
						  nonblocking);
a4251 1
#ifdef notyet
a4252 1
#endif
d4269 1
a4269 1
	BUG_ON(obj->gtt_space == NULL);
d4306 5
d4312 1
a4312 1
		ret = i915_gem_object_pin(obj, args->alignment, true, false);
d4320 1
a4320 5
	/* XXX - flush the CPU caches for pinned objects
	 * as the X server doesn't manage domains yet
	 */
	i915_gem_object_flush_cpu_write_domain(obj);
	args->offset = obj->gtt_offset;
d4459 1
a4459 2
	INIT_LIST_HEAD(&obj->mm_list);
	INIT_LIST_HEAD(&obj->gtt_list);
d4461 2
a4462 1
	INIT_LIST_HEAD(&obj->exec_list);
d4483 4
d4488 1
a4488 1
	obj = pool_get(&dev->objpl, PR_WAITOK | PR_ZERO);
d4493 1
a4493 1
		pool_put(&dev->objpl, obj);
d4497 12
d4531 2
a4535 7
int i915_gem_init_object(struct drm_gem_object *obj)
{
	BUG();

	return 0;
}

d4541 3
d4551 21
a4571 1
	i915_gem_object_unbind(obj);
d4573 2
a4574 1
	obj->pages_pin_count = 0;
d4577 1
d4581 5
d4590 62
a4651 1
	pool_put(&dev->objpl, obj);
d4655 1
a4655 1
i915_gem_idle(struct drm_device *dev)
d4658 1
a4658 1
	int ret;
d4661 2
d4664 3
a4666 4
	if (dev_priv->mm.suspended) {
		mutex_unlock(&dev->struct_mutex);
		return 0;
	}
a4667 5
	ret = i915_gpu_idle(dev);
	if (ret) {
		mutex_unlock(&dev->struct_mutex);
		return ret;
	}
d4674 2
a4675 1
	i915_gem_reset_fences(dev);
d4679 1
a4679 1
	 * And not confound mm.suspended!
d4681 2
a4682 6
	dev_priv->mm.suspended = 1;
	timeout_del(&dev_priv->hangcheck_timer);

	i915_kernel_lost_context(dev);
	i915_gem_cleanup_ringbuffer(dev);

d4685 1
a4685 1
	/* Cancel the retire work handler, which should be idle now. */
d4687 1
d4690 4
d4696 1
a4696 2
#ifdef notyet
void i915_gem_l3_remap(struct drm_device *dev)
d4698 1
d4700 3
a4702 2
	u32 misccpctl;
	int i;
d4704 2
a4705 2
	if (!HAS_L3_GPU_CACHE(dev))
		return;
d4707 3
a4709 6
	if (!dev_priv->l3_parity.remap_info)
		return;

	misccpctl = I915_READ(GEN7_MISCCPCTL);
	I915_WRITE(GEN7_MISCCPCTL, misccpctl & ~GEN7_DOP_CLOCK_GATE_ENABLE);
	POSTING_READ(GEN7_MISCCPCTL);
d4711 5
d4717 3
a4719 7
		u32 remap = I915_READ(GEN7_L3LOG_BASE + i);
		if (remap && remap != dev_priv->l3_parity.remap_info[i/4])
			DRM_DEBUG("0x%x was already programmed to %x\n",
				  GEN7_L3LOG_BASE + i, remap);
		if (remap && !dev_priv->l3_parity.remap_info[i/4])
			DRM_DEBUG_DRIVER("Clearing remapped register\n");
		I915_WRITE(GEN7_L3LOG_BASE + i, dev_priv->l3_parity.remap_info[i/4]);
d4722 1
a4722 2
	/* Make sure all the writes land before disabling dop clock gating */
	POSTING_READ(GEN7_L3LOG_BASE);
d4724 1
a4724 1
	I915_WRITE(GEN7_MISCCPCTL, misccpctl);
a4725 1
#endif /* notyet */
d4744 4
d4749 1
a4749 1
		I915_WRITE(ARB_MODE, _MASKED_BIT_ENABLE(ARB_MODE_SWIZZLE_IVB));
d4770 1
a4770 2
int
i915_gem_init_hw(struct drm_device *dev)
d4772 1
a4772 1
	drm_i915_private_t *dev_priv = dev->dev_private;
a4774 14
#ifdef notyet
	if (INTEL_INFO(dev)->gen < 6 && !intel_enable_gtt())
		return -EIO;
#endif

	if (IS_HASWELL(dev) && (I915_READ(0x120010) == 1))
		I915_WRITE(0x9008, I915_READ(0x9008) | 0xf0000);

#ifdef notyet
	i915_gem_l3_remap(dev);
#endif

	i915_gem_init_swizzling(dev);

d4791 6
a4796 1
	dev_priv->next_seqno = 1;
d4798 3
a4800 8
	/*
	 * XXX: There was some w/a described somewhere suggesting loading
	 * contexts before PPGTT.
	 */
	i915_gem_context_init(dev);
#ifdef notyet
	i915_gem_init_ppgtt(dev);
#endif
d4804 4
d4812 1
d4816 2
a4817 3
#ifdef notyet
static bool
intel_enable_ppgtt(struct drm_device *dev)
d4819 2
a4820 2
	if (i915_enable_ppgtt >= 0)
		return i915_enable_ppgtt;
d4822 3
a4824 4
#ifdef CONFIG_INTEL_IOMMU
	/* Disable ppgtt on SNB if VT-d is on. */
	if (INTEL_INFO(dev)->gen == 6 && intel_iommu_gfx_mapped)
		return false;
d4827 42
a4868 1
	return true;
a4869 1
#endif /* notyet */
a4873 1
	unsigned long gtt_size, mappable_size;
a4875 3
	gtt_size = dev_priv->mm.gtt->gtt_total_entries << PAGE_SHIFT;
	mappable_size = dev_priv->mm.gtt->gtt_mappable_entries << PAGE_SHIFT;

a4876 5
#ifdef notyet
	if (intel_enable_ppgtt(dev) && HAS_ALIASING_PPGTT(dev)) {
		/* PPGTT pdes are stolen from global gtt ptes, so shrink the
		 * aperture accordingly when using aliasing ppgtt. */
		gtt_size -= I915_PPGTT_PD_ENTRIES*PAGE_SIZE;
d4878 6
a4883 1
		i915_gem_init_global_gtt(dev, 0, mappable_size, gtt_size);
d4885 1
a4885 22
		ret = i915_gem_init_aliasing_ppgtt(dev);
		if (ret) {
			mutex_unlock(&dev->struct_mutex);
			return ret;
		}
	} else {
#endif
		/* Let GEM Manage all of the aperture.
		 *
		 * However, leave one page at the end still bound to the scratch
		 * page.  There are a number of places where the hardware
		 * apparently prefetches past the end of the object, and we've
		 * seen multiple hangs with the GPU head pointer stuck in a
		 * batchbuffer bound at the last page of the aperture.  One page
		 * should be enough to keep any prefetching inside of the
		 * aperture.
		 */
		i915_gem_init_global_gtt(dev, 0, mappable_size,
					 gtt_size);
#ifdef notyet
	}
#endif
d4917 1
a4917 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d4923 1
a4923 1
	if (atomic_read(&dev_priv->mm.wedged)) {
d4925 1
a4925 1
		atomic_set(&dev_priv->mm.wedged, 0);
d4929 1
a4929 1
	dev_priv->mm.suspended = 0;
d4937 1
a4937 1
	BUG_ON(!list_empty(&dev_priv->mm.active_list));
d4949 1
a4949 1
	dev_priv->mm.suspended = 1;
d4963 2
a4964 1
	return i915_gem_idle(dev);
a4966 1
#ifdef notyet
d4975 1
a4975 1
	ret = i915_gem_idle(dev);
a4978 1
#endif /* notyet */
d4987 10
d5000 1
a5001 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d5003 12
a5014 2
	INIT_LIST_HEAD(&dev_priv->mm.active_list);
	INIT_LIST_HEAD(&dev_priv->mm.inactive_list);
d5024 3
a5026 1
	init_completion(&dev_priv->error_completion);
d5040 3
a5042 1
	if (INTEL_INFO(dev)->gen >= 4 || IS_I945G(dev) || IS_I945GM(dev) || IS_G33(dev))
d5048 2
a5049 1
	i915_gem_reset_fences(dev);
d5056 3
a5058 2
#if 0
	dev_priv->mm.inactive_shrinker.shrink = i915_gem_inactive_shrink;
d5078 1
a5078 1
	phys_obj = kzalloc(sizeof(struct drm_i915_gem_phys_object), GFP_KERNEL);
d5229 4
a5232 1
	int ret;
d5234 10
a5243 2
	ret = -copyin((char *)(uintptr_t)args->data_ptr,
	    vaddr, args->size);
d5246 1
a5246 2

	return ret;
d5253 2
d5272 36
d5314 1
a5314 1
#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_MUTEXES)
d5322 2
a5323 2
static int
i915_gem_inactive_shrink(struct shrinker *shrinker, struct shrink_control *sc)
a5330 1
	int nr_to_scan = sc->nr_to_scan;
d5332 1
a5332 1
	int cnt;
d5344 100
a5443 7
	if (nr_to_scan) {
		nr_to_scan -= i915_gem_purge(dev_priv, nr_to_scan);
		if (nr_to_scan > 0)
			nr_to_scan -= __i915_gem_shrink(dev_priv, nr_to_scan,
							false);
		if (nr_to_scan > 0)
			i915_gem_shrink_all(dev_priv);
d5446 7
a5452 7
	cnt = 0;
	list_for_each_entry(obj, &dev_priv->mm.unbound_list, gtt_list)
		if (obj->pages_pin_count == 0)
			cnt += obj->base.size >> PAGE_SHIFT;
	list_for_each_entry(obj, &dev_priv->mm.inactive_list, mm_list)
		if (obj->pin_count == 0 && obj->pages_pin_count == 0)
			cnt += obj->base.size >> PAGE_SHIFT;
d5456 2
a5457 1
	return cnt;
d5460 14
@


1.98
log
@Add Linux completion API and use it.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.97 2015/06/24 17:59:42 kettenis Exp $	*/
d1065 7
a1071 33
		end = timeout_jiffies;
		mtx_enter(&dev_priv->irq_lock);
		do {
			if (EXIT_COND) {
				ret = 0;
				break;
			}
			ret = msleep(ring, &dev_priv->irq_lock,
			    PZERO | (interruptible ? PCATCH : 0),
			    "gemwt", end);
			nanouptime(&now);
			timespecsub(&now, &before, &sleep_time);
			if (timespeccmp(&sleep_time, &wait_time, >=)) {
				end = 0;
				break;
			}
			end = timeout_jiffies -
			    timespec_to_jiffies(&sleep_time);
		} while (ret == 0);
		mtx_leave(&dev_priv->irq_lock);
		switch (ret) {
		case 0:
			break;
		case ERESTART:
			end = -ERESTARTSYS;
			break;
		case EWOULDBLOCK:
			end = 0;
			break;
		default:
			end = -ret;
			break;
		}
@


1.97
log
@Linux jiffies and OpenBSD ticks are the same thing.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.96 2015/06/24 08:32:39 kettenis Exp $	*/
d113 2
d125 6
a130 8
	mtx_enter(&dev_priv->error_completion_lock);
	while (dev_priv->error_completion == 0) {
		ret = -msleep(&dev_priv->error_completion,
		    &dev_priv->error_completion_lock, PCATCH, "915wco", 10*hz);
		if (ret) {
			mtx_leave(&dev_priv->error_completion_lock);
			return ret;
		}
a131 1
	mtx_leave(&dev_priv->error_completion_lock);
d139 3
a141 3
		mtx_enter(&dev_priv->error_completion_lock);
		dev_priv->error_completion++;
		mtx_leave(&dev_priv->error_completion_lock);
d980 1
d982 1
d985 4
a988 4
		mtx_enter(&dev_priv->error_completion_lock);
		recovery_complete = dev_priv->error_completion > 0;
		mtx_leave(&dev_priv->error_completion_lock);
		
a4312 1
#if 0
a4313 3
#else
	dev_priv->error_completion = 0;
#endif
@


1.96
log
@Introduce Linux work queue APIs and use them.  As a side-effect, this will
move some of the work from the system task queue to the driver-specific
task queue.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.95 2015/06/22 15:20:43 kettenis Exp $	*/
a81 2
extern int ticks;

d2186 1
a2186 1
	request->emitted_ticks = ticks;
d3595 1
a3595 1
	unsigned long recent_enough = ticks - msecs_to_jiffies(20);
d3606 1
a3606 1
		if (time_after_eq(request->emitted_ticks, recent_enough))
@


1.95
log
@Flush out another small diff to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.94 2015/04/18 14:47:34 jsg Exp $	*/
d2212 3
a2214 1
			timeout_add_sec(&dev_priv->mm.retire_timer, 1);
d2385 2
a2386 2
void
i915_gem_retire_work_handler(void *arg1)
d2388 1
a2388 1
	drm_i915_private_t *dev_priv = arg1;
d2394 2
d2400 2
a2401 1
		timeout_add_sec(&dev_priv->mm.retire_timer, 1);
d2419 2
a2420 1
		timeout_add_sec(&dev_priv->mm.retire_timer, 1);
d3621 1
a3621 1
		timeout_add_sec(&dev_priv->mm.retire_timer, 0);
d4004 1
a4004 2
	timeout_del(&dev_priv->mm.retire_timer);
	task_del(dev_priv->mm.retire_taskq, &dev_priv->mm.retire_task);
d4312 2
a4313 3
	task_set(&dev_priv->mm.retire_task, i915_gem_retire_work_handler,
	    dev_priv);
	timeout_set(&dev_priv->mm.retire_timer, inteldrm_timeout, dev_priv);
@


1.94
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.93 2015/04/18 11:41:28 jsg Exp $	*/
d228 1
a228 1
	size = round_page(size);
@


1.93
log
@define and use trace macros
discussed with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.92 2015/04/17 00:54:42 jsg Exp $	*/
a490 2
		page_do_bit17_swizzling = obj_do_bit17_swizzling &&
			(page_to_phys(page) & (1 << 17)) != 0;
d493 1
d495 1
a495 2
			(VM_PAGE_TO_PHYS(page) & (1 << 17)) != 0;
#endif
a854 2
		page_do_bit17_swizzling = obj_do_bit17_swizzling &&
			(page_to_phys(page) & (1 << 17)) != 0;
d857 1
d859 1
a859 2
			(VM_PAGE_TO_PHYS(page) & (1 << 17)) != 0;
#endif
d878 1
a879 1
		set_page_dirty(page);
a880 2
#else
		atomic_clearbits_int(&page->pg_flags, PG_CLEAN);
d1060 1
a1060 1
	nanouptime(&before);
d1105 1
a1105 1
	nanouptime(&now);
@


1.92
log
@Make drm ioctls table driven.  Further reduces the diff to linux.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.91 2015/04/12 17:10:07 kettenis Exp $	*/
a3202 1
#if 0
d3205 1
@


1.91
log
@Add a few missing trace functions, and "use" them.  Add back the WATCH_GTT
code (that isn't actually compiled in).  Use dev_priv->dev in one more place
now that we have it, and add set_normalized_timespec() and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.90 2015/04/12 03:54:10 jsg Exp $	*/
a3814 1
#ifdef notyet
a3820 1
#endif
@


1.90
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.89 2015/04/08 02:28:13 jsg Exp $	*/
d1129 1
a1129 1
			timeout->tv_sec = timeout->tv_nsec = 0;
d2219 1
a2219 1
			intel_mark_busy(ring->dev);
d3019 36
d3945 2
@


1.89
log
@ttm has it's own version of kmap/kunmap that uses
kernel_map/uvm_km_valloc and i915 has a version that uses
phys_map/uvm_km_valloc_wait as calling code assumes kmap would
sleep if no memory is available.

Move these and ttm's vmap/vunmap into the linux compat files
and make them all use phys_map/uvm_km_valloc_wait.

looks good kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.88 2015/04/06 12:25:10 jsg Exp $	*/
a4306 1
#if 0
a4307 1
#endif
@


1.88
log
@move some inline linux compat into the dedicated files
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.87 2015/04/06 10:56:37 jsg Exp $	*/
a290 29
}

static void *
kmap(struct vm_page *pg)
{
	vaddr_t va;

#if defined (__HAVE_PMAP_DIRECT)
	va = pmap_map_direct(pg);
#else
	va = uvm_km_valloc_wait(phys_map, PAGE_SIZE);
	pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());
#endif
	return (void *)va;
}

static void
kunmap(void *addr)
{
	vaddr_t va = (vaddr_t)addr;

#if defined (__HAVE_PMAP_DIRECT)
	pmap_unmap_direct(va);
#else
	pmap_kremove(va, PAGE_SIZE);
	pmap_update(pmap_kernel());
	uvm_km_free_wakeup(phys_map, va, PAGE_SIZE);
#endif
@


1.87
log
@add/use some more errno remapping
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.86 2015/04/05 11:53:53 kettenis Exp $	*/
a292 2
#define offset_in_page(off) ((off) & PAGE_MASK)

a404 3

#define round_up(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
#define round_down(x, y) (((x) / (y)) * (y))
@


1.86
log
@Another round of reducing diffs with Linux.  This one moves the various
copy_to_user and copy_from_user functions into drm_linux.h and uses them
instead of copyin/copyout and DRM_COPY_*.  Also move the timespec functions,
and put i915_gem_object_is_purgable() where it belongs.

Uncovered a bug where the arguments to copyout() were in the wrong order.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.85 2015/02/12 08:48:32 jsg Exp $	*/
d1164 1
a1164 1
		return -ETIMEDOUT;
d2546 1
a2546 1
		ret = -ETIMEDOUT;
@


1.85
log
@Add and use macros for linux memory barriers.  Fix the call in
i915_gem_object_flush_fence() to be mb() not wmb() while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.84 2015/02/12 04:56:03 kettenis Exp $	*/
a81 5
static inline int timespec_to_jiffies(const struct timespec *);
static inline int timespec_valid(const struct timespec *);
static struct timespec ns_to_timespec(const int64_t);
static inline int64_t timespec_to_ns(const struct timespec *);

a329 21
static inline unsigned long
__copy_to_user(void *to, const void *from, unsigned len)
{
	if (copyout(from, to, len))
		return len;
	return 0;
}

static inline unsigned long
__copy_to_user_inatomic(void *to, const void *from, unsigned len)
{
	struct cpu_info *ci = curcpu();
	int error;

	ci->ci_inatomic = 1;
	error = copyout(from, to, len);
	ci->ci_inatomic = 0;

	return (error ? len : 0);
}

a355 21
static inline unsigned long
__copy_from_user(void *to, const void *from, unsigned len)
{
	if (copyin(from, to, len))
		return len;
	return 0;
}

static inline unsigned long
__copy_from_user_inatomic_nocache(void *to, const void *from, unsigned len)
{
	struct cpu_info *ci = curcpu();
	int error;

	ci->ci_inatomic = 1;
	error = copyin(from, to, len);
	ci->ci_inatomic = 0;

	return (error ? len : 0);
}

d1788 5
a1792 1
// i915_gem_object_is_purgeable
a4608 51

#define NSEC_PER_SEC	1000000000L

static inline int64_t
timespec_to_ns(const struct timespec *ts)
{
	return ((ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec);
}

static inline int
timespec_to_jiffies(const struct timespec *ts)
{
	long long to_ticks;

	to_ticks = (long long)hz * ts->tv_sec + ts->tv_nsec / (tick * 1000);
	if (to_ticks > INT_MAX)
		to_ticks = INT_MAX;

	return ((int)to_ticks);
}

static struct timespec
ns_to_timespec(const int64_t nsec)
{
	struct timespec ts;
	int32_t rem;

	if (nsec == 0) {
		ts.tv_sec = 0;
		ts.tv_nsec = 0;
		return (ts);
	}

	ts.tv_sec = nsec / NSEC_PER_SEC;
	rem = nsec % NSEC_PER_SEC;
	if (rem < 0) {
		ts.tv_sec--;
		rem += NSEC_PER_SEC;
	}
	ts.tv_nsec = rem;
	return (ts);
}

static inline int
timespec_valid(const struct timespec *ts)
{
	if (ts->tv_sec < 0 || ts->tv_sec > 100000000 ||
	    ts->tv_nsec < 0 || ts->tv_nsec >= 1000000000)
		return (0);
	return (1);
}
@


1.84
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.83 2015/02/12 02:12:02 kettenis Exp $	*/
d2661 1
a2661 1
	DRM_MEMORYBARRIER();
d2942 1
a2942 1
		DRM_WRITEMEMORYBARRIER();
d3276 1
a3276 1
	DRM_WRITEMEMORYBARRIER();
@


1.83
log
@Add mutex_is_locked and use it wherever linux uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.82 2015/02/10 10:50:49 jsg Exp $	*/
d2475 1
a2475 1
	dev = (struct drm_device *)dev_priv->drmdev;
@


1.82
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.81 2015/02/10 06:19:36 jsg Exp $	*/
d1101 1
a1101 1
//	BUG_ON(!mutex_is_locked(&ring->dev->struct_mutex));
d1230 1
a1230 1
//	BUG_ON(!mutex_is_locked(&dev->struct_mutex));
d1291 1
a1291 1
	rw_assert_wrlock(&dev->struct_mutex);
@


1.81
log
@switch most rwlock calls back to their linux equivalents
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.80 2015/02/10 01:39:32 jsg Exp $	*/
d2279 1
a2279 1
		mtx_enter(&file_priv->mm.lock);
d2283 1
a2283 1
		mtx_leave(&file_priv->mm.lock);
d2313 1
a2313 1
	mtx_enter(&file_priv->mm.lock);
d2318 1
a2318 1
	mtx_leave(&file_priv->mm.lock);
d3647 1
a3647 1
	mtx_enter(&file_priv->mm.lock);
d3655 1
a3655 1
	mtx_leave(&file_priv->mm.lock);
d4580 1
a4580 1
	mtx_enter(&file_priv->mm.lock);
d4590 1
a4590 1
	mtx_leave(&file_priv->mm.lock);
@


1.80
log
@Remove DRM_LOCK macros, rename dev_lock to struct_mutex and directly
call linux style lock functions where these macros were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.79 2015/01/27 03:17:36 dlg Exp $	*/
d162 1
a162 1
	ret = -rw_enter(&dev->struct_mutex, RW_WRITE | RW_INTR);
@


1.79
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.78 2014/12/17 06:58:10 guenther Exp $	*/
d162 1
a162 1
	ret = -rw_enter(&dev->dev_lock, RW_WRITE | RW_INTR);
d193 1
a193 1
	DRM_LOCK();
d196 1
a196 1
	DRM_UNLOCK();
d211 1
a211 1
	DRM_LOCK();
d215 1
a215 1
	DRM_UNLOCK();
d587 1
a587 1
		DRM_UNLOCK();
d605 1
a605 1
		DRM_LOCK();
d672 1
a672 1
	DRM_UNLOCK();
d954 1
a954 1
		DRM_UNLOCK();
d960 1
a960 1
		DRM_LOCK();
d1061 1
a1061 1
	DRM_UNLOCK();
d1291 1
a1291 1
	rw_assert_wrlock(&dev->dev_lock);
d1306 1
a1306 1
	DRM_UNLOCK();
d1308 1
a1308 1
	DRM_LOCK();
d1386 1
a1386 1
	DRM_UNLOCK();
d1417 1
a1417 1
	DRM_UNLOCK();
d1487 1
a1487 1
	if (!obj->base.map || RWLOCK_OWNER(&dev->dev_lock) == curproc) {
d1496 1
a1496 1
	if (rw_enter(&dev->dev_lock, RW_NOSLEEP | RW_WRITE) != 0) {
d1498 1
a1498 1
		DRM_LOCK();
d1502 1
a1502 1
		DRM_UNLOCK();
d1547 1
a1547 1
			DRM_UNLOCK();
d1558 1
a1558 1
	DRM_UNLOCK();
d1795 1
a1795 1
	DRM_UNLOCK();
d2478 1
a2478 1
	if (rw_enter(&dev->dev_lock, RW_NOSLEEP | RW_WRITE)) {
d2501 1
a2501 1
	DRM_UNLOCK();
d2568 1
a2568 1
		DRM_UNLOCK();
d2594 1
a2594 1
	DRM_UNLOCK();
d2605 1
a2605 1
	DRM_UNLOCK();
d3456 1
a3456 1
	DRM_UNLOCK();
d3493 1
a3493 1
	DRM_UNLOCK();
d3778 1
a3778 1
	DRM_UNLOCK();
d3815 1
a3815 1
	DRM_UNLOCK();
d3852 1
a3852 1
	DRM_UNLOCK();
d3908 1
a3908 1
	DRM_UNLOCK();
d4012 1
a4012 1
	DRM_LOCK();
d4015 1
a4015 1
		DRM_UNLOCK();
d4021 1
a4021 1
		DRM_UNLOCK();
d4042 1
a4042 1
	DRM_UNLOCK();
d4206 1
a4206 1
	DRM_LOCK();
d4239 1
a4239 1
	DRM_UNLOCK();
d4279 1
a4279 1
	DRM_LOCK();
d4284 1
a4284 1
		DRM_UNLOCK();
d4289 1
a4289 1
	DRM_UNLOCK();
d4298 1
a4298 1
	DRM_LOCK();
d4301 1
a4301 1
	DRM_UNLOCK();
@


1.78
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.77 2014/12/15 02:24:23 guenther Exp $	*/
d2467 1
a2467 1
i915_gem_retire_work_handler(void *arg1, void *unused)
d4355 1
a4355 1
	    dev_priv, NULL);
@


1.77
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.76 2014/11/16 12:31:00 deraadt Exp $	*/
d1454 1
a1454 1
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0));
@


1.76
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.75 2014/09/20 21:17:43 kettenis Exp $	*/
d1454 1
a1454 1
	    PROT_READ | PROT_WRITE, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0));
@


1.75
log
@Make another fast path properly atomic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.74 2014/07/12 18:48:52 tedu Exp $	*/
d309 1
a309 1
	pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg), VM_PROT_READ|VM_PROT_WRITE);
d1453 2
a1454 2
	    obj->uao, args->offset, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0));
d1476 1
a1476 1
	int write = !!(access_type & VM_PROT_WRITE);
d1530 1
a1530 1
		mapprot &= ~VM_PROT_WRITE;
d1625 1
a1625 1
		pmap_page_protect(pg, VM_PROT_NONE);
@


1.74
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.73 2014/05/12 19:29:16 kettenis Exp $	*/
d699 25
d737 4
a740 5
	bus_space_handle_t bsh;
	bus_addr_t offset;
	bus_size_t size;
	char *vaddr;
	int ret;
d754 3
a757 1
	size = round_page(offset + args->size) - trunc_page(offset);
d759 12
a770 8
	if ((ret = agp_map_subregion(dev_priv->agph,
	    trunc_page(offset), size, &bsh)) != 0)
		goto out_unpin;
	vaddr = bus_space_vaddr(dev_priv->bst, bsh);
	if (vaddr == NULL) {
		ret = -EFAULT;
		goto out_unmap;
	}
d772 9
a780 2
	ret = -copyin((char *)(uintptr_t)args->data_ptr,
	    vaddr + (offset & PAGE_MASK), args->size);
d782 4
a785 2
out_unmap:
	agp_unmap_subregion(dev_priv->agph, bsh, size);
@


1.73
log
@Move GTT management for Sandy Bridge and up into inteldrm(4).  This makes
it possible to use the non-mappable part of the GTT, prepares the way for
using the PPGTT and reduces the diffs with Linux.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.72 2014/04/01 20:16:50 kettenis Exp $	*/
d2039 1
a2039 1
	free(st, M_DRM);
@


1.72
log
@Move some duplicated code implementing Linux compatibility APIs and stick it
in a seperate header file.  This will become a dumping ground for similar code.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.71 2014/03/24 17:06:49 kettenis Exp $	*/
d1501 1
a1501 1
		paddr = dev->agp->base + obj->gtt_offset + offset;
d4160 1
d4164 2
a4165 2
	gtt_size = dev->agp->info.ai_aperture_size;
	mappable_size = dev->agp->info.ai_aperture_size;
@


1.71
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.70 2014/02/13 23:11:05 kettenis Exp $	*/
a325 25
#endif
}

static inline void *
kmap_atomic(struct vm_page *pg)
{
	vaddr_t va;

#if defined (__HAVE_PMAP_DIRECT)
	va = pmap_map_direct(pg);
#else
	extern vaddr_t pmap_tmpmap_pa(paddr_t);
	va = pmap_tmpmap_pa(VM_PAGE_TO_PHYS(pg));
#endif
	return (void *)va;
}

static inline void
kunmap_atomic(void *addr)
{
#if defined (__HAVE_PMAP_DIRECT)
	pmap_unmap_direct((vaddr_t)addr);
#else
	extern void pmap_tmpunmap_pa(void);
	pmap_tmpunmap_pa();
@


1.70
log
@Some Linux i915 drm "fast" path code relies on being able to "disable" page
faults to avoid sleeping.  Implement this functionality for i386 and amd64
for faults in the user address space.  If the ci_inatomic flag is set in
struct cpu_info, copyin(9) and copyout(9) will return EFAULT when a user-space
address needs to be faulted in.  Use this to properly implement
__copy_to_user_inatomic() and __copy_from_user_inatomic_nocache() in the
inteldrm(4) code.

ok krw@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.69 2014/02/05 10:41:32 kettenis Exp $	*/
d3832 1
a3832 1
//		BUILD_BUG_ON(I915_NUM_RINGS > 16);
@


1.69
log
@Do proper error handling in the fault handler.  Fixes spurious SIGSEGVs as
seen with the new xf86-video-intel 2.99.909 on some hardware.  The problem
was probably masked bu the holding logic that was removed in rev 1.67.

tested by tedu@@, matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.68 2014/02/02 10:54:10 kettenis Exp $	*/
d371 8
a378 3
	if (copyout(from, to, len))
		return len;
	return 0;
d418 8
a425 3
	if (copyin(from, to, len))
		return len;
	return 0;
@


1.68
log
@Add missing DRM_UNLOCK() in error path.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.67 2014/01/30 15:10:47 kettenis Exp $	*/
d1525 1
d1537 23
a1559 1
	if (ret == -EIO) {
d1561 2
a1562 2
		 * EIO means we're wedged, so upon resetting the gpu we'll
		 * be alright and can refault. XXX only on resettable chips.
d1564 8
a1571 5
		ret = VM_PAGER_REFAULT;
	} else if (ret) {
		ret = VM_PAGER_ERROR;
	} else {
		ret = VM_PAGER_OK;
a1572 1
	return ret;
@


1.67
log
@Get rid of the simple locks; they're lies.  Also get rid of the holding
logic for uvm objects; it's not necessary anymore as far as I can tell, at
least as long as we run all this code under the kernel lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.66 2014/01/21 08:57:22 kettenis Exp $	*/
d1478 1
@


1.66
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.65 2014/01/21 08:29:32 kettenis Exp $	*/
a1475 2
		if (locked)
			drm_lock_obj(&obj->base);
d1477 1
a1477 3
	if (locked)
		drm_hold_object_locked(&obj->base);
	else { /* obj already unlocked */
a1481 5
	/* we have a hold set on the object now, we can unlock so that we can
	 * sleep in binding and flushing.
	 */
	drm_unlock_obj(&obj->base);

a1519 1
			drm_unhold_object(&obj->base);
a1530 1
	drm_unhold_object(&obj->base);
a1776 2
	DRM_ASSERT_HELD(&obj->base);

a1778 1
	simple_lock(&obj->base.uao->vmobjlock);
a1780 1
	simple_unlock(&obj->base.uao->vmobjlock);
a3267 2
	DRM_ASSERT_HELD(&obj->base);

a3533 2
	DRM_ASSERT_HELD(obj);

a3697 2
	drm_hold_object(&obj->base);

d3726 1
a3726 1
	drm_unhold_and_unref(&obj->base);
a3749 2
	drm_hold_object(&obj->base);

d3763 1
a3763 1
	drm_unhold_and_unref(&obj->base);
a3840 2
	drm_hold_object(&obj->base);

d3856 1
a3856 1
	drm_unhold_and_unref(&obj->base);
a3935 2

	DRM_ASSERT_HELD(&obj->base);
@


1.65
log
@oops, missed one
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.64 2014/01/21 08:25:33 kettenis Exp $	*/
d1854 1
a1855 3
#else
	drm_free(obj->pages);
#endif
d2043 1
a2043 1
	drm_free(st);
d2215 1
a2215 1
	request = drm_alloc(sizeof(*request));
d2229 1
a2229 1
		drm_free(request);
d2298 1
a2298 1
		drm_free(request);
d2392 1
a2392 1
		drm_free(request);
d3120 1
a3120 1
	node = malloc(sizeof(*node), M_DRM, M_NOWAIT | M_ZERO);
d3147 1
a3147 1
		free(node, M_DRM);
d3979 1
a3979 1
	drm_free(obj->bit_17);
d4387 1
a4387 1
	phys_obj = drm_alloc(sizeof(struct drm_i915_gem_phys_object));
d4403 1
a4403 1
	drm_free(phys_obj);
@


1.64
log
@Change a couple of #if 0 into #ifdef __linx__ or #ifdef notyet.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.63 2014/01/21 04:47:38 kettenis Exp $	*/
d2036 1
a2036 1
#if 0
@


1.63
log
@Use ARRAY_SIZE() instead of nitems() to reduce diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.62 2013/12/21 15:09:23 kettenis Exp $	*/
d1806 1
a1806 1
#if 0
d1829 1
a1829 1
#if 0
d1852 1
a1852 1
#if 0
d1942 1
a1942 1
#if 0
d1964 1
a1964 1
#if 0
d3329 3
a3331 1
//	drm_i915_private_t *dev_priv = dev->dev_private;
d4185 1
a4185 1
#if 0
d4212 1
a4212 1
#if 0
d4223 5
@


1.62
log
@i915_gem_mmap_ioctl() should return a Linux-style negative errno value.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.61 2013/12/21 12:21:23 kettenis Exp $	*/
d2158 1
a2158 1
		for (j = 0; j < nitems(ring->sync_seqno); j++)
d2170 1
a2170 1
		for (j = 0; j < nitems(ring->sync_seqno); j++)
@


1.61
log
@Fix locking in the page fault handler.  A (somewhat malicious) userland
program could force a copyin/copyout from/to memory mapped through the GTT,
forcing a "locking against myself" panic.  The intel-gpu-tools "package" has
a test for this.  The problem can be circumvented by making the fault handler
fail if we already hold the (DRM) lock.  This will make the copyin/copyout
return with EFAULT making the caller fall back on a "slow path".

This makes it obvious that using a shared (read) lock here doesn't make any
sense.  So use an exclusive (write) lock like everywhere else in the inteldrm
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.60 2013/12/15 11:42:10 kettenis Exp $	*/
d1428 1
a1428 1
	ret = uvm_map(&curproc->p_vmspace->vm_map, &addr, size,
@


1.60
log
@Overhaul the pread and pwrite code to match what Linux does.  Should fix a few
more cache coherency issues, hopefully reducing the number of artifacts
showing up the screen.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.59 2013/12/11 20:31:43 kettenis Exp $	*/
d602 1
a602 1
		DRM_READUNLOCK();
d620 1
a620 1
		DRM_READLOCK();
d663 4
d668 4
a671 4
	if (obj == NULL)
		return -ENOENT;
	DRM_READLOCK();
	drm_hold_object(&obj->base);
d685 3
a687 3
	drm_unhold_and_unref(&obj->base);
	DRM_READUNLOCK();

d930 1
a930 1
		DRM_READUNLOCK();
d936 1
a936 1
		DRM_READLOCK();
d991 4
d996 4
a999 4
	if (obj == NULL)
		return -ENOENT;
	DRM_READLOCK();
	drm_hold_object(&obj->base);
d1035 3
a1037 3
	drm_unhold_and_unref(&obj->base);
	DRM_READUNLOCK();

d1458 6
a1463 1
	if (!obj->base.map) {
d1472 1
a1472 1
	if (rw_enter(&dev->dev_lock, RW_NOSLEEP | RW_READ) != 0) {
d1474 1
a1474 1
		DRM_READLOCK();
d1532 1
a1532 1
			DRM_READUNLOCK();
d1543 1
a1543 1
	DRM_READUNLOCK();
@


1.59
log
@Make obj->pages a simple array instead of an array of bus_dma_segment_t's.
Simplifies things a bit and reduces the diffs with Linux a bit too.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.58 2013/12/09 20:09:55 kettenis Exp $	*/
d298 78
a375 1
#ifdef notyet
d384 1
a384 1
		int cacheline_end = ALIGN(gpu_offset + 1, 64);
d402 16
d426 1
a426 1
		int cacheline_end = ALIGN(gpu_offset + 1, 64);
d448 1
a448 1
shmem_pread_fast(struct page *page, int shmem_page_offset, int page_length,
d470 3
d498 1
a498 1
shmem_pread_slow(struct page *page, int shmem_page_offset, int page_length,
d519 1
a519 1
	kunmap(page);
d532 1
a532 1
	loff_t offset;
a535 1
	int prefaulted = 0;
a536 1
	struct scatterlist *sg;
d566 2
a567 2
	for_each_sg(obj->pages->sgl, sg, obj->pages->nents, i) {
		struct page *page;
d585 1
d589 5
d602 1
a602 1
		mutex_unlock(&dev->struct_mutex);
d604 1
d614 1
d620 1
a620 1
		mutex_lock(&dev->struct_mutex);
d623 1
d625 1
a645 1
#endif /* notyet */
d656 6
a661 8
	struct inteldrm_softc		*dev_priv = dev->dev_private;
	struct drm_i915_gem_pread	*args = data;
	struct drm_i915_gem_object	*obj;
	char				*vaddr;
	bus_space_handle_t		 bsh;
	bus_size_t			 bsize;
	voff_t				 offset;
	int				 ret;
d669 3
a671 5
	/*
	 * Bounds check source.
	 */
	if (args->offset > obj->base.size || args->size > obj->base.size ||
	    args->offset + args->size > obj->base.size) {
d676 1
a676 19
	ret = i915_gem_object_pin(obj, 0, true, true);
	if (ret)
		goto out;

	ret = i915_gem_object_set_to_gtt_domain(obj, false);
	if (ret)
		goto unpin;

	offset = obj->gtt_offset + args->offset;
	bsize = round_page(offset + args->size) - trunc_page(offset);

	if ((ret = agp_map_subregion(dev_priv->agph,
	    trunc_page(offset), bsize, &bsh)) != 0)
		goto unpin;
	vaddr = bus_space_vaddr(dev->bst, bsh);
	if (vaddr == NULL) {
		ret = -EFAULT;
		goto unmap;
	}
d678 1
a678 2
	ret = -copyout(vaddr + (offset & PAGE_MASK),
	    (char *)(uintptr_t)args->data_ptr, args->size);
a679 4
unmap:
	agp_unmap_subregion(dev_priv->agph, bsh, bsize);
unpin:
	i915_gem_object_unpin(obj);
d687 1
a687 1
#ifdef notyet
d710 1
d723 5
a727 4
	ssize_t remain;
	loff_t offset, page_base;
	char __user *user_data;
	int page_offset, page_length, ret;
a740 3
	user_data = (char __user *) (uintptr_t) args->data_ptr;
	remain = args->size;

d742 1
d744 8
a751 12
	while (remain > 0) {
		/* Operation in this page
		 *
		 * page_base = page offset within aperture
		 * page_offset = offset within page
		 * page_length = bytes to copy for this page
		 */
		page_base = offset & PAGE_MASK;
		page_offset = offset_in_page(offset);
		page_length = remain;
		if ((page_offset + remain) > PAGE_SIZE)
			page_length = PAGE_SIZE - page_offset;
d753 2
a754 9
		/* If we get a fault while copying data, then (presumably) our
		 * source page isn't available.  Return the error and we'll
		 * retry in the slow path.
		 */
		if (fast_user_write(dev_priv->mm.gtt_mapping, page_base,
				    page_offset, user_data, page_length)) {
			ret = -EFAULT;
			goto out_unpin;
		}
d756 2
a757 4
		remain -= page_length;
		user_data += page_length;
		offset += page_length;
	}
d770 1
a770 1
shmem_pwrite_fast(struct page *page, int shmem_page_offset, int page_length,
d800 1
a800 1
shmem_pwrite_slow(struct page *page, int shmem_page_offset, int page_length,
d826 1
a826 1
	kunmap(page);
d838 1
a838 1
	loff_t offset;
a845 1
	struct scatterlist *sg;
d880 2
a881 2
	for_each_sg(obj->pages->sgl, sg, obj->pages->nents, i) {
		struct page *page;
d906 1
a906 1
				& (boot_cpu_data.x86_clflush_size - 1));
d908 1
d912 5
d926 1
a926 1
		mutex_unlock(&dev->struct_mutex);
d932 1
a932 1
		mutex_lock(&dev->struct_mutex);
d935 1
d938 3
a969 1
#endif /* notyet */
d980 6
a985 8
	struct inteldrm_softc		*dev_priv = dev->dev_private;
	struct drm_i915_gem_pwrite	*args = data;
	struct drm_i915_gem_object	*obj;
	char				*vaddr;
	bus_space_handle_t		 bsh;
	bus_size_t			 bsize;
	off_t				 offset;
	int				 ret = 0;
d994 2
a995 2
	if (args->offset > obj->base.size || args->size > obj->base.size ||
	    args->offset + args->size > obj->base.size) {
d1000 9
d1014 7
a1020 22
	ret = i915_gem_object_pin(obj, 0, true, true);
	if (ret)
		goto out;

	ret = i915_gem_object_set_to_gtt_domain(obj, true);
	if (ret)
		goto unpin;

	ret = i915_gem_object_put_fence(obj);
	if (ret)
		goto unpin;

	offset = obj->gtt_offset + args->offset;
	bsize = round_page(offset + args->size) - trunc_page(offset);

	if ((ret = agp_map_subregion(dev_priv->agph,
	    trunc_page(offset), bsize, &bsh)) != 0)
		goto unpin;
	vaddr = bus_space_vaddr(dev_priv->bst, bsh);
	if (vaddr == NULL) {
		ret = -EFAULT;
		goto unmap;
d1023 2
a1024 2
	ret = -copyin((char *)(uintptr_t)args->data_ptr,
	    vaddr + (offset & PAGE_MASK), args->size);
a1025 4
unmap:
	agp_unmap_subregion(dev_priv->agph, bsh, bsize);
unpin:
	i915_gem_object_unpin(obj);
@


1.58
log
@Bring i915_gem_mmap_ioctl a bit closer to the Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.57 2013/12/07 17:20:47 kettenis Exp $	*/
d1771 1
a1771 1
		struct vm_page *pg = PHYS_TO_VM_PAGE(obj->pages[i].ds_addr);
d1774 1
a1774 1
			atomic_clearbits_int(&pg->pg_flags, PG_CLEAN);
d1880 1
a1880 1
	bus_dma_segment_t *segs;
d1882 1
a1882 1
	struct vm_page *pg;
d1942 3
a1944 3
	segs = malloc(page_count * sizeof(*segs), M_DRM,
	    M_WAITOK | M_CANFAIL | M_ZERO);
	if (segs == NULL)
d1952 2
a1953 3
	TAILQ_FOREACH(pg, &plist, pageq) {
		segs[i].ds_addr = VM_PAGE_TO_PHYS(pg);
		segs[i].ds_len = PAGE_SIZE;
d1956 1
a1956 1
	obj->pages = segs;
d1973 1
a1973 1
	drm_free(segs);
a3144 1
	bus_dma_segment_t *segp;
d3146 1
a3146 1
	int i, n;
d3148 2
a3149 10
	segp = &obj->pages[0];
	n = 0;
	for (i = 0; i < page_count; i++) {
		pmap_flush_page(segp->ds_addr + n);
		n += PAGE_SIZE;
		if (n >= segp->ds_len) {
			n = 0;
			segp++;
		}
	}
@


1.57
log
@Emulating wait_event_timeout() using msleep() is hard.  This version should
avoid the negative timeout panic and make __wait_seqno() properly wait
forever if no timeout was specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.56 2013/12/06 23:41:51 kettenis Exp $	*/
d1344 1
a1344 2
	voff_t offset;
	vsize_t end, nsize;
d1347 9
a1359 20
	/* Since we are doing purely uvm-related operations here we do
	 * not need to hold the object, a reference alone is sufficient
	 */

	/* Check size. Also ensure that the object is not purgeable */
	if (args->size == 0 || args->offset > obj->size || args->size >
	    obj->size || (args->offset + args->size) > obj->size ||
	    i915_gem_object_is_purgeable(to_intel_bo(obj))) {
		ret = -EINVAL;
		goto done;
	}

	end = round_page(args->offset + args->size);
	offset = trunc_page(args->offset);
	nsize = end - offset;

	/*
	 * We give our reference from object_lookup to the mmap, so only
	 * must free it in the case that the map fails.
	 */
d1361 2
a1362 2
	ret = uvm_map(&curproc->p_vmspace->vm_map, &addr, nsize, obj->uao,
	    offset, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
a1365 2

done:
d1370 1
a1370 1
	args->addr_ptr = (uint64_t) addr + (args->offset & PAGE_MASK);
@


1.56
log
@Change a WARN_ON into a BUG_ON to match Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.55 2013/12/06 20:13:29 kettenis Exp $	*/
d1062 1
d1071 1
a1071 1
			    "gemwt", timeout_jiffies);
d1074 2
a1075 4
			timeout_jiffies = timespec_to_jiffies(&wait_time);
			timeout_jiffies -= timespec_to_jiffies(&sleep_time);
			if (timeout_jiffies <= 0) {
				timeout_jiffies = 0;
d1078 2
a1083 1
			end = timeout_jiffies;
@


1.55
log
@It seems to be possible to truncate an object while it is still mapped.
Don't panic in that case but force a page fault instead.  Hopefully this
fixes the panic during coredump that deraadt@@ reported.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.54 2013/12/05 13:29:56 kettenis Exp $	*/
d3258 1
a3258 1
	WARN_ON((obj->base.write_domain & ~I915_GEM_DOMAIN_GTT) != 0);
@


1.54
log
@Rename 'struct drm_obj' to 'struct drm_gem_object' to reduce the diffs with
Linux.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.53 2013/12/01 14:23:48 kettenis Exp $	*/
d1405 7
a1411 1
	KASSERT(obj->base.map);
@


1.53
log
@drm/i915: Fix write-read race with multiple rings

From Chris Wilson
caf40bcc8f6751b723f0ec78e2f67beb771bfb68 in ubuntu 3.8
02978ff57a5bdfbf703d2bc5a4d933a53ede3144 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.52 2013/12/01 12:58:33 kettenis Exp $	*/
d1342 1
a1342 1
	struct drm_obj *obj;
d1390 1
a1390 1
i915_gem_fault(struct drm_obj *gem_obj, struct uvm_faultinfo *ufi,
d3895 1
a3895 1
int i915_gem_init_object(struct drm_obj *obj)
d3902 1
a3902 1
void i915_gem_free_object(struct drm_obj *gem_obj)
@


1.52
log
@drm/i915: Correct obj->mm_list link to dev_priv->dev_priv->mm.inactive_list

From Xiong Zhang
77e700964bdb06caf7eaf03371d7ffd4a6500199 in ubuntu 3.8
067556084a0e412013af6b0250a3143ae5afde6d in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.51 2013/12/01 11:47:13 kettenis Exp $	*/
d2023 4
@


1.51
log
@Bring back the DRM_IOCTL_I915_GEM_WAIT diff now that I've figured out what
made it fail (WARN_ON() was evaluating its argument multiple times).
This time, also advertise support through I915_PARAM_HAS_WAIT_TIMEOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.50 2013/11/30 20:13:36 kettenis Exp $	*/
d4556 1
a4556 1
	list_for_each_entry(obj, &dev_priv->mm.inactive_list, gtt_list)
@


1.50
log
@Oops!  Only intended to commit the i915_dma.c changes in the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.48 2013/11/28 20:32:20 kettenis Exp $	*/
d55 1
d82 5
d1032 7
a1038 3
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret = 0;
d1043 23
a1065 6
	mtx_enter(&dev_priv->irq_lock);
	if (!i915_seqno_passed(ring->get_seqno(ring, true), seqno)) {
		ring->irq_get(ring);
		while (ret == 0) {
			if (i915_seqno_passed(ring->get_seqno(ring, false),
			    seqno) || dev_priv->mm.wedged)
d1067 2
a1068 1
			ret = -msleep(ring, &dev_priv->irq_lock,
d1070 24
a1093 1
			    "gemwt", 0);
d1095 15
a1109 1
		ring->irq_put(ring);
a1110 3
	mtx_leave(&dev_priv->irq_lock);
	if (dev_priv->mm.wedged)
		ret = -EIO;
d1112 13
a1124 1
	return ret;
a2424 1
#ifdef notyet
d2468 1
a2468 1
		mutex_unlock(&dev->struct_mutex);
d2489 1
a2489 1
		ret = -ETIME;
d2494 1
a2494 1
	mutex_unlock(&dev->struct_mutex);
d2505 1
a2505 1
	mutex_unlock(&dev->struct_mutex);
a2507 1
#endif /* notyet */
d4565 51
@


1.49
log
@Reorder some case statements to reduce the diffs with Linux.
@
text
@a54 1
#include <sys/time.h>
a80 5
static inline int timespec_to_jiffies(const struct timespec *);
static inline int timespec_valid(const struct timespec *);
static struct timespec ns_to_timespec(const int64_t);
static inline int64_t timespec_to_ns(const struct timespec *);

d1026 3
a1028 7
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	struct timespec before, now, wait_time={1,0};
	struct timespec sleep_time;
	unsigned long timeout_jiffies;
	long end;
	bool wait_forever = true;
	int ret;
d1033 6
a1038 28
	trace_i915_gem_request_wait_begin(ring, seqno);

	if (timeout != NULL) {
		wait_time = *timeout;
		wait_forever = false;
	}

	timeout_jiffies = timespec_to_jiffies(&wait_time);

#if 0
	if (WARN_ON(!ring->irq_get(ring)))
		return -ENODEV;
#else
	if (!ring->irq_get(ring))
		return -ENODEV;
#endif

	/* Record current time in case interrupted by signal, or wedged * */
	nanouptime(&before);

#define EXIT_COND \
	(i915_seqno_passed(ring->get_seqno(ring, false), seqno) || \
	atomic_read(&dev_priv->mm.wedged))
	do {
		mtx_enter(&dev_priv->irq_lock);
		do {
			if (EXIT_COND) {
				ret = 0;
d1040 1
a1040 2
			}
			ret = msleep(ring, &dev_priv->irq_lock,
d1042 1
a1042 24
			    "gemwt", timeout_jiffies);
			nanouptime(&now);
			timespecsub(&now, &before, &sleep_time);
			timeout_jiffies = timespec_to_jiffies(&wait_time);
			timeout_jiffies -= timespec_to_jiffies(&sleep_time);
			if (timeout_jiffies <= 0) {
				timeout_jiffies = 0;
				break;
			}
		} while (ret == 0);
		mtx_leave(&dev_priv->irq_lock);
		switch (ret) {
		case 0:
			end = timeout_jiffies;
			break;
		case ERESTART:
			end = -ERESTARTSYS;
			break;
		case EWOULDBLOCK:
			end = 0;
			break;
		default:
			end = -ret;
			break;
d1044 1
a1044 15

		ret = i915_gem_check_wedge(dev_priv, interruptible);
		if (ret)
			end = ret;
	} while (end == 0 && wait_forever);

	nanouptime(&now);

	ring->irq_put(ring);
	trace_i915_gem_request_wait_end(ring, seqno);
#undef EXIT_COND

	if (timeout) {
		timespecsub(&now, &before, &sleep_time);
		timespecsub(timeout, &sleep_time, timeout);
d1046 3
d1050 1
a1050 13
	switch (end) {
	case -EIO:
	case -EAGAIN: /* Wedged */
	case -ERESTARTSYS: /* Signal */
		return (int)end;
	case 0: /* Timeout */
		if (timeout)
			timeout->tv_sec = timeout->tv_nsec = 0;
		return -ETIMEDOUT;
	default: /* Completed */
		WARN_ON(end < 0); /* We're not aware of other errors */
		return 0;
	}
d2351 1
d2395 1
a2395 1
		DRM_UNLOCK();
d2416 1
a2416 1
		ret = -ETIMEDOUT;
d2421 1
a2421 1
	DRM_UNLOCK();
d2432 1
a2432 1
	DRM_UNLOCK();
d2435 1
a4492 51

#define NSEC_PER_SEC	1000000000L

static inline int64_t
timespec_to_ns(const struct timespec *ts)
{
	return ((ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec);
}

static inline int
timespec_to_jiffies(const struct timespec *ts)
{
	long long to_ticks;

	to_ticks = (long long)hz * ts->tv_sec + ts->tv_nsec / (tick * 1000);
	if (to_ticks > INT_MAX)
		to_ticks = INT_MAX;

	return ((int)to_ticks);
}

static struct timespec
ns_to_timespec(const int64_t nsec)
{
	struct timespec ts;
	int32_t rem;

	if (nsec == 0) {
		ts.tv_sec = 0;
		ts.tv_nsec = 0;
		return (ts);
	}

	ts.tv_sec = nsec / NSEC_PER_SEC;
	rem = nsec % NSEC_PER_SEC;
	if (rem < 0) {
		ts.tv_sec--;
		rem += NSEC_PER_SEC;
	}
	ts.tv_nsec = rem;
	return (ts);
}

static inline int
timespec_valid(const struct timespec *ts)
{
	if (ts->tv_sec < 0 || ts->tv_sec > 100000000 ||
	    ts->tv_nsec < 0 || ts->tv_nsec >= 1000000000)
		return (0);
	return (1);
}
@


1.48
log
@Add short-circuit code to __wait_seqno() that's also present in Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.47 2013/11/27 20:13:30 kettenis Exp $	*/
d55 1
d82 5
d1032 7
a1038 3
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret = 0;
d1043 28
a1070 6
	mtx_enter(&dev_priv->irq_lock);
	if (!i915_seqno_passed(ring->get_seqno(ring, true), seqno)) {
		ring->irq_get(ring);
		while (ret == 0) {
			if (i915_seqno_passed(ring->get_seqno(ring, false),
			    seqno) || dev_priv->mm.wedged)
d1072 2
a1073 1
			ret = -msleep(ring, &dev_priv->irq_lock,
d1075 24
a1098 1
			    "gemwt", 0);
d1100 15
a1114 1
		ring->irq_put(ring);
a1115 3
	mtx_leave(&dev_priv->irq_lock);
	if (dev_priv->mm.wedged)
		ret = -EIO;
d1117 13
a1129 1
	return ret;
a2429 1
#ifdef notyet
d2473 1
a2473 1
		mutex_unlock(&dev->struct_mutex);
d2494 1
a2494 1
		ret = -ETIME;
d2499 1
a2499 1
	mutex_unlock(&dev->struct_mutex);
d2510 1
a2510 1
	mutex_unlock(&dev->struct_mutex);
a2512 1
#endif /* notyet */
d4570 51
@


1.47
log
@Add 'struct drm_i915_gem_objects_ops' and use it; reduces diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.46 2013/11/20 02:03:52 jsg Exp $	*/
d1029 3
@


1.46
log
@switch to the drm_mm based gtt eviction code from linux 3.8.13
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.45 2013/11/19 19:14:09 kettenis Exp $	*/
a1721 1
#if 0
a1722 1
#endif
a1736 1
#if 0
a1737 3
#else
	i915_gem_object_put_pages_gtt(obj);
#endif
a1920 1
#if 0
a1921 1
#endif
a1928 1
#if 0
a1929 3
#else
	ret = i915_gem_object_get_pages_gtt(obj);
#endif
d3754 2
a3755 1
void i915_gem_object_init(struct drm_i915_gem_object *obj)
d3762 2
d3772 5
d3791 1
a3791 1
	i915_gem_object_init(obj);
@


1.45
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.44 2013/11/19 15:08:04 jsg Exp $	*/
a3008 1
#if 0
a3012 3
#else
		ret = i915_gem_evict_something(dev_priv, size);
#endif
@


1.44
log
@backout the DRM_IOCTL_I915_GEM_WAIT commit
it seems to leave X unuseable on resume on at least snb/ivb
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.43 2013/11/17 18:47:13 kettenis Exp $	*/
d167 1
a167 1
	return obj->dmamap && !obj->active;
d174 1
a174 2
	struct inteldrm_softc		*dev_priv = dev->dev_private;
	struct drm_i915_gem_init	*args = data;
a178 2
	DRM_LOCK();

d180 1
a180 4
	    args->gtt_end > dev->agp->info.ai_aperture_size ||
	    (args->gtt_start & PAGE_MASK) != 0 ||
	    (args->gtt_end & PAGE_MASK) != 0) {
		DRM_UNLOCK();
a181 16
	}
	/*
	 * putting stuff in the last page of the aperture can cause nasty
	 * problems with prefetch going into unassigned memory. Since we put
	 * a scratch page on all unused aperture pages, just leave the last
	 * page as a spill to prevent gpu hangs.
	 */
	if (args->gtt_end == dev->agp->info.ai_aperture_size)
		args->gtt_end -= 4096;

	if (agp_bus_dma_init((struct agp_softc *)dev->agp->agpdev,
	    dev->agp->base + args->gtt_start, dev->agp->base + args->gtt_end,
	    &dev_priv->agpdmat) != 0) {
		DRM_UNLOCK();
		return -ENOMEM;
	}
d183 3
a185 1
	dev->gtt_total = (uint32_t)(args->gtt_end - args->gtt_start);
d187 3
d208 1
a208 1
			pinned += obj->dmamap->dm_segs[0].ds_len;
d1729 1
a1729 1
	BUG_ON(obj->dmamap);
d2526 1
a2526 6
	DRM_ASSERT_HELD(&obj->base);
	/*
	 * if it's already unbound, or we've already done lastclose, just
	 * let it happen. XXX does this fail to unwire?
	 */
	if (obj->dmamap == NULL || dev_priv->agpdmat == NULL)
d2551 9
a2559 4
	/*
	 * unload the map, then unwire the backing object.
	 */
	bus_dmamap_unload(dev_priv->agpdmat, obj->dmamap);
d2566 2
a2567 5
	obj->has_global_gtt_mapping = 0;

	/* XXX persistent dmamap worth the memory? */
	bus_dmamap_destroy(dev_priv->agpdmat, obj->dmamap);
	obj->dmamap = NULL;
d2626 1
a2626 1
		u32 size = obj->dmamap->dm_segs[0].ds_len;
d2655 1
a2655 1
		u32 size = obj->dmamap->dm_segs[0].ds_len;
d2699 1
a2699 1
		u32 size = obj->dmamap->dm_segs[0].ds_len;
d2901 29
a2929 1
// i915_gem_valid_gtt_space
d2946 1
a2949 3
	int flags;

	DRM_ASSERT_HELD(&obj->base);
d2992 2
a2993 4
	ret = -bus_dmamap_create(dev_priv->agpdmat, size, 1,
	    size, 0, BUS_DMA_WAITOK, &obj->dmamap);
	if (ret) {
		DRM_ERROR("Failed to create dmamap\n");
d2997 1
a2997 1
		return ret;
a2998 2
	agp_bus_dma_set_alignment(dev_priv->agpdmat, obj->dmamap,
	    alignment);
d3001 24
a3024 12
	switch (obj->cache_level) {
	case I915_CACHE_NONE:
		flags = BUS_DMA_GTT_NOCACHE;
		break;
	case I915_CACHE_LLC:
		flags = BUS_DMA_GTT_CACHE_LLC;
		break;
	case I915_CACHE_LLC_MLC:
		flags = BUS_DMA_GTT_CACHE_LLC_MLC;
		break;
	default:
		BUG();
d3026 6
a3031 8
	ret = -bus_dmamap_load_raw(dev_priv->agpdmat, obj->dmamap, obj->pages,
				   obj->base.size / PAGE_SIZE, obj->base.size,
				   BUS_DMA_WAITOK | obj->dma_flags | flags);
	if (ret) {
		ret = i915_gem_evict_something(dev_priv, obj->base.size);
		if (ret)
			goto error;
		goto search_free;
d3034 7
a3040 16
	/*
	 * Create a mapping that wraps around once; the second half
	 * maps to the same set of physical pages as the first half.
	 * Used to implement fast vertical scrolling in inteldrm(4).
	 *
	 * XXX This is an ugly hack that wastes pages and abuses the
	 * internals of the scatter gather DMA code.
	 */
	if (obj->dma_flags & BUS_DMA_GTT_WRAPAROUND) {
		struct sg_page_map *spm = obj->dmamap->_dm_cookie;
		int i;

		for (i = spm->spm_pagecnt / 2; i < spm->spm_pagecnt; i++)
			spm->spm_map[i].spe_pa =
				spm->spm_map[i - spm->spm_pagecnt / 2].spe_pa;
		agp_bus_dma_rebind(dev_priv->agpdmat, obj->dmamap, flags);
d3046 2
a3047 1
	obj->gtt_offset = obj->dmamap->dm_segs[0].ds_addr - dev->agp->base;
d3050 2
a3051 2
		obj->dmamap->dm_segs[0].ds_len == fence_size &&
		(obj->dmamap->dm_segs[0].ds_addr & (fence_alignment - 1)) == 0;
a3061 9

error:
	i915_gem_object_unpin_pages(obj);
	/* XXX Until we've hooked up the shrinking functions. */
	i915_gem_object_put_pages(obj);
	bus_dmamap_destroy(dev_priv->agpdmat, obj->dmamap);
	obj->dmamap = NULL;
	obj->gtt_offset = 0;
	return ret;
a3066 3
	struct drm_device *dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;

a3069 4
	 *
	 * XXX On OpenBSD we check if we have a DMA mapping instead,
	 * as the bus_dmamap_sync(9) call below needs one.  If we're
	 * not pinned to the GPU, we don't have a DMA mapping either.
d3071 1
a3071 1
	if (obj->dmamap == NULL)
d3085 22
a3106 2
	bus_dmamap_sync(dev_priv->agpdmat, obj->dmamap, 0,
	    obj->base.size, BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
d3171 1
a3171 1
	if (obj->dmamap == NULL)
d3223 7
a3229 1
	if (obj->dmamap) {
d3247 1
a3247 1
			i915_gem_gtt_rebind_object(obj, cache_level);
d3253 2
a3526 2
	DRM_ASSERT_HELD(&obj->base);

d3530 1
a3530 1
	if (obj->dmamap != NULL) {
d3546 1
a3546 1
	if (obj->dmamap == NULL) {
d3560 1
a3560 1
			i915_gem_gtt_rebind_object(obj, obj->cache_level);
d3564 1
a3564 1
		i915_gem_gtt_rebind_object(obj, obj->cache_level);
d3576 1
a3576 1
	BUG_ON(obj->dmamap == NULL);
d4051 5
a4055 4
	struct drm_i915_private		*dev_priv = dev->dev_private;
	uint64_t			 gtt_start, gtt_end;
	struct agp_softc		*asc;
	int				 ret;
d4058 5
d4064 1
a4064 2
	asc = (struct agp_softc *)dev->agp->agpdev;
	gtt_start = asc->sc_stolen_entries * 4096;
d4066 20
a4085 13
	/*
	 * putting stuff in the last page of the aperture can cause nasty
	 * problems with prefetch going into unassigned memory. Since we put
	 * a scratch page on all unused aperture pages, just leave the last
	 * page as a spill to prevent gpu hangs.
	 */
	gtt_end = dev->agp->info.ai_aperture_size - 4096;

	if (agp_bus_dma_init(asc,
	    dev->agp->base + gtt_start, dev->agp->base + gtt_end,
	    &dev_priv->agpdmat) != 0) {
		DRM_UNLOCK();
		return -ENOMEM;
d4087 1
a4087 7

	dev->gtt_total = (uint32_t)(gtt_end - gtt_start);

	dev_priv->mm.gtt_start = gtt_start;
	dev_priv->mm.gtt_mappable_end = gtt_end;
	dev_priv->mm.gtt_end = gtt_end;
	dev_priv->mm.gtt_total = gtt_end - gtt_start;
@


1.43
log
@Implement DRM_IOCTL_I915_GEM_WAIT.  Based on an earlier diff from jsg@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.42 2013/11/17 14:29:45 jsg Exp $	*/
a54 1
#include <sys/time.h>
a80 5
static inline int timespec_to_jiffies(const struct timespec *);
static inline int timespec_valid(const struct timespec *);
static struct timespec ns_to_timespec(const int64_t);
static inline int64_t timespec_to_ns(const struct timespec *);

d1043 3
a1045 25
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	struct timespec before, now, wait_time={1,0};
	struct timespec sleep_time;
	unsigned long timeout_jiffies;
	long end;
	bool wait_forever = true;
	int ret;

	if (i915_seqno_passed(ring->get_seqno(ring, true), seqno))
		return 0;

	trace_i915_gem_request_wait_begin(ring, seqno);

	if (timeout != NULL) {
		wait_time = *timeout;
		wait_forever = false;
	}

	timeout_jiffies = timespec_to_jiffies(&wait_time);

	if (WARN_ON(!ring->irq_get(ring)))
		return -ENODEV;

	/* Record current time in case interrupted by signal, or wedged * */
	nanouptime(&before);
d1047 6
a1052 8
#define EXIT_COND \
	(i915_seqno_passed(ring->get_seqno(ring, false), seqno) || \
	atomic_read(&dev_priv->mm.wedged))
	do {
		mtx_enter(&dev_priv->irq_lock);
		do {
			if (EXIT_COND) {
				ret = 0;
d1054 1
a1054 2
			}
			ret = msleep(ring, &dev_priv->irq_lock,
d1056 1
a1056 24
			    "gemwt", timeout_jiffies);
			nanouptime(&now);
			timespecsub(&now, &before, &sleep_time);
			timeout_jiffies = timespec_to_jiffies(&wait_time);
			timeout_jiffies -= timespec_to_jiffies(&sleep_time);
			if (timeout_jiffies <= 0) {
				timeout_jiffies = 0;
				break;
			}
		} while (ret == 0);
		mtx_leave(&dev_priv->irq_lock);
		switch (ret) {
		case 0:
			end = timeout_jiffies;
			break;
		case ERESTART:
			end = -ERESTARTSYS;
			break;
		case EWOULDBLOCK:
			end = 0;
			break;
		default:
			end = -ret;
			break;
d1058 1
a1058 15

		ret = i915_gem_check_wedge(dev_priv, interruptible);
		if (ret)
			end = ret;
	} while (end == 0 && wait_forever);

	nanouptime(&now);

	ring->irq_put(ring);
	trace_i915_gem_request_wait_end(ring, seqno);
#undef EXIT_COND

	if (timeout) {
		timespecsub(&now, &before, &sleep_time);
		timespecsub(timeout, &sleep_time, timeout);
d1060 3
d1064 1
a1064 13
	switch (end) {
	case -EIO:
	case -EAGAIN: /* Wedged */
	case -ERESTARTSYS: /* Signal */
		return (int)end;
	case 0: /* Timeout */
		if (timeout)
			timeout->tv_sec = timeout->tv_nsec = 0;
		return -ETIMEDOUT;
	default: /* Completed */
		WARN_ON(end < 0); /* We're not aware of other errors */
		return 0;
	}
d2377 1
d2421 1
a2421 1
		DRM_UNLOCK();
d2442 1
a2442 1
		ret = -ETIMEDOUT;
d2447 1
a2447 1
	DRM_UNLOCK();
d2458 1
a2458 1
	DRM_UNLOCK();
d2461 1
a4477 51

#define NSEC_PER_SEC	1000000000L

static inline int64_t
timespec_to_ns(const struct timespec *ts)
{
	return ((ts->tv_sec * NSEC_PER_SEC) + ts->tv_nsec);
}

static inline int
timespec_to_jiffies(const struct timespec *ts)
{
	long long to_ticks;

	to_ticks = (long long)hz * ts->tv_sec + ts->tv_nsec / (tick * 1000);
	if (to_ticks > INT_MAX)
		to_ticks = INT_MAX;

	return ((int)to_ticks);
}

static struct timespec
ns_to_timespec(const int64_t nsec)
{
	struct timespec ts;
	int32_t rem;

	if (nsec == 0) {
		ts.tv_sec = 0;
		ts.tv_nsec = 0;
		return (ts);
	}

	ts.tv_sec = nsec / NSEC_PER_SEC;
	rem = nsec % NSEC_PER_SEC;
	if (rem < 0) {
		ts.tv_sec--;
		rem += NSEC_PER_SEC;
	}
	ts.tv_nsec = rem;
	return (ts);
}

static inline int
timespec_valid(const struct timespec *ts)
{
	if (ts->tv_sec < 0 || ts->tv_sec > 100000000 ||
	    ts->tv_nsec < 0 || ts->tv_nsec >= 1000000000)
		return (0);
	return (1);
}
@


1.42
log
@drm/i915: Only clear write-domains after a successful wait-seqno

From Chris Wilson
5ca3f11716a0487110745824ad5282bf4c00d211 in ubuntu 3.8
daa13e1ca587bc773c1aae415ed1af6554117bd4 in mainline linux
https://bugs.freedesktop.org/show_bug.cgi?id=66163
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.41 2013/11/02 22:58:10 kettenis Exp $	*/
d55 1
d82 5
d1049 25
a1073 3
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	int ret = 0;
d1075 8
a1082 6
	mtx_enter(&dev_priv->irq_lock);
	if (!i915_seqno_passed(ring->get_seqno(ring, true), seqno)) {
		ring->irq_get(ring);
		while (ret == 0) {
			if (i915_seqno_passed(ring->get_seqno(ring, false),
			    seqno) || dev_priv->mm.wedged)
d1084 2
a1085 1
			ret = -msleep(ring, &dev_priv->irq_lock,
d1087 24
a1110 1
			    "gemwt", 0);
d1112 15
a1126 1
		ring->irq_put(ring);
a1127 3
	mtx_leave(&dev_priv->irq_lock);
	if (dev_priv->mm.wedged)
		ret = -EIO;
d1129 13
a1141 1
	return ret;
a2453 1
#ifdef notyet
d2497 1
a2497 1
		mutex_unlock(&dev->struct_mutex);
d2518 1
a2518 1
		ret = -ETIME;
d2523 1
a2523 1
	mutex_unlock(&dev->struct_mutex);
d2534 1
a2534 1
	mutex_unlock(&dev->struct_mutex);
a2536 1
#endif /* notyet */
d4553 51
@


1.41
log
@Replace drm_handle_create/delete with drm_gem_handle_create/delete and make
the necessary adjustments to reference counting of GEM objects.  Matches what
Linux does these days.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.40 2013/11/02 14:37:19 kettenis Exp $	*/
d1164 2
a1165 1
	if (obj->last_write_seqno &&
@


1.40
log
@Fix reference leak in i915_gem_mmap_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.39 2013/10/29 06:30:57 jsg Exp $	*/
d253 5
a257 3
	ret = -drm_handle_create(file, &obj->base, &handle);
	if (ret != 0) {
		drm_unref(&obj->base.uobj);
d261 4
a284 1
#if 0
a285 3
#else
	return drm_handle_delete(file, handle);
#endif
@


1.39
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.38 2013/10/26 20:31:48 kettenis Exp $	*/
d1317 5
a1321 4
	if (ret == 0)
		args->addr_ptr = (uint64_t) addr + (args->offset & PAGE_MASK);
	else
		drm_unref(&obj->uobj);
d1323 1
a1323 1
	return ret;
@


1.38
log
@Unstub i915_gem_dumb_destroy() and radeon_mode_dumb_destroy().
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.37 2013/10/05 07:30:06 jsg Exp $	*/
d54 1
a54 1
#include <sys/workq.h>
d3880 1
d4176 2
@


1.37
log
@add and use gtt mapping flags, further reduces the diff to linux
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.36 2013/10/03 18:12:18 kettenis Exp $	*/
d279 5
a283 3
	printf("%s stub\n", __func__);
	return -ENOSYS;
//	return (drm_gem_handle_delete(file, handle));
@


1.36
log
@Another fix from Linux that ended up being packported to the 3.8.13 stable
branche maintained by the Ubuntu folks.  Original linux commit message:
'Fix incoherence with fence updates on Sandybridge+'.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.35 2013/09/13 13:00:00 kettenis Exp $	*/
d2577 2
d3226 2
a3227 2
		i915_gem_gtt_rebind_object(obj, cache_level);
		
d3527 4
d3536 5
d3542 3
@


1.35
log
@Fix sign of returned error code.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.34 2013/09/10 03:40:39 jsg Exp $	*/
d2608 2
a2609 2
static void sandybridge_write_fence_reg(struct drm_device *dev, int reg,
					struct drm_i915_gem_object *obj)
d2612 2
a2613 1
	uint64_t val;
d2615 7
a2621 2
	if (obj) {
		u32 size = obj->dmamap->dm_segs[0].ds_len;
d2623 1
a2623 5
		val = (uint64_t)((obj->gtt_offset + size - 4096) &
				 0xfffff000) << 32;
		val |= obj->gtt_offset & 0xfffff000;
		val |= (uint64_t)((obj->stride / 128) - 1) <<
			SANDYBRIDGE_FENCE_PITCH_SHIFT;
d2625 11
a2635 15
		if (obj->tiling_mode == I915_TILING_Y)
			val |= 1 << I965_FENCE_TILING_Y_SHIFT;
		val |= I965_FENCE_REG_VALID;
	} else
		val = 0;

	I915_WRITE64(FENCE_REG_SANDYBRIDGE_0 + reg * 8, val);
	POSTING_READ(FENCE_REG_SANDYBRIDGE_0 + reg * 8);
}

static void i965_write_fence_reg(struct drm_device *dev, int reg,
				 struct drm_i915_gem_object *obj)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	uint64_t val;
d2639 1
d2644 1
a2644 1
		val |= ((obj->stride / 128) - 1) << I965_FENCE_PITCH_SHIFT;
a2647 2
	} else
		val = 0;
d2649 9
a2657 2
	I915_WRITE64(FENCE_REG_965_0 + reg * 8, val);
	POSTING_READ(FENCE_REG_965_0 + reg * 8);
d2741 1
a2741 1
	case 6: sandybridge_write_fence_reg(dev, reg, obj); break;
a2755 7
#ifdef __linux__
static void i915_gem_write_fence__ipi(void *data)
{
	wbinvd();
}
#endif

d2760 2
a2761 3
	struct drm_device *dev = obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int fence_reg = fence_number(dev_priv, fence);
d2763 1
a2763 17
	/* In order to fully serialize access to the fenced region and
	 * the update to the fence register we need to take extreme
	 * measures on SNB+. In theory, the write to the fence register
	 * flushes all memory transactions before, and coupled with the
	 * mb() placed around the register write we serialise all memory
	 * operations with respect to the changes in the tiler. Yet, on
	 * SNB+ we need to take a step further and emit an explicit wbinvd()
	 * on each processor in order to manually flush all memory
	 * transactions before updating the fence register.
	 */
	if (HAS_LLC(obj->base.dev))
#ifdef __linux__
		on_each_cpu(i915_gem_write_fence__ipi, NULL, 1);
#else
		wbinvd();
#endif
	i915_gem_write_fence(dev, fence_reg, enable ? obj : NULL);
d2766 1
a2766 1
		obj->fence_reg = fence_reg;
@


1.34
log
@Enable some code that seems to relate to an errata for
Crystalwell/eDRAM Haswell parts.  Original linux commit mesage:
'This magic brings stability to HSW CRW machines.'
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.33 2013/08/13 10:23:49 jsg Exp $	*/
d1050 1
a1050 1
			ret = msleep(ring, &dev_priv->irq_lock,
@


1.33
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.32 2013/08/09 07:55:42 jsg Exp $	*/
d3970 1
d3975 1
d3977 1
a3978 1
#endif
@


1.32
log
@add commented out versions of unused functions present in the original
files to reduce the diff to linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.31 2013/08/07 19:49:06 kettenis Exp $	*/
d56 24
a79 35
int i915_gem_object_needs_bit17_swizzle(struct drm_i915_gem_object *obj);
int i915_gem_object_get_pages_gtt(struct drm_i915_gem_object *obj);
void i915_gem_object_put_pages_gtt(struct drm_i915_gem_object *obj);
int i915_gem_object_put_pages(struct drm_i915_gem_object *obj);
uint32_t i915_gem_get_gtt_size(struct drm_device *dev, uint32_t size,
			       int tiling_mode);
uint32_t i915_gem_get_gtt_alignment(struct drm_device *dev,
				    uint32_t size, int tiling_mode);
void i915_gem_object_finish_gtt(struct drm_i915_gem_object *);
void i915_gem_object_flush_cpu_write_domain(struct drm_i915_gem_object *);
int i915_gem_init_phys_object(struct drm_device *, int, int, int);
int i915_gem_phys_pwrite(struct drm_device *, struct drm_i915_gem_object *,
			 struct drm_i915_gem_pwrite *, struct drm_file *);
bool intel_enable_blt(struct drm_device *);
int i915_gem_handle_seqno_wrap(struct drm_device *);
void i915_gem_object_update_fence(struct drm_i915_gem_object *,
    struct drm_i915_fence_reg *, bool);
int i915_gem_object_flush_fence(struct drm_i915_gem_object *);
struct drm_i915_fence_reg *i915_find_fence_reg(struct drm_device *);
void i915_gem_reset_ring_lists(struct drm_i915_private *,
    struct intel_ring_buffer *);
void i915_gem_object_flush_gtt_write_domain(struct drm_i915_gem_object *);
void i915_gem_request_remove_from_client(struct drm_i915_gem_request *);
int i915_gem_object_flush_active(struct drm_i915_gem_object *);
int i915_gem_check_olr(struct intel_ring_buffer *, u32);
void i915_gem_object_truncate(struct drm_i915_gem_object *obj);
void i915_gem_verify_gtt(struct drm_device *dev);
int i915_gem_object_bind_to_gtt(struct drm_i915_gem_object *obj,
				unsigned alignment, bool map_and_fenceable,
				bool nonblocking);
int i915_gem_wait_for_error(struct drm_device *);
int __wait_seqno(struct intel_ring_buffer *, uint32_t, bool, struct timespec *);
int i915_gem_object_create_mmap_offset(struct drm_i915_gem_object *);
void i915_gem_object_free_mmap_offset(struct drm_i915_gem_object *);
void i915_gem_object_init(struct drm_i915_gem_object *);
d110 1
a110 1
int
d148 1
a148 2
int
i915_mutex_lock_interruptible(struct drm_device *dev)
d234 1
a234 1
int
d275 3
a277 3
int
i915_gem_dumb_destroy(struct drm_file *file, struct drm_device *dev,
    uint32_t handle)
d297 1
a297 2
int
i915_gem_object_needs_bit17_swizzle(struct drm_i915_gem_object *obj)
d1012 1
a1012 1
int
d1036 2
a1037 3
int
__wait_seqno(struct intel_ring_buffer *ring, uint32_t seqno,
		bool interruptible, struct timespec *timeout)
d1093 1
a1093 1
int
d1126 1
a1126 1
static int
d1461 1
a1461 1
uint32_t
d1489 1
a1489 1
uint32_t
d1538 1
a1538 2
int
i915_gem_object_create_mmap_offset(struct drm_i915_gem_object *obj)
d1578 1
a1578 2
void
i915_gem_object_free_mmap_offset(struct drm_i915_gem_object *obj)
d1655 1
a1655 1
void
d1672 1
a1672 1
void
d1730 1
a1730 1
int
d1815 1
a1815 1
int
d1997 1
a1997 1
void
d2024 1
a2024 1
int
d2151 1
a2151 1
void
d2167 1
a2167 2
void
i915_gem_reset_ring_lists(struct drm_i915_private *dev_priv,
d2193 1
a2193 2
void
i915_gem_reset_fences(struct drm_device *dev)
d2214 1
a2214 2
void
i915_gem_reset(struct drm_device *dev)
d2355 1
a2355 1
int
d2504 1
a2504 2
void
i915_gem_object_finish_gtt(struct drm_i915_gem_object *obj)
d2588 1
a2588 2
int
i915_gpu_idle(struct drm_device *dev)
d2608 1
a2608 2
void
sandybridge_write_fence_reg(struct drm_device *dev, int reg,
d2633 1
a2633 2
void
i965_write_fence_reg(struct drm_device *dev, int reg,
d2656 1
a2656 2
void
i915_write_fence_reg(struct drm_device *dev, int reg,
d2700 1
a2700 2
void
i830_write_fence_reg(struct drm_device *dev, int reg,
d2732 1
a2732 2
void
i915_gem_write_fence(struct drm_device *dev, int reg,
d2746 1
a2746 2
static inline int
fence_number(struct drm_i915_private *dev_priv,
d2753 1
a2753 2
void
i915_gem_write_fence__ipi(void *data)
d2759 1
a2759 2
void
i915_gem_object_update_fence(struct drm_i915_gem_object *obj,
d2796 1
a2796 1
int
d2838 1
a2838 1
struct drm_i915_fence_reg *
d2935 1
a2935 2
void
i915_gem_verify_gtt(struct drm_device *dev)
d2942 1
a2942 1
int
d3114 1
a3114 1
void
d3141 1
a3141 1
void
d3212 1
a3212 2
int
i915_gem_object_set_cache_level(struct drm_i915_gem_object *obj,
d3281 1
a3281 2
int
i915_gem_get_caching_ioctl(struct drm_device *dev, void *data,
d3306 1
a3306 2
int
i915_gem_set_caching_ioctl(struct drm_device *dev, void *data,
d3756 1
a3756 2
void
i915_gem_object_init(struct drm_i915_gem_object *obj)
d3771 2
a3772 2
struct drm_i915_gem_object *
i915_gem_alloc_object(struct drm_device *dev, size_t size)
d3810 1
a3810 2
int
i915_gem_init_object(struct drm_obj *obj)
d3817 1
a3817 2
void
i915_gem_free_object(struct drm_obj *gem_obj)
d3922 1
a3922 2
void
i915_gem_init_swizzling(struct drm_device *dev)
d3943 1
a3943 1
bool
d4032 1
a4032 2
int
i915_gem_init(struct drm_device *dev)
d4155 1
a4155 1
void
d4222 2
a4223 3
int
i915_gem_init_phys_object(struct drm_device *dev,
			  int id, int size, int align)
d4376 1
a4376 1
int
d4393 1
a4393 2
void
i915_gem_release(struct drm_device *dev, struct drm_file *file)
@


1.31
log
@Another major overhaul of the inteldrm(4) GEM code, bringing us considerably
closer to the Linux 3.8.13 codebase.  Almost certainly squashes a few more
bugs.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.30 2013/08/07 00:04:28 jsg Exp $	*/
d318 246
d631 289
d1779 51
a1829 3
// __i915_gem_shrink
// i915_gem_purge
// i915_gem_shrink_all
d2390 85
a2474 1
// i915_gem_wait_ioctl
d3731 8
a3738 1
// i915_gem_throttle_ioctl
d3924 33
a3956 1
// i915_gem_l3_remap
d4052 16
a4067 1
// intel_enable_ppgtt
d4178 14
a4191 1
// i915_gem_lastclose
d4291 30
a4320 2
// i915_gem_free_phys_object
// i915_gem_free_all_phys_object
d4454 59
a4512 2
// mutex_is_locked_by
// i915_gem_inactive_shrink
@


1.30
log
@add support for hardware contexts on recent intel hardware
based on the code in linux 3.8.13
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.29 2013/07/29 18:32:15 kettenis Exp $	*/
d48 1
d59 1
d82 1
d94 1
a94 2
static inline void
i915_gem_object_fence_lost(struct drm_i915_gem_object *obj)
d106 14
a119 2
// i915_gem_info_add_obj
// i915_gem_info_remove_obj
d139 1
a139 1
		if (ret != 0) {
d141 1
a141 1
			return (ret);
d147 5
d168 1
a168 1
	ret = rw_enter(&dev->dev_lock, RW_WRITE | RW_INTR);
d179 1
a179 1
	return obj->dmamap && !obj->active && obj->pin_count == 0;
d190 1
a190 1
		return ENODEV;
d199 1
a199 1
		return (EINVAL);
d214 1
a214 1
		return (ENOMEM);
a217 1
	inteldrm_set_max_obj_size(dev_priv);
d228 1
d230 2
d233 1
a233 1
	/* we need a write lock here to make sure we get the right value */
d235 3
a237 3
	args->aper_size = dev->gtt_total;
	args->aper_available_size = (args->aper_size -
	    atomic_read(&dev->pin_memory));
d240 3
d265 1
a265 2
	handle = 0;
	ret = drm_handle_create(file, &obj->base, &handle);
d268 1
a268 1
		return (-ret);
a290 1

d292 1
a292 1
	return ENOSYS;
d303 1
a303 4
	struct inteldrm_softc		*dev_priv = dev->dev_private;
	struct drm_i915_gem_create	*args = data;
	struct drm_i915_gem_object	*obj;
	int				 handle, ret;
d305 2
a306 24
	args->size = round_page(args->size);
	/*
	 * XXX to avoid copying between 2 objs more than half the aperture size
	 * we don't allow allocations that are that big. This will be fixed
	 * eventually by intelligently falling back to cpu reads/writes in
	 * such cases. (linux allows this but does cpu maps in the ddx instead).
	 */
	if (args->size > dev_priv->max_gem_obj_size)
		return (EFBIG);

	/* Allocate the new object */
	obj = i915_gem_alloc_object(dev, args->size);
	if (obj == NULL)
		return (ENOMEM);

	/* we give our reference to the handle */
	ret = drm_handle_create(file, &obj->base, &handle);

	if (ret == 0)
		args->handle = handle;
	else
		drm_unref(&obj->base.uobj);

	return (ret);
d338 1
a338 1
		return ENOENT;
d347 1
a347 1
		ret = EINVAL;
d367 1
a367 1
		ret = EFAULT;
d371 1
a371 1
	ret = copyout(vaddr + (offset & PAGE_MASK),
d382 1
a382 1
	return (ret);
d405 1
a405 1
		return ENOENT;
d412 1
a412 1
		ret = EINVAL;
d441 1
a441 1
		ret = EFAULT;
d445 1
a445 1
	ret = copyin((char *)(uintptr_t)args->data_ptr,
d456 1
a456 1
	return (ret);
d537 1
a537 1
		ret = EIO;
d539 1
a539 1
	return (ret);
d568 4
d664 1
a664 1
		return EINVAL;
d667 1
a667 1
		return EINVAL;
d673 1
a673 1
		return EINVAL;
d681 1
a681 1
		ret = ENOENT;
d700 1
a700 1
		if (ret == EINVAL)
d730 1
a730 1
		ret = ENOENT;
d764 1
a764 1
		return ENOENT;
d774 1
a774 1
		ret = EINVAL;
d799 1
a799 1
	return (ret);
d840 4
a843 6
	/* Now bind into the GTT if needed */
	if (!obj->map_and_fenceable) {
		ret = i915_gem_object_unbind(obj);
		if (ret)
			goto error;
	}
d845 3
a847 9
	if (obj->dmamap == NULL) {
		ret = i915_gem_object_bind_to_gtt(obj, 0, true, false);
		if (ret)
			goto error;

		ret = i915_gem_object_set_to_gtt_domain(obj, write);
		if (ret)
			goto error;
	}
d851 1
a851 4
		goto error;

	if (i915_gem_object_is_inactive(obj))
		list_move_tail(&obj->mm_list, &dev_priv->mm.inactive_list);
d877 1
d887 3
a889 1
error:
d895 1
a895 1
	if (ret == EIO) {
d906 1
a906 1
	return (ret);
d1152 92
a1243 1
// i915_gem_object_put_pages
a1246 1
// i915_gem_object_get_pages
d1252 1
d1255 2
a1256 1
	struct inode *inode;
d1258 26
d1287 2
d1290 32
d1323 3
a1325 3
	BUG_ON(obj->pages != NULL);
	obj->pages = drm_malloc_ab(page_count, sizeof(struct page *));
	if (obj->pages == NULL)
d1328 9
a1336 10
	inode = obj->base.filp->f_path.dentry->d_inode;
	mapping = inode->i_mapping;
	gfpmask |= mapping_gfp_mask(mapping);

	for (i = 0; i < page_count; i++) {
		page = shmem_read_mapping_page_gfp(mapping, i, gfpmask);
		if (IS_ERR(page))
			goto err_pages;

		obj->pages[i] = page;
d1338 1
d1348 4
a1351 5
	while (i--)
		page_cache_release(obj->pages[i]);

	drm_free_large(obj->pages);
	obj->pages = NULL;
d1353 4
d1360 9
a1368 2
void
i915_gem_object_put_pages_gtt(struct drm_i915_gem_object *obj)
d1370 1
d1372 1
a1372 2
	int page_count = obj->base.size / PAGE_SIZE;
	int i;
d1374 1
d1376 2
a1377 4
	BUG_ON(obj->madv == __I915_MADV_PURGED);

	if (i915_gem_object_needs_bit17_swizzle(obj))
		i915_gem_object_save_bit_17_swizzle(obj);
d1379 1
a1379 2
	if (obj->madv == I915_MADV_DONTNEED)
		obj->dirty = 0;
d1382 3
a1384 9
	for (i = 0; i < page_count; i++) {
		if (obj->dirty)
			set_page_dirty(obj->pages[i]);

		if (obj->madv == I915_MADV_WILLNEED)
			mark_page_accessed(obj->pages[i]);

		page_cache_release(obj->pages[i]);
	}
d1386 2
a1387 1
	obj->dirty = 0;
d1389 2
a1390 4
#if 0
	drm_free_large(obj->pages);
	obj->pages = NULL;
#endif
d1439 1
a1439 4
	if (obj->pin_count != 0)
		list_del_init(&obj->mm_list);
	else
		list_move_tail(&obj->mm_list, &dev_priv->mm.inactive_list);
d1565 1
d1613 1
a1613 1
		free(request, M_DRM);
d1685 2
d1699 1
a1699 1
//		trace_i915_gem_request_retire(ring, request->seqno);
d1727 8
a1875 1
#if 0
a1878 1
#endif
a1882 2
 *
 * XXX track dirty and pass down to uvm (note, DONTNEED buffers are clean).
a1887 1
	struct drm_device *dev = obj->base.dev;
d1899 3
a1901 1
		return EBUSY;
d1904 1
a1904 1
	if (ret == ERESTART || ret == EINTR)
d1915 1
a1915 1
	if (ret == ERESTART || ret == EINTR)
d1918 1
a1918 1
	i915_gem_object_put_pages_gtt(obj);
a1923 6
	uvm_objunwire(obj->base.uao, 0, obj->base.size);
	/* XXX persistent dmamap worth the memory? */
	bus_dmamap_destroy(dev_priv->agpdmat, obj->dmamap);
	obj->dmamap = NULL;
	free(obj->dma_segs, M_DRM);
	obj->dma_segs = NULL;
d1925 2
a1926 2
	list_del_init(&obj->gtt_list);
	list_del_init(&obj->mm_list);
d1930 3
a1933 2
	atomic_dec(&dev->gtt_count);
	atomic_sub(obj->base.size, &dev->gtt_memory);
d1935 2
a1936 2
	if (i915_gem_object_is_purgeable(obj))
		i915_gem_object_truncate(obj);
d1938 1
a1938 1
	return ret;
d2296 5
a2300 1
// i915_gem_verify_gtt
d2322 1
a2322 1
		return EINVAL;
d2341 1
a2341 1
		return EINVAL;
d2355 9
a2363 2
	if ((ret = bus_dmamap_create(dev_priv->agpdmat, size, 1,
	    size, 0, BUS_DMA_WAITOK, &obj->dmamap)) != 0) {
d2365 4
a2368 1
		return (ret);
d2387 4
a2390 18
	/*
	 * the helper function wires the uao then binds it to the aperture for
	 * us, so all we have to do is set up the dmamap then load it.
	 */
	ret = drm_gem_load_uao(dev_priv->agpdmat, obj->dmamap, obj->base.uao,
	    obj->base.size, BUS_DMA_WAITOK | obj->dma_flags | flags,
	    &obj->dma_segs);
	/* XXX NOWAIT? */
	if (ret != 0) {
		/* If the gtt is empty and we're still having trouble
		 * fitting our object in, we're out of memory.
		 */
		if (list_empty(&dev_priv->mm.inactive_list) &&
		    list_empty(&dev_priv->mm.active_list)) {
			DRM_ERROR("GTT full, but LRU list empty\n");
			goto error;
		}

d2392 1
a2392 1
		if (ret != 0)
d2397 17
a2413 1
	i915_gem_object_get_pages_gtt(obj);
d2416 1
a2416 7

	/* Assert that the object is not currently in any GPU domain. As it
	 * wasn't in the GTT, there shouldn't be any way it could have been in
	 * a GPU cache
	 */
	BUG_ON(obj->base.read_domains & I915_GEM_GPU_DOMAINS);
	BUG_ON(obj->base.write_domain & I915_GEM_GPU_DOMAINS);
d2429 4
a2432 4
	atomic_inc(&dev->gtt_count);
	atomic_add(obj->base.size, &dev->gtt_memory);

	return (0);
d2435 3
d2441 1
a2441 1
	return (ret);
d2453 4
a2497 1
#if 0
a2500 1
#endif
a2516 1
#if 0
a2519 1
#endif
d2532 1
a2532 1
//	uint32_t old_write_domain, old_read_domains;
d2539 1
a2539 1
		return (EINVAL);
d2550 2
a2551 2
//	old_write_domain = obj->base.write_domain;
//	old_read_domains = obj->base.read_domains;
d2564 3
a2566 3
//	trace_i915_gem_object_change_domain(obj,
//					    old_read_domains,
//					    old_write_domain);
d2591 1
a2591 1
	if (obj->dmamap != NULL) {
a2634 1
#if 0
a2637 1
#endif
d2641 1
d2659 1
a2659 1
		ret = ENOENT;
d2688 1
a2688 1
		return EINVAL;
d2697 1
a2697 1
		ret = ENOENT;
d2719 1
a2719 1
//	u32 old_read_domains, old_write_domain;
d2751 2
a2752 2
//	old_write_domain = obj->write_domain;
//	old_read_domains = obj->read_domains;
d2760 3
a2762 3
//	trace_i915_gem_object_change_domain(obj,
//					    old_read_domains,
//					    old_write_domain);
d2793 1
a2793 1
//	uint32_t old_write_domain, old_read_domains;
d2807 2
a2808 2
//	old_write_domain = obj->base.write_domain;
//	old_read_domains = obj->base.read_domains;
d2830 3
a2832 3
//	trace_i915_gem_object_change_domain(obj,
//					    old_read_domains,
//					    old_write_domain);
d2859 1
a2859 1
		return EIO;
a2886 1
	struct drm_device	*dev = obj->base.dev;
d2890 3
a2892 1
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);
d2918 2
a2919 7
	if (obj->pin_count++ == 0) {
		atomic_inc(&dev->pin_count);
		atomic_add(obj->base.size, &dev->pin_memory);
		if (!obj->active)
			list_del_init(&obj->mm_list);
	}
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);
a2926 6
	struct drm_device	*dev = obj->base.dev;
	drm_i915_private_t *dev_priv = dev->dev_private;

	DRM_ASSERT_HELD(&obj->base);
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);

d2930 2
a2931 8
	if (--obj->pin_count == 0) {
		if (!obj->active)
			list_move_tail(&obj->mm_list,
				       &dev_priv->mm.inactive_list);
		atomic_dec(&dev->pin_count);
		atomic_sub(obj->base.size, &dev->pin_memory);
	}
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);
a2937 1
	struct inteldrm_softc	*dev_priv = dev->dev_private;
d2948 1
a2948 1
		ret = ENOENT;
d2956 8
a2963 1
		ret = EINVAL;
a2970 1
		inteldrm_set_max_obj_size(dev_priv);
d2974 1
d2979 1
a2979 1
	i915_gem_object_set_to_gtt_domain(obj, true);
a2991 1
	struct inteldrm_softc	*dev_priv = dev->dev_private;
d3002 1
a3002 1
		ret = ENOENT;
d3008 4
a3011 2
	if (obj->user_pin_count == 0) {
		ret = EINVAL;
a3013 1

d3016 1
a3017 1
		inteldrm_set_max_obj_size(dev_priv);
d3041 1
a3041 1
		ret = ENOENT;
d3045 5
d3051 1
d3053 4
d3079 1
a3079 1
	    return EINVAL;
d3088 1
a3088 1
		ret = ENOENT;
a3093 1
	/* invalid to madvise on a pinned BO */
d3095 1
a3095 1
		ret = EINVAL;
d3103 1
a3103 1
	if (i915_gem_object_is_purgeable(obj) && obj->dmamap == NULL)
a3127 1
#ifdef notyet
a3128 1
#endif
d3182 2
a3183 1
	struct drm_device *dev = gem_obj->dev;
a3188 3
	
	while (obj->pin_count > 0)
		i915_gem_object_unpin(obj);
d3190 1
d3193 6
a3199 1
#ifdef notyet
a3200 1
#endif
d3373 1
a3373 1
		return (ENOMEM);
a3376 1
	inteldrm_set_max_obj_size(dev_priv);
d3384 4
a3387 3
	if (ret != 0) {
		DRM_UNLOCK();
		return (ret);
a3389 2
	DRM_UNLOCK();

d3662 1
a3662 1
	ret = copyin((char *)(uintptr_t)args->data_ptr,
a3691 1
// i915_gem_release
@


1.29
log
@Fix typo/thinko; checking whether an address is bigger than 0 makes no sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.28 2013/07/10 02:21:09 jsg Exp $	*/
a1803 1
#ifdef notyet
a1806 1
#endif
d3174 1
a3175 1
	i915_gem_context_init(dev);
@


1.28
log
@match linux and call i915_gem_object_wait_rendering__nonblocking
in the set domain ioctl.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.27 2013/07/05 07:20:27 jsg Exp $	*/
d471 1
a471 1
		recovery_complete = (&dev_priv->error_completion) > 0;
@


1.27
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.26 2013/07/04 09:49:00 jsg Exp $	*/
d601 45
a645 1
// i915_gem_object_wait_rendering__nonblocking
a683 1
#if notyet
a690 1
#endif
a704 1
#ifdef notyet
a705 1
#endif
@


1.26
log
@Workaround incoherence between fences and LLC across multiple CPUs
from linux 3.8.13

this does not currently do the ipi to run wbinvd() on all processors
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.25 2013/06/12 14:28:40 kettenis Exp $	*/
d73 1
a73 1
void i915_gem_reset_ring_lists(drm_i915_private_t *,
d1417 1
a1417 1
i915_gem_reset_ring_lists(drm_i915_private_t *dev_priv,
d1922 1
a1922 1
fence_number(drm_i915_private_t *dev_priv,
d3155 1
a3155 1
	struct inteldrm_softc		*dev_priv = dev->dev_private;
@


1.25
log
@Oops.  I looked at slightly newer Linux code when doing the previous change.
This fixes things up to better match Linux 3.8.x, which we're currently
tracking.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.24 2013/06/11 19:39:09 kettenis Exp $	*/
d1928 8
d1941 3
a1943 2
	struct drm_i915_private *dev_priv = obj->base.dev->dev_private;
	int reg = fence_number(dev_priv, fence);
d1945 17
a1961 1
	i915_gem_write_fence(obj->base.dev, reg, enable ? obj : NULL);
d1964 1
a1964 1
		obj->fence_reg = reg;
@


1.24
log
@Turn the allocation of GEM objects upside down and make the driver
responsible for allocating and freeing them.  This is what Linux has been
doing for a while now, and will be needed for radeondrm(4) in the near
future.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.23 2013/06/07 20:46:15 kettenis Exp $	*/
a86 2
void *i915_gem_object_alloc(struct drm_device *);
void i915_gem_object_free(struct drm_i915_gem_object *);
a221 13
void *
i915_gem_object_alloc(struct drm_device *dev)
{
	return pool_get(&dev->objpl, PR_WAITOK | PR_ZERO);
}

void
i915_gem_object_free(struct drm_i915_gem_object *obj)
{
	struct drm_device *dev = obj->base.dev;
	pool_put(&dev->objpl, obj);
}

d2918 1
a2918 1
	obj = i915_gem_object_alloc(dev);
d2923 1
a2923 1
		i915_gem_object_free(obj);
d2982 1
a2982 1
	i915_gem_object_free(obj);
@


1.23
log
@Add proper mmap(2) support for drm(4)/inteldrm(4).  This changes the
DRM_I915_GEM_MMAP and DRM_I915_GEM_MMAP_GTT ioctls to be compatible with
Linux.  This also is the first step that moves us away from accessing all
graphics memory through the GTT, which should make things faster.

ok tedu@@ (for the uvm bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.22 2013/05/27 19:29:25 kettenis Exp $	*/
d87 3
d224 13
d2910 18
d2931 1
a2931 2
	struct drm_obj			*obj;
	struct drm_i915_gem_object	*obj_priv;
d2933 1
a2933 1
	obj = drm_gem_object_alloc(dev, size);
d2937 4
a2940 1
	obj_priv = to_intel_bo(obj);
d2942 1
a2942 8
	return (obj_priv);
}

int
i915_gem_init_object(struct drm_obj *obj)
{
	struct drm_i915_gem_object *obj_priv = to_intel_bo(obj);
	struct drm_device *dev = obj->dev;
d2944 2
a2945 8
	/*
	 * We've just allocated pages from the kernel,
	 * so they've just been written by the CPU with
	 * zeros. They'll need to be flushed before we
	 * use them with the GPU.
	 */
	obj->write_domain = I915_GEM_DOMAIN_CPU;
	obj->read_domains = I915_GEM_DOMAIN_CPU;
d2960 1
a2960 1
		obj_priv->cache_level = I915_CACHE_LLC;
d2962 1
a2962 1
		obj_priv->cache_level = I915_CACHE_NONE;
d2964 2
a2965 6
	/* normal objects don't need special treatment */
	obj_priv->dma_flags = 0;
	obj_priv->fence_reg = I915_FENCE_REG_NONE;
	obj_priv->madv = I915_MADV_WILLNEED;
	/* Avoid an unnecessary call to unbind on the first bind. */
	obj_priv->map_and_fenceable = true;
d2967 4
a2970 3
	INIT_LIST_HEAD(&obj_priv->mm_list);
	INIT_LIST_HEAD(&obj_priv->gtt_list);
	INIT_LIST_HEAD(&obj_priv->ring_list);
a2974 4
/*
 * NOTE all object unreferences in this driver need to hold the DRM_LOCK(),
 * because if they free they poke around in driver structures.
 */
d2990 6
d2997 1
a2997 2
	obj->bit_17 = NULL;
	/* XXX dmatag went away? */
@


1.22
log
@Make i915_gem_set_domain_ioctl closer to the Linux code.  Prepares us for a
future where we don't map everything through the GTT anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.21 2013/05/18 21:43:42 kettenis Exp $	*/
d85 2
a628 7
	/*
	 * Only allow GTT since that is all that we let userland near
	 * on OpenBSD.
	 */
	if ((write_domain | read_domains)  & ~I915_GEM_DOMAIN_GTT)
		return EINVAL;

d745 1
a745 1
	ret = uvm_map(&curproc->p_vmspace->vm_map, &addr, nsize, &obj->uobj,
d748 2
d776 3
d983 49
a1031 2
// i915_gem_object_create_mmap_offset
// i915_gem_object_free_mmap_offset
d1034 4
a1037 2
i915_gem_mmap_gtt(struct drm_file *file, struct drm_device *dev,
    uint32_t handle, uint64_t *mmap_offset)
d1039 3
a1041 5
	struct drm_i915_gem_object	*obj;
	struct drm_local_map		*map;
	voff_t				 offset; 
	vsize_t				 end, nsize;
	int				 ret;
d1043 3
a1045 1
	offset = (voff_t)*mmap_offset;
d1048 4
a1051 2
	if (obj == NULL)
		return ENOENT;
d1053 3
a1055 8
	/* Since we are doing purely uvm-related operations here we do
	 * not need to hold the object, a reference alone is sufficient
	 */

	/* Check size. */
	if (offset > obj->base.size) {
		ret = EINVAL;
		goto done;
d1060 2
a1061 2
		ret = EINVAL;
		goto done;
d1064 3
a1066 6
	ret = i915_gem_object_bind_to_gtt(obj, 0, true, false);
	if (ret) {
		printf("%s: failed to bind\n", __func__);
		goto done;
	}
	i915_gem_object_move_to_inactive(obj);
d1068 1
a1068 3
	end = round_page(offset + obj->base.size);
	offset = trunc_page(offset);
	nsize = end - offset;
d1070 5
a1074 10
	ret = drm_addmap(dev, offset + obj->gtt_offset, nsize, _DRM_AGP,
	    _DRM_WRITE_COMBINING, &map);
	
done:
	if (ret == 0)
		*mmap_offset = map->ext;
	else
		drm_unref(&obj->base.uobj);

	return (ret);
d1106 2
@


1.21
log
@Add parameters describing the usable part of the GTT and enable the checks
that use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.20 2013/05/11 19:03:41 kettenis Exp $	*/
d614 13
d628 2
a629 5
	 * Only handle setting domains to types we allow the cpu to see.
	 * while linux allows the CPU domain here, we only allow GTT since that
	 * is all that we let userland near.
	 * Also sanity check that having something in the write domain implies
	 * it's in the read domain, and only that read domain.
d631 2
a632 3
	if ((write_domain | read_domains)  & ~I915_GEM_DOMAIN_GTT ||
	    (write_domain != 0 && read_domains != write_domain))
		return (EINVAL);
d644 9
a652 3
	drm_hold_object(&obj->base);
	ret = i915_gem_object_set_to_gtt_domain(obj, write_domain != 0);
	drm_unhold_and_unref(&obj->base);
d654 2
a655 7
	/*
	 * Silently promote `you're not bound, there was nothing to do'
	 * to success, since the client was just asking us to make sure
	 * everything was done.
	 */
	if (ret == EINVAL)
		ret = 0;
d657 14
@


1.20
log
@Another small tweak to get things close to Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.19 2013/05/11 15:57:24 kettenis Exp $	*/
a2069 1
#ifdef notyet
a2077 1
#endif
a2141 1
#ifdef notyet
a2143 3
#else
	mappable = true;
#endif
d3089 5
@


1.19
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.18 2013/05/09 16:06:40 kettenis Exp $	*/
d1283 2
a1284 3
	request = drm_calloc(1, sizeof(*request));
	if (request == NULL) {
		printf("%s: failed to allocate request\n", __func__);
d1286 1
a1286 1
	}
d1307 1
@


1.18
log
@A few more changes to reduce the diffs to the Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.17 2013/05/09 15:00:41 kettenis Exp $	*/
d107 1
a107 1
	struct drm_i915_private *dev_priv= dev->dev_private;
@


1.17
log
@Add a #define such that we can say "struct drm_i915_private"  to reduce the
diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.16 2013/05/08 23:01:36 kettenis Exp $	*/
d460 1
a460 1
i915_gem_check_wedge(struct inteldrm_softc *dev_priv,
d550 1
a550 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1017 15
d1034 1
a1034 1
    struct drm_file *file)
d1036 1
a1036 5
	struct inteldrm_softc *dev_priv;
	struct drm_i915_gem_mmap_gtt *args;

	dev_priv = dev->dev_private;
	args = data;
d1038 1
a1038 1
	return (i915_gem_mmap_gtt(file, dev, args->handle, &args->offset));
d1149 1
a1149 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1184 2
a1185 2
	struct drm_device	*dev = obj->base.dev;
	struct inteldrm_softc	*dev_priv = dev->dev_private;
d1214 1
a1214 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1246 1
a1246 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1383 1
a1383 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1405 1
a1405 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1494 1
a1494 1
	struct inteldrm_softc *dev_priv = arg1;
d1520 1
d1870 1
a1870 1
	drm_i915_private_t *dev_priv = obj->base.dev->dev_private;
d1910 1
a1910 1
	drm_i915_private_t *dev_priv = obj->base.dev->dev_private;
d1931 1
a1931 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1978 1
a1978 1
	drm_i915_private_t *dev_priv = dev->dev_private;
@


1.16
log
@The "locking" in i915_gem_object_move_to_inactive() makes no sense.  Get rid
of it.  It's implemented using "simple" locks anyway, which are no-ops.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.15 2013/05/05 13:55:36 kettenis Exp $	*/
d107 1
a107 1
	drm_i915_private_t *dev_priv= dev->dev_private;
d2560 1
a2560 1
	drm_i915_private_t *dev_priv = dev->dev_private;
@


1.15
log
@Add nonblocking argument to i915_gem_object_pin() and
i915_gem_object_bind_to_gtt().
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.14 2013/05/05 13:19:00 kettenis Exp $	*/
a1169 1
/* called locked */
d1171 1
a1171 1
i915_gem_object_move_to_inactive_locked(struct drm_i915_gem_object *obj)
a1175 2
	DRM_OBJ_ASSERT_LOCKED(&obj->base);
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);
d1197 1
a1197 12
	inteldrm_verify_inactive(dev_priv, __FILE__, __LINE__);
}

/* If you call this on an object that you have held, you must have your own
 * reference, not just the reference from the active list.
 */
void
i915_gem_object_move_to_inactive(struct drm_i915_gem_object *obj)
{
	drm_lock_obj(&obj->base);
	/* unlocks object lock */
	i915_gem_object_move_to_inactive_locked(obj);
@


1.14
log
@Remove a supefluous check.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.13 2013/05/05 13:02:46 kettenis Exp $	*/
d81 2
a82 1
				unsigned alignment, bool map_and_fenceable);
d351 2
a352 2
	ret = i915_gem_object_pin(obj, 0, 1);
	if (ret) {
d354 1
a354 1
	}
d421 2
a422 2
	ret = i915_gem_object_pin(obj, 0, 1);
	if (ret) {
d424 1
a424 1
	}
d782 1
a782 1
		ret = i915_gem_object_bind_to_gtt(obj, 0, true);
d994 1
a994 1
	ret = i915_gem_object_bind_to_gtt(obj, 0, true);
d2034 2
a2035 1
			    bool map_and_fenceable)
d2469 1
a2469 1
	ret = i915_gem_object_pin(obj, alignment, true);
d2608 2
a2609 1
		    bool map_and_fenceable)
d2635 2
a2636 1
						  map_and_fenceable);
d2702 1
a2702 1
		ret = i915_gem_object_pin(obj, args->alignment, 1);
@


1.13
log
@With KMS, the inteldrm_quiesce dance isn't needed anymore.  Zap the code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.12 2013/04/21 14:41:26 kettenis Exp $	*/
a2925 4

	/* If drm attach failed */
	if (dev == NULL)
		return (0);
@


1.12
log
@Move GEM initialization code into its own function like Linux has.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.11 2013/04/17 20:04:04 kettenis Exp $	*/
d752 1
a752 23
	/* Are we about to suspend?, if so wait until we're done */
	if (dev_priv->sc_flags & INTELDRM_QUIET) {
		/* we're about to sleep, unlock the map etc */
		uvmfault_unlockall(ufi, NULL, &obj->base.uobj, NULL);
		while (dev_priv->sc_flags & INTELDRM_QUIET)
			tsleep(&dev_priv->flags, 0, "intelflt", 0);
		dev_priv->entries++;
		/*
		 * relock so we're in the same state we would be in if we
		 * were not quiesced before
		 */
		locked = uvmfault_relock(ufi);
		if (locked) {
			drm_lock_obj(&obj->base);
		} else {
			dev_priv->entries--;
			if (dev_priv->sc_flags & INTELDRM_QUIET)
				wakeup(&dev_priv->entries);
			return (VM_PAGER_REFAULT);
		}
	} else {
		dev_priv->entries++;
	}
a764 2
		if (dev_priv->sc_flags & INTELDRM_QUIET)
			wakeup(&dev_priv->entries);
a825 2
			if (dev_priv->sc_flags & INTELDRM_QUIET)
				wakeup(&dev_priv->entries);
a834 2
	if (dev_priv->sc_flags & INTELDRM_QUIET)
		wakeup(&dev_priv->entries);
@


1.11
log
@Another round of reducing diffs with Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.10 2013/04/08 21:32:19 kettenis Exp $	*/
d3210 55
a3264 1
// i915_gem_load
@


1.10
log
@A few changes that reduce the diffs to the Linux code.  Mostly style issues,
but in one case change the errno value that gets returened to match Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.9 2013/04/03 19:57:17 kettenis Exp $	*/
d161 1
a161 1
		    struct drm_file *file_priv)
d219 4
a222 2
i915_gem_create(struct drm_file *file, struct drm_device *dev, uint64_t size,
    uint32_t *handle_p)
a224 1
	uint32_t handle;
d226 1
d232 1
a252 1

d275 1
a275 1
    struct drm_file *file_priv)
d298 1
a298 1
	ret = drm_handle_create(file_priv, &obj->base, &handle);
d391 1
a391 1
    struct drm_file *file)
d600 2
a601 2
 * Called when user space prepares to use an object with the CPU, either through
 * the mmap ioctl's mapping or a GTT mapping.
d607 1
a607 1
	struct drm_i915_gem_set_domain*args = data;
d1164 3
a1166 5
	struct drm_device		*dev = obj->base.dev;
	struct inteldrm_softc		*dev_priv = dev->dev_private;
	u_int32_t			 seqno;

	seqno = intel_ring_get_seqno(ring);
d1189 1
a1189 1
			
d1264 1
a1264 1
	i915_gem_retire_requests(dev_priv);
a1290 7
/**
 * Creates a new sequence number, emitting a write of it to the status page
 * plus an interrupt, which will trigger and interrupt if they are currently
 * enabled.
 *
 * Returned sequence numbers are nonzero on success.
 */
d1296 5
a1300 4
	drm_i915_private_t	*dev_priv = ring->dev->dev_private;
	struct drm_i915_gem_request	*request;
	u32				 request_ring_position;
	int				 was_empty, ret;
d1437 1
d1440 2
a1441 2
	for (i = 0; i < I915_NUM_RINGS; i++)
		i915_gem_reset_ring_lists(dev_priv, &dev_priv->rings[i]);
d1511 1
a1511 1
i915_gem_retire_requests(struct inteldrm_softc *dev_priv)
d1513 1
d1538 1
a1538 1
	i915_gem_retire_requests(dev_priv);
d1540 1
a1540 1
        /* Send a periodic flush down the ring so we don't hold onto GEM
a1654 1

d1663 3
a1665 3
	struct drm_device	*dev = obj->base.dev;
	struct inteldrm_softc	*dev_priv = dev->dev_private;
	int			 ret = 0;
d2060 2
a2061 1
    unsigned alignment, bool map_and_fenceable)
d2328 1
a2328 1
//	struct drm_device *dev = obj->base.dev;
d2351 1
a2351 1
		if (INTEL_INFO(obj->base.dev)->gen < 6) {
d2459 5
d2538 1
a2538 1
 * flushes to return.
d2637 1
a2637 1
	int			 ret;
d2703 1
a2703 1
	struct drm_i915_gem_pin	*args = data;
d2725 1
a2725 1
	if (++obj->user_pin_count == 1) {
d2727 1
a2727 1
		if (ret != 0)
d2732 2
a2738 1

d2751 1
a2751 1
	struct drm_i915_gem_pin	*args = data;
d2787 1
a2787 1
    struct drm_file *file)
d2851 1
a2851 1
	/* if the object is no longer bound, discard its backing storage */
d2950 1
a2950 1
i915_gem_idle(struct inteldrm_softc *dev_priv)
d2952 2
a2953 2
	struct drm_device	*dev = (struct drm_device *)dev_priv->drmdev;
	int			 ret;
d2971 1
a2971 1
	i915_gem_retire_requests(dev_priv);
d2975 1
a2975 1
		i915_gem_evict_everything(dev_priv);
a2983 1
	/* if we hung then the timer alredy fired. */
d2988 1
d2991 1
a2991 1
	/* this should be idle now */
d3087 1
a3087 1
	intel_cleanup_ring_buffer(&dev_priv->rings[VCS]);
d3089 1
a3089 1
	intel_cleanup_ring_buffer(&dev_priv->rings[RCS]);
d3152 2
a3153 3
	struct inteldrm_softc *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring;
	int ret, i;
d3156 1
a3156 1
		return (0);
d3158 1
a3158 5
	/* XXX until we have support for the rings on sandybridge */
	if (IS_GEN6(dev) || IS_GEN7(dev))
		return (0);

	if (dev_priv->mm.wedged) {
d3160 1
a3160 1
		dev_priv->mm.wedged = 0;
a3162 1

d3169 1
a3169 1
		return (ret);
d3172 1
a3172 4
	/* gtt mapping means that the inactive list may not be empty */
	KASSERT(list_empty(&dev_priv->mm.active_list));
	for_each_ring(ring, dev_priv, i)
		KASSERT(list_empty(&ring->request_list));
d3175 11
a3185 1
	drm_irq_install(dev);
d3187 1
a3187 1
	return (0);
a3193 3
	struct inteldrm_softc	*dev_priv = dev->dev_private;
	int			 ret;

d3197 2
a3198 4
	/* don't unistall if we fail, repeat calls on failure will screw us */
	if ((ret = i915_gem_idle(dev_priv)) == 0)
		drm_irq_uninstall(dev);
	return (ret);
d3212 4
d3286 3
a3288 1
    struct drm_i915_gem_object *obj, int id, int align)
@


1.9
log
@Return ENOENT instead of EBADF if looking up a gem object fails.
Return EINVAL instead of EBADF if the same object is specified twice in
an execbuffer2 call.
This is what Linux does.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.8 2013/03/30 11:08:07 kettenis Exp $	*/
d110 1
a110 1
		return (0);
d133 1
a133 1
	return (0);
d167 1
a167 1
		return (ENODEV);
d204 1
a204 1
    struct drm_file *file_priv)
d206 1
a206 1
	struct drm_i915_gem_get_aperture	*args = data;
d215 1
a215 1
	return (0);
d228 1
a228 1
		return (-EINVAL);
d232 1
a232 1
		return (-ENOMEM);
d242 1
a242 1
	return (0);
d246 3
a248 2
i915_gem_dumb_create(struct drm_file *file, struct drm_device *dev,
    struct drm_mode_create_dumb *args)
d254 2
a255 1
	return (i915_gem_create(file, dev, args->size, &args->handle));
d460 1
a460 1
	if (atomic_read(&dev_priv->mm.wedged) != 0) {
d556 1
a556 1
		return (ret);
d1680 2
a1681 4
	if (obj->pin_count != 0) {
		DRM_ERROR("Attempting to unbind pinned buffer\n");
		return (EINVAL);
	}
d2474 1
a2474 1
			return (ret);
d2672 1
a2672 1
	return (0);
d2814 1
a2814 1
    struct drm_file *file_priv)
d2823 1
a2823 1
		break;
d2825 1
a2825 1
		return (EINVAL);
d2967 1
a2967 1
		return (ret);
d2979 1
d3307 1
a3307 1
			return (ret);
@


1.8
log
@Remove debug printf that causes problems with framebuffer acceleration when
turned on.  Linux doesn't have it anyway.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.7 2013/03/28 22:41:48 kettenis Exp $	*/
d333 1
a333 1
		return (EBADF);
d400 1
a400 1
		return (EBADF);
d626 1
a626 1
		ret = EBADF;
d999 1
a999 1
		return (EBADF);
d2712 1
a2712 1
		ret = EBADF;
d2759 1
a2759 1
		ret = EBADF;
d2797 1
a2797 1
		ret = EBADF;
d2834 1
a2834 1
		ret = EBADF;
@


1.7
log
@Add missing locking in i915_gem_retire_work_handler() and call
intel_mark_idle() when idle.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.6 2013/03/28 19:38:53 kettenis Exp $	*/
a1341 2

	DRM_DEBUG("%d\n", request->seqno);
@


1.6
log
@Call intel_mark_busy() in the right place, and call intel_mark_fb_busy()
where we used to call intel_mark_busy().
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.5 2013/03/28 05:13:07 jsg Exp $	*/
d1528 2
a1529 1
	struct inteldrm_softc	*dev_priv = arg1;
d1531 10
a1540 2
	bool			 idle;
	int			 i;
d1543 4
d1556 4
@


1.5
log
@add the ioctls to get/set the caching level of a buffer object
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.4 2013/03/22 22:51:00 kettenis Exp $	*/
d1357 6
a1362 2
	if (dev_priv->mm.suspended == 0) {
		if (was_empty)
d1364 2
a1365 3
		/* XXX was_empty? */
		timeout_add_msec(&dev_priv->hangcheck_timer,
		    DRM_I915_HANGCHECK_PERIOD);
@


1.4
log
@Move i915_gem_gtt_map_ioctl() from i915_drv.c to i915_gem.c and rename it
to i915_gem_mmap_ioctl().
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.3 2013/03/22 06:19:56 jsg Exp $	*/
d2381 63
a2443 2
// i915_gem_get_caching_ioctl
// i915_gem_set_caching_ioctl
@


1.3
log
@implement DRM_IOCTL_I915_GEM_SW_FINISH
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.2 2013/03/21 21:49:07 kettenis Exp $	*/
d678 55
a732 1
// i915_gem_mmap_ioctl
@


1.2
log
@Zap a few useless comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: i915_gem.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d647 31
a677 1
// i915_gem_sw_finish_ioctl
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a312 7
// __copy_to_user_swizzled
// __copy_from_user_swizzled
// shmem_pread_fast
// shmem_clflush_swizzled_range
// shmem_pread_slow
// i915_gem_shmem_pread

a378 6

// fast_user_write
// i915_gem_gtt_pwrite_fast
// shmem_pwrite_fast
// shmem_pwrite_slow
// i915_gem_shmem_pwrite
@

