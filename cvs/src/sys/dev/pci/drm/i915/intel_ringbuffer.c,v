head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.31
date	2015.09.25.16.15.19;	author jsg;	state Exp;
branches;
next	1.30;
commitid	qBczsgFZrSbAS824;

1.30
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	lQlppvmETCN49oZe;

1.29
date	2015.06.24.17.59.42;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	3wz7SV1D1yJbfWE9;

1.28
date	2015.04.12.17.10.07;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	7RIU3AxWXbuzxDet;

1.27
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.26;
commitid	syZU9J25izIJ2cm1;

1.26
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.25;
commitid	uVTyY1h8Sggc8pFj;

1.25
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	adfbJ0ccUTdhFGhI;

1.24
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.23;
commitid	aHLMSW1RfE1rmMw9;

1.23
date	2014.12.17.06.58.10;	author guenther;	state Exp;
branches;
next	1.22;
commitid	DImukoCWyTxwdbuh;

1.22
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.21;
commitid	ZxaujiOM0aYQRjFY;

1.21
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	yv0ECmCdICvq576h;

1.20
date	2014.03.30.00.58.24;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.01.09.32.05;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.24.01.42.50;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2013.12.01.11.47.13;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.30.20.13.36;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.30.20.03.32;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.30.13.58.51;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.29.21.44.15;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.20.22.10.19;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.19.15.08.04;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.17.18.47.13;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.13.10.23.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.05.05.13.55.36;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.17.20.04.05;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@3.14 backports of some Broadwell fixes from
http://lists.freedesktop.org/archives/intel-gfx/2014-March/042121.html

Ben Widawsky
drm/i915/bdw: Restore PPAT on thaw
a2319c08bfd849ea32b4f890ce92df86074c5731

Ville Syrjala
drm/i915: We implement WaDisableAsyncFlipPerfMode:bdw
8285222c487b61c48b9b955b82598544c3c06050

Ben Widawsky
drm/i915/bdw: Use scratch page table for GEN8 PPGTT
8407bb9129da95fc4099b84cdbbc23e6d4f66aee

Jani Nikula
drm/i915: don't flood the logs about bdw semaphores
c923facd535b97972b5bb7d3df4fcafd61a63a5e

Ville Syrjala
drm/i915: Implement WaDisableSDEUnitClockGating:bdw
4f1ca9e94057de098d65bc7477e8f89dd51609aa

Ville Syrjala
drm/i915: Don't clobber CHICKEN_PIPESL_1 on BDW
c7c656226842679bcd9f39dc24441b4ff398a850

Kenneth Graunke
drm/i915: Add a partial instruction shootdown workaround on Broadwell.
c8966e1058e1e8ae2eec4211157847032829697a

Damien Lespiau
drm/i915/bdw: The TLB invalidation mechanism has been removed from INSTPM
dc616b89dbc4bb6a99884d214bd1ed1e0eef59a0

Kenneth Graunke
drm/i915: Add thread stall DOP clock gating workaround on Broadwell.
1411e6a57a1836ba8a3d4f17c8733b2fbaf0f005

Ville Syrjala
drm/i915: Disable semaphore wait event idle message on BDW
295e8bb73a4785b65db6655fbf6ad57c4177b551

Mika Kuoppala
drm/i915: Do forcewake reset on gen8
0a089e3355d77f758e46db54a0a81d4b58a28cc3

Mika Kuoppala
drm/i915: Fix forcewake counts for gen8
e9dbd2b20201b49b04476d2e5763faa822967913

ok kettenis@@
@
text
@/*	$OpenBSD: intel_ringbuffer.c,v 1.30 2015/09/23 23:12:12 kettenis Exp $	*/
/*
 * Copyright Â© 2008-2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Zou Nan hai <nanhai.zou@@intel.com>
 *    Xiang Hai hao<haihao.xiang@@intel.com>
 *
 */

#include <dev/pci/drm/drmP.h>
#include "i915_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_trace.h"
#include "intel_drv.h"

static inline int ring_space(struct intel_ring_buffer *ring)
{
	int space = (ring->head & HEAD_ADDR) - (ring->tail + I915_RING_FREE_SPACE);
	if (space < 0)
		space += ring->size;
	return space;
}

void __intel_ring_advance(struct intel_ring_buffer *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	ring->tail &= ring->size - 1;
	if (dev_priv->gpu_error.stop_rings & intel_ring_flag(ring))
		return;
	ring->write_tail(ring, ring->tail);
}

static int
gen2_render_ring_flush(struct intel_ring_buffer *ring,
		       u32	invalidate_domains,
		       u32	flush_domains)
{
	u32 cmd;
	int ret;

	cmd = MI_FLUSH;
	if (((invalidate_domains|flush_domains) & I915_GEM_DOMAIN_RENDER) == 0)
		cmd |= MI_NO_WRITE_FLUSH;

	if (invalidate_domains & I915_GEM_DOMAIN_SAMPLER)
		cmd |= MI_READ_FLUSH;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
gen4_render_ring_flush(struct intel_ring_buffer *ring,
		       u32	invalidate_domains,
		       u32	flush_domains)
{
	struct drm_device *dev = ring->dev;
	u32 cmd;
	int ret;

	/*
	 * read/write caches:
	 *
	 * I915_GEM_DOMAIN_RENDER is always invalidated, but is
	 * only flushed if MI_NO_WRITE_FLUSH is unset.  On 965, it is
	 * also flushed at 2d versus 3d pipeline switches.
	 *
	 * read-only caches:
	 *
	 * I915_GEM_DOMAIN_SAMPLER is flushed on pre-965 if
	 * MI_READ_FLUSH is set, and is always flushed on 965.
	 *
	 * I915_GEM_DOMAIN_COMMAND may not exist?
	 *
	 * I915_GEM_DOMAIN_INSTRUCTION, which exists on 965, is
	 * invalidated when MI_EXE_FLUSH is set.
	 *
	 * I915_GEM_DOMAIN_VERTEX, which exists on 965, is
	 * invalidated with every MI_FLUSH.
	 *
	 * TLBs:
	 *
	 * On 965, TLBs associated with I915_GEM_DOMAIN_COMMAND
	 * and I915_GEM_DOMAIN_CPU in are invalidated at PTE write and
	 * I915_GEM_DOMAIN_RENDER and I915_GEM_DOMAIN_SAMPLER
	 * are flushed at any MI_FLUSH.
	 */

	cmd = MI_FLUSH | MI_NO_WRITE_FLUSH;
	if ((invalidate_domains|flush_domains) & I915_GEM_DOMAIN_RENDER)
		cmd &= ~MI_NO_WRITE_FLUSH;
	if (invalidate_domains & I915_GEM_DOMAIN_INSTRUCTION)
		cmd |= MI_EXE_FLUSH;

	if (invalidate_domains & I915_GEM_DOMAIN_COMMAND &&
	    (IS_G4X(dev) || IS_GEN5(dev)))
		cmd |= MI_INVALIDATE_ISP;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

/**
 * Emits a PIPE_CONTROL with a non-zero post-sync operation, for
 * implementing two workarounds on gen6.  From section 1.4.7.1
 * "PIPE_CONTROL" of the Sandy Bridge PRM volume 2 part 1:
 *
 * [DevSNB-C+{W/A}] Before any depth stall flush (including those
 * produced by non-pipelined state commands), software needs to first
 * send a PIPE_CONTROL with no bits set except Post-Sync Operation !=
 * 0.
 *
 * [Dev-SNB{W/A}]: Before a PIPE_CONTROL with Write Cache Flush Enable
 * =1, a PIPE_CONTROL with any non-zero post-sync-op is required.
 *
 * And the workaround for these two requires this workaround first:
 *
 * [Dev-SNB{W/A}]: Pipe-control with CS-stall bit set must be sent
 * BEFORE the pipe-control with a post-sync op and no write-cache
 * flushes.
 *
 * And this last workaround is tricky because of the requirements on
 * that bit.  From section 1.4.7.2.3 "Stall" of the Sandy Bridge PRM
 * volume 2 part 1:
 *
 *     "1 of the following must also be set:
 *      - Render Target Cache Flush Enable ([12] of DW1)
 *      - Depth Cache Flush Enable ([0] of DW1)
 *      - Stall at Pixel Scoreboard ([1] of DW1)
 *      - Depth Stall ([13] of DW1)
 *      - Post-Sync Operation ([13] of DW1)
 *      - Notify Enable ([8] of DW1)"
 *
 * The cache flushes require the workaround flush that triggered this
 * one, so we can't use it.  Depth stall would trigger the same.
 * Post-sync nonzero is what triggered this second workaround, so we
 * can't use that one either.  Notify enable is IRQs, which aren't
 * really our business.  That leaves only stall at scoreboard.
 */
static int
intel_emit_post_sync_nonzero_flush(struct intel_ring_buffer *ring)
{
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
	int ret;


	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(5));
	intel_ring_emit(ring, PIPE_CONTROL_CS_STALL |
			PIPE_CONTROL_STALL_AT_SCOREBOARD);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT); /* address */
	intel_ring_emit(ring, 0); /* low dword */
	intel_ring_emit(ring, 0); /* high dword */
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(5));
	intel_ring_emit(ring, PIPE_CONTROL_QW_WRITE);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT); /* address */
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
gen6_render_ring_flush(struct intel_ring_buffer *ring,
                         u32 invalidate_domains, u32 flush_domains)
{
	u32 flags = 0;
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
	int ret;

	/* Force SNB workarounds for PIPE_CONTROL flushes */
	ret = intel_emit_post_sync_nonzero_flush(ring);
	if (ret)
		return ret;

	/* Just flush everything.  Experiments have shown that reducing the
	 * number of bits based on the write domains has little performance
	 * impact.
	 */
	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
		/*
		 * Ensure that any following seqno writes only happen
		 * when the render cache is indeed flushed.
		 */
		flags |= PIPE_CONTROL_CS_STALL;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		/*
		 * TLB invalidate requires a post-sync write.
		 */
		flags |= PIPE_CONTROL_QW_WRITE | PIPE_CONTROL_CS_STALL;
	}

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int
gen7_render_ring_cs_stall_wa(struct intel_ring_buffer *ring)
{
	int ret;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, PIPE_CONTROL_CS_STALL |
			      PIPE_CONTROL_STALL_AT_SCOREBOARD);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int gen7_ring_fbc_flush(struct intel_ring_buffer *ring, u32 value)
{
	int ret;

	if (!ring->fbc_dirty)
		return 0;

	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;
	/* WaFbcNukeOn3DBlt:ivb/hsw */
	intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
	intel_ring_emit(ring, MSG_FBC_REND_STATE);
	intel_ring_emit(ring, value);
	intel_ring_emit(ring, MI_STORE_REGISTER_MEM(1) | MI_SRM_LRM_GLOBAL_GTT);
	intel_ring_emit(ring, MSG_FBC_REND_STATE);
	intel_ring_emit(ring, ring->scratch.gtt_offset + 256);
	intel_ring_advance(ring);

	ring->fbc_dirty = false;
	return 0;
}

static int
gen7_render_ring_flush(struct intel_ring_buffer *ring,
		       u32 invalidate_domains, u32 flush_domains)
{
	u32 flags = 0;
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
	int ret;

	/*
	 * Ensure that any following seqno writes only happen when the render
	 * cache is indeed flushed.
	 *
	 * Workaround: 4th PIPE_CONTROL command (except the ones with only
	 * read-cache invalidate bits set) must have the CS_STALL bit set. We
	 * don't try to be clever and just set it unconditionally.
	 */
	flags |= PIPE_CONTROL_CS_STALL;

	/* Just flush everything.  Experiments have shown that reducing the
	 * number of bits based on the write domains has little performance
	 * impact.
	 */
	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_MEDIA_STATE_CLEAR;
		/*
		 * TLB invalidate requires a post-sync write.
		 */
		flags |= PIPE_CONTROL_QW_WRITE;
		flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;

		flags |= PIPE_CONTROL_STALL_AT_SCOREBOARD;

		/* Workaround: we must issue a pipe_control with CS-stall bit
		 * set before a pipe_control command that has the state cache
		 * invalidate bit set. */
		gen7_render_ring_cs_stall_wa(ring);
	}

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	if (!invalidate_domains && flush_domains)
		return gen7_ring_fbc_flush(ring, FBC_REND_NUKE);

	return 0;
}

static int
gen8_render_ring_flush(struct intel_ring_buffer *ring,
		       u32 invalidate_domains, u32 flush_domains)
{
	u32 flags = 0;
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
	int ret;

	flags |= PIPE_CONTROL_CS_STALL;

	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_QW_WRITE;
		flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;
	}

	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(6));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;

}

static void ring_write_tail(struct intel_ring_buffer *ring,
			    u32 value)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	I915_WRITE_TAIL(ring, value);
}

u32 intel_ring_get_active_head(struct intel_ring_buffer *ring)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	u32 acthd_reg = INTEL_INFO(ring->dev)->gen >= 4 ?
			RING_ACTHD(ring->mmio_base) : ACTHD;

	return I915_READ(acthd_reg);
}

static void ring_setup_phys_status_page(struct intel_ring_buffer *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	u32 addr;

	addr = dev_priv->status_page_dmah->map->dm_segs[0].ds_addr;
	if (INTEL_INFO(ring->dev)->gen >= 4)
		addr |= (dev_priv->status_page_dmah->map->dm_segs[0].ds_addr >> 28) & 0xf0;
	I915_WRITE(HWS_PGA, addr);
}

static int init_ring_common(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj = ring->obj;
	int ret = 0;
	u32 head;

	gen6_gt_force_wake_get(dev_priv, FORCEWAKE_ALL);

	if (I915_NEED_GFX_HWS(dev))
		intel_ring_setup_status_page(ring);
	else
		ring_setup_phys_status_page(ring);

	/* Stop the ring if it's running. */
	I915_WRITE_CTL(ring, 0);
	I915_WRITE_HEAD(ring, 0);
	ring->write_tail(ring, 0);

	head = I915_READ_HEAD(ring) & HEAD_ADDR;

	/* G45 ring initialization fails to reset head to zero */
	if (head != 0) {
		DRM_DEBUG_KMS("%s head not reset to zero "
			      "ctl %08x head %08x tail %08x start %08x\n",
			      ring->name,
			      I915_READ_CTL(ring),
			      I915_READ_HEAD(ring),
			      I915_READ_TAIL(ring),
			      I915_READ_START(ring));

		I915_WRITE_HEAD(ring, 0);

		if (I915_READ_HEAD(ring) & HEAD_ADDR) {
			DRM_ERROR("failed to set %s head to zero "
				  "ctl %08x head %08x tail %08x start %08x\n",
				  ring->name,
				  I915_READ_CTL(ring),
				  I915_READ_HEAD(ring),
				  I915_READ_TAIL(ring),
				  I915_READ_START(ring));
		}
	}

	/* Enforce ordering by reading HEAD register back */
	I915_READ_HEAD(ring);

	/* Initialize the ring. This must happen _after_ we've cleared the ring
	 * registers with the above sequence (the readback of the HEAD registers
	 * also enforces ordering), otherwise the hw might lose the new ring
	 * register values. */
	I915_WRITE_START(ring, i915_gem_obj_ggtt_offset(obj));
	I915_WRITE_CTL(ring,
			((ring->size - PAGE_SIZE) & RING_NR_PAGES)
			| RING_VALID);

	/* If the head is still not zero, the ring is dead */
	if (wait_for((I915_READ_CTL(ring) & RING_VALID) != 0 &&
		     I915_READ_START(ring) == i915_gem_obj_ggtt_offset(obj) &&
		     (I915_READ_HEAD(ring) & HEAD_ADDR) == 0, 50)) {
		DRM_ERROR("%s initialization failed "
				"ctl %08x head %08x tail %08x start %08x\n",
				ring->name,
				I915_READ_CTL(ring),
				I915_READ_HEAD(ring),
				I915_READ_TAIL(ring),
				I915_READ_START(ring));
		ret = -EIO;
		goto out;
	}

	if (!drm_core_check_feature(ring->dev, DRIVER_MODESET))
		i915_kernel_lost_context(ring->dev);
	else {
		ring->head = I915_READ_HEAD(ring);
		ring->tail = I915_READ_TAIL(ring) & TAIL_ADDR;
		ring->space = ring_space(ring);
		ring->last_retired_head = -1;
	}

	memset(&ring->hangcheck, 0, sizeof(ring->hangcheck));

out:
	gen6_gt_force_wake_put(dev_priv, FORCEWAKE_ALL);

	return ret;
}

static int
init_pipe_control(struct intel_ring_buffer *ring)
{
	int ret;

	if (ring->scratch.obj)
		return 0;

	ring->scratch.obj = i915_gem_alloc_object(ring->dev, 4096);
	if (ring->scratch.obj == NULL) {
		DRM_ERROR("Failed to allocate seqno page\n");
		ret = -ENOMEM;
		goto err;
	}

	i915_gem_object_set_cache_level(ring->scratch.obj, I915_CACHE_LLC);

	ret = i915_gem_obj_ggtt_pin(ring->scratch.obj, 4096, true, false);
	if (ret)
		goto err_unref;

	ring->scratch.gtt_offset = i915_gem_obj_ggtt_offset(ring->scratch.obj);
	ring->scratch.cpu_page = (volatile u_int32_t *)vm_map_min(kernel_map);
	ring->scratch.obj->base.uao->pgops->pgo_reference(ring->scratch.obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&ring->scratch.cpu_page,
	    PAGE_SIZE, ring->scratch.obj->base.uao, 0, 0,
	    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_READ | PROT_WRITE,
	    MAP_INHERIT_SHARE, MADV_RANDOM, 0));
	if (ret != 0) {
		ring->scratch.obj->base.uao->pgops->pgo_detach(ring->scratch.obj->base.uao);
		ret = -ENOMEM;
		goto err_unpin;
	}

	DRM_DEBUG_DRIVER("%s pipe control offset: 0x%08x\n",
			 ring->name, ring->scratch.gtt_offset);
	return 0;

err_unpin:
	i915_gem_object_unpin(ring->scratch.obj);
err_unref:
	drm_gem_object_unreference(&ring->scratch.obj->base);
err:
	return ret;
}

static int init_render_ring(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret = init_ring_common(ring);

	if (INTEL_INFO(dev)->gen > 3)
		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(VS_TIMER_DISPATCH));

	/* We need to disable the AsyncFlip performance optimisations in order
	 * to use MI_WAIT_FOR_EVENT within the CS. It should already be
	 * programmed to '1' on all products.
	 *
	 * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv,bdw
	 */
	if (INTEL_INFO(dev)->gen >= 6)
		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(ASYNC_FLIP_PERF_DISABLE));

	/* Required for the hardware to program scanline values for waiting */
	if (INTEL_INFO(dev)->gen == 6)
		I915_WRITE(GFX_MODE,
			   _MASKED_BIT_ENABLE(GFX_TLB_INVALIDATE_ALWAYS));

	if (IS_GEN7(dev))
		I915_WRITE(GFX_MODE_GEN7,
			   _MASKED_BIT_DISABLE(GFX_TLB_INVALIDATE_ALWAYS) |
			   _MASKED_BIT_ENABLE(GFX_REPLAY_MODE));

	if (INTEL_INFO(dev)->gen >= 5) {
		ret = init_pipe_control(ring);
		if (ret)
			return ret;
	}

	if (IS_GEN6(dev)) {
		/* From the Sandybridge PRM, volume 1 part 3, page 24:
		 * "If this bit is set, STCunit will have LRA as replacement
		 *  policy. [...] This bit must be reset.  LRA replacement
		 *  policy is not supported."
		 */
		I915_WRITE(CACHE_MODE_0,
			   _MASKED_BIT_DISABLE(CM0_STC_EVICT_DISABLE_LRA_SNB));

		/* This is not explicitly set for GEN6, so read the register.
		 * see intel_ring_mi_set_context() for why we care.
		 * TODO: consider explicitly setting the bit for GEN5
		 */
		ring->itlb_before_ctx_switch =
			!!(I915_READ(GFX_MODE) & GFX_TLB_INVALIDATE_ALWAYS);
	}

	if (INTEL_INFO(dev)->gen >= 6)
		I915_WRITE(INSTPM, _MASKED_BIT_ENABLE(INSTPM_FORCE_ORDERING));

	if (HAS_L3_DPF(dev))
		I915_WRITE_IMR(ring, ~GT_PARITY_ERROR(dev));

	return ret;
}

static void render_ring_cleanup(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;

	if (ring->scratch.obj == NULL)
		return;

	if (INTEL_INFO(dev)->gen >= 5) {
		uvm_unmap(kernel_map, (vaddr_t)ring->scratch.cpu_page,
		    (vaddr_t)ring->scratch.cpu_page + PAGE_SIZE);
		i915_gem_object_unpin(ring->scratch.obj);
	}

	drm_gem_object_unreference(&ring->scratch.obj->base);
	ring->scratch.obj = NULL;
}

static void
update_mboxes(struct intel_ring_buffer *ring,
	      u32 mmio_offset)
{
/* NB: In order to be able to do semaphore MBOX updates for varying number
 * of rings, it's easiest if we round up each individual update to a
 * multiple of 2 (since ring updates must always be a multiple of 2)
 * even though the actual update only requires 3 dwords.
 */
#define MBOX_UPDATE_DWORDS 4
	intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
	intel_ring_emit(ring, mmio_offset);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, MI_NOOP);
}

/**
 * gen6_add_request - Update the semaphore mailbox registers
 * 
 * @@ring - ring that is adding a request
 * @@seqno - return seqno stuck into the ring
 *
 * Update the mailbox registers in the *other* rings with the current seqno.
 * This acts like a signal in the canonical semaphore.
 */
static int
gen6_add_request(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *useless;
	int i, ret, num_dwords = 4;

	if (i915_semaphore_is_enabled(dev))
		num_dwords += ((I915_NUM_RINGS-1) * MBOX_UPDATE_DWORDS);
#undef MBOX_UPDATE_DWORDS

	ret = intel_ring_begin(ring, num_dwords);
	if (ret)
		return ret;

	if (i915_semaphore_is_enabled(dev)) {
		for_each_ring(useless, dev_priv, i) {
			u32 mbox_reg = ring->signal_mbox[i];
			if (mbox_reg != GEN6_NOSYNC)
				update_mboxes(ring, mbox_reg);
		}
	}

	intel_ring_emit(ring, MI_STORE_DWORD_INDEX);
	intel_ring_emit(ring, I915_GEM_HWS_INDEX << MI_STORE_DWORD_INDEX_SHIFT);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, MI_USER_INTERRUPT);
	__intel_ring_advance(ring);

	return 0;
}

static inline bool i915_gem_has_seqno_wrapped(struct drm_device *dev,
					      u32 seqno)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	return dev_priv->last_seqno < seqno;
}

/**
 * intel_ring_sync - sync the waiter to the signaller on seqno
 *
 * @@waiter - ring that is waiting
 * @@signaller - ring which has, or will signal
 * @@seqno - seqno which the waiter will block on
 */
static int
gen6_ring_sync(struct intel_ring_buffer *waiter,
	       struct intel_ring_buffer *signaller,
	       u32 seqno)
{
	int ret;
	u32 dw1 = MI_SEMAPHORE_MBOX |
		  MI_SEMAPHORE_COMPARE |
		  MI_SEMAPHORE_REGISTER;

	/* Throughout all of the GEM code, seqno passed implies our current
	 * seqno is >= the last seqno executed. However for hardware the
	 * comparison is strictly greater than.
	 */
	seqno -= 1;

	WARN_ON(signaller->semaphore_register[waiter->id] ==
		MI_SEMAPHORE_SYNC_INVALID);

	ret = intel_ring_begin(waiter, 4);
	if (ret)
		return ret;

	/* If seqno wrap happened, omit the wait with no-ops */
	if (likely(!i915_gem_has_seqno_wrapped(waiter->dev, seqno))) {
		intel_ring_emit(waiter,
				dw1 |
				signaller->semaphore_register[waiter->id]);
		intel_ring_emit(waiter, seqno);
		intel_ring_emit(waiter, 0);
		intel_ring_emit(waiter, MI_NOOP);
	} else {
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
	}
	intel_ring_advance(waiter);

	return 0;
}

#define PIPE_CONTROL_FLUSH(ring__, addr__)					\
do {									\
	intel_ring_emit(ring__, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |		\
		 PIPE_CONTROL_DEPTH_STALL);				\
	intel_ring_emit(ring__, (addr__) | PIPE_CONTROL_GLOBAL_GTT);			\
	intel_ring_emit(ring__, 0);							\
	intel_ring_emit(ring__, 0);							\
} while (0)

static int
pc_render_add_request(struct intel_ring_buffer *ring)
{
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
	int ret;

	/* For Ironlake, MI_USER_INTERRUPT was deprecated and apparently
	 * incoherent with writes to memory, i.e. completely fubar,
	 * so we need to use PIPE_NOTIFY instead.
	 *
	 * However, we also need to workaround the qword write
	 * incoherence by flushing the 6 PIPE_NOTIFY buffers out to
	 * memory before requesting an interrupt.
	 */
	ret = intel_ring_begin(ring, 32);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |
			PIPE_CONTROL_WRITE_FLUSH |
			PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE);
	intel_ring_emit(ring, ring->scratch.gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, 0);
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 128; /* write to separate cachelines */
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 128;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 128;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 128;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 128;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |
			PIPE_CONTROL_WRITE_FLUSH |
			PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE |
			PIPE_CONTROL_NOTIFY);
	intel_ring_emit(ring, ring->scratch.gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, 0);
	__intel_ring_advance(ring);

	return 0;
}

static u32
gen6_ring_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
{
	/* Workaround to force correct ordering between irq and seqno writes on
	 * ivb (and maybe also on snb) by reading from a CS register (like
	 * ACTHD) before reading the status page. */
	if (!lazy_coherency)
		intel_ring_get_active_head(ring);
	return intel_read_status_page(ring, I915_GEM_HWS_INDEX);
}

static u32
ring_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
{
	return intel_read_status_page(ring, I915_GEM_HWS_INDEX);
}

static void
ring_set_seqno(struct intel_ring_buffer *ring, u32 seqno)
{
	intel_write_status_page(ring, I915_GEM_HWS_INDEX, seqno);
}

static u32
pc_render_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
{
	return ring->scratch.cpu_page[0];
}

static void
pc_render_set_seqno(struct intel_ring_buffer *ring, u32 seqno)
{
	ring->scratch.cpu_page[0] = seqno;
}

static bool
gen5_ring_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0)
		ilk_enable_gt_irq(dev_priv, ring->irq_enable_mask);
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen5_ring_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0)
		ilk_disable_gt_irq(dev_priv, ring->irq_enable_mask);
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
i9xx_ring_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		dev_priv->irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(IMR, dev_priv->irq_mask);
		POSTING_READ(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
i9xx_ring_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		dev_priv->irq_mask |= ring->irq_enable_mask;
		I915_WRITE(IMR, dev_priv->irq_mask);
		POSTING_READ(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
i8xx_ring_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		dev_priv->irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE16(IMR, dev_priv->irq_mask);
		POSTING_READ16(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
i8xx_ring_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		dev_priv->irq_mask |= ring->irq_enable_mask;
		I915_WRITE16(IMR, dev_priv->irq_mask);
		POSTING_READ16(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

void intel_ring_setup_status_page(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	u32 mmio = 0;

	/* The ring status page addresses are no longer next to the rest of
	 * the ring registers as of gen7.
	 */
	if (IS_GEN7(dev)) {
		switch (ring->id) {
		case RCS:
			mmio = RENDER_HWS_PGA_GEN7;
			break;
		case BCS:
			mmio = BLT_HWS_PGA_GEN7;
			break;
		case VCS:
			mmio = BSD_HWS_PGA_GEN7;
			break;
		case VECS:
			mmio = VEBOX_HWS_PGA_GEN7;
			break;
		}
	} else if (IS_GEN6(ring->dev)) {
		mmio = RING_HWS_PGA_GEN6(ring->mmio_base);
	} else {
		/* XXX: gen8 returns to sanity */
		mmio = RING_HWS_PGA(ring->mmio_base);
	}

	I915_WRITE(mmio, (u32)ring->status_page.gfx_addr);
	POSTING_READ(mmio);

	/*
	 * Flush the TLB for this page
	 *
	 * FIXME: These two bits have disappeared on gen8, so a question
	 * arises: do we still need this and if so how should we go about
	 * invalidating the TLB?
	 */
	if (INTEL_INFO(dev)->gen >= 6 && INTEL_INFO(dev)->gen < 8) {
		u32 reg = RING_INSTPM(ring->mmio_base);
		I915_WRITE(reg,
			   _MASKED_BIT_ENABLE(INSTPM_TLB_INVALIDATE |
					      INSTPM_SYNC_FLUSH));
		if (wait_for((I915_READ(reg) & INSTPM_SYNC_FLUSH) == 0,
			     1000))
			DRM_ERROR("%s: wait for SyncFlush to complete for TLB invalidation timed out\n",
				  ring->name);
	}
}

static int
bsd_ring_flush(struct intel_ring_buffer *ring,
	       u32     invalidate_domains,
	       u32     flush_domains)
{
	int ret;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_FLUSH);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);
	return 0;
}

static int
i9xx_add_request(struct intel_ring_buffer *ring)
{
	int ret;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_STORE_DWORD_INDEX);
	intel_ring_emit(ring, I915_GEM_HWS_INDEX << MI_STORE_DWORD_INDEX_SHIFT);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, MI_USER_INTERRUPT);
	__intel_ring_advance(ring);

	return 0;
}

static bool
gen6_ring_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
	       return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring,
				       ~(ring->irq_enable_mask |
					 GT_PARITY_ERROR(dev)));
		else
			I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		ilk_enable_gt_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen6_ring_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~GT_PARITY_ERROR(dev));
		else
			I915_WRITE_IMR(ring, ~0);
		ilk_disable_gt_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
hsw_vebox_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		snb_enable_pm_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
hsw_vebox_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		I915_WRITE_IMR(ring, ~0);
		snb_disable_pm_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
gen8_ring_get_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!dev->irq_enabled)
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS) {
			I915_WRITE_IMR(ring,
				       ~(ring->irq_enable_mask |
					 GT_RENDER_L3_PARITY_ERROR_INTERRUPT));
		} else {
			I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		}
		POSTING_READ(RING_IMR(ring->mmio_base));
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen8_ring_put_irq(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS) {
			I915_WRITE_IMR(ring,
				       ~GT_RENDER_L3_PARITY_ERROR_INTERRUPT);
		} else {
			I915_WRITE_IMR(ring, ~0);
		}
		POSTING_READ(RING_IMR(ring->mmio_base));
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static int
i965_dispatch_execbuffer(struct intel_ring_buffer *ring,
			 u32 offset, u32 length,
			 unsigned flags)
{
	int ret;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START |
			MI_BATCH_GTT |
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_I965));
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

/* Just userspace ABI convention to limit the wa batch bo to a resonable size */
#define I830_BATCH_LIMIT (256*1024)
static int
i830_dispatch_execbuffer(struct intel_ring_buffer *ring,
				u32 offset, u32 len,
				unsigned flags)
{
	int ret;

	if (flags & I915_DISPATCH_PINNED) {
		ret = intel_ring_begin(ring, 4);
		if (ret)
			return ret;

		intel_ring_emit(ring, MI_BATCH_BUFFER);
		intel_ring_emit(ring, offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
		intel_ring_emit(ring, offset + len - 8);
		intel_ring_emit(ring, MI_NOOP);
		intel_ring_advance(ring);
	} else {
		u32 cs_offset = ring->scratch.gtt_offset;

		if (len > I830_BATCH_LIMIT)
			return -ENOSPC;

		ret = intel_ring_begin(ring, 9+3);
		if (ret)
			return ret;
		/* Blit the batch (which has now all relocs applied) to the stable batch
		 * scratch bo area (so that the CS never stumbles over its tlb
		 * invalidation bug) ... */
		intel_ring_emit(ring, XY_SRC_COPY_BLT_CMD |
				XY_SRC_COPY_BLT_WRITE_ALPHA |
				XY_SRC_COPY_BLT_WRITE_RGB);
		intel_ring_emit(ring, BLT_DEPTH_32 | BLT_ROP_GXCOPY | 4096);
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, (DIV_ROUND_UP(len, 4096) << 16) | 1024);
		intel_ring_emit(ring, cs_offset);
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, 4096);
		intel_ring_emit(ring, offset);
		intel_ring_emit(ring, MI_FLUSH);

		/* ... and execute it. */
		intel_ring_emit(ring, MI_BATCH_BUFFER);
		intel_ring_emit(ring, cs_offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
		intel_ring_emit(ring, cs_offset + len - 8);
		intel_ring_advance(ring);
	}

	return 0;
}

static int
i915_dispatch_execbuffer(struct intel_ring_buffer *ring,
			 u32 offset, u32 len,
			 unsigned flags)
{
	int ret;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_BATCH_BUFFER_START | MI_BATCH_GTT);
	intel_ring_emit(ring, offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
	intel_ring_advance(ring);

	return 0;
}

static void cleanup_status_page(struct intel_ring_buffer *ring)
{
	struct drm_i915_gem_object *obj;

	obj = ring->status_page.obj;
	if (obj == NULL)
		return;

	uvm_unmap(kernel_map, (vaddr_t)ring->status_page.page_addr,
	    (vaddr_t)ring->status_page.page_addr + PAGE_SIZE);
	i915_gem_object_unpin(obj);
	drm_gem_object_unreference(&obj->base);
	ring->status_page.obj = NULL;
}

static int init_status_page(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_gem_object *obj;
	int ret;

	obj = i915_gem_alloc_object(dev, 4096);
	if (obj == NULL) {
		DRM_ERROR("Failed to allocate status page\n");
		ret = -ENOMEM;
		goto err;
	}

	i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);

	ret = i915_gem_obj_ggtt_pin(obj, 4096, true, false);
	if (ret != 0) {
		goto err_unref;
	}

	ring->status_page.gfx_addr = i915_gem_obj_ggtt_offset(obj);
	ring->status_page.page_addr = (u_int32_t *)vm_map_min(kernel_map);
	obj->base.uao->pgops->pgo_reference(obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&ring->status_page.page_addr,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE,
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, MADV_RANDOM, 0));
	if (ret != 0) {
		obj->base.uao->pgops->pgo_detach(obj->base.uao);
		ret = -ENOMEM;
		goto err_unpin;
	}
	ring->status_page.obj = obj;
	memset(ring->status_page.page_addr, 0, PAGE_SIZE);

	DRM_DEBUG_DRIVER("%s hws offset: 0x%08x\n",
			ring->name, ring->status_page.gfx_addr);

	return 0;

err_unpin:
	i915_gem_object_unpin(obj);
err_unref:
	drm_gem_object_unreference(&obj->base);
err:
	return ret;
}

static int init_phys_status_page(struct intel_ring_buffer *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	if (!dev_priv->status_page_dmah) {
		dev_priv->status_page_dmah = drm_dmamem_alloc(dev_priv->dmat,
		    PAGE_SIZE, PAGE_SIZE, 1, PAGE_SIZE, 0, BUS_DMA_READ);
		if (!dev_priv->status_page_dmah)
			return -ENOMEM;
	}

	ring->status_page.page_addr = (u32 *)dev_priv->status_page_dmah->kva;
	memset(ring->status_page.page_addr, 0, PAGE_SIZE);

	return 0;
}

static int intel_init_ring_buffer(struct drm_device *dev,
				  struct intel_ring_buffer *ring)
{
	struct drm_i915_gem_object *obj;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret;

	ring->dev = dev;
	INIT_LIST_HEAD(&ring->active_list);
	INIT_LIST_HEAD(&ring->request_list);
	ring->size = 32 * PAGE_SIZE;
	memset(ring->sync_seqno, 0, sizeof(ring->sync_seqno));

	init_waitqueue_head(&ring->irq_queue);

	if (I915_NEED_GFX_HWS(dev)) {
		ret = init_status_page(ring);
		if (ret)
			return ret;
	} else {
		BUG_ON(ring->id != RCS);
		ret = init_phys_status_page(ring);
		if (ret)
			return ret;
	}

	obj = NULL;
	if (!HAS_LLC(dev))
		obj = i915_gem_object_create_stolen(dev, ring->size);
	if (obj == NULL)
		obj = i915_gem_alloc_object(dev, ring->size);
	if (obj == NULL) {
		DRM_ERROR("Failed to allocate ringbuffer\n");
		ret = -ENOMEM;
		goto err_hws;
	}

	ring->obj = obj;

	ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, true, false);
	if (ret)
		goto err_unref;

	ret = i915_gem_object_set_to_gtt_domain(obj, true);
	if (ret)
		goto err_unpin;

	if ((ret = agp_map_subregion(dev_priv->agph,
	    i915_gem_obj_ggtt_offset(obj), ring->size, &ring->bsh)) != 0) {
		DRM_ERROR("Failed to map ringbuffer.\n");
		ret = -EINVAL;
		goto err_unpin;
	}
	ring->virtual_start = bus_space_vaddr(dev_priv->bst, ring->bsh);

	ret = ring->init(ring);
	if (ret)
		goto err_unmap;

	/* Workaround an erratum on the i830 which causes a hang if
	 * the TAIL pointer points to within the last 2 cachelines
	 * of the buffer.
	 */
	ring->effective_size = ring->size;
	if (IS_I830(ring->dev) || IS_845G(ring->dev))
		ring->effective_size -= 128;

	return 0;

err_unmap:
	agp_unmap_subregion(dev_priv->agph, ring->bsh, ring->size);
err_unpin:
	i915_gem_object_unpin(obj);
err_unref:
	drm_gem_object_unreference(&obj->base);
	ring->obj = NULL;
err_hws:
	cleanup_status_page(ring);
	return ret;
}

void intel_cleanup_ring_buffer(struct intel_ring_buffer *ring)
{
	struct drm_i915_private *dev_priv;
	int ret;

	if (ring->obj == NULL)
		return;

	/* Disable the ring buffer. The ring must be idle at this point */
	dev_priv = ring->dev->dev_private;
	ret = intel_ring_idle(ring);
	if (ret && !i915_reset_in_progress(&dev_priv->gpu_error))
		DRM_ERROR("failed to quiesce %s whilst cleaning up: %d\n",
			  ring->name, ret);

	I915_WRITE_CTL(ring, 0);

	agp_unmap_subregion(dev_priv->agph, ring->bsh, ring->size);

	i915_gem_object_unpin(ring->obj);
	drm_gem_object_unreference(&ring->obj->base);
	ring->obj = NULL;
	ring->preallocated_lazy_request = NULL;
	ring->outstanding_lazy_seqno = 0;

	if (ring->cleanup)
		ring->cleanup(ring);

	cleanup_status_page(ring);
}

static int intel_ring_wait_seqno(struct intel_ring_buffer *ring, u32 seqno)
{
	int ret;

	ret = i915_wait_seqno(ring, seqno);
	if (!ret)
		i915_gem_retire_requests_ring(ring);

	return ret;
}

static int intel_ring_wait_request(struct intel_ring_buffer *ring, int n)
{
	struct drm_i915_gem_request *request;
	u32 seqno = 0;
	int ret;

	i915_gem_retire_requests_ring(ring);

	if (ring->last_retired_head != -1) {
		ring->head = ring->last_retired_head;
		ring->last_retired_head = -1;
		ring->space = ring_space(ring);
		if (ring->space >= n)
			return 0;
	}

	list_for_each_entry(request, &ring->request_list, list) {
		int space;

		if (request->tail == -1)
			continue;

		space = request->tail - (ring->tail + I915_RING_FREE_SPACE);
		if (space < 0)
			space += ring->size;
		if (space >= n) {
			seqno = request->seqno;
			break;
		}

		/* Consume this request in case we need more space than
		 * is available and so need to prevent a race between
		 * updating last_retired_head and direct reads of
		 * I915_RING_HEAD. It also provides a nice sanity check.
		 */
		request->tail = -1;
	}

	if (seqno == 0)
		return -ENOSPC;

	ret = intel_ring_wait_seqno(ring, seqno);
	if (ret)
		return ret;

	if (WARN_ON(ring->last_retired_head == -1))
		return -ENOSPC;

	ring->head = ring->last_retired_head;
	ring->last_retired_head = -1;
	ring->space = ring_space(ring);
	if (WARN_ON(ring->space < n))
		return -ENOSPC;

	return 0;
}

static int ring_wait_for_space(struct intel_ring_buffer *ring, int n)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long end;
	int ret;

	ret = intel_ring_wait_request(ring, n);
	if (ret != -ENOSPC)
		return ret;

	/* force the tail write in case we have been skipping them */
	__intel_ring_advance(ring);

	trace_i915_ring_wait_begin(ring);
	/* With GEM the hangcheck timer should kick us out of the loop,
	 * leaving it early runs the risk of corrupting GEM state (due
	 * to running on almost untested codepaths). But on resume
	 * timers don't work yet, so prevent a complete hang in that
	 * case by choosing an insanely large timeout. */
	end = jiffies + 60 * HZ;

	do {
		ring->head = I915_READ_HEAD(ring);
		ring->space = ring_space(ring);
		if (ring->space >= n) {
			trace_i915_ring_wait_end(ring);
			return 0;
		}

#if 0
		if (dev->primary->master) {
			struct drm_i915_master_private *master_priv = dev->primary->master->driver_priv;
			if (master_priv->sarea_priv)
				master_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;
		}
#endif

		drm_msleep(1);

		ret = i915_gem_check_wedge(&dev_priv->gpu_error,
					   dev_priv->mm.interruptible);
		if (ret)
			return ret;
	} while (!time_after(jiffies, end));
	trace_i915_ring_wait_end(ring);
	return -EBUSY;
}

static int intel_wrap_ring_buffer(struct intel_ring_buffer *ring)
{
	uint32_t __iomem *virt;
	int rem = ring->size - ring->tail;

	if (ring->space < rem) {
		int ret = ring_wait_for_space(ring, rem);
		if (ret)
			return ret;
	}

	virt = ring->virtual_start + ring->tail;
	rem /= 4;
	while (rem--)
		iowrite32(MI_NOOP, virt++);

	ring->tail = 0;
	ring->space = ring_space(ring);

	return 0;
}

int intel_ring_idle(struct intel_ring_buffer *ring)
{
	u32 seqno;
	int ret;

	/* We need to add any requests required to flush the objects and ring */
	if (ring->outstanding_lazy_seqno) {
		ret = i915_add_request(ring, NULL);
		if (ret)
			return ret;
	}

	/* Wait upon the last request to be completed */
	if (list_empty(&ring->request_list))
		return 0;

	seqno = list_entry(ring->request_list.prev,
			   struct drm_i915_gem_request,
			   list)->seqno;

	return i915_wait_seqno(ring, seqno);
}

static int
intel_ring_alloc_seqno(struct intel_ring_buffer *ring)
{
	if (ring->outstanding_lazy_seqno)
		return 0;

	if (ring->preallocated_lazy_request == NULL) {
		struct drm_i915_gem_request *request;

		request = kmalloc(sizeof(*request), GFP_KERNEL);
		if (request == NULL)
			return -ENOMEM;

		ring->preallocated_lazy_request = request;
	}

	return i915_gem_get_seqno(ring->dev, &ring->outstanding_lazy_seqno);
}

static int __intel_ring_prepare(struct intel_ring_buffer *ring,
				int bytes)
{
	int ret;

	if (unlikely(ring->tail + bytes > ring->effective_size)) {
		ret = intel_wrap_ring_buffer(ring);
		if (unlikely(ret))
			return ret;
	}

	if (unlikely(ring->space < bytes)) {
		ret = ring_wait_for_space(ring, bytes);
		if (unlikely(ret))
			return ret;
	}

	return 0;
}

int intel_ring_begin(struct intel_ring_buffer *ring,
		     int num_dwords)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	int ret;

	ret = i915_gem_check_wedge(&dev_priv->gpu_error,
				   dev_priv->mm.interruptible);
	if (ret)
		return ret;

	ret = __intel_ring_prepare(ring, num_dwords * sizeof(uint32_t));
	if (ret)
		return ret;

	/* Preallocate the olr before touching the ring */
	ret = intel_ring_alloc_seqno(ring);
	if (ret)
		return ret;

	ring->space -= num_dwords * sizeof(uint32_t);
	return 0;
}

/* Align the ring tail to a cacheline boundary */
int intel_ring_cacheline_align(struct intel_ring_buffer *ring)
{
	int num_dwords = (64 - (ring->tail & 63)) / sizeof(uint32_t);
	int ret;

	if (num_dwords == 0)
		return 0;

	ret = intel_ring_begin(ring, num_dwords);
	if (ret)
		return ret;

	while (num_dwords--)
		intel_ring_emit(ring, MI_NOOP);

	intel_ring_advance(ring);

	return 0;
}

void intel_ring_init_seqno(struct intel_ring_buffer *ring, u32 seqno)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	BUG_ON(ring->outstanding_lazy_seqno);

	if (INTEL_INFO(ring->dev)->gen >= 6) {
		I915_WRITE(RING_SYNC_0(ring->mmio_base), 0);
		I915_WRITE(RING_SYNC_1(ring->mmio_base), 0);
		if (HAS_VEBOX(ring->dev))
			I915_WRITE(RING_SYNC_2(ring->mmio_base), 0);
	}

	ring->set_seqno(ring, seqno);
	ring->hangcheck.seqno = seqno;
}

static void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,
				     u32 value)
{
	drm_i915_private_t *dev_priv = ring->dev->dev_private;

       /* Every tail move must follow the sequence below */

	/* Disable notification that the ring is IDLE. The GT
	 * will then assume that it is busy and bring it out of rc6.
	 */
	I915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,
		   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));

	/* Clear the context id. Here be magic! */
	I915_WRITE64(GEN6_BSD_RNCID, 0x0);

	/* Wait for the ring not to be idle, i.e. for it to wake up. */
	if (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &
		      GEN6_BSD_SLEEP_INDICATOR) == 0,
		     50))
		DRM_ERROR("timed out waiting for the BSD ring to wake up\n");

	/* Now that the ring is fully powered up, update the tail */
	I915_WRITE_TAIL(ring, value);
	POSTING_READ(RING_TAIL(ring->mmio_base));

	/* Let the ring send IDLE messages to the GT again,
	 * and so let it sleep to conserve power when idle.
	 */
	I915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,
		   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));
}

static int gen6_bsd_ring_flush(struct intel_ring_buffer *ring,
			       u32 invalidate, u32 flush)
{
	uint32_t cmd;
	int ret;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	cmd = MI_FLUSH_DW;
	if (INTEL_INFO(ring->dev)->gen >= 8)
		cmd += 1;
	/*
	 * Bspec vol 1c.5 - video engine command streamer:
	 * "If ENABLED, all TLBs will be invalidated once the flush
	 * operation is complete. This bit is only valid when the
	 * Post-Sync Operation field is a value of 1h or 3h."
	 */
	if (invalidate & I915_GEM_GPU_DOMAINS)
		cmd |= MI_INVALIDATE_TLB | MI_INVALIDATE_BSD |
			MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;
	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, I915_GEM_HWS_SCRATCH_ADDR | MI_FLUSH_DW_USE_GTT);
	if (INTEL_INFO(ring->dev)->gen >= 8) {
		intel_ring_emit(ring, 0); /* upper addr */
		intel_ring_emit(ring, 0); /* value */
	} else  {
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, MI_NOOP);
	}
	intel_ring_advance(ring);
	return 0;
}

static int
gen8_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	bool ppgtt = dev_priv->mm.aliasing_ppgtt != NULL &&
		!(flags & I915_DISPATCH_SECURE);
	int ret;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	/* FIXME(BDW): Address space and security selectors. */
	intel_ring_emit(ring, MI_BATCH_BUFFER_START_GEN8 | (ppgtt<<8));
	intel_ring_emit(ring, offset);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
hsw_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
{
	int ret;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START | MI_BATCH_PPGTT_HSW |
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_HSW));
	/* bit0-7 is the length on GEN6+ */
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

static int
gen6_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
{
	int ret;

	ret = intel_ring_begin(ring, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START |
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_I965));
	/* bit0-7 is the length on GEN6+ */
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

/* Blitter support (SandyBridge+) */

static int gen6_ring_flush(struct intel_ring_buffer *ring,
			   u32 invalidate, u32 flush)
{
	struct drm_device *dev = ring->dev;
	uint32_t cmd;
	int ret;

	ret = intel_ring_begin(ring, 4);
	if (ret)
		return ret;

	cmd = MI_FLUSH_DW;
	if (INTEL_INFO(ring->dev)->gen >= 8)
		cmd += 1;
	/*
	 * Bspec vol 1c.3 - blitter engine command streamer:
	 * "If ENABLED, all TLBs will be invalidated once the flush
	 * operation is complete. This bit is only valid when the
	 * Post-Sync Operation field is a value of 1h or 3h."
	 */
	if (invalidate & I915_GEM_DOMAIN_RENDER)
		cmd |= MI_INVALIDATE_TLB | MI_FLUSH_DW_STORE_INDEX |
			MI_FLUSH_DW_OP_STOREDW;
	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, I915_GEM_HWS_SCRATCH_ADDR | MI_FLUSH_DW_USE_GTT);
	if (INTEL_INFO(ring->dev)->gen >= 8) {
		intel_ring_emit(ring, 0); /* upper addr */
		intel_ring_emit(ring, 0); /* value */
	} else  {
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, MI_NOOP);
	}
	intel_ring_advance(ring);

	if (IS_GEN7(dev) && !invalidate && flush)
		return gen7_ring_fbc_flush(ring, FBC_REND_CACHE_CLEAN);

	return 0;
}

int intel_init_render_ring_buffer(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];

	ring->name = "render ring";
	ring->id = RCS;
	ring->mmio_base = RENDER_RING_BASE;

	if (INTEL_INFO(dev)->gen >= 6) {
		ring->add_request = gen6_add_request;
		ring->flush = gen7_render_ring_flush;
		if (INTEL_INFO(dev)->gen == 6)
			ring->flush = gen6_render_ring_flush;
		if (INTEL_INFO(dev)->gen >= 8) {
			ring->flush = gen8_render_ring_flush;
			ring->irq_get = gen8_ring_get_irq;
			ring->irq_put = gen8_ring_put_irq;
		} else {
			ring->irq_get = gen6_ring_get_irq;
			ring->irq_put = gen6_ring_put_irq;
		}
		ring->irq_enable_mask = GT_RENDER_USER_INTERRUPT;
		ring->get_seqno = gen6_ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		ring->sync_to = gen6_ring_sync;
		ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_RV;
		ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_RB;
		ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_RVE;
		ring->signal_mbox[RCS] = GEN6_NOSYNC;
		ring->signal_mbox[VCS] = GEN6_VRSYNC;
		ring->signal_mbox[BCS] = GEN6_BRSYNC;
		ring->signal_mbox[VECS] = GEN6_VERSYNC;
	} else if (IS_GEN5(dev)) {
		ring->add_request = pc_render_add_request;
		ring->flush = gen4_render_ring_flush;
		ring->get_seqno = pc_render_get_seqno;
		ring->set_seqno = pc_render_set_seqno;
		ring->irq_get = gen5_ring_get_irq;
		ring->irq_put = gen5_ring_put_irq;
		ring->irq_enable_mask = GT_RENDER_USER_INTERRUPT |
					GT_RENDER_PIPECTL_NOTIFY_INTERRUPT;
	} else {
		ring->add_request = i9xx_add_request;
		if (INTEL_INFO(dev)->gen < 4)
			ring->flush = gen2_render_ring_flush;
		else
			ring->flush = gen4_render_ring_flush;
		ring->get_seqno = ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (IS_GEN2(dev)) {
			ring->irq_get = i8xx_ring_get_irq;
			ring->irq_put = i8xx_ring_put_irq;
		} else {
			ring->irq_get = i9xx_ring_get_irq;
			ring->irq_put = i9xx_ring_put_irq;
		}
		ring->irq_enable_mask = I915_USER_INTERRUPT;
	}
	ring->write_tail = ring_write_tail;
	if (IS_HASWELL(dev))
		ring->dispatch_execbuffer = hsw_ring_dispatch_execbuffer;
	else if (IS_GEN8(dev))
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
	else if (INTEL_INFO(dev)->gen >= 6)
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
	else if (INTEL_INFO(dev)->gen >= 4)
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	else if (IS_I830(dev) || IS_845G(dev))
		ring->dispatch_execbuffer = i830_dispatch_execbuffer;
	else
		ring->dispatch_execbuffer = i915_dispatch_execbuffer;
	ring->init = init_render_ring;
	ring->cleanup = render_ring_cleanup;

	/* Workaround batchbuffer to combat CS tlb bug. */
	if (HAS_BROKEN_CS_TLB(dev)) {
		struct drm_i915_gem_object *obj;
		int ret;

		obj = i915_gem_alloc_object(dev, I830_BATCH_LIMIT);
		if (obj == NULL) {
			DRM_ERROR("Failed to allocate batch bo\n");
			return -ENOMEM;
		}

		ret = i915_gem_obj_ggtt_pin(obj, 0, true, false);
		if (ret != 0) {
			drm_gem_object_unreference(&obj->base);
			DRM_ERROR("Failed to ping batch bo\n");
			return ret;
		}

		ring->scratch.obj = obj;
		ring->scratch.gtt_offset = i915_gem_obj_ggtt_offset(obj);
	}

	return intel_init_ring_buffer(dev, ring);
}

int intel_render_ring_init_dri(struct drm_device *dev, u64 start, u32 size)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
	int ret;

	ring->name = "render ring";
	ring->id = RCS;
	ring->mmio_base = RENDER_RING_BASE;

	if (INTEL_INFO(dev)->gen >= 6) {
		/* non-kms not supported on gen6+ */
		return -ENODEV;
	}

	/* Note: gem is not supported on gen5/ilk without kms (the corresponding
	 * gem_init ioctl returns with -ENODEV). Hence we do not need to set up
	 * the special gen5 functions. */
	ring->add_request = i9xx_add_request;
	if (INTEL_INFO(dev)->gen < 4)
		ring->flush = gen2_render_ring_flush;
	else
		ring->flush = gen4_render_ring_flush;
	ring->get_seqno = ring_get_seqno;
	ring->set_seqno = ring_set_seqno;
	if (IS_GEN2(dev)) {
		ring->irq_get = i8xx_ring_get_irq;
		ring->irq_put = i8xx_ring_put_irq;
	} else {
		ring->irq_get = i9xx_ring_get_irq;
		ring->irq_put = i9xx_ring_put_irq;
	}
	ring->irq_enable_mask = I915_USER_INTERRUPT;
	ring->write_tail = ring_write_tail;
	if (INTEL_INFO(dev)->gen >= 4)
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	else if (IS_I830(dev) || IS_845G(dev))
		ring->dispatch_execbuffer = i830_dispatch_execbuffer;
	else
		ring->dispatch_execbuffer = i915_dispatch_execbuffer;
	ring->init = init_render_ring;
	ring->cleanup = render_ring_cleanup;

	ring->dev = dev;
	INIT_LIST_HEAD(&ring->active_list);
	INIT_LIST_HEAD(&ring->request_list);

	ring->size = size;
	ring->effective_size = ring->size;
	if (IS_I830(ring->dev) || IS_845G(ring->dev))
		ring->effective_size -= 128;

	if ((ret = agp_map_subregion(dev_priv->agph, start,
	    size, &ring->bsh)) != 0) {
		DRM_ERROR("Failed to map ringbuffer.\n");
		return -ENOMEM;
	}
	ring->virtual_start = bus_space_vaddr(dev_priv->bst, ring->bsh);

	if (!I915_NEED_GFX_HWS(dev)) {
		ret = init_phys_status_page(ring);
		if (ret)
			return ret;
	}

	return 0;
}

int intel_init_bsd_ring_buffer(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[VCS];

	ring->name = "bsd ring";
	ring->id = VCS;

	ring->write_tail = ring_write_tail;
	if (INTEL_INFO(dev)->gen >= 6) {
		ring->mmio_base = GEN6_BSD_RING_BASE;
		/* gen6 bsd needs a special wa for tail updates */
		if (IS_GEN6(dev))
			ring->write_tail = gen6_bsd_ring_write_tail;
		ring->flush = gen6_bsd_ring_flush;
		ring->add_request = gen6_add_request;
		ring->get_seqno = gen6_ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (INTEL_INFO(dev)->gen >= 8) {
			ring->irq_enable_mask =
				GT_RENDER_USER_INTERRUPT << GEN8_VCS1_IRQ_SHIFT;
			ring->irq_get = gen8_ring_get_irq;
			ring->irq_put = gen8_ring_put_irq;
			ring->dispatch_execbuffer =
				gen8_ring_dispatch_execbuffer;
		} else {
			ring->irq_enable_mask = GT_BSD_USER_INTERRUPT;
			ring->irq_get = gen6_ring_get_irq;
			ring->irq_put = gen6_ring_put_irq;
			ring->dispatch_execbuffer =
				gen6_ring_dispatch_execbuffer;
		}
		ring->sync_to = gen6_ring_sync;
		ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_VR;
		ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_VB;
		ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_VVE;
		ring->signal_mbox[RCS] = GEN6_RVSYNC;
		ring->signal_mbox[VCS] = GEN6_NOSYNC;
		ring->signal_mbox[BCS] = GEN6_BVSYNC;
		ring->signal_mbox[VECS] = GEN6_VEVSYNC;
	} else {
		ring->mmio_base = BSD_RING_BASE;
		ring->flush = bsd_ring_flush;
		ring->add_request = i9xx_add_request;
		ring->get_seqno = ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (IS_GEN5(dev)) {
			ring->irq_enable_mask = ILK_BSD_USER_INTERRUPT;
			ring->irq_get = gen5_ring_get_irq;
			ring->irq_put = gen5_ring_put_irq;
		} else {
			ring->irq_enable_mask = I915_BSD_USER_INTERRUPT;
			ring->irq_get = i9xx_ring_get_irq;
			ring->irq_put = i9xx_ring_put_irq;
		}
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	}
	ring->init = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int intel_init_blt_ring_buffer(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[BCS];

	ring->name = "blitter ring";
	ring->id = BCS;

	ring->mmio_base = BLT_RING_BASE;
	ring->write_tail = ring_write_tail;
	ring->flush = gen6_ring_flush;
	ring->add_request = gen6_add_request;
	ring->get_seqno = gen6_ring_get_seqno;
	ring->set_seqno = ring_set_seqno;
	if (INTEL_INFO(dev)->gen >= 8) {
		ring->irq_enable_mask =
			GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT;
		ring->irq_get = gen8_ring_get_irq;
		ring->irq_put = gen8_ring_put_irq;
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
	} else {
		ring->irq_enable_mask = GT_BLT_USER_INTERRUPT;
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
	}
	ring->sync_to = gen6_ring_sync;
	ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_BR;
	ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_BV;
	ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_INVALID;
	ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_BVE;
	ring->signal_mbox[RCS] = GEN6_RBSYNC;
	ring->signal_mbox[VCS] = GEN6_VBSYNC;
	ring->signal_mbox[BCS] = GEN6_NOSYNC;
	ring->signal_mbox[VECS] = GEN6_VEBSYNC;
	ring->init = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int intel_init_vebox_ring_buffer(struct drm_device *dev)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[VECS];

	ring->name = "video enhancement ring";
	ring->id = VECS;

	ring->mmio_base = VEBOX_RING_BASE;
	ring->write_tail = ring_write_tail;
	ring->flush = gen6_ring_flush;
	ring->add_request = gen6_add_request;
	ring->get_seqno = gen6_ring_get_seqno;
	ring->set_seqno = ring_set_seqno;

	if (INTEL_INFO(dev)->gen >= 8) {
		ring->irq_enable_mask =
			GT_RENDER_USER_INTERRUPT << GEN8_VECS_IRQ_SHIFT;
		ring->irq_get = gen8_ring_get_irq;
		ring->irq_put = gen8_ring_put_irq;
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
	} else {
		ring->irq_enable_mask = PM_VEBOX_USER_INTERRUPT;
		ring->irq_get = hsw_vebox_get_irq;
		ring->irq_put = hsw_vebox_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
	}
	ring->sync_to = gen6_ring_sync;
	ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_VER;
	ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_VEV;
	ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_VEB;
	ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_INVALID;
	ring->signal_mbox[RCS] = GEN6_RVESYNC;
	ring->signal_mbox[VCS] = GEN6_VVESYNC;
	ring->signal_mbox[BCS] = GEN6_BVESYNC;
	ring->signal_mbox[VECS] = GEN6_NOSYNC;
	ring->init = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int
intel_ring_flush_all_caches(struct intel_ring_buffer *ring)
{
	int ret;

	if (!ring->gpu_caches_dirty)
		return 0;

	ret = ring->flush(ring, 0, I915_GEM_GPU_DOMAINS);
	if (ret)
		return ret;

	trace_i915_gem_ring_flush(ring, 0, I915_GEM_GPU_DOMAINS);

	ring->gpu_caches_dirty = false;
	return 0;
}

int
intel_ring_invalidate_all_caches(struct intel_ring_buffer *ring)
{
	uint32_t flush_domains;
	int ret;

	flush_domains = 0;
	if (ring->gpu_caches_dirty)
		flush_domains = I915_GEM_GPU_DOMAINS;

	ret = ring->flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);
	if (ret)
		return ret;

	trace_i915_gem_ring_flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);

	ring->gpu_caches_dirty = false;
	return 0;
}
@


1.30
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.29 2015/06/24 17:59:42 kettenis Exp $	*/
d585 1
a585 1
	 * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv
d994 8
a1001 2
	/* Flush the TLB for this page */
	if (INTEL_INFO(dev)->gen >= 6) {
@


1.29
log
@Linux jiffies and OpenBSD ticks are the same thing.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.28 2015/04/12 17:10:07 kettenis Exp $	*/
a36 10
/*
 * 965+ support PIPE_CONTROL commands, which provide finer grained control
 * over cache flushing.
 */
struct pipe_control {
	struct drm_i915_gem_object *obj;
	volatile u32 *cpu_page;
	u32 gtt_offset;
};

d45 10
d179 1
a179 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d216 1
a216 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d282 23
d310 1
a310 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d338 1
d345 2
d363 43
d407 1
d426 11
d445 6
a450 2
	if (HAS_FORCE_WAKE(dev))
		gen6_gt_force_wake_get(dev_priv);
d482 3
d489 1
a489 1
	I915_WRITE_START(ring, obj->gtt_offset);
d496 1
a496 1
		     I915_READ_START(ring) == obj->gtt_offset &&
d518 2
d521 1
a521 2
	if (HAS_FORCE_WAKE(dev))
		gen6_gt_force_wake_put(dev_priv);
a528 2
	struct pipe_control *pc;
	struct drm_i915_gem_object *obj;
d531 1
a531 1
	if (ring->private)
d534 2
a535 6
	pc = kmalloc(sizeof(*pc), GFP_KERNEL);
	if (!pc)
		return -ENOMEM;

	obj = i915_gem_alloc_object(ring->dev, 4096);
	if (obj == NULL) {
d541 1
a541 1
	i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);
d543 1
a543 1
	ret = i915_gem_object_pin(obj, 4096, true, false);
d547 7
a553 6
	pc->gtt_offset = obj->gtt_offset;
	pc->cpu_page = (volatile u_int32_t *)vm_map_min(kernel_map);
	obj->base.uao->pgops->pgo_reference(obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&pc->cpu_page,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE,
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, MADV_RANDOM, 0));
d555 2
a556 2
		DRM_ERROR("Failed to map status page.\n");
		obj->base.uao->pgops->pgo_detach(obj->base.uao);
d560 2
a561 2
	pc->obj = obj;
	ring->private = pc;
d565 1
a565 1
	i915_gem_object_unpin(obj);
d567 1
a567 1
	drm_gem_object_unreference(&obj->base);
a568 1
	kfree(pc);
a571 16
static void
cleanup_pipe_control(struct intel_ring_buffer *ring)
{
	struct pipe_control *pc = ring->private;
	struct drm_i915_gem_object *obj;

	obj = pc->obj;

	uvm_unmap(kernel_map, (vaddr_t)pc->cpu_page,
	    (vaddr_t)pc->cpu_page + PAGE_SIZE);
	i915_gem_object_unpin(obj);
	drm_gem_object_unreference(&obj->base);

	kfree(pc);
}

d584 2
d626 2
a627 2
	if (HAS_L3_GPU_CACHE(dev))
		I915_WRITE_IMR(ring, ~GEN6_RENDER_L3_PARITY_ERROR);
d636 1
a636 1
	if (!ring->private)
d639 5
a643 5
	if (HAS_BROKEN_CS_TLB(dev))
		drm_gem_object_unreference(to_gem_object(ring->private));

	if (INTEL_INFO(dev)->gen >= 5)
		cleanup_pipe_control(ring);
d645 2
a646 1
	ring->private = NULL;
d653 6
d661 2
a662 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d677 8
a684 3
	u32 mbox1_reg;
	u32 mbox2_reg;
	int ret;
d686 1
a686 1
	ret = intel_ring_begin(ring, 10);
d690 7
a696 2
	mbox1_reg = ring->signal_mbox[0];
	mbox2_reg = ring->signal_mbox[1];
a697 2
	update_mboxes(ring, mbox1_reg);
	update_mboxes(ring, mbox2_reg);
d700 1
a700 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d702 1
a702 1
	intel_ring_advance(ring);
d707 7
d744 14
a757 5
	intel_ring_emit(waiter,
			dw1 | signaller->semaphore_register[waiter->id]);
	intel_ring_emit(waiter, seqno);
	intel_ring_emit(waiter, 0);
	intel_ring_emit(waiter, MI_NOOP);
d775 1
a775 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d793 2
a794 2
	intel_ring_emit(ring, pc->gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d812 2
a813 2
	intel_ring_emit(ring, pc->gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d815 1
a815 1
	intel_ring_advance(ring);
d837 6
d846 7
a852 2
	struct pipe_control *pc = ring->private;
	return pc->cpu_page[0];
d866 2
a867 5
	if (ring->irq_refcount++ == 0) {
		dev_priv->gt_irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
	}
d881 2
a882 5
	if (--ring->irq_refcount == 0) {
		dev_priv->gt_irq_mask |= ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
	}
d980 3
d984 1
a984 1
	} else if (IS_GEN6(dev_priv->dev)) {
d987 1
d1035 1
a1035 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d1037 1
a1037 1
	intel_ring_advance(ring);
a1051 5
	/* It looks like we need to prevent the gt from suspending while waiting
	 * for an notifiy irq, otherwise irqs seem to get lost on at least the
	 * blt/bsd rings on ivb. */
	gen6_gt_force_wake_get(dev_priv);

d1054 4
a1057 3
		if (HAS_L3_GPU_CACHE(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~(ring->irq_enable_mask |
						GEN6_RENDER_L3_PARITY_ERROR));
d1060 1
a1060 3
		dev_priv->gt_irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
d1076 2
a1077 2
		if (HAS_L3_GPU_CACHE(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~GEN6_RENDER_L3_PARITY_ERROR);
d1080 39
a1118 3
		dev_priv->gt_irq_mask |= ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
d1121 1
d1123 44
a1166 1
	gen6_gt_force_wake_put(dev_priv);
d1210 1
a1210 2
		struct drm_i915_gem_object *obj = ring->private;
		u32 cs_offset = obj->gtt_offset;
d1291 1
a1291 1
	ret = i915_gem_object_pin(obj, 4096, true, false);
d1296 1
a1296 1
	ring->status_page.gfx_addr = obj->gtt_offset;
a1309 1
	intel_ring_setup_status_page(ring);
d1323 1
a1323 1
static int init_phys_hws_pga(struct intel_ring_buffer *ring)
a1325 1
	u32 addr;
a1333 7
	addr = dev_priv->status_page_dmah->map->dm_segs[0].ds_addr;
	if (INTEL_INFO(ring->dev)->gen >= 4)
		addr |= (dev_priv->status_page_dmah->map->dm_segs[0].ds_addr >> 28) & 0xf0;
	bus_dmamap_sync(dev_priv->dmat, dev_priv->status_page_dmah->map, 0,
	    PAGE_SIZE, BUS_DMASYNC_PREREAD);
	I915_WRITE(HWS_PGA, addr);

a1339 10
u32
intel_read_status_page(struct intel_ring_buffer *ring, int reg)
{
	u32			 val;

	val = ((volatile u_int32_t *)(ring->status_page.page_addr))[reg];

	return (val);
}

d1361 1
a1361 1
		ret = init_phys_hws_pga(ring);
d1366 5
a1370 1
	obj = i915_gem_alloc_object(dev, ring->size);
d1379 1
a1379 1
	ret = i915_gem_object_pin(obj, PAGE_SIZE, true, false);
d1387 2
a1388 2
	if ((ret = agp_map_subregion(dev_priv->agph, obj->gtt_offset,
	    ring->size, &ring->bsh)) != 0) {
d1393 1
d1432 1
a1432 1
	if (ret)
d1443 2
d1531 3
d1558 1
a1558 1
		drm_msleep(1, "915wfs");
d1560 2
a1561 1
		ret = i915_gem_check_wedge(dev_priv, dev_priv->mm.interruptible);
d1571 1
a1571 1
	struct inteldrm_softc *dev_priv = ring->dev->dev_private;
d1580 4
a1583 2
	bus_space_set_region_4(dev_priv->bst, ring->bsh,
	    ring->tail, MI_NOOP, rem / 4);
d1597 2
a1598 2
	if (ring->outstanding_lazy_request) {
		ret = i915_add_request(ring, NULL, NULL);
d1617 1
a1617 1
	if (ring->outstanding_lazy_request)
d1620 31
a1650 1
	return i915_gem_get_seqno(ring->dev, &ring->outstanding_lazy_request);
a1656 1
	int n = 4*num_dwords;
d1659 6
a1664 1
	ret = i915_gem_check_wedge(dev_priv, dev_priv->mm.interruptible);
d1673 1
a1673 13
	if (unlikely(ring->tail + n > ring->effective_size)) {
		ret = intel_wrap_ring_buffer(ring);
		if (unlikely(ret))
			return ret;
	}

	if (unlikely(ring->space < n)) {
		ret = ring_wait_for_space(ring, n);
		if (unlikely(ret))
			return ret;
	}

	ring->space -= n;
d1698 1
a1698 1
void intel_ring_advance(struct intel_ring_buffer *ring)
d1702 11
a1712 4
	ring->tail &= ring->size - 1;
	if (dev_priv->stop_rings & intel_ring_flag(ring))
		return;
	ring->write_tail(ring, ring->tail);
a1714 1

d1748 2
a1749 2
static int gen6_ring_flush(struct intel_ring_buffer *ring,
			   u32 invalidate, u32 flush)
d1759 2
d1772 28
d1803 1
d1851 2
a1852 2
static int blt_ring_flush(struct intel_ring_buffer *ring,
			  u32 invalidate, u32 flush)
d1854 1
d1863 2
d1876 7
a1882 2
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, MI_NOOP);
d1884 4
d1905 9
a1913 3
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->irq_enable_mask = GT_USER_INTERRUPT;
d1915 1
d1917 8
a1924 5
		ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_RV;
		ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_RB;
		ring->signal_mbox[0] = GEN6_VRSYNC;
		ring->signal_mbox[1] = GEN6_BRSYNC;
d1929 1
d1932 2
a1933 1
		ring->irq_enable_mask = GT_USER_INTERRUPT | GT_PIPE_NOTIFY;
d1941 1
d1954 2
d1978 1
a1978 1
		ret = i915_gem_object_pin(obj, 0, true, false);
d1985 2
a1986 1
		ring->private = obj;
d2016 1
d2049 1
d2052 1
a2052 1
		ret = init_phys_hws_pga(ring);
d2069 1
a2069 1
	if (IS_GEN6(dev) || IS_GEN7(dev)) {
d2074 1
a2074 1
		ring->flush = gen6_ring_flush;
d2077 15
a2091 4
		ring->irq_enable_mask = GEN6_BSD_USER_INTERRUPT;
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
d2093 8
a2100 5
		ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_VR;
		ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_VB;
		ring->signal_mbox[0] = GEN6_RVSYNC;
		ring->signal_mbox[1] = GEN6_BVSYNC;
d2106 1
d2108 1
a2108 1
			ring->irq_enable_mask = GT_BSD_USER_INTERRUPT;
d2133 41
a2173 1
	ring->flush = blt_ring_flush;
d2176 14
a2189 4
	ring->irq_enable_mask = GEN6_BLITTER_USER_INTERRUPT;
	ring->irq_get = gen6_ring_get_irq;
	ring->irq_put = gen6_ring_put_irq;
	ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
d2191 8
a2198 5
	ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_BR;
	ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_BV;
	ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_INVALID;
	ring->signal_mbox[0] = GEN6_RBSYNC;
	ring->signal_mbox[1] = GEN6_VBSYNC;
a2239 10
}

void
intel_ring_emit(struct intel_ring_buffer *ring, uint32_t data)
{
	struct drm_device	*dev = ring->dev;
	struct inteldrm_softc	*dev_priv = dev->dev_private;
	bus_space_write_4(dev_priv->bst, ring->bsh,
	    ring->tail, data);
	ring->tail += 4;
@


1.28
log
@Add a few missing trace functions, and "use" them.  Add back the WATCH_GTT
code (that isn't actually compiled in).  Use dev_priv->dev in one more place
now that we have it, and add set_normalized_timespec() and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.27 2015/04/12 11:26:54 jsg Exp $	*/
a46 2
extern int ticks;

d1370 1
a1370 1
	end = ticks + 60 * hz;
d1393 1
a1393 1
	} while (!time_after(ticks, end));
@


1.27
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.26 2015/04/12 03:54:10 jsg Exp $	*/
d34 1
d1366 1
a1366 1
//	trace_i915_ring_wait_begin(ring);
d1378 1
a1378 1
//			trace_i915_ring_wait_end(ring);
d1396 1
a1396 1
//	trace_i915_ring_wait_end(ring);
d1888 1
a1888 1
//	trace_i915_gem_ring_flush(ring, 0, I915_GEM_GPU_DOMAINS);
d1908 1
a1908 1
//	trace_i915_gem_ring_flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);
@


1.26
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.25 2015/02/12 04:56:03 kettenis Exp $	*/
a366 1
	int retries;
d411 3
a413 8
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ_CTL(ring) & RING_VALID) != 0 &&
		    I915_READ_START(ring) == obj->gtt_offset &&
		    (I915_READ_HEAD(ring) & HEAD_ADDR) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
a890 1
		int retries;
d895 2
a896 6
		for (retries = 1000; retries > 0; retries--) {
			if ((I915_READ(reg) & INSTPM_SYNC_FLUSH) == 0)
				break;
			DELAY(1000);
		}
		if (retries == 0)
a1518 1
	int retries;
d1532 3
a1534 7
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &
		    GEN6_BSD_SLEEP_INDICATOR) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
@


1.25
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.24 2015/02/10 10:50:49 jsg Exp $	*/
d1205 1
a1205 1
//	init_waitqueue_head(&ring->irq_queue);
@


1.24
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.23 2014/12/17 06:58:10 guenther Exp $	*/
d886 1
a886 1
	} else if (IS_GEN6(dev)) {
@


1.23
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.22 2014/12/15 02:24:23 guenther Exp $	*/
d759 1
d764 1
a764 1
	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
	mtx_leave(&dev_priv->irq_lock);
d780 1
d782 1
a782 1
	mtx_enter(&dev_priv->irq_lock);
d788 1
a788 1
	mtx_leave(&dev_priv->irq_lock);
d796 1
d801 1
a801 1
	mtx_enter(&dev_priv->irq_lock);
d807 1
a807 1
	mtx_leave(&dev_priv->irq_lock);
d817 1
d819 1
a819 1
	mtx_enter(&dev_priv->irq_lock);
d825 1
a825 1
	mtx_leave(&dev_priv->irq_lock);
d833 1
d838 1
a838 1
	mtx_enter(&dev_priv->irq_lock);
d844 1
a844 1
	mtx_leave(&dev_priv->irq_lock);
d854 1
d856 1
a856 1
	mtx_enter(&dev_priv->irq_lock);
d862 1
a862 1
	mtx_leave(&dev_priv->irq_lock);
d953 1
d963 1
a963 1
	mtx_enter(&dev_priv->irq_lock);
d974 1
a974 1
	mtx_leave(&dev_priv->irq_lock);
d984 1
d986 1
a986 1
	mtx_enter(&dev_priv->irq_lock);
d996 1
a996 1
	mtx_leave(&dev_priv->irq_lock);
@


1.22
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.21 2014/11/16 12:31:00 deraadt Exp $	*/
d479 1
a479 1
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0));
d1126 1
a1126 1
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0));
@


1.21
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.20 2014/03/30 00:58:24 jsg Exp $	*/
d479 1
a479 1
	    PROT_READ | PROT_WRITE, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0));
d1126 1
a1126 1
	    PROT_READ | PROT_WRITE, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0));
@


1.20
log
@drm/i915: Add intel_ring_cachline_align()

From Ville Syrjala
0320c449d2a820ed2a1972e23d8f20f8024a5872 in ubuntu 3.8
753b1ad4a281b0663329409d410243e91825c323 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.19 2014/03/24 17:06:49 kettenis Exp $	*/
d478 2
a479 2
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW,
	    UVM_PROT_RW, UVM_INH_SHARE, UVM_ADV_RANDOM, 0));
d1125 2
a1126 2
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW,
	    UVM_PROT_RW, UVM_INH_SHARE, UVM_ADV_RANDOM, 0));
@


1.19
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.18 2014/02/01 09:32:05 jsg Exp $	*/
d1483 21
@


1.18
log
@drm/i915: Invalidate TLBs for the rings after a reset

From Chris Wilson
92e199c62a5d698a8e934aea8bcb4fb43968a290 in ubuntu 3.8
884020bf3d2a3787a1cc6df902e98e0eec60330b in mainline linux

While the original commit message mentions
https://bugs.freedesktop.org/show_bug.cgi?id=64725
which is a problem with hibernate mlarkin@@ says it neither
helps or hurts in his testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.17 2014/01/24 01:42:50 jsg Exp $	*/
d476 7
a482 7
        obj->base.uao->pgops->pgo_reference(obj->base.uao);
        if ((ret = uvm_map(kernel_map, (vaddr_t *)&pc->cpu_page,
            PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
            UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) != 0)
        if (ret != 0) {
                DRM_ERROR("Failed to map status page.\n");
                obj->base.uao->pgops->pgo_detach(obj->base.uao);
d484 1
a484 1
        }
d1124 3
a1126 3
	if ((ret = uvm_map(kernel_map, (vaddr_t *)&ring->status_page.page_addr,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) != 0)
@


1.17
log
@drm/i915: fix up ring cleanup for the i830/i845 CS tlb w/a

From Daniel Vetter
cf9f2fc81448a358349320311ccb25bb6016749f in ubuntu 3.8
aaf8a5167291b65e9116cb8736d862965b57c13a in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.16 2014/01/22 04:04:53 kettenis Exp $	*/
d888 17
@


1.16
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.15 2014/01/21 08:57:22 kettenis Exp $	*/
a504 3
	if (!ring->private)
		return;

a512 1
	ring->private = NULL;
d583 4
a586 1
	cleanup_pipe_control(ring);
@


1.15
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.14 2013/12/01 11:47:13 kettenis Exp $	*/
d1035 1
a1035 1
		intel_ring_emit(ring, (howmany(len, 4096) << 16) | 1024);
@


1.14
log
@Bring back the DRM_IOCTL_I915_GEM_WAIT diff now that I've figured out what
made it fail (WARN_ON() was evaluating its argument multiple times).
This time, also advertise support through I915_PARAM_HAS_WAIT_TIMEOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.13 2013/11/30 20:13:36 kettenis Exp $	*/
d457 1
a457 1
	pc = malloc(sizeof(*pc), M_DRM, M_WAITOK);
d495 1
a495 1
	free(pc, M_DRM);
d515 1
a515 1
	free(pc, M_DRM);
@


1.13
log
@Oops!  Only intended to commit the i915_dma.c changes in the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.11 2013/11/30 13:58:51 kettenis Exp $	*/
d764 1
a764 1
//	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
//	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
//	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
//	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
//	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
//	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
//	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
//	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
//	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
//	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
//	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
//	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
//	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
//	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
//	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.12
log
@Reorder some case statements to reduce the diffs with Linux.
@
text
@d764 1
a764 1
	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
	mtx_leave(&dev_priv->irq_lock);
@


1.11
log
@Enable some #ifdef'ed out SandyBridge-specific code that seems to work fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.10 2013/11/29 21:44:15 kettenis Exp $	*/
d764 1
a764 1
//	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
//	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
//	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
//	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
//	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
//	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
//	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
//	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
//	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
//	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
//	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
//	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
//	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
//	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
//	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.10
log
@Should be safe to allow intel_ring_wait_seqno() to be interrupted.
Reduces diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.9 2013/11/20 22:10:19 kettenis Exp $	*/
a550 1
#ifdef notyet
a566 1
#endif
@


1.9
log
@Eliminate some differences with the Linux code; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.8 2013/11/19 19:14:09 kettenis Exp $	*/
a1276 2
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	bool was_interruptible;
a1278 7
	/* XXX As we have not yet audited all the paths to check that
	 * they are ready for ERESTARTSYS from intel_ring_begin, do not
	 * allow us to be interruptible by a signal.
	 */
	was_interruptible = dev_priv->mm.interruptible;
	dev_priv->mm.interruptible = false;

a1279 1

a1281 2

	dev_priv->mm.interruptible = was_interruptible;
@


1.8
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.7 2013/11/19 15:08:04 jsg Exp $	*/
d1425 1
d1432 1
a1438 1
	
d1494 1
d1605 2
a1606 1
static int blt_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
@


1.7
log
@backout the DRM_IOCTL_I915_GEM_WAIT commit
it seems to leave X unuseable on resume on at least snb/ivb
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.6 2013/11/17 18:47:13 kettenis Exp $	*/
a469 7
	/*
	 * snooped gtt mapping please .
	 * Normally this flag is only to dmamem_map, but it's been overloaded
	 * for the agp mapping
	 */
        obj->dma_flags = BUS_DMA_COHERENT | BUS_DMA_READ;

a1101 7
	/*
	 * snooped gtt mapping please .
	 * Normally this flag is only to dmamem_map, but it's been overloaded
	 * for the agp mapping
	 */
	obj->dma_flags = BUS_DMA_COHERENT | BUS_DMA_READ;

a1162 5
	struct inteldrm_softc	*dev_priv = ring->dev->dev_private;
	struct drm_device	*dev = ring->dev;
	struct drm_i915_gem_object *obj_priv;
	bus_dma_tag_t		 tag;
	bus_dmamap_t		 map;
a1164 10
	if (I915_NEED_GFX_HWS(dev)) {
		obj_priv = ring->status_page.obj;
		map = obj_priv->dmamap;
		tag = dev_priv->agpdmat;
	} else {
		map = dev_priv->status_page_dmah->map;
		tag = dev->dmat;
	}
	/* Ensure that the compiler doesn't optimize away the load. */
	bus_dmamap_sync(tag, map, 0, PAGE_SIZE, BUS_DMASYNC_POSTREAD);
a1165 1
	bus_dmamap_sync(tag, map, 0, PAGE_SIZE, BUS_DMASYNC_PREREAD);
@


1.6
log
@Implement DRM_IOCTL_I915_GEM_WAIT.  Based on an earlier diff from jsg@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.5 2013/08/13 10:23:52 jsg Exp $	*/
d773 1
a773 1
	mtx_enter(&dev_priv->irq_lock);
d779 1
a779 1
	mtx_leave(&dev_priv->irq_lock);
d790 1
a790 1
	mtx_enter(&dev_priv->irq_lock);
d796 1
a796 1
	mtx_leave(&dev_priv->irq_lock);
d808 1
a808 1
	mtx_enter(&dev_priv->irq_lock);
d814 1
a814 1
	mtx_leave(&dev_priv->irq_lock);
d825 1
a825 1
	mtx_enter(&dev_priv->irq_lock);
d831 1
a831 1
	mtx_leave(&dev_priv->irq_lock);
d843 1
a843 1
	mtx_enter(&dev_priv->irq_lock);
d849 1
a849 1
	mtx_leave(&dev_priv->irq_lock);
d860 1
a860 1
	mtx_enter(&dev_priv->irq_lock);
d866 1
a866 1
	mtx_leave(&dev_priv->irq_lock);
d949 1
a949 1
	mtx_enter(&dev_priv->irq_lock);
d960 1
a960 1
	mtx_leave(&dev_priv->irq_lock);
d971 1
a971 1
	mtx_enter(&dev_priv->irq_lock);
d981 1
a981 1
	mtx_leave(&dev_priv->irq_lock);
@


1.5
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.4 2013/07/05 07:20:27 jsg Exp $	*/
d773 1
a773 1
//	mtx_enter(&dev_priv->irq_lock);
d779 1
a779 1
//	mtx_leave(&dev_priv->irq_lock);
d790 1
a790 1
//	mtx_enter(&dev_priv->irq_lock);
d796 1
a796 1
//	mtx_leave(&dev_priv->irq_lock);
d808 1
a808 1
//	mtx_enter(&dev_priv->irq_lock);
d814 1
a814 1
//	mtx_leave(&dev_priv->irq_lock);
d825 1
a825 1
//	mtx_enter(&dev_priv->irq_lock);
d831 1
a831 1
//	mtx_leave(&dev_priv->irq_lock);
d843 1
a843 1
//	mtx_enter(&dev_priv->irq_lock);
d849 1
a849 1
//	mtx_leave(&dev_priv->irq_lock);
d860 1
a860 1
//	mtx_enter(&dev_priv->irq_lock);
d866 1
a866 1
//	mtx_leave(&dev_priv->irq_lock);
d949 1
a949 1
//	mtx_enter(&dev_priv->irq_lock);
d960 1
a960 1
//	mtx_leave(&dev_priv->irq_lock);
d971 1
a971 1
//	mtx_enter(&dev_priv->irq_lock);
d981 1
a981 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.4
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.3 2013/05/05 13:55:36 kettenis Exp $	*/
a45 52
int	 gen2_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen4_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen6_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen7_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 intel_emit_post_sync_nonzero_flush(struct intel_ring_buffer *);
int	 gen7_render_ring_cs_stall_wa(struct intel_ring_buffer *);
void	 ring_write_tail(struct intel_ring_buffer *, u32);
int	 init_pipe_control(struct intel_ring_buffer *);
void	 cleanup_pipe_control(struct intel_ring_buffer *);
int	 init_render_ring(struct intel_ring_buffer *);
void	 render_ring_cleanup(struct intel_ring_buffer *);
void	 update_mboxes(struct intel_ring_buffer *, u32);
int	 gen6_add_request(struct intel_ring_buffer *);
int	 gen6_ring_sync(struct intel_ring_buffer *, struct intel_ring_buffer *,
	     u32);
int	 pc_render_add_request(struct intel_ring_buffer *);
u32	 gen6_ring_get_seqno(struct intel_ring_buffer *, bool);
u32	 ring_get_seqno(struct intel_ring_buffer *, bool);
u32	 pc_render_get_seqno(struct intel_ring_buffer *, bool);
bool	 gen5_ring_get_irq(struct intel_ring_buffer *);
void	 gen5_ring_put_irq(struct intel_ring_buffer *);
bool	 i9xx_ring_get_irq(struct intel_ring_buffer *);
void	 i9xx_ring_put_irq(struct intel_ring_buffer *);
bool	 i8xx_ring_get_irq(struct intel_ring_buffer *);
void	 i8xx_ring_put_irq(struct intel_ring_buffer *);
int	 bsd_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 i9xx_add_request(struct intel_ring_buffer *);
bool	 gen6_ring_get_irq(struct intel_ring_buffer *);
void	 gen6_ring_put_irq(struct intel_ring_buffer *);
int	 i830_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 i915_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 i965_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 init_status_page(struct intel_ring_buffer *);
int	 init_phys_hws_pga(struct intel_ring_buffer *);
int	 intel_ring_idle(struct intel_ring_buffer *);
int	 intel_ring_wait_seqno(struct intel_ring_buffer *, u32);
int	 intel_ring_wait_request(struct intel_ring_buffer *, int);
int	 intel_wrap_ring_buffer(struct intel_ring_buffer *);
int	 intel_ring_alloc_seqno(struct intel_ring_buffer *);
void	 gen6_bsd_ring_write_tail(struct intel_ring_buffer *, u32);
int	 gen6_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen6_ring_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 hsw_ring_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 blt_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 intel_ring_flush_all_caches(struct intel_ring_buffer *);
int	 intel_ring_invalidate_all_caches(struct intel_ring_buffer *);

d48 1
a48 2
static inline int
ring_space(struct intel_ring_buffer *ring)
d56 1
a56 1
int
d82 1
a82 1
int
d177 1
a177 1
int
d213 1
a213 1
int
d266 1
a266 1
int
d285 1
a285 1
int
d344 2
a345 2
void
ring_write_tail(struct intel_ring_buffer *ring, u32 value)
d351 1
a351 2
u32
intel_ring_get_active_head(struct intel_ring_buffer *ring)
d360 1
a360 2
int
init_ring_common(struct intel_ring_buffer *ring)
d447 1
a447 1
int
d506 1
a506 1
void
d526 1
a526 2
int
init_render_ring(struct intel_ring_buffer *ring)
d586 1
a586 2
void
render_ring_cleanup(struct intel_ring_buffer *ring)
d599 1
a599 1
void
d617 1
a617 1
int
d649 1
a649 1
int
d691 1
a691 1
int
d740 1
a740 1
u32
d751 1
a751 1
u32
d757 1
a757 1
u32
d764 1
a764 1
bool
d784 1
a784 1
void
d799 1
a799 1
bool
d819 1
a819 1
void
d834 1
a834 1
bool
d854 1
a854 1
void
d869 1
a869 2
void
intel_ring_setup_status_page(struct intel_ring_buffer *ring)
d900 1
a900 1
int
d917 1
a917 1
int
d935 1
a935 1
bool
d965 1
a965 1
void
d986 1
a986 1
int
d1009 1
a1009 1
int
d1061 1
a1061 1
int
d1079 1
a1079 2
void
cleanup_status_page(struct intel_ring_buffer *ring)
d1094 1
a1094 2
int
init_status_page(struct intel_ring_buffer *ring)
d1149 1
a1149 2
int
init_phys_hws_pga(struct intel_ring_buffer *ring)
d1200 1
a1200 2
int
intel_init_ring_buffer(struct drm_device *dev,
d1276 1
a1276 2
void
intel_cleanup_ring_buffer(struct intel_ring_buffer *ring)
d1305 1
a1305 2
int
intel_ring_wait_seqno(struct intel_ring_buffer *ring, u32 seqno)
d1328 1
a1328 2
int
intel_ring_wait_request(struct intel_ring_buffer *ring, int n)
d1385 1
a1385 2
int
ring_wait_for_space(struct intel_ring_buffer *ring, int n)
d1430 1
a1430 2
int
intel_wrap_ring_buffer(struct intel_ring_buffer *ring)
d1450 1
a1450 2
int
intel_ring_idle(struct intel_ring_buffer *ring)
d1472 1
a1472 1
int
d1481 2
a1482 2
int
intel_ring_begin(struct intel_ring_buffer *ring, int num_dwords)
d1513 1
a1513 2
void
intel_ring_advance(struct intel_ring_buffer *ring)
d1523 2
a1524 2
void
gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring, u32 value)
d1561 2
a1562 2
int
gen6_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
d1589 1
a1589 1
int
d1610 1
a1610 1
int
d1633 1
a1633 2
int
blt_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
d1660 1
a1660 2
int
intel_init_render_ring_buffer(struct drm_device *dev)
d1745 1
a1745 2
int
intel_render_ring_init_dri(struct drm_device *dev, u64 start, u32 size)
d1811 1
a1811 2
int
intel_init_bsd_ring_buffer(struct drm_device *dev)
d1859 1
a1859 2
int
intel_init_blt_ring_buffer(struct drm_device *dev)
@


1.3
log
@Add nonblocking argument to i915_gem_object_pin() and
i915_gem_object_bind_to_gtt().
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.2 2013/04/17 20:04:05 kettenis Exp $	*/
d585 1
a585 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1212 1
a1212 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
d1266 1
a1266 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1341 1
a1341 1
	drm_i915_private_t *dev_priv;
d1454 1
a1454 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1584 1
a1584 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
@


1.2
log
@Another round of reducing diffs with Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d532 1
a532 1
	ret = i915_gem_object_pin(obj, 4096, true);
d1176 1
a1176 1
	ret = i915_gem_object_pin(obj, 4096, true);
d1297 1
a1297 1
	ret = i915_gem_object_pin(obj, PAGE_SIZE, true);
d1803 1
a1803 1
		ret = i915_gem_object_pin(obj, 0, true);
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1734 1
a1734 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d1820 1
a1820 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d1887 1
a1887 1
	struct intel_ring_buffer *ring = &dev_priv->rings[VCS];
d1936 1
a1936 1
	struct intel_ring_buffer *ring = &dev_priv->rings[BCS];
@

