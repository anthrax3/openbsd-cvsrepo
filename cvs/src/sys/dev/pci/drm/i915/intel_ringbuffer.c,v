head	1.33;
access;
symbols
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.25.0.4
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.33
date	2017.07.19.22.05.58;	author kettenis;	state Exp;
branches;
next	1.32;
commitid	e9Q72NCdXpHdLN3j;

1.32
date	2017.07.01.16.14.10;	author kettenis;	state Exp;
branches;
next	1.31;
commitid	KnwRPOZok9A30HI4;

1.31
date	2015.09.25.16.15.19;	author jsg;	state Exp;
branches;
next	1.30;
commitid	qBczsgFZrSbAS824;

1.30
date	2015.09.23.23.12.12;	author kettenis;	state Exp;
branches;
next	1.29;
commitid	lQlppvmETCN49oZe;

1.29
date	2015.06.24.17.59.42;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	3wz7SV1D1yJbfWE9;

1.28
date	2015.04.12.17.10.07;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	7RIU3AxWXbuzxDet;

1.27
date	2015.04.12.11.26.54;	author jsg;	state Exp;
branches;
next	1.26;
commitid	syZU9J25izIJ2cm1;

1.26
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.25;
commitid	uVTyY1h8Sggc8pFj;

1.25
date	2015.02.12.04.56.03;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	adfbJ0ccUTdhFGhI;

1.24
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.23;
commitid	aHLMSW1RfE1rmMw9;

1.23
date	2014.12.17.06.58.10;	author guenther;	state Exp;
branches;
next	1.22;
commitid	DImukoCWyTxwdbuh;

1.22
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.21;
commitid	ZxaujiOM0aYQRjFY;

1.21
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	yv0ECmCdICvq576h;

1.20
date	2014.03.30.00.58.24;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.24.17.06.49;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.01.09.32.05;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.24.01.42.50;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.22.04.04.53;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.21.08.57.22;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2013.12.01.11.47.13;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.30.20.13.36;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2013.11.30.20.03.32;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.11.30.13.58.51;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.29.21.44.15;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2013.11.20.22.10.19;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2013.11.19.19.14.09;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.11.19.15.08.04;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.11.17.18.47.13;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.13.10.23.52;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2013.07.05.07.20.27;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.05.05.13.55.36;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.17.20.04.05;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.52;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Implement drm_pci_alloc() and drm_pci_free() and use them to reduce the
diffs with Linux.
@
text
@/*
 * Copyright Â© 2008-2010 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Authors:
 *    Eric Anholt <eric@@anholt.net>
 *    Zou Nan hai <nanhai.zou@@intel.com>
 *    Xiang Hai hao<haihao.xiang@@intel.com>
 *
 */

#include <dev/pci/drm/drmP.h>
#include "i915_drv.h"
#include <dev/pci/drm/i915_drm.h>
#include "i915_trace.h"
#include "intel_drv.h"

bool
intel_ring_initialized(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;

	if (!dev)
		return false;

	if (i915.enable_execlists) {
		struct intel_context *dctx = ring->default_context;
		struct intel_ringbuffer *ringbuf = dctx->engine[ring->id].ringbuf;

		return ringbuf->obj;
	} else
		return ring->buffer && ring->buffer->obj;
}

int __intel_ring_space(int head, int tail, int size)
{
	int space = head - tail;
	if (space <= 0)
		space += size;
	return space - I915_RING_FREE_SPACE;
}

void intel_ring_update_space(struct intel_ringbuffer *ringbuf)
{
	if (ringbuf->last_retired_head != -1) {
		ringbuf->head = ringbuf->last_retired_head;
		ringbuf->last_retired_head = -1;
	}

	ringbuf->space = __intel_ring_space(ringbuf->head & HEAD_ADDR,
					    ringbuf->tail, ringbuf->size);
}

int intel_ring_space(struct intel_ringbuffer *ringbuf)
{
	intel_ring_update_space(ringbuf);
	return ringbuf->space;
}

bool intel_ring_stopped(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	return dev_priv->gpu_error.stop_rings & intel_ring_flag(ring);
}

static void __intel_ring_advance(struct intel_engine_cs *ring)
{
	struct intel_ringbuffer *ringbuf = ring->buffer;
	ringbuf->tail &= ringbuf->size - 1;
	if (intel_ring_stopped(ring))
		return;
	ring->write_tail(ring, ringbuf->tail);
}

static int
gen2_render_ring_flush(struct drm_i915_gem_request *req,
		       u32	invalidate_domains,
		       u32	flush_domains)
{
	struct intel_engine_cs *ring = req->ring;
	u32 cmd;
	int ret;

	cmd = MI_FLUSH;
	if (((invalidate_domains|flush_domains) & I915_GEM_DOMAIN_RENDER) == 0)
		cmd |= MI_NO_WRITE_FLUSH;

	if (invalidate_domains & I915_GEM_DOMAIN_SAMPLER)
		cmd |= MI_READ_FLUSH;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
gen4_render_ring_flush(struct drm_i915_gem_request *req,
		       u32	invalidate_domains,
		       u32	flush_domains)
{
	struct intel_engine_cs *ring = req->ring;
	struct drm_device *dev = ring->dev;
	u32 cmd;
	int ret;

	/*
	 * read/write caches:
	 *
	 * I915_GEM_DOMAIN_RENDER is always invalidated, but is
	 * only flushed if MI_NO_WRITE_FLUSH is unset.  On 965, it is
	 * also flushed at 2d versus 3d pipeline switches.
	 *
	 * read-only caches:
	 *
	 * I915_GEM_DOMAIN_SAMPLER is flushed on pre-965 if
	 * MI_READ_FLUSH is set, and is always flushed on 965.
	 *
	 * I915_GEM_DOMAIN_COMMAND may not exist?
	 *
	 * I915_GEM_DOMAIN_INSTRUCTION, which exists on 965, is
	 * invalidated when MI_EXE_FLUSH is set.
	 *
	 * I915_GEM_DOMAIN_VERTEX, which exists on 965, is
	 * invalidated with every MI_FLUSH.
	 *
	 * TLBs:
	 *
	 * On 965, TLBs associated with I915_GEM_DOMAIN_COMMAND
	 * and I915_GEM_DOMAIN_CPU in are invalidated at PTE write and
	 * I915_GEM_DOMAIN_RENDER and I915_GEM_DOMAIN_SAMPLER
	 * are flushed at any MI_FLUSH.
	 */

	cmd = MI_FLUSH | MI_NO_WRITE_FLUSH;
	if ((invalidate_domains|flush_domains) & I915_GEM_DOMAIN_RENDER)
		cmd &= ~MI_NO_WRITE_FLUSH;
	if (invalidate_domains & I915_GEM_DOMAIN_INSTRUCTION)
		cmd |= MI_EXE_FLUSH;

	if (invalidate_domains & I915_GEM_DOMAIN_COMMAND &&
	    (IS_G4X(dev) || IS_GEN5(dev)))
		cmd |= MI_INVALIDATE_ISP;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

/**
 * Emits a PIPE_CONTROL with a non-zero post-sync operation, for
 * implementing two workarounds on gen6.  From section 1.4.7.1
 * "PIPE_CONTROL" of the Sandy Bridge PRM volume 2 part 1:
 *
 * [DevSNB-C+{W/A}] Before any depth stall flush (including those
 * produced by non-pipelined state commands), software needs to first
 * send a PIPE_CONTROL with no bits set except Post-Sync Operation !=
 * 0.
 *
 * [Dev-SNB{W/A}]: Before a PIPE_CONTROL with Write Cache Flush Enable
 * =1, a PIPE_CONTROL with any non-zero post-sync-op is required.
 *
 * And the workaround for these two requires this workaround first:
 *
 * [Dev-SNB{W/A}]: Pipe-control with CS-stall bit set must be sent
 * BEFORE the pipe-control with a post-sync op and no write-cache
 * flushes.
 *
 * And this last workaround is tricky because of the requirements on
 * that bit.  From section 1.4.7.2.3 "Stall" of the Sandy Bridge PRM
 * volume 2 part 1:
 *
 *     "1 of the following must also be set:
 *      - Render Target Cache Flush Enable ([12] of DW1)
 *      - Depth Cache Flush Enable ([0] of DW1)
 *      - Stall at Pixel Scoreboard ([1] of DW1)
 *      - Depth Stall ([13] of DW1)
 *      - Post-Sync Operation ([13] of DW1)
 *      - Notify Enable ([8] of DW1)"
 *
 * The cache flushes require the workaround flush that triggered this
 * one, so we can't use it.  Depth stall would trigger the same.
 * Post-sync nonzero is what triggered this second workaround, so we
 * can't use that one either.  Notify enable is IRQs, which aren't
 * really our business.  That leaves only stall at scoreboard.
 */
static int
intel_emit_post_sync_nonzero_flush(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	u32 scratch_addr = ring->scratch.gtt_offset + 2 * CACHELINE_BYTES;
	int ret;

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(5));
	intel_ring_emit(ring, PIPE_CONTROL_CS_STALL |
			PIPE_CONTROL_STALL_AT_SCOREBOARD);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT); /* address */
	intel_ring_emit(ring, 0); /* low dword */
	intel_ring_emit(ring, 0); /* high dword */
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(5));
	intel_ring_emit(ring, PIPE_CONTROL_QW_WRITE);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT); /* address */
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
gen6_render_ring_flush(struct drm_i915_gem_request *req,
		       u32 invalidate_domains, u32 flush_domains)
{
	struct intel_engine_cs *ring = req->ring;
	u32 flags = 0;
	u32 scratch_addr = ring->scratch.gtt_offset + 2 * CACHELINE_BYTES;
	int ret;

	/* Force SNB workarounds for PIPE_CONTROL flushes */
	ret = intel_emit_post_sync_nonzero_flush(req);
	if (ret)
		return ret;

	/* Just flush everything.  Experiments have shown that reducing the
	 * number of bits based on the write domains has little performance
	 * impact.
	 */
	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
		/*
		 * Ensure that any following seqno writes only happen
		 * when the render cache is indeed flushed.
		 */
		flags |= PIPE_CONTROL_CS_STALL;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		/*
		 * TLB invalidate requires a post-sync write.
		 */
		flags |= PIPE_CONTROL_QW_WRITE | PIPE_CONTROL_CS_STALL;
	}

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int
gen7_render_ring_cs_stall_wa(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, PIPE_CONTROL_CS_STALL |
			      PIPE_CONTROL_STALL_AT_SCOREBOARD);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int
gen7_render_ring_flush(struct drm_i915_gem_request *req,
		       u32 invalidate_domains, u32 flush_domains)
{
	struct intel_engine_cs *ring = req->ring;
	u32 flags = 0;
	u32 scratch_addr = ring->scratch.gtt_offset + 2 * CACHELINE_BYTES;
	int ret;

	/*
	 * Ensure that any following seqno writes only happen when the render
	 * cache is indeed flushed.
	 *
	 * Workaround: 4th PIPE_CONTROL command (except the ones with only
	 * read-cache invalidate bits set) must have the CS_STALL bit set. We
	 * don't try to be clever and just set it unconditionally.
	 */
	flags |= PIPE_CONTROL_CS_STALL;

	/* Just flush everything.  Experiments have shown that reducing the
	 * number of bits based on the write domains has little performance
	 * impact.
	 */
	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
		flags |= PIPE_CONTROL_FLUSH_ENABLE;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_MEDIA_STATE_CLEAR;
		/*
		 * TLB invalidate requires a post-sync write.
		 */
		flags |= PIPE_CONTROL_QW_WRITE;
		flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;

		flags |= PIPE_CONTROL_STALL_AT_SCOREBOARD;

		/* Workaround: we must issue a pipe_control with CS-stall bit
		 * set before a pipe_control command that has the state cache
		 * invalidate bit set. */
		gen7_render_ring_cs_stall_wa(req);
	}

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int
gen8_emit_pipe_control(struct drm_i915_gem_request *req,
		       u32 flags, u32 scratch_addr)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(6));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;
}

static int
gen8_render_ring_flush(struct drm_i915_gem_request *req,
		       u32 invalidate_domains, u32 flush_domains)
{
	u32 flags = 0;
	u32 scratch_addr = req->ring->scratch.gtt_offset + 2 * CACHELINE_BYTES;
	int ret;

	flags |= PIPE_CONTROL_CS_STALL;

	if (flush_domains) {
		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
		flags |= PIPE_CONTROL_FLUSH_ENABLE;
	}
	if (invalidate_domains) {
		flags |= PIPE_CONTROL_TLB_INVALIDATE;
		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
		flags |= PIPE_CONTROL_QW_WRITE;
		flags |= PIPE_CONTROL_GLOBAL_GTT_IVB;

		/* WaCsStallBeforeStateCacheInvalidate:bdw,chv */
		ret = gen8_emit_pipe_control(req,
					     PIPE_CONTROL_CS_STALL |
					     PIPE_CONTROL_STALL_AT_SCOREBOARD,
					     0);
		if (ret)
			return ret;
	}

	return gen8_emit_pipe_control(req, flags, scratch_addr);
}

static void ring_write_tail(struct intel_engine_cs *ring,
			    u32 value)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	I915_WRITE_TAIL(ring, value);
}

u64 intel_ring_get_active_head(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	u64 acthd;

	if (INTEL_INFO(ring->dev)->gen >= 8)
		acthd = I915_READ64_2x32(RING_ACTHD(ring->mmio_base),
					 RING_ACTHD_UDW(ring->mmio_base));
	else if (INTEL_INFO(ring->dev)->gen >= 4)
		acthd = I915_READ(RING_ACTHD(ring->mmio_base));
	else
		acthd = I915_READ(ACTHD);

	return acthd;
}

static void ring_setup_phys_status_page(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	u32 addr;

	addr = dev_priv->status_page_dmah->busaddr;
	if (INTEL_INFO(ring->dev)->gen >= 4)
		addr |= (dev_priv->status_page_dmah->busaddr >> 28) & 0xf0;
	I915_WRITE(HWS_PGA, addr);
}

static void intel_ring_setup_status_page(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	u32 mmio = 0;

	/* The ring status page addresses are no longer next to the rest of
	 * the ring registers as of gen7.
	 */
	if (IS_GEN7(dev)) {
		switch (ring->id) {
		case RCS:
			mmio = RENDER_HWS_PGA_GEN7;
			break;
		case BCS:
			mmio = BLT_HWS_PGA_GEN7;
			break;
		/*
		 * VCS2 actually doesn't exist on Gen7. Only shut up
		 * gcc switch check warning
		 */
		case VCS2:
		case VCS:
			mmio = BSD_HWS_PGA_GEN7;
			break;
		case VECS:
			mmio = VEBOX_HWS_PGA_GEN7;
			break;
		}
	} else if (IS_GEN6(ring->dev)) {
		mmio = RING_HWS_PGA_GEN6(ring->mmio_base);
	} else {
		/* XXX: gen8 returns to sanity */
		mmio = RING_HWS_PGA(ring->mmio_base);
	}

	I915_WRITE(mmio, (u32)ring->status_page.gfx_addr);
	POSTING_READ(mmio);

	/*
	 * Flush the TLB for this page
	 *
	 * FIXME: These two bits have disappeared on gen8, so a question
	 * arises: do we still need this and if so how should we go about
	 * invalidating the TLB?
	 */
	if (INTEL_INFO(dev)->gen >= 6 && INTEL_INFO(dev)->gen < 8) {
		u32 reg = RING_INSTPM(ring->mmio_base);

		/* ring should be idle before issuing a sync flush*/
		WARN_ON((I915_READ_MODE(ring) & MODE_IDLE) == 0);

		I915_WRITE(reg,
			   _MASKED_BIT_ENABLE(INSTPM_TLB_INVALIDATE |
					      INSTPM_SYNC_FLUSH));
		if (wait_for((I915_READ(reg) & INSTPM_SYNC_FLUSH) == 0,
			     1000))
			DRM_ERROR("%s: wait for SyncFlush to complete for TLB invalidation timed out\n",
				  ring->name);
	}
}

static bool stop_ring(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = to_i915(ring->dev);

	if (!IS_GEN2(ring->dev)) {
		I915_WRITE_MODE(ring, _MASKED_BIT_ENABLE(STOP_RING));
		if (wait_for((I915_READ_MODE(ring) & MODE_IDLE) != 0, 1000)) {
			DRM_ERROR("%s : timed out trying to stop ring\n", ring->name);
			/* Sometimes we observe that the idle flag is not
			 * set even though the ring is empty. So double
			 * check before giving up.
			 */
			if (I915_READ_HEAD(ring) != I915_READ_TAIL(ring))
				return false;
		}
	}

	I915_WRITE_CTL(ring, 0);
	I915_WRITE_HEAD(ring, 0);
	ring->write_tail(ring, 0);

	if (!IS_GEN2(ring->dev)) {
		(void)I915_READ_CTL(ring);
		I915_WRITE_MODE(ring, _MASKED_BIT_DISABLE(STOP_RING));
	}

	return (I915_READ_HEAD(ring) & HEAD_ADDR) == 0;
}

static int init_ring_common(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ringbuffer *ringbuf = ring->buffer;
	struct drm_i915_gem_object *obj = ringbuf->obj;
	int ret = 0;

	intel_uncore_forcewake_get(dev_priv, FORCEWAKE_ALL);

	if (!stop_ring(ring)) {
		/* G45 ring initialization often fails to reset head to zero */
		DRM_DEBUG_KMS("%s head not reset to zero "
			      "ctl %08x head %08x tail %08x start %08x\n",
			      ring->name,
			      I915_READ_CTL(ring),
			      I915_READ_HEAD(ring),
			      I915_READ_TAIL(ring),
			      I915_READ_START(ring));

		if (!stop_ring(ring)) {
			DRM_ERROR("failed to set %s head to zero "
				  "ctl %08x head %08x tail %08x start %08x\n",
				  ring->name,
				  I915_READ_CTL(ring),
				  I915_READ_HEAD(ring),
				  I915_READ_TAIL(ring),
				  I915_READ_START(ring));
			ret = -EIO;
			goto out;
		}
	}

	if (I915_NEED_GFX_HWS(dev))
		intel_ring_setup_status_page(ring);
	else
		ring_setup_phys_status_page(ring);

	/* Enforce ordering by reading HEAD register back */
	I915_READ_HEAD(ring);

	/* Initialize the ring. This must happen _after_ we've cleared the ring
	 * registers with the above sequence (the readback of the HEAD registers
	 * also enforces ordering), otherwise the hw might lose the new ring
	 * register values. */
	I915_WRITE_START(ring, i915_gem_obj_ggtt_offset(obj));

	/* WaClearRingBufHeadRegAtInit:ctg,elk */
	if (I915_READ_HEAD(ring))
		DRM_DEBUG("%s initialization failed [head=%08x], fudging\n",
			  ring->name, I915_READ_HEAD(ring));
	I915_WRITE_HEAD(ring, 0);
	(void)I915_READ_HEAD(ring);

	I915_WRITE_CTL(ring,
			((ringbuf->size - PAGE_SIZE) & RING_NR_PAGES)
			| RING_VALID);

	/* If the head is still not zero, the ring is dead */
	if (wait_for((I915_READ_CTL(ring) & RING_VALID) != 0 &&
		     I915_READ_START(ring) == i915_gem_obj_ggtt_offset(obj) &&
		     (I915_READ_HEAD(ring) & HEAD_ADDR) == 0, 50)) {
		DRM_ERROR("%s initialization failed "
			  "ctl %08x (valid? %d) head %08x tail %08x start %08x [expected %08lx]\n",
			  ring->name,
			  I915_READ_CTL(ring), I915_READ_CTL(ring) & RING_VALID,
			  I915_READ_HEAD(ring), I915_READ_TAIL(ring),
			  I915_READ_START(ring), (unsigned long)i915_gem_obj_ggtt_offset(obj));
		ret = -EIO;
		goto out;
	}

	ringbuf->last_retired_head = -1;
	ringbuf->head = I915_READ_HEAD(ring);
	ringbuf->tail = I915_READ_TAIL(ring) & TAIL_ADDR;
	intel_ring_update_space(ringbuf);

	memset(&ring->hangcheck, 0, sizeof(ring->hangcheck));

out:
	intel_uncore_forcewake_put(dev_priv, FORCEWAKE_ALL);

	return ret;
}

void
intel_fini_pipe_control(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;

	if (ring->scratch.obj == NULL)
		return;

	if (INTEL_INFO(dev)->gen >= 5) {
		kunmap(sg_page(ring->scratch.obj->pages->sgl));
		i915_gem_object_ggtt_unpin(ring->scratch.obj);
	}

	drm_gem_object_unreference(&ring->scratch.obj->base);
	ring->scratch.obj = NULL;
}

int
intel_init_pipe_control(struct intel_engine_cs *ring)
{
	int ret;

	WARN_ON(ring->scratch.obj);

	ring->scratch.obj = i915_gem_alloc_object(ring->dev, 4096);
	if (ring->scratch.obj == NULL) {
		DRM_ERROR("Failed to allocate seqno page\n");
		ret = -ENOMEM;
		goto err;
	}

	ret = i915_gem_object_set_cache_level(ring->scratch.obj, I915_CACHE_LLC);
	if (ret)
		goto err_unref;

	ret = i915_gem_obj_ggtt_pin(ring->scratch.obj, 4096, 0);
	if (ret)
		goto err_unref;

	ring->scratch.gtt_offset = i915_gem_obj_ggtt_offset(ring->scratch.obj);
	ring->scratch.cpu_page = kmap(sg_page(ring->scratch.obj->pages->sgl));
	if (ring->scratch.cpu_page == NULL) {
		ret = -ENOMEM;
		goto err_unpin;
	}

	DRM_DEBUG_DRIVER("%s pipe control offset: 0x%08x\n",
			 ring->name, ring->scratch.gtt_offset);
	return 0;

err_unpin:
	i915_gem_object_ggtt_unpin(ring->scratch.obj);
err_unref:
	drm_gem_object_unreference(&ring->scratch.obj->base);
err:
	return ret;
}

static int intel_ring_workarounds_emit(struct drm_i915_gem_request *req)
{
	int ret, i;
	struct intel_engine_cs *ring = req->ring;
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct i915_workarounds *w = &dev_priv->workarounds;

	if (w->count == 0)
		return 0;

	ring->gpu_caches_dirty = true;
	ret = intel_ring_flush_all_caches(req);
	if (ret)
		return ret;

	ret = intel_ring_begin(req, (w->count * 2 + 2));
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(w->count));
	for (i = 0; i < w->count; i++) {
		intel_ring_emit(ring, w->reg[i].addr);
		intel_ring_emit(ring, w->reg[i].value);
	}
	intel_ring_emit(ring, MI_NOOP);

	intel_ring_advance(ring);

	ring->gpu_caches_dirty = true;
	ret = intel_ring_flush_all_caches(req);
	if (ret)
		return ret;

	DRM_DEBUG_DRIVER("Number of Workarounds emitted: %d\n", w->count);

	return 0;
}

static int intel_rcs_ctx_init(struct drm_i915_gem_request *req)
{
	int ret;

	ret = intel_ring_workarounds_emit(req);
	if (ret != 0)
		return ret;

	ret = i915_gem_render_state_init(req);
	if (ret)
		DRM_ERROR("init render state: %d\n", ret);

	return ret;
}

static int wa_add(struct drm_i915_private *dev_priv,
		  const u32 addr, const u32 mask, const u32 val)
{
	const u32 idx = dev_priv->workarounds.count;

	if (WARN_ON(idx >= I915_MAX_WA_REGS))
		return -ENOSPC;

	dev_priv->workarounds.reg[idx].addr = addr;
	dev_priv->workarounds.reg[idx].value = val;
	dev_priv->workarounds.reg[idx].mask = mask;

	dev_priv->workarounds.count++;

	return 0;
}

#define WA_REG(addr, mask, val) do { \
		const int r = wa_add(dev_priv, (addr), (mask), (val)); \
		if (r) \
			return r; \
	} while (0)

#define WA_SET_BIT_MASKED(addr, mask) \
	WA_REG(addr, (mask), _MASKED_BIT_ENABLE(mask))

#define WA_CLR_BIT_MASKED(addr, mask) \
	WA_REG(addr, (mask), _MASKED_BIT_DISABLE(mask))

#define WA_SET_FIELD_MASKED(addr, mask, value) \
	WA_REG(addr, mask, _MASKED_FIELD(mask, value))

#define WA_SET_BIT(addr, mask) WA_REG(addr, mask, I915_READ(addr) | (mask))
#define WA_CLR_BIT(addr, mask) WA_REG(addr, mask, I915_READ(addr) & ~(mask))

#define WA_WRITE(addr, val) WA_REG(addr, 0xffffffff, val)

static int gen8_init_workarounds(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	WA_SET_BIT_MASKED(INSTPM, INSTPM_FORCE_ORDERING);

	/* WaDisableAsyncFlipPerfMode:bdw,chv */
	WA_SET_BIT_MASKED(MI_MODE, ASYNC_FLIP_PERF_DISABLE);

	/* WaDisablePartialInstShootdown:bdw,chv */
	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN,
			  PARTIAL_INSTRUCTION_SHOOTDOWN_DISABLE);

	/* Use Force Non-Coherent whenever executing a 3D context. This is a
	 * workaround for for a possible hang in the unlikely event a TLB
	 * invalidation occurs during a PSD flush.
	 */
	/* WaForceEnableNonCoherent:bdw,chv */
	/* WaHdcDisableFetchWhenMasked:bdw,chv */
	WA_SET_BIT_MASKED(HDC_CHICKEN0,
			  HDC_DONOT_FETCH_MEM_WHEN_MASKED |
			  HDC_FORCE_NON_COHERENT);

	/* From the Haswell PRM, Command Reference: Registers, CACHE_MODE_0:
	 * "The Hierarchical Z RAW Stall Optimization allows non-overlapping
	 *  polygons in the same 8x4 pixel/sample area to be processed without
	 *  stalling waiting for the earlier ones to write to Hierarchical Z
	 *  buffer."
	 *
	 * This optimization is off by default for BDW and CHV; turn it on.
	 */
	WA_CLR_BIT_MASKED(CACHE_MODE_0_GEN7, HIZ_RAW_STALL_OPT_DISABLE);

	/* Wa4x4STCOptimizationDisable:bdw,chv */
	WA_SET_BIT_MASKED(CACHE_MODE_1, GEN8_4x4_STC_OPTIMIZATION_DISABLE);

	/*
	 * BSpec recommends 8x4 when MSAA is used,
	 * however in practice 16x4 seems fastest.
	 *
	 * Note that PS/WM thread counts depend on the WIZ hashing
	 * disable bit, which we don't touch here, but it's good
	 * to keep in mind (see 3DSTATE_PS and 3DSTATE_WM).
	 */
	WA_SET_FIELD_MASKED(GEN7_GT_MODE,
			    GEN6_WIZ_HASHING_MASK,
			    GEN6_WIZ_HASHING_16x4);

	return 0;
}

static int bdw_init_workarounds(struct intel_engine_cs *ring)
{
	int ret;
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	ret = gen8_init_workarounds(ring);
	if (ret)
		return ret;

	/* WaDisableThreadStallDopClockGating:bdw (pre-production) */
	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN, STALL_DOP_GATING_DISABLE);

	/* WaDisableDopClockGating:bdw */
	WA_SET_BIT_MASKED(GEN7_ROW_CHICKEN2,
			  DOP_CLOCK_GATING_DISABLE);

	WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN3,
			  GEN8_SAMPLER_POWER_BYPASS_DIS);

	WA_SET_BIT_MASKED(HDC_CHICKEN0,
			  /* WaForceContextSaveRestoreNonCoherent:bdw */
			  HDC_FORCE_CONTEXT_SAVE_RESTORE_NON_COHERENT |
			  /* WaDisableFenceDestinationToSLM:bdw (pre-prod) */
			  (IS_BDW_GT3(dev) ? HDC_FENCE_DEST_SLM_DISABLE : 0));

	return 0;
}

static int chv_init_workarounds(struct intel_engine_cs *ring)
{
	int ret;
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	ret = gen8_init_workarounds(ring);
	if (ret)
		return ret;

	/* WaDisableThreadStallDopClockGating:chv */
	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN, STALL_DOP_GATING_DISABLE);

	/* Improve HiZ throughput on CHV. */
	WA_SET_BIT_MASKED(HIZ_CHICKEN, CHV_HZ_8X8_MODE_IN_1X);

	return 0;
}

static int gen9_init_workarounds(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	uint32_t tmp;

	/* WaEnableLbsSlaRetryTimerDecrement:skl */
	I915_WRITE(BDW_SCRATCH1, I915_READ(BDW_SCRATCH1) |
		   GEN9_LBS_SLA_RETRY_TIMER_DECREMENT_ENABLE);

	/* WaDisableKillLogic:bxt,skl */
	I915_WRITE(GAM_ECOCHK, I915_READ(GAM_ECOCHK) |
		   ECOCHK_DIS_TLB);

	/* WaDisablePartialInstShootdown:skl,bxt */
	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN,
			  PARTIAL_INSTRUCTION_SHOOTDOWN_DISABLE);

	/* Syncing dependencies between camera and graphics:skl,bxt */
	WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN3,
			  GEN9_DISABLE_OCL_OOB_SUPPRESS_LOGIC);

	if ((IS_SKYLAKE(dev) && (INTEL_REVID(dev) == SKL_REVID_A0 ||
	    INTEL_REVID(dev) == SKL_REVID_B0)) ||
	    (IS_BROXTON(dev) && INTEL_REVID(dev) < BXT_REVID_B0)) {
		/* WaDisableDgMirrorFixInHalfSliceChicken5:skl,bxt */
		WA_CLR_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN5,
				  GEN9_DG_MIRROR_FIX_ENABLE);
	}

	if ((IS_SKYLAKE(dev) && INTEL_REVID(dev) <= SKL_REVID_B0) ||
	    (IS_BROXTON(dev) && INTEL_REVID(dev) < BXT_REVID_B0)) {
		/* WaSetDisablePixMaskCammingAndRhwoInCommonSliceChicken:skl,bxt */
		WA_SET_BIT_MASKED(GEN7_COMMON_SLICE_CHICKEN1,
				  GEN9_RHWO_OPTIMIZATION_DISABLE);
		/*
		 * WA also requires GEN9_SLICE_COMMON_ECO_CHICKEN0[14:14] to be set
		 * but we do that in per ctx batchbuffer as there is an issue
		 * with this register not getting restored on ctx restore
		 */
	}

	if ((IS_SKYLAKE(dev) && INTEL_REVID(dev) >= SKL_REVID_C0) ||
	    IS_BROXTON(dev)) {
		/* WaEnableYV12BugFixInHalfSliceChicken7:skl,bxt */
		WA_SET_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN7,
				  GEN9_ENABLE_YV12_BUGFIX);
	}

	/* Wa4x4STCOptimizationDisable:skl,bxt */
	/* WaDisablePartialResolveInVc:skl,bxt */
	WA_SET_BIT_MASKED(CACHE_MODE_1, (GEN8_4x4_STC_OPTIMIZATION_DISABLE |
					 GEN9_PARTIAL_RESOLVE_IN_VC_DISABLE));

	/* WaCcsTlbPrefetchDisable:skl,bxt */
	WA_CLR_BIT_MASKED(GEN9_HALF_SLICE_CHICKEN5,
			  GEN9_CCS_TLB_PREFETCH_ENABLE);

	/* WaDisableMaskBasedCammingInRCC:skl,bxt */
	if ((IS_SKYLAKE(dev) && INTEL_REVID(dev) == SKL_REVID_C0) ||
	    (IS_BROXTON(dev) && INTEL_REVID(dev) < BXT_REVID_B0))
		WA_SET_BIT_MASKED(SLICE_ECO_CHICKEN0,
				  PIXEL_MASK_CAMMING_DISABLE);

	/* WaForceContextSaveRestoreNonCoherent:skl,bxt */
	tmp = HDC_FORCE_CONTEXT_SAVE_RESTORE_NON_COHERENT;
	if ((IS_SKYLAKE(dev) && INTEL_REVID(dev) == SKL_REVID_F0) ||
	    (IS_BROXTON(dev) && INTEL_REVID(dev) >= BXT_REVID_B0))
		tmp |= HDC_FORCE_CSR_NON_COHERENT_OVR_DISABLE;
	WA_SET_BIT_MASKED(HDC_CHICKEN0, tmp);

	/* WaDisableSamplerPowerBypassForSOPingPong:skl,bxt */
	if (IS_SKYLAKE(dev) ||
	    (IS_BROXTON(dev) && INTEL_REVID(dev) <= BXT_REVID_B0)) {
		WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN3,
				  GEN8_SAMPLER_POWER_BYPASS_DIS);
	}

	/* WaDisableSTUnitPowerOptimization:skl,bxt */
	WA_SET_BIT_MASKED(HALF_SLICE_CHICKEN2, GEN8_ST_PO_DISABLE);

	return 0;
}

static int skl_tune_iz_hashing(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	u8 vals[3] = { 0, 0, 0 };
	unsigned int i;

	for (i = 0; i < 3; i++) {
		u8 ss;

		/*
		 * Only consider slices where one, and only one, subslice has 7
		 * EUs
		 */
		if (hweight8(dev_priv->info.subslice_7eu[i]) != 1)
			continue;

		/*
		 * subslice_7eu[i] != 0 (because of the check above) and
		 * ss_max == 4 (maximum number of subslices possible per slice)
		 *
		 * ->    0 <= ss <= 3;
		 */
		ss = ffs(dev_priv->info.subslice_7eu[i]) - 1;
		vals[i] = 3 - ss;
	}

	if (vals[0] == 0 && vals[1] == 0 && vals[2] == 0)
		return 0;

	/* Tune IZ hashing. See intel_device_info_runtime_init() */
	WA_SET_FIELD_MASKED(GEN7_GT_MODE,
			    GEN9_IZ_HASHING_MASK(2) |
			    GEN9_IZ_HASHING_MASK(1) |
			    GEN9_IZ_HASHING_MASK(0),
			    GEN9_IZ_HASHING(2, vals[2]) |
			    GEN9_IZ_HASHING(1, vals[1]) |
			    GEN9_IZ_HASHING(0, vals[0]));

	return 0;
}

static int skl_init_workarounds(struct intel_engine_cs *ring)
{
	int ret;
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	ret = gen9_init_workarounds(ring);
	if (ret)
		return ret;

	if (INTEL_REVID(dev) <= SKL_REVID_D0) {
		/* WaDisableHDCInvalidation:skl */
		I915_WRITE(GAM_ECOCHK, I915_READ(GAM_ECOCHK) |
			   BDW_DISABLE_HDC_INVALIDATION);

		/* WaDisableChickenBitTSGBarrierAckForFFSliceCS:skl */
		I915_WRITE(FF_SLICE_CS_CHICKEN2,
			   _MASKED_BIT_ENABLE(GEN9_TSG_BARRIER_ACK_DISABLE));
	}

	/* GEN8_L3SQCREG4 has a dependency with WA batch so any new changes
	 * involving this register should also be added to WA batch as required.
	 */
	if (INTEL_REVID(dev) <= SKL_REVID_E0)
		/* WaDisableLSQCROPERFforOCL:skl */
		I915_WRITE(GEN8_L3SQCREG4, I915_READ(GEN8_L3SQCREG4) |
			   GEN8_LQSC_RO_PERF_DIS);

	/* WaEnableGapsTsvCreditFix:skl */
	if (IS_SKYLAKE(dev) && (INTEL_REVID(dev) >= SKL_REVID_C0)) {
		I915_WRITE(GEN8_GARBCNTL, (I915_READ(GEN8_GARBCNTL) |
					   GEN9_GAPS_TSV_CREDIT_DISABLE));
	}

	/* WaDisablePowerCompilerClockGating:skl */
	if (INTEL_REVID(dev) == SKL_REVID_B0)
		WA_SET_BIT_MASKED(HIZ_CHICKEN,
				  BDW_HIZ_POWER_COMPILER_CLOCK_GATING_DISABLE);

	if (INTEL_REVID(dev) <= SKL_REVID_D0) {
		/*
		 *Use Force Non-Coherent whenever executing a 3D context. This
		 * is a workaround for a possible hang in the unlikely event
		 * a TLB invalidation occurs during a PSD flush.
		 */
		/* WaForceEnableNonCoherent:skl */
		WA_SET_BIT_MASKED(HDC_CHICKEN0,
				  HDC_FORCE_NON_COHERENT);
	}

	if (INTEL_REVID(dev) == SKL_REVID_C0 ||
	    INTEL_REVID(dev) == SKL_REVID_D0)
		/* WaBarrierPerformanceFixDisable:skl */
		WA_SET_BIT_MASKED(HDC_CHICKEN0,
				  HDC_FENCE_DEST_SLM_DISABLE |
				  HDC_BARRIER_PERFORMANCE_DISABLE);

	/* WaDisableSbeCacheDispatchPortSharing:skl */
	if (INTEL_REVID(dev) <= SKL_REVID_F0) {
		WA_SET_BIT_MASKED(
			GEN7_HALF_SLICE_CHICKEN1,
			GEN7_SBE_SS_CACHE_DISPATCH_PORT_SHARING_DISABLE);
	}

	return skl_tune_iz_hashing(ring);
}

static int bxt_init_workarounds(struct intel_engine_cs *ring)
{
	int ret;
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	ret = gen9_init_workarounds(ring);
	if (ret)
		return ret;

	/* WaStoreMultiplePTEenable:bxt */
	/* This is a requirement according to Hardware specification */
	if (INTEL_REVID(dev) == BXT_REVID_A0)
		I915_WRITE(TILECTL, I915_READ(TILECTL) | TILECTL_TLBPF);

	/* WaSetClckGatingDisableMedia:bxt */
	if (INTEL_REVID(dev) == BXT_REVID_A0) {
		I915_WRITE(GEN7_MISCCPCTL, (I915_READ(GEN7_MISCCPCTL) &
					    ~GEN8_DOP_CLOCK_GATE_MEDIA_ENABLE));
	}

	/* WaDisableThreadStallDopClockGating:bxt */
	WA_SET_BIT_MASKED(GEN8_ROW_CHICKEN,
			  STALL_DOP_GATING_DISABLE);

	/* WaDisableSbeCacheDispatchPortSharing:bxt */
	if (INTEL_REVID(dev) <= BXT_REVID_B0) {
		WA_SET_BIT_MASKED(
			GEN7_HALF_SLICE_CHICKEN1,
			GEN7_SBE_SS_CACHE_DISPATCH_PORT_SHARING_DISABLE);
	}

	return 0;
}

int init_workarounds_ring(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	WARN_ON(ring->id != RCS);

	dev_priv->workarounds.count = 0;

	if (IS_BROADWELL(dev))
		return bdw_init_workarounds(ring);

	if (IS_CHERRYVIEW(dev))
		return chv_init_workarounds(ring);

	if (IS_SKYLAKE(dev))
		return skl_init_workarounds(ring);

	if (IS_BROXTON(dev))
		return bxt_init_workarounds(ring);

	return 0;
}

static int init_render_ring(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	int ret = init_ring_common(ring);
	if (ret)
		return ret;

	/* WaTimedSingleVertexDispatch:cl,bw,ctg,elk,ilk,snb */
	if (INTEL_INFO(dev)->gen >= 4 && INTEL_INFO(dev)->gen < 7)
		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(VS_TIMER_DISPATCH));

	/* We need to disable the AsyncFlip performance optimisations in order
	 * to use MI_WAIT_FOR_EVENT within the CS. It should already be
	 * programmed to '1' on all products.
	 *
	 * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv
	 */
	if (INTEL_INFO(dev)->gen >= 6 && INTEL_INFO(dev)->gen < 8)
		I915_WRITE(MI_MODE, _MASKED_BIT_ENABLE(ASYNC_FLIP_PERF_DISABLE));

	/* Required for the hardware to program scanline values for waiting */
	/* WaEnableFlushTlbInvalidationMode:snb */
	if (INTEL_INFO(dev)->gen == 6)
		I915_WRITE(GFX_MODE,
			   _MASKED_BIT_ENABLE(GFX_TLB_INVALIDATE_EXPLICIT));

	/* WaBCSVCSTlbInvalidationMode:ivb,vlv,hsw */
	if (IS_GEN7(dev))
		I915_WRITE(GFX_MODE_GEN7,
			   _MASKED_BIT_ENABLE(GFX_TLB_INVALIDATE_EXPLICIT) |
			   _MASKED_BIT_ENABLE(GFX_REPLAY_MODE));

	if (IS_GEN6(dev)) {
		/* From the Sandybridge PRM, volume 1 part 3, page 24:
		 * "If this bit is set, STCunit will have LRA as replacement
		 *  policy. [...] This bit must be reset.  LRA replacement
		 *  policy is not supported."
		 */
		I915_WRITE(CACHE_MODE_0,
			   _MASKED_BIT_DISABLE(CM0_STC_EVICT_DISABLE_LRA_SNB));
	}

	if (INTEL_INFO(dev)->gen >= 6 && INTEL_INFO(dev)->gen < 8)
		I915_WRITE(INSTPM, _MASKED_BIT_ENABLE(INSTPM_FORCE_ORDERING));

	if (HAS_L3_DPF(dev))
		I915_WRITE_IMR(ring, ~GT_PARITY_ERROR(dev));

	return init_workarounds_ring(ring);
}

static void render_ring_cleanup(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (dev_priv->semaphore_obj) {
		i915_gem_object_ggtt_unpin(dev_priv->semaphore_obj);
		drm_gem_object_unreference(&dev_priv->semaphore_obj->base);
		dev_priv->semaphore_obj = NULL;
	}

	intel_fini_pipe_control(ring);
}

static int gen8_rcs_signal(struct drm_i915_gem_request *signaller_req,
			   unsigned int num_dwords)
{
#define MBOX_UPDATE_DWORDS 8
	struct intel_engine_cs *signaller = signaller_req->ring;
	struct drm_device *dev = signaller->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *waiter;
	int i, ret, num_rings;

	num_rings = hweight32(INTEL_INFO(dev)->ring_mask);
	num_dwords += (num_rings-1) * MBOX_UPDATE_DWORDS;
#undef MBOX_UPDATE_DWORDS

	ret = intel_ring_begin(signaller_req, num_dwords);
	if (ret)
		return ret;

	for_each_ring(waiter, dev_priv, i) {
		u32 seqno;
		u64 gtt_offset = signaller->semaphore.signal_ggtt[i];
		if (gtt_offset == MI_SEMAPHORE_SYNC_INVALID)
			continue;

		seqno = i915_gem_request_get_seqno(signaller_req);
		intel_ring_emit(signaller, GFX_OP_PIPE_CONTROL(6));
		intel_ring_emit(signaller, PIPE_CONTROL_GLOBAL_GTT_IVB |
					   PIPE_CONTROL_QW_WRITE |
					   PIPE_CONTROL_FLUSH_ENABLE);
		intel_ring_emit(signaller, lower_32_bits(gtt_offset));
		intel_ring_emit(signaller, upper_32_bits(gtt_offset));
		intel_ring_emit(signaller, seqno);
		intel_ring_emit(signaller, 0);
		intel_ring_emit(signaller, MI_SEMAPHORE_SIGNAL |
					   MI_SEMAPHORE_TARGET(waiter->id));
		intel_ring_emit(signaller, 0);
	}

	return 0;
}

static int gen8_xcs_signal(struct drm_i915_gem_request *signaller_req,
			   unsigned int num_dwords)
{
#define MBOX_UPDATE_DWORDS 6
	struct intel_engine_cs *signaller = signaller_req->ring;
	struct drm_device *dev = signaller->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *waiter;
	int i, ret, num_rings;

	num_rings = hweight32(INTEL_INFO(dev)->ring_mask);
	num_dwords += (num_rings-1) * MBOX_UPDATE_DWORDS;
#undef MBOX_UPDATE_DWORDS

	ret = intel_ring_begin(signaller_req, num_dwords);
	if (ret)
		return ret;

	for_each_ring(waiter, dev_priv, i) {
		u32 seqno;
		u64 gtt_offset = signaller->semaphore.signal_ggtt[i];
		if (gtt_offset == MI_SEMAPHORE_SYNC_INVALID)
			continue;

		seqno = i915_gem_request_get_seqno(signaller_req);
		intel_ring_emit(signaller, (MI_FLUSH_DW + 1) |
					   MI_FLUSH_DW_OP_STOREDW);
		intel_ring_emit(signaller, lower_32_bits(gtt_offset) |
					   MI_FLUSH_DW_USE_GTT);
		intel_ring_emit(signaller, upper_32_bits(gtt_offset));
		intel_ring_emit(signaller, seqno);
		intel_ring_emit(signaller, MI_SEMAPHORE_SIGNAL |
					   MI_SEMAPHORE_TARGET(waiter->id));
		intel_ring_emit(signaller, 0);
	}

	return 0;
}

static int gen6_signal(struct drm_i915_gem_request *signaller_req,
		       unsigned int num_dwords)
{
	struct intel_engine_cs *signaller = signaller_req->ring;
	struct drm_device *dev = signaller->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *useless;
	int i, ret, num_rings;

#define MBOX_UPDATE_DWORDS 3
	num_rings = hweight32(INTEL_INFO(dev)->ring_mask);
	num_dwords += round_up((num_rings-1) * MBOX_UPDATE_DWORDS, 2);
#undef MBOX_UPDATE_DWORDS

	ret = intel_ring_begin(signaller_req, num_dwords);
	if (ret)
		return ret;

	for_each_ring(useless, dev_priv, i) {
		u32 mbox_reg = signaller->semaphore.mbox.signal[i];
		if (mbox_reg != GEN6_NOSYNC) {
			u32 seqno = i915_gem_request_get_seqno(signaller_req);
			intel_ring_emit(signaller, MI_LOAD_REGISTER_IMM(1));
			intel_ring_emit(signaller, mbox_reg);
			intel_ring_emit(signaller, seqno);
		}
	}

	/* If num_dwords was rounded, make sure the tail pointer is correct */
	if (num_rings % 2 == 0)
		intel_ring_emit(signaller, MI_NOOP);

	return 0;
}

/**
 * gen6_add_request - Update the semaphore mailbox registers
 *
 * @@request - request to write to the ring
 *
 * Update the mailbox registers in the *other* rings with the current seqno.
 * This acts like a signal in the canonical semaphore.
 */
static int
gen6_add_request(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	if (ring->semaphore.signal)
		ret = ring->semaphore.signal(req, 4);
	else
		ret = intel_ring_begin(req, 4);

	if (ret)
		return ret;

	intel_ring_emit(ring, MI_STORE_DWORD_INDEX);
	intel_ring_emit(ring, I915_GEM_HWS_INDEX << MI_STORE_DWORD_INDEX_SHIFT);
	intel_ring_emit(ring, i915_gem_request_get_seqno(req));
	intel_ring_emit(ring, MI_USER_INTERRUPT);
	__intel_ring_advance(ring);

	return 0;
}

static inline bool i915_gem_has_seqno_wrapped(struct drm_device *dev,
					      u32 seqno)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	return dev_priv->last_seqno < seqno;
}

/**
 * intel_ring_sync - sync the waiter to the signaller on seqno
 *
 * @@waiter - ring that is waiting
 * @@signaller - ring which has, or will signal
 * @@seqno - seqno which the waiter will block on
 */

static int
gen8_ring_sync(struct drm_i915_gem_request *waiter_req,
	       struct intel_engine_cs *signaller,
	       u32 seqno)
{
	struct intel_engine_cs *waiter = waiter_req->ring;
	struct drm_i915_private *dev_priv = waiter->dev->dev_private;
	int ret;

	ret = intel_ring_begin(waiter_req, 4);
	if (ret)
		return ret;

	intel_ring_emit(waiter, MI_SEMAPHORE_WAIT |
				MI_SEMAPHORE_GLOBAL_GTT |
				MI_SEMAPHORE_POLL |
				MI_SEMAPHORE_SAD_GTE_SDD);
	intel_ring_emit(waiter, seqno);
	intel_ring_emit(waiter,
			lower_32_bits(GEN8_WAIT_OFFSET(waiter, signaller->id)));
	intel_ring_emit(waiter,
			upper_32_bits(GEN8_WAIT_OFFSET(waiter, signaller->id)));
	intel_ring_advance(waiter);
	return 0;
}

static int
gen6_ring_sync(struct drm_i915_gem_request *waiter_req,
	       struct intel_engine_cs *signaller,
	       u32 seqno)
{
	struct intel_engine_cs *waiter = waiter_req->ring;
	u32 dw1 = MI_SEMAPHORE_MBOX |
		  MI_SEMAPHORE_COMPARE |
		  MI_SEMAPHORE_REGISTER;
	u32 wait_mbox = signaller->semaphore.mbox.wait[waiter->id];
	int ret;

	/* Throughout all of the GEM code, seqno passed implies our current
	 * seqno is >= the last seqno executed. However for hardware the
	 * comparison is strictly greater than.
	 */
	seqno -= 1;

	WARN_ON(wait_mbox == MI_SEMAPHORE_SYNC_INVALID);

	ret = intel_ring_begin(waiter_req, 4);
	if (ret)
		return ret;

	/* If seqno wrap happened, omit the wait with no-ops */
	if (likely(!i915_gem_has_seqno_wrapped(waiter->dev, seqno))) {
		intel_ring_emit(waiter, dw1 | wait_mbox);
		intel_ring_emit(waiter, seqno);
		intel_ring_emit(waiter, 0);
		intel_ring_emit(waiter, MI_NOOP);
	} else {
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
		intel_ring_emit(waiter, MI_NOOP);
	}
	intel_ring_advance(waiter);

	return 0;
}

#define PIPE_CONTROL_FLUSH(ring__, addr__)					\
do {									\
	intel_ring_emit(ring__, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |		\
		 PIPE_CONTROL_DEPTH_STALL);				\
	intel_ring_emit(ring__, (addr__) | PIPE_CONTROL_GLOBAL_GTT);			\
	intel_ring_emit(ring__, 0);							\
	intel_ring_emit(ring__, 0);							\
} while (0)

static int
pc_render_add_request(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	u32 scratch_addr = ring->scratch.gtt_offset + 2 * CACHELINE_BYTES;
	int ret;

	/* For Ironlake, MI_USER_INTERRUPT was deprecated and apparently
	 * incoherent with writes to memory, i.e. completely fubar,
	 * so we need to use PIPE_NOTIFY instead.
	 *
	 * However, we also need to workaround the qword write
	 * incoherence by flushing the 6 PIPE_NOTIFY buffers out to
	 * memory before requesting an interrupt.
	 */
	ret = intel_ring_begin(req, 32);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |
			PIPE_CONTROL_WRITE_FLUSH |
			PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE);
	intel_ring_emit(ring, ring->scratch.gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, i915_gem_request_get_seqno(req));
	intel_ring_emit(ring, 0);
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 2 * CACHELINE_BYTES; /* write to separate cachelines */
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 2 * CACHELINE_BYTES;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 2 * CACHELINE_BYTES;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 2 * CACHELINE_BYTES;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);
	scratch_addr += 2 * CACHELINE_BYTES;
	PIPE_CONTROL_FLUSH(ring, scratch_addr);

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(4) | PIPE_CONTROL_QW_WRITE |
			PIPE_CONTROL_WRITE_FLUSH |
			PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE |
			PIPE_CONTROL_NOTIFY);
	intel_ring_emit(ring, ring->scratch.gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, i915_gem_request_get_seqno(req));
	intel_ring_emit(ring, 0);
	__intel_ring_advance(ring);

	return 0;
}

static u32
gen6_ring_get_seqno(struct intel_engine_cs *ring, bool lazy_coherency)
{
	/* Workaround to force correct ordering between irq and seqno writes on
	 * ivb (and maybe also on snb) by reading from a CS register (like
	 * ACTHD) before reading the status page. */
	if (!lazy_coherency) {
		struct drm_i915_private *dev_priv = ring->dev->dev_private;
		POSTING_READ(RING_ACTHD(ring->mmio_base));
	}

	return intel_read_status_page(ring, I915_GEM_HWS_INDEX);
}

static u32
ring_get_seqno(struct intel_engine_cs *ring, bool lazy_coherency)
{
	return intel_read_status_page(ring, I915_GEM_HWS_INDEX);
}

static void
ring_set_seqno(struct intel_engine_cs *ring, u32 seqno)
{
	intel_write_status_page(ring, I915_GEM_HWS_INDEX, seqno);
}

static u32
pc_render_get_seqno(struct intel_engine_cs *ring, bool lazy_coherency)
{
	return ring->scratch.cpu_page[0];
}

static void
pc_render_set_seqno(struct intel_engine_cs *ring, u32 seqno)
{
	ring->scratch.cpu_page[0] = seqno;
}

static bool
gen5_ring_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0)
		gen5_enable_gt_irq(dev_priv, ring->irq_enable_mask);
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen5_ring_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0)
		gen5_disable_gt_irq(dev_priv, ring->irq_enable_mask);
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
i9xx_ring_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!intel_irqs_enabled(dev_priv))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		dev_priv->irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(IMR, dev_priv->irq_mask);
		POSTING_READ(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
i9xx_ring_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		dev_priv->irq_mask |= ring->irq_enable_mask;
		I915_WRITE(IMR, dev_priv->irq_mask);
		POSTING_READ(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
i8xx_ring_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (!intel_irqs_enabled(dev_priv))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		dev_priv->irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE16(IMR, dev_priv->irq_mask);
		POSTING_READ16(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
i8xx_ring_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		dev_priv->irq_mask |= ring->irq_enable_mask;
		I915_WRITE16(IMR, dev_priv->irq_mask);
		POSTING_READ16(IMR);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static int
bsd_ring_flush(struct drm_i915_gem_request *req,
	       u32     invalidate_domains,
	       u32     flush_domains)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_FLUSH);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);
	return 0;
}

static int
i9xx_add_request(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_STORE_DWORD_INDEX);
	intel_ring_emit(ring, I915_GEM_HWS_INDEX << MI_STORE_DWORD_INDEX_SHIFT);
	intel_ring_emit(ring, i915_gem_request_get_seqno(req));
	intel_ring_emit(ring, MI_USER_INTERRUPT);
	__intel_ring_advance(ring);

	return 0;
}

static bool
gen6_ring_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring,
				       ~(ring->irq_enable_mask |
					 GT_PARITY_ERROR(dev)));
		else
			I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		gen5_enable_gt_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen6_ring_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~GT_PARITY_ERROR(dev));
		else
			I915_WRITE_IMR(ring, ~0);
		gen5_disable_gt_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
hsw_vebox_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		gen6_enable_pm_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
hsw_vebox_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		I915_WRITE_IMR(ring, ~0);
		gen6_disable_pm_irq(dev_priv, ring->irq_enable_mask);
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static bool
gen8_ring_get_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	if (WARN_ON(!intel_irqs_enabled(dev_priv)))
		return false;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (ring->irq_refcount++ == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS) {
			I915_WRITE_IMR(ring,
				       ~(ring->irq_enable_mask |
					 GT_RENDER_L3_PARITY_ERROR_INTERRUPT));
		} else {
			I915_WRITE_IMR(ring, ~ring->irq_enable_mask);
		}
		POSTING_READ(RING_IMR(ring->mmio_base));
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);

	return true;
}

static void
gen8_ring_put_irq(struct intel_engine_cs *ring)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long flags;

	spin_lock_irqsave(&dev_priv->irq_lock, flags);
	if (--ring->irq_refcount == 0) {
		if (HAS_L3_DPF(dev) && ring->id == RCS) {
			I915_WRITE_IMR(ring,
				       ~GT_RENDER_L3_PARITY_ERROR_INTERRUPT);
		} else {
			I915_WRITE_IMR(ring, ~0);
		}
		POSTING_READ(RING_IMR(ring->mmio_base));
	}
	spin_unlock_irqrestore(&dev_priv->irq_lock, flags);
}

static int
i965_dispatch_execbuffer(struct drm_i915_gem_request *req,
			 u64 offset, u32 length,
			 unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START |
			MI_BATCH_GTT |
			(dispatch_flags & I915_DISPATCH_SECURE ?
			 0 : MI_BATCH_NON_SECURE_I965));
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

/* Just userspace ABI convention to limit the wa batch bo to a resonable size */
#define I830_BATCH_LIMIT (256*1024)
#define I830_TLB_ENTRIES (2)
#define I830_WA_SIZE max(I830_TLB_ENTRIES*4096, I830_BATCH_LIMIT)
static int
i830_dispatch_execbuffer(struct drm_i915_gem_request *req,
			 u64 offset, u32 len,
			 unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	u32 cs_offset = ring->scratch.gtt_offset;
	int ret;

	ret = intel_ring_begin(req, 6);
	if (ret)
		return ret;

	/* Evict the invalid PTE TLBs */
	intel_ring_emit(ring, COLOR_BLT_CMD | BLT_WRITE_RGBA);
	intel_ring_emit(ring, BLT_DEPTH_32 | BLT_ROP_COLOR_COPY | 4096);
	intel_ring_emit(ring, I830_TLB_ENTRIES << 16 | 4); /* load each page */
	intel_ring_emit(ring, cs_offset);
	intel_ring_emit(ring, 0xdeadbeef);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	if ((dispatch_flags & I915_DISPATCH_PINNED) == 0) {
		if (len > I830_BATCH_LIMIT)
			return -ENOSPC;

		ret = intel_ring_begin(req, 6 + 2);
		if (ret)
			return ret;

		/* Blit the batch (which has now all relocs applied) to the
		 * stable batch scratch bo area (so that the CS never
		 * stumbles over its tlb invalidation bug) ...
		 */
		intel_ring_emit(ring, SRC_COPY_BLT_CMD | BLT_WRITE_RGBA);
		intel_ring_emit(ring, BLT_DEPTH_32 | BLT_ROP_SRC_COPY | 4096);
		intel_ring_emit(ring, DIV_ROUND_UP(len, 4096) << 16 | 4096);
		intel_ring_emit(ring, cs_offset);
		intel_ring_emit(ring, 4096);
		intel_ring_emit(ring, offset);

		intel_ring_emit(ring, MI_FLUSH);
		intel_ring_emit(ring, MI_NOOP);
		intel_ring_advance(ring);

		/* ... and execute it. */
		offset = cs_offset;
	}

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_BATCH_BUFFER);
	intel_ring_emit(ring, offset | (dispatch_flags & I915_DISPATCH_SECURE ?
					0 : MI_BATCH_NON_SECURE));
	intel_ring_emit(ring, offset + len - 8);
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
i915_dispatch_execbuffer(struct drm_i915_gem_request *req,
			 u64 offset, u32 len,
			 unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring, MI_BATCH_BUFFER_START | MI_BATCH_GTT);
	intel_ring_emit(ring, offset | (dispatch_flags & I915_DISPATCH_SECURE ?
					0 : MI_BATCH_NON_SECURE));
	intel_ring_advance(ring);

	return 0;
}

static void cleanup_phys_status_page(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = to_i915(ring->dev);

	if (!dev_priv->status_page_dmah)
		return;

	drm_pci_free(ring->dev, dev_priv->status_page_dmah);
	ring->status_page.page_addr = NULL;
}

static void cleanup_status_page(struct intel_engine_cs *ring)
{
	struct drm_i915_gem_object *obj;

	obj = ring->status_page.obj;
	if (obj == NULL)
		return;

	kunmap(sg_page(obj->pages->sgl));
	i915_gem_object_ggtt_unpin(obj);
	drm_gem_object_unreference(&obj->base);
	ring->status_page.obj = NULL;
}

static int init_status_page(struct intel_engine_cs *ring)
{
	struct drm_i915_gem_object *obj = ring->status_page.obj;

	if (obj == NULL) {
		unsigned flags;
		int ret;

		obj = i915_gem_alloc_object(ring->dev, 4096);
		if (obj == NULL) {
			DRM_ERROR("Failed to allocate status page\n");
			return -ENOMEM;
		}

		ret = i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);
		if (ret)
			goto err_unref;

		flags = 0;
		if (!HAS_LLC(ring->dev))
			/* On g33, we cannot place HWS above 256MiB, so
			 * restrict its pinning to the low mappable arena.
			 * Though this restriction is not documented for
			 * gen4, gen5, or byt, they also behave similarly
			 * and hang if the HWS is placed at the top of the
			 * GTT. To generalise, it appears that all !llc
			 * platforms have issues with us placing the HWS
			 * above the mappable region (even though we never
			 * actualy map it).
			 */
			flags |= PIN_MAPPABLE;
		ret = i915_gem_obj_ggtt_pin(obj, 4096, flags);
		if (ret) {
err_unref:
			drm_gem_object_unreference(&obj->base);
			return ret;
		}

		ring->status_page.obj = obj;
	}

	ring->status_page.gfx_addr = i915_gem_obj_ggtt_offset(obj);
	ring->status_page.page_addr = kmap(sg_page(obj->pages->sgl));
	memset(ring->status_page.page_addr, 0, PAGE_SIZE);

	DRM_DEBUG_DRIVER("%s hws offset: 0x%08x\n",
			ring->name, ring->status_page.gfx_addr);

	return 0;
}

static int init_phys_status_page(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	if (!dev_priv->status_page_dmah) {
		dev_priv->status_page_dmah =
			drm_pci_alloc(ring->dev, PAGE_SIZE, PAGE_SIZE);
		if (!dev_priv->status_page_dmah)
			return -ENOMEM;
	}

	ring->status_page.page_addr = dev_priv->status_page_dmah->vaddr;
	memset(ring->status_page.page_addr, 0, PAGE_SIZE);

	return 0;
}

void intel_unpin_ringbuffer_obj(struct intel_ringbuffer *ringbuf)
{
	struct drm_device *dev = ringbuf->obj->base.dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	agp_unmap_subregion(dev_priv->agph, ringbuf->bsh, ringbuf->size);
	ringbuf->virtual_start = NULL;
	i915_gem_object_ggtt_unpin(ringbuf->obj);
}

int intel_pin_and_map_ringbuffer_obj(struct drm_device *dev,
				     struct intel_ringbuffer *ringbuf)
{
	struct drm_i915_private *dev_priv = to_i915(dev);
	struct drm_i915_gem_object *obj = ringbuf->obj;
	int ret;

	ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, PIN_MAPPABLE);
	if (ret)
		return ret;

	ret = i915_gem_object_set_to_gtt_domain(obj, true);
	if (ret) {
		i915_gem_object_ggtt_unpin(obj);
		return ret;
	}

	if (agp_map_subregion(dev_priv->agph, i915_gem_obj_ggtt_offset(obj),
	    ringbuf->size, &ringbuf->bsh) != 0) {
		i915_gem_object_ggtt_unpin(obj);
		return -EINVAL;
	}
	ringbuf->virtual_start = bus_space_vaddr(dev_priv->bst, ringbuf->bsh);

	return 0;
}

static void intel_destroy_ringbuffer_obj(struct intel_ringbuffer *ringbuf)
{
	drm_gem_object_unreference(&ringbuf->obj->base);
	ringbuf->obj = NULL;
}

static int intel_alloc_ringbuffer_obj(struct drm_device *dev,
				      struct intel_ringbuffer *ringbuf)
{
	struct drm_i915_gem_object *obj;

	obj = NULL;
	if (!HAS_LLC(dev))
		obj = i915_gem_object_create_stolen(dev, ringbuf->size);
	if (obj == NULL)
		obj = i915_gem_alloc_object(dev, ringbuf->size);
	if (obj == NULL)
		return -ENOMEM;

	/* mark ring buffers as read-only from GPU side by default */
	obj->gt_ro = 1;

	ringbuf->obj = obj;

	return 0;
}

struct intel_ringbuffer *
intel_engine_create_ringbuffer(struct intel_engine_cs *engine, int size)
{
	struct intel_ringbuffer *ring;
	int ret;

	ring = kzalloc(sizeof(*ring), GFP_KERNEL);
	if (ring == NULL)
		return ERR_PTR(-ENOMEM);

	ring->ring = engine;

	ring->size = size;
	/* Workaround an erratum on the i830 which causes a hang if
	 * the TAIL pointer points to within the last 2 cachelines
	 * of the buffer.
	 */
	ring->effective_size = size;
	if (IS_I830(engine->dev) || IS_845G(engine->dev))
		ring->effective_size -= 2 * CACHELINE_BYTES;

	ring->last_retired_head = -1;
	intel_ring_update_space(ring);

	ret = intel_alloc_ringbuffer_obj(engine->dev, ring);
	if (ret) {
		DRM_ERROR("Failed to allocate ringbuffer %s: %d\n",
			  engine->name, ret);
		kfree(ring);
		return ERR_PTR(ret);
	}

	return ring;
}

void
intel_ringbuffer_free(struct intel_ringbuffer *ring)
{
	intel_destroy_ringbuffer_obj(ring);
	kfree(ring);
}

static int intel_init_ring_buffer(struct drm_device *dev,
				  struct intel_engine_cs *ring)
{
	struct intel_ringbuffer *ringbuf;
	int ret;

	WARN_ON(ring->buffer);

	ring->dev = dev;
	INIT_LIST_HEAD(&ring->active_list);
	INIT_LIST_HEAD(&ring->request_list);
	INIT_LIST_HEAD(&ring->execlist_queue);
	i915_gem_batch_pool_init(dev, &ring->batch_pool);
	memset(ring->semaphore.sync_seqno, 0, sizeof(ring->semaphore.sync_seqno));

	init_waitqueue_head(&ring->irq_queue);

	ringbuf = intel_engine_create_ringbuffer(ring, 32 * PAGE_SIZE);
	if (IS_ERR(ringbuf))
		return PTR_ERR(ringbuf);
	ring->buffer = ringbuf;

	if (I915_NEED_GFX_HWS(dev)) {
		ret = init_status_page(ring);
		if (ret)
			goto error;
	} else {
		WARN_ON(ring->id != RCS);
		ret = init_phys_status_page(ring);
		if (ret)
			goto error;
	}

	ret = intel_pin_and_map_ringbuffer_obj(dev, ringbuf);
	if (ret) {
		DRM_ERROR("Failed to pin and map ringbuffer %s: %d\n",
				ring->name, ret);
		intel_destroy_ringbuffer_obj(ringbuf);
		goto error;
	}

	ret = i915_cmd_parser_init_ring(ring);
	if (ret)
		goto error;

	return 0;

error:
	intel_ringbuffer_free(ringbuf);
	ring->buffer = NULL;
	return ret;
}

void intel_cleanup_ring_buffer(struct intel_engine_cs *ring)
{
	struct drm_i915_private *dev_priv;

	if (!intel_ring_initialized(ring))
		return;

	dev_priv = to_i915(ring->dev);

	intel_stop_ring_buffer(ring);
	WARN_ON(!IS_GEN2(ring->dev) && (I915_READ_MODE(ring) & MODE_IDLE) == 0);

	intel_unpin_ringbuffer_obj(ring->buffer);
	intel_ringbuffer_free(ring->buffer);
	ring->buffer = NULL;

	if (ring->cleanup)
		ring->cleanup(ring);

	if (I915_NEED_GFX_HWS(ring->dev)) {
		cleanup_status_page(ring);
	} else {
		WARN_ON(ring->id != RCS);
		cleanup_phys_status_page(ring);
	}

	i915_cmd_parser_fini_ring(ring);
	i915_gem_batch_pool_fini(&ring->batch_pool);
}

static int ring_wait_for_space(struct intel_engine_cs *ring, int n)
{
	struct intel_ringbuffer *ringbuf = ring->buffer;
	struct drm_i915_gem_request *request;
	unsigned space;
	int ret;

	if (intel_ring_space(ringbuf) >= n)
		return 0;

	/* The whole point of reserving space is to not wait! */
	WARN_ON(ringbuf->reserved_in_use);

	list_for_each_entry(request, &ring->request_list, list) {
		space = __intel_ring_space(request->postfix, ringbuf->tail,
					   ringbuf->size);
		if (space >= n)
			break;
	}

	if (WARN_ON(&request->list == &ring->request_list))
		return -ENOSPC;

	ret = i915_wait_request(request);
	if (ret)
		return ret;

	ringbuf->space = space;
	return 0;
}

static void __wrap_ring_buffer(struct intel_ringbuffer *ringbuf)
{
	uint32_t __iomem *virt;
	int rem = ringbuf->size - ringbuf->tail;

	virt = ringbuf->virtual_start + ringbuf->tail;
	rem /= 4;
	while (rem--)
		iowrite32(MI_NOOP, virt++);

	ringbuf->tail = 0;
	intel_ring_update_space(ringbuf);
}

int intel_ring_idle(struct intel_engine_cs *ring)
{
	struct drm_i915_gem_request *req;

	/* Wait upon the last request to be completed */
	if (list_empty(&ring->request_list))
		return 0;

	req = list_entry(ring->request_list.prev,
			struct drm_i915_gem_request,
			list);

	/* Make sure we do not trigger any retires */
	return __i915_wait_request(req,
				   atomic_read(&to_i915(ring->dev)->gpu_error.reset_counter),
				   to_i915(ring->dev)->mm.interruptible,
				   NULL, NULL);
}

int intel_ring_alloc_request_extras(struct drm_i915_gem_request *request)
{
	request->ringbuf = request->ring->buffer;
	return 0;
}

int intel_ring_reserve_space(struct drm_i915_gem_request *request)
{
	/*
	 * The first call merely notes the reserve request and is common for
	 * all back ends. The subsequent localised _begin() call actually
	 * ensures that the reservation is available. Without the begin, if
	 * the request creator immediately submitted the request without
	 * adding any commands to it then there might not actually be
	 * sufficient room for the submission commands.
	 */
	intel_ring_reserved_space_reserve(request->ringbuf, MIN_SPACE_FOR_ADD_REQUEST);

	return intel_ring_begin(request, 0);
}

void intel_ring_reserved_space_reserve(struct intel_ringbuffer *ringbuf, int size)
{
	WARN_ON(ringbuf->reserved_size);
	WARN_ON(ringbuf->reserved_in_use);

	ringbuf->reserved_size = size;
}

void intel_ring_reserved_space_cancel(struct intel_ringbuffer *ringbuf)
{
	WARN_ON(ringbuf->reserved_in_use);

	ringbuf->reserved_size   = 0;
	ringbuf->reserved_in_use = false;
}

void intel_ring_reserved_space_use(struct intel_ringbuffer *ringbuf)
{
	WARN_ON(ringbuf->reserved_in_use);

	ringbuf->reserved_in_use = true;
	ringbuf->reserved_tail   = ringbuf->tail;
}

void intel_ring_reserved_space_end(struct intel_ringbuffer *ringbuf)
{
	WARN_ON(!ringbuf->reserved_in_use);
	if (ringbuf->tail > ringbuf->reserved_tail) {
		WARN(ringbuf->tail > ringbuf->reserved_tail + ringbuf->reserved_size,
		     "request reserved size too small: %d vs %d!\n",
		     ringbuf->tail - ringbuf->reserved_tail, ringbuf->reserved_size);
	} else {
		/*
		 * The ring was wrapped while the reserved space was in use.
		 * That means that some unknown amount of the ring tail was
		 * no-op filled and skipped. Thus simply adding the ring size
		 * to the tail and doing the above space check will not work.
		 * Rather than attempt to track how much tail was skipped,
		 * it is much simpler to say that also skipping the sanity
		 * check every once in a while is not a big issue.
		 */
	}

	ringbuf->reserved_size   = 0;
	ringbuf->reserved_in_use = false;
}

static int __intel_ring_prepare(struct intel_engine_cs *ring, int bytes)
{
	struct intel_ringbuffer *ringbuf = ring->buffer;
	int remain_usable = ringbuf->effective_size - ringbuf->tail;
	int remain_actual = ringbuf->size - ringbuf->tail;
	int ret, total_bytes, wait_bytes = 0;
	bool need_wrap = false;

	if (ringbuf->reserved_in_use)
		total_bytes = bytes;
	else
		total_bytes = bytes + ringbuf->reserved_size;

	if (unlikely(bytes > remain_usable)) {
		/*
		 * Not enough space for the basic request. So need to flush
		 * out the remainder and then wait for base + reserved.
		 */
		wait_bytes = remain_actual + total_bytes;
		need_wrap = true;
	} else {
		if (unlikely(total_bytes > remain_usable)) {
			/*
			 * The base request will fit but the reserved space
			 * falls off the end. So don't need an immediate wrap
			 * and only need to effectively wait for the reserved
			 * size space from the start of ringbuffer.
			 */
			wait_bytes = remain_actual + ringbuf->reserved_size;
		} else if (total_bytes > ringbuf->space) {
			/* No wrapping required, just waiting. */
			wait_bytes = total_bytes;
		}
	}

	if (wait_bytes) {
		ret = ring_wait_for_space(ring, wait_bytes);
		if (unlikely(ret))
			return ret;

		if (need_wrap)
			__wrap_ring_buffer(ringbuf);
	}

	return 0;
}

int intel_ring_begin(struct drm_i915_gem_request *req,
		     int num_dwords)
{
	struct intel_engine_cs *ring;
	struct drm_i915_private *dev_priv;
	int ret;

	WARN_ON(req == NULL);
	ring = req->ring;
	dev_priv = ring->dev->dev_private;

	ret = i915_gem_check_wedge(&dev_priv->gpu_error,
				   dev_priv->mm.interruptible);
	if (ret)
		return ret;

	ret = __intel_ring_prepare(ring, num_dwords * sizeof(uint32_t));
	if (ret)
		return ret;

	ring->buffer->space -= num_dwords * sizeof(uint32_t);
	return 0;
}

/* Align the ring tail to a cacheline boundary */
int intel_ring_cacheline_align(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int num_dwords = (ring->buffer->tail & (CACHELINE_BYTES - 1)) / sizeof(uint32_t);
	int ret;

	if (num_dwords == 0)
		return 0;

	num_dwords = CACHELINE_BYTES / sizeof(uint32_t) - num_dwords;
	ret = intel_ring_begin(req, num_dwords);
	if (ret)
		return ret;

	while (num_dwords--)
		intel_ring_emit(ring, MI_NOOP);

	intel_ring_advance(ring);

	return 0;
}

void intel_ring_init_seqno(struct intel_engine_cs *ring, u32 seqno)
{
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;

	if (INTEL_INFO(dev)->gen == 6 || INTEL_INFO(dev)->gen == 7) {
		I915_WRITE(RING_SYNC_0(ring->mmio_base), 0);
		I915_WRITE(RING_SYNC_1(ring->mmio_base), 0);
		if (HAS_VEBOX(dev))
			I915_WRITE(RING_SYNC_2(ring->mmio_base), 0);
	}

	ring->set_seqno(ring, seqno);
	ring->hangcheck.seqno = seqno;
}

static void gen6_bsd_ring_write_tail(struct intel_engine_cs *ring,
				     u32 value)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

       /* Every tail move must follow the sequence below */

	/* Disable notification that the ring is IDLE. The GT
	 * will then assume that it is busy and bring it out of rc6.
	 */
	I915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,
		   _MASKED_BIT_ENABLE(GEN6_BSD_SLEEP_MSG_DISABLE));

	/* Clear the context id. Here be magic! */
	I915_WRITE64(GEN6_BSD_RNCID, 0x0);

	/* Wait for the ring not to be idle, i.e. for it to wake up. */
	if (wait_for((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &
		      GEN6_BSD_SLEEP_INDICATOR) == 0,
		     50))
		DRM_ERROR("timed out waiting for the BSD ring to wake up\n");

	/* Now that the ring is fully powered up, update the tail */
	I915_WRITE_TAIL(ring, value);
	POSTING_READ(RING_TAIL(ring->mmio_base));

	/* Let the ring send IDLE messages to the GT again,
	 * and so let it sleep to conserve power when idle.
	 */
	I915_WRITE(GEN6_BSD_SLEEP_PSMI_CONTROL,
		   _MASKED_BIT_DISABLE(GEN6_BSD_SLEEP_MSG_DISABLE));
}

static int gen6_bsd_ring_flush(struct drm_i915_gem_request *req,
			       u32 invalidate, u32 flush)
{
	struct intel_engine_cs *ring = req->ring;
	uint32_t cmd;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	cmd = MI_FLUSH_DW;
	if (INTEL_INFO(ring->dev)->gen >= 8)
		cmd += 1;

	/* We always require a command barrier so that subsequent
	 * commands, such as breadcrumb interrupts, are strictly ordered
	 * wrt the contents of the write cache being flushed to memory
	 * (and thus being coherent from the CPU).
	 */
	cmd |= MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;

	/*
	 * Bspec vol 1c.5 - video engine command streamer:
	 * "If ENABLED, all TLBs will be invalidated once the flush
	 * operation is complete. This bit is only valid when the
	 * Post-Sync Operation field is a value of 1h or 3h."
	 */
	if (invalidate & I915_GEM_GPU_DOMAINS)
		cmd |= MI_INVALIDATE_TLB | MI_INVALIDATE_BSD;

	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, I915_GEM_HWS_SCRATCH_ADDR | MI_FLUSH_DW_USE_GTT);
	if (INTEL_INFO(ring->dev)->gen >= 8) {
		intel_ring_emit(ring, 0); /* upper addr */
		intel_ring_emit(ring, 0); /* value */
	} else  {
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, MI_NOOP);
	}
	intel_ring_advance(ring);
	return 0;
}

static int
gen8_ring_dispatch_execbuffer(struct drm_i915_gem_request *req,
			      u64 offset, u32 len,
			      unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	bool ppgtt = USES_PPGTT(ring->dev) &&
			!(dispatch_flags & I915_DISPATCH_SECURE);
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	/* FIXME(BDW): Address space and security selectors. */
	intel_ring_emit(ring, MI_BATCH_BUFFER_START_GEN8 | (ppgtt<<8) |
			(dispatch_flags & I915_DISPATCH_RS ?
			 MI_BATCH_RESOURCE_STREAMER : 0));
	intel_ring_emit(ring, lower_32_bits(offset));
	intel_ring_emit(ring, upper_32_bits(offset));
	intel_ring_emit(ring, MI_NOOP);
	intel_ring_advance(ring);

	return 0;
}

static int
hsw_ring_dispatch_execbuffer(struct drm_i915_gem_request *req,
			     u64 offset, u32 len,
			     unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START |
			(dispatch_flags & I915_DISPATCH_SECURE ?
			 0 : MI_BATCH_PPGTT_HSW | MI_BATCH_NON_SECURE_HSW) |
			(dispatch_flags & I915_DISPATCH_RS ?
			 MI_BATCH_RESOURCE_STREAMER : 0));
	/* bit0-7 is the length on GEN6+ */
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

static int
gen6_ring_dispatch_execbuffer(struct drm_i915_gem_request *req,
			      u64 offset, u32 len,
			      unsigned dispatch_flags)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	ret = intel_ring_begin(req, 2);
	if (ret)
		return ret;

	intel_ring_emit(ring,
			MI_BATCH_BUFFER_START |
			(dispatch_flags & I915_DISPATCH_SECURE ?
			 0 : MI_BATCH_NON_SECURE_I965));
	/* bit0-7 is the length on GEN6+ */
	intel_ring_emit(ring, offset);
	intel_ring_advance(ring);

	return 0;
}

/* Blitter support (SandyBridge+) */

static int gen6_ring_flush(struct drm_i915_gem_request *req,
			   u32 invalidate, u32 flush)
{
	struct intel_engine_cs *ring = req->ring;
	struct drm_device *dev = ring->dev;
	uint32_t cmd;
	int ret;

	ret = intel_ring_begin(req, 4);
	if (ret)
		return ret;

	cmd = MI_FLUSH_DW;
	if (INTEL_INFO(dev)->gen >= 8)
		cmd += 1;

	/* We always require a command barrier so that subsequent
	 * commands, such as breadcrumb interrupts, are strictly ordered
	 * wrt the contents of the write cache being flushed to memory
	 * (and thus being coherent from the CPU).
	 */
	cmd |= MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;

	/*
	 * Bspec vol 1c.3 - blitter engine command streamer:
	 * "If ENABLED, all TLBs will be invalidated once the flush
	 * operation is complete. This bit is only valid when the
	 * Post-Sync Operation field is a value of 1h or 3h."
	 */
	if (invalidate & I915_GEM_DOMAIN_RENDER)
		cmd |= MI_INVALIDATE_TLB;
	intel_ring_emit(ring, cmd);
	intel_ring_emit(ring, I915_GEM_HWS_SCRATCH_ADDR | MI_FLUSH_DW_USE_GTT);
	if (INTEL_INFO(dev)->gen >= 8) {
		intel_ring_emit(ring, 0); /* upper addr */
		intel_ring_emit(ring, 0); /* value */
	} else  {
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, MI_NOOP);
	}
	intel_ring_advance(ring);

	return 0;
}

int intel_init_render_ring_buffer(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *ring = &dev_priv->ring[RCS];
	struct drm_i915_gem_object *obj;
	int ret;

	ring->name = "render ring";
	ring->id = RCS;
	ring->mmio_base = RENDER_RING_BASE;

	if (INTEL_INFO(dev)->gen >= 8) {
		if (i915_semaphore_is_enabled(dev)) {
			obj = i915_gem_alloc_object(dev, 4096);
			if (obj == NULL) {
				DRM_ERROR("Failed to allocate semaphore bo. Disabling semaphores\n");
				i915.semaphores = 0;
			} else {
				i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);
				ret = i915_gem_obj_ggtt_pin(obj, 0, PIN_NONBLOCK);
				if (ret != 0) {
					drm_gem_object_unreference(&obj->base);
					DRM_ERROR("Failed to pin semaphore bo. Disabling semaphores\n");
					i915.semaphores = 0;
				} else
					dev_priv->semaphore_obj = obj;
			}
		}

		ring->init_context = intel_rcs_ctx_init;
		ring->add_request = gen6_add_request;
		ring->flush = gen8_render_ring_flush;
		ring->irq_get = gen8_ring_get_irq;
		ring->irq_put = gen8_ring_put_irq;
		ring->irq_enable_mask = GT_RENDER_USER_INTERRUPT;
		ring->get_seqno = gen6_ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (i915_semaphore_is_enabled(dev)) {
			WARN_ON(!dev_priv->semaphore_obj);
			ring->semaphore.sync_to = gen8_ring_sync;
			ring->semaphore.signal = gen8_rcs_signal;
			GEN8_RING_SEMAPHORE_INIT;
		}
	} else if (INTEL_INFO(dev)->gen >= 6) {
		ring->init_context = intel_rcs_ctx_init;
		ring->add_request = gen6_add_request;
		ring->flush = gen7_render_ring_flush;
		if (INTEL_INFO(dev)->gen == 6)
			ring->flush = gen6_render_ring_flush;
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->irq_enable_mask = GT_RENDER_USER_INTERRUPT;
		ring->get_seqno = gen6_ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (i915_semaphore_is_enabled(dev)) {
			ring->semaphore.sync_to = gen6_ring_sync;
			ring->semaphore.signal = gen6_signal;
			/*
			 * The current semaphore is only applied on pre-gen8
			 * platform.  And there is no VCS2 ring on the pre-gen8
			 * platform. So the semaphore between RCS and VCS2 is
			 * initialized as INVALID.  Gen8 will initialize the
			 * sema between VCS2 and RCS later.
			 */
			ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_RV;
			ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_RB;
			ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_RVE;
			ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.signal[RCS] = GEN6_NOSYNC;
			ring->semaphore.mbox.signal[VCS] = GEN6_VRSYNC;
			ring->semaphore.mbox.signal[BCS] = GEN6_BRSYNC;
			ring->semaphore.mbox.signal[VECS] = GEN6_VERSYNC;
			ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
		}
	} else if (IS_GEN5(dev)) {
		ring->add_request = pc_render_add_request;
		ring->flush = gen4_render_ring_flush;
		ring->get_seqno = pc_render_get_seqno;
		ring->set_seqno = pc_render_set_seqno;
		ring->irq_get = gen5_ring_get_irq;
		ring->irq_put = gen5_ring_put_irq;
		ring->irq_enable_mask = GT_RENDER_USER_INTERRUPT |
					GT_RENDER_PIPECTL_NOTIFY_INTERRUPT;
	} else {
		ring->add_request = i9xx_add_request;
		if (INTEL_INFO(dev)->gen < 4)
			ring->flush = gen2_render_ring_flush;
		else
			ring->flush = gen4_render_ring_flush;
		ring->get_seqno = ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (IS_GEN2(dev)) {
			ring->irq_get = i8xx_ring_get_irq;
			ring->irq_put = i8xx_ring_put_irq;
		} else {
			ring->irq_get = i9xx_ring_get_irq;
			ring->irq_put = i9xx_ring_put_irq;
		}
		ring->irq_enable_mask = I915_USER_INTERRUPT;
	}
	ring->write_tail = ring_write_tail;

	if (IS_HASWELL(dev))
		ring->dispatch_execbuffer = hsw_ring_dispatch_execbuffer;
	else if (IS_GEN8(dev))
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
	else if (INTEL_INFO(dev)->gen >= 6)
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
	else if (INTEL_INFO(dev)->gen >= 4)
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	else if (IS_I830(dev) || IS_845G(dev))
		ring->dispatch_execbuffer = i830_dispatch_execbuffer;
	else
		ring->dispatch_execbuffer = i915_dispatch_execbuffer;
	ring->init_hw = init_render_ring;
	ring->cleanup = render_ring_cleanup;

	/* Workaround batchbuffer to combat CS tlb bug. */
	if (HAS_BROKEN_CS_TLB(dev)) {
		obj = i915_gem_alloc_object(dev, I830_WA_SIZE);
		if (obj == NULL) {
			DRM_ERROR("Failed to allocate batch bo\n");
			return -ENOMEM;
		}

		ret = i915_gem_obj_ggtt_pin(obj, 0, 0);
		if (ret != 0) {
			drm_gem_object_unreference(&obj->base);
			DRM_ERROR("Failed to ping batch bo\n");
			return ret;
		}

		ring->scratch.obj = obj;
		ring->scratch.gtt_offset = i915_gem_obj_ggtt_offset(obj);
	}

	ret = intel_init_ring_buffer(dev, ring);
	if (ret)
		return ret;

	if (INTEL_INFO(dev)->gen >= 5) {
		ret = intel_init_pipe_control(ring);
		if (ret)
			return ret;
	}

	return 0;
}

int intel_init_bsd_ring_buffer(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *ring = &dev_priv->ring[VCS];

	ring->name = "bsd ring";
	ring->id = VCS;

	ring->write_tail = ring_write_tail;
	if (INTEL_INFO(dev)->gen >= 6) {
		ring->mmio_base = GEN6_BSD_RING_BASE;
		/* gen6 bsd needs a special wa for tail updates */
		if (IS_GEN6(dev))
			ring->write_tail = gen6_bsd_ring_write_tail;
		ring->flush = gen6_bsd_ring_flush;
		ring->add_request = gen6_add_request;
		ring->get_seqno = gen6_ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (INTEL_INFO(dev)->gen >= 8) {
			ring->irq_enable_mask =
				GT_RENDER_USER_INTERRUPT << GEN8_VCS1_IRQ_SHIFT;
			ring->irq_get = gen8_ring_get_irq;
			ring->irq_put = gen8_ring_put_irq;
			ring->dispatch_execbuffer =
				gen8_ring_dispatch_execbuffer;
			if (i915_semaphore_is_enabled(dev)) {
				ring->semaphore.sync_to = gen8_ring_sync;
				ring->semaphore.signal = gen8_xcs_signal;
				GEN8_RING_SEMAPHORE_INIT;
			}
		} else {
			ring->irq_enable_mask = GT_BSD_USER_INTERRUPT;
			ring->irq_get = gen6_ring_get_irq;
			ring->irq_put = gen6_ring_put_irq;
			ring->dispatch_execbuffer =
				gen6_ring_dispatch_execbuffer;
			if (i915_semaphore_is_enabled(dev)) {
				ring->semaphore.sync_to = gen6_ring_sync;
				ring->semaphore.signal = gen6_signal;
				ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_VR;
				ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_INVALID;
				ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_VB;
				ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_VVE;
				ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
				ring->semaphore.mbox.signal[RCS] = GEN6_RVSYNC;
				ring->semaphore.mbox.signal[VCS] = GEN6_NOSYNC;
				ring->semaphore.mbox.signal[BCS] = GEN6_BVSYNC;
				ring->semaphore.mbox.signal[VECS] = GEN6_VEVSYNC;
				ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
			}
		}
	} else {
		ring->mmio_base = BSD_RING_BASE;
		ring->flush = bsd_ring_flush;
		ring->add_request = i9xx_add_request;
		ring->get_seqno = ring_get_seqno;
		ring->set_seqno = ring_set_seqno;
		if (IS_GEN5(dev)) {
			ring->irq_enable_mask = ILK_BSD_USER_INTERRUPT;
			ring->irq_get = gen5_ring_get_irq;
			ring->irq_put = gen5_ring_put_irq;
		} else {
			ring->irq_enable_mask = I915_BSD_USER_INTERRUPT;
			ring->irq_get = i9xx_ring_get_irq;
			ring->irq_put = i9xx_ring_put_irq;
		}
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	}
	ring->init_hw = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

/**
 * Initialize the second BSD ring (eg. Broadwell GT3, Skylake GT3)
 */
int intel_init_bsd2_ring_buffer(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *ring = &dev_priv->ring[VCS2];

	ring->name = "bsd2 ring";
	ring->id = VCS2;

	ring->write_tail = ring_write_tail;
	ring->mmio_base = GEN8_BSD2_RING_BASE;
	ring->flush = gen6_bsd_ring_flush;
	ring->add_request = gen6_add_request;
	ring->get_seqno = gen6_ring_get_seqno;
	ring->set_seqno = ring_set_seqno;
	ring->irq_enable_mask =
			GT_RENDER_USER_INTERRUPT << GEN8_VCS2_IRQ_SHIFT;
	ring->irq_get = gen8_ring_get_irq;
	ring->irq_put = gen8_ring_put_irq;
	ring->dispatch_execbuffer =
			gen8_ring_dispatch_execbuffer;
	if (i915_semaphore_is_enabled(dev)) {
		ring->semaphore.sync_to = gen8_ring_sync;
		ring->semaphore.signal = gen8_xcs_signal;
		GEN8_RING_SEMAPHORE_INIT;
	}
	ring->init_hw = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int intel_init_blt_ring_buffer(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *ring = &dev_priv->ring[BCS];

	ring->name = "blitter ring";
	ring->id = BCS;

	ring->mmio_base = BLT_RING_BASE;
	ring->write_tail = ring_write_tail;
	ring->flush = gen6_ring_flush;
	ring->add_request = gen6_add_request;
	ring->get_seqno = gen6_ring_get_seqno;
	ring->set_seqno = ring_set_seqno;
	if (INTEL_INFO(dev)->gen >= 8) {
		ring->irq_enable_mask =
			GT_RENDER_USER_INTERRUPT << GEN8_BCS_IRQ_SHIFT;
		ring->irq_get = gen8_ring_get_irq;
		ring->irq_put = gen8_ring_put_irq;
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
		if (i915_semaphore_is_enabled(dev)) {
			ring->semaphore.sync_to = gen8_ring_sync;
			ring->semaphore.signal = gen8_xcs_signal;
			GEN8_RING_SEMAPHORE_INIT;
		}
	} else {
		ring->irq_enable_mask = GT_BLT_USER_INTERRUPT;
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
		if (i915_semaphore_is_enabled(dev)) {
			ring->semaphore.signal = gen6_signal;
			ring->semaphore.sync_to = gen6_ring_sync;
			/*
			 * The current semaphore is only applied on pre-gen8
			 * platform.  And there is no VCS2 ring on the pre-gen8
			 * platform. So the semaphore between BCS and VCS2 is
			 * initialized as INVALID.  Gen8 will initialize the
			 * sema between BCS and VCS2 later.
			 */
			ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_BR;
			ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_BV;
			ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_BVE;
			ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.signal[RCS] = GEN6_RBSYNC;
			ring->semaphore.mbox.signal[VCS] = GEN6_VBSYNC;
			ring->semaphore.mbox.signal[BCS] = GEN6_NOSYNC;
			ring->semaphore.mbox.signal[VECS] = GEN6_VEBSYNC;
			ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
		}
	}
	ring->init_hw = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int intel_init_vebox_ring_buffer(struct drm_device *dev)
{
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_engine_cs *ring = &dev_priv->ring[VECS];

	ring->name = "video enhancement ring";
	ring->id = VECS;

	ring->mmio_base = VEBOX_RING_BASE;
	ring->write_tail = ring_write_tail;
	ring->flush = gen6_ring_flush;
	ring->add_request = gen6_add_request;
	ring->get_seqno = gen6_ring_get_seqno;
	ring->set_seqno = ring_set_seqno;

	if (INTEL_INFO(dev)->gen >= 8) {
		ring->irq_enable_mask =
			GT_RENDER_USER_INTERRUPT << GEN8_VECS_IRQ_SHIFT;
		ring->irq_get = gen8_ring_get_irq;
		ring->irq_put = gen8_ring_put_irq;
		ring->dispatch_execbuffer = gen8_ring_dispatch_execbuffer;
		if (i915_semaphore_is_enabled(dev)) {
			ring->semaphore.sync_to = gen8_ring_sync;
			ring->semaphore.signal = gen8_xcs_signal;
			GEN8_RING_SEMAPHORE_INIT;
		}
	} else {
		ring->irq_enable_mask = PM_VEBOX_USER_INTERRUPT;
		ring->irq_get = hsw_vebox_get_irq;
		ring->irq_put = hsw_vebox_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
		if (i915_semaphore_is_enabled(dev)) {
			ring->semaphore.sync_to = gen6_ring_sync;
			ring->semaphore.signal = gen6_signal;
			ring->semaphore.mbox.wait[RCS] = MI_SEMAPHORE_SYNC_VER;
			ring->semaphore.mbox.wait[VCS] = MI_SEMAPHORE_SYNC_VEV;
			ring->semaphore.mbox.wait[BCS] = MI_SEMAPHORE_SYNC_VEB;
			ring->semaphore.mbox.wait[VECS] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.wait[VCS2] = MI_SEMAPHORE_SYNC_INVALID;
			ring->semaphore.mbox.signal[RCS] = GEN6_RVESYNC;
			ring->semaphore.mbox.signal[VCS] = GEN6_VVESYNC;
			ring->semaphore.mbox.signal[BCS] = GEN6_BVESYNC;
			ring->semaphore.mbox.signal[VECS] = GEN6_NOSYNC;
			ring->semaphore.mbox.signal[VCS2] = GEN6_NOSYNC;
		}
	}
	ring->init_hw = init_ring_common;

	return intel_init_ring_buffer(dev, ring);
}

int
intel_ring_flush_all_caches(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	int ret;

	if (!ring->gpu_caches_dirty)
		return 0;

	ret = ring->flush(req, 0, I915_GEM_GPU_DOMAINS);
	if (ret)
		return ret;

	trace_i915_gem_ring_flush(req, 0, I915_GEM_GPU_DOMAINS);

	ring->gpu_caches_dirty = false;
	return 0;
}

int
intel_ring_invalidate_all_caches(struct drm_i915_gem_request *req)
{
	struct intel_engine_cs *ring = req->ring;
	uint32_t flush_domains;
	int ret;

	flush_domains = 0;
	if (ring->gpu_caches_dirty)
		flush_domains = I915_GEM_GPU_DOMAINS;

	ret = ring->flush(req, I915_GEM_GPU_DOMAINS, flush_domains);
	if (ret)
		return ret;

	trace_i915_gem_ring_flush(req, I915_GEM_GPU_DOMAINS, flush_domains);

	ring->gpu_caches_dirty = false;
	return 0;
}

void
intel_stop_ring_buffer(struct intel_engine_cs *ring)
{
	int ret;

	if (!intel_ring_initialized(ring))
		return;

	ret = intel_ring_idle(ring);
	if (ret && !i915_reset_in_progress(&to_i915(ring->dev)->gpu_error))
		DRM_ERROR("failed to quiesce %s whilst cleaning up: %d\n",
			  ring->name, ret);

	stop_ring(ring);
}
@


1.32
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@d476 1
a476 1
	addr = dev_priv->status_page_dmah->map->dm_segs[0].ds_addr;
d478 1
a478 1
		addr |= (dev_priv->status_page_dmah->map->dm_segs[0].ds_addr >> 28) & 0xf0;
a1931 1
#ifdef __linux__
a1932 3
#else
	drm_dmamem_free(dev_priv->dmat, dev_priv->status_page_dmah);
#endif
a2005 1
#ifdef __linux__
a2007 4
#else
		dev_priv->status_page_dmah = drm_dmamem_alloc(dev_priv->dmat,
		    PAGE_SIZE, PAGE_SIZE, 1, PAGE_SIZE, 0, BUS_DMA_READ);
#endif
d2012 1
a2012 1
	ring->status_page.page_addr = (u32 *)dev_priv->status_page_dmah->kva;
@


1.31
log
@3.14 backports of some Broadwell fixes from
http://lists.freedesktop.org/archives/intel-gfx/2014-March/042121.html

Ben Widawsky
drm/i915/bdw: Restore PPAT on thaw
a2319c08bfd849ea32b4f890ce92df86074c5731

Ville Syrjala
drm/i915: We implement WaDisableAsyncFlipPerfMode:bdw
8285222c487b61c48b9b955b82598544c3c06050

Ben Widawsky
drm/i915/bdw: Use scratch page table for GEN8 PPGTT
8407bb9129da95fc4099b84cdbbc23e6d4f66aee

Jani Nikula
drm/i915: don't flood the logs about bdw semaphores
c923facd535b97972b5bb7d3df4fcafd61a63a5e

Ville Syrjala
drm/i915: Implement WaDisableSDEUnitClockGating:bdw
4f1ca9e94057de098d65bc7477e8f89dd51609aa

Ville Syrjala
drm/i915: Don't clobber CHICKEN_PIPESL_1 on BDW
c7c656226842679bcd9f39dc24441b4ff398a850

Kenneth Graunke
drm/i915: Add a partial instruction shootdown workaround on Broadwell.
c8966e1058e1e8ae2eec4211157847032829697a

Damien Lespiau
drm/i915/bdw: The TLB invalidation mechanism has been removed from INSTPM
dc616b89dbc4bb6a99884d214bd1ed1e0eef59a0

Kenneth Graunke
drm/i915: Add thread stall DOP clock gating workaround on Broadwell.
1411e6a57a1836ba8a3d4f17c8733b2fbaf0f005

Ville Syrjala
drm/i915: Disable semaphore wait event idle message on BDW
295e8bb73a4785b65db6655fbf6ad57c4177b551

Mika Kuoppala
drm/i915: Do forcewake reset on gen8
0a089e3355d77f758e46db54a0a81d4b58a28cc3

Mika Kuoppala
drm/i915: Fix forcewake counts for gen8
e9dbd2b20201b49b04476d2e5763faa822967913

ok kettenis@@
@
text
@a0 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.30 2015/09/23 23:12:12 kettenis Exp $	*/
d36 2
a37 1
static inline int ring_space(struct intel_ring_buffer *ring)
d39 31
a69 4
	int space = (ring->head & HEAD_ADDR) - (ring->tail + I915_RING_FREE_SPACE);
	if (space < 0)
		space += ring->size;
	return space;
d72 7
a78 1
void __intel_ring_advance(struct intel_ring_buffer *ring)
d81 2
d84 5
a88 2
	ring->tail &= ring->size - 1;
	if (dev_priv->gpu_error.stop_rings & intel_ring_flag(ring))
d90 1
a90 1
	ring->write_tail(ring, ring->tail);
d94 1
a94 1
gen2_render_ring_flush(struct intel_ring_buffer *ring,
d98 1
d109 1
a109 1
	ret = intel_ring_begin(ring, 2);
d121 1
a121 1
gen4_render_ring_flush(struct intel_ring_buffer *ring,
d125 1
d168 1
a168 1
	ret = intel_ring_begin(ring, 2);
d217 1
a217 1
intel_emit_post_sync_nonzero_flush(struct intel_ring_buffer *ring)
d219 2
a220 1
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
d223 1
a223 2

	ret = intel_ring_begin(ring, 6);
d236 1
a236 1
	ret = intel_ring_begin(ring, 6);
d252 2
a253 2
gen6_render_ring_flush(struct intel_ring_buffer *ring,
                         u32 invalidate_domains, u32 flush_domains)
d255 1
d257 1
a257 1
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
d261 1
a261 1
	ret = intel_emit_post_sync_nonzero_flush(ring);
d291 1
a291 1
	ret = intel_ring_begin(ring, 4);
d305 1
a305 1
gen7_render_ring_cs_stall_wa(struct intel_ring_buffer *ring)
d307 1
d310 1
a310 1
	ret = intel_ring_begin(ring, 4);
a323 23
static int gen7_ring_fbc_flush(struct intel_ring_buffer *ring, u32 value)
{
	int ret;

	if (!ring->fbc_dirty)
		return 0;

	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;
	/* WaFbcNukeOn3DBlt:ivb/hsw */
	intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
	intel_ring_emit(ring, MSG_FBC_REND_STATE);
	intel_ring_emit(ring, value);
	intel_ring_emit(ring, MI_STORE_REGISTER_MEM(1) | MI_SRM_LRM_GLOBAL_GTT);
	intel_ring_emit(ring, MSG_FBC_REND_STATE);
	intel_ring_emit(ring, ring->scratch.gtt_offset + 256);
	intel_ring_advance(ring);

	ring->fbc_dirty = false;
	return 0;
}

d325 1
a325 1
gen7_render_ring_flush(struct intel_ring_buffer *ring,
d328 1
d330 1
a330 1
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
d350 2
d372 1
a372 1
		gen7_render_ring_cs_stall_wa(ring);
d375 1
a375 1
	ret = intel_ring_begin(ring, 4);
d385 21
a405 2
	if (!invalidate_domains && flush_domains)
		return gen7_ring_fbc_flush(ring, FBC_REND_NUKE);
d411 1
a411 1
gen8_render_ring_flush(struct intel_ring_buffer *ring,
d415 1
a415 1
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
d423 2
d435 8
d445 1
a445 14
	ret = intel_ring_begin(ring, 6);
	if (ret)
		return ret;

	intel_ring_emit(ring, GFX_OP_PIPE_CONTROL(6));
	intel_ring_emit(ring, flags);
	intel_ring_emit(ring, scratch_addr);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, 0);
	intel_ring_advance(ring);

	return 0;

d448 1
a448 1
static void ring_write_tail(struct intel_ring_buffer *ring,
d451 1
a451 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
d455 1
a455 1
u32 intel_ring_get_active_head(struct intel_ring_buffer *ring)
d457 10
a466 3
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	u32 acthd_reg = INTEL_INFO(ring->dev)->gen >= 4 ?
			RING_ACTHD(ring->mmio_base) : ACTHD;
d468 1
a468 1
	return I915_READ(acthd_reg);
d471 1
a471 1
static void ring_setup_phys_status_page(struct intel_ring_buffer *ring)
d482 1
a482 1
static int init_ring_common(struct intel_ring_buffer *ring)
d485 58
a542 4
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct drm_i915_gem_object *obj = ring->obj;
	int ret = 0;
	u32 head;
d544 3
a546 1
	gen6_gt_force_wake_get(dev_priv, FORCEWAKE_ALL);
d548 12
a559 4
	if (I915_NEED_GFX_HWS(dev))
		intel_ring_setup_status_page(ring);
	else
		ring_setup_phys_status_page(ring);
a560 1
	/* Stop the ring if it's running. */
d565 4
a568 1
	head = I915_READ_HEAD(ring) & HEAD_ADDR;
d570 15
a584 2
	/* G45 ring initialization fails to reset head to zero */
	if (head != 0) {
d593 1
a593 3
		I915_WRITE_HEAD(ring, 0);

		if (I915_READ_HEAD(ring) & HEAD_ADDR) {
d601 2
d606 5
d619 8
d628 1
a628 1
			((ring->size - PAGE_SIZE) & RING_NR_PAGES)
d636 5
a640 6
				"ctl %08x head %08x tail %08x start %08x\n",
				ring->name,
				I915_READ_CTL(ring),
				I915_READ_HEAD(ring),
				I915_READ_TAIL(ring),
				I915_READ_START(ring));
d645 4
a648 8
	if (!drm_core_check_feature(ring->dev, DRIVER_MODESET))
		i915_kernel_lost_context(ring->dev);
	else {
		ring->head = I915_READ_HEAD(ring);
		ring->tail = I915_READ_TAIL(ring) & TAIL_ADDR;
		ring->space = ring_space(ring);
		ring->last_retired_head = -1;
	}
d653 1
a653 1
	gen6_gt_force_wake_put(dev_priv, FORCEWAKE_ALL);
d658 19
a676 2
static int
init_pipe_control(struct intel_ring_buffer *ring)
d680 1
a680 2
	if (ring->scratch.obj)
		return 0;
d689 3
a691 1
	i915_gem_object_set_cache_level(ring->scratch.obj, I915_CACHE_LLC);
d693 1
a693 1
	ret = i915_gem_obj_ggtt_pin(ring->scratch.obj, 4096, true, false);
d698 2
a699 8
	ring->scratch.cpu_page = (volatile u_int32_t *)vm_map_min(kernel_map);
	ring->scratch.obj->base.uao->pgops->pgo_reference(ring->scratch.obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&ring->scratch.cpu_page,
	    PAGE_SIZE, ring->scratch.obj->base.uao, 0, 0,
	    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_READ | PROT_WRITE,
	    MAP_INHERIT_SHARE, MADV_RANDOM, 0));
	if (ret != 0) {
		ring->scratch.obj->base.uao->pgops->pgo_detach(ring->scratch.obj->base.uao);
d709 1
a709 1
	i915_gem_object_unpin(ring->scratch.obj);
d716 444
a1159 1
static int init_render_ring(struct intel_ring_buffer *ring)
d1164 2
d1167 2
a1168 1
	if (INTEL_INFO(dev)->gen > 3)
d1175 1
a1175 1
	 * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv,bdw
d1177 1
a1177 1
	if (INTEL_INFO(dev)->gen >= 6)
d1181 1
d1184 78
a1261 1
			   _MASKED_BIT_ENABLE(GFX_TLB_INVALIDATE_ALWAYS));
d1263 2
a1264 4
	if (IS_GEN7(dev))
		I915_WRITE(GFX_MODE_GEN7,
			   _MASKED_BIT_DISABLE(GFX_TLB_INVALIDATE_ALWAYS) |
			   _MASKED_BIT_ENABLE(GFX_REPLAY_MODE));
d1266 9
a1274 5
	if (INTEL_INFO(dev)->gen >= 5) {
		ret = init_pipe_control(ring);
		if (ret)
			return ret;
	}
d1276 3
a1278 8
	if (IS_GEN6(dev)) {
		/* From the Sandybridge PRM, volume 1 part 3, page 24:
		 * "If this bit is set, STCunit will have LRA as replacement
		 *  policy. [...] This bit must be reset.  LRA replacement
		 *  policy is not supported."
		 */
		I915_WRITE(CACHE_MODE_0,
			   _MASKED_BIT_DISABLE(CM0_STC_EVICT_DISABLE_LRA_SNB));
d1280 3
a1282 7
		/* This is not explicitly set for GEN6, so read the register.
		 * see intel_ring_mi_set_context() for why we care.
		 * TODO: consider explicitly setting the bit for GEN5
		 */
		ring->itlb_before_ctx_switch =
			!!(I915_READ(GFX_MODE) & GFX_TLB_INVALIDATE_ALWAYS);
	}
d1284 5
a1288 2
	if (INTEL_INFO(dev)->gen >= 6)
		I915_WRITE(INSTPM, _MASKED_BIT_ENABLE(INSTPM_FORCE_ORDERING));
d1290 11
a1300 2
	if (HAS_L3_DPF(dev))
		I915_WRITE_IMR(ring, ~GT_PARITY_ERROR(dev));
d1302 1
a1302 1
	return ret;
d1305 2
a1306 1
static void render_ring_cleanup(struct intel_ring_buffer *ring)
d1308 10
a1317 1
	struct drm_device *dev = ring->dev;
d1319 3
a1321 2
	if (ring->scratch.obj == NULL)
		return;
d1323 8
a1330 4
	if (INTEL_INFO(dev)->gen >= 5) {
		uvm_unmap(kernel_map, (vaddr_t)ring->scratch.cpu_page,
		    (vaddr_t)ring->scratch.cpu_page + PAGE_SIZE);
		i915_gem_object_unpin(ring->scratch.obj);
d1333 3
a1335 3
	drm_gem_object_unreference(&ring->scratch.obj->base);
	ring->scratch.obj = NULL;
}
d1337 1
a1337 14
static void
update_mboxes(struct intel_ring_buffer *ring,
	      u32 mmio_offset)
{
/* NB: In order to be able to do semaphore MBOX updates for varying number
 * of rings, it's easiest if we round up each individual update to a
 * multiple of 2 (since ring updates must always be a multiple of 2)
 * even though the actual update only requires 3 dwords.
 */
#define MBOX_UPDATE_DWORDS 4
	intel_ring_emit(ring, MI_LOAD_REGISTER_IMM(1));
	intel_ring_emit(ring, mmio_offset);
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
	intel_ring_emit(ring, MI_NOOP);
d1342 2
a1343 3
 * 
 * @@ring - ring that is adding a request
 * @@seqno - return seqno stuck into the ring
d1349 1
a1349 1
gen6_add_request(struct intel_ring_buffer *ring)
d1351 2
a1352 4
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	struct intel_ring_buffer *useless;
	int i, ret, num_dwords = 4;
d1354 4
a1357 3
	if (i915_semaphore_is_enabled(dev))
		num_dwords += ((I915_NUM_RINGS-1) * MBOX_UPDATE_DWORDS);
#undef MBOX_UPDATE_DWORDS
a1358 1
	ret = intel_ring_begin(ring, num_dwords);
a1361 8
	if (i915_semaphore_is_enabled(dev)) {
		for_each_ring(useless, dev_priv, i) {
			u32 mbox_reg = ring->signal_mbox[i];
			if (mbox_reg != GEN6_NOSYNC)
				update_mboxes(ring, mbox_reg);
		}
	}

d1364 1
a1364 1
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
d1385 1
d1387 2
a1388 2
gen6_ring_sync(struct intel_ring_buffer *waiter,
	       struct intel_ring_buffer *signaller,
d1391 2
d1394 24
d1421 2
d1430 1
a1430 2
	WARN_ON(signaller->semaphore_register[waiter->id] ==
		MI_SEMAPHORE_SYNC_INVALID);
d1432 1
a1432 1
	ret = intel_ring_begin(waiter, 4);
d1438 1
a1438 3
		intel_ring_emit(waiter,
				dw1 |
				signaller->semaphore_register[waiter->id]);
d1463 1
a1463 1
pc_render_add_request(struct intel_ring_buffer *ring)
d1465 2
a1466 1
	u32 scratch_addr = ring->scratch.gtt_offset + 128;
d1477 1
a1477 1
	ret = intel_ring_begin(ring, 32);
d1485 1
a1485 1
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
d1488 1
a1488 1
	scratch_addr += 128; /* write to separate cachelines */
d1490 1
a1490 1
	scratch_addr += 128;
d1492 1
a1492 1
	scratch_addr += 128;
d1494 1
a1494 1
	scratch_addr += 128;
d1496 1
a1496 1
	scratch_addr += 128;
d1504 1
a1504 1
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
d1512 1
a1512 1
gen6_ring_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
d1517 5
a1521 2
	if (!lazy_coherency)
		intel_ring_get_active_head(ring);
d1526 1
a1526 1
ring_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
d1532 1
a1532 1
ring_set_seqno(struct intel_ring_buffer *ring, u32 seqno)
d1538 1
a1538 1
pc_render_get_seqno(struct intel_ring_buffer *ring, bool lazy_coherency)
d1544 1
a1544 1
pc_render_set_seqno(struct intel_ring_buffer *ring, u32 seqno)
d1550 1
a1550 1
gen5_ring_get_irq(struct intel_ring_buffer *ring)
d1553 1
a1553 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1556 1
a1556 1
	if (!dev->irq_enabled)
d1561 1
a1561 1
		ilk_enable_gt_irq(dev_priv, ring->irq_enable_mask);
d1568 1
a1568 1
gen5_ring_put_irq(struct intel_ring_buffer *ring)
d1571 1
a1571 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1576 1
a1576 1
		ilk_disable_gt_irq(dev_priv, ring->irq_enable_mask);
d1581 1
a1581 1
i9xx_ring_get_irq(struct intel_ring_buffer *ring)
d1584 1
a1584 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1587 1
a1587 1
	if (!dev->irq_enabled)
d1602 1
a1602 1
i9xx_ring_put_irq(struct intel_ring_buffer *ring)
d1605 1
a1605 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1618 1
a1618 1
i8xx_ring_get_irq(struct intel_ring_buffer *ring)
d1621 1
a1621 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1624 1
a1624 1
	if (!dev->irq_enabled)
d1639 1
a1639 1
i8xx_ring_put_irq(struct intel_ring_buffer *ring)
d1642 1
a1642 1
	drm_i915_private_t *dev_priv = dev->dev_private;
a1653 53
void intel_ring_setup_status_page(struct intel_ring_buffer *ring)
{
	struct drm_device *dev = ring->dev;
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	u32 mmio = 0;

	/* The ring status page addresses are no longer next to the rest of
	 * the ring registers as of gen7.
	 */
	if (IS_GEN7(dev)) {
		switch (ring->id) {
		case RCS:
			mmio = RENDER_HWS_PGA_GEN7;
			break;
		case BCS:
			mmio = BLT_HWS_PGA_GEN7;
			break;
		case VCS:
			mmio = BSD_HWS_PGA_GEN7;
			break;
		case VECS:
			mmio = VEBOX_HWS_PGA_GEN7;
			break;
		}
	} else if (IS_GEN6(ring->dev)) {
		mmio = RING_HWS_PGA_GEN6(ring->mmio_base);
	} else {
		/* XXX: gen8 returns to sanity */
		mmio = RING_HWS_PGA(ring->mmio_base);
	}

	I915_WRITE(mmio, (u32)ring->status_page.gfx_addr);
	POSTING_READ(mmio);

	/*
	 * Flush the TLB for this page
	 *
	 * FIXME: These two bits have disappeared on gen8, so a question
	 * arises: do we still need this and if so how should we go about
	 * invalidating the TLB?
	 */
	if (INTEL_INFO(dev)->gen >= 6 && INTEL_INFO(dev)->gen < 8) {
		u32 reg = RING_INSTPM(ring->mmio_base);
		I915_WRITE(reg,
			   _MASKED_BIT_ENABLE(INSTPM_TLB_INVALIDATE |
					      INSTPM_SYNC_FLUSH));
		if (wait_for((I915_READ(reg) & INSTPM_SYNC_FLUSH) == 0,
			     1000))
			DRM_ERROR("%s: wait for SyncFlush to complete for TLB invalidation timed out\n",
				  ring->name);
	}
}

d1655 1
a1655 1
bsd_ring_flush(struct intel_ring_buffer *ring,
d1659 1
d1662 1
a1662 1
	ret = intel_ring_begin(ring, 2);
d1673 1
a1673 1
i9xx_add_request(struct intel_ring_buffer *ring)
d1675 1
d1678 1
a1678 1
	ret = intel_ring_begin(ring, 4);
d1684 1
a1684 1
	intel_ring_emit(ring, ring->outstanding_lazy_seqno);
d1692 1
a1692 1
gen6_ring_get_irq(struct intel_ring_buffer *ring)
d1695 1
a1695 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1698 2
a1699 2
	if (!dev->irq_enabled)
	       return false;
d1709 1
a1709 1
		ilk_enable_gt_irq(dev_priv, ring->irq_enable_mask);
d1717 1
a1717 1
gen6_ring_put_irq(struct intel_ring_buffer *ring)
d1720 1
a1720 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1729 1
a1729 1
		ilk_disable_gt_irq(dev_priv, ring->irq_enable_mask);
d1735 1
a1735 1
hsw_vebox_get_irq(struct intel_ring_buffer *ring)
d1741 1
a1741 1
	if (!dev->irq_enabled)
d1747 1
a1747 1
		snb_enable_pm_irq(dev_priv, ring->irq_enable_mask);
d1755 1
a1755 1
hsw_vebox_put_irq(struct intel_ring_buffer *ring)
a1760 3
	if (!dev->irq_enabled)
		return;

d1764 1
a1764 1
		snb_disable_pm_irq(dev_priv, ring->irq_enable_mask);
d1770 1
a1770 1
gen8_ring_get_irq(struct intel_ring_buffer *ring)
d1776 1
a1776 1
	if (!dev->irq_enabled)
d1796 1
a1796 1
gen8_ring_put_irq(struct intel_ring_buffer *ring)
d1816 3
a1818 3
i965_dispatch_execbuffer(struct intel_ring_buffer *ring,
			 u32 offset, u32 length,
			 unsigned flags)
d1820 1
d1823 1
a1823 1
	ret = intel_ring_begin(ring, 2);
d1830 2
a1831 1
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_I965));
d1840 2
d1843 3
a1845 3
i830_dispatch_execbuffer(struct intel_ring_buffer *ring,
				u32 offset, u32 len,
				unsigned flags)
d1847 2
d1851 3
a1853 4
	if (flags & I915_DISPATCH_PINNED) {
		ret = intel_ring_begin(ring, 4);
		if (ret)
			return ret;
d1855 8
a1862 7
		intel_ring_emit(ring, MI_BATCH_BUFFER);
		intel_ring_emit(ring, offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
		intel_ring_emit(ring, offset + len - 8);
		intel_ring_emit(ring, MI_NOOP);
		intel_ring_advance(ring);
	} else {
		u32 cs_offset = ring->scratch.gtt_offset;
d1864 1
d1868 1
a1868 1
		ret = intel_ring_begin(ring, 9+3);
d1871 8
a1878 9
		/* Blit the batch (which has now all relocs applied) to the stable batch
		 * scratch bo area (so that the CS never stumbles over its tlb
		 * invalidation bug) ... */
		intel_ring_emit(ring, XY_SRC_COPY_BLT_CMD |
				XY_SRC_COPY_BLT_WRITE_ALPHA |
				XY_SRC_COPY_BLT_WRITE_RGB);
		intel_ring_emit(ring, BLT_DEPTH_32 | BLT_ROP_GXCOPY | 4096);
		intel_ring_emit(ring, 0);
		intel_ring_emit(ring, (DIV_ROUND_UP(len, 4096) << 16) | 1024);
a1879 1
		intel_ring_emit(ring, 0);
d1882 1
d1884 2
d1888 1
a1888 4
		intel_ring_emit(ring, MI_BATCH_BUFFER);
		intel_ring_emit(ring, cs_offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
		intel_ring_emit(ring, cs_offset + len - 8);
		intel_ring_advance(ring);
d1891 11
d1906 3
a1908 3
i915_dispatch_execbuffer(struct intel_ring_buffer *ring,
			 u32 offset, u32 len,
			 unsigned flags)
d1910 1
d1913 1
a1913 1
	ret = intel_ring_begin(ring, 2);
d1918 2
a1919 1
	intel_ring_emit(ring, offset | (flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE));
d1925 16
a1940 1
static void cleanup_status_page(struct intel_ring_buffer *ring)
d1948 2
a1949 3
	uvm_unmap(kernel_map, (vaddr_t)ring->status_page.page_addr,
	    (vaddr_t)ring->status_page.page_addr + PAGE_SIZE);
	i915_gem_object_unpin(obj);
d1954 1
a1954 1
static int init_status_page(struct intel_ring_buffer *ring)
d1956 1
a1956 3
	struct drm_device *dev = ring->dev;
	struct drm_i915_gem_object *obj;
	int ret;
a1957 1
	obj = i915_gem_alloc_object(dev, 4096);
d1959 12
a1970 4
		DRM_ERROR("Failed to allocate status page\n");
		ret = -ENOMEM;
		goto err;
	}
d1972 19
a1990 1
	i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);
d1992 1
a1992 3
	ret = i915_gem_obj_ggtt_pin(obj, 4096, true, false);
	if (ret != 0) {
		goto err_unref;
d1996 1
a1996 11
	ring->status_page.page_addr = (u_int32_t *)vm_map_min(kernel_map);
	obj->base.uao->pgops->pgo_reference(obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&ring->status_page.page_addr,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE,
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, MADV_RANDOM, 0));
	if (ret != 0) {
		obj->base.uao->pgops->pgo_detach(obj->base.uao);
		ret = -ENOMEM;
		goto err_unpin;
	}
	ring->status_page.obj = obj;
d2003 82
d2086 3
a2088 6
err_unpin:
	i915_gem_object_unpin(obj);
err_unref:
	drm_gem_object_unreference(&obj->base);
err:
	return ret;
d2091 23
a2113 3
static int init_phys_status_page(struct intel_ring_buffer *ring)
{
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
d2115 6
a2120 5
	if (!dev_priv->status_page_dmah) {
		dev_priv->status_page_dmah = drm_dmamem_alloc(dev_priv->dmat,
		    PAGE_SIZE, PAGE_SIZE, 1, PAGE_SIZE, 0, BUS_DMA_READ);
		if (!dev_priv->status_page_dmah)
			return -ENOMEM;
d2123 2
a2124 2
	ring->status_page.page_addr = (u32 *)dev_priv->status_page_dmah->kva;
	memset(ring->status_page.page_addr, 0, PAGE_SIZE);
d2126 5
a2130 1
	return 0;
d2134 1
a2134 1
				  struct intel_ring_buffer *ring)
d2136 1
a2136 2
	struct drm_i915_gem_object *obj;
	struct drm_i915_private *dev_priv = dev->dev_private;
d2139 2
d2144 3
a2146 2
	ring->size = 32 * PAGE_SIZE;
	memset(ring->sync_seqno, 0, sizeof(ring->sync_seqno));
d2150 5
d2158 1
a2158 1
			return ret;
d2160 1
a2160 1
		BUG_ON(ring->id != RCS);
d2163 1
a2163 12
			return ret;
	}

	obj = NULL;
	if (!HAS_LLC(dev))
		obj = i915_gem_object_create_stolen(dev, ring->size);
	if (obj == NULL)
		obj = i915_gem_alloc_object(dev, ring->size);
	if (obj == NULL) {
		DRM_ERROR("Failed to allocate ringbuffer\n");
		ret = -ENOMEM;
		goto err_hws;
d2166 6
a2171 15
	ring->obj = obj;

	ret = i915_gem_obj_ggtt_pin(obj, PAGE_SIZE, true, false);
	if (ret)
		goto err_unref;

	ret = i915_gem_object_set_to_gtt_domain(obj, true);
	if (ret)
		goto err_unpin;

	if ((ret = agp_map_subregion(dev_priv->agph,
	    i915_gem_obj_ggtt_offset(obj), ring->size, &ring->bsh)) != 0) {
		DRM_ERROR("Failed to map ringbuffer.\n");
		ret = -EINVAL;
		goto err_unpin;
a2172 1
	ring->virtual_start = bus_space_vaddr(dev_priv->bst, ring->bsh);
d2174 1
a2174 1
	ret = ring->init(ring);
d2176 1
a2176 9
		goto err_unmap;

	/* Workaround an erratum on the i830 which causes a hang if
	 * the TAIL pointer points to within the last 2 cachelines
	 * of the buffer.
	 */
	ring->effective_size = ring->size;
	if (IS_I830(ring->dev) || IS_845G(ring->dev))
		ring->effective_size -= 128;
d2180 3
a2182 9
err_unmap:
	agp_unmap_subregion(dev_priv->agph, ring->bsh, ring->size);
err_unpin:
	i915_gem_object_unpin(obj);
err_unref:
	drm_gem_object_unreference(&obj->base);
	ring->obj = NULL;
err_hws:
	cleanup_status_page(ring);
d2186 1
a2186 1
void intel_cleanup_ring_buffer(struct intel_ring_buffer *ring)
a2188 1
	int ret;
d2190 1
a2190 1
	if (ring->obj == NULL)
d2193 1
a2193 8
	/* Disable the ring buffer. The ring must be idle at this point */
	dev_priv = ring->dev->dev_private;
	ret = intel_ring_idle(ring);
	if (ret && !i915_reset_in_progress(&dev_priv->gpu_error))
		DRM_ERROR("failed to quiesce %s whilst cleaning up: %d\n",
			  ring->name, ret);

	I915_WRITE_CTL(ring, 0);
d2195 2
a2196 1
	agp_unmap_subregion(dev_priv->agph, ring->bsh, ring->size);
d2198 3
a2200 5
	i915_gem_object_unpin(ring->obj);
	drm_gem_object_unreference(&ring->obj->base);
	ring->obj = NULL;
	ring->preallocated_lazy_request = NULL;
	ring->outstanding_lazy_seqno = 0;
d2205 6
a2210 6
	cleanup_status_page(ring);
}

static int intel_ring_wait_seqno(struct intel_ring_buffer *ring, u32 seqno)
{
	int ret;
d2212 2
a2213 5
	ret = i915_wait_seqno(ring, seqno);
	if (!ret)
		i915_gem_retire_requests_ring(ring);

	return ret;
d2216 1
a2216 1
static int intel_ring_wait_request(struct intel_ring_buffer *ring, int n)
d2218 1
d2220 1
a2220 1
	u32 seqno = 0;
d2223 2
a2224 1
	i915_gem_retire_requests_ring(ring);
d2226 2
a2227 7
	if (ring->last_retired_head != -1) {
		ring->head = ring->last_retired_head;
		ring->last_retired_head = -1;
		ring->space = ring_space(ring);
		if (ring->space >= n)
			return 0;
	}
d2230 3
a2232 10
		int space;

		if (request->tail == -1)
			continue;

		space = request->tail - (ring->tail + I915_RING_FREE_SPACE);
		if (space < 0)
			space += ring->size;
		if (space >= n) {
			seqno = request->seqno;
a2233 8
		}

		/* Consume this request in case we need more space than
		 * is available and so need to prevent a race between
		 * updating last_retired_head and direct reads of
		 * I915_RING_HEAD. It also provides a nice sanity check.
		 */
		request->tail = -1;
d2236 1
a2236 1
	if (seqno == 0)
d2239 1
a2239 1
	ret = intel_ring_wait_seqno(ring, seqno);
d2243 1
a2243 9
	if (WARN_ON(ring->last_retired_head == -1))
		return -ENOSPC;

	ring->head = ring->last_retired_head;
	ring->last_retired_head = -1;
	ring->space = ring_space(ring);
	if (WARN_ON(ring->space < n))
		return -ENOSPC;

d2247 1
a2247 1
static int ring_wait_for_space(struct intel_ring_buffer *ring, int n)
d2249 2
a2250 4
	struct drm_device *dev = ring->dev;
	struct drm_i915_private *dev_priv = dev->dev_private;
	unsigned long end;
	int ret;
d2252 4
a2255 30
	ret = intel_ring_wait_request(ring, n);
	if (ret != -ENOSPC)
		return ret;

	/* force the tail write in case we have been skipping them */
	__intel_ring_advance(ring);

	trace_i915_ring_wait_begin(ring);
	/* With GEM the hangcheck timer should kick us out of the loop,
	 * leaving it early runs the risk of corrupting GEM state (due
	 * to running on almost untested codepaths). But on resume
	 * timers don't work yet, so prevent a complete hang in that
	 * case by choosing an insanely large timeout. */
	end = jiffies + 60 * HZ;

	do {
		ring->head = I915_READ_HEAD(ring);
		ring->space = ring_space(ring);
		if (ring->space >= n) {
			trace_i915_ring_wait_end(ring);
			return 0;
		}

#if 0
		if (dev->primary->master) {
			struct drm_i915_master_private *master_priv = dev->primary->master->driver_priv;
			if (master_priv->sarea_priv)
				master_priv->sarea_priv->perf_boxes |= I915_BOX_WAIT;
		}
#endif
d2257 2
a2258 9
		drm_msleep(1);

		ret = i915_gem_check_wedge(&dev_priv->gpu_error,
					   dev_priv->mm.interruptible);
		if (ret)
			return ret;
	} while (!time_after(jiffies, end));
	trace_i915_ring_wait_end(ring);
	return -EBUSY;
d2261 1
a2261 1
static int intel_wrap_ring_buffer(struct intel_ring_buffer *ring)
d2263 1
a2263 2
	uint32_t __iomem *virt;
	int rem = ring->size - ring->tail;
d2265 3
a2267 5
	if (ring->space < rem) {
		int ret = ring_wait_for_space(ring, rem);
		if (ret)
			return ret;
	}
d2269 3
a2271 4
	virt = ring->virtual_start + ring->tail;
	rem /= 4;
	while (rem--)
		iowrite32(MI_NOOP, virt++);
d2273 6
a2278 2
	ring->tail = 0;
	ring->space = ring_space(ring);
d2280 3
d2286 1
a2286 1
int intel_ring_idle(struct intel_ring_buffer *ring)
d2288 12
a2299 2
	u32 seqno;
	int ret;
d2301 4
a2304 6
	/* We need to add any requests required to flush the objects and ring */
	if (ring->outstanding_lazy_seqno) {
		ret = i915_add_request(ring, NULL);
		if (ret)
			return ret;
	}
d2306 2
a2307 3
	/* Wait upon the last request to be completed */
	if (list_empty(&ring->request_list))
		return 0;
d2309 3
a2311 3
	seqno = list_entry(ring->request_list.prev,
			   struct drm_i915_gem_request,
			   list)->seqno;
d2313 2
a2314 1
	return i915_wait_seqno(ring, seqno);
d2317 1
a2317 2
static int
intel_ring_alloc_seqno(struct intel_ring_buffer *ring)
d2319 1
a2319 2
	if (ring->outstanding_lazy_seqno)
		return 0;
d2321 3
a2323 2
	if (ring->preallocated_lazy_request == NULL) {
		struct drm_i915_gem_request *request;
d2325 17
a2341 5
		request = kmalloc(sizeof(*request), GFP_KERNEL);
		if (request == NULL)
			return -ENOMEM;

		ring->preallocated_lazy_request = request;
d2344 2
a2345 1
	return i915_gem_get_seqno(ring->dev, &ring->outstanding_lazy_seqno);
d2348 1
a2348 2
static int __intel_ring_prepare(struct intel_ring_buffer *ring,
				int bytes)
d2350 10
a2359 1
	int ret;
d2361 20
a2380 4
	if (unlikely(ring->tail + bytes > ring->effective_size)) {
		ret = intel_wrap_ring_buffer(ring);
		if (unlikely(ret))
			return ret;
d2383 2
a2384 2
	if (unlikely(ring->space < bytes)) {
		ret = ring_wait_for_space(ring, bytes);
d2387 3
d2395 1
a2395 1
int intel_ring_begin(struct intel_ring_buffer *ring,
d2398 2
a2399 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
d2402 4
d2415 1
a2415 6
	/* Preallocate the olr before touching the ring */
	ret = intel_ring_alloc_seqno(ring);
	if (ret)
		return ret;

	ring->space -= num_dwords * sizeof(uint32_t);
d2420 1
a2420 1
int intel_ring_cacheline_align(struct intel_ring_buffer *ring)
d2422 2
a2423 1
	int num_dwords = (64 - (ring->tail & 63)) / sizeof(uint32_t);
d2429 2
a2430 1
	ret = intel_ring_begin(ring, num_dwords);
d2442 1
a2442 1
void intel_ring_init_seqno(struct intel_ring_buffer *ring, u32 seqno)
d2444 2
a2445 3
	struct drm_i915_private *dev_priv = ring->dev->dev_private;

	BUG_ON(ring->outstanding_lazy_seqno);
d2447 1
a2447 1
	if (INTEL_INFO(ring->dev)->gen >= 6) {
d2450 1
a2450 1
		if (HAS_VEBOX(ring->dev))
d2458 1
a2458 1
static void gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring,
d2461 1
a2461 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
d2491 1
a2491 1
static int gen6_bsd_ring_flush(struct intel_ring_buffer *ring,
d2494 1
d2498 1
a2498 1
	ret = intel_ring_begin(ring, 4);
d2505 8
d2520 2
a2521 2
		cmd |= MI_INVALIDATE_TLB | MI_INVALIDATE_BSD |
			MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;
d2536 3
a2538 3
gen8_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
d2540 3
a2542 3
	struct drm_i915_private *dev_priv = ring->dev->dev_private;
	bool ppgtt = dev_priv->mm.aliasing_ppgtt != NULL &&
		!(flags & I915_DISPATCH_SECURE);
d2545 1
a2545 1
	ret = intel_ring_begin(ring, 4);
d2550 5
a2554 3
	intel_ring_emit(ring, MI_BATCH_BUFFER_START_GEN8 | (ppgtt<<8));
	intel_ring_emit(ring, offset);
	intel_ring_emit(ring, 0);
d2562 3
a2564 3
hsw_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
d2566 1
d2569 1
a2569 1
	ret = intel_ring_begin(ring, 2);
d2574 5
a2578 2
			MI_BATCH_BUFFER_START | MI_BATCH_PPGTT_HSW |
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_HSW));
d2587 3
a2589 3
gen6_ring_dispatch_execbuffer(struct intel_ring_buffer *ring,
			      u32 offset, u32 len,
			      unsigned flags)
d2591 1
d2594 1
a2594 1
	ret = intel_ring_begin(ring, 2);
d2600 2
a2601 1
			(flags & I915_DISPATCH_SECURE ? 0 : MI_BATCH_NON_SECURE_I965));
d2611 1
a2611 1
static int gen6_ring_flush(struct intel_ring_buffer *ring,
d2614 1
d2619 1
a2619 1
	ret = intel_ring_begin(ring, 4);
d2624 1
a2624 1
	if (INTEL_INFO(ring->dev)->gen >= 8)
d2626 8
d2641 1
a2641 2
		cmd |= MI_INVALIDATE_TLB | MI_FLUSH_DW_STORE_INDEX |
			MI_FLUSH_DW_OP_STOREDW;
d2644 1
a2644 1
	if (INTEL_INFO(ring->dev)->gen >= 8) {
a2652 3
	if (IS_GEN7(dev) && !invalidate && flush)
		return gen7_ring_fbc_flush(ring, FBC_REND_CACHE_CLEAN);

d2658 4
a2661 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
d2667 34
a2700 1
	if (INTEL_INFO(dev)->gen >= 6) {
d2705 2
a2706 8
		if (INTEL_INFO(dev)->gen >= 8) {
			ring->flush = gen8_render_ring_flush;
			ring->irq_get = gen8_ring_get_irq;
			ring->irq_put = gen8_ring_put_irq;
		} else {
			ring->irq_get = gen6_ring_get_irq;
			ring->irq_put = gen6_ring_put_irq;
		}
d2710 21
a2730 9
		ring->sync_to = gen6_ring_sync;
		ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_RV;
		ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_RB;
		ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_RVE;
		ring->signal_mbox[RCS] = GEN6_NOSYNC;
		ring->signal_mbox[VCS] = GEN6_VRSYNC;
		ring->signal_mbox[BCS] = GEN6_BRSYNC;
		ring->signal_mbox[VECS] = GEN6_VERSYNC;
d2758 1
d2771 1
a2771 1
	ring->init = init_render_ring;
d2776 1
a2776 4
		struct drm_i915_gem_object *obj;
		int ret;

		obj = i915_gem_alloc_object(dev, I830_BATCH_LIMIT);
d2782 1
a2782 1
		ret = i915_gem_obj_ggtt_pin(obj, 0, true, false);
d2793 3
a2795 2
	return intel_init_ring_buffer(dev, ring);
}
d2797 2
a2798 61
int intel_render_ring_init_dri(struct drm_device *dev, u64 start, u32 size)
{
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[RCS];
	int ret;

	ring->name = "render ring";
	ring->id = RCS;
	ring->mmio_base = RENDER_RING_BASE;

	if (INTEL_INFO(dev)->gen >= 6) {
		/* non-kms not supported on gen6+ */
		return -ENODEV;
	}

	/* Note: gem is not supported on gen5/ilk without kms (the corresponding
	 * gem_init ioctl returns with -ENODEV). Hence we do not need to set up
	 * the special gen5 functions. */
	ring->add_request = i9xx_add_request;
	if (INTEL_INFO(dev)->gen < 4)
		ring->flush = gen2_render_ring_flush;
	else
		ring->flush = gen4_render_ring_flush;
	ring->get_seqno = ring_get_seqno;
	ring->set_seqno = ring_set_seqno;
	if (IS_GEN2(dev)) {
		ring->irq_get = i8xx_ring_get_irq;
		ring->irq_put = i8xx_ring_put_irq;
	} else {
		ring->irq_get = i9xx_ring_get_irq;
		ring->irq_put = i9xx_ring_put_irq;
	}
	ring->irq_enable_mask = I915_USER_INTERRUPT;
	ring->write_tail = ring_write_tail;
	if (INTEL_INFO(dev)->gen >= 4)
		ring->dispatch_execbuffer = i965_dispatch_execbuffer;
	else if (IS_I830(dev) || IS_845G(dev))
		ring->dispatch_execbuffer = i830_dispatch_execbuffer;
	else
		ring->dispatch_execbuffer = i915_dispatch_execbuffer;
	ring->init = init_render_ring;
	ring->cleanup = render_ring_cleanup;

	ring->dev = dev;
	INIT_LIST_HEAD(&ring->active_list);
	INIT_LIST_HEAD(&ring->request_list);

	ring->size = size;
	ring->effective_size = ring->size;
	if (IS_I830(ring->dev) || IS_845G(ring->dev))
		ring->effective_size -= 128;

	if ((ret = agp_map_subregion(dev_priv->agph, start,
	    size, &ring->bsh)) != 0) {
		DRM_ERROR("Failed to map ringbuffer.\n");
		return -ENOMEM;
	}
	ring->virtual_start = bus_space_vaddr(dev_priv->bst, ring->bsh);

	if (!I915_NEED_GFX_HWS(dev)) {
		ret = init_phys_status_page(ring);
d2808 2
a2809 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[VCS];
d2831 5
d2842 14
a2856 9
		ring->sync_to = gen6_ring_sync;
		ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_VR;
		ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_VB;
		ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_VVE;
		ring->signal_mbox[RCS] = GEN6_RVSYNC;
		ring->signal_mbox[VCS] = GEN6_NOSYNC;
		ring->signal_mbox[BCS] = GEN6_BVSYNC;
		ring->signal_mbox[VECS] = GEN6_VEVSYNC;
d2874 34
a2907 1
	ring->init = init_ring_common;
d2914 2
a2915 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[BCS];
d2932 5
d2942 21
d2964 1
a2964 10
	ring->sync_to = gen6_ring_sync;
	ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_BR;
	ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_BV;
	ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_INVALID;
	ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_BVE;
	ring->signal_mbox[RCS] = GEN6_RBSYNC;
	ring->signal_mbox[VCS] = GEN6_VBSYNC;
	ring->signal_mbox[BCS] = GEN6_NOSYNC;
	ring->signal_mbox[VECS] = GEN6_VEBSYNC;
	ring->init = init_ring_common;
d2971 2
a2972 2
	drm_i915_private_t *dev_priv = dev->dev_private;
	struct intel_ring_buffer *ring = &dev_priv->ring[VECS];
d2990 5
d3000 14
d3015 1
a3015 10
	ring->sync_to = gen6_ring_sync;
	ring->semaphore_register[RCS] = MI_SEMAPHORE_SYNC_VER;
	ring->semaphore_register[VCS] = MI_SEMAPHORE_SYNC_VEV;
	ring->semaphore_register[BCS] = MI_SEMAPHORE_SYNC_VEB;
	ring->semaphore_register[VECS] = MI_SEMAPHORE_SYNC_INVALID;
	ring->signal_mbox[RCS] = GEN6_RVESYNC;
	ring->signal_mbox[VCS] = GEN6_VVESYNC;
	ring->signal_mbox[BCS] = GEN6_BVESYNC;
	ring->signal_mbox[VECS] = GEN6_NOSYNC;
	ring->init = init_ring_common;
d3021 1
a3021 1
intel_ring_flush_all_caches(struct intel_ring_buffer *ring)
d3023 1
d3029 1
a3029 1
	ret = ring->flush(ring, 0, I915_GEM_GPU_DOMAINS);
d3033 1
a3033 1
	trace_i915_gem_ring_flush(ring, 0, I915_GEM_GPU_DOMAINS);
d3040 1
a3040 1
intel_ring_invalidate_all_caches(struct intel_ring_buffer *ring)
d3042 1
d3050 1
a3050 1
	ret = ring->flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);
d3054 1
a3054 1
	trace_i915_gem_ring_flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);
d3058 16
@


1.30
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.29 2015/06/24 17:59:42 kettenis Exp $	*/
d585 1
a585 1
	 * WaDisableAsyncFlipPerfMode:snb,ivb,hsw,vlv
d994 8
a1001 2
	/* Flush the TLB for this page */
	if (INTEL_INFO(dev)->gen >= 6) {
@


1.29
log
@Linux jiffies and OpenBSD ticks are the same thing.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.28 2015/04/12 17:10:07 kettenis Exp $	*/
a36 10
/*
 * 965+ support PIPE_CONTROL commands, which provide finer grained control
 * over cache flushing.
 */
struct pipe_control {
	struct drm_i915_gem_object *obj;
	volatile u32 *cpu_page;
	u32 gtt_offset;
};

d45 10
d179 1
a179 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d216 1
a216 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d282 23
d310 1
a310 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d338 1
d345 2
d363 43
d407 1
d426 11
d445 6
a450 2
	if (HAS_FORCE_WAKE(dev))
		gen6_gt_force_wake_get(dev_priv);
d482 3
d489 1
a489 1
	I915_WRITE_START(ring, obj->gtt_offset);
d496 1
a496 1
		     I915_READ_START(ring) == obj->gtt_offset &&
d518 2
d521 1
a521 2
	if (HAS_FORCE_WAKE(dev))
		gen6_gt_force_wake_put(dev_priv);
a528 2
	struct pipe_control *pc;
	struct drm_i915_gem_object *obj;
d531 1
a531 1
	if (ring->private)
d534 2
a535 6
	pc = kmalloc(sizeof(*pc), GFP_KERNEL);
	if (!pc)
		return -ENOMEM;

	obj = i915_gem_alloc_object(ring->dev, 4096);
	if (obj == NULL) {
d541 1
a541 1
	i915_gem_object_set_cache_level(obj, I915_CACHE_LLC);
d543 1
a543 1
	ret = i915_gem_object_pin(obj, 4096, true, false);
d547 7
a553 6
	pc->gtt_offset = obj->gtt_offset;
	pc->cpu_page = (volatile u_int32_t *)vm_map_min(kernel_map);
	obj->base.uao->pgops->pgo_reference(obj->base.uao);
	ret = uvm_map(kernel_map, (vaddr_t *)&pc->cpu_page,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE,
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, MADV_RANDOM, 0));
d555 2
a556 2
		DRM_ERROR("Failed to map status page.\n");
		obj->base.uao->pgops->pgo_detach(obj->base.uao);
d560 2
a561 2
	pc->obj = obj;
	ring->private = pc;
d565 1
a565 1
	i915_gem_object_unpin(obj);
d567 1
a567 1
	drm_gem_object_unreference(&obj->base);
a568 1
	kfree(pc);
a571 16
static void
cleanup_pipe_control(struct intel_ring_buffer *ring)
{
	struct pipe_control *pc = ring->private;
	struct drm_i915_gem_object *obj;

	obj = pc->obj;

	uvm_unmap(kernel_map, (vaddr_t)pc->cpu_page,
	    (vaddr_t)pc->cpu_page + PAGE_SIZE);
	i915_gem_object_unpin(obj);
	drm_gem_object_unreference(&obj->base);

	kfree(pc);
}

d584 2
d626 2
a627 2
	if (HAS_L3_GPU_CACHE(dev))
		I915_WRITE_IMR(ring, ~GEN6_RENDER_L3_PARITY_ERROR);
d636 1
a636 1
	if (!ring->private)
d639 5
a643 5
	if (HAS_BROKEN_CS_TLB(dev))
		drm_gem_object_unreference(to_gem_object(ring->private));

	if (INTEL_INFO(dev)->gen >= 5)
		cleanup_pipe_control(ring);
d645 2
a646 1
	ring->private = NULL;
d653 6
d661 2
a662 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d677 8
a684 3
	u32 mbox1_reg;
	u32 mbox2_reg;
	int ret;
d686 1
a686 1
	ret = intel_ring_begin(ring, 10);
d690 7
a696 2
	mbox1_reg = ring->signal_mbox[0];
	mbox2_reg = ring->signal_mbox[1];
a697 2
	update_mboxes(ring, mbox1_reg);
	update_mboxes(ring, mbox2_reg);
d700 1
a700 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d702 1
a702 1
	intel_ring_advance(ring);
d707 7
d744 14
a757 5
	intel_ring_emit(waiter,
			dw1 | signaller->semaphore_register[waiter->id]);
	intel_ring_emit(waiter, seqno);
	intel_ring_emit(waiter, 0);
	intel_ring_emit(waiter, MI_NOOP);
d775 1
a775 2
	struct pipe_control *pc = ring->private;
	u32 scratch_addr = pc->gtt_offset + 128;
d793 2
a794 2
	intel_ring_emit(ring, pc->gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d812 2
a813 2
	intel_ring_emit(ring, pc->gtt_offset | PIPE_CONTROL_GLOBAL_GTT);
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d815 1
a815 1
	intel_ring_advance(ring);
d837 6
d846 7
a852 2
	struct pipe_control *pc = ring->private;
	return pc->cpu_page[0];
d866 2
a867 5
	if (ring->irq_refcount++ == 0) {
		dev_priv->gt_irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
	}
d881 2
a882 5
	if (--ring->irq_refcount == 0) {
		dev_priv->gt_irq_mask |= ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
	}
d980 3
d984 1
a984 1
	} else if (IS_GEN6(dev_priv->dev)) {
d987 1
d1035 1
a1035 1
	intel_ring_emit(ring, ring->outstanding_lazy_request);
d1037 1
a1037 1
	intel_ring_advance(ring);
a1051 5
	/* It looks like we need to prevent the gt from suspending while waiting
	 * for an notifiy irq, otherwise irqs seem to get lost on at least the
	 * blt/bsd rings on ivb. */
	gen6_gt_force_wake_get(dev_priv);

d1054 4
a1057 3
		if (HAS_L3_GPU_CACHE(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~(ring->irq_enable_mask |
						GEN6_RENDER_L3_PARITY_ERROR));
d1060 1
a1060 3
		dev_priv->gt_irq_mask &= ~ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
d1076 2
a1077 2
		if (HAS_L3_GPU_CACHE(dev) && ring->id == RCS)
			I915_WRITE_IMR(ring, ~GEN6_RENDER_L3_PARITY_ERROR);
d1080 39
a1118 3
		dev_priv->gt_irq_mask |= ring->irq_enable_mask;
		I915_WRITE(GTIMR, dev_priv->gt_irq_mask);
		POSTING_READ(GTIMR);
d1121 1
d1123 44
a1166 1
	gen6_gt_force_wake_put(dev_priv);
d1210 1
a1210 2
		struct drm_i915_gem_object *obj = ring->private;
		u32 cs_offset = obj->gtt_offset;
d1291 1
a1291 1
	ret = i915_gem_object_pin(obj, 4096, true, false);
d1296 1
a1296 1
	ring->status_page.gfx_addr = obj->gtt_offset;
a1309 1
	intel_ring_setup_status_page(ring);
d1323 1
a1323 1
static int init_phys_hws_pga(struct intel_ring_buffer *ring)
a1325 1
	u32 addr;
a1333 7
	addr = dev_priv->status_page_dmah->map->dm_segs[0].ds_addr;
	if (INTEL_INFO(ring->dev)->gen >= 4)
		addr |= (dev_priv->status_page_dmah->map->dm_segs[0].ds_addr >> 28) & 0xf0;
	bus_dmamap_sync(dev_priv->dmat, dev_priv->status_page_dmah->map, 0,
	    PAGE_SIZE, BUS_DMASYNC_PREREAD);
	I915_WRITE(HWS_PGA, addr);

a1339 10
u32
intel_read_status_page(struct intel_ring_buffer *ring, int reg)
{
	u32			 val;

	val = ((volatile u_int32_t *)(ring->status_page.page_addr))[reg];

	return (val);
}

d1361 1
a1361 1
		ret = init_phys_hws_pga(ring);
d1366 5
a1370 1
	obj = i915_gem_alloc_object(dev, ring->size);
d1379 1
a1379 1
	ret = i915_gem_object_pin(obj, PAGE_SIZE, true, false);
d1387 2
a1388 2
	if ((ret = agp_map_subregion(dev_priv->agph, obj->gtt_offset,
	    ring->size, &ring->bsh)) != 0) {
d1393 1
d1432 1
a1432 1
	if (ret)
d1443 2
d1531 3
d1558 1
a1558 1
		drm_msleep(1, "915wfs");
d1560 2
a1561 1
		ret = i915_gem_check_wedge(dev_priv, dev_priv->mm.interruptible);
d1571 1
a1571 1
	struct inteldrm_softc *dev_priv = ring->dev->dev_private;
d1580 4
a1583 2
	bus_space_set_region_4(dev_priv->bst, ring->bsh,
	    ring->tail, MI_NOOP, rem / 4);
d1597 2
a1598 2
	if (ring->outstanding_lazy_request) {
		ret = i915_add_request(ring, NULL, NULL);
d1617 1
a1617 1
	if (ring->outstanding_lazy_request)
d1620 31
a1650 1
	return i915_gem_get_seqno(ring->dev, &ring->outstanding_lazy_request);
a1656 1
	int n = 4*num_dwords;
d1659 6
a1664 1
	ret = i915_gem_check_wedge(dev_priv, dev_priv->mm.interruptible);
d1673 1
a1673 13
	if (unlikely(ring->tail + n > ring->effective_size)) {
		ret = intel_wrap_ring_buffer(ring);
		if (unlikely(ret))
			return ret;
	}

	if (unlikely(ring->space < n)) {
		ret = ring_wait_for_space(ring, n);
		if (unlikely(ret))
			return ret;
	}

	ring->space -= n;
d1698 1
a1698 1
void intel_ring_advance(struct intel_ring_buffer *ring)
d1702 11
a1712 4
	ring->tail &= ring->size - 1;
	if (dev_priv->stop_rings & intel_ring_flag(ring))
		return;
	ring->write_tail(ring, ring->tail);
a1714 1

d1748 2
a1749 2
static int gen6_ring_flush(struct intel_ring_buffer *ring,
			   u32 invalidate, u32 flush)
d1759 2
d1772 28
d1803 1
d1851 2
a1852 2
static int blt_ring_flush(struct intel_ring_buffer *ring,
			  u32 invalidate, u32 flush)
d1854 1
d1863 2
d1876 7
a1882 2
	intel_ring_emit(ring, 0);
	intel_ring_emit(ring, MI_NOOP);
d1884 4
d1905 9
a1913 3
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->irq_enable_mask = GT_USER_INTERRUPT;
d1915 1
d1917 8
a1924 5
		ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_RV;
		ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_RB;
		ring->signal_mbox[0] = GEN6_VRSYNC;
		ring->signal_mbox[1] = GEN6_BRSYNC;
d1929 1
d1932 2
a1933 1
		ring->irq_enable_mask = GT_USER_INTERRUPT | GT_PIPE_NOTIFY;
d1941 1
d1954 2
d1978 1
a1978 1
		ret = i915_gem_object_pin(obj, 0, true, false);
d1985 2
a1986 1
		ring->private = obj;
d2016 1
d2049 1
d2052 1
a2052 1
		ret = init_phys_hws_pga(ring);
d2069 1
a2069 1
	if (IS_GEN6(dev) || IS_GEN7(dev)) {
d2074 1
a2074 1
		ring->flush = gen6_ring_flush;
d2077 15
a2091 4
		ring->irq_enable_mask = GEN6_BSD_USER_INTERRUPT;
		ring->irq_get = gen6_ring_get_irq;
		ring->irq_put = gen6_ring_put_irq;
		ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
d2093 8
a2100 5
		ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_VR;
		ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_INVALID;
		ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_VB;
		ring->signal_mbox[0] = GEN6_RVSYNC;
		ring->signal_mbox[1] = GEN6_BVSYNC;
d2106 1
d2108 1
a2108 1
			ring->irq_enable_mask = GT_BSD_USER_INTERRUPT;
d2133 41
a2173 1
	ring->flush = blt_ring_flush;
d2176 14
a2189 4
	ring->irq_enable_mask = GEN6_BLITTER_USER_INTERRUPT;
	ring->irq_get = gen6_ring_get_irq;
	ring->irq_put = gen6_ring_put_irq;
	ring->dispatch_execbuffer = gen6_ring_dispatch_execbuffer;
d2191 8
a2198 5
	ring->semaphore_register[0] = MI_SEMAPHORE_SYNC_BR;
	ring->semaphore_register[1] = MI_SEMAPHORE_SYNC_BV;
	ring->semaphore_register[2] = MI_SEMAPHORE_SYNC_INVALID;
	ring->signal_mbox[0] = GEN6_RBSYNC;
	ring->signal_mbox[1] = GEN6_VBSYNC;
a2239 10
}

void
intel_ring_emit(struct intel_ring_buffer *ring, uint32_t data)
{
	struct drm_device	*dev = ring->dev;
	struct inteldrm_softc	*dev_priv = dev->dev_private;
	bus_space_write_4(dev_priv->bst, ring->bsh,
	    ring->tail, data);
	ring->tail += 4;
@


1.28
log
@Add a few missing trace functions, and "use" them.  Add back the WATCH_GTT
code (that isn't actually compiled in).  Use dev_priv->dev in one more place
now that we have it, and add set_normalized_timespec() and use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.27 2015/04/12 11:26:54 jsg Exp $	*/
a46 2
extern int ticks;

d1370 1
a1370 1
	end = ticks + 60 * hz;
d1393 1
a1393 1
	} while (!time_after(ticks, end));
@


1.27
log
@change back to wait_for/wait_for_atomic_us
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.26 2015/04/12 03:54:10 jsg Exp $	*/
d34 1
d1366 1
a1366 1
//	trace_i915_ring_wait_begin(ring);
d1378 1
a1378 1
//			trace_i915_ring_wait_end(ring);
d1396 1
a1396 1
//	trace_i915_ring_wait_end(ring);
d1888 1
a1888 1
//	trace_i915_gem_ring_flush(ring, 0, I915_GEM_GPU_DOMAINS);
d1908 1
a1908 1
//	trace_i915_gem_ring_flush(ring, I915_GEM_GPU_DOMAINS, flush_domains);
@


1.26
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.25 2015/02/12 04:56:03 kettenis Exp $	*/
a366 1
	int retries;
d411 3
a413 8
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ_CTL(ring) & RING_VALID) != 0 &&
		    I915_READ_START(ring) == obj->gtt_offset &&
		    (I915_READ_HEAD(ring) & HEAD_ADDR) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0) {
a890 1
		int retries;
d895 2
a896 6
		for (retries = 1000; retries > 0; retries--) {
			if ((I915_READ(reg) & INSTPM_SYNC_FLUSH) == 0)
				break;
			DELAY(1000);
		}
		if (retries == 0)
a1518 1
	int retries;
d1532 3
a1534 7
	for (retries = 50; retries > 0; retries--) {
		if ((I915_READ(GEN6_BSD_SLEEP_PSMI_CONTROL) &
		    GEN6_BSD_SLEEP_INDICATOR) == 0)
			break;
		DELAY(1000);
	}
	if (retries == 0)
@


1.25
log
@Rename the struct device member of inteldrm_softc to sc_dev and rename the
pointer to the drm subdevice to dev such that we can match the linux code
better.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.24 2015/02/10 10:50:49 jsg Exp $	*/
d1205 1
a1205 1
//	init_waitqueue_head(&ring->irq_queue);
@


1.24
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.23 2014/12/17 06:58:10 guenther Exp $	*/
d886 1
a886 1
	} else if (IS_GEN6(dev)) {
@


1.23
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.22 2014/12/15 02:24:23 guenther Exp $	*/
d759 1
d764 1
a764 1
	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
	mtx_leave(&dev_priv->irq_lock);
d780 1
d782 1
a782 1
	mtx_enter(&dev_priv->irq_lock);
d788 1
a788 1
	mtx_leave(&dev_priv->irq_lock);
d796 1
d801 1
a801 1
	mtx_enter(&dev_priv->irq_lock);
d807 1
a807 1
	mtx_leave(&dev_priv->irq_lock);
d817 1
d819 1
a819 1
	mtx_enter(&dev_priv->irq_lock);
d825 1
a825 1
	mtx_leave(&dev_priv->irq_lock);
d833 1
d838 1
a838 1
	mtx_enter(&dev_priv->irq_lock);
d844 1
a844 1
	mtx_leave(&dev_priv->irq_lock);
d854 1
d856 1
a856 1
	mtx_enter(&dev_priv->irq_lock);
d862 1
a862 1
	mtx_leave(&dev_priv->irq_lock);
d953 1
d963 1
a963 1
	mtx_enter(&dev_priv->irq_lock);
d974 1
a974 1
	mtx_leave(&dev_priv->irq_lock);
d984 1
d986 1
a986 1
	mtx_enter(&dev_priv->irq_lock);
d996 1
a996 1
	mtx_leave(&dev_priv->irq_lock);
@


1.22
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.21 2014/11/16 12:31:00 deraadt Exp $	*/
d479 1
a479 1
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0));
d1126 1
a1126 1
	    PROT_READ | PROT_WRITE, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0));
@


1.21
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.20 2014/03/30 00:58:24 jsg Exp $	*/
d479 1
a479 1
	    PROT_READ | PROT_WRITE, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0));
d1126 1
a1126 1
	    PROT_READ | PROT_WRITE, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0));
@


1.20
log
@drm/i915: Add intel_ring_cachline_align()

From Ville Syrjala
0320c449d2a820ed2a1972e23d8f20f8024a5872 in ubuntu 3.8
753b1ad4a281b0663329409d410243e91825c323 in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.19 2014/03/24 17:06:49 kettenis Exp $	*/
d478 2
a479 2
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW,
	    UVM_PROT_RW, UVM_INH_SHARE, UVM_ADV_RANDOM, 0));
d1125 2
a1126 2
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW,
	    UVM_PROT_RW, UVM_INH_SHARE, UVM_ADV_RANDOM, 0));
@


1.19
log
@Another round of reducing diffs with the Linux codebase.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.18 2014/02/01 09:32:05 jsg Exp $	*/
d1483 21
@


1.18
log
@drm/i915: Invalidate TLBs for the rings after a reset

From Chris Wilson
92e199c62a5d698a8e934aea8bcb4fb43968a290 in ubuntu 3.8
884020bf3d2a3787a1cc6df902e98e0eec60330b in mainline linux

While the original commit message mentions
https://bugs.freedesktop.org/show_bug.cgi?id=64725
which is a problem with hibernate mlarkin@@ says it neither
helps or hurts in his testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.17 2014/01/24 01:42:50 jsg Exp $	*/
d476 7
a482 7
        obj->base.uao->pgops->pgo_reference(obj->base.uao);
        if ((ret = uvm_map(kernel_map, (vaddr_t *)&pc->cpu_page,
            PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
            UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) != 0)
        if (ret != 0) {
                DRM_ERROR("Failed to map status page.\n");
                obj->base.uao->pgops->pgo_detach(obj->base.uao);
d484 1
a484 1
        }
d1124 3
a1126 3
	if ((ret = uvm_map(kernel_map, (vaddr_t *)&ring->status_page.page_addr,
	    PAGE_SIZE, obj->base.uao, 0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) != 0)
@


1.17
log
@drm/i915: fix up ring cleanup for the i830/i845 CS tlb w/a

From Daniel Vetter
cf9f2fc81448a358349320311ccb25bb6016749f in ubuntu 3.8
aaf8a5167291b65e9116cb8736d862965b57c13a in mainline linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.16 2014/01/22 04:04:53 kettenis Exp $	*/
d888 17
@


1.16
log
@Use DIV_ROUND_UP instead of howmany to reduce the diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.15 2014/01/21 08:57:22 kettenis Exp $	*/
a504 3
	if (!ring->private)
		return;

a512 1
	ring->private = NULL;
d583 4
a586 1
	cleanup_pipe_control(ring);
@


1.15
log
@Use Linux compat functions to do kernel memory allocations in the bits of code
that are shared with Linux.  Use OpenBSD functions in the few sports where we
have our own implementation of bits.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.14 2013/12/01 11:47:13 kettenis Exp $	*/
d1035 1
a1035 1
		intel_ring_emit(ring, (howmany(len, 4096) << 16) | 1024);
@


1.14
log
@Bring back the DRM_IOCTL_I915_GEM_WAIT diff now that I've figured out what
made it fail (WARN_ON() was evaluating its argument multiple times).
This time, also advertise support through I915_PARAM_HAS_WAIT_TIMEOUT.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.13 2013/11/30 20:13:36 kettenis Exp $	*/
d457 1
a457 1
	pc = malloc(sizeof(*pc), M_DRM, M_WAITOK);
d495 1
a495 1
	free(pc, M_DRM);
d515 1
a515 1
	free(pc, M_DRM);
@


1.13
log
@Oops!  Only intended to commit the i915_dma.c changes in the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.11 2013/11/30 13:58:51 kettenis Exp $	*/
d764 1
a764 1
//	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
//	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
//	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
//	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
//	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
//	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
//	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
//	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
//	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
//	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
//	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
//	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
//	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
//	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
//	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.12
log
@Reorder some case statements to reduce the diffs with Linux.
@
text
@d764 1
a764 1
	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
	mtx_leave(&dev_priv->irq_lock);
@


1.11
log
@Enable some #ifdef'ed out SandyBridge-specific code that seems to work fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.10 2013/11/29 21:44:15 kettenis Exp $	*/
d764 1
a764 1
//	mtx_enter(&dev_priv->irq_lock);
d770 1
a770 1
//	mtx_leave(&dev_priv->irq_lock);
d781 1
a781 1
//	mtx_enter(&dev_priv->irq_lock);
d787 1
a787 1
//	mtx_leave(&dev_priv->irq_lock);
d799 1
a799 1
//	mtx_enter(&dev_priv->irq_lock);
d805 1
a805 1
//	mtx_leave(&dev_priv->irq_lock);
d816 1
a816 1
//	mtx_enter(&dev_priv->irq_lock);
d822 1
a822 1
//	mtx_leave(&dev_priv->irq_lock);
d834 1
a834 1
//	mtx_enter(&dev_priv->irq_lock);
d840 1
a840 1
//	mtx_leave(&dev_priv->irq_lock);
d851 1
a851 1
//	mtx_enter(&dev_priv->irq_lock);
d857 1
a857 1
//	mtx_leave(&dev_priv->irq_lock);
d940 1
a940 1
//	mtx_enter(&dev_priv->irq_lock);
d951 1
a951 1
//	mtx_leave(&dev_priv->irq_lock);
d962 1
a962 1
//	mtx_enter(&dev_priv->irq_lock);
d972 1
a972 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.10
log
@Should be safe to allow intel_ring_wait_seqno() to be interrupted.
Reduces diffs with Linux.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.9 2013/11/20 22:10:19 kettenis Exp $	*/
a550 1
#ifdef notyet
a566 1
#endif
@


1.9
log
@Eliminate some differences with the Linux code; no code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.8 2013/11/19 19:14:09 kettenis Exp $	*/
a1276 2
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
	bool was_interruptible;
a1278 7
	/* XXX As we have not yet audited all the paths to check that
	 * they are ready for ERESTARTSYS from intel_ring_begin, do not
	 * allow us to be interruptible by a signal.
	 */
	was_interruptible = dev_priv->mm.interruptible;
	dev_priv->mm.interruptible = false;

a1279 1

a1281 2

	dev_priv->mm.interruptible = was_interruptible;
@


1.8
log
@Move the GTT management into the inteldrm driver.  It is really obvious now
that this is necessary as on some hardware we need guard pages between
regions that have different cache attributes.  Even if this appears to cause
regressions on some hardware, this change is a necessary (but not sufficient)
step to fix the cache coherency problems on the affected hardware.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.7 2013/11/19 15:08:04 jsg Exp $	*/
d1425 1
d1432 1
a1438 1
	
d1494 1
d1605 2
a1606 1
static int blt_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
@


1.7
log
@backout the DRM_IOCTL_I915_GEM_WAIT commit
it seems to leave X unuseable on resume on at least snb/ivb
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.6 2013/11/17 18:47:13 kettenis Exp $	*/
a469 7
	/*
	 * snooped gtt mapping please .
	 * Normally this flag is only to dmamem_map, but it's been overloaded
	 * for the agp mapping
	 */
        obj->dma_flags = BUS_DMA_COHERENT | BUS_DMA_READ;

a1101 7
	/*
	 * snooped gtt mapping please .
	 * Normally this flag is only to dmamem_map, but it's been overloaded
	 * for the agp mapping
	 */
	obj->dma_flags = BUS_DMA_COHERENT | BUS_DMA_READ;

a1162 5
	struct inteldrm_softc	*dev_priv = ring->dev->dev_private;
	struct drm_device	*dev = ring->dev;
	struct drm_i915_gem_object *obj_priv;
	bus_dma_tag_t		 tag;
	bus_dmamap_t		 map;
a1164 10
	if (I915_NEED_GFX_HWS(dev)) {
		obj_priv = ring->status_page.obj;
		map = obj_priv->dmamap;
		tag = dev_priv->agpdmat;
	} else {
		map = dev_priv->status_page_dmah->map;
		tag = dev->dmat;
	}
	/* Ensure that the compiler doesn't optimize away the load. */
	bus_dmamap_sync(tag, map, 0, PAGE_SIZE, BUS_DMASYNC_POSTREAD);
a1165 1
	bus_dmamap_sync(tag, map, 0, PAGE_SIZE, BUS_DMASYNC_PREREAD);
@


1.6
log
@Implement DRM_IOCTL_I915_GEM_WAIT.  Based on an earlier diff from jsg@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.5 2013/08/13 10:23:52 jsg Exp $	*/
d773 1
a773 1
	mtx_enter(&dev_priv->irq_lock);
d779 1
a779 1
	mtx_leave(&dev_priv->irq_lock);
d790 1
a790 1
	mtx_enter(&dev_priv->irq_lock);
d796 1
a796 1
	mtx_leave(&dev_priv->irq_lock);
d808 1
a808 1
	mtx_enter(&dev_priv->irq_lock);
d814 1
a814 1
	mtx_leave(&dev_priv->irq_lock);
d825 1
a825 1
	mtx_enter(&dev_priv->irq_lock);
d831 1
a831 1
	mtx_leave(&dev_priv->irq_lock);
d843 1
a843 1
	mtx_enter(&dev_priv->irq_lock);
d849 1
a849 1
	mtx_leave(&dev_priv->irq_lock);
d860 1
a860 1
	mtx_enter(&dev_priv->irq_lock);
d866 1
a866 1
	mtx_leave(&dev_priv->irq_lock);
d949 1
a949 1
	mtx_enter(&dev_priv->irq_lock);
d960 1
a960 1
	mtx_leave(&dev_priv->irq_lock);
d971 1
a971 1
	mtx_enter(&dev_priv->irq_lock);
d981 1
a981 1
	mtx_leave(&dev_priv->irq_lock);
@


1.5
log
@add static back to functions that originally had it
reduces the diff to linux and makes ddb hangman a little easier
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.4 2013/07/05 07:20:27 jsg Exp $	*/
d773 1
a773 1
//	mtx_enter(&dev_priv->irq_lock);
d779 1
a779 1
//	mtx_leave(&dev_priv->irq_lock);
d790 1
a790 1
//	mtx_enter(&dev_priv->irq_lock);
d796 1
a796 1
//	mtx_leave(&dev_priv->irq_lock);
d808 1
a808 1
//	mtx_enter(&dev_priv->irq_lock);
d814 1
a814 1
//	mtx_leave(&dev_priv->irq_lock);
d825 1
a825 1
//	mtx_enter(&dev_priv->irq_lock);
d831 1
a831 1
//	mtx_leave(&dev_priv->irq_lock);
d843 1
a843 1
//	mtx_enter(&dev_priv->irq_lock);
d849 1
a849 1
//	mtx_leave(&dev_priv->irq_lock);
d860 1
a860 1
//	mtx_enter(&dev_priv->irq_lock);
d866 1
a866 1
//	mtx_leave(&dev_priv->irq_lock);
d949 1
a949 1
//	mtx_enter(&dev_priv->irq_lock);
d960 1
a960 1
//	mtx_leave(&dev_priv->irq_lock);
d971 1
a971 1
//	mtx_enter(&dev_priv->irq_lock);
d981 1
a981 1
//	mtx_leave(&dev_priv->irq_lock);
@


1.4
log
@make use of the drm_i915_private macro to reduce the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.3 2013/05/05 13:55:36 kettenis Exp $	*/
a45 52
int	 gen2_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen4_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen6_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen7_render_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 intel_emit_post_sync_nonzero_flush(struct intel_ring_buffer *);
int	 gen7_render_ring_cs_stall_wa(struct intel_ring_buffer *);
void	 ring_write_tail(struct intel_ring_buffer *, u32);
int	 init_pipe_control(struct intel_ring_buffer *);
void	 cleanup_pipe_control(struct intel_ring_buffer *);
int	 init_render_ring(struct intel_ring_buffer *);
void	 render_ring_cleanup(struct intel_ring_buffer *);
void	 update_mboxes(struct intel_ring_buffer *, u32);
int	 gen6_add_request(struct intel_ring_buffer *);
int	 gen6_ring_sync(struct intel_ring_buffer *, struct intel_ring_buffer *,
	     u32);
int	 pc_render_add_request(struct intel_ring_buffer *);
u32	 gen6_ring_get_seqno(struct intel_ring_buffer *, bool);
u32	 ring_get_seqno(struct intel_ring_buffer *, bool);
u32	 pc_render_get_seqno(struct intel_ring_buffer *, bool);
bool	 gen5_ring_get_irq(struct intel_ring_buffer *);
void	 gen5_ring_put_irq(struct intel_ring_buffer *);
bool	 i9xx_ring_get_irq(struct intel_ring_buffer *);
void	 i9xx_ring_put_irq(struct intel_ring_buffer *);
bool	 i8xx_ring_get_irq(struct intel_ring_buffer *);
void	 i8xx_ring_put_irq(struct intel_ring_buffer *);
int	 bsd_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 i9xx_add_request(struct intel_ring_buffer *);
bool	 gen6_ring_get_irq(struct intel_ring_buffer *);
void	 gen6_ring_put_irq(struct intel_ring_buffer *);
int	 i830_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 i915_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 i965_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 init_status_page(struct intel_ring_buffer *);
int	 init_phys_hws_pga(struct intel_ring_buffer *);
int	 intel_ring_idle(struct intel_ring_buffer *);
int	 intel_ring_wait_seqno(struct intel_ring_buffer *, u32);
int	 intel_ring_wait_request(struct intel_ring_buffer *, int);
int	 intel_wrap_ring_buffer(struct intel_ring_buffer *);
int	 intel_ring_alloc_seqno(struct intel_ring_buffer *);
void	 gen6_bsd_ring_write_tail(struct intel_ring_buffer *, u32);
int	 gen6_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 gen6_ring_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 hsw_ring_dispatch_execbuffer(struct intel_ring_buffer *, u32, u32,
	     unsigned);
int	 blt_ring_flush(struct intel_ring_buffer *, u32, u32);
int	 intel_ring_flush_all_caches(struct intel_ring_buffer *);
int	 intel_ring_invalidate_all_caches(struct intel_ring_buffer *);

d48 1
a48 2
static inline int
ring_space(struct intel_ring_buffer *ring)
d56 1
a56 1
int
d82 1
a82 1
int
d177 1
a177 1
int
d213 1
a213 1
int
d266 1
a266 1
int
d285 1
a285 1
int
d344 2
a345 2
void
ring_write_tail(struct intel_ring_buffer *ring, u32 value)
d351 1
a351 2
u32
intel_ring_get_active_head(struct intel_ring_buffer *ring)
d360 1
a360 2
int
init_ring_common(struct intel_ring_buffer *ring)
d447 1
a447 1
int
d506 1
a506 1
void
d526 1
a526 2
int
init_render_ring(struct intel_ring_buffer *ring)
d586 1
a586 2
void
render_ring_cleanup(struct intel_ring_buffer *ring)
d599 1
a599 1
void
d617 1
a617 1
int
d649 1
a649 1
int
d691 1
a691 1
int
d740 1
a740 1
u32
d751 1
a751 1
u32
d757 1
a757 1
u32
d764 1
a764 1
bool
d784 1
a784 1
void
d799 1
a799 1
bool
d819 1
a819 1
void
d834 1
a834 1
bool
d854 1
a854 1
void
d869 1
a869 2
void
intel_ring_setup_status_page(struct intel_ring_buffer *ring)
d900 1
a900 1
int
d917 1
a917 1
int
d935 1
a935 1
bool
d965 1
a965 1
void
d986 1
a986 1
int
d1009 1
a1009 1
int
d1061 1
a1061 1
int
d1079 1
a1079 2
void
cleanup_status_page(struct intel_ring_buffer *ring)
d1094 1
a1094 2
int
init_status_page(struct intel_ring_buffer *ring)
d1149 1
a1149 2
int
init_phys_hws_pga(struct intel_ring_buffer *ring)
d1200 1
a1200 2
int
intel_init_ring_buffer(struct drm_device *dev,
d1276 1
a1276 2
void
intel_cleanup_ring_buffer(struct intel_ring_buffer *ring)
d1305 1
a1305 2
int
intel_ring_wait_seqno(struct intel_ring_buffer *ring, u32 seqno)
d1328 1
a1328 2
int
intel_ring_wait_request(struct intel_ring_buffer *ring, int n)
d1385 1
a1385 2
int
ring_wait_for_space(struct intel_ring_buffer *ring, int n)
d1430 1
a1430 2
int
intel_wrap_ring_buffer(struct intel_ring_buffer *ring)
d1450 1
a1450 2
int
intel_ring_idle(struct intel_ring_buffer *ring)
d1472 1
a1472 1
int
d1481 2
a1482 2
int
intel_ring_begin(struct intel_ring_buffer *ring, int num_dwords)
d1513 1
a1513 2
void
intel_ring_advance(struct intel_ring_buffer *ring)
d1523 2
a1524 2
void
gen6_bsd_ring_write_tail(struct intel_ring_buffer *ring, u32 value)
d1561 2
a1562 2
int
gen6_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
d1589 1
a1589 1
int
d1610 1
a1610 1
int
d1633 1
a1633 2
int
blt_ring_flush(struct intel_ring_buffer *ring, u32 invalidate, u32 flush)
d1660 1
a1660 2
int
intel_init_render_ring_buffer(struct drm_device *dev)
d1745 1
a1745 2
int
intel_render_ring_init_dri(struct drm_device *dev, u64 start, u32 size)
d1811 1
a1811 2
int
intel_init_bsd_ring_buffer(struct drm_device *dev)
d1859 1
a1859 2
int
intel_init_blt_ring_buffer(struct drm_device *dev)
@


1.3
log
@Add nonblocking argument to i915_gem_object_pin() and
i915_gem_object_bind_to_gtt().
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.2 2013/04/17 20:04:05 kettenis Exp $	*/
d585 1
a585 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1212 1
a1212 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
d1266 1
a1266 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1341 1
a1341 1
	drm_i915_private_t *dev_priv;
d1454 1
a1454 1
	drm_i915_private_t *dev_priv = dev->dev_private;
d1584 1
a1584 1
	drm_i915_private_t *dev_priv = ring->dev->dev_private;
@


1.2
log
@Another round of reducing diffs with Linux code.
@
text
@d1 1
a1 1
/*	$OpenBSD: intel_ringbuffer.c,v 1.1 2013/03/18 12:36:52 jsg Exp $	*/
d532 1
a532 1
	ret = i915_gem_object_pin(obj, 4096, true);
d1176 1
a1176 1
	ret = i915_gem_object_pin(obj, 4096, true);
d1297 1
a1297 1
	ret = i915_gem_object_pin(obj, PAGE_SIZE, true);
d1803 1
a1803 1
		ret = i915_gem_object_pin(obj, 0, true);
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1734 1
a1734 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d1820 1
a1820 1
	struct intel_ring_buffer *ring = &dev_priv->rings[RCS];
d1887 1
a1887 1
	struct intel_ring_buffer *ring = &dev_priv->rings[VCS];
d1936 1
a1936 1
	struct intel_ring_buffer *ring = &dev_priv->rings[BCS];
@

