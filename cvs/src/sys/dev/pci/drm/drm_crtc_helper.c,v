head	1.15;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.1.0.2
	OPENBSD_5_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.07.01.16.00.25;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	aN6GlSqZJXG1gx72;

1.14
date	2015.09.23.23.12.11;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	lQlppvmETCN49oZe;

1.13
date	2015.07.11.04.00.46;	author jsg;	state Exp;
branches;
next	1.12;
commitid	eVKv6xUxvZe6BPUh;

1.12
date	2015.04.18.11.05.32;	author jsg;	state Exp;
branches;
next	1.11;
commitid	N5rmYm7ybHimJmMa;

1.11
date	2015.04.06.09.23.19;	author jsg;	state Exp;
branches;
next	1.10;
commitid	99nej6bpjNHMCLwr;

1.10
date	2015.02.11.07.01.36;	author jsg;	state Exp;
branches;
next	1.9;
commitid	dLgISW35NAmGN8Xl;

1.9
date	2015.02.10.03.39.41;	author jsg;	state Exp;
branches;
next	1.8;
commitid	C5l5rZ5v9mpRR1eS;

1.8
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.7;
commitid	MyKPm9Q3dQu92BiX;

1.7
date	2014.03.09.11.07.18;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2013.12.16.19.57.09;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2013.10.30.02.11.32;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2013.09.02.06.25.27;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.03.18.12.36.51;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update inteldrm(4) to code based on Linux 4.4.70.  This brings us support for
Skylake and Cherryview and better support for Broadwell and Valleyview.  Also
adds MST support.  Some tweaks to the TTM code and radeondrm(4) to keep it
working with the updated generic DRM code needed for inteldrm(4).

Tested by many.
@
text
@/*
 * Copyright (c) 2006-2008 Intel Corporation
 * Copyright (c) 2007 Dave Airlie <airlied@@linux.ie>
 *
 * DRM core CRTC related functions
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting documentation, and
 * that the name of the copyright holders not be used in advertising or
 * publicity pertaining to distribution of the software without specific,
 * written prior permission.  The copyright holders make no representations
 * about the suitability of this software for any purpose.  It is provided "as
 * is" without express or implied warranty.
 *
 * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THIS SOFTWARE.
 *
 * Authors:
 *      Keith Packard
 *	Eric Anholt <eric@@anholt.net>
 *      Dave Airlie <airlied@@linux.ie>
 *      Jesse Barnes <jesse.barnes@@intel.com>
 */

#ifdef __linux__
#include <linux/kernel.h>
#include <linux/export.h>
#include <linux/moduleparam.h>
#endif

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/drm_atomic.h>
#include <dev/pci/drm/drm_crtc.h>
#include <dev/pci/drm/drm_fourcc.h>
#include <dev/pci/drm/drm_crtc_helper.h>
#include <dev/pci/drm/drm_fb_helper.h>
#include <dev/pci/drm/drm_plane_helper.h>
#include <dev/pci/drm/drm_atomic_helper.h>
#include <dev/pci/drm/drm_edid.h>

/**
 * DOC: overview
 *
 * The CRTC modeset helper library provides a default set_config implementation
 * in drm_crtc_helper_set_config(). Plus a few other convenience functions using
 * the same callbacks which drivers can use to e.g. restore the modeset
 * configuration on resume with drm_helper_resume_force_mode().
 *
 * The driver callbacks are mostly compatible with the atomic modeset helpers,
 * except for the handling of the primary plane: Atomic helpers require that the
 * primary plane is implemented as a real standalone plane and not directly tied
 * to the CRTC state. For easier transition this library provides functions to
 * implement the old semantics required by the CRTC helpers using the new plane
 * and atomic helper callbacks.
 *
 * Drivers are strongly urged to convert to the atomic helpers (by way of first
 * converting to the plane helpers). New drivers must not use these functions
 * but need to implement the atomic interface instead, potentially using the
 * atomic helpers for that.
 */
MODULE_AUTHOR("David Airlie, Jesse Barnes");
MODULE_DESCRIPTION("DRM KMS helper");
MODULE_LICENSE("GPL and additional rights");

/**
 * drm_helper_move_panel_connectors_to_head() - move panels to the front in the
 * 						connector list
 * @@dev: drm device to operate on
 *
 * Some userspace presumes that the first connected connector is the main
 * display, where it's supposed to display e.g. the login screen. For
 * laptops, this should be the main panel. Use this function to sort all
 * (eDP/LVDS) panels to the front of the connector list, instead of
 * painstakingly trying to initialize them in the right order.
 */
void drm_helper_move_panel_connectors_to_head(struct drm_device *dev)
{
	struct drm_connector *connector, *tmp;
	struct list_head panel_list;

	INIT_LIST_HEAD(&panel_list);

	list_for_each_entry_safe(connector, tmp,
				 &dev->mode_config.connector_list, head) {
		if (connector->connector_type == DRM_MODE_CONNECTOR_LVDS ||
		    connector->connector_type == DRM_MODE_CONNECTOR_eDP)
			list_move_tail(&connector->head, &panel_list);
	}

	list_splice(&panel_list, &dev->mode_config.connector_list);
}
EXPORT_SYMBOL(drm_helper_move_panel_connectors_to_head);

/**
 * drm_helper_encoder_in_use - check if a given encoder is in use
 * @@encoder: encoder to check
 *
 * Checks whether @@encoder is with the current mode setting output configuration
 * in use by any connector. This doesn't mean that it is actually enabled since
 * the DPMS state is tracked separately.
 *
 * Returns:
 * True if @@encoder is used, false otherwise.
 */
bool drm_helper_encoder_in_use(struct drm_encoder *encoder)
{
	struct drm_connector *connector;
	struct drm_device *dev = encoder->dev;

	/*
	 * We can expect this mutex to be locked if we are not panicking.
	 * Locking is currently fubar in the panic handler.
	 */
	if (!oops_in_progress) {
		WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));
		WARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));
	}

	drm_for_each_connector(connector, dev)
		if (connector->encoder == encoder)
			return true;
	return false;
}
EXPORT_SYMBOL(drm_helper_encoder_in_use);

/**
 * drm_helper_crtc_in_use - check if a given CRTC is in a mode_config
 * @@crtc: CRTC to check
 *
 * Checks whether @@crtc is with the current mode setting output configuration
 * in use by any connector. This doesn't mean that it is actually enabled since
 * the DPMS state is tracked separately.
 *
 * Returns:
 * True if @@crtc is used, false otherwise.
 */
bool drm_helper_crtc_in_use(struct drm_crtc *crtc)
{
	struct drm_encoder *encoder;
	struct drm_device *dev = crtc->dev;

	/*
	 * We can expect this mutex to be locked if we are not panicking.
	 * Locking is currently fubar in the panic handler.
	 */
	if (!oops_in_progress)
		WARN_ON(!mutex_is_locked(&dev->mode_config.mutex));

	drm_for_each_encoder(encoder, dev)
		if (encoder->crtc == crtc && drm_helper_encoder_in_use(encoder))
			return true;
	return false;
}
EXPORT_SYMBOL(drm_helper_crtc_in_use);

static void
drm_encoder_disable(struct drm_encoder *encoder)
{
	const struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;

	drm_bridge_disable(encoder->bridge);

	if (encoder_funcs->disable)
		(*encoder_funcs->disable)(encoder);
	else
		(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);

	drm_bridge_post_disable(encoder->bridge);
}

static void __drm_helper_disable_unused_functions(struct drm_device *dev)
{
	struct drm_encoder *encoder;
	struct drm_crtc *crtc;

	drm_warn_on_modeset_not_all_locked(dev);

	drm_for_each_encoder(encoder, dev) {
		if (!drm_helper_encoder_in_use(encoder)) {
			drm_encoder_disable(encoder);
			/* disconnect encoder from any connector */
			encoder->crtc = NULL;
		}
	}

	drm_for_each_crtc(crtc, dev) {
		const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
		crtc->enabled = drm_helper_crtc_in_use(crtc);
		if (!crtc->enabled) {
			if (crtc_funcs->disable)
				(*crtc_funcs->disable)(crtc);
			else
				(*crtc_funcs->dpms)(crtc, DRM_MODE_DPMS_OFF);
			crtc->primary->fb = NULL;
		}
	}
}

/**
 * drm_helper_disable_unused_functions - disable unused objects
 * @@dev: DRM device
 *
 * This function walks through the entire mode setting configuration of @@dev. It
 * will remove any crtc links of unused encoders and encoder links of
 * disconnected connectors. Then it will disable all unused encoders and crtcs
 * either by calling their disable callback if available or by calling their
 * dpms callback with DRM_MODE_DPMS_OFF.
 */
void drm_helper_disable_unused_functions(struct drm_device *dev)
{
	drm_modeset_lock_all(dev);
	__drm_helper_disable_unused_functions(dev);
	drm_modeset_unlock_all(dev);
}
EXPORT_SYMBOL(drm_helper_disable_unused_functions);

/*
 * Check the CRTC we're going to map each output to vs. its current
 * CRTC.  If they don't match, we have to disable the output and the CRTC
 * since the driver will have to re-route things.
 */
static void
drm_crtc_prepare_encoders(struct drm_device *dev)
{
	const struct drm_encoder_helper_funcs *encoder_funcs;
	struct drm_encoder *encoder;

	drm_for_each_encoder(encoder, dev) {
		encoder_funcs = encoder->helper_private;
		/* Disable unused encoders */
		if (encoder->crtc == NULL)
			drm_encoder_disable(encoder);
		/* Disable encoders whose CRTC is about to change */
		if (encoder_funcs->get_crtc &&
		    encoder->crtc != (*encoder_funcs->get_crtc)(encoder))
			drm_encoder_disable(encoder);
	}
}

/**
 * drm_crtc_helper_set_mode - internal helper to set a mode
 * @@crtc: CRTC to program
 * @@mode: mode to use
 * @@x: horizontal offset into the surface
 * @@y: vertical offset into the surface
 * @@old_fb: old framebuffer, for cleanup
 *
 * Try to set @@mode on @@crtc.  Give @@crtc and its associated connectors a chance
 * to fixup or reject the mode prior to trying to set it. This is an internal
 * helper that drivers could e.g. use to update properties that require the
 * entire output pipe to be disabled and re-enabled in a new configuration. For
 * example for changing whether audio is enabled on a hdmi link or for changing
 * panel fitter or dither attributes. It is also called by the
 * drm_crtc_helper_set_config() helper function to drive the mode setting
 * sequence.
 *
 * Returns:
 * True if the mode was set successfully, false otherwise.
 */
bool drm_crtc_helper_set_mode(struct drm_crtc *crtc,
			      struct drm_display_mode *mode,
			      int x, int y,
			      struct drm_framebuffer *old_fb)
{
	struct drm_device *dev = crtc->dev;
	struct drm_display_mode *adjusted_mode, saved_mode, saved_hwmode;
	const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
	const struct drm_encoder_helper_funcs *encoder_funcs;
	int saved_x, saved_y;
	bool saved_enabled;
	struct drm_encoder *encoder;
	bool ret = true;

	drm_warn_on_modeset_not_all_locked(dev);

	saved_enabled = crtc->enabled;
	crtc->enabled = drm_helper_crtc_in_use(crtc);
	if (!crtc->enabled)
		return true;

	adjusted_mode = drm_mode_duplicate(dev, mode);
	if (!adjusted_mode) {
		crtc->enabled = saved_enabled;
		return false;
	}

	saved_mode = crtc->mode;
	saved_hwmode = crtc->hwmode;
	saved_x = crtc->x;
	saved_y = crtc->y;

	/* Update crtc values up front so the driver can rely on them for mode
	 * setting.
	 */
	crtc->mode = *mode;
	crtc->x = x;
	crtc->y = y;

	/* Pass our mode to the connectors and the CRTC to give them a chance to
	 * adjust it according to limitations or connector properties, and also
	 * a chance to reject the mode entirely.
	 */
	drm_for_each_encoder(encoder, dev) {

		if (encoder->crtc != crtc)
			continue;

		ret = drm_bridge_mode_fixup(encoder->bridge,
			mode, adjusted_mode);
		if (!ret) {
			DRM_DEBUG_KMS("Bridge fixup failed\n");
			goto done;
		}

		encoder_funcs = encoder->helper_private;
		if (!(ret = encoder_funcs->mode_fixup(encoder, mode,
						      adjusted_mode))) {
			DRM_DEBUG_KMS("Encoder fixup failed\n");
			goto done;
		}
	}

	if (!(ret = crtc_funcs->mode_fixup(crtc, mode, adjusted_mode))) {
		DRM_DEBUG_KMS("CRTC fixup failed\n");
		goto done;
	}
	DRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);

	crtc->hwmode = *adjusted_mode;

	/* Prepare the encoders and CRTCs before setting the mode. */
	drm_for_each_encoder(encoder, dev) {

		if (encoder->crtc != crtc)
			continue;

		drm_bridge_disable(encoder->bridge);

		encoder_funcs = encoder->helper_private;
		/* Disable the encoders as the first thing we do. */
		encoder_funcs->prepare(encoder);

		drm_bridge_post_disable(encoder->bridge);
	}

	drm_crtc_prepare_encoders(dev);

	crtc_funcs->prepare(crtc);

	/* Set up the DPLL and any encoders state that needs to adjust or depend
	 * on the DPLL.
	 */
	ret = !crtc_funcs->mode_set(crtc, mode, adjusted_mode, x, y, old_fb);
	if (!ret)
	    goto done;

	drm_for_each_encoder(encoder, dev) {

		if (encoder->crtc != crtc)
			continue;

		DRM_DEBUG_KMS("[ENCODER:%d:%s] set [MODE:%d:%s]\n",
			encoder->base.id, encoder->name,
			mode->base.id, mode->name);
		encoder_funcs = encoder->helper_private;
		encoder_funcs->mode_set(encoder, mode, adjusted_mode);

		drm_bridge_mode_set(encoder->bridge, mode, adjusted_mode);
	}

	/* Now enable the clocks, plane, pipe, and connectors that we set up. */
	crtc_funcs->commit(crtc);

	drm_for_each_encoder(encoder, dev) {

		if (encoder->crtc != crtc)
			continue;

		drm_bridge_pre_enable(encoder->bridge);

		encoder_funcs = encoder->helper_private;
		encoder_funcs->commit(encoder);

		drm_bridge_enable(encoder->bridge);
	}

	/* Calculate and store various constants which
	 * are later needed by vblank and swap-completion
	 * timestamping. They are derived from true hwmode.
	 */
	drm_calc_timestamping_constants(crtc, &crtc->hwmode);

	/* FIXME: add subpixel order */
done:
	drm_mode_destroy(dev, adjusted_mode);
	if (!ret) {
		crtc->enabled = saved_enabled;
		crtc->mode = saved_mode;
		crtc->hwmode = saved_hwmode;
		crtc->x = saved_x;
		crtc->y = saved_y;
	}

	return ret;
}
EXPORT_SYMBOL(drm_crtc_helper_set_mode);

static void
drm_crtc_helper_disable(struct drm_crtc *crtc)
{
	struct drm_device *dev = crtc->dev;
	struct drm_connector *connector;
	struct drm_encoder *encoder;

	/* Decouple all encoders and their attached connectors from this crtc */
	drm_for_each_encoder(encoder, dev) {
		if (encoder->crtc != crtc)
			continue;

		drm_for_each_connector(connector, dev) {
			if (connector->encoder != encoder)
				continue;

			connector->encoder = NULL;

			/*
			 * drm_helper_disable_unused_functions() ought to be
			 * doing this, but since we've decoupled the encoder
			 * from the connector above, the required connection
			 * between them is henceforth no longer available.
			 */
			connector->dpms = DRM_MODE_DPMS_OFF;
		}
	}

	__drm_helper_disable_unused_functions(dev);
}

/**
 * drm_crtc_helper_set_config - set a new config from userspace
 * @@set: mode set configuration
 *
 * Setup a new configuration, provided by the upper layers (either an ioctl call
 * from userspace or internally e.g. from the fbdev support code) in @@set, and
 * enable it. This is the main helper functions for drivers that implement
 * kernel mode setting with the crtc helper functions and the assorted
 * ->prepare(), ->modeset() and ->commit() helper callbacks.
 *
 * Returns:
 * Returns 0 on success, negative errno numbers on failure.
 */
int drm_crtc_helper_set_config(struct drm_mode_set *set)
{
	struct drm_device *dev;
	struct drm_crtc *new_crtc;
	struct drm_encoder *save_encoders, *new_encoder, *encoder;
	bool mode_changed = false; /* if true do a full mode set */
	bool fb_changed = false; /* if true and !mode_changed just do a flip */
	struct drm_connector *save_connectors, *connector;
	int count = 0, ro, fail = 0;
	const struct drm_crtc_helper_funcs *crtc_funcs;
	struct drm_mode_set save_set;
	int ret;
	int i;

	DRM_DEBUG_KMS("\n");

	BUG_ON(!set);
	BUG_ON(!set->crtc);
	BUG_ON(!set->crtc->helper_private);

	/* Enforce sane interface api - has been abused by the fb helper. */
	BUG_ON(!set->mode && set->fb);
	BUG_ON(set->fb && set->num_connectors == 0);

	crtc_funcs = set->crtc->helper_private;

	if (!set->mode)
		set->fb = NULL;

	if (set->fb) {
		DRM_DEBUG_KMS("[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n",
				set->crtc->base.id, set->fb->base.id,
				(int)set->num_connectors, set->x, set->y);
	} else {
		DRM_DEBUG_KMS("[CRTC:%d] [NOFB]\n", set->crtc->base.id);
		drm_crtc_helper_disable(set->crtc);
		return 0;
	}

	dev = set->crtc->dev;

	drm_warn_on_modeset_not_all_locked(dev);

	/*
	 * Allocate space for the backup of all (non-pointer) encoder and
	 * connector data.
	 */
	save_encoders = kzalloc(dev->mode_config.num_encoder *
				sizeof(struct drm_encoder), GFP_KERNEL);
	if (!save_encoders)
		return -ENOMEM;

	save_connectors = kzalloc(dev->mode_config.num_connector *
				sizeof(struct drm_connector), GFP_KERNEL);
	if (!save_connectors) {
		kfree(save_encoders);
		return -ENOMEM;
	}

	/*
	 * Copy data. Note that driver private data is not affected.
	 * Should anything bad happen only the expected state is
	 * restored, not the drivers personal bookkeeping.
	 */
	count = 0;
	drm_for_each_encoder(encoder, dev) {
		save_encoders[count++] = *encoder;
	}

	count = 0;
	drm_for_each_connector(connector, dev) {
		save_connectors[count++] = *connector;
	}

	save_set.crtc = set->crtc;
	save_set.mode = &set->crtc->mode;
	save_set.x = set->crtc->x;
	save_set.y = set->crtc->y;
	save_set.fb = set->crtc->primary->fb;

	/* We should be able to check here if the fb has the same properties
	 * and then just flip_or_move it */
	if (set->crtc->primary->fb != set->fb) {
		/* If we have no fb then treat it as a full mode set */
		if (set->crtc->primary->fb == NULL) {
			DRM_DEBUG_KMS("crtc has no fb, full mode set\n");
			mode_changed = true;
		} else if (set->fb == NULL) {
			mode_changed = true;
		} else if (set->fb->pixel_format !=
			   set->crtc->primary->fb->pixel_format) {
			mode_changed = true;
		} else
			fb_changed = true;
	}

	if (set->x != set->crtc->x || set->y != set->crtc->y)
		fb_changed = true;

	if (set->mode && !drm_mode_equal(set->mode, &set->crtc->mode)) {
		DRM_DEBUG_KMS("modes are different, full mode set\n");
		drm_mode_debug_printmodeline(&set->crtc->mode);
		drm_mode_debug_printmodeline(set->mode);
		mode_changed = true;
	}

	/* a) traverse passed in connector list and get encoders for them */
	count = 0;
	drm_for_each_connector(connector, dev) {
		const struct drm_connector_helper_funcs *connector_funcs =
			connector->helper_private;
		new_encoder = connector->encoder;
		for (ro = 0; ro < set->num_connectors; ro++) {
			if (set->connectors[ro] == connector) {
				new_encoder = connector_funcs->best_encoder(connector);
				/* if we can't get an encoder for a connector
				   we are setting now - then fail */
				if (new_encoder == NULL)
					/* don't break so fail path works correct */
					fail = 1;

				if (connector->dpms != DRM_MODE_DPMS_ON) {
					DRM_DEBUG_KMS("connector dpms not on, full mode switch\n");
					mode_changed = true;
				}

				break;
			}
		}

		if (new_encoder != connector->encoder) {
			DRM_DEBUG_KMS("encoder changed, full mode switch\n");
			mode_changed = true;
			/* If the encoder is reused for another connector, then
			 * the appropriate crtc will be set later.
			 */
			if (connector->encoder)
				connector->encoder->crtc = NULL;
			connector->encoder = new_encoder;
		}
	}

	if (fail) {
		ret = -EINVAL;
		goto fail;
	}

	count = 0;
	drm_for_each_connector(connector, dev) {
		if (!connector->encoder)
			continue;

		if (connector->encoder->crtc == set->crtc)
			new_crtc = NULL;
		else
			new_crtc = connector->encoder->crtc;

		for (ro = 0; ro < set->num_connectors; ro++) {
			if (set->connectors[ro] == connector)
				new_crtc = set->crtc;
		}

		/* Make sure the new CRTC will work with the encoder */
		if (new_crtc &&
		    !drm_encoder_crtc_ok(connector->encoder, new_crtc)) {
			ret = -EINVAL;
			goto fail;
		}
		if (new_crtc != connector->encoder->crtc) {
			DRM_DEBUG_KMS("crtc changed, full mode switch\n");
			mode_changed = true;
			connector->encoder->crtc = new_crtc;
		}
		if (new_crtc) {
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [CRTC:%d]\n",
				connector->base.id, connector->name,
				new_crtc->base.id);
		} else {
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [NOCRTC]\n",
				connector->base.id, connector->name);
		}
	}

	/* mode_set_base is not a required function */
	if (fb_changed && !crtc_funcs->mode_set_base)
		mode_changed = true;

	if (mode_changed) {
		if (drm_helper_crtc_in_use(set->crtc)) {
			DRM_DEBUG_KMS("attempting to set mode from"
					" userspace\n");
			drm_mode_debug_printmodeline(set->mode);
			set->crtc->primary->fb = set->fb;
			if (!drm_crtc_helper_set_mode(set->crtc, set->mode,
						      set->x, set->y,
						      save_set.fb)) {
				DRM_ERROR("failed to set mode on [CRTC:%d]\n",
					  set->crtc->base.id);
				set->crtc->primary->fb = save_set.fb;
				ret = -EINVAL;
				goto fail;
			}
			DRM_DEBUG_KMS("Setting connector DPMS state to on\n");
			for (i = 0; i < set->num_connectors; i++) {
				DRM_DEBUG_KMS("\t[CONNECTOR:%d:%s] set DPMS on\n", set->connectors[i]->base.id,
					      set->connectors[i]->name);
				set->connectors[i]->funcs->dpms(set->connectors[i], DRM_MODE_DPMS_ON);
			}
		}
		__drm_helper_disable_unused_functions(dev);
	} else if (fb_changed) {
		set->crtc->x = set->x;
		set->crtc->y = set->y;
		set->crtc->primary->fb = set->fb;
		ret = crtc_funcs->mode_set_base(set->crtc,
						set->x, set->y, save_set.fb);
		if (ret != 0) {
			set->crtc->x = save_set.x;
			set->crtc->y = save_set.y;
			set->crtc->primary->fb = save_set.fb;
			goto fail;
		}
	}

	kfree(save_connectors);
	kfree(save_encoders);
	return 0;

fail:
	/* Restore all previous data. */
	count = 0;
	drm_for_each_encoder(encoder, dev) {
		*encoder = save_encoders[count++];
	}

	count = 0;
	drm_for_each_connector(connector, dev) {
		*connector = save_connectors[count++];
	}

	/* Try to restore the config */
	if (mode_changed &&
	    !drm_crtc_helper_set_mode(save_set.crtc, save_set.mode, save_set.x,
				      save_set.y, save_set.fb))
		DRM_ERROR("failed to restore config after modeset failure\n");

	kfree(save_connectors);
	kfree(save_encoders);
	return ret;
}
EXPORT_SYMBOL(drm_crtc_helper_set_config);

static int drm_helper_choose_encoder_dpms(struct drm_encoder *encoder)
{
	int dpms = DRM_MODE_DPMS_OFF;
	struct drm_connector *connector;
	struct drm_device *dev = encoder->dev;

	drm_for_each_connector(connector, dev)
		if (connector->encoder == encoder)
			if (connector->dpms < dpms)
				dpms = connector->dpms;
	return dpms;
}

/* Helper which handles bridge ordering around encoder dpms */
static void drm_helper_encoder_dpms(struct drm_encoder *encoder, int mode)
{
	struct drm_bridge *bridge = encoder->bridge;
	const struct drm_encoder_helper_funcs *encoder_funcs;

	if (mode == DRM_MODE_DPMS_ON)
		drm_bridge_pre_enable(bridge);
	else
		drm_bridge_disable(bridge);

	encoder_funcs = encoder->helper_private;
	if (encoder_funcs->dpms)
		encoder_funcs->dpms(encoder, mode);

	if (mode == DRM_MODE_DPMS_ON)
		drm_bridge_enable(bridge);
	else
		drm_bridge_post_disable(bridge);
}

static int drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)
{
	int dpms = DRM_MODE_DPMS_OFF;
	struct drm_connector *connector;
	struct drm_device *dev = crtc->dev;

	drm_for_each_connector(connector, dev)
		if (connector->encoder && connector->encoder->crtc == crtc)
			if (connector->dpms < dpms)
				dpms = connector->dpms;
	return dpms;
}

/**
 * drm_helper_connector_dpms() - connector dpms helper implementation
 * @@connector: affected connector
 * @@mode: DPMS mode
 *
 * This is the main helper function provided by the crtc helper framework for
 * implementing the DPMS connector attribute. It computes the new desired DPMS
 * state for all encoders and crtcs in the output mesh and calls the ->dpms()
 * callback provided by the driver appropriately.
 *
 * Returns:
 * Always returns 0.
 */
int drm_helper_connector_dpms(struct drm_connector *connector, int mode)
{
	struct drm_encoder *encoder = connector->encoder;
	struct drm_crtc *crtc = encoder ? encoder->crtc : NULL;
	int old_dpms, encoder_dpms = DRM_MODE_DPMS_OFF;

	if (mode == connector->dpms)
		return 0;

	old_dpms = connector->dpms;
	connector->dpms = mode;

	if (encoder)
		encoder_dpms = drm_helper_choose_encoder_dpms(encoder);

	/* from off to on, do crtc then encoder */
	if (mode < old_dpms) {
		if (crtc) {
			const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
			if (crtc_funcs->dpms)
				(*crtc_funcs->dpms) (crtc,
						     drm_helper_choose_crtc_dpms(crtc));
		}
		if (encoder)
			drm_helper_encoder_dpms(encoder, encoder_dpms);
	}

	/* from on to off, do encoder then crtc */
	if (mode > old_dpms) {
		if (encoder)
			drm_helper_encoder_dpms(encoder, encoder_dpms);
		if (crtc) {
			const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
			if (crtc_funcs->dpms)
				(*crtc_funcs->dpms) (crtc,
						     drm_helper_choose_crtc_dpms(crtc));
		}
	}

	return 0;
}
EXPORT_SYMBOL(drm_helper_connector_dpms);

/**
 * drm_helper_mode_fill_fb_struct - fill out framebuffer metadata
 * @@fb: drm_framebuffer object to fill out
 * @@mode_cmd: metadata from the userspace fb creation request
 *
 * This helper can be used in a drivers fb_create callback to pre-fill the fb's
 * metadata fields.
 */
void drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
				    struct drm_mode_fb_cmd2 *mode_cmd)
{
	int i;

	fb->width = mode_cmd->width;
	fb->height = mode_cmd->height;
	for (i = 0; i < 4; i++) {
		fb->pitches[i] = mode_cmd->pitches[i];
		fb->offsets[i] = mode_cmd->offsets[i];
		fb->modifier[i] = mode_cmd->modifier[i];
	}
	drm_fb_get_bpp_depth(mode_cmd->pixel_format, &fb->depth,
				    &fb->bits_per_pixel);
	fb->pixel_format = mode_cmd->pixel_format;
	fb->flags = mode_cmd->flags;
}
EXPORT_SYMBOL(drm_helper_mode_fill_fb_struct);

/**
 * drm_helper_resume_force_mode - force-restore mode setting configuration
 * @@dev: drm_device which should be restored
 *
 * Drivers which use the mode setting helpers can use this function to
 * force-restore the mode setting configuration e.g. on resume or when something
 * else might have trampled over the hw state (like some overzealous old BIOSen
 * tended to do).
 *
 * This helper doesn't provide a error return value since restoring the old
 * config should never fail due to resource allocation issues since the driver
 * has successfully set the restored configuration already. Hence this should
 * boil down to the equivalent of a few dpms on calls, which also don't provide
 * an error code.
 *
 * Drivers where simply restoring an old configuration again might fail (e.g.
 * due to slight differences in allocating shared resources when the
 * configuration is restored in a different order than when userspace set it up)
 * need to use their own restore logic.
 */
void drm_helper_resume_force_mode(struct drm_device *dev)
{
	struct drm_crtc *crtc;
	struct drm_encoder *encoder;
	const struct drm_crtc_helper_funcs *crtc_funcs;
	int encoder_dpms;
	bool ret;

	drm_modeset_lock_all(dev);
	drm_for_each_crtc(crtc, dev) {

		if (!crtc->enabled)
			continue;

		ret = drm_crtc_helper_set_mode(crtc, &crtc->mode,
					       crtc->x, crtc->y, crtc->primary->fb);

		/* Restoring the old config should never fail! */
		if (ret == false)
			DRM_ERROR("failed to set mode on crtc %p\n", crtc);

		/* Turn off outputs that were already powered off */
		if (drm_helper_choose_crtc_dpms(crtc)) {
			drm_for_each_encoder(encoder, dev) {

				if(encoder->crtc != crtc)
					continue;

				encoder_dpms = drm_helper_choose_encoder_dpms(
							encoder);

				drm_helper_encoder_dpms(encoder, encoder_dpms);
			}

			crtc_funcs = crtc->helper_private;
			if (crtc_funcs->dpms)
				(*crtc_funcs->dpms) (crtc,
						     drm_helper_choose_crtc_dpms(crtc));
		}
	}

	/* disable the unused connectors while restoring the modesetting */
	__drm_helper_disable_unused_functions(dev);
	drm_modeset_unlock_all(dev);
}
EXPORT_SYMBOL(drm_helper_resume_force_mode);

/**
 * drm_helper_crtc_mode_set - mode_set implementation for atomic plane helpers
 * @@crtc: DRM CRTC
 * @@mode: DRM display mode which userspace requested
 * @@adjusted_mode: DRM display mode adjusted by ->mode_fixup callbacks
 * @@x: x offset of the CRTC scanout area on the underlying framebuffer
 * @@y: y offset of the CRTC scanout area on the underlying framebuffer
 * @@old_fb: previous framebuffer
 *
 * This function implements a callback useable as the ->mode_set callback
 * required by the crtc helpers. Besides the atomic plane helper functions for
 * the primary plane the driver must also provide the ->mode_set_nofb callback
 * to set up the crtc.
 *
 * This is a transitional helper useful for converting drivers to the atomic
 * interfaces.
 */
int drm_helper_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,
			     struct drm_display_mode *adjusted_mode, int x, int y,
			     struct drm_framebuffer *old_fb)
{
	struct drm_crtc_state *crtc_state;
	const struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
	int ret;

	if (crtc->funcs->atomic_duplicate_state)
		crtc_state = crtc->funcs->atomic_duplicate_state(crtc);
	else {
		if (!crtc->state)
			drm_atomic_helper_crtc_reset(crtc);

		crtc_state = drm_atomic_helper_crtc_duplicate_state(crtc);
	}

	if (!crtc_state)
		return -ENOMEM;

	crtc_state->planes_changed = true;
	crtc_state->mode_changed = true;
	ret = drm_atomic_set_mode_for_crtc(crtc_state, mode);
	if (ret)
		goto out;
	drm_mode_copy(&crtc_state->adjusted_mode, adjusted_mode);

	if (crtc_funcs->atomic_check) {
		ret = crtc_funcs->atomic_check(crtc, crtc_state);
		if (ret)
			goto out;
	}

	swap(crtc->state, crtc_state);

	crtc_funcs->mode_set_nofb(crtc);

	ret = drm_helper_crtc_mode_set_base(crtc, x, y, old_fb);

out:
	if (crtc_state) {
		if (crtc->funcs->atomic_destroy_state)
			crtc->funcs->atomic_destroy_state(crtc, crtc_state);
		else
			drm_atomic_helper_crtc_destroy_state(crtc, crtc_state);
	}

	return ret;
}
EXPORT_SYMBOL(drm_helper_crtc_mode_set);

/**
 * drm_helper_crtc_mode_set_base - mode_set_base implementation for atomic plane helpers
 * @@crtc: DRM CRTC
 * @@x: x offset of the CRTC scanout area on the underlying framebuffer
 * @@y: y offset of the CRTC scanout area on the underlying framebuffer
 * @@old_fb: previous framebuffer
 *
 * This function implements a callback useable as the ->mode_set_base used
 * required by the crtc helpers. The driver must provide the atomic plane helper
 * functions for the primary plane.
 *
 * This is a transitional helper useful for converting drivers to the atomic
 * interfaces.
 */
int drm_helper_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,
				  struct drm_framebuffer *old_fb)
{
	struct drm_plane_state *plane_state;
	struct drm_plane *plane = crtc->primary;

	if (plane->funcs->atomic_duplicate_state)
		plane_state = plane->funcs->atomic_duplicate_state(plane);
	else if (plane->state)
		plane_state = drm_atomic_helper_plane_duplicate_state(plane);
	else
		plane_state = kzalloc(sizeof(*plane_state), GFP_KERNEL);
	if (!plane_state)
		return -ENOMEM;
	plane_state->plane = plane;

	plane_state->crtc = crtc;
	drm_atomic_set_fb_for_plane(plane_state, crtc->primary->fb);
	plane_state->crtc_x = 0;
	plane_state->crtc_y = 0;
	plane_state->crtc_h = crtc->mode.vdisplay;
	plane_state->crtc_w = crtc->mode.hdisplay;
	plane_state->src_x = x << 16;
	plane_state->src_y = y << 16;
	plane_state->src_h = crtc->mode.vdisplay << 16;
	plane_state->src_w = crtc->mode.hdisplay << 16;

	return drm_plane_helper_commit(plane, plane_state, old_fb);
}
EXPORT_SYMBOL(drm_helper_crtc_mode_set_base);
@


1.14
log
@Update inteldrm to the code from Linux 3.14.52 (which corresponds to
commit 48f8f36a6c8018c2b36ea207aaf68ef5326c5075 on the linux-3.14.y
branch of the linux-stable tree).  This brings preliminary support for
the GPU on Intel's Broadwell CPUs.  Don't expect these to work
perfectly yet.  There are some remaining issues with older hardware as
well, but no significant regressions have been uncovered.

This also updates some of drm core code.  The radeondrm code remains
based on Linux 3.8 with some minimal canges to adjust to changes in
the core drm APIs.

Joint effort with jsg@@, who did the initial update of the relevant drm
core bits.  Committing this early to make sure it gets more testing
and make it possible for others to help getting the remaining wrinkles
straightened out.
@
text
@a0 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.13 2015/07/11 04:00:46 jsg Exp $	*/
d32 39
a70 6
#include "drmP.h"
#include "drm_crtc.h"
#include "drm_fourcc.h"
#include "drm_crtc_helper.h"
#include "drm_fb_helper.h"
#include "drm_edid.h"
a100 143
static bool drm_kms_helper_poll = true;
module_param_named(poll, drm_kms_helper_poll, bool, 0600);

static void drm_mode_validate_flag(struct drm_connector *connector,
				   int flags)
{
	struct drm_display_mode *mode;

	if (flags == (DRM_MODE_FLAG_DBLSCAN | DRM_MODE_FLAG_INTERLACE |
		      DRM_MODE_FLAG_3D_MASK))
		return;

	list_for_each_entry(mode, &connector->modes, head) {
		if ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&
				!(flags & DRM_MODE_FLAG_INTERLACE))
			mode->status = MODE_NO_INTERLACE;
		if ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&
				!(flags & DRM_MODE_FLAG_DBLSCAN))
			mode->status = MODE_NO_DBLESCAN;
		if ((mode->flags & DRM_MODE_FLAG_3D_MASK) &&
				!(flags & DRM_MODE_FLAG_3D_MASK))
			mode->status = MODE_NO_STEREO;
	}

	return;
}

/**
 * drm_helper_probe_single_connector_modes - get complete set of display modes
 * @@connector: connector to probe
 * @@maxX: max width for modes
 * @@maxY: max height for modes
 *
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Based on the helper callbacks implemented by @@connector try to detect all
 * valid modes.  Modes will first be added to the connector's probed_modes list,
 * then culled (based on validity and the @@maxX, @@maxY parameters) and put into
 * the normal modes list.
 *
 * Intended to be use as a generic implementation of the ->fill_modes()
 * @@connector vfunc for drivers that use the crtc helpers for output mode
 * filtering and detection.
 *
 * RETURNS:
 * Number of modes found on @@connector.
 */
int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
					    uint32_t maxX, uint32_t maxY)
{
	struct drm_device *dev = connector->dev;
	struct drm_display_mode *mode;
	struct drm_connector_helper_funcs *connector_funcs =
		connector->helper_private;
	int count = 0;
	int mode_flags = 0;
	bool verbose_prune = true;

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,
			drm_get_connector_name(connector));
	/* set all modes to the unverified state */
	list_for_each_entry(mode, &connector->modes, head)
		mode->status = MODE_UNVERIFIED;

	if (connector->force) {
		if (connector->force == DRM_FORCE_ON)
			connector->status = connector_status_connected;
		else
			connector->status = connector_status_disconnected;
		if (connector->funcs->force)
			connector->funcs->force(connector);
	} else {
		connector->status = connector->funcs->detect(connector, true);
	}

	/* Re-enable polling in case the global poll config changed. */
	if (drm_kms_helper_poll != dev->mode_config.poll_running)
		drm_kms_helper_poll_enable(dev);

	dev->mode_config.poll_running = drm_kms_helper_poll;

	if (connector->status == connector_status_disconnected) {
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",
			connector->base.id, drm_get_connector_name(connector));
		drm_mode_connector_update_edid_property(connector, NULL);
		verbose_prune = false;
		goto prune;
	}

#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE
	count = drm_load_edid_firmware(connector);
	if (count == 0)
#endif
		count = (*connector_funcs->get_modes)(connector);

	if (count == 0 && connector->status == connector_status_connected)
		count = drm_add_modes_noedid(connector, 1024, 768);
	if (count == 0)
		goto prune;

	drm_mode_connector_list_update(connector);

	if (maxX && maxY)
		drm_mode_validate_size(dev, &connector->modes, maxX,
				       maxY, 0);

	if (connector->interlace_allowed)
		mode_flags |= DRM_MODE_FLAG_INTERLACE;
	if (connector->doublescan_allowed)
		mode_flags |= DRM_MODE_FLAG_DBLSCAN;
	if (connector->stereo_allowed)
		mode_flags |= DRM_MODE_FLAG_3D_MASK;
	drm_mode_validate_flag(connector, mode_flags);

	list_for_each_entry(mode, &connector->modes, head) {
		if (mode->status == MODE_OK)
			mode->status = connector_funcs->mode_valid(connector,
								   mode);
	}

prune:
	drm_mode_prune_invalid(dev, &connector->modes, verbose_prune);

	if (list_empty(&connector->modes))
		return 0;

	list_for_each_entry(mode, &connector->modes, head)
		mode->vrefresh = drm_mode_vrefresh(mode);

	drm_mode_sort(&connector->modes);

	DRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,
			drm_get_connector_name(connector));
	list_for_each_entry(mode, &connector->modes, head) {
		drm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);
		drm_mode_debug_printmodeline(mode);
	}

	return count;
}
EXPORT_SYMBOL(drm_helper_probe_single_connector_modes);

d105 3
a107 4
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * Walk @@encoders's DRM device's mode_config and see if it's in use.
d109 2
a110 2
 * RETURNS:
 * True if @@encoder is part of the mode_config, false otherwise.
d116 11
a126 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
d137 3
a139 2
 * LOCKING:
 * Caller must hold mode config lock.
d141 2
a142 4
 * Walk @@crtc's DRM device's mode_config and see if it's in use.
 *
 * RETURNS:
 * True if @@crtc is part of the mode_config, false otherwise.
d148 9
a156 2
	/* FIXME: Locking around list access? */
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head)
d166 1
a166 1
	struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;
d168 1
a168 2
	if (encoder->bridge)
		encoder->bridge->funcs->disable(encoder->bridge);
d175 1
a175 2
	if (encoder->bridge)
		encoder->bridge->funcs->post_disable(encoder->bridge);
d178 1
a178 11
/**
 * drm_helper_disable_unused_functions - disable unused objects
 * @@dev: DRM device
 *
 * LOCKING:
 * Caller must hold mode config lock.
 *
 * If an connector or CRTC isn't part of @@dev's mode_config, it can be disabled
 * by calling its dpms function, which should power it off.
 */
void drm_helper_disable_unused_functions(struct drm_device *dev)
a180 1
	struct drm_connector *connector;
d183 1
a183 6
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (!connector->encoder)
			continue;
		if (connector->status == connector_status_disconnected)
			connector->encoder = NULL;
	}
d185 1
a185 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d188 1
a188 1
			/* disconnector encoder from any connector */
d193 2
a194 2
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
d201 1
a201 1
			crtc->fb = NULL;
d205 17
d232 1
a232 1
	struct drm_encoder_helper_funcs *encoder_funcs;
d235 1
a235 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
a254 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d264 2
a265 2
 * RETURNS:
 * True if the mode was set successfully, or false otherwise.
d273 3
a275 3
	struct drm_display_mode *adjusted_mode, saved_mode;
	struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
	struct drm_encoder_helper_funcs *encoder_funcs;
d281 2
d295 1
d310 1
a310 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d315 5
a319 7
		if (encoder->bridge && encoder->bridge->funcs->mode_fixup) {
			ret = encoder->bridge->funcs->mode_fixup(
					encoder->bridge, mode, adjusted_mode);
			if (!ret) {
				DRM_DEBUG_KMS("Bridge fixup failed\n");
				goto done;
			}
d336 2
d339 1
a339 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d344 1
a344 2
		if (encoder->bridge)
			encoder->bridge->funcs->disable(encoder->bridge);
d350 1
a350 2
		if (encoder->bridge)
			encoder->bridge->funcs->post_disable(encoder->bridge);
d364 1
a364 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d370 1
a370 1
			encoder->base.id, drm_get_encoder_name(encoder),
d375 1
a375 3
		if (encoder->bridge && encoder->bridge->funcs->mode_set)
			encoder->bridge->funcs->mode_set(encoder->bridge, mode,
					adjusted_mode);
d381 1
a381 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d386 1
a386 2
		if (encoder->bridge)
			encoder->bridge->funcs->pre_enable(encoder->bridge);
d391 1
a391 2
		if (encoder->bridge)
			encoder->bridge->funcs->enable(encoder->bridge);
a393 3
	/* Store real post-adjustment hardware mode. */
	crtc->hwmode = *adjusted_mode;

d406 1
d415 1
a415 2

static int
d423 1
a423 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d427 1
a427 1
		list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
d443 1
a443 2
	drm_helper_disable_unused_functions(dev);
	return 0;
a449 3
 * LOCKING:
 * Caller must hold mode config lock.
 *
d451 1
a451 1
 * from userspace or internally e.g. from the fbdev suppport code) in @@set, and
d456 2
a457 2
 * RETURNS:
 * Returns 0 on success, -ERRNO on failure.
d468 1
a468 1
	struct drm_crtc_helper_funcs *crtc_funcs;
d494 2
a495 1
		return drm_crtc_helper_disable(set->crtc);
d500 2
d524 1
a524 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d529 1
a529 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
d537 1
a537 1
	save_set.fb = set->crtc->fb;
d541 1
a541 1
	if (set->crtc->fb != set->fb) {
d543 1
a543 1
		if (set->crtc->fb == NULL) {
d549 1
a549 1
			   set->crtc->fb->pixel_format) {
d567 2
a568 2
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		struct drm_connector_helper_funcs *connector_funcs =
a578 1
				break;
d584 2
d607 1
a607 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
d634 1
a634 1
				connector->base.id, drm_get_connector_name(connector),
d638 1
a638 1
				connector->base.id, drm_get_connector_name(connector));
d651 1
a651 1
			set->crtc->fb = set->fb;
d657 1
a657 1
				set->crtc->fb = save_set.fb;
d664 1
a664 1
					      drm_get_connector_name(set->connectors[i]));
d668 1
a668 1
		drm_helper_disable_unused_functions(dev);
d672 1
a672 1
		set->crtc->fb = set->fb;
d678 1
a678 1
			set->crtc->fb = save_set.fb;
d690 1
a690 1
	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d695 1
a695 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
d717 1
a717 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
d728 1
a728 1
	struct drm_encoder_helper_funcs *encoder_funcs;
d730 4
a733 6
	if (bridge) {
		if (mode == DRM_MODE_DPMS_ON)
			bridge->funcs->pre_enable(bridge);
		else
			bridge->funcs->disable(bridge);
	}
d739 4
a742 6
	if (bridge) {
		if (mode == DRM_MODE_DPMS_ON)
			bridge->funcs->enable(bridge);
		else
			bridge->funcs->post_disable(bridge);
	}
d751 1
a751 1
	list_for_each_entry(connector, &dev->mode_config.connector_list, head)
d767 3
d771 1
a771 1
void drm_helper_connector_dpms(struct drm_connector *connector, int mode)
d778 1
a778 1
		return;
d789 1
a789 1
			struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
d803 1
a803 1
			struct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;
d810 1
a810 1
	return;
d814 10
a823 2
int drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
				   struct drm_mode_fb_cmd2 *mode_cmd)
d832 1
d837 1
a837 2

	return 0;
d841 21
a861 1
int drm_helper_resume_force_mode(struct drm_device *dev)
d865 3
a867 2
	struct drm_crtc_helper_funcs *crtc_funcs;
	int ret, encoder_dpms;
d869 2
a870 1
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
d876 1
a876 1
					       crtc->x, crtc->y, crtc->fb);
d878 1
d884 1
a884 1
			list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
d901 1
d903 2
a904 2
	drm_helper_disable_unused_functions(dev);
	return 0;
d908 20
a927 1
void drm_kms_helper_hotplug_event(struct drm_device *dev)
d929 3
a931 6
	/* send a uevent + call fbdev */
	drm_sysfs_hotplug_event(dev);
	if (dev->mode_config.funcs->output_poll_changed)
		dev->mode_config.funcs->output_poll_changed(dev);
}
EXPORT_SYMBOL(drm_kms_helper_hotplug_event);
d933 5
a937 8
#define DRM_OUTPUT_POLL_PERIOD (10*HZ)
static void output_poll_execute(struct work_struct *work)
{
	struct delayed_work *delayed_work = to_delayed_work(work);
	struct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);
	struct drm_connector *connector;
	enum drm_connector_status old_status;
	bool repoll = false, changed = false;
d939 2
a940 2
	if (!drm_kms_helper_poll)
		return;
d942 2
a943 2
	mutex_lock(&dev->mode_config.mutex);
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
d945 6
a950 30
		/* Ignore forced connectors. */
		if (connector->force)
			continue;

		/* Ignore HPD capable connectors and connectors where we don't
		 * want any hotplug detection at all for polling. */
		if (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)
			continue;

		repoll = true;

		old_status = connector->status;
		/* if we are connected and don't want to poll for disconnect
		   skip it */
		if (old_status == connector_status_connected &&
		    !(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))
			continue;

		connector->status = connector->funcs->detect(connector, false);
		if (old_status != connector->status) {
			const char *old, *new;

			old = drm_get_connector_status_name(old_status);
			new = drm_get_connector_status_name(connector->status);

			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] "
				      "status updated from %s to %s\n",
				      connector->base.id,
				      drm_get_connector_name(connector),
				      old, new);
d952 4
a955 2
			changed = true;
		}
d958 1
a958 1
	mutex_unlock(&dev->mode_config.mutex);
d960 1
a960 2
	if (changed)
		drm_kms_helper_hotplug_event(dev);
d962 1
a962 3
	if (repoll)
		schedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);
}
d964 6
a969 20
void drm_kms_helper_poll_disable(struct drm_device *dev)
{
	if (!dev->mode_config.poll_enabled)
		return;
	cancel_delayed_work_sync(&dev->mode_config.output_poll_work);
}
EXPORT_SYMBOL(drm_kms_helper_poll_disable);

void drm_kms_helper_poll_enable(struct drm_device *dev)
{
	bool poll = false;
	struct drm_connector *connector;

	if (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)
		return;

	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
		if (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |
					 DRM_CONNECTOR_POLL_DISCONNECT))
			poll = true;
d972 1
a972 2
	if (poll)
		schedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);
d974 1
a974 1
EXPORT_SYMBOL(drm_kms_helper_poll_enable);
d976 16
a991 1
void drm_kms_helper_poll_init(struct drm_device *dev)
d993 2
a994 2
	INIT_DELAYED_WORK(&dev->mode_config.output_poll_work, output_poll_execute);
	dev->mode_config.poll_enabled = true;
d996 9
a1004 39
	drm_kms_helper_poll_enable(dev);
}
EXPORT_SYMBOL(drm_kms_helper_poll_init);

void drm_kms_helper_poll_fini(struct drm_device *dev)
{
	drm_kms_helper_poll_disable(dev);
}
EXPORT_SYMBOL(drm_kms_helper_poll_fini);

bool drm_helper_hpd_irq_event(struct drm_device *dev)
{
	struct drm_connector *connector;
	enum drm_connector_status old_status;
	bool changed = false;

	if (!dev->mode_config.poll_enabled)
		return false;

	mutex_lock(&dev->mode_config.mutex);
	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {

		/* Only handle HPD capable connectors. */
		if (!(connector->polled & DRM_CONNECTOR_POLL_HPD))
			continue;

		old_status = connector->status;

		connector->status = connector->funcs->detect(connector, false);
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %s to %s\n",
			      connector->base.id,
			      drm_get_connector_name(connector),
			      drm_get_connector_status_name(old_status),
			      drm_get_connector_status_name(connector->status));
		if (old_status != connector->status)
			changed = true;
	}

	mutex_unlock(&dev->mode_config.mutex);
d1006 10
a1015 2
	if (changed)
		drm_kms_helper_hotplug_event(dev);
d1017 1
a1017 1
	return changed;
d1019 1
a1019 1
EXPORT_SYMBOL(drm_helper_hpd_irq_event);
@


1.13
log
@Make use of recent drm_linux.h additions to further reduce the
diff to linux.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.12 2015/04/18 11:05:32 jsg Exp $	*/
d77 2
a78 1
	if (flags == (DRM_MODE_FLAG_DBLSCAN | DRM_MODE_FLAG_INTERLACE))
d88 3
d110 3
a112 3
 * Intended to be use as a generic implementation of the ->probe() @@connector
 * callback for drivers that use the crtc helpers for output mode filtering and
 * detection.
d126 1
d155 1
d180 2
d191 1
a191 1
	drm_mode_prune_invalid(dev, &connector->modes, true);
d196 3
a203 2
		mode->vrefresh = drm_mode_vrefresh(mode);

d264 3
d271 3
a320 29
/**
 * drm_encoder_crtc_ok - can a given crtc drive a given encoder?
 * @@encoder: encoder to test
 * @@crtc: crtc to test
 *
 * Return false if @@encoder can't be driven by @@crtc, true otherwise.
 */
static bool drm_encoder_crtc_ok(struct drm_encoder *encoder,
				struct drm_crtc *crtc)
{
	struct drm_device *dev;
	struct drm_crtc *tmp;
	int crtc_mask = 1;

	WARN(!crtc, "checking null crtc?\n");

	dev = crtc->dev;

	list_for_each_entry(tmp, &dev->mode_config.crtc_list, head) {
		if (tmp == crtc)
			break;
		crtc_mask <<= 1;
	}

	if (encoder->possible_crtcs & crtc_mask)
		return true;
	return false;
}

d373 1
a373 1
	struct drm_display_mode *adjusted_mode, saved_mode, saved_hwmode;
d377 1
d381 1
d387 2
a388 1
	if (!adjusted_mode)
d390 1
a391 1
	saved_hwmode = crtc->hwmode;
d411 10
d440 4
d447 3
d473 4
d487 3
d493 2
d504 1
a504 1
	drm_calc_timestamping_constants(crtc);
d510 1
a510 1
		crtc->hwmode = saved_hwmode;
d538 8
d572 1
a572 1
	struct drm_crtc *save_crtcs, *new_crtc, *crtc;
a573 1
	struct drm_framebuffer *old_fb = NULL;
d585 7
a591 8
	if (!set)
		return -EINVAL;

	if (!set->crtc)
		return -EINVAL;

	if (!set->crtc->helper_private)
		return -EINVAL;
d609 4
a612 7
	/* Allocate space for the backup of all (non-pointer) crtc, encoder and
	 * connector data. */
	save_crtcs = kzalloc(dev->mode_config.num_crtc *
			     sizeof(struct drm_crtc), GFP_KERNEL);
	if (!save_crtcs)
		return -ENOMEM;

d615 1
a615 2
	if (!save_encoders) {
		kfree(save_crtcs);
a616 1
	}
a620 1
		kfree(save_crtcs);
d625 2
a626 1
	/* Copy data. Note that driver private data is not affected.
a630 5
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		save_crtcs[count++] = *crtc;
	}

	count = 0;
d655 2
a656 4
		} else if (set->fb->depth != set->crtc->fb->depth) {
			mode_changed = true;
		} else if (set->fb->bits_per_pixel !=
			   set->crtc->fb->bits_per_pixel) {
d687 5
d753 1
a753 2
		set->crtc->enabled = drm_helper_crtc_in_use(set->crtc);
		if (set->crtc->enabled) {
a756 1
			old_fb = set->crtc->fb;
d760 1
a760 1
						      old_fb)) {
d763 1
a763 1
				set->crtc->fb = old_fb;
d778 1
a778 4

		old_fb = set->crtc->fb;
		if (set->crtc->fb != set->fb)
			set->crtc->fb = set->fb;
d780 1
a780 1
						set->x, set->y, old_fb);
d782 3
a784 1
			set->crtc->fb = old_fb;
a790 1
	kfree(save_crtcs);
a795 5
	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
		*crtc = save_crtcs[count++];
	}

	count = 0;
a812 1
	kfree(save_crtcs);
d830 25
d882 1
a882 1
	int old_dpms;
d890 3
d901 2
a902 6
		if (encoder) {
			struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;
			if (encoder_funcs->dpms)
				(*encoder_funcs->dpms) (encoder,
							drm_helper_choose_encoder_dpms(encoder));
		}
d907 2
a908 6
		if (encoder) {
			struct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;
			if (encoder_funcs->dpms)
				(*encoder_funcs->dpms) (encoder,
							drm_helper_choose_encoder_dpms(encoder));
		}
a943 1
	struct drm_encoder_helper_funcs *encoder_funcs;
d945 1
a945 1
	int ret;
d965 4
a968 4
				encoder_funcs = encoder->helper_private;
				if (encoder_funcs->dpms)
					(*encoder_funcs->dpms) (encoder,
								drm_helper_choose_encoder_dpms(encoder));
d1027 7
a1033 1
			DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
d1036 2
a1037 1
				      old_status, connector->status);
d1093 1
a1093 1
void drm_helper_hpd_irq_event(struct drm_device *dev)
d1100 1
a1100 1
		return;
d1112 1
a1112 1
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
d1115 2
a1116 1
			      old_status, connector->status);
d1125 2
@


1.12
log
@add and use module param macros
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.11 2015/04/06 09:23:19 jsg Exp $	*/
d969 2
a970 2
#define DRM_OUTPUT_POLL_SECONDS 10
static void drm_output_poll_execute(void *arg1)
d972 2
a973 1
	struct drm_device *dev = (struct drm_device *)arg1;
d1018 1
a1018 10
		timeout_add_sec(&dev->mode_config.output_poll_to,
		    DRM_OUTPUT_POLL_SECONDS);
}

static void
drm_output_poll_tick(void *arg)
{
	struct drm_device *dev = arg;

	task_add(systq, &dev->mode_config.poll_task);
d1025 1
a1025 2
	timeout_del(&dev->mode_config.output_poll_to);
	task_del(systq, &dev->mode_config.poll_task);
d1044 1
a1044 2
		timeout_add_sec(&dev->mode_config.output_poll_to,
		    DRM_OUTPUT_POLL_SECONDS);
d1050 1
a1050 3
	task_set(&dev->mode_config.poll_task, drm_output_poll_execute, dev);
	timeout_set(&dev->mode_config.output_poll_to, drm_output_poll_tick,
	    dev);
@


1.11
log
@Add an empty drm_sysfs_hotplug_event() function and use it
and the existing drm_sysfs* functions to remove some ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.10 2015/02/11 07:01:36 jsg Exp $	*/
d70 1
@


1.10
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.9 2015/02/10 03:39:41 jsg Exp $	*/
d962 1
a962 1
//	drm_sysfs_hotplug_event(dev);
@


1.9
log
@use linux function names when locking mode config
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.8 2015/01/27 03:17:36 dlg Exp $	*/
d319 1
a319 2
	if (crtc == NULL)
		printf("%s checking null crtc?\n", __func__);
@


1.8
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.7 2014/03/09 11:07:18 jsg Exp $	*/
d980 1
a980 1
	rw_enter_write(&dev->mode_config.rwl);
d1011 1
a1011 1
	rw_exit_write(&dev->mode_config.rwl);
d1084 1
a1084 1
	rw_enter_write(&dev->mode_config.rwl);
d1102 1
a1102 1
	rw_exit_write(&dev->mode_config.rwl);
@


1.7
log
@use linux style memory allocations in shared drm code
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.6 2013/12/16 19:57:09 kettenis Exp $	*/
d970 1
a970 1
static void drm_output_poll_execute(void *arg1, void *arg2)
d1060 1
a1060 2
	task_set(&dev->mode_config.poll_task, drm_output_poll_execute, dev,
	    NULL);
@


1.6
log
@Switch generic drm modesetting code over to Linux-style negative errno
return values.  Fixes at least one bug where userland would see a negative
errno value and hopefully doesn't introduce any new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.5 2013/10/30 02:11:32 dlg Exp $	*/
d590 2
a591 2
	save_crtcs = malloc(dev->mode_config.num_crtc *
	    sizeof(struct drm_crtc), M_DRM, M_WAITOK|M_ZERO);
d595 2
a596 2
	save_encoders = malloc(dev->mode_config.num_encoder *
	    sizeof(struct drm_encoder), M_DRM, M_WAITOK|M_ZERO);
d598 1
a598 1
		free(save_crtcs, M_DRM);
d602 2
a603 2
	save_connectors = malloc(dev->mode_config.num_connector *
	    sizeof(struct drm_connector), M_DRM, M_WAITOK|M_ZERO);
d605 2
a606 2
		free(save_crtcs, M_DRM);
		free(save_encoders, M_DRM);
d778 3
a780 3
	free(save_connectors, M_DRM);
	free(save_encoders, M_DRM);
	free(save_crtcs, M_DRM);
d806 3
a808 3
	free(save_connectors, M_DRM);
	free(save_encoders, M_DRM);
	free(save_crtcs, M_DRM);
@


1.5
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.4 2013/10/29 06:30:57 jsg Exp $	*/
d544 1
a544 1
 * Returns 0 on success, ERRNO on failure.
d564 1
a564 1
		return EINVAL;
d567 1
a567 1
		return EINVAL;
d570 1
a570 1
		return EINVAL;
d593 1
a593 1
		return ENOMEM;
d599 1
a599 1
		return ENOMEM;
d607 1
a607 1
		return ENOMEM;
d694 1
a694 1
		ret = EINVAL;
d716 1
a716 1
			ret = EINVAL;
d752 1
a752 1
				ret = EINVAL;
@


1.4
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.3 2013/09/02 06:25:27 jsg Exp $	*/
d1026 1
a1026 1
	task_add(taskq_systq(), &dev->mode_config.poll_task);
d1034 1
a1034 1
	task_del(taskq_systq(), &dev->mode_config.poll_task);
@


1.3
log
@add static back to functions that originally had it
reduces the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.2 2013/08/12 04:11:52 jsg Exp $	*/
d1026 1
a1026 2
	workq_queue_task(NULL, &dev->mode_config.poll_task, 0,
	    drm_output_poll_execute, dev, NULL);
d1034 1
d1060 2
@


1.2
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD: drm_crtc_helper.c,v 1.1 2013/03/18 12:36:51 jsg Exp $	*/
a39 11
void	 drm_mode_validate_flag(struct drm_connector *, int);
void	 drm_encoder_disable(struct drm_encoder *);
void	 drm_calc_timestamping_constants(struct drm_crtc *);
bool	 drm_encoder_crtc_ok(struct drm_encoder *, struct drm_crtc *);
void	 drm_crtc_prepare_encoders(struct drm_device *);
int	 drm_helper_choose_encoder_dpms(struct drm_encoder *);
int	 drm_helper_choose_crtc_dpms(struct drm_crtc *);
int	 drm_crtc_helper_disable(struct drm_crtc *);
void	 drm_output_poll_execute(void *, void *);
void	 drm_output_poll_tick(void *);

d51 1
a51 2
void
drm_helper_move_panel_connectors_to_head(struct drm_device *dev)
d71 1
a71 2
void
drm_mode_validate_flag(struct drm_connector *connector,
d112 1
a112 2
int
drm_helper_probe_single_connector_modes(struct drm_connector *connector,
d214 1
a214 2
bool
drm_helper_encoder_in_use(struct drm_encoder *encoder)
d237 1
a237 2
bool
drm_helper_crtc_in_use(struct drm_crtc *crtc)
d249 1
a249 1
void
d270 1
a270 2
void
drm_helper_disable_unused_functions(struct drm_device *dev)
d312 1
a312 2
bool
drm_encoder_crtc_ok(struct drm_encoder *encoder,
d340 1
a340 1
void
d381 1
a381 2
bool
drm_crtc_helper_set_mode(struct drm_crtc *crtc,
d506 1
a506 1
int
d546 1
a546 2
int
drm_crtc_helper_set_config(struct drm_mode_set *set)
d813 1
a813 2
int
drm_helper_choose_encoder_dpms(struct drm_encoder *encoder)
d826 1
a826 2
int
drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)
d849 1
a849 2
void
drm_helper_connector_dpms(struct drm_connector *connector, int mode)
d897 1
a897 2
int
drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,
d916 1
a916 2
int
drm_helper_resume_force_mode(struct drm_device *dev)
d960 1
a960 2
void
drm_kms_helper_hotplug_event(struct drm_device *dev)
a968 9
void
drm_output_poll_tick(void *arg)
{
	struct drm_device *dev = arg;

	workq_queue_task(NULL, &dev->mode_config.poll_task, 0,
	    drm_output_poll_execute, dev, NULL);
}

d970 1
a970 2
void
drm_output_poll_execute(void *arg1, void *arg2)
d1021 10
a1030 2
void
drm_kms_helper_poll_disable(struct drm_device *dev)
d1038 1
a1038 2
void
drm_kms_helper_poll_enable(struct drm_device *dev)
d1058 1
a1058 2
void
drm_kms_helper_poll_init(struct drm_device *dev)
d1068 1
a1068 2
void
drm_kms_helper_poll_fini(struct drm_device *dev)
d1074 1
a1074 2
void
drm_helper_hpd_irq_event(struct drm_device *dev)
@


1.1
log
@Significantly increase the wordlist for ddb hangman,
and update our device independent DRM code and the Intel DRM code
to be mostly in sync with Linux 3.8.3.  Among other things this
brings support for kernel modesetting and enables use of
the rings on gen6+ Intel hardware.

Based on some earlier work from matthieu@@ with some hints from FreeBSD
and with lots of help from kettenis@@ (including a beautiful accelerated
wscons framebuffer console!)

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1038 5
a1042 5
		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",
			      connector->base.id,
			      drm_get_connector_name(connector),
			      old_status, connector->status);
		if (old_status != connector->status)
d1044 1
@

