head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.8
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.6
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.8.0.4
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2015.09.27.11.09.26;	author jsg;	state Exp;
branches;
next	1.8;
commitid	OkoKp05dU7tP7DK3;

1.8
date	2015.04.18.14.47.35;	author jsg;	state Exp;
branches;
next	1.7;
commitid	c1fUeeFWMNg4COgR;

1.7
date	2015.04.11.05.10.13;	author jsg;	state Exp;
branches;
next	1.6;
commitid	pjaRMzmEKTQk8EZt;

1.6
date	2015.02.12.06.52.11;	author jsg;	state Exp;
branches;
next	1.5;
commitid	q8lsF9SxaT1LyCh4;

1.5
date	2015.02.11.07.01.37;	author jsg;	state Exp;
branches;
next	1.4;
commitid	dLgISW35NAmGN8Xl;

1.4
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.3;
commitid	aHLMSW1RfE1rmMw9;

1.3
date	2015.02.10.06.19.36;	author jsg;	state Exp;
branches;
next	1.2;
commitid	0OQNG9STPII6jEb4;

1.2
date	2014.02.09.10.57.26;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.12.04.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Switch remaining users of the FreeBSD refcount apis back to the original
linux kref/kobject use.

ok kettenis@@
@
text
@/*	$OpenBSD: ttm_object.c,v 1.8 2015/04/18 14:47:35 jsg Exp $	*/
/**************************************************************************
 *
 * Copyright (c) 2009 VMware, Inc., Palo Alto, CA., USA
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
/*
 * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
 */
/** @@file ttm_ref_object.c
 *
 * Base- and reference object implementation for the various
 * ttm objects. Implements reference counting, minimal security checks
 * and release on file close.
 */

/**
 * struct ttm_object_file
 *
 * @@tdev: Pointer to the ttm_object_device.
 *
 * @@lock: Lock that protects the ref_list list and the
 * ref_hash hash tables.
 *
 * @@ref_list: List of ttm_ref_objects to be destroyed at
 * file release.
 *
 * @@ref_hash: Hash tables of ref objects, one per ttm_ref_type,
 * for fast lookup of ref objects given a base object.
 */

#define pr_fmt(fmt) "[TTM] " fmt

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/ttm/ttm_object.h>
#include <dev/pci/drm/ttm/ttm_module.h>

struct ttm_object_file {
	struct ttm_object_device *tdev;
	rwlock_t lock;
	struct list_head ref_list;
	struct drm_open_hash ref_hash[TTM_REF_NUM];
	struct kref refcount;
};

/**
 * struct ttm_object_device
 *
 * @@object_lock: lock that protects the object_hash hash table.
 *
 * @@object_hash: hash table for fast lookup of object global names.
 *
 * @@object_count: Per device object count.
 *
 * This is the per-device data structure needed for ttm object management.
 */

struct ttm_object_device {
	spinlock_t object_lock;
	struct drm_open_hash object_hash;
	atomic_t object_count;
	struct ttm_mem_global *mem_glob;
};

/**
 * struct ttm_ref_object
 *
 * @@hash: Hash entry for the per-file object reference hash.
 *
 * @@head: List entry for the per-file list of ref-objects.
 *
 * @@kref: Ref count.
 *
 * @@obj: Base object this ref object is referencing.
 *
 * @@ref_type: Type of ref object.
 *
 * This is similar to an idr object, but it also has a hash table entry
 * that allows lookup with a pointer to the referenced object as a key. In
 * that way, one can easily detect whether a base object is referenced by
 * a particular ttm_object_file. It also carries a ref count to avoid creating
 * multiple ref objects if a ttm_object_file references the same base
 * object more than once.
 */

struct ttm_ref_object {
	struct drm_hash_item hash;
	struct list_head head;
	struct kref kref;
	enum ttm_ref_type ref_type;
	struct ttm_base_object *obj;
	struct ttm_object_file *tfile;
};

static inline struct ttm_object_file *
ttm_object_file_ref(struct ttm_object_file *tfile)
{
	kref_get(&tfile->refcount);
	return tfile;
}

static void ttm_object_file_destroy(struct kref *kref)
{
	struct ttm_object_file *tfile =
		container_of(kref, struct ttm_object_file, refcount);

	kfree(tfile);
}


static inline void ttm_object_file_unref(struct ttm_object_file **p_tfile)
{
	struct ttm_object_file *tfile = *p_tfile;

	*p_tfile = NULL;
	kref_put(&tfile->refcount, ttm_object_file_destroy);
}


int ttm_base_object_init(struct ttm_object_file *tfile,
			 struct ttm_base_object *base,
			 bool shareable,
			 enum ttm_object_type object_type,
			 void (*refcount_release) (struct ttm_base_object **),
			 void (*ref_obj_release) (struct ttm_base_object *,
						  enum ttm_ref_type ref_type))
{
	struct ttm_object_device *tdev = tfile->tdev;
	int ret;

	base->shareable = shareable;
	base->tfile = ttm_object_file_ref(tfile);
	base->refcount_release = refcount_release;
	base->ref_obj_release = ref_obj_release;
	base->object_type = object_type;
	kref_init(&base->refcount);
	spin_lock(&tdev->object_lock);
	ret = drm_ht_just_insert_please_rcu(&tdev->object_hash,
					    &base->hash,
					    (unsigned long)base, 31, 0, 0);
	spin_unlock(&tdev->object_lock);
	if (unlikely(ret != 0))
		goto out_err0;

	ret = ttm_ref_object_add(tfile, base, TTM_REF_USAGE, NULL);
	if (unlikely(ret != 0))
		goto out_err1;

	ttm_base_object_unref(&base);

	return 0;
out_err1:
	spin_lock(&tdev->object_lock);
	(void)drm_ht_remove_item_rcu(&tdev->object_hash, &base->hash);
	spin_unlock(&tdev->object_lock);
out_err0:
	return ret;
}
EXPORT_SYMBOL(ttm_base_object_init);

static void ttm_release_base(struct kref *kref)
{
	struct ttm_base_object *base =
	    container_of(kref, struct ttm_base_object, refcount);
	struct ttm_object_device *tdev = base->tfile->tdev;

	spin_lock(&tdev->object_lock);
	(void)drm_ht_remove_item_rcu(&tdev->object_hash, &base->hash);
	spin_unlock(&tdev->object_lock);

	/*
	 * Note: We don't use synchronize_rcu() here because it's far
	 * too slow. It's up to the user to free the object using
	 * call_rcu() or ttm_base_object_kfree().
	 */

	if (base->refcount_release) {
		ttm_object_file_unref(&base->tfile);
		base->refcount_release(&base);
	}
}

void ttm_base_object_unref(struct ttm_base_object **p_base)
{
	struct ttm_base_object *base = *p_base;

	*p_base = NULL;

	kref_put(&base->refcount, ttm_release_base);
}
EXPORT_SYMBOL(ttm_base_object_unref);

struct ttm_base_object *ttm_base_object_lookup(struct ttm_object_file *tfile,
					       uint32_t key)
{
	struct ttm_object_device *tdev = tfile->tdev;
	struct ttm_base_object *base;
	struct drm_hash_item *hash;
	int ret;

	mtx_enter(&tdev->object_lock);
	ret = drm_ht_find_item(&tdev->object_hash, key, &hash);

	if (likely(ret == 0)) {
		base = drm_hash_entry(hash, struct ttm_base_object, hash);
		ret = kref_get_unless_zero(&base->refcount) ? 0 : -EINVAL;
	}
	mtx_leave(&tdev->object_lock);

	if (unlikely(ret != 0))
		return NULL;

	if (tfile != base->tfile && !base->shareable) {
		pr_err("Attempted access of non-shareable object\n");
		ttm_base_object_unref(&base);
		return NULL;
	}

	return base;
}
EXPORT_SYMBOL(ttm_base_object_lookup);

int ttm_ref_object_add(struct ttm_object_file *tfile,
		       struct ttm_base_object *base,
		       enum ttm_ref_type ref_type, bool *existed)
{
	struct drm_open_hash *ht = &tfile->ref_hash[ref_type];
	struct ttm_ref_object *ref;
	struct drm_hash_item *hash;
	struct ttm_mem_global *mem_glob = tfile->tdev->mem_glob;
	int ret = -EINVAL;

	if (existed != NULL)
		*existed = true;

	while (ret == -EINVAL) {
		read_lock(&tfile->lock);
		ret = drm_ht_find_item(ht, base->hash.key, &hash);

		if (ret == 0) {
			ref = drm_hash_entry(hash, struct ttm_ref_object, hash);
			kref_get(&ref->kref);
			read_unlock(&tfile->lock);
			break;
		}

		read_unlock(&tfile->lock);
		ret = ttm_mem_global_alloc(mem_glob, sizeof(*ref),
					   false, false);
		if (unlikely(ret != 0))
			return ret;
		ref = kmalloc(sizeof(*ref), GFP_KERNEL);
		if (unlikely(ref == NULL)) {
			ttm_mem_global_free(mem_glob, sizeof(*ref));
			return -ENOMEM;
		}

		ref->hash.key = base->hash.key;
		ref->obj = base;
		ref->tfile = tfile;
		ref->ref_type = ref_type;
		kref_init(&ref->kref);

		write_lock(&tfile->lock);
		ret = drm_ht_insert_item(ht, &ref->hash);

		if (likely(ret == 0)) {
			list_add_tail(&ref->head, &tfile->ref_list);
			kref_get(&base->refcount);
			write_unlock(&tfile->lock);
			if (existed != NULL)
				*existed = false;
			break;
		}

		write_unlock(&tfile->lock);
		BUG_ON(ret != -EINVAL);

		ttm_mem_global_free(mem_glob, sizeof(*ref));
		kfree(ref);
	}

	return ret;
}
EXPORT_SYMBOL(ttm_ref_object_add);

static void ttm_ref_object_release(struct kref *kref)
{
	struct ttm_ref_object *ref =
	    container_of(kref, struct ttm_ref_object, kref);
	struct ttm_base_object *base = ref->obj;
	struct ttm_object_file *tfile = ref->tfile;
	struct drm_open_hash *ht;
	struct ttm_mem_global *mem_glob = tfile->tdev->mem_glob;

	ht = &tfile->ref_hash[ref->ref_type];
	(void)drm_ht_remove_item(ht, &ref->hash);
	list_del(&ref->head);
	write_unlock(&tfile->lock);

	if (ref->ref_type != TTM_REF_USAGE && base->ref_obj_release)
		base->ref_obj_release(base, ref->ref_type);

	ttm_base_object_unref(&ref->obj);
	ttm_mem_global_free(mem_glob, sizeof(*ref));
	kfree(ref);
	write_lock(&tfile->lock);
}

int ttm_ref_object_base_unref(struct ttm_object_file *tfile,
			      unsigned long key, enum ttm_ref_type ref_type)
{
	struct drm_open_hash *ht = &tfile->ref_hash[ref_type];
	struct ttm_ref_object *ref;
	struct drm_hash_item *hash;
	int ret;

	write_lock(&tfile->lock);
	ret = drm_ht_find_item(ht, key, &hash);
	if (unlikely(ret != 0)) {
		write_unlock(&tfile->lock);
		return -EINVAL;
	}
	ref = drm_hash_entry(hash, struct ttm_ref_object, hash);
	kref_put(&ref->kref, ttm_ref_object_release);
	write_unlock(&tfile->lock);
	return 0;
}
EXPORT_SYMBOL(ttm_ref_object_base_unref);

void ttm_object_file_release(struct ttm_object_file **p_tfile)
{
	struct ttm_ref_object *ref;
	struct list_head *list;
	unsigned int i;
	struct ttm_object_file *tfile = *p_tfile;

	*p_tfile = NULL;
	write_lock(&tfile->lock);

	/*
	 * Since we release the lock within the loop, we have to
	 * restart it from the beginning each time.
	 */

	while (!list_empty(&tfile->ref_list)) {
		list = tfile->ref_list.next;
		ref = list_entry(list, struct ttm_ref_object, head);
		ttm_ref_object_release(&ref->kref);
	}

	for (i = 0; i < TTM_REF_NUM; ++i)
		drm_ht_remove(&tfile->ref_hash[i]);

	write_unlock(&tfile->lock);
	ttm_object_file_unref(&tfile);
}
EXPORT_SYMBOL(ttm_object_file_release);

struct ttm_object_file *ttm_object_file_init(struct ttm_object_device *tdev,
					     unsigned int hash_order)
{
	struct ttm_object_file *tfile = kmalloc(sizeof(*tfile), GFP_KERNEL);
	unsigned int i;
	unsigned int j = 0;
	int ret;

	if (unlikely(tfile == NULL))
		return NULL;

	rw_init(&tfile->lock, "ttmfl");
	tfile->tdev = tdev;
	kref_init(&tfile->refcount);
	INIT_LIST_HEAD(&tfile->ref_list);

	for (i = 0; i < TTM_REF_NUM; ++i) {
		ret = drm_ht_create(&tfile->ref_hash[i], hash_order);
		if (ret) {
			j = i;
			goto out_err;
		}
	}

	return tfile;
out_err:
	for (i = 0; i < j; ++i)
		drm_ht_remove(&tfile->ref_hash[i]);

	kfree(tfile);

	return NULL;
}
EXPORT_SYMBOL(ttm_object_file_init);

struct ttm_object_device *ttm_object_device_init(struct ttm_mem_global
						 *mem_glob,
						 unsigned int hash_order)
{
	struct ttm_object_device *tdev = kmalloc(sizeof(*tdev), GFP_KERNEL);
	int ret;

	if (unlikely(tdev == NULL))
		return NULL;

	tdev->mem_glob = mem_glob;
	mtx_init(&tdev->object_lock, IPL_NONE);
	atomic_set(&tdev->object_count, 0);
	ret = drm_ht_create(&tdev->object_hash, hash_order);

	if (likely(ret == 0))
		return tdev;

	kfree(tdev);
	return NULL;
}
EXPORT_SYMBOL(ttm_object_device_init);

void ttm_object_device_release(struct ttm_object_device **p_tdev)
{
	struct ttm_object_device *tdev = *p_tdev;

	*p_tdev = NULL;

	spin_lock(&tdev->object_lock);
	drm_ht_remove(&tdev->object_hash);
	spin_unlock(&tdev->object_lock);

	kfree(tdev);
}
EXPORT_SYMBOL(ttm_object_device_release);
@


1.8
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.7 2015/04/11 05:10:13 jsg Exp $	*/
a57 1
#include <dev/pci/drm/refcount.h>
d64 1
a64 1
	int refcount;
d110 1
a110 1
	u_int kref;
d119 1
a119 1
	refcount_acquire(&tfile->refcount);
d123 1
a123 1
static void ttm_object_file_destroy(struct ttm_object_file *tfile)
d125 2
d137 1
a137 2
	if (refcount_release(&tfile->refcount))
		ttm_object_file_destroy(tfile);
d157 1
a157 1
	refcount_init(&base->refcount, 1);
d182 1
a182 1
static void ttm_release_base(struct ttm_base_object *base)
d184 2
d210 1
a210 2
	if (refcount_release(&base->refcount))
		ttm_release_base(base);
d227 1
a227 1
		refcount_acquire(&base->refcount);
d263 1
a263 1
			refcount_acquire(&ref->kref);
d283 1
a283 1
		refcount_init(&ref->kref, 1);
d290 1
a290 1
			refcount_acquire(&base->refcount);
d308 1
a308 1
static void ttm_ref_object_release(struct ttm_ref_object *ref)
d310 2
d346 1
a346 2
	if (refcount_release(&ref->kref))
		ttm_ref_object_release(ref);
d370 1
a370 1
		ttm_ref_object_release(ref);
d394 1
a394 1
	refcount_init(&tfile->refcount, 1);
@


1.7
log
@change back to spinlock_t/DEFINE_SPINLOCK
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.6 2015/02/12 06:52:11 jsg Exp $	*/
d62 1
a62 1
	struct rwlock lock;
@


1.6
log
@switch some free calls back to kfree
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.5 2015/02/11 07:01:37 jsg Exp $	*/
d81 1
a81 1
	struct mutex object_lock;
@


1.5
log
@Switch most printf style functions calls back to linux function names
and move DRM_INFO/pr_info/dev_info messages under DRMDEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.4 2015/02/10 10:50:49 jsg Exp $	*/
d130 1
d193 1
a193 1
	 * call_rcu() or ttm_base_object_free().
@


1.4
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.3 2015/02/10 06:19:36 jsg Exp $	*/
d233 1
a233 1
		DRM_ERROR("Attempted access of non-shareable object\n");
@


1.3
log
@switch most rwlock calls back to their linux equivalents
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.2 2014/02/09 10:57:26 jsg Exp $	*/
d157 1
a157 1
	mtx_enter(&tdev->object_lock);
d161 1
a161 1
	mtx_leave(&tdev->object_lock);
d173 1
a173 1
	mtx_enter(&tdev->object_lock);
d175 1
a175 1
	mtx_leave(&tdev->object_lock);
d185 1
a185 1
	mtx_enter(&tdev->object_lock);
d187 1
a187 1
	mtx_leave(&tdev->object_lock);
d442 1
a442 1
	mtx_enter(&tdev->object_lock);
d444 1
a444 1
	mtx_leave(&tdev->object_lock);
@


1.2
log
@use linux style memory allocations in ttm
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_object.c,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/
d256 1
a256 1
		rw_enter_read(&tfile->lock);
d262 1
a262 1
			rw_exit_read(&tfile->lock);
d266 1
a266 1
		rw_exit_read(&tfile->lock);
d283 1
a283 1
		rw_enter_write(&tfile->lock);
d289 1
a289 1
			rw_exit_write(&tfile->lock);
d295 1
a295 1
		rw_exit_write(&tfile->lock);
d316 1
a316 1
	rw_exit_write(&tfile->lock);
d324 1
a324 1
	rw_enter_write(&tfile->lock);
d335 1
a335 1
	rw_enter_write(&tfile->lock);
d338 1
a338 1
		rw_exit_write(&tfile->lock);
d344 1
a344 1
	rw_exit_write(&tfile->lock);
d357 1
a357 1
	rw_enter_write(&tfile->lock);
d373 1
a373 1
	rw_exit_write(&tfile->lock);
@


1.1
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 1
a127 1
	free(tfile, M_DRM);
d271 1
a271 1
		ref = malloc(sizeof(*ref), M_DRM, M_WAITOK);
d299 1
a299 1
		free(ref, M_DRM);
d323 1
a323 1
	free(ref, M_DRM);
d381 1
a381 1
	struct ttm_object_file *tfile = malloc(sizeof(*tfile), M_DRM, M_WAITOK);
d407 1
a407 1
	free(tfile, M_DRM);
d417 1
a417 1
	struct ttm_object_device *tdev = malloc(sizeof(*tdev), M_DRM, M_WAITOK);
d431 1
a431 1
	free(tdev, M_DRM);
d446 1
a446 1
	free(tdev, M_DRM);
@

