head	1.5;
access;
symbols
	OPENBSD_6_1:1.5.0.10
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.8
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2015.04.12.03.54.10;	author jsg;	state Exp;
branches;
next	1.4;
commitid	uVTyY1h8Sggc8pFj;

1.4
date	2015.04.06.05.35.29;	author jsg;	state Exp;
branches;
next	1.3;
commitid	oeVBooRupIYToF2n;

1.3
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.2;
commitid	aHLMSW1RfE1rmMw9;

1.2
date	2013.12.08.07.54.06;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.12.04.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@make wait_queue_head a struct with a mutex
better matches linux behaviour
@
text
@/*	$OpenBSD: ttm_lock.c,v 1.4 2015/04/06 05:35:29 jsg Exp $	*/
/**************************************************************************
 *
 * Copyright (c) 2007-2009 VMware, Inc., Palo Alto, CA., USA
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/
/*
 * Authors: Thomas Hellstrom <thellstrom-at-vmware-dot-com>
 */

#include <dev/pci/drm/drmP.h>
#include <dev/pci/drm/ttm/ttm_lock.h>
#include <dev/pci/drm/ttm/ttm_module.h>

#define TTM_WRITE_LOCK_PENDING    (1 << 0)
#define TTM_VT_LOCK_PENDING       (1 << 1)
#define TTM_SUSPEND_LOCK_PENDING  (1 << 2)
#define TTM_VT_LOCK               (1 << 3)
#define TTM_SUSPEND_LOCK          (1 << 4)

void	 ttm_write_lock_downgrade(struct ttm_lock *);

void ttm_lock_init(struct ttm_lock *lock)
{
	mtx_init(&lock->lock, IPL_NONE);
	init_waitqueue_head(&lock->queue);
	lock->rw = 0;
	lock->flags = 0;
	lock->kill_takers = false;
	lock->signal = SIGKILL;
}
EXPORT_SYMBOL(ttm_lock_init);

void ttm_read_unlock(struct ttm_lock *lock)
{
	spin_lock(&lock->lock);
	if (--lock->rw == 0)
		wake_up_all(&lock->queue);
	spin_unlock(&lock->lock);
}
EXPORT_SYMBOL(ttm_read_unlock);

#ifdef notyet
static bool __ttm_read_lock(struct ttm_lock *lock)
{
	bool locked = false;

	spin_lock(&lock->lock);
	if (unlikely(lock->kill_takers)) {
		send_sig(lock->signal, current, 0);
		spin_unlock(&lock->lock);
		return false;
	}
	if (lock->rw >= 0 && lock->flags == 0) {
		++lock->rw;
		locked = true;
	}
	spin_unlock(&lock->lock);
	return locked;
}
#endif

int ttm_read_lock(struct ttm_lock *lock, bool interruptible)
{
	printf("%s stub\n", __func__);
	return -ENOSYS;
#ifdef notyet
	int ret = 0;

	if (interruptible)
		ret = wait_event_interruptible(lock->queue,
					       __ttm_read_lock(lock));
	else
		wait_event(lock->queue, __ttm_read_lock(lock));
	return ret;
#endif
}
EXPORT_SYMBOL(ttm_read_lock);

#ifdef notyet
static bool __ttm_read_trylock(struct ttm_lock *lock, bool *locked)
{
	bool block = true;

	*locked = false;

	spin_lock(&lock->lock);
	if (unlikely(lock->kill_takers)) {
		send_sig(lock->signal, current, 0);
		spin_unlock(&lock->lock);
		return false;
	}
	if (lock->rw >= 0 && lock->flags == 0) {
		++lock->rw;
		block = false;
		*locked = true;
	} else if (lock->flags == 0) {
		block = false;
	}
	spin_unlock(&lock->lock);

	return !block;
}
#endif

int ttm_read_trylock(struct ttm_lock *lock, bool interruptible)
{
	printf("%s stub\n", __func__);
	return -ENOSYS;
#ifdef notyet
	int ret = 0;
	bool locked;

	if (interruptible)
		ret = wait_event_interruptible
			(lock->queue, __ttm_read_trylock(lock, &locked));
	else
		wait_event(lock->queue, __ttm_read_trylock(lock, &locked));

	if (unlikely(ret != 0)) {
		BUG_ON(locked);
		return ret;
	}

	return (locked) ? 0 : -EBUSY;
#endif
}

void ttm_write_unlock(struct ttm_lock *lock)
{
	spin_lock(&lock->lock);
	lock->rw = 0;
	wake_up_all(&lock->queue);
	spin_unlock(&lock->lock);
}
EXPORT_SYMBOL(ttm_write_unlock);

#ifdef notyet
static bool __ttm_write_lock(struct ttm_lock *lock)
{
	bool locked = false;

	spin_lock(&lock->lock);
	if (unlikely(lock->kill_takers)) {
		send_sig(lock->signal, current, 0);
		spin_unlock(&lock->lock);
		return false;
	}
	if (lock->rw == 0 && ((lock->flags & ~TTM_WRITE_LOCK_PENDING) == 0)) {
		lock->rw = -1;
		lock->flags &= ~TTM_WRITE_LOCK_PENDING;
		locked = true;
	} else {
		lock->flags |= TTM_WRITE_LOCK_PENDING;
	}
	spin_unlock(&lock->lock);
	return locked;
}
#endif

int ttm_write_lock(struct ttm_lock *lock, bool interruptible)
{
	printf("%s stub\n", __func__);
	return -ENOSYS;
#ifdef notyet
	int ret = 0;

	if (interruptible) {
		ret = wait_event_interruptible(lock->queue,
					       __ttm_write_lock(lock));
		if (unlikely(ret != 0)) {
			spin_lock(&lock->lock);
			lock->flags &= ~TTM_WRITE_LOCK_PENDING;
			wake_up_all(&lock->queue);
			spin_unlock(&lock->lock);
		}
	} else
		wait_event(lock->queue, __ttm_read_lock(lock));

	return ret;
#endif
}
EXPORT_SYMBOL(ttm_write_lock);

void ttm_write_lock_downgrade(struct ttm_lock *lock)
{
	spin_lock(&lock->lock);
	lock->rw = 1;
	wake_up_all(&lock->queue);
	spin_unlock(&lock->lock);
}

#ifdef notyet
static int __ttm_vt_unlock(struct ttm_lock *lock)
{
	int ret = 0;

	spin_lock(&lock->lock);
	if (unlikely(!(lock->flags & TTM_VT_LOCK)))
		ret = -EINVAL;
	lock->flags &= ~TTM_VT_LOCK;
	wake_up_all(&lock->queue);
	spin_unlock(&lock->lock);

	return ret;
}
#endif

#ifdef notyet
static void ttm_vt_lock_remove(struct ttm_base_object **p_base)
{
	struct ttm_base_object *base = *p_base;
	struct ttm_lock *lock = container_of(base, struct ttm_lock, base);
	int ret;

	*p_base = NULL;
	ret = __ttm_vt_unlock(lock);
	BUG_ON(ret != 0);
}
#endif

#ifdef notyet
static bool __ttm_vt_lock(struct ttm_lock *lock)
{
	bool locked = false;

	spin_lock(&lock->lock);
	if (lock->rw == 0) {
		lock->flags &= ~TTM_VT_LOCK_PENDING;
		lock->flags |= TTM_VT_LOCK;
		locked = true;
	} else {
		lock->flags |= TTM_VT_LOCK_PENDING;
	}
	spin_unlock(&lock->lock);
	return locked;
}
#endif

int ttm_vt_lock(struct ttm_lock *lock,
		bool interruptible,
		struct ttm_object_file *tfile)
{
	printf("%s stub\n", __func__);
	return -ENOSYS;
#ifdef notyet
	int ret = 0;

	if (interruptible) {
		ret = wait_event_interruptible(lock->queue,
					       __ttm_vt_lock(lock));
		if (unlikely(ret != 0)) {
			spin_lock(&lock->lock);
			lock->flags &= ~TTM_VT_LOCK_PENDING;
			wake_up_all(&lock->queue);
			spin_unlock(&lock->lock);
			return ret;
		}
	} else
		wait_event(lock->queue, __ttm_vt_lock(lock));

	/*
	 * Add a base-object, the destructor of which will
	 * make sure the lock is released if the client dies
	 * while holding it.
	 */

	ret = ttm_base_object_init(tfile, &lock->base, false,
				   ttm_lock_type, &ttm_vt_lock_remove, NULL);
	if (ret)
		(void)__ttm_vt_unlock(lock);
	else
		lock->vt_holder = tfile;

	return ret;
#endif
}
EXPORT_SYMBOL(ttm_vt_lock);

int ttm_vt_unlock(struct ttm_lock *lock)
{
	return ttm_ref_object_base_unref(lock->vt_holder,
					 lock->base.hash.key, TTM_REF_USAGE);
}
EXPORT_SYMBOL(ttm_vt_unlock);

void ttm_suspend_unlock(struct ttm_lock *lock)
{
	spin_lock(&lock->lock);
	lock->flags &= ~TTM_SUSPEND_LOCK;
	wake_up_all(&lock->queue);
	spin_unlock(&lock->lock);
}
EXPORT_SYMBOL(ttm_suspend_unlock);

#ifdef notyet
static bool __ttm_suspend_lock(struct ttm_lock *lock)
{
	bool locked = false;

	spin_lock(&lock->lock);
	if (lock->rw == 0) {
		lock->flags &= ~TTM_SUSPEND_LOCK_PENDING;
		lock->flags |= TTM_SUSPEND_LOCK;
		locked = true;
	} else {
		lock->flags |= TTM_SUSPEND_LOCK_PENDING;
	}
	spin_unlock(&lock->lock);
	return locked;
}
#endif

void ttm_suspend_lock(struct ttm_lock *lock)
{
	printf("%s stub\n", __func__);
#ifdef notyet
	wait_event(lock->queue, __ttm_suspend_lock(lock));
#endif
}
EXPORT_SYMBOL(ttm_suspend_lock);
@


1.4
log
@add and use macros for wake_up/wake_up_all/wake_up_all_locked
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_lock.c,v 1.3 2015/02/10 10:50:49 jsg Exp $	*/
a46 1
#ifdef notyet
a47 1
#endif
@


1.3
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_lock.c,v 1.2 2013/12/08 07:54:06 jsg Exp $	*/
d61 1
a61 1
		wakeup(&lock->queue);
d156 1
a156 1
	wakeup(&lock->queue);
d212 1
a212 1
	wakeup(&lock->queue);
d225 1
a225 1
	wakeup(&lock->queue);
d314 1
a314 1
	wakeup(&lock->queue);
@


1.2
log
@add static back to the ttm functions
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_lock.c,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/
d59 1
a59 1
	mtx_enter(&lock->lock);
d62 1
a62 1
	mtx_leave(&lock->lock);
d71 1
a71 1
	mtx_enter(&lock->lock);
d74 1
a74 1
		mtx_leave(&lock->lock);
d81 1
a81 1
	mtx_leave(&lock->lock);
d110 1
a110 1
	mtx_enter(&lock->lock);
d113 1
a113 1
		mtx_leave(&lock->lock);
d123 1
a123 1
	mtx_leave(&lock->lock);
d154 1
a154 1
	mtx_enter(&lock->lock);
d157 1
a157 1
	mtx_leave(&lock->lock);
d166 1
a166 1
	mtx_enter(&lock->lock);
d169 1
a169 1
		mtx_leave(&lock->lock);
d179 1
a179 1
	mtx_leave(&lock->lock);
d195 1
a195 1
			mtx_enter(&lock->lock);
d198 1
a198 1
			mtx_leave(&lock->lock);
d210 1
a210 1
	mtx_enter(&lock->lock);
d213 1
a213 1
	mtx_leave(&lock->lock);
d221 1
a221 1
	mtx_enter(&lock->lock);
d226 1
a226 1
	mtx_leave(&lock->lock);
d250 1
a250 1
	mtx_enter(&lock->lock);
d258 1
a258 1
	mtx_leave(&lock->lock);
d276 1
a276 1
			mtx_enter(&lock->lock);
d279 1
a279 1
			mtx_leave(&lock->lock);
d312 1
a312 1
	mtx_enter(&lock->lock);
d315 1
a315 1
	mtx_leave(&lock->lock);
d324 1
a324 1
	mtx_enter(&lock->lock);
d332 1
a332 1
	mtx_leave(&lock->lock);
@


1.1
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 6
bool	 __ttm_read_lock(struct ttm_lock *);
bool	 __ttm_read_trylock(struct ttm_lock *, bool *);
bool	 __ttm_write_lock(struct ttm_lock *);
void	 ttm_vt_lock_remove(struct ttm_base_object **);
bool	 __ttm_vt_lock(struct ttm_lock *);
bool	 __ttm_suspend_lock(struct ttm_lock *);
d66 2
a67 2
bool
__ttm_read_lock(struct ttm_lock *lock)
a68 3
	printf("%s stub\n", __func__);
	return false;
#ifdef notyet
d83 1
a84 1
}
d103 2
a104 2
bool
__ttm_read_trylock(struct ttm_lock *lock, bool *locked)
a105 3
	printf("%s stub\n", __func__);
	return -ENOSYS;
#ifdef notyet
d126 1
a127 1
}
d161 2
a162 2
bool
__ttm_write_lock(struct ttm_lock *lock)
a163 3
	printf("%s stub\n", __func__);
	return false;
#ifdef notyet
d181 1
a182 1
}
d216 1
d230 1
d232 2
a233 2
void
ttm_vt_lock_remove(struct ttm_base_object **p_base)
d243 1
d245 2
a246 2
bool
__ttm_vt_lock(struct ttm_lock *lock)
d261 1
d319 2
a320 2
bool
__ttm_suspend_lock(struct ttm_lock *lock)
d335 1
@

