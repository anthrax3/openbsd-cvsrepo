head	1.5;
access;
symbols
	OPENBSD_6_2_BASE:1.5
	OPENBSD_6_1:1.5.0.8
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.4.0.4
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.3.0.4
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.6
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.4
	OPENBSD_5_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.5
date	2015.09.27.11.09.26;	author jsg;	state Exp;
branches;
next	1.4;
commitid	OkoKp05dU7tP7DK3;

1.4
date	2015.04.18.14.47.35;	author jsg;	state Exp;
branches;
next	1.3;
commitid	c1fUeeFWMNg4COgR;

1.3
date	2015.02.10.10.50.49;	author jsg;	state Exp;
branches;
next	1.2;
commitid	aHLMSW1RfE1rmMw9;

1.2
date	2013.10.29.06.30.57;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2013.08.12.04.11.53;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Switch remaining users of the FreeBSD refcount apis back to the original
linux kref/kobject use.

ok kettenis@@
@
text
@/*	$OpenBSD: ttm_memory.h,v 1.4 2015/04/18 14:47:35 jsg Exp $	*/
/**************************************************************************
 *
 * Copyright (c) 2006-2009 VMware, Inc., Palo Alto, CA., USA
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 **************************************************************************/

#ifndef TTM_MEMORY_H
#define TTM_MEMORY_H

#include <sys/task.h>

/**
 * struct ttm_mem_shrink - callback to shrink TTM memory usage.
 *
 * @@do_shrink: The callback function.
 *
 * Arguments to the do_shrink functions are intended to be passed using
 * inheritance. That is, the argument class derives from struct ttm_mem_shrink,
 * and can be accessed using container_of().
 */

struct ttm_mem_shrink {
	int (*do_shrink) (struct ttm_mem_shrink *);
};

/**
 * struct ttm_mem_global - Global memory accounting structure.
 *
 * @@shrink: A single callback to shrink TTM memory usage. Extend this
 * to a linked list to be able to handle multiple callbacks when needed.
 * @@swap_queue: A workqueue to handle shrinking in low memory situations. We
 * need a separate workqueue since it will spend a lot of time waiting
 * for the GPU, and this will otherwise block other workqueue tasks(?)
 * At this point we use only a single-threaded workqueue.
 * @@work: The workqueue callback for the shrink queue.
 * @@lock: Lock to protect the @@shrink - and the memory accounting members,
 * that is, essentially the whole structure with some exceptions.
 * @@zones: Array of pointers to accounting zones.
 * @@num_zones: Number of populated entries in the @@zones array.
 * @@zone_kernel: Pointer to the kernel zone.
 * @@zone_highmem: Pointer to the highmem zone if there is one.
 * @@zone_dma32: Pointer to the dma32 zone if there is one.
 *
 * Note that this structure is not per device. It should be global for all
 * graphics devices.
 */

#define TTM_MEM_MAX_ZONES 2
struct ttm_mem_zone;
struct ttm_mem_global {
	struct kobject kobj;
	struct ttm_mem_shrink *shrink;
	struct taskq *swap_queue;
	struct task task;
	bool task_queued;
	spinlock_t lock;
	struct ttm_mem_zone *zones[TTM_MEM_MAX_ZONES];
	unsigned int num_zones;
	struct ttm_mem_zone *zone_kernel;
#ifdef CONFIG_HIGHMEM
	struct ttm_mem_zone *zone_highmem;
#else
	struct ttm_mem_zone *zone_dma32;
#endif
};

/**
 * ttm_mem_init_shrink - initialize a struct ttm_mem_shrink object
 *
 * @@shrink: The object to initialize.
 * @@func: The callback function.
 */

static inline void ttm_mem_init_shrink(struct ttm_mem_shrink *shrink,
				       int (*func) (struct ttm_mem_shrink *))
{
	shrink->do_shrink = func;
}

/**
 * ttm_mem_register_shrink - register a struct ttm_mem_shrink object.
 *
 * @@glob: The struct ttm_mem_global object to register with.
 * @@shrink: An initialized struct ttm_mem_shrink object to register.
 *
 * Returns:
 * -EBUSY: There's already a callback registered. (May change).
 */

static inline int ttm_mem_register_shrink(struct ttm_mem_global *glob,
					  struct ttm_mem_shrink *shrink)
{
	spin_lock(&glob->lock);
	if (glob->shrink != NULL) {
		spin_unlock(&glob->lock);
		return -EBUSY;
	}
	glob->shrink = shrink;
	spin_unlock(&glob->lock);
	return 0;
}

/**
 * ttm_mem_unregister_shrink - unregister a struct ttm_mem_shrink object.
 *
 * @@glob: The struct ttm_mem_global object to unregister from.
 * @@shrink: A previously registert struct ttm_mem_shrink object.
 *
 */

static inline void ttm_mem_unregister_shrink(struct ttm_mem_global *glob,
					     struct ttm_mem_shrink *shrink)
{
	spin_lock(&glob->lock);
	BUG_ON(glob->shrink != shrink);
	glob->shrink = NULL;
	spin_unlock(&glob->lock);
}

extern int ttm_mem_global_init(struct ttm_mem_global *glob);
extern void ttm_mem_global_release(struct ttm_mem_global *glob);
extern int ttm_mem_global_alloc(struct ttm_mem_global *glob, uint64_t memory,
				bool no_wait, bool interruptible);
extern void ttm_mem_global_free(struct ttm_mem_global *glob,
				uint64_t amount);
extern int ttm_mem_global_alloc_page(struct ttm_mem_global *glob,
				     struct vm_page *page,
				     bool no_wait, bool interruptible);
extern void ttm_mem_global_free_page(struct ttm_mem_global *glob,
				     struct vm_page *page);
extern size_t ttm_round_pot(size_t size);
#endif
@


1.4
log
@another round of reducing the diff to linux
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_memory.h,v 1.3 2015/02/10 10:50:49 jsg Exp $	*/
d73 1
a73 1
	u_int kobj_ref;
@


1.3
log
@switch most mtx_* calls back to linux spinlocks
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_memory.h,v 1.2 2013/10/29 06:30:57 jsg Exp $	*/
d78 1
a78 1
	struct mutex lock;
@


1.2
log
@Move most of the uses of workqs in drm to the new task/taskq api.
Prevents unintended multiple additions to workqs that was causing
hangs on radeon, and lets us remove tasks more closely matching
the behaviour of the original linux code.

ok kettenis@@
cause of the ttm/radeon hangs debugged by claudio@@ and kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ttm_memory.h,v 1.1 2013/08/12 04:11:53 jsg Exp $	*/
d115 1
a115 1
	mtx_enter(&glob->lock);
d117 1
a117 1
		mtx_leave(&glob->lock);
d121 1
a121 1
	mtx_leave(&glob->lock);
d136 1
a136 1
	mtx_enter(&glob->lock);
d139 1
a139 1
	mtx_leave(&glob->lock);
@


1.1
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d32 2
d75 2
a76 4
#ifdef notyet
	struct workqueue_struct *swap_queue;
#endif
	struct workq_task task;
@

