head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.14
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.12
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.8
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.26.0.6
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.8
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2014.03.13.13.35.21;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2013.08.12.04.11.52;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2012.12.06.14.46.17;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2012.09.08.16.42.20;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.22.15.17.05;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.26.07.25.06;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.24.03.49.19;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.22.22.10.42;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2008.10.07.21.59.32;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.18.15.10.57;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.09.21.02.06;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.02.01.12.04;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.17.20.49.52;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.17.16.56.14;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.17.15.31.39;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.02.16.03.05;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.29.19.44.13;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.26.18.35.24;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.26.16.42.47;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.12.13.55.59;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.26
log
@We no longer provide the dri1 agp interfaces, so remove the associated glue
as well.

ok jsg@@
@
text
@/* $OpenBSD: drm_agpsupport.c,v 1.25 2013/08/12 04:11:52 jsg Exp $ */
/*-
 * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Author:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *
 */

/*
 * Support code for tying the kernel AGP support to DRM drivers.
 */

#include "drmP.h"

#if __OS_HAS_AGP

int
drm_agp_info(struct drm_device * dev, struct drm_agp_info *info)
{
	struct agp_info	*kern;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	kern = &dev->agp->info;
	agp_get_info(dev->agp->agpdev, kern);
	info->agp_version_major = 1;
	info->agp_version_minor = 0;
	info->mode = kern->ai_mode;
	info->aperture_base = kern->ai_aperture_base;
	info->aperture_size = kern->ai_aperture_size;
	info->memory_allowed = kern->ai_memory_allowed;
	info->memory_used = kern->ai_memory_used;
	info->id_vendor = kern->ai_devid & 0xffff;
	info->id_device = kern->ai_devid >> 16;

	return (0);
}

int
drm_agp_acquire(struct drm_device *dev)
{
	int	retcode;

	if (dev->agp == NULL || dev->agp->acquired)
		return (EINVAL);

	retcode = agp_acquire(dev->agp->agpdev);
	if (retcode)
		return (retcode);

	dev->agp->acquired = 1;

	return (0);
}

int
drm_agp_release(struct drm_device * dev)
{
	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);
	agp_release(dev->agp->agpdev);
	dev->agp->acquired = 0;

	return (0);
}

int
drm_agp_enable(struct drm_device *dev, drm_agp_mode_t mode)
{
	int	retcode = 0;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	dev->agp->mode = mode.mode;
	if ((retcode = agp_enable(dev->agp->agpdev, mode.mode)) == 0)
		dev->agp->enabled = 1;
	return (retcode);
}

void
drm_agp_takedown(struct drm_device *dev)
{
	if (dev->agp == NULL)
		return;

	drm_agp_release(dev);
	dev->agp->enabled  = 0;
}

struct drm_agp_head *
drm_agp_init(void)
{
	struct agp_softc	*agpdev;
	struct drm_agp_head	*head = NULL;
	int		 	 agp_available = 1;

	agpdev = agp_find_device(0);
	if (agpdev == NULL)
		agp_available = 0;

	DRM_DEBUG("agp_available = %d\n", agp_available);

	if (agp_available) {
		head = drm_calloc(1, sizeof(*head));
		if (head == NULL)
			return (NULL);
		head->agpdev = agpdev;
		agp_get_info(agpdev, &head->info);
		head->base = head->info.ai_aperture_base;
		head->cant_use_aperture = (head->base == 0);
		TAILQ_INIT(&head->memory);
	}
	return (head);
}

#endif /* __OS_HAS_AGP */
@


1.25
log
@Add a port of the TTM and Radeon DRM code from Linux 3.8.13.
Includes kernel modesetting, framebuffer console and support
for newer hardware.

Firmware needs to be present for acceleration and in some cases
modesetting to work.  It can be installed via fw_update
or manually via pkg_add.

With lots of help from kettenis@@ some macppc bits from mpi@@
and some ttm refcount/queue bits from FreeBSD.

Thanks to M:Tier and the OpenBSD Foundation for sponsoring this work.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_agpsupport.c,v 1.24 2012/12/06 15:05:21 mpi Exp $ */
d33 1
a33 2
 * Support code for tying the kernel AGP support to DRM drivers and
 * the DRM's AGP ioctls.
a39 4
struct drm_agp_mem	*drm_agp_lookup_entry(struct drm_device *, void *);
void			 drm_agp_remove_entry(struct drm_device *,
			     struct drm_agp_mem *);

a63 16
drm_agp_info_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_info	*info = data;

	return (drm_agp_info(dev, info));
}

int
drm_agp_acquire_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	return (drm_agp_acquire(dev));
}

int
a80 7
drm_agp_release_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	return (drm_agp_release(dev));
}

int
a104 169
int
drm_agp_enable_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_mode	*mode = data;

	return (drm_agp_enable(dev, *mode));
}

int
drm_agp_alloc(struct drm_device *dev, struct drm_agp_buffer *request)
{
	struct drm_agp_mem	*entry;
	void			*handle;
	struct agp_memory_info	 info;
	unsigned long		 pages;
	u_int32_t		 type;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	entry = drm_alloc(sizeof(*entry));
	if (entry == NULL)
		return (ENOMEM);

	pages = (request->size + PAGE_SIZE - 1) / PAGE_SIZE;
	type = (u_int32_t)request->type;

	handle = agp_alloc_memory(dev->agp->agpdev, type,
	    pages << AGP_PAGE_SHIFT);
	if (handle == NULL) {
		drm_free(entry);
		return (ENOMEM);
	}

	entry->handle = handle;
	entry->bound = 0;
	entry->pages = pages;

	agp_memory_info(dev->agp->agpdev, entry->handle, &info);

	request->handle = (unsigned long)entry->handle;
        request->physical = info.ami_physical;
	DRM_LOCK();
	TAILQ_INSERT_HEAD(&dev->agp->memory, entry, link);
	DRM_UNLOCK();

	return (0);
}

int
drm_agp_alloc_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_buffer	*request = data;

	return (drm_agp_alloc(dev, request));
}

/*
 * find entry on agp list. Must be called with dev_lock locked.
 */
struct drm_agp_mem *
drm_agp_lookup_entry(struct drm_device *dev, void *handle)
{
	struct drm_agp_mem	*entry;

	TAILQ_FOREACH(entry, &dev->agp->memory, link) {
		if (entry->handle == handle)
			break;
	}
	return (entry);
}

int
drm_agp_unbind(struct drm_device *dev, struct drm_agp_binding *request)
{
	struct drm_agp_mem	*entry;
	int			 retcode;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	DRM_LOCK();
	entry = drm_agp_lookup_entry(dev, (void *)request->handle);
	/*
	 * If the AGP bridge has an aperture base address of 0 and
	 * the entry is bound with an offset of 0, entry->bound will
	 * not reflect the reality.
	 *
	 * XXX This means that we may try to unbind unbound entries
	 * with such an AGP bridge, but it should be safe because
	 * agp_unbind_memory() has a correct check for bound memory.
	 */
	if (entry == NULL || (!entry->bound && dev->agp->base)) {
		DRM_UNLOCK();
		return (EINVAL);
	}

	retcode =  agp_unbind_memory(dev->agp->agpdev, entry->handle);

	if (retcode == 0)
		entry->bound = 0;
	DRM_UNLOCK();

	return (retcode);
}

int
drm_agp_unbind_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_binding	*request = data;

	return (drm_agp_unbind(dev, request));
}

int
drm_agp_bind(struct drm_device *dev, struct drm_agp_binding *request)
{
	struct drm_agp_mem	*entry;
	int			 retcode, page;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	DRM_DEBUG("agp_bind, page_size=%x\n", PAGE_SIZE);

	DRM_LOCK();
	entry = drm_agp_lookup_entry(dev, (void *)request->handle);
	if (entry == NULL || entry->bound) {
		DRM_UNLOCK();
		return (EINVAL);
	}

	page = (request->offset + PAGE_SIZE - 1) / PAGE_SIZE;

	retcode = agp_bind_memory(dev->agp->agpdev, entry->handle,
	    page * PAGE_SIZE);
	if (retcode == 0)
		entry->bound = dev->agp->base + (page << PAGE_SHIFT);
	DRM_UNLOCK();

	return (retcode);
}

int
drm_agp_bind_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_binding	*request = data;

	return (drm_agp_bind(dev, request));
}

/*
 * Remove entry from list and free. Call locked.
 */
void
drm_agp_remove_entry(struct drm_device *dev, struct drm_agp_mem *entry)
{
	TAILQ_REMOVE(&dev->agp->memory, entry, link);

	if (entry->bound)
		agp_unbind_memory(dev->agp->agpdev, entry->handle);
	agp_free_memory(dev->agp->agpdev, entry->handle);
	drm_free(entry);
}

a107 2
	struct drm_agp_mem	*entry;

a110 9
	/*
	 * Remove AGP resources, but leave dev->agp intact until
	 * we detach the device
	 */
	DRM_LOCK();
	while ((entry = TAILQ_FIRST(&dev->agp->memory)) != NULL)
		drm_agp_remove_entry(dev, entry);
	DRM_UNLOCK();

a112 30
}

int
drm_agp_free(struct drm_device *dev, struct drm_agp_buffer *request)
{
	struct drm_agp_mem	*entry;

	if (dev->agp == NULL || !dev->agp->acquired)
		return (EINVAL);

	DRM_LOCK();
	entry = drm_agp_lookup_entry(dev, (void*)request->handle);
	if (entry == NULL) {
		DRM_UNLOCK();
		return (EINVAL);
	}

	drm_agp_remove_entry(dev, entry);
	DRM_UNLOCK();

	return (0);
}

int
drm_agp_free_ioctl(struct drm_device *dev, void *data,
    struct drm_file *file_priv)
{
	struct drm_agp_buffer	*request = data;

	return (drm_agp_free(dev, request));
@


1.24
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_agpsupport.c,v 1.23 2012/12/06 14:46:17 mpi Exp $ */
d373 1
@


1.23
log
@Make sure we try to unbind AGP memory regions if the aperture base address
is 0, otherwise we never free the memory region bound at offset 0x00 when
exiting X on macppc.

ok kettenis@@ as part of larger diff
@
text
@d1 1
a1 1
/* $OpenBSD: drm_agpsupport.c,v 1.22 2012/09/08 16:42:20 mpi Exp $ */
d356 1
a356 1
	struct device		*agpdev;
@


1.22
log
@Instead of having yet an other option to compile the drm code without agp
support, wrap all the agp glue with 'if __OS_HAS_AGP' in such form that it
is true if the agp(4) driver is present.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_agpsupport.c,v 1.21 2012/08/22 15:17:05 mpi Exp $ */
d218 10
a227 1
	if (entry == NULL || !entry->bound) {
@


1.21
log
@Unbreak drm when DRM_NO_AGP is defined.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_agpsupport.c,v 1.20 2011/06/02 18:22:00 weerd Exp $ */
d39 2
a53 1
#ifndef DRM_NO_AGP
a54 1
#endif
a86 1
#ifndef DRM_NO_AGP
d97 1
a97 1
#endif
a110 1
#ifndef DRM_NO_AGP
d115 1
a115 1
#endif
d123 1
a123 1
#ifndef DRM_NO_AGP
d126 1
a126 1
	
a129 1
#endif
a144 1
#ifndef DRM_NO_AGP
d167 1
a167 1
	
a178 1
#endif
a209 1
#ifndef DRM_NO_AGP
a229 3
#else
	return (0);
#endif
a243 1
#ifndef DRM_NO_AGP
a267 3
#else
	return (0);
#endif
a284 1
#ifndef DRM_NO_AGP
a290 1
#endif
d318 1
a318 1
	
d331 1
a331 1
   
a346 1
#ifndef DRM_NO_AGP
d350 1
a350 1
   
a366 3
#else
	return (NULL);
#endif
d368 2
@


1.20
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d215 1
d236 3
d253 1
d256 1
a256 1
	
d278 3
d298 1
d305 1
@


1.19
log
@The drm_* allocation functions have been #defined to not use most of
their arguments for a while. Actually go through the code and remove the
extraneous arguments. Makes things easier to read.
@
text
@d1 1
@


1.18
log
@make device works out if it's agp and tells the drm driver, not the
other way round. More dev->pa reduction
@
text
@d157 1
a157 1
	entry = drm_alloc(sizeof(*entry), DRM_MEM_AGPLISTS);
d167 1
a167 1
		drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
d294 1
a294 1
	drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);
d363 1
a363 1
		head = drm_calloc(1, sizeof(*head), DRM_MEM_AGPLISTS);
@


1.17
log
@drm_device_is_pcie is only needed in one place: radeondrm_attach

so just inline it there.

also remove dev->pci_vendor and dev->pci_device, and insert pci_device
into the one place any of them are needed (inteldrm's interface can give
this info to the X driver. to remove that you'd need to fix X too).
@
text
@a42 18
drm_device_is_agp(struct drm_device *dev)
{
	if (dev->driver->device_is_agp != NULL) {
		int ret;
		/*
		 * device_is_agp returns a tristate, 0 = not AGP, 1 = definitely
		 * AGP, 2 = fall back to PCI capability
		 */
		ret = (*dev->driver->device_is_agp)(dev);
		if (ret != DRM_MIGHT_BE_AGP)
			return (ret);
	}

	return (pci_get_capability(dev->pa.pa_pc, dev->pa.pa_tag, PCI_CAP_AGP,
	    NULL, NULL));
}

int
@


1.16
log
@Move dev->driver over to being a pointer to a const struct, instead of stupidly
filling in a pre-allocated one on each attach.

Makes the code a bunch nicer, shrinks a kernel by about 1.5k on amd64,
helps with my sanity, and paves way for later changes.

Tested by a few for a couple of weeks now.
@
text
@a60 7
drm_device_is_pcie(struct drm_device *dev)
{
	return (pci_get_capability(dev->pa.pa_pc, dev->pa.pa_tag,
	    PCI_CAP_PCIEXPRESS, NULL, NULL));
}

int
@


1.15
log
@Rework the drm locking to be at least halfway sane. The freebsd code
held a lock over all driver ioctls in order to be ``mpsafe''. Stop lying
to ourselves for a start. This code is not fully mpsafe, and should not
pretend to be so.  Put the locking around where it should, and rely on
biglock for the rest. This will need to be fixed, but avoids some of the
horrible that we have right now.

Tested by many over a long time and several iterations.
@
text
@d45 1
a45 1
	if (dev->driver.device_is_agp != NULL) {
d51 1
a51 1
		ret = (*dev->driver.device_is_agp)(dev);
@


1.14
log
@Kill some stupid agp api wrapper functions, just use the agp api
directly.  While i'm here, factor out some common functionality into a
separate function, and kill some typedefs (man this code is full of
them...). Shaves another 450 bytes off the kernel.

Tested by ckuethe and Paul de Weerd, thanks.
@
text
@a188 1
	DRM_UNLOCK();
a190 1
	DRM_LOCK();
a198 1
	TAILQ_INSERT_HEAD(&dev->agp->memory, entry, link);
d204 3
a216 1
	int			 retcode;
d218 1
a218 4
	DRM_LOCK();
	retcode = drm_agp_alloc(dev, request);
	DRM_UNLOCK();
	return (retcode);
d221 3
d245 1
d247 2
a248 1
	if (entry == NULL || !entry->bound)
d250 1
a251 1
	DRM_UNLOCK();
a252 1
	DRM_LOCK();
d256 1
a265 5
	int			 retcode;

	DRM_LOCK();
	retcode = drm_agp_unbind(dev, request);
	DRM_UNLOCK();
d267 1
a267 1
	return (retcode);
d281 1
d283 2
a284 1
	if (entry == NULL || entry->bound)
d286 1
a289 1
	DRM_UNLOCK();
a291 1
	DRM_LOCK();
d294 1
a303 1
	int			 retcode;
d305 1
a305 5
	DRM_LOCK();
	retcode = drm_agp_bind(dev, request);
	DRM_UNLOCK();

	return (retcode);
a315 1
	DRM_UNLOCK();
a319 1
	DRM_LOCK();
d351 1
d353 2
a354 1
	if (entry == NULL)
d356 1
d359 1
a368 1
	int			 retcode;
d370 1
a370 5
	DRM_LOCK();
	retcode = drm_agp_free(dev, request);
	DRM_UNLOCK();

	return (retcode);
@


1.13
log
@detypedef some more. No functional change.
@
text
@d39 2
d190 2
a191 1
	handle = drm_agp_allocate_memory(pages, type);
d251 1
a251 1
	retcode = drm_agp_unbind_memory(entry->handle);
d292 2
a293 1
	retcode = drm_agp_bind_memory(entry->handle, page);
d315 37
d363 2
a365 10
	TAILQ_REMOVE(&dev->agp->memory, entry, link);

	DRM_UNLOCK();
	if (entry->bound)
		drm_agp_unbind_memory(entry->handle);
	drm_agp_free_memory(entry->handle);
	DRM_LOCK();

	drm_free(entry, sizeof(*entry), DRM_MEM_AGPLISTS);

a366 1

d383 1
a383 1
drm_agp_head_t *
d387 3
a389 3
	struct device	*agpdev;
	drm_agp_head_t	*head = NULL;
	int		 agp_available = 1;
d391 1
a391 1
	agpdev = DRM_AGP_FIND_DEVICE();
a408 57
#endif
}

void *
drm_agp_allocate_memory(size_t pages, u32 type)
{
	struct device	*agpdev;

	agpdev = DRM_AGP_FIND_DEVICE();
	if (agpdev == NULL)
		return (NULL);

	return (agp_alloc_memory(agpdev, type, pages << AGP_PAGE_SHIFT));
}

int
drm_agp_free_memory(void *handle)
{
	struct device	*agpdev;

	agpdev = DRM_AGP_FIND_DEVICE();
	if (agpdev == NULL || handle == NULL)
		return (0);

	agp_free_memory(agpdev, handle);
	return (1);
}

int
drm_agp_bind_memory(void *handle, off_t start)
{
#ifndef DRM_NO_AGP
	struct device	*agpdev;

	agpdev = DRM_AGP_FIND_DEVICE();
	if (agpdev == NULL || handle == NULL)
		return (EINVAL);

	return (agp_bind_memory(agpdev, handle, start * PAGE_SIZE));
#else
	return (0);
#endif
}

int
drm_agp_unbind_memory(void *handle)
{
#ifndef DRM_NO_AGP
	struct device	*agpdev;

	agpdev = DRM_AGP_FIND_DEVICE();
	if (agpdev == NULL || handle == NULL)
		return (EINVAL);

	return (agp_unbind_memory(agpdev, handle));
#else
	return (0);
@


1.12
log
@Check the return value of agp_enable() instead of assuming it completed.
apply some knf and other formatting while i'm at it.

problem originally pointed out by Tobias Ulmer, thanks!
@
text
@d66 1
a66 1
drm_agp_info(struct drm_device * dev, drm_agp_info_t *info)
d94 1
a94 1
	drm_agp_info_t	*info = data;
d162 1
a162 1
	drm_agp_mode_t	*mode = data;
d168 1
a168 1
drm_agp_alloc(struct drm_device *dev, drm_agp_buffer_t *request)
d213 1
a213 1
	drm_agp_buffer_t	*request = data;
d235 1
a235 1
drm_agp_unbind(struct drm_device *dev, drm_agp_binding_t *request)
d261 1
a261 1
	drm_agp_binding_t	*request = data;
d272 1
a272 1
drm_agp_bind(struct drm_device *dev, drm_agp_binding_t *request)
d301 1
a301 1
	drm_agp_binding_t	*request = data;
d312 1
a312 1
drm_agp_free(struct drm_device *dev, drm_agp_buffer_t *request)
d341 1
a341 1
	drm_agp_buffer_t	*request = data;
@


1.11
log
@kill the stupid pci capability defines, we have our own. Don't wrap
pci_read_capability while i'm at it.
@
text
@d31 1
a31 1
/** @@file drm_agpsupport.c
d51 1
a51 1
			return ret;
d68 1
a68 1
	struct agp_info *kern;
d70 2
a71 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d87 1
a87 1
	return 0;
d94 1
a94 2
	int err;
	drm_agp_info_t info;
d96 1
a96 6
	err = drm_agp_info(dev, &info);
	if (err != 0)
		return err;

	*(drm_agp_info_t *)data = info;
	return 0;
d103 1
a103 1
	return drm_agp_acquire(dev);
d110 1
a110 1
	int retcode;
d112 2
a113 2
	if (!dev->agp || dev->agp->acquired)
		return EINVAL;
d117 1
a117 1
		return retcode;
d121 1
a121 1
	return 0;
d128 1
a128 1
	return drm_agp_release(dev);
d135 2
a136 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d140 1
a140 1
	return 0;
d146 1
a146 1

d148 2
a149 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d152 2
a153 2
	agp_enable(dev->agp->agpdev, mode.mode);
	dev->agp->enabled = 1;
d155 1
a155 1
	return 0;
d162 1
a162 3
	drm_agp_mode_t mode;

	mode = *(drm_agp_mode_t *)data;
d164 1
a164 1
	return drm_agp_enable(dev, mode);
d171 5
a175 5
	struct drm_agp_mem *entry;
	void *handle;
	unsigned long pages;
	u_int32_t type;
	struct agp_memory_info info;
d177 2
a178 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d182 1
a182 1
		return ENOMEM;
d192 1
a192 1
		return ENOMEM;
d206 1
a206 1
	return 0;
d213 2
a214 4
	drm_agp_buffer_t request;
	int retcode;

	request = *(drm_agp_buffer_t *)data;
d217 1
a217 1
	retcode = drm_agp_alloc(dev, &request);
d219 1
a219 4

	*(drm_agp_buffer_t *)data = request;

	return retcode;
d225 1
a225 1
	struct drm_agp_mem *entry;
d229 1
a229 1
			return entry;
d231 1
a231 1
	return NULL;
d237 2
a238 2
	struct drm_agp_mem *entry;
	int retcode;
d240 2
a241 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d245 1
a245 1
		return EINVAL;
d254 1
a254 1
	return retcode;
d261 2
a262 4
	drm_agp_binding_t request;
	int retcode;

	request = *(drm_agp_binding_t *)data;
d265 1
a265 1
	retcode = drm_agp_unbind(dev, &request);
d268 1
a268 1
	return retcode;
d274 2
a275 3
	struct drm_agp_mem *entry;
	int retcode;
	int page;
d277 2
a278 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d284 1
a284 1
		return EINVAL;
d294 1
a294 1
	return retcode;
d301 2
a302 4
	drm_agp_binding_t request;
	int retcode;

	request = *(drm_agp_binding_t *)data;
d305 1
a305 1
	retcode = drm_agp_bind(dev, &request);
d308 1
a308 1
	return retcode;
d314 1
a314 1
	struct drm_agp_mem *entry;
d316 2
a317 2
	if (!dev->agp || !dev->agp->acquired)
		return EINVAL;
d321 1
a321 1
		return EINVAL;
d333 1
a333 1
	return 0;
d341 2
a342 4
	drm_agp_buffer_t request;
	int retcode;

	request = *(drm_agp_buffer_t *)data;
d345 1
a345 1
	retcode = drm_agp_free(dev, &request);
d348 1
a348 1
	return retcode;
d355 3
a357 3
	struct device *agpdev;
	drm_agp_head_t *head = NULL;
	int agp_available = 1;
d360 1
a360 1
	if (!agpdev)
d368 1
a368 1
			return NULL;
d374 1
a374 1
	return head;
d383 1
a383 1
	struct device *agpdev;
d386 2
a387 2
	if (!agpdev)
		return NULL;
d389 1
a389 1
	return agp_alloc_memory(agpdev, type, pages << AGP_PAGE_SHIFT);
d395 1
a395 1
	struct device *agpdev;
d398 2
a399 2
	if (!agpdev || !handle)
		return 0;
d402 1
a402 1
	return 1;
d409 1
a409 1
	struct device *agpdev;
d412 2
a413 2
	if (!agpdev || !handle)
		return EINVAL;
d415 1
a415 1
	return agp_bind_memory(agpdev, handle, start * PAGE_SIZE);
d417 1
a417 1
	return 0;
d425 1
a425 1
	struct device *agpdev;
d428 2
a429 2
	if (!agpdev || !handle)
		return EINVAL;
d431 1
a431 1
	return agp_unbind_memory(agpdev, handle);
d433 1
a433 1
	return 0;
@


1.10
log
@Kill some redundant ifdefs, they're taken care of elsewhere.
@
text
@d38 1
a38 10
int	drm_device_find_capability(struct drm_device *, int);
struct drm_agp_mem *drm_agp_lookup_entry(struct drm_device *, void *);

/* Returns 1 if AGP or 0 if not. */
int
drm_device_find_capability(struct drm_device *dev, int cap)
{
	return pci_get_capability(dev->pa.pa_pc, dev->pa.pa_tag, cap,
	    NULL, NULL);
}
d54 2
a55 1
	return (drm_device_find_capability(dev, PCIY_AGP));
d61 2
a62 1
	return (drm_device_find_capability(dev, PCIY_EXPRESS));
@


1.9
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@d381 1
a396 1
#ifndef DRM_NO_AGP
a397 1
#endif
d402 3
@


1.8
log
@Make the drm attach messages a lot prettier.

the DRM_{INFO,ERROR,DEBUG} printf macros still need some __VA_ARGS__ love.

reyk@@ and marco@@ liked this, prompted by deraadt.
@
text
@d54 2
a55 2

		/* device_is_agp returns a tristate, 0 = not AGP, 1 = definitely
d80 1
a80 1
	kern                   = &dev->agp->info;
d86 7
a92 7
	info->mode              = kern->ai_mode;
	info->aperture_base     = kern->ai_aperture_base;
	info->aperture_size     = kern->ai_aperture_size;
	info->memory_allowed    = kern->ai_memory_allowed;
	info->memory_used       = kern->ai_memory_used;
	info->id_vendor         = kern->ai_devid & 0xffff;
	info->id_device         = kern->ai_devid >> 16;
d108 1
a108 1
	*(drm_agp_info_t *) data = info;
d200 1
a200 1
	type = (u_int32_t) request->type;
d248 2
a249 1
		if (entry->handle == handle) return entry;
d369 1
a369 1
	request = *(drm_agp_buffer_t *) data;
@


1.7
log
@Switch all instances of malloc/free in the DRM to drm_alloc, drm_free
and drm_calloc.

With the recent change to check overflow in drm_calloc, this means that
all allocations that require multiplication are now checked. Also use
drm_calloc() when zeroing is needed and drop the bzero/memset
afterwards.  Finally, make drm_free() check for NULL, so we don't need
to do so every time.

ok miod@@, deraadt@@
@
text
@a399 3
		DRM_INFO("AGP at 0x%08lx %dMB\n",
		    (long)head->info.ai_aperture_base,
		    (int)(head->info.ai_aperture_size >> 20));
@


1.6
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d195 1
a195 1
	entry = malloc(sizeof(*entry), M_DRM, M_NOWAIT | M_ZERO);
d206 1
a206 1
		free(entry, M_DRM);
d355 1
a355 1
	free(entry, M_DRM);
d391 1
a391 1
		head = malloc(sizeof(*head), M_DRM, M_NOWAIT | M_ZERO);
@


1.5
log
@Kill the device_t and vm_offset_t typedefs.
@
text
@d38 2
a39 2
int	drm_device_find_capability(drm_device_t *, int);
struct drm_agp_mem *drm_agp_lookup_entry(drm_device_t *, void *);
d43 1
a43 1
drm_device_find_capability(drm_device_t *dev, int cap)
d50 1
a50 1
drm_device_is_agp(drm_device_t *dev)
d67 1
a67 1
drm_device_is_pcie(drm_device_t *dev)
d73 1
a73 1
drm_agp_info(drm_device_t * dev, drm_agp_info_t *info)
d98 2
a99 1
drm_agp_info_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d113 2
a114 1
drm_agp_acquire_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d120 1
a120 1
drm_agp_acquire(drm_device_t *dev)
d138 2
a139 1
drm_agp_release_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d145 1
a145 1
drm_agp_release(drm_device_t * dev)
d157 1
a157 1
drm_agp_enable(drm_device_t *dev, drm_agp_mode_t mode)
d172 2
a173 1
drm_agp_enable_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d183 1
a183 1
drm_agp_alloc(drm_device_t *dev, drm_agp_buffer_t *request)
d225 2
a226 1
drm_agp_alloc_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d243 1
a243 1
drm_agp_lookup_entry(drm_device_t *dev, void *handle)
d254 1
a254 1
drm_agp_unbind(drm_device_t *dev, drm_agp_binding_t *request)
d277 2
a278 1
drm_agp_unbind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d293 1
a293 1
drm_agp_bind(drm_device_t *dev, drm_agp_binding_t *request)
d320 2
a321 1
drm_agp_bind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d336 1
a336 1
drm_agp_free(drm_device_t *dev, drm_agp_buffer_t *request)
d362 2
a363 1
drm_agp_free_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
@


1.4
log
@Kill the rest of the ifdef maze in drm_*.c

I was going to do this per file, but decided all it would achieve was
artificially increasing my commit count.

>Kill the ifdef maze. I've been considering doing this for months, it
>doesn't make getting changes to and  from upstream much easier, and just
>makes the code hard to read.
@
text
@d372 1
a372 1
	device_t agpdev;
d402 1
a402 1
	device_t agpdev;
d414 1
a414 1
	device_t agpdev;
d428 1
a428 1
	device_t agpdev;
d444 1
a444 1
	device_t agpdev;
@


1.3
log
@Convert the list of agp memory over to a TAILQ instead of using a hand-
rolled list.

Tested by many
@
text
@a37 5
#ifdef __FreeBSD__
#include <pci/agpreg.h>
#include <dev/pci/pcireg.h>
#endif

a44 35
#ifdef __FreeBSD__
#if __FreeBSD_version >= 602102

	return (pci_find_extcap(dev->device, cap, NULL) == 0);
#else
	/* Code taken from agp.c.  IWBNI that was a public interface. */
	u_int32_t status;
	u_int8_t ptr, next;

	/*
	 * Check the CAP_LIST bit of the PCI status register first.
	 */
	status = pci_read_config(dev->device, PCIR_STATUS, 2);
	if (!(status & 0x10))
		return 0;

	/*
	 * Traverse the capabilities list.
	 */
	for (ptr = pci_read_config(dev->device, AGP_CAPPTR, 1);
	    ptr != 0; ptr = next) {
		u_int32_t capid = pci_read_config(dev->device, ptr, 4);
		next = AGP_CAPID_GET_NEXT_PTR(capid);

		/*
		 * If this capability entry ID is cap, then we are done.
		 */
		if (AGP_CAPID_GET_CAP_ID(capid) == cap)
			return 1;
	}

	return 0;
#endif
#else
#if defined(__NetBSD__) || defined (__OpenBSD__)
a46 4
#endif
	/* XXX: fill me in for non-FreeBSD */
	return 1;
#endif
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d44 1
a44 1
drm_agp_mem_t *drm_agp_lookup_entry(drm_device_t *, void *);
d226 1
a226 1
	drm_agp_mem_t *entry;
d253 1
a253 5
	entry->prev = NULL;
	entry->next = dev->agp->memory;
	if (dev->agp->memory)
		dev->agp->memory->prev = entry;
	dev->agp->memory = entry;
d281 1
a281 1
drm_agp_mem_t *
d284 1
a284 1
	drm_agp_mem_t *entry;
d286 1
a286 1
	for (entry = dev->agp->memory; entry; entry = entry->next) {
d295 1
a295 1
	drm_agp_mem_t *entry;
d333 1
a333 1
	drm_agp_mem_t *entry;
d375 1
a375 1
	drm_agp_mem_t *entry;
d384 1
a384 6
	if (entry->prev)
		entry->prev->next = entry->next;
	else
		dev->agp->memory  = entry->next;
	if (entry->next)
		entry->next->prev = entry->prev;
d435 1
a435 1
		head->memory = NULL;
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d43 3
d47 1
a47 1
static int
d70 1
a70 2
	     ptr != 0;
	     ptr = next) {
d86 1
a86 1
				  NULL, NULL);
d93 2
a94 1
int drm_device_is_agp(drm_device_t *dev)
d110 2
a111 1
int drm_device_is_pcie(drm_device_t *dev)
d116 2
a117 1
int drm_agp_info(drm_device_t * dev, drm_agp_info_t *info)
d141 2
a142 1
int drm_agp_info_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d155 2
a156 1
int drm_agp_acquire_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d161 2
a162 1
int drm_agp_acquire(drm_device_t *dev)
d179 2
a180 1
int drm_agp_release_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d185 2
a186 1
int drm_agp_release(drm_device_t * dev)
d197 2
a198 1
int drm_agp_enable(drm_device_t *dev, drm_agp_mode_t mode)
d205 1
a205 1
	dev->agp->mode    = mode.mode;
d212 2
a213 1
int drm_agp_enable_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d217 1
a217 1
	mode = *(drm_agp_mode_t *) data;
d222 2
a223 1
int drm_agp_alloc(drm_device_t *dev, drm_agp_buffer_t *request)
d226 4
a229 4
	drm_agp_mem_t    *entry;
	void	         *handle;
	unsigned long    pages;
	u_int32_t	 type;
d250 5
a254 5
	entry->handle    = handle;
	entry->bound     = 0;
	entry->pages     = pages;
	entry->prev      = NULL;
	entry->next      = dev->agp->memory;
d261 1
a261 1
	request->handle   = (unsigned long) entry->handle;
d268 2
a269 1
int drm_agp_alloc_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d274 1
a274 1
	request = *(drm_agp_buffer_t *) data;
d280 1
a280 1
	*(drm_agp_buffer_t *) data = request;
d285 2
a286 1
static drm_agp_mem_t * drm_agp_lookup_entry(drm_device_t *dev, void *handle)
d296 2
a297 1
int drm_agp_unbind(drm_device_t *dev, drm_agp_binding_t *request)
d299 1
a299 1
	drm_agp_mem_t     *entry;
d319 2
a320 1
int drm_agp_unbind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d325 1
a325 1
	request = *(drm_agp_binding_t *) data;
d334 2
a335 1
int drm_agp_bind(drm_device_t *dev, drm_agp_binding_t *request)
d337 3
a339 3
	drm_agp_mem_t     *entry;
	int               retcode;
	int               page;
d361 2
a362 1
int drm_agp_bind_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d367 1
a367 1
	request = *(drm_agp_binding_t *) data;
d376 2
a377 1
int drm_agp_free(drm_device_t *dev, drm_agp_buffer_t *request)
d379 1
a379 1
	drm_agp_mem_t    *entry;
d407 2
a408 1
int drm_agp_free_ioctl(drm_device_t *dev, void *data, struct drm_file *file_priv)
d422 2
a423 1
drm_agp_head_t *drm_agp_init(void)
d426 2
a427 2
	drm_agp_head_t *head   = NULL;
	int      agp_available = 1;
d446 2
a447 2
			 (long)head->info.ai_aperture_base,
			 (int)(head->info.ai_aperture_size >> 20));
d452 2
a453 1
void *drm_agp_allocate_memory(size_t pages, u32 type)
d464 2
a465 1
int drm_agp_free_memory(void *handle)
d477 2
a478 1
int drm_agp_bind_memory(void *handle, off_t start)
d493 2
a494 1
int drm_agp_unbind_memory(void *handle)
@

