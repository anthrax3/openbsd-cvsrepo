head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.10
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.6
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.8
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.27
date	2015.06.04.06.07.23;	author jsg;	state Exp;
branches;
next	1.26;
commitid	GbdhDEDLvb1UR8cE;

1.26
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.25;
commitid	OBNa5kfxQ2UXoiIw;

1.25
date	2014.03.09.07.42.29;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2012.12.06.15.05.21;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2012.09.08.16.53.01;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.02.18.22.00;	author weerd;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.29.15.23.28;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.04.16.02.57;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.03.15.22.31;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.31.20.05.06;	author oga;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.27.17.44.12;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.26.07.25.06;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.24.04.21.31;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.23.22.02.00;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.22.22.43.53;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.01.17.50.15;	author chl;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.29.13.44.23;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.16.01.53.05;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.13.20.45.42;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2008.07.29.19.44.13;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2008.07.29.19.13.19;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.10.00.10.22;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.26.19.33.19;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.26.16.42.48;	author oga;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.06.19.19.02;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.01.02.31;	author oga;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	;


desc
@@


1.27
log
@use mallocarray instead of malloc in drm_calloc
@
text
@/* $OpenBSD: drm_memory.c,v 1.26 2014/07/12 18:48:52 tedu Exp $ */
/*-
 *Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
 * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * Authors:
 *    Rickard E. (Rik) Faith <faith@@valinux.com>
 *    Gareth Hughes <gareth@@valinux.com>
 *
 */

/** @@file drm_memory.c
 * Wrappers for kernel memory allocation routines, and MTRR management support.
 *
 * This file previously implemented a memory consumption tracking system using
 * the "area" argument for various different types of allocations, but that
 * has been stripped out for now.
 */

#include "drmP.h"

#if !defined(__amd64__) && !defined(__i386__)
#define DRM_NO_MTRR	1
#endif

void*
drm_alloc(size_t size)
{
	return (malloc(size, M_DRM, M_NOWAIT));
}

void *
drm_calloc(size_t nmemb, size_t size)
{
	if (nmemb == 0 || SIZE_MAX / nmemb < size)
		return (NULL);
	else
		return mallocarray(size, nmemb, M_DRM, M_NOWAIT | M_ZERO);
}

void *
drm_realloc(void *oldpt, size_t oldsize, size_t size)
{
	void *pt;

	pt = malloc(size, M_DRM, M_NOWAIT);
	if (pt == NULL)
		return NULL;
	if (oldpt && oldsize) {
		memcpy(pt, oldpt, min(oldsize, size));
		free(oldpt, M_DRM, 0);
	}
	return pt;
}

void
drm_free(void *pt)
{
	if (pt != NULL)
		free(pt, M_DRM, 0);
}

int
drm_mtrr_add(unsigned long offset, size_t size, int flags)
{
#ifndef DRM_NO_MTRR
	int act;
	struct mem_range_desc mrdesc;

	mrdesc.mr_base = offset;
	mrdesc.mr_len = size;
	mrdesc.mr_flags = flags;
	act = MEMRANGE_SET_UPDATE;
	strlcpy(mrdesc.mr_owner, "drm", sizeof(mrdesc.mr_owner));
	return mem_range_attr_set(&mrdesc, &act);
#else
	return 0;
#endif
}

int
drm_mtrr_del(int handle, unsigned long offset, size_t size, int flags)
{
#ifndef DRM_NO_MTRR
	int act;
	struct mem_range_desc mrdesc;

	mrdesc.mr_base = offset;
	mrdesc.mr_len = size;
	mrdesc.mr_flags = flags;
	act = MEMRANGE_SET_REMOVE;
	strlcpy(mrdesc.mr_owner, "drm", sizeof(mrdesc.mr_owner));
	return mem_range_attr_set(&mrdesc, &act);
#else
	return 0;
#endif
}
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: drm_memory.c,v 1.25 2014/03/09 07:42:29 jsg Exp $ */
d58 1
a58 1
		return malloc(size * nmemb, M_DRM, M_NOWAIT | M_ZERO);
@


1.25
log
@remove dri1 interfaces
discussed with kettenis some time last year
@
text
@d1 1
a1 1
/* $OpenBSD: drm_memory.c,v 1.24 2012/12/06 15:05:21 mpi Exp $ */
d71 1
a71 1
		free(oldpt, M_DRM);
d80 1
a80 1
		free(pt, M_DRM);
@


1.24
log
@Rework how AGP memory regions are mapped and add support for AGP bridges
that do not support remapping for processor accesses.

Add new functions to map/unmap/mmap agp memory and let the agp layer
decides how these memory regions should be accessed. It's assumed here
that the bridge does not support remapping if its aperture address is 0.

This is the last diff required for having drm(4) on macppc using agp(4).

Joint work with and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_memory.c,v 1.23 2012/09/08 16:53:01 mpi Exp $ */
a80 63
}

/* Inline replacements for DRM_IOREMAP macros */
void
drm_core_ioremap(struct drm_local_map *map, struct drm_device *dev)
{
	DRM_DEBUG("offset: 0x%x size: 0x%x type: %d\n", map->offset, map->size,
	    map->type);

	/* default to failure. */
	map->handle = 0;

	switch (map->type) {
#if __OS_HAS_AGP
	case _DRM_AGP:
		DRM_DEBUG("AGP map\n");
		map->bst = dev->bst;
		/* handles are still supposed to be kernel virtual addresses */
		map->handle = agp_map(dev->agp->agpdev,
		    map->offset - dev->agp->base, map->size, &map->bsh);
		if (map->handle == 0) {
			DRM_ERROR("ioremap fail\n");
			return;
		}
		break;
#endif
	case _DRM_FRAME_BUFFER:
		DRM_DEBUG("FRAME_BUFFER map\n");
		map->bst = dev->bst;
		if (bus_space_map(map->bst, map->offset,
		    map->size, BUS_SPACE_MAP_LINEAR |
		    BUS_SPACE_MAP_PREFETCHABLE, &map->bsh)) {
			DRM_ERROR("ioremap fail\n");
			return;
		}
		/* handles are still supposed to be kernel virtual addresses */
		map->handle = bus_space_vaddr(map->bst, map->bsh);
		break;
	default:
		break;
	}
}

void
drm_core_ioremapfree(struct drm_local_map *map, struct drm_device *dev)
{
	if (map->handle == 0 || map->size == 0)
		return;

	switch (map->type) {
#if __OS_HAS_AGP
	case _DRM_AGP:
		agp_unmap(dev->agp->agpdev, map->handle, map->size, map->bsh);
		map->handle = 0;
		break;
#endif
	case _DRM_FRAME_BUFFER:
		bus_space_unmap(map->bst, map->bsh, map->size);
		map->handle = 0;
		break;
	default:
		break;
	}
@


1.23
log
@Don't use mtrr if we are not on i386/amd64.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: drm_memory.c,v 1.22 2011/06/02 18:22:00 weerd Exp $ */
d93 3
a95 6
	if (map->type == _DRM_AGP || map->type == _DRM_FRAME_BUFFER) {
	/*
	 * there can be multiple agp maps in the same BAR, agp also
	 * quite possibly isn't the same as the vga device, just try
	 * to map it.
	 */
d98 12
d118 3
d125 1
a125 1
drm_core_ioremapfree(struct drm_local_map *map)
d127 11
a137 2
	if (map->handle && map->size && (map->type == _DRM_AGP ||
	    map->type == _DRM_FRAME_BUFFER)) {
d140 3
@


1.22
log
@Add $OpenBSD$ after oga said 'go ahead and fix that'

'go for it' oga@@
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d41 4
@


1.21
log
@use BUS_SPACE_MAP_PREFETCHABLE on maps that should be WC (soon this will
actually do so).
@
text
@d1 1
@


1.20
log
@Remove the three inline functions from drmP.h.

deiline drm_core_findmap(), and merge drm_core_ioremap{,free}() into
drm_ioremap{,free}() instead of having an inline that just calls another
function.
@
text
@d97 2
a98 1
		    map->size, BUS_SPACE_MAP_LINEAR, &map->bsh)) {
@


1.19
log
@detypedef drm_local_map.
@
text
@d78 3
a80 2
void *
drm_ioremap(struct drm_device *dev, struct drm_local_map *map)
d85 3
d99 1
a99 1
			return (NULL);
d101 2
a102 2
	} else {
		return (NULL);
a103 2
	/* handles are still supposed to be kernel virtual addresses */
	return bus_space_vaddr(map->bst, map->bsh);
d107 1
a107 1
drm_ioremapfree(struct drm_local_map *map)
d109 5
a113 5
	if (map == NULL || (map->type != _DRM_AGP && map->type !=
	    _DRM_FRAME_BUFFER))
		return;

	bus_space_unmap(map->bst, map->bsh, map->size);
@


1.18
log
@remove the drm_read and drm_write functions. instead just do the
conditional on whether we treat the data like memspace or system memory
into the one driver that needs this.

Something similar was done upstream a while back.
@
text
@d79 1
a79 1
drm_ioremap(struct drm_device *dev, drm_local_map_t *map)
d105 1
a105 1
drm_ioremapfree(drm_local_map_t *map)
@


1.17
log
@Remove a bunch of compat macros, just expand them to the openbsd
equivalent.
@
text
@a148 83

u_int8_t
drm_read8(drm_local_map_t *map, unsigned long offset)
{
	u_int8_t *ptr;

	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		return  (*ptr);
		
	default:
		return (bus_space_read_1(map->bst, map->bsh, offset));
	}
}

u_int16_t
drm_read16(drm_local_map_t *map, unsigned long offset)
{
	u_int16_t *ptr;
	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		return  (*ptr);
	default:
		return (bus_space_read_2(map->bst, map->bsh, offset));
	}
}

u_int32_t
drm_read32(drm_local_map_t *map, unsigned long offset)
{
	u_int32_t *ptr;
	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		return  (*ptr);
	default:
		return (bus_space_read_4(map->bst, map->bsh, offset));
	}
}

void
drm_write8(drm_local_map_t *map, unsigned long offset, u_int8_t val)
{
	u_int8_t *ptr;
	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		*ptr = val;
		break;
	default:
		bus_space_write_1(map->bst, map->bsh, offset, val);
	}
}

void
drm_write16(drm_local_map_t *map, unsigned long offset, u_int16_t val)
{
	u_int16_t *ptr;
	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		*ptr = val;
		break;
	default:
		bus_space_write_2(map->bst, map->bsh, offset, val);
	}
}

void
drm_write32(drm_local_map_t *map, unsigned long offset, u_int32_t val)
{
	u_int32_t *ptr;
	switch (map->type) {
	case _DRM_SCATTER_GATHER:
		ptr = map->handle + offset;
		*ptr = val;
		break;
	default:
		bus_space_write_4(map->bst, map->bsh, offset, val);
	}
}
@


1.16
log
@The drm_* allocation functions have been #defined to not use most of
their arguments for a while. Actually go through the code and remove the
extraneous arguments. Makes things easier to read.
@
text
@d133 1
a133 1
drm_mtrr_del(int __unused handle, unsigned long offset, size_t size, int flags)
@


1.15
log
@change drm_attach_mi to drm_attach_pci. we take the pci_attach_args, and
setup the drm_attach_args with the needed information.

require interface version 1.1 libdrm has been requesting it for ages),
which means that we can set the busid string at attach time. (generated in
drm_attach_pci), also pass in the interrupt line and bst.

Now we don't need dev->pa at all, so remove it, finally.
@
text
@d42 1
a42 1
_drm_alloc(size_t size)
d44 1
a44 1
	return malloc(size, M_DRM, M_NOWAIT);
d48 1
a48 1
_drm_calloc(size_t nmemb, size_t size)
d57 1
a57 1
_drm_realloc(void *oldpt, size_t oldsize, size_t size)
d72 1
a72 1
_drm_free(void *pt)
@


1.14
log
@#define away unused arguments for the drm_alloc functions. to save some
size.

kill (empty) drm_mem_{un,}init() while here.
@
text
@d91 1
a91 1
		map->bst = dev->pa.pa_memt;
@


1.13
log
@Make all drm drivers map their mmio register space on attach instead of
using the drm_maps interface (this was done for inteldrm a few days
ago).  All drivers now ignore the mmio_offset argument that the init
ioctl takes.

This clears up the code and makes sure that drm_ioremap_core() doesn't
need the vga_pci_map inteface anymore, so we don't have to pass in the
vga softc anymore. We also get to kill the drm_resource_{start,length}
linux-alike functions since we just calculate all the requisite offsets
at startup and cache those we need. This now means that technically the
only driver that needs the vga_pci_map api is inteldrm (due to sharing
with intagp issues), though this diff doesn't convert them over.
@
text
@a40 10
void
drm_mem_init(void)
{
}

void
drm_mem_uninit(void)
{
}

d42 1
a42 1
drm_alloc(size_t size, int area)
d48 1
a48 1
drm_calloc(size_t nmemb, size_t size, int area)
d57 1
a57 1
drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
d72 1
a72 1
drm_free(void *pt, size_t size, int area)
@


1.12
log
@fix null dereference.

initial patch from me, reworked by oga@@.

found by LLVM/Clang Static Analyzer.

ok oga@@
@
text
@a90 3
	struct vga_pci_bar *bar = NULL;
	int i;

a106 1
		goto done;
d108 1
a108 18
		for (i = 0; i < DRM_MAX_PCI_RESOURCE; ++i) {
			bar = vga_pci_bar_info(dev->vga_softc, i);
			if (bar == NULL)
				continue;

			if (bar->base == map->offset) {
				DRM_DEBUG("REGISTERS map\n");
				map->bsr = vga_pci_bar_map(dev->vga_softc,
				    bar->addr, map->size, BUS_SPACE_MAP_LINEAR);
				if (map->bsr == NULL) {
					DRM_ERROR("ioremap fail\n");
					return (NULL);
				}
				map->bst = map->bsr->bst;
				map->bsh = map->bsr->bsh;
				goto done;
			}
		}
a109 1
done:
d117 2
a118 1
	if (map == NULL)
d121 1
a121 4
	if (map->bsr != NULL)
		vga_pci_bar_unmap(map->bsr);
	else
		bus_space_unmap(map->bst, map->bsh, map->size);
@


1.11
log
@Don't memcpy too far whem drm_realloc() is called with a smaller size.
This was never noticed since it's always used with a larger size.

Noticed by Stephane Marchesin.
@
text
@d139 4
a142 1
	if (map != NULL && map->bsr != NULL)
@


1.10
log
@Apply a light paddling with the knf stick. No binary change.
@
text
@d75 1
a75 1
		memcpy(pt, oldpt, oldsize);
@


1.9
log
@Check for zero in drm_calloc() to prevent divide-by-zero. Also rearrange
the two calls to drm_calloc() that had nmemb and size the wrong way
around.
@
text
@d112 1
a112 1
		for (i = 0 ; i < DRM_MAX_PCI_RESOURCE; ++i) {
@


1.8
log
@Switch all instances of malloc/free in the DRM to drm_alloc, drm_free
and drm_calloc.

With the recent change to check overflow in drm_calloc, this means that
all allocations that require multiplication are now checked. Also use
drm_calloc() when zeroing is needed and drop the bzero/memset
afterwards.  Finally, make drm_free() check for NULL, so we don't need
to do so every time.

ok miod@@, deraadt@@
@
text
@d60 1
a60 1
	if (SIZE_MAX / nmemb < size)
@


1.7
log
@Check for multiplication overflow in drm_calloc(). ok oga@@
@
text
@d84 2
a85 1
	free(pt, M_DRM);
@


1.6
log
@the DRM_{READ,WRITE}$NUMBER() macros currently use
bus_space_{read,write}(). A bug in the code this was based on means that
this is also used for scatter gather maps, which are bus_dma memory, not
pci memory.  This obviously fails. Pull them out into a function and
Special case scatter gather to use the mapped virtual address to write
instead. Makes writeback test pass on pci and pci express radeon cards.

Tested by, among others ckuethe@@ and sthen@@.
@
text
@d60 4
a63 2
	/* XXX overflow checking */
	return malloc(size * nmemb, M_DRM, M_NOWAIT | M_ZERO);
@


1.5
log
@Kill the silly ``drm_device_t'' and ``drm_file_t'' typedefs. just use
``struct drm_device'' and ``struct drm_file'' respectively. Since i'm
changing a lot of prototypes anyway, remove all parameter names from
prototypes, in accordance with style(9) (and sanity).
@
text
@d177 83
@


1.4
log
@Kill the rest of the ifdef maze in drm_*.c

I was going to do this per file, but decided all it would achieve was
artificially increasing my commit count.

>Kill the ifdef maze. I've been considering doing this for months, it
>doesn't make getting changes to and  from upstream much easier, and just
>makes the code hard to read.
@
text
@d86 1
a86 1
drm_ioremap(drm_device_t *dev, drm_local_map_t *map)
@


1.3
log
@currently agp_i810 needs to map the same BAR as inteldrm, this obviously
fails.

In order to allow this, implement an API so that drm and agp can share
mappings for the BARs. Now it works as it should.

tested by many.
ok kettenis, miod said he'd look at it when it's in tree.
@
text
@a40 4
#ifndef __OpenBSD__
MALLOC_DEFINE(M_DRM, "drm", "DRM Data Structures");
#endif

a43 5
#if defined(__NetBSD__) 
/*
	malloc_type_attach(M_DRM);
*/
#endif
a87 3
#ifdef __FreeBSD__
	return pmap_mapdev(map->offset, map->size);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a130 1
#endif
a135 3
#ifdef __FreeBSD__
	pmap_unmapdev((vm_offset_t) map->handle, map->size);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a139 1
#endif
a141 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a176 37
#elif defined(__NetBSD__) 
int
drm_mtrr_add(unsigned long offset, size_t size, int flags)
{
#ifndef DRM_NO_MTRR
	struct mtrr mtrrmap;
	int one = 1;

	DRM_DEBUG("offset=%lx size=%ld\n", (long)offset, (long)size);
	mtrrmap.base = offset;
	mtrrmap.len = size;
	mtrrmap.type = flags;
	mtrrmap.flags = MTRR_VALID;
	return mtrr_set(&mtrrmap, &one, NULL, MTRR_GETSET_KERNEL);
#else
	return 0;
#endif
}

int
drm_mtrr_del(int __unused handle, unsigned long offset, size_t size, int flags)
{
#ifndef DRM_NO_MTRR
	struct mtrr mtrrmap;
	int one = 1;

	DRM_DEBUG("offset=%lx size=%ld\n", (long)offset, (long)size);
	mtrrmap.base = offset;
	mtrrmap.len = size;
	mtrrmap.type = flags;
	mtrrmap.flags = 0;
	return mtrr_set(&mtrrmap, &one, NULL, MTRR_GETSET_KERNEL);
#else
	return 0;
#endif
}
#endif
@


1.2
log
@destatic the static functions, they only make debugging harder.
While i'm here:
remove a couple of debug printfs that shouldn't have gone in anyway.
trowel on some KNF (I really need to get around to sending some of this upstream).
remove some netbsd specific code that netbsd doesn't have anymore.

ok tedu.
@
text
@d100 39
a138 6
	int ret;
	if (!map->bst)
	map->bst = dev->pa.pa_memt;
	if ((ret = bus_space_map(map->bst, map->offset, map->size,
	    BUS_SPACE_MAP_LINEAR, &map->bsh))) {
		return NULL;
d140 2
d152 4
a155 1
	bus_space_unmap(map->bst, map->bsh, map->size);
@


1.1
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d45 2
a46 1
void drm_mem_init(void)
d55 2
a56 1
void drm_mem_uninit(void)
d60 2
a61 1
void *drm_alloc(size_t size, int area)
d66 2
a67 1
void *drm_calloc(size_t nmemb, size_t size, int area)
d73 2
a74 1
void *drm_realloc(void *oldpt, size_t oldsize, size_t size, int area)
d88 2
a89 1
void drm_free(void *pt, size_t size, int area)
d94 2
a95 1
void *drm_ioremap(drm_device_t *dev, drm_local_map_t *map)
a104 2
		DRM_ERROR("Failed to map offset = 0x%08lx, size = 0x%08lx, type = %d, ret = %d\n", map->offset,
		    map->size, map->type, ret);
a106 2
	DRM_INFO("mapped offset = 0x%08lx, size = 0x%08lx, type = %d\n", map->offset,
		    map->offset, map->size);
d111 2
a112 1
void drm_ioremapfree(drm_local_map_t *map)
a140 3
#if defined(__OpenBSD__)
drm_mtrr_del(int handle, unsigned long offset, size_t size, int flags)
#else
a141 1
#endif
@

