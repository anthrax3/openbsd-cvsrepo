head	1.16;
access;
symbols
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.10.0.8
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.4
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.2.0.6
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2016.11.17.21.08.27;	author mikeb;	state Exp;
branches;
next	1.15;
commitid	nldMJuxfqfXVZAUt;

1.15
date	2016.11.17.19.26.57;	author mikeb;	state Exp;
branches;
next	1.14;
commitid	s7sWiFVcUtMtUOpv;

1.14
date	2016.11.17.12.21.27;	author mikeb;	state Exp;
branches;
next	1.13;
commitid	rl7UKnhqgZzc9auT;

1.13
date	2016.11.16.23.19.29;	author mikeb;	state Exp;
branches;
next	1.12;
commitid	IZg2nJoFrsaft35v;

1.12
date	2015.04.30.14.17.26;	author jsg;	state Exp;
branches;
next	1.11;
commitid	kHonDANUeRfBUHle;

1.11
date	2015.04.30.13.24.36;	author sthen;	state Exp;
branches;
next	1.10;
commitid	9CN7Tt44JhZ4CTB3;

1.10
date	2013.08.05.19.58.06;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.17.12.28.06;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.10.13.00.47;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.06.17.29.39;	author mikeb;	state Exp;
branches;
next	1.6;

1.6
date	2012.08.11.06.53.31;	author mikeb;	state Exp;
branches;
next	1.5;

1.5
date	2012.08.06.21.07.52;	author mikeb;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.29.13.49.03;	author mikeb;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.10.12.46.35;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2010.02.25.10.56.07;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2010.02.23.18.43.15;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Autoconfiguration and firmware semaphore refactoring
@
text
@/*	$OpenBSD: ixgbe_82599.c,v 1.15 2016/11/17 19:26:57 mikeb Exp $	*/

/******************************************************************************

  Copyright (c) 2001-2015, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

******************************************************************************/
/*$FreeBSD: head/sys/dev/ixgbe/ixgbe_82599.c 292674 2015-12-23 22:45:17Z sbruno $*/

#include <dev/pci/ixgbe.h>
#include <dev/pci/ixgbe_type.h>

#define IXGBE_82599_MAX_TX_QUEUES 128
#define IXGBE_82599_MAX_RX_QUEUES 128
#define IXGBE_82599_RAR_ENTRIES   128
#define IXGBE_82599_MC_TBL_SIZE   128
#define IXGBE_82599_VFT_TBL_SIZE  128
#define IXGBE_82599_RX_PB_SIZE	  512

int32_t ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
					  ixgbe_link_speed *speed,
					  bool *autoneg);
enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw);
void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed);
int32_t ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
					ixgbe_link_speed speed,
					bool autoneg_wait_to_complete);
int32_t ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
				   bool autoneg_wait_to_complete);
int32_t ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
				   ixgbe_link_speed speed,
				   bool autoneg_wait_to_complete);
int32_t ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw);
void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw);
int32_t ixgbe_reset_hw_82599(struct ixgbe_hw *hw);
int32_t ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg,
				     uint8_t *val);
int32_t ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg,
				      uint8_t val);
int32_t ixgbe_start_hw_82599(struct ixgbe_hw *hw);
int32_t ixgbe_identify_phy_82599(struct ixgbe_hw *hw);
int32_t ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw);
uint32_t ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw);
int32_t ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, uint32_t regval);
int32_t prot_autoc_read_82599(struct ixgbe_hw *, bool *locked, uint32_t *reg_val);
int32_t prot_autoc_write_82599(struct ixgbe_hw *, uint32_t reg_val, bool locked);

void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);

int32_t ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed,
				      bool autoneg_wait_to_complete);

int32_t ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);
bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
int32_t ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);
int32_t ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
				uint16_t offset, uint16_t *data);
int32_t ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, uint8_t byte_offset,
				  uint8_t dev_addr, uint8_t *data);
int32_t ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, uint8_t byte_offset,
				   uint8_t dev_addr, uint8_t data);

void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
{
	struct ixgbe_mac_info *mac = &hw->mac;

	DEBUGFUNC("ixgbe_init_mac_link_ops_82599");

	/*
	 * enable the laser control functions for SFP+ fiber
	 * and MNG not enabled
	 */
	if ((mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) &&
	    !ixgbe_mng_enabled(hw)) {
		mac->ops.disable_tx_laser =
				       ixgbe_disable_tx_laser_multispeed_fiber;
		mac->ops.enable_tx_laser =
					ixgbe_enable_tx_laser_multispeed_fiber;
		mac->ops.flap_tx_laser = ixgbe_flap_tx_laser_multispeed_fiber;

	} else {
		mac->ops.disable_tx_laser = NULL;
		mac->ops.enable_tx_laser = NULL;
		mac->ops.flap_tx_laser = NULL;
	}

	if (hw->phy.multispeed_fiber) {
		/* Set up dual speed SFP+ support */
		mac->ops.setup_link = ixgbe_setup_mac_link_multispeed_fiber;
		mac->ops.setup_mac_link = ixgbe_setup_mac_link_82599;
		mac->ops.set_rate_select_speed =
					       ixgbe_set_hard_rate_select_speed;
		if (ixgbe_get_media_type(hw) == ixgbe_media_type_fiber_fixed)
			mac->ops.set_rate_select_speed =
					       ixgbe_set_soft_rate_select_speed;
	} else {
		if ((ixgbe_get_media_type(hw) == ixgbe_media_type_backplane) &&
		     (hw->phy.smart_speed == ixgbe_smart_speed_auto ||
		      hw->phy.smart_speed == ixgbe_smart_speed_on) &&
		      !ixgbe_verify_lesm_fw_enabled_82599(hw)) {
			mac->ops.setup_link = ixgbe_setup_mac_link_smartspeed;
		} else {
			mac->ops.setup_link = ixgbe_setup_mac_link_82599;
		}
	}
}

/**
 *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init
 *  @@hw: pointer to hardware structure
 *
 *  Initialize any function pointers that were not able to be
 *  set during init_shared_code because the PHY/SFP type was
 *  not known.  Perform the SFP init if necessary.
 *
 **/
int32_t ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)
{
	struct ixgbe_mac_info *mac = &hw->mac;
	struct ixgbe_phy_info *phy = &hw->phy;
	int32_t ret_val = IXGBE_SUCCESS;
	uint32_t esdp;

	DEBUGFUNC("ixgbe_init_phy_ops_82599");

	if (hw->device_id == IXGBE_DEV_ID_82599_QSFP_SF_QP) {
		/* Store flag indicating I2C bus access control unit. */
		hw->phy.qsfp_shared_i2c_bus = TRUE;

		/* Initialize access to QSFP+ I2C bus */
		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
		esdp |= IXGBE_ESDP_SDP0_DIR;
		esdp &= ~IXGBE_ESDP_SDP1_DIR;
		esdp &= ~IXGBE_ESDP_SDP0;
		esdp &= ~IXGBE_ESDP_SDP0_NATIVE;
		esdp &= ~IXGBE_ESDP_SDP1_NATIVE;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
		IXGBE_WRITE_FLUSH(hw);

		phy->ops.read_i2c_byte = ixgbe_read_i2c_byte_82599;
		phy->ops.write_i2c_byte = ixgbe_write_i2c_byte_82599;
	}
	/* Identify the PHY or SFP module */
	ret_val = phy->ops.identify(hw);
	if (ret_val == IXGBE_ERR_SFP_NOT_SUPPORTED)
		goto init_phy_ops_out;

	/* Setup function pointers based on detected SFP module and speeds */
	ixgbe_init_mac_link_ops_82599(hw);
	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown)
		hw->phy.ops.reset = NULL;

	/* If copper media, overwrite with copper function pointers */
	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
		mac->ops.setup_link = ixgbe_setup_copper_link_82599;
		mac->ops.get_link_capabilities =
				  ixgbe_get_copper_link_capabilities_generic;
	}

	/* Set necessary function pointers based on PHY type */
	switch (hw->phy.type) {
	case ixgbe_phy_tn:
		phy->ops.setup_link = ixgbe_setup_phy_link_tnx;
		phy->ops.check_link = ixgbe_check_phy_link_tnx;
		phy->ops.get_firmware_version =
			     ixgbe_get_phy_firmware_version_tnx;
		break;
	default:
		break;
	}
init_phy_ops_out:
	return ret_val;
}

int32_t ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;
	uint16_t list_offset, data_offset, data_value;

	DEBUGFUNC("ixgbe_setup_sfp_modules_82599");

	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {
		ixgbe_init_mac_link_ops_82599(hw);

		hw->phy.ops.reset = NULL;

		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
							      &data_offset);
		if (ret_val != IXGBE_SUCCESS)
			goto setup_sfp_out;

		/* PHY config will finish before releasing the semaphore */
		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
		if (ret_val != IXGBE_SUCCESS) {
			ret_val = IXGBE_ERR_SWFW_SYNC;
			goto setup_sfp_out;
		}

		if (hw->eeprom.ops.read(hw, ++data_offset, &data_value))
			goto setup_sfp_err;
		while (data_value != 0xffff) {
			IXGBE_WRITE_REG(hw, IXGBE_CORECTL, data_value);
			IXGBE_WRITE_FLUSH(hw);
			if (hw->eeprom.ops.read(hw, ++data_offset, &data_value))
				goto setup_sfp_err;
		}

		/* Release the semaphore */
		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
		/* Delay obtaining semaphore again to allow FW access
		 * prot_autoc_write uses the semaphore too.
		 */
		msec_delay(hw->eeprom.semaphore_delay);

		/* Restart DSP and set SFI mode */
		ret_val = hw->mac.ops.prot_autoc_write(hw,
			hw->mac.orig_autoc | IXGBE_AUTOC_LMS_10G_SERIAL,
			FALSE);

		if (ret_val) {
			DEBUGOUT("sfp module setup not complete\n");
			ret_val = IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
			goto setup_sfp_out;
		}

	}

setup_sfp_out:
	return ret_val;

setup_sfp_err:
	/* Release the semaphore */
	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
	/* Delay obtaining semaphore again to allow FW access */
	msec_delay(hw->eeprom.semaphore_delay);
	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
		      "eeprom read at offset %d failed", data_offset);
	return IXGBE_ERR_PHY;
}

/**
 *  prot_autoc_read_82599 - Hides MAC differences needed for AUTOC read
 *  @@hw: pointer to hardware structure
 *  @@locked: Return the if we locked for this read.
 *  @@reg_val: Value we read from AUTOC
 *
 *  For this part (82599) we need to wrap read-modify-writes with a possible
 *  FW/SW lock.  It is assumed this lock will be freed with the next
 *  prot_autoc_write_82599().
 */
int32_t prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,
    uint32_t *reg_val)
{
	int32_t ret_val;

	*locked = FALSE;
	 /* If LESM is on then we need to hold the SW/FW semaphore. */
	if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
					IXGBE_GSSR_MAC_CSR_SM);
		if (ret_val != IXGBE_SUCCESS)
			return IXGBE_ERR_SWFW_SYNC;

		*locked = TRUE;
	}

	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	return IXGBE_SUCCESS;
}

/**
 * prot_autoc_write_82599 - Hides MAC differences needed for AUTOC write
 * @@hw: pointer to hardware structure
 * @@reg_val: value to write to AUTOC
 * @@locked: bool to indicate whether the SW/FW lock was already taken by
 *           previous proc_autoc_read_82599.
 *
 * This part (82599) may need to hold the SW/FW lock around all writes to
 * AUTOC. Likewise after a write we need to do a pipeline reset.
 */
int32_t prot_autoc_write_82599(struct ixgbe_hw *hw, uint32_t autoc, bool locked)
{
	int32_t ret_val = IXGBE_SUCCESS;

	/* Blocked by MNG FW so bail */
	if (ixgbe_check_reset_blocked(hw))
		goto out;

	/* We only need to get the lock if:
	 *  - We didn't do it already (in the read part of a read-modify-write)
	 *  - LESM is enabled.
	 */
	if (!locked && ixgbe_verify_lesm_fw_enabled_82599(hw)) {
		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
					IXGBE_GSSR_MAC_CSR_SM);
		if (ret_val != IXGBE_SUCCESS)
			return IXGBE_ERR_SWFW_SYNC;

		locked = TRUE;
	}

	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
	ret_val = ixgbe_reset_pipeline_82599(hw);

out:
	/* Free the SW/FW semaphore as we either grabbed it here or
	 * already had it when this function was called.
	 */
	if (locked)
		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);

	return ret_val;
}

/**
 *  ixgbe_init_ops_82599 - Inits func ptrs and MAC type
 *  @@hw: pointer to hardware structure
 *
 *  Initialize the function pointers and assign the MAC type for 82599.
 *  Does not touch the hardware.
 **/

int32_t ixgbe_init_ops_82599(struct ixgbe_hw *hw)
{
	struct ixgbe_mac_info *mac = &hw->mac;
	struct ixgbe_phy_info *phy = &hw->phy;
	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
	int32_t ret_val;

	DEBUGFUNC("ixgbe_init_ops_82599");

	ret_val = ixgbe_init_phy_ops_generic(hw);
	ret_val = ixgbe_init_ops_generic(hw);

	/* PHY */
	phy->ops.identify = ixgbe_identify_phy_82599;
	phy->ops.init = ixgbe_init_phy_ops_82599;

	/* MAC */
	mac->ops.reset_hw = ixgbe_reset_hw_82599;
	mac->ops.get_media_type = ixgbe_get_media_type_82599;
	mac->ops.get_supported_physical_layer =
				    ixgbe_get_supported_physical_layer_82599;
	mac->ops.disable_sec_rx_path = ixgbe_disable_sec_rx_path_generic;
	mac->ops.enable_sec_rx_path = ixgbe_enable_sec_rx_path_generic;
	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_82599;
	mac->ops.read_analog_reg8 = ixgbe_read_analog_reg8_82599;
	mac->ops.write_analog_reg8 = ixgbe_write_analog_reg8_82599;
	mac->ops.start_hw = ixgbe_start_hw_82599;

	mac->ops.prot_autoc_read = prot_autoc_read_82599;
	mac->ops.prot_autoc_write = prot_autoc_write_82599;

	/* RAR, Multicast, VLAN */
	mac->ops.set_vmdq = ixgbe_set_vmdq_generic;
	mac->ops.clear_vmdq = ixgbe_clear_vmdq_generic;
	mac->ops.insert_mac_addr = ixgbe_insert_mac_addr_generic;
	mac->rar_highwater = 1;
	mac->ops.set_vfta = ixgbe_set_vfta_generic;
	mac->ops.set_vlvf = ixgbe_set_vlvf_generic;
	mac->ops.clear_vfta = ixgbe_clear_vfta_generic;
	mac->ops.init_uta_tables = ixgbe_init_uta_tables_generic;
	mac->ops.setup_sfp = ixgbe_setup_sfp_modules_82599;

	/* Link */
	mac->ops.get_link_capabilities = ixgbe_get_link_capabilities_82599;
	mac->ops.check_link = ixgbe_check_mac_link_generic;
	mac->ops.stop_mac_link_on_d3 = ixgbe_stop_mac_link_on_d3_82599;
	ixgbe_init_mac_link_ops_82599(hw);

	mac->mcft_size		= IXGBE_82599_MC_TBL_SIZE;
	mac->vft_size		= IXGBE_82599_VFT_TBL_SIZE;
	mac->num_rar_entries	= IXGBE_82599_RAR_ENTRIES;
	mac->rx_pb_size		= IXGBE_82599_RX_PB_SIZE;
	mac->max_rx_queues	= IXGBE_82599_MAX_RX_QUEUES;
	mac->max_tx_queues	= IXGBE_82599_MAX_TX_QUEUES;
	mac->max_msix_vectors	= 0 /*ixgbe_get_pcie_msix_count_generic(hw)*/;

	hw->mbx.ops.init_params = ixgbe_init_mbx_params_pf;

	/* EEPROM */
	eeprom->ops.read = ixgbe_read_eeprom_82599;

	return ret_val;
}

/**
 *  ixgbe_get_link_capabilities_82599 - Determines link capabilities
 *  @@hw: pointer to hardware structure
 *  @@speed: pointer to link speed
 *  @@autoneg: TRUE when autoneg or autotry is enabled
 *
 *  Determines the link capabilities by reading the AUTOC register.
 **/
int32_t ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
				      ixgbe_link_speed *speed,
				      bool *autoneg)
{
	int32_t status = IXGBE_SUCCESS;
	uint32_t autoc = 0;

	DEBUGFUNC("ixgbe_get_link_capabilities_82599");

	/* Check if 1G SFP module. */
	if (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		goto out;
	}

	/*
	 * Determine link capabilities based on the stored value of AUTOC,
	 * which represents EEPROM defaults.  If AUTOC value has not
	 * been stored, use the current register values.
	 */
	if (hw->mac.orig_link_settings_stored)
		autoc = hw->mac.orig_autoc;
	else
		autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);

	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = FALSE;
		break;

	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
		*autoneg = FALSE;
		break;

	case IXGBE_AUTOC_LMS_1G_AN:
		*speed = IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		break;

	case IXGBE_AUTOC_LMS_10G_SERIAL:
		*speed = IXGBE_LINK_SPEED_10GB_FULL;
		*autoneg = FALSE;
		break;

	case IXGBE_AUTOC_LMS_KX4_KX_KR:
	case IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN:
		*speed = IXGBE_LINK_SPEED_UNKNOWN;
		if (autoc & IXGBE_AUTOC_KR_SUPP)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (autoc & IXGBE_AUTOC_KX4_SUPP)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (autoc & IXGBE_AUTOC_KX_SUPP)
			*speed |= IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		break;

	case IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII:
		*speed = IXGBE_LINK_SPEED_100_FULL;
		if (autoc & IXGBE_AUTOC_KR_SUPP)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (autoc & IXGBE_AUTOC_KX4_SUPP)
			*speed |= IXGBE_LINK_SPEED_10GB_FULL;
		if (autoc & IXGBE_AUTOC_KX_SUPP)
			*speed |= IXGBE_LINK_SPEED_1GB_FULL;
		*autoneg = TRUE;
		break;

	case IXGBE_AUTOC_LMS_SGMII_1G_100M:
		*speed = IXGBE_LINK_SPEED_1GB_FULL | IXGBE_LINK_SPEED_100_FULL;
		*autoneg = FALSE;
		break;

	default:
		status = IXGBE_ERR_LINK_SETUP;
		goto out;
		break;
	}

	if (hw->phy.multispeed_fiber) {
		*speed |= IXGBE_LINK_SPEED_10GB_FULL |
			  IXGBE_LINK_SPEED_1GB_FULL;

		/* QSFP must not enable full auto-negotiation
		 * Limited autoneg is enabled at 1G
		 */
		if (hw->phy.media_type == ixgbe_media_type_fiber_qsfp)
			*autoneg = FALSE;
		else
			*autoneg = TRUE;
	}

out:
	return status;
}

/**
 *  ixgbe_get_media_type_82599 - Get media type
 *  @@hw: pointer to hardware structure
 *
 *  Returns the media type (fiber, copper, backplane)
 **/
enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
{
	enum ixgbe_media_type media_type;

	DEBUGFUNC("ixgbe_get_media_type_82599");

	/* Detect if there is a copper PHY attached. */
	switch (hw->phy.type) {
	case ixgbe_phy_cu_unknown:
	case ixgbe_phy_tn:
		media_type = ixgbe_media_type_copper;
		goto out;
	default:
		break;
	}

	switch (hw->device_id) {
	case IXGBE_DEV_ID_82599_KX4:
	case IXGBE_DEV_ID_82599_KX4_MEZZ:
	case IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
	case IXGBE_DEV_ID_82599_KR:
	case IXGBE_DEV_ID_82599_BACKPLANE_FCOE:
	case IXGBE_DEV_ID_82599_XAUI_LOM:
		/* Default device ID is mezzanine card KX/KX4 */
		media_type = ixgbe_media_type_backplane;
		break;
	case IXGBE_DEV_ID_82599_SFP:
	case IXGBE_DEV_ID_82599_SFP_FCOE:
	case IXGBE_DEV_ID_82599_SFP_EM:
	case IXGBE_DEV_ID_82599_SFP_SF2:
	case IXGBE_DEV_ID_82599_SFP_SF_QP:
	case IXGBE_DEV_ID_82599EN_SFP:
		media_type = ixgbe_media_type_fiber;
		break;
	case IXGBE_DEV_ID_82599_CX4:
		media_type = ixgbe_media_type_cx4;
		break;
	case IXGBE_DEV_ID_82599_T3_LOM:
		media_type = ixgbe_media_type_copper;
		break;
	case IXGBE_DEV_ID_82599_QSFP_SF_QP:
		media_type = ixgbe_media_type_fiber_qsfp;
		break;
	case IXGBE_DEV_ID_82599_BYPASS:
		media_type = ixgbe_media_type_fiber_fixed;
		hw->phy.multispeed_fiber = TRUE;
		break;
	default:
		media_type = ixgbe_media_type_unknown;
		break;
	}
out:
	return media_type;
}

/**
 *  ixgbe_stop_mac_link_on_d3_82599 - Disables link on D3
 *  @@hw: pointer to hardware structure
 *
 *  Disables link during D3 power down sequence.
 *
 **/
void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
{
	uint32_t autoc2_reg;
	uint16_t ee_ctrl_2 = 0;

	DEBUGFUNC("ixgbe_stop_mac_link_on_d3_82599");
	ixgbe_read_eeprom_82599(hw, IXGBE_EEPROM_CTRL_2, &ee_ctrl_2);

	if (!ixgbe_mng_present(hw) &&
	    (ee_ctrl_2 & IXGBE_EEPROM_CCD_BIT)) {
		autoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
		autoc2_reg |= IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);
	}
}

/**
 *  ixgbe_start_mac_link_82599 - Setup MAC link settings
 *  @@hw: pointer to hardware structure
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Configures link settings based on values in the ixgbe_hw struct.
 *  Restarts the link.  Performs autonegotiation if needed.
 **/
int32_t ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
				   bool autoneg_wait_to_complete)
{
	uint32_t autoc_reg;
	uint32_t links_reg;
	uint32_t i;
	int32_t status = IXGBE_SUCCESS;
	bool got_lock = FALSE;

	DEBUGFUNC("ixgbe_start_mac_link_82599");


	/*  reset_pipeline requires us to hold this lock as it writes to
	 *  AUTOC.
	 */
	if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
		status = hw->mac.ops.acquire_swfw_sync(hw,
						       IXGBE_GSSR_MAC_CSR_SM);
		if (status != IXGBE_SUCCESS)
			goto out;

		got_lock = TRUE;
	}

	/* Restart link */
	ixgbe_reset_pipeline_82599(hw);

	if (got_lock)
		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);

	/* Only poll for autoneg to complete if specified to do so */
	if (autoneg_wait_to_complete) {
		autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
		if ((autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
		     IXGBE_AUTOC_LMS_KX4_KX_KR ||
		    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
		     IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||
		    (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
		     IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {
			links_reg = 0; /* Just in case Autoneg time = 0 */
			for (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {
				links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
				if (links_reg & IXGBE_LINKS_KX_AN_COMP)
					break;
				msec_delay(100);
			}
			if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
				status = IXGBE_ERR_AUTONEG_NOT_COMPLETE;
				DEBUGOUT("Autoneg did not complete.\n");
			}
		}
	}

	/* Add delay to filter out noises during initial link setup */
	msec_delay(50);

out:
	return status;
}

/**
 *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser
 *  @@hw: pointer to hardware structure
 *
 *  The base drivers may require better control over SFP+ module
 *  PHY states.  This includes selectively shutting down the Tx
 *  laser on the PHY, effectively halting physical link.
 **/
void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
	uint32_t esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);

	/* Blocked by MNG FW so bail */
	if (ixgbe_check_reset_blocked(hw))
		return;

	/* Disable Tx laser; allow 100us to go dark per spec */
	esdp_reg |= IXGBE_ESDP_SDP3;
	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(100);
}

/**
 *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser
 *  @@hw: pointer to hardware structure
 *
 *  The base drivers may require better control over SFP+ module
 *  PHY states.  This includes selectively turning on the Tx
 *  laser on the PHY, effectively starting physical link.
 **/
void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
	uint32_t esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);

	/* Enable Tx laser; allow 100ms to light up */
	esdp_reg &= ~IXGBE_ESDP_SDP3;
	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
	IXGBE_WRITE_FLUSH(hw);
	msec_delay(100);
}

/**
 *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser
 *  @@hw: pointer to hardware structure
 *
 *  When the driver changes the link speeds that it can support,
 *  it sets autotry_restart to TRUE to indicate that we need to
 *  initiate a new autotry session with the link partner.  To do
 *  so, we set the speed then disable and re-enable the Tx laser, to
 *  alert the link partner that it also needs to restart autotry on its
 *  end.  This is consistent with TRUE clause 37 autoneg, which also
 *  involves a loss of signal.
 **/
void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
{
	DEBUGFUNC("ixgbe_flap_tx_laser_multispeed_fiber");

	/* Blocked by MNG FW so bail */
	if (ixgbe_check_reset_blocked(hw))
		return;

	if (hw->mac.autotry_restart) {
		ixgbe_disable_tx_laser_multispeed_fiber(hw);
		ixgbe_enable_tx_laser_multispeed_fiber(hw);
		hw->mac.autotry_restart = FALSE;
	}
}

/**
 *  ixgbe_set_hard_rate_select_speed - Set module link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: link speed to set
 *
 *  Set module link speed via RS0/RS1 rate select pins.
 */
void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed)
{
	uint32_t esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);

	switch (speed) {
	case IXGBE_LINK_SPEED_10GB_FULL:
		esdp_reg |= (IXGBE_ESDP_SDP5_DIR | IXGBE_ESDP_SDP5);
		break;
	case IXGBE_LINK_SPEED_1GB_FULL:
		esdp_reg &= ~IXGBE_ESDP_SDP5;
		esdp_reg |= IXGBE_ESDP_SDP5_DIR;
		break;
	default:
		DEBUGOUT("Invalid fixed module speed\n");
		return;
	}

	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
	IXGBE_WRITE_FLUSH(hw);
}

/**
 *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Implements the Intel SmartSpeed algorithm.
 **/
int32_t ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
					ixgbe_link_speed speed,
					bool autoneg_wait_to_complete)
{
	int32_t status = IXGBE_SUCCESS;
	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
	int32_t i, j;
	bool link_up = FALSE;
	uint32_t autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);

	DEBUGFUNC("ixgbe_setup_mac_link_smartspeed");

	 /* Set autoneg_advertised value based on input link speed */
	hw->phy.autoneg_advertised = 0;

	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;

	if (speed & IXGBE_LINK_SPEED_1GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;

	if (speed & IXGBE_LINK_SPEED_100_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_100_FULL;

	/*
	 * Implement Intel SmartSpeed algorithm.  SmartSpeed will reduce the
	 * autoneg advertisement if link is unable to be established at the
	 * highest negotiated rate.  This can sometimes happen due to integrity
	 * issues with the physical media connection.
	 */

	/* First, try to get link with full advertisement */
	hw->phy.smart_speed_active = FALSE;
	for (j = 0; j < IXGBE_SMARTSPEED_MAX_RETRIES; j++) {
		status = ixgbe_setup_mac_link_82599(hw, speed,
						    autoneg_wait_to_complete);
		if (status != IXGBE_SUCCESS)
			goto out;

		/*
		 * Wait for the controller to acquire link.  Per IEEE 802.3ap,
		 * Section 73.10.2, we may have to wait up to 500ms if KR is
		 * attempted, or 200ms if KX/KX4/BX/BX4 is attempted, per
		 * Table 9 in the AN MAS.
		 */
		for (i = 0; i < 5; i++) {
			msec_delay(100);

			/* If we have link, just jump out */
			status = ixgbe_check_link(hw, &link_speed, &link_up,
						  FALSE);
			if (status != IXGBE_SUCCESS)
				goto out;

			if (link_up)
				goto out;
		}
	}

	/*
	 * We didn't get link.  If we advertised KR plus one of KX4/KX
	 * (or BX4/BX), then disable KR and try again.
	 */
	if (((autoc_reg & IXGBE_AUTOC_KR_SUPP) == 0) ||
	    ((autoc_reg & IXGBE_AUTOC_KX4_KX_SUPP_MASK) == 0))
		goto out;

	/* Turn SmartSpeed on to disable KR support */
	hw->phy.smart_speed_active = TRUE;
	status = ixgbe_setup_mac_link_82599(hw, speed,
					    autoneg_wait_to_complete);
	if (status != IXGBE_SUCCESS)
		goto out;

	/*
	 * Wait for the controller to acquire link.  600ms will allow for
	 * the AN link_fail_inhibit_timer as well for multiple cycles of
	 * parallel detect, both 10g and 1g. This allows for the maximum
	 * connect attempts as defined in the AN MAS table 73-7.
	 */
	for (i = 0; i < 6; i++) {
		msec_delay(100);

		/* If we have link, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			goto out;

		if (link_up)
			goto out;
	}

	/* We didn't get link.  Turn SmartSpeed back off. */
	hw->phy.smart_speed_active = FALSE;
	status = ixgbe_setup_mac_link_82599(hw, speed,
					    autoneg_wait_to_complete);

out:
	if (link_up && (link_speed == IXGBE_LINK_SPEED_1GB_FULL))
		DEBUGOUT("Smartspeed has downgraded the link speed "
		"from the maximum advertised\n");
	return status;
}

/**
 *  ixgbe_setup_mac_link_82599 - Set MAC link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Set the link speed in the AUTOC register and restarts link.
 **/
int32_t ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
				   ixgbe_link_speed speed,
				   bool autoneg_wait_to_complete)
{
	bool autoneg = FALSE;
	int32_t status = IXGBE_SUCCESS;
	uint32_t pma_pmd_1g, link_mode;
	/* holds the value of AUTOC register at this current point in time */
	uint32_t current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	/* holds the cached value of AUTOC register */
	uint32_t orig_autoc = 0;
	/* Temporary variable used for comparison purposes */
	uint32_t autoc = current_autoc;
	uint32_t autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
	uint32_t pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
	uint32_t links_reg;
	uint32_t i;
	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;

	DEBUGFUNC("ixgbe_setup_mac_link_82599");

	/* Check to see if speed passed in is supported. */
	status = ixgbe_get_link_capabilities_82599(hw, &link_capabilities,
	    &autoneg);
	if (status)
		goto out;

	speed &= link_capabilities;

	if (speed == IXGBE_LINK_SPEED_UNKNOWN) {
		status = IXGBE_ERR_LINK_SETUP;
		goto out;
	}

	/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
	if (hw->mac.orig_link_settings_stored)
		orig_autoc = hw->mac.orig_autoc;
	else
		orig_autoc = autoc;

	link_mode = autoc & IXGBE_AUTOC_LMS_MASK;
	pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;

	if (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||
	    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||
	    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {
		/* Set KX4/KX/KR support according to speed requested */
		autoc &= ~(IXGBE_AUTOC_KX4_KX_SUPP_MASK | IXGBE_AUTOC_KR_SUPP);
		if (speed & IXGBE_LINK_SPEED_10GB_FULL) {
			if (orig_autoc & IXGBE_AUTOC_KX4_SUPP)
				autoc |= IXGBE_AUTOC_KX4_SUPP;
			if ((orig_autoc & IXGBE_AUTOC_KR_SUPP) &&
			    (hw->phy.smart_speed_active == FALSE))
				autoc |= IXGBE_AUTOC_KR_SUPP;
		}
		if (speed & IXGBE_LINK_SPEED_1GB_FULL)
			autoc |= IXGBE_AUTOC_KX_SUPP;
	} else if ((pma_pmd_1g == IXGBE_AUTOC_1G_SFI) &&
		   (link_mode == IXGBE_AUTOC_LMS_1G_LINK_NO_AN ||
		    link_mode == IXGBE_AUTOC_LMS_1G_AN)) {
		/* Switch from 1G SFI to 10G SFI if requested */
		if ((speed == IXGBE_LINK_SPEED_10GB_FULL) &&
		    (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI)) {
			autoc &= ~IXGBE_AUTOC_LMS_MASK;
			autoc |= IXGBE_AUTOC_LMS_10G_SERIAL;
		}
	} else if ((pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI) &&
		   (link_mode == IXGBE_AUTOC_LMS_10G_SERIAL)) {
		/* Switch from 10G SFI to 1G SFI if requested */
		if ((speed == IXGBE_LINK_SPEED_1GB_FULL) &&
		    (pma_pmd_1g == IXGBE_AUTOC_1G_SFI)) {
			autoc &= ~IXGBE_AUTOC_LMS_MASK;
			if (autoneg || hw->phy.type == ixgbe_phy_qsfp_intel)
				autoc |= IXGBE_AUTOC_LMS_1G_AN;
			else
				autoc |= IXGBE_AUTOC_LMS_1G_LINK_NO_AN;
		}
	}

	if (autoc != current_autoc) {
		/* Restart link */
		status = hw->mac.ops.prot_autoc_write(hw, autoc, FALSE);
		if (status != IXGBE_SUCCESS)
			goto out;

		/* Only poll for autoneg to complete if specified to do so */
		if (autoneg_wait_to_complete) {
			if (link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR ||
			    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||
			    link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {
				links_reg = 0; /*Just in case Autoneg time=0*/
				for (i = 0; i < IXGBE_AUTO_NEG_TIME; i++) {
					links_reg =
					       IXGBE_READ_REG(hw, IXGBE_LINKS);
					if (links_reg & IXGBE_LINKS_KX_AN_COMP)
						break;
					msec_delay(100);
				}
				if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
					status =
						IXGBE_ERR_AUTONEG_NOT_COMPLETE;
					DEBUGOUT("Autoneg did not complete.\n");
				}
			}
		}

		/* Add delay to filter out noises during initial link setup */
		msec_delay(50);
	}

out:
	return status;
}

/**
 *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE if waiting is needed to complete
 *
 *  Restarts link on PHY and MAC based on settings passed in.
 **/
int32_t ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed,
				      bool autoneg_wait_to_complete)
{
	int32_t status;

	DEBUGFUNC("ixgbe_setup_copper_link_82599");

	/* Setup the PHY according to input speed */
	status = hw->phy.ops.setup_link_speed(hw, speed,
					      autoneg_wait_to_complete);
	/* Set up MAC */
	ixgbe_start_mac_link_82599(hw, autoneg_wait_to_complete);

	return status;
}

/**
 *  ixgbe_reset_hw_82599 - Perform hardware reset
 *  @@hw: pointer to hardware structure
 *
 *  Resets the hardware by resetting the transmit and receive units, masks
 *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)
 *  reset.
 **/
int32_t ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
{
	ixgbe_link_speed link_speed;
	int32_t status;
	uint32_t ctrl = 0;
	uint32_t i, autoc, autoc2;
	uint32_t curr_lms;
	bool link_up = FALSE;

	DEBUGFUNC("ixgbe_reset_hw_82599");

	/* Call adapter stop to disable tx/rx and clear interrupts */
	status = hw->mac.ops.stop_adapter(hw);
	if (status != IXGBE_SUCCESS)
		goto reset_hw_out;

	/* flush pending Tx transactions */
	ixgbe_clear_tx_pending(hw);

	/* PHY ops must be identified and initialized prior to reset */

	/* Identify PHY and related function pointers */
	status = hw->phy.ops.init(hw);

	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
		goto reset_hw_out;

	/* Setup SFP module if there is one present. */
	if (hw->phy.sfp_setup_needed) {
		status = hw->mac.ops.setup_sfp(hw);
		hw->phy.sfp_setup_needed = FALSE;
	}

	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
		goto reset_hw_out;

	/* Reset PHY */
	if (hw->phy.reset_disable == FALSE && hw->phy.ops.reset != NULL)
		hw->phy.ops.reset(hw);

	/* remember AUTOC from before we reset */
	curr_lms = IXGBE_READ_REG(hw, IXGBE_AUTOC) & IXGBE_AUTOC_LMS_MASK;

mac_reset_top:
	/*
	 * Issue global reset to the MAC.  Needs to be SW reset if link is up.
	 * If link reset is used when link is up, it might reset the PHY when
	 * mng is using it.  If link is down or the flag to force full link
	 * reset is set, then perform link reset.
	 */
	ctrl = IXGBE_CTRL_LNK_RST;
	if (!hw->force_full_reset) {
		hw->mac.ops.check_link(hw, &link_speed, &link_up, FALSE);
		if (link_up)
			ctrl = IXGBE_CTRL_RST;
	}

	ctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
	IXGBE_WRITE_FLUSH(hw);

	/* Poll for reset bit to self-clear meaning reset is complete */
	for (i = 0; i < 10; i++) {
		usec_delay(1);
		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
		if (!(ctrl & IXGBE_CTRL_RST_MASK))
			break;
	}

	if (ctrl & IXGBE_CTRL_RST_MASK) {
		status = IXGBE_ERR_RESET_FAILED;
		DEBUGOUT("Reset polling failed to complete.\n");
	}

	msec_delay(50);

	/*
	 * Double resets are required for recovery from certain error
	 * conditions.  Between resets, it is necessary to stall to
	 * allow time for any pending HW events to complete.
	 */
	if (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {
		hw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
		goto mac_reset_top;
	}

	/*
	 * Store the original AUTOC/AUTOC2 values if they have not been
	 * stored off yet.  Otherwise restore the stored original
	 * values since the reset operation sets back to defaults.
	 */
	autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);

	/* Enable link if disabled in NVM */
	if (autoc2 & IXGBE_AUTOC2_LINK_DISABLE_MASK) {
		autoc2 &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);
		IXGBE_WRITE_FLUSH(hw);
	}

	if (hw->mac.orig_link_settings_stored == FALSE) {
		hw->mac.orig_autoc = autoc;
		hw->mac.orig_autoc2 = autoc2;
		hw->mac.orig_link_settings_stored = TRUE;
	} else {

		/* If MNG FW is running on a multi-speed device that
		 * doesn't autoneg with out driver support we need to
		 * leave LMS in the state it was before we MAC reset.
		 * Likewise if we support WoL we don't want change the
		 * LMS state.
		 */
		if (hw->phy.multispeed_fiber && ixgbe_mng_enabled(hw))
			hw->mac.orig_autoc =
				(hw->mac.orig_autoc & ~IXGBE_AUTOC_LMS_MASK) |
				curr_lms;

		if (autoc != hw->mac.orig_autoc) {
			status = hw->mac.ops.prot_autoc_write(hw,
							hw->mac.orig_autoc,
							FALSE);
			if (status != IXGBE_SUCCESS)
				goto reset_hw_out;
		}

		if ((autoc2 & IXGBE_AUTOC2_UPPER_MASK) !=
		    (hw->mac.orig_autoc2 & IXGBE_AUTOC2_UPPER_MASK)) {
			autoc2 &= ~IXGBE_AUTOC2_UPPER_MASK;
			autoc2 |= (hw->mac.orig_autoc2 &
				   IXGBE_AUTOC2_UPPER_MASK);
			IXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2);
		}
	}

	/* Store the permanent mac address */
	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);

	/*
	 * Store MAC address from RAR0, clear receive address registers, and
	 * clear the multicast table.  Also reset num_rar_entries to 128,
	 * since we modify this value when programming the SAN MAC address.
	 */
	hw->mac.num_rar_entries = 128;
	hw->mac.ops.init_rx_addrs(hw);

reset_hw_out:
	return status;
}

/**
 *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register
 *  @@hw: pointer to hardware structure
 *  @@reg: analog register to read
 *  @@val: read value
 *
 *  Performs read operation to Omer analog register specified.
 **/
int32_t ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg,
				     uint8_t *val)
{
	uint32_t  core_ctl;

	DEBUGFUNC("ixgbe_read_analog_reg8_82599");

	IXGBE_WRITE_REG(hw, IXGBE_CORECTL, IXGBE_CORECTL_WRITE_CMD |
			(reg << 8));
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(10);
	core_ctl = IXGBE_READ_REG(hw, IXGBE_CORECTL);
	*val = (uint8_t)core_ctl;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register
 *  @@hw: pointer to hardware structure
 *  @@reg: atlas register to write
 *  @@val: value to write
 *
 *  Performs write operation to Omer analog register specified.
 **/
int32_t ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg,
				      uint8_t val)
{
	uint32_t  core_ctl;

	DEBUGFUNC("ixgbe_write_analog_reg8_82599");

	core_ctl = (reg << 8) | val;
	IXGBE_WRITE_REG(hw, IXGBE_CORECTL, core_ctl);
	IXGBE_WRITE_FLUSH(hw);
	usec_delay(10);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx
 *  @@hw: pointer to hardware structure
 *
 *  Starts the hardware using the generic start_hw function
 *  and the generation start_hw function.
 *  Then performs revision-specific operations, if any.
 **/
int32_t ixgbe_start_hw_82599(struct ixgbe_hw *hw)
{
	int32_t ret_val = IXGBE_SUCCESS;

	DEBUGFUNC("ixgbe_start_hw_82599");

	ret_val = ixgbe_start_hw_generic(hw);
	if (ret_val != IXGBE_SUCCESS)
		goto out;

	ret_val = ixgbe_start_hw_gen2(hw);
	if (ret_val != IXGBE_SUCCESS)
		goto out;

	/* We need to run link autotry after the driver loads */
	hw->mac.autotry_restart = TRUE;

	if (ret_val == IXGBE_SUCCESS)
		ret_val = ixgbe_verify_fw_version_82599(hw);
out:
	return ret_val;
}

/**
 *  ixgbe_identify_phy_82599 - Get physical layer module
 *  @@hw: pointer to hardware structure
 *
 *  Determines the physical layer module found on the current adapter.
 *  If PHY already detected, maintains current PHY type in hw struct,
 *  otherwise executes the PHY detection routine.
 **/
int32_t ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
{
	int32_t status;

	DEBUGFUNC("ixgbe_identify_phy_82599");

	/* Detect PHY if not unknown - returns success if already detected. */
	status = ixgbe_identify_phy_generic(hw);
	if (status != IXGBE_SUCCESS) {
		/* 82599 10GBASE-T requires an external PHY */
		if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper)
			return status;
		else
			status = ixgbe_identify_module_generic(hw);
	}

	/* Set PHY type none if no PHY detected */
	if (hw->phy.type == ixgbe_phy_unknown) {
		hw->phy.type = ixgbe_phy_none;
		return IXGBE_SUCCESS;
	}

	/* Return error if SFP module has been detected but is not supported */
	if (hw->phy.type == ixgbe_phy_sfp_unsupported)
		return IXGBE_ERR_SFP_NOT_SUPPORTED;

	return status;
}

/**
 *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type
 *  @@hw: pointer to hardware structure
 *
 *  Determines physical layer capabilities of the current configuration.
 **/
uint32_t ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw)
{
	uint32_t physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
	uint32_t autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	uint32_t autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
	uint32_t pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
	uint32_t pma_pmd_10g_parallel = autoc & IXGBE_AUTOC_10G_PMA_PMD_MASK;
	uint32_t pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
	uint16_t ext_ability = 0;

	DEBUGFUNC("ixgbe_get_support_physical_layer_82599");

	hw->phy.ops.identify(hw);

	switch (hw->phy.type) {
	case ixgbe_phy_tn:
	case ixgbe_phy_cu_unknown:
		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
		IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
		if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
		if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
		if (ext_ability & IXGBE_MDIO_PHY_100BASETX_ABILITY)
			physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
		goto out;
	default:
		break;
	}

	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
	case IXGBE_AUTOC_LMS_1G_AN:
	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
		if (pma_pmd_1g == IXGBE_AUTOC_1G_KX_BX) {
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX |
			    IXGBE_PHYSICAL_LAYER_1000BASE_BX;
			goto out;
		} else
			/* SFI mode so read SFP module */
			goto sfp_check;
		break;
	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
		if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_CX4)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_CX4;
		else if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_KX4)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
		else if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_XAUI)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_XAUI;
		goto out;
		break;
	case IXGBE_AUTOC_LMS_10G_SERIAL:
		if (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_KR) {
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KR;
			goto out;
		} else if (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI)
			goto sfp_check;
		break;
	case IXGBE_AUTOC_LMS_KX4_KX_KR:
	case IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN:
		if (autoc & IXGBE_AUTOC_KX_SUPP)
			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_KX;
		if (autoc & IXGBE_AUTOC_KX4_SUPP)
			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
		if (autoc & IXGBE_AUTOC_KR_SUPP)
			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KR;
		goto out;
		break;
	default:
		goto out;
		break;
	}

sfp_check:
	/* SFP check must be done last since DA modules are sometimes used to
	 * test KR mode -  we need to id KR mode correctly before SFP module.
	 * Call identify_sfp because the pluggable module may have changed */
	physical_layer = ixgbe_get_supported_phy_sfp_layer_generic(hw);
out:
	return physical_layer;
}

/**
 *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599
 *  @@hw: pointer to hardware structure
 *  @@regval: register value to write to RXCTRL
 *
 *  Enables the Rx DMA unit for 82599
 **/
int32_t ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, uint32_t regval)
{

	DEBUGFUNC("ixgbe_enable_rx_dma_82599");

	/*
	 * Workaround for 82599 silicon errata when enabling the Rx datapath.
	 * If traffic is incoming before we enable the Rx unit, it could hang
	 * the Rx DMA unit.  Therefore, make sure the security engine is
	 * completely disabled prior to enabling the Rx unit.
	 */

	hw->mac.ops.disable_sec_rx_path(hw);

	if (regval & IXGBE_RXCTRL_RXEN)
		ixgbe_enable_rx(hw);
	else
		ixgbe_disable_rx(hw);

	hw->mac.ops.enable_sec_rx_path(hw);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_verify_fw_version_82599 - verify FW version for 82599
 *  @@hw: pointer to hardware structure
 *
 *  Verifies that installed the firmware version is 0.6 or higher
 *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.
 *
 *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or
 *  if the FW version is not supported.
 **/
int32_t ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)
{
	int32_t status = IXGBE_ERR_EEPROM_VERSION;
	uint16_t fw_offset, fw_ptp_cfg_offset;
	uint16_t fw_version;

	DEBUGFUNC("ixgbe_verify_fw_version_82599");

	/* firmware check is only necessary for SFI devices */
	if (hw->phy.media_type != ixgbe_media_type_fiber) {
		status = IXGBE_SUCCESS;
		goto fw_version_out;
	}

	/* get the offset to the Firmware Module block */
	if (hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset)) {
		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
			      "eeprom read at offset %d failed", IXGBE_FW_PTR);
		return IXGBE_ERR_EEPROM_VERSION;
	}

	if ((fw_offset == 0) || (fw_offset == 0xFFFF))
		goto fw_version_out;

	/* get the offset to the Pass Through Patch Configuration block */
	if (hw->eeprom.ops.read(hw, (fw_offset +
				 IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR),
				 &fw_ptp_cfg_offset)) {
		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
			      "eeprom read at offset %d failed",
			      fw_offset +
			      IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR);
		return IXGBE_ERR_EEPROM_VERSION;
	}

	if ((fw_ptp_cfg_offset == 0) || (fw_ptp_cfg_offset == 0xFFFF))
		goto fw_version_out;

	/* get the firmware version */
	if (hw->eeprom.ops.read(hw, (fw_ptp_cfg_offset +
			    IXGBE_FW_PATCH_VERSION_4), &fw_version)) {
		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
			      "eeprom read at offset %d failed",
			      fw_ptp_cfg_offset + IXGBE_FW_PATCH_VERSION_4);
		return IXGBE_ERR_EEPROM_VERSION;
	}

	if (fw_version > 0x5)
		status = IXGBE_SUCCESS;

fw_version_out:
	return status;
}

/**
 *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.
 *  @@hw: pointer to hardware structure
 *
 *  Returns TRUE if the LESM FW module is present and enabled. Otherwise
 *  returns FALSE. Smart Speed must be disabled if LESM FW module is enabled.
 **/
bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
{
	bool lesm_enabled = FALSE;
	uint16_t fw_offset, fw_lesm_param_offset, fw_lesm_state;
	int32_t status;

	DEBUGFUNC("ixgbe_verify_lesm_fw_enabled_82599");

	/* get the offset to the Firmware Module block */
	status = hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset);

	if ((status != IXGBE_SUCCESS) ||
	    (fw_offset == 0) || (fw_offset == 0xFFFF))
		goto out;

	/* get the offset to the LESM Parameters block */
	status = hw->eeprom.ops.read(hw, (fw_offset +
				     IXGBE_FW_LESM_PARAMETERS_PTR),
				     &fw_lesm_param_offset);

	if ((status != IXGBE_SUCCESS) ||
	    (fw_lesm_param_offset == 0) || (fw_lesm_param_offset == 0xFFFF))
		goto out;

	/* get the LESM state word */
	status = hw->eeprom.ops.read(hw, (fw_lesm_param_offset +
				     IXGBE_FW_LESM_STATE_1),
				     &fw_lesm_state);

	if ((status == IXGBE_SUCCESS) &&
	    (fw_lesm_state & IXGBE_FW_LESM_STATE_ENABLED))
		lesm_enabled = TRUE;

out:
	return lesm_enabled;
}

/**
 *  ixgbe_read_eeprom_82599 - Read EEPROM word using
 *  fastest available method
 *
 *  @@hw: pointer to hardware structure
 *  @@offset: offset of  word in the EEPROM to read
 *  @@data: word read from the EEPROM
 *
 *  Reads a 16 bit word from the EEPROM
 **/
int32_t ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
				uint16_t offset, uint16_t *data)
{
	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
	int32_t ret_val = IXGBE_ERR_CONFIG;

	DEBUGFUNC("ixgbe_read_eeprom_82599");

	/*
	 * If EEPROM is detected and can be addressed using 14 bits,
	 * use EERD otherwise use bit bang
	 */
	if ((eeprom->type == ixgbe_eeprom_spi) &&
	    (offset <= IXGBE_EERD_MAX_ADDR))
		ret_val = ixgbe_read_eerd_generic(hw, offset, data);
	else
		ret_val = ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);

	return ret_val;
}

/**
 * ixgbe_reset_pipeline_82599 - perform pipeline reset
 *
 *  @@hw: pointer to hardware structure
 *
 * Reset pipeline by asserting Restart_AN together with LMS change to ensure
 * full pipeline reset.  This function assumes the SW/FW lock is held.
 **/
int32_t ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
{
	int32_t ret_val;
	uint32_t anlp1_reg = 0;
	uint32_t i, autoc_reg, autoc2_reg;

	/* Enable link if disabled in NVM */
	autoc2_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
	if (autoc2_reg & IXGBE_AUTOC2_LINK_DISABLE_MASK) {
		autoc2_reg &= ~IXGBE_AUTOC2_LINK_DISABLE_MASK;
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC2, autoc2_reg);
		IXGBE_WRITE_FLUSH(hw);
	}

	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
	/* Write AUTOC register with toggled LMS[2] bit and Restart_AN */
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC,
			autoc_reg ^ (0x4 << IXGBE_AUTOC_LMS_SHIFT));
	/* Wait for AN to leave state 0 */
	for (i = 0; i < 10; i++) {
		msec_delay(4);
		anlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);
		if (anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)
			break;
	}

	if (!(anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)) {
		DEBUGOUT("auto negotiation not completed\n");
		ret_val = IXGBE_ERR_RESET_FAILED;
		goto reset_pipeline_out;
	}

	ret_val = IXGBE_SUCCESS;

reset_pipeline_out:
	/* Write AUTOC register with original LMS field and Restart_AN */
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
	IXGBE_WRITE_FLUSH(hw);

	return ret_val;
}

/**
 *  ixgbe_read_i2c_byte_82599 - Reads 8 bit word over I2C
 *  @@hw: pointer to hardware structure
 *  @@byte_offset: byte offset to read
 *  @@data: value read
 *
 *  Performs byte read operation to SFP module's EEPROM over I2C interface at
 *  a specified device address.
 **/
int32_t ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, uint8_t byte_offset,
				  uint8_t dev_addr, uint8_t *data)
{
	uint32_t esdp;
	int32_t status;
	int32_t timeout = 200;

	DEBUGFUNC("ixgbe_read_i2c_byte_82599");

	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
		/* Acquire I2C bus ownership. */
		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
		esdp |= IXGBE_ESDP_SDP0;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
		IXGBE_WRITE_FLUSH(hw);

		while (timeout) {
			esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
			if (esdp & IXGBE_ESDP_SDP1)
				break;

			msec_delay(5);
			timeout--;
		}

		if (!timeout) {
			DEBUGOUT("Driver can't access resource,"
				 " acquiring I2C bus timeout.\n");
			status = IXGBE_ERR_I2C;
			goto release_i2c_access;
		}
	}

	status = ixgbe_read_i2c_byte_generic(hw, byte_offset, dev_addr, data);

release_i2c_access:

	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
		/* Release I2C bus ownership. */
		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
		esdp &= ~IXGBE_ESDP_SDP0;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
		IXGBE_WRITE_FLUSH(hw);
	}

	return status;
}

/**
 *  ixgbe_write_i2c_byte_82599 - Writes 8 bit word over I2C
 *  @@hw: pointer to hardware structure
 *  @@byte_offset: byte offset to write
 *  @@data: value to write
 *
 *  Performs byte write operation to SFP module's EEPROM over I2C interface at
 *  a specified device address.
 **/
int32_t ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, uint8_t byte_offset,
				   uint8_t dev_addr, uint8_t data)
{
	uint32_t esdp;
	int32_t status;
	int32_t timeout = 200;

	DEBUGFUNC("ixgbe_write_i2c_byte_82599");

	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
		/* Acquire I2C bus ownership. */
		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
		esdp |= IXGBE_ESDP_SDP0;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
		IXGBE_WRITE_FLUSH(hw);

		while (timeout) {
			esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
			if (esdp & IXGBE_ESDP_SDP1)
				break;

			msec_delay(5);
			timeout--;
		}

		if (!timeout) {
			DEBUGOUT("Driver can't access resource,"
				 " acquiring I2C bus timeout.\n");
			status = IXGBE_ERR_I2C;
			goto release_i2c_access;
		}
	}

	status = ixgbe_write_i2c_byte_generic(hw, byte_offset, dev_addr, data);

release_i2c_access:

	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
		/* Release I2C bus ownership. */
		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
		esdp &= ~IXGBE_ESDP_SDP0;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
		IXGBE_WRITE_FLUSH(hw);
	}

	return status;
}
@


1.15
log
@Bring in new PHY bits, some of the 82599 specific stuff becomes shared
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.14 2016/11/17 12:21:27 mikeb Exp $	*/
d76 2
a210 1
	bool got_lock = FALSE;
d243 3
a245 1
		/* Delay obtaining semaphore again to allow FW access */
a247 15
		/* Need SW/FW semaphore around AUTOC writes if LESM on,
		 * likewise reset_pipeline requires lock as it also writes
		 * AUTOC.
		 */
		if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
			ret_val = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
			if (ret_val != IXGBE_SUCCESS) {
				ret_val = IXGBE_ERR_SWFW_SYNC;
				goto setup_sfp_out;
			}

			got_lock = TRUE;
		}

d249 3
a251 10
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, ((hw->mac.orig_autoc) |
				IXGBE_AUTOC_LMS_10G_SERIAL));
		hw->mac.cached_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
		ret_val = ixgbe_reset_pipeline_82599(hw);

		if (got_lock) {
			hw->mac.ops.release_swfw_sync(hw,
						      IXGBE_GSSR_MAC_CSR_SM);
			got_lock = FALSE;
		}
d275 74
d384 3
a397 3
	mac->ops.verify_lesm_fw_enabled = ixgbe_verify_lesm_fw_enabled_82599;
	mac->ops.stop_mac_link_on_d3 = ixgbe_stop_mac_link_on_d3_82599;

d907 7
a913 1
	uint32_t autoc, pma_pmd_1g, link_mode, start_autoc;
a914 1
	uint32_t orig_autoc = 0;
a918 1
	bool got_lock = FALSE;
d937 1
a937 1
		autoc = hw->mac.orig_autoc;
d939 1
a939 1
		autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
a940 2
	orig_autoc = autoc;
	start_autoc = hw->mac.cached_autoc;
d980 1
a980 16
	if (autoc != start_autoc) {
		/* Need SW/FW semaphore around AUTOC writes if LESM is on,
		 * likewise reset_pipeline requires us to hold this lock as
		 * it also writes to AUTOC.
		 */
		if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
			status = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
			if (status != IXGBE_SUCCESS) {
				status = IXGBE_ERR_SWFW_SYNC;
				goto out;
			}

			got_lock = TRUE;
		}

d982 3
a984 9
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
		hw->mac.cached_autoc = autoc;
		ixgbe_reset_pipeline_82599(hw);

		if (got_lock) {
			hw->mac.ops.release_swfw_sync(hw,
						      IXGBE_GSSR_MAC_CSR_SM);
			got_lock = FALSE;
		}
d1052 2
a1053 1
	uint32_t ctrl, i, autoc2;
d1089 1
a1089 5
	if (hw->mac.cached_autoc)
		curr_lms = hw->mac.cached_autoc & IXGBE_AUTOC_LMS_MASK;
	else
		curr_lms = IXGBE_READ_REG(hw, IXGBE_AUTOC) &
					  IXGBE_AUTOC_LMS_MASK;
d1139 1
a1139 1
	hw->mac.cached_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d1150 1
a1150 1
		hw->mac.orig_autoc = hw->mac.cached_autoc;
d1166 6
a1171 24
		if (hw->mac.cached_autoc != hw->mac.orig_autoc) {
			/* Need SW/FW semaphore around AUTOC writes if LESM is
			 * on, likewise reset_pipeline requires us to hold
			 * this lock as it also writes to AUTOC.
			 */
			bool got_lock = FALSE;
			if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
				status = hw->mac.ops.acquire_swfw_sync(hw,
							IXGBE_GSSR_MAC_CSR_SM);
				if (status != IXGBE_SUCCESS) {
					status = IXGBE_ERR_SWFW_SYNC;
					goto reset_hw_out;
				}

				got_lock = TRUE;
			}

			IXGBE_WRITE_REG(hw, IXGBE_AUTOC, hw->mac.orig_autoc);
			hw->mac.cached_autoc = hw->mac.orig_autoc;
			ixgbe_reset_pipeline_82599(hw);

			if (got_lock)
				hw->mac.ops.release_swfw_sync(hw,
						      IXGBE_GSSR_MAC_CSR_SM);
d1593 1
a1593 1
	autoc_reg = hw->mac.cached_autoc;
d1596 2
a1597 1
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg ^ IXGBE_AUTOC_LMS_1G_AN);
@


1.14
log
@Style and typo fixes; no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.13 2016/11/16 23:19:29 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2013, Intel Corporation
d35 1
a35 1
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_82599.c 251964 Jun 18 21:28:19 2013 UTC */
d54 2
a55 5
void ixgbe_set_fiber_fixed_speed(struct ixgbe_hw *hw,
				 ixgbe_link_speed speed);
int32_t ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
					      ixgbe_link_speed speed,
					      bool autoneg_wait_to_complete);
d57 2
a58 2
				     ixgbe_link_speed speed,
				     bool autoneg_wait_to_complete);
a60 1
void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);
d62 2
a63 5
				     ixgbe_link_speed speed,
				     bool autoneg_wait_to_complete);
int32_t ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed,
				      bool autoneg_wait_to_complete);
d76 7
d85 1
d88 4
a91 22
int32_t ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);
int32_t ixgbe_blink_led_start_82599(struct ixgbe_hw *hw, uint32_t index);
int32_t ixgbe_blink_led_stop_82599(struct ixgbe_hw *hw, uint32_t index);

static bool ixgbe_mng_enabled(struct ixgbe_hw *hw)
{
	uint32_t fwsm, manc, factps;

	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM);
	if ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)
		return FALSE;

	manc = IXGBE_READ_REG(hw, IXGBE_MANC);
	if (!(manc & IXGBE_MANC_RCV_TCO_EN))
		return FALSE;

	factps = IXGBE_READ_REG(hw, IXGBE_FACTPS);
	if (factps & IXGBE_FACTPS_MNGCG)
		return FALSE;

	return TRUE;
}
d104 1
a104 1
	    !hw->mng_fw_enabled) {
d120 6
d152 1
d156 17
d310 1
a310 1
	ixgbe_init_phy_ops_generic(hw);
a340 1
	mac->ops.reset_pipeline = ixgbe_reset_pipeline_82599;
d346 1
d353 1
a354 1
	mac->max_rx_queues	= IXGBE_82599_MAX_RX_QUEUES;
a361 3
	/* Cache if MNG FW is up */
	hw->mng_fw_enabled = ixgbe_mng_enabled(hw);

d462 8
a469 1
		*autoneg = TRUE;
d522 3
d552 2
a553 1
	if (!hw->mng_fw_enabled && ee_ctrl_2 & IXGBE_EEPROM_CCD_BIT) {
d640 4
d686 4
d698 1
a698 1
 *  ixgbe_set_fiber_fixed_speed - Set module link speed for fixed fiber
d702 1
a702 3
 *  We set the module speed differently for fixed fiber.  For other
 *  multi-speed devices we don't have an error value so here if we
 *  detect an error we just log it and exit.
d704 2
a705 2
void ixgbe_set_fiber_fixed_speed(struct ixgbe_hw *hw,
				 ixgbe_link_speed speed)
d707 1
a707 2
	int32_t status;
	uint8_t rs, eeprom_data;
d711 1
a711 2
		/* one bit mask same as setting on */
		rs = IXGBE_SFF_SOFT_RS_SELECT_10G;
d714 2
a715 1
		rs = IXGBE_SFF_SOFT_RS_SELECT_1G;
d722 2
a723 196
	/* Set RS0 */
	status = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,
					   IXGBE_I2C_EEPROM_DEV_ADDR2,
					   &eeprom_data);
	if (status) {
		DEBUGOUT("Failed to read Rx Rate Select RS0\n");
		goto out;
	}

	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) & rs;

	status = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_OSCB,
					    IXGBE_I2C_EEPROM_DEV_ADDR2,
					    eeprom_data);
	if (status) {
		DEBUGOUT("Failed to write Rx Rate Select RS0\n");
		goto out;
	}

	/* Set RS1 */
	status = hw->phy.ops.read_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,
					   IXGBE_I2C_EEPROM_DEV_ADDR2,
					   &eeprom_data);
	if (status) {
		DEBUGOUT("Failed to read Rx Rate Select RS1\n");
		goto out;
	}

	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) & rs;

	status = hw->phy.ops.write_i2c_byte(hw, IXGBE_SFF_SFF_8472_ESCB,
					    IXGBE_I2C_EEPROM_DEV_ADDR2,
					    eeprom_data);
	if (status) {
		DEBUGOUT("Failed to write Rx Rate Select RS1\n");
		goto out;
	}
out:
	return;
}

/**
 *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
 *  @@hw: pointer to hardware structure
 *  @@speed: new link speed
 *  @@autoneg_wait_to_complete: TRUE when waiting for completion is needed
 *
 *  Set the link speed in the AUTOC register and restarts link.
 **/
int32_t ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
				     ixgbe_link_speed speed,
				     bool autoneg_wait_to_complete)
{
	int32_t status = IXGBE_SUCCESS;
	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
	ixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;
	uint32_t speedcnt = 0;
	uint32_t esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);
	uint32_t i = 0;
	bool autoneg, link_up = FALSE;

	DEBUGFUNC("ixgbe_setup_mac_link_multispeed_fiber");

	/* Mask off requested but non-supported speeds */
	status = ixgbe_get_link_capabilities_82599(hw, &link_speed, &autoneg);
	if (status != IXGBE_SUCCESS)
		return status;

	speed &= link_speed;

	/*
	 * Try each speed one by one, highest priority first.  We do this in
	 * software because 10gb fiber doesn't support speed autonegotiation.
	 */
	if (speed & IXGBE_LINK_SPEED_10GB_FULL) {
		speedcnt++;
		highest_link_speed = IXGBE_LINK_SPEED_10GB_FULL;

		/* If we already have link at this speed, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if ((link_speed == IXGBE_LINK_SPEED_10GB_FULL) && link_up)
			goto out;

		/* Set the module link speed */
		if (hw->phy.media_type == ixgbe_media_type_fiber_fixed) {
			ixgbe_set_fiber_fixed_speed(hw,
						    IXGBE_LINK_SPEED_10GB_FULL);
		} else {
			esdp_reg |= (IXGBE_ESDP_SDP5_DIR | IXGBE_ESDP_SDP5);
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			IXGBE_WRITE_FLUSH(hw);
		}

		/* Allow module to change analog characteristics (1G->10G) */
		msec_delay(40);

		status = ixgbe_setup_mac_link_82599(hw,
						    IXGBE_LINK_SPEED_10GB_FULL,
						    autoneg_wait_to_complete);
		if (status != IXGBE_SUCCESS)
			return status;

		/* Flap the tx laser if it has not already been done */
		ixgbe_flap_tx_laser(hw);

		/*
		 * Wait for the controller to acquire link.  Per IEEE 802.3ap,
		 * Section 73.10.2, we may have to wait up to 500ms if KR is
		 * attempted.  82599 uses the same timing for 10g SFI.
		 */
		for (i = 0; i < 5; i++) {
			/* Wait for the link partner to also set speed */
			msec_delay(100);

			/* If we have link, just jump out */
			status = ixgbe_check_link(hw, &link_speed,
						  &link_up, FALSE);
			if (status != IXGBE_SUCCESS)
				return status;

			if (link_up)
				goto out;
		}
	}

	if (speed & IXGBE_LINK_SPEED_1GB_FULL) {
		speedcnt++;
		if (highest_link_speed == IXGBE_LINK_SPEED_UNKNOWN)
			highest_link_speed = IXGBE_LINK_SPEED_1GB_FULL;

		/* If we already have link at this speed, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if ((link_speed == IXGBE_LINK_SPEED_1GB_FULL) && link_up)
			goto out;

		/* Set the module link speed */
		if (hw->phy.media_type == ixgbe_media_type_fiber_fixed) {
			ixgbe_set_fiber_fixed_speed(hw,
						    IXGBE_LINK_SPEED_1GB_FULL);
		} else {
			esdp_reg &= ~IXGBE_ESDP_SDP5;
			esdp_reg |= IXGBE_ESDP_SDP5_DIR;
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			IXGBE_WRITE_FLUSH(hw);
		}

		/* Allow module to change analog characteristics (10G->1G) */
		msec_delay(40);

		status = ixgbe_setup_mac_link_82599(hw,
						    IXGBE_LINK_SPEED_1GB_FULL,
						    autoneg_wait_to_complete);
		if (status != IXGBE_SUCCESS)
			return status;

		/* Flap the tx laser if it has not already been done */
		ixgbe_flap_tx_laser(hw);

		/* Wait for the link partner to also set speed */
		msec_delay(100);

		/* If we have link, just jump out */
		status = ixgbe_check_link(hw, &link_speed, &link_up, FALSE);
		if (status != IXGBE_SUCCESS)
			return status;

		if (link_up)
			goto out;
	}

	/*
	 * We didn't get link.  Configure back to the highest speed we tried,
	 * (if there was more than one).  We call ourselves back with just the
	 * single highest speed that the user requested.
	 */
	if (speedcnt > 1)
		status = ixgbe_setup_mac_link_multispeed_fiber(hw,
			highest_link_speed, autoneg_wait_to_complete);

out:
	/* Set autoneg_advertised value based on input link speed */
	hw->phy.autoneg_advertised = 0;

	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10GB_FULL;

	if (speed & IXGBE_LINK_SPEED_1GB_FULL)
		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_1GB_FULL;

	return status;
d864 2
a865 1
	status = ixgbe_get_link_capabilities_82599(hw, &link_capabilities, &autoneg);
d916 1
a916 1
			if (autoneg)
d1128 1
a1128 1
		if (hw->phy.multispeed_fiber && hw->mng_fw_enabled)
d1272 1
a1272 1
	int32_t status = IXGBE_ERR_PHY_ADDR_INVALID;
d1281 1
a1281 1
			goto out;
d1289 1
a1289 1
		status = IXGBE_SUCCESS;
d1294 1
a1294 1
		status = IXGBE_ERR_SFP_NOT_SUPPORTED;
a1295 1
out:
a1313 2
	uint8_t comp_codes_10g = 0;
	uint8_t comp_codes_1g = 0;
d1381 1
a1381 41
	hw->phy.ops.identify_sfp(hw);
	if (hw->phy.sfp_type == ixgbe_sfp_type_not_present)
		goto out;

	switch (hw->phy.type) {
	case ixgbe_phy_sfp_passive_tyco:
	case ixgbe_phy_sfp_passive_unknown:
		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
		break;
	case ixgbe_phy_sfp_ftl_active:
	case ixgbe_phy_sfp_active_unknown:
		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA;
		break;
	case ixgbe_phy_sfp_avago:
	case ixgbe_phy_sfp_ftl:
	case ixgbe_phy_sfp_intel:
	case ixgbe_phy_sfp_unknown:
		hw->phy.ops.read_i2c_eeprom(hw,
		      IXGBE_SFF_1GBE_COMP_CODES, &comp_codes_1g);
		hw->phy.ops.read_i2c_eeprom(hw,
		      IXGBE_SFF_10GBE_COMP_CODES, &comp_codes_10g);
		if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
		else if (comp_codes_10g &
		    (IXGBE_SFF_DA_PASSIVE_CABLE | IXGBE_SFF_DA_BAD_HP_CABLE))
			physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
		else if (comp_codes_10g & IXGBE_SFF_DA_ACTIVE_CABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA;
		else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_T;
		else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_SX;
		else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE)
			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_LX;
		break;
	default:
		break;
	}

d1407 4
a1410 1
	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, regval);
d1604 114
@


1.13
log
@Remove unused bits; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.12 2015/04/30 14:17:26 jsg Exp $	*/
d40 7
d123 1
a123 1
				       &ixgbe_disable_tx_laser_multispeed_fiber;
d125 2
a126 2
					&ixgbe_enable_tx_laser_multispeed_fiber;
		mac->ops.flap_tx_laser = &ixgbe_flap_tx_laser_multispeed_fiber;
d136 1
a136 1
		mac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;
d142 1
a142 1
			mac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;
d144 1
a144 1
			mac->ops.setup_link = &ixgbe_setup_mac_link_82599;
d178 1
a178 1
		mac->ops.setup_link = &ixgbe_setup_copper_link_82599;
d180 1
a180 1
				  &ixgbe_get_copper_link_capabilities_generic;
d183 1
a183 1
	/* Set necessary function pointers based on phy type */
d186 2
a187 2
		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
d189 1
a189 1
			     &ixgbe_get_phy_firmware_version_tnx;
d307 2
a308 2
	phy->ops.identify = &ixgbe_identify_phy_82599;
	phy->ops.init = &ixgbe_init_phy_ops_82599;
d311 2
a312 2
	mac->ops.reset_hw = &ixgbe_reset_hw_82599;
	mac->ops.get_media_type = &ixgbe_get_media_type_82599;
d314 7
a320 7
				    &ixgbe_get_supported_physical_layer_82599;
	mac->ops.disable_sec_rx_path = &ixgbe_disable_sec_rx_path_generic;
	mac->ops.enable_sec_rx_path = &ixgbe_enable_sec_rx_path_generic;
	mac->ops.enable_rx_dma = &ixgbe_enable_rx_dma_82599;
	mac->ops.read_analog_reg8 = &ixgbe_read_analog_reg8_82599;
	mac->ops.write_analog_reg8 = &ixgbe_write_analog_reg8_82599;
	mac->ops.start_hw = &ixgbe_start_hw_82599;
d323 3
a325 3
	mac->ops.set_vmdq = &ixgbe_set_vmdq_generic;
	mac->ops.clear_vmdq = &ixgbe_clear_vmdq_generic;
	mac->ops.insert_mac_addr = &ixgbe_insert_mac_addr_generic;
d327 9
a335 9
	mac->ops.set_vfta = &ixgbe_set_vfta_generic;
	mac->ops.set_vlvf = &ixgbe_set_vlvf_generic;
	mac->ops.clear_vfta = &ixgbe_clear_vfta_generic;
	mac->ops.init_uta_tables = &ixgbe_init_uta_tables_generic;
	mac->ops.setup_sfp = &ixgbe_setup_sfp_modules_82599;

	mac->ops.verify_lesm_fw_enabled = &ixgbe_verify_lesm_fw_enabled_82599;
	mac->ops.reset_pipeline = &ixgbe_reset_pipeline_82599;
	mac->ops.stop_mac_link_on_d3 = &ixgbe_stop_mac_link_on_d3_82599;
d338 2
a339 2
	mac->ops.get_link_capabilities = &ixgbe_get_link_capabilities_82599;
	mac->ops.check_link = &ixgbe_check_mac_link_generic;
d342 6
a347 6
	mac->mcft_size		= 128;
	mac->vft_size		= 128;
	mac->num_rar_entries	= 128;
	mac->rx_pb_size		= 512;
	mac->max_tx_queues	= 128;
	mac->max_rx_queues	= 128;
d353 1
a353 1
	eeprom->ops.read = &ixgbe_read_eeprom_82599;
d625 1
a625 1
	/* Disable tx laser; allow 100us to go dark per spec */
d644 1
a644 1
	/* Enable tx laser; allow 100ms to light up */
d658 1
a658 1
 *  so, we set the speed then disable and re-enable the tx laser, to
d909 2
a910 2
				     ixgbe_link_speed speed,
				     bool autoneg_wait_to_complete)
d1249 1
a1249 1
	/* Poll for reset bit to self-clear indicating reset is complete */
d1266 2
a1267 2
	 * conditions.  Between resets, it is necessary to stall to allow time
	 * for any pending HW events to complete.
d1631 1
a1631 1
 *  ixgbe_verify_fw_version_82599 - verify fw version for 82599
d1725 1
a1725 1
	/* get the lesm state word */
d1775 1
a1775 1
 * full pipeline reset
@


1.12
log
@Set the correct media type for 1000baseLX SFPs.
Tested by/ok sthen@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.11 2015/04/30 13:24:36 sthen Exp $	*/
a304 1
	mac->ops.enable_relaxed_ordering = &ixgbe_enable_relaxed_ordering_gen2;
@


1.11
log
@Allow use of 1Gb 1000baseLX SFPs in 82599 ix(4) SFP+ port. Adapted from
Linux commit 345be204dcbb. ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.10 2013/08/05 19:58:06 mikeb Exp $	*/
d1585 2
@


1.10
log
@First stab at updating this monster to the Intel/FreeBSD current version.
This syncs PHY and chip dependent parts as well as brings support for the
flow control and additional (untested) bits for 1G fiber versions.

Tested by Hrvoje Popovski <hrvoje at srce ! hr> on 82599/SFP+DA, florian@@
and benno@@ on 82599/SFP+SR and on 82598/CX4-BP, 82599/SFP+DA and X540/RJ45
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.9 2012/12/17 12:28:06 mikeb Exp $	*/
d375 2
@


1.9
log
@Implement SFP+ module hot-plug support for 82599 obtained
from FreeBSD.  This also adds untested and hence disabled
support for multispeed fiber interrupts.  With input from
and ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.8 2012/11/10 13:00:47 mikeb Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation
d35 1
a35 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_82599.c,v 1.3 2009/12/07 21:30:54 jfv Exp $*/
a39 1
int32_t ixgbe_init_ops_82599(struct ixgbe_hw *hw);
d41 2
a42 2
				      ixgbe_link_speed *speed,
				      int *autoneg);
d47 2
d50 2
a51 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete);
d53 2
a54 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete);
d56 2
a57 1
				int autoneg_wait_to_complete);
d60 1
a60 2
				     int autoneg,
				     int autoneg_wait_to_complete);
d62 2
a63 3
					       ixgbe_link_speed speed,
					       int autoneg,
					       int autoneg_wait_to_complete);
d67 4
a70 2
int32_t ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val);
int32_t ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg, uint8_t val);
d77 25
a101 1
int ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
d109 6
a114 2
	/* enable the laser control functions for SFP+ fiber */
	if (mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) {
d131 1
a131 1
		if ((ixgbe_hw0(hw, get_media_type) == ixgbe_media_type_backplane) &&
a193 2
	uint32_t reg_anlp1 = 0;
	uint32_t i = 0;
d195 1
d217 2
a218 1
		hw->eeprom.ops.read(hw, ++data_offset, &data_value);
d222 2
a223 1
			hw->eeprom.ops.read(hw, ++data_offset, &data_value);
d231 13
a243 11
		/* Now restart DSP by setting Restart_AN and clearing LMS */
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, ((IXGBE_READ_REG(hw,
				IXGBE_AUTOC) & ~IXGBE_AUTOC_LMS_MASK) |
				IXGBE_AUTOC_AN_RESTART));

		/* Wait for AN to leave state 0 */
		for (i = 0; i < 10; i++) {
			msec_delay(4);
			reg_anlp1 = IXGBE_READ_REG(hw, IXGBE_ANLP1);
			if (reg_anlp1 & IXGBE_ANLP1_AN_STATE_MASK)
				break;
d245 14
a258 1
		if (!(reg_anlp1 & IXGBE_ANLP1_AN_STATE_MASK)) {
a263 4
		/* Restart DSP by setting Restart_AN and return to SFI mode */
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, (IXGBE_READ_REG(hw,
				IXGBE_AUTOC) | IXGBE_AUTOC_LMS_10G_SERIAL |
				IXGBE_AUTOC_AN_RESTART));
d268 9
d291 1
d296 1
a296 1
	ret_val = ixgbe_init_phy_ops_generic(hw);
d309 2
a315 8
	mac->ops.get_device_caps = &ixgbe_get_device_caps_generic;
#if 0
	mac->ops.get_san_mac_addr = &ixgbe_get_san_mac_addr_generic;
	mac->ops.set_san_mac_addr = &ixgbe_set_san_mac_addr_generic;
	mac->ops.get_wwn_prefix = &ixgbe_get_wwn_prefix_generic;
	mac->ops.get_fcoe_boot_status = &ixgbe_get_fcoe_boot_status_generic;
#endif

d322 1
d326 4
a329 4
#if 0
	mac->ops.set_mac_anti_spoofing = &ixgbe_set_mac_anti_spoofing;
	mac->ops.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing;
#endif
d336 7
a342 7
	mac->mcft_size        = 128;
	mac->vft_size         = 128;
	mac->num_rar_entries  = 128;
	mac->rx_pb_size       = 512;
	mac->max_tx_queues    = 128;
	mac->max_rx_queues    = 128;
	mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
d346 6
d359 1
a359 1
 *  @@negotiation: TRUE when autoneg or autotry is enabled
d365 1
a365 1
				      int *negotiation)
d374 3
a376 1
	    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1) {
d378 1
a378 1
		*negotiation = TRUE;
d395 1
a395 1
		*negotiation = FALSE;
d400 1
a400 1
		*negotiation = FALSE;
d405 1
a405 1
		*negotiation = TRUE;
d410 1
a410 1
		*negotiation = FALSE;
d422 1
a422 1
		*negotiation = TRUE;
d433 1
a433 1
		*negotiation = TRUE;
d438 1
a438 1
		*negotiation = FALSE;
d450 1
a450 1
		*negotiation = TRUE;
d493 1
d503 4
d516 22
d546 1
a546 1
			       int autoneg_wait_to_complete)
d552 1
d557 12
d570 4
a573 3
	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc_reg);
d577 1
d601 1
d667 69
a738 1
 *  @@autoneg: TRUE if autonegotiation enabled
d744 2
a745 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete)
d748 1
a748 1
	ixgbe_link_speed link_speed;
d753 1
a753 2
	int link_up = FALSE;
	int negotiation;
d758 1
a758 1
	status = ixgbe_hw(hw, get_link_capabilities, &link_speed, &negotiation);
d773 1
a773 1
		status = ixgbe_hw(hw, check_link, &link_speed, &link_up, FALSE);
d781 8
a788 3
		esdp_reg |= (IXGBE_ESDP_SDP5_DIR | IXGBE_ESDP_SDP5);
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
		IXGBE_WRITE_FLUSH(hw);
d794 2
a795 3
						IXGBE_LINK_SPEED_10GB_FULL,
						autoneg,
						autoneg_wait_to_complete);
d800 1
a800 1
		ixgbe_hw(hw, flap_tx_laser);
d812 1
a812 1
			status = ixgbe_hw(hw, check_link, &link_speed,
d828 1
a828 1
		status = ixgbe_hw(hw, check_link, &link_speed, &link_up, FALSE);
d836 9
a844 4
		esdp_reg &= ~IXGBE_ESDP_SDP5;
		esdp_reg |= IXGBE_ESDP_SDP5_DIR;
		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
		IXGBE_WRITE_FLUSH(hw);
a850 1
						    autoneg,
d856 1
a856 1
		ixgbe_hw(hw, flap_tx_laser);
d862 1
a862 1
		status = ixgbe_hw(hw, check_link, &link_speed, &link_up, FALSE);
d877 1
a877 1
			highest_link_speed, autoneg, autoneg_wait_to_complete);
a895 1
 *  @@autoneg: TRUE if autonegotiation enabled
d901 2
a902 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete)
d905 1
a905 1
	ixgbe_link_speed link_speed;
d907 1
a907 1
	int link_up = FALSE;
d934 1
a934 1
		status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
d949 1
a949 1
			status = ixgbe_hw(hw, check_link, &link_speed, &link_up,
d969 1
a969 1
	status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
d984 1
a984 1
		status = ixgbe_hw(hw, check_link, &link_speed, &link_up, FALSE);
d994 1
a994 1
	status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
a1007 1
 *  @@autoneg: TRUE if autonegotiation enabled
d1013 2
a1014 2
				     ixgbe_link_speed speed, int autoneg,
				     int autoneg_wait_to_complete)
d1016 1
d1018 1
a1018 1
	uint32_t autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
a1019 1
	uint32_t start_autoc = autoc;
a1020 2
	uint32_t link_mode = autoc & IXGBE_AUTOC_LMS_MASK;
	uint32_t pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
d1025 1
d1030 2
a1031 2
	status = ixgbe_hw(hw, get_link_capabilities, &link_capabilities, &autoneg);
	if (status != IXGBE_SUCCESS)
d1043 1
a1043 1
		orig_autoc = hw->mac.orig_autoc;
d1045 6
a1050 1
		orig_autoc = autoc;
d1067 2
a1068 2
		 (link_mode == IXGBE_AUTOC_LMS_1G_LINK_NO_AN ||
		  link_mode == IXGBE_AUTOC_LMS_1G_AN)) {
d1089 15
a1104 1
		autoc |= IXGBE_AUTOC_AN_RESTART;
d1106 8
a1147 1
 *  @@autoneg: TRUE if autonegotiation enabled
d1153 2
a1154 3
					       ixgbe_link_speed speed,
					       int autoneg,
					       int autoneg_wait_to_complete)
d1161 1
a1161 1
	status = hw->phy.ops.setup_link_speed(hw, speed, autoneg,
d1168 1
d1179 5
a1183 5
	int32_t status = IXGBE_SUCCESS;
	uint32_t ctrl;
	uint32_t i;
	uint32_t autoc;
	uint32_t autoc2;
d1188 6
a1193 1
	hw->mac.ops.stop_adapter(hw);
d1216 6
a1221 5
	/*
	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master
	 * access and verify no pending requests before reset
	 */
	ixgbe_disable_pcie_master(hw);
d1225 4
a1228 2
	 * Issue global reset to the MAC.  This needs to be a SW reset.
	 * If link reset is used, it might reset the MAC when mng is using it
d1230 9
a1238 2
	ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
	IXGBE_WRITE_REG(hw, IXGBE_CTRL, (ctrl | IXGBE_CTRL_RST));
d1245 1
a1245 1
		if (!(ctrl & IXGBE_CTRL_RST))
d1248 2
a1249 1
	if (ctrl & IXGBE_CTRL_RST) {
d1271 1
a1271 1
	autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
d1273 8
d1282 1
a1282 1
		hw->mac.orig_autoc = autoc;
d1286 37
a1322 3
		if (autoc != hw->mac.orig_autoc)
			IXGBE_WRITE_REG(hw, IXGBE_AUTOC, (hw->mac.orig_autoc |
					IXGBE_AUTOC_AN_RESTART));
a1343 20
#if 0
	/* Store the permanent SAN mac address */
	hw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);

	/* Add the SAN MAC address to the RAR only if it's a valid address */
	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
		hw->mac.ops.set_rar(hw, hw->mac.num_rar_entries - 1,
				    hw->mac.san_addr, 0, IXGBE_RAH_AV);

		/* Save the SAN MAC RAR index */
		hw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;

		/* Reserve the last RAR for the SAN MAC address */
		hw->mac.num_rar_entries--;
	}

	/* Store the alternative WWNN/WWPN prefix */
	hw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,
				       &hw->mac.wwpn_prefix);
#endif
d1356 2
a1357 1
int32_t ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val)
d1381 2
a1382 1
int32_t ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, uint32_t reg, uint8_t val)
a1406 1
	uint32_t gcr = IXGBE_READ_REG(hw, IXGBE_GCR);
d1408 1
a1408 1
	DEBUGFUNC("ixgbe_start_hw_rev_1__82599");
a1420 14
	/*
	 * From the 82599 specification update:
	 * set the completion timeout value for 16ms to 55ms if needed
	 */
	if (gcr & IXGBE_GCR_CAP_VER2) {
		uint16_t reg;
		reg = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2);
		if ((reg & 0x0f) == 0) {
			reg |= IXGBE_PCI_DEVICE_CONTROL2_16ms;
			IXGBE_WRITE_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2,
			    reg);
		}
	}

d1448 1
a1448 1
			status = ixgbe_identify_sfp_module_generic(hw);
d1581 2
a1600 3
#define IXGBE_MAX_SECRX_POLL 30
	int i;
	int secrxreg;
a1609 11
	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
	secrxreg |= IXGBE_SECRXCTRL_RX_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
	for (i = 0; i < IXGBE_MAX_SECRX_POLL; i++) {
		secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);
		if (secrxreg & IXGBE_SECRXSTAT_SECRX_RDY)
			break;
		else
			/* Use interrupt-safe sleep just in case */
			usec_delay(1000);
	}
d1611 1
a1611 4
	/* For informational purposes only */
	if (i >= IXGBE_MAX_SECRX_POLL)
		DEBUGOUT("Rx unit being enabled before security "
			 "path fully disabled.  Continuing with init.\n");
d1614 2
a1615 4
	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
	secrxreg &= ~IXGBE_SECRXCTRL_RX_DIS;
	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
	IXGBE_WRITE_FLUSH(hw);
d1634 1
a1634 1
	uint16_t fw_version = 0;
d1645 5
a1649 1
	hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset);
d1655 1
a1655 1
	hw->eeprom.ops.read(hw, (fw_offset +
d1657 7
a1663 1
				 &fw_ptp_cfg_offset);
d1669 7
a1675 3
	hw->eeprom.ops.read(hw, (fw_ptp_cfg_offset +
				 IXGBE_FW_PATCH_VERSION_4),
				 &fw_version);
d1691 1
a1691 1
int ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
d1693 1
a1693 1
	int lesm_enabled = FALSE;
d1708 2
a1709 2
				 IXGBE_FW_LESM_PARAMETERS_PTR),
				 &fw_lesm_param_offset);
d1726 81
@


1.8
log
@sync some 82599 bits with freebsd driver; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.7 2012/11/06 17:29:39 mikeb Exp $	*/
d1353 5
@


1.7
log
@Remove Flow Director code that is not used, is outdated and tends
to get in the way.  ok krw, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.6 2012/08/11 06:53:31 mikeb Exp $	*/
d69 1
a69 1
int32_t ixgbe_start_hw_rev_1_82599(struct ixgbe_hw *hw);
a153 4
	case ixgbe_phy_aq:
		phy->ops.get_firmware_version =
			     &ixgbe_get_phy_firmware_version_generic;
		break;
d260 1
a260 1
	mac->ops.start_hw = &ixgbe_start_hw_rev_1_82599;
d286 1
a286 1
	mac->ops.check_link            = &ixgbe_check_mac_link_generic;
a417 1
	case ixgbe_phy_aq:
d428 1
d436 1
d438 1
d458 1
d882 1
a882 1
		if (speed & IXGBE_LINK_SPEED_10GB_FULL)
d888 1
d1042 2
d1047 1
a1047 3
	 * for any pending HW events to complete.  We use 1usec since that is
	 * what is needed for ixgbe_disable_pcie_master().  The second reset
	 * then clears out any effects of those events.
a1050 1
		usec_delay(1);
a1053 2
	msec_delay(50);

d1099 3
d1161 1
a1161 1
 *  ixgbe_start_hw_rev_1_82599 - Prepare hardware for Tx/Rx
d1168 1
a1168 1
int32_t ixgbe_start_hw_rev_1_82599(struct ixgbe_hw *hw)
a1267 1
	case ixgbe_phy_aq:
d1394 1
a1394 1
			usec_delay(10);
@


1.6
log
@Add support for another 82599 SFP+ card.  Original diff and tests by
Chris Maxwell <chris ! maxwell () hootsuite.com>
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.5 2012/08/06 21:07:52 mikeb Exp $	*/
a76 8
uint32_t ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
					    union ixgbe_atr_hash_dword common);
int32_t ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
					  union ixgbe_atr_hash_dword input,
					  union ixgbe_atr_hash_dword common,
					  uint8_t queue);
uint32_t ixgbe_get_fdirtcpm_82599(struct ixgbe_atr_input_masks *input_masks);

a1111 680
}

/**
 *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.
 *  @@hw: pointer to hardware structure
 **/
int32_t ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
{
	int i;
	uint32_t fdirctrl = IXGBE_READ_REG(hw, IXGBE_FDIRCTRL);
	fdirctrl &= ~IXGBE_FDIRCTRL_INIT_DONE;

	DEBUGFUNC("ixgbe_reinit_fdir_tables_82599");

	/*
	 * Before starting reinitialization process,
	 * FDIRCMD.CMD must be zero.
	 */
	for (i = 0; i < IXGBE_FDIRCMD_CMD_POLL; i++) {
		if (!(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &
		      IXGBE_FDIRCMD_CMD_MASK))
			break;
		usec_delay(10);
	}
	if (i >= IXGBE_FDIRCMD_CMD_POLL) {
		DEBUGOUT("Flow Director previous command isn't complete, "
			 "aborting table re-initialization. \n");
		return IXGBE_ERR_FDIR_REINIT_FAILED;
	}

	IXGBE_WRITE_REG(hw, IXGBE_FDIRFREE, 0);
	IXGBE_WRITE_FLUSH(hw);
	/*
	 * 82599 adapters flow director init flow cannot be restarted,
	 * Workaround 82599 silicon errata by performing the following steps
	 * before re-writing the FDIRCTRL control register with the same value.
	 * - write 1 to bit 8 of FDIRCMD register &
	 * - write 0 to bit 8 of FDIRCMD register
	 */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,
			(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) |
			 IXGBE_FDIRCMD_CLEARHT));
	IXGBE_WRITE_FLUSH(hw);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,
			(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &
			 ~IXGBE_FDIRCMD_CLEARHT));
	IXGBE_WRITE_FLUSH(hw);
	/*
	 * Clear FDIR Hash register to clear any leftover hashes
	 * waiting to be programmed.
	 */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, 0x00);
	IXGBE_WRITE_FLUSH(hw);

	IXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);
	IXGBE_WRITE_FLUSH(hw);

	/* Poll init-done after we write FDIRCTRL register */
	for (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {
		if (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &
				   IXGBE_FDIRCTRL_INIT_DONE)
			break;
		usec_delay(10);
	}
	if (i >= IXGBE_FDIR_INIT_DONE_POLL) {
		DEBUGOUT("Flow Director Signature poll time exceeded!\n");
		return IXGBE_ERR_FDIR_REINIT_FAILED;
	}

	/* Clear FDIR statistics registers (read to clear) */
	IXGBE_READ_REG(hw, IXGBE_FDIRUSTAT);
	IXGBE_READ_REG(hw, IXGBE_FDIRFSTAT);
	IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
	IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
	IXGBE_READ_REG(hw, IXGBE_FDIRLEN);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters
 *  @@hw: pointer to hardware structure
 *  @@pballoc: which mode to allocate filters with
 **/
int32_t ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, uint32_t pballoc)
{
	uint32_t fdirctrl = 0;
	uint32_t pbsize;
	int i;

	DEBUGFUNC("ixgbe_init_fdir_signature_82599");

	/*
	 * Before enabling Flow Director, the Rx Packet Buffer size
	 * must be reduced.  The new value is the current size minus
	 * flow director memory usage size.
	 */
	pbsize = (1 << (IXGBE_FDIR_PBALLOC_SIZE_SHIFT + pballoc));
	IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(0),
	    (IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(0)) - pbsize));

	/*
	 * The defaults in the HW for RX PB 1-7 are not zero and so should be
	 * intialized to zero for non DCB mode otherwise actual total RX PB
	 * would be bigger than programmed and filter space would run into
	 * the PB 0 region.
	 */
	for (i = 1; i < 8; i++)
		IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);

	/* Send interrupt when 64 filters are left */
	fdirctrl |= 4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT;

	/* Set the maximum length per hash bucket to 0xA filters */
	fdirctrl |= 0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT;

	switch (pballoc) {
	case IXGBE_FDIR_PBALLOC_64K:
		/* 8k - 1 signature filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_64K;
		break;
	case IXGBE_FDIR_PBALLOC_128K:
		/* 16k - 1 signature filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_128K;
		break;
	case IXGBE_FDIR_PBALLOC_256K:
		/* 32k - 1 signature filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_256K;
		break;
	default:
		/* bad value */
		return IXGBE_ERR_CONFIG;
	};

	/* Move the flexible bytes to use the ethertype - shift 6 words */
	fdirctrl |= (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT);


	/* Prime the keys for hashing */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY, IXGBE_ATR_BUCKET_HASH_KEY);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY, IXGBE_ATR_SIGNATURE_HASH_KEY);

	/*
	 * Poll init-done after we write the register.  Estimated times:
	 *      10G: PBALLOC = 11b, timing is 60us
	 *       1G: PBALLOC = 11b, timing is 600us
	 *     100M: PBALLOC = 11b, timing is 6ms
	 *
	 *     Multiple these timings by 4 if under full Rx load
	 *
	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for
	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then
	 * this might not finish in our poll time, but we can live with that
	 * for now.
	 */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);
	IXGBE_WRITE_FLUSH(hw);
	for (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {
		if (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &
				   IXGBE_FDIRCTRL_INIT_DONE)
			break;
		msec_delay(1);
	}
	if (i >= IXGBE_FDIR_INIT_DONE_POLL)
		DEBUGOUT("Flow Director Signature poll time exceeded!\n");

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters
 *  @@hw: pointer to hardware structure
 *  @@pballoc: which mode to allocate filters with
 **/
int32_t ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, uint32_t pballoc)
{
	uint32_t fdirctrl = 0;
	uint32_t pbsize;
	int i;

	DEBUGFUNC("ixgbe_init_fdir_perfect_82599");

	/*
	 * Before enabling Flow Director, the Rx Packet Buffer size
	 * must be reduced.  The new value is the current size minus
	 * flow director memory usage size.
	 */
	pbsize = (1 << (IXGBE_FDIR_PBALLOC_SIZE_SHIFT + pballoc));
	IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(0),
	    (IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(0)) - pbsize));

	/*
	 * The defaults in the HW for RX PB 1-7 are not zero and so should be
	 * intialized to zero for non DCB mode otherwise actual total RX PB
	 * would be bigger than programmed and filter space would run into
	 * the PB 0 region.
	 */
	for (i = 1; i < 8; i++)
		IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);

	/* Send interrupt when 64 filters are left */
	fdirctrl |= 4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT;

	/* Initialize the drop queue to Rx queue 127 */
	fdirctrl |= (127 << IXGBE_FDIRCTRL_DROP_Q_SHIFT);

	switch (pballoc) {
	case IXGBE_FDIR_PBALLOC_64K:
		/* 2k - 1 perfect filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_64K;
		break;
	case IXGBE_FDIR_PBALLOC_128K:
		/* 4k - 1 perfect filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_128K;
		break;
	case IXGBE_FDIR_PBALLOC_256K:
		/* 8k - 1 perfect filters */
		fdirctrl |= IXGBE_FDIRCTRL_PBALLOC_256K;
		break;
	default:
		/* bad value */
		return IXGBE_ERR_CONFIG;
	};

	/* Turn perfect match filtering on */
	fdirctrl |= IXGBE_FDIRCTRL_PERFECT_MATCH;
	fdirctrl |= IXGBE_FDIRCTRL_REPORT_STATUS;

	/* Move the flexible bytes to use the ethertype - shift 6 words */
	fdirctrl |= (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT);

	/* Prime the keys for hashing */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY, IXGBE_ATR_BUCKET_HASH_KEY);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY, IXGBE_ATR_SIGNATURE_HASH_KEY);

	/*
	 * Poll init-done after we write the register.  Estimated times:
	 *      10G: PBALLOC = 11b, timing is 60us
	 *       1G: PBALLOC = 11b, timing is 600us
	 *     100M: PBALLOC = 11b, timing is 6ms
	 *
	 *     Multiple these timings by 4 if under full Rx load
	 *
	 * So we'll poll for IXGBE_FDIR_INIT_DONE_POLL times, sleeping for
	 * 1 msec per poll time.  If we're at line rate and drop to 100M, then
	 * this might not finish in our poll time, but we can live with that
	 * for now.
	 */

	/* Set the maximum length per hash bucket to 0xA filters */
	fdirctrl |= (0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT);

	IXGBE_WRITE_REG(hw, IXGBE_FDIRCTRL, fdirctrl);
	IXGBE_WRITE_FLUSH(hw);
	for (i = 0; i < IXGBE_FDIR_INIT_DONE_POLL; i++) {
		if (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &
				   IXGBE_FDIRCTRL_INIT_DONE)
			break;
		msec_delay(1);
	}
	if (i >= IXGBE_FDIR_INIT_DONE_POLL)
		DEBUGOUT("Flow Director Perfect poll time exceeded!\n");

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_compute_hash_82599 - Compute the hashes for SW ATR
 *  @@stream: input bitstream to compute the hash on
 *  @@key: 32-bit hash key
 **/
uint32_t ixgbe_atr_compute_hash_82599(union ixgbe_atr_input *atr_input,
				uint32_t key)
{
	/*
	 * The algorithm is as follows:
	 *    Hash[15:0] = Sum { S[n] x K[n+16] }, n = 0...350
	 *    where Sum {A[n]}, n = 0...n is bitwise XOR of A[0], A[1]...A[n]
	 *    and A[n] x B[n] is bitwise AND between same length strings
	 *
	 *    K[n] is 16 bits, defined as:
	 *       for n modulo 32 >= 15, K[n] = K[n % 32 : (n % 32) - 15]
	 *       for n modulo 32 < 15, K[n] =
	 *             K[(n % 32:0) | (31:31 - (14 - (n % 32)))]
	 *
	 *    S[n] is 16 bits, defined as:
	 *       for n >= 15, S[n] = S[n:n - 15]
	 *       for n < 15, S[n] = S[(n:0) | (350:350 - (14 - n))]
	 *
	 *    To simplify for programming, the algorithm is implemented
	 *    in software this way:
	 *
	 *    key[31:0], hi_hash_dword[31:0], lo_hash_dword[31:0], hash[15:0]
	 *
	 *    for (i = 0; i < 352; i+=32)
	 *        hi_hash_dword[31:0] ^= Stream[(i+31):i];
	 *
	 *    lo_hash_dword[15:0]  ^= Stream[15:0];
	 *    lo_hash_dword[15:0]  ^= hi_hash_dword[31:16];
	 *    lo_hash_dword[31:16] ^= hi_hash_dword[15:0];
	 *
	 *    hi_hash_dword[31:0]  ^= Stream[351:320];
	 *
	 *    if(key[0])
	 *        hash[15:0] ^= Stream[15:0];
	 *
	 *    for (i = 0; i < 16; i++) {
	 *        if (key[i])
	 *            hash[15:0] ^= lo_hash_dword[(i+15):i];
	 *        if (key[i + 16])
	 *            hash[15:0] ^= hi_hash_dword[(i+15):i];
	 *    }
	 *
	 */
	__be32 common_hash_dword = 0;
	uint32_t hi_hash_dword, lo_hash_dword, flow_vm_vlan;
	uint32_t hash_result = 0;
	uint8_t i;

	/* record the flow_vm_vlan bits as they are a key part to the hash */
	flow_vm_vlan = ntohl(atr_input->dword_stream[0]);

	/* generate common hash dword */
	for (i = 10; i; i -= 2)
		common_hash_dword ^= atr_input->dword_stream[i] ^
				     atr_input->dword_stream[i - 1];

	hi_hash_dword = ntohl(common_hash_dword);

	/* low dword is word swapped version of common */
	lo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);

	/* apply flow ID/VM pool/VLAN ID bits to hash words */
	hi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);

	/* Process bits 0 and 16 */
	if (key & 0x0001) hash_result ^= lo_hash_dword;
	if (key & 0x00010000) hash_result ^= hi_hash_dword;

	/*
	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to
	 * delay this because bit 0 of the stream should not be processed
	 * so we do not add the vlan until after bit 0 was processed
	 */
	lo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);


	/* process the remaining 30 bits in the key 2 bits at a time */
	for (i = 15; i; i-- ) {
		if (key & (0x0001 << i)) hash_result ^= lo_hash_dword >> i;
		if (key & (0x00010000 << i)) hash_result ^= hi_hash_dword >> i;
	}

	return hash_result & IXGBE_ATR_HASH_MASK;
}

/*
 * These defines allow us to quickly generate all of the necessary instructions
 * in the function below by simply calling out IXGBE_COMPUTE_SIG_HASH_ITERATION
 * for values 0 through 15
 */
#define IXGBE_ATR_COMMON_HASH_KEY \
		(IXGBE_ATR_BUCKET_HASH_KEY & IXGBE_ATR_SIGNATURE_HASH_KEY)
#define IXGBE_COMPUTE_SIG_HASH_ITERATION(_n) \
do { \
	uint32_t n = (_n); \
	if (IXGBE_ATR_COMMON_HASH_KEY & (0x01 << n)) \
		common_hash ^= lo_hash_dword >> n; \
	else if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << n)) \
		bucket_hash ^= lo_hash_dword >> n; \
	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & (0x01 << n)) \
		sig_hash ^= lo_hash_dword << (16 - n); \
	if (IXGBE_ATR_COMMON_HASH_KEY & (0x01 << (n + 16))) \
		common_hash ^= hi_hash_dword >> n; \
	else if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << (n + 16))) \
		bucket_hash ^= hi_hash_dword >> n; \
	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & (0x01 << (n + 16))) \
		sig_hash ^= hi_hash_dword << (16 - n); \
} while (0);

/**
 *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash
 *  @@stream: input bitstream to compute the hash on
 *
 *  This function is almost identical to the function above but contains
 *  several optomizations such as unwinding all of the loops, letting the
 *  compiler work out all of the conditional ifs since the keys are static
 *  defines, and computing two keys at once since the hashed dword stream
 *  will be the same for both keys.
 **/
uint32_t ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
					    union ixgbe_atr_hash_dword common)
{
	uint32_t hi_hash_dword, lo_hash_dword, flow_vm_vlan;
	uint32_t sig_hash = 0, bucket_hash = 0, common_hash = 0;

	/* record the flow_vm_vlan bits as they are a key part to the hash */
	flow_vm_vlan = ntohl(input.dword);

	/* generate common hash dword */
	hi_hash_dword = ntohl(common.dword);

	/* low dword is word swapped version of common */
	lo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);

	/* apply flow ID/VM pool/VLAN ID bits to hash words */
	hi_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan >> 16);

	/* Process bits 0 and 16 */
	IXGBE_COMPUTE_SIG_HASH_ITERATION(0);

	/*
	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to
	 * delay this because bit 0 of the stream should not be processed
	 * so we do not add the vlan until after bit 0 was processed
	 */
	lo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);

	/* Process remaining 30 bit of the key */
	IXGBE_COMPUTE_SIG_HASH_ITERATION(1);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(2);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(3);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(4);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(5);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(6);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(7);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(8);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(9);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(10);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(11);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(12);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(13);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(14);
	IXGBE_COMPUTE_SIG_HASH_ITERATION(15);

	/* combine common_hash result with signature and bucket hashes */
	bucket_hash ^= common_hash;
	bucket_hash &= IXGBE_ATR_HASH_MASK;

	sig_hash ^= common_hash << 16;
	sig_hash &= IXGBE_ATR_HASH_MASK << 16;

	/* return completed signature hash */
	return sig_hash ^ bucket_hash;
}

/**
 *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter
 *  @@hw: pointer to hardware structure
 *  @@stream: input bitstream
 *  @@queue: queue index to direct traffic to
 **/
int32_t ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
					  union ixgbe_atr_hash_dword input,
					  union ixgbe_atr_hash_dword common,
					  uint8_t queue)
{
	uint64_t  fdirhashcmd;
	uint64_t  fdircmd;

	DEBUGFUNC("ixgbe_fdir_add_signature_filter_82599");

	/*
	 * Get the flow_type in order to program FDIRCMD properly
	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6
	 */
	switch (input.formatted.flow_type) {
	case IXGBE_ATR_FLOW_TYPE_TCPV4:
	case IXGBE_ATR_FLOW_TYPE_UDPV4:
	case IXGBE_ATR_FLOW_TYPE_SCTPV4:
	case IXGBE_ATR_FLOW_TYPE_TCPV6:
	case IXGBE_ATR_FLOW_TYPE_UDPV6:
	case IXGBE_ATR_FLOW_TYPE_SCTPV6:
		break;
	default:
		DEBUGOUT(" Error on flow type input\n");
		return IXGBE_ERR_CONFIG;
	}

	/* configure FDIRCMD register */
	fdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |
		  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;
	fdircmd |= input.formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;
	fdircmd |= (uint32_t)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;

	/*
	 * The lower 32-bits of fdirhashcmd is for FDIRHASH, the upper 32-bits
	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH.
	 */
	fdirhashcmd = (uint64_t)fdircmd << 32;
	fdirhashcmd |= ixgbe_atr_compute_sig_hash_82599(input, common);
	IXGBE_WRITE_REG64(hw, IXGBE_FDIRHASH, fdirhashcmd);

	DEBUGOUT2("Tx Queue=%x hash=%x\n", queue, (uint32_t)fdirhashcmd);

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_get_fdirtcpm_82599 - generate a tcp port from atr_input_masks
 *  @@input_mask: mask to be bit swapped
 *
 *  The source and destination port masks for flow director are bit swapped
 *  in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to
 *  generate a correctly swapped value we need to bit swap the mask and that
 *  is what is accomplished by this function.
 **/
uint32_t ixgbe_get_fdirtcpm_82599(struct ixgbe_atr_input_masks *input_masks)
{
	uint32_t mask = ntohs(input_masks->dst_port_mask);
	mask <<= IXGBE_FDIRTCPM_DPORTM_SHIFT;
	mask |= ntohs(input_masks->src_port_mask);
	mask = ((mask & 0x55555555) << 1) | ((mask & 0xAAAAAAAA) >> 1);
	mask = ((mask & 0x33333333) << 2) | ((mask & 0xCCCCCCCC) >> 2);
	mask = ((mask & 0x0F0F0F0F) << 4) | ((mask & 0xF0F0F0F0) >> 4);
	return ((mask & 0x00FF00FF) << 8) | ((mask & 0xFF00FF00) >> 8);
}

/*
 * These two macros are meant to address the fact that we have registers
 * that are either all or in part big-endian.  As a result on big-endian
 * systems we will end up byte swapping the value to little-endian before
 * it is byte swapped again and written to the hardware in the original
 * big-endian format.
 */
#define IXGBE_STORE_AS_BE32(_value) \
	(((uint32_t)(_value) >> 24) | (((uint32_t)(_value) & 0x00FF0000) >> 8) | \
	 (((uint32_t)(_value) & 0x0000FF00) << 8) | ((uint32_t)(_value) << 24))

#define IXGBE_WRITE_REG_BE32(a, reg, value) \
	IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(ntohl(value)))

#define IXGBE_STORE_AS_BE16(_value) \
	(((uint16_t)(_value) >> 8) | ((uint16_t)(_value) << 8))


/**
 *  ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter
 *  @@hw: pointer to hardware structure
 *  @@input_masks: masks for the input bitstream
 *  @@soft_id: software index for the filters
 *  @@queue: queue index to direct traffic to
 *
 *  Note that the caller to this function must lock before calling, since the
 *  hardware writes must be protected from one another.
 **/
int32_t ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
				      union ixgbe_atr_input *input,
				      struct ixgbe_atr_input_masks *input_masks,
				      uint16_t soft_id, uint8_t queue)
{
	uint32_t fdirhash;
	uint32_t fdircmd;
	uint32_t fdirport, fdirtcpm;
	uint32_t fdirvlan;
	/* start with VLAN, flex bytes, VM pool, and IPv6 destination masked */
	uint32_t fdirm = IXGBE_FDIRM_VLANID | IXGBE_FDIRM_VLANP | IXGBE_FDIRM_FLEX |
			 IXGBE_FDIRM_POOL | IXGBE_FDIRM_DIPv6;

	DEBUGFUNC("ixgbe_fdir_add_perfect_filter_82599");

	/*
	 * Check flow_type formatting, and bail out before we touch the hardware
	 * if there's a configuration issue
	 */
	switch (input->formatted.flow_type) {
	case IXGBE_ATR_FLOW_TYPE_IPV4:
		/* use the L4 protocol mask for raw IPv4/IPv6 traffic */
		fdirm |= IXGBE_FDIRM_L4P;
	case IXGBE_ATR_FLOW_TYPE_SCTPV4:
		if (input_masks->dst_port_mask || input_masks->src_port_mask) {
			DEBUGOUT(" Error on src/dst port mask\n");
			return IXGBE_ERR_CONFIG;
		}
	case IXGBE_ATR_FLOW_TYPE_TCPV4:
	case IXGBE_ATR_FLOW_TYPE_UDPV4:
		break;
	default:
		DEBUGOUT(" Error on flow type input\n");
		return IXGBE_ERR_CONFIG;
	}

	/*
	 * Program the relevant mask registers.  If src/dst_port or src/dst_addr
	 * are zero, then assume a full mask for that field.  Also assume that
	 * a VLAN of 0 is unspecified, so mask that out as well.  L4type
	 * cannot be masked out in this implementation.
	 *
	 * This also assumes IPv4 only.  IPv6 masking isn't supported at this
	 * point in time.
	 */

	/* Program FDIRM */
	switch (ntohs(input_masks->vlan_id_mask) & 0xEFFF) {
	case 0xEFFF:
		/* Unmask VLAN ID - bit 0 and fall through to unmask prio */
		fdirm &= ~IXGBE_FDIRM_VLANID;
	case 0xE000:
		/* Unmask VLAN prio - bit 1 */
		fdirm &= ~IXGBE_FDIRM_VLANP;
		break;
	case 0x0FFF:
		/* Unmask VLAN ID - bit 0 */
		fdirm &= ~IXGBE_FDIRM_VLANID;
		break;
	case 0x0000:
		/* do nothing, vlans already masked */
		break;
	default:
		DEBUGOUT(" Error on VLAN mask\n");
		return IXGBE_ERR_CONFIG;
	}

	if (input_masks->flex_mask & 0xFFFF) {
		if ((input_masks->flex_mask & 0xFFFF) != 0xFFFF) {
			DEBUGOUT(" Error on flexible byte mask\n");
			return IXGBE_ERR_CONFIG;
		}
		/* Unmask Flex Bytes - bit 4 */
		fdirm &= ~IXGBE_FDIRM_FLEX;
	}

	/* Now mask VM pool and destination IPv6 - bits 5 and 2 */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRM, fdirm);

	/* store the TCP/UDP port masks, bit reversed from port layout */
	fdirtcpm = ixgbe_get_fdirtcpm_82599(input_masks);

	/* write both the same so that UDP and TCP use the same mask */
	IXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, ~fdirtcpm);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, ~fdirtcpm);

	/* store source and destination IP masks (big-enian) */
	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M,
			     ~input_masks->src_ip_mask[0]);
	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M,
			     ~input_masks->dst_ip_mask[0]);

	/* Apply masks to input data */
	input->formatted.vlan_id &= input_masks->vlan_id_mask;
	input->formatted.flex_bytes &= input_masks->flex_mask;
	input->formatted.src_port &= input_masks->src_port_mask;
	input->formatted.dst_port &= input_masks->dst_port_mask;
	input->formatted.src_ip[0] &= input_masks->src_ip_mask[0];
	input->formatted.dst_ip[0] &= input_masks->dst_ip_mask[0];

	/* record vlan (little-endian) and flex_bytes(big-endian) */
	fdirvlan =
		IXGBE_STORE_AS_BE16(ntohs(input->formatted.flex_bytes));
	fdirvlan <<= IXGBE_FDIRVLAN_FLEX_SHIFT;
	fdirvlan |= ntohs(input->formatted.vlan_id);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRVLAN, fdirvlan);

	/* record source and destination port (little-endian)*/
	fdirport = ntohs(input->formatted.dst_port);
	fdirport <<= IXGBE_FDIRPORT_DESTINATION_SHIFT;
	fdirport |= ntohs(input->formatted.src_port);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, fdirport);

	/* record the first 32 bits of the destination address (big-endian) */
	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPDA, input->formatted.dst_ip[0]);

	/* record the source address (big-endian) */
	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPSA, input->formatted.src_ip[0]);

	/* configure FDIRCMD register */
	fdircmd = IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |
		  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;
	fdircmd |= input->formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;
	fdircmd |= (uint32_t)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;

	/* we only want the bucket hash so drop the upper 16 bits */
	fdirhash = ixgbe_atr_compute_hash_82599(input,
						IXGBE_ATR_BUCKET_HASH_KEY);
	fdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;

	IXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRCMD, fdircmd);

	return IXGBE_SUCCESS;
@


1.5
log
@Add support for 10Gb ethernet cards based on the Intel X540 chipset.
The code was obtained from FreeBSD and tested on the hardware kindly
donated by Tony Sarendal <tony () polarcap ! org>.  Thanks a lot!

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.4 2012/07/29 13:49:03 mikeb Exp $	*/
d448 1
@


1.4
log
@whitespace cleanup, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.3 2011/06/10 12:46:35 claudio Exp $	*/
d193 2
a194 1
		ret_val = ixgbe_acquire_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
d208 1
a208 1
		ixgbe_release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
@


1.3
log
@Monster update of ix(4). This brings ix(4) close to what is currently
in FreeBSD. This seems to fix a lot of problems on 82599 based cards
including the VLAN problems and the corrupted receives.
Putting this in now to work on it in tree since a few additional things
need to be merged. Tested by myself, deraadt@@ and jsg@@ on both 98er and
99er cards.
OK jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.2 2010/02/25 10:56:07 jsg Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2009, Intel Corporation 
d7 2
a8 2
  
  Redistribution and use in source and binary forms, with or without 
d10 2
a11 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d13 3
a15 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d21 1
a21 1
  
d23 8
a30 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d42 2
a43 2
                                      ixgbe_link_speed *speed,
                                      int *autoneg);
d49 2
a50 2
                                     ixgbe_link_speed speed, int autoneg,
                                     int autoneg_wait_to_complete);
d57 3
a59 3
                                     ixgbe_link_speed speed,
                                     int autoneg,
                                     int autoneg_wait_to_complete);
d61 3
a63 3
                                               ixgbe_link_speed speed,
                                               int autoneg,
                                               int autoneg_wait_to_complete);
d80 3
a82 3
                                          union ixgbe_atr_hash_dword input,
                                          union ixgbe_atr_hash_dword common,
                                          uint8_t queue);
d94 1
a94 1
		                       &ixgbe_disable_tx_laser_multispeed_fiber;
d96 1
a96 1
		                        &ixgbe_enable_tx_laser_multispeed_fiber;
d151 1
a151 1
		                  &ixgbe_get_copper_link_capabilities_generic;
d160 1
a160 1
		             &ixgbe_get_phy_firmware_version_tnx;
d164 1
a164 1
		             &ixgbe_get_phy_firmware_version_generic;
d188 1
a188 1
		                                              &data_offset);
d213 2
a214 2
		                IXGBE_AUTOC) & ~IXGBE_AUTOC_LMS_MASK) |
		                IXGBE_AUTOC_AN_RESTART));
d231 2
a232 2
		                IXGBE_AUTOC) | IXGBE_AUTOC_LMS_10G_SERIAL |
		                IXGBE_AUTOC_AN_RESTART));
d267 1
a267 1
	                            &ixgbe_get_supported_physical_layer_82599;
d322 2
a323 2
                                      ixgbe_link_speed *speed,
                                      int *negotiation)
d405 1
a405 1
		          IXGBE_LINK_SPEED_1GB_FULL;
d471 1
a471 1
                               int autoneg_wait_to_complete)
d585 2
a586 2
                                     ixgbe_link_speed speed, int autoneg,
                                     int autoneg_wait_to_complete)
d651 1
a651 1
			                          &link_up, FALSE);
d711 1
a711 1
		        highest_link_speed, autoneg, autoneg_wait_to_complete);
d849 2
a850 2
                                     ixgbe_link_speed speed, int autoneg,
                                     int autoneg_wait_to_complete)
d898 2
a899 2
	         (link_mode == IXGBE_AUTOC_LMS_1G_LINK_NO_AN ||
	          link_mode == IXGBE_AUTOC_LMS_1G_AN)) {
d907 1
a907 1
	           (link_mode == IXGBE_AUTOC_LMS_10G_SERIAL)) {
d963 3
a965 3
                                               ixgbe_link_speed speed,
                                               int autoneg,
                                               int autoneg_wait_to_complete)
d973 1
a973 1
	                                      autoneg_wait_to_complete);
d1083 1
a1083 1
			           IXGBE_AUTOC2_UPPER_MASK);
d1106 1
a1106 1
		                    hw->mac.san_addr, 0, IXGBE_RAH_AV);
d1114 1
a1114 1
	                               &hw->mac.wwpn_prefix);
d1144 1
a1144 1
		         "aborting table re-initialization. \n");
d1158 2
a1159 2
	                (IXGBE_READ_REG(hw, IXGBE_FDIRCMD) |
	                 IXGBE_FDIRCMD_CLEARHT));
d1162 2
a1163 2
	                (IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &
	                 ~IXGBE_FDIRCMD_CLEARHT));
d1178 1
a1178 1
		                   IXGBE_FDIRCTRL_INIT_DONE)
d1277 1
a1277 1
		                   IXGBE_FDIRCTRL_INIT_DONE)
d1374 1
a1374 1
		                   IXGBE_FDIRCTRL_INIT_DONE)
d1390 1
a1390 1
                                uint32_t key)
d1571 3
a1573 3
                                          union ixgbe_atr_hash_dword input,
                                          union ixgbe_atr_hash_dword common,
                                          uint8_t queue)
d1599 1
a1599 1
	          IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;
d1665 3
a1667 3
                                      union ixgbe_atr_input *input,
                                      struct ixgbe_atr_input_masks *input_masks,
                                      uint16_t soft_id, uint8_t queue)
d1815 1
a1815 1
	                (reg << 8));
d2087 1
a2087 1
		         "path fully disabled.  Continuing with init.\n");
d2130 2
a2131 2
	                         IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR),
	                         &fw_ptp_cfg_offset);
d2138 2
a2139 2
	                         IXGBE_FW_PATCH_VERSION_4),
	                         &fw_version);
d2172 2
a2173 2
	                         IXGBE_FW_LESM_PARAMETERS_PTR),
	                         &fw_lesm_param_offset);
d2181 2
a2182 2
	                             IXGBE_FW_LESM_STATE_1),
	                             &fw_lesm_state);
a2190 2


@


1.2
log
@Add support for the 82599 ExpressModule (X520-P2) card.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe_82599.c,v 1.1 2010/02/23 18:43:15 jsg Exp $	*/
d45 3
a73 1
int32_t ixgbe_get_device_caps_82599(struct ixgbe_hw *hw, uint16_t *device_caps);
d75 1
d77 2
a78 3
int32_t ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
int32_t ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, uint32_t pballoc);
int32_t ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, uint32_t pballoc);
d80 2
a81 1
                                          struct ixgbe_atr_input *input,
d83 1
a83 35
int32_t ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
                                        struct ixgbe_atr_input *input,
                                        uint16_t soft_id,
                                        uint8_t queue);
uint16_t ixgbe_atr_compute_hash_82599(struct ixgbe_atr_input *input, uint32_t key);
int32_t ixgbe_atr_set_vlan_id_82599(struct ixgbe_atr_input *input, uint16_t vlan_id);
int32_t ixgbe_atr_set_src_ipv4_82599(struct ixgbe_atr_input *input, uint32_t src_addr);
int32_t ixgbe_atr_set_dst_ipv4_82599(struct ixgbe_atr_input *input, uint32_t dst_addr);
int32_t ixgbe_atr_set_src_ipv6_82599(struct ixgbe_atr_input *input, uint32_t src_addr_1,
                                 uint32_t src_addr_2, uint32_t src_addr_3,
                                 uint32_t src_addr_4);
int32_t ixgbe_atr_set_dst_ipv6_82599(struct ixgbe_atr_input *input, uint32_t dst_addr_1,
                                 uint32_t dst_addr_2, uint32_t dst_addr_3,
                                 uint32_t dst_addr_4);
int32_t ixgbe_atr_set_src_port_82599(struct ixgbe_atr_input *input, uint16_t src_port);
int32_t ixgbe_atr_set_dst_port_82599(struct ixgbe_atr_input *input, uint16_t dst_port);
int32_t ixgbe_atr_set_flex_byte_82599(struct ixgbe_atr_input *input, uint16_t flex_byte);
int32_t ixgbe_atr_set_vm_pool_82599(struct ixgbe_atr_input *input, uint8_t vm_pool);
int32_t ixgbe_atr_set_l4type_82599(struct ixgbe_atr_input *input, uint8_t l4type);
int32_t ixgbe_atr_get_vlan_id_82599(struct ixgbe_atr_input *input, uint16_t *vlan_id);
int32_t ixgbe_atr_get_src_ipv4_82599(struct ixgbe_atr_input *input, uint32_t *src_addr);
int32_t ixgbe_atr_get_dst_ipv4_82599(struct ixgbe_atr_input *input, uint32_t *dst_addr);
int32_t ixgbe_atr_get_src_ipv6_82599(struct ixgbe_atr_input *input, uint32_t *src_addr_1,
                                 uint32_t *src_addr_2, uint32_t *src_addr_3,
                                 uint32_t *src_addr_4);
int32_t ixgbe_atr_get_dst_ipv6_82599(struct ixgbe_atr_input *input, uint32_t *dst_addr_1,
                                 uint32_t *dst_addr_2, uint32_t *dst_addr_3,
                                 uint32_t *dst_addr_4);
int32_t ixgbe_atr_get_src_port_82599(struct ixgbe_atr_input *input, uint16_t *src_port);
int32_t ixgbe_atr_get_dst_port_82599(struct ixgbe_atr_input *input, uint16_t *dst_port);
int32_t ixgbe_atr_get_flex_byte_82599(struct ixgbe_atr_input *input,
                                  uint16_t *flex_byte);
int32_t ixgbe_atr_get_vm_pool_82599(struct ixgbe_atr_input *input, uint8_t *vm_pool);
int32_t ixgbe_atr_get_l4type_82599(struct ixgbe_atr_input *input, uint8_t *l4type);

d91 14
d109 1
a109 1
		if ((ixgbe_get_media_type_82599(hw) == ixgbe_media_type_backplane) &&
d111 2
a112 1
		      hw->phy.smart_speed == ixgbe_smart_speed_on))
d114 1
a114 1
		else
d116 1
d176 2
a204 3
		/* Now restart DSP by setting Restart_AN */
		IXGBE_WRITE_REG(hw, IXGBE_AUTOC,
		    (IXGBE_READ_REG(hw, IXGBE_AUTOC) | IXGBE_AUTOC_AN_RESTART));
d210 23
d264 1
d272 8
a279 1
	mac->ops.get_device_caps = &ixgbe_get_device_caps_82599;
d290 4
d303 1
d308 1
d330 8
d426 4
a429 3
	if (hw->phy.type == ixgbe_phy_cu_unknown ||
	    hw->phy.type == ixgbe_phy_tn ||
	    hw->phy.type == ixgbe_phy_aq) {
d432 2
d440 1
d446 1
a446 1
	case IXGBE_DEV_ID_82599_SFP_EM:
d452 3
d491 2
a492 2
		     IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN
		    || (autoc_reg & IXGBE_AUTOC_LMS_MASK) ==
d515 61
d600 1
a600 1
	status = ixgbe_get_link_capabilities_82599(hw, &link_speed, &negotiation);
a606 10
	 * When the driver changes the link speeds that it can support,
	 * it sets autotry_restart to TRUE to indicate that we need to
	 * initiate a new autotry session with the link partner.  To do
	 * so, we set the speed then disable and re-enable the tx laser, to
	 * alert the link partner that it also needs to restart autotry on its
	 * end.  This is consistent with TRUE clause 37 autoneg, which also
	 * involves a loss of signal.
	 */

	/*
d615 1
a615 1
		status = ixgbe_check_mac_link_generic(hw, &link_speed, &link_up, FALSE);
d625 1
d630 4
a633 3
		status = ixgbe_setup_mac_link_82599(
			hw, IXGBE_LINK_SPEED_10GB_FULL, autoneg,
			autoneg_wait_to_complete);
d638 1
a638 13
		if (hw->mac.autotry_restart) {
			/* Disable tx laser; allow 100us to go dark per spec */
			esdp_reg |= IXGBE_ESDP_SDP3;
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			usec_delay(100);

			/* Enable tx laser; allow 2ms to light up per spec */
			esdp_reg &= ~IXGBE_ESDP_SDP3;
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			msec_delay(2);

			hw->mac.autotry_restart = FALSE;
		}
d650 1
a650 1
			status = ixgbe_check_mac_link_generic(hw, &link_speed,
d666 1
a666 1
		status = ixgbe_check_mac_link_generic(hw, &link_speed, &link_up, FALSE);
d677 1
d682 4
a685 3
		status = ixgbe_setup_mac_link_82599(
			hw, IXGBE_LINK_SPEED_1GB_FULL, autoneg,
			autoneg_wait_to_complete);
d690 1
a690 13
		if (hw->mac.autotry_restart) {
			/* Disable tx laser; allow 100us to go dark per spec */
			esdp_reg |= IXGBE_ESDP_SDP3;
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			usec_delay(100);

			/* Enable tx laser; allow 2ms to light up per spec */
			esdp_reg &= ~IXGBE_ESDP_SDP3;
			IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
			msec_delay(2);

			hw->mac.autotry_restart = FALSE;
		}
d696 1
a696 1
		status = ixgbe_check_mac_link_generic(hw, &link_speed, &link_up, FALSE);
d784 1
a784 1
			status = ixgbe_check_mac_link_generic(hw, &link_speed, &link_up,
d819 1
a819 1
		status = ixgbe_check_mac_link_generic(hw, &link_speed, &link_up, FALSE);
d833 3
d867 1
a867 1
	status = ixgbe_get_link_capabilities_82599(hw, &link_capabilities, &autoneg);
d885 2
a886 2
	         link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN ||
	         link_mode == IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII) {
d907 1
a907 1
	         (link_mode == IXGBE_AUTOC_LMS_10G_SERIAL)) {
a919 1

d990 1
a990 1
	uint32_t ctrl, ctrl_ext;
d1025 1
a1025 5
	status = ixgbe_disable_pcie_master(hw);
	if (status != IXGBE_SUCCESS) {
		status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
		DEBUGOUT("PCI-E Master disable polling has failed.\n");
	}
d1027 1
d1047 13
a1059 4
	/* Clear PF Reset Done bit so PF/VF Mail Ops can work */
	ctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
	ctrl_ext |= IXGBE_CTRL_EXT_PFRSTD;
	IXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);
d1088 1
a1088 1
       /* Store the permanent mac address */
d1099 17
d1257 2
a1258 4
	IXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY,
	                htonl(IXGBE_ATR_BUCKET_HASH_KEY));
	IXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY,
	                htonl(IXGBE_ATR_SIGNATURE_HASH_KEY));
a1304 1

d1321 3
d1350 2
a1351 4
	IXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY,
	                htonl(IXGBE_ATR_BUCKET_HASH_KEY));
	IXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY,
	                htonl(IXGBE_ATR_SIGNATURE_HASH_KEY));
a1383 1

d1389 2
a1390 1
uint16_t ixgbe_atr_compute_hash_82599(struct ixgbe_atr_input *atr_input, uint32_t key)
d1410 1
a1410 1
	 *    Key[31:0], Stream[335:0]
d1412 2
a1413 3
	 *    tmp_key[11 * 32 - 1:0] = 11{Key[31:0] = key concatenated 11 times
	 *    int_key[350:0] = tmp_key[351:1]
	 *    int_stream[365:0] = Stream[14:0] | Stream[335:0] | Stream[335:321]
d1415 14
a1428 4
	 *    hash[15:0] = 0;
	 *    for (i = 0; i < 351; i++) {
	 *        if (int_key[i])
	 *            hash ^= int_stream[(i + 15):i];
d1430 1
d1432 65
a1496 85

	union {
		uint64_t    fill[6];
		uint32_t    key[11];
		uint8_t     key_stream[44];
	} tmp_key;

	uint8_t   *stream = (uint8_t *)atr_input;
	uint8_t   int_key[44];      /* upper-most bit unused */
	uint8_t   hash_str[46];     /* upper-most 2 bits unused */
	uint16_t  hash_result = 0;
	int  i, j, k, h;

	DEBUGFUNC("ixgbe_atr_compute_hash_82599");

	/*
	 * Initialize the fill member to prevent warnings
	 * on some compilers
	 */
	 tmp_key.fill[0] = 0;

	/* First load the temporary key stream */
	for (i = 0; i < 6; i++) {
		uint64_t fillkey = ((uint64_t)key << 32) | key;
		tmp_key.fill[i] = fillkey;
	}

	/*
	 * Set the interim key for the hashing.  Bit 352 is unused, so we must
	 * shift and compensate when building the key.
	 */

	int_key[0] = tmp_key.key_stream[0] >> 1;
	for (i = 1, j = 0; i < 44; i++) {
		unsigned int this_key = tmp_key.key_stream[j] << 7;
		j++;
		int_key[i] = (uint8_t)(this_key | (tmp_key.key_stream[j] >> 1));
	}

	/*
	 * Set the interim bit string for the hashing.  Bits 368 and 367 are
	 * unused, so shift and compensate when building the string.
	 */
	hash_str[0] = (stream[40] & 0x7f) >> 1;
	for (i = 1, j = 40; i < 46; i++) {
		unsigned int this_str = stream[j] << 7;
		j++;
		if (j > 41)
			j = 0;
		hash_str[i] = (uint8_t)(this_str | (stream[j] >> 1));
	}

	/*
	 * Now compute the hash.  i is the index into hash_str, j is into our
	 * key stream, k is counting the number of bits, and h interates within
	 * each byte.
	 */
	for (i = 45, j = 43, k = 0; k < 351 && i >= 2 && j >= 0; i--, j--) {
		for (h = 0; h < 8 && k < 351; h++, k++) {
			if (int_key[j] & (1 << h)) {
				/*
				 * Key bit is set, XOR in the current 16-bit
				 * string.  Example of processing:
				 *    h = 0,
				 *      tmp = (hash_str[i - 2] & 0 << 16) |
				 *            (hash_str[i - 1] & 0xff << 8) |
				 *            (hash_str[i] & 0xff >> 0)
				 *      So tmp = hash_str[15 + k:k], since the
				 *      i + 2 clause rolls off the 16-bit value
				 *    h = 7,
				 *      tmp = (hash_str[i - 2] & 0x7f << 9) |
				 *            (hash_str[i - 1] & 0xff << 1) |
				 *            (hash_str[i] & 0x80 >> 7)
				 */
				int tmp = (hash_str[i] >> h);
				tmp |= (hash_str[i - 1] << (8 - h));
				tmp |= (int)(hash_str[i - 2] & ((1 << h) - 1))
				             << (16 - h);
				hash_result ^= (uint16_t)tmp;
			}
		}
	}

	return hash_result;
}
d1499 2
a1500 342
 *  ixgbe_atr_set_vlan_id_82599 - Sets the VLAN id in the ATR input stream
 *  @@input: input stream to modify
 *  @@vlan: the VLAN id to load
 **/
int32_t ixgbe_atr_set_vlan_id_82599(struct ixgbe_atr_input *input, uint16_t vlan)
{
	DEBUGFUNC("ixgbe_atr_set_vlan_id_82599");

	input->byte_stream[IXGBE_ATR_VLAN_OFFSET + 1] = vlan >> 8;
	input->byte_stream[IXGBE_ATR_VLAN_OFFSET] = vlan & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_src_ipv4_82599 - Sets the source IPv4 address
 *  @@input: input stream to modify
 *  @@src_addr: the IP address to load
 **/
int32_t ixgbe_atr_set_src_ipv4_82599(struct ixgbe_atr_input *input, uint32_t src_addr)
{
	DEBUGFUNC("ixgbe_atr_set_src_ipv4_82599");

	input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 3] = src_addr >> 24;
	input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 2] =
	                                               (src_addr >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 1] =
	                                                (src_addr >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET] = src_addr & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_dst_ipv4_82599 - Sets the destination IPv4 address
 *  @@input: input stream to modify
 *  @@dst_addr: the IP address to load
 **/
int32_t ixgbe_atr_set_dst_ipv4_82599(struct ixgbe_atr_input *input, uint32_t dst_addr)
{
	DEBUGFUNC("ixgbe_atr_set_dst_ipv4_82599");

	input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 3] = dst_addr >> 24;
	input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 2] =
	                                               (dst_addr >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 1] =
	                                                (dst_addr >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET] = dst_addr & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_src_ipv6_82599 - Sets the source IPv6 address
 *  @@input: input stream to modify
 *  @@src_addr_1: the first 4 bytes of the IP address to load
 *  @@src_addr_2: the second 4 bytes of the IP address to load
 *  @@src_addr_3: the third 4 bytes of the IP address to load
 *  @@src_addr_4: the fourth 4 bytes of the IP address to load
 **/
int32_t ixgbe_atr_set_src_ipv6_82599(struct ixgbe_atr_input *input,
                                 uint32_t src_addr_1, uint32_t src_addr_2,
                                 uint32_t src_addr_3, uint32_t src_addr_4)
{
	DEBUGFUNC("ixgbe_atr_set_src_ipv6_82599");

	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET] = src_addr_4 & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 1] =
	                                               (src_addr_4 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 2] =
	                                              (src_addr_4 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 3] = src_addr_4 >> 24;

	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 4] = src_addr_3 & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 5] =
	                                               (src_addr_3 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 6] =
	                                              (src_addr_3 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 7] = src_addr_3 >> 24;

	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 8] = src_addr_2 & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 9] =
	                                               (src_addr_2 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 10] =
	                                              (src_addr_2 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 11] = src_addr_2 >> 24;

	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 12] = src_addr_1 & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 13] =
	                                               (src_addr_1 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 14] =
	                                              (src_addr_1 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 15] = src_addr_1 >> 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_dst_ipv6_82599 - Sets the destination IPv6 address
 *  @@input: input stream to modify
 *  @@dst_addr_1: the first 4 bytes of the IP address to load
 *  @@dst_addr_2: the second 4 bytes of the IP address to load
 *  @@dst_addr_3: the third 4 bytes of the IP address to load
 *  @@dst_addr_4: the fourth 4 bytes of the IP address to load
 **/
int32_t ixgbe_atr_set_dst_ipv6_82599(struct ixgbe_atr_input *input,
                                 uint32_t dst_addr_1, uint32_t dst_addr_2,
                                 uint32_t dst_addr_3, uint32_t dst_addr_4)
{
	DEBUGFUNC("ixgbe_atr_set_dst_ipv6_82599");

	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET] = dst_addr_4 & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 1] =
	                                               (dst_addr_4 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 2] =
	                                              (dst_addr_4 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 3] = dst_addr_4 >> 24;

	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 4] = dst_addr_3 & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 5] =
	                                               (dst_addr_3 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 6] =
	                                              (dst_addr_3 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 7] = dst_addr_3 >> 24;

	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 8] = dst_addr_2 & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 9] =
	                                               (dst_addr_2 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 10] =
	                                              (dst_addr_2 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 11] = dst_addr_2 >> 24;

	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 12] = dst_addr_1 & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 13] =
	                                               (dst_addr_1 >> 8) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 14] =
	                                              (dst_addr_1 >> 16) & 0xff;
	input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 15] = dst_addr_1 >> 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_src_port_82599 - Sets the source port
 *  @@input: input stream to modify
 *  @@src_port: the source port to load
 **/
int32_t ixgbe_atr_set_src_port_82599(struct ixgbe_atr_input *input, uint16_t src_port)
{
	DEBUGFUNC("ixgbe_atr_set_src_port_82599");

	input->byte_stream[IXGBE_ATR_SRC_PORT_OFFSET + 1] = src_port >> 8;
	input->byte_stream[IXGBE_ATR_SRC_PORT_OFFSET] = src_port & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_dst_port_82599 - Sets the destination port
 *  @@input: input stream to modify
 *  @@dst_port: the destination port to load
 **/
int32_t ixgbe_atr_set_dst_port_82599(struct ixgbe_atr_input *input, uint16_t dst_port)
{
	DEBUGFUNC("ixgbe_atr_set_dst_port_82599");

	input->byte_stream[IXGBE_ATR_DST_PORT_OFFSET + 1] = dst_port >> 8;
	input->byte_stream[IXGBE_ATR_DST_PORT_OFFSET] = dst_port & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_flex_byte_82599 - Sets the flexible bytes
 *  @@input: input stream to modify
 *  @@flex_bytes: the flexible bytes to load
 **/
int32_t ixgbe_atr_set_flex_byte_82599(struct ixgbe_atr_input *input, uint16_t flex_byte)
{
	DEBUGFUNC("ixgbe_atr_set_flex_byte_82599");

	input->byte_stream[IXGBE_ATR_FLEX_BYTE_OFFSET + 1] = flex_byte >> 8;
	input->byte_stream[IXGBE_ATR_FLEX_BYTE_OFFSET] = flex_byte & 0xff;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_vm_pool_82599 - Sets the Virtual Machine pool
 *  @@input: input stream to modify
 *  @@vm_pool: the Virtual Machine pool to load
 **/
int32_t ixgbe_atr_set_vm_pool_82599(struct ixgbe_atr_input *input, uint8_t vm_pool)
{
	DEBUGFUNC("ixgbe_atr_set_vm_pool_82599");

	input->byte_stream[IXGBE_ATR_VM_POOL_OFFSET] = vm_pool;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_set_l4type_82599 - Sets the layer 4 packet type
 *  @@input: input stream to modify
 *  @@l4type: the layer 4 type value to load
 **/
int32_t ixgbe_atr_set_l4type_82599(struct ixgbe_atr_input *input, uint8_t l4type)
{
	DEBUGFUNC("ixgbe_atr_set_l4type_82599");

	input->byte_stream[IXGBE_ATR_L4TYPE_OFFSET] = l4type;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_vlan_id_82599 - Gets the VLAN id from the ATR input stream
 *  @@input: input stream to search
 *  @@vlan: the VLAN id to load
 **/
int32_t ixgbe_atr_get_vlan_id_82599(struct ixgbe_atr_input *input, uint16_t *vlan)
{
	DEBUGFUNC("ixgbe_atr_get_vlan_id_82599");

	*vlan = input->byte_stream[IXGBE_ATR_VLAN_OFFSET];
	*vlan |= input->byte_stream[IXGBE_ATR_VLAN_OFFSET + 1] << 8;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_src_ipv4_82599 - Gets the source IPv4 address
 *  @@input: input stream to search
 *  @@src_addr: the IP address to load
 **/
int32_t ixgbe_atr_get_src_ipv4_82599(struct ixgbe_atr_input *input, uint32_t *src_addr)
{
	DEBUGFUNC("ixgbe_atr_get_src_ipv4_82599");

	*src_addr = input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET];
	*src_addr |= input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 1] << 8;
	*src_addr |= input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 2] << 16;
	*src_addr |= input->byte_stream[IXGBE_ATR_SRC_IPV4_OFFSET + 3] << 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_dst_ipv4_82599 - Gets the destination IPv4 address
 *  @@input: input stream to search
 *  @@dst_addr: the IP address to load
 **/
int32_t ixgbe_atr_get_dst_ipv4_82599(struct ixgbe_atr_input *input, uint32_t *dst_addr)
{
	DEBUGFUNC("ixgbe_atr_get_dst_ipv4_82599");

	*dst_addr = input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET];
	*dst_addr |= input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 1] << 8;
	*dst_addr |= input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 2] << 16;
	*dst_addr |= input->byte_stream[IXGBE_ATR_DST_IPV4_OFFSET + 3] << 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_src_ipv6_82599 - Gets the source IPv6 address
 *  @@input: input stream to search
 *  @@src_addr_1: the first 4 bytes of the IP address to load
 *  @@src_addr_2: the second 4 bytes of the IP address to load
 *  @@src_addr_3: the third 4 bytes of the IP address to load
 *  @@src_addr_4: the fourth 4 bytes of the IP address to load
 **/
int32_t ixgbe_atr_get_src_ipv6_82599(struct ixgbe_atr_input *input,
                                 uint32_t *src_addr_1, uint32_t *src_addr_2,
                                 uint32_t *src_addr_3, uint32_t *src_addr_4)
{
	DEBUGFUNC("ixgbe_atr_get_src_ipv6_82599");

	*src_addr_1 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 12];
	*src_addr_1 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 13] << 8;
	*src_addr_1 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 14] << 16;
	*src_addr_1 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 15] << 24;

	*src_addr_2 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 8];
	*src_addr_2 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 9] << 8;
	*src_addr_2 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 10] << 16;
	*src_addr_2 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 11] << 24;

	*src_addr_3 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 4];
	*src_addr_3 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 5] << 8;
	*src_addr_3 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 6] << 16;
	*src_addr_3 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 7] << 24;

	*src_addr_4 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET];
	*src_addr_4 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 1] << 8;
	*src_addr_4 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 2] << 16;
	*src_addr_4 = input->byte_stream[IXGBE_ATR_SRC_IPV6_OFFSET + 3] << 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_dst_ipv6_82599 - Gets the destination IPv6 address
 *  @@input: input stream to search
 *  @@dst_addr_1: the first 4 bytes of the IP address to load
 *  @@dst_addr_2: the second 4 bytes of the IP address to load
 *  @@dst_addr_3: the third 4 bytes of the IP address to load
 *  @@dst_addr_4: the fourth 4 bytes of the IP address to load
 **/
int32_t ixgbe_atr_get_dst_ipv6_82599(struct ixgbe_atr_input *input,
                                 uint32_t *dst_addr_1, uint32_t *dst_addr_2,
                                 uint32_t *dst_addr_3, uint32_t *dst_addr_4)
{
	DEBUGFUNC("ixgbe_atr_get_dst_ipv6_82599");

	*dst_addr_1 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 12];
	*dst_addr_1 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 13] << 8;
	*dst_addr_1 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 14] << 16;
	*dst_addr_1 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 15] << 24;

	*dst_addr_2 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 8];
	*dst_addr_2 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 9] << 8;
	*dst_addr_2 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 10] << 16;
	*dst_addr_2 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 11] << 24;

	*dst_addr_3 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 4];
	*dst_addr_3 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 5] << 8;
	*dst_addr_3 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 6] << 16;
	*dst_addr_3 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 7] << 24;

	*dst_addr_4 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET];
	*dst_addr_4 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 1] << 8;
	*dst_addr_4 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 2] << 16;
	*dst_addr_4 = input->byte_stream[IXGBE_ATR_DST_IPV6_OFFSET + 3] << 24;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_src_port_82599 - Gets the source port
 *  @@input: input stream to modify
 *  @@src_port: the source port to load
d1502 50
a1551 8
 *  Even though the input is given in big-endian, the FDIRPORT registers
 *  expect the ports to be programmed in little-endian.  Hence the need to swap
 *  endianness when retrieving the data.  This can be confusing since the
 *  internal hash engine expects it to be big-endian.
 **/
int32_t ixgbe_atr_get_src_port_82599(struct ixgbe_atr_input *input, uint16_t *src_port)
{
	DEBUGFUNC("ixgbe_atr_get_src_port_82599");
d1553 3
a1555 49
	*src_port = input->byte_stream[IXGBE_ATR_SRC_PORT_OFFSET] << 8;
	*src_port |= input->byte_stream[IXGBE_ATR_SRC_PORT_OFFSET + 1];

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_dst_port_82599 - Gets the destination port
 *  @@input: input stream to modify
 *  @@dst_port: the destination port to load
 *
 *  Even though the input is given in big-endian, the FDIRPORT registers
 *  expect the ports to be programmed in little-endian.  Hence the need to swap
 *  endianness when retrieving the data.  This can be confusing since the
 *  internal hash engine expects it to be big-endian.
 **/
int32_t ixgbe_atr_get_dst_port_82599(struct ixgbe_atr_input *input, uint16_t *dst_port)
{
	DEBUGFUNC("ixgbe_atr_get_dst_port_82599");

	*dst_port = input->byte_stream[IXGBE_ATR_DST_PORT_OFFSET] << 8;
	*dst_port |= input->byte_stream[IXGBE_ATR_DST_PORT_OFFSET + 1];

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_flex_byte_82599 - Gets the flexible bytes
 *  @@input: input stream to modify
 *  @@flex_bytes: the flexible bytes to load
 **/
int32_t ixgbe_atr_get_flex_byte_82599(struct ixgbe_atr_input *input, uint16_t *flex_byte)
{
	DEBUGFUNC("ixgbe_atr_get_flex_byte_82599");

	*flex_byte = input->byte_stream[IXGBE_ATR_FLEX_BYTE_OFFSET];
	*flex_byte |= input->byte_stream[IXGBE_ATR_FLEX_BYTE_OFFSET + 1] << 8;

	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_vm_pool_82599 - Gets the Virtual Machine pool
 *  @@input: input stream to modify
 *  @@vm_pool: the Virtual Machine pool to load
 **/
int32_t ixgbe_atr_get_vm_pool_82599(struct ixgbe_atr_input *input, uint8_t *vm_pool)
{
	DEBUGFUNC("ixgbe_atr_get_vm_pool_82599");
d1557 2
a1558 1
	*vm_pool = input->byte_stream[IXGBE_ATR_VM_POOL_OFFSET];
d1560 2
a1561 15
	return IXGBE_SUCCESS;
}

/**
 *  ixgbe_atr_get_l4type_82599 - Gets the layer 4 packet type
 *  @@input: input stream to modify
 *  @@l4type: the layer 4 type value to load
 **/
int32_t ixgbe_atr_get_l4type_82599(struct ixgbe_atr_input *input, uint8_t *l4type)
{
	DEBUGFUNC("ixgbe_atr_get_l4type__82599");

	*l4type = input->byte_stream[IXGBE_ATR_L4TYPE_OFFSET];

	return IXGBE_SUCCESS;
d1571 2
a1572 1
                                          struct ixgbe_atr_input *input,
a1576 3
	uint32_t  fdirhash;
	uint16_t  bucket_hash, sig_hash;
	uint8_t   l4type;
d1580 16
a1595 5
	bucket_hash = ixgbe_atr_compute_hash_82599(input,
	                                           IXGBE_ATR_BUCKET_HASH_KEY);

	/* bucket_hash is only 15 bits */
	bucket_hash &= IXGBE_ATR_HASH_MASK;
d1597 5
a1601 6
	sig_hash = ixgbe_atr_compute_hash_82599(input,
	                                        IXGBE_ATR_SIGNATURE_HASH_KEY);

	/* Get the l4type in order to program FDIRCMD properly */
	/* lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6 */
	ixgbe_atr_get_l4type_82599(input, &l4type);
d1607 3
a1609 1
	fdirhash = sig_hash << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT | bucket_hash;
d1611 1
a1611 2
	fdircmd = (IXGBE_FDIRCMD_CMD_ADD_FLOW | IXGBE_FDIRCMD_FILTER_UPDATE |
	           IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN);
d1613 22
a1634 14
	switch (l4type & IXGBE_ATR_L4TYPE_MASK) {
	case IXGBE_ATR_L4TYPE_TCP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_TCP;
		break;
	case IXGBE_ATR_L4TYPE_UDP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_UDP;
		break;
	case IXGBE_ATR_L4TYPE_SCTP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_SCTP;
		break;
	default:
		DEBUGOUT(" Error on l4type input\n");
		return IXGBE_ERR_CONFIG;
	}
d1636 10
a1645 2
	if (l4type & IXGBE_ATR_L4TYPE_IPV6_MASK)
		fdircmd |= IXGBE_FDIRCMD_IPV6;
d1647 2
a1648 2
	fdircmd |= ((uint64_t)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT);
	fdirhashcmd = ((fdircmd << 32) | fdirhash);
d1650 2
a1651 2
	DEBUGOUT2("Tx Queue=%x hash=%x\n", queue, fdirhash & 0x7FFF7FFF);
	IXGBE_WRITE_REG64(hw, IXGBE_FDIRHASH, fdirhashcmd);
a1652 2
	return IXGBE_SUCCESS;
}
d1657 2
a1658 1
 *  @@input: input bitstream
d1665 3
a1667 3
                                        struct ixgbe_atr_input *input,
                                        uint16_t soft_id,
                                        uint8_t queue)
a1668 1
	uint32_t fdircmd = 0;
d1670 6
a1675 5
	uint32_t src_ipv4, dst_ipv4;
	uint32_t src_ipv6_1, src_ipv6_2, src_ipv6_3, src_ipv6_4;
	uint16_t src_port, dst_port, vlan_id, flex_bytes;
	uint16_t bucket_hash;
	uint8_t  l4type;
a1678 3
	/* Get our input values */
	ixgbe_atr_get_l4type_82599(input, &l4type);

d1680 1
a1680 1
	 * Check l4type formatting, and bail out before we touch the hardware
d1683 11
a1693 3
	switch (l4type & IXGBE_ATR_L4TYPE_MASK) {
	case IXGBE_ATR_L4TYPE_TCP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_TCP;
d1695 27
a1721 2
	case IXGBE_ATR_L4TYPE_UDP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_UDP;
d1723 2
a1724 2
	case IXGBE_ATR_L4TYPE_SCTP:
		fdircmd |= IXGBE_FDIRCMD_L4TYPE_SCTP;
d1727 1
a1727 1
		DEBUGOUT(" Error on l4type input\n");
d1731 7
a1737 32
	bucket_hash = ixgbe_atr_compute_hash_82599(input,
	                                           IXGBE_ATR_BUCKET_HASH_KEY);

	/* bucket_hash is only 15 bits */
	bucket_hash &= IXGBE_ATR_HASH_MASK;

	ixgbe_atr_get_vlan_id_82599(input, &vlan_id);
	ixgbe_atr_get_src_port_82599(input, &src_port);
	ixgbe_atr_get_dst_port_82599(input, &dst_port);
	ixgbe_atr_get_flex_byte_82599(input, &flex_bytes);

	fdirhash = soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT | bucket_hash;

	/* Now figure out if we're IPv4 or IPv6 */
	if (l4type & IXGBE_ATR_L4TYPE_IPV6_MASK) {
		/* IPv6 */
		ixgbe_atr_get_src_ipv6_82599(input, &src_ipv6_1, &src_ipv6_2,
	                                     &src_ipv6_3, &src_ipv6_4);

		IXGBE_WRITE_REG(hw, IXGBE_FDIRSIPv6(0), src_ipv6_1);
		IXGBE_WRITE_REG(hw, IXGBE_FDIRSIPv6(1), src_ipv6_2);
		IXGBE_WRITE_REG(hw, IXGBE_FDIRSIPv6(2), src_ipv6_3);
		/* The last 4 bytes is the same register as IPv4 */
		IXGBE_WRITE_REG(hw, IXGBE_FDIRIPSA, src_ipv6_4);

		fdircmd |= IXGBE_FDIRCMD_IPV6;
		fdircmd |= IXGBE_FDIRCMD_IPv6DMATCH;
	} else {
		/* IPv4 */
		ixgbe_atr_get_src_ipv4_82599(input, &src_ipv4);
		IXGBE_WRITE_REG(hw, IXGBE_FDIRIPSA, src_ipv4);

d1740 2
a1741 7
	ixgbe_atr_get_dst_ipv4_82599(input, &dst_ipv4);
	IXGBE_WRITE_REG(hw, IXGBE_FDIRIPDA, dst_ipv4);

	IXGBE_WRITE_REG(hw, IXGBE_FDIRVLAN, (vlan_id |
	                            (flex_bytes << IXGBE_FDIRVLAN_FLEX_SHIFT)));
	IXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, (src_port |
	                       (dst_port << IXGBE_FDIRPORT_DESTINATION_SHIFT)));
d1743 50
a1792 5
	fdircmd |= IXGBE_FDIRCMD_CMD_ADD_FLOW;
	fdircmd |= IXGBE_FDIRCMD_FILTER_UPDATE;
	fdircmd |= IXGBE_FDIRCMD_LAST;
	fdircmd |= IXGBE_FDIRCMD_QUEUE_EN;
	fdircmd |= queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;
d1850 3
a1852 3
 *  Starts the hardware using the generic start_hw function.
 *  Then performs revision-specific operations:
 *  Clears the rate limiter registers.
a1855 2
	uint32_t i;
	uint32_t regval;
d1857 1
d1862 2
d1865 3
a1867 6
	/* Clear the rate limiters */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		IXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, i);
		IXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, 0);
	}
	IXGBE_WRITE_FLUSH(hw);
d1869 2
a1870 6
	/* Disable relaxed ordering */
	for (i = 0; i < hw->mac.max_tx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));
		regval &= ~IXGBE_DCA_TXCTRL_TX_WB_RO_EN;
		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);
	}
d1872 12
a1883 5
	for (i = 0; i < hw->mac.max_rx_queues; i++) {
		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
		regval &= ~(IXGBE_DCA_RXCTRL_DESC_WRO_EN |
			    IXGBE_DCA_RXCTRL_DESC_HSRO_EN);
		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
a1885 3
	/* We need to run link autotry after the driver loads */
	hw->mac.autotry_restart = TRUE;

d1888 1
d1908 8
a1915 2
	if (status != IXGBE_SUCCESS)
		status = ixgbe_identify_sfp_module_generic(hw);
d1926 1
d1946 1
d1952 4
a1955 3
	if (hw->phy.type == ixgbe_phy_tn ||
	    hw->phy.type == ixgbe_phy_aq ||
	    hw->phy.type == ixgbe_phy_cu_unknown) {
d1965 2
d2020 2
a2021 2
	case ixgbe_phy_tw_tyco:
	case ixgbe_phy_tw_unknown:
d2024 4
d2033 2
d2040 2
a2098 17
 *  ixgbe_get_device_caps_82599 - Get additional device capabilities
 *  @@hw: pointer to hardware structure
 *  @@device_caps: the EEPROM word with the extra device capabilities
 *
 *  This function will read the EEPROM location for the device capabilities,
 *  and return the word through device_caps.
 **/
int32_t ixgbe_get_device_caps_82599(struct ixgbe_hw *hw, uint16_t *device_caps)
{
	DEBUGFUNC("ixgbe_get_device_caps_82599");

	hw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);

	return IXGBE_SUCCESS;
}

/**
d2147 46
@


1.1
log
@Add support for 82599 devices based on changes to the FreeBSD driver.

Tested by deraadt on a HotLava card and myself with an Intel X520
and a CX4 82598.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d413 1
@

