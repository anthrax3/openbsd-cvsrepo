head	1.22;
access;
symbols
	OPENBSD_6_1:1.22.0.2
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.42
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.30
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.38
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.36
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.34
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.32
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.28
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.26
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.24
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.22
	OPENBSD_5_0:1.21.0.20
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.18
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.16
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.12
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.14
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.10
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.8
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.6
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.4
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.6
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.14
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.12
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.10
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2017.03.22.07.21.39;	author jsg;	state Exp;
branches;
next	1.21;
commitid	8YRrqg9ezwqcRglv;

1.21
date	2007.02.21.13.08.22;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.02.19.22.38;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.01.11.17.31;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.12.20.24.39;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.21.17.01.39;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.23.16.06.07;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.07.19.21.40;	author tdeval;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.03.20.52.24;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.08.20.13.18;	author mickey;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.01.27.01.19.10;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.26.22.27.36;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.16.23.35.31;	author d;	state Exp;
branches;
next	1.8;

1.8
date	98.02.03.19.47.13;	author deraadt;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	98.02.03.19.42.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.01.06.02.36.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.01.05.13.35.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.11.28.23.28.10;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.31.03.29.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.23.48.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.40;	author deraadt;	state Exp;
branches;
next	;

1.8.10.1
date	2001.05.14.22.25.52;	author niklas;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2001.07.04.10.42.48;	author niklas;	state Exp;
branches;
next	1.8.10.3;

1.8.10.3
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.8.10.4;

1.8.10.4
date	2003.03.28.00.38.23;	author niklas;	state Exp;
branches;
next	1.8.10.5;

1.8.10.5
date	2003.05.13.19.35.07;	author ho;	state Exp;
branches;
next	;

1.12.4.1
date	2002.01.31.22.55.35;	author niklas;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Add some more PCI classes and subclasses.  Checked against EDK2 as
"PCI Code and ID Assignment Specification" is only available for those
willing to pay thousands of dollars for PDFs.

Prompted by a dmesg from an AMD Zen system which uses class 0x13
(Non-Essential Instrumentation) and System subclass 0x06 (IOMMU).  There
is currently no public documentation for AMD family 17h to reference to
see if this is sane.

ok kettenis@@ on an earlier version
@
text
@/*	$OpenBSD: pci_subr.c,v 1.21 2007/02/21 13:08:22 dlg Exp $	*/
/*	$NetBSD: pci_subr.c,v 1.19 1996/10/13 01:38:29 christos Exp $	*/

/*
 * Copyright (c) 1995, 1996 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCI autoconfiguration support functions.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#ifdef PCIVERBOSE
#include <dev/pci/pcidevs.h>
#include <dev/pci/pcidevs_data.h>
#endif

/*
 * Descriptions of known PCI classes and subclasses.
 *
 * Subclasses are described in the same way as classes, but have a
 * NULL subclass pointer.
 */
struct pci_class {
	const char	*name;
	int		val;		/* as wide as pci_{,sub}class_t */
	const struct pci_class *subclasses;
};

const struct pci_class pci_subclass_prehistoric[] = {
	{ "miscellaneous",	PCI_SUBCLASS_PREHISTORIC_MISC,		},
	{ "VGA",		PCI_SUBCLASS_PREHISTORIC_VGA,		},
	{ 0 }
};

const struct pci_class pci_subclass_mass_storage[] = {
	{ "SCSI",		PCI_SUBCLASS_MASS_STORAGE_SCSI,		},
	{ "IDE",		PCI_SUBCLASS_MASS_STORAGE_IDE,		},
	{ "floppy",		PCI_SUBCLASS_MASS_STORAGE_FLOPPY,	},
	{ "IPI",		PCI_SUBCLASS_MASS_STORAGE_IPI,		},
	{ "RAID",		PCI_SUBCLASS_MASS_STORAGE_RAID,		},
	{ "ATA",		PCI_SUBCLASS_MASS_STORAGE_ATA,		},
	{ "SATA",		PCI_SUBCLASS_MASS_STORAGE_SATA,		},
	{ "SAS",		PCI_SUBCLASS_MASS_STORAGE_SAS,		},
	{ "UFS",		PCI_SUBCLASS_MASS_STORAGE_UFS,		},
	{ "miscellaneous",	PCI_SUBCLASS_MASS_STORAGE_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_network[] = {
	{ "ethernet",		PCI_SUBCLASS_NETWORK_ETHERNET,		},
	{ "token ring",		PCI_SUBCLASS_NETWORK_TOKENRING,		},
	{ "FDDI",		PCI_SUBCLASS_NETWORK_FDDI,		},
	{ "ATM",		PCI_SUBCLASS_NETWORK_ATM,		},
	{ "ISDN",		PCI_SUBCLASS_NETWORK_ISDN,		},
	{ "WorldFip",		PCI_SUBCLASS_NETWORK_WORLDFIP,		},
	{ "PCMIG Multi Computing", PCI_SUBCLASS_NETWORK_PCIMGMULTICOMP,	},
	{ "InfiniBand",		PCI_SUBCLASS_NETWORK_INFINIBAND,	},
	{ "miscellaneous",	PCI_SUBCLASS_NETWORK_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_display[] = {
	{ "VGA",		PCI_SUBCLASS_DISPLAY_VGA,		},
	{ "XGA",		PCI_SUBCLASS_DISPLAY_XGA,		},
	{ "3D",			PCI_SUBCLASS_DISPLAY_3D,		},
	{ "miscellaneous",	PCI_SUBCLASS_DISPLAY_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_multimedia[] = {
	{ "video",		PCI_SUBCLASS_MULTIMEDIA_VIDEO,		},
	{ "audio",		PCI_SUBCLASS_MULTIMEDIA_AUDIO,		},
	{ "telephony",		PCI_SUBCLASS_MULTIMEDIA_TELEPHONY,	},
	{ "hdaudio",		PCI_SUBCLASS_MULTIMEDIA_HDAUDIO,	},
	{ "miscellaneous",	PCI_SUBCLASS_MULTIMEDIA_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_memory[] = {
	{ "RAM",		PCI_SUBCLASS_MEMORY_RAM,		},
	{ "flash",		PCI_SUBCLASS_MEMORY_FLASH,		},
	{ "miscellaneous",	PCI_SUBCLASS_MEMORY_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_bridge[] = {
	{ "host",		PCI_SUBCLASS_BRIDGE_HOST,		},
	{ "ISA",		PCI_SUBCLASS_BRIDGE_ISA,		},
	{ "EISA",		PCI_SUBCLASS_BRIDGE_EISA,		},
	{ "MicroChannel",	PCI_SUBCLASS_BRIDGE_MC,			},
	{ "PCI",		PCI_SUBCLASS_BRIDGE_PCI,		},
	{ "PCMCIA",		PCI_SUBCLASS_BRIDGE_PCMCIA,		},
	{ "NuBus",		PCI_SUBCLASS_BRIDGE_NUBUS,		},
	{ "CardBus",		PCI_SUBCLASS_BRIDGE_CARDBUS,		},
	{ "RACEway",		PCI_SUBCLASS_BRIDGE_RACEWAY,		},
	{ "Semi-transparent PCI", PCI_SUBCLASS_BRIDGE_STPCI,		},
	{ "InfiniBand",		PCI_SUBCLASS_BRIDGE_INFINIBAND,		},
	{ "miscellaneous",	PCI_SUBCLASS_BRIDGE_MISC,		},
	{ "advanced switching",	PCI_SUBCLASS_BRIDGE_AS,			},
	{ 0 },
};

const struct pci_class pci_subclass_communications[] = {
	{ "serial",		PCI_SUBCLASS_COMMUNICATIONS_SERIAL,	},
	{ "parallel",		PCI_SUBCLASS_COMMUNICATIONS_PARALLEL,	},
	{ "multi-port serial",	PCI_SUBCLASS_COMMUNICATIONS_MPSERIAL,	},
	{ "modem",		PCI_SUBCLASS_COMMUNICATIONS_MODEM,	},
	{ "GPIB",		PCI_SUBCLASS_COMMUNICATIONS_GPIB,	},
	{ "smartcard",		PCI_SUBCLASS_COMMUNICATIONS_SMARTCARD,	},
	{ "miscellaneous",	PCI_SUBCLASS_COMMUNICATIONS_MISC,	},
	{ 0 },
};

const struct pci_class pci_subclass_system[] = {
	{ "interrupt",		PCI_SUBCLASS_SYSTEM_PIC,		},
	{ "8237 DMA",		PCI_SUBCLASS_SYSTEM_DMA,		},
	{ "8254 timer",		PCI_SUBCLASS_SYSTEM_TIMER,		},
	{ "RTC",		PCI_SUBCLASS_SYSTEM_RTC,		},
	{ "PCI Hot-Plug",	PCI_SUBCLASS_SYSTEM_PCIHOTPLUG,		},
	{ "SD Host Controller",	PCI_SUBCLASS_SYSTEM_SDHC,		},
	{ "IOMMU",		PCI_SUBCLASS_SYSTEM_IOMMU,		},
	{ "root complex event",	PCI_SUBCLASS_SYSTEM_ROOTCOMPEVENT,	},
	{ "miscellaneous",	PCI_SUBCLASS_SYSTEM_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_input[] = {
	{ "keyboard",		PCI_SUBCLASS_INPUT_KEYBOARD,		},
	{ "digitizer",		PCI_SUBCLASS_INPUT_DIGITIZER,		},
	{ "mouse",		PCI_SUBCLASS_INPUT_MOUSE,		},
	{ "scanner",		PCI_SUBCLASS_INPUT_SCANNER,		},
	{ "game port",		PCI_SUBCLASS_INPUT_GAMEPORT,		},
	{ "miscellaneous",	PCI_SUBCLASS_INPUT_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_dock[] = {
	{ "generic",		PCI_SUBCLASS_DOCK_GENERIC,		},
	{ "miscellaneous",	PCI_SUBCLASS_DOCK_MISC,			},
	{ 0 },
};

const struct pci_class pci_subclass_processor[] = {
	{ "386",		PCI_SUBCLASS_PROCESSOR_386,		},
	{ "486",		PCI_SUBCLASS_PROCESSOR_486,		},
	{ "Pentium",		PCI_SUBCLASS_PROCESSOR_PENTIUM,		},
	{ "Alpha",		PCI_SUBCLASS_PROCESSOR_ALPHA,		},
	{ "PowerPC",		PCI_SUBCLASS_PROCESSOR_POWERPC,		},
	{ "MIPS",		PCI_SUBCLASS_PROCESSOR_MIPS,		},
	{ "Co-processor",	PCI_SUBCLASS_PROCESSOR_COPROC,		},
	{ 0 },
};

const struct pci_class pci_subclass_serialbus[] = {
	{ "Firewire",		PCI_SUBCLASS_SERIALBUS_FIREWIRE,	},
	{ "ACCESS.bus",		PCI_SUBCLASS_SERIALBUS_ACCESS,		},
	{ "SSA",		PCI_SUBCLASS_SERIALBUS_SSA,		},
	{ "USB",		PCI_SUBCLASS_SERIALBUS_USB,		},
	/* XXX Fiber Channel/_FIBRECHANNEL */
	{ "Fiber Channel",	PCI_SUBCLASS_SERIALBUS_FIBER,		},
	{ "SMBus",		PCI_SUBCLASS_SERIALBUS_SMBUS,		},
	{ "InfiniBand",		PCI_SUBCLASS_SERIALBUS_INFINIBAND,	},
	{ "IPMI",		PCI_SUBCLASS_SERIALBUS_IPMI,		},
	{ "SERCOS",		PCI_SUBCLASS_SERIALBUS_SERCOS,		},
	{ "CANbus",		PCI_SUBCLASS_SERIALBUS_CANBUS,		},
	{ 0 },
};

const struct pci_class pci_subclass_wireless[] = {
	{ "IrDA",		PCI_SUBCLASS_WIRELESS_IRDA,		},
	{ "Consumer IR",	PCI_SUBCLASS_WIRELESS_CONSUMERIR,	},
	{ "RF",			PCI_SUBCLASS_WIRELESS_RF,		},
	{ "bluetooth",		PCI_SUBCLASS_WIRELESS_BLUETOOTH,	},
	{ "broadband",		PCI_SUBCLASS_WIRELESS_BROADBAND,	},
	{ "802.11a (5 GHz)",	PCI_SUBCLASS_WIRELESS_802_11A,		},
	{ "802.11b (2.4 GHz)",	PCI_SUBCLASS_WIRELESS_802_11B,		},
	{ "miscellaneous",	PCI_SUBCLASS_WIRELESS_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_i2o[] = {
	{ "standard",		PCI_SUBCLASS_I2O_STANDARD,		},
	{ 0 },
};

const struct pci_class pci_subclass_satcom[] = {
	{ "TV",			PCI_SUBCLASS_SATCOM_TV,			},
	{ "audio",		PCI_SUBCLASS_SATCOM_AUDIO,		},
	{ "voice",		PCI_SUBCLASS_SATCOM_VOICE,		},
	{ "data",		PCI_SUBCLASS_SATCOM_DATA,		},
	{ 0 },
};

const struct pci_class pci_subclass_crypto[] = {
	{ "network/computing",	PCI_SUBCLASS_CRYPTO_NETCOMP,		},
	{ "entertainment",	PCI_SUBCLASS_CRYPTO_ENTERTAINMENT,	},
	{ "miscellaneous",	PCI_SUBCLASS_CRYPTO_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_dasp[] = {
	{ "DPIO",		PCI_SUBCLASS_DASP_DPIO,			},
	{ "Time and Frequency",	PCI_SUBCLASS_DASP_TIMEFREQ,		},
	{ "synchronization",	PCI_SUBCLASS_DASP_SYNC,			},
	{ "management",		PCI_SUBCLASS_DASP_MGMT,			},
	{ "miscellaneous",	PCI_SUBCLASS_DASP_MISC,			},
	{ 0 },
};

const struct pci_class pci_class[] = {
	{ "prehistoric",	PCI_CLASS_PREHISTORIC,
	    pci_subclass_prehistoric,				},
	{ "mass storage",	PCI_CLASS_MASS_STORAGE,
	    pci_subclass_mass_storage,				},
	{ "network",		PCI_CLASS_NETWORK,
	    pci_subclass_network,				},
	{ "display",		PCI_CLASS_DISPLAY,
	    pci_subclass_display,				},
	{ "multimedia",		PCI_CLASS_MULTIMEDIA,
	    pci_subclass_multimedia,				},
	{ "memory",		PCI_CLASS_MEMORY,
	    pci_subclass_memory,				},
	{ "bridge",		PCI_CLASS_BRIDGE,
	    pci_subclass_bridge,				},
	{ "communications",	PCI_CLASS_COMMUNICATIONS,
	    pci_subclass_communications,			},
	{ "system",		PCI_CLASS_SYSTEM,
	    pci_subclass_system,				},
	{ "input",		PCI_CLASS_INPUT,
	    pci_subclass_input,					},
	{ "dock",		PCI_CLASS_DOCK,
	    pci_subclass_dock,					},
	{ "processor",		PCI_CLASS_PROCESSOR,
	    pci_subclass_processor,				},
	{ "serial bus",		PCI_CLASS_SERIALBUS,
	    pci_subclass_serialbus,				},
	{ "wireless",		PCI_CLASS_WIRELESS,
	    pci_subclass_wireless,				},
	{ "I2O",		PCI_CLASS_I2O,
	    pci_subclass_i2o,					},
	{ "satellite comm",	PCI_CLASS_SATCOM,
	    pci_subclass_satcom,				},
	{ "crypto",		PCI_CLASS_CRYPTO,
	    pci_subclass_crypto,				},
	{ "DASP",		PCI_CLASS_DASP,
	    pci_subclass_dasp,					},
	{ "accelerator",	PCI_CLASS_ACCELERATOR,
	    NULL,						},
	{ "instrumentation",	PCI_CLASS_INSTRUMENTATION,
	    NULL,						},
	{ "undefined",		PCI_CLASS_UNDEFINED,
	    0,							},
	{ 0 },
};

const char *
pci_findvendor(pcireg_t id_reg)
{
#ifdef PCIVERBOSE
	pci_vendor_id_t vendor = PCI_VENDOR(id_reg);
	const struct pci_known_vendor *kdp;

	kdp = pci_known_vendors;
        while (kdp->vendorname != NULL) {	/* all have vendor name */
                if (kdp->vendor == vendor)
                        break;
		kdp++;
	}
        return (kdp->vendorname);
#else
	return (NULL);
#endif
}

const char *
pci_findproduct(pcireg_t id_reg)
{
#ifdef PCIVERBOSE
	pci_vendor_id_t vendor = PCI_VENDOR(id_reg);
	pci_product_id_t product = PCI_PRODUCT(id_reg);
	const struct pci_known_product *pkp;

	pkp = pci_known_products;
	while (pkp->productname != NULL) {	/* all have product name */
		if (pkp->vendor == vendor && pkp->product == product)
			break;
		pkp++;
	}
	return (pkp->productname);
#else
	return NULL;
#endif
}

void
pci_devinfo(pcireg_t id_reg, pcireg_t class_reg, int showclass, char *cp,
	    size_t cp_max)
{
	pci_vendor_id_t vendor;
	pci_product_id_t product;
	pci_class_t class;
	pci_subclass_t subclass;
	pci_interface_t interface;
	pci_revision_t revision;
	const char *vendor_namep = NULL, *product_namep = NULL;
	const struct pci_class *classp, *subclassp;
	size_t cp_len = 0;
#ifdef PCIVERBOSE
	const char *unmatched = "unknown ";
#else
	const char *unmatched = "";
#endif

	vendor = PCI_VENDOR(id_reg);
	product = PCI_PRODUCT(id_reg);

	class = PCI_CLASS(class_reg);
	subclass = PCI_SUBCLASS(class_reg);
	interface = PCI_INTERFACE(class_reg);
	revision = PCI_REVISION(class_reg);

#ifdef PCIVERBOSE
	vendor_namep = pci_findvendor(id_reg);
	if (vendor_namep != NULL)
		product_namep = pci_findproduct(id_reg);
#endif /* PCIVERBOSE */

	classp = pci_class;
	while (classp->name != NULL) {
		if (class == classp->val)
			break;
		classp++;
	}

	subclassp = (classp->name != NULL) ? classp->subclasses : NULL;
	while (subclassp && subclassp->name != NULL) {
		if (subclass == subclassp->val)
			break;
		subclassp++;
	}

	if (vendor_namep == NULL)
		snprintf(cp, cp_max, "%svendor 0x%04x product 0x%04x",
		    unmatched, vendor, product);
	else if (product_namep != NULL)
		snprintf(cp, cp_max, "\"%s %s\"", vendor_namep, product_namep);
	else
		snprintf(cp, cp_max, "vendor \"%s\", unknown product 0x%04x",
		    vendor_namep, product);
	if (showclass && product_namep == NULL) {
		strlcat(cp, " (", cp_max);
		cp_len = strlen(cp);
		if (classp->name == NULL)
			snprintf(cp + cp_len, cp_max - cp_len,
			    "unknown class 0x%02x, subclass 0x%02x",
			    class, subclass);
		else if (subclassp == NULL || subclassp->name == NULL)
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s unknown subclass 0x%02x", classp->name,
			    subclass);
		else
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s subclass %s", classp->name,
			    subclassp->name);
#if 0 /* not very useful */
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", interface 0x%02x", interface);
#endif
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", rev 0x%02x)", revision);
	} else {
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len, " rev 0x%02x",
		    revision);
	}
}
@


1.21
log
@put the structs defining the content of pcidevs_data.h into that header
file, rather than in pci_subr.c before theyre used. this allows the header
to be used elsewhere without needing to copy a chunk out of pci_subr.c.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.19 2006/06/01 11:17:31 brad Exp $	*/
d76 1
d89 1
d131 1
d153 2
d279 4
@


1.20
log
@Provide a new function, pci_findproduct(), which is analog to pci_findvendor().
Use these two functions in pci_devinfo() to remove some duplicated code and
make it easier to read.  Remove two now unused variables.  This shrinks the
size of the resulting object code.

Drivers (or other kernel code) can now get at the PCI vendor and/or product
strings using pci_findvendor() and pci_findproduct().

ok claudio, deraadt, mglocker
@
text
@d46 1
a277 18

#ifdef PCIVERBOSE
/*
 * Descriptions of known vendors and devices ("products").
 */
struct pci_known_vendor {
	pci_vendor_id_t		vendor;
	const char		*vendorname;
};

struct pci_known_product {
	pci_vendor_id_t		vendor;
	pci_product_id_t	product;
	const char		*productname;
};

#include <dev/pci/pcidevs_data.h>
#endif /* PCIVERBOSE */
@


1.19
log
@add 2 subclasses, subclass storage SAS and subclass system SD Host Controller.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.18 2006/05/12 20:24:39 brad Exp $	*/
d315 20
a348 2
	const struct pci_known_vendor *pkv;
	const struct pci_known_product *pkp;
d363 3
a365 18
	pkv = pci_known_vendors;
	while (pkv->vendorname != NULL) {	/* all have vendor name */
		if (pkv->vendor == vendor) {
			vendor_namep = pkv->vendorname;
			break;
		}
		pkv++;
	}
	if (vendor_namep) {
		pkp = pci_known_products;
		while (pkp->productname != NULL) {	/* all have product name */
			if (pkp->vendor == vendor && pkp->product == product) {
				product_namep = pkp->productname;
				break;
			}
			pkp++;
		}
	}
@


1.18
log
@add the PCI hdaudio subclass.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.17 2004/11/21 17:01:39 grange Exp $	*/
d74 1
d148 1
@


1.17
log
@Better printf for unknown product id.

ok todd@@ tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.16 2004/10/23 16:06:07 brad Exp $	*/
d102 1
@


1.16
log
@add subclass codes from the 2.3 spec

From NetBSD

ok jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.15 2003/04/27 11:22:53 ho Exp $	*/
d382 1
a382 1
		snprintf(cp, cp_max, "vendor \"%s\", unknown product 0x%x",
@


1.15
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.14 2002/04/07 19:21:40 tdeval Exp $	*/
d73 1
d134 2
d141 1
a141 1
	{ "8259 PIC",		PCI_SUBCLASS_SYSTEM_PIC,		},
d196 4
d227 2
@


1.14
log
@Typo.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.13 2002/01/03 20:52:24 nate Exp $	*/
d304 2
a305 4
pci_devinfo(id_reg, class_reg, showclass, cp)
	pcireg_t id_reg, class_reg;
	int showclass;
	char *cp;
d315 1
d368 1
a368 1
		cp += sprintf(cp, "%svendor 0x%04x product 0x%04x",
d371 1
a371 1
		cp += sprintf(cp, "\"%s %s\"", vendor_namep, product_namep);
d373 1
a373 1
		cp += sprintf(cp, "vendor \"%s\", unknown product 0x%x",
d376 2
a377 1
		cp += sprintf(cp, " (");
d379 1
a379 1
			cp += sprintf(cp,
d382 8
a389 9
		else {
			cp += sprintf(cp, "class %s, ", classp->name);
			if (subclassp == NULL || subclassp->name == NULL)
				cp += sprintf(cp, "unknown subclass 0x%02x",
				    subclass);
			else
				cp += sprintf(cp, "subclass %s",
				    subclassp->name);
		}
d391 3
a393 1
		cp += sprintf(cp, ", interface 0x%02x", interface);
d395 8
a402 3
		cp += sprintf(cp, ", rev 0x%02x)", revision);
	} else
		cp += sprintf(cp, " rev 0x%02x", revision);
@


1.13
log
@Add the pci_findvendor function
If compiled with PCI_VERBOSE, this function looks up a vendor string based
on a vendor id.  Otherwise, it returns NULL.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.12 2001/05/08 20:13:18 mickey Exp $	*/
d268 1
a268 1
 * Descriptions of of known vendors and devices ("products").
@


1.12
log
@string names for those new classes/subclasses; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.11 2001/01/27 01:19:10 deraadt Exp $	*/
d283 19
@


1.12.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.13 2002/01/03 20:52:24 nate Exp $	*/
a282 19

const char *
pci_findvendor(pcireg_t id_reg)
{
#ifdef PCIVERBOSE
	pci_vendor_id_t vendor = PCI_VENDOR(id_reg);
	const struct pci_known_vendor *kdp;

	kdp = pci_known_vendors;
        while (kdp->vendorname != NULL) {	/* all have vendor name */
                if (kdp->vendor == vendor)
                        break;
		kdp++;
	}
        return (kdp->vendorname);
#else
	return (NULL);
#endif
}
@


1.12.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.12.4.1 2002/01/31 22:55:35 niklas Exp $	*/
d268 1
a268 1
 * Descriptions of known vendors and devices ("products").
@


1.12.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 4
a307 2
pci_devinfo(pcireg_t id_reg, pcireg_t class_reg, int showclass, char *cp,
	    size_t cp_max)
a316 1
	size_t cp_len = 0;
d369 1
a369 1
		snprintf(cp, cp_max, "%svendor 0x%04x product 0x%04x",
d372 1
a372 1
		snprintf(cp, cp_max, "\"%s %s\"", vendor_namep, product_namep);
d374 1
a374 1
		snprintf(cp, cp_max, "vendor \"%s\", unknown product 0x%x",
d377 1
a377 2
		strlcat(cp, " (", cp_max);
		cp_len = strlen(cp);
d379 1
a379 1
			snprintf(cp + cp_len, cp_max - cp_len,
d382 9
a390 8
		else if (subclassp == NULL || subclassp->name == NULL)
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s unknown subclass 0x%02x", classp->name,
			    subclass);
		else
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s subclass %s", classp->name,
			    subclassp->name);
d392 1
a392 3
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", interface 0x%02x", interface);
d394 3
a396 8
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", rev 0x%02x)", revision);
	} else {
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len, " rev 0x%02x",
		    revision);
	}
@


1.11
log
@split vendor & product lists into 2 tables, saving 12K
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.10 2001/01/26 22:27:36 mickey Exp $	*/
d72 1
d82 3
d92 1
d100 1
d121 3
d131 2
d142 1
d151 2
d169 1
d179 1
d181 40
d251 10
@


1.10
log
@constify pci_knowndevs
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.9 2001/01/16 23:35:31 d Exp $	*/
d204 6
a209 1
struct pci_knowndev {
d212 1
a212 2
	int			flags;
	const char		*vendorname, *productname;
a213 1
#define	PCI_KNOWNDEV_NOPROD	0x01		/* match on vendor only */
d230 1
a230 1
	const char *vendor_namep, *product_namep;
d233 2
a234 1
	const struct pci_knowndev *kdp;
d249 17
a265 6
	kdp = pci_knowndevs;
        while (kdp->vendorname != NULL) {	/* all have vendor name */
                if (kdp->vendor == vendor && (kdp->product == product ||
		    (kdp->flags & PCI_KNOWNDEV_NOPROD) != 0))
                        break;
		kdp++;
a266 9
        if (kdp->vendorname == NULL)
		vendor_namep = product_namep = NULL;
	else {
		vendor_namep = kdp->vendorname;
		product_namep = (kdp->flags & PCI_KNOWNDEV_NOPROD) == 0 ?
		    kdp->productname : NULL;
        }
#else /* PCIVERBOSE */
	vendor_namep = product_namep = NULL;
@


1.9
log
@"0x 2" -> "0x02"
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.8 1998/02/03 19:47:13 deraadt Exp $	*/
d55 1
a55 1
	char		*name;
d57 1
a57 1
	struct pci_class *subclasses;
d60 1
a60 1
struct pci_class pci_subclass_prehistoric[] = {
d66 1
a66 1
struct pci_class pci_subclass_mass_storage[] = {
d76 1
a76 1
struct pci_class pci_subclass_network[] = {
d85 1
a85 1
struct pci_class pci_subclass_display[] = {
d92 1
a92 1
struct pci_class pci_subclass_multimedia[] = {
d99 1
a99 1
struct pci_class pci_subclass_memory[] = {
d106 1
a106 1
struct pci_class pci_subclass_bridge[] = {
d119 1
a119 1
struct pci_class pci_subclass_communications[] = {
d126 1
a126 1
struct pci_class pci_subclass_system[] = {
d135 1
a135 1
struct pci_class pci_subclass_input[] = {
d143 1
a143 1
struct pci_class pci_subclass_dock[] = {
d149 1
a149 1
struct pci_class pci_subclass_processor[] = {
d159 1
a159 1
struct pci_class pci_subclass_serialbus[] = {
d168 1
a168 1
struct pci_class pci_class[] = {
d208 1
a208 1
	char			*vendorname, *productname;
d227 2
a228 2
	char *vendor_namep, *product_namep;
	struct pci_class *classp, *subclassp;
d230 1
a230 1
	struct pci_knowndev *kdp;
@


1.8
log
@more pci subclasses and such; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.7 1998/02/03 19:42:04 deraadt Exp $	*/
d289 1
a289 1
			    "unknown class 0x%2x, subclass 0x%02x",
@


1.8.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.11 2001/01/27 01:19:10 deraadt Exp $	*/
d55 1
a55 1
	const char	*name;
d57 1
a57 1
	const struct pci_class *subclasses;
d60 1
a60 1
const struct pci_class pci_subclass_prehistoric[] = {
d66 1
a66 1
const struct pci_class pci_subclass_mass_storage[] = {
d76 1
a76 1
const struct pci_class pci_subclass_network[] = {
d85 1
a85 1
const struct pci_class pci_subclass_display[] = {
d92 1
a92 1
const struct pci_class pci_subclass_multimedia[] = {
d99 1
a99 1
const struct pci_class pci_subclass_memory[] = {
d106 1
a106 1
const struct pci_class pci_subclass_bridge[] = {
d119 1
a119 1
const struct pci_class pci_subclass_communications[] = {
d126 1
a126 1
const struct pci_class pci_subclass_system[] = {
d135 1
a135 1
const struct pci_class pci_subclass_input[] = {
d143 1
a143 1
const struct pci_class pci_subclass_dock[] = {
d149 1
a149 1
const struct pci_class pci_subclass_processor[] = {
d159 1
a159 1
const struct pci_class pci_subclass_serialbus[] = {
d168 1
a168 1
const struct pci_class pci_class[] = {
d204 1
a204 6
struct pci_known_vendor {
	pci_vendor_id_t		vendor;
	const char		*vendorname;
};

struct pci_known_product {
d207 2
a208 1
	const char		*productname;
d210 1
d227 2
a228 2
	const char *vendor_namep = NULL, *product_namep = NULL;
	const struct pci_class *classp, *subclassp;
d230 1
a230 2
	const struct pci_known_vendor *pkv;
	const struct pci_known_product *pkp;
d245 6
a250 17
	pkv = pci_known_vendors;
	while (pkv->vendorname != NULL) {	/* all have vendor name */
		if (pkv->vendor == vendor) {
			vendor_namep = pkv->vendorname;
			break;
		}
		pkv++;
	}
	if (vendor_namep) {
		pkp = pci_known_products;
		while (pkp->productname != NULL) {	/* all have product name */
			if (pkp->vendor == vendor && pkp->product == product) {
				product_namep = pkp->productname;
				break;
			}
			pkp++;
		}
d252 9
d289 1
a289 1
			    "unknown class 0x%02x, subclass 0x%02x",
@


1.8.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.8.10.1 2001/05/14 22:25:52 niklas Exp $	*/
a71 1
	{ "ATA",		PCI_SUBCLASS_MASS_STORAGE_ATA,		},
a80 3
	{ "ISDN",		PCI_SUBCLASS_NETWORK_ISDN,		},
	{ "WorldFip",		PCI_SUBCLASS_NETWORK_WORLDFIP,		},
	{ "PCMIG Multi Computing", PCI_SUBCLASS_NETWORK_PCIMGMULTICOMP,	},
a87 1
	{ "3D",			PCI_SUBCLASS_DISPLAY_3D,		},
a94 1
	{ "telephony",		PCI_SUBCLASS_MULTIMEDIA_TELEPHONY,	},
a114 3
	{ "RACEway",		PCI_SUBCLASS_BRIDGE_RACEWAY,		},
	{ "Semi-transparent PCI", PCI_SUBCLASS_BRIDGE_STPCI,		},
	{ "InfiniBand",		PCI_SUBCLASS_BRIDGE_INFINIBAND,		},
a121 2
	{ "multi-port serial",	PCI_SUBCLASS_COMMUNICATIONS_MPSERIAL,	},
	{ "modem",		PCI_SUBCLASS_COMMUNICATIONS_MODEM,	},
a130 1
	{ "PCI Hot-Plug",	PCI_SUBCLASS_SYSTEM_PCIHOTPLUG,		},
a138 2
	{ "scanner",		PCI_SUBCLASS_INPUT_SCANNER,		},
	{ "game port",		PCI_SUBCLASS_INPUT_GAMEPORT,		},
a154 1
	{ "MIPS",		PCI_SUBCLASS_PROCESSOR_MIPS,		},
a163 1
	/* XXX Fiber Channel/_FIBRECHANNEL */
a164 40
	{ "SMBus",		PCI_SUBCLASS_SERIALBUS_SMBUS,		},
	{ "InfiniBand",		PCI_SUBCLASS_SERIALBUS_INFINIBAND,	},
	{ "IPMI",		PCI_SUBCLASS_SERIALBUS_IPMI,		},
	{ "SERCOS",		PCI_SUBCLASS_SERIALBUS_SERCOS,		},
	{ "CANbus",		PCI_SUBCLASS_SERIALBUS_CANBUS,		},
	{ 0 },
};

const struct pci_class pci_subclass_wireless[] = {
	{ "IrDA",		PCI_SUBCLASS_WIRELESS_IRDA,		},
	{ "Consumer IR",	PCI_SUBCLASS_WIRELESS_CONSUMERIR,	},
	{ "RF",			PCI_SUBCLASS_WIRELESS_RF,		},
	{ "miscellaneous",	PCI_SUBCLASS_WIRELESS_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_i2o[] = {
	{ "standard",		PCI_SUBCLASS_I2O_STANDARD,		},
	{ 0 },
};

const struct pci_class pci_subclass_satcom[] = {
	{ "TV",			PCI_SUBCLASS_SATCOM_TV,			},
	{ "audio",		PCI_SUBCLASS_SATCOM_AUDIO,		},
	{ "voice",		PCI_SUBCLASS_SATCOM_VOICE,		},
	{ "data",		PCI_SUBCLASS_SATCOM_DATA,		},
	{ 0 },
};

const struct pci_class pci_subclass_crypto[] = {
	{ "network/computing",	PCI_SUBCLASS_CRYPTO_NETCOMP,		},
	{ "entertainment",	PCI_SUBCLASS_CRYPTO_ENTERTAINMENT,	},
	{ "miscellaneous",	PCI_SUBCLASS_CRYPTO_MISC,		},
	{ 0 },
};

const struct pci_class pci_subclass_dasp[] = {
	{ "DPIO",		PCI_SUBCLASS_DASP_DPIO,			},
	{ "Time and Frequency",	PCI_SUBCLASS_DASP_TIMEFREQ,		},
	{ "miscellaneous",	PCI_SUBCLASS_DASP_MISC,			},
a194 10
	{ "wireless",		PCI_CLASS_WIRELESS,
	    pci_subclass_wireless,				},
	{ "I2O",		PCI_CLASS_I2O,
	    pci_subclass_i2o,					},
	{ "satellite comm",	PCI_CLASS_SATCOM,
	    pci_subclass_satcom,				},
	{ "crypto",		PCI_CLASS_CRYPTO,
	    pci_subclass_crypto,				},
	{ "DASP",		PCI_CLASS_DASP,
	    pci_subclass_dasp,					},
@


1.8.10.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a282 19

const char *
pci_findvendor(pcireg_t id_reg)
{
#ifdef PCIVERBOSE
	pci_vendor_id_t vendor = PCI_VENDOR(id_reg);
	const struct pci_known_vendor *kdp;

	kdp = pci_known_vendors;
        while (kdp->vendorname != NULL) {	/* all have vendor name */
                if (kdp->vendor == vendor)
                        break;
		kdp++;
	}
        return (kdp->vendorname);
#else
	return (NULL);
#endif
}
@


1.8.10.4
log
@Sync the SMP branch with 3.3
@
text
@d268 1
a268 1
 * Descriptions of known vendors and devices ("products").
@


1.8.10.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.8.10.4 2003/03/28 00:38:23 niklas Exp $	*/
d304 4
a307 2
pci_devinfo(pcireg_t id_reg, pcireg_t class_reg, int showclass, char *cp,
	    size_t cp_max)
a316 1
	size_t cp_len = 0;
d369 1
a369 1
		snprintf(cp, cp_max, "%svendor 0x%04x product 0x%04x",
d372 1
a372 1
		snprintf(cp, cp_max, "\"%s %s\"", vendor_namep, product_namep);
d374 1
a374 1
		snprintf(cp, cp_max, "vendor \"%s\", unknown product 0x%x",
d377 1
a377 2
		strlcat(cp, " (", cp_max);
		cp_len = strlen(cp);
d379 1
a379 1
			snprintf(cp + cp_len, cp_max - cp_len,
d382 9
a390 8
		else if (subclassp == NULL || subclassp->name == NULL)
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s unknown subclass 0x%02x", classp->name,
			    subclass);
		else
			snprintf(cp + cp_len, cp_max - cp_len,
			    "class %s subclass %s", classp->name,
			    subclassp->name);
d392 1
a392 3
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", interface 0x%02x", interface);
d394 3
a396 8
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len,
		    ", rev 0x%02x)", revision);
	} else {
		cp_len = strlen(cp);
		snprintf(cp + cp_len, cp_max - cp_len, " rev 0x%02x",
		    revision);
	}
@


1.7
log
@more bridge types
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.6 1998/01/06 02:36:43 deraadt Exp $	*/
d71 1
d119 49
d183 12
@


1.6
log
@even cleaner
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.5 1998/01/05 13:35:23 deraadt Exp $	*/
d112 2
@


1.5
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.4 1996/11/28 23:28:10 niklas Exp $	*/
d241 1
a241 1
		cp += sprintf(cp, " (rev 0x%02x)", revision);
@


1.4
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_subr.c,v 1.3 1996/10/31 03:29:11 millert Exp $	*/
d217 1
a217 1
		cp += sprintf(cp, "%s %s", vendor_namep, product_namep);
d219 1
a219 1
		cp += sprintf(cp, "vendor %s, unknown product 0x%x",
d221 1
a221 1
	if (showclass) {
d239 3
a241 2
		cp += sprintf(cp, ", revision 0x%02x)", revision);
	}
@


1.3
log
@Add ATM defines.  From Jim Rees <rees@@umich.edu>
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_subr.c,v 1.2 1996/04/18 23:48:03 niklas Exp $	*/
/*	$NetBSD: pci_subr.c,v 1.17 1996/03/02 02:28:48 cgd Exp $	*/
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: pci_subr.c,v 1.12 1995/08/16 04:54:50 cgd Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Christopher G. Demetriou.  All rights reserved.
a47 73
int
pciprint(aux, pci)
	void *aux;
	char *pci;
{
	register struct pci_attach_args *pa = aux;

	printf(" bus %d device %d", pa->pa_bus, pa->pa_device);
	return (UNCONF);
}

int
pcisubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct pci_attach_args *pa = aux;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != pa->pa_bus)
		return 0;
	if (cf->cf_loc[1] != -1 && cf->cf_loc[1] != pa->pa_device)
		return 0;
	return ((*cf->cf_driver->cd_match)(parent, match, aux));
}

/*
 * Try to find and attach the PCI device at the give bus and device number.
 * Return 1 if successful, 0 if unsuccessful.
 */
int
pci_attach_subdev(pcidev, bus, device)
	struct device *pcidev;
	int bus, device;
{
	pcitag_t tag;
	pcireg_t id, class;
	struct pci_attach_args pa;
	struct cfdata *cf;
	int supported;
	char devinfo[256];

	tag = pci_make_tag(bus, device, 0);
	id = pci_conf_read(tag, PCI_ID_REG);
	if (id == 0 || id == 0xffffffff)
		return (0);
	class = pci_conf_read(tag, PCI_CLASS_REG);

	pa.pa_bus = bus;
	pa.pa_device = device;
	pa.pa_tag = tag;
	pa.pa_id = id;
	pa.pa_class = class;

#if defined(PCIVERBOSE) && 0 /* _too_ verbose */
	pci_devinfo(id, class, devinfo, NULL);
	printf("%s bus %d device %d: %s\n", pcidev->dv_xname, bus,
	    device, devinfo);
#endif /* _too_ verbose */

	if ((cf = config_search(pcisubmatch, pcidev, &pa)) != NULL)
		config_attach(pcidev, cf, &pa, pciprint);
	else {
		pci_devinfo(id, class, devinfo, &supported);
		printf("%s bus %d device %d: %s not %s\n", pcidev->dv_xname,
		    bus, device, devinfo,
		    supported ? "configured" : "supported");
		return (0);
	}

	return (1);
}

d145 1
a145 2
#define	PCI_KNOWNDEV_UNSUPP	0x01		/* unsupported device */
#define	PCI_KNOWNDEV_NOPROD	0x02		/* match on vendor only */
d151 1
a151 1
pci_devinfo(id_reg, class_reg, cp, supp)
d153 1
a154 1
	int *supp;
d166 3
d187 1
a187 1
        if (kdp->vendorname == NULL) {
d189 1
a189 3
		if (supp != NULL)
			*supp = 0;
        } else {
a192 2
		if (supp != NULL)
			*supp = (kdp->flags & PCI_KNOWNDEV_UNSUPP) == 0;
a195 2
	if (supp != NULL)
		*supp = 1;		/* always say 'not configured' */
d213 2
a214 2
		cp += sprintf(cp, "unknown vendor/product: 0x%04x/0x%04x",
		    vendor, product);
d218 1
a218 1
		cp += sprintf(cp, "vendor: %s, unknown product: 0x%x",
d220 15
a234 12
	cp += sprintf(cp, " (");
	if (classp->name == NULL)
		cp += sprintf(cp, "unknown class/subclass: 0x%02x/0x%02x",
		    class, subclass);
	else {
		cp += sprintf(cp, "class: %s, ", classp->name);
		if (subclassp == NULL || subclassp->name == NULL)
			cp += sprintf(cp, "unknown subclass: 0x%02x",
			    subclass);
		else
			cp += sprintf(cp, "subclass: %s", subclassp->name);
	}
d236 1
a236 1
	cp += sprintf(cp, ", interface: 0x%02x", interface);
d238 2
a239 1
	cp += sprintf(cp, ", revision: 0x%02x)", revision);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
