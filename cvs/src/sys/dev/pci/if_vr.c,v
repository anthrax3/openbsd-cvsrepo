head	1.153;
access;
symbols
	OPENBSD_6_1:1.153.0.2
	OPENBSD_6_1_BASE:1.153
	OPENBSD_6_0:1.152.0.4
	OPENBSD_6_0_BASE:1.152
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.141.0.4
	OPENBSD_5_8_BASE:1.141
	OPENBSD_5_7:1.137.0.4
	OPENBSD_5_7_BASE:1.137
	OPENBSD_5_6:1.135.0.4
	OPENBSD_5_6_BASE:1.135
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.128.0.2
	OPENBSD_5_4_BASE:1.128
	OPENBSD_5_3:1.127.0.2
	OPENBSD_5_3_BASE:1.127
	OPENBSD_5_2:1.114.0.4
	OPENBSD_5_2_BASE:1.114
	OPENBSD_5_1_BASE:1.114
	OPENBSD_5_1:1.114.0.2
	OPENBSD_5_0:1.111.0.2
	OPENBSD_5_0_BASE:1.111
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.97.0.4
	OPENBSD_4_6_BASE:1.97
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.67.0.4
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.67.0.2
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.64.0.2
	OPENBSD_4_0_BASE:1.64
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.45.0.2
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.31.0.4
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.31
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.26
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.153
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.152;
commitid	VyLWTsbepAOk7VQM;

1.152
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.151;
commitid	8YSL8ByWzGeIGBiJ;

1.151
date	2016.03.15.16.45.52;	author naddy;	state Exp;
branches;
next	1.150;
commitid	X5t9omeXAp1mh2AJ;

1.150
date	2016.01.26.01.52.10;	author dlg;	state Exp;
branches;
next	1.149;
commitid	DXADCkrE2fsGcLfX;

1.149
date	2016.01.26.01.51.33;	author dlg;	state Exp;
branches;
next	1.148;
commitid	G3s15Uvp3OvVG8yd;

1.148
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.147;
commitid	B0kwmVGiD5DVx4kv;

1.147
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.146;
commitid	5gdEnqVoJuTuwdTu;

1.146
date	2015.11.24.12.32.53;	author mpi;	state Exp;
branches;
next	1.145;
commitid	N4FwuXZDsGAH4cQz;

1.145
date	2015.11.09.00.22.57;	author dlg;	state Exp;
branches;
next	1.144;
commitid	wwK6FrEGh9clvRWT;

1.144
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.143;
commitid	hPF95ClMUQfeqQDX;

1.143
date	2015.10.20.17.08.39;	author chrisz;	state Exp;
branches;
next	1.142;
commitid	dHvRleKtOmi6SxLB;

1.142
date	2015.09.12.10.15.10;	author miod;	state Exp;
branches;
next	1.141;
commitid	7nT32okhwAwISbr0;

1.141
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.140;
commitid	MVWrtktB46JRxFWT;

1.140
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.139;
commitid	aiRvgNOa4qke9vft;

1.139
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.138;
commitid	p4LJxGKbi0BU2cG6;

1.138
date	2015.03.13.15.58.22;	author jasper;	state Exp;
branches;
next	1.137;
commitid	5tCIXfdbDpsXvJ4R;

1.137
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.136;
commitid	yM2VFFhpDTeFQlve;

1.136
date	2014.11.27.03.49.07;	author brad;	state Exp;
branches;
next	1.135;
commitid	RrUGMvCniSWte40f;

1.135
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.134;
commitid	TGHgrLxu6sxZoiFt;

1.134
date	2014.07.08.05.35.19;	author dlg;	state Exp;
branches;
next	1.133;
commitid	0QJleeeWqZmC5anF;

1.133
date	2014.04.19.14.47.51;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2013.12.28.03.34.54;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2013.08.21.05.21.44;	author dlg;	state Exp;
branches;
next	1.129;

1.129
date	2013.08.07.01.06.38;	author bluhm;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.07.11.20.26;	author sthen;	state Exp;
branches;
next	1.127;

1.127
date	2013.02.09.19.17.52;	author sthen;	state Exp;
branches
	1.127.2.1;
next	1.126;

1.126
date	2013.01.28.02.57.02;	author dtucker;	state Exp;
branches;
next	1.125;

1.125
date	2013.01.17.21.49.48;	author chris;	state Exp;
branches;
next	1.124;

1.124
date	2013.01.16.06.15.50;	author dtucker;	state Exp;
branches;
next	1.123;

1.123
date	2013.01.16.04.23.42;	author dtucker;	state Exp;
branches;
next	1.122;

1.122
date	2013.01.16.03.21.14;	author dtucker;	state Exp;
branches;
next	1.121;

1.121
date	2012.12.01.09.55.03;	author brad;	state Exp;
branches;
next	1.120;

1.120
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.119;

1.119
date	2012.11.23.18.40.30;	author gsoares;	state Exp;
branches;
next	1.118;

1.118
date	2012.11.15.15.50.19;	author jsing;	state Exp;
branches;
next	1.117;

1.117
date	2012.10.20.16.12.22;	author chris;	state Exp;
branches;
next	1.116;

1.116
date	2012.10.18.21.44.21;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2012.09.18.14.49.44;	author gerhard;	state Exp;
branches;
next	1.114;

1.114
date	2012.01.30.09.11.30;	author sthen;	state Exp;
branches;
next	1.113;

1.113
date	2012.01.05.19.08.25;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2011.12.08.20.19.23;	author markus;	state Exp;
branches;
next	1.111;

1.111
date	2011.06.22.16.44.27;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.20.01.05.28;	author dlg;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2011.03.13.15.38.50;	author stsp;	state Exp;
branches;
next	1.107;

1.107
date	2011.01.13.11.28.14;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.03.18.14.54;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2009.11.25.13.14.47;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2009.11.25.12.45.02;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.25.12.43.28;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2009.11.25.12.42.28;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.10.19.41.05;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.09.11.40.56;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2009.06.18.18.53.02;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2009.06.18.17.48.15;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.04.16.56.20;	author sthen;	state Exp;
branches;
next	1.94;

1.94
date	2009.05.29.06.57.21;	author mpf;	state Exp;
branches;
next	1.93;

1.93
date	2009.05.21.14.34.35;	author sthen;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.12.13.30.56;	author sthen;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.12.08.38.56;	author sthen;	state Exp;
branches;
next	1.90;

1.90
date	2009.05.11.16.23.03;	author sthen;	state Exp;
branches;
next	1.89;

1.89
date	2009.05.11.10.25.07;	author sthen;	state Exp;
branches;
next	1.88;

1.88
date	2009.05.11.08.03.57;	author sthen;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.11.07.56.52;	author sthen;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.10.12.35.46;	author sthen;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.10.12.31.58;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2009.05.10.12.09.46;	author sthen;	state Exp;
branches;
next	1.83;

1.83
date	2009.04.30.18.28.29;	author mpf;	state Exp;
branches;
next	1.82;

1.82
date	2009.04.28.12.54.31;	author mpf;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2008.09.24.08.41.29;	author mpf;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.75;

1.75
date	2008.07.24.19.01.28;	author thib;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2008.07.18.13.38.40;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.22.19.23.04;	author mk;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.07.16.04.01;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.70;

1.70
date	2007.10.02.07.22.18;	author brad;	state Exp;
branches;
next	1.69;

1.69
date	2007.09.12.19.49.29;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.01.10.26.25;	author mglocker;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.03.23.45.26;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.03.22.32.27;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2006.09.22.03.18.57;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2006.06.17.18.00.43;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.62;

1.62
date	2006.04.28.06.32.31;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.20.16.15.03;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.07.18.15.20;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.06.23.57.04;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.05.23.23.18;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2006.02.05.18.23.37;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.14.09.50.20;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2005.12.10.18.34.11;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.10.18.29.12;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.10.04.22.39;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.08.23.45.49;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2005.12.07.22.48.38;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.07.02.57.45;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.04.16.59.45;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.09.11.18.17.08;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.06.02.22.28;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.06.17.56.36;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2004.04.14.04.48.56;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.29.23.06.55;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.14.05.04.00;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.13.04.25.30;	author jason;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.12.02.53.59;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.12.02.35.53;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.10.19.02.24;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.10.18.19.16;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.10.18.12.41;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.10.18.05.12;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.07.12.42.07;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.19.14.38.22;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.09.10.53.24;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.12.06.58.30;	author jason;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.12.06.55.04;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.19.18.40.17;	author jason;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.14.16.54.45;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.03.08.44.08;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.59;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.12.09.51.20;	author kjc;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.12.20.03.49;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.06.34.50;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.24.22.38.47;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.24.20.27.02;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.16.13.41.27;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.25.06.34.51;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.19.39.44;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.20.19.12.47;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.17.07.52.44;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.17.07.35.36;	author jason;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.09.04.08.11;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.02.00.27.23;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.15.02.28.15;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	99.09.13.22.32.31;	author niklas;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	99.08.05.23.03.47;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	99.02.26.17.05.55;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.00.20.09;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.01.30.23.15.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.01.10.22.30.45;	author downsj;	state Exp;
branches;
next	;

1.6.4.1
date	2000.02.20.11.57.08;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.05.14.22.25.48;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.07.04.10.42.29;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.10.31.03.22.46;	author nate;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2001.11.13.21.10.02;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.06.02.11.46;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2003.03.28.00.38.22;	author niklas;	state Exp;
branches;
next	1.6.4.9;

1.6.4.9
date	2004.02.19.10.56.27;	author niklas;	state Exp;
branches;
next	1.6.4.10;

1.6.4.10
date	2004.06.05.23.12.51;	author niklas;	state Exp;
branches;
next	1.6.4.11;

1.6.4.11
date	2004.06.07.20.41.26;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.42.26;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.05.19.22.18.01;	author tedu;	state Exp;
branches;
next	;

1.75.2.1
date	2008.11.02.03.58.35;	author brad;	state Exp;
branches;
next	;

1.105.2.1
date	2010.10.02.03.00.52;	author william;	state Exp;
branches;
next	;

1.127.2.1
date	2013.05.05.11.05.49;	author dtucker;	state Exp;
branches;
next	;


desc
@@


1.153
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_vr.c,v 1.152 2016/04/13 10:34:32 mpi Exp $	*/

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.73 2003/08/22 07:13:22 imp Exp $
 */

/*
 * VIA Rhine fast ethernet PCI NIC driver
 *
 * Supports various network adapters based on the VIA Rhine
 * and Rhine II PCI controllers, including the D-Link DFE530TX.
 * Datasheets are available at ftp://ftp.vtbridge.org/Docs/LAN/.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The VIA Rhine controllers are similar in some respects to the
 * the DEC tulip chips, except less complicated. The controller
 * uses an MII bus and an external physical layer interface. The
 * receiver has a one entry perfect filter and a 64-bit hash table
 * multicast filter. Transmit and receive descriptors are similar
 * to the tulip.
 *
 * Early Rhine has a serious flaw in its transmit DMA mechanism:
 * transmit buffers must be longword aligned. Unfortunately,
 * OpenBSD doesn't guarantee that mbufs will be filled in starting
 * at longword boundaries, so we have to do a buffer copy before
 * transmission.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/socket.h>

#include <net/if.h>
#include <sys/device.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define VR_USEIOSPACE

#include <dev/pci/if_vrreg.h>

int vr_probe(struct device *, void *, void *);
int vr_quirks(struct pci_attach_args *);
void vr_attach(struct device *, struct device *, void *);
int vr_activate(struct device *, int);

struct cfattach vr_ca = {
	sizeof(struct vr_softc), vr_probe, vr_attach, NULL,
	vr_activate
};
struct cfdriver vr_cd = {
	NULL, "vr", DV_IFNET
};

int vr_encap(struct vr_softc *, struct vr_chain **, struct mbuf *);
void vr_rxeof(struct vr_softc *);
void vr_rxeoc(struct vr_softc *);
void vr_txeof(struct vr_softc *);
void vr_tick(void *);
void vr_rxtick(void *);
int vr_intr(void *);
int vr_dmamem_alloc(struct vr_softc *, struct vr_dmamem *,
    bus_size_t, u_int);
void vr_dmamem_free(struct vr_softc *, struct vr_dmamem *);
void vr_start(struct ifnet *);
int vr_ioctl(struct ifnet *, u_long, caddr_t);
void vr_chipinit(struct vr_softc *);
void vr_init(void *);
void vr_stop(struct vr_softc *);
void vr_watchdog(struct ifnet *);
int vr_ifmedia_upd(struct ifnet *);
void vr_ifmedia_sts(struct ifnet *, struct ifmediareq *);

int vr_mii_readreg(struct vr_softc *, struct vr_mii_frame *);
int vr_mii_writereg(struct vr_softc *, struct vr_mii_frame *);
int vr_miibus_readreg(struct device *, int, int);
void vr_miibus_writereg(struct device *, int, int, int);
void vr_miibus_statchg(struct device *);

void vr_setcfg(struct vr_softc *, uint64_t);
void vr_iff(struct vr_softc *);
void vr_reset(struct vr_softc *);
int vr_list_rx_init(struct vr_softc *);
void vr_fill_rx_ring(struct vr_softc *);
int vr_list_tx_init(struct vr_softc *);
#ifndef SMALL_KERNEL
int vr_wol(struct ifnet *, int);
#endif

int vr_alloc_mbuf(struct vr_softc *, struct vr_chain_onefrag *);

/*
 * Supported devices & quirks
 */
#define	VR_Q_NEEDALIGN		(1<<0)
#define	VR_Q_CSUM		(1<<1)
#define	VR_Q_CAM		(1<<2)
#define	VR_Q_HWTAG		(1<<3)
#define	VR_Q_INTDISABLE		(1<<4)
#define	VR_Q_BABYJUMBO		(1<<5) /* others may work too */

struct vr_type {
	pci_vendor_id_t		vr_vid;
	pci_product_id_t	vr_pid;
	int			vr_quirks;
} vr_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINE,
	    VR_Q_NEEDALIGN },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII,
	    VR_Q_NEEDALIGN },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII_2,
	    VR_Q_BABYJUMBO },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105,
	    VR_Q_BABYJUMBO },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105M,
	    VR_Q_CSUM | VR_Q_CAM | VR_Q_HWTAG | VR_Q_INTDISABLE |
	    VR_Q_BABYJUMBO },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_RHINEII,
	    VR_Q_NEEDALIGN },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_RHINEII,
	    VR_Q_NEEDALIGN }
};

#define VR_SETBIT(sc, reg, x)				\
	CSR_WRITE_1(sc, reg,				\
		CSR_READ_1(sc, reg) | (x))

#define VR_CLRBIT(sc, reg, x)				\
	CSR_WRITE_1(sc, reg,				\
		CSR_READ_1(sc, reg) & ~(x))

#define VR_SETBIT16(sc, reg, x)				\
	CSR_WRITE_2(sc, reg,				\
		CSR_READ_2(sc, reg) | (x))

#define VR_CLRBIT16(sc, reg, x)				\
	CSR_WRITE_2(sc, reg,				\
		CSR_READ_2(sc, reg) & ~(x))

#define VR_SETBIT32(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) | (x))

#define VR_CLRBIT32(sc, reg, x)				\
	CSR_WRITE_4(sc, reg,				\
		CSR_READ_4(sc, reg) & ~(x))

#define SIO_SET(x)					\
	CSR_WRITE_1(sc, VR_MIICMD,			\
		CSR_READ_1(sc, VR_MIICMD) | (x))

#define SIO_CLR(x)					\
	CSR_WRITE_1(sc, VR_MIICMD,			\
		CSR_READ_1(sc, VR_MIICMD) & ~(x))

/*
 * Read an PHY register through the MII.
 */
int
vr_mii_readreg(struct vr_softc *sc, struct vr_mii_frame *frame)
{
	int			s, i;

	s = splnet();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_READ_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_READ_ENB) == 0)
			break;
		DELAY(1);
	}

	frame->mii_data = CSR_READ_2(sc, VR_MIIDATA);

	splx(s);

	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int
vr_mii_writereg(struct vr_softc *sc, struct vr_mii_frame *frame)
{
	int			s, i;

	s = splnet();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address and data to write */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	CSR_WRITE_2(sc, VR_MIIDATA, frame->mii_data);

	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_WRITE_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_WRITE_ENB) == 0)
			break;
		DELAY(1);
	}

	splx(s);

	return(0);
}

int
vr_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct vr_softc *sc = (struct vr_softc *)dev;
	struct vr_mii_frame frame;

	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
	case REV_ID_VT6103:
		if (phy != 1)
			return 0;
	default:
		break;
	}

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	vr_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
vr_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct vr_softc *sc = (struct vr_softc *)dev;
	struct vr_mii_frame frame;

	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
	case REV_ID_VT6103:
		if (phy != 1)
			return;
	default:
		break;
	}

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = data;

	vr_mii_writereg(sc, &frame);
}

void
vr_miibus_statchg(struct device *dev)
{
	struct vr_softc *sc = (struct vr_softc *)dev;

	vr_setcfg(sc, sc->sc_mii.mii_media_active);
}

void
vr_iff(struct vr_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			h = 0;
	u_int32_t		hashes[2];
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int8_t		rxfilt;

	rxfilt = CSR_READ_1(sc, VR_RXCFG);
	rxfilt &= ~(VR_RXCFG_RX_BROAD | VR_RXCFG_RX_MULTI |
	    VR_RXCFG_RX_PROMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 */
	rxfilt |= VR_RXCFG_RX_BROAD;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxfilt |= VR_RXCFG_RX_MULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxfilt |= VR_RXCFG_RX_PROMISC;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		/* Program new filter. */
		rxfilt |= VR_RXCFG_RX_MULTI;
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	CSR_WRITE_4(sc, VR_MAR0, hashes[0]);
	CSR_WRITE_4(sc, VR_MAR1, hashes[1]);
	CSR_WRITE_1(sc, VR_RXCFG, rxfilt);
}

/*
 * In order to fiddle with the
 * 'full-duplex' and '100Mbps' bits in the netconfig register, we
 * first have to put the transmit and/or receive logic in the idle state.
 */
void
vr_setcfg(struct vr_softc *sc, uint64_t media)
{
	int i;

	if (sc->sc_mii.mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(sc->sc_mii.mii_media_active) != IFM_NONE) {
		sc->vr_link = 1;

		if (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON))
			VR_CLRBIT16(sc, VR_COMMAND,
			    (VR_CMD_TX_ON|VR_CMD_RX_ON));

		if ((media & IFM_GMASK) == IFM_FDX)
			VR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);
		else
			VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);

		VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_RX_ON);
	} else {
		sc->vr_link = 0;
		VR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));
		for (i = VR_TIMEOUT; i > 0; i--) {
			DELAY(10);
			if (!(CSR_READ_2(sc, VR_COMMAND) &
			    (VR_CMD_TX_ON|VR_CMD_RX_ON)))
				break;
		}
		if (i == 0) {
#ifdef VR_DEBUG
			printf("%s: rx shutdown error!\n", sc->sc_dev.dv_xname);
#endif
			sc->vr_flags |= VR_F_RESTART;
		}
	}
}

void
vr_reset(struct vr_softc *sc)
{
	int			i;

	VR_SETBIT16(sc, VR_COMMAND, VR_CMD_RESET);

	for (i = 0; i < VR_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RESET))
			break;
	}
	if (i == VR_TIMEOUT) {
		if (sc->vr_revid < REV_ID_VT3065_A)
			printf("%s: reset never completed!\n",
			    sc->sc_dev.dv_xname);
		else {
#ifdef VR_DEBUG
			/* Use newer force reset command */
			printf("%s: Using force reset command.\n",
			    sc->sc_dev.dv_xname);
#endif
			VR_SETBIT(sc, VR_MISC_CR1, VR_MISCCR1_FORSRST);
		}
	}

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);
}

/*
 * Probe for a VIA Rhine chip.
 */
int
vr_probe(struct device *parent, void *match, void *aux)
{
	const struct vr_type *vr;
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;
	int i, nent = nitems(vr_devices);

	for (i = 0, vr = vr_devices; i < nent; i++, vr++)
		if (PCI_VENDOR(pa->pa_id) == vr->vr_vid &&
		   PCI_PRODUCT(pa->pa_id) == vr->vr_pid)
			return(1);

	return(0);
}

int
vr_quirks(struct pci_attach_args *pa)
{
	const struct vr_type *vr;
	int i, nent = nitems(vr_devices);

	for (i = 0, vr = vr_devices; i < nent; i++, vr++)
		if (PCI_VENDOR(pa->pa_id) == vr->vr_vid &&
		   PCI_PRODUCT(pa->pa_id) == vr->vr_pid)
			return(vr->vr_quirks);

	return(0);
}

int
vr_dmamem_alloc(struct vr_softc *sc, struct vr_dmamem *vrm,
    bus_size_t size, u_int align)
{
	vrm->vrm_size = size;

	if (bus_dmamap_create(sc->sc_dmat, vrm->vrm_size, 1,
	    vrm->vrm_size, 0, BUS_DMA_WAITOK | BUS_DMA_ALLOCNOW,
	    &vrm->vrm_map) != 0)
		return (1);
	if (bus_dmamem_alloc(sc->sc_dmat, vrm->vrm_size,
	    align, 0, &vrm->vrm_seg, 1, &vrm->vrm_nsegs,
	    BUS_DMA_WAITOK | BUS_DMA_ZERO) != 0)
		goto destroy;
	if (bus_dmamem_map(sc->sc_dmat, &vrm->vrm_seg, vrm->vrm_nsegs,
	    vrm->vrm_size, &vrm->vrm_kva, BUS_DMA_WAITOK) != 0)
		goto free;
	if (bus_dmamap_load(sc->sc_dmat, vrm->vrm_map, vrm->vrm_kva,
	    vrm->vrm_size, NULL, BUS_DMA_WAITOK) != 0)
		goto unmap;

	return (0);
 unmap:
	bus_dmamem_unmap(sc->sc_dmat, vrm->vrm_kva, vrm->vrm_size);
 free:
	bus_dmamem_free(sc->sc_dmat, &vrm->vrm_seg, 1);
 destroy:
	bus_dmamap_destroy(sc->sc_dmat, vrm->vrm_map);
	return (1);
}

void
vr_dmamem_free(struct vr_softc *sc, struct vr_dmamem *vrm)
{
	bus_dmamap_unload(sc->sc_dmat, vrm->vrm_map);
	bus_dmamem_unmap(sc->sc_dmat, vrm->vrm_kva, vrm->vrm_size);
	bus_dmamem_free(sc->sc_dmat, &vrm->vrm_seg, 1);
	bus_dmamap_destroy(sc->sc_dmat, vrm->vrm_map);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
vr_attach(struct device *parent, struct device *self, void *aux)
{
	int			i;
	struct vr_softc		*sc = (struct vr_softc *)self;
	struct pci_attach_args	*pa = aux;
	pci_chipset_tag_t	pc = pa->pa_pc;
	pci_intr_handle_t	ih;
	const char		*intrstr = NULL;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	bus_size_t		size;

	pci_set_powerstate(pa->pa_pc, pa->pa_tag, PCI_PMCSR_STATE_D0);

	/*
	 * Map control/status registers.
	 */

#ifdef VR_USEIOSPACE
	if (pci_mapreg_map(pa, VR_PCI_LOIO, PCI_MAPREG_TYPE_IO, 0,
	    &sc->vr_btag, &sc->vr_bhandle, NULL, &size, 0)) {
		printf(": can't map i/o space\n");
		return;
	}
#else
	if (pci_mapreg_map(pa, VR_PCI_LOMEM, PCI_MAPREG_TYPE_MEM, 0,
	    &sc->vr_btag, &sc->vr_bhandle, NULL, &size, 0)) {
		printf(": can't map mem space\n");
		return;
	}
#endif

	/* Allocate interrupt */
	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		goto fail;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, vr_intr, sc,
				       self->dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		goto fail;
	}
	printf(": %s", intrstr);

	sc->vr_revid = PCI_REVISION(pa->pa_class);
	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;

	vr_chipinit(sc);

	/*
	 * Get station address. The way the Rhine chips work,
	 * you're not allowed to directly access the EEPROM once
	 * they've been programmed a special way. Consequently,
	 * we need to read the node address from the PAR0 and PAR1
	 * registers.
	 */
	VR_SETBIT(sc, VR_EECSR, VR_EECSR_LOAD);
	DELAY(1000);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->arpcom.ac_enaddr[i] = CSR_READ_1(sc, VR_PAR0 + i);

	/*
	 * A Rhine chip was detected. Inform the world.
	 */
	printf(", address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));

	sc->sc_dmat = pa->pa_dmat;
	if (vr_dmamem_alloc(sc, &sc->sc_zeromap, 64, PAGE_SIZE) != 0) {
		printf(": failed to allocate zero pad memory\n");
		return;
	}
	bzero(sc->sc_zeromap.vrm_kva, 64);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_zeromap.vrm_map, 0,
	    sc->sc_zeromap.vrm_map->dm_mapsize, BUS_DMASYNC_PREREAD);
	if (vr_dmamem_alloc(sc, &sc->sc_listmap, sizeof(struct vr_list_data),
	    PAGE_SIZE) != 0) {
		printf(": failed to allocate dma map\n");
		goto free_zero;
	}

	sc->vr_ldata = (struct vr_list_data *)sc->sc_listmap.vrm_kva;
	sc->vr_quirks = vr_quirks(pa);

	ifp = &sc->arpcom.ac_if;
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = vr_ioctl;
	ifp->if_start = vr_start;
	ifp->if_watchdog = vr_watchdog;
	if (sc->vr_quirks & VR_Q_BABYJUMBO)
		ifp->if_hardmtu = VR_RXLEN_BABYJUMBO -
		    ETHER_HDR_LEN - ETHER_CRC_LEN;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	if (sc->vr_quirks & VR_Q_CSUM)
		ifp->if_capabilities |= IFCAP_CSUM_IPv4 | IFCAP_CSUM_TCPv4 |
					IFCAP_CSUM_UDPv4;

#if NVLAN > 0
	/* if the hardware can do VLAN tagging, say so. */
	if (sc->vr_quirks & VR_Q_HWTAG)
		ifp->if_capabilities |= IFCAP_VLAN_HWTAGGING;
#endif

#ifndef SMALL_KERNEL
	if (sc->vr_revid >= REV_ID_VT3065_A) {
		ifp->if_capabilities |= IFCAP_WOL;
		ifp->if_wol = vr_wol;
		vr_wol(ifp, 0);
	}
#endif

	/*
	 * Do MII setup.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = vr_miibus_readreg;
	sc->sc_mii.mii_writereg = vr_miibus_writereg;
	sc->sc_mii.mii_statchg = vr_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, vr_ifmedia_upd, vr_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
	timeout_set(&sc->sc_to, vr_tick, sc);
	timeout_set(&sc->sc_rxto, vr_rxtick, sc);

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	return;

free_zero:
	bus_dmamap_sync(sc->sc_dmat, sc->sc_zeromap.vrm_map, 0,
	    sc->sc_zeromap.vrm_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
	vr_dmamem_free(sc, &sc->sc_zeromap);
fail:
	bus_space_unmap(sc->vr_btag, sc->vr_bhandle, size);
}

int
vr_activate(struct device *self, int act)
{
	struct vr_softc *sc = (struct vr_softc *)self;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			vr_stop(sc);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			vr_init(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

/*
 * Initialize the transmit descriptors.
 */
int
vr_list_tx_init(struct vr_softc *sc)
{
	struct vr_chain_data	*cd;
	struct vr_list_data	*ld;
	int			i;

	cd = &sc->vr_cdata;
	ld = sc->vr_ldata;

	cd->vr_tx_cnt = cd->vr_tx_pkts = 0;

	for (i = 0; i < VR_TX_LIST_CNT; i++) {
		cd->vr_tx_chain[i].vr_ptr = &ld->vr_tx_list[i];
		cd->vr_tx_chain[i].vr_paddr =
		    sc->sc_listmap.vrm_map->dm_segs[0].ds_addr +
		    offsetof(struct vr_list_data, vr_tx_list[i]);

		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, VR_MAXFRAGS,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &cd->vr_tx_chain[i].vr_map))
			return (ENOBUFS);

		if (i == (VR_TX_LIST_CNT - 1))
			cd->vr_tx_chain[i].vr_nextdesc =
				&cd->vr_tx_chain[0];
		else
			cd->vr_tx_chain[i].vr_nextdesc =
				&cd->vr_tx_chain[i + 1];
	}

	cd->vr_tx_cons = cd->vr_tx_prod = &cd->vr_tx_chain[0];

	return (0);
}


/*
 * Initialize the RX descriptors and allocate mbufs for them. Note that
 * we arrange the descriptors in a closed ring, so that the last descriptor
 * points back to the first.
 */
int
vr_list_rx_init(struct vr_softc *sc)
{
	struct vr_chain_data	*cd;
	struct vr_list_data	*ld;
	struct vr_desc		*d;
	int			 i, nexti;

	cd = &sc->vr_cdata;
	ld = sc->vr_ldata;

	for (i = 0; i < VR_RX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
		    0, BUS_DMA_NOWAIT | BUS_DMA_READ,
		    &cd->vr_rx_chain[i].vr_map))
			return (ENOBUFS);

		d = (struct vr_desc *)&ld->vr_rx_list[i];
		cd->vr_rx_chain[i].vr_ptr = d;
		cd->vr_rx_chain[i].vr_paddr =
		    sc->sc_listmap.vrm_map->dm_segs[0].ds_addr +
		    offsetof(struct vr_list_data, vr_rx_list[i]);

		if (i == (VR_RX_LIST_CNT - 1))
			nexti = 0;
		else
			nexti = i + 1;

		cd->vr_rx_chain[i].vr_nextdesc = &cd->vr_rx_chain[nexti];
		ld->vr_rx_list[i].vr_next =
		    htole32(sc->sc_listmap.vrm_map->dm_segs[0].ds_addr +
		    offsetof(struct vr_list_data, vr_rx_list[nexti]));
	}

	cd->vr_rx_prod = cd->vr_rx_cons = &cd->vr_rx_chain[0];
	if_rxr_init(&sc->sc_rxring, 2, VR_RX_LIST_CNT - 1);
	vr_fill_rx_ring(sc);

	return (0);
}

void
vr_fill_rx_ring(struct vr_softc *sc)
{
	struct vr_chain_data	*cd;
	struct vr_list_data	*ld;
	u_int			slots;

	cd = &sc->vr_cdata;
	ld = sc->vr_ldata;

	for (slots = if_rxr_get(&sc->sc_rxring, VR_RX_LIST_CNT);
	    slots > 0; slots--) {
		if (vr_alloc_mbuf(sc, cd->vr_rx_prod))
			break;

		cd->vr_rx_prod = cd->vr_rx_prod->vr_nextdesc;
	}

	if_rxr_put(&sc->sc_rxring, slots);
	if (if_rxr_inuse(&sc->sc_rxring) == 0)
		timeout_add(&sc->sc_rxto, 0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
vr_rxeof(struct vr_softc *sc)
{
	struct mbuf		*m;
	struct mbuf_list 	ml = MBUF_LIST_INITIALIZER();
	struct ifnet		*ifp;
	struct vr_chain_onefrag	*cur_rx;
	int			total_len = 0;
	u_int32_t		rxstat, rxctl;

	ifp = &sc->arpcom.ac_if;

	while (if_rxr_inuse(&sc->sc_rxring) > 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap.vrm_map,
		    0, sc->sc_listmap.vrm_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		rxstat = letoh32(sc->vr_cdata.vr_rx_cons->vr_ptr->vr_status);
		if (rxstat & VR_RXSTAT_OWN)
			break;

		rxctl = letoh32(sc->vr_cdata.vr_rx_cons->vr_ptr->vr_ctl);

		cur_rx = sc->vr_cdata.vr_rx_cons;
		m = cur_rx->vr_mbuf;
		cur_rx->vr_mbuf = NULL;
		sc->vr_cdata.vr_rx_cons = cur_rx->vr_nextdesc;
		if_rxr_put(&sc->sc_rxring, 1);

		/*
		 * If an error occurs, update stats, clear the
		 * status word and leave the mbuf cluster in place:
		 * it should simply get re-used next time this descriptor
		 * comes up in the ring.
		 */
		if ((rxstat & VR_RXSTAT_RX_OK) == 0) {
			ifp->if_ierrors++;
#ifdef VR_DEBUG
			printf("%s: rx error (%02x):",
			    sc->sc_dev.dv_xname, rxstat & 0x000000ff);
			if (rxstat & VR_RXSTAT_CRCERR)
				printf(" crc error");
			if (rxstat & VR_RXSTAT_FRAMEALIGNERR)
				printf(" frame alignment error");
			if (rxstat & VR_RXSTAT_FIFOOFLOW)
				printf(" FIFO overflow");
			if (rxstat & VR_RXSTAT_GIANT)
				printf(" received giant packet");
			if (rxstat & VR_RXSTAT_RUNT)
				printf(" received runt packet");
			if (rxstat & VR_RXSTAT_BUSERR)
				printf(" system bus error");
			if (rxstat & VR_RXSTAT_BUFFERR)
				printf(" rx buffer error");
			printf("\n");
#endif

			m_freem(m);
			continue;
		}

		/* No errors; receive the packet. */
		total_len = VR_RXBYTES(letoh32(cur_rx->vr_ptr->vr_status));

		bus_dmamap_sync(sc->sc_dmat, cur_rx->vr_map, 0,
		    cur_rx->vr_map->dm_mapsize, BUS_DMASYNC_POSTREAD);
		bus_dmamap_unload(sc->sc_dmat, cur_rx->vr_map);

		/*
		 * The VIA Rhine chip includes the CRC with every
		 * received frame, and there's no way to turn this
		 * behavior off so trim the CRC manually.
		 */
		total_len -= ETHER_CRC_LEN;

#ifdef __STRICT_ALIGNMENT
		{
			struct mbuf *m0;
			m0 = m_devget(mtod(m, caddr_t), total_len, ETHER_ALIGN);
			m_freem(m);
			if (m0 == NULL) {
				ifp->if_ierrors++;
				continue;
			}
			m = m0;
		} 
#else
		m->m_pkthdr.len = m->m_len = total_len;
#endif

		if (sc->vr_quirks & VR_Q_CSUM &&
		    (rxstat & VR_RXSTAT_FRAG) == 0 &&
		    (rxctl & VR_RXCTL_IP) != 0) {
			/* Checksum is valid for non-fragmented IP packets. */
			if ((rxctl & VR_RXCTL_IPOK) == VR_RXCTL_IPOK)
				m->m_pkthdr.csum_flags |= M_IPV4_CSUM_IN_OK;
			if (rxctl & (VR_RXCTL_TCP | VR_RXCTL_UDP) &&
			    ((rxctl & VR_RXCTL_TCPUDPOK) != 0))
				m->m_pkthdr.csum_flags |= M_TCP_CSUM_IN_OK |
				    M_UDP_CSUM_IN_OK;
		}

#if NVLAN > 0
		/*
		 * If there's a tagged packet, the 802.1q header will be at the
		 * 4-byte boundary following the CRC.  There will be 2 bytes
		 * TPID (0x8100) and 2 bytes TCI (including VLAN ID).
		 * This isn't in the data sheet.
		 */
		if (rxctl & VR_RXCTL_TAG) {
			int offset = ((total_len + 3) & ~3) + ETHER_CRC_LEN + 2;
			m->m_pkthdr.ether_vtag = htons(*(u_int16_t *)
			    ((u_int8_t *)m->m_data + offset));
			m->m_flags |= M_VLANTAG;
		}
#endif

		ml_enqueue(&ml, m);
	}

	vr_fill_rx_ring(sc);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap.vrm_map,
	    0, sc->sc_listmap.vrm_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

	if_input(ifp, &ml);
}

void
vr_rxeoc(struct vr_softc *sc)
{
	struct ifnet		*ifp;
	int			i;

	ifp = &sc->arpcom.ac_if;

	ifp->if_ierrors++;

	VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);
	DELAY(10000);

	for (i = 0x400;
	    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RX_ON);
	    i--)
		;       /* Wait for receiver to stop */

	if (!i) {
		printf("%s: rx shutdown error!\n", sc->sc_dev.dv_xname);
		sc->vr_flags |= VR_F_RESTART;
		return;
	}

	vr_rxeof(sc);

	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_cons->vr_paddr);
	VR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);
	VR_SETBIT16(sc, VR_COMMAND, VR_CMD_RX_GO);
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
vr_txeof(struct vr_softc *sc)
{
	struct vr_chain		*cur_tx;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	cur_tx = sc->vr_cdata.vr_tx_cons;
	while (cur_tx != sc->vr_cdata.vr_tx_prod) {
		u_int32_t		txstat, txctl;
		int			i;

		txstat = letoh32(cur_tx->vr_ptr->vr_status);
		txctl = letoh32(cur_tx->vr_ptr->vr_ctl);

		if ((txstat & VR_TXSTAT_ABRT) ||
		    (txstat & VR_TXSTAT_UDF)) {
			for (i = 0x400;
			    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_TX_ON);
			    i--)
				;	/* Wait for chip to shutdown */
			if (!i) {
				printf("%s: tx shutdown timeout\n",
				    sc->sc_dev.dv_xname);
				sc->vr_flags |= VR_F_RESTART;
				break;
			}
			cur_tx->vr_ptr->vr_status = htole32(VR_TXSTAT_OWN);
			CSR_WRITE_4(sc, VR_TXADDR, cur_tx->vr_paddr);
			break;
		}

		if (txstat & VR_TXSTAT_OWN)
			break;

		sc->vr_cdata.vr_tx_cnt--;
		/* Only the first descriptor in the chain is valid. */
		if ((txctl & VR_TXCTL_FIRSTFRAG) == 0)
			goto next;

		if (txstat & VR_TXSTAT_ERRSUM) {
			ifp->if_oerrors++;
			if (txstat & VR_TXSTAT_DEFER)
				ifp->if_collisions++;
			if (txstat & VR_TXSTAT_LATECOLL)
				ifp->if_collisions++;
		}

		ifp->if_collisions +=(txstat & VR_TXSTAT_COLLCNT) >> 3;

		if (cur_tx->vr_map != NULL && cur_tx->vr_map->dm_nsegs > 0)
			bus_dmamap_unload(sc->sc_dmat, cur_tx->vr_map);

		m_freem(cur_tx->vr_mbuf);
		cur_tx->vr_mbuf = NULL;
		ifq_clr_oactive(&ifp->if_snd);

next:
		cur_tx = cur_tx->vr_nextdesc;
	}

	sc->vr_cdata.vr_tx_cons = cur_tx;
	if (sc->vr_cdata.vr_tx_cnt == 0)
		ifp->if_timer = 0;
}

void
vr_tick(void *xsc)
{
	struct vr_softc *sc = xsc;
	int s;

	s = splnet();
	if (sc->vr_flags & VR_F_RESTART) {
		printf("%s: restarting\n", sc->sc_dev.dv_xname);
		vr_init(sc);
		sc->vr_flags &= ~VR_F_RESTART;
	}

	mii_tick(&sc->sc_mii);
	timeout_add_sec(&sc->sc_to, 1);
	splx(s);
}

void
vr_rxtick(void *xsc)
{
	struct vr_softc *sc = xsc;
	int s;

	s = splnet();
	if (if_rxr_inuse(&sc->sc_rxring) == 0) {
		vr_fill_rx_ring(sc);
		if (if_rxr_inuse(&sc->sc_rxring) == 0)
			timeout_add(&sc->sc_rxto, 1);
	}
	splx(s);
}

int
vr_intr(void *arg)
{
	struct vr_softc		*sc;
	struct ifnet		*ifp;
	u_int16_t		status;
	int claimed = 0;

	sc = arg;
	ifp = &sc->arpcom.ac_if;

	/* Suppress unwanted interrupts. */
	if (!(ifp->if_flags & IFF_UP)) {
		vr_stop(sc);
		return 0;
	}

	status = CSR_READ_2(sc, VR_ISR);
	if (status)
		CSR_WRITE_2(sc, VR_ISR, status);

	if (status & VR_INTRS) {
		claimed = 1;

		if (status & VR_ISR_RX_OK)
			vr_rxeof(sc);

		if (status & VR_ISR_RX_DROPPED) {
#ifdef VR_DEBUG
			printf("%s: rx packet lost\n", sc->sc_dev.dv_xname);
#endif
			ifp->if_ierrors++;
		}

		if ((status & VR_ISR_RX_ERR) || (status & VR_ISR_RX_NOBUF) ||
		    (status & VR_ISR_RX_OFLOW)) {
#ifdef VR_DEBUG
			printf("%s: receive error (%04x)",
			    sc->sc_dev.dv_xname, status);
			if (status & VR_ISR_RX_NOBUF)
				printf(" no buffers");
			if (status & VR_ISR_RX_OFLOW)
				printf(" overflow");
			printf("\n");
#endif
			vr_rxeoc(sc);
		}

		if ((status & VR_ISR_BUSERR) || (status & VR_ISR_TX_UNDERRUN)) {
			if (status & VR_ISR_BUSERR)
				printf("%s: PCI bus error\n",
				    sc->sc_dev.dv_xname);
			if (status & VR_ISR_TX_UNDERRUN)
				printf("%s: transmit underrun\n",
				    sc->sc_dev.dv_xname);
			vr_init(sc);
			status = 0;
		}

		if ((status & VR_ISR_TX_OK) || (status & VR_ISR_TX_ABRT) ||
		    (status & VR_ISR_TX_ABRT2) || (status & VR_ISR_UDFI)) {
			vr_txeof(sc);
			if ((status & VR_ISR_UDFI) ||
			    (status & VR_ISR_TX_ABRT2) ||
			    (status & VR_ISR_TX_ABRT)) {
#ifdef VR_DEBUG
				if (status & (VR_ISR_TX_ABRT | VR_ISR_TX_ABRT2))
					printf("%s: transmit aborted\n",
					    sc->sc_dev.dv_xname);
				if (status & VR_ISR_UDFI)
					printf("%s: transmit underflow\n",
					    sc->sc_dev.dv_xname);
#endif
				ifp->if_oerrors++;
				if (sc->vr_cdata.vr_tx_cons->vr_mbuf != NULL) {
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_ON);
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_GO);
				}
			}
		}
	}

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		vr_start(ifp);

	return (claimed);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
vr_encap(struct vr_softc *sc, struct vr_chain **cp, struct mbuf *m)
{
	struct vr_chain		*c = *cp;
	struct vr_desc		*f = NULL;
	u_int32_t		vr_ctl = 0, vr_status = 0, intdisable = 0;
	bus_dmamap_t		txmap;
	int			i, runt = 0;
	int			error;

	if (sc->vr_quirks & VR_Q_CSUM) {
		if (m->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			vr_ctl |= VR_TXCTL_IPCSUM;
		if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
			vr_ctl |= VR_TXCTL_TCPCSUM;
		if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
			vr_ctl |= VR_TXCTL_UDPCSUM;
	}

	if (sc->vr_quirks & VR_Q_NEEDALIGN) {
		/* Deep copy for chips that need alignment */
		error = EFBIG;
	} else {
		error = bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE);
	}

	switch (error) {
	case 0:
		break;
	case EFBIG:
		if (m_defrag(m, M_DONTWAIT) == 0 &&
                    bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m,
                     BUS_DMA_NOWAIT) == 0)
                        break;

		/* FALLTHROUGH */
        default:
		return (ENOBUFS);
        }

	bus_dmamap_sync(sc->sc_dmat, c->vr_map, 0, c->vr_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);
	if (c->vr_map->dm_mapsize < VR_MIN_FRAMELEN)
		runt = 1;

#if NVLAN > 0
	/*
	 * Tell chip to insert VLAN tag if needed.
	 * This chip expects the VLAN ID (0x0FFF) and the PCP (0xE000)
	 * in only 15 bits without the gap at 0x1000 (reserved for DEI).
	 * Therefore we need to de- / re-construct the VLAN header.
	 */
	if (m->m_flags & M_VLANTAG) {
		u_int32_t vtag = m->m_pkthdr.ether_vtag;
		vtag = EVL_VLANOFTAG(vtag) | EVL_PRIOFTAG(vtag) << 12;
		vr_status |= vtag << VR_TXSTAT_PQSHIFT;
		vr_ctl |= htole32(VR_TXCTL_INSERTTAG);
	}
#endif

	/*
	 * We only want TX completion interrupts on every Nth packet.
	 * We need to set VR_TXNEXT_INTDISABLE on every descriptor except
	 * for the last discriptor of every Nth packet, where we set
	 * VR_TXCTL_FINT.  The former is in the specs for only some chips.
	 * present: VT6102 VT6105M VT8235M
	 * not present: VT86C100 6105LOM
	 */
	if (++sc->vr_cdata.vr_tx_pkts % VR_TX_INTR_THRESH != 0 &&
	    sc->vr_quirks & VR_Q_INTDISABLE)
		intdisable = VR_TXNEXT_INTDISABLE;

	c->vr_mbuf = m;
	txmap = c->vr_map;
	for (i = 0; i < txmap->dm_nsegs; i++) {
		if (i != 0)
			*cp = c = c->vr_nextdesc;
		f = c->vr_ptr;
		f->vr_ctl = htole32(txmap->dm_segs[i].ds_len | VR_TXCTL_TLINK |
		    vr_ctl);
		if (i == 0)
			f->vr_ctl |= htole32(VR_TXCTL_FIRSTFRAG);
		f->vr_status = htole32(vr_status);
		f->vr_data = htole32(txmap->dm_segs[i].ds_addr);
		f->vr_next = htole32(c->vr_nextdesc->vr_paddr | intdisable);
		sc->vr_cdata.vr_tx_cnt++;
	}

	/* Pad runt frames */
	if (runt) {
		*cp = c = c->vr_nextdesc;
		f = c->vr_ptr;
		f->vr_ctl = htole32((VR_MIN_FRAMELEN - txmap->dm_mapsize) |
		    VR_TXCTL_TLINK | vr_ctl);
		f->vr_status = htole32(vr_status);
		f->vr_data = htole32(sc->sc_zeromap.vrm_map->dm_segs[0].ds_addr);
		f->vr_next = htole32(c->vr_nextdesc->vr_paddr | intdisable);
		sc->vr_cdata.vr_tx_cnt++;
	}

	/* Set EOP on the last descriptor */
	f->vr_ctl |= htole32(VR_TXCTL_LASTFRAG);

	if (sc->vr_cdata.vr_tx_pkts % VR_TX_INTR_THRESH == 0)
		f->vr_ctl |= htole32(VR_TXCTL_FINT);

	return (0);
}

/*
 * Main transmit routine. To avoid having to do mbuf copies, we put pointers
 * to the mbuf data regions directly in the transmit lists. We also save a
 * copy of the pointers since the transmit list fragment pointers are
 * physical addresses.
 */

void
vr_start(struct ifnet *ifp)
{
	struct vr_softc		*sc;
	struct mbuf		*m;
	struct vr_chain		*cur_tx, *head_tx;
	unsigned int		 queued = 0;

	sc = ifp->if_softc;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	if (sc->vr_link == 0)
		return;

	cur_tx = sc->vr_cdata.vr_tx_prod;
	for (;;) {
		if (sc->vr_cdata.vr_tx_cnt + VR_MAXFRAGS >=
		    VR_TX_LIST_CNT - 1) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m);
		if (m == NULL)
			break;

		/* Pack the data into the descriptor. */
		head_tx = cur_tx;
		if (vr_encap(sc, &cur_tx, m)) {
			m_freem(m);
			ifp->if_oerrors++;
			continue;
		}
		queued++;

		/* Only set ownership bit on first descriptor */
		head_tx->vr_ptr->vr_status |= htole32(VR_TXSTAT_OWN);

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
		cur_tx = cur_tx->vr_nextdesc;
	}
	if (queued > 0) {
		sc->vr_cdata.vr_tx_prod = cur_tx;

		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap.vrm_map, 0,
		    sc->sc_listmap.vrm_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

		/* Tell the chip to start transmitting. */
		VR_SETBIT16(sc, VR_COMMAND, /*VR_CMD_TX_ON|*/VR_CMD_TX_GO);

		/* Set a timeout in case the chip goes out to lunch. */
		ifp->if_timer = 5;
	}
}

void
vr_chipinit(struct vr_softc *sc)
{
	/*
	 * Make sure it isn't suspended.
	 */
	if (pci_get_capability(sc->sc_pc, sc->sc_tag,
	    PCI_CAP_PWRMGMT, NULL, NULL))
		VR_CLRBIT(sc, VR_STICKHW, (VR_STICKHW_DS0|VR_STICKHW_DS1));

	/* Reset the adapter. */
	vr_reset(sc);

	/*
	 * Turn on bit2 (MIION) in PCI configuration register 0x53 during
	 * initialization and disable AUTOPOLL.
	 */
	pci_conf_write(sc->sc_pc, sc->sc_tag, VR_PCI_MODE,
	    pci_conf_read(sc->sc_pc, sc->sc_tag, VR_PCI_MODE) |
	    (VR_MODE3_MIION << 24));
	VR_CLRBIT(sc, VR_MIICMD, VR_MIICMD_AUTOPOLL);
}

void
vr_init(void *xsc)
{
	struct vr_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mii_data		*mii = &sc->sc_mii;
	int			s, i;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	vr_stop(sc);
	vr_chipinit(sc);

	/*
	 * Set our station address.
	 */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		CSR_WRITE_1(sc, VR_PAR0 + i, sc->arpcom.ac_enaddr[i]);

	/* Set DMA size */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_DMA_LENGTH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_DMA_STORENFWD);

	/*
	 * BCR0 and BCR1 can override the RXCFG and TXCFG registers,
	 * so we must set both.
	 */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_RX_THRESH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_RXTHRESH128BYTES);

	VR_CLRBIT(sc, VR_BCR1, VR_BCR1_TX_THRESH);
	VR_SETBIT(sc, VR_BCR1, VR_BCR1_TXTHRESHSTORENFWD);

	VR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_THRESH);
	VR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_128BYTES);

	VR_CLRBIT(sc, VR_TXCFG, VR_TXCFG_TX_THRESH);
	VR_SETBIT(sc, VR_TXCFG, VR_TXTHRESH_STORENFWD);

	if (ifp->if_capabilities & IFCAP_VLAN_HWTAGGING)
		VR_SETBIT(sc, VR_TXCFG, VR_TXCFG_TXTAGEN);

	/* Init circular RX list. */
	if (vr_list_rx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no memory for rx buffers\n",
		    sc->sc_dev.dv_xname);
		vr_stop(sc);
		splx(s);
		return;
	}

	/*
	 * Init tx descriptors.
	 */
	if (vr_list_tx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no memory for tx buffers\n",
		    sc->sc_dev.dv_xname);
		vr_stop(sc);
		splx(s);
		return;
	}

	/*
	 * Program promiscuous mode and multicast filters.
	 */
	vr_iff(sc);

	/*
	 * Load the address of the RX list.
	 */
	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_cons->vr_paddr);

	/* Enable receiver and transmitter. */
	CSR_WRITE_2(sc, VR_COMMAND, VR_CMD_TX_NOPOLL|VR_CMD_START|
				    VR_CMD_TX_ON|VR_CMD_RX_ON|
				    VR_CMD_RX_GO);

	CSR_WRITE_4(sc, VR_TXADDR, sc->sc_listmap.vrm_map->dm_segs[0].ds_addr +
	    offsetof(struct vr_list_data, vr_tx_list[0]));

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_2(sc, VR_ISR, 0xFFFF);
	CSR_WRITE_2(sc, VR_IMR, VR_INTRS);

	/* Restore state of BMCR */
	sc->vr_link = 1;
	mii_mediachg(mii);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (!timeout_pending(&sc->sc_to))
		timeout_add_sec(&sc->sc_to, 1);

	splx(s);
}

/*
 * Set media options.
 */
int
vr_ifmedia_upd(struct ifnet *ifp)
{
	struct vr_softc		*sc = ifp->if_softc;

	if (ifp->if_flags & IFF_UP)
		vr_init(sc);

	return (0);
}

/*
 * Report current media status.
 */
void
vr_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct vr_softc		*sc = ifp->if_softc;
	struct mii_data		*mii = &sc->sc_mii;

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
vr_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct vr_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	int			s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			vr_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				vr_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				vr_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	case SIOCGIFRXR:
		error = if_rxr_ioctl((struct if_rxrinfo *)ifr->ifr_data,
		    NULL, MCLBYTES, &sc->sc_rxring);
 		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			vr_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
vr_watchdog(struct ifnet *ifp)
{
	struct vr_softc		*sc;

	sc = ifp->if_softc;

	/*
	 * Since we're only asking for completion interrupts only every
	 * few packets, occasionally the watchdog will fire when we have
	 * some TX descriptors to reclaim, so check for that first.
	 */
	vr_txeof(sc);
	if (sc->vr_cdata.vr_tx_cnt == 0)
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
	vr_init(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		vr_start(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
vr_stop(struct vr_softc *sc)
{
	int		i;
	struct ifnet	*ifp;
	bus_dmamap_t	map;

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;

	timeout_del(&sc->sc_to);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	VR_SETBIT16(sc, VR_COMMAND, VR_CMD_STOP);
	VR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_RX_ON|VR_CMD_TX_ON));

	/* wait for xfers to shutdown */
	for (i = VR_TIMEOUT; i > 0; i--) {
		DELAY(10);
		if (!(CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)))
			break;
	}
#ifdef VR_DEBUG
	if (i == 0)
		printf("%s: rx shutdown error!\n", sc->sc_dev.dv_xname);
#endif
	CSR_WRITE_2(sc, VR_IMR, 0x0000);
	CSR_WRITE_4(sc, VR_TXADDR, 0x00000000);
	CSR_WRITE_4(sc, VR_RXADDR, 0x00000000);

	/*
	 * Free data in the RX lists.
	 */
	for (i = 0; i < VR_RX_LIST_CNT; i++) {
		if (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {
			m_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);
			sc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;
		}
		map = sc->vr_cdata.vr_rx_chain[i].vr_map;
		if (map != NULL) {
			if (map->dm_nsegs > 0)
				bus_dmamap_unload(sc->sc_dmat, map);
			bus_dmamap_destroy(sc->sc_dmat, map);
			sc->vr_cdata.vr_rx_chain[i].vr_map = NULL;
		}
	}
	bzero(&sc->vr_ldata->vr_rx_list, sizeof(sc->vr_ldata->vr_rx_list));

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < VR_TX_LIST_CNT; i++) {
		if (sc->vr_cdata.vr_tx_chain[i].vr_mbuf != NULL) {
			m_freem(sc->vr_cdata.vr_tx_chain[i].vr_mbuf);
			sc->vr_cdata.vr_tx_chain[i].vr_mbuf = NULL;
			ifp->if_oerrors++;
		}
		map = sc->vr_cdata.vr_tx_chain[i].vr_map;
		if (map != NULL) {
			if (map->dm_nsegs > 0)
				bus_dmamap_unload(sc->sc_dmat, map);
			bus_dmamap_destroy(sc->sc_dmat, map);
			sc->vr_cdata.vr_tx_chain[i].vr_map = NULL;
		}
	}
	bzero(&sc->vr_ldata->vr_tx_list, sizeof(sc->vr_ldata->vr_tx_list));
}

#ifndef SMALL_KERNEL
int
vr_wol(struct ifnet *ifp, int enable)
{
	struct vr_softc *sc = ifp->if_softc;

	/* Clear WOL configuration */
	CSR_WRITE_1(sc, VR_WOLCRCLR, 0xFF);

	/* Clear event status bits. */
	CSR_WRITE_1(sc, VR_PWRCSRCLR, 0xFF);

	/* Disable PME# assertion upon wake event. */
	VR_CLRBIT(sc, VR_STICKHW, VR_STICKHW_WOL_ENB);
	VR_SETBIT(sc, VR_WOLCFGCLR, VR_WOLCFG_PMEOVR);

	if (enable) {
		VR_SETBIT(sc, VR_WOLCRSET, VR_WOLCR_MAGIC);

		/* Enable PME# assertion upon wake event. */
		VR_SETBIT(sc, VR_STICKHW, VR_STICKHW_WOL_ENB);
		VR_SETBIT(sc, VR_WOLCFGSET, VR_WOLCFG_PMEOVR);
	}

	return (0);
}
#endif

int
vr_alloc_mbuf(struct vr_softc *sc, struct vr_chain_onefrag *r)
{
	struct vr_desc	*d;
	struct mbuf	*m;

	if (r == NULL)
		return (EINVAL);

	m = MCLGETI(NULL, M_DONTWAIT, NULL, MCLBYTES);
	if (!m)
		return (ENOBUFS);

	m->m_len = m->m_pkthdr.len = MCLBYTES;
	m_adj(m, sizeof(u_int64_t));

	if (bus_dmamap_load_mbuf(sc->sc_dmat, r->vr_map, m, BUS_DMA_NOWAIT)) {
		m_free(m);
		return (ENOBUFS);
	}

	bus_dmamap_sync(sc->sc_dmat, r->vr_map, 0, r->vr_map->dm_mapsize,
	    BUS_DMASYNC_PREREAD);

	/* Reinitialize the RX descriptor */
	r->vr_mbuf = m;
	d = r->vr_ptr;
	d->vr_data = htole32(r->vr_map->dm_segs[0].ds_addr);
	if (sc->vr_quirks & VR_Q_BABYJUMBO)
		d->vr_ctl = htole32(VR_RXCTL | VR_RXLEN_BABYJUMBO);
	else
		d->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap.vrm_map, 0,
	    sc->sc_listmap.vrm_map->dm_mapsize, BUS_DMASYNC_PREWRITE);

	d->vr_status = htole32(VR_RXSTAT);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap.vrm_map, 0,
	    sc->sc_listmap.vrm_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	return (0);
}
@


1.152
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.151 2016/03/15 16:45:52 naddy Exp $	*/
a1035 1
		ifp->if_opackets++;
@


1.151
log
@Ethernet drivers no longer need to include if_vlan_var.h for the VLAN
definitions; ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.150 2016/01/26 01:52:10 dlg Exp $	*/
a625 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.150
log
@prettify a NULL test in vr_start.

from richard proctor on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.149 2016/01/26 01:51:33 dlg Exp $	*/
a79 4

#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif
@


1.149
log
@dont leak mbufs on encap failure.

diff from richard proctor on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.148 2015/11/25 03:09:59 dlg Exp $	*/
d1327 1
a1327 1
		if (m== NULL)
@


1.148
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.147 2015/11/24 17:11:39 mpi Exp $	*/
d1333 1
@


1.147
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.146 2015/11/24 12:32:53 mpi Exp $	*/
d1047 1
a1047 1
		ifp->if_flags &= ~IFF_OACTIVE;
d1312 1
a1312 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1322 1
a1322 1
			ifp->if_flags |= IFF_OACTIVE;
d1483 1
a1483 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1611 2
a1612 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.146
log
@No need to include <net/if_types.h> for <net/if_vlan_var.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.145 2015/11/09 00:22:57 dlg Exp $	*/
a78 1
#include <net/if_dl.h>
@


1.145
log
@rework the code to avoid IF_PREPEND.

IF_PREPEND assumes the underlying send queue is using priq, so if you're
using hfsc things dont work well.

part of this shuffle moved the defragmentation of the mbuf to using
m_defrag instead of hand rolled code.

tested by several people on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.144 2015/10/25 13:04:28 mpi Exp $	*/
a82 1
#include <net/if_types.h>
@


1.144
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.143 2015/10/20 17:08:39 chrisz Exp $	*/
d1188 1
a1188 1
vr_encap(struct vr_softc *sc, struct vr_chain **cp, struct mbuf *m_head)
a1191 1
	struct mbuf		*m_new = NULL;
d1195 1
d1198 1
a1198 1
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
d1200 1
a1200 1
		if (m_head->m_pkthdr.csum_flags & M_TCP_CSUM_OUT)
d1202 1
a1202 1
		if (m_head->m_pkthdr.csum_flags & M_UDP_CSUM_OUT)
d1206 6
a1211 23
	/* Deep copy for chips that need alignment, or too many segments */
	if (sc->vr_quirks & VR_Q_NEEDALIGN ||
	    bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m_head,
				 BUS_DMA_NOWAIT | BUS_DMA_WRITE)) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return (1);
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				return (1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,
		    mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;

		if (bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m_new,
		    BUS_DMA_NOWAIT | BUS_DMA_WRITE)) {
			m_freem(m_new);
			return(1);
		}
d1214 14
a1232 8
	/* Check number of available descriptors */
	if (sc->vr_cdata.vr_tx_cnt + c->vr_map->dm_nsegs + runt >=
	    (VR_TX_LIST_CNT - 1)) {
		if (m_new)
			m_freem(m_new);
		return(1);
	}

d1240 2
a1241 2
	if (m_head->m_flags & M_VLANTAG) {
		u_int32_t vtag = m_head->m_pkthdr.ether_vtag;
d1260 1
a1260 6
	if (m_new != NULL) {
		m_freem(m_head);

		c->vr_mbuf = m_new;
	} else
		c->vr_mbuf = m_head;
d1308 1
a1308 1
	struct mbuf		*m_head;
d1321 9
a1329 3
	while (cur_tx->vr_mbuf == NULL) {
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
d1334 3
a1336 4
		if (vr_encap(sc, &cur_tx, m_head)) {
			/* Rollback, send what we were able to encap. */
			IF_PREPEND(&ifp->if_snd, m_head);
			break;
d1349 1
a1349 2
			bpf_mtap_ether(ifp->if_bpf, head_tx->vr_mbuf,
			BPF_DIRECTION_OUT);
a1364 3

		if (cur_tx->vr_mbuf != NULL)
			ifp->if_flags |= IFF_OACTIVE;
@


1.143
log
@Fix 802.1p VLAN priority code points for VLAN_HWTAGGING.
Our in-kernel ether-vtag has a different layout to the vr TXSTAT register.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.142 2015/09/12 10:15:10 miod Exp $	*/
a1539 1
	struct ifaddr		*ifa = (struct ifaddr *) data;
a1549 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.142
log
@More ifmedia64 fallout; that should be the last.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.141 2015/06/24 09:40:54 mpi Exp $	*/
d1245 6
a1250 1
	/* Tell chip to insert VLAN tag if needed. */
d1253 2
a1254 2
		vtag = (vtag << VR_TXSTAT_PQSHIFT) & VR_TXSTAT_PQMASK;
		vr_status |= vtag;
@


1.141
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.140 2015/04/13 08:45:48 mpi Exp $	*/
d141 1
a141 1
void vr_setcfg(struct vr_softc *, int);
d392 1
a392 1
vr_setcfg(struct vr_softc *sc, int media)
@


1.140
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.139 2015/03/14 03:38:48 jsg Exp $	*/
a911 2

		ifp->if_ipackets++;
@


1.139
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.138 2015/03/13 15:58:22 jasper Exp $	*/
d901 1
a901 2
			m0 = m_devget(mtod(m, caddr_t), total_len,
			    ETHER_ALIGN, ifp);
@


1.138
log
@convert to if_input()

ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.137 2014/12/22 02:28:52 tedu Exp $	*/
a92 1
#include <dev/mii/mii.h>
@


1.137
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.136 2014/11/27 03:49:07 brad Exp $	*/
d829 1
a911 1
		m->m_pkthdr.rcvif = ifp;
d944 1
a944 9
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap_ether(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d952 2
@


1.136
log
@rxr ioctl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.135 2014/07/22 13:12:11 mpi Exp $	*/
a76 1
#ifdef INET
a78 1
#endif	/* INET */
a1555 1
#ifdef INET
a1557 1
#endif
@


1.135
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.134 2014/07/08 05:35:19 dlg Exp $	*/
d1580 5
@


1.134
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.133 2014/04/19 14:47:51 henning Exp $	*/
a78 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.133
log
@sigh, another driver fiddling with altq outside #ifdef ALTQ
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.131 2013/12/06 21:03:04 deraadt Exp $	*/
a680 1
	m_clsetwms(ifp, MCLBYTES, 2, VR_RX_LIST_CNT - 1);
d796 1
a796 1
	cd->vr_rx_cnt = 0;
d807 1
d812 3
a814 4
	while (cd->vr_rx_cnt < VR_RX_LIST_CNT) {
		if (vr_alloc_mbuf(sc, cd->vr_rx_prod)) {
			if (cd->vr_rx_cnt == 0)
				timeout_add(&sc->sc_rxto, 0);
d816 1
a816 1
		}
a817 1
		cd->vr_rx_cnt++;
d819 4
d840 1
a840 1
	while(sc->vr_cdata.vr_rx_cnt > 0) {
d854 1
a854 1
		sc->vr_cdata.vr_rx_cnt--;
d1099 1
a1099 1
	if (sc->vr_cdata.vr_rx_cnt == 0) {
d1101 1
a1101 1
		if (sc->vr_cdata.vr_rx_cnt == 0)
d1731 1
a1731 1
	m = MCLGETI(NULL, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
@


1.132
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1353 1
a1353 4
			if (ALTQ_IS_ENABLED(&ifp->if_snd))
				m_freem(m_head);
			else
				IF_PREPEND(&ifp->if_snd, m_head);
@


1.131
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.130 2013/08/21 05:21:44 dlg Exp $	*/
a707 1
		rv = config_activate_children(self, act);
@


1.130
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.129 2013/08/07 01:06:38 bluhm Exp $	*/
a701 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d711 3
@


1.129
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.128 2013/03/07 11:20:26 sthen Exp $	*/
d905 1
a905 1
			    ETHER_ALIGN, ifp, NULL);
@


1.128
log
@remove spurious semicolon at end of if statement in vr_watchdog.
from oga@@bitrig, ok dtucker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.127 2013/02/09 19:17:52 sthen Exp $	*/
a79 1
#include <netinet/in_var.h>
@


1.127
log
@Programme the VT6105M, VT6105 and RhineII-2 to permit frames of up to
1758 bytes (MTU 1740) and raise hardmtu to allow the user to set them.
Tests by Mark Patruck, Michal Markowski, mikeb, beck, dtucker. ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.126 2013/01/28 02:57:02 dtucker Exp $	*/
d1613 1
a1613 1
	if (sc->vr_cdata.vr_tx_cnt == 0);
@


1.127.2.1
log
@MFC, original by sthen@@.
----
remove spurious semicolon at end of if statement in vr_watchdog.
from oga@@bitrig, ok dtucker
----
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.127 2013/02/09 19:17:52 sthen Exp $	*/
d1613 1
a1613 1
	if (sc->vr_cdata.vr_tx_cnt == 0)
@


1.126
log
@Add TX interrupt mitigation for vr(4) chips, loosely based on FreeBSD,
but with tweaks so it works on 6105Ms like those found in pcengines alix
and soekris 5501s.  ok sthen@@, help brad chris mikeb dlg jsing

There may be other 610x chips that would benefit from the VR_Q_INTDISABLE
quirk, please send me a dmesg if you can confirm it works.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.125 2013/01/17 21:49:48 chris Exp $	*/
d167 1
d179 1
a179 1
	    0 },
d181 1
a181 1
	    0 },
d183 2
a184 1
	    VR_Q_CSUM | VR_Q_CAM | VR_Q_HWTAG | VR_Q_INTDISABLE },
d635 3
d1753 4
a1756 1
	d->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);
@


1.125
log
@Don't try to access m_head after it may be freed (unlikely for VT6105M,
but possible). Also don't re-calculate vlan tag repeatedly through the
descriptor loop.

ok dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.124 2013/01/16 06:15:50 dtucker Exp $	*/
d166 1
d182 1
a182 1
	    VR_Q_CSUM | VR_Q_CAM | VR_Q_HWTAG },
d728 1
a728 1
	cd->vr_tx_cnt = 0;
d1202 1
a1202 1
	u_int32_t		vr_ctl = 0, vr_status = 0;
d1263 12
d1292 1
a1292 1
		f->vr_next = htole32(c->vr_nextdesc->vr_paddr);
d1304 1
a1304 1
		f->vr_next = htole32(c->vr_nextdesc->vr_paddr);
d1309 4
a1312 1
	f->vr_ctl |= htole32(VR_TXCTL_LASTFRAG | VR_TXCTL_FINT);
d1601 9
@


1.124
log
@fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.123 2013/01/16 04:23:42 dtucker Exp $	*/
d1252 10
a1269 9
#if NVLAN > 0
		/* Tell chip to insert VLAN tag if needed. */
		if (m_head->m_flags & M_VLANTAG) {
			u_int32_t vtag = m_head->m_pkthdr.ether_vtag;
			vtag = (vtag << VR_TXSTAT_PQSHIFT) & VR_TXSTAT_PQMASK;
			vr_status |= vtag;
			vr_ctl |= htole32(VR_TXCTL_INSERTTAG);
		}
#endif
@


1.123
log
@Add hardware VLAN tag/untag support for VT6105M chips.  Help/feedback/ok
brad@@ chris@@ jsing@@ kettenis@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.122 2013/01/16 03:21:14 dtucker Exp $	*/
d1294 1
a1294 1
	/* Set EOP on the last desciptor */
@


1.122
log
@Keep a count of packets added to the chip's TX queue and only poke the chip
if we've added a packet.  Reduces CPU util a tiny bit.  ok brad@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.121 2012/12/01 09:55:03 brad Exp $	*/
d65 1
d87 5
d641 6
d914 1
d927 15
d1260 9
d1437 3
@


1.121
log
@Don't bother to zero initialize the if_capabilities field first and
then set the flags. Just set the flags as is done everywhere else.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.120 2012/11/29 21:10:32 brad Exp $	*/
d1276 1
d1302 1
d1318 1
a1318 1
	if (sc->vr_cdata.vr_tx_cnt != 0) {
@


1.120
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.119 2012/11/23 18:40:30 gsoares Exp $	*/
a625 1
	ifp->if_capabilities = 0;
d629 2
a630 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
d632 1
a632 1
		ifp->if_capabilities |= IFCAP_CSUM_IPv4|IFCAP_CSUM_TCPv4|
d634 1
@


1.119
log
@set ifp->if_baudrate with IF_Gbps() / IF_Mbps().

OK reyk@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.118 2012/11/15 15:50:19 jsing Exp $	*/
a625 1
	ifp->if_baudrate = IF_Mbps(10);
@


1.118
log
@Do not try to transmit packets if the interface is not running.

ok chris@@ deraadt@@ dtucker@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.116 2012/10/18 21:44:21 deraadt Exp $	*/
d626 1
a626 1
	ifp->if_baudrate = 10000000;
@


1.117
log
@Implement transmit DMA segments. The descriptor usage is from FreeBSD,
which contradicts the datasheet (but actually works).

Also, use a segment (instead of a new mbuf and data copy) to zero-pad
small packets, modeled after if_myx.

ok sthen@@, gerhard@@, henning@@
@
text
@d1279 4
a1282 1
	if (ifp->if_flags & IFF_OACTIVE || sc->vr_link == 0)
@


1.116
log
@Convert a number of old private copies of code which predates
pci_set_powerstate() to using it instead.  Many of these chunks of code had
bugs in them, especially missing delay() calls.  Some of them were doing
things our PCI subsystem is now responsible for handling.  If you have
any of the affected devices, please keep an eye out for regressions.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.115 2012/09/18 14:49:44 gerhard Exp $	*/
d116 1
a116 1
int vr_encap(struct vr_softc *, struct vr_chain *, struct mbuf *);
d123 3
d487 40
a541 2
	int rseg;
	caddr_t kva;
d566 1
a566 1
		goto fail_1;
d576 1
a576 1
		goto fail_1;
d604 11
a614 21
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct vr_list_data),
	    PAGE_SIZE, 0, &sc->sc_listseg, 1, &rseg,
	    BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf(": can't alloc list\n");
		goto fail_2;
	}
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_listseg, rseg,
	    sizeof(struct vr_list_data), &kva, BUS_DMA_NOWAIT)) {
		printf(": can't map dma buffers (%d bytes)\n",
		    sizeof(struct vr_list_data));
		goto fail_3;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct vr_list_data), 1,
	    sizeof(struct vr_list_data), 0, BUS_DMA_NOWAIT, &sc->sc_listmap)) {
		printf(": can't create dma map\n");
		goto fail_4;
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, kva,
	    sizeof(struct vr_list_data), NULL, BUS_DMA_NOWAIT)) {
		printf(": can't load dma map\n");
		goto fail_5;
d616 2
a617 1
	sc->vr_ldata = (struct vr_list_data *)kva;
d669 5
a673 13
fail_5:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_listmap);

fail_4:
	bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct vr_list_data));

fail_3:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);

fail_2:
	pci_intr_disestablish(pc, sc->sc_ih);

fail_1:
d714 3
d720 1
a720 1
		    sc->sc_listmap->dm_segs[0].ds_addr +
d723 1
a723 1
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
d766 1
a766 1
		    sc->sc_listmap->dm_segs[0].ds_addr +
d776 1
a776 1
		    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
d823 2
a824 2
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    0, sc->sc_listmap->dm_mapsize,
d927 2
a928 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
d981 2
a982 2
	while(cur_tx->vr_mbuf != NULL) {
		u_int32_t		txstat;
d986 1
d1000 1
a1000 1
			VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
d1008 5
d1031 1
d1036 1
a1036 1
	if (cur_tx->vr_mbuf == NULL)
d1168 1
a1168 1
vr_encap(struct vr_softc *sc, struct vr_chain *c, struct mbuf *m_head)
d1170 1
d1173 3
a1175 1
	u_int32_t		vr_flags = 0, vr_status = 0;
d1179 1
a1179 1
			vr_flags |= VR_TXCTL_IPCSUM;
d1181 1
a1181 1
			vr_flags |= VR_TXCTL_TCPCSUM;
d1183 1
a1183 1
			vr_flags |= VR_TXCTL_UDPCSUM;
d1186 1
a1187 1
	    m_head->m_pkthdr.len < VR_MIN_FRAMELEN ||
a1203 13
		/*
		 * The Rhine chip doesn't auto-pad, so we have to make
		 * sure to pad short frames out to the minimum frame length
		 * ourselves.
		 */
		if (m_head->m_pkthdr.len < VR_MIN_FRAMELEN) {
			/* data field should be padded with octets of zero */
			bzero(&m_new->m_data[m_new->m_len],
			    VR_MIN_FRAMELEN-m_new->m_len);
			m_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;
			m_new->m_len = m_new->m_pkthdr.len;
		}

d1207 1
a1207 1
			return (1);
d1213 10
d1230 26
d1257 2
a1258 8
	f = c->vr_ptr;
	f->vr_data = htole32(c->vr_map->dm_segs[0].ds_addr);
	f->vr_ctl = htole32(c->vr_map->dm_mapsize);
	f->vr_ctl |= htole32(vr_flags|VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG);
	f->vr_status = htole32(vr_status);

	f->vr_ctl |= htole32(VR_TXCTL_LASTFRAG|VR_TXCTL_FINT);
	f->vr_next = htole32(c->vr_nextdesc->vr_paddr);
d1275 1
a1275 1
	struct vr_chain		*cur_tx;
d1289 2
a1290 1
		if (vr_encap(sc, cur_tx, m_head)) {
d1299 2
a1300 1
		VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
d1308 1
a1308 1
			bpf_mtap_ether(ifp->if_bpf, cur_tx->vr_mbuf,
d1313 1
a1313 1
	if (cur_tx != sc->vr_cdata.vr_tx_prod || cur_tx->vr_mbuf != NULL) {
d1316 2
a1317 2
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
		    sc->sc_listmap->dm_mapsize,
d1431 1
a1431 1
	CSR_WRITE_4(sc, VR_TXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
d1679 2
a1680 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d1684 2
a1685 2
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize,
@


1.115
log
@Wait until all xfers have finished before giving up DMA buffer mappings.

ok deraadt@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.114 2012/01/30 09:11:30 sthen Exp $	*/
a491 1
	pcireg_t		command;
d502 1
a502 33
	/*
	 * Handle power management nonsense.
	 */
	command = pci_conf_read(pa->pa_pc, pa->pa_tag,
	    VR_PCI_CAPID) & 0x000000ff;
	if (command == 0x01) {
		command = pci_conf_read(pa->pa_pc, pa->pa_tag,
		    VR_PCI_PWRMGMTCTRL);
		if (command & VR_PSTATE_MASK) {
			pcireg_t	iobase, membase, irq;

			/* Save important PCI config data. */
			iobase = pci_conf_read(pa->pa_pc, pa->pa_tag,
						VR_PCI_LOIO);
			membase = pci_conf_read(pa->pa_pc, pa->pa_tag,
						VR_PCI_LOMEM);
			irq = pci_conf_read(pa->pa_pc, pa->pa_tag,
						VR_PCI_INTLINE);

			/* Reset the power state. */
			command &= 0xFFFFFFFC;
			pci_conf_write(pa->pa_pc, pa->pa_tag,
						VR_PCI_PWRMGMTCTRL, command);

			/* Restore PCI config data. */
			pci_conf_write(pa->pa_pc, pa->pa_tag,
						VR_PCI_LOIO, iobase);
			pci_conf_write(pa->pa_pc, pa->pa_tag,
						VR_PCI_LOMEM, membase);
			pci_conf_write(pa->pa_pc, pa->pa_tag,
						VR_PCI_INTLINE, irq);
		}
	}
@


1.114
log
@Remove redundant call to vr_reset. From Bryan Steele, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.113 2012/01/05 19:08:25 deraadt Exp $	*/
d1545 11
@


1.113
log
@suspend/resume support for vr(4); from brynet@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.112 2011/12/08 20:19:23 markus Exp $	*/
a1126 1
			vr_reset(sc);
@


1.112
log
@add timeout to fill rx-ring in case of mbuf shortage while in vr_intr();
fixes hanging interfaces similar to in myx(4); ok dlg@@, claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.111 2011/06/22 16:44:27 tedu Exp $	*/
d106 1
d109 2
a110 1
	sizeof(struct vr_softc), vr_probe, vr_attach
d125 1
d573 2
d576 1
a576 20
	/*
	 * Windows may put the chip in suspend mode when it
	 * shuts down. Be sure to kick it in the head to wake it
	 * up again.
	 */
	if (pci_get_capability(pa->pa_pc, pa->pa_tag,
	    PCI_CAP_PWRMGMT, NULL, NULL))
		VR_CLRBIT(sc, VR_STICKHW, (VR_STICKHW_DS0|VR_STICKHW_DS1));

	/* Reset the adapter. */
	vr_reset(sc);

	/*
	 * Turn on bit2 (MIION) in PCI configuration register 0x53 during
	 * initialization and disable AUTOPOLL.
	 */
	pci_conf_write(pa->pa_pc, pa->pa_tag, VR_PCI_MODE,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, VR_PCI_MODE) |
	    (VR_MODE3_MIION << 24));
	VR_CLRBIT(sc, VR_MIICMD, VR_MIICMD_AUTOPOLL);
d686 25
d1310 23
d1346 1
a1346 1
	vr_reset(sc);
@


1.111
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.110 2011/04/20 01:05:28 dlg Exp $	*/
d119 1
d674 1
d792 3
a794 1
		if (vr_alloc_mbuf(sc, cd->vr_rx_prod))
d796 1
d1043 15
@


1.110
log
@do not disable interrupts in the isr and then enable them again
when leaving. when you're handling an interrupt it is masked.
whacking the chip is work for no gain.

diff from chris@@
tested by marco@@
ok by me :)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.109 2011/04/05 18:01:21 henning Exp $	*/
d284 1
a284 1
	bzero((char *)&frame, sizeof(frame));
d308 1
a308 1
	bzero((char *)&frame, sizeof(frame));
d1512 1
a1512 2
	bzero((char *)&sc->vr_ldata->vr_rx_list,
		sizeof(sc->vr_ldata->vr_rx_list));
d1531 1
a1531 2
	bzero((char *)&sc->vr_ldata->vr_tx_list,
		sizeof(sc->vr_ldata->vr_tx_list));
@


1.109
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.108 2011/03/13 15:38:50 stsp Exp $	*/
a1057 3
	/* Disable interrupts. */
	CSR_WRITE_2(sc, VR_IMR, 0x0000);

a1124 3

	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, VR_IMR, VR_INTRS);
@


1.108
log
@Wake On LAN support for vr(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.107 2011/01/13 11:28:14 kettenis Exp $	*/
d1152 1
a1152 1
		if (m_head->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
d1154 1
a1154 1
		if (m_head->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
@


1.107
log
@Get rid of "forever" loop in the interrupt handler such that we drop out of the
interrupt handler if the "no rx buffer available" bit is set and no new mbufs
are available to populate descriptors.  While it doesn't make livelock
mitigation work for everybody, it does resolve some lockup issues.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.106 2010/09/03 18:14:54 kettenis Exp $	*/
d140 3
d649 7
d1541 28
@


1.106
log
@bus_dmamap_sync() freshly initialized Rx descriptors before flipping the bit
that hands them over to the hardware.  This prevents the hardware from seeing
stale contents if the compiler decides to re-order stores or if the hardware
does store-reordering.

There are sme doubts whether the i386/amd64 bus_dmamap_sync() implementation
will be able to convince future compilers that do even more insanely stupid
optimizations from re-ordering stores.  That will be addressed in a seperate
patch.

ok matthew@@, sthen@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.105 2010/05/19 15:27:35 oga Exp $	*/
d1051 3
a1053 8
	for (;;) {

		status = CSR_READ_2(sc, VR_ISR);
		if (status)
			CSR_WRITE_2(sc, VR_ISR, status);

		if ((status & VR_INTRS) == 0)
			break;
d1055 1
d1091 1
a1091 1
			break;
@


1.105
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.104 2009/11/25 13:14:47 claudio Exp $	*/
d1565 4
@


1.105.2.1
log
@MFC:

- - -
revision 1.106
date: 2010/09/03 18:14:54;  author: kettenis;  state: Exp;  lines: +5 -1
bus_dmamap_sync() freshly initialized Rx descriptors before flipping the bit
that hands them over to the hardware.  This prevents the hardware from seeing
stale contents if the compiler decides to re-order stores or if the hardware
does store-reordering.

There are sme doubts whether the i386/amd64 bus_dmamap_sync() implementation
will be able to convince future compilers that do even more insanely stupid
optimizations from re-ordering stores.  That will be addressed in a seperate
patch.

ok matthew@@, sthen@@, oga@@
- - -

from sthen
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.105 2010/05/19 15:27:35 oga Exp $	*/
a1564 4

	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize, BUS_DMASYNC_PREWRITE);

@


1.104
log
@Just some minor cleanup. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.103 2009/11/25 12:45:02 deraadt Exp $	*/
d607 2
a608 1
	    PAGE_SIZE, 0, &sc->sc_listseg, 1, &rseg, BUS_DMA_NOWAIT)) {
a628 1
	bzero(sc->vr_ldata, sizeof(struct vr_list_data));
@


1.103
log
@Consider any tx buffer that is freed in vr_stop() to be an unsent
packet, ie. an output error.  This way, we'll be able to see if the
seized interfaces had tx packets queued.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.102 2009/11/25 12:43:28 deraadt Exp $	*/
a1499 1

a1503 1

a1518 2
		bus_dmamap_t map;

a1531 1

@


1.102
log
@Re-enable the debug messages from bus errors and tx underruns so that
we can dianose if those ever happen.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.101 2009/11/25 12:42:28 deraadt Exp $	*/
d1526 1
@


1.101
log
@Do not call vr_stop() and vr_reset() before calling vr_init(), because
the latter does that itself.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.100 2009/08/13 14:24:47 jasper Exp $	*/
a1086 1
#ifdef VR_DEBUG
a1092 1
#endif
@


1.100
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.99 2009/08/10 19:41:05 deraadt Exp $	*/
a1021 2
		vr_stop(sc);
		vr_reset(sc);
a1467 3

	vr_stop(sc);
	vr_reset(sc);
@


1.99
log
@A few more simple cases of shutdown hooks which only call xxstop, when
we now know the interface has already been stopped
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.98 2009/08/09 11:40:56 deraadt Exp $	*/
d111 1
a111 1
	0, "vr", DV_IFNET
@


1.98
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.97 2009/06/18 18:53:02 claudio Exp $	*/
a124 1
void vr_shutdown(void *);
a669 2

	shutdownhook_establish(vr_shutdown, sc);
a1544 12
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
vr_shutdown(void *arg)
{
	struct vr_softc		*sc = (struct vr_softc *)arg;

	vr_stop(sc);
@


1.97
log
@Remove the if (1) that makes blambert@@ cry. Appreciated blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.96 2009/06/18 17:48:15 claudio Exp $	*/
d1571 2
a1572 2
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
a1573 6

	MCLGETI(m, M_DONTWAIT, &sc->arpcom.ac_if, MCLBYTES);
	if (!(m->m_flags & M_EXT)) {
		m_free(m);
		return (ENOBUFS);
	}
@


1.96
log
@MCLGETI support for vr(4) interfaces. This will make the newer soekris and
Alix boards suck a little bit less because it will be harder to live lock them
with traffic. Diff mostly adapted from sis(4).
OK kettenis@@, dlg@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.95 2009/06/04 16:56:20 sthen Exp $	*/
d868 1
a868 1
		if (1) {
d878 4
a881 1
		} else
a882 4
		{
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		} 
@


1.95
log
@move redundant bus_dmamap_sync calls outside an if/else block.
from Brad; ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.94 2009/05/29 06:57:21 mpf Exp $	*/
d139 1
d142 1
a142 1
int vr_alloc_mbuf(struct vr_softc *, struct vr_chain_onefrag *, struct mbuf *);
d668 1
a754 3
		if (vr_alloc_mbuf(sc, &cd->vr_rx_chain[i], NULL))
			return (ENOBUFS);

d766 3
a768 1
	cd->vr_rx_head = &cd->vr_rx_chain[0];
d773 17
d797 1
a797 1
	struct mbuf		*m0, *m;
d805 1
a805 2
	for (;;) {

d809 1
a809 1
		rxstat = letoh32(sc->vr_cdata.vr_rx_head->vr_ptr->vr_status);
d813 1
a813 1
		rxctl = letoh32(sc->vr_cdata.vr_rx_head->vr_ptr->vr_ctl);
d815 5
a819 3
		m0 = NULL;
		cur_rx = sc->vr_cdata.vr_rx_head;
		sc->vr_cdata.vr_rx_head = cur_rx->vr_nextdesc;
d849 1
a849 9
			/* Reinitialize descriptor */
			cur_rx->vr_ptr->vr_status = htole32(VR_RXSTAT);
			cur_rx->vr_ptr->vr_data =
			    htole32(cur_rx->vr_map->dm_segs[0].ds_addr +
			    sizeof(u_int64_t));
			cur_rx->vr_ptr->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);
			bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
			    0, sc->sc_listmap->dm_mapsize,
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
a855 3
		m = cur_rx->vr_mbuf;
		cur_rx->vr_mbuf = NULL;

d867 3
a869 7
#ifndef __STRICT_ALIGNMENT
		if (vr_alloc_mbuf(sc, cur_rx, NULL) == 0) {
			m->m_pkthdr.rcvif = ifp;
			m->m_pkthdr.len = m->m_len = total_len;
		} else
#endif
		{
d872 1
a872 1
			vr_alloc_mbuf(sc, cur_rx, m);
d878 6
a883 1
		}
d909 2
d942 1
a942 1
	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_head->vr_paddr);
d1356 1
a1356 1
	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_head->vr_paddr);
d1564 1
a1564 1
vr_alloc_mbuf(struct vr_softc *sc, struct vr_chain_onefrag *r, struct mbuf *mb)
d1569 6
a1574 4
	if (mb == NULL) {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return (ENOBUFS);
d1576 4
a1579 8
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_free(m);
			return (ENOBUFS);
		}
	} else  {
		m = mb;
		m->m_data = m->m_ext.ext_buf;
a1582 2
	r->vr_mbuf = m;

d1585 2
a1586 3
	if (bus_dmamap_load_mbuf(sc->sc_dmat, r->vr_map, r->vr_mbuf,
	    BUS_DMA_NOWAIT)) {
		m_freem(r->vr_mbuf);
d1594 1
@


1.94
log
@Return the RX descriptor after pointing it to the new mbuf.
Otherwise the card can mess with mbufs that have been given to the
stack already.  Fixes panics seen with a high rate of of small
packets and POOL_DEBUG enabled.
OK sthen@@, chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.92 2009/05/12 13:30:56 sthen Exp $	*/
d1185 4
a1188 2
		bus_dmamap_sync(sc->sc_dmat, c->vr_map, 0, c->vr_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
d1190 1
d1194 2
a1195 6
	} else {
		bus_dmamap_sync(sc->sc_dmat, c->vr_map, 0, c->vr_map->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

                c->vr_mbuf = m_head;
	}
@


1.93
log
@always set VR_RXCFG_RX_MULTI when setting the chip into promiscuous
mode; VR_RXCFG_RX_PROMISC isn't enough to allow reception of multicast
frames.

Discussed with Brad, ok dlg@@.
@
text
@a1589 1
	d->vr_status = htole32(VR_RXSTAT);
d1592 1
@


1.92
log
@cleanup and simplify promiscuous/multicast setup (setmulti -> iff).
from Brad; ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.91 2009/05/12 08:38:56 sthen Exp $	*/
d345 1
a347 2
		else
			rxfilt |= VR_RXCFG_RX_MULTI;
@


1.91
log
@Fix the URL for datasheets.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.90 2009/05/11 16:23:03 sthen Exp $	*/
d136 1
a136 1
void vr_setmulti(struct vr_softc *);
a321 3
/*
 * Program the 64-bit multicast hash filter.
 */
d323 1
a323 1
vr_setmulti(struct vr_softc *sc)
d325 2
a326 1
	struct ifnet		*ifp;
d328 3
a330 4
	u_int32_t		hashes[2] = { 0, 0 };
	struct arpcom *ac = &sc->arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
a331 1
	int			mcnt = 0;
d333 4
a336 1
	ifp = &sc->arpcom.ac_if;
d338 4
a341 1
	rxfilt = CSR_READ_1(sc, VR_RXCFG);
d343 9
a351 2
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
d353 11
a363 5
		CSR_WRITE_1(sc, VR_RXCFG, rxfilt);
		CSR_WRITE_4(sc, VR_MAR0, 0xFFFFFFFF);
		CSR_WRITE_4(sc, VR_MAR1, 0xFFFFFFFF);
		return;
	}
d365 1
a365 10
	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, VR_MAR0, 0);
	CSR_WRITE_4(sc, VR_MAR1, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
a366 8
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		mcnt++;

		ETHER_NEXT_MULTI(step, enm);
a368 5
	if (mcnt)
		rxfilt |= VR_RXCFG_RX_MULTI;
	else
		rxfilt &= ~VR_RXCFG_RX_MULTI;

a1338 12
	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		VR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);
	else
		VR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_PROMISC);

	/* Set capture broadcast bit to capture broadcast frames. */
	if (ifp->if_flags & IFF_BROADCAST)
		VR_SETBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);
	else
		VR_CLRBIT(sc, VR_RXCFG, VR_RXCFG_RX_BROAD);

d1340 1
a1340 1
	 * Program the multicast filter, if necessary.
d1342 1
a1342 1
	vr_setmulti(sc);
d1427 4
a1430 19
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->sc_if_flags & IFF_PROMISC)) {
				VR_SETBIT(sc, VR_RXCFG,
				    VR_RXCFG_RX_PROMISC);
				vr_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->sc_if_flags & IFF_PROMISC) {
				VR_CLRBIT(sc, VR_RXCFG,
				    VR_RXCFG_RX_PROMISC);
				vr_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    (ifp->if_flags ^ sc->sc_if_flags) & IFF_ALLMULTI) {
				vr_setmulti(sc);
			} else {
				if (!(ifp->if_flags & IFF_RUNNING))
					vr_init(sc);
			}
a1434 1
		sc->sc_if_flags = ifp->if_flags;
d1448 1
a1448 1
			vr_setmulti(sc);
@


1.90
log
@in the case where mbufs had to be copied _and_ checksums were enabled,
m_head could be accessed after it had been freed, so do the access earlier.
from chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.89 2009/05/11 10:25:07 sthen Exp $	*/
d42 1
a42 1
 * Datasheets are available at http://www.via.com.tw.
@


1.89
log
@preliminary parts for hw vlan tag insertion/removal, ideas gleaned from
via rhinefet. not yet used, but committing now so it isn't lost.

from chris@@, ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.88 2009/05/11 08:03:57 sthen Exp $	*/
d1148 9
a1203 9
	}

	if (sc->vr_quirks & VR_Q_CSUM) {
		if (m_head->m_pkthdr.csum_flags & M_IPV4_CSUM_OUT)
			vr_flags |= VR_TXCTL_IPCSUM;
		if (m_head->m_pkthdr.csum_flags & M_TCPV4_CSUM_OUT)
			vr_flags |= VR_TXCTL_TCPCSUM;
		if (m_head->m_pkthdr.csum_flags & M_UDPV4_CSUM_OUT)
			vr_flags |= VR_TXCTL_UDPCSUM;
@


1.88
log
@On VT6105M, use hardware IP, TCP and UDP checksums in and out. Tested on
alix/net5501 with and without software vlan tagging, also with NFS (v2, v3,
UDP, TCP). Not used on earlier chips and does not introduce problems on
original EPIA board.

From chris@@, based on enhancements in the FreeBSD driver.
"put it in then" dlg@@, looks good to claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.87 2009/05/11 07:56:52 sthen Exp $	*/
d902 1
a902 1
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
d1146 1
a1146 1
	u_int32_t		vr_flags = 0;
d1210 1
a1210 1
	f->vr_status = htole32(0);
d1261 1
a1261 1
			bpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf,
@


1.87
log
@Start using VR_RXSTAT_RX_OK instead of VR_RXSTAT_ERR (It exists
from the oldest vt86c100a datasheet to the newest vt6105m. FreeBSD
indicates that it is more reliable than VR_RXSTAT_ERR for detecting
error conditions, that its use results in less incorrectly dropped
packets).  From chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.86 2009/05/10 12:35:46 sthen Exp $	*/
d646 1
d650 4
a653 1
	ifp->if_capabilities = IFCAP_VLAN_MTU;
d791 1
a791 1
	u_int32_t		rxstat;
d804 2
a852 9
		/*
		 * XXX The VIA Rhine chip includes the CRC with every
		 * received frame, and there's no way to turn this
		 * behavior off (at least, I can't find anything in
		 * the manual that explains how to do it) so we have
		 * to trim off the CRC manually.
		 */
		total_len -= ETHER_CRC_LEN;

d860 7
d885 11
d1146 1
d1197 9
d1209 1
a1209 1
	f->vr_ctl |= htole32(VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG);
@


1.86
log
@- fix whitespace problems (introduces no change with diff -w)
- s/FreeBSD/OpenBSD/ in comment, suggested by mpf

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.85 2009/05/10 12:31:58 sthen Exp $	*/
d810 1
a810 1
		if (rxstat & VR_RXSTAT_RXERR) {
@


1.85
log
@- use nitems() rather than handrolled version.
- add HWTAG capability to the quirks table. not yet used.
from chris@@.  no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.84 2009/05/10 12:09:46 sthen Exp $	*/
d59 1
a59 1
 * FreeBSD doesn't guarantee that mbufs will be filled in starting
d240 1
a240 1
{      
d258 1
a258 1
		DELAY(1); 
d447 1
a447 1
	}       
d456 1
a456 1
int                
d495 1
a495 1
	struct pci_attach_args 	*pa = aux;
d716 1
a716 1
			cd->vr_tx_chain[i].vr_nextdesc = 
d746 1
a746 1
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 
d762 1
a762 1
		else 
d808 1
a808 1
	 	 * comes up in the ring.
d844 1
a844 1
		/* No errors; receive the packet. */	
d851 1
a851 1
	 	 * the manual that explains how to do it) so we have
d906 1
a906 1
	ifp->if_ierrors++;      
d908 2
a909 2
	VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);      
	DELAY(10000);  
d911 1
a911 1
	for (i = 0x400; 
d913 1
a913 1
	    i--)  
d916 1
a916 1
	if (!i) {       
d919 1
a919 1
		return; 
d996 1
a996 1
 		ifp->if_timer = 0;
d1009 1
a1009 1
		vr_reset(sc);   
d1012 1
a1012 1
	}           
d1058 1
a1058 1
		}       
d1107 1
a1107 1
					    VR_CMD_TX_GO); 
@


1.84
log
@- change device matching to use a quirks table.

- avoid the need for unnecessary mbuf copies on modern vr(4) devices
(ancient ones required longword-alignment, but this has not been the case
for several generations now). reduces cpu time, particularly for forwarded
traffic.

from chris@@. tested by chris@@, myself, Emilio Perea on various devices
including original VIA EPIA, Soekris net5501, pcengines.ch ALIX.

ok mpf. deraadt and dlg agree with committing at this stage.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.83 2009/04/30 18:28:29 mpf Exp $	*/
d149 1
d165 1
a165 1
	    VR_Q_CSUM | VR_Q_CAM },
d461 1
a461 1
	int i, nent = sizeof(vr_devices)/sizeof(vr_devices[0]);
d475 1
a475 1
	int i, nent = sizeof(vr_devices)/sizeof(vr_devices[0]);
@


1.83
log
@The previous change did not always update vr_link on rlphy(4) based
interfaces. Therefore we now always start off with vr_link = 1.
Bug found and feedback by Emilio Perea.
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.82 2009/04/28 12:54:31 mpf Exp $	*/
d57 1
a57 1
 * The Rhine has a serious flaw in its transmit DMA mechanism:
d104 1
d143 26
a168 8
const struct pci_matchid vr_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINE },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII_2 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105M },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_RHINEII },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_RHINEII }
d455 15
d471 1
a471 1
vr_probe(struct device *parent, void *match, void *aux)
d473 9
a481 2
	return (pci_matchbyid((struct pci_attach_args *)aux, vr_devices,
	    sizeof(vr_devices)/sizeof(vr_devices[0])));
d636 1
d1131 33
a1163 6
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return (1);
	if (m_head->m_pkthdr.len > MHLEN) {
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
d1167 4
a1170 3
	}
	m_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));
	m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
d1172 4
a1175 12
	/*
	 * The Rhine chip doesn't auto-pad, so we have to make
	 * sure to pad short frames out to the minimum frame length
	 * ourselves.
	 */
	if (m_new->m_len < VR_MIN_FRAMELEN) {
		/* data field should be padded with octets of zero */
		bzero(&m_new->m_data[m_new->m_len],
		    VR_MIN_FRAMELEN-m_new->m_len);
		m_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;
		m_new->m_len = m_new->m_pkthdr.len;
	}
d1177 1
a1177 4
	if (bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m_new,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE)) {
		m_freem(m_new);
		return (1);
a1178 6
	bus_dmamap_sync(sc->sc_dmat, c->vr_map, 0, c->vr_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	m_freem(m_head);

	c->vr_mbuf = m_new;
@


1.82
log
@The TX engine can get stuck if the interface went through a link
state change. Workaround by resetting the chip if necessary.
Also do not try to send packets if our link is down, as this triggers
watchdog timeouts.  While there correct the VR_RXSTAT_RX_OK define
(not used yet).  Changes inspired from FreeBSDs overhauled vr(4).
Testing, input and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.81 2009/03/29 21:53:52 sthen Exp $	*/
d1304 1
a1304 1
	sc->vr_link = 0;
@


1.81
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.80 2008/11/28 02:44:18 brad Exp $	*/
d369 1
a369 1
	int restart = 0;
d371 7
a377 4
	if (CSR_READ_2(sc, VR_COMMAND) & (VR_CMD_TX_ON|VR_CMD_RX_ON)) {
		restart = 1;
		VR_CLRBIT16(sc, VR_COMMAND, (VR_CMD_TX_ON|VR_CMD_RX_ON));
	}
d379 4
a382 4
	if ((media & IFM_GMASK) == IFM_FDX)
		VR_SETBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);
	else
		VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_FULLDUPLEX);
a383 1
	if (restart)
d385 16
d1153 3
a1155 1
	if (ifp->if_flags & IFF_OACTIVE)
a1157 2
	sc = ifp->if_softc;

d1304 1
@


1.80
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.79 2008/10/14 18:01:53 naddy Exp $	*/
d485 1
a485 1
		printf(": failed to map i/o space\n");
d491 1
a491 1
		printf(": failed to map memory space\n");
d498 1
a498 1
		printf(": couldn't map interrupt\n");
d505 1
a505 1
		printf(": could not establish interrupt");
@


1.79
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.78 2008/10/02 20:21:14 brad Exp $	*/
d1329 1
a1331 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d1345 1
d1373 1
a1373 22
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				vr_setmulti(sc);
			error = 0;
		}
		break;
d1378 1
d1381 6
@


1.78
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.77 2008/09/24 08:41:29 mpf Exp $	*/
d809 2
a810 2
			m0 = m_devget(mtod(m, caddr_t) - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
a815 1
			m_adj(m0, ETHER_ALIGN);
@


1.77
log
@Fix a vr(4) panic that occurs under high load.
If the RX path runs into an out of mbuf scenario, the code
will leave the RX chain with a NULL'd mbuf-slot.
We now always reassign a valid mbuf, even if m_devget() fails.

OK brad@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.76 2008/09/10 14:01:23 blambert Exp $	*/
a1335 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1400 1
a1400 2
		error = ENOTTY;
		break;
a1403 1

@


1.76
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.75 2008/07/24 19:01:28 thib Exp $	*/
d811 2
a812 1
			if (m0 == NULL || vr_alloc_mbuf(sc, cur_rx, m)) {
@


1.75
log
@dont need malloc.h anymore; plus two tiny whitespace fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.74 2008/07/18 13:38:40 thib Exp $	*/
d954 1
a954 1
	timeout_add(&sc->sc_to, hz);
d1292 1
a1292 1
		timeout_add(&sc->sc_to, hz);
@


1.75.2.1
log
@Fix a vr(4) panic that occurs under high load.
If the RX path runs into an out of mbuf scenario, the code
will leave the RX chain with a NULL'd mbuf-slot.
We now always reassign a valid mbuf, even if m_devget() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.75 2008/07/24 19:01:28 thib Exp $	*/
d811 1
a811 2
			vr_alloc_mbuf(sc, cur_rx, m);
			if (m0 == NULL) {
@


1.74
log
@o Use mbufs, for the RX ring, instead of malloc()'ing an MCLBYTES sized buffer.
o On non-strict alignment archs, dont copy the mbuf, every time, unload it, and send
  it up the stack and just get a new one for the rx ring. We still do the copy on
  strict alignment archs though...
o create a function to handle mbuf allocation for the rx ring, vr_mbuf_alloc(),
  use it to allocate the mbufs and shuffle the bus dma setup around.

ideas/code from vic(4) and sis(4);

ok reyk@@, brad@@, dlg@@
tested by many, been in snapshots for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.73 2008/05/22 19:23:04 mk Exp $	*/
a69 1
#include <sys/malloc.h>
d684 1
a684 1
	for (i = 0; i < VR_RX_LIST_CNT; i++)  {
d712 1
a712 1
	return(0);
@


1.73
log
@More timeout(9) usage cleaned up.

ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.72 2008/02/07 16:04:01 thib Exp $	*/
d141 2
a678 1
	int			i;
d680 1
d685 6
a690 1
	for (i = 0; i < VR_RX_LIST_CNT; i++) {
a695 4
		cd->vr_rx_chain[i].vr_buf =
		    (u_int8_t *)malloc(MCLBYTES, M_DEVBUF, M_NOWAIT);
		if (cd->vr_rx_chain[i].vr_buf == NULL)
			return (ENOBUFS);
d697 1
a697 3
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 
		    0, BUS_DMA_NOWAIT | BUS_DMA_READ,
		    &cd->vr_rx_chain[i].vr_map))
d700 9
a708 26
		if (bus_dmamap_load(sc->sc_dmat, cd->vr_rx_chain[i].vr_map,
		    cd->vr_rx_chain[i].vr_buf, MCLBYTES, NULL, BUS_DMA_NOWAIT))
			return (ENOBUFS);
		bus_dmamap_sync(sc->sc_dmat, cd->vr_rx_chain[i].vr_map,
		    0, cd->vr_rx_chain[i].vr_map->dm_mapsize,
		    BUS_DMASYNC_PREREAD);

		d->vr_status = htole32(VR_RXSTAT);
		d->vr_data =
		    htole32(cd->vr_rx_chain[i].vr_map->dm_segs[0].ds_addr +
		    sizeof(u_int64_t));
		d->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);

		if (i == (VR_RX_LIST_CNT - 1)) {
			cd->vr_rx_chain[i].vr_nextdesc =
			    &cd->vr_rx_chain[0];
			ld->vr_rx_list[i].vr_next =
			    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[0]));
		} else {
			cd->vr_rx_chain[i].vr_nextdesc =
			    &cd->vr_rx_chain[i + 1];
			ld->vr_rx_list[i].vr_next =
			    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[i + 1]));
		}
a712 4
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

d723 1
a723 1
	struct mbuf		*m0;
d796 3
d800 2
a801 7
		    cur_rx->vr_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		m0 = m_devget(cur_rx->vr_buf + sizeof(u_int64_t) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
		bus_dmamap_sync(sc->sc_dmat, cur_rx->vr_map, 0,
		    cur_rx->vr_map->dm_mapsize,
		    BUS_DMASYNC_PREREAD);
d803 15
a817 13
		/* Reinitialize descriptor */
		cur_rx->vr_ptr->vr_status = htole32(VR_RXSTAT);
		cur_rx->vr_ptr->vr_data =
		    htole32(cur_rx->vr_map->dm_segs[0].ds_addr +
		    sizeof(u_int64_t));
		cur_rx->vr_ptr->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
		    sc->sc_listmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

		if (m0 == NULL) {
			ifp->if_ierrors++;
			continue;
a818 1
		m_adj(m0, ETHER_ALIGN);
d827 1
a827 1
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_IN);
d830 1
a830 1
		ether_input_mbuf(ifp, m0);
d1461 3
a1463 3
		if (sc->vr_cdata.vr_rx_chain[i].vr_buf != NULL) {
			free(sc->vr_cdata.vr_rx_chain[i].vr_buf, M_DEVBUF);
			sc->vr_cdata.vr_rx_chain[i].vr_buf = NULL;
d1510 48
@


1.72
log
@Add the SIOCSIFMTU ioctl to allow ioctl changes;

ok brad@@ (w/ comments), reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.71 2007/11/26 09:28:33 martynas Exp $	*/
d1467 1
a1467 2
	if (timeout_pending(&sc->sc_to))
		timeout_del(&sc->sc_to);
@


1.71
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.70 2007/10/02 07:22:18 brad Exp $	*/
d1398 6
@


1.70
log
@In vr_attach() only touch the VR_STICKHW register if the adapter
is found to have PCI power management capability. It has been
found that unconditionally touching this register with the original
VIA Rhine chipset, which does not have power management capability,
and due to the shorter width of the IO addess space, it is possible
for the vr(4) driver to do bad things with hw with IO address space
adjacent to a vr(4) adapter.

Tested by a few users, brad@@ and jmc@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.69 2007/09/12 19:49:29 brad Exp $	*/
d991 1
a991 1
	/* Supress unwanted interrupts. */
@


1.69
log
@Remove the old software bit-banging MII interface, we started using
the Rhine's shift registers four and a half years ago (1.31).

From phk@@FreeBSD

ok dlg@@

Tested by brad@@ and Jacob Yocom-Piatt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.68 2007/09/01 10:26:25 mglocker Exp $	*/
d519 3
a521 1
	VR_CLRBIT(sc, VR_STICKHW, (VR_STICKHW_DS0|VR_STICKHW_DS1));
@


1.68
log
@Add VLAN reception support to vr(4).  Diff from Brad.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.67 2006/11/03 23:45:26 brad Exp $	*/
a100 1
#undef VR_USESWSHIFT
a128 2
void vr_mii_sync(struct vr_softc *);
void vr_mii_send(struct vr_softc *, u_int32_t, int);
a182 43
#ifdef VR_USESWSHIFT
/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
vr_mii_sync(struct vr_softc *sc)
{
	int			i;

	SIO_SET(VR_MIICMD_DIR|VR_MIICMD_DATAIN);

	for (i = 0; i < 32; i++) {
		SIO_SET(VR_MIICMD_CLK);
		DELAY(1);
		SIO_CLR(VR_MIICMD_CLK);
		DELAY(1);
	}
}

/*
 * Clock a series of bits through the MII.
 */
void
vr_mii_send(struct vr_softc *sc, u_int32_t bits, int cnt)
{
	int			i;

	SIO_CLR(VR_MIICMD_CLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
		if (bits & i) {
			SIO_SET(VR_MIICMD_DATAIN);
		} else {
			SIO_CLR(VR_MIICMD_DATAIN);
		}
		DELAY(1);
		SIO_CLR(VR_MIICMD_CLK);
		DELAY(1);
		SIO_SET(VR_MIICMD_CLK);
	}
}
#endif

a187 88
#ifdef VR_USESWSHIFT
{
	int			i, ack, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = VR_MII_STARTDELIM;
	frame->mii_opcode = VR_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;
	
	CSR_WRITE_1(sc, VR_MIICMD, 0);
	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);

	/*
 	 * Turn on data xmit.
	 */
	SIO_SET(VR_MIICMD_DIR);

	vr_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	vr_mii_send(sc, frame->mii_stdelim, 2);
	vr_mii_send(sc, frame->mii_opcode, 2);
	vr_mii_send(sc, frame->mii_phyaddr, 5);
	vr_mii_send(sc, frame->mii_regaddr, 5);

	/* Idle bit */
	SIO_CLR((VR_MIICMD_CLK|VR_MIICMD_DATAIN));
	DELAY(1);
	SIO_SET(VR_MIICMD_CLK);
	DELAY(1);

	/* Turn off xmit. */
	SIO_CLR(VR_MIICMD_DIR);

	/* Check for ack */
	SIO_CLR(VR_MIICMD_CLK);
	DELAY(1);
	ack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;
	SIO_SET(VR_MIICMD_CLK);
	DELAY(1);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			SIO_CLR(VR_MIICMD_CLK);
			DELAY(1);
			SIO_SET(VR_MIICMD_CLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		SIO_CLR(VR_MIICMD_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT)
				frame->mii_data |= i;
			DELAY(1);
		}
		SIO_SET(VR_MIICMD_CLK);
		DELAY(1);
	}

fail:

	SIO_CLR(VR_MIICMD_CLK);
	DELAY(1);
	SIO_SET(VR_MIICMD_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}
#else  
d212 1
a212 3
}      
#endif         

a218 47
#ifdef VR_USESWSHIFT
{
	int			s;

	s = splnet();

	CSR_WRITE_1(sc, VR_MIICMD, 0);
	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_DIRECTPGM);

	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = VR_MII_STARTDELIM;
	frame->mii_opcode = VR_MII_WRITEOP;
	frame->mii_turnaround = VR_MII_TURNAROUND;
	
	/*
 	 * Turn on data output.
	 */
	SIO_SET(VR_MIICMD_DIR);

	vr_mii_sync(sc);

	vr_mii_send(sc, frame->mii_stdelim, 2);
	vr_mii_send(sc, frame->mii_opcode, 2);
	vr_mii_send(sc, frame->mii_phyaddr, 5);
	vr_mii_send(sc, frame->mii_regaddr, 5);
	vr_mii_send(sc, frame->mii_turnaround, 2);
	vr_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	SIO_SET(VR_MIICMD_CLK);
	DELAY(1);
	SIO_CLR(VR_MIICMD_CLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	SIO_CLR(VR_MIICMD_DIR);

	splx(s);

	return(0);
}
#else  
a243 1
#endif                 
@


1.67
log
@vr_rxeof(): stick receive error messages under VR_DEBUG.
vr_init(): add debug printfs for some error conditions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.66 2006/11/03 22:32:27 brad Exp $	*/
d768 2
@


1.66
log
@vr_intr(): remove duplicate check for VR_ISR_RX_NOBUF and the "packet lost"
printf which will never be reached.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.65 2006/09/22 03:18:57 brad Exp $	*/
d952 1
d970 1
d1216 8
d1235 8
d1351 1
a1351 1
			if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
d1353 1
a1353 1
			} else {
a1354 1
			}
@


1.65
log
@put a few printf's in the interrupt handler under VR_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.64 2006/06/17 18:00:43 brad Exp $	*/
d1200 1
a1200 1
		    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW)) {
a1207 2
			if (status & VR_ISR_RX_DROPPED)
				printf(" packet lost");
d1239 1
a1239 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
a1240 1
	}
@


1.64
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.63 2006/05/28 00:04:24 jason Exp $	*/
d585 1
a585 1
#ifdef DEBUG
d1193 1
d1195 1
d1201 1
d1211 1
@


1.63
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.62 2006/04/28 06:32:31 brad Exp $	*/
d72 1
@


1.62
log
@check for IFF_RUNNING being set before calling vr_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.61 2006/03/25 22:41:46 djm Exp $	*/
d1581 1
a1581 1
		error = EINVAL;
@


1.61
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.60 2006/03/20 16:15:03 brad Exp $	*/
a1211 1
			ifp->if_flags &= ~IFF_RUNNING;
a1379 5
	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return;
	}

d1488 1
a1488 2
	if (ifp->if_flags & IFF_UP) {
		ifp->if_flags &= ~IFF_RUNNING;
a1489 1
	}
d1491 1
a1491 1
	return(0);
d1526 2
a1527 2
		vr_init(sc);
		switch (ifa->ifa_addr->sa_family) {
d1529 1
a1529 1
		case AF_INET:
d1531 1
a1531 5
			break;
#endif	/* INET */
		default:
			break;
		}
d1548 1
a1548 1
			    (ifp->if_flags ^ sc->sc_if_flags) & IFF_ALLMULTI)
d1550 4
a1553 2
			else
				vr_init(sc);
@


1.60
log
@de-register.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.59 2006/02/07 18:15:20 brad Exp $	*/
d1025 1
a1025 1
			bpf_mtap(ifp->if_bpf, m0);
d1348 2
a1349 1
			bpf_mtap(ifp->if_bpf, cur_tx->vr_mbuf);
@


1.59
log
@move the devices list up a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.58 2006/02/06 23:57:04 brad Exp $	*/
d192 1
a192 1
	register int		i;
d570 1
a570 1
	register int		i;
@


1.58
log
@vr_start(): return if IFF_OACTIVE is set.

From FreeBSD via Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.57 2006/02/05 23:23:18 brad Exp $	*/
d143 10
a595 10

const struct pci_matchid vr_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINE },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII_2 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105M },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_RHINEII },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_RHINEII },
};
@


1.57
log
@make sure to set or clear the RX mode promiscuous bit.

tested by Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.56 2006/02/05 18:23:37 brad Exp $	*/
d1317 3
@


1.56
log
@call vr_setmulti() if adjusting PROMISC or ALLMULTI and do not do a full
re-init if configuring the IP address.

tested by Andrey Matveev
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.55 2006/01/14 09:50:20 brad Exp $	*/
d1530 1
a1533 1
			vr_init(sc);
a1537 1
			vr_init(sc);
d1543 14
a1556 3
			if ((ifp->if_flags & IFF_RUNNING) &&
			    ((ifp->if_flags ^ sc->sc_if_flags) &
			     (IFF_ALLMULTI | IFF_PROMISC)) != 0)
@


1.55
log
@- the allmulti target initially enables all multicast mode so don't bother
checking the IFF_ALLMULTI flag.
- clean up vr_encap() a bit.

From: Andrey Matveev <evol at online dot ptt dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.54 2005/12/10 18:34:11 krw Exp $	*/
d1212 1
d1377 5
d1490 2
a1491 1
	if (ifp->if_flags & IFF_UP)
d1493 1
d1544 6
a1549 1
			vr_init(sc);
d1554 1
a1554 1
		error = 0;
@


1.54
log
@Check dm_nsegs > 0 rather than dm_segs > 0 when deciding if there are
valid segments to unload. Spotted by lint.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.53 2005/12/10 18:29:12 brad Exp $	*/
d493 1
a494 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d1289 2
d1297 2
a1298 3
	c->vr_mbuf = m_new;
	c->vr_ptr->vr_ctl |= htole32(VR_TXCTL_LASTFRAG|VR_TXCTL_FINT);
	c->vr_ptr->vr_next = htole32(c->vr_nextdesc->vr_paddr);
@


1.53
log
@remove an unused mbuf struct from vr_encap(), leftover from Jason's bus_dma conversion.

From Andrey Matveev <evol at online dot ptt dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.52 2005/12/10 04:22:39 brad Exp $	*/
d1122 1
a1122 1
		if (cur_tx->vr_map != NULL && cur_tx->vr_map->dm_segs > 0)
d1627 1
a1627 1
			if (map->dm_segs > 0)
@


1.52
log
@ANSI functions.

From Andrey Matveev <evol at online dot ptt dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.51 2005/12/08 23:45:49 brad Exp $	*/
a1250 1
	struct mbuf		*m = m_head;
a1251 2

	m = m_head;
@


1.51
log
@- remove unnecessary return at end of void function
- remove unnecessary cast to void for splx

From Andrey Matveev <evol at online dot ptt dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.50 2005/12/07 22:48:38 brad Exp $	*/
d180 1
a180 2
vr_mii_sync(sc)
	struct vr_softc		*sc;
d198 1
a198 4
vr_mii_send(sc, bits, cnt)
	struct vr_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d222 1
a222 4
vr_mii_readreg(sc, frame)
	struct vr_softc		*sc;
	struct vr_mii_frame	*frame;
	
d343 1
a343 4
vr_mii_writereg(sc, frame)
	struct vr_softc		*sc;
	struct vr_mii_frame	*frame;
	
d419 1
a419 3
vr_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d443 1
a443 3
vr_miibus_writereg(dev, phy, reg, data)
	struct device *dev;
	int phy, reg, data;
d467 1
a467 2
vr_miibus_statchg(dev)
	struct device *dev;
d478 1
a478 2
vr_setmulti(sc)
	struct vr_softc		*sc;
d539 1
a539 3
vr_setcfg(sc, media)
	struct vr_softc *sc;
	int media;
d558 1
a558 2
vr_reset(sc)
	struct vr_softc		*sc;
d601 1
a601 3
vr_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d612 1
a612 3
vr_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d814 1
a814 2
vr_list_tx_init(sc)
	struct vr_softc		*sc;
d852 1
a852 2
vr_list_rx_init(sc)
	struct vr_softc		*sc;
d920 1
a920 2
vr_rxeof(sc)
	struct vr_softc		*sc;
d1037 1
a1037 2
vr_rxeoc(sc)
	struct vr_softc		*sc;
d1073 1
a1073 2
vr_txeof(sc)
	struct vr_softc		*sc;
d1138 1
a1138 2
vr_tick(xsc)
	void *xsc;
d1158 1
a1158 2
vr_intr(arg)
	void			*arg;
d1248 1
a1248 4
vr_encap(sc, c, m_head)
	struct vr_softc		*sc;
	struct vr_chain		*c;
	struct mbuf		*m_head;
d1313 1
a1313 2
vr_start(ifp)
	struct ifnet		*ifp;
d1369 1
a1369 2
vr_init(xsc)
	void			*xsc;
d1482 1
a1482 2
vr_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1496 1
a1496 3
vr_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1507 1
a1507 4
vr_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
d1576 1
a1576 2
vr_watchdog(ifp)
	struct ifnet		*ifp;
d1598 1
a1598 2
vr_stop(sc)
	struct vr_softc		*sc;
d1667 1
a1667 2
vr_shutdown(arg)
	void			*arg;
@


1.50
log
@this should fix the VT6103.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.49 2005/11/07 02:57:45 brad Exp $	*/
a192 2

	return;
d339 1
a339 1
	(void)splx(s);
d422 1
a422 1
	(void)splx(s);
a477 2

	return;
a546 2

	return;
a572 2

	return;
a1059 2

	return;
a1091 2

	return;
a1632 2

	return;
a1702 2

	return;
@


1.49
log
@- splimp -> splnet
- remove spl's from attach
- removing redundant checks before pci_mapreg_map()
- fix dmesg printing
- de-allocate resources on failure to attach
- remove unused VLAN input code from vge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.48 2005/11/04 16:59:45 brad Exp $	*/
d440 1
d466 1
@


1.48
log
@- splimp -> splnet
- remove spl's from attach
- fix dmesg printing
- de-allocate resources on failure to attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.47 2005/09/11 18:17:08 mickey Exp $	*/
d599 1
d603 1
d765 1
a765 1
		printf("%s: can't alloc list\n", sc->sc_dev.dv_xname);
d770 2
a771 2
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sc_dev.dv_xname, sizeof(struct vr_list_data));
d776 1
a776 1
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
d781 1
a781 1
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
@


1.47
log
@do not inline pci_mapreg_map() anymore as it is olrite now; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.46 2005/07/06 02:22:28 brad Exp $	*/
d236 1
a236 1
	s = splimp();
d323 1
a323 1
	s = splimp();
d360 1
a360 1
	s = splimp();
d406 1
a406 1
	s = splimp();
d641 2
a642 2
	int			s, i;
	u_int32_t		command;
d649 1
a649 1
	bus_size_t		iosize;
a652 2
	s = splimp();

a689 2
	command = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	sc->vr_revid = PCI_REVISION(pa->pa_class);
a691 4
	if (!(command & PCI_COMMAND_IO_ENABLE)) {
		printf(": failed to enable I/O ports\n");
		goto fail;
	}
d693 1
a693 1
	    &sc->vr_btag, &sc->vr_bhandle, NULL, &iosize, 0)) {
d695 1
a695 1
		goto fail;
a697 4
	if (!(command & PCI_COMMAND_MEM_ENABLE)) {
		printf(": failed to enable memory mapping\n");
		goto fail;
	}
d699 1
a699 1
	    &sc->vr_btag, &sc->vr_bhandle, NULL, &iosize, 0)) {
d701 1
a701 1
		goto fail;
d722 2
d758 1
a758 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d764 1
a764 1
		goto fail_1;
d770 1
a770 2
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
		goto fail_1;
d775 1
a775 3
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct vr_list_data));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
		goto fail_1;
d780 1
a780 4
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_listmap);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct vr_list_data));
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
		goto fail_1;
d819 13
d834 1
a834 4
	bus_space_unmap(sc->vr_btag, sc->vr_bhandle, iosize);
fail:
	splx(s);
	return;
d1180 1
a1180 1
	s = splimp();
d1419 1
a1419 1
	s = splimp();
d1563 1
a1563 1
	s = splimp();
@


1.46
log
@- Rewritten TX to use only two pointers to track producer/consumer.
- Bugfix: don't forget to set IFF_OACTIVE when TX list is full.

From FreeBSD

- clear IFF_RUNNING & IFF_OACTIVE in vr_stop() before de-allocating resources.

Thanks to cloder@@, millert@@ and pedro@@ for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.45 2005/01/15 05:24:11 brad Exp $	*/
a648 1
	bus_addr_t		iobase;
d664 1
a664 1
			u_int32_t		iobase, membase, irq;
d700 3
a702 2
	if (pci_io_find(pc, pa->pa_tag, VR_PCI_LOIO, &iobase, &iosize)) {
		printf(": failed to find i/o space\n");
a704 5
	if (bus_space_map(pa->pa_iot, iobase, iosize, 0, &sc->vr_bhandle)) {
		printf(": failed map i/o space\n");
		goto fail;
	}
	sc->vr_btag = pa->pa_iot;
d710 3
a712 2
	if (pci_mem_find(pc, pa->pa_tag, VR_PCI_LOMEM, &iobase, &iosize)) {
		printf(": failed to find memory space\n");
a714 5
	if (bus_space_map(pa->pa_memt, iobase, iosize, 0, &sc->vr_bhandle)) {
		printf(": failed map memory space\n");
		goto fail;
	}
	sc->vr_btag = pa->pa_memt;
d720 1
a720 1
		goto fail;
d730 1
a730 1
		goto fail;
d774 1
a774 1
		goto fail;
d781 1
a781 1
		goto fail;
d788 1
a788 1
		goto fail;
d796 1
a796 1
		goto fail;
d836 2
@


1.45
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.44 2004/09/23 17:45:16 brad Exp $	*/
a117 1
void vr_txeoc(struct vr_softc *);
d881 1
a881 2
	cd->vr_tx_free = &cd->vr_tx_chain[0];
	cd->vr_tx_tail = cd->vr_tx_head = NULL;
d965 1
a973 1
		struct mbuf		*m0 = NULL;
d982 1
a1128 7
	/* Reset the timeout timer; if_txeoc will clear it. */
	ifp->if_timer = 5;

	/* Sanity check. */
	if (sc->vr_cdata.vr_tx_head == NULL)
		return;

d1133 2
a1134 1
	while(sc->vr_cdata.vr_tx_head->vr_mbuf != NULL) {
a1137 1
		cur_tx = sc->vr_cdata.vr_tx_head;
a1172 4
		if (cur_tx->vr_mbuf != NULL) {
			m_freem(cur_tx->vr_mbuf);
			cur_tx->vr_mbuf = NULL;
		}
d1174 3
a1176 20
		if (sc->vr_cdata.vr_tx_head == sc->vr_cdata.vr_tx_tail) {
			sc->vr_cdata.vr_tx_head = NULL;
			sc->vr_cdata.vr_tx_tail = NULL;
			break;
		}

		sc->vr_cdata.vr_tx_head = cur_tx->vr_nextdesc;
	}

	return;
}

/*
 * TX 'end of channel' interrupt handler.
 */
void
vr_txeoc(sc)
	struct vr_softc		*sc;
{
	struct ifnet		*ifp;
d1178 1
a1178 6
	ifp = &sc->arpcom.ac_if;

	if (sc->vr_cdata.vr_tx_head == NULL) {
		ifp->if_flags &= ~IFF_OACTIVE;
		sc->vr_cdata.vr_tx_tail = NULL;
		ifp->if_timer = 0;
d1181 3
a1183 1
	return;
d1274 1
a1274 1
				if (sc->vr_cdata.vr_tx_head != NULL) {
d1280 1
a1280 2
			} else
				vr_txeoc(sc);
d1371 2
a1372 2
	struct mbuf		*m_head = NULL;
	struct vr_chain		*cur_tx = NULL, *start_tx, *prev_tx;
d1376 2
a1377 11
	/*
	 * Check for an available queue slot. If there are none,
	 * punt.
	 */
	if (sc->vr_cdata.vr_tx_free->vr_mbuf != NULL) {
		return;
	}

	start_tx = sc->vr_cdata.vr_tx_free;

	while(sc->vr_cdata.vr_tx_free->vr_mbuf == NULL) {
a1381 5
		/* Pick a descriptor off the free list. */
		prev_tx = cur_tx;
		cur_tx = sc->vr_cdata.vr_tx_free;
		sc->vr_cdata.vr_tx_free = cur_tx->vr_nextdesc;

a1389 2
			sc->vr_cdata.vr_tx_free = cur_tx;
			cur_tx = prev_tx;
d1393 1
a1393 2
		if (cur_tx != start_tx)
			VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
d1403 1
a1403 1
		VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
d1405 2
d1408 3
a1410 5
	/*
	 * If there are no frames queued, bail.
	 */
	if (cur_tx == NULL)
		return;
d1412 2
a1413 1
	sc->vr_cdata.vr_tx_tail = cur_tx;
d1415 2
a1416 2
	if (sc->vr_cdata.vr_tx_head == NULL)
		sc->vr_cdata.vr_tx_head = start_tx;
d1418 3
a1420 11
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	/* Tell the chip to start transmitting. */
	VR_SETBIT16(sc, VR_COMMAND, /*VR_CMD_TX_ON|*/VR_CMD_TX_GO);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
d1676 2
a1725 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.44
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.43 2004/06/06 17:56:36 mcbride Exp $	*/
d1675 2
a1676 1
			vr_setmulti(sc);
@


1.43
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.42 2004/04/14 04:48:56 deraadt Exp $	*/
a812 1
	ifp->if_mtu = ETHERMTU;
a814 1
	ifp->if_output = ether_output;
@


1.42
log
@new vr; loki@@animata.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.41 2003/12/29 23:06:55 brad Exp $	*/
a138 1
u_int8_t vr_calchash(u_int8_t *);
a492 29
 * Calculate CRC of a multicast group address, return the lower 6 bits.
 */
u_int8_t
vr_calchash(addr)
	u_int8_t		*addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return((crc >> 26) & 0x0000003F);
}

/*
d512 1
d528 5
a532 1
		h = vr_calchash(enm->enm_addrlo);
@


1.41
log
@no vtophys(), don't need uvm_extern.h anymore.

tested on alpha, i386, macppc and sparc64.

ok millert@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.40 2003/10/14 05:04:00 drahn Exp $	*/
d641 1
@


1.40
log
@Add htole and bus_dmamap_sync code. These allow if_vr to work on powerpc.
Code is a collaboration of jason@@ and myself. Ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.39 2003/10/13 04:25:30 jason Exp $	*/
a90 2

#include <uvm/uvm_extern.h>			/* for vtophys */
@


1.39
log
@last vtophys (tx data) is now dead.  Needs dma sync's and probably more
htole32 now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.38 2003/10/12 02:53:59 jason Exp $	*/
d953 3
d980 4
d1002 1
a1002 2
	while(!((rxstat = sc->vr_cdata.vr_rx_head->vr_ptr->vr_status) &
							VR_RXSTAT_OWN)) {
d1005 7
d1047 3
d1054 1
a1054 1
		total_len = VR_RXBYTES(cur_rx->vr_ptr->vr_status);
d1065 3
d1070 3
d1080 3
d1103 4
d1174 1
a1174 1
		txstat = cur_tx->vr_ptr->vr_status;
d1188 1
a1188 1
			VR_TXOWN(cur_tx) = VR_TXSTAT_OWN;
d1402 2
d1411 1
a1411 1
	f->vr_status = 0;
d1471 1
a1471 1
			VR_TXOWN(cur_tx) = VR_TXSTAT_OWN;
d1481 1
a1481 1
		VR_TXOWN(cur_tx) = VR_TXSTAT_OWN;
d1494 4
@


1.38
log
@only one vtophys left (tx data)... both the rx and tx descriptors are
fully handled by bus_dma now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.37 2003/10/12 02:35:53 jason Exp $	*/
d897 5
d913 1
a913 1
	return(0);
d1178 2
a1184 7
		if (cur_tx->vr_map != NULL) {
			if (cur_tx->vr_map->dm_nsegs > 0)
				bus_dmamap_unload(sc->sc_dmat, cur_tx->vr_map);
			bus_dmamap_destroy(sc->sc_dmat, cur_tx->vr_map);
			cur_tx->vr_map = NULL;
		}

a1336 1
	int			total_len;
a1340 1
	total_len = 0;
d1344 1
a1344 1
		return(1);
d1349 1
a1349 1
			return(1);
d1354 1
a1354 2
	m_freem(m_head);
	m_head = m_new;
d1360 1
a1360 1
	if (m_head->m_len < VR_MIN_FRAMELEN) {
d1362 2
a1363 2
		bzero(&m_new->m_data[m_head->m_len],
		    VR_MIN_FRAMELEN-m_head->m_len);
d1367 9
d1377 3
a1379 3
	f->vr_data = vtophys(mtod(m_new, caddr_t));
	f->vr_ctl = total_len = m_new->m_len;
	f->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;
d1382 2
a1383 2
	c->vr_mbuf = m_head;
	c->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG|VR_TXCTL_FINT;
d1386 1
a1386 1
	return(0);
d1519 1
a1519 1
							sc->sc_dev.dv_xname);
d1528 7
a1534 1
	vr_list_tx_init(sc);
@


1.37
log
@rework rx to use bus_dma and sprinkle with a small amount of htole32.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.36 2003/10/10 19:02:24 jason Exp $	*/
d894 3
d932 3
a934 1

d1103 1
a1103 1
	CSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));
d1155 1
a1155 1
			CSR_WRITE_4(sc, VR_TXADDR, vtophys(cur_tx->vr_ptr));
d1378 1
a1378 1
	c->vr_ptr->vr_next = vtophys(c->vr_nextdesc->vr_ptr);
d1544 1
a1544 1
	CSR_WRITE_4(sc, VR_RXADDR, vtophys(sc->vr_cdata.vr_rx_head->vr_ptr));
@


1.36
log
@unsmoke drugs in vr_encap() (simplify it quite alot)
prepare for bus_dma of tx data
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.35 2003/10/10 18:19:16 jason Exp $	*/
d116 1
a116 6
int vr_newbuf(struct vr_softc *,
				     struct vr_chain_onefrag *,
				     struct mbuf *);
int vr_encap(struct vr_softc *, struct vr_chain *,
				     struct mbuf * );

d921 1
d927 23
a949 4
		cd->vr_rx_chain[i].vr_ptr =
			(struct vr_desc *)&ld->vr_rx_list[i];
		if (vr_newbuf(sc, &cd->vr_rx_chain[i], NULL) == ENOBUFS)
			return(ENOBUFS);
a970 42
 * Initialize an RX descriptor and attach an MBUF cluster.
 * Note: the length fields are only 11 bits wide, which means the
 * largest size we can specify is 2047. This is important because
 * MCLBYTES is 2048, so we have to subtract one otherwise we'll
 * overflow the field and make a mess.
 */
int
vr_newbuf(sc, c, m)
	struct vr_softc		*sc;
	struct vr_chain_onefrag	*c;
	struct mbuf		*m;
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, sizeof(u_int64_t));

	c->vr_mbuf = m_new;
	c->vr_ptr->vr_status = VR_RXSTAT;
	c->vr_ptr->vr_data = vtophys(mtod(m_new, caddr_t));
	c->vr_ptr->vr_ctl = VR_RXCTL | VR_RXLEN;

	return(0);
}

/*
a977 1
	struct mbuf		*m;
a990 1
		m = cur_rx->vr_mbuf;
d1017 7
a1023 1
			vr_newbuf(sc, cur_rx, m);
d1039 1
a1039 1
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
d1041 8
a1048 1
		vr_newbuf(sc, cur_rx, m);
a1053 1
		m = m0;
d1062 1
a1062 1
			bpf_mtap(ifp->if_bpf, m);
d1065 1
a1065 1
		ether_input_mbuf(ifp, m);
d1698 3
a1700 2
	register int		i;
	struct ifnet		*ifp;
d1718 12
a1729 3
		if (sc->vr_cdata.vr_rx_chain[i].vr_mbuf != NULL) {
			m_freem(sc->vr_cdata.vr_rx_chain[i].vr_mbuf);
			sc->vr_cdata.vr_rx_chain[i].vr_mbuf = NULL;
@


1.35
log
@lightly season with a touch of htole32()... a pinch will do.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.34 2003/10/10 18:12:41 jason Exp $	*/
d1190 7
a1347 1
	int			frag = 0;
d1350 2
a1351 1
	struct mbuf		*m;
d1356 7
a1362 11
	/*
	 * The VIA Rhine wants packet buffers to be longword
	 * aligned, but very often our mbufs aren't. Rather than
	 * waste time trying to decide when to copy and when not
	 * to copy, just do it all the time.
	 */
	if (m != NULL) {
		struct mbuf		*m_new = NULL;

		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
a1364 30
		if (m_head->m_pkthdr.len > MHLEN) {
			MCLGET(m_new, M_DONTWAIT);
			if (!(m_new->m_flags & M_EXT)) {
				m_freem(m_new);
				return(1);
			}
		}
		m_copydata(m_head, 0, m_head->m_pkthdr.len,	
					mtod(m_new, caddr_t));
		m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
		m_freem(m_head);
		m_head = m_new;
		/*
		 * The Rhine chip doesn't auto-pad, so we have to make
		 * sure to pad short frames out to the minimum frame length
		 * ourselves.
		 */
		if (m_head->m_len < VR_MIN_FRAMELEN) {
			/* data field should be padded with octets of zero */
			bzero(&m_new->m_data[m_head->m_len],
			    VR_MIN_FRAMELEN-m_head->m_len);
			m_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;
			m_new->m_len = m_new->m_pkthdr.len;
		}
		f = c->vr_ptr;
		f->vr_data = vtophys(mtod(m_new, caddr_t));
		f->vr_ctl = total_len = m_new->m_len;
		f->vr_ctl |= VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG;
		f->vr_status = 0;
		frag = 1;
d1366 21
d1746 2
d1751 7
@


1.34
log
@another easy vtophys removal (tx descriptor setup)... 6 to go.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.33 2003/10/10 18:05:12 jason Exp $	*/
d939 2
a940 2
			    sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[0]);
d945 2
a946 2
			    sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[i + 1]);
@


1.33
log
@don't use vtophys on rx lists any more
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.32 2003/10/07 12:42:07 miod Exp $	*/
d1569 2
a1570 1
	CSR_WRITE_4(sc, VR_TXADDR, vtophys(&sc->vr_ldata->vr_tx_list[0]));
@


1.32
log
@Do not forget to initialise the version member of the softc, and bring
yet another set of reliability fixes from FreeBSD; PR #3461
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.31 2003/02/19 14:38:22 miod Exp $	*/
d90 2
a682 2
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
d813 1
a813 1
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d817 2
a818 2
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(struct vr_list_data),
	    &kva, BUS_DMA_NOWAIT)) {
d821 1
a821 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d825 1
a825 1
	    sizeof(struct vr_list_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
d828 1
a828 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d831 1
a831 1
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva,
d834 1
a834 1
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
d836 1
a836 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d937 1
a937 1
					&cd->vr_rx_chain[0];
d939 2
a940 1
					vtophys(&ld->vr_rx_list[0]);
d943 1
a943 1
					&cd->vr_rx_chain[i + 1];
d945 2
a946 1
					vtophys(&ld->vr_rx_list[i + 1]);
@


1.31
log
@Sync if_vr code with FreeBSD. This makes the driver much better when it comes
to trying to recover the hardware going nuts under the load.

Reported to work by various people including krw@@and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.30 2003/02/09 10:53:24 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.61 2003/02/01 01:27:05 silby Exp $
d726 1
d1412 1
a1412 1
	struct vr_chain		*cur_tx = NULL, *start_tx;
a1415 3
	if (ifp->if_flags & IFF_OACTIVE)
		return;

a1420 1
		ifp->if_flags |= IFF_OACTIVE;
d1432 1
d1438 1
a1442 1
				ifp->if_flags |= IFF_OACTIVE;
d1444 2
a1445 1
			cur_tx = NULL;
a1460 1
		VR_SETBIT16(sc, VR_COMMAND, /*VR_CMD_TX_ON|*/VR_CMD_TX_GO);
d1473 3
@


1.30
log
@Must set BCR0/BCR1 since they can override the RXCFG/TXCFG registers; from freebsd via openbsd pr 3086 (thom at press dot alt-f4 dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.29 2003/01/12 06:58:30 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.40 2001/02/06 10:11:48 phk Exp $
d100 1
d152 1
a152 1
		CSR_READ_1(sc, reg) | x)
d156 1
a156 1
		CSR_READ_1(sc, reg) & ~x)
d160 1
a160 1
		CSR_READ_2(sc, reg) | x)
d164 1
a164 1
		CSR_READ_2(sc, reg) & ~x)
d168 1
a168 1
		CSR_READ_4(sc, reg) | x)
d172 1
a172 1
		CSR_READ_4(sc, reg) & ~x)
d176 1
a176 1
		CSR_READ_1(sc, VR_MIICMD) | x)
d180 1
a180 1
		CSR_READ_1(sc, VR_MIICMD) & ~x)
d182 1
d229 1
d239 1
d283 1
a285 1
	ack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;
d326 28
d363 1
d409 27
d445 8
d470 8
d625 11
a635 2
	if (i == VR_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);
d692 1
a692 1
					VR_PCI_CAPID) & 0x000000FF;
d695 1
a695 1
					VR_PCI_PWRMGMTCTRL);
d785 9
d1026 17
a1042 27
			printf("%s: rx error: ", sc->sc_dev.dv_xname);
			switch(rxstat & 0x000000FF) {
			case VR_RXSTAT_CRCERR:
				printf("crc error\n");
				break;
			case VR_RXSTAT_FRAMEALIGNERR:
				printf("frame alignment error\n");
				break;
			case VR_RXSTAT_FIFOOFLOW:
				printf("FIFO overflow\n");
				break;
			case VR_RXSTAT_GIANT:
				printf("received giant packet\n");
				break;
			case VR_RXSTAT_RUNT:
				printf("received runt packet\n");
				break;
			case VR_RXSTAT_BUSERR:
				printf("system bus error\n");
				break;
			case VR_RXSTAT_BUFFERR:
				printf("rx buffer error\n");
				break;
			default:
				printf("unknown rx error\n");
				break;
			}
d1089 20
d1111 1
a1111 1
	VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);
d1133 2
a1134 2
	/* Clear the timeout timer. */
	ifp->if_timer = 0;
d1146 1
d1151 17
a1209 2
	ifp->if_timer = 0;

d1213 1
d1227 8
d1275 5
d1281 10
a1290 3
		    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW) ||
		    (status & VR_ISR_RX_DROPPED)) {
			vr_rxeof(sc);
d1294 4
a1297 3
		if (status & VR_ISR_TX_OK) {
			vr_txeof(sc);
			vr_txeoc(sc);
d1300 2
a1301 2
		if ((status & VR_ISR_TX_UNDERRUN)||(status & VR_ISR_TX_ABRT)){ 
			ifp->if_oerrors++;
d1303 12
a1314 9
			if (sc->vr_cdata.vr_tx_head != NULL) {
				VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON);
				VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_GO);
			}
		}

		if (status & VR_ISR_BUSERR) {
			vr_reset(sc);
			vr_init(sc);
a1479 2

	return;
d1505 4
d1510 1
a1510 1
	 * BCR0 and BCR1 can override the RXCFG and TXCFG registers,   
d1514 2
a1515 2
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_RXTHRESHSTORENFWD);
 
d1520 1
a1520 1
	VR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_STORENFWD);
@


1.29
log
@add support for via rhine III; Jonathon Fletcher, jonathon.fletcher at pobox dot com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.28 2003/01/12 06:55:04 jason Exp $	*/
d90 1
a90 1
#include <uvm/uvm_extern.h>              /* for vtophys */
d216 1
a216 1
                if (bits & i) {
d218 1
a218 1
                } else {
d220 1
a220 1
                }
a553 2

        return;
d908 2
a909 2
        struct mbuf		*m;
        struct ifnet		*ifp;
d1361 10
@


1.28
log
@pad tx buffer with zero's; John L. Scarfone, j0 at cox.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.27 2002/11/19 18:40:17 jason Exp $	*/
d562 1
@


1.27
log
@Add a simplistic table driven lookup routine and use it where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.26 2002/05/14 16:54:45 millert Exp $	*/
d1233 3
@


1.26
log
@Fixed ALTQ support.
Patch from ftp://ftp.csl.sony.co.jp/pub/kjc/altq-3.1.errata.txt (kjc)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.25 2002/04/03 08:44:08 deraadt Exp $	*/
d558 8
d574 2
a575 20
	struct pci_attach_args *pa = (struct pci_attach_args *)aux;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH) {
		switch (PCI_PRODUCT(pa->pa_id)) {
		case PCI_PRODUCT_VIATECH_RHINE:
		case PCI_PRODUCT_VIATECH_RHINEII:
		case PCI_PRODUCT_VIATECH_RHINEII_2:
			return (1);
		}
	}

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_DELTA &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_DELTA_RHINEII)
		return (1);

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ADDTRON &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ADDTRON_RHINEII)
		return (1);

	return (0);
@


1.25
log
@back out ALTQ diff which breaks it; see PR 2517
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.22 2002/02/15 20:45:31 nordin Exp $	*/
d1303 6
a1308 2
			IF_PREPEND(&ifp->if_snd, m_head);
			ifp->if_flags |= IFF_OACTIVE;
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.23 2002/03/12 09:51:20 kjc Exp $	*/
d1293 1
a1293 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1303 1
a1310 3

		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.23
log
@sync with KAME
ALTQify more drivers.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.22 2002/02/15 20:45:31 nordin Exp $	*/
d103 2
a104 2
int vr_probe			__P((struct device *, void *, void *));
void vr_attach			__P((struct device *, struct device *, void *));
d113 1
a113 1
int vr_newbuf			__P((struct vr_softc *,
d115 33
a147 33
				     struct mbuf *));
int vr_encap			__P((struct vr_softc *, struct vr_chain *,
				     struct mbuf * ));

void vr_rxeof			__P((struct vr_softc *));
void vr_rxeoc			__P((struct vr_softc *));
void vr_txeof			__P((struct vr_softc *));
void vr_txeoc			__P((struct vr_softc *));
void vr_tick			__P((void *));
int vr_intr			__P((void *));
void vr_start			__P((struct ifnet *));
int vr_ioctl			__P((struct ifnet *, u_long, caddr_t));
void vr_init			__P((void *));
void vr_stop			__P((struct vr_softc *));
void vr_watchdog		__P((struct ifnet *));
void vr_shutdown		__P((void *));
int vr_ifmedia_upd		__P((struct ifnet *));
void vr_ifmedia_sts		__P((struct ifnet *, struct ifmediareq *));

void vr_mii_sync		__P((struct vr_softc *));
void vr_mii_send		__P((struct vr_softc *, u_int32_t, int));
int vr_mii_readreg		__P((struct vr_softc *, struct vr_mii_frame *));
int vr_mii_writereg		__P((struct vr_softc *, struct vr_mii_frame *));
int vr_miibus_readreg		__P((struct device *, int, int));
void vr_miibus_writereg		__P((struct device *, int, int, int));
void vr_miibus_statchg		__P((struct device *));

void vr_setcfg			__P((struct vr_softc *, int));
u_int8_t vr_calchash		__P((u_int8_t *));
void vr_setmulti		__P((struct vr_softc *));
void vr_reset			__P((struct vr_softc *));
int vr_list_rx_init		__P((struct vr_softc *));
int vr_list_tx_init		__P((struct vr_softc *));
@


1.22
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.21 2001/11/06 19:53:19 miod Exp $	*/
d1293 1
a1293 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
a1302 1
			IF_PREPEND(&ifp->if_snd, m_head);
d1310 3
@


1.21
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.20 2001/08/25 10:13:29 art Exp $	*/
d1377 1
a1377 1
		(void)splx(s);
d1430 1
a1430 1
	(void)splx(s);
d1530 1
a1530 1
	(void)splx(s);
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.21 2001/11/06 19:53:19 miod Exp $	*/
d103 2
a104 2
int vr_probe(struct device *, void *, void *);
void vr_attach(struct device *, struct device *, void *);
d113 1
a113 1
int vr_newbuf(struct vr_softc *,
d115 33
a147 33
				     struct mbuf *);
int vr_encap(struct vr_softc *, struct vr_chain *,
				     struct mbuf * );

void vr_rxeof(struct vr_softc *);
void vr_rxeoc(struct vr_softc *);
void vr_txeof(struct vr_softc *);
void vr_txeoc(struct vr_softc *);
void vr_tick(void *);
int vr_intr(void *);
void vr_start(struct ifnet *);
int vr_ioctl(struct ifnet *, u_long, caddr_t);
void vr_init(void *);
void vr_stop(struct vr_softc *);
void vr_watchdog(struct ifnet *);
void vr_shutdown(void *);
int vr_ifmedia_upd(struct ifnet *);
void vr_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void vr_mii_sync(struct vr_softc *);
void vr_mii_send(struct vr_softc *, u_int32_t, int);
int vr_mii_readreg(struct vr_softc *, struct vr_mii_frame *);
int vr_mii_writereg(struct vr_softc *, struct vr_mii_frame *);
int vr_miibus_readreg(struct device *, int, int);
void vr_miibus_writereg(struct device *, int, int, int);
void vr_miibus_statchg(struct device *);

void vr_setcfg(struct vr_softc *, int);
u_int8_t vr_calchash(u_int8_t *);
void vr_setmulti(struct vr_softc *);
void vr_reset(struct vr_softc *);
int vr_list_rx_init(struct vr_softc *);
int vr_list_tx_init(struct vr_softc *);
d1303 2
a1304 6
			if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
				m_freem(m_head);
			} else {
				IF_PREPEND(&ifp->if_snd, m_head);
				ifp->if_flags |= IFF_OACTIVE;
			}
d1377 1
a1377 1
		splx(s);
d1430 1
a1430 1
	splx(s);
d1530 1
a1530 1
	splx(s);
@


1.21.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.61 2003/02/01 01:27:05 silby Exp $
d90 1
a90 1
#include <uvm/uvm_extern.h>			/* for vtophys */
a99 1
#undef VR_USESWSHIFT
d151 1
a151 1
		CSR_READ_1(sc, reg) | (x))
d155 1
a155 1
		CSR_READ_1(sc, reg) & ~(x))
d159 1
a159 1
		CSR_READ_2(sc, reg) | (x))
d163 1
a163 1
		CSR_READ_2(sc, reg) & ~(x))
d167 1
a167 1
		CSR_READ_4(sc, reg) | (x))
d171 1
a171 1
		CSR_READ_4(sc, reg) & ~(x))
d175 1
a175 1
		CSR_READ_1(sc, VR_MIICMD) | (x))
d179 1
a179 1
		CSR_READ_1(sc, VR_MIICMD) & ~(x))
a180 1
#ifdef VR_USESWSHIFT
d216 1
a216 1
		if (bits & i) {
d218 1
a218 1
		} else {
d220 1
a220 1
		}
a226 1
#endif
a235 1
#ifdef VR_USESWSHIFT
a278 1
	ack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;
d281 1
a321 28
#else  
{
	int			s, i;

	s = splimp();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_READ_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_READ_ENB) == 0)
			break;
		DELAY(1);
	}

	frame->mii_data = CSR_READ_2(sc, VR_MIIDATA);

	(void)splx(s);

	return(0);
}      
#endif         

a330 1
#ifdef VR_USESWSHIFT
a375 27
#else  
{      
	int			s, i;

	s = splimp();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address and data to write */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	CSR_WRITE_2(sc, VR_MIIDATA, frame->mii_data);

	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_WRITE_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_WRITE_ENB) == 0)
			break;
		DELAY(1); 
	}

	(void)splx(s);

	return(0);
}
#endif                 
a384 8
	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
		if (phy != 1)
			return 0;
	default:
		break;
	}

a401 8
	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
		if (phy != 1)
			return;
	default:
		break;
	}

d549 2
a550 11
	if (i == VR_TIMEOUT) {
		if (sc->vr_revid < REV_ID_VT3065_A)
			printf("%s: reset never completed!\n",
			    sc->sc_dev.dv_xname);
		else {
			/* Use newer force reset command */
			printf("%s: Using force reset command.\n",
			    sc->sc_dev.dv_xname);
			VR_SETBIT(sc, VR_MISC_CR1, VR_MISCCR1_FORSRST);
		}
	}       
d554 2
a557 9
const struct pci_matchid vr_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINE },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII_2 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105 },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_RHINEII },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_RHINEII },
};

d566 20
a585 2
	return (pci_matchbyid((struct pci_attach_args *)aux, vr_devices,
	    sizeof(vr_devices)/sizeof(vr_devices[0])));
d618 1
a618 1
	    VR_PCI_CAPID) & 0x000000ff;
d621 1
a621 1
		    VR_PCI_PWRMGMTCTRL);
a710 9
	 * Turn on bit2 (MIION) in PCI configuration register 0x53 during
	 * initialization and disable AUTOPOLL.
	 */
	pci_conf_write(pa->pa_pc, pa->pa_tag, VR_PCI_MODE,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, VR_PCI_MODE) |
	    (VR_MODE3_MIION << 24));
	VR_CLRBIT(sc, VR_MIICMD, VR_MIICMD_AUTOPOLL);

	/*
d919 2
a920 2
	struct mbuf		*m;
	struct ifnet		*ifp;
d943 27
a969 17
			printf("%s: rx error (%02x):",
			    sc->sc_dev.dv_xname, rxstat & 0x000000ff);
			if (rxstat & VR_RXSTAT_CRCERR)
				printf(" crc error");
			if (rxstat & VR_RXSTAT_FRAMEALIGNERR)
				printf(" frame alignment error");
			if (rxstat & VR_RXSTAT_FIFOOFLOW)
				printf(" FIFO overflow");
			if (rxstat & VR_RXSTAT_GIANT)
				printf(" received giant packet");
			if (rxstat & VR_RXSTAT_RUNT)
				printf(" received runt packet");
			if (rxstat & VR_RXSTAT_BUSERR)
				printf(" system bus error");
			if (rxstat & VR_RXSTAT_BUFFERR)
				printf(" rx buffer error");
			printf("\n");
a1015 20
	struct ifnet		*ifp;
	int			i;

	ifp = &sc->arpcom.ac_if;

	ifp->if_ierrors++;      

	VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);      
	DELAY(10000);  

	for (i = 0x400; 
	    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RX_ON);
	    i--)  
		;       /* Wait for receiver to stop */

	if (!i) {       
		printf("%s: rx shutdown error!\n", sc->sc_dev.dv_xname);
		sc->vr_flags |= VR_F_RESTART;
		return; 
	}
d1018 1
a1018 1

d1040 2
a1041 2
	/* Reset the timeout timer; if_txeoc will clear it. */
	ifp->if_timer = 5;
a1052 1
		int			i;
a1056 17
		if ((txstat & VR_TXSTAT_ABRT) ||
		    (txstat & VR_TXSTAT_UDF)) {
			for (i = 0x400;
			    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_TX_ON);
			    i--)
				;	/* Wait for chip to shutdown */
			if (!i) {
				printf("%s: tx shutdown timeout\n",
				    sc->sc_dev.dv_xname);
				sc->vr_flags |= VR_F_RESTART;
				break;
			}
			VR_TXOWN(cur_tx) = VR_TXSTAT_OWN;
			CSR_WRITE_4(sc, VR_TXADDR, vtophys(cur_tx->vr_ptr));
			break;
		}

d1099 2
a1103 1
		ifp->if_timer = 0;
a1116 8
	if (sc->vr_flags & VR_F_RESTART) {
		printf("%s: restarting\n", sc->sc_dev.dv_xname);
		vr_stop(sc);
		vr_reset(sc);   
		vr_init(sc);
		sc->vr_flags &= ~VR_F_RESTART;
	}           

a1156 5
		if (status & VR_ISR_RX_DROPPED) {
			printf("%s: rx packet lost\n", sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		}       

d1158 3
a1160 10
		    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW)) {
			printf("%s: receive error (%04x)",
			    sc->sc_dev.dv_xname, status);
			if (status & VR_ISR_RX_NOBUF)
				printf(" no buffers");
			if (status & VR_ISR_RX_OFLOW)
				printf(" overflow");
			if (status & VR_ISR_RX_DROPPED)
				printf(" packet lost");
			printf("\n");
d1164 3
a1166 4
		if ((status & VR_ISR_BUSERR) || (status & VR_ISR_TX_UNDERRUN)) {
			vr_reset(sc);
			vr_init(sc);
			break;
d1169 2
a1170 2
		if ((status & VR_ISR_TX_OK) || (status & VR_ISR_TX_ABRT) ||
		    (status & VR_ISR_TX_ABRT2) || (status & VR_ISR_UDFI)) {
d1172 9
a1180 12
			if ((status & VR_ISR_UDFI) ||
			    (status & VR_ISR_TX_ABRT2) ||
			    (status & VR_ISR_TX_ABRT)) {
				ifp->if_oerrors++;
				if (sc->vr_cdata.vr_tx_head != NULL) {
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_ON);
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_GO); 
				}
			} else
				vr_txeoc(sc);
a1242 3
			/* data field should be padded with octets of zero */
			bzero(&m_new->m_data[m_head->m_len],
			    VR_MIN_FRAMELEN-m_head->m_len);
d1343 2
a1369 14
	/* Set DMA size */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_DMA_LENGTH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_DMA_STORENFWD);

	/*
	 * BCR0 and BCR1 can override the RXCFG and TXCFG registers,
	 * so we must set both.
	 */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_RX_THRESH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_RXTHRESH128BYTES);

	VR_CLRBIT(sc, VR_BCR1, VR_BCR1_TX_THRESH);
	VR_SETBIT(sc, VR_BCR1, VR_BCR1_TXTHRESHSTORENFWD);

d1371 1
a1371 1
	VR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_128BYTES);
@


1.20
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.19 2001/08/12 20:03:49 mickey Exp $	*/
d90 1
a90 1
#include <vm/vm.h>              /* for vtophys */
@


1.19
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.18 2001/06/27 06:34:50 kjc Exp $	*/
d684 1
a684 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.18
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.17 2001/06/24 22:38:47 aaron Exp $	*/
a90 1
#include <vm/pmap.h>            /* for vtophys */
@


1.17
log
@Program the address filter in vr_init(). Apparently the rhine cards are smart
enough to read their own Ethernet address from the EEPROM and program their
unicast filters automatically, but to support setting the Ethernet address with
ifconfig on vr(4) cards we need to do this. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.16 2001/06/24 20:27:02 fgsch Exp $	*/
d769 1
d1189 1
a1189 1
	if (ifp->if_snd.ifq_head != NULL) {
d1295 1
a1295 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d1552 1
a1552 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.16
log
@more ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.15 2001/05/16 13:41:27 aaron Exp $	*/
d1351 1
a1351 1
	int			s;
d1360 6
@


1.15
log
@Bring chip out of suspend mode in case we're booting after a shutdown from
Windows. Needed for the VT6102, but doesn't hurt older chips; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.14 2001/03/25 06:34:51 csapuntz Exp $	*/
a919 1
        struct ether_header	*eh;
a997 1
		eh = mtod(m, struct ether_header *);
d1006 2
a1007 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.14
log
@Missing splx(s). Thanks to dawson and team for finding this one
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.13 2001/02/20 19:39:44 mickey Exp $	*/
d701 7
@


1.13
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.12 2001/02/20 19:12:47 jason Exp $	*/
d726 1
a726 1
		return;
d733 1
a733 1
		return;
d740 1
a740 1
		return;
d748 1
a748 1
		return;
@


1.12
log
@add mii support to if_vr (mostly from FreeBSD)
also sync with other FreeBSD changes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.11 2001/02/17 07:52:44 jason Exp $	*/
a786 4
#if NBPFILTER > 0
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
			sizeof(struct ether_header));
#endif
@


1.11
log
@no need for seperate variable to hold ethernet address... that's what
ac_enaddr is for
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.10 2001/02/17 07:35:36 jason Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.17 1999/09/17 18:25:30 wpaul Exp $
d93 3
a101 2
/* #define VR_BACKGROUND_AUTONEG */

a103 10
static struct vr_type vr_phys[] = {
	{ TI_PHY_VENDORID, TI_PHY_10BT, "<TI ThunderLAN 10BT (internal)>" },
	{ TI_PHY_VENDORID, TI_PHY_100VGPMI, "<TI TNETE211 100VG Any-LAN>" },
	{ NS_PHY_VENDORID, NS_PHY_83840A, "<National Semiconductor DP83840A>"},
	{ LEVEL1_PHY_VENDORID, LEVEL1_PHY_LXT970, "<Level 1 LXT970>" },
	{ INTEL_PHY_VENDORID, INTEL_PHY_82555, "<Intel 82555>" },
	{ SEEQ_PHY_VENDORID, SEEQ_PHY_80220, "<SEEQ 80220>" },
	{ 0, 0, "<MII-compliant physical interface>" }
};

d124 1
d137 7
a143 12
int vr_mii_readreg		__P((struct vr_softc *,
				     struct vr_mii_frame *));
int vr_mii_writereg		__P((struct vr_softc *,
				     struct vr_mii_frame *));
u_int16_t vr_phy_readreg	__P((struct vr_softc *, int));
void vr_phy_writereg		__P((struct vr_softc *, u_int16_t, u_int16_t));

void vr_autoneg_xmit		__P((struct vr_softc *));
void vr_autoneg_mii		__P((struct vr_softc *, int, int));
void vr_setmode_mii		__P((struct vr_softc *, int));
void vr_getmode_mii		__P((struct vr_softc *));
void vr_setcfg			__P((struct vr_softc *, u_int16_t));
d378 4
a381 4
u_int16_t
vr_phy_readreg(sc, reg)
	struct vr_softc		*sc;
	int			reg;
d383 2
a384 1
	struct vr_mii_frame	frame;
d388 1
a388 1
	frame.mii_phyaddr = sc->vr_phy_addr;
d396 3
a398 4
vr_phy_writereg(sc, reg, data)
	struct vr_softc		*sc;
	u_int16_t		reg;
	u_int16_t		data;
d400 2
a401 1
	struct vr_mii_frame	frame;
d405 1
a405 1
	frame.mii_phyaddr = sc->vr_phy_addr;
d414 9
a509 291
 * Initiate an autonegotiation session.
 */
void
vr_autoneg_xmit(sc)
	struct vr_softc		*sc;
{
	u_int16_t		phy_sts;

	vr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
	DELAY(500);
	while(vr_phy_readreg(sc, PHY_BMCR)
			& PHY_BMCR_RESET);

	phy_sts = vr_phy_readreg(sc, PHY_BMCR);
	phy_sts |= PHY_BMCR_AUTONEGENBL|PHY_BMCR_AUTONEGRSTR;
	vr_phy_writereg(sc, PHY_BMCR, phy_sts);

	return;
}

/*
 * Invoke autonegotiation on a PHY.
 */
void
vr_autoneg_mii(sc, flag, verbose)
	struct vr_softc		*sc;
	int			flag;
	int			verbose;
{
	u_int16_t		phy_sts = 0, media, advert, ability;
	struct ifnet		*ifp;
	struct ifmedia		*ifm;

	ifm = &sc->ifmedia;
	ifp = &sc->arpcom.ac_if;

	ifm->ifm_media = IFM_ETHER | IFM_AUTO;

	/*
	 * The 100baseT4 PHY on the 3c905-T4 has the 'autoneg supported'
	 * bit cleared in the status register, but has the 'autoneg enabled'
	 * bit set in the control register. This is a contradiction, and
	 * I'm not sure how to handle it. If you want to force an attempt
	 * to autoneg for 100baseT4 PHYs, #define FORCE_AUTONEG_TFOUR
	 * and see what happens.
	 */
#ifndef FORCE_AUTONEG_TFOUR
	/*
	 * First, see if autoneg is supported. If not, there's
	 * no point in continuing.
	 */
	phy_sts = vr_phy_readreg(sc, PHY_BMSR);
	if (!(phy_sts & PHY_BMSR_CANAUTONEG)) {
		if (verbose)
			printf("%s: autonegotiation not supported\n",
							sc->sc_dev.dv_xname);
		ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;	
		return;
	}
#endif

	switch (flag) {
	case VR_FLAG_FORCEDELAY:
		/*
	 	 * XXX Never use this option anywhere but in the probe
	 	 * routine: making the kernel stop dead in its tracks
 		 * for three whole seconds after we've gone multi-user
		 * is really bad manners.
	 	 */
		vr_autoneg_xmit(sc);
		DELAY(5000000);
		break;
	case VR_FLAG_SCHEDDELAY:
		/*
		 * Wait for the transmitter to go idle before starting
		 * an autoneg session, otherwise vr_start() may clobber
	 	 * our timeout, and we don't want to allow transmission
		 * during an autoneg session since that can screw it up.
	 	 */
		if (sc->vr_cdata.vr_tx_head != NULL) {
			sc->vr_want_auto = 1;
			return;
		}
		vr_autoneg_xmit(sc);
		ifp->if_timer = 5;
		sc->vr_autoneg = 1;
		sc->vr_want_auto = 0;
		return;
		break;
	case VR_FLAG_DELAYTIMEO:
		ifp->if_timer = 0;
		sc->vr_autoneg = 0;
		break;
	default:
		printf("%s: invalid autoneg flag: %d\n",
						sc->sc_dev.dv_xname, flag);
		return;
	}

	if (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_AUTONEGCOMP) {
		if (verbose)
			printf("%s: autoneg complete, ", sc->sc_dev.dv_xname);
		phy_sts = vr_phy_readreg(sc, PHY_BMSR);
	} else {
		if (verbose)
			printf("%s: autoneg not complete, ",
						sc->sc_dev.dv_xname);
	}

	media = vr_phy_readreg(sc, PHY_BMCR);

	/* Link is good. Report modes and set duplex mode. */
	if (vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT) {
		if (verbose)
			printf("link status good ");
		advert = vr_phy_readreg(sc, PHY_ANAR);
		ability = vr_phy_readreg(sc, PHY_LPAR);

		if (advert & PHY_ANAR_100BT4 && ability & PHY_ANAR_100BT4) {
			ifm->ifm_media = IFM_ETHER|IFM_100_T4;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(100baseT4)\n");
		} else if (advert & PHY_ANAR_100BTXFULL &&
			ability & PHY_ANAR_100BTXFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
			media |= PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_100BTXHALF &&
			ability & PHY_ANAR_100BTXHALF) {
			ifm->ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
			media |= PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 100Mbps)\n");
		} else if (advert & PHY_ANAR_10BTFULL &&
			ability & PHY_ANAR_10BTFULL) {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media |= PHY_BMCR_DUPLEX;
			printf("(full-duplex, 10Mbps)\n");
		} else {
			ifm->ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;
			media &= ~PHY_BMCR_SPEEDSEL;
			media &= ~PHY_BMCR_DUPLEX;
			printf("(half-duplex, 10Mbps)\n");
		}

		media &= ~PHY_BMCR_AUTONEGENBL;

		/* Set ASIC's duplex mode to match the PHY. */
		vr_setcfg(sc, media);
		vr_phy_writereg(sc, PHY_BMCR, media);
	} else {
		if (verbose)
			printf("no carrier\n");
	}

	vr_init(sc);

	if (sc->vr_tx_pend) {
		sc->vr_autoneg = 0;
		sc->vr_tx_pend = 0;
		vr_start(ifp);
	}

	return;
}

void
vr_getmode_mii(sc)
	struct vr_softc		*sc;
{
	u_int16_t		bmsr;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	bmsr = vr_phy_readreg(sc, PHY_BMSR);

	/* fallback */
	sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_HDX;

	if (bmsr & PHY_BMSR_10BTHALF) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_HDX, 0, NULL);
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	}

	if (bmsr & PHY_BMSR_10BTFULL) {
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_10_T|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_10_T|IFM_FDX;
	}

	if (bmsr & PHY_BMSR_100BTXHALF) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_TX, 0, NULL);
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_HDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_HDX;
	}

	if (bmsr & PHY_BMSR_100BTXFULL) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia,
			IFM_ETHER|IFM_100_TX|IFM_FDX, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	}

	/* Some also support 100BaseT4. */
	if (bmsr & PHY_BMSR_100BT4) {
		ifp->if_baudrate = 100000000;
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_100_T4, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_100_T4;
#ifdef FORCE_AUTONEG_TFOUR
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0 NULL):
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
#endif
	}

	if (bmsr & PHY_BMSR_CANAUTONEG) {
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
		sc->ifmedia.ifm_media = IFM_ETHER|IFM_AUTO;
	}

	return;
}

/*
 * Set speed and duplex mode.
 */
void
vr_setmode_mii(sc, media)
	struct vr_softc		*sc;
	int			media;
{
	u_int16_t		bmcr;
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	/*
	 * If an autoneg session is in progress, stop it.
	 */
	if (sc->vr_autoneg) {
		printf("%s: canceling autoneg session\n", sc->sc_dev.dv_xname);
		ifp->if_timer = sc->vr_autoneg = sc->vr_want_auto = 0;
		bmcr = vr_phy_readreg(sc, PHY_BMCR);
		bmcr &= ~PHY_BMCR_AUTONEGENBL;
		vr_phy_writereg(sc, PHY_BMCR, bmcr);
	}

	printf("%s: selecting MII, ", sc->sc_dev.dv_xname);

	bmcr = vr_phy_readreg(sc, PHY_BMCR);

	bmcr &= ~(PHY_BMCR_AUTONEGENBL|PHY_BMCR_SPEEDSEL|
			PHY_BMCR_DUPLEX|PHY_BMCR_LOOPBK);

	if (IFM_SUBTYPE(media) == IFM_100_T4) {
		printf("100Mbps/T4, half-duplex\n");
		bmcr |= PHY_BMCR_SPEEDSEL;
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	if (IFM_SUBTYPE(media) == IFM_100_TX) {
		printf("100Mbps, ");
		bmcr |= PHY_BMCR_SPEEDSEL;
	}

	if (IFM_SUBTYPE(media) == IFM_10_T) {
		printf("10Mbps, ");
		bmcr &= ~PHY_BMCR_SPEEDSEL;
	}

	if ((media & IFM_GMASK) == IFM_FDX) {
		printf("full duplex\n");
		bmcr |= PHY_BMCR_DUPLEX;
	} else {
		printf("half duplex\n");
		bmcr &= ~PHY_BMCR_DUPLEX;
	}

	vr_setcfg(sc, bmcr);
	vr_phy_writereg(sc, PHY_BMCR, bmcr);

	return;
}

/*
d515 3
a517 3
vr_setcfg(sc, bmcr)
	struct vr_softc		*sc;
	u_int16_t		bmcr;
d519 1
a519 1
	int			restart = 0;
d526 1
a526 1
	if (bmcr & PHY_BMCR_DUPLEX)
d608 4
a611 5
	int			media = IFM_ETHER|IFM_100_TX|IFM_FDX;
	unsigned int		round;
	caddr_t			roundptr;
	struct vr_type		*p;
	u_int16_t		phy_vid, phy_did, phy_sts;
d722 4
a725 4
	sc->vr_ldata_ptr = malloc(sizeof(struct vr_list_data) + 8,
				M_DEVBUF, M_NOWAIT);
	if (sc->vr_ldata_ptr == NULL) {
		printf("%s: no memory for list buffers\n", sc->sc_dev.dv_xname);
d728 21
a748 10

	sc->vr_ldata = (struct vr_list_data *)sc->vr_ldata_ptr;
	round = (unsigned int)sc->vr_ldata_ptr & 0xF;
	roundptr = sc->vr_ldata_ptr;
	for (i = 0; i < 8; i++) {
		if (round % 8) {
			round++;
			roundptr++;
		} else
			break;
d750 1
a750 1
	sc->vr_ldata = (struct vr_list_data *)roundptr;
a763 28
	for (i = VR_PHYADDR_MIN; i < VR_PHYADDR_MAX + 1; i++) {
		sc->vr_phy_addr = i;
		vr_phy_writereg(sc, PHY_BMCR, PHY_BMCR_RESET);
		DELAY(500);
		while(vr_phy_readreg(sc, PHY_BMCR)
				& PHY_BMCR_RESET);
		if ((phy_sts = vr_phy_readreg(sc, PHY_BMSR)))
			break;
	}
	if (phy_sts) {
		phy_vid = vr_phy_readreg(sc, PHY_VENID);
		phy_did = vr_phy_readreg(sc, PHY_DEVID);
		p = vr_phys;
		while(p->vr_vid) {
			if (phy_vid == p->vr_vid &&
				(phy_did | 0x000F) == p->vr_did) {
				sc->vr_pinfo = p;
				break;
			}
			p++;
		}
		if (sc->vr_pinfo == NULL)
			sc->vr_pinfo = &vr_phys[PHY_UNKNOWN];
	} else {
		printf("%s: MII without any phy!\n", sc->sc_dev.dv_xname);
		goto fail;
	}

d765 1
a765 1
	 * Do ifmedia setup.
d767 13
a779 8
	ifmedia_init(&sc->ifmedia, 0, vr_ifmedia_upd, vr_ifmedia_sts);

	vr_getmode_mii(sc);
	vr_autoneg_mii(sc, VR_FLAG_FORCEDELAY, 1);
	vr_stop(sc);
	media = sc->ifmedia.ifm_media;

	ifmedia_set(&sc->ifmedia, media);
a1037 1
	register struct mbuf	*n;
d1072 4
a1075 2
        	MFREE(cur_tx->vr_mbuf, n);
		cur_tx->vr_mbuf = NULL;
a1104 2
		if (sc->vr_want_auto)
			vr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);
d1110 13
d1279 1
a1279 2
	if (sc->vr_autoneg) {
		sc->vr_tx_pend = 1;
a1280 1
	}
d1322 1
a1322 1
		VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);
d1350 1
a1350 1
	u_int16_t		phy_bmcr = 0;
a1352 3
	if (sc->vr_autoneg)
		return;

a1354 3
	if (sc->vr_pinfo != NULL)
		phy_bmcr = vr_phy_readreg(sc, PHY_BMCR);

a1407 2
	vr_setcfg(sc, vr_phy_readreg(sc, PHY_BMCR));

d1417 1
a1417 2
	if (sc->vr_pinfo != NULL)
		vr_phy_writereg(sc, PHY_BMCR, phy_bmcr);
d1422 3
a1425 2

	return;
d1435 1
a1435 5
	struct vr_softc		*sc;
	struct ifmedia		*ifm;

	sc = ifp->if_softc;
	ifm = &sc->ifmedia;
d1437 2
a1438 7
	if (IFM_TYPE(ifm->ifm_media) != IFM_ETHER)
		return(EINVAL);

	if (IFM_SUBTYPE(ifm->ifm_media) == IFM_AUTO)
		vr_autoneg_mii(sc, VR_FLAG_SCHEDDELAY, 1);
	else
		vr_setmode_mii(sc, ifm->ifm_media);
d1451 2
a1452 4
	struct vr_softc		*sc;
	u_int16_t		advert = 0, ability = 0;

	sc = ifp->if_softc;
d1454 3
a1456 34
	ifmr->ifm_active = IFM_ETHER;

	if (!(vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_AUTONEGENBL)) {
		if (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_SPEEDSEL)
			ifmr->ifm_active = IFM_ETHER|IFM_100_TX;
		else
			ifmr->ifm_active = IFM_ETHER|IFM_10_T;
		if (vr_phy_readreg(sc, PHY_BMCR) & PHY_BMCR_DUPLEX)
			ifmr->ifm_active |= IFM_FDX;
		else
			ifmr->ifm_active |= IFM_HDX;
		return;
	}

	ability = vr_phy_readreg(sc, PHY_LPAR);
	advert = vr_phy_readreg(sc, PHY_ANAR);
	if (advert & PHY_ANAR_100BT4 &&
		ability & PHY_ANAR_100BT4) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_T4;
	} else if (advert & PHY_ANAR_100BTXFULL &&
		ability & PHY_ANAR_100BTXFULL) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_FDX;
	} else if (advert & PHY_ANAR_100BTXHALF &&
		ability & PHY_ANAR_100BTXHALF) {
		ifmr->ifm_active = IFM_ETHER|IFM_100_TX|IFM_HDX;
	} else if (advert & PHY_ANAR_10BTFULL &&
		ability & PHY_ANAR_10BTFULL) {
		ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_FDX;
	} else if (advert & PHY_ANAR_10BTHALF &&
		ability & PHY_ANAR_10BTHALF) {
		ifmr->ifm_active = IFM_ETHER|IFM_10_T|IFM_HDX;
	}

	return;
d1518 1
a1518 1
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, command);
a1537 7
	if (sc->vr_autoneg) {
		vr_autoneg_mii(sc, VR_FLAG_DELAYTIMEO, 1);
		if (!(ifp->if_flags & IFF_UP))
			vr_stop(sc);
		return;
	}

a1540 4
	if (!(vr_phy_readreg(sc, PHY_BMSR) & PHY_BMSR_LINKSTAT))
		printf("%s: no carrier - transceiver cable problem?\n",
							sc->sc_dev.dv_xname);

d1564 3
@


1.10
log
@sync with freebsd up to switch to mii
also increase the delay for accessing the eeprom (seems it needs a bit
longer to get ether address settled).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.9 2001/02/09 04:08:11 aaron Exp $	*/
a892 1
	u_char			eaddr[ETHER_ADDR_LEN];
d1010 1
a1010 1
		eaddr[i] = CSR_READ_1(sc, VR_PAR0 + i);
a1014 1
	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
@


1.9
log
@Handle vr_encap() failure. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.8 2000/07/02 00:27:23 jason Exp $	*/
d34 1
a34 1
 *	$FreeBSD: if_vr.c,v 1.7 1999/01/10 18:51:49 wpaul Exp $
d124 2
a125 1
				     struct vr_chain_onefrag *));
d1009 1
a1009 1
	DELAY(200);
d1085 1
a1086 1
	vr_stop(sc);
d1156 1
a1156 1
		if (vr_newbuf(sc, &cd->vr_rx_chain[i]) == ENOBUFS)
d1184 1
a1184 1
vr_newbuf(sc, c)
d1187 1
d1191 15
a1205 8
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return(ENOBUFS);

	MCLGET(m_new, M_DONTWAIT);
	if (!(m_new->m_flags & M_EXT)) {
		m_freem(m_new);
		return(ENOBUFS);
d1208 2
d1237 2
d1241 1
d1278 1
a1278 2
			cur_rx->vr_ptr->vr_status = VR_RXSTAT;
			cur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;
a1282 1
		m = cur_rx->vr_mbuf;
d1294 4
a1297 8
		/*
		 * Try to conjure up a new mbuf cluster. If that
		 * fails, it means we have an out of memory condition and
		 * should leave the buffer in place and continue. This will
		 * result in a lost packet, but there's little else we
		 * can do in this situation.
		 */
		if (vr_newbuf(sc, cur_rx) == ENOBUFS) {
a1298 2
			cur_rx->vr_ptr->vr_status = VR_RXSTAT;
			cur_rx->vr_ptr->vr_ctl = VR_RXCTL|VR_RXLEN;
d1301 2
d1306 1
a1306 2
		m->m_pkthdr.rcvif = ifp;
		m->m_pkthdr.len = m->m_len = total_len;
d1889 2
@


1.8
log
@add via vt6102 id; freebsd-gnats
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.7 2000/02/15 02:28:15 jason Exp $	*/
d1595 6
a1600 1
		vr_encap(sc, cur_tx, m_head);
@


1.7
log
@make sure to call ether_{add,del}multi() as appropriate in xxx_ioctl()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.6 1999/09/13 22:32:31 niklas Exp $	*/
d866 1
@


1.6
log
@Remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.5 1999/08/05 23:03:47 jason Exp $	*/
d1839 12
a1850 2
		vr_setmulti(sc);
		error = 0;
@


1.6.4.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.7 2000/02/15 02:28:15 jason Exp $	*/
d1839 2
a1840 12
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			vr_setmulti(sc);
			error = 0;
		}
@


1.6.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.14 2001/03/25 06:34:51 csapuntz Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.40 2001/02/06 10:11:48 phk Exp $
a92 3
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

d99 2
d103 10
d124 1
a124 2
				     struct vr_chain_onefrag *,
				     struct mbuf *));
a131 1
void vr_tick			__P((void *));
d144 12
a155 7
int vr_mii_readreg		__P((struct vr_softc *, struct vr_mii_frame *));
int vr_mii_writereg		__P((struct vr_softc *, struct vr_mii_frame *));
int vr_miibus_readreg		__P((struct device *, int, int));
void vr_miibus_writereg		__P((struct device *, int, int, int));
void vr_miibus_statchg		__P((struct device *));

void vr_setcfg			__P((struct vr_softc *, int));
d390 4
a393 4
int
vr_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
d395 1
a395 2
	struct vr_softc *sc = (struct vr_softc *)dev;
	struct vr_mii_frame frame;
d399 1
a399 1
	frame.mii_phyaddr = phy;
d407 4
a410 3
vr_miibus_writereg(dev, phy, reg, data)
	struct device *dev;
	int phy, reg, data;
d412 1
a412 2
	struct vr_softc *sc = (struct vr_softc *)dev;
	struct vr_mii_frame frame;
d416 1
a416 1
	frame.mii_phyaddr = phy;
a424 9
void
vr_miibus_statchg(dev)
	struct device *dev;
{
	struct vr_softc *sc = (struct vr_softc *)dev;

	vr_setcfg(sc, sc->sc_mii.mii_media_active);
}

d512 291
d808 3
a810 3
vr_setcfg(sc, media)
	struct vr_softc *sc;
	int media;
d812 1
a812 1
	int restart = 0;
d819 1
a819 1
	if ((media & IFM_GMASK) == IFM_FDX)
a865 1
		case PCI_PRODUCT_VIATECH_RHINEII_2:
d891 1
d901 5
a905 4
	bus_dma_segment_t	seg;
	bus_dmamap_t		dmamap;
	int rseg;
	caddr_t kva;
d1007 1
a1007 1
	DELAY(1000);
d1009 1
a1009 1
		sc->arpcom.ac_enaddr[i] = CSR_READ_1(sc, VR_PAR0 + i);
d1014 1
d1017 5
a1021 5
	sc->sc_dmat = pa->pa_dmat;
	if (bus_dmamem_alloc(sc->sc_dmat, sizeof(struct vr_list_data),
	    PAGE_SIZE, 0, &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
		printf("%s: can't alloc list\n", sc->sc_dev.dv_xname);
		goto fail;
d1023 10
a1032 13
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, sizeof(struct vr_list_data),
	    &kva, BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sc_dev.dv_xname, sizeof(struct vr_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		goto fail;
	}
	if (bus_dmamap_create(sc->sc_dmat, sizeof(struct vr_list_data), 1,
	    sizeof(struct vr_list_data), 0, BUS_DMA_NOWAIT, &dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct vr_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		goto fail;
d1034 1
a1034 9
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva,
	    sizeof(struct vr_list_data), NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
		bus_dmamem_unmap(sc->sc_dmat, kva, sizeof(struct vr_list_data));
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
		goto fail;
	}
	sc->vr_ldata = (struct vr_list_data *)kva;
d1048 28
d1077 1
a1077 1
	 * Do MII setup.
d1079 8
a1086 13
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = vr_miibus_readreg;
	sc->sc_mii.mii_writereg = vr_miibus_writereg;
	sc->sc_mii.mii_statchg = vr_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, vr_ifmedia_upd, vr_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);
	timeout_set(&sc->sc_to, vr_tick, sc);
d1094 4
d1154 1
a1154 1
		if (vr_newbuf(sc, &cd->vr_rx_chain[i], NULL) == ENOBUFS)
d1182 1
a1182 1
vr_newbuf(sc, c, m)
a1184 1
	struct mbuf		*m;
d1188 8
a1195 15
	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL)
			return(ENOBUFS);

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
a1197 2
	m_adj(m_new, sizeof(u_int64_t));

a1224 2
		struct mbuf		*m0 = NULL;

a1226 1
		m = cur_rx->vr_mbuf;
d1263 2
a1264 1
			vr_newbuf(sc, cur_rx, m);
d1269 1
d1281 8
a1288 4
		m0 = m_devget(mtod(m, char *) - ETHER_ALIGN,
		    total_len + ETHER_ALIGN, 0, ifp, NULL);
		vr_newbuf(sc, cur_rx, m);
		if (m0 == NULL) {
d1290 2
a1293 2
		m_adj(m0, ETHER_ALIGN);
		m = m0;
d1297 2
a1298 1

d1339 1
d1374 2
a1375 4
		if (cur_tx->vr_mbuf != NULL) {
			m_freem(cur_tx->vr_mbuf);
			cur_tx->vr_mbuf = NULL;
		}
d1405 2
a1411 13
void
vr_tick(xsc)
	void *xsc;
{
	struct vr_softc *sc = xsc;
	int s;

	s = splimp();
	mii_tick(&sc->sc_mii);
	timeout_add(&sc->sc_to, hz);
	splx(s);
}

d1568 2
a1569 1
	if (ifp->if_flags & IFF_OACTIVE)
d1571 1
d1594 1
a1594 6
		if (vr_encap(sc, cur_tx, m_head)) {
			IF_PREPEND(&ifp->if_snd, m_head);
			ifp->if_flags |= IFF_OACTIVE;
			cur_tx = NULL;
			break;
		}
d1608 1
a1608 1
		VR_SETBIT16(sc, VR_COMMAND, /*VR_CMD_TX_ON|*/VR_CMD_TX_GO);
d1636 1
a1636 1
	struct mii_data		*mii = &sc->sc_mii;
d1639 3
d1644 3
d1700 2
d1711 2
a1712 1
	mii_mediachg(mii);
d1717 1
a1717 2
	if (!timeout_pending(&sc->sc_to))
		timeout_add(&sc->sc_to, hz);
d1719 1
a1719 1
	(void)splx(s);
d1729 8
a1736 1
	struct vr_softc		*sc = ifp->if_softc;
d1738 4
a1741 2
	if (ifp->if_flags & IFF_UP)
		vr_init(sc);
d1754 37
a1790 2
	struct vr_softc		*sc = ifp->if_softc;
	struct mii_data		*mii = &sc->sc_mii;
d1792 1
a1792 3
	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
d1854 1
a1854 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
d1874 5
d1882 4
a1908 3

	if (timeout_pending(&sc->sc_to))
		timeout_del(&sc->sc_to);
@


1.6.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.6.4.2 2001/05/14 22:25:48 niklas Exp $	*/
a701 7
	/*
	 * Windows may put the chip in suspend mode when it
	 * shuts down. Be sure to kick it in the head to wake it
	 * up again.
	 */
	VR_CLRBIT(sc, VR_STICKHW, (VR_STICKHW_DS0|VR_STICKHW_DS1));

a761 1
	IFQ_SET_READY(&ifp->if_snd);
d913 1
d992 1
d1001 3
a1003 2
		/* pass it on. */
		ether_input_mbuf(ifp, m);
d1184 1
a1184 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
d1290 1
a1290 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d1347 1
a1347 1
	int			s, i;
a1356 6
	/*
	 * Set our station address.
	 */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		CSR_WRITE_1(sc, VR_PAR0 + i, sc->arpcom.ac_enaddr[i]);

d1541 1
a1541 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
@


1.6.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.6.4.3 2001/07/04 10:42:29 niklas Exp $	*/
d91 1
d685 2
a686 1
	if (pci_intr_map(pa, &ih)) {
@


1.6.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#include <uvm/uvm_extern.h>              /* for vtophys */
@


1.6.4.6
log
@Merge in trunk
@
text
@d1377 1
a1377 1
		splx(s);
d1430 1
a1430 1
	splx(s);
d1530 1
a1530 1
	splx(s);
@


1.6.4.7
log
@Merge in -current from roughly a week ago
@
text
@d103 2
a104 2
int vr_probe(struct device *, void *, void *);
void vr_attach(struct device *, struct device *, void *);
d113 1
a113 1
int vr_newbuf(struct vr_softc *,
d115 33
a147 33
				     struct mbuf *);
int vr_encap(struct vr_softc *, struct vr_chain *,
				     struct mbuf * );

void vr_rxeof(struct vr_softc *);
void vr_rxeoc(struct vr_softc *);
void vr_txeof(struct vr_softc *);
void vr_txeoc(struct vr_softc *);
void vr_tick(void *);
int vr_intr(void *);
void vr_start(struct ifnet *);
int vr_ioctl(struct ifnet *, u_long, caddr_t);
void vr_init(void *);
void vr_stop(struct vr_softc *);
void vr_watchdog(struct ifnet *);
void vr_shutdown(void *);
int vr_ifmedia_upd(struct ifnet *);
void vr_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void vr_mii_sync(struct vr_softc *);
void vr_mii_send(struct vr_softc *, u_int32_t, int);
int vr_mii_readreg(struct vr_softc *, struct vr_mii_frame *);
int vr_mii_writereg(struct vr_softc *, struct vr_mii_frame *);
int vr_miibus_readreg(struct device *, int, int);
void vr_miibus_writereg(struct device *, int, int, int);
void vr_miibus_statchg(struct device *);

void vr_setcfg(struct vr_softc *, int);
u_int8_t vr_calchash(u_int8_t *);
void vr_setmulti(struct vr_softc *);
void vr_reset(struct vr_softc *);
int vr_list_rx_init(struct vr_softc *);
int vr_list_tx_init(struct vr_softc *);
d1293 1
a1293 1
		IFQ_POLL(&ifp->if_snd, m_head);
d1303 1
a1310 3

		/* now we are committed to transmit the packet */
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.6.4.8
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.61 2003/02/01 01:27:05 silby Exp $
d90 1
a90 1
#include <uvm/uvm_extern.h>			/* for vtophys */
a99 1
#undef VR_USESWSHIFT
d151 1
a151 1
		CSR_READ_1(sc, reg) | (x))
d155 1
a155 1
		CSR_READ_1(sc, reg) & ~(x))
d159 1
a159 1
		CSR_READ_2(sc, reg) | (x))
d163 1
a163 1
		CSR_READ_2(sc, reg) & ~(x))
d167 1
a167 1
		CSR_READ_4(sc, reg) | (x))
d171 1
a171 1
		CSR_READ_4(sc, reg) & ~(x))
d175 1
a175 1
		CSR_READ_1(sc, VR_MIICMD) | (x))
d179 1
a179 1
		CSR_READ_1(sc, VR_MIICMD) & ~(x))
a180 1
#ifdef VR_USESWSHIFT
d216 1
a216 1
		if (bits & i) {
d218 1
a218 1
		} else {
d220 1
a220 1
		}
a226 1
#endif
a235 1
#ifdef VR_USESWSHIFT
a278 1
	ack = CSR_READ_4(sc, VR_MIICMD) & VR_MIICMD_DATAOUT;
d281 1
a321 28
#else  
{
	int			s, i;

	s = splimp();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_READ_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_READ_ENB) == 0)
			break;
		DELAY(1);
	}

	frame->mii_data = CSR_READ_2(sc, VR_MIIDATA);

	(void)splx(s);

	return(0);
}      
#endif         

a330 1
#ifdef VR_USESWSHIFT
a375 27
#else  
{      
	int			s, i;

	s = splimp();

	/* Set the PHY-address */
	CSR_WRITE_1(sc, VR_PHYADDR, (CSR_READ_1(sc, VR_PHYADDR)& 0xe0)|
	    frame->mii_phyaddr);

	/* Set the register-address and data to write */
	CSR_WRITE_1(sc, VR_MIIADDR, frame->mii_regaddr);
	CSR_WRITE_2(sc, VR_MIIDATA, frame->mii_data);

	VR_SETBIT(sc, VR_MIICMD, VR_MIICMD_WRITE_ENB);

	for (i = 0; i < 10000; i++) {
		if ((CSR_READ_1(sc, VR_MIICMD) & VR_MIICMD_WRITE_ENB) == 0)
			break;
		DELAY(1); 
	}

	(void)splx(s);

	return(0);
}
#endif                 
a384 8
	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
		if (phy != 1)
			return 0;
	default:
		break;
	}

a401 8
	switch (sc->vr_revid) {
	case REV_ID_VT6102_APOLLO:
		if (phy != 1)
			return;
	default:
		break;
	}

d549 2
a550 11
	if (i == VR_TIMEOUT) {
		if (sc->vr_revid < REV_ID_VT3065_A)
			printf("%s: reset never completed!\n",
			    sc->sc_dev.dv_xname);
		else {
			/* Use newer force reset command */
			printf("%s: Using force reset command.\n",
			    sc->sc_dev.dv_xname);
			VR_SETBIT(sc, VR_MISC_CR1, VR_MISCCR1_FORSRST);
		}
	}       
d554 2
a557 9
const struct pci_matchid vr_devices[] = {
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINE },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_RHINEII_2 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105 },
	{ PCI_VENDOR_DELTA, PCI_PRODUCT_DELTA_RHINEII },
	{ PCI_VENDOR_ADDTRON, PCI_PRODUCT_ADDTRON_RHINEII },
};

d566 20
a585 2
	return (pci_matchbyid((struct pci_attach_args *)aux, vr_devices,
	    sizeof(vr_devices)/sizeof(vr_devices[0])));
d618 1
a618 1
	    VR_PCI_CAPID) & 0x000000ff;
d621 1
a621 1
		    VR_PCI_PWRMGMTCTRL);
a710 9
	 * Turn on bit2 (MIION) in PCI configuration register 0x53 during
	 * initialization and disable AUTOPOLL.
	 */
	pci_conf_write(pa->pa_pc, pa->pa_tag, VR_PCI_MODE,
	    pci_conf_read(pa->pa_pc, pa->pa_tag, VR_PCI_MODE) |
	    (VR_MODE3_MIION << 24));
	VR_CLRBIT(sc, VR_MIICMD, VR_MIICMD_AUTOPOLL);

	/*
d919 2
a920 2
	struct mbuf		*m;
	struct ifnet		*ifp;
d943 27
a969 17
			printf("%s: rx error (%02x):",
			    sc->sc_dev.dv_xname, rxstat & 0x000000ff);
			if (rxstat & VR_RXSTAT_CRCERR)
				printf(" crc error");
			if (rxstat & VR_RXSTAT_FRAMEALIGNERR)
				printf(" frame alignment error");
			if (rxstat & VR_RXSTAT_FIFOOFLOW)
				printf(" FIFO overflow");
			if (rxstat & VR_RXSTAT_GIANT)
				printf(" received giant packet");
			if (rxstat & VR_RXSTAT_RUNT)
				printf(" received runt packet");
			if (rxstat & VR_RXSTAT_BUSERR)
				printf(" system bus error");
			if (rxstat & VR_RXSTAT_BUFFERR)
				printf(" rx buffer error");
			printf("\n");
a1015 20
	struct ifnet		*ifp;
	int			i;

	ifp = &sc->arpcom.ac_if;

	ifp->if_ierrors++;      

	VR_CLRBIT16(sc, VR_COMMAND, VR_CMD_RX_ON);      
	DELAY(10000);  

	for (i = 0x400; 
	    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_RX_ON);
	    i--)  
		;       /* Wait for receiver to stop */

	if (!i) {       
		printf("%s: rx shutdown error!\n", sc->sc_dev.dv_xname);
		sc->vr_flags |= VR_F_RESTART;
		return; 
	}
d1018 1
a1018 1

d1040 2
a1041 2
	/* Reset the timeout timer; if_txeoc will clear it. */
	ifp->if_timer = 5;
a1052 1
		int			i;
a1056 17
		if ((txstat & VR_TXSTAT_ABRT) ||
		    (txstat & VR_TXSTAT_UDF)) {
			for (i = 0x400;
			    i && (CSR_READ_2(sc, VR_COMMAND) & VR_CMD_TX_ON);
			    i--)
				;	/* Wait for chip to shutdown */
			if (!i) {
				printf("%s: tx shutdown timeout\n",
				    sc->sc_dev.dv_xname);
				sc->vr_flags |= VR_F_RESTART;
				break;
			}
			VR_TXOWN(cur_tx) = VR_TXSTAT_OWN;
			CSR_WRITE_4(sc, VR_TXADDR, vtophys(cur_tx->vr_ptr));
			break;
		}

d1099 2
a1103 1
		ifp->if_timer = 0;
a1116 8
	if (sc->vr_flags & VR_F_RESTART) {
		printf("%s: restarting\n", sc->sc_dev.dv_xname);
		vr_stop(sc);
		vr_reset(sc);   
		vr_init(sc);
		sc->vr_flags &= ~VR_F_RESTART;
	}           

a1156 5
		if (status & VR_ISR_RX_DROPPED) {
			printf("%s: rx packet lost\n", sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
		}       

d1158 3
a1160 10
		    (status & VR_ISR_RX_NOBUF) || (status & VR_ISR_RX_OFLOW)) {
			printf("%s: receive error (%04x)",
			    sc->sc_dev.dv_xname, status);
			if (status & VR_ISR_RX_NOBUF)
				printf(" no buffers");
			if (status & VR_ISR_RX_OFLOW)
				printf(" overflow");
			if (status & VR_ISR_RX_DROPPED)
				printf(" packet lost");
			printf("\n");
d1164 3
a1166 4
		if ((status & VR_ISR_BUSERR) || (status & VR_ISR_TX_UNDERRUN)) {
			vr_reset(sc);
			vr_init(sc);
			break;
d1169 2
a1170 2
		if ((status & VR_ISR_TX_OK) || (status & VR_ISR_TX_ABRT) ||
		    (status & VR_ISR_TX_ABRT2) || (status & VR_ISR_UDFI)) {
d1172 9
a1180 12
			if ((status & VR_ISR_UDFI) ||
			    (status & VR_ISR_TX_ABRT2) ||
			    (status & VR_ISR_TX_ABRT)) {
				ifp->if_oerrors++;
				if (sc->vr_cdata.vr_tx_head != NULL) {
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_ON);
					VR_SETBIT16(sc, VR_COMMAND,
					    VR_CMD_TX_GO); 
				}
			} else
				vr_txeoc(sc);
a1242 3
			/* data field should be padded with octets of zero */
			bzero(&m_new->m_data[m_head->m_len],
			    VR_MIN_FRAMELEN-m_head->m_len);
d1293 1
a1293 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
d1303 1
a1303 6
			if (ALTQ_IS_ENABLED(&ifp->if_snd)) {
				m_freem(m_head);
			} else {
				IF_PREPEND(&ifp->if_snd, m_head);
				ifp->if_flags |= IFF_OACTIVE;
			}
d1311 3
d1341 2
a1367 14
	/* Set DMA size */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_DMA_LENGTH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_DMA_STORENFWD);

	/*
	 * BCR0 and BCR1 can override the RXCFG and TXCFG registers,
	 * so we must set both.
	 */
	VR_CLRBIT(sc, VR_BCR0, VR_BCR0_RX_THRESH);
	VR_SETBIT(sc, VR_BCR0, VR_BCR0_RXTHRESH128BYTES);

	VR_CLRBIT(sc, VR_BCR1, VR_BCR1_TX_THRESH);
	VR_SETBIT(sc, VR_BCR1, VR_BCR1_TXTHRESHSTORENFWD);

d1369 1
a1369 1
	VR_SETBIT(sc, VR_RXCFG, VR_RXTHRESH_128BYTES);
@


1.6.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d34 1
a34 1
 * $FreeBSD: src/sys/pci/if_vr.c,v 1.73 2003/08/22 07:13:22 imp Exp $
d90 1
a90 1
#include <machine/bus.h>
d114 6
a119 1
int vr_encap(struct vr_softc *, struct vr_chain *, struct mbuf *);
d681 2
a725 1
	sc->vr_revid = PCI_REVISION(pa->pa_class);
d812 1
a812 1
	    PAGE_SIZE, 0, &sc->sc_listseg, 1, &rseg, BUS_DMA_NOWAIT)) {
d816 2
a817 2
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_listseg, rseg,
	    sizeof(struct vr_list_data), &kva, BUS_DMA_NOWAIT)) {
d820 1
a820 1
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
d824 1
a824 1
	    sizeof(struct vr_list_data), 0, BUS_DMA_NOWAIT, &sc->sc_listmap)) {
d827 1
a827 1
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
d830 1
a830 1
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_listmap, kva,
d833 1
a833 1
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_listmap);
d835 1
a835 1
		bus_dmamem_free(sc->sc_dmat, &sc->sc_listseg, rseg);
a897 8
		cd->vr_tx_chain[i].vr_paddr =
		    sc->sc_listmap->dm_segs[0].ds_addr +
		    offsetof(struct vr_list_data, vr_tx_list[i]);

		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, BUS_DMA_NOWAIT, &cd->vr_tx_chain[i].vr_map))
			return (ENOBUFS);

d909 1
a909 1
	return (0);
a924 1
	struct vr_desc		*d;
d930 4
a933 28
		d = (struct vr_desc *)&ld->vr_rx_list[i];
		cd->vr_rx_chain[i].vr_ptr = d;
		cd->vr_rx_chain[i].vr_paddr =
		    sc->sc_listmap->dm_segs[0].ds_addr +
		    offsetof(struct vr_list_data, vr_rx_list[i]);
		cd->vr_rx_chain[i].vr_buf =
		    (u_int8_t *)malloc(MCLBYTES, M_DEVBUF, M_NOWAIT);
		if (cd->vr_rx_chain[i].vr_buf == NULL)
			return (ENOBUFS);

		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 
		    0, BUS_DMA_NOWAIT | BUS_DMA_READ,
		    &cd->vr_rx_chain[i].vr_map))
			return (ENOBUFS);

		if (bus_dmamap_load(sc->sc_dmat, cd->vr_rx_chain[i].vr_map,
		    cd->vr_rx_chain[i].vr_buf, MCLBYTES, NULL, BUS_DMA_NOWAIT))
			return (ENOBUFS);
		bus_dmamap_sync(sc->sc_dmat, cd->vr_rx_chain[i].vr_map,
		    0, cd->vr_rx_chain[i].vr_map->dm_mapsize,
		    BUS_DMASYNC_PREREAD);

		d->vr_status = htole32(VR_RXSTAT);
		d->vr_data =
		    htole32(cd->vr_rx_chain[i].vr_map->dm_segs[0].ds_addr +
		    sizeof(u_int64_t));
		d->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);

d936 1
a936 1
			    &cd->vr_rx_chain[0];
d938 1
a938 2
			    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[0]));
d941 1
a941 1
			    &cd->vr_rx_chain[i + 1];
d943 1
a943 2
			    htole32(sc->sc_listmap->dm_segs[0].ds_addr +
			    offsetof(struct vr_list_data, vr_rx_list[i + 1]));
d949 41
a989 3
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
d1002 1
d1010 2
a1011 1
	for (;;) {
a1013 7
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
		    0, sc->sc_listmap->dm_mapsize,
		    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
		rxstat = letoh32(sc->vr_cdata.vr_rx_head->vr_ptr->vr_status);
		if (rxstat & VR_RXSTAT_OWN)
			break;

d1016 1
d1043 1
a1043 10

			/* Reinitialize descriptor */
			cur_rx->vr_ptr->vr_status = htole32(VR_RXSTAT);
			cur_rx->vr_ptr->vr_data =
			    htole32(cur_rx->vr_map->dm_segs[0].ds_addr +
			    sizeof(u_int64_t));
			cur_rx->vr_ptr->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);
			bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
			    0, sc->sc_listmap->dm_mapsize,
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
d1048 1
a1048 1
		total_len = VR_RXBYTES(letoh32(cur_rx->vr_ptr->vr_status));
d1059 1
a1059 4
		bus_dmamap_sync(sc->sc_dmat, cur_rx->vr_map, 0,
		    cur_rx->vr_map->dm_mapsize,
		    BUS_DMASYNC_POSTREAD);
		m0 = m_devget(cur_rx->vr_buf + sizeof(u_int64_t) - ETHER_ALIGN,
d1061 1
a1061 14
		bus_dmamap_sync(sc->sc_dmat, cur_rx->vr_map, 0,
		    cur_rx->vr_map->dm_mapsize,
		    BUS_DMASYNC_PREREAD);

		/* Reinitialize descriptor */
		cur_rx->vr_ptr->vr_status = htole32(VR_RXSTAT);
		cur_rx->vr_ptr->vr_data =
		    htole32(cur_rx->vr_map->dm_segs[0].ds_addr +
		    sizeof(u_int64_t));
		cur_rx->vr_ptr->vr_ctl = htole32(VR_RXCTL | VR_RXLEN);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
		    sc->sc_listmap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

d1067 1
d1076 1
a1076 1
			bpf_mtap(ifp->if_bpf, m0);
d1079 1
a1079 1
		ether_input_mbuf(ifp, m0);
a1081 4
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap,
	    0, sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);

d1112 1
a1112 1
	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_head->vr_paddr);
d1149 1
a1149 1
		txstat = letoh32(cur_tx->vr_ptr->vr_status);
d1163 2
a1164 2
			VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
			CSR_WRITE_4(sc, VR_TXADDR, cur_tx->vr_paddr);
a1181 2
		if (cur_tx->vr_map != NULL && cur_tx->vr_map->dm_segs > 0)
			bus_dmamap_unload(sc->sc_dmat, cur_tx->vr_map);
d1338 1
d1340 2
a1341 2
	struct mbuf		*m = m_head;
	struct mbuf		*m_new = NULL;
d1344 1
d1346 19
a1364 8
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL)
		return (1);
	if (m_head->m_pkthdr.len > MHLEN) {
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			return (1);
d1366 28
a1393 3
	}
	m_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));
	m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;
d1395 1
a1395 34
	/*
	 * The Rhine chip doesn't auto-pad, so we have to make
	 * sure to pad short frames out to the minimum frame length
	 * ourselves.
	 */
	if (m_new->m_len < VR_MIN_FRAMELEN) {
		/* data field should be padded with octets of zero */
		bzero(&m_new->m_data[m_new->m_len],
		    VR_MIN_FRAMELEN-m_new->m_len);
		m_new->m_pkthdr.len += VR_MIN_FRAMELEN - m_new->m_len;
		m_new->m_len = m_new->m_pkthdr.len;
	}

	if (bus_dmamap_load_mbuf(sc->sc_dmat, c->vr_map, m_new,
	    BUS_DMA_NOWAIT | BUS_DMA_WRITE)) {
		m_freem(m_new);
		return (1);
	}
	bus_dmamap_sync(sc->sc_dmat, c->vr_map, 0, c->vr_map->dm_mapsize,
	    BUS_DMASYNC_PREWRITE);

	m_freem(m_head);

	f = c->vr_ptr;
	f->vr_data = htole32(c->vr_map->dm_segs[0].ds_addr);
	f->vr_ctl = htole32(c->vr_map->dm_mapsize);
	f->vr_ctl |= htole32(VR_TXCTL_TLINK|VR_TXCTL_FIRSTFRAG);
	f->vr_status = htole32(0);

	c->vr_mbuf = m_new;
	c->vr_ptr->vr_ctl |= htole32(VR_TXCTL_LASTFRAG|VR_TXCTL_FINT);
	c->vr_ptr->vr_next = htole32(c->vr_nextdesc->vr_paddr);

	return (0);
d1411 1
a1411 1
	struct vr_chain		*cur_tx = NULL, *start_tx, *prev_tx;
d1415 3
d1423 1
a1434 1
		prev_tx = cur_tx;
a1439 1
			/* Rollback, send what we were able to encap. */
d1444 1
d1446 1
a1446 2
			sc->vr_cdata.vr_tx_free = cur_tx;
			cur_tx = prev_tx;
d1451 1
a1451 1
			VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
d1461 2
a1462 1
		VR_TXOWN(cur_tx) = htole32(VR_TXSTAT_OWN);
a1475 7
	bus_dmamap_sync(sc->sc_dmat, sc->sc_listmap, 0,
	    sc->sc_listmap->dm_mapsize,
	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);

	/* Tell the chip to start transmitting. */
	VR_SETBIT16(sc, VR_COMMAND, /*VR_CMD_TX_ON|*/VR_CMD_TX_GO);

d1528 1
a1528 1
		    sc->sc_dev.dv_xname);
d1537 1
a1537 7
	if (vr_list_tx_init(sc) == ENOBUFS) {
		printf("%s: initialization failed: no memory for tx buffers\n",
		    sc->sc_dev.dv_xname);
		vr_stop(sc);
		splx(s);
		return;
	}
d1559 1
a1559 1
	CSR_WRITE_4(sc, VR_RXADDR, sc->vr_cdata.vr_rx_head->vr_paddr);
d1566 1
a1566 2
	CSR_WRITE_4(sc, VR_TXADDR, sc->sc_listmap->dm_segs[0].ds_addr +
	    offsetof(struct vr_list_data, vr_tx_list[0]));
d1717 2
a1718 3
	int		i;
	struct ifnet	*ifp;
	bus_dmamap_t	map;
d1736 3
a1738 12

		if (sc->vr_cdata.vr_rx_chain[i].vr_buf != NULL) {
			free(sc->vr_cdata.vr_rx_chain[i].vr_buf, M_DEVBUF);
			sc->vr_cdata.vr_rx_chain[i].vr_buf = NULL;
		}

		map = sc->vr_cdata.vr_rx_chain[i].vr_map;
		if (map != NULL) {
			if (map->dm_segs > 0)
				bus_dmamap_unload(sc->sc_dmat, map);
			bus_dmamap_destroy(sc->sc_dmat, map);
			sc->vr_cdata.vr_rx_chain[i].vr_map = NULL;
a1747 2
		bus_dmamap_t map;

a1750 7
		}
		map = sc->vr_cdata.vr_tx_chain[i].vr_map;
		if (map != NULL) {
			if (map->dm_nsegs > 0)
				bus_dmamap_unload(sc->sc_dmat, map);
			bus_dmamap_destroy(sc->sc_dmat, map);
			sc->vr_cdata.vr_tx_chain[i].vr_map = NULL;
@


1.6.4.10
log
@Merge with the trunk
@
text
@a640 1
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT6105M },
@


1.6.4.11
log
@sync to head
@
text
@d139 1
d494 29
a541 1
allmulti:
d557 1
a557 5
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
@


1.5
log
@remove some debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.4 1999/02/26 17:05:55 jason Exp $	*/
d123 38
a160 36
static int vr_newbuf		__P((struct vr_softc *,
						struct vr_chain_onefrag *));
static int vr_encap		__P((struct vr_softc *, struct vr_chain *,
						struct mbuf * ));

static void vr_rxeof		__P((struct vr_softc *));
static void vr_rxeoc		__P((struct vr_softc *));
static void vr_txeof		__P((struct vr_softc *));
static void vr_txeoc		__P((struct vr_softc *));
static int vr_intr		__P((void *));
static void vr_start		__P((struct ifnet *));
static int vr_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void vr_init		__P((void *));
static void vr_stop		__P((struct vr_softc *));
static void vr_watchdog		__P((struct ifnet *));
static void vr_shutdown		__P((void *));
static int vr_ifmedia_upd	__P((struct ifnet *));
static void vr_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

static void vr_mii_sync		__P((struct vr_softc *));
static void vr_mii_send		__P((struct vr_softc *, u_int32_t, int));
static int vr_mii_readreg	__P((struct vr_softc *, struct vr_mii_frame *));
static int vr_mii_writereg	__P((struct vr_softc *, struct vr_mii_frame *));
static u_int16_t vr_phy_readreg	__P((struct vr_softc *, int));
static void vr_phy_writereg	__P((struct vr_softc *, u_int16_t, u_int16_t));

static void vr_autoneg_xmit	__P((struct vr_softc *));
static void vr_autoneg_mii	__P((struct vr_softc *, int, int));
static void vr_setmode_mii	__P((struct vr_softc *, int));
static void vr_getmode_mii	__P((struct vr_softc *));
static void vr_setcfg		__P((struct vr_softc *, u_int16_t));
static u_int8_t vr_calchash	__P((u_int8_t *));
static void vr_setmulti		__P((struct vr_softc *));
static void vr_reset		__P((struct vr_softc *));
static int vr_list_rx_init	__P((struct vr_softc *));
static int vr_list_tx_init	__P((struct vr_softc *));
d197 2
a198 1
static void vr_mii_sync(sc)
d218 2
a219 1
static void vr_mii_send(sc, bits, cnt)
d244 2
a245 1
static int vr_mii_readreg(sc, frame)
d339 2
a340 1
static int vr_mii_writereg(sc, frame)
d390 2
a391 1
static u_int16_t vr_phy_readreg(sc, reg)
d406 2
a407 1
static void vr_phy_writereg(sc, reg, data)
d428 2
a429 1
static u_int8_t vr_calchash(addr)
d457 2
a458 1
static void vr_setmulti(sc)
d514 2
a515 1
static void vr_autoneg_xmit(sc)
d535 2
a536 1
static void vr_autoneg_mii(sc, flag, verbose)
d681 2
a682 1
static void vr_getmode_mii(sc)
d744 2
a745 1
static void vr_setmode_mii(sc, media)
d807 2
a808 1
static void vr_setcfg(sc, bmcr)
d830 2
a831 1
static void vr_reset(sc)
d1108 2
a1109 1
static int vr_list_tx_init(sc)
d1140 2
a1141 1
static int vr_list_rx_init(sc)
d1181 2
a1182 1
static int vr_newbuf(sc, c)
d1210 2
a1211 1
static void vr_rxeof(sc)
d1314 2
a1315 1
void vr_rxeoc(sc)
d1333 2
a1334 1
static void vr_txeof(sc)
d1392 2
a1393 1
static void vr_txeoc(sc)
d1412 2
a1413 1
static int vr_intr(arg)
d1488 2
a1489 1
static int vr_encap(sc, c, m_head)
d1558 2
a1559 1
static void vr_start(ifp)
d1630 2
a1631 1
static void vr_init(xsc)
d1725 2
a1726 1
static int vr_ifmedia_upd(ifp)
d1749 2
a1750 1
static void vr_ifmedia_sts(ifp, ifmr)
d1795 2
a1796 1
static int vr_ioctl(ifp, command, data)
d1856 2
a1857 1
static void vr_watchdog(ifp)
d1890 2
a1891 1
static void vr_stop(sc)
d1940 2
a1941 1
static void vr_shutdown(arg)
@


1.4
log
@compensate for the fact that the check for ownership of a unicast packet
has moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.3 1999/02/24 00:20:09 deraadt Exp $	*/
a95 1
#define bootverbose 0
a677 2
	if (bootverbose)
		printf("%s: PHY status word: %x\n", sc->sc_dev.dv_xname, bmsr);
a682 3
		if (bootverbose)
			printf("%s: 10Mbps half-duplex mode supported\n",
							sc->sc_dev.dv_xname);
a688 3
		if (bootverbose)
			printf("%s: 10Mbps full-duplex mode supported\n",
							sc->sc_dev.dv_xname);
a694 3
		if (bootverbose)
			printf("%s: 100Mbps half-duplex mode supported\n",
							sc->sc_dev.dv_xname);
a702 3
		if (bootverbose)
			printf("%s: 100Mbps full-duplex mode supported\n",
							sc->sc_dev.dv_xname);
a710 3
		if (bootverbose)
			printf("%s: 100baseT4 mode supported\n",
							sc->sc_dev.dv_xname);
a714 3
		if (bootverbose)
			printf("%s: forcing on autoneg support for BT4\n",
							sc->sc_dev.dv_xname);
a720 2
		if (bootverbose)
			printf("%s: autoneg supported\n", sc->sc_dev.dv_xname);
a1031 2
	if (bootverbose)
		printf("%s: probing for a PHY\n", sc->sc_dev.dv_xname);
a1032 3
		if (bootverbose)
			printf("%s: checking address: %d\n",
						sc->sc_dev.dv_xname, i);
a1043 6
		if (bootverbose) {
			printf("%s: found PHY at address %d, ",
					sc->sc_dev.dv_xname, sc->vr_phy_addr);
			printf("vendor id: %x device id: %x\n",
				phy_vid, phy_did);
		}
a1054 3
		if (bootverbose)
			printf("%s: PHY type: %s\n",
				sc->sc_dev.dv_xname, sc->vr_pinfo->vr_name);
@


1.3
log
@why do new manufacturers make identical products, but change the vendor field?
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.2 1999/01/30 23:15:37 niklas Exp $	*/
d1318 1
a1318 4
		 * Handle BPF listeners. Let the BPF user see the packet, but
		 * don't pass it up to the ether_input() layer unless it's
		 * a broadcast packet, multicast packet, matches our ethernet
		 * address or the interface is in promiscuous mode.
d1320 1
a1320 1
		if (ifp->if_bpf) {
a1321 8
			if (ifp->if_flags & IFF_PROMISC &&
				(bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
						ETHER_ADDR_LEN) &&
					(eh->ether_dhost[0] & 1) == 0)) {
				m_freem(m);
				continue;
			}
		}
@


1.2
log
@update to latest freebsd code, fixes stalls during heavy traffic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_vr.c,v 1.1 1999/01/10 22:30:45 downsj Exp $	*/
d876 9
@


1.1
log
@VIA Rhine driver, ported from FreeBSD; written by wpaul@@ctr.columbia.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d34 1
a34 1
 *	$FreeBSD: if_vr.c,v 1.6 1999/01/03 02:05:21 wpaul Exp $
d1210 1
a1210 1
	c->vr_ptr->vr_ctl = VR_RXCTL_CHAIN | (MCLBYTES - 1);
d1272 1
a1272 2
			cur_rx->vr_ptr->vr_ctl =
			VR_RXCTL_CHAIN | (MCLBYTES - 1);
d1299 1
a1299 2
			cur_rx->vr_ptr->vr_ctl =
			VR_RXCTL_CHAIN | (MCLBYTES - 1);
d1377 1
a1377 1
		if ((txstat & VR_TXSTAT_OWN) || txstat == VR_UNSENT)
a1422 6
	} else {
		if (VR_TXOWN(sc->vr_cdata.vr_tx_head) == VR_UNSENT) {
			VR_TXOWN(sc->vr_cdata.vr_tx_head) = VR_TXSTAT_OWN;
			ifp->if_timer = 5;
			VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);
		}
d1559 1
a1559 1
	c->vr_ptr->vr_ctl |= VR_TXCTL_LASTFRAG;
d1620 2
a1629 8
	/*
	 * Place the request for the upload interrupt
	 * in the last descriptor in the chain. This way, if
	 * we're chaining several packets at once, we'll only
	 * get an interupt once for the whole chain rather than
	 * once for each packet.
	 */
	cur_tx->vr_ptr->vr_ctl |= VR_TXCTL_FINT;
d1632 1
a1632 1
	if (sc->vr_cdata.vr_tx_head == NULL) {
a1633 5
		VR_TXOWN(start_tx) = VR_TXSTAT_OWN;
		VR_SETBIT16(sc, VR_COMMAND, VR_CMD_TX_ON|VR_CMD_TX_GO);
	} else {
		VR_TXOWN(start_tx) = VR_UNSENT;
	}
@

