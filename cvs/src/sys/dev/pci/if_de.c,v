head	1.137;
access;
symbols
	OPENBSD_6_1:1.137.0.4
	OPENBSD_6_1_BASE:1.137
	OPENBSD_6_0:1.135.0.4
	OPENBSD_6_0_BASE:1.135
	OPENBSD_5_9:1.134.0.2
	OPENBSD_5_9_BASE:1.134
	OPENBSD_5_8:1.123.0.4
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.117.0.4
	OPENBSD_5_7_BASE:1.117
	OPENBSD_5_6:1.115.0.4
	OPENBSD_5_6_BASE:1.115
	OPENBSD_5_5:1.112.0.4
	OPENBSD_5_5_BASE:1.112
	OPENBSD_5_4:1.110.0.2
	OPENBSD_5_4_BASE:1.110
	OPENBSD_5_3:1.109.0.8
	OPENBSD_5_3_BASE:1.109
	OPENBSD_5_2:1.109.0.6
	OPENBSD_5_2_BASE:1.109
	OPENBSD_5_1_BASE:1.109
	OPENBSD_5_1:1.109.0.4
	OPENBSD_5_0:1.109.0.2
	OPENBSD_5_0_BASE:1.109
	OPENBSD_4_9:1.106.0.2
	OPENBSD_4_9_BASE:1.106
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.102.0.4
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.99.0.4
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.99.0.2
	OPENBSD_4_3_BASE:1.99
	OPENBSD_4_2:1.97.0.4
	OPENBSD_4_2_BASE:1.97
	OPENBSD_4_1:1.97.0.2
	OPENBSD_4_1_BASE:1.97
	OPENBSD_4_0:1.96.0.2
	OPENBSD_4_0_BASE:1.96
	OPENBSD_3_9:1.87.0.2
	OPENBSD_3_9_BASE:1.87
	OPENBSD_3_8:1.75.0.2
	OPENBSD_3_8_BASE:1.75
	OPENBSD_3_7:1.63.0.2
	OPENBSD_3_7_BASE:1.63
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	SMP_SYNC_A:1.60
	SMP_SYNC_B:1.60
	OPENBSD_3_5:1.58.0.4
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.58.0.2
	OPENBSD_3_4_BASE:1.58
	UBC_SYNC_A:1.57
	OPENBSD_3_3:1.56.0.4
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.56.0.2
	OPENBSD_3_2_BASE:1.56
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	UBC_SYNC_B:1.56
	UBC:1.52.0.2
	UBC_BASE:1.52
	OPENBSD_3_0:1.51.0.2
	OPENBSD_3_0_BASE:1.51
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_8:1.43.0.4
	OPENBSD_2_8_BASE:1.43
	OPENBSD_2_7:1.43.0.2
	OPENBSD_2_7_BASE:1.43
	SMP:1.41.0.4
	SMP_BASE:1.41
	kame_19991208:1.41
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.40.0.2
	OPENBSD_2_5_BASE:1.40
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.29.0.2
	OPENBSD_2_3_BASE:1.29
	OPENBSD_2_2:1.24.0.2
	OPENBSD_2_2_BASE:1.24
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.137
date	2017.03.08.12.02.41;	author mpi;	state Exp;
branches;
next	1.136;
commitid	okVP7pbbXG8IxGgU;

1.136
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.135;
commitid	VyLWTsbepAOk7VQM;

1.135
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.134;
commitid	8YSL8ByWzGeIGBiJ;

1.134
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.133;
commitid	J9apD0jq2AjFmqZc;

1.133
date	2015.12.08.06.12.56;	author dlg;	state Exp;
branches;
next	1.132;
commitid	Bdbkyy2hNaMGNhTt;

1.132
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.131;
commitid	f4dx5ry1aOiKJw33;

1.131
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.130;
commitid	B0kwmVGiD5DVx4kv;

1.130
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.129;
commitid	5gdEnqVoJuTuwdTu;

1.129
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.128;
commitid	5DvsamK0GblTp8ww;

1.128
date	2015.11.23.23.34.42;	author dlg;	state Exp;
branches;
next	1.127;
commitid	l2ezscijc8CX7Jz4;

1.127
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.126;
commitid	eYnPulzvLjDImPCa;

1.126
date	2015.11.04.00.10.50;	author dlg;	state Exp;
branches;
next	1.125;
commitid	uH36xriNjDBY3Uur;

1.125
date	2015.11.04.00.09.59;	author dlg;	state Exp;
branches;
next	1.124;
commitid	SQdQ8n5H8XjU4sVS;

1.124
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.123;
commitid	hPF95ClMUQfeqQDX;

1.123
date	2015.06.26.11.50.39;	author kettenis;	state Exp;
branches;
next	1.122;
commitid	ZHSeOBG3WVHwrk21;

1.122
date	2015.06.25.18.35.48;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	16OmVJruFc3qS99o;

1.121
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.120;
commitid	MVWrtktB46JRxFWT;

1.120
date	2015.05.15.11.36.30;	author mpi;	state Exp;
branches;
next	1.119;
commitid	c8Ar0NXQW26UbBN3;

1.119
date	2015.04.01.13.35.32;	author mpi;	state Exp;
branches;
next	1.118;
commitid	K1boEOiei7EEsXg0;

1.118
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.117;
commitid	p4LJxGKbi0BU2cG6;

1.117
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.116;
commitid	yM2VFFhpDTeFQlve;

1.116
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.115;
commitid	ZqXwxwmeo3l29NOg;

1.115
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.114;
commitid	TGHgrLxu6sxZoiFt;

1.114
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.113;

1.113
date	2014.04.19.12.25.03;	author henning;	state Exp;
branches;
next	1.112;

1.112
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2013.08.07.01.06.34;	author bluhm;	state Exp;
branches;
next	1.110;

1.110
date	2013.06.04.19.10.52;	author miod;	state Exp;
branches;
next	1.109;

1.109
date	2011.07.07.20.42.56;	author henning;	state Exp;
branches;
next	1.108;

1.108
date	2011.07.06.02.42.27;	author henning;	state Exp;
branches;
next	1.107;

1.107
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.20.07.40.38;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.02.23.11.56;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.13.14.24.47;	author jasper;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.19.14.13.41;	author naddy;	state Exp;
branches;
next	1.101;

1.101
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2008.03.04.19.43.18;	author miod;	state Exp;
branches;
next	1.98;

1.98
date	2007.09.19.02.32.57;	author brad;	state Exp;
branches;
next	1.97;

1.97
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.96;

1.96
date	2006.07.08.04.15.36;	author brad;	state Exp;
branches;
next	1.95;

1.95
date	2006.07.08.03.58.09;	author brad;	state Exp;
branches;
next	1.94;

1.94
date	2006.07.08.03.10.22;	author brad;	state Exp;
branches;
next	1.93;

1.93
date	2006.07.08.02.54.43;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.01.09.45.48;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2006.05.28.00.04.24;	author jason;	state Exp;
branches;
next	1.90;

1.90
date	2006.05.09.20.58.56;	author brad;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.06.02.57.30;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.87;

1.87
date	2005.11.07.00.03.16;	author brad;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2005.10.01.13.58.10;	author martin;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.01.13.49.50;	author martin;	state Exp;
branches;
next	1.84;

1.84
date	2005.09.25.18.13.16;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2005.09.25.17.45.15;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2005.09.25.02.23.39;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.25.00.22.59;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.08.01.29.19;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.08.00.59.49;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.07.13.32.14;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.06.16.03.40;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2005.09.06.00.41.41;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2005.08.09.04.10.11;	author mickey;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2005.07.16.17.20.47;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2005.06.26.01.38.39;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2005.06.20.22.44.39;	author martin;	state Exp;
branches;
next	1.71;

1.71
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.25.22.14.16;	author martin;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.25.07.48.30;	author martin;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.23.20.54.32;	author martin;	state Exp;
branches;
next	1.67;

1.67
date	2005.05.22.19.29.55;	author martin;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.23.01.45.55;	author martin;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.16.16.08.07;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2005.03.29.00.37.50;	author martin;	state Exp;
branches;
next	1.63;

1.63
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2004.11.08.21.16.47;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.31.04.21.12;	author mcbride;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.06.18.54.20;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.30.16.00.30;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.02.22.50.00;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2002.04.01.18.41.47;	author nate;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.27.06.34.47;	author kjc;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.12.15.40.31;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.05.20.56.58;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.03.06.10.17;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2000.04.27.01.23.29;	author chris;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.27.00.06.41;	author chris;	state Exp;
branches;
next	1.41;

1.41
date	99.07.18.03.20.18;	author csapuntz;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	99.02.26.17.05.51;	author jason;	state Exp;
branches;
next	1.39;

1.39
date	99.02.04.22.33.32;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	99.01.11.04.31.13;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	98.12.02.07.34.59;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	98.10.28.23.40.42;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	98.10.08.05.51.18;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	98.09.09.04.05.36;	author rahnds;	state Exp;
branches;
next	1.33;

1.33
date	98.08.28.06.31.23;	author rahnds;	state Exp;
branches;
next	1.32;

1.32
date	98.08.07.16.48.16;	author pefo;	state Exp;
branches;
next	1.31;

1.31
date	98.05.28.20.25.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.05.22.21.37.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.02.22.21.26.57;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	98.01.07.11.03.26;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.01.05.13.35.19;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.11.16.07.46.46;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	97.11.13.21.14.15;	author rees;	state Exp;
branches;
next	1.24;

1.24
date	97.10.20.20.56.12;	author pefo;	state Exp;
branches;
next	1.23;

1.23
date	97.07.29.19.31.45;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.07.28.19.28.37;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.06.24.16.41.55;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	97.06.20.07.17.25;	author grr;	state Exp;
branches;
next	1.19;

1.19
date	97.06.18.19.07.06;	author dm;	state Exp;
branches;
next	1.18;

1.18
date	97.04.10.16.51.35;	author pefo;	state Exp;
branches;
next	1.17;

1.17
date	97.04.10.16.33.05;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	96.12.19.12.49.53;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	96.11.28.23.28.04;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.11.12.20.30.51;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.08.23.16.24.50;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.08.21.22.27.52;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.10.07.34.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.26.00.27.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.41.24;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.38.29;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.05.13.38.58;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.25.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.23.47.56;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.03.05.02.31.15;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.36.15;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.01.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.39;	author deraadt;	state Exp;
branches;
next	;

1.41.4.1
date	2001.05.14.22.25.44;	author niklas;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2001.07.04.10.42.10;	author niklas;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.41.4.4;

1.41.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.41.4.5;

1.41.4.5
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.41.4.6;

1.41.4.6
date	2003.03.28.00.38.21;	author niklas;	state Exp;
branches;
next	1.41.4.7;

1.41.4.7
date	2003.05.13.19.35.05;	author ho;	state Exp;
branches;
next	1.41.4.8;

1.41.4.8
date	2004.02.19.10.56.26;	author niklas;	state Exp;
branches;
next	1.41.4.9;

1.41.4.9
date	2004.06.05.23.12.49;	author niklas;	state Exp;
branches;
next	;

1.52.2.1
date	2002.06.11.03.42.25;	author art;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.10.29.00.33.28;	author art;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2003.05.19.22.18.00;	author tedu;	state Exp;
branches;
next	;

1.75.2.1
date	2006.05.09.21.08.53;	author brad;	state Exp;
branches;
next	;

1.87.2.1
date	2006.05.09.22.21.30;	author brad;	state Exp;
branches;
next	;


desc
@@


1.137
log
@Do not clear IFF_UP, even in the error path, clearing IFF_RUNNING
is enough.

This flag should only be set by the stack, drivers shouldn't mess
with it.

Discussed with dlg@@ and mikeb@@, ok mikeb@@, stsp@@
@
text
@/*	$OpenBSD: if_de.c,v 1.136 2017/01/22 10:17:38 dlg Exp $	*/
/*	$NetBSD: if_de.c,v 1.58 1998/01/12 09:39:58 thorpej Exp $	*/

/*-
 * Copyright (c) 1994-1997 Matt Thomas (matt@@3am-software.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: if_de.c,v 1.89 1997/06/03 19:19:55 thomas Exp
 *
 */

/*
 * DEC 21040 PCI Ethernet Controller
 *
 * Written by Matt Thomas
 * BPF support code stolen directly from if_ec.c
 *
 *   This driver supports the DEC DE435 or any other PCI
 *   board which support 21040, 21041, or 21140 (mostly).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/pool.h>

#include <net/if.h>
#include <net/if_media.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/ic/dc21040reg.h>

/*
 * Intel CPUs should use I/O mapped access.
 */
#if defined(__i386__)
#define	TULIP_IOMAPPED
#endif

#define	TULIP_HZ	10

#define TULIP_SIAGEN_WATCHDOG	0

#define TULIP_GPR_CMDBITS	(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)

#define EMIT	do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
#define MII_EMIT	do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)

#define tulip_mchash(mca)	(ether_crc32_le(mca, 6) & 0x1FF)
#define tulip_srom_crcok(databuf)	( \
    ((ether_crc32_le(databuf, 126) & 0xFFFFU) ^ 0xFFFFU) == \
     ((databuf)[126] | ((databuf)[127] << 8)))

/*
 * This is the PCI configuration support.  Since the 21040 is available
 * on both EISA and PCI boards, one must be careful in how defines the
 * 21040 in the config file.
 */

#define PCI_CFID	0x00	/* Configuration ID */
#define PCI_CFCS	0x04	/* Configurtion Command/Status */
#define PCI_CFRV	0x08	/* Configuration Revision */
#define PCI_CFLT	0x0c	/* Configuration Latency Timer */
#define PCI_CBIO	0x10	/* Configuration Base IO Address */
#define PCI_CBMA	0x14	/* Configuration Base Memory Address */
#define PCI_CFIT	0x3c	/* Configuration Interrupt */
#define PCI_CFDA	0x40	/* Configuration Driver Area */

#define PCI_CONF_WRITE(r, v)	pci_conf_write(pa->pa_pc, pa->pa_tag, (r), (v))
#define PCI_CONF_READ(r)	pci_conf_read(pa->pa_pc, pa->pa_tag, (r))
#define PCI_GETBUSDEVINFO(sc)	do { \
	(sc)->tulip_pci_busno = parent; \
	(sc)->tulip_pci_devno = pa->pa_device; \
    } while (0)

#include <dev/pci/if_devar.h>
/*
 * This module supports
 *	the DEC 21040 PCI Ethernet Controller.
 *	the DEC 21041 PCI Ethernet Controller.
 *	the DEC 21140 PCI Fast Ethernet Controller.
 */
int tulip_probe(struct device *parent, void *match, void *aux);
void tulip_attach(struct device * const parent, struct device * const self, void * const aux);

struct cfattach de_ca = {
	sizeof(tulip_softc_t), tulip_probe, tulip_attach
};

struct cfdriver de_cd = {
	NULL, "de", DV_IFNET
};

void tulip_timeout_callback(void *arg);
void tulip_timeout(tulip_softc_t * const sc);
int tulip_txprobe(tulip_softc_t * const sc);
void tulip_media_set(tulip_softc_t * const sc, tulip_media_t media);
void tulip_linkup(tulip_softc_t * const sc, tulip_media_t media);
void tulip_media_print(tulip_softc_t * const sc);
tulip_link_status_t tulip_media_link_monitor(tulip_softc_t * const sc);
void tulip_media_poll(tulip_softc_t * const sc, tulip_mediapoll_event_t event);
void tulip_media_select(tulip_softc_t * const sc);

void tulip_21040_mediainfo_init(tulip_softc_t * const sc, tulip_media_t media);
void tulip_21040_media_probe(tulip_softc_t * const sc);
void tulip_21040_10baset_only_media_probe(tulip_softc_t * const sc);
void tulip_21040_10baset_only_media_select(tulip_softc_t * const sc);
void tulip_21040_auibnc_only_media_probe(tulip_softc_t * const sc);
void tulip_21040_auibnc_only_media_select(tulip_softc_t * const sc);

void tulip_21041_mediainfo_init(tulip_softc_t * const sc);
void tulip_21041_media_probe(tulip_softc_t * const sc);
void tulip_21041_media_poll(tulip_softc_t * const sc, const tulip_mediapoll_event_t event);

tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);
unsigned tulip_mii_get_phyaddr(tulip_softc_t * const sc, unsigned offset);
int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);
void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);

void tulip_2114x_media_preset(tulip_softc_t * const sc);

void tulip_null_media_poll(tulip_softc_t * const sc, tulip_mediapoll_event_t event);

void tulip_21140_mediainit(tulip_softc_t * const sc, tulip_media_info_t * const mip,
    tulip_media_t const media, unsigned gpdata, unsigned cmdmode);
void tulip_21140_evalboard_media_probe(tulip_softc_t * const sc);
void tulip_21140_accton_media_probe(tulip_softc_t * const sc);
void tulip_21140_smc9332_media_probe(tulip_softc_t * const sc);
void tulip_21140_cogent_em100_media_probe(tulip_softc_t * const sc);
void tulip_21140_znyx_zx34x_media_probe(tulip_softc_t * const sc);

void tulip_2114x_media_probe(tulip_softc_t * const sc);

void tulip_delay_300ns(tulip_softc_t * const sc);
void tulip_srom_idle(tulip_softc_t * const sc);
void tulip_srom_read(tulip_softc_t * const sc);
void tulip_mii_writebits(tulip_softc_t * const sc, unsigned data, unsigned bits);
void tulip_mii_turnaround(tulip_softc_t * const sc, unsigned cmd);
unsigned tulip_mii_readbits(tulip_softc_t * const sc);
unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);
void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno,
    unsigned data);

void tulip_identify_dec_nic(tulip_softc_t * const sc);
void tulip_identify_znyx_nic(tulip_softc_t * const sc);
void tulip_identify_smc_nic(tulip_softc_t * const sc);
void tulip_identify_cogent_nic(tulip_softc_t * const sc);
void tulip_identify_accton_nic(tulip_softc_t * const sc);
void tulip_identify_asante_nic(tulip_softc_t * const sc);
void tulip_identify_compex_nic(tulip_softc_t * const sc);

int tulip_srom_decode(tulip_softc_t * const sc);
int tulip_read_macaddr(tulip_softc_t * const sc);
void tulip_ifmedia_add(tulip_softc_t * const sc);
int tulip_ifmedia_change(struct ifnet * const ifp);
void tulip_ifmedia_status(struct ifnet * const ifp, struct ifmediareq *req);
void tulip_addr_filter(tulip_softc_t * const sc);
void tulip_reset(tulip_softc_t * const sc);
void tulip_init(tulip_softc_t * const sc);
void tulip_rx_intr(tulip_softc_t * const sc);
int tulip_tx_intr(tulip_softc_t * const sc);
void tulip_print_abnormal_interrupt(tulip_softc_t * const sc, u_int32_t csr);
void tulip_intr_handler(tulip_softc_t * const sc, int *progress_p);
int tulip_intr_shared(void *arg);
int tulip_intr_normal(void *arg);
struct mbuf *tulip_mbuf_compress(struct mbuf *m);
struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m, int);
void tulip_txput_setup(tulip_softc_t * const sc);
int tulip_ifioctl(struct ifnet * ifp, u_long cmd, caddr_t data);
void tulip_ifstart(struct ifnet *ifp);
void tulip_ifwatchdog(struct ifnet *ifp);
int tulip_busdma_allocmem(tulip_softc_t * const sc, size_t size,
    bus_dmamap_t *map_p, tulip_desc_t **desc_p);
int tulip_busdma_init(tulip_softc_t * const sc);
void tulip_initcsrs(tulip_softc_t * const sc, bus_addr_t csr_base, size_t csr_size);
void tulip_initring(tulip_softc_t * const sc, tulip_ringinfo_t * const ri,
    tulip_desc_t *descs, int ndescs);

bus_dmamap_t tulip_alloc_rxmap(tulip_softc_t *);
void tulip_free_rxmap(tulip_softc_t *, bus_dmamap_t);
bus_dmamap_t tulip_alloc_txmap(tulip_softc_t *);
void tulip_free_txmap(tulip_softc_t *, bus_dmamap_t);

void
tulip_timeout_callback(void *arg)
{
    tulip_softc_t * const sc = arg;
    int s;

    s = splnet();

    TULIP_PERFSTART(timeout)

    sc->tulip_flags &= ~TULIP_TIMEOUTPENDING;
    sc->tulip_probe_timeout -= 1000 / TULIP_HZ;
    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_TIMER);

    TULIP_PERFEND(timeout);
    splx(s);
}

void
tulip_timeout(tulip_softc_t * const sc)
{
    if (sc->tulip_flags & TULIP_TIMEOUTPENDING)
	return;
    sc->tulip_flags |= TULIP_TIMEOUTPENDING;
    timeout_add(&sc->tulip_stmo, (hz + TULIP_HZ / 2) / TULIP_HZ);
}

int
tulip_txprobe(tulip_softc_t * const sc)
{
    struct mbuf *m;

    /*
     * Before we are sure this is the right media we need
     * to send a small packet to make sure there's carrier.
     * Strangely, BNC and AUI will "see" receive data if
     * either is connected so the transmit is the only way
     * to verify the connectivity.
     */
    MGETHDR(m, M_DONTWAIT, MT_DATA);
    if (m == NULL)
	return (0);
    /*
     * Construct a LLC TEST message which will point to ourselves.
     */
    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost,
       ETHER_ADDR_LEN);
    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost,
       ETHER_ADDR_LEN);
    mtod(m, struct ether_header *)->ether_type = htons(3);
    mtod(m, unsigned char *)[14] = 0;
    mtod(m, unsigned char *)[15] = 0;
    mtod(m, unsigned char *)[16] = 0xE3;	/* LLC Class1 TEST (no poll) */
    m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;
    /*
     * send it!
     */
    sc->tulip_cmdmode |= TULIP_CMD_TXRUN;
    sc->tulip_intrmask |= TULIP_STS_TXINTR;
    sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;
    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
    if ((m = tulip_txput(sc, m, 1)) != NULL)
	m_freem(m);
    sc->tulip_probe.probe_txprobes++;
    return (1);
}

void
tulip_media_set(tulip_softc_t * const sc, tulip_media_t media)
{
    const tulip_media_info_t *mi = sc->tulip_mediums[media];

    if (mi == NULL)
	return;

    /* Reset the SIA first
     */
    if (mi->mi_type == TULIP_MEDIAINFO_SIA || (sc->tulip_features & TULIP_HAVE_SIANWAY))
	TULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);

    /* Next, set full duplex if needed.
     */
    if (sc->tulip_flags & TULIP_FULLDUPLEX) {
#ifdef TULIP_DEBUG
	if (TULIP_CSR_READ(sc, csr_command) & (TULIP_CMD_RXRUN|TULIP_CMD_TXRUN))
	    printf(TULIP_PRINTF_FMT ": warning: board is running (FD).\n", TULIP_PRINTF_ARGS);
	if ((TULIP_CSR_READ(sc, csr_command) & TULIP_CMD_FULLDUPLEX) == 0)
	    printf(TULIP_PRINTF_FMT ": setting full duplex.\n", TULIP_PRINTF_ARGS);
#endif
	sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;
	TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~(TULIP_CMD_RXRUN|TULIP_CMD_TXRUN));
    }

    /* Now setup the media.
     *
     * If we are switching media, make sure we don't think there's
     * any stale RX activity
     */
    sc->tulip_flags &= ~TULIP_RXACT;
    if (mi->mi_type == TULIP_MEDIAINFO_SIA) {
	TULIP_CSR_WRITE(sc, csr_sia_tx_rx,        mi->mi_sia_tx_rx);
	if (sc->tulip_features & TULIP_HAVE_SIAGP) {
	    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_control|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);
	    DELAY(50);
	    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_gp_data|mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);
	} else
	    TULIP_CSR_WRITE(sc, csr_sia_general,  mi->mi_sia_general|TULIP_SIAGEN_WATCHDOG);
	TULIP_CSR_WRITE(sc, csr_sia_connectivity, mi->mi_sia_connectivity);
    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {
	/*
	 * If the cmdmode bits don't match the currently operating mode,
	 * set the cmdmode appropriately and reset the chip.
	 */
	if (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {
	    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;
	    sc->tulip_cmdmode |= mi->mi_cmdmode;
	    tulip_reset(sc);
	}
	TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);
	DELAY(10);
	TULIP_CSR_WRITE(sc, csr_gp, (u_int8_t) mi->mi_gpdata);
    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {
	/*
	 * If the cmdmode bits don't match the currently operating mode,
	 * set the cmdmode appropriately and reset the chip.
	 */
	if (((mi->mi_cmdmode ^ TULIP_CSR_READ(sc, csr_command)) & TULIP_GPR_CMDBITS) != 0) {
	    sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;
	    sc->tulip_cmdmode |= mi->mi_cmdmode;
	    tulip_reset(sc);
	}
	TULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpcontrol);
	TULIP_CSR_WRITE(sc, csr_sia_general, mi->mi_gpdata);
    } else if (mi->mi_type == TULIP_MEDIAINFO_MII
	       && sc->tulip_probe_state != TULIP_PROBE_INACTIVE) {
	int idx;
	if (sc->tulip_features & TULIP_HAVE_SIAGP) {
	    const u_int8_t *dp;
	    dp = &sc->tulip_rombuf[mi->mi_reset_offset];
	    for (idx = 0; idx < mi->mi_reset_length; idx++, dp += 2) {
		DELAY(10);
		TULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);
	    }
	    sc->tulip_phyaddr = mi->mi_phyaddr;
	    dp = &sc->tulip_rombuf[mi->mi_gpr_offset];
	    for (idx = 0; idx < mi->mi_gpr_length; idx++, dp += 2) {
		DELAY(10);
		TULIP_CSR_WRITE(sc, csr_sia_general, (dp[0] + 256 * dp[1]) << 16);
	    }
	} else {
	    for (idx = 0; idx < mi->mi_reset_length; idx++) {
		DELAY(10);
		TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx]);
	    }
	    sc->tulip_phyaddr = mi->mi_phyaddr;
	    for (idx = 0; idx < mi->mi_gpr_length; idx++) {
		DELAY(10);
		TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx]);
	    }
	}

	if (sc->tulip_features & TULIP_HAVE_SIANWAY) {
	    /* Set the SIA port into MII mode */
	    TULIP_CSR_WRITE(sc, csr_sia_general, 1);
	    TULIP_CSR_WRITE(sc, csr_sia_tx_rx, 0);
	    TULIP_CSR_WRITE(sc, csr_sia_status, 0);
	}

	if (sc->tulip_flags & TULIP_TRYNWAY)
	    tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);
	else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {
	    u_int32_t data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_CONTROL);
	    data &= ~(PHYCTL_SELECT_100MB|PHYCTL_FULL_DUPLEX|PHYCTL_AUTONEG_ENABLE);
	    sc->tulip_flags &= ~TULIP_DIDNWAY;
	    if (TULIP_IS_MEDIA_FD(media))
		data |= PHYCTL_FULL_DUPLEX;
	    if (TULIP_IS_MEDIA_100MB(media))
		data |= PHYCTL_SELECT_100MB;
	    tulip_mii_writereg(sc, sc->tulip_phyaddr, PHYREG_CONTROL, data);
	}
    }
}

void
tulip_linkup(tulip_softc_t * const sc, tulip_media_t media)
{
    if ((sc->tulip_flags & TULIP_LINKUP) == 0)
	sc->tulip_flags |= TULIP_PRINTLINKUP;
    sc->tulip_flags |= TULIP_LINKUP;
    ifq_clr_oactive(&sc->tulip_if.if_snd);
    if (sc->tulip_media != media) {
#ifdef TULIP_DEBUG
	sc->tulip_dbg.dbg_last_media = sc->tulip_media;
#endif
	sc->tulip_media = media;
	sc->tulip_flags |= TULIP_PRINTMEDIA;
	if (TULIP_IS_MEDIA_FD(sc->tulip_media))
	    sc->tulip_flags |= TULIP_FULLDUPLEX;
	else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0)
	    sc->tulip_flags &= ~TULIP_FULLDUPLEX;
    }
    /*
     * We could set probe_timeout to 0 but setting to 3000 puts this
     * in one central place and the only matters is tulip_link is
     * followed by a tulip_timeout.  Therefore setting it should not
     * result in aberrant behavour.
     */
    sc->tulip_probe_timeout = 3000;
    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_TRYNWAY);
    if (sc->tulip_flags & TULIP_INRESET)
	tulip_media_set(sc, sc->tulip_media);
    else if (sc->tulip_probe_media != sc->tulip_media) {
	/*
	 * No reason to change media if we have the right media.
	 */
	tulip_reset(sc);
    }
    tulip_init(sc);
}

void
tulip_media_print(tulip_softc_t * const sc)
{
    if ((sc->tulip_flags & TULIP_LINKUP) == 0)
	return;
    if (sc->tulip_flags & TULIP_PRINTMEDIA) {
#ifdef TULIP_DEBUG
	printf(TULIP_PRINTF_FMT ": enabling %s port\n",
	       TULIP_PRINTF_ARGS,
	       tulip_mediums[sc->tulip_media]);
#endif
	sc->tulip_flags &= ~(TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);
    } else if (sc->tulip_flags & TULIP_PRINTLINKUP) {
#ifdef TULIP_DEBUG
	printf(TULIP_PRINTF_FMT ": link up\n", TULIP_PRINTF_ARGS);
#endif
	sc->tulip_flags &= ~TULIP_PRINTLINKUP;
    }
}

tulip_link_status_t
tulip_media_link_monitor(tulip_softc_t * const sc)
{
    const tulip_media_info_t * const mi = sc->tulip_mediums[sc->tulip_media];
    tulip_link_status_t linkup = TULIP_LINK_DOWN;

    if (mi == NULL) {
#if defined(TULIP_DEBUG)
	printf("tulip_media_link_monitor: %s: botch at line %d\n",
	      tulip_mediums[sc->tulip_media],__LINE__);
#endif
	return (TULIP_LINK_UNKNOWN);
    }


    /*
     * Have we seen some packets?  If so, the link must be good.
     */
    if ((sc->tulip_flags & (TULIP_RXACT|TULIP_LINKUP)) == (TULIP_RXACT|TULIP_LINKUP)) {
	sc->tulip_flags &= ~TULIP_RXACT;
	sc->tulip_probe_timeout = 3000;
	return (TULIP_LINK_UP);
    }

    sc->tulip_flags &= ~TULIP_RXACT;
    if (mi->mi_type == TULIP_MEDIAINFO_MII) {
	u_int32_t status;
	/*
	 * Read the PHY status register.
	 */
	status = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS)
		| tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);
	if (status & PHYSTS_AUTONEG_DONE) {
	    /*
	     * If the PHY has completed autonegotiation, see the if the
	     * remote systems abilities have changed.  If so, upgrade or
	     * downgrade as appropriate.
	     */
	    u_int32_t abilities = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_AUTONEG_ABILITIES);
	    abilities = (abilities << 6) & status;
	    if (abilities != sc->tulip_abilities) {
#if defined(TULIP_DEBUG)
		printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\n",
			   TULIP_PRINTF_ARGS, sc->tulip_phyaddr,
			   sc->tulip_abilities, abilities);
#endif
		if (tulip_mii_map_abilities(sc, abilities)) {
		    tulip_linkup(sc, sc->tulip_probe_media);
		    return (TULIP_LINK_UP);
		}
		/*
		 * if we had selected media because of autonegotiation,
		 * we need to probe for the new media.
		 */
		sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
		if (sc->tulip_flags & TULIP_DIDNWAY)
		    return (TULIP_LINK_DOWN);
	    }
	}
	/*
	 * The link is now up.  If was down, say its back up.
	 */
	if ((status & (PHYSTS_LINK_UP|PHYSTS_REMOTE_FAULT)) == PHYSTS_LINK_UP)
	    linkup = TULIP_LINK_UP;
    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR) {
	/*
	 * No activity sensor?  Assume all's well.
	 */
	if (mi->mi_actmask == 0)
	    return (TULIP_LINK_UNKNOWN);
	/*
	 * Does the activity data match?
	 */
	if ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) == mi->mi_actdata)
	    linkup = TULIP_LINK_UP;
    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {
	/*
	 * Assume non TP ok for now.
	 */
	if (!TULIP_IS_MEDIA_TP(sc->tulip_media))
	    return (TULIP_LINK_UNKNOWN);
	if ((TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)
	    linkup = TULIP_LINK_UP;
#if defined(TULIP_DEBUG)
	if (sc->tulip_probe_timeout <= 0)
	    printf(TULIP_PRINTF_FMT ": sia status = 0x%08x\n", TULIP_PRINTF_ARGS, TULIP_CSR_READ(sc, csr_sia_status));
#endif
    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM)
	return (TULIP_LINK_UNKNOWN);
    /*
     * We will wait for 3 seconds until the link goes into suspect mode.
     */
    if (sc->tulip_flags & TULIP_LINKUP) {
	if (linkup == TULIP_LINK_UP)
	    sc->tulip_probe_timeout = 3000;
	if (sc->tulip_probe_timeout > 0)
	    return (TULIP_LINK_UP);

	sc->tulip_flags &= ~TULIP_LINKUP;
    }
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_link_downed++;
#endif
    return (TULIP_LINK_DOWN);
}

void
tulip_media_poll(tulip_softc_t * const sc, tulip_mediapoll_event_t event)
{
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_events[event]++;
#endif
    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE
	    && event == TULIP_MEDIAPOLL_TIMER) {
	switch (tulip_media_link_monitor(sc)) {
	    case TULIP_LINK_DOWN: {
		/*
		 * Link Monitor failed.  Probe for new media.
		 */
		event = TULIP_MEDIAPOLL_LINKFAIL;
		break;
	    }
	    case TULIP_LINK_UP: {
		/*
		 * Check again soon.
		 */
		tulip_timeout(sc);
		return;
	    }
	    case TULIP_LINK_UNKNOWN: {
		/*
		 * We can't tell so don't bother.
		 */
		return;
	    }
	}
    }

    if (event == TULIP_MEDIAPOLL_LINKFAIL) {
	if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE) {
	    if (TULIP_DO_AUTOSENSE(sc)) {
#if defined(TULIP_DEBUG)
		sc->tulip_dbg.dbg_link_failures++;
#endif
		sc->tulip_media = TULIP_MEDIA_UNKNOWN;
		if (sc->tulip_if.if_flags & IFF_UP)
		    tulip_reset(sc);	/* restart probe */
	    }
	    return;
	}
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_link_pollintrs++;
#endif
    }

    if (event == TULIP_MEDIAPOLL_START) {
	ifq_set_oactive(&sc->tulip_if.if_snd);
	if (sc->tulip_probe_state != TULIP_PROBE_INACTIVE)
	    return;
	sc->tulip_probe_mediamask = 0;
	sc->tulip_probe_passes = 0;
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_media_probes++;
#endif
	/*
	 * If the SROM contained an explicit media to use, use it.
	 */
	sc->tulip_cmdmode &= ~(TULIP_CMD_RXRUN|TULIP_CMD_FULLDUPLEX);
	sc->tulip_flags |= TULIP_TRYNWAY|TULIP_PROBE1STPASS;
	sc->tulip_flags &= ~(TULIP_DIDNWAY|TULIP_PRINTMEDIA|TULIP_PRINTLINKUP);
	/*
	 * connidx is defaulted to a media_unknown type.
	 */
	sc->tulip_probe_media = tulip_srom_conninfo[sc->tulip_connidx].sc_media;
	if (sc->tulip_probe_media != TULIP_MEDIA_UNKNOWN) {
	    tulip_linkup(sc, sc->tulip_probe_media);
	    tulip_timeout(sc);
	    return;
	}

	if (sc->tulip_features & TULIP_HAVE_GPR) {
	    sc->tulip_probe_state = TULIP_PROBE_GPRTEST;
	    sc->tulip_probe_timeout = 2000;
	} else {
	    sc->tulip_probe_media = TULIP_MEDIA_MAX;
	    sc->tulip_probe_timeout = 0;
	    sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
	}
    }

    /*
     * Ignore txprobe failures or spurious callbacks.
     */
    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED
	    && sc->tulip_probe_state != TULIP_PROBE_MEDIATEST) {
	sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
	return;
    }

    /*
     * If we really transmitted a packet, then that's the media we'll use.
     */
    if (event == TULIP_MEDIAPOLL_TXPROBE_OK || event == TULIP_MEDIAPOLL_LINKPASS) {
	if (event == TULIP_MEDIAPOLL_LINKPASS) {
	    /* XXX Check media status just to be sure */
	    sc->tulip_probe_media = TULIP_MEDIA_10BASET;
#if defined(TULIP_DEBUG)
	} else {
	    sc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;
#endif
	}
	tulip_linkup(sc, sc->tulip_probe_media);
	tulip_timeout(sc);
	return;
    }

    if (sc->tulip_probe_state == TULIP_PROBE_GPRTEST) {
	/*
	 * Brute force.  We cycle through each of the media types
	 * and try to transmit a packet.
	 */
	sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
	sc->tulip_probe_media = TULIP_MEDIA_MAX;
	sc->tulip_probe_timeout = 0;
	tulip_timeout(sc);
	return;
    }

    if (sc->tulip_probe_state != TULIP_PROBE_MEDIATEST
	   && (sc->tulip_features & TULIP_HAVE_MII)) {
	tulip_media_t old_media = sc->tulip_probe_media;
	tulip_mii_autonegotiate(sc, sc->tulip_phyaddr);
	switch (sc->tulip_probe_state) {
	    case TULIP_PROBE_FAILED:
	    case TULIP_PROBE_MEDIATEST: {
		/*
		 * Try the next media.
		 */
		sc->tulip_probe_mediamask |= sc->tulip_mediums[sc->tulip_probe_media]->mi_mediamask;
		sc->tulip_probe_timeout = 0;
		break;
	    }
	    case TULIP_PROBE_PHYAUTONEG: {
		return;
	    }
	    case TULIP_PROBE_INACTIVE: {
		/*
		 * Only probe if we autonegotiated a media that hasn't failed.
		 */
		sc->tulip_probe_timeout = 0;
		if (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media)) {
		    sc->tulip_probe_media = old_media;
		    break;
		}
		tulip_linkup(sc, sc->tulip_probe_media);
		tulip_timeout(sc);
		return;
	    }
	    default: {
#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)
		printf("tulip_media_poll: botch at line %d\n", __LINE__);
#endif
		break;
	    }
	}
    }

    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED) {
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_txprobes_failed[sc->tulip_probe_media]++;
#endif
	sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
	return;
    }

    /*
     * Switch to another media if we tried this one enough.
     */
    if (/* event == TULIP_MEDIAPOLL_TXPROBE_FAILED || */ sc->tulip_probe_timeout <= 0) {
#if defined(TULIP_DEBUG)
	if (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {
	    printf(TULIP_PRINTF_FMT ": poll media unknown!\n",
		   TULIP_PRINTF_ARGS);
	    sc->tulip_probe_media = TULIP_MEDIA_MAX;
	}
#endif
	/*
	 * Find the next media type to check for.  Full Duplex
	 * types are not allowed.
	 */
	do {
	    sc->tulip_probe_media -= 1;
	    if (sc->tulip_probe_media == TULIP_MEDIA_UNKNOWN) {
		if (++sc->tulip_probe_passes == 3) {
		    if ((sc->tulip_if.if_flags & IFF_UP) == 0) {
			sc->tulip_if.if_flags &= ~IFF_RUNNING;
			sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
			return;
		    }
		}
		sc->tulip_flags ^= TULIP_TRYNWAY;	/* XXX */
		sc->tulip_probe_mediamask = 0;
		sc->tulip_probe_media = TULIP_MEDIA_MAX - 1;
	    }
	} while (sc->tulip_mediums[sc->tulip_probe_media] == NULL
		 || (sc->tulip_probe_mediamask & TULIP_BIT(sc->tulip_probe_media))
		 || TULIP_IS_MEDIA_FD(sc->tulip_probe_media));

#if defined(TULIP_DEBUG)
	printf(TULIP_PRINTF_FMT ": %s: probing %s\n", TULIP_PRINTF_ARGS,
	       event == TULIP_MEDIAPOLL_TXPROBE_FAILED ? "txprobe failed" : "timeout",
	       tulip_mediums[sc->tulip_probe_media]);
#endif
	sc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 1000;
	sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
	sc->tulip_probe.probe_txprobes = 0;
	tulip_reset(sc);
	tulip_media_set(sc, sc->tulip_probe_media);
	sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
    }
    tulip_timeout(sc);

    /*
     * If this is hanging off a phy, we know are doing NWAY and we have
     * forced the phy to a specific speed.  Wait for link up before
     * before sending a packet.
     */
    switch (sc->tulip_mediums[sc->tulip_probe_media]->mi_type) {
	case TULIP_MEDIAINFO_MII: {
	    if (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))
		return;
	    break;
	}
	case TULIP_MEDIAINFO_SIA: {
	    if (TULIP_IS_MEDIA_TP(sc->tulip_probe_media)) {
		if (TULIP_CSR_READ(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL)
		    return;
		tulip_linkup(sc, sc->tulip_probe_media);
		return;
	    }
	    break;
	}
	case TULIP_MEDIAINFO_RESET:
	case TULIP_MEDIAINFO_SYM:
	case TULIP_MEDIAINFO_NONE:
	case TULIP_MEDIAINFO_GPR: {
	    break;
	}
    }
    /*
     * Try to send a packet.
     */
    tulip_txprobe(sc);
}

void
tulip_media_select(tulip_softc_t * const sc)
{
    if (sc->tulip_features & TULIP_HAVE_GPR) {
	TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_PINSET|sc->tulip_gpinit);
	DELAY(10);
	TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpdata);
    }
    /*
     * If this board has no media, just return
     */
    if (sc->tulip_features & TULIP_HAVE_NOMEDIA)
	return;

    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {
	TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	(*sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_START);
    } else
	tulip_media_set(sc, sc->tulip_media);
}

void
tulip_21040_mediainfo_init(tulip_softc_t * const sc, tulip_media_t media)
{
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160
	|TULIP_CMD_BACKOFFCTR;
    sc->tulip_if.if_baudrate = 10000000;

    if (media == TULIP_MEDIA_10BASET || media == TULIP_MEDIA_UNKNOWN) {
	TULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[0], 21040, 10BASET);
	TULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[1], 21040, 10BASET_FD);
	sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
    }

    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN)
	TULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[2], 21040, AUIBNC);

    if (media == TULIP_MEDIA_UNKNOWN)
	TULIP_MEDIAINFO_SIA_INIT(sc, &sc->tulip_mediainfo[3], 21040, EXTSIA);
}

void
tulip_21040_media_probe(tulip_softc_t * const sc)
{
    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_UNKNOWN);
}

void
tulip_21040_10baset_only_media_probe(tulip_softc_t * const sc)
{
    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_10BASET);
    tulip_media_set(sc, TULIP_MEDIA_10BASET);
    sc->tulip_media = TULIP_MEDIA_10BASET;
}

void
tulip_21040_10baset_only_media_select(tulip_softc_t * const sc)
{
    sc->tulip_flags |= TULIP_LINKUP;
    if (sc->tulip_media == TULIP_MEDIA_10BASET_FD) {
	sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;
	sc->tulip_flags &= ~TULIP_SQETEST;
    } else {
	sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;
	sc->tulip_flags |= TULIP_SQETEST;
    }
    tulip_media_set(sc, sc->tulip_media);
}

void
tulip_21040_auibnc_only_media_probe(tulip_softc_t * const sc)
{
    tulip_21040_mediainfo_init(sc, TULIP_MEDIA_AUIBNC);
    sc->tulip_flags |= TULIP_SQETEST|TULIP_LINKUP;
    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);
    sc->tulip_media = TULIP_MEDIA_AUIBNC;
}

void
tulip_21040_auibnc_only_media_select(tulip_softc_t * const sc)
{
    tulip_media_set(sc, TULIP_MEDIA_AUIBNC);
    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;
}

static const tulip_boardsw_t tulip_21040_boardsw = {
    TULIP_21040_GENERIC,
    tulip_21040_media_probe,
    tulip_media_select,
    tulip_media_poll,
};

static const tulip_boardsw_t tulip_21040_10baset_only_boardsw = {
    TULIP_21040_GENERIC,
    tulip_21040_10baset_only_media_probe,
    tulip_21040_10baset_only_media_select,
    NULL,
};

static const tulip_boardsw_t tulip_21040_auibnc_only_boardsw = {
    TULIP_21040_GENERIC,
    tulip_21040_auibnc_only_media_probe,
    tulip_21040_auibnc_only_media_select,
    NULL,
};

void
tulip_21041_mediainfo_init(tulip_softc_t * const sc)
{
    tulip_media_info_t * const mi = sc->tulip_mediainfo;

    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041, 10BASET);
    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041, 10BASET_FD);
    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[2], 21041, AUI);
    TULIP_MEDIAINFO_SIA_INIT(sc, &mi[3], 21041, BNC);
}

void
tulip_21041_media_probe(tulip_softc_t * const sc)
{
    sc->tulip_if.if_baudrate = 10000000;
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT
	|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;
    sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
    tulip_21041_mediainfo_init(sc);
}

void
tulip_21041_media_poll(tulip_softc_t * const sc, const tulip_mediapoll_event_t event)
{
    u_int32_t sia_status;

#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_events[event]++;
#endif

    if (event == TULIP_MEDIAPOLL_LINKFAIL) {
	if (sc->tulip_probe_state != TULIP_PROBE_INACTIVE
		|| !TULIP_DO_AUTOSENSE(sc))
	    return;
	sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	tulip_reset(sc);	/* start probe */
	return;
    }

    /*
     * If we've been been asked to start a poll or link change interrupt
     * restart the probe (and reset the tulip to a known state).
     */
    if (event == TULIP_MEDIAPOLL_START) {
	ifq_set_oactive(&sc->tulip_if.if_snd);
	sc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_RXRUN);
	TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
	sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
	sc->tulip_probe_media = TULIP_MEDIA_10BASET;
	sc->tulip_probe_timeout = TULIP_21041_PROBE_10BASET_TIMEOUT;
	tulip_media_set(sc, TULIP_MEDIA_10BASET);
	tulip_timeout(sc);
	return;
    }

    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)
	return;

    if (event == TULIP_MEDIAPOLL_TXPROBE_OK) {
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_txprobes_ok[sc->tulip_probe_media]++;
#endif
	tulip_linkup(sc, sc->tulip_probe_media);
	return;
    }

    sia_status = TULIP_CSR_READ(sc, csr_sia_status);
    TULIP_CSR_WRITE(sc, csr_sia_status, sia_status);
    if ((sia_status & TULIP_SIASTS_LINKFAIL) == 0) {
	if (sc->tulip_revinfo >= 0x20) {
	    if (sia_status & (PHYSTS_10BASET_FD << (16 - 6)))
		sc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;
	}
	/*
	 * If the link has passed LinkPass, 10baseT is the
	 * proper media to use.
	 */
	tulip_linkup(sc, sc->tulip_probe_media);
	return;
    }

    /*
     * wait for up to 2.4 seconds for the link to reach pass state.
     * Only then start scanning the other media for activity.
     * choose media with receive activity over those without.
     */
    if (sc->tulip_probe_media == TULIP_MEDIA_10BASET) {
	if (event != TULIP_MEDIAPOLL_TIMER)
	    return;
	if (sc->tulip_probe_timeout > 0
		&& (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) == 0) {
	    tulip_timeout(sc);
	    return;
	}
	sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;
	sc->tulip_flags |= TULIP_WANTRXACT;
	if (sia_status & TULIP_SIASTS_OTHERRXACTIVITY)
	    sc->tulip_probe_media = TULIP_MEDIA_BNC;
	else
	    sc->tulip_probe_media = TULIP_MEDIA_AUI;
	tulip_media_set(sc, sc->tulip_probe_media);
	tulip_timeout(sc);
	return;
    }

    /*
     * If we failed, clear the txprobe active flag.
     */
    if (event == TULIP_MEDIAPOLL_TXPROBE_FAILED)
	sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;


    if (event == TULIP_MEDIAPOLL_TIMER) {
	/*
	 * If we've received something, then that's our link!
	 */
	if (sc->tulip_flags & TULIP_RXACT) {
	    tulip_linkup(sc, sc->tulip_probe_media);
	    return;
	}
	/*
	 * if no txprobe active
	 */
	if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0
		&& ((sc->tulip_flags & TULIP_WANTRXACT) == 0
		    || (sia_status & TULIP_SIASTS_RXACTIVITY))) {
	    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;
	    tulip_txprobe(sc);
	    tulip_timeout(sc);
	    return;
	}
	/*
	 * Take 2 passes through before deciding to not
	 * wait for receive activity.  Then take another
	 * two passes before spitting out a warning.
	 */
	if (sc->tulip_probe_timeout <= 0) {
	    if (sc->tulip_flags & TULIP_WANTRXACT) {
		sc->tulip_flags &= ~TULIP_WANTRXACT;
		sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;
	    } else {
		if ((sc->tulip_if.if_flags & IFF_UP) == 0) {
		    sc->tulip_if.if_flags &= ~IFF_RUNNING;
		    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
		    return;
		}
	    }
	}
    }

    /*
     * Since this media failed to probe, try the other one.
     */
    sc->tulip_probe_timeout = TULIP_21041_PROBE_AUIBNC_TIMEOUT;
    if (sc->tulip_probe_media == TULIP_MEDIA_AUI)
	sc->tulip_probe_media = TULIP_MEDIA_BNC;
    else
	sc->tulip_probe_media = TULIP_MEDIA_AUI;
    tulip_media_set(sc, sc->tulip_probe_media);
    sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
    tulip_timeout(sc);
}

static const tulip_boardsw_t tulip_21041_boardsw = {
    TULIP_21041_GENERIC,
    tulip_21041_media_probe,
    tulip_media_select,
    tulip_21041_media_poll
};

static const tulip_phy_attr_t tulip_mii_phy_attrlist[] = {
    { 0x20005c00, 0,		/* 08-00-17 */
      {
	{ 0x19, 0x0040, 0x0040 },	/* 10TX */
	{ 0x19, 0x0040, 0x0000 },	/* 100TX */
      },
#if defined(TULIP_DEBUG)
      "NS DP83840",
#endif
    },
    { 0x0281F400, 0,		/* 00-A0-7D */
      {
	{ 0x12, 0x0010, 0x0000 },	/* 10T */
	{ 0 },				/* 100TX */
	{ 0x12, 0x0010, 0x0010 },	/* 100T4 */
	{ 0x12, 0x0008, 0x0008 },	/* FULL_DUPLEX */
      },
#if defined(TULIP_DEBUG)
      "Seeq 80C240"
#endif
    },
    { 0x0281F400, 3,	/* 00-A0-7D */
      {
	{ 0x12, 0x0080, 0x0000 },	/* 10T */
	{ 0x12, 0x0080, 0x0080 },	/* 100TX */
	{ 0 },				/* 100T4 */
	{ 0x12, 0x0040, 0x0040 },	/* FULL_DUPLEX */
      },
#if defined(TULIP_DEBUG)
      "Seeq 80225"
#endif
    },
    { 0x0281F400, 0,		/* 00-A0-BE */
      {
	{ 0x11, 0x8000, 0x0000 },	/* 10T */
	{ 0x11, 0x8000, 0x8000 },	/* 100TX */
	{ 0 },				/* 100T4 */
	{ 0x11, 0x4000, 0x4000 },	/* FULL_DUPLEX */
      },
#if defined(TULIP_DEBUG)
      "ICS 1890"
#endif
    },
    { 0x78100000, 0,		/* 00-A0-CC */
      {
	{ 0x14, 0x0800, 0x0000 },	/* 10TX */
	{ 0x14, 0x0800, 0x0800 },	/* 100TX */
	{ 0 },				/* 100T4 */
	{ 0x14, 0x1000, 0x1000 },	/* FULL_DUPLEX */
      },
#if defined(TULIP_DEBUG)
      "LEVEL1 LXT970"
#endif
    },
    { 0 }
};

tulip_media_t
tulip_mii_phy_readspecific(tulip_softc_t * const sc)
{
    const tulip_phy_attr_t *attr;
    u_int16_t data;
    u_int32_t id;
    unsigned idx = 0;
    static const tulip_media_t table[] = {
	TULIP_MEDIA_UNKNOWN,
	TULIP_MEDIA_10BASET,
	TULIP_MEDIA_100BASETX,
	TULIP_MEDIA_100BASET4,
	TULIP_MEDIA_UNKNOWN,
	TULIP_MEDIA_10BASET_FD,
	TULIP_MEDIA_100BASETX_FD,
	TULIP_MEDIA_UNKNOWN
    };

    /*
     * Don't read phy specific registers if link is not up.
     */
    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS)
	    | tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);
    if ((data & (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS)) != (PHYSTS_LINK_UP|PHYSTS_EXTENDED_REGS))
	return (TULIP_MEDIA_UNKNOWN);

    id = (tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDLOW) << 16) |
	tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_IDHIGH);
    for (attr = tulip_mii_phy_attrlist;; attr++) {
	if (attr->attr_id == 0)
	    return (TULIP_MEDIA_UNKNOWN);
	if ((id & ~0x0F) == attr->attr_id)
	    break;
    }

    if (attr->attr_modes[PHY_MODE_100TX].pm_regno) {
	const tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100TX];
	data = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);
	if ((data & pm->pm_mask) == pm->pm_value)
	    idx = 2;
    }
    if (idx == 0 && attr->attr_modes[PHY_MODE_100T4].pm_regno) {
	const tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_100T4];
	data = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);
	if ((data & pm->pm_mask) == pm->pm_value)
	    idx = 3;
    }
    if (idx == 0 && attr->attr_modes[PHY_MODE_10T].pm_regno) {
	const tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_10T];
	data = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);
	if ((data & pm->pm_mask) == pm->pm_value)
	    idx = 1;
    }
    if (idx != 0 && attr->attr_modes[PHY_MODE_FULLDUPLEX].pm_regno) {
	const tulip_phy_modedata_t * const pm = &attr->attr_modes[PHY_MODE_FULLDUPLEX];
	data = tulip_mii_readreg(sc, sc->tulip_phyaddr, pm->pm_regno);
	idx += ((data & pm->pm_mask) == pm->pm_value ? 4 : 0);
    }
    return (table[idx]);
}

unsigned
tulip_mii_get_phyaddr(tulip_softc_t * const sc, unsigned offset)
{
    unsigned phyaddr;

    for (phyaddr = 1; phyaddr < 32; phyaddr++) {
	unsigned status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);
	if (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)
	    continue;
	if (offset == 0)
	    return (phyaddr);
	offset--;
    }
    if (offset == 0) {
	unsigned status = tulip_mii_readreg(sc, 0, PHYREG_STATUS);
	if (status == 0 || status == 0xFFFF || status < PHYSTS_10BASET)
	    return (TULIP_MII_NOPHY);
	return (0);
    }
    return (TULIP_MII_NOPHY);
}

int
tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities)
{
    sc->tulip_abilities = abilities;
    if (abilities & PHYSTS_100BASETX_FD)
	sc->tulip_probe_media = TULIP_MEDIA_100BASETX_FD;
    else if (abilities & PHYSTS_100BASET4)
	sc->tulip_probe_media = TULIP_MEDIA_100BASET4;
    else if (abilities & PHYSTS_100BASETX)
	sc->tulip_probe_media = TULIP_MEDIA_100BASETX;
    else if (abilities & PHYSTS_10BASET_FD)
	sc->tulip_probe_media = TULIP_MEDIA_10BASET_FD;
    else if (abilities & PHYSTS_10BASET)
	sc->tulip_probe_media = TULIP_MEDIA_10BASET;
    else {
	sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
	return (0);
    }
    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
    return (1);
}

void
tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr)
{
    switch (sc->tulip_probe_state) {
        case TULIP_PROBE_MEDIATEST:
        case TULIP_PROBE_INACTIVE: {
	    sc->tulip_flags |= TULIP_DIDNWAY;
	    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, PHYCTL_RESET);
	    sc->tulip_probe_timeout = 3000;
	    sc->tulip_intrmask |= TULIP_STS_ABNRMLINTR|TULIP_STS_NORMALINTR;
	    sc->tulip_probe_state = TULIP_PROBE_PHYRESET;
	    /* FALLTHROUGH */
	}
        case TULIP_PROBE_PHYRESET: {
	    u_int32_t status;
	    u_int32_t data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);
	    if (data & PHYCTL_RESET) {
		if (sc->tulip_probe_timeout > 0) {
		    tulip_timeout(sc);
		    return;
		}
#ifdef TULIP_DEBUG
		printf(TULIP_PRINTF_FMT "(phy%d): error: reset of PHY never completed!\n",
			   TULIP_PRINTF_ARGS, phyaddr);
#endif
		sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
		sc->tulip_probe_state = TULIP_PROBE_FAILED;
		sc->tulip_if.if_flags &= ~IFF_RUNNING;
		return;
	    }
	    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS)
		    | tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);
	    if ((status & PHYSTS_CAN_AUTONEG) == 0) {
#if defined(TULIP_DEBUG)
		printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation disabled\n",
			   TULIP_PRINTF_ARGS, phyaddr);
#endif
		sc->tulip_flags &= ~TULIP_DIDNWAY;
		sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
		return;
	    }
	    if (tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT) != ((status >> 6) | 0x01))
		tulip_mii_writereg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT, (status >> 6) | 0x01);
	    tulip_mii_writereg(sc, phyaddr, PHYREG_CONTROL, data|PHYCTL_AUTONEG_RESTART|PHYCTL_AUTONEG_ENABLE);
	    data = tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL);
#if defined(TULIP_DEBUG)
	    if ((data & PHYCTL_AUTONEG_ENABLE) == 0)
		printf(TULIP_PRINTF_FMT "(phy%d): oops: enable autonegotiation failed: 0x%04x\n",
			   TULIP_PRINTF_ARGS, phyaddr, data);
	    else
		printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation restarted: 0x%04x (ad=0x%04x)\n",
			   TULIP_PRINTF_ARGS, phyaddr, data,
			   tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ADVERTISEMENT));
	    sc->tulip_dbg.dbg_nway_starts++;
#endif
	    sc->tulip_probe_state = TULIP_PROBE_PHYAUTONEG;
	    sc->tulip_probe_timeout = 3000;
	    /* FALLTHROUGH */
	}
        case TULIP_PROBE_PHYAUTONEG: {
	    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS)
			    | tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);
	    u_int32_t data;
	    if ((status & PHYSTS_AUTONEG_DONE) == 0) {
		if (sc->tulip_probe_timeout > 0) {
		    tulip_timeout(sc);
		    return;
		}
#if defined(TULIP_DEBUG)
		printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\n",
			   TULIP_PRINTF_ARGS, phyaddr, status,
			   tulip_mii_readreg(sc, phyaddr, PHYREG_CONTROL));
#endif
		sc->tulip_flags &= ~TULIP_DIDNWAY;
		sc->tulip_probe_state = TULIP_PROBE_MEDIATEST;
		return;
	    }
	    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES)
		| tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);
#if defined(TULIP_DEBUG)
	    printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation complete: 0x%04x (sts=0x%04x)\n",
		       TULIP_PRINTF_ARGS, phyaddr, data, status);
#endif
	    data = (data << 6) & status;
	    if (!tulip_mii_map_abilities(sc, data))
		sc->tulip_flags &= ~TULIP_DIDNWAY;
	    return;
	}
	default: {
#if defined(DIAGNOSTIC)
	    printf("tulip_media_poll: botch at line %d\n", __LINE__);
#endif
	    break;
	}
    }
#if defined(TULIP_DEBUG)
    printf(TULIP_PRINTF_FMT "(phy%d): autonegotiation failure: state = %d\n",
	       TULIP_PRINTF_ARGS, phyaddr, sc->tulip_probe_state);
	    sc->tulip_dbg.dbg_nway_failures++;
#endif
}

void
tulip_2114x_media_preset(tulip_softc_t * const sc)
{
    const tulip_media_info_t *mi = NULL;
    tulip_media_t media = sc->tulip_media;

    if (sc->tulip_probe_state == TULIP_PROBE_INACTIVE)
	media = sc->tulip_media;
    else
	media = sc->tulip_probe_media;

    sc->tulip_cmdmode &= ~(TULIP_CMD_PORTSELECT|TULIP_CMD_NOHEARTBEAT
		|TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL);
    sc->tulip_flags &= ~(TULIP_SQETEST|TULIP_FULLDUPLEX);
    if (media != TULIP_MEDIA_UNKNOWN && media != TULIP_MEDIA_MAX) {
#if defined(TULIP_DEBUG)
	if (media < TULIP_MEDIA_MAX && sc->tulip_mediums[media] != NULL) {
#endif
	    mi = sc->tulip_mediums[media];
	    if (mi->mi_type == TULIP_MEDIAINFO_MII)
		sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;
	    else if (mi->mi_type == TULIP_MEDIAINFO_GPR
		       || mi->mi_type == TULIP_MEDIAINFO_SYM) {
		sc->tulip_cmdmode &= ~TULIP_GPR_CMDBITS;
		sc->tulip_cmdmode |= mi->mi_cmdmode;
	    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA)
		TULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
#if defined(TULIP_DEBUG)
	} else {
	    printf(TULIP_PRINTF_FMT ": preset: bad media %d!\n",
		   TULIP_PRINTF_ARGS, media);
	}
#endif
    }
    switch (media) {
	case TULIP_MEDIA_BNC:
	case TULIP_MEDIA_AUI:
	case TULIP_MEDIA_10BASET: {
	    sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;
	    sc->tulip_if.if_baudrate = 10000000;
	    sc->tulip_flags |= TULIP_SQETEST;
	    break;
	}
	case TULIP_MEDIA_10BASET_FD: {
	    sc->tulip_flags |= TULIP_FULLDUPLEX;
	    sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX;
	    sc->tulip_if.if_baudrate = 10000000;
	    break;
	}
	case TULIP_MEDIA_100BASEFX:
	case TULIP_MEDIA_100BASET4:
	case TULIP_MEDIA_100BASETX: {
	    sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT;
	    sc->tulip_if.if_baudrate = 100000000;
	    if (mi->mi_type == TULIP_MEDIAINFO_SYM
		    || mi->mi_type == TULIP_MEDIAINFO_MII) {
		sc->tulip_cmdmode |= TULIP_CMD_NOHEARTBEAT;
	    }
	    break;
	}
	case TULIP_MEDIA_100BASEFX_FD:
	case TULIP_MEDIA_100BASETX_FD: {
	    sc->tulip_flags |= TULIP_FULLDUPLEX;
	    sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT|TULIP_CMD_FULLDUPLEX;
	    sc->tulip_if.if_baudrate = 100000000;
	    if (mi->mi_type == TULIP_MEDIAINFO_SYM
		    || mi->mi_type == TULIP_MEDIAINFO_MII) {
		sc->tulip_cmdmode |= TULIP_CMD_NOHEARTBEAT;
	    }
	    break;
	}
	default: {
	    break;
	}
    }
    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
}

/*
 ********************************************************************
 *  Start of 21140/21140A support which does not use the MII interface
 */

void
tulip_null_media_poll(tulip_softc_t * const sc, tulip_mediapoll_event_t event)
{
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_events[event]++;
#endif
#if defined(DIAGNOSTIC)
    printf(TULIP_PRINTF_FMT ": botch(media_poll) at line %d\n",
	   TULIP_PRINTF_ARGS, __LINE__);
#endif
}

void
tulip_21140_mediainit(tulip_softc_t * const sc, tulip_media_info_t * const mip,
    tulip_media_t const media, unsigned gpdata, unsigned cmdmode)
{
    sc->tulip_mediums[media] = mip;
    mip->mi_type = TULIP_MEDIAINFO_GPR;
    mip->mi_cmdmode = cmdmode;
    mip->mi_gpdata = gpdata;
}

void
tulip_21140_evalboard_media_probe(tulip_softc_t * const sc)
{
    tulip_media_info_t *mip = sc->tulip_mediainfo;

    sc->tulip_gpinit = TULIP_GP_EB_PINS;
    sc->tulip_gpdata = TULIP_GP_EB_INIT;
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    DELAY(1000000);
    if ((TULIP_CSR_READ(sc, csr_gp) & TULIP_GP_EB_OK100) != 0)
	sc->tulip_media = TULIP_MEDIA_10BASET;
    else
	sc->tulip_media = TULIP_MEDIA_100BASETX;
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,
			  TULIP_GP_EB_INIT,
			  TULIP_CMD_TXTHRSHLDCTL);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,
			  TULIP_GP_EB_INIT,
			  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,
			  TULIP_GP_EB_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,
			  TULIP_GP_EB_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);
}

static const tulip_boardsw_t tulip_21140_eb_boardsw = {
    TULIP_21140_DEC_EB,
    tulip_21140_evalboard_media_probe,
    tulip_media_select,
    tulip_null_media_poll,
    tulip_2114x_media_preset,
};

void
tulip_21140_accton_media_probe(tulip_softc_t * const sc)
{
    tulip_media_info_t *mip = sc->tulip_mediainfo;
    unsigned gpdata;

    sc->tulip_gpinit = TULIP_GP_EB_PINS;
    sc->tulip_gpdata = TULIP_GP_EB_INIT;
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_PINS);
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EB_INIT);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    DELAY(1000000);
    gpdata = TULIP_CSR_READ(sc, csr_gp);
    if ((gpdata & TULIP_GP_EN1207_UTP_INIT) == 0)
	sc->tulip_media = TULIP_MEDIA_10BASET;
    else {
	if ((gpdata & TULIP_GP_EN1207_BNC_INIT) == 0)
		sc->tulip_media = TULIP_MEDIA_BNC;
        else
		sc->tulip_media = TULIP_MEDIA_100BASETX;
    }
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_BNC,
			  TULIP_GP_EN1207_BNC_INIT,
			  TULIP_CMD_TXTHRSHLDCTL);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,
			  TULIP_GP_EN1207_UTP_INIT,
			  TULIP_CMD_TXTHRSHLDCTL);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,
			  TULIP_GP_EN1207_UTP_INIT,
			  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,
			  TULIP_GP_EN1207_100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,
			  TULIP_GP_EN1207_100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);
}

static const tulip_boardsw_t tulip_21140_accton_boardsw = {
    TULIP_21140_EN1207,
    tulip_21140_accton_media_probe,
    tulip_media_select,
    tulip_null_media_poll,
    tulip_2114x_media_preset,
};

void
tulip_21140_smc9332_media_probe(tulip_softc_t * const sc)
{
    tulip_media_info_t *mip = sc->tulip_mediainfo;
    int idx, cnt = 0;

    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT|TULIP_CMD_MUSTBEONE);
    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
		   33MHz that comes to two microseconds but wait a
		   bit longer anyways) */
    TULIP_CSR_WRITE(sc, csr_command, TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    sc->tulip_gpinit = TULIP_GP_SMC_9332_PINS;
    sc->tulip_gpdata = TULIP_GP_SMC_9332_INIT;
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_PINS|TULIP_GP_PINSET);
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_SMC_9332_INIT);
    DELAY(200000);
    for (idx = 1000; idx > 0; idx--) {
	u_int32_t csr = TULIP_CSR_READ(sc, csr_gp);
	if ((csr & (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) == (TULIP_GP_SMC_9332_OK10|TULIP_GP_SMC_9332_OK100)) {
	    if (++cnt > 100)
		break;
	} else if ((csr & TULIP_GP_SMC_9332_OK10) == 0)
	    break;
	else
	    cnt = 0;
	DELAY(1000);
    }
    sc->tulip_media = cnt > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,
			  TULIP_GP_SMC_9332_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,
			  TULIP_GP_SMC_9332_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,
			  TULIP_GP_SMC_9332_INIT,
			  TULIP_CMD_TXTHRSHLDCTL);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,
			  TULIP_GP_SMC_9332_INIT,
			  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);
}

static const tulip_boardsw_t tulip_21140_smc9332_boardsw = {
    TULIP_21140_SMC_9332,
    tulip_21140_smc9332_media_probe,
    tulip_media_select,
    tulip_null_media_poll,
    tulip_2114x_media_preset,
};

void
tulip_21140_cogent_em100_media_probe(tulip_softc_t * const sc)
{
    tulip_media_info_t *mip = sc->tulip_mediainfo;
    u_int32_t cmdmode = TULIP_CSR_READ(sc, csr_command);

    sc->tulip_gpinit = TULIP_GP_EM100_PINS;
    sc->tulip_gpdata = TULIP_GP_EM100_INIT;
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_PINS);
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_EM100_INIT);

    cmdmode = TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_MUSTBEONE;
    cmdmode &= ~(TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_SCRAMBLER);
    if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {
	TULIP_CSR_WRITE(sc, csr_command, cmdmode);
	sc->tulip_media = TULIP_MEDIA_100BASEFX;

	tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX,
			  TULIP_GP_EM100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION);
	tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASEFX_FD,
			  TULIP_GP_EM100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_FULLDUPLEX);
    } else {
	TULIP_CSR_WRITE(sc, csr_command, cmdmode|TULIP_CMD_SCRAMBLER);
	sc->tulip_media = TULIP_MEDIA_100BASETX;
	tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,
			  TULIP_GP_EM100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER);
	tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,
			  TULIP_GP_EM100_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);
    }
}

static const tulip_boardsw_t tulip_21140_cogent_em100_boardsw = {
    TULIP_21140_COGENT_EM100,
    tulip_21140_cogent_em100_media_probe,
    tulip_media_select,
    tulip_null_media_poll,
    tulip_2114x_media_preset
};

void
tulip_21140_znyx_zx34x_media_probe(tulip_softc_t * const sc)
{
    tulip_media_info_t *mip = sc->tulip_mediainfo;
    int cnt10 = 0, cnt100 = 0, idx;

    sc->tulip_gpinit = TULIP_GP_ZX34X_PINS;
    sc->tulip_gpdata = TULIP_GP_ZX34X_INIT;
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_PINS);
    TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ZX34X_INIT);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_CSR_WRITE(sc, csr_command,
	TULIP_CSR_READ(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);

    DELAY(200000);
    for (idx = 1000; idx > 0; idx--) {
	u_int32_t csr = TULIP_CSR_READ(sc, csr_gp);
	if ((csr & (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) == (TULIP_GP_ZX34X_LNKFAIL|TULIP_GP_ZX34X_SYMDET|TULIP_GP_ZX34X_SIGDET)) {
	    if (++cnt100 > 100)
		break;
	} else if ((csr & TULIP_GP_ZX34X_LNKFAIL) == 0) {
	    if (++cnt10 > 100)
		break;
	} else {
	    cnt10 = 0;
	    cnt100 = 0;
	}
	DELAY(1000);
    }
    sc->tulip_media = cnt100 > 100 ? TULIP_MEDIA_100BASETX : TULIP_MEDIA_10BASET;
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET,
			  TULIP_GP_ZX34X_INIT,
			  TULIP_CMD_TXTHRSHLDCTL);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_10BASET_FD,
			  TULIP_GP_ZX34X_INIT,
			  TULIP_CMD_TXTHRSHLDCTL|TULIP_CMD_FULLDUPLEX);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX,
			  TULIP_GP_ZX34X_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER);
    tulip_21140_mediainit(sc, mip++, TULIP_MEDIA_100BASETX_FD,
			  TULIP_GP_ZX34X_INIT,
			  TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION
			      |TULIP_CMD_SCRAMBLER|TULIP_CMD_FULLDUPLEX);
}

static const tulip_boardsw_t tulip_21140_znyx_zx34x_boardsw = {
    TULIP_21140_ZNYX_ZX34X,
    tulip_21140_znyx_zx34x_media_probe,
    tulip_media_select,
    tulip_null_media_poll,
    tulip_2114x_media_preset,
};

void
tulip_2114x_media_probe(tulip_softc_t * const sc)
{
    sc->tulip_cmdmode |= TULIP_CMD_MUSTBEONE
	|TULIP_CMD_BACKOFFCTR|TULIP_CMD_THRSHLD72;
}

static const tulip_boardsw_t tulip_2114x_isv_boardsw = {
    TULIP_21140_ISV,
    tulip_2114x_media_probe,
    tulip_media_select,
    tulip_media_poll,
    tulip_2114x_media_preset,
};

/*
 * ******** END of chip-specific handlers. ***********
 */

/*
 * Code the read the SROM and MII bit streams (I2C)
 */
void
tulip_delay_300ns(tulip_softc_t * const sc)
{
    int idx;
    for (idx = (300 / 33) + 1; idx > 0; idx--)
	(void) TULIP_CSR_READ(sc, csr_busmode);
}

void
tulip_srom_idle(tulip_softc_t * const sc)
{
    unsigned bit, csr;

    csr  = SROMSEL ; EMIT;
    csr  = SROMSEL | SROMRD; EMIT;
    csr ^= SROMCS; EMIT;
    csr ^= SROMCLKON; EMIT;

    /*
     * Write 25 cycles of 0 which will force the SROM to be idle.
     */
    for (bit = 3 + SROM_BITWIDTH + 16; bit > 0; bit--) {
        csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
        csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
    }
    csr ^= SROMCLKOFF; EMIT;
    csr ^= SROMCS; EMIT;
    csr  = 0; EMIT;
}

void
tulip_srom_read(tulip_softc_t * const sc)
{
    unsigned idx;
    const unsigned bitwidth = SROM_BITWIDTH;
    const unsigned cmdmask = (SROMCMD_RD << bitwidth);
    const unsigned msb = 1 << (bitwidth + 3 - 1);
    unsigned lastidx = (1 << bitwidth) - 1;

    tulip_srom_idle(sc);

    for (idx = 0; idx <= lastidx; idx++) {
        unsigned lastbit, data, bits, bit, csr;
	csr  = SROMSEL ;	        EMIT;
        csr  = SROMSEL | SROMRD;        EMIT;
        csr ^= SROMCSON;                EMIT;
        csr ^=            SROMCLKON;    EMIT;

        lastbit = 0;
        for (bits = idx|cmdmask, bit = bitwidth + 3; bit > 0; bit--, bits <<= 1) {
            const unsigned thisbit = bits & msb;
            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
            if (thisbit != lastbit) {
                csr ^= SROMDOUT; EMIT;  /* clock low; invert data */
            } else {
		EMIT;
            }
            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
            lastbit = thisbit;
        }
        csr ^= SROMCLKOFF; EMIT;

        for (data = 0, bits = 0; bits < 16; bits++) {
            data <<= 1;
            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
            data |= TULIP_CSR_READ(sc, csr_srom_mii) & SROMDIN ? 1 : 0;
            csr ^= SROMCLKOFF; EMIT;    /* clock low; data not valid */
        }
	sc->tulip_rombuf[idx*2] = data & 0xFF;
	sc->tulip_rombuf[idx*2+1] = data >> 8;
	csr  = SROMSEL | SROMRD; EMIT;
	csr  = 0; EMIT;
    }
    tulip_srom_idle(sc);
}

void
tulip_mii_writebits(tulip_softc_t * const sc, unsigned data, unsigned bits)
{
    unsigned msb = 1 << (bits - 1);
    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);
    unsigned lastbit = (csr & MII_DOUT) ? msb : 0;

    csr |= MII_WR; MII_EMIT;		/* clock low; assert write */

    for (; bits > 0; bits--, data <<= 1) {
	const unsigned thisbit = data & msb;
	if (thisbit != lastbit)
	    csr ^= MII_DOUT; MII_EMIT;  /* clock low; invert data */
	csr ^= MII_CLKON; MII_EMIT;     /* clock high; data valid */
	lastbit = thisbit;
	csr ^= MII_CLKOFF; MII_EMIT;    /* clock low; data not valid */
    }
}

void
tulip_mii_turnaround(tulip_softc_t * const sc, unsigned cmd)
{
    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);

    if (cmd == MII_WRCMD) {
	csr |= MII_DOUT; MII_EMIT;	/* clock low; change data */
	csr ^= MII_CLKON; MII_EMIT;	/* clock high; data valid */
	csr ^= MII_CLKOFF; MII_EMIT;	/* clock low; data not valid */
	csr ^= MII_DOUT; MII_EMIT;	/* clock low; change data */
    } else
	csr |= MII_RD; MII_EMIT;	/* clock low; switch to read */
    csr ^= MII_CLKON; MII_EMIT;		/* clock high; data valid */
    csr ^= MII_CLKOFF; MII_EMIT;	/* clock low; data not valid */
}

unsigned
tulip_mii_readbits(tulip_softc_t * const sc)
{
    unsigned data;
    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);
    int idx;

    for (idx = 0, data = 0; idx < 16; idx++) {
	data <<= 1;	/* this is NOOP on the first pass through */
	csr ^= MII_CLKON; MII_EMIT;	/* clock high; data valid */
	if (TULIP_CSR_READ(sc, csr_srom_mii) & MII_DIN)
	    data |= 1;
	csr ^= MII_CLKOFF; MII_EMIT;	/* clock low; data not valid */
    }
    csr ^= MII_RD; MII_EMIT;		/* clock low; turn off read */

    return (data);
}

unsigned
tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno)
{
    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);
    unsigned data;

    csr &= ~(MII_RD|MII_CLK); MII_EMIT;
    tulip_mii_writebits(sc, MII_PREAMBLE, 32);
    tulip_mii_writebits(sc, MII_RDCMD, 8);
    tulip_mii_writebits(sc, devaddr, 5);
    tulip_mii_writebits(sc, regno, 5);
    tulip_mii_turnaround(sc, MII_RDCMD);

    data = tulip_mii_readbits(sc);
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_phyregs[regno][0] = data;
    sc->tulip_dbg.dbg_phyregs[regno][1]++;
#endif
    return (data);
}

void
tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr,
    unsigned regno, unsigned data)
{
    unsigned csr;

    csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);
    csr &= ~(MII_RD|MII_CLK); MII_EMIT;
    tulip_mii_writebits(sc, MII_PREAMBLE, 32);
    tulip_mii_writebits(sc, MII_WRCMD, 8);
    tulip_mii_writebits(sc, devaddr, 5);
    tulip_mii_writebits(sc, regno, 5);
    tulip_mii_turnaround(sc, MII_WRCMD);
    tulip_mii_writebits(sc, data, 16);
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_phyregs[regno][2] = data;
    sc->tulip_dbg.dbg_phyregs[regno][3]++;
#endif
}

void
tulip_identify_dec_nic(tulip_softc_t * const sc)
{
    strlcpy(sc->tulip_boardid, "DEC ", sizeof(sc->tulip_boardid));
#define D0	4
    if (sc->tulip_chipid <= TULIP_DE425)
	return;
    if (bcmp(sc->tulip_rombuf + 29, "DE500", 5) == 0
	|| bcmp(sc->tulip_rombuf + 29, "DE450", 5) == 0) {
	bcopy(sc->tulip_rombuf + 29, &sc->tulip_boardid[D0], 8);
	sc->tulip_boardid[D0+8] = ' ';
    }
#undef D0
}

void
tulip_identify_znyx_nic(tulip_softc_t * const sc)
{
    unsigned id = 0;
    strlcpy(sc->tulip_boardid, "ZNYX ZX3XX ", sizeof(sc->tulip_boardid));
    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {
	unsigned znyx_ptr;
	sc->tulip_boardid[8] = '4';
	znyx_ptr = sc->tulip_rombuf[124] + 256 * sc->tulip_rombuf[125];
	if (znyx_ptr < 26 || znyx_ptr > 116) {
	    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;
	    return;
	}
	/* ZX344 = 0010 .. 0013FF
	 */
	if (sc->tulip_rombuf[znyx_ptr] == 0x4A
		&& sc->tulip_rombuf[znyx_ptr + 1] == 0x52
		&& sc->tulip_rombuf[znyx_ptr + 2] == 0x01) {
	    id = sc->tulip_rombuf[znyx_ptr + 5] + 256 * sc->tulip_rombuf[znyx_ptr + 4];
	    if ((id >> 8) == (TULIP_ZNYX_ID_ZX342 >> 8)) {
		sc->tulip_boardid[9] = '2';
		if (id == TULIP_ZNYX_ID_ZX342B) {
		    sc->tulip_boardid[10] = 'B';
		    sc->tulip_boardid[11] = ' ';
		}
		sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;
	    } else if (id == TULIP_ZNYX_ID_ZX344) {
		sc->tulip_boardid[10] = '4';
		sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;
	    } else if (id == TULIP_ZNYX_ID_ZX345) {
		sc->tulip_boardid[9] = (sc->tulip_rombuf[19] > 1) ? '8' : '5';
	    } else if (id == TULIP_ZNYX_ID_ZX346) {
		sc->tulip_boardid[9] = '6';
	    } else if (id == TULIP_ZNYX_ID_ZX351) {
		sc->tulip_boardid[8] = '5';
		sc->tulip_boardid[9] = '1';
	    }
	}
	if (id == 0) {
	    /*
	     * Assume it's a ZX342...
	     */
	    sc->tulip_boardsw = &tulip_21140_znyx_zx34x_boardsw;
	}
	return;
    }
    sc->tulip_boardid[8] = '1';
    if (sc->tulip_chipid == TULIP_21041) {
	sc->tulip_boardid[10] = '1';
	return;
    }
    if (sc->tulip_rombuf[32] == 0x4A && sc->tulip_rombuf[33] == 0x52) {
	id = sc->tulip_rombuf[37] + 256 * sc->tulip_rombuf[36];
	if (id == TULIP_ZNYX_ID_ZX312T) {
	    sc->tulip_boardid[9] = '2';
	    sc->tulip_boardid[10] = 'T';
	    sc->tulip_boardid[11] = ' ';
	    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;
	} else if (id == TULIP_ZNYX_ID_ZX314_INTA) {
	    sc->tulip_boardid[9] = '4';
	    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;
	    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;
	} else if (id == TULIP_ZNYX_ID_ZX314) {
	    sc->tulip_boardid[9] = '4';
	    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;
	    sc->tulip_features |= TULIP_HAVE_BASEROM;
	} else if (id == TULIP_ZNYX_ID_ZX315_INTA) {
	    sc->tulip_boardid[9] = '5';
	    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;
	} else if (id == TULIP_ZNYX_ID_ZX315) {
	    sc->tulip_boardid[9] = '5';
	    sc->tulip_features |= TULIP_HAVE_BASEROM;
	} else
	    id = 0;
    }
    if (id == 0) {
	if ((sc->tulip_enaddr[3] & ~3) == 0xF0 && (sc->tulip_enaddr[5] & 3) == 0) {
	    sc->tulip_boardid[9] = '4';
	    sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;
	    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;
	} else if ((sc->tulip_enaddr[3] & ~3) == 0xF4 && (sc->tulip_enaddr[5] & 1) == 0) {
	    sc->tulip_boardid[9] = '5';
	    sc->tulip_boardsw = &tulip_21040_boardsw;
	    sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;
	} else if ((sc->tulip_enaddr[3] & ~3) == 0xEC) {
	    sc->tulip_boardid[9] = '2';
	    sc->tulip_boardsw = &tulip_21040_boardsw;
	}
    }
}

void
tulip_identify_smc_nic(tulip_softc_t * const sc)
{
    u_int32_t id1, id2, ei;
    int auibnc = 0, utp = 0;
    char *cp;

    strlcpy(sc->tulip_boardid, "SMC ", sizeof(sc->tulip_boardid));
    if (sc->tulip_chipid == TULIP_21041)
	return;
    if (sc->tulip_chipid != TULIP_21040) {
	if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {
	    strlcat(sc->tulip_boardid, "9332DST ", sizeof(sc->tulip_boardid));
	    sc->tulip_boardsw = &tulip_21140_smc9332_boardsw;
	} else if (sc->tulip_features & (TULIP_HAVE_BASEROM|TULIP_HAVE_SLAVEDROM))
	    strlcat(sc->tulip_boardid, "9334BDT ", sizeof(sc->tulip_boardid));
	else
	    strlcat(sc->tulip_boardid, "9332BDT ", sizeof(sc->tulip_boardid));
	return;
    }
    id1 = sc->tulip_rombuf[0x60] | (sc->tulip_rombuf[0x61] << 8);
    id2 = sc->tulip_rombuf[0x62] | (sc->tulip_rombuf[0x63] << 8);
    ei  = sc->tulip_rombuf[0x66] | (sc->tulip_rombuf[0x67] << 8);

    strlcat(sc->tulip_boardid, "8432", sizeof(sc->tulip_boardid));
    cp = &sc->tulip_boardid[8];
    if ((id1 & 1) == 0)
	*cp++ = 'B', auibnc = 1;
    if ((id1 & 0xFF) > 0x32)
	*cp++ = 'T', utp = 1;
    if ((id1 & 0x4000) == 0)
	*cp++ = 'A', auibnc = 1;
    if (id2 == 0x15) {
	sc->tulip_boardid[7] = '4';
	*cp++ = '-';
	*cp++ = 'C';
	*cp++ = 'H';
	*cp++ = (ei ? '2' : '1');
    }
    *cp++ = ' ';
    *cp = '\0';
    if (utp && !auibnc)
	sc->tulip_boardsw = &tulip_21040_10baset_only_boardsw;
    else if (!utp && auibnc)
	sc->tulip_boardsw = &tulip_21040_auibnc_only_boardsw;
}

void
tulip_identify_cogent_nic(tulip_softc_t * const sc)
{
    strlcpy(sc->tulip_boardid, "Cogent ", sizeof(sc->tulip_boardid));
    if (sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A) {
	if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100TX_ID) {
	    strlcat(sc->tulip_boardid, "EM100TX ", sizeof(sc->tulip_boardid));
	    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;
#if defined(TULIP_COGENT_EM110TX_ID)
	} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM110TX_ID) {
	    strlcat(sc->tulip_boardid, "EM110TX ", sizeof(sc->tulip_boardid));
	    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;
#endif
	} else if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100FX_ID) {
	    strlcat(sc->tulip_boardid, "EM100FX ", sizeof(sc->tulip_boardid));
	    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;
	}
	/*
	 * Magic number (0x24001109U) is the SubVendor (0x2400) and
	 * SubDevId (0x1109) for the ANA6944TX (EM440TX).
	 */
	if (*(u_int32_t *) sc->tulip_rombuf == 0x24001109U
		&& (sc->tulip_features & TULIP_HAVE_BASEROM)) {
	    /*
	     * Cogent (Adaptec) is still mapping all INTs to INTA of
	     * first 21140.  Dumb!  Dumb!
	     */
	    strlcat(sc->tulip_boardid, "EM440TX ", sizeof(sc->tulip_boardid));
	    sc->tulip_features |= TULIP_HAVE_SHAREDINTR;
	}
    } else if (sc->tulip_chipid == TULIP_21040)
	sc->tulip_features |= TULIP_HAVE_SHAREDINTR|TULIP_HAVE_BASEROM;
}

void
tulip_identify_accton_nic(tulip_softc_t * const sc)
{
    strlcpy(sc->tulip_boardid, "ACCTON ", sizeof(sc->tulip_boardid));
    switch (sc->tulip_chipid) {
	case TULIP_21140A:
	    strlcat(sc->tulip_boardid, "EN1207 ", sizeof(sc->tulip_boardid));
	    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)
		sc->tulip_boardsw = &tulip_21140_accton_boardsw;
	    break;
	case TULIP_21140:
	    strlcat(sc->tulip_boardid, "EN1207TX ", sizeof(sc->tulip_boardid));
	    if (sc->tulip_boardsw != &tulip_2114x_isv_boardsw)
		sc->tulip_boardsw = &tulip_21140_eb_boardsw;
            break;
        case TULIP_21040:
	    strlcat(sc->tulip_boardid, "EN1203 ", sizeof(sc->tulip_boardid));
            sc->tulip_boardsw = &tulip_21040_boardsw;
            break;
        case TULIP_21041:
	    strlcat(sc->tulip_boardid, "EN1203 ", sizeof(sc->tulip_boardid));
            sc->tulip_boardsw = &tulip_21041_boardsw;
            break;
	default:
            sc->tulip_boardsw = &tulip_2114x_isv_boardsw;
            break;
    }
}

void
tulip_identify_asante_nic(tulip_softc_t * const sc)
{
    strlcpy(sc->tulip_boardid, "Asante ", sizeof(sc->tulip_boardid));
    if ((sc->tulip_chipid == TULIP_21140 || sc->tulip_chipid == TULIP_21140A)
	    && sc->tulip_boardsw != &tulip_2114x_isv_boardsw) {
	tulip_media_info_t *mi = sc->tulip_mediainfo;
	int idx;
	/*
	 * The Asante Fast Ethernet doesn't always ship with a valid
	 * new format SROM.  So if isn't in the new format, we cheat
	 * set it up as if we had.
	 */

	sc->tulip_gpinit = TULIP_GP_ASANTE_PINS;
	sc->tulip_gpdata = 0;

	TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PINS|TULIP_GP_PINSET);
	TULIP_CSR_WRITE(sc, csr_gp, TULIP_GP_ASANTE_PHYRESET);
	DELAY(100);
	TULIP_CSR_WRITE(sc, csr_gp, 0);

	mi->mi_type = TULIP_MEDIAINFO_MII;
	mi->mi_gpr_length = 0;
	mi->mi_gpr_offset = 0;
	mi->mi_reset_length = 0;
	mi->mi_reset_offset = 0;

	mi->mi_phyaddr = TULIP_MII_NOPHY;
	for (idx = 20; idx > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx--) {
	    DELAY(10000);
	    mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, 0);
	}
	if (mi->mi_phyaddr == TULIP_MII_NOPHY) {
#ifdef TULIP_DEBUG
	    printf(TULIP_PRINTF_FMT ": can't find phy 0\n", TULIP_PRINTF_ARGS);
#endif
	    return;
	}

	sc->tulip_features |= TULIP_HAVE_MII;
	mi->mi_capabilities  = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;
	mi->mi_advertisement = PHYSTS_10BASET|PHYSTS_10BASET_FD|PHYSTS_100BASETX|PHYSTS_100BASETX_FD;
	mi->mi_full_duplex   = PHYSTS_10BASET_FD|PHYSTS_100BASETX_FD;
	mi->mi_tx_threshold  = PHYSTS_10BASET|PHYSTS_10BASET_FD;
	TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);
	TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);
	TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);
	TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);
	TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);
	mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |
	    tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);

	sc->tulip_boardsw = &tulip_2114x_isv_boardsw;
    }
}

void
tulip_identify_compex_nic(tulip_softc_t * const sc)
{
    strlcpy(sc->tulip_boardid, "COMPEX ", sizeof(sc->tulip_boardid));
    if (sc->tulip_chipid == TULIP_21140A) {
	int root_unit;
	tulip_softc_t *root_sc = NULL;

	strlcat(sc->tulip_boardid, "400TX/PCI ", sizeof(sc->tulip_boardid));
	/*
	 * All 4 chips on these boards share an interrupt.  This code
	 * copied from tulip_read_macaddr.
	 */
	sc->tulip_features |= TULIP_HAVE_SHAREDINTR;
	for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {
	    root_sc = TULIP_UNIT_TO_SOFTC(root_unit);
	    if (root_sc == NULL
		|| !(root_sc->tulip_features & TULIP_HAVE_SLAVEDINTR))
		break;
	    root_sc = NULL;
	}
	if (root_sc != NULL
	    && root_sc->tulip_chipid == sc->tulip_chipid
	    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {
	    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;
	    sc->tulip_slaves = root_sc->tulip_slaves;
	    root_sc->tulip_slaves = sc;
	} else if(sc->tulip_features & TULIP_HAVE_SLAVEDINTR)
	    printf("\nCannot find master device for de%d interrupts", sc->tulip_unit);
    } else
	strlcat(sc->tulip_boardid, "unknown ", sizeof(sc->tulip_boardid));

    /*      sc->tulip_boardsw = &tulip_21140_eb_boardsw; */
}

int
tulip_srom_decode(tulip_softc_t * const sc)
{
    unsigned idx1, idx2, idx3;

    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];
    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);
    tulip_srom_media_t srom_media;
    tulip_media_info_t *mi = sc->tulip_mediainfo;
    const u_int8_t *dp;
    u_int32_t leaf_offset, blocks, data;

    for (idx1 = 0; idx1 < shp->sh_adapter_count; idx1++, saip++) {
	if (shp->sh_adapter_count == 1)
	    break;
	if (saip->sai_device == sc->tulip_pci_devno)
	    break;
    }
    /*
     * Didn't find the right media block for this card.
     */
    if (idx1 == shp->sh_adapter_count)
	return (0);

    /*
     * Save the hardware address.
     */
    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr,
       ETHER_ADDR_LEN);
    /*
     * If this is a multiple port card, add the adapter index to the last
     * byte of the hardware address.  (if it isn't multiport, adding 0
     * won't hurt.
     */
    sc->tulip_enaddr[5] += idx1;

    leaf_offset = saip->sai_leaf_offset_lowbyte
	+ saip->sai_leaf_offset_highbyte * 256;
    dp = sc->tulip_rombuf + leaf_offset;

    sc->tulip_conntype = (tulip_srom_connection_t) (dp[0] + dp[1] * 256); dp += 2;

    for (idx2 = 0;; idx2++) {
	if (tulip_srom_conninfo[idx2].sc_type == sc->tulip_conntype
	        || tulip_srom_conninfo[idx2].sc_type == TULIP_SROM_CONNTYPE_NOT_USED)
	    break;
    }
    sc->tulip_connidx = idx2;

    if (sc->tulip_chipid == TULIP_21041) {
	blocks = *dp++;
	for (idx2 = 0; idx2 < blocks; idx2++) {
	    tulip_media_t media;
	    data = *dp++;
	    srom_media = (tulip_srom_media_t) (data & 0x3F);
	    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {
		if (tulip_srom_mediums[idx3].sm_srom_type == srom_media)
		    break;
	    }
	    media = tulip_srom_mediums[idx3].sm_type;
	    if (media != TULIP_MEDIA_UNKNOWN) {
		if (data & TULIP_SROM_21041_EXTENDED) {
		    mi->mi_type = TULIP_MEDIAINFO_SIA;
		    sc->tulip_mediums[media] = mi;
		    mi->mi_sia_connectivity = dp[0] + dp[1] * 256;
		    mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;
		    mi->mi_sia_general      = dp[4] + dp[5] * 256;
		    mi++;
		} else {
		    switch (media) {
			case TULIP_MEDIA_BNC: {
			    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC);
			    mi++;
			    break;
			}
			case TULIP_MEDIA_AUI: {
			    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI);
			    mi++;
			    break;
			}
			case TULIP_MEDIA_10BASET: {
			    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET);
			    mi++;
			    break;
			}
			case TULIP_MEDIA_10BASET_FD: {
			    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD);
			    mi++;
			    break;
			}
			default: {
			    break;
			}
		    }
		}
	    }
	    if (data & TULIP_SROM_21041_EXTENDED)
		dp += 6;
	}
    } else {
	unsigned length, type;
	tulip_media_t gp_media = TULIP_MEDIA_UNKNOWN;
	if (sc->tulip_features & TULIP_HAVE_GPR)
	    sc->tulip_gpinit = *dp++;
	blocks = *dp++;
	for (idx2 = 0; idx2 < blocks; idx2++) {
	    const u_int8_t *ep;
	    if ((*dp & 0x80) == 0) {
		length = 4;
		type = 0;
	    } else {
		length = (*dp++ & 0x7f) - 1;
		type = *dp++ & 0x3f;
	    }
	    ep = dp + length;
	    switch (type & 0x3f) {
		case 0: {	/* 21140[A] GPR block */
		    tulip_media_t media;
		    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);
		    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {
			if (tulip_srom_mediums[idx3].sm_srom_type == srom_media)
			    break;
		    }
		    media = tulip_srom_mediums[idx3].sm_type;
		    if (media == TULIP_MEDIA_UNKNOWN)
			break;
		    mi->mi_type = TULIP_MEDIAINFO_GPR;
		    sc->tulip_mediums[media] = mi;
		    mi->mi_gpdata = dp[1];
		    if (media > gp_media && !TULIP_IS_MEDIA_FD(media)) {
			sc->tulip_gpdata = mi->mi_gpdata;
			gp_media = media;
		    }
		    data = dp[2] + dp[3] * 256;
		    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);
		    if (data & TULIP_SROM_2114X_NOINDICATOR)
			mi->mi_actmask = 0;
		    else {
			mi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);
			mi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;
		    }
		    mi++;
		    break;
		}
		case 1: {	/* 21140[A] MII block */
		    const unsigned phyno = *dp++;
		    mi->mi_type = TULIP_MEDIAINFO_MII;
		    mi->mi_gpr_length = *dp++;
		    mi->mi_gpr_offset = dp - sc->tulip_rombuf;
		    dp += mi->mi_gpr_length;
		    mi->mi_reset_length = *dp++;
		    mi->mi_reset_offset = dp - sc->tulip_rombuf;
		    dp += mi->mi_reset_length;

		    /*
		     * Before we probe for a PHY, use the GPR information
		     * to select it.  If we don't, it may be inaccessible.
		     */
		    TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_gpinit|TULIP_GP_PINSET);
		    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++) {
			DELAY(10);
			TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_reset_offset + idx3]);
		    }
		    sc->tulip_phyaddr = mi->mi_phyaddr;
		    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++) {
			DELAY(10);
			TULIP_CSR_WRITE(sc, csr_gp, sc->tulip_rombuf[mi->mi_gpr_offset + idx3]);
		    }

		    /*
		     * At least write something!
		     */
		    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)
			TULIP_CSR_WRITE(sc, csr_gp, 0);

		    mi->mi_phyaddr = TULIP_MII_NOPHY;
		    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {
			DELAY(10000);
			mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);
		    }
		    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {
#if defined(TULIP_DEBUG)
			printf(TULIP_PRINTF_FMT ": can't find phy %d\n",
			       TULIP_PRINTF_ARGS, phyno);
#endif
			break;
		    }
		    sc->tulip_features |= TULIP_HAVE_MII;
		    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);
		    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |
			tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);
		    mi++;
		    break;
		}
		case 2: {	/* 2114[23] SIA block */
		    tulip_media_t media;
		    srom_media = (tulip_srom_media_t)(dp[0] & 0x3f);
		    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {
			if (tulip_srom_mediums[idx3].sm_srom_type == srom_media)
			    break;
		    }
		    media = tulip_srom_mediums[idx3].sm_type;
		    if (media == TULIP_MEDIA_UNKNOWN)
			break;
		    mi->mi_type = TULIP_MEDIAINFO_SIA;
		    sc->tulip_mediums[media] = mi;
		    if (dp[0] & 0x40) {
			mi->mi_sia_connectivity = dp[1] + dp[2] * 256;
			mi->mi_sia_tx_rx        = dp[3] + dp[4] * 256;
			mi->mi_sia_general      = dp[5] + dp[6] * 256;
			dp += 6;
		    } else {
			switch (media) {
			    case TULIP_MEDIA_BNC: {
				TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, BNC);
				break;
			    }
			    case TULIP_MEDIA_AUI: {
				TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, AUI);
				break;
			    }
			    case TULIP_MEDIA_10BASET: {
				TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET);
				sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
				break;
			    }
			    case TULIP_MEDIA_10BASET_FD: {
				TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21142, 10BASET_FD);
				sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
				break;
			    }
			    default: {
				goto bad_media;
			    }
			}
		    }
		    mi->mi_sia_gp_control = (dp[1] + dp[2] * 256) << 16;
		    mi->mi_sia_gp_data    = (dp[3] + dp[4] * 256) << 16;
		    mi++;
		  bad_media:
		    break;
		}
		case 3: {	/* 2114[23] MII PHY block */
		    const unsigned phyno = *dp++;
		    const u_int8_t *dp0;
		    mi->mi_type = TULIP_MEDIAINFO_MII;
		    mi->mi_gpr_length = *dp++;
		    mi->mi_gpr_offset = dp - sc->tulip_rombuf;
		    dp += 2 * mi->mi_gpr_length;
		    mi->mi_reset_length = *dp++;
		    mi->mi_reset_offset = dp - sc->tulip_rombuf;
		    dp += 2 * mi->mi_reset_length;

		    dp0 = &sc->tulip_rombuf[mi->mi_reset_offset];
		    for (idx3 = 0; idx3 < mi->mi_reset_length; idx3++, dp0 += 2) {
			DELAY(10);
			TULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);
		    }
		    sc->tulip_phyaddr = mi->mi_phyaddr;
		    dp0 = &sc->tulip_rombuf[mi->mi_gpr_offset];
		    for (idx3 = 0; idx3 < mi->mi_gpr_length; idx3++, dp0 += 2) {
			DELAY(10);
			TULIP_CSR_WRITE(sc, csr_sia_general, (dp0[0] + 256 * dp0[1]) << 16);
		    }

		    if (mi->mi_reset_length == 0 && mi->mi_gpr_length == 0)
			TULIP_CSR_WRITE(sc, csr_sia_general, 0);

		    mi->mi_phyaddr = TULIP_MII_NOPHY;
		    for (idx3 = 20; idx3 > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx3--) {
			DELAY(10000);
			mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, phyno);
		    }
		    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {
#if defined(TULIP_DEBUG)
			printf(TULIP_PRINTF_FMT ": can't find phy %d\n",
			       TULIP_PRINTF_ARGS, phyno);
#endif
			break;
		    }
		    sc->tulip_features |= TULIP_HAVE_MII;
		    mi->mi_capabilities  = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_advertisement = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_full_duplex   = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_tx_threshold  = dp[0] + dp[1] * 256; dp += 2;
		    mi->mi_mii_interrupt = dp[0] + dp[1] * 256; dp += 2;
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASET4);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);
		    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);
		    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |
			tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);
		    mi++;
		    break;
		}
		case 4: {	/* 21143 SYM block */
		    tulip_media_t media;
		    srom_media = (tulip_srom_media_t) dp[0];
		    for (idx3 = 0; tulip_srom_mediums[idx3].sm_type != TULIP_MEDIA_UNKNOWN; idx3++) {
			if (tulip_srom_mediums[idx3].sm_srom_type == srom_media)
			    break;
		    }
		    media = tulip_srom_mediums[idx3].sm_type;
		    if (media == TULIP_MEDIA_UNKNOWN)
			break;
		    mi->mi_type = TULIP_MEDIAINFO_SYM;
		    sc->tulip_mediums[media] = mi;
		    mi->mi_gpcontrol = (dp[1] + dp[2] * 256) << 16;
		    mi->mi_gpdata    = (dp[3] + dp[4] * 256) << 16;
		    data = dp[5] + dp[6] * 256;
		    mi->mi_cmdmode = TULIP_SROM_2114X_CMDBITS(data);
		    if (data & TULIP_SROM_2114X_NOINDICATOR)
			mi->mi_actmask = 0;
		    else {
			mi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;
			mi->mi_actmask = TULIP_SROM_2114X_BITPOS(data);
			mi->mi_actdata = (data & TULIP_SROM_2114X_POLARITY) ? 0 : mi->mi_actmask;
		    }
		    if (TULIP_IS_MEDIA_TP(media))
			sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
		    mi++;
		    break;
		}
		default: {
		}
	    }
	    dp = ep;
	}
    }
    return (mi - sc->tulip_mediainfo);
}

static const struct {
    void (*vendor_identify_nic)(tulip_softc_t * const sc);
    unsigned char vendor_oui[3];
} tulip_vendors[] = {
    { tulip_identify_dec_nic,		{ 0x08, 0x00, 0x2B } },
    { tulip_identify_dec_nic,		{ 0x00, 0x00, 0xF8 } },
    { tulip_identify_smc_nic,		{ 0x00, 0x00, 0xC0 } },
    { tulip_identify_smc_nic,		{ 0x00, 0xE0, 0x29 } },
    { tulip_identify_znyx_nic,		{ 0x00, 0xC0, 0x95 } },
    { tulip_identify_cogent_nic,	{ 0x00, 0x00, 0x92 } },
    { tulip_identify_cogent_nic,	{ 0x00, 0x00, 0xD1 } },
    { tulip_identify_asante_nic,	{ 0x00, 0x00, 0x94 } },
    { tulip_identify_accton_nic,	{ 0x00, 0x00, 0xE8 } },
    { tulip_identify_compex_nic,	{ 0x00, 0x80, 0x48 } },
    { NULL }
};

/*
 * This deals with the vagaries of the address roms and the
 * brain-deadness that various vendors commit in using them.
 */
int
tulip_read_macaddr(tulip_softc_t * const sc)
{
    unsigned cksum, rom_cksum, idx;
    u_int32_t csr;
    unsigned char tmpbuf[8];
    static const u_char testpat[] = { 0xFF, 0, 0x55, 0xAA, 0xFF, 0, 0x55, 0xAA };

    sc->tulip_connidx = TULIP_SROM_LASTCONNIDX;

    if (sc->tulip_chipid == TULIP_21040) {
	TULIP_CSR_WRITE(sc, csr_enetrom, 1);
	for (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {
	    int cnt = 0;
	    while (((csr = TULIP_CSR_READ(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)
		cnt++;
	    sc->tulip_rombuf[idx] = csr & 0xFF;
	}
	sc->tulip_boardsw = &tulip_21040_boardsw;
    } else {
	if (sc->tulip_chipid == TULIP_21041) {
	    /*
	     * Thankfully all 21041's act the same.
	     */
	    sc->tulip_boardsw = &tulip_21041_boardsw;
	} else {
	    /*
	     * Assume all 21140 board are compatible with the
	     * DEC 10/100 evaluation board.  Not really valid but
	     * it's the best we can do until every one switches to
	     * the new SROM format.
	     */

	    sc->tulip_boardsw = &tulip_21140_eb_boardsw;
	}
	tulip_srom_read(sc);
	if (tulip_srom_crcok(sc->tulip_rombuf)) {
	    /*
	     * SROM CRC is valid therefore it must be in the
	     * new format.
	     */
	    sc->tulip_features |= TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM;
	} else if (sc->tulip_rombuf[126] == 0xff && sc->tulip_rombuf[127] == 0xFF) {
	    /*
	     * No checksum is present.  See if the SROM id checks out;
	     * the first 18 bytes should be 0 followed by a 1 followed
	     * by the number of adapters (which we don't deal with yet).
	     */
	    for (idx = 0; idx < 18; idx++) {
		if (sc->tulip_rombuf[idx] != 0)
		    break;
	    }
	    if (idx == 18 && sc->tulip_rombuf[18] == 1 && sc->tulip_rombuf[19] != 0)
		sc->tulip_features |= TULIP_HAVE_ISVSROM;
	} else if (sc->tulip_chipid >= TULIP_21142) {
	    sc->tulip_features |= TULIP_HAVE_ISVSROM;
	    sc->tulip_boardsw = &tulip_2114x_isv_boardsw;
	}
	if ((sc->tulip_features & TULIP_HAVE_ISVSROM) && tulip_srom_decode(sc)) {
	    if (sc->tulip_chipid != TULIP_21041)
		sc->tulip_boardsw = &tulip_2114x_isv_boardsw;

	    /*
	     * If the SROM specifies more than one adapter, tag this as a
	     * BASE rom.
	     */
	    if (sc->tulip_rombuf[19] > 1)
		sc->tulip_features |= TULIP_HAVE_BASEROM;
	    if (sc->tulip_boardsw == NULL)
		return (-6);
	    goto check_oui;
	}
    }

    if (bcmp(&sc->tulip_rombuf[0], &sc->tulip_rombuf[16], 8) != 0) {
	/*
	 * Some folks don't use the standard ethernet rom format
	 * but instead just put the address in the first 6 bytes
	 * of the rom and let the rest be all 0xffs.  (Can we say
	 * ZNYX???) (well sometimes they put in a checksum so we'll
	 * start at 8).
	 */
	for (idx = 8; idx < 32; idx++) {
	    if (sc->tulip_rombuf[idx] != 0xFF)
		return (-4);
	}
	/*
	 * Make sure the address is not multicast or locally assigned
	 * that the OUI is not 00-00-00.
	 */
	if ((sc->tulip_rombuf[0] & 3) != 0)
	    return (-4);
	if (sc->tulip_rombuf[0] == 0 && sc->tulip_rombuf[1] == 0
		&& sc->tulip_rombuf[2] == 0)
	    return (-4);
	bcopy(sc->tulip_rombuf, sc->tulip_enaddr, ETHER_ADDR_LEN);
	sc->tulip_features |= TULIP_HAVE_OKROM;
	goto check_oui;
    } else {
	/*
	 * A number of makers of multiport boards (ZNYX and Cogent)
	 * only put on one address ROM on their 21040 boards.  So
	 * if the ROM is all zeros (or all 0xFFs), look at the
	 * previous configured boards (as long as they are on the same
	 * PCI bus and the bus number is non-zero) until we find the
	 * master board with address ROM.  We then use its address ROM
	 * as the base for this board.  (we add our relative board
	 * to the last byte of its address).
	 */
	for (idx = 0; idx < sizeof(sc->tulip_rombuf); idx++) {
	    if (sc->tulip_rombuf[idx] != 0 && sc->tulip_rombuf[idx] != 0xFF)
		break;
	}
	if (idx == sizeof(sc->tulip_rombuf)) {
	    int root_unit;
	    tulip_softc_t *root_sc = NULL;
	    for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {
		root_sc = TULIP_UNIT_TO_SOFTC(root_unit);
		if (root_sc == NULL || (root_sc->tulip_features & (TULIP_HAVE_OKROM|TULIP_HAVE_SLAVEDROM)) == TULIP_HAVE_OKROM)
		    break;
		root_sc = NULL;
	    }
	    if (root_sc != NULL && (root_sc->tulip_features & TULIP_HAVE_BASEROM)
		    && root_sc->tulip_chipid == sc->tulip_chipid
		    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {
		sc->tulip_features |= TULIP_HAVE_SLAVEDROM;
		sc->tulip_boardsw = root_sc->tulip_boardsw;
		strlcpy(sc->tulip_boardid, root_sc->tulip_boardid,
		    sizeof(sc->tulip_boardid));
		if (sc->tulip_boardsw->bd_type == TULIP_21140_ISV) {
		    bcopy(root_sc->tulip_rombuf, sc->tulip_rombuf,
			  sizeof(sc->tulip_rombuf));
		    if (!tulip_srom_decode(sc))
			return (-5);
		} else {
		    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr,
		       ETHER_ADDR_LEN);
		    sc->tulip_enaddr[5] += sc->tulip_unit - root_sc->tulip_unit;
		}
		/*
		 * Now for a truly disgusting kludge: all 4 21040s on
		 * the ZX314 share the same INTA line so the mapping
		 * setup by the BIOS on the PCI bridge is worthless.
		 * Rather than reprogramming the value in the config
		 * register, we will handle this internally.
		 */
		if (root_sc->tulip_features & TULIP_HAVE_SHAREDINTR) {
		    sc->tulip_slaves = root_sc->tulip_slaves;
		    root_sc->tulip_slaves = sc;
		    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;
		}
		return (0);
	    }
	}
    }

    /*
     * This is the standard DEC address ROM test.
     */

    if (bcmp(&sc->tulip_rombuf[24], testpat, 8) != 0)
	return (-3);

    tmpbuf[0] = sc->tulip_rombuf[15]; tmpbuf[1] = sc->tulip_rombuf[14];
    tmpbuf[2] = sc->tulip_rombuf[13]; tmpbuf[3] = sc->tulip_rombuf[12];
    tmpbuf[4] = sc->tulip_rombuf[11]; tmpbuf[5] = sc->tulip_rombuf[10];
    tmpbuf[6] = sc->tulip_rombuf[9];  tmpbuf[7] = sc->tulip_rombuf[8];
    if (bcmp(&sc->tulip_rombuf[0], tmpbuf, 8) != 0)
	return (-2);

    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, ETHER_ADDR_LEN);

    cksum = *(u_int16_t *) &sc->tulip_enaddr[0];
    cksum *= 2;
    if (cksum > 65535) cksum -= 65535;
    cksum += *(u_int16_t *) &sc->tulip_enaddr[2];
    if (cksum > 65535) cksum -= 65535;
    cksum *= 2;
    if (cksum > 65535) cksum -= 65535;
    cksum += *(u_int16_t *) &sc->tulip_enaddr[4];
    if (cksum >= 65535) cksum -= 65535;

    rom_cksum = *(u_int16_t *) &sc->tulip_rombuf[6];

    if (cksum != rom_cksum)
	return (-1);

  check_oui:
    /*
     * Check for various boards based on OUI.  Did I say braindead?
     */
    for (idx = 0; tulip_vendors[idx].vendor_identify_nic != NULL; idx++) {
	if (bcmp((caddr_t) sc->tulip_enaddr,
		 (caddr_t) tulip_vendors[idx].vendor_oui, 3) == 0) {
	    (*tulip_vendors[idx].vendor_identify_nic)(sc);
	    break;
	}
    }

    sc->tulip_features |= TULIP_HAVE_OKROM;
    return (0);
}

void
tulip_ifmedia_add(tulip_softc_t * const sc)
{
    tulip_media_t media;
    int medias = 0;

    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
	if (sc->tulip_mediums[media] != NULL) {
	    ifmedia_add(&sc->tulip_ifmedia, tulip_media_to_ifmedia[media],
			0, 0);
	    medias++;
	}
    }
    if (medias == 0) {
	sc->tulip_features |= TULIP_HAVE_NOMEDIA;
	ifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE, 0, 0);
	ifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_NONE);
    } else if (sc->tulip_media == TULIP_MEDIA_UNKNOWN) {
	ifmedia_add(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO, 0, 0);
	ifmedia_set(&sc->tulip_ifmedia, IFM_ETHER | IFM_AUTO);
    } else {
	ifmedia_set(&sc->tulip_ifmedia, tulip_media_to_ifmedia[sc->tulip_media]);
	sc->tulip_flags |= TULIP_PRINTMEDIA;
	tulip_linkup(sc, sc->tulip_media);
    }
}

int
tulip_ifmedia_change(struct ifnet * const ifp)
{
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);

    sc->tulip_flags |= TULIP_NEEDRESET;
    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
    if (IFM_SUBTYPE(sc->tulip_ifmedia.ifm_media) != IFM_AUTO) {
	tulip_media_t media;
	for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
	    if (sc->tulip_mediums[media] != NULL
		&& sc->tulip_ifmedia.ifm_media == tulip_media_to_ifmedia[media]) {
		sc->tulip_flags |= TULIP_PRINTMEDIA;
		sc->tulip_flags &= ~TULIP_DIDNWAY;
		tulip_linkup(sc, media);
		return (0);
	    }
	}
    }
    sc->tulip_flags &= ~(TULIP_TXPROBE_ACTIVE|TULIP_WANTRXACT);
    tulip_reset(sc);
    tulip_init(sc);
    return (0);
}

/*
 * Media status callback
 */
void
tulip_ifmedia_status(struct ifnet * const ifp, struct ifmediareq *req)
{
    tulip_softc_t *sc = TULIP_IFP_TO_SOFTC(ifp);

    if (sc->tulip_media == TULIP_MEDIA_UNKNOWN)
	return;

    req->ifm_status = IFM_AVALID;
    if (sc->tulip_flags & TULIP_LINKUP)
	req->ifm_status |= IFM_ACTIVE;

    req->ifm_active = tulip_media_to_ifmedia[sc->tulip_media];
}

bus_dmamap_t
tulip_alloc_rxmap(tulip_softc_t *sc)
{
	return (sc->tulip_free_rxmaps[--sc->tulip_num_free_rxmaps]);
}

void
tulip_free_rxmap(tulip_softc_t *sc, bus_dmamap_t map)
{
	sc->tulip_free_rxmaps[sc->tulip_num_free_rxmaps++] = map;
}

bus_dmamap_t
tulip_alloc_txmap(tulip_softc_t *sc)
{
	return (sc->tulip_free_txmaps[--sc->tulip_num_free_txmaps]);
}

void
tulip_free_txmap(tulip_softc_t *sc, bus_dmamap_t map)
{
	sc->tulip_free_txmaps[sc->tulip_num_free_txmaps++] = map;
}

void
tulip_addr_filter(tulip_softc_t * const sc)
{
    struct arpcom *ac = &sc->tulip_ac;
    struct ether_multistep step;
    struct ether_multi *enm;

    sc->tulip_flags &= ~(TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY|TULIP_ALLMULTI);
    sc->tulip_flags |= TULIP_WANTSETUP|TULIP_WANTTXSTART;
    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;
    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;
    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;
    if (sc->tulip_multicnt > 14) {
	u_int32_t *sp = sc->tulip_setupdata;
	unsigned hash;
	/*
	 * Some early passes of the 21140 have broken implementations of
	 * hash-perfect mode.  When we get too many multicasts for perfect
	 * filtering with these chips, we need to switch into hash-only
	 * mode (this is better than all-multicast on network with lots
	 * of multicast traffic).
	 */
	if (sc->tulip_features & TULIP_HAVE_BROKEN_HASH)
	    sc->tulip_flags |= TULIP_WANTHASHONLY;
	else
	    sc->tulip_flags |= TULIP_WANTHASHPERFECT;
	/*
	 * If we have more than 14 multicasts, we have
	 * go into hash perfect mode (512 bit multicast
	 * hash and one perfect hardware).
	 */
	bzero(sc->tulip_setupdata, sizeof(sc->tulip_setupdata));
	if (ac->ac_multirangecnt > 0) {
	    sc->tulip_flags |= TULIP_ALLMULTI;
	    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);
	} else {
	    ETHER_FIRST_MULTI(step, ac, enm);
	    while (enm != NULL) {
		    hash = tulip_mchash(enm->enm_addrlo);
#if BYTE_ORDER == BIG_ENDIAN
		    sp[hash >> 4] |= swap32(1 << (hash & 0xF));
#else
		    sp[hash >> 4] |= 1 << (hash & 0xF);
#endif
		ETHER_NEXT_MULTI(step, enm);
	    }
	}
	/*
	 * No reason to use a hash if we are going to be
	 * receiving every multicast.
	 */
	if ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {
	    hash = tulip_mchash(etherbroadcastaddr);
#if BYTE_ORDER == BIG_ENDIAN
	    sp[hash >> 4] |= swap32(1 << (hash & 0xF));
#else
	    sp[hash >> 4] |= 1 << (hash & 0xF);
#endif
	    if (sc->tulip_flags & TULIP_WANTHASHONLY) {
		hash = tulip_mchash(sc->tulip_enaddr);
#if BYTE_ORDER == BIG_ENDIAN
		sp[hash >> 4] |= swap32(1 << (hash & 0xF));
#else
		sp[hash >> 4] |= 1 << (hash & 0xF);
#endif
	    } else {
#if BYTE_ORDER == BIG_ENDIAN
		sp[39] = ((u_int16_t *) sc->tulip_enaddr)[0] << 16;
		sp[40] = ((u_int16_t *) sc->tulip_enaddr)[1] << 16;
		sp[41] = ((u_int16_t *) sc->tulip_enaddr)[2] << 16;
#else
		sp[39] = ((u_int16_t *) sc->tulip_enaddr)[0];
		sp[40] = ((u_int16_t *) sc->tulip_enaddr)[1];
		sp[41] = ((u_int16_t *) sc->tulip_enaddr)[2];
#endif
	    }
	}
    }
    if ((sc->tulip_flags & (TULIP_WANTHASHPERFECT|TULIP_WANTHASHONLY)) == 0) {
	u_int32_t *sp = sc->tulip_setupdata;
	int idx = 0;
	if (ac->ac_multirangecnt > 0)
		sc->tulip_flags |= TULIP_ALLMULTI;

	if ((sc->tulip_flags & TULIP_ALLMULTI) == 0) {
	    /*
	     * Else can get perfect filtering for 16 addresses.
	     */
	    ETHER_FIRST_MULTI(step, ac, enm);
	    for (; enm != NULL; idx++) {
#if BYTE_ORDER == BIG_ENDIAN
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[0] << 16;
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[1] << 16;
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[2] << 16;
#else
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[0];
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[1];
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[2];
#endif
		ETHER_NEXT_MULTI(step, enm);
	    }
	    /*
	     * Add the broadcast address.
	     */
	    idx++;
#if BYTE_ORDER == BIG_ENDIAN
	    *sp++ = 0xFFFF << 16;
	    *sp++ = 0xFFFF << 16;
	    *sp++ = 0xFFFF << 16;
#else
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
#endif
	}
	/*
	 * Pad the rest with our hardware address
	 */
	for (; idx < 16; idx++) {
#if BYTE_ORDER == BIG_ENDIAN
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[0] << 16;
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[1] << 16;
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[2] << 16;
#else
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[0];
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[1];
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[2];
#endif
	}
    }
    if (sc->tulip_flags & TULIP_ALLMULTI)
	sc->tulip_if.if_flags |= IFF_ALLMULTI;
}

void
tulip_reset(tulip_softc_t * const sc)
{
    tulip_ringinfo_t *ri;
    tulip_desc_t *di;
    u_int32_t inreset = (sc->tulip_flags & TULIP_INRESET);

    /*
     * Brilliant.  Simply brilliant.  When switching modes/speeds
     * on a 2114*, you need to set the appriopriate MII/PCS/SCL/PS
     * bits in CSR6 and then do a software reset to get the 21140
     * to properly reset its internal pathways to the right places.
     *   Grrrr.
     */
    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0
	    && sc->tulip_boardsw->bd_media_preset != NULL)
	(*sc->tulip_boardsw->bd_media_preset)(sc);

    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
		   33MHz that comes to two microseconds but wait a
		   bit longer anyways) */

    if (!inreset) {
	sc->tulip_flags |= TULIP_INRESET;
	sc->tulip_flags &= ~(TULIP_NEEDRESET|TULIP_RXBUFSLOW);
	ifq_clr_oactive(&sc->tulip_if.if_snd);
    }

    TULIP_CSR_WRITE(sc, csr_txlist, sc->tulip_txdescmap->dm_segs[0].ds_addr);
    TULIP_CSR_WRITE(sc, csr_rxlist, sc->tulip_rxdescmap->dm_segs[0].ds_addr);
    TULIP_CSR_WRITE(sc, csr_busmode,
		    (1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))
		    |TULIP_BUSMODE_CACHE_ALIGN8
		    |TULIP_BUSMODE_READMULTIPLE
		    |(BYTE_ORDER != LITTLE_ENDIAN ?
		      TULIP_BUSMODE_DESC_BIGENDIAN : 0));

    sc->tulip_txtimer = 0;
    /*
     * Free all the mbufs that were on the transmit ring.
     */
    for (;;) {
	bus_dmamap_t map;
	struct mbuf *m;
	m = ml_dequeue(&sc->tulip_txq);
	if (m == NULL)
	    break;
	map = TULIP_GETCTX(m, bus_dmamap_t);
	bus_dmamap_unload(sc->tulip_dmatag, map);
	tulip_free_txmap(sc, map);
	m_freem(m);
    }

    ri = &sc->tulip_txinfo;
    ri->ri_nextin = ri->ri_nextout = ri->ri_first;
    ri->ri_free = ri->ri_max;
    for (di = ri->ri_first; di < ri->ri_last; di++)
	di->d_status = 0;
    bus_dmamap_sync(sc->tulip_dmatag, sc->tulip_txdescmap,
		    0, sc->tulip_txdescmap->dm_mapsize,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

    /*
     * We need to collect all the mbufs were on the
     * receive ring before we reinit it either to put
     * them back on or to know if we have to allocate
     * more.
     */
    ri = &sc->tulip_rxinfo;
    ri->ri_nextin = ri->ri_nextout = ri->ri_first;
    ri->ri_free = ri->ri_max;
    for (di = ri->ri_first; di < ri->ri_last; di++) {
	di->d_status = 0;
	di->d_length1 = 0; di->d_addr1 = 0;
	di->d_length2 = 0; di->d_addr2 = 0;
    }
    bus_dmamap_sync(sc->tulip_dmatag, sc->tulip_rxdescmap,
		    0, sc->tulip_rxdescmap->dm_mapsize,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
    for (;;) {
	bus_dmamap_t map;
	struct mbuf *m;
	m = ml_dequeue(&sc->tulip_rxq);
	if (m == NULL)
	    break;
	map = TULIP_GETCTX(m, bus_dmamap_t);
	bus_dmamap_unload(sc->tulip_dmatag, map);
	tulip_free_rxmap(sc, map);
	m_freem(m);
    }

    /*
     * If tulip_reset is being called recurisvely, exit quickly knowing
     * that when the outer tulip_reset returns all the right stuff will
     * have happened.
     */
    if (inreset)
	return;

    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR
	|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED
	|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE
	|TULIP_STS_RXSTOPPED;

    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0)
	(*sc->tulip_boardsw->bd_media_select)(sc);
#if defined(TULIP_DEBUG)
    if ((sc->tulip_flags & TULIP_NEEDRESET) == TULIP_NEEDRESET)
	printf(TULIP_PRINTF_FMT ": tulip_reset: additional reset needed?!?\n",
	       TULIP_PRINTF_ARGS);
#endif
    tulip_media_print(sc);
    if (sc->tulip_features & TULIP_HAVE_DUALSENSE)
	TULIP_CSR_WRITE(sc, csr_sia_status, TULIP_CSR_READ(sc, csr_sia_status));

    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET
			 |TULIP_RXACT);
    tulip_addr_filter(sc);
}

void
tulip_init(tulip_softc_t * const sc)
{
    if (sc->tulip_if.if_flags & IFF_UP) {
	if ((sc->tulip_if.if_flags & IFF_RUNNING) == 0) {
	    /* initialize the media */
	    tulip_reset(sc);
	}
	sc->tulip_if.if_flags |= IFF_RUNNING;
	if (sc->tulip_if.if_flags & IFF_PROMISC) {
	    sc->tulip_flags |= TULIP_PROMISC;
	    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;
	    sc->tulip_intrmask |= TULIP_STS_TXINTR;
	} else {
	    sc->tulip_flags &= ~TULIP_PROMISC;
	    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;
	    if (sc->tulip_flags & TULIP_ALLMULTI)
		sc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;
	    else
		sc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;
	}
	sc->tulip_cmdmode |= TULIP_CMD_TXRUN;
	if ((sc->tulip_flags & (TULIP_TXPROBE_ACTIVE|TULIP_WANTSETUP)) == 0) {
	    tulip_rx_intr(sc);
	    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;
	    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;
	} else {
	    ifq_set_oactive(&sc->tulip_if.if_snd);
	    sc->tulip_cmdmode &= ~TULIP_CMD_RXRUN;
	    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;
	}
	TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
	if ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)
	    tulip_txput_setup(sc);
    } else {
	sc->tulip_if.if_flags &= ~IFF_RUNNING;
	tulip_reset(sc);
    }
}

void
tulip_rx_intr(tulip_softc_t * const sc)
{
    TULIP_PERFSTART(rxintr)
    tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;
    struct ifnet * const ifp = &sc->tulip_if;
    struct mbuf_list ml = MBUF_LIST_INITIALIZER();
    int fillok = 1;
#if defined(TULIP_DEBUG)
    int cnt = 0;
#endif

    for (;;) {
	TULIP_PERFSTART(rxget)
	tulip_desc_t *eop = ri->ri_nextin;
	int total_len = 0, last_offset = 0;
	struct mbuf *ms = NULL, *me = NULL;
	int accept = 0;
	bus_dmamap_t map;
	int error;

	if (fillok && ml_len(&sc->tulip_rxq) < TULIP_RXQ_TARGET)
	    goto queue_mbuf;

#if defined(TULIP_DEBUG)
	if (cnt == ri->ri_max)
	    break;
#endif
	/*
	 * If the TULIP has no descriptors, there can't be any receive
	 * descriptors to process.
	 */
	if (eop == ri->ri_nextout)
	    break;

	/*
	 * 90% of the packets will fit in one descriptor.  So we optimize
	 * for that case.
	 */
	TULIP_RXDESC_POSTSYNC(sc, eop, sizeof(*eop));
	if ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {
#ifdef DIAGNOSTIC
	    if (ml_empty(&sc->tulip_rxq))
		panic("%s: tulip_rxq empty", sc->tulip_if.if_xname);
#endif
	    ms = ml_dequeue(&sc->tulip_rxq);
	    me = ms;
	} else {
	    /*
	     * If still owned by the TULIP, don't touch it.
	     */
	    if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
		break;

	    /*
	     * It is possible (though improbable unless MCLBYTES < 1518) for
	     * a received packet to cross more than one receive descriptor.
	     */
	    while ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {
		if (++eop == ri->ri_last)
		    eop = ri->ri_first;
		TULIP_RXDESC_POSTSYNC(sc, eop, sizeof(*eop));
		if (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {
		    TULIP_PERFEND(rxget);
		    goto out;
		}
		total_len++;
	    }

	    /*
	     * Dequeue the first buffer for the start of the packet.  Hopefully
	     * this will be the only one we need to dequeue.  However, if the
	     * packet consumed multiple descriptors, then we need to dequeue
	     * those buffers and chain to the starting mbuf.  All buffers but
	     * the last buffer have the same length so we can set that now.
	     * (we add to last_offset instead of multiplying since we normally
	     * won't go into the loop and thereby saving a ourselves from
	     * doing a multiplication by 0 in the normal case).
	     */
	    ms = ml_dequeue(&sc->tulip_rxq);
	    for (me = ms; total_len > 0; total_len--) {
		map = TULIP_GETCTX(me, bus_dmamap_t);
		TULIP_RXMAP_POSTSYNC(sc, map);
		bus_dmamap_unload(sc->tulip_dmatag, map);
		tulip_free_rxmap(sc, map);
		me->m_len = TULIP_RX_BUFLEN;
		last_offset += TULIP_RX_BUFLEN;
		me->m_next = ml_dequeue(&sc->tulip_rxq);
		me = me->m_next;
	    }
	}

	/*
	 *  Now get the size of received packet (minus the CRC).
	 */
	total_len = ((eop->d_status >> 16) & 0x7FFF) - 4;
	if ((sc->tulip_flags & TULIP_RXIGNORE) == 0
		&& ((eop->d_status & TULIP_DSTS_ERRSUM) == 0)) {
	    me->m_len = total_len - last_offset;

	    map = TULIP_GETCTX(me, bus_dmamap_t);
	    bus_dmamap_sync(sc->tulip_dmatag, map, 0, me->m_len,
			    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
	    bus_dmamap_unload(sc->tulip_dmatag, map);
	    tulip_free_rxmap(sc, map);
	    sc->tulip_flags |= TULIP_RXACT;
	    accept = 1;
	} else {
	    ifp->if_ierrors++;
	    if (eop->d_status & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxOVERFLOW|TULIP_DSTS_RxWATCHDOG))
		sc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;
	    else {
#ifdef TULIP_DEBUG
		const char *error = NULL;
		if (eop->d_status & TULIP_DSTS_RxTOOLONG) {
		    sc->tulip_dot3stats.dot3StatsFrameTooLongs++;
		    error = "frame too long";
		}
		if (eop->d_status & TULIP_DSTS_RxBADCRC) {
		    if (eop->d_status & TULIP_DSTS_RxDRBBLBIT) {
			sc->tulip_dot3stats.dot3StatsAlignmentErrors++;
			error = "alignment error";
		    } else {
			sc->tulip_dot3stats.dot3StatsFCSErrors++;
			error = "bad crc";
		    }
		}
		if (error != NULL && (sc->tulip_flags & TULIP_NOMESSAGES) == 0) {
		    printf(TULIP_PRINTF_FMT ": receive: %s: %s\n",
			   TULIP_PRINTF_ARGS,
			   ether_sprintf(mtod(ms, u_char *) + 6),
			   error);
		    sc->tulip_flags |= TULIP_NOMESSAGES;
		}
#endif
	    }

	    map = TULIP_GETCTX(me, bus_dmamap_t);
	    bus_dmamap_unload(sc->tulip_dmatag, map);
	    tulip_free_rxmap(sc, map);
	}
#if defined(TULIP_DEBUG)
	cnt++;
#endif
	if (++eop == ri->ri_last)
	    eop = ri->ri_first;
	ri->ri_nextin = eop;
      queue_mbuf:
	/*
	 * Either we are priming the TULIP with mbufs (m == NULL)
	 * or we are about to accept an mbuf for the upper layers
	 * so we need to allocate an mbuf to replace it.  If we
	 * can't replace it, send up it anyways.  This may cause
	 * us to drop packets in the future but that's better than
	 * being caught in livelock.
	 *
	 * Note that if this packet crossed multiple descriptors
	 * we don't even try to reallocate all the mbufs here.
	 * Instead we rely on the test of the beginning of
	 * the loop to refill for the extra consumed mbufs.
	 */
	if (accept || ms == NULL) {
	    struct mbuf *m0;
	    MGETHDR(m0, M_DONTWAIT, MT_DATA);
	    if (m0 != NULL) {
#if defined(TULIP_COPY_RXDATA)
		if (!accept || total_len >= (MHLEN - 2)) {
#endif
		    MCLGET(m0, M_DONTWAIT);
		    if ((m0->m_flags & M_EXT) == 0) {
			m_freem(m0);
			m0 = NULL;
		    }
#if defined(TULIP_COPY_RXDATA)
		}
#endif
	    }
	    if (accept
#if defined(TULIP_COPY_RXDATA)
		&& m0 != NULL
#endif
		) {
#if !defined(TULIP_COPY_RXDATA)
		ms->m_pkthdr.len = total_len;
		ml_enqueue(&ml, ms);
#else
		m0->m_data += 2;	/* align data after header */
		m_copydata(ms, 0, total_len, mtod(m0, caddr_t));
		m0->m_len = m0->m_pkthdr.len = total_len;
		ml_enqueue(&ml, m0);
		m0 = ms;
#endif
	    }
	    ms = m0;
	}
	if (ms == NULL) {
	    /*
	     * Couldn't allocate a new buffer.  Don't bother
	     * trying to replenish the receive queue.
	     */
	    fillok = 0;
	    sc->tulip_flags |= TULIP_RXBUFSLOW;
#if defined(TULIP_DEBUG)
	    sc->tulip_dbg.dbg_rxlowbufs++;
#endif
	    TULIP_PERFEND(rxget);
	    continue;
	}
	/*
	 * Now give the buffer(s) to the TULIP and save in our
	 * receive queue.
	 */
	do {
	    tulip_desc_t * const nextout = ri->ri_nextout;
	    if (sc->tulip_num_free_rxmaps > 0) {
		map = tulip_alloc_rxmap(sc);
	    } else {
		m_freem(ms);
		sc->tulip_flags |= TULIP_RXBUFSLOW;
#if defined(TULIP_DEBUG)
		sc->tulip_dbg.dbg_rxlowbufs++;
#endif
		break;
	    }
	    TULIP_SETCTX(ms, map);
	    error = bus_dmamap_load(sc->tulip_dmatag, map, mtod(ms, void *),
				    TULIP_RX_BUFLEN, NULL, BUS_DMA_NOWAIT);
	    if (error) {
		printf(TULIP_PRINTF_FMT ": unable to load rx map, "
		       "error = %d\n", TULIP_PRINTF_ARGS, error);
		panic("tulip_rx_intr");		/* XXX */
	    }
	    nextout->d_addr1 = map->dm_segs[0].ds_addr;
	    nextout->d_length1 = map->dm_segs[0].ds_len;
	    if (map->dm_nsegs == 2) {
		nextout->d_addr2 = map->dm_segs[1].ds_addr;
		nextout->d_length2 = map->dm_segs[1].ds_len;
	    } else {
		nextout->d_addr2 = 0;
		nextout->d_length2 = 0;
	    }
	    TULIP_RXDESC_POSTSYNC(sc, nextout, sizeof(*nextout));
	    nextout->d_status = TULIP_DSTS_OWNER;
	    TULIP_RXDESC_POSTSYNC(sc, nextout, sizeof(u_int32_t));
	    if (++ri->ri_nextout == ri->ri_last)
		ri->ri_nextout = ri->ri_first;
	    me = ms->m_next;
	    ms->m_next = NULL;
	    ml_enqueue(&sc->tulip_rxq, ms);
	} while ((ms = me) != NULL);

	if (ml_len(&sc->tulip_rxq) >= TULIP_RXQ_TARGET)
	    sc->tulip_flags &= ~TULIP_RXBUFSLOW;
	TULIP_PERFEND(rxget);
    }
out:
    if_input(ifp, &ml);

#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_rxintrs++;
    sc->tulip_dbg.dbg_rxpktsperintr[cnt]++;
#endif
    TULIP_PERFEND(rxintr);
}

int
tulip_tx_intr(tulip_softc_t * const sc)
{
    TULIP_PERFSTART(txintr)
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
    struct mbuf *m;
    int xmits = 0;
    int descs = 0;

    while (ri->ri_free < ri->ri_max) {
	u_int32_t d_flag;

	TULIP_TXDESC_POSTSYNC(sc, ri->ri_nextin, sizeof(*ri->ri_nextin));
	if (((volatile tulip_desc_t *) ri->ri_nextin)->d_status & TULIP_DSTS_OWNER)
	    break;

	ri->ri_free++;
	descs++;
	d_flag = ri->ri_nextin->d_flag;
	if (d_flag & TULIP_DFLAG_TxLASTSEG) {
	    if (d_flag & TULIP_DFLAG_TxSETUPPKT) {
		/*
		 * We've just finished processing a setup packet.
		 * Mark that we finished it.  If there's not
		 * another pending, startup the TULIP receiver.
		 * Make sure we ack the RXSTOPPED so we won't get
		 * an abormal interrupt indication.
		 */
		TULIP_TXMAP_POSTSYNC(sc, sc->tulip_setupmap);
		sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_HASHONLY);
		if (ri->ri_nextin->d_flag & TULIP_DFLAG_TxINVRSFILT)
		    sc->tulip_flags |= TULIP_HASHONLY;
		if ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == 0) {
		    tulip_rx_intr(sc);
		    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;
		    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;
		    TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);
		    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
		    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
		}
	    } else {
		const u_int32_t d_status = ri->ri_nextin->d_status;
		m = ml_dequeue(&sc->tulip_txq);
		if (m != NULL) {
		    bus_dmamap_t map = TULIP_GETCTX(m, bus_dmamap_t);
		    TULIP_TXMAP_POSTSYNC(sc, map);
		    tulip_free_txmap(sc, map);
#if NBPFILTER > 0
		    if (sc->tulip_bpf != NULL)
			bpf_mtap(sc->tulip_if.if_bpf, m, BPF_DIRECTION_OUT);
#endif
		    m_freem(m);
		}
		if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {
		    tulip_mediapoll_event_t event = TULIP_MEDIAPOLL_TXPROBE_OK;
		    if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) {
#if defined(TULIP_DEBUG)
			if (d_status & TULIP_DSTS_TxNOCARR)
			    sc->tulip_dbg.dbg_txprobe_nocarr++;
			if (d_status & TULIP_DSTS_TxEXCCOLL)
			    sc->tulip_dbg.dbg_txprobe_exccoll++;
#endif
			event = TULIP_MEDIAPOLL_TXPROBE_FAILED;
		    }
		    (*sc->tulip_boardsw->bd_media_poll)(sc, event);
		    /*
		     * Escape from the loop before media poll has reset the TULIP!
		     */
		    break;
		} else {
		    xmits++;
		    if (d_status & TULIP_DSTS_ERRSUM) {
			sc->tulip_if.if_oerrors++;
			if (d_status & TULIP_DSTS_TxEXCCOLL)
			    sc->tulip_dot3stats.dot3StatsExcessiveCollisions++;
			if (d_status & TULIP_DSTS_TxLATECOLL)
			    sc->tulip_dot3stats.dot3StatsLateCollisions++;
			if (d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxCARRLOSS))
			    sc->tulip_dot3stats.dot3StatsCarrierSenseErrors++;
			if (d_status & (TULIP_DSTS_TxUNDERFLOW|TULIP_DSTS_TxBABBLE))
			    sc->tulip_dot3stats.dot3StatsInternalMacTransmitErrors++;
			if (d_status & TULIP_DSTS_TxUNDERFLOW)
			    sc->tulip_dot3stats.dot3StatsInternalTransmitUnderflows++;
			if (d_status & TULIP_DSTS_TxBABBLE)
			    sc->tulip_dot3stats.dot3StatsInternalTransmitBabbles++;
		    } else {
			u_int32_t collisions =
			    (d_status & TULIP_DSTS_TxCOLLMASK)
				>> TULIP_DSTS_V_TxCOLLCNT;
			sc->tulip_if.if_collisions += collisions;
			if (collisions == 1)
			    sc->tulip_dot3stats.dot3StatsSingleCollisionFrames++;
			else if (collisions > 1)
			    sc->tulip_dot3stats.dot3StatsMultipleCollisionFrames++;
			else if (d_status & TULIP_DSTS_TxDEFERRED)
			    sc->tulip_dot3stats.dot3StatsDeferredTransmissions++;
			/*
			 * SQE is only valid for 10baseT/BNC/AUI when not
			 * running in full-duplex.  In order to speed up the
			 * test, the corresponding bit in tulip_flags needs to
			 * set as well to get us to count SQE Test Errors.
			 */
			if (d_status & TULIP_DSTS_TxNOHRTBT & sc->tulip_flags)
			    sc->tulip_dot3stats.dot3StatsSQETestErrors++;
		    }
		}
	    }
	}

	if (++ri->ri_nextin == ri->ri_last)
	    ri->ri_nextin = ri->ri_first;

	if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)
	    ifq_clr_oactive(&sc->tulip_if.if_snd);
    }
    /*
     * If nothing left to transmit, disable the timer.
     * Else if progress, reset the timer back to 2 ticks.
     */
    if (ri->ri_free == ri->ri_max || (sc->tulip_flags & TULIP_TXPROBE_ACTIVE))
	sc->tulip_txtimer = 0;
    else if (xmits > 0)
	sc->tulip_txtimer = TULIP_TXTIMER;
    TULIP_PERFEND(txintr);
    return (descs);
}

void
tulip_print_abnormal_interrupt(tulip_softc_t * const sc, u_int32_t csr)
{
#ifdef TULIP_DEBUG
    const char * const *msgp = tulip_status_bits;
    const char *sep;
    u_int32_t mask;
    const char thrsh[] = "72|128\0\0\0" "96|256\0\0\0" "128|512\0\0" "160|1024\0";

    csr &= (1 << (nitems(tulip_status_bits))) - 1;
    printf(TULIP_PRINTF_FMT ": abnormal interrupt:", TULIP_PRINTF_ARGS);
    for (sep = " ", mask = 1; mask <= csr; mask <<= 1, msgp++) {
	if ((csr & mask) && *msgp != NULL) {
	    printf("%s%s", sep, *msgp);
	    if (mask == TULIP_STS_TXUNDERFLOW && (sc->tulip_flags & TULIP_NEWTXTHRESH)) {
		sc->tulip_flags &= ~TULIP_NEWTXTHRESH;
		if (sc->tulip_cmdmode & TULIP_CMD_STOREFWD)
		    printf(" (switching to store-and-forward mode)");
		else {
		    printf(" (raising TX threshold to %s)",
			   &thrsh[9 * ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) >> 14)]);
		}
	    }
	    sep = ", ";
	}
    }
    printf("\n");
#endif
}

void
tulip_intr_handler(tulip_softc_t * const sc, int *progress_p)
{
    TULIP_PERFSTART(intr)
    u_int32_t csr;

    while ((csr = TULIP_CSR_READ(sc, csr_status)) & sc->tulip_intrmask) {
	*progress_p = 1;
	TULIP_CSR_WRITE(sc, csr_status, csr);

	if (csr & TULIP_STS_SYSERROR) {
	    sc->tulip_last_system_error = (csr & TULIP_STS_ERRORMASK) >> TULIP_STS_ERR_SHIFT;
	    if (sc->tulip_flags & TULIP_NOMESSAGES)
		sc->tulip_flags |= TULIP_SYSTEMERROR;
	    else {
#if defined(TULIP_DEBUG)
		printf(TULIP_PRINTF_FMT ": system error: %s\n",
		       TULIP_PRINTF_ARGS,
		       tulip_system_errors[sc->tulip_last_system_error]);
#endif
	    }
	    sc->tulip_flags |= TULIP_NEEDRESET;
	    sc->tulip_system_errors++;
	    break;
	}
	if (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL) & sc->tulip_intrmask) {
#if defined(TULIP_DEBUG)
	    sc->tulip_dbg.dbg_link_intrs++;
#endif
	    if (sc->tulip_boardsw->bd_media_poll != NULL) {
		(*sc->tulip_boardsw->bd_media_poll)(sc, csr & TULIP_STS_LINKFAIL
						    ? TULIP_MEDIAPOLL_LINKFAIL
						    : TULIP_MEDIAPOLL_LINKPASS);
		csr &= ~TULIP_STS_ABNRMLINTR;
	    }
	    tulip_media_print(sc);
	}
	if (csr & (TULIP_STS_RXINTR|TULIP_STS_RXNOBUF)) {
	    u_int32_t misses = TULIP_CSR_READ(sc, csr_missed_frames);
	    if (csr & TULIP_STS_RXNOBUF)
		sc->tulip_dot3stats.dot3StatsMissedFrames += misses & 0xFFFF;
	    /*
	     * Pass 2.[012] of the 21140A-A[CDE] may hang and/or corrupt data
	     * on receive overflows.
	     */
	   if ((misses & 0x0FFE0000) && (sc->tulip_features & TULIP_HAVE_RXBADOVRFLW)) {
		sc->tulip_dot3stats.dot3StatsInternalMacReceiveErrors++;
		/*
		 * Stop the receiver process and spin until it's stopped.
		 * Tell rx_intr to drop the packets it dequeues.
		 */
		TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode & ~TULIP_CMD_RXRUN);
		while ((TULIP_CSR_READ(sc, csr_status) & TULIP_STS_RXSTOPPED) == 0)
		    ;
		TULIP_CSR_WRITE(sc, csr_status, TULIP_STS_RXSTOPPED);
		sc->tulip_flags |= TULIP_RXIGNORE;
	    }
	    tulip_rx_intr(sc);
	    if (sc->tulip_flags & TULIP_RXIGNORE) {
		/*
		 * Restart the receiver.
		 */
		sc->tulip_flags &= ~TULIP_RXIGNORE;
		TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
	    }
	}
	if (csr & TULIP_STS_ABNRMLINTR) {
	    u_int32_t tmp = csr & sc->tulip_intrmask
		& ~(TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR);
	    if (csr & TULIP_STS_TXUNDERFLOW) {
#if defined(TULIP_DEBUG)
		printf ("Underflow interrupt\n");
#endif
		if ((sc->tulip_cmdmode & TULIP_CMD_THRESHOLDCTL) != TULIP_CMD_THRSHLD160) {
		    sc->tulip_cmdmode += TULIP_CMD_THRSHLD96;
		    sc->tulip_flags |= TULIP_NEWTXTHRESH;
		} else if (sc->tulip_features & TULIP_HAVE_STOREFWD) {
		    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;
		    sc->tulip_flags |= TULIP_NEWTXTHRESH;
		}
	    }
	    if (sc->tulip_flags & TULIP_NOMESSAGES)
		sc->tulip_statusbits |= tmp;
	    else {
		tulip_print_abnormal_interrupt(sc, tmp);
		sc->tulip_flags |= TULIP_NOMESSAGES;
	    }
	    TULIP_CSR_WRITE(sc, csr_command, sc->tulip_cmdmode);
	}
	if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_TXPROBE_ACTIVE|TULIP_DOINGSETUP|TULIP_PROMISC)) {
	    tulip_tx_intr(sc);
	    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)
		tulip_ifstart(&sc->tulip_if);
	}
    }
    if (sc->tulip_flags & TULIP_NEEDRESET) {
	tulip_reset(sc);
	tulip_init(sc);
    }
    TULIP_PERFEND(intr);
}

int
tulip_intr_shared(void *arg)
{
    tulip_softc_t * sc = arg;
    int progress = 0;

    for (; sc != NULL; sc = sc->tulip_slaves) {
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_intrs++;
#endif
	tulip_intr_handler(sc, &progress);
    }
    return (progress);
}

int
tulip_intr_normal(void *arg)
{
    tulip_softc_t * sc = (tulip_softc_t *) arg;
    int progress = 0;

#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_intrs++;
#endif
    tulip_intr_handler(sc, &progress);

    return (progress);
}

struct mbuf *
tulip_mbuf_compress(struct mbuf *m)
{
    struct mbuf *m0;
#if MCLBYTES >= ETHERMTU + 18
    MGETHDR(m0, M_DONTWAIT, MT_DATA);
    if (m0 != NULL) {
	if (m->m_pkthdr.len > MHLEN) {
	    MCLGET(m0, M_DONTWAIT);
	    if ((m0->m_flags & M_EXT) == 0) {
		m_freem(m);
		m_freem(m0);
		return (NULL);
	    }
	}
	m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));
	m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;
    }
#else
    int mlen = MHLEN;
    int len = m->m_pkthdr.len;
    struct mbuf **mp = &m0;

    while (len > 0) {
	if (mlen == MHLEN)
	    MGETHDR(*mp, M_DONTWAIT, MT_DATA);
	else
	    MGET(*mp, M_DONTWAIT, MT_DATA);
	if (*mp == NULL) {
	    m_freem(m0);
	    m0 = NULL;
	    break;
	}
	if (len > MLEN) {
	    MCLGET(*mp, M_DONTWAIT);
	    if (((*mp)->m_flags & M_EXT) == 0) {
		m_freem(m0);
		m0 = NULL;
		break;
	    }
	    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;
	else
	    (*mp)->m_len = len <= mlen ? len : mlen;
	m_copydata(m, m->m_pkthdr.len - len,
		   (*mp)->m_len, mtod((*mp), caddr_t));
	len -= (*mp)->m_len;
	mp = &(*mp)->m_next;
	mlen = MLEN;
    }
#endif
    m_freem(m);
    return (m0);
}

struct mbuf *
tulip_txput(tulip_softc_t * const sc, struct mbuf *m, int notonqueue)
{
    TULIP_PERFSTART(txput)
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
    tulip_desc_t *eop, *nextout;
    int segcnt, freedescs;
    u_int32_t d_status;
    bus_dmamap_t map;
    struct ifnet *ifp = &sc->tulip_if;

#if defined(TULIP_DEBUG)
    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {
	printf(TULIP_PRINTF_FMT ": txput%s: tx not running\n",
	       TULIP_PRINTF_ARGS,
	       (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? "(probe)" : "");
	sc->tulip_flags |= TULIP_WANTTXSTART;
	sc->tulip_dbg.dbg_txput_finishes[0]++;
	goto finish;
    }
#endif

    /*
     * Now we try to fill in our transmit descriptors.  This is
     * a bit reminiscent of going on the Ark two by two
     * since each descriptor for the TULIP can describe
     * two buffers.  So we advance through packet filling
     * each of the two entries at a time to to fill each
     * descriptor.  Clear the first and last segment bits
     * in each descriptor (actually just clear everything
     * but the end-of-ring or chain bits) to make sure
     * we don't get messed up by previously sent packets.
     *
     * We may fail to put the entire packet on the ring if
     * there is either not enough ring entries free or if the
     * packet has more than MAX_TXSEG segments.  In the former
     * case we will just wait for the ring to empty.  In the
     * latter case we have to recopy.
     */
    d_status = 0;
    eop = nextout = ri->ri_nextout;
    segcnt = 0;
    freedescs = ri->ri_free;

    /*
     * Reclaim some DMA maps from if we are out.
     */
    if (sc->tulip_num_free_txmaps == 0) {
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_no_txmaps++;
#endif
	freedescs += tulip_tx_intr(sc);
    }
    if (sc->tulip_num_free_txmaps > 0)
	map = tulip_alloc_txmap(sc);
    else {
	sc->tulip_flags |= TULIP_WANTTXSTART;
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_txput_finishes[1]++;
#endif
	goto finish;
    }
    switch (bus_dmamap_load_mbuf(sc->tulip_dmatag, map, m, BUS_DMA_NOWAIT)) {
    case 0:
	break;
    case EFBIG:
	/*
	 * The packet exceeds the number of transmit buffer
	 * entries that we can use for one packet, so we have
	 * to recopy it into one mbuf and then try again.
	 */
	if (m_defrag(m, M_DONTWAIT) == 0 &&
	  bus_dmamap_load_mbuf(sc->tulip_dmatag, map, m, BUS_DMA_NOWAIT) == 0)
	    break;
	/* FALLTHROUGH */
    default:
	tulip_free_txmap(sc, map);
        goto finish;
    }

    if ((freedescs -= (map->dm_nsegs + 1) / 2) <= 0
	    /*
	     * See if there's any unclaimed space in the transmit ring.
	     */
	    && (freedescs += tulip_tx_intr(sc)) <= 0) {
	/*
	 * There's no more room but since nothing
	 * has been committed at this point, just
	 * show output is active, put back the
	 * mbuf and return.
	 */
	sc->tulip_flags |= TULIP_WANTTXSTART;
#if defined(TULIP_DEBUG)
	sc->tulip_dbg.dbg_txput_finishes[4]++;
#endif
	bus_dmamap_unload(sc->tulip_dmatag, map);
	tulip_free_txmap(sc, map);
	goto finish;
    }
    for (; map->dm_nsegs - segcnt > 1; segcnt += 2) {
	eop = nextout;
	eop->d_flag   &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
	eop->d_status  = d_status;
	eop->d_addr1   = map->dm_segs[segcnt].ds_addr;
	eop->d_length1 = map->dm_segs[segcnt].ds_len;
	eop->d_addr2   = map->dm_segs[segcnt+1].ds_addr;
	eop->d_length2 = map->dm_segs[segcnt+1].ds_len;
	d_status = TULIP_DSTS_OWNER;
	if (++nextout == ri->ri_last)
	    nextout = ri->ri_first;
    }
    if (segcnt < map->dm_nsegs) {
	eop = nextout;
	eop->d_flag   &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
	eop->d_status  = d_status;
	eop->d_addr1   = map->dm_segs[segcnt].ds_addr;
	eop->d_length1 = map->dm_segs[segcnt].ds_len;
	eop->d_addr2   = 0;
	eop->d_length2 = 0;
	if (++nextout == ri->ri_last)
	    nextout = ri->ri_first;
    }
    TULIP_TXMAP_PRESYNC(sc, map);

    /*
     * The descriptors have been filled in.  Now get ready
     * to transmit.
     */
    if (!notonqueue)
	ifq_deq_commit(&ifp->if_snd, m);

    TULIP_SETCTX(m, map);
    map = NULL;

    ml_enqueue(&sc->tulip_txq, m);
    m = NULL;

    /*
     * Make sure the next descriptor after this packet is owned
     * by us since it may have been set up above if we ran out
     * of room in the ring.
     */
    nextout->d_status = 0;
    TULIP_TXDESC_PRESYNC(sc, nextout, sizeof(u_int32_t));

    /*
     * Mark the last and first segments, indicate we want a transmit
     * complete interrupt, and tell it to transmit!
     */
    eop->d_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;

    /*
     * Note that ri->ri_nextout is still the start of the packet
     * and until we set the OWNER bit, we can still back out of
     * everything we have done.
     */
    ri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;
    if (eop < ri->ri_nextout) {
	TULIP_TXDESC_PRESYNC(sc, ri->ri_nextout,
			     (caddr_t) ri->ri_last - (caddr_t) ri->ri_nextout);
	TULIP_TXDESC_PRESYNC(sc, ri->ri_first,
			     (caddr_t) (eop + 1) - (caddr_t) ri->ri_first);
    } else {
	TULIP_TXDESC_PRESYNC(sc, ri->ri_nextout,
			     (caddr_t) (eop + 1) - (caddr_t) ri->ri_nextout);
    }
    ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
    TULIP_TXDESC_PRESYNC(sc, ri->ri_nextout, sizeof(u_int32_t));

    /*
     * This advances the ring for us.
     */
    ri->ri_nextout = nextout;
    ri->ri_free = freedescs;

    TULIP_PERFEND(txput);

    if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {
	TULIP_CSR_WRITE(sc, csr_txpoll, 1);
	ifq_set_oactive(&sc->tulip_if.if_snd);
	TULIP_PERFEND(txput);
	return (NULL);
    }

    /*
     * switch back to the single queueing ifstart.
     */
    sc->tulip_flags &= ~TULIP_WANTTXSTART;
    if (sc->tulip_txtimer == 0)
	sc->tulip_txtimer = TULIP_TXTIMER;
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_txput_finishes[5]++;
#endif

    /*
     * If we want a txstart, there must be not enough space in the
     * transmit ring.  So we want to enable transmit done interrupts
     * so we can immediately reclaim some space.  When the transmit
     * interrupt is posted, the interrupt handler will call tx_intr
     * to reclaim space and then txstart (since WANTTXSTART is set).
     * txstart will move the packet into the transmit ring and clear
     * WANTTXSTART thereby causing TXINTR to be cleared.
     */
  finish:
#if defined(TULIP_DEBUG)
    sc->tulip_dbg.dbg_txput_finishes[6]++;
#endif
    if (sc->tulip_flags & (TULIP_WANTTXSTART|TULIP_DOINGSETUP)) {
	ifq_set_oactive(&sc->tulip_if.if_snd);
	if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {
	    sc->tulip_intrmask |= TULIP_STS_TXINTR;
	    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	}
    } else if ((sc->tulip_flags & TULIP_PROMISC) == 0) {
	if (sc->tulip_intrmask & TULIP_STS_TXINTR) {
	    sc->tulip_intrmask &= ~TULIP_STS_TXINTR;
	    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	}
    }
    TULIP_CSR_WRITE(sc, csr_txpoll, 1);
    TULIP_PERFEND(txput);
    return (m);
}

void
tulip_txput_setup(tulip_softc_t * const sc)
{
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
    tulip_desc_t *nextout;

    /*
     * We will transmit, at most, one setup packet per call to ifstart.
     */

#if defined(TULIP_DEBUG)
    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {
	printf(TULIP_PRINTF_FMT ": txput_setup: tx not running\n",
	       TULIP_PRINTF_ARGS);
	sc->tulip_flags |= TULIP_WANTTXSTART;
	return;
    }
#endif
    /*
     * Try to reclaim some free descriptors..
     */
    if (ri->ri_free < 2)
	tulip_tx_intr(sc);
    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {
	sc->tulip_flags |= TULIP_WANTTXSTART;
	return;
    }
    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,
        sizeof(sc->tulip_setupdata));
    /*
     * Clear WANTSETUP and set DOINGSETUP.  Set know that WANTSETUP is
     * set and DOINGSETUP is clear doing an XOR of the two will DTRT.
     */
    sc->tulip_flags ^= TULIP_WANTSETUP|TULIP_DOINGSETUP;
    ri->ri_free--;
    nextout = ri->ri_nextout;
    nextout->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
    nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG
	|TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;
    if (sc->tulip_flags & TULIP_WANTHASHPERFECT)
	nextout->d_flag |= TULIP_DFLAG_TxHASHFILT;
    else if (sc->tulip_flags & TULIP_WANTHASHONLY)
	nextout->d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;

    nextout->d_length2 = 0;
    nextout->d_addr2 = 0;
    nextout->d_length1 = sc->tulip_setupmap->dm_segs[0].ds_len;
    nextout->d_addr1 = sc->tulip_setupmap->dm_segs[0].ds_addr;
    if (sc->tulip_setupmap->dm_nsegs == 2) {
	nextout->d_length2 = sc->tulip_setupmap->dm_segs[1].ds_len;
	nextout->d_addr2 = sc->tulip_setupmap->dm_segs[1].ds_addr;
    }
    TULIP_TXMAP_PRESYNC(sc, sc->tulip_setupmap);
    TULIP_TXDESC_PRESYNC(sc, nextout, sizeof(*nextout));

    /*
     * Advance the ring for the next transmit packet.
     */
    if (++ri->ri_nextout == ri->ri_last)
	ri->ri_nextout = ri->ri_first;

    /*
     * Make sure the next descriptor is owned by us since it
     * may have been set up above if we ran out of room in the
     * ring.
     */
    ri->ri_nextout->d_status = 0;
    TULIP_TXDESC_PRESYNC(sc, ri->ri_nextout, sizeof(u_int32_t));
    nextout->d_status = TULIP_DSTS_OWNER;
    /*
     * Flush the ownwership of the current descriptor
     */
    TULIP_TXDESC_PRESYNC(sc, nextout, sizeof(u_int32_t));
    TULIP_CSR_WRITE(sc, csr_txpoll, 1);
    if ((sc->tulip_intrmask & TULIP_STS_TXINTR) == 0) {
	sc->tulip_intrmask |= TULIP_STS_TXINTR;
	TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
    }
}

/*
 * This routine is entered at splnet().
 */
int
tulip_ifioctl(struct ifnet * ifp, u_long cmd, caddr_t data)
{
    TULIP_PERFSTART(ifioctl)
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);
    struct ifreq *ifr = (struct ifreq *) data;
    int s;
    int error = 0;

    s = splnet();

    switch (cmd) {
    case SIOCSIFADDR: {
	ifp->if_flags |= IFF_UP;
	tulip_init(sc);
	break;
    }

    case SIOCSIFFLAGS: {
	tulip_init(sc);
	break;
    }

    case SIOCSIFMEDIA:
    case SIOCGIFMEDIA: {
	error = ifmedia_ioctl(ifp, ifr, &sc->tulip_ifmedia, cmd);
	break;
    }

    default:
	error = ether_ioctl(ifp, &sc->tulip_ac, cmd, data);
    }

    if (error == ENETRESET) {
	if (ifp->if_flags & IFF_RUNNING) {
		tulip_addr_filter(sc); /* reset multicast filtering */
		tulip_init(sc);
	}
	error = 0;
    }

    splx(s);
    TULIP_PERFEND(ifioctl);
    return (error);
}

/*
 * the original dequeueing policy is dequeue-and-prepend if something
 * goes wrong.
 * the modification becomes a bit complicated since tulip_txput() might
 * copy and modify the mbuf passed.
 */

void
tulip_ifstart(struct ifnet * const ifp)
{
    TULIP_PERFSTART(ifstart)
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);
    struct mbuf *m, *m0;

    if (sc->tulip_if.if_flags & IFF_RUNNING) {

	if ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP)
	    tulip_txput_setup(sc);

        for (;;) {
	    m = ifq_deq_begin(&sc->tulip_if.if_snd);
	    if (m == NULL)
		break;
            m0 = tulip_txput(sc, m, 0);
            if (m0 != NULL) {
		KASSERT(m == m0);
                ifq_deq_rollback(&sc->tulip_if.if_snd, m);
		break;
	    }
	}
    }

    TULIP_PERFEND(ifstart);
}

void
tulip_ifwatchdog(struct ifnet *ifp)
{
    TULIP_PERFSTART(ifwatchdog)
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);

#if defined(TULIP_DEBUG)
    u_int32_t rxintrs = sc->tulip_dbg.dbg_rxintrs - sc->tulip_dbg.dbg_last_rxintrs;
    if (rxintrs > sc->tulip_dbg.dbg_high_rxintrs_hz)
	sc->tulip_dbg.dbg_high_rxintrs_hz = rxintrs;
    sc->tulip_dbg.dbg_last_rxintrs = sc->tulip_dbg.dbg_rxintrs;
#endif /* TULIP_DEBUG */

    sc->tulip_if.if_timer = 1;
    /*
     * These should be rare so do a bulk test up front so we can just skip
     * them if needed.
     */
    if (sc->tulip_flags & (TULIP_SYSTEMERROR|TULIP_RXBUFSLOW|TULIP_NOMESSAGES)) {
	/*
	 * If the number of receive buffer is low, try to refill
	 */
	if (sc->tulip_flags & TULIP_RXBUFSLOW)
	    tulip_rx_intr(sc);

#if defined(TULIP_DEBUG)
	if (sc->tulip_flags & TULIP_SYSTEMERROR) {
	    printf(TULIP_PRINTF_FMT ": %d system errors: last was %s\n",
		   TULIP_PRINTF_ARGS, sc->tulip_system_errors,
		   tulip_system_errors[sc->tulip_last_system_error]);
	}
#endif
	if (sc->tulip_statusbits) {
	    tulip_print_abnormal_interrupt(sc, sc->tulip_statusbits);
	    sc->tulip_statusbits = 0;
	}

	sc->tulip_flags &= ~(TULIP_NOMESSAGES|TULIP_SYSTEMERROR);
    }

    if (sc->tulip_txtimer)
	tulip_tx_intr(sc);
    if (sc->tulip_txtimer && --sc->tulip_txtimer == 0) {
	printf(TULIP_PRINTF_FMT ": transmission timeout\n", TULIP_PRINTF_ARGS);
	if (TULIP_DO_AUTOSENSE(sc)) {
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
	    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP);
	}
	tulip_reset(sc);
	tulip_init(sc);
    }

    TULIP_PERFEND(ifwatchdog);
    TULIP_PERFMERGE(sc, perf_intr_cycles);
    TULIP_PERFMERGE(sc, perf_ifstart_cycles);
    TULIP_PERFMERGE(sc, perf_ifioctl_cycles);
    TULIP_PERFMERGE(sc, perf_ifwatchdog_cycles);
    TULIP_PERFMERGE(sc, perf_timeout_cycles);
    TULIP_PERFMERGE(sc, perf_ifstart_one_cycles);
    TULIP_PERFMERGE(sc, perf_txput_cycles);
    TULIP_PERFMERGE(sc, perf_txintr_cycles);
    TULIP_PERFMERGE(sc, perf_rxintr_cycles);
    TULIP_PERFMERGE(sc, perf_rxget_cycles);
    TULIP_PERFMERGE(sc, perf_intr);
    TULIP_PERFMERGE(sc, perf_ifstart);
    TULIP_PERFMERGE(sc, perf_ifioctl);
    TULIP_PERFMERGE(sc, perf_ifwatchdog);
    TULIP_PERFMERGE(sc, perf_timeout);
    TULIP_PERFMERGE(sc, perf_ifstart_one);
    TULIP_PERFMERGE(sc, perf_txput);
    TULIP_PERFMERGE(sc, perf_txintr);
    TULIP_PERFMERGE(sc, perf_rxintr);
    TULIP_PERFMERGE(sc, perf_rxget);
}

/*
 * All printf's are real as of now!
 */
#ifdef printf
#undef printf
#endif

int
tulip_busdma_allocmem(tulip_softc_t * const sc, size_t size,
    bus_dmamap_t *map_p, tulip_desc_t **desc_p)
{
    bus_dma_segment_t segs[1];
    int nsegs, error;
    error = bus_dmamem_alloc(sc->tulip_dmatag, size, 1, PAGE_SIZE,
			     segs, sizeof(segs)/sizeof(segs[0]),
			     &nsegs, BUS_DMA_NOWAIT);
    if (error == 0) {
	void *desc;
	error = bus_dmamem_map(sc->tulip_dmatag, segs, nsegs, size,
			       (void *) &desc, BUS_DMA_NOWAIT|BUS_DMA_COHERENT);
	if (error == 0) {
	    bus_dmamap_t map;
	    error = bus_dmamap_create(sc->tulip_dmatag, size, 1, size, 0,
				      BUS_DMA_NOWAIT, &map);
	    if (error == 0) {
		error = bus_dmamap_load(sc->tulip_dmatag, map, desc,
					size, NULL, BUS_DMA_NOWAIT);
		if (error)
		    bus_dmamap_destroy(sc->tulip_dmatag, map);
		else
		    *map_p = map;
	    }
	    if (error)
		bus_dmamem_unmap(sc->tulip_dmatag, desc, size);
	}
	if (error)
	    bus_dmamem_free(sc->tulip_dmatag, segs, nsegs);
	else
	    *desc_p = desc;
    }
    return (error);
}

int
tulip_busdma_init(tulip_softc_t * const sc)
{
    int error = 0;

    /*
     * Allocate space and dmamap for setup descriptor
     */
    error = tulip_busdma_allocmem(sc, sizeof(sc->tulip_setupdata),
				  &sc->tulip_setupmap, &sc->tulip_setupbuf);

    /*
     * Allocate space and dmamap for transmit ring
     */
    if (error == 0) {
	error = tulip_busdma_allocmem(sc, sizeof(tulip_desc_t) * TULIP_TXDESCS,
				      &sc->tulip_txdescmap,
				      &sc->tulip_txdescs);
    }

    /*
     * Allocate dmamaps for each transmit descriptor, and place on the
     * free list.
     */
    if (error == 0) {
	while (error == 0 && sc->tulip_num_free_txmaps < TULIP_TXDESCS) {
	    bus_dmamap_t map;
	    if ((error = TULIP_TXMAP_CREATE(sc, &map)) == 0)
		tulip_free_txmap(sc, map);
	}
	if (error) {
	    while (sc->tulip_num_free_txmaps > 0)
		bus_dmamap_destroy(sc->tulip_dmatag, tulip_alloc_txmap(sc));
	}
    }

    /*
     * Allocate space and dmamap for receive ring
     */
    if (error == 0) {
	error = tulip_busdma_allocmem(sc, sizeof(tulip_desc_t) * TULIP_RXDESCS,
				      &sc->tulip_rxdescmap,
				      &sc->tulip_rxdescs);
    }

    /*
     * Allocate dmamaps for each receive descriptor, and place on the
     * free list.
     */
    if (error == 0) {
	while (error == 0 && sc->tulip_num_free_rxmaps < TULIP_RXDESCS) {
	    bus_dmamap_t map;
	    if ((error = TULIP_RXMAP_CREATE(sc, &map)) == 0)
		tulip_free_rxmap(sc, map);
	}
	if (error) {
	    while (sc->tulip_num_free_rxmaps > 0)
		bus_dmamap_destroy(sc->tulip_dmatag, tulip_alloc_rxmap(sc));
	}
    }
    return (error);
}

void
tulip_initcsrs(tulip_softc_t * const sc, bus_addr_t csr_base, size_t csr_size)
{
    sc->tulip_csrs.csr_busmode		= csr_base +  0 * csr_size;
    sc->tulip_csrs.csr_txpoll		= csr_base +  1 * csr_size;
    sc->tulip_csrs.csr_rxpoll		= csr_base +  2 * csr_size;
    sc->tulip_csrs.csr_rxlist		= csr_base +  3 * csr_size;
    sc->tulip_csrs.csr_txlist		= csr_base +  4 * csr_size;
    sc->tulip_csrs.csr_status		= csr_base +  5 * csr_size;
    sc->tulip_csrs.csr_command		= csr_base +  6 * csr_size;
    sc->tulip_csrs.csr_intr		= csr_base +  7 * csr_size;
    sc->tulip_csrs.csr_missed_frames	= csr_base +  8 * csr_size;
    sc->tulip_csrs.csr_9		= csr_base +  9 * csr_size;
    sc->tulip_csrs.csr_10		= csr_base + 10 * csr_size;
    sc->tulip_csrs.csr_11		= csr_base + 11 * csr_size;
    sc->tulip_csrs.csr_12		= csr_base + 12 * csr_size;
    sc->tulip_csrs.csr_13		= csr_base + 13 * csr_size;
    sc->tulip_csrs.csr_14		= csr_base + 14 * csr_size;
    sc->tulip_csrs.csr_15		= csr_base + 15 * csr_size;
}

void
tulip_initring(tulip_softc_t * const sc, tulip_ringinfo_t * const ri,
    tulip_desc_t *descs, int ndescs)
{
    ri->ri_max = ndescs;
    ri->ri_first = descs;
    ri->ri_last = ri->ri_first + ri->ri_max;
    bzero((caddr_t) ri->ri_first, sizeof(ri->ri_first[0]) * ri->ri_max);
    ri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;
}

int
tulip_probe(struct device *parent, void *match, void *aux)
{
    struct pci_attach_args *pa = (struct pci_attach_args *) aux;

    if (PCI_VENDORID(pa->pa_id) != DEC_VENDORID)
	return (0);
    if (PCI_CHIPID(pa->pa_id) == CHIPID_21040
	    || PCI_CHIPID(pa->pa_id) == CHIPID_21041
	    || PCI_CHIPID(pa->pa_id) == CHIPID_21140
	    || PCI_CHIPID(pa->pa_id) == CHIPID_21142)
	return (2);

    return (0);
}

void
tulip_attach(struct device * const parent, struct device * const self, void * const aux)
{
    tulip_softc_t * const sc = (tulip_softc_t *) self;
    struct pci_attach_args * const pa = (struct pci_attach_args *) aux;
    struct ifnet * const ifp = &sc->tulip_if;
    const int unit = sc->tulip_dev.dv_unit;
    int retval, idx;
    u_int32_t revinfo, cfdainfo, id;
    unsigned csroffset = TULIP_PCI_CSROFFSET;
    unsigned csrsize = TULIP_PCI_CSRSIZE;
    bus_addr_t csr_base;
    tulip_chipid_t chipid = TULIP_CHIPID_UNKNOWN;

    if (unit >= TULIP_MAX_DEVICES) {
	printf(": not configured; limit of %d reached or exceeded\n",
	       TULIP_MAX_DEVICES);
	return;
    }

    ml_init(&sc->tulip_txq);
    ml_init(&sc->tulip_rxq);

    revinfo  = PCI_CONF_READ(PCI_CFRV) & 0xFF;
    id       = PCI_CONF_READ(PCI_CFID);
    cfdainfo = PCI_CONF_READ(PCI_CFDA);

    if (PCI_VENDORID(id) == DEC_VENDORID) {
	if (PCI_CHIPID(id) == CHIPID_21040)
		chipid = TULIP_21040;
	else if (PCI_CHIPID(id) == CHIPID_21041)
		chipid = TULIP_21041;
	else if (PCI_CHIPID(id) == CHIPID_21140)
		chipid = (revinfo >= 0x20) ? TULIP_21140A : TULIP_21140;
	else if (PCI_CHIPID(id) == CHIPID_21142)
		chipid = (revinfo >= 0x20) ? TULIP_21143 : TULIP_21142;
    }

    if (chipid == TULIP_CHIPID_UNKNOWN)
	return;

    if ((chipid == TULIP_21040 || chipid == TULIP_DE425) && revinfo < 0x20) {
	printf(": not configured; 21040 pass 2.0 required (%d.%d found)\n",
	       revinfo >> 4, revinfo & 0x0f);
	return;
    } else if (chipid == TULIP_21140 && revinfo < 0x11) {
	printf(": not configured; 21140 pass 1.1 required (%d.%d found)\n",
	       revinfo >> 4, revinfo & 0x0f);
	return;
    }

    PCI_GETBUSDEVINFO(sc);
    sc->tulip_chipid = chipid;
    sc->tulip_flags |= TULIP_DEVICEPROBE;
    if (chipid == TULIP_21140 || chipid == TULIP_21140A)
	sc->tulip_features |= TULIP_HAVE_GPR|TULIP_HAVE_STOREFWD;
    if (chipid == TULIP_21140A && revinfo <= 0x22)
	sc->tulip_features |= TULIP_HAVE_RXBADOVRFLW;
    if (chipid == TULIP_21140)
	sc->tulip_features |= TULIP_HAVE_BROKEN_HASH;
    if (chipid != TULIP_21040 && chipid != TULIP_DE425 && chipid != TULIP_21140)
	sc->tulip_features |= TULIP_HAVE_POWERMGMT;
    if (chipid == TULIP_21041 || chipid == TULIP_21142 || chipid == TULIP_21143) {
	sc->tulip_features |= TULIP_HAVE_DUALSENSE;
	if (chipid != TULIP_21041 || revinfo >= 0x20)
	    sc->tulip_features |= TULIP_HAVE_SIANWAY;
	if (chipid != TULIP_21041)
	    sc->tulip_features |= TULIP_HAVE_SIAGP|TULIP_HAVE_RXBADOVRFLW|TULIP_HAVE_STOREFWD;
	if (chipid != TULIP_21041 && revinfo >= 0x20)
	    sc->tulip_features |= TULIP_HAVE_SIA100;
    }

    if (sc->tulip_features & TULIP_HAVE_POWERMGMT
	    && (cfdainfo & (TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE))) {
	cfdainfo &= ~(TULIP_CFDA_SLEEP|TULIP_CFDA_SNOOZE);
	PCI_CONF_WRITE(PCI_CFDA, cfdainfo);
	DELAY(11*1000);
    }

    if (sc->tulip_features & TULIP_HAVE_STOREFWD)
	    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD;

    bcopy(self->dv_xname, sc->tulip_if.if_xname, IFNAMSIZ);
    sc->tulip_if.if_softc = sc;
    sc->tulip_pc = pa->pa_pc;
    sc->tulip_dmatag = pa->pa_dmat;
    sc->tulip_revinfo = revinfo;

    timeout_set(&sc->tulip_stmo, tulip_timeout_callback, sc);

    csr_base = 0;
    {
	bus_space_tag_t iot, memt;
	bus_space_handle_t ioh, memh;
	int ioh_valid, memh_valid;

    	ioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
		 &iot, &ioh, NULL, NULL, 0) == 0);
    	memh_valid = (pci_mapreg_map(pa, PCI_CBMA,
		  PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
		  &memt, &memh, NULL, NULL, 0) == 0);

	if (memh_valid) {
	    sc->tulip_bustag = memt;
	    sc->tulip_bushandle = memh;
	} else if (ioh_valid) {
	    sc->tulip_bustag = iot;
	    sc->tulip_bushandle = ioh;
	} else {
	   printf(": unable to map device registers\n");
           return;
	}
    }

    tulip_initcsrs(sc, csr_base + csroffset, csrsize);

    if ((retval = tulip_busdma_init(sc)) != 0) {
	printf(": error initing bus_dma: %d\n", retval);
	return;
    }

    tulip_initring(sc, &sc->tulip_rxinfo, sc->tulip_rxdescs, TULIP_RXDESCS);
    tulip_initring(sc, &sc->tulip_txinfo, sc->tulip_txdescs, TULIP_TXDESCS);

    /*
     * Make sure there won't be any interrupts or such...
     */
    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(100);	/* Wait 10 microseconds (actually 50 PCI cycles but at
		   33MHz that comes to two microseconds but wait a
		   bit longer anyways) */

    if ((retval = tulip_read_macaddr(sc)) < 0) {
	printf(", %s%s pass %d.%d", sc->tulip_boardid,
	     tulip_chipdescs[sc->tulip_chipid],
	      (sc->tulip_revinfo & 0xF0) >> 4, sc->tulip_revinfo & 0x0F);
	printf(": can't read ENET ROM (why=%d) (", retval);
	for (idx = 0; idx < 32; idx++)
	    printf("%02x", sc->tulip_rombuf[idx]);
	printf(", address unknown\n");
    } else {
	int (*intr_rtn)(void *) = tulip_intr_normal;

	if (sc->tulip_features & TULIP_HAVE_SHAREDINTR)
	    intr_rtn = tulip_intr_shared;

	if ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {
	    pci_intr_handle_t intrhandle;
	    const char *intrstr;

	    if (pci_intr_map(pa, &intrhandle)) {
		printf(": couldn't map interrupt\n");
		return;
	    }

	    intrstr = pci_intr_string(pa->pa_pc, intrhandle);
	    sc->tulip_ih = pci_intr_establish(pa->pa_pc, intrhandle, IPL_NET,
					      intr_rtn, sc, self->dv_xname);
	    if (sc->tulip_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
		    printf(" at %s", intrstr);
		printf("\n");
		return;
	    }

	    printf(", %s%s pass %d.%d%s: %s, address %s\n",
		   sc->tulip_boardid,
		   tulip_chipdescs[sc->tulip_chipid],
		   (sc->tulip_revinfo & 0xF0) >> 4,
			sc->tulip_revinfo & 0x0F,
			(sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))
			== TULIP_HAVE_ISVSROM ? " (invalid EESPROM checksum)" : "",
		   intrstr, ether_sprintf(sc->tulip_enaddr));
	}

	ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_MULTICAST;
	ifp->if_ioctl = tulip_ifioctl;
	ifp->if_start = tulip_ifstart;
	ifp->if_watchdog = tulip_ifwatchdog;
	ifp->if_timer = 1;

	(*sc->tulip_boardsw->bd_media_probe)(sc);
	ifmedia_init(&sc->tulip_ifmedia, 0,
	    tulip_ifmedia_change, tulip_ifmedia_status);
	sc->tulip_flags &= ~TULIP_DEVICEPROBE;
	tulip_ifmedia_add(sc);

	tulip_reset(sc);

	if_attach(ifp);
	ether_ifattach(ifp);
    }
}
@


1.136
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.135 2016/04/13 10:34:32 mpi Exp $	*/
d1284 1
a1284 1
		sc->tulip_if.if_flags &= ~(IFF_UP|IFF_RUNNING);
@


1.135
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.134 2015/12/08 13:34:22 tedu Exp $	*/
a3559 1
    sc->tulip_if.if_opackets += xmits;
@


1.134
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.133 2015/12/08 06:12:56 dlg Exp $	*/
a4587 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.133
log
@dont need to repeatedly set if_start to the same function.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.132 2015/11/25 11:20:38 mpi Exp $	*/
d4574 1
a4574 1
	ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;
@


1.132
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.131 2015/11/25 03:09:59 dlg Exp $	*/
a2887 1
    sc->tulip_if.if_start = tulip_ifstart;	/* so the setup packet gets queued */
a3036 1
	sc->tulip_if.if_start = tulip_ifstart;
a3959 1
	sc->tulip_if.if_start = tulip_ifstart;
a3988 1
	sc->tulip_if.if_start = tulip_ifstart;
a4018 1
	sc->tulip_if.if_start = tulip_ifstart;
a4028 1
	sc->tulip_if.if_start = tulip_ifstart;
@


1.131
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.130 2015/11/24 17:11:39 mpi Exp $	*/
a55 1
#include <net/netisr.h>
@


1.130
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.129 2015/11/24 13:33:17 mpi Exp $	*/
d413 1
a413 1
    sc->tulip_if.if_flags &= ~IFF_OACTIVE;
d621 1
a621 1
	sc->tulip_if.if_flags |= IFF_OACTIVE;
d970 1
a970 1
	sc->tulip_if.if_flags |= IFF_OACTIVE;
d3038 1
a3038 1
	sc->tulip_if.if_flags &= ~IFF_OACTIVE;
d3161 1
a3161 1
	    sc->tulip_if.if_flags |= IFF_OACTIVE;
d3553 1
a3553 1
	    sc->tulip_if.if_flags &= ~IFF_OACTIVE;
d3962 1
a3962 1
	sc->tulip_if.if_flags |= IFF_OACTIVE;
d3992 1
a3992 1
	sc->tulip_if.if_flags |= IFF_OACTIVE;
@


1.129
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.128 2015/11/23 23:34:42 dlg Exp $	*/
a55 1
#include <net/if_dl.h>
@


1.128
log
@you cant touch m_pkthdr in between ifq_deq_begin and ifq_deq_commit.

TULIP_SETCTX() does though. this moves that call after ifq_deq_commit.

problem reported (with great detail) and fix tested by ricardo mestre
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.127 2015/11/20 03:35:23 dlg Exp $	*/
a55 1
#include <net/if_types.h>
@


1.127
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.126 2015/11/04 00:10:50 dlg Exp $	*/
a3261 3
#if defined(DIAGNOSTIC)
		TULIP_SETCTX(me, NULL);
#endif
a3281 3
#if defined(DIAGNOSTIC)
	    TULIP_SETCTX(me, NULL);
#endif
a3316 3
#if defined(DIAGNOSTIC)
	    TULIP_SETCTX(me, NULL);
#endif
a3907 2
    TULIP_SETCTX(m, map);
    map = NULL;
d3915 3
@


1.126
log
@use IFQ_IS_EMPTY to see if if_snd is empty, not IF_IS_EMPTY
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.124 2015/10/25 13:04:28 mpi Exp $	*/
a3802 1
    int error;
a3803 4
#ifdef DIAGNOSTIC
    struct mbuf *ombuf = m;
#endif
    int compressed = 0;
d3856 16
a3871 40
    error = bus_dmamap_load_mbuf(sc->tulip_dmatag, map, m, BUS_DMA_NOWAIT);
    if (error != 0) {
	if (error == EFBIG) {
	    /*
	     * The packet exceeds the number of transmit buffer
	     * entries that we can use for one packet, so we have
	     * to recopy it into one mbuf and then try again.
	     */
	    struct mbuf *tmp;
	    if (!notonqueue) {
#ifdef DIAGNOSTIC
		if (IFQ_IS_EMPTY(&ifp->if_snd))
			panic("%s: if_snd queue empty", ifp->if_xname);
#endif
		IFQ_DEQUEUE(&ifp->if_snd, tmp);
#ifdef DIAGNOSTIC
		if (tmp != ombuf)
		    panic("tulip_txput: different mbuf dequeued!");
#endif
	    }
	    compressed = 1;
	    m = tulip_mbuf_compress(m);
	    if (m == NULL) {
#if defined(TULIP_DEBUG)
		sc->tulip_dbg.dbg_txput_finishes[2]++;
#endif
		tulip_free_txmap(sc, map);
		goto finish;
	    }
	    error = bus_dmamap_load_mbuf(sc->tulip_dmatag, map, m, BUS_DMA_NOWAIT);
	}
	if (error != 0) {
	    printf(TULIP_PRINTF_FMT ": unable to load tx map, "
		   "error = %d\n", TULIP_PRINTF_ARGS, error);
#if defined(TULIP_DEBUG)
	    sc->tulip_dbg.dbg_txput_finishes[3]++;
#endif
	    tulip_free_txmap(sc, map);
	    goto finish;
	}
d3873 1
d3924 2
a3925 13
    if (!compressed && !notonqueue) {
	/* remove the mbuf from the queue */
	struct mbuf *tmp;
#ifdef DIAGNOSTIC
	if (IFQ_IS_EMPTY(&ifp->if_snd))
	    panic("%s: if_snd queue empty", ifp->if_xname);
#endif
	IFQ_DEQUEUE(&ifp->if_snd, tmp);
#ifdef DIAGNOSTIC
	if (tmp != ombuf)
	    panic("tulip_txput: different mbuf dequeued!");
#endif
    }
d4162 1
d4169 2
a4170 3
	while (!IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	    struct mbuf *m, *m0;
	    IFQ_POLL(&sc->tulip_if.if_snd, m);
d4173 4
a4176 4
	    if ((m0 = tulip_txput(sc, m, 0)) != NULL) {
		if (m0 != m)
		    /* should not happen */
		    printf("tulip_if_start: txput failed!\n");
@


1.125
log
@replace the ifqueues used for tulip_txq and _rxq with mbuf_lists.
@
text
@d3872 1
a3872 1
		if (IF_IS_EMPTY(&ifp->if_snd))
d3956 1
a3956 1
	if (IF_IS_EMPTY(&ifp->if_snd))
@


1.124
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.123 2015/06/26 11:50:39 kettenis Exp $	*/
a3053 1
    IFQ_SET_MAXLEN(&sc->tulip_txq, TULIP_TXDESCS);
d3060 1
a3060 1
	IF_DEQUEUE(&sc->tulip_txq, m);
d3098 1
a3098 1
	IF_DEQUEUE(&sc->tulip_rxq, m);
d3198 1
a3198 1
	if (fillok && IF_LEN(&sc->tulip_rxq) < TULIP_RXQ_TARGET)
d3219 1
a3219 1
	    if (IF_IS_EMPTY(&sc->tulip_rxq))
d3222 1
a3222 1
	    IF_DEQUEUE(&sc->tulip_rxq, ms);
d3256 1
a3256 1
	    IF_DEQUEUE(&sc->tulip_rxq, ms);
d3267 1
a3267 1
		IF_DEQUEUE(&sc->tulip_rxq, me->m_next);
d3434 1
a3434 1
	    IF_ENQUEUE(&sc->tulip_rxq, ms);
d3437 1
a3437 1
	if (IF_LEN(&sc->tulip_rxq) >= TULIP_RXQ_TARGET)
d3493 1
a3493 1
		IF_DEQUEUE(&sc->tulip_txq, m);
d3966 1
a3966 1
    IF_ENQUEUE(&sc->tulip_txq, m);
d4473 3
@


1.123
log
@There is no excuse for using dma_alloc(9) when a bus_dma_tag_t is available.

deraadt@@ thinks this isn't worth it, but reyk@@ and mlarkin@@ tested it anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.122 2015/06/25 18:35:48 deraadt Exp $	*/
a4148 1
    struct ifaddr *ifa = (struct ifaddr *)data;
a4158 10
	switch(ifa->ifa_addr->sa_family) {
	case AF_INET: {
	    arp_ifinit(&sc->tulip_ac, ifa);
	    break;
	}

	default: {
	    break;
	}
	}
@


1.122
log
@Ensure the setup block is DMA reachable.
tested by reyk, mlarkin, others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.121 2015/06/24 09:40:54 mpi Exp $	*/
d4088 2
a4089 1
    bcopy(sc->tulip_setupdata, sc->tulip_setupdma, sizeof(sc->tulip_setupdata));
a4359 2
    sc->tulip_setupdma = dma_alloc(sizeof(sc->tulip_setupdata), PR_WAITOK);

d4361 1
a4361 1
     * Allocate dmamap for setup descriptor
d4363 3
a4365 8
    error = bus_dmamap_create(sc->tulip_dmatag, TULIP_SETUP, 2,
	TULIP_SETUP, 0, BUS_DMA_NOWAIT, &sc->tulip_setupmap);
    if (error == 0) {
	error = bus_dmamap_load(sc->tulip_dmatag, sc->tulip_setupmap,
	    sc->tulip_setupdma, TULIP_SETUP, NULL, BUS_DMA_NOWAIT);
	if (error)
	    bus_dmamap_destroy(sc->tulip_dmatag, sc->tulip_setupmap);
    }
@


1.121
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.120 2015/05/15 11:36:30 mpi Exp $	*/
d52 1
d4088 1
a4088 2
    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,
	  sizeof(sc->tulip_setupbuf));
d4359 2
d4364 2
a4365 3
    error = bus_dmamap_create(sc->tulip_dmatag, sizeof(sc->tulip_setupbuf), 2,
			      sizeof(sc->tulip_setupbuf), 0, BUS_DMA_NOWAIT,
			      &sc->tulip_setupmap);
d4368 1
a4368 2
				sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf),
				NULL, BUS_DMA_NOWAIT);
@


1.120
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.119 2015/04/01 13:35:32 mpi Exp $	*/
a3329 1
	ifp->if_ipackets++;
@


1.119
log
@Remove annoying comment mentionning ether_output().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.118 2015/03/14 03:38:48 jsg Exp $	*/
d3183 1
a3239 4
#if defined(TULIP_DEBUG)
		    sc->tulip_dbg.dbg_rxintrs++;
		    sc->tulip_dbg.dbg_rxpktsperintr[cnt]++;
#endif
d3241 1
a3241 2
		    TULIP_PERFEND(rxintr);
		    return;
a3287 10

#if NBPFILTER > 0
	    if (sc->tulip_bpf != NULL) {
		if (me == ms) {
		    bpf_tap(sc->tulip_if.if_bpf, mtod(ms, caddr_t),
		        total_len, BPF_DIRECTION_IN);
		} else
		    bpf_mtap(sc->tulip_if.if_bpf, ms, BPF_DIRECTION_IN);
	    }
#endif
d3371 1
a3371 2
		ms->m_pkthdr.rcvif = ifp;
		ether_input_mbuf(ifp, ms);
d3376 1
a3376 2
		m0->m_pkthdr.rcvif = ifp;
		ether_input_mbuf(ifp, m0);
d3442 2
@


1.118
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.117 2014/12/22 02:28:52 tedu Exp $	*/
a4219 3
 */
/*
 * These routines gets called at device spl (from ether_output).
@


1.117
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.116 2014/09/08 06:24:13 jsg Exp $	*/
a70 1
#include <dev/pci/pcidevs.h>
@


1.116
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.115 2014/07/22 13:12:11 mpi Exp $	*/
a4175 1
#ifdef INET
a4179 1
#endif /* INET */
@


1.115
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.114 2014/04/22 14:41:03 mpi Exp $	*/
a56 1
#include <net/route.h>
@


1.114
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.113 2014/04/19 12:25:03 henning Exp $	*/
a64 1
#ifdef INET
a65 4
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#endif

@


1.113
log
@another questionable "optimization": de used tulip_ifstart_one instead
of tulip_ifstart if the sendqueue was empty, but only if altq wasn't
compiled in (i. e., that's a _compile time_ decision and not based on
wether altq was actually used).
just use tulip_ifstart all the time, as before in our regular kernels.
kill tulip_ifstart_one completely.
makes sense to sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.111 2013/08/07 01:06:34 bluhm Exp $	*/
d4226 1
a4226 1
 * goes wrong.  when altq is used, it is changed to peek-and-dequeue.
@


1.112
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@a217 1
void tulip_ifstart_one(struct ifnet *ifp);
a4256 6
#ifdef ALTQ
	if (0) /* don't switch to the one packet mode */
#else
	if (IFQ_IS_EMPTY(&sc->tulip_if.if_snd))
#endif
	    sc->tulip_if.if_start = tulip_ifstart_one;
a4259 18
}

void
tulip_ifstart_one(struct ifnet * const ifp)
{
    TULIP_PERFSTART(ifstart_one)
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);

    if ((sc->tulip_if.if_flags & IFF_RUNNING)
	    && !IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	struct mbuf *m, *m0;
	IFQ_POLL(&sc->tulip_if.if_snd, m);
	if (m != NULL && (m0 = tulip_txput(sc, m, 0)) != NULL)
	    if (m0 != m)
		/* should not happen */
		printf("tulip_if_start_one: txput failed!\n");
    }
    TULIP_PERFEND(ifstart_one);
@


1.111
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.110 2013/06/04 19:10:52 miod Exp $	*/
d2889 1
d2919 6
a2924 3
	ETHER_FIRST_MULTI(step, &sc->tulip_ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {
a2930 5
		} else {
		    sc->tulip_flags |= TULIP_ALLMULTI;
		    sc->tulip_flags &= ~(TULIP_WANTHASHONLY|TULIP_WANTHASHPERFECT);
		    break;
		}
d2932 1
d2968 3
d2975 1
a2975 1
	    ETHER_FIRST_MULTI(step, &sc->tulip_ac, enm);
a2976 1
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, 6) == 0) {
a2985 4
		} else {
		    sc->tulip_flags |= TULIP_ALLMULTI;
		    break;
		}
@


1.110
log
@Prevent panic'ing on alpha after ifconfig'ing up an unplugged de interface,
by making tulip_txput() aware of whether or not the mbuf it is processing
is in if_snq or not, rather than abusing the TULIP_TXPROBE_ACTIVE flag.

Found the hard way by kurt@@, tested on AlphaServer 1000A, I've been sleeping
on this diff for about 3 years.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.109 2011/07/07 20:42:56 henning Exp $	*/
a67 1
#include <netinet/in_var.h>
@


1.109
log
@use IF_LEN/IFQ_LEN to access and ifqueue's length field. ryan ok
with this nothing in the tree fiddles if ifqueue internals any more, of
course except if.c and if.h (and some altq)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.108 2011/07/06 02:42:27 henning Exp $	*/
d215 1
a215 1
struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);
d295 1
a295 1
    if ((m = tulip_txput(sc, m)) != NULL)
d3228 4
d3821 1
a3821 1
tulip_txput(tulip_softc_t * const sc, struct mbuf *m)
d3831 1
d3833 1
d3896 9
a3904 12
	    /*
	     * tulip_mbuf_compress() frees the original mbuf.
	     * thus, we have to remove the mbuf from the queue
	     * before calling it.
	     * we don't have to worry about space shortage
	     * after compressing the mbuf since the compressed
	     * mbuf will take only two segs.
	     */
	     if (compressed) {
		 /* should not happen */
#ifdef TULIP_DEBUG
		 printf("tulip_txput: compress called twice!\n");
a3905 1
		 goto finish;
a3906 3
	    IFQ_DEQUEUE(&ifp->if_snd, tmp);
	    if (tmp != ombuf)
		 panic("tulip_txput: different mbuf dequeued!");
d3978 1
a3978 1
    if (!compressed && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
d3981 4
d3986 1
d3989 1
d4254 1
a4254 1
	    if ((m0 = tulip_txput(sc, m)) != NULL) {
d4282 1
a4282 1
	if (m != NULL && (m0 = tulip_txput(sc, m)) != NULL)
@


1.108
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.107 2011/04/03 15:36:02 jasper Exp $	*/
d3208 1
a3208 1
	if (fillok && sc->tulip_rxq.ifq_len < TULIP_RXQ_TARGET)
d3461 1
a3461 1
	if (sc->tulip_rxq.ifq_len >= TULIP_RXQ_TARGET)
@


1.107
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.106 2010/09/20 07:40:38 deraadt Exp $	*/
d3064 1
a3064 1
    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;
@


1.106
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.105 2010/04/08 00:23:53 tedu Exp $	*/
d3610 1
a3610 1
    csr &= (1 << (sizeof(tulip_status_bits)/sizeof(tulip_status_bits[0]))) - 1;
@


1.105
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.104 2009/10/02 23:11:56 deraadt Exp $	*/
a226 1
void tulip_shutdown(void *arg);
a4522 10
tulip_shutdown(void *arg)
{
    tulip_softc_t * const sc = arg;
    TULIP_CSR_WRITE(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
		   33MHz that comes to two microseconds but wait a
		   bit longer anyways) */
}

void
a4693 5

	sc->tulip_ats = shutdownhook_establish(tulip_shutdown, sc);
	if (sc->tulip_ats == NULL)
	    printf("%s: warning: couldn't establish shutdown hook\n",
		   sc->tulip_xname);
@


1.104
log
@remove trash left in debug changes; lindroos@@nls.fi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.103 2009/08/13 14:24:47 jasper Exp $	*/
a49 1
#include <sys/proc.h>	/* only for declaration of wakeup() used by vm.h */
@


1.103
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.102 2009/06/19 14:13:41 naddy Exp $	*/
a323 1
		       TULIP_PRINTF_ARGS);
@


1.102
log
@Tidy up allocation of transmit DMA maps and generalize it to also
tidy up allocation of receive DMA maps.  Previously the driver was
using DMA maps off the free list without fully allocating them, in
order to save two or three lines releasing them on error paths.
This was causing it to reuse a map already in use when under load.
From NetBSD.

Revert a workaround against a NULL pointer dereference on alpha
when invoking bus_dmaamp_sync.

All submitted by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.101 2008/11/28 02:44:17 brad Exp $	*/
d140 1
a140 1
	0, "de", DV_IFNET
@


1.101
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.100 2008/10/02 20:21:14 brad Exp $	*/
d230 4
d2866 24
d3079 1
a3079 1
	sc->tulip_txmaps[sc->tulip_txmaps_free++] = map;
d3117 1
a3117 1
	sc->tulip_rxmaps[sc->tulip_rxmaps_free++] = map;
a3272 3
#ifdef __alpha__
		if (map->_dm_window != NULL)
#endif
d3275 1
a3275 1
		sc->tulip_rxmaps[sc->tulip_rxmaps_free++] = map;
d3298 1
a3298 1
	    sc->tulip_rxmaps[sc->tulip_rxmaps_free++] = map;
d3346 1
a3346 1
	    sc->tulip_rxmaps[sc->tulip_rxmaps_free++] = map;
d3427 3
a3429 3
	    if (sc->tulip_rxmaps_free > 0)
		map = sc->tulip_rxmaps[--sc->tulip_rxmaps_free];
	    else {
a3520 3
#ifdef __alpha__
		    if (map->_dm_window != NULL)
#endif
d3522 1
a3522 1
		    sc->tulip_txmaps[sc->tulip_txmaps_free++] = map;
d3869 1
a3869 1
    if (sc->tulip_txmaps_free == 0) {
d3875 2
a3876 2
    if (sc->tulip_txmaps_free > 0)
	map = sc->tulip_txmaps[sc->tulip_txmaps_free-1];
d3917 1
d3928 1
d3948 1
a3976 1
    --sc->tulip_txmaps_free;		/* commit to using the dmamap */
d4435 2
a4436 1
     * Allocate dmamaps for each transmit descriptors
d4439 1
a4439 1
	while (error == 0 && sc->tulip_txmaps_free < TULIP_TXDESCS) {
d4442 1
a4442 1
		sc->tulip_txmaps[sc->tulip_txmaps_free++] = map;
d4445 2
a4446 3
	    while (sc->tulip_txmaps_free > 0)
		bus_dmamap_destroy(sc->tulip_dmatag,
				   sc->tulip_txmaps[--sc->tulip_txmaps_free]);
d4460 2
a4461 1
     * Allocate dmamaps for each receive descriptors
d4464 1
a4464 1
	while (error == 0 && sc->tulip_rxmaps_free < TULIP_RXDESCS) {
d4467 1
a4467 1
		sc->tulip_rxmaps[sc->tulip_rxmaps_free++] = map;
d4470 2
a4471 3
	    while (sc->tulip_rxmaps_free > 0)
		bus_dmamap_destroy(sc->tulip_dmatag,
				   sc->tulip_rxmaps[--sc->tulip_rxmaps_free]);
@


1.100
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.99 2008/03/04 19:43:18 miod Exp $	*/
d4185 3
a4187 9
    case SIOCADDMULTI:
    case SIOCDELMULTI: {
	/*
	 * Update multicast listeners
	 */
	if (cmd == SIOCADDMULTI)
	    error = ether_addmulti(ifr, &sc->tulip_ac);
	else
	    error = ether_delmulti(ifr, &sc->tulip_ac);
d4189 2
a4190 2
	if (error == ENETRESET) {
	    if (ifp->if_flags & IFF_RUNNING) {
a4192 2
	    }
	    error = 0;
d4194 1
a4194 15
	break;
    }

    case SIOCSIFMTU:
	/*
	 * Set the interface MTU.
	 */
	if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU)
	    error = EINVAL;
	else if (ifp->if_mtu != ifr->ifr_mtu)
	    ifp->if_mtu = ifr->ifr_mtu;
	break;

    default:
	error = ether_ioctl(ifp, &sc->tulip_ac, cmd, data);
@


1.99
log
@Add a workaround against a NULL pointer dereference on alpha when
invoking bus_dmaamp_sync, until the cause of the problem is found.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.98 2007/09/19 02:32:57 brad Exp $	*/
a4154 5
    if ((error = ether_ioctl(ifp, &sc->tulip_ac, cmd, data)) > 0) {
	    splx(s);
	    return (error);
    }

d4216 1
a4216 2
	error = ENOTTY;
	break;
@


1.98
log
@Remove unused tulip_21041_media_noprobe() function and tulip_21041np_boardsw
struct.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.97 2007/02/14 00:53:48 jsg Exp $	*/
d3245 3
d3496 3
@


1.97
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.96 2006/07/08 04:15:36 brad Exp $	*/
a160 1
void tulip_21041_media_noprobe(tulip_softc_t * const sc);
a946 9
tulip_21041_media_noprobe(tulip_softc_t * const sc)
{
    sc->tulip_if.if_baudrate = 10000000;
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT
	|TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;
    sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
}

void
a1100 7
    tulip_media_select,
    tulip_21041_media_poll
};

static const tulip_boardsw_t tulip_21041np_boardsw = {
    TULIP_21041_GENERIC,
    tulip_21041_media_noprobe,
@


1.96
log
@print the chipset revision too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.95 2006/07/08 03:58:09 brad Exp $	*/
d1295 1
a1295 1
	    /* FALL THROUGH */
d1341 1
a1341 1
	    /* FALL THROUGH */
@


1.95
log
@shorten dmesg entry from two lines to one.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.94 2006/07/08 03:10:22 brad Exp $	*/
a4680 1
#if defined(TULIP_DEBUG)
a4681 3
#else
	     "",
#endif
a4714 1
#if defined(TULIP_DEBUG)
a4715 3
#else
		   "",
#endif
@


1.94
log
@tulip_pci_(probe/attach) -> tulip_(probe/attach)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.93 2006/07/08 02:54:43 brad Exp $	*/
a88 12
/*
 * This turns on all sort of debugging stuff and makes the
 * driver much larger.
 */
#if 0
#define TULIP_DEBUG
#endif

#if 0
#define TULIP_PERFSTATS
#endif

a3516 5
#if defined(TULIP_DEBUG)
		} else {
		    printf(TULIP_PRINTF_FMT ": tx_intr: failed to dequeue mbuf?!?\n",
			TULIP_PRINTF_ARGS);
#endif
d4593 2
a4594 3
	printf("\n");
	printf("de%d: not configured; 21140 pass 1.1 required (%d.%d found)\n",
	       unit, revinfo >> 4, revinfo & 0x0f);
d4664 1
a4664 1
	printf("error initing bus_dma: %d\n", retval);
d4680 7
d4690 1
a4690 10
	printf("\n");
	printf(TULIP_PRINTF_FMT ": %s%s pass %d.%d address unknown",
	       TULIP_PRINTF_ARGS,
	       sc->tulip_boardid,
#if defined(TULIP_DEBUG)
 tulip_chipdescs[sc->tulip_chipid],
#else
 "",
#endif
	       (sc->tulip_revinfo & 0xF0) >> 4, sc->tulip_revinfo & 0x0F);
d4702 1
a4702 1
		printf(", couldn't map interrupt\n");
d4705 1
d4710 1
a4710 1
		printf(", couldn't establish interrupt");
d4716 13
a4728 1
	    printf(": %s", intrstr);
d4730 1
a4730 1
	printf("\n");
a4740 13

	printf(TULIP_PRINTF_FMT ": %s%s pass %d.%d%s address %s\n",
	       TULIP_PRINTF_ARGS, sc->tulip_boardid,
#if defined(TULIP_DEBUG)
	       tulip_chipdescs[sc->tulip_chipid],
#else
	       "",
#endif
	(sc->tulip_revinfo & 0xF0) >> 4,  
	  sc->tulip_revinfo & 0x0F,
	    (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))
		== TULIP_HAVE_ISVSROM ? " (invalid EESPROM checksum)" : "",
	ether_sprintf(sc->tulip_enaddr));
@


1.93
log
@remove splnet from attach routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.92 2006/06/01 09:45:48 brad Exp $	*/
d144 2
a145 2
int tulip_pci_probe(struct device *parent, void *match, void *aux);
void tulip_pci_attach(struct device * const parent, struct device * const self, void * const aux);
d148 1
a148 1
	sizeof(tulip_softc_t), tulip_pci_probe, tulip_pci_attach
a234 1
void tulip_attach(tulip_softc_t * const sc);
a4402 40
void
tulip_attach(tulip_softc_t * const sc)
{
    struct ifnet * const ifp = &sc->tulip_if;

    ifp->if_flags = IFF_BROADCAST|IFF_SIMPLEX|IFF_NOTRAILERS|IFF_MULTICAST;
    ifp->if_ioctl = tulip_ifioctl;
    ifp->if_start = tulip_ifstart;
    ifp->if_watchdog = tulip_ifwatchdog;
    ifp->if_timer = 1;

    printf(
	   TULIP_PRINTF_FMT ": %s%s pass %d.%d%s address %s\n",
	   TULIP_PRINTF_ARGS,
	   sc->tulip_boardid,
#if defined(TULIP_DEBUG)
	   tulip_chipdescs[sc->tulip_chipid],
#else
	"",
#endif
	   (sc->tulip_revinfo & 0xF0) >> 4,
	   sc->tulip_revinfo & 0x0F,
	   (sc->tulip_features & (TULIP_HAVE_ISVSROM|TULIP_HAVE_OKSROM))
		 == TULIP_HAVE_ISVSROM ? " (invalid EESPROM checksum)" : "",
	   ether_sprintf(sc->tulip_enaddr));

    (*sc->tulip_boardsw->bd_media_probe)(sc);
    ifmedia_init(&sc->tulip_ifmedia, 0,
		 tulip_ifmedia_change,
		 tulip_ifmedia_status);
    sc->tulip_flags &= ~TULIP_DEVICEPROBE;
    tulip_ifmedia_add(sc);

    tulip_reset(sc);

    IFQ_SET_READY(&ifp->if_snd);
    if_attach(ifp);
    ether_ifattach(ifp);
}

d4542 1
a4542 1
tulip_pci_probe(struct device *parent, void *match, void *aux)
d4568 1
a4568 1
tulip_pci_attach(struct device * const parent, struct device * const self, void * const aux)
d4572 1
d4743 30
a4772 1
	tulip_attach(sc);
@


1.92
log
@de-static and formatting.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.91 2006/05/28 00:04:24 jason Exp $	*/
a4751 1
	int s;
a4782 1
	s = splnet();
a4783 1
	splx(s);
@


1.91
log
@unknown ioctl is ENOTTY not EINVAL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.90 2006/05/09 20:58:56 brad Exp $	*/
d144 103
a246 22
static void tulip_mii_autonegotiate(tulip_softc_t * const sc, const unsigned phyaddr);
static int tulip_intr_shared(void *arg);
static int tulip_intr_normal(void *arg);
static void tulip_init(tulip_softc_t * const sc);
static void tulip_reset(tulip_softc_t * const sc);
static void tulip_ifstart_one(struct ifnet *ifp);
static void tulip_ifstart(struct ifnet *ifp);
static struct mbuf *tulip_txput(tulip_softc_t * const sc, struct mbuf *m);
static void tulip_txput_setup(tulip_softc_t * const sc);
static void tulip_rx_intr(tulip_softc_t * const sc);
static void tulip_addr_filter(tulip_softc_t * const sc);
static unsigned tulip_mii_readreg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno);
static void tulip_mii_writereg(tulip_softc_t * const sc, unsigned devaddr, unsigned regno, unsigned data);
static int tulip_mii_map_abilities(tulip_softc_t * const sc, unsigned abilities);
static tulip_media_t tulip_mii_phy_readspecific(tulip_softc_t * const sc);
static int tulip_srom_decode(tulip_softc_t * const sc);
static int tulip_ifmedia_change(struct ifnet * const ifp);
static void tulip_ifmedia_status(struct ifnet * const ifp, struct ifmediareq *req);

static void
tulip_timeout_callback(
    void *arg)
d249 3
a251 1
    int s = splnet();
d263 2
a264 3
static void
tulip_timeout(
    tulip_softc_t * const sc)
d272 2
a273 3
static int
tulip_txprobe(
    tulip_softc_t * const sc)
d276 1
d286 1
a286 1
	return 0;
d310 1
a310 1
    return 1;
d313 2
a314 4
static void
tulip_media_set(
    tulip_softc_t * const sc,
    tulip_media_t media)
d323 1
a323 1
    if (mi->mi_type == TULIP_MEDIAINFO_SIA || (sc->tulip_features & TULIP_HAVE_SIANWAY)) {
a324 1
    }
d330 4
a333 6
	if (TULIP_CSR_READ(sc, csr_command) & (TULIP_CMD_RXRUN|TULIP_CMD_TXRUN)) {
	    printf(TULIP_PRINTF_FMT ": warning: board is running (FD).\n",
		   TULIP_PRINTF_ARGS);
	}
	if ((TULIP_CSR_READ(sc, csr_command) & TULIP_CMD_FULLDUPLEX) == 0) {
	    printf(TULIP_PRINTF_FMT ": setting full duplex.\n",
a334 1
	}
d352 1
a352 1
	} else {
a353 1
	}
d415 1
a415 1
	if (sc->tulip_flags & TULIP_TRYNWAY) {
d417 1
a417 1
	} else if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {
d430 2
a431 4
static void
tulip_linkup(
    tulip_softc_t * const sc,
    tulip_media_t media)
d443 1
a443 1
	if (TULIP_IS_MEDIA_FD(sc->tulip_media)) {
d445 1
a445 1
	} else if (sc->tulip_chipid != TULIP_21041 || (sc->tulip_flags & TULIP_DIDNWAY) == 0) {
a446 1
	}
d457 1
a457 1
    if (sc->tulip_flags & TULIP_INRESET) {
d459 1
a459 1
    } else if (sc->tulip_probe_media != sc->tulip_media) {
d468 2
a469 3
static void
tulip_media_print(
    tulip_softc_t * const sc)
d488 2
a489 3
static tulip_link_status_t
tulip_media_link_monitor(
    tulip_softc_t * const sc)
d499 1
a499 1
	return TULIP_LINK_UNKNOWN;
d509 1
a509 1
	return TULIP_LINK_UP;
d536 1
a536 1
		    return TULIP_LINK_UP;
d544 1
a544 1
		    return TULIP_LINK_DOWN;
d557 1
a557 1
	    return TULIP_LINK_UNKNOWN;
d568 1
a568 1
	    return TULIP_LINK_UNKNOWN;
d575 2
a576 3
    } else if (mi->mi_type == TULIP_MEDIAINFO_SYM) {
	return TULIP_LINK_UNKNOWN;
    }
d584 1
a584 1
	    return TULIP_LINK_UP;
d591 1
a591 1
    return TULIP_LINK_DOWN;
d594 2
a595 4
static void
tulip_media_poll(
    tulip_softc_t * const sc,
    tulip_mediapoll_event_t event)
d843 2
a844 3
static void
tulip_media_select(
    tulip_softc_t * const sc)
d860 1
a860 1
    } else {
a861 1
    }
d864 2
a865 4
static void
tulip_21040_mediainfo_init(
    tulip_softc_t * const sc,
    tulip_media_t media)
d877 1
a877 1
    if (media == TULIP_MEDIA_AUIBNC || media == TULIP_MEDIA_UNKNOWN) {
a878 1
    }
d880 1
a880 1
    if (media == TULIP_MEDIA_UNKNOWN) {
a881 1
    }
d884 2
a885 3
static void
tulip_21040_media_probe(
    tulip_softc_t * const sc)
a887 1
    return;
d890 2
a891 3
static void
tulip_21040_10baset_only_media_probe(
    tulip_softc_t * const sc)
d898 2
a899 3
static void
tulip_21040_10baset_only_media_select(
    tulip_softc_t * const sc)
d912 2
a913 3
static void
tulip_21040_auibnc_only_media_probe(
    tulip_softc_t * const sc)
d921 2
a922 3
static void
tulip_21040_auibnc_only_media_select(
    tulip_softc_t * const sc)
d949 2
a950 3
static void
tulip_21041_mediainfo_init(
    tulip_softc_t * const sc)
d960 2
a961 3
static void
tulip_21041_media_noprobe(
    tulip_softc_t * const sc)
d969 2
a970 3
static void
tulip_21041_media_probe(
    tulip_softc_t * const sc)
d979 2
a980 4
static void
tulip_21041_media_poll(
    tulip_softc_t * const sc,
    const tulip_mediapoll_event_t event)
d1054 1
a1054 1
	if (sia_status & TULIP_SIASTS_OTHERRXACTIVITY) {
d1056 1
a1056 1
	} else {
a1057 1
	}
d1112 1
a1112 1
    if (sc->tulip_probe_media == TULIP_MEDIA_AUI) {
d1114 1
a1114 1
    } else {
a1115 1
    }
d1192 2
a1193 3
static tulip_media_t
tulip_mii_phy_readspecific(
    tulip_softc_t * const sc)
d1216 1
a1216 1
	return TULIP_MEDIA_UNKNOWN;
d1222 1
a1222 1
	    return TULIP_MEDIA_UNKNOWN;
d1250 1
a1250 1
    return table[idx];
d1253 2
a1254 4
static unsigned
tulip_mii_get_phyaddr(
    tulip_softc_t * const sc,
    unsigned offset)
d1263 1
a1263 1
	    return phyaddr;
d1269 2
a1270 2
	    return TULIP_MII_NOPHY;
	return 0;
d1272 1
a1272 1
    return TULIP_MII_NOPHY;
d1275 2
a1276 4
static int
tulip_mii_map_abilities(
    tulip_softc_t * const sc,
    unsigned abilities)
d1279 1
a1279 1
    if (abilities & PHYSTS_100BASETX_FD) {
d1281 1
a1281 1
    } else if (abilities & PHYSTS_100BASET4) {
d1283 1
a1283 1
    } else if (abilities & PHYSTS_100BASETX) {
d1285 1
a1285 1
    } else if (abilities & PHYSTS_10BASET_FD) {
d1287 1
a1287 1
    } else if (abilities & PHYSTS_10BASET) {
d1289 1
a1289 1
    } else {
d1291 1
a1291 1
	return 0;
d1294 1
a1294 1
    return 1;
d1297 2
a1298 4
static void
tulip_mii_autonegotiate(
    tulip_softc_t * const sc,
    const unsigned phyaddr)
d1399 2
a1400 3
static void
tulip_2114x_media_preset(
    tulip_softc_t * const sc)
d1418 1
a1418 1
	    if (mi->mi_type == TULIP_MEDIAINFO_MII) {
d1420 1
a1420 1
	    } else if (mi->mi_type == TULIP_MEDIAINFO_GPR
d1424 1
a1424 1
	    } else if (mi->mi_type == TULIP_MEDIAINFO_SIA) {
a1425 1
	    }
d1482 2
a1483 4
static void
tulip_null_media_poll(
    tulip_softc_t * const sc,
    tulip_mediapoll_event_t event)
d1494 3
a1496 7
static void
tulip_21140_mediainit(
    tulip_softc_t * const sc,
    tulip_media_info_t * const mip,
    tulip_media_t const media,
    unsigned gpdata,
    unsigned cmdmode)
d1504 2
a1505 3
static void
tulip_21140_evalboard_media_probe(
    tulip_softc_t * const sc)
d1519 1
a1519 1
    if ((TULIP_CSR_READ(sc, csr_gp) & TULIP_GP_EB_OK100) != 0) {
d1521 1
a1521 1
    } else {
a1522 1
    }
d1547 2
a1548 3
static void
tulip_21140_accton_media_probe(
    tulip_softc_t * const sc)
d1564 1
a1564 1
    if ((gpdata & TULIP_GP_EN1207_UTP_INIT) == 0) {
d1566 2
a1567 2
    } else {
	if ((gpdata & TULIP_GP_EN1207_BNC_INIT) == 0) {
d1569 1
a1569 1
        } else {
a1570 1
        }
d1599 2
a1600 3
static void
tulip_21140_smc9332_media_probe(
    tulip_softc_t * const sc)
d1622 1
a1622 1
	} else if ((csr & TULIP_GP_SMC_9332_OK10) == 0) {
d1624 1
a1624 1
	} else {
a1625 1
	}
d1653 2
a1654 3
static void
tulip_21140_cogent_em100_media_probe(
    tulip_softc_t * const sc)
d1699 2
a1700 3
static void
tulip_21140_znyx_zx34x_media_probe(
    tulip_softc_t * const sc)
d1755 2
a1756 3
static void
tulip_2114x_media_probe(
    tulip_softc_t * const sc)
d1777 2
a1778 3
static void
tulip_delay_300ns(
    tulip_softc_t * const sc)
d1785 2
a1786 3
static void
tulip_srom_idle(
    tulip_softc_t * const sc)
d1807 2
a1808 4

static void
tulip_srom_read(
    tulip_softc_t * const sc)
d1833 1
a1833 1
	    }
d1853 2
a1854 5
static void
tulip_mii_writebits(
    tulip_softc_t * const sc,
    unsigned data,
    unsigned bits)
d1864 1
a1864 1
	if (thisbit != lastbit) {
a1865 1
	}
d1872 2
a1873 4
static void
tulip_mii_turnaround(
    tulip_softc_t * const sc,
    unsigned cmd)
d1882 1
a1882 1
    } else {
a1883 1
    }
d1888 2
a1889 3
static unsigned
tulip_mii_readbits(
    tulip_softc_t * const sc)
d1904 1
a1904 1
    return data;
d1907 2
a1908 5
static unsigned
tulip_mii_readreg(
    tulip_softc_t * const sc,
    unsigned devaddr,
    unsigned regno)
d1925 1
a1925 1
    return data;
d1928 3
a1930 6
static void
tulip_mii_writereg(
    tulip_softc_t * const sc,
    unsigned devaddr,
    unsigned regno,
    unsigned data)
d1948 2
a1949 3
static void
tulip_identify_dec_nic(
    tulip_softc_t * const sc)
d1963 2
a1964 3
static void
tulip_identify_znyx_nic(
    tulip_softc_t * const sc)
d2035 1
a2035 1
	} else {
a2036 1
	}
d2054 2
a2055 3
static void
tulip_identify_smc_nic(
    tulip_softc_t * const sc)
d2068 1
a2068 1
	} else if (sc->tulip_features & (TULIP_HAVE_BASEROM|TULIP_HAVE_SLAVEDROM)) {
d2070 1
a2070 1
	} else {
a2071 1
	}
d2101 2
a2102 3
static void
tulip_identify_cogent_nic(
    tulip_softc_t * const sc)
d2131 1
a2131 1
    } else if (sc->tulip_chipid == TULIP_21040) {
a2132 1
    }
d2135 2
a2136 3
static void
tulip_identify_accton_nic(
    tulip_softc_t * const sc)
d2164 2
a2165 3
static void
tulip_identify_asante_nic(
    tulip_softc_t * const sc)
d2221 2
a2222 3
static void
tulip_identify_compex_nic(
    tulip_softc_t * const sc)
d2248 3
a2250 5
	} else if(sc->tulip_features & TULIP_HAVE_SLAVEDINTR) {
	    printf("\nCannot find master device for de%d interrupts",
		   sc->tulip_unit);
	}
    } else {
d2252 1
a2252 1
    }
a2253 1
    return;
d2256 2
a2257 3
static int
tulip_srom_decode(
    tulip_softc_t * const sc)
d2278 1
a2278 1
	return 0;
d2391 1
a2391 1
		    if (data & TULIP_SROM_2114X_NOINDICATOR) {
d2393 1
a2393 1
		    } else {
d2576 1
a2576 1
		    if (data & TULIP_SROM_2114X_NOINDICATOR) {
d2578 1
a2578 1
		    } else {
d2594 1
a2594 1
    return mi - sc->tulip_mediainfo;
d2618 2
a2619 3
static int
tulip_read_macaddr(
    tulip_softc_t * const sc)
d2687 1
a2687 1
		return -6;
d2702 1
a2702 1
		return -4;
d2709 1
a2709 1
	    return -4;
d2712 1
a2712 1
	    return -4;
d2751 1
a2751 1
			return -5;
d2769 1
a2769 1
		return 0;
d2779 1
a2779 1
	return -3;
d2786 1
a2786 1
	return -2;
d2803 1
a2803 1
	return -1;
d2818 1
a2818 1
    return 0;
d2821 2
a2822 3
static void
tulip_ifmedia_add(
    tulip_softc_t * const sc)
d2848 2
a2849 3
static int
tulip_ifmedia_change(
    struct ifnet * const ifp)
d2864 1
a2864 1
		return 0;
d2871 1
a2871 1
    return 0;
d2877 2
a2878 4
static void
tulip_ifmedia_status(
    struct ifnet * const ifp,
    struct ifmediareq *req)
d2892 2
a2893 3
static void
tulip_addr_filter(
    tulip_softc_t * const sc)
d3029 2
a3030 3
static void
tulip_reset(
    tulip_softc_t * const sc)
d3152 2
a3153 3
static void
tulip_init(
    tulip_softc_t * const sc)
d3168 1
a3168 1
	    if (sc->tulip_flags & TULIP_ALLMULTI) {
d3170 1
a3170 1
	    } else {
a3171 1
	    }
d3193 2
a3194 3
static void
tulip_rx_intr(
    tulip_softc_t * const sc)
d3318 1
a3318 1
	    if (eop->d_status & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxOVERFLOW|TULIP_DSTS_RxWATCHDOG)) {
d3320 1
a3320 1
	    } else {
d3429 1
a3429 1
	    if (sc->tulip_rxmaps_free > 0) {
d3431 1
a3431 1
	    } else {
d3478 2
a3479 4

static int
tulip_tx_intr(
    tulip_softc_t * const sc)
d3608 1
a3608 1
    return descs;
d3611 2
a3612 4
static void
tulip_print_abnormal_interrupt(
    tulip_softc_t * const sc,
    u_int32_t csr)
d3627 1
a3627 1
		if (sc->tulip_cmdmode & TULIP_CMD_STOREFWD) {
d3629 1
a3629 1
		} else {
d3641 2
a3642 4
static void
tulip_intr_handler(
    tulip_softc_t * const sc,
    int *progress_p)
d3653 1
a3653 1
	    if (sc->tulip_flags & TULIP_NOMESSAGES) {
d3655 1
a3655 1
	    } else {
d3722 1
a3722 1
	    if (sc->tulip_flags & TULIP_NOMESSAGES) {
d3724 1
a3724 1
	    } else {
d3743 2
a3744 3
static int
tulip_intr_shared(
    void *arg)
d3755 1
a3755 1
    return progress;
d3758 2
a3759 3
static int
tulip_intr_normal(
    void *arg)
d3769 1
a3769 1
    return progress;
d3772 2
a3773 3
static struct mbuf *
tulip_mbuf_compress(
    struct mbuf *m)
d3784 1
a3784 1
		return NULL;
d3796 1
a3796 1
	if (mlen == MHLEN) {
d3798 1
a3798 1
	} else {
a3799 1
	}
d3813 1
a3813 1
	} else {
a3814 1
	}
d3823 1
a3823 1
    return m0;
d3826 2
a3827 4
static struct mbuf *
tulip_txput(
    tulip_softc_t * const sc,
    struct mbuf *m)
d3882 1
a3882 1
    if (sc->tulip_txmaps_free > 0) {
d3884 1
a3884 1
    } else {
d4043 1
a4043 1
	return NULL;
d4084 1
a4084 1
    return m;
d4087 2
a4088 3
static void
tulip_txput_setup(
    tulip_softc_t * const sc)
d4172 2
a4173 5
static int
tulip_ifioctl(
    struct ifnet * ifp,
    u_long cmd,
    caddr_t data)
d4185 2
a4186 2
		splx(s);
		return (error);
d4192 1
a4195 1
	    tulip_init(sc);
a4201 1
	    tulip_init(sc);
d4256 1
a4256 1
    return error;
d4269 2
a4270 3
static void
tulip_ifstart(
    struct ifnet * const ifp)
d4303 2
a4304 3
static void
tulip_ifstart_one(
    struct ifnet * const ifp)
d4321 2
a4322 3
static void
tulip_ifwatchdog(
    struct ifnet *ifp)
d4404 2
a4405 3
static void
tulip_attach(
    tulip_softc_t * const sc)
d4444 3
a4446 6
static int
tulip_busdma_allocmem(
    tulip_softc_t * const sc,
    size_t size,
    bus_dmamap_t *map_p,
    tulip_desc_t **desc_p)
d4477 1
a4477 1
    return error;
d4480 2
a4481 3
static int
tulip_busdma_init(
    tulip_softc_t * const sc)
d4547 1
a4547 1
    return error;
d4550 2
a4551 5
static void
tulip_initcsrs(
    tulip_softc_t * const sc,
    bus_addr_t csr_base,
    size_t csr_size)
d4571 3
a4573 6
static void
tulip_initring(
    tulip_softc_t * const sc,
    tulip_ringinfo_t * const ri,
    tulip_desc_t *descs,
    int ndescs)
d4582 2
a4583 5
static int
tulip_pci_probe(
    struct device *parent,
    void *match,
    void *aux)
d4588 1
a4588 1
	return 0;
d4593 1
a4593 1
	return 2;
d4595 1
a4595 1
    return 0;
d4598 1
a4598 11
static void tulip_pci_attach(struct device * const parent, struct device * const self, void * const aux);

struct cfattach de_ca = {
    sizeof(tulip_softc_t), tulip_pci_probe, tulip_pci_attach
};

struct cfdriver de_cd = {
    0, "de", DV_IFNET
};

static void
d4608 1
a4608 1
static void
@


1.90
log
@fix non-ALTQ case.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.89 2006/05/06 02:57:30 brad Exp $	*/
d4285 2
a4286 2
    default: {
	error = EINVAL;
a4287 1
    }
@


1.89
log
@restore ALTQ support which was lost with rev 1.87
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.88 2006/03/25 22:41:44 djm Exp $	*/
d149 1
d4330 6
d4342 19
d4420 1
d4430 1
@


1.88
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.87 2005/11/07 00:03:16 brad Exp $	*/
a148 1
static void tulip_ifstart_one(struct ifnet *ifp);
d3866 3
d3929 20
d4017 8
d4296 6
d4317 9
a4325 5
	while (sc->tulip_if.if_snd.ifq_head != NULL) {
	    struct mbuf *m;
	    IF_DEQUEUE(&sc->tulip_if.if_snd, m);
	    if ((m = tulip_txput(sc, m)) != NULL) {
		IF_PREPEND(&sc->tulip_if.if_snd, m);
a4328 2
	if (sc->tulip_if.if_snd.ifq_head == NULL)
	    sc->tulip_if.if_start = tulip_ifstart_one;
a4334 17
tulip_ifstart_one(
    struct ifnet * const ifp)
{
    TULIP_PERFSTART(ifstart_one)
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);

    if ((sc->tulip_if.if_flags & IFF_RUNNING)
	    && sc->tulip_if.if_snd.ifq_head != NULL) {
	struct mbuf *m;
	IF_DEQUEUE(&sc->tulip_if.if_snd, m);
	if ((m = tulip_txput(sc, m)) != NULL)
	    IF_PREPEND(&sc->tulip_if.if_snd, m);
    }
    TULIP_PERFEND(ifstart_one);
}

static void
a4393 1
    TULIP_PERFMERGE(sc, perf_ifstart_one_cycles);
a4402 1
    TULIP_PERFMERGE(sc, perf_ifstart_one);
d4452 1
@


1.87
log
@add bus_dma support.

From NetBSD

tested on i386/alpha.

ok martin@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.86 2005/10/01 13:58:10 martin Exp $	*/
d3325 5
a3329 4
		if (me == ms)
		    bpf_tap(sc->tulip_if.if_bpf, mtod(ms, caddr_t), total_len);
		else
		    bpf_mtap(sc->tulip_if.if_bpf, ms);
d3547 1
a3547 1
			bpf_mtap(sc->tulip_if.if_bpf, m);
@


1.87.2.1
log
@MFC:
Fix by brad@@

restore ALTQ support which was lost with rev 1.87
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.87 2005/11/07 00:03:16 brad Exp $	*/
a3865 3
    struct ifnet *ifp = &sc->tulip_if;
    struct mbuf *ombuf = m;
    int compressed = 0;
a3925 20
	    struct mbuf *tmp;
	    /*
	     * tulip_mbuf_compress() frees the original mbuf.
	     * thus, we have to remove the mbuf from the queue
	     * before calling it.
	     * we don't have to worry about space shortage
	     * after compressing the mbuf since the compressed
	     * mbuf will take only two segs.
	     */
	     if (compressed) {
		 /* should not happen */
#ifdef TULIP_DEBUG
		 printf("tulip_txput: compress called twice!\n");
#endif
		 goto finish;
	    }
	    IFQ_DEQUEUE(&ifp->if_snd, tmp);
	    if (tmp != ombuf)
		 panic("tulip_txput: different mbuf dequeued!");
	    compressed = 1;
a3993 8
    if (!compressed && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
	/* remove the mbuf from the queue */
	struct mbuf *tmp;
	IFQ_DEQUEUE(&ifp->if_snd, tmp);
	if (tmp != ombuf)
	    panic("tulip_txput: different mbuf dequeued!");
    }

a4264 6
 * the original dequeueing policy is dequeue-and-prepend if something
 * goes wrong.  when altq is used, it is changed to peek-and-dequeue.
 * the modification becomes a bit complicated since tulip_txput() might
 * copy and modify the mbuf passed.
 */
/*
d4280 5
a4284 9
	while (!IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	    struct mbuf *m, *m0;
	    IFQ_POLL(&sc->tulip_if.if_snd, m);
	    if (m == NULL)
		break;
	    if ((m0 = tulip_txput(sc, m)) != NULL) {
		if (m0 != m)
		    /* should not happen */
		    printf("tulip_if_start: txput failed!\n");
d4288 1
a4288 5
#ifdef ALTQ
	if (0) /* don't switch to the one packet mode */
#else
	if (IFQ_IS_EMPTY(&sc->tulip_if.if_snd))
#endif
d4303 5
a4307 7
	    && !IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	struct mbuf *m, *m0;
	IFQ_POLL(&sc->tulip_if.if_snd, m);
	if (m != NULL && (m0 = tulip_txput(sc, m)) != NULL)
	    if (m0 != m)
		/* should not happen */
		printf("tulip_if_start_one: txput failed!\n");
a4431 1
    IFQ_SET_READY(&ifp->if_snd);
@


1.86
log
@oops, the include was just doing fine there
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.85 2005/10/01 13:49:50 martin Exp $	*/
a72 1
#include <uvm/uvm_extern.h>
d2942 5
a2946 1
		    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));
d2960 5
a2964 1
	    sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));
d2967 5
a2971 1
		sp[hash >> 4] |= FILT_BO(1 << (hash & 0xF));
d2973 9
a2981 3
		sp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]);
		sp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]);
		sp[41] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);
d2995 9
a3003 3
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]);
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]);
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[2]);
d3014 9
a3022 3
	    *sp++ = FILT_BO(0xFFFF);
	    *sp++ = FILT_BO(0xFFFF);
	    *sp++ = FILT_BO(0xFFFF);
d3028 9
a3036 3
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]);
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]);
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[2]);
d3074 2
a3075 12
    TULIP_CSR_WRITE(sc, csr_txlist, TULIP_KVATOPHYS(sc, &sc->tulip_txinfo.ri_first[0]));
    TULIP_CSR_WRITE(sc, csr_rxlist, TULIP_KVATOPHYS(sc, &sc->tulip_rxinfo.ri_first[0]));
#ifdef __powerpc__
    TULIP_CSR_WRITE(sc, csr_busmode,
		    (4 << 2)	/* Descriptor skip length */
		    |TULIP_BUSMODE_CACHE_ALIGN8
		    |TULIP_BUSMODE_READMULTIPLE
		    /*
		    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0)
		    */
		    );
#else
d3080 2
a3081 2
		    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_DESC_BIGENDIAN : 0));
#endif
d3089 1
d3094 3
d3104 4
a3107 1
	di->d_status = 0; /* no swabbing necessary -dsr */
d3119 7
a3125 12
	di->d_status = 0; /* no swabbing necessary -dsr */
	{
	    tulip_desc_bitfield_t u;

	    u.f = DESC_BO(di->u.f); /* copy the bitfields */
	    u.bd_length1 = 0;
	    u.bd_length2 = 0;
	    di->u.f = DESC_BO(u.f);
	}
	di->d_addr1 = 0; /* no swabbing necessary -dsr */
	di->d_addr2 = 0; /* no swabbing necessary -dsr */
    }
d3127 1
d3132 3
d3228 2
d3249 2
a3250 1
	if ((DESC_BO(((volatile tulip_desc_t *) eop)->d_status) & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {
d3257 1
a3257 1
	    if (DESC_BO(((volatile tulip_desc_t *) eop)->d_status) & TULIP_DSTS_OWNER)
d3264 1
a3264 1
	    while ((DESC_BO(((volatile tulip_desc_t *) eop)->d_status) & TULIP_DSTS_RxLASTDESC) == 0) {
d3267 2
a3268 1
		if (eop == ri->ri_nextout || (DESC_BO(((volatile tulip_desc_t *) eop)->d_status) & TULIP_DSTS_OWNER)) {
d3292 7
d3309 1
a3309 1
	total_len = ((DESC_BO(eop->d_status) >> 16) & 0x7FFF) - 4;
d3311 1
a3311 1
		&& ((DESC_BO(eop->d_status) & TULIP_DSTS_ERRSUM) == 0)) {
d3313 10
d3335 1
a3335 1
	    if (DESC_BO(eop->d_status) & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxOVERFLOW|TULIP_DSTS_RxWATCHDOG)) {
d3340 1
a3340 1
		if (DESC_BO(eop->d_status) & TULIP_DSTS_RxTOOLONG) {
d3344 2
a3345 2
		if (DESC_BO(eop->d_status) & TULIP_DSTS_RxBADCRC) {
		    if (DESC_BO(eop->d_status) & TULIP_DSTS_RxDRBBLBIT) {
d3362 7
d3445 31
a3475 8
	    tulip_desc_bitfield_t u;
	    u.f = DESC_BO ( ri->ri_nextout->u.f );
	    u.bd_length1 = TULIP_RX_BUFLEN;
	    ri->ri_nextout->u.f = DESC_BO ( u.f );

	    ri->ri_nextout->d_addr1 =
		    DESC_BO(TULIP_KVATOPHYS(sc, mtod(ms, caddr_t)));
	    ri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);
d3508 3
a3510 1
	if (DESC_BO(((volatile tulip_desc_t *) ri->ri_nextin)->d_status) & TULIP_DSTS_OWNER)
d3513 3
a3515 6
	{
		tulip_desc_bitfield_t u;

		u.f = DESC_BO(ri->ri_nextin->u.f); /* copy the bitfields */
		d_flag = u.bd_flag;
	}
d3525 1
d3527 1
a3527 1
		if (d_flag & TULIP_DFLAG_TxINVRSFILT)
d3538 1
a3538 1
		const u_int32_t d_status = DESC_BO(ri->ri_nextin->d_status);
d3541 3
a3613 2
	ri->ri_free++;
	descs++;
d3864 2
a3865 4
    struct mbuf *m0;
    struct ifnet *ifp = &sc->tulip_if;
    struct mbuf *ombuf = m;
    int compressed = 0;
d3873 1
a3894 1
 again:
a3896 1
    m0 = m;
d3899 31
a3929 27
    do {
	int len = m0->m_len;
	caddr_t addr = mtod(m0, caddr_t);
	unsigned clsize = PAGE_SIZE - (((u_long) addr) & PAGE_MASK);

	while (len > 0) {
	    unsigned slen = min(len, clsize);
	    segcnt++;
	    if (segcnt > TULIP_MAX_TXSEG) {
		/*
		 * The packet exceeds the number of transmit buffer
		 * entries that we can use for one packet, so we have
		 * recopy it into one mbuf and then try again.
		 */
		struct mbuf *tmp;
		/*
		 * tulip_mbuf_compress() frees the original mbuf.
		 * thus, we have to remove the mbuf from the queue
		 * before calling it.
		 * we don't have to worry about space shortage
		 * after compressing the mbuf since the compressed
		 * mbuf will take only two segs.
		 */
		if (compressed) {
		    /* should not happen */
#ifdef TULIP_DEBUG
		    printf("tulip_txput: compress called twice!\n");
d3931 1
a3931 10
		    goto finish;
		}
		IFQ_DEQUEUE(&ifp->if_snd, tmp);
		if (tmp != ombuf)
		    panic("tulip_txput: different mbuf dequeued!");
		compressed = 1;
		m = tulip_mbuf_compress(m);
		if (m == NULL)
		    goto finish;
		goto again;
d3933 9
a3941 46
	    if (segcnt & 1) {
		if (--freedescs == 0) {
		    /*
		     * See if there's any unclaimed space in the
		     * transmit ring.
		     */
		    if ((freedescs += tulip_tx_intr(sc)) == 0) {
			/*
			 * There's no more room but since nothing
			 * has been committed at this point, just
			 * show output is active, put back the
			 * mbuf and return.
			 */
			sc->tulip_flags |= TULIP_WANTTXSTART;
			goto finish;
		    }
		}
		eop = nextout;
		if (++nextout == ri->ri_last)
		    nextout = ri->ri_first;
		{
		    tulip_desc_bitfield_t u;
		    u.f = DESC_BO(eop->u.f); /* copy the bitfields */
		    u.bd_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
		    u.bd_length1 = slen;

		    eop->d_status = DESC_BO(d_status);
		    eop->d_addr1 = DESC_BO( TULIP_KVATOPHYS(sc, addr) );
		    eop->u.f = DESC_BO(u.f); /* copy the bitfields */
		}
	    } else {
		/*
		 *  Fill in second half of descriptor
		 */
		eop->d_addr2 = DESC_BO(TULIP_KVATOPHYS(sc, addr));
		{
		    tulip_desc_bitfield_t u;
		    u.f = DESC_BO(eop->u.f); /* copy the bitfields */
		    u.bd_length2 = slen;
		    eop->u.f = DESC_BO(u.f); /* copy the bitfields */
		}
	    }
	    d_status = TULIP_DSTS_OWNER;
	    len -= slen;
	    addr += slen;
	    clsize = PAGE_SIZE;
d3943 46
a3988 2
    } while ((m0 = m0->m_next) != NULL);

a3993 8
    if (!compressed && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
	/* remove the mbuf from the queue */
	struct mbuf *tmp;
	IFQ_DEQUEUE(&ifp->if_snd, tmp);
	if (tmp != ombuf)
	    panic("tulip_txput: different mbuf dequeued!");
    }

d4002 2
a4003 13
    nextout->d_status = 0; /* doesn't need swab - dsr */

    /*
     * If we only used the first segment of the last descriptor,
     * make sure the second segment will not be used.
     */
    if (segcnt & 1) {
	tulip_desc_bitfield_t u;
	u.f = DESC_BO(eop->u.f); /* copy the bitfields */
	u.bd_length2 = 0;
	eop->d_addr2 = 0; /* no swab necessary - dsr */
	eop->u.f = DESC_BO(u.f);
    }
d4009 1
a4009 7
    {
	tulip_desc_bitfield_t u;

	u.f = DESC_BO(eop->u.f); /* copy the bitfields */
	u.bd_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;
	eop->u.f = DESC_BO(u.f);
    }
d4016 9
a4024 7
    {
	tulip_desc_bitfield_t u;

	u.f = DESC_BO(ri->ri_nextout->u.f); /* copy the bitfields */
	u.bd_flag |= TULIP_DFLAG_TxFIRSTSEG;
	ri->ri_nextout->u.f = DESC_BO(u.f);
	ri->ri_nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);
d4026 2
d4051 3
d4065 3
d4125 15
a4139 23
    {
	u_int32_t d_flag;
	tulip_desc_bitfield_t u;

	u.f = DESC_BO(nextout->u.f); /* copy the bitfields */
	d_flag = u.bd_flag;

	d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
	d_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG
	    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;
	if (sc->tulip_flags & TULIP_WANTHASHPERFECT)
	    d_flag |= TULIP_DFLAG_TxHASHFILT;
	else if (sc->tulip_flags & TULIP_WANTHASHONLY)
	    d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;


	u.bd_flag = d_flag;
	u.bd_length1 = sizeof(sc->tulip_setupbuf);
	u.bd_length2 = 0;

	nextout->u.f = DESC_BO(u.f);
	nextout->d_addr1 = DESC_BO(TULIP_KVATOPHYS(sc, sc->tulip_setupbuf));
	nextout->d_addr2 = 0; /* no need to swab */
d4141 2
d4155 7
a4161 2
    ri->ri_nextout->d_status = 0; /* doesn't need swab - dsr */
    nextout->d_status = DESC_BO(TULIP_DSTS_OWNER);
a4264 6
 * The original dequeueing policy is dequeue-and-prepend if something
 * goes wrong.  When altq is used, it is changed to peek-and-dequeue.
 * The modification becomes a bit complicated since tulip_txput() might
 * copy and modify the mbuf passed.
 */
/*
d4280 5
a4284 9
	while (!IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	    struct mbuf *m, *m0;
	    IFQ_POLL(&sc->tulip_if.if_snd, m);
	    if (m == NULL)
		break;
	    if ((m0 = tulip_txput(sc, m)) != NULL) {
		if (m0 != m)
		    /* should not happen */
		    printf("tulip_if_start: txput failed!\n");
d4288 2
a4289 1
	sc->tulip_if.if_start = tulip_ifstart_one;
d4303 5
a4307 7
	    && !IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	struct mbuf *m, *m0;
	IFQ_POLL(&sc->tulip_if.if_snd, m);
	if (m != NULL && (m0 = tulip_txput(sc, m)) != NULL)
	    if (m0 != m)
		/* should not happen */
		printf("tulip_if_start_one: txput failed!\n");
a4431 1
    IFQ_SET_READY(&ifp->if_snd);
d4436 110
d4581 1
a4581 7
    {
	tulip_desc_bitfield_t u;

	u.f = DESC_BO( ri->ri_last[-1].u.f );
	u.bd_flag = TULIP_DFLAG_ENDRING;
	ri->ri_last[-1].u.f = DESC_BO(u.f);
    }
d4705 1
d4735 6
@


1.85
log
@fix some comments and put if_devar.h include where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.84 2005/09/25 18:13:16 brad Exp $	*/
a80 1
#include <dev/pci/if_devar.h>
d138 1
@


1.84
log
@shuffle some stuff around
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.83 2005/09/25 17:45:15 brad Exp $	*/
d81 1
d92 1
a92 1
 * This turns on all sort of debugging stuff and make the
a138 1
#include <dev/pci/if_devar.h>
d698 1
a698 1
     * switch to another media if we tried this one enough.
d4199 3
a4201 3
 * the original dequeueing policy is dequeue-and-prepend if something
 * goes wrong.  when altq is used, it is changed to peek-and-dequeue.
 * the modification becomes a bit complicated since tulip_txput() might
@


1.83
log
@remove TULIP_PCI_ATTACH_ARGS and TULIP_SHUTDOWN_ARGS
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.82 2005/09/25 02:23:39 brad Exp $	*/
d104 34
a231 2
#define	TULIP_SIAGEN_WATCHDOG	0

a281 1
#define	TULIP_GPR_CMDBITS	(TULIP_CMD_PORTSELECT|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER|TULIP_CMD_TXTHRSHLDCTL)
a1762 2
#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)

a1833 2
#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)

a1942 5
#define	tulip_mchash(mca)	(ether_crc32_le(mca, 6) & 0x1FF)
#define	tulip_srom_crcok(databuf)	( \
    ((ether_crc32_le(databuf, 126) & 0xFFFFU) ^ 0xFFFFU) == \
     ((databuf)[126] | ((databuf)[127] << 8)))

a2701 1

a4425 15
/*
 * This is the PCI configuration support.  Since the 21040 is available
 * on both EISA and PCI boards, one must be careful in how defines the
 * 21040 in the config file.
 */

#define	PCI_CFID	0x00	/* Configuration ID */
#define	PCI_CFCS	0x04	/* Configurtion Command/Status */
#define	PCI_CFRV	0x08	/* Configuration Revision */
#define	PCI_CFLT	0x0c	/* Configuration Latency Timer */
#define	PCI_CBIO	0x10	/* Configuration Base IO Address */
#define	PCI_CBMA	0x14	/* Configuration Base Memory Address */
#define	PCI_CFIT	0x3c	/* Configuration Interrupt */
#define	PCI_CFDA	0x40	/* Configuration Driver Area */

a4470 7
#define	PCI_CONF_WRITE(r, v)	pci_conf_write(pa->pa_pc, pa->pa_tag, (r), (v))
#define	PCI_CONF_READ(r)	pci_conf_read(pa->pa_pc, pa->pa_tag, (r))
#define	PCI_GETBUSDEVINFO(sc)	do { \
	(sc)->tulip_pci_busno = parent; \
	(sc)->tulip_pci_devno = pa->pa_device; \
    } while (0)

@


1.82
log
@remove more indirection through typedef's and macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.81 2005/09/25 00:22:59 brad Exp $	*/
a4419 2
#define	TULIP_PCI_ATTACH_ARGS	struct device * const parent, struct device * const self, void * const aux
#define	TULIP_SHUTDOWN_ARGS	void *arg
d4439 1
a4439 1
static void tulip_pci_attach(TULIP_PCI_ATTACH_ARGS);
d4450 1
a4450 1
tulip_shutdown(TULIP_SHUTDOWN_ARGS)
d4460 1
a4460 1
tulip_pci_attach(TULIP_PCI_ATTACH_ARGS)
@


1.81
log
@- delint: zero sized array initalisation is a gccism
- move timeout_set() from tulip_attach() to tulip_pci_attach()
- free -> freedescs in tulip_txput()
- remove duplicate flag setting in tulip_2114x_media_preset()
  TULIP_MEDIA_10BASET_FD switch case
- some cleaning

reduces the delta from the NetBSD driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.80 2005/09/08 01:29:19 brad Exp $	*/
d112 2
a113 2
static tulip_intrfunc_t tulip_intr_shared(void *arg);
static tulip_intrfunc_t tulip_intr_normal(void *arg);
d116 2
a117 2
static ifnet_ret_t tulip_ifstart_one(struct ifnet *ifp);
static ifnet_ret_t tulip_ifstart(struct ifnet *ifp);
a128 1
/* static void tulip_21140_map_media(tulip_softc_t *sc); */
d135 1
a135 1
    tulip_spl_t s = TULIP_RAISESPL();
d144 1
a144 1
    TULIP_RESTORESPL(s);
d225 1
a225 1
	    loudprintf(TULIP_PRINTF_FMT ": setting full duplex.\n",
d430 1
a430 1
		loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation changed: 0x%04x -> 0x%04x\n",
d1260 1
a1260 1
		loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation disabled\n",
d1273 1
a1273 1
		loudprintf(TULIP_PRINTF_FMT "(phy%d): oops: enable autonegotiation failed: 0x%04x\n",
d1276 1
a1276 1
		loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation restarted: 0x%04x (ad=0x%04x)\n",
d1295 1
a1295 1
		loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation timeout: sts=0x%04x, ctl=0x%04x\n",
d1306 1
a1306 1
	    loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation complete: 0x%04x (sts=0x%04x)\n",
d1322 1
a1322 1
    loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation failure: state = %d\n",
d3253 1
a3253 1
		    TULIP_BPF_TAP(sc, mtod(ms, caddr_t), total_len);
d3255 1
a3255 1
		    TULIP_BPF_MTAP(sc, ms);
d3281 1
a3281 1
		    printf(TULIP_PRINTF_FMT ": receive: " TULIP_EADDR_FMT ": %s\n",
d3283 1
a3283 1
			   TULIP_EADDR_ARGS(mtod(ms, u_char *) + 6),
d3440 1
a3440 1
			TULIP_BPF_MTAP(sc, m);
d3662 1
a3662 1
static tulip_intrfunc_t
d3678 1
a3678 1
static tulip_intrfunc_t
d4088 1
a4088 1
    ioctl_cmd_t cmd,
d4095 1
a4095 1
    tulip_spl_t s;
d4098 1
a4098 1
    s = TULIP_RAISESPL();
d4101 1
a4101 1
		TULIP_RESTORESPL(s);
d4172 1
a4172 1
    TULIP_RESTORESPL(s);
d4187 1
a4187 1
static ifnet_ret_t
d4217 1
a4217 1
static ifnet_ret_t
d4333 1
a4333 1
	   TULIP_PRINTF_FMT ": %s%s pass %d.%d%s address " TULIP_EADDR_FMT "\n",
d4345 1
a4345 1
	   TULIP_EADDR_ARGS(sc->tulip_enaddr));
a4358 4

#if NBPFILTER > 0
    TULIP_BPF_ATTACH(sc);
#endif
d4364 1
a4364 1
    tulip_csrptr_t csr_base,
d4478 1
a4478 1
    tulip_csrptr_t csr_base;
d4605 2
a4606 2
	tulip_spl_t s;
	tulip_intrfunc_t (*intr_rtn)(void *) = tulip_intr_normal;
d4637 1
a4637 1
	s = TULIP_RAISESPL();
d4639 1
a4639 1
	TULIP_RESTORESPL(s);
@


1.80
log
@add missing TULIP_STS_LINKFAIL flag in tulip_21041_media_probe().

From NetBSD rev 1.67 and verified to still be there in -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.79 2005/09/08 00:59:49 brad Exp $	*/
d213 1
a213 2
    if (mi->mi_type == TULIP_MEDIAINFO_SIA ||
      (sc->tulip_features & TULIP_HAVE_SIANWAY)) {
d221 3
a223 3
       if (TULIP_CSR_READ(sc, csr_command) & (TULIP_CMD_RXRUN|TULIP_CMD_TXRUN)) {
	printf(TULIP_PRINTF_FMT ": warning: board is running (FD).\n",
		TULIP_PRINTF_ARGS);
d596 1
a596 1
	    /* XXX check media status just to be sure */
d1071 1
a1071 1
	{ },				/* 100TX */
d1083 1
a1083 1
	{ },				/* 100T4 */
d1094 1
a1094 1
	{ },				/* 100T4 */
d1105 1
a1105 1
	{ },				/* 100T4 */
d1138 1
a1138 1
	   | tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);
a1374 1
	    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL;
d1926 1
a1926 1
    strlcpy(sc->tulip_boardid, "DEC ", sizeof sc->tulip_boardid);
d1943 1
a1943 1
    strlcpy(sc->tulip_boardid, "ZNYX ZX3XX ", sizeof sc->tulip_boardid);
d2039 1
a2039 1
    strlcpy(sc->tulip_boardid, "SMC ", sizeof sc->tulip_boardid);
d2044 1
a2044 1
	    strlcat(sc->tulip_boardid, "9332DST ", sizeof sc->tulip_boardid);
d2047 1
a2047 1
	    strlcat(sc->tulip_boardid, "9334BDT ", sizeof sc->tulip_boardid);
d2049 1
a2049 1
	    strlcat(sc->tulip_boardid, "9332BDT ", sizeof sc->tulip_boardid);
d2057 1
a2057 1
    strlcat(sc->tulip_boardid, "8432", sizeof sc->tulip_boardid);
d2084 1
a2084 1
    strlcpy(sc->tulip_boardid, "Cogent ", sizeof sc->tulip_boardid);
d2087 1
a2087 1
	    strlcat(sc->tulip_boardid, "EM100TX ", sizeof sc->tulip_boardid);
d2091 1
a2091 1
	    strlcat(sc->tulip_boardid, "EM110TX ", sizeof sc->tulip_boardid);
d2095 1
a2095 1
	    strlcat(sc->tulip_boardid, "EM100FX ", sizeof sc->tulip_boardid);
d2108 1
a2108 1
	    strlcat(sc->tulip_boardid, "EM440TX ", sizeof sc->tulip_boardid);
d2120 1
a2120 1
    strlcpy(sc->tulip_boardid, "ACCTON ", sizeof sc->tulip_boardid);
d2123 1
a2123 1
	    strlcat(sc->tulip_boardid, "EN1207 ", sizeof sc->tulip_boardid);
d2128 1
a2128 1
	    strlcat(sc->tulip_boardid, "EN1207TX ", sizeof sc->tulip_boardid);
d2133 1
a2133 1
	    strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2137 1
a2137 1
	  strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2150 1
a2150 1
    strlcpy(sc->tulip_boardid, "Asante ", sizeof sc->tulip_boardid);
d2234 1
a2234 1
		sc->tulip_unit);
d2736 1
a2736 1
			sizeof sc->tulip_boardid);
d3004 1
a3004 1
	&& sc->tulip_boardsw->bd_media_preset != NULL)
d3443 1
a3443 1
		m_freem(m);
d3759 1
a3759 1
    int segcnt, free;
d3798 1
a3798 1
    free = ri->ri_free;
d3839 1
a3839 1
		if (--free == 0) {
d3844 1
a3844 1
		    if ((free += tulip_tx_intr(sc)) == 0) {
a3947 2
    TULIP_CSR_WRITE(sc, csr_txpoll, 1);

d3952 1
a3952 1
    ri->ri_free = free;
d3957 1
d3980 1
a3980 1
 finish:
d3994 1
a4332 2
    timeout_set(&sc->tulip_stmo, tulip_timeout_callback, sc);

d4504 1
a4504 1
	        chipid = (revinfo >= 0x20) ? TULIP_21143 : TULIP_21142;
d4556 2
@


1.79
log
@make de(4) use ether_input_mbuf()

From thorpej NetBSD

ok krw@@ martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.78 2005/09/07 13:32:14 brad Exp $	*/
a782 1

d895 1
a895 1
    sc->tulip_intrmask |= TULIP_STS_LINKPASS;
@


1.78
log
@do not try to restore the spl level two times in a row.

ok martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.77 2005/09/06 16:03:40 brad Exp $	*/
a3175 1
	struct ether_header eh;
a3253 1
	    eh = *mtod(ms, struct ether_header *);
a3263 1
	    total_len -= sizeof(struct ether_header);
d3320 1
a3320 1
		if (!accept || total_len >= MHLEN) {
a3336 2
		ms->m_data += sizeof(struct ether_header);
		ms->m_len -= sizeof(struct ether_header);
d3339 1
a3339 1
		ether_input(ifp, &eh, ms);
d3341 2
a3342 5
		if (ms == me)
		    bcopy(mtod(ms, caddr_t) + sizeof(struct ether_header),
			  mtod(m0, caddr_t), total_len);
		else
		    m_copydata(ms, 0, total_len, mtod(m0, caddr_t));
d3345 1
a3345 1
		ether_input(ifp, &eh, m0);
@


1.77
log
@- fix up the ioctl handler and make it use ether_ioctl() too
- remove more unused code
- remove some of the macros to make this more readable

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.76 2005/09/06 00:41:41 brad Exp $	*/
a142 1
    TULIP_RESTORESPL(s);
@


1.76
log
@another round of removing ifdef crud from this driver.

ok krw@@ martin@@
@
text
@d1 2
a2 2
/*	$OpenBSD: if_de.c,v 1.75 2005/08/09 04:10:11 mickey Exp $	*/
/*	$NetBSD: if_de.c,v 1.45 1997/06/09 00:34:18 thorpej Exp $	*/
a633 7
#ifdef notyet
		if (sc->tulip_probe_state == TULIP_PROBE_FAILED)
		    break;
		if (sc->tulip_probe_media != tulip_mii_phy_readspecific(sc))
		    break;
		sc->tulip_probe_timeout = TULIP_IS_MEDIA_TP(sc->tulip_probe_media) ? 2500 : 300;
#endif
a731 4
#ifdef notyet
		if (sc->tulip_features & TULIP_HAVE_MII)
		    tulip_timeout(sc);
#endif
a873 9
#ifdef notyet
    if (sc->tulip_revinfo >= 0x20) {
	TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, 10BASET);
	TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, 10BASET_FD);
	TULIP_MEDIAINFO_SIA_INIT(sc, &mi[0], 21041P2, AUI);
	TULIP_MEDIAINFO_SIA_INIT(sc, &mi[1], 21041P2, BNC);
	return;
    }
#endif
a927 6
#ifdef notyet
	if (sc->tulip_revinfo >= 0x20) {
	    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;
	    sc->tulip_flags |= TULIP_DIDNWAY;
	}
#endif
a2346 8
#ifdef notdef
	if (blocks == 0) {
	    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, BNC); mi++;
	    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, AUI); mi++;
	    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET); mi++;
	    TULIP_MEDIAINFO_SIA_INIT(sc, mi, 21041, 10BASET_FD); mi++;
	}
#endif
a2900 1
#if defined(IFF_ALLMULTI)
a2901 1
#endif
d2923 1
a2923 1
	ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);
d2959 1
a2959 1
	    ETHER_FIRST_MULTI(step, TULIP_ETHERCOM(sc), enm);
a2987 1
#if defined(IFF_ALLMULTI)
a2989 1
#endif
a3385 3
#if defined(__mips__)
	    pci_sync_cache(sc->tulip_pc, (vm_offset_t)mtod(ms, caddr_t),TULIP_RX_BUFLEN);
#endif
a3891 3
#if defined(__mips__)
	    pci_sync_cache(sc->tulip_pc, (vm_offset_t)addr, slen);
#endif
d4010 1
a4010 1

a4048 3
#if defined(__mips__)
    pci_sync_cache(sc->tulip_pc, (vm_offset_t)sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));
#endif
d4113 5
d4125 1
a4125 1
	    TULIP_ARP_IFINIT(sc, ifa);
a4136 6
    case SIOCGIFADDR: {
	bcopy((caddr_t) sc->tulip_enaddr,
	      (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,
	      ETHER_ADDR_LEN);
	break;
    }
d4155 1
a4155 1
	    error = ether_addmulti(ifr, TULIP_ETHERCOM(sc));
d4157 1
a4157 1
	    error = ether_delmulti(ifr, TULIP_ETHERCOM(sc));
d4168 1
d4173 1
a4173 1
	if (ifr->ifr_mtu > ETHERMTU) {
d4175 2
a4176 3
	    break;
	}
	ifp->if_mtu = ifr->ifr_mtu;
a4178 12
#ifdef SIOCGADDRROM
    case SIOCGADDRROM: {
	error = copyout(sc->tulip_rombuf, ifr->ifr_data, sizeof(sc->tulip_rombuf));
	break;
    }
#endif
#ifdef SIOCGCHIPID
    case SIOCGCHIPID: {
	ifr->ifr_metric = (int) sc->tulip_chipid;
	break;
    }
#endif
d4373 1
a4373 1
    TULIP_ETHER_IFATTACH(sc);
a4410 14
#if defined(__mips__)
    tulip_desc_t *xdesc = descs;
    /*
     * Someone moved the descriptors into the softc struct.
     * Avoid cache line conflicts by aligning on cache line.
     */
    descs = (tulip_desc_t *)(roundup((int)descs, 16));
    if(xdesc != descs) {
	ndescs--;
    }
    pci_sync_cache(sc->tulip_pc, (vm_offset_t)descs, ndescs * sizeof(tulip_desc_t));
    descs = (tulip_desc_t *)TULIP_KVATOPHYS(sc, descs);
    descs = (tulip_desc_t *)PHYS_TO_UNCACHED((int)descs & 0x3fffffff);
#endif
@


1.75
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.74 2005/07/16 17:20:47 brad Exp $	*/
a39 1
#define	TULIP_HDR_DATA
a54 1
#if defined(SIOCSIFMEDIA) && !defined(TULIP_NOIFMEDIA)
a55 1
#endif
a81 1
#define	DEVAR_INCLUDE	"dev/pci/if_devar.h"
d86 1
a86 1
#if defined(__i386__) || defined(TULIP_EISA)
a101 4
#if 0
#define	TULIP_USE_SOFTINTR
#endif

d104 1
a104 1
#include DEVAR_INCLUDE
a126 1
#if defined(IFM_ETHER)
a128 1
#endif
a158 24
#if defined(TULIP_NEED_FASTTIMEOUT)
static void
tulip_fasttimeout_callback(
    void *arg)
{
    tulip_softc_t * const sc = arg;
    tulip_spl_t s = TULIP_RAISESPL();

    sc->tulip_flags &= ~TULIP_FASTTIMEOUTPENDING;
    (sc->tulip_boardsw->bd_media_poll)(sc, TULIP_MEDIAPOLL_FASTTIMER);
    TULIP_RESTORESPL(s);
}

static void
tulip_fasttimeout(
    tulip_softc_t * const sc)
{
    if (sc->tulip_flags & TULIP_FASTTIMEOUTPENDING)
	return;
    sc->tulip_flags |= TULIP_FASTTIMEOUTPENDING;
    timeout_add(&sc->tulip_ftmo, 1);
}
#endif

a199 3
#ifdef BIG_PACKET
#define TULIP_SIAGEN_WATCHDOG	(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)
#else
a200 1
#endif
a336 13
#if 0 /* XXX how does with work with ifmedia? */
    if ((sc->tulip_flags & TULIP_DIDNWAY) == 0) {
	if (sc->tulip_if.if_flags & IFF_FULLDUPLEX) {
	    if (TULIP_CAN_MEDIA_FD(media)
		    && sc->tulip_mediums[TULIP_FD_MEDIA_OF(media)] != NULL)
		media = TULIP_FD_MEDIA_OF(media);
	} else {
	    if (TULIP_IS_MEDIA_FD(media)
		    && sc->tulip_mediums[TULIP_HD_MEDIA_OF(media)] != NULL)
		media = TULIP_HD_MEDIA_OF(media);
	}
    }
#endif
a389 63
#if defined(TULIP_DO_GPR_SENSE)
static tulip_media_t
tulip_21140_gpr_media_sense(
    tulip_softc_t * const sc)
{
    tulip_media_t maybe_media = TULIP_MEDIA_UNKNOWN;
    tulip_media_t last_media = TULIP_MEDIA_UNKNOWN;
    tulip_media_t media;

    /*
     * If one of the media blocks contained a default media flag,
     * use that.
     */
    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
	const tulip_media_info_t *mi;
	/*
	 * Media is not supported (or is full-duplex).
	 */
	if ((mi = sc->tulip_mediums[media]) == NULL || TULIP_IS_MEDIA_FD(media))
	    continue;
	if (mi->mi_type != TULIP_MEDIAINFO_GPR)
	    continue;

	/*
	 * Remember the media is this is the "default" media.
	 */
	if (mi->mi_default && maybe_media == TULIP_MEDIA_UNKNOWN)
	    maybe_media = media;

	/*
	 * No activity mask?  Can't see if it is active if there's no mask.
	 */
	if (mi->mi_actmask == 0)
	    continue;

	/*
	 * Does the activity data match?
	 */
	if ((TULIP_CSR_READ(sc, csr_gp) & mi->mi_actmask) != mi->mi_actdata)
	    continue;

#if defined(TULIP_DEBUG)
	printf(TULIP_PRINTF_FMT ": gpr_media_sense: %s: 0x%02x & 0x%02x == 0x%02x\n",
	       TULIP_PRINTF_ARGS, tulip_mediums[media],
	       TULIP_CSR_READ(sc, csr_gp) & 0xFF,
	       mi->mi_actmask, mi->mi_actdata);
#endif
	/*
	 * It does!  If this is the first media we detected, then
	 * remember this media.  If isn't the first, then there were
	 * multiple matches which we equate to no match (since we don't
	 * which to select (if any).
	 */
	if (last_media == TULIP_MEDIA_UNKNOWN) {
	    last_media = media;
	} else if (last_media != media) {
	    last_media = TULIP_MEDIA_UNKNOWN;
	}
    }
    return (last_media != TULIP_MEDIA_UNKNOWN) ? last_media : maybe_media;
}
#endif /* TULIP_DO_GPR_SENSE */

a610 26
#if defined(TULIP_DO_GPR_SENSE)
	/*
	 * Check for media via the general purpose register.
	 *
	 * Try to sense the media via the GPR.  If the same value
	 * occurs 3 times in a row then just use that.
	 */
	if (sc->tulip_probe_timeout > 0) {
	    tulip_media_t new_probe_media = tulip_21140_gpr_media_sense(sc);
#if defined(TULIP_DEBUG)
	    printf(TULIP_PRINTF_FMT ": media_poll: gpr sensing = %s\n",
		   TULIP_PRINTF_ARGS, tulip_mediums[new_probe_media]);
#endif
	    if (new_probe_media != TULIP_MEDIA_UNKNOWN) {
		if (new_probe_media == sc->tulip_probe_media) {
		    if (--sc->tulip_probe_count == 0)
			tulip_linkup(sc, sc->tulip_probe_media);
		} else {
		    sc->tulip_probe_count = 10;
		}
	    }
	    sc->tulip_probe_media = new_probe_media;
	    tulip_timeout(sc);
	    return;
	}
#endif /* TULIP_DO_GPR_SENSE */
a1118 13
#if 0
    { 0x0015F420, 0,	/* 00-A0-7D */
      {
	{ 0x12, 0x0010, 0x0000 },	/* 10T */
	{ },				/* 100TX */
	{ 0x12, 0x0010, 0x0010 },	/* 100T4 */
	{ 0x12, 0x0008, 0x0008 },	/* FULL_DUPLEX */
      },
#if defined(TULIP_DEBUG)
      "Broadcom BCM5000"
#endif
    },
#endif
a2419 3
#if 0
			mi->mi_default = (data & TULIP_SROM_2114X_DEFAULT) != 0;
#endif
a2613 10
#if 0
		case 5: {	/* 21143 Reset block */
		    mi->mi_type = TULIP_MEDIAINFO_RESET;
		    mi->mi_reset_length = *dp++;
		    mi->mi_reset_offset = dp - sc->tulip_rombuf;
		    dp += 2 * mi->mi_reset_length;
		    mi++;
		    break;
		}
#endif
a2663 14
#if defined(TULIP_EISA)
    } else if (sc->tulip_chipid == TULIP_DE425) {
	int cnt;
	for (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {
	    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);
	    if (tmpbuf[idx] == testpat[idx])
		++idx;
	    else
		idx = 0;
	}
	for (idx = 0; idx < 32; idx++)
	    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);
	sc->tulip_boardsw = &tulip_21040_boardsw;
#endif /* TULIP_EISA */
a2679 10
#ifdef NEED_PCI_ETHER_HW_ADDR_FUNC
	if(pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf),
	    sc->tulip_pci_busno, sc->tulip_pci_devno)) {
		if(sc->tulip_boardsw == &tulip_21041_boardsw)
		    sc->tulip_boardsw = &tulip_21041np_boardsw;
	}
	else {
		tulip_srom_read(sc);
	}
#else
a2680 1
#endif
a2848 1
#if defined(IFM_ETHER)
a2922 1
#endif
d3063 1
a3063 1
#ifdef powerpc
d3250 2
a3251 3
	     * It is possible (though improbable unless the BIG_PACKET support
	     * is enabled or MCLBYTES < 1518) for a received packet to cross
	     * more than one receive descriptor.
d3292 1
a3292 8
		&& ((DESC_BO(eop->d_status) & TULIP_DSTS_ERRSUM) == 0
#ifdef BIG_PACKET
		     || (total_len <= sc->tulip_if.if_mtu + sizeof(struct ether_header) &&
			 (DESC_BO(eop->d_status) & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxRUNT|
					  TULIP_DSTS_RxCOLLSEEN|TULIP_DSTS_RxBADCRC|
					  TULIP_DSTS_RxOVERFLOW)) == 0)
#endif
		)) {
a3384 3
#ifdef BIG_PACKET
#error BIG_PACKET is incompatible with TULIP_COPY_RXDATA
#endif
a3715 97
#if defined(TULIP_USE_SOFTINTR)
/*
 * This is a experimental idea to alleviate problems due to interrupt
 * livelock.  What is interrupt livelock?  It's when you spend all your
 * time servicing device interrupts and never drop below device ipl
 * to do "useful" work.
 *
 * So what we do here is see if the device needs service and if so,
 * disable interrupts (dismiss the interrupt), place it in a list of devices
 * needing service, and issue a network software interrupt.
 *
 * When our network software interrupt routine gets called, we simply
 * walk done the list of devices that we have created and deal with them
 * at splnet/splsoftnet.
 *
 */
static void
tulip_hardintr_handler(
    tulip_softc_t * const sc,
    int *progress_p)
{
    if (TULIP_CSR_READ(sc, csr_status) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR) == 0)
	return;
    *progress_p = 1;
    /*
     * disable interrupts
     */
    TULIP_CSR_WRITE(sc, csr_intr, 0);
    /*
     * mark it as needing a software interrupt
     */
    tulip_softintr_mask |= (1U << sc->tulip_unit);
}

static void
tulip_softintr(
    void)
{
    u_int32_t softintr_mask, mask;
    int progress = 0;
    int unit;
    tulip_spl_t s;

    /*
     * Copy mask to local copy and reset global one to 0.
     */
    s = TULIP_RAISESPL();
    softintr_mask = tulip_softintr_mask;
    tulip_softintr_mask = 0;
    TULIP_RESTORESPL(s);

    /*
     * Optimize for the single unit case.
     */
    if (tulip_softintr_max_unit == 0) {
	if (softintr_mask & 1) {
	    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(0);
	    /*
	     * Handle the "interrupt" and then reenable interrupts
	     */
	    softintr_mask = 0;
	    tulip_intr_handler(sc, &progress);
	    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	}
	return;
    }

    /*
     * Handle all "queued" interrupts in a round robin fashion.
     * This is done so as not to favor a particular interface.
     */
    unit = tulip_softintr_last_unit;
    mask = (1U << unit);
    while (softintr_mask != 0) {
	if (tulip_softintr_max_unit == unit) {
	    unit  = 0; mask   = 1;
	} else {
	    unit += 1; mask <<= 1;
	}
	if (softintr_mask & mask) {
	    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(unit);
	    /*
	     * Handle the "interrupt" and then reenable interrupts
	     */
	    softintr_mask ^= mask;
	    tulip_intr_handler(sc, &progress);
	    TULIP_CSR_WRITE(sc, csr_intr, sc->tulip_intrmask);
	}
    }

    /*
     * Save where we ending up.
     */
    tulip_softintr_last_unit = unit;
}
#endif	/* TULIP_USE_SOFTINTR */

a3726 3
#if defined(TULIP_USE_SOFTINTR)
	tulip_hardintr_handler(sc, &progress);
#else
a3727 1
#endif
a3728 5
#if defined(TULIP_USE_SOFTINTR)
    if (progress)
	schednetisr(NETISR_DE);
#endif
#if !defined(TULIP_VOID_INTRFUNC)
a3729 1
#endif
a3741 5
#if defined(TULIP_USE_SOFTINTR)
    tulip_hardintr_handler(sc, &progress);
    if (progress)
	schednetisr(NETISR_DE);
#else
d3743 1
a3743 2
#endif
#if !defined(TULIP_VOID_INTRFUNC)
a3744 1
#endif
d3752 1
a3752 1
#if MCLBYTES >= ETHERMTU + 18 && !defined(BIG_PACKET)
a3858 5
#ifdef BIG_PACKET
	    int partial = 0;
	    if (slen >= 2048)
		slen = 2040, partial = 1;
#endif
a3938 4
#ifdef BIG_PACKET
	    if (partial)
		continue;
#endif
a4141 1

d4143 1
a4143 3
 * This routine is entered at splnet() (splsoftnet() on OpenBSD)
 * and thereby imposes no problems when TULIP_USE_SOFTINTR is
 * defined or not.
a4157 3
#if defined(TULIP_USE_SOFTINTR)
    s = TULIP_RAISESOFTSPL();
#else
d4159 1
a4159 1
#endif
a4186 27
#if !defined(IFM_ETHER)
	int flags = 0;
	if (ifp->if_flags & IFF_LINK0) flags |= 1;
	if (ifp->if_flags & IFF_LINK1) flags |= 2;
	if (ifp->if_flags & IFF_LINK2) flags |= 4;
	if (flags == 7) {
	    ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
	    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP|TULIP_NOAUTOSENSE);
	    tulip_reset(sc);
	} else if (flags) {
	    tulip_media_t media;
	    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
		if (sc->tulip_mediums[media] != NULL && --flags == 0) {
		    sc->tulip_flags |= TULIP_NOAUTOSENSE;
		    if (sc->tulip_media != media || (sc->tulip_flags & TULIP_DIDNWAY)) {
			sc->tulip_flags &= ~TULIP_DIDNWAY;
			tulip_linkup(sc, media);
		    }
		    break;
		}
	    }
	    if (flags)
		printf(TULIP_PRINTF_FMT ": ignored invalid media request\n", TULIP_PRINTF_ARGS);
	}
#endif
a4190 1
#if defined(SIOCSIFMEDIA)
a4195 1
#endif
d4220 1
a4220 7
	if (ifr->ifr_mtu > ETHERMTU
#ifdef BIG_PACKET
	    && sc->tulip_chipid != TULIP_21140
	    && sc->tulip_chipid != TULIP_21140A
	    && sc->tulip_chipid != TULIP_21041
#endif
	    ) {
a4224 4
#ifdef BIG_PACKET
	tulip_reset(sc);
	tulip_init(sc);
#endif
d4257 1
a4257 3
 * These routines gets called at device spl (from ether_output).  This might
 * pose a problem for TULIP_USE_SOFTINTR if ether_output is called at
 * device spl from another driver.
a4308 7
/*
 * Even though this routine runs at device spl, it does not break
 * our use of splnet (splsoftnet under OpenBSD) for the majority
 * of this driver (if TULIP_USE_SOFTINTR defined) since
 * if_watcbog is called from if_watchdog which is called from
 * splsoftclock which is below spl[soft]net.
 */
a4391 3
#if !defined(IFF_NOTRAILERS)
#define IFF_NOTRAILERS		0
#endif
a4405 3
#if defined(TULIP_NEED_FASTTIMEOUT)
    timeout_set(&sc->tulip_ftmo, tulip_fasttimeout_callback, sc);
#endif
a4422 1
#if defined(IFM_ETHER)
a4425 19
#else
    {
	tulip_media_t media;
	int cnt;
	printf(TULIP_PRINTF_FMT ": media:", TULIP_PRINTF_ARGS);
	for (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {
	    if (sc->tulip_mediums[media] != NULL) {
		printf(" %d=\"%s\"", cnt, tulip_mediums[media]);
		cnt++;
	    }
	}
	if (cnt == 1) {
	    sc->tulip_features |= TULIP_HAVE_NOMEDIA;
	    printf(" none\n");
	} else {
	    printf("\n");
	}
    }
#endif
a4426 1
#if defined(IFM_ETHER)
a4427 1
#endif
a4461 3
#if defined(TULIP_EISA)
    sc->tulip_csrs.csr_enetrom		= csr_base + DE425_ENETROM_OFFSET;
#endif
a4484 13
#ifdef PPC_MPC106_BUG
    /*
     * This is a workaround for the powerpc MPC106 chip not snooping
     * accesses to the descriptor area correctly.
     */
    tulip_desc_t *xdesc = descs;
    xdesc = (tulip_desc_t *)(roundup((int)descs, 32) - 4);
    if(xdesc < descs) {
	ndescs--;
	xdesc++;
    }
    descs = xdesc;
#endif
a4512 4
#if defined(TULIP_EISA)
static const int tulip_eisa_irqs[4] = { IRQ5, IRQ9, IRQ10, IRQ11 };
#endif

a4726 4
#if defined(TULIP_USE_SOFTINTR)
	if (sc->tulip_unit > tulip_softintr_max_unit)
	    tulip_softintr_max_unit = sc->tulip_unit;
#endif
@


1.75.2.1
log
@partially revert rev 1.67, "ALTQ cleanout". the unintended change
would cause the driver to always switch to one packet mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.75 2005/08/09 04:10:11 mickey Exp $	*/
d4658 1
a4658 6
#ifdef ALTQ
	if (0) /* don't switch to the one packet mode */
#else
	if (IFQ_IS_EMPTY(&sc->tulip_if.if_snd))
#endif
	    sc->tulip_if.if_start = tulip_ifstart_one;
@


1.74
log
@remove __BROKEN_INDIRECT_CONFIG cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.73 2005/06/26 01:38:39 brad Exp $	*/
a5095 6

	/* Make sure bus mastering is enabled. */
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		       pci_conf_read(pa->pa_pc, pa->pa_tag,
			             PCI_COMMAND_STATUS_REG) |
				     PCI_COMMAND_MASTER_ENABLE);
@


1.73
log
@remove one more piece of the media detection from SRM code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.72 2005/06/20 22:44:39 martin Exp $	*/
a4946 1
#ifdef __BROKEN_INDIRECT_CONFIG
a4947 3
#else
    struct cfdata *match,
#endif
@


1.72
log
@Remove media detection from the SRM on alpha. Initially a good idea, it
breaks some onboard de(4)'s. The conventional way of getting media settings
is just fine on alpha, so let's just use this. Shrinks de(4) a bit on alpha.

While there de-inline tulip_21140_mediainit().

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.71 2005/06/08 17:03:00 henning Exp $	*/
a4807 9

#if defined(__alpha__)
    /*
     * In case the SRM console told us about a bogus media,
     * we need to check to be safe.
     */
    if (sc->tulip_mediums[sc->tulip_media] == NULL)
	sc->tulip_media = TULIP_MEDIA_UNKNOWN;
#endif
@


1.71
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.70 2005/05/25 22:14:16 martin Exp $	*/
d1611 1
a1611 1
__inline__ static void
a5008 3
#if defined(__alpha__)
    tulip_media_t media = TULIP_MEDIA_UNKNOWN;
#endif
a5081 20

#if defined(__alpha__)
    /*
     * The Alpha SRM console encodes a console set media in the driver
     * part of the CFDA register.  Note that the Multia presents a
     * problem in that its BNC mode is really EXTSIA.  So in that case
     * force a probe.
     */
    switch ((cfdainfo >> 8) & 0xff) {
    case 1: media = chipid > TULIP_DE425 ?
        TULIP_MEDIA_AUI : TULIP_MEDIA_AUIBNC; break;
    case 2: media = chipid > TULIP_DE425 ?
        TULIP_MEDIA_BNC : TULIP_MEDIA_UNKNOWN; break;
    case 3: media = TULIP_MEDIA_10BASET; break;
    case 4: media = TULIP_MEDIA_10BASET_FD; break;
    case 5: media = TULIP_MEDIA_100BASETX; break;
    case 6: media = TULIP_MEDIA_100BASETX_FD; break;
    }
#endif

a5180 3
#if defined(__alpha__)
	sc->tulip_media = media;
#endif
a5181 4
#if defined(__alpha__)
	if (sc->tulip_media != TULIP_MEDIA_UNKNOWN)
		tulip_linkup(sc, media);
#endif
@


1.70
log
@- identify Compex NICs (untested)
- wrap more functions in TULIP_PERF* macros

ok brad@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.69 2005/05/25 07:48:30 martin Exp $	*/
a75 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a4503 21

#ifdef NS
	    /*
	     * This magic copied from if_is.c; I don't use XNS,
	     * so I have no way of telling if this actually
	     * works or not.
	     */
	case AF_NS: {
	    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
	    if (ns_nullhost(*ina)) {
		ina->x_host = *(union ns_host *)(sc->tulip_enaddr);
	    } else {
		ifp->if_flags &= ~IFF_RUNNING;
		bcopy((caddr_t)ina->x_host.c_host,
		      (caddr_t)sc->tulip_enaddr,
		      sizeof(sc->tulip_enaddr));
	    }
	    tulip_init(sc);
	    break;
	}
#endif /* NS */
@


1.69
log
@in tulip_reset() remove a useless printf and check flags before resetting
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.68 2005/05/23 20:54:32 martin Exp $	*/
d108 4
d153 2
d159 3
d2392 39
d2807 1
d3403 1
d3412 1
d3460 2
d3617 1
d3645 1
d3652 1
d3660 1
d3785 1
@


1.68
log
@- remomve unneeded tulip_reset() and always include intr.h
- make it possible to get media information from the SRM on alpha

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.67 2005/05/22 19:29:55 martin Exp $	*/
a3186 4
#if defined(TULIP_DEBUG)
    printf ("de0: resetting...\n");
#endif

d3194 2
a3195 1
    if (sc->tulip_boardsw->bd_media_preset != NULL)
@


1.67
log
@ALTQ cleanout

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.66 2005/04/23 01:45:55 martin Exp $	*/
a84 1
#if defined(__alpha__)
a85 1
#endif
d4421 1
a4421 1
 * This routine is entered at splnet() (splsoftnet() on NetBSD)
d4656 1
a4656 1
 * our use of splnet (splsoftnet under NetBSD) for the majority
d4980 3
d5057 1
a5057 1
#if defined(__alpha__) && defined(__NetBSD__)
d5175 3
a5177 1
	tulip_reset(sc);
d5179 4
@


1.66
log
@make sure bus mastering is enabled

ok brad@@

from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.65 2005/04/16 16:08:07 deraadt Exp $	*/
a4084 1
#if 1 /* ALTQ */
a4087 1
#endif
a4140 1
#if 1 /* ALTQ */
a4160 1
#endif
a4226 1
#if 1 /* ALTQ */
a4233 1
#endif
a4594 1
#if 1 /* ALTQ */
a4600 1
#endif
d4631 1
a4631 6
#ifdef ALTQ
	if (0) /* don't switch to the one packet mode */
#else
	if (IFQ_IS_EMPTY(&sc->tulip_if.if_snd))
#endif
	    sc->tulip_if.if_start = tulip_ifstart_one;
@


1.65
log
@remove lots of crud from this driver, makes it fit on the alpha media
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.64 2005/03/29 00:37:50 martin Exp $	*/
d5115 6
@


1.64
log
@pull over some minor fixes from NetBSD:

- use ETHER_ADDR_LEN where apropriate
- consistency fixes in mem-io vs io-io logic
- fixes for 21143 in full-duplex mode
- minor nits here and there

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.63 2005/01/15 05:24:11 brad Exp $	*/
a51 3
#if defined(__FreeBSD__)
#include <machine/clock.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a52 2
#endif
#ifdef __OpenBSD__
a53 1
#endif
a63 5
#if defined(__bsdi__) && _BSDI_VERSION >= 199701
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#endif

a81 13

#if defined(__FreeBSD__)
#include <vm/pmap.h>
#include <pci.h>
#include <netinet/if_ether.h>
#if NPCI > 0
#include <pci/pcivar.h>
#include <pci/dc21040reg.h>
#define	DEVAR_INCLUDE	"pci/if_devar.h"
#endif
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
a82 17
#include <i386/pci/ic/dc21040reg.h>
#include <i386/isa/isa.h>
#include <i386/isa/icu.h>
#include <i386/isa/dma.h>
#include <i386/isa/isavar.h>
#include <i386/pci/pci.h>
#if _BSDI_VERSION < 199510
#include <eisa.h>
#else
#define	NEISA 0
#endif
#if NEISA > 0 && _BSDI_VERSION >= 199401
#include <i386/eisa/eisa.h>
#define	TULIP_EISA
#endif
#define	DEVAR_INCLUDE	"i386/pci/if_devar.h"
#endif /* __bsdi__ */
a83 12
#if defined(__NetBSD__)
#include <net/if_ether.h>
#if defined(INET)
#include <netinet/if_inarp.h>
#endif
#endif

#if defined(__OpenBSD__)
#include <netinet/if_ether.h>
#endif

#if defined(__NetBSD__) || defined(__OpenBSD__)
a92 1
#endif /* __NetBSD__ */
a163 1
#ifdef __OpenBSD__
a164 3
#else
    timeout(tulip_timeout_callback, sc, (hz + TULIP_HZ / 2) / TULIP_HZ);
#endif
a186 1
#ifdef __OpenBSD__
a187 3
#else
    timeout(tulip_fasttimeout_callback, sc, 1);
#endif
d250 2
a251 1
    if (mi->mi_type == TULIP_MEDIAINFO_SIA || (sc->tulip_features & TULIP_HAVE_SIANWAY)) {
a3063 8
#if defined(__bsdi__)
    if (sc->tulip_mii.mii_instance != 0) {
	mii_pollstat(&sc->tulip_mii);
	req->ifm_active = sc->tulip_mii.mii_media_active;
	req->ifm_status = sc->tulip_mii.mii_media_status;
	return;
    }
#endif
d3469 1
a3484 1
#ifdef TULIP_DEBUG
a3488 1
#endif
d3491 1
a3535 3
#if defined(__bsdi__)
		eh.ether_type = ntohs(eh.ether_type);
#endif
d3741 1
d3765 1
d3785 1
d3789 1
a3903 9

#if defined(__NetBSD__) && NRND > 0
    /*
     * This isn't all that random (the value we feed in) but it is
     * better than a constant probably.  It isn't used in entropy
     * calculation anyway, just to add something to the pool.
     */
    rnd_add_uint32(&sc->tulip_rndsource, sc->tulip_flags);
#endif
d4702 1
d4708 1
a4752 10
#if defined(__bsdi__) || (defined(__FreeBSD__) && BSD < 199506)
static ifnet_ret_t
tulip_ifwatchdog_wrapper(
    int unit)
{
    tulip_ifwatchdog(&TULIP_UNIT_TO_SOFTC(unit)->tulip_if);
}
#define	tulip_ifwatchdog	tulip_ifwatchdog_wrapper
#endif

a4774 1
#ifdef __OpenBSD__
a4778 1
#endif
a4779 12
#if defined(__bsdi__) && _BSDI_VERSION >= 199510
    aprint_naive(": DEC Ethernet");
    aprint_normal(": %s%s", sc->tulip_boardid,
        tulip_chipdescs[sc->tulip_chipid]);
    aprint_verbose(" pass %d.%d", (sc->tulip_revinfo & 0xF0) >> 4,
        sc->tulip_revinfo & 0x0F);
    printf("\n");
    sc->tulip_pf = aprint_normal;
    aprint_normal(TULIP_PRINTF_FMT ": address " TULIP_EADDR_FMT "\n",
		  TULIP_PRINTF_ARGS,
		  TULIP_EADDR_ARGS(sc->tulip_enaddr));
#else
a4780 3
#if defined(__bsdi__)
	   "\n"
#endif
d4784 1
d4786 3
a4793 1
#endif
a4835 4
#if defined(__bsdi__) && _BSDI_VERSION >= 199510
    sc->tulip_pf = printf;
    TULIP_ETHER_IFATTACH(sc);
#else
a4836 1
#if defined(__NetBSD__) || defined(__OpenBSD__) || (defined(__FreeBSD__) && BSD >= 199506)
a4837 2
#endif
#endif /* __bsdi__ */
a4841 5

#if defined(__NetBSD__) && NRND > 0
    rnd_attach_source(&sc->tulip_rndsource, sc->tulip_dev.dv_xname,
		      RND_TYPE_NET);
#endif
a4936 216
#if defined(__FreeBSD__)

#define	TULIP_PCI_ATTACH_ARGS	pcici_t config_id, int unit
#define	TULIP_SHUTDOWN_ARGS	int howto, void * arg

#if defined(TULIP_DEVCONF)
static void tulip_shutdown(TULIP_SHUTDOWN_ARGS);

static int
tulip_pci_shutdown(
    struct kern_devconf * const kdc,
    int force)
{
    if (kdc->kdc_unit < TULIP_MAX_DEVICES) {
	tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(kdc->kdc_unit);
	if (sc != NULL)
	    tulip_shutdown(0, sc);
    }
    (void) dev_detach(kdc);
    return 0;
}
#endif

static char *
tulip_pci_probe(
    pcici_t config_id,
    pcidi_t device_id)
{
    if (PCI_VENDORID(device_id) != DEC_VENDORID)
	return NULL;
    if (PCI_CHIPID(device_id) == CHIPID_21040)
	return "Digital 21040 Ethernet";
    if (PCI_CHIPID(device_id) == CHIPID_21041)
	return "Digital 21041 Ethernet";
    if (PCI_CHIPID(device_id) == CHIPID_21140) {
	u_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;
	if (revinfo >= 0x20)
	    return "Digital 21140A Fast Ethernet";
	else
	    return "Digital 21140 Fast Ethernet";
    }
    if (PCI_CHIPID(device_id) == CHIPID_21142) {
	u_int32_t revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;
	if (revinfo >= 0x20)
	    return "Digital 21143 Fast Ethernet";
	else
	    return "Digital 21142 Fast Ethernet";
    }
    return NULL;
}

static void  tulip_pci_attach(TULIP_PCI_ATTACH_ARGS);
static u_long tulip_pci_count;

struct pci_device dedevice = {
    "de",
    tulip_pci_probe,
    tulip_pci_attach,
   &tulip_pci_count,
#if defined(TULIP_DEVCONF)
    tulip_pci_shutdown,
#endif
};

DATA_SET (pcidevice_set, dedevice);
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
#define	TULIP_PCI_ATTACH_ARGS	struct device * const parent, struct device * const self, void * const aux
#define	TULIP_SHUTDOWN_ARGS	void *arg

static int
tulip_pci_match(
    pci_devaddr_t *pa)
{
    int irq;
    unsigned id;

    id = pci_inl(pa, PCI_VENDOR_ID);
    if (PCI_VENDORID(id) != DEC_VENDORID)
	return 0;
    id = PCI_CHIPID(id);
    if (id != CHIPID_21040 && id != CHIPID_21041
	    && id != CHIPID_21140 && id != CHIPID_21142)
	return 0;
    irq = pci_inl(pa, PCI_I_LINE) & 0xFF;
    if (irq == 0 || irq >= 16) {
#ifdef TULIP_DEBUG
	printf("de?: invalid IRQ %d; skipping\n", irq);
#endif
	return 0;
    }
    return 1;
}

static int
tulip_probe(
    struct device *parent,
    struct cfdata *cf,
    void *aux)
{
    struct isa_attach_args * const ia = (struct isa_attach_args *) aux;
    unsigned irq, slot;
    pci_devaddr_t *pa;

#if _BSDI_VERSION >= 199401
    switch (ia->ia_bustype) {
    case BUS_PCI:
#endif
	pa = pci_scan(tulip_pci_match);
	if (pa == NULL)
	    return 0;

	irq = (1 << (pci_inl(pa, PCI_I_LINE) & 0xFF));

	/* Get the base address; assume the BIOS set it up correctly */
#if defined(TULIP_IOMAPPED)
	ia->ia_maddr = NULL;
	ia->ia_msize = 0;
	ia->ia_iobase = pci_inl(pa, PCI_CBIO) & ~7;
	pci_outl(pa, PCI_CBIO, 0xFFFFFFFF);
	ia->ia_iosize = ((~pci_inl(pa, PCI_CBIO)) | 7) + 1;
	pci_outl(pa, PCI_CBIO, (int) ia->ia_iobase);

	/* Disable memory space access */
	pci_outl(pa, PCI_COMMAND, pci_inl(pa, PCI_COMMAND) & ~2);
#else
	ia->ia_maddr = (caddr_t) (pci_inl(pa, PCI_CBMA) & ~7);
	pci_outl(pa, PCI_CBMA, 0xFFFFFFFF);
	ia->ia_msize = ((~pci_inl(pa, PCI_CBMA)) | 7) + 1;
	pci_outl(pa, PCI_CBMA, (int) ia->ia_maddr);
	ia->ia_iobase = 0;
	ia->ia_iosize = 0;

	/* Disable I/O space access */
	pci_outl(pa, PCI_COMMAND, pci_inl(pa, PCI_COMMAND) & ~1);
#endif /* TULIP_IOMAPPED */

	ia->ia_aux = (void *) pa;
#if _BSDI_VERSION >= 199401
	break;

#if defined(TULIP_EISA)
    case BUS_EISA: {
	unsigned tmp;

	if ((slot = eisa_match(cf, ia)) == 0)
	    return 0;
	ia->ia_iobase = slot << 12;
	ia->ia_iosize = EISA_NPORT;
	eisa_slotalloc(slot);
	tmp = inb(ia->ia_iobase + DE425_CFG0);
	irq = tulip_eisa_irqs[(tmp >> 1) & 0x03];
	/*
	 * Until BSD/OS likes level interrupts, force
	 * the DE425 into edge-triggered mode.
	 */
	if ((tmp & 1) == 0)
	    outb(ia->ia_iobase + DE425_CFG0, tmp | 1);
	/*
	 * CBIO needs to map to the EISA slot
	 * enable I/O access and Master
	 */
	outl(ia->ia_iobase + DE425_CBIO, ia->ia_iobase);
	outl(ia->ia_iobase + DE425_CFCS, 5 | inl(ia->ia_iobase + DE425_CFCS));
	ia->ia_aux = NULL;
	break;
    }
#endif /* TULIP_EISA */
    default:
	return 0;
    }
#endif

    /* PCI bus masters don't use host DMA channels */
    ia->ia_drq = DRQNONE;

    if (ia->ia_irq != IRQUNK && irq != ia->ia_irq) {
	printf("de%d: error: desired IRQ of %d does not match device's "
	    "actual IRQ of %d,\n",
	       cf->cf_unit,
	       ffs(ia->ia_irq) - 1, ffs(irq) - 1);
	return 0;
    }
    if (ia->ia_irq == IRQUNK)
	ia->ia_irq = irq;
#ifdef IRQSHARE
    ia->ia_irq |= IRQSHARE;
#endif
    return 1;
}

static void tulip_pci_attach(TULIP_PCI_ATTACH_ARGS);

#if defined(TULIP_EISA)
static char *tulip_eisa_ids[] = {
    "DEC4250",
    NULL
};
#endif

struct cfdriver decd = {
    0, "de", tulip_probe, tulip_pci_attach,
#if _BSDI_VERSION >= 199401
    DV_IFNET,
#endif
    sizeof(tulip_softc_t),
#if defined(TULIP_EISA)
    tulip_eisa_ids
#endif
};

#endif /* __bsdi__ */


#if defined(__NetBSD__) || defined(__OpenBSD__)
a4971 2
#endif /* __NetBSD__ */

d4973 1
a4973 2
tulip_shutdown(
    TULIP_SHUTDOWN_ARGS)
d4983 1
a4983 2
tulip_pci_attach(
    TULIP_PCI_ATTACH_ARGS)
a4984 18
#if defined(__FreeBSD__)
    tulip_softc_t *sc;
#define	PCI_CONF_WRITE(r, v)	pci_conf_write(config_id, (r), (v))
#define	PCI_CONF_READ(r)	pci_conf_read(config_id, (r))
#define	PCI_GETBUSDEVINFO(sc)	((void)((sc)->tulip_pci_busno = ((config_id.cfg1 >> 16) & 0xFF), /* XXX */ \
					(sc)->tulip_pci_devno = ((config_id.cfg1 >> 11) & 0x1F))) /* XXX */
#endif
#if defined(__bsdi__)
    tulip_softc_t * const sc = (tulip_softc_t *) self;
    struct isa_attach_args * const ia = (struct isa_attach_args *) aux;
    pci_devaddr_t *pa = (pci_devaddr_t *) ia->ia_aux;
    const int unit = sc->tulip_dev.dv_unit;
#define	PCI_CONF_WRITE(r, v)	pci_outl(pa, (r), (v))
#define	PCI_CONF_READ(r)	pci_inl(pa, (r))
#define	PCI_GETBUSDEVINFO(sc)	((void)((sc)->tulip_pci_busno = pa->d_bus, \
					(sc)->tulip_pci_devno = pa->d_agent))
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
a4993 1
#endif /* __NetBSD__ */
a4996 3
#if !defined(TULIP_IOMAPPED) && defined(__FreeBSD__)
    vm_offset_t pa_csrs;
#endif
a5002 3
#ifdef __FreeBSD__
	printf("de%d", unit);
#endif
a5007 15
#if defined(__bsdi__)
    if (pa != NULL) {
	revinfo = pci_inl(pa, PCI_CFRV) & 0xFF;
	id = pci_inl(pa, PCI_CFID);
	cfdainfo = pci_inl(pa, PCI_CFDA);
#if defined(TULIP_EISA)
    } else {
	revinfo = inl(ia->ia_iobase + DE425_CFRV) & 0xFF;
	csroffset = TULIP_EISA_CSROFFSET;
	csrsize = TULIP_EISA_CSRSIZE;
	chipid = TULIP_DE425;
	cfdainfo = 0;
#endif /* TULIP_EISA */
    }
#else /* __bsdi__ */
a5010 1
#endif /* __bsdi__ */
a5026 3
#ifdef __FreeBSD__
	printf("de%d", unit);
#endif
a5030 1
#ifndef __FreeBSD__
a5031 1
#endif
a5036 7
#if defined(__FreeBSD__)
    sc = (tulip_softc_t *) malloc(sizeof(*sc), M_DEVBUF, M_NOWAIT);
    if (sc == NULL)
	return;
    bzero(sc, sizeof(*sc));				/* Zero out the softc*/
#endif

a5064 3
#if defined(__OpenBSD__)
    /* XXX - csapuntz@@lcs.mit.edu
       OpenBSD + our PCI motherboard underflows consistently */
a5066 1
#endif
a5087 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a5090 4
#else
    sc->tulip_unit = unit;
    sc->tulip_name = "de";
#endif
a5091 24
#if defined(__FreeBSD__)
#if BSD >= 199506
    sc->tulip_if.if_softc = sc;
#endif
#if defined(TULIP_IOMAPPED)
    retval = pci_map_port(config_id, PCI_CBIO, &csr_base);
#else
    retval = pci_map_mem(config_id, PCI_CBMA, (vm_offset_t *) &csr_base, &pa_csrs);
#endif
    if (!retval) {
	free((caddr_t) sc, M_DEVBUF);
	return;
    }
    tulips[unit] = sc;
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
    sc->tulip_pf = printf;
#if defined(TULIP_IOMAPPED)
    csr_base = ia->ia_iobase;
#else
    csr_base = (vm_offset_t) mapphys((vm_offset_t) ia->ia_maddr, ia->ia_msize);
#endif
#endif /* __bsdi__ */
a5092 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a5115 1
#endif /* __NetBSD__ */
a5129 3
#if defined(__FreeBSD__)
	printf(TULIP_PRINTF_FMT, TULIP_PRINTF_ARGS);
#endif
d5136 6
a5141 1
	       sc->tulip_boardid, tulip_chipdescs[sc->tulip_chipid],
a5149 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a5174 26
#endif
#if defined(__FreeBSD__)
	if ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {
	    if (!pci_map_int (config_id, intr_rtn, (void *) sc, &net_imask)) {
		printf(TULIP_PRINTF_FMT ": couldn't map interrupt\n",
		       TULIP_PRINTF_ARGS);
		return;
	    }
	}
#if !defined(TULIP_DEVCONF)
	at_shutdown(tulip_shutdown, sc, SHUTDOWN_POST_SYNC);
#endif
#endif
#if defined(__bsdi__)
	if ((sc->tulip_features & TULIP_HAVE_SLAVEDINTR) == 0) {
	    isa_establish(&sc->tulip_id, &sc->tulip_dev);

	    sc->tulip_ih.ih_fun = intr_rtn;
	    sc->tulip_ih.ih_arg = (void *) sc;
	    intr_establish(ia->ia_irq, &sc->tulip_ih, DV_NET);
	}

	sc->tulip_ats.func = tulip_shutdown;
	sc->tulip_ats.arg = (void *) sc;
	atshutdown(&sc->tulip_ats, ATSH_ADD);
#endif
@


1.63
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.62 2004/11/08 21:16:47 deraadt Exp $	*/
d271 4
a274 2
    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_dhost, 6);
    bcopy(sc->tulip_enaddr, mtod(m, struct ether_header *)->ether_shost, 6);
d310 25
a334 1
    /*
a339 1
	TULIP_CSR_WRITE(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
d402 8
d454 1
a454 1
	    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX;
d456 1
a456 1
	    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;
d594 2
a595 1
	status = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);
d1307 11
d1378 2
a1379 1
    data = tulip_mii_readreg(sc, sc->tulip_phyaddr, PHYREG_STATUS);
d1498 2
a1499 1
	    status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);
d1518 3
a1520 2
		loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation restarted: 0x%04x\n",
			   TULIP_PRINTF_ARGS, phyaddr, data);
d1528 2
a1529 1
	    u_int32_t status = tulip_mii_readreg(sc, phyaddr, PHYREG_STATUS);
d1545 2
a1546 1
	    data = tulip_mii_readreg(sc, phyaddr, PHYREG_AUTONEG_ABILITIES);
d1548 2
a1549 2
	    loudprintf(TULIP_PRINTF_FMT "(phy%d): autonegotiation complete: 0x%04x\n",
		       TULIP_PRINTF_ARGS, phyaddr, data);
d1582 3
a1584 2
    sc->tulip_cmdmode &= ~TULIP_CMD_PORTSELECT;
    sc->tulip_flags &= ~TULIP_SQETEST;
a1609 1
	    sc->tulip_cmdmode &= ~TULIP_CMD_FULLDUPLEX;
d1617 2
a1624 1
	    sc->tulip_cmdmode &= ~(TULIP_CMD_FULLDUPLEX|TULIP_CMD_TXTHRSHLDCTL);
d1627 4
d1635 2
a1636 2
	    sc->tulip_cmdmode |= TULIP_CMD_FULLDUPLEX|TULIP_CMD_PORTSELECT;
	    sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;
d1638 4
d2474 2
a2475 1
    bcopy((caddr_t) shp->sh_ieee802_address, (caddr_t) sc->tulip_enaddr, 6);
d2951 1
a2951 1
	bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);
d2991 2
a2992 1
		    bcopy(root_sc->tulip_enaddr, sc->tulip_enaddr, 6);
d3026 1
a3026 1
    bcopy(sc->tulip_rombuf, sc->tulip_enaddr, 6);
d4571 1
a4571 1
	      6);
a5336 3
    bus_space_tag_t iot, memt;
    bus_space_handle_t ioh, memh;
    int ioh_valid, memh_valid;
d5340 2
a5341 4
	int busno, devno, funcno; \
	pci_decompose_tag(pa->pa_pc, pa->pa_tag, &busno, &devno, &funcno); \
	(sc)->tulip_pci_busno = busno; \
	(sc)->tulip_pci_devno = devno; \
d5512 4
d5517 1
a5517 1
    ioh_valid = (pci_mapreg_map(pa, PCI_CBIO, PCI_MAPREG_TYPE_IO, 0,
d5519 1
a5519 1
    memh_valid = (pci_mapreg_map(pa, PCI_CBMA,
a5521 1
#endif
d5523 10
a5532 21
#if defined(__OpenBSD__) || defined(__NetBSD__)
#if defined(TULIP_IOMAPPED)
    if (ioh_valid) {
	sc->tulip_bustag = iot;
	sc->tulip_bushandle = ioh;
    } else if (memh_valid) {
	sc->tulip_bustag = memt;
	sc->tulip_bushandle = memh;
    }
#else /* defined(TULIP_IOMAPPED) */
    if (memh_valid) {
	sc->tulip_bustag = memt;
	sc->tulip_bushandle = memh;
    } else if (ioh_valid) {
	sc->tulip_bustag = iot;
	sc->tulip_bushandle = ioh;
    }
#endif /* TULIP_IOMAPPED */
    else {
        printf(": unable to map device registers\n");
        return;
a5626 4
#if defined(__alpha__) && defined(__NetBSD__)
	if (media != TULIP_MEDIA_UNKNOWN)
	    tulip_linkup(sc, media);
#endif
@


1.62
log
@put more debug stuff inside #ifdef, to make the driver a wee bit smaller
for the alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.61 2004/09/23 17:45:16 brad Exp $	*/
d4565 4
a4568 2
	    tulip_addr_filter(sc); /* reset multicast filtering */
	    tulip_init(sc);
@


1.61
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.60 2004/05/31 04:21:12 mcbride Exp $	*/
d453 1
d457 1
d460 1
d462 1
d538 1
a538 1
#if defined(DIAGNOSTIC) || defined(TULIP_DEBUG)
d1443 1
d1446 1
d2364 1
d2366 1
d3492 1
d3497 1
d3667 2
a3668 1
		    printf(TULIP_PRINTF_FMT ": tx_intr: failed to dequeue mbuf?!?\n", TULIP_PRINTF_ARGS);
d4171 1
d4173 1
d5072 1
d5074 1
@


1.60
log
@Replace tulip_crc32 with ether_crc32_le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.59 2004/05/12 06:35:11 tedu Exp $	*/
a4782 6
#if !defined(__bsdi__) || _BSDI_VERSION < 199401
    ifp->if_output = ether_output;
#endif
#if defined(__bsdi__) && _BSDI_VERSION < 199401
    ifp->if_mtu = ETHERMTU;
#endif
@


1.59
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.58 2003/08/06 21:08:06 millert Exp $	*/
d2094 1
a2094 1
#define	tulip_mchash(mca)	(tulip_crc32(mca, 6) & 0x1FF)
d2096 1
a2096 1
    ((tulip_crc32(databuf, 126) & 0xFFFFU) ^ 0xFFFFU) == \
a2097 22

static unsigned
tulip_crc32(
    const unsigned char *databuf,
    size_t datalen)
{
    u_int idx, crc = 0xFFFFFFFFUL;
    static const u_int crctab[] = {
	0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
	0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
	0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
	0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
    };

    for (idx = 0; idx < datalen; idx++) {
	crc ^= *databuf++;
	crc = (crc >> 4) ^ crctab[crc & 0xf];
	crc = (crc >> 4) ^ crctab[crc & 0xf];
    }

    return crc;
}
@


1.58
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.57 2003/04/06 18:54:20 ho Exp $	*/
a77 1
#include <net/bpfdesc.h>
@


1.57
log
@strcat/strcpy/sprintf cleanup. krw@@, anil@@ ok. art@@ tested sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.56 2002/06/30 16:00:30 art Exp $	*/
d2373 1
a2373 1
	mi->mi_reset_offset = 0;;
@


1.56
log
@The #@@$% message about the #$%@@ cable down is going to drive me @@#%$ insane.
I'm not using this built-in tulip because it sucks and I want it to SHUT UP!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.55 2002/06/02 22:50:00 deraadt Exp $	*/
d2126 1
a2126 1
    strcpy(sc->tulip_boardid, "DEC ");
d2143 1
a2143 1
    strcpy(sc->tulip_boardid, "ZNYX ZX3XX ");
d2239 1
a2239 1
    strcpy(sc->tulip_boardid, "SMC ");
d2244 1
a2244 1
	    strcpy(&sc->tulip_boardid[4], "9332DST ");
d2247 1
a2247 1
	    strcpy(&sc->tulip_boardid[4], "9334BDT ");
d2249 1
a2249 1
	    strcpy(&sc->tulip_boardid[4], "9332BDT ");
d2257 1
a2257 1
    strcpy(&sc->tulip_boardid[4], "8432");
d2284 1
a2284 1
    strcpy(sc->tulip_boardid, "Cogent ");
d2287 1
a2287 1
	    strcat(sc->tulip_boardid, "EM100TX ");
d2291 1
a2291 1
	    strcat(sc->tulip_boardid, "EM110TX ");
d2295 1
a2295 1
	    strcat(sc->tulip_boardid, "EM100FX ");
d2308 1
a2308 1
	    strcat(sc->tulip_boardid, "EM440TX ");
d2320 1
a2320 1
    strcpy(sc->tulip_boardid, "ACCTON ");
d2323 1
a2323 1
	    strcat(sc->tulip_boardid, "EN1207 ");
d2328 1
a2328 1
	    strcat(sc->tulip_boardid, "EN1207TX ");
d2333 1
a2333 1
	    strcat(sc->tulip_boardid, "EN1203 ");
d2337 1
a2337 1
	    strcat(sc->tulip_boardid, "EN1203 ");
d2350 1
a2350 1
    strcpy(sc->tulip_boardid, "Asante ");
d2938 2
a2939 1
		strcpy(sc->tulip_boardid, root_sc->tulip_boardid);
@


1.55
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.54 2002/04/01 18:41:47 nate Exp $	*/
a626 1
	printf(TULIP_PRINTF_FMT ": link down: cable problem?\n", TULIP_PRINTF_ARGS);
a856 2
		    printf(TULIP_PRINTF_FMT ": autosense failed: cable problem?\n",
			   TULIP_PRINTF_ARGS);
a1211 2
		printf(TULIP_PRINTF_FMT ": autosense failed: cable problem?\n",
		       TULIP_PRINTF_ARGS);
@


1.54
log
@Don't have dc and de return the same match value in any case.
Comment the reasoning for the various return values in dc_pci_match.
dc is preferred over de on all archs except for alpha where de is used.
The main reason dc is not preferred on alpha is that it doesn't fit
on the floppy, so RAMDISK and GENERIC would have different drivers for
the same device which is rather confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.53 2002/03/14 03:16:06 millert Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.53
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.52 2001/11/06 19:53:19 miod Exp $	*/
d5239 1
a5239 1
	return 1;
@


1.52
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.51 2001/09/21 17:55:43 miod Exp $	*/
d5028 1
a5028 1
static char*
d5564 1
a5564 1
	    if (!pci_map_int (config_id, intr_rtn, (void*) sc, &net_imask)) {
@


1.52.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.52 2001/11/06 19:53:19 miod Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
d5028 1
a5028 1
static char *
d5239 1
a5239 1
	return 2;
d5564 1
a5564 1
	    if (!pci_map_int (config_id, intr_rtn, (void *) sc, &net_imask)) {
@


1.52.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.52.2.1 2002/06/11 03:42:25 art Exp $	*/
d627 1
d858 2
d1215 2
@


1.52.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2126 1
a2126 1
    strlcpy(sc->tulip_boardid, "DEC ", sizeof sc->tulip_boardid);
d2143 1
a2143 1
    strlcpy(sc->tulip_boardid, "ZNYX ZX3XX ", sizeof sc->tulip_boardid);
d2239 1
a2239 1
    strlcpy(sc->tulip_boardid, "SMC ", sizeof sc->tulip_boardid);
d2244 1
a2244 1
	    strlcat(sc->tulip_boardid, "9332DST ", sizeof sc->tulip_boardid);
d2247 1
a2247 1
	    strlcat(sc->tulip_boardid, "9334BDT ", sizeof sc->tulip_boardid);
d2249 1
a2249 1
	    strlcat(sc->tulip_boardid, "9332BDT ", sizeof sc->tulip_boardid);
d2257 1
a2257 1
    strlcat(sc->tulip_boardid, "8432", sizeof sc->tulip_boardid);
d2284 1
a2284 1
    strlcpy(sc->tulip_boardid, "Cogent ", sizeof sc->tulip_boardid);
d2287 1
a2287 1
	    strlcat(sc->tulip_boardid, "EM100TX ", sizeof sc->tulip_boardid);
d2291 1
a2291 1
	    strlcat(sc->tulip_boardid, "EM110TX ", sizeof sc->tulip_boardid);
d2295 1
a2295 1
	    strlcat(sc->tulip_boardid, "EM100FX ", sizeof sc->tulip_boardid);
d2308 1
a2308 1
	    strlcat(sc->tulip_boardid, "EM440TX ", sizeof sc->tulip_boardid);
d2320 1
a2320 1
    strlcpy(sc->tulip_boardid, "ACCTON ", sizeof sc->tulip_boardid);
d2323 1
a2323 1
	    strlcat(sc->tulip_boardid, "EN1207 ", sizeof sc->tulip_boardid);
d2328 1
a2328 1
	    strlcat(sc->tulip_boardid, "EN1207TX ", sizeof sc->tulip_boardid);
d2333 1
a2333 1
	    strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2337 1
a2337 1
	  strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2350 1
a2350 1
    strlcpy(sc->tulip_boardid, "Asante ", sizeof sc->tulip_boardid);
d2938 1
a2938 2
		strlcpy(sc->tulip_boardid, root_sc->tulip_boardid,
			sizeof sc->tulip_boardid);
@


1.51
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.50 2001/09/11 20:05:25 miod Exp $	*/
d93 1
a93 1
#include <vm/vm.h>
@


1.50
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.49 2001/08/25 10:13:29 art Exp $	*/
d5548 1
a5548 2
		printf(", couldn't establish interrupt",
		       sc->tulip_dev.dv_xname);
@


1.49
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.48 2001/08/12 20:33:50 mickey Exp $	*/
a93 1
#include <vm/vm_kern.h>
@


1.48
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.47 2001/06/27 06:34:47 kjc Exp $	*/
d5541 1
a5541 2
	    if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			     pa->pa_intrline, &intrhandle)) {
@


1.47
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.46 2001/06/12 15:40:31 niklas Exp $	*/
a93 1
#include <vm/vm_param.h>
@


1.46
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.45 2001/05/05 20:56:58 art Exp $	*/
d4119 5
d4177 20
d4263 10
d4631 8
d4643 1
a4643 1
	 */
d4657 9
a4665 5
	while (sc->tulip_if.if_snd.ifq_head != NULL) {
	    struct mbuf *m;
	    IF_DEQUEUE(&sc->tulip_if.if_snd, m);
	    if ((m = tulip_txput(sc, m)) != NULL) {
		IF_PREPEND(&sc->tulip_if.if_snd, m);
d4669 5
a4673 1
	if (sc->tulip_if.if_snd.ifq_head == NULL)
d4688 7
a4694 5
	    && sc->tulip_if.if_snd.ifq_head != NULL) {
	struct mbuf *m;
	IF_DEQUEUE(&sc->tulip_if.if_snd, m);
	if ((m = tulip_txput(sc, m)) != NULL)
	    IF_PREPEND(&sc->tulip_if.if_snd, m);
d4893 1
@


1.45
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.44 2001/02/03 06:10:17 mickey Exp $	*/
d5422 1
a5422 1
		 &iot, &ioh, NULL, NULL) == 0);
d5425 1
a5425 1
		  &memt, &memh, NULL, NULL) == 0);
@


1.44
log
@new timeout, space control
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.43 2000/04/27 01:23:29 chris Exp $	*/
d4156 1
a4156 1
	unsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));
d4229 1
a4229 1
	    clsize = CLBYTES;
@


1.43
log
@Previous commit contained things that I want to keep local for now
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.41 1999/07/18 03:20:18 csapuntz Exp $	*/
d57 3
d128 1
a128 1
#if defined(__NetBSD__) 
d221 3
d225 1
d248 3
d252 1
d514 1
a514 1
	 * It does!  If this is the first media we detected, then 
d1197 1
a1197 1
	 * if no txprobe active  
d1227 1
a1227 1
    
d1299 1
a1299 1
#endif 
d1310 1
a1310 1
#endif 
d1367 1
a1367 1
    } 
d1533 1
a1533 1
    
d1596 1
a1596 1
 *  Start of 21140/21140A support which does not use the MII interface 
d1735 1
a1735 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
d1773 1
a1773 1
 
d1925 1
a1925 1
    
d1927 1
a1927 1
    csr  = SROMSEL | SROMRD; EMIT;  
d1943 1
a1943 1
     
d1947 2
a1948 2
{   
    unsigned idx; 
d1962 1
a1962 1
    
d1979 1
a1979 1
            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */ 
d2003 1
a2003 1
    csr |= MII_WR; MII_EMIT;  		/* clock low; assert write */
d2221 1
a2221 1
    }		    
d2448 1
a2448 1
	
d2505 1
a2505 1
	    if (data & TULIP_SROM_21041_EXTENDED)	
d2838 1
a2838 1
	     
d2844 1
a2844 1
	    	if(sc->tulip_boardsw == &tulip_21041_boardsw)
d2999 1
a2999 1
	
d3115 1
a3115 1
#if defined(IFF_ALLMULTI)    
d3162 2
a3163 2
		sp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); 
		sp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); 
d3178 2
a3179 2
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]); 
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]); 
d3199 2
a3200 2
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]); 
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]); 
d3233 1
a3233 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
d3283 1
a3283 1
     * We need to collect all the mbufs were on the 
d3293 1
a3293 1
	{ 
d3412 1
a3412 1
 	 */
d3415 1
a3415 1
	    
d3433 1
a3433 1
	     * more than one receive descriptor.  
d3474 1
a3474 1
		     || (total_len <= sc->tulip_if.if_mtu + sizeof(struct ether_header) && 
d3591 1
a3591 1
	     * Couldn't allocate a new buffer.  Don't bother 
d3722 1
a3722 1
			u_int32_t collisions = 
d4264 1
a4264 1
    { 
d4343 1
a4343 1
	
d4427 1
a4427 1
 * and thereby imposes no problems when TULIP_USE_SOFTINTR is 
d4649 1
a4649 1
 * of this driver (if TULIP_USE_SOFTINTR defined) since 
d4765 8
a4772 1
  
d4927 1
a4927 1
		
d5210 1
a5210 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
d5240 1
a5240 1
    bus_space_tag_t iot, memt;  
d5260 1
a5260 1
    tulip_csrptr_t csr_base; 
d5424 1
a5424 1
    		  PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
d5460 1
a5460 1
    DELAY(100);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
@


1.42
log
@Remove MTU cruft
@
text
@d118 4
d151 1
a151 1
#if defined(__i386__)
d192 1
d195 1
d1073 1
a1073 1
    sc->tulip_intrmask |= TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
d1898 8
d1907 1
a1907 1
#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); DELAY(1); } while (0)
d1980 1
a1980 1
#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); DELAY(1); } while (0)
a2397 39
static void
tulip_identify_compex_nic(
    tulip_softc_t * const sc)
{
     strcpy(sc->tulip_boardid, "COMPEX ");
     if (sc->tulip_chipid == TULIP_21140A) {
	int root_unit;
	tulip_softc_t *root_sc = NULL;

	strcat(sc->tulip_boardid, "400TX/PCI ");
       /*
	* All 4 chips on these boards share an interrupt.  This code
	* copied from tulip_read_macaddr.
	*/
	sc->tulip_features |= TULIP_HAVE_SHAREDINTR;
	for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {
	    root_sc = TULIP_UNIT_TO_SOFTC(root_unit);
	    if (root_sc == NULL
		|| !(root_sc->tulip_features & TULIP_HAVE_SLAVEDINTR))
		break;
		root_sc = NULL;
	}
	if (root_sc != NULL
	    && root_sc->tulip_chipid == sc->tulip_chipid
	    && root_sc->tulip_pci_busno == sc->tulip_pci_busno) {
	    sc->tulip_features |= TULIP_HAVE_SLAVEDINTR;
	    sc->tulip_slaves = root_sc->tulip_slaves;
	    root_sc->tulip_slaves = sc;
	} else if(sc->tulip_features & TULIP_HAVE_SLAVEDINTR) {
	    printf("\nCannot find master device for de%d interrupts",
		    sc->tulip_unit);
	}
    } else {
	strcat(sc->tulip_boardid, "unknown ");
    }
    /*      sc->tulip_boardsw = &tulip_21140_eb_boardsw; */
    return;
}

d2770 1
a2770 1
    { tulip_identify_cogent_nic,	{ 0x00, 0x00, 0xD1 } }, /* Adaptec */
a2772 1
    { tulip_identify_compex_nic,	{ 0x00, 0x80, 0x48 } },
d2800 14
d3008 1
d3091 1
d3104 2
a3105 3
#if defined(IFF_ALLMULTI)
    if (sc->tulip_if.if_flags & IFF_ALLMULTI)
	sc->tulip_flags |= TULIP_ALLMULTI;
d3107 1
a3107 2
    sc->tulip_if.if_start = tulip_ifstart; /* so the setup packet gets queued */

d3218 1
a3218 3

    if ((sc->tulip_flags & TULIP_DEVICEPROBE) == 0
	&& sc->tulip_boardsw->bd_media_preset != NULL)
d3481 1
d3536 1
a3536 1
		if (!accept || total_len >= (MHLEN - 2)) {
d3556 2
a3559 4
#if defined(__NetBSD__)
		(*ifp->if_input)(ifp, ms);
#else
		m_adj(ms, sizeof(struct ether_header));
a3560 1
#endif
d3565 5
a3569 2
		m0->m_data += 2;        /* align data after header */
		m_copydata(ms, 0, total_len, mtod(m0, caddr_t));
a3571 4
#if defined(__NetBSD__)
		(*ifp->if_input)(ifp, m0);
#else
		m_adj(m0, sizeof(struct ether_header));
a3572 1
#endif /* NetBSD */
d3574 1
a3574 1
#endif /* TULIP_COPY_RXDATA */
d4275 2
a4285 1
	TULIP_CSR_WRITE(sc, csr_txpoll, 1);
a4321 1
    TULIP_CSR_WRITE(sc, csr_txpoll, 1);
d4485 27
a4511 1
	tulip_addr_filter(sc); /* reinit multicast filter */
d4792 1
d4796 19
d4816 1
d4818 1
d4864 3
d4931 4
d5075 27
d5127 7
d5140 3
d5259 8
d5432 1
a5432 6
    /* Make sure bus mastering is enabled. */
    pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
                   pci_conf_read(pa->pa_pc, pa->pa_tag,
                        PCI_COMMAND_STATUS_REG) |
                   PCI_COMMAND_MASTER_ENABLE);
#endif /* __NetBSD__  || __OpenBSD __ */
@


1.41
log
@

Added pci_mapreg* interface from NetBSD.
Added PCI 2.2 stuff from NetBSD
Modified if_de to use mapreg interface
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.40 1999/02/26 17:05:51 jason Exp $	*/
a117 4
#if NEISA > 0 && _BSDI_VERSION >= 199401
#include <i386/eisa/eisa.h>
#define	TULIP_EISA
#endif
d147 1
a147 1
#if defined(__i386__) || defined(TULIP_EISA)
a187 1
#if defined(IFM_ETHER)
a189 1
#endif
d1067 1
a1067 1
    sc->tulip_intrmask |= TULIP_STS_LINKPASS;
a1891 8
static void
tulip_delay_300ns(
    tulip_softc_t * const sc)
{
    int idx;
    for (idx = (300 / 33) + 1; idx > 0; idx--)
	(void) TULIP_CSR_READ(sc, csr_busmode);
}
d1893 1
a1893 1
#define EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
d1966 1
a1966 1
#define MII_EMIT    do { TULIP_CSR_WRITE(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
d2384 39
d2795 1
a2795 1
    { tulip_identify_cogent_nic,	{ 0x00, 0x00, 0xD1 } },
d2798 1
a2825 14
#if defined(TULIP_EISA)
    } else if (sc->tulip_chipid == TULIP_DE425) {
	int cnt;
	for (idx = 0, cnt = 0; idx < sizeof(testpat) && cnt < 32; cnt++) {
	    tmpbuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);
	    if (tmpbuf[idx] == testpat[idx])
		++idx;
	    else
		idx = 0;
	}
	for (idx = 0; idx < 32; idx++)
	    sc->tulip_rombuf[idx] = TULIP_CSR_READBYTE(sc, csr_enetrom);
	sc->tulip_boardsw = &tulip_21040_boardsw;
#endif /* TULIP_EISA */
a3019 1
#if defined(IFM_ETHER)
a3101 1
#endif
d3114 3
a3116 2
#if defined(IFF_ALLMULTI)    
    sc->tulip_if.if_flags &= ~IFF_ALLMULTI;
d3118 2
a3119 1
    sc->tulip_if.if_start = tulip_ifstart;	/* so the setup packet gets queued */
d3230 3
a3232 1
    if (sc->tulip_boardsw->bd_media_preset != NULL)
a3494 1
	    total_len -= sizeof(struct ether_header);
d3549 1
a3549 1
		if (!accept || total_len >= MHLEN) {
a3568 2
		ms->m_data += sizeof(struct ether_header);
		ms->m_len -= sizeof(struct ether_header);
d3571 4
d3576 1
d3581 2
a3582 5
		if (ms == me)
		    bcopy(mtod(ms, caddr_t) + sizeof(struct ether_header),
			  mtod(m0, caddr_t), total_len);
		else
		    m_copydata(ms, 0, total_len, mtod(m0, caddr_t));
d3585 4
d3590 1
d3592 1
a3592 1
#endif
a4292 2
    TULIP_CSR_WRITE(sc, csr_txpoll, 1);

d4302 1
d4339 1
d4503 1
a4503 27
#if !defined(IFM_ETHER)
	int flags = 0;
	if (ifp->if_flags & IFF_LINK0) flags |= 1;
	if (ifp->if_flags & IFF_LINK1) flags |= 2;
	if (ifp->if_flags & IFF_LINK2) flags |= 4;
	if (flags == 7) {
	    ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
	    sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP|TULIP_NOAUTOSENSE);
	    tulip_reset(sc);
	} else if (flags) {
	    tulip_media_t media;
	    for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
		if (sc->tulip_mediums[media] != NULL && --flags == 0) {
		    sc->tulip_flags |= TULIP_NOAUTOSENSE;
		    if (sc->tulip_media != media || (sc->tulip_flags & TULIP_DIDNWAY)) {
			sc->tulip_flags &= ~TULIP_DIDNWAY;
			tulip_linkup(sc, media);
		    }
		    break;
		}
	    }
	    if (flags)
		printf(TULIP_PRINTF_FMT ": ignored invalid media request\n", TULIP_PRINTF_ARGS);
	}
#endif
a4532 4
#if defined(SIOCSIFMTU)
#if !defined(ifr_mtu)
#define ifr_mtu ifr_metric
#endif
a4552 1
#endif /* SIOCSIFMTU */
a4783 1
#if defined(IFM_ETHER)
a4786 19
#else
    {
	tulip_media_t media;
	int cnt;
	printf(TULIP_PRINTF_FMT ": media:", TULIP_PRINTF_ARGS);
	for (media = TULIP_MEDIA_UNKNOWN, cnt = 1; cnt < 7 && media < TULIP_MEDIA_MAX; media++) {
	    if (sc->tulip_mediums[media] != NULL) {
		printf(" %d=\"%s\"", cnt, tulip_mediums[media]);
		cnt++;
	    }
	}
	if (cnt == 1) {
	    sc->tulip_features |= TULIP_HAVE_NOMEDIA;
	    printf(" none\n");
	} else {
	    printf("\n");
	}
    }
#endif
a4787 1
#if defined(IFM_ETHER)
a4788 1
#endif
a4833 3
#if defined(TULIP_EISA)
    sc->tulip_csrs.csr_enetrom		= csr_base + DE425_ENETROM_OFFSET;
#endif
a4897 4
#if defined(TULIP_EISA)
static const int tulip_eisa_irqs[4] = { IRQ5, IRQ9, IRQ10, IRQ11 };
#endif

a5037 27
#if defined(TULIP_EISA)
    case BUS_EISA: {
	unsigned tmp;

	if ((slot = eisa_match(cf, ia)) == 0)
	    return 0;
	ia->ia_iobase = slot << 12;
	ia->ia_iosize = EISA_NPORT;
	eisa_slotalloc(slot);
	tmp = inb(ia->ia_iobase + DE425_CFG0);
	irq = tulip_eisa_irqs[(tmp >> 1) & 0x03];
	/*
	 * Until BSD/OS likes level interrupts, force
	 * the DE425 into edge-triggered mode.
	 */
	if ((tmp & 1) == 0)
	    outb(ia->ia_iobase + DE425_CFG0, tmp | 1);
	/*
	 * CBIO needs to map to the EISA slot
	 * enable I/O access and Master
	 */
	outl(ia->ia_iobase + DE425_CBIO, ia->ia_iobase);
	outl(ia->ia_iobase + DE425_CFCS, 5 | inl(ia->ia_iobase + DE425_CFCS));
	ia->ia_aux = NULL;
	break;
    }
#endif /* TULIP_EISA */
a5062 7
#if defined(TULIP_EISA)
static char *tulip_eisa_ids[] = {
    "DEC4250",
    NULL
};
#endif

a5068 3
#if defined(TULIP_EISA)
    tulip_eisa_ids
#endif
a5184 8
#if defined(TULIP_EISA)
    } else {
	revinfo = inl(ia->ia_iobase + DE425_CFRV) & 0xFF;
	csroffset = TULIP_EISA_CSROFFSET;
	csrsize = TULIP_EISA_CSRSIZE;
	chipid = TULIP_DE425;
	cfdainfo = 0;
#endif /* TULIP_EISA */
d5350 6
a5355 1
#endif /* __NetBSD__ */
@


1.41.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.44 2001/02/03 06:10:17 mickey Exp $	*/
a56 3
#ifdef __OpenBSD__
#include <sys/timeout.h>
#endif
d125 1
a125 1
#if defined(__NetBSD__)
a217 3
#ifdef __OpenBSD__
    timeout_add(&sc->tulip_stmo, (hz + TULIP_HZ / 2) / TULIP_HZ);
#else
a218 1
#endif
a240 3
#ifdef __OpenBSD__
    timeout_add(&sc->tulip_ftmo, 1);
#else
a241 1
#endif
d503 1
a503 1
	 * It does!  If this is the first media we detected, then
d1186 1
a1186 1
	 * if no txprobe active
d1216 1
a1216 1

d1288 1
a1288 1
#endif
d1299 1
a1299 1
#endif
d1356 1
a1356 1
    }
d1522 1
a1522 1

d1585 1
a1585 1
 *  Start of 21140/21140A support which does not use the MII interface
d1724 1
a1724 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
d1762 1
a1762 1

d1914 1
a1914 1

d1916 1
a1916 1
    csr  = SROMSEL | SROMRD; EMIT;
d1932 1
a1932 1

d1936 2
a1937 2
{
    unsigned idx;
d1951 1
a1951 1

d1968 1
a1968 1
            csr ^= SROMCLKON; EMIT;     /* clock high; data valid */
d1992 1
a1992 1
    csr |= MII_WR; MII_EMIT;		/* clock low; assert write */
d2210 1
a2210 1
    }
d2437 1
a2437 1

d2494 1
a2494 1
	    if (data & TULIP_SROM_21041_EXTENDED)
d2827 1
a2827 1

d2833 1
a2833 1
		if(sc->tulip_boardsw == &tulip_21041_boardsw)
d2988 1
a2988 1

d3104 1
a3104 1
#if defined(IFF_ALLMULTI)
d3151 2
a3152 2
		sp[39] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]);
		sp[40] = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]);
d3167 2
a3168 2
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[0]);
		    *sp++ = FILT_BO(((u_int16_t *) enm->enm_addrlo)[1]);
d3188 2
a3189 2
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[0]);
	    *sp++ = FILT_BO(((u_int16_t *) sc->tulip_enaddr)[1]);
d3222 1
a3222 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
d3272 1
a3272 1
     * We need to collect all the mbufs were on the
d3282 1
a3282 1
	{
d3401 1
a3401 1
	 */
d3404 1
a3404 1

d3422 1
a3422 1
	     * more than one receive descriptor.
d3463 1
a3463 1
		     || (total_len <= sc->tulip_if.if_mtu + sizeof(struct ether_header) &&
d3580 1
a3580 1
	     * Couldn't allocate a new buffer.  Don't bother
d3711 1
a3711 1
			u_int32_t collisions =
d4253 1
a4253 1
    {
d4332 1
a4332 1

d4416 1
a4416 1
 * and thereby imposes no problems when TULIP_USE_SOFTINTR is
d4541 4
d4565 1
d4643 1
a4643 1
 * of this driver (if TULIP_USE_SOFTINTR defined) since
d4759 1
a4759 8

#ifdef __OpenBSD__
    timeout_set(&sc->tulip_stmo, tulip_timeout_callback, sc);
#if defined(TULIP_NEED_FASTTIMEOUT)
    timeout_set(&sc->tulip_ftmo, tulip_fasttimeout_callback, sc);
#endif
#endif

d4914 1
a4914 1

d5197 1
a5197 1
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at
d5227 1
a5227 1
    bus_space_tag_t iot, memt;
d5247 1
a5247 1
    tulip_csrptr_t csr_base;
d5411 1
a5411 1
		  PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT, 0,
d5447 1
a5447 1
    DELAY(100);	/* Wait 10 microseconds (actually 50 PCI cycles but at
@


1.41.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.41.4.1 2001/05/14 22:25:44 niklas Exp $	*/
a4118 5
#if 1 /* ALTQ */
    struct ifnet *ifp = &sc->tulip_if;
    struct mbuf *ombuf = m;
    int compressed = 0;
#endif
d4156 1
a4156 1
	unsigned clsize = PAGE_SIZE - (((u_long) addr) & PAGE_MASK);
a4171 20
#if 1 /* ALTQ */
		struct mbuf *tmp;
		/*
		 * tulip_mbuf_compress() frees the original mbuf.
		 * thus, we have to remove the mbuf from the queue
		 * before calling it.
		 * we don't have to worry about space shortage
		 * after compressing the mbuf since the compressed
		 * mbuf will take only two segs.
		 */
		if (compressed) {
		    /* should not happen */
		    printf("tulip_txput: compress called twice!\n");
		    goto finish;
		}
		IFQ_DEQUEUE(&ifp->if_snd, tmp);
		if (tmp != ombuf)
		    panic("tulip_txput: different mbuf dequeued!");
		compressed = 1;
#endif
d4229 1
a4229 1
	    clsize = PAGE_SIZE;
a4237 10
#if 1 /* ALTQ */
    if (!compressed && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
	/* remove the mbuf from the queue */
	struct mbuf *tmp;
	IFQ_DEQUEUE(&ifp->if_snd, tmp);
	if (tmp != ombuf)
	    panic("tulip_txput: different mbuf dequeued!");
    }
#endif

a4595 8
#if 1 /* ALTQ */
/*
 * the original dequeueing policy is dequeue-and-prepend if something
 * goes wrong.  when altq is used, it is changed to peek-and-dequeue.
 * the modification becomes a bit complicated since tulip_txput() might
 * copy and modify the mbuf passed.
 */
#endif
d4600 1
a4600 1
 */
d4614 5
a4618 9
	while (!IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	    struct mbuf *m, *m0;
	    IFQ_POLL(&sc->tulip_if.if_snd, m);
	    if (m == NULL)
		break;
	    if ((m0 = tulip_txput(sc, m)) != NULL) {
		if (m0 != m)
		    /* should not happen */
		    printf("tulip_if_start: txput failed!\n");
d4622 1
a4622 5
#ifdef ALTQ
	if (0) /* don't switch to the one packet mode */
#else
	if (IFQ_IS_EMPTY(&sc->tulip_if.if_snd))
#endif
d4637 5
a4641 7
	    && !IFQ_IS_EMPTY(&sc->tulip_if.if_snd)) {
	struct mbuf *m, *m0;
	IFQ_POLL(&sc->tulip_if.if_snd, m);
	if (m != NULL && (m0 = tulip_txput(sc, m)) != NULL)
	    if (m0 != m)
		/* should not happen */
		printf("tulip_if_start_one: txput failed!\n");
a4839 1
    IFQ_SET_READY(&ifp->if_snd);
d5422 1
a5422 1
		 &iot, &ioh, NULL, NULL, 0) == 0);
d5425 1
a5425 1
		  &memt, &memh, NULL, NULL, 0) == 0);
@


1.41.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.41.4.2 2001/07/04 10:42:10 niklas Exp $	*/
d94 2
d5542 2
a5543 1
	    if (pci_intr_map(pa, &intrhandle)) {
d5551 2
a5552 1
		printf(", couldn't establish interrupt");
@


1.41.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
#include <uvm/uvm_extern.h>
@


1.41.4.5
log
@Merge in -current from roughly a week ago
@
text
@d5028 1
a5028 1
static char *
d5564 1
a5564 1
	    if (!pci_map_int (config_id, intr_rtn, (void *) sc, &net_imask)) {
@


1.41.4.6
log
@Sync the SMP branch with 3.3
@
text
@d14 1
a14 1
 *    derived from this software without specific prior written permission
d627 1
d858 2
d1215 2
d5239 1
a5239 1
	return 2;
@


1.41.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.41.4.6 2003/03/28 00:38:21 niklas Exp $	*/
d2126 1
a2126 1
    strlcpy(sc->tulip_boardid, "DEC ", sizeof sc->tulip_boardid);
d2143 1
a2143 1
    strlcpy(sc->tulip_boardid, "ZNYX ZX3XX ", sizeof sc->tulip_boardid);
d2239 1
a2239 1
    strlcpy(sc->tulip_boardid, "SMC ", sizeof sc->tulip_boardid);
d2244 1
a2244 1
	    strlcat(sc->tulip_boardid, "9332DST ", sizeof sc->tulip_boardid);
d2247 1
a2247 1
	    strlcat(sc->tulip_boardid, "9334BDT ", sizeof sc->tulip_boardid);
d2249 1
a2249 1
	    strlcat(sc->tulip_boardid, "9332BDT ", sizeof sc->tulip_boardid);
d2257 1
a2257 1
    strlcat(sc->tulip_boardid, "8432", sizeof sc->tulip_boardid);
d2284 1
a2284 1
    strlcpy(sc->tulip_boardid, "Cogent ", sizeof sc->tulip_boardid);
d2287 1
a2287 1
	    strlcat(sc->tulip_boardid, "EM100TX ", sizeof sc->tulip_boardid);
d2291 1
a2291 1
	    strlcat(sc->tulip_boardid, "EM110TX ", sizeof sc->tulip_boardid);
d2295 1
a2295 1
	    strlcat(sc->tulip_boardid, "EM100FX ", sizeof sc->tulip_boardid);
d2308 1
a2308 1
	    strlcat(sc->tulip_boardid, "EM440TX ", sizeof sc->tulip_boardid);
d2320 1
a2320 1
    strlcpy(sc->tulip_boardid, "ACCTON ", sizeof sc->tulip_boardid);
d2323 1
a2323 1
	    strlcat(sc->tulip_boardid, "EN1207 ", sizeof sc->tulip_boardid);
d2328 1
a2328 1
	    strlcat(sc->tulip_boardid, "EN1207TX ", sizeof sc->tulip_boardid);
d2333 1
a2333 1
	    strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2337 1
a2337 1
	  strlcat(sc->tulip_boardid, "EN1203 ", sizeof sc->tulip_boardid);
d2350 1
a2350 1
    strlcpy(sc->tulip_boardid, "Asante ", sizeof sc->tulip_boardid);
d2938 1
a2938 2
		strlcpy(sc->tulip_boardid, root_sc->tulip_boardid,
			sizeof sc->tulip_boardid);
@


1.41.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2373 1
a2373 1
	mi->mi_reset_offset = 0;
@


1.41.4.9
log
@Merge with the trunk
@
text
@d78 1
d2095 1
a2095 1
#define	tulip_mchash(mca)	(ether_crc32_le(mca, 6) & 0x1FF)
d2097 1
a2097 1
    ((ether_crc32_le(databuf, 126) & 0xFFFFU) ^ 0xFFFFU) == \
d2099 22
@


1.40
log
@compensate for the fact that the check for ownership of a unicast packet
has moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.39 1999/02/04 22:33:32 deraadt Exp $	*/
a5239 5
#if defined(__OpenBSD__)
    pci_chipset_tag_t pc = pa->pa_pc;
    bus_addr_t tulipbase;
    bus_size_t tulipsize;
#endif
d5405 1
a5405 1
#if defined(__NetBSD__)
a5412 26
#endif

#if defined(__OpenBSD__)
    ioh_valid = 0;
    memh_valid = 0;
    csr_base = 0;

#if defined(TULIP_IO_MAPPED)
    iot = pa->pa_iot;
    retval = pci_io_find(pc, pa->pa_tag, PCI_CBIO, &tulipbase, &tulipsize);
    if (!retval) 
	retval = bus_space_map(pa->pa_iot, tulipbase, tulipsize, 0,
	    &ioh);

    ioh_valid = (retval == 0);
#else
    memt = pa->pa_memt;
    retval = pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &tulipbase, &tulipsize,
	NULL);
    if (!retval)
	retval = bus_space_map(pa->pa_memt, tulipbase, tulipsize, 0,
	    &memh);

    memh_valid = (retval == 0);
#endif

@


1.39
log
@correct attach printing for 4-port cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.38 1999/01/11 04:31:13 jason Exp $	*/
a3479 4
	    if ((sc->tulip_flags & (TULIP_PROMISC|TULIP_HASHONLY))
		    && (eh.ether_dhost[0] & 1) == 0
		    && !TULIP_ADDREQUAL(eh.ether_dhost, sc->tulip_enaddr))
		    goto next;
a3509 1
      next:
@


1.38
log
@remove pnic stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.37 1998/12/02 07:34:59 deraadt Exp $	*/
d5527 1
a5527 1
	    printf(": %s\n", intrstr);
d5529 1
@


1.37
log
@cogent-compatible adapters appearing in an adaptec ethernet block range
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.36 1998/10/28 23:40:42 csapuntz Exp $	*/
a196 3
static void tulip_pnic_media_probe(tulip_softc_t * const);
static void tulip_identify_pnic_nic(tulip_softc_t * const);
static void tulip_pnic_media_preset(tulip_softc_t * const);
d725 1
a725 2
	if (event == TULIP_MEDIAPOLL_LINKPASS &&
	    sc->tulip_chipid != TULIP_LC82C168) {
a1890 25
static void
tulip_pnic_media_probe(sc)
	tulip_softc_t * const sc;
{
	/* Media probe is actually handled by tulip_identify_pnic_nic */
	sc->tulip_media = TULIP_MEDIA_UNKNOWN;
}

static void
tulip_pnic_media_preset(sc)
	tulip_softc_t * const sc;
{
	TULIP_CSR_WRITE(sc, csr_command,
		sc->tulip_cmdmode | TULIP_CMD_PORTSELECT);
	DELAY(10);
}

static const tulip_boardsw_t tulip_pnic_boardsw = {
    TULIP_21040,
    tulip_pnic_media_probe,
    tulip_media_select,
    tulip_media_poll,
    tulip_pnic_media_preset,
};

a2052 15
    if (sc->tulip_chipid == TULIP_LC82C168) {
	u_int32_t v;
	int tmout = 1000;

	TULIP_CSR_WRITE(sc, csr_20, (MII_RDCMD << 28) |
				    (devaddr << 23) |
				    (regno << 18));
	do {
	    if (!((v = TULIP_CSR_READ(sc, csr_20)) & 0x80000000))
		return (v & 0xffff);
	} while (--tmout);
	printf("Timeout reading from PHY\n");
	return 0xffff;
    }

a2076 12
    if (sc->tulip_chipid == TULIP_LC82C168) {
	int tmout = 1000;

	TULIP_CSR_WRITE(sc, csr_20, (MII_WRCMD << 28) |
				    (devaddr << 23) | (regno << 18) | data);
	do {
	    if (! (TULIP_CSR_READ(sc, csr_20) & 0x80000000))
		return;
	} while (--tmout);
	return;
    }

a2342 43
tulip_identify_pnic_nic(
    tulip_softc_t * const sc)
{
    tulip_media_info_t *mi = sc->tulip_mediainfo;
    int idx;

    strcpy(sc->tulip_boardid, "Lite-On ");
    mi->mi_type = TULIP_MEDIAINFO_MII;
    mi->mi_gpr_length = 0;
    mi->mi_gpr_offset = 0;
    mi->mi_reset_length = 0;
    mi->mi_reset_offset = 0;;
    mi->mi_phyaddr = TULIP_MII_NOPHY;
    for (idx = 20; idx > 0 && mi->mi_phyaddr == TULIP_MII_NOPHY; idx--) {
	DELAY(10000);
	mi->mi_phyaddr = tulip_mii_get_phyaddr(sc, 0);
    }
    if (mi->mi_phyaddr == TULIP_MII_NOPHY) {
	printf(TULIP_PRINTF_FMT ": can't find phy 0\n", TULIP_PRINTF_ARGS);
	return;
    }

    sc->tulip_features |= TULIP_HAVE_MII | TULIP_HAVE_POWERMGMT;
    mi->mi_capabilities  = PHYSTS_10BASET | PHYSTS_10BASET_FD |
			   PHYSTS_100BASETX | PHYSTS_100BASETX_FD;
    mi->mi_advertisement = PHYSTS_10BASET | PHYSTS_10BASET_FD |
			   PHYSTS_100BASETX | PHYSTS_100BASETX_FD;
    mi->mi_full_duplex   = PHYSTS_10BASET_FD | PHYSTS_100BASETX_FD;
    mi->mi_tx_threshold  = PHYSTS_10BASET | PHYSTS_10BASET_FD;
    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX_FD);
    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 100BASETX);
    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET_FD);
    TULIP_MEDIAINFO_ADD_CAPABILITY(sc, mi, 10BASET);
    mi->mi_phyid = (tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDLOW) << 16) |
	    tulip_mii_readreg(sc, mi->mi_phyaddr, PHYREG_IDHIGH);

    TULIP_CSR_WRITE(sc, csr_15, 0x00000001);
    TULIP_CSR_WRITE(sc, csr_12, 0x00000032);
    TULIP_CSR_WRITE(sc, csr_23, 0x0201b07a);
    sc->tulip_cmdmode = 0x812C0000;
}

static void
a2772 1
    { tulip_identify_pnic_nic,		{ 0x00, 0xA0, 0xCC } },
a2813 15
    } else if (sc->tulip_chipid == TULIP_LC82C168) {
	for (idx = 0; idx < 3; idx++) {
	    int tmout = 10000;
	    TULIP_CSR_WRITE(sc, csr_19, 0x600 | idx);
	    while ((csr = TULIP_CSR_READ(sc, csr_9)) & 0x80000000 && --tmout);
	    if (!tmout)
		return -1;
	    sc->tulip_rombuf[idx * 2] = (csr >> 8) & 0xff;
	    sc->tulip_enaddr[idx * 2] = (csr >> 8) & 0xff;
	    sc->tulip_rombuf[(idx * 2) + 1] = csr & 0xff;
	    sc->tulip_enaddr[(idx * 2) + 1] = csr & 0xff;
	}
	sc->tulip_boardsw = &tulip_pnic_boardsw;
	sc->tulip_features |= TULIP_HAVE_OKROM;
	goto check_oui;
a4873 3
    sc->tulip_csrs.csr_19		= csr_base + 19 * csr_size; /* PNIC */
    sc->tulip_csrs.csr_20		= csr_base + 20 * csr_size; /* PNIC */
    sc->tulip_csrs.csr_23		= csr_base + 23 * csr_size; /* PNIC */
a5172 6
    if (PCI_VENDORID(pa->pa_id) == PCI_VENDOR_LITEON) {
	if (PCI_CHIPID(pa->pa_id) == PCI_PRODUCT_LITEON_PNIC)
	    return 1;
	return 0;
    }

a5298 3
    if (PCI_VENDOR(id) == PCI_VENDOR_LITEON &&
	PCI_CHIPID(id) == PCI_PRODUCT_LITEON_PNIC)
	chipid = TULIP_LC82C168;
a5345 2
    if (chipid == TULIP_LC82C168)
	    sc->tulip_features |= TULIP_HAVE_POWERMGMT;
@


1.36
log
@

Partial merge from netBSD 102498. Seems to fix autonegotation difficulties
on Bay Networks FA310TX card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.35 1998/10/08 05:51:18 jason Exp $	*/
d2869 1
@


1.35
log
@Support for the Lite-On PNIC found on Netgear FA310TX rev D1 and
several other boards.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.34 1998/09/09 04:05:36 rahnds Exp $	*/
a154 1
#if 0
d159 1
a436 1
	tulip_init(sc);
d438 1
d670 2
a671 1
		tulip_reset(sc);	/* restart probe */
d729 2
a730 1
		sc->tulip_chipid != TULIP_LC82C168)
d733 1
a733 1
	else
d736 1
d955 2
d1067 1
a1067 1
    sc->tulip_intrmask |= TULIP_STS_LINKPASS;
d2157 13
a2169 1
    u_int idx, bit, data, crc = 0xFFFFFFFFUL;
a2170 3
    for (idx = 0; idx < datalen; idx++)
        for (data = *databuf++, bit = 0; bit < 8; bit++, data >>= 1)
            crc = (crc >> 1) ^ (((crc ^ data) & 1) ? TULIP_CRC32_POLY : 0);
a2345 1
	    sc->tulip_boardsw = &tulip_21140_cogent_em100_boardsw;
d2376 2
a2377 1
	    sc->tulip_boardsw = &tulip_21140_accton_boardsw;
d2381 2
a2382 1
	    sc->tulip_boardsw = &tulip_21140_eb_boardsw;
d2623 1
a2623 1
		    srom_media = (tulip_srom_media_t) dp[0];
d2689 1
d2692 1
d2712 1
a2712 1
		    srom_media = (tulip_srom_media_t) dp[0];
d2722 4
a2725 4
		    if (type & 0x40) {
			mi->mi_sia_connectivity = dp[0] + dp[1] * 256;
			mi->mi_sia_tx_rx        = dp[2] + dp[3] * 256;
			mi->mi_sia_general      = dp[4] + dp[5] * 256;
d2739 1
d2744 1
d2752 2
a2753 2
		    mi->mi_sia_gp_control = (dp[0] + dp[1] * 256) << 16;
		    mi->mi_sia_gp_data    = (dp[2] + dp[3] * 256) << 16;
d2790 1
d2793 1
d2835 2
d3321 4
d3344 1
d3425 1
a3425 1
	|TULIP_STS_TXUNDERFLOW|TULIP_STS_TXBABBLE|TULIP_STS_LINKFAIL
d3881 1
a3881 1
    const char thrsh[] = "72|128\0\0\096|256\0\0\0128|512\0\0160|1024\0";
d3928 1
a3928 1
	if (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL)) {
d4002 1
d4173 1
a4173 1
		}
d4186 1
a4186 1
		    } else {
d4188 1
a4188 1
		    }
d4192 2
a4193 2
		    break;
		}
d4199 2
a4200 2
		    break;
		}
d4204 1
a4204 1
	    }
d4210 1
a4210 1
	}
d4222 1
a4222 1
	tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
d4406 1
a4414 1
    sc->tulip_if.if_start = tulip_ifstart_one;
d4463 1
a4463 1
		    }
d4545 1
a4545 1
	tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);
d4735 2
d5413 8
a5420 8
	if (PCI_CHIPID(id) == CHIPID_21040) chipid = TULIP_21040;
	else if (PCI_CHIPID(id) == CHIPID_21140) {
	    chipid = (revinfo >= 0x20) ? TULIP_21140A : TULIP_21140;
	} else if (PCI_CHIPID(id) == CHIPID_21142) {
	    chipid = (revinfo >= 0x20) ? TULIP_21143 : TULIP_21142;
	}
	else if (PCI_CHIPID(id) == CHIPID_21041) chipid = TULIP_21041;
	else if (PCI_CHIPID(id) == CHIPID_21142) chipid = TULIP_21142;
d5422 2
a5423 2
    else if (PCI_VENDOR(id) == PCI_VENDOR_LITEON &&
		PCI_CHIPID(id) == PCI_PRODUCT_LITEON_PNIC)
d5425 1
d5465 1
a5465 1
	if (chipid != TULIP_21041 || sc->tulip_revinfo >= 0x20)
d5469 1
a5469 1
	if (chipid != TULIP_21041 && sc->tulip_revinfo >= 0x20)
@


1.34
log
@Dont swab the data twice, only when assiging to the structure.
This only affect big endian machines (powerpc).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.33 1998/08/28 06:31:23 rahnds Exp $	*/
d143 1
d197 3
d727 2
a728 1
	if (event == TULIP_MEDIAPOLL_LINKPASS)
d1289 11
d1890 25
d2077 15
d2114 15
a2128 1
    unsigned csr = TULIP_CSR_READ(sc, csr_srom_mii) & (MII_RD|MII_DOUT|MII_CLK);
d2384 43
d2848 1
d2890 15
d4957 3
d5259 6
d5391 3
d5440 2
@


1.33
log
@Changes to make if_de driver work on big endian machines with a 21040 based
card. Tested on i386 and alpha. Could use some cleanup to swab constants
instead of variables, so that the compiler can do the work, not the processor.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.32 1998/08/07 16:48:16 pefo Exp $	*/
d4172 1
a4172 1
	    d_status = DESC_BO(TULIP_DSTS_OWNER);
@


1.32
log
@com.c needs to know about mem mapped ports in ppc systems.

ncr.c and if_de.c needs some hooks for systems with ncr and dec
ether chips on the motherboard that runs on odd clocks and doesn't
support a srom. srom is emulated in machine dependent code.

big endian support for ncr and dec ether finished. the 21040
have some more coding requirements if it is to run BE since
it does not have the descriptor endian swap configuration bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.31 1998/05/28 20:25:51 deraadt Exp $	*/
d3197 4
a3200 1
		    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN) : 0));
d3226 1
a3226 1
	di->d_status = 0;
d3238 11
a3248 3
	di->d_status = 0;
	di->d_length1 = 0; di->d_addr1 = 0;
	di->d_length2 = 0; di->d_addr2 = 0;
d3366 1
a3366 1
	if ((((volatile tulip_desc_t *) eop)->d_status & (TULIP_DSTS_OWNER|TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) == (TULIP_DSTS_RxFIRSTDESC|TULIP_DSTS_RxLASTDESC)) {
d3373 1
a3373 1
	    if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
d3381 1
a3381 1
	    while ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {
d3384 1
a3384 1
		if (eop == ri->ri_nextout || ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER))) {
d3416 1
a3416 1
	total_len = ((eop->d_status >> 16) & 0x7FFF) - 4;
d3418 1
a3418 1
		&& ((eop->d_status & TULIP_DSTS_ERRSUM) == 0
d3421 1
a3421 1
			 (eop->d_status & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxRUNT|
d3445 1
a3445 1
	    if (eop->d_status & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxOVERFLOW|TULIP_DSTS_RxWATCHDOG)) {
d3449 1
a3449 1
		if (eop->d_status & TULIP_DSTS_RxTOOLONG) {
d3453 2
a3454 2
		if (eop->d_status & TULIP_DSTS_RxBADCRC) {
		    if (eop->d_status & TULIP_DSTS_RxDRBBLBIT) {
d3557 8
a3564 3
	    ri->ri_nextout->d_length1 = TULIP_RX_BUFLEN;
	    ri->ri_nextout->d_addr1 = TULIP_KVATOPHYS(sc, mtod(ms, caddr_t));
	    ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
d3597 1
a3597 1
	if (((volatile tulip_desc_t *) ri->ri_nextin)->d_status & TULIP_DSTS_OWNER)
d3600 6
a3605 1
	d_flag = ri->ri_nextin->d_flag;
d3616 1
a3616 1
		if (ri->ri_nextin->d_flag & TULIP_DFLAG_TxINVRSFILT)
d3627 1
a3627 1
		const u_int32_t d_status = ri->ri_nextin->d_status;
d4147 10
a4156 4
		eop->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
		eop->d_status = d_status;
		eop->d_addr1 = TULIP_KVATOPHYS(sc, addr);
		eop->d_length1 = slen;
d4161 7
a4167 2
		eop->d_addr2 = TULIP_KVATOPHYS(sc, addr);
		eop->d_length2 = slen;
d4172 1
a4172 1
	    d_status = TULIP_DSTS_OWNER;
d4196 1
a4196 1
    nextout->d_status = 0;
d4203 5
a4207 2
	eop->d_addr2 = 0;
	eop->d_length2 = 0;
d4214 7
a4220 1
    eop->d_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;
d4227 8
a4234 2
    ri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;
    ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
d4329 24
a4352 12
    nextout->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
    nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG
	|TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;
    if (sc->tulip_flags & TULIP_WANTHASHPERFECT)
	nextout->d_flag |= TULIP_DFLAG_TxHASHFILT;
    else if (sc->tulip_flags & TULIP_WANTHASHONLY)
	nextout->d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;

    nextout->d_length1 = sizeof(sc->tulip_setupbuf);
    nextout->d_addr1 = TULIP_KVATOPHYS(sc, sc->tulip_setupbuf);
    nextout->d_length2 = 0;
    nextout->d_addr2 = 0;
d4365 2
a4366 2
    ri->ri_nextout->d_status = 0;
    nextout->d_status = TULIP_DSTS_OWNER;
d4871 7
a4877 1
    ri->ri_last[-1].d_flag = TULIP_DFLAG_ENDRING;
@


1.31
log
@do not panic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.30 1998/05/22 21:37:04 deraadt Exp $	*/
d1051 10
d1232 7
d2792 9
a2800 3
#ifdef powerpc
/*XXX This should be fixed in some other way. Right now we need someting. */
	pci_ether_hw_addr(sc->tulip_pc, (u_char *)(&sc->tulip_rombuf));
d3094 1
a3094 1
		    sp[hash >> 4] |= 1 << (hash & 0xF);
d3108 1
a3108 1
	    sp[hash >> 4] |= 1 << (hash & 0xF);
d3111 1
a3111 1
		sp[hash >> 4] |= 1 << (hash & 0xF);
d3113 3
a3115 3
		sp[39] = ((u_int16_t *) sc->tulip_enaddr)[0]; 
		sp[40] = ((u_int16_t *) sc->tulip_enaddr)[1]; 
		sp[41] = ((u_int16_t *) sc->tulip_enaddr)[2];
d3129 3
a3131 3
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[0]; 
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[1]; 
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[2];
d3142 3
a3144 3
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
d3150 3
a3152 3
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[0]; 
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[1]; 
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[2];
d3192 7
d3203 2
a3204 1
		    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));
d3549 3
d4137 3
d4278 3
d4781 27
@


1.30
log
@EM100FX
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.29 1998/02/22 21:26:57 niklas Exp $	*/
d526 1
a526 1
	panic("tulip_media_link_monitor: %s: botch at line %d\n",
d811 1
a811 1
		panic("tulip_media_poll: botch at line %d\n", __LINE__);
d1465 1
a1465 1
	    panic("tulip_media_poll: botch at line %d\n", __LINE__);
@


1.29
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.28 1998/01/07 11:03:26 deraadt Exp $	*/
d2238 7
a2244 1
	    strcat(sc->tulip_boardid, "EM100FX ");
@


1.28
log
@now this is really pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.27 1998/01/05 13:35:19 deraadt Exp $	*/
d3381 1
a3381 1
	    if (sc->tulip_bpf != NULL)
d3386 1
@


1.27
log
@new style pci attach printing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.26 1997/11/16 07:46:46 millert Exp $	*/
d5341 1
a5341 1
	    printf(", %s\n", intrstr);
@


1.26
log
@compile on alpha, needs testing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.25 1997/11/13 21:14:15 rees Exp $	*/
d4629 1
a4629 1
	   TULIP_PRINTF_FMT ": %s%s pass %d.%d%s\n",
d4636 1
a4636 3
		 == TULIP_HAVE_ISVSROM ? " (invalid EESPROM checksum)" : "");
    printf(TULIP_PRINTF_FMT ": address " TULIP_EADDR_FMT "\n",
	   TULIP_PRINTF_ARGS,
a5324 2
	    printf("\n");

d5327 1
a5327 1
		printf("%s: couldn't map interrupt\n", sc->tulip_dev.dv_xname);
d5334 1
a5334 1
		printf("%s: couldn't establish interrupt",
d5341 1
a5341 1
	    printf("%s: interrupting at %s\n", sc->tulip_dev.dv_xname, intrstr);
@


1.25
log
@merge netbsd 1.56.2.1 for de500B (and other 21143) support
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.24 1997/10/20 20:56:12 pefo Exp $	*/
d5178 1
a5178 1
#if defined(__alpha__)
@


1.24
log
@Few minor changes to make if_de work big endian on 21140
@
text
@d1 1
a1 1
/*	$OpenBSD: if_de.c,v 1.23 1997/07/29 19:31:45 downsj Exp $	*/
d180 1
d182 2
a196 1

a243 1

d252 1
a252 1
     * Strangely, BNC and AUI will 'see" receive data if
d273 1
d276 3
a278 2
    IF_PREPEND(&sc->tulip_if.if_snd, m);
    tulip_ifstart(&sc->tulip_if);
a282 1

d309 1
a382 1

d428 4
a431 1
    } else {
a436 1

a453 1

a516 1

d600 4
a624 1

d901 1
a911 1

a934 1

a1028 1

a1049 1

a1221 1

a1269 1

a1330 1

a1354 1

a1476 1

d1491 1
a1491 1
    if (media != TULIP_MEDIA_UNKNOWN) {
a1548 1

a1553 1

a1581 1

d1627 53
a1736 1

a1783 1

a1840 1

a1856 1

a1860 1

a1872 1

d1903 1
a1903 1
    int idx; 
a1945 1

a2054 1

d2057 1
a2057 1
    ((tulip_crc32(databuf, 126) & 0xFFFF) ^ 0xFFFF)== \
a2072 1

a2088 1

a2181 1

d2198 2
a2200 2
	} else {
	    strcpy(&sc->tulip_boardid[4], "9334BDT ");
a2230 1

d2262 27
a2345 1

d2350 1
a2350 1
    int idx1, idx2, idx3;
d2352 2
a2353 2
    /* const */ tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];
    tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);
a2455 1

d2700 1
a2700 2

static /* const */ struct {
d2711 1
d2723 1
a2723 1
    int cksum, rom_cksum, idx;
d2780 1
a2780 1
	    sc->tulip_features |= TULIP_HAVE_ISVSROM;
d2793 3
a2940 1

a2996 1

a3025 1

d3034 1
a3034 1
    sc->tulip_flags |= TULIP_WANTSETUP;
d3040 1
d3065 1
a3065 1
		    sp[hash >> 4] |= FILT_SWAP(1 << (hash & 0xF));
d3079 1
a3079 1
	    sp[hash >> 4] |= FILT_SWAP(1 << (hash & 0xF));
d3082 1
a3082 1
		sp[hash >> 4] |= FILT_SWAP(1 << (hash & 0xF));
d3084 3
a3086 3
		sp[39] = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[0]);
		sp[40] = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[1]);
		sp[41] = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[2]);
d3100 3
a3102 3
		    *sp++ = FILT_SWAP(((u_int16_t *) enm->enm_addrlo)[0]);
		    *sp++ = FILT_SWAP(((u_int16_t *) enm->enm_addrlo)[1]);
		    *sp++ = FILT_SWAP(((u_int16_t *) enm->enm_addrlo)[2]);
d3113 3
a3115 3
	    *sp++ = FILT_SWAP(0xffff);
	    *sp++ = FILT_SWAP(0xffff);
	    *sp++ = FILT_SWAP(0xffff);
d3121 3
a3123 3
	    *sp++ = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[0]);
	    *sp++ = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[1]);
	    *sp++ = FILT_SWAP(((u_int16_t *) sc->tulip_enaddr)[2]);
a3131 1

d3167 1
a3167 1
		    |(BYTE_ORDER != LITTLE_ENDIAN ? (TULIP_BUSMODE_DESC_BIGENDIAN/*|TULIP_BUSMODE_BIGENDIAN*/) : 0));
d3220 2
a3221 1
	    |TULIP_STS_TXBABBLE|TULIP_STS_LINKFAIL|TULIP_STS_RXSTOPPED;
d3235 1
a3235 1
			 |TULIP_RXACT|TULIP_TXINTPENDING);
a3238 1

d3252 1
a3271 1

d3274 2
a3275 1
	tulip_ifstart(&sc->tulip_if);
a3281 1

d3567 5
d3573 4
a3576 2
		if (d_flag & TULIP_DFLAG_TxWANTINTR) {
		    sc->tulip_flags &= ~TULIP_TXINTPENDING;
a3597 5

#if defined(TULIP_DEBUG)
			printf ("Output error, status: %x, %x\n", d_status,
				TULIP_CSR_READ(sc, csr_command));
#endif
d3606 4
a3653 1

d3666 1
a3666 1
    for (sep = " ", mask = 1; mask >= csr; mask <<= 1, msgp++) {
d3689 1
d3773 1
a3773 1
	if (sc->tulip_txinfo.ri_free < sc->tulip_txinfo.ri_max) {
d3817 9
d3895 1
a3895 1
    tulip_softc_t * sc;
d3898 1
a3898 1
    for (sc = (tulip_softc_t *) arg; sc != NULL; sc = sc->tulip_slaves) {
d3939 328
d4268 1
d4276 1
a4276 1
    struct ifnet * const ifp,
d4280 2
a4281 1
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);
d4293 3
a4295 3
	case SIOCSIFADDR: {
	    ifp->if_flags |= IFF_UP;
	    switch(ifa->ifa_addr->sa_family) {
d4297 5
a4301 5
		case AF_INET: {
		    tulip_init(sc);
		    TULIP_ARP_IFINIT(sc, ifa);
		    break;
		}
d4305 18
a4322 18
		/*
		 * This magic copied from if_is.c; I don't use XNS,
		 * so I have no way of telling if this actually
		 * works or not.
		 */
		case AF_NS: {
		    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
		    if (ns_nullhost(*ina)) {
			ina->x_host = *(union ns_host *)(sc->tulip_enaddr);
		    } else {
			ifp->if_flags &= ~IFF_RUNNING;
			bcopy((caddr_t)ina->x_host.c_host,
			      (caddr_t)sc->tulip_enaddr,
			      sizeof(sc->tulip_enaddr));
		    }
		    tulip_init(sc);
		    break;
		}
d4325 2
a4326 5
		default: {
		    tulip_init(sc);
		    break;
		}
	    }
a4328 5
	case SIOCGIFADDR: {
	    bcopy((caddr_t) sc->tulip_enaddr,
		  (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,
		  6);
	    break;
d4330 8
d4339 1
a4339 1
	case SIOCSIFFLAGS: {
d4341 18
a4358 20
	    int flags = 0;
	    if (ifp->if_flags & IFF_LINK0) flags |= 1;
	    if (ifp->if_flags & IFF_LINK1) flags |= 2;
	    if (ifp->if_flags & IFF_LINK2) flags |= 4;
	    if (flags == 7) {
		ifp->if_flags &= ~(IFF_LINK0|IFF_LINK1|IFF_LINK2);
		sc->tulip_media = TULIP_MEDIA_UNKNOWN;
		sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
		sc->tulip_flags &= ~(TULIP_WANTRXACT|TULIP_LINKUP|TULIP_NOAUTOSENSE);
		tulip_reset(sc);
	    } else if (flags) {
		tulip_media_t media;
		for (media = TULIP_MEDIA_UNKNOWN; media < TULIP_MEDIA_MAX; media++) {
		    if (sc->tulip_mediums[media] != NULL && --flags == 0) {
			sc->tulip_flags |= TULIP_NOAUTOSENSE;
			if (sc->tulip_media != media || (sc->tulip_flags & TULIP_DIDNWAY)) {
			    sc->tulip_flags &= ~TULIP_DIDNWAY;
			    tulip_linkup(sc, media);
			}
			break;
d4360 1
a4361 2
		if (flags)
		    printf(TULIP_PRINTF_FMT ": ignored invalid media request\n");
d4363 3
d4367 3
a4369 3
	    tulip_init(sc);
	    break;
	}
d4372 5
a4376 5
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA: {
	    error = ifmedia_ioctl(ifp, ifr, &sc->tulip_ifmedia, cmd);
	    break;
	}
d4379 9
a4387 9
	case SIOCADDMULTI:
	case SIOCDELMULTI: {
	    /*
	     * Update multicast listeners
	     */
	    if (cmd == SIOCADDMULTI)
		error = ether_addmulti(ifr, TULIP_ETHERCOM(sc));
	    else
		error = ether_delmulti(ifr, TULIP_ETHERCOM(sc));
d4389 4
a4392 6
	    if (error == ENETRESET) {
		tulip_addr_filter(sc);		/* reset multicast filtering */
		tulip_init(sc);
		error = 0;
	    }
	    break;
d4394 2
d4400 5
a4404 5
	case SIOCSIFMTU:
	    /*
	     * Set the interface MTU.
	     */
	    if (ifr->ifr_mtu > ETHERMTU
d4406 3
a4408 3
		    && sc->tulip_chipid != TULIP_21140
		    && sc->tulip_chipid != TULIP_21140A
		    && sc->tulip_chipid != TULIP_21041
d4410 5
a4414 5
		) {
		error = EINVAL;
		break;
	    }
	    ifp->if_mtu = ifr->ifr_mtu;
d4416 2
a4417 2
	    tulip_reset(sc);
	    tulip_init(sc);
d4419 1
a4419 1
	    break;
d4423 4
a4426 4
	case SIOCGADDRROM: {
	    error = copyout(sc->tulip_rombuf, ifr->ifr_data, sizeof(sc->tulip_rombuf));
	    break;
	}
d4429 4
a4432 4
	case SIOCGCHIPID: {
	    ifr->ifr_metric = (int) sc->tulip_chipid;
	    break;
	}
d4434 4
a4437 4
	default: {
	    error = EINVAL;
	    break;
	}
d4441 1
a4444 1

d4446 1
a4446 1
 * This routine gets called at device spl (from ether_output).  This might
d4449 1
a4449 1
 */
d4455 1
a4456 2
    struct ifqueue * const ifq = &ifp->if_snd;
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
d4458 1
a4458 3
    if ((ifp->if_flags & IFF_RUNNING) == 0
	    && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)
	return;
d4460 2
a4461 5
    for (;;) {
	tulip_desc_t *eop, *nextout;
	int segcnt, free, recopy;
	u_int32_t d_status;
	struct mbuf *m, *m0, *next_m0;
d4463 6
a4468 12
	if ((sc->tulip_flags & (TULIP_WANTSETUP|TULIP_TXPROBE_ACTIVE)) == TULIP_WANTSETUP) {
#if defined(TULIP_DEBUG)
	    if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {
		printf(TULIP_PRINTF_FMT ": ifstart: tx not running\n",
		       TULIP_PRINTF_ARGS);
		ifp->if_flags |= IFF_OACTIVE;
		return;
	    }
#endif
	    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {
		ifp->if_flags |= IFF_OACTIVE;
		return;
a4469 30
	    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,
		   sizeof(sc->tulip_setupbuf));
	    sc->tulip_flags &= ~TULIP_WANTSETUP;
	    sc->tulip_flags |= TULIP_DOINGSETUP;
	    ri->ri_free--;
	    nextout = ri->ri_nextout;
	    nextout->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
	    nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG
		    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;
	    if (sc->tulip_flags & TULIP_WANTHASHPERFECT)
		nextout->d_flag |= TULIP_DFLAG_TxHASHFILT;
	    else if (sc->tulip_flags & TULIP_WANTHASHONLY)
		nextout->d_flag |= TULIP_DFLAG_TxHASHFILT|TULIP_DFLAG_TxINVRSFILT;
	    nextout->d_length1 = sizeof(sc->tulip_setupbuf);
	    nextout->d_addr1 = TULIP_KVATOPHYS(sc, sc->tulip_setupbuf);
	    nextout->d_length2 = 0;
	    nextout->d_addr2 = 0;
	    /*
	     * Advance the ring for the next transmit packet.
	     */
	    if (++ri->ri_nextout == ri->ri_last)
		ri->ri_nextout = ri->ri_first;
	    /*
	     * Make sure the next descriptor is owned by us since it
	     * may have been set up above if we ran out of room in the
	     * ring.
	     */
	    ri->ri_nextout->d_status = 0;
	    nextout->d_status = TULIP_DSTS_OWNER;
	    TULIP_CSR_WRITE(sc, csr_txpoll, 1);
d4471 1
d4473 2
a4474 3
	IF_DEQUEUE(ifq, m);
	if (m == NULL)
	    return;
d4476 6
a4481 10
#if defined(TULIP_DEBUG)
	if ((sc->tulip_cmdmode & TULIP_CMD_TXRUN) == 0) {
	    printf(TULIP_PRINTF_FMT ": ifstart%s: tx not running\n",
		   TULIP_PRINTF_ARGS,
		   (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) ? "(probe)" : "");
	    ifp->if_flags |= IFF_OACTIVE;
	    IF_PREPEND(ifq, m);
	    return;
	}
#endif
d4483 6
a4488 214
	/*
	 * Now we try to fill in our transmit descriptors.  This is
	 * a bit reminiscent of going on the Ark two by two
	 * since each descriptor for the TULIP can describe
	 * two buffers.  So we advance through packet filling
	 * each of the two entries at a time to to fill each
	 * descriptor.  Clear the first and last segment bits
	 * in each descriptor (actually just clear everything
	 * but the end-of-ring or chain bits) to make sure
	 * we don't get messed up by previously sent packets.
	 *
	 * We may fail to put the entire packet on the ring if
	 * there is either not enough ring entries free or if the
	 * packet has more than MAX_TXSEG segments.  In the former
	 * case we will just wait for the ring to empty.  In the
	 * latter case we have to recopy.
	 */
	d_status = 0;
	recopy = 0;
	eop = nextout = ri->ri_nextout;
	m0 = m;
	segcnt = 0;
	free = ri->ri_free;
	do {
	    int len = m0->m_len;
	    caddr_t addr = mtod(m0, caddr_t);
	    unsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));

	    next_m0 = m0->m_next;
	    while (len > 0) {
		unsigned slen = min(len, clsize);
#ifdef BIG_PACKET
		int partial = 0;
		if (slen >= 2048)
		    slen = 2040, partial = 1;
#endif
		segcnt++;
		if (segcnt > TULIP_MAX_TXSEG) {
		    recopy = 1;
		    next_m0 = NULL; /* to break out of outside loop */
		    break;
		}
		if (segcnt & 1) {
		    if (--free == 0) {
			/*
			 * See if there's any unclaimed space in the
			 * transmit ring.
			 */
			if ((free += tulip_tx_intr(sc)) == 0) {
			    /*
			     * There's no more room but since nothing
			     * has been committed at this point, just
			     * show output is active, put back the
			     * mbuf and return.
			     */
			    IF_PREPEND(ifq, m);
			    ifp->if_flags |= IFF_OACTIVE;
			    return;
			}
		    }
		    eop = nextout;
		    if (++nextout == ri->ri_last)
			nextout = ri->ri_first;
		    eop->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
		    eop->d_status = d_status;
		    eop->d_addr1 = TULIP_KVATOPHYS(sc, addr);
		    eop->d_length1 = slen;
		} else {
		    /*
		     *  Fill in second half of descriptor
		     */
		    eop->d_addr2 = TULIP_KVATOPHYS(sc, addr);
		    eop->d_length2 = slen;
		}
		d_status = TULIP_DSTS_OWNER;
		len -= slen;
		addr += slen;
#ifdef BIG_PACKET
		if (partial)
		    continue;
#endif
		clsize = CLBYTES;
	    }
	} while ((m0 = next_m0) != NULL);

	/*
	 * The packet exceeds the number of transmit buffer
	 * entries that we can use for one packet, so we have
	 * recopy it into one mbuf and then try again.
	 */
	if (recopy) {
#if MCLBYTES >= ETHERMTU + 18
	    MGETHDR(m0, M_DONTWAIT, MT_DATA);
	    if (m0 != NULL) {
		if (m->m_pkthdr.len > MHLEN) {
		    MCLGET(m0, M_DONTWAIT);
		    if ((m0->m_flags & M_EXT) == 0) {
			m_freem(m);
			m_freem(m0);
			continue;
		    }
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));
		m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;
	    }
#else
	    int mlen = MHLEN;
	    int len = m->m_pkthdr.len;
	    struct mbuf **mp = &m0;

	    while (len > 0) {
		if (mlen == MHLEN) {
		    MGETHDR(*mp, M_DONTWAIT, MT_DATA);
		} else {
		    MGET(*mp, M_DONTWAIT, MT_DATA);
		}
		if (*mp == NULL) {
		    m_freem(m0);
		    m0 = NULL;
		    break;
		}
		if (len > MLEN) {
		    MCLGET(*mp, M_DONTWAIT);
		    if (((*mp)->m_flags & M_EXT) == 0) {
			m_freem(m0);
			m0 = NULL;
			break;
		    }
		    (*mp)->m_len = len <= MCLBYTES ? len : MCLBYTES;
		} else {
		    (*mp)->m_len = len <= mlen ? len : mlen;
		}
		m_copydata(m, m->m_pkthdr.len - len,
			   (*mp)->m_len, mtod((*mp), caddr_t));
		len -= (*mp)->m_len;
		mp = &(*mp)->m_next;
		mlen = MLEN;
	    }
#endif
	    if (m0 != NULL)
		IF_PREPEND(ifq, m0);
	    m_freem(m);
	    continue;
	}

	/*
	 * The descriptors have been filled in.  Now get ready
	 * to transmit.
	 */
#if NBPFILTER > 0
	if (sc->tulip_bpf != NULL)
	    TULIP_BPF_MTAP(sc, m);
#endif
	IF_ENQUEUE(&sc->tulip_txq, m);

	/*
	 * Make sure the next descriptor after this packet is owned
	 * by us since it may have been set up above if we ran out
	 * of room in the ring.
	 */
	nextout->d_status = 0;

	/*
	 * If we only used the first segment of the last descriptor,
	 * make sure the second segment will not be used.
	 */
	if (segcnt & 1) {
	    eop->d_addr2 = 0;
	    eop->d_length2 = 0;
	}

	/*
	 * Mark the last and first segments, indicate we want a transmit
	 * complete interrupt if there isn't one queued, give the
	 * descriptors to the TULIP, and tell it to transmit!
	 */
	if (sc->tulip_flags & TULIP_TXINTPENDING) {
	    eop->d_flag |= TULIP_DFLAG_TxLASTSEG;
#if defined(TULIP_DEBUG)
	    sc->tulip_dbg.dbg_txpipe++;
#endif
	} else {
	    eop->d_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;
	    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
		sc->tulip_flags |= TULIP_TXINTPENDING;
#if defined(TULIP_DEBUG)
		sc->tulip_dbg.dbg_txpipestats[sc->tulip_dbg.dbg_txpipe]++;
		sc->tulip_dbg.dbg_txpipe = 0;
#endif
	    }
	}

	/*
	 * Note that ri->ri_nextout is still the start of the packet
	 * and until we set the OWNER bit, we can still back out of
	 * everything we have done.
	 */
	ri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;
	ri->ri_nextout->d_status = TULIP_DSTS_OWNER;

	/*
	 * This advances the ring for us.
	 */
	ri->ri_nextout = nextout;
	ri->ri_free = free;

	TULIP_CSR_WRITE(sc, csr_txpoll, 1);

	if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {
	    ifp->if_flags |= IFF_OACTIVE;
	    return;
	}
	if (sc->tulip_txtimer == 0)
	    sc->tulip_txtimer = TULIP_TXTIMER;
d4490 1
a4492 1

d4504 1
d4551 22
d4574 1
a4584 1

d4629 1
a4629 1
	   TULIP_PRINTF_FMT ": %s%s pass %d.%d address " TULIP_EADDR_FMT "\n",
d4635 4
d4695 5
a4701 1

a4728 1

a4742 1

a4828 1

a5012 1

a5066 1

d5159 2
d5186 8
a5193 6
    case 1: sc->tulip_media = chipid > TULIP_DE425 ? TULIP_MEDIA_AUI : TULIP_MEDIA_AUIBNC;
    case 2: sc->tulip_media = chipid > TULIP_DE425 ? TULIP_MEDIA_BNC : TULIP_MEDIA_UNKNOWN;
    case 3: sc->tulip_media = TULIP_MEDIA_10BASET;
    case 4: sc->tulip_media = TULIP_MEDIA_10BASET_FD;
    case 5: sc->tulip_media = TULIP_MEDIA_100BASETX;
    case 6: sc->tulip_media = TULIP_MEDIA_100BASETX_FD;
d5327 2
d5331 1
a5331 1
		printf(": couldn't map interrupt\n");
d5337 6
a5342 6
	    if (sc->tulip_ih == NULL)
		printf(": couldn't establish interrupt");
	    if (intrstr != NULL)
		printf(" at %s", intrstr);
	    printf("\n");
	    if (sc->tulip_ih == NULL)
d5344 2
d5349 1
a5349 1
	    printf("\n%s: warning: couldn't establish shutdown hook\n",
d5385 4
@


1.23
log
@Support BSD/OS 2.1, add OpenBSD tags.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2395 1
d2709 4
d2714 1
d3004 1
a3004 1
		    sp[hash >> 4] |= 1 << (hash & 0xF);
d3018 1
a3018 1
	    sp[hash >> 4] |= 1 << (hash & 0xF);
d3021 1
a3021 1
		sp[hash >> 4] |= 1 << (hash & 0xF);
d3023 3
a3025 3
		sp[39] = ((u_int16_t *) sc->tulip_enaddr)[0]; 
		sp[40] = ((u_int16_t *) sc->tulip_enaddr)[1]; 
		sp[41] = ((u_int16_t *) sc->tulip_enaddr)[2];
d3039 3
a3041 3
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[0]; 
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[1]; 
		    *sp++ = ((u_int16_t *) enm->enm_addrlo)[2];
d3052 3
a3054 3
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
d3060 3
a3062 3
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[0]; 
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[1]; 
	    *sp++ = ((u_int16_t *) sc->tulip_enaddr)[2];
d3107 1
a3107 1
		    |(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));
@


1.22
log
@pretty
@
text
@d1 1
@


1.21
log
@Force driver into store-forward mode on cards that support it. This increases
reliability (less underflows) at the expense of speed.
@
text
@d4448 1
a4448 1
	   TULIP_PRINTF_FMT ": %s%s pass %d.%d\n",
d4453 1
a4453 3
	   sc->tulip_revinfo & 0x0F);
    printf(TULIP_PRINTF_FMT ": address " TULIP_EADDR_FMT "\n",
	   TULIP_PRINTF_ARGS,
d5123 1
a5123 1
	printf(TULIP_PRINTF_FMT ": %s%s pass %d.%d\n",
a5126 1
	printf(TULIP_PRINTF_FMT ": address unknown\n", TULIP_PRINTF_ARGS);
@


1.20
log
@Comment out some superfluous const declarations that cause cast warnings
with gcc/alpha.  We have bcopy(const void *...) so casting a const foo *bar
as in bcopy((caddr_t) bar,...) for bcopy seems to be fairly pointless in
the first place, but there are too many of these to hack out at the moment.
@
text
@d3204 1
d3524 5
d3681 3
d4985 9
@


1.19
log
@csapuntz@@lcs.mit.edu: Port of NetBSD tulip driver.  Works with new (21140-AC-based) SMC Etherpower cards.
@
text
@d2290 2
a2291 2
    const tulip_srom_header_t *shp = (tulip_srom_header_t *) &sc->tulip_rombuf[0];
    const tulip_srom_adapter_info_t *saip = (tulip_srom_adapter_info_t *) (shp + 1);
d2639 1
a2639 1
static const struct {
@


1.18
log
@These two was not ready for commit yet. Backed out.
@
text
@d1 1
a1 2
/*    $OpenBSD: if_de.c,v 1.16 1996/12/19 12:49:53 mickey Exp $       */
/*    $NetBSD: if_de.c,v 1.29 1996/10/25 21:33:30 cgd Exp $       */
d4 1
a4 1
 * Copyright (c) 1994, 1995 Matt Thomas (matt@@lkg.dec.com)
d25 3
d31 1
a31 1
 * DEC DC21040 PCI Ethernet Controller
d37 1
a37 1
 *   board which support DC21040, DC21041, or DC21140 (mostly).
d39 1
a39 5

#if defined(__FreeBSD__)
#include "de.h"
#endif
#if NDE > 0 || !defined(__FreeBSD__)
a51 1
#include <sys/devconf.h>
d58 3
d64 6
d82 5
a86 1
#include <netinet/if_ether.h>
d90 1
a91 1
#include <vm/vm_param.h>
d94 1
d96 1
d99 2
a100 1
#include <pci/dc21040.h>
d105 2
a106 2
#include <i386/pci/pci.h>
#include <i386/pci/ic/dc21040.h>
d111 2
d114 4
a117 1
#if NEISA > 0
d121 1
d124 11
d137 1
d139 1
a139 1

d143 1
d149 1
a149 1
#if defined(__i386__)
d153 1
d155 2
a156 4
 * This module supports
 *	the DEC DC21040 PCI Ethernet Controller.
 *	the DEC DC21041 PCI Ethernet Controller.
 *	the DEC DC21140 PCI Fast Ethernet Controller.
d158 2
d161 3
a163 35
typedef struct {
    tulip_desc_t *ri_first;
    tulip_desc_t *ri_last;
    tulip_desc_t *ri_nextin;
    tulip_desc_t *ri_nextout;
    int ri_max;
    int ri_free;
} tulip_ringinfo_t;

#if defined(__NetBSD__) || defined(__OpenBSD__)
/*
 * These macros are the same for NetBSD regardless of TULIP_IOMAPPED.
 */
typedef bus_size_t tulip_csrptr_t;

#define	TULIP_READ_CSR(sc, csr)	\
    bus_space_read_4((sc)->tulip_bst, (sc)->tulip_bsh, (sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSR(sc, csr, val) \
    bus_space_write_4((sc)->tulip_bst, (sc)->tulip_bsh, (sc)->tulip_csrs.csr, \
    (val))

#define	TULIP_READ_CSRBYTE(sc, csr) \
    bus_space_read_1((sc)->tulip_bst, (sc)->tulip_bsh, (sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSRBYTE(sc, csr, val) \
    bus_space_write_1((sc)->tulip_bst, (sc)->tulip_bsh, (sc)->tulip_csrs.csr, \
    (val))
#endif /* __NetBSD__ */

#ifdef TULIP_IOMAPPED

#define	TULIP_EISA_CSRSIZE	16
#define	TULIP_PCI_CSRSIZE	8

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
typedef tulip_uint16_t tulip_csrptr_t;
d165 1
a165 13
#define	TULIP_READ_CSR(sc, csr)			(inl((sc)->tulip_csrs.csr))
#define	TULIP_WRITE_CSR(sc, csr, val)   	outl((sc)->tulip_csrs.csr, val)

#define	TULIP_READ_CSRBYTE(sc, csr)		(inb((sc)->tulip_csrs.csr))
#define	TULIP_WRITE_CSRBYTE(sc, csr, val)	outb((sc)->tulip_csrs.csr, val)
#endif /* ! __NetBSD__ */

#else /* TULIP_IOMAPPED */

#define	TULIP_PCI_CSRSIZE	8

#if !defined(__NetBSD__) && !defined(__OpenBSD__)
typedef volatile tulip_uint32_t *tulip_csrptr_t;
d167 1
d169 4
a172 73
 * macros to read and write CSRs.  Note that the "0 +" in
 * READ_CSR is to prevent the macro from being an lvalue
 * and WRITE_CSR shouldn't be assigned from.
 */
#define	TULIP_READ_CSR(sc, csr)		(0 + *(sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSR(sc, csr, val) \
	    ((void)(*(sc)->tulip_csrs.csr = (val)))
#endif /* ! __NetBSD__ */

#endif /* TULIP_IOMAPPED */

typedef struct {
    tulip_csrptr_t csr_busmode;			/* CSR0 */
    tulip_csrptr_t csr_txpoll;			/* CSR1 */
    tulip_csrptr_t csr_rxpoll;			/* CSR2 */
    tulip_csrptr_t csr_rxlist;			/* CSR3 */
    tulip_csrptr_t csr_txlist;			/* CSR4 */
    tulip_csrptr_t csr_status;			/* CSR5 */
    tulip_csrptr_t csr_command;			/* CSR6 */
    tulip_csrptr_t csr_intr;			/* CSR7 */
    tulip_csrptr_t csr_missed_frame;		/* CSR8 */

    /* DC21040 specific registers */

    tulip_csrptr_t csr_enetrom;			/* CSR9 */
    tulip_csrptr_t csr_reserved;		/* CSR10 */
    tulip_csrptr_t csr_full_duplex;		/* CSR11 */

    /* DC21040/DC21041 common registers */

    tulip_csrptr_t csr_sia_status;		/* CSR12 */
    tulip_csrptr_t csr_sia_connectivity;	/* CSR13 */
    tulip_csrptr_t csr_sia_tx_rx;		/* CSR14 */
    tulip_csrptr_t csr_sia_general;		/* CSR15 */

    /* DC21140/DC21041 common registers */

    tulip_csrptr_t csr_srom_mii;		/* CSR9 */
    tulip_csrptr_t csr_gp_timer;		/* CSR11 */

    /* DC21140 specific registers */

    tulip_csrptr_t csr_gp;			/* CSR12 */
    tulip_csrptr_t csr_watchdog;		/* CSR15 */

    /* DC21041 specific registers */

    tulip_csrptr_t csr_bootrom;			/* CSR10 */
} tulip_regfile_t;

/*
 * The DC21040 has a stupid restriction in that the receive
 * buffers must be longword aligned.  But since Ethernet
 * headers are not a multiple of longwords in size this forces
 * the data to non-longword aligned.  Since IP requires the
 * data to be longword aligned, we need to copy it after it has
 * been DMA'ed in our memory.
 *
 * Since we have to copy it anyways, we might as well as allocate
 * dedicated receive space for the input.  This allows to use a
 * small receive buffer size and more ring entries to be able to
 * better keep with a flood of tiny Ethernet packets.
 *
 * The receive space MUST ALWAYS be a multiple of the page size.
 * And the number of receive descriptors multiplied by the size
 * of the receive buffers must equal the recevive space.  This
 * is so that we can manipulate the page tables so that even if a
 * packet wraps around the end of the receive space, we can 
 * treat it as virtually contiguous.
 *
 * The above used to be true (the stupid restriction is still true)
 * but we gone to directly DMA'ing into MBUFs because with 100Mb
 * cards the copying is just too much of a hit.
d174 16
a189 2
#if defined(__alpha__)
#define	TULIP_COPY_RXDATA	1
d191 1
a192 42
#define	TULIP_RXDESCS		16
#define	TULIP_TXDESCS		128
#define	TULIP_RXQ_TARGET	16
#define	TULIP_RX_BUFLEN		((MCLBYTES < 2048 ? MCLBYTES : 2048) - 16)

typedef enum {
    TULIP_DC21040_GENERIC,
    TULIP_DC21040_ZX314_MASTER,
    TULIP_DC21040_ZX314_SLAVE,
    TULIP_DC21140_DEC_EB,
    TULIP_DC21140_DEC_DE500,
    TULIP_DC21140_COGENT_EM100,
    TULIP_DC21140_ZNYX_ZX34X,
    TULIP_DC21041_GENERIC,
    TULIP_DC21041_DE450
} tulip_board_t;

typedef struct _tulip_softc_t tulip_softc_t;

typedef struct {
    tulip_board_t bd_type;
    const char *bd_description;
    int (*bd_media_probe)(tulip_softc_t *sc);
    void (*bd_media_select)(tulip_softc_t *sc);
} tulip_boardsw_t;

typedef enum {
    TULIP_DC21040, TULIP_DC21140,
    TULIP_DC21041, TULIP_DE425,
    TULIP_CHIPID_UNKNOWN
} tulip_chipid_t;

typedef enum {
    TULIP_PROBE_INACTIVE, TULIP_PROBE_10BASET, TULIP_PROBE_AUI,
    TULIP_PROBE_BNC
} tulip_probe_state_t;

typedef enum {
    TULIP_MEDIA_UNKNOWN, TULIP_MEDIA_10BASET,
    TULIP_MEDIA_BNC, TULIP_MEDIA_AUI,
    TULIP_MEDIA_BNCAUI, TULIP_MEDIA_100BASET
} tulip_media_t;
d194 3
a196 127
struct _tulip_softc_t {
#if defined(__bsdi__)
    struct device tulip_dev;		/* base device */
    struct isadev tulip_id;		/* ISA device */
    struct intrhand tulip_ih;		/* intrrupt vectoring */
    struct atshutdown tulip_ats;	/* shutdown hook */
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
    struct device tulip_dev;		/* base device */
    void *tulip_ih;			/* intrrupt vectoring */
    void *tulip_ats;			/* shutdown hook */
    pci_chipset_tag_t tulip_pc;		/* PCI chipset cookie */
    bus_space_tag_t tulip_bst;		/* bus space tag */
    bus_space_handle_t tulip_bsh;	/* bus space handle */
#endif
    char tulip_xname[IFNAMSIZ];		/* name + unit number */
    struct arpcom tulip_ac;
    tulip_regfile_t tulip_csrs;
    unsigned tulip_flags;
#define	TULIP_WANTSETUP		0x0001
#define	TULIP_WANTHASH		0x0002
#define	TULIP_DOINGSETUP	0x0004
#define	TULIP_ALTPHYS		0x0008	/* use AUI */
#define	TULIP_TXPROBE_ACTIVE	0x0010
#define	TULIP_TXPROBE_OK	0x0020
#define	TULIP_INRESET		0x0040
#define	TULIP_WANTRXACT		0x0080
#define	TULIP_SLAVEDROM		0x0100
#define	TULIP_ROMOK		0x0200
    unsigned char tulip_rombuf[128];
    tulip_uint32_t tulip_setupbuf[192/sizeof(tulip_uint32_t)];
    tulip_uint32_t tulip_setupdata[192/sizeof(tulip_uint32_t)];
    tulip_uint32_t tulip_intrmask;
    tulip_uint32_t tulip_cmdmode;
    tulip_uint32_t tulip_revinfo;
    tulip_uint32_t tulip_gpticks;
    /* tulip_uint32_t tulip_bus; XXX */
    tulip_media_t tulip_media;
    tulip_probe_state_t tulip_probe_state;
    tulip_chipid_t tulip_chipid;
    const tulip_boardsw_t *tulip_boardsw;
    tulip_softc_t *tulip_slaves;
    struct ifqueue tulip_txq;
    struct ifqueue tulip_rxq;
    tulip_ringinfo_t tulip_rxinfo;
    tulip_ringinfo_t tulip_txinfo;
};

#ifndef IFF_ALTPHYS
#define	IFF_ALTPHYS	IFF_LINK0		/* In case it isn't defined */
#endif
static const char *tulip_chipdescs[] = { 
    "DC21040 [10Mb/s]",
    "DC21140 [10-100Mb/s]",
    "DC21041 [10Mb/s]",
#if defined(TULIP_EISA)
    "DE425 [10Mb/s]"
#endif
};

#if defined(__FreeBSD__)
typedef void ifnet_ret_t;
typedef int ioctl_cmd_t;
tulip_softc_t *tulips[NDE];
#define	TULIP_UNIT_TO_SOFTC(unit)	(tulips[unit])
#define	TULIP_IFP_TO_SOFTC(ifp)		(TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
#define	TULIP_BURSTSIZE(unit)		pci_max_burst_len
#endif
#if defined(__bsdi__)
typedef int ifnet_ret_t;
typedef int ioctl_cmd_t;
extern struct cfdriver decd;
#define	TULIP_UNIT_TO_SOFTC(unit)	((tulip_softc_t *) decd.cd_devs[unit])
#define TULIP_IFP_TO_SOFTC(ifp)		(TULIP_UNIT_TO_SOFTC((ifp)->if_unit))
#define	TULIP_BURSTSIZE(unit)		log2_burst_size
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
typedef void ifnet_ret_t;
typedef u_long ioctl_cmd_t;
extern struct cfattach de_ca;
extern struct cfdriver de_cd;
#define	TULIP_UNIT_TO_SOFTC(unit)	((tulip_softc_t *) de_cd.cd_devs[unit])
#define	TULIP_IFP_TO_SOFTC(ifp)		((tulip_softc_t *)((ifp)->if_softc))
#endif

#ifndef TULIP_BURSTSIZE
#define	TULIP_BURSTSIZE(unit)		3
#endif

#define	tulip_if	tulip_ac.ac_if
#if defined(__NetBSD__) || defined(__OpenBSD__)
#define	tulip_unit	tulip_dev.dv_unit
#define	tulip_name	tulip_dev.dv_cfdata->cf_driver->cd_name
#else
#define	tulip_unit	tulip_ac.ac_if.if_unit
#define	tulip_name	tulip_ac.ac_if.if_name
#endif
#define	tulip_bpf	tulip_ac.ac_if.if_bpf
#define	tulip_hwaddr	tulip_ac.ac_enaddr

#define	TULIP_CRC32_POLY	0xEDB88320UL	/* CRC-32 Poly -- Little Endian */
#define	TULIP_CHECK_RXCRC	0
#define	TULIP_MAX_TXSEG		30

#define	TULIP_ADDREQUAL(a1, a2) \
	(((u_short *)a1)[0] == ((u_short *)a2)[0] \
	 && ((u_short *)a1)[1] == ((u_short *)a2)[1] \
	 && ((u_short *)a1)[2] == ((u_short *)a2)[2])
#define	TULIP_ADDRBRDCST(a1) \
	(((u_short *)a1)[0] == 0xFFFFU \
	 && ((u_short *)a1)[1] == 0xFFFFU \
	 && ((u_short *)a1)[2] == 0xFFFFU)

static ifnet_ret_t tulip_start(struct ifnet *ifp);
static void tulip_rx_intr(tulip_softc_t *sc);
static void tulip_addr_filter(tulip_softc_t *sc);

#if (defined(__NetBSD__) || defined(__OpenBSD__)) && defined(__alpha__)
/* XXX XXX NEED REAL DMA MAPPING SUPPORT XXX XXX */
#undef vtophys
#define	vtophys(va)	alpha_XXX_dmamap((vm_offset_t)(va))
#endif


static int
tulip_dc21040_media_probe(
    tulip_softc_t * const sc)
d198 2
a199 1
    int cnt;
d201 4
a204 8
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, 0);
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_10BASET);
    for (cnt = 0; cnt < 2400; cnt++) {
	if ((TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) == 0)
	    break;
	DELAY(1000);
    }
    return (TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) != 0;
d208 1
a208 1
tulip_dc21040_media_select(
d211 4
a214 15
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
    if (sc->tulip_if.if_flags & IFF_ALTPHYS) {
	if ((sc->tulip_flags & TULIP_ALTPHYS) == 0)
	    printf("%s: enabling Thinwire/AUI port\n", sc->tulip_xname);
	TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_AUI);
	sc->tulip_flags |= TULIP_ALTPHYS;
    } else {
	if (sc->tulip_flags & TULIP_ALTPHYS)
	    printf("%s: enabling 10baseT/UTP port\n", sc->tulip_xname);
	TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_10BASET);
	sc->tulip_flags &= ~TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_10BASET;
    }
d217 4
a220 10
static const tulip_boardsw_t tulip_dc21040_boardsw = {
    TULIP_DC21040_GENERIC,
    "",
    tulip_dc21040_media_probe,
    tulip_dc21040_media_select
};

static int
tulip_zx314_media_probe(
    tulip_softc_t * const sc)
d222 6
a227 3
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, 0);
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_10BASET);
    return 0;
d231 1
a231 1
tulip_zx314_media_select(
d234 4
a237 8
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
    if (sc->tulip_flags & TULIP_ALTPHYS)
	printf("%s: enabling 10baseT/UTP port\n", sc->tulip_xname);
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_10BASET);
    sc->tulip_flags &= ~TULIP_ALTPHYS;
    sc->tulip_media = TULIP_MEDIA_10BASET;
d239 1
a241 14
static const tulip_boardsw_t tulip_dc21040_zx314_master_boardsw = {
    TULIP_DC21040_ZX314_MASTER,
    "ZNYX ZX314 ",
    tulip_zx314_media_probe,
    tulip_zx314_media_select
};

static const tulip_boardsw_t tulip_dc21040_zx314_slave_boardsw = {
    TULIP_DC21040_ZX314_SLAVE,
    "ZNYX ZX314 ",
    tulip_zx314_media_probe,
    tulip_zx314_media_select
};

d243 1
a243 1
tulip_dc21140_evalboard_media_probe(
d246 31
a276 9
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EB_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EB_INIT);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    DELAY(1000000);
    return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_EB_OK100) != 0;
d279 7
d287 3
a289 2
tulip_dc21140_evalboard_media_select(
    tulip_softc_t * const sc)
d291 85
a375 24
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EB_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EB_INIT);
    if (sc->tulip_if.if_flags & IFF_ALTPHYS) {
	if ((sc->tulip_flags & TULIP_ALTPHYS) == 0)
	    printf("%s: enabling 100baseTX UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT
	    |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER;
	sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags |= TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_100BASET;
    } else {
	if (sc->tulip_flags & TULIP_ALTPHYS)
	    printf("%s: enabling 10baseT UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode &= ~(TULIP_CMD_PORTSELECT
			       |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER);
	sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags &= ~TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_10BASET;
    }
#ifdef BIG_PACKET
    if (sc->tulip_if.if_mtu > ETHERMTU) {
	TULIP_WRITE_CSR(sc, csr_watchdog, TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE);
a376 1
#endif
a378 20
static const tulip_boardsw_t tulip_dc21140_eb_boardsw = {
    TULIP_DC21140_DEC_EB,
    "",
    tulip_dc21140_evalboard_media_probe,
    tulip_dc21140_evalboard_media_select
};

static int
tulip_dc21140_cogent_em100_media_probe(
    tulip_softc_t * const sc)
{
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EM100_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EM100_INIT);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    return 1;
}
d381 3
a383 2
tulip_dc21140_cogent_em100_media_select(
    tulip_softc_t * const sc)
d385 15
a399 14
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EM100_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_EM100_INIT);
    if ((sc->tulip_flags & TULIP_ALTPHYS) == 0)
	printf("%s: enabling 100baseTX UTP port\n", sc->tulip_xname);
    sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT
	|TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER;
    sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;
    sc->tulip_flags |= TULIP_ALTPHYS;
    sc->tulip_media = TULIP_MEDIA_100BASET;
#ifdef BIG_PACKET
    if (sc->tulip_if.if_mtu > ETHERMTU) {
	TULIP_WRITE_CSR(sc, csr_watchdog, TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE);
d402 27
a430 23
static const tulip_boardsw_t tulip_dc21140_cogent_em100_boardsw = {
    TULIP_DC21140_COGENT_EM100,
    "Cogent EM100 ",
    tulip_dc21140_cogent_em100_media_probe,
    tulip_dc21140_cogent_em100_media_select
};


static int
tulip_dc21140_znyx_zx34x_media_probe(
    tulip_softc_t * const sc)
{
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_ZX34X_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_ZX34X_INIT);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    DELAY(1000000);

    return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_ZX34X_OK10);
}
d433 1
a433 1
tulip_dc21140_znyx_zx34x_media_select(
d436 10
a445 24
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_ZX34X_PINS);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_ZX34X_INIT);
    if (sc->tulip_if.if_flags & IFF_ALTPHYS) {
	if ((sc->tulip_flags & TULIP_ALTPHYS) == 0)
	    printf("%s: enabling 100baseTX UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT
	    |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER;
	sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags |= TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_100BASET;
    } else {
	if (sc->tulip_flags & TULIP_ALTPHYS)
	    printf("%s: enabling 10baseT UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode &= ~(TULIP_CMD_PORTSELECT
			       |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER);
	sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags &= ~TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_10BASET;
    }
#ifdef BIG_PACKET
    if (sc->tulip_if.if_mtu > ETHERMTU) {
	TULIP_WRITE_CSR(sc, csr_watchdog, TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE);
a446 1
#endif
d449 4
a452 9
static const tulip_boardsw_t tulip_dc21140_znyx_zx34x_boardsw = {
    TULIP_DC21140_ZNYX_ZX34X,
    "ZNYX ZX34X ",
    tulip_dc21140_znyx_zx34x_media_probe,
    tulip_dc21140_znyx_zx34x_media_select
};

static int
tulip_dc21140_de500_media_probe(
d455 35
a489 17
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_DE500_PINS);
    DELAY(1000);
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_DE500_HALFDUPLEX);
    if ((TULIP_READ_CSR(sc, csr_gp) &
	(TULIP_GP_DE500_NOTOK_100|TULIP_GP_DE500_NOTOK_10)) !=
	(TULIP_GP_DE500_NOTOK_100|TULIP_GP_DE500_NOTOK_10))
	return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_DE500_NOTOK_100) == 0;
    TULIP_WRITE_CSR(sc, csr_gp,
	TULIP_GP_DE500_HALFDUPLEX|TULIP_GP_DE500_FORCE_100);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) | TULIP_CMD_PORTSELECT |
	TULIP_CMD_PCSFUNCTION | TULIP_CMD_SCRAMBLER | TULIP_CMD_MUSTBEONE);
    TULIP_WRITE_CSR(sc, csr_command,
	TULIP_READ_CSR(sc, csr_command) & ~TULIP_CMD_TXTHRSHLDCTL);
    DELAY(1000000);
    return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_DE500_NOTOK_100) == 0;
}
d491 17
a507 30
static void
tulip_dc21140_de500_media_select(
    tulip_softc_t * const sc)
{
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE
	|TULIP_CMD_BACKOFFCTR;
    TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_DE500_PINS);
    if (sc->tulip_if.if_flags & IFF_ALTPHYS) {
	if ((sc->tulip_flags & TULIP_ALTPHYS) == 0)
	    printf("%s: enabling 100baseTX UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode |= TULIP_CMD_PORTSELECT
	    |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER;
	sc->tulip_cmdmode &= ~TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags |= TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_100BASET;
	TULIP_WRITE_CSR(sc, csr_gp,
	    TULIP_GP_DE500_HALFDUPLEX|TULIP_GP_DE500_FORCE_100);
    } else {
	if (sc->tulip_flags & TULIP_ALTPHYS)
	    printf("%s: enabling 10baseT UTP port\n", sc->tulip_xname);
	sc->tulip_cmdmode &= ~(TULIP_CMD_PORTSELECT
			       |TULIP_CMD_PCSFUNCTION|TULIP_CMD_SCRAMBLER);
	sc->tulip_cmdmode |= TULIP_CMD_TXTHRSHLDCTL;
	sc->tulip_flags &= ~TULIP_ALTPHYS;
	sc->tulip_media = TULIP_MEDIA_10BASET;
	TULIP_WRITE_CSR(sc, csr_gp, TULIP_GP_DE500_HALFDUPLEX);
    }
#ifdef BIG_PACKET
    if (sc->tulip_if.if_mtu > ETHERMTU) {
	TULIP_WRITE_CSR(sc, csr_watchdog, TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE);
d509 1
a509 1
#endif
d511 2
d514 2
a515 8
static const tulip_boardsw_t tulip_dc21140_de500_boardsw = {
    TULIP_DC21140_DEC_DE500, "Digital DE500 ",
    tulip_dc21140_de500_media_probe,
    tulip_dc21140_de500_media_select
};

static int
tulip_dc21041_media_probe(
d518 2
a519 2
    return 0;
}
d521 4
a524 4
#ifdef BIG_PACKET
#define TULIP_DC21041_SIAGEN_WATCHDOG	(sc->tulip_if.if_mtu > ETHERMTU ? TULIP_WATCHDOG_RXDISABLE|TULIP_WATCHDOG_TXDISABLE : 0)
#else
#define	TULIP_DC21041_SIAGEN_WATCHDOG	0
d526 1
a526 23

static void
tulip_dc21041_media_select(
    tulip_softc_t * const sc)
{
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT
	/* |TULIP_CMD_FULLDUPLEX */ |TULIP_CMD_THRSHLD160|TULIP_CMD_BACKOFFCTR;
    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_GPTIMEOUT
	|TULIP_STS_ABNRMLINTR|TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
    if (sc->tulip_if.if_flags & IFF_ALTPHYS) {
	if ((sc->tulip_flags & TULIP_ALTPHYS) == 0) {
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	    sc->tulip_flags &= ~(TULIP_TXPROBE_OK|TULIP_TXPROBE_ACTIVE);
	    sc->tulip_flags |= TULIP_ALTPHYS|TULIP_WANTRXACT;
	    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
	}
    } else {
	if (sc->tulip_flags & TULIP_ALTPHYS) {
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	    sc->tulip_flags &= ~(TULIP_TXPROBE_OK|TULIP_TXPROBE_ACTIVE|TULIP_ALTPHYS);
	    sc->tulip_flags |= TULIP_WANTRXACT;
	    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
	}
d529 143
a671 9
    if (TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_LINKFAIL) {
	if (sc->tulip_media == TULIP_MEDIA_10BASET) {
	    sc->tulip_media = TULIP_MEDIA_UNKNOWN;
	} else if (sc->tulip_media == TULIP_MEDIA_BNC) {
	    sc->tulip_intrmask &= ~TULIP_STS_GPTIMEOUT;
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_BNC);
	    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_BNC);
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC|TULIP_DC21041_SIAGEN_WATCHDOG);
d673 18
a690 6
	} else if (sc->tulip_media == TULIP_MEDIA_AUI) {
	    sc->tulip_intrmask &= ~TULIP_STS_GPTIMEOUT;
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_AUI);
	    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_AUI);
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI|TULIP_DC21041_SIAGEN_WATCHDOG);
d694 52
a745 29
	switch (sc->tulip_probe_state) {
	    case TULIP_PROBE_INACTIVE: {
		TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
		sc->tulip_if.if_flags |= IFF_OACTIVE;
		sc->tulip_gpticks = 200;
		sc->tulip_probe_state = TULIP_PROBE_10BASET;
		TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
		TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_10BASET);
		TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_10BASET);
		TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_10BASET|TULIP_DC21041_SIAGEN_WATCHDOG);
		TULIP_WRITE_CSR(sc, csr_gp_timer, 12000000 / 204800); /* 120 ms */
		break;
	    }
	    case TULIP_PROBE_10BASET: {
		if (--sc->tulip_gpticks > 0) {
		    if ((TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_OTHERRXACTIVITY) == 0) {
			TULIP_WRITE_CSR(sc, csr_gp_timer, 12000000 / 204800); /* 120 ms */
			TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);
			break;
		    }
		}
		sc->tulip_gpticks = 4;
		if (TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_OTHERRXACTIVITY) {
		    sc->tulip_probe_state = TULIP_PROBE_BNC;
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_BNC);
		    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_BNC);
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC|TULIP_DC21041_SIAGEN_WATCHDOG);
		    TULIP_WRITE_CSR(sc, csr_gp_timer, 100000000 / 204800); /* 100 ms */
d747 1
a747 6
		    sc->tulip_probe_state = TULIP_PROBE_AUI;
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_AUI);
		    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_AUI);
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI|TULIP_DC21041_SIAGEN_WATCHDOG);
		    TULIP_WRITE_CSR(sc, csr_gp_timer, 100000000 / 204800); /* 100 ms */
a748 1
		break;
d750 23
a772 60
	    case TULIP_PROBE_BNC:
	    case TULIP_PROBE_AUI: {
		if (sc->tulip_flags & TULIP_TXPROBE_OK) {
		    sc->tulip_intrmask &= ~TULIP_STS_GPTIMEOUT;
		    sc->tulip_flags &= ~(TULIP_TXPROBE_OK|TULIP_TXPROBE_ACTIVE);
		    TULIP_WRITE_CSR(sc, csr_gp_timer, 0); /* disable */
		    if ((sc->tulip_probe_state == TULIP_PROBE_AUI
			 && sc->tulip_media != TULIP_MEDIA_AUI)
			|| (sc->tulip_probe_state == TULIP_PROBE_BNC
			    && sc->tulip_media != TULIP_MEDIA_AUI)) {
			printf("%s: enabling %s port\n", sc->tulip_xname,
			       sc->tulip_probe_state == TULIP_PROBE_BNC
			           ? "Thinwire/BNC" : "AUI");
			if (sc->tulip_probe_state == TULIP_PROBE_AUI)
			    sc->tulip_media = TULIP_MEDIA_AUI;
			else if (sc->tulip_probe_state == TULIP_PROBE_BNC)
			    sc->tulip_media = TULIP_MEDIA_BNC;
		    }
		    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;
		    break;
		}
		if ((sc->tulip_flags & TULIP_WANTRXACT) == 0
		    || (TULIP_READ_CSR(sc, csr_sia_status) & TULIP_SIASTS_RXACTIVITY)) {
		    if ((sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0) {
			struct mbuf *m;
			/*
			 * Before we are sure this is the right media we need
			 * to send a small packet to make sure there's carrier.
			 * Strangely, BNC and AUI will 'see" receive data if
			 * either is connected so the transmit is the only way
			 * to verify the connectivity.
			 */
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
			    TULIP_WRITE_CSR(sc, csr_gp_timer, 100000000 / 204800); /* 100 ms */
			    break;
			}
			/*
			 * Construct a LLC TEST message which will point to ourselves.
			 */
			bcopy(sc->tulip_hwaddr, mtod(m, struct ether_header *)->ether_dhost, 6);
			bcopy(sc->tulip_hwaddr, mtod(m, struct ether_header *)->ether_shost, 6);
			mtod(m, struct ether_header *)->ether_type = htons(3);
			mtod(m, unsigned char *)[14] = 0;
			mtod(m, unsigned char *)[15] = 0;
			mtod(m, unsigned char *)[16] = 0xE3;	/* LLC Class1 TEST (no poll) */
			m->m_len = m->m_pkthdr.len = sizeof(struct ether_header) + 3;
			/*
			 * send it!
			 */
			sc->tulip_flags |= TULIP_TXPROBE_ACTIVE;
			sc->tulip_flags &= ~TULIP_TXPROBE_OK;
			sc->tulip_cmdmode |= TULIP_CMD_TXRUN;
			TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
			IF_PREPEND(&sc->tulip_if.if_snd, m);
			tulip_start(&sc->tulip_if);
			break;
		    }
		    sc->tulip_flags &= ~TULIP_TXPROBE_ACTIVE;
		}
d774 1
a774 3
		 * Take 2 passes through before deciding to not
		 * wait for receive activity.  Then take another
		 * two passes before spitting out a warning.
d776 15
a790 9
		if (sc->tulip_gpticks > 0 && --sc->tulip_gpticks == 0) {
		    if (sc->tulip_flags & TULIP_WANTRXACT) {
			sc->tulip_flags &= ~TULIP_WANTRXACT;
			sc->tulip_gpticks = 4;
		    } else {
			printf("%s: autosense failed: cable problem?\n",
			       sc->tulip_xname);
		    }
		}
d792 1
a792 1
		 * Since this media failed to probe, try the other one.
d794 4
a797 14
		if (sc->tulip_probe_state == TULIP_PROBE_AUI) {
		    sc->tulip_probe_state = TULIP_PROBE_BNC;
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_BNC);
		    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_BNC);
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC|TULIP_DC21041_SIAGEN_WATCHDOG);
		    TULIP_WRITE_CSR(sc, csr_gp_timer, 100000000 / 204800); /* 100 ms */
		} else {
		    sc->tulip_probe_state = TULIP_PROBE_AUI;
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
		    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_AUI);
		    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_AUI);
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI|TULIP_DC21041_SIAGEN_WATCHDOG);
		    TULIP_WRITE_CSR(sc, csr_gp_timer, 100000000 / 204800); /* 100 ms */
d799 8
a806 1
		TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);
d810 21
a830 1
    } else {
d832 2
a833 2
	 * If the link has passed LinkPass, 10baseT is the
	 * proper media to use.
d835 63
a897 15
	if (sc->tulip_media != TULIP_MEDIA_10BASET)
	    printf("%s: enabling 10baseT/UTP port\n", sc->tulip_xname);
	if (sc->tulip_media != TULIP_MEDIA_10BASET
		|| (sc->tulip_flags & TULIP_INRESET)) {
	    sc->tulip_media = TULIP_MEDIA_10BASET;
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
	    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_10BASET);
	    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_10BASET);
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_10BASET|TULIP_DC21041_SIAGEN_WATCHDOG);
	}
	TULIP_WRITE_CSR(sc, csr_gp_timer, 0); /* disable */
	sc->tulip_gpticks = 1;
	sc->tulip_probe_state = TULIP_PROBE_10BASET;
	sc->tulip_intrmask &= ~TULIP_STS_GPTIMEOUT;
	sc->tulip_if.if_flags &= ~IFF_OACTIVE;
d899 4
a902 1
    TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);
a904 6
static const tulip_boardsw_t tulip_dc21041_boardsw = {
    TULIP_DC21041_GENERIC,
    "",
    tulip_dc21041_media_probe,
    tulip_dc21041_media_select
};
a905 7
static const tulip_boardsw_t tulip_dc21041_de450_boardsw = {
    TULIP_DC21041_DE450,
    "Digital DE450 ",
    tulip_dc21041_media_probe,
    tulip_dc21041_media_select
};

d907 1
a907 1
tulip_reset(
d910 5
a914 20
    tulip_ringinfo_t *ri;
    tulip_desc_t *di;

    TULIP_WRITE_CSR(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
		   33MHz that comes to two microseconds but wait a
		   bit longer anyways) */

    sc->tulip_flags |= TULIP_INRESET;
    sc->tulip_intrmask = 0;
    TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);

    TULIP_WRITE_CSR(sc, csr_txlist, vtophys(&sc->tulip_txinfo.ri_first[0]));
    TULIP_WRITE_CSR(sc, csr_rxlist, vtophys(&sc->tulip_rxinfo.ri_first[0]));
    TULIP_WRITE_CSR(sc, csr_busmode,
	(1 << (TULIP_BURSTSIZE(sc->tulip_unit) + 8))
	|TULIP_BUSMODE_CACHE_ALIGN8
	|(BYTE_ORDER != LITTLE_ENDIAN ? TULIP_BUSMODE_BIGENDIAN : 0));

    sc->tulip_txq.ifq_maxlen = TULIP_TXDESCS;
d916 1
a916 1
     * Free all the mbufs that were on the transmit ring.
d918 8
a925 6
    for (;;) {
	struct mbuf *m;
	IF_DEQUEUE(&sc->tulip_txq, m);
	if (m == NULL)
	    break;
	m_freem(m);
d927 1
a928 5
    ri = &sc->tulip_txinfo;
    ri->ri_nextin = ri->ri_nextout = ri->ri_first;
    ri->ri_free = ri->ri_max;
    for (di = ri->ri_first; di < ri->ri_last; di++)
	di->d_status = 0;
d930 12
a941 13
    /*
     * We need to collect all the mbufs were on the 
     * receive ring before we reinit it either to put
     * them back on or to know if we have to allocate
     * more.
     */
    ri = &sc->tulip_rxinfo;
    ri->ri_nextin = ri->ri_nextout = ri->ri_first;
    ri->ri_free = ri->ri_max;
    for (di = ri->ri_first; di < ri->ri_last; di++) {
	di->d_status = 0;
	di->d_length1 = 0; di->d_addr1 = 0;
	di->d_length2 = 0; di->d_addr2 = 0;
d943 3
a945 6
    for (;;) {
	struct mbuf *m;
	IF_DEQUEUE(&sc->tulip_rxq, m);
	if (m == NULL)
	    break;
	m_freem(m);
d948 4
a951 1
    (*sc->tulip_boardsw->bd_media_select)(sc);
d953 6
a958 5
    sc->tulip_intrmask |= TULIP_STS_NORMALINTR|TULIP_STS_RXINTR|TULIP_STS_TXINTR
	|TULIP_STS_ABNRMLINTR|TULIP_STS_SYSERROR|TULIP_STS_TXSTOPPED
	    |TULIP_STS_TXBABBLE|TULIP_STS_LINKFAIL|TULIP_STS_RXSTOPPED;
    sc->tulip_flags &= ~(TULIP_DOINGSETUP|TULIP_WANTSETUP|TULIP_INRESET);
    tulip_addr_filter(sc);
d960 1
a960 1

d962 1
a962 1
tulip_init(
d965 3
a967 27
    if (sc->tulip_if.if_flags & IFF_UP) {
	sc->tulip_if.if_flags |= IFF_RUNNING;
	if (sc->tulip_if.if_flags & IFF_PROMISC) {
	    sc->tulip_cmdmode |= TULIP_CMD_PROMISCUOUS;
	} else {
	    sc->tulip_cmdmode &= ~TULIP_CMD_PROMISCUOUS;
	    if (sc->tulip_if.if_flags & IFF_ALLMULTI) {
		sc->tulip_cmdmode |= TULIP_CMD_ALLMULTI;
	    } else {
		sc->tulip_cmdmode &= ~TULIP_CMD_ALLMULTI;
	    }
	}
	sc->tulip_cmdmode |= TULIP_CMD_TXRUN;
	if ((sc->tulip_flags & TULIP_WANTSETUP) == 0) {
	    tulip_rx_intr(sc);
	    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;
	    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;
	} else {
	    sc->tulip_intrmask &= ~TULIP_STS_RXSTOPPED;
	    tulip_start(&sc->tulip_if);
	}
	TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);
	TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
    } else {
	tulip_reset(sc);
	sc->tulip_if.if_flags &= ~IFF_RUNNING;
    }
d969 1
a969 1

d971 1
a971 1
tulip_rx_intr(
d974 83
a1056 2
    tulip_ringinfo_t * const ri = &sc->tulip_rxinfo;
    struct ifnet * const ifp = &sc->tulip_if;
d1058 6
a1063 6
    for (;;) {
	struct ether_header eh;
	tulip_desc_t *eop = ri->ri_nextin;
	int total_len = 0, last_offset = 0;
	struct mbuf *ms = NULL, *me = NULL;
	int accept = 0;
d1065 3
a1067 2
	if (sc->tulip_rxq.ifq_len < TULIP_RXQ_TARGET)
	    goto queue_mbuf;
d1069 3
a1071 1
	if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
d1073 37
d1111 7
d1119 26
a1144 10
	 * It is possible (though improbable unless the BIG_PACKET support
	 * is enabled) for a received packet to cross more than one receive
	 * descriptor.  
	 */
	while ((((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_RxLASTDESC) == 0) {
	    if (++eop == ri->ri_last)
		eop = ri->ri_first;
	    if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
		return;
	    total_len++;
d1146 4
d1151 8
d1160 1
a1160 7
	 * Dequeue the first buffer for the start of the packet.  Hopefully this
	 * will be the only one we need to dequeue.  However, if the packet consumed
	 * multiple descriptors, then we need to dequeue those buffers and chain to
	 * the starting mbuf.  All buffers but the last buffer have the same length
	 * so we can set that now.  (we add to last_offset instead of multiplying 
	 * since we normally won't go into the loop and thereby saving a ourselves
	 * from doing a multiplication by 0 in the normal case).
d1162 3
a1164 6
	IF_DEQUEUE(&sc->tulip_rxq, ms);
	for (me = ms; total_len > 0; total_len--) {
	    me->m_len = TULIP_RX_BUFLEN;
	    last_offset += TULIP_RX_BUFLEN;
	    IF_DEQUEUE(&sc->tulip_rxq, me->m_next);
	    me = me->m_next;
a1165 1

d1167 1
a1167 1
	 *  Now get the size of received packet.
d1169 7
a1175 26
	total_len = ((eop->d_status >> 16) & 0x7FFF) - 4;
	if ((eop->d_status & TULIP_DSTS_ERRSUM) == 0
#ifdef BIG_PACKET
	     || (total_len <= sc->tulip_if.if_mtu + sizeof(struct ether_header) && 
		 (eop->d_status & (TULIP_DSTS_RxBADLENGTH|TULIP_DSTS_RxRUNT|
				  TULIP_DSTS_RxCOLLSEEN|TULIP_DSTS_RxBADCRC|
				  TULIP_DSTS_RxOVERFLOW)))
#endif
		) {
	    me->m_len = total_len - last_offset;
	    eh = *mtod(ms, struct ether_header *);
#if NBPFILTER > 0
	    if (sc->tulip_bpf != NULL)
		if (me == ms)
		    bpf_tap(sc->tulip_bpf, mtod(ms, caddr_t), total_len);
		else
		    bpf_mtap(sc->tulip_bpf, ms);
#endif
	    if ((sc->tulip_if.if_flags & IFF_PROMISC)
		    && (eh.ether_dhost[0] & 1) == 0
		    && !TULIP_ADDREQUAL(eh.ether_dhost, sc->tulip_ac.ac_enaddr))
		    goto next;
	    accept = 1;
	    total_len -= sizeof(struct ether_header);
	} else {
	    ifp->if_ierrors++;
a1176 6
      next:
	ifp->if_ipackets++;
	if (++eop == ri->ri_last)
	    eop = ri->ri_first;
	ri->ri_nextin = eop;
      queue_mbuf:
d1178 3
a1180 8
	 * Either we are priming the TULIP with mbufs (m == NULL)
	 * or we are about to accept an mbuf for the upper layers
	 * so we need to allocate an mbuf to replace it.  If we
	 * can't replace, then count it as an input error and reuse
	 * the mbuf.  *** Note that if this packet crossed multiple
	 * descriptors we don't even try to reallocate all the mbufs
	 * here.  Instead we rely on the test of the beginning of
	 * the loop to refill for the extra consumed mbufs.
d1182 11
a1192 43
	if (accept || ms == NULL) {
	    struct mbuf *m0;
	    MGETHDR(m0, M_DONTWAIT, MT_DATA);
	    if (m0 != NULL) {
#if defined(TULIP_COPY_RXDATA)
		if (!accept || total_len >= MHLEN) {
#endif
		    MCLGET(m0, M_DONTWAIT);
		    if ((m0->m_flags & M_EXT) == 0) {
			m_freem(m0);
			m0 = NULL;
		    }
#if defined(TULIP_COPY_RXDATA)
		}
#endif
	    }
	    if (accept) {
		if (m0 != NULL) {
#if defined(__bsdi__)
		    eh.ether_type = ntohs(eh.ether_type);
#endif
#if !defined(TULIP_COPY_RXDATA)
		    ms->m_data += sizeof(struct ether_header);
		    ms->m_len -= sizeof(struct ether_header);
		    ms->m_pkthdr.len = total_len;
		    ms->m_pkthdr.rcvif = ifp;
		    ether_input(ifp, &eh, ms);
		    ms = m0;
#else
#ifdef BIG_PACKET
#error BIG_PACKET is incompatible with TULIP_COPY_RXDATA
#endif
		    if (ms == me)
/*XXX?*/		bcopy(mtod(ms, caddr_t) + sizeof(struct ether_header),
			      mtod(m0, caddr_t), total_len);
		    else
/*XXX?*/		m_copydata(ms, 0, total_len, mtod(m0, caddr_t));
		    m0->m_len = m0->m_pkthdr.len = total_len;
		    m0->m_pkthdr.rcvif = ifp;
		    ether_input(ifp, &eh, m0);
#endif
		} else {
		    ifp->if_ierrors++;
a1193 2
	    } else {
		ms = m0;
a1195 16
	if (ms == NULL)
	    return;
	/*
	 * Now give the buffer(s) to the TULIP and save in our
	 * receive queue.
	 */
	do {
	    ri->ri_nextout->d_length1 = TULIP_RX_BUFLEN;
	    ri->ri_nextout->d_addr1 = vtophys(mtod(ms, caddr_t));
	    ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
	    if (++ri->ri_nextout == ri->ri_last)
		ri->ri_nextout = ri->ri_first;
	    me = ms->m_next;
	    ms->m_next = NULL;
	    IF_ENQUEUE(&sc->tulip_rxq, ms);
	} while ((ms = me) != NULL);
d1197 13
d1211 60
a1270 3

static int
tulip_tx_intr(
d1273 14
a1286 3
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
    struct mbuf *m;
    int xmits = 0;
d1288 13
a1300 2
    while (ri->ri_free < ri->ri_max) {
	if (((volatile tulip_desc_t *) ri->ri_nextin)->d_status & TULIP_DSTS_OWNER)
d1302 53
d1356 46
a1401 17
	if (ri->ri_nextin->d_flag & TULIP_DFLAG_TxLASTSEG) {
	    if (ri->ri_nextin->d_flag & TULIP_DFLAG_TxSETUPPKT) {
		/*
		 * We've just finished processing a setup packet.
		 * Mark that we can finished it.  If there's not
		 * another pending, startup the TULIP receiver.
		 * Make sure we ack the RXSTOPPED so we won't get
		 * an abormal interrupt indication.
		 */
		sc->tulip_flags &= ~TULIP_DOINGSETUP;
		if ((sc->tulip_flags & TULIP_WANTSETUP) == 0) {
		    tulip_rx_intr(sc);
		    sc->tulip_cmdmode |= TULIP_CMD_RXRUN;
		    sc->tulip_intrmask |= TULIP_STS_RXSTOPPED;
		    TULIP_WRITE_CSR(sc, csr_status, TULIP_STS_RXSTOPPED);
		    TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
		    TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);
d1403 41
a1443 14
	   } else {
		IF_DEQUEUE(&sc->tulip_txq, m);
		m_freem(m);
		xmits++;
		if (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) {
		    if ((ri->ri_nextin->d_status & (TULIP_DSTS_TxNOCARR|TULIP_DSTS_TxEXCCOLL)) == 0)
			sc->tulip_flags |= TULIP_TXPROBE_OK;
		    (*sc->tulip_boardsw->bd_media_select)(sc);
		} else {
		    sc->tulip_if.if_collisions +=
			(ri->ri_nextin->d_status & TULIP_DSTS_TxCOLLMASK)
			    >> TULIP_DSTS_V_TxCOLLCNT;
		    if (ri->ri_nextin->d_status & TULIP_DSTS_ERRSUM)
			sc->tulip_if.if_oerrors++;
d1445 8
d1454 15
a1469 5

	if (++ri->ri_nextin == ri->ri_last)
	    ri->ri_nextin = ri->ri_first;
	ri->ri_free++;
	sc->tulip_if.if_flags &= ~IFF_OACTIVE;
d1471 5
a1475 2
    sc->tulip_if.if_opackets += xmits;
    return xmits;
a1476 9

static ifnet_ret_t
tulip_start(
    struct ifnet * const ifp)
{
    tulip_softc_t * const sc = TULIP_IFP_TO_SOFTC(ifp);
    struct ifqueue * const ifq = &ifp->if_snd;
    tulip_ringinfo_t * const ri = &sc->tulip_txinfo;
    struct mbuf *m, *m0, *next_m0;
a1477 3
    if ((ifp->if_flags & IFF_RUNNING) == 0
	    && (sc->tulip_flags & TULIP_TXPROBE_ACTIVE) == 0)
	return;
d1479 6
a1484 4
    for (;;) {
	tulip_desc_t *eop, *nextout;
	int segcnt, free, recopy;
	tulip_uint32_t d_status;
d1486 20
a1505 4
	if (sc->tulip_flags & TULIP_WANTSETUP) {
	    if ((sc->tulip_flags & TULIP_DOINGSETUP) || ri->ri_free == 1) {
		ifp->if_flags |= IFF_OACTIVE;
		return;
d1507 39
a1545 27
	    bcopy(sc->tulip_setupdata, sc->tulip_setupbuf,
		   sizeof(sc->tulip_setupbuf));
	    sc->tulip_flags &= ~TULIP_WANTSETUP;
	    sc->tulip_flags |= TULIP_DOINGSETUP;
	    ri->ri_free--;
	    ri->ri_nextout->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
	    ri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG|TULIP_DFLAG_TxLASTSEG
		    |TULIP_DFLAG_TxSETUPPKT|TULIP_DFLAG_TxWANTINTR;
	    if (sc->tulip_flags & TULIP_WANTHASH)
		ri->ri_nextout->d_flag |= TULIP_DFLAG_TxHASHFILT;
	    ri->ri_nextout->d_length1 = sizeof(sc->tulip_setupbuf);
	    ri->ri_nextout->d_addr1 = vtophys(sc->tulip_setupbuf);
	    ri->ri_nextout->d_length2 = 0;
	    ri->ri_nextout->d_addr2 = 0;
	    ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
	    TULIP_WRITE_CSR(sc, csr_txpoll, 1);
	    /*
	     * Advance the ring for the next transmit packet.
	     */
	    if (++ri->ri_nextout == ri->ri_last)
		ri->ri_nextout = ri->ri_first;
	    /*
	     * Make sure the next descriptor is owned by us since it
	     * may have been set up above if we ran out of room in the
	     * ring.
	     */
	    ri->ri_nextout->d_status = 0;
d1547 3
a1550 3
	IF_DEQUEUE(ifq, m);
	if (m == NULL)
	    break;
d1552 4
a1555 27
	/*
	 * Now we try to fill in our transmit descriptors.  This is
	 * a bit reminiscent of going on the Ark two by two
	 * since each descriptor for the TULIP can describe
	 * two buffers.  So we advance through packet filling
	 * each of the two entries at a time to to fill each
	 * descriptor.  Clear the first and last segment bits
	 * in each descriptor (actually just clear everything
	 * but the end-of-ring or chain bits) to make sure
	 * we don't get messed up by previously sent packets.
	 *
	 * We may fail to put the entire packet on the ring if
	 * there is either not enough ring entries free or if the
	 * packet has more than MAX_TXSEG segments.  In the former
	 * case we will just wait for the ring to empty.  In the
	 * latter case we have to recopy.
	 */
	d_status = 0;
	recopy = 0;
	eop = nextout = ri->ri_nextout;
	m0 = m;
	segcnt = 0;
	free = ri->ri_free;
	do {
	    int len = m0->m_len;
	    caddr_t addr = mtod(m0, caddr_t);
	    unsigned clsize = CLBYTES - (((u_long) addr) & (CLBYTES-1));
a1556 3
	    next_m0 = m0->m_next;
	    while (len > 0) {
		unsigned slen = min(len, clsize);
d1558 13
a1570 36
		segcnt++;
		if (segcnt > TULIP_MAX_TXSEG) {
		    recopy = 1;
		    next_m0 = NULL; /* to break out of outside loop */
		    break;
		}
		if (segcnt & 1) {
		    if (--free == 0) {
			/*
			 * There's no more room but since nothing
			 * has been committed at this point, just
			 * show output is active, put back the
			 * mbuf and return.
			 */
			ifp->if_flags |= IFF_OACTIVE;
			IF_PREPEND(ifq, m);
			return;
		    }
		    eop = nextout;
		    if (++nextout == ri->ri_last)
			nextout = ri->ri_first;
		    eop->d_flag &= TULIP_DFLAG_ENDRING|TULIP_DFLAG_CHAIN;
		    eop->d_status = d_status;
		    eop->d_addr1 = vtophys(addr); eop->d_length1 = slen;
		} else {
		    /*
		     *  Fill in second half of descriptor
		     */
		    eop->d_addr2 = vtophys(addr); eop->d_length2 = slen;
		}
		d_status = TULIP_DSTS_OWNER;
		len -= slen;
		addr += slen;
		clsize = CLBYTES;
	    }
	} while ((m0 = next_m0) != NULL);
d1572 13
a1584 23
	/*
	 * The packet exceeds the number of transmit buffer
	 * entries that we can use for one packet, so we have
	 * recopy it into one mbuf and then try again.
	 */
	if (recopy) {
	    MGETHDR(m0, M_DONTWAIT, MT_DATA);
	    if (m0 != NULL) {
		if (m->m_pkthdr.len > MHLEN) {
		    MCLGET(m0, M_DONTWAIT);
		    if ((m0->m_flags & M_EXT) == 0) {
			m_freem(m);
			m_freem(m0);
			continue;
		    }
		}
		m_copydata(m, 0, m->m_pkthdr.len, mtod(m0, caddr_t));
		m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len;
		IF_PREPEND(ifq, m0);
	    }
	    m_freem(m);
	    continue;
	}
a1585 9
	/*
	 * The descriptors have been filled in.  Now get ready
	 * to transmit.
	 */
#if NBPFILTER > 0
	if (sc->tulip_bpf != NULL)
	    bpf_mtap(sc->tulip_bpf, m);
#endif
	IF_ENQUEUE(&sc->tulip_txq, m);
d1587 5
a1591 6
	/*
	 * Make sure the next descriptor after this packet is owned
	 * by us since it may have been set up above if we ran out
	 * of room in the ring.
	 */
	nextout->d_status = 0;
d1593 30
a1622 8
	/*
	 * If we only used the first segment of the last descriptor,
	 * make sure the second segment will not be used.
	 */
	if (segcnt & 1) {
	    eop->d_addr2 = 0;
	    eop->d_length2 = 0;
	}
d1624 7
a1630 6
	/*
	 * Mark the last and first segments, indicate we want a transmit
	 * complete interrupt, give the descriptors to the TULIP, and tell
	 * it to transmit!
	 */
	eop->d_flag |= TULIP_DFLAG_TxLASTSEG|TULIP_DFLAG_TxWANTINTR;
a1631 7
	/*
	 * Note that ri->ri_nextout is still the start of the packet
	 * and until we set the OWNER bit, we can still back out of
	 * everything we have done.
	 */
	ri->ri_nextout->d_flag |= TULIP_DFLAG_TxFIRSTSEG;
	ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
d1633 6
a1638 5
	/*
	 * This advances the ring for us.
	 */
	ri->ri_nextout = nextout;
	ri->ri_free = free;
d1640 23
a1662 1
	TULIP_WRITE_CSR(sc, csr_txpoll, 1);
d1664 62
a1725 3
    if (m != NULL) {
	ifp->if_flags |= IFF_OACTIVE;
	IF_PREPEND(ifq, m);
d1728 13
a1740 4

static int
tulip_intr(
    void *arg)
d1742 12
a1753 7
    tulip_softc_t * sc = (tulip_softc_t *) arg;
    tulip_uint32_t csr;
#if defined(__bsdi__)
    int progress = 1;
#else
    int progress = 0;
#endif
d1755 12
a1766 30
    do {
	while ((csr = TULIP_READ_CSR(sc, csr_status)) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR)) {
	    progress = 1;
	    TULIP_WRITE_CSR(sc, csr_status, csr & sc->tulip_intrmask);

	    if (csr & TULIP_STS_SYSERROR) {
		if ((csr & TULIP_STS_ERRORMASK) == TULIP_STS_ERR_PARITY) {
		    tulip_reset(sc);
		    tulip_init(sc);
		    break;
		}
	    }
	    if (csr & (TULIP_STS_GPTIMEOUT|TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL)) {
		if (sc->tulip_chipid == TULIP_DC21041) {
		    (*sc->tulip_boardsw->bd_media_select)(sc);
		    if (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL))
			csr &= ~TULIP_STS_ABNRMLINTR;
		}
	    }
	    if (csr & TULIP_STS_ABNRMLINTR) {
		printf("%s: abnormal interrupt: 0x%05x [0x%05x]\n",
		       sc->tulip_xname, csr, csr & sc->tulip_intrmask);
		TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
	    }
	    if (csr & TULIP_STS_RXINTR)
		tulip_rx_intr(sc);
	    if (sc->tulip_txinfo.ri_free < sc->tulip_txinfo.ri_max) {
		tulip_tx_intr(sc);
		tulip_start(&sc->tulip_if);
	    }
d1768 34
a1801 2
    } while ((sc = sc->tulip_slaves) != NULL);
    return progress;
d1803 10
a1812 1

d1814 1
a1814 1
 *
d1817 4
d1825 4
a1828 5
    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);
    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);

    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);
    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);
a1829 3
    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);
    TULIP_READ_CSR(sc, csr_busmode); TULIP_READ_CSR(sc, csr_busmode);
}
d1831 1
a1831 1
#define EMIT    do { TULIP_WRITE_CSR(sc, csr_srom_mii, csr); tulip_delay_300ns(sc); } while (0)
d1834 1
a1834 1
tulip_idle_srom(
d1839 1
d1852 1
a1852 1
    csr ^= SROMCS; EMIT; EMIT;
d1858 1
a1858 1
tulip_read_srom(
d1867 1
a1867 1
    tulip_idle_srom(sc);
d1871 1
d1882 3
a1884 1
            }
d1893 1
a1893 1
            data |= TULIP_READ_CSR(sc, csr_srom_mii) & SROMDIN ? 1 : 0;
d1898 2
a1899 2
        csr  = SROMSEL | SROMRD; EMIT;
        csr  = 0; EMIT;
d1901 1
d1903 116
a2018 5

#define	tulip_mchash(mca)	(tulip_crc32(mca, 6) & 0x1FF)
#define	tulip_srom_crcok(databuf)	( \
    ((tulip_crc32(databuf, 126) & 0xFFFF) ^ 0xFFFF)== \
     ((databuf)[126] | ((databuf)[127] << 8)))
d2032 620
a2651 1

d2659 1
a2659 1
    tulip_softc_t *sc)
d2662 1
a2662 1
    tulip_uint32_t csr;
d2666 5
a2670 3
    if (sc->tulip_chipid == TULIP_DC21040) {
	TULIP_WRITE_CSR(sc, csr_enetrom, 1);
	for (idx = 0; idx < 32; idx++) {
d2672 1
a2672 1
	    while (((csr = TULIP_READ_CSR(sc, csr_enetrom)) & 0x80000000L) && cnt < 10000)
d2676 1
a2676 1
	sc->tulip_boardsw = &tulip_dc21040_boardsw;
d2681 1
a2681 1
	    tmpbuf[idx] = TULIP_READ_CSRBYTE(sc, csr_enetrom);
d2688 2
a2689 2
	    sc->tulip_rombuf[idx] = TULIP_READ_CSRBYTE(sc, csr_enetrom);
	sc->tulip_boardsw = &tulip_dc21040_boardsw;
d2692 16
a2707 15
	int new_srom_fmt = 0;
	/*
	 * Assume all DC21140 board are compatible with the
	 * DEC 10/100 evaluation board.  Not really valid but
	 * it's the best we can do until every one switches to
	 * the new SROM format.
	 */
	if (sc->tulip_chipid == TULIP_DC21140)
	    sc->tulip_boardsw = &tulip_dc21140_eb_boardsw;
	/*
	 * Thankfully all DC21041's act the same.
	 */
	if (sc->tulip_chipid == TULIP_DC21041)
	    sc->tulip_boardsw = &tulip_dc21041_boardsw;
	tulip_read_srom(sc);
d2713 1
a2713 1
	    new_srom_fmt = 1;
d2725 1
a2725 1
		new_srom_fmt = 2;
d2727 4
a2730 1
	if (new_srom_fmt) {
d2732 5
a2736 9
	     * New SROM format.  Copy out the Ethernet address.
	     * If it contains a DE500-XA string, then it must be
	     * a DE500-XA.
	     */
	    bcopy(sc->tulip_rombuf + 20, sc->tulip_hwaddr, 6);
	    if (bcmp(sc->tulip_rombuf + 29, "DE500-XA", 8) == 0)
		sc->tulip_boardsw = &tulip_dc21140_de500_boardsw;
	    if (bcmp(sc->tulip_rombuf + 29, "DE450", 5) == 0)
		sc->tulip_boardsw = &tulip_dc21041_de450_boardsw;
d2739 1
a2739 2
	    sc->tulip_flags |= TULIP_ROMOK;
	    return 0;
d2765 3
a2767 13
	bcopy(sc->tulip_rombuf, sc->tulip_hwaddr, 6);
	sc->tulip_flags |= TULIP_ROMOK;
	if (sc->tulip_hwaddr[0] == TULIP_OUI_ZNYX_0
		&& sc->tulip_hwaddr[1] == TULIP_OUI_ZNYX_1
		&& sc->tulip_hwaddr[2] == TULIP_OUI_ZNYX_2
	        && (sc->tulip_hwaddr[3] & ~3) == 0xF0) {
	    /*
	     * Now if the OUI is ZNYX and hwaddr[3] == 0xF0 .. 0xF3
	     * then it's a ZX314 Master port.
	     */
	    sc->tulip_boardsw = &tulip_dc21040_zx314_master_boardsw;
	}
	return 0;
d2771 2
a2772 2
	 * only put on one address ROM on their DC21040 boards.  So
	 * if the ROM is all zeros and this is a DC21040, look at the
d2779 10
a2788 3
	if (sc->tulip_chipid == TULIP_DC21040 /* && sc->tulip_bus != 0 XXX */) {
	    for (idx = 0; idx < 32; idx++) {
		if (sc->tulip_rombuf[idx] != 0)
d2790 1
d2792 14
a2805 8
	    if (idx == 32) {
		int root_unit;
		tulip_softc_t *root_sc = NULL;
		for (root_unit = sc->tulip_unit - 1; root_unit >= 0; root_unit--) {
		    root_sc = TULIP_UNIT_TO_SOFTC(root_unit);
		    if (root_sc == NULL || (root_sc->tulip_flags & (TULIP_ROMOK|TULIP_SLAVEDROM)) == TULIP_ROMOK)
			break;
		    root_sc = NULL;
d2807 11
a2817 18
		if (root_sc != NULL
			/* && root_sc->tulip_bus == sc->tulip_bus XXX */) {
		    bcopy(root_sc->tulip_hwaddr, sc->tulip_hwaddr, 6);
		    sc->tulip_hwaddr[5] += sc->tulip_unit - root_sc->tulip_unit;
		    sc->tulip_flags |= TULIP_SLAVEDROM;
		    if (root_sc->tulip_boardsw->bd_type == TULIP_DC21040_ZX314_MASTER) {
			sc->tulip_boardsw = &tulip_dc21040_zx314_slave_boardsw;
			/*
			 * Now for a truly disgusting kludge: all 4 DC21040s on
			 * the ZX314 share the same INTA line so the mapping
			 * setup by the BIOS on the PCI bridge is worthless.
			 * Rather than reprogramming the value in the config
			 * register, we will handle this internally.
			 */
			sc->tulip_slaves = root_sc->tulip_slaves;
			root_sc->tulip_slaves = sc;
		    }
		    return 0;
d2819 1
d2838 1
a2838 1
    bcopy(sc->tulip_rombuf, sc->tulip_hwaddr, 6);
d2840 1
a2840 1
    cksum = *(u_short *) &sc->tulip_hwaddr[0];
d2843 1
a2843 1
    cksum += *(u_short *) &sc->tulip_hwaddr[2];
d2847 1
a2847 1
    cksum += *(u_short *) &sc->tulip_hwaddr[4];
d2850 1
a2850 1
    rom_cksum = *(u_short *) &sc->tulip_rombuf[6];
d2855 1
d2859 5
a2863 13

    if (sc->tulip_chipid == TULIP_DC21140) {
	if (sc->tulip_hwaddr[0] == TULIP_OUI_COGENT_0
		&& sc->tulip_hwaddr[1] == TULIP_OUI_COGENT_1
		&& sc->tulip_hwaddr[2] == TULIP_OUI_COGENT_2) {
	    if (sc->tulip_rombuf[32] == TULIP_COGENT_EM100_ID)
		sc->tulip_boardsw = &tulip_dc21140_cogent_em100_boardsw;
	}
	if (sc->tulip_hwaddr[0] == TULIP_OUI_ZNYX_0
		&& sc->tulip_hwaddr[1] == TULIP_OUI_ZNYX_1
		&& sc->tulip_hwaddr[2] == TULIP_OUI_ZNYX_2) {
	    /* this at least works for the zx342 from Znyx */
	    sc->tulip_boardsw = &tulip_dc21140_znyx_zx34x_boardsw;
d2867 1
a2867 1
    sc->tulip_flags |= TULIP_ROMOK;
d2870 3
a2872 1

d2874 1
a2874 1
tulip_addr_filter(
d2877 2
a2878 4
    tulip_uint32_t *sp = sc->tulip_setupdata;
    struct ether_multistep step;
    struct ether_multi *enm;
    int i;
d2880 87
a2966 1
    sc->tulip_flags &= ~TULIP_WANTHASH;
d2970 5
a2974 1
    if (sc->tulip_ac.ac_multicnt > 14) {
d2977 11
a2991 1

d2993 1
a2993 3
	hash = tulip_mchash(etherbroadcastaddr);
	sp[hash >> 4] |= 1 << (hash & 0xF);
	ETHER_FIRST_MULTI(step, &sc->tulip_ac, enm);
d2995 16
a3010 1
	    hash = tulip_mchash(enm->enm_addrlo);
d3012 191
a3202 1
	    ETHER_NEXT_MULTI(step, enm);
d3204 3
a3206 4
	sc->tulip_flags |= TULIP_WANTHASH;
	sp[39] = ((u_short *) sc->tulip_ac.ac_enaddr)[0]; 
	sp[40] = ((u_short *) sc->tulip_ac.ac_enaddr)[1]; 
	sp[41] = ((u_short *) sc->tulip_ac.ac_enaddr)[2];
d3208 155
d3364 944
a4307 17
	 * Else can get perfect filtering for 16 addresses.
	 */
	i = 0;
	ETHER_FIRST_MULTI(step, &sc->tulip_ac, enm);
	for (; enm != NULL; i++) {
	    *sp++ = ((u_short *) enm->enm_addrlo)[0]; 
	    *sp++ = ((u_short *) enm->enm_addrlo)[1]; 
	    *sp++ = ((u_short *) enm->enm_addrlo)[2];
	    ETHER_NEXT_MULTI(step, enm);
	}
	/*
	 * Add the broadcast address.
	 */
	i++;
	*sp++ = 0xFFFF;
	*sp++ = 0xFFFF;
	*sp++ = 0xFFFF;
d4309 1
a4309 1
	 * Pad the rest with our hardware address
d4311 8
a4318 4
	for (; i < 16; i++) {
	    *sp++ = ((u_short *) sc->tulip_ac.ac_enaddr)[0]; 
	    *sp++ = ((u_short *) sc->tulip_ac.ac_enaddr)[1]; 
	    *sp++ = ((u_short *) sc->tulip_ac.ac_enaddr)[2];
d4320 2
d4324 12
a4335 6

static int
tulip_ioctl(
    struct ifnet * const ifp,
    ioctl_cmd_t cmd,
    caddr_t data)
a4337 3
    struct ifaddr *ifa = (struct ifaddr *)data;
    struct ifreq *ifr = (struct ifreq *) data;
    int s, error = 0;
d4339 6
a4344 1
    s = splnet();
d4346 11
a4356 16
    if ((error = ether_ioctl(ifp, &sc->tulip_ac, cmd, data)) > 0) {
	splx(s);
	return error;
    }

    switch (cmd) {
	case SIOCSIFADDR: {
	    ifp->if_flags |= IFF_UP;
	    switch(ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET: {
		    tulip_init(sc);
		    arp_ifinit(&sc->tulip_ac, ifa);
		    break;
		}
#endif /* INET */
d4358 4
a4361 6
		default: {
		    tulip_init(sc);
		    break;
		}
	    }
	    break;
d4363 3
a4365 14

	case SIOCSIFFLAGS: {
	    /*
	     * Changing the connection forces a reset.
	     */
	    if (sc->tulip_flags & TULIP_ALTPHYS) {
		if ((ifp->if_flags & IFF_ALTPHYS) == 0)
		    tulip_reset(sc);
	    } else {
		if (ifp->if_flags & IFF_ALTPHYS)
		    tulip_reset(sc);
	    }
	    tulip_init(sc);
	    break;
d4368 2
a4369 9
	case SIOCADDMULTI:
	case SIOCDELMULTI: {
	    /*
	     * Update multicast listeners
	     */
	    if (cmd == SIOCADDMULTI)
		error = ether_addmulti(ifr, &sc->tulip_ac);
	    else
		error = ether_delmulti(ifr, &sc->tulip_ac);
d4371 8
a4378 6
	    if (error == ENETRESET) {
		tulip_addr_filter(sc);		/* reset multicast filtering */
		tulip_init(sc);
		error = 0;
	    }
	    break;
d4380 12
a4391 3
#if defined(SIOCSIFMTU)
#if !defined(ifr_mtu)
#define ifr_mtu ifr_metric
d4393 7
a4399 8
	case SIOCSIFMTU:
	    /*
	     * Set the interface MTU.
	     */
	    if (ifr->ifr_mtu > ETHERMTU
#ifndef BIG_PACKET
		    && sc->tulip_chipid != TULIP_DC21140
		    && sc->tulip_chipid != TULIP_DC21041
d4401 2
a4402 8
		) {
		error = EINVAL;
		break;
	    }
	    ifp->if_mtu = ifr->ifr_mtu;
#ifdef BIG_PACKET
	    tulip_reset(sc);
	    tulip_init(sc);
a4403 8
	    break;
#endif /* SIOCSIFMTU */

	default: {
	    error = EINVAL;
	    break;
	}
    }
a4404 4
    splx(s);
    return error;
}

d4412 5
a4416 1
    ifp->if_ioctl = tulip_ioctl;
d4418 4
a4421 1
    ifp->if_start = tulip_start;
d4423 11
a4433 7
#if defined(__FreeBSD__)
    printf("%s", sc->tulip_xname);
#elif defined(__bsdi__)
    printf("\n%s", sc->tulip_xname);
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
    printf(": %s%s pass %d.%d\n%s: Ethernet address %s\n",
d4435 3
a4437 1
    printf(": %s%s pass %d.%d Ethernet address %s\n", 
d4439 3
a4441 1
	   sc->tulip_boardsw->bd_description,
d4444 13
a4456 3
	   sc->tulip_revinfo & 0x0F,
#if defined(__NetBSD__) || defined(__OpenBSD__)
	   sc->tulip_dev.dv_xname,
a4457 1
	   ether_sprintf(sc->tulip_hwaddr));
d4459 22
a4480 4
    if ((*sc->tulip_boardsw->bd_media_probe)(sc)) {
	ifp->if_flags |= IFF_ALTPHYS;
    } else {
	sc->tulip_flags |= TULIP_ALTPHYS;
d4482 5
d4490 4
d4495 2
a4496 2
#if defined(__NetBSD__) || defined(__OpenBSD__)
    ether_ifattach(ifp);
d4498 1
d4501 1
a4501 1
    bpfattach(&sc->tulip_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
d4504 2
a4505 1

d4520 8
a4527 9
    sc->tulip_csrs.csr_missed_frame	= csr_base +  8 * csr_size;
    if (sc->tulip_chipid == TULIP_DC21040) {
	sc->tulip_csrs.csr_enetrom		= csr_base +  9 * csr_size;
	sc->tulip_csrs.csr_reserved		= csr_base + 10 * csr_size;
	sc->tulip_csrs.csr_full_duplex		= csr_base + 11 * csr_size;
	sc->tulip_csrs.csr_sia_status		= csr_base + 12 * csr_size;
	sc->tulip_csrs.csr_sia_connectivity	= csr_base + 13 * csr_size;
	sc->tulip_csrs.csr_sia_tx_rx 		= csr_base + 14 * csr_size;
	sc->tulip_csrs.csr_sia_general		= csr_base + 15 * csr_size;
d4529 2
a4530 23
    } else if (sc->tulip_chipid == TULIP_DE425) {
	sc->tulip_csrs.csr_enetrom		= csr_base + DE425_ENETROM_OFFSET;
	sc->tulip_csrs.csr_reserved		= csr_base + 10 * csr_size;
	sc->tulip_csrs.csr_full_duplex		= csr_base + 11 * csr_size;
	sc->tulip_csrs.csr_sia_status		= csr_base + 12 * csr_size;
	sc->tulip_csrs.csr_sia_connectivity	= csr_base + 13 * csr_size;
	sc->tulip_csrs.csr_sia_tx_rx 		= csr_base + 14 * csr_size;
	sc->tulip_csrs.csr_sia_general		= csr_base + 15 * csr_size;
#endif /* TULIP_EISA */
    } else if (sc->tulip_chipid == TULIP_DC21140) {
	sc->tulip_csrs.csr_srom_mii		= csr_base +  9 * csr_size;
	sc->tulip_csrs.csr_gp_timer		= csr_base + 11 * csr_size;
	sc->tulip_csrs.csr_gp			= csr_base + 12 * csr_size;
	sc->tulip_csrs.csr_watchdog		= csr_base + 15 * csr_size;
    } else if (sc->tulip_chipid == TULIP_DC21041) {
	sc->tulip_csrs.csr_srom_mii		= csr_base +  9 * csr_size;
	sc->tulip_csrs.csr_bootrom		= csr_base + 10 * csr_size;
	sc->tulip_csrs.csr_gp_timer		= csr_base + 11 * csr_size;
	sc->tulip_csrs.csr_sia_status		= csr_base + 12 * csr_size;
	sc->tulip_csrs.csr_sia_connectivity	= csr_base + 13 * csr_size;
	sc->tulip_csrs.csr_sia_tx_rx 		= csr_base + 14 * csr_size;
	sc->tulip_csrs.csr_sia_general		= csr_base + 15 * csr_size;
    }
d4532 2
a4533 1

d4547 2
a4548 1

d4550 1
a4550 1
 * This is the PCI configuration support.  Since the DC21040 is available
d4552 1
a4552 1
 * DC21040 in the config file.
d4571 4
d4581 1
a4581 1
    if (kdc->kdc_unit < NDE) {
d4583 2
a4584 4
	TULIP_WRITE_CSR(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
	DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
			   33MHz that comes to two microseconds but wait a
			   bit longer anyways) */
d4589 1
d4598 18
a4615 6
    if (PCI_CHIPID(device_id) == DC21040_CHIPID)
	return "Digital DC21040 Ethernet";
    if (PCI_CHIPID(device_id) == DC21041_CHIPID)
	return "Digital DC21041 Ethernet";
    if (PCI_CHIPID(device_id) == DC21140_CHIPID)
	return "Digital DC21140 Fast Ethernet";
d4627 1
d4629 1
d4634 2
a4635 1

d4638 1
a4638 11

static void
tulip_shutdown(
    void *arg)
{
    tulip_softc_t * const sc = (tulip_softc_t *) arg;
    TULIP_WRITE_CSR(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
			   33MHz that comes to two microseconds but wait a
			   bit longer anyways) */
}
d4651 2
a4652 1
    if (id != DC21040_CHIPID && id != DC21041_CHIPID && id != DC21140_CHIPID)
d4672 1
d4675 1
d4706 1
a4735 1

d4739 1
d4753 1
d4755 1
d4769 5
a4773 1
    0, "de", tulip_probe, tulip_pci_attach, DV_IFNET, sizeof(tulip_softc_t),
d4780 2
a4781 1

d4784 1
a4784 12

static void
tulip_pci_shutdown(
    void *arg)
{
    tulip_softc_t * const sc = (tulip_softc_t *) arg;
    TULIP_WRITE_CSR(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
    DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
			   33MHz that comes to two microseconds but wait a
			   bit longer anyways) */
}

d4788 1
d4790 3
d4799 4
a4802 3
    if (PCI_CHIPID(pa->pa_id) == DC21040_CHIPID
	    || PCI_CHIPID(pa->pa_id) == DC21041_CHIPID
	    || PCI_CHIPID(pa->pa_id) == DC21140_CHIPID)
d4819 13
a4831 1

d4838 4
d4847 5
a4851 1
    int unit = sc->tulip_dev.dv_unit;
d4856 15
a4873 2
#if defined(__FreeBSD__)
    int unit = sc->tulip_dev.dv_unit;
d4875 4
a4878 5
    const char *intrstr = NULL;
#endif
    int retval, idx, revinfo, id;
#if !defined(TULIP_IOMAPPED) && !defined(__bsdi__) && \
	!defined(__NetBSD__) && !defined(__OpenBSD__)
d4881 1
d4883 1
a4883 2
    tulip_csrptr_t csr_base;
    tulip_desc_t *rxdescs, *txdescs;
d4886 6
a4891 4
#if defined(__FreeBSD__)
    if (unit >= NDE) {
	printf("de%d: not configured; kernel is built for only %d device%s.\n",
	       unit, NDE, NDE == 1 ? "" : "s");
a4893 1
#endif
a4894 4
#if defined(__FreeBSD__)
    revinfo = pci_conf_read(config_id, PCI_CFRV) & 0xFF;
    id = pci_conf_read(config_id, PCI_CFID);
#endif
d4899 1
d4903 1
d4906 2
a4907 1
#endif
d4909 5
a4913 5
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
    revinfo = pci_conf_read(pc, pa->pa_tag, PCI_CFRV) & 0xFF;
    id = pa->pa_id;
#endif
d4916 8
a4923 3
	if (PCI_CHIPID(id) == DC21040_CHIPID) chipid = TULIP_DC21040;
	else if (PCI_CHIPID(id) == DC21140_CHIPID) chipid = TULIP_DC21140;
	else if (PCI_CHIPID(id) == DC21041_CHIPID) chipid = TULIP_DC21041;
d4928 1
a4928 1
    if ((chipid == TULIP_DC21040 || chipid == TULIP_DE425) && revinfo < 0x20) {
d4932 1
a4932 1
	printf(": not configured; DC21040 pass 2.0 required (%d.%d found)\n",
d4935 3
a4937 3
    } else if (chipid == TULIP_DC21140 && revinfo < 0x11) {
#ifdef __FreeBSD__
	printf("de%d", unit);
d4939 2
a4940 2
	printf(": not configured; DC21140 pass 1.1 required (%d.%d found)\n",
	       revinfo >> 4, revinfo & 0x0f);
d4951 39
a4989 7
    rxdescs = (tulip_desc_t *)
	malloc(sizeof(tulip_desc_t) * TULIP_RXDESCS, M_DEVBUF, M_NOWAIT);
    if (rxdescs == NULL) {
#if defined(__FreeBSD__)
	free((caddr_t) sc, M_DEVBUF);
#endif
	return;
a4990 7

    txdescs = (tulip_desc_t *)
	malloc(sizeof(tulip_desc_t) * TULIP_TXDESCS, M_DEVBUF, M_NOWAIT);
    if (txdescs == NULL) {
	free((caddr_t) rxdescs, M_DEVBUF);
#if defined(__FreeBSD__)
	free((caddr_t) sc, M_DEVBUF);
a4991 2
	return;
    }
a4992 1
    sc->tulip_chipid = chipid;
d4996 1
a5001 5

    /* Set up human-readable name. */
    bzero(sc->tulip_xname, sizeof(sc->tulip_xname));
    sprintf(sc->tulip_xname, "%s%d", sc->tulip_name, sc->tulip_unit);

d5003 3
a5011 2
	free((caddr_t) txdescs, M_DEVBUF);
	free((caddr_t) rxdescs, M_DEVBUF);
d5019 1
d5027 17
a5043 4
#if defined(__NetBSD__) || defined(__OpenBSD__)
    sc->tulip_pc = pc;
#if defined(TULIP_IOMAPPED)
    sc->tulip_bst = pa->pa_iot;
d5045 1
a5045 1
    if (!retval)
d5047 3
a5049 1
	    &sc->tulip_bsh);
d5051 1
a5051 1
    sc->tulip_bst = pa->pa_memt;
d5056 5
a5060 1
	    &sc->tulip_bsh);
d5062 22
a5083 5
    csr_base = 0;
    if (retval) {
	free((caddr_t) txdescs, M_DEVBUF);
	free((caddr_t) rxdescs, M_DEVBUF);
	return;
d5087 12
a5098 3
    tulip_initcsrs(sc, csr_base, csrsize);
    tulip_initring(sc, &sc->tulip_rxinfo, rxdescs, TULIP_RXDESCS);
    tulip_initring(sc, &sc->tulip_txinfo, txdescs, TULIP_TXDESCS);
d5100 2
a5101 2
#ifdef __FreeBSD__
	printf("%s", sc->tulip_xname);
d5107 5
a5111 6
	printf("%s: %s%s pass %d.%d Ethernet address %s\n",
	       sc->tulip_xname,
	       (sc->tulip_boardsw != NULL ? sc->tulip_boardsw->bd_description : ""),
	       tulip_chipdescs[sc->tulip_chipid],
	       (sc->tulip_revinfo & 0xF0) >> 4, sc->tulip_revinfo & 0x0F,
	       "unknown");
d5113 6
a5118 7
	/*
	 * Make sure there won't be any interrupts or such...
	 */
	TULIP_WRITE_CSR(sc, csr_busmode, TULIP_BUSMODE_SWRESET);
	DELAY(10);	/* Wait 10 microseconds (actually 50 PCI cycles but at 
			   33MHz that comes to two microseconds but wait a
			   bit longer anyways) */
d5120 1
a5120 1
	if (sc->tulip_boardsw->bd_type != TULIP_DC21040_ZX314_SLAVE) {
d5122 1
d5124 2
a5125 2
	    if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
		pa->pa_intrline, &intrhandle)) {
d5129 4
a5132 4
	    intrstr = pci_intr_string(pc, intrhandle);
	    sc->tulip_ih = pci_intr_establish(pc, intrhandle, IPL_NET,
		tulip_intr, sc, self->dv_xname);
	    if (sc->tulip_ih == NULL) {
d5134 4
a5137 3
                if (intrstr != NULL)
                        printf(" at %s", intrstr);
                printf("\n");
a5138 1
	    }
d5140 1
a5140 1
	sc->tulip_ats = shutdownhook_establish(tulip_pci_shutdown, sc);
d5142 1
a5142 1
	    printf("\n%s: warning: couldn't establish shutdown hook",
d5146 4
a5149 3
	if (sc->tulip_boardsw->bd_type != TULIP_DC21040_ZX314_SLAVE) {
	    if (!pci_map_int (config_id, tulip_intr, (void*) sc, &net_imask)) {
		printf("%s: couldn't map interrupt\n", sc->tulip_xname);
d5153 3
d5158 1
a5158 1
	if (sc->tulip_boardsw->bd_type != TULIP_DC21040_ZX314_SLAVE) {
d5161 2
a5162 2
	    sc->tulip_ih.ih_fun = tulip_intr;
	    sc->tulip_ih.ih_arg = (void *)sc;
d5170 6
d5178 1
a5178 4
#if defined(__NetBSD__) || defined(__OpenBSD__)
	if (intrstr != NULL)
	    printf("%s: interrupting at %s\n", self->dv_xname, intrstr);
#endif
a5180 1
#endif /* NDE > 0 */
@


1.17
log
@Add Matrox Mystique
@
text
@a107 3
#if defined(__mips__)
#include <machine/cpu.h>
#endif
d253 1
a253 1
#if defined(__alpha__) || defined(__mips__)
a270 1
    TULIP_DC21041_P4032,
a948 34

#if defined(__mips__)
static void
tulip_p4032_media_select(
    tulip_softc_t * const sc)
{
    /* This board is AUI only! */
    sc->tulip_media = TULIP_MEDIA_AUI;
    sc->tulip_probe_state = TULIP_PROBE_INACTIVE;

    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_ENHCAPTEFFCT
        /* |TULIP_CMD_FULLDUPLEX */ |TULIP_CMD_THRSHLD160;
    TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);

    sc->tulip_intrmask |= TULIP_STS_NORMALINTR
        |TULIP_STS_ABNRMLINTR|TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL;
    TULIP_WRITE_CSR(sc, csr_intr, sc->tulip_intrmask);

    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_SIACONN_RESET);
    TULIP_WRITE_CSR(sc, csr_sia_tx_rx,        TULIP_DC21041_SIATXRX_AUI);
    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI);
    TULIP_WRITE_CSR(sc, csr_sia_connectivity, TULIP_DC21041_SIACONN_AUI);
    DELAY(10000);       /* Wait 10 millisecs */
}


static const tulip_boardsw_t tulip_p4032_boardsw = {
    TULIP_DC21041_P4032,
    "P4032 ",
    tulip_dc21041_media_probe,
    tulip_p4032_media_select
};
#endif

d966 2
a967 2
    TULIP_WRITE_CSR(sc, csr_txlist, vtophys(&sc->tulip_txinfo.ri_first[0]) | 0xc0000000);
    TULIP_WRITE_CSR(sc, csr_rxlist, vtophys(&sc->tulip_rxinfo.ri_first[0]) | 0xc0000000);
d970 1
a970 1
	|TULIP_BUSMODE_CACHE_ALIGN8|TULIP_BUSMODE_BURSTLEN_8LW /*XXX*/
d988 1
a988 1
    for (di = ri->ri_first; di < ri->ri_last; di++) {
a989 1
    }
d1072 1
a1072 1
	if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER) {
a1073 1
	}
d1083 1
a1083 1
	    if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER) {
a1084 1
	    }
d1207 1
a1207 1
	    ri->ri_nextout->d_addr1 = vtophys(mtod(ms, caddr_t)) | 0xc0000000;
a1208 3
#if defined(__mips__)
	    R4K_HitFlushDCache(mtod(ms, caddr_t),TULIP_RX_BUFLEN);
#endif
a1305 3
#if defined(__mips__)
	    R4K_HitFlushDCache(sc->tulip_setupbuf, sizeof(sc->tulip_setupbuf));
#endif
d1309 1
a1309 1
	    ri->ri_nextout->d_addr1 = vtophys(sc->tulip_setupbuf) | 0xc0000000;
d1386 1
a1386 1
		    eop->d_addr1 = vtophys(addr) | 0xc0000000; eop->d_length1 = slen;
d1391 1
a1391 1
		    eop->d_addr2 = vtophys(addr) | 0xc0000000; eop->d_length2 = slen;
a1392 3
#if defined(__mips__)
		R4K_HitFlushDCache(addr, slen);
#endif
a1643 7
#if defined(__mips__)	/* XXX Oh well */
    if (sc->tulip_chipid == TULIP_DC21041 && sc->tulip_unit == 0 &&
        pci_ether_hw_addr(sc->tulip_pc, (u_int8_t *)&sc->tulip_hwaddr) == 0) {
        sc->tulip_boardsw = &tulip_p4032_boardsw;
        return 0;
    }
#endif
a2129 4
#if defined(__mips__)
    R4K_HitFlushDCache(descs, ndescs * sizeof(tulip_desc_t));
    descs = (tulip_desc_t *)PHYS_TO_UNCACHED(vtophys(descs));
#endif
@


1.16
log
@do SIOCGIFADDR in ether_ioctl
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.15 1996/11/28 23:28:04 niklas Exp $       */
d108 3
d256 1
a256 1
#if defined(__alpha__)
d274 1
d953 34
d1004 2
a1005 2
    TULIP_WRITE_CSR(sc, csr_txlist, vtophys(&sc->tulip_txinfo.ri_first[0]));
    TULIP_WRITE_CSR(sc, csr_rxlist, vtophys(&sc->tulip_rxinfo.ri_first[0]));
d1008 1
a1008 1
	|TULIP_BUSMODE_CACHE_ALIGN8
d1026 1
a1026 1
    for (di = ri->ri_first; di < ri->ri_last; di++)
d1028 1
d1111 1
a1111 1
	if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
d1113 1
d1123 1
a1123 1
	    if (((volatile tulip_desc_t *) eop)->d_status & TULIP_DSTS_OWNER)
d1125 1
d1248 1
a1248 1
	    ri->ri_nextout->d_addr1 = vtophys(mtod(ms, caddr_t));
d1250 3
d1350 3
d1356 1
a1356 1
	    ri->ri_nextout->d_addr1 = vtophys(sc->tulip_setupbuf);
d1433 1
a1433 1
		    eop->d_addr1 = vtophys(addr); eop->d_length1 = slen;
d1438 1
a1438 1
		    eop->d_addr2 = vtophys(addr); eop->d_length2 = slen;
d1440 3
d1694 7
d2187 4
@


1.15
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.14 1996/11/12 20:30:51 niklas Exp $       */
a1955 6
	    break;
	}
	case SIOCGIFADDR: {
	    bcopy((caddr_t) sc->tulip_ac.ac_enaddr,
		  (caddr_t) ((struct sockaddr *)&ifr->ifr_data)->sa_data,
		  6);
@


1.14
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*    $OpenBSD: if_de.c,v 1.13 1996/08/23 16:24:50 niklas Exp $       */
/*    $NetBSD: if_de.c,v 1.22.4.1 1996/06/03 20:32:07 cgd Exp $       */
d106 1
a106 1
#include <machine/bus.old.h>
d137 19
d169 1
a169 13
#else
typedef bus_io_size_t tulip_csrptr_t;

#define	TULIP_READ_CSR(sc, csr)	\
    bus_io_read_4((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSR(sc, csr, val) \
    bus_io_write_4((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr, (val))

#define	TULIP_READ_CSRBYTE(sc, csr) \
    bus_io_read_1((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSRBYTE(sc, csr, val) \
    bus_io_write_1((sc)->tulip_bc, (sc)->tulip_ioh, (sc)->tulip_csrs.csr, (val))
#endif
d186 1
a186 2
#else
typedef bus_mem_size_t tulip_csrptr_t;
a187 6
#define	TULIP_READ_CSR(sc, csr)	\
    bus_mem_read_4((sc)->tulip_bc, (sc)->tulip_memh, (sc)->tulip_csrs.csr)
#define	TULIP_WRITE_CSR(sc, csr, val) \
    bus_mem_write_4((sc)->tulip_bc, (sc)->tulip_memh, (sc)->tulip_csrs.csr, \
      (val))
#endif
d311 3
a313 7
    bus_chipset_tag_t tulip_bc;
    pci_chipset_tag_t tulip_pc;
#ifdef TULIP_IOMAPPED
    bus_io_handle_t tulip_ioh;		/* I/O region handle */
#else
    bus_io_handle_t tulip_memh;		/* memory region handle */
#endif
d419 3
a421 1
#define	vtophys(va)	__alpha_bus_XXX_dmamap(sc->tulip_bc, (void *)(va))
a422 1
#endif
a2416 1
    bus_chipset_tag_t bc = pa->pa_bc;
d2418 2
a2419 7
#if defined(TULIP_IOMAPPED)
    bus_io_addr_t iobase;
    bus_io_size_t iosize;
#else
    bus_mem_addr_t membase;
    bus_mem_size_t memsize;
#endif
a2551 1
    sc->tulip_bc = bc;
d2554 2
a2555 1
    retval = pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize);
d2557 2
a2558 1
	retval = bus_io_map(bc, iobase, iosize, &sc->tulip_ioh);
d2560 2
a2561 1
    retval = pci_mem_find(pc, pa->pa_tag, PCI_CBMA, &membase, &memsize,
d2564 2
a2565 1
	retval = bus_mem_map(bc, membase, memsize, 0, &sc->tulip_memh);
@


1.13
log
@__OpenBSD__ messup fixed
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.12 1996/08/21 22:27:52 deraadt Exp $       */
d106 1
a106 1
#include <machine/bus.h>
@


1.12
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.11 1996/06/10 07:34:41 deraadt Exp $       */
d168 1
a168 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d2436 1
a2436 1
	!(defined(__NetBSD__) || defined(__OpenBSD__))
@


1.11
log
@sync to 0607
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.10 1996/05/26 00:27:41 deraadt Exp $       */
d56 1
a56 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d105 1
a105 1
#if defined(__NetBSD__)
d142 1
a142 1
#ifndef __NetBSD__
d168 1
a168 1
#ifndef __NetBSD__
d307 1
a307 1
#if defined(__NetBSD__)
d380 1
a380 1
#if defined(__NetBSD__)
d394 1
a394 1
#ifdef __NetBSD__
d421 1
a421 1
#if defined(__NetBSD__) && defined(__alpha__)
d2051 1
a2051 1
#if defined(__NetBSD__)
d2060 1
a2060 1
#if defined(__NetBSD__)
d2074 1
a2074 1
#if defined(__NetBSD__)
d2360 1
a2360 1
#if defined(__NetBSD__)
d2417 1
a2417 1
#if defined(__NetBSD__)
d2435 2
a2436 1
#if !defined(TULIP_IOMAPPED) && !defined(__bsdi__) && !defined(__NetBSD__)
d2468 1
a2468 1
#if defined(__NetBSD__)
d2524 1
a2524 1
#if defined(__NetBSD__)
d2560 1
a2560 1
#if defined(__NetBSD__)
d2606 1
a2606 1
#if defined(__NetBSD__)
d2654 1
a2654 1
#if defined(__NetBSD__)
@


1.10
log
@sync 0521
@
text
@d1 2
a2 2
/*    $OpenBSD: if_de.c,v 1.9 1996/05/10 12:41:24 deraadt Exp $       */
/*    $NetBSD: if_de.c,v 1.22 1996/05/13 00:03:09 mycroft Exp $       */
d423 2
a424 1
#define vtophys(va)     (vtophys(va) | 0x40000000)
@


1.9
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*    $OpenBSD: if_de.c,v 1.6 1996/04/21 22:25:13 deraadt Exp $       */
/*    $NetBSD: if_de.c,v 1.19 1996/05/07 02:17:18 thorpej Exp $       */
a106 1
#ifdef __alpha__
d108 1
a108 1
#endif
a1946 1
		    sc->tulip_ac.ac_ipaddr = IA_SIN(ifa)->sin_addr;
d2428 1
d2430 1
@


1.8
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*    $NetBSD: if_de.c,v 1.18 1996/05/03 17:32:20 christos Exp $       */
d320 1
d370 1
d378 1
d387 1
d395 4
d401 1
d452 1
a452 2
	    printf("%s%d: enabling Thinwire/AUI port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d457 1
a457 2
	    printf("%s%d: enabling 10baseT/UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d488 1
a488 2
	printf("%s%d: enabling 10baseT/UTP port\n",
	       sc->tulip_if.if_name, sc->tulip_if.if_unit);
d534 1
a534 2
	    printf("%s%d: enabling 100baseTX UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d542 1
a542 2
	    printf("%s%d: enabling 10baseT UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d586 1
a586 2
	printf("%s%d: enabling 100baseTX UTP port\n",
	       sc->tulip_if.if_name, sc->tulip_if.if_unit);
d633 1
a633 2
	    printf("%s%d: enabling 100baseTX UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d641 1
a641 2
	    printf("%s%d: enabling 10baseT UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d693 1
a693 2
	    printf("%s%d: enabling 100baseTX UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d703 1
a703 2
	    printf("%s%d: enabling 10baseT UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d829 1
a829 2
			printf("%s%d: enabling %s port\n",
			       sc->tulip_if.if_name, sc->tulip_if.if_unit,
d889 2
a890 2
			printf("%s%d: autosense failed: cable problem?\n",
			       sc->tulip_name, sc->tulip_unit);
d921 1
a921 2
	    printf("%s%d: enabling 10baseT/UTP port\n",
		   sc->tulip_if.if_name, sc->tulip_if.if_unit);
d1282 1
a1282 1
    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(ifp->if_unit);
d1514 2
a1515 2
		printf("%s%d: abnormal interrupt: 0x%05x [0x%05x]\n",
		       sc->tulip_name, sc->tulip_unit, csr, csr & sc->tulip_intrmask);
d1930 1
a1930 1
    tulip_softc_t * const sc = TULIP_UNIT_TO_SOFTC(ifp->if_unit);
d2048 1
a2048 1
    printf("%s%d", sc->tulip_name, sc->tulip_unit);
d2050 1
a2050 1
    printf("\n%s%d", sc->tulip_name, sc->tulip_unit);
d2052 3
d2056 1
d2061 3
d2522 4
d2528 1
d2530 5
d2584 1
a2584 1
	printf("%s%d", sc->tulip_name, sc->tulip_unit);
d2590 2
a2591 2
	printf("%s%d: %s%s pass %d.%d Ethernet address %s\n",
	       sc->tulip_name, sc->tulip_unit,
d2626 2
a2627 2
	    printf("\n%s%d: warning: couldn't establish shutdown hook",
		   sc->tulip_name, sc->tulip_unit);
d2632 1
a2632 2
		printf("%s%d: couldn't map interrupt\n",
		       sc->tulip_name, sc->tulip_unit);
@


1.7
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d2 1
a2 1
/*    $NetBSD: if_de.c,v 1.17 1996/04/01 19:37:54 cgd Exp $       */
d1940 1
a1940 1
    if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
d2596 1
a2596 1
		printf(": couldn't map interrupt\n", self->dv_xname);
d2603 1
a2603 1
		printf(": couldn't establish interrupt", self->dv_xname);
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*    $OpenBSD: if_de.c,v 1.5 1996/04/18 23:47:56 niklas Exp $       */
a78 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d1940 5
a1956 21

#ifdef NS
		/*
		 * This magic copied from if_is.c; I don't use XNS,
		 * so I have no way of telling if this actually
		 * works or not.
		 */
		case AF_NS: {
		    struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);
		    if (ns_nullhost(*ina)) {
			ina->x_host = *(union ns_host *)(sc->tulip_ac.ac_enaddr);
		    } else {
			ifp->if_flags &= ~IFF_RUNNING;
			bcopy((caddr_t)ina->x_host.c_host,
			      (caddr_t)sc->tulip_ac.ac_enaddr,
			      sizeof sc->tulip_ac.ac_enaddr);
		    }
		    tulip_init(sc);
		    break;
		}
#endif /* NS */
@


1.5
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*    $OpenBSD$       */
/*    $NetBSD: if_de.c,v 1.13 1996/03/14 03:04:17 cgd Exp $       */
d112 3
a117 3
#ifdef __i386__	/* XXX -- fix later -- cgd */
#include <i386/isa/isa_machdep.h>
#endif
a143 3
#ifndef __NetBSD__
#else
#endif
d317 2
a318 1
    bus_chipset_tag_t tulip_bc;		/* bus chipset tag */
d386 3
a388 2
extern struct cfdriver decd;
#define	TULIP_UNIT_TO_SOFTC(unit)	((tulip_softc_t *) decd.cd_devs[unit])
d418 4
d676 1
a676 1
	return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_DE500_NOTOK_100) != 0;
d685 1
a685 1
    return (TULIP_READ_CSR(sc, csr_gp) & TULIP_GP_DE500_NOTOK_100) != 0;
d1195 1
a1195 1
			bcopy(mtod(m, caddr_t) + sizeof(struct ether_header),
d1198 1
a1198 1
			m_copydata(m, 0, total_len, mtod(m0, caddr_t));
d2412 6
a2417 2
struct cfdriver decd = {
    0, "de", tulip_pci_probe, tulip_pci_attach, DV_IFNET, sizeof(tulip_softc_t)
d2438 9
d2448 1
d2451 1
a2451 1
#if !defined(TULIP_IOMAPPED) && !defined(__bsdi__)
d2484 1
a2484 1
    revinfo = pci_conf_read(pa->pa_tag, PCI_CFRV) & 0xFF;
d2566 2
a2567 1
    sc->tulip_bc = pa->pa_bc;
d2569 3
a2571 1
    retval = pci_map_io(pa->pa_tag, PCI_CBIO, &sc->tulip_ioh);
d2573 4
a2576 1
    retval = pci_map_mem(pa->pa_tag, PCI_CBMA, &sc->tulip_memh, &pa_csrs);
d2613 10
a2622 2
	    sc->tulip_ih = pci_map_int(pa->pa_tag, IPL_NET, tulip_intr, sc,
				       sc->tulip_dev.dv_xname);
d2624 4
a2627 2
		printf("%s%d: couldn't map interrupt\n",
		       sc->tulip_name, sc->tulip_unit);
a2629 4
#if defined(__i386__)
	    /* gross but netbsd won't print the irq otherwise */
	    printf(" irq %d", ((struct intrhand *) sc->tulip_ih)->ih_irq);
#endif
d2633 1
a2633 1
	    printf("%s%d: warning: couldn't establish shutdown hook\n",
d2660 4
@


1.4
log
@sc_dev -> tulip_dev
@
text
@d1 2
a2 1
/*    $NetBSD: if_de.c,v 1.11 1995/12/24 02:32:13 mycroft Exp $       */
d111 2
d115 1
a115 2
#if defined(__i386__)
#include <machine/pio.h>
a144 1
typedef tulip_uint16_t tulip_csrptr_t;
a145 1
typedef int tulip_csrptr_t;
a148 1
#define	TULIP_EISA_CSROFFSET	0
d150 3
a152 1
#define	TULIP_PCI_CSROFFSET	0
d159 13
d175 3
a179 8
#if defined(__alpha__)
#define	TULIP_PCI_CSRSIZE	(256 / sizeof(tulip_uint32_t))
#define	TULIP_PCI_CSROFFSET	(24 / sizeof(tulip_uint32_t))
#elif defined(__i386__)
#define	TULIP_PCI_CSRSIZE	(8 / sizeof(tulip_uint32_t))
#define	TULIP_PCI_CSROFFSET	0
#endif

a185 1
#ifndef __alpha__
d189 4
d194 2
a195 1
	    ((void)(*(sc)->tulip_csrs.csr = (val), MB()))
a196 1

d320 6
a2436 1
    unsigned csroffset = TULIP_PCI_CSROFFSET;
a2460 1
	csroffset = TULIP_EISA_CSROFFSET;
d2549 1
d2551 1
a2551 1
    retval = pci_map_io(pa->pa_tag, PCI_CBIO, &csr_base);
d2553 1
a2553 1
    retval = pci_map_mem(pa->pa_tag, PCI_CBMA, (vm_offset_t *) &csr_base, &pa_csrs);
d2555 1
d2563 1
a2563 1
    tulip_initcsrs(sc, csr_base + csroffset, csrsize);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d2573 1
a2573 1
				       sc->sc_dev.dv_xname);
@


1.2
log
@from netbsd; merge latest Thomas version with our minimal changes
@
text
@d2572 2
a2573 1
	    sc->tulip_ih = pci_map_int(pa->pa_tag, IPL_NET, tulip_intr, sc);
@


1.1
log
@Initial revision
@
text
@d1 2
d256 2
a257 1
#define	TULIP_RXQ_TARGET	8
d261 2
d301 1
a301 1
    struct intrhand tulip_ih;		/* interrupt vectoring */
d306 1
a306 1
    void *tulip_ih;			/* interrupt vectoring */
d312 10
a321 8
#define	TULIP_WANTSETUP		0x01
#define	TULIP_WANTHASH		0x02
#define	TULIP_DOINGSETUP	0x04
#define	TULIP_ALTPHYS		0x08	/* use AUI */
#define	TULIP_TXPROBE_ACTIVE	0x10
#define	TULIP_TXPROBE_OK	0x20
#define	TULIP_INRESET		0x40
#define	TULIP_WANTRXACT		0x80
d329 1
d334 1
d358 1
d365 1
d374 4
d422 2
a423 1
    sc->tulip_cmdmode |= TULIP_CMD_CAPTREFFCT|TULIP_CMD_THRSHLD160;
d449 39
d506 2
a507 1
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE;
d529 5
a542 1

d561 2
a562 1
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE;
d573 5
d582 1
a582 1
    "Cogent EM100",
d608 2
a609 1
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE;
d631 5
d640 1
a640 1
    "Znyx ZX34X ",
d671 2
a672 1
    sc->tulip_cmdmode |= TULIP_CMD_STOREFWD|TULIP_CMD_MUSTBEONE;
d696 5
d716 6
d727 1
a727 1
	/* |TULIP_CMD_FULLDUPLEX */ |TULIP_CMD_THRSHLD160;
d754 1
a754 1
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC);
d761 1
a761 1
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI);
d774 1
a774 1
		TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_10BASET);
d792 1
a792 1
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC);
d799 1
a799 1
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI);
d887 1
a887 1
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_BNC);
d894 1
a894 1
		    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_AUI);
d915 1
a915 1
	    TULIP_WRITE_CSR(sc, csr_sia_general,      TULIP_DC21041_SIAGEN_10BASET);
d948 1
a948 1
    DELAY(10);	/* Wait 10 microsends (actually 50 PCI cycles but at 
d959 2
a960 1
        TULIP_BUSMODE_BURSTLEN_8LW|TULIP_BUSMODE_CACHE_ALIGN8
a1044 35

#if TULIP_CHECK_RXCRC
static unsigned
tulip_crc32(
    u_char *addr,
    int len)
{
    unsigned int crc = 0xFFFFFFFF;
    static unsigned int crctbl[256];
    int idx;
    static int done;
    /*
     * initialize the multicast address CRC table
     */
    for (idx = 0; !done && idx < 256; idx++) {
	unsigned int tmp = idx;
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	tmp = (tmp >> 1) ^ (tmp & 1 ? TULIP_CRC32_POLY : 0);	/* XOR */
	crctbl[idx] = tmp;
    }
    done = 1;

    while (len-- > 0)
	crc = (crc >> 8) ^ crctbl[*addr++] ^ crctbl[crc & 0xFF];

    return crc;
}
#endif

d1055 2
a1056 2
	int total_len = 0;
	struct mbuf *m = NULL;
d1060 1
a1060 1
	     goto queue_mbuf;
d1063 31
a1093 5
	    break;
	
	total_len = ((eop->d_status >> 16) & 0x7FF) - 4;
	IF_DEQUEUE(&sc->tulip_rxq, m);
	if ((eop->d_status & TULIP_DSTS_ERRSUM) == 0) {
d1095 10
a1104 8
#if TULIP_CHECK_RXCRC
	    unsigned crc = tulip_crc32(mtod(m, unsigned char *), total_len);
	    if (~crc != *((unsigned *) &bufaddr[total_len])) {
		printf("%s%d: bad rx crc: %08x [rx] != %08x\n",
		       sc->tulip_name, sc->tulip_unit,
		       *((unsigned *) &bufaddr[total_len]), ~crc);
		goto next;
	    }
d1106 3
a1108 1
	    eh = *mtod(m, struct ether_header *);
d1111 4
a1114 1
		bpf_tap(sc->tulip_bpf, mtod(m, caddr_t), total_len);
d1127 3
a1129 2
	if (++ri->ri_nextin == ri->ri_last)
	    ri->ri_nextin = ri->ri_first;
d1136 4
a1139 1
	 * the mbuf.
d1141 1
a1141 1
	if (accept || m == NULL) {
d1163 6
a1168 5
		    m->m_data += sizeof(struct ether_header);
		    m->m_len = m->m_pkthdr.len = total_len;
		    m->m_pkthdr.rcvif = ifp;
		    ether_input(ifp, &eh, m);
		    m = m0;
d1170 8
a1177 2
		    bcopy(mtod(m, caddr_t) + sizeof(struct ether_header),
			  mtod(m0, caddr_t), total_len);
d1186 1
a1186 1
		m = m0;
d1189 2
a1190 2
	if (m == NULL)
	    break;
d1192 1
a1192 1
	 * Now give the buffer to the TULIP and save in our
d1195 10
a1204 6
	ri->ri_nextout->d_length1 = MCLBYTES - 4;
	ri->ri_nextout->d_addr1 = vtophys(mtod(m, caddr_t));
	ri->ri_nextout->d_status = TULIP_DSTS_OWNER;
	if (++ri->ri_nextout == ri->ri_last)
	    ri->ri_nextout = ri->ri_first;
	IF_ENQUEUE(&sc->tulip_rxq, m);
d1473 1
a1473 1
    tulip_softc_t * const sc = (tulip_softc_t *) arg;
d1481 23
a1503 9
    while ((csr = TULIP_READ_CSR(sc, csr_status)) & (TULIP_STS_NORMALINTR|TULIP_STS_ABNRMLINTR)) {
	progress = 1;
	TULIP_WRITE_CSR(sc, csr_status, csr & sc->tulip_intrmask);

	if (csr & TULIP_STS_SYSERROR) {
	    if ((csr & TULIP_STS_ERRORMASK) == TULIP_STS_ERR_PARITY) {
		tulip_reset(sc);
		tulip_init(sc);
		break;
d1505 5
a1509 6
	}
	if (csr & (TULIP_STS_GPTIMEOUT|TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL)) {
	    if (sc->tulip_chipid == TULIP_DC21041) {
		(*sc->tulip_boardsw->bd_media_select)(sc);
		if (csr & (TULIP_STS_LINKPASS|TULIP_STS_LINKFAIL))
		    csr &= ~TULIP_STS_ABNRMLINTR;
d1512 1
a1512 12
	if (csr & TULIP_STS_ABNRMLINTR) {
	    printf("%s%d: abnormal interrupt: 0x%05x [0x%05x]\n",
		   sc->tulip_name, sc->tulip_unit, csr, csr & sc->tulip_intrmask);
	    TULIP_WRITE_CSR(sc, csr_command, sc->tulip_cmdmode);
	}
	if (csr & TULIP_STS_RXINTR)
	    tulip_rx_intr(sc);
	if (sc->tulip_txinfo.ri_free < sc->tulip_txinfo.ri_max) {
	    tulip_tx_intr(sc);
	    tulip_start(&sc->tulip_if);
	}
    }
d1705 1
d1716 2
a1717 1
	 * ZNYX???)
d1719 1
a1719 1
	for (idx = 6; idx < 32; idx++) {
d1733 11
d1745 46
d1843 1
d1894 1
a1894 1
	 * If an IP address is enabled, turn on broadcast
d1896 4
a1899 6
	if (sc->tulip_ac.ac_ipaddr.s_addr != 0) {
	    i++;
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
	    *sp++ = 0xFFFF;
	}
a1910 2
/*extern void arp_ifinit(struct arpcom *, struct ifaddr*);*/

d1922 1
a1922 1
    s = splimp();
a1925 1

a1930 1
		    tulip_addr_filter(sc);	/* reset multicast filtering */
a1931 1
#if defined(__FreeBSD__) || defined(__NetBSD__)
a1932 3
#elif defined(__bsdi__)
		    arpwhohas(&sc->tulip_ac, &IA_SIN(ifa)->sin_addr);
#endif
a1952 1

d1965 6
d2012 6
a2017 1
	    if (ifr->ifr_mtu > ETHERMTU) {
d2019 1
a2019 2
	    } else {
		ifp->if_mtu = ifr->ifr_mtu;
d2021 5
d2027 1
a2027 1
#endif
d2050 1
a2050 1
#ifdef __FreeBSD__
d2052 2
d2174 1
a2174 1
	DELAY(10);	/* Wait 10 microsends (actually 50 PCI cycles but at 
d2221 1
a2221 1
    DELAY(10);	/* Wait 10 microsends (actually 50 PCI cycles but at 
d2257 2
a2258 23
#if defined(TULIP_EISA)
    if ((slot = eisa_match(cf, ia)) != 0) {
	unsigned tmp;
	ia->ia_iobase = slot << 12;
	ia->ia_iosize = EISA_NPORT;
	eisa_slotalloc(slot);
	tmp = inb(ia->ia_iobase + DE425_CFG0);
	irq = tulip_eisa_irqs[(tmp >> 1) & 0x03];
	/*
	 * Until BSD/OS likes level interrupts, force
	 * the DE425 into edge-triggered mode.
	 */
	if ((tmp & 1) == 0)
	    outb(ia->ia_iobase + DE425_CFG0, tmp | 1);
	/*
	 * CBIO needs to map to the EISA slot
	 * enable I/O access and Master
	 */
	outl(ia->ia_iobase + DE425_CBIO, ia->ia_iobase);
	outl(ia->ia_iobase + DE425_CFCS, 5 | inl(ia->ia_iobase + DE425_CFCS));
	ia->ia_aux = NULL;
    } else {
#endif /* TULIP_EISA */
d2289 2
d2292 29
a2321 1
#endif
d2327 2
a2328 1
	printf("de%d: error: desired IRQ of %d does not match device's actual IRQ of %d,\n",
d2333 1
a2333 2
    if (ia->ia_irq == IRQUNK && (ia->ia_irq = isa_irqalloc(irq)) == 0) {
	printf("de%d: warning: IRQ %d is shared\n", cf->cf_unit, ffs(irq) - 1);
d2335 1
a2335 1
    }
d2366 1
a2366 1
    DELAY(10);	/* Wait 10 microsends (actually 50 PCI cycles but at 
d2567 1
a2567 1
	DELAY(10);	/* Wait 10 microsends (actually 50 PCI cycles but at 
d2571 7
a2577 6
	sc->tulip_ih = pci_map_int(pa->pa_tag, PCI_IPL_NET, tulip_intr, sc);
	if (sc->tulip_ih == NULL) {
	    printf("%s%d: couldn't map interrupt\n",
		   sc->tulip_name, sc->tulip_unit);
	    return;
	}
d2579 2
a2580 2
	/* gross but netbsd won't print the irq otherwise */
	printf(" irq %d", ((struct intrhand *) sc->tulip_ih)->ih_irq);
d2582 1
d2589 7
a2595 1
	pci_map_int (config_id, tulip_intr, (void*) sc, &net_imask);
d2598 2
a2599 1
	isa_establish(&sc->tulip_id, &sc->tulip_dev);
d2601 4
a2604 3
	sc->tulip_ih.ih_fun = tulip_intr;
	sc->tulip_ih.ih_arg = (void *)sc;
	intr_establish(ia->ia_irq, &sc->tulip_ih, DV_NET);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
