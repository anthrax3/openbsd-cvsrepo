head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.4
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.6
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.16.0.18
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.14
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.4
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.24
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.22
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.20
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.18
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.16
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.14
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.12
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.10
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	SMP:1.2.0.8
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	UBC:1.2.0.4
	UBC_SYNC_B:1.2
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2015.09.09.19.47.11;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	oiL5hLU4dw0Ni62e;

1.20
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.19;
commitid	OBNa5kfxQ2UXoiIw;

1.19
date	2014.05.27.12.40.00;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.26.14.41.41;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2014.03.17.22.01.56;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.07.19.32.44;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.08.00.23.53;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2010.03.28.13.22.07;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.10.16.57.44;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.10.15.28.45;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.10.14.44.42;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2009.04.20.01.28.45;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.09.15.11.19;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.07.17.35.22;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.06.22.49.39;	author oga;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.26.15.35.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2007.10.06.23.50.54;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.04.19.40.25;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.25.23.31.04;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2002.07.12.20.17.03;	author mickey;	state Exp;
branches;
next	;

1.2.4.1
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@sizes for free(); ok semarie
@
text
@/*	$OpenBSD: agp_amd.c,v 1.20 2014/07/12 18:48:51 tedu Exp $	*/
/*	$NetBSD: agp_amd.c,v 1.6 2001/10/06 02:48:50 thorpej Exp $	*/

/*-
 * Copyright (c) 2000 Doug Rabson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/pci/agp_amd.c,v 1.6 2001/07/05 21:28:46 jhb Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/rwlock.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/vga_pcivar.h>
#include <dev/pci/agpvar.h>
#include <dev/pci/agpreg.h>

#include <dev/pci/pcidevs.h>

#define READ2(off)	bus_space_read_2(asc->iot, asc->ioh, off)
#define READ4(off)	bus_space_read_4(asc->iot, asc->ioh, off)
#define WRITE2(off,v)	bus_space_write_2(asc->iot, asc->ioh, off, v)
#define WRITE4(off,v)	bus_space_write_4(asc->iot, asc->ioh, off, v)

struct agp_amd_gatt {
	bus_dmamap_t	ag_dmamap;
	bus_dma_segment_t ag_dmaseg;
	int		ag_nseg;
	u_int32_t	ag_entries;
	u_int32_t      *ag_vdir;	/* virtual address of page dir */
	bus_addr_t	ag_pdir;	/* bus address of page dir */
	u_int32_t      *ag_virtual;	/* virtual address of gatt */
	bus_addr_t	ag_physical;	/* bus address of gatt */
	size_t		ag_size;
};

struct agp_amd_softc {
	struct device		 dev;
	struct agp_softc	*agpdev;
	struct agp_amd_gatt	*gatt;
	pci_chipset_tag_t	 asc_pc;
	pcitag_t		 asc_tag;
	bus_space_handle_t	 ioh;
	bus_space_tag_t		 iot;
	bus_addr_t		 asc_apaddr;
	bus_size_t		 asc_apsize;
	pcireg_t		 asc_apctrl;
	pcireg_t		 asc_modectrl;
	u_int16_t		 asc_status;
};

void	agp_amd_attach(struct device *, struct device *, void *);
int	agp_amd_activate(struct device *, int);
void	agp_amd_save(struct agp_amd_softc *);
void	agp_amd_restore(struct agp_amd_softc *);
int	agp_amd_probe(struct device *, void *, void *);
bus_size_t agp_amd_get_aperture(void *);
struct agp_amd_gatt *agp_amd_alloc_gatt(bus_dma_tag_t, bus_size_t);
int	agp_amd_set_aperture(void *, bus_size_t);
void	agp_amd_bind_page(void *, bus_size_t, paddr_t, int);
void	agp_amd_unbind_page(void *, bus_size_t);
void	agp_amd_flush_tlb(void *);

struct cfattach amdagp_ca = {
	sizeof(struct agp_amd_softc), agp_amd_probe, agp_amd_attach, NULL,
	agp_amd_activate
};

struct cfdriver amdagp_cd = {
	NULL, "amdagp", DV_DULL
};

const struct agp_methods agp_amd_methods = {
	agp_amd_bind_page,
	agp_amd_unbind_page,
	agp_amd_flush_tlb,
};


struct agp_amd_gatt *
agp_amd_alloc_gatt(bus_dma_tag_t dmat, bus_size_t apsize)
{
	bus_size_t entries = apsize >> AGP_PAGE_SHIFT;
	struct agp_amd_gatt *gatt;
	int i, npages;
	caddr_t vdir;

	gatt = malloc(sizeof(struct agp_amd_gatt), M_AGP, M_NOWAIT);
	if (!gatt)
		return (0);
	gatt->ag_size = AGP_PAGE_SIZE + entries * sizeof(u_int32_t);

	if (agp_alloc_dmamem(dmat, gatt->ag_size, &gatt->ag_dmamap,
	    &gatt->ag_pdir, &gatt->ag_dmaseg) != 0) {
		printf("failed to allocate GATT\n");
		free(gatt, M_AGP, sizeof *gatt);
		return (NULL);
	}

	if (bus_dmamem_map(dmat, &gatt->ag_dmaseg, 1, gatt->ag_size,
	    &vdir, BUS_DMA_NOWAIT) != 0) {
		printf("failed to map GATT\n");
		agp_free_dmamem(dmat, gatt->ag_size, gatt->ag_dmamap,
		    &gatt->ag_dmaseg);
		free(gatt, M_AGP, sizeof *gatt);
		return (NULL);
	}

	gatt->ag_vdir = (u_int32_t *)vdir;
	gatt->ag_entries = entries;
	gatt->ag_virtual = (u_int32_t *)(vdir + AGP_PAGE_SIZE);
	gatt->ag_physical = gatt->ag_pdir + AGP_PAGE_SIZE;

	/*
	 * Map the pages of the GATT into the page directory.
	 */
	npages = ((gatt->ag_size - 1) >> AGP_PAGE_SHIFT);

	for (i = 0; i < npages; i++)
		gatt->ag_vdir[i] = (gatt->ag_physical + i * AGP_PAGE_SIZE) | 1;

	/*
	 * Make sure the chipset can see everything.
	 */
	agp_flush_cache();

	return (gatt);
}

int
agp_amd_probe(struct device *parent, void *match, void *aux)
{
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;

	/* Must be a pchb */
	if (agpbus_probe(aa) == 1 && PCI_VENDOR(pa->pa_id) == PCI_VENDOR_AMD &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_SC751_SC ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_761_PCHB ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_AMD_762_PCHB))
			return (1);
	return (0);
}

void
agp_amd_attach(struct device *parent, struct device *self, void *aux)
{
	struct agp_amd_softc	*asc = (struct agp_amd_softc *)self;
	struct agp_attach_args	*aa = aux;
	struct pci_attach_args	*pa = aa->aa_pa;
	struct agp_amd_gatt	*gatt;
	pcireg_t		 reg;
	int			 error;

	asc->asc_pc = pa->pa_pc;
	asc->asc_tag = pa->pa_tag;

	if (pci_mapreg_info(pa->pa_pc, pa->pa_tag, AGP_APBASE,
	    PCI_MAPREG_TYPE_MEM, &asc->asc_apaddr, NULL, NULL) != 0) {
		printf(": can't get aperture info\n");
		return;
	}

	error = pci_mapreg_map(pa, AGP_AMD751_REGISTERS,
	     PCI_MAPREG_TYPE_MEM, 0, &asc->iot, &asc->ioh, NULL, NULL, 0);
	if (error != 0) {
		printf("can't map AGP registers\n");
		return;
	}

	asc->asc_apsize = agp_amd_get_aperture(asc);

	for (;;) {
		gatt = agp_amd_alloc_gatt(pa->pa_dmat, asc->asc_apsize);
		if (gatt != NULL)
			break;

		/*
		 * almost certainly error allocating contigious dma memory
		 * so reduce aperture so that the gatt size reduces.
		 */
		asc->asc_apsize /= 2;
		if (agp_amd_set_aperture(asc, asc->asc_apsize)) {
			printf(": failed to set aperture\n");
			return;
		}
	}
	asc->gatt = gatt;

	/* Install the gatt. */
	WRITE4(AGP_AMD751_ATTBASE, gatt->ag_physical);

	/* Enable synchronisation between host and agp. */
	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_AMD751_MODECTRL);
	reg &= ~0x00ff00ff;
	reg |= (AGP_AMD751_MODECTRL_SYNEN) | (AGP_AMD751_MODECTRL2_GPDCE << 16);
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_AMD751_MODECTRL, reg);
	/* Enable the TLB and flush */
	WRITE2(AGP_AMD751_STATUS,
	    READ2(AGP_AMD751_STATUS) | AGP_AMD751_STATUS_GCE);
	agp_amd_flush_tlb(asc);

	asc->agpdev = (struct agp_softc *)agp_attach_bus(pa, &agp_amd_methods,
	    asc->asc_apaddr, asc->asc_apsize, &asc->dev);
	return;
}

int
agp_amd_activate(struct device *arg, int act)
{
	struct agp_amd_softc *asc = (struct agp_amd_softc *)arg;

	switch (act) {
	case DVACT_SUSPEND:
		agp_amd_save(asc);
		break;
	case DVACT_RESUME:
		agp_amd_restore(asc);
		break;
	}

	return (0);
}

void
agp_amd_save(struct agp_amd_softc *asc)
{
	asc->asc_apctrl = pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_AMD751_APCTRL);
	asc->asc_modectrl = pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_AMD751_MODECTRL);
	asc->asc_status = READ2(AGP_AMD751_STATUS);
}

void
agp_amd_restore(struct agp_amd_softc *asc)
{

	/* restore aperture size */
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_AMD751_APCTRL,
	    asc->asc_apctrl);

	/* Install the gatt. */
	WRITE4(AGP_AMD751_ATTBASE, asc->gatt->ag_physical);

	/* Reenable synchronisation between host and agp. */
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_AMD751_MODECTRL,
	    asc->asc_modectrl);
	/* Enable the TLB and flush */
	WRITE2(AGP_AMD751_STATUS, asc->asc_status);
	agp_amd_flush_tlb(asc);
}

bus_size_t
agp_amd_get_aperture(void *sc)
{
	struct agp_amd_softc	*asc = sc;
	int			 vas;

	vas = (pci_conf_read(asc->asc_pc, asc->asc_tag,
	    AGP_AMD751_APCTRL) & 0x06);
	vas >>= 1;
	/*
	 * The aperture size is equal to 32M<<vas.
	 */
	return ((32 * 1024 * 1024) << vas);
}

int
agp_amd_set_aperture(void *sc, bus_size_t aperture)
{
	struct agp_amd_softc	*asc = sc;
	int			 vas;
	pcireg_t		 reg;

	/*
	 * Check for a power of two and make sure its within the
	 * programmable range.
	 */
	if (aperture & (aperture - 1)
	    || aperture < 32*1024*1024
	    || aperture > 2U*1024*1024*1024)
		return (EINVAL);

	vas = ffs(aperture / 32*1024*1024) - 1;

	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_AMD751_APCTRL);
	reg = (reg & ~0x06) | (vas << 1);
	pci_conf_write(asc->asc_pc, asc->asc_tag, AGP_AMD751_APCTRL, reg);

	return (0);
}

void
agp_amd_bind_page(void *sc, bus_size_t offset, paddr_t physical, int flags)
{
	struct agp_amd_softc	*asc = sc;

	asc->gatt->ag_virtual[(offset - asc->asc_apaddr) >> AGP_PAGE_SHIFT] =
	    physical | 1;
}

void
agp_amd_unbind_page(void *sc, bus_size_t offset)
{
	struct agp_amd_softc	*asc = sc;

	asc->gatt->ag_virtual[(offset - asc->asc_apaddr) >> AGP_PAGE_SHIFT] = 0;
}

void
agp_amd_flush_tlb(void *sc)
{
	struct agp_amd_softc	*asc = sc;

	/* Set the cache invalidate bit and wait for the chipset to clear */
	WRITE4(AGP_AMD751_TLBCTRL, 1);
	do {
		DELAY(1);
	} while (READ4(AGP_AMD751_TLBCTRL));
}
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.19 2014/05/27 12:40:00 kettenis Exp $	*/
d122 1
a122 1
		free(gatt, M_AGP, 0);
d131 1
a131 1
		free(gatt, M_AGP, 0);
@


1.19
log
@We're never going to detach agp(4), so remove the #ifdef'ed out code like we
already did for intagp(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.18 2014/03/26 14:41:41 mpi Exp $	*/
d122 1
a122 1
		free(gatt, M_AGP);
d131 1
a131 1
		free(gatt, M_AGP);
@


1.18
log
@No need to include <sys/lock.h> when only <sys/rwlock.h> is needed,
so remove the former and include the latter instead of pulling it
in <dev/pci/agpvar.h>.  This header already requires various other
types anyway.  While here remove unneeded headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.17 2014/03/17 22:01:56 kettenis Exp $	*/
a155 12
#if 0
void
agp_amd_free_gatt(bus_dma_tag_t dmat, struct agp_amd_gatt *gatt)
{
	bus_dmamem_unmap(dmat, gatt->ag_virtual, gatt->ag_size);
	agp_free_dmamem(dmat, gatt->ag_size,
	    gatt->ag_dmamap, (caddr_t)gatt->ag_virtual, &gatt->ag_dmaseg,
	    gatt->ag_nseg);
	free(gatt, M_AGP);
}
#endif

a232 30

#if 0
int
agp_amd_detach(void *sc)
{
	struct agp_amd_softc	*asc = sc;
	pcireg_t		 reg;

	/* Disable the TLB.. */
	WRITE2(AGP_AMD751_STATUS,
	    READ2(AGP_AMD751_STATUS) & ~AGP_AMD751_STATUS_GCE);

	/* Disable host-agp sync */
	reg = pci_conf_read(asc->asc_pc, asc->asc_tag, AGP_AMD751_MODECTRL);
	reg &= 0xffffff00;
	pci_conf_write(asc->asc_pc, asc->asc_pcitag, AGP_AMD751_MODECTRL, reg);

	/* Clear the GATT base */
	WRITE4(AGP_AMD751_ATTBASE, 0);

	/* Put the aperture back the way it started. */
	agp_amd_set_aperture(asc, asc->initial_aperture);

	agp_amd_free_gatt(asc, asc->gatt);

	/* XXXfvdl no pci_mapreg_unmap */

	return (0);
}
#endif
@


1.17
log
@The AGP ioctl interface is gone; remove the header file as well.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.16 2010/08/07 19:32:44 oga Exp $	*/
a34 3
#include <sys/kernel.h>
#include <sys/lock.h>
#include <sys/conf.h>
d36 1
@


1.16
log
@Suspend/resume for agp_amd.c

Note: the unconditional restore of the status register is ok because all
of the bits are either ones we want to preserve or read-only.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.15 2010/04/08 00:23:53 tedu Exp $	*/
a38 1
#include <sys/agpio.h>
@


1.15
log
@these files don't need to include proc.h anymore.  ok oga for agp
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.14 2010/03/28 13:22:07 oga Exp $	*/
d76 3
d82 3
d94 2
a95 1
	sizeof(struct agp_amd_softc), agp_amd_probe, agp_amd_attach
d278 46
@


1.14
log
@Don't assign the same value to gatt->ag_size twice, also use ag_size in
a later calculation instead of doing it *again*

pointed out by miod quite some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.13 2009/05/10 16:57:44 oga Exp $	*/
a36 1
#include <sys/proc.h>
@


1.13
log
@Change agp attach (again) so that the driver passes in the aperture size.

While the aperture size may change during attach, it never changes after
the end of the subdriver attach function, so getting this value with a
function is a waste of time. shrinks things slightly and makes the code
clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.12 2009/05/10 15:28:45 oga Exp $	*/
a135 1
	gatt->ag_size = AGP_PAGE_SIZE + entries * sizeof(u_int32_t);
d140 1
a140 2
	npages = ((entries * sizeof(u_int32_t) + AGP_PAGE_SIZE - 1)
	    >> AGP_PAGE_SHIFT);
@


1.12
log
@In preparation for using agp as a bus_dma backend for drm, convert the bind_page
and unbind_page callbacks from

int bind_page(void *, off_t, bus_addr_t)

to

void bind_page(void *, bus_addr_t, paddr_t, int)

We can make these function void by making sure that the agp code sanity
checks properly (it already mostly did), so by definition these
functions may not fail.  The flags field is currently unused (intagp at
least will have a use for it soon).

Been in my tree for ages.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.11 2009/05/10 14:44:42 oga Exp $	*/
d76 1
a76 1
	bus_size_t		 initial_aperture;
a96 1
	agp_amd_get_aperture,
d208 1
a208 1
	asc->initial_aperture = agp_amd_get_aperture(asc);
d211 1
a211 2
		bus_size_t size = agp_amd_get_aperture(asc);
		gatt = agp_amd_alloc_gatt(pa->pa_dmat, size);
d219 2
a220 1
		if (agp_amd_set_aperture(asc, size / 2)) {
d241 1
a241 1
	    asc->asc_apaddr, &asc->dev);
@


1.11
log
@change agp driver attach so that the driver passes in the base address
of its aperture, instead of the BAR and memory type. This is a little
larger, but allows the driver to know it's aperture address. Needed for
some future stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.10 2009/04/20 01:28:45 oga Exp $	*/
d84 2
a85 2
int	agp_amd_bind_page(void *, off_t, bus_addr_t);
int	agp_amd_unbind_page(void *, off_t);
d316 2
a317 2
int
agp_amd_bind_page(void *sc, off_t offset, bus_addr_t physical)
d321 2
a322 5
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = physical | 1;
	return (0);
d325 2
a326 2
int
agp_amd_unbind_page(void *sc, off_t offset)
d330 1
a330 5
	if (offset < 0 || offset >= (asc->gatt->ag_entries << AGP_PAGE_SHIFT))
		return (EINVAL);

	asc->gatt->ag_virtual[offset >> AGP_PAGE_SHIFT] = 0;
	return (0);
@


1.10
log
@Don't map all agp memory we allocate.

If we're just going to be making it available to userland (the X
server), just use load_raw and make sure it's zeroed with BUS_DMA_ZERO.
Should save $AMOUNT_BOUND_TO_GART kva. Most kernel users also write
through the gart, so no mapping there either.

tested by sthen and todd a while back.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.9 2008/11/09 15:11:19 oga Exp $	*/
d75 1
d196 6
d242 1
a242 1
	    AGP_APBASE, PCI_MAPREG_TYPE_MEM, &asc->dev);
@


1.9
log
@Rework that way that agp attaches.

previously, we had a static list of pcidevs and which agp driver would
be interanlly attached. Instead, split the agp drivers so they work like
audio(4), where we attach a driver, which sets up some callbacks and
initial state, then attaches the interface (agp(4)). Since this allows
us to attach different drivers in different places, and give them
/proper/ probe functions move most of the drivers back to attaching at
pchb, where they should, and intagp (formerly agp_i810) stays attaching
at vga, since it's part of the intel integrated graphics chips.

Diff shrinks the kernel slightly, gets rid of the annoying "no integrated
graphics" warning, and allows more cleanup later.

Tested by many. fix for alpha build (the only other vga_pci.c consumer)
suggested by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.8 2007/12/07 17:35:22 oga Exp $	*/
d114 1
d116 2
a117 4
	if (agp_alloc_dmamem(dmat,
	    AGP_PAGE_SIZE + entries * sizeof(u_int32_t), 0,
	    &gatt->ag_dmamap, &vdir, &gatt->ag_pdir,
	    &gatt->ag_dmaseg, 1, &gatt->ag_nseg) != 0) {
d123 9
a137 3
	memset(gatt->ag_vdir, 0, AGP_PAGE_SIZE);
	memset(gatt->ag_virtual, 0, entries * sizeof(u_int32_t));

d159 1
@


1.8
log
@KNF, no binary change.

Looked over by a few people.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.7 2007/12/06 22:49:39 oga Exp $	*/
a31 2


d68 8
a75 4
	u_int32_t	initial_aperture; /* aperture size at startup */
	struct agp_amd_gatt *gatt;
	bus_space_handle_t ioh;
	bus_space_tag_t iot;
d78 12
a89 6
u_int32_t agp_amd_get_aperture(struct agp_softc *);
struct agp_amd_gatt * agp_amd_alloc_gatt(struct agp_softc *);
int	agp_amd_set_aperture(struct agp_softc *, u_int32_t);
int	agp_amd_bind_page(struct agp_softc *, off_t, bus_addr_t);
int	agp_amd_unbind_page(struct agp_softc *, off_t);
void	agp_amd_flush_tlb(struct agp_softc *);
d91 3
d95 1
a95 1
struct agp_methods agp_amd_methods = {
a96 1
	agp_amd_set_aperture,
a99 5
	agp_generic_enable,
	agp_generic_alloc_memory,
	agp_generic_free_memory,
	agp_generic_bind_memory,
	agp_generic_unbind_memory,
d104 1
a104 1
agp_amd_alloc_gatt(struct agp_softc *sc)
d106 1
a106 2
	u_int32_t apsize = AGP_GET_APERTURE(sc);
	u_int32_t entries = apsize >> AGP_PAGE_SHIFT;
d115 1
a115 1
	if (agp_alloc_dmamem(sc->sc_dmat,
d152 1
a152 1
agp_amd_free_gatt(struct agp_softc *sc, struct agp_amd_gatt *gatt)
d154 1
a154 1
	agp_free_dmamem(sc->sc_dmat, gatt->ag_size,
d162 16
a177 1
agp_amd_attach(struct agp_softc *sc, struct pci_attach_args *pa)
d179 6
a184 4
	struct agp_amd_softc *asc;
	struct agp_amd_gatt *gatt;
	pcireg_t reg;
	int error;
d186 2
a187 6
	asc = malloc(sizeof *asc, M_AGP, M_NOWAIT | M_ZERO);
	if (asc == NULL) {
		printf("can't allocate softc\n");
		/* agp_generic_detach(sc) */
		return (ENOMEM);
	}
d193 1
a193 2
		agp_generic_detach(sc);
		return (error);
d196 1
a196 9
	if (agp_map_aperture(pa, sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
		printf("can't map aperture\n");
		agp_generic_detach(sc);
		free(asc, M_AGP);
		return (ENXIO);
	}
	sc->sc_methods = &agp_amd_methods;
	sc->sc_chipc = asc;
	asc->initial_aperture = AGP_GET_APERTURE(sc);
d199 3
a201 2
		gatt = agp_amd_alloc_gatt(sc);
		if (gatt)
d205 2
a206 2
		 * Probably contigmalloc failure. Try reducing the
		 * aperture so that the gatt size reduces.
d208 3
a210 3
		if (AGP_SET_APERTURE(sc, AGP_GET_APERTURE(sc) / 2)) {
			printf(": can't set aperture\n");
			return (ENOMEM);
d219 1
a219 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_MODECTRL);
d222 1
a222 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_MODECTRL, reg);
d226 1
a226 1
	AGP_FLUSH_TLB(sc);
d228 3
a230 1
	return (0);
d235 1
a235 1
agp_amd_detach(struct agp_softc *sc)
d237 2
a238 2
	pcireg_t reg;
	struct agp_amd_softc *asc = sc->sc_chipc;
d245 1
a245 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_MODECTRL);
d247 1
a247 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_MODECTRL, reg);
d253 1
a253 1
	AGP_SET_APERTURE(sc, asc->initial_aperture);
d255 1
a255 1
	agp_amd_free_gatt(sc, asc->gatt);
d263 2
a264 2
u_int32_t
agp_amd_get_aperture(struct agp_softc *sc)
d266 2
a267 1
	int vas;
d269 1
a269 1
	vas = (pci_conf_read(sc->sc_pc, sc->sc_pcitag,
d279 1
a279 1
agp_amd_set_aperture(struct agp_softc *sc, u_int32_t aperture)
d281 3
a283 2
	int vas;
	pcireg_t reg;
d296 1
a296 1
	reg = pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_APCTRL);
d298 1
a298 1
	pci_conf_write(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_APCTRL, reg);
d304 1
a304 1
agp_amd_bind_page(struct agp_softc *sc, off_t offset, bus_addr_t physical)
d306 1
a306 1
	struct agp_amd_softc *asc = sc->sc_chipc;
d316 1
a316 1
agp_amd_unbind_page(struct agp_softc *sc, off_t offset)
d318 1
a318 1
	struct agp_amd_softc *asc = sc->sc_chipc;
d328 1
a328 1
agp_amd_flush_tlb(struct agp_softc *sc)
d330 1
a330 1
	struct agp_amd_softc *asc = sc->sc_chipc;
@


1.7
log
@Destatic functions in the agp subsystem.

KNF coming shortly.

ok marco, jsg and mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.6 2007/11/26 15:35:15 deraadt Exp $	*/
a3 1

d78 4
a81 4
int agp_amd_set_aperture(struct agp_softc *, u_int32_t);
int agp_amd_bind_page(struct agp_softc *, off_t, bus_addr_t);
int agp_amd_unbind_page(struct agp_softc *, off_t);
void agp_amd_flush_tlb(struct agp_softc *);
d133 1
a133 1
		  >> AGP_PAGE_SHIFT);
@


1.6
log
@correct newlines surrounding the sub-bus configuration, and unify
pchb's further
ok reyk oga
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.5 2007/11/25 17:11:12 oga Exp $	*/
d77 6
a82 5
static u_int32_t agp_amd_get_aperture(struct agp_softc *);
static int agp_amd_set_aperture(struct agp_softc *, u_int32_t);
static int agp_amd_bind_page(struct agp_softc *, off_t, bus_addr_t);
static int agp_amd_unbind_page(struct agp_softc *, off_t);
static void agp_amd_flush_tlb(struct agp_softc *);
d99 1
a99 1
static struct agp_amd_gatt *
d148 1
a148 1
static void
d224 1
a224 1
static int
d253 1
a253 1
static u_int32_t
d267 1
a267 1
static int
d291 1
a291 1
static int
d303 1
a303 1
static int
d315 1
a315 1
static void
@


1.5
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.4 2007/10/06 23:50:54 krw Exp $	*/
d167 1
a167 1
		printf(": can't allocate softc\n");
d175 1
a175 1
		printf(": can't map AGP registers\n");
d181 1
a181 1
		printf(": can't map aperture\n");
@


1.4
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.3 2007/08/04 19:40:25 reyk Exp $	*/
d77 5
a81 5
static u_int32_t agp_amd_get_aperture(struct vga_pci_softc *);
static int agp_amd_set_aperture(struct vga_pci_softc *, u_int32_t);
static int agp_amd_bind_page(struct vga_pci_softc *, off_t, bus_addr_t);
static int agp_amd_unbind_page(struct vga_pci_softc *, off_t);
static void agp_amd_flush_tlb(struct vga_pci_softc *);
d99 1
a99 1
agp_amd_alloc_gatt(struct vga_pci_softc *sc)
d107 1
a107 1
	gatt = malloc(sizeof(struct agp_amd_gatt), M_DEVBUF, M_NOWAIT);
d116 1
a116 1
		free(gatt, M_DEVBUF);
d148 1
a148 1
agp_amd_free_gatt(struct vga_pci_softc *sc, struct agp_amd_gatt *gatt)
d153 1
a153 1
	free(gatt, M_DEVBUF);
d158 1
a158 1
agp_amd_attach(struct vga_pci_softc *sc, struct pci_attach_args *pa, struct pci_attach_args *pchb_pa)
d165 1
a165 1
	asc = malloc(sizeof *asc, M_DEVBUF, M_NOWAIT | M_ZERO);
d172 2
a173 2
	error = pci_mapreg_map(pchb_pa, AGP_AMD751_REGISTERS,
	     PCI_MAPREG_TYPE_MEM,0, &asc->iot, &asc->ioh, NULL, NULL, 0);
d180 1
a180 1
	if (agp_map_aperture(sc, AGP_APBASE, PCI_MAPREG_TYPE_MEM) != 0) {
d183 1
a183 1
		free(asc, M_DEVBUF);
d224 1
a224 1
agp_amd_detach(struct vga_pci_softc *sc)
d253 1
a253 1
agp_amd_get_aperture(struct vga_pci_softc *sc)
d267 1
a267 1
agp_amd_set_aperture(struct vga_pci_softc *sc, u_int32_t aperture)
d291 1
a291 1
agp_amd_bind_page(struct vga_pci_softc *sc, off_t offset, bus_addr_t physical)
d303 1
a303 1
agp_amd_unbind_page(struct vga_pci_softc *sc, off_t offset)
d315 1
a315 1
agp_amd_flush_tlb(struct vga_pci_softc *sc)
@


1.3
log
@Add AGP support for the intel i965 chipset, this also extends the
internal AGP API to work with 64bit PCI-Express memory and
non-standard AGP aperture bases.

tested by many
ok matthieu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.2 2002/07/25 23:31:04 fgsch Exp $	*/
d165 1
a165 1
	asc = malloc(sizeof *asc, M_DEVBUF, M_NOWAIT);
a170 1
	memset(asc, 0, sizeof *asc);
@


1.2
log
@- some KNF.
- comment out debugging printf for i810.
- remove checks for failure if malloc is used with M_WAITOK.

mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: agp_amd.c,v 1.1 2002/07/12 20:17:03 mickey Exp $	*/
d181 1
a181 1
	if (agp_map_aperture(sc) != 0) {
@


1.2.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1
log
@support for the agp gart on various agp chipsets.
only i810 driver was tested though.
based on the netbsd's lkm, initially ported
by hunter@@dg.net.ua and later made into shape by mickey.
testing by art@@ and millert@@ .
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
		return 0;
d117 1
a117 1
		return NULL;
d143 1
a143 1
	return gatt;
d169 1
a169 1
		return ENOMEM;
d178 1
a178 1
		return error;
d185 1
a185 1
		return ENXIO;
d202 1
a202 1
			return ENOMEM;
d217 1
a217 1
	       READ2(AGP_AMD751_STATUS) | AGP_AMD751_STATUS_GCE);
d220 1
a220 1
	return 0;
d232 1
a232 1
	       READ2(AGP_AMD751_STATUS) & ~AGP_AMD751_STATUS_GCE);
d249 1
a249 1
	return 0;
d258 2
a259 1
	vas = (pci_conf_read(sc->sc_pc, sc->sc_pcitag, AGP_AMD751_APCTRL) & 0x06);
d264 1
a264 1
	return (32*1024*1024) << vas;
d280 1
a280 1
		return EINVAL;
d288 1
a288 1
	return 0;
d297 1
a297 1
		return EINVAL;
d300 1
a300 1
	return 0;
d309 1
a309 1
		return EINVAL;
d312 1
a312 1
	return 0;
a325 2


@

