head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.37.0.4
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.34.0.4
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.6
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.8
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.6
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.23.0.4
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.16.0.2
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.6.0.2
	OPENBSD_4_3_BASE:1.6;
locks; strict;
comment	@ * @;


1.44
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.43;
commitid	VyLWTsbepAOk7VQM;

1.43
date	2016.04.13.10.34.32;	author mpi;	state Exp;
branches;
next	1.42;
commitid	8YSL8ByWzGeIGBiJ;

1.42
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.41;
commitid	B0kwmVGiD5DVx4kv;

1.41
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.40;
commitid	5gdEnqVoJuTuwdTu;

1.40
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.39;
commitid	5DvsamK0GblTp8ww;

1.39
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.38;
commitid	eYnPulzvLjDImPCa;

1.38
date	2015.10.25.13.04.28;	author mpi;	state Exp;
branches;
next	1.37;
commitid	hPF95ClMUQfeqQDX;

1.37
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.36;
commitid	MVWrtktB46JRxFWT;

1.36
date	2015.04.11.14.40.42;	author jsing;	state Exp;
branches;
next	1.35;
commitid	lBL4R9IkbhsbyCWB;

1.35
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.33;
commitid	yM2VFFhpDTeFQlve;

1.33
date	2014.08.30.09.52.13;	author brad;	state Exp;
branches;
next	1.32;
commitid	FlNrWG2cdG2Q63hw;

1.32
date	2013.12.28.03.34.54;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.19.00.15.41;	author sthen;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.26.22.21.59;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.02.08.12.28.42;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2010.02.03.14.08.41;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.24.02.29.11;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.12.15.16.07;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.07.16.03.37;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2008.09.01.14.38.31;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.17.13.50.49;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.30.11.20.28;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.10.04.30.17;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.20.18.21.56;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.15.04.37.59;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.13.13.20.44;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.03.16.39.54;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.30.14.17.48;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.30.14.09.56;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2008.03.30.14.08.46;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.05.07.51.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.05.03.49.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.04.01.47.55;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.04.01.43.09;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.31.15.18.06;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.31.14.51.19;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.44
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_lii.c,v 1.43 2016/04/13 10:34:32 mpi Exp $	*/

/*
 *  Copyright (c) 2007 The NetBSD Foundation.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 *  ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for Attansic/Atheros's L2 Fast Ethernet controller
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <dev/pci/if_liireg.h>

/*#define LII_DEBUG*/
#ifdef LII_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

struct lii_softc {
	struct device		sc_dev;
	pci_chipset_tag_t	sc_pc;
	pcitag_t		sc_tag;

	bus_space_tag_t		sc_mmiot;
	bus_space_handle_t	sc_mmioh;
	bus_size_t		sc_mmios;

	/*
	 * We allocate a big chunk of DMA-safe memory for all data exchanges.
	 * It is unfortunate that this chip doesn't seem to do scatter-gather.
	 */
	bus_dma_tag_t		sc_dmat;
	bus_dmamap_t		sc_ringmap;
	bus_dma_segment_t	sc_ringseg;

	uint8_t			*sc_ring; /* the whole area */
	size_t			sc_ringsize;

	struct rx_pkt		*sc_rxp; /* the part used for RX */
	struct tx_pkt_status	*sc_txs; /* the parts used for TX */
	bus_addr_t		sc_txsp;
	char			*sc_txdbase;
	bus_addr_t		sc_txdp;

	unsigned int		sc_rxcur;
	/* the active area is [ack; cur[ */
	int			sc_txs_cur;
	int			sc_txs_ack;
	int			sc_txd_cur;
	int			sc_txd_ack;
	int			sc_free_tx_slots;

	void			*sc_ih;

	struct arpcom		sc_ac;
	struct mii_data		sc_mii;
	struct timeout		sc_tick;

	int			(*sc_memread)(struct lii_softc *, uint32_t,
				     uint32_t *);
};

#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)

int	lii_match(struct device *, void *, void *);
void	lii_attach(struct device *, struct device *, void *);
int	lii_activate(struct device *, int);

struct cfdriver lii_cd = {
	0,
	"lii",
	DV_IFNET
};

struct cfattach lii_ca = {
	sizeof(struct lii_softc),
	lii_match,
	lii_attach,
	NULL,
	lii_activate
};

int	lii_reset(struct lii_softc *);
int	lii_eeprom_present(struct lii_softc *);
void	lii_read_macaddr(struct lii_softc *, uint8_t *);
int	lii_eeprom_read(struct lii_softc *, uint32_t, uint32_t *);
void	lii_spi_configure(struct lii_softc *);
int	lii_spi_read(struct lii_softc *, uint32_t, uint32_t *);
void	lii_iff(struct lii_softc *);
void	lii_tick(void *);

int	lii_alloc_rings(struct lii_softc *);
int	lii_free_tx_space(struct lii_softc *);
void	lii_tx_put(struct lii_softc *, struct mbuf *);

int	lii_mii_readreg(struct device *, int, int);
void	lii_mii_writereg(struct device *, int, int, int);
void	lii_mii_statchg(struct device *);

int	lii_media_change(struct ifnet *);
void	lii_media_status(struct ifnet *, struct ifmediareq *);

int	lii_init(struct ifnet *);
void	lii_start(struct ifnet *);
void	lii_stop(struct ifnet *);
void	lii_watchdog(struct ifnet *);
int	lii_ioctl(struct ifnet *, u_long, caddr_t);

int	lii_intr(void *);
void	lii_rxintr(struct lii_softc *);
void	lii_txintr(struct lii_softc *);

const struct pci_matchid lii_devices[] = {
	{ PCI_VENDOR_ATTANSIC, PCI_PRODUCT_ATTANSIC_L2 }
};

#define LII_READ_4(sc,reg) \
    bus_space_read_4((sc)->sc_mmiot, (sc)->sc_mmioh, (reg))
#define LII_READ_2(sc,reg) \
    bus_space_read_2((sc)->sc_mmiot, (sc)->sc_mmioh, (reg))
#define LII_READ_1(sc,reg) \
    bus_space_read_1((sc)->sc_mmiot, (sc)->sc_mmioh, (reg))
#define LII_WRITE_4(sc,reg,val) \
    bus_space_write_4((sc)->sc_mmiot, (sc)->sc_mmioh, (reg), (val))
#define LII_WRITE_2(sc,reg,val) \
    bus_space_write_2((sc)->sc_mmiot, (sc)->sc_mmioh, (reg), (val))
#define LII_WRITE_1(sc,reg,val) \
    bus_space_write_1((sc)->sc_mmiot, (sc)->sc_mmioh, (reg), (val))

/*
 * Those are the default Linux parameters.
 */

#define AT_TXD_NUM		64
#define AT_TXD_BUFFER_SIZE	8192
#define AT_RXD_NUM		64

/* Pad the RXD buffer so that the packets are on a 128-byte boundary. */
#define AT_RXD_PADDING		120

int
lii_match(struct device *parent, void *match, void *aux)
{
	return (pci_matchbyid((struct pci_attach_args *)aux, lii_devices,   
	    nitems(lii_devices)));
}

void
lii_attach(struct device *parent, struct device *self, void *aux)
{
	struct lii_softc *sc = (struct lii_softc *)self;
	struct pci_attach_args *pa = aux;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	pci_intr_handle_t ih;
	pcireg_t memtype;

	sc->sc_pc = pa->pa_pc;
	sc->sc_tag = pa->pa_tag;
	sc->sc_dmat = pa->pa_dmat;

	memtype = pci_mapreg_type(sc->sc_pc, sc->sc_tag, PCI_MAPREG_START);
	if (pci_mapreg_map(pa, PCI_MAPREG_START, memtype, 0,  &sc->sc_mmiot, 
	    &sc->sc_mmioh, NULL, &sc->sc_mmios, 0)) {
		printf(": can't map mem space\n");
		return;
	}

	if (lii_reset(sc))
		goto unmap;

	lii_spi_configure(sc);

	if (lii_eeprom_present(sc))
		sc->sc_memread = lii_eeprom_read;
	else
		sc->sc_memread = lii_spi_read;

	lii_read_macaddr(sc, sc->sc_ac.ac_enaddr);

	if (pci_intr_map(pa, &ih) != 0) {
		printf(": can't map interrupt\n");
		goto unmap;
	}
	sc->sc_ih = pci_intr_establish(sc->sc_pc, ih, IPL_NET,
	    lii_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": can't establish interrupt\n");
		goto unmap;
	}

	if (lii_alloc_rings(sc))
		goto deintr;

	printf(": %s, address %s\n", pci_intr_string(sc->sc_pc, ih),
	    ether_sprintf(sc->sc_ac.ac_enaddr));

	timeout_set(&sc->sc_tick, lii_tick, sc);

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = lii_mii_readreg;
	sc->sc_mii.mii_writereg = lii_mii_writereg;
	sc->sc_mii.mii_statchg = lii_mii_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, lii_media_change,
	    lii_media_status);
	mii_attach(self, &sc->sc_mii, 0xffffffff, 1,
	    MII_OFFSET_ANY, 0);
	ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	strlcpy(ifp->if_xname, DEVNAME(sc), IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_capabilities = IFCAP_VLAN_MTU;
	ifp->if_ioctl = lii_ioctl;
	ifp->if_start = lii_start;
	ifp->if_watchdog = lii_watchdog;

	if_attach(ifp);
	ether_ifattach(ifp);

	return;

deintr:
	pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
unmap:
	bus_space_unmap(sc->sc_mmiot, sc->sc_mmioh, sc->sc_mmios);
	return;
}

int
lii_activate(struct device *self, int act)
{
	struct lii_softc *sc = (struct lii_softc *)self;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			lii_stop(ifp);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			lii_init(ifp);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
lii_reset(struct lii_softc *sc)
{
	int i;

	DPRINTF(("lii_reset\n"));

	LII_WRITE_4(sc, LII_SMC, SMC_SOFT_RST);
	DELAY(1000);

	for (i = 0; i < 10; ++i) {
		if (LII_READ_4(sc, LII_BIS) == 0)
			break;
		DELAY(1000);
	}

	if (i == 10) {
		printf("%s: reset failed\n", DEVNAME(sc));
		return 1;
	}

	LII_WRITE_4(sc, LII_PHYC, PHYC_ENABLE);
	DELAY(10);

	/* Init PCI-Express module */
	/* Magic Numbers Warning */
	LII_WRITE_4(sc, 0x12fc, 0x00006500);
	LII_WRITE_4(sc, 0x1008, 0x00008000 |
	    LII_READ_4(sc, 0x1008));

	return 0;
}

int
lii_eeprom_present(struct lii_softc *sc)
{
	uint32_t val;

	val = LII_READ_4(sc, LII_SFC);
	if (val & SFC_EN_VPD)
		LII_WRITE_4(sc, LII_SFC, val & ~(SFC_EN_VPD));

	return pci_get_capability(sc->sc_pc, sc->sc_tag, PCI_CAP_VPD,
	    NULL, NULL) == 1;
}

int
lii_eeprom_read(struct lii_softc *sc, uint32_t reg, uint32_t *val)
{
	return pci_vpd_read(sc->sc_pc, sc->sc_tag, reg, 1, (pcireg_t *)val);
}

void
lii_spi_configure(struct lii_softc *sc)
{
	/*
	 * We don't offer a way to configure the SPI Flash vendor parameter, so
	 * the table is given for reference
	 */
	static const struct lii_spi_flash_vendor {
	    const char *sfv_name;
	    const uint8_t sfv_opcodes[9];
	} lii_sfv[] = {
	    { "Atmel", { 0x00, 0x03, 0x02, 0x06, 0x04, 0x05, 0x15, 0x52, 0x62 } },
	    { "SST",   { 0x01, 0x03, 0x02, 0x06, 0x04, 0x05, 0x90, 0x20, 0x60 } },
	    { "ST",    { 0x01, 0x03, 0x02, 0x06, 0x04, 0x05, 0xab, 0xd8, 0xc7 } },
	};
#define SF_OPCODE_WRSR	0
#define SF_OPCODE_READ	1
#define SF_OPCODE_PRGM	2
#define SF_OPCODE_WREN	3
#define SF_OPCODE_WRDI	4
#define SF_OPCODE_RDSR	5
#define SF_OPCODE_RDID	6
#define SF_OPCODE_SECT_ER	7
#define SF_OPCODE_CHIP_ER	8

#define SF_DEFAULT_VENDOR	0
	static const uint8_t vendor = SF_DEFAULT_VENDOR;

	/*
	 * Why isn't WRDI used?  Heck if I know.
	 */

	LII_WRITE_1(sc, LII_SFOP_WRSR,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_WRSR]);
	LII_WRITE_1(sc, LII_SFOP_READ,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_READ]);
	LII_WRITE_1(sc, LII_SFOP_PROGRAM,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_PRGM]);
	LII_WRITE_1(sc, LII_SFOP_WREN,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_WREN]);
	LII_WRITE_1(sc, LII_SFOP_RDSR,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_RDSR]);
	LII_WRITE_1(sc, LII_SFOP_RDID,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_RDID]);
	LII_WRITE_1(sc, LII_SFOP_SC_ERASE,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_SECT_ER]);
	LII_WRITE_1(sc, LII_SFOP_CHIP_ERASE,
	    lii_sfv[vendor].sfv_opcodes[SF_OPCODE_CHIP_ER]);
}

#define MAKE_SFC(cssetup, clkhi, clklo, cshold, cshi, ins) \
    ( (((cssetup) & SFC_CS_SETUP_MASK)	\
        << SFC_CS_SETUP_SHIFT)		\
    | (((clkhi) & SFC_CLK_HI_MASK)	\
        << SFC_CLK_HI_SHIFT)		\
    | (((clklo) & SFC_CLK_LO_MASK)	\
        << SFC_CLK_LO_SHIFT)		\
    | (((cshold) & SFC_CS_HOLD_MASK)	\
        << SFC_CS_HOLD_SHIFT)		\
    | (((cshi) & SFC_CS_HI_MASK)	\
        << SFC_CS_HI_SHIFT)		\
    | (((ins) & SFC_INS_MASK)		\
        << SFC_INS_SHIFT))

#define CUSTOM_SPI_CS_SETUP	2
#define CUSTOM_SPI_CLK_HI	2
#define CUSTOM_SPI_CLK_LO	2
#define CUSTOM_SPI_CS_HOLD	2
#define CUSTOM_SPI_CS_HI	3

int
lii_spi_read(struct lii_softc *sc, uint32_t reg, uint32_t *val)
{
	uint32_t v;
	int i;

	LII_WRITE_4(sc, LII_SF_DATA, 0);
	LII_WRITE_4(sc, LII_SF_ADDR, reg);

	v = SFC_WAIT_READY |
	    MAKE_SFC(CUSTOM_SPI_CS_SETUP, CUSTOM_SPI_CLK_HI,
	         CUSTOM_SPI_CLK_LO, CUSTOM_SPI_CS_HOLD, CUSTOM_SPI_CS_HI, 1);

	LII_WRITE_4(sc, LII_SFC, v);
	v |= SFC_START;
	LII_WRITE_4(sc, LII_SFC, v);

	for (i = 0; i < 10; ++i) {
		DELAY(1000);
		if (!(LII_READ_4(sc, LII_SFC) & SFC_START))
			break;
	}
	if (i == 10)
		return EBUSY;

	*val = LII_READ_4(sc, LII_SF_DATA);
	return 0;
}

void
lii_read_macaddr(struct lii_softc *sc, uint8_t *ea)
{
	uint32_t offset = 0x100;
	uint32_t val, val1, addr0 = 0, addr1 = 0;
	uint8_t found = 0;

	while ((*sc->sc_memread)(sc, offset, &val) == 0) {
		offset += 4;

		/* Each chunk of data starts with a signature */
		if ((val & 0xff) != 0x5a)
			break;
		if ((*sc->sc_memread)(sc, offset, &val1))
			break;

		offset += 4;

		val >>= 16;
		switch (val) {
		case LII_MAC_ADDR_0:
			addr0 = val1;
			++found;
			break;
		case LII_MAC_ADDR_1:
			addr1 = val1;
			++found;
			break;
		default:
			continue;
		}
	}

#ifdef LII_DEBUG
	if (found < 2)
		printf(": error reading MAC address, using registers...\n");
#endif

	addr0 = htole32(addr0);
	addr1 = htole32(addr1);

	if ((addr0 == 0xffffff && (addr1 & 0xffff) == 0xffff) ||
	    (addr0 == 0 && (addr1 & 0xffff) == 0)) {
		addr0 = htole32(LII_READ_4(sc, LII_MAC_ADDR_0));
		addr1 = htole32(LII_READ_4(sc, LII_MAC_ADDR_1));
	}

	ea[0] = (addr1 & 0x0000ff00) >> 8;
	ea[1] = (addr1 & 0x000000ff);
	ea[2] = (addr0 & 0xff000000) >> 24;
	ea[3] = (addr0 & 0x00ff0000) >> 16;
	ea[4] = (addr0 & 0x0000ff00) >> 8;
	ea[5] = (addr0 & 0x000000ff);
}

int
lii_mii_readreg(struct device *dev, int phy, int reg)
{
	struct lii_softc *sc = (struct lii_softc *)dev;
	uint32_t val;
	int i;

	val = (reg & MDIOC_REG_MASK) << MDIOC_REG_SHIFT;

	val |= MDIOC_START | MDIOC_SUP_PREAMBLE;
	val |= MDIOC_CLK_25_4 << MDIOC_CLK_SEL_SHIFT;

	val |= MDIOC_READ;

	LII_WRITE_4(sc, LII_MDIOC, val);

	for (i = 0; i < MDIO_WAIT_TIMES; ++i) {
		DELAY(2);
		val = LII_READ_4(sc, LII_MDIOC);
		if ((val & (MDIOC_START | MDIOC_BUSY)) == 0)
			break;
	}

	if (i == MDIO_WAIT_TIMES) {
		printf("%s: timeout reading PHY %d reg %d\n", DEVNAME(sc), phy,
		    reg);
	}

	return (val & 0x0000ffff);
}

void
lii_mii_writereg(struct device *dev, int phy, int reg, int data)
{
	struct lii_softc *sc = (struct lii_softc *)dev;
	uint32_t val;
	int i;

	val = (reg & MDIOC_REG_MASK) << MDIOC_REG_SHIFT;
	val |= (data & MDIOC_DATA_MASK) << MDIOC_DATA_SHIFT;

	val |= MDIOC_START | MDIOC_SUP_PREAMBLE;
	val |= MDIOC_CLK_25_4 << MDIOC_CLK_SEL_SHIFT;

	/* val |= MDIOC_WRITE; */

	LII_WRITE_4(sc, LII_MDIOC, val);

	for (i = 0; i < MDIO_WAIT_TIMES; ++i) {
		DELAY(2);
		val = LII_READ_4(sc, LII_MDIOC);
		if ((val & (MDIOC_START | MDIOC_BUSY)) == 0)
			break;
	}

	if (i == MDIO_WAIT_TIMES) {
		printf("%s: timeout writing PHY %d reg %d\n", DEVNAME(sc), phy,
		    reg);
	}
}

void
lii_mii_statchg(struct device *dev)
{
	struct lii_softc *sc = (struct lii_softc *)dev;
	uint32_t val;

	DPRINTF(("lii_mii_statchg\n"));

	val = LII_READ_4(sc, LII_MACC);

	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)
		val |= MACC_FDX;
	else
		val &= ~MACC_FDX;

	LII_WRITE_4(sc, LII_MACC, val);
}

int
lii_media_change(struct ifnet *ifp)
{
	struct lii_softc *sc = ifp->if_softc;

	DPRINTF(("lii_media_change\n"));

	if (ifp->if_flags & IFF_UP)
		mii_mediachg(&sc->sc_mii);
	return 0;
}

void
lii_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct lii_softc *sc = ifp->if_softc;

	DPRINTF(("lii_media_status\n"));

	mii_pollstat(&sc->sc_mii);
	imr->ifm_status = sc->sc_mii.mii_media_status;
	imr->ifm_active = sc->sc_mii.mii_media_active;
}

int
lii_init(struct ifnet *ifp)
{
	struct lii_softc *sc = ifp->if_softc;
	uint32_t val;
	int error;

	DPRINTF(("lii_init\n"));

	lii_stop(ifp);

	memset(sc->sc_ring, 0, sc->sc_ringsize);

	/* Disable all interrupts */
	LII_WRITE_4(sc, LII_ISR, 0xffffffff);

	LII_WRITE_4(sc, LII_DESC_BASE_ADDR_HI, 0);
/* XXX
	    sc->sc_ringmap->dm_segs[0].ds_addr >> 32);
*/
	LII_WRITE_4(sc, LII_RXD_BASE_ADDR_LO,
	    (sc->sc_ringmap->dm_segs[0].ds_addr & 0xffffffff)
	    + AT_RXD_PADDING);
	LII_WRITE_4(sc, LII_TXS_BASE_ADDR_LO,
	    sc->sc_txsp & 0xffffffff);
	LII_WRITE_4(sc, LII_TXD_BASE_ADDR_LO,
	    sc->sc_txdp & 0xffffffff);

	LII_WRITE_2(sc, LII_TXD_BUFFER_SIZE, AT_TXD_BUFFER_SIZE / 4);
	LII_WRITE_2(sc, LII_TXS_NUM_ENTRIES, AT_TXD_NUM);
	LII_WRITE_2(sc, LII_RXD_NUM_ENTRIES, AT_RXD_NUM);

	/*
	 * Inter Paket Gap Time = 0x60 (IPGT)
	 * Minimum inter-frame gap for RX = 0x50 (MIFG)
	 * 64-bit Carrier-Sense window = 0x40 (IPGR1)
	 * 96-bit IPG window = 0x60 (IPGR2)
	 */
	LII_WRITE_4(sc, LII_MIPFG, 0x60405060);

	/*
	 * Collision window = 0x37 (LCOL)
	 * Maximum # of retrans = 0xf (RETRY)
	 * Maximum binary expansion # = 0xa (ABEBT)
	 * IPG to start jam = 0x7 (JAMIPG)
	*/
	LII_WRITE_4(sc, LII_MHDC, 0x07a0f037 |
	     MHDC_EXC_DEF_EN);

	/* 100 means 200us */
	LII_WRITE_2(sc, LII_IMTIV, 100);
	LII_WRITE_2(sc, LII_SMC, SMC_ITIMER_EN);

	/* 500000 means 100ms */
	LII_WRITE_2(sc, LII_IALTIV, 50000);

	LII_WRITE_4(sc, LII_MTU, ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN);

	/* unit unknown for TX cur-through threshold */
	LII_WRITE_4(sc, LII_TX_CUT_THRESH, 0x177);

	LII_WRITE_2(sc, LII_PAUSE_ON_TH, AT_RXD_NUM * 7 / 8);
	LII_WRITE_2(sc, LII_PAUSE_OFF_TH, AT_RXD_NUM / 12);

	sc->sc_rxcur = 0;
	sc->sc_txs_cur = sc->sc_txs_ack = 0;
	sc->sc_txd_cur = sc->sc_txd_ack = 0;
	sc->sc_free_tx_slots = 1;
	LII_WRITE_2(sc, LII_MB_TXD_WR_IDX, sc->sc_txd_cur);
	LII_WRITE_2(sc, LII_MB_RXD_RD_IDX, sc->sc_rxcur);

	LII_WRITE_1(sc, LII_DMAR, DMAR_EN);
	LII_WRITE_1(sc, LII_DMAW, DMAW_EN);

	LII_WRITE_4(sc, LII_SMC, LII_READ_4(sc, LII_SMC) | SMC_MANUAL_INT);

	error = ((LII_READ_4(sc, LII_ISR) & ISR_PHY_LINKDOWN) != 0);
	LII_WRITE_4(sc, LII_ISR, 0x3fffffff);
	LII_WRITE_4(sc, LII_ISR, 0);
	if (error) {
		printf("%s: init failed\n", DEVNAME(sc));
		goto out;
	}

	/*
	 * Initialise MAC. 
	 */
	val = LII_READ_4(sc, LII_MACC) & MACC_FDX;

	val |= MACC_RX_EN | MACC_TX_EN | MACC_MACLP_CLK_PHY |
	    MACC_TX_FLOW_EN | MACC_RX_FLOW_EN | MACC_ADD_CRC |
	    MACC_PAD;

	val |= 7 << MACC_PREAMBLE_LEN_SHIFT;
	val |= 2 << MACC_HDX_LEFT_BUF_SHIFT;

	LII_WRITE_4(sc, LII_MACC, val);

	/* Set the hardware MAC address. */
	LII_WRITE_4(sc, LII_MAC_ADDR_0, letoh32((sc->sc_ac.ac_enaddr[2] << 24) |
	    (sc->sc_ac.ac_enaddr[3] << 16) | (sc->sc_ac.ac_enaddr[4] << 8) |
	    sc->sc_ac.ac_enaddr[5]));
	LII_WRITE_4(sc, LII_MAC_ADDR_1,
	    letoh32((sc->sc_ac.ac_enaddr[0] << 8) | sc->sc_ac.ac_enaddr[1]));

	/* Program promiscuous mode and multicast filters. */
	lii_iff(sc);

	mii_mediachg(&sc->sc_mii);

	LII_WRITE_4(sc, LII_IMR, IMR_NORMAL_MASK);

	timeout_add_sec(&sc->sc_tick, 1);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

out:
	return error;
}

void
lii_tx_put(struct lii_softc *sc, struct mbuf *m)
{
	int left;
	struct tx_pkt_header *tph =
	    (struct tx_pkt_header *)(sc->sc_txdbase + sc->sc_txd_cur);

	memset(tph, 0, sizeof *tph);
	tph->txph_size = m->m_pkthdr.len;

	sc->sc_txd_cur = (sc->sc_txd_cur + 4) % AT_TXD_BUFFER_SIZE;

	/*
	 * We already know we have enough space, so if there is a part of the
	 * space ahead of txd_cur that is active, it doesn't matter because
	 * left will be large enough even without it.
	 */
	left  = AT_TXD_BUFFER_SIZE - sc->sc_txd_cur;

	if (left > m->m_pkthdr.len) {
		m_copydata(m, 0, m->m_pkthdr.len,
		    sc->sc_txdbase + sc->sc_txd_cur);
		sc->sc_txd_cur += m->m_pkthdr.len;
	} else {
		m_copydata(m, 0, left, sc->sc_txdbase + sc->sc_txd_cur);
		m_copydata(m, left, m->m_pkthdr.len - left, sc->sc_txdbase);
		sc->sc_txd_cur = m->m_pkthdr.len - left;
	}

	/* Round to a 32-bit boundary */
	sc->sc_txd_cur = ((sc->sc_txd_cur + 3) & ~3) % AT_TXD_BUFFER_SIZE;
	if (sc->sc_txd_cur == sc->sc_txd_ack)
		sc->sc_free_tx_slots = 0;
}

int
lii_free_tx_space(struct lii_softc *sc)
{
	int space;

	if (sc->sc_txd_cur >= sc->sc_txd_ack)
		space = (AT_TXD_BUFFER_SIZE - sc->sc_txd_cur) +
		    sc->sc_txd_ack;
	else
		space = sc->sc_txd_ack - sc->sc_txd_cur;

	/* Account for the tx_pkt_header */
	return (space - 4);
}

void
lii_start(struct ifnet *ifp)
{
	struct lii_softc *sc = ifp->if_softc;
	struct mbuf *m0;

	DPRINTF(("lii_start\n"));

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		m0 = ifq_deq_begin(&ifp->if_snd);
		if (m0 == NULL)
			break;

		if (!sc->sc_free_tx_slots ||
		    lii_free_tx_space(sc) < m0->m_pkthdr.len) {
			ifq_deq_rollback(&ifp->if_snd, m0);
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		lii_tx_put(sc, m0);

		DPRINTF(("lii_start: put %d\n", sc->sc_txs_cur));

		sc->sc_txs[sc->sc_txs_cur].txps_update = 0;
		sc->sc_txs_cur = (sc->sc_txs_cur + 1) % AT_TXD_NUM;
		if (sc->sc_txs_cur == sc->sc_txs_ack)
			sc->sc_free_tx_slots = 0;

		LII_WRITE_2(sc, LII_MB_TXD_WR_IDX, sc->sc_txd_cur/4);

		ifq_deq_commit(&ifp->if_snd, m0);

#if NBPFILTER > 0
		if (ifp->if_bpf != NULL)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
		m_freem(m0);
	}
}

void
lii_stop(struct ifnet *ifp)
{
	struct lii_softc *sc = ifp->if_softc;

	timeout_del(&sc->sc_tick);

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	mii_down(&sc->sc_mii);

	lii_reset(sc);

	LII_WRITE_4(sc, LII_IMR, 0);
}

int
lii_intr(void *v)
{
	struct lii_softc *sc = v;
	uint32_t status;

	status = LII_READ_4(sc, LII_ISR);
	if (status == 0)
		return 0;

	DPRINTF(("lii_intr (%x)\n", status));

	/* Clear the interrupt and disable them */
	LII_WRITE_4(sc, LII_ISR, status | ISR_DIS_INT);

	if (status & (ISR_PHY | ISR_MANUAL)) {
		/* Ack PHY interrupt.  Magic register */
		if (status & ISR_PHY)
			(void)lii_mii_readreg(&sc->sc_dev, 1, 19);
		mii_mediachg(&sc->sc_mii);
	}

	if (status & (ISR_DMAR_TO_RST | ISR_DMAW_TO_RST | ISR_PHY_LINKDOWN)) {
		lii_init(&sc->sc_ac.ac_if);
		return 1;
	}

	if (status & ISR_RX_EVENT) {
#ifdef LII_DEBUG
		if (!(status & ISR_RS_UPDATE))
			printf("rxintr %08x\n", status);
#endif
		lii_rxintr(sc);
	}

	if (status & ISR_TX_EVENT)
		lii_txintr(sc);

	/* Re-enable interrupts */
	LII_WRITE_4(sc, LII_ISR, 0);

	return 1;
}

void
lii_rxintr(struct lii_softc *sc)
{
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct rx_pkt *rxp;
	struct mbuf *m;
	uint16_t size;

	DPRINTF(("lii_rxintr\n"));

	for (;;) {
		rxp = &sc->sc_rxp[sc->sc_rxcur];
		if (rxp->rxp_update == 0)
			break;

		DPRINTF(("lii_rxintr: getting %u (%u) [%x]\n", sc->sc_rxcur,
		    rxp->rxp_size, rxp->rxp_flags));
		sc->sc_rxcur = (sc->sc_rxcur + 1) % AT_RXD_NUM;
		rxp->rxp_update = 0;
		if (!(rxp->rxp_flags & LII_RXF_SUCCESS)) {
			++ifp->if_ierrors;
			continue;
		}

		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			++ifp->if_ierrors;
			continue;
		}
		size = rxp->rxp_size - ETHER_CRC_LEN;
		if (size > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_freem(m);
				++ifp->if_ierrors;
				continue;
			}
		}

		/* Copy the packet withhout the FCS */
		m->m_pkthdr.len = m->m_len = size;
		memcpy(mtod(m, void *), &rxp->rxp_data[0], size);

		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);

	LII_WRITE_4(sc, LII_MB_RXD_RD_IDX, sc->sc_rxcur);
}

void
lii_txintr(struct lii_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct tx_pkt_status *txs;
	struct tx_pkt_header *txph;

	DPRINTF(("lii_txintr\n"));

	for (;;) {
		txs = &sc->sc_txs[sc->sc_txs_ack];
		if (txs->txps_update == 0)
			break;
		DPRINTF(("lii_txintr: ack'd %d\n", sc->sc_txs_ack));
		sc->sc_txs_ack = (sc->sc_txs_ack + 1) % AT_TXD_NUM;
		sc->sc_free_tx_slots = 1;

		txs->txps_update = 0;

		txph =  (struct tx_pkt_header *)
		    (sc->sc_txdbase + sc->sc_txd_ack);

		if (txph->txph_size != txs->txps_size) {
			printf("%s: mismatched status and packet\n",
			    DEVNAME(sc));
		}

		/*
		 * Move ack by the packet size, taking the packet header in
		 * account and round to the next 32-bit boundary
		 * (7 = sizeof(header) + 3)
		 */
		sc->sc_txd_ack = (sc->sc_txd_ack + txph->txph_size + 7 ) & ~3;
		sc->sc_txd_ack %= AT_TXD_BUFFER_SIZE;

		if (!ISSET(txs->txps_flags, LII_TXF_SUCCESS))
			++ifp->if_oerrors;
		ifq_clr_oactive(&ifp->if_snd);
	}

	if (sc->sc_free_tx_slots)
		lii_start(ifp);
}

int
lii_alloc_rings(struct lii_softc *sc)
{
	int nsegs;
	bus_size_t bs;

	/*
	 * We need a big chunk of DMA-friendly memory because descriptors
	 * are not separate from data on that crappy hardware, which means
	 * we'll have to copy data from and to that memory zone to and from
	 * the mbufs.
	 *
	 * How lame is that?  Using the default values from the Linux driver,
	 * we allocate space for receiving up to 64 full-size Ethernet frames,
	 * and only 8kb for transmitting up to 64 Ethernet frames.
	 */

	sc->sc_ringsize = bs = AT_RXD_PADDING
	    + AT_RXD_NUM * sizeof(struct rx_pkt)
	    + AT_TXD_NUM * sizeof(struct tx_pkt_status)
	    + AT_TXD_BUFFER_SIZE;

	if (bus_dmamap_create(sc->sc_dmat, bs, 1, bs, (1<<30),
	    BUS_DMA_NOWAIT, &sc->sc_ringmap) != 0) {
		printf(": failed to create DMA map\n");
		return 1;
	}

	if (bus_dmamem_alloc(sc->sc_dmat, bs, PAGE_SIZE, (1<<30),
	    &sc->sc_ringseg, 1, &nsegs, BUS_DMA_NOWAIT) != 0) {
		printf(": failed to allocate DMA memory\n");
		goto destroy;
	}

	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_ringseg, nsegs, bs,
	    (caddr_t *)&sc->sc_ring, BUS_DMA_NOWAIT) != 0) {
		printf(": failed to map DMA memory\n");
		goto free;
	}

	if (bus_dmamap_load(sc->sc_dmat, sc->sc_ringmap, sc->sc_ring,
	    bs, NULL, BUS_DMA_NOWAIT) != 0) {
		printf(": failed to load DMA memory\n");
		goto unmap;
	}

	sc->sc_rxp = (void *)(sc->sc_ring + AT_RXD_PADDING);
	sc->sc_txs = (void *)(sc->sc_ring + AT_RXD_PADDING
	    + AT_RXD_NUM * sizeof(struct rx_pkt));
	sc->sc_txdbase = ((char *)sc->sc_txs)
	    + AT_TXD_NUM * sizeof(struct tx_pkt_status);
	sc->sc_txsp = sc->sc_ringmap->dm_segs[0].ds_addr
	    + ((char *)sc->sc_txs - (char *)sc->sc_ring);
	sc->sc_txdp = sc->sc_ringmap->dm_segs[0].ds_addr
	    + ((char *)sc->sc_txdbase - (char *)sc->sc_ring);

	return 0;

unmap:
	bus_dmamem_unmap(sc->sc_dmat, sc->sc_ring, bs);
free:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_ringseg, nsegs);
destroy:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ringmap);
	return 1;
}

void
lii_watchdog(struct ifnet *ifp)
{
	struct lii_softc *sc = ifp->if_softc;

	printf("%s: watchdog timeout\n", DEVNAME(sc));
	++ifp->if_oerrors;
	lii_init(ifp);
}

int
lii_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
{
	struct lii_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)addr;
	int s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		SET(ifp->if_flags, IFF_UP);
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ISSET(ifp->if_flags, IFF_UP)) {
			if (ISSET(ifp->if_flags, IFF_RUNNING))
				error = ENETRESET;
			else
				lii_init(ifp);
		} else {
			if (ISSET(ifp->if_flags, IFF_RUNNING))
				lii_stop(ifp);
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, addr);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			lii_iff(sc);
		error = 0;
	}

	splx(s);
	return error;
}

void
lii_iff(struct lii_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	struct arpcom *ac = &sc->sc_ac;
	struct ether_multi *enm;
	struct ether_multistep step;
	uint32_t hashes[2];
	uint32_t crc, val;

	val = LII_READ_4(sc, LII_MACC);
	val &= ~(MACC_ALLMULTI_EN | MACC_BCAST_EN | MACC_PROMISC_EN);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept broadcast frames.
	 */
	val |= MACC_BCAST_EN;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			val |= MACC_PROMISC_EN;
		else
			val |= MACC_ALLMULTI_EN;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			crc = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN);

			hashes[((crc >> 31) & 0x1)] |=
			    (1 << ((crc >> 26) & 0x1f));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	LII_WRITE_4(sc, LII_MHT, hashes[0]);
	LII_WRITE_4(sc, LII_MHT + 4, hashes[1]);
	LII_WRITE_4(sc, LII_MACC, val);
}

void
lii_tick(void *v)
{
	struct lii_softc *sc = v;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick, 1);
}
@


1.43
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.42 2015/11/25 03:09:59 dlg Exp $	*/
d979 1
a979 3
		if (txs->txps_flags & LII_TXF_SUCCESS)
			++ifp->if_opackets;
		else
@


1.42
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.41 2015/11/24 17:11:39 mpi Exp $	*/
a268 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.41
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.40 2015/11/24 13:33:17 mpi Exp $	*/
d731 1
a731 1
	ifp->if_flags &= ~IFF_OACTIVE;
d795 1
a795 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
d806 1
a806 1
			ifp->if_flags |= IFF_OACTIVE;
d839 2
a840 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d984 1
a984 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.40
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.39 2015/11/20 03:35:23 dlg Exp $	*/
a47 1
#include <net/if_dl.h>
@


1.39
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.38 2015/10/25 13:04:28 mpi Exp $	*/
a49 1
#include <net/if_types.h>
@


1.38
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.37 2015/06/24 09:40:54 mpi Exp $	*/
d801 1
a801 1
		IFQ_POLL(&ifp->if_snd, m0);
d807 1
d823 1
a823 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.37
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.36 2015/04/11 14:40:42 jsing Exp $	*/
a1071 1
	struct ifaddr *ifa = (struct ifaddr *)addr;
a1079 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.36
log
@Convert lii(4) to if_input().

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.35 2015/03/14 03:38:48 jsg Exp $	*/
a935 1
		++ifp->if_ipackets;
@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.34 2014/12/22 02:28:52 tedu Exp $	*/
d896 1
a932 1
		m->m_pkthdr.rcvif = ifp;
d938 2
a939 4
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
d941 1
a941 2
		ether_input_mbuf(ifp, m);
	}
@


1.34
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.33 2014/08/30 09:52:13 brad Exp $	*/
a58 1
#include <dev/mii/mii.h>
@


1.33
log
@Set the MRU to a full size frame instead of basing it on the MTU.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.32 2013/12/28 03:34:54 deraadt Exp $	*/
a55 1
#ifdef INET
a57 1
#endif
a1085 1
#ifdef INET
a1087 1
#endif
@


1.32
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.31 2013/12/06 21:03:04 deraadt Exp $	*/
d677 1
a677 2
	LII_WRITE_4(sc, LII_MTU, ifp->if_mtu + ETHER_HDR_LEN
	    + ETHER_CRC_LEN + ETHER_VLAN_ENCAP_LEN);
@


1.31
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.30 2010/09/19 00:15:41 sthen Exp $	*/
a301 1
		rv = config_activate_children(self, act);
@


1.30
log
@Move setting of reception of broadcast packets from lii_init() into
lii_iff() to be consistent with age/alc and other drivers. No functional
change. From Brad, tested by oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.29 2010/08/31 17:13:44 deraadt Exp $	*/
a295 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d305 3
@


1.29
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.28 2010/08/27 17:08:00 jsg Exp $	*/
d713 2
a714 2
	    MACC_TX_FLOW_EN | MACC_RX_FLOW_EN |
	    MACC_ADD_CRC | MACC_PAD | MACC_BCAST_EN;
d1138 1
a1138 1
	val &= ~(MACC_ALLMULTI_EN | MACC_PROMISC_EN);
d1140 5
@


1.28
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.27 2010/07/26 22:21:59 deraadt Exp $	*/
d296 3
d310 1
a310 1
	return rv;
@


1.27
log
@ca_activate function brings eeepc701 network back after resume.
tested by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.26 2010/02/08 12:28:42 jsing Exp $	*/
a273 1
	ifp->if_init = lii_init;
@


1.26
log
@When initialising the chip actually set the hardware MAC address, thus
allowing the MAC address to be changed/set via ifconfig.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.21 2008/11/28 02:44:18 brad Exp $	*/
d125 1
d136 3
a138 1
	lii_attach
d287 22
@


1.25
log
@Use nitems.
@
text
@d694 7
@


1.24
log
@Bring multicast/promisc handling in line with other network drives.

From Brad.
@
text
@d200 1
a200 1
	    sizeof(lii_devices)/sizeof(lii_devices[0])));
@


1.23
log
@Remove erroneous spaces.

From brad
@
text
@d1100 1
a1100 1
	uint32_t hashes[2] = { 0, 0 };
d1104 1
a1104 1
	val &= ~(MACC_PROMISC_EN | MACC_ALLMULTI_EN);
d1107 1
a1107 1
	if (ifp->if_flags & IFF_PROMISC) {
d1109 5
a1113 4
		val |= MACC_PROMISC_EN;
	} else if (ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		val |= MACC_ALLMULTI_EN;
d1115 2
a1116 3
		/* Clear multicast hash table. */
		LII_WRITE_4(sc, LII_MHT, 0);
		LII_WRITE_4(sc, LII_MHT + 4, 0);
a1117 1
		/* Calculate multicast hashes. */
d1122 1
a1129 1
	/* Write new hashes to multicast hash table. */
a1131 1

@


1.22
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1108 1
a1108 1
		ifp ->if_flags |= IFF_ALLMULTI;
d1111 1
a1111 1
		ifp ->if_flags |= IFF_ALLMULTI;
@


1.21
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.20 2008/10/07 16:03:37 jsing Exp $	*/
d219 1
a219 1
		printf(": failed to map memory!\n");
d236 1
a236 1
		printf(": failed to map interrupt!\n");
d242 1
a242 1
		printf(": failed to establish interrupt!\n");
d990 1
a990 1
		printf(": failed to create DMA map!\n");
d996 1
a996 1
		printf(": failed to allocate DMA memory!\n");
d1002 1
a1002 1
		printf(": failed to map DMA memory!\n");
d1008 1
a1008 1
		printf(": failed to load DMA memory!\n");
@


1.20
log
@If we fail to read the MAC address from the eeprom, fallback to reading
the MAC address registers. In most cases these already have the correct
MAC address. This should address PR5743. Thanks to Rodolfo Gouveia for
testing earlier diffs.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.18 2008/09/10 14:01:22 blambert Exp $	*/
d1047 1
a1048 1
	struct ifaddr *ifa;
a1056 1
		ifa = (struct ifaddr *)addr;
d1061 1
a1073 7
	case SIOCADDMULTI:
		error = ether_addmulti(ifr, &sc->sc_ac);
		break;
	case SIOCDELMULTI:
		error = ether_delmulti(ifr, &sc->sc_ac);
		break;

d1078 1
@


1.19
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d140 1
a140 1
int	lii_read_macaddr(struct lii_softc *, uint8_t *);
d233 1
a233 2
	if (lii_read_macaddr(sc, sc->sc_ac.ac_enaddr))
		goto unmap;
d437 1
a437 1
int
d470 4
a473 4
	if (found < 2) {
		printf(": error reading MAC address\n");
		return 1;
	}
a489 2

	return 0;
@


1.18
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.17 2008/09/01 14:38:31 brad Exp $	*/
d1052 1
a1052 1
	int s, error;
a1055 4
	error = ether_ioctl(ifp, &sc->sc_ac, cmd, addr);
	if (error > 0)
		goto err;

d1089 1
a1089 2
		error = ENOTTY;
		break;
a1091 1
err:
d1097 1
a1098 1

@


1.17
log
@Finish the rest... ATL2 -> LII

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.16 2008/07/17 13:50:49 jsing Exp $	*/
d704 1
a704 1
	timeout_add(&sc->sc_tick, hz);
d1162 1
a1162 1
	timeout_add(&sc->sc_tick, hz);
@


1.16
log
@Remove clause 3 from NetBSD license.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.15 2008/06/30 11:20:28 jsing Exp $	*/
d70 2
a71 2
/*#define ATL2_DEBUG*/
#ifdef ATL2_DEBUG
d294 1
a294 1
	LII_WRITE_4(sc, ATL2_SMC, SMC_SOFT_RST);
d298 1
a298 1
		if (LII_READ_4(sc, ATL2_BIS) == 0)
d308 1
a308 1
	LII_WRITE_4(sc, ATL2_PHYC, PHYC_ENABLE);
d325 1
a325 1
	val = LII_READ_4(sc, ATL2_SFC);
d327 1
a327 1
		LII_WRITE_4(sc, ATL2_SFC, val & ~(SFC_EN_VPD));
d371 1
a371 1
	LII_WRITE_1(sc, ATL2_SFOP_WRSR,
d373 1
a373 1
	LII_WRITE_1(sc, ATL2_SFOP_READ,
d375 1
a375 1
	LII_WRITE_1(sc, ATL2_SFOP_PROGRAM,
d377 1
a377 1
	LII_WRITE_1(sc, ATL2_SFOP_WREN,
d379 1
a379 1
	LII_WRITE_1(sc, ATL2_SFOP_RDSR,
d381 1
a381 1
	LII_WRITE_1(sc, ATL2_SFOP_RDID,
d383 1
a383 1
	LII_WRITE_1(sc, ATL2_SFOP_SC_ERASE,
d385 1
a385 1
	LII_WRITE_1(sc, ATL2_SFOP_CHIP_ERASE,
d415 2
a416 2
	LII_WRITE_4(sc, ATL2_SF_DATA, 0);
	LII_WRITE_4(sc, ATL2_SF_ADDR, reg);
d422 1
a422 1
	LII_WRITE_4(sc, ATL2_SFC, v);
d424 1
a424 1
	LII_WRITE_4(sc, ATL2_SFC, v);
d428 1
a428 1
		if (!(LII_READ_4(sc, ATL2_SFC) & SFC_START))
d434 1
a434 1
	*val = LII_READ_4(sc, ATL2_SF_DATA);
d458 1
a458 1
		case ATL2_MAC_ADDR_0:
d462 1
a462 1
		case ATL2_MAC_ADDR_1:
d481 2
a482 2
		addr0 = htole32(LII_READ_4(sc, ATL2_MAC_ADDR_0));
		addr1 = htole32(LII_READ_4(sc, ATL2_MAC_ADDR_1));
d509 1
a509 1
	LII_WRITE_4(sc, ATL2_MDIOC, val);
d513 1
a513 1
		val = LII_READ_4(sc, ATL2_MDIOC);
d541 1
a541 1
	LII_WRITE_4(sc, ATL2_MDIOC, val);
d545 1
a545 1
		val = LII_READ_4(sc, ATL2_MDIOC);
d564 1
a564 1
	val = LII_READ_4(sc, ATL2_MACC);
d571 1
a571 1
	LII_WRITE_4(sc, ATL2_MACC, val);
d612 1
a612 1
	LII_WRITE_4(sc, ATL2_ISR, 0xffffffff);
d614 1
a614 1
	LII_WRITE_4(sc, ATL2_DESC_BASE_ADDR_HI, 0);
d618 1
a618 1
	LII_WRITE_4(sc, ATL2_RXD_BASE_ADDR_LO,
d621 1
a621 1
	LII_WRITE_4(sc, ATL2_TXS_BASE_ADDR_LO,
d623 1
a623 1
	LII_WRITE_4(sc, ATL2_TXD_BASE_ADDR_LO,
d626 3
a628 3
	LII_WRITE_2(sc, ATL2_TXD_BUFFER_SIZE, AT_TXD_BUFFER_SIZE / 4);
	LII_WRITE_2(sc, ATL2_TXS_NUM_ENTRIES, AT_TXD_NUM);
	LII_WRITE_2(sc, ATL2_RXD_NUM_ENTRIES, AT_RXD_NUM);
d636 1
a636 1
	LII_WRITE_4(sc, ATL2_MIPFG, 0x60405060);
d644 1
a644 1
	LII_WRITE_4(sc, ATL2_MHDC, 0x07a0f037 |
d648 2
a649 2
	LII_WRITE_2(sc, ATL2_IMTIV, 100);
	LII_WRITE_2(sc, ATL2_SMC, SMC_ITIMER_EN);
d652 1
a652 1
	LII_WRITE_2(sc, ATL2_IALTIV, 50000);
d654 1
a654 1
	LII_WRITE_4(sc, ATL2_MTU, ifp->if_mtu + ETHER_HDR_LEN
d658 1
a658 1
	LII_WRITE_4(sc, ATL2_TX_CUT_THRESH, 0x177);
d660 2
a661 2
	LII_WRITE_2(sc, ATL2_PAUSE_ON_TH, AT_RXD_NUM * 7 / 8);
	LII_WRITE_2(sc, ATL2_PAUSE_OFF_TH, AT_RXD_NUM / 12);
d667 2
a668 2
	LII_WRITE_2(sc, ATL2_MB_TXD_WR_IDX, sc->sc_txd_cur);
	LII_WRITE_2(sc, ATL2_MB_RXD_RD_IDX, sc->sc_rxcur);
d670 2
a671 2
	LII_WRITE_1(sc, ATL2_DMAR, DMAR_EN);
	LII_WRITE_1(sc, ATL2_DMAW, DMAW_EN);
d673 1
a673 1
	LII_WRITE_4(sc, ATL2_SMC, LII_READ_4(sc, ATL2_SMC) | SMC_MANUAL_INT);
d675 3
a677 3
	error = ((LII_READ_4(sc, ATL2_ISR) & ISR_PHY_LINKDOWN) != 0);
	LII_WRITE_4(sc, ATL2_ISR, 0x3fffffff);
	LII_WRITE_4(sc, ATL2_ISR, 0);
d686 1
a686 1
	val = LII_READ_4(sc, ATL2_MACC) & MACC_FDX;
d695 1
a695 1
	LII_WRITE_4(sc, ATL2_MACC, val);
d702 1
a702 1
	LII_WRITE_4(sc, ATL2_IMR, IMR_NORMAL_MASK);
d794 1
a794 1
		LII_WRITE_2(sc, ATL2_MB_TXD_WR_IDX, sc->sc_txd_cur/4);
d820 1
a820 1
	LII_WRITE_4(sc, ATL2_IMR, 0);
d829 1
a829 1
	status = LII_READ_4(sc, ATL2_ISR);
d836 1
a836 1
	LII_WRITE_4(sc, ATL2_ISR, status | ISR_DIS_INT);
d851 1
a851 1
#ifdef ATL2_DEBUG
d862 1
a862 1
	LII_WRITE_4(sc, ATL2_ISR, 0);
d886 1
a886 1
		if (!(rxp->rxp_flags & ATL2_RXF_SUCCESS)) {
d920 1
a920 1
	LII_WRITE_4(sc, ATL2_MB_RXD_RD_IDX, sc->sc_rxcur);
d958 1
a958 1
		if (txs->txps_flags & ATL2_TXF_SUCCESS)
d1118 1
a1118 1
	val = LII_READ_4(sc, ATL2_MACC);
d1130 2
a1131 2
		LII_WRITE_4(sc, ATL2_MHT, 0);
		LII_WRITE_4(sc, ATL2_MHT + 4, 0);
d1146 2
a1147 2
	LII_WRITE_4(sc, ATL2_MHT, hashes[0]);
	LII_WRITE_4(sc, ATL2_MHT + 4, hashes[1]);
d1149 1
a1149 1
	LII_WRITE_4(sc, ATL2_MACC, val);
@


1.15
log
@Teach lii(4) how to clean up after itself.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.14 2008/06/10 04:30:17 jsing Exp $	*/
a14 3
 *  3. Neither the name of The NetBSD Foundation nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
@


1.14
log
@Rename access macros so that they match the driver name.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.13 2008/05/20 18:21:56 jsing Exp $	*/
d87 1
d221 2
a222 2
	    &sc->sc_mmioh, NULL, NULL, 0)) {
		printf(": failed to map mem space\n");
d227 1
a227 1
		return;
d237 1
a237 1
		return;
d240 2
a241 3
		printf(": failed to map interrupt\n");
		/* XXX cleanup */
		return;
d246 2
a247 3
		printf(": failed to establish interrupt\n");
		/* XXX cleanup */
		return;
d250 2
a251 4
	if (lii_alloc_rings(sc)) {
		pci_intr_disestablish(sc->sc_pc, sc->sc_ih);
		return;
	}
d280 8
d996 1
a996 1
		printf(": bus_dmamap_create failed\n");
d1002 2
a1003 2
		printf(": bus_dmamem_alloc failed\n");
		goto fail;
d1008 2
a1009 2
		printf(": bus_dmamem_map failed\n");
		goto fail1;
d1014 2
a1015 2
		printf(": bus_dmamap_load failed\n");
		goto fail2;
d1030 1
a1030 1
fail2:
d1032 1
a1032 1
fail1:
d1034 1
a1034 1
fail:
@


1.13
log
@Add multicast support to lii(4), with suggestions/changes from brad@@.

ok brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.12 2008/05/15 04:37:59 brad Exp $	*/
d174 1
a174 1
#define AT_READ_4(sc,reg) \
d176 1
a176 1
#define AT_READ_2(sc,reg) \
d178 1
a178 1
#define AT_READ_1(sc,reg) \
d180 1
a180 1
#define AT_WRITE_4(sc,reg,val) \
d182 1
a182 1
#define AT_WRITE_2(sc,reg,val) \
d184 1
a184 1
#define AT_WRITE_1(sc,reg,val) \
d292 1
a292 1
	AT_WRITE_4(sc, ATL2_SMC, SMC_SOFT_RST);
d296 1
a296 1
		if (AT_READ_4(sc, ATL2_BIS) == 0)
d306 1
a306 1
	AT_WRITE_4(sc, ATL2_PHYC, PHYC_ENABLE);
d311 3
a313 3
	AT_WRITE_4(sc, 0x12fc, 0x00006500);
	AT_WRITE_4(sc, 0x1008, 0x00008000 |
	    AT_READ_4(sc, 0x1008));
d323 1
a323 1
	val = AT_READ_4(sc, ATL2_SFC);
d325 1
a325 1
		AT_WRITE_4(sc, ATL2_SFC, val & ~(SFC_EN_VPD));
d369 1
a369 1
	AT_WRITE_1(sc, ATL2_SFOP_WRSR,
d371 1
a371 1
	AT_WRITE_1(sc, ATL2_SFOP_READ,
d373 1
a373 1
	AT_WRITE_1(sc, ATL2_SFOP_PROGRAM,
d375 1
a375 1
	AT_WRITE_1(sc, ATL2_SFOP_WREN,
d377 1
a377 1
	AT_WRITE_1(sc, ATL2_SFOP_RDSR,
d379 1
a379 1
	AT_WRITE_1(sc, ATL2_SFOP_RDID,
d381 1
a381 1
	AT_WRITE_1(sc, ATL2_SFOP_SC_ERASE,
d383 1
a383 1
	AT_WRITE_1(sc, ATL2_SFOP_CHIP_ERASE,
d413 2
a414 2
	AT_WRITE_4(sc, ATL2_SF_DATA, 0);
	AT_WRITE_4(sc, ATL2_SF_ADDR, reg);
d420 1
a420 1
	AT_WRITE_4(sc, ATL2_SFC, v);
d422 1
a422 1
	AT_WRITE_4(sc, ATL2_SFC, v);
d426 1
a426 1
		if (!(AT_READ_4(sc, ATL2_SFC) & SFC_START))
d432 1
a432 1
	*val = AT_READ_4(sc, ATL2_SF_DATA);
d479 2
a480 2
		addr0 = htole32(AT_READ_4(sc, ATL2_MAC_ADDR_0));
		addr1 = htole32(AT_READ_4(sc, ATL2_MAC_ADDR_1));
d507 1
a507 1
	AT_WRITE_4(sc, ATL2_MDIOC, val);
d511 1
a511 1
		val = AT_READ_4(sc, ATL2_MDIOC);
d539 1
a539 1
	AT_WRITE_4(sc, ATL2_MDIOC, val);
d543 1
a543 1
		val = AT_READ_4(sc, ATL2_MDIOC);
d562 1
a562 1
	val = AT_READ_4(sc, ATL2_MACC);
d569 1
a569 1
	AT_WRITE_4(sc, ATL2_MACC, val);
d610 1
a610 1
	AT_WRITE_4(sc, ATL2_ISR, 0xffffffff);
d612 1
a612 1
	AT_WRITE_4(sc, ATL2_DESC_BASE_ADDR_HI, 0);
d616 1
a616 1
	AT_WRITE_4(sc, ATL2_RXD_BASE_ADDR_LO,
d619 1
a619 1
	AT_WRITE_4(sc, ATL2_TXS_BASE_ADDR_LO,
d621 1
a621 1
	AT_WRITE_4(sc, ATL2_TXD_BASE_ADDR_LO,
d624 3
a626 3
	AT_WRITE_2(sc, ATL2_TXD_BUFFER_SIZE, AT_TXD_BUFFER_SIZE / 4);
	AT_WRITE_2(sc, ATL2_TXS_NUM_ENTRIES, AT_TXD_NUM);
	AT_WRITE_2(sc, ATL2_RXD_NUM_ENTRIES, AT_RXD_NUM);
d634 1
a634 1
	AT_WRITE_4(sc, ATL2_MIPFG, 0x60405060);
d642 1
a642 1
	AT_WRITE_4(sc, ATL2_MHDC, 0x07a0f037 |
d646 2
a647 2
	AT_WRITE_2(sc, ATL2_IMTIV, 100);
	AT_WRITE_2(sc, ATL2_SMC, SMC_ITIMER_EN);
d650 1
a650 1
	AT_WRITE_2(sc, ATL2_IALTIV, 50000);
d652 1
a652 1
	AT_WRITE_4(sc, ATL2_MTU, ifp->if_mtu + ETHER_HDR_LEN
d656 1
a656 1
	AT_WRITE_4(sc, ATL2_TX_CUT_THRESH, 0x177);
d658 2
a659 2
	AT_WRITE_2(sc, ATL2_PAUSE_ON_TH, AT_RXD_NUM * 7 / 8);
	AT_WRITE_2(sc, ATL2_PAUSE_OFF_TH, AT_RXD_NUM / 12);
d665 2
a666 2
	AT_WRITE_2(sc, ATL2_MB_TXD_WR_IDX, sc->sc_txd_cur);
	AT_WRITE_2(sc, ATL2_MB_RXD_RD_IDX, sc->sc_rxcur);
d668 2
a669 2
	AT_WRITE_1(sc, ATL2_DMAR, DMAR_EN);
	AT_WRITE_1(sc, ATL2_DMAW, DMAW_EN);
d671 1
a671 1
	AT_WRITE_4(sc, ATL2_SMC, AT_READ_4(sc, ATL2_SMC) | SMC_MANUAL_INT);
d673 3
a675 3
	error = ((AT_READ_4(sc, ATL2_ISR) & ISR_PHY_LINKDOWN) != 0);
	AT_WRITE_4(sc, ATL2_ISR, 0x3fffffff);
	AT_WRITE_4(sc, ATL2_ISR, 0);
d684 1
a684 1
	val = AT_READ_4(sc, ATL2_MACC) & MACC_FDX;
d693 1
a693 1
	AT_WRITE_4(sc, ATL2_MACC, val);
d700 1
a700 1
	AT_WRITE_4(sc, ATL2_IMR, IMR_NORMAL_MASK);
d792 1
a792 1
		AT_WRITE_2(sc, ATL2_MB_TXD_WR_IDX, sc->sc_txd_cur/4);
d818 1
a818 1
	AT_WRITE_4(sc, ATL2_IMR, 0);
d827 1
a827 1
	status = AT_READ_4(sc, ATL2_ISR);
d834 1
a834 1
	AT_WRITE_4(sc, ATL2_ISR, status | ISR_DIS_INT);
d860 1
a860 1
	AT_WRITE_4(sc, ATL2_ISR, 0);
d918 1
a918 1
	AT_WRITE_4(sc, ATL2_MB_RXD_RD_IDX, sc->sc_rxcur);
d1116 1
a1116 1
	val = AT_READ_4(sc, ATL2_MACC);
d1128 2
a1129 2
		AT_WRITE_4(sc, ATL2_MHT, 0);
		AT_WRITE_4(sc, ATL2_MHT + 4, 0);
d1144 2
a1145 2
	AT_WRITE_4(sc, ATL2_MHT, hashes[0]);
	AT_WRITE_4(sc, ATL2_MHT + 4, hashes[1]);
d1147 1
a1147 1
	AT_WRITE_4(sc, ATL2_MACC, val);
@


1.12
log
@- Use pci_matchbyid().
- Simplify the use of pci_mapreg_map().

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.11 2008/05/13 13:20:44 jsing Exp $	*/
d146 1
a146 1
void	lii_setmulti(struct lii_softc *);
d600 1
d681 17
a697 1
	lii_setmulti(sc);
d1098 1
a1098 1
			lii_setmulti(sc);
d1107 1
a1107 1
lii_setmulti(struct lii_softc *sc)
d1110 5
a1114 1
	uint32_t val;
d1116 3
a1118 6
	/* XXX That should be done lii_init */
	val = AT_READ_4(sc, ATL2_MACC) & MACC_FDX;

	val |= MACC_RX_EN | MACC_TX_EN | MACC_MACLP_CLK_PHY |
	    MACC_TX_FLOW_EN | MACC_RX_FLOW_EN |
	    MACC_ADD_CRC | MACC_PAD | MACC_BCAST_EN;
d1120 2
a1121 1
	if (ifp->if_flags & IFF_PROMISC)
d1123 2
a1124 1
	else if (ifp->if_flags & IFF_ALLMULTI)
d1126 12
d1139 7
a1145 2
	val |= 7 << MACC_PREAMBLE_LEN_SHIFT;
	val |= 2 << MACC_HDX_LEFT_BUF_SHIFT;
a1147 6

	/* XXX actual setmulti needed */

	/* Clear multicast hash table */
	AT_WRITE_4(sc, ATL2_MHT, 0);
	AT_WRITE_4(sc, ATL2_MHT + 4, 0);
@


1.11
log
@The driver is called lii, not atl2. Change function and variable names to
match.

go go go dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.9 2008/03/30 14:17:48 jsing Exp $	*/
d170 4
d201 2
a202 4
	struct pci_attach_args *pa = aux;

	return (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_ATTANSIC &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_ATTANSIC_L2);
d212 1
a212 1
	pcireg_t mem;
d218 4
a221 13
	mem = pci_mapreg_type(sc->sc_pc, sc->sc_tag, PCI_MAPREG_START);
	switch (mem) {
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_32BIT_1M:
	case PCI_MAPREG_TYPE_MEM | PCI_MAPREG_MEM_TYPE_64BIT:
		break;
	default:
		printf(": invalid base address register\n");
		return;
	}
	if (pci_mapreg_map(pa, PCI_MAPREG_START, mem, 0,
	    &sc->sc_mmiot, &sc->sc_mmioh, NULL, NULL, 0) != 0) {
		printf(": failed to map registers\n");
@


1.10
log
@Ensure that we wrap around to the start of the TXD buffer when incrementing
the TXD pointer beyond the end.

Fixes PR5786.
@
text
@d80 1
a80 1
struct atl2_softc {
d119 1
a119 1
	int			(*sc_memread)(struct atl2_softc *, uint32_t,
d125 2
a126 2
int	atl2_match(struct device *, void *, void *);
void	atl2_attach(struct device *, struct device *, void *);
d135 3
a137 3
	sizeof(struct atl2_softc),
	atl2_match,
	atl2_attach
d140 29
a168 29
int	atl2_reset(struct atl2_softc *);
int	atl2_eeprom_present(struct atl2_softc *);
int	atl2_read_macaddr(struct atl2_softc *, uint8_t *);
int	atl2_eeprom_read(struct atl2_softc *, uint32_t, uint32_t *);
void	atl2_spi_configure(struct atl2_softc *);
int	atl2_spi_read(struct atl2_softc *, uint32_t, uint32_t *);
void	atl2_setmulti(struct atl2_softc *);
void	atl2_tick(void *);

int	atl2_alloc_rings(struct atl2_softc *);
int	atl2_free_tx_space(struct atl2_softc *);
void	atl2_tx_put(struct atl2_softc *, struct mbuf *);

int	atl2_mii_readreg(struct device *, int, int);
void	atl2_mii_writereg(struct device *, int, int, int);
void	atl2_mii_statchg(struct device *);

int	atl2_media_change(struct ifnet *);
void	atl2_media_status(struct ifnet *, struct ifmediareq *);

int	atl2_init(struct ifnet *);
void	atl2_start(struct ifnet *);
void	atl2_stop(struct ifnet *);
void	atl2_watchdog(struct ifnet *);
int	atl2_ioctl(struct ifnet *, u_long, caddr_t);

int	atl2_intr(void *);
void	atl2_rxintr(struct atl2_softc *);
void	atl2_txintr(struct atl2_softc *);
d195 1
a195 1
atl2_match(struct device *parent, void *match, void *aux)
d204 1
a204 1
atl2_attach(struct device *parent, struct device *self, void *aux)
d206 1
a206 1
	struct atl2_softc *sc = (struct atl2_softc *)self;
d232 1
a232 1
	if (atl2_reset(sc))
d235 1
a235 1
	atl2_spi_configure(sc);
d237 2
a238 2
	if (atl2_eeprom_present(sc))
		sc->sc_memread = atl2_eeprom_read;
d240 1
a240 1
		sc->sc_memread = atl2_spi_read;
d242 1
a242 1
	if (atl2_read_macaddr(sc, sc->sc_ac.ac_enaddr))
d251 1
a251 1
	    atl2_intr, sc, DEVNAME(sc));
d258 1
a258 1
	if (atl2_alloc_rings(sc)) {
d266 1
a266 1
	timeout_set(&sc->sc_tick, atl2_tick, sc);
d269 5
a273 5
	sc->sc_mii.mii_readreg = atl2_mii_readreg;
	sc->sc_mii.mii_writereg = atl2_mii_writereg;
	sc->sc_mii.mii_statchg = atl2_mii_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, atl2_media_change,
	    atl2_media_status);
d282 4
a285 4
	ifp->if_ioctl = atl2_ioctl;
	ifp->if_start = atl2_start;
	ifp->if_watchdog = atl2_watchdog;
	ifp->if_init = atl2_init;
d293 1
a293 1
atl2_reset(struct atl2_softc *sc)
d297 1
a297 1
	DPRINTF(("atl2_reset\n"));
d326 1
a326 1
atl2_eeprom_present(struct atl2_softc *sc)
d339 1
a339 1
atl2_eeprom_read(struct atl2_softc *sc, uint32_t reg, uint32_t *val)
d345 1
a345 1
atl2_spi_configure(struct atl2_softc *sc)
d415 1
a415 1
atl2_spi_read(struct atl2_softc *sc, uint32_t reg, uint32_t *val)
d444 1
a444 1
atl2_read_macaddr(struct atl2_softc *sc, uint8_t *ea)
d501 1
a501 1
atl2_mii_readreg(struct device *dev, int phy, int reg)
d503 1
a503 1
	struct atl2_softc *sc = (struct atl2_softc *)dev;
d532 1
a532 1
atl2_mii_writereg(struct device *dev, int phy, int reg, int data)
d534 1
a534 1
	struct atl2_softc *sc = (struct atl2_softc *)dev;
d562 1
a562 1
atl2_mii_statchg(struct device *dev)
d564 1
a564 1
	struct atl2_softc *sc = (struct atl2_softc *)dev;
d567 1
a567 1
	DPRINTF(("atl2_mii_statchg\n"));
d580 1
a580 1
atl2_media_change(struct ifnet *ifp)
d582 1
a582 1
	struct atl2_softc *sc = ifp->if_softc;
d584 1
a584 1
	DPRINTF(("atl2_media_change\n"));
d592 1
a592 1
atl2_media_status(struct ifnet *ifp, struct ifmediareq *imr)
d594 1
a594 1
	struct atl2_softc *sc = ifp->if_softc;
d596 1
a596 1
	DPRINTF(("atl2_media_status\n"));
d604 1
a604 1
atl2_init(struct ifnet *ifp)
d606 1
a606 1
	struct atl2_softc *sc = ifp->if_softc;
d609 1
a609 1
	DPRINTF(("atl2_init\n"));
d611 1
a611 1
	atl2_stop(ifp);
d687 1
a687 1
	atl2_setmulti(sc);
d702 1
a702 1
atl2_tx_put(struct atl2_softc *sc, struct mbuf *m)
d737 1
a737 1
atl2_free_tx_space(struct atl2_softc *sc)
d752 1
a752 1
atl2_start(struct ifnet *ifp)
d754 1
a754 1
	struct atl2_softc *sc = ifp->if_softc;
d757 1
a757 1
	DPRINTF(("atl2_start\n"));
d768 1
a768 1
		    atl2_free_tx_space(sc) < m0->m_pkthdr.len) {
d773 1
a773 1
		atl2_tx_put(sc, m0);
d775 1
a775 1
		DPRINTF(("atl2_start: put %d\n", sc->sc_txs_cur));
d795 1
a795 1
atl2_stop(struct ifnet *ifp)
d797 1
a797 1
	struct atl2_softc *sc = ifp->if_softc;
d806 1
a806 1
	atl2_reset(sc);
d812 1
a812 1
atl2_intr(void *v)
d814 1
a814 1
	struct atl2_softc *sc = v;
d821 1
a821 1
	DPRINTF(("atl2_intr (%x)\n", status));
d829 1
a829 1
			(void)atl2_mii_readreg(&sc->sc_dev, 1, 19);
d834 1
a834 1
		atl2_init(&sc->sc_ac.ac_if);
d843 1
a843 1
		atl2_rxintr(sc);
d847 1
a847 1
		atl2_txintr(sc);
d856 1
a856 1
atl2_rxintr(struct atl2_softc *sc)
d863 1
a863 1
	DPRINTF(("atl2_rxintr\n"));
d870 1
a870 1
		DPRINTF(("atl2_rxintr: getting %u (%u) [%x]\n", sc->sc_rxcur,
d912 1
a912 1
atl2_txintr(struct atl2_softc *sc)
d918 1
a918 1
	DPRINTF(("atl2_txintr\n"));
d924 1
a924 1
		DPRINTF(("atl2_txintr: ack'd %d\n", sc->sc_txs_ack));
d954 1
a954 1
		atl2_start(ifp);
d958 1
a958 1
atl2_alloc_rings(struct atl2_softc *sc)
d1025 1
a1025 1
atl2_watchdog(struct ifnet *ifp)
d1027 1
a1027 1
	struct atl2_softc *sc = ifp->if_softc;
d1031 1
a1031 1
	atl2_init(ifp);
d1035 1
a1035 1
atl2_ioctl(struct ifnet *ifp, u_long cmd, caddr_t addr)
d1037 1
a1037 1
	struct atl2_softc *sc = ifp->if_softc;
d1062 1
a1062 1
				atl2_init(ifp);
d1065 1
a1065 1
				atl2_stop(ifp);
d1088 1
a1088 1
			atl2_setmulti(sc);
d1097 1
a1097 1
atl2_setmulti(struct atl2_softc *sc)
d1102 1
a1102 1
	/* XXX That should be done atl2_init */
d1127 1
a1127 1
atl2_tick(void *v)
d1129 1
a1129 1
	struct atl2_softc *sc = v;
@


1.9
log
@Add code to configure the vendor specific opcodes of the SPI Flash.

From NetBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.8 2008/03/30 14:09:56 jsing Exp $	*/
d731 1
a731 1
	sc->sc_txd_cur = (sc->sc_txd_cur + 3) & ~3;
@


1.8
log
@Enable setting of interrupt timers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.7 2008/03/30 14:08:46 jsing Exp $	*/
d144 1
d235 1
a235 1
	/* XXX set correct opcodes for the flash */
d342 50
@


1.7
log
@Pad the RXD buffer so that packets are aligned on a 128-byte boundary. This
prevents the chip from hard locking the machine when receiving packets.

Diff committed from an ASUS EeePC using lii(4).

From NetBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.5 2008/01/05 03:49:06 deraadt Exp $	*/
a599 1
#if 0
a605 1
#endif
@


1.6
log
@even better attach message location
@
text
@d190 3
d572 2
a573 1
	    sc->sc_ringmap->dm_segs[0].ds_addr & 0xffffffff);
d925 2
a926 1
	sc->sc_ringsize = bs = AT_RXD_NUM * sizeof(struct rx_pkt)
d954 3
a956 3
	sc->sc_rxp = (void *)sc->sc_ring;
	sc->sc_txs =
	    (void *)(sc->sc_ring + AT_RXD_NUM * sizeof(struct rx_pkt));
@


1.5
log
@print info in attach before if_attach
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.4 2008/01/04 01:47:55 dlg Exp $	*/
d259 3
a282 3

	printf("%s, address %s\n", pci_intr_string(sc->sc_pc, ih),
	    ether_sprintf(sc->sc_ac.ac_enaddr));
@


1.4
log
@read the hardware mac address into the drivers ac_enaddr thing rather than
a useless buffer. should hook the mac address up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.3 2008/01/04 01:43:09 dlg Exp $	*/
a280 3
	if_attach(ifp);
	ether_ifattach(ifp);

d284 2
a285 1
	return;
@


1.3
log
@we have pci_vpd_read now. get rid of the (bad) comment that left it out

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_lii.c,v 1.2 2007/12/31 15:18:06 jasper Exp $	*/
a203 1
	uint8_t eaddr[ETHER_ADDR_LEN];
d238 1
a238 1
	if (atl2_read_macaddr(sc, eaddr))
d285 1
a285 1
	    ether_sprintf(eaddr));
@


1.2
log
@use OpenBSD rcs id's
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d340 1
a340 2
//	return pci_vpd_read(sc->sc_pc, sc->sc_tag, reg, 1, (pcireg_t *)val);
	return (1);
@


1.1
log
@lii(4) is a driver for the atheros l2 ethernet chip as found on the asus
eeepc. unfortunately it doesnt work, but its going into the tree so it can
be worked on. if anyone wants to have a go at it, please do.

this driver was written by Quentin Garnier for NetBSD
@
text
@d1 1
a1 1
/*	$NetBSD$	*/
@

