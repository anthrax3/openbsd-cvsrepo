head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.2
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.22.0.4
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.17.0.6
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.4
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.12.0.4
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.8.0.4
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.2
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.4.0.4
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.26
date	2016.11.17.21.08.27;	author mikeb;	state Exp;
branches;
next	1.25;
commitid	nldMJuxfqfXVZAUt;

1.25
date	2016.11.17.20.44.04;	author mikeb;	state Exp;
branches;
next	1.24;
commitid	KOfaZlZSSU1u7i53;

1.24
date	2016.11.17.19.26.57;	author mikeb;	state Exp;
branches;
next	1.23;
commitid	s7sWiFVcUtMtUOpv;

1.23
date	2016.09.25.14.58.00;	author fcambus;	state Exp;
branches;
next	1.22;
commitid	EigQrdBOHNJWegdi;

1.22
date	2016.03.15.16.45.52;	author naddy;	state Exp;
branches;
next	1.21;
commitid	X5t9omeXAp1mh2AJ;

1.21
date	2015.12.18.19.08.36;	author kettenis;	state Exp;
branches;
next	1.20;
commitid	hYZ6jAF8H818qYE8;

1.20
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.19;
commitid	5gdEnqVoJuTuwdTu;

1.19
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.18;
commitid	FuSD2mFDJWATHIDx;

1.18
date	2015.11.24.12.32.53;	author mpi;	state Exp;
branches;
next	1.17;
commitid	N4FwuXZDsGAH4cQz;

1.17
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.16;
commitid	Z1vcFtHO8wRH0yRt;

1.16
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.15;
commitid	TGHgrLxu6sxZoiFt;

1.15
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Jjzk0Y0KSLF2oro4;

1.14
date	2013.10.30.03.59.26;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.08.05.19.58.05;	author mikeb;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.05.14.41.28;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2012.11.06.17.29.39;	author mikeb;	state Exp;
branches;
next	1.10;

1.10
date	2012.08.06.21.07.52;	author mikeb;	state Exp;
branches;
next	1.9;

1.9
date	2012.07.29.13.49.03;	author mikeb;	state Exp;
branches;
next	1.8;

1.8
date	2012.01.20.14.48.49;	author mikeb;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.10.12.46.35;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.23.18.43.15;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2010.02.19.18.55.12;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.04.22.27.31;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.08.21.15.34;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2008.06.08.20.33.51;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2008.06.08.20.01.02;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Autoconfiguration and firmware semaphore refactoring
@
text
@/*	$OpenBSD: ixgbe.h,v 1.25 2016/11/17 20:44:04 mikeb Exp $	*/

/******************************************************************************

  Copyright (c) 2001-2008, Intel Corporation
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

   1. Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.

   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

   3. Neither the name of the Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived from
      this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  POSSIBILITY OF SUCH DAMAGE.

******************************************************************************/
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_osdep.h 251964 Jun 18 21:28:19 2013 UTC */
/* FreeBSD: src/sys/dev/ixgbe/ixgbe_common.h 251964 Jun 18 21:28:19 2013 UTC */

#ifndef _IXGBE_H_
#define _IXGBE_H_

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/timeout.h>
#include <sys/pool.h>
#include <sys/rwlock.h>
#include <sys/atomic.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

typedef int	boolean_t;
#define TRUE	1
#define FALSE	0

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
#include <dev/pci/ixgbe_type.h>

#define DBG 0
#define MSGOUT(S, A, B)     printf(S "\n", A, B)
#define DEBUGFUNC(F)        DEBUGOUT(F);
#if DBG
	#define DEBUGOUT(S)         printf(S "\n")
	#define DEBUGOUT1(S,A)      printf(S "\n",A)
	#define DEBUGOUT2(S,A,B)    printf(S "\n",A,B)
	#define DEBUGOUT3(S,A,B,C)  printf(S "\n",A,B,C)
	#define DEBUGOUT4(S,A,B,C,D)  printf(S "\n",A,B,C,D)
	#define DEBUGOUT5(S,A,B,C,D,E)  printf(S "\n",A,B,C,D,E)
	#define DEBUGOUT6(S,A,B,C,D,E,F)  printf(S "\n",A,B,C,D,E,F)
	#define DEBUGOUT7(S,A,B,C,D,E,F,G)  printf(S "\n",A,B,C,D,E,F,G)
	#define ERROR_REPORT1(S,A)      printf(S "\n",A)
	#define ERROR_REPORT2(S,A,B)    printf(S "\n",A,B)
	#define ERROR_REPORT3(S,A,B,C)  printf(S "\n",A,B,C)
#else
	#define DEBUGOUT(S)
	#define DEBUGOUT1(S,A)
	#define DEBUGOUT2(S,A,B)
	#define DEBUGOUT3(S,A,B,C)
	#define DEBUGOUT4(S,A,B,C,D)
	#define DEBUGOUT5(S,A,B,C,D,E)
	#define DEBUGOUT6(S,A,B,C,D,E,F)
	#define DEBUGOUT7(S,A,B,C,D,E,F,G)

	#define ERROR_REPORT1(S,A)
	#define ERROR_REPORT2(S,A,B)
	#define ERROR_REPORT3(S,A,B,C)
#endif

#define FALSE		    		0
#define TRUE		    		1
#define CMD_MEM_WRT_INVALIDATE          0x0010  /* BIT_4 */
#define PCI_COMMAND_REGISTER            PCIR_COMMAND

/* Compat glue */
#define PCIR_BAR(_x)	(0x10 + (_x) * 4)
#define roundup2(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))
#define usec_delay(x) delay(x)
#define msec_delay(x) delay(1000 * (x))

/* This is needed by the shared code */
struct ixgbe_hw;

struct ixgbe_osdep {
	bus_dma_tag_t		 os_dmat;
	bus_space_tag_t		 os_memt;
	bus_space_handle_t	 os_memh;

	bus_size_t		 os_memsize;
	bus_addr_t		 os_membase;

	void			*os_sc;
	struct pci_attach_args	 os_pa;
};

extern uint16_t ixgbe_read_pci_cfg(struct ixgbe_hw *, uint32_t);
#define IXGBE_READ_PCIE_WORD ixgbe_read_pci_cfg

extern void ixgbe_write_pci_cfg(struct ixgbe_hw *, uint32_t, uint16_t);
#define IXGBE_WRITE_PCIE_WORD ixgbe_write_pci_cfg

#define IXGBE_WRITE_FLUSH(a)						\
	IXGBE_READ_REG(a, IXGBE_STATUS)
#define IXGBE_READ_REG(a, reg)						\
	bus_space_read_4(((struct ixgbe_osdep *)(a)->back)->os_memt,	\
	((struct ixgbe_osdep *)(a)->back)->os_memh, reg)
#define IXGBE_WRITE_REG(a, reg, value)					\
	bus_space_write_4(((struct ixgbe_osdep *)(a)->back)->os_memt,	\
	((struct ixgbe_osdep *)(a)->back)->os_memh, reg, value)
#define IXGBE_READ_REG_ARRAY(a, reg, offset)				\
	bus_space_read_4(((struct ixgbe_osdep *)(a)->back)->os_memt,	\
	((struct ixgbe_osdep *)(a)->back)->os_memh, (reg + ((offset) << 2)))
#define IXGBE_WRITE_REG_ARRAY(a, reg, offset, value)			\
	bus_space_write_4(((struct ixgbe_osdep *)(a)->back)->os_memt,	\
	((struct ixgbe_osdep *)(a)->back)->os_memh, (reg + ((offset) << 2)), value)

/* MAC Operations */
uint16_t ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_generic(struct ixgbe_hw *hw);
int32_t ixgbe_init_hw_generic(struct ixgbe_hw *hw);
int32_t ixgbe_start_hw_generic(struct ixgbe_hw *hw);
int32_t ixgbe_start_hw_gen2(struct ixgbe_hw *hw);
int32_t ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);
int32_t ixgbe_read_pba_num_generic(struct ixgbe_hw *hw, uint32_t *pba_num);
int32_t ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, uint8_t *pba_num,
				      uint32_t pba_num_size);
int32_t ixgbe_read_pba_length_generic(struct ixgbe_hw *hw, uint32_t *pba_num_size);
int32_t ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *mac_addr);
int32_t ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);
void    ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);
int32_t ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);

int32_t ixgbe_led_on_generic(struct ixgbe_hw *hw, uint32_t index);
int32_t ixgbe_led_off_generic(struct ixgbe_hw *hw, uint32_t index);

int32_t ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw);
int32_t ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data);
int32_t ixgbe_read_eerd_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t *data);
int32_t ixgbe_write_eewr_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t data);
int32_t ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, uint16_t offset,
					   uint16_t *data);
int32_t ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);
int32_t ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
					       uint16_t *checksum_val);
int32_t ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);
int32_t ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, uint32_t ee_reg);

int32_t ixgbe_set_rar_generic(struct ixgbe_hw *hw, uint32_t index, uint8_t *addr, uint32_t vmdq,
			      uint32_t enable_addr);
int32_t ixgbe_clear_rar_generic(struct ixgbe_hw *hw, uint32_t index);
int32_t ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);
int32_t ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, uint8_t *mc_addr_list,
					  uint32_t mc_addr_count,
					  ixgbe_mc_addr_itr func, bool clear);
int32_t ixgbe_enable_mc_generic(struct ixgbe_hw *hw);
int32_t ixgbe_disable_mc_generic(struct ixgbe_hw *hw);
int32_t ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, uint32_t regval);
int32_t ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw);
int32_t ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw);

int32_t ixgbe_fc_enable_generic(struct ixgbe_hw *hw);
void ixgbe_fc_autoneg(struct ixgbe_hw *hw);
int32_t ixgbe_setup_fc_generic(struct ixgbe_hw *hw);

int32_t ixgbe_validate_mac_addr(uint8_t *mac_addr);
int32_t ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, uint32_t mask);
void    ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint32_t mask);
int32_t ixgbe_disable_pcie_master(struct ixgbe_hw *hw);

int32_t prot_autoc_read_generic(struct ixgbe_hw *hw, bool *, uint32_t *reg_val);
int32_t prot_autoc_write_generic(struct ixgbe_hw *hw, uint32_t reg_val, bool locked);

int32_t ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, uint32_t index);
int32_t ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, uint32_t index);

int32_t ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *addr, uint32_t vmdq);
int32_t ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw);
int32_t ixgbe_set_vfta_generic(struct ixgbe_hw *hw, uint32_t vlan,
			       uint32_t vind, bool vlan_on);
int32_t ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, uint32_t vlan, uint32_t vind,
			       bool vlan_on, bool *vfta_changed);
int32_t ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);

int32_t ixgbe_check_mac_link_generic(struct ixgbe_hw *hw,
				     ixgbe_link_speed *speed,
				     bool *link_up,
				     bool link_up_wait_to_complete);

int32_t ixgbe_get_device_caps_generic(struct ixgbe_hw *hw,
				      uint16_t *device_caps);
int32_t ixgbe_host_interface_command(struct ixgbe_hw *hw, uint32_t *buffer,
				     uint32_t length, uint32_t timeout,
				     bool return_data);
void ixgbe_clear_tx_pending(struct ixgbe_hw *hw);

bool ixgbe_mng_present(struct ixgbe_hw *hw);
bool ixgbe_mng_enabled(struct ixgbe_hw *hw);

void ixgbe_disable_rx_generic(struct ixgbe_hw *hw);
void ixgbe_enable_rx_generic(struct ixgbe_hw *hw);
int32_t ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
					      ixgbe_link_speed speed,
					      bool autoneg_wait_to_complete);
void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
				      ixgbe_link_speed speed);

int32_t ixgbe_init_shared_code(struct ixgbe_hw *hw);

int32_t ixgbe_init_ops_82598(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_82599(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_X540(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_X550(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_X550EM(struct ixgbe_hw *hw);

int32_t ixgbe_set_mac_type(struct ixgbe_hw *hw);
int32_t ixgbe_init_hw(struct ixgbe_hw *hw);
enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw);
int32_t ixgbe_identify_phy(struct ixgbe_hw *hw);
void ixgbe_flap_tx_laser(struct ixgbe_hw *hw);
int32_t ixgbe_setup_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
			 bool autoneg_wait_to_complete);
int32_t ixgbe_setup_mac_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
			 bool autoneg_wait_to_complete);
int32_t ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
			 bool *link_up, bool link_up_wait_to_complete);
int32_t ixgbe_get_link_capabilities(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
				    bool *autoneg);

int32_t ixgbe_set_rar(struct ixgbe_hw *hw, uint32_t index, uint8_t *addr,
		      uint32_t vmdq, uint32_t enable_addr);
int32_t ixgbe_set_vmdq(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_clear_vmdq(struct ixgbe_hw *hw, uint32_t rar, uint32_t vmdq);
int32_t ixgbe_init_uta_tables(struct ixgbe_hw *hw);

void ixgbe_add_uc_addr(struct ixgbe_hw *hw, uint8_t *addr, uint32_t vmdq);
void ixgbe_set_mta(struct ixgbe_hw *hw, uint8_t *mc_addr);

void ixgbe_disable_rx(struct ixgbe_hw *hw);
void ixgbe_enable_rx(struct ixgbe_hw *hw);

/* PHY */
int32_t ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw);
bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, uint32_t phy_addr);
enum ixgbe_phy_type ixgbe_get_phy_type_from_id(uint32_t phy_id);
int32_t ixgbe_get_phy_id(struct ixgbe_hw *hw);
int32_t ixgbe_identify_phy_generic(struct ixgbe_hw *hw);
int32_t ixgbe_reset_phy_generic(struct ixgbe_hw *hw);
int32_t ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, uint32_t reg_addr,
			       uint32_t device_type, uint16_t *phy_data);
int32_t ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, uint32_t reg_addr,
				uint32_t device_type, uint16_t phy_data);
int32_t ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, uint32_t reg_addr,
				   uint32_t device_type, uint16_t *phy_data);
int32_t ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, uint32_t reg_addr,
				    uint32_t device_type, uint16_t phy_data);
int32_t ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw);
int32_t ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
					   ixgbe_link_speed speed,
					   bool autoneg_wait_to_complete);
int32_t ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
						   ixgbe_link_speed *speed,
						   bool *autoneg);
int32_t ixgbe_check_reset_blocked(struct ixgbe_hw *hw);

/* PHY specific */
int32_t ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw,
				 ixgbe_link_speed *speed,
				 bool *link_up);
int32_t ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw);
int32_t ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
					   uint16_t *firmware_version);
int32_t ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
					       uint16_t *firmware_version);

int32_t ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
bool ixgbe_is_sfp(struct ixgbe_hw *hw);
int32_t ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on);
int32_t ixgbe_identify_module_generic(struct ixgbe_hw *hw);
int32_t ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw);
int32_t ixgbe_get_supported_phy_sfp_layer_generic(struct ixgbe_hw *hw);
int32_t ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
int32_t ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
					    uint16_t *list_offset,
					    uint16_t *data_offset);
int32_t ixgbe_tn_check_overtemp(struct ixgbe_hw *hw);
int32_t ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, uint8_t byte_offset,
				    uint8_t dev_addr, uint8_t *data);
int32_t ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, uint8_t byte_offset,
					     uint8_t dev_addr, uint8_t *data);
int32_t ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, uint8_t byte_offset,
				     uint8_t dev_addr, uint8_t data);
int32_t ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, uint8_t byte_offset,
					      uint8_t dev_addr, uint8_t data);
int32_t ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, uint8_t byte_offset,
				      uint8_t *eeprom_data);
int32_t ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, uint8_t byte_offset,
				       uint8_t eeprom_data);

/* MBX */
int32_t ixgbe_read_mbx(struct ixgbe_hw *, uint32_t *, uint16_t, uint16_t);
int32_t ixgbe_write_mbx(struct ixgbe_hw *, uint32_t *, uint16_t, uint16_t);
int32_t ixgbe_read_posted_mbx(struct ixgbe_hw *, uint32_t *, uint16_t, uint16_t);
int32_t ixgbe_write_posted_mbx(struct ixgbe_hw *, uint32_t *, uint16_t, uint16_t);
int32_t ixgbe_check_for_msg(struct ixgbe_hw *, uint16_t);
int32_t ixgbe_check_for_ack(struct ixgbe_hw *, uint16_t);
int32_t ixgbe_check_for_rst(struct ixgbe_hw *, uint16_t);
void ixgbe_init_mbx_ops_generic(struct ixgbe_hw *hw);
void ixgbe_init_mbx_params_pf(struct ixgbe_hw *);

#endif /* _IXGBE_H_ */
@


1.25
log
@EEPROM code refactoring for X540
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.24 2016/11/17 19:26:57 mikeb Exp $	*/
a197 1
int32_t ixgbe_setup_fc(struct ixgbe_hw *hw);
d200 1
d203 2
a204 2
int32_t ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, uint16_t mask);
void    ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint16_t mask);
d207 3
a272 2
bool ixgbe_verify_lesm_fw_enabled(struct ixgbe_hw *hw);
int32_t ixgbe_reset_pipeline(struct ixgbe_hw *hw);
a273 1
/* API */
d327 2
d331 2
@


1.24
log
@Bring in new PHY bits, some of the 82599 specific stuff becomes shared
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.23 2016/09/25 14:58:00 fcambus Exp $	*/
d179 1
a179 1
uint16_t ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);
a342 1
void ixgbe_init_mbx_params_vf(struct ixgbe_hw *);
@


1.23
log
@Remove more duplicated includes

OK jca@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.22 2016/03/15 16:45:52 naddy Exp $	*/
d154 1
a155 1

a191 2
int32_t ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, uint8_t *addr_list,
					  uint32_t addr_count, ixgbe_mc_addr_itr func);
a209 3
int32_t ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *san_mac_addr);
int32_t ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, uint8_t *san_mac_addr);

d222 2
a223 1
				     bool *link_up, bool link_up_wait_to_complete);
d225 5
a229 2
int32_t ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, uint16_t *device_caps);
void ixgbe_enable_relaxed_ordering_gen2(struct ixgbe_hw *hw);
d232 11
a242 1
/* MAC Operations */
d244 8
d255 5
d262 3
a264 1
void ixgbe_flap_tx_laser(struct ixgbe_hw *hw);
d277 2
a278 3
int32_t ixgbe_init_ops_82598(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_82599(struct ixgbe_hw *hw);
int32_t ixgbe_init_ops_X540(struct ixgbe_hw *hw);
d302 1
d315 2
d319 2
@


1.22
log
@Ethernet drivers no longer need to include if_vlan_var.h for the VLAN
definitions; ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.21 2015/12/18 19:08:36 kettenis Exp $	*/
a57 1
#include <net/bpf.h>
@


1.21
log
@Make ix(4) mpsafer.  Take advantage of intr_barrier() to eliminate the mutex
introduced in the previous step, and use atomic instructions to make the
tx completion path mpsafe as well.

ok claudio@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.20 2015/11/24 17:11:40 mpi Exp $	*/
a66 4
#endif

#if NVLAN > 0
#include <net/if_vlan_var.h>
@


1.20
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.19 2015/11/24 13:45:06 mpi Exp $	*/
d55 1
@


1.19
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.18 2015/11/24 12:32:53 mpi Exp $	*/
a57 1
#include <net/if_dl.h>
@


1.18
log
@No need to include <net/if_types.h> for <net/if_vlan_var.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.17 2014/11/18 02:37:30 tedu Exp $	*/
a56 1
#include <net/if_arp.h>
@


1.17
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.16 2014/07/22 13:12:11 mpi Exp $	*/
a70 1
#include <net/if_types.h>
@


1.16
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.15 2014/07/10 14:21:20 deraadt Exp $	*/
a77 2

#include <dev/rndvar.h>
@


1.15
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.14 2013/10/30 03:59:26 dlg Exp $	*/
a61 1
#include <netinet/in_systm.h>
a64 3
#include <netinet/ip6.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
@


1.14
log
@remove #include <sys/workq.h> cos this driver doesnt use it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.13 2013/08/05 19:58:05 mikeb Exp $	*/
d79 3
a81 1
#include <uvm/uvm_extern.h>
@


1.13
log
@First stab at updating this monster to the Intel/FreeBSD current version.
This syncs PHY and chip dependent parts as well as brings support for the
flow control and additional (untested) bits for 1G fiber versions.

Tested by Hrvoje Popovski <hrvoje at srce ! hr> on 82599/SFP+DA, florian@@
and benno@@ on 82599/SFP+SR and on 82598/CX4-BP, 82599/SFP+DA and X540/RJ45
by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.12 2012/12/05 14:41:28 mikeb Exp $	*/
a54 1
#include <sys/workq.h>
@


1.12
log
@minor cleanup, whitespaces, mostly synced with freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.11 2012/11/06 17:29:39 mikeb Exp $	*/
d35 2
a36 1
/*$FreeBSD: src/sys/dev/ixgbe/ixgbe_osdep.h,v 1.4 2008/05/16 18:46:30 jfv Exp $*/
d93 11
a103 6
#define DEBUGOUT(S)         printf(S)
#define DEBUGOUT1(S,A)      printf(S,A)
#define DEBUGOUT2(S,A,B)    printf(S,A,B)
#define DEBUGOUT3(S,A,B,C)  printf(S,A,B,C)
#define DEBUGOUT6(S,A,B,C,D,E,F)    printf(S,A,B,C,D,E,F)
#define DEBUGOUT7(S,A,B,C,D,E,F,G)  printf(S,A,B,C,D,E,F,G)
d105 12
a116 6
#define DEBUGOUT(S)
#define DEBUGOUT1(S,A)
#define DEBUGOUT2(S,A,B)
#define DEBUGOUT3(S,A,B,C)
#define DEBUGOUT6(S,A,B,C,D,E,F)
#define DEBUGOUT7(S,A,B,C,D,E,F,G)
d166 1
a166 7
#define IXGBE_WRITE_REG64(hw, reg, value) \
	do { \
		IXGBE_WRITE_REG(hw, reg, (uint32_t) value); \
		IXGBE_WRITE_REG(hw, reg + 4, (uint32_t) (value >> 32)); \
	} while (0)

uint32_t ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);
d175 1
a175 1
				  uint32_t pba_num_size);
d190 1
a190 1
				       uint16_t *data);
d193 1
a193 1
					   uint16_t *checksum_val);
d198 1
a198 1
			  uint32_t enable_addr);
d202 2
a203 2
				      uint32_t mc_addr_count,
				      ixgbe_mc_addr_itr func);
d205 1
a205 1
				      uint32_t addr_count, ixgbe_mc_addr_itr func);
d209 2
d212 3
a214 3
int32_t ixgbe_setup_fc(struct ixgbe_hw *hw, int32_t packetbuf_num);
int32_t ixgbe_fc_enable_generic(struct ixgbe_hw *hw, int32_t packtetbuf_num);
int32_t ixgbe_fc_autoneg(struct ixgbe_hw *hw);
d232 3
a234 1
			 uint32_t vind, int vlan_on);
d238 2
a239 5
			       ixgbe_link_speed *speed,
			       int *link_up, int link_up_wait_to_complete);

int32_t ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, uint16_t *wwnn_prefix,
				 uint16_t *wwpn_prefix);
a240 3
int32_t ixgbe_get_fcoe_boot_status_generic(struct ixgbe_hw *hw, uint16_t *bs);
void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, int enable, int pf);
void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, int enable, int vf);
d243 17
d271 1
a271 1
int ixgbe_validate_phy_addr(struct ixgbe_hw *hw, uint32_t phy_addr);
d276 4
d281 1
a281 1
			       uint32_t device_type, uint16_t *phy_data);
d283 1
a283 1
				uint32_t device_type, uint16_t phy_data);
d286 2
a287 3
				       ixgbe_link_speed speed,
				       int autoneg,
				       int autoneg_wait_to_complete);
d289 2
a290 2
					     ixgbe_link_speed *speed,
					     int *autoneg);
d294 2
a295 2
			     ixgbe_link_speed *speed,
			     int *link_up);
d298 1
a298 1
				       uint16_t *firmware_version);
d300 1
a300 1
				       uint16_t *firmware_version);
d303 1
d306 2
a307 2
				       uint16_t *list_offset,
				       uint16_t *data_offset);
d310 1
a310 1
				uint8_t dev_addr, uint8_t *data);
d312 1
a312 1
				uint8_t dev_addr, uint8_t data);
d314 1
a314 1
				  uint8_t *eeprom_data);
d316 1
a316 1
				   uint8_t eeprom_data);
@


1.11
log
@Remove Flow Director code that is not used, is outdated and tends
to get in the way.  ok krw, brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.10 2012/08/06 21:07:52 mikeb Exp $	*/
d173 1
a173 1
void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);
d210 1
a210 1
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, uint16_t mask);
@


1.10
log
@Add support for 10Gb ethernet cards based on the Intel X540 chipset.
The code was obtained from FreeBSD and tested on the hardware kindly
donated by Tony Sarendal <tony () polarcap ! org>.  Thanks a lot!

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.9 2012/07/29 13:49:03 mikeb Exp $	*/
a242 10

int32_t ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
int32_t ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, uint32_t pballoc);
int32_t ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, uint32_t pballoc);
int32_t ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
					union ixgbe_atr_input *input,
					struct ixgbe_atr_input_masks *masks,
					uint16_t soft_id,
					uint8_t queue);
uint32_t ixgbe_atr_compute_hash_82599(union ixgbe_atr_input *input, uint32_t key);
@


1.9
log
@whitespace cleanup, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.8 2012/01/20 14:48:49 mikeb Exp $	*/
d256 1
@


1.8
log
@save content of the pci attach args, not the pointer; from Christian Ehrhardt
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.7 2011/06/10 12:46:35 claudio Exp $	*/
d5 1
a5 1
  Copyright (c) 2001-2008, Intel Corporation 
d7 2
a8 2
  
  Redistribution and use in source and binary forms, with or without 
d10 2
a11 2
  
   1. Redistributions of source code must retain the above copyright notice, 
d13 3
a15 3
  
   2. Redistributions in binary form must reproduce the above copyright 
      notice, this list of conditions and the following disclaimer in the 
d17 3
a19 3
  
   3. Neither the name of the Intel Corporation nor the names of its 
      contributors may be used to endorse or promote products derived from 
d21 1
a21 1
  
d23 8
a30 8
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
d88 1
a88 1
#define DBG 0 
d107 2
a108 2
#define FALSE               		0
#define TRUE                		1
d119 1
a119 1
struct ixgbe_hw; 
d169 1
a169 1
                                  uint32_t pba_num_size);
d184 1
a184 1
                                       uint16_t *data);
d187 1
a187 1
                                           uint16_t *checksum_val);
d192 1
a192 1
                          uint32_t enable_addr);
d196 2
a197 2
                                      uint32_t mc_addr_count,
                                      ixgbe_mc_addr_itr func);
d199 1
a199 1
                                      uint32_t addr_count, ixgbe_mc_addr_itr func);
d224 1
a224 1
                         uint32_t vind, int vlan_on);
d228 2
a229 2
                               ixgbe_link_speed *speed,
                               int *link_up, int link_up_wait_to_complete);
d232 1
a232 1
                                 uint16_t *wwpn_prefix);
d248 4
a251 4
                                        union ixgbe_atr_input *input,
                                        struct ixgbe_atr_input_masks *masks,
                                        uint16_t soft_id,
                                        uint8_t queue);
d265 1
a265 1
                               uint32_t device_type, uint16_t *phy_data);
d267 1
a267 1
                                uint32_t device_type, uint16_t phy_data);
d270 3
a272 3
                                       ixgbe_link_speed speed,
                                       int autoneg,
                                       int autoneg_wait_to_complete);
d274 2
a275 2
                                             ixgbe_link_speed *speed,
                                             int *autoneg);
d279 2
a280 2
                             ixgbe_link_speed *speed,
                             int *link_up);
d283 1
a283 1
                                       uint16_t *firmware_version);
d285 1
a285 1
                                       uint16_t *firmware_version);
d290 2
a291 2
                                       uint16_t *list_offset,
                                       uint16_t *data_offset);
d294 1
a294 1
                                uint8_t dev_addr, uint8_t *data);
d296 1
a296 1
                                uint8_t dev_addr, uint8_t data);
d298 1
a298 1
                                  uint8_t *eeprom_data);
d300 1
a300 1
                                   uint8_t eeprom_data);
@


1.7
log
@Monster update of ix(4). This brings ix(4) close to what is currently
in FreeBSD. This seems to fix a lot of problems on 82599 based cards
including the VLAN problems and the corrupted receives.
Putting this in now to work on it in tree since a few additional things
need to be merged. Tested by myself, deraadt@@ and jsg@@ on both 98er and
99er cards.
OK jsg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.6 2010/02/23 18:43:15 jsg Exp $	*/
d130 1
a130 1
	struct pci_attach_args	*os_pa;
@


1.6
log
@Add support for 82599 devices based on changes to the FreeBSD driver.

Tested by deraadt on a HotLava card and myself with an Intel X520
and a CX4 82598.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.5 2010/02/19 18:55:12 jsg Exp $	*/
a112 1
#define MJUMPAGESIZE	MCLBYTES
a120 6
extern uint16_t ixgbe_read_pci_cfg(struct ixgbe_hw *, uint32_t);
#define IXGBE_READ_PCIE_WORD ixgbe_read_pci_cfg

extern void ixgbe_write_pci_cfg(struct ixgbe_hw *, uint32_t, uint16_t);
#define IXGBE_WRITE_PCIE_WORD ixgbe_write_pci_cfg

d133 6
d149 1
a149 1
	((struct ixgbe_osdep *)(a)->back)->os_memh, (reg + ((offset) << 2))))
d165 1
d168 3
d182 1
d216 3
d231 10
d244 10
d277 1
d292 1
d301 13
@


1.5
log
@Partial sync to the latest version of ixgbe in FreeBSD leaving things
like if_ix.c mostly untouched for now.  This brings in support for
newer 82598 parts and adds several things that will be needed for 82599.

Initially from claudio with some additions by me.

Tested by claudio, dlg (earlier version) and myself on different cards
and media types.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.4 2009/06/04 22:27:31 jsg Exp $	*/
d228 1
@


1.4
log
@switch to a bnx style dynamic pool backed tx so we don't
have to allocate everything up front.

Requested by reyk@@, 'I'm fine with it' dlg@@, 'commit it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.3 2008/06/08 21:15:34 reyk Exp $	*/
d92 6
a97 5
#define DEBUGOUT(S)         printf(S "\n")
#define DEBUGOUT1(S,A)      printf(S "\n",A)
#define DEBUGOUT2(S,A,B)    printf(S "\n",A,B)
#define DEBUGOUT3(S,A,B,C)  printf(S "\n",A,B,C)
#define DEBUGOUT7(S,A,B,C,D,E,F,G)  printf(S "\n",A,B,C,D,E,F,G)
d125 3
d155 8
d170 1
d178 1
a178 1
int32_t ixgbe_read_eeprom_generic(struct ixgbe_hw *hw, uint16_t offset, uint16_t *data);
d181 1
d185 1
d189 1
d198 5
a202 3
int32_t ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);
int32_t ixgbe_set_vfta_generic(struct ixgbe_hw *hw, uint32_t vlan,
                           uint32_t vind, int vlan_on);
d209 2
a210 2
int32_t ixgbe_read_analog_reg8_generic(struct ixgbe_hw *hw, uint32_t reg, uint8_t *val);
int32_t ixgbe_write_analog_reg8_generic(struct ixgbe_hw *hw, uint32_t reg, uint8_t val);
d212 13
d226 1
d245 3
d252 1
d255 2
d259 12
@


1.3
log
@more cleanup, removed unused code. we don't do LRO/RSS yet, code can
be added later if we ever support it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.2 2008/06/08 20:33:51 reyk Exp $	*/
d52 2
@


1.2
log
@replace strange Linux-style u8/u16/u32/u64/s32 integer types with the
standard C99 uint*_t/int*_t types (i don't get why these drivers
always use their own types when there is a well-defined standard).
@
text
@d1 1
a1 1
/*	$OpenBSD: ixgbe.h,v 1.1 2008/06/08 20:01:02 reyk Exp $	*/
d37 2
a38 2
#ifndef _IXGBE_OS_H_
#define _IXGBE_OS_H_
d79 2
a83 3

#include <dev/rndvar.h>

a85 6
#define ASSERT(x) if(!(x)) panic("IXGBE: x")

/* The happy-fun DELAY macro is defined in /usr/src/sys/i386/include/clock.h */
#define usec_delay(x) DELAY(x)
#define msec_delay(x) DELAY(1000*(x))

d104 2
a105 2
#define FALSE               0
#define TRUE                1
d109 6
a114 4
typedef struct device device_t;
#define TUNABLE_INT(x...)
#define DRIVER_MODULE(x...)
#define MODULE_DEPEND(x...)
d118 1
d134 2
a135 2
#define IXGBE_WRITE_FLUSH(a) IXGBE_READ_REG(a, IXGBE_STATUS)

a148 5
/* FreeBSD compat glue */
#define MJUMPAGESIZE	MCLBYTES
#define PCIR_BAR(_x)	(0x10 + (_x) * 4)
#define roundup2(size, unit) (((size) + (unit) - 1) & ~((unit) - 1))

d219 1
a219 2

#endif /* _IXGBE_OS_H_ */
@


1.1
log
@Import ix, a driver for the Intel 82598 PCI-Express 10 Gig Ethernet Adapter,
based on Intel's ixgbe driver.

Done on borrowed hardware since Intel was too poor to give us a card.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a84 7
typedef uint8_t  u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef int32_t	 s32;
typedef uint64_t u64;
typedef boolean_t bool;

d123 1
a123 1
extern u16 ixgbe_read_pci_cfg(struct ixgbe_hw *, u32);
d158 26
a183 26
s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw);
s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw);
s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw);
s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);
s32 ixgbe_read_pba_num_generic(struct ixgbe_hw *hw, u32 *pba_num);
s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr);
s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);
s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);

s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index);
s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index);

s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw);
s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data);
s32 ixgbe_read_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 *data);
s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
                                       u16 *data);
s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
                                           u16 *checksum_val);
s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);

s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
                          u32 enable_addr);
s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);
s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
                                      u32 mc_addr_count,
d185 12
a196 12
s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
                                      u32 addr_count, ixgbe_mc_addr_itr func);
s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw);
s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw);
s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);
s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan,
                           u32 vind, bool vlan_on);

s32 ixgbe_validate_mac_addr(u8 *mac_addr);
s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u16 mask);
void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u16 mask);
s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw);
d198 2
a199 2
s32 ixgbe_read_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 *val);
s32 ixgbe_write_analog_reg8_generic(struct ixgbe_hw *hw, u32 reg, u8 val);
d201 2
a202 2
void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr);
s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw);
d205 12
a216 12
s32 ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw);
bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, u32 phy_addr);
enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);
s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);
s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw);
s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw);
s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
                               u32 device_type, u16 *phy_data);
s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
                                u32 device_type, u16 phy_data);
s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw);
s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
d218 2
a219 2
                                       bool autoneg,
                                       bool autoneg_wait_to_complete);
d221 1
a221 1
s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw,
d223 3
a225 3
                             bool *link_up);
s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
                                       u16 *firmware_version);
d227 1
a227 1
s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
@

