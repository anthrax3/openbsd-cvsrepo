head	1.106;
access;
symbols
	OPENBSD_6_2:1.106.0.2
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.106.0.4
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.104.0.8
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.104.0.4
	OPENBSD_5_8_BASE:1.104
	OPENBSD_5_7:1.102.0.4
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.99.0.4
	OPENBSD_5_5_BASE:1.99
	OPENBSD_5_4:1.98.0.2
	OPENBSD_5_4_BASE:1.98
	OPENBSD_5_3:1.96.0.6
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.96.0.4
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.2
	OPENBSD_5_0:1.95.0.2
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.93.0.2
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.86.0.2
	OPENBSD_4_8_BASE:1.86
	OPENBSD_4_7:1.80.0.2
	OPENBSD_4_7_BASE:1.80
	OPENBSD_4_6:1.78.0.6
	OPENBSD_4_6_BASE:1.78
	OPENBSD_4_5:1.78.0.2
	OPENBSD_4_5_BASE:1.78
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.63.0.2
	OPENBSD_4_1_BASE:1.63
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.58.0.2
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.56.0.2
	OPENBSD_3_8_BASE:1.56
	OPENBSD_3_7:1.45.0.2
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.28
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	SMP:1.8.0.4
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2;
locks; strict;
comment	@ * @;


1.106
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.105;
commitid	qGgYgJTgEFuAoGj4;

1.105
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.104;
commitid	pi1a9KN0itEngOc4;

1.104
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.103;
commitid	RaOGL5SyOGOZylwx;

1.103
date	2015.03.14.03.38.48;	author jsg;	state Exp;
branches;
next	1.102;
commitid	p4LJxGKbi0BU2cG6;

1.102
date	2014.09.24.08.35.12;	author mpi;	state Exp;
branches;
next	1.101;
commitid	eVKYrJEBlSMUGiA3;

1.101
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.100;
commitid	OBNa5kfxQ2UXoiIw;

1.100
date	2014.05.17.12.40.25;	author ratchov;	state Exp;
branches;
next	1.99;

1.99
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.97;

1.97
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.96;

1.96
date	2012.01.11.16.22.33;	author dhill;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2011.04.03.15.36.02;	author jasper;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.12.03.17.34;	author jakemsr;	state Exp;
branches;
next	1.92;

1.92
date	2010.09.12.02.04.31;	author jakemsr;	state Exp;
branches;
next	1.91;

1.91
date	2010.09.07.16.21.44;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2010.09.06.19.20.22;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.31.17.13.44;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2010.08.31.06.12.28;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2010.08.27.18.50.56;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2010.08.09.05.43.48;	author jakemsr;	state Exp;
branches;
next	1.85;

1.85
date	2010.08.08.20.37.33;	author jakemsr;	state Exp;
branches;
next	1.84;

1.84
date	2010.08.03.22.58.58;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.07.23.35.24;	author ratchov;	state Exp;
branches;
next	1.81;

1.81
date	2010.03.30.09.38.07;	author dcoppa;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.14.18.15.27;	author ratchov;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.05.01.29.06;	author jakemsr;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.28.03.57.42;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.76;

1.76
date	2008.10.23.21.50.01;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.23.21.28.31;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.15.22.40.50;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.25.23.59.33;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.24.07.03.16;	author jakemsr;	state Exp;
branches;
next	1.70;

1.70
date	2008.02.12.11.25.57;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2008.02.08.14.35.01;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2008.01.15.02.52.50;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.23.19.59.27;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.20.02.40.54;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.17.00.50.46;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.02.07.43.41;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.19.19.06.51;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2006.08.01.21.36.54;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.29.08.46.58;	author jsg;	state Exp;
branches;
next	1.59;

1.59
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.13.06.15.32;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.26.14.31.26;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2005.08.10.15.28.35;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2005.08.09.04.10.10;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.04.13.22.49;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.31.19.17.03;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.14.12.42.16;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.05.21.08.47;	author marc;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.05.17.30.57;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.05.17.19.01;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.05.01.41.44;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.02.01.20.56;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.22.20.03.07;	author marc;	state Exp;
branches;
next	1.45;

1.45
date	2005.01.17.20.37.04;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.17.20.07.44;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.30.22.30.47;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2004.09.20.17.27.53;	author grange;	state Exp;
branches;
next	1.41;

1.41
date	2004.07.21.04.05.33;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.08.00.34.47;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.10.20.12.49;	author marc;	state Exp;
branches;
next	1.38;

1.38
date	2004.04.09.07.24.15;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.10.04.38.56;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.06.21.08.06;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.12.18.08.09;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.20.00.22.56;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.19.20.15.02;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.01.21.13.04.59;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.16.14.20.27;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.17.19.10.30;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.04.23.52.20;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.24.20.41.19;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.19.15.27.43;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.03.16.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.58;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.31.04.19.55;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.19.04.14.32;	author provos;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.12.18.23.02.39;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.18.22.55.25;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.10.24.03.43.48;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.10.17.38.54;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.05.03.07.44;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.12.15.40.30;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.06.22.11.29;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.16.23.38.04;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.16.06.29.15;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.16.03.18.18;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.03.09.09.26.45;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.11.21.40.05;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.11.19.22.33;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.20.17.48.58;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.11.06.17.18;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.18.21.33.11;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.30.16.30.38;	author mickey;	state Exp;
branches;
next	;

1.8.4.1
date	2001.05.14.22.25.33;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.07.04.10.41.53;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2001.10.31.03.22.45;	author nate;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2002.03.06.02.11.45;	author niklas;	state Exp;
branches;
next	1.8.4.6;

1.8.4.6
date	2002.03.28.15.35.57;	author niklas;	state Exp;
branches;
next	1.8.4.7;

1.8.4.7
date	2003.03.28.00.38.20;	author niklas;	state Exp;
branches;
next	1.8.4.8;

1.8.4.8
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.8.4.9;

1.8.4.9
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.8.4.10;

1.8.4.10
date	2004.02.19.10.56.25;	author niklas;	state Exp;
branches;
next	1.8.4.11;

1.8.4.11
date	2004.06.05.23.12.48;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.01.31.22.55.34;	author niklas;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.06.11.03.42.24;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.10.29.00.33.27;	author art;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2003.05.19.22.17.59;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: auich.c,v 1.105 2016/09/14 06:12:19 ratchov Exp $	*/

/*
 * Copyright (c) 2000,2001 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * AC'97 audio found on Intel 810/815/820/440MX chipsets.
 *	http://developer.intel.com/design/chipsets/datashts/290655.htm
 *	http://developer.intel.com/design/chipsets/manuals/298028.htm
 *	http://www.intel.com/design/chipsets/datashts/290714.htm
 *	http://www.intel.com/design/chipsets/datashts/290744.htm
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <dev/pci/pcidevs.h>
#include <dev/pci/pcivar.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <machine/bus.h>

#include <dev/ic/ac97.h>

/* 12.1.10 NAMBAR - native audio mixer base address register */
#define	AUICH_NAMBAR	0x10
/* 12.1.11 NABMBAR - native audio bus mastering base address register */
#define	AUICH_NABMBAR	0x14
#define	AUICH_CFG	0x41
#define	AUICH_CFG_IOSE	0x01
/* ICH4/ICH5/ICH6/ICH7 native audio mixer BAR */
#define	AUICH_MMBAR	0x18
/* ICH4/ICH5/ICH6/ICH7 native bus mastering BAR */
#define	AUICH_MBBAR	0x1c
#define	AUICH_S2CR	0x10000000	/* tertiary codec ready */

/* table 12-3. native audio bus master control registers */
#define	AUICH_BDBAR	0x00	/* 8-byte aligned address */
#define	AUICH_CIV		0x04	/* 5 bits current index value */
#define	AUICH_LVI		0x05	/* 5 bits last valid index value */
#define		AUICH_LVI_MASK	0x1f
#define	AUICH_STS		0x06	/* 16 bits status */
#define		AUICH_FIFOE	0x10	/* fifo error */
#define		AUICH_BCIS	0x08	/* r- buf cmplt int sts; wr ack */
#define		AUICH_LVBCI	0x04	/* r- last valid bci, wr ack */
#define		AUICH_CELV	0x02	/* current equals last valid */
#define		AUICH_DCH	0x01	/* dma halted */
#define		AUICH_ISTS_BITS	"\020\01dch\02celv\03lvbci\04bcis\05fifoe"
#define	AUICH_PICB	0x08	/* 16 bits */
#define	AUICH_PIV		0x0a	/* 5 bits prefetched index value */
#define	AUICH_CTRL	0x0b	/* control */
#define		AUICH_IOCE	0x10	/* int on completion enable */
#define		AUICH_FEIE	0x08	/* fifo error int enable */
#define		AUICH_LVBIE	0x04	/* last valid buf int enable */
#define		AUICH_RR		0x02	/* 1 - reset regs */
#define		AUICH_RPBM	0x01	/* 1 - run, 0 - pause */

#define	AUICH_PCMI	0x00
#define	AUICH_PCMO	0x10
#define	AUICH_MICI	0x20

#define	AUICH_GCTRL	0x2c
#define		AUICH_SSM_78	0x40000000	/* S/PDIF slots 7 and 8 */
#define		AUICH_SSM_69	0x80000000	/* S/PDIF slots 6 and 9 */
#define		AUICH_SSM_1011	0xc0000000	/* S/PDIF slots 10 and 11 */
#define		AUICH_POM16	0x000000	/* PCM out precision 16bit */
#define		AUICH_POM20	0x400000	/* PCM out precision 20bit */
#define		AUICH_PCM246_MASK 0x300000
#define		AUICH_PCM2	0x000000	/* 2ch output */
#define		AUICH_PCM4	0x100000	/* 4ch output */
#define		AUICH_PCM6	0x200000	/* 6ch output */
#define		AUICH_SIS_PCM246_MASK 0x0000c0	/* SiS 7012 */
#define		AUICH_SIS_PCM2	0x000000	/* SiS 7012 2ch output */
#define		AUICH_SIS_PCM4	0x000040	/* SiS 7012 4ch output */
#define		AUICH_SIS_PCM6	0x000080	/* SiS 7012 6ch output */
#define		AUICH_S2RIE	0x40	/* int when tertiary codec resume */
#define		AUICH_SRIE	0x20	/* int when 2ndary codec resume */
#define		AUICH_PRIE	0x10	/* int when primary codec resume */
#define		AUICH_ACLSO	0x08	/* aclink shut off */
#define		AUICH_WRESET	0x04	/* warm reset */
#define		AUICH_CRESET	0x02	/* cold reset */
#define		AUICH_GIE		0x01	/* gpi int enable */
#define	AUICH_GSTS	0x30
#define		AUICH_MD3		0x20000	/* pwr-dn semaphore for modem */
#define		AUICH_AD3		0x10000	/* pwr-dn semaphore for audio */
#define		AUICH_RCS		0x08000	/* read completion status */
#define		AUICH_B3S12	0x04000	/* bit 3 of slot 12 */
#define		AUICH_B2S12	0x02000	/* bit 2 of slot 12 */
#define		AUICH_B1S12	0x01000	/* bit 1 of slot 12 */
#define		AUICH_SRI		0x00800	/* secondary resume int */
#define		AUICH_PRI		0x00400	/* primary resume int */
#define		AUICH_SCR		0x00200	/* secondary codec ready */
#define		AUICH_PCR		0x00100	/* primary codec ready */
#define		AUICH_MINT	0x00080	/* mic in int */
#define		AUICH_POINT	0x00040	/* pcm out int */
#define		AUICH_PIINT	0x00020	/* pcm in int */
#define		AUICH_MOINT	0x00004	/* modem out int */
#define		AUICH_MIINT	0x00002	/* modem in int */
#define		AUICH_GSCI	0x00001	/* gpi status change */
#define		AUICH_GSTS_BITS	"\020\01gsci\02miict\03moint\06piint\07point\010mint\011pcr\012scr\013pri\014sri\015b1s12\016b2s12\017b3s12\020rcs\021ad3\022md3"
#define	AUICH_CAS		0x34	/* 1/8 bit */
#define	AUICH_SEMATIMO		1000	/* us */
#define	AUICH_RESETIMO		500000	/* us */

#define	ICH_SIS_NV_CTL	0x4c	/* some SiS/NVIDIA register.  From Linux */
#define		ICH_SIS_CTL_UNMUTE	0x01	/* un-mute the output */

/*
 * There are 32 buffer descriptors.  Each can reference up to 2^16 16-bit
 * samples.
 */
#define	AUICH_DMALIST_MAX	32
#define	AUICH_DMASEG_MAX	(65536*2)
struct auich_dmalist {
	u_int32_t	base;
	u_int32_t	len;
#define	AUICH_DMAF_IOC	0x80000000	/* 1-int on complete */
#define	AUICH_DMAF_BUP	0x40000000	/* 0-retrans last, 1-transmit 0 */
};

#define	AUICH_FIXED_RATE 48000

struct auich_dma {
	bus_dmamap_t map;
	caddr_t addr;
	bus_dma_segment_t segs[1];
	int nsegs;
	size_t size;
};

struct auich_cdata {
	struct auich_dmalist ic_dmalist_pcmo[AUICH_DMALIST_MAX];
	struct auich_dmalist ic_dmalist_pcmi[AUICH_DMALIST_MAX];
	struct auich_dmalist ic_dmalist_mici[AUICH_DMALIST_MAX];
};

#define	AUICH_CDOFF(x)		offsetof(struct auich_cdata, x)
#define	AUICH_PCMO_OFF(x)	AUICH_CDOFF(ic_dmalist_pcmo[(x)])
#define	AUICH_PCMI_OFF(x)	AUICH_CDOFF(ic_dmalist_pcmi[(x)])
#define	AUICH_MICI_OFF(x)	AUICH_CDOFF(ic_dmalist_mici[(x)])

struct auich_softc {
	struct device sc_dev;
	void *sc_ih;

	pcireg_t pci_id;
	bus_space_tag_t iot;
	bus_space_tag_t iot_mix;
	bus_space_handle_t mix_ioh;
	bus_space_handle_t aud_ioh;
	bus_dma_tag_t dmat;

	struct ac97_codec_if *codec_if;
	struct ac97_host_if host_if;
	int sc_spdif;

	/* dma scatter-gather buffer lists */

	bus_dmamap_t sc_cddmamap;
#define	sc_cddma	sc_cddmamap->dm_segs[0].ds_addr

	struct auich_cdata *sc_cdata;

	struct auich_ring {
		int qptr;
		struct auich_dmalist *dmalist;

		uint32_t start, p, end;
		int blksize;

		void (*intr)(void *);
		void *arg;
		int running;
		size_t size;
		uint32_t ap;
	} pcmo, pcmi, mici;

	struct auich_dma *sc_pdma;	/* play */
	struct auich_dma *sc_rdma;	/* record */
	struct auich_dma *sc_cdma;	/* calibrate */

#ifdef AUICH_DEBUG
	int pcmi_fifoe;
	int pcmo_fifoe;
#endif

	int suspend;
	u_int16_t ext_ctrl;
	int sc_sample_size;
	int sc_sts_reg;
	int sc_dmamap_flags;
	int sc_ignore_codecready;
	int flags;
	int sc_ac97rate;

	/* multi-channel control bits */
	int sc_pcm246_mask;
	int sc_pcm2;
	int sc_pcm4;
	int sc_pcm6;

	u_int last_rrate;
	u_int last_prate;
	u_int last_pchan;
};

#ifdef AUICH_DEBUG
#define	DPRINTF(l,x)	do { if (auich_debug & (l)) printf x; } while(0)
int auich_debug = 0x0002;
#define	AUICH_DEBUG_CODECIO	0x0001
#define	AUICH_DEBUG_DMA		0x0002
#define	AUICH_DEBUG_INTR	0x0004
#else
#define	DPRINTF(x,y)	/* nothing */
#endif

struct cfdriver	auich_cd = {
	NULL, "auich", DV_DULL
};

int  auich_match(struct device *, void *, void *);
void auich_attach(struct device *, struct device *, void *);
int  auich_intr(void *);

int auich_activate(struct device *, int);

struct cfattach auich_ca = {
	sizeof(struct auich_softc), auich_match, auich_attach,
	NULL, auich_activate
};

static const struct auich_devtype {
	int	vendor;
	int	product;
	int	options;
	char	name[8];
} auich_devices[] = {
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6300ESB_ACA,	0, "ESB" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6321ESB_ACA,	0, "ESB2" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AA_ACA,	0, "ICH" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AB_ACA,	0, "ICH0" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801BA_ACA,	0, "ICH2" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801CA_ACA,	0, "ICH3" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801DB_ACA,	0, "ICH4" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801EB_ACA,	0, "ICH5" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801FB_ACA,	0, "ICH6" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GB_ACA,	0, "ICH7" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82440MX_ACA,	0, "440MX" },
	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_7012_ACA,	0, "SiS7012" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE_ACA,	0, "nForce" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE2_ACA,	0, "nForce2" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE2_400_ACA,
	    0, "nForce2" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE3_ACA,	0, "nForce3" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE3_250_ACA,
	    0, "nForce3" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE4_AC,	0, "nForce4" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP04_AC97,	0, "MCP04" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_MCP51_ACA,	0, "MCP51" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC768_ACA,	0, "AMD768" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_8111_ACA,	0, "AMD8111" },
};

int auich_open(void *, int);
void auich_close(void *);
int auich_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int auich_round_blocksize(void *, int);
void auich_halt_pipe(struct auich_softc *, int, struct auich_ring *);
int auich_halt_output(void *);
int auich_halt_input(void *);
int auich_set_port(void *, mixer_ctrl_t *);
int auich_get_port(void *, mixer_ctrl_t *);
int auich_query_devinfo(void *, mixer_devinfo_t *);
void *auich_allocm(void *, int, size_t, int, int);
void auich_freem(void *, void *, int);
size_t auich_round_buffersize(void *, int, size_t);
int auich_get_props(void *);
void auich_trigger_pipe(struct auich_softc *, int, struct auich_ring *);
void auich_intr_pipe(struct auich_softc *, int, struct auich_ring *);
int auich_trigger_output(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
int auich_trigger_input(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
int auich_alloc_cdata(struct auich_softc *);
int auich_allocmem(struct auich_softc *, size_t, size_t, struct auich_dma *);
int auich_freemem(struct auich_softc *, struct auich_dma *);

int auich_resume(struct auich_softc *);

struct audio_hw_if auich_hw_if = {
	auich_open,
	auich_close,
	auich_set_params,
	auich_round_blocksize,
	NULL,			/* commit_setting */
	NULL,			/* init_output */
	NULL,			/* init_input */
	NULL,			/* start_output */
	NULL,			/* start_input */
	auich_halt_output,
	auich_halt_input,
	NULL,			/* speaker_ctl */
	NULL,			/* getfd */
	auich_set_port,
	auich_get_port,
	auich_query_devinfo,
	auich_allocm,
	auich_freem,
	auich_round_buffersize,
	auich_get_props,
	auich_trigger_output,
	auich_trigger_input
};

int  auich_attach_codec(void *, struct ac97_codec_if *);
int  auich_read_codec(void *, u_int8_t, u_int16_t *);
int  auich_write_codec(void *, u_int8_t, u_int16_t);
void auich_reset_codec(void *);
enum ac97_host_flags auich_flags_codec(void *);
unsigned int auich_calibrate(struct auich_softc *);
void auich_spdif_event(void *, int);

int
auich_match(struct device *parent, void *match, void *aux)
{
	struct pci_attach_args *pa = aux;
	int i;

	for (i = nitems(auich_devices); i--;)
		if (PCI_VENDOR(pa->pa_id) == auich_devices[i].vendor &&
		    PCI_PRODUCT(pa->pa_id) == auich_devices[i].product)
			return 1;

	return 0;
}

void
auich_attach(struct device *parent, struct device *self, void *aux)
{
	struct auich_softc *sc = (struct auich_softc *)self;
	struct pci_attach_args *pa = aux;
	pci_intr_handle_t ih;
	bus_size_t mix_size, aud_size;
	pcireg_t csr;
	const char *intrstr;
	u_int32_t status;
	int i;

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DB_ACA ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801EB_ACA ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801FB_ACA ||
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801GB_ACA)) {
		/*
		 * Use native mode for ICH4/ICH5/ICH6/ICH7
		 */
		if (pci_mapreg_map(pa, AUICH_MMBAR, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->iot_mix, &sc->mix_ioh, NULL, &mix_size, 0)) {
			csr = pci_conf_read(pa->pa_pc, pa->pa_tag, AUICH_CFG);
			pci_conf_write(pa->pa_pc, pa->pa_tag, AUICH_CFG,
			    csr | AUICH_CFG_IOSE);
			if (pci_mapreg_map(pa, AUICH_NAMBAR, PCI_MAPREG_TYPE_IO,
			    0, &sc->iot_mix, &sc->mix_ioh, NULL, &mix_size, 0)) {
				printf(": can't map codec mem/io space\n");
				return;
			}
		}

		if (pci_mapreg_map(pa, AUICH_MBBAR, PCI_MAPREG_TYPE_MEM, 0,
		    &sc->iot, &sc->aud_ioh, NULL, &aud_size, 0)) {
			csr = pci_conf_read(pa->pa_pc, pa->pa_tag, AUICH_CFG);
			pci_conf_write(pa->pa_pc, pa->pa_tag, AUICH_CFG,
			    csr | AUICH_CFG_IOSE);
			if (pci_mapreg_map(pa, AUICH_NABMBAR,
			    PCI_MAPREG_TYPE_IO, 0, &sc->iot,
			    &sc->aud_ioh, NULL, &aud_size, 0)) {
				printf(": can't map device mem/io space\n");
				bus_space_unmap(sc->iot_mix, sc->mix_ioh, mix_size);
				return;
			}
		}
	} else {
		if (pci_mapreg_map(pa, AUICH_NAMBAR, PCI_MAPREG_TYPE_IO,
		    0, &sc->iot_mix, &sc->mix_ioh, NULL, &mix_size, 0)) {
			printf(": can't map codec i/o space\n");
			return;
		}

		if (pci_mapreg_map(pa, AUICH_NABMBAR, PCI_MAPREG_TYPE_IO,
		    0, &sc->iot, &sc->aud_ioh, NULL, &aud_size, 0)) {
			printf(": can't map device i/o space\n");
			bus_space_unmap(sc->iot_mix, sc->mix_ioh, mix_size);
			return;
		}
	}
	sc->dmat = pa->pa_dmat;
	sc->pci_id = pa->pa_id;

	if (pci_intr_map(pa, &ih)) {
		printf(": can't map interrupt\n");
		bus_space_unmap(sc->iot, sc->aud_ioh, aud_size);
		bus_space_unmap(sc->iot_mix, sc->mix_ioh, mix_size);
		return;
	}
	intrstr = pci_intr_string(pa->pa_pc, ih);
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO | IPL_MPSAFE,
	    auich_intr, sc, sc->sc_dev.dv_xname);
	if (!sc->sc_ih) {
		printf(": can't establish interrupt");
		if (intrstr)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(sc->iot, sc->aud_ioh, aud_size);
		bus_space_unmap(sc->iot_mix, sc->mix_ioh, mix_size);
		return;
	}

	for (i = nitems(auich_devices); i--;)
		if (PCI_PRODUCT(pa->pa_id) == auich_devices[i].product)
			break;

	printf(": %s, %s\n", intrstr, auich_devices[i].name);

	/* SiS 7012 needs special handling */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_7012_ACA) {
		sc->sc_sts_reg = AUICH_PICB;
		sc->sc_sample_size = 1;
		sc->sc_pcm246_mask = AUICH_SIS_PCM246_MASK;
		sc->sc_pcm2 = AUICH_SIS_PCM2;
		sc->sc_pcm4 = AUICH_SIS_PCM4;
		sc->sc_pcm6 = AUICH_SIS_PCM6;
		/* un-mute output */
		bus_space_write_4(sc->iot, sc->aud_ioh, ICH_SIS_NV_CTL,
		    bus_space_read_4(sc->iot, sc->aud_ioh, ICH_SIS_NV_CTL) |
		    ICH_SIS_CTL_UNMUTE);
	} else {
		sc->sc_sts_reg = AUICH_STS;
		sc->sc_sample_size = 2;
		sc->sc_pcm246_mask = AUICH_PCM246_MASK;
		sc->sc_pcm2 = AUICH_PCM2;
		sc->sc_pcm4 = AUICH_PCM4;
		sc->sc_pcm6 = AUICH_PCM6;
	}

	/* Workaround for a 440MX B-stepping erratum */
	sc->sc_dmamap_flags = BUS_DMA_COHERENT;
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82440MX_ACA) {
		sc->sc_dmamap_flags |= BUS_DMA_NOCACHE;
		printf("%s: DMA bug workaround enabled\n", sc->sc_dev.dv_xname);
	}

	/* Set up DMA lists. */
	sc->pcmo.qptr = sc->pcmi.qptr = sc->mici.qptr = 0;
	auich_alloc_cdata(sc);

	DPRINTF(AUICH_DEBUG_DMA, ("auich_attach: lists %p %p %p\n",
	    sc->pcmo.dmalist, sc->pcmi.dmalist, sc->mici.dmalist));

	/* Reset codec and AC'97 */
	auich_reset_codec(sc);
	status = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS);
	if (!(status & AUICH_PCR)) {	/* reset failure */
		if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
		    (PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DB_ACA ||
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801EB_ACA ||
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801FB_ACA ||
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801GB_ACA)) {
			/* MSI 845G Max never return AUICH_PCR */
			sc->sc_ignore_codecready = 1;
		} else {
			printf("%s: reset failed!\n", sc->sc_dev.dv_xname);
			return;
		}
	}

	sc->host_if.arg = sc;
	sc->host_if.attach = auich_attach_codec;
	sc->host_if.read = auich_read_codec;
	sc->host_if.write = auich_write_codec;
	sc->host_if.reset = auich_reset_codec;
	sc->host_if.flags = auich_flags_codec;
	sc->host_if.spdif_event = auich_spdif_event;
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001)
		sc->flags = AC97_HOST_SWAPPED_CHANNELS;

	if (ac97_attach(&sc->host_if) != 0) {
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
		bus_space_unmap(sc->iot, sc->aud_ioh, aud_size);
		bus_space_unmap(sc->iot_mix, sc->mix_ioh, mix_size);
		return;
	}
	sc->codec_if->vtbl->unlock(sc->codec_if);

	audio_attach_mi(&auich_hw_if, sc, &sc->sc_dev);

	/* Watch for power changes */
	sc->suspend = DVACT_RESUME;

	sc->sc_ac97rate = -1;
}

int
auich_activate(struct device *self, int act)
{
	struct auich_softc *sc = (struct auich_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		auich_resume(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
auich_read_codec(void *v, u_int8_t reg, u_int16_t *val)
{
	struct auich_softc *sc = v;
	int i;

	/* wait for an access semaphore */
	for (i = AUICH_SEMATIMO; i-- &&
	    bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_CAS) & 1; DELAY(1));

	if (!sc->sc_ignore_codecready && i < 0) {
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("%s: read_codec timeout\n", sc->sc_dev.dv_xname));
		return (-1);
	}

	*val = bus_space_read_2(sc->iot_mix, sc->mix_ioh, reg);
	DPRINTF(AUICH_DEBUG_CODECIO, ("%s: read_codec(%x, %x)\n",
	    sc->sc_dev.dv_xname, reg, *val));
	return (0);
}

int
auich_write_codec(void *v, u_int8_t reg, u_int16_t val)
{
	struct auich_softc *sc = v;
	int i;

	/* wait for an access semaphore */
	for (i = AUICH_SEMATIMO; i-- &&
	    bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_CAS) & 1; DELAY(1));

	if (sc->sc_ignore_codecready || i >= 0) {
		DPRINTF(AUICH_DEBUG_CODECIO, ("%s: write_codec(%x, %x)\n",
		    sc->sc_dev.dv_xname, reg, val));
		bus_space_write_2(sc->iot_mix, sc->mix_ioh, reg, val);
		return (0);
	} else {
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("%s: write_codec timeout\n", sc->sc_dev.dv_xname));
		return (-1);
	}
}

int
auich_attach_codec(void *v, struct ac97_codec_if *cif)
{
	struct auich_softc *sc = v;

	sc->codec_if = cif;
	return 0;
}

void
auich_reset_codec(void *v)
{
	struct auich_softc *sc = v;
	u_int32_t control;
	int i;

	control = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GCTRL);
	control &= ~(AUICH_ACLSO | sc->sc_pcm246_mask);
	control |= (control & AUICH_CRESET) ? AUICH_WRESET : AUICH_CRESET;
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GCTRL, control);

	for (i = AUICH_RESETIMO; i-- &&
	    !(bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS) & AUICH_PCR);
	    DELAY(1));

	if (i < 0)
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("%s: reset_codec timeout\n", sc->sc_dev.dv_xname));
}

enum ac97_host_flags
auich_flags_codec(void *v)
{
	struct auich_softc *sc = v;

	return (sc->flags);
}

void
auich_spdif_event(void *v, int flag)
{
	struct auich_softc *sc = v;
	sc->sc_spdif = flag;
}

int
auich_open(void *v, int flags)
{
	struct auich_softc *sc = v;

	if (sc->sc_ac97rate == -1)
		sc->sc_ac97rate = auich_calibrate(sc);

	sc->codec_if->vtbl->lock(sc->codec_if);

	return 0;
}

void
auich_close(void *v)
{
	struct auich_softc *sc = v;

	sc->codec_if->vtbl->unlock(sc->codec_if);
}

int
auich_set_params(void *v, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct auich_softc *sc = v;
	struct ac97_codec_if *codec = sc->codec_if;
	int error;
	u_int orate;
	u_int adj_rate;
	u_int32_t control;
	u_int16_t ext_id;

	if (setmode & AUMODE_PLAY) {
		/* only 16-bit 48kHz slinear_le if s/pdif enabled */
		if (sc->sc_spdif) {
			play->sample_rate = 48000;
			play->precision = 16;
			play->encoding = AUDIO_ENCODING_SLINEAR_LE;
		}
	}
	if (setmode & AUMODE_PLAY) {
		play->precision = 16;
		switch(play->encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			if (play->channels > 6)
				play->channels = 6;
			if (play->channels > 1)
				play->channels &= ~1;
			switch (play->channels) {
			case 1:
				play->channels = 2;
				break;
			case 2:
				break;
			case 4:
				ext_id = codec->vtbl->get_caps(codec);
				if (!(ext_id & AC97_EXT_AUDIO_SDAC))
					play->channels = 2;
				break;
			case 6:
				ext_id = codec->vtbl->get_caps(codec);
				if ((ext_id & AC97_BITS_6CH) !=
				    AC97_BITS_6CH)
					play->channels = 2;
				break;
			default:
				return (EINVAL);
			}
			break;
		default:
			return (EINVAL);
		}
		play->bps = AUDIO_BPS(play->precision);
		play->msb = 1;

		orate = adj_rate = play->sample_rate;
		if (sc->sc_ac97rate != 0)
			adj_rate = orate * AUICH_FIXED_RATE / sc->sc_ac97rate;

		play->sample_rate = adj_rate;
		sc->last_prate = play->sample_rate;

		error = ac97_set_rate(sc->codec_if,
		    AC97_REG_PCM_LFE_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

		play->sample_rate = adj_rate;
		error = ac97_set_rate(sc->codec_if,
		    AC97_REG_PCM_SURR_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

		play->sample_rate = adj_rate;
		error = ac97_set_rate(sc->codec_if,
		    AC97_REG_PCM_FRONT_DAC_RATE, &play->sample_rate);
		if (error)
			return (error);

		if (play->sample_rate == adj_rate)
			play->sample_rate = orate;

		control = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GCTRL);
		control &= ~(sc->sc_pcm246_mask);
		if (play->channels == 4)
			control |= sc->sc_pcm4;
		else if (play->channels == 6)
			control |= sc->sc_pcm6;
		bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GCTRL, control);

		sc->last_pchan = play->channels;
	}

	if (setmode & AUMODE_RECORD) {
		rec->channels = 2;
		rec->precision = 16;
		rec->encoding = AUDIO_ENCODING_SLINEAR_LE;
		rec->bps = AUDIO_BPS(rec->precision);
		rec->msb = 1;

		orate = rec->sample_rate;
		if (sc->sc_ac97rate != 0)
			rec->sample_rate = orate * AUICH_FIXED_RATE /
			    sc->sc_ac97rate;
		sc->last_rrate = rec->sample_rate;
		error = ac97_set_rate(sc->codec_if, AC97_REG_PCM_LR_ADC_RATE,
		    &rec->sample_rate);
		if (error)
			return (error);
		rec->sample_rate = orate;
	}

	return (0);
}

int
auich_round_blocksize(void *v, int blk)
{
	return (blk + 0x3f) & ~0x3f;
}


void
auich_halt_pipe(struct auich_softc *sc, int pipe, struct auich_ring *ring)
{
	int i;
	uint32_t sts;

	bus_space_write_1(sc->iot, sc->aud_ioh, pipe + AUICH_CTRL, 0);

	/* wait for DMA halted and clear interrupt / event bits if needed */
	for (i = 0; i < 1000; i++) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    pipe + sc->sc_sts_reg);
		if (sts & (AUICH_CELV | AUICH_LVBCI | AUICH_BCIS | AUICH_FIFOE))
			bus_space_write_2(sc->iot, sc->aud_ioh,
			    pipe + sc->sc_sts_reg,
			    AUICH_CELV | AUICH_LVBCI |
			    AUICH_BCIS | AUICH_FIFOE);
		if (sts & AUICH_DCH)
			break;
		DELAY(100);
	}
	bus_space_write_1(sc->iot, sc->aud_ioh, pipe + AUICH_CTRL, AUICH_RR);

	if (i > 0)
		DPRINTF(AUICH_DEBUG_DMA,
		    ("auich_halt_pipe: halt took %d cycles\n", i));

	ring->running = 0;
}


int
auich_halt_output(void *v)
{
	struct auich_softc *sc = v;

	DPRINTF(AUICH_DEBUG_DMA, ("%s: halt_output\n", sc->sc_dev.dv_xname));

	mtx_enter(&audio_lock);
	auich_halt_pipe(sc, AUICH_PCMO, &sc->pcmo);

	sc->pcmo.intr = NULL;
	mtx_leave(&audio_lock);
	return 0;
}

int
auich_halt_input(void *v)
{
	struct auich_softc *sc = v;

	DPRINTF(AUICH_DEBUG_DMA,
	    ("%s: halt_input\n", sc->sc_dev.dv_xname));

	/* XXX halt both unless known otherwise */
	mtx_enter(&audio_lock);
	auich_halt_pipe(sc, AUICH_PCMI, &sc->pcmi);
	auich_halt_pipe(sc, AUICH_MICI, &sc->mici);

	sc->pcmi.intr = NULL;
	mtx_leave(&audio_lock);
	return 0;
}

int
auich_set_port(void *v, mixer_ctrl_t *cp)
{
	struct auich_softc *sc = v;
	return sc->codec_if->vtbl->mixer_set_port(sc->codec_if, cp);
}

int
auich_get_port(void *v, mixer_ctrl_t *cp)
{
	struct auich_softc *sc = v;
	return sc->codec_if->vtbl->mixer_get_port(sc->codec_if, cp);
}

int
auich_query_devinfo(void *v, mixer_devinfo_t *dp)
{
	struct auich_softc *sc = v;
	return sc->codec_if->vtbl->query_devinfo(sc->codec_if, dp);
}

void *
auich_allocm(void *v, int direction, size_t size, int pool, int flags)
{
	struct auich_softc *sc = v;
	struct auich_dma *p;
	int error;

	/* can only use 1 segment */
	if (size > AUICH_DMASEG_MAX) {
		DPRINTF(AUICH_DEBUG_DMA,
		    ("%s: requested buffer size too large: %zd", \
		    sc->sc_dev.dv_xname, size));
		return NULL;
	}

	p = malloc(sizeof(*p), pool, flags | M_ZERO);
	if (!p)
		return NULL;

	error = auich_allocmem(sc, size, PAGE_SIZE, p);
	if (error) {
		free(p, pool, 0);
		return NULL;
	}

	if (direction == AUMODE_PLAY)
		sc->sc_pdma = p;
	else if (direction == AUMODE_RECORD)
		sc->sc_rdma = p;
	else
		sc->sc_cdma = p;

	return p->addr;
}

void
auich_freem(void *v, void *ptr, int pool)
{
	struct auich_softc *sc;
	struct auich_dma *p;

	sc = v;
	if (sc->sc_pdma != NULL && sc->sc_pdma->addr == ptr)
		p = sc->sc_pdma;
	else if (sc->sc_rdma != NULL && sc->sc_rdma->addr == ptr)
		p = sc->sc_rdma;
	else if (sc->sc_cdma != NULL && sc->sc_cdma->addr == ptr)
		p = sc->sc_cdma;
	else
		return;

	auich_freemem(sc, p);
	free(p, pool, 0);
}

size_t
auich_round_buffersize(void *v, int direction, size_t size)
{
	if (size > AUICH_DMALIST_MAX * AUICH_DMASEG_MAX)
		size = AUICH_DMALIST_MAX * AUICH_DMASEG_MAX;

	return size;
}

int
auich_get_props(void *v)
{
	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX;
}

int
auich_intr(void *v)
{
	struct auich_softc *sc = v;
	int ret = 0, sts, gsts;

	mtx_enter(&audio_lock);
	gsts = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS);
	DPRINTF(AUICH_DEBUG_INTR, ("auich_intr: gsts=%b\n", gsts, AUICH_GSTS_BITS));

	if (gsts & AUICH_POINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg);
		DPRINTF(AUICH_DEBUG_INTR,
		    ("auich_intr: osts=%b\n", sts, AUICH_ISTS_BITS));

#ifdef AUICH_DEBUG
		if (sts & AUICH_FIFOE) {
			printf("%s: in fifo underrun # %u civ=%u ctrl=0x%x sts=%b\n",
			    sc->sc_dev.dv_xname, sc->pcmo_fifoe++,
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_PCMO + AUICH_CIV),
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_PCMO + AUICH_CTRL),
			    bus_space_read_2(sc->iot, sc->aud_ioh,
				AUICH_PCMO + sc->sc_sts_reg),
			    AUICH_ISTS_BITS);
		}
#endif

		if (sts & AUICH_BCIS)
			auich_intr_pipe(sc, AUICH_PCMO, &sc->pcmo);

		/* int ack */
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg, sts &
		    (AUICH_BCIS | AUICH_FIFOE));
		bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_POINT);
		ret++;
	}

	if (gsts & AUICH_PIINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg);
		DPRINTF(AUICH_DEBUG_INTR,
		    ("auich_intr: ists=%b\n", sts, AUICH_ISTS_BITS));

#ifdef AUICH_DEBUG
		if (sts & AUICH_FIFOE) {
			printf("%s: in fifo overrun # %u civ=%u ctrl=0x%x sts=%b\n",
			    sc->sc_dev.dv_xname, sc->pcmi_fifoe++,
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_PCMI + AUICH_CIV),
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_PCMI + AUICH_CTRL),
			    bus_space_read_2(sc->iot, sc->aud_ioh,
				AUICH_PCMI + sc->sc_sts_reg),
			    AUICH_ISTS_BITS);
		}
#endif

		if (sts & AUICH_BCIS)
			auich_intr_pipe(sc, AUICH_PCMI, &sc->pcmi);

		/* int ack */
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg, sts &
		    (AUICH_BCIS | AUICH_FIFOE));
		bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_PIINT);
		ret++;
	}

	if (gsts & AUICH_MINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_MICI + sc->sc_sts_reg);
		DPRINTF(AUICH_DEBUG_INTR,
		    ("auich_intr: ists=%b\n", sts, AUICH_ISTS_BITS));
#ifdef AUICH_DEBUG
		if (sts & AUICH_FIFOE) {
			printf("%s: in fifo overrun civ=%u ctrl=0x%x sts=%b\n",
			    sc->sc_dev.dv_xname,
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_MICI + AUICH_CIV),
			    bus_space_read_1(sc->iot, sc->aud_ioh,
				AUICH_MICI + AUICH_CTRL),
			    bus_space_read_2(sc->iot, sc->aud_ioh,
				AUICH_MICI + sc->sc_sts_reg),
			    AUICH_ISTS_BITS);
		}
#endif
		if (sts & AUICH_BCIS)
			auich_intr_pipe(sc, AUICH_MICI, &sc->mici);

		/* int ack */
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_MICI + sc->sc_sts_reg,
		    sts + (AUICH_BCIS | AUICH_FIFOE));

		bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_MINT);
		ret++;
	}
	mtx_leave(&audio_lock);
	return ret;
}


void
auich_trigger_pipe(struct auich_softc *sc, int pipe, struct auich_ring *ring)
{
	int blksize, qptr, oqptr;
	struct auich_dmalist *q;

	blksize = ring->blksize;
	qptr = oqptr = bus_space_read_1(sc->iot, sc->aud_ioh, pipe + AUICH_CIV);

	/* XXX remove this when no one reports problems */
	if(oqptr >= AUICH_DMALIST_MAX) {
		printf("%s: Unexpected CIV: %d\n", sc->sc_dev.dv_xname, oqptr);
		qptr = oqptr = 0;
	}

	do {
		q = &ring->dmalist[qptr];
		q->base = ring->p;
		q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;

		DPRINTF(AUICH_DEBUG_INTR,
		    ("auich_trigger_pipe: %p, %p = %x @@ 0x%x qptr=%d\n",
			&ring->dmalist[qptr], q, q->len, q->base, qptr));

		ring->p += blksize;
		if (ring->p >= ring->end)
			ring->p = ring->start;

		qptr = (qptr + 1) & AUICH_LVI_MASK;
	} while (qptr != oqptr);

	ring->qptr = qptr;

	DPRINTF(AUICH_DEBUG_DMA,
	    ("auich_trigger_pipe: qptr=%d\n", qptr));

	bus_space_write_1(sc->iot, sc->aud_ioh, pipe + AUICH_LVI,
	    (qptr - 1) & AUICH_LVI_MASK);
	bus_space_write_1(sc->iot, sc->aud_ioh, pipe + AUICH_CTRL,
	    AUICH_IOCE | AUICH_FEIE | AUICH_RPBM);

	ring->running = 1;
}

void
auich_intr_pipe(struct auich_softc *sc, int pipe, struct auich_ring *ring)
{
	int blksize, qptr, nqptr;
	struct auich_dmalist *q;

	blksize = ring->blksize;
	qptr = ring->qptr;
	nqptr = bus_space_read_1(sc->iot, sc->aud_ioh, pipe + AUICH_CIV);

	while (qptr != nqptr) {
		q = &ring->dmalist[qptr];
		q->base = ring->p;
		q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;

		DPRINTF(AUICH_DEBUG_INTR,
		    ("auich_intr: %p, %p = %x @@ 0x%x qptr=%d\n",
		    &ring->dmalist[qptr], q, q->len, q->base, qptr));

		ring->p += blksize;
		if (ring->p >= ring->end)
			ring->p = ring->start;

		qptr = (qptr + 1) & AUICH_LVI_MASK;
		if (ring->intr)
			ring->intr(ring->arg);
		else
			printf("auich_intr: got progress with intr==NULL\n");

		ring->ap += blksize;
		if (ring->ap >= ring->size)
			ring->ap = 0;
	}
	ring->qptr = qptr;

	bus_space_write_1(sc->iot, sc->aud_ioh, pipe + AUICH_LVI,
	    (qptr - 1) & AUICH_LVI_MASK);
}


int
auich_trigger_output(void *v, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct auich_softc *sc = v;
	struct auich_dma *p;
	size_t size;
#ifdef AUICH_DEBUG
	uint16_t sts;
	sts = bus_space_read_2(sc->iot, sc->aud_ioh,
	    AUICH_PCMO + sc->sc_sts_reg);
	DPRINTF(AUICH_DEBUG_DMA,
	    ("auich_trigger_output(%p, %p, %d, %p, %p, %p) sts=%b\n",
		start, end, blksize, intr, arg, param, sts, AUICH_ISTS_BITS));
#endif

	if (sc->sc_pdma->addr == start)
		p = sc->sc_pdma;
	else
		return -1;

	size = (size_t)((caddr_t)end - (caddr_t)start);
	sc->pcmo.size = size;
	sc->pcmo.intr = intr;
	sc->pcmo.arg = arg;

	/*
	 * The logic behind this is:
	 * setup one buffer to play, then LVI dump out the rest
	 * to the scatter-gather chain.
	 */
	sc->pcmo.start = p->segs->ds_addr;
	sc->pcmo.p = sc->pcmo.start;
	sc->pcmo.end = sc->pcmo.start + size;
	sc->pcmo.blksize = blksize;

	mtx_enter(&audio_lock);
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_BDBAR,
	    sc->sc_cddma + AUICH_PCMO_OFF(0));
	auich_trigger_pipe(sc, AUICH_PCMO, &sc->pcmo);
	mtx_leave(&audio_lock);
	return 0;
}

int
auich_trigger_input(v, start, end, blksize, intr, arg, param)
	void *v;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct auich_softc *sc = v;
	struct auich_dma *p;
	size_t size;

#ifdef AUICH_DEBUG
	DPRINTF(AUICH_DEBUG_DMA,
	    ("auich_trigger_input(%p, %p, %d, %p, %p, %p) sts=%b\n",
		start, end, blksize, intr, arg, param,
		bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg),
		AUICH_ISTS_BITS));
#endif
	if (sc->sc_rdma->addr == start)
		p = sc->sc_rdma;
	else
		return -1;

	size = (size_t)((caddr_t)end - (caddr_t)start);
	sc->pcmi.size = size;
	sc->pcmi.intr = intr;
	sc->pcmi.arg = arg;

	/*
	 * The logic behind this is:
	 * setup one buffer to play, then LVI dump out the rest
	 * to the scatter-gather chain.
	 */
	sc->pcmi.start = p->segs->ds_addr;
	sc->pcmi.p = sc->pcmi.start;
	sc->pcmi.end = sc->pcmi.start + size;
	sc->pcmi.blksize = blksize;
	mtx_enter(&audio_lock);
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_BDBAR,
	    sc->sc_cddma + AUICH_PCMI_OFF(0));
	auich_trigger_pipe(sc, AUICH_PCMI, &sc->pcmi);
	mtx_leave(&audio_lock);
	return 0;
}


int
auich_allocmem(struct auich_softc *sc, size_t size, size_t align,
    struct auich_dma *p)
{
	int error;

	p->size = size;
	error = bus_dmamem_alloc(sc->dmat, p->size, align, 0, p->segs, 1,
	    &p->nsegs, BUS_DMA_NOWAIT);
	if (error) {
		DPRINTF(AUICH_DEBUG_DMA, 
		    ("%s: bus_dmamem_alloc failed: error %d\n",
		    sc->sc_dev.dv_xname, error));
		return error;
	}

	error = bus_dmamem_map(sc->dmat, p->segs, 1, p->size, &p->addr,
	    BUS_DMA_NOWAIT | sc->sc_dmamap_flags);
	if (error) {
		DPRINTF(AUICH_DEBUG_DMA, 
		    ("%s: bus_dmamem_map failed: error %d\n",
		    sc->sc_dev.dv_xname, error));
		goto free;
	}

	error = bus_dmamap_create(sc->dmat, p->size, 1, p->size, 0,
	    BUS_DMA_NOWAIT, &p->map);
	if (error) {
		DPRINTF(AUICH_DEBUG_DMA, 
		    ("%s: bus_dmamap_create failed: error %d\n",
		    sc->sc_dev.dv_xname, error));
		goto unmap;
	}

	error = bus_dmamap_load(sc->dmat, p->map, p->addr, p->size, NULL,
	    BUS_DMA_NOWAIT);
	if (error) {
		DPRINTF(AUICH_DEBUG_DMA,
		    ("%s: bus_dmamap_load failed: error %d\n",
		    sc->sc_dev.dv_xname, error));
		goto destroy;
	}
	return 0;

 destroy:
	bus_dmamap_destroy(sc->dmat, p->map);
 unmap:
	bus_dmamem_unmap(sc->dmat, p->addr, p->size);
 free:
	bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
	return error;
}


int
auich_freemem(struct auich_softc *sc, struct auich_dma *p)
{
	bus_dmamap_unload(sc->dmat, p->map);
	bus_dmamap_destroy(sc->dmat, p->map);
	bus_dmamem_unmap(sc->dmat, p->addr, p->size);
	bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
	return 0;
}



int
auich_alloc_cdata(struct auich_softc *sc)
{
	bus_dma_segment_t seg;
	int error, rseg;

	/*
	 * Allocate the control data structure, and create and load the
	 * DMA map for it.
	 */
	if ((error = bus_dmamem_alloc(sc->dmat, sizeof(struct auich_cdata),
	    PAGE_SIZE, 0, &seg, 1, &rseg, 0)) != 0) {
		printf("%s: unable to allocate control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_0;
	}

	if ((error = bus_dmamem_map(sc->dmat, &seg, 1,
	    sizeof(struct auich_cdata), (caddr_t *) &sc->sc_cdata,
	    sc->sc_dmamap_flags)) != 0) {
		printf("%s: unable to map control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->dmat, sizeof(struct auich_cdata), 1,
	    sizeof(struct auich_cdata), 0, 0, &sc->sc_cddmamap)) != 0) {
		printf("%s: unable to create control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->dmat, sc->sc_cddmamap, sc->sc_cdata,
	    sizeof(struct auich_cdata), NULL, 0)) != 0) {
		printf("%s: unable tp load control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	sc->pcmo.dmalist = sc->sc_cdata->ic_dmalist_pcmo;
	sc->pcmi.dmalist = sc->sc_cdata->ic_dmalist_pcmi;
	sc->mici.dmalist = sc->sc_cdata->ic_dmalist_mici;

	return 0;

 fail_3:
	bus_dmamap_destroy(sc->dmat, sc->sc_cddmamap);
 fail_2:
	bus_dmamem_unmap(sc->dmat, (caddr_t) sc->sc_cdata,
	    sizeof(struct auich_cdata));
 fail_1:
	bus_dmamem_free(sc->dmat, &seg, rseg);
 fail_0:
	return error;
}

int
auich_resume(struct auich_softc *sc)
{
	/* SiS 7012 needs special handling */
	if (PCI_VENDOR(sc->pci_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(sc->pci_id) == PCI_PRODUCT_SIS_7012_ACA) {
		/* un-mute output */
		bus_space_write_4(sc->iot, sc->aud_ioh, ICH_SIS_NV_CTL,
		    bus_space_read_4(sc->iot, sc->aud_ioh, ICH_SIS_NV_CTL) |
		    ICH_SIS_CTL_UNMUTE);
	}

	ac97_resume(&sc->host_if, sc->codec_if);

	return (0);
}

/* -------------------------------------------------------------------- */
/* Calibrate card (some boards are overclocked and need scaling) */

unsigned int
auich_calibrate(struct auich_softc *sc)
{
	struct timeval t1, t2;
	u_int8_t civ, ociv;
	uint16_t sts, osts;
	u_int32_t wait_us, actual_48k_rate, bytes, ac97rate;
	void *temp_buffer;
	struct auich_dma *p;

	ac97rate = AUICH_FIXED_RATE;
	/*
	 * Grab audio from input for fixed interval and compare how
	 * much we actually get with what we expect.  Interval needs
	 * to be sufficiently short that no interrupts are
	 * generated.
	 * XXX: Is this true? We don't request any interrupts,
	 * so why should the chip issue any?
	 */

	/* Setup a buffer */
	bytes = 16000;
	temp_buffer = auich_allocm(sc, 0, bytes, M_DEVBUF, M_NOWAIT);
	if (temp_buffer == NULL)
		return (ac97rate);
	if (sc->sc_cdma->addr == temp_buffer) {
		p = sc->sc_cdma;
	} else {
		printf("auich_calibrate: bad address %p\n", temp_buffer);
		return (ac97rate);
	}

	/* get current CIV (usually 0 after reboot) */
	ociv = civ = bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CIV);
	sc->pcmi.dmalist[civ].base = p->map->dm_segs[0].ds_addr;
	sc->pcmi.dmalist[civ].len = bytes / sc->sc_sample_size;


	/*
	 * our data format is stereo, 16 bit so each sample is 4 bytes.
	 * assuming we get 48000 samples per second, we get 192000 bytes/sec.
	 * we're going to start recording with interrupts disabled and measure
	 * the time taken for one block to complete.  we know the block size,
	 * we know the time in microseconds, we calculate the sample rate:
	 *
	 * actual_rate [bps] = bytes / (time [s] * 4)
	 * actual_rate [bps] = (bytes * 1000000) / (time [us] * 4)
	 * actual_rate [Hz] = (bytes * 250000) / time [us]
	 */

	/* prepare */
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_BDBAR,
	    sc->sc_cddma + AUICH_PCMI_OFF(0));
	/* we got only one valid sample, so set LVI to CIV
	 * otherwise we provoke a AUICH_FIFOE FIFO error
	 * which will confuse the chip later on. */
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_LVI,
	    civ & AUICH_LVI_MASK);

	/* start, but don't request any interupts */
	microuptime(&t1);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL,
	    AUICH_RPBM);

	/* XXX remove this sometime */
	osts = bus_space_read_2(sc->iot, sc->aud_ioh,
	    AUICH_PCMI + sc->sc_sts_reg);
	/* wait */
	while(1) {
		microuptime(&t2);
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg);
		civ = bus_space_read_1(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + AUICH_CIV);
	  
		/* turn time delta into us */
		wait_us = ((t2.tv_sec - t1.tv_sec) * 1000000) +
		    t2.tv_usec - t1.tv_usec;

		/* this should actually never happen because civ==lvi */
		if ((civ & AUICH_LVI_MASK) != (ociv & AUICH_LVI_MASK)) {
			printf("%s: ac97 CIV progressed after %d us sts=%b civ=%u\n",
			    sc->sc_dev.dv_xname, wait_us, sts,
			    AUICH_ISTS_BITS, civ);
			ociv = civ;
		}
		/* normal completion */
		if (sts & (AUICH_DCH | AUICH_CELV | AUICH_LVBCI))
			break;
		/*
		 * check for strange changes in STS -
		 * XXX remove it when everythings fine
		 */
		if (sts != osts) {
			printf("%s: ac97 sts changed after %d us sts=%b civ=%u\n",
			    sc->sc_dev.dv_xname, wait_us, sts,
			    AUICH_ISTS_BITS, civ);
			osts = sts;
		}
		/*
		 * timeout: we expect 83333 us for 48k sampling rate,
		 * 600000 us will be enough even for 8k sampling rate
		 */
		if (wait_us > 600000) {
			printf("%s: ac97 link rate timed out %d us sts=%b civ=%u\n",
			    sc->sc_dev.dv_xname, wait_us, sts,
			    AUICH_ISTS_BITS, civ);
			/* reset and clean up*/
			auich_halt_pipe(sc, AUICH_PCMI, &sc->pcmi);
			auich_halt_pipe(sc, AUICH_MICI, &sc->mici);
			auich_freem(sc, temp_buffer, M_DEVBUF);
			/* return default sample rate */
			return (ac97rate);
		}
	}

	DPRINTF(AUICH_DEBUG_CODECIO,
	    ("%s: ac97 link rate calibration took %d us sts=%b civ=%u\n",
		sc->sc_dev.dv_xname, wait_us, sts, AUICH_ISTS_BITS, civ));

	/* reset and clean up */
	auich_halt_pipe(sc, AUICH_PCMI, &sc->pcmi);
	auich_halt_pipe(sc, AUICH_MICI, &sc->mici);
	auich_freem(sc, temp_buffer, M_DEVBUF);

#ifdef AUICH_DEBUG
	sts = bus_space_read_2(sc->iot, sc->aud_ioh,
	    AUICH_PCMI + sc->sc_sts_reg);
	civ = bus_space_read_4(sc->iot, sc->aud_ioh,
	    AUICH_PCMI + AUICH_CIV);
	printf("%s: after calibration and reset sts=%b civ=%u\n",
	    sc->sc_dev.dv_xname, sts, AUICH_ISTS_BITS, civ);
#endif

	/* now finally calculate measured samplerate */
	actual_48k_rate = (bytes * 250000) / wait_us;

	if (actual_48k_rate <= 48500)
		ac97rate = AUICH_FIXED_RATE;
	else
		ac97rate = actual_48k_rate;

	DPRINTF(AUICH_DEBUG_CODECIO, ("%s: measured ac97 link rate at %d Hz",
		sc->sc_dev.dv_xname, actual_48k_rate));
	if (ac97rate != actual_48k_rate)
		DPRINTF(AUICH_DEBUG_CODECIO, (", will use %d Hz", ac97rate));
	DPRINTF(AUICH_DEBUG_CODECIO, ("\n"));

	return (ac97rate);
}
@


1.105
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.103 2015/03/14 03:38:48 jsg Exp $	*/
a172 2
	audio_device_t sc_audev;

a298 1
int auich_getdev(void *, struct audio_device *);
a330 1
	auich_getdev,
d450 1
a450 8
	snprintf(sc->sc_audev.name, sizeof sc->sc_audev.name, "%s AC97",
		 auich_devices[i].name);
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audev.config, sc->sc_dev.dv_xname,
		sizeof sc->sc_audev.config);

	printf(": %s, %s\n", intrstr, sc->sc_audev.name);
a842 8
	return 0;
}

int
auich_getdev(void *v, struct audio_device *adp)
{
	struct auich_softc *sc = v;
	*adp = sc->sc_audev;
@


1.104
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@a294 1
int auich_query_encoding(void *, struct audio_encoding *);
a307 1
paddr_t auich_mappage(void *, void *, off_t, int);
a317 1
void auich_get_default_params(void *, int, struct audio_params *);
a323 2
	NULL,			/* drain */
	auich_query_encoding,
a341 1
	auich_mappage,
d344 1
a344 2
	auich_trigger_input,
	auich_get_default_params
a670 23
void
auich_get_default_params(void *addr, int mode, struct audio_params *params)
{
	ac97_get_default_params(params);
}

int
auich_query_encoding(void *v, struct audio_encoding *aep)
{
	switch (aep->index) {
	case 0:
		strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
		aep->precision = 16;
		aep->flags = 0;
		aep->bps = 2;
		aep->msb = 1;
		return (0);
	default:
		return (EINVAL);
	}
}

a947 21
}

paddr_t
auich_mappage(void *v, void *mem, off_t off, int prot)
{
	struct auich_softc *sc = v;
	struct auich_dma *p;

	if (off < 0)
		return -1;

	p = NULL;
	if (sc->sc_pdma != NULL && sc->sc_pdma->addr == mem)
		p = sc->sc_pdma;
	else if (sc->sc_rdma != NULL && sc->sc_rdma->addr == mem)
		p = sc->sc_rdma;
	else
		return -1;

	return bus_dmamem_mmap(sc->dmat, p->segs, p->nsegs,
	    off, prot, BUS_DMA_WAITOK);
@


1.103
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.102 2014/09/24 08:35:12 mpi Exp $	*/
a46 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
d687 7
a693 68
	struct auich_softc *sc = v;
	if (sc->sc_spdif) {
		switch (aep->index) {
		case 0:
			strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
			aep->precision = 16;
			aep->flags = 0;
			aep->bps = 2;
			aep->msb = 1;
			return (0);
		default:
			return (EINVAL);
		}
	} else {
		switch (aep->index) {
		case 0:
			strlcpy(aep->name, AudioEulinear, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_ULINEAR;
			aep->precision = 8;
			aep->flags = 0;
			break;
		case 1:
			strlcpy(aep->name, AudioEmulaw, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_ULAW;
			aep->precision = 8;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 2:
			strlcpy(aep->name, AudioEalaw, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_ALAW;
			aep->precision = 8;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 3:
			strlcpy(aep->name, AudioEslinear, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_SLINEAR;
			aep->precision = 8;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 4:
			strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
			aep->precision = 16;
			aep->flags = 0;
			break;
		case 5:
			strlcpy(aep->name, AudioEulinear_le, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_ULINEAR_LE;
			aep->precision = 16;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 6:
			strlcpy(aep->name, AudioEslinear_be, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_SLINEAR_BE;
			aep->precision = 16;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		case 7:
			strlcpy(aep->name, AudioEulinear_be, sizeof aep->name);
			aep->encoding = AUDIO_ENCODING_ULINEAR_BE;
			aep->precision = 16;
			aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
			break;
		default:
			return (EINVAL);
		}
		aep->bps = AUDIO_BPS(aep->precision);
d696 2
d722 1
a722 4
		play->factor = 1;
		play->sw_code = NULL;
		if (play->precision > 16)
			play->precision = 16;
d724 5
a728 3
		case AUDIO_ENCODING_ULAW:
			if (play->channels > 2)
				play->channels = 2;
d731 1
a731 2
				play->factor = 4;
				play->sw_code = mulaw_to_slinear16_le_mts;
a733 2
				play->factor = 2;
				play->sw_code = mulaw_to_slinear16_le;
d735 3
a737 8
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			switch (play->precision) {
			case 8:
				if (play->channels > 2)
a738 12
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
d740 5
a744 145
			case 16:
				if (play->channels > 6)
					play->channels = 6;
				if (play->channels > 1)
					play->channels &= ~1;
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = noswap_bytes_mts;
					break;
				case 2:
					break;
				case 4:
					ext_id = codec->vtbl->get_caps(codec);
					if (!(ext_id & AC97_EXT_AUDIO_SDAC))
						play->channels = 2;
					break;
				case 6:
					ext_id = codec->vtbl->get_caps(codec);
					if ((ext_id & AC97_BITS_6CH) !=
					    AC97_BITS_6CH)
						play->channels = 2;
					break;
				default:
					return (EINVAL);
				}
				break;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (play->channels > 2)
				play->channels = 2;
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_le_mts;
					break;
				case 2:
					play->sw_code = change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (play->channels > 2)
				play->channels = 2;
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = alaw_to_slinear16_le_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = alaw_to_slinear16_le;
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (play->channels > 2)
				play->channels = 2;
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_mts;
					break;
				case 2:
					play->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (play->channels > 2)
				play->channels = 2;
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_le_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16_le;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_change_sign16_le_mts;
					break;
				case 2:
					play->sw_code = swap_bytes_change_sign16_le;
					break;
				default:
					return (EINVAL);
				}
d795 3
a797 149
		rec->factor = 1;
		rec->sw_code = 0;
		if (rec->channels > 2)
			rec->channels = 2;
		if (rec->precision > 16)
			rec->precision = 16;
		switch(rec->encoding) {
		case AUDIO_ENCODING_ULAW:
			switch (rec->channels) {
			case 1:
				rec->sw_code = slinear16_to_mulaw_le_stm;
				rec->factor = 4;
				break;
			case 2:
				rec->sw_code = slinear16_to_mulaw_le;
				rec->factor = 2;
				break;
			}
			break;
		case AUDIO_ENCODING_ALAW:
			switch (rec->channels) {
			case 1:
				rec->sw_code = slinear16_to_alaw_le_stm;
				rec->factor = 4;
				break;
			case 2:
				rec->sw_code = slinear16_to_alaw_le;
				rec->factor = 2;
				break;
			}
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			switch (rec->precision) {
			case 8:
				switch (rec->channels) {
				case 1:
					rec->sw_code = linear16_to_linear8_le_stm;
					rec->factor = 4;
					break;
				case 2:
					rec->sw_code = linear16_to_linear8_le;
					rec->factor = 2;
					break;
				}
				break;
			case 16:
				switch (rec->channels) {
				case 1:
					rec->sw_code = linear16_decimator;
					rec->factor = 2;
					break;
				case 2:
					break;
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			switch (rec->precision) {
			case 8:
				switch (rec->channels) {
				case 1:
					rec->sw_code = linear16_to_ulinear8_le_stm;
					rec->factor = 4;
					break;
				case 2:
					rec->sw_code = linear16_to_ulinear8_le;
					rec->factor = 2;
					break;
				}
				break;
			case 16:
				switch (rec->channels) {
				case 1:
					rec->sw_code = change_sign16_le_stm;
					rec->factor = 2;
					break;
				case 2:
					rec->sw_code = change_sign16_le;
					break;
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			switch (rec->precision) {
			case 8:
				switch (rec->channels) {
				case 1:
					rec->sw_code = linear16_to_linear8_le_stm;
					rec->factor = 4;
					break;
				case 2:
					rec->sw_code = linear16_to_linear8_le;
					rec->factor = 2;
					break;
				}
				break;
			case 16:
				switch (rec->channels) {
				case 1:
					rec->sw_code = swap_bytes_stm;
					rec->factor = 2;
					break;
				case 2:
					rec->sw_code = swap_bytes;
					break;
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			switch (rec->precision) {
			case 8:
				switch (rec->channels) {
				case 1:
					rec->sw_code = linear16_to_ulinear8_le_stm;
					rec->factor = 4;
					break;
				case 2:
					rec->sw_code = linear16_to_ulinear8_le;
					rec->factor = 2;
					break;
				}
				break;
			case 16:
				switch (rec->channels) {
				case 1:
					rec->sw_code = change_sign16_swap_bytes_le_stm;
					rec->factor = 2;
					break;
				case 2:
					rec->sw_code = change_sign16_swap_bytes_le;
					break;
				}
				break;
			default:
				return (EINVAL);
			}
			break;
		default:
			return (EINVAL);
		}
@


1.102
log
@Kill two generic DVACT_DEACTIVATE handlers since this event is now
autoconf(9)ally passed to the children of a device.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.101 2014/07/12 18:48:51 tedu Exp $	*/
a38 1
#include <sys/kernel.h>
@


1.101
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.100 2014/05/17 12:40:25 ratchov Exp $	*/
a176 1
	struct device *audiodev;
d545 1
a545 1
	sc->audiodev = audio_attach_mi(&auich_hw_if, sc, &sc->sc_dev);
a562 4
		break;
	case DVACT_DEACTIVATE:
		if (sc->audiodev != NULL)
			rv = config_deactivate(sc->audiodev);
@


1.100
log
@fix format mistakes visible if AUICH_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.99 2013/12/06 21:03:03 deraadt Exp $	*/
d1311 1
a1311 1
		free(p, pool);
d1342 1
a1342 1
	free(p, pool);
@


1.99
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.98 2013/05/24 07:58:46 ratchov Exp $	*/
d1300 1
a1300 1
		    ("%s: requested buffer size too large: %d", \
d1430 1
a1430 1
			printf("%s: in fifo overrun civ=%u ctrl=0x%x sts=%b\n",
d1460 1
a1460 1
			printf("%s: in fifo overrun # %u civ=%u ctrl=0x%x sts=%b\n",
d1583 1
a1583 1
	    ("auich_trigger_output(%x, %x, %d, %p, %p, %p) sts=%b\n",
d1630 1
a1630 1
	    ("auich_trigger_input(%x, %x, %d, %p, %p, %p) sts=%b\n",
@


1.98
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.97 2013/05/15 08:29:24 ratchov Exp $	*/
a560 5
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		break;
d568 3
@


1.97
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.96 2012/01/11 16:22:33 dhill Exp $	*/
d449 2
a450 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, auich_intr,
				       sc, sc->sc_dev.dv_xname);
@


1.96
log
@ansify and de'register some prototypes

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.95 2011/07/03 15:47:16 matthew Exp $	*/
d1237 1
d1241 1
a1241 1

d1254 1
a1254 1

d1259 1
a1259 1

d1389 1
d1484 1
a1484 1

d1609 1
d1613 1
a1613 1

d1657 1
a1657 1

d1661 1
a1661 1

@


1.95
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.94 2011/04/03 15:36:02 jasper Exp $	*/
d367 1
a367 4
auich_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d381 1
a381 3
auich_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d579 1
a579 4
auich_read_codec(v, reg, val)
	void *v;
	u_int8_t reg;
	u_int16_t *val;
d601 1
a601 4
auich_write_codec(v, reg, val)
	void *v;
	u_int8_t reg;
	u_int16_t val;
d623 1
a623 3
auich_attach_codec(v, cif)
	void *v;
	struct ac97_codec_if *cif;
d632 1
a632 2
auich_reset_codec(v)
	void *v;
d668 1
a668 3
auich_open(v, flags)
	void *v;
	int flags;
d681 1
a681 2
auich_close(v)
	void *v;
d695 1
a695 3
auich_query_encoding(v, aep)
	void *v;
	struct audio_encoding *aep;
d771 2
a772 4
auich_set_params(v, setmode, usemode, play, rec)
	void *v;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1193 1
a1193 3
auich_round_blocksize(v, blk)
	void *v;
	int blk;
d1231 1
a1231 2
auich_halt_output(v)
	void *v;
d1245 1
a1245 2
auich_halt_input(v)
	void *v;
d1263 1
a1263 3
auich_getdev(v, adp)
	void *v;
	struct audio_device *adp;
d1271 1
a1271 3
auich_set_port(v, cp)
	void *v;
	mixer_ctrl_t *cp;
d1278 1
a1278 3
auich_get_port(v, cp)
	void *v;
	mixer_ctrl_t *cp;
d1285 1
a1285 3
auich_query_devinfo(v, dp)
	void *v;
	mixer_devinfo_t *dp;
d1292 1
a1292 5
auich_allocm(v, direction, size, pool, flags)
	void *v;
	int direction;
	size_t size;
	int pool, flags;
d1347 1
a1347 4
auich_round_buffersize(v, direction, size)
	void *v;
	int direction;
	size_t size;
d1356 1
a1356 5
auich_mappage(v, mem, off, prot)
	void *v;
	void *mem;
	off_t off;
	int prot;
d1377 1
a1377 2
auich_get_props(v)
	void *v;
d1383 1
a1383 2
auich_intr(v)
	void *v;
d1572 2
a1573 7
auich_trigger_output(v, start, end, blksize, intr, arg, param)
	void *v;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
@


1.94
log
@use nitems(); no binary change for drivers that are compiled on amd64.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.93 2010/09/12 03:17:34 jakemsr Exp $	*/
a565 2
	case DVACT_ACTIVATE:
		break;
@


1.93
log
@silly me.  use the switch() variable, not the case value.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.92 2010/09/12 02:04:31 jakemsr Exp $	*/
d375 1
a375 1
	for (i = sizeof(auich_devices)/sizeof(auich_devices[0]); i--;)
d466 1
a466 1
	for (i = sizeof(auich_devices)/sizeof(auich_devices[0]); i--;)
@


1.92
log
@use audio(4) DVACT_{QUIESCE,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.91 2010/09/07 16:21:44 deraadt Exp $	*/
d569 1
a569 1
		rv = config_activate_children(self, DVACT_QUIESCE);
d575 1
a575 1
		rv = config_activate_children(self, DVACT_RESUME);
@


1.91
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.90 2010/09/06 19:20:22 deraadt Exp $	*/
a325 1
int auich_suspend(struct auich_softc *);
d569 1
a569 1
		/* XXX to be filled by jakemsr */
a571 1
		auich_suspend(sc);
d575 1
a1838 19
auich_suspend(struct auich_softc *sc)
{
	if (sc->pcmo.running) {
		auich_halt_pipe(sc, AUICH_PCMO, &sc->pcmo);
		sc->pcmo.running = 1;
	}
	if (sc->pcmi.running) {
		auich_halt_pipe(sc, AUICH_PCMI, &sc->pcmi);
		sc->pcmi.running = 1;
	}
	if (sc->mici.running) {
		auich_halt_pipe(sc, AUICH_MICI, &sc->mici);
		sc->mici.running = 1;
	}

	return (0);
}

int
a1840 3
	struct auich_ring *ring;
	u_long rate, control;

a1850 75

	ring = &sc->pcmo;
	if (ring->running) {

		rate = sc->last_prate;
		ac97_set_rate(sc->codec_if, AC97_REG_PCM_LFE_DAC_RATE, &rate);

		rate = sc->last_prate;
		ac97_set_rate(sc->codec_if, AC97_REG_PCM_SURR_DAC_RATE, &rate);

		rate = sc->last_prate;
		ac97_set_rate(sc->codec_if, AC97_REG_PCM_FRONT_DAC_RATE, &rate);

		control = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GCTRL);
		control &= ~(sc->sc_pcm246_mask);
		if (sc->last_pchan == 4)
			control |= sc->sc_pcm4;
		else if (sc->last_pchan == 6)
			control |= sc->sc_pcm6;
		bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GCTRL, control);

		if (ring->intr) {
			while (ring->ap != 0) {
				ring->intr(ring->arg);
				ring->ap += ring->blksize;
				if (ring->ap >= ring->size)
					ring->ap = 0;
			}
			ring->p = ring->start;
		}

		bus_space_write_4(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + AUICH_BDBAR, sc->sc_cddma + AUICH_PCMO_OFF(0));
		auich_trigger_pipe(sc, AUICH_PCMO, ring);
	}

	ring = &sc->pcmi;
	if (ring->running) {
		rate = sc->last_rrate;
		ac97_set_rate(sc->codec_if, AC97_REG_PCM_LR_ADC_RATE, &rate);

		if (ring->intr) {
			while (ring->ap != 0) {
				ring->intr(ring->arg);
				ring->ap += ring->blksize;
				if (ring->ap >= ring->size)
					ring->ap = 0;
			}
			ring->p = ring->start;
		}

		bus_space_write_4(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + AUICH_BDBAR, sc->sc_cddma + AUICH_PCMI_OFF(0));
		auich_trigger_pipe(sc, AUICH_PCMI, ring);
	}

	ring = &sc->mici;
	if (ring->running) {
		rate = sc->last_rrate;
		ac97_set_rate(sc->codec_if, AC97_REG_PCM_MIC_ADC_RATE, &rate);

		if (ring->intr) {
			while (ring->ap != 0) {
				ring->intr(ring->arg);
				ring->ap += ring->blksize;
				if (ring->ap >= ring->size)
					ring->ap = 0;
			}
			ring->p = ring->start;
		}

		bus_space_write_4(sc->iot, sc->aud_ioh,
		    AUICH_MICI + AUICH_BDBAR, sc->sc_cddma + AUICH_MICI_OFF(0));
		auich_trigger_pipe(sc, AUICH_MICI, ring);
	}
@


1.90
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.89 2010/08/31 17:13:44 deraadt Exp $	*/
a219 1
	void *powerhook;
a328 2
void auich_powerhook(int, void *);

a555 1
	sc->powerhook = powerhook_establish(auich_powerhook, sc);
a1951 7

void
auich_powerhook(int why, void *self)
{
	auich_activate(self, why);
}

@


1.89
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.88 2010/08/31 06:12:28 deraadt Exp $	*/
d558 1
a558 1
	sc->suspend = PWR_RESUME;
@


1.88
log
@do not return EOPNOTSUPP for unknown activate actions
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.87 2010/08/27 18:50:56 deraadt Exp $	*/
d572 3
@


1.87
log
@Since the changes in neo(4) work, it is very likely that the exact same
mechnical changes work in these drivers too.  Testing can occur after
this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.86 2010/08/09 05:43:48 jakemsr Exp $	*/
d568 1
a568 1
	int ret = 0;
d572 1
a572 5
		return ret;
	case DVACT_DEACTIVATE:
		if (sc->audiodev != NULL)
			ret = config_deactivate(sc->audiodev);
		return ret;
d575 1
a575 1
		return ret;
d578 5
a582 1
		return ret;
d584 1
a584 1
	return EOPNOTSUPP;
@


1.86
log
@sync hardware and software buffer positions on resume
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.85 2010/08/08 20:37:33 jakemsr Exp $	*/
d1955 1
a1955 3
auich_powerhook(why, self)
	int why;
	void *self;
d1957 1
a1957 23
	struct auich_softc *sc = (struct auich_softc *)self;

	if (why != PWR_RESUME) {
		/* Power down */
		DPRINTF(1, ("auich: power down\n"));
		sc->suspend = why;
		auich_read_codec(sc, AC97_REG_EXT_AUDIO_CTRL, &sc->ext_ctrl);

	} else {
		/* Wake up */
		DPRINTF(1, ("auich: power resume\n"));
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
			    sc->sc_dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
		auich_reset_codec(sc);
		DELAY(1000);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
		auich_write_codec(sc, AC97_REG_EXT_AUDIO_CTRL, sc->ext_ctrl);
	}
@


1.85
log
@suspend/resume support for auich, and some infrastructure in ac97
"commit" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.84 2010/08/03 22:58:58 jakemsr Exp $	*/
d207 2
d1609 4
d1648 1
a1648 1

d1696 1
a1696 1

d1896 10
d1915 11
d1935 11
@


1.84
log
@if interrupt mapping fails, say so
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.83 2010/07/15 03:43:11 jakemsr Exp $	*/
d177 1
d179 1
d206 1
d233 4
d257 2
d260 2
a261 1
	sizeof(struct auich_softc), auich_match, auich_attach
d302 1
a302 1
void auich_halt_pipe(struct auich_softc *, int);
d325 3
d447 1
d553 1
a553 1
	audio_attach_mi(&auich_hw_if, sc, &sc->sc_dev);
d563 23
d1014 2
d1043 2
d1204 1
d1225 1
a1225 1
auich_halt_pipe(struct auich_softc *sc, int pipe)
d1250 2
d1263 1
a1263 1
	auich_halt_pipe(sc, AUICH_PCMO);
d1281 2
a1282 2
	auich_halt_pipe(sc, AUICH_PCMI);
	auich_halt_pipe(sc, AUICH_MICI);
d1575 2
d1834 81
d2058 2
a2059 2
			auich_halt_pipe(sc, AUICH_PCMI);
			auich_halt_pipe(sc, AUICH_MICI);
d2071 2
a2072 2
	auich_halt_pipe(sc, AUICH_PCMI);
	auich_halt_pipe(sc, AUICH_MICI);
@


1.83
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.82 2010/06/07 23:35:24 ratchov Exp $	*/
d436 1
@


1.82
log
@Fix various problems of auich on SiS 7012 based chips:

- rework auich_halt_pipe() and use it to ensure AUICH_RR is
  set only after DMA is halted (spec says to do so)

- rework auich_calibrate(): clear interrupt and event bits in
  AUICH_STS and ensure CIV counter is not changed.

- in the interrupt handler, set LVI to (qptr - 1) rather than
  the max value (bug introduced by previous commit)

All fixes are from Christopher Zimmermann <madroach at zakweb.de>,
Thanks!

tested on two different intel-based auich devices,
ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.81 2010/03/30 09:38:07 dcoppa Exp $	*/
d688 2
d701 1
a701 1
			return (0);
d707 1
a707 1
			return (0);
d713 1
a713 1
			return (0);
d719 1
a719 1
			return (0);
d725 1
a725 1
			return (0);
d731 1
a731 1
			return (0);
d737 1
a737 1
			return (0);
d743 1
a743 1
			return (0);
d747 3
d968 2
d1155 2
@


1.81
log
@Do not print ac97 link rate message unless debug is enabled.

Adapted from NetBSD

OK jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.80 2010/01/14 18:15:27 ratchov Exp $	*/
a28 1
/* #define	AUICH_DEBUG */
d33 1
a33 1
 *	http://www.intel.com/design/chipsets/datashts/290716.htm
d77 1
a77 1
#define		AUICH_DCH		0x01	/* dma halted */
d234 1
a234 1
int auich_debug = 0xfffe;
d1176 1
a1176 1
	uint32_t status;
d1179 11
a1189 3
	for (i = 0; i < 100; i++) {
		status = bus_space_read_4(sc->iot, sc->aud_ioh, pipe + AUICH_STS);
		if (status & AUICH_DCH)
d1191 1
a1191 1
		DELAY(1);
d1209 2
a1210 1
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_CTRL, AUICH_RR);
d1227 3
a1229 2
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL, AUICH_RR);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_MICI + AUICH_CTRL, AUICH_RR);
d1393 9
a1401 2
			printf("%s: fifo underrun # %u\n",
			    sc->sc_dev.dv_xname, ++sc->pcmo_fifoe);
d1424 9
a1432 2
			printf("%s: in fifo overrun # %u\n",
			    sc->sc_dev.dv_xname, ++sc->pcmi_fifoe);
d1453 11
a1463 2
		if (sts & AUICH_FIFOE)
			printf("%s: mic fifo overrun\n", sc->sc_dev.dv_xname);
a1464 1

d1488 1
d1490 1
a1490 8
	DPRINTF(AUICH_DEBUG_INTR, ("auich_trigger_pipe: ring->qptr: %d\n",
	    ring->qptr));

	qptr = bus_space_read_1(sc->iot, sc->aud_ioh, pipe + AUICH_CIV);
	oqptr = qptr;

	DPRINTF(AUICH_DEBUG_INTR, ("auich_trigger_pipe: qptr: %d\n", qptr));

d1495 1
d1501 4
d1508 2
a1509 3
		qptr++;
		if (qptr == AUICH_DMALIST_MAX)
			qptr = 0;
d1511 1
d1513 4
d1518 1
a1518 1
	    (AUICH_DMALIST_MAX - 1) & AUICH_LVI_MASK);
d1539 2
a1540 2
		    ("auich_intr: %p, %p = %x @@ 0x%x\n",
		    &ring->dmalist[qptr], q, q->len, q->base));
d1549 2
d1571 4
a1574 1

d1576 3
a1578 2
	    ("auich_trigger_output(%x, %x, %d, %p, %p, %p)\n",
	    start, end, blksize, intr, arg, param));
d1620 1
d1622 6
a1627 3
	    ("auich_trigger_input(%x, %x, %d, %p, %p, %p)\n",
	    start, end, blksize, intr, arg, param));

d1817 2
a1818 1
	u_int8_t ociv, nciv;
d1829 2
d1845 4
a1848 2
	sc->pcmi.dmalist[0].base = p->map->dm_segs[0].ds_addr;
	sc->pcmi.dmalist[0].len = bytes / sc->sc_sample_size;
a1863 2
	ociv = bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CIV);
	nciv = ociv;
d1866 3
d1870 1
a1870 1
			  (0 - 1) & AUICH_LVI_MASK);
d1872 1
a1872 1
	/* start */
d1877 3
d1881 1
a1881 1
	while (nciv == ociv) {
d1883 18
a1900 1
		if (t2.tv_sec - t1.tv_sec > 1)
d1902 25
a1926 2
		nciv = bus_space_read_1(sc->iot, sc->aud_ioh,
					AUICH_PCMI + AUICH_CIV);
a1927 9
	microuptime(&t2);

	/* reset */
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL, AUICH_RR);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_MICI + AUICH_CTRL, AUICH_RR);
	DELAY(100);

	/* turn time delta into us */
	wait_us = ((t2.tv_sec - t1.tv_sec) * 1000000) + t2.tv_usec - t1.tv_usec;
d1929 7
d1938 8
a1945 5
	if (nciv == ociv) {
		printf("%s: ac97 link rate calibration timed out after %d us\n",
		       sc->sc_dev.dv_xname, wait_us);
		return (ac97rate);
	}
d1947 1
d1956 1
a1956 1
	       sc->sc_dev.dv_xname, actual_48k_rate));
@


1.80
log
@SiS devices seem unable to reset dma block index to zero, causing
dma to start at the wrong place. Workaround this limitation by
starting at the current offset.

From Christopher Zimmermann <madroach at zakweb.de>
Thanks a lot!

ok jakemsr
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.79 2009/11/05 01:29:06 jakemsr Exp $	*/
d1860 2
a1861 2
	printf("%s: measured ac97 link rate at %d Hz",
	       sc->sc_dev.dv_xname, actual_48k_rate);
d1863 2
a1864 2
		printf(", will use %d Hz", ac97rate);
	printf("\n");
@


1.79
log
@BUS_DMA_NOCACHE is defined on all archs that include this driver

from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.78 2008/10/28 03:57:42 jakemsr Exp $	*/
d1453 1
a1453 1
	int blksize, qptr;
d1458 13
a1470 1
	for (qptr = 0; qptr < AUICH_DMALIST_MAX; qptr++) {
d1478 5
a1482 3
	}
	ring->qptr = 0;

d1484 1
a1484 1
	    (qptr - 1) & AUICH_LVI_MASK);
@


1.78
log
@
SiS 7012 uses different multichannel control bits (data from linux).

makes 4 channel output work for Anathae Townsend.  thanks for testing.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.77 2008/10/25 22:30:43 jakemsr Exp $	*/
a152 4

#ifndef BUS_DMA_NOCACHE
#define BUS_DMA_NOCACHE 0
#endif
@


1.77
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.76 2008/10/23 21:50:01 jakemsr Exp $	*/
d103 4
d229 6
d476 4
d487 4
d622 1
a622 1
	control &= ~(AUICH_ACLSO | AUICH_PCM246_MASK);
d995 1
a995 1
		control &= ~AUICH_PCM246_MASK;
d997 1
a997 1
			control |= AUICH_PCM4;
d999 1
a999 1
			control |= AUICH_PCM6;
@


1.76
log
@
S/PDIF output support in ac97(4), auich(4) and auvia(4)

from NetBSD

tested by a few with no regressions.  optical works for jsg@@.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.75 2008/10/23 21:28:31 jakemsr Exp $	*/
d751 5
a755 4
		if (sc->sc_spdif &&
		    ((play->sample_rate != 48000) || (play->precision != 16) ||
		    (play->encoding != AUDIO_ENCODING_SLINEAR_LE)))
			return (EINVAL);
d760 2
d764 2
d782 2
d798 4
d812 1
a812 1
						return (EINVAL);
d818 1
a818 1
						return (EINVAL);
a823 2
			default:
				return (EINVAL);
d827 2
d862 2
d878 2
d913 2
d988 4
@


1.75
log
@
enable 4 and 6 channel support.

tested by a few.  no regressions, but 4 and 6 channel playback
is not working with all codecs yet.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.74 2008/09/15 22:40:50 jakemsr Exp $	*/
d187 1
d348 1
d513 1
d523 1
d625 7
d641 3
d651 3
d667 65
a731 51
	switch (aep->index) {
	case 0:
		strlcpy(aep->name, AudioEulinear, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 1:
		strlcpy(aep->name, AudioEmulaw, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 2:
		strlcpy(aep->name, AudioEalaw, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ALAW;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 3:
		strlcpy(aep->name, AudioEslinear, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR;
		aep->precision = 8;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 4:
		strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR_LE;
		aep->precision = 16;
		aep->flags = 0;
		return (0);
	case 5:
		strlcpy(aep->name, AudioEulinear_le, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR_LE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 6:
		strlcpy(aep->name, AudioEslinear_be, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_SLINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	case 7:
		strlcpy(aep->name, AudioEulinear_be, sizeof aep->name);
		aep->encoding = AUDIO_ENCODING_ULINEAR_BE;
		aep->precision = 16;
		aep->flags = AUDIO_ENCODINGFLAG_EMULATED;
		return (0);
	default:
		return (EINVAL);
d749 7
@


1.74
log
@
this driver uses three dma segments; play, record, calibrate.
instead of using a linked list to describe the dma segments
use three distinct pointers.

also, this driver only needs 1 buffer descriptor for each dma
segment, since each buffer descriptor can handle as many samples
as each segment can hold.

makes the code a little easier to read and allows us to free
the calibration buffer when we're done with it.

idea originally from ratchov@@ a while back.  tested by ratchov@@
and myself.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.73 2008/05/25 23:59:33 jakemsr Exp $	*/
d711 1
d715 2
d760 11
d920 8
@


1.73
log
@
use ac97 default parameters for auich(4), auixp(4) and auvia(4).
they may have codecs which only handle 48kHz sampling rates.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.72 2008/04/21 00:32:43 jakemsr Exp $	*/
d136 2
a137 3
 * according to the dev/audiovar.h AU_RING_SIZE is 2^16, what fits
 * in our limits perfectly, i.e. setting it to higher value
 * in your kernel config would improve perfomance, still 2^21 is the max
d140 1
a140 1
#define	AUICH_DMASEG_MAX	(65536*2)	/* 64k samples, 2x16 bit samples */
d157 1
a157 1
	bus_dma_segment_t segs[AUICH_DMALIST_MAX];
a159 1
	struct auich_dma *next;
d206 3
a208 1
	struct auich_dma *sc_dmas;
d1197 6
a1202 2
	p->next = sc->sc_dmas;
	sc->sc_dmas = p;
d1211 1
a1211 1
	struct auich_dma *p, **pp;
d1214 11
a1224 8
	for (pp = &sc->sc_dmas; (p = *pp) != NULL; pp = &p->next) {
		if (p->addr == ptr) {
			auich_freemem(sc, p);
			*pp = p->next;
			free(p, pool);
			return;
		}
	}
d1252 6
a1257 2
	for (p = sc->sc_dmas; p && p->addr != mem; p = p->next);
	if (!p)
d1431 3
a1433 2
	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
d1475 3
a1477 2
	for (p = sc->sc_dmas; p && p->addr != start; p = p->next);
	if (!p)
d1586 1
a1586 1
	if ((error = bus_dmamem_map(sc->dmat, &seg, rseg,
d1679 1
a1679 2
	temp_buffer = auich_allocm(sc, AUMODE_RECORD, bytes, M_DEVBUF,
	    M_NOWAIT);
d1682 3
a1684 3
	for (p = sc->sc_dmas; p && p->addr != temp_buffer; p = p->next)
		;
	if (p == NULL) {
a1735 1
#if 0
a1736 1
#endif
@


1.72
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.71 2008/03/24 07:03:16 jakemsr Exp $	*/
d307 1
d338 1
a338 1
	NULL
d637 6
@


1.71
log
@8-bit has been emulated for some time now.  quit lying.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.70 2008/02/12 11:25:57 jakemsr Exp $	*/
d336 2
a337 1
	auich_trigger_input
@


1.70
log
@
if the ac97 codec is fixed-rate, ac97_set_rate() will return the
fixed-rate, regardless of what sample rate we tried to set, without
an error.

so, instead of checking for an error after we've set the rate on all
dacs, we need to check that ac97_set_rate() successfully set the rate
we wanted, which may not be exactly the rate the user specified, due to
auich's sample rate scaling.

finally, we need to set the sample rate for the dacs in this order:
lfe, surround, front.  this is necessary because ac97_set_rate()
will return without checking for fixed-rate if the dac is
unsupported.  so, if the lfe dac is set last on a stereo only
fixed-rate codec, then we will not know whether we have a fixed-rate
codec.  all codecs have a front dac, and some codecs may have a
surround dac but not lfe.

discussed with brad@@, who noticed that the previous commit was
slightly bogus.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.69 2008/02/08 14:35:01 jakemsr Exp $	*/
d647 1
a647 1
		aep->flags = 0;
@


1.69
log
@don't unconditionally return here, still need to set recording parameters
when configuring for full-duplex.

fixes problem noticed by todd@@

ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.68 2008/01/15 02:52:50 jakemsr Exp $	*/
d880 1
a880 1
		    AC97_REG_PCM_FRONT_DAC_RATE, &play->sample_rate);
d892 1
a892 1
		    AC97_REG_PCM_LFE_DAC_RATE, &play->sample_rate);
d896 2
a897 4
		play->sample_rate = orate;

		if (error)
			return (error);
a1052 1
		rec->sample_rate = orate;
d1055 1
@


1.68
log
@bring in lots of ac97(4) and auvia(4) updates from NetBSD

user visible changes:
- when setting up ac97(4) mixer items, for some features like surround
  sound, check if the feature if supported by the codec and only add
  items for that feature if it is
- auvia(4) now supports multichannel playback with at least some
  multichannel ac97(4) codecs

fixes problems for me and ajacoutot with different auvia(4)
devices/codecs.  no regressions reported by testers.

if you have an ac97(4) audio device and are using mixerctl.conf(5),
you may want/need to update it.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.67 2007/10/23 19:59:27 jakemsr Exp $	*/
d897 3
a899 1
		return (error);
@


1.67
log
@- use endian-specific conversions, instead of relying on
  machine-dependent #defines
- use the correct conversions for slinear_le:16 -> ulinear_be:16
- fix mono recording by using various stereo -> mono conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.66 2007/10/20 02:40:54 jakemsr Exp $	*/
d877 7
d885 2
a886 3
		error = ac97_set_rate(sc->codec_if, play, AUMODE_PLAY);
		if (play->sample_rate == adj_rate)
			play->sample_rate = orate;
d889 9
d1051 2
a1052 1
		error = ac97_set_rate(sc->codec_if, rec, AUMODE_RECORD);
@


1.66
log
@replace auich's DMA and interrupt handling with code from NetBSD's
auich.  fixes recording from the microphone input as well as
full-duplex operation.

tested by brad@@, sthen@@, deanna@@ and ckuethe@@.  thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.65 2007/09/17 00:50:46 krw Exp $	*/
d715 1
a715 1
				play->sw_code = mulaw_to_slinear16_mts;
d719 1
a719 1
				play->sw_code = mulaw_to_slinear16;
d731 1
a731 1
					play->sw_code = linear8_to_linear16_mts;
d735 1
a735 1
					play->sw_code = linear8_to_linear16;
d763 1
a763 1
					play->sw_code = ulinear8_to_linear16_mts;
d767 1
a767 1
					play->sw_code = ulinear8_to_linear16;
d777 1
a777 1
					play->sw_code = change_sign16_mts;
d780 1
a780 1
					play->sw_code = change_sign16;
d794 1
a794 1
				play->sw_code = alaw_to_slinear16_mts;
d798 1
a798 1
				play->sw_code = alaw_to_slinear16;
d810 1
a810 1
					play->sw_code = linear8_to_linear16_mts;
d814 1
a814 1
					play->sw_code = linear8_to_linear16;
d843 1
a843 1
					play->sw_code = ulinear8_to_linear16_mts;
d847 1
a847 1
					play->sw_code = ulinear8_to_linear16;
d857 1
a857 1
					play->sw_code = change_sign16_swap_bytes_mts;
d860 1
a860 1
					play->sw_code = change_sign16_swap_bytes;
d890 10
a899 2
			rec->sw_code = slinear16_to_mulaw_le;
			rec->factor = 2;
d902 10
a911 2
			rec->sw_code = slinear16_to_alaw_le;
			rec->factor = 2;
d916 10
a925 2
				rec->sw_code = linear16_to_linear8_le;
				rec->factor = 2;
d928 8
d944 10
a953 2
				rec->sw_code = linear16_to_ulinear8_le;
				rec->factor = 2;
d956 9
a964 1
				rec->sw_code = change_sign16_le;
d973 10
a982 2
				rec->sw_code = linear16_to_linear8_le;
				rec->factor = 2;
d985 9
a993 1
				rec->sw_code = swap_bytes;
d1002 10
a1011 2
				rec->sw_code = linear16_to_ulinear8_le;
				rec->factor = 2;
d1014 9
a1022 1
				rec->sw_code = change_sign16_swap_bytes_le;
@


1.65
log
@Some bzero() -> M_ZERO. ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.64 2007/08/02 07:43:41 jakemsr Exp $	*/
d151 4
d164 11
d190 18
a207 19
	/* dma scatter-gather buffer lists, aligned to 8 bytes */
	struct auich_dmalist *dmalist_pcmo, *dmap_pcmo;
	struct auich_dmalist *dmalist_pcmi, *dmap_pcmi;
	struct auich_dmalist *dmalist_mici, *dmap_mici;

	bus_dmamap_t dmalist_map;
	bus_dma_segment_t dmalist_seg[2];
	caddr_t dmalist_kva;
	bus_addr_t dmalist_pcmo_pa;
	bus_addr_t dmalist_pcmi_pa;
	bus_addr_t dmalist_mici_pa;

	/* i/o buffer pointers */
	u_int32_t pcmo_start, pcmo_p, pcmo_end;
	int pcmo_blksize, pcmo_fifoe;
	u_int32_t pcmi_start, pcmi_p, pcmi_end;
	int pcmi_blksize, pcmi_fifoe;
	u_int32_t mici_start, mici_p, mici_end;
	int mici_blksize, mici_fifoe;
d210 4
a213 5
	void (*sc_pintr)(void *);
	void *sc_parg;

	void (*sc_rintr)(void *);
	void *sc_rarg;
d220 1
d231 1
a231 1
#define	AUICH_DEBUG_PARAM	0x0004
d286 1
d298 2
d304 3
d375 1
a375 2
	bus_size_t dmasz;
	int i, segs;
a425 31
	/* allocate dma memory */
	dmasz = AUICH_DMALIST_MAX * 3 * sizeof(struct auich_dma);
	segs = 1;
	if (bus_dmamem_alloc(sc->dmat, dmasz, PAGE_SIZE, 0, sc->dmalist_seg,
	    segs, &segs, BUS_DMA_NOWAIT)) {
		printf(": failed to alloc dmalist\n");
		return;
	}
	if (bus_dmamem_map(sc->dmat, sc->dmalist_seg, segs, dmasz,
	    &sc->dmalist_kva, BUS_DMA_NOWAIT)) {
		printf(": failed to map dmalist\n");
		bus_dmamem_free(sc->dmat, sc->dmalist_seg, segs);
		return;
	}
	if (bus_dmamap_create(sc->dmat, dmasz, segs, dmasz, 0, BUS_DMA_NOWAIT,
	    &sc->dmalist_map)) {
		printf(": failed to create dmalist map\n");
		bus_dmamem_unmap(sc->dmat, sc->dmalist_kva, dmasz);
		bus_dmamem_free(sc->dmat, sc->dmalist_seg, segs);
		return;
	}
	if (bus_dmamap_load_raw(sc->dmat, sc->dmalist_map, sc->dmalist_seg,
	    segs, dmasz, BUS_DMA_NOWAIT)) {
		printf(": failed to load dmalist map: %d segs %lu size\n",
		    segs, (u_long)dmasz);
		bus_dmamap_destroy(sc->dmat, sc->dmalist_map);
		bus_dmamem_unmap(sc->dmat, sc->dmalist_kva, dmasz);
		bus_dmamem_free(sc->dmat, sc->dmalist_seg, segs);
		return;
	}

d471 11
a481 14
	sc->dmalist_pcmo = (struct auich_dmalist *)(sc->dmalist_kva +
	    (0 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX));
	sc->dmalist_pcmo_pa = sc->dmalist_map->dm_segs[0].ds_addr +
	    (0 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX);

	sc->dmalist_pcmi = (struct auich_dmalist *)(sc->dmalist_kva +
	    (1 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX));
	sc->dmalist_pcmi_pa = sc->dmalist_map->dm_segs[0].ds_addr +
	    (1 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX);

	sc->dmalist_mici = (struct auich_dmalist *)(sc->dmalist_kva +
	    (2 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX));
	sc->dmalist_mici_pa = sc->dmalist_map->dm_segs[0].ds_addr +
	    (2 * sizeof(struct auich_dmalist) + AUICH_DMALIST_MAX);
d484 1
a484 1
	    sc->dmalist_pcmo, sc->dmalist_pcmi, sc->dmalist_mici));
d973 22
d1004 1
d1022 1
d1075 5
a1079 1
	if (size > AUICH_DMALIST_MAX * AUICH_DMASEG_MAX)
d1081 1
d1087 2
a1088 35
	p->size = size;
	if ((error = bus_dmamem_alloc(sc->dmat, p->size, NBPG, 0, p->segs,
	    1, &p->nsegs, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to allocate dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		free(p, pool);
		return NULL;
	}

	if ((error = bus_dmamem_map(sc->dmat, p->segs, p->nsegs, p->size,
	    &p->addr, BUS_DMA_NOWAIT | BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map dma, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
		free(p, pool);
		return NULL;
	}

	if ((error = bus_dmamap_create(sc->dmat, p->size, 1,
	    p->size, 0, BUS_DMA_NOWAIT, &p->map)) != 0) {
		printf("%s: unable to create dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamem_unmap(sc->dmat, p->addr, size);
		bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
		free(p, pool);
		return NULL;
	}

	if ((error = bus_dmamap_load(sc->dmat, p->map, p->addr, p->size,
	    NULL, BUS_DMA_NOWAIT)) != 0) {
		printf("%s: unable to load dma map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		bus_dmamap_destroy(sc->dmat, p->map);
		bus_dmamem_unmap(sc->dmat, p->addr, size);
		bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
d1100 1
a1100 4
auich_freem(v, ptr, pool)
	void *v;
	void *ptr;
	int pool;
d1102 2
a1103 2
	struct auich_softc *sc = v;
	struct auich_dma *p;
d1105 6
a1110 3
	for (p = sc->sc_dmas; p->addr != ptr; p = p->next)
		if (p->next == NULL) {
			printf("auich_freem: trying to free not allocated memory");
d1113 1
a1113 6

	bus_dmamap_unload(sc->dmat, p->map);
	bus_dmamap_destroy(sc->dmat, p->map);
	bus_dmamem_unmap(sc->dmat, p->addr, p->size);
	bus_dmamem_free(sc->dmat, p->segs, p->nsegs);
	free(p, pool);
d1161 1
a1161 1
	int ret = 0, sts, gsts, i;
d1163 2
a1164 2
	gsts = bus_space_read_2(sc->iot, sc->aud_ioh, AUICH_GSTS);
	DPRINTF(AUICH_DEBUG_DMA, ("auich_intr: gsts=%b\n", gsts, AUICH_GSTS_BITS));
d1169 1
a1169 1
		DPRINTF(AUICH_DEBUG_DMA,
a1177 20
		i = bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_CIV);
		if (sts & (AUICH_LVBCI | AUICH_CELV)) {
			struct auich_dmalist *q, *qe;

			q = sc->dmap_pcmo;
			qe = &sc->dmalist_pcmo[i];

			while (q != qe) {

				q->base = sc->pcmo_p;
				q->len = (sc->pcmo_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
				DPRINTF(AUICH_DEBUG_DMA,
				    ("auich_intr: %p, %p = %x @@ %p\n",
				    qe, q, sc->pcmo_blksize /
				    sc->sc_sample_size, sc->pcmo_p));

				sc->pcmo_p += sc->pcmo_blksize;
				if (sc->pcmo_p >= sc->pcmo_end)
					sc->pcmo_p = sc->pcmo_start;
d1179 2
a1180 13
				if (++q == &sc->dmalist_pcmo[AUICH_DMALIST_MAX])
					q = sc->dmalist_pcmo;
			}

			sc->dmap_pcmo = q;
			bus_space_write_1(sc->iot, sc->aud_ioh,
			    AUICH_PCMO + AUICH_LVI,
			    (sc->dmap_pcmo - sc->dmalist_pcmo - 1) &
			    AUICH_LVI_MASK);
		}

		if (sts & AUICH_BCIS && sc->sc_pintr)
			sc->sc_pintr(sc->sc_parg);
d1185 2
a1186 2
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_POINT);
d1193 1
a1193 1
		DPRINTF(AUICH_DEBUG_DMA,
a1201 20
		i = bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CIV);
		if (sts & (AUICH_LVBCI | AUICH_CELV)) {
			struct auich_dmalist *q, *qe;

			q = sc->dmap_pcmi;
			qe = &sc->dmalist_pcmi[i];

			while (q != qe) {

				q->base = sc->pcmi_p;
				q->len = (sc->pcmi_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
				DPRINTF(AUICH_DEBUG_DMA,
				    ("auich_intr: %p, %p = %x @@ %p\n",
				    qe, q, sc->pcmi_blksize /
				    sc->sc_sample_size, sc->pcmi_p));

				sc->pcmi_p += sc->pcmi_blksize;
				if (sc->pcmi_p >= sc->pcmi_end)
					sc->pcmi_p = sc->pcmi_start;
d1203 2
a1204 13
				if (++q == &sc->dmalist_pcmi[AUICH_DMALIST_MAX])
					q = sc->dmalist_pcmi;
			}

			sc->dmap_pcmi = q;
			bus_space_write_1(sc->iot, sc->aud_ioh,
			    AUICH_PCMI + AUICH_LVI,
			    (sc->dmap_pcmi - sc->dmalist_pcmi - 1) &
			    AUICH_LVI_MASK);
		}

		if (sts & AUICH_BCIS && sc->sc_rintr)
			sc->sc_rintr(sc->sc_rarg);
d1209 2
a1210 2
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_PIINT);
d1214 1
a1214 1
	if (gsts & AUICH_MIINT) {
d1217 1
a1217 1
		DPRINTF(AUICH_DEBUG_DMA,
d1224 2
a1225 1
		/* TODO mic input dma */
d1227 7
a1233 1
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_MIINT);
d1239 60
a1308 1
	struct auich_dmalist *q;
d1310 1
d1320 4
a1323 2
	sc->sc_pintr = intr;
	sc->sc_parg = arg;
d1330 4
a1333 11
	sc->pcmo_start = p->segs->ds_addr;
	sc->pcmo_p = sc->pcmo_start + blksize;
	sc->pcmo_end = sc->pcmo_start + ((char *)end - (char *)start);
	sc->pcmo_blksize = blksize;

	q = sc->dmap_pcmo = sc->dmalist_pcmo;
	q->base = sc->pcmo_start;
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
	if (++q == &sc->dmalist_pcmo[AUICH_DMALIST_MAX])
		q = sc->dmalist_pcmo;
	sc->dmap_pcmo = q;
d1336 2
a1337 5
	    sc->dmalist_pcmo_pa);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_CTRL,
	    AUICH_IOCE | AUICH_FEIE | AUICH_LVBIE | AUICH_RPBM);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_LVI,
	    (sc->dmap_pcmo - 1 - sc->dmalist_pcmo) & AUICH_LVI_MASK);
a1351 1
	struct auich_dmalist *q;
d1353 1
d1363 4
a1366 2
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;
d1373 4
a1376 11
	sc->pcmi_start = p->segs->ds_addr;
	sc->pcmi_p = sc->pcmi_start + blksize;
	sc->pcmi_end = sc->pcmi_start + ((char *)end - (char *)start);
	sc->pcmi_blksize = blksize;

	q = sc->dmap_pcmi = sc->dmalist_pcmi;
	q->base = sc->pcmi_start;
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
	if (++q == &sc->dmalist_pcmi[AUICH_DMALIST_MAX])
		q = sc->dmalist_pcmi;
	sc->dmap_pcmi = q;
d1379 2
a1380 5
	    sc->dmalist_pcmi_pa);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL,
	    AUICH_IOCE | AUICH_FEIE | AUICH_LVBIE | AUICH_RPBM);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_LVI,
	    (sc->dmap_pcmi - 1 - sc->dmalist_pcmi) & AUICH_LVI_MASK);
d1385 124
a1539 1

a1550 1
	int i;
d1573 3
a1575 4
	for (i = 0; i < AUICH_DMALIST_MAX; i++) {
		sc->dmalist_pcmi[i].base = p->map->dm_segs[0].ds_addr;
		sc->dmalist_pcmi[i].len = bytes / sc->sc_sample_size;
	}
d1593 1
a1593 1
	    sc->dmalist_pcmi_pa);
@


1.64
log
@add proper recording encodings to auich(4).

tested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.63 2006/12/29 13:04:37 pedro Exp $	*/
d1069 1
a1069 1
	p = malloc(sizeof(*p), pool, flags);
a1071 1
	bzero(p, sizeof(*p));
@


1.63
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.62 2006/08/19 19:06:51 brad Exp $	*/
d905 6
a910 1
			rec->sw_code = ulinear8_to_mulaw;
d913 10
a922 2
			if (rec->precision == 8)
				rec->sw_code = change_sign8;
d925 11
a935 5
			if (rec->precision == 16)
				rec->sw_code = change_sign16;
			break;
		case AUDIO_ENCODING_ALAW:
			rec->sw_code = ulinear8_to_alaw;
d938 6
a943 1
			if (rec->precision == 16)
d945 4
a948 2
			else
				rec->sw_code = change_sign8;
d951 11
a961 2
			if (rec->precision == 16)
				rec->sw_code = swap_bytes_change_sign16;
@


1.62
log
@add the Intel 6300ESB and 6321ESB AC97 controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.61 2006/08/01 21:36:54 brad Exp $	*/
d1315 1
a1315 1
	sc->pcmo_end = sc->pcmo_start + (end - start);
d1366 1
a1366 1
	sc->pcmi_end = sc->pcmi_start + (end - start);
@


1.61
log
@attach to the NVIDIA MCP51 AC97 controller as well.

From bsh@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.60 2006/05/29 08:46:58 jsg Exp $	*/
d240 2
@


1.60
log
@NVIDIA nForce MCP04 (some kind of nForce4) AC97 should work here
as well going by the Linux driver.

"fine by me" jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.59 2006/04/20 20:31:12 miod Exp $	*/
d259 1
@


1.59
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.58 2006/02/13 06:15:32 brad Exp $	*/
d258 1
@


1.58
log
@nVidia/nvidia -> NVIDIA
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.57 2005/11/26 14:31:26 krw Exp $	*/
d426 2
a427 1
		printf(": failed to load dmalist map: %d segs %u size\n", segs, dmasz);
@


1.57
log
@Add some missing 'break;'s in auich and auixp that lint spotted. While
here, use FALLTHRU or FALLTHROUGH to make lint even happier.

ok marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.56 2005/08/10 15:28:35 jsg Exp $	*/
d132 1
a132 1
#define	ICH_SIS_NV_CTL	0x4c	/* some SiS/nVidia register.  From Linux */
@


1.56
log
@Some additional ICH7 bits which aren't strictly necessary to work
but are desireable.  Tested by Mark Peoples, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.55 2005/08/09 04:10:10 mickey Exp $	*/
d805 1
d809 1
@


1.55
log
@do not set PCI_COMMAND_MASTER_ENABLE explicitly as it's already set in pcisubmatch(); kettenis@@ testing; brad@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.54 2005/08/04 13:22:49 jsg Exp $	*/
d62 1
a62 1
/* ICH4/ICH5/ICH6 native audio mixer BAR */
d64 1
a64 1
/* ICH4/ICH5/ICH6 native bus mastering BAR */
d357 2
a358 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801FB_ACA)) {
d360 1
a360 1
		 * Use native mode for ICH4/ICH5/ICH6
d503 2
a504 1
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801FB_ACA)) {
@


1.54
log
@Support for ICH7 audio tested by Mark.Peoples at asu.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.53 2005/05/31 19:17:03 jason Exp $	*/
a430 5

	/* enable bus mastering (should it not be mi?) */
	csr = pci_conf_read(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG);
	pci_conf_write(pa->pa_pc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
	    csr | PCI_COMMAND_MASTER_ENABLE);
@


1.53
log
@bus_dma-ify.  needs bus_dmamap_sync's, but works on coherent arch's now.
NOW: someone remove vtophys from the amd64 port before someone else gets
the silly idea that it somehow "works" on that port.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.52 2005/04/14 12:42:16 mickey Exp $	*/
d247 1
@


1.52
log
@make sure round_blocksize does not produce 0 after alignment
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.51 2005/04/05 21:08:47 marc Exp $	*/
a55 9
/*
 * XXX > 4GB kaboom: define kvtop as a truncated vtophys.  Will not
 * do the right thing on machines with more than 4 gig of ram.
 */
#if defined(__amd64__)
#include <uvm/uvm_extern.h>	/* for vtophys */
#define kvtop(va)		(int)vtophys((vaddr_t)(va))
#endif

d176 11
a186 6
	struct auich_dmalist *dmalist_pcmo, *dmap_pcmo,
	    dmasto_pcmo[AUICH_DMALIST_MAX+1];
	struct auich_dmalist *dmalist_pcmi, *dmap_pcmi,
	    dmasto_pcmi[AUICH_DMALIST_MAX+1];
	struct auich_dmalist *dmalist_mici, *dmap_mici,
	    dmasto_mici[AUICH_DMALIST_MAX+1];
d350 2
a351 1
	int i;
d401 31
a431 1
	/* enable bus mastering (should not it be mi?) */
d481 15
a495 6
	/* allocate dma lists */
#define	a(a)	(void *)(((u_long)(a) + sizeof(*(a)) - 1) & ~(sizeof(*(a))-1))
	sc->dmalist_pcmo = sc->dmap_pcmo = a(sc->dmasto_pcmo);
	sc->dmalist_pcmi = sc->dmap_pcmi = a(sc->dmasto_pcmi);
	sc->dmalist_mici = sc->dmap_mici = a(sc->dmasto_mici);
#undef a
d1321 1
a1321 1
	    kvtop((caddr_t)sc->dmalist_pcmo));
d1372 1
a1372 1
	    kvtop((caddr_t)sc->dmalist_pcmi));
d1468 1
a1468 1
	    kvtop((caddr_t)sc->dmalist_pcmi));
@


1.51
log
@
Don't clobber the returned sample rate when the AC97 changes it.
This lets an application know, should it bother testing, that a
requested bit rate is not available.   'looks ok to me' mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.50 2005/04/05 17:30:57 mickey Exp $	*/
d909 1
a909 1
	return blk & ~0x3f;
@


1.50
log
@match on nforce4 and nforce2-400 ac97 as well; form netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.49 2005/04/05 17:19:01 mickey Exp $	*/
d681 1
d848 1
a848 1
		orate = play->sample_rate;
d850 2
a851 2
			play->sample_rate = orate * AUICH_FIXED_RATE /
			    sc->sc_ac97rate;
d853 2
a854 1
		play->sample_rate = orate;
@


1.49
log
@from netbsd:
Some SiS 7012 chips come muted by default, so un-mute all SiS 7012 chips at
attach time the way Linux does it.  Reported and tested by Jonathan
Schleifer, I checked it didn't break my own 7012 device which doesn't need
that manipulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.48 2005/04/05 01:41:44 mickey Exp $	*/
d255 3
a257 1
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE3_ACA, 0, "nForce3" },
d260 1
@


1.48
log
@ich6 support from freebsd via [Bjorn] Sandell <biorn@@dce.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.47 2005/04/02 01:20:56 mickey Exp $	*/
d141 3
a352 10
	/* SiS 7012 needs special handling */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_7012_ACA) {
		sc->sc_sts_reg = AUICH_PICB;
		sc->sc_sample_size = 1;
	} else {
		sc->sc_sts_reg = AUICH_STS;
		sc->sc_sample_size = 2;
	}

d436 14
@


1.47
log
@mixer can endup mapped w/ a different tag and so give it one of its own; from 71@@becile.com pr4162
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.46 2005/03/22 20:03:07 marc Exp $	*/
d71 1
a71 1
/* ICH4/ICH5 native audio mixer BAR */
d73 1
a73 1
/* ICH4/ICH5 native bus mastering BAR */
d247 1
d362 2
a363 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801EB_ACA)) {
d365 1
a365 1
		 * Use native mode for ICH4/ICH5
d459 2
a460 1
		     PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801EB_ACA)) {
@


1.46
log
@
fix probable pasto that calculated a control register value for
reset then ignored the calculated value.   Also, move the underrun
and overrun printfs to AUICH_DEBUG.   As it was, you'd get at least
one underrun per play reported to the console.   Changes OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.45 2005/01/17 20:37:04 mickey Exp $	*/
d173 1
d366 1
a366 1
		    &sc->iot, &sc->mix_ioh, NULL, &mix_size, 0)) {
d371 1
a371 1
			    0, &sc->iot, &sc->mix_ioh, NULL, &mix_size, 0)) {
d386 1
a386 1
				bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
d392 1
a392 1
		    0, &sc->iot, &sc->mix_ioh, NULL, &mix_size, 0)) {
d400 1
a400 1
			bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
a411 1
		printf(": can't map interrupt\n");
d413 1
a413 1
		bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
d425 1
a425 1
		bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
d478 1
a478 1
		bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
d510 1
a510 1
	*val = bus_space_read_2(sc->iot, sc->mix_ioh, reg);
d532 1
a532 1
		bus_space_write_2(sc->iot, sc->mix_ioh, reg, val);
@


1.45
log
@try memory-mapped bars first that exist on ich4/ich5 and fall bak to io-mapped if that fails; from Lars Heidieke via Michael van der Westhuizen
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.44 2005/01/17 20:07:44 mickey Exp $	*/
d563 1
a563 1
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GCTRL, AUICH_CRESET);
d1106 1
d1111 1
a1111 1

d1161 1
d1166 1
a1166 1

d1215 1
d1218 1
@


1.44
log
@typo; from Michael van der Westhuizen <michael@@skanky.homeunix.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.43 2004/11/30 22:30:47 mickey Exp $	*/
d69 7
d357 45
a401 11
	    
	if (pci_mapreg_map(pa, AUICH_NAMBAR, PCI_MAPREG_TYPE_IO, 0,
			   &sc->iot, &sc->mix_ioh, NULL, &mix_size, 0)) {
		printf(": can't map codec i/o space\n");
		return;
	}
	if (pci_mapreg_map(pa, AUICH_NABMBAR, PCI_MAPREG_TYPE_IO, 0,
			   &sc->iot, &sc->aud_ioh, NULL, &aud_size, 0)) {
		printf(": can't map device i/o space\n");
		bus_space_unmap(sc->iot, sc->mix_ioh, mix_size);
		return;
d472 1
a472 1
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001) 
d1328 2
a1329 2
       int why;
       void *self;
@


1.43
log
@EB is just like DB does not set PCR; reported and tested by Jan Johansson <janj+openbsd@@wenf.org>auich.c
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.42 2004/09/20 17:27:53 grange Exp $	*/
d1163 1
a1163 1
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_GSTS, AUICH_POINT);
@


1.42
log
@Add nvidia nforce3 250 audio. From FreeBSD via deraadt@@.

``go for it'' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.41 2004/07/21 04:05:33 tedu Exp $	*/
d415 2
a416 1
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DB_ACA) {
@


1.41
log
@calibrate after opening.  helps if cpu speed is changing and microtime can't
be trusted. ok deraadt, several testers.  solves pr3814.  while here, art says
use microuptime.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.40 2004/07/08 00:34:47 deraadt Exp $	*/
d244 2
@


1.40
log
@nforce3; downsj
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.39 2004/05/10 20:12:49 marc Exp $	*/
d444 1
a444 1
	sc->sc_ac97rate = auich_calibrate(sc);
d543 4
d1374 1
a1374 1
	microtime(&t1);
d1380 1
a1380 1
		microtime(&t2);
d1386 1
a1386 1
	microtime(&t2);
@


1.39
log
@ugly hackery for auich support on amd64.
Will not work on machine with > 4G phys memory.   OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.38 2004/04/09 07:24:15 miod Exp $	*/
d243 1
@


1.38
log
@Warn the user if we don't attach the ac97 codec.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.37 2003/10/10 04:38:56 jason Exp $	*/
d55 9
@


1.37
log
@Calibration code from FreeBSD/NetBSD.  Some of the auich's are clocked too
high and sound particularly awful on playback.  Thanks to millert and marc
for testing (and frantzen for giving me a broken machine).
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.36 2003/08/06 21:08:06 millert Exp $	*/
d406 2
a407 1
		} else
d409 1
@


1.36
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.35 2003/06/12 18:08:09 mickey Exp $	*/
d139 2
d193 1
d296 1
d431 2
d607 1
d774 7
a780 1
		if ((error = ac97_set_rate(sc->codec_if, play, AUMODE_PLAY)))
d816 7
a822 1
		if ((error = ac97_set_rate(sc->codec_if, rec, AUMODE_RECORD)))
d1294 110
@


1.35
log
@several lusers suggested it should work none capable of definately answering the question does it play the damn music. see if anybody report problems w/ it now
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.34 2003/06/02 19:24:22 mickey Exp $	*/
d166 1
a166 1
	    dmasto_pcmi[AUICH_DMALIST_MAX+1];;
d168 1
a168 1
	    dmasto_mici[AUICH_DMALIST_MAX+1];;
@


1.34
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.33 2003/05/20 00:22:56 tedu Exp $	*/
d226 1
@


1.33
log
@add flags support for reversing stereo.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.32 2003/04/27 11:22:53 ho Exp $	*/
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.32
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.31 2003/03/19 20:15:02 mickey Exp $	*/
d192 1
d293 1
d412 3
d511 8
@


1.31
log
@match on nvidia nforce2; from netbsd@@ via wayne@@epipe.com.au; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.30 2003/01/21 13:04:59 mickey Exp $	*/
d359 2
a360 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, auich_intr, sc,
				       sc->sc_dev.dv_xname);
d375 6
a380 3
	sprintf(sc->sc_audev.name, "%s AC97", auich_devices[i].name);
	sprintf(sc->sc_audev.version, "0x%02x", PCI_REVISION(pa->pa_class));
	strcpy(sc->sc_audev.config, sc->sc_dev.dv_xname);
d529 1
a529 1
		strcpy(aep->name, AudioEulinear);
d535 1
a535 1
		strcpy(aep->name, AudioEmulaw);
d541 1
a541 1
		strcpy(aep->name, AudioEalaw);
d547 1
a547 1
		strcpy(aep->name, AudioEslinear);
d553 1
a553 1
		strcpy(aep->name, AudioEslinear_le);
d559 1
a559 1
		strcpy(aep->name, AudioEulinear_le);
d565 1
a565 1
		strcpy(aep->name, AudioEslinear_be);
d571 1
a571 1
		strcpy(aep->name, AudioEulinear_be);
@


1.30
log
@do not need explicit match on intel; from alexander.guy@@andern.org
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.29 2003/01/16 14:20:27 mickey Exp $	*/
d230 1
@


1.29
log
@add support for a few more devices (sis7012, nforce, amd768, amd8111), from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.28 2002/09/17 19:10:30 mickey Exp $	*/
a299 3

	if (PCI_VENDOR(pa->pa_id) != PCI_VENDOR_INTEL)
		return 0;
@


1.28
log
@match on ich4; from hunter@@dg.net.ua
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.27 2002/07/04 23:52:20 mickey Exp $	*/
d36 2
d89 10
d189 3
d217 1
d222 10
a231 6
	{ PCI_PRODUCT_INTEL_82801AA_ACA, 0, "ICH" },
	{ PCI_PRODUCT_INTEL_82801AB_ACA, 0, "ICH0" },
	{ PCI_PRODUCT_INTEL_82801BA_ACA, 0, "ICH2" },
	{ PCI_PRODUCT_INTEL_82801CA_ACA, 0, "ICH3" },
	{ PCI_PRODUCT_INTEL_82801DB_ACA, 0, "ICH4" },
	{ PCI_PRODUCT_INTEL_82440MX_ACA, 0, "440MX" },
d305 2
a306 1
		if (PCI_PRODUCT(pa->pa_id) == auich_devices[i].product)
d323 1
d326 10
d394 9
d437 1
a437 7
	if (i >= 0) {
		*val = bus_space_read_2(sc->iot, sc->mix_ioh, reg);
		DPRINTF(AUICH_DEBUG_CODECIO, ("%s: read_codec(%x, %x)\n",
		    sc->sc_dev.dv_xname, reg, *val));

		return 0;
	} else {
d440 1
a440 1
		return -1;
d442 5
d462 1
a462 1
	if (i >= 0) {
d466 1
a466 1
		return 0;
d470 1
a470 1
		return -1;
d490 1
d493 3
a495 2
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_GCTRL, 0);
	DELAY(10);
d504 1
a504 1
		    ("%s: write_codec timeout\n", sc->sc_dev.dv_xname));
d1009 2
a1010 1
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, AUICH_PCMO+AUICH_STS);
d1029 2
a1030 1
				q->len = (sc->pcmo_blksize / 2) | AUICH_DMAF_IOC;
d1033 2
a1034 1
				    qe, q, sc->pcmo_blksize / 2, sc->pcmo_p));
d1055 3
a1057 2
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_PCMO + AUICH_STS,
		    sts & (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1063 2
a1064 1
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, AUICH_PCMI+AUICH_STS);
d1083 2
a1084 1
				q->len = (sc->pcmi_blksize / 2) | AUICH_DMAF_IOC;
d1087 2
a1088 1
				    qe, q, sc->pcmi_blksize / 2, sc->pcmi_p));
d1109 3
a1111 2
		bus_space_write_2(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_STS,
		    sts & (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1117 2
a1118 1
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, AUICH_MICI+AUICH_STS);
d1168 1
a1168 1
	q->len = (blksize / 2) | AUICH_DMAF_IOC;
d1219 1
a1219 1
	q->len = (blksize / 2) | AUICH_DMAF_IOC;
@


1.27
log
@repair a dmesg cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.26 2002/03/24 20:41:19 mickey Exp $	*/
d210 1
@


1.26
log
@after codec reset wait for 1/2 sec; from mark@@mcs.vuw.ac.nz (http://mail-index.netbsd.org/port-i386/2002/03/18/0000.html)
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.25 2002/03/19 15:27:43 mickey Exp $	*/
d348 1
a348 1
	printf(": %s %s\n", intrstr, sc->sc_audev.name);
@


1.25
log
@fix the ich3 ac97 audio id
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.24 2002/03/14 03:16:06 millert Exp $	*/
d113 1
d395 1
a395 1
	if (i > 0) {
d421 1
a421 1
	if (i > 0) {
d449 2
d454 8
@


1.24
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.23 2002/03/14 01:26:58 millert Exp $	*/
d208 1
a208 1
	{ PCI_PRODUCT_INTEL_82801CA_CAM, 0, "ICH3" },
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.22 2002/01/20 19:56:53 ericj Exp $	*/
d229 4
a232 4
int auich_trigger_output __P((void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *));
int auich_trigger_input __P((void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *));
d350 1
a350 1
#define	a(a)	(void*)(((u_long)(a) + sizeof(*(a)) - 1) & ~(sizeof(*(a))-1))
@


1.22
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.21 2001/12/31 04:19:55 mickey Exp $	*/
d167 1
a167 1
	void (*sc_pintr) __P((void *));
d170 1
a170 1
	void (*sc_rintr) __P((void *));
d192 3
a194 3
int  auich_match __P((struct device *, void *, void *));
void auich_attach __P((struct device *, struct device *, void *));
int  auich_intr __P((void *));
d212 17
a228 17
int auich_open __P((void *, int));
void auich_close __P((void *));
int auich_query_encoding __P((void *, struct audio_encoding *));
int auich_set_params __P((void *, int, int, struct audio_params *,
    struct audio_params *));
int auich_round_blocksize __P((void *, int));
int auich_halt_output __P((void *));
int auich_halt_input __P((void *));
int auich_getdev __P((void *, struct audio_device *));
int auich_set_port __P((void *, mixer_ctrl_t *));
int auich_get_port __P((void *, mixer_ctrl_t *));
int auich_query_devinfo __P((void *, mixer_devinfo_t *));
void *auich_allocm __P((void *, int, size_t, int, int));
void auich_freem __P((void *, void *, int));
size_t auich_round_buffersize __P((void *, int, size_t));
paddr_t auich_mappage __P((void *, void *, off_t, int));
int auich_get_props __P((void *));
d234 1
a234 1
void auich_powerhook __P((int, void *));
d265 4
a268 4
int  auich_attach_codec __P((void *, struct ac97_codec_if *));
int  auich_read_codec __P((void *, u_int8_t, u_int16_t *));
int  auich_write_codec __P((void *, u_int8_t, u_int16_t));
void auich_reset_codec __P((void *));
@


1.21
log
@support playing mono; from Kazuhiko Fukuhara <zaa83571@@oak.zero.ad.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.20 2001/12/19 04:14:32 provos Exp $	*/
d224 1
a224 1
void *auich_allocm __P((void *, u_long, int, int));
d226 1
a226 1
u_long auich_round_buffersize __P((void *, u_long));
d819 1
a819 1
auich_allocm(v, size, pool, flags)
d821 2
a822 1
	u_long size;
d904 2
a905 2
u_long
auich_round_buffersize(v, size)
d907 2
a908 1
	u_long size;
@


1.20
log
@unbreak mickey commit; make vra work after resume.  previous commit
was based on jcs@@openbsd yds changed btw.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.19 2001/12/18 23:02:39 mickey Exp $	*/
d540 12
a551 2
			play->factor = 2;
			play->sw_code = mulaw_to_slinear16;
d554 30
a583 2
			if (play->precision == 8)
				play->sw_code = change_sign8;
d586 31
a616 2
			if (play->precision == 16)
				play->sw_code = change_sign16;
d619 10
a628 2
			play->factor = 2;
			play->sw_code = alaw_to_slinear16;
d631 31
a661 4
			if (play->precision == 16)
				play->sw_code = swap_bytes;
			else
				play->sw_code = change_sign8;
d664 31
a694 2
			if (play->precision == 16)
				play->sw_code = change_sign16_swap_bytes;
@


1.20.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.22 2002/01/20 19:56:53 ericj Exp $	*/
d224 1
a224 1
void *auich_allocm __P((void *, int, size_t, int, int));
d226 1
a226 1
size_t auich_round_buffersize __P((void *, int, size_t));
d540 2
a541 12
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = mulaw_to_slinear16_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = mulaw_to_slinear16;
				break;
			default:
				return (EINVAL);
			}
d544 2
a545 30
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = noswap_bytes_mts;
					break;
				case 2:
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d548 2
a549 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_mts;
					break;
				case 2:
					play->sw_code = change_sign16;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d552 2
a553 10
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = alaw_to_slinear16_mts;
			case 2:
				play->factor = 2;
				play->sw_code = alaw_to_slinear16;
			default:
				return (EINVAL);
			}
d556 4
a559 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_mts;
					break;
				case 2:
					play->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d562 2
a563 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_swap_bytes_mts;
					break;
				case 2:
					play->sw_code = change_sign16_swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d688 1
a688 1
auich_allocm(v, direction, size, pool, flags)
d690 1
a690 2
	int direction;
	size_t size;
d772 2
a773 2
size_t
auich_round_buffersize(v, direction, size)
d775 1
a775 2
	int direction;
	size_t size;
@


1.20.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.20.2.1 2002/01/31 22:55:34 niklas Exp $	*/
a112 1
#define	AUICH_RESETIMO		500000	/* us */
d167 1
a167 1
	void (*sc_pintr)(void *);
d170 1
a170 1
	void (*sc_rintr)(void *);
d192 3
a194 3
int  auich_match(struct device *, void *, void *);
void auich_attach(struct device *, struct device *, void *);
int  auich_intr(void *);
d208 1
a208 1
	{ PCI_PRODUCT_INTEL_82801CA_ACA, 0, "ICH3" },
d212 21
a232 21
int auich_open(void *, int);
void auich_close(void *);
int auich_query_encoding(void *, struct audio_encoding *);
int auich_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int auich_round_blocksize(void *, int);
int auich_halt_output(void *);
int auich_halt_input(void *);
int auich_getdev(void *, struct audio_device *);
int auich_set_port(void *, mixer_ctrl_t *);
int auich_get_port(void *, mixer_ctrl_t *);
int auich_query_devinfo(void *, mixer_devinfo_t *);
void *auich_allocm(void *, int, size_t, int, int);
void auich_freem(void *, void *, int);
size_t auich_round_buffersize(void *, int, size_t);
paddr_t auich_mappage(void *, void *, off_t, int);
int auich_get_props(void *);
int auich_trigger_output(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
int auich_trigger_input(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
d234 1
a234 1
void auich_powerhook(int, void *);
d265 4
a268 4
int  auich_attach_codec(void *, struct ac97_codec_if *);
int  auich_read_codec(void *, u_int8_t, u_int16_t *);
int  auich_write_codec(void *, u_int8_t, u_int16_t);
void auich_reset_codec(void *);
d350 1
a350 1
#define	a(a)	(void *)(((u_long)(a) + sizeof(*(a)) - 1) & ~(sizeof(*(a))-1))
d394 1
a394 1
	if (i >= 0) {
d420 1
a420 1
	if (i >= 0) {
a447 2
	int i;

a450 8

	for (i = AUICH_RESETIMO; i-- &&
	    !(bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS) & AUICH_PCR);
	    DELAY(1));

	if (i < 0)
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("%s: write_codec timeout\n", sc->sc_dev.dv_xname));
@


1.20.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.20.2.2 2002/06/11 03:42:24 art Exp $	*/
a209 1
	{ PCI_PRODUCT_INTEL_82801DB_ACA, 0, "ICH4" },
d348 1
a348 1
	printf(": %s, %s\n", intrstr, sc->sc_audev.name);
@


1.20.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 2
 *	http://www.intel.com/design/chipsets/datashts/290716.htm
 *	http://www.intel.com/design/chipsets/datashts/290744.htm
a86 10
#define		AUICH_SSM_78	0x40000000	/* S/PDIF slots 7 and 8 */
#define		AUICH_SSM_69	0x80000000	/* S/PDIF slots 6 and 9 */
#define		AUICH_SSM_1011	0xc0000000	/* S/PDIF slots 10 and 11 */
#define		AUICH_POM16	0x000000	/* PCM out precision 16bit */
#define		AUICH_POM20	0x400000	/* PCM out precision 20bit */
#define		AUICH_PCM246_MASK 0x300000
#define		AUICH_PCM2	0x000000	/* 2ch output */
#define		AUICH_PCM4	0x100000	/* 4ch output */
#define		AUICH_PCM6	0x200000	/* 6ch output */
#define		AUICH_S2RIE	0x40	/* int when tertiary codec resume */
a176 3
	int sc_sample_size;
	int sc_sts_reg;
	int sc_ignore_codecready;
a201 1
	int	vendor;
d206 6
a211 11
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AA_ACA,	0, "ICH" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AB_ACA,	0, "ICH0" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801BA_ACA,	0, "ICH2" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801CA_ACA,	0, "ICH3" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801DB_ACA,	0, "ICH4" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82440MX_ACA,	0, "440MX" },
	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_7012_ACA,	0, "SiS7012" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE_ACA,	0, "nForce" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE2_ACA,	0, "nForce2" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC768_ACA,	0, "AMD768" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_8111_ACA,	0, "AMD8111" },
d281 3
d285 1
a285 2
		if (PCI_VENDOR(pa->pa_id) == auich_devices[i].vendor &&
		    PCI_PRODUCT(pa->pa_id) == auich_devices[i].product)
a301 1
	u_int32_t status;
a303 10
	/* SiS 7012 needs special handling */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_7012_ACA) {
		sc->sc_sts_reg = AUICH_PICB;
		sc->sc_sample_size = 1;
	} else {
		sc->sc_sts_reg = AUICH_STS;
		sc->sc_sample_size = 2;
	}
	    
d329 2
a330 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, auich_intr,
				       sc, sc->sc_dev.dv_xname);
d345 3
a347 6
	snprintf(sc->sc_audev.name, sizeof sc->sc_audev.name, "%s AC97",
		 auich_devices[i].name);
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audev.config, sc->sc_dev.dv_xname,
		sizeof sc->sc_audev.config);
a361 9
	status = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS);
	if (!(status & AUICH_PCR)) {	/* reset failure */
		if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DB_ACA) {
			/* MSI 845G Max never return AUICH_PCR */
			sc->sc_ignore_codecready = 1;
		} else
			return;
	}
d396 7
a402 1
	if (!sc->sc_ignore_codecready && i < 0) {
d405 1
a405 1
		return (-1);
a406 5

	*val = bus_space_read_2(sc->iot, sc->mix_ioh, reg);
	DPRINTF(AUICH_DEBUG_CODECIO, ("%s: read_codec(%x, %x)\n",
	    sc->sc_dev.dv_xname, reg, *val));
	return (0);
d422 1
a422 1
	if (sc->sc_ignore_codecready || i >= 0) {
d426 1
a426 1
		return (0);
d430 1
a430 1
		return (-1);
a449 1
	u_int32_t control;
d452 2
a453 3
	control = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GCTRL);
	control &= ~(AUICH_ACLSO | AUICH_PCM246_MASK);
	control |= (control & AUICH_CRESET) ? AUICH_WRESET : AUICH_CRESET;
d462 1
a462 1
		    ("%s: reset_codec timeout\n", sc->sc_dev.dv_xname));
d486 1
a486 1
		strlcpy(aep->name, AudioEulinear, sizeof aep->name);
d492 1
a492 1
		strlcpy(aep->name, AudioEmulaw, sizeof aep->name);
d498 1
a498 1
		strlcpy(aep->name, AudioEalaw, sizeof aep->name);
d504 1
a504 1
		strlcpy(aep->name, AudioEslinear, sizeof aep->name);
d510 1
a510 1
		strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
d516 1
a516 1
		strlcpy(aep->name, AudioEulinear_le, sizeof aep->name);
d522 1
a522 1
		strlcpy(aep->name, AudioEslinear_be, sizeof aep->name);
d528 1
a528 1
		strlcpy(aep->name, AudioEulinear_be, sizeof aep->name);
d967 1
a967 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg);
d986 1
a986 2
				q->len = (sc->pcmo_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
d989 1
a989 2
				    qe, q, sc->pcmo_blksize /
				    sc->sc_sample_size, sc->pcmo_p));
d1010 2
a1011 3
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg, sts &
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1017 1
a1017 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg);
d1036 1
a1036 2
				q->len = (sc->pcmi_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
d1039 1
a1039 2
				    qe, q, sc->pcmi_blksize /
				    sc->sc_sample_size, sc->pcmi_p));
d1060 2
a1061 3
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg, sts &
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1067 1
a1067 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_MICI + sc->sc_sts_reg);
d1117 1
a1117 1
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
d1168 1
a1168 1
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
@


1.19
log
@correctly deal w/ ext_ctrl in powerhook
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.18 2001/12/18 22:55:25 provos Exp $	*/
d1062 2
a1064 1
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
@


1.18
log
@powerhook for auich; based on jason's changed for yds; okay mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.17 2001/10/31 11:00:24 art Exp $	*/
d175 1
d1049 1
a1051 2
		u_int16_t id, ext_id;

d1062 1
a1062 9

		auich_read_codec(sc, AC97_REG_EXT_AUDIO_ID, &ext_id);
		auich_read_codec(sc, AC97_REG_EXT_AUDIO_ID, &id);
		if (ext_id & AC97_EXT_AUDIO_VRA)
			id |= AC97_EXT_AUDIO_VRA;
		if (ext_id & AC97_EXT_AUDIO_VRM)
			id |= AC97_EXT_AUDIO_VRM;
		auich_write_codec(sc, AC97_REG_EXT_AUDIO_CTRL, id);

@


1.17
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.16 2001/10/24 03:43:48 mickey Exp $	*/
d172 3
d233 2
d374 4
d1037 37
@


1.16
log
@do not use kvtop(), use dma maps' stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.15 2001/09/10 17:38:54 mickey Exp $	*/
d223 1
a223 1
int auich_mappage __P((void *, void *, int, int));
d773 1
a773 1
int
d777 1
a777 1
	int off;
@


1.15
log
@fix the bzero size, not that it matters that much
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.14 2001/09/05 03:07:44 provos Exp $	*/
d937 1
d941 1
a941 2
	    kvtop((caddr_t)start), kvtop((caddr_t)end),
	    blksize, intr, arg, param));
a942 3
#ifdef DIAGNOSTIC
	{
	struct auich_dma *p;
d946 1
a946 2
	}
#endif
d955 1
a955 1
	sc->pcmo_start = kvtop((caddr_t)start);
d957 1
a957 1
	sc->pcmo_end = kvtop((caddr_t)end);
d988 1
d992 1
a992 2
	    kvtop((caddr_t)start), kvtop((caddr_t)end),
	    blksize, intr, arg, param));
a993 3
#ifdef DIAGNOSTIC
	{
	struct auich_dma *p;
d997 1
a997 2
	}
#endif
d1006 1
a1006 1
	sc->pcmi_start = kvtop((caddr_t)start);
d1008 1
a1008 1
	sc->pcmi_end = kvtop((caddr_t)end);
@


1.14
log
@add intel ich3 ac97
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.12 2001/06/12 15:40:30 niklas Exp $	*/
d693 1
a693 2

	bzero(p, sizeof(p));
@


1.13
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d204 1
@


1.12
log
@Make pci_mapreg_map take an extra argument where we can
put a size limitation of the PCI region to map.  That makes the PERC 3/Di
raid controller usable, as it publishes too much PCI memory for us to map
in the kernel virtual memory.  As we only access the first 256 byte it is
of no use to map 128MB of kvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.11 2001/06/06 22:11:29 mickey Exp $	*/
d313 1
a313 2
	if (pci_intr_map(pa->pa_pc, pa->pa_intrtag, pa->pa_intrpin,
			 pa->pa_intrline, &ih)) {
@


1.11
log
@be more consistant in codec i/o debug prints
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.10 2001/05/16 23:38:04 mickey Exp $	*/
d296 1
a296 1
			   &sc->iot, &sc->mix_ioh, NULL, &mix_size)) {
d301 1
a301 1
			   &sc->iot, &sc->aud_ioh, NULL, &aud_size)) {
@


1.10
log
@use ac97_set_rate, auvia can use it too, cannot test it though
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.9 2001/05/16 06:29:15 mickey Exp $	*/
d386 2
a387 2
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("auich_read_codec(%x, %x)\n", reg, *val));
a405 2
	DPRINTF(AUICH_DEBUG_CODECIO, ("auich_write_codec(%x, %x)\n", reg, val));

d411 2
@


1.9
log
@dump private extended ac97 reg defs
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8 2001/04/16 03:18:18 deraadt Exp $	*/
a113 4
#define	AUICH_PM_PCMI		0x100
#define	AUICH_PM_PCMO		0x200
#define	AUICH_PM_MICI		0x400

d523 1
a523 1
	u_int16_t val, rate;
d556 1
a556 1
			return EINVAL;
d559 2
a560 9
		auich_read_codec(sc, AC97_REG_POWER, &val);
		auich_write_codec(sc, AC97_REG_POWER, val | AUICH_PM_PCMO);

		auich_write_codec(sc, AC97_REG_FRONT_DAC_RATE,
		    play->sample_rate);
		auich_read_codec(sc, AC97_REG_FRONT_DAC_RATE, &rate);
		play->sample_rate = rate;

		auich_write_codec(sc, AC97_REG_POWER, val);
d582 2
a583 2
			if (play->precision == 16)
				play->sw_code = swap_bytes;
d585 1
a585 1
				play->sw_code = change_sign8;
d588 2
a589 2
			if (play->precision == 16)
				play->sw_code = swap_bytes_change_sign16;
d592 1
a592 1
			return EINVAL;
d595 2
a596 8
		auich_read_codec(sc, AC97_REG_POWER, &val);
		auich_write_codec(sc, AC97_REG_POWER, val | AUICH_PM_PCMI);

		auich_write_codec(sc, AC97_REG_PCM_DAC_RATE, play->sample_rate);
		auich_read_codec(sc, AC97_REG_PCM_DAC_RATE, &rate);
		play->sample_rate = rate;

		auich_write_codec(sc, AC97_REG_POWER, val);
d599 1
a599 1
	return 0;
@


1.8
log
@dmesg cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.7 2001/03/09 09:26:45 mickey Exp $	*/
d112 1
a112 1
#define	AUICH_SEMATIMO	1000	/* us */
d114 3
a116 32
#define	AUICH_MIXER_RESET		0x00
#define	AUICH_MIXER_MUTE		0x02
#define	AUICH_MIXER_HDFMUTE	0x04
#define	AUICH_MIXER_MONOMUTE	0x06
#define	AUICH_MIXER_TONE		0x08
#define	AUICH_MIXER_BEEPMUTE	0x0a
#define	AUICH_MIXER_PHONEMUTE	0x0c
#define	AUICH_MIXER_MICMUTE	0x0e
#define	AUICH_MIXER_LINEMUTE	0x10
#define	AUICH_MIXER_CDMUTE	0x12
#define	AUICH_MIXER_VDMUTE	0x14
#define	AUICH_MIXER_AUXMUTE	0x16
#define	AUICH_MIXER_PCMMUTE	0x18
#define	AUICH_MIXER_RECSEL	0x1a
#define	AUICH_MIXER_RECGAIN	0x1c
#define	AUICH_MIXER_RECGAINMIC	0x1e
#define	AUICH_MIXER_GP		0x20
#define	AUICH_MIXER_3DCTRL	0x22
#define	AUICH_MIXER_RESERVED	0x24
#define	AUICH_PM			0x26
#define		AUICH_PM_PCMI	0x100
#define		AUICH_PM_PCMO	0x200
#define		AUICH_PM_MICI	0x400
#define	AUICH_EXTAUDIO		0x28
#define	AUICH_EXTAUCTRL		0x2a
#define	AUICH_PCMRATE		0x2c
#define	AUICH_PCM3dRATE		0x2e
#define	AUICH_PCMLFERATE		0x30
#define	AUICH_PCMLRRATE		0x32
#define	AUICH_MICADCRATE		0x34
#define	AUICH_CLFEMUTE		0x36
#define	AUICH_LR3DMUTE		0x38
d563 2
a564 2
		auich_read_codec(sc, AUICH_PM, &val);
		auich_write_codec(sc, AUICH_PM, val | AUICH_PM_PCMO);
d566 3
a568 2
		auich_write_codec(sc, AUICH_PCMRATE, play->sample_rate);
		auich_read_codec(sc, AUICH_PCMRATE, &rate);
d571 1
a571 1
		auich_write_codec(sc, AUICH_PM, val);
d606 2
a607 2
		auich_read_codec(sc, AUICH_PM, &val);
		auich_write_codec(sc, AUICH_PM, val | AUICH_PM_PCMI);
d609 2
a610 2
		auich_write_codec(sc, AUICH_PCMLFERATE, play->sample_rate);
		auich_read_codec(sc, AUICH_PCMLFERATE, &rate);
d613 1
a613 1
		auich_write_codec(sc, AUICH_PM, val);
@


1.8.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8 2001/04/16 03:18:18 deraadt Exp $	*/
@


1.8.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8.4.1 2001/05/14 22:25:33 niklas Exp $	*/
d112 34
a145 1
#define	AUICH_SEMATIMO		1000	/* us */
d329 1
a329 1
			   &sc->iot, &sc->mix_ioh, NULL, &mix_size, 0)) {
d334 1
a334 1
			   &sc->iot, &sc->aud_ioh, NULL, &aud_size, 0)) {
d419 2
a420 2
		DPRINTF(AUICH_DEBUG_CODECIO, ("%s: read_codec(%x, %x)\n",
		    sc->sc_dev.dv_xname, reg, *val));
d439 2
a445 2
		DPRINTF(AUICH_DEBUG_CODECIO, ("%s: write_codec(%x, %x)\n",
		    sc->sc_dev.dv_xname, reg, val));
d556 1
a556 1
	int error;
d589 1
a589 1
			return (EINVAL);
d592 8
a599 2
		if ((error = ac97_set_rate(sc->codec_if, play, AUMODE_PLAY)))
			return (error);
d621 2
a622 2
			if (rec->precision == 16)
				rec->sw_code = swap_bytes;
d624 1
a624 1
				rec->sw_code = change_sign8;
d627 2
a628 2
			if (rec->precision == 16)
				rec->sw_code = swap_bytes_change_sign16;
d631 1
a631 1
			return (EINVAL);
d634 8
a641 2
		if ((error = ac97_set_rate(sc->codec_if, rec, AUMODE_RECORD)))
			return (error);
d644 1
a644 1
	return (0);
@


1.8.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8.4.2 2001/07/04 10:41:53 niklas Exp $	*/
a203 1
	{ PCI_PRODUCT_INTEL_82801CA_CAM, 0, "ICH3" },
d313 2
a314 1
	if (pci_intr_map(pa, &ih)) {
d693 2
a694 1
	bzero(p, sizeof(*p));
a937 1
	struct auich_dma *p;
d941 2
a942 1
	    start, end, blksize, intr, arg, param));
d944 3
d950 2
a951 1

d960 1
a960 1
	sc->pcmo_start = p->segs->ds_addr;
d962 1
a962 1
	sc->pcmo_end = sc->pcmo_start + (end - start);
a992 1
	struct auich_dma *p;
d996 2
a997 1
	    start, end, blksize, intr, arg, param));
d999 3
d1005 2
a1006 1

d1015 1
a1015 1
	sc->pcmi_start = p->segs->ds_addr;
d1017 1
a1017 1
	sc->pcmi_end = sc->pcmi_start + (end - start);
@


1.8.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d223 1
a223 1
paddr_t auich_mappage __P((void *, void *, off_t, int));
d773 1
a773 1
paddr_t
d777 1
a777 1
	off_t off;
@


1.8.4.5
log
@Merge in trunk
@
text
@a171 4

	void *powerhook;
	int suspend;
	u_int16_t ext_ctrl;
d220 1
a220 1
void *auich_allocm __P((void *, int, size_t, int, int));
d222 1
a222 1
size_t auich_round_buffersize __P((void *, int, size_t));
a229 2
void auich_powerhook __P((int, void *));

a368 4

	/* Watch for power changes */
	sc->suspend = PWR_RESUME;
	sc->powerhook = powerhook_establish(auich_powerhook, sc);
d530 2
a531 12
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = mulaw_to_slinear16_mts;
				break;
			case 2:
				play->factor = 2;
				play->sw_code = mulaw_to_slinear16;
				break;
			default:
				return (EINVAL);
			}
d534 2
a535 30
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = noswap_bytes_mts;
					break;
				case 2:
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d538 2
a539 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_mts;
					break;
				case 2:
					play->sw_code = change_sign16;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d542 2
a543 10
			switch (play->channels) {
			case 1:
				play->factor = 4;
				play->sw_code = alaw_to_slinear16_mts;
			case 2:
				play->factor = 2;
				play->sw_code = alaw_to_slinear16;
			default:
				return (EINVAL);
			}
d546 4
a549 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = linear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = linear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = swap_bytes_mts;
					break;
				case 2:
					play->sw_code = swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d552 2
a553 31
			switch (play->precision) {
			case 8:
				switch (play->channels) {
				case 1:
					play->factor = 4;
					play->sw_code = ulinear8_to_linear16_mts;
					break;
				case 2:
					play->factor = 2;
					play->sw_code = ulinear8_to_linear16;
					break;
				default:
					return (EINVAL);
				}
				break;
			case 16:
				switch (play->channels) {
				case 1:
					play->factor = 2;
					play->sw_code = change_sign16_swap_bytes_mts;
					break;
				case 2:
					play->sw_code = change_sign16_swap_bytes;
					break;
				default:
					return (EINVAL);
				}
				break;
			default:
				return (EINVAL);
			}
d678 1
a678 1
auich_allocm(v, direction, size, pool, flags)
d680 1
a680 2
	int direction;
	size_t size;
d762 2
a763 2
size_t
auich_round_buffersize(v, direction, size)
d765 1
a765 2
	int direction;
	size_t size;
a1027 29
void
auich_powerhook(why, self)
       int why;
       void *self;
{
	struct auich_softc *sc = (struct auich_softc *)self;

	if (why != PWR_RESUME) {
		/* Power down */
		DPRINTF(1, ("auich: power down\n"));
		sc->suspend = why;
		auich_read_codec(sc, AC97_REG_EXT_AUDIO_CTRL, &sc->ext_ctrl);

	} else {
		/* Wake up */
		DPRINTF(1, ("auich: power resume\n"));
		if (sc->suspend == PWR_RESUME) {
			printf("%s: resume without suspend?\n",
			    sc->sc_dev.dv_xname);
			sc->suspend = why;
			return;
		}
		sc->suspend = why;
		auich_reset_codec(sc);
		DELAY(1000);
		(sc->codec_if->vtbl->restore_ports)(sc->codec_if);
		auich_write_codec(sc, AC97_REG_EXT_AUDIO_CTRL, sc->ext_ctrl);
	}
}
@


1.8.4.6
log
@Merge in -current from roughly a week ago
@
text
@d167 1
a167 1
	void (*sc_pintr)(void *);
d170 1
a170 1
	void (*sc_rintr)(void *);
d192 3
a194 3
int  auich_match(struct device *, void *, void *);
void auich_attach(struct device *, struct device *, void *);
int  auich_intr(void *);
d208 1
a208 1
	{ PCI_PRODUCT_INTEL_82801CA_ACA, 0, "ICH3" },
d212 21
a232 21
int auich_open(void *, int);
void auich_close(void *);
int auich_query_encoding(void *, struct audio_encoding *);
int auich_set_params(void *, int, int, struct audio_params *,
    struct audio_params *);
int auich_round_blocksize(void *, int);
int auich_halt_output(void *);
int auich_halt_input(void *);
int auich_getdev(void *, struct audio_device *);
int auich_set_port(void *, mixer_ctrl_t *);
int auich_get_port(void *, mixer_ctrl_t *);
int auich_query_devinfo(void *, mixer_devinfo_t *);
void *auich_allocm(void *, int, size_t, int, int);
void auich_freem(void *, void *, int);
size_t auich_round_buffersize(void *, int, size_t);
paddr_t auich_mappage(void *, void *, off_t, int);
int auich_get_props(void *);
int auich_trigger_output(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
int auich_trigger_input(void *, void *, void *, int, void (*)(void *),
    void *, struct audio_params *);
d234 1
a234 1
void auich_powerhook(int, void *);
d265 4
a268 4
int  auich_attach_codec(void *, struct ac97_codec_if *);
int  auich_read_codec(void *, u_int8_t, u_int16_t *);
int  auich_write_codec(void *, u_int8_t, u_int16_t);
void auich_reset_codec(void *);
d350 1
a350 1
#define	a(a)	(void *)(((u_long)(a) + sizeof(*(a)) - 1) & ~(sizeof(*(a))-1))
@


1.8.4.7
log
@Sync the SMP branch with 3.3
@
text
@a35 2
 *	http://www.intel.com/design/chipsets/datashts/290716.htm
 *	http://www.intel.com/design/chipsets/datashts/290744.htm
a86 10
#define		AUICH_SSM_78	0x40000000	/* S/PDIF slots 7 and 8 */
#define		AUICH_SSM_69	0x80000000	/* S/PDIF slots 6 and 9 */
#define		AUICH_SSM_1011	0xc0000000	/* S/PDIF slots 10 and 11 */
#define		AUICH_POM16	0x000000	/* PCM out precision 16bit */
#define		AUICH_POM20	0x400000	/* PCM out precision 20bit */
#define		AUICH_PCM246_MASK 0x300000
#define		AUICH_PCM2	0x000000	/* 2ch output */
#define		AUICH_PCM4	0x100000	/* 4ch output */
#define		AUICH_PCM6	0x200000	/* 6ch output */
#define		AUICH_S2RIE	0x40	/* int when tertiary codec resume */
a112 1
#define	AUICH_RESETIMO		500000	/* us */
a175 3
	int sc_sample_size;
	int sc_sts_reg;
	int sc_ignore_codecready;
a200 1
	int	vendor;
d205 5
a209 11
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AA_ACA,	0, "ICH" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AB_ACA,	0, "ICH0" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801BA_ACA,	0, "ICH2" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801CA_ACA,	0, "ICH3" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801DB_ACA,	0, "ICH4" },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82440MX_ACA,	0, "440MX" },
	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_7012_ACA,	0, "SiS7012" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE_ACA,	0, "nForce" },
	{ PCI_VENDOR_NVIDIA,	PCI_PRODUCT_NVIDIA_NFORCE2_ACA,	0, "nForce2" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC768_ACA,	0, "AMD768" },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_8111_ACA,	0, "AMD8111" },
d279 3
d283 1
a283 2
		if (PCI_VENDOR(pa->pa_id) == auich_devices[i].vendor &&
		    PCI_PRODUCT(pa->pa_id) == auich_devices[i].product)
a299 1
	u_int32_t status;
a301 10
	/* SiS 7012 needs special handling */
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SIS &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SIS_7012_ACA) {
		sc->sc_sts_reg = AUICH_PICB;
		sc->sc_sample_size = 1;
	} else {
		sc->sc_sts_reg = AUICH_STS;
		sc->sc_sample_size = 2;
	}
	    
d347 1
a347 1
	printf(": %s, %s\n", intrstr, sc->sc_audev.name);
a359 9
	status = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS);
	if (!(status & AUICH_PCR)) {	/* reset failure */
		if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_INTEL &&
		    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_INTEL_82801DB_ACA) {
			/* MSI 845G Max never return AUICH_PCR */
			sc->sc_ignore_codecready = 1;
		} else
			return;
	}
d394 7
a400 1
	if (!sc->sc_ignore_codecready && i < 0) {
d403 1
a403 1
		return (-1);
a404 5

	*val = bus_space_read_2(sc->iot, sc->mix_ioh, reg);
	DPRINTF(AUICH_DEBUG_CODECIO, ("%s: read_codec(%x, %x)\n",
	    sc->sc_dev.dv_xname, reg, *val));
	return (0);
d420 1
a420 1
	if (sc->sc_ignore_codecready || i >= 0) {
d424 1
a424 1
		return (0);
d428 1
a428 1
		return (-1);
d448 2
a449 6
	u_int32_t control;
	int i;

	control = bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GCTRL);
	control &= ~(AUICH_ACLSO | AUICH_PCM246_MASK);
	control |= (control & AUICH_CRESET) ? AUICH_WRESET : AUICH_CRESET;
a450 8

	for (i = AUICH_RESETIMO; i-- &&
	    !(bus_space_read_4(sc->iot, sc->aud_ioh, AUICH_GSTS) & AUICH_PCR);
	    DELAY(1));

	if (i < 0)
		DPRINTF(AUICH_DEBUG_CODECIO,
		    ("%s: reset_codec timeout\n", sc->sc_dev.dv_xname));
d955 1
a955 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg);
d974 1
a974 2
				q->len = (sc->pcmo_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
d977 1
a977 2
				    qe, q, sc->pcmo_blksize /
				    sc->sc_sample_size, sc->pcmo_p));
d998 2
a999 3
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMO + sc->sc_sts_reg, sts &
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1005 1
a1005 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg);
d1024 1
a1024 2
				q->len = (sc->pcmi_blksize /
				    sc->sc_sample_size) | AUICH_DMAF_IOC;
d1027 1
a1027 2
				    qe, q, sc->pcmi_blksize /
				    sc->sc_sample_size, sc->pcmi_p));
d1048 2
a1049 3
		bus_space_write_2(sc->iot, sc->aud_ioh,
		    AUICH_PCMI + sc->sc_sts_reg, sts &
		    (AUICH_LVBCI | AUICH_CELV | AUICH_BCIS | AUICH_FIFOE));
d1055 1
a1055 2
		sts = bus_space_read_2(sc->iot, sc->aud_ioh,
		    AUICH_MICI + sc->sc_sts_reg);
d1105 1
a1105 1
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
d1156 1
a1156 1
	q->len = (blksize / sc->sc_sample_size) | AUICH_DMAF_IOC;
@


1.8.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8.4.7 2003/03/28 00:38:20 niklas Exp $	*/
d359 2
a360 2
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, auich_intr,
				       sc, sc->sc_dev.dv_xname);
d375 3
a377 6
	snprintf(sc->sc_audev.name, sizeof sc->sc_audev.name, "%s AC97",
		 auich_devices[i].name);
	snprintf(sc->sc_audev.version, sizeof sc->sc_audev.version, "0x%02x",
		 PCI_REVISION(pa->pa_class));
	strlcpy(sc->sc_audev.config, sc->sc_dev.dv_xname,
		sizeof sc->sc_audev.config);
d526 1
a526 1
		strlcpy(aep->name, AudioEulinear, sizeof aep->name);
d532 1
a532 1
		strlcpy(aep->name, AudioEmulaw, sizeof aep->name);
d538 1
a538 1
		strlcpy(aep->name, AudioEalaw, sizeof aep->name);
d544 1
a544 1
		strlcpy(aep->name, AudioEslinear, sizeof aep->name);
d550 1
a550 1
		strlcpy(aep->name, AudioEslinear_le, sizeof aep->name);
d556 1
a556 1
		strlcpy(aep->name, AudioEulinear_le, sizeof aep->name);
d562 1
a562 1
		strlcpy(aep->name, AudioEslinear_be, sizeof aep->name);
d568 1
a568 1
		strlcpy(aep->name, AudioEulinear_be, sizeof aep->name);
@


1.8.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.8.4.8 2003/05/13 19:35:04 ho Exp $	*/
d15 2
a191 1
	int flags;
a291 1
enum ac97_host_flags auich_flags_codec(void *);
a409 3
	sc->host_if.flags = auich_flags_codec;
	if (sc->sc_dev.dv_cfdata->cf_flags & 0x0001) 
		sc->flags = AC97_HOST_SWAPPED_CHANNELS;
a505 8
}

enum ac97_host_flags
auich_flags_codec(void *v)
{
	struct auich_softc *sc = v;

	return (sc->flags);
@


1.8.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a138 2
#define	AUICH_FIXED_RATE 48000

d166 1
a166 1
	    dmasto_pcmi[AUICH_DMALIST_MAX+1];
d168 1
a168 1
	    dmasto_mici[AUICH_DMALIST_MAX+1];
a190 1
	int sc_ac97rate;
a225 1
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801EB_ACA,	0, "ICH5" },
a291 1
unsigned int auich_calibrate(struct auich_softc *);
a425 2

	sc->sc_ac97rate = auich_calibrate(sc);
a599 1
	u_int orate;
d766 1
a766 7
		orate = play->sample_rate;
		if (sc->sc_ac97rate != 0)
			play->sample_rate = orate * AUICH_FIXED_RATE /
			    sc->sc_ac97rate;
		error = ac97_set_rate(sc->codec_if, play, AUMODE_PLAY);
		play->sample_rate = orate;
		if (error)
d802 1
a802 7
		orate = rec->sample_rate;
		if (sc->sc_ac97rate != 0)
			rec->sample_rate = orate * AUICH_FIXED_RATE /
			    sc->sc_ac97rate;
		error = ac97_set_rate(sc->codec_if, rec, AUMODE_RECORD);
		rec->sample_rate = orate;
		if (error)
a1273 110
}



/* -------------------------------------------------------------------- */
/* Calibrate card (some boards are overclocked and need scaling) */

unsigned int
auich_calibrate(struct auich_softc *sc)
{
	struct timeval t1, t2;
	u_int8_t ociv, nciv;
	u_int32_t wait_us, actual_48k_rate, bytes, ac97rate;
	void *temp_buffer;
	struct auich_dma *p;
	int i;

	ac97rate = AUICH_FIXED_RATE;
	/*
	 * Grab audio from input for fixed interval and compare how
	 * much we actually get with what we expect.  Interval needs
	 * to be sufficiently short that no interrupts are
	 * generated.
	 */

	/* Setup a buffer */
	bytes = 16000;
	temp_buffer = auich_allocm(sc, AUMODE_RECORD, bytes, M_DEVBUF,
	    M_NOWAIT);
	if (temp_buffer == NULL)
		return (ac97rate);
	for (p = sc->sc_dmas; p && p->addr != temp_buffer; p = p->next)
		;
	if (p == NULL) {
		printf("auich_calibrate: bad address %p\n", temp_buffer);
		return (ac97rate);
	}

	for (i = 0; i < AUICH_DMALIST_MAX; i++) {
		sc->dmalist_pcmi[i].base = p->map->dm_segs[0].ds_addr;
		sc->dmalist_pcmi[i].len = bytes / sc->sc_sample_size;
	}

	/*
	 * our data format is stereo, 16 bit so each sample is 4 bytes.
	 * assuming we get 48000 samples per second, we get 192000 bytes/sec.
	 * we're going to start recording with interrupts disabled and measure
	 * the time taken for one block to complete.  we know the block size,
	 * we know the time in microseconds, we calculate the sample rate:
	 *
	 * actual_rate [bps] = bytes / (time [s] * 4)
	 * actual_rate [bps] = (bytes * 1000000) / (time [us] * 4)
	 * actual_rate [Hz] = (bytes * 250000) / time [us]
	 */

	/* prepare */
	ociv = bus_space_read_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CIV);
	nciv = ociv;
	bus_space_write_4(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_BDBAR,
	    kvtop((caddr_t)sc->dmalist_pcmi));
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_LVI,
			  (0 - 1) & AUICH_LVI_MASK);

	/* start */
	microtime(&t1);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL,
	    AUICH_RPBM);

	/* wait */
	while (nciv == ociv) {
		microtime(&t2);
		if (t2.tv_sec - t1.tv_sec > 1)
			break;
		nciv = bus_space_read_1(sc->iot, sc->aud_ioh,
					AUICH_PCMI + AUICH_CIV);
	}
	microtime(&t2);

	/* reset */
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_PCMI + AUICH_CTRL, AUICH_RR);
	bus_space_write_1(sc->iot, sc->aud_ioh, AUICH_MICI + AUICH_CTRL, AUICH_RR);
	DELAY(100);

	/* turn time delta into us */
	wait_us = ((t2.tv_sec - t1.tv_sec) * 1000000) + t2.tv_usec - t1.tv_usec;

#if 0
	auich_freem(sc, temp_buffer, M_DEVBUF);
#endif

	if (nciv == ociv) {
		printf("%s: ac97 link rate calibration timed out after %d us\n",
		       sc->sc_dev.dv_xname, wait_us);
		return (ac97rate);
	}

	actual_48k_rate = (bytes * 250000) / wait_us;

	if (actual_48k_rate <= 48500)
		ac97rate = AUICH_FIXED_RATE;
	else
		ac97rate = actual_48k_rate;

	printf("%s: measured ac97 link rate at %d Hz",
	       sc->sc_dev.dv_xname, actual_48k_rate);
	if (ac97rate != actual_48k_rate)
		printf(", will use %d Hz", ac97rate);
	printf("\n");

	return (ac97rate);
@


1.8.4.11
log
@Merge with the trunk
@
text
@a55 9
/*
 * XXX > 4GB kaboom: define kvtop as a truncated vtophys.  Will not
 * do the right thing on machines with more than 4 gig of ram.
 */
#if defined(__amd64__)
#include <uvm/uvm_extern.h>	/* for vtophys */
#define kvtop(va)		(int)vtophys((vaddr_t)(va))
#endif

d406 1
a406 2
		} else {
			printf("%s: reset failed!\n", sc->sc_dev.dv_xname);
a407 1
		}
@


1.7
log
@differentiate fifo overrun errors
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.6 2001/01/11 21:40:05 mickey Exp $	*/
d374 1
a374 1
	printf(" %s: %s\n", intrstr, sc->sc_audev.name);
@


1.6
log
@fix a few strings
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.5 2001/01/11 19:22:33 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d33 1
a33 1
 * AC'97 audio found on Intel 810/820/440MX chipsets.
d913 1
a913 1
			printf("%s: fifo overrun # %u\n",
d962 1
a962 1
			printf("%s: fifo overrun\n", sc->sc_dev.dv_xname);
@


1.5
log
@rename the rest to auich, verbalize the chipset type we are a part of
@
text
@d1 1
a1 1
/*	$OpenBSD: auich.c,v 1.5 2001/01/11 18:52:52 deraadt dead $	*/
d212 1
a212 1
#define	AUICH_DEBUG_PARAM		0x0004
d234 3
a236 3
	{ PCI_PRODUCT_INTEL_82801AA_ACA, 0, "AUICH" },
	{ PCI_PRODUCT_INTEL_82801AB_ACA, 0, "AUICH0" },
	{ PCI_PRODUCT_INTEL_82801BA_ACA, 0, "AUICH2" },
d797 1
a797 1
			printf("auich_free: trying to free not allocated memory");
@


1.4
log
@likely to work on ich2 too; from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ich.c,v 1.3 2000/08/11 06:17:18 mickey Exp $	*/
d31 1
a31 1
/* #define	ICH_DEBUG */
d57 1
a57 1
#define	ICH_NAMBAR	0x10
d59 1
a59 1
#define	ICH_NABMBAR	0x14
d62 84
a145 84
#define	ICH_BDBAR	0x00	/* 8-byte aligned address */
#define	ICH_CIV		0x04	/* 5 bits current index value */
#define	ICH_LVI		0x05	/* 5 bits last valid index value */
#define		ICH_LVI_MASK	0x1f
#define	ICH_STS		0x06	/* 16 bits status */
#define		ICH_FIFOE	0x10	/* fifo error */
#define		ICH_BCIS	0x08	/* r- buf cmplt int sts; wr ack */
#define		ICH_LVBCI	0x04	/* r- last valid bci, wr ack */
#define		ICH_CELV	0x02	/* current equals last valid */
#define		ICH_DCH		0x01	/* dma halted */
#define		ICH_ISTS_BITS	"\020\01dch\02celv\03lvbci\04bcis\05fifoe"
#define	ICH_PICB	0x08	/* 16 bits */
#define	ICH_PIV		0x0a	/* 5 bits prefetched index value */
#define	ICH_CTRL	0x0b	/* control */
#define		ICH_IOCE	0x10	/* int on completion enable */
#define		ICH_FEIE	0x08	/* fifo error int enable */
#define		ICH_LVBIE	0x04	/* last valid buf int enable */
#define		ICH_RR		0x02	/* 1 - reset regs */
#define		ICH_RPBM	0x01	/* 1 - run, 0 - pause */

#define	ICH_PCMI	0x00
#define	ICH_PCMO	0x10
#define	ICH_MICI	0x20

#define	ICH_GCTRL	0x2c
#define		ICH_SRIE	0x20	/* int when 2ndary codec resume */
#define		ICH_PRIE	0x10	/* int when primary codec resume */
#define		ICH_ACLSO	0x08	/* aclink shut off */
#define		ICH_WRESET	0x04	/* warm reset */
#define		ICH_CRESET	0x02	/* cold reset */
#define		ICH_GIE		0x01	/* gpi int enable */
#define	ICH_GSTS	0x30
#define		ICH_MD3		0x20000	/* pwr-dn semaphore for modem */
#define		ICH_AD3		0x10000	/* pwr-dn semaphore for audio */
#define		ICH_RCS		0x08000	/* read completion status */
#define		ICH_B3S12	0x04000	/* bit 3 of slot 12 */
#define		ICH_B2S12	0x02000	/* bit 2 of slot 12 */
#define		ICH_B1S12	0x01000	/* bit 1 of slot 12 */
#define		ICH_SRI		0x00800	/* secondary resume int */
#define		ICH_PRI		0x00400	/* primary resume int */
#define		ICH_SCR		0x00200	/* secondary codec ready */
#define		ICH_PCR		0x00100	/* primary codec ready */
#define		ICH_MINT	0x00080	/* mic in int */
#define		ICH_POINT	0x00040	/* pcm out int */
#define		ICH_PIINT	0x00020	/* pcm in int */
#define		ICH_MOINT	0x00004	/* modem out int */
#define		ICH_MIINT	0x00002	/* modem in int */
#define		ICH_GSCI	0x00001	/* gpi status change */
#define		ICH_GSTS_BITS	"\020\01gsci\02miict\03moint\06piint\07point\010mint\011pcr\012scr\013pri\014sri\015b1s12\016b2s12\017b3s12\020rcs\021ad3\022md3"
#define	ICH_CAS		0x34	/* 1/8 bit */
#define	ICH_SEMATIMO	1000	/* us */

#define	ICH_MIXER_RESET		0x00
#define	ICH_MIXER_MUTE		0x02
#define	ICH_MIXER_HDFMUTE	0x04
#define	ICH_MIXER_MONOMUTE	0x06
#define	ICH_MIXER_TONE		0x08
#define	ICH_MIXER_BEEPMUTE	0x0a
#define	ICH_MIXER_PHONEMUTE	0x0c
#define	ICH_MIXER_MICMUTE	0x0e
#define	ICH_MIXER_LINEMUTE	0x10
#define	ICH_MIXER_CDMUTE	0x12
#define	ICH_MIXER_VDMUTE	0x14
#define	ICH_MIXER_AUXMUTE	0x16
#define	ICH_MIXER_PCMMUTE	0x18
#define	ICH_MIXER_RECSEL	0x1a
#define	ICH_MIXER_RECGAIN	0x1c
#define	ICH_MIXER_RECGAINMIC	0x1e
#define	ICH_MIXER_GP		0x20
#define	ICH_MIXER_3DCTRL	0x22
#define	ICH_MIXER_RESERVED	0x24
#define	ICH_PM			0x26
#define		ICH_PM_PCMI	0x100
#define		ICH_PM_PCMO	0x200
#define		ICH_PM_MICI	0x400
#define	ICH_EXTAUDIO		0x28
#define	ICH_EXTAUCTRL		0x2a
#define	ICH_PCMRATE		0x2c
#define	ICH_PCM3dRATE		0x2e
#define	ICH_PCMLFERATE		0x30
#define	ICH_PCMLRRATE		0x32
#define	ICH_MICADCRATE		0x34
#define	ICH_CLFEMUTE		0x36
#define	ICH_LR3DMUTE		0x38
d152 3
a154 3
#define	ICH_DMALIST_MAX	32
#define	ICH_DMASEG_MAX	(65536*2)	/* 64k samples, 2x16 bit samples */
struct ich_dmalist {
d157 2
a158 2
#define	ICH_DMAF_IOC	0x80000000	/* 1-int on complete */
#define	ICH_DMAF_BUP	0x40000000	/* 0-retrans last, 1-transmit 0 */
d161 1
a161 1
struct ich_dma {
d164 1
a164 1
	bus_dma_segment_t segs[ICH_DMALIST_MAX];
d167 1
a167 1
	struct ich_dma *next;
d170 1
a170 1
struct ich_softc {
d185 6
a190 6
	struct ich_dmalist *dmalist_pcmo, *dmap_pcmo,
	    dmasto_pcmo[ICH_DMALIST_MAX+1];
	struct ich_dmalist *dmalist_pcmi, *dmap_pcmi,
	    dmasto_pcmi[ICH_DMALIST_MAX+1];;
	struct ich_dmalist *dmalist_mici, *dmap_mici,
	    dmasto_mici[ICH_DMALIST_MAX+1];;
d198 1
a198 1
	struct ich_dma *sc_dmas;
d207 6
a212 6
#ifdef ICH_DEBUG
#define	DPRINTF(l,x)	do { if (ich_debug & (l)) printf x; } while(0)
int ich_debug = 0xfffe;
#define	ICH_DEBUG_CODECIO	0x0001
#define	ICH_DEBUG_DMA		0x0002
#define	ICH_DEBUG_PARAM		0x0004
d217 2
a218 2
struct cfdriver	ich_cd = {
	NULL, "ich", DV_DULL
d221 3
a223 3
int  ich_match __P((struct device *, void *, void *));
void ich_attach __P((struct device *, struct device *, void *));
int  ich_intr __P((void *));
d225 2
a226 2
struct cfattach ich_ca = {
	sizeof(struct ich_softc), ich_match, ich_attach
d229 1
a229 1
static const struct ich_devtype {
d232 6
a237 5
} ich_devices[] = {
	{ PCI_PRODUCT_INTEL_82801AA_ACA, 0 },
	{ PCI_PRODUCT_INTEL_82801AB_ACA, 0 },
	{ PCI_PRODUCT_INTEL_82801BA_ACA, 0 },
	{ PCI_PRODUCT_INTEL_82440MX_ACA, 0 },
d240 4
a243 4
int ich_open __P((void *, int));
void ich_close __P((void *));
int ich_query_encoding __P((void *, struct audio_encoding *));
int ich_set_params __P((void *, int, int, struct audio_params *,
d245 13
a257 13
int ich_round_blocksize __P((void *, int));
int ich_halt_output __P((void *));
int ich_halt_input __P((void *));
int ich_getdev __P((void *, struct audio_device *));
int ich_set_port __P((void *, mixer_ctrl_t *));
int ich_get_port __P((void *, mixer_ctrl_t *));
int ich_query_devinfo __P((void *, mixer_devinfo_t *));
void *ich_allocm __P((void *, u_long, int, int));
void ich_freem __P((void *, void *, int));
u_long ich_round_buffersize __P((void *, u_long));
int ich_mappage __P((void *, void *, int, int));
int ich_get_props __P((void *));
int ich_trigger_output __P((void *, void *, void *, int, void (*)(void *),
d259 1
a259 1
int ich_trigger_input __P((void *, void *, void *, int, void (*)(void *),
d262 3
a264 3
struct audio_hw_if ich_hw_if = {
	ich_open,
	ich_close,
d266 3
a268 3
	ich_query_encoding,
	ich_set_params,
	ich_round_blocksize,
d274 2
a275 2
	ich_halt_output,
	ich_halt_input,
d277 1
a277 1
	ich_getdev,
d279 10
a288 10
	ich_set_port,
	ich_get_port,
	ich_query_devinfo,
	ich_allocm,
	ich_freem,
	ich_round_buffersize,
	ich_mappage,
	ich_get_props,
	ich_trigger_output,
	ich_trigger_input
d291 4
a294 4
int  ich_attach_codec __P((void *, struct ac97_codec_if *));
int  ich_read_codec __P((void *, u_int8_t, u_int16_t *));
int  ich_write_codec __P((void *, u_int8_t, u_int16_t));
void ich_reset_codec __P((void *));
d297 1
a297 1
ich_match(parent, match, aux)
d308 2
a309 2
	for (i = sizeof(ich_devices)/sizeof(ich_devices[0]); i--;)
		if (PCI_PRODUCT(pa->pa_id) == ich_devices[i].product)
d316 1
a316 1
ich_attach(parent, self, aux)
d320 1
a320 1
	struct ich_softc *sc = (struct ich_softc *)self;
d326 1
d328 1
a328 1
	if (pci_mapreg_map(pa, ICH_NAMBAR, PCI_MAPREG_TYPE_IO, 0,
d333 1
a333 1
	if (pci_mapreg_map(pa, ICH_NABMBAR, PCI_MAPREG_TYPE_IO, 0,
d354 1
a354 1
	sc->sc_ih = pci_intr_establish(pa->pa_pc, ih, IPL_AUDIO, ich_intr, sc,
d366 2
a367 3
#ifdef notused
	for (i = sizeof(ich_devices)/sizeof(ich_devices[0]); i--;)
		if (PCI_PRODUCT(pa->pa_id) == ich_devices[i].product)
a368 1
#endif
d370 1
a370 1
	strcpy(sc->sc_audev.name, "ICH0 AC97");
d382 1
a382 1
	DPRINTF(ICH_DEBUG_DMA, ("ich_attach: lists %p %p %p\n",
d386 1
a386 1
	ich_reset_codec(sc);
d389 4
a392 4
	sc->host_if.attach = ich_attach_codec;
	sc->host_if.read = ich_read_codec;
	sc->host_if.write = ich_write_codec;
	sc->host_if.reset = ich_reset_codec;
d401 1
a401 1
	audio_attach_mi(&ich_hw_if, sc, &sc->sc_dev);
d405 1
a405 1
ich_read_codec(v, reg, val)
d410 1
a410 1
	struct ich_softc *sc = v;
d414 2
a415 2
	for (i = ICH_SEMATIMO; i-- &&
	    bus_space_read_1(sc->iot, sc->aud_ioh, ICH_CAS) & 1; DELAY(1));
d419 2
a420 2
		DPRINTF(ICH_DEBUG_CODECIO,
		    ("ich_read_codec(%x, %x)\n", reg, *val));
d424 1
a424 1
		DPRINTF(ICH_DEBUG_CODECIO,
d431 1
a431 1
ich_write_codec(v, reg, val)
d436 1
a436 1
	struct ich_softc *sc = v;
d439 1
a439 1
	DPRINTF(ICH_DEBUG_CODECIO, ("ich_write_codec(%x, %x)\n", reg, val));
d442 2
a443 2
	for (i = ICH_SEMATIMO; i-- &&
	    bus_space_read_1(sc->iot, sc->aud_ioh, ICH_CAS) & 1; DELAY(1));
d449 1
a449 1
		DPRINTF(ICH_DEBUG_CODECIO,
d456 1
a456 1
ich_attach_codec(v, cif)
d460 1
a460 1
	struct ich_softc *sc = v;
d467 1
a467 1
ich_reset_codec(v)
d470 2
a471 2
	struct ich_softc *sc = v;
	bus_space_write_4(sc->iot, sc->aud_ioh, ICH_GCTRL, 0);
d473 1
a473 1
	bus_space_write_4(sc->iot, sc->aud_ioh, ICH_GCTRL, ICH_CRESET);
d477 1
a477 1
ich_open(v, flags)
d485 1
a485 1
ich_close(v)
d491 1
a491 1
ich_query_encoding(v, aep)
d550 1
a550 1
ich_set_params(v, setmode, usemode, play, rec)
d555 1
a555 1
	struct ich_softc *sc = v;
d592 2
a593 2
		ich_read_codec(sc, ICH_PM, &val);
		ich_write_codec(sc, ICH_PM, val | ICH_PM_PCMO);
d595 2
a596 2
		ich_write_codec(sc, ICH_PCMRATE, play->sample_rate);
		ich_read_codec(sc, ICH_PCMRATE, &rate);
d599 1
a599 1
		ich_write_codec(sc, ICH_PM, val);
d634 2
a635 2
		ich_read_codec(sc, ICH_PM, &val);
		ich_write_codec(sc, ICH_PM, val | ICH_PM_PCMI);
d637 2
a638 2
		ich_write_codec(sc, ICH_PCMLFERATE, play->sample_rate);
		ich_read_codec(sc, ICH_PCMLFERATE, &rate);
d641 1
a641 1
		ich_write_codec(sc, ICH_PM, val);
d648 1
a648 1
ich_round_blocksize(v, blk)
d656 1
a656 1
ich_halt_output(v)
d659 1
a659 1
	struct ich_softc *sc = v;
d661 1
a661 1
	DPRINTF(ICH_DEBUG_DMA, ("%s: halt_output\n", sc->sc_dev.dv_xname));
d663 1
a663 1
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_CTRL, ICH_RR);
d669 1
a669 1
ich_halt_input(v)
d672 1
a672 1
	struct ich_softc *sc = v;
d674 1
a674 1
	DPRINTF(ICH_DEBUG_DMA,
d679 2
a680 2
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_CTRL, ICH_RR);
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_MICI + ICH_CTRL, ICH_RR);
d686 1
a686 1
ich_getdev(v, adp)
d690 1
a690 1
	struct ich_softc *sc = v;
d696 1
a696 1
ich_set_port(v, cp)
d700 1
a700 1
	struct ich_softc *sc = v;
d705 1
a705 1
ich_get_port(v, cp)
d709 1
a709 1
	struct ich_softc *sc = v;
d714 1
a714 1
ich_query_devinfo(v, dp)
d718 1
a718 1
	struct ich_softc *sc = v;
d723 1
a723 1
ich_allocm(v, size, pool, flags)
d728 2
a729 2
	struct ich_softc *sc = v;
	struct ich_dma *p;
d732 1
a732 1
	if (size > ICH_DMALIST_MAX * ICH_DMASEG_MAX)
d787 1
a787 1
ich_freem(v, ptr, pool)
d792 2
a793 2
	struct ich_softc *sc = v;
	struct ich_dma *p;
d797 1
a797 1
			printf("ich_free: trying to free not allocated memory");
d809 1
a809 1
ich_round_buffersize(v, size)
d813 2
a814 2
	if (size > ICH_DMALIST_MAX * ICH_DMASEG_MAX)
		size = ICH_DMALIST_MAX * ICH_DMASEG_MAX;
d820 1
a820 1
ich_mappage(v, mem, off, prot)
d826 2
a827 2
	struct ich_softc *sc = v;
	struct ich_dma *p;
d841 1
a841 1
ich_get_props(v)
d848 1
a848 1
ich_intr(v)
d851 1
a851 1
	struct ich_softc *sc = v;
d854 2
a855 2
	gsts = bus_space_read_2(sc->iot, sc->aud_ioh, ICH_GSTS);
	DPRINTF(ICH_DEBUG_DMA, ("ich_intr: gsts=%b\n", gsts, ICH_GSTS_BITS));
d857 4
a860 4
	if (gsts & ICH_POINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, ICH_PCMO+ICH_STS);
		DPRINTF(ICH_DEBUG_DMA,
		    ("ich_intr: osts=%b\n", sts, ICH_ISTS_BITS));
d862 1
a862 1
		if (sts & ICH_FIFOE) {
d867 3
a869 3
		i = bus_space_read_1(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_CIV);
		if (sts & (ICH_LVBCI | ICH_CELV)) {
			struct ich_dmalist *q, *qe;
d877 3
a879 3
				q->len = (sc->pcmo_blksize / 2) | ICH_DMAF_IOC;
				DPRINTF(ICH_DEBUG_DMA,
				    ("ich_intr: %p, %p = %x @@ %p\n",
d886 1
a886 1
				if (++q == &sc->dmalist_pcmo[ICH_DMALIST_MAX])
d892 1
a892 1
			    ICH_PCMO + ICH_LVI,
d894 1
a894 1
			    ICH_LVI_MASK);
d897 1
a897 1
		if (sts & ICH_BCIS && sc->sc_pintr)
d901 3
a903 3
		bus_space_write_2(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_STS,
		    sts & (ICH_LVBCI | ICH_CELV | ICH_BCIS | ICH_FIFOE));
		bus_space_write_2(sc->iot, sc->aud_ioh, ICH_GSTS, ICH_POINT);
d907 4
a910 4
	if (gsts & ICH_PIINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, ICH_PCMI+ICH_STS);
		DPRINTF(ICH_DEBUG_DMA,
		    ("ich_intr: ists=%b\n", sts, ICH_ISTS_BITS));
d912 1
a912 1
		if (sts & ICH_FIFOE) {
d917 3
a919 3
		i = bus_space_read_1(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_CIV);
		if (sts & (ICH_LVBCI | ICH_CELV)) {
			struct ich_dmalist *q, *qe;
d927 3
a929 3
				q->len = (sc->pcmi_blksize / 2) | ICH_DMAF_IOC;
				DPRINTF(ICH_DEBUG_DMA,
				    ("ich_intr: %p, %p = %x @@ %p\n",
d936 1
a936 1
				if (++q == &sc->dmalist_pcmi[ICH_DMALIST_MAX])
d942 1
a942 1
			    ICH_PCMI + ICH_LVI,
d944 1
a944 1
			    ICH_LVI_MASK);
d947 1
a947 1
		if (sts & ICH_BCIS && sc->sc_rintr)
d951 3
a953 3
		bus_space_write_2(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_STS,
		    sts & (ICH_LVBCI | ICH_CELV | ICH_BCIS | ICH_FIFOE));
		bus_space_write_2(sc->iot, sc->aud_ioh, ICH_GSTS, ICH_POINT);
d957 5
a961 5
	if (gsts & ICH_MIINT) {
		sts = bus_space_read_2(sc->iot, sc->aud_ioh, ICH_MICI+ICH_STS);
		DPRINTF(ICH_DEBUG_DMA,
		    ("ich_intr: ists=%b\n", sts, ICH_ISTS_BITS));
		if (sts & ICH_FIFOE)
d966 1
a966 1
		bus_space_write_2(sc->iot, sc->aud_ioh, ICH_GSTS, ICH_MIINT);
d973 1
a973 1
ich_trigger_output(v, start, end, blksize, intr, arg, param)
d981 2
a982 2
	struct ich_softc *sc = v;
	struct ich_dmalist *q;
d984 2
a985 2
	DPRINTF(ICH_DEBUG_DMA,
	    ("ich_trigger_output(%x, %x, %d, %p, %p, %p)\n",
d991 1
a991 1
	struct ich_dma *p;
d1012 2
a1013 2
	q->len = (blksize / 2) | ICH_DMAF_IOC;
	if (++q == &sc->dmalist_pcmo[ICH_DMALIST_MAX])
d1017 1
a1017 1
	bus_space_write_4(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_BDBAR,
d1019 4
a1022 4
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_CTRL,
	    ICH_IOCE | ICH_FEIE | ICH_LVBIE | ICH_RPBM);
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMO + ICH_LVI,
	    (sc->dmap_pcmo - 1 - sc->dmalist_pcmo) & ICH_LVI_MASK);
d1028 1
a1028 1
ich_trigger_input(v, start, end, blksize, intr, arg, param)
d1036 2
a1037 2
	struct ich_softc *sc = v;
	struct ich_dmalist *q;
d1039 2
a1040 2
	DPRINTF(ICH_DEBUG_DMA,
	    ("ich_trigger_input(%x, %x, %d, %p, %p, %p)\n",
d1046 1
a1046 1
	struct ich_dma *p;
d1067 2
a1068 2
	q->len = (blksize / 2) | ICH_DMAF_IOC;
	if (++q == &sc->dmalist_pcmi[ICH_DMALIST_MAX])
d1072 1
a1072 1
	bus_space_write_4(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_BDBAR,
d1074 4
a1077 4
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_CTRL,
	    ICH_IOCE | ICH_FEIE | ICH_LVBIE | ICH_RPBM);
	bus_space_write_1(sc->iot, sc->aud_ioh, ICH_PCMI + ICH_LVI,
	    (sc->dmap_pcmi - 1 - sc->dmalist_pcmi) & ICH_LVI_MASK);
@


1.3
log
@provide generic audio device name
@
text
@d1 1
a1 1
/*	$OpenBSD: ich.c,v 1.2 2000/07/18 21:33:11 mickey Exp $	*/
d235 1
@


1.2
log
@better error messages for mapreg
@
text
@d1 1
a1 1
/*	$OpenBSD: ich.c,v 1.1 2000/05/30 16:30:38 mickey Exp $	*/
d15 2
d184 1
a184 1
	/* dma scatter-gather buffer lists */
a229 1
	char	name[MAX_AUDIO_DEV_LEN];
d233 3
a235 3
	{ "i82801AA",	PCI_PRODUCT_INTEL_82801AA_ACA, 0 },
	{ "i82801AB",	PCI_PRODUCT_INTEL_82801AB_ACA, 0 },
	{ "440MX",	PCI_PRODUCT_INTEL_82440MX_ACA, 0 },
a323 1
	int i;
d363 1
d367 1
d369 2
a370 1
	strcpy(sc->sc_audev.name, ich_devices[i].name);
d394 1
a396 1
		pci_intr_disestablish(pa->pa_pc, sc->sc_ih);
@


1.1
log
@audio driver for intel 810/820/440MX i/o controller hub ac'97 .
820 and 440MX are untested, but should work.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d327 1
a327 1
		printf(": can't map i/o space\n");
d332 1
a332 1
		printf(": can't map i/o space\n");
@

